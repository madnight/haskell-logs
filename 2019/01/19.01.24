00:01:05 <dminuoso> v0d1ch Here's a couple of "standard store functions" you might want to implement. https://gist.github.com/dminuoso/ac6d72cf8d83d96b84ecdc23ed44cae2 -> try them out to get a feeling for them, and then implement the entire Comonad instance using those utility functions.
00:01:17 <jle`> again, this is just because this is how <> is defined for Maybe
00:01:38 <dminuoso> v0d1ch: Also note that the last utility function `experiment` is included for completeness and will play a really interesting role in the next excercise. :)
00:03:35 <ski> dminuoso : s/w/Store s/,s/ Source#// ?
00:03:41 <v0d1ch> dminuoso: niiice, thanks!
00:03:48 <dminuoso> ski: Oi! Thank you
00:04:09 <ar1a> jle`: mind if i pm you?
00:04:17 <dminuoso> ski: I just copy pasted the MonadStore interface and specialized it, didn't notice the mishap. :)
00:04:24 <dminuoso> v0d1ch: Be sure to update my gist.
00:04:48 <v0d1ch> will do
00:05:02 <ski> dminuoso, that's what i surmised :)
00:05:32 <dminuoso> Haven't seen you in a while, what have you been up to ski?
00:06:15 <ski> had an irc break
00:08:17 <jle`> ar1a: i might not answer too quickly, but sure
00:08:44 <ar1a> ah don't worry, i figured it out. haskell is like maths! i could do (fizz <> buzz) n instead of fizz n <> buzz n
00:09:07 <ar1a> kind of like compose with concat :O
00:09:45 <dminuoso> ar1a: And if you eta reduce, you don't even need the `n`
00:09:52 <dminuoso> ar1a: so you can truly do: fizzbuzz = fizz <> buzz
00:10:02 <ar1a> not with fromMaybe apparently
00:10:12 <ar1a> i tried to do fizzbuzz = fromMaybe show (fizz <> buzz) but it didn't like it
00:10:21 <ar1a> and hlint isn't telling me i can eta reduce either
00:10:54 <dminuoso> Maybe I was looking at old code then.
00:11:09 <ar1a> yeah, let me paste my solution! im quite proud of it, i learnt so much from such a basic thing
00:11:16 <ar1a> ^ story of my entire haskell experience
00:11:30 <ar1a> https://ptpb.pw/e8c1/haskell
00:15:24 <ar1a> dminuoso: 
00:36:00 * hackage mysql-haskell 0.8.4.2 - pure haskell MySQL driver  https://hackage.haskell.org/package/mysql-haskell-0.8.4.2 (winterland)
00:50:12 <merijn> oh god, some masochist implemented a type level red-black tree? o.O
00:51:01 <Ariakenom> All hail our new overlord?
00:51:51 <merijn> I'm not sure I wanna be ruled by someone who enjoys pain that much :)
00:51:55 <jle`> ar1a: modStr n str input = str <$ guard (input `mod` n == 0)
00:52:26 <merijn> jle`: FizzBuzz? :p
00:52:46 <hc> lol
00:52:54 <hc> merijn: got a link to that one?
00:53:15 <merijn> hc: No, I was just guessing that was used in FizzBuzz, seemed plausible based on what it does
00:53:19 <ar1a> jle`: can you explain what that does
00:53:26 <merijn> hc: Although I did already permanently solve FizzBuzz for Haskellers
00:53:38 <jle`> guard True = Just ()
00:53:40 <merijn> hc: Behold, the most general FizzBuzz implementation ever: https://gist.github.com/merijn/cd0e7918a96fe913cf7d66833e8da354
00:53:42 <jle`> guard False = Nothing
00:53:57 <jle`> ar1a: and <$ "replaces" the value in a Just
00:54:01 <jle`> > "hello" <$ Just ()
00:54:04 <lambdabot>  Just "hello"
00:54:10 <jle`> and leaves Nothings as Nothings
00:54:14 <jle`> > "hello" <$ Nothing
00:54:16 <lambdabot>  Nothing
00:54:22 <MarcelineVQ> merijn: list? :>
00:54:26 <merijn> hc: It takes the idea in jle`'s snippet of code to it's logical extreme :p
00:54:51 <jle`> balanced RB tries is actually one of the examples that got me into dependently typed code, lol
00:54:55 <merijn> MarcelineVQ: Ah, fair enough. I suppose I could technically generalise it further to any Foldable
00:54:55 <jle`> ever since i saw a talk on it
00:55:11 <merijn> jle`: No, this announcement was not on a type checked red black tree
00:55:19 <merijn> jle`: It was "a red black tree, at the type level"
00:55:20 <jle`> oh, it's a *type-level* RB tree?
00:55:30 <merijn> jle`: Yes, that's an entire new level of insane
00:55:31 <jle`> now i'm feeling many different emotions.
00:55:39 <jle`> well, is it a type-safe type-level RB tree?
00:55:53 <Ariakenom> obligatory https://aphyr.com/posts/342-typing-the-technical-interview
00:55:56 <merijn> jle`: Dunno, it's too early in the morning to open a link like that :)
00:56:10 <merijn> Ariakenom: That post is a work of art :)
00:56:20 <jle`> ar1a: i'd take some inspiration from merijn and define `divides n m = n `mod` m == 0`
00:56:43 <Ariakenom> jle`: no because “Haskell is a dynamically-typed, interpreted language.”
00:56:44 <jle`> ar1a: and then you can write `fizz n = "Fizz" <$ guard (divides m 5)
00:56:54 <Ariakenom> wrt type-safe type-level
00:57:06 <MarcelineVQ> jle`: http://hackage.haskell.org/package/red-black-record-1.1.0.0
00:57:10 <jle`> well now that we have singletons of GADT's ....
00:57:18 <jle`> and we can promote GADT's to the type level ...
00:57:42 <jle`> hm. i like this.
00:57:49 <jle`> i always wanted a type-level Map
00:58:03 <jle`> i just always thought that it would be easier to implement it natively (as a part of ghc)
00:58:06 <merijn> MarcelineVQ: Happy now? https://gist.github.com/merijn/cd0e7918a96fe913cf7d66833e8da354 :)
00:58:24 <merijn> MarcelineVQ: Now I think it really can't get any more general
00:59:31 * jle` . o ( forM_ xs f == mapM_ f xs )
00:59:47 <merijn> jle`: Then I need more parenthesis!
01:00:25 <jle`> i still haven't gotten used to using traverse_ instead of mapM_ yet
01:01:29 <jle`> ar1a: don't worry about using guard, it's just a personal style of mine, and a lot of people just write it out like you did
01:07:59 <mniip> dminuoso, less concretely
01:08:24 <mniip> I meant  Dict (Show a) to be a literal record for the (Show a) instance
01:09:15 <mniip> data instance Dict (Show a) = ShowDict { showsPrec :: Int -> a -> ShowS; showList :: [a] -> ShowS }
01:09:34 <mniip> if you know data families
01:37:34 <gentauro> is there a way to make this any faster (I'm trying to make a tiny Haskell app that can generate bytes based on input)
01:37:39 <gentauro> http://dpaste.com/3XFG28T
01:38:07 <gentauro> https://imgur.com/a/FQU3KML (profiling ... 16 seconds to generate a 200 MB file sounds "slow")
01:43:58 <Ariakenom> gentauro: you can try replacing read
01:44:37 <Ariakenom> oh wait that's small, right? 
01:45:43 <Ariakenom> profiling is the right way to solve performance issues
01:47:18 <Taneb> gentauro: one small thing is using BL.repeat to define zeros, it does things slightly more cleverly with chunks
01:48:16 <Ariakenom> Let's see if it was a "small thing" :)
01:49:25 <Taneb> Looking at how zeros is being used, replacing (flip BL.take) zeros with flip BL.replicate 0 might be even better
01:56:28 <janat08> why do you have to declare new type for stuff like transformers/state
01:57:19 <janat08> I assume to define new accessor function, but what is the point of acessor function then
01:57:38 <tdammers> the main reason is so that you can define typeclass instances
01:58:21 <tdammers> without the newtype wrapper, defining, say, a Monad instance for a typical monad transformer, becomes rather tricky
01:58:41 <gentauro> Taneb: `flip BL.replicate 0` works way faster :o
02:00:34 <cocreature> removing the conversion to string in favor of bytestring’s readInt might also be worth a try
02:00:46 <gentauro> even tough `cons` is O(1) done `n` times and `replicate` is O(n) ...
02:01:02 <cocreature> and I’d probably also remove interact, it doesn’t buy you much here
02:01:41 <Taneb> gentauro: the repeated cons is done n times, the replicate does about n/1000 work
02:01:46 <gentauro> cocreature: both `read` and `interact` are not what dominates. The big operation here is the many bytes (which `replicate` seem to outperform `cons`)
02:01:49 <gentauro> by far
02:01:58 <gentauro> (I can't even generate a profiling picture anymore)
02:02:24 <Taneb> gentauro: reading the source of BL.replicate might be an interesting learning experience for you! :)
02:03:22 <gentauro> Taneb: for sure
02:04:35 <gentauro> Taneb: `| otherwise          = Chunk (S.unsafeTake (fromIntegral r) c) cs` gotcha ;)
02:05:24 <gentauro> I'm guessing `S.unsafeTake` does stuff `under the hood` which "pure Haskell" can't outperform, even though having the same asymptotic time complexity ...
02:05:42 <Taneb> gentauro: it's the definition of cs that's most interesting (and of nChunks)
02:05:46 <cocreature> I wouldn’t be so sure that interact doesn’t make a difference. I could imagine that GHC might be able to fuse away the lazy bytestring list in BL.putStr $ BL.replicate … but might not be able to do the same with interact
02:06:41 <Taneb> cocreature: interact is just "putStr . f =<< getContents", there's not going to be much difference there
02:07:03 <cocreature> hm yeah I guess
02:07:22 <Taneb> gentauro: so replicate is essentially doing what you're doing, but instead of value-wise, it's doing it a whole chunk of about 1000 values at a time
02:07:57 <gentauro> Taneb: so we are back to Okasaki? :)
02:08:40 <Taneb> gentauro: a lazy bytestring is more or less a list of small arrays
02:09:33 <gentauro> Taneb: yes, and in my case, it was a lazy list of very very small lists (of only 1 element)
02:09:43 <Taneb> Yeah :)
02:09:54 <Taneb> "replicate" gets you maximal sharing, too
02:10:22 <gentauro> Okasaki in his famours "purely functional data structures" show how to "think" when desinging algorithms like this ;)
02:11:10 <Taneb> Reading PFDS is good :)
02:11:17 <gentauro> reminds me that I need to look back and try to finish the implementation my InmutableArraysLog32 :D
02:12:50 <Taneb> Also, remember that asymptotics aren't everything! Last week I designed an O(log(log n)) algorithm that only overtakes the naive algorithm at n = ~ 25 octillion
02:13:05 <Taneb> (according to my back of the envelope calculation)
02:13:52 <__monty__> Thinking intergalactic scale I see? : )
02:14:08 <cocreature> I prefer to believe that you’ve actually run it on n = ~ 25 octillion :)
02:15:08 <gentauro> Taneb: I know "Efficient algorithms and data structures on multi-core computers" => Master's Thesis ;)
02:15:29 <Taneb> gentauro: :D could you send me a PDF of that? It sounds interesting?
02:15:30 <merijn> gentauro: I'd wager unsafeTake just skips bounds checking
02:15:32 <delYsid> In the context of typed lambda calculus, what does Pi mean?
02:15:51 <merijn> delYsid: In the context of simply typed lambda calculus, it means nothing :p
02:16:02 <merijn> delYsid: Pi types are a thing in dependently typed calculi
02:16:53 <utdemir[m]> If I have a `Pipe Foo Bar (ST s) ()`, is there a way to convert it to `Pipe Foo Bar IO ()` or `Monad m => Pipe Foo Bar m ()` using `runST`?
02:17:11 <merijn> utdemir[m]: You'd probably have to first tell us what Pipe is and where it's from :)
02:18:04 <gentauro> merijn: so that's why Irdirs REPL is like `∏>` ;)
02:18:43 <utdemir[m]> merjin, oh sorry, it's from the `pipes` package, defined as type `data Proxy a' a b' b m r
02:18:44 <utdemir[m]> ; type Pipe a b = Proxy () a () b`.
02:19:55 <delYsid> merijn: OK, thanks.  And what does it mean in DTLC?  In particular, I am trying to understand how do implment custom type "parsers" for Dhall, and looking at some sample code, I dont get what Pi would do.
02:20:25 <merijn> utdemir[m]: Anyway, there's a stToIO function in Control.Monad.ST, that combined with one of the functions from the mmorph package should work
02:20:34 <Taneb> utdemir[m]: I've not really used pipes, but could you use hoist from the MFunctor class?
02:20:42 <merijn> delYsid: Pi is -> for dependent functions
02:20:58 <merijn> delYsid: i.e. the -> in "Int -> Bool" is specialisation of Pi
02:21:29 <merijn> delYsid: Have you read the Henk paper?
02:22:10 <delYsid> merijn: no, I haven't.
02:22:12 <merijn> delYsid: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.50.7152&rep=rep1&type=pdf
02:22:16 <utdemir[m]> merjin, Taneb: Thank you very much, I never checked mmorph package before, now I'll check it out. Thanks again.
02:22:22 <merijn> delYsid: It's what Tekmo based dhall on :)
02:22:41 <merijn> delYsid: It's fairly readable and should explain Pi and co in more details
02:25:18 <delYsid> thanks!"
02:27:23 <dminuoso> mniip: data families appear to be "open GADTs" so to speak, is this assessment right?
02:27:56 <mniip> questionable
02:27:58 <mniip> more no than yes
02:29:12 <dminuoso> Mmm, because you dont have the type equality proof embedded for type refinement/pattern matching?
02:32:08 <dminuoso> Then perhaps they are closed to type families that map types to anonymous ADTs.
02:32:15 <dminuoso> *closer
02:32:31 <dminuoso> Or, in your case, constraints. Though I reckon you used it as a pseudo-syntax.
02:45:59 * hackage HasCacBDD 0.1.0.1 - Haskell bindings for CacBDD  https://hackage.haskell.org/package/HasCacBDD-0.1.0.1 (m4lvin)
03:00:24 <mniip> dminuoso, they are exactly that
03:00:31 <mniip> in the implementation as well
03:07:44 <zhamar> @help unmtl
03:07:45 <lambdabot> unroll mtl monads
03:08:09 <zhamar> @unmtl State s a
03:08:09 <lambdabot> s -> (a, s)
03:08:46 <zhamar> @unmtl StateT s Maybe a
03:08:47 <lambdabot> s -> Maybe (a, s)
03:09:47 <zhamar> @unmtl MaybeT State s a
03:09:47 <lambdabot> Maybe s -> (a, Maybe s)
03:10:42 <zhamar> @unmtl MaybeT State s
03:10:43 <lambdabot> Plugin `unmtl' failed with: `State (Maybe s)' is not applied to enough arguments, giving `/\A. Maybe s -> (A, Maybe s)'
03:11:05 <zhamar> @unmtl MaybeT (State s) a
03:11:05 <lambdabot> s -> (Maybe a, s)
03:12:23 <zhamar> @unmtl State s IO
03:12:24 <lambdabot> s -> (IO, s)
03:13:07 <zhamar> @unmtl StateT s IO
03:13:08 <lambdabot> Plugin `unmtl' failed with: `StateT s IO' is not applied to enough arguments, giving `/\A. s -> IO (A, s)'
03:13:33 <zhamar> @unmtl MaybeT (State IO) a
03:13:34 <lambdabot> IO -> (Maybe a, IO)
03:14:30 <zhamar> @unmtl MaybeT (StateT IO) a
03:14:30 <lambdabot> Plugin `unmtl' failed with: `StateT IO (Maybe a)' is not applied to enough arguments, giving `/\A. IO -> Maybe a (A, IO)'
03:15:45 <Taneb> @unmtl MaybeT (State Int IO) a
03:15:46 <lambdabot> Plugin `unmtl' failed with: `Int -> (IO, Int)' is not a type function.
03:15:51 <Taneb> @unmtl MaybeT (StateT Int IO) a
03:15:51 <lambdabot> Int -> IO (Maybe a, Int)
03:17:50 <zhamar> @unmtl RWS
03:17:50 <lambdabot> Plugin `unmtl' failed with: `RWS' is not applied to enough arguments, giving `/\A B C D. A -> C -> (D, C, B)'
03:18:18 <Taneb> zhamar: you have to fully saturate it
03:18:22 <zhamar> @unmtl State
03:18:23 <lambdabot> Plugin `unmtl' failed with: `State' is not applied to enough arguments, giving `/\A B. A -> (B, A)'
03:18:26 <zhamar> @unmtl State s a
03:18:27 <lambdabot> s -> (a, s)
03:18:36 <zhamar> @ty State
03:18:37 <lambdabot> error:
03:18:37 <lambdabot>     • Data constructor not in scope: State
03:18:37 <lambdabot>     • Perhaps you meant one of these:
03:18:42 <zhamar> @ty State s
03:18:44 <lambdabot> error:
03:18:44 <lambdabot>     • Data constructor not in scope: State :: Expr -> t
03:18:44 <lambdabot>     • Perhaps you meant one of these:
03:19:10 <zhamar> @unmtl RWS r w s
03:19:10 <lambdabot> Plugin `unmtl' failed with: `RWS r w s' is not applied to enough arguments, giving `/\A. r -> s -> (A, s, w)'
03:19:21 <zhamar> @unmtl RWS r w s a
03:19:21 <lambdabot> r -> s -> (a, s, w)
03:20:37 <zhamar> @unmtl MaybeT (State s) a
03:20:37 <lambdabot> s -> (Maybe a, s)
03:20:52 <zhamar> @unmtl MaybeT (Reader r) a
03:20:52 <lambdabot> r -> Maybe a
03:21:04 <zhamar> @unmtl WriterT (Reader r) a
03:21:04 <lambdabot> Plugin `unmtl' failed with: `WriterT (Reader r) a' is not applied to enough arguments, giving `/\A. a (A, Reader r)'
03:21:28 <zhamar> @unmtl WriterT (Reader r) w a
03:21:29 <lambdabot> w (a, Reader r)
03:22:04 <zhamar> @unmtl StateT (WriterT (Reader r) w) a
03:22:04 <lambdabot> Plugin `unmtl' failed with: `StateT (WriterT (Reader r) w) a' is not applied to enough arguments.
03:22:13 <zhamar> @unmtl StateT (WriterT (Reader r) w)  s a
03:22:13 <lambdabot> Plugin `unmtl' failed with: `WriterT (Reader r) w' is not applied to enough arguments, giving `/\A. w (A, Reader r)'
03:22:28 <zhamar> @unmtl StateT (WriterT (Reader r) w a)  s
03:22:28 <lambdabot> Plugin `unmtl' failed with: `StateT (w (a, Reader r)) s' is not applied to enough arguments, giving `/\A. w (a, Reader r) -> s (A, w (a, Reader r))'
03:22:39 <zhamar> @unmtl StateT (WriterT (Reader r) w a)  s b
03:22:39 <lambdabot> w (a, Reader r) -> s (b, w (a, Reader r))
03:23:37 <zhamar> @unmtl StateT (WriterT (Reader r) w a)  s a
03:23:37 <lambdabot> w (a, Reader r) -> s (a, w (a, Reader r))
03:24:05 <zhamar> @t WriterT
03:24:05 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
03:24:17 <zhamar> @ty WriterT
03:24:19 <lambdabot> m (a, w) -> WriterT w m a
03:24:50 <zhamar> @unmtl StateT (WriterT w (Reader r) a)  s a
03:24:50 <lambdabot> (r -> (a, w)) -> s (a, r -> (a, w))
03:24:51 <Taneb> zhamar: did you know that lambdabot also works by private message?
03:25:28 <zhamar> @help
03:25:28 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:25:46 <zhamar> vlist
03:25:51 <zhamar> @list
03:25:52 <lambdabot> What module?  Try @listmodules for some ideas.
03:39:55 <dminuoso> mniip: What is the reason that liftShowsPrec also takes some `[a] -> ShowS` argument? It seems redundant, or is this in case a more efficient showList exists in the unlifted instance?
04:00:51 <lyxia> you need a special case for a = Char
04:07:19 <mniip> dminuoso, showList
04:07:26 <mniip> yeah
04:07:31 <mniip> that's the thing used to show strings
04:07:59 <dminuoso> Ah, I guess this would be useful if I wanted to lift `String` into `f String` for some choice of f.
04:08:09 <dminuoso> Well, the Show instance I mean.
04:08:41 <dminuoso> It seems a bit weird that this one special case has an impact on the general interface of Show1. :S
04:09:50 <gwosix> alright...
04:09:58 <gwosix> so i've installed cabal
04:10:27 <gwosix> because using gentoo's stack tells me it doesn't like "ncurses6"
04:11:25 <gwosix> wot
04:12:21 <gwosix> can someone help? i and a few others have this problem...
04:12:37 <gwosix> "No setup information found for ghc-8.6.3 on your platform."
04:13:23 <__monty__> gwosix: Do you have GHC installed? Maybe cabal can't find stack-installed GHCs by default.
04:13:46 <__monty__> You probably just need GHC 8.6.3 on your PATH.
04:13:58 <gwosix> no that's stack's error message
04:14:13 <gwosix> (and cabal's ebuild just installed stack lol)
04:14:31 <gwosix> stack doesn't seem to install ghc...
04:14:48 <gwosix> __monty__: is it not supposed to?
04:16:04 <__monty__> Cabal doesn't install stack afaik, unless you tell it to.
04:16:27 <__monty__> What I know of stack tells me that, yes, it *is* supposed to install ghc for you.
04:17:09 <gwosix> i wanted to make cabal install stack since the version of stack handed to me by my package manager doesn't "do the thing"
04:17:44 <gwosix> but i don't think anyone else seems to have this problem apart of my friends that don't know how to fix the problem either
04:21:03 <__monty__> gwosix: I'll try stumbling around helping you until someone who actually knows what they're talking about falls in ; )
04:23:54 <__monty__> gwosix: Hmm, seems like the issue is availability of bindists. Possible solutions are switch to an older stackage LTS or maybe install ncurses5.
04:24:56 <__monty__> Or install the haskell platform for 8.6.3, that should get you a working ghc and cabal at least and possibly a working stack.
04:27:00 * hackage patat 0.8.1.3 - Terminal-based presentations using Pandoc  https://hackage.haskell.org/package/patat-0.8.1.3 (JasperVanDerJeugt)
04:52:48 <gwosix> __monty__ could you help me with that?
04:53:01 <gwosix> installing 8.6.3 and so on?
04:54:39 <maerwald> gwosix: use ghcup if you are on linux
04:55:04 <maerwald> https://github.com/haskell/ghcup#installation
04:55:08 <__monty__> Does that install the platform? I thought it was limited to the compiler.
04:55:19 <maerwald> __monty__: what do you mean with platform?
04:55:29 <__monty__> The haskell platform.
04:55:35 <maerwald> yes, what do you mean
04:55:47 <__monty__> We want to get a working stack setup, not just a ghc installed.
04:55:57 <maerwald> haskell-platform already recommends ghcup
04:56:02 <__monty__> https://www.haskell.org/platform/
04:56:08 <maerwald> platform is just ghc, cabal and stack (possibly)
04:56:13 <maerwald> ghcup installs ghc and cabal
04:56:29 <maerwald> __monty__: check https://www.haskell.org/platform/#linux-generic
04:56:39 <__monty__> gwosix: Debian should have it packaged as haskell-platform.
04:57:34 <maerwald> stack has its own installer anyway
04:57:51 <__monty__> maerwald: I'm afraid ghcup might run into the same issue as stack though. Seems like ncurses6 isn't well supported yet.
04:57:55 <gwosix> is there stuff like rust's $RUSTUP_HOME?
04:58:24 <maerwald> __monty__: we install debian tarballs for debian
04:58:52 <__monty__> maerwald: Problem isn't getting stack installed. Problem is stack can't find a bindist for their platform. Seemingly because of ncurses6.
04:59:32 <__monty__> So I figured, install haskell-platform then use stack's "system ghc" support.
04:59:35 <maerwald> gwosix: you're on gentoo?
04:59:49 <gwosix> you can't even get ncurses 5.8 with the normal gentoo depos
04:59:56 <gwosix> yeah gentoo
04:59:57 <gwosix> uwu
05:00:07 <maerwald> gwosix: I'm on exherbo, I believe ghcup should work on gentoo as well
05:00:15 <maerwald> it will install fedora bindist
05:00:19 <gwosix> alright
05:00:43 <gwosix> maerwald: how do specify install location?
05:00:49 <gwosix> is there a global var?
05:01:01 <maerwald> gwosix: it installs into ~/.ghcup
05:01:06 <__monty__> Oh, woops, not sure why I was thinking debian.
05:01:16 <gwosix> maerwald i don't like it to
05:01:24 <maerwald> gwosix: yes there is a var
05:01:42 <maerwald> GHCUP_INSTALL_BASE_PREFIX which defaults to $HOME
05:01:51 <maerwald> so it will install into GHCUP_INSTALL_BASE_PREFIX/.ghcup
05:02:06 <maerwald> you should set that var in your bashrc
05:02:16 <gwosix> yeah
05:02:20 <gwosix> oh shit
05:02:29 <gwosix> i'm going to have to do that tomorrow
05:02:35 <gwosix> i'm off, thanks
05:10:24 <gentauro> maerwald: exherbo? Wasn't that the distro who came out of gentoo and which stated on the website. If you want to use this distro "don't" :o
05:10:27 <gentauro> is it any good?
05:13:21 <maerwald> gentauro: there is common history with gentoo (the PM started as a gentoo PM), but it's not a gentoo derivate and uses none of its packages
05:13:30 <maerwald> and yes, don't use it
05:14:32 <mniip> avoid success at all costs
05:16:34 <dminuoso> mniip: Is there a point to Show1/Read1/Eq1/etc.. beyond avoiding UndecidableInstances?
05:17:20 <mniip> how does that avoid UndecidableInstances
05:17:36 <dminuoso> Perhaps Im too focused on my original problem back then.
05:17:54 <mniip> I mean originally Show1 le you express something you could not express in haskell at all
05:25:23 <Janat08_> numbers = 0:map (1+) numbers. How does this get to 3
05:25:41 <Janat08_> *2
05:28:20 <dmwit> numbers = 0:map (1+) numbers = 0:map (1+) (0:map (1+) numbers) = 0:1:map (1+) (map (1+) numbers) = 0:1:map (1+) (map (1+) (0:map (1+) numbers)) = 0:1:2:map (1+) (map (1+) (map (1+) numbers))
05:29:05 <dmwit> The steps, in order: expand definition of numbers; expand definition of numbers; expand definition of map; expand definition of numbers; expand definition of map
05:45:00 * hackage blas-comfort-array 0.0.0.1 - Auto-generated interface to Fortran BLAS via comfort-array  https://hackage.haskell.org/package/blas-comfort-array-0.0.0.1 (HenningThielemann)
05:45:59 * hackage blas-carray 0.1.0.1 - Auto-generated interface to Fortran BLAS via CArrays  https://hackage.haskell.org/package/blas-carray-0.1.0.1 (HenningThielemann)
05:56:09 <emacstheviking> How does one avoid getting "Couldn't match type ‘Integer’ with ‘CInt’" all over the place when using SDL2? I have been trying to use "instance where" to and from Integers but getting nowhere. I cant' even believe this is a problem! I've looked at various source files but I am mystified. It feels like it should be easy to solve. I am using Float internally for drawing and want to use CInt at render time! HELP!!
05:57:28 <lyxia> where do you get the Integers from
05:58:59 * hackage hmm-lapack 0.3.0.2 - Hidden Markov Models using LAPACK primitives  https://hackage.haskell.org/package/hmm-lapack-0.3.0.2 (HenningThielemann)
05:59:17 <emacstheviking> lyxia: my code!! I have two local Int vars for width and height, I have them saved in my app-state as Int but the SDL createWindow wants V2 CInt...this is going to be a problem all over the place!
06:00:04 <Ariakenom> % (fromIntegral (1 :: Integer) :: Foreign.C.Types.CInt)
06:00:05 <yahb> Ariakenom: 1
06:01:23 <emacstheviking> So I have to do that *every* time I want to convert from Int to CInt...I already have a utility function for converting V2 Float to V2 CInt but the code is getting messy.
06:01:51 <emacstheviking> {-# INLINABLE v2CInt #-} v2CInt :: V2 Float -> V2 CInt v2CInt = fmap round
06:02:12 <Ariakenom> % :t fromIntegral :: Int -> Foreign.C.Types.CInt
06:02:13 <yahb> Ariakenom: Int -> Foreign.C.Types.CInt
06:03:31 <emacstheviking> windowInitialSize = V2 (fromIntegral wWidth) (fromIntegral wHeight)
06:03:50 <Ariakenom> % :t round :: Double -> Foreign.C.Types.CInt
06:03:50 <yahb> Ariakenom: Double -> Foreign.C.Types.CInt
06:04:31 <Ariakenom> emacstheviking: looks like you only need to change the type signature of your app-state. but you should probably gist some code.
06:04:41 <Ariakenom> you sound a bit confused :)
06:05:24 <emacstheviking> I wanted to keep my AppState as "Int" as that's what they are...CInt to me is just an implementation detail of SDL2...if I used something else later then I'd only have the code to change where it makes graphics API calls.
06:05:30 <emacstheviking> I *AM* confused! LOL
06:06:28 <merijn> emacstheviking: You can't use CInt and Int interchangeably, if you plan to interact with SDL and need CInt all the time, I would recommend using CInt everywhere in your code too
06:06:55 <emacstheviking> I was beginning to come to that conclusion. But then it feels like I am being to used a foreign type in pure code just because.
06:07:58 <merijn> emacstheviking: 1) I'm not sure why the "pure code" part matters? What other code would you use it in. And 2) how else would you resolve the distinction between C's int and GHC's Int?
06:08:00 <emacstheviking> I was hoping to model my game state independently of the hardware API if you get me....but seems like it might not be worth the effort
06:08:53 <emacstheviking> OK...well it *is* intended to be a game written in SDL2 so I guess using CInt is the way to stop faffinf about and make progress.
06:08:56 <emacstheviking> Thanks.
06:31:29 * hackage potoki-core 2.3.4.1 - Low-level components of "potoki"  https://hackage.haskell.org/package/potoki-core-2.3.4.1 (OShev)
06:42:29 * hackage potoki 2.1.4.1 - Simple streaming in IO  https://hackage.haskell.org/package/potoki-2.1.4.1 (OShev)
07:33:37 <wroathe> :t when
07:33:39 <lambdabot> Applicative f => Bool -> f () -> f ()
07:33:58 <wroathe> Is there a version of when that's f a -> f a
07:34:28 <Ariakenom> wroathe: that wouldn't work for when False
07:34:35 <lyxia> :t guard
07:34:37 <lambdabot> Alternative f => Bool -> f ()
07:35:17 <lyxia> so close
07:35:41 <Ariakenom> @src when
07:35:41 <lambdabot> when p s = if p then s else return ()
07:36:06 <wroathe> Got it, so if statement it is then
07:36:17 <wroathe> if expression*
07:36:58 <infandum> Is there an hmatrix function to map with indices? Like map (\i j v -> f i j v) mat
07:39:16 <gobby> I wrapped the `tripping` function from the Hedgehog library with a function that just takes the value to be tested. When the roundtrip test fails I no longer get the nice diffing on my terminal.
07:42:29 * hackage patat 0.8.2.0 - Terminal-based presentations using Pandoc  https://hackage.haskell.org/package/patat-0.8.2.0 (JasperVanDerJeugt)
07:46:51 <freusque> is there any terminal multiplexer plugin around?
07:47:16 <freusque> project*
07:47:36 <merijn> freusque: not afaik, I started working on one, but it never went anywhere
07:48:09 <gobby> does wrapping a function in another function hide its constraints?
07:48:24 <merijn> gobby: Yes, no, maybe? Depends on what you mean :p
07:48:39 <gobby> well basically I wrapped a test function in another function
07:48:50 <gobby> and now the test function does not show the diffs of failures
07:49:18 <gobby> the only thing that has changed is the wrapping function has less constraints
07:49:38 <merijn> gobby: pastebin your code?
07:49:41 <gobby> sure
07:50:32 <gobby> merijn: https://pastebin.com/wc0dgcxP
07:50:43 <freusque> merijn did you use bricks?
07:50:53 <gobby> merijn: http://hackage.haskell.org/package/hedgehog-0.6.1/docs/Hedgehog-Internal-Tripping.html
07:51:41 <merijn> Ah, no clue what MonadTest and co do
07:52:02 <merijn> Although the forall and constraint on the type signatures for encode and decode are SUPER suspicious
07:52:12 <gobby> even with them removed
07:52:17 <gobby> it's still the same issue
08:10:59 * hackage hapistrano 0.3.9.1 - A deployment library for Haskell applications  https://hackage.haskell.org/package/hapistrano-0.3.9.1 (juanpaucar)
08:14:32 <parkeraa> Howdy, #haskell. Am I correct in my understanding that => establishes the typeclass of a function, and -> is for establishing the operands of a function and the output?
08:15:19 <linduxed> parkeraa: s/operands/arguments/, i think. but other than that, yes
08:15:57 <linduxed> hmmm, i should look up the word operand in this case...
08:15:58 <tdammers> more generally, => expresses constraints. But those do usually involve typeclasses.
08:15:58 <lyxia> constraint => argument -> result
08:16:24 <parkeraa> What constraints may exist other than typeclasses?
08:16:42 <lyxia> type equalities   x ~ y
08:17:42 <lyxia> HasCallstack
08:17:49 <phadej> implicit arguments
08:17:57 <Taneb> lyxia: isn't that a nullary typeclass?
08:18:02 <lyxia> it's not
08:18:03 <parkeraa> So "constraints" may exist outside of type constraints
08:18:33 <Taneb> lyxia: so it's not. Huh
08:19:15 <lyxia> it's a magic constraint, GHC adds something to the callstack every time this constraint is encountered, whereas type classes are just dictionaries that get passed around unchanged.
08:19:29 <Putonlalla> You can think of `=>` as a variant of `->` that the compiler applies, parkeraa.
08:20:02 <Putonlalla> We have the monomorphism restriction to control when this happens.
08:20:15 <lyxia> One could also argue Coercible is not a typeclass, because it comes with its own constraint solver.
08:21:32 <parkeraa> Putonlalla: that makes sense
08:25:00 * hackage log-elasticsearch 0.10.0.1 - Structured logging solution (Elasticsearch back end)  https://hackage.haskell.org/package/log-elasticsearch-0.10.0.1 (MikhailGlushenkov)
08:27:02 <parkeraa> Am I also correct to believe that Ord specifies a class of types (being a typeclass), and is a way of specifying that a value may be any of the types in the typeclass?
08:27:41 <parkeraa> i.e. "Ord x" specifies that x may be any of the types in the class "Ord"
08:29:47 <dminuoso> lyxia: Why is the constraint solver different?
08:32:11 <dminuoso> Oh. I guess there are not actually any instances of Coercible..
08:32:35 <dminuoso> So that would mean... constraint solving needs to know about roles instead of instances. 
08:33:38 <ski> parkeraa : `Ord x' specifies that `x' is any of the types that support ordering, yes. to specify that a value is of type `x', then refer to `x' in the rest of the type signature
08:35:53 <ski> parkeraa : perhaps you could elaborate more on how you want to use this (these) value(s) that "may be any of the types in the typeclass" ?
08:38:32 <lyxia> dminuoso: it's also aware of transitivity and symmetry, which don't work well with typeclasses in general.
08:38:57 <parkeraa> I'm just trying to understand what is meant by Ord, I'm not working on a particular project
08:39:14 <parkeraa> Thank you all for your help, I greatly appreciate it
08:41:04 <ski> parkeraa : well, an example of what you're thinking about would help us better understand what it is you're thinking of, so that we could give more appropriate/specific help
08:42:31 <ski> parkeraa : if you e.g. say `blah :: Ord a => a -> [a] -> [a]', then that's the type signature of a function `blah' that takes a value, and a list of elements of the same type, and returns another list of the same type, as long as the element type `a' is in the type class `Ord'
08:43:00 <ski> parkeraa : so, in this case, a single call to `blah' only involves a *single* type `a' which is in the type class `Ord'
08:43:58 <ski> parkeraa : however, your question sounded like you were perhaps wondering about a single function handling multiple values of different types, all in the type class `Ord'. maybe even handling a list of multiple such values of different types ?
09:00:48 --- mode: ChanServ set +o glguy
09:00:48 --- mode: glguy set -bbbb *!~dameloo@* $a:phaskell *!*@185.2.188.17 *!*jimmyray@unaffiliated/stafford
09:00:48 --- mode: glguy set -bbbb *!*@aftertheome.ga *!*@202.81.242.188 *!*@*.lab.im *!*@gateway/tor-sasl/qqumber
09:00:48 --- mode: glguy set -bbbb *!*@206.189.157.115 hamme!*@* $a:chare $a:anticensored
09:00:48 --- mode: glguy set -bbbb *!~TURK@* *!*rly@unaffiliated/rly *!*@233-179-0-131.e-client.com.br *!~elaineben@*
09:00:49 --- mode: glguy set -bbbb *!*@unaffiliated/scheme $a:harrisonpartch *!*@70.35.192.0/20 unamazing!*@*$##fix_your_connection
09:00:50 --- mode: glguy set -bbbb *!~hmm@*.btcentralplus.com *!~MRd@114.125.* $a:Kihokki chord!*@*
09:00:51 --- mode: glguy set -bbbb $a:republican_devil *!*@104.237.255.131 *!*Krisostoo@*.dyn.estpak.ee *!*@187-108-067-184.ip3.com.br
09:00:52 --- mode: glguy set -bbbb *!*@2001:ee0:4101:a16:* *!*irc2000@*gateway/tor-sasl/irc2000 $r:*FAT*16* $a:EthicalHacker
09:00:53 --- mode: glguy set -bbbb *!*@unaffiliated/ethicalhacker *!*@cassarossa.samfundet.no *!*25e4ed97@*.37.228.237.151 *!*weenis@2607:5300:60:41a::*
09:00:54 --- mode: glguy set -o glguy
09:01:12 <Welkin> what
09:02:23 <phadej> I guess those were spammer bans?
09:02:52 <glguy> Outdated ones, at least
09:05:37 * ski idly wonders how long before gavino reappears
09:08:05 <dminuoso> Is it safe to use log through a Chan this way? https://gist.github.com/dminuoso/7761edf574e272cd4758e8cfed2ac27f  
09:08:40 --- mode: ChanServ set +o glguy
09:08:41 --- mode: glguy set -qqqo phaskell-1!*@* phaskell-2!*@* *!*@gateway/web/cgi-irc/kiwiirc.com/ip.46.92.185.101 glguy
09:09:15 <merijn> dminuoso: Define safe
09:09:35 --- mode: ChanServ set +o glguy
09:09:35 --- mode: glguy set -qo Krisostoomus!*@* glguy
09:09:47 <merijn> dminuoso: There's a race where the program can exit before all messages have been logged, yes.
09:11:00 <merijn> dminuoso: I'm assuming you're using link to terminate the logging thread?
09:11:20 <merijn> hmm, gotta run to catch my bus!
09:43:48 <iqubic> When will dependent haskell be a thing?
09:45:28 <saml> cabal is dependency management
09:47:45 <iqubic> saml: That's not quite what I meant.
09:47:54 <iqubic> I want haskell with dependent types.
09:47:56 <saml> ah i see
09:48:29 <koala_man> I've developed a Haskell dependency. I need my fix :: (a -> a) -> a
09:49:49 <saml> @type fix
09:49:50 <lambdabot> (a -> a) -> a
09:49:56 <saml> @src fix
09:49:56 <lambdabot> fix f = let x = f x in x
09:50:45 <saml> > fix id
09:50:48 <lambdabot>  *Exception: <<loop>>
09:52:26 <phadej> fix error
09:52:28 <phadej> > fix error
09:52:31 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
09:52:37 <phadej> fun every time
09:52:43 <iqubic> How does that work?!?!
09:52:53 <iqubic> :t error
09:52:54 <lambdabot> [Char] -> a
09:53:18 <iqubic> Oh, I see how that works.
09:54:00 <phadej> iqubic: 
09:54:02 <phadej> > take 30 $ fix ("foo " ++ )
09:54:04 <lambdabot>  "foo foo foo foo foo foo foo fo"
09:54:28 <iqubic> phadej: I figured it out, yeah.
09:57:54 <saml> > take -1 $ fix id
09:57:56 <lambdabot>  error:
09:57:56 <lambdabot>      • No instance for (Typeable a0)
09:57:56 <lambdabot>          arising from a use of ‘show_M6649213988889905026928’
09:59:30 <phadej> > take 0 undefined :: Char
09:59:32 <lambdabot>  error:
09:59:32 <lambdabot>      • Couldn't match expected type ‘Char’ with actual type ‘[a0]’
09:59:32 <lambdabot>      • In the expression: take 0 undefined :: Char
09:59:37 <phadej> > take 0 undefined :: [Char]
09:59:39 <lambdabot>  ""
10:01:27 <dmwit> > take (-1) $ fix id
10:01:29 <lambdabot>  []
10:04:19 <dmwit> > let f = take -1 in f 3 [1..]
10:04:21 <lambdabot>  [0,1,2]
10:04:58 <dmwit> For when you need to go backwards from the beginning of an infinite list.
10:05:57 <iqubic> dmwit: HOW THE HECK!?!?!
10:06:19 <iqubic> :t take
10:06:20 <lambdabot> Int -> [a] -> [a]
10:06:47 <iqubic> Also, 3 doesn't have the type [a]
10:06:55 <dmwit> Doesn't it?
10:06:59 * dmwit looks on innocently
10:07:20 <dmwit> > 3 :: [_]
10:07:22 <lambdabot>  error:
10:07:22 <lambdabot>      • Found type wildcard ‘_’ standing for ‘w’
10:07:22 <lambdabot>        Where: ‘w’ is a rigid type variable bound by
10:07:34 <dmwit> > [3, []]
10:07:36 <lambdabot>  [[3],[]]
10:07:59 <dmwit> Oh, dear. It seems I've written a bug.
10:08:08 <iqubic> It does? How so?
10:09:30 <dmwit> Let's try that again.
10:09:32 <dmwit> > [3, []]
10:09:34 <lambdabot>  [[3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,...
10:09:38 <dmwit> MUCH better.
10:10:30 <dmwit> Okay, fair dinkum: claiming this goes backwards is misdirection. The fact that 3 can have a list type is also misdirection.
10:10:41 <iqubic> How does that work???
10:10:52 <iqubic> How does any of this trickery work?
10:10:58 <binq> > [3, []]
10:11:00 <lambdabot>  [[3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,...
10:11:08 <iqubic> > [3, 4, []]
10:11:10 <lambdabot>  [[3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,...
10:11:16 <dmwit> And to complete the list: the spacing I used in `take -1` is also misdirection.
10:11:24 <iqubic> Huh??? Where's the 4?
10:11:38 <dmwit> > drop 1 [3, 4, []] -- right here, of course
10:11:40 <lambdabot>  [[4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,...
10:11:53 <iqubic> > let f = take -1 in f 3 [1..]
10:11:56 <lambdabot>  [0,1,2]
10:12:02 <iqubic> How does that work?
10:12:11 <iqubic> > let f = take -2 in f 3 [1..]
10:12:14 <lambdabot>  [-1,0,1]
10:12:29 <iqubic> Seems to be going backwards to me.
10:12:30 <dmwit> Be careful. If you go backwards in time too far it might blow up.
10:12:47 <iqubic> > let f = take -3 in f 3 [1..]
10:12:50 <lambdabot>  [-2,-1,0]
10:13:03 <dmwit> > let f = take -3 in f 3 [42..] -- does it really go backwards for every infinite list?
10:13:04 <ym555> :t take -1
10:13:05 <lambdabot>  [39,40,41]
10:13:05 <lambdabot> Num a => Int -> [a] -> [a]
10:13:25 <iqubic> > [0, 2, 3] -1
10:13:27 <lambdabot>  [-1,1,2]
10:13:28 <dmwit> (Fair dinkum: yet more misdirection! But misdirection is way too fun to stop doing, so...)
10:13:32 * ski smirks
10:13:48 <iqubic> Wait... I think I found the trick.
10:14:01 <dmwit> I think you only found half of the trick. =)
10:14:10 <iqubic> You take the first n elements, and then subtract x from them.
10:14:26 <iqubic> :t (\x -> [1, 2, 3] -x)
10:14:28 <lambdabot> Num a => [a] -> [a]
10:14:36 <iqubic> How heck does that work???
10:15:10 <iqubic> :t (\x -> (-) [1, 2, 3] x)
10:15:12 <lambdabot> Num a => [a] -> [a]
10:15:19 <ski> @type let x = undefined in x `asTypeIn` \x -> [1, 2, 3] -x
10:15:21 <lambdabot> Num a => [a]
10:15:25 <Rembane> Have you given list a Num instance? 
10:15:25 <iqubic> So it is actually applying the minus function.
10:15:36 <iqubic> I think he must have.
10:15:37 <ski> yes
10:15:50 <iqubic> So now, how does the take thing work?
10:15:55 <dmwit> It's hard to imagine how [3, []] could work if there were no Num instance for lists.
10:16:07 <Rembane> Dark magci?
10:16:11 <dmwit> yes =)
10:16:16 <iqubic> > let f = take -1 in f 3 [1..]
10:16:18 <lambdabot>  [0,1,2]
10:16:20 <wroathe> So say I define a function with a polymorphic return type that has a few possible instances, like so: foo :: (MyClass b) => a -> b
10:16:34 <iqubic> Now, how does the that take thing work/
10:16:35 <wroathe> Normally the user would have to specify or let type inference kick in
10:16:38 <dmwit> Perhaps I have actually replaced lambdabot with a custom bot with an AI trained on producing the maximally confusing answers. =)
10:16:43 <ski> > map ((^2) + (^3)) [0 ..]
10:16:43 <wroathe> so foo "bar" :: Baz
10:16:45 <lambdabot>  [0,2,12,36,80,150,252,392,576,810,1100,1452,1872,2366,2940,3600,4352,5202,61...
10:16:55 <wroathe> Is there a way to specify a default type for type inference?
10:17:08 <dmwit> > map (sin^2 + cos^2) [3,4,5]
10:17:10 <iqubic> > let f = take . -1 in f 3 [1..]
10:17:10 <lambdabot>  [0.9999999999999999,1.0,0.9999999999999999]
10:17:12 <lambdabot>  error:
10:17:12 <lambdabot>      Precedence parsing error
10:17:12 <lambdabot>          cannot mix ‘.’ [infixr 9] and prefix `-' [infixl 6] in the same infi...
10:17:30 <iqubic> > let f = (.) take -1 in f 3 [1..]
10:17:32 <lambdabot>  <[Integer] -> [Integer]>
10:17:33 <wroathe> sot aht if the user just calls it as foo "bar" without the type specifier
10:17:41 <ski> > let f = take . subtract 1 in f 3 [1..]
10:17:43 <lambdabot>  [1,2]
10:17:53 <iqubic> ski: Is that what it's doing?
10:17:55 <dmwit> wroathe: No, you will always need a specifier. But TypeApplications can make the specification fairly lightweight.
10:18:03 <dmwit> iqubic: no
10:18:04 <ski> iqubic, no
10:18:12 <iqubic> Does it evaluate the take first, and then the subtraction?
10:18:16 <dmwit> iqubic: As you can tell by the fact that it gives a different answer. =)
10:18:33 <iqubic> > subtract 1 2
10:18:35 <lambdabot>  1
10:18:41 <ski> > subtract a b
10:18:41 <dmwit> ?src subtract
10:18:42 <lambdabot> subtract x y = y - x
10:18:43 <lambdabot>  b - a
10:18:53 <iqubic> So it's doing something weird.
10:18:59 <ski> heh
10:19:02 <dmwit> Well you knew that right from the beginning. =D
10:19:04 <iqubic> > let f = take . flip subtract 1 in f 3 [1..]
10:19:06 <lambdabot>  []
10:19:10 <iqubic> What?!?!
10:19:24 <ski> taking a negative amount yields the empty list
10:19:33 <iqubic> I see.
10:19:39 <iqubic> So how does the initial thing work?
10:19:45 <iqubic> > let f = take -1 in f 3 [1..]
10:19:47 <lambdabot>  [0,1,2]
10:19:59 * ski blames brownies
10:20:15 <iqubic> I get how the subtraction works, but nothing else
10:20:27 <dmwit> Claim: you do not even get how the subtraction works.
10:20:39 <ski> iqubic : could you get the same result, but without the `let' ?
10:20:55 <iqubic> Did you really just create an orphan instance to screw with my mind?
10:20:56 <dmwit> Oh yeah! I forgot to call out the "let" as part of the misdirection! Shame on me.
10:21:17 <iqubic> Is the let needed?
10:21:23 <dmwit> ...sort of.
10:21:29 * hackage spectral-clustering 0.2.2.0 - Library for spectral clustering.  https://hackage.haskell.org/package/spectral-clustering-0.2.2.0 (GregorySchwartz)
10:21:35 <dmwit> You can do without, but then the trick is much more obvious. =)
10:21:41 * ski . o O ( "so many misdirections to provide, so easy to forget mentioning one." )
10:21:59 <iqubic> >  take -1 3 [1..]
10:22:02 <lambdabot>  <Int -> [Integer] -> [Integer]>
10:22:06 <iqubic> Huh???
10:22:09 * ski smiles
10:22:19 <dmwit> hehehehe
10:22:42 <dmwit> Wow, that's a really diabolical result.
10:22:51 <iqubic> Is there just one orphan instance (Num a => Num [a]) here or not?
10:23:04 <dmwit> Can you think of a test that would help you answer that?
10:23:17 <iqubic> :info [a]
10:23:37 <iqubic> oh... lambdabot does't repond to that.
10:23:37 <dmwit> Ah. \bot doesn't support that, but I'd be willing to prepare yahb for this trick so that you can use :info. One moment.
10:23:38 <ski> @undo [a]
10:23:38 <lambdabot> [a]
10:24:08 <iqubic> You don't need to prepare yahb for that.
10:24:34 <iqubic> @undo "hello"
10:24:34 <lambdabot> "hello"
10:24:52 <iqubic> @undo Just 2
10:24:52 <lambdabot> Just 2
10:24:55 <dmwit> % let f = take -1 in f 3 [1..]
10:24:56 <yahb> dmwit: [0,1,2]
10:25:00 <dmwit> % :info [a]
10:25:00 <yahb> dmwit: ; <interactive>:1:2: error: parse error on input `a'
10:25:06 <dmwit> % :info []
10:25:09 <yahb> dmwit: data [] a = [] | a : [a] -- Defined in `GHC.Types'; instance [safe] Num a => Num [a] -- Defined at <interactive>:22:10; instance Alternative [] -- Defined in `GHC.Base'; instance Applicative [] -- Defined in `GHC.Base'; instance Eq a => Eq [a] -- Defined in `GHC.Classes'; instance Functor [] -- Defined in `GHC.Base'; instance Monad [] -- Defined in `GHC.Base'; instance MonadPlus [] -- Defined in `GHC.Ba
10:25:25 <iqubic> Looks like it cuts off before the interesting bits.
10:25:29 <dmwit> I think there's also %% to get the full output pasted online and a link sent to the channel.
10:25:30 <iqubic> Curses...
10:25:37 <dmwit> %% :info []
10:25:37 <yahb> dmwit: http://qp.mniip.com/y/53
10:27:45 <dmwit> %% :info Num
10:27:45 <yahb> dmwit: http://qp.mniip.com/y/54
10:27:50 <dmwit> hint ^
10:27:53 <ski> @undo do ()
10:27:53 <lambdabot> ()
10:28:04 <ski> @undo do x <- act; cont x
10:28:04 <lambdabot> act >>= \ x -> cont x
10:28:19 <nshepperd1> > take -_ 3 [1..]
10:28:21 <lambdabot>  error:
10:28:22 <lambdabot>      • Found hole: _ :: Integer -> [Integer] -> Int -> [a] -> [a]
10:28:22 <lambdabot>        Where: ‘a’ is a rigid type variable bound by
10:28:25 <ski> @undo [f x | x <- list,test x]
10:28:25 <lambdabot> concatMap (\ x -> if test x then [f x] else []) list
10:28:33 <iqubic_> > [1,2,3] - [1,2,3]
10:28:35 <lambdabot>  [0,0,0]
10:28:43 <iqubic_> I see. That makes sense.
10:28:52 <iqubic_> > 1 :: Num [a]
10:28:53 <ski> iqubic_ : that's what `undo' does
10:28:54 <lambdabot>  error:
10:28:55 <lambdabot>      • Expected a type, but ‘Num [a]’ has kind ‘Constraint’
10:28:55 <lambdabot>      • In an expression type signature: Num [a]
10:29:07 <iqubic_> ski: what does undo do?
10:29:13 <ski> (sometimes people try `@info ...', but that gets spellcorrected to `@undo ...')
10:29:28 <ski> iqubic_ : remove syntactic sugar of `do', and also list comprehensions
10:29:36 <iqubic_> I see. Makes sense.
10:29:51 <ski> @help undo
10:29:52 <lambdabot> undo <expr>
10:29:52 <lambdabot> Translate do notation to Monad operators.
10:29:52 <iqubic_> So what is the trick to this nonsensical stuff?
10:30:01 <dmwit> iqubic_: Did you check out my hint above?
10:30:20 <dmwit> http://qp.mniip.com/y/54 <- it's here
10:30:43 <iqubic_> Oh, yeah... I can't view that yet, as my school wifi blocks that site for some reason.
10:31:13 <dmwit> % :info Num
10:31:13 <yahb> dmwit: class Num a where; (+) :: a -> a -> a; (-) :: a -> a -> a; (*) :: a -> a -> a; negate :: a -> a; abs :: a -> a; signum :: a -> a; fromInteger :: Integer -> a; {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}; -- Defined in `GHC.Num'; instance [safe] Num a => Num [a] -- Defined at <interactive>:22:10; instance [safe] Num b => Num (a -> b) -- Defined at <interactive>:23:10
10:31:28 <dmwit> The important bits of the hint are already in this initial snippet. =P
10:31:51 <iqubic> OH??!?! You did some really interesting things there.
10:32:11 <iqubic> :t take -1
10:32:12 <lambdabot> Num a => Int -> [a] -> [a]
10:32:52 <dmwit> gotta run
10:32:59 <nshepperd1> > -1
10:33:01 <lambdabot>  -1
10:33:05 <iqubic> I'm so close to figuring this out.
10:33:19 <nshepperd1> Oh, disappoint
10:33:30 <dmwit> One more hint:
10:33:33 <iqubic> What was the initial thing we were exploring?
10:33:48 <ski> > let f = take -1 in f 3 [1..]
10:33:50 <lambdabot>  [0,1,2]
10:34:00 <dmwit> > ((3) (-1), 3 -1, (-) 3 1)
10:34:02 <lambdabot>  (3,2,2)
10:34:14 <iqubic> > (take -1) 3 [1..]
10:34:16 <lambdabot>  [0,1,2]
10:34:20 <iqubic> I see.
10:34:26 <iqubic> Getting there.
10:34:29 * hackage modularity 0.2.1.0 - Find the modularity of a network.  https://hackage.haskell.org/package/modularity-0.2.1.0 (GregorySchwartz)
10:34:46 <iqubic> > (subtract take 1) 3 [1..]
10:34:48 <lambdabot>  [0,-1,-2]
10:35:26 <iqubic> > (subtract 1 take) 3 [1..] -- (take - 1) 3 [1..]
10:35:29 <lambdabot>  [0,1,2]
10:38:07 <iqubic> (f - n) == \x -> f x - n
10:38:31 <slackcals> Could someone please help me out:  https://gist.github.com/slackcals/0054247ce41edd0aef500dbb8cd3d83d
10:38:51 <iqubic> I now understand what is going on there.
10:38:53 <slackcals> I am having a hard time understanding where the use of "when" is incorrect
10:39:13 <wroathe> Is there an idiom for naming functions that either produce the expected value or fails as part of a libraries API?
10:39:28 <iqubic> slackcals: Add the line `import Control.Monad` to the top of your file.
10:39:42 <wroathe> I see Maybe and Either being used for error handling, but I also want a "this might blow up your program" set of functions
10:39:44 <Welkin> wroathe: it's encoded in the type
10:39:49 <ski> slackcals : did you use `return' inside `when' ?
10:40:00 <Welkin> if it raises exceptions, it is not in the type though
10:40:34 <iqubic> Guys... It can't find the function that's trying to be run.
10:40:35 <Welkin> functions prefixed with `unsafe` break referential transparency
10:41:21 <slackcals> iqubic: I'm really embarrassed now.  Thank you, much!
10:41:43 <iqubic> The type of when that GHC is looking for matches the type when in hoogle.
10:42:07 <wroathe> For instance, it's a common pattern for a function that could fail to produce a result to wrap it in a Maybe, like "lookup" in Prelude. 
10:42:38 <iqubic> in XMonad, X is a monad. As the name kinda suggests.
10:42:46 <wroathe> But in some cases I think it can make sense to say "if you don't want to handle the case analysis after calling me function, you can accept the risks that if this fails it'll nuke everything"
10:43:39 <iqubic> ski: He doesn't need `return` because the type that GHC assumes `when` should have is correct for `when` He just needed to import Control.Monad
10:44:22 <ski> iqubic : some people mistakenly assume that `when (...) $ do return (...)' will abort their `do'-block
10:44:45 <iqubic> I see. I don't think that was the issue here.
10:44:56 <ski> it looks like it wasn't, true
10:45:36 <iqubic> I suggested my fix, and then he thanked me for my suggestion.
10:46:48 <slackcals> just for clarity/confirmation... importing Control.Monad resolved my problem
10:47:04 <slackcals> thank you all!
10:55:57 <wroathe> So I have another function with a polymorphic return type, where there's a finite number of instances that that return type could be. A sort of "closed" class of types. Is there a better way of modeling this than just using regular old typeclasses and asking users to be on their best behavior?
10:56:17 <wroathe> Is this what type families are for?
10:58:04 <nbloomf> does it make sense to wrap the closed family behind an algebraic type?
10:58:21 <wroathe> I don't think so
10:58:32 <Welkin> always start wit the simplest solution, which is using basic ADTs, not typeclasses
10:58:34 <wroathe> Basically think something like "read" from prelude with a constrained set of "a"s
10:58:41 <Welkin> if you need more flexibility, then look into using typeclasses
10:59:20 <wroathe> Well, I suppose read already has a constrained set of As
10:59:24 <wroathe> "a"s
10:59:32 <wroathe> In the sense that the types need to be instances of Read
10:59:48 <wroathe> So the approach base uses is typeclasses for this
11:00:05 <wroathe> I guess I'm asking if there's a competing "better" way of doing this
11:02:49 <cocreature> make a sumtype of all the options that you can return and use that
11:05:57 <nbloomf> trying to think of a way to use a phantom type parameter to do this
11:09:16 <wroathe> Basically what I have is a hashmap that contains Aeson "Values"
11:09:29 <wroathe> Which is a sum type for modeling JSON data (and other serializable things)
11:09:54 <wroathe> And I want to provide a function to look up a value in that hashmap and and convert it to the desired "simple" type
11:10:38 <wroathe> i.e. MyMap -> a where a could be one of Float, Double, Int, Bool, String
11:11:00 <Zvpun> Hey, I have a performance problem. My program generates lots of configurations and needs to check them, but I was hoping for lazyness. It seems I was wrong. Here is the source: https://pastebin.com/raw/ET1ta9BB and here is a profiler result https://pastebin.com/raw/qCm1uY5U
11:11:02 <cocreature> what should happen if it cannot be converted to that type?
11:11:10 <wroathe> It blows up, but that's documented as part of the API
11:11:21 <wroathe> It's for converting configuration
11:11:42 <cocreature> documenting that your API blows up doesn’t make it a good API :)
11:11:52 <wroathe> cocreature: :P Read my earlier message
11:12:01 <wroathe> I'm going to provide Either and Maybe versions of the same function
11:12:16 <wroathe> But being that it's configuration state, if a user says something like:
11:12:29 <wroathe> get "db.connString" config
11:12:44 <wroathe> and connString wasn't present in any of their configuration
11:12:52 <wroathe> I think it's fair that say that that can explode
11:13:04 <wroathe> If they want to do case analysis, there will be a getMaybe and a getEither
11:13:10 <Welkin> just use an external (json) document store
11:13:17 <Welkin> they already provide a query interface
11:14:21 <wroathe> Ima just use a typeclass
11:14:29 <cocreature> wroathe: it usually makes more sense to have the individual calls return something like "Either String …", then batch all calls that read the documentation together in one do block and then decide how you handle the combined failure (and leave that up to the users, if they want to blow up that’s easy enough to do)
11:14:49 <cocreature> there is already a typeclass for this: FromJSON
11:15:05 <wroathe> cocreature: Yup, that's why there will be a getEither
11:15:55 <wroathe> And yeah, I'm making FromJSON the superclass
11:16:08 <cocreature> why do you need another typeclass instead of using FromJSON directly?
11:16:22 <cocreature> and I’d strongly advise to make "get" the safe version and then have a getUnsafe if you really want to
11:17:31 <wroathe> Because I don't consider all of the instances of FromJSON to be valid instances for my thing
11:17:56 <wroathe> That could change though, but for now Ima do it this way
11:18:03 <wroathe> And yeah, I'll think about the getUnsafe thing. Thanks!
11:19:27 <cocreature> it kind of sounds like you are artifically restricting things by not using FromJSON. unless you have a good reason for that, there is usually little reason to do that
11:19:57 <cocreature> eh that’s a tautology but hopefully you get my point :)
11:20:10 <cocreature> don’t restrict your API if it doesn’t provide a benefit
11:59:29 * hackage hakyll-images 0.4.2 - Hakyll utilities to work with images  https://hackage.haskell.org/package/hakyll-images-0.4.2 (LaurentRDC)
12:01:50 <Good-Luck-007> pastebin.com*G5Jqrd2S - new ctf gl
12:13:30 * hackage hierarchical-spectral-clustering 0.2.2.0 - Hierarchical spectral clustering of a graph.  https://hackage.haskell.org/package/hierarchical-spectral-clustering-0.2.2.0 (GregorySchwartz)
12:20:43 <infandum> Quick question: Why does -194.42441343872122 ** (-1/2) give an answer, but (\x -> x ** (-1/2)) $ -194.42441343872122 gives a NaN?
12:22:24 <merijn> :t -194.42441343872122 ** (-1/2)
12:22:26 <lambdabot> Floating a => a
12:22:36 <merijn> infandum: I blame IEEE754
12:23:11 <ski> > -194.42441343872122 ** (-1/2)
12:23:13 <lambdabot>  -7.171741069714176e-2
12:23:13 <ski> > (-194.42441343872122) ** (-1/2)
12:23:16 <lambdabot>  NaN
12:23:32 <saml> > \ (x::Double) -> x ** (-1/2.0) $  -194.42441343872122
12:23:34 <lambdabot>  error:
12:23:35 <lambdabot>      • Couldn't match expected type ‘Double -> t’
12:23:35 <lambdabot>                    with actual type ‘Double’
12:23:46 <ski> brackets
12:23:59 <saml> > \x :: Double -> x ** (-1/2.0) $  -194.42441343872122
12:24:01 <lambdabot>  error:
12:24:01 <lambdabot>      Illegal result type signature ‘Double’
12:24:01 <lambdabot>        Result signatures are no longer supported in pattern matches
12:24:10 * ski sighs
12:24:26 <ski> > (\(x :: Double) -> x ** (-1/2.0)) (-194.42441343872122)
12:24:28 <lambdabot>  NaN
12:24:59 <saml> :t  (-194.42441343872122)
12:25:00 <lambdabot> Fractional a => a
12:25:28 <infandum> weird, right?
12:25:49 <merijn> :t (**)
12:25:51 <lambdabot> Floating a => a -> a -> a
12:25:52 <infandum> Is there a solution?
12:26:00 <ski> solution to what ?
12:26:02 <saml> what's relationship between Fractional and Floating?
12:26:26 <ski> `Floating' is a subclass of `Fractional'
12:27:06 <saml> a**b  where a < 0   and b < 0   is imaginary number?
12:27:45 <ski> > (-1) ** (-1/2) :: Complex Double
12:27:48 <lambdabot>  6.123233995736766e-17 :+ 1.0
12:27:53 <ski> > (-1) ** (-1/2) :: Double
12:27:55 <lambdabot>  NaN
12:28:13 <ski> > (-1) ** (-1/3) :: Complex Double
12:28:15 <lambdabot>  0.5000000000000001 :+ 0.8660254037844386
12:28:18 <infandum> Is there a way to apply ** (-1/2) to numbers with no NaNs for ones that shouldn't have NaNs?
12:29:09 <ski> square root of negative real numbers will not be a real number
12:29:27 <saml> infandum, you wanna get square root of x?
12:29:39 <saml> **(-1/2)  is same as square root, right?
12:29:46 <saml> oh what ski said
12:30:13 <ski> no, `(** 1/2)' is square root
12:30:23 <infandum> inverse square root
12:30:27 <ski> what you had was the inverse of the square root
12:30:35 <saml> ah wow math
12:30:35 <johnw> is there an easy way to submit additions to 'base', like GitHub PR level easy?
12:33:55 <utdemir[m]> johnw: AFAIK they accept simple contributions via GitHub PR's. I'm not sure a change in `base` counts as simple tho.  But at least if you open a PR, they'll help you to move it to their tool of choice (GitLab?). https://github.com/ghc/ghc/tree/master/libraries/base
12:34:28 <geekosaur> no; and base is core enough that all such are supposed to go through the core libraries committee and be discussed on their mailing list, unless it's e.g. a simple bug
12:36:58 <johnw> utdemir[m]: thanks, I just wanted to submit mapMaybeM
12:58:09 <saml> division isn't associative. but multiplication is. and you can turn division into floating point multiplication
12:58:20 <saml> does that mean i can turn non-monad to monad?
12:59:05 <Welkin> yes, using pure
13:00:49 * ski doesn't see what multiplication has to do with monads, there
13:01:58 <johnw> i missed the leap too
13:11:53 <c_wraith> multiplication forms a monoid. a monoid is a 1-element category. monads are kleisli categories.
13:12:06 <c_wraith> that almost leads up to a conclusion
13:12:15 <c_wraith> except it doesn't right at the end.
13:12:59 * hackage spectral-clustering 0.2.2.2 - Library for spectral clustering.  https://hackage.haskell.org/package/spectral-clustering-0.2.2.2 (GregorySchwartz)
13:13:07 <johnw> the only general way to turn non-monads into monads that I know of, is using the Freer monad
13:13:25 <c_wraith> but I can see how one might trace the ideas to points right next to each other.
13:13:26 <johnw> or just Free, if it's at least a Functor
13:23:44 <nbloomf> it's not that monads _are_ kleisli categories, they can be used to construct them
13:25:42 <johnw> right, given a Monad m, we can construct a Kleisli category whose arrows are a -> m b.
13:33:00 * hackage spectral-clustering 0.2.2.3 - Library for spectral clustering.  https://hackage.haskell.org/package/spectral-clustering-0.2.2.3 (GregorySchwartz)
13:46:30 * hackage too-many-cells 0.1.1.0 - Cluster single cells and analyze cell clade relationships.  https://hackage.haskell.org/package/too-many-cells-0.1.1.0 (GregorySchwartz)
13:54:25 <iqubic> ski: I figured out how you did the crazy `take -1` thing.
13:57:25 <ski> dmwit, not me
13:58:29 <ahri> I loaded a file into GHCI that contained `{-# LANGUAGE DataKinds #-}`, why do I need to type `:set -XDataKinds` into GHCI in order to interact with e.g. `:k "hello"`?
13:59:00 <dmwit> The REPL and the file have separate language extension settings.
13:59:05 <dmwit> This is occasionally handy.
13:59:31 <ahri> it's surprising to me - can you give an example of its handiness?
14:01:15 <dmwit> Extensions don't leak from ghci to the file. This means it doesn't have to re-load the file every time you turn on or off an extension, and turning off an extension in ghci doesn't accidentally prevent the file from being loadable.
14:01:49 <dmwit> Extensions don't leak from the file to ghci. This means that you land in a predictable state when ghci starts up; you don't need to mentally shift every time you start interpreting a file from some project you've never source-dived on before.
14:04:07 <ahri> I see, I can't find an option to automatically load extensions based on a file - is this not available?
14:05:18 <dexterfoo> ahri: you can use a .ghci file: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#the-ghci-files
14:05:48 <dexterfoo> ahri: or if you are using cabal, then you can list your extensions in your cabal file, and then "cabal repl" will load them i believe
14:06:45 <dmwit> I believe the exact feature you ask for is not available.
14:07:36 <ahri> ok, that's interesting, I can see why in most projects it's not all that useful. I think I'll code something up to load them in for my case :) thanks!
14:11:55 <geekosaur> it's even trickier than that. say you have a project with multiple source files, each with its own LANGUAGE pragmas, and you load all of them. which one wins?
14:12:29 <geekosaur> note that :m doesn't help here, it controls only which one gets unqualified names. would you expect it to look at a qualified name and switch extensions to match? and what happens if you mix them in the same expression?
14:12:50 <ahri> yeah, so my case is single-file "projects", so I'm spared this complication
14:17:29 * hackage expresso 0.1.2.0 - A simple expressions language based on row types  https://hackage.haskell.org/package/expresso-0.1.2.0 (willtim)
14:26:05 <iqubic> dmwit: ski: I solve the puzzle of the weird (take -1) thing.
14:27:00 <ski> ok
14:27:19 <iqubic> it's clever and weird.
14:27:33 <iqubic> how is the let misdirection though?
14:28:29 <ski> brackets emphasize that something weird is going on with the function and the minus sign
14:29:30 <iqubic> Ah, I see.
14:33:53 <iqubic> fromInteger = const -- for functions
14:33:57 <iqubic> I think.
14:34:34 <kadoban> Wat? Functions are Num instances ?
14:34:41 <iqubic> no.
14:34:50 <ski> they are now, thanks to dmwit
14:34:56 <kadoban> Oh
14:34:59 <iqubic> ski and/or dmwit can explain this better.
14:35:06 <ski> > 2 3
14:35:09 <lambdabot>  2
14:35:14 <kadoban> Haha
14:35:21 <iqubic> > let f = take -1 in [1..]
14:35:23 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:35:41 <iqubic> > let f = take -1 in f 3 [1..]
14:35:43 <lambdabot>  [0,1,2]
14:36:10 <iqubic> bonus point to you kadoban if you can figure out how that works.
14:36:31 <kadoban> :t take
14:36:32 <lambdabot> Int -> [a] -> [a]
14:37:22 <ski> > (map . map) (fst^2 + snd^2) [[(x,y) | x <- [0 .. 3]] | y <- [x .. 3]]
14:37:25 <lambdabot>  *Exception: not an integer: x
14:37:34 <ski> > (map . map) (fst^2 + snd^2) [[(x,y) | x <- [y .. 3]] | y <- [0 .. 3]]
14:37:36 <lambdabot>  [[0,1,4,9],[2,5,10],[8,13],[18]]
14:38:04 <kadoban> :t take -1
14:38:06 <lambdabot> Num a => Int -> [a] -> [a]
14:38:19 <kadoban> I'm guessing it has something to do with that
14:38:27 <iqubic> there is so much cleverness going on there.
14:38:57 <iqubic> kadoban: Perhaps, but how does (take -1) work exactly?
14:39:15 <kadoban> Depends what the definition is for subtraction in this Num instance
14:39:31 <kadoban> It's probably just ...   (-) a b = a  I guess?
14:39:41 <iqubic> Try testing it.
14:39:43 <kadoban> So (take -1) = take
14:39:54 <iqubic> does that work?
14:40:04 <kadoban> > take -1 5 [1,2,3,4,5]
14:40:06 <lambdabot>  <Int -> [Integer] -> [Integer]>
14:40:10 * ski grins
14:40:16 <kadoban> > (take -1) 5 [1,2,3,4,5]
14:40:18 <lambdabot>  [0,1,2,3,4]
14:40:22 <kadoban> There we go
14:40:29 <iqubic> that was figured out quickly.
14:40:29 <kadoban> > (take -1) 3 [1,2,3,4,5]
14:40:31 <lambdabot>  [0,1,2]
14:40:50 <kadoban> Damn is that confusing though. What a garbage language this is xD </s>
14:40:58 <iqubic> See there's an interesting thing going on here.
14:41:41 <iqubic> There are two critical pieces of information you need to find here.
14:43:11 <Heffalump> iqubic: FTP and FTP? :-)
14:43:16 <iqubic> > [1,2,3] - [1,2,3] -- kadoban
14:43:19 <lambdabot>  [0,0,0]
14:43:19 <kadoban> I wonder if you could make this Num instance even more confusing depending on what the arguments to the function are. If you start acutally using a and b ... that'd be even more wonky.
14:43:35 <iqubic> Heffalump: what is FTP?
14:43:43 <kadoban> Nice. That's almost a halfway sane Num instance.
14:43:54 <Heffalump> Foldable Traversable Proposal - the thing that led to nonsense like length (2, 3) = 1
14:44:04 * ski . o O ( "Fleyland Tenebrificate Plangorous" )
14:44:15 <Heffalump> I'm assuming that's not actually the culprit here, but it feels like it ought to be :-)
14:44:39 <kadoban> I don't think so, ya
14:44:43 <iqubic> yeah. It's basically "x `binOp` y == zipWith binOp x y"
14:45:11 <iqubic> Where "x is the same type as y and both are [a]"
14:45:40 <iqubic> And `binOp` is one of (+, -, *, /)
14:46:09 <ski> not `/'
14:46:21 <iqubic> Why?
14:46:26 <iqubic> Is div different?
14:46:38 <ski> @type [(+),(-),(*)]
14:46:40 <lambdabot> Num a => [a -> a -> a]
14:46:41 <ski> @type [(+),(-),(*),(/)]
14:46:42 <lambdabot> Fractional a => [a -> a -> a]
14:46:54 <ski> > [0] / [1]
14:46:56 <lambdabot>  error:
14:46:56 <lambdabot>      • No instance for (Fractional [Integer])
14:46:56 <lambdabot>          arising from a use of ‘e_101’
14:47:33 <iqubic> Ah right. But I'm basically right with my implementation of (Num a => Num [a])
14:47:40 <ski> (one could easily make a `Fractional' instance, though. it's just that dmwit didn't bother to)
14:47:58 <iqubic> also: "fromInteger = repeat"
14:48:06 <ski> yep, that's crucial
14:48:21 <ski> (together with the cut-off behaviour of `zipWith')
14:48:36 <iqubic> kadoban: There still one or two things that you haven't explained.
14:48:39 <ski> iqubic : did you see the monoids thing, yet ?
14:49:05 <iqubic> > let f = take -1 in f 3 [1..]
14:49:07 <lambdabot>  [0,1,2]
14:49:09 <iqubic> ski: No.
14:49:17 <iqubic> Care to show me some weirdness?
14:50:46 <ski> > sortBy (comparing length <> compare) (words "The quick brown fox jumps over the lazy dog")  -- primarily sort by length, secondarily by contents (lexicographically as usual)
14:50:48 <lambdabot>  ["The","dog","fox","the","lazy","over","brown","jumps","quick"]
14:50:49 <kadoban> iqubic: Oh, what'd I not figure out yet?
14:50:58 <ski> @where monoids
14:50:59 <lambdabot> comment on "Monoids? In my programming language?" by Cale in 2008 (or 2009 ?) at <http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx> about a use of `
14:50:59 <lambdabot> instance Monoid a => Monoid (rho -> a)'
14:51:03 <ski> iqubic ^
14:51:45 <iqubic> kadoban: There something more to this.
14:51:46 <iqubic> > let f = take -1 in f 3 [1..]
14:51:48 <lambdabot>  [0,1,2]
14:51:58 <iqubic> :t (take - 1)
14:52:00 <lambdabot> Num a => Int -> [a] -> [a]
14:52:10 <iqubic> :t (id - 1)
14:52:12 <lambdabot> Num a => a -> a
14:52:19 <iqubic> :t (const - 1)
14:52:20 <lambdabot> Num a => a -> b -> a
14:52:30 <ski> iqubic : have fun reading that
14:52:39 <iqubic> What is rho?
14:52:46 <Heffalump> :t (\f -> f - 1)
14:52:47 <lambdabot> Num a => a -> a
14:53:01 <Heffalump> :t 1
14:53:02 <lambdabot> Num p => p
14:53:10 <iqubic> Also kadoban, there's one more Num instance that has been created that hasn't been explicitly called out.
14:53:29 <Heffalump> > let f = take - const 1 in f 3 [1..]
14:53:31 <lambdabot>  [0,1,2]
14:53:41 <iqubic> Other than the "Num a => Num [a]" that dmwit made.
14:53:47 <ski> iqubic : just a type variable
14:53:47 <kadoban> iqubic: I'm not sure what I'm missing. Those seem easy to understand so far? I'm not really sure why there's a Num constraint on id -1 and const -1, is that it?
14:54:19 <kadoban> > (id - 42) 100
14:54:21 <lambdabot>  58
14:54:26 <iqubic> What is that doing.
14:54:30 <kadoban> Oh, because it does the funny thing I thought would be funny
14:54:41 <kadoban> > (id - 1) 100
14:54:43 <lambdabot>  99
14:54:48 <Heffalump> is kadoban the only person supposed to be solving this problem, or can anyone play?
14:54:48 <iqubic> How the heck are are you able to subtract a number from a function?
14:55:01 <iqubic> Heffalump: You can certainly help.
14:55:17 <kadoban> Because the number becomes a function because there's a Num instance for functions (and a subtraction instance for functions)
14:55:18 * ski suspects Heffalump would solve it too fast :)
14:55:31 <iqubic> kadoban: Yes.
14:55:32 <Heffalump> well, I don't know the answer, so I can't guarantee to help without actually solving it :-)
14:55:46 <kadoban> iqubic: I thought that's already what I said though earlier
14:55:49 <Heffalump> though I have a vague guess, if my idea above is on the right track
14:55:54 <iqubic> Oh. I misunderstood.
14:56:37 <kadoban> Ah
14:56:41 <Heffalump> ok, I do know now actually
14:56:47 <iqubic> Yeah. dmwit also made "Instance Num b => Num (a -> b)"A
14:57:04 <kadoban> I didn't realize it was actually using the "1" part, but now I see
14:57:09 <iqubic> But I'm unsure of what the fromInteger looks like there.
14:57:10 <kadoban> Did the instance change or was the original one doing that too?
14:57:34 <iqubic> kadoban: "take -1" and "take (-1)" are two different things.
14:57:36 <ski> iqubic : it was mentioned before
14:57:51 <kadoban> iqubic: Yeah, I got that
14:58:03 <Heffalump> so all the pieces have been mentioned now, right?
14:58:08 <kadoban> fromInteger a = \x -> x - a   I think?
14:58:15 <kadoban> Or is it more complicated somehow?
14:58:17 <iqubic> ski: What is the fromInteger for this new Num type on functions?
14:58:19 <Heffalump> kadoban: it's simpler I think
14:58:23 * ski . o O ( "`take -1' is clearly the inverse function of `take' .." )
14:58:25 <Heffalump> iqubic: just the obvious one, surely?
14:58:40 <iqubic> Heffalump: What is the obvious one.
14:58:44 <iqubic> Also, I don't know.
14:58:49 <Heffalump> iqubic: fromInteger k = \_ -> fromInteger k
14:58:57 <kadoban> Oh, fromInteger a = const a   probably
14:58:59 <ski> Heffalump : yes, since about four and a half hour ago
14:59:03 <kadoban> Gotcha
14:59:24 <kadoban> Or ya, whatever actually typechecks there
14:59:34 <iqubic> ski: That's actually what I said a while ago.
14:59:43 <ski> iqubic : yep, as i said :)
14:59:49 <iqubic> ski: http://www.rubinsteyn.com/monoids.html
14:59:56 <iqubic> That gives me a 404 error.
15:00:09 <iqubic> So I can't really look at the monoids thing.
15:00:12 <ski> dunno where you got that link from
15:00:17 <ski> i certainly didn't provide it
15:01:05 <iqubic> It's the link I got when I opened the reddit post and looked at what link they were discussing.
15:01:16 <iqubic> You provided a link to the reddit post.
15:01:41 <ski> yea. just look at the message composed by Cale in the message thread
15:01:55 <ski> (you know, the one i pointed you to)
15:02:04 <iqubic> And I click through to see what link they were discussing by clicking the text "Monoids? In my programming language?"
15:02:31 <Heffalump> so it's just Num a => Num [a] and Num a => Num (b -> a) , right?
15:02:31 * ski doesn't recall whether they even looked at the link they were originally discussing
15:02:38 <ski> Heffalump : pretty much
15:02:57 <ski> and overloaded numeric literals, of course
15:03:21 <Heffalump> isn't that automatic? Given Num contains fromInteger and that's how Haskell works
15:03:53 <ski> sure, but it might not be obvious to people not already familiar with how that works
15:04:02 <ski> (is that a truism ?)
15:04:19 <Heffalump> :-) I really meant "it's just ... in addition to the Prelude+standard Haskell, right?"
15:04:31 <ski> (in any case, even if one's heard about it, it needn't be something that immediately comes to mind)
15:04:38 <ski> sure :)
15:04:49 <Heffalump> I guess that fromInteger = pure might be more natural than fromInteger = repeat
15:05:05 <ski> yea, `liftA2' works in place of `zipWith'
15:05:05 <Heffalump> but otherwise those are quite natural instances if you're going to have them at all
15:05:44 <iqubic> Are there default definitions for "Monoid Ordering" and and "Monoid m => Monoid (e -> m)" in the haskell standard library already?
15:06:34 <iqubic> > sortBy (comparing length <> compare) (words "here is a bunch of words to sort first by length and then alphabetically")
15:06:36 <lambdabot>  ["a","by","is","of","to","and","here","sort","then","bunch","first","words",...
15:06:40 <Solonarv> iqubic: yes
15:06:49 <iqubic> I see. So that's how that thing works.
15:06:59 <ski> pretty neat, huh ?
15:07:19 <Solonarv> Heffalump: the 'Num [a]' instance is a special case of lifting "through" an applicative functor
15:07:35 <iqubic> What exactly does that thing do that I just posted?
15:07:49 <iqubic> And how does it work??
15:07:55 <wroathe> So with TypeApplications, if I have a foo :: Monad m => m a, and I call it like so: foo @Integer, it tries to apply Integer to m a. The documentation mentions using forall to make it so that it applies Integer to a
15:08:03 <wroathe> How would that syntax look?
15:08:18 <ski> iqubic : it does what it says
15:08:30 <lyxia> foo :: forall m a. Monad m => m a
15:08:39 <Solonarv> [] is actually an applicative functor in two different ways (pure = repeat and liftA2 = zipWith, or: pure x = [x] and liftA2 = {- cartesian product -}), so there are two ways to lift a Num instance through []
15:08:53 <lyxia> I'm pretty sure that's what you get by default though
15:09:13 <lyxia> so foo @Integer is ill-typed
15:09:29 <wroathe> get :: (MonadFail m, FromJSON a) => String -> FlatConfigMap -> m a
15:09:35 <wroathe> This is the actual signature
15:10:14 <wroathe> It's telling me it can't match type Integer with IO
15:10:28 <wroathe> So it's trying to do something like Integer a,  instead of IO Integer
15:10:43 <Solonarv> sure looks like the order is 'forall m a. ...'
15:10:57 <geekosaur> I think you'd have to swap those variables in the forall?
15:11:04 <Solonarv> you can also use wildcards in type applications, like so:
15:11:08 <geekosaur> forall a m. ...
15:11:14 <Solonarv> foo @_ @Integer
15:11:29 <geekosaur> but that would be weird, and I'd recommend Solonarv's solution
15:11:38 <geekosaur> weird and confusing
15:15:13 <wroathe> Yeah, so forall a m. (MonadFail m, FromJSON a) => String -> FlatConfigMap -> m a works
15:15:24 <wroathe> But why is that weird/confusing geekosaur?
15:16:25 <geekosaur> because people tend to think of m and a there as having a particular relationship, which here gets inverted. consider as an example wanting to apply both
15:16:46 <wroathe> Well, the use case is I want m to be inferred 
15:16:54 <geekosaur> (foo @Integer @IO) where one would expect (foo @IO @Integer)
15:18:03 <wroathe> I suppose I could just say that it's just IO a
15:18:20 <wroathe> But that seems like it rules out too many cases where this might be useful
15:18:50 <Solonarv> did you miss the solution I posted?
15:19:02 <wroathe> No, sorry Solonarv, I saw it
15:19:12 <wroathe> It's not ideal to require the user to specify @_
15:19:20 <wroathe> Even though it might make sense
15:19:44 <wroathe> Basically this is a map lookup that performs a conversion to the specified type, and it's mainly going to be used in IO
15:20:04 <wroathe> so I want the API to be: get @Integer "foo" config
15:20:34 <wroathe> get @Int "port" config
15:20:50 <wroathe> Requiring @_ clutters that
15:20:59 <Solonarv> ah, I see
15:21:38 <wroathe> just like requiring them to specify @IO would clutter things
15:21:38 <Solonarv> that seems like a valid case for flipping the type variables, I think
15:23:54 <wroathe> Solonarv: Cool, thanks
15:24:54 <jackdk> does this lookup need IO? If you can do it in just a MonadFail, why not return Either or Maybe and only have one type var?
15:25:27 <wroathe> jackdk: I provide a getMaybe and a getEither for users that want to handle the case analysis
15:25:47 <wroathe> jackdk: This is for lazy people that are cool with things exploding if the config either doesn't exist or can't be converted to the desired type
15:26:25 <wroathe> Or if they consider it to be an exceptional case that their configuration doesn't have a certain thing defined
15:28:28 <amalloy> if the user has to write get @Integer "foo" config anyyway, and you have a fixed set of types, why not defineN monomorphic functions? getInteger, getString, etc
15:29:20 <Solonarv> because this 'get' function uses the result type's FromJSON instance
15:29:46 <Solonarv> in practice the user should usually not need to specify the result type; it should be fixed by type inference
15:31:55 <wroathe> Yup, exactly
15:31:59 <wroathe> That's the idea anyways
15:32:21 <wroathe> But if they need to be explicit, I'd rather make that easy too
15:33:15 <wroathe> and I did consider that amalloy 
15:33:34 <wroathe> I might end up doing that, but I think this current approach will probably end up being v1
15:39:29 * hackage wreq 0.5.3.2 - An easy-to-use HTTP client library.  https://hackage.haskell.org/package/wreq-0.5.3.2 (ondrap)
16:11:59 * hackage pencil 0.1.3 - Static site generator  https://hackage.haskell.org/package/pencil-0.1.3 (elben)
16:23:12 <Lycurgus> there's no channel for bnfc someplace is there?
16:29:10 <ski> apparently there is a #bnfc channel. not densely populated, though
16:32:06 <Lycurgus> yeah and it might have been just created
16:33:24 <zachk> what is bnfc?
16:33:39 <Lycurgus> (because it didn show in the search I did before asking)
16:34:10 <Lycurgus> https://bnfc.digitalgrammars.com one of a handful of killer hs apps
16:34:53 <Lycurgus> pandoc, xmonad, bnfc, and maybe a couple i can't recall right now
16:35:00 <wroathe> I'm curious what those of you who have built applications think of https://www.parsonsmatt.org/2018/03/22/three_layer_haskell_cake.html
16:36:30 <Lycurgus> actually there's killer, and killer but narrow appeal the ones I mentioned were not narrow and example of narrow would be like GF and there's a lot more of them
16:36:55 <Lycurgus> *an example (Grammatical Framework)
16:38:42 <ski> Lycurgus : secret channel, i think. still doesn't show with `alis'
16:39:11 <ski> i wonder whether the GF people would know of an appropriate channel
16:39:46 <sm> wroathe: I have not tried it; it seems more complex than my apps, and than this pattern: https://www.reddit.com/r/haskell/comments/aizfui/how_long_did_it_take_you_to_become_confident_in/eerkf1i/
16:40:05 <Lycurgus> ski, you mean #gf ?
16:40:09 <ski> yes
16:41:09 <sm> Lycurgus: don't forget hledger!
16:41:22 <ski> (note that Aarne Ranta, who wrote the BNFC book, is also the progenitor of GF)
16:41:33 <sm> and darcs, for a while
16:41:39 <Lycurgus> i'm too tired to do a regex search for gf lower case 
16:42:13 <Lycurgus> well it currently lists a team of contributors at chalmers
16:42:14 <ski> -!- Topic for #gf: Grammatical Framework · www.grammaticalframework.org
16:43:17 <Lycurgus> right they're talked about as if they were apples and apples, but I've always associated GF with NLP
16:43:34 <Lycurgus> and BNFC is just a tool
16:44:35 <Lycurgus> like CRISPR is Just a tool
16:46:07 <sm> pandoc, shellcheck and postgrest are the big three in github stars. purescript and elm are the next tier. Then it's Haxl, cardano, stack, luna, idris.
16:46:50 <Lycurgus> is that a stray t on pg?
16:46:55 * ski . o O ( Neuro-Linguistic Programming ? )
16:47:14 <Welkin> natural language processing
16:47:22 * Lycurgus goes bonk bonk on the ski head
16:47:25 <Welkin> no hypo-rapist stuff
16:47:29 <Welkin> hynpo*
16:47:32 <Welkin> hypno*
16:47:55 <ski> heh
16:48:02 <ski> and CRISPR ?
16:48:06 <Welkin> no idea
16:48:11 <Welkin> it's a techinque for gene editing
16:48:31 <Welkin> the full name is never important
16:48:39 <Welkin> they try to make clever acronyms in science
16:48:43 <Welkin> so the full name is oftne meaningless
16:49:04 <Welkin> clustered regularly interspaced short palindromic repeats
16:49:06 <Welkin> apparently
16:49:13 <Lycurgus> conserved repeating intersomething palandromic repeats
16:49:22 <ski> (WP points me to DNA stuff. "CRISPR is a family of DNA sequences found within the genomes of prokaryotic organisms such as bacteria and archaea. These sequences are derived from DNA fragments from viruses that have previously infected the prokaryote and are used to detect and destroy DNA from similar viruses during subsequent infections. Hence these sequences play a key role in the antiviral defense system of prokaryotes.")
16:49:29 <Lycurgus> oh yeah clustered
16:49:49 <ski> so how is CRISPR just a tool ?
16:49:53 <benzrf> CRISPR drawer
16:50:01 <Welkin> it's a technique for gene editing
16:50:06 <Lycurgus> if WP is word press, figures, CRISPR is much more than that
16:50:12 <ski> nah, Wikipedia
16:50:36 <Lycurgus> https://www.youtube.com/watch?v=4YKFw2KZA5o
16:51:11 <Welkin> wikipedia is awful lately
16:51:22 <Welkin> I often find myself reading broken english
16:51:22 <Lycurgus> yeah I stopped editing completely
16:51:47 <Welkin> I have to stop and go "what!?" and re-read it five times
16:52:11 <Lycurgus> Criticism of monarchy was my absolute last, cold turkey from it
16:52:26 <Welkin> are russians editing wikipedia or something?
16:52:50 <Lycurgus> yeah but wiki is much stronger in dealing with them
16:52:59 <Lycurgus> they really prey best on firms
16:53:21 <Lycurgus> and communities of dummies
16:53:43 <Lycurgus> which does describe the wiki masses but not the WMF staff
17:00:35 <geekosaur> the actual tool is CRISPR/Cas9
17:01:02 <geekosaur> Cas9 being a protein that grabs a CRISPR sequence, and when that grabs onto something floating in the cell, chops up the floater
17:01:34 <geekosaur> then hauls the fragments to be incorporated into new CRISPR sequences
17:02:14 <geekosaur> hence the funny acronym; it's freezing samples of invading bacteriophages so the cell can react to them or their relatives (they mutate quickly, so one fragment is never enough)
17:22:14 <ar1a> how can i safely run user input as haskell code? kind of like > or % with yahb lambdabot 
17:25:46 <zachk> hint maybe iirc 
17:27:19 <amx> ar1a: I think that's the whole point of Safe Haskell
17:28:17 <ar1a> amx: ty
17:28:35 <amx> https://wiki.haskell.org/Safely_running_untrusted_Haskell_code
17:29:45 <Welkin> pipe it into /dev/null
17:43:25 <c_wraith> @hackage mueval ar1a, this is probably what you want. it's what lambdabot uses.
17:43:26 <lambdabot> http://hackage.haskell.org/package/mueval ar1a, this is probably what you want. it's what lambdabot uses.
17:44:18 <recursion-ninja> How do I change one element at a given index of a bytestring. I looked at the ByteString API and there doesn't seem to export a function to do this. I was looking for something along the lines of ByteString -> Int -> Char -> ByteString. Am I missing something?
17:45:05 <Axman6> Char would be the wrong type, should be Word8, but also doing that will be quite inefficient
17:47:26 <lyxia> if it's really a one off thing, you can slice the bytestring to rebuild it. Otherwise if you really want mutation, convert to a mutable vector.
17:50:01 <DasBrain> Hi, I try to understand Lenses. In particular, according to the lens tutorial Control.Lens.Tutorial, the type Lens' a b = forall f . Functor f => (b -> f b) -> (a -> f a) looks kind of simple.
17:51:15 <DasBrain> A function, when given some function to convert the value to a Functor, returns a function which will turn some other value into a Functor.
17:51:28 <c_wraith> DasBrain, are you trying to use them, or understand their implementation?
17:51:37 <DasBrain> Understand them.
17:52:28 <c_wraith> OK, then first. only types can be an instance of Functor. values are not Functors, nor are they not-Functors
17:53:04 <c_wraith> a function cannot return a Functor, because functions return values.
17:53:30 <DasBrain> Yeah.
17:53:49 <sedeki> hello all, i've read haskellbook, now what? i don't feel like i have a sufficient theoretical foundation
17:53:59 <ski> `Maybe' (together with its implementation of `fmap', satisfying laws) is a functor. `Just False' is not a functor
17:54:39 <DasBrain> I don't have all the nessencary technical terms, so I was probably not very specific in my wording.
17:54:55 <lyxia> sedeki: isn't there an exercise at the end where you build a whole program
17:54:58 <c_wraith> DasBrain, the van Laarhoven encoding of lenses is indeed a rather simple encoding. the trick is how flexible it lets you be with only minor modifications
17:55:09 <ski> sedeki : perhaps CIS194, Typeclassopedia, Data61
17:55:35 <c_wraith> DasBrain, have you watched the Simon Peyton Jones video on skillsmatter that lens links to? it's a great place to start
17:56:17 <c_wraith> (that man is an amazingly skilled educator. I wish I was that good.)
17:57:00 <DasBrain> Ok, to quote the tutorial which the point I have a problem understanding it: "You might wonder how you can fit both getter and setter functionality in a single value like this. The trick is that we get to pick what Functor we specialize f to and depending on which Functor we pick we get different features."
17:57:43 <c_wraith> have you watched the video? it spends a lot of time explaining that.
17:58:05 <DasBrain> Ok, I'll watch it. Thank you.
17:58:30 <c_wraith> I understand if video isn't your favorite format to learn something. it's not mine either. this one is so good I recommend it anyway. :)
17:58:38 <sedeki> ski bookmarked, thanks
17:58:49 <ski> @where CIS194
17:58:50 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
17:58:53 <ski> @where Typeclassopedia
17:58:54 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
17:58:59 <ski> @where AAM
17:58:59 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
17:59:02 <ski> @where Data61
17:59:02 <lambdabot> Data61 Functional Programming Course <https://github.com/data61/fp-course>,<https://qfpl.io/links/2017-october-fp-course/> by Tony Morris,Mark Hibberd
17:59:17 <sedeki> 404 not found (last one)
18:00:37 <DasBrain> I don't like to signup to random pages.
18:01:41 <c_wraith> also fair.
18:02:16 <c_wraith> well, are you familiar with how polymorphism works in Haskell?
18:03:50 <c_wraith> like, what it means for a function to have the type Functor f => (Int -> f Int) -> ((Int, String) -> f (Int, String))
18:04:18 <c_wraith> I've chosen a silly example to make it monomorphic in everything but f
18:04:57 <shachaf> Control.Lens.Tutorial? What's that?
18:05:06 <shachaf> Oh, Tekmo's thing, right.
18:05:49 <shachaf> So many explanations of lens just pull the Functor f => (a -> f b) -> s -> f t thing out of thin air, which seems like such an odd way to do it.
18:06:21 <c_wraith> yeah, that's why I like SPJ's video
18:06:40 <c_wraith> but I acknowledge the registration barrier is annoying.
18:06:47 <ski> which video are we talking about ?
18:07:01 <DasBrain> myLens Identity (3, "foo") = Identity (3, "foo")
18:07:06 <c_wraith> SPJ's introduction to lenses on skillsmatter
18:08:18 <DasBrain> This video: https://player.vimeo.com/video/76506719?api=1&title=0 It's an hour, so.. be right back?
18:09:07 <ski> "Lenses: compositional data access and manipulation" by Simon Peyton-Jones in 2013-10-09 at <https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation>
18:09:14 <ski> ?
18:09:24 <shachaf> c_wraith: Didn't his video do that too?
18:09:38 <shachaf> Maybe I'm thinking of something else.
18:09:43 <c_wraith> ski, yes
18:10:06 * ski gets "Sorry. Because of its privacy settings, this video cannot be played here." for the link DasBrain provided
18:10:32 <c_wraith> shachaf, no, he go to it from starting with get, set, modify, then adding modifyIO, then finally generalizing that
18:10:37 <c_wraith> *got to it
18:10:39 <DasBrain> Ahh, well, it's the URL of the IFrame on skillsmatter.
18:11:19 <shachaf> Hmm.
18:11:27 <shachaf> Maybe I'm remembering wrong.
18:11:31 <c_wraith> shachaf, no idea if it has anything to do with the historical development method, but it's a good story
18:12:54 <shachaf> I still think the natural way to do it is Setter->Traversal->Lens
18:13:25 <shachaf> But I never wrote that up except in IRC. And now I'm a grouch so it's too late.
18:14:33 <c_wraith> I did like edwardk calling Gibbons' "The Essence of the Iterator Pattern" the old testament of lens.
18:15:29 <iqubic> I learned about Lenses first, then traversals.
18:17:04 <shachaf> Anyway I don't think looking at the way things were figured out historically is necessarily particularly good.
18:17:24 <shachaf> (Though I still have a soft spot for "(g a -> f b) -> g s -> f t", which doesn't exist anywhere anymore.)
18:19:36 <jackdk> is it correct to say that while you could do lens with Profunctor p => p a b -> p s t, Haskell does it with Functor f => (a -> f b) -> s -> f t so it lines up with the type of Data.Traversable.traverse?
18:20:06 <c_wraith> anyway, SPJ did have a good story. each new modify function was well motivated, then he made a great show of demonstrating how all of the other functions can be derived from the last one.
18:20:19 <shachaf> jackdk: That's what the lens library does.
18:20:51 <shachaf> Well, in general it does p a (f b) -> p s (f t), so you can choose p = (->) and get something compatible with traverse.
18:21:08 <c_wraith> jackdk, I don't think that's the biggest contributor. I think the biggest contributor is the ability to write indexed optics that unify down to non-indexed ones.
18:21:31 <c_wraith> by varying the choice of p in shachaf's example.
18:21:38 <shachaf> I guess one of those ps can be a q to make it more general, sure.
18:21:49 <shachaf> But the f is pretty superfluous.
18:22:00 <shachaf> You can always add it to your profunctor instead.
18:22:15 <jackdk> yeah okay, so it's an ergonomic thing rather than a theoretical one?
18:23:59 <shachaf> Yes.
18:25:51 <SolJ_> jd
18:43:02 <iqubic> Well, I just got a complete system slow down caused by a rouge instance of GHC.
18:45:58 <iqubic> It used like 4GB of my swap and slowed everything down. Luckily htop exists.
18:46:42 <nullremains> try a black instance of GHC
18:47:37 <iqubic> Huh?
18:47:46 <nullremains> rouge = red
18:48:26 <iqubic> I meant rogue.
18:48:36 <nullremains> yeah, bad joke, continue on...
18:49:06 <iqubic> Well, somehow GHC decided that it wanted to run as a background program that I couldn't easily kill.
18:49:23 <iqubic> Except for with htop.
18:49:41 <iqubic> It used all my RAM and most of my SWAP too.
18:50:18 <nullremains> impressive, I run without swap so that would be a reboot for me
18:51:08 <iqubic> Well, it was a reboot, the first time. But then I ran into the same issues when I tried to resume my code editing. The second time I was able to use HTOP effectively.
18:51:33 <iqubic> I might not want to continue using Dante for Emacs in the future.
18:52:11 <nullremains> In this case, Dante's inferno
18:54:53 <iqubic> Och, that's a terrible joke.
18:57:10 <nullremains> I thought it was actually pretty good, I mean surely your laptop fans are attempting liftoff when GHC decides to melt your CPU.
18:57:27 <suzu> what with everyone ditching stack and moving to cabal new-build
18:57:35 <suzu> is cabal the hot shit now
18:57:38 <suzu> what about intero and such
18:58:57 <iqubic> nullremains: That's actually what happen. That's how I noticed the problem in the first place.
19:10:59 <iqubic> the main issue is that Dante doesn't like dealing with IO or Debug.Trace functions, I think.
19:17:22 <jackdk> @pl \x -> f x . g
19:17:22 <lambdabot> (. g) . f
19:21:15 <DasBrain> @pl \x -> (f x) . (g x)
19:21:15 <lambdabot> liftM2 (.) f g
19:21:29 <DasBrain> @pl liftM2
19:21:30 <lambdabot> liftM2
19:22:25 <DasBrain> c_wraith, thanks for the useful video. My initial questions have been answered. And I get the feeling that I only scratched the surface.
19:23:05 <c_wraith> DasBrain: you're welcome.  and you've absolutely just scratched the surface.  If/when you have followup questions, feel free to ask.
19:23:40 <iqubic> @pl \x -> f . x . g
19:23:41 <lambdabot> (f .) . (. g)
19:23:46 <iqubic> Huh??
19:24:04 <iqubic> @unpl (f .) . g
19:24:05 <lambdabot> (\ x x0 -> f (g x x0))
19:24:13 <iqubic> Huh? How does that work???
19:24:37 <DasBrain> @unpl liftM2
19:24:37 <lambdabot> (\ f m1 m2 -> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2))
19:24:49 <iqubic> Yeah, that's what that does.
19:24:59 <DasBrain> @unpl liftM2 (.)
19:24:59 <lambdabot> (\ m1 m2 -> m1 >>= \ x1 -> m2 >>= \ x2 -> return (\ x -> x1 (x2 x)))
19:25:19 <c_wraith> iqubic: just substitute in the definition of (.) and then simplify.  There's no other way to learn it
19:31:19 <russruss> I have no idea how stack works or what it does really - is there a way to install and run a program in an isolated environment without installing anything globally using stack?
19:32:20 <russruss> I'm familiar with a few package manager tools, including npm and cargo.  I'm having trouble mapping stack to the concepts from these other tools, which may be a bad way to approach it anyways
19:32:51 <russruss> if there's no way to install a program to an isolated environment, I can make do with a different tool, just wondering if there's something I'm missing from stack
19:34:14 <wroathe> russruss: AFAIK stack creates it's own isolated sandbox in .stack-work
19:34:44 <wroathe> russruss: Not quite the same semantics as NPM, but I think close enough to what it sounds like you're looking for
19:34:46 <russruss> yes, I've noticed this when I've wanted to build something.  In this case, I'm not building anything, I just want to install a program without messing with any of my global state
19:35:59 <jackdk> russruss what program, out of interest?
19:36:11 <russruss> "stack install" seems to install to somewhere like ~/.stack/snapshots/x86_64-osx/lts-8.12/8.0.2/lib/x86_64-osx-ghc-8.0.2
19:36:40 <russruss> clash
19:36:58 <russruss> https://github.com/clash-lang/clash-compiler/wiki/FAQ#how-do-i-run-and-install-clash-using-stack seems to only include global install instructions
19:40:08 <wroathe> russruss: I can't try this now, but I think Stack lets you specify the local bin path with stack --local-bin-path=foo install my-package
19:40:58 <wroathe> "stack path" prints out the directories stack cares about
19:41:14 <wroathe> "stack --help" prints out that flag
19:42:41 <iqubic> Does anyone know why GHC sometimes hogs all the memory on my system.
19:43:35 <russruss> wroathe: thanks, it seems even if I specify local-bin-path, it still modifies file in the ~/.stack directory, which I don't want.  I think it probably wasn't designed for this usage pattern
19:43:54 <shachaf> Do you mean a lot of address space or a lot of memory actually used?
19:44:04 <MarcelineVQ> "Does anyone know why GHC sometimes hogs all the memory on my system. [when I'm doing <specific task written here>]"
19:44:08 <shachaf> I think the GHC allocator just asks for 1TB of address space at startup nowadays.
19:44:26 <iqubic> It's stolen all my memory twice in a row now, and at this point I'm afraid to ever open GHCI
19:45:18 <iqubic> MarcelineVQ: GHC has eaten throug all my RAM and most of my 8GB SWAP and slowed my whole computer down ten fold.
19:45:31 <iqubic> I have 8GB RAM, and 8GB Swap.
19:45:46 <maerwald> iqubic: ghc?
19:45:47 <wroathe> iqubic: It always seems like you have the most unique issues
19:45:48 <MarcelineVQ> "while I'm doing <specific task written here"
19:45:50 <maerwald> or cabal
19:45:58 <wroathe> Of anyone I've seen in this channel
19:46:07 <iqubic> maerwald: Actually, I think it was cabal.
19:46:16 <maerwald> iqubic: likely, since default numbers of jobs is unsafe
19:46:29 <maerwald> https://github.com/haskell/cabal/issues/5776
19:46:36 <iqubic> maerwald: Is there a way to tell it to use less jobs.
19:46:41 <maerwald> --jobs=1
19:47:17 <MarcelineVQ> aka -j1 which is a common shorthand for build systems
19:48:14 <iqubic> MarcelineVQ: I was running `cabal new-repl` and evaluating some functions to test my code. Everything was going fine, until I modified one of my functions to use `traceShowId` Evaluating that was the wrong thing to do.
19:48:16 <maerwald> -j1 is ambigously parsed in some cases afair
19:48:17 <MarcelineVQ> however you just said you were afraid of open ghci, that doesn't sound like a cabal issue. so what specific thing are you doing when the memory is used up?
19:48:43 <maerwald> yeah that sounds you were just recompiling the current project, not dependencies
19:48:59 <iqubic> Memory usage spiked when I ran a function that had just recently been modified.
19:49:06 <MarcelineVQ> suspicious, kinda sounds like you wrote a loop
19:49:19 <iqubic> Oh. I did write a loop.
19:49:24 <iqubic> Doh.
19:49:44 <iqubic> I'm trying to make a recursive parser, and I did actually write a loop.
19:49:47 <MarcelineVQ> This is why being specific with questions is a big deal.
19:50:06 <MarcelineVQ> Because that was a one line conclusion/solution to the more specific information.
19:53:11 <iqubic> Well, this is not the right way to write a parser of mathematical expressions.
19:53:20 <iqubic> http://dpaste.com/3MZBP19
19:53:44 <MarcelineVQ> not so much
19:54:19 <iqubic> What I actually meant was `try minus` which parses something of the form `expr - expr` not `try expr`
19:54:55 <iqubic> I'll update that to include all binary operators once I figure out how to parse things with the correct fixity.
19:55:16 <iqubic> But yeah, that has an infinite loop in it.
19:58:49 <iqubic> Can I use cabal's --jobs=1 flag with new-repl/
19:58:58 <iqubic> s./.?.
19:59:29 <sclv> repl is always single threaded?
20:00:54 <iqubic> Is it? I'm not sure it is? Can a single threaded program still chew through memory rapidly?
20:01:10 <wroathe> Yes it is, and yes it can
20:02:01 <iqubic> So I don't need the --jobs=1 flag when running `cabal new-repl`?
20:02:20 <maerwald> if cabal needs to install deps in order to spawn your repl, it will use ncpus
20:02:25 <maerwald> boom
20:02:50 <maerwald> or just set it globally
20:02:59 <iqubic> maerwald: I had all the dependencies installed already.
20:03:13 <wroathe> But the actual repl itself will be, by default, single threaded
20:03:19 <iqubic> How do I set the jobs flag globally? That is a thing I wish to do.
20:05:46 <wroathe> Pass +RTS -N through to GHCI?
20:06:15 <wroathe> Something like cabal new-repl --ghc-options='+RTS -N' should get the job done
20:06:42 <iqubic> What does the +RTS -N flags do?
20:08:43 <wroathe> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-opts-cmdline
20:08:49 <MarcelineVQ> they're irrelivant to your earlier issue, but youo can find out what they do in the ghc manual
20:09:34 <wroathe> Although I can't imagine why you'd want testing this simple parser to be multi-threaded in the repl
20:10:20 <iqubic> wroathe: I don't.
20:10:35 <iqubic> In fact I want it to use as little memory as possible.
20:12:08 <wroathe> Well, the repl is already single-threaded, and the cause of your earlier issue was the infinite loop
20:12:13 <wroathe> So... problem solved?
20:12:26 <iqubic> I'm too scared to try fixing it.
20:12:51 <iqubic> I don't want to softlock my system for a third time this evening.
20:18:50 <iqubic> wroathe: Well... Good news and bad news.
20:19:27 <iqubic> Bad: I didn't fix my issues. My computer was slowed a bunch.
20:19:34 <wroathe> You've saved a bunch of money on your car insurance by switching to Geico?
20:20:23 <iqubic> Good: I didn't have to reboot, as it was just slow, not completely blocked. I was able to launch htop and kill ghc.
20:20:42 <iqubic> So I'm back to square one here.
20:21:17 <iqubic> I just realized that I didn't actually solve my issue.
20:21:28 <iqubic> I still had an infinite loop.
20:21:47 <wroathe> Then you'll need to spend more time reasoning about your program :P
20:22:23 <wroathe> Or maybe someone here can tell you how to get a stack trace at runtime (I haven't figured that out yet)
20:22:50 <iqubic> I know what the issue is.
20:26:07 <iqubic> http://dpaste.com/3VPGEJ3
20:26:18 <iqubic> That's the code I just ran a moment ago.
20:26:28 <iqubic> It's another infinite loop.
20:26:48 <iqubic> I think I just need to move the minus parser to the end.
20:28:13 <wroathe> Where are minus, func, var, and num defined?
20:28:24 <MarcelineVQ> Seems to me that just means that it'll only loop if the rest fail, so it'll only loop sometimes
20:28:45 <iqubic> No. As that is written, it will always loop.
20:28:52 <MarcelineVQ> I
20:29:02 <MarcelineVQ> 'm referring to your proposed change
20:29:06 <iqubic> Oh.
20:29:18 <wroathe> You should paste all of your code
20:30:57 <iqubic> I'm not sure how to make a recursive parser parse infix operators properly.
20:32:29 <iqubic> Why is this so darn hard?
20:32:57 <MarcelineVQ> because it's your first time
20:33:40 <iqubic> yes. yes it is.
20:34:02 <wroathe> There's plenty of EBNF examples for simple math expression parsers online
20:34:04 <wroathe> http://matt.might.net/articles/grammars-bnf-ebnf/
20:34:19 <iqubic> What is EBNF?
20:34:28 <wroathe> You're trying to map your understanding of that to using haskell's parser combinators
20:34:41 <MarcelineVQ> iqubic. when your question fits on one line you ask google.
20:35:16 <AfC> Sometimes if you're having what you suspect is an infinite loop, ghci won't catch it / gets wedged. One thing to try is building to an executable binary. At least ^C will work. And it opens yhe avenue to stack traces if you become desperate.
20:36:34 <AfC> (for the benefit thay the deadlock detection seems to work slightly better)
20:38:17 <wroathe> http://math.pnw.edu/~rlkraft/cs31600-2012/chapter03/syntax-examples.html
20:38:23 <wroathe> This might be helpful
20:38:38 <iqubic> This is my first parser of any sort.
20:38:59 <wroathe> And EBNF: https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form
20:41:16 <geekosaur> also wrt ^C, with an executable you can use -fno-omit-yields which sometimes helps
20:41:52 <iqubic> Well, I don't know how to write a parser for recursive EBNF grammar.
20:42:06 <iqubic> I mean, one that doesn't loop infinitely.
20:42:45 <wroathe> Pasting the rest of your code might help us :D
20:43:33 <mniip> eliminate left recursion
20:43:40 <mniip> that's pretty much it
20:46:40 <iqubic> The main roadblock I'm running into is: `expr := expr, "-", expr`
20:48:58 <iqubic> For some reason I was able to write `func := String, "(", expr, ")"` without running into trouble anywhere.
20:49:21 <iqubic> So I could parse things like "sin(cos(tan(5)))" just fine.
20:49:40 <iqubic> With no infinite loop. It's minus that is screwing me up.
20:50:08 <iqubic> And maybe `func` is just a fluke, IDK.
20:50:57 <ski> that main roadblock appears to be left recursion
20:52:40 <iqubic> I'm not sure what that is, but I'm looking into it online.
20:54:39 <jdawgz959> Hi all, I am an experience dev and new to Haskell. I have been reading a book about Haskell for the past week and doing some exercises. I want to build a small app and I was thinking of building a basic web api with a relational db. Does anyone have any suggested resources for doing so?
20:55:10 <ski> the first thing `expr' does is attempting the parser `minus'. and the first thing `minus' does is attempting the parser `expr'
20:55:31 <jdawgz959> The purpose of doing so is to upskill in Haskell
20:55:53 <ski> and so it goes round and round, chasing its own tail, without ever possibly getting a parse error, since it never gets to consume any token (which might fail, on mismatch with what was expected)
20:55:57 <iqubic> ski: I get that there is an error there.
20:56:14 <nshepperd1> iqubic: If you had expr := expr that's obviously an infinite loop
20:56:26 <iqubic> right. I understand.
20:56:53 <nshepperd1> iqubic: with recursive descent, 'expr := expr, other stuff' is an infinite loop for much the same reason
20:57:42 <ski> let's say you wanted to parse `expr ::= expr + num | num', how would you solve that ?
20:58:33 <ski> (that's about as simple as this problem gets. i suggest attempting to solve something this simple, so you better understand the solution, before going back to what you actually want to parse)
20:58:45 <iqubic> I'm not sure how I would go about solving that.
20:58:52 <iqubic> It looks impossible.
20:58:53 <glguy> Is the answer 'use happy'?
20:59:00 * ski grins
20:59:09 <iqubic> glguy: I don't want to do that.
20:59:23 <iqubic> or, not right now.
20:59:57 <ski> let's say you get the input `2 + 3 + 5 + 7', and you want to build the parse result `Add (Add (Add (Lit 2) (Lit 3)) (Lit 5)) (Lit 7)'
21:00:09 <iqubic> expr ::= num + expr'
21:00:18 <ski> well, that's a good start
21:00:30 <iqubic> expr' ::= num | expr
21:00:36 <iqubic> I think. I'm not really sure.
21:00:43 <ski> however, that will get you `Add (Lit 2) (Add (Lit 3) (Add (Lit 5) (Lit 7)))'
21:01:12 <iqubic> Is that not what I want?
21:01:28 <ski> well, it's not the same thing as what i was asking about
21:01:29 <iqubic> Did I create a thing with the wrong associativity?
21:01:42 <ski> yes. imagine you had subtraction instead of addition
21:01:47 <ski> with addition, it matters less
21:02:07 <ski> is there a way you could "fix up" the associativity ?
21:02:36 <iqubic> expr ::= num + expr'
21:03:02 <iqubic> Wait... No my thing won't work.
21:03:16 <ski> (btw, your current version can't parse `42', but that's a valid token stream accepted by the original grammar)
21:03:53 <iqubic> Oh. I'm not sure how to fix the associativeity.
21:04:15 <iqubic> eliminating left recursion is hard.
21:04:23 <iqubic> Why is it called left recursion?
21:05:13 <ski> because the recursive "call" is immediately to the left (with no token preceding it)
21:05:18 <johnw> iqubic: http://www.personal.kent.edu/~rmuhamma/Compilers/MyCompiler/leftRecursion.htm
21:05:49 <ski> well, the problem is that you're attempting to parse something like `(((..(((a + b) + c) + d)..) + x) + y) + z' (iow that's the structure of the parse tree you want to get, given a token stream `a + b + c + d + ... + x + y + z')
21:07:16 <ar1a> i have a couple functions i want to test, maybe 8 functions, whats the recommended way of going about that
21:07:25 <ar1a> ive seen people recommend hunit, hspec, quickcheck
21:07:31 <ski> if you'd get something like `a + b + c + d + ... + x + y + z', in C, or Java, or Python, or whatever, and you just wanted to be able to parse something of this form (into the desired, left-leaning, tree/list), in an unprincipled way, how would you do it ?
21:10:21 <iqubic> Wait...
21:10:34 <iqubic> expr ::= num add
21:11:01 <iqubic> add ::= + expr
21:11:07 <iqubic> I think that works?
21:12:05 <iqubic> See, I'd check if there is a number at the start, and then keep going as long as the next bit is the `+` symbol followed by another expression.
21:12:22 <iqubic> I think that works.
21:12:33 <iqubic> ski: Is this right?
21:12:50 <iqubic> expr ::= num add | num
21:12:57 <iqubic> add ::= + expr
21:18:57 <AfC> jdawgz959: that's a great place to start!
21:19:43 <ski> iqubic : it's a good start :)
21:19:47 <AfC> jdawgz959: though I'd suggest keeping it as stock simple as you can for starters,
21:20:02 <ski> iqubic : that will only parse at most one `+', though
21:20:09 <iqubic> Why?
21:20:40 <ski> oh, right
21:21:09 <ski> yea, it can build `a + (b + c)'
21:21:21 <iqubic> But you are right the better way to do it is.
21:21:26 <ski> it can't build `(a + b) + c', though
21:21:34 <iqubic> expr ::= num add | num
21:21:47 <iqubic> add ::= + add
21:22:12 <ski> the `expr' in `+ expr' is the right operand of the addition symbol. it has nothing to do with the repetition of `+'s that we're trying to capture at the moment
21:22:35 <AfC> jdawgz959: there are any number of gotchas. First thing I ever did was a little URL redirector. I wasted lots of time doing things the hard way
21:22:48 <ski> this is why i suggested concentrating on the grammar `expr ::= expr + num | num' at the start, and not `expr ::= expr + expr | num'
21:23:20 <ski> iqubic : `add ::= + add' is perhaps closer, but not right there
21:23:27 <iqubic> Why not?
21:23:31 <ski> iqubic : now your parser can parse `a + + + + +'
21:23:45 <ski> (`a' being an arbitrary numeric literal, a numeral)
21:23:47 <iqubic> Oh, right..
21:26:28 <ski> `add', given `add ::= + num', represents a *single* addition of a `+' token, and a numeral
21:27:08 <iqubic> expr ::= num add | num, add ::= + expr add
21:27:20 <iqubic> I think that's better, but I'm really not sure.
21:27:22 <ski> getting better :)
21:27:29 <iqubic> HUH?!?!
21:27:32 <ski> but `add' has no base case
21:27:48 <iqubic> expr ::= num add
21:27:49 <ski> it always parses infinitely many `+'&numeral pairs
21:28:23 <ski> (well, expression, not numeral, in your case, since you used `expr' to the right of `+', not `num', which was in my original specification)
21:29:13 <iqubic> expr ::= num add | num
21:29:15 <iqubic> add ::= + num add | ɛ
21:29:29 <ski> good good
21:29:38 <ski> now, factor the first rule like
21:29:39 <iqubic> Where ɛis the empty string.
21:29:49 <ski>   expr ::= num (add | ɛ)
21:30:04 <iqubic> And then what is add?
21:30:32 <ski> but note that `add' already can succeed, accepting the empty string. so `add | ɛ' is just `add', so `expr' is defined by
21:30:37 <ski>   expr ::= num add
21:30:59 <iqubic> But then what is `add' in that cass?
21:31:03 <ski> (keeping the same definition of `add')
21:31:50 <iqubic> add ::= + num add | ε
21:32:00 <ski> yes
21:32:01 <ski> so, you've succeeded, this is the left-recursion-eliminated form of `expr ::= expr + num | num' ! :)
21:32:52 <ski> now, what's left to do, is figuring out how to translate this into parser combinators (easy), and figuring out how to generate the proper, expected (left-associated) parse tree (perhaps requiring a bit more thought)
21:33:09 <iqubic> And this grammar parses like "a + b + c + d" -> "(((a + b) + c)+ d)"
21:33:19 <ski> yes, that's the intention
21:33:53 <iqubic> What does left associated mean? I always mix up left and right ssociativity.
21:33:54 <ski> and if you replace the `num' in the `add' clause with `expr', it should also be able to (ambiguously) parse that token stream as `(a + b) + (c + d)' (e.g.)
21:34:11 <iqubic> I was planing on doing that, yeah.
21:34:15 <mniip> iqubic, left assoc ~~ foldl
21:34:23 <iqubic> Meaning???
21:34:24 <ski> `((a + b) + c) + d' is left associated, the tree "leans to the left"
21:34:31 <iqubic> I see.
21:34:34 <mniip> well do you know the difference between foldr and foldl
21:34:38 <iqubic> yes.
21:34:39 <iqubic> I do.
21:34:45 <ski> > foldl1 (**) [a,b,c,d]
21:34:47 <lambdabot>  ((a**b)**c)**d
21:34:50 <mniip> idk I always remember which direction foldr codes
21:34:52 <mniip> goes*
21:35:16 <iqubic> So now, how would I parse something that is right associative in the right manner?
21:35:47 <ski> as before
21:36:02 <iqubic> So that I get "a + b + c + d" -> "a + (b + (c + d))"
21:36:09 <iqubic> What do you mean, as before?
21:36:23 <ski> no special precaution is needed
21:36:44 <iqubic> Really, why not?
21:36:53 <iqubic> is that just:
21:37:13 <iqubic> expr ::= num + expr | num | ε
21:37:14 <iqubic> ??
21:37:32 <iqubic> I suppose it is. Isn't it.
21:37:39 <ski> only in the left associative case here do we get left recursion, which is problematic with recursive descent parsers (as opposed to bottom-up parsing like yacc,happy, in which left recursion is preferable to right recursion, which nonetheless isn't problematic in the same way)
21:38:00 <ski> yes (except no `ε'. it doesn't make sense therE)
21:38:14 <iqubic> Why doesn't ε make sense there?
21:38:29 <ski> an empty numeric expression doesn't make much sense
21:38:40 <ski> `2 +' doesn't make much sense as a numeric expression, either
21:38:43 <iqubic> Oh right... because having ε make "1 +" a valid parse.
21:38:53 <iqubic> Well, time to go code this up.
21:39:27 * ski would typically call the parser for  add  above,  return'
21:39:30 <iqubic> I have a feeling that this is going to create a lot of thunks during the parsing process.
21:39:40 <iqubic> Why return'?
21:39:53 <ski> if you try it, you may see
21:40:05 <ski> (one could also call it `exprRest', e.g.)
21:44:33 <iqubic> translating this into megaparsec is hard.
21:45:36 <iqubic> I have a data constructor of the type `Sub :: Expr -> Expr -> Expr' and I'm not sure how do things correctly.
21:45:49 <iqubic> I also have a function `num' which parses a number.
21:46:19 <ski> do you see how to translate `expr ::= num add' ?
21:47:19 <iqubic> Sure. I'll just use a where clause.
21:48:24 <iqubic> http://dpaste.com/1C3B056
21:48:25 <ski>   expr = do ...  -- ?
21:48:25 <ar1a> hi, i have a Main module in Main.hs, and i have a file called Test.hs. Test.hs can't see any of the functions that are declared in the Main module, and it's throwing me an error if I try and import Main. how can I get my test file to see my functions?
21:48:30 <iqubic> have that so far.
21:49:23 <ski> iqubic : well, the grammar you have in the comment is not the grammar we ended up with in the end, above
21:49:24 <iqubic> http://dpaste.com/0PN7K1H
21:49:40 <iqubic> It isn't???
21:50:00 <iqubic> I just changed it to be subtraction. Is there something else I missed?
21:50:01 <ski> check the `expr' production rule
21:50:46 <iqubic> Right.
21:51:25 <iqubic> http://dpaste.com/1D58JMF -- I hope this is better.
21:52:26 <ski> better, but not there still
21:52:46 <ski> check what i said after "now, factor the first rule like", above
21:53:44 <ski> (you don't have to rename the grammar rule if you don't want to. that's not the point i was objecting to)
21:54:10 <iqubic> http://dpaste.com/2JEJ56W
21:54:18 <ski> ar1a : you should probably state the error you get (and then also possibly what you tried to get that error)
21:54:44 <iqubic> ski: What now?
21:55:05 <ski> iqubic : also read the following couple of lines above, again
21:55:20 <ski> s/following/subsequent/
21:55:25 <ar1a> ski: Module imports form a cycle:
21:55:27 <ar1a>   module ‘Main’ (Test.hs) imports itself
21:55:46 <ar1a> test.hs has `import Main` in it and main.hs never imports or even references test.hs
21:55:52 <ski> ok, so `Main' imports `Test' (that wasn't obvious from what you said, before)
21:56:08 <ar1a> main doesn't
21:56:24 <ski> hm, ok. sorry, i misread then
21:56:59 <ar1a> thats why im so confused
21:57:25 <iqubic> http://dpaste.com/29E9SFW
21:57:29 <ski> right, i think this is because you're trying to compile `Test.hs' as an executable, and in that special case, the main file will always be a module called `Main', even if the file isn't called `Main.hs'
21:57:49 <iqubic> There we go. Still not sure where to go from there.
21:58:20 <ar1a> alright, how can i not compile it as executable?
21:59:10 <ski> well, possibly you can use `runhaskell' or `runghc' instead
21:59:54 <ar1a> i got the same error with runhaskell
21:59:57 <ski> another thing which i think would work would be if you put the mean of the code in `Main.hs' into a separate file, which you then import both into `Main.hs', and into `Test.hs'. then you could compile them into separate executables, if you want to
22:00:06 <ski> iqubic : ok
22:00:13 <ar1a> hm i might have to do that
22:01:16 <ski> iqubic : now note how `expr ::= num sub' has two nonterminals to the right of the `::='. so just one command (not counting `return sub', which is a no-op action, only giving back `sub' as a value) won't suffice
22:01:34 <ski> iqubic : you need to run two parsing actions in a row
22:02:01 <iqubic> are you saying that `sub' needs a do block?
22:02:23 <ski> that's not what i'm saying, though that would be true as well, yes
22:02:44 <iqubic> Oh.
22:02:51 <iqubic> What are you saying?
22:03:01 <ski> to begin with, aim at having two `<-'s in the main `do'-expression of `expr'
22:03:33 <ski> (then, if you want to, you could perhaps do some simple optimization at the end, to omit one of them, letting it "implicitly return its value")
22:03:52 <iqubic> http://dpaste.com/0DHDEW4
22:04:20 <iqubic> Why do I need 2 `<-'s in the main do block of minus?
22:05:08 <ski> because there's two nonterminals to the right of `::=' in the production rule for `expr', namely `expr ::= num sub' : there's both `num' and `sub' there, you need a parsing action for each of them
22:05:39 <iqubic> I thought `return sub' WAS the second parsing action.
22:05:45 <ski> `return sub' won't parse anything (it would also be a type error)
22:05:56 <iqubic> right.
22:06:18 <ski> `return (...)' always is a no-op, never performing any effect (in your case, a parsing effect, since you're in a parsing monad)
22:06:40 <iqubic> http://dpaste.com/1BEDR5Z
22:06:58 <ski> that's better
22:07:01 <iqubic> I'm using symbol, because that deals with whitespace for me.
22:07:08 <iqubic> I'm not sure where to go from there.
22:07:37 <iqubic> At some point I need to make a call to my AST construct Sub.
22:07:49 <ski> perhaps you could try to fill in `sub' more, if you want to. or perhaps there's something else you'd like to adjust
22:07:59 <ski> yes, a very good observation
22:08:28 <iqubic> `num' returns a thing of Parser Expr. And `Sub' has type Expr -> Expr -> Expr
22:09:15 <ski> oh, so `num' doesn't have type `Parser Integer' or something, then ?
22:09:41 <ski> (i'm assuming something like `data Expr = Lit Integer | Sub Expr Expr')
22:10:23 <ski> (so that the parser `minus' would also include the data constructor `Lit' somewhere. but perhaps you prefer to put that inside `num' itself)
22:10:31 <iqubic> Well, Double but yes.
22:10:44 <ski> *nod*, same thing
22:11:04 <iqubic> ski: `num' already has the Lit constructor applied when it returns.
22:11:15 <ski> ok, fair enough
22:11:45 <iqubic> So I can take arg1 and pass it as a parameter to Sub and everything would work just fine.
22:11:47 <ski> (depending, that might not always be the best organization of things. but it probably doesn't matter here)
22:12:00 <iqubic> I don't really care right now.
22:12:09 * ski nods
22:12:12 <iqubic> I just want to write this function here.
22:12:17 <ski> mhm, how would that look like, in code ?
22:12:25 <iqubic> IDK what to do with that hole in sub.
22:12:29 * hackage hasbolt-extras 0.0.0.15 - Extras for hasbolt library  https://hackage.haskell.org/package/hasbolt-extras-0.0.0.15 (ozzzzz)
22:13:23 * ski waits for more feedback
22:14:00 <iqubic> What more do you want?
22:14:14 <ski> <iqubic> So I can take arg1 and pass it as a parameter to Sub and everything would work just fine.
22:14:20 <ski> did you have an idea in mind, for that ?
22:14:23 <iqubic> No.
22:14:26 <iqubic> Not really.
22:14:32 <ski> well
22:14:43 <ski> look at `sub ::= - sub num | ε', then
22:15:03 <iqubic> I see that.
22:15:07 <ski> the first alternative starts with a token `-', which you have translated into a call to `symbol', which is fine
22:15:14 <ski> next you have two nonterminals
22:15:31 <ski> can you translate them into corresponding code as well, as you did before ?
22:15:39 <iqubic> Sure.
22:16:23 <ski> so far, this is mostly straight-forward, mechanical translation of your grammar rules
22:16:49 <ski> (there will come an interesting point, probably. but not quite yet)
22:17:21 <iqubic> Not sure I found the best names for things.
22:17:27 <iqubic> But here is this: http://dpaste.com/23D7DAG
22:17:28 <ski> don't worry about that
22:18:07 <iqubic> Also, I've been thinking this for a while, but I'm fairly certain `sub' needs a parameter.
22:18:19 <ski> oh, actually i just noticed a discrepancy with the version i suggested a bit up
22:18:26 <iqubic> Oh?!
22:18:42 <ski> (nothing very big. a simple mistake)
22:18:56 <iqubic> Care to tell me?
22:19:17 <ski> you have written `sub ::= - sub num | ε', while i derived
22:19:36 <ski> well, actually, you derived :)
22:19:43 <ski> <iqubic> add ::= + num add | ε
22:20:00 <ski> see the small but important difference ?
22:20:06 <iqubic> Yeah. Yes.
22:20:17 <iqubic> That solves a few mysteries.
22:20:52 <ski> now that that small matter is out of the way, i can say that your hunch seems to be homing in on the target :)
22:22:25 <iqubic> I think I have something.
22:22:48 * ski nods and smiles
22:23:42 <iqubic> Well, it doesn't work quite right. But it also isn't an infinite loop either.
22:24:00 <ski> well, let's see it ?
22:24:52 <iqubic> http://dpaste.com/03YNC9K
22:25:43 <ski> you've mostly got it ! :)
22:26:05 <iqubic> Also, I think this is right associative actually, now that I look at it.
22:26:07 <ski> the argument of `sub' is an accumulator, "what we've parsed, so far"
22:26:19 <ski> or, anyway, it's supposed to be an accumulator
22:26:41 <iqubic> Is it not an accumulator now?
22:26:45 <ski> it's initialized with the initial numeral, so if we have `a + b + ... + y + z', it's initialized with the parse tree for `a'
22:26:56 <iqubic> I have my Sub constructor in the wrong place.
22:28:07 <ski> then, when you've eaten the part from `a + b + ... + k + l + m', say, and that's in `arg', and you eat a token `+', and a further numeral `n', then what should you pass on as "currently parsed intermediate result", to the recursive `sub' call ?
22:28:37 <iqubic> http://dpaste.com/1FTCK83
22:29:08 <ski> right, you pass the `Sub' thing on to the recursive call to `sub' !
22:29:26 <ski> and then whatever that returns in the end, is also the parse tree you give
22:29:35 <ski> (and so you don't need the `<-' at the end there, yes)
22:29:37 <iqubic> Alright... Well, I'm not sure what tools megaparsec has that would let me test this.
22:29:52 <ski> now, you're still missing the other alternative of `sub'
22:30:16 <iqubic> Oh, right... That might be why my tests have failed. LOL.
22:30:51 <ski> (also, if you want to, you could avoid that `let', and directly pass the newly constructed pare tree (or abstract syntax tree, rather) node to `sub')
22:31:10 <iqubic> My tests reach the end of the input stream before the base case of the recursive calls to sub.
22:31:15 <iqubic> ski: I already did that.
22:31:34 <ski> fine (just that wasn't in the last paste)
22:31:52 <iqubic> I know.
22:32:08 <iqubic> I don't feel the need to paste every small incremental thing I do.
22:32:16 * ski nods
22:33:06 <iqubic> Now, how does Megaparsec let me handle the base case.
22:33:11 * ski imagines an emacs mode which would update a gist (or whatever) after every keypress in the buffer
22:33:35 * iqubic is using emacs right now.
22:33:47 <ski> (or maybe that's called collaborative editing ?)
22:34:14 * iqubic things such a mode would be slow since emacs lisp lacks proper threads
22:34:28 <ski> (quite possibly)
22:34:28 <iqubic> So about that empty string case.
22:34:43 <ski> how do you express alternatives, in Megaparsec ?
22:34:52 <iqubic> <|>
22:35:08 <iqubic> Same as any other member of the Alternative type class.
22:35:16 <ski> empty string means zero terminals and zero nonterminals
22:35:42 <ski> so you just need to specify an appropriate return value, no parsing effect TBD
22:35:42 <iqubic> Sure.
22:36:13 <iqubic> I'm not sure what I should use as the return value?
22:36:25 <ski> well, what do you have to work with ?
22:37:09 <ski> (perhaps you could think of scanning `a + b + ... + y + z' again, from left to right, keeping track of a current parse tree as you go)
22:37:46 <iqubic> I have the current AST.
22:38:03 <iqubic> I can just return the current AST when I find the end of the string.
22:38:32 <iqubic> But I'm not sure how.
22:38:40 <iqubic> http://dpaste.com/1928083
22:38:51 <ski> base case in this case is when there's no more input to be "added on top" of your current tree, when you've reached end of the relevant input
22:39:29 <iqubic> Cool. So, how do I check for that with Megaparsec?
22:39:49 <ski> you don't check, you just write another alternative
22:40:04 <iqubic> And what does that alternative do?
22:40:23 <ski> parse nothing, corresponding to the branch `ε'
22:40:49 <iqubic> Right.
22:41:37 <iqubic> Not sure of the best way to format this, but...
22:41:50 <iqubic> http://dpaste.com/152DHHW
22:42:41 <ski> i would put `<|> ...' on a new line, indented less than the previous lines
22:43:17 <iqubic> Indeted less gives me a compiler error.
22:44:11 <iqubic> In fact... It says: `parse error: <|>'
22:44:29 <iqubic> or rather, parse error on input.
22:44:48 <amalloy> there's not a lot of room to be to the right of sub but to the left of the do statements
22:45:17 <ski> it needs to be indented more than `sub acc = ...', still
22:45:57 <iqubic> http://dpaste.com/2F961A3
22:46:00 <ski> (so "indented less than the previous lines" in this case means that it may be a good idea to increase the indentation of those previous lines)
22:46:40 <iqubic> http://dpaste.com/17AQ0MM
22:47:48 <amalloy> could avoid the do if you wanted, with applicative style: sub acc = try (symbol "-" *> (sub . Sub acc <$> num)) <|> return acc
22:49:23 <ski> well, i suppose this is the point where i would possibly replace  sub  with  return'
22:49:36 <ski> (in the code, not in the grammar rules in the comment)
22:50:03 <iqubic> why return'?
22:50:35 <ski> it looks suggestive, to me
22:50:39 <iqubic> I see.
22:51:00 <ski> it's like we want to return `first', respectively `Sub acc next'
22:51:35 <ski> except that we want to insert an indeterminate amount of parse tree levels above (and to the right) of the thing we "return"
22:51:47 <ski> which is what our  return'  /  sub  does
22:52:21 <ski> if you prefer, you can use `sub' or `minusRest', or something like that
22:53:11 <ski> anyway, i'm impressed that i didn't even have to give a hint that `sub' might want an argument, you figured that out from the available data of the situation ! :)
22:53:19 <iqubic> amalloy: That doesn't type check.
22:54:05 <ski> s/<$>/=<</
22:54:58 <dminuoso> Is there a deeper reason why arrows like `a -> f a` for some Functor/Applicative f are so powerful? This is such a repetitive theme in lens..
22:55:54 <iqubic> Nice.
22:56:21 <iqubic> http://dpaste.com/1BM4KAK
22:56:23 <slack1256> dminuoso: Because you can choose the `f` at use time, which depending of the `f` defines if it is Getter, Setter, Fold, Traversable
22:57:21 <ski> iqubic : so, now you've got the basic technique down your belt
22:57:34 <iqubic> Yeah.
22:58:08 <iqubic> Can I just add `try minus' to this list of things or not?
22:58:09 <iqubic> http://dpaste.com/16XCSXP
22:58:23 <dminuoso> slack1256: Sure, but why is it that Functor/Applicative is so rich/powerful to describe all this? Is there a notion of computational power of functors in Set?
22:58:51 <ski> try it ?
22:59:32 <iqubic> But if I do that, and change minus with s/num/expr/ then I might get infinite loops again.
22:59:50 <ski> depends on which `num's you change
22:59:56 <iqubic> Does it?
22:59:59 <ski> recall
23:00:06 <ski>   expr ::= expr + num | num
23:00:11 <iqubic> Yes.
23:00:12 <ski> this became
23:00:24 <ski>   expr ::= num expr_rest
23:00:38 <ski>   expr_rest ::= + num expr_rest | ε
23:00:42 <iqubic> sure.
23:00:47 <ski> similarly, if you start with
23:00:54 <ski>   expr ::= expr + expr | num
23:00:58 <ski> it will become
23:01:03 <ski>   expr ::= num expr_rest
23:01:09 <ski>   expr_rest ::= + expr expr_rest | ε
23:01:22 <ski> the only changed part is that `+ num' is now `+ expr'
23:01:32 <iqubic> but won't that be infinite recursion?
23:01:52 <ski> it doesn't matter that there's a recursive "call" to `expr' in `+ expr', since it's not left recursion, it's not the first thing, it's preceded by the token `+'
23:02:32 <ski> (but of course you should not change `expr ::= num expr_rest' into `expr ::= expr expr_rest' .. *that* would screw you up !)
23:04:47 <iqubic> But in that case I want to make sure that `num' is tried before `num expr_rest'
23:05:02 <ski> i don't know what you mean
23:05:13 <ski> `num expr_rest' already tries `num'
23:05:16 <iqubic> Right.
23:05:24 <iqubic> Ignore me.
23:05:36 <ski> and `expr_rest' can succeed, while eating nothing. so `expr' can already parse a single `num'
23:05:45 <iqubic> Right...
23:06:00 <ski> (at least if you keep that `try'. without that, i think it would try maximal munch)
23:06:21 * ski is generally annoyed by `try'
23:08:55 <iqubic> Why don't you like try?
23:09:35 <iqubic> Also: let's add more parameters to make it easy to define things like +, -, *, and /.
23:09:36 <iqubic> http://dpaste.com/1AAFT6A
23:11:11 <ski> s/sub/expr_rest/
23:12:24 <iqubic> In the comment, yeah.
23:12:31 <ski> instead of passing a `T.Text' and an `Expr -> Expr -> Expr', you could possibly pass a `Parser (Expr -> Expr -> Expr)'
23:13:14 <ski> which will itself parse the operator token, and yield back the corresponding operator data constructor
23:13:28 <ski> that way, it could possibly also handle multiple cases
23:13:42 <iqubic> What do you mean by multiple cases?
23:15:08 <iqubic> But if do that then it ruins my nice and perfect do free code.
23:15:28 <ski> well, `symbol char' is just one operator alternative, no ?
23:15:33 <iqubic> Sure.
23:16:17 <iqubic> There we go.
23:16:20 <iqubic> http://dpaste.com/129Z127
23:16:59 <ski>   return' <=< (($ acc) <$> op) =<< expr  -- i think ?
23:17:07 <iqubic> Huh??
23:17:11 <iqubic> How???
23:17:20 <ski> assuming `op :: Parser (Expr -> Expr -> Expr)'
23:17:37 <ski> hm, wait
23:19:04 <iqubic> No. Not that at all.
23:19:26 <ski> yea, i realized :/
23:19:28 <iqubic> That has many errors.
23:20:12 <ski> this looks ok with `do'. but perhaps not that great, without
23:20:54 <iqubic> Did you not see my paste?
23:21:03 <iqubic> http://dpaste.com/129Z127
23:21:20 <ski> hm, no i missed it
23:21:54 <iqubic> Well, that's what I did.
23:22:11 <iqubic> I thought you were trying to remove the lambda.
23:24:59 <ski>   return' =<< (($ acc) <$> op <*> expr)
23:26:23 <iqubic> How does that work>
23:26:39 <iqubic> I don't understand what ($ acc) does.
23:27:17 <ski> oh, the outer brackets are redundant
23:27:20 <ski> well
23:27:28 <Ariakenom> :t ($ 1)
23:27:29 <lambdabot> Num a => (a -> b) -> b
23:27:38 <ski> > map ($ 3) [(2 +),(2 *),(2 ^)]
23:27:41 <lambdabot>  [5,6,8]
23:27:53 <iqubic> :t ($)
23:27:54 <lambdabot> (a -> b) -> a -> b
23:28:00 <ski> @src $
23:28:01 <lambdabot> f $ x = f x
23:28:21 <ski> `($ 3)' is the function that, given a function as input, applies it to the input `3'
23:28:24 <iqubic> So we are providing the argument, and then mapping over a list of functions.
23:28:35 <ski> yes
23:28:41 <iqubic> Seems rather backwards.
23:29:23 <ski> so in `($ acc) <$> op <*> expr', we're providing the first input `acc' to the function that the parser `op' will yield back, then applying the remaining function to the argument that the parser `expr' yields back
23:29:45 <iqubic> And then we shove that into return' as a result?
23:29:54 <ski> yea
23:30:19 <ski> i think it's relatively reasonanble. perhaps you don't like the "backwardness" of it, though
23:30:35 <iqubic> I want to appreciate it.
23:30:52 <iqubic> op >>= (\constr -> return' . constr acc =<< expr)
23:31:00 <iqubic> (return' =<< ($ acc) <$> op <*> expr)
23:31:11 <iqubic> Those two do the same thing basically.
23:31:59 <ski> in any case, you could do stuff like `binOp (Add <$ symbol '+' <|> Sub <$ symbol '-')', i think
23:33:16 <ski> (well, probably one should use double quotes with the literals passed to `symbol')
23:34:16 <iqubic> One must.
23:34:44 <iqubic> symbol only accepts T.Text, and I have overloaded strings.
23:35:46 * ski isn't sure where this `symbol' is from
23:35:55 <trcc> There is absolutely no functional jobs what so ever in my city it seems like :(
23:36:36 <trcc> not even a meetup
23:36:46 <dminuoso> trcc: What city is that?
23:36:52 <trcc> Aarhus, Denmark
23:37:38 <suzu> are you open to moving?
23:37:47 <iqubic> ski: I wrote my own function that parses a T.Text and then strips the following whitespace.
23:37:55 <trcc> just bought house, 2 children aged 0 and 2 years, not currently suzu :)
23:38:08 <trcc> didn't expect to get so hooked on this functional wave
23:39:08 <suzu> ah true
23:39:14 <suzu> well you could try looking for remote jobs i guess
23:39:32 <trcc> that is always an option.. and I have considered it a lot.. I think I will miss the social aspect
23:40:11 <suzu> yeah not much to be done about that
23:40:17 <suzu> you could fly in occasionally but it isnt the same
23:41:05 <Ariakenom> time to open up a company then, good luck
23:42:55 <trcc> Ariakenom: I have actually done exactly that! Takes time to make enough money to go full time. Think i'll finish med hobby haskell project and try to find a open source project with some good knowledge sharing
23:47:03 <Ariakenom> Nice! Hope you get to hire other haskell starved Aarhusers :)
23:49:27 * ski . o O ( #haskell.scandinavian , #haskell.se , #haskell.no )
23:49:44 <trcc> Ariakenom: I hope so too :)
23:50:33 <trcc> ski: thanks!
23:51:46 <ar1a> how do you quickcheck for IO? I've found a few examples on file io but none for stdin/out. i'm trying to test a readline program!
23:52:32 <ski> (apparently there's also a #haskell-de, not sure which country or language that is)
23:52:42 <trcc> germany
23:52:46 <trcc> deutschland
23:54:32 <ski> ok, right
