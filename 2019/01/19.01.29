00:04:00 * hackage reflex 0.5 - Higher-order Functional Reactive Programming  https://hackage.haskell.org/package/reflex-0.5 (luigy)
00:17:50 <dminuoso> % let a = (showHex (ord '\0127') "foo") in ('\' : a)
00:17:50 <yahb> dminuoso: ; <interactive>:107:46: error: lexical error in string/character literal at character ' '; (0.01 secs,)
00:17:57 <dminuoso> Heh, took me a while to figure out what went wrong there. :)
00:56:20 <kmelvn> I'm using `stack build --file-watch --fast` to rebuild on file change -- is there a flag to clear the screen of the previous build?
01:02:54 <Athas> Does anyone have experience statically linking Haskell when using stack?  If I do "stack build --ghc-options='-optl-static -optl-pthread'", then I eventually get the error "/usr/lib/gcc/x86_64-linux-gnu/7/crtbeginT.o: requires dynamic R_X86_64_32 reloc against '__TMC_END__' which may overflow at runtime; recompile with -fPIC"
01:03:10 <Athas> (Just adding -fPIC to the --ghc-options does not help.
01:05:23 <Unhammer> anyone know if brittany can be configured to do the vertical layout thing that https://memfrob.de/posts/announcing-floskell/ does? (I like putting $'s under each other when there's more than one in a line, instead of very long horizontal lines)
01:07:24 <dminuoso> Athas: Although I dont like linking SO in general, can you check whether the two answers apply to your problem? https://stackoverflow.com/questions/41419102/haskell-stack-static-binary-relocation-r-x86-64-32-against-tmc-end-can-not
01:15:16 <Athas> dminuoso: thanks, the first answer worked!  (Although the linker spews lots of warnings.)
01:16:35 <dminuoso> Athas: can you revert add `-v` to the options and gist the output? Im curious as to what gcc is receiving on your end.
01:19:09 <Ferdirand> I'd like to use hoist over the RandT from monad-random, but it doesn't implement MFunctor, and it doesn't export its data constructor (but it does implement MonadTrans)
01:19:31 <Ferdirand> any idea how I can coax it into doing so ?
01:31:38 <dminuoso> > length "\256"
01:31:40 <lambdabot>  1
01:35:29 * hackage magico 0.0.1.2 - Compute solutions for Magico puzzle  https://hackage.haskell.org/package/magico-0.0.1.2 (HenningThielemann)
01:40:18 <davean> Ferdirand: mapRandT?
01:41:37 <Ferdirand> davean: aha.. i was reading obsolete doc
01:44:21 <merijn> Ferdirand: Which browser do you use? Chrome has a hackage extension that notifies you of that :p
01:44:43 <Ferdirand> chromium. That's a nice idea, thanks :)
01:44:52 <merijn> Hackage-Fu
01:45:36 <Ferdirand> so, latest MonadRandom i'm not sure has MFunctor, but it has liftRand so I know at least one way to write this. good.
01:46:00 <merijn> Similarly neat, there's an extension "Module Linker" which links module imports on github to Hackage
01:46:53 <Ferdirand> ah, and mapRandT does exactly what I want. Thanks davean.
01:46:57 <Ferdirand> phew
01:47:10 <davean> yes yes it does ;)
01:56:18 <Athas> dminuoso: https://paste.fedoraproject.org/paste/PkfmyaRMgksJdSmuk-F~Tw
01:56:23 <Athas> That must be pushing up against some command line limits!
02:00:30 * hackage servant-pagination 2.2.0 - Type-safe pagination for Servant APIs  https://hackage.haskell.org/package/servant-pagination-2.2.0 (KtorZ)
02:04:02 <merijn> Athas: On linux the default limit is like 4MB, so...
02:09:10 <dminuoso> Athas: Yeah indeed the SO theory applies to you. Both -shared and -static are passed, and apparently -static wins the race there.
02:11:08 <dminuoso> It's mildly amusing that GCC has these kinds of "you get the weirdest linker errors creeping up if you pass a flag combination that cant possibly work and could easily be caught by the option parser/early option semantic analysis pass"
02:13:29 <Athas> GCC extends the notion of undefined behaviour to even its command line option language.
02:15:22 <dminuoso> Athas: For what its worth, Haskells version of "undefined behavior" is bottom.
02:16:07 <dminuoso> Yesterday I learned why decodeUtf8 was a terrible function.
02:16:29 <dminuoso> For months I have been telling people to use readMaybe, but didn't realize I was using decodeUtf8 myself..
02:16:46 <merijn> dminuoso: decodeUtf8' is where it's at :p
02:17:24 <Athas> For my program, the difference between dynamic and static linking is a 63MiB binary and a 66MiB binary.
02:17:28 <Athas> Static linking seems an easy win.
02:17:40 <dminuoso> merijn: Yeah, many of my projects have received commits like "Add better unicode handling for improper bytesequences." - was up all night fixing code..
02:17:47 <merijn> Athas: Have you tried stripping?
02:18:12 <Athas> merijn: makes no difference for the dynamic one, and I've thrown away the static one now.
02:18:15 <merijn> dminuoso: "decodeUtf8With lenientDecode" and let the user deal with it :p
02:18:24 <sayola> Blaze or Lucid? Has someone experience with both to give a recommendation?
02:18:30 <dminuoso> merijn: Haha is that a thing?
02:19:10 <merijn> dminuoso: Yes, if you don't wanna deal with "Either" there's several OnDecodeError handlers in Data.Text.Encoding
02:19:38 <merijn> dminuoso: It replaces any invalid bytes in the input with U+FFFD
02:19:44 <dminuoso> merijn: Well that's great actually. I think in my usecase it's actually the right thing to do.
02:20:04 <merijn> dminuoso: aka the official replacement character for missing glyphs/wrong characters
02:20:23 <merijn> dminuoso: So your users will just get bunches of ï¿½ if they feed invalid UTF-8
02:20:47 <dminuoso> merijn: I feel like decodeUtf8 should be tossed out, just to force you to make such a function from decodeUtf8With and make the choice explicit.
02:20:48 <merijn> You can provide custom replacements or dropping versions via decodeUtf8With too
02:20:59 <merijn> dminuoso: "But backwards compat!!"
02:21:09 <dminuoso> merijn: :|
02:21:34 <dminuoso> Just like `instance IsString ByteString` needs to be undone.
02:21:35 <merijn> decodeUtf8 is just a synonym for "decodeUtf8With strictDecode"
02:21:52 <merijn> dminuoso: decodeUtf8 is considerably better defined than IsString
02:21:54 <dminuoso> merijn: yeah precisely, it's just a short line that you can drop somewhere in your project if you need it frequently.
02:22:03 <merijn> dminuoso: At least decodeUtf8 properly errors out
02:22:17 <dminuoso> merijn: depending on how you define "properly" though.
02:22:42 <dminuoso> merijn: In my case lazyness deferred the error into a hard to debug scenario, had to do a bit of digging to find where it came from.
02:24:13 <dminuoso> `throw` is not a proper mode of error handling.
02:39:46 <tdammers> the problem with undoing instance IsString ByteString is that there are too many pseudo-textual protocols and file formats out there, for which having a convenient way of writing bytestring literals as string literals is just too damn convenient
02:40:52 <tdammers> a more elegant solution, I think, would be to have a separate type of literals only for bytestrings
02:41:05 <tdammers> accompanied by a separate typeclass to convert from those
02:41:45 <Athas> Erlang's binaries are something you always end up missing when working with protocols.
02:41:48 <kadoban> Sounds like a lot of work to avoid just having a name for the converter function and using that
02:43:43 <dminuoso> kadoban: With every year of programming I learn more and more that explicit is often better than implicit.
02:43:52 <kadoban> For this I'd definitely think so
02:43:54 <maerwald> dminuoso: go write more python :)
02:44:50 <kadoban> For something like Text, sure, IsString makes total sense, but ByteString and it gets too implicit for me.
02:45:52 <dminuoso> kadoban: Whats worse, the default is a really bad one.
02:46:27 <kadoban> What even does it do, just ASCII and ... what make total nonsense out of anything not ASCII?
02:47:13 <dminuoso> % :set -XOverloadedStrings
02:47:14 <yahb> dminuoso: 
02:47:20 <dminuoso> % a :: ByteString; a = "fÎ»"
02:47:20 <yahb> dminuoso: ; <interactive>:110:6: error:; Not in scope: type constructor or class `ByteString'; Perhaps you meant one of these: `BSL.ByteString' (imported from Data.ByteString.Lazy), `BS.ByteString' (imported from Data.ByteString), `IsByteString' (imported from Data.ByteString.Lens); (0.01 secs,)
02:47:26 <dminuoso> % import Data.ByteString
02:47:26 <yahb> dminuoso: (0.01 secs, 0 bytes)
02:47:33 <dminuoso> % let a :: ByteString; a = "fÎ»" in a
02:47:33 <yahb> dminuoso: "f\187"; (0.02 secs, 155,128 bytes)
02:47:38 <dminuoso> This is truly wonderful.
02:47:46 <kadoban> Ew
02:48:16 <kadoban> Yeah, that's like begging for silent errors that are fun to find.
02:48:38 <dminuoso> % let a :: ByteString; a = "fðŸƒŸ" in a
02:48:38 <yahb> dminuoso: "f\223"; (0.02 secs, 155,128 bytes)
02:48:44 <dminuoso> kadoban: Yup. :)
02:52:55 <Gurkenglas> For backtracking, it might sometimes be useful to mutate an array, recurse, and undo the mutation afterwards instead of copying the array and recursing. Is there library support for this?
02:58:19 <gentauro> Gurkenglas: any blogpost on this approach?
02:58:52 <dminuoso> gentauro: Do you need to be able to do IO freely? Or is it fine if those actions are somehow constrained to reversible ones?
02:59:00 <kmelvn> Anyone here using tmux and `send-keys` command to operate a running GHCi? Maybe from Vim...
02:59:18 <dminuoso> Ops. Tab completion mishap, I meant Gurkenglas.
02:59:26 <gentauro> :D
03:01:20 <Gurkenglas> dminuoso, no IO needed, what sort of reversibility do you mean? I expect it would keep the old elements in thunks until the recursion is finished
03:02:42 <Gurkenglas> gentauro, dunno i just thought it up
03:02:57 <Gurkenglas> thats why im asking whether a library has done prior work on this
03:05:11 <Gurkenglas> i think i did it manually once a few years back in java because it was useful for an assignment?
03:06:22 <kadoban> If the constants don't matter much, you could just use an IntMap or something, that's already persistent. For an actual array, I think there's a persistent array library around here somewhere, trying to remember what it's called.
03:07:12 <Gurkenglas> i didn't say anything about persistency ._.
03:07:48 <dminuoso> Gurkenglas: I guess you would have to roll your own Transaction monad.
03:08:13 <kadoban> Isn't being persistent pretty much what you're asking for? You want to be able to go back to an old state, right?
03:09:07 <dminuoso> Gurkenglas: Do you just need rollback semantics, or something closer to LogicT?
03:09:22 <Gurkenglas> afaik persistency is when the state outlives the program
03:10:17 <kadoban> In this context it's just data structures where you can use old versions even after you do modifications
03:10:44 <kadoban> Like Data.Map works. You don't have to throw away a Map value just because you added stuff to it ... you just now have two Maps
03:10:58 <dminuoso> kadoban: The point is to not copy things around.
03:11:15 <kadoban> Who said anything about copying things?
03:11:22 <dminuoso> Gurkenglas did?
03:11:47 <dminuoso> kadoban: I mean if you have two maps, you have copied it.
03:12:20 <kadoban> No, that's not at all what I'm saying. I'm (apparently badly) trying to explain what I mean by the concept of persistent data structures.
03:13:22 <Gurkenglas> dminuoso, I was expecting something like PrimMonad m => [(Int, a)] -> (MVector (PrimState m) a -> m b) -> m b
03:14:22 <Gurkenglas> ie it takes a computation that needs a mutated vector, with an unchecked invariant that this computation does not finish with a different mvector than it started with
03:14:37 <Gurkenglas> and it takes the way it wants the vector mutated
03:14:40 <__monty__> kadoban: Isn't that immutable rather than persistent data structures?
03:14:54 <Gurkenglas> and then it mutates, does the computation, and unmutates
03:14:58 <kadoban> __monty__: It's both
03:15:35 <__monty__> kmelvn: I do, in a very limited way, just reloading the current buffer in ghci.
03:15:46 <Gurkenglas> (not sure my type signature is right)
03:16:31 <Gurkenglas> ReversibleMutation -> RecursiveStep -> Step
03:17:01 <__monty__> kadoban: So persistent -> immutable, can we make that <->?
03:17:17 <kmelvn> __monty__: cool, using vim? do you have your configuration somewhere online? I've been toying with `rapid` for quick reloading and it's pretty great so far
03:17:23 <Gurkenglas> so mostly a combinator that uses bracket, but maybe the interface can be nicer if that's the only usecase for mutability
03:19:49 <Gurkenglas> (forall m. Monad m => ((Int, a) -> m b -> m b) -> (Int -> m a) -> m c) -> Vector a -> c
03:20:10 <kadoban> __monty__: I think so, as long as we're talking about data structures. Outside of haskell though, persistent can get a little fuzzier, there's various degrees. (like you can be able to *view* old version but not modify them efficiently, perhaps)
03:21:11 <__monty__> kmelvn: It's just a single line, and now I see it actually runs the file relying on something like a nix or stack shebang: `nmap <Leader>e :!tmux send-keys -t 0 'time ./%' C-m<CR>` You could replace `'time ./%' C-m` with `':l %' C-m` though, that should load the current file in an open ghci session.
03:22:31 <__monty__> kmelvn: For extra meta-ness, I actually map that not in my vim config but in a script I use to setup a tmux session, using tmux send-keys to map a tmux send-keys command : )
03:23:23 <kadoban> Anyway, this is the one I was thinking of: https://www.lri.fr/~filliatr/puf/ but I don't see a haskell implementation. Oh well, doesn't sound like my suggestion is interesting anyway, but in case anyone was curious anyway.
03:23:29 <Gurkenglas> it's like MonadReader with Int-many environment slots, and efficient local
03:23:52 <kmelvn> __monty__: sweet, thanks :)! that's similar to what I've got. It's such a nice little hack, wonder why I haven't seen it anywhere...
03:27:19 <Gurkenglas> gotta go feel free to @tell me
03:32:20 <__monty__> kmelvn: I'd expect it to be fairly common among the intersection of tmuxers âˆ© haskellers âˆ© vimmers : ) But yeah, vimmers âˆ© haskellers is already not a huge group and tmux has to compete against all the tiling wm fans and terminals that support tiling.
04:06:25 <asheshambasta> https://www.stackage.org/haddock/lts-13.5/validation-1/Data-Validation.html -- the name of this package in package.yaml must be validation-1 correct? Stack seems to reject it as "invalid dependency"
04:07:31 <__monty__> asheshambasta: Isn't everything after - just the version
04:07:38 <dminuoso> Is there some idiomatic way to do: 'a':'b':'c': arr without having to specify as many cons?
04:07:38 <merijn> __monty__: Yes
04:08:22 <asheshambasta> __monty__: I'm not sure, from what I can check within GHCi I don't have the right instances for the Validation type when I remove the `-1` 
04:08:24 <asheshambasta> so I'
04:08:39 <asheshambasta> so I assumed there might be other packages, but it looks like I'm going a little crazy :-) 
04:10:46 <__monty__> asheshambasta: I'm pretty sure you drop the `-x.y.z`, maybe you're looking at documentation for a different version than the LTS you're actually using?
04:10:46 <asheshambasta> https://gist.github.com/asheshambasta/51b45b1e0ba783e30366e4b110dfcaa9 
04:11:12 <asheshambasta> checked within my LTS, but it doesn't seem to tally, unless I'm doing something wrong 
04:12:52 <merijn> asheshambasta: You might wanna use Validation from the either package
04:13:24 <__monty__> asheshambasta: Maybe it's because :i only shows instances for which everything is in scope? Hmm, that doesn't sound right since Eq et al. shouldn't require dependencies.
04:13:57 <asheshambasta> this is the version I
04:14:09 <asheshambasta> I'm running: https://www.stackage.org/haddock/lts-12.26/validation-1/Data-Validation.html
04:14:28 <asheshambasta> Something is definitely up here. 
04:16:43 <asheshambasta> merijn: what are the advantages of the one from the either package? 
04:17:22 <__monty__> It looks quite similar: https://www.stackage.org/haddock/lts-12.26/either-5.0.1/Data-Either-Validation.html
04:18:02 <merijn> asheshambasta: For me the advantage was not being required to use various lenses to work with them, but it's also one of edwardk's package, so that makes it a safe default :p
04:23:36 <Unhammer> Is there a QuickCheck generator that will make [(a,b)] where a<=b , or should I just do pairs<-arbitrary; return $ filter pairs?
04:23:42 <lyxia> dminuoso: (stripPrefix "abc" -> Just arr)
04:24:07 <__monty__> Huh, using a kmett package to lessen the lense reliance? What's the catch? -.- : )
04:24:28 <merijn> __monty__: either exports lenses, but doesn't require you use them
04:24:32 <lyxia> Unhammer: you could use map to swap the bad pairs instead of filtering them.
04:24:35 <dminuoso> lyxia: Brilliant! That's neat. :)
04:24:48 <merijn> oh, looks like validation now also exposes constructors
04:24:54 <merijn> Last I looked at it, it didn't
04:24:57 <Unhammer> oh neat
04:26:51 <Unhammer> thanks lyxia
04:28:27 <dminuoso> lyxia: Though, that's just for ViewPattern matching in bindings right?
04:29:19 <lyxia> right, that's for patterns
04:29:48 <dminuoso> lyxia: Is there a way to utilize this trick for the other way around? Im not pattern matching on this, I want to construct a string with some suffix without having to resort to (++)
04:30:04 <dminuoso> (Or some prefix, depending on how you look at it)
04:31:13 <M2tias> nn
04:31:15 <M2tias> oops
04:32:14 <lyxia> isn't that what (++) is for?
04:33:16 <mniip> can someone clear this up
04:33:29 <mniip> is `cata` the homomorphism of algebras?
04:33:59 <merijn> dminuoso: Why do you wanna avoid ++?
04:40:43 <dexterfoo> i have a question about wai "Application" function: what happens if you call "respond" more than once?
04:40:45 <lyxia> mniip: for every algebra f, cata f is the corresponding catamorphism.
04:41:00 <mniip> yes but how is the catamorphism defined
04:41:26 <mniip> Fix :: f (Fix f) -> Fix f
04:41:29 * hackage aeson-value-parser 0.14.3 - An API for parsing "aeson" JSON tree into Haskell types  https://hackage.haskell.org/package/aeson-value-parser-0.14.3 (NikitaVolkov)
04:41:30 <mniip> that's the initial algebra right?
04:41:40 <lyxia> yes
04:44:28 <lyxia> A morphism between f-algebras (u :: f a -> a) and (v :: f b -> b) is a function (k :: a -> b) satisfying some laws.
04:45:51 <dminuoso> This site canâ€™t be reached ertes.euâ€™s server IP address could not be found.
04:45:52 <dminuoso> :(
04:46:29 <dminuoso> merijn: I guess I was just figuring out why shows is a good thing.
05:00:34 <gentauro> dminuoso: what is that site? (ertes.eu)
05:01:16 <dminuoso> The website of a dear mentor that used to share much wisdom in here some time ago.
05:02:29 <__monty__> I hope someone mirrored it? Unless that was against his wishes?
05:02:57 <tdammers> in case things weren't clear already: https://byorgey.wordpress.com/2018/05/21/ertugrul-soylemez-1985-2018/
05:03:10 <merijn> I don't think it was. I was just checking, I can snap up the name, but then we need to get in contact with his friend to see if he can get us the actual source/files
05:03:11 <dminuoso> __monty__: https://web.archive.org/web/20180522053624/http://ertes.eu/tutorial/foldr.html
05:03:41 <dminuoso> That remains my favourite foldr tutorial. :)
05:04:59 <merijn> byorgey: ping?
05:05:56 <__monty__> dminuoso: <3 The Wayback Machine is such an underrated project.
05:08:38 <gentauro> dminuoso: looks like a nice site (web.archive.org)
05:10:31 <gentauro> wasn't his site on GitHub/BitBucket/GitLab?
05:23:36 <dminuoso> Why am I getting different output here? https://gist.github.com/dminuoso/783a4a1e5f622da549d22b678ccb5447
05:26:23 <mniip> lyxia, that explains it thanks
05:26:28 <mniip> I was trying to explain catamorphisms to a homological algebra person with no haskell programming experience :v
05:31:52 <[Leary]> dminuoso: fixup never touches '\n' in that fold. I'm guessing you meant to supply the last two args in the opposite order.
05:38:45 <dminuoso> [Leary]: What do you mean it never touches '\n'?
05:38:59 <dminuoso> % fixup c | isPrint c = (c:); fixup c | otherwise = ('\\':) . ('x':) . shows (ord c)
05:39:00 <yahb> dminuoso: (0.01 secs, 0 bytes)
05:39:05 <dminuoso> % fixup '\n' ""
05:39:05 <yahb> dminuoso: "\\x10"; (0.01 secs, 155,632 bytes)
05:39:35 <dminuoso> Oh wait..
05:39:38 <dminuoso> [Leary]: I see what you mean.
05:40:04 <cheater> hi
05:40:13 <dminuoso> [Leary]: Wow I feel silly now.
05:40:52 <[Leary]> Happens to the best of us.
05:42:28 <cheater> following the notations in here, https://en.wikipedia.org/wiki/Universal_property are vector space morphisms universal properties? i would say you could make an initial property by making D and C vector spaces, X a base in D, A a base in C, Y a base in C, U a morphism, and g a base change in C.
06:04:17 <mniip> %kill
06:04:17 <yahb> mniip: Done
06:04:46 <mniip> cheater, how are C and D categories?
06:04:52 <mniip> as in, how are vector spaces categories?
06:07:59 * hackage recursion-schemes 5.1.1 - Representing common recursion patterns as higher-order functions  https://hackage.haskell.org/package/recursion-schemes-5.1.1 (gelisam)
06:14:30 * hackage pandora 0.1.0 - A box of patterns and paradigms  https://hackage.haskell.org/package/pandora-0.1.0 (iokasimovmt)
06:19:20 <dminuoso> If I specify a git repository through cabal.project and point it to HEAD, how do I update the dependency after I have already `run cabal new-run/build`?
06:19:36 <dminuoso> Until now I have been deleting the entire dist-newstyle folder, but that's not really a good solution.
06:20:00 <merijn> dminuoso: It automatically updates the dependency for me?
06:20:05 <dminuoso> merijn: Mmm.
06:20:13 <dminuoso> merijn: On each run?
06:20:36 <dminuoso> merijn: Can I take a look at one sample cabal.project? Perhaps there's something subtly different in yours.
06:20:37 <merijn> dminuoso: Are you literally specifying "HEAD" in your cabal.project?
06:20:39 <dminuoso> merijn: Yes.
06:20:45 <merijn> dminuoso: That's a godawful idea
06:21:03 <[Bergi]> Hi! Can anyone help me simplify `\f x -> foldr (>=>) return $ map f x`? There must be a better solution than foldr. I was hoping there exists something like `traverse` for this, but I can't find anything.
06:21:03 <dminuoso> merijn: It's just a temporary workaround until I have a local hackage setup.
06:21:16 <dminuoso> :t \f x -> foldr (>=>) return $ map f x
06:21:17 <lambdabot> Monad m => (a -> c -> m c) -> [a] -> c -> m c
06:21:21 <merijn> dminuoso: You should specify a specific git commit: https://github.com/merijn/GPU-benchmarks/blob/master/cabal.project#L9-L13
06:21:42 <merijn> dminuoso: Then, if you change the commit tag in cabal.project it will auto update the git repo and rebuild
06:22:22 <dminuoso> merijn: Maybe I should just install hackage on a server..
06:23:10 <merijn> dminuoso: I'm not sure what issue a local/custom hackage setup address that you can't address just by depending on specific commits?
06:23:31 <dminuoso> merijn: I could just new-update and it would update within version constraints automatically.
06:23:37 <dminuoso> I wouldn't have to pin every dependency by hand to a commit.
06:23:57 <merijn> dminuoso: How many dependencies do you have that that's a problem?
06:24:21 <dminuoso> merijn: Its not a problem, just annoying.
06:24:37 <merijn> dminuoso: Especially, considering how much of a pain it'd be if one of the dependencies new commits isn't compatible and now all your projects can't compile
06:24:50 <dminuoso> merijn: I feel like if I specify HEAD, then I should get a check on the repo on every build.
06:25:06 <dminuoso> merijn: Well its just my own projects so its not an issue.
06:26:02 <dminuoso> merijn: Or even an explicit `cabal new-update that-dependency` should really update a git dependency and see if the ref has moved.
06:26:28 <dminuoso> Or HEAD should be removed entirely. Because the current state is even worse.
06:35:14 <[Bergi]> Seems I was looking for KEndo <https://chrispenner.ca/posts/kleisli-endo> that allows me to use `foldMap` instead of `foldr (>=>) return`, but I don't want to define my own type.
06:36:18 <dminuoso> [Bergi]: There's nothing wrong with `foldr (>=>) pure`
06:36:27 <[Bergi]> Also, some interesting reasoning why `Kleisli m a a` itself isn't a `Monoid`: https://stackoverflow.com/questions/32935812/why-isnt-kleisli-an-instance-of-monoid
06:37:04 <[Bergi]> dminuoso: Yeah, I figured that now
06:37:39 <dminuoso> [Bergi]: Though thesedays some `unKEndo . foldMap KEndo` is more preferrable to me.
06:37:54 <dminuoso> It's just easier to parse mentally.
06:38:38 <[Bergi]> dminuoso: Exactly. Only that there is no `KEndo` in `base` (or any other popular package)
06:40:48 <Taneb> There's Endomorphism (Kleisli m) from monoid-extras
06:41:00 <Taneb> Although it's another level of indirection away
06:41:32 <Solonarv> ...huh, that blog post mentions StateT as an alternative
06:42:07 <Taneb> http://hackage.haskell.org/package/monoid-extras-0.5/docs/Data-Monoid-Endomorphism.html
06:43:39 <nshepperd1> [Bergi]: it's called EndoM in 'foldl' package
06:47:47 <Guillaum> ghc build with -prof and TemplateHaskell is writting object file with suffix -osuf in the -odir directory. But it will try to read .o_dyn in the -odir directory too. Can I change the directory in which the .o_dyn ar read?
06:52:00 * hackage haskoin-store 0.9.3 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.9.3 (xenog)
06:58:29 * hackage reflex-dom-core 0.4 - Functional Reactive Web Apps with Reflex  https://hackage.haskell.org/package/reflex-dom-core-0.4 (luigy)
06:59:30 * hackage reflex-dom 0.4 - Functional Reactive Web Apps with Reflex  https://hackage.haskell.org/package/reflex-dom-0.4 (luigy)
07:01:53 <okabe_> hey! I am not able to print constructor of a tree using toConstr 
07:02:45 <okabe_> toConstr (Just 'a') 
07:02:59 <okabe_> prints Just
07:03:16 <okabe_> toConstr (Just 5) prints Just
07:03:28 <okabe_> but toConstr (EmptyTree) doesnt
07:03:41 <okabe_> doesnt print anything. 
07:03:57 <okabe_> any helpers? 
07:04:44 <merijn> okabe_: It'd probably help to start by telling us where toConstr comes from
07:04:45 <okabe_> <interactive>:37:1: error:     â€¢ No instance for (Data (Tree a0)) arising from a use of â€˜toConstrâ€™     â€¢ In the expression: toConstr (EmptyTree)       In an equation for â€˜itâ€™: it = toConstr (EmptyTree)
07:04:52 <okabe_> this is the error i get
07:05:00 <dminuoso> okabe_: You need to have an instance Data.
07:05:13 <Solonarv> it'd also help to know where 'Tree' comes from!
07:05:26 <Solonarv> (please don't copy-paste a large amount of code directly into IRC, though)
07:05:46 <okabe_> I tried deriving Data while defining the tree. 
07:06:04 <okabe_> that didnt work. 
07:06:17 <Solonarv> please upload your code somewhere (e.g. gist.github.com) and post that link
07:06:25 <Solonarv> also, please include the error message you got.
07:06:35 <okabe_> okay. 
07:09:40 <okabe_> https://gist.github.com/ashutosh2411/46f435ceece6bdaa9f9836eae660d99c
07:10:15 <okabe_> @dminuoso, please check out the gist
07:10:15 <lambdabot> Unknown command, try @list
07:10:21 <Solonarv> the error message tells you what to do: you need to enable a language extension
07:10:41 <Solonarv> (that's what DeriveDataTypeable is)
07:11:45 <okabe_> I tried 'using Data.DeriveDataTypeable'
07:12:15 <lyxia> {-# LANGUAGE DeriveDataTypeable #-}
07:12:28 <Solonarv> (in a source file)
07:12:41 <Solonarv> 'using' isn't a keyword, it doesn't have any particular meaning
07:14:19 <dminuoso> If you can't deduce what to do from the error message, chances are Data is the wrong tool.. but it's just a guess.
07:16:29 <[Bergi]> nshepperd1: Thanks, that's perfect!
07:25:24 <bbear> how would you bring your understanding of CS (and potentially your employability/ability to do crazy stuff) to the next level after you'd have a good grasp of production application, database, VCS and networking ?
07:31:43 <srk> bbear: by learning nix and nixos :)
07:32:01 <merijn> I don't think that helps with understanding of CS, tbh
07:33:17 <srk> not really but definitely with employability/ability to do crazy stuff :)
07:45:27 <AndrewR> Is Nixos really worth learning? Why would I chose Nixos over a linux distro that has long term support? Can Nixos be counted on in the long term? 
07:46:50 <monochrom> Wrong channel?
07:48:08 <AndrewR> I was just responding to what was said above, but yes it is somewhat off topic. 
07:49:58 <asheshambasta>  
07:49:58 <asheshambasta> https://gist.github.com/asheshambasta/d14ffe838375bc582e283070985a3c91 why? 
07:50:56 <asheshambasta> Or more: what does that error message mean? Besides calling 'GeneralizedNewtypeDeriving' cunning. 
07:52:11 <monochrom> I would notice "cannot eta-reduce", and blame it on JsResult standing in the way.
07:52:57 <Solonarv> in order for GND to work on classes like Monad, the representation of 'JsRead m a' would have to be of the form 'Blah x y z a' (and 'Blah x y z' needs to have a Monad instance)
07:54:18 <asheshambasta> hm, I see
07:56:28 <c_wraith> AndrewR: one might choose nix as a project management tool that handles all dependencies well.  One might there choose nixos as "hey, this works for my whole OS!"
07:56:55 <dminuoso> Solonarv: quantified constraints should address this though, no?
07:57:18 <Solonarv> not really, no
07:57:47 <Solonarv> even if JsResut is a monad, that doesn't help - the composition of two monads isn't always a monad!
07:58:16 <dminuoso> Ohh right.
07:59:05 <Solonarv> QuantifiedConstraints isn't really related to this AFAIK
07:59:28 <Taneb> DerivingVia might help, though (emphasis on "might")
08:00:28 <Solonarv> not in this case, but certainly in other cases!
08:01:16 <asheshambasta> Solonarv: JsResult is a sum type with there being a Monoid on the "error" side, I'm trying to implement something for json validation failure accumulation 
08:01:44 <asheshambasta> So from what I understand, there can never be a monad on `JsResult a`
08:01:47 <Solonarv> have you heard of ChronicleT ?
08:01:57 <Solonarv> IIRC it does just that
08:02:07 <asheshambasta> Solonarv: yeah, but I cannot stand the function names :-) 
08:02:25 <Solonarv> you're free to define aliases for them!
08:02:31 <asheshambasta> yes :-) 
08:04:24 <byorgey> merijn: pong?
08:09:59 <dminuoso> Solonarv: Is ChronicleT just some ValidationT?
08:10:31 <Solonarv> I don't remember exactly, so the best I could do is look up the docs and parrot them back at you
08:10:37 <asheshambasta> Solonarv: also, the ChronicleT is atop the `These c a` which has a "third" apart from the Left and Right, and that isn't quite so desirable in my use case 
08:11:15 <tabaqui> What I've learned today: NEVER use System.IO.getContents with pattern matching
08:12:03 <pavonia> tabaqui: Why not?
08:12:55 <Solonarv> because lazy IO will bite you in the butt
08:13:02 <Solonarv> (presumably)
08:13:53 <tabaqui> In ANSI terminals sequence "\ESC[A" means key up
08:14:37 <asheshambasta> dminuoso: are you speaking of https://hackage.haskell.org/package/validationt-0.2.1.0/docs/Control-Monad-Validation.html ? 
08:14:57 <tabaqui> and if you want to write smth like "case a of { "\ESC[A" -> run keyUp; "\ESC" -> run esc }"
08:15:52 <tabaqui> then second branch will not be executed when single ESC is pressed
08:18:40 <pepegar> Hi! I've a question related to recursion-schemes. Is there anything like a monadic anamorhism? I've seen cataA, which is an effectful fold, but haven't seen an effectful unfold
08:20:11 <Rembane> pepegar: I've seen some in other packages than the recursion-schemes package. 
08:20:35 <lyxia> @hackage recursion-schemes-ext
08:20:35 <lambdabot> http://hackage.haskell.org/package/recursion-schemes-ext
08:21:49 <pepegar> Rembane: Yep, I'm used to use it in scala's matryoshka,but didn't see here
08:22:00 <pepegar> lixia: Thank you very much, that's awesome!
08:25:08 <mniip> about to start updating the GHC in yahb
08:25:11 <asheshambasta> Also, for ChronicleT, `confess` will just add an error to the "stack" of errors and then continue validating right? Say I have do { a <- someChron ; b <- someOtherChron ; ... } will the `b` validation happen if someChron ends with a `confess`? 
08:25:19 <mniip> is 8.6.3 good or does 8.7 pack any new exciting stuff yet
08:26:11 <cocreature> Is there a way see the RTS options baked into an executable? +RTS --info doesnâ€™t seem to show them
08:27:04 <asheshambasta> I need some sleep, I cannot make head or tail of this anymore 
08:28:24 <Solonarv> asheshambasta: I believe that is indeed what 'confess' does
08:29:24 <asheshambasta> it also says: The return function produces a computation with no output, and >>= combines multiple outputs with mappend.
08:29:24 <asheshambasta>  
08:29:24 <asheshambasta> I'm guessing the author means `c` when they say `output`. 
08:32:27 <cocreature> I guess getRTSFlags does the job. I was hoping to avoid recompilation but better than nothing for sure
08:37:19 <cheater> mniip: i don't know.
08:48:59 * hackage SVGFonts 1.7.0.1 - Fonts from the SVG-Font format  https://hackage.haskell.org/package/SVGFonts-1.7.0.1 (BrentYorgey)
09:02:04 <AndrewR> Are there any Haskeller ordained sources on type theory? Or is just studying Haskell the most effective route? 
09:02:41 <dmj`> @google TaPL
09:02:43 <lambdabot> https://www.youtube.com/channel/UC9tXyGZiEft9J4ZiI8dHb3Q
09:02:48 <Clint> ordained
09:02:57 <Welkin> what is this, the catholic church?
09:03:09 <dmj`> @google types and programming languages
09:03:10 <lambdabot> https://www.cis.upenn.edu/~bcpierce/tapl/
09:03:14 <dmj`> ^ AndrewR 
09:03:19 <dmj`> be blessed
09:03:24 <Welkin> haskell will not help you with typ theory and you don't need to know any to use it
09:07:15 <AndrewR> Thanks lads. 
09:11:26 <AndrewR> Isn't Haskell a child of Type Theory and LC? Knowing the son does not help gauge the character of the father? 
09:12:32 <chessai> https://gist.github.com/chessai/a7ed82a06fb3ca187bc6f8695a0ca353
09:13:17 <chessai> typo in that
09:13:18 <chessai> fixed
09:15:01 <bsima> AndrewR: i would say haskell is "inspired by" category theory, and an "implementation of one flavor of" type theory
09:18:45 <lyxia> AndrewR: Learning Haskell to learn type theory is a bit like learning to drive to be a mechanical engineer.
09:19:51 <AndrewR> bsima Is that how it began or is that what it has evolved to become? Did the original Haskell group really have that categorical vision in the beginning? 
09:20:48 <wroathe> https://chrispenner.ca/posts/monadio-considered-harmful anyone have an opinion on this? The argument he's making about the breadth of IO seems compelling
09:22:14 <wroathe> (Incidentally "considered harmful
09:22:20 <wroathe> " posts are getting on my nerves)
09:22:47 <c_wraith> AndrewR, it's more like Haskell was designed to be a programming language. early in its development, it was discovered that a couple ideas from category theory could simplify things, so they were adopted.
09:22:54 <mitchellsalad> It sort of depends on what layer of your application you're working at. MonadIO is useful/necessary at the core, but should probably be discouraged at higher levels of abstraction
09:23:04 <Taneb> (wroathe: you should explain why in a blog post called "Considered harmful posts considered harmful" ;P)
09:23:14 <c_wraith> Taneb, already been done
09:23:18 <wroathe> That post already exists
09:23:32 <Taneb> c_wraith: wow, I need to be more original
10:08:18 <wroathe> So say I've got an IO action that can throw multiple types of exceptions, IOException, MyCustomException. Is it ever a good idea to catch the IOException, and convert it to MyCustomException? That is, to prevent the user from having to distinguish multiple exception types and instead allow them to just perform one case analysis?
10:10:14 <lyxia> Sure it can be a good idea.
10:11:40 <wroathe> In most of the libraries I've looked at it seems like they just throw multiple types, but this seems inconvenient to me with the way Control.Exception.catches works
10:12:30 <wroathe> I wonder if there's a good way of encoding the possible types of exceptions in the type signature for a function
10:13:24 <boj> wroathe: if you haven't already check out safe-exceptions, it has some handy functions for catching the different exception types you described
10:14:42 <boj> we typically catch our own custom AppErrors, and let actual IOExceptions bleed up since they typically imply a component of the system is fundamentally broken and the user can't do anything
10:15:57 <wroathe> Ah, I suppose that is an advantage to multiple types
10:16:24 <wroathe> Allowing the distinction between handleable and non-handleable
10:16:42 <wroathe> That said, if it's an exception that is intended to be handled, it's probably not that exceptional 
10:16:58 <boj> yeah
10:17:08 <wroathe> And at that point you're just doing control flow
10:19:22 <boj> in our case we don't particularly care where a certain error happened, but want to act on it (maybe obscure a specific error from the user), so we treat it as a throwable exception
10:19:46 <boj> not exceptional, but the mechanism makes short circuiting easier
10:20:11 <boj> we're still on the fence about half of what we do these days :)
10:25:22 <wroathe> For encoding it in the type signature, I suppose you could subclass MonadThrow with an extra typeclass parameter for the type of exception
10:26:12 <wroathe> i.e. class MonadThrow m => ThrowsReadOrParse m e
10:26:34 <wroathe> instance ThrowsReadOrParse IO ReadException
10:26:39 <wroathe> instance ThrowsReadOrParse IO ParseException
10:37:40 <nshepperd1> Choosing how to signal errors is more art than science, i think
10:38:33 <nshepperd1> Since the best option depends on how the user of your library will want to handle the error
10:39:55 <wroathe> Yeah, I think the best case scenario would be to somehow signal the types of exceptions that your routine can throw, but not require that they necessarily be handled
10:40:09 <wroathe> signal in the type signature I mean
10:43:17 <Solonarv|phone> You could just have a vacuous 'Throws' type class, I guess
10:44:02 <wroathe> What does the qualifier "vacuous" mean in this context?
10:44:12 <wroathe> Containing no methods?
10:48:46 <wroathe> Maybe something like this... https://gist.github.com/JustinChristensen/ed983124a6dba81d3e9a47eef4379569
10:49:42 <wroathe> Well, that's technically not throwing anything though
10:49:47 * nshepperd1 . o O (class Throws e where {throw :: e -> IO a }; catch ::  (e -> IO a) -> (Throws e => IO a) -> IO a)
10:51:43 <nshepperd1> ignore :: (Throws e => IO a) -> IO a
10:51:56 <nshepperd1> That's for checked exceptions though
10:53:00 * hackage flac-picture 0.1.2 - Support for writing picture to FLAC metadata blocks with JuicyPixels  https://hackage.haskell.org/package/flac-picture-0.1.2 (mrkkrp)
10:56:10 <wroathe> Another approach would be subclassing MonadThrow, and providing a throwM with a subclass of the Exception typeclass
10:57:26 <wroathe> (to indicate which exception types are possible)
11:08:43 <wroathe> Is there any extensions that allow you to subclass an existing class and provide a list of types as instances with a shorthand syntax?
11:08:54 <wroathe> Instead of explictly writing out the class/instance declarations
11:09:39 <wroathe> Creating a tree of MonadThrow/Exception subclasses will get cumbersome quickly
11:11:00 * hackage mmark 0.0.6.1 - Strict markdown processor for writers  https://hackage.haskell.org/package/mmark-0.0.6.1 (mrkkrp)
11:26:30 * hackage git-annex 7.20190129 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-7.20190129 (JoeyHess)
11:28:31 <wroathe> Ah, this clears up a few things: https://www.reddit.com/r/haskell/comments/3f9ycj/lightweight_checked_exceptions_in_haskell/
11:31:09 <nshepperd1> Hah, i should have known that thing i said would already exist
11:31:49 <wroathe> Yeah, it seems like the concept of checked exceptions for Haskell is still very much an open design space
11:32:42 <wroathe> MonadThrow basically gets away with saying that this context could throw any type of exception
11:41:54 <Solonarv|phone> wroathe: sorry for the late response; "vacuous" means it has no methods, and also that all instances are provided
11:42:23 <bodisiw> are there any popular examples of plugin (dynamic link i guess) systems using haskell?
11:42:44 <wroathe> Solonarv|phone: Thanks for clarifying
11:54:38 <DasBrain> :t (>>= return)
11:54:40 <lambdabot> Monad m => m b -> m b
12:00:19 <johnw> modifying an IORef using a stateful action:
12:00:22 <johnw> withIORef ref action = atomicModifyIORef ref (swap . runState action)
12:09:37 <sm> bodisiw: not really
12:11:42 <bodisiw> sm thanks... i think i'm only ready to look at Data.Dynamic, and not yet hs-plugins etc.
12:12:25 <bodisiw> but i found 'Dynamic Extension of Typed Functional Languages' thesis which in turn points to lambdabot and xmonad as examples
12:14:34 <monochrom> Data.Dynamic is just upcast and downcast.
12:14:44 <Solonarv> I don't know if it's been mentioned, but there is also hint which lets you evaluate Haskell expressions
12:15:05 <Solonarv> (it's a wrapper around the GHC API, which you could also use directly)
12:15:55 <Solonarv> xmonad "cheats" by recompiling itself whenever the user configuration (incl. plugins, AFAIK) changes
12:22:24 <bodisiw> thx Solonarv i'll look for hint
12:22:39 <Solonarv> (hint is how lambdabot does its thing, btw)
12:23:03 <bodisiw> monochrom, i don't understand 'upcast and downcast'
12:23:18 <bodisiw> Solonarv, i found mueval
12:23:26 <bodisiw> which apparently has hint as a dependency
12:23:37 <Solonarv> oh right, I'd forgotten about that
12:24:22 <monochrom> For exampe upcast from Int to Dynamic. Later, downcast it back to Int (actually Maybe Int because maybe it was not Int originally).
12:28:00 <bodisiw> monochrom, i don't know if Data.Dynamic itself is too useful, but it's led me to Type.Reflection, which sounds maybe more like what i'm thinking about
12:34:06 <slack1256> Any function to converte a Word32 to network byte order?
12:34:50 <slack1256> htonl is deprecated on Network.
12:40:13 <slack1256> Nvm Data.ByteString.Builder is what I needed.
12:43:59 <bsima> does sh have the 'if [[ <test> ]]` syntax, or only bash?
12:44:30 <__monty__> bsima: That's a bashism. Not sure why you're asking in #haskell though?
12:44:46 <__monty__> bsima: Shellcheck will tell you things like this, it's amazing : )
12:44:47 <bsima> i just dont know how to google that question...
12:44:58 <bsima> oh yeah, i'll use shellcheck, forgot about that
12:46:25 <geekosaur> bsima, it;s a ksh-ism, actually
12:46:48 <bsima> see i knew #haskell would have the answers :)
12:47:23 <bsima> that deep shell knowledge only gained through blood, sweat, and shellscript
12:47:30 * hackage cue-sheet 2.0.1 - Support for construction, rendering, and parsing of CUE sheets  https://hackage.haskell.org/package/cue-sheet-2.0.1 (mrkkrp)
12:47:41 <slack1256> bsima: I don't wanna be that guy, but if you want to do a general programming question to the folks on #haskell, use #haskell-blah.
12:47:48 <geekosaur> was in POSIX for a while, then removed. (and is why I gave up on POSIX as anything but marketing: no such thing as a stable API)
12:50:19 <bsima> slack1256: wasn't aware of #haskell-blah, thanks!
12:50:44 <bsima> i mean I like the *idea* of posix...
13:00:30 * hackage network 3.0.0.1 - Low-level networking interface  https://hackage.haskell.org/package/network-3.0.0.1 (dukerutledge)
13:01:59 * hackage vt-utils 1.2.0.0 - Vector and Text utilities  https://hackage.haskell.org/package/vt-utils-1.2.0.0 (Wilton)
13:09:25 <o1lo01ol1o> given [Foo] where a field of foo foo_List :: [Bar] what's a lens that will traverse the first list, filter, and then pull out the head of foo_list?  I would have thought toListOf (traverse . foo_bar . filtered blah . ix 1) but the ix 1 tells me that Bar is not a member of Ix
13:21:50 <__monty__> bsima: And if #haskell-blah isn't responsive, there's also #haskell-offtopic.
13:23:51 <__monty__> My biggest gripe with POSIX is no local variables.
13:28:00 <Clint> __monty__: well, technically you have the positional parameters
13:28:45 <chessai> does anyone know why packageimports treats `base-noprelude` as `base`?
13:28:52 <chessai> -XPackageImports*
13:29:39 <chessai> when i use -XPackageImports with base-noprelude, i cannot specify something as coming from `base-noprelude` (I get 'package not found')
13:29:39 <__monty__> Clint: Within a script though. And specifically defining variables local to a function.
13:30:33 <Clint> __monty__: yes, you can use "set" for that but I get your point
13:31:20 <heebo> hello im trying to get haskell-ide-engine working but i cant install ghc-mod via stack
13:31:50 <vaibhavsagar> chessai: maybe because it uses `reexported-modules`? https://github.com/haskell-hvr/base-noprelude/blob/master/base-noprelude.cabal
13:31:57 <heebo> i dont think ghc-mod is available in stack...or ami doing something wrong?
13:32:14 <Clint> has ghc-mod been updated for modern compilers lately?
13:32:54 <heebo> Clint: i dont think so i cant see it available on stackage in 8.4.4 or 8.6.3
13:32:59 <vaibhavsagar> Clint: it's being deprecated https://github.com/DanielG/ghc-mod
13:33:41 <heebo> vaibhavsagar: what is supposed to be used for haskell-ide-engine if not ghc-mod
13:33:45 <MarcelineVQ> er, you don't need to install ghc-mod to use/install haskell-ide-engine, ghc-mod is build into it
13:34:01 <Clint> that is a confusing README
13:34:16 <vaibhavsagar> I disclaim all responsibility
13:34:44 <MarcelineVQ> many kinds of install directions can be found here https://github.com/haskell/haskell-ide-engine#installation
13:35:34 <heebo> i followed them but my code completition doesnt seem to be working right i assumed it was because of no ghc-mod
13:36:41 <wroathe> heebo: HIE is a chore to get working. You'll need to configure your editor to start HIE with logging and see what startup errors you get.
13:37:39 <heebo> wrothe: ah thats really helpful, but the page doest talk about how to configure logging?
13:37:54 <wroathe> What do you use?
13:38:01 <heebo> emacs
13:39:15 <heebo> wroathe: how did you configure logging?
13:39:44 <heebo> i may be able to port the method in my head to emacs
13:41:06 <wroathe> actually, before you do anything try running HIE standalone with -d 
13:41:25 <heebo> ah ok thanks
13:43:12 <Solonarv> o1lo01ol1o: to get the first target of a Fold, you want '^?', not 'toListOf'
13:44:20 <o1lo01ol1o> Solonarv:  Thanks, I actually want a list of first targets: toListOf (traverse . foo_bar . ix 0 . filtered blah )
13:44:37 <Solonarv> ah, yes
13:44:55 <Solonarv> I'm pretty sure you just need to drop the 'ix'
13:44:55 <o1lo01ol1o> thought that really reads like it should be doing something I don't want . . . 
13:46:21 <chessai> vaibhavsagar: good point, it might use the origin package rather than any re-exported code
13:46:37 <chessai> so it doesnt care what exports the thing, just where it's defined
13:46:40 <chessai> guessing that
14:03:07 <hc> > let f = 1:1:zipWith (+) f (tail f) in take 23 f
14:03:08 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
14:09:13 <mniip> I'm installing packages for yahb
14:09:16 <mniip> any suggestions?
14:10:06 <hpc> random utility stuff like http://hackage.haskell.org/package/IPv6Addr
14:10:41 <MarcelineVQ> mniip: making :doc available if possible
14:10:52 <t4nk190> Hello! Is there a splitOn for [Int]? I'm trying to use splitOn "0" on an [Int], but it won't work.
14:10:52 <mniip> what's doc
14:11:09 <MarcelineVQ> it's a new ghci feature that spits out the basic hackage doc info
14:11:35 <hpc> t4nk190: take a look at partition
14:11:36 <MarcelineVQ> :doc length "Returns the size/length of a finite structure as an 'Int'. The ..." it goes on
14:11:37 <hpc> https://www.haskell.org/hoogle/?hoogle=partition
14:11:58 <mniip> ghc: Can't find any documentation for GHC.Base.
14:11:59 <mniip> hmm
14:12:16 <mniip> that's because I explicitly bootstrapped cabal without haddock
14:12:44 <mniip> it would be much cooler if it hyperlinked the documentation to hackage
14:12:55 <MarcelineVQ> oh yeah I meant to say haddock
14:13:18 <MarcelineVQ> but hyperlink is a good idea, brevity-wise
14:13:36 <Clint> unless you don't have network
14:13:52 <MarcelineVQ> I just mean for the robut :>
14:13:55 <mniip> well
14:13:58 <mniip> for an IRC bot
14:14:02 <Clint> ah
14:15:38 <t4nk190> Can I convert a [Int] to a [Char] so I can then use splitOn? Partition doesn't  exactly do what I need hmm
14:16:15 <Rembane> :t digitToChar 
14:16:16 <lambdabot> error: Variable not in scope: digitToChar
14:16:34 <Rembane> t4nk190: Is the list of Int containing single digit integers?
14:17:27 <t4nk190> Yeah, only single digit
14:18:12 <mniip> t4nk190, splitOn from Data.List.Split?
14:18:15 <MarcelineVQ> did you perhaps want splitOn [0] rather than splitOn "0"
14:18:46 <mniip> hmm, do I need a special ./configure option to cause GHC to include docs in .hi files?
14:18:52 <mniip> for base that is
14:19:40 <t4nk190> Yes, Data.List.Split
14:19:59 <mniip> t4nk190, well then, "0" is a [Char]
14:20:03 <mniip> which is a type error
14:20:18 <hpc> mniip: uuid and guid would be good packages to add
14:21:20 <t4nk190> I am trying to split for example 111000100 to "111", "0", "1", "0"
14:21:30 <mniip> hpc, I mean consider the current set of packages
14:21:30 <mniip> %% :! ghc-pkg list
14:21:30 <yahb> mniip: http://qp.mniip.com/y/75
14:21:52 <monochrom> splitOn can work on [Int] too.
14:22:07 <mniip> most of those make sense in terms of an interactive eval bot. c.f. lens, mtl, free, parsec, ...
14:22:54 <mniip> oh
14:22:56 <mniip> I should add these
14:24:44 <geekosaur> t4nk190, this is still unclear. you hve a number which you want to render as binary digits and then split those? or is this already a String or ByteString or etc.
14:25:12 <hpc> mniip: science-constants is another good one
14:25:31 <mniip> again I question your choice here
14:25:46 <dmwit> > group [1,1,1,0,0,0,1,0,0] -- t4nk190 
14:25:49 <lambdabot>  [[1,1,1],[0,0,0],[1],[0,0]]
14:26:19 <dmwit> Just to be as explicit as possible...
14:26:28 <dmwit> > group ([1,1,1,0,0,0,1,0,0] :: [Int])
14:26:30 <lambdabot>  [[1,1,1],[0,0,0],[1],[0,0]]
14:26:59 <benzrf> > group []
14:27:01 <lambdabot>  []
14:27:09 <dmwit> But, if you have your heart set on splitOn for some reason...
14:27:14 <hpc> mniip: for -offtopic say, if physics discussions come up
14:27:16 <dmwit> > splitOn [0] [1,1,1,0,0,0,1,0,0]
14:27:18 <lambdabot>  [[1,1,1],[],[],[1],[],[]]
14:31:17 <t4nk190> Thank you  dmwit!
14:45:01 <mniip> MarcelineVQ, it looks like :doc is highly experimental anyway
14:45:36 <MarcelineVQ> it's pretty neat
14:47:29 <Solonarv> mniip: when has "experimental" ever stopped you from adding something to yahb!?
14:47:43 <mniip> it's like
14:47:44 <mniip> half broken
14:47:53 <Solonarv> I seem to remember it had QuantifiedConstraints a good while before 8.6 came out
14:50:42 <nshepperd> half broken is half working! :)
14:51:33 <Solonarv> hah!
14:57:35 <hodapp> sometimes half-broken just means "at least half" >_>
15:27:30 <Trollinator> Hey, I'm looking for an equivalent of the `EitherK` data type from Scala's `cats` library
15:28:05 <lyxia> what does it do
15:28:13 <Trollinator> `data EitherK f g a = Left (f a) | Right (g a)`
15:28:49 <lyxia> Data.Functor.Sum
15:29:05 <lyxia> https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Sum.html
15:29:27 <Trollinator> Wow, awesome
15:29:30 <Trollinator> thanks!
15:29:36 <lyxia> yw
15:30:31 <Solonarv> Trollinator: there's also an infix version in GHC.Generics, called :+:
15:30:56 <Solonarv> (tbh I have no idea why they're separate)
15:31:49 <Trollinator> Sum will do nicely, but thanks
15:33:16 <Solonarv> yeah, I just wanted to mention it for completeness' sake
15:34:24 <lyxia> GHC.Generics predates Data.Functor.* going into base, and they didn't have the same instances (still don't).
15:35:00 <Trollinator> So is there any reason to prefer one over the other? 
15:35:37 <lyxia> not really, except that it's strange to import GHC.Generics for non-generic stuff.
15:36:05 <hpc> it's strange just to import GHC.*, most of the time
15:36:36 <Trollinator> Yeah, let's at least pretend to care about compilers other than GHC
15:37:58 <Trollinator> Isn't Sum also the newtype for when you want the Monoid instance for e. g. Int that adds stuff? 
15:38:21 <lyxia> yes it's the same name
15:38:47 <Trollinator> that must be why I need to `import Relude hiding(Sum)`
15:45:38 <Solonarv> probably.
15:46:03 <Trollinator> OK, one more question. Why does this compile? let { x :: Sum (Const String) [] Int; x = InL "foo" }
15:46:22 <Trollinator> shouldn't it be `InL $ Const "foo"`?
15:46:24 <Solonarv> probably because you enabled OverloadedStrings
15:46:40 <Trollinator> Oh, I see
15:46:42 <Trollinator> yes, I have
15:46:45 <Solonarv> and I'd wager there is a 'IsString s => IsString (Const s a)' instance
15:46:56 <Trollinator> yeah, that makes sense
15:50:25 <mniip> asking again
15:50:34 <mniip> is there any cool packages yall'd like to see in yahb
15:53:22 <Trollinator> what's yahb? 
15:53:27 <Trollinator> yet another haskell book? 
15:53:31 <__monty__> bot
15:53:48 <Trollinator> I see
15:53:51 <mniip> that's one of the interpreter bots around here
15:54:13 <mniip> we've got
15:54:20 <Solonarv> yahb is basically GHCi stuffed into a sandbox and stapled to an IRC bot
15:54:21 <Axman6> I find the formatting package quite useful for little things
15:54:22 <mniip> % unsafeCoerce () () () -- spicy exceptions
15:54:22 <yahb> mniip: <interactive>: internal error: stg_ap_pp_ret; (GHC version 8.6.0.20180620 for x86_64_unknown_linux); Please report this as a GHC bug: http://www.haskell.org/ghc/reportabug; [Aborted]
15:54:39 <Axman6> so spicy
15:56:07 <Solonarv> lambdabot (the other bot around here) merely evaluates expressions (and checks types/kinds, and does a bunch of other stuff)
15:56:39 <TheKing01> % let x = x in fix x
15:56:45 <yahb> TheKing01: [Timed out]
15:57:06 <Axman6> % Data.ByteString.readFile "/etc/passwd"
15:57:07 <yahb> Axman6: *** Exception: /etc/passwd: openBinaryFile: does not exist (No such file or directory)
15:57:17 <Trollinator> % fix error
15:57:22 <Axman6> ... that got further than I hoped it would
15:57:22 <yahb> Trollinator: "*** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Excep
16:00:41 <Solonarv> Axman6: what error did you expect? something along the lines of "you don't have filesystem access"?
16:01:41 <hpc> i played around with yahb in pm once to look around its sandbox
16:01:44 <hpc> it's pretty interesting
16:02:04 <hpc> what things exist and don't exist in it
16:03:11 <__monty__> Does god?
16:05:05 <Axman6> Solonarv: yeah something like that
16:05:28 <Solonarv> yahb lives in a ptrace jail
16:05:55 <Solonarv> I'm not entirely sure what that is but you can probably look it up
16:05:58 <Solonarv> % :! ls .
16:06:00 <yahb> Solonarv: foo; ghci
16:06:07 <hpc> ah, that's what it is
16:06:40 <hpc> ptrace lets one process act as the kernel on behalf of another process
16:06:47 <hpc> plus various other things like stepping through instructions
16:07:34 <Trollinator> Is it possible to get a REPL for a stack script?
16:07:35 <hpc> i was expecting it to be a container with loads of stuff turned off
16:08:50 <Trollinator> never mind, found it
16:31:06 <Solonarv> hpc: that's a very neat way of explaining what ptrace is! I remember looking it up before, but I clearly didn't stumble across that explanation.
16:33:35 <Axman6> % :t ($)
16:33:36 <yahb> Axman6: (a -> b) -> a -> b
16:34:06 <Axman6> hmm, what was the change in GHC to make ($) work with runST? is it a special case in the compiler now?
16:34:47 <Axman6> I thought it was something about adding explicit kind variables but I guess not
16:35:27 <mniip> the special rule is that f $ x is erased to f x in the typechecker
16:35:42 <Solonarv> runST $ is actually a special-case hack IIRC
16:36:08 <Solonarv> let me see if I can find a reference for that
16:38:17 <Sexylady88> http://www.allanalpass.com/Ab1wA
16:39:20 --- mode: ChanServ set +o geekosaur
16:39:27 --- mode: geekosaur set +b *!Sexylady88@87.70.83.*
16:39:27 --- kick: Sexylady88 was kicked by geekosaur (Sexylady88)
16:41:52 <hpc> Solonarv: it comes out of a particular way of thinking
16:42:08 <hpc> Solonarv: from being in the special hell of being a programmer on a team of sysadmins
16:42:39 <hpc> you end up seeing a lot of how computers are put together at every layer
16:51:37 <Solonarv> ah! I found it: https://gitlab.haskell.org/ghc/ghc/blob/master/compiler/typecheck/TcExpr.hs#L368
16:53:57 <hpc> oh yeah, there's an extension now that i forget the name of, which lets you omit the ($) when it's just to apply something to a block
16:54:07 <Solonarv> BlockArguments
16:54:09 <hpc> so you can write runST do ...
16:54:10 <Solonarv> it's awesome!
16:54:12 <hpc> that's the one
16:54:25 <Solonarv> also works for lambdas, case/if-expressins, and so on
16:54:53 <Solonarv> Axman6: https://gitlab.haskell.org/ghc/ghc/blob/master/compiler/typecheck/TcExpr.hs#L368 -- here's the source link again, forgot to ping you earlier
16:56:01 <pfurla> https://hayoo.fh-wedel.de/ is out for several days :(
16:56:04 <Solonarv> unrelated to that hack, ($)'s type is levity-polymorphic - it's actually 'forall (r :: RuntimeRep) (a :: Type) (b :: TYPE r). (a -> b) -> a -> b'
16:58:17 <c_wraith> that's just so it can be used with functions that return unboxed values, right?
16:59:56 <hpc> yeah
17:00:47 <hpc> :k (forall a. a -> a) -> b
17:00:49 <lambdabot> error: Not in scope: type variable â€˜bâ€™
17:00:59 <hpc> :k forall b. (forall a. a -> a) -> b
17:01:01 <lambdabot> *
17:01:11 <hpc> the ST issue doesn't show up at the kind level
17:01:25 <Solonarv> yup! that's exactly what levity polymorphism is
17:02:27 <Solonarv> I vaguely remember there being an incantation to make :t ($) show the real type, but I don't remember what it is
17:18:46 <glguy> $ doesn't have a real type
17:21:26 <Solonarv> true, it is a chimera
17:21:47 <c_wraith> ($) has a real type, though.
17:22:14 <Solonarv> (is it the levity-polymorphic one I gave?)
17:22:51 <c_wraith> yeah. the magic lack of type only applies when it's used infix.
17:24:52 <Solonarv> on a semi-related note, I wonder if and when GHC will start using BlockArguments in its source
17:31:39 <nshepperd> with runST it 'just' needs the type of $ to allow impredicative substitution, i think
17:32:50 <nshepperd> so maybe you could imagine that the 'real' type is '($) :: impredicative_forall a. forall b. (a -> b) -> a -> b'
17:33:07 <nshepperd> for some sufficiently evil and broken definition of impredicative_forall
17:34:13 <Solonarv> oof
17:34:25 <Solonarv> (well, you left out the levity polymorphism on b)
17:37:18 <nshepperd> that too
17:49:54 <c_wraith> I'd be OK with the typing hack being removed in a couple versions, now that BlockArguments exists
18:00:19 --- mode: geekosaur set -o geekosaur
18:00:29 * hackage recursion 2.2.2.0 - A recursion schemes library for GHC.  https://hackage.haskell.org/package/recursion-2.2.2.0 (vmchale)
18:15:22 <jackdk> Suppose I have `a :: Prism' Foo Bar` and `b :: Prism' Foo Bar`. Is there a way to compose `a` and `b` so that the composite prism focuses with `a` if it exists and tries `b` otherwise?
18:19:00 <c_wraith> and stay a Prism? no.
18:19:13 <c_wraith> you can't reverse that.
18:19:22 <benzrf> there's this, but as mentioned, not a prism https://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-Traversal.html#v:failing
18:27:25 <jackdk> good point. I don't need reversing, so that will work well. thanks both
19:03:00 * hackage recursion-schemes 5.1.1.1 - Representing common recursion patterns as higher-order functions  https://hackage.haskell.org/package/recursion-schemes-5.1.1.1 (gelisam)
19:05:10 <Axman6> Solonarv: thanks for that, that's the info I was looking for re ($)
19:05:36 <Axman6> :t (_Left <> _Right)
19:05:37 <Solonarv> \o/
19:05:38 <lambdabot> (Applicative f, Choice p, Monoid (p (Either b b) (f (Either b b)))) => p b (f b) -> p (Either b b) (f (Either b b))
19:05:52 <Axman6> jackdk: ^
19:06:10 <Axman6> but you don't get a prism, I think it's sort sort of getter
19:06:12 <Solonarv> no, no - that isn't useful at all!
19:06:36 <Solonarv> that abomination isn't anything useful
19:06:58 <Axman6> % Left True ^. (_Left <> _Right)
19:06:58 <yahb> Axman6: ; <interactive>:3:15: error:; * No instance for (Monoid Bool) arising from a use of `_Left'; * In the first argument of `(<>)', namely `_Left'; In the second argument of `(^.)', namely `(_Left <> _Right)'; In the expression: Left True ^. (_Left <> _Right); <interactive>:3:15: error:; * No instance for (Semigroup Bool) arising from a use of `<>'; * In the second argument of `(^
19:07:17 <Axman6> hmmm, right. there is a way to do this which is useful though
19:07:26 <Axman6> % Left True ^.. (_Left <> _Right)
19:07:26 <Solonarv> % Left True ^.. (_Left <> _Right) -- hmm
19:07:27 <yahb> Axman6: [True]
19:07:27 <yahb> Solonarv: [True]
19:07:30 <Axman6> ha
19:08:01 <Solonarv> % Left True ^?! (_Left <> _Right) -- note: would be unsafe if _Left and _Right didn't completely cover the input type
19:08:02 <yahb> Solonarv: True
19:08:10 <emmanuel_erc> has anyone here ever written a Serialize instance for a GADT?
19:08:22 <emmanuel_erc> This seems to be tricky.
19:08:30 <Solonarv> % Left True & (_Left <> _Right) .~ 5
19:08:30 <yahb> Solonarv: ; <interactive>:7:34: error:; * No instance for (Num Bool) arising from the literal `5'; * In the second argument of `(.~)', namely `5'; In the second argument of `(&)', namely `(_Left <> _Right) .~ 5'; In the expression: Left True & (_Left <> _Right) .~ 5
19:08:40 <Solonarv> % Left True & (_Left <> _Right) .~ False
19:08:41 <yahb> Solonarv: Left True
19:08:47 <Solonarv> uh oh!
19:09:11 <Axman6> % Right True & (_Left <> _Right) .~ False
19:09:11 <yahb> Axman6: Right True
19:09:26 <Solonarv> % Left True & (_Left `failing` _Right) .~ False
19:09:26 <yahb> Solonarv: Left False
19:09:46 <Solonarv> alright, the lesson is: don't use (<>) on optics
19:09:50 <Solonarv> the result is bogus
19:11:17 <Axman6> % (1,True) ^. beside _2 _1 :: (Bool,Int)
19:11:17 <yahb> Axman6: ; <interactive>:11:13: error:; * No instance for (Monoid Bool) arising from a use of `beside'; * In the second argument of `(^.)', namely `beside _2 _1'; In the expression: (1, True) ^. beside _2 _1 :: (Bool, Int); In an equation for `it': it = (1, True) ^. beside _2 _1 :: (Bool, Int); <interactive>:11:20: error:; * No instance for (Field2 Integer Integer (Bool, Int) (Bool, Int))
19:11:42 <Axman6> ok, completely misread that
19:14:52 <emmanuel_erc> nvm about my question
19:16:35 <q6AA4FD> i want to access the output of `free` from my haskell. is it faster to process the string in haskell, or in awk?
19:30:20 <Solonarv> that doesn't have an obvious answer AFAIK
19:30:25 <Solonarv> (also, what's 'free'?)
19:30:43 <emmanuel_erc> is there any particular that there is not a Serialize or Generic instance for the HashMap datatype in unordered-containers?
19:31:34 <q6AA4FD> Solonarv: the command, i think it uses a syscall
19:32:23 <byorgey> q6AA4FD: I can't imagine the performance is really going to matter unless you are calling free thousands of times a second or something crazy like that.
19:32:52 <q6AA4FD> byorgey: you're probably right, i just like to do things the "right" way
19:33:18 <byorgey> q6AA4FD: ok, then do it in Haskell =)
19:33:22 <MarcelineVQ> man free > "The information is gathered by parsing /proc/meminfo" I'd be inclined to do the same.
19:33:28 <q6AA4FD> byorgey: alright :')
19:33:46 <q6AA4FD> MarcelineVQ: i think i'll do just that
19:34:52 <MarcelineVQ> It's actually kind fun to parse that sort of file, did similar for a process monitor tool
19:35:28 <q6AA4FD> MarcelineVQ: that's sort of what this is for, though i don't know if if i'll find it strictly fun
19:35:29 <Solonarv> @hackage attoparsec -- you'll probably want to use this
19:35:29 <lambdabot> http://hackage.haskell.org/package/attoparsec -- you'll probably want to use this
19:36:00 <q6AA4FD> Solonarv: that does look useful, thank you
19:37:17 <MarcelineVQ> alternatively megaparsec if attoparsec isn't jiving with you. I used http://hackage.haskell.org/package/base-4.12.0.0/docs/Text-ParserCombinators-ReadP.html just to see how it worked
20:36:04 <q6AA4FD_> is there a module for dealing with sizes (in bytes) of things?
20:43:38 <jle`> what's the preferred haskell redis interface these days :)
20:46:57 <dmj`> hedis
20:53:32 <jle`> dmj`: ty man :)
20:53:47 <dmj`> jle`: np ;)
21:05:58 <cobreadmonster> What's up, everyone?
21:43:44 <Angela20> Register and looking for me and maybe we will be sex partner --->  http://gg.gg/d0al3
21:58:22 <AfC> jle`: Haven't used hedis in several years, but it was sensible.
22:23:00 * hackage aeson-value-parser 0.15 - An API for parsing "aeson" JSON tree into Haskell types  https://hackage.haskell.org/package/aeson-value-parser-0.15 (NikitaVolkov)
22:28:41 <Axman6> q6AA4FD: what do you mean?
22:28:59 * hackage yesod-content-pdf 0.2.0.4 - PDF Content Type for Yesod  https://hackage.haskell.org/package/yesod-content-pdf-0.2.0.4 (alexkyllo)
22:46:08 <q6AA4FD> Axman6: sorry, i'm not sure what i asked and i can't find it in my scrollback
22:49:12 <koz_> cobreadmonster: The ceiling, mostly.
22:55:38 <MarcelineVQ> koz_: howdareyou.png
22:55:45 <koz_> MarcelineVQ: Lol.
23:23:29 * hackage yesod-core 1.6.11 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.6.11 (MichaelSnoyman)
23:58:57 <v0d1ch> what happened with hayoo :( https://hayoo.fh-wedel.de/
