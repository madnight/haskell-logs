00:11:48 <karel-de-macil> MarcelineVQ are you still here ?
00:14:03 <MarcelineVQ> yes
00:14:41 <karel-de-macil> i have read your pages , so is my error the fact that what i wrote add a level of list in my code ?
00:16:06 <karel-de-macil> [_:s] == with s=[] is [[_]] ?
00:16:09 <MarcelineVQ> That's correct
00:16:25 <karel-de-macil> ok realy thanks for all so ...
00:32:35 <mightymosquito> Hi, Haskell noob here. quick question => Can a module have multiple haskell files in it? If yes then how do I import a function written in one file to another?
00:36:35 <cocreature> mightymosquito: I’m not sure what exactly you mean. you have one module per file but you can import other modules (and thereby other files)
00:42:07 <mightymosquito> cocreature: So I have a module called Main(in Main.hs file) and another module Views(in Views.hs file) . Now I cannot have let's say URL.hs as a part of the Views module. I will have to go ahead and create a seperate module called URL to actually split my code.
00:42:55 <mightymosquito> even if it serves no purpose outside my Views module?!
00:43:54 <cocreature> mightymosquito: if it serves no purpose outside of Views, why do you want to split it from Views?
00:44:37 <cocreature> you can make a module called Views.URL and place it at Views/URL.hs
00:45:03 <cocreature> but the hierarchy doesn’t have any special meaning in Haskell, you can still import that module from some other place
00:49:08 <mightymosquito> cocreature: thanks!! I'll try it out(still coming to terms with how things works in haskell)
03:15:28 * hackage failable 0.1.0.0 - A 'Failable' error monad class to unify failure across monads that can fail  http://hackage.haskell.org/package/failable-0.1.0.0 (erick)
03:18:27 * hackage failable 0.1.0.1 - A 'Failable' error monad class to unify failure across monads that can fail  http://hackage.haskell.org/package/failable-0.1.0.1 (erick)
04:00:44 <adamretter> Can someone help me briefly understand the concept of lifting? If I have a function like `convert :: Char -> String`. If I have an IO Char, and I "lifted" my convert function for use with the IO should it have the signature, 1) Char -> IO String, or the signature, 2) IO Char -> IO String ???
04:02:07 <Rembane> adamretter: You can use fmap to use your convert function with IO.
04:02:10 <Rembane> :t fmap
04:02:11 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:02:22 <Rembane> Replace all the f's with IO.
04:02:37 <merijn> adamretter: You mean the use of the word "lift" or the actual types/meanings you just gave?
04:03:07 <adamretter> Rembane: okay so it looks like the signature should be (2) - IO Char -> IO String
04:03:43 <adamretter> merijn: dude, I am so confused right now, I have no idea. I was trying to understand function lifting
04:04:02 <xsperry> :t toUpper
04:04:03 <lambdabot> Char -> Char
04:04:05 <xsperry> :t fmap toUpper
04:04:06 <lambdabot> Functor f => f Char -> f Char
04:04:12 <xsperry> :t fmap toUpper :: IO Char
04:04:14 <lambdabot> error:
04:04:14 <lambdabot>     • Couldn't match expected type ‘IO Char’
04:04:14 <lambdabot>                   with actual type ‘f0 Char -> f0 Char’
04:04:17 <butterthebuddha> I'm writing a lisp interpreter and most of my code is functions of the form "b -> a -> IO (Either (b, a))"
04:04:23 <xsperry> :t fmap toUpper :: Char -> IO Char
04:04:24 <butterthebuddha> I.e. I have three levels of Monad nesting
04:04:25 <lambdabot> error:
04:04:25 <lambdabot>     • Couldn't match type ‘Char’ with ‘IO Char’
04:04:25 <lambdabot>       Expected type: Char -> IO Char
04:04:31 <merijn> adamretter: Ok, I'll let you in on a dirty secret :) "lift" doesn't have a single unified meaning and it's actual meaning is almost 90% context dependent
04:04:55 <Ferdirand> :t return . toUpper
04:04:56 <lambdabot> Monad m => Char -> m Char
04:04:58 <xsperry> :t fmap toUpper :: IO Char -> IO Char   -- probably confused more than I helped :P
04:04:59 <jle`> yeah, lift is more of a natural language term than anything with a precise technical meaning
04:05:00 <lambdabot> IO Char -> IO Char
04:05:00 <adamretter> merijn: okay, thanks that does make me feel better
04:05:01 <Ferdirand> :t return toUpper
04:05:03 <lambdabot> Monad m => m (Char -> Char)
04:05:10 <merijn> adamretter: The only really agreed thing is that lift "takes a type/function" and turns it into something that has it (or parts of it) wrapped in a different type
04:05:28 <butterthebuddha> I've never used monad transformers (successfully) before - is it worthwhile trying to rewrite the code in terms of transformers, or should I be attempting to simplify the function types?
04:05:49 <adamretter> merijn: okay so in that instance it would be valid to say that it could be either (1) or (2) in my question?
04:05:53 <merijn> adamretter: I would say that both "Char -> String" converted to "Char -> IO String" and "IO Char -> IO String" could both be described as "lifting"
04:06:03 <jle`> butterthebuddha: you should probably only rewrite working code in terms of transformers if your code becomes simpler after it
04:06:03 <merijn> adamretter: Yes
04:06:03 <adamretter> merijn: right I see
04:06:09 <adamretter> merijn: thanks
04:06:16 <adamretter> Rembane: thank you too 
04:06:54 <jle`> :t fmap toUpper
04:06:55 <lambdabot> Functor f => f Char -> f Char
04:06:57 <merijn> adamretter: "lift" is about as specific as saying "convert" or "wrap" ;) Although lift does imply some more specific things than convert/wrap, but those implications and fuzzy and can be shifted for whatever context you like
04:10:13 <Axman6> adamretter: afor me, lifting jjust means using something in another context, so fmap turns (a -> b) into smoething that works in the context of some f, (f a -> f b). liftA2 lets us take a function of "2" arguments and lift it into the context of working with two things in some context, going from (a -> b -> c) to (f a -> f b -> f c). There are certainly more general meanings for the team and it's not well definied as far as I know. 
04:11:13 <Rembane> adamretter: No worries. Good luck! 
04:13:39 <adamretter> So, am I correct in thinking that I can apply my lifted function directly to IO Char, i.e. I don't need to use >>=
04:14:04 <Axman6> yes
04:14:23 <Axman6> fmap <your function> has type IO Char -> IO String
04:15:37 <adamretter> Axman6: okay, but this starts making the ordering look a bit weird when writing the syntax right, with >>= it is easy to see what follows what
04:16:08 <merijn> adamretter: Well, the nice thing of purity is that order of pure operations is irrelevant :)
04:16:18 <merijn> adamretter: Only the order of IO matters, and that's not affected :)
04:16:42 <adamretter> merijn: right, the order the IO happens in is not affected, but reading the code becomes harder for my brain to follow the order?
04:17:22 <Axman6> > fmap (*7) [1..10]
04:17:23 <lambdabot>  [7,14,21,28,35,42,49,56,63,70]
04:17:24 <xsperry> adamretter, there is <&>, flipped fmap
04:17:25 <merijn> adamretter: You get used to it ;)
04:17:32 <Axman6> > fmap (*7) readLn
04:17:33 <lambdabot>  <IO Integer>
04:17:53 <adamretter> hmm
04:18:06 <adamretter> Okay I have to take 30 mins to let my brain decompress
04:18:10 <Axman6> "apple times 7 to this list" "aply times 7 to the result of this action"
04:18:15 <adamretter> I'll be back soon with more silly questions...
04:18:24 <Axman6> adamretter: there is a very important rule for you to remember
04:18:24 <adamretter> thanks for everyones help
04:18:33 <adamretter> Axman6: oh?
04:18:55 <Axman6> All functions take exactly one argument; if you believe this wholy, you'll find that a lot of these problems become simpler.
04:19:15 <Axman6> (if you do the NICTA/Data61 FP course we/they wiull drill that into you)
04:19:32 <adamretter> Axman6: ah okay, I am trying to relate this to a language where that isn't the case though
04:19:36 <adamretter> BBL
04:19:48 <Axman6> so, if you have fmap :: (A -> b) -> (f a -> f b), you a function which take one argument, another function, and returns a new function
04:20:07 <Axman6> don't do that, that other language is holding you back ;)
04:45:11 <Sakura> Hello world
04:45:18 <Sakura> hello
04:45:23 <Sakura> Hello samurha
04:45:49 <Guest6290> hmm
04:50:39 <yushyin> hello Guest6290
04:51:10 <Guest6290> Hey
04:58:46 <coldpress> adamretter: look at currying and uncurrying
05:00:50 <merijn> tbh, I don't think the term (and functions) currying and uncurrying are particularly helpful
05:02:28 <merijn> Unrelatedly: What's a good formulation from segueing from "here's a bunch of math formula's" to "lemme give an informal explanation for all that"
05:04:21 <philippD> merijn: Start with the informal explanation so the listener has some context for the formulas.
05:05:48 <merijn> philippD: I already covered that one, but it's very high level
05:06:11 <merijn> Not detailed enough to cover the individual parts of the formula
05:06:16 <mtesseract> merijn: Of course, examples are also always a good idea to provide context and motivate something.
05:25:23 <lortabac> hello, I have a singleton inductive type, similar to a Peano number. Since it is infinite, I cannot pattern-match on every single case, so the last case has to be a catch-all. Is there a way to ensure that a given set of cases (for example, from 0 to 3) are matched?
05:26:48 <_deepfire> lortabac: if the type is inductive, why can't the matching be also inductive?
05:27:15 <lortabac> _deepfire: what do you mean by inductive matching?
05:27:20 <Axman6> data Foo = Zero | One | Two | Three | Succ Foo?
05:27:49 <Axman6> (I guess Succ One is allowed there...)
05:28:25 <lortabac> Axman6: the idea is that the type is fixed but the obligatory cases can be set by the users of the library
05:28:44 <_deepfire> lortabac: basically you should be able to have as many match cases, as there are constructors -- and if not, why not?
05:30:12 <lortabac> _deepfire: the constructors are only Zero and Succ
05:30:16 <lortabac> but the cases are infinite
05:30:40 <Axman6> one way to do it woul be to use ... church encoding: match :: a -> a -> a -> a -> (Foo -> a) -> Foo -> a, ie, a case for zero, one, two and three, and a recursive case. 
05:30:41 <lortabac> since there can be an arbitrary number of applications of Succ
05:31:45 <merijn> lortabac: What's the problem, exactly?
05:31:51 <Axman6> that way, if match is the only function which can be used to destruct a Foo, then the user must always a) always provide cases to match those 4 special cases and b) use match in the recursive case too
05:32:47 <lortabac> merijn: I have a library which provides a sort of Peano number, expressing the versions of a data-type
05:32:58 <merijn> lortabac: If you're using GADTs it should "just work"?
05:33:16 <Anonym16> okay hi dude's
05:33:26 <Anonym16> Iam a pro
05:33:28 <Anonym16> not
05:33:29 <Axman6> and dudettes
05:33:30 <Anonym16> xD
05:33:31 <lortabac> merijn: I want to ensure that the users of the library match on all the existing versions
05:33:57 <Anonym16> can we speak german?
05:34:02 <Anonym16> it is better
05:34:04 <Anonym16> for me
05:34:11 <lortabac> merijn: currently it does work, but if you omit a case it blows up at runtime
05:34:23 <Axman6> there is probably a german haskell channel, maybe #haskell-de
05:34:44 <lortabac> merijn: since the last case is always something like _ -> error "Unsupported version"
05:34:46 <Anonym16> that Channel is dead
05:34:52 <merijn> lortabac: That's what -Wall is for, no?
05:35:43 <Anonym16> welcome
05:35:46 <Anonym16> back
05:36:11 <Axman6> Anonym16: do you have a question about Haskell?
05:36:16 <lortabac> Axman6: your approach is interesting, but my library only provides a single data-type
05:36:25 <Anonym16> what is this
05:36:29 <_deepfire> lortabac: so you're trying to create a user-extensible ADT?
05:37:25 <Anonym16> Is this a programming language?
05:37:30 <lortabac> _deepfire: maybe that could be a solution, but it would be much more complex than the current Zero/Succ type
05:37:46 <Axman6> @google haskell
05:37:47 <lambdabot> https://www.haskell.org/
05:37:58 <Anonym16> okay i have a question
05:38:09 <Anonym16> can i ddos with this tool?
05:38:17 <Anonym16> i have ts3 server and i will testing it
05:38:48 <Axman6> of course, Haskell is turing complete
05:38:58 <Anonym16> okay
05:38:58 <lortabac> merijn: I couldn't find a way to leverage -Wall
05:39:25 <mniip> Anonym16, we do not discuss DDOSing an other illegal activities on freenod
05:39:26 <mniip> e
05:39:59 <Anonym16> No dude i will testing my server my TeamSpeak3 Server
05:40:31 <Axman6> why do you think you need to do that?
05:40:43 <Anonym16> testing
05:41:03 <Axman6> I'm pretty sure you don't need to do that
05:41:07 <Anonym16> if I do that to others it's illegal
05:41:18 <Anonym16> I want to see how much he can stand
05:41:19 <mniip> this sounds largely irrelevant to haskell
05:41:43 <Anonym16> okay i go to youtube.Looking for a tutorial
05:42:14 <Axman6> you should watch https://www.youtube.com/watch?v=P1Yc2QmzX88 
05:42:36 <Anonym16> ok
05:42:39 <Axman6> I believe it even begins with a video of a kid showing how to DDOS something
05:44:07 <DigitalKiwi> does it end with the kid getting arrested?
05:44:08 <Axman6> but long story short, you do not need to DDOS your teamspeak3 server
05:44:37 <Axman6> surprisingly no. I guess his ping just wasn't powerful enough
05:46:27 <Anonym16> okay bye
05:47:18 <DigitalKiwi> Axman6: i'm disappointed it wasn't the first scene in Sneakers
05:47:43 <Axman6> ha
05:50:26 <merijn> Incidentally, anyone here ever have to write down pseudo-code structs/records in LaTeX? What did you use?
06:03:25 <lortabac> Axman6, merijn, _deepfire: I think I found a solution for my pattern-matching problem. I use an auxiliary type family to say that for ex. from 0 to 3 I am expecting a given type, and for the other cases I am expecting ()
06:04:05 <lortabac> so I don't need to use error, and -Wall becomes useful again
06:04:50 <Axman6> can you share it?
06:05:41 <lortabac> it's an idea I've just had, I don't have any code yet
06:05:57 <lortabac> however I can share a link to the definition of the singleton data-type
06:07:07 <lortabac> Axman6: the data-type is called SV https://github.com/lortabac/versioning/blob/singletons/versioning/src/Versioning/Singleton.hs
06:08:42 <merijn> lortabac: You could use ConstraintKinds + a type family to force a constraint to only versions you support too: https://gist.github.com/merijn/39dc86e345e87276c523
06:11:12 <lortabac> merijn: good idea, I will give it try
06:11:18 <lortabac> *a try
06:20:03 <Lears> lortabac: I might not be understanding your exact needs, but if you do something like `data SV :: V -> V -> Type where { SVZero :: SV m V0; SVSucc :: SV m v -> SV (VSucc m) (VSucc v) }` then the first parameter to `SV` can assert a maximum supported version.
06:25:34 <Axman6> Looks like a cool package lortabac
06:26:59 <Axman6> ooo, the versioning-servant makes it particularly interesting
06:27:52 <lortabac> Lears: yes, this is a good idea too. However the constraint-based solution has the advantage of keeping the data-type simple and "standard"
06:28:13 <lortabac> Axman6: thanks
06:28:15 <lortabac> :)
06:28:49 <lortabac> Axman6: if I can solve https://github.com/haskell-servant/servant/issues/1095 I have some very cool ideas for versioning-servant
06:29:29 <lortabac> Axman6: like for ex. responding at the same version as the request
06:33:57 * hackage failable 0.1.0.2 - A 'Failable' error monad class to unify failure across monads that can fail  http://hackage.haskell.org/package/failable-0.1.0.2 (erick)
07:01:58 * hackage geodetics 0.1.0 - Terrestrial coordinate systems and geodetic calculations.  http://hackage.haskell.org/package/geodetics-0.1.0 (PaulJohnson)
07:46:27 * hackage hakyll 4.12.5.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.12.5.0 (JasperVanDerJeugt)
07:46:57 <mizu_no_oto> I'm in the process of working on a 'typeclasses 101' talk for the local Scala group, which is mostly going to get a lot of beginners.  What do you guys think the most important ideas are?  I was planning on talking about how typeclasses separate implementation from data (unlike OO), how they allow for retroactive extension of library code, how you can have 'conditional implementation' of typeclasses (e.g. 'Ord a => Ord [a]'), r
07:46:57 <mizu_no_oto>  type polymorphism/polymorphic values (e.g. '1 :: Num a => a') and how there's no need for data to have access to implementation (e.g. 'foldl <> mempty')
07:51:10 <mizu_no_oto> I'm thinking it's probably a waste of time to mention how you might implement Monoid in an OO way with F-bounds, but I'm thinking it might be good to point out that typeclasses are a bad solution to problems like heterogenous lists (in OO, you might want to have a List[Renderable], but you don't usually want to have 'Renderable a => [a]')
07:52:15 <mizu_no_oto> Also, I'm planning on having a repl-intensive talk, particularly for talking about polymorphic values
07:52:31 <Younder> In a language with no classes, yes, a waste of time.
07:53:37 <Younder> Also a pain in Haskel
07:55:18 <mizu_no_oto> Well, it's a talk for a Scala group, so I'll be using a mixture of Scala and Haskell.  I'll mostly use Haskell for things like the polymorphic values with Int and FromJSON, but also because typeclasses look a bit simpler in Haskell
07:55:53 <mizu_no_oto> So most of the code will be in a language with classes
07:57:13 <Younder> I am also a heterogeneous programmer
08:03:08 <ski> `List[Renderable]' would correspond to `[exists a. Renderable a *> a]', rather than `exists a. Renderable a *> [a]'
08:03:38 <ski> (having `forall a. Renderable a => [a]' wouldn't be very sensible, so i assume you didn't really mean that)
08:07:06 <merijn> ski: That would be very sensible, tbh. Just not very exciting :p
08:08:58 <ski> well, i think our notions of what to include in "sensible" here just didn't match :)
08:10:58 <ski> (there's this tendency i've noticed that people say something has type `C a => ..a..', when they really meant that it has type `..a..', where `C a' is known, for some, not currently further specified type `a' (perhaps a universally, or existentially, quantified type variable))
08:11:42 <ski> (e.g. the input to `sort' doesn't have type `Ord a => [a]')
08:11:57 * hackage debian 3.93.3 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.93.3 (DavidFox)
08:16:59 <mizu_no_oto> ski: I mostly meant that `exists a. Renderable a *> [a]' doesn't have the semantics an OO person would expect, and as a further point that `[exists a. Renderable a *> a]' is probably worse than not having a Renderable typeclass and saying '[Renderable]' instead
08:17:36 <ski> worse, in which regard ?
08:19:09 <monochrom> Best of both worlds: "data Renderable = forall a. RenderableClass a => a" so you can say [Renderable] and involve a type class >:)
08:19:44 <hpc> data Renderable = Ptr Void
08:19:45 <mizu_no_oto> In that there's a bunch of extra boilerplate for no extra expressive power that I'm aware of
08:19:46 <monochrom> Bah forgot a data constructor!
08:20:05 <hpc> er, type
08:20:12 <hpc> haha, we both made the same mistake
08:20:13 * ski blinks twice
08:20:27 * hackage servant-py 0.1.1.1 - Automatically derive python functions to query servant webservices.  http://hackage.haskell.org/package/servant-py-0.1.1.1 (erewok)
08:22:28 <ski> mizu_no_oto : well, the extra expressive power (of real existentials, with associated bundled type class constraints, over the usual OO idea of bundling the value with the methods) is that you could have `[exists a. Renderable a *> Map ID a]', say, where all the values in each separate map has the same type
08:23:06 <ski> mizu_no_oto : which is sortof one of the selling points of type classes (also abstract data types) over OO interfaces
08:23:41 <ski> (whether you'd in practice want or need such extra expressive power as `[exists a. Renderable a *> Map ID a]' is another question)
08:56:57 <iqubic> How expensive of an operation is it to turn a Lazy Text into a Strict Text?
08:57:09 <iqubic> What differences do the two have?
09:06:46 <hpc> lazy text is a linked list of strict texts
09:07:12 <iqubic> I'm not sure I see which is better for my usecase.
09:07:51 <hpc> just use the default text until you run into an issue, usually
09:09:56 <iqubic> my issue is that wl-pprint-text's function Text::Text -> Doc requires a strict text, but I have a lazy text stored in my AST.
09:12:05 <wroathe> Is there a standard way people report test code coverage in Haskell?
09:12:12 <wroathe> Library/tool etc
09:12:24 <wroathe> hpc?
09:12:33 <wroathe> (the tool, not the person in this channel)
09:13:33 <wroathe> Ah, nvm, I see that hpc is built into ghc now
09:13:34 <wroathe> Ignore me
09:15:27 * hackage snap-loader-dynamic 1.0.0.1 - Snap dynamic loader  http://hackage.haskell.org/package/snap-loader-dynamic-1.0.0.1 (DougBeardsley)
09:18:55 <hpc> it's true, i am a lambdabot alt
09:23:14 <xsperry> why does properFraction take RealFrac and not Fractional?
09:31:34 <monochrom> Fractional just tries to support "has multiplicative inverse", and instances could have nothing to do with real numbers (for which proper fractions make sense).
09:33:48 <xsperry> should BigDecimal have RealFrac instance? (it doesn't)
09:34:02 <monochrom> I think it should.
09:36:39 <matheus23> Hi! I'm streaming some haskell development on twitch, in case anyone is interested: https://twitch.tv/matheusdev23 this time with a mic :D
09:37:03 <monochrom> God help us!
09:38:35 <monochrom> Um, just so we can hear your keyboard clicks, background music, and sighs?! >:)
09:40:30 <int-e> is there a rubber duck?
09:40:42 <wroathe> monochrom: This seems to be the new fad all the cool kids are doing. It's the computer scientist's equivalent of live streaming your walk to the club on the vegas strip.
09:41:49 <wroathe> monochrom: Only with marginally less duck face
09:42:45 <Welkin> is that like blackface?
09:44:31 <wroathe> Welkin: They share the similarity of both involving a face
09:47:30 <wroathe> What's the preferred way of adding development only dependencies (like hlint, for example) to your cabal file?
09:48:09 <Welkin> check the caba user guide https://www.haskell.org/cabal/users-guide/
09:48:12 <Welkin> cabal*
09:49:14 <wroathe> Welkin: Ah, the old RTFM :P
09:49:19 <Welkin> well, I don't know
09:49:23 <Welkin> but it's a good question
09:52:59 <Welkin> your test suite can have its own build dependencies
09:53:09 <Welkin> and you set up your application as a library
09:53:12 <iqubic> So is there a way to Lazy Text to a Strict Text?
09:53:22 <Welkin> yes
09:53:23 <Welkin> toStrict
09:53:56 <Welkin> Data.Text.Lazy.toStrict
09:54:31 <Welkin> wroathe: https://www.haskell.org/cabal/users-guide/developing-packages.html#build-information
09:55:23 <Welkin> also https://www.haskell.org/cabal/users-guide/developing-packages.html#pkg-field-build-tool-depends
09:57:27 * hackage bizzlelude 1.6.0 - A lousy Prelude replacement by a lousy dude  http://hackage.haskell.org/package/bizzlelude-1.6.0 (TheBizzle)
09:58:02 <monochrom> I don't think *.cabal files support development-only dependencies.
09:58:41 <wroathe> monochrom: Yeah, that's the picture I'm getting too
09:59:04 <glguy> There's https://www.haskell.org/cabal/users-guide/developing-packages.html#pkg-field-build-tool-depends
09:59:33 <glguy> I'm not sure if that would help with hlint since cabal doesn't need to know that you're using hlint to make odd style choices
10:00:07 <wroathe> glguy: :P Care to elaborate on that a bit?
10:00:32 <iqubic> Wait?!?! I actually need to go from Strict Text to Lazy Text.
10:00:33 <wroathe> glguy: Is hlint controversial in the haskell community or something?
10:00:42 <Welkin> you could have two library clauses, my-app-lib and my-app-lib-dev
10:00:48 <iqubic> Actually, let me just change my code to Lazy Text in the first place.
10:00:52 <Welkin> and then of course, my-app and my-app-dev
10:01:57 <Welkin> Lazy <-> Strict and String <-> Text <-> ByteString conversion are the biggest pain point for me in web applications when libraries use all different combinations of these
10:02:39 <glguy> wroathe: Not all of the suggested hlint makes are good, so you end up having to turn a bunch off, and then it can't parse all of the various GHC extensions so it can litter your file with #ifndef HLINT pragmas
10:02:53 <Welkin> I realized that if I just stick with wai, I can have everything be ByteString
10:02:54 <doyougnu> I typically just decide if I need the laziness and just import Data.Text.Lazy if needed
10:03:16 <iqubic> Welkin: Good thing I'm not making a web app.
10:03:26 <Welkin> I don't see the point of using a linter or formatter in haskell
10:03:37 <wroathe> glguy: Yeah, I figured that by dialing it in with extra configuration it would be a net positive
10:03:38 <Welkin> haskell has so many extensions and so many different ways to format your code
10:03:46 <Welkin> there is no "one true way"
10:03:54 <Welkin> it works great in Elm however, since the language is simple
10:03:59 <iqubic> doyougnu: Should my parsec parser use Strict or Lazy text?
10:04:02 <wroathe> For instance, pointing out when I've got redundant "do" statements
10:04:05 <Welkin> I also like to decide in context how to format it
10:04:10 <doyougnu> i do find some of hlint's suggestions valuable. Like the arrow suggestions...they make me step back and go huh...
10:04:14 <glguy> wroathe: once you've turned off most of the warnings there's not much to be gained by running it
10:04:21 <Welkin> I haven't had a syntax error in haskell is a very long time
10:04:30 <wroathe> But I've already had to turn off suggestions that I use <$> for everything
10:04:34 <Welkin> and I don't use anything other than syntax highlighting in emacs
10:05:15 <Welkin> on the rare occasion that I do get a syntax error, I know how to fix it immediately and move on
10:05:31 <Welkin> I've been having a lot of trouble with erlang punctuation, by contrast
10:05:53 <doyougnu> iqubic: that depends on your use case, do you want to build up thunks and save time at cost of memory, or save memory at cost of time?
10:06:35 <iqubic> I run hlint, mainly because I like knowing that I have redundent parens or that I can switch from `maybe x id y` to `fromMaybe x y`
10:06:41 <iqubic> or stuff like that.
10:06:48 <doyougnu> ^^
10:06:51 <Welkin> in Wai, headers are Strict ByteString
10:06:55 <Welkin> but the body is Lazy ByteString
10:07:02 <Welkin> the use-case is important
10:07:08 <Athas> Regarding hlint, I have found the following ignores to work well for me: hlint -i "Use import/export shortcut" -i "Use const" -i "Use tuple-section"
10:07:21 <Athas> I am vacillating on whether to also disable the Arrow suggestions.
10:07:23 <wroathe> But regardless of one's preference on linting, it seems to me that it makes sense to list versions of development-only dependencies in a project's manifest that you know work with the configuration files for those dependencies you've got checked into version control
10:08:22 <Welkin> wroathe: you should be able to do that with my suggestion above: have two executable clauses, one for my-app and another for my-app-dev
10:08:29 <Welkin> where the -dev one has your extra dependencies
10:08:40 <Welkin> and your application code is a library
10:09:17 <wroathe> Welkin: Yeah, I had thought about doing that. I was hoping for something already established as a community idiom though.
10:09:28 <wroathe> It seems that there isn't one
10:09:35 <wroathe> and right now this isn't that big a deal for me
10:12:34 <iqubic> If I use the guard function in parser, will the parser fail if the function returns false?
10:12:37 <iqubic> :t guard
10:12:38 <lambdabot> Alternative f => Bool -> f ()
10:13:06 <c_wraith> the branch will fail, anyway
10:13:07 <monochrom> What does the doc say?
10:13:28 <iqubic> That's exactly what I want.
10:14:19 <iqubic> I'm going to be parsing varibles and I want to do something like `guard (not . elem reservedWords)`
10:16:03 <Welkin> after having used a redis client in erlang with a delightful api ({ok, Result}, {ok, undefined}, {error, Error}) I'm eveb more convinced that the haskell redis client (hedis) is a mess
10:16:55 <Welkin> `m (f (Maybe ByteString))` is not okay
10:17:48 <Welkin> I don't see why, insteado f wrapping a Maybe inside of an Either, the authors would not just create a custom ADT `data RedisResult a = RedisOk a | RedisNotFound | RedisError Error`
10:17:52 <Welkin> that would make so much more sense
10:18:02 <Welkin> hedis, as it stands now, is a nightmare to use
10:18:27 * hackage morphisms-functors-inventory 0.1.0 - Inventory is state and store  http://hackage.haskell.org/package/morphisms-functors-inventory-0.1.0 (iokasimovmt)
10:18:55 <Welkin> any database client in haskell is a pain to use, especially because of the need to convert to/from ADTs, unfortunately
10:21:02 <wroathe> Welkin: Seems like you've got a vision. Time to implement your design :P
10:21:26 <wroathe> The one redis client to rule them all
10:21:30 <Welkin> here is the blueprint https://github.com/wooga/eredis
10:26:14 <Athas> I wonder if there are any functional languages whose "default" list type (the one who gets the syntactical sugar) is an array, or at least something more sophisticated than a singly linked list.
10:27:33 <Welkin> a singly linked list is the most elegant
10:27:43 <Welkin> you can implement any type with it
10:27:49 <doyougnu> Athas: APL?
10:28:44 <doyougnu> dont know if it is particularly functional though
10:29:20 <Welkin> functional is not a standard concept
10:29:25 <Welkin> there is no definition for it
10:29:43 <Welkin> pure functional languages are pretty well defined though
10:29:55 <Welkin> they control for effects/referential transparency
10:30:14 <Welkin> haskell, elm, idris, clean
10:30:22 <doyougnu> yea I was thinking: immutable vars, referential transparency, functions are first class
10:30:49 <Welkin> common lisp is considered functional by some, even javascript (I disagree on both)
10:31:27 <doyougnu> why don't you think CL is functional? 
10:31:33 <Welkin> because it's not
10:31:38 <Welkin> it's an imperative language
10:31:43 <Welkin> with an object system
10:32:00 <Welkin> it has first-class functions, but that's about it
10:32:13 <doyougnu> yea I view it has multi-paradigm
10:32:24 <Welkin> oh, then there is the issue with 2 namespaces
10:32:29 <Welkin> so, not quite first-class
10:32:29 <geekosaur> there's a certain amount of "<x> is what I point to when I say it" here
10:32:31 <doyougnu> haha yea
10:32:35 <geekosaur> and not just with respect to functional
10:33:38 <Welkin> very few languages are pure functional, which is a shame
10:33:58 <Welkin> at least the influence is strong
10:34:19 <Welkin> rust has a lot of similarities with how it manages memory
10:34:21 <iqubic> F# is pure functional.
10:34:27 <iqubic> So is Haskell.
10:34:32 <iqubic> Erlang too.
10:34:33 <Welkin> F# is not
10:34:36 <Welkin> neither is erlang
10:34:38 <doyougnu> erlang is pure?!?!
10:34:41 <Welkin> you misunderstand what pure means
10:34:43 <doyougnu> yea I didn't think so
10:34:53 <Welkin> pure means referential transparency, meaning it encodes the effcts in the type system
10:35:00 <dmj`> very few languages default to pure, for sure
10:35:06 <Welkin> and by extension, immutable data
10:35:10 <iqubic> what about Agda?
10:35:17 <Welkin> agda is a proof assistant
10:35:25 <Welkin> you don't build software with it
10:35:26 <iqubic> I mean Idris.
10:35:31 <Welkin> I said that already
10:35:34 <Welkin> scroll up
10:35:38 <iqubic> I will.
10:35:52 <Athas> Welkin: sure, lists are conceptually simple, but maybe they shouldn't quite have prime of place anymore.
10:36:51 <Athas> Also, they are not really used as a building block in modern typed functional languages.
10:37:16 <doyougnu> I generally don't write haskell code using lists unless i'm using lists as a stack. Using traversable, foldable is much better imo
10:37:27 <Athas> doyougnu: APL is a good example, yes.  It is very alien from lambda calculus-based languages, though.
10:37:54 <wroathe> The day APL becomes the new hotness is the day that I quit programming
10:37:58 <wroathe> No thank you to that
10:38:03 <Athas> APL is the old hotness.
10:39:16 <cocreature> everything old is new again
10:40:11 <Athas> I don't really see the wave of APL influence spreading across the programming landscape.
10:40:13 <Welkin> early 20th century hairstyles (for men) are in fashion again
11:04:48 <wroathe> So running cabal v2-run my-test-suite --enable-coverage apparently isn't working as intended and is instead generating the tix file in the root of the project directory instead of in the dist-newstyle directory
11:05:09 <wroathe> cabal v2-test does correctly generate the tix/mix files in the right spot and spits out the HTML reports
11:05:50 <wroathe> But something is preventing color output in the latter case :S
11:20:30 <Welkin> I forgot who it was that said dialyzer is a huge disappointment, but you were right
11:56:57 * hackage PSQueue 1.1.0.1 - Priority Search Queue  http://hackage.haskell.org/package/PSQueue-1.1.0.1 (HerbertValerioRiedel)
12:10:34 <enoq> hi I was wondering how useful the associativity law was in languages with nulls (and even undefineds)
12:10:51 <enoq> since Java's Optional.flatMap violates it for being more usable
12:11:22 <enoq> I'm looking for a similar implementation in JavaScript/TypeScript to get rid of the dreaded null/undefined
12:12:49 <royal_screwup21> can I ask a game theory question here? It's a quick  one
12:13:34 <Welkin> enoq: use Elm
12:13:37 <Welkin> it has no null
12:13:43 <Welkin> and it has a type system like haskell's
12:13:45 <infinisil> royal_screwup21: If it's got something to do with haskell then sure
12:13:53 <Welkin> it compiles to very tiny javascript
12:14:04 <royal_screwup21> how is 'a' strictly dominated by B? https://prnt.sc/m6d5z2
12:14:14 <enoq> Welkin: has no HKTs and uses bower (afaik) which is kinda dead
12:14:20 <Welkin> what?
12:14:21 <infinisil> royal_screwup21: What has this to do with Haskell?
12:14:25 <Welkin> you are thinking of purescript
12:14:29 <Welkin> elm does no use bower at all
12:14:31 <enoq> my bad :)
12:14:33 <Welkin> it has it's own package manager
12:14:59 <enoq> Welkin: if I was fancy enough to rewrite code I'd just go for Kotlin tbh
12:15:06 <Welkin> kotlin is crap
12:15:37 <enoq> tl;dr: not really eager to rewrite code in a different language atm
12:15:45 <enoq> and kotlin is fine
12:16:23 <Welkin> seriously, check out Elm. It's extremely easy to read and write and gives you the best correctness guarantees of any compile to js language. It also has the best tooling and package ecosystem
12:17:00 <Welkin> I recently wrote a 14,000 line Elm app and it was a breeze to refactor thousands of lines in an afternoon
12:17:27 * hackage eventstore 1.2.1 - EventStore TCP Client  http://hackage.haskell.org/package/eventstore-1.2.1 (YorickLaupa)
12:17:33 <Welkin> the compiler is also super fast now (sub-1-second)
12:17:35 <enoq> refactoring is easy if your IDE and typesystem is good enough 
12:17:44 <Welkin> I don't use an IDE
12:17:51 <Welkin> just a text editor
12:17:55 <enoq> you're missing out then :)
12:17:59 <Welkin> I'm not at all
12:18:09 <Welkin> I prefer the minimal setup
12:18:18 <enoq> but I only really got used to intellij because I had to do Java
12:18:25 <enoq> now I used it for basically anything
12:18:30 <Welkin> java is impossible without an ide...
12:18:39 <Welkin> which is why people coming from java think everyone needs one
12:18:40 <koz_> I agree with Welkin.
12:18:52 <koz_> IDEs are wholly and entirely not necessary except for languages like Java.
12:18:57 <koz_> Where each ADT is novel-length.
12:19:04 <koz_> (abstract, not algebraic)
12:19:10 <mniip> haskell's typesystem is too good for an IDE
12:19:15 <enoq> an IDE can do much more than code generation
12:19:24 <enoq> (which is what you really need for java)
12:19:58 <mniip> parametric polymorphism doesn't easily allow type-driven code completion
12:20:00 <enoq> anyways I guess we're already too OT
12:20:06 <mniip> which is mostly why you would use an IDE in java
12:22:13 <monochrom> An IDE that fits Haskell would do what emacs Agda mode does.
12:24:55 <mniip> some kind of hole driven development?
12:25:11 <monochrom> Yeah.
12:25:12 <koz_> mniip: That's... a new term. :P
12:25:17 <mniip> not really
12:25:27 <Welkin> any kind of thing-deriven-development is a stupid idea
12:25:28 <mniip> at least I didn't invent it rather I heard it used elsehwere
12:25:30 <Welkin> driven*
12:25:47 <Welkin> it promotes non-thinking
12:26:02 <Welkin> "don't think, just do" like in rails "convention over configuration"
12:26:04 <monochrom> Don't be so sure, Welkin. How about development-driven-development?
12:26:11 <Welkin> just use this magic incantation and it works, like magic
12:26:49 <mniip> driving-driven driving?
12:27:01 <koz_> Drink-driven development. :P
12:27:27 <monochrom> Also, I often do proof-driven development. Do not think proof reduces thinking.
12:27:38 <Welkin> it's funny that even "the man" himself (who rails users worship) DHH, came out and said in a blog post that TDD is a stupid idea
12:27:52 <koz_> Welkin: Link please, if you could?
12:28:15 <Welkin> https://dhh.dk/2014/tdd-is-dead-long-live-testing.html
12:28:24 <koz_> THanks!
12:28:28 <monochrom> I don't think most of the _-driven development reduces thinking. Instead, they focuses thinking.
12:28:35 <monochrom> Darn English.
12:31:12 <monochrom> When I teach students how to write recursive code, I teach proof-driven writing. I say: Write the induction proof of your code's correctness first. Oh you don't have the code yet? Well the process of writing the induction proof will help you come up with code.
12:32:59 <monochrom> Does this reduce thinking? Yes, the wasteful kind. If you think in no particular direction you're wasting 99% of your thinking. We are reducing waste and increasing efficiency, not pretending to avoid the necessary.
12:34:16 <monochrom> Hell in fact when it comes to writing recursive code, traditional teaching ("unfold the recursion!") actually causes 100% waste of your thinking because unfolding is the wrong direction.
12:34:36 <monochrom> Don't work harder, work smarter.
12:35:48 <mniip> generalized stackframes when
12:35:58 <merijn> koz_: Drink-driven development is what it's called when you're trying to finish your thesis code ;)
12:36:01 <monochrom> An argument that advocates "thinking more is better" without qualifying what to think there comes across as equivalent to the old and wrong "more lines of code is better".
12:36:05 <koz_> merijn: Depends on the drink.
12:36:15 <merijn> koz_: Whiskey, naturally :p
12:36:16 <nfd9001> Huh. I know this developer who was looking to expand his borders beyond his Python job (which he got by solving Fizzbuzz). I sent him a few interview-style questions to gauge his understanding
12:36:27 <koz_> merijn: I was _expecting_ beer, but I guess that works too.
12:37:03 <nfd9001> One of those problems was greedy, and I gave enough information in the phrasing of that question to allow him to come up with that inductive proof. He really couldn't
12:37:03 <koz_> (although my dev drink of choice is the rather-overused coffee)
12:37:17 <nfd9001> monochrom: what do you even do in that situation?
12:37:18 <merijn> koz_: Beer is for relaxed drink-driven development. Whiskey is for despair-driven development ;)
12:37:19 <koz_> nfd9001: That shows that maths is terribly taught.
12:37:22 <koz_> News at 11.
12:37:40 <nfd9001> i ended up pointing him to the Book of Proof and saying that it would help him a lot moving forward
12:37:46 <koz_> merijn: 'Despair-driven development' sounds like something from Danganronpa. :P
12:37:51 <kadoban> nfd9001: Anything with proof in the name is literally impossible for at least 1/2 of programmers
12:37:57 <koz_> kadoban: I'd say more.
12:38:00 <kadoban> And that's probably being optimistic, ya
12:38:16 <koz_> Maths and programming are, in general, _awfully_ taught.
12:39:09 <nfd9001> See, I would've merely put myself down as a passable dev at best, so that observation is mighty confusing to me
12:39:26 <nfd9001> (just-graduated bachelors in CS, note)
12:39:34 <mniip> programming ~~ math
12:39:36 <mniip> curry-howard
12:39:42 <nfd9001> true
12:39:51 <nshepperd1> . o O (whiskey - 80-proof driven development)
12:39:55 <nfd9001> the confusing part is that his academic history was actually in physics
12:39:58 <koz_> nshepperd1: LOL
12:40:02 <nfd9001> heh
12:40:21 <monochrom> Yes, I do 80-proof-driven lecture slide development!
12:40:27 <koz_> nfd9001: I could be 100% wrong, but I don't think physics involves _proofs_ much.
12:40:40 <koz_> monochrom: Do your slides get horribly derailed about halfway through?
12:40:59 <monochrom> No, I just drink one shot, and over an hour.
12:41:00 <nfd9001> fifty-fifty. it's more analysis than algebraic, of course, but it does require generally-good mathematical reasoning
12:41:10 <nfd9001> which he managed to squeak through without, apparently
12:41:50 <Welkin> Joe Armstrong's background was in theoretical physics too
12:41:55 <Welkin> then he created Erlang
12:49:09 <nfd9001> I know I had that one CS instructor who half-in-jest was always rumored to throw a little whiskey in his coffee mug
12:52:52 <hololeap> :t maybe empty pure
12:52:53 <lambdabot> Alternative f => Maybe a -> f a
12:57:40 <hololeap> so if you had a category where objects are members of Alternative, and morphisms are natural transformations, Maybe would be the initial object...
12:58:37 <mniip> hololeap, natural transformations that preserve empty/<|> ?
12:59:13 <mniip> with the assumption that <|> is assoc and empty is the left and right unit of <|> ?
13:00:43 <hololeap> i guess... i don't know if anything interesting can be gleaned from that
13:02:11 <hololeap> something something monoid homomorphisms
13:05:56 <mniip> hololeap, in that case Maybe definitely isn't the initial
13:06:23 <mniip> that would be the list functor I think
13:07:44 <hololeap> :t (\l -> if null l then empty else pure (head l))
13:07:46 <lambdabot> Alternative f => [a] -> f a
13:08:29 <hololeap> makes sense considering that it's the free monoid
13:09:15 <hololeap> :t (foldr (<|>) empty)
13:09:16 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
13:10:20 <hololeap> idk, just a passing thought
13:11:00 <mniip> the latter not the former
13:14:05 <hololeap> :t foldr ((<|>) . pure) empty
13:14:06 <lambdabot> (Alternative f, Foldable t) => t a -> f a
13:15:56 <hololeap> monoids are crazy... the glue of the universe or something
13:16:03 <merijn> :t asum
13:16:05 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
13:16:10 <ddellacosta> so I'm trying to get doctest working with my project which I'm using `cabal new-*` commands with, and I'm having trouble. I've tried following the instructions here: https://github.com/phadej/cabal-doctest but I'm still getting `Could not find module ‘Build_doctests’` despite having a library section in my cabal file and etc.
13:16:55 <ddellacosta> however reading the notes seems like maybe the necessary stuff has been merged into cabal and I no longer need this library, is that right? I'm having trouble figuring this out from the linked issue and PR (see "There is an issue in the Cabal issue tracker..." under https://github.com/phadej/cabal-doctest#notes)
13:17:40 <hololeap> merijn: nice... i was hoping there was something in base that reflected my observation
13:25:11 <Welkin> this talk by Joe Armstrong is pretty good. https://www.youtube.com/watch?v=bo5WL5IQAd0
13:25:22 <hololeap> another observation is that (<*>) is similar to the multiplication monoid and (<|>) is similar to the addition monoid in that `pure f <*> empty === empty` and `pure f <|> empty === pure f`
13:25:31 <Welkin> it's about parallel programming and the internet
13:25:54 <Welkin> he mentions json encoders/decoder should be implemented in hardware
13:25:58 <Welkin> along with many other things
13:26:05 <mniip> hololeap, the laws of Alternative and its relation to Applicative are not well documented
13:26:07 <mniip> and may vary
13:26:26 <hololeap> well in the case of Maybe and [] it seems to hold
13:26:34 <mniip> sure but that doesn't mean anything
13:29:37 <hololeap> there's really nothing documented about how (<*>) and empty should work with each other?
13:30:10 <mniip> for any set of requirements you come up with, there's a really useful instance that violates it
13:31:14 <mniip> consider something like PEGs for example, with <|> being the ordered choice
13:31:41 <mniip> ordered choice has some really nontrivial relations to other operations
13:32:35 <hololeap> i know nothing about what you're talking about, but i'll take your word for it that it isn't straightforward
13:32:36 <mniip> Parsec's <|> is similar
13:33:27 * hackage ttl-hashtables 1.0.0.0 - Extends hashtables so that entries added can be expired after a TTL  http://hackage.haskell.org/package/ttl-hashtables-1.0.0.0 (erick)
13:33:47 <mniip> hololeap, when we talk about a Monad, we mean an endofunctor with such and such natural transformations with such and such commutative diagrams
13:33:52 <mniip> we don't talk about the collection for instances
13:34:24 <mniip> the problem I'm outlining is that while Alternative has a bunch of instances, there isn't a one-fits-all mathematical formulation
13:35:10 <mniip> so when talking about a specific type of abstract algebraic structure, it's best to use its mathematical name than a haskell typeclass name
13:35:51 <mniip> e.g, "associate <|>, and empty being left and right unit of <|>" is a "functor into the category of monoids"
13:35:59 <mniip> associative*
13:37:52 <mniip> like, Monad, Applicative has a well defined meaning as a lax monoidal functor
13:41:16 <mniip> now, obviously a monoidal structure on C upgrades to a monoidal structure on Mon(C), so a particular functor could be both
13:42:25 <mniip> ah of course
13:43:08 <hololeap> ok... all i really wanted to know is if there are any instances of Alternative where `pure f <*> empty === empty` and `empty <*> pure x` don't hold, because they do even with Parsec, or am i mistaken?
13:43:18 <mniip> if it is both, then the unit (pure) and the product (<*>) are morphisms in Mon(C) and thus you have distributivity with empty/<|>
13:43:21 <hololeap> *`empty <*> pure x === empty`
13:43:41 <mniip> what you're describing is probably true
13:43:54 <mniip> but (f <|> g) <*> x = (f <*> x) <|> (g <*> x)
13:43:59 <mniip> that's whre problems begin
13:44:18 <hololeap> ok, that makes a lot more sense to me
13:44:57 <mniip> consider a parsing expression grammar like
13:45:08 <mniip> ("a" <|> "ab") <*> "c"
13:45:20 <mniip> that only matches the string "ac"
13:45:33 <mniip> ("a" <*> "c") <|> ("ab" <*> "c")
13:45:39 <mniip> this matches both "ac" and "abc"
13:46:33 <typetetris> I would like to produce c code with text templating library. For now i looked at stache, as it seems to be the most maintained option. Are there other options I should consider?
13:46:53 <mniip> by "foo" here I obviously mean a parser that only matches the string "foo" and produces some variant of \_ ... _ -> ()
13:48:27 <hololeap> right... i get that the distribution laws are not well defined.
13:49:00 <mniip> well without distributivity it starts looking ugly
13:49:37 <mniip> then you have F : C -> Mon(D)
13:49:47 <mniip> and  Forget . F : C -> D  lax monoidal
13:49:52 <mniip> where Forget : Mon(D) -> D
13:50:11 <mniip> though you still have unital laws
13:50:27 <mniip> so you could consider  Forget : Mon(D) -> UnitalMagma(D)
13:50:42 <mniip> and then call  Forget . F : C -> UnitalMagma(D)  a lax monoidal
13:50:57 * hackage ttl-hashtables 1.0.0.1 - Extends hashtables so that entries added can be expired after a TTL  http://hackage.haskell.org/package/ttl-hashtables-1.0.0.1 (erick)
14:08:43 <Welkin> wtf?
14:09:28 <Welkin> someone made a github issue in the hedis (redis client in haskell) repo, and the author replied telling them that they "vehemently disagree" that the api is confusing. https://github.com/informatikr/hedis/issues/54#issuecomment-190351911
14:09:53 <Welkin> that does not make me want to contribute to the project if the author is that much of an ass
14:13:32 <MarcelineVQ> I don't see the story of an ass in this thread.
14:13:50 <comerijn> Neither do I
14:14:38 <dale> Me neither
14:23:43 <mniip> I don't see anyone being an ass here
14:25:03 <monochrom> What I said about overreaction and overcounterreaction yesterday in #haskell-offtopic :)
14:29:08 <hc> Welkin: that thread is 2 years old :)
14:29:47 <hc> and the discussion does seem rather civiliced; what is it in particular that you don't like?
14:30:22 <tdammers> it would be somewhat ridiculous in today's post-Monad-Applicative world, but I don't see anything wrong with the tone nor the message here
14:47:20 <_kwstas> Hi guys! I'm a little bit confused about IO laziness when it comes to reading a file. I have this code: `readFile file >>= parse myparser "". I would expect that this code would run in constant memory space no matter how large the file is, but it doe not happen.It seems that memory consumption is directly related to the size of the file. This probsbly means the the whole content of the file is kept in memory, but I do not understand why.
14:47:22 <_kwstas>  Can anyone help? Thx
14:47:45 <comerijn> _kwstas: Which parser library are you using?
14:47:57 <comerijn> _kwstas: And is that the String version of readFile?
14:48:24 <_kwstas> comerijn: Megaparsec and yes it's the String version
14:49:04 <meganF> hello, Im shy girl
14:49:04 <meganF> find me please....  
14:49:04 <meganF> u.nu/devojka
14:49:16 <comerijn> _kwstas: String uses up terrible amounts of memory and is generally bad for "real" use. As for keeping the whole content in memory: If you're using try or backtracking in your parser, it needs to keep the input in memory until it can commit to a specific branch
14:50:39 <monochrom> String is contant-multiplier-inefficient but does not change a constant-space algorithm to a linear-space one.
14:51:11 <comerijn> monochrom: Sure, I didn't mean that was the issue. Just saying he might wanna change that :)
14:52:08 <monochrom> That way lies a rabbit hole IME IMO.
14:52:23 <monochrom> Or maybe more accurately distraction.
14:53:06 <monochrom> Also Megaparsec doesn't default to keeping backtracking information.
14:53:46 <monochrom> This is the problem with question-independent blanket advices.
14:54:49 <_kwstas> comerijn: Yes I thought of using Text instead String, but Megaparsec has the Char module that is for Strings specifically. I don not know if and how it will work with Text. Regarding your second point, I do not think that backtracking should have so massive effect on the memory consumption
14:55:59 <_kwstas> monochrom: I use quite extensively backtracking (through `try` parsers) but for small segments of text
14:57:53 <Welkin> this other redis client seems to be exactly how it should be implemented https://hackage.haskell.org/package/redis-io
14:59:57 * hackage semirings 0.3.1.0 - two monoids as one, in holy haskimony  http://hackage.haskell.org/package/semirings-0.3.1.0 (chessai)
15:06:52 <koz_> How difficult is it to cross-compile Haskell to ARM?
15:07:04 <koz_> I wanna write a CLI app and compile it so I can run it on an ARM device.
15:07:17 <comerijn> koz_: How much are you into masochism? ;)
15:07:28 <Welkin> what about running it on your leg
15:07:29 <koz_> comerijn: That depends.
15:07:32 <Welkin> or another appendage
15:07:46 <koz_> Welkin: I just have to wait for those to become architectures. :P
15:07:58 <MarcelineVQ> koz_: angerrman has done a lot of the nailbiting for you https://www.reddit.com/r/haskell/comments/6bg1u8/a_haskell_cross_compiler_for_raspberry_pi/
15:08:00 <comerijn> koz_: I know a bunch of people are working on this and care about it a lot, but I think it's still very experimental
15:08:06 <MarcelineVQ> angerman
15:08:24 <koz_> MarcelineVQ, comerijn: Thanks, shall investigate. It's not a _huge_ must-have, but it'd be nice.
15:08:27 * hackage ats-pkg 3.2.4.5 - A build tool for ATS  http://hackage.haskell.org/package/ats-pkg-3.2.4.5 (vmchale)
15:08:29 <infinisil> koz_: I think it works effortlessly with Nix, *goes to try it out*
15:08:34 <MarcelineVQ> https://medium.com/@zw3rk/
15:09:12 <comerijn> koz_: I mean, it's the sort of effort that needs more people testing/trying it, but it will involve asking around in #ghc and scouring ghc wiki articles for details
15:09:32 <koz_> comerijn: I'll see just how hard it'll seemingly be, and go for it if it's workable.
15:11:03 <angerman> koz_: hackage.mobilehaskell.org
15:12:07 <koz_> angerman: OK, that looks pretty good. I'll give it a go.
15:17:57 * hackage semirings 0.3.1.1 - two monoids as one, in holy haskimony  http://hackage.haskell.org/package/semirings-0.3.1.1 (chessai)
15:18:49 <Tyr4> Hello everybody
15:18:49 <Tyr4> I would like to know how to... it will be clearer with an example:
15:18:49 <Tyr4> if a have:
15:18:49 <Tyr4> class Showable a where showing :: a -> String
15:18:49 <Tyr4> how can I do:
15:18:49 <Tyr4> instance Showable ((Show a) => [a]) where showing l = concat $ map show l
15:18:50 <Tyr4> ? (this is only for tests purposes)
15:19:14 <glguy> instance Showable a => Showable [a]
15:19:21 <glguy> err, Show a =>
15:20:11 <Tyr4> ?
15:20:51 <glguy> !
15:20:55 <koz_> ?!
15:20:56 <lambdabot> Maybe you meant: v @ ? .
15:21:10 <koz_> OK, time to break out lyxia's all-singing, all-dancing, all-deriving library whose name I can never remember.
15:21:47 <lyxia> generic-data
15:21:56 <koz_> lyxia: One day, I shall learn this name. Thanks!
15:22:07 <lyxia> it's the most generic name ever
15:22:09 <koz_> Also, what's a good Text-based pretty printing library?
15:22:14 <koz_> lyxia: Probably why I can't remember it.
15:22:23 <Tyr4> I want to make a `m a` instance of a class, but only if `a` is instance of another class 
15:22:26 <koz_> If you named it 'cossack-dancing' I'd never forget it.
15:23:47 <Tyr4> oh ok, I understood. Thank you glguy
15:44:33 <ca1ek> so i'm solving some random kata stuff and I have one where i must replace instances of "WUB" with a space 
15:44:46 <koz_> ca1ek: Heard of sed?
15:44:52 <ca1ek> obviously there are better ways to do it than what I did but here's how I approached it
15:44:57 <ca1ek> https://gist.github.com/ca1ek/b1f41d1376071855e873b7574aa37663
15:45:05 <ca1ek> and I don't have a clue why this is incorrect
15:45:21 <ca1ek> it seems to replace each wub with three spaces
15:46:00 <Welkin> if it's a String, just pattern match on 'W':'U':'B':rest
15:46:15 <lyxia> which is what they did
15:47:22 <Welkin> then continue on with `wubToSpace (' ':processed) rest`
15:47:26 <Welkin> and reverse at the end
15:47:39 <koz_> lyxia: Could you explain a little what the deal with FiniteEnum is? I get the problem it's trying to address, I just have no idea how to use it.
15:48:36 <koz_> Oh wait, never mind, I think I get it.
15:48:36 <lyxia> koz_: gtoFiniteEnum gives the standard template
15:49:05 <hpc> i wish when you gave ghc a hole, it would show you some things that unify with it
15:49:17 <koz_> hpc: Doesn't it do that?
15:49:18 <Welkin> you are too obsessed with holes
15:50:03 <hpc> afaict, it just shows whatever the most local bindings are
15:50:11 <MarcelineVQ> hpc: recent versions do suggest some things don't they?
15:50:19 <hpc> some things
15:51:09 <hpc> Welkin: holes are great - you can half-finish writing a chunk of code and still get correctness info from the compiler
15:51:26 <Welkin> what happens if you give a hole a cookie?
15:52:35 <koz_> lyxia: Is there a reason why there's no 'gpred' and 'gsucc' and FiniteEnum equivalents?
15:54:17 <koz_> (also, if someone could suggest a Text-based pretty printer, I would be very grateful)
15:54:57 <lyxia> prettyprinter?
15:55:17 <koz_> lyxia: http://hackage.haskell.org/package/prettyprinter ?
15:55:21 <lyxia> yeah
15:57:15 <Welkin> since http can only transport plain text anyway, does it even make sense to convert it to Text compared to just keeping it as a ByteString?
15:57:26 <Welkin> you can already be guaranteed that it is valid Text
15:57:31 <lyxia> koz_: as for gpred/gsucc, the current generic implementation is based on mapping to Int and back, so that gpred/gsucc don't bring much compared to the default implementation
15:57:44 <koz_> lyxia: Yeah, point taken, now that I think about it.
15:57:45 <Welkin> Text <-> ByteString is a linear operation
15:57:51 <Welkin> extra overhead for no reason
16:03:20 <monochrom> You forgot that http uses "plain text" to transport non-plain-text.
16:03:55 <monochrom> and it uses 8-bit bytes to transport non-8-bit unicode codepoints.
16:03:57 <monochrom> etc etc
16:05:23 <monochrom> That line of English-word-based thinking is like "base64 is just ascii so I'll just keep it undecoded".
16:05:44 <monochrom> But sure, it's your program, don't decode if you don't like to.
16:06:17 <koz_> lyxia: Does your all-deriving library have a name of getting the name of the constructor used for a value?
16:06:53 <koz_> Like, if I have 'data Foo = Bar | Baz | Quux deriving (Generic)', can your library, given a Foo, give me back a String (say) with whatever constructor was used for it?
16:07:04 <lyxia> gconName?
16:07:12 <koz_> lyxia: Thanks, that appears to be what I need.
16:18:57 <hpc> where does the Whoops type class come from?
16:19:04 <hpc> http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Map.html
16:19:56 <hpc> oh nvm, the source links it - http://hackage.haskell.org/package/containers-0.6.0.1/docs/src/Utils.Containers.Internal.TypeError.html
16:25:23 <monochrom> Woah I almost thought "now we can write types in English?!"
16:27:45 <Welkin> Whoops "There it is!"
16:30:14 <koz_> lyxia: I might actually contribute something to generic-data for auto-deriving Random instances for Bounded things.
16:30:30 <koz_> Although actually, it's not 100% safe with just Bounded.
16:30:35 <koz_> I guess Bounded, Enum things.
16:31:10 <hpc> Welkin: dated references are the best references
16:31:36 <Welkin> especially if they are from the 20th century
16:31:50 <hpc> literally a millenium ago
16:32:28 <Welkin> what?
16:32:36 <Welkin> a millenium is a thousand years
16:33:03 <Welkin> that song is from 1993
16:33:10 <hpc> yeah, last millenium
16:34:27 <Welkin> falcon
16:35:25 <koz_> What's a good _simple_ CLI argument parsing library? I basically just need to ensure that I get given one argument, which parses as a single-digit number.
16:36:55 <Welkin> optparse-applicative
16:36:58 <Welkin> I've heard that one is good
16:37:06 <koz_> Thanks Welkin .
16:40:28 <MarcelineVQ> though getArgs would be pretty appropriate for that small a requirement
16:40:53 <koz_> :t getArgs
16:40:54 <lambdabot> error: Variable not in scope: getArgs
16:41:12 <MarcelineVQ> :t System.Environment.getArgs
16:41:13 <lambdabot> IO [String]
16:41:41 <hpc> that has the benefit of being in base
16:42:57 * hackage quickcheck-classes 0.6.1.0 - QuickCheck common typeclasses  http://hackage.haskell.org/package/quickcheck-classes-0.6.1.0 (chessai)
16:58:38 <fen> what is the set of endomorphisms between objects of this set?
16:59:17 <fen> its a category under composition...
16:59:17 <Solonarv> lyxia: would you consider changing your generic-data package's metadata somehow so it actually shows up in a Hackage search for "derive" / "deriving"?
17:01:16 <fen> is it just a group, as the objects define a group action?
17:01:41 <mniip> fen, which set?
17:02:50 <lyxia> Solonarv: sure
17:04:02 <fen> mniip: the set of endomorphisms on objects of itself 
17:04:41 <mniip> you can't have a function be an element of its own domain/codomain
17:04:47 <mniip> that fails the axiom of regularity
17:05:04 <fen> hmm
17:05:19 <mniip> but other than that you've described lambda calculus
17:05:31 <mniip> the naive set theory model of lambda calculus
17:05:50 <fen> well that is not what was expected!
17:06:09 <mniip> the set of lambdas L is such that L = L -> L
17:06:12 <fen> so this is a kind of recurring theme?
17:06:55 <fen> how is this regularity concern alleviated? 
17:07:34 <fen> also, is it the same as an algebra upon partial application of the product to the values?
17:08:06 <mniip> @let newtype L = L { unL :: L -> L }
17:08:07 <lambdabot>  Defined.
17:08:09 <fen> oh, no because then its an algebra under composition..
17:08:15 <mniip> :t L (\f -> L (\g -> L (\x -> unL (unL f x) (unL g x))))
17:08:15 <lambdabot> L
17:09:11 <Solonarv> mniip: can you inspect values of 'L' in any useful way?
17:09:14 <fen> so haskell manages to wrangle it somehow, but it cant be a set because of russles paradox, or regularity
17:09:20 <mniip> probably not
17:09:38 <fen> Solonarv: they can be indexed by a totally ordered set such as Nat
17:09:42 <fen> or R
17:09:43 <mniip> fen, the difference is that in haskell (->) is not the set of all functions
17:10:03 <mniip> which is also the case with lambda calculus
17:10:35 <mniip> when constructing lambda calculus we consider just the finitely generated terms
17:10:59 <fen> only, not sure how to manage higher dimensional indexing, like with tuples of irrational numbers, because then its not clear how to order them. 
17:11:25 <crestfallen> hi I'm using import Data.Set     also...
17:11:42 <mniip> wtf does this have with R or irrational numbers
17:11:46 <crestfallen> import qualified Data.Set as Set
17:11:47 <Solonarv> fen: wdym by "indexing into L"?
17:12:02 <Solonarv> crestfallen: hi, what's your question?
17:12:09 <fen> mniip: to distinguish the functions, which are presumably dense
17:12:10 <crestfallen> this second import is not recognized first of all...
17:12:36 <crestfallen> with the first import I cannot use basic functions such as union
17:12:42 <crestfallen> in ghci
17:13:00 <mniip> dense?
17:13:01 <mniip> in what
17:13:21 <Solonarv> crestfallen: I'd recommend pasting the relevant part of your GHCi session somewhere and posting a link to that
17:13:29 <fen> well just that they seem difficult to order, or index by something ordered 
17:13:30 <crestfallen> thanks Solonarv 
17:13:40 <mniip> what
17:14:17 <orion[sf]> Hello. I would like to create an interface which keeps track of state, but prevents the user from accessing it directly. What's the standard way to approach this?
17:14:25 <fen> well the problem is that this L = L -> L needs to be able to tell which L it is passed, which seems like they should be indexed
17:14:37 <mniip> "which L it is passed"?
17:14:58 <Solonarv> orion[sf]: what kind of interface? a graphical interface? a CLI? something else?
17:15:40 <fen> well in haskell, it wouldnt be possible to tell which function was provided, so it would not be possible to lookup which function to return 
17:15:59 <Solonarv> fen: the premise is true, but the conclusion is nonsense
17:16:05 <fen> huh?
17:16:21 <fen> you mean its still possible?
17:17:00 <mniip> we talked about this, please refrain from using words when you're not completely sure what they mean
17:17:01 <fen> or is the concept of "lookup" not the correct way to describe a function that cannot be indexed
17:17:28 <Solonarv> Correct, the concept of "lookup" is also not very well-defined - and neither is "indexing"
17:17:44 <mniip> are you thinking of countable sets?
17:17:54 <fen> something to do with the inhabitants of a type being uncountable?
17:18:42 <Solonarv> the lambda calculus has infinitely many terms, but it's a *countable* infinity
17:18:53 <fen> not quite sure about how that fits with indexing by the real line, as thats uncountable, but totally ordered 
17:19:01 <mniip> on the other hand L = L -> L does not have a cardinality
17:19:15 <mniip> (because it is formally not a set)
17:19:29 <fen> this seems to be the problem
17:19:49 <crestfallen> Solonarv I'm just following the page on haskell-containers.readthedocs.io    https://paste.ee/p/iywRw
17:19:56 <mniip> if you're establishing a total order on a set, I wouldn't call that "indexing"
17:20:06 <mniip> you've uhh, defined a total order on a set
17:20:13 <evanm> #emacs-haskell
17:20:34 <fen> it just means the index can be used to identify the function
17:21:01 <crestfallen> btw initially I was reading the zvon page but evidently missing something..
17:21:10 <fen> and then the function itself is just a "lookup" i.e. a square matrix associating the input index to the output index
17:21:22 <Solonarv> crestfallen: why would you think "blahblah" is a set literal?
17:21:59 <mniip> what
17:22:00 <Solonarv> similarly, [1, 2, 3] isn't a set literal normally
17:22:00 <crestfallen> based on zvon example. but [1,2,3] [2]   also is invalid
17:22:07 <crestfallen> o
17:22:09 <crestfallen> oh
17:22:38 <Solonarv> (Set.fromList [1, 2, 3]) is a "set literal"
17:23:08 <Solonarv> if you enable the OverloadedLists extension, then [1, 2, 3] can be treated as a set literal too, but you clearly didn't enable it ;)
17:23:35 <mniip> square matrix?
17:23:36 <mniip> wtf
17:23:58 <crestfallen> could you write a few examples on that paste.ee  Solonarv if you have time?
17:24:44 <Solonarv> crestfallen: frankly, I'd just end up copy-pasting from the docs, which you linked and therefore clearly know about already
17:25:05 <Solonarv> if you say what exactly is confusing you, I can try to alleviate that
17:25:29 <fen> mniip: whats up?
17:25:48 <mniip> you're not making any sense as always
17:27:21 <fen> basically this idea of a function not being identifiable, re: "<Solonarv> mniip: can you inspect values of 'L' in any useful way?" seems to be something to do with a bijection between functions and their indexing set, and a representation of the isomorphism as an isomorphism on the index
17:27:51 <Solonarv> whether functions are identifiable depends on the formalism you're working in
17:27:53 <crestfallen> trying. this script is not usable in ghci though correct Solonarv ?
17:28:03 <crestfallen> {-# LANGUAGE ExtensionName #-}
17:28:03 <fen> (L -> L) -> Ix + Ix -> (L -> L) + (Ix -> Ix) = L -> L
17:28:08 <mniip> no
17:28:09 <Solonarv> examples: in set theory, they are; in the lambda calculus, they are not
17:28:24 <Solonarv> crestfallen: in ghci, you type :set -XLanguageExtension
17:28:36 <crestfallen> got it thanks
17:28:37 <mniip> Solonarv meant whether you can tell two elements of L apart in haskell
17:28:50 <mniip> that has nothing to do with any isomorphisms of L with anything
17:29:15 <fen> thought that was because you would need to be able to tell which L was provided to L -> L to tell which L should be returned
17:29:20 <orion[sf]> Solonarv: Consider this code: https://gist.github.com/centromere/e09d76aa0474a2716dbfb6ff4d9e634b
17:29:22 <Solonarv> ...and I don't think you can, unless you're okay with the result being wrapped in L again.
17:29:25 * ski idly wonders what "functions being identifiable" even means
17:29:38 <mniip> the short answer here is that there is no ADT in sight and thus you can never use a pattern match to branch between False and True
17:29:46 <fen> ski: thats what the indexing and lookup concepts were trying to cover
17:29:53 <mniip> they aren't concepts
17:29:55 <mniip> you made them up
17:29:57 <Solonarv> orion[sf]: looks like a great use case for the 'State' monad
17:30:19 * ski doesn't know what, if anything, was meant by "indexing" and "lookup", either
17:30:54 <fen> well functions could be distinguished if they had a total order...
17:30:54 <orion[sf]> Solonarv: Line 4 represents a catastrophic problem because the state is reused. I would like to prevent the user from ever seeing the state.
17:31:10 <mniip> unsurprising, but so what?
17:31:23 <fen> the index is that which parametrises this order
17:31:23 <Solonarv> orion[sf]: State doesn't make it impossible to see the state, but it does make it considerably harder to shoot yourself in the foot like that
17:31:33 <orion[sf]> Solonarv: Okay.
17:32:12 <mniip> the functions could also be distinguished if they were isomorphic to some language in a finite alphabet
17:32:14 <mniip> but so what
17:33:00 <monochrom> orion[sf]: I'm thinking you need to define your own monad that, under the hood is implemented like the State monad, but you choose what operations to provide to the user at your interface boundary.
17:33:15 <Solonarv> yep, that's also a thing you can do
17:33:26 <Solonarv> (you can even re-use State to make it easier!)
17:33:29 <mniip> orion[sf], monochrom why not use a free monad
17:33:59 <fen> well thats the concept of indexing anyway... probably this lack of isomorphic alphabet or index is the problem when trying to create these L terms
17:34:11 <mniip> no
17:34:51 <Solonarv> you can *create* L terms just fine, you just can't do anything with them other than build more L terms
17:35:00 <Solonarv> (barring unsafeCoerce and similar shenanigans)
17:35:06 <orion[sf]> mniip: I'd like to give the user the option of composing other Monads too.
17:35:13 <mniip> free monad transformer
17:35:35 <mniip> Solonarv, sounds like existential quantification
17:35:47 <mniip> I wonder if (mu L. L -> L) ~ 1
17:36:24 <Solonarv> mniip: huh, I wonder if L is iso to 'newtype LEx = forall a. LEx (a -> a)'
17:36:40 <monochrom> No, "L equiv L->L" is untyped lambda calculus.
17:36:43 <fen> a good example is vectors V with L2 norm. they are self dual, so conjugation :: V -> (V -> V)
17:36:46 <Solonarv> orion[sf]: a monad transformer, then - you can re-use StateT in your implementation
17:37:09 <monochrom> Or rather, "L order-isomorphic-to L->L"
17:37:57 <mniip> Solonarv, again, FreeT
17:38:04 <mniip> it's pretty exciting
17:38:15 <fen> it defines an inner product space
17:38:16 <orion[sf]> mniip: What about a free applicative?
17:38:17 <monochrom> Ah I have to think again, what I said is true in math but there is a difference with Haskell.
17:38:50 <mniip> orion[sf], are you using "applicative transformers"?
17:38:54 <mniip> if so for what
17:38:58 <fen> basically its partial application of mappend in a monoidal category to the objects
17:39:23 <Solonarv> (you never need applicative transformers, because applicatives compose just fine)
17:39:45 <mniip> fen, elaborate
17:39:58 <orion[sf]> mniip: https://github.com/centromere/cacophony/blob/master/src/Crypto/Noise/Internal/Handshake/Pattern.hs
17:40:01 <fen> apparently this defines a naive lambda calculus set theory 
17:41:02 <fen> which is made regular in haskell because of some properties of (->) not containing all possible functions
17:41:39 <mniip> fen, I see reminiscence of my own words but that isn't at all what I said
17:42:10 <monochrom> :)
17:42:16 <mniip> "naive lambda calculus" isn't a thing, "naive set theory" is
17:42:28 <crestfallen> Solonarv, thanks got that to work. Still, why would a function like union require an extension, when i.e. ' union [1,2,3] [3] ' is such a basic operation with a dataType (Int) that is according to the documentation: " Set relies on the element type having instances of the Eq and Ord typeclass for its internal representation. "
17:42:34 <mniip> "regular" - is that referring to the axiom of regularity?
17:42:38 <fen> yes
17:42:58 <Solonarv> crestfallen: you've got it backwards - 'union' doesn't require an extension
17:43:06 <mniip> that's a perk of ZF that in particular eliminates russel's paradox and the like
17:43:11 <Solonarv> writing [1, 2, 3] for a Set literal is what you need the extension for
17:43:12 <mniip> nothing to do with haskell's type system
17:43:28 <mniip> all haskell types are countable
17:43:30 <fen> what was that about (->) then ?
17:43:37 <mniip> and (->) denotes the type of *computable* functions
17:43:42 <mniip> where there is a countable number of
17:44:05 <monochrom> I wouldn't even talk about countability of a type.
17:44:22 <fen> so then the countability, or indexing (fixing a counting) solves this issue to do with regularity?
17:44:23 <crestfallen> Solonarv, ok, odd, so the list container is not by default a Set object
17:44:34 <mniip> monochrom, you can model haskell with sets
17:44:35 <monochrom> Like, next thing you know, let's discuss green kinds.
17:44:39 <mniip> sets can have cardinality
17:44:43 <Solonarv> crestfallen: of course not, [] and Set are different things
17:44:49 <Solonarv> how's that odd?
17:45:05 <mniip> fen, no!
17:45:07 <fen> mniip: is that where infinity categories enter pitcure?
17:45:13 <mniip> jeez
17:45:37 <fen> sets containing sets of lower cardinality
17:45:40 <crestfallen> its fine, I'm glad to make the distinction.
17:45:45 <crestfallen> thanks Solonarv 
17:46:24 <crestfallen> I've been studying math out of a book so I was blurry
17:47:37 <fen> i wish to define functions based on how they change other functions
17:47:58 <fen> that this action be their defining property
17:48:10 <monochrom> Math usually doesn't talk about lists at all.
17:48:21 <mniip> monochrom, free monoid?
17:48:24 <fen> but then it seems they need another piece of information, which could be to do with how they are indexed, or identified 
17:48:40 <monochrom> mniip, usually?
17:48:50 <hpc> fen: writing functions in that style doesn't require anything complicated at all - look up semantic editor combinators
17:49:01 <mniip> well math doesn't talk about anything usually
17:49:05 <hpc> the most complicated thing in that style of programming is (.)
17:49:12 <Solonarv> mniip: ouch ;)
17:49:15 <mniip> it's too diverse for any single topic to pop up in all of the fields
17:49:25 <ski> (hm, doesn't Cantor work on the type `Nat -> Bool' ?)
17:49:26 <monochrom> It talks about sets and functions most of the time.
17:49:30 <mniip> Solonarv, pay attention to the quantifiers
17:49:56 <Solonarv> ski: IIRC that is indeed what Cantor sequences are
17:50:03 <fen> hpc: it seems like quite a jump from describing functions over vectors to logic 
17:50:29 * ski was merely trying to sensibly interpret "all haskell types are countable"
17:50:38 <hpc> i have no idea how any of that relates to what i said
17:50:40 <monochrom> I mean you could easily go to a math library and count books and count how many use natural numbers, how many use sets, how many use lists, how many use free monoids...
17:51:17 <monochrom> You don't have to polarize everything by oversimplifying everything to booleans.  There is such a thing as statistics and percentage.
17:52:16 <mniip> ski, well the set of elements of a type is the quotient set of all expressions of that type over the alpha/beta/eta/... equivalence relations
17:52:17 <monochrom> Why does everything booleanize everything to create polarization?  Is this a new kind of boolean blindness?
17:52:27 <mniip> which is necessarily countable because the set of expressions is countable
17:54:01 <mniip> and once you have elements of types that you can't write down - that's when you know you've left haskell and entered mathematics
17:54:06 <mniip> /s
17:54:11 <hpc> monochrom: they must be using the law of the excluded middle
17:54:18 <hpc> which is a very unconstructive way of thinking if you ask me :P
17:54:22 <crestfallen> Solonarv,   wondering also what "as" keyword is and why ghci doesn't accept this command:     ' λ > import qualified Data.Set (Set) as Set  '
17:54:50 <Solonarv> crestfallen: the 'as' keyword is only used in import statements, IIRC
17:55:03 <hpc> the syntax is import qualified Data.Set as Set (Set)
17:55:07 <geekosaur> it has to be in the proper order.
17:55:13 <hpc> "as" names the module you're importing
17:55:26 <ski> mniip : assuming you only consider values that can be "defined" by expressions
17:55:26 <hpc> @let import qualified Data.Set as OogaBooga
17:55:28 <lambdabot>  Defined.
17:55:36 <hpc> :k OogaBooga.Set
17:55:38 <lambdabot> * -> *
17:55:41 <geekosaur> and "as" isn't rewally a keyword which is why it is only recognozed in the right place in the importy
17:55:46 <mniip> ski, so as I said
17:55:51 <ski> mniip : also, doesn't quotients of countable being countable rely on excluded middle ?
17:55:55 <mniip> if you can't write them down
17:56:01 <Solonarv> @let import qualified Data.Set as Useless (Set)
17:56:02 <lambdabot>  Defined.
17:56:10 <Solonarv> :t Useless.fromList
17:56:12 <lambdabot> error:
17:56:12 <lambdabot>     Not in scope: ‘Useless.fromList’
17:56:12 <lambdabot>     No module named ‘Useless’ is imported.
17:56:28 <Solonarv> :k Useless.Set
17:56:29 <lambdabot> * -> *
17:56:43 <Solonarv> so, while you can write those imports, they're not particularly useful ;)
17:57:16 <monochrom> It is still best to put your code in a file and use :load
17:57:31 <mniip> ski, well even if you can't construct a bijection into N, you can show a monomorphism into N
17:57:37 <mniip> and that has similar power
17:57:54 <hpc> the even easierer way is put your code in a file, "ghci file.hs", and use :r
17:58:07 <ski> one could imagine an interpretation of e.g. `Nat -> Bool' which included input streams to the program, fed from some external sensor. and presumably we're not assuming that physical processes must be algorithmic ?
17:58:09 <hpc> then you don't even have to remember if it's "load or "m
17:58:11 <hpc> :m
17:59:22 <crestfallen> got it! thanks Solonarv geekosaur I swear I dread the possibility I am dyslexic - very sorry
17:59:27 <fen> the problem is that there are too many L to feasibly supply all of them to some L -> L to find out what it does, or "identify" it
17:59:44 <mniip> ski, such a process would need to be infinite
18:00:15 <Solonarv> and before you say "infinite precision": actually, quantum mechanics forbids this.
18:00:15 <ski> (at least i remember that subsets of finite sets doesn't (in a weak sense) necessarily have to be finite, barring excluded middle)
18:00:24 <ski> mniip : yes
18:00:58 <monochrom> Hey I believe in the very strong physical version of the Turing thesis too!
18:01:20 <mniip> monochrom, that we're all running on a turing machine?
18:01:33 <hpc> i had a professor with a funny physical solution to P=NP
18:01:48 <ski> iirc, Escardó talks a bit about the difference between assuming program inputs to be algorithmic, and assuming them to merely be computable
18:01:56 <hpc> wait a polynomial amount of time for moore's law to build up, then buy a $1000 computer that can solve your problem in some fixed amount of time
18:02:35 <mniip> monochrom, but then that means that turing, an element of the turing machine, conceived the turing machine
18:02:42 <mniip> and that violates axiom of regularity
18:03:37 <fen> but if there was a notion of distance between these L = L -> L (lambda terms?), like they were ordered so that all L acting on them had bounded effect, then perhaps a finite set of test inputs could be used to characterise them. no idea if such an organisation is possible
18:04:00 <mniip> monochrom, which means our world is inconsistent, and by the principle of explosion (also known as the big bang...
18:04:40 <monochrom> I think we have a way out by having the universe having the possibility of hanging.
18:05:13 <ski> hm, would it violate regularity ?
18:05:15 <monochrom> Roughly, the same way GHC-extended Haskell can afford Type :: Type by being not a total language.
18:05:48 <hpc> i mean, universal turing machines are a thing
18:06:11 <ski> an abstraction
18:06:17 <mniip> monochrom, Oracle is an oracle
18:06:48 <monochrom> This is exciting! My theory predicts that there is an experiment that will hang the whole universe.  In the interest of science let's look for that experiment!
18:07:00 <fen> also, it would be good to extend this so that many L can act together, intuitively, that different subsets of L would give rise to different flows. L' = [L'] -> L -> L
18:07:38 <fen> hopefully this would lead to a steady state distribution under some conditions
18:07:38 * ski . o O ( Hawking radiation )
18:08:18 <fen> turing cant start the universe!?
18:08:20 <geekosaur> or just singularities in general
18:08:25 <fen> the hell are you onabout
18:08:26 <geekosaur> cf. cosmic censorship
18:08:34 <xsperry> is there (&&&)-like operator for functions in base or somewhere else else? not sure I like pulling arrows package just for that
18:08:49 <geekosaur> (which is an attempt to ensure such "experiments" can't leak.)
18:09:08 <xsperry> > map (id &&& (*10)) [1..5]
18:09:10 <lambdabot>  [(1,10),(2,20),(3,30),(4,40),(5,50)]
18:09:31 <mniip> just rotate the black hole really fast
18:09:36 <monochrom> &&& is in base.
18:09:58 <xsperry> oh? ok then
18:10:08 <mniip> that causes a moment of inertia overflow, and the ring 0 singularity escapes the array bounds
18:10:25 * ski has called `(id &&&)', `graph' (and `(||| id)', `cograph')
18:11:25 <monochrom> Hole breed.
18:11:31 <monochrom> err, bleed!
18:12:04 * ski . o O ( <https://en.wikipedia.org/wiki/Field_with_one_element> )
18:12:19 <monochrom> ooohhh field with one element is controversial!
18:17:41 <ski> (anyway, iirc, there are countable models of ZF, where (internally) not every set is countable)
18:18:40 <fen> what about functions which are close to id?
18:19:30 <monochrom> Yeah beware of the line between the target level and the meta level.
18:19:51 <ski> (it's also not clear to me that "turing, an element of the turing machine, conceived the turing machine" would have to mean a cycle, or just that there is an internal (incomplete) description of the system itself. perhaps one could think of that as a "cycle through a meta" ? (hmm .. cf. Löb ?))
18:19:54 <fen> how do we get a measure on lambda terms?
18:20:41 <fen> it seems like the notion of distance is one up from identifiability 
18:21:12 <fen> which is why semantic editor combinators seem difficult to use here
18:22:29 * ski idly wonders whether it would be possible to associate a distance/length with isomorphisms, measuring "distances of invertible paths" between objects, in some category
18:22:33 <fen> sometimes the notion of a derivative of a computational routine relies on soft computing notions like partial membership 
18:23:12 <fen> giving then a kind of baysian formalism for propagation of certainty of a value through the computation
18:24:21 <ski> .. i don't follow
18:25:10 <fen> https://arxiv.org/pdf/1805.11813.pdf
18:25:29 <fen> Derivatives of Turing machines in Linear Logic James Clift, Daniel Murfet May 31, 2018
18:26:45 <fen> for algorithms with discrete inputs and outputs the problem with this intuition is clear: it does not a priori make sense to make such infinitesimal variations. ][ we try to motivate our general point of view on this problem, which is the problem of propagation of error (or uncertainty) through algorithms
18:29:12 <fen> however, this is quite different to the perspective of ergodic theory, which is phrased in terms of the amplification of seperation of two close points under a flow
18:30:02 <fen> where a space can be partitioned into where this distance remains bounded
18:31:04 <fen> the problem is trying to think of L = L -> L as points in some space, and how they flow under some map
18:31:23 <ski> (hm, that paper description slightly reminds me of "A Theory of Chanes for Higher-Order Languages - Incrementalizing λ-Calculi by Static Differentiation" by Yufei Cai,Paolo G. Giarrusso,Tillmann Rendel,Klaus Ostermann in 2014 at <http://www.informatik.uni-marburg.de/~pgiarrusso/ILC/>)
18:32:33 <fen> if well mixed, a result of hyperbolicity, then all configurations or different L can all act on each other to give flow to a stable distribution, or have some preserved measure or observable
18:33:13 <fen> a set is ergodic if it is invarient under action of the evolution opperator, which maps points into each other, like a group orbit.
18:34:22 <fen> it would be good to consider similarly collections of L which visit all configurations and so give a collective action
18:36:44 <fen> ski: thats really cool! its here; https://arxiv.org/abs/1312.0658 
18:37:01 <fen> kind of like reproducing kernal trick
18:38:40 <fen> projection of a nonlinear function into a higher dimensional space giving rise to classification via linear partitioning 
18:39:24 <fen> arises in support vector machines...
18:42:45 <fen> not sure about uniqueness proofs though... infinitesimal variation around initial conditions remaining bounded
18:48:52 <fen> a lattice approach to lambda calculi?
18:51:01 <fen> does seem like differentiation is a good way to get a notion of distance, but with types having discreet terms it seems difficult without soft membership..
18:54:20 <fen> could restrict the input space to being continuous... but then for L this again requires restriction to a manifold of lambda terms...
18:54:39 <fen> which all seems rather complicated
18:58:15 <hololeap> ok, i'm stuck. i can't figure out how i got into this mess with an ambiguous type error or how to get out of it: http://dpaste.com/3VJWXKK
18:58:50 <koz_> hololeap: What error are you getting?
18:59:19 <hololeap> http://dpaste.com/0GGGF9E
19:00:06 <hololeap> and before anyone asks what i'm doing, i was just playing around. but it was compiling not too long ago...
19:01:50 <glguy> hololeap: give 'undefined' a type signature
19:02:43 <c_wraith> or just change it to be extr
19:03:00 <c_wraith> Since that's where you were headed, and you put an explicit type on extr for some reason
19:04:51 <hololeap> it was extr... but i changed it trying to figure out which direction to go. now i get two errors :p  http://dpaste.com/2SR2GFP
19:06:50 <c_wraith> oh, well.
19:06:53 <c_wraith> g is ambiguous
19:07:19 <c_wraith> since it isn't specified by extr or the return type of trieLookup
19:09:18 <hololeap> so... is my code incorrect?
19:09:53 <c_wraith> It's too polymorphic
19:10:06 <c_wraith> *something* needs to specify what instance to use
19:10:28 <c_wraith> It's like read . show
19:10:58 <hololeap> is there an extension that will make ghc more liberal about this kind of thing?
19:11:11 <c_wraith> nothing will remove the fact that you have to specify it
19:11:20 <c_wraith> but there are ways to make it more convenient to do so
19:12:05 <geekosaur> hololeap, "make ghc more liberal" invites ghc to do something like choose ()
19:12:10 <geekosaur> which tends to be kinda useless
19:12:15 <c_wraith> But why is extr polymorphic?  Is the idea that the caller of mapTrieLookup supposed to choose the type g?
19:12:24 <c_wraith> +is
19:12:27 <geekosaur> this is not a place where you want to give the compiler more rope to hang you with
19:12:30 <hololeap> c_wraith: that was the idea
19:12:44 <c_wraith> hololeap: in that case, g needs to be in the type of mapTrieLookup
19:13:39 <c_wraith> hololeap: that used to be done with proxies, but these days it's usually done using TypeApplications
19:14:27 <hololeap> c_wraith: thanks i was wondering how that would be done
19:15:17 <Solonarv> (you still need AllowAmbiguousTypes to *write* the non-Proxy-using function)
19:17:26 <hololeap> aside from the language pragmas, what would i need to add to my code?
19:17:44 <hololeap> i know that it is something like @Type, but i wouldn't know what to add here
19:17:53 <hololeap> or where to add it
19:18:26 <c_wraith> You'd need to rewrite the types for mapTrieLookup to include g and its constraints, and then remove that polymorphism from extr
19:20:33 <hololeap> oh... i see. that wasn't working for me before, but it is now with AllowAmbiguousTypes
19:21:55 <hololeap> so is it something along the lines of, don't use internally scoped types if you are going to pass them to another function? 
19:22:54 <hololeap> i'm just looking for a rule of thumb for using RankNTypes
19:23:22 * ski . o O ( `show . read' )
19:24:01 <hololeap> ski: what?
19:25:31 <Solonarv> the rule of thumb is "don't define a function with an ambiguous type, unless you intend its callers to use type applications"
19:26:25 <ski> `read . show' has type `(Show a,Read b) => a -> b', which is not ambiguous. `show . read' has type `(Read a,Show a) => String', which is ambiguous, since the constrained type variable doesn't occur after the `=>'. so it doesn't know which type to first try to read as, and then to show. (unless one adds a `default' for that)
19:27:44 <ski> > (show . read) "()"
19:27:46 <lambdabot>  "()"
19:27:47 <ski> > (show . read) "0"
19:27:49 <lambdabot>  "*Exception: Prelude.read: no parse
19:28:56 <geekosaur> ^ this is what I meant by giving the compiler too much rope
19:29:34 <hololeap> i don't understand why having the reference and constraints of g attached to `extr` was ambiguous, but having them attached to mapTrieLookup is not
19:29:58 <hololeap> i'm obviously missing something...
19:33:03 <hololeap> is it because there is nothing saying that the g in trieLookup is the same as the g in mapTrieLookup?
19:33:14 <hololeap> unless they're both on the top level?
19:42:18 <xsperry> hololeap, (show . read) has String -> String type, regardless of what Read instance we use.
19:46:33 <infinisil> :t show . read
19:46:35 <lambdabot> String -> String
19:50:36 <hololeap> oh... i get it now. if the type variable isn't exposed in the top-level signature, there's no way for the caller to specify what it should be unless they use TypeApplications
19:52:50 <hololeap> i did not know that you could expose a type variable simply by having a constraint for it
19:54:57 * hololeap sees the error in my logic
20:04:17 <Solonarv> @tell hololeap I would recommend always explicitly quantifying type variables when using AllowAmbiguousTypes/TypeApplications
20:04:17 <lambdabot> Consider it noted.
20:05:31 <Nexilva> Trying to learn haskell is painful.
20:06:04 <c_wraith> Nexilva: it was the hardest time I ever had learning a new language.  But in some sense, it was also the most fun.  I actually had to learn new things!
20:06:18 <Nexilva> Well, that's not the painful part.
20:06:25 <Nexilva> The painful part is too much theory and not enough application.
20:06:36 <rotaerk> depends on the learning resource
20:06:45 <Nexilva> Everywhere I turn it's pages upon pages of mundane unintersting boring dry stuff
20:06:59 <c_wraith> I learned it on the job.  I didn't have that issue.  It was more "why does the code do this?"
20:07:04 <rotaerk> where is "everywhere [you] turn"?
20:07:18 <Nexilva> Literally every single haskell resource every advised to me.
20:07:27 <Nexilva> I can't learn like this. It's impossible I've been trying for over a week now.
20:07:39 <Nexilva> Nothing has yet made sense. I don't even yet know how to write a damn haskell function!
20:07:47 <Nexilva> This is really insane.
20:07:49 <c_wraith> what resources?
20:08:02 <c_wraith> Every one I know of explains how to write a function almost immediately
20:08:15 <Nexilva> https://www.haskell.org/tutorial/goodies.html
20:08:22 <Nexilva> http://learnyouahaskell.com/chapters
20:08:29 <Nexilva> https://www.seas.upenn.edu/~cis194/spring13/lectures/01-intro.html
20:08:36 <Nexilva> https://upload.wikimedia.org/wikipedia/commons/2/26/Haskell.pdf
20:08:46 <Nexilva> https://en.wikibooks.org/wiki/Haskell/
20:08:52 <rotaerk> Nexilva, I see a function definition in that first link of yours
20:08:55 <Nexilva> I could go on... I've like 10 more resources.
20:08:58 <Nexilva> You do!
20:09:00 <Nexilva> I don't!
20:09:07 <Nexilva> *sigh*
20:09:18 <rotaerk> "Functions in Haskell are normally defined by a series of equations. For example, the function inc can be defined by the single equation: inc n = n+1"
20:09:20 <Nexilva> Nothing about any of this is making any sense to me and I feel mental.
20:09:24 <geekosaur> this complaint sounds a lot like "but it's not javascript" or whatever
20:09:28 <Nexilva> I'm extremely frustrated and on the verge of giving up.
20:09:35 <geekosaur> well, no, it's not javascript, or python, or whatever
20:09:49 <geekosaur> if you require a language to be just like what you already know, what's the point?
20:09:50 <Nexilva> rotaerk: taht doesn't help me
20:09:53 <rotaerk> Nexilva, did you not see what I quoted, or did you not consider it satisfying for some reason
20:09:55 <Nexilva> I can't use dry boring theory
20:09:56 <Nexilva> I n eed application
20:10:03 <Nexilva> I need to see actual workign code in action
20:10:05 <rotaerk> that's not theory, that's an actual compilable haskell function
20:10:06 <Nexilva> and then hav eht aexplalined
20:10:09 <Nexilva> thats' how I learn
20:10:18 <Nexilva> I can't rea pages upon pages of mundane nonsense 
20:10:24 <Nexilva> that doesn't help me
20:10:27 <Nexilva> *sigh*
20:11:23 <rotaerk> in most languages, a "function" is a bundle of execution steps that may or may not depend on some input parameters and may or may not return a value
20:11:35 <Nexilva> Today we're going to build this applicat. This will do x y and z. This is what we need to learn in order to code it. Here's how we code it. Here's the explainations of the code. THEN I go look at the documentation and then I can make sense out of it.
20:11:49 <Nexilva> Otherwise, I'm stupid, and I simply cannot piece it together
20:11:54 <Nexilva> I need a whole cohesive thing.
20:11:57 <rotaerk> in haskell, a function is just an expression that depends on an input parameter
20:12:12 <Nexilva> I appreciate the explanation sir, but that still isn't helping me.
20:12:35 <rotaerk> so the point is that haskell "functions" don't really fill the same role as "functions" in other languages
20:12:58 <rotaerk> they cover a subset of the roles that other languages' functions do
20:12:58 <Nexilva> I've read all that, countless times by now
20:13:03 <Nexilva> It still means nothing to me.
20:13:14 <Nexilva> I have yet to see one piece of functional code that does anyting worthwhile.
20:13:19 <Nexilva> it's all theory nonsense that isn't helping me.
20:13:26 <maerwald> What do you want to do?
20:13:28 <rotaerk> what is a concrete example of something you want to know how to do?
20:13:40 <Nexilva> Anything.
20:13:44 <xsperry> main = putStrLn "hello, world"
20:13:54 <Nexilva> Let's start here.
20:13:56 <Nexilva> Sure.
20:15:14 <rotaerk> so now you know how to do something
20:15:24 <Nexilva> Which is 100% useless.
20:15:47 <Nexilva> I feel as if I'm not able to explain myself. I have never been able to explain myself to teachers
20:15:50 <rotaerk> what is an example of something that would be useful to you?
20:16:01 <Nexilva> The entire education system has failed me, and yet here we are again.
20:16:13 <Nexilva> Eitehr I'm stupid... or the way you people teach normally in the world is messed up.
20:16:21 <Nexilva> *shrug*
20:16:37 <rotaerk> learning is always the responsibility of the student; the teacher is just an assistant
20:16:39 <Nexilva> Like in other languages, they build a functional application.
20:16:43 <Nexilva> something actually does something.
20:16:54 <Nexilva> Then they code it slowly, piece by piece, explaining as they go.
20:17:00 <Nexilva> I've asked this thirce now
20:17:12 <Nexilva> I don't get what is so hard to understand about what I'm asking.
20:17:14 <rotaerk> they do that in books that teach the language itself?
20:17:22 <Nexilva> EVERYWHERE, yes.
20:17:31 <Nexilva> That's how I learn. By building things.
20:17:44 <Nexilva> I am not the theory guy. I read pages upon pages of theory and pretend I understand anything
20:17:56 <Nexilva> It'a aliteral haze i my mind. One entire week, countless hours reading and sturyign
20:17:59 <MarcelineVQ> What is hard is you haven't asked anything yet.
20:17:59 <Nexilva> and I am at 0%
20:18:10 <Nexilva> I feel like I've made no progress and my entire time has been wasted.
20:18:30 <Nexilva> Sir, I have been asking desperately for a while now.
20:18:42 <Nexilva> I'm sorry you can't understand What I'm asking. Very sorry for me.
20:19:08 <rotaerk> as I said, learning is the student's responsibility, and the teacher is just the assistant; part of the student's job is to formulate targeted questions.  so far all I've seen you ask for is a broad walkthrough of building an entire application, which isn't targeted
20:19:23 <rotaerk> you need to think through how you can break that down into multiple smaller questions
20:19:26 <Nexilva> Yes it is targeted.
20:19:43 <Nexilva> For example, in php, or python, you build some application, anything, and it explains parts.
20:19:45 <Nexilva> For example
20:20:17 <rotaerk> you mean, in PHP or python *books*?
20:20:21 <Nexilva> YES!
20:20:23 <Nexilva> wher eslse?"
20:20:25 <Nexilva> omg
20:20:33 <Nexilva> now I'm screaming in frustration in my room
20:20:35 <Nexilva> Sigh.
20:21:22 <Nexilva> I'm astonished how you haskell people are so unfamiliar with the concetp fo building an actual functional application.
20:21:23 <rotaerk> I don't know of any haskell resources that follow that pattern; but I've also never seen it in a book for other languages; I can't help you with that particular request
20:21:26 <Nexilva> Instead of just hello world nonsense.
20:21:47 <Nexilva> So haskell people don't buid working apps?
20:21:56 <Nexilva> what do you do? theorize and write papers and get patted ont he back?
20:22:02 <Nexilva> that seems fairly useless.
20:22:12 <rotaerk> the existence or non-existence of a application-building walkthrough has nothing to do with whether the users of the language can actually build applications
20:22:26 <Nexilva> it does.
20:22:28 <Nexilva> Clearly it does.
20:22:30 <Solonarv> (fact: applications are indeed built in haskell)
20:22:30 <MarcelineVQ> The backpats are self-administered, travel is expensive
20:22:30 <xsperry> Nexilva, you were specifically asked what you wanted, and you said "anything". hello world is a start.
20:23:09 <rotaerk> I never read a book that walked me through building an application; I just learned C, C++, C#, etc and then, through tinkering, figured out how to construct applications from those fundamental mechanisms
20:23:11 <xsperry> if someone had pasted 10k program instead, that would probably be less helpful
20:23:29 <rotaerk> I then learned the haskell mechanisms, and figured out how to build complex things from them through tinkering
20:23:43 <Nexilva> Not everone is you.
20:23:55 <Nexilva> Some people are stupid.
20:24:01 <Nexilva> Perhaps I am just too stupid for this.
20:24:04 <Nexilva> It's okay.
20:24:16 <Nexilva> Not everyone has a high enough IQ to accomplish certain things.
20:24:38 <Nexilva> I did my best. I spend a week and countless hours
20:24:45 <Nexilva> And have made 0% sense out of any of this.
20:24:54 <rotaerk> I think you're expecting too much of the world and thinking too little of yourself... I don't believe that you can't figure it out.  also, a week is nothing
20:24:58 <Nexilva> No one seems willing to be able to help and I feel very unwelcomed.
20:25:10 <Cale> Nexilva: It took me about 2 months to feel like I could do useful things with Haskell and about a year to be comfortable
20:25:12 <rotaerk> I definitely couldn't make a practical application after a week of my first language, or haskell
20:25:22 <Nexilva> https://www.stackbuilders.com/tutorials/haskell/gui-application/\
20:25:22 <Cale> What did you need help with?
20:25:25 <Nexilva> For example
20:25:28 <Nexilva> EXAMPLE!
20:25:36 <rotaerk> I *could* make pracctical appliccations in C# after a week, but that's just because I had C++ experience already
20:26:02 <Nexilva> I need stuff like this.
20:26:12 <vaibhavsagar> well, there it is
20:26:13 <Cale> Haskell is fundamentally different from most imperative programming languages that you might already know, so you shouldn't expect to pick it up in a week. It's more like re-learning how to program.
20:26:18 <Nexilva> That's when I look at docs of the lanauge, and figure out for myself what the syntax maeans
20:26:23 <vaibhavsagar> you found it, congratulations
20:26:28 <Nexilva> oh window <- window New
20:26:30 <Nexilva> oh ok
20:26:37 <Nexilva> let's see what arrow means
20:26:41 <Nexilva> I research on my own.
20:26:52 <Nexilva> if I anly see stupdi thigns like pi * 2
20:26:59 <Nexilva> that's how you use haskell
20:27:03 <Nexilva> or hello world nonsense
20:27:11 <vaibhavsagar> okay, that's a concrete question we can answer
20:27:11 <Nexilva> nothing happens in my mind.
20:27:19 <Nexilva> Stop/
20:27:21 <Nexilva> Riht here.
20:27:23 <Nexilva> Just sotp.
20:27:23 <rotaerk> what the arrow means is not something you learn from something that teaches "how to build an application"; that's something you learn from something that teaches the mechanisms of the language
20:27:27 <Nexilva> I don[t need an arrow explained to me.
20:27:32 <Nexilva> Yu're still missing my point.
20:27:34 <Nexilva> *sigh*
20:28:00 <vaibhavsagar> okay, what does the arrow do then?
20:28:14 <Nexilva> I don't know. I will have to find out by reseaching the language docs myself.
20:28:18 <Nexilva> I don't have a probme with working had.
20:28:20 <Nexilva> hard*
20:28:30 <xsperry> I don't think GUI is a good place to start when you don't even know how to define a function, regardless of language
20:28:32 <vaibhavsagar> I mean, I could just tell you if you want
20:28:40 <Nexilva> I asked you, I can't process things in a certain way. My abstraction ability is dulled due to my autism. I need things in a very specific way in order to process them.
20:28:45 <Nexilva> Why can't anyone understand that.
20:28:51 <MarcelineVQ> Nexilva: pretty good language doc if you haven't seen https://www.haskell.org/onlinereport/haskell2010/
20:28:51 <Nexilva> my frustration is building to immense levels.
20:29:41 <vaibhavsagar> so you're frustrated because you haven't found a Haskell tutorial that is tailored to your very specific learning needs?
20:29:42 <rotaerk> Nexilva, would it help if the learning resource gave you exercises after the theory, to prompt you to apply it?
20:29:50 <Nexilva> vaibhavsagar: that is corect, sir, yes.
20:30:06 <Nexilva> That's what I am having trouble with.
20:30:11 <vaibhavsagar> do you want validation or suggestions?
20:30:17 <Nexilva> Both, please.
20:30:27 <Nexilva> To validate my difficulty if you want.
20:30:31 <Nexilva> If not, then suggestions.
20:30:37 <rotaerk> Nexilva, have you checked out http://haskellbook.com/assets/img/sample.pdf ? it has practical exercises
20:30:46 <Nexilva> Yes, that's the words
20:30:48 <rotaerk> (the full book you'll need to buy, if you like it)
20:30:50 <Nexilva> Practice exercies!
20:31:06 <Nexilva> That's what I like. But with examples like in math books.
20:31:43 <vaibhavsagar> the book rotarerk suggested is like that, I will second that recommendation
20:31:51 <Nexilva> Ok
20:31:59 <Nexilva> finally! we're getting somewhere.
20:32:01 <Nexilva> Thank you.
20:32:03 <rotaerk> go to the root URL for the link to get the actual book; this is just their sample
20:32:13 <vaibhavsagar> there's also https://github.com/data61/fp-course
20:32:16 <vaibhavsagar> learn by doing
20:32:30 <Nexilva> I can't learn by reading my mind shuts off. I only learn by doing.
20:32:33 <vaibhavsagar> it's all practice exercises
20:32:42 <Nexilva> I learn only exctly the concepts I only need to build tha tparticlar thing.
20:32:49 <Nexilva> THEN move on to build another thing and learn new concepts.
20:32:56 <Nexilva> I can't read concetps and then learn and then try to build something
20:33:01 <Nexilva> My mind just doesn't work that way.
20:33:02 <vaibhavsagar> fp-course is structured like that
20:33:08 <Nexilva> Thank you, I'm checking it out
20:33:21 <rotaerk> well, most people best learn abstract concepts only after they understand concrete examples
20:33:35 <Nexilva> Most people are not severely autistic.
20:33:36 <angerman> vaibhavsagar: you up late!
20:33:47 <Nexilva> I have to work very hard to be functional.
20:34:00 <Nexilva> My frustration usually builds easily. Sorry if I was rude.
20:34:03 <Nexilva> I don't mean to be.
20:34:09 <Nexilva> Now I foudn something my mind is a bit more calm.
20:34:10 <vaibhavsagar> angerman: not really, it's 11:30pm here on a Saturday night, and I'm procrastinating on writing some slides :)
20:34:33 <angerman> Oh right it’s Saturday.
20:34:40 <vaibhavsagar> :D
20:34:49 <fresheyeball> So I am working through a problem
20:34:52 <rotaerk> Nexilva, I'm saying that what you're describing as something you need ... is basically the way most people learn abstract things
20:34:53 <angerman> I’m living in the future
20:34:55 <fresheyeball> and I have come up with a solution
20:35:02 <fresheyeball> but I am not jazzed about it
20:35:15 <fresheyeball> so I would like to appeal to the community for feedback
20:35:15 <rotaerk> i.e. they need to see specific examples before they really start to grasp the abstract generalization of them
20:35:42 <Nexilva> rotaerk: I'm sorry I just can't see anything other than what my brain processes to see. 
20:35:54 <Nexilva> So far, what you're saying isn't processed.
20:36:29 <Nexilva> There is a certain kind of abstraction I am unable to process. 
20:36:33 <angerman> FWIW: I didn’t learn haskell from books. In fact I don’t even like the haskell book much. Take a problem and try to solve it. Then try another one. Then try again.
20:36:52 <Nexilva> The language is like playing nethack.
20:36:59 <Nexilva> barey any keywords, and all it is is just symbols
20:37:05 <Nexilva> it's very difficult for me.
20:37:21 <Nexilva> + < << and -> arrows and (+) and what not
20:37:28 <Nexilva> no other languag is so severely cryptic.
20:37:41 <angerman> Apl?
20:37:42 <vaibhavsagar> have you heard of APL?
20:37:42 <xsperry> everything but -> there is an infix function
20:37:48 <Nexilva> it's just ... my brain is having immense difficulty. anyway. I'm going to go read more now.
20:37:52 <Nexilva> Thanks for helping me.
20:37:54 <angerman> Agda?
20:37:57 <vaibhavsagar> or K, or J
20:38:06 <vaibhavsagar> or Perl maybe
20:38:06 <rprije> Hey-o. Are there any good techniques for doing deserialisation of existentially quantified types? I want to make a SafeCopy instance for such a type and I'm having trouble convincing the compiler to use safeGet on the wrapped type (it doesn't like the ambiguity of the type)
20:38:33 <Solonarv> C++ can be a mess of symbols too
20:38:46 <angerman> Nexilva: you don’t need most of those symbols. Not at first.
20:39:13 <vaibhavsagar> someone compared Haskell to Perl some time ago and I was pretty offended, but I've come around to that point of view recently
20:39:18 <vaibhavsagar> it's a big language
20:39:26 <rotaerk> the language itself is rather small
20:39:43 <rotaerk> at least, the core language... maybe big once you add in all the extensions
20:39:47 <monochrom> I wouldn't refer to more-symbol languages like APL, but I would disbelieve the aritificial distinction between "words are easy, operatos are hard".
20:39:59 <vaibhavsagar> even without the extensions
20:40:04 <vaibhavsagar> things like pattern guards
20:40:07 <Solonarv> If you don't count extensions, you're living in the '90s
20:40:15 <Nexilva> What's hard is change. The brain fights it.
20:40:19 <Nexilva> surely you know basic biology.
20:40:30 <angerman> Nexilva: however (+) is just a way to write infix (here +) as prefix. 1 + 2 == (+) 1 2; there is also the inverse: f x y == x `f` y
20:40:33 <Nexilva> I've not known anything but imperative.
20:40:38 <vaibhavsagar> a type constructor starting with `:` can be an infix operator
20:40:48 <Nexilva> So you can witness the fight my brain is having, right?
20:40:53 <vaibhavsagar> Nexilva: most of us here also have an imperative background
20:40:55 <monochrom> Like unless you came from the 16th century it is actually facetious to assert "one plus two times three" is more readable than "1+2*3".
20:41:06 <angerman> vaibhavsagar: Perl is write once. Haskell is not.
20:41:21 <vaibhavsagar> that's true
20:41:23 <Nexilva> monochrom: no one codes like that anyway. That example is too exagerated
20:41:30 <rotaerk> programmers whose first language was purely functional are the minority; rare pokemon
20:41:42 <Nexilva> vaibhavsagar: oh fantastic
20:41:45 <monochrom> Ah check out COBOL then! "Multiply x by y into z".
20:41:46 <Nexilva> Then I'm not alone :)
20:41:50 <julianleviston> monochrom: I agree… people think if they can pronounce a word they undersatnd the intent of the word. Not true :)
20:41:53 <vaibhavsagar> Nexilva: times(1, plus(2, 3))
20:41:57 <Solonarv> yup, another imperative-first programmer reporting in
20:42:01 <Nexilva> I dunno why I keep thinking you guys are all probably university professors and teachers and stuff
20:42:08 <Nexilva> I feel dumb.
20:42:10 <vaibhavsagar> lots of programmers prefer words over symbols
20:42:37 <angerman> vaibhavsagar: lack of math edu :p
20:42:38 <vaibhavsagar> list.get(1)
20:42:40 <vaibhavsagar> especially if they are Java programmers
20:42:53 <Solonarv> if they're java programmers, they don't have a choice
20:43:07 <rotaerk> people have this perception that haskell is a language for smart people ... I guess because it's "mathy" (because math is only for smart people?) ... but its features basically make it a language for mortals ... while assembly and C are for gods
20:43:09 <vaibhavsagar> angerman: you're right, it should be `plus(1, times(2, 3)`
20:43:34 <julianleviston> rotaerk: sure… but you have to do the work upfront to understand things, which is probably why ;-)
20:43:48 <Nexilva> One of the biggest problems in the world today is the lack of mathematical education
20:44:03 <angerman> vaibhavsagar: Sum(1, Prod(2,3))
20:44:12 <vaibhavsagar> woah
20:44:13 <rotaerk> julianleviston, yeah I think that's another reason for the *perception*.  but I don't think haskell is necessarily harder to learn than, say, C++ ... I'd say C++ may even be harder
20:44:18 <julianleviston> Nexilva: so, not malaria, or aids then?
20:44:18 <Nexilva> Mathematics is what helps to form neural connections in the brain for higher level thinking
20:44:29 <Nexilva> julianleviston: correct.
20:44:36 <rotaerk> it's just that people are expecting their existing programming background to give them a leg up with haskell, and it doesn't
20:44:40 <julianleviston> Nexilva: could you show your working out, plz? ;-)
20:44:47 <rotaerk> so they see *different* and assume *hard*
20:44:54 <julianleviston> rotaerk: also there are far less educational resources for it. :)
20:45:04 <julianleviston> rotaerk: different *is* hard ;)
20:45:11 <julianleviston> rotaerk: coz you have to do work to get it :)
20:45:23 <Nexilva> julianleviston: those problems will be non-problems with more people being educated in mathematics, which will cause their brains to be able to think critically and reason better. Possibly make better choices in life that don't lead to AIDS transmission.
20:45:24 <vaibhavsagar> angerman: it's only two steps away from a type definition
20:45:34 <julianleviston> rotaerk: however, haskell is decidedly *simpler*. Doesn’t mean easier tho :)
20:46:14 <julianleviston> Nexilva: ok, we’re talking cross-purposes. Maybe we just need to leave that part of the convo alone :)
20:47:03 <monochrom> Nash made many poor choices in life.
20:47:05 <rotaerk> saying that haskell is hard because their C++ background doesn't give them much of a head start in learning it, compared to a new programmer, is like saying plumbing is hard because C++ doesn't give them a head start, compared to a new plumber
20:47:18 <fresheyeball> https://dpaste.de/kmCK
20:47:19 <julianleviston> rotaerk: I agree haskell is easier to learn compared to procedural or OOP… 
20:47:24 <fresheyeball> ok
20:47:37 <julianleviston> rotaerk: although, it’s not easier *in reality* because there are less education materials available, and less people avaialble.
20:47:39 <fresheyeball> so that an example of the data
20:48:00 <fresheyeball> my current idea is to do this in 2 steps
20:48:12 <fresheyeball> step 1, get all the Ints out of the input
20:48:20 <julianleviston> rotaerk: and I think it’s a valid perspective to *understand where people currently *are** and teach them according to *that*.
20:48:35 <rotaerk> julianleviston, I think the fewer materials/people is primarily a problem due to the fact that the language itself is so different.  other new languages get adoption much more quickly, with fewer learning resources, because they're so similar to the languages people are used to
20:48:40 <fresheyeball> step 2, map over the list of all ints, and query all rows of the input
20:48:46 <rotaerk> e.g. Rust
20:48:51 <julianleviston> rotaerk: Yeah, sure. I’m just saying why it’s harder :)
20:48:55 <monochrom> rotaerk: Wait a second, I thought it was: C++ is hard because my Haskell background doesn't give me a head start, like plumbing is hard because Haskell doesn't give me a head start. :)
20:49:11 <julianleviston> rotaerk: there are all sorts of reasons. As people who know haskell, it’s our “duty” to make it easier to learn if we’re interested in that.
20:49:21 <rotaerk> monochrom, well, that too :P
20:49:35 <fresheyeball> \x (create, deleted, k v) -> create >= x && x <=deleted
20:49:36 <Solonarv> monochrom: your Haskell background gives you a head start in moaning about the templates and (lack of a) module system
20:49:41 <Solonarv> ;)
20:49:45 <julianleviston> ironically haskell gives you a head start in bot C++ *and* plumbing ;-)
20:50:06 <julianleviston> coz more of haskell is universally applicable.
20:50:13 <rotaerk> although I think haskell would make learning other languages easier where the reverse isn't true
20:50:18 <julianleviston> definitely.
20:50:27 <rotaerk> the difficulty when learning them would be "why doesn't this work!"
20:50:31 <julianleviston> one reason why it’s a pity they dropped it at many universities
20:51:21 <julianleviston> and lisp.
20:53:05 <monochrom> fresheyeball: I'm wondering if http://hackage.haskell.org/packages/search?terms=multimap helps
20:53:14 <julianleviston> One of my current favourite sussman lectures… https://www.youtube.com/watch?v=O3tVctB_VSU he talks about propagators a bit, which edwardk built a lib for relatively recently…
20:56:07 <rotaerk> Nexilva, I wonder if one reason you have problems learning from certain resources is that you're focused on the "how do I build an application with this?" question throughout the entire process.  rather your mentality should perhaps be to just absorb *without an agenda* whatever it is that the material wants to present to you.  then you can always ask that other question later
20:56:47 <rotaerk> (building an application isn't the point of the material, so that's the wrong question to ask it)
20:59:20 <Nexilva> rotaerk: do you control your neurology?
20:59:28 <Nexilva> rotaerk: do you control how your neurons fire?
20:59:46 <julianleviston> rotaerk: I think I have a similar learning style to Nexilva… I also had a hard time learning things at the beginning, because I wanted to have an example-driven learning path. I personally find it incredibly difficult to learn things unless I have good interesting examples to use.
20:59:52 <Nexilva> rotaerk: do you control the amount of your neurochemicals coursing through your brain?
20:59:56 <rotaerk> for instance, if it shows you how to build that `inc n = n+1` function, you shouldn't expect to immediately see how this fits into the larger effort of building an application; just understand it on its own merits: a simple function of integers
21:00:18 <Nexilva> Where exactly is this 'mentality' you speak of? It should be this, or it should be that? No sir. It is exactly what it physically is.
21:00:28 <Nexilva> You cannot control your neurology, and you cannot control yuor psychology.
21:00:41 <Nexilva> There is no control. There is no should or should not. There is only 'what is'.
21:00:43 <julianleviston> rotaerk: some of us find it difficult to remember things if they’re not pumbed directly into our experience, and understanding is derived from seeing the use of things in context.
21:01:00 <monochrom> rotaerk: Hey I know how to answer that question! Learned from Scott Aaronson. "My neurons force me to answer yes I control my neurons. What choice do I have?!"  hehe
21:01:00 <Nexilva> Julian is far more aticulate than myself.
21:01:33 <c_wraith> Nexilva: maybe https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours is for you
21:01:36 <rotaerk> julianleviston, remembering comes with practice and repetition; when learning you shouldn't worry about remembering.  you can always go back and re-read if necessary
21:01:55 <rotaerk> even if you can't recall exactly what you "learned", you still learned something
21:01:57 <Nexilva> Sir, practice divides.
21:01:58 <julianleviston> rotaerk: sure… but without a “bigger picture”, often some of us flounder and dont’ find motivation :)
21:02:05 <Nexilva> Practice is the worse thing you can do in any endeavor.
21:02:06 <c_wraith> Nexilva: it's a project-based intro.  You write a pretty big scheme interpreter
21:02:10 <Nexilva> The practice always divides
21:02:19 <Nexilva> There is then the one who practices, and the thing to be practiced.
21:02:21 <julianleviston> Nexilva: please qualify — practice is useful for some people.
21:02:23 <Nexilva> Division is violence of the mind.
21:02:31 <Nexilva> To divide, you must break. You must cut. You must slice
21:02:40 <Nexilva> To divide, you must violate with violence.
21:02:45 <julianleviston> Nexilva: there are other ways of viewing things… where division *isn’t* violence.
21:02:45 <c_wraith> Nexilva: that logic applies to every single thing that can be done.
21:02:51 <Nexilva> I refuse to live an existence of violence.
21:02:58 <Nexilva> I do not live i division.
21:03:01 <c_wraith> now you're just trolling
21:03:06 <julianleviston> Nexilva: perhaps try to accept that there are other ways of doing things that just your own.
21:03:16 <Nexilva> I do not practice. I do not create the one who practices and thing to be practiced.
21:03:37 <monochrom> What is practice?
21:03:37 <c_wraith> you also do not breath.  you do not create the one who breathes and the action of breathing
21:03:40 <monochrom> (Why not?)
21:03:50 <julianleviston> Nexilva: while it’s lovely to have that incredibly buddhist view, perhaps realise you’re not going to find much sympathy in this channel for the way you’re couching these things.
21:04:19 <monochrom> Actually I think it's Daoist.
21:04:27 <julianleviston> monochrom: sure :)
21:04:41 <monochrom> (I mean, "why not?" again :) )
21:05:01 <Nexilva> julianleviston: sir, there is no law sacred to me but that of my own nature.
21:05:11 <Nexilva> julianleviston: what is right, just and good, is what is to MY constitition.
21:05:15 <julianleviston> Nexilva: how does this help me or you?
21:05:20 <Nexilva> What is wrong, unjust, and evil... is everythign that is against it.
21:05:40 <monochrom> I think we're heading for "Haskell is evil" now.
21:05:48 <c_wraith> everything is evil
21:05:56 <c_wraith> You can always divide anything into steps
21:06:00 <julianleviston> :)
21:06:02 <monochrom> I don't actually mind. This is exciting! I have always wanted to be evil...
21:06:17 <c_wraith> And therefore doing anything is committing evil.
21:06:24 <rotaerk> Nexilva, while it's objectively true that biology and disorders influence and limit you in certain ways, as the person with that biology, you should never use it as an excuse for your behavior.  it's basically defeatism.  it also turns that supposed limitation into a self-fulfilling prophecy.  it's possible that your biology might make it *harder* to do something, but the moment you use that as a reason that you *can't* is the moment it 
21:06:24 <rotaerk> becomes an insurmountable wall.
21:06:28 <c_wraith> Pretty powerful philosophy
21:06:42 <julianleviston> s/he is talking about division being antithetic to having a unified mind and body and spirit towards having an “aim”. :)
21:06:55 <Nexilva> julianleviston: offtopic now, but I would add that Buddha was a deluded charlatan, an idiot who not only let himself be fooled by 'thought'... he fooled countless others. If it wasn't for the King Ashok, budhism would have died out a long time ago.
21:07:21 <Nexilva> rotaerk: I think what you're saying is that one should take responsibility for one's actions, yes?
21:07:29 <MarcelineVQ> Oh, nooow we're offtopic :>
21:07:46 <Nexilva> rotaerk: I did not go into the market today, naked, dancing, singing, making a spectacle of myself.
21:07:50 <julianleviston> Yeah, maybe let’s talk about Haskell.
21:07:55 <Nexilva> rotaerk: am I responsible for that action?
21:08:04 <julianleviston> couch it in Haskell terms… :) if you understand what you’re saying, you can do that :)
21:08:10 <rotaerk> if you want to keep talking about this, let's take it to #haskell-blah
21:08:17 <monochrom> I thought practice was how to unify mind body and spirit.
21:08:21 <Nexilva> rotaerk: I understand what you're saying, but that's another cultural incarceration that I do not with to be ... clapped by others into the jail.
21:08:30 <Nexilva> Mind is a myth.
21:08:33 <Nexilva> There is no such thing as mind.
21:08:43 <monochrom> and armchair philosophy was how to divide mind from reality.
21:08:44 <c_wraith> how does any of this help you learn Haskell?
21:08:44 <Nexilva> spirit is also just another construct of 'thought'.
21:09:01 <Nexilva> Anyway, like I said offtopic. Let's focus on learnign methods.
21:09:22 <c_wraith> Nexilva: if you scroll back a ways, you can find a link to Write Yourself a Scheme in 48 hours.
21:09:27 <c_wraith> You should look at it.
21:09:33 <c_wraith> It's a project-driven introduction
21:09:37 <Nexilva> monochrom: philosophy is a tool for the enfeebled minds. 
21:09:40 <julianleviston> also what’s wrong with the cis course?
21:09:45 <Nexilva> I've loaded it, than you
21:09:49 <Nexilva> thank*
21:09:57 <julianleviston> Nexilva: have you done the CIS course?
21:10:02 <Nexilva> What is a cis course?
21:10:10 <Nexilva> cis? like in genders?
21:10:12 * Nexilva is confused
21:10:12 <julianleviston> @where cis194
21:10:13 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
21:10:18 <julianleviston> That.
21:10:26 <Nexilva> Yes, I am reading that as well.
21:10:48 <julianleviston> good.
21:10:53 <Nexilva> I think I might need to rethink my approach to haskell.
21:11:01 <rotaerk> cis as in computer information systems
21:11:03 <julianleviston> Nexilva: what’s your current approach?
21:11:05 <Nexilva> Perhaps I am approaching it from an imperative mindset.
21:11:45 <julianleviston> Nexilva: this might help: http://www.happylearnhaskelltutorial.com/1/main_road.html
21:12:17 <rotaerk> imperative programs and subprograms exist in haskell, they're just represented as *values* that a function can return
21:12:50 <Nexilva> They’re expressed in the world of the computer, where pure thought can exist. 
21:13:05 <Nexilva> And one has to watch the movement of 'thought' very carefully.
21:13:18 <Nexilva> In programming or elsewhere, I've discovered one universal truth
21:13:26 <Nexilva> 'thought' is the most cunning thing in the Universe.
21:13:31 <Nexilva> Thought isn't there to serve the thinker.
21:13:37 <Nexilva> On the contrary.
21:13:58 <rotaerk> for instance:  greetAs myName = do { putStrLn ("Hi, I'm " ++ myName ++ ". What's your name?"); yourName <- readLine; putStrLn ("Nice to meet you, " ++ yourName) }
21:14:11 <rotaerk> you might see that thing starting with do and ending with } to be an imperative program
21:14:15 <Nexilva> I can read that and make some sense of it.
21:14:26 <Nexilva> I do see that, yes
21:14:55 <rotaerk> but that entire block is essentially a value of type IO (), and it's being returned by the greetAs function
21:15:06 <Odarevlis> Is this a good channel to learn haskell? I don't want to swamp others with newb questions if there is a more appropriate channel. I'd love some help with BST specifically. It is homework.
21:15:12 <rotaerk> so even though it's imperative, the overall function is still pure
21:15:26 <xsperry> Odarevlis it is
21:15:32 <Nexilva> greetAs is a function which takes myNAme as argument and this function is defined as do putstringline, read from iput, etc. 
21:15:33 <julianleviston> Nexilva: I think it’s helpful to realise haskell programs are written on a level *above* imperative languages. In Haskell, the compiler builds an imperative program out of your main value.
21:15:34 <Nexilva> very simple.
21:15:36 <Solonarv> Odarevlis: it is, there is also #haskell-beginners
21:15:39 <Nexilva> I can understand that bit of haskell sure
21:15:45 <Odarevlis> Okay cool. 
21:16:09 <Nexilva> I see.
21:16:17 <Nexilva> I don't see.
21:16:21 <julianleviston> Odarevlis: generally people will try to help you understand what you need to know in order to solve the homework yourself rather than just give you the answers (mostly).
21:16:22 <rotaerk> Nexilva, functions just take a value as a parameter and return a value as a result.  the value that's a result is the entire do-block
21:16:26 <Nexilva>  rotaerk │ but that entire block is essentially a value of type IO ()
21:16:39 <Odarevlis> I'm not looking for answers, but wanted to be upfront about it. 
21:16:47 <Odarevlis> Does that make sense? 
21:16:50 <julianleviston> Odarevlis: yeah this is an ideal place.
21:16:50 <Nexilva> Yes, I understand pure functions as much as I do.
21:17:23 <Nexilva> main :: IO () what is this?
21:17:36 <julianleviston> Nexilva: it’s a type declaration for main.
21:17:54 <Nexilva> I havne't evne yet found a document that explains the variosu haskel syntax
21:18:03 <Nexilva> I know programming concetps. I just cant' make sense ofu to haskell.
21:18:04 <julianleviston> Nexilva: the haskell report explains the syntax.
21:18:08 <Nexilva> What does anythingin haskell mean?
21:18:14 <Nexilva> It's just a bunch of symbols
21:18:23 <Nexilva> What is a :: and <- and << and (+) and $ and all that
21:18:36 <julianleviston> Nexilva: :: means “has type”
21:18:40 <julianleviston> Nexilva: <- is part of do syntax.
21:18:45 <julianleviston> Nexilva:  << is the name of a function.
21:18:51 <Nexilva> You don't have to tell me
21:18:53 <julianleviston> Nexilva:  (+) and ($) are the names of functions.
21:18:58 <julianleviston> Nexilva: werne’t you just asking?
21:18:58 <Nexilva> You can linke me to a doc?
21:19:02 <Nexilva> I can read the whole thing myself.
21:19:07 <Nexilva> that way you don't have to burn calories.
21:19:07 <rotaerk> I think they were intended as rhetorical questions
21:19:07 <julianleviston> Nexilva: that’s called “learning haskell".
21:19:20 <julianleviston> Nexilva: We have linked you to documents.
21:19:21 <Nexilva> rotaerk: yes they were.
21:19:25 <rotaerk> to demonstrate the kinds of questions they have trouble answering on their own
21:19:29 <Nexilva> *sigh*
21:19:46 <Nexilva> Where is the document anywhere that quickly explains all the syntax/symbols used in haskell
21:19:48 <julianleviston> Nexilva: well.. you want an answer for *everything*, but things aren’t what you think they are.
21:19:52 <Nexilva> so when I read code and examples, Ic an make sense of it.
21:19:52 <julianleviston> Nexilva: symbols arne’t syntax!
21:19:58 <julianleviston> Nexilva: only *some* symbols are syntax.
21:19:58 <Nexilva> WHATEVER IT IS
21:20:03 <Nexilva> CAN I PLEASE GET A LIJNKL TO READ!
21:20:05 <Nexilva> omg.
21:20:07 <Nexilva> sotp aruging
21:20:15 <Nexilva> just give me the damn docs.
21:20:20 <MarcelineVQ> I linked https://www.haskell.org/onlinereport/haskell2010/ earlier.
21:20:27 <monochrom> My view: Stop demanding, start offering payment.
21:20:40 <julianleviston> good view
21:20:41 <rotaerk> Nexilva, you were complaining that these resources were just teaching you "theory", but weren't teaching you how to actually build an application.  thing is, that "theory" is precisely what would answer these questions
21:21:00 <rotaerk> they just introduce this stuff incrementally
21:21:01 <Nexilva> rotaerk: I understand, but only after I look at some code. 
21:21:24 <Nexilva> I can't just learn some abstract concepts and apply them. I forget too quickly and I have to read over and over adn over and it still doesn't retain.
21:21:26 <julianleviston> Nexilva: did you read http://www.happylearnhaskelltutorial.com yet?
21:21:36 <Nexilva> I have to build something manually and only then do I retain that information that I'm building.
21:21:41 <julianleviston> Nexilva: if you go through that, it’s a set of example programs that will slowly teach you all you’re asking for.
21:21:42 <Nexilva> It's not like I can read a chapter in a book and retain it.
21:21:45 <Nexilva> No matter how many times I read it.
21:21:49 <Nexilva> My brain is not wired like yours.
21:22:00 <julianleviston> Nexilva: so go through http://www.happylearnhaskelltutorial.com and type the programs in as you read it. :)
21:22:04 <Nexilva> :)
21:22:08 <Nexilva> Thank you. give me time.
21:22:10 <rotaerk> Nexilva, you're assuming my brain works like that at all :P
21:22:18 <rotaerk> I can't retain it just by reading it
21:23:01 <Nexilva> Exactly. Like when I read ... oh for example, I dunno, Thoreau, or Emerson... or Satre or Kant, I find myself reading a single paragraph for days sometimes...
21:23:08 <Nexilva> over and over, pondering deeply.
21:23:23 <Nexilva> I don't mind that with haskell, I just need something concerete to build. that's all.
21:23:40 <julianleviston> It’s difficult to build something if you don’t know the language.
21:23:52 <Nexilva> so build tiny things
21:23:54 <julianleviston> but, you can do small programs as exercises
21:24:02 <Nexilva> You go bigger as you learn the language more
21:24:07 <julianleviston> yep. so go do that.
21:24:09 <julianleviston> now
21:24:09 <Nexilva> You can't just learn a language and then start buildilng.
21:24:11 <Nexilva> You can't do that.
21:24:12 <julianleviston> go do it now.
21:24:17 <Nexilva> Ok.
21:24:20 <julianleviston> :)
21:24:27 <Nexilva> Thank you guys :)
21:24:46 <Odarevlis> I’m working from a template that the professor provided. In a Tree data structure, what does the line “deriving (Eq, Show)” mean?
21:25:00 <julianleviston> Odarevlis: do you undersatnd typeclasses yet?
21:25:20 <monochrom> Enables equality tests and printing (in REPL) for Tree.
21:25:31 <julianleviston> monochrom: much better answer :)
21:25:35 <monochrom> I guess s/in REPL/in REPL for example/
21:26:22 <monochrom> It's what I tell my students at an early stage when I can't go over type classes yet.
21:26:57 <monochrom> It's OK since one or two weeks later I get to type classes.
21:27:05 <julianleviston> monochrom: haha I pretty much always teach constraints before teaching classes.
21:27:25 <julianleviston> monochrom: by the time instances and deriving comes up, it’s pretty obvious what they do.
21:27:27 <Solonarv> whoa, who do you teach constraints to if you're not teaching classes yet?
21:27:28 <Solonarv> :p
21:27:40 <julianleviston> Solonarv: nice ;-)
21:27:56 <monochrom> I also do live-coding in lectures so at least I can show "if you don't include this, see? no equality test, no printing"
21:28:30 <monochrom> haha Solonarv
21:29:13 <Odarevlis> Our teacher just kinda through us into the mix. Told us to download haskell and go at it. Sort of.. I'm exaggerating a tiny bit. 
21:30:19 <monochrom> Oh I am doing that too.  But I'm less evil.  The current homework is just "here is faulty code, fix it".  Also it's just Integer -> Integer -> Integer so very little to worry about for now.
21:30:48 <julianleviston> Odarevlis: cool. So deriving automatically writes some code for your type that … as monochrom pointed out… lets you use equality and string printing functions on your data type.
21:30:51 <Solonarv> "here is faulty code, fix it" - that's a nice approach
21:31:03 <monochrom> Hell, in fact, why don't I show you: http://www.cs.utoronto.ca/~trebla/CSCC24-2019-Winter/lab02/
21:31:07 <Solonarv> ('Eq' for equality, 'Show' for printing)
21:33:05 <Odarevlis> Ahh. That makes sense!
21:35:14 <Odarevlis> What exactly is an underscore in Haskell? _ ? is it the lowest value in a list?
21:35:35 <monochrom> It is the wildcard pattern.
21:35:53 <monochrom> "f _ = 0" means "I don't need to know the parameter"
21:40:37 <Odarevlis> Thanks!
21:42:16 <julianleviston> If you put it on the right, you’ll get an errored program that explains what the type of the “hole” would be where the _ is standing in for.
21:42:26 <julianleviston> > f x = _
21:42:28 <lambdabot>  <hint>:1:5: error:
21:42:28 <lambdabot>      parse error on input ‘=’
21:42:28 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
21:42:39 <julianleviston> guh.
21:42:44 <Solonarv> % f x = _
21:42:45 <yahb> Solonarv: ; <interactive>:1:1: error:; GHC internal error: `Ghci2.$trModule' is not in scope during type checking, but it passed the renamer; tcl_env of environment: [aoVl :-> Identifier[foo::[a], NotLetBound], rp1j :-> Identifier[f::forall p t. p -> t, TopLevelLet]]
21:42:53 <Solonarv> uh oh!
21:43:57 <julianleviston> Odarevlis: anyway, the one monochrom explained is the most important use of it.
21:46:27 * hackage salak 0.2.1 - Configuration Loader  http://hackage.haskell.org/package/salak-0.2.1 (leptonyu)
21:50:49 <jlamothe> I'm having a brain failure, in yesod, what's the typeclass that can be either a Handler or a Widget?
22:14:27 * hackage yam 0.5.7 - Yam Web  http://hackage.haskell.org/package/yam-0.5.7 (leptonyu)
22:15:27 * hackage yam-datasource 0.5.7 - Yam DataSource Middleware  http://hackage.haskell.org/package/yam-datasource-0.5.7 (leptonyu)
22:43:14 <iqubic> I'm a little confused as to what it meanst to have a Parsec Parser with underlying an underlying stream type T.Text
22:43:49 <iqubic> So I have this: http://dpaste.com/2H5KJPW
22:44:27 * hackage pixela 0.3.0.0 - Pixela client.  http://hackage.haskell.org/package/pixela-0.3.0.0 (kakkun61)
22:44:28 <iqubic> Where lexeme strips leading whitespace, and Var is a constructor taking T.Text as an input.
22:45:37 <iqubic> I wonder why I still need to use T.pack here if the type signature I gave this function `Parsec T.Text () Expr` uses Text as the underlying stream type.
22:45:54 <iqubic> Is there a way to avoid the call to T.pack?
22:49:57 <koz_> Think about what you're doing when you call c:cs.
22:50:00 <koz_> What's the result gonna be?
22:54:39 <iqubic> String.
22:54:59 <iqubic> I have a Char that I want to prepend onto a String.
22:55:13 <iqubic> Except that I want the final result to be a T.Text.
22:55:16 <koz_> So why are you surprised at having to call T.pack.
22:55:26 <koz_> s/\./?/
22:56:30 <iqubic> koz_: Is there a better way to do this sort of thing in Parsec?
22:57:02 <koz_> iqubic: Dunno. I think Megaparsec is what you're meant to use nowadays, but I'm not very familiar with parser combinators to be honest.
22:57:52 <iqubic> why should one use Megaparsec these days?
22:59:03 <koz_> It's what I heard when I last asked about which parser combinator library to use most recently.
22:59:10 * koz_ isn't really sure to be honest.
22:59:16 <iqubic> Is T.pack slow or not?
22:59:35 <koz_> iqubic: It depends, and you might not even care.
22:59:46 <iqubic> Isn't it an O(n) computation with regards to the length of the String?
23:00:04 <koz_> So's comparing Strings for length. Doesn't mean you care.
23:00:11 <maerwald> Nexilva: comparing learning haskell with reading Kant is... interesting xD
23:00:24 <koz_> Especially consider that, given you're working on _parsing_, you're doing some kind of file or network IO.
23:00:36 <koz_> Compared to that, a few calls to T.pack probably don't matter at all.
23:00:57 <koz_> Premature optimization, root of all evil, blah blah, etc etc.
23:01:38 <Arahael> A naive benchmark on my parser, for instance, shows that <|> alone is where 30% of my CPU is spent.
23:02:12 <iqubic> I see. I'm not going to try optimizing this right now.
23:02:50 <Arahael> Smart kid.  Get it working first. :)
23:02:55 <maerwald> high-level and performance don't combine well, usually :)
23:03:04 <iqubic> Also, reservedWords is a list of keywords. If you try to parse "if" as a variable name, then it will fail.
23:03:19 <iqubic> maerwald: Should I switch to Megaparsec now?
23:03:55 <maerwald> If you care about performance, switch to a custom low-level implementation :P you will never get the same performance with parser combinators
23:04:31 <maerwald> And our parser libraries like attoparsec are already quite optimized
23:05:19 <iqubic> I do care about performance. I'm still early enough in writting my parsers that switching won't be *TOO* hard.
23:05:53 <maerwald> write the parser in C and enjoy ffi
23:06:21 <koz_> iqubic: I somehow doubt parsing will be the bottleneck for whatever you choose to do.
23:06:33 <maerwald> I also find it unlikely
23:06:55 <koz_> As an aside, is parsec maintained again?
23:07:29 <iqubic> koz_: What do you think the bottlenck will be?
23:07:43 <koz_> iqubic: Dunno, what're you trying to do?
23:07:49 <koz_> Parsing is a highly general first step.
23:10:08 <iqubic> I'm parsing a mathematical expression, and then evaluating it.
23:10:29 <maerwald> How many megabytes is the expression
23:10:39 <iqubic> I have an AST defined and I used Recursion-Schemes to write the evalutor.
23:10:44 <iqubic> maerwald: Not long at all.
23:10:49 <maerwald> Then why do you care
23:10:52 <koz_> iqubic: You shouldn't even be worried.
23:11:01 <iqubic> This just a pet project.
23:11:04 <maerwald> Even if it's 100mb you will barely notice a difference to a C implementation
23:11:06 <koz_> _Especially_ if you're using recursion schemes.
23:11:16 <iqubic> I'm just do this to prove that I can.
23:11:27 <koz_> iqubic: Then, don't worry and use whatever works.
23:11:34 <iqubic> Also this is my first parser, and also my first time using recursion schemes.
23:11:35 <koz_> Getting it _working_ is a much higher priority.
23:11:45 <koz_> Especially given what you just said.
23:13:52 <von-strauss> hi
23:14:25 <koz_> von-strauss: Guten abend.
23:14:30 <von-strauss> good evening
23:14:42 <von-strauss> just hanging out banging out crud apps for work
23:14:42 <von-strauss> lame
23:15:08 <von-strauss> i want to do something with robots
23:15:36 <maerwald> robots can be dangerous without an ethics unit
23:15:51 <von-strauss> thats easy maerwald
23:15:54 <koz_> maerwald: Needs more Asimov monad.
23:17:32 <von-strauss> id like to do something with more of a realworld impact
23:18:30 <maerwald> Then you shouldn't do programming 
23:19:03 <maerwald> Technology is just alienating people from each other, from their environment and from themselves. Get into healthcare
23:19:15 <maerwald> But then you have to give up on haskell
23:19:59 <von-strauss> i have
23:19:59 <von-strauss> heh
23:20:04 <von-strauss> ocaml is my primary hobby language
23:39:19 <Arahael> koz_: Asimov never had a monad form.
23:39:35 <Arahael> koz_: If it did, you wouldn't have a whole story arc on how the three laws aren't quite sufficient! ;)
23:42:06 <koz_> Arahael: _Several_ actually, but who's counting? :P
23:42:33 <koz_> A lot of Asimov's writings are basically about free theorems from the laws. :P
23:45:47 <Arahael> koz_: Arguably, quite a few of them seem to eventually get dismissed by not being 'advanced' enough.  But yeah, who's counting. ;)  Then again, maybe your'e right...  If they used a monad, they wouldn't /need/ to be that advanced.
23:46:47 <koz_> inb4 someone writes a robotics library in Haskell and calls it asimov.
23:48:50 <Arahael> koz_: Honestly, I think the line between Skynet and Gaia is too thin.  
