00:24:53 <royal_screwup21> anyone into game theory here? I'm trying to solve a problem and I'd love a pointer or two in the right direction :_
00:26:08 <koz_> royal_screwup21: What're you after?
00:26:24 <royal_screwup21> I have a payoff matrix https://prnt.sc/m3yvq0 I'm trying to figure out if (S01,S01) is a state of nash equilibrium
00:26:36 <royal_screwup21> I think it is, because if either the row or column player plays S01, the other player doesn't have an incentive to change
00:27:45 <koz_> royal_screwup21: You're right - that's the basic 'intuitive test'.
00:27:51 <koz_> What's the issue?
00:28:02 <xsperry> this is frustrating. there are two big floating point libraries, and neither has proper fromString function. BigDecimal has fromString, which errors when it fails to parse, and BigFloat does not have anything
00:28:03 <royal_screwup21> The solution says it's not...I'm not sure I understand why. I'd love a pointer or two in the right direction :)
00:28:17 <koz_> What does the solution say, out of interest?
00:28:19 <royal_screwup21> the solution is: . Both players play s0,1 with probability 2/3 and s1,0 with probability 1/3
00:28:34 <royal_screwup21> it's a mixed strategy basically ^
00:28:34 <koz_> Yeah, because of the key 'mixed strategies are allowed' phrase.
00:28:52 <royal_screwup21> koz_: but there was another option: both players play S01
00:28:52 <koz_> However, you may note that this is not the question you asked.
00:29:16 <koz_> Calculate the payoffs given those probabilities as weights for each player.
00:29:29 <koz_> Then compare with payoffs with s1,0 for both without weights.
00:31:12 <royal_screwup21> koz_: given the matrix, isn't this statement flat out incorrect? https://prnt.sc/m3z1gr
00:31:55 <royal_screwup21> "C[blah blah]" = 1 (not -1 as shown in the screenshot)
00:38:57 <royal_screwup21> I'm so confused :(
00:58:41 <merijn> I wonder why no one has ever suggested creating a new bytes package that is just bytestring with ByteString renamed to bytes and then making bytestring a re-export that adds a type alias "type ByteString = Bytes" as a sort of first step to ridding the ecosystem of this historical naming mistake...
00:59:58 <sm> I think some alternate prelude(s) did that
01:00:27 <sm> rio.. ? no
01:00:55 <sm> maybe I dreamed it
01:01:01 <merijn> rio has ByteString according to my quick google
01:01:19 <merijn> But then we could at least tell new users to use "bytes" and avoid some confusing about the string bit
01:01:24 <merijn> Added bonus, Bytes is shorter!
01:01:36 <xsperry> toString $ (fromString "10.....5" :: BigDecimal)  => "0.00105"
01:01:41 <sm> oh foundation, more likely
01:01:59 <merijn> Foundation is...a whole other mess
01:02:03 <julianleviston> it’d be nice if we could get rid of String, too… and call it CharList
01:02:08 <julianleviston> but … legacy
01:02:12 <julianleviston> (or Chars)
01:02:33 <julianleviston> but… yeah… mess.
01:02:35 <merijn> julianleviston: String I'm okay with, at least it's not wildly misleading
01:02:50 <julianleviston> It’s pretty disappointing, though.
01:03:11 <julianleviston> similarly disappointing to how lists of chars work in erlang
01:03:47 <julianleviston> the main reason is that it’s simple and teachable, I think, right?
01:03:56 <julianleviston> (the main reason to keep String as it is)
01:04:11 <merijn> Some operations are also mucher easier to write recursively on String
01:04:48 <sm> looks like foundation doesn't define a bytes type, it uses UArray Word8 in places
01:05:05 <tdammers> if I had never heard about Python 3, I might have suggested to get rid of all the legacy by making a breaking-release Prelude 2.0 or something like that
01:05:27 <xsperry> tdammers heh
01:05:32 <sm> foundation presentes well organised clean-looking set of batteries.. what's wrong with it ?
01:05:41 <sm> presents a
01:05:42 <tdammers> the main reason for keeping String, I think, is that there's just too much stuff out there that depends on it
01:05:44 <tdammers> way too much
01:06:17 <xsperry> I'd sooner remove partial functions like head and read than String
01:06:32 <julianleviston> Maybe Backpack will make us all happy eventually :)
01:06:38 <tdammers> there's also the theoretical concern that [Char] is trivial to implement in vanilla Haskell than an efficient packed unicode string type like Text
01:07:36 <maerwald> xsperry: what's wrong with partial functions?
01:07:40 <julianleviston> HasString CharList ? ;-)
01:07:54 <maerwald> want people to type fromJust all the time? That's nonsense :)
01:08:05 <nyc> Backpack does sound promising.
01:08:19 <merijn> sm: Foundation has way too many fucking typeclasses making things confusing
01:08:24 <tdammers> maerwald: it is, and it's not the proposed alternative
01:08:46 <sm> I see..
01:08:49 <merijn> sm: Every single time I have to interact with foundation's ByteString thingies I have to search 2 libraries to find the right magic conversion
01:09:01 <tdammers> maerwald: the idea is that making read more honest (e.g. :: Read a => a -> Either ReadError String) gives people a choice as to how to deal with failures
01:09:05 <sm> heh, sounds like normal haskell
01:09:15 <julianleviston> Need a progressively gradiated mechanism in the language. That’d be nice.
01:09:22 <maerwald> tdammers: oh well, read is just utterly wrong from every possible angle
01:09:26 <maerwald> but head is a different story
01:09:38 <tdammers> head is similarly dishonest
01:09:53 <tdammers> its type says "give me any list, and I will give you the first element, always"
01:09:57 <tdammers> but that is of course impossible
01:10:07 <merijn> tdammers: otoh, some code becomes really tedious to write without head
01:10:22 <julianleviston> maerwald: rust has a nice way to deal with it… but it really reminded me of Do Be Do Be Do ;-)
01:10:24 <maerwald> tdammers: no, that's not what the documentation says
01:10:26 <merijn> Dealing with Maybe when you know it can't occur is a mess
01:10:42 <maerwald> "Extract the first element of a list, which must be non-empty." is pretty clear
01:11:20 <maerwald> arguably it could be unsafeHead and head or something, but both should be in base
01:11:34 <xsperry> maerwald, they crash your program at unexpected places, escaping catch blocks unless you force everything
01:11:45 <maerwald> xsperry: local proofs are fine for internal API
01:11:58 <maerwald> It's nonsensical to deal with Maybe where you know it cannot happen
01:12:48 <sm> do you know it cannot happen for all time as code changes ? usually not
01:12:49 <xsperry> maerwald, that doesn't justify pervasive partial functions. at best, only fromJust is needed. and even if it wasn't provide by prelude, you could easily write one yourself
01:13:13 <tdammers> then the problem is that *you* know it cannot happen, but the *compiler* doesn't
01:13:16 <tdammers> so fix that
01:13:26 <tdammers> head :: NonEmpty a -> a -- perfect
01:13:31 <merijn> tdammers: That requires going full dependent types which is also a no go
01:13:53 <merijn> tdammers: Ok, now tell me how I retrofit groupBy to return NonEmpty without breaking the entire ecosystem
01:13:56 <maerwald> xsperry: haskell is not a total language and the solution to this problem is not "every function must be total". You only care about your program being total
01:14:09 <merijn> "map head . groupBy f" is perfectly safe
01:14:22 <tdammers> merijn: it requires full DT to get completely right, but that doesn't mean we should just give up entirely
01:14:38 <xsperry> maerwald, every function doesn't need to be total.. but read, head, etc, should have been
01:15:01 <maerwald> Then people will just write a prelude extension where everything has fromJust prepended...
01:15:09 <julianleviston> do be do be do: https://arxiv.org/pdf/1611.09259.pdf
01:15:16 <merijn> tdammers: Yes, but blindly claiming "head should be removed" ignores the fact that it's useful in a bunch of scenarios where it's not easily replaced
01:15:21 <tdammers> personally, I much prefer explicitly dealing with a few impossible Nothings over doing ad-hoc dependent typing in my head all the time (and then fucking it up, or failing to document the reasoning, or having to redo it every time I read the code)
01:15:35 <maerwald> these purist discussions are useless, you want both forms in base
01:15:39 <xsperry> merijn, it is easily replaced with fromJust $ headThatReturnsMaybe
01:15:53 <xsperry> fromJust is the only one that needed to exist
01:16:08 <maerwald> unsafeHead :: [a] -> a and head :: [a] -> Maybe a are fine, where the function name denotes the unsafety
01:16:09 <merijn> I find fromJust a lot more offensive than head, tbh
01:16:33 <maerwald> xsperry: so you want people to write fromJust everywhere for no useful reason?
01:16:34 <xsperry> that makes no sense. it does exactly what you asked. it can't catch you by surprise
01:16:50 <tdammers> oh sure, head is useful in a few cases, and under some programming styles; I'm not saying it shouldn't exist, but I do think it should be less prominent (i.e., not in Prelude, and with a name that doesn't suggest that it's a good default)
01:16:55 <xsperry> maerwald, if you have head, read all over the place, you are doing something wrong
01:17:01 <maerwald> lol
01:17:36 <maerwald> only the function name needs fixing, as described above. Don't judge other peoples code you haven't read :)
01:17:58 <tdammers> ^ I think I agree. Call it unsafeHead, and put it in Data.List so people have to import it somewhat explicitly
01:18:20 <tdammers> but, backwards compatamability, Python 3, so actually, keep it as is and live with the pain
01:20:28 <bahamas> anyone using the hsdev app? I'm getting this error, even though I have aeson installed Error: Failed to load interface for ‘Data.Aeson’
01:20:58 <xsperry> maerwald, 1) I've seen unsafe uses of head, etc far more than safe ones, where non-empty list is guaranteed 2) it encourages people to write their own, unsafe functions, without even providing safe versions (afterall, that is what Prelude did, safe versions were introduced many years later)
01:21:57 <xsperry> renaming it to unsafeHead would discourage both, so I guess it is an improvement
01:25:59 <maerwald> also, head -> unsafeHead could be easily replaced in most codebases with sed ;)
01:26:12 <maerwald> I wouldn't be too worried about backwards compat. Life has to go on
01:32:20 <xsperry> case in point: http://hackage.haskell.org/package/HasBigDecimal-0.1.1/docs/Data-BigDecimal.html
01:33:07 <xsperry> nice library, but the String to BigDecimal function library provided is fromString :: String -> BigDecimal
01:33:25 <xsperry> the only*
01:33:39 <xsperry> and why not? Prelude does, so it must be the way to do it
01:40:23 * hackage matchable-th 0.1.0.0 - Generates Matchable instances using TemplateHaskell  http://hackage.haskell.org/package/matchable-th-0.1.0.0 (viercc)
01:41:48 <maerwald> xsperry: ?
01:44:53 <xsperry> maerwald?
01:46:59 <maerwald> Prelude does what?
01:48:55 <xsperry> maerwald, it exports unsafe version of read. it is the only read function that is always available, and has the best, most concise name
01:49:18 <xsperry> that encourages other to provide similar functions
01:55:27 <maerwald> xsperry: I don't think that function is meant for user input, so it seems safe
01:55:46 <maerwald> For user input, you probably need more checks anyway
01:56:47 <xsperry> not sure how you came to that conclusion, other than the fact that it doesn't return Maybe
01:56:48 <xsperry> "read a BigDecimal from a human readable decimal notation. e.g. fromString "3.14" yields 'BigDecimal 314 2'"
01:57:04 <maerwald> Yeah, basically fixed strings.
01:57:18 <maerwald> So it is assumed the string is human readable decimal notation
01:57:20 <xsperry> nothing suggests it is only for fixed strings
01:57:37 <maerwald> If the string is not human readable decimal notation, you have to ensure it is
01:57:47 <maerwald> Pretty clear documentation
01:59:52 <xsperry> maerwald, humans write human readable numbers, too
02:00:30 <maerwald> Sure, what I meant is this function is not meant to be used with random unknown input
02:00:36 <maerwald> That's what the documentation says
02:00:43 <xsperry> documentation does not say that
02:00:43 <maerwald> If you need that, you write a wrapper around it
02:00:49 <xsperry> that is your interpretation
02:01:12 <merijn> fromString is for OverloadedStrings, unfortunately partial IsString implementations are both common and evil
02:01:33 <maerwald> merijn: this one is not about IsString
03:22:23 * hackage terminal-progress-bar 0.4.0.1 - A simple progress bar in the terminal  http://hackage.haskell.org/package/terminal-progress-bar-0.4.0.1 (RoelVanDijk)
03:30:52 * hackage haskus-utils 1.4 - Haskus utility modules  http://hackage.haskell.org/package/haskus-utils-1.4 (SylvainHenry)
03:34:52 * hackage haskus-utils-data 1.1.1, haskus-utils-types 1.3.1, haskus-utils-variant 2.5 (SylvainHenry)
04:01:52 * hackage haskus-binary 1.2 - Haskus binary format manipulation  http://hackage.haskell.org/package/haskus-binary-1.2 (SylvainHenry)
04:26:14 <sm> here's a slight puzzle: in a vty/brick app, how would you make C-z suspend the app, as it does for a long-running shell command ? Is it possible ?
04:29:08 <lavalike> sm: "Known Issues: • Signal handling for STOP, … are nonexistent."
04:29:13 <lavalike> that doesn't bode well
04:29:49 <Rembane> Is that in the RTS? 
04:30:03 <lavalike> No, here: https://github.com/jtdaugherty/vty#known-issues
04:31:04 <sm> thanks! so, needs adding to vty I guess
04:31:13 <Rembane> Ah. Sweet.
04:33:10 <sm> WIP support from the yi folks: https://github.com/yi-editor/yi/pull/1080
04:39:36 <xsperry> what package is preferred these days, mtl or transformers?
04:40:09 <merijn> xsperry: Those things do different things
04:40:23 <merijn> xsperry: It's like asking "What's preferred barbecues or showers?"
04:40:45 <dminuoso> xsperry: They are not meant to compete.
04:40:55 <xsperry> merijn huh? I am using StateT Data IO (), and my code compiles without changes with both libraries
04:41:23 <merijn> xsperry: transformers is the library that provides transformers. mtl provides a set of typeclass instances for working with stacks of transformers from transformers
04:41:48 <merijn> xsperry: StateT from mtl is just StateT from transformers, but re-exported...
04:42:18 <dminuoso> xsperry: In a way transformers is a smaller subset of mtl.
04:42:33 <dminuoso> xsperry: but both are considered standard libraries.
04:44:37 <xsperry> ok, I'm more confused now than before I asked the question. since my code compiles with both packages, it appears that I am just using transformers
04:45:04 <xsperry> would mtl offer me anything with what I am doing?
04:53:01 <merijn> xsperry: Do you want to write code that works across multiple transformer stacks?
04:53:17 <merijn> Rather than just "StateT Data IO ()"?
04:54:37 <dminuoso> xsperry: mtl also offers lifting through multiple layers.
04:55:06 <dminuoso> Without explicitly doing so I mean.
04:55:44 <xsperry> my code is project specific, so StateT Data IO () is fine. but if I can avoid lifting every time I'm doing IO, that would be nice
04:56:18 <merijn> liftIO is in base (as of recently) and was in transformers before then. So you don't need mtl
04:57:11 <infinisil> xsperry: You could use classy-prelude, which uses MonadIO instead of IO everywhere, so no need to liftIO
05:00:17 <xsperry> I tried classy prelude once, and it was too big of a chance from standard prelude
05:00:43 <xsperry> so can mtl help me avoid having liftIO all over the place? or not
05:01:13 <merijn> no
05:01:18 <merijn> You have to lift or liftIO
05:05:17 <mouse07410> maerwald: I have working saltine v0.1.1.0 (local source that's been modified) that builds and passes tests under cabal (with saltine.cabal), using both v1 and v2 commands. I have a local project/package that uses/depends on saltine >= 0.1.1.0, which also has its <project>.cabal file (that file specifies dependency on saltine). When v1 commands are used on both, it all works as expected, aka fine.
05:05:23 <dminuoso> xsperry: Though at its core, mtl is not about transformers. mtl is just about using typeclasses to talk about effects.
05:06:45 <dminuoso> xsperry: For example `class Monad m => MonadError e m | m -> e where ...` is just an *interface*. Since this a typeclass, you can also use it to write polymorphic code that lets the user pick "whatever MonadError instance he wants"
05:10:40 <mouse07410> maerwald: when v2 commands are used on both, cabal still claims it succeeds on saltine ("v2-build" and "v2-install --lib"), but on my project it fails "v2-configure", complaining it cannot find saltine that's >= 0.1.1.0. Somehow either v2-build does not cache the result where other cabal invocations can find it, or my project didn't know where to look. And again, it only fails with v2. With v1 everything is located and
05:10:40 <mouse07410> resolved correctly.
05:11:02 <dminuoso> transformers just happen to provide some natural instances for mtl, so it's just a bonus. 
05:11:15 <mouse07410> Needless to say, same cabal files used for v1 and v2
05:11:22 <dminuoso> Or no. mtl provides these instances for you, but that's just a bonus.
05:11:50 <hpc> there are lots of instances of mtl classes that don't come from transformers either
05:11:57 <merijn> mouse07410: Build-plans with v2 are completely independent
05:11:58 <hpc> for instance, acid-state has a couple
05:12:28 <merijn> mouse07410: So if you installed a library for project 1, project 2 will only see that version IFF cabal computes the exact same version in it's build plan for project 2
05:14:20 <xsperry> dminuoso, that looks to be similar to MonadCatch/MonadThrow
05:16:06 <dminuoso> xsperry: Ignoring the details of what they are for exactly, exceptions too is not about transformers. Do you see this? :)
05:16:45 <xsperry> yes
05:17:00 <Lears> mouse07410: Sounds like correct behaviour if you forgot to specify your local saltine source in cabal.package.
05:20:27 <dminuoso> xsperry: To quote jle`: "rough analogy, MonadError generalizes Either, MonadThrow generalizes IO"
05:20:46 <dminuoso> (IO in the sense of exceptions)
05:22:29 <xsperry> dminuoso, what did you mean by this: xsperry: mtl also offers lifting through multiple layers.  Without explicitly doing so I mean.
05:23:59 <dminuoso> xsperry: Well let's say you have some `ReaderT Env (StateT Int (WriterT Log IO ()))` stack. You'll have to do some `lift . lift . lift` shenanigans to lift actions into the stack.
05:25:13 <julianleviston> We haven’t really arrived at any paritcularly great answer to effects yet, have we?
05:25:37 <julianleviston> I mean that gives us the benefits of Freer, but also the speed of stacks?
05:25:43 <julianleviston> speed/efficiency*
05:25:56 <xsperry> dminuoso, so it helps when having multiple transformer layer stacks? not just StateT IO
05:27:21 <julianleviston> xsperry: coz you can not lift your functions when using them, they’re on the monad itself as a typeclass constraint, therefore the instance gets the methods. That’s roughly right, I think....
05:27:41 <dminuoso> xsperry: Depending on how you define "help" really.
05:28:36 <julianleviston> Have you all read this? https://ocharles.org.uk/posts/2016-01-26-transformers-free-monads-mtl-laws.html
05:28:46 <julianleviston> has there been much work after that in this space?
05:30:41 <mouse07410> merijn: but doesn't "only if computes exactly the same version" apply to both v1 and v2? So why when I install with v1 and use V1 for both projects, it's fine - but when I build/install the first one with v2, and try to use it with v2  in the second project - it can't find it?
05:32:31 <mouse07410> Lears: I hear you, and no I didn't point my project at the saltine source. But I wanted my project to use the cached build... Are you saying that in V2 there's no more per-user DB of locally installed packages?
05:32:33 <dminuoso> xsperry: Say you wanted to `tell` to the log. With transformers you'd take your `tell someErr :: WriterT Log IO ()` action, and lift it twice into the whole stack.
05:34:08 <dminuoso> xsperry: With mtl you do not talk about monad stacks anymore, since you'd use the mtl interface. Because it uses typeclass tricks, it will happen to have an instance MonadWriter for `ReaderT Env (StateT Int (WriterT Log IO ()))`
05:34:29 <xsperry> I see
05:34:48 <dminuoso> So you can just use `tell someErr` - but do note that it's a *different* tell
05:35:35 <dminuoso> The instances (which are recursed by the typechecker) then happen to be implemented to use `lift` internally, so it still happens.
05:36:09 <dminuoso> But that's only if you use the transformer instances of mtl.
05:36:12 <merijn> mouse07410: v1- will try to actively reuse existing installs. v2 computes a build-plan in a vacuum (i.e. ignores whatever might exist, only looks at constraint and known packages) THEN if the computed build plan happens to match an existing version, that one will be used
05:37:17 <merijn> mouse07410: v2 has a per-user DB of installed packages, it just doesn't care what's in there when computing a build plan
05:37:35 <merijn> mouse07410: IOW your buildplan computed a version of saltine other than the one you previously installed
05:41:28 <merijn> mouse07410: Why do you want it to reuse the version you just installed?
05:43:58 <ClaudiusMaximus> fwiw, i have the same issue as mouse07410 with a different package set: can't figure out how to get v2-install to see my modified version of a dependency.  i gave up and used v1-install
05:44:22 <merijn> ClaudiusMaximus: You use cabal.project file to point it to the source of the modified version
05:45:33 <merijn> ClaudiusMaximus: If you have package A that depends on package B and you want to use a locally modified/unreleased version of B to build against, you point you cabal.project at the modified version of B
05:46:18 <merijn> By adding the path to the cabal file of modified B to packages: or optional-packages:
05:46:23 <merijn> https://cabal.readthedocs.io/en/latest/nix-local-build.html#specifying-the-local-packages
05:54:49 <ClaudiusMaximus> merijn: can't get it to work, added it to packages: but cabal doesn't seem to find it
05:55:14 <merijn> ClaudiusMaximus: What did you add? Just the path?
05:55:30 <merijn> It expects the path (or a glob of the path) to the actual cabal file
05:55:33 <ClaudiusMaximus> $ cat cabal.project 
05:55:33 <ClaudiusMaximus> packages: *.cabal ../../github.com/claudeha/grenade/grenade.cabal
05:55:47 <merijn> That should work
05:56:39 <ClaudiusMaximus> that grenade.cabal has version 0.1.1
05:56:40 <ClaudiusMaximus> [__0] rejecting: grenade-0.1.0 (constraint from user target requires ==0.1.1)
05:56:55 <ClaudiusMaximus> don't even know if cabal is reading cabal.project
05:57:41 <merijn> Gotta run, meeting
06:05:51 <ClaudiusMaximus> cabal stats cabal.project with result 0, but doesn't actually open it or read it, it seems
06:06:13 <ClaudiusMaximus> (n00b at strace)
06:41:26 <mouse07410> merijn: ClaudiusMaximus it may be that cabal v2 simply hasn't implemented yet support that we expect for libraries - it may do it now only for built executables. That's the impression I got from "cabal v2-install --help"
06:43:22 <ClaudiusMaximus> i'm building an executable (that depends on a modified library)
06:48:27 <Boarders> does anyone have an example of using AutoBench in a project that I could have a look at?
06:49:04 <mouse07410> ClaudiusMaximus: Exactly! Your executable depends on a *library* which successfully builds and, presumably, installs - but cannot be found as a built dependency. Just like in my case.
06:49:43 <merijn> ClaudiusMaximus: Which version of cabal-install do you have?
06:53:04 <ClaudiusMaximus>  cabal --version
06:53:04 <ClaudiusMaximus> cabal-install version 2.4.1.0
06:53:05 <ClaudiusMaximus> compiled using version 2.4.1.0 of the Cabal library 
06:53:53 <merijn> And it's not reading cabal.project when running with v2-build? That's weird...
06:54:35 <ClaudiusMaximus> merijn: i'm using v2-install, will try v2-build
06:54:58 <merijn> ClaudiusMaximus: You should basically never be using v2-install, imo
06:55:00 <ClaudiusMaximus> v2-build seems to work
06:55:06 <ClaudiusMaximus> thanks
06:55:40 <mouse07410> She version in my case. Except that I don't use cabal.project.
06:55:43 <merijn> ClaudiusMaximus: install is probably the least polished/tested command there is and it's functionally is...pretty useless, except for executables
06:56:11 <ClaudiusMaximus> i have an executable i want to install on my user's path, instead of in /home/claude/code/code.mathr.co.uk/nnirror/dist-newstyle/build/x86_64-linux/ghc-8.6.3/nnirror-0/x/nnirror/build/nnirror/nnirror
06:56:18 <c_wraith> v2-install should exist to support project less use.
06:56:35 <mouse07410> merijn: that functionality is supposed to work for executables *and* libraries - but currently it only works for executables
06:56:48 <merijn> c_wraith: I'm not saying v2-install is conceptually useless. Just pragmatically atm
06:56:54 <c_wraith> but lots of other commanda don't respect that projectless is a valid use case.
06:57:10 <merijn> mouse07410: installing libraries makes no sense in the v2 paradigm
06:57:13 <ClaudiusMaximus> i guess i can copy it manually, luckily it needs no Paths_* modules
06:57:17 <merijn> c_wraith: Which ones?
06:57:18 <c_wraith> like v2-repl doesn't really work right without a project.
06:57:25 <merijn> ClaudiusMaximus: Is this just for personal use?
06:57:33 <ClaudiusMaximus> merijn: yeah
06:57:39 <merijn> ClaudiusMaximus: Because there's a much nicer/simpler trick for using projects in development
06:58:42 <mouse07410> So, with v1 when I build *and* install, the package gets into the global (or per-user global on this machine) DB, and can be located there as as dependency by any other project that wants the same version.
06:59:19 <merijn> mouse07410: What do you expect v2-install to do for a library?
06:59:50 <merijn> ClaudiusMaximus: You can make a shell script like this: http://dpaste.com/2KTBR71
06:59:54 <ClaudiusMaximus> Boarders: what is AutoBench? don't see it on hackage, so the revdeps tool is useless
07:00:08 <merijn> ClaudiusMaximus: That properly supports Paths_modules, datafiles, everything
07:00:21 <merijn> ClaudiusMaximus: It's what I use to easily test executables while developing
07:00:28 <mouse07410> But with v2, "install" dues nothing, and any project that wants this one as a dependency must be pointed to it's source directory where the build ran. Didn't make sense to me.
07:00:45 <ClaudiusMaximus> merijn: cool
07:01:36 <merijn> ClaudiusMaximus: Because my projects are all use datafiles and Paths_x and zero issues so far. It's super nice, actually :)
07:01:44 <merijn> s/are all/all
07:02:19 <mouse07410> merijn: I expect v2-install to at least record that a library of a given version exists and is located in XXX, so any other project on this machine can find it just by listing it as a dependency.
07:02:29 <merijn> mouse07410: The entire point of v2's Nix style approach was to make separate projects completely independent to avoid the common breakage encountered between installations from separate projects
07:02:55 <merijn> mouse07410: This means that v2 allows MANY different installs of the same library (and even many different installs of the same version of a library)
07:03:19 <merijn> mouse07410: There is no sensible way to describe "the one in the global DB", because the global DB can have many versions
07:04:24 <merijn> mouse07410: And the build plan can only include unreleased libraries if you tell cabal about said unreleased version. Which means pointing at a specific directory, repo, or tarball containing said unreleased version
07:04:36 <ClaudiusMaximus> merijn: well, v2-build works, but v2-install (which i would imagine conceptually is build then install the resulting artifacts) fails obscurely (at dependencyresolution without even reading cabal.project)
07:05:01 <merijn> ClaudiusMaximus: hmm, ask in #hackage, I don't know the internals of v2-install
07:05:32 <mouse07410> In other words, v2 and nix move away from the re-use approach and to stack-like snapshot approach. Your want it - you build your own copy of it.
07:05:48 <merijn> mouse07410: That's only true for unreleased libraries
07:05:53 <c_wraith> unlike stack, it does reuse
07:06:08 <c_wraith> as long as it's 100% sure it's the same thing.
07:07:37 <mouse07410> But my whole problem is with "unreleased" libraries - aka those that can't be found on Hackage (at least of the requested version)
07:08:04 <merijn> mouse07410: Why is it problematic to tell it where to find an unreleased version? How else would it work?
07:08:15 <mouse07410> c_wraith: so far I've been unable to make it re-use.
07:08:35 <c_wraith> have you tried telling it where the package is from?
07:10:00 <c_wraith> if it's an unreleased package, it's not enough to say "it's installed, really". unreleased stuff might silently change at any time.
07:10:51 <mouse07410> merijn: it's "unreleased" from Hackage point of view. From my local machine point of view, it should be shared as-is by other projects that want it. Without rebuilding it for every project
07:11:05 <merijn> c_wraith: Also "it's installed, really" is insufficient *anyway* as there may be multiple installed unreleased versions
07:11:50 <adamCS> Anyone with some experience with Vinyl/Frames compile-time (and compile memory usage) have some pointers?  I can see that the issues are proportional to the number of columns, so casting rows records to smaller records helps.  But it's not always obvious exactly where and any general rules, or compile time flags, would be helpful. I can develop with -O0 and that helps but for exploring data, I'd like to be able to recompile
07:11:50 <adamCS>  optimized code more easily.  
07:12:13 <mouse07410> c_wraith: no I didn't tell where it is. But somehow it works as I want, with v1. There's no way to get v1 behavior with v2?
07:12:42 <c_wraith> mouse07410, nope. that behavior leads to lots of bugs. so it was replaced with something that doesn't.
07:12:43 <merijn> mouse07410: No, v2 is fundamentally different from v1 by design
07:17:32 <elmcrest> hey everybody. I'm playing with haskell and noticed some kind of bug ... or not sure if it's a bug or not. but if I insert emojis (emoticons) in the GHCI on mac (within the os terminal) I can't edit text anymore before submitting with enter.
07:18:00 <elmcrest> so I'm curious about this since I've read something like "ah unicode, we got that since 80s" or so :P 
07:18:02 <mouse07410> c_wraith: respectfully disagree, and my experience with other ecosystems, including OS, suggests that it doesn't introduce more bugs. But I think I get your point.
07:18:37 <c_wraith> I mean.. I've certainly run into them.
07:18:48 <merijn> mouse07410: The v1 approach objectively introduces lots of problems that are impossible with v2. I empathise that it's annoying your current workflow, but v2 *is* better and more robust
07:19:10 <c_wraith> "oops, I didn't reinstall that package" "oops, rebuild didn't notice the updated package"
07:19:33 <c_wraith> those are things I ran into consistently when using that pattern.
07:20:07 <c_wraith> the latter was less common, but especially annoying to deal with.
07:21:12 <merijn> c_wraith: Or the "whoops, you're completely stuck and need to nuke your entire database because of conflicting dependency constraints across projects!"
07:26:11 <__monty__> elmcrest: From some testing it seems like it's handled fine except for the rendering.
07:26:35 <elmcrest> __monty__ try to use your left arrow key to edit things once a icon is inserted
07:27:09 <elmcrest> ah you've said except for the rendering ... ok let me try to get that
07:27:17 <__monty__> elmcrest: Deleting a double width icon, takes a single backspace, the rendering is messed up and doesn't remove the character though.
07:28:15 <elmcrest> __monty__  ok so a "rendering bug"?
07:29:14 <geekosaur> that will be a terminal issue
07:29:38 <geekosaur> unicode doesn't include how wide a "character" is *in terminal character cells*
07:29:45 <__monty__> elmcrest: Yeah, I'd say so. It's pretty confusing. Was gonna say that too, I'm not sure it's not just terminals shitting their pants with double width unicode.
07:29:55 <c_wraith> yeah, some terminals do unicode correctly.
07:30:06 <__monty__> Which ones?
07:30:15 <elmcrest> I can try that I guess
07:30:47 <elmcrest> so in the regular prompt, bash I guess, it works just fine
07:30:48 <c_wraith> I managed to get Terminal.app on os x to work correctly, after a bunch of tweaking. I don't recall the details.
07:31:38 <elmcrest> ok I was wrong, now got it into a similar buggy behaviour
07:31:57 <elmcrest> ok anyways, nothing important I guess ... just curiousity
07:32:15 <mouse07410> I'm creating and/or modifying a package. Whole it's being i developed/debugged, I don't want it "found" by other projects. Once I consider it stable, I do want to place it to where other projects can re-use the current build (er, snapshot), while I keep modifying the source (and keep those new changes away from other projects)
07:32:40 <geekosaur> best you can do there is (a) switch font (b) hope something isn't substituting characters from a different font, which is practically guaranteed to break terminals (c) pray to whatever if anything you hold dear
07:32:44 <mouse07410> Whole -> While
07:32:55 <merijn> You can point v2 builds at specific git repo commits...
07:33:30 <merijn> Also at tarballs, iirc
07:33:51 <_deepfire> Is there a particular reason why IntMap introduces the Key type alias to paper over Int keys?
07:34:24 <__monty__> Clearer intent?
07:34:52 <merijn> _deepfire: Not that I've been able to discern
07:35:23 <mouse07410> merijn: I see. This workflow is not acceptable to me. I'm going to stay with v1, which does exactly what I need.
07:36:06 <geekosaur> unclear but it's one of severl, the rest of which are internal
07:36:23 <geekosaur> (Prefix, Mask, BitMap)
07:38:52 * hackage githash 0.1.3.1 - Compile git revision info into Haskell projects  http://hackage.haskell.org/package/githash-0.1.3.1 (MichaelSnoyman)
07:49:48 <elmcrest> haha factorial of 250 is a huge number indeed :D
07:49:59 <elmcrest> s/250/2500
07:50:04 <elmcrest> anyways, true for both
07:52:25 <elmcrest> and for 250.000 it took some time :D ... fun :P 
07:53:46 <Ariakenom> % length $ show $ foldl (*) 1 [1..2500]
07:53:46 <yahb> Ariakenom: 7412
07:55:29 <elmcrest> that's way smaller ;)
07:56:09 <elmcrest> *Main> length $ show $ factorial 25000
07:56:09 <elmcrest> 99094
07:56:20 <Taneb> > sum (map log [1..2500])/log 10
07:56:23 <lambdabot>  7411.211891336963
07:56:23 <elmcrest> now I wonder why I have *Main> as the prompt :P 
07:56:25 <mouse07410> Are the logs of this channel (and other channels) kept somewhere that I can retrieve later?
07:56:28 <Taneb> > sum (map log [1..25000])/log 10
07:56:31 <lambdabot>  99093.73623060582
07:56:46 <geekosaur> because at some point you loaded a Main.hs
07:56:51 <elmcrest> nice
07:56:56 <elmcrest> > 1+1
07:56:58 <lambdabot>  2
07:56:58 <elmcrest> pff
07:56:59 <geekosaur> the focused module would be Prelude otherwise
07:57:00 <elmcrest> ah now
07:57:01 <elmcrest> nice
07:57:17 <elmcrest> geekosaur thx
07:57:26 <elmcrest> no Idea how I did so though
07:57:46 <elmcrest> ah ok, when I load a file with `:l`
07:58:16 <elmcrest> REPL is such a cool thing to get in touch with any programming language
07:58:43 <elmcrest> was what sucked me into Python... so we'll see how functional programming will blow my mind or frustration
07:59:07 <dminuoso> elmcrest: Be prepared for much frustration as you realize how much unlearning you have to do.
07:59:33 <elmcrest> motivating though are the list comprehensions ... way more powerful than the already loved one from python
07:59:46 <merijn> elmcrest: You can override the prompt if you want, btw
07:59:52 <elmcrest> dminuoso yeah I've "heard" about that
08:00:06 <elmcrest> merijn yeah thx, learn you a python covered that
08:00:10 <elmcrest> ups
08:00:17 <elmcrest> learn you a haskell ofc
08:00:34 <merijn> elmcrest: Setting it also stops it from adding modules to the name (which I find annoying as it takes up a lot of space)
08:00:41 <dminuoso> elmcrest: The first 3 months it was realizing how much different Haskell was in every sense. Then it was 6 months getting a grasp, and then I've realized how similar Haskell is to say.. Python. But you have to understand Haskell first to see *how* they are similar.
08:00:42 <aldum> I thought for a moment there existed a Learn you a Python
08:00:52 <elmcrest> merijn how can I have it persistent?
08:01:11 <merijn> elmcrest: On *nix you can make ~/.ghci and store commands there
08:01:15 <merijn> Not sure about windows
08:01:18 <dminuoso> merijn: By the way, I still love your comment "Haskell is the best imperative programming language" you make from time to time. :)
08:01:22 <elmcrest> dminuoso and now you#re happy that you've learned it?
08:01:25 <dminuoso> Should printit on a shirt.
08:01:34 <elmcrest> merijn cool thx
08:01:36 <merijn> elmcrest: Also lets you "pre" import modules and enable extensions: https://github.com/merijn/dotfiles/blob/master/dotfiles/ghci
08:01:53 <merijn> dminuoso: I didn't come up with that, someone else did I just stole it :p
08:01:59 <dminuoso> Heh.
08:02:13 <elmcrest> "λ " is nice :)
08:02:27 <merijn> dminuoso: At some point I spent a lot of time designing a statically typed, but I stopped when I realised I was basically reinvening Haskell
08:02:44 <codedmart> With s3-signer 0.3 I could get the ByteString of the url from S3URL. Now with 0.5 I don't see how I can just get the ByteString of the S3SignedRequest.
08:04:55 <Ariakenom> dminuoso, merijn: maybe from "In short, Haskell is the world’s fine
08:04:55 <Ariakenom> st imperative programming language." https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/mark.pdf?from=https%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fum%2Fpeople%2Fsimonpj%2Fpapers%2Fmarktoberdorf%2Fmark.pdf
08:06:53 <elmcrest> so, isn't it clearly better to do "functional"?
08:06:56 * elmcrest cries
08:07:21 <elmcrest> I'd expect at least in this channel a clear "hell, yeah, it is!" :D 
08:08:31 <geekosaur> there are very, very few 100% perfect/applicab;e approaches
08:08:39 <dminuoso> elmcrest: What is "better" depends on what you consider to be good really.
08:09:08 <geekosaur> reality is dirty, messy, and doesn't particularly care about humans or their weird aesthetics
08:09:13 <merijn> elmcrest: Contrary to popular opinion Haskell isn't about "no mutation ever!". The benefit of purity is "be in control of when and where mutation can happen"
08:09:31 <elmcrest> well ... I guess better software is the goal ... not necessarily speed but reliability, maintainability etc.
08:09:43 <dminuoso> Not just "be in control" but provably constrain it with the type system.
08:10:01 <geekosaur> that's where you win from being able to decide *where* to use mutability. and reliably limit it to those places and nowhere else.
08:10:06 <elmcrest> I like the Idea of immutability since I've seen a video about "event sourcing" it was called I think
08:10:23 <merijn> elmcrest: I mean, in IO you can do literally anything you can do in traditional imperative languages. Mutable data structures, eventful loops, etc.
08:10:24 <dminuoso> elmcrest: immutability is a hipster thing in the JS world that seems to be very poorly understood.
08:10:56 <merijn> elmcrest: The separation between "pure" and "IO" is less about "banning IO and mutability" and more about "giving you the tools to be sure about when you are NOT using those things"
08:11:27 <Solonarv> And Haskell also lets you build abstractions and control flow structures using plain old functions
08:11:48 <Solonarv> for example: we don't need async/await as a language feature, it can just be a library
08:11:57 <elmcrest> ah another thing what is really important to me is of course speed of my development ... like how fast could I get stuff done ... in my case all "usual" business stuff for our own family business :P
08:12:03 <merijn> elmcrest: The problem with reasoning about mutation is not really about mutation, but how it makes you care about "what unrelated part could this be potentially mutated". While inside pure parts you can completely forget all that mental overhead
08:12:25 <dminuoso> elmcrest: My Haskell development speed has by far exceeded my 5 years of Ruby programming experience in under 12 months.
08:12:31 <dminuoso> That's my personal experience.
08:12:42 <Solonarv> even inside imperative-mutable Haskell you can often forget about this - you can't mutate an IORef that isn't in scope!
08:12:43 <elmcrest> that sounds promising
08:12:49 <elmcrest> dminuoso  ^
08:13:34 <elmcrest> yeah I guess the least I should do is get used to the syntax a couple weeks and play with it
08:14:19 <merijn> elmcrest: I think (like dminuoso) that my overall development speed has improved dramatically. But, there's a caveat/warning for beginners. A lot of the ecosystem and the language is *not* optimised for "being immediately productive as you learn", there is definitely and initial productivity hit when you're still figuring out the language and ecosystem.
08:15:07 <elmcrest> yeah ok sure
08:15:14 <elmcrest> probably the one excludes the other
08:15:15 <Solonarv> merijn++
08:15:41 <merijn> elmcrest: Additionally a lot of the libraries value correctness over "ease of quick and dirty prototypes" so sometimes getting an initial version done can be harder/take more time than in, say, Python and Ruby. The trade-off is that when you have an initial version I find it dramatically easier to do sweeping rewrites, getting that final polish done, or adding complex features
08:16:10 <Solonarv> elmcrest: not inherently, Haskell's ecosystem does have some holes. Those don't go away just because you're an expert, though they might become less problematic as you learn to work around them
08:16:29 <merijn> elmcrest: So, getting a 80-90% done version takes me considerably more effort than getting an 80-90% version in python (this also depends on the kinda problem, some issues are always easier in Haskell)
08:16:33 <elmcrest> yeah, I'll continue :D 
08:16:54 <merijn> elmcrest: But I find Haskell makes the final 10-20% to robust and complete MUCH easier
08:17:26 <elmcrest> actually, what convinced me the most, from the one video on youtube (from the or one of the haskell "founders"??) where he says that haskell was so little known over decades that they could evolve it without any time constraints or something ... that's a really appealing argument to me somehow
08:18:12 <dminuoso> Haskell also has a tendency to have you spend much more time in the editor before you get a final working program, but the quality is usually so high that there's much less refactoring or "bug discovery" or "test writing" going on that you overall saved a lot of time.
08:18:26 <dminuoso> That's what I still discover regularly.
08:18:39 <elmcrest> ah, is TDD a thing for "haskellers"?
08:18:48 <dminuoso> elmcrest: It is sort-of actually.
08:18:53 <elmcrest> yeah ok
08:18:58 <c_wraith> if T = type, sure. :)
08:19:01 <dminuoso> elmcrest: You could consider types as tests.
08:19:06 <dminuoso> Provable tests.
08:19:11 <Solonarv> c_wraith: hah, I was about to say something to that effect
08:19:47 <ClaudiusMaximus> @check \xs -> length (nub xs) == Data.Set.size (Data.Set.fromList (xs :: [Int]))
08:19:50 <lambdabot>  +++ OK, passed 100 tests.
08:20:16 <dminuoso> elmcrest: And in Haskell you very frequently start with just types, designing program parts with just type signatures.
08:20:25 <elmcrest> ok thx to all so far ... gotta go (family) but I'm probably back later, so my journey continues :P 
08:20:28 <dminuoso> And then you start filling in code matching the types. "Let the types guide you"
08:20:32 <merijn> elmcrest: I would say that TDD as in many dynamic languages isn't very popular, no. On the other hand there's other cool stuff
08:20:44 <merijn> elmcrest: QuickCheck beats the shit outta TDD, tbh :p
08:20:48 <dminuoso> merijn: I very much consider the "let the types guide you" to be the better version of TDD.
08:20:57 <dminuoso> Since types really are just tests.
08:21:08 <elmcrest> QuickCheck sounded really cool, yeah
08:21:33 <elmcrest> so, I imagine the Types like Models ... right? ... somehow
08:21:47 <elmcrest> you need to get to something and first you design the system with appropriate Types?`
08:21:53 <Boarders> ClaudiusMaximus: it is this: https://github.com/mathandley/AutoBench
08:21:59 <Boarders> I do not know why it isn't on hackage
08:22:10 <elmcrest> anyways, my wife beats me ... ttyl
08:30:33 <fr33domlover> Is it a good idea to use functions from Control.Arrow if I don't otherwise use arrows? For example (&&&) is useful and seems to have no equivalent in base
08:30:46 <merijn> :t (&&&)
08:30:48 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
08:30:58 <fr33domlover> (I've used stuff like (***) in the past too but now using bimap instead)
08:31:07 <merijn> fr33domlover: Most (but not quite all) has been replaced with Bifunctor
08:31:40 <merijn> fr33domlover: Depends how much nicer it becomes with &&& vs just writing it by hand :p
08:32:27 <fr33domlover> merijn, writing it by hand is trivial, just wondering about writing it VS using the one from Control.Arrow, btw does anyone even use arrows? I never see them in people's code
08:33:19 <fr33domlover> (tbh I'm not even sure what they are exactly, just read intro but it wasn't enough)
08:33:28 <dminuoso> fr33domlover: I've seen (&&&) being used every once in a while.
08:33:57 <dminuoso> fr33domlover: I find that the value of writing it by hand exceeds the many people who will be confused by (&&&) down the road.
08:34:14 <dminuoso> Consider not the prettyness of you looking at it now, but of you looking at it 2 years from now - or someone else.
08:34:23 <merijn> fr33domlover: Arrow is mostly dead as abstraction
08:34:23 <dminuoso> Suddenly Control.Arrow gets very odd.
08:34:51 <merijn> fr33domlover: The interface isn't quite what you'd like and most of it's functionality is captured by other more general and useful typeclasses
08:34:56 <fr33domlover> dminuoso, personally I use &&& only with (,) tuples but I guess it could confuse other people idk
08:35:16 <merijn> I think someone mentioned that Arrow is equivalent to Applicative, Category, and Profunctor. Each of which are more useful
08:35:45 * fr33domlover never used categories or profunctors :P
08:36:23 <fr33domlover> dminuoso, merijn, thanks for explaining :) I guess I'll write by hand
08:37:14 <dminuoso> fr33domlover: Ive started browsing around GHC and hacking a bit on it. I've *greatly* appreciated that none of the type-theory heavy academic freaks used any complicated code.
08:37:47 <dminuoso> Simple code seems much more maintainable than cool code-golfed category theory.
08:38:39 <dminuoso> I still dont understand what Lan/Ran is exactly.
08:39:07 <merijn> I don't understand Kan extension, adjunctions, or really any of that shit :p
08:39:32 <Solonarv> same tbh
08:39:58 <fr33domlover> lol
08:40:00 <dminuoso> Even Co/Yoneda is just "free fusion for fmap" to me
08:40:07 <fr33domlover> At least we know what we don't know ^_^
08:40:19 <dminuoso> Superficially I can work through the yoneda lemma though, but I dont have a good understanding of what it means.
08:40:56 <jhrcek> Anyone experienced with optparse-applicative? I have a parser with multiple subcommands and I'd like to print list of all available commands as help message every time when user call the command just "executable" from cli.
08:40:57 <nshepperd1> I sometimes use (&&&) in cases like "sortOn (f &&& g) list"
08:41:05 <jhrcek> So far I've got this https://gist.github.com/jhrcek/b73c5ef79f7cc0a474ead1df7f7eebbb
08:41:31 <jhrcek> But no matter what I try it only prints the list of commands on "myexecutable --help", but not on "myexecutable"
08:41:39 <dminuoso> :t \f g -> sortOn (f &&& g)
08:41:40 <lambdabot> (Ord c', Ord c) => (a -> c) -> (a -> c') -> [a] -> [a]
08:42:29 <dminuoso> merijn: I've finally accepted that it's more valuable to understand type theory than category theory.
08:42:52 <nshepperd1> That's just 'sort by f, then g lexicographically'
08:43:24 <merijn> Which in turn is just "sortBy (comparing f <> comparing g)"
08:43:45 <fr33domlover> I wonder sometimes if I'm somewhat behind due to having no math/CS background (well, except for undergraduate stuff, but that just gave me basic knowledge about what functional programming is)
08:43:56 <dminuoso> fr33domlover: You do not need a math/cs background at all.
08:44:06 <dminuoso> fr33domlover: high school math is enough to be very competent.
08:44:22 <merijn> fr33domlover: https://patrickmn.com/software/the-haskell-pyramid/
08:44:31 <fr33domlover> dminuoso, yeah clearly I'm Haskelling just fine, but I'd love to know more, just never found the time
08:45:02 <fr33domlover> I've learned a lot about all those GHC type related extensions just from being here in this channel
08:45:17 <fr33domlover> Sometimes I read here just to learn ^_^
08:46:16 <Solonarv> That's a pretty big part of why I originally started hanging around here, too
08:47:34 <dminuoso> fr33domlover: Maybe consider some basic category theory then. It doesn't take much to get some pretty cool insights.
08:48:17 <fr33domlover> merijn, that's an awesome insight! I don't read about Haskell on social networks though, I hope people there don't get a bad impression
08:48:45 <dminuoso> Isn't IRC a social network?
08:48:51 <fr33domlover> dminuoso, I'm very very curious about all of that, I wish I had more time to learn it all lol
08:49:36 <fr33domlover> dminuoso, yeah it is but idk maybe it's different, idk what that person was referring to in their writing "social networks"
08:49:37 <__monty__> dminuoso: No, the information isn't in the hands of a single greedy entity. So clearly it's not.
08:50:04 <fr33domlover> __monty__, there are other networks! Like Mastodon and the fediverse ^_^
08:50:06 <Solonarv> dminuoso: not in the modern sense (I think), but there's enough overlap for the term to not be entirely wrong.
08:51:15 <fr33domlover> I also like browsing to random interesting Hackage packages, especially ones using type system concepts
08:51:25 <fr33domlover> And just reading their docs etc.
08:53:41 <dminuoso> sophisticated type trick packages on hackage? with documentation?
08:53:43 <dminuoso> what package is that?
08:54:03 <Solonarv> well... lens?
08:54:07 <Solonarv> Servant?
08:54:52 <dminuoso> Solonarv: does lens use much type trickery though?
08:54:52 <michaelsdunn1> Is there much of a difference between using newTVar vs. newTVarIO? newTVarIO allows me to make a new TVar without having to call atomically. Are there any consequences?
08:55:10 <merijn> michaelsdunn1: Nope, that's all
08:55:20 <merijn> michaelsdunn1: newTVarIO is just a convenience function
08:55:31 <dminuoso> merijn: Is it just convenience?
08:55:33 <Solonarv> dminuoso: it's not all that "tricky", but the subtyping stuff counts IMO
08:55:51 <dminuoso> merijn: If I consider the documentation of newTVarIO it seems to be a *necessicity* because apparently you cant use `atomically` with `unsafePerformIO`
08:56:03 <Solonarv> Ah, I was about to say that
08:56:12 <michaelsdunn1> Yeah, I'm not using `unsafePerformIO`
08:56:16 <merijn> dminuoso: It's still just for convenience :p
08:56:18 <asheshambasta> Is a use of type families in this manner considered ok? https://gist.github.com/asheshambasta/f72614f924d4b7c7bda1e98e54b1b61f Or am I severely mistaken here?
08:56:46 <Solonarv> merijn: you can't safely have a top-level TVar with newTVar, you can with newTVarIO. That's not just convenience.
08:57:36 <merijn> Solonarv: You could implement it yourself if you want bad things :p
08:57:50 <Solonarv> merijn: that's why I said "safely" :>
08:58:06 <__monty__> fr33domlover: They're all nice in theory but the network effect and the general lack of f*cks people give about the issue makes it mostly a pipe dream afaik. I don't really use traditional social media anyway so I don't really need free alternatives.
08:58:28 <dminuoso> merijn: Has IO a *defined* public API to construct?
08:58:39 <dminuoso> If not, then it's still not convenience.
08:58:42 <Solonarv> asheshambasta: it's a bit weird for a type family to take a Proxy argument
08:58:48 <merijn> dminuoso: There is a public API, whether it's defined depends on how you define defined? :p
08:58:52 <dminuoso> heh.
08:59:45 <asheshambasta> Solonarv: that is just a hacked up example, basically, what I'm trying to do is "know" which "FromJSON" to use depending on the type of some parameter to the function 
09:00:00 <Solonarv> yes, you can certainly do that.
09:00:14 <michaelsdunn1> I'll just stick with `atomically $ newTVar x` since I'm using it in `IO`
09:00:14 <asheshambasta> Solonarv: okay, interesting. 
09:00:23 <Solonarv> I'd probably use a type class with an associated type family, instead of a "free-standing" type family
09:00:34 <Solonarv> but that's still a type family ;)
09:02:00 <asheshambasta> yeah, as far as the proxy is concerned, I need to be able to supply the "type" I expect without having a value that I can give the function as input
09:03:20 <Solonarv> your *function* should take a proxy argument, your type family shouldn't.
09:03:47 <Solonarv> gimme a minute, I'll fork your gist
09:06:27 <Solonarv> asheshambasta: https://gist.github.com/Solonarv/04090930242588b4eee8c081bebec599
09:07:06 <asheshambasta> Solonarv: ah, thanks!
09:07:28 <asheshambasta> Solonarv: for an associated type family; does the syntax remain the same? 
09:07:44 <asheshambasta> I think not, it looks like GHC isn't happy with what I'm typing. 
09:07:58 <fr33domlover> asheshambasta, Haskell Wiki has a page about type families
09:08:09 <fr33domlover> The syntax is visible there
09:08:26 <merijn> A better place is the GHC user's guide section on type families
09:10:52 <asheshambasta> fr33domlover merijn: AFAICS, the examples don't contain something like a function on types in the gist Solonarv and I discussed above, but I could be wrong. 
09:11:31 <Solonarv> asheshambasta: the GHC user's guide is usually my first stop when I can't remember the syntax for some extension
09:13:53 <asheshambasta> Solonarv: Hm, I cannot find the particular thing we discussed (in its associated flavour); I'm looking here: https://wiki.haskell.org/GHC/Type_families#Associated_type_instances_2
09:14:51 <Solonarv> asheshambasta: that's not the GHC user's guide
09:20:50 <asheshambasta> Whoopsie, my bas
09:20:53 <asheshambasta> bad*
09:22:02 <Solonarv> asheshambasta: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#associated-data-and-type-families
09:32:52 * hackage cereal 0.5.8.0 - A binary serialization library  http://hackage.haskell.org/package/cereal-0.5.8.0 (EricMertens)
09:33:17 <asheshambasta> Solonarv: gotcha, thanks
09:39:38 <asheshambasta> Also, speaking of datakinds; how does one go about defining typeclass instances like these? https://gist.github.com/asheshambasta/4b8b25201189b7b870cc347192e162c5
09:40:33 <asheshambasta> My (naive) approach so far is to define an instance for each type based on the MySumType kind since doing otherwise results in a big scary "rigid type error" 
09:41:56 <Solonarv> that approach seems correct to me
09:42:16 <koz_> asheshambasta: Pattern matching on each of the GADT constructors.
09:43:03 <Solonarv> koz_: that doesn't help when you're supposed to *return* a value of that GADT
09:43:03 <koz_> What exactly is Parser a in this case?
09:43:24 <Solonarv> koz_: presumably, they're using the aeson package
09:43:34 <koz_> Solonarv: Yeah, but I dunno what Aeson defines it as.
09:43:54 <asheshambasta> koz_: maybe to "destructure" the GADT no? I'd like to have one typeclass instance for all types `t`
09:44:37 <Solonarv> I don't know exactly either, but it certainly doesn't give you an 'a' to work with - if it did, it couldn't have a Monad instance
09:45:45 <Solonarv> I think it just supports failure and not much else, so something like: newtype Parser a = Parser (Either WhateverErrorType a)
09:46:00 <koz_> Solonarv: It's _way_ more elaborate than that, as it turns out.
09:46:12 <koz_> http://hackage.haskell.org/package/aeson-1.4.2.0/docs/src/Data.Aeson.Types.Internal.html#Parser
09:46:53 <koz_> asheshambasta: You might wanna define toJSON first, because that will determine what your possible representations look like.
09:47:27 <Solonarv> ah, so it's basically that, but CPSed.
09:52:14 <nan`> does your witness (using "as ::") in hint have to be top-level for the generated code to work? I can't seem to use Data.ByteString.ByteString unless i import it top-level using setImportsQ
09:52:37 <c_wraith> nan`, well, it has to be in scope, anyway.
09:53:00 <c_wraith> it's a super awkward way of enforcing type safety
09:53:46 <nan`> well, i tried using setImportsQ with a ("Data.ByteString", "B") and i the intermediate generated code will always use unqualified ByteString in my types
09:53:47 <c_wraith> it rewrites the expression you provide with an extra wrapper ascribing the as type to the contents
09:54:17 <c_wraith> it just uses the show instance for the TypeRep
09:54:31 <nan`> c_wraith: i was thinking that, thanks
09:54:42 <nan`> sounds about right
10:00:36 <berndl> Say I have x :: f (Identity a). How do I simplify this to x' :: f a?
10:01:20 <dminuoso> berndl: You could use a type family.
10:01:52 <berndl> I was thinking about using coerce.
10:01:57 <Solonarv> berndl: what do you know about 'f'? is it just some completely unknown type?
10:02:07 <berndl> f is just some Functor.
10:02:07 <dminuoso> berndl: Can you give a bit more context?
10:02:45 <Solonarv> if 'f' is some Functor, you can use 'fmap runIdentity' or 'fmap coerce'
10:03:13 <Solonarv> No way to avoid the fmap without an additional constraint, I'm afraid.
10:03:18 <dminuoso> berndl: I do not see the advantage of using coerce over runIdentity for such a case, especially because coerce has way more potential to leak a bu.
10:03:23 <dminuoso> *bug even.
10:03:47 <dminuoso> In case of higher kinded datatypes I just use type families to get rid of Identity though.
10:04:28 <dminuoso> berndl: https://gist.github.com/dminuoso/e0246dec3a94cf7515c1ed86bd64810b
10:04:28 <berndl> I think 'fmap runIdentity' should work. Let me try.
10:05:43 <Solonarv> berndl: if you're able to add constraints, you can add 'Coercible (f a) (f (Identity a))' constraint
10:05:58 <Solonarv> and replace 'fmap runIdentity' with 'coerce'
10:06:24 <berndl> Solonarv: Good to know.
10:06:27 <Solonarv> (the difference is that 'fmap runIdentity' may uselessly traverse its argument, while coerce is guaranteed to be a proper no-op)
10:07:06 <Ariakenom> neither lambdabot or yahb has integer logarithms? :(
10:07:07 <Solonarv> On GHC 8.6 you can also enable QuantifiedConstraints and write 'forall x y. Coercible x y => Coercible (f x) (f y)' instead, which is cleaner IMO since it's a constraint on 'f' only.
10:07:44 <dminuoso> QuantifiedConstraints seems like a cool thing...
10:08:01 <dminuoso> Off to figure out what it means.. :)
10:08:04 <Solonarv> It is!
10:08:18 <glguy> % :t GHC.Integer.Logarithms.integerLogBase#
10:08:18 <yahb> glguy: Integer -> Integer -> Int#
10:08:33 <Solonarv> Eventually Functor should get a quantified superclass, I think
10:08:37 <glguy> I don't know if any packages wrap that up into a more useable form
10:09:04 <Solonarv> i.e.: class (forall x y. Coercible x y => Coercible (f x) (f y)) => Functor f where ...
10:09:08 <glguy> % GHC.Int.I# (GHC.Integer.Logarithms.integerLogBase# 2 1000)
10:09:08 <yahb> glguy: 9
10:09:25 <Solonarv> @hackage integer-logarithms -- pretty sure that's the package you're looking for
10:09:25 <lambdabot> http://hackage.haskell.org/package/integer-logarithms -- pretty sure that's the package you're looking for
10:14:15 <hyperisco> how about unsafeCoerce
10:21:06 <Solonarv> that would work, but unlike coerce it isn't guaranteed to be safe
10:22:27 <wroathe> Is there a way to get the numbber of currently pending or active green threads spawned with forkIO?
10:23:06 <Solonarv> wroathe: go have a look around the GHC.* modules in base, one of them has functions for retrieving RTS statistics
10:23:13 <wroathe> Solonarv: Thanks
10:23:15 <Solonarv> (which should include current number of green threads)
10:26:37 <adamCS> Another Vinyl/Frames question: I've got a "Rec (Maybe :. ElField) (as Vinyl.++ bs)" and I would like to somehow have a "Rec ElField (as V.++ cs)" where for each a ~ (al :-> at)  in as I have a function "Maybe at -> at" and for each b ~ (bl :-> bt) in bs, there would be a c ~ (bl :-> (Maybe bt)) in cs.  Does that even make sense?    
10:26:52 <adamCS> lyxia ^ 
10:33:51 <lyxia> I would start by splitting the record in two
10:36:11 <adamCS> lyxia: into the as and bs?  Okay.  Would it be easier if I explained the specific issue?
10:41:40 <adamCS> lyxia: Sorry! the ks and as!
10:42:14 <lyxia> there's ks?
10:42:21 <adamCS> sorry!
10:42:23 * hackage cantor-pairing 0.1.0.0 - Convert data to and from a natural number representation  http://hackage.haskell.org/package/cantor-pairing-0.1.0.0 (identicalsnowflake)
10:42:40 <adamCS> I named things differently for the question and in my code. No.  Only as bs and cs
10:42:50 <lyxia> heh
10:45:32 <adamCS> basically, I have a csv file with some missing data, so I need to read it into (Maybe :. ElField) form.  But I need to join it with another frame on a column which I know is present in every row. So I want to get a row where the key(s) (my as) are fromJust(ed) and the rest of the cols I will turn into Text and just write out the joined data.  Or I could put maybe back into the keys after the join.  Either would be fine.
10:48:53 <lyxia> I don't know, that sounds reasonable.
10:59:42 <Tranquil>  السَّلاَمُ عَلَيْكُمْ وَرَحْمَةُ اللهِ وَبَرَكَاتُهُ May the peace, mercy, and blessings of Allah be with you
10:59:44 <Tranquil> to you all
11:04:55 <sm> thanks Tranquil 
11:06:10 <Tranquil> sm not a problem
11:06:16 <Tranquil> sm are you female ?
11:06:48 <lyxia> totally a sane question to ask out of nowhere
11:06:56 <sm> aand it goes downhill :/
11:07:18 <Tranquil> sm are you ?
11:07:21 * Tranquil is male
11:07:50 <sm> Tranquil: you can't ask that kind of thing here
11:08:12 <Tranquil> sm well okey i will not ask you again
11:08:30 <sm> are you interested in haskell, or just cruising ?
11:08:39 <Tranquil> well just came here to chat
11:08:49 <__monty__> I'm fine with the question. It's just still up to the askee whether they want to answer or not.
11:09:46 <wroathe> Solonarv: Would you happen to know the function right off hand? gcdetails_threads in GHC.Stats seems to give me the number of OS level threads
11:10:32 <Solonarv> wroathe: no idea, I just figured that if such a function exists that's where it would be
11:10:51 <dminuoso> So.. even GHC makes use of _|_ to denote missing things in a data record..
11:10:55 <hyperisco> I bet you can answer that question yourself and be right 90% of the time
11:11:45 <wroathe> Tranquil is a troll who has been in here before and was kicked last time
11:11:58 <hyperisco> not the only channel they're done this in
11:15:01 <Tranquil> wroathe learn some manners
11:15:13 <Tranquil> dminuoso no bad language on main
11:16:48 <__monty__> wroathe: Seems likely, yes. Best way to deal with that is ignore them, rather than speak for an entire channel as to what questions can and cannot be asked here. I'd be happy to continue discussion about this in offtopic, since it's *offtopic* : )
11:17:46 <merijn> FYI: @where ops and #haskell-ops are the right way to deal with things you think are inappropriate
11:19:52 * hackage psqueues 0.2.7.1 - Pure priority search queues  http://hackage.haskell.org/package/psqueues-0.2.7.1 (JasperVanDerJeugt)
11:23:39 <__monty__> Even better.
11:24:22 * hackage haskell-gi-base 0.21.5 - Foundation for libraries generated by haskell-gi  http://hackage.haskell.org/package/haskell-gi-base-0.21.5 (inaki)
11:25:53 <wroathe> case (fork# action_plus s) of (# s1, tid #) -> (# s1, ThreadId tid #), do you guys happen to know where fork is defined? Is this some sort of FFI thing to the pthreads library?
11:28:25 <dminuoso> wroathe: https://hoogle.haskell.org/?hoogle=fork%23
11:28:30 <Boarders> does anyone know if there is a way to use critereon to benchmark on Arbitrary instances e.g. say I have a function f :: Arbitrary a => a -> IO () and want to generate random benchmarking based on the size of the input?
11:28:32 <Solonarv> wroathe: it's part of the RTS, I think
11:28:40 <dminuoso> wroathe: You should really bookmark Hoogle. :)
11:29:04 <cocreature> wroathe: definitely pthreads, that’s for OS level threads not for Haskell threads
11:29:34 <cocreature> fork# is a primop, you won’t be able to find a regular Haskell definition for that
11:30:56 <wroathe> dminuoso: https://www.haskell.org/hoogle/?hoogle=fork%23
11:31:06 <wroathe> Apparently the version of Hoogle you linked is different
11:31:37 <wroathe> But yeah, thanks!
11:33:48 <__monty__> wroathe: hoogle.haskell.org is a newer hoogle version and different from haskell.org/hoogle. I think the latter is still around because it has better (i.e. working) type search.
11:37:40 <fendor> given a filename "/home/user/test/" how can I extract the directory name "test/"? I am using the filepath library.
11:39:50 <__monty__> last . splitPath . takeDirectory?
11:40:28 <fendor> __monty__, good enough i suppose, thanks! 
11:40:59 <__monty__> fendor: You're not alone in thinking filepath is a little barebones.
11:43:10 <fendor> __monty__, still better than system-filepath though?
11:43:46 <the_2nd> can I configure stack to build into a different folder? currently it's that very long path containing cabal version etc. makes it hard to write tools that copy the output
11:44:17 <__monty__> fendor: It is?
11:44:42 <__monty__> Looks more featureful, not sure what its shortcomings are.
11:45:16 <cocreature> isn’t system-filepath the one that is deprecated?
11:45:37 <fendor> it is deprecated. 
11:46:12 <fendor> a pain point is definitely that they are not compatible with base `FilePath`
11:46:36 <__monty__> Both of them?
11:48:16 <Tranquil> laugh out loudly
11:48:24 <ClaudiusMaximus> base type FilePath = String, which is varying degrees of wrong, depending on the file system in use
11:48:59 <merijn> ClaudiusMaximus: That's mostly just wrong on non macOS *nix, no?
11:49:40 <__monty__> Aren't linux paths C strings?
11:49:48 <the_2nd> can someone answer with "don't know" to whether the stack build output dirs can be changed? So I know whether it's likely not possible or if nobody is responding ;)
11:49:58 <merijn> __monty__: Linux paths don't have a specified encoding, they're just a sequence of bytes
11:50:03 <koz_> the_2nd: Dunno.
11:50:13 <the_2nd> thanks :)
11:50:14 <merijn> __monty__: So there's no correct way to turn a unicode String into a filepath on unix
11:50:16 <lyxia> the_2nd: it's possible
11:50:48 <merijn> __monty__: On Windows and macOS the filesystem has unicode filepaths, which means that there *is* a right way to convert unicode String to paths on those systems
11:51:11 * shapr hops quietly
11:51:14 <lyxia> the_2nd: --work-dir .my-stack-root
11:51:29 <lyxia> shapr: heard you
11:51:32 <shapr> oh no!
11:52:00 <__monty__> merijn: The more you learn. The less you know...
11:53:03 <the_2nd> lyxia, still contains all the sub folders, hm
11:53:33 <the_2nd> I'd prefer to at least have the executables flat in a folder
11:55:41 <lyxia> sounds like stack install
11:59:07 <the_2nd> that would work, could also change the drop folder to something local
12:00:16 <the_2nd> stack install --local-bin-path ./bin
12:02:11 <the_2nd> that seems to do what I want, thanks
12:02:37 <lyxia> yw
12:06:09 <fendor> ClaudiusMaximus, I dont think that this is wrong... 
12:21:39 <wroathe> Ah, so Haskell's green threads are represented as TSOs in the RTS source code. As best I can tell, there's no primitives that can give the count of TSOs
12:25:11 <c_wraith> well, something must be able to, because threadscope exists
12:25:51 <c_wraith> it ingests some sort of rts log data, so whatever does that logging must have the information
12:40:45 <_deepfire> It's rather sad that default method declarations _must_ reside with the type class declaration.
12:42:30 <_deepfire> I sort of understand the rationale, but I think it's avoidable -- just stating that such a default must exist in the TC decl could've been enough.
12:42:38 <shapr> right on
12:43:24 <trcc> I am building a haskell package that can be used to implement a simulation unit. The end result is a zip file containing an xml description file and a shared object. Therefore, I need some extra functionality to package the compiled haskell application. Is there any best practices on this? I was considering providing an executable along with the package. I looked at hakyll, which does this, but hakyll also creates a cabal file for an entire new pro
12:43:25 <trcc> ject using hakyll. I do not think this is required. Any inputs?
12:45:51 <dmwit> I think I don't understand the question yet.
12:46:07 <trcc> hehe I will try again then
12:47:13 <bartavelle> OT : is there a document where the same thing is described using operational, denotational and axiomatic semantics?
12:48:21 <trcc> dmwit: I provide a package with some FFI functionality, and the developer can use this package to develop the control logic of a simulation unit. This should compile to a shared object, that can be loaded by an external application. But there is an extra step - this shared object must be part of a zip file, that also contains an xml file with various information of the simulation unit. Thus, I need an approach to perform this packaging.
12:50:06 <dmwit> cabal has a concept of data files that should be installed alongside a package when it's built.
12:50:11 <dmwit> Perhaps you can reuse that mechanism.
12:50:45 <dmwit> I believe its Paths_* module pokes about for an environment variable override in case you plan to have some manual install process into a not-easily-predictable location.
12:51:05 <monochrom> bartavelle: Consider Hoare and He's book Unifying Theories of Programming
12:51:07 <trcc> ah ok.  thanks
12:52:13 <bartavelle> monochrom: will look at it, but I suppose it is a lot of work getting through this, right?
12:53:14 <monochrom> I don't know. I think it's a reasonable amount of work for this ambition.
12:53:23 <bartavelle> ;)
12:54:22 <bartavelle> I would like to get a feeling particularly at how denotational and big step semantics differ, which is not obvious to me, but I am almost completely ignorant on the subject, I expected that a simple example would make it obvious
12:55:36 <monochrom> They differ when your language allows recursion.
12:55:58 <bartavelle> ah! I will ponder on that and stop the OT
12:56:26 <monochrom> In big step semantics it's OK to say "to evaluate fix (\f -> blah), evaluate f (fix (\f -> blah)) instead"
12:57:25 <monochrom> OTOH denotational semantics has this obsessive insistence on structure recursion over program syntax.
12:58:00 <monochrom> i.e., if you ever write down "sem(xxx) = ... sem(yyy) ..." then yyy must be a smaller expression than xxx.
12:58:38 <monochrom> Well that forbids you from asserting "sem(fix f) = sem(f (fix f))".
12:59:06 <monochrom> (whereas operational semantics are OK with that)
12:59:56 <monochrom> So basically 99% of any denotational semantics course is devoted to how to work around it.  (It's cheesy: You say that you move the recursion to the meta level.)
13:02:07 <Rembane> For the untrained lay ear that sounds like cheating. 
13:03:02 <monochrom> It is a deep philosophical point that you can't get rid of recursion, you can only move it elsewhere.
13:03:54 <__monty__> And it doesn't apply to structural recursion?
13:04:52 <monochrom> So denotational semantics says do this instead: sem(fix f) = meta-level-fix (sem(f)).  Now you devote the rest of your life on why meta-level-fix exists.
13:13:22 * hackage ping 0.1.0.1 - icmp echo requests  http://hackage.haskell.org/package/ping-0.1.0.1 (andrewthad)
13:17:59 <trcc> monochrom: bartavelle: perhaps take a look at isabelle-utp
13:18:20 <trcc> https://github.com/isabelle-utp/utp-main
13:19:35 <bartavelle> trcc: this is probably a bit over my head!
13:20:08 <trcc> bartavelle: mine as well ^^
13:20:46 <trcc> bartavelle: maybe this is a bit better. It takes a toy langauge, gives it big step and small step semantics. later on, it described a denotation approach. http://concrete-semantics.org/concrete-semantics.pdf
13:21:43 <monochrom> Hey I should use that as my textbook!
13:21:56 <trcc> monochrom: it is fairly new
13:22:03 <trcc> last year I think
13:22:13 <trcc> packed with exercises
13:22:35 <monochrom> Haha "this is a great book, I learned Isabell/HOL from it".
13:23:04 <monochrom> Like that time I was having a steak dinner and "how is it? is it good?" "yeah the sauce is pretty good".
13:23:17 <monochrom> (which is a way to say the steak is pretty meh!)
13:23:45 <bartavelle> oh that looks exactly like the type of things I like
13:24:20 <monochrom> Can't go wrong with Nipkow.
13:25:02 <bartavelle> I loved "software foundations", for it had many exercises, and learning coq/playing proof tetris was a great motivation in learning the concepts
13:25:27 <bartavelle> if that does the same thing for isabelle, that would be awesome
13:26:06 <monochrom> Haha "I will not allow books to prove anything"
13:26:38 * monochrom jumps right into Part II
13:28:20 <monochrom> Anyone interested in porting the proofs to Dependent Haskell? >:)
13:36:10 <bartavelle> amusing, there is an abstract interpretation part
13:37:13 <johnw> has anyone been able to get servant-quickcheck working with Stream requests?
14:14:41 <wroathe> c_wraith: threadscope huh? I'll take a look, thanks
15:13:21 <oao> i have a question about the ST monad that i haven't been able to figure out by myself. i am working on some code for which the best implementation choice seems to be unboxed vectors--specifically, making one mutable inside runST and then doing a bunch of math on the contents (inherently an iterative process), and then freezing it on the exit
15:14:31 <oao> but the nature of the operations required seem to call for sub-functions, and i am having trouble making the mutable vector available to these other functions
15:14:52 <oao> i may be too early on in my work with haskell to properly use ST
15:14:54 <merijn> oao: Having trouble how?
15:15:21 <Welkin> just apply the functions
15:15:46 <Welkin> functins defined at the top level of a module are available everywhere in that module
15:15:56 <Welkin> or imported from another module
15:16:01 <oao> i admit i am rather confused since i've tried so many things which seemed like they should work
15:16:22 <merijn> oao: Can you pastebin the code you have?
15:16:56 <oao> yes, though i should clean it up a bit first, thank you!
15:16:58 <oao> stdby...
15:19:11 <Welkin> make sure your function take mutable vectors https://hackage.haskell.org/package/vector-0.12.0.2/docs/Data-Vector-Mutable.html
15:20:14 <Welkin> unboxed here https://hackage.haskell.org/package/vector-0.12.0.2/docs/Data-Vector-Unboxed-Mutable.html
15:20:16 <oao> (this will take a bit since i'd munged the code trying to do something that didn't work)
15:27:42 <oao> update: in simplifying the code to make a sample, i may have identified the problem ;) but it's a little too early to say for sure
15:28:02 <oao> the latest change was just specifying the types for one of the subfunctions
15:29:08 <oao> even though i had used <- to grab the vector from thaw, i was getting a complaint about the PrimState and am still not sure why, though i may be able to defer that question for now
15:30:51 <mouse07410> Well, I decided to give cabal v2 another try. I added cabal.project, like maerwald suggested. Now v2 command started finding that dependency package - but the sod thing insisted on building a copy in this project dir, no matter what. I.e., cabal v2 follows the stack approach of keeping copies of everything in this project directory. I call this approach putting a straightjacket on to avoid shooting oneself in the foot.
15:33:52 * hackage wkt-geom 0.0.5 - A parser of WKT, WKB and eWKB.  http://hackage.haskell.org/package/wkt-geom-0.0.5 (newmana)
15:35:11 <__monty__> That's not true in general.
15:36:56 <iqubic> So how do recursive Parsers work?
15:38:30 <oao> merijn: here's a sample illustrating the difficulty: https://gist.github.com/unprolix/1bd2923af854c31b87b30111f2925874
15:39:25 <oao> (turns out i was wrong about having figured it out... intero just decided not to complain for a few minutes, for an undisclosed-to-me reason)
15:40:32 <oao> oh wait, i bet i'm screwed up about where again
15:41:11 <oao> ok, don't think that's it.
15:42:05 <iqubic> So recurisive parsers are really really weird.
15:44:53 * hackage stratosphere 0.29.1 - EDSL for AWS CloudFormation  http://hackage.haskell.org/package/stratosphere-0.29.1 (jdreaver)
15:45:16 <oao> oops standby...
15:46:09 <oao> (ok, just some extra type cruft that wasn't properly simplified away)
15:50:56 <iqubic> So I have something like this, and I'm not sure how to go about parsing it. http://dpaste.com/2ZDJA3W
15:51:33 <iqubic> Note, that this will be the first parser I've ever made. I've looked at online tutorials, so I have some idea of the theory behind parser combinators.
15:53:22 <__monty__> iqubic: You mean you want to parse a syntax into a value of type Expr?
15:53:58 <__monty__> I'd recommend http://dev.stephendiehl.com/fun/
15:54:17 <lyxia> iqubic: megaparsec's README links to some tutorials
15:54:41 <lyxia> and there are very readable papers on this topic
15:55:14 <ClaudiusMaximus> https://hackage.haskell.org/package/parsec-3.1.13.0/docs/Text-Parsec-Expr.html may be useful too
15:56:06 <lyxia> http://www.cs.nott.ac.uk/~pszgmh/pearl.pdf
15:57:09 <iqubic> __monty__: I want to turn something like "5 * (3 + 4)"::String into "Mul (Const 5) (Add (Const 3) (Const 4))"
15:57:40 <iqubic> I want a Parser s Expr. Where s is some repersentation of a string.
16:05:51 <wroathe> So I'm trying to write a routine to download 40 or so files from the internet in parallel. One thing I noticed about the RTS's green threads is that after each thread opens a connection to the remote webserver the scheduler moves onto another thread and lets it do the same thing. That means I end up with 40 of these haskell threads, and 40 open connections all competing for time to stream data to the 
16:05:57 <wroathe> disk. I'd like to do these downloads in batches... Say N at a time where N is the number of cores on my system...
16:06:17 <wroathe> I'm using mapConcurrently from async for this
16:07:07 <wroathe> I tried splitting my input data into chunks and feeding that to mapConcurrently, but still seems to just create 40 threads without waiting for the previous mapConcurrently to finish
16:08:00 <wroathe> Is there a standard way people do this in terms of async?
16:09:06 <Solonarv> wroathe: async-pool seems to do this
16:15:00 <wroathe> Solonarv: Yeah, I saw that. Didn't seem to be very popular, but I suppose I can use it for inspiration.
16:15:22 <Solonarv> Why not just use it?
16:15:50 <Solonarv> It might have problems (I don't know, I've never used it), but so could your hand-rolled implementation
16:17:56 <wroathe> Solonarv: I'm thinking the solution to my problem should be simple enough to do in one function, and I'd rather roll my own if that's the case than include an entire library just to get this behavior
16:18:05 <wroathe> And my implementation doesn't need to be perfect
16:22:33 <wroathe> Actually, mapConcurrently does wait like I expected. There must have been something wrong with my earlier attempt.
16:23:01 <oao> okay, i think i figured it out! at the root seems to have been a misunderstanding about `do`
16:34:31 <fen> solved the problem by associating the abstracted Traversabler (r :: * -> *) (t :: * -> *) corresponding to the normal Traversable clas with the type synonym `type Id a = a', similarly for `r'
16:35:30 <fen> similarly `type Pair a b = (a,b)' gives; type Traversable_i i t = Traversabler (Pair i) t
16:39:38 <fen> Pair is needed as there is no "TupleSections" at type level, also using `type Id a = a' instead of Identity as a Type "kind * -> *" which when supplied with type `a' is isomorphic to `a'
16:40:22 <Solonarv> you don't need TupleSections
16:40:36 <fen> :k (Int,)
16:40:38 <lambdabot> error: parse error on input ‘)’
16:40:47 <Solonarv> :k (,) Int
16:40:49 <lambdabot> * -> *
16:40:58 <fen> oh nice
16:41:45 <fen> so just Id then... is this found elsewhere?
16:42:25 <Solonarv> a type synonym? Possibly, but I don't know when that would be useful
16:43:07 <fen> its useful for the example just given at least
16:43:41 <Solonarv> I'm pretty sure that isn't legal, actually
16:50:47 <fen> The type synonym `Id' should have 1 argument, but has been given none
16:50:50 <fen> damn
16:52:00 <fen> % type Id a = a
16:52:01 <yahb> fen: 
16:52:06 <fen> % :k Id
16:52:06 <yahb> fen: Id :: k -> k
16:52:11 <Solonarv> yup, that's what I meant
16:52:25 <Solonarv> type synonyms must be fully applied where they're used
16:52:25 <fen> but it has the right kind...
16:53:12 <glguy> It's a restriction of type synonyms. It doesn't have anything to do with its kind
16:53:26 <fen> these newtypes are so clumsy 
16:53:27 <Solonarv> Allowing unsaturated type synonyms lets type lambdas sneak in, which in turn makes type inference go to shit
16:55:12 <fen> so there is no kind * -> * type that when provided with `a' is equal to `a' ?
16:55:31 <fen> which can be passed unsaturated
16:55:35 <Solonarv> Not in Haskell.
16:56:32 <Solonarv> There are various means of faking it, but they're all cumbersome
16:56:38 <fen> in general it could break inference, but not here!
16:56:50 <fen> Id explicitly preserves the applied type!
16:57:55 <fen> means carrying around type casts from Identity a -> a
16:58:31 <fen> nvm
17:01:00 <fen> do we have a library for ergodic theory? measure preserving spaces and such constructions...
17:02:01 <fen> cant even find banach spaces...
17:02:46 <fen> there is http://hackage.haskell.org/package/Dist
17:02:50 <fen> for distributions
17:03:12 <fen> but not sure the API is done
17:03:20 <johnw> fen: I'd ask that you avoid using #haskell as a place to express streams of consciousness
17:04:31 <fen> haskell does have some stochastic libraries...
17:04:49 <fen> just not axiomatically constructed on top of function spaces
17:04:57 <fen> unless they are hiding somewhere
17:05:04 <fen> johnw: its not a question?
17:05:09 <johnw> fen: it's not a question ;)
17:07:09 <fen> seems like the right language to develop algebraic objects
17:07:20 <johnw> what I mean is, you're using a channel of ~1200 people to talk to yourself at the moment. If it's part of an active discussion, great, there are really no limits here other than it being related to Haskell. But we discourage people from using the channel as a sounding board.
17:09:03 <argent0> Is this: `data Rec a = Rec a (Rec a)` equivalent to `Cofree Identity a`. It seems so. If so, is there a `class` to zip these. Something like: `foo :: Cofree Identity a -> Cofree Identity b -> Cofree Identity (a, b)` ?
17:09:12 <fen> wondering if there was some existing efforts for this in haskell, or if there is any enthusiasm for such a task. 
17:09:20 <johnw> argent0: yes, it seems so
17:09:44 <nyc> fen: I recommend starting an ergodic theory library project.
17:10:38 <argent0> I tried mzip, but Identity is not an instance of applicative 
17:10:51 <fen> nyc: nice. not sure if it would fit in easily with the existing work on Categories
17:10:54 <Solonarv> Thats seems wrong
17:11:04 <Solonarv> > Identity negate <*> Identity 5
17:11:07 <lambdabot>  Identity (-5)
17:11:19 <argent0> *alternative
17:11:40 <Solonarv> what's Alternative got to do with zipping?
17:11:46 <johnw> right, there's no `empty' for Identity possible
17:12:06 <nyc> fen: It could be good to request changes to accommodate your work when you run into problems.
17:12:34 <johnw> yes, we love helping with code examples here
17:13:11 <argent0> Solonarv: idk, http://hackage.haskell.org/package/free-5.1/docs/src/Control.Comonad.Cofree.html#line-175
17:13:31 <Solonarv> yeah I'm waiting for those docs to load, my laptop is being slow :/
17:13:41 <johnw> sure, cofree is Alternative if 'f' is
17:14:05 <johnw> you can see how this would work with Cofree Maybe a
17:14:16 <Solonarv> perhaps more relevantly, cofree is Apply whenever 'f' is
17:14:24 <johnw> Cofree Identity a is a stream, Cofree Maybe a is a non-empty list
17:14:46 <Solonarv> (since the original question was about zipping, which alternative has nothing to do with)
17:15:37 <argent0> johnw: I want a stream `Rec a = Rec a (Rec a)`
17:16:42 <argent0> zip two streams
17:16:45 <Solonarv> argent0: the class you're looking for is 'ComonadApply' or 'Apply'
17:17:20 <argent0> Solonarv: I'll check it up, thanks
17:18:19 <Solonarv> 'Cofree f' is an instance of those whenever 'f' is
17:20:34 <Solonarv> % type Stream = Cofree Identity
17:20:35 <yahb> Solonarv: 
17:22:33 <shapr> Is there a haskell emacs mode that does in-scope completion?
17:22:37 <shapr> perhaps I should try hie again
17:22:45 <fen> johnw: maybe its something to do with Haskell traditionally instilling a prepositional logic approach to programming, hence the lack of support for continuous functions. though FRP had a differentiable aspect, and we have polynomials etc, it still seems difficult despite this work, to think about this kind of approach in Haskell
17:23:31 <Solonarv> % takeStream n = take n . toListOf shoots
17:23:32 <yahb> Solonarv: 
17:23:35 <shapr> fen, do you use emacs?
17:24:05 <argent0> Solonarv: thanks: `liftF2 (,) foo bar` does the trick
17:24:27 <Solonarv> % nats = coiter (Identity . succ) 0
17:24:27 <yahb> Solonarv: 
17:26:00 <fen> shapr: thats more of a pure computational persons thing right? more concerned with simulation..
17:26:12 <shapr> fen, wait what?
17:26:28 <shapr> fen, what editor do you use to write Haskell?
17:26:29 <fen> isnt that for people developing things like cabal?
17:26:35 <Solonarv> argent0: great!
17:26:48 <fen> shapr: oh sorry! just whatever
17:27:16 <shapr> fen, oh is any of your code on github?
17:28:03 <fen> hackage is the goto repo no?
17:28:37 <Solonarv> Not really. Hackage is a package database, not so much a code repository.
17:29:12 <fen> yeah, guess github has better vc for teamwork
17:29:16 <Solonarv> i.e. it's somewhere you can upload your package so other people can use it easily
17:30:01 <fen> well arguably cabal install is easier than git..
17:30:21 <fen> but yeah, for contributing to existing projects, totally
17:30:29 <shapr> oh, tried cabal install darcs?
17:30:46 <shapr> version control system written in Haskell, with a really cool patch theory
17:31:13 <fen> rather support that sure
17:32:05 <fen> the haskell community normally takes a really strong approach and has some great tools as a result
17:35:08 <shapr> I like the lsp support in emacs for other languages
17:36:18 <nyc> cabal may need to be accommodated, too, though I think it's easy.
18:06:18 <mouse07410> shapr: there are several decent editors that are good for Haskell. First, Emacs and Spacemacs - and you can invoke REPL from within it. Then, BBEdit is nice, and there are scripts (on Mac at least) to compile and run your file. If you want a heavier gun - IntelliJ IDEA has a decent plugin for Haskell. Finally, there's vi for quick-n-dirty. I've used all of the above, and an hair with them.
18:06:56 <mouse07410> "an hair"->"am happy"
18:07:41 <koz_> I would like to add that Neovim + ALE is a great solution too, with a small tweak.
18:10:13 <shapr> mouse07410, for the moment I prefer emacs, but I do appreciate you listing the options :-)
18:10:17 <shapr> mouse07410, what do you use?
18:21:33 <nyc> nvi is my favorite.
18:30:28 <mouse07410> Emacs is fine. IntelliJ is a full-blown IDE, and a very good one (IMHO). I use it for all my heavier work. For a quick in-and-out - either Emacs or vi. Nite that I got the scripts working, I occasionally use BBEdit (it's a better editor, but I'm too used to the other two ;)
18:31:03 <mouse07410> "Nite"->"Now"
18:36:29 <dsal> Does anyone happen to know where stack ghc binary dists come from?
18:37:23 <adamCS> How do I lift a type constructor out of a vinyl record?  Rec ElField (MapTyCon f rs) -> Rec (f :. ElField) rs ?
18:39:45 <meinheld> hey could someone help me? i'm learning haskell
18:40:39 <meinheld> are these vids obsolete now with ghci 8.0.1? https://www.youtube.com/watch?v=OfxCm_OarIg&list=PLS6urCrsYES24Fwzg5-Uga1QEbNm9kiU_&index=9
18:41:45 <meinheld> i'm getting a 'variable not in scope error in the Winner function that is in this video at 4:15
18:41:52 <meinheld> i triple checked my typing...
18:42:10 <dsal> meinheld: can you paste your code somewhere?
18:42:58 <c_wraith> it's a lot of work to ask someone to review a video. can you help us out by providing a more direct representation, like the code itself? (as dsal has also requested)
18:43:10 <meinheld> https://hastebin.com/akivagesul.coffeescript
18:43:29 <meinheld> ok there you are breh
18:43:54 <dsal> abc /= [a,b,c]
18:43:58 <c_wraith> oh, could you include the error message as a comment? it helps a ton.
18:44:26 <meinheld> wowwwwwwwwwwwwwwwwwwwww
18:44:31 <meinheld> argh
18:44:37 <meinheld> pebcak
18:44:43 <meinheld> thank you
18:44:54 <meinheld> should be commas
18:45:07 <dsal> What error message did you get?
18:46:34 <meinheld> variable not in scope
18:46:42 <dsal> I'm certain you got more than that.
18:46:50 <dsal> ghc tends to give pretty good error messages.
18:47:14 <Solonarv> (do *not* copy-paste it into this chat! add it to your paste, or make a new one)
18:47:54 <meinheld> i got that error for every variable mentioned in the instance lines
18:47:59 <meinheld> it's fixed now,
18:48:00 <meinheld> thx
18:48:29 <meinheld> i added commas in the establishing line
18:48:38 <meinheld> line 6 i believe
18:48:51 <meinheld> [a,b,c] etc instead of no commas
18:49:16 <meinheld> thx all!
18:49:59 <Welkin> yes, make a new irc server and paste it there
18:50:06 <dsal> ha
18:50:17 <meinheld> wut?
18:50:30 <Solonarv> they're joking ;)
18:50:40 <meinheld> :]
18:51:36 <dsal> meinheld: But, do please be easier to help.  If you get an error, paste the code and error into a paste thing.  Don't assume you've done it right and we all know that even though you did it right, we can fix it.  Showing the error also makes it easier to try to understand why it wasn't obvious to you, and how we might help fix that.
18:52:01 <meinheld> i didn't assume i'd done it right.
18:53:17 <dsal> Heh, OK.  I guess by that, I mean, pointing to a video of someone else having written code and asking if the compiler is the reason it doesn't work for you instead of showing your own code.
18:53:39 <Welkin> if only the erlang channel were as responsive as this one
18:53:46 <Welkin> anyone know erlang?
18:53:54 <dsal> I used to write erlang.
18:54:18 <dsal> If the channel isn't responsive, the process probably died, but you should've been signaled if you were linked properly.
18:55:19 <meinheld> yes dsal that's a better way. got it
18:55:32 <meinheld> better by magnitudes...
19:28:17 <meinheld> so i'm trying to make the game connect four
19:28:25 <meinheld> i've got this for the drop in
19:28:27 <meinheld> https://hastebin.com/ihohefesok.bash
19:29:21 <meinheld> and these errors.
19:29:23 <meinheld> https://hastebin.com/joqokuyewe.cpp
19:29:40 <meinheld> obv i'm all off but i'm looking at the type? 
19:30:10 <meinheld> i mean my definition. i forgot what that line is called
19:36:52 * hackage char-decode 0.0.1 - Convert legacy byte encodings to and from Unicode  http://hackage.haskell.org/package/char-decode-0.0.1 (nbloomf)
19:48:15 <meinheld> any help with my type decl?
19:48:53 <meinheld> https://hastebin.com/ihohefesok.bash
19:48:59 <meinheld> these errors.
19:49:04 <meinheld> https://hastebin.com/joqokuyewe.cpp
19:49:17 <dmwit> meinheld: From `if o == "."`, we learn that `o` must be of type `String`.
19:49:33 <dmwit> meinheld: So the claim that you can handle any type as your second argument is right out. You can only handle [[String]].
19:49:56 <dmwit> (Sorry, [String], I mean.)
19:50:13 <meinheld> what does "right out" mean?
19:50:26 <dmwit> "not possible", "completely incorrect"
19:50:27 <jackdk> impossible.
19:51:05 <meinheld> ah i want to address each . in a series of . 's
19:51:13 <dmwit> meinheld: From `o:os`, we learn that `os` must be `[String]`. But from `n:os` and `n :: Int`, we learn that `os` must be `[Int]`. So that's not possible either.
19:51:16 <meinheld> for instance "..."
19:51:40 <dmwit> > findIndices ('.'==) "..."
19:51:42 <lambdabot>  [0,1,2]
19:52:03 <dmwit> > findIndices ('.'==) "wat.txt"
19:52:05 <lambdabot>  [3]
19:52:46 <meinheld> what's all this?
19:52:50 <dmwit> But it seems like you've misunderstood something fairly fundamental (maybe several things), so it might be worth struggling together to fix the thing you've got.
19:53:05 <Welkin> pattern matching solves all things
19:53:05 <meinheld> i'd like to, thank you
19:53:34 <meinheld> so i want to make a game of connect four
19:54:00 <meinheld> for the dropin i wanted to check each char in a string for . which will be a blank
19:54:23 <dmwit> Sounds good so far.
19:55:01 <dmwit> What type do you think dropin should have?
19:55:04 <Welkin> you could use a List, Array, or Map for that
19:55:53 <dmwit> I think switching data structures isn't going to make anything easier.
19:56:12 <meinheld> what type hmm
19:56:16 <dmwit> My personal recommendation would be to stick with your current implementation plan and figure out how to get it working. Then figure out if there's a better plan after that.
19:56:33 <meinheld> well i'm evaluating char and the input is....?
19:56:40 <meinheld> yeah
19:56:43 <meinheld> ^
19:57:18 <meinheld> i mean, i'm evaluating a string
19:57:33 <meinheld> but each value in that string is a char right?
19:57:42 <dmwit> Sure.
19:57:48 <Welkin> a String is [Char]
19:57:53 <Welkin> so it's a list
19:58:08 <meinheld> yes a list
19:58:24 <dmwit> Okay. So after this clarification and deliberation, what type do you think dropin should have?
19:58:55 <meinheld> maybe i need to go back to a type declaration introduction
19:58:58 <meinheld> i'm swimming
19:59:11 <meinheld> but to try
19:59:41 <meinheld> it's evaluating [char] ?
20:00:01 <dmwit> Are you saying you believe the type of dropin should be `[Char]`?
20:01:05 <meinheld> well as i understand it, type declarations have a type for the input, then the type for the output right?
20:01:34 <Welkin> it sounds like you may need to read a book on haskell
20:01:36 <dmwit> That is true for functions, yes. Not all values are functions, of course, but I definitely think `dropin` should be a function.
20:01:48 <meinheld> and the input that i was is r or b and those are Int s?
20:01:58 <Welkin> https://www.seas.upenn.edu/~cis194/spring13/
20:02:06 <Welkin> use the resources lists in that course
20:02:10 <kadoban> meinheld: They're just types. And functions have types too.
20:02:14 <Welkin> there are newer books, but the basics haven't changed
20:02:28 <dmwit> What is "r" and "b"?
20:02:33 <meinheld> red black
20:02:37 <meinheld> (connect four game)
20:02:50 <dmwit> Why is the color an input to this function?
20:03:20 <meinheld> because then the whole string must be evaluated to see a win
20:03:28 <maerwald> Does anyone know how to avoid the rebuild between 'cabal new-install' and 'cabal new-test'?
20:04:09 <dmwit> cabal new-build all test # or something like that, can't remember the name for the magic build target for tests
20:04:35 <meinheld> thanks all for your inputs. i think i'll re-go-over type decl's in the video series i was in
20:04:47 <dmwit> I think reviewing some tutorial material would be wise.
20:04:49 <glguy> maerwald: The trick is that new-install doesn't reuse the stuff from new-build, either
20:04:59 <meinheld> k dmwit thx
20:04:59 <dmwit> oh what
20:05:04 <glguy> Those things don't mix that well
20:05:17 <glguy> It like in v1 build how build and install don't mix well
20:05:32 <glguy> not exactly the same, but related
20:05:40 <maerwald> glguy: I know
20:05:48 <maerwald> and I cannot enable tests on new-install
20:05:53 <glguy> in that case install was a shortcut for build/copy/register, but in v2 world new-install doesn't work with dist-newstyle stuff
20:06:02 <glguy> it goes into the ~/.cabal/store 
20:06:44 <maerwald> Basically what would solve it would be new-build + symlinking the binaries (what stack already does)
20:08:53 <meinheld> (oh, you guy[s] were asking which type the function is, as in recursive, pattern-matching, etc?)
20:09:30 <glguy> maerwald: Does new-install --run-tests do it?
20:09:46 <maerwald> Cannot run tests at that stage, that would break CD
20:10:01 <glguy> What was CD?
20:10:22 <glguy> continuous dev?
20:10:27 <Welkin> continuous deployment?
20:10:28 <maerwald> deployment pipeline
20:10:37 <dmj`> compact disc 
20:10:37 <Welkin> usually called CI (integration)
20:11:18 <Welkin> there are too many acronyms
20:11:51 <iqubic> I just read CI and thought CaseInsensitive. LOL.
20:25:38 <jackdk> is there a clear winner between scotty and spock, in terms of active maintenance, or is there a third lightweight wai application I should be using?
20:26:09 <Welkin> scotty is more lightweight than spock
20:26:13 <Welkin> spock is pretty heavy
20:26:30 <Welkin> it's more liek a framework
20:26:33 <Welkin> scotty is just a library
20:26:40 <jackdk> spock is also not in nixpkgs, and scotty wants aeson < 1.4 =(
20:26:57 <Welkin> really though
20:27:00 <Welkin> you can just use wai
20:27:05 <Welkin> that is what I'd do
20:27:17 <Welkin> I get annoyed at all the conversions I need to do in scotty
20:27:24 <Welkin> I just end up using wai functions anyway a lot of the time
20:27:40 <Welkin> scotty is a very thin wrapper over wai that can make it kind of annoying when you really know what you are doing
20:28:15 <jackdk> perhaps that's better. there is only one endpoint that's inexpressible with servant
20:28:17 <jle`> hey um why is there no Monoid instance for Data.Functor.Product
20:28:46 <Welkin> servant is not a general purpose web server library
20:29:04 <jle`> hm, there's a Monoid instance for (:*:), i might use that one instead
20:29:05 <jackdk> correct.
20:29:06 <Welkin> it's only for a web (really json) API and comes with some tight restrictions on how you do things
20:29:20 <Welkin> wai (or scotty) gives you complete freedom to do whatever
20:31:59 <julianleviston> There’s a Product in Data.Monoid.
20:33:54 <julianleviston> Oh… different kind of product.
20:38:20 <meinheld> thx agn all
20:38:23 <meinheld> til nxt tim
20:38:59 <jle`> oh, the Monoid instance for :*: is ghc 8.8+
20:39:06 <jle`> so for now we are stuck with no monoid ...
20:40:11 <Welkin> 8.8 comes out in march right?
20:40:26 <julianleviston> Where does :*: come from?
20:40:27 <Welkin> I'm still on 8.4
20:41:20 <Welkin> that seems to be the ultimate question in all of haskell: where does <weird looking operator> come from?
20:41:49 <Welkin> at least in source code you can trace it back to its origin
20:41:58 <julianleviston> Oh it’s from GHC.Generics.
20:42:12 <julianleviston> I looked it up on hayoo...
20:43:02 <Welkin> all operators should have human-readable versions
20:43:12 <julianleviston> tho… there are actaully several other candidates, too :) So, it’s more a question of “which one are you guys talking about” :) hehe. I *guess* Control.Compose given you’re talking about products.
20:43:28 <julianleviston> Welkin: yeah, but we would people use the human-readable versions they were talking about? :)
20:43:46 <Welkin> lens does it at least
20:43:56 <julianleviston> Welkin: I mean… the problem isn’t finding out some weird operator name, it’s finding an instance of what’s being talked about in the wild on some findy-site :)
20:44:08 <julianleviston> Welkin: yeah thank god lens does :)
20:44:15 <julianleviston> Welkin: or rather, thank EK ;-)
20:44:53 <julianleviston> But yeah, I should have known better :) I apologise for asking before I hayoo’d it. :)
20:45:51 <Welkin> I see `mappend` used instead of <>
20:46:01 <Welkin> at least in the hakyll skeleton
20:48:08 <jackdk> lens' operators at least follow a very carefully-considered pattern
20:50:05 <Welkin> that is true
20:50:32 <Welkin> user-defined operators were removed from Elm and I think the language is better for it
20:50:58 <Welkin> not that I'd want them removed from Haskell, but having human-readable options is always good
20:56:17 <jackdk> I strongly disagree with Elm's decision there
20:57:04 <jackdk> while I don't think you should do silly things like bit-shift a stream by a string, there are good reasons to leave that toolkit in the hands of EDSL-writers
20:57:49 <Welkin> it makes everyone's code much more readable
20:58:30 <Welkin> I got very annoyed at people blindly copying random operators from other people's code that did nothing more than wrap the parameters in a tuple. Basically, users were abusing it
20:58:42 <jackdk> i don contraction-mark t think so period punctuation scans differently to words comma and that is valuable
20:59:59 <jackdk> I find the use of "idm" for "mempty" in optparse-applicative much more jarring than the use of <> for "mappend"
21:01:47 <jle`> julianleviston: yeah, we have Data.Functor.Product, Data.Functor.Sum, and Data.Functor.COmpose
21:02:20 <jle`> julianleviston: but we also have the same types `:*:`, `:+:`, and `:.:`
21:02:28 <jle`> it's a little unfortunate that we duplicate these
21:03:10 <glguy> I think it's OK to have types specific to a particular purpose
21:03:24 <jle`> but, they're identical and have identical instances?
21:03:25 <glguy> We don't need to try to cram everything into the same generic structures, say using Either 
21:03:28 <glguy> Yeah
21:03:36 <jle`> i think the difference between the two is mostly historical
21:03:39 <julianleviston> jle`: yeah it’s all good. Makes complete sense because it pretties up the type level constructors.
21:04:08 <julianleviston> I’m quite glad we’ve not done an Elm. I think Haskell is richer for having put up with the pain involved in having operators.
21:05:13 <julianleviston> It does make complete sense in Elm, tho. Elm’s more aimed at winning.
21:05:21 <glguy> e
21:05:38 <julianleviston> Where “winning” means gaining market mindshare and being approachable to JS level devs.
21:05:39 <glguy> Especially for GHC.Generics it makes sense to have types that are intended to be specific to the generic structures
21:06:03 <glguy> where those instances won't be confused with other uses that happen to use some Data.Functor types
21:06:15 <glguy> the primary use of the GHC.Generics types is to make instances
21:06:53 <julianleviston> It still makes me feel mildly offended on behalf of haskell every time a JS-was-my-first-lang dev announces how amazing some haskellism is that they first discovered in Elm.
21:07:14 <julianleviston> but it really doesn’t matter :) it’s nice we’re all experiencing more of the pure FP :)
21:07:34 <jle`> heh, there's no need to be offended. i feel proud of haskell whenever someone says they love python's list comprehensions :)
21:07:44 <julianleviston> Yeah I’m not actually offended. Wrong word choice.
21:07:52 <julianleviston> jle`: that’s the way :) hehe. :)
21:07:57 <nyc> julianleviston: Elm the mailreader?
21:08:00 <jle`> glguy: i suppose that's true in the general case. i'm just sad that they stole the :*:/:+:/:.: names
21:08:16 <julianleviston> nyc: https://elm-lang.org
21:09:07 <Welkin> Elm has things haskell doesn't have, namely nice record syntax and extensible records
21:09:26 <Welkin> I've said before that Elm has helped me become an even better haskell programmer
21:09:42 <nyc> I think there's an extensible record extension for Haskell.
21:09:56 <Welkin> and a surprising number of people in the Elm community are also haskell programmers or at least becoming interested in haskell because of Elm
21:10:51 <nyc> I think it was originally Mark Jones' baby and implemented in hugs.
21:10:51 <Welkin> of course the compiler is in Haskell, so you need to know it to contribute
21:11:47 <julianleviston> and the compiler isn’t a bad haskell codebase ;-)
21:11:59 <Welkin> I feel I learn something valuable from every language I learn to us
21:12:13 <Welkin> the compiler as recently completely rewritten for 0.19
21:12:15 <Welkin> was*
21:13:00 <Welkin> racket/scheme has helped me to understand how I can use quasiquotes
21:13:11 <Welkin> in haskell they've always been some weird, ugly ting I never dared touch
21:13:32 <Welkin> erlang is teaching me about actors, which can be used in haskell (or even scala)
21:13:35 <julianleviston> nyc: https://wiki.haskell.org/Extensible_record ?
21:13:52 <julianleviston> Welkin: Cloud Haskell is much nicer to learn about “actors” than Erlang IMO.
21:14:18 <julianleviston> Welkin: or smalltalk for that matter ;-) ;-)
21:14:30 <Welkin> not just actors, but distributed computing
21:14:52 <Welkin> cloud haskell's learning resources are sparse to non-existent
21:14:54 <julianleviston> Welkin: likewise for Cloud Haskell. Simon Marlow’s book is a must read IMO
21:15:02 <Welkin> yes, I love the fish book
21:15:09 <Welkin> but that has nothing to do with distributed computing
21:15:14 <julianleviston> eh?!
21:15:22 <julianleviston> sure it does.
21:15:35 <Welkin> it helped me learn a ton about concurrency though
21:15:43 <julianleviston> distributed-process is covered in it, isn’t it?
21:15:52 <Welkin> if it is, I haven't read it yet
21:16:31 <julianleviston> Let me go look.
21:17:09 <julianleviston> Yeah chapter 14.
21:17:31 <julianleviston> He creates a distributed chat server.
21:18:15 <Welkin> I see
21:18:43 <nyc> julianleviston: That's got some of the old stuff I remember.
21:19:30 <julianleviston> nyc: should do. haskell’s been concurrent & parallel for a long time.
21:20:04 <julianleviston> Welkin: but yeah, I see your point — language “siloism” isn’t usually a useful thing to do (I mean deciding one is a “haskeller” or a “rust person” or a “rubyist”…) coz it locks one into a mental box and one potentially stops learning so much. All good :)
21:20:49 <Welkin> if cloud haskell has a one-to-one (or close enough) correspondance to erlang's api, then I can use either
21:20:58 <Welkin> although I would like to use both languages together
21:22:01 <Welkin> there are at least 2 distributed databases written in erlang, and one of the most popular message queue systems
21:22:11 <Welkin> I'd like to see something like that in haskell
21:23:10 <nyc> julianleviston: It was Glasgow Parallel Haskell before anything.
21:23:20 <julianleviston> Welkin: I did a google: https://github.com/ntindall/KVStore
21:23:39 <julianleviston> Someone’s final project for a course.
21:23:54 <Welkin> I mean something product ready
21:23:58 <Welkin> production*
21:24:17 <Welkin> these usually have a company backing them, like CouchDB or Riak
21:24:55 <Welkin> but I suppose there isn't any huge benefit to doing it in haskell vs erlang
21:25:03 <julianleviston> type safety?! lol
21:26:06 <Welkin> when your types are simple anyway, not a huge benefit. You can run a static analyzer
21:26:44 <julianleviston> Welkin: guh have you *used* dialyzer? :shudder:
21:26:53 <julianleviston> This looks interesting: http://hackage.haskell.org/package/courier
21:27:42 <Welkin> nope, not yet
21:27:47 <julianleviston> Welkin: we use Elixir heavily at work. I’d still rather write almost anything in Haskell TBH. There are *some* advantages to using Elixir/Erlang, but we use hardly any of them at work (supervision trees is one, but you could easily implement such things in Haskell anyway, methinks).
21:28:08 <julianleviston> there’s just *such a lot of boilerplate* in Erlang/Elixir.
21:28:15 <Welkin> elixir and erlang are not the same language
21:28:19 <Welkin> I can't stand elixir
21:28:24 <Welkin> but I like erlang
21:28:33 <julianleviston> it’s mostly syntax differences IMO.
21:28:37 <Welkin> erlang is much more concise
21:28:42 <Welkin> and consistent
21:28:51 <julianleviston> eh? not my experience.
21:29:17 <AfC> "methinks" at any kind of scale the supervision problem has shifted to cluster orchestration layers
21:29:44 <julianleviston> wellthinked:+1:
21:30:19 <AfC> (Erlang's take on it is epic, but single process or local network supervision only gets you so far)
21:34:32 <Welkin> haha
21:34:51 <Welkin> it looks like there is a very brief exercise introduced in chapter 14 for setting up a distributed key-value store
21:35:11 <Welkin> luckily I know several answers after having read a whole book on the subject (well, half of it so far!)
21:46:13 <dminuoso> 06:22          Welkin | [05:09:04] I've said before that Elm has helped me become an even better haskell programmer
21:46:28 <dminuoso> This I find really surprising. Generally I read a lot more bad opinions from fellow Haskellers about Elm.
21:46:56 <dminuoso> Can you elaborate a bit more on how that came to be?
21:50:53 * hackage waargonaut 0.5.2.1 - JSON wrangling  http://hackage.haskell.org/package/waargonaut-0.5.2.1 (schalmers)
21:51:00 <maerwald> My guess is that Elm focuses on simplicity, while that is generally not very high priority in most of haskell code you see
21:51:32 <Welkin> I find that people who dismiss elm because it doesn't have all the special features of haskell are missing the point, and missing out on what it is good at
21:51:59 <Welkin> it has to do with the approach to writing the code, and how I learned to think about program in an even more stuctured way 
21:52:21 <maerwald> Welkin: write a blog post please :P
21:52:26 <maerwald> Might be interesting
21:52:28 <Welkin> for example, using ADTs to make impossible states impossible
21:52:34 <Welkin> I don't need to write a blog post
21:52:38 <Welkin> just look up any elm talk
21:52:43 <Welkin> most of them are incredibly good
21:52:55 <dminuoso> Welkin: How is Elm any different from Haskell in that regard?
21:52:57 <Welkin> anything by Evan or Richard Feldman
21:53:08 <maerwald> I only watched the FRP overview of Evan
21:53:08 <dminuoso> I mean, the "using ADTs to make impossible states impossible" part.
21:53:38 <Welkin> I have come up against obstacle in Elm where I thought there was no way to do what I wanted to do, but I was thinking about the problem wrong, and the solution turned out to be very simple
21:53:49 <Welkin> elm is not frp and does not use signals any more
21:54:50 <Welkin> dminuoso: I don't find talks like that for Haskell. Generally I find that haskell material tends to be much more academic and less approachable, unless you already know all of the background material
21:56:04 <Welkin> I'm off to bed though
21:56:06 <dminuoso> Welkin: While it stems from an academic field, I reject the idea that you need to understand background material to learn Haskell.
21:56:55 <Welkin> of course, ad Elm has the same roots, but the way that it is discussed is another matter entirely.
21:57:05 <nyc> To be honest, the main thing I use is arbitrary-precision arithmetic with overloaded infix arithmetic operators.
22:02:22 <julianleviston> I don’t agree with hat “make impossible states impossible” idea very much, because… it’s not Idris.
22:02:36 <AfC> Haskell is a very broad community. It is a privilege to be able to write code in an environment that has such a rich academic background and rigour;
22:02:55 <dminuoso> julianleviston: Since he left I cant be sure, but I think what Welkin meant, was to use a sum type to define possible states.
22:03:19 <dminuoso> Say `data State = Open | Closed | Deleted`, once you have a state of type `State` it's guaranteed to be any of these three (+ bottom)
22:03:21 <AfC> but day to day we spend essentially zero time considering "more complex" (sic) ways to do things. Quite the opposite.
22:03:27 <julianleviston> yeah that’s exactly what he meant. It’s a common adage in the Elm community…. beacuse of RT Feldman’s talk “Making Impossible States Impossible” or whatever it’s called.
22:03:40 <julianleviston> dminuoso: Elm doesn’t have bottom ;-)
22:03:42 <systemfault> That video also shows zippers
22:03:46 <systemfault> IIRC
22:03:54 <julianleviston> yup… 
22:03:57 <dminuoso> julianleviston: Does it have exceptions?
22:04:04 <julianleviston> dminuoso: no.
22:04:09 <dminuoso> julianleviston: Does elm have a totality checker?
22:04:12 <julianleviston> dminuoso: it’s an interesting language.
22:04:21 <dminuoso> julianleviston: Im going to *bet* that Elm has no totality checker.
22:04:22 <julianleviston> dminuoso: I think so.
22:04:32 <dminuoso> julianleviston: So you have to supply termination proofs?
22:04:42 <dminuoso> That strikes me as odd for a language that is supposed to be approachable for JS develoeprs
22:05:00 <systemfault> Elm is definitely not Idris.
22:05:01 <julianleviston> dminuoso: it’s a simple language… simpler than haskell.
22:05:04 <julianleviston> that’s true.
22:05:25 <dminuoso> julianleviston: My point is: Can you have infinite loops in Elm?
22:05:29 <julianleviston> dminuoso: at least, the surface syntax and the fact that all the values are pure.
22:05:32 <julianleviston> dminuoso: no.
22:05:40 <julianleviston> dminuoso: the runtime handles that ;-)
22:05:41 <systemfault> Anyway, welkin's point seemed to have been more about the community than the language itself.
22:05:48 <julianleviston> dminuoso: they were very clever. :)
22:05:50 <dminuoso> julianleviston: What does the runtime do to an infinite computation?
22:05:57 <dminuoso> julianleviston: Does it just timeout after n seconds?
22:05:58 <julianleviston> dminuoso: it’s a type error.
22:06:23 * hackage viewprof 0.0.0.27 - Text-based interactive GHC .prof viewer  http://hackage.haskell.org/package/viewprof-0.0.0.27 (MitsutoshiAoe)
22:06:28 <julianleviston> dminuoso: the language doesn’t *have* computation or even descriptions of it, like Haskell does (ie IO).
22:06:39 <dminuoso> julianleviston: IO is not about computation.
22:06:40 <julianleviston> dminuoso: it’s just expressions all the way down :)
22:06:54 <julianleviston> dminuoso: :sigh:
22:10:44 <lyxia> Why does the fact that Haskell is not Idris mean that it's not worth "making impossible states impossible"? Sure you're not going to have a mechanical proof of that guarantee but you can get pretty damn close in many cases.
22:11:20 <dminuoso> julianleviston: You can trivially set up infinite recursion in Elm by means of lambda, giving you bottom.
22:11:24 <julianleviston> lyxia: oh, I meant… what if you’re making a password validation system, say…? how are you going to encode in the type that the length of your strings should be between 5 and 12 characters, say?
22:11:40 <julianleviston> dminuoso: I don’t see how, but I’ll believe you.
22:12:11 <julianleviston> dminuoso: I’m pretty sure the compiler checks for infinite recursion and won’t allow it (ie totality), but maybe I’m deluded.
22:12:19 <dminuoso> julianleviston: It's essentially the halting problem, Elm is too powerful in terms of computational power.
22:12:35 <julianleviston> dminuoso: but it’s not a turing complete language...
22:12:37 <nyc> There are I think easy ways to have strings of a maximum length.
22:12:38 <julianleviston> dminuoso: is it?
22:12:47 <julianleviston> nyc: really?
22:12:55 <julianleviston> nyc: in the types?
22:13:17 <julianleviston> nyc: AFAIK you’d need peano numbers (ie Nat), and be able to lift the length of the String into the type system
22:13:21 <lyxia> not in the types
22:13:25 <julianleviston> mm
22:13:26 <dminuoso> julianleviston: Yes it is, it's just an extended form of typed lambda calculus.
22:13:51 <lyxia> but an abstract type with smart constructors gets you 99% of the way there.
22:13:54 <jackdk> you get a special error message if you do (say) `let x = x in x`, but it's more of a safety rail than a full-blown totality checker
22:13:56 <nyc> julianleviston: Peano types were what I had in mind.
22:13:57 <julianleviston> dminuoso: ok I must have missed something. Maybe demonstrate? https://ellie-app.com/new
22:14:10 <julianleviston> nyc:  yeah but the length of a string needs to be lifted into the type system as well, no?
22:14:19 <julianleviston> nyc: otherwise how can you make your “impossible type impossible"?
22:14:32 <lyxia> but still
22:14:53 <dmwit> julianleviston: Just replace `update msg model = ...` with `update msg model = update msg model`.
22:14:53 <julianleviston> nyc:  this is relatively trivial in Idris
22:15:02 <dmwit> julianleviston: Click compile, then click "+", and boom, infinite loop.
22:15:13 <julianleviston> dmwit: ok. I stand corrected.
22:15:20 <julianleviston> dmwit: I thought it gave an error.
22:15:28 <julianleviston> (last time I check I’m pretty sure it did)
22:16:12 <nyc> julianleviston: You'd be able to have a fixed number for a maximum length no problem.
22:16:27 <julianleviston> dmwit: you’re quite right. it does do that. I stand corrected :)
22:17:01 <dmwit> It does check that you've handled all patterns. But that's not enough for totality.e
22:17:02 <julianleviston> nyc: I don’t see how.
22:17:22 <julianleviston> dmwit: yeah, I understand.
22:17:34 <julianleviston> dmwit: I actually did think it had a totality checker in it lol
22:17:41 * dmwit nods
22:17:57 <julianleviston> dmwit: but not a rigourous one, just one to check you’d handled the base and recursive cases of recursion.
22:18:04 <dmwit> Totality checking is v. v. hard.
22:18:10 <julianleviston> dmwit: yeah.
22:20:11 <dmwit> Well. Good totality checking, anyway. =)
22:20:40 <julianleviston> so maybe it has a “partial function checker” lol :)
22:20:43 <dmwit> STLC is v. v. easy but it's absolute garbage for programming in.
22:20:54 <julianleviston> the weird thing is, I’ve had cases where it’s complained about loops. Not sure what hte context was tho.
22:20:54 <lyxia> There may be plenty of properties you can't encode in Haskell but my point still stands that what you can encode is already plenty useful.
22:21:02 <dminuoso> julianleviston: Im fighting the elm compiler at the moment because it has *extremely* conservative checks ruling out so many *non* infinite programs as infinite.
22:21:06 <julianleviston> lyxia: definitely.
22:21:14 <dminuoso> But I have a working implementation of a fixed point combinator.
22:21:38 <dminuoso> So its just a question of finding any of the *infinite* cases that Elm does not have a conservative check for.
22:21:50 <julianleviston> dminuoso: dmwit already pointed one out.
22:22:14 <julianleviston> dminuoso: and I agreed it’s not a totality checker… basically just read the last 20 backscroll messages :)
22:22:26 <dminuoso> julianleviston: Oh yeah, I was just in a different window.
22:22:32 <lyxia> If I'm being a smart ass, one way to read "making impossible states impossible" gives it a different meaning from "making *only* possible states possible".
22:24:03 <dminuoso> dmwit: It's interesting that *that* case is not cause. Other degenerate cases are caught easily, and plenty of non-degenerate cases.
22:24:17 <dminuoso> This is another example of Elm trying to "help" you.
22:24:24 <dminuoso> *case is not caught
22:25:52 * hackage hw-dsv 0.3.4 - Unbelievably fast streaming DSV file parser  http://hackage.haskell.org/package/hw-dsv-0.3.4 (haskellworks)
22:49:57 <DigitalKiwi> my impression of elm is that it and its authors are highly opinionated and if your opinion matches with it great but if they don't it's going to be rough and you'll face technical and political problems *shrug*
22:56:24 <maerwald> As with any language
22:57:51 <DigitalKiwi> eh, some are more burdened with it than others...
23:00:00 <maerwald> Well, at least there is a direction ;=
23:02:23 * hackage yam 0.5.4, yam-datasource 0.5.4 (leptonyu): https://qbin.io/pvc-denial-y79c
23:08:45 <dminuoso> DigitalKiwi: I dont mind the language giving some direction, but when it creates completely arbitrary constraints because the authors believe it leads to "bad code" - then it's not a language for me.
23:09:53 <trcc> I am looking for a clever approach to do: Run a function X times. Every time it is run, it subtracts a number A from a number B. When B < C, then function should not be executed anymore. The result of one function, must be passed to the next function execution. If any of the functions return a status of FATAL, it should stop recursing. It is sort of a iterate/sequence/fold thingie. Any construct in haskell for this? My current implementat
23:09:53 <trcc> ion: https://gist.github.com/CThuleHansen/8a6ee3501b180f86a714565dba021fa7
23:10:00 <DigitalKiwi> dminuoso: agreed
23:10:36 <maerwald> dminuoso: maybe he is right? What constraints
23:14:22 <dminuoso> maerwald: It used to be that the comparable instance was provided for only up to 6-tuple. A 7 tuple had no comparable because.. well completely arbitrary reasoning.
23:14:32 <dminuoso> Now it seems that you cannot even make tuples larger than 3-tuple anymore.
23:16:04 <julianleviston> trcc: you could use iterate, no?
23:16:07 <julianleviston> > :t iterate
23:16:10 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
23:16:16 <dminuoso> :t iterate
23:16:16 <lyxia> trcc: why does "remTime" get replaced with "period", are they really only different at the start?
23:16:17 <lambdabot> (a -> a) -> a -> [a]
23:16:24 <julianleviston> dminuoso: thanks :)
23:16:57 <lyxia> iterate doesn't do IO
23:17:14 <trcc> lyxia: because the doStepF executes for a certain time period. remTime is the remaining time until the period has finished executing
23:18:05 <julianleviston> sorry I didn’t look at the code yet. Didn’t realise it was in IO.
23:18:37 <maerwald> dminuoso: afais, elm has the goal to be an easy switch-to language for javascripters
23:18:51 <maerwald> so they consider things differently in that light
23:19:01 <julianleviston> Does it actually need to be in IO?
23:19:01 <trcc> julianleviston: thanks though
23:19:04 <trcc> yes
23:19:22 <trcc> the doStepF is created by the developer using my package, and he must be allowed to do anything
23:19:29 <julianleviston> ah yeah, ok.
23:19:49 <trcc> Ideas on seperating this call is also very welcome
23:19:58 <julianleviston> So you could write a function that iterates on predicate truth, no?
23:20:06 <julianleviston> this feels very familiar...
23:20:07 <trcc> could you elaborate?
23:20:52 <julianleviston> You want it to keep going while a certain condition holds, right?
23:21:29 <julianleviston> https://hackage.haskell.org/package/loop-while-1.0.0/docs/Control-Monad-LoopWhile.html
23:21:58 <trcc> yes. While remTime <= css && T.dsrStatus == T.oke
23:22:00 <trcc> yes. While remTime <= css && T.dsrStatus == T.OK
23:22:27 <julianleviston> Would that lib help?
23:23:27 <trcc> hmm, I need parts of the result from one execution of the function to be used in the following execution
23:23:39 <trcc> It does not look like that is supported here?
23:23:58 <julianleviston> it doesn't?
23:24:11 <lyxia> do you intentionally not use endTime
23:24:17 <julianleviston> all this lib is, is the frame of conditional iteration isn’t it?
23:24:35 <nyc> dminuoso: Which tuple instances got removed?
23:24:54 <trcc> lyxia: thank you! I am using it somewhere else, not needed for this function. 
23:26:32 <lyxia> trcc: what do you mean by "separating this call", does having it as a parameter not do what you want?
23:26:35 <trcc> julianleviston: I will give it a closer look. I cannot se where the return from performAction is
23:27:07 <julianleviston> performAction?
23:27:37 <trcc> lyxia, something like separating the impure from the pure parts, so I can move some of the logic to a pure function
23:27:59 <trcc> julianleviston: yes, I guess the performAction corresponds to doStepF
23:28:00 <julianleviston> trcc: I think performAction is just their hand-wave for “some work you want to do"
23:28:32 <julianleviston> trcc: you can do whatever you like in that do action, I’d say, so long as you do a while in there, no?
23:28:50 <trcc> but can I pass the result from the previous execution of performAction into the next?
23:29:35 <julianleviston> I don’t see why not. it’s like a regular IO action, except it’s got this additional structure that represents the continuation around it, (seems to me anyway).
23:30:16 <trcc> Then it is probably me that cannot see how. I will try to look more into it. Thank you
23:30:18 <julianleviston> if your lifted step returns a value, you can extract it and use that in another “call” to your lifted step function.
23:30:30 <julianleviston> sorry I didn’t explain it very well.
23:31:00 <julianleviston> I think what you’re doing is fine, tho.
23:31:11 <trcc> hmm then maybe I should just stick to it
23:32:37 <trcc> I will write your suggestion down and get back to it :)
23:33:15 <julianleviston> You could do some small simple refactorings and it’d show you a nicer direction to move in, maybe… start wiht the most obvious duplciation.
23:37:00 <trcc> Thanks lyxia and julianleviston
23:37:03 <julianleviston> I often find a really good way to approach this kind of stuff is writing down pseudocode for what I’m trying to achieve. Then, see if I can somehow extract/create pure functions to do the bulk of that stuff, so I can “push” the IO out to the edges, so it’s just in one tiny place.
23:37:17 <trcc> seems reasonable
23:38:23 * hackage tensors 0.1.2 - Tensor in Haskell  http://hackage.haskell.org/package/tensors-0.1.2 (leptonyu)
23:51:35 <dminuoso> nyc: At least on ellie I cannot make tuples larger than 3-tuples anymore.
23:51:42 <dminuoso> nyc: so not just instances, but tuple constructors.
23:53:55 <nyc> dminuoso: The compiler magic for tuple syntax got ripped out.
23:55:03 <dminuoso> nyc: I just consider it a bad violation of the zero or infinity rule.
23:56:18 <nyc> dminuoso: I don't have to have heard of that rule to know it sucks.
23:56:46 <dminuoso> err *zero one or infinity :P
