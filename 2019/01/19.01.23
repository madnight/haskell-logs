00:00:02 <jle`> you might be right :o
00:00:37 <dminuoso> I wonder whether adding HasCallStack might be enough for just `read` then/.
00:00:42 <bryan1_> jle`: the issue is that there are no calls to `read` in my project :(
00:00:55 <jle`> oh. then that's annoying, heh
00:00:58 <jle`> ;_;
00:01:00 <dminuoso> bryan1_: One of your (possibly transitive) dependencies might. :<
00:01:55 <bryan1_> dminuoso: i bet it does... but i fear there are too many dependencies I wouldn't know where to start
00:02:14 <bryan1_> why do ppl use read!
00:02:22 <dminuoso> bryan1_: you could run the expression in GHCi with `:trace` while having `:set -fbreak-on-error` enabled and then use `:history` and `:back`, no?
00:02:56 <bryan1_> dminuoso: one step ahead of ya
00:06:00 <dminuoso> jle`: Mmm, couldn't one try to disable optimization and dump.. say simplifier output and see if there's any reference to `read`?
00:06:18 <dminuoso> Or something similar.
00:43:28 * hackage prolog 0.2.1.1 - A Prolog interpreter written in Haskell.  http://hackage.haskell.org/package/prolog-0.2.1.1 (MarcelFourne)
00:52:12 <asheshambasta> Apart from on Functional Programming Slack and /r/haskell; where else does one advertise a Haskell job opening? 
00:52:44 <asheshambasta> (just checking if there are places I'm unaware of)
00:53:16 <dminuoso> asheshambasta: haskell mailing list?
00:53:33 <dminuoso> (haskell-cafe probably)
00:53:40 <dminuoso> Or haskell
00:53:41 <asheshambasta> I looked at Functional Works, but they ask you for $450/month just to be able to look at your applicationts 
00:53:54 <dminuoso> asheshambasta: Where is the opening?
00:53:57 <dminuoso> Which country I mean.
00:54:05 <asheshambasta> dminuoso: Belgium
00:54:39 <asheshambasta> but we're open to part-remote applications from within the EU 
00:54:49 <merijn> asheshambasta: haskell-cafe probably :)
00:55:18 <merijn> asheshambasta: Ah you just missed the best opportunity to recruite people around Belgium by 2 weeks :)
00:56:07 <merijn> asheshambasta: Every January for the past few decades we've had the NL-FP day, which attracts lots of functional people from around the Netherlands and Belgium
00:57:02 <dminuoso> It's better to have functional people than dysfunctional people.
00:58:07 <asheshambasta> merijn: ah, I was not aware 
00:59:57 * hackage netlib-carray 0.1 - Helper modules for CArray wrappers to BLAS and LAPACK  http://hackage.haskell.org/package/netlib-carray-0.1 (HenningThielemann)
01:00:36 <merijn> asheshambasta: There's the affiliated fp-nl mailing list, but I dunno if they allow job adverts (I think they would, it's super low traffic and call-for-papers are ok), but maybe check first
01:00:57 <asheshambasta> and its okay to post job adverts in Haskell-cafe, right?
01:01:01 <asheshambasta> I'm doing that right no
01:01:04 <asheshambasta> now*
01:01:06 <chadhaa> How to do get around to debugging and logging in haskell? Traditional logging appraches don't really make sense in haskell(and I don't want to write imperative haskell just for this)?!?! Any suggestions?!
01:01:16 <merijn> asheshambasta: https://mailman.science.uu.nl/mailman/listinfo/fp-nl (there's contact emails for the admins at the bottom)
01:01:35 <merijn> chadhaa: First step: Debug.Trace?
01:01:40 <merijn> @quote refresing.desert
01:01:41 <lambdabot> No quotes match. :(
01:01:45 <merijn> @quote refreshing.desert
01:01:46 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
01:02:13 <merijn> asheshambasta: haskell-cafe definitely allows job postings IFF they're Haskell openings
01:03:00 <merijn> asheshambasta: But fp-nl might give you better geographic reach (as subscribers tend to be clustered around the Benelux), if they allow them
01:05:02 <merijn> chadhaa: For logging I tend to try something more systematic, recently I've grown to like the monad-logger package. But Debug.Trace is excellent for printf debugging pure code
01:05:57 * hackage blas-carray 0.1 - Auto-generated interface to Fortran BLAS via CArrays  http://hackage.haskell.org/package/blas-carray-0.1 (HenningThielemann)
01:06:33 <MarcelineVQ> merijn: co-log is pretty cool https://kowainik.github.io/posts/2018-09-25-co-log
01:12:53 <chadhaa> merijn: Will using this affect the purity of my functions?? Since this is doing some IO?
01:13:27 * hackage lapack-carray 0.0.3 - Auto-generated interface to Fortran LAPACK via CArrays  http://hackage.haskell.org/package/lapack-carray-0.0.3 (HenningThielemann)
01:13:44 <dminuoso> chadhaa: Yes.
01:14:03 <dminuoso> chadhaa: For debugging purposes it's perfectly fine, but don't commit the code into your production branch..
01:14:24 <merijn> What he said :p
01:14:57 <dminuoso> merijn: Oh and I also love monad-logger, it feels like the right abstraction. :)
01:15:26 <merijn> MarcelineVQ: That looks...considerably less simple to use :p
01:15:44 <MarcelineVQ> dunno much about that, but it's neat
01:15:50 <dminuoso> composable contravariant combinatorial comonadic configurable convenient logging..
01:16:57 <merijn> dminuoso: As soon as things require like 4 constraints to use a log function I'm quickly losing interest :p
01:17:08 <merijn> eh, s/dminuoso/MarcelineVQ
01:19:12 <dminuoso> Though for what its worth, it's really interesting to see Contravariant/Divisible/Decidable. 
01:19:14 <merijn> I'm not sure what the new complex API actually buys me. I mean the docs re-export 6 modules worth of stuff I have to look through. monad-logger has like, 1.5 modules (it has two, but one is just a variation of the other...)
01:19:43 <dminuoso> merijn: and best of all, monad-logger is just a slightly specialized MonadReader :)
01:19:58 <merijn> I just wish it has slightly lighter weight dependencies :)
01:21:34 <dminuoso> merijn: Do you also have UnliftIO flowing through all your code?
01:24:09 <merijn> dminuoso: I started using it in my chan library, but unliftio-core is super lightweight in comparison
01:24:36 <merijn> It only depends on base and transformers, both of which ship with GHC, so are essentially free
01:25:57 * hackage aeson-value-parser 0.13 - An API for parsing "aeson" JSON tree into Haskell types  http://hackage.haskell.org/package/aeson-value-parser-0.13 (NikitaVolkov)
01:47:28 * hackage hlint 2.1.13 - Source code suggestions  http://hackage.haskell.org/package/hlint-2.1.13 (NeilMitchell)
01:48:29 <merijn> Anyone know if there's a conduit ZipSource that continues until *both* are exhausted, rather than just 1?
01:51:22 <merijn> I guess I can wrap both source with Maybe and then use takeWhile until both are Nothing, but that seems hacky..
01:51:28 * hackage prolog-graph-lib 0.2.1 - Generating images of resolution trees for Prolog queries.  http://hackage.haskell.org/package/prolog-graph-lib-0.2.1 (MarcelFourne)
01:52:20 <bryan1_> merijn: ZipSink?
01:52:41 <dminuoso> bryan1_: Did you figure out where `read` came from without rebuilding with -prof?
01:53:01 <merijn> bryan1_: That...doesn't seem related to my problem at all?
01:53:11 <bryan1_> dminuoso: Yes...
01:53:53 <bryan1_> merijn: sorry i went cross-eyed.. 
01:55:51 <merijn> Is there even a name for a zip that elongates both sequences to be the same length?
01:55:58 * hackage hevm 0.24 - Ethereum virtual machine evaluator  http://hackage.haskell.org/package/hevm-0.24 (mbrock)
01:56:42 <dminuoso> merijn: `these` calls it Align.
01:56:54 <dminuoso> As introduced by http://pchiusano.blogspot.com/2010/06/alignable-functors-typeclass-for-zippy.html
01:56:57 * hackage prolog-graph-lib 0.2.1.1 - Generating images of resolution trees for Prolog queries.  http://hackage.haskell.org/package/prolog-graph-lib-0.2.1.1 (MarcelFourne)
01:58:30 <merijn> dminuoso: That doesn't seem like it'd really help with my problem either unless I write align instances first
01:58:57 <dminuoso> merijn: You asked for a name, I gave you one... :P
02:03:04 <cinimod> Can anyone see anything obviously wrong with this: https://gist.github.com/idontgetoutmuch/ab62a7d535898c3aa7b854174c0f4601
02:03:41 <cinimod> I am testing it by giving it an array with 3 elements; the first two are updated but not the third :(
02:05:44 <bryan1_> `VS.thaw v; upd mv; VS.freeze mv`
02:05:54 <bryan1_> v vs mv
02:06:06 <merijn> bryan1_: No, that's right
02:06:16 <merijn> bryan1_: He's binding the result of thaw as 'mv'
02:08:04 <dminuoso> `thaw v >>= \mv -> upd mv >> freeze mv`
02:08:41 <dminuoso> cinimod: One thing I noticed, are you using ScopedTypeVariables?
02:08:47 <cinimod> Yes
02:12:31 <cinimod> dminuoso: I can see something suspicious in the input function
02:12:40 <cinimod> So the gist might actually be fine
02:13:05 <dminuoso> cinimod: Everything does look fine. Im guessing your `h :: Ptr a -> IO ()` is borked.
02:13:15 <cinimod> That is also my guess
02:13:39 <cinimod> Thanks for taking the time :)
02:21:39 <merijn> hmmm, Conduit doesn't have a Maybe based filter, does it?
02:32:32 <merijn> Somewhat relatedly: Man, Data.Bifunctor really needs "both :: Bifunctor f => (a -> b) -> f a a -> f b b"
02:37:08 <Ariakenom> % :t \f -> runIdentity . both (Identity . f)
02:37:08 <yahb> Ariakenom: Data.Bitraversable.Bitraversable r => (a -> b) -> r a a -> r b b
02:39:35 <merijn> phadej: Ping?
02:40:28 <phadej> pong
02:40:46 <merijn> phadej: How well does tree-diff perform on Text/textual data?
02:41:02 <phadej> it doesn't Text is opaque, so it simply == it
02:41:49 <merijn> hmmm, bummer, all these other diff libraries seem like a hassle to use :\
02:42:06 <merijn> I guess I can try diffing String via T.unpack...
02:42:17 <c50a326> why does building stuff with ghc take soooo long (hakyll, pandoc, haskell-ide-engine... pretty major packages...)
02:42:38 <tdammers> because GHC is a complex beast
02:43:12 <ventonegro> GHC relies on inlining a lot, generating boatloads of code
02:43:15 <tdammers> usually, a lot of compilation time is spent on typechecking and optimizing
02:43:23 <phadej> merijn: Diff isn't that bad: https://github.com/haskell/cabal/blob/97484d8e46f3c542523ef5daf5470540a4d66cb6/Cabal/tests/ParserTests.hs#L324-L338
02:43:30 <merijn> c50a326: Hakyll takes long because it depends on (and thus builds) pandoc, pandoc is slow because it has one dependency which triggers an edge-condition in GHC making it SUPER slow to compile (a year or two ago, this single 1500 line package took 40 minutes to build)
02:44:39 <merijn> phadej: I'm not/don't want to diff at a line level, though. The output seems focussed on that, despite supporting diffing arbitrary lists
02:44:57 <phadej> well, you can diff String as [Char] too
02:45:01 <phadej> it just what you want
02:45:39 <merijn> phadej: Yeah, I just wonder how reasonable the output will end up being
02:45:42 <phadej> visualising that diff is trickier (if you can use ansi-terminal, it's not so bad)
02:46:36 <phadej> I didn't bother to hack anything like github does (2D diff, highlights with color the differences between different lines)
02:47:01 <merijn> phadej: difference between two lines is exactly the only bit I care about :)
02:47:22 <Ariakenom> is there performance measurements of compiler phases somewhere? Other compilers than GHC would be interesting too.
02:48:20 <phadej> compiler architecture is not something set in stone, there are different phases in different compilers :)
02:49:27 * hackage hsdns 1.8 - Asynchronous DNS Resolver  http://hackage.haskell.org/package/hsdns-1.8 (PeterSimons)
02:49:45 <inkbottle> :t (let foo = undefined :: a -> b -> Int in (fromIntegral .) . foo :: a -> b -> Integer, let foo = undefined :: a -> b -> c -> Int in ((fromIntegral .) .) . foo :: a -> b -> c -> Integer) -- Is there a lambda to pf chat sheet?
02:49:47 <lambdabot> (a1 -> b1 -> Integer, a2 -> b2 -> c -> Integer)
02:50:46 <Ariakenom> phadej: yes, I didn't want a comparison between compilers
02:51:55 <inkbottle> cheat*
02:54:00 <gentauro> "this single 1500 line package took 40 minutes to build" wait wat. pandoc takes 40 minutes to build? I don't want to be a Gentoo user ...
02:54:52 <merijn> gentauro: It used to 1 or 2 years ago
02:55:28 <merijn> gentauro: AFAIK the situation was improved (so probably not 40 minutes anymore), but the fundamental issue is still open
03:03:48 <gentauro> merijn: I'm downloading it just to see how long it takes :D
03:09:55 <gentauro> " This process will take a while, and will consume a considerable amount of disk space."
03:09:58 <gentauro> :o
03:10:49 <Logio> gentauro: I actually use gentoo and at one point got rid of anything depending on pandoc for that reason :P 
03:11:41 <gentauro> Logio: I remember the old days when I used it (hint: my nickname) but gosh, compiling Open Office from scratch. Never again !!!
03:11:48 <Logio> though 40min compiles are nothing new, the problem was that any change in pandocs dependencies triggers it again
03:11:54 <gentauro> "the north members"
03:12:19 <Logio> yeah, done that too :P 
03:12:23 <gentauro> (and so did Open Office) :'(
03:13:25 <Logio> right now I'm debating whether I actually need a web browser compiled, both firefox and chromium take 3+ hours to compile (at least if you include rust in the time for firefox)
03:14:07 <hc> have you tried nixos? it is like gentoo, but with a binary code cache :)
03:14:24 <gentauro> Logio: one of my friends who prepare old laptops for people in Africa and Asia, is very mad at FF cos they now require mandatory installation of `Node.js/npm` to build FF
03:14:26 <Logio> thought about it, haven't gotten round to it
03:15:15 <gentauro> hc: that days I left Gentoo (package manager I use was Paludis) nix was a package manager that we were begin to look at (cos of the FP nature)
03:15:45 <gentauro> but I thought to myself that I could probably use my CPU cycles in something more useful than "compiling" binaries
03:15:55 <gentauro> now, I just use the cycles for `memes` :D
03:22:53 <Logio> I live in the north, so the extra entropy generation from the compilation is useful
03:24:54 <fen> :t foldr (:) []
03:24:55 <lambdabot> Foldable t => t a -> [a]
03:25:41 <Taneb> :t foldr (\a b -> pure a <|> b) empty
03:25:42 <lambdabot> (Alternative f, Foldable t) => t a -> f a
03:25:55 <Taneb> > foldr (\a b -> pure a <|> b) empty (Just "hello") :: [String]
03:25:57 <lambdabot>  ["hello"]
03:26:40 <fen> does that preserve build?
03:26:57 <Taneb> I've got no idea, it's something I was messing around with yesterday that you reminded me of
03:29:08 <dminuoso> Taneb: Mmm, that seems like a silly version of `fold`
03:30:55 <fen> but does fold (:) [] preserve build fold fusion on a list constructed via (a -> b -> b) -> b -> b ?
03:32:46 <fen> :t build
03:32:47 <lambdabot> error:
03:32:47 <lambdabot>     • Variable not in scope: build
03:32:47 <lambdabot>     • Perhaps you meant ‘buildG’ (imported from Data.Graph)
03:32:53 <fen> % :t build
03:32:53 <yahb> fen: (forall b. (a -> b -> b) -> b -> b) -> [a]
03:33:21 <fen> % let hyloList f q c n = go q where go q = (\(x,q') -> maybe (x `c` n) ((x `c`) . go) q') (f q)
03:33:22 <yahb> fen: 
03:33:50 <fen> % let loop f s = build (hyloList f s)
03:33:50 <yahb> fen: 
03:33:57 <fen> % :t loop
03:33:57 <yahb> fen: (p -> (a, Maybe p)) -> p -> [a]
03:34:10 <fen> % :t unfold
03:34:11 <yahb> fen: Corecursive t => (a -> Base t a) -> a -> t
03:34:15 <fen> % :t unfoldr
03:34:16 <yahb> fen: (b -> Maybe (a, b)) -> b -> [a]
03:34:22 <fen> % :t loop unfoldr
03:34:23 <yahb> fen: ; <interactive>:1:6: error:; * Couldn't match type `b -> [a]' with `(a1, Maybe (b -> Maybe (a, b)))'; Expected type: (b -> Maybe (a, b)) -> (a1, Maybe (b -> Maybe (a, b))); Actual type: (b -> Maybe (a, b)) -> b -> [a]; * Probable cause: `unfoldr' is applied to too few arguments; In the first argument of `loop', namely `unfoldr'; In the expression: loop unfoldr
03:34:39 <fen> brarg
03:38:50 <gentauro> hmmm it took around 20 - 25 minutes to build pandoc from GitHub source code ...
03:41:28 * hackage netlib-comfort-array 0.0 - Helper modules for comfort-array wrappers to BLAS and LAPACK  http://hackage.haskell.org/package/netlib-comfort-array-0.0 (HenningThielemann)
03:41:31 <fen> ok;
03:41:33 <fen> % let hyloList f q c n = go q where go q = maybe n (\(x,q') -> x `c` go q') (f q)
03:41:33 <yahb> fen: 
03:41:44 <fen> % let loop f s = build (hyloList f s)
03:41:44 <yahb> fen: 
03:41:56 <fen> % :t uncons
03:41:56 <yahb> fen: [a] -> Maybe (a, [a])
03:42:05 <fen> % :t loop uncons
03:42:05 <yahb> fen: [a] -> [a]
03:43:28 * hackage blas-comfort-array 0.0 - Auto-generated interface to Fortran BLAS via comfort-array  http://hackage.haskell.org/package/blas-comfort-array-0.0 (HenningThielemann)
03:43:30 * hackage hsyslog 5.0.2 - FFI interface to syslog(3) from POSIX.1-2001  http://hackage.haskell.org/package/hsyslog-5.0.2 (PeterSimons)
03:45:03 <fen> % :t \f -> loop (fmap (\(x,xs) -> (f x,xs)) . uncons)
03:45:04 <yahb> fen: (t -> a) -> [t] -> [a]
03:45:07 <fen> thats fmap
03:47:32 <merijn> What's the best way to send contributions to people using darcs? Just diffs?
03:49:27 <__monty__> I assume that's a hypothetical? : >
03:49:36 <merijn> No?
03:50:27 <__monty__> Was just a bad joke, nvm. I assume patches though, yes. Since its theory is based around them.
03:50:57 * hackage lapack-comfort-array 0.0 - Auto-generated interface to Fortran LAPACK via comfort-array  http://hackage.haskell.org/package/lapack-comfort-array-0.0 (HenningThielemann)
03:51:57 * hackage postmaster 0.3.3 - Postmaster ESMTP Server  http://hackage.haskell.org/package/postmaster-0.3.3 (PeterSimons)
03:55:36 <fen> traverse is;
03:55:37 <fen> % let hyloList' app f q c n = go q where go q = maybe n (\(x,q') -> c <$> app x <*> go q') (f q)
03:55:37 <yahb> fen: 
03:55:49 <fen> % let build' g = g (:) (pure [])
03:55:49 <yahb> fen: 
03:55:58 <fen> % :t \app -> loop' app uncons
03:55:58 <yahb> fen: Applicative f => (t1 -> f a2) -> [t1] -> f [a2]
03:56:03 <Taneb> :t ala Alt foldMap
03:56:05 <lambdabot> forall k2 (t :: * -> *) (g :: k2 -> *) (b :: k2). (Monoid (Alt g b), Foldable t) => t (g b) -> g b
03:56:28 <fen> whats that?
03:56:32 <Taneb> :t ala (Alt . pure) foldMap
03:56:33 <lambdabot> error:
03:56:33 <lambdabot>     • Occurs check: cannot construct the infinite type: b ~ g b
03:56:34 <lambdabot>       Expected type: Unwrapped (Alt g b) -> Alt g b
03:56:38 <Taneb> Irrelevant
03:56:43 <fen> ...
03:56:55 <fen> ok, so the traverse above *preserves fusion*
03:57:10 <fen> as its written in terms of build
03:57:28 <fen> well almost, needs a new fusion rule for the applicative case
03:58:38 <fen> right?
04:02:23 <fen> so then if foldMap = foldMapDefault, foldr (:) [] should also preserve fusion?
04:04:01 <fen> allowing containers to be coverted via foldr (cons) empty, for their respective constructor and basecase, with the deconstructor appearing in the traverse instance (along with the old constructor and basecase)
04:09:45 <merijn> hmmm
04:10:01 <merijn> I don't understand "line" in Data.Conduit.Combinators, I think...
04:10:13 <merijn> It seems to only ever feed in one line, rather than repeatedly?
04:11:11 <merijn> Ah, lookes like I need linesUnbounded instead
04:13:47 <fen> or is it like, if the original container was constructed using build (like hyloList above), then folding over it with new constructors *does* preserve fusion, because fusion essentially just changes the (:) and [] in the definition of build, so that the new container is also then defined using build
04:14:54 <fen> makes more sense that way, so that converting a container (created using build) to another container using fold does preserve build fold fusion
04:15:24 <inkbottle> :hoogle "(a,b) -> (a -> b -> c) -> c"
04:15:38 <Taneb> :t flip uncurry
04:15:40 <lambdabot> (a, b) -> (a -> b -> c) -> c
04:15:48 <inkbottle> thanks
04:18:25 <fen> ah ok, thats the point. so if fold preserves build/fold fusion, does traverse
04:18:44 <fen> and if not, then shouldnt traverse be defined using fold
04:18:51 <fen> so that it does
04:19:04 <fen> ?
04:23:05 <dminuoso> % :t build
04:23:05 <yahb> dminuoso: ((a1 -> [a1] -> [a1]) -> [a2] -> t) -> t
04:23:18 <fen> note that to define the version of build for the particular container, its constructor, deconstructor and basecase are needed
04:23:26 <dminuoso> Did you redefine this binding?
04:23:45 <fen> maybe, sry
04:23:57 <fen> http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#build
04:24:17 <fen> build   :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
04:25:24 <dminuoso> This looks like a conversion from a church encoding to a cons representation.
04:26:14 <fen> is the church encoding the thing returned by hyloList?
04:26:20 <fen> % :t hyloList
04:26:20 <yahb> fen: (t1 -> Maybe (t2, t1)) -> t1 -> (t2 -> t3 -> t3) -> t3 -> t3
04:26:25 <inkbottle> :t let {foo = undefined :: a -> b -> c; bar = undefined :: IO (b, a)} in (uncurry (flip foo)) <$> bar -- was expecting 'IO c'
04:26:26 <lambdabot> IO b
04:26:37 <inkbottle> how comes?
04:27:23 <fen> :t flip (undefined :: a -> b -> c)
04:27:24 <lambdabot> b -> a -> c
04:27:27 <fen> hmm
04:28:00 <fen> :t uncurry $ flip (undefined :: a -> b -> c)
04:28:01 <lambdabot> (b, a) -> c
04:28:21 <inkbottle> so far so good
04:28:48 <inkbottle> and nothing here produces a 'b'
04:28:55 <fen> :t fmap (undefined :: (b, a) -> c) (undefined :: IO (b,a))
04:28:57 <lambdabot> IO b
04:29:00 <fen> !?
04:29:21 <hpc> :t fmap (undefined :: a -> b) (undefined :: IO a)
04:29:22 <lambdabot> IO b
04:29:29 * hpc 's mind boggles
04:29:48 <dminuoso> % type ChurchList t u = (t -> u -> u) -> u -> u
04:29:48 <yahb> dminuoso: 
04:29:52 <fen> % :t fmap (undefined :: (b, a) -> c) (undefined :: IO (b,a))
04:29:52 <yahb> fen: IO b
04:29:56 <Ariakenom> % :t fmap (undefined :: (b, a) -> c) (undefined :: IO (b,a))
04:29:56 <yahb> Ariakenom: IO b
04:30:01 <fen> lol
04:30:11 <dminuoso> % let someList = \c -> \n -> c 1 (c 2 (c 3 n))
04:30:11 <yahb> dminuoso: 
04:30:23 <Ariakenom> I'd guess it's a scoping thing
04:31:01 <dminuoso> No wait, this is Scott'
04:31:03 <dminuoso> No wait, this is Scott's encoding.
04:31:12 <fen> oh
04:31:20 <inkbottle> ?
04:31:22 <Ariakenom> b isn't a thing, instead b is anything. c is also anything. Take either.
04:31:56 <hpc> ah, that would make sense
04:31:57 <inkbottle> :t fmap (undefined :: (b, a) -> Int) (undefined :: IO (b,a))
04:31:58 <lambdabot> IO Int
04:32:02 <dminuoso> fen: This makes sense in a lot of ways, since `foldr` is the tool to replace `(:)` with some `c` and `[]` with some `n`
04:32:03 <fen> % :t fmap (undefined :: (y, a) -> c) (undefined :: IO (x,a))
04:32:03 <yahb> fen: IO b
04:32:07 <dminuoso> This is so cool. =)
04:32:10 <hpc> :t fmap (undefined :: a -> b) (undefined :: IO totallyOtherType)
04:32:12 <lambdabot> IO b
04:32:13 <hpc> yep
04:32:35 <inkbottle> So, it's fixed :)
04:32:42 <fen> seems so
04:32:49 <hpc> :t fix fmap
04:32:50 <lambdabot> error:
04:32:50 <lambdabot>     • Occurs check: cannot construct the infinite type: b ~ f b
04:32:50 <lambdabot>       Expected type: (f a -> f b) -> f a -> f b
04:32:53 <hpc> oh no!
04:33:02 <fen> dminuoso, still not sure about the traverse version though
04:33:10 <inkbottle> dminuoso: thanks for the insight
04:33:41 <dminuoso> fen: what traverse version?
04:33:59 <dminuoso> inkbottle: Glad I could help without even knowing what your problem was!
04:34:10 <fen> % :t \app -> loop' app uncons
04:34:11 <yahb> fen: Applicative f => (t1 -> f a2) -> [t1] -> f [a2]
04:34:15 <fen> above at 11:55
04:34:36 <dminuoso> % :t loop'
04:34:37 <yahb> dminuoso: Applicative f => (t1 -> f a2) -> (t2 -> Maybe (t1, t2)) -> t2 -> f [a2]
04:34:58 <fen> loop f s = build (hyloList f s)
04:35:06 <fen> hyloList f q c n = go q where go q = (\(x,q') -> maybe (x `c` n) ((x `c`) . go) q') (f q)
04:35:38 <fen> oops
04:35:42 <fen> hyloList' app f q c n = go q where go q = maybe n (\(x,q') -> c <$> app x <*> go q') (f q)
04:36:28 <fen> loop' app f s = build' (hyloList' app f s)
04:36:37 <fen> build' g = g (:) (pure [])
04:36:59 <dminuoso> I dont even pretend to understand recursion schemes.
04:37:27 <dminuoso> hylo alg coalg = ana coalg >>> cata alg
04:38:08 <fen> well its like, traverse is implemented using a recursion, which is the same pattern fold abstracts, and the fold version fuses with build, so traverse should be written using fold, and the respective constructors
04:38:31 <fen> (the (:) pattern and [] but for the respective container)
04:40:21 <fen> dminuoso: not sure why it was called hylo in the wiki... cant find the page now
04:41:11 <dminuoso> fen: well I understand it on an abstract level
04:41:12 <fen> anyway, does this seem right? that traverse should use fold and the equivalents of (:) and [] ?
04:41:33 <fen> in order to preserve build fold fusion when traversing
04:41:42 <dminuoso> apparently: hyloList h g = cataList h . anaList g
04:42:15 <fen> what are those defined as?
04:43:36 <dminuoso> https://github.com/OctavioMaia/CalculoProgramas/blob/master/List.hs
04:44:27 <merijn> Anyone here use prettyprinter/prettyprinter-ansi-terminal ?
04:44:39 <merijn> renderStrict seems to discard my colour info
04:49:11 <fen> in which case, wouldnt it make more sense for the Traverse just to be defined in terms of get set and empty?
04:49:47 <fen> then the traverse function has a fixed implementation in terms of fold
04:50:38 <fen> not sure the compiler can fathom that the recursion normally used to define traverse is the same as fold and hence preserve fusion
04:51:21 <fen> or is this a special case of traverse? like, not all traversable things follow this fold using constructors pattern
05:36:32 <cocreature> merijn: are you sure you are using the correct renderStrict, i.e. the one from *-ansi-terminal and not the one from prettyprinter itself?
05:36:51 <cocreature> merijn: I’ve used that literally today and it hasn’t discarded my color info :)
05:37:04 <merijn> cocreature: Yes, turns out layoutCompact strips my annotations somehow...
05:37:22 <merijn> cocreature: Because if I use layoutPretty instead, it works
05:38:44 <cocreature> huh weird
05:39:37 <cocreature> merijn: looking at the code it just seems to throw away all annotations …
05:39:57 <cocreature> seems like if that’s intended, it should have a different type and point this out in the docs
05:39:58 <merijn> cocreature: Which seems...different from what the docs describe
05:45:05 <asheshambasta> What can be a testing workflow? I'm not sure if I can work on this project without fixing this problem: I do `stack ghci --no-build --no-load <name>`, but as soon as I do `:l Main`, I max out my memory 
05:45:52 <asheshambasta> Basically, its impossible to work on my project 
05:46:28 <cocreature> asheshambasta: how much memory do you have?
05:46:33 <asheshambasta> 16GB 
05:47:01 <asheshambasta> Basically, compiling _anything_ in this project is taking several GB
05:47:03 <cocreature> unless you have some giant project that should more than sufficient to load your project in ghci
05:47:15 <merijn> That seems...odd
05:47:25 <merijn> Where are you getting your memory usage from?
05:47:56 <cocreature> I guess if you throw all kinds of type-level crap at GHC it will also use a ton of memory so don’t do that :)
05:48:10 <Saizan> also if you have ~300 or so modules
05:48:24 <asheshambasta> Well, this is a large project, but its just about 
05:48:29 <asheshambasta> 60 modules 
05:48:50 <cocreature> I have 282 modules loaded in ghci atm and memory usage is around 4gb
05:49:07 <merijn> asheshambasta: Where are you getting your memory usage info from?
05:49:18 <asheshambasta> xmobar + htop 
05:49:18 <cocreature> but ofc the number of modules is also a pretty bad metric :)
05:49:36 <merijn> asheshambasta: top and htop are notoriously bad places to get your memory info from
05:50:02 <merijn> virtual memory is complicated and top simplifies the numbers to the point of making no sense unless you know what you're looking at/for
05:50:27 <cocreature> dunno, resident memory in htop has been a pretty useful metric ime
05:50:50 <merijn> cocreature: Yeah, but is he looking at resident memory or something else? :)
05:51:24 <asheshambasta> yeah I'm not sure what this is, I am using type-level stuff
05:51:44 <asheshambasta> but it doesn't really make sense for ghci to consume 6GB of memory at all 
05:51:51 <asheshambasta> unless there's a lkeak 
05:51:54 <asheshambasta> leak* 
05:52:22 <cocreature> 6GB doesn’t seem that uncommon (whether it is reasonable is a separate question :)) if you’re doing fancy type-level things
05:53:14 <asheshambasta> then the only way I can fix this is by buying more memory or staying away from type-level stuff
05:53:54 <merijn> Depends on how fancy the type-level stuff is :p
05:54:14 <cocreature> if you have 16gb, 6gb seems doable. you just need to stop slack from taking up 10gb :)
05:54:29 <asheshambasta> Lets say I'm using something like Squeal + Servant 
05:54:44 <asheshambasta> I  don't really think I'm doing type-level stuff to that fancy extreme. 
05:54:54 <asheshambasta> cocreature: I stay away from Slack :-) 
05:57:57 <cocreature> is this a new development? or did you get your project to the point where it’s using 6gb of memory in ghci without ever trying to use ghci before? That would be kind of impressive :)
05:57:58 * hackage static-text 0.2.0.4 - Lists, Texts, ByteStrings and Vectors of statically known length  http://hackage.haskell.org/package/static-text-0.2.0.4 (DmitryDzhus)
05:58:10 <Saizan> asheshambasta: compiling stuff works better for me, tbh
05:58:35 <asheshambasta> Saizan: you still need _some_ interaction on ghci no? 
05:58:59 <Saizan> you can load compiled modules, and that's going to use less memory
05:59:35 <asheshambasta> using `:set -fobject-code`? 
05:59:48 <asheshambasta> I've tried doing that, and it makes little-no difference
06:00:03 <Saizan> i wonder if stack is messing with that
06:00:30 <cocreature> if you run it from within ghci before you load things, it should work fine regardless of how ghci is launched
06:00:31 <Saizan> --ghc-options=-fobject-code is working well for me with "cabal repl"
06:01:22 <cocreature> but if your problem is memory usage during type checking I doubt -fobject-code is going to make a difference
06:02:22 <asheshambasta> hm yeah, well, it doesn't make any difference 
06:02:30 <asheshambasta> 93% RAM and climbing 
06:03:08 <merijn> Saizan: That's deprecated, use --repl-options in the future
06:03:14 <Saizan> do you have the same problem when compiling?
06:03:58 <merijn> Saizan: Because specifying ghci options via --ghc-options does not work* in new-repl
06:04:11 <merijn> * - well, it might, but -fobject-code definitely won't
06:29:28 * hackage dynamic-graphs 0.1.0.3 - Dynamic graph algorithms  http://hackage.haskell.org/package/dynamic-graphs-0.1.0.3 (JasperVanDerJeugt)
06:40:10 <merijn> Anyone know any faster ways of turning ASCII/latin-1 [Word8] into Text then "T.decodeUtf8 . BS.pack"?
06:43:45 <merijn> hmm, maybe "T.pack . map unsafeChr8"
06:44:19 <tdammers> merijn: one of these maybe? https://hackage.haskell.org/package/text-1.2.3.1/docs/Data-Text-Encoding.html
06:45:00 <tdammers> (idk, decodeLatin1 maybe)
06:45:25 <tdammers> oh wait, [Word8] actually
06:46:14 <byorgey> merijn: const T.empty is pretty fast
06:46:35 <merijn> byorgey: ಠ_ಠ
06:50:51 <Jetien> Is it possible to see the automatically derived type of value inside a let expression?
06:52:07 <merijn> Jetien: You mean "of a value"?
06:52:25 <merijn> And what do you mean by derived? Inferred?
06:52:32 <Jetien> merijn: yes, i think i meant in general the type of any expression that is not top-level
06:52:42 <Jetien> merijn: sorry, yes, inferred
06:53:19 <merijn> Jetien: Well, one of the simplest (but hacky) solutions would be to just annotate the binding with ":: ()" and wait for GHC to yell at you ;)
06:53:46 <Jetien> merijn: good enough ;)
06:54:10 <merijn> In fact, that works for anything, regardless of whether it's a binding or value :p
06:54:29 <merijn> Jetien: Alternatively, if you want to know what kinda expression to fill in you can use typed holdes
06:54:33 <merijn> > even _
06:54:35 <lambdabot>  error:
06:54:35 <lambdabot>      • Found hole: _ :: Integer
06:54:35 <lambdabot>      • In the first argument of ‘even’, namely ‘_’
06:55:04 <merijn> Jetien: Any identifier starting with _ that is not in scope is considered a "hole" and GHC will continue to compile and then report the types of all holes it found
06:55:43 <merijn> Jetien: There's also -fdefer-typed-holes which turns the error into a warning and throws an exception at runtime so you can execute code without having implemented all the holes (assuming you don't try to use one of the holes :p)
06:55:57 <Jetien> merijn: thanks
07:00:21 <Jetien> I'm having trouble writing a generic typeclass that uses Proxy. https://gist.github.com/smatting/92c086a2c78f38e719627dc7e4b677a0 - I'm especially puzzled because i can't seem to annotate (understand) the type of "f"
07:01:57 <bryan1_> does f :: proxy a -> [Int] work?
07:02:11 <merijn> Jetien: the proxy variable there has type "Proxy (D1 c f p)"
07:02:29 <Jetien> bryan1_: no, Couldn't match type ‘proxy’ with ‘Proxy’
07:02:49 <merijn> I'm kinda confused what the binding of f does there
07:03:14 <Jetien> merijn: how did you figure out the correct type? I used your "incorrec type annotation trick" but i got "Proxy (t0 p0) -> [Int]"
07:03:45 <Jetien> merijn: "f" is just for me to understand the types better
07:04:43 <merijn> Jetien: If you look at your class definition you see "Proxy (t p) -> [Int]"
07:04:59 <merijn> Jetien: the 't' there is *the type your defining the instance for*
07:05:31 <merijn> Jetien: You're defining an instance for "D1 c f", therefore I just filled "D1 c f" in the type from the class
07:09:01 <pavonia> Is the type variable f in the local binding even the same as in the instance signature?
07:09:21 <Jetien> merijn: I've updated the gist. Would the type of "f" now be "Proxy (a p) -> [Int]" (as per EnumCons' a in the condition)?
07:09:22 <osa1> do we have a channel for gtk2hs user/dev discussions?
07:09:52 <Jetien> pavonia: I've renamed the type variables in the gist to avoid confusion
07:10:10 <pavonia> I see
07:10:18 <dmwit> Jetien: If you turn on ScopedTypeVariables, then you can write `f :: Proxy (t p) -> [Int]`.
07:10:28 <dmwit> Jetien: N.B. you have written an infinite loop here.
07:11:01 <dmwit> Jetien: You *probably* want `f :: Proxy p -> [Int]` and `in f Proxy` instead of what you have here.
07:11:10 <dmwit> Jetien: Sorry. Correction.
07:11:26 <dmwit> Jetien: If you turn on ScopedTypeVariables, then you can write `f :: Proxy (D1 c a) -> [Int]`.
07:11:36 <Jetien> dmwit: I want to get enumCons' i get from the condition (EnumCons' a)
07:11:54 <Jetien> and use that inside of the definition of (EnumCons' (D1 c a))
07:11:55 <pavonia> osa1: There's #gtk2hs but it hasn't ever been really active
07:12:08 <dmwit> Jetien: You *probably* want `f :: Proxy (c a) -> [Int]` and `in f Proxy` instead of what you have here.
07:12:34 <dmwit> Or, sure, `f :: Proxy (a p) -> [Int]` if that's what you intended.
07:12:37 <osa1> pavonia: any mailing lists? forums?
07:12:54 <pavonia> There's a mailing list, yes
07:14:12 <Jetien> dmwit: exactly. but if i type-annotate "f" this way I get a compiler error at line 24:  Couldn't match type ‘a’ with ‘M1 D c a’ .. Mmmh...
07:14:31 <osa1> pavonia: the sourceforge one or is there another mailing list?
07:14:33 <dmwit> Jetien: Why does this class mention `p` at all? Why not `class EnumCons' t where enumCons' :: Proxy t -> [Int]`, or, for that matter, `class EnumCons' t where enumCons' :: Tagged t [Int]` or even `class EnumCons' t where enumCons' :: [Int]`?
07:14:54 <dmwit> Jetien: Have you turned on ScopedTypeVariables as I said?
07:15:15 <pavonia> osa1: That's the one I meant, seems to be pretty dead as well, though :S
07:15:36 <Jetien> dmwit: Because "p" is needed If i want to use generic programming. I'm following the tutorial at Couldn't match type ‘a’ with ‘M1 D c a’
07:15:45 <Jetien> dmwit: tutorial at http://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-Generics.html#t:M1
07:15:56 <Jetien> dmwit: yes
07:16:37 <Jetien> dmwit: i think "proxy" has an incorrect type for "f" - i think i understand now where the problem is
07:16:51 <dmwit> Jetien: Yes. Read my suggestion again very carefully.
07:17:13 <dmwit> Jetien: "...and `in f Proxy` instead of what you have here"
07:17:37 <dmwit> It compiles for me if I make the three suggested changes.
07:17:50 <dmwit> (ScopedTypeVariables, `f :: Proxy (a p) -> [Int]`, `in f Proxy`)
07:18:18 <Jetien> dmwit: ah, i missed `in f Proxy` :) sorry
07:18:23 <dmwit> I think you may have mislinked your tutorial, by the way.
07:18:30 <asheshambasta> So, I may have found a way to work around the memory issues; 
07:18:37 <Jetien> dmwit: thank you
07:19:07 <dmwit> I am still skeptical of this `p` business. =P
07:19:19 <asheshambasta> I start stack with `--no-build --no-load` and then set `-fobject-code` within GHCI 
07:19:19 <Jetien> dmwit: yes, anchor is incorrect. The tutorial is at the beginning of the docs for GHC.Generics
07:19:21 <dmwit> (And, for that matter, this `Proxy` instead of `proxy` business!)
07:20:32 <Jetien> dmwit: haha :) the `p` business is all over the place in GHC.Generics . At least I got it working for other generic stuff. Just this Proxy stuff was puzzling me
07:21:14 <dmwit> Mmmm... perhaps you misunderstood my complaint.
07:21:34 <dmwit> I am skeptical of using `Proxy (t p)` in the method type signature instead of `Proxy t`.
07:21:46 <Jetien> dmwit: don't i need a `p` type variable in the end to make to write the instances for (M1 ..) ?
07:22:25 <Jetien> dmwit: ah :) well i'm just going by trial-and-error here ;)
07:23:19 <dmwit> Jetien: Why? Why can't you just dispatch to the underlying `f` instance?
07:24:34 <dmwit> instance EnumCons' f => EnumCons' (M1 i c f) where enumCons' _ = enumCons' @f Proxy
07:25:12 <Jetien> dmwit: I'll give that a try. I just started learning about GHC.Generics yesterday. I got some stuff working but I don't really understand most of it
07:25:43 <dmwit> While you're at it, switch Proxy to proxy. ;-)
07:25:58 <dmwit> `class EnumCons' t where enumCons' :: proxy t -> [Int]`
07:26:27 <Jetien> dmwit: k
07:27:01 <dmwit> Then you'll be caught up with the state of the art from 2.5 years ago. =P
07:27:50 <Jetien> dmwit: *sigh* :) as long as it solve my realworld problem i can live with that ;)
07:39:20 <Jetien> dmwit: FYI: if i drop the "p" i can't seem to make the instance for (M1 i c f) work. "Expecting one more argument to ‘M1 i c f’". I've updated the gist in case you're still interested
07:41:46 <glguy> Jetien: in your original 
07:42:37 <glguy> Jetien: in the paste  saw, you could have used a kind signature
07:43:09 <dmwit> Jetien: Ah, yes, you need to turn on PolyKinds.
07:43:11 <glguy> Rather than adding a p argument
07:43:30 <dmwit> Jetien: (Alternately, turn on KindSignatures and write `class EnumCons' (t :: * -> *)` or similar.)
07:43:40 <dmwit> Jetien: This is my fault, I should have predicted this problem.
07:45:03 <Jetien> Where can I learn about this kind of type programming? I feel I'm not getting anywhere if can't understand kinds, type level programming, etc
07:45:55 <dmwit> Well, this is a pretty silly thing. Akin to the monomorphism restriction at the term level, I'd say, not a fundamental fact about type systems.
07:46:28 <dmwit> GHC has a kind inference system, like its type inference system, and if it doesn't have enough info to infer a specific kind, it chooses *
07:46:40 <dmwit> ...for no good reason, really.
07:46:45 <dmwit> It's just a fact you have to know about GHC.
07:47:41 <dmwit> So what's happened here is that it's decided the `t` in `class EnumCons' t` could be anything -- and then afterwards chosen specifically to demand that it be only concrete types (of kind *, I mean).
07:49:25 <Jetien> dmwit: but i need it to be of kind * -> *, right? because the stuff in GHC.Generics needs it to be like this, correct?
07:49:37 <dmwit> (It makes this decision as soon as it's done "processing" the `class` declaration and before it starts "processing" the `instance` declaration.)
07:49:57 <dmwit> Jetien: Right. Or a more polymorphic type that can be specialized to * -> * would be fine, too.
08:03:11 <glguy> In this case of using GHC.Generics the * -> * specific class works well becuase it's the only kind you'll neeed, so you'll get kind errors if you make a mistake instead of missing instance errors
08:07:27 <Jetien> glguy: ok
08:07:38 <liquid_pascal> Question, could someone explain/point me to understanding what higher kinded types are?
08:10:45 <merijn> liquid_pascal: "Generics that take generics as arguments"
08:11:09 <liquid_pascal> So what does that let me accomplish that normal generics don't?
08:11:31 <liquid_pascal> (also, thanks)
08:11:34 <merijn> liquid_pascal: Values have a type with kind *. So "Maybe :: * -> *" is a regular generic, right? It takes a type and produces a new type
08:11:44 <liquid_pascal> Yup
08:11:47 <merijn> liquid_pascal: A higher kinded type is one that takes arguments with kinds other than *
08:12:24 <merijn> liquid_pascal: An example would be something like "data Form f = Form { email :: f String, name :: f String, id :: f Int }" etc.
08:13:00 <merijn> liquid_pascal: And then you can have "Form Maybe" as result from a webform (some fields might be missing) and convert it into, say "Form Identity" after validation
08:13:06 <Ariakenom> :t fmap
08:13:08 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:13:28 <bsima> liquid_pascal: this explanation helped me understand https://stackoverflow.com/a/6246833/1146898
08:13:33 <merijn> liquid_pascal: With regular generics you can't pass an unapplied generic type (like a container) as argument to something else
08:13:50 <liquid_pascal> So it's kind of like partially applied functions but for types?
08:14:14 <merijn> liquid_pascal: Kinda, I guess?
08:14:27 <Ariakenom> maybe it's like higher order functions for types
08:15:03 <Denommus> hey
08:15:24 <Ariakenom> (value -> value) vs (value->value)->value. type->type vs (type->type)->type.
08:15:31 <Denommus> how do I check if a value of a sum type is of multiple specific variants using lenses?
08:15:40 <liquid_pascal> bsima: That links helps. Thanks everyone
08:15:56 <Denommus> for instance, if I have data Foo = Foo | Bar Bool | Baz Int, how do I check if a value :: Foo is either Foo or Bar?
08:16:55 <lyxia> Denommus: if you have prisms _Foo and _Bar,  \x -> is _Foo x || is _Bar x   perhaps?
08:17:51 <Denommus> lyxia: where is `is` defined?
08:17:57 <lyxia> https://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-Extras.html#v:is
08:20:30 <Denommus> that helps
08:21:53 <glguy> has works too, and is in the normal module
08:23:21 <Denommus> and if it's nested I could just use over, right?
08:25:54 <lyxia> I'm not sure I understand, over does something quite unrelated
08:28:58 <Denommus> yeah, I'm mistaken
08:30:36 <Denommus> lyxia: what I mean is if I have it under a Map, I would have to do `has (ix "foo" . _Foo) value || has (ix "foo" . _Bar) value`, is there a shortcut?
08:31:40 <Denommus> any (\x -> has (ix "foo" . x) value) [_Foo, _Bar] could work, I guess?
08:33:07 <dmwit> not . has (ix "foo" . _Bar) -- ;-)
08:33:23 <JonReed> Hi guys, how do I convert unit `()` to `Void`? How to construct Void? If I try to use `import Data.Void (Void); let t = Void` it says that data constructor is not in scope
08:33:26 <Jetien> I have another generic programming question: I've read the tutorial from the docs for GHC.Generics. In the example two classes Encode' and Encode are defined. Then there is a default implementaion "encode x = encode' (from x)". In my use case however i don't have value "x", because my the function from my class just has a proxy type hint: "enumCons' :: proxy t -> [Int]". How can I then write a EnumCons class that makes use of EnumClass for generic types?
08:33:38 <Denommus> dmwit: heh, but the type in question could have any number of variants
08:33:57 <dmwit> For efficiency, I would want to view (or whatever the analog for prisms is) `ix "foo"` first, then do the `is _Foo || is _Bar` check.
08:34:10 <dmwit> This way you do the "foo" lookup just once.
08:34:48 <dmwit> JonReed: You cannot construct a Void. That's the whole point of the type.
08:35:20 <dmwit> JonReed: If you share what led you to believe that constructing a Void would be a good goal, we might be able to say more about where you've gone wrong. =)
08:36:39 <Jetien> my use case: https://gist.github.com/smatting/92c086a2c78f38e719627dc7e4b677a0
08:37:25 <JonReed> dmwit: I have a `ConduitT () () m ()`, but `runConduit` expects `ConduitT () Void m ()`, so I need to convert my conduit to something I can use `runConduit` on.
08:37:26 <Jetien> JonReed: Void is the type that doesn't have a value
08:38:16 <dmwit> Jetien: Presumably you'd pass in a `Proxy` with the appropriate `Rep` type "inside".
08:38:53 <dmwit> JonReed: You will need to connect your conduit to a suitable sink, then.
08:39:29 <Jetien> dmwit: thanks, again. "enumCons _ = enumCons' @(Rep a) Proxy" worked
08:41:20 <dmwit> JonReed: e.g. sink{List,Vector} might interest you
08:41:31 <dmwit> There's also sinkNull if you really don't care about the output.
08:43:18 <dmwit> The blind leading the blind on that one. One of these days I should really dig into Generics enough to understand them.
08:44:48 <MiniCow> Anybody able to help me decode this profile snippet? I’m confused how the bottom two functions consume time and memory, but have zero entries. https://gist.github.com/WeeBull/29e49b359fdce74ff9bb4ce11a3ceaa1
08:45:00 <MiniCow> What’s it telling me?
08:45:50 <JonReed> dmwit: Thanks. sinkNull was the one that I was looking for
09:14:36 <asheshambasta> Anyway, scratch that. It looks like there's one module with a lot of typelevel stuff that is causing a space-leak somehow during compilation. 
09:15:01 <asheshambasta> No matter what I've tried so far, I've not been able to fix this. 
09:19:21 <wroathe> sudo rm -rf / and start again
09:22:23 <asheshambasta> wroathe: sounds tempting. 
09:31:19 <WilliamHamilton[> phadej: I have some questions on unification like it's done in the Dijstra paper of `Efficient Functional Substitution and Unification`: if one eliminates the occur check from the unification process and only keeps it when applying substitutions, which api should one offer to the user? Should one always do unifications before presenting an answer to the user?
09:36:17 <dminuoso> JonReed: One way of thinking about Void is that Void is the type of bottom.
09:36:45 <dminuoso> That is, Void is inhabitated by only bottom.
09:36:50 <NoidedSuper> Could anybody possibly look over some changes I made to the `lens` package's documentation? I basically added some examples that would've helped my understanding when I was first learning the library, but I'm still kinda a beginner and I want to make sure said examples actually make sense
09:37:03 <NoidedSuper> The changes are here if anyone is interested: https://github.com/ekmett/lens/compare/master...AnthonySuper:big-docs
09:38:16 <NoidedSuper> https://github.com/AnthonySuper/lens/pull/1 <- here's a version that's a PR with comments enabled actually
09:41:27 * hackage typed-admin 0.1.0.0 - Admin console framework  http://hackage.haskell.org/package/typed-admin-0.1.0.0 (nakaji_dayo)
09:41:57 <c50a326> are monads and/or arrows covered in the lambda calculus and/or combinatory logic?
09:42:17 <bsima> not in lambda calculus
09:42:23 <c50a326> is bind a combinator?
09:42:31 <bsima> i think not in combinatory logic
09:42:36 <bsima> bind comes from category theory afaik
09:43:08 <dmj`> combinator can be used as a general term for a function that takes two higher order functions and returns a new function 
09:43:35 <dminuoso> \a -> a
09:43:37 <dminuoso> Is a combinator too.
09:43:56 <bsima> it seems there's no 'bind' in category theory, it's just a functional programming thing
09:44:07 <dmj`> there is join in category theory iirc
09:44:17 <c50a326> hmm it says in this talk https://www.youtube.com/watch?v=3VQ382QG-y4 that a combinator is a function (an abstraction I guess) with no free variables
09:44:28 <dminuoso> c50a326: bind is an interface not a concrete function, so the question does not seem to make sense
09:44:42 <dminuoso> c50a326: That's the combinatory logic perspective, yes.
09:44:52 <c_wraith> c50a326, that's the traditional definition. programmers use a different one.
09:45:19 <__monty__> dmj`: I know of combinator as just a function without free variables.
09:45:25 <lyxia> bind occurs when you talk about Kleisli categories.
09:45:27 <tabaqui> How can I directly access argv array?
09:45:37 <tabaqui> I want to rename working process in Linux
09:45:50 <tabaqui> and the only solution I found is to printf into argv[0]
09:45:53 <dmj`> __monty__: would you consider (.) a combinator
09:46:04 <tabaqui> *Hi all :)
09:46:11 <dmj`> for example, the term "combinator" in Monadic Parser Combinators
09:46:46 <dminuoso> I guess there is two very different meanings of the word floating in the Haskell world.
09:46:47 <lyxia> tabaqui: there are functions for that in System.Environment
09:46:48 <dmj`> Refers more to just combining functions rather than anything from combinatory logic
09:47:01 <dminuoso> dmj`: The two do not seem to be related.
09:47:09 <dmj`> dminuoso: yea, its a misnomer
09:47:19 <dmj`> there's quite a few false friends out there
09:47:23 <tabaqui> lyxia: they don't work
09:47:30 <tabaqui> getArgs returns a Haskell list
09:47:56 <tabaqui> and setProgName doesn't change the name really
09:48:30 <lyxia> tabaqui: there is withProgName
09:49:17 <tabaqui> lyxia: yeah, sorry. Well, it doesn't work
09:49:28 <tabaqui> I want to see new name in htop
09:50:13 <lyxia> Is "printf into argv[0]" really the right way to do it even in C
09:50:27 <c50a326> yeah I'm wondering if that actually works also lol
09:50:28 * hackage spectral-clustering 0.2.1.4 - Library for spectral clustering.  http://hackage.haskell.org/package/spectral-clustering-0.2.1.4 (GregorySchwartz)
09:51:05 <tabaqui> https://www.linuxquestions.org/questions/programming-9/change-child-name-c-fork-361989/
09:51:29 <wroathe> AFAIK you can't change the process name from the environment's point of view
09:51:51 <wroathe> From within the process
09:52:16 <tabaqui> wroathe: but bash can do it: "bash -a foo sleep 10"
09:52:22 <tabaqui> *wroathe: but bash can do it: "exec -a foo sleep 10"
09:52:46 <tabaqui> it calls "sleep 10", but ps shows you the string "foo"
09:53:02 <c50a326> exec starts a new process doesn't it?
09:53:02 <wroathe> You're no longer runnning bash at that point
09:53:12 <tabaqui> right
09:53:22 <wroathe> So you haven't changed teh name of the running bash process, just replaced it with a new process
09:53:23 <tabaqui> if you know the other way, it would be fine
09:53:31 <c50a326> tabaqui: fork, I guess
09:53:53 <tabaqui> c50a326: in Linux you have to run fork to create new process and exec to replace old memory and run new program
09:54:46 <tabaqui> wroathe: but how it works? How bash can start new process with arbitary name?
09:55:09 <dminuoso> PR_SET_NAME in prctl.
09:56:02 <wroathe> dminuoso: Huh, TIL
09:56:25 <wroathe> dminuoso: You'll see that update in top or ps then?
09:56:32 <tabaqui> dminuoso: doesn't it set the name of the *thread*?
09:57:15 <dmwit> Nah, you just call the exec syscall with an executable path whose name doesn't match the argv[0] you give to exec.
09:57:25 <wroathe> https://stackoverflow.com/questions/16165667/change-process-name-without-changing-argv0-in-linux
09:58:42 <dminuoso> wroathe: Well it depends on how the tool scrapes information.
09:58:59 <dmwit> Haskell doesn't have a low-enough-level interface to exec to do this.
09:59:10 <dminuoso> I think modifying argv[0] is unsupported *and* you're invoking UB.
09:59:14 <tabaqui> dmwit: it is fine, haskell has ffi
09:59:21 <dmwit> (I just checked the source for the unix package's executeFile. It prepends the program name to the argv you give it. Rude.)
10:02:18 <dmwit> tabaqui: If you just want to know how to do it in C, then here: https://gist.github.com/dmwit/46258e6238112eb049b3c8f2bb7ae378
10:02:29 <wroathe> The other question is, why would you want to do this instead of just naming the executable what you want the name to be?
10:02:33 <tabaqui> "ps -a" displays the new name, while "ps -x" and "htop" do not
10:03:07 <tabaqui> wroathe: I have some server that forks a new thread for each client (there are not many of them)
10:03:31 <tabaqui> and I want to indicate somehow process relate to some client
10:03:37 <tabaqui> *relates
10:03:44 <dmwit> Modifying argv[0] is not UB. It just doesn't do what you want it to do.
10:05:25 <tabaqui> hm, you call exec with some arguments
10:05:46 <tabaqui> is there a way to do it with parent memory? I mean just fork without exec
10:05:52 <wroathe> The problem here is that Haskell's runtime uses green threads
10:05:58 <wroathe> (by default)
10:06:18 <dmwit> I don't think so, no.
10:06:33 <tabaqui> wroathe: threads are nothing to do with
10:06:43 <tabaqui> it is about processes
10:07:08 <wroathe> Oh, so you're not forking new threads, you're forking new processes
10:07:10 <wroathe> Got it
10:07:54 <tabaqui> sorry, guys, it is a question for #archlinux and #gentoo :)
10:10:45 <tabaqui> *the question
10:19:31 <bsima> what's the benefit of using async over forkIO?
10:21:38 <boj> bsima: it has better control mechanisms for stuff like canceling, waiting, and collecting thread results
10:22:28 <bsima> so if I just want to, say, submit a job which writes to db and get () back, then forkIO is better?
10:22:56 <boj> if it is fire and forget, forkIO would make sense i think
10:23:00 <tabaqui> I would say, that asyncronious code usualy has less races, but async is written with haskell threads
10:24:47 <bsima> ok thakns
10:25:00 <bsima> forkIO it is
10:26:09 <dmwit> bsima: Wouldn't you like to at least get Bool back, saying whether it worked or not?
10:26:24 <bsima> yeah but i don't want to wait for that
10:26:27 * hackage monadLib 3.9 - A collection of monad transformers.  http://hackage.haskell.org/package/monadLib-3.9 (IavorDiatchki)
10:26:43 <bsima> i want to return an http response saying we recieved the request
10:27:20 <dmwit> strange
10:27:51 <bsima> i'm working on a data pipeline, the data is more-or-less ephemeral
10:27:55 <dmwit> Why would I, the user, care if you received the request (as opposed to caring if the request made it far enough through your pipeline that it wouldn't be forgotten about ten seconds from now)?
10:28:05 <boj> makes sense for long running jobs
10:28:41 <bsima> i've gotta hit a few other api's, which are very slow (php)
10:29:04 <bsima> so yeah, the job ends up running for a little while
10:29:10 <boj> dmwit: a case would be a database report that takes minutes to generate. your response would go beyond the tcp timeout of a browser, for example, so better to just poll for a result later
10:31:17 <boj> however, you probably want to verify that your request actually went through
11:08:37 <inkbottle> Is there a "general flip solver": (a -> b -> c -> d) -> (b -> c -> a -> d)?
11:11:07 <cocreature> inkbottle: what do you mean by “flip solver”
11:11:54 <lyxia> @djinn (a -> b -> c -> d) -> (b -> c -> a -> d)
11:11:55 <lambdabot> f a b c d = a d b c
11:12:20 <cocreature> @pl f a b c d = a d b c
11:12:21 <lambdabot> f = (flip .) . flip
11:12:35 <cocreature> but please don’t use that :)
11:12:38 <inkbottle> cocreature: I want a function of the above signature, and I believe I can achieve that through flip only
11:12:48 <inkbottle> Yes?
11:12:58 <nbloomf> This blog post shows how: http://nbloomf.blog/posts/arithmetic-made-difficult/Flip.html
11:13:44 <inkbottle> cocreature: you think it's bad practice /)
11:14:45 <lyxia> a lambda is infinitely more readable than a mess of flips.
11:14:49 <cocreature> lyxia++
11:15:25 <inkbottle> OK, OK, will do that ;)
11:17:39 <rain1> how do i make a 2d array of arrays defined based on indexes? like f 2 3 = < < (0,0), (1,0) >, < (0,1), (1,1) >, < (0,2), (1,2) > >
11:17:46 <cocreature> or even better, try to change either the callee or the caller such that you don’t need to change the order of parameterse
11:23:07 <inkbottle> cocreature: working on it...
11:25:13 <leothrix> Is the current state of the art for cross-compiling for armv7 the guides written by zw3rk? I very naively tried changing `arch` in my stack.yaml but I doubt that's sufficient
11:26:12 <inkbottle> cocreature: can you do better with accessor functions? `data A = A Int Char String; (\x y z -> A z x y) <$> (undefined :: IO Char) <*> (undefined :: IO String)`
11:26:15 <cocreature> leothrix: yeah that should be the current state or at least the most recent state that I’ve seen written up. he also hangs around here as angerman so if you get lucky you might be able to catch him here if you have questions
11:26:40 <rain1> How do I install Data.Vector on nixos
11:27:40 <cocreature> inkbottle: do x <- undefined :: IO Char; y <- undefined :: IO String; z <- …; pure $ A z x y
11:28:02 <inkbottle> cocreature: OK, I see
11:28:29 <leothrix> cocreature: gotcha, thanks. I tried compiling natively on an ARM SBC but it's a little much for the board; forunately it's Pi-like (armv7) so hopefully angerman's guides would apply
11:28:32 <cocreature> rain1: are you working on a cabal project or do you just want to get compile a single file/load it in ghci
11:28:57 <rain1> just a single file
11:29:53 <cocreature> rain1: try nix-shell -p "haskellPackages.ghcWithPackages(pkgs: [pkgs.vector])"
11:30:09 <cocreature> that should drop you into a shell where you can invoke ghc/ghci and vector should be in scope
11:33:21 <rain1> thanks
11:50:57 * hackage typograffiti 0.1.0.2 - Just let me draw nice text already  http://hackage.haskell.org/package/typograffiti-0.1.0.2 (SchellScivally)
11:56:00 <jpg> when mimicking dependent types in askell, is there some advantage in defining type functions as indexed types over typefamilies instead 
11:56:23 <jpg> I mean
11:56:55 <jpg> > type family (xs :: [Type]) :++ ( ys :: [Type]) :: [Type]
11:56:55 <jpg> > type instance '[]       :++ ys = ys
11:56:55 <jpg> > type instance (x ': xs) :++ ys = x ': (xs :++ ys)
11:56:58 <lambdabot>  <hint>:1:1: error: parse error on input ‘type’
11:56:59 <lambdabot>  <hint>:1:1: error: parse error on input ‘type’
11:56:59 <lambdabot>  <hint>:1:1: error: parse error on input ‘type’
11:57:02 <jpg> > hAppend :: HList xs -> HList ys -> HList (xs :++ ys)
11:57:02 <jpg> > hAppend HNil ys = ys
11:57:03 <jpg> > hAppend (HCons x xs) ys = HCons x (hAppend xs ys)
11:57:05 <lambdabot>  error:
11:57:05 <lambdabot>      Not in scope: type constructor or class ‘HList’error:
11:57:05 <lambdabot>      Not in scope: type constructor or class ‘HList’error:
11:57:05 <lambdabot>  <hint>:1:17: error:
11:57:05 <lambdabot>      parse error on input ‘=’
11:57:07 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
11:57:09 <lambdabot>  <hint>:1:25: error:
11:57:11 <lambdabot>      parse error on input ‘=’
11:57:13 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
11:57:42 <jpg> instead of that, is it better this?
11:58:16 <jpg> < class HAppend xs ys where
11:58:17 <jpg> <   type HAppendR xs ys :: [Type]
11:58:17 <jpg> <   chAppend :: HList xs -> HList ys -> HList (HAppendR xs ys)
11:58:57 <lyxia> jpg: please don't paste code in IRC chat and use a paste service like gist.github.com instead
12:00:23 <jpg> I think I read somewhere that the second alternative (Implemented, of course) is better in some scenario when ghc infers types
12:00:25 <lyxia> the class version has more overhead because it elaborates to a class dictionary to pass around at runtime, which is redundant with the GADT HList
12:04:00 <jpg> Is that the only difference? Is the first implementation allways better?
12:16:27 <inkbottle> nbloomf: Thanks for the link, I'll read it ASAP; I understand the solution going: do {blah blah; return}, is, well more readable: but somehow I like so much more the solution `(((flip .) . flip) A) <$> undef <*> undef`; and as the saying goes: "the flipper the merrier", so to hell with the readability, let's go point free
12:19:48 <cocreature> as long as nobody else is going to read your code you’re free to commit whatever atrocities you want :)
12:20:20 <benzrf> cocreature: http://catb.org/esr/writings/unix-koans/prodigy.html
12:20:31 <MarcelineVQ> importantly, future-you counts as somebody else
12:20:47 <kadoban> MarcelineVQ: Screw that guy though, he's a jerk.
12:20:51 <MarcelineVQ> benzrf: :>
12:20:57 * hackage massiv 0.2.7.0 - Massiv (Массив) is an Array Library.  http://hackage.haskell.org/package/massiv-0.2.7.0 (lehins)
12:34:57 * hackage constraints-extras 0.2.2.0 - Utility package for constraints  http://hackage.haskell.org/package/constraints-extras-0.2.2.0 (abrar)
12:38:27 * hackage constraints-extras 0.2.2.1 - Utility package for constraints  http://hackage.haskell.org/package/constraints-extras-0.2.2.1 (abrar)
12:50:43 <mniip> how would you "actually" use reflection?
12:51:13 * shapr reflects on that question
12:51:14 <mniip> if you reflect over your entire program then the entire program is littered by `Reifies` constraints
12:51:34 <mniip> and if your program already uses a monad transformer stack
12:51:42 <mniip> you're better off just adding another ReaderT
13:09:27 * hackage record-encode 0.2.3 - Generic encoding of records  http://hackage.haskell.org/package/record-encode-0.2.3 (ocramz)
13:29:20 <hc> hmm, hackage could use https links instead of http...
13:33:14 <__monty__> kadoban: Pretty sure you're talking about past-you, not future-you. Future-you's just the poor shmuck that has to fix present-you's mistakes.
13:33:22 <amalloy> happily mniip is right here to hear that suggestion about the hackage irc bot
13:35:22 <mniip> let me take a look
13:37:36 <amalloy> mniip: is the source for hackage bot online somewhere? i don't see it under your name on hackage or github
13:37:48 <mniip> no
13:37:55 <mniip> it wouldn't be on hackage as it isn't written in haskell
13:39:16 <zachk> what is it written in?
13:39:17 <mniip> ok, it turns out the bot isn't generating the http links
13:39:22 <mniip> they come from the RSS feed as is
13:39:48 <mniip> zachk, it's one page of code - a module for the sopel irc bot
13:40:16 <zachk> what language though 
13:42:26 <amalloy> zachk: it's easy enough to look up sopel and see it's a python program
13:42:36 <zachk> yea doing that atm
13:42:48 <mniip> python yes
13:44:56 <mniip> this should do it
14:02:59 * hackage constraints-extras 0.2.3.0 - Utility package for constraints  https://hackage.haskell.org/package/constraints-extras-0.2.3.0 (abrar)
14:12:28 <mniip> looks good
14:32:49 <jzeus> im trying to write a solution in haskell for https://code.google.com/codejam/contest/2270488/dashboard#s=p2
14:33:16 <jzeus> so far i got ix.io/1z42
14:33:53 <jzeus> but it is too slow for large inputs 
14:34:08 <jzeus> any tips on optimization?
14:36:19 <utdemir[m]> jzeus: instead iterating through the numbers filtering for palindromes, you can probably generate all palindromes within a range more efficiently.
14:36:57 <utdemir[m]> Like if you take a number, reverse it and append it with any number in between, the result will be a palindrome
14:37:28 <utdemir[m]> and if you just iterate through the palindromes, take the square root and check if the root is palindrome, it might be more efficent IMO
14:39:39 <merijn> jzeus: Ouch... "read" is bad, it's unsafe and superslow!
14:40:35 <merijn> jzeus: Also, probably want to factor a bunch of that code into let/where, because it's very tricky to read (and thus see what it's doing/what could be faster)
14:41:45 <merijn> You're also computing the list of fair numbers twice (unnecessarily)
14:42:19 <merijn> I'd define it once and share it. Even nicer would be to combine the two "length + takeWhile" into a single traversal
14:45:48 <danso> for years, i thought "STM" meant "strict threading monad" but i've just learned that's not correct
14:45:59 <danso> does anybody know a source that says this? i'm wondering now where i got it
14:46:32 * Clint shrugs.
14:46:52 <danso> or "single threaded monad"
14:47:00 <fiftysix> is there an operator like =<< but with a return
14:47:02 <fiftysix> like https://gist.github.com/5FiftySix6/395f100723772196b1e6582f5b3cfae3
14:47:08 <merijn> danso: Maybe you're misremembering ST?
14:47:32 <merijn> danso: The original ST paper is called "Lazy Functional State Threads"
14:48:01 <merijn> fiftysix: That's just fmap?
14:48:11 <danso> oh, no, i'm not crazy
14:48:23 <danso> ST is "strict threading" 
14:48:39 <merijn> danso: Where did you see that?
14:48:47 <danso> is there a relationship between ST and STM? 
14:48:53 <merijn> danso: Nope
14:49:00 <danso> merijn, https://wiki.haskell.org/Monad/ST
14:49:27 <merijn> danso: The S is not for strict, though, it's for State
14:49:49 <fiftysix> when I use fmap the type doesn't match
14:50:12 <merijn> fiftysix: Then you need to write out the type of the variables there, because right now you're asking us to guess :)
14:50:36 <Clint> fiftysix: did you mean return (op x)
14:50:59 <fiftysix> no I've got r as an IO (Response Blocks)
14:51:04 <danso> ah
14:51:10 <fiftysix> and then I return (r ^. responseBody) to get IO Blocks
14:51:16 <danso> yeah, that page isn't really clear, but that makes sense
14:53:33 <aplainzetakind> I remember seeing a sequel to the data61 course at some point but I can't find it now.
15:14:34 <jackdk> aplainzetakind: https://github.com/qfpl/applied-fp-course ?
15:18:11 <aplainzetakind> jackdk: That one, thanks.
15:34:17 <Yuon> Suppose I have a function Word16 -> Word16 and I'd like to pre-compute all possible outputs in order to improve performance, what would be the optimal container to save the results ?
15:35:45 <koala_man> one of the unboxed arrays probably?
15:35:46 <boj> Yuon: perhaps look at some of the memoization examples?
15:37:05 <boj> i guess that wouldn't pre-compute it, but it would give you cached results on demand
15:38:40 <Yuon> Thanks ! I'll look into both of your suggestions. Cached results might be even better than pre-computing. 
15:41:59 * hackage function-builder 0.1.0.2 - Create poly variadic functions for monoidal results  https://hackage.haskell.org/package/function-builder-0.1.0.2 (SvenHeyll)
15:48:59 * hackage function-builder 0.1.0.3 - Create poly variadic functions for monoidal results  https://hackage.haskell.org/package/function-builder-0.1.0.3 (SvenHeyll)
15:51:00 * hackage function-builder 0.1.0.4 - Create poly variadic functions for monoidal results  https://hackage.haskell.org/package/function-builder-0.1.0.4 (SvenHeyll)
16:01:35 <wroathe> So I see people here saying don't use read/show quite a bit. I have a need to convert a string to another type at runtime, and I was planning on using readMaybe. Is there a better alternative?
16:02:31 <zachk> I use readMaybe alot, read is just slow and not considered for industrial/production use, people use a parser from parsec or something for industrial grade stuff
16:04:10 <v0d1ch> dminuoso: here are that Comonad instance https://github.com/v0d1ch/thinking-with-types/blob/master/src/Irc.hs#L41
16:05:45 <wroathe> Is the performance difference between using readMaybe and parsec really that large when converting a string to a numeric type or a boolean?
16:06:07 <v0d1ch> I didn't have any problems with those which I could not say for `Cont`, perhaps I was just too tired
16:06:17 <wroathe> I can't imagine readMaybe "32342343" :: Int being unworthy of production use
16:06:37 <wroathe> (or similar)
16:07:17 <c_wraith> iirc, read for Float and Double are really slow
16:08:14 <c_wraith> because there has been a lot of work done on finding optimized algorithms for those, but their read instance just goes via Rational
16:08:40 <c_wraith> simple, easy to make correct, but far from fast.
16:10:53 <wroathe> c_wraith: Yeah, that's a good point. Maybe I should just look at the implementation to make my decision.
16:13:21 <ned> Suppose you have a function that generates a file. You could parameterise it with the filename to output to, which obviously has the advantage that you get to decide the filename. However, if the function decides the filename (given a directory) and returns e.g. f :: Directory -> IO FilePath then the caller is forced to run `f` before using the output filename, thus avoiding a potential mistake.
16:13:30 <ned> Does anyone try this pattern with their functions?
16:14:13 <ned> or have any thoughts on forcing IO actions to be sequenced properly
16:14:57 <infinisil> ned: How about not outputting any file path at all, but the contents of the file instead. Then the user can write it wherever they want
16:17:23 <ned> infinisil: I think that's a very good idea... I was getting distracted by the fact that I'm working on a database and thinking it needs to be on disk, but I can work around that either by using an in memory representation and returning that or creating a temporary file and then reading back the bytes.
16:17:30 <ned> infinisil: thanks, that's really helpful
16:20:08 <ned> .. although, even when you have a function that just returns the contents of the file, I feel like when it comes to being used you face the same problem. You have to setup the parameters, call the function, write the contents to a file. If you pull that wrapper logic out into its own IO action you get the original problem.. hmm
16:22:37 <lyxia> What is the original problem you were trying to solve with that pattern
16:28:23 <ibloom> Is there a way to define a type synonym so that it doesn’t type check with other synonyms that have the same right hand side.
16:28:50 <kadoban> ibloom: A newtype
16:28:58 <ibloom> So for example say I have two types Pair and Duo which are both synonyms for Linear.V2
16:29:41 <ibloom> But wouldn’t my newtype need new instances for classes like foldable, functor etc.
16:29:52 <hpc> yep
16:29:55 <hpc> they're different types
16:30:07 <hpc> there's a newtype deriving mechanism you can use to reuse instances
16:30:21 <hpc> GeneralizedNewtypeDeriving
16:30:33 <ibloom> Ah, got it.
16:30:38 <hpc> or something like that, i haven't ever had to use it
16:30:52 <ibloom> And then I can use a pattern synonym to unwrap
16:30:59 <ibloom> I’ll try that.
16:34:42 <lyxia> it's just called a "constructor", a "pattern synonym" is a more general way to construct patterns, that doesn't seem necessary for your problem.
16:36:21 <angerman> leothrix: yep they should work. Best option is probably to use the binary distributions, unless you really feel like building it yourself. See hackage.mobilehaskell.org
16:38:59 * hackage prefetch 0.1.0.0 - Prefetch stdin even before stdout is ready  https://hackage.haskell.org/package/prefetch-0.1.0.0 (EyalLotem)
16:43:09 <leothrix> angerman: cool, thank you muchly
17:35:24 <michalrus> Can I do `class X x where type (S x) :: SomeOtherKind`?
17:35:31 <michalrus> This syntax doesn’t work
17:37:14 <lyxia> remove the parentheses
17:40:45 <michalrus> Thank you. ♥
18:14:32 <winny> is there a recommended resource to understand how monads and arrows relate? This is for a beginner/intermediate haskell user.
18:15:27 <jle`> winny: what if i told you that there wasn't really too much meaningful relationship
18:15:38 <jle`> and that arrow has a dead abstraction for over a decade :)
18:15:42 <winny> :)
18:15:57 <jle`> *arrow has been
18:16:12 <wildtrees[m]> How are arrows dead?
18:16:18 <jle`> arrows aren't dead
18:16:31 <jle`> but as an abstraction, they have been largely replaced by Applicative interfaces in the haskell ecosystem
18:16:31 <winny> some context, a friend was asked to look into arrows and monads. He has some experience with scala, standard ml, and basic haskell. I'm having a tough time explaining it
18:17:26 <jle`> arrow instances obviously aren't dead (we will always be using (->)), but nobody writes libraries that export their functionality chiefly through arrow interfaces, or nobody writes generic arrow combinators anymore really
18:17:37 <jle`> they had a heyday in the mid 2000's
18:18:00 <jle`> but since then most things that would have used arrow-based interfaces now use Applicative-based interfaces instead
18:18:57 <lyxia> also CCCs
18:24:05 <jle`> winny: to answer your original question, the common things people used to do to compare-and-contrast monads and arrows (back in the old days) are same points people now use to compare and contrast Applicative and Monad
18:24:46 <winny> that seems like the only way to really understand it truly
18:32:24 <jle`> winny: the main thing to look out for is that an Applicative interface is more limiting than a Monadic interface, but in return you get opportunities for static analysis of "effects"
18:32:58 <jle`> winny: if you have an action that you accumulate using Applicative combinators, you always know in advance *what* effects you have, before you actually execute them
18:33:16 <jle`> but if you accumulate an action using a Monadic interface, it's impossible to know what effects your action has until you start to execute them
18:34:25 <jle`> for a simple example, using applicative combinators for list means that you always know the length of the resulting list without needing to inspect the elements of the input lists
18:34:50 <jle`> but if you use monadic combinators to build a list, you can't know how long the resulting list is until you look at the items inside your input list
18:35:56 <jle`> similarly for IO, if you assemble an IO action using applicative combinators, you can deduce the effects of the reuslting action only from the effects of the input actions, without waiting for their results.  but if you use monadic combinators, you can't know what effects your resulting IO action has until you actually start executing it
18:36:50 <jle`> for parsers, if you assemble a parser combinator using Applicative combinators, you'll know up-front how much values the parser will consume, just from looking at the consumption of the input parsers
18:37:16 <libertyprime> hey guys. i was wondering since i am a noob, if someone could please help me to make a basic program to generate combinations of lines from separate files. the biggest barrier to me writing haskell is how i can incorporate it in my shell scripts
18:37:17 <jle`> if you assemble a parser-combinator parser using Monadic combinators, you can't tell how much your parser combinator will consume until you actually start parsing 
18:37:18 <jle`> etc.
18:37:22 <michalrus> / In Dhall… can I have a `Nothing` without specifying its type completely?…
18:37:29 <jle`> michalrus: you can't
18:37:36 * michalrus sad
18:37:39 <jle`> Dhall doesn't have type inference
18:37:50 <jle`> it's not too bad though, since `None Integer` isn't too bad to write
18:38:09 <michalrus> OK, but what if this type is a record that takes two screens to print…
18:38:18 <jle`> you should give the type a name
18:38:21 <jle`> and do `None MyType`
18:38:39 <michalrus> OK, but I don’t have that type in Dhall anywhere. I just use `instance Dhall.Interpret …`.
18:39:07 <jle`> dhall is all about being explicit with your schemas
18:39:34 <jle`> so it's probably helpful in the long run to specify that type within dhall at some point
18:39:43 <michalrus> So I should duplicate the information between Interpret instances (which are auto-derived, too), and… Dhall code?
18:39:48 <michalrus> Hmmmm.
18:39:54 <jle`> at least so that people who need to write the Dhall files know what schema to adhere to
18:40:22 <jle`> otherwise if i have to write a configuration file for your thing, how do i know what schema to use?
18:40:33 <jle`> what keys are expected, what the types of the values are, etc.
18:40:53 <jle`> what is this, json? ;)
18:41:04 <michalrus> Mhmmm, that’s right. =)
18:41:31 <michalrus> However that type file could be autogenerated from my instances, when building the project, hmm.
18:41:36 <jle`> one thing that is nice is that dhall programs describe themselves, so your description of your schema can be directly used as the type
18:41:55 <michalrus> Yes. =)
18:42:02 <jle`> ah yeah, there is the issue of duplicationg your dhall statement of the schema with the haskell aspect
18:42:07 <jle`> *haskell statement
18:42:15 <jle`> idk what the best way to handle that is :/
18:42:18 <libertyprime> if anyone has the time to help me make this little program, here is my specification: https://ptpb.pw/fSL2.txt
18:42:30 * hackage brick-filetree 0.1.0.0 -   https://hackage.haskell.org/package/brick-filetree-0.1.0.0 (ChrisPenner)
18:43:14 <michalrus> I’ll ask in an issue, @Gabriel439 has always been v. helpful!
18:51:26 <michalrus> → https://github.com/dhall-lang/dhall-haskell/issues/794
18:51:34 <winny> jle`: so basically Applicative cuts out the need to do extra pattern matching or special handling to determine the "shape" (?) of the result
18:52:29 * hackage brick-filetree 0.1.0.1 -   https://hackage.haskell.org/package/brick-filetree-0.1.0.1 (ChrisPenner)
18:59:41 <pacak> I'm running a program as a script with #!/path/to/runghc on a machine with a bunch of cores, as it uses memory it starts spending 800% CPU time doing (I suspect) parallel GC. Any ideas how tell ghc to use something like -qm2? Usual +RTS ... or via GHCRTS env variable isn't working - runghc complains about not being build with -threaded. It's working much better when number of cores is small.
19:02:53 <lyxia> maybe -rtsopts -with-rtsopts=-qm2
19:05:00 <geekosaur> try after a --
19:05:20 <geekosaur> the first -- switches from runghc flags to ghc flags, the second -- to arguments to your program
19:06:02 <geekosaur> alternately there's --ghc-arg: --ghc-arg=+RTS --ghc-arg=-qm2 --ghc-arg=-RTS
19:07:14 <_deepfire> glguy, https://github.com/glguy/th-abstraction/issues/69
19:08:53 <_deepfire> Ryan is away, though..
19:12:29 * hackage brick-filetree 0.1.0.2 -   https://hackage.haskell.org/package/brick-filetree-0.1.0.2 (ChrisPenner)
19:14:23 <pacak> "#!/usr/local/ghc/ghc-8.6.2.0/bin/runghc --ghc-arg=+RTS --ghc-arg=-qm2 --ghc-arg=-RTS" results in "can't find file: +RTS --ghc-arg=-qm2 --ghc-arg=-RTS", but when started with a script as a parameter it works and does the right thing.
19:18:15 <pacak> But at least I'm getting somewhere, thanks!
19:21:06 <suzu> how do i use hoogle to search packages?
19:21:22 <suzu> as in, a specific set of a packages
19:21:40 <suzu> i see "Not on Stackage, so not searched."
19:22:55 <lyxia> I don't know but each package has a "quick jump" button that amounts to that
19:22:59 <geekosaur> +packagename (can be specified multiple times). but it has to be indexed, so if you're using stackage's hoogle you may lose
19:23:15 <suzu> i'm using https://hoogle.haskell.org. is that not good enough?
19:23:33 <geekosaur> that might be
19:23:45 <suzu> seems not be  :/
19:23:53 <suzu> specifically i'm trying to look in beam-core and beam-sqlite for things
19:23:55 <geekosaur> I tend to use hayoo instead of hoogle, it searches all of hackage instead of just either the platform or stackage
19:23:59 <geekosaur> but has its own issues at times
19:28:22 <libertyprime> guys, i think this is what i was looking for : https://github.com/Errorific/haskell-script-examples
19:28:40 <libertyprime> i have hope again
19:29:19 <libertyprime> damn thats a goodo link to give to newbies
19:32:16 <[rg]> can a function "def" have operators in it?
19:33:22 <geekosaur> I have no idea what you're asking
19:34:21 <geekosaur> > let a <+++> b = a * 16 + b * 3 in 5 <+++> 6 -- defines an operator
19:34:23 <lambdabot>  98
19:35:12 <Axman6> % "who am I"
19:35:13 <yahb> Axman6: "who am I"; (0.02 secs, 157,880 bytes)
19:35:22 <Axman6> who runs yahb?
19:36:18 <geekosaur> mniip (try /whois)
19:37:12 <Axman6> Thanks - would love to have it in #haskell.au
19:37:45 <geekosaur> [rg], if you are asking about mixfix like e.g. agda has, haskell doesn't support that. sometimes you can hack arund it with multiple operators and careful precedence
19:41:21 <[rg]> geekosaur, no I was thinking like like f x+1 = ...
19:41:58 <geekosaur> it'd require parentheses, and the NPlusKPatterns extension (which used to be a default but it makes it too easy to write partial functions and has other anomalous behaviors)
19:42:21 <geekosaur> 'f x+1' is parsed as (f x) + 1
19:43:49 <[rg]> ah ok, thank you
19:44:03 <[rg]> is this where you look at the grammar? https://www.haskell.org/onlinereport/syntax-iso.html
19:44:15 <[rg]> in the context free section
20:55:16 <carlosdagos> Hi all o/ 
20:55:30 <carlosdagos> Is there a way to set the `hashedMirrors` property in `nixos/configuration.nix`? 
20:56:19 <carlosdagos> Oops, actually, wrong channel >.< Sorry about that
21:18:30 * hackage thrift 0.12.0 - Haskell bindings for the Apache Thrift RPC system  https://hackage.haskell.org/package/thrift-0.12.0 (jking)
22:33:02 <ned> if you have a bunch of newtype wrappers, do people prefer to put them in e.g. a Types module or have a separate module for each type?
22:35:00 * hackage thrift 0.11.0 - Haskell bindings for the Apache Thrift RPC system  https://hackage.haskell.org/package/thrift-0.11.0 (jking)
22:52:24 <dminuoso> dmwit: Oh, indeed argv is explicitly defined to be modifable, I must have remembered about something different then.
23:11:41 <dminuoso> @tell mniip A long while ago you tried to explain Show1 to me https://gist.github.com/dminuoso/b0898daa5df37f0676931c53362199b5 - those last bits, did you mean `Dict` in the sense of `data Dict :: Constraint -> * where Dict :: a => Dict a`?
23:11:41 <lambdabot> Consider it noted.
23:14:32 <jle`> winny: Applicative interfaces all have "deterministic" shapes, that don't depend on results of actions
23:17:34 <jle`> winny: the shape of the results only depend on the shape of the inputs
23:19:00 <dminuoso> jle`: Heh I didn't intuitively understood that until I learned to think of Applicative as Monoidal. :)
23:20:27 <dminuoso> That is, seeing the difference between Applicative and Monad is hard when there's this extra "application" interference that distracts.
23:22:17 <ar1a> is there a way to shorten `fizzbuzz`? maybe with composition or something https://ptpb.pw/KoVF/haskell
23:22:36 <dminuoso> % unit = pure () 
23:22:36 <yahb> dminuoso: (0.01 secs, 0 bytes)
23:22:43 <dminuoso> Oi, new yahb? =)
23:22:51 <ar1a> i want to keep concatenation going though so it's easy to add a new number
23:23:25 <MarcelineVQ> dminuoso: new?
23:23:51 <dminuoso> MarcelineVQ: It didn't use to tell me something.
23:23:58 <MarcelineVQ> oh, someone set +s
23:23:59 <dminuoso> % (<+>) = liftA2 (,)
23:23:59 <yahb> dminuoso: (0.01 secs, 0 bytes)
23:24:03 <MarcelineVQ> % :q
23:24:04 <yahb> MarcelineVQ: 
23:24:08 <dminuoso> MarcelineVQ: Ah.
23:24:17 <dminuoso> % :t (<+>)
23:24:18 <yahb> dminuoso: ; <interactive>:1:1: error:; Ambiguous occurrence `<+>'; It could refer to either `Text.PrettyPrint.HughesPJ.<+>', imported from `Text.PrettyPrint.HughesPJ'; or `Control.Arrow.<+>', imported from `Control.Arrow'
23:24:43 <dminuoso> Mmm, how do I qualify an identifier I created locally in GHCi?
23:25:10 <MarcelineVQ> I rebooted yahb so it was erased. but good question, I'm not sure.
23:26:23 <dminuoso> MarcelineVQ: It's good to know you can `:q` reset yahb, this seems really useful to reset it into a well known state. :)
23:29:15 <dminuoso> ar1a: You can do it much shorter in just one function and using guards.
23:30:15 <ar1a> dminuoso: if you read my second message i mentioned i dont want to do it that way
23:30:49 <ar1a> because a second question is often to add another number, which is a lot more work than just concating another function for that number
23:31:26 <jle`> ar1a: fizzbuzz = fizz <> buzz
23:31:39 <ar1a> :t (<>)
23:31:40 <lambdabot> error:
23:31:40 <lambdabot>     Ambiguous occurrence ‘<>’
23:31:41 <lambdabot>     It could refer to either ‘Data.Monoid.<>’,
23:31:42 <jle`> this makes it easy to add more numbers, because you can do:
23:31:53 <jle`> fizzbuzzbloop = mconcat [fizz, buzz, bloop]
23:32:24 <ar1a> hoogle doesn't find <>
23:32:33 <ar1a> gives me stuff from hackage
23:32:36 <jle`> which hoogle are you using?
23:33:01 <jle`> <> is in base (twice)
23:33:10 <jle`> it should also be in Prelude
23:33:19 <jle`> so it's automatically imported in every haskell file
23:33:20 <ar1a> https://www.haskell.org/hoogle/?hoogle=%3C%3E
23:33:31 <jle`> ah yeah, don't use that one ... it's like ten years out of date
23:33:39 <jle`> well i guess to be fair, it's closer to five years out of date
23:33:48 <ar1a> which should i use?
23:34:05 <jle`> you can use stackage hoogle, or the beta at hoogle.haskell.org
23:34:29 <jle`> https://www.stackage.org/lts/hoogle?q=%3C%3E
23:34:47 <jle`> in this case you can just check in ghci since it's automatically imported :)
23:34:51 <dminuoso> instance Monoid m => Monoid (a -> m)
23:34:57 <dminuoso> Is one of the coolest instances =)
23:35:21 <ar1a> so how should i use <>? i've never seen it before - not sure what it does
23:35:33 <jle`> ar1a: i gave an example usage up there
23:35:39 <dminuoso> ar1a: <> is the generalized "mash things together" interface of Monoid.
23:35:48 <dminuoso> Or Semigroup rather (staying up to date is hard)
23:35:50 <jle`> ar1a: it's `mappend` from the Monoid typeclass, essentially
23:35:56 <jle`> it's a typeclass method
23:35:58 <ar1a> yeah i know i meant in other situations 
23:36:04 <jle`> like +, *, ==, etc.
23:36:13 <ar1a> but String isn't a monoid 
23:36:14 <jle`> ar1a: every type provides its own implementation
23:36:17 <jle`> is it? :)
23:36:22 <jle`> > "hello" <> "world"
23:36:23 <dminuoso> ar1a: what is String?
23:36:24 <lambdabot>  error:
23:36:24 <lambdabot>      Ambiguous occurrence ‘<>’
23:36:24 <lambdabot>      It could refer to either ‘Data.Monoid.<>’,
23:36:27 <jle`> gr
23:36:35 <dminuoso> ar1a: That is, String is a type alias. What does it resolve to?
23:36:35 <jle`> % "hello" <> "world"
23:36:35 <yahb> jle`: "helloworld"
23:36:43 <ar1a> [Char]
23:36:52 <dminuoso> ar1a: Do you think lists form monoids under some operation?
23:36:55 <jle`> ar1a: <> is a typeclass method, so every instance of Monoid provides its own implementation
23:37:09 <jle`> * every instance of Semigroup 
23:37:18 <jle`> for the case of string, it's concatenation
23:37:44 <ar1a> i guess so, honestly i sort of need more reading material on functors, applicatives and monads. i know what they do, i know what <$> <*> and >>= do, but i don't think i fully understand them
23:37:47 <ar1a> > 1 <> 2
23:37:49 <lambdabot>  error:
23:37:49 <lambdabot>      Ambiguous occurrence ‘<>’
23:37:49 <lambdabot>      It could refer to either ‘Data.Monoid.<>’,
23:37:53 <jle`> ar1a: right, this is actually Monoid :)
23:38:03 <jle`> but yeah, it's different for every type
23:38:07 <jle`> it's just like *, +, etc.
23:38:07 <dminuoso> ar1a: Dont read material on them, just use them repeatedly. :)
23:38:12 <jle`> every type implements its own <>
23:38:20 <dminuoso> If you dont have a good background already, reading abstract material on these abstract interfaces is not very helpful.
23:38:28 <ar1a> i tried `1 <> 2 :: Int` and it errored out in my ghci
23:38:29 <jle`> so don't really look at this as "using monoids"; look at it as using <> for a specific type
23:38:36 <jle`> ar1a: are you familiar with typeclasses?
23:38:45 <jle`> if a type is an instance of a typeclass, then it implements its methods so you can use them
23:38:53 <jle`> but this only works if a type is an instance of a typeclass
23:38:55 <dminuoso> ar1a: In case of `Int` it was decided to not provide an instance Monoid because there exist two equally good candidates.
23:39:08 <jle`> Int doesn't have an instance of Semigroup, so you can't use <>
23:39:13 <jle`> it's the same error as if you were using /
23:39:16 <jle`> > 1 / 2 :: Int
23:39:18 <lambdabot>  error:
23:39:18 <lambdabot>      • No instance for (Fractional Int) arising from a use of ‘/’
23:39:18 <lambdabot>      • In the expression: 1 / 2 :: Int
23:39:21 <dminuoso> ar1a: So instead newtype wrappers `Product` and `Sum` were created, both of which have a Semigroup/Monoid instance
23:39:35 <dminuoso> Oh actually wait! Int is a bad choice because you dont have closure.
23:39:42 <jle`> yeah, the problem here is much simpler
23:39:48 <jle`> it isn't about distinguishing possible instances
23:39:51 <jle`> it's just that there is no instance
23:40:00 <jle`> it's just like what happens if you do (1 :: Int) / (2 :: Int)
23:40:16 <jle`> or "hello" * "world"
23:40:36 <jle`> ar1a: if you want to use + for your type, you have to *define an instance of Num* for that type
23:40:39 <jle`> that's how typeclasses work
23:40:47 <jle`> if you don't define an instance of Num, then you can't use +
23:40:58 <jle`> it's the same case here; Int has no Semigroup instance (it is never given one), so you can't use <>
23:41:07 <jle`> you can only use typeclass methods if the types have an instance
23:41:25 <jle`> that's the meaning of type signatures like: `myFunc :: Eq a => a -> a -> Bool`
23:41:35 <jle`> it means that `myFunc` can be used with any type, *as long as it has an Eq instance*
23:41:38 <ar1a> what are some other basic types that <> works on?
23:41:52 <jle`> check ghci :) if you do `:i Semigroup`, it'll give you a list of all instances
23:41:57 <dminuoso> ar1a: check `:i Monoid` or `:i Semigroup`
23:41:59 <jle`> you can also see on the documentation, too
23:42:07 <dminuoso> *list of all known/included Instances
23:42:27 <jle`> you can also check the docs here -- https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Semigroup.html
23:42:29 <v0d1ch> 1:03 AM <v0d1ch> dminuoso: here are that Comonad instance https://github.com/v0d1ch/thinking-with-types/blob/master/src/Irc.hs#L41
23:42:33 <jle`> there is a list of all instances in 'base'
23:42:41 <jle`> % () <> ()
23:42:41 <yahb> jle`: ()
23:42:45 <ar1a> also, i forgot whats the operator you use when chaining a bunch of maybes together? yknow so if you need 3 values from maybes you dont have to write 3 case statements
23:42:59 <jle`> ar1a: it depends on how you want to chain
23:43:11 <jle`> you can use catMaybes if you want to get all of the Just values
23:43:15 <jle`> > [Just 3, Just 10, Just 2]
23:43:17 <lambdabot>  [Just 3,Just 10,Just 2]
23:43:19 <v0d1ch> dminuoso: I did those instances yesterday if you remember my “task”
23:43:23 <dminuoso> v0d1ch: The Comonad instance is definitely wrong.
23:43:24 <jle`> > catMaybes [Just 3, Just 10, Nothing, Just 2]
23:43:26 <lambdabot>  [3,10,2]
23:43:34 <jle`> you can use <|> if you want to get the first Just
23:43:43 <jle`> > Just 3 <|> Just 10 <|> Nothing <|> Just 2
23:43:45 <lambdabot>  Just 3
23:43:46 <jle`> etc.
23:44:05 <v0d1ch> oh again, I need to probably write out some check for those laws
23:44:09 <ar1a> so is there any reason you'd want to use ++ instead of <>?
23:44:17 <v0d1ch> so I know they are correct
23:44:19 <jle`> well, in our case, ++ isn't defined for functions
23:44:26 <dminuoso> v0d1ch: It might be easier to approach this from a "what is this even" perspective
23:44:28 <jle`> but functions have a Monoid instance, so <> is defined
23:44:32 <jle`> so you can use <>, but not ++
23:44:45 <jle`> using `fizzbuzz = fizz ++ buzz` is a type error
23:44:47 <dminuoso> v0d1ch: A Store is a generalized indexed container that has a "current position" 
23:45:03 <dminuoso> v0d1ch: So in a store you can "read out an arbitrary position", "read out the current position" or "seek to a new position"
23:45:09 <jle`> ar1a: usually, the main reason you'd use ++ instead of <> is... any time you don't have a list, heh
23:45:16 <jle`> since you can only use ++ for lists
23:45:27 <jle`> <> is overloaded, so it works for many other types that aren't lists
23:45:30 <MarcelineVQ> more generally: it's immediately clear to the reader that ++ means we're talking about lists
23:45:37 <v0d1ch> dminuoso: ok I will give it another shot
23:45:37 <ar1a> ah, i meant in terms of strings! :P
23:45:45 <jle`> ar1a: ah. no, i'd usually use ++
23:45:49 <ar1a> but thanks fsor the input that answers my inevitable second question
23:46:06 <jle`> ar1a: but it might be convenient to use monoid-polymorphic functions like mconcat
23:46:10 <jle`> mconcat [x,y,z] = x <> y <> z
23:46:10 <dminuoso> v0d1ch: Im dropping off from the train in a minute, if you're still around in 20 minutes Ill give you some extra utility functions to implement, those should prove helpful. 
23:46:19 <jle`> > mconcat ["hello", "world", "goodbye"]
23:46:21 <lambdabot>  "helloworldgoodbye"
23:46:32 <jle`> mconcat is defined for all monoids, so you can piggyback on it if you want to concatenate a bunch of strings together
23:46:39 <jle`> although in this case you could just use concat, i just realized, heh
23:46:45 <jle`> so maybe bad example
23:46:56 <MarcelineVQ> or fold if you're feeling golfy
23:47:27 <jle`> right, i'm saying that this isn't a case where String provides a "works only on strings" version out of the box
23:47:36 <v0d1ch> dminuoso: I will be skiing but just write them to me, I have irccloud app so I can view them later, appreciated
23:47:37 <jle`> you can always use ++ instead of <>
23:48:03 <jle`> and you can always use concat instead of mconcat
23:48:15 <jle`> so there isn't much incentive to use the monoid-polymorphic versions in that case
23:48:26 <jle`> it's just like how i'll always use `map` instead of `fmap`
23:48:33 <jle`> or `.` instead of `fmap`
23:50:16 <jle`> to me, the main advantage of Monoid as an abstraction is that you can use the large plethora of useful monoid-polymorphic functions defined in base and the standard libraries
23:50:29 <jle`> so, if you make your type into a monoid, you get all of that functionality for free
23:51:02 <jle`> i guess the other (equally valuable) main advantage is that it allows for you to do code refactoring and restructuring while guaranteeing that the resulting code does the same thing
23:51:45 <tdammers> it gets even better: there's a vast plethora of functions written in terms of *several* common typeclasses, so the benefits stack up
23:51:50 <jle`> :D
23:52:24 <jle`> ar1a: in your case, we actually take advantage of this right here
23:52:33 <jle`> since for functions, f <> g = \x -> f x <> g x
23:52:58 <ar1a> :D haskell is cool
23:53:00 <jle`> so `fizzbuzz = fizz <> buzz` evaluates to `fizzbuzz = \n -> fizz n <> buzz n`
23:53:12 <jle`> which evaluates to `fizzbuzz = \n -> fizz n ++ buzz n`
23:53:18 <jle`> which is `fizzbuzz n = fizz n ++ buzz n`
23:53:48 <jle`> this is an advantage of having a universal Monoid typeclass, because we can write a <> for functions that takes advantage of the result type's Monoid typeclass
23:54:57 <jle`> we can actually double-piggyback this, and use Maybe's monoid instance
23:55:39 <ar1a> hmm, maybe theres some haskell magic for this. https://ptpb.pw/HNpr/haskell how do you think I can fix this?
23:56:29 <ar1a> maybe with maybes? or...
23:56:36 <jle`> ah yeah, using maybe's is a common route for this
23:56:47 <jle`> your fizzies can be `Int -> Maybe String`s
23:56:56 <jle`> and you can <> the Maybe Strings together
23:57:19 <jle`> <> for Maybe works like this: if they're both Nothing, the result is Nothing.  otherwise, it's the <>-ing of any Just's
23:57:25 <jle`> > Just "fizz" <> Nothing
23:57:27 <lambdabot>  error:
23:57:27 <lambdabot>      Ambiguous occurrence ‘<>’
23:57:27 <lambdabot>      It could refer to either ‘Data.Monoid.<>’,
23:57:33 <ar1a> how can i print the number if they are all nothing?
23:57:36 <jle`> % Just "fizz" <> Nothing
23:57:36 <yahb> jle`: Just "fizz"
23:57:43 <jle`> % Just "fizz" <> Just "buzz"
23:57:43 <yahb> jle`: Just "fizzbuzz"
23:57:51 <jle`> % Nothing <> Nothing
23:57:52 <yahb> jle`: Nothing
23:59:26 <jle`> so you can write `fizzbuzz n = fromMaybe (show n) (mconcat [fizz, buzz, diffie] n)`
23:59:39 <jle`> or you can manually pattern match on the result
23:59:53 <jle`> the main thing we leverage here is that <> for Maybe is "it's NOthing if they're all Nothing" behavior
23:59:58 <jle`> which is exactly what we want from fizzbuzz
