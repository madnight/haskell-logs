00:21:57 * hackage http-client 0.6.1 - An HTTP client engine  http://hackage.haskell.org/package/http-client-0.6.1 (MichaelSnoyman)
01:05:24 <larryba> hi. does ghci load the file faster when unused imports are removed? I removed a bunch now, and subjectively, loading seems to be much faster now
01:05:57 <Athas> larryba: yes, because in general ghci cannot tell whether an import is used until after it has been loaded.
01:06:41 <larryba> good to know. I used -fno-warn-unused-imports for a while, I think I'll stop using it from now on
01:46:26 <phadej> also reload is faster, as module dependency graph is sparser, so you don't need to reload "everything"
01:56:56 <dminuoso> Athas: Does ghci process the file line-by-line?
02:01:40 <adamretter_> jle`: dammn power cuts today!
02:24:54 <dminuoso> Lets say I needed to obtain a resource during unsafeIOToSTM, would I have to protect it with uninterruptibleMask?
02:31:25 <phadej> sounds like a bad idea
02:31:56 <phadej> (to acquire resources in IO)
02:32:02 <phadej> in STM*
02:36:34 <dminuoso> phadej: Well I mean say something like `unsafeIOToSTM (bracket acq rel stuff)`
02:37:00 <dminuoso> Just reading the documentation of `unsafeIOToSTM` that seems like a particularly bad idea.
02:37:18 <dminuoso> I do not understand the mechanism by which GHC interrupts a transaction if need be.
02:40:27 <Athas> dminuoso: what difference would it make whether it is line-by-line?  Values are only evaluated when they are needed.
02:40:44 <Athas> Now, if you enter IO expressions at the ghci *prompt*, then they are executed immediately.
02:41:09 <dminuoso> 10:05         Athas | larryba: yes, because in general ghci cannot tell whether an import is used until after it has been loaded.
02:41:20 <dminuoso> Athas: ^- the difference is if GHCi scanned the entire file it could make that determination.
02:41:28 <dminuoso> If it processed the file line by line it would have to blindly follow every import.
02:41:54 <Athas> dminuoso: but how could ghci possibly know whether the imports are used before seeing what they define?
02:42:17 <Athas> Even if you are a saintly Haskell programmer who only uses qualified imports, ghci will still have to check for type class instances in each of the imports.
02:42:38 * dminuoso always wears a white robe when programming
02:48:14 <sshine> but do you wear a wizard hat?
02:53:42 <larryba> > execState (_Just += 10) (Just 10)
02:53:44 <lambdabot>  Just 20
02:53:52 <larryba> :-)
02:54:13 <larryba> lenses and State are a match made in heaven
02:55:29 <Taneb> > Just 10 &~ _Just += 10
02:55:31 <lambdabot>  Just 20
02:55:55 <Taneb> larryba: so much so that there's an operator synonym for flip execState in lens!
03:04:33 <larryba> Taneb, I"m still figuring out the logic behind lens operator names. this seemed like a good basic start. https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial#actually-there-are-a-whole-lot-of-operators-in-lens---over-100
03:05:21 <fr33domlover> Athas, it could load imports on demand, every time something isn't found in the imports it already loaded
03:05:49 <Taneb> larryba: most of them follow a fairly consistent scheme
03:06:24 <Taneb> operator~ for a function, operator= for a state update
03:06:42 <Taneb> < to get the new value as well, << to get the old value
03:07:06 <Taneb> Getter operators are different but there's only three or four of them, and there's a few others as well
03:21:37 <dminuoso> Interesting, I think `Permutation` is an example of a non-Monad Applicative.
03:24:27 * hackage bisc 0.1.0.0 - A small tool that clears qutebrowser cookies.  http://hackage.haskell.org/package/bisc-0.1.0.0 (rnhmjoj)
03:25:08 <mniip> dminuoso, what does that do
03:27:25 <dminuoso> mniip: It's part of parser-combinators. It allows you to run various permutations of some (Alternative m)
03:27:27 <dminuoso> https://hackage.haskell.org/package/parser-combinators-1.0.1/docs/Control-Applicative-Permutations.html
03:28:04 <turbo_MaCk> hi there! I'm about to release my first package on Hackage and would like to give an oportunity to let community peer review it before I do so.
03:28:41 <turbo_MaCk> It's nothing big per se so it should be easy enough to review
03:28:55 <turbo_MaCk> here is a release candidate on Hackage https://hackage.haskell.org/package/wai-enforce-https-0.0.1/candidate
03:29:06 <turbo_MaCk> and repo https://github.com/turboMaCk/wai-enforce-https
03:38:56 <dminuoso> turbo_MaCk: https://github.com/turboMaCk/wai-enforce-https/blob/master/Network/Wai/Middleware/EnforceHTTPS.hs#L148 I'd use Data.Char.ord for expressivity there.
03:40:13 <DukeDrake> hi
03:40:46 <dminuoso> turbo_MaCk: Also I would probably use guards rather than `if/then/else` in most of your cases.
03:41:52 <DukeDrake> I'm very new to haskell. We're currently learning the lambda calculus and I feel a bit challenged by the very reduced syntax .... 
03:42:28 <dminuoso> DukeDrake: Curious, you'd think that less syntax was easier to learn than lots of syntax. :-)
03:43:00 <DukeDrake> dminuoso: heh ... would be nice =)
03:43:05 <DukeDrake> is it possible to "transpile" \lambda s.\lambda z. s (s z) to pseudo code of some sort?
03:43:43 <DukeDrake> (maybe even *cough* java? ^^)
03:43:44 <dminuoso> DukeDrake: In haskell the equivalent might be: `\s -> \z -> s (s z)` - types aside for a moment.
03:44:15 <Putonlalla> :t \ s -> \ z -> s (s z)
03:44:16 <lambdabot> (t -> t) -> t -> t
03:44:21 <DukeDrake> dminuoso: yeah, well .. still doesn't ring a bell
03:44:45 <Putonlalla> :t \ s -> s . s
03:44:45 <turbo_MaCk> dminuso: Thx for looking into it. I will think about appling both. Honestly I still have mixed feelings about guards. There are definitevely powerful but to some degree they're kind of language feature fetish but maybe I'm just too crippled from ammount of elm lamg I've wrote in past 3 years.
03:44:46 <lambdabot> (b -> b) -> b -> b
03:44:51 <DukeDrake> Putonlalla: thanx, but doesn't compute (at my place)
03:45:00 <Putonlalla> :t join (.)
03:45:01 <lambdabot> (a -> a) -> a -> a
03:45:22 <Putonlalla> There's a pointfree representation for you.
03:46:21 <DukeDrake> I'm afraid, I can not understand the syntax at all. What's a paramter, what's the function, what's the function call, what's the value?
03:46:44 <__monty__> DukeDrake: What languages are you familiar with?
03:46:49 <DukeDrake> (That's why I asked for pseudo code ^^)
03:46:52 <Athas> fr33domlover: that would prevent it from signaling an error when something is imported twice.
03:46:53 <turbo_MaCk> dminuoso: Looking to docs for `ord` now -> good tip :+1:
03:46:55 <dminuoso> DukeDrake: `\s -> s + a` is an anonymous function that takes an argument `s` and produces `s + a` when applied to an argument.
03:47:09 <DukeDrake> __monty__: Java, PHP, python, JS, C, C++ ...
03:47:12 <dminuoso> turbo_MaCk: Your other file also has some odd uses of magic numbers where `ord` would be great to use,.
03:47:37 <Putonlalla> JavaScript ought to make the translation easy.
03:47:55 <dminuoso> DukeDrake: Then maybe JS: s => z => s(s(z))
03:47:59 <__monty__> DukeDrake: Ah, then python lambdas : ) lambda s: lambda z: s(s(z))
03:48:25 <dminuoso> DukeDrake: There's one drastic difference in lambda calculus: Namely substitution is mechanical.
03:48:37 <dminuoso> It also does not matter in what order you substitute.
03:48:47 <turbo_MaCk> dminuoso: true true. I took that approach from `cookie` package but I agree it would be much better to convert from Char for expressiveness
03:48:51 <DukeDrake> dminuoso: ah .... hmmm ...... I do know lambdas in python, js and Java ...... hmmm
03:49:23 <dminuoso> DukeDrake: The reason we use `\` in Haskell to denote anonymous function is because `\` is an ascii approximation of `λ`
03:49:36 <dminuoso> So when you write `λx.x` in LC, the haskell equivalent is `\x -> x`
03:49:55 <DukeDrake> ah =D
03:50:05 <__monty__> DukeDrake: With regular python functions you'd have to come up with name but: def f1(s): def f2(z): return s(s(z)); return f2 # At least I think, single line python isn't exactly fun.
03:51:19 <DukeDrake> __monty__: ah!! =D
03:51:43 <DukeDrake> well .. nope xD
03:53:27 <dminuoso> DukeDrake: So when imperative languages use the term "call a function with some argument" in Haskell you would say "apply a function to some argument". The act of "function application" is very mechanical by nature. So when you have some `f x = x + 2` and apply `f` to `7`, you replace every occurence of `x` in the right side of the `equals` sign with 7.
03:53:57 <merijn> dminuoso: tbh, I would use call in Haskell too
03:54:10 <merijn> I consider "calling 'f'" and "applying 'f'" synonymous
03:55:05 <DukeDrake> dminuoso: I see. Maybe the single letter aspects of both function names and variable names irritates me xD
03:55:06 <dminuoso> DukeDrake: And lambda calculus calls the same process β-reduction
03:55:10 <Lears> @let twice = \s -> \z -> s (s z)
03:55:11 <lambdabot>  Defined.
03:55:17 <Lears> > twice (+1) 0
03:55:19 <lambdabot>  2
03:55:23 <Lears> > twice (*3) 1
03:55:25 <lambdabot>  9
03:55:33 <DukeDrake> Lears: ahhh! =D
03:55:52 <dminuoso> DukeDrake: So the act of "replace every occurence of `x` in the right side of the `equals` sign with 7" looks like this in lambda calculus
03:56:18 <__monty__> DukeDrake: http://ix.io/1yjm
03:56:43 <dminuoso> DukeDrake: (λx.x)y - if you apply β-reduction you can replace every bound variable `x` to the right of `.` with the argument `y`. So you might write: `x[x:=y]` which is exactly `y`
03:57:29 <DukeDrake> dminuoso: ok .... 
03:57:36 <DukeDrake> __monty__: thanx =)
03:58:31 <larryba> DukeDrake, in haskell  "add x y = x + y"  is the same as  "add = \x -> \y -> x + y" 
03:58:38 <dminuoso> DukeDrake: M[x:=Q] just denotes "in the term M replace every occurence of `x` with Q"
03:59:01 <DukeDrake> larryba: ah, thanx =)
03:59:24 <DukeDrake> thank you all! This is a really nice community =)
03:59:38 <mniip> as opposed to? :)
04:00:01 <dminuoso> merijn: The reason why I generally avoid `call` is to avoid the notion of "enter this function and *do* something"
04:00:18 <DukeDrake> mniip: other, less active channels? %)
04:00:37 <merijn> mniip: ##c and ##c++ ;)
04:00:43 <mniip> surprisingly, #haskell is one of the largest channels
04:01:04 <mniip> though I think SPJ mentioned this in one of his talks, haskell isn't used very much but it is very much being talked about
04:01:13 <Rembane> Evaluate all the things! 
04:01:18 <__monty__> dminuoso: I'm more familiar with M[x/Q], I assume that's the exact same thing.
04:01:23 <__monty__> *?
04:01:31 <DukeDrake> larryba: which in turn could be written as \x.\y.f x y ?
04:01:32 <dminuoso> __monty__: Yeah, there's a few writing styles.
04:02:17 <larryba> DukeDrake that is not valid haskell
04:02:50 <dminuoso> DukeDrake: (+) does not exist in LC.
04:03:27 <DukeDrake> larryba: yes. My endeavour is to understand this syntax:  \s.\z. s (s z)
04:03:43 <dminuoso> DukeDrake: Maybe start with something simple:
04:04:07 <dminuoso> DukeDrake: `(λx.x) M`, if you apply β-reduction, what do you get?
04:04:10 <DukeDrake> dminuoso: yes. I understand, f is short for a function, which would apply y and x? 
04:04:45 <dminuoso> DukeDrake: if `f` was some function that encoded number addition on church numerals, then sure.
04:04:52 <DukeDrake> dminuoso: \x.M ?
04:04:52 <dminuoso> (or some other encoding)
04:05:01 <dminuoso> DukeDrake: Nope! Just `M`
04:05:16 <DukeDrake> I got a lot to learn
04:06:31 <__monty__> DukeDrake: When you apply a function you do the substitution in its body. So you "peel" off a lambda layer. (\x.x) M -> x[x/M] -> M
04:06:40 <dminuoso> DukeDrake: so `λx.M` is a function that names a variable `x` that is bound in `M`
04:06:51 <dminuoso> DukeDrake: so `λ` starts a function definition and `.` starts the "body of the function."
04:07:13 <dminuoso> so `λx.x` is similar to say `function (x) { return x; }` in JavaScript
04:07:39 <dminuoso> where λ takes a similar role to the keyword `function` and `.` takes a similar role to {}.
04:07:57 <__monty__> (\arg.body-that-potentially-uses-arg) val -> body-that-potentially-uses-arg[arg/val] -> body-with-all-occurences-of-arg-substituted-by-val.
04:09:42 <DukeDrake> dminuoso: yes. 
04:10:14 <DukeDrake> dminuoso: a common example in this lecture is: \x.x x 
04:11:09 <dminuoso> DukeDrake: Take this term and reduce it: (\x.x x)(\y.y)
04:11:12 <dminuoso> Just one step.
04:12:38 <DukeDrake> (dang ... lecture is over ... bbiab! ^^)
04:25:08 <adamretter___> When I have an IO a, and a function a -> b, is there a simple expression like >>= that will allow me to use that function to result in an IO b ?
04:25:39 <merijn> :t fmap -- adamretter___ :)
04:25:41 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:25:55 <merijn> adamretter___: Remember that IO is an instance of Functor :)
04:27:07 <adamretter___> merijn: so how would that be expressed? in an example of its use? e.g. instead of: IO a >>= some-func
04:27:39 <merijn> :t fmap even `asAppliedTo` (undefined :: IO Int)
04:27:40 <lambdabot> IO Int -> IO Bool
04:28:07 <merijn> adamretter___: So, if "act :: IO a" and "f :: a -> b" you write "fmap f act"
04:28:29 <merijn> Or, alternatively <$> (this is just infix fmap) lets you write "f <$> act" which can be nicer looking sometimes
04:30:23 <adamretter___> merijn: okay cool. and is there a prescriptive english name for "fmap"
04:30:48 <larryba> > fmap getLine
04:30:50 <lambdabot>  error:
04:30:50 <lambdabot>      • Couldn't match expected type ‘a -> b’
04:30:50 <lambdabot>                    with actual type ‘IO String’
04:30:54 <larryba> > fmap (++"foo") getLine
04:30:56 <lambdabot>  <IO [Char]>
04:31:21 <dminuoso> adamretter___: `map` might be a bit more descriptive. :P
04:31:25 <merijn> fmap is just "functor map" (map used to be what is now fmap, but it got changed to the current version to help beginners)
04:31:33 <dminuoso> but historical reasons turned `map` into an `fmap` that was specialized for lists.
04:31:43 <merijn> adamretter___: "generalised map" is a reasonable intuition
04:32:07 <larryba> generalised map is a good way to think about it
04:32:09 <adamretter___> Okay... so fmap is very much like Scala's map function which compony appears on container objects
04:32:13 <dminuoso> adamretter___: equivalently Functor can be described as the typeclass of things that you can map over in a sensible fashion.
04:32:24 <Ariakenom> :t fmap read getLine
04:32:26 <lambdabot> Read b => IO b
04:33:16 <larryba> adamretter___, it is even more general than that. it works not only on all generic containers, but also on parsers, etc
04:33:42 <dminuoso> larryba: In some sense a parser can be thought of a container too.
04:34:22 <adamretter___> larryba: okay cool
04:34:24 <larryba> dminuoso, only if you stretch the definition of the word container so far that it has lost its original meaning :)
04:34:42 <adamretter___> I had seen "map" a lot in Scala and was wondering what the equivalent was in Haskell, I guess fmap is it
04:35:13 <larryba> adampretter, for example,  fmap (+10) intParser, creates a new parser that will, on succesful parse, multiply parsed Int by 10 (and if the parser fails, it will propagate error message)
04:38:19 <Ariakenom> :t \f -> fmap f show -- fmap a function
04:38:21 <lambdabot> Show a => (String -> b) -> a -> b
04:39:19 <larryba> > fmap (+1) (+2) 10
04:39:21 <lambdabot>  13
04:39:32 <larryba> > fmap (+1) (Just 10)
04:39:34 <lambdabot>  Just 11
04:40:25 <Ariakenom> fmap (div 3) [1,2,3,4]
04:40:29 <Ariakenom> > fmap (div 3) [1,2,3,4]
04:40:31 <lambdabot>  [3,1,1,0]
04:45:16 <adamretter___> Okay thanks everyone
04:53:50 <nyc> > let cubert = (**(1/3)) . fromIntegral in take 3 . filter (\(_,xs) -> length xs > 1) . map (\xs@((n,_,_):_) -> (n, nub $ map (\(_,a,b)->(a,b)) xs)) $ groupBy (\(u,_,_) (v,_,_) -> u == v) [(n,a,b) | n :: Int <- [2..], a <- [1..ceiling . cubert $ (n+1)`div`2], let b' = cubert (n-a^3), b <- [floor b', ceiling b'], a^3+b^3==n, a <= b]
04:53:53 <lambdabot>  [(1729,[(1,12),(9,10)]),(4104,[(2,16),(9,15)]),(13832,[(2,24),(18,20)])]
05:08:06 <dminuoso> lambdabot: I dont need to stretch it far really.
05:08:09 <dminuoso> Err larryba.
05:09:26 <dminuoso> larryba: So if you take some `Parser a` and think of it as some `String -> (a, String)` (or any similar encoding you want), then you could think of it as a string indexed container that can produce pairs (a, String)
05:33:46 <L29Ah> > Warning: The build command is a part of the legacy v1 style of cabal usage.
05:33:48 <lambdabot>  <hint>:1:38: error: parse error on input ‘of’
05:33:48 <L29Ah> > ...
05:33:50 <lambdabot>  <hint>:1:1: error: parse error on input ‘...’
05:33:59 <L29Ah> how do i disable this junk?
05:34:25 <dminuoso> L29Ah: Not use it?
05:34:27 <merijn> By using v2? xD
05:34:50 <L29Ah> merijn: i don't need any implicit dependence management
05:34:52 <tdammers> L29Ah: either use the new-style commands, like "cabal new-build", or explicitly say "cabal v1-install". But I'd seriously recommend the new-style commands.
05:35:30 <mouse074_> Or better yet, by changing "cabal build" to "cabal v1-build"? Especially if you want results that cabal used to provide?
05:35:34 <dminuoso> L29Ah: cabal has an old command set and a new command set. You have reached a cabal version that sends deprecation notices for the old command set.
05:36:07 <dminuoso> L29Ah: The new command set is stable and has been long tested and has almost nothing but advantages. :)
05:37:02 <L29Ah> dminuoso: how do i "cabal build" in the new command set? the linked cabal manual suggests that "new-build" does lots of undesirable work
05:37:12 <mouse074_> Depending on how consistent the packages that you're dealing with are, you may benefit from the clearer v1 logic that keeps a global (per your system and user id) database of packages that would be reused by other projects.
05:37:26 <merijn> L29Ah: What undesirable work?
05:37:29 <dminuoso> L29Ah: try `cabal v2-build` and see if it works.
05:37:29 <__monty__> L29Ah: If you want old behavior just prefix every command with v1-
05:37:33 <dminuoso> L29Ah: It should in most cases work out of the box.
05:37:39 <L29Ah> merijn: installing dependencies if they are missing
05:37:58 <dminuoso> L29Ah: It has to do this once because it works a bit differently.
05:38:05 <mouse074_> v2 will replicate packages mercilessly, and not keep that common/shared repo. There is no v2 equivalent of "v1-install".
05:38:06 <__monty__> Doesn't old-build do that too?
05:38:33 <L29Ah> i don't need "install", i only care about "configure" and "build" in fact
05:38:35 <dminuoso> mouse074_: No it does not replicate them mercilessly.
05:38:40 <L29Ah> __monty__: no
05:38:50 <dminuoso> mouse074_: cabal keeps a global store that is used for caching across projects
05:38:53 <__monty__> L29Ah: It totally does though.
05:38:56 <tdammers> v2-build installs packages, and shares versions it has already built between projects
05:39:00 <mouse074_> v2 helps you if your dependencies change like crazy, by having each weird package/module refer to its own weirdly-compiled copy of those previously built packages.
05:39:01 <Taneb> __monty__: the amound I've written "cabal install --only-dependencies" would suggest not
05:39:02 <merijn> __monty__: No, v1-build just crashes/stops when you are missing dependencies
05:39:18 <dminuoso> merijn: v2 mainly helps because it gives you *deterministic* builds.
05:39:21 <merijn> __monty__: You have to manually "cabal install --dependencies-only foo" before building
05:39:25 <dminuoso> err mouse074_ ^-
05:39:48 <mouse074_> dminuoso: in my experience it did not - because it replicated unnecessarily.
05:40:03 <dminuoso> mouse074_: If it does so, it very likely has to do something differently
05:40:06 <dminuoso> Like build them with different flags
05:40:08 <dminuoso> or different versions.
05:40:28 <mouse074_> merijn: yes, "cabal install --only-dependencies" is unpleasant - but I found it a better option than "v2-configure"
05:40:34 <__monty__> Wow, did not remember that. Don't know why that's desirable so I'm glad v2 does what I expect it to.
05:40:34 <dminuoso> In which case you will thank cabal new-* for doing this, because you have just reduced some "but it compiles on my machine" bugs.
05:41:05 <dminuoso> If v2- commands have some "it shouldn't do that" or "it seems to needlessly rebuild things", file a bug report.
05:41:15 <mouse074_> __monty__: and I'm glad v1 does what *I* expect it to. "To each his own" ;-)
05:41:36 <dminuoso> aren't v1-* style commands going to be removed at some point?
05:41:36 <merijn> mouse074_: I basically never have to v2-configure, what are you needing it for?
05:41:57 <merijn> dminuoso: 3.0 will switch to build being v2-build, not sure if/when v1-build will be removed
05:42:03 <L29Ah> okay, i hope v1-stuff is not going to be dropped easily like Data.Map.fold and other "deprecated" stuff
05:42:19 <dminuoso> L29Ah: Or just get used to v2-stuff, it really is much better across the board.
05:42:22 <merijn> L29Ah: Why? What exactly does v2-build do that you don't want?
05:42:24 <dminuoso> You shouldn't experience any negative effects.
05:42:32 <L29Ah> merijn: i told it two times already
05:42:34 <dminuoso> Other than "having to rebuild dependencies *once* for switching to v2-style"
05:42:46 <mouse074_> merijn: don't remember. Maybe going straight to "new-build". As I said, after experimenting with v2- I found that it doesn't do what I want it to, but v1- does. So I'm sticking with v1- for most of what I'm doing.
05:42:56 <dminuoso> 14:38         L29Ah | i don't need "install", i only care about "configure" and "build" in fact
05:43:03 <__monty__> merijn: For some reason they want build to fail rather than fetch missing dependencies.
05:43:12 <dminuoso> L29Ah: In order to build your package cabal needs to provide the dependencies.
05:43:25 <L29Ah> i have dependencies provided by my system-wide package manager
05:43:33 <L29Ah> and it does its job much better than cabal
05:43:33 <dminuoso> L29Ah: and that's horrid and error prone.
05:43:39 <dminuoso> If you think so, be my guest.
05:43:40 <L29Ah> so i'd prefer it to stay that way
05:44:00 <merijn> L29Ah: You must be the only person who has a working setup using system package manager for dependencies
05:44:01 <dminuoso> L29Ah: If you dont intend to build your package on any other machine, then that's probably fine.
05:44:16 <__monty__> L29Ah: You should give new/v2-build a real shot. The problems of old cabal are all gone afaik.
05:44:34 <L29Ah> __monty__: does it magically understand non-haskell dependencies or something?
05:44:41 <mouse074_> dminuoso: Whether v2- is better or not, is the matter of taste. For me it's worse, for you it's better. As for error-prone - I'm seeing as much of complaints and bug reports on Haskell forums as everywhere else.
05:45:09 <dminuoso> L29Ah: No, but neither does v1-build
05:45:17 <L29Ah> and my package manager does
05:45:17 <c_wraith> I just wished v2 properly supported working without a project.  that is a real thing that I really want to do.
05:45:24 <dminuoso> L29Ah: All v2-build does, is manage the things it *is* actually better at itself.
05:45:27 <L29Ah> i only need cabal for the stuff that i develop
05:45:50 <mouse074_> L29Ah: Haskell ecosystem uses a different paradigm, based on Haskell packages apparently being less careful about avoiding breaking changes than, e.g., in C or Java infrastructure.
05:46:24 <merijn> c_wraith: In what sense?
05:46:24 <c_wraith> Haskell packages break things every time it improves them
05:46:28 <dminuoso> mouse074_: You could argue that much of the care in those languages is attributed to being pinned to shitty package managers.
05:47:02 <mouse074_> As evidenced by the fact that practically all of the OS have some kind of package manager that doesn't need to keep a dozen of versions of the same package because each of them had (or COULD have) a small but breaking change.
05:47:04 <L29Ah> afaik cabal cannot even rebuild the stuff i use when i update my ghc
05:47:08 <c_wraith> merijn: Say I want to work in a repl with megaparsec and lens available, without creating a project.  v2 doesn't support that.
05:47:19 <L29Ah> w/o explicitly asking it to install such and such stuff
05:47:37 <dminuoso> L29Ah: cabal v2 can.
05:47:44 <dminuoso> L29Ah: you just punch `cabal v2-build` and thats it.
05:47:57 <dminuoso> it will do the right™ thing.
05:48:17 <L29Ah> does it keep track of the packages i've asked it to install earlier or smth?
05:48:22 <dminuoso> L29Ah: Yes.
05:48:41 <L29Ah> to be clear, "installed" ≠ "asked to install"
05:49:03 <c_wraith> merijn: it thinks it supports it, but it has two significant bugs that prevent it from working that they don't seem to prioritize highly
05:49:49 <mouse074_> L29Ah: the fact that you need to *explicitly* list your dependencies is not bad. The fact that in v1- cabal requires you to *explicitly* *ask* to install them, in addition to just *listing*, is annoying. But for me it's still better than not having that assured no-replication.
05:49:57 <dminuoso> L29Ah: Sure, though keep in mind that versions or build flags might differ.
05:50:20 <mouse074_> I already said what I thought about breaking changes in API.
05:50:34 <dminuoso> L29Ah: cabal v2 has a global store, but its managed very differently. Essentially you get the benfit of sandboxing like stack does but with a global store to cache build artifacts from dependencies.
05:50:39 <L29Ah> mouse074_: i don't have anything against .cabal files
05:50:41 <mouse074_> v2- is for people with unlimited disk and memory.
05:50:54 <L29Ah> they're just awesome compared to Makefiles
05:51:02 <dminuoso> L29Ah: So you get the benefit of isolation (installing things wont randomly break builds), and the benefit of reusing builds across pacakges. :)
05:52:06 <mouse074_> In my view, avoiding "randomly breaking builds" comes from tidy API, and avoidance of API breaking - which most every ecosystem and language promotes, and which majority of programmers abide by.
05:52:11 <jneira> less space that using sandboxes though
05:52:28 <mouse074_> Some programmers don't (in every ecosystem), and that creates problems. 
05:52:34 <L29Ah> 16:51:44]<mouse074_> In my view, avoiding "randomly breaking builds" comes from tidy API, and avoidance of API breaking - which most every ecosystem and language promotes, and which majority of programmers abide by.
05:52:35 <L29Ah> too bad ghc programmers don't
05:52:59 <monarch_> <L29Ah> too bad ghc programmers don't
05:53:01 <monarch_> Why not?
05:53:05 <merijn> L29Ah: How does GHC "randomly break builds"?
05:53:26 <L29Ah> 16:41:41]<L29Ah> okay, i hope v1-stuff is not going to be dropped easily like Data.Map.fold and other "deprecated" stuff
05:53:44 <L29Ah> you'd say that if base version is bumped then it's not a random breakage, ofc (:
05:53:46 <dminuoso> L29Ah: Data.Map is `containers`, not ghc.
05:53:50 <merijn> L29Ah: What does Data.Map have to do with ghc?
05:53:52 <L29Ah> oh
05:54:08 <L29Ah> i've missed when they have forked it
05:54:13 <c_wraith> more important, what did Data.Map.fold do that isn't covered by the hundreds of other folding combinators?
05:54:19 <dminuoso> The major API breaks I can think of are the on-going SMP and the AMP.
05:54:36 <c_wraith> FTP confused a lot of people who hadn't payed attention
05:54:49 <c_wraith> *paid
05:54:50 <dminuoso> Oh and that yes. :)
05:54:51 <L29Ah> ok, ghc have broken Monad.Fail recently
05:54:59 <mouse074_> GHC programmers decided that instead of restricting the API and thinking hard about what it should look like ahead of deployment, it's better to "sandbox" each version and maintain as many versions of a package on your system as there are incompatible changes. In other ecosystem a single incompatible change would require re-porting of all the dependencies, or pushing the stuff into containers.
05:55:02 <L29Ah> kudos for them for providing the migration guide though
05:55:06 <dminuoso> L29Ah: Didnt that have plenty of deprecation warnings though?
05:55:08 <merijn> L29Ah: It hasn't unless you opt in
05:55:11 <c_wraith> L29Ah: yes, but that's after 10 years off warning that it was going to happen
05:55:14 <c_wraith> *of
05:55:21 <blueflame_99> <mouse074_> GHC programmers decided that instead of restricting the API and thinking hard about what it should look like ahead of deployment, it's better to "sandbox" each version and maintain as many versions of a package on your system as there are incompatible changes. In other ecosystem a single incompatible change would require re-porting of all the dependencies, or pushing the stuff into containers.
05:55:23 <blueflame_99> ^this is sad
05:55:30 <blueflame_99> is this a sweeping generalization?
05:55:35 <merijn> Or did 8.6 force -XMonadFailDesugaring to on?
05:55:37 <c_wraith> L29Ah: not joking.  people were talking about that migration when I learned haskell in 2008.
05:55:46 <blueflame_99> i'm coming from rails, java and node.js. just started learning haskell seriously today. this is disheartening!
05:55:52 <dminuoso> blueflame_99: Ive come to really appreciate it.
05:55:58 <L29Ah> merijn: 8.6.3, yeah
05:56:00 <dminuoso> blueflame_99: It makes builds deterministic and predictable.
05:56:14 <c_wraith> blueflame_99: given how awful most rails apis are, I'd think you'd appreciate being willing to move away from wrong designs. :P
05:56:15 <L29Ah> or 8.6 in general
05:56:20 <merijn> blueflame_99: I disagree with that reading, tbh
05:56:20 <dminuoso> blueflame_99: And since you come from `rails`, think of Bundler. Since you come from `JS`, think of yarn.
05:56:20 <L29Ah> i'm not sure now
05:56:35 <mouse074_> blueflame_99: yes, it's a generalization - but it does seem to be rooted in reality, even if it exaggerrates somewhat.
05:56:44 <dminuoso> blueflame_99: The idea of sandboxing to create *predictable* builds is not new, and I do not think it's bad. :)
05:57:07 <c_wraith> blueflame_99: and I work in rails daily.  It's not fad hate.  It's how years of rails development have made me.
05:57:08 <blueflame_99> dminuoso, interesting, i see, so it's VERSIONED, but the api changes through versions?
05:57:09 <merijn> blueflame_99: The core problem is: Different projects have different, not necessarily comatible dependencies.
05:57:15 <dminuoso> L29Ah: https://wiki.haskell.org/MonadFail_Proposal#Transitional_strategy
05:57:32 <L29Ah> 16:54:40]<L29Ah> kudos for them for providing the migration guide though
05:57:33 <merijn> blueflame_99: So you have two options: 1) you can only ever have one project you work on, or 2) you ensure dependencies of separate projects cannot conflict
05:57:50 <blueflame_99> c_wraith, absolutely, totally understand what you're saying re: rails :-) java saved my
05:57:53 <blueflame_99> c_wraith, absolutely, totally understand what you're saying re: rails :-) java saved me
05:57:55 <mouse074_> IMHO, sandboxing (meant as "taking every dependency and creating a frozen copy of it") is good if used sparingly. It's bad if it's the mainstream approach.
05:58:00 <merijn> blueflame_99: cabal v1 basically forced 1) (unless you manually sandboxed), cabal v2 defaults to 2
05:58:03 <dminuoso> L29Ah: So in 8.4 warnings were added, 8.6 changed from opt-in to opt-out.. so you have a really soft transitioning that shouldn't break your code for any reason other than not caring to add one line of code. :P
05:58:26 <blueflame_99> merijn, do different projects allow different versions of the same dependency?
05:58:35 <dminuoso> blueflame_99: In v2 yes.
05:58:43 <L29Ah> dminuoso: and less than a year have passed
05:58:43 <blueflame_99> understood, i installed v2
05:58:53 <L29Ah> most hackage packages don't update that often in fact!
05:58:53 <merijn> blueflame_99: If that's how you configured your projects, yes.
05:59:08 <blueflame_99> merijn, that is encouraging
05:59:14 <L29Ah> i didn't even had 8.4 on my computers
05:59:35 <mouse074_> blueflame_99: Yes, it appears they do. For some it's an added convenience of not having to port their stuff to a new version, because the "old" stuff is supposed to still be around. 
05:59:37 <dminuoso> L29Ah: For what its worth, the changes were kind of important though. :)
05:59:40 <merijn> blueflame_99: Basically, v2 approach is: Look at a projects constraints (ignoring all other installed packages), solve the dependency graph, then build and install all dependencies needed
05:59:46 <sm> morning all. I'm a bit stuck, can you see why https://hastebin.com/iyenukapul.bash line 16 is giving that error ?
05:59:57 * hackage salak 0.1.7 - Configuration Loader  http://hackage.haskell.org/package/salak-0.1.7 (leptonyu)
06:00:12 <blueflame_99> mouse074_, thanks for the comments, it sounds like you'd have to be careful in how you manage your project's packaging system
06:00:17 <merijn> blueflame_99: If the exact same version (not just actual version, also flags, etc.) of a dependency already exists, that gets used. If not, it installs something new
06:00:27 <sm> (can't match types due to "rigid type variable")
06:00:31 <L29Ah> i get it with AMP, but fail is just uh, does anyone even use it?
06:00:49 <merijn> blueflame_99: No, the point of v2 is that you no longer have to give a shit about how you package/specify projects
06:01:04 <blueflame_99> merijn, that sounds like yarn/node
06:01:09 <__monty__> blueflame_99: v2 as in v2-build, v2-configure, etc. Not version 2 of cabal-install.
06:01:14 <mouse074_> Yes, absolutely. But there's no free lunch - you pay either way. Only question - what exactly you prefer to buy. ;-)
06:01:20 <blueflame_99> __monty__, ah!
06:01:50 <dminuoso> sm: What is `f`?
06:02:14 <dminuoso> sm: Thetype signature looks a bit fishy.
06:02:39 <blueflame_99> are there libraries that are only v1 compatible, but not v2 compatible?
06:02:55 <dminuoso> sm: Oh! Nevermind I spotted it.
06:02:56 <blueflame_99> i.e. if i have a v2 project, do i have to worry about whether there are dependencies that will work with my v2 project?
06:03:03 <__monty__> blueflame_99: No, that's not how it works.
06:03:04 <sm> dminuoso: aha.. I changed the type of f to (forall st. st -> x) (adding the forall) and added Rank2Types pragma
06:03:13 <sm> sounds ok ?
06:03:20 <blueflame_99> yknow what -- i'm still young at this, i'll RTFM about v2/v1 :-)
06:03:53 <sm> ghc is happy at least
06:04:11 <__monty__> blueflame_99: In theory you could write code that depends on old-cabal's created directories but this is just a build system. It's like wondering whether make vX is compatible with code normally developed with make vY.
06:04:13 <dminuoso> sm: Yes that looks about right.
06:04:41 <mouse074_> blueflame_99: in v2- it will track and install what you need. My only issue with that it that it installs more than I want to.
06:05:19 <__monty__> mouse074_: Are you sure? With v1-* it'd probably have led to conflicts.
06:05:30 <blueflame_99> __monty__, gotcha ty. mouse074_ , sounds a LOT like npm!
06:05:49 <mouse074_> __monty__: yes it is, at least in my experience. Unless you mean trying to run make vN on a Makefile written for make v(N+K) with K large "enough"
06:05:52 <Clint> sm: was that only happening with ghc 8.6?
06:05:53 <dminuoso> sm: Although there's something still off I think. `st` is ambiguous if you do that.
06:06:05 <mouse074_> __monty__: npm is OK ;-)
06:06:06 <blueflame_99> mouse074_, so if i ever want to build a slim library, i'd use v1 by the sound of it
06:06:37 <__monty__> blueflame_99: No, definitely not.
06:06:48 <dminuoso> blueflame_99: You lose nothing by using v2 really. :)
06:06:50 <__monty__> If you're just now getting into haskell just forget v1-* even exists.
06:06:56 <mouse074_> Probably - and if that library doesn't need to go to other machines that don't have Haskell installed, you can probably request dynamic build.
06:07:40 <dminuoso> blueflame_99: cabal v2 will resolve the dependency graph, figure out what packages need to be there. it then goes to its global store, sees if they are build with the right flags.
06:07:56 <dminuoso> blueflame_99: if yes, it will reuse those, if not it will build them, put them into the global store, and them use them to build your project.
06:08:16 <mouse074_> __monty__: v1- vs. v2- depends on how much you prefer a global (for your machine) package repo where everything plays nicely together, as opposed to sandboxing everything and not caring how nice the different package versions are to each other.
06:08:33 <__monty__> mouse074_: What my make reference was about was think of a super simple makefile that just runs a compiler on your code. It doesn't matter what version of make you run that makefile with. So too with cabal v1-*/v2-*, except v2-*'ll work even if you already built other projects with conflicting dependency versions.
06:08:35 <dminuoso> mouse074_: v2 will sandbox your projects.
06:08:35 <sm> Clint: I've only compiled it with 8.6 so far. dminuoso: hmm, yes. Though it compiles, I get another rigid type var error when I call it with a specific f
06:08:48 <dminuoso> sm: I think your type signature is off.
06:09:05 <sm> (I mean, the definition compiles, the call doesn't)
06:09:06 <mouse074_> dminuoso: *exactly*!
06:09:31 <dminuoso> mouse074_: so you get the benfit of sandboxing, but without having to rebuild everything for separate projects.
06:09:37 <dminuoso> so you lose nothing if you use v2 for a single project
06:09:46 <dminuoso> but you gain everything if you have more than 1 project on your machiine.
06:09:49 <__monty__> mouse074_: You claimed the problem with v2 was it installs too much but if you're using v1 sandboxing you're installing strictly *more* stuff.
06:10:10 <mouse074_> dminuoso: true, but who on Earth has only one/single project?! 
06:10:22 <dminuoso> mouse074_: :)
06:10:25 <mouse074_> And in general I do *not* sandbox. 
06:10:35 <dminuoso> mouse074_: cabal does it transparently for you.
06:10:47 <mouse074_> Which is why I'm sticking to v1- that doesn't.
06:10:55 <__monty__> mouse074_: Then you get conflicts with v1, where v2'll just install the conflicting version as if it's sandboxed.
06:11:01 <dminuoso> __monty__: with v1 you will break projects.
06:11:13 <dminuoso> err mouse074_. Imagine you recompile something without profiling flags.
06:11:15 <mouse074_> That is correct - "you pays your money and you makes your choice"
06:11:20 <kuribas`> we should have more tooling support around versioning.
06:11:39 <kuribas`> like checking if versions are correct.
06:11:49 <hpc> some kind of api-aware tool that tells you how major your changes are would be pretty neat
06:11:59 <sm> dminuoso: https://hastebin.com/wayeceriji.shell is just the type signature, cleaned up.. are you saying there's a problem in this ?
06:12:02 <Clint> yeah, an api checker
06:12:37 <dminuoso> sm: Is it possible you wanted to have: StateT st (ParsecT CustomErr st IO) a -> st -> (st -> x) -> x -> E.Text ()` ?
06:12:58 <dminuoso> (Not sure whether that will type check with your customErrorBundlePretty since I dont know that ones type)
06:13:55 <dminuoso> Or wait no. Where does the `State T.Text` come from?
06:13:58 <__monty__> There's this, not sure how well it works though: http://hackage.haskell.org/package/precis
06:14:30 <sm> dminuoso: no.. I'm parsing Text, and the concrete state type is Journal
06:14:50 <sm> maybe making it monomorphic in st will hlep
06:15:33 <dminuoso> sm: Just a random thought.. but can GHC infer the type of expectParseStateOn?
06:15:53 <sm> I'll check
06:16:16 <dminuoso> sm: Though I can see why it wont type check. Let me connect all the dots now. :)
06:16:25 <sm> it can! 
06:17:30 * sm contemplates the types
06:18:28 <dminuoso> sm: Is it something along the lines of `(Monoid st, Eq x, HasCallStack) => StateT st (ParsecT CustomErr T.Text IO) a -> (State T.Text -> x) -> x -> E.Text ()` ?
06:18:50 <sm> it's inferred as https://hastebin.com/nodajivono.coffeescript
06:18:55 <hpc> that precis package looks like it only works down to the level of modules
06:19:12 <hpc> if you make breaking changes within a file, as long as the files themselves stay the same it doesn't notice changes
06:19:17 <dminuoso> sm: That's pretty close.
06:19:31 <hpc> oh wait, nvm
06:19:32 <dminuoso> sm: I think you have a wrong type of `runParserT'` in mind.
06:19:41 <hpc> http://hackage.haskell.org/package/precis-0.5.0/docs/Precis-ModuleProperties.html
06:20:01 <sm> https://hackage.haskell.org/package/megaparsec-7.0.4/docs/Text-Megaparsec.html#v:runParserT-39- 
06:20:11 <sm> perhaps I'm mixing up StateT and megaparsec's State
06:20:35 <dminuoso> sm: Yeah
06:20:48 <dminuoso> sm: You just get the parser state back after the parser has run.
06:20:54 <dminuoso> Which is just https://hackage.haskell.org/package/megaparsec-7.0.4/docs/Text-Megaparsec.html#t:State
06:21:42 <hpc> also last updated 2010
06:22:06 <hpc> i guess if someone is sufficiently motiviated, they can take that package as a proof of concept and make something better
06:22:07 <dminuoso> sm: what is `f` supposed to do?
06:22:09 <sm> it's complicated by my monadic parser layers.. at least IO, StateT are involved somehow
06:22:21 <sm> having a really hard time reading this code
06:22:34 <dminuoso> sm: extract the "actual" obtained thing from the parser?
06:22:46 <sm> it's supposed to extract part of the final parse state. I want to test the state, not the parsed value
06:23:20 <dminuoso> sm: `s` *is* the parse state.
06:23:29 <sm> yep
06:23:46 <sm> and I want to test just part of that, since the whole state is too complicated
06:23:55 <sm> f selects one field
06:24:22 <dminuoso> runParserT' :: Monad m => ParsecT e s m a -> State s -> m (State s, Either (ParseErrorBundle s e) a)
06:25:02 <dminuoso> But you give it some `(ParsecT CustomErr T.Text IO)`
06:26:07 <sm> you're right, that sounds wrong. I copied that from other type sigs which compile
06:26:20 <sm> yeah, good catch!
06:28:04 <sm> I think
06:28:56 * sm wonders why ParsecT is called that, and if it's a monad transformer.. I think not
06:29:13 <sm> no, it is
06:29:25 <Taneb> sm: in the parsec library, ParsecT is a monad transformer, although it's very rarely used as such
06:30:55 <sm> I'll have to come back to this in a bit. Thanks for all the help. I'll post the outcome
06:32:49 <sm> just for context, http://hackage.haskell.org/package/hledger-lib-1.12/docs/Hledger-Utils-Test.html#v:expectEqPP are the working functions I'm trying to extend
06:40:51 <dminuoso> type HasCallStack = ?callStack :: CallStack
06:40:58 <dminuoso> expectEqPP :: (Eq a, Show a, HasCallStack) => a -> a -> Test ()
06:41:05 <dminuoso> What deep black magic is this HasCallStack?
06:41:21 <merijn> dminuoso: Compiler builtin voodoo
06:41:45 <merijn> dminuoso: Basically "Please generate a callstack here for use in stacktraces"
06:42:12 <dminuoso> merijn: I suppose this could incur a rather costly penalty?
06:42:47 <merijn> dminuoso: It shouldn't. It's done compile time, but you have to propagate it up in every call, which can be annoying to retrofit
06:43:21 <dminuoso> merijn: I mean, the ability to generate stack traces, isn't that an optimization boundary?
06:43:44 <merijn> dminuoso: Why?
06:44:53 <dmwit> It incurs the same costs that other classes do.
06:45:13 <dmwit> So don't stick one on that memoization table you want to compute just once.
06:45:20 <__monty__> So it doesn't prevent specializing?
06:46:11 <dminuoso> merijn: Oh I think I misunderstood the primitive.
06:46:46 <dminuoso> dmwit: gotcha
07:06:27 * hackage tomland 1.0.0 - Bidirectional TOML serialization  http://hackage.haskell.org/package/tomland-1.0.0 (shersh)
07:07:27 * hackage yam 0.5.8 - Yam Web  http://hackage.haskell.org/package/yam-0.5.8 (leptonyu)
07:08:57 * hackage yam-datasource 0.5.8 - Yam DataSource Middleware  http://hackage.haskell.org/package/yam-datasource-0.5.8 (leptonyu)
07:52:58 <freusque> I'm a bit lost in my use of Linear
07:53:08 <freusque> I'm trying to implement a simple L1 projection
07:53:11 <freusque> https://gist.github.com/freuk/5d5361c37074bd99808b96d95c278e54
07:53:31 <freusque> the one in figure 2 from https://stanford.edu/~jduchi/projects/DuchiShSiCh08.pdf
07:54:06 <freusque> I'd like to access the "v x" via index, and I don't know what's the standard way to do this
07:55:08 <freusque> perhaps you might have an idea of how to answer that bgamari 
07:56:08 <freusque> or jle` , I think you've done similar things?
08:00:38 <asheshambasta> Just asking if anyone is aware: do we have any kind of memory leaks in GHC 8.4.4? 
08:01:14 <asheshambasta> I'm working on a program with something like 40 modules and GHC is consuming about 5GB of memory 
08:02:07 <asheshambasta> restarting ghci seems to fix the huge memory issue, but only temporarily 
08:02:47 <merijn> asheshambasta: Any of them have a datatype with a huge number of constructors that is deriving typeclasses?
08:03:21 <asheshambasta> Yes, http://hackage.haskell.org/package/iso639-0.1.0.3/docs/Data-LanguageCodes.html
08:03:55 <merijn> asheshambasta: There was a longstanding bug where deriving for data with huge numbers of constructors was SUPER slow and memory hungry
08:04:00 <merijn> I'm not sure whether that's been fixed
08:04:13 <asheshambasta> I'm deriving stuff for a type alias to the `ISO639_1` datatype 
08:04:23 <asheshambasta> ah okay, that seems unfortunate 
08:05:15 <hpc> oh wow, that's a shame
08:05:35 <merijn> asheshambasta: https://ghc.haskell.org/trac/ghc/ticket/10980
08:06:31 <merijn> asheshambasta: I can think of a few work arounds
08:07:20 <Boarders> what is the purpose of the flag --copy-bins in stack
08:07:32 <Boarders> does it put the binary of your project into some globally accessible store?
08:07:32 <merijn> asheshambasta: The most obvious one being to replace it with a "newtype ISO639 = ISO639 (Char, Char)" or similar, which avoids the deriving, but whether that's acceptable to you depends on your usecase
08:07:58 <asheshambasta> merijn: That issue is 3 years old! I'd love to get my hands dirty with stuff like this, but I know GHC is a behemoth to understand, leave alone for a noob like myself. 
08:08:17 <merijn> asheshambasta: GHC isn't so bad if you avoid the type system, tbh
08:08:33 <merijn> asheshambasta: But I assume it's a tricky problem, considering how crippling it can be and no one has solved it yt
08:09:33 <asheshambasta> yeah, that kind of workaround is also what I had in mind 
08:09:36 <merijn> asheshambasta: If replacing the representation is unacceptable for some reason, you could try generating code for the instances yourself instead of relying on GHCs deriving mechanism
08:09:55 <merijn> That way you could keep the constructors
08:10:41 <merijn> asheshambasta: It looks like especially Ord is super costly
08:11:04 <merijn> asheshambasta: But you can manually write an Ord instance that's equivalent and orders of magnitude less code :p
08:11:46 <merijn> asheshambasta: "instance Ord ISO639 where compare = comparing show"
08:11:58 <merijn> Since your constructors are alphabetically ordered anyway
08:12:39 <asheshambasta> merijn: yeah, good point, although in this case I was just deriving a Generic for this type, which I can do without 
08:14:07 <Solonarv> Boarders: yes, that is exactly what that flag means
08:14:24 <Boarders> Solonarv: thank you
08:14:30 <asheshambasta> merijn: a related question: how much more expensive is it to deal with String vs. Text? If the string is small (in this case the 2 char. lang. code), isn't the performance delta almost negligible? 
08:14:46 <merijn> asheshambasta: Depends on how many you have
08:15:29 <asheshambasta> how many of? 
08:15:39 <Solonarv> It's weird that Ord is slow when it could just be 'compare = comparing dataToTag' (for enum types)
08:15:54 <merijn> asheshambasta: how many strings/texts
08:16:12 <merijn> Solonarv: I don't think GHC special cases that
08:16:17 <Solonarv> Boarders: `stack path --local-bin` tells you where the binaries are copied by default
08:16:22 <dminuoso> asheshambasta: Do you have a reason to use String over Text?
08:16:25 <Solonarv> merijn: yeah, that's why I said "could"
08:17:04 <merijn> asheshambasta: Also, since your language codes are all ASCII you could use a ShortByteString instead. That's cheaper than Text and String for sure
08:17:25 <dminuoso> asheshambasta: You could also encode the country code with an ADT.
08:18:06 <asheshambasta> in the case of my problem above, yes. I was deriving a Generic instance for this type with a large no. of constructors, to be able to derive ToJSON and FromJSON instances for it automatically (albeit that means I was blind to what was goind on under the hood). Now, since that is no longer an option, I'm writing a ToJSON by hand where `toJSON = toJSON . T.pack . show` 
08:18:49 <asheshambasta> or a `parseJSON = fromText "foo" (\t -> either fail return . readEither $ t)
08:19:14 <asheshambasta> in this case, I'm stuck with having to use `readEither`
08:29:32 <kuribas`> yeah, it sucks that the standard type classes use String, not Text.
08:29:53 <kuribas`> And conversion isn't for free
08:33:21 <kuribas`> well, there is: http://hackage.haskell.org/package/text-show-3.7.5/docs/TextShow.html
08:35:24 <dminuoso> Mmm, couldn't GHC steal string buffers when using `T.pack . show`?
08:35:36 <dminuoso> Or is it too naive to expect that to happen?
08:38:06 <merijn> dminuoso: Fusion rules do that for literals, but not in general
08:59:08 <aramiscd> Hey, could someone briefly tell me what the ghc flag -Wsafe is for?  Is it related to Safe Haskell as in https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/safe_haskell.html ? Why would I ever want this to be a compiler warning/error?
09:01:09 <kuribas`> aramiscd: "Should be used to check the safety type of modules when using safe inference."
09:01:18 <kuribas`> aramiscd: I think it's more information than warning.
09:01:56 <aramiscd> kuribas`: Thanks.  Where is this quote from?
09:02:03 <kuribas`> aramiscd: ghc documentation
09:02:30 <kuribas`> aramiscd: that page you linked
09:02:47 <aramiscd> I see :-)
09:11:59 <Boarders> does anyone know how I pass test arguments to cabal
09:12:13 <Boarders> i.e. the equivalent of stack build --test --ta "[test flags here]"
09:23:15 <kuribas`> can ghc "see" that local variables can be garbage collected right away?  Or even putting them on the stack?
09:25:04 <[exa]> kuribas`: "local" "variables"?
09:25:28 <kuribas`> [exa]: let bindings...
09:25:36 <kuribas`> function arguments...
09:25:42 <Boarders> instead of the above I should ask: how can I use --test-option with cabal new-test?
09:26:03 <Boarders> I get back "cabal: unrecognized 'new-test' option `--test-option=rerun-filter=failures'"
09:26:27 * hackage haskell-gettext 0.1.2.0 - GetText runtime library implementation in pure Haskell  http://hackage.haskell.org/package/haskell-gettext-0.1.2.0 (IlyaPortnov)
09:26:34 <[exa]> kuribas`: function arguments are taken from other parts of the program, these are not local. But it applies to let bindings. I guess that it can add some heuristic to GC if it sees that the thunks will be collectible
09:26:35 <Boarders> (this is how it specifies to pass arguments to cabal on the hspec website but it doesn't say what to do about cabal new)
09:27:22 <[exa]> kuribas`: anyway there's usually a completely orthogonal and much more effective 'nursery-style' approach right in the GC for optimizing this kind of stuff
09:28:00 <[exa]> kuribas`: btw, from another viewpoint, the program should not create GC-able objects if it knows the GC won't be needed
09:28:27 <[exa]> (s/program/compiler/)
09:32:26 <Boarders> what do people use to build a local hoogle data base for their project?
09:34:04 <Welkin> the hoogle command
09:41:27 <iqubic> I might be blind as a bat, but there's a function that I'm just not seeing.
09:42:08 <iqubic> Is there any way to tell megaparsec to use parser p 1 or more times?
09:42:33 <Clint> yes
09:42:54 <koala_man> iqubic: 'some'?
09:42:57 <iqubic> Right... I'm switching from Parsec to Megaparsec.
09:43:22 <iqubic> I was looking for a function called many1. I was not looking for a thing called some.
09:43:30 <koala_man> the equivalent of many1 would be some
09:43:52 <koala_man> it's admittedly a better name
09:44:08 <iqubic> I know. It just didn't occur to me that the name would change.
09:44:27 <koala_man> what motivated the migration?
09:44:43 <iqubic> people said that parsec was old and not well maintained.
09:45:03 <iqubic> And I haven't written that much parsing code, so switching isn't a big pain.
09:47:31 <travv0> iqubic: I just saw this yesterday, might be of use: https://markkarpov.com/megaparsec/switch-from-parsec-to-megaparsec.html
09:52:42 <dminuoso> iqubic: You could use `some/many` for Parsec too.
09:52:54 <iqubic> I didn't know that.
09:53:01 <dminuoso> :t some
09:53:02 <lambdabot> Alternative f => f a -> f [a]
09:53:03 <dminuoso> :t many
09:53:04 <iqubic> I'm still switching to megaparsec.
09:53:04 <lambdabot> Alternative f => f a -> f [a]
09:53:13 <dminuoso> iqubic: They are just standard base functions for dealing with Alternative.
09:53:27 <iqubic> I don't understand how those work with things other than parsers TBH.
09:53:58 <iqubic> So you're telling me that these functions work with all Alternatives? https://hackage.haskell.org/package/parser-combinators-1.0.0/docs/Control-Monad-Combinators.html
09:54:06 <dminuoso> iqubic: They only make sense if they have some notion of "changing state" that could at some point converge into empty.
09:54:22 <iqubic> I see. Which ParsecT does.
09:56:35 <dminuoso> iqubic: Right or more generally `State/StateT` if you think of ParsecT as some moral equivalent of `Parser = StateT String []`
09:56:48 <kuribas> [exa]: sure, but it has to keep the objects somewhere in memory?
09:56:51 <kuribas> [exa]: does it have storage for non-gc'able objects?
09:56:56 <kuribas> [exa]: like stack in other languages?
09:57:34 <Solonarv> kuribas: there is a stack, but it's only used during evaluation
09:58:21 <Solonarv> objects which will never be GCed can be moved into compact regions (this must be done explicitly by the programmer), and will also eventually end up in a region that the GC doesn't check very often
09:59:33 <dminuoso> 18:53        iqubic | So you're telling me that these functions work with all Alternatives? https://hackage.haskell.org/package/parser-combinators-1.0.0/docs/Control-Monad-Combinators.html
09:59:35 <Solonarv> objects which are discarded immediately still have to be freed somehow, and this is done by the GC, but the GC used by GHC is quite good at handling such short-lived objects
09:59:36 <dminuoso> iqubic: Look at the type signatures
10:00:04 <dminuoso> iqubic: For reasons I dont understand the author of parser-combinators has chosen to implement some/many in terms of MonadPlus, but that is not necessary.
10:00:07 <kuribas> Solonarv: so they don't have to be marked first?
10:00:32 <kuribas> Solonarv: I suppose it only marks "live" objects...
10:01:18 <Solonarv> kuribas: I'd recommend reading the GHC commentary: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC
10:01:20 <dminuoso> kuribas: GHC uses a generational, two-space moving, stop-the-world garbage collector.
10:01:31 <[exa]> kuribas: IIRC there are registers for stack-like stuff; suggest seeing the SPJ's paper in STG
10:01:37 <sm> dminuoso: I was mixing up the state types, indeed - fixed version: https://hastebin.com/komuzecipu.sql
10:01:43 <[exa]> *on
10:02:10 <geekosaur> backward compatibility?
10:02:21 <kuribas> [exa]: I need to know this stuff for my lisp coworker, who believes that immutable is inefficient :)
10:02:45 <dminuoso> sm: That looks wrong still, does this type check?
10:02:53 <sm> yup
10:03:27 * hackage ttl-hashtables 1.2.0.0 - Extends hashtables so that entries added can be expired after a TTL  http://hackage.haskell.org/package/ttl-hashtables-1.2.0.0 (erick)
10:03:30 <[exa]> kuribas: I don't know how to answer that kind of question in context of a liked-list-eating machine... :D
10:03:32 <sm> I should have stuck with runParserT, runParserT' was a mistake
10:03:57 <kuribas> [exa]: we don't have any lisp machines though :)
10:04:03 <sm> and evalStateT has changed to execStateT 
10:04:04 <dminuoso> sm: The reason this looks wrong is:
10:04:24 <kuribas> [exa]: in the context of lisp it is probably less efficient
10:04:51 <dminuoso> sm: runParserT :: Monad m => ParsecT e s m a -> String -> s -> m (Either (ParseErrorBundle s e) a)
10:05:20 <[exa]> kuribas: lisps usually don't have any optimizer or static analysis, immutability is just a fancy thing in there
10:05:50 <dminuoso> sm: Oh! I finally understand how `f` is supposed to work! Nevermind, my mind was stuck in your mistake still.
10:05:57 <sm> \o/
10:06:06 <dminuoso> sm: I somehow thought that `st ~ T.Text` 
10:06:32 <sm> it was very very easy to mix up the two states
10:07:57 <dminuoso> @tell iqubic Yes those primitives from parser-combinators work with any Alternative, though for perhaps historic reasons the author requires MonadPlus on some combinators which imposes an (unnecessarily) stronger constraint.
10:07:58 <lambdabot> Consider it noted.
10:09:06 <fr33domlover> IORef vs MVar: If in my web app request handlers need to read from a shared resource (almost every request needs it, and resource gets changed once an hour or so), should I use IORef or MVar (or TVar?) to hold the resource?
10:09:06 <sm> especially as the outer state and megaparsec's internal state only recently became separate
10:09:46 <hpc> MVar
10:10:24 <hpc> don't rely on IORef happening to be correct
10:10:31 <fr33domlover> hpc, what happens if I use IORef? I've had issues with IORef in concurrent code but I'm not sure why, like, I don't understand the theory of it
10:10:33 <hpc> or TVar is probably better here actually
10:11:26 <hpc> so fundamentally, your problem is a shared resource being accessed concurrently by several things
10:11:38 <hpc> with MVar, one thing takes the resource
10:11:42 <hpc> now it's not there for anything else
10:11:57 <kuribas> [exa]: I think sbcl has
10:12:02 <hpc> MVar takes care of that taking and putting back being safe, and now your code works with no problem
10:12:07 <hpc> with IORef, it just changes
10:12:32 <hpc> do {x <- readIORef r; y <- readIORef r; ...} -- in this, x and y are not guaranteed to be the same
10:12:52 <hpc> it doesn't look like it with IORef, but you're double-taking the ref and that's a concurrency bug
10:12:57 <hpc> with MVar, a double take is a deadlock
10:13:18 <hpc> so hidden concurrency bugs become guaranteed sequential bugs
10:13:38 <hpc> so, the difference between TVar and MVar, and why you probably want TVar here
10:13:54 <hpc> MVar is bad when there is lots of contention, because only one thing can work on the value at a time
10:14:18 <hpc> with transactions, you can do as many reads at once as you feel like, and it's just writes that fight with each other
10:14:36 <hpc> so for most of the hour it's as if you're using IORef absolutely perfectly
10:14:40 <hpc> no mistakes in your code at all
10:15:08 <hpc> then when the resource is changed, it changes consistently for everyone, no matter how complex your modification is
10:15:31 <hpc> if it changes in the middle of a read's operation, it retries
10:16:27 <hpc> i would go so far as to say you never want to use IORef
10:16:39 <hpc> there's always a domain-specific reference type that's better
10:16:46 <hpc> MVar, TVar, STRef
10:16:49 <hpc> the FFI pointer types
10:18:35 <fr33domlover> hpc, oh I see! Them Tvar is definitely the best here. In general I have another option, to hold the value in the web server and pass it as a regular function parameter to request handlers when they start running on new threads. But idk if I can do that in e.g. Yesod, like, does it allow to put state there. I'm guessing not, in which I'll use the TVar ^_^ and see if it's worth adding a feature in the relevant
10:18:37 <fr33domlover> place
10:19:22 <Solonarv> are you planning to have a top-level (global) TVar?
10:20:43 <hpc> avoid writing a global TVar too, unless you have a crazy weird special case (which you shouldn't for just web stuff)
10:20:48 <fr33domlover> Solonarv, nope
10:20:51 <hpc> worst case, create it in main and curry it into stuff
10:21:15 <c50a326> is hoogle.haskell.org down? https://hoogle.haskell.org/?hoogle=scanr
10:21:30 <fr33domlover> I'll create the TVar in IO
10:21:30 <c50a326> I can't resolve it, might just be me
10:21:36 <hpc> back up
10:21:43 <hpc> if it was down
10:21:53 <hpc> maybe some random isp thing
10:22:01 <hpc> scanr :: (a -> b -> b) -> b -> [a] -> [b]
10:22:02 <hpc> base Prelude, base Data.List
10:22:04 <cocreature> I should ask neil at some point why it tends to be down for short time frames quite often
10:22:31 <c50a326> was just wondering why scanr is defined there, but foldr is defined in Data.Foldable... and scanr doesn't have the Foldable constraint, it's only for lists...
10:23:18 <cocreature> c50a326: you can’t implement a scanr that returns a Foldable
10:23:29 <cocreature> you could implement one that consumes a Foldable and returns a list
10:23:35 <c50a326> (and I don't think it's down, it's some problem to do with my own connection I suppose, I can't resolve the name, something up with the dns servers my isp is giving me)
10:23:36 <cocreature> but that’s probably just not that useful of an operation
10:23:57 <hpc> maybe with Traversible
10:24:39 <cocreature> Traversable doesn’t give you a way to construct a data structure either. you can only replace the contents
10:24:47 <cocreature> > scanr (+) 0 []
10:24:49 <lambdabot>  [0]
10:24:52 <cocreature> scanr does more
10:24:58 <hpc> ah right
10:25:32 <nshepperd> you could do scanr1 with traversable
10:26:54 <cocreature> yeah but it’s kind of awkward to have scanr1 for traversable but not scanr
10:27:13 <hpc> > scanr1 (+) []
10:27:15 <lambdabot>  []
10:27:50 <nshepperd> it's only a problem because scanr appends the initial value to the end of the list, which increases the size by 1
10:27:57 <nshepperd> you can just not do that
10:28:04 <hpc> [scanr1 (+), scanr (+) 0] <*> [[], [1, 2, 3]]
10:28:09 <hpc> > [scanr1 (+), scanr (+) 0] <*> [[], [1, 2, 3]]
10:28:11 <lambdabot>  [[],[6,5,3],[0],[6,5,3,0]]
10:28:43 <hpc> > [scanl1 (+), scanl (+) 0] <*> [[], [1, 2, 3]]
10:28:44 <lambdabot>  [[],[1,3,6],[0],[0,1,3,6]]
10:29:48 <hpc> if you described the scan functions without any specifics, scanl1 is the behavior i would expect
10:30:28 <hpc> i wouldn't mind having that for Traversible
10:30:36 <cocreature> scanl1' ;)
10:30:43 <hpc> heh
10:31:04 <cocreature> ahrg, there is no scanl1' in base :(
10:31:11 <cocreature> at least there is a scanl'
10:34:13 <fr33domlover> hpc, even if I used readMVar, it would have to be one-thread-at-a-time?
10:34:33 <Solonarv> there's a peekMVar which takes the value out and puts a copy back in
10:34:40 <nshepperd> :t scanr1Of traverse
10:34:41 <lambdabot> Traversable t => (b -> b -> b) -> t b -> t b
10:34:50 <nshepperd> > scanr1Of traverse (+) [1, 2, 3]
10:34:52 <lambdabot>  [6,5,3]
10:35:03 <hpc> that should be fine
10:35:15 <hpc> see the compatibility note though
10:35:17 <Solonarv> > scanl1Of traverse (+) [1..]
10:35:19 <lambdabot>  [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276...
10:35:27 <Solonarv> neat!
10:35:33 <wroathe> fr33domlover: https://en.wikipedia.org/wiki/Synchronization_(computer_science)#Thread_or_process_synchronization this might help
10:39:17 <nshepperd> @let scanrOf l f z = snd . mapAccumROf l (\acc a -> join (,) (f a acc)) z
10:39:18 <lambdabot>  Defined.
10:39:23 <fr33domlover> wroathe, thanks :)
10:39:29 <nshepperd> > scanrOf traverse (+) 10 [1, 2, 3]
10:39:31 <lambdabot>  [16,15,13]
10:40:05 <fr33domlover> hpc, hmm so if I use readMVar from many threads, and once an hour one specific dedicated thread does swapMVar, looks like MBar could be a good solution?
10:40:07 <fr33domlover> *MVar
10:40:27 <hpc> yeah
10:40:42 <fr33domlover> The only weirness if that I never need the MVar to be empty, always holds a value
10:40:47 <Solonarv> hm, actually you might run into issues if the threads put the value back in the MVar
10:40:48 <fr33domlover> *weirdness
10:40:51 <fr33domlover> *is
10:40:56 <hpc> it's a bit like using the thread-safety of modifying an IORef though, it's possible but just outside the intended use of the type
10:41:16 <Solonarv> I think TVar might be more straightforward
10:41:38 <fr33domlover> Solonarv, but only 1 dedicated thread in my code ever changes the MVar
10:41:48 <fr33domlover> All the other threadds do readMvar and nothing more
10:41:51 <nshepperd> @let scanrOf2 l f z = snd . mapAccumROf l (\acc a -> (f a acc, acc)) z
10:41:52 <lambdabot>  Defined.
10:41:57 <nshepperd> > scanrOf2 traverse (+) 10 [1, 2, 3]
10:41:59 <lambdabot>  [15,13,10]
10:42:20 <Welkin> why doesn't `cabal new-run` work anymore in cabal 2.4.1.0?
10:42:42 <Welkin> when I run it all that happens is new-build
10:42:47 <Welkin> it never runs the executable
10:42:59 <Solonarv> MVar still has a footgun where: some thread takes from the mvar, dedicated thread puts into the mvar, first thread puts back the old value
10:43:30 <Solonarv> you can avoid this by using {read,swap}MVar, but that same "use the right operations" argument applies to IORef
10:43:54 <fr33domlover> Solonarv, but no thread ever takes the MVar in my case
10:44:04 <tdammers> MVar has the added benefit that it has a way of saying "don't touch this, I'm working on it"
10:44:06 <hpc> every thread takes, just a little bit
10:44:09 <fr33domlover> Solonarv, swapMvar is atomic when there's a single producer
10:44:15 <fr33domlover> and readMVar too
10:44:23 <hpc> conceptually, MVar's operations are take and put
10:44:43 <Welkin> in fact I can't run my executable at all?
10:44:46 <Welkin> what's happening?
10:44:50 <Solonarv> if there is only a single thread writing, IORef is safe too
10:45:06 <fr33domlover> Yes single thread writing
10:45:08 <Welkin> I upgraded a project from ghc 8.4.2 to 8.6.3 and now my application binary won't run
10:45:11 <Welkin> it just does nothing
10:45:15 <Welkin> no output
10:45:55 <fhdhsni> How do you read this? (>>=) :: forall a b. m a -> (a -> m b) -> m b 
10:46:09 <hpc> fhdhsni: (>>=) can be called "bind"
10:46:48 <fhdhsni> hpc: and the rest? :) 
10:46:50 <hpc> it takes an action that produces 'a', and a function that expects 'a'
10:47:03 <hpc> and a miracle occurs in the body of (>>=) and the function is applied to that value
10:47:10 <hpc> with the effects of the two actions sequenced
10:47:11 <fr33domlover> hpc, Solonarv now I'm confused, sounds like I could use IORef too? ^_^ I think I prefer MVar/TVar though in this case because out-of-order means some handlers will return http response with outdated value
10:47:44 <Solonarv> fr33domlover: in your situation any of them would work, yes
10:47:47 <hpc> fr33domlover: basically it's a matter of possible vs "correct"
10:48:10 <hpc> any of them can be used to make something that given the same input, produce the same desired output
10:48:21 <fr33domlover> hpc, what would you say corret is in this case?
10:48:32 <hpc> but only TVar really says what's happening if you forget what's going on and read your code later
10:48:47 <hpc> when you see IORef, you don't expect concurrency
10:48:52 <Solonarv> if your handler reads from the variable right before said variable is updated, it'll have an old value, none of the variable types prevent that (how could they?)
10:48:58 <hpc> when you see MVar, you expect blocking semantics
10:50:38 <fr33domlover> hpc, ah I see! Solonarv what do you think about that? ^_^
10:50:59 <fr33domlover> I guess TVar is safer here in the sense that if the code is modified, things stay safe
10:51:05 <fr33domlover> Because Tvar guarantees it
10:51:09 <hpc> yep
10:51:19 <Solonarv> yup
10:51:20 <fr33domlover> MVar and IOref would just happen to be safe as long as the code is very careful
10:51:54 <Welkin> does anyone know what is going on with cabal? I feel like I am going crazy here
10:51:59 <Welkin> is 2.4.1.0 just broken?
10:52:04 <fr33domlover> Since I'm not worried about optimizing stuff like Tvar vs MVar vs IORef micro operation speed, I'm going with TVar ^_^
10:52:09 <fr33domlover> Thanks hpc and Solonarv :)
10:52:12 <Welkin> or do I need to do something that I haven't done yet?
10:53:24 <Welkin> oh shit
10:53:39 <Welkin> it was my main function exiting immediately
10:54:37 <hpc> classic
10:55:00 <Welkin> well, I changed the entire application, and the main function had some stuff in it from some guide
10:55:08 <hpc> Welkin: i've seen people just run the complete wrong code before
10:55:14 <hpc> "why isn't the output changing?!"
10:55:22 <Welkin> bracket (forkIO runApp) killThread (const $ pure ())
10:55:45 <Solonarv> kek
10:55:49 <Welkin> I changed it to runApp
10:56:22 <Welkin> hpc:  that is a real problem in web development
10:56:35 <Welkin> sometimes you need to nuke the build cache
10:56:36 <hpc> yeah
10:56:53 <hpc> one of my favorite debugging tools is going to line one of the code and just writing "laskjdhkjashdglkjahsdglkjhasdlkgjfhalkjsfhlsakjdhlakjsdhlakjsdhlkasjhdl"
10:57:28 <fhdhsni> dumb request: [1,2,3] is a monad, right? Can you show me an example using [1,2,3] and >>=
10:58:02 <Welkin> no
10:58:09 <Welkin> that is a list of integral numbers
10:58:30 <hpc> types are monads
10:58:31 <Welkin> List has an instance defined for the Monad typeclass
10:58:45 <wroathe> fhdhsni: [1,2,3] >>= \i -> return $ succ i
10:58:46 <hpc> [] (the list type, not the empty list) would be one
10:58:58 <hpc> so would Maybe - but not Maybe Int or [Int]
10:59:02 <Welkin> Monad requires that the type has kind * -> * (a function that takes a type and returns another type)
10:59:46 <wroathe> fhdhsni: You've opened a can of worms with this channel
10:59:46 <hpc> > [(+ 5), (* 2)] >>= \f -> [f 10, f 100] -- fhdhsni: a more elaborate example
10:59:48 <lambdabot>  [15,105,20,200]
11:00:12 <Welkin> list is not the easiest Monad instance to start with
11:00:14 <Welkin> look at Maybe
11:00:30 <cronokirby> look at Identity 8^)
11:00:35 <Welkin> lol
11:00:40 <Welkin> read the definition for Monad here https://wiki.haskell.org/Typeclassopedia
11:00:56 <Welkin> it's an interface to a type that you can define instances for
11:01:11 <cronokirby> my process of learning was getting used to a few specific examples, and then slowly trying to make sense of the concept more generally
11:01:53 <[exa]> fhdhsni: perhaps Applicative [] is better to start with...  [succ, pred] <*> [1,10]
11:02:20 <hpc> and probably Functor before that
11:02:56 <wroathe> fhdhsni: A monad is just a monoid in the category of endofunctors, what's the problem?
11:03:01 <wroathe>  :troll:
11:03:04 <Welkin> and Cofree Comonads before that
11:03:19 <hpc> and Yoneda before that
11:03:24 <Welkin> (I don't even know what that one is)
11:03:25 <hpc> and zygohistomorphic prepromorphisms before that
11:03:27 <hpc> and lens before that
11:03:28 <hpc> :D
11:04:02 <nshepperd1> What is a monad? A miserable little pile of secrets!
11:04:24 <Welkin> that reminds me
11:04:32 <Solonarv> (co)yoneda isn't that bad if you understand functors, tbh
11:04:51 <Welkin> I watched a talk with Alan Kay recently where he was a grumpy old man. He really hates monads
11:07:02 <howdoi> sorry, I have a very basic question, in perlude if I am using interact, how do I end the input?
11:08:17 <Solonarv> howdoi: are you asking how to say "this is the end of input" when running a program built using interact?
11:08:52 <kadoban> Ctrl+D in linux, Ctrl+Z in windows typically. If that's what you mean
11:08:52 <howdoi> in ghci; I am trying something like `interact $ show . sum. map read . words `
11:09:11 <kadoban> Hm I'm not sure in ghci actually
11:09:24 <howdoi> kadoban: tried Ctrl+D, didn't help
11:09:34 <Welkin> interact is just a wrapper over reading and writing to the terminal, isn't it? (an infinite loop)
11:10:08 <kadoban> AFAIK, yeah. It reads from stdin. I dunno how you close stdin in ghci tho, or give stdin anything to do. I would imagine that interact doesn't make a ton of sense run in GHCi usually
11:10:42 <howdoi> hmm, yeah, it just stays accepting inputs 
11:10:45 <hpc> it works the same on linux, but drops you back to the prompt iirc?
11:10:59 <hpc> oh, not even close :D
11:11:08 <howdoi> :|
11:11:20 <Welkin> Ctral+Alt+Delete
11:11:51 <howdoi> ^ on GNU/Linux?
11:11:57 <Welkin> on windows
11:12:02 <howdoi> heh heh
11:12:09 <kadoban> howdoi: Where do you want it to get the input from? Like you'd type after running that and then end the input? Unless I'm missing something, or unless GHCi is quite a bit more clever than I realized, I don't think that's going to work
11:12:29 <Solonarv> actually, this works: interact $ show . sum . map read . words . head . lines
11:12:52 <Solonarv> (basically, you need to stop looking at the input past a certain point)
11:13:38 <kadoban> Hmm, it does? That's curious
11:13:55 <Solonarv> yes, if you do that 'interact' will exit
11:14:01 <howdoi> Solonarv: nice, but it exits after that, <stdin>: hGetChar: illegal operation (handle is semi-closed)
11:14:09 <Solonarv> yup, I was about to say that
11:14:16 <howdoi> we can avoid exit too?
11:14:56 <Solonarv> I mean, yes, but then 'interact' will never finish and you can't use the GHCi prompt anymore
11:15:22 <Solonarv> So the conclusion seems to be: don't use 'interact' from GHCi
11:15:25 <howdoi> makes sense
11:16:00 <howdoi> thanks!
11:16:18 <howdoi> BTW what would be an apt example to understand `$` and `.`?
11:16:38 <Solonarv> I don't know about examples, but their definitions are pretty simple
11:16:51 <wroathe> :t (.)
11:16:52 <lambdabot> (b -> c) -> (a -> b) -> a -> c
11:16:56 <wroathe> :t ($)
11:16:57 <howdoi> I am like: `take 5 (reverse (filter odd [1..10]))` to `take 5 $ reverse $ filter odd $ [1..10]` to `take 5 . reverse . filter odd $ [1..10]`
11:16:57 <lambdabot> (a -> b) -> a -> b
11:17:45 <Clint> and which one don't you understand?
11:18:23 <howdoi> well, isn't `(f x)` is same as `(f $ x)`?
11:19:04 <hpc> so, the definition of ($) is f $ x = f x
11:19:18 <hpc> but it has different precedence from actual function application
11:19:18 <howdoi> if we were to explain `(a -> b) -> a -> b` in words, we would do it like?
11:19:24 <hpc> which is why the middle one works
11:19:35 <Solonarv> howdoi: indeed, and that's the definition of ($)
11:19:38 <Solonarv> @src $
11:19:38 <lambdabot> f $ x = f x
11:19:40 <hpc> (.) is function composition
11:19:51 <hpc> if you wrote the last one with (.) but without ($), you would have
11:19:59 <hpc> (take 5 . reverse . filter odd) [1..10]
11:20:14 <hpc> the advantage of that is, let's say you don't care about the list it's applied to
11:20:25 <hpc> when you're writing your code, all you care about is how you're transforming the list
11:20:28 <hpc> you can write
11:20:33 <hpc> foo = take 5 . reverse . filter odd
11:20:57 <hpc> because (.) is composing functions into a new function, and then that single function is being given a list
11:21:21 <howdoi> hpc: sweet! 
11:21:34 <howdoi> @src .
11:21:34 <lambdabot> (f . g) x = f (g x)
11:21:58 <howdoi> Solonarv: neat
11:22:09 <howdoi> thanks you all, I shall pester you again soon ;)
11:24:56 <Heffalump> is there a way to get cabal to use package versions from a particular stackage version (LTS 13 in this case), e.g. by getting a cabal freeze file?
11:25:21 <Heffalump> I want to reproduce a build problem someone has reported but don't have stack installed
11:25:22 <hpc> yes
11:25:26 <Welkin> you don't need stackage/LTS
11:25:33 <hpc> i forget how, but there's a particular url you can download the freeze file from
11:25:46 <hpc> you generally don't need it though
11:26:50 <Heffalump> happy to consider any alternatives too
11:27:28 <howdoi> BTW, coming for node world, if I have to read a JSON endpoint and parse the JSON data in haskell, where should I start?
11:27:45 <Welkin> aeson for json parsing
11:27:47 <Clint> Heffalump: https://www.stackage.org/lts-13.3/cabal.config ?
11:27:56 <Welkin> req or wreq for http client
11:28:17 <shapr> a wild Heffalump appears!
11:28:21 --- mode: shapr set -o shapr
11:31:26 <Solonarv> keep in mind that stackage actually *predates* stack by a bit
11:32:36 <wroathe> Welkin: Or http-client if he/she doesn't want something that immediately drops Lenses as a concept on them :P
11:33:27 <Welkin> req doesn't use lens https://hackage.haskell.org/package/req
11:34:03 <wroathe> Welkin: Ah, didn't see you mention req
11:34:04 <wroathe> My bad
11:34:11 <Welkin> http-client is very low-level
11:36:52 <Heffalump> Clint: perfect, thanks
11:42:40 * howdoi is looking for a quick example
11:43:15 <howdoi> I get lenses [I guess :D]
11:43:18 <Heffalump> hi shapr :-)
11:43:27 * shapr hugs Heffalump 
11:45:30 <vaibhavsagar> howdoi: https://github.com/vaibhavsagar/notebooks/blob/master/zulip-api/API.ipynb
11:45:38 <vaibhavsagar> look at cell 2
11:46:23 <vaibhavsagar> also you can look at the Hackage README: http://hackage.haskell.org/package/req
11:47:19 <howdoi> vaibhavsagar: rad!
11:55:32 <lambdaman> Parser combinators question:
11:55:32 <lambdaman> I have a parser (in Megaparsec) for a variable name that must:
11:55:32 <lambdaman> - Fail (consuming input) if a symbol table lookup fails 
11:55:34 <lambdaman> - Fail (consuming no input) if some other checks fail (may be a variable of a different type)
11:55:36 <lambdaman> - Succeed (consuming input) if all is well 
11:55:38 <lambdaman> The two fail cases are challenging me.  I sort of want to bookmark the input stream on entry to the parser and then decide later whether failure should consume or not. 
11:55:40 <lambdaman> A simple ‘try’ will not achieve this.  
11:55:42 <lambdaman> Any ideas?
11:59:26 <sclv> lambdaman: which of the fail cases do you want to take precedence?
11:59:49 <sclv> the weird thing is it looks like you want the first to take precedence
12:00:21 <sclv> so it consumes but then if some other checks fail it "backs out" and unconsumes
12:01:18 <Solonarv> I'm pretty sure megaparsec has functions to manipulate where you are in the input
12:01:27 <sclv> it does
12:01:47 <sclv> but you can also cheat and use a nonconsuming lookahead and then analyze what happens and "reparse/consume" if you decide you did want to
12:02:58 <lambdaman> I need to check if the variable reference is the right type, once I've parsed the variable name.  If it's the right type then I consume, otherwise I fail and don't consume. 
12:03:39 <lambdaman> Yes, I thought about lookahead, but then it seemed wrong to parse it all over again to consume if I decided I liked everything.
12:14:29 <shachaf> seraphina_: heraphina
12:18:19 <seraphina_> Heraphina?
12:30:47 <Boarders> if I use cabal new and I build with profiling will it cache the result if I build without profiling later?
12:31:07 <Boarders> in stack you need to do something like: stack build --work-dir=.stack-work-profile --profile
12:32:11 <cocreature> Boarders: it will cache things in your store but not inplace packages
12:32:28 <Boarders> so it will not rebuild all dependencies with profiling?
12:32:46 <cocreature> yep
12:32:55 <Boarders> excellent, thank you
12:33:23 <cocreature> but it will rebuild the packages that you have in the packages section in your cabal.project (and their deps)
12:33:25 <Solonarv> It should if a) you've enabled profiling for them and b) profiliing-enabled dependencies aren't already cached
12:33:32 <cocreature> eh not their deps, the things that depend on them
12:41:15 <fr33domlover> Is there a standard way to watch threads? Suppose my app has a main thread, a few persistent helper threads, and any other thread is short-term. If any of those persistent threads stop, I'd like to stop the whole app with an error message
12:42:34 <fr33domlover> ah there's forkFinally!
12:42:34 <Solonarv> @hackage async -- fr33domlover
12:42:34 <lambdabot> http://hackage.haskell.org/package/async -- fr33domlover
12:44:54 <fr33domlover> Solonarv, hmmm but I don't want to wait for the return value, just be notified if the thread stops (it's not supposed to, it uses forever, so if it stops that's an error to me)
12:45:20 <Solonarv> what kind of notification do you want?
12:50:12 <fr33domlover> Solonarv, to get an exception thrown, I suppose. Looks like 2 simple ways are 'forkFinally' from base and 'link' from async which you linked
12:55:03 <Solonarv> 'async (shouldRunForever >> throwIO DidntRunForeverException) >>= link' should work, I suppose
13:23:27 * hackage mysql 0.1.7 - A low-level MySQL client library.  http://hackage.haskell.org/package/mysql-0.1.7 (paulrouse)
13:36:36 <suzu> @pl \fn f -> r <$> fn f
13:36:37 <lambdabot> ((r <$>) .)
13:36:43 <suzu> u wot
13:37:22 <MarcelineVQ> m8
13:37:27 <suzu> oh
13:37:40 <suzu> @pl \f x -> r <$> g x
13:37:40 <lambdabot> const ((r <$>) . g)
13:37:44 <suzu> thats better
13:37:50 <suzu> still melts my brain though
13:38:02 <suzu> i think i'm.. not gonna use that
13:38:55 <[exa]> if you can ignore a slightly different constraint, `ap r . g` seems better
13:39:10 <MarcelineVQ> @pl \f x -> fmap r (g x)
13:39:10 <lambdabot> const (fmap r . g)
13:39:38 <MarcelineVQ> somehow nicer than the slice
13:40:02 <[exa]> oh, s/ap/fmap/
13:40:17 <[exa]> I see applicatives where there are none
13:41:17 <suzu> is there some explanation of how to mechanically make things pointfree
13:41:33 <suzu> i understand you can reduce, say, f x = g x to f = g
13:41:40 <suzu> (iirc this is eta-reduction?)
13:41:40 <MarcelineVQ> I have a gist somewhere, hmm..
13:41:44 <suzu> where can i find other rules?
13:43:07 <MarcelineVQ> I guess github deletes old ones, maybe I saved elsewhere
13:43:42 <suzu> maybe you're looking in the wrong place? gist.github.com will show gists but github.com will not
13:43:59 <fr33domlover> suzu, in actual code though, personally I want to make sure the code is readable, so I do the pointfreeing manually and if it gets ugly I stop and undo ^_^
13:44:04 <geekosaur> https://wiki.haskell.org/Pointfree has some references
13:44:27 <suzu> yeah im not gonna use this. but was curious what it is in pf
13:44:51 <[exa]> suzu: you basically use flip to rotate the bound variables to the end of argument list, and then either eta-reduce them or use (.) to "squash" two argument lists together
13:45:12 <[exa]> @pl \x -> f x a b c
13:45:13 <lambdabot> flip (flip (flip f a) b) c
13:45:21 <fr33domlover> suzu, iirc there's a library lambdabot uses for that
13:45:28 <fr33domlover> you can look at the code
13:45:30 <[exa]> @pl \x -> f (g x a b) c d
13:45:30 <lambdabot> flip (flip f c . flip (flip g a) b) d
13:46:43 <fr33domlover> @pl \f x g y -> f (g x) y
13:46:43 <lambdabot> (. flip id) . (.)
13:47:20 <fr33domlover> @pl \f x g y -> g x . f y
13:47:20 <lambdabot> flip (flip . (((.) . (.)) .) . flip id)
13:47:33 <fr33domlover> ^_^
13:48:03 <MarcelineVQ> darn you gist :X
13:55:49 <lyxia> suzu: you can also read about various encodings of lambda calculus into combinator calculi
14:10:10 <MarcelineVQ> suzu: it was someone else's gist ;_; https://gist.github.com/TiredSounds/7d5b2b97d37490c47f320c0072527a42
14:10:34 <MarcelineVQ> but also not what I thought it was, despite being what I was looking for :>
14:10:41 <MarcelineVQ> so probably not so useful to you
14:18:44 <Solonarv> another key combinator is <*>: turn 'f x (g x)' into '(f <*> g) x', making it possible to eta-reduce 'x' away
14:22:37 <utdemir> Small `constraints` question. If I have a `Dict (Eq a, Show b, Ord c)`, what's the easiest way to pluck out a `Dict (Show b)` from it? The only way I could find was representing it as `Dict (Eq a, (Show b, Ord c))` and doing `mapDict $ trans weaken1 weaken2`. Can you think of a nicer way? What is the reason of not having a polymorphic `weaken` function with lots of instances?
14:25:37 <phadej> utdemir: easiest way is pattern match and construct new DIct
14:25:52 <phadej> i.e. case dictABC of Dict -> Dict
14:26:29 <Solonarv> if you want it as a function, (\Dict -> Dict) works (you might need a type signature)
14:27:19 <utdemir> phadej, Solonarv: You are right. However in my case I am using StaticPointers extension which means I can not just grab arbitrary 
14:27:42 <utdemir> Oh, nevermind, turns out I can :). Thank you.
14:34:13 <fr33domlover> throw vs throwIO: In a library, there's a function that returns Either Error Success. I'd like to provide a version of it that returns Success, and expresses Error by throwing exception. Should I use throw or throwIO? The former allows the function to be used in pure code, but it's barely useful because the context is sending an HTTP request so there's going to be IO anyway, and that function is meant to be
14:34:16 <fr33domlover> called right before doing that IO
14:34:35 <Cale> fr33domlover: You should prefer throwIO whenever it's an option.
14:34:51 <fr33domlover> Cale, can you explain? :)
14:35:13 <Cale> Exceptions thrown by throwIO are much easier to catch, because they are thrown when the IO action is executed.
14:35:35 <Cale> Those thrown by throw are thrown when the throw expression is evaluated.
14:36:15 <Cale> Making sure that the appropriate evaluation happens inside of a suitable catch can be fiddly, and is usually sort of a last-resort thing to do.
14:37:01 <Cale> i.e. I'll usually prefer to make commits to another person's library to avoid having to deal with such exceptions, if I need to be able to catch them.
14:37:02 <fr33domlover> Cale, oh I see! So if you use throw and the expression isn't fully evaluated, the error may get skipped?
14:37:07 <Cale> right
14:37:20 <fr33domlover> Cale, thanks for explaining :) I'll use throwIO
14:37:26 <Cale> It'll lazily occur when the expression eventually does get evaluated, which might be outside the catch at that point.
14:37:44 <Cale> So you have to really understand what evaluation is taking place if you want to catch them.
14:37:45 <larryba> Cale, what do you think of MonadThrow/MonadCatch classes? allowing you to write functions that can, depending on context, call throwIO, or return Maybe/Either SomeException
14:38:08 <Cale> They're okay
14:40:02 <Cale> I think more often they'd be used for IO vs. other monads built in terms of IO.
14:40:45 <Cale> Usually if Maybe/Either is an option, I'd rather just have that be the type directly.
14:48:39 <utdemir> Can anyone give me an example of how to write a 'Control.Disributed.Closure.Static' instance? For example, how do I implement 'instance Eq a => Static (Eq a)'? Does it even possible?
15:00:43 <larryba> Cale they are nicer than Either/Maybe when used in IO, as you can just use them directly and they'll do throwIO for you, while still giving you an option to use them in pure code
15:13:09 <larryba> they are also nicer than Either if you are composing them with functions returning Maybe. and nicer than Maybe, if you're composing them with functions returning Either. I like them as they reduce the amount of code I have to write, but a couple of times I asked about them in here, it doesn't seem like people share my enthusiasm :P
15:15:24 <iqubic> What are you talking about here?
15:17:39 <pgiarrusso> utdemir: Static (Eq a) looks surprising, don’t you mean Static a?
15:18:52 <larryba> iqubic: https://bpaste.net/show/b5a9344aca64
15:19:44 <utdemir> @pgiarrusso, Sorry, I actually meant 'Static (Dict (Eq a))'. Actually, what I'm trying to do is that use those typeclass instances inside the static keyword, however inside the static keyword I can not access the typeclass instance.
15:19:44 <lambdabot> Unknown command, try @list
15:21:56 <pgiarrusso> utdemir: indeed, Eq a is not a type
15:22:07 <pgiarrusso> So Dict (Eq a) is illegal
15:22:14 <pgiarrusso> You’d want Dict a
15:22:52 <pgiarrusso> if that part is correct, which I’m not sure... I can’t find the typeclass you describe
15:23:13 <utdemir> pgiarrusso: https://hackage.haskell.org/package/distributed-closure-0.4.1/docs/Control-Distributed-Closure.html#t:Static
15:23:37 <larryba> iqubic, basically, it allows the caller of the function to decide how errors are handled, rather than forcing specific one on him
15:25:01 <pgiarrusso> utdemir: ok sorry, that’s trickier
15:25:14 <pgiarrusso> So disregard what I wrote
15:28:04 <pgiarrusso> utdemir: looking at that, it seems you can’t do it for Eq a in general, but you can do it for a particular Eq x where that exists
15:28:53 <pgiarrusso> The example in https://hackage.haskell.org/package/distributed-closure-0.4.1/docs/Control-Distributed-Closure-TH.html#v:withStatic gives a couple suggestions there
15:30:22 <pgiarrusso> utdemir: that’s because “Eq a” does not have a fixed instance
15:30:40 <pgiarrusso> Not even a fixed polymorphic one
15:33:08 <utdemir> pgiarrusso: I kinda understand. So, if we are in a function where there's 'Eq a' in scope, there is no way to get a 'Closure (Dict (Eq a))' from that?
15:34:06 <pgiarrusso> utdemir: maybe... but this can’t be done in a Static instance, since you can’t define instances inside a function, right?
15:35:39 <utdemir> Yes, you are right. To be more specific, I am trying to develop this library, which uses distributed-closure underneath. So, when I expose a polymorphic function, I had to ask my user to provide a (Closure (Dict (SomeClass a))). e.g here: https://hackage.haskell.org/package/distributed-fork-0.0.1.3/docs/Control-Distributed-Fork.html#v:fork
15:36:26 <pgiarrusso> utdemir: Dict :: Dict (Eq a) should get you to the first step
15:36:43 <utdemir> pgiarrusso: I kinda understand. So, if we are in a function where there's 'Eq a' in scope, there is no way to get a 'Closure (Dict (Eq a))' from that?
15:37:05 <utdemir> Sorry for the above message. I was trying to paste this gist: https://gist.github.com/utdemir/7ec0b5df5468d76e57f1fd4daa9dd848
15:37:54 <pgiarrusso> utdemir: now I’m not sure, but it seems that you can’t get a StaticPtr from such a Dict?
15:39:11 <utdemir> pgiarrusso: Yeah, as soon as I am in 'static' keyword, it can not deduce the instance. 
15:39:53 <utdemir> I was thinking if that 'Static' typeclass is the answer, but looks like it is not.
15:40:44 <pgiarrusso> utdemir: it is
15:40:55 <pgiarrusso> utdemir: but you need to ask for an extra instance
15:41:09 <pgiarrusso> And propagate the constraint up the call chain
15:41:46 <pgiarrusso> utdemir: some caller will call you with a fixed a; and *that* can be passed to static
15:42:14 <pgiarrusso> I checked
15:42:16 <pgiarrusso> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#static-pointershttps://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#static-pointers
15:42:20 <pgiarrusso> Ahem https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#static-pointers
15:42:35 <pgiarrusso> The language extension StaticPointers adds a new syntactic form static e, which stands for a reference to the closed expression ⟨e⟩
15:43:06 <pgiarrusso> There, “closed” means that e cannot use any local variables, including the instance Eq a that you get as parameter
15:43:32 <pgiarrusso> But at the call site that picks, e.g. a = [Int]
15:44:08 <pgiarrusso> The compiler knows how to build the instance using only *global* values (instances), and those *can* be wrapped in static
15:44:54 <pgiarrusso> Looking at the withStatic example, it seems you want to declare, for each instance that you use, a corresponding Static instance
15:45:28 <pgiarrusso> But if the source has a generic instance, e.g., Eq a => Eq [a], you can declare *one* Static instance for that
15:45:54 <pgiarrusso> Instead of one for [Int], one for [Integer], etc.
15:46:18 <utdemir> Ooh, I now understand, I think.
15:46:21 <utdemir> Let me try.
15:46:32 <pgiarrusso> Such a generic instance still wraps with static *one* pointer
15:48:25 <utdemir> Got it, I guess, like this: https://gist.github.com/utdemir/2b009b3e1ee06ec51cb4704bcf4fdf0f
15:49:20 <utdemir> I just need to define a bunch of instances, and ask my user to define a new instance for every other datatype they want to use.
15:53:16 <jjb> is there a standard module that implements a vector/array like structure which retains a history of modifications?
15:54:02 <chessai> jjb: indefinitely?
15:54:14 <jjb> yes
15:55:07 <chessai> jjb: i guess you could use something with Writer, but that feels weird
15:55:45 <jjb> (i have also been trying to make something that keeps both a (mutable, unboxed) vector and a separate list of modifications, but have so far been unable to make it play nicely inside runST, so i'm going to punt on that part for now until i get better at this.
15:55:48 <jjb> )
15:56:10 <chessai> jjb: why do you want all modifications made available to you?
15:56:35 <chessai> ie what are you trying to do
15:56:38 <jjb> it's for debugging a function that makes lots of modifications to an array
15:56:51 <jjb> i have a canonical (validated) implementation and it's list
15:57:20 <jjb> i could do what i want just by printing/tracing the changes but i'm trying to do it in a not completely gross way
15:57:26 <jjb> s/it's/itsw
15:57:28 <jjb> ARG
15:57:34 <chessai> jjb: show your code?
15:57:51 <jjb> happy to, but it's pretty gross! standby
15:57:55 <chessai> ok
15:59:39 <jjb> this is the current code that does/can print out the changes and uses just a vector: https://gist.github.com/unprolix/3771d12dd055cfd344a44a1557c0abe2
16:00:50 <jjb> i'd ideally like to replace the MVector with a structure which contains the mvector and a list of mods, and return the frozen vector along with the list when the function is done
16:01:25 <chessai> jjb: you can wrap VUM.write
16:02:44 <jjb> as in f x y = do { VUM.write x y;  {-return a modified array here-} } ?
16:02:47 <chessai> myWrite :: PrimMonad m => VUM.MVector (PrimState m) a -> Int -> a -> m (VUM.MVector (PrimState m) a, ()) 
16:03:14 <chessai> it would copy the array into a new one, and return that along with performing the write
16:03:22 <chessai> you dont actually need that () there, excuse that
16:04:00 <chessai> you need to accumulate these vectors
16:04:39 <chessai> so everytime you copy a vector, add it to a list or something, then continue modifications on the source vector
16:04:46 <jjb> i just need a list of changes as in [(index, value)]
16:04:48 <jjb> right
16:04:58 <chessai> you can store the index/value instead of the vector
16:05:27 * hackage sbv 8.0 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-8.0 (LeventErkok)
16:05:45 <chessai> you should can also store (index,oldValue,newValue) - but that can be recovered from a full trace if necessary
16:05:52 <chessai> might just be easier to do that up front
16:06:17 <jjb> i won't actually need that, i just want enough data to be able to discover where the implementation is going wrong relative to the reference
16:06:22 <chessai> ok
16:06:30 <chessai> jjb: did what i say help in any way?
16:06:33 <jjb> thank you for the help! i'll try to make it work as you suggest
16:06:38 <jjb> we'll see ;)
16:06:40 <chessai> ok
16:06:48 <chessai> did it make sense at least?
16:07:18 <jjb> i think i understand enough to start investigating now. i haven't used monad transformers before so it sounds like it's time.
16:07:32 <chessai> you don't need monad transformers for the list accumulation
16:07:35 <chessai> unless you want to
16:07:58 <jjb> i would ideally like to do this in the most idiomatic way i can make myself understand in the nearish term
16:09:03 <chessai> jjb: if you feel like it would be good for you to learn, then go ahead. shouldn't make much of a difference (though i think writer is overkill there)
16:09:49 <jjb> oh, perhaps i misunderstood. when you gave a type for myWriter i thought that was related to using a Writer
16:10:09 <chessai> that was `myWrite`, no 'r'
16:10:19 <chessai> ie a wrapper of 'VUM.write'
16:10:21 <jjb> aha
16:10:31 <jjb> gotcha, thank you!
16:10:43 <chessai> jjb: no problem
16:12:27 * hackage sbp 2.4.7 - SwiftNav's SBP Library  http://hackage.haskell.org/package/sbp-2.4.7 (markfine)
16:14:49 <jjb> \
16:25:24 <utdemir> pgiarrusso: Now everything clicked. Thank you very much for your patience.
16:29:15 <mouse074_> When stack creates a new project via "stack new my-project", it creates "package.yaml" and "stack.yaml" in "my-project/". "package.yaml" has "ghc-options:" parameter. Is it combined with "ghc-options:" values from "~/.stack/config.yaml", or does this file completely overwrites what was in "~/.stack/config.yaml"?
16:31:08 <mouse074_> Solonarv: do you happen to know...?
16:31:29 <geekosaur> overrides. the latter is the "default project" when there's no local project definition
16:33:14 <Solonarv> mouse074_: please stop pinging me every time you have a stack question, I'm not that knowledgeable on it and I don't even use it anymore
16:34:11 <mouse074_> geekosaur: that's what I was afraid of. So if ~/.stack/config.yaml has `ghc-options: "$everybody": -optL=something` and my-project/package.yaml has `ghc-options:` that set other parameters - the package.yaml will blow away what was in config.yaml? 
16:34:20 <mouse074_> Solonarv: got it. My apologies.
16:34:57 * geekosaur should probably check. except I don't use stack either
16:35:19 <geekosaur> it's more frustration than it's worth especially sicne stuff like this changes ("$everybody"?)
16:35:49 <mouse074_> Well, I wouldn't use it either, but IntelliJ-Haskell plugin uses stack exclusively. And yes, tell me how frustrating it is!!! ;-)
16:36:53 <Solonarv> the flippant answer is "don't use intellij then"
16:38:02 <mouse074_> The answer to the flippant answer is "it is the best editor+IDE I've dealt with, and I'm using it for all the other languages. So it would be a shame to be forced to use something less convenient for just one language." 
16:38:24 <Clint> fix the plugin
16:38:47 <mouse074_> Especially since I still hope that it could be tamed. ;-)
16:39:29 <mouse074_> That's what I'm trying to accomplish with the plugin author. But in the meanwhile, I have to accumulate *precise* data on what gets broken.
16:39:47 <jjb> when i try to define the type of a function that takes a mutable vector, i get a complaint about how PrimState m doesn't match Primstate m0, which i gather is by design and intended to prevent the mutable state from escaping the impure context. does that mean i have to define such functions inside the context where they will receive the vector/state?
16:43:58 <mouse074_> @geekosaur it appears that it combines the options when it can - i.e., when what's in package.yaml does not directly overrides what's in the global config.
16:43:58 <lambdabot> Unknown command, try @list
16:44:06 <mouse074_> @list
16:44:06 <lambdabot> What module?  Try @listmodules for some ideas.
16:44:46 <geekosaur> yeh, that "$everything" made me wonder, which is why I commented on stuff like that changing
16:45:30 <geekosaur> and @ is for bot commands. just mention nicks, clients are smart enough to recognize it without 
16:45:35 <geekosaur> withotu @
16:46:00 <mouse074_> That's the crazy format specified in the stack docs. Of course, package.yaml has a different format. Oh well... ;-)
16:46:29 <Welkin> stack is a mess
16:46:51 <utdemir> @jjb You shouldn't need to, if you make that context polymorphic it should work as you expect. Do you have an example code?
16:46:52 <lambdabot> Unknown command, try @list
16:46:54 <Welkin> just use cabal
16:47:06 <mouse074_> Oh yes... BTW, do you know if #haskell-stack forum is alive? I haven't gotten a single answer there.
16:47:10 <Welkin> https://www.haskell.org/cabal/users-guide/
16:47:22 <jjb> utdemir: do you mean replace (PrimMonad m) in the type with 'a' or the like?
16:47:30 <Welkin> the people who support stack and yesod and other related projects are almost never around
16:47:41 <Welkin> you can email them
16:47:43 <utdemir> jjb: let me prepare an example
16:47:49 <jjb> thank you!
16:48:16 <jjb> by the way, this has got to be the friendliest IRC room ever.
16:48:18 <mouse074_> Welkin: I do use cabal (and am happy with it) - except when I want to use a nice IDE plugin. ;-) Then the whole stack hell breaks loose.
16:48:25 <jjb> and most helpful.
16:50:37 <oats> how can I uncurry a function that takes more than three arguments?
16:50:56 <Cale> Use a lambda?
16:51:16 <Welkin> \ (a,b,c) -> f a b c
16:51:30 <Welkin> I don't see why you would do that though
16:51:36 <Welkin> why would you uncurry?
16:51:59 <oats> I have a function that returns a tuple of 3 items, I want to apply a function to them
16:52:09 <Welkin> okay, then use that lambda
16:52:12 <oats> oh, I misspoke
16:52:15 <oats> *more than 2 argumens
16:52:21 <jjb> you can destructure when you bind, right?
16:52:29 <Welkin> jjb: what?
16:52:32 <Welkin> bind what?
16:52:36 <jjb> let (a, b, c) = f arg
16:52:40 <Welkin> pattern match
16:52:41 <Welkin> yes
16:53:12 <Welkin> let ... in ...
16:53:49 <oats> well a lambda just makes too much sense
16:53:51 <oats> thanks y'all
16:54:07 <Clint> you could always use one of the 50 different libraries that export an uncurry3 function
16:54:08 <oats> thinking functionally has been a real challenge for me
16:54:42 <hpc> you could always write the 51st library :D
16:55:57 * hackage stylish-cabal 0.4.1.0 - Format Cabal files  http://hackage.haskell.org/package/stylish-cabal-0.4.1.0 (JudeTaylor)
16:56:36 <jjb> (utdemir: must step away for a bit, should be back in a few min)
16:57:51 <nyc> I made fst, snd, thd, etc. typeclass methods and made tuples instances.
16:58:22 <Solonarv> If you're okay with pulling in lens, it has typeclasses for tuples
16:58:33 <Solonarv> up to 9 I think
16:58:35 <nyc> Solonarv: Sounds good.
16:58:39 <Solonarv> :t _1
16:58:41 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
16:59:04 <jackdk> and even if you don't want to learn all the lens, `tuple ^. _1` and `tuple & _1 .~ foo` are reasonable places to get started
16:59:12 <Welkin> if you are reaching for more than a 2-tuple, make a record
17:00:07 <Welkin> what is an hs-boot file?
17:00:08 <Welkin> https://github.com/AtnNn/haskell-rethinkdb/blob/master/Database/RethinkDB/ReQL.hs-boot
17:00:44 <Welkin> to avoid circular dependencies or something?
17:00:51 <Clint> yes
17:01:07 <jackdk> they're used to untangle circular imports http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/separate_compilation.html#how-to-compile-mutually-recursive-modules
17:01:24 <AfC> Welkin there are plenty of stack contributors here.
17:02:23 <Welkin> why not just move the code into another file?
17:02:31 <Welkin> instead of creating another file to resolve the conflict
17:02:37 <Welkin> it makes more sense
17:02:48 <Solonarv> do you mean: move the mutually-dependent things into the same file?
17:03:01 <Solonarv> hs-boot files are finicky, so that is usually the better option
17:03:48 <Welkin> yes, I mean you are already creating a file
17:04:02 <nyc> [(n, a, b) | n :: Int <- [2..maxBound], a <- [1..ceiling((fromIntegral n / 2)**(1/3))], let b' = (fromIntegral (n-a^3))^(1/3), b <- [floor b'..ceiling b'], a <= b, a^3+b^3==n] or similar doesn't really want a record.
17:04:20 <Solonarv> Usually when you say "nah I won't use recursive imports" you end up merging the mutually-dependent modules together
17:04:35 <Welkin> replace (n, a, b) with `MyRecord n a b`
17:04:49 <Welkin> then you can give each field a name
17:04:59 <Solonarv> If the mutually-dependent stuff is small you would've probably put it all in one file to begin with
17:05:06 <Welkin> records are named tuples
17:05:11 <Welkin> tuples are anonymous records
17:07:10 <utdemir> jjb (when you're back): https://glot.io/snippets/f8jq9iqmo6 . What happens is that 'm' gets specialised to what's in 'runST'. You just have to make sure that somehow you're forcing those monads to be the same.
17:09:59 <mouse07410> AfC: why are those contributors mostly silent when stack questions pop up here?
17:27:29 <jjb>  utdemir: thank you! i think i'm still missing some understanding because i can't seem to (a) modify foo in your example to return the history array, or (b) get anything OUT of the runST except vec itself
17:28:12 <jjb> i.e. i can't make (vec, fooresult) be the last line in the do
17:29:11 <Welkin> you need to understand how monads work
17:29:28 <Welkin> do-blocks are syntactic sugar around monads
17:29:53 <utdemir> jjb: in order to return from that, you need to freeze your mutable vector. basically, nothing should have 'm' in their type.
17:29:58 <Welkin> `a <- ma; b <- mb` is really ma >>= \a -> mb >>= \b -> ...
17:30:41 <jjb> i know that in theory ;) but i think there are still fundamental aspects i'm missing in actual practice thinking
17:31:04 <jjb> maybe i should desugar manually and that would help
17:31:35 <jjb> (i did freeze the vector)
17:32:33 <AfC> mouse07410: It's often quite hostile to their work here, which is unfortunate. 
17:33:25 <AfC> mouse07410: but if you have a question you can ask here, via Twitter, or on GitHub.
17:33:40 <utdemir> AfC: Yeah, I think IRC is for us old school cabal users. Afaik FP Complete has their Slack channels, and probably they're more active there.
17:33:49 <MarcelineVQ> idk about that, I think they're mostly just busy in general, not waiting around on irc to answer questions
17:34:19 <AfC> utdemir: I'd like to think IRC was for everyone.
17:34:30 <MarcelineVQ> not everyone likes providing 1 on 1 when you can be doing work that affects many
17:34:41 <Welkin> hostile?
17:34:50 <Welkin> don't even start on that
17:34:56 <AfC> MarcelineVQ: you're right
17:35:08 <MarcelineVQ> "hostile? I'll give you hostile!" hehe
17:45:01 <NewToHadkell> join
17:46:13 <Welkin> :t join
17:46:15 <lambdabot> Monad m => m (m a) -> m a
17:46:31 <Welkin> what is hadkell?
17:46:57 * hackage grids 0.2.0.0 -   http://hackage.haskell.org/package/grids-0.2.0.0 (ChrisPenner)
17:47:49 <doyougnu> mouse07410: looks like the options in package.yaml overwrite those in stack.yaml. Just did a quick test.
17:48:12 <doyougnu> I would think it should be the otherway around? who knows...
17:51:03 <mouse07410> doyougnu: interesting. So package.yaml overwrites what's in stack.yaml, but appears to combine with non-contradicting parameters from ~/.stack/config.yaml?
17:52:53 <doyougnu> ooo good point I missed that edge case. AFAIK package.yaml jsut calls HPack to generate a cabal file. I'm not sure what other processing stack does on a per package basis but it's possible there is overlap between stack and HPacks integration into stack
17:53:28 * hackage sbvPlugin 0.11 - Formally prove properties of Haskell programs using SBV/SMT  http://hackage.haskell.org/package/sbvPlugin-0.11 (LeventErkok)
17:53:52 <mouse07410> AfC: I've been asking a ton of questions here (mostly about how to get certain parameters to GHC thorough stack). Usually got answers from folks more experienced with Haskell, can't recall any stack developer pitching in to help.
17:55:09 <mouse07410> I have an issue open on GitHub/stack. Don't use Twitter, so can't ask for help there.
17:55:59 <mouse07410> And Haskell-stack forum seems mostly dead. Asked questions there a few times times, no response.
17:57:00 <AfC> Whatever is in package.yaml just ends up in the generated .cabal file (which works according to Cabal's rules). I've never tried to put GHC flags in the stack.yaml file
17:57:06 <kadoban> There's a forum?
17:57:29 <jackdk> I've always shied away from package.yaml. As awkward as .cabal files are sometimes, yaml is an insane format
17:58:06 <AfC> {shrug} not everyone uses everything. I've been away from IRC for four years.
17:58:47 <mouse07410> But according to stack messages, it prefers package.y'all, unless <project>.cabal was manually modified?
17:59:08 <Solonarv> It'll use whichever was most recently modified, yes
17:59:13 <kadoban> mouse07410: Yes
17:59:58 <Solonarv> I would recommend deleting package.yaml (so you don't accidentally edit it) and just using the cabal file
18:00:34 <Welkin> plus yaml is a terrible format
18:00:52 <Welkin> compared to json/erlang/lua for configuration
18:00:59 <Welkin> indent it wrong and it will break
18:01:14 <kadoban> ...
18:01:18 <kadoban> Can't tell if serious
18:01:21 <Welkin> I am
18:01:31 <kadoban> We're in #haskell, right? Just checking.
18:01:54 <Clint> yes, who wouldn't want to write configs in erlang
18:02:10 <Welkin> erlang tuples and lua tables are very similar
18:02:28 <Solonarv> kadoban: if you indent haskell wrong, you get a parse error (or maybe a type error); if you indent yaml wrong, you just get wrong behavior
18:02:39 <mouse07410> You mean - stack would use both <project>.cabal and stack.yaml? And will take what's in the global config.yaml for parameters/values that were not set by these two in the project dir?
18:02:39 <Welkin> or hell, even lisp s-expressions are better than yaml
18:02:55 <Solonarv> that said, yaml is a superset of json, so you can just write json and call it a day
18:02:59 <kadoban> Solonarv: You can indent haskell incorrectly to get incorrect behavior as well.
18:03:13 <Solonarv> kadoban: yes, but that only happens very rarely
18:03:21 <Welkin> kadoban: then use more parentheses
18:03:31 <Welkin> stop using $ everywhere
18:03:52 <Welkin> this isn't php
18:03:55 <zachk> Solonarv, happened to me the other month, on wrong indentation level 
18:04:14 <kadoban> Welkin: Now I'm not even following.
18:04:42 <kadoban> Are $ notorious for causing indent errors?
18:04:52 <Welkin> the only place where indentation will cause problems is in a do-block or if you are using $ instead of parentheses and indenting wrong
18:04:59 <Welkin> parens make it impossible to have indentation errors
18:05:17 <zachk> or braces and semicolons perhaps! 
18:05:29 <Welkin> possibly case expressions too, if you are sloppy
18:05:34 <Welkin> yes, you can do that
18:05:56 <Solonarv> I'm pretty sure case expressions would (almost always) simply not parse / type error if they're misindented
18:06:11 <Welkin> anyway
18:06:14 <Solonarv> ah, nested case expressions, I suppose
18:06:15 <Welkin> parenthese are good
18:06:17 <Welkin> long live lisp
18:06:18 <Solonarv> (and nested do blocks)
18:07:10 <Welkin> it's awesome how in erlang and lua you write configuration files in the same language
18:07:20 <Welkin> because they are just native data structures
18:07:34 <mouse07410> To gently nudge back to the stack behavior: stack would use both <project>.cabal and stack.yaml? And will take what's in the global config.yaml for parameters/values that were not set by these two in the project dir?
18:08:41 <Solonarv> the stack.yaml and <blah>.cabal files are orthogonal
18:09:03 <Solonarv> very roughly, <blah>.cabal specifies what your dependencies are, and stack.yaml specifies where to get them
18:12:49 <Solonarv> for ghc-options, you should end up with the values specified in stack.yaml and blah.cabal combined together
18:12:58 <Solonarv> (with those in blah.cabal taking priority)
18:14:00 <NewToHaskell> mult _ 0 = 0
18:14:17 <iqubic`> hello
18:14:20 <NewToHaskell> mu
18:16:35 <NewToHaskell> mult n m = (mult n (m - 1)) + n
18:17:10 <iqubic> I think you mean *
18:17:21 <Solonarv> NewToHaskell: why are you typing this into IRC?
18:17:24 <iqubic> Or no, then that'd be exponetiation.
18:17:37 <Welkin> haha
18:17:43 <Welkin> they think this is their repl
18:17:46 <Welkin> or they are a bot
18:17:54 <koz_> Well, I guess that makes them... new to Haskell? :P
18:18:07 <NewToHaskell> please, explain why that recursive function work; I cannot understand it...
18:18:16 <Welkin> they joined several minutes ago with the name NewToHadkell
18:18:34 <koz_> monochrom: I summon thee to teach recursion properly!
18:18:40 <suzu> NewToHaskell: do you know any othe programming languages?
18:19:41 <Welkin> > let x = 1:x in x
18:19:43 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:19:49 <suzu> function mult(n, m) { if (m == 0) { return 0; } else return (mult(n, m-1) + n); }
18:20:01 <suzu> if it were javascript
18:20:05 <Welkin> suzu: what is that doing in here!
18:20:13 <suzu> hey hey i'm just trying to explain
18:20:16 * suzu ducks
18:22:12 <nyc> :t fix (1:)
18:22:14 <lambdabot> Num a => [a]
18:22:55 <NewToHaskell> I am typing this on a smartphone; not easy...; I know other programming languages but little about recursion; I would like a breakdown of how the result is obtained.
18:23:11 <monochrom> Oh I was just re-preparing my recursion lecture notes ealier today!
18:23:17 <koz_> monochrom: Perfect!
18:23:46 <nyc> structural induction is the way to go
18:24:30 <Welkin> monochrom: does it involve turtles?
18:25:23 <monochrom> Here: http://www.cs.utoronto.ca/~trebla/CSCC24-2019-Winter/Haskell.hs
18:25:45 <monochrom> No turtles. It's induction all the way down.
18:26:12 <monochrom> Wait, "well-ordering principle all the way down" is better!
18:26:37 <NewToHaskell> the function above is a recursive definition of multiplication; but even though I know that it works, I cannot get my head around it...
18:26:47 <monochrom> But I prefer "it's Lasagna all the way down" when I'm hungry.
18:29:09 <NewToHaskell> this is my first visit to this channel.
18:29:49 <mouse074_> monochrom: what app would format nicely your Haskell.hs? (apology for a probably very naive question)
18:29:59 <coldpress> I'm using `stack install cabal-install`, but I'm getting a dependency clash between `Cabal` and the local project's external dependencies. Is there a way to resolve this?
18:30:01 <nyc> mult n m | n == 0 = 0 | n < 0 = mult (n+1) m - m | n > 0 = mult (n - 1) m + m ? 
18:30:08 <monochrom> I think it is already perfectly formatted?
18:31:23 <mouse074_> Yeah, but I thought those "{-", "-} and such mean something? And they look like formatting commands...
18:31:38 <monochrom> Comments.
18:31:52 <mouse074_> Ah... Block comments...? 
18:32:12 <Clint> {- yes -}
18:32:55 <Solonarv> there are a few formatters around, but they're not always used and they all have some issues
18:34:21 <mouse074_> Are there good tools t pretty-print Haskell code?
18:34:45 <Solonarv> that... sounds like the same question?
18:35:20 <Solonarv> brittany and stylish-haskell are the two I can think of right now
18:36:14 <mouse074_> Well, some people call tools that auto-indent their code and force certain line breaks "fromatters". Just wanted to make sure.
18:36:39 <mouse074_> "fromatters"->"formatters" (we aren't talking cheese in French ;)
18:37:48 <Solonarv> I'm a bit confused; what could a formatter mess with other than whitespace?
18:37:51 <NewToHaskell> @nyc mult _ 0 = 0; mult n m = (mult n (m - 1)) + n    -- it works, but I don't get it...
18:37:51 <lambdabot> Maybe you meant: src rc ghc
18:38:09 <monochrom> Fromatters are essential for lasagna!
18:38:26 <nyc> NewToHaskell: It checks to see if m == 0 first.
18:38:36 <jle`> Solonarv: they can re-order import lines maybe
18:38:43 <nyc> NewToHaskell: It ignores the value of n when it checks if m == 0.
18:38:51 <Solonarv> oh yeah, I forgot about imports. good point.
18:39:08 <monochrom> NewToHaskell, the expectation is after the foregoing conversation you would have picked up the hint and try studying my notes first.
18:39:12 <dmwit> NewToHaskell: Would it be easier to read if I wrote (n+1)*m = n*m + m ?
18:39:47 <nyc> n+1 `mult` m with n+k patterns etc.
18:39:53 <dmwit> This is a pretty standard specialization of the distributive property.
18:40:11 <dmwit> Then there's just a little bit of massaging needed to transform it from standard math notation to something suitable for use in a Haskell program.
18:40:18 <Welkin> n+k patterns hasn't been in haskell for years
18:40:20 <Welkin> I thought
18:40:31 <nyc> They got removed?
18:41:51 <nyc> ghci 8.0.2 doesn't recognize them.
18:42:40 <monochrom> Haskell 2010 removed n+k patterns.  You can still reinstate it in GHC by the NPlusKPattern extension.
18:43:21 <monochrom> But dmwit's sentence did not mean to use "(n+1)*m = n*m + m" as actual code. It was a mathematical explanation.
18:55:27 <mouse074_> Solonarv: depends on the language - but it could vary spaces between parentheses, braces, and other tokens, it could force function arguments or parens on a new line, etc. etc. It can truly reformat your code, not just correct indentation
18:55:49 <Solonarv> that's still whitespace!
18:56:28 <Solonarv> but okay, I see now that what you originally said ("linebreaks and indentation") is more restrictive than messing with all whitespace
18:56:40 <mouse074_> :-)
18:57:34 <monochrom> Don't dismiss whitespace differences. People fight wars over whitespace differences.
18:58:31 <mouse074_> :-) :-)
18:58:42 <Solonarv> oh, I wasn't dismissing them. I just mistakenly thought they were already accounted for.
18:58:43 <Welkin> you mean they throw tantrums
18:59:22 <monochrom> But even if not, it should be pretty obvious that wise use of whitespace helps your readers, and cunning use of whitespace creates ascii art.
19:00:17 <monochrom> Next we will discuss tools that mess with your tabs!
19:00:40 <Solonarv> tabs are whitespace ;)
19:01:30 <jackdk> tabs should be three spaces, and you should use tabs for indentation, then spaces for alignment.
19:01:37 <jackdk> there, that should tick everyone off :)
19:01:42 <mouse074_> Guys, you're too much. I'm heading out to catch some sleep - need to present Foreshadow tomorrow. ;-)
19:01:54 <monochrom> I have a better idea.  The average tab width is 3.418 spaces.
19:02:45 <Welkin> I only use mongolian vowel separators
19:02:53 <Solonarv> jackdk: I wouldn't actually mind that tab/space mix, but tools are (rightly IMO) very conservative and tend to outright reject mixed tab/space code
19:03:11 <Welkin> in fact, the mongolian vowel separator improved the performance of my application
19:03:17 <Welkin> (not a joke)
19:03:20 <mouse074_> Well, if there can be a vector space with non-integer number of dimensions, why not 3.14159? ;-)
19:03:27 <monochrom> Please don't reject my vertical tabs and form feeds!
19:03:40 <koz_> NUL is best token separator.
19:03:46 <jackdk> Solonarv: in principle it makes sense to me too but good luck making it work with other people.
19:04:00 <jackdk> koz_: YEAH\0but actually no I disagree
19:04:07 <nyc> With as much as people are obsessed with whitespace, someone ought to make a language entirely out of whitespace.
19:04:22 <Solonarv> Which is ironic, because working with other people is half the point of that tab style
19:04:24 <koz_> nyc: https://en.wikipedia.org/wiki/Whitespace_(programming_language)
19:04:37 <jackdk> koz_ is quick on the draw today.
19:04:38 <nyc> koz: heh
19:04:45 <koz_> jackdk: Pew pew.
19:04:46 <Solonarv> Everyone can set tabs to display at whatever size they want and the code will still look right
19:05:07 <Welkin> butthen it looks different on everyone's machine
19:05:33 <Solonarv> So? that's also the case when people use different syntax highlighters, or different fonts, or whatever
19:06:07 <Welkin> cone-nipple people rule!
19:06:08 <monochrom> @quote monochrom arguments.*polymorphism
19:06:08 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
19:06:18 <monochrom> @quote monochrom debates.*polymorphism
19:06:18 <lambdabot> No quotes match. You untyped fool!
19:06:22 <monochrom> aw
19:06:29 <monochrom> Oh!
19:06:33 <monochrom> @quote monochrom debates.*polymorph
19:06:33 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
19:06:51 <koz_> monochrom: Are you saying we need polymorphic canned responses?
19:07:18 <mouse074_> :D
19:07:23 <monochrom> So in this case you make the semantics of tab polymorphic so people stop arguing over whether everyone should indent by 4 or by 2 or by 6 or by 8 or...
19:07:28 <Solonarv> hmm, someone should build a template-enabled version of @where
19:07:39 <jackdk> tab = five spaces
19:07:50 <monochrom> But it only works if you use tabs exclusively, no space.  If you mix in spaces, it breaks.
19:07:55 <iqubic> Solonarv: I totally agree with that.
19:08:05 <iqubic> monochrom: I use spaces everywhere.
19:08:05 <jackdk> hence tabs for indentation, spaces for alignment
19:08:27 <jackdk> but I have enough trouble getting people to keep whitespace lint out of git commits, that tab/spaces isn't a war I will fight
19:08:33 <MarcelineVQ> problem solving 101: tabs are 1 char wide
19:08:37 <monochrom> Well I guess pure tabs followed by pure spaces is OK.
19:08:42 <Welkin> (setq-default indent-tabs-mode nil)
19:08:43 <Welkin> for life!
19:08:51 <Solonarv> monochrom: that's the idea, yes
19:08:54 <iqubic> What do you mean by "whitespace lint"?
19:09:08 <iqubic> Welkin: I do that too. Exclusively that.
19:09:14 <monochrom> But people are dumb they mess it up.
19:09:24 <Solonarv> also that you never have the ambiguity of "is 5 tabs + 3 spaces or 3 tabs + 2 spaces a deeper indent?"
19:10:36 <Solonarv> er, bad example, swap the space counts
19:10:40 <jackdk> iqubic: trailing lines at EOF, extra spaces at EOL, things like that. makes diffs noisy for no good reason
19:11:18 <Solonarv> I suppose you could distribute a pre-commit hook to fix that crap
19:11:22 <monochrom> Well people can't even distinguish big-O from worst-case time so good luck with indentation != alignment.
19:11:55 <iqubic> Solonarv: I'd say the first is a deeper indetation, but it'd be clearer if you just used spaces so we could compare `x spaces` vs `y spaces`
19:12:23 <nyc> Big-Omega, big-O, and tilde all need to be done.
19:12:32 <Solonarv> well the example I gave is unambiguous anyway
19:13:29 <iqubic> jackdk: everytime I save my file all blank lines are trimmed to 0 chars, trailing whitespace at EOL is removed, and the EOF is shortened to 1 blank line at the end. Emacs just does this for me.
19:13:29 <zachk> can haskell just hang on trying to bind/listen to a port, as a server program? and how would i debug that get around it, do I need to open the port somehow?
19:14:13 <jackdk> iqubic: me too. this should be a standard feature.
19:14:54 <iqubic> by one blank line at EOF, I mean, "The last character in my file is \n"
19:20:57 * hackage yam 0.5.9 - Yam Web  http://hackage.haskell.org/package/yam-0.5.9 (leptonyu)
19:21:57 * hackage yam-datasource 0.5.9 - Yam DataSource Middleware  http://hackage.haskell.org/package/yam-datasource-0.5.9 (leptonyu)
19:28:14 <zachk> if I recompile ghc, do I need to reinstall all my cabal libraries? 
19:29:39 <geekosaur> yes, generally
19:30:15 <zachk> how do I do that? 
19:30:19 <Welkin> you can avoid recompiling ghc by downloading the platform instead
19:30:24 <Welkin> it's on 8.6.3
19:30:25 <zachk> delete .cabal? 
19:30:34 <Welkin> it installs in seconds
19:30:38 <Welkin> no need to do anything
19:31:05 <Welkin> you don't need to delete anything with recent versions
19:31:16 <monochrom> Look under .ghc, there may be a directory you also need to delete.
19:31:17 <Welkin> packages are namespaced (really, put in directories) for their version of ghc
19:31:25 <Welkin> at least that is what I have experienced
19:31:28 <geekosaur> and deleting .cabal is not the right thing even for older versions. deleting .ghc would be
19:31:30 <zachk> i am trying to use ghc on android, using userland app with ubuntu, and I can't bind network ports for servers, looked around a bit and something touched on how their glibc libraries are different, so I thought a recompile on my targect architecture might work 
19:31:58 <geekosaur> deleting .cabal would just leave dangling garbage in ghc's package database. and nothing would work
19:31:59 <Welkin> you are running ghc on a phone?
19:32:19 <monochrom> Is that outside your comfort zone?
19:32:44 <zachk> yea i have ghc and ghci running on a non rooted phone 8.0.2 I think 
19:32:52 <Welkin> why would you want that?
19:32:58 <zachk> just playing around 
19:32:59 <monochrom> Why not.
19:33:21 <monochrom> Why challenge everyone who does something you would never do.
19:33:30 <Welkin> I am not challenging anyone
19:33:30 <zachk> run haskell on a $40 dollar computer(phone) 
19:34:03 <zachk> so after I recompile ghc, I need to delete .ghc? 
19:34:08 <Welkin> I can't communicate tone over text
19:34:14 <maerwald> monochrom: You might get insights doing that
19:34:16 <zachk> or not even do that?
19:34:18 <Welkin> but I am asking a question out of curiosity
19:34:23 <Welkin> don't take it as a challenge monochrom 
19:34:51 <geekosaur> why does it bother you?
19:34:52 * geekosaur used to do stuff liek that on a jailbroken ipod (well, that was before I discovered haskell)
19:34:52 <geekosaur> zachk, as we both said, only with older ghc versions
19:34:53 <geekosaur> newer ones use abi hashes and will track stuff appropriately
19:35:09 <geekosaur> older versions would break in weird ways. 8.x shoould be fine here
19:35:10 <zachk> how much newer? 
19:35:19 <zachk> alright thank you all, and good night :) 
19:39:14 <monochrom> maerwald: I get even more insights plus make more friends if I join them, not challenge them.
19:40:36 <maerwald> friends challenge each other
19:40:59 <monochrom> That is a different kind of challenge.
19:41:14 <maerwald> I don't think so :)
19:42:43 <monochrom> Or you just haven't seen more kinds.
19:43:04 <maerwald> Are you challenging me? :)
19:43:20 <monochrom> There is a "don't challenge the channel" and there is also a "profs should challenge the students" and clearly they are different kind, tldr they differ in attitude.
19:43:57 <maerwald> I avoid running around the world with a prof attitude. I prefer challenging as friends.
19:44:29 <monochrom> As it happens, there are also different kinds, even opposite kinds, of prof attitudes.
20:08:27 * hackage stratosphere 0.30.0 - EDSL for AWS CloudFormation  http://hackage.haskell.org/package/stratosphere-0.30.0 (jdreaver)
21:30:17 <Welkin> what is the package to use for bcrypt password hashing?
21:30:32 <Welkin> this one looks fine https://github.com/a1kmm/hs-bcrypt
21:30:37 <Welkin> but it uses a C library
21:30:42 <Welkin> are there any in pure haskell?
21:44:37 <xelxebar> Welkin: Do you need bcrypt, or just a good KDF?
21:59:54 <Welkin> just a decent password hashing algorithm
21:59:58 <Welkin> xelxebar: 
22:00:08 <Welkin> I've been using bcrypt so far
22:01:04 <Welkin> I found a few packages on hackage that haven't been updated in some time
22:01:12 <Welkin> cryptonite looks very low level
22:03:10 <xelxebar> Welkin: Yeah, cryptonite provides scrypt and Argon2, but it looks like those are still both ffi into C
22:03:29 <Welkin> that's not a problem
22:03:40 <Welkin> I just don't want to have to install any special packages
22:03:44 <Welkin> as long as it uses openssl
22:05:15 <Welkin> I see
22:05:20 <Welkin> I was loking at the wrong modules
22:05:28 <Welkin> there is a hashPassword function
22:06:11 <howdoi> wreq seems like a good module
22:07:10 <Welkin> package
22:07:34 <howdoi> Welkin: okies, will say package from now, sorry I am from the node world 
22:07:37 <Welkin> req is easier to use I think, but wreq is fine
22:07:45 <Welkin> a package contains modules
22:07:51 <Welkin> a module is a single file
22:07:57 <howdoi> nods 
22:09:19 <howdoi> r <- asJSON =<< get "http://httpbin.org/get" :: IO Resp 
22:09:22 <howdoi> neat!
22:10:16 <howdoi> req doesn't have lenses right?
22:19:32 <cocreature> right, whether that’s a good or a bad thing is up for debate :)
22:44:28 <ddellacosta> I found this error message pretty confusing: https://gist.github.com/ddellacosta/bf2650b93cb33f87da3eed11b9f3ae28
22:44:36 <ddellacosta> is there anything in there that would have helped me know what I was doing wrong?
22:50:36 <dminuoso> Let's say I have some `IO Void` that starts up a network service. I want to write HUnit tests to test the external behavior, what mechanisms could I use to figure out how long to wait until the process is operational?
22:50:56 <dminuoso> Is using stdout to communicate some "Server started" an approrimate mechanism?
22:51:42 <cocreature> stdout is more useful if you’re building an executable. not if you’re building a library that you want to test with hunit
22:52:06 <cocreature> you could do somethingl ike MVar () -> IO Void where the mvar is filled in when it’s ready
22:52:06 <dminuoso> cocreature: It's an executable, though out of convenience I'm going to start it internally rather than invoking cabal from hunit.
22:52:51 <dminuoso> cocreature: Mmm, that's not too shabby. That mvar could be passed along the Env.
22:53:15 <dminuoso> And it's less messy than having to probe stdout, in particular because other things might be writing to stdout as well.
22:53:45 <cocreature> or something like IO (IO (), IO Void) which you use like (waitUntilReady, start) <- setup
22:53:50 <cocreature> that keeps it a bit more abstract
22:54:50 <maerwald> howdoi: wreq unfortunately depends on tls
22:55:25 <maerwald> But I guess most do
22:56:10 <dminuoso> cocreature: Mmm yeah. Internally I would still could implement this as: setup = (readMVar tok, startServer tok)
22:56:41 <cocreature> you first need to create the mvar but yeah that’s the idea
22:56:57 <dminuoso> cocreature: Thanks that will work nicely.
22:57:24 <dminuoso> Now the real tricky part is figuring out when the server is ready.
22:58:09 <cocreature> the alternative is to just retry a few times in your test suite :)
22:58:20 <dminuoso> cocreature: UDP makes this a bit hard.
22:58:43 <dminuoso> I'd start making assumptions about timings, which feels.. unclean.
22:59:11 <dminuoso> Though I have an idea.
23:01:27 * hackage yam 0.5.10 - Yam Web  http://hackage.haskell.org/package/yam-0.5.10 (leptonyu)
23:02:27 * hackage yam-datasource 0.5.10 - Yam DataSource Middleware  http://hackage.haskell.org/package/yam-datasource-0.5.10 (leptonyu)
23:07:49 <howdoi> maerwald: the TLS decencies causes a side effect? 
23:07:59 <howdoi> how do I unwrap the values of `r ^.. responseBody` ?
23:10:30 <maerwald> howdoi: I just don't like to use vulnerable crypto implementations =)
23:15:33 <suzu> whats vulnerable about tls?
23:15:55 <suzu> does the req package have the same problem?
23:16:28 <dminuoso> suzu: How many crypto experts do you know that have analyzed the pure haskell implementation` tls?`
23:16:38 <suzu> hmm, none
23:16:49 <suzu> is the issue that you want to use a crypto dep with a history?
23:16:50 <dminuoso> How many published papers on the side-effects or lack of side effects about using the GHC to produce cryptographic code have you read?
23:17:04 <suzu> i dont know anything about that
23:17:08 <dminuoso> Me neither.
23:17:13 <suzu> oh. lol
23:17:15 <maerwald> dminuoso: even worse https://github.com/vincenthz/hs-tls/issues/117
23:17:48 <dminuoso> suzu: You know what is as hard as coming up with secure cryptographic schemes?
23:17:50 <maerwald> So apart from the fact that we no nothing to zero about how appropriate haskell actually is for this
23:17:56 <maerwald> There is proof the lib is already vulnerable
23:18:14 <dminuoso> suzu: Implementing cryptographic schemes correctly as to not introduce timing attacks or other side channels.
23:18:24 <dminuoso> suzu: It's so ridiculously hard.
23:18:26 <suzu> hmm
23:18:36 <suzu> okay
23:18:37 <suzu> true
23:19:11 <suzu> now the whole ecosystem relies on `tls` doesnt it
23:19:17 <dminuoso> suzu: It begins with: You need to tightly control code generation, so you need a complete understanding of the generated *machine code*. you need to tharwt optimizations in key parts of the code. 
23:19:28 <suzu> does this mean that tls in haskell is probably vulernerable to all kinds of things
23:19:46 <dminuoso> suzu: No idea.
23:19:56 <suzu> should i be concerned
23:20:06 <suzu> fwiw i'm using saltine for my own crypto usage from hs
23:20:12 <suzu> which binds to libsodium
23:20:55 <dminuoso> suzu: As a completely random fun side channel attack on some older openssl version: https://ts.data61.csiro.au/projects/TS/cachebleed/ 
23:21:18 <dminuoso> suzu: Well not as much an attack, but some insights.
23:21:41 <dminuoso> suzu: And this paper is particularly interesting: https://crypto.stanford.edu/~dabo/papers/ssl-timing.pdf
23:23:19 <dminuoso> suzu: If you emit wrong machine code instructions, you can leak entropy. If you emit wrong code you can leak entropy. If the cache behavior is not precisely controlled you can leak entropy. If you don't have constant worst time algorithms that defeat caches and hardware optimizations on super scalar processors, you can leak entropy.
23:24:12 <suzu> rip
23:24:48 <suzu> leaking entropy means to leak information?
23:25:30 <dminuoso> suzu: Yes/
23:32:27 * hackage hasql-pool 0.5.0.1 - A pool of connections for Hasql  http://hackage.haskell.org/package/hasql-pool-0.5.0.1 (NikitaVolkov)
23:38:13 <dminuoso> suzu: https://perso.uclouvain.be/fstandae/PUBLIS/34.pdf and https://arxiv.org/pdf/1707.03473.pdf are also fun papers to read.
23:39:24 <dminuoso> Differential power analysis is my favourite.
