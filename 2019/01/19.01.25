00:05:59 * hackage aeson-value-parser 0.13.1 - An API for parsing "aeson" JSON tree into Haskell types  https://hackage.haskell.org/package/aeson-value-parser-0.13.1 (NikitaVolkov)
01:22:21 <ar1a> how do you pattern match for prefixes on Text. for String i could just do ('.':x) 
01:22:40 <merijn> ar1a: You can't really pattern match text, tbh
01:23:17 <ar1a> only guards huh?
01:23:47 <ar1a> i ended up doing "." `T.isPrefixOf` s
01:23:50 <merijn> Yeah, you can "pattern" match on entire values with OverloadedStrings, but not partial things
01:23:58 <merijn> ar1a: You might want to use pattern guards
01:24:04 <lortabac> ar1a: there is uncons, but it's only one letter at a time
01:25:03 <merijn> ar1a: You can do 'foo myTextVal | Just suffix <- T.stripPrefix "." myTextVal = doStuffWith suffix'
01:25:36 <merijn> (Assuming you wanted to do something without the prefix, else a guard with isPrefixOf works)
01:26:36 <ski>   foo (T.stripPrefix "." -> Just suffix) = doStuffWith suffix  -- after enabling `ViewPatterns'
01:28:09 <ar1a> all these language features i have no idea what they do! :D
01:28:11 <ski> (also there's `PatternSynonyms', which probably would look nicer)
01:28:18 <merijn> ski: That requires an extension, though. Pattern guard does not
01:28:34 <ski> oh, right. i forget it's included in the language, now
01:28:41 <merijn> ski: Everyone always does...
01:28:45 * ski smiles
01:29:21 <merijn> ar1a: My version uses a pattern guard, i.e. it pattern matches in the guard (allowing you to use T.stripPrefix) if the pattern match fails it will just continue and try the next guard (like regular boolean guards)
01:29:57 <merijn> ski: FPComplete is still enabling EmptyDataDecls in their code and writing articles recommending the extension, despite it being part of Haskell2010 too
01:30:30 <ski> ar1a : the pattern guard `Just suffix <- T.stripPrefix "." myTextVal' matches the result value of the expression `T.stripPrefix "." myTextVal' with the pattern `Just suffix'. if it matches, the pattern guard is successful, and we commit to evaluating `doStuffWith suffix'. otherwise the next guard, or next defining equation, of `foo', is tried, if any
01:31:34 <ski> > stripPrefix [0,1,2] [0,1,2,3,4,5,6,7]
01:31:36 <lambdabot>  Just [3,4,5,6,7]
01:31:39 <ski> > stripPrefix [0,1,2] [0,1,3,2,4,5,6,7]
01:31:41 <lambdabot>  Nothing
01:32:02 <merijn> Pattern guards are one of Haskell's most underrated features, imo
01:32:07 <ar1a> thanks
01:34:59 * hackage trackit 0.6 - A command-line tool for live monitoring  https://hackage.haskell.org/package/trackit-0.6 (EmilAxelsson)
01:38:48 <dminuoso> merijn: Sorry I had to quickly leave to catch the train myself. :)
01:39:22 <dminuoso> merijn: I just want to prevent log messages from different threads from overlapping. The possible loss of messages during shutdown is acceptable at this point.
01:39:49 <merijn> dminuoso: If not, I've got a Chan to fix that for you ;)
01:40:12 <dminuoso> merijn: Heh really, because I would have used a TChan instead to solve it.
01:40:16 <dminuoso> Let's have it =)
01:40:34 <merijn> dminuoso: https://hackage.haskell.org/package/broadcast-chan
01:40:52 <merijn> dminuoso: Benchmarks are a bit out of date, but last time it was basically as fast/slightly faster than Control.Concurrent.Chan
01:41:27 <merijn> dminuoso: Initially I wanted to add more "batteries included" to Chan, but that got shut down without a proof of concept, so I ended up just moving it into a library
01:42:10 <merijn> dminuoso: And then I figured "while I'm at it, why not make it closable?" because that always annoyed me about Chan, that you couldn't "stop" when you were done :)
01:43:15 <phadej> for logging you don't need Chan, do you? TQueue/TBQueue is enough (you don't need broadcast, do you?)
01:43:38 <dminuoso> merijn: Yeah, at this point I would "stop" by contract. There's going to be an `TMVar QuitToken` that I'd put into to notify a graceful shutdown. The workers would finish off, the dispatcher dying - and the logger would stop reading off the TChan..
01:43:39 <merijn> phadej: broadcast-chan is, perhaps, a bit of a misnomer carried forward from the initial design goal
01:43:49 <merijn> phadej: Nothing limits it to broadcast style use
01:44:32 <merijn> phadej: With TQueue/TBQueue you still need to handroll all sorts of things
01:44:37 <phadej> it's still too powerful, if you have only one reader?
01:44:37 <dminuoso> phadej: Well Chan is nice because it allows you to attach multiple log endpoints. :)
01:45:03 <phadej> dminuoso: ok, so you have multiple log endpoints; that makes sense then.
01:45:10 <merijn> phadej: Not sure what "too powerful" means?
01:45:31 <phadej> "Using Monad when Applicative is enough"
01:45:37 <merijn> phadej: It's basically strictly better than Chan. It has more functionality and in all my benchmarks it's more performant
01:45:54 <dminuoso> merijn: I think the point is rather "Chan vs Queue" rather than "Chan vs broadcast-chan"
01:45:59 <phadej> dminuoso: yes
01:46:01 <merijn> Sure
01:46:29 <merijn> But then you have to handroll logic for determining the end of the queue via an extra TVar to signal closing, etc.
01:46:39 <merijn> And I got tired of redoing that :p
01:46:47 <phadej> logging queue doesn't end. does it?
01:46:54 <merijn> phadej: Says who?
01:47:07 <phadej> ok, this debate is pointless ->
01:47:14 <merijn> phadej: If you have logging in a regular, non-server process why would it be endless?
01:47:29 <merijn> phadej: Most of my code is "do a bunch of stuff and do some logging, then terminate"
01:47:40 <merijn> I would like to ensure my log channel is flushed before exiting
01:48:19 <merijn> Most programs shut down *at some point* and you presumably wanna flush any last log bits before doing so
02:49:15 <inkbottle> cocreature: Unfortunately, I am likely to have to read my code again: that's the tricky part ;)
02:58:27 <WilliamHamilton[> is it possible to export only `some` methods of a typeclass?
03:00:40 <merijn> WilliamHamilton[: I think so, but then no one could implement those
03:01:16 <gentauro> WilliamHamilton[: why would you do that?
03:01:20 <gentauro> if I might ask?
03:02:13 <Saizan> WilliamHamilton[: iirc you can have "ClassFoo(method1,method2)" in your export list, to avoid exporting method3 and so on
03:06:00 <dminuoso> Why would you do that? :|
03:06:24 <dminuoso> If you have that desire, I feel typeclasses are the wrong tool to begin with. 
03:07:08 <opqdonut> I think it's a reasonable question
03:07:18 <opqdonut> I might split the class into "public" and "private" parts though
03:07:43 <opqdonut> but if there's cross-dependencies between the public and private methods that might not work
03:20:28 <WilliamHamilton[> gentauro, dminuoso: I want to do it because there is a method in a typeclass that should morally be hidden, but due to the vast amount of overlapping type classes that I'm using, I cannot really factor it out. I'd like it to be hidden for usability reasons, and the user is not supposed to write instances of this class
03:20:53 <dminuoso> WilliamHamilton[: "morally hidden" why?
03:22:12 <WilliamHamilton[> dminuoso, because I don't want it to confuse the user of the library. It's never supposed to be called by the user, as I provide another function in the same class that I expect to be used
03:23:02 <WilliamHamilton[> Saizan: thanks, I'll try that
03:23:26 <WilliamHamilton[> diminuoso: mostly, I don't want that function to appear in the generated haddocks, if I can prevent that
03:25:49 <inkbottle> f :: monad m => a -> m b -> m a -> m b -- like with only <$> and <*>
03:26:17 <mniip> do you mean (a -> m b) -> m a -> m b
03:26:30 <inkbottle> yes
03:26:35 <mniip> not possible
03:26:44 <inkbottle> What!!?
03:26:52 <mniip> there are some applicatives that aren't lawful monads
03:27:06 <inkbottle> OK
03:27:32 <inkbottle> because, you can easily do that with do-return...
03:28:10 <dminuoso> WilliamHamilton[: I dont see the value in either partially hiding a class method, nor in trying to simulate closed typeclasses.
03:30:27 <dminuoso> WilliamHamilton[: Are you sure passing a dict of functions is not better for your usecase?
03:30:42 <inkbottle> mniip: I will put that in my applicative limitation list ;) [but, how did you know for sure that wasn't possible? You probably have an example that doesn't work?]
03:30:48 <ski> inkbottle : `do'-notation is syntactic sugar, that expands to uses of `(>>=)'
03:31:18 <inkbottle> yes, but why not possible with <$> <*>?
03:31:30 <inkbottle> looking for a counter example
03:31:30 <mniip> inkbottle, consider the Const r applicative
03:31:39 <inkbottle> OK
03:31:40 <mniip> data Const r a = Const r
03:32:10 <inkbottle> OK, I'll try to do the math myself...
03:33:20 <ski> think about what would be required to write `(=<<) :: (a -> Const r b) -> Const r a -> Const r b' (satisfying the monad laws)
03:33:47 <WilliamHamilton[> dminuoso that translation is always possible, right? In this case though I think that typeclasses are clearer, although I will probably try a rewrite with the explicit dictionary, and ping you as soon as I package up polished code, so we can discuss it concretely
04:21:28 <merijn> Any recommendations for libraries for PCA in Haskell?
04:48:33 <arianvp> hey
04:48:38 <arianvp> anybody here use cabal new-build on NixOS?
04:48:43 <arianvp> I mean,  cabal v2*
04:48:47 <arianvp> I can't get cabal new-repl to work
04:48:56 <arianvp> it crashes with  "can't load .so/.DLL for libz.so"
04:49:09 <arianvp> cabal new-build works fine though.  and   zlib is in my shell.nix
04:49:10 <arianvp> :/
04:50:22 <Lears> arianvp: No, but I have the same problem with X11. Let me know if you figure it out.
04:50:56 <arianvp> seems like a cabal bug to me or something
04:51:09 <arianvp> Lears: oh then im gonna run into that soon as well. I'm trying to build a gtk project :P
04:57:26 * M5hadow_w1n5ton[ sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/xiSJhtltBcgXMSGaeCMOlWDR >
04:58:11 <arianvp> Lears: I found it I think
04:58:15 <arianvp> https://www.mail-archive.com/search?l=nix-dev@lists.science.uu.nl&q=subject:%22%5C%5BNix%5C-dev%5C%5D+problem+using+Haskell+libraries+that+depend+on+C+libraries%22&o=newest&f=1
05:17:57 <Lears> arianvp: Thanks, I had to cut a bit out of $NIX_LDFLAGS but that workaround has v2-repl running.
05:18:23 <Lears> I'm surprised we still have this 4+ years onwards.
05:18:45 <arianvp> Yeh I think the suggested way to handle this is  ghc.withPackages
05:18:51 <arianvp> but that uses the packages from Nix
05:24:51 <arianvp> Lears: it didnt work for me :(
05:26:39 <Lears> Are you running the command from a nix-shell that can build the project? If you're not then $NIX_LDFLAGS is probably empty; I'd check that it has the lib dir/s you need.
05:30:21 <asheshambasta> https://gist.github.com/asheshambasta/077b15362bca01e7c33418a9cdd85c2b <- is there a known "pattern" to implement things like these? 
05:33:24 <merijn> asheshambasta: I'm not quite sure what "things like these" is supposed to be?
05:33:41 <wildtrees[m]> Perhaps a dependent map not totally sure though
05:34:50 <asheshambasta> I see, this http://hackage.haskell.org/package/HMap-1.3.0/docs/Data-HMap.html is what I've just stumbled upon 
05:35:03 <__monty__> asheshambasta: Is it the "forgetting" of the type parameter so you can have a somewhat heterogeneous Map?
05:35:57 <asheshambasta> __monty__: yes but also being able to drill down to the specific type when I'm doing a lookup 
05:58:59 * hackage graph-wrapper 0.2.6.0 - A wrapper around the standard Data.Graph with a less awkward interface  https://hackage.haskell.org/package/graph-wrapper-0.2.6.0 (SoenkeHahn)
06:00:16 <lortabac> asheshambasta: do you have at most one element for each type?
06:02:10 <asheshambasta> lortabac: yes
06:02:33 <asheshambasta> lortabac: from the HMap package solves my problem, from what I see 
06:02:37 <asheshambasta> its quite neat 
06:02:47 <lortabac> in that case maybe you can avoid the map completely and just use a type class
06:03:01 <lortabac> something like: class LookupFieldConf a where lookupFieldConf :: Proxy a -> FieldConf a
06:03:22 <lortabac> and then define an instance for each element
06:03:33 <asheshambasta> lortabac: yeah: 
06:03:33 <asheshambasta> -- | An environment within which `FieldConf` for some types can be read
06:03:33 <asheshambasta> class Monad m => MonadField (m :: * -> *) where
06:03:34 <asheshambasta>   fieldConf :: DataField a => Proxy a -> m (Maybe (FieldConf a))
06:03:54 <asheshambasta> (on similar lines)
06:04:26 <asheshambasta> and then I'm going to delegate this problem to the person implementing an instance of this environment 
06:04:54 <lortabac> it looks simpler than a full-fledged hmap
06:05:29 * hackage ngx-export 1.6.4 - Helper module for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-1.6.4 (lyokha)
06:07:20 <asheshambasta> lortabac: besides, I'd like the implementation of "getting" the right type to be flexible and up to the implementing party 
06:07:51 <asheshambasta> should they be in some sort of MonadReader HMap environment, they can chose to use that
06:08:12 <lyxia> have you seen typerep-map
06:08:22 <asheshambasta> lyxia: no
06:09:05 <asheshambasta> lyxia: I see now, nice 
06:10:24 <asheshambasta> yeah this is nicer
06:20:12 <inkbottle> ski [sorry we've been cut off, I'll come back to that later]: It is not yet crystal clear, as I don't even need a functional type as the second parameter of the type constructor Const; However, I understand I'll have some hard time finding some value of type a to bind at the issue of Const 3 :: Const Int a [I wish I had some mind boggling exercise sheet about that]
06:21:30 * hackage ngx-export-tools 0.4.4.0 - Extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-0.4.4.0 (lyokha)
06:24:04 <inkbottle> I took thorough notes of the specifics, so I'll be able to come back to it later :)
06:31:50 <iqubic> ski: There's one major flaw with the binOp parser you helped me create.
06:32:48 <iqubic> "(1 + 3) + 4" fails to parse properly. Even though it really should.
06:33:32 <iqubic> that's because `(1 + 3)' is an expr, and our parser needs to start with a number first.
06:35:08 * M5hadow_w1n5ton[ sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/qDWxOcpSoQnJWoeEILXuUoNj >
06:35:33 <sm> nifty. Auto paste bin
06:36:05 <sm> I wish irc clients did that
06:36:55 <__monty__> sm: If only the url wasn't so terrible : ) Pretty sure you can use the "long message do you really want to send" hook in irssi to pastebin for you.
06:36:58 <byorgey> iqubic: writing a proper parser for expressions with parentheses and infix binary operators is tricky to get right.
06:37:21 <byorgey> iqubic: if you want to learn how to do it yourself, Google "shunting yard algorithm".  If you just want to make one that works, use https://hackage.haskell.org/package/parser-combinators-1.0.1/docs/Control-Monad-Combinators-Expr.html
06:37:59 <iqubic> byorgeyL I have one that nearly works to be honest.
06:38:15 <byorgey> great
06:38:50 <iqubic> Me and Ski worked it out last night.
06:39:28 <ski> iqubic : right. so it should not have been `expr ::= expr + num | num', but `expr ::= expr + atomic | atomic', where `atomic ::= '(' expr ')' | num', i think
06:39:49 <iqubic> Well, I have a few more atomic things.
06:39:59 <iqubic> but yes, basically that.
06:39:59 * hackage tonatona 0.1.0.0 - meta application framework  https://hackage.haskell.org/package/tonatona-0.1.0.0 (arowM)
06:40:02 <ski> yea :)
06:41:59 * hackage tonatona-persistent-postgresql 0.1.0.0, tonatona-logger 0.2.0.0, tonaparser 0.1.0.0, tonalude 0.1.0.0, tonatona-servant 0.1.0.0, tonatona-persistent-sqlite 0.1.0.0 (arowM)
06:47:46 <byorgey> yeah, this idea of having mutually recursive expression and atomic parsers seems common but I don't remember ever learning about it explicitly, I kind of just figured it out.
06:47:57 <byorgey> how come + is required to have an 'atomic' on its RHS?
06:48:17 <byorgey> you're not allowed to write   2 + (1 + 3) ?
06:48:39 <ski> well, it's more that presumably that would be allowed
06:49:07 <ski> with just `expr ::= expr + num | atomic', that'd be fine, but then to the right of any `+' must be only a numeral
06:49:27 <ski> replacing that `num' with `atomic', we also allow a bracketed expression to the right of `+'
06:49:27 <byorgey> oh, right, never mind!
06:50:29 <ski> (we started with `expr ::= expr + num | num', rather than `expr ::= expr + expr | num', in order not to complicate issues with ambiguous grammar, and with yet another recursion, on top of left recursion)
06:50:41 <byorgey> yes, that makes sense.
06:51:29 <ski> (that recursion turns out to not be problematic. but i figured it's easier to just get rid of it, while we're running into problems caused by (some) recursions)
06:51:52 <byorgey> OK, if you only have one binary operator it's not too bad to write it manually I guess.  I was thinking of the difficulties that arise when you want to parse things like  2 + 3 * 4 - 6 ^ 2 ^ 2
06:52:29 <ski> you can still separate the precedences manually, and then transform away the left recursion
06:53:12 <ski> but if one wants to be able to feed in an arbitrary operator spec table, or even want to allow dynamically declaring operators, it gets more complicated
06:53:48 <ski> (i had some ideas where i thought shift/reset could help with the latter ..)
06:55:14 <byorgey> right
06:56:14 <byorgey> once upon a time someone had a problem. "I know," they thought, "I'll use delimited continuations."  Now they have two problems.
06:57:00 * ski grins
06:58:16 <ski> @quote get.a.link
06:58:17 <lambdabot> shachaf says: Some people, when asking about a problem in #haskell, get a link to okmij.org. Now they have two problems.
07:01:06 <byorgey> hehe
07:01:25 <iqubic> ski: So I just realized that the stuff we hammered out yesterday has a major flaw.
07:01:40 <__monty__> What is thisk okmij.org?
07:01:46 <iqubic> Ski: I have no way to parse "1 + 2 * 3" at all.
07:02:17 <ski> @quote give.a.man
07:02:17 <lambdabot> mrd says: give a man a fire and you warm him for one day; point a man to oleg's web site, and he will create fire for himself -- in the type system
07:02:29 <iqubic> My function only works for the one operator type.
07:03:03 <iqubic> So I think I need to do something clever, but I'm not sure what.
07:03:54 <ski> @quote cornered.me
07:03:55 <lambdabot> edwinb says: where does 'Oleg cornered me in a pub and explained delimited continuations to me' fit in?
07:03:57 <srhb> __monty__: Oleg Kiselyov's (ok) homepage
07:03:58 <ski> @quote standard.operating.procedure
07:03:59 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
07:04:42 <ski> iqubic : well, you need to, somehow, represent the different precedences of operators
07:04:55 <iqubic> I know. I'm not sure how.
07:05:22 <ski> <ski> you can still separate the precedences manually, and then transform away the left recursion
07:05:26 <ski> (in that order)
07:06:01 <iqubic> But how will I deal with something like "1 + 2 * 3"?
07:06:19 <ski> how do you want the parser to (implicitly) bracket that ?
07:06:29 <iqubic> 1 + (2 * 4)
07:06:34 <iqubic> err... 3
07:06:40 <iqubic> But you get the idea.
07:06:42 <ski> so, you want a sum of products, of numerals ?
07:06:53 <iqubic> Well, yes.
07:06:58 <ski> (that's a hint)
07:07:47 <iqubic> But for something like `1 + 2 - 3 + 4' I want `((1 + 2) - 3) + 4'
07:08:08 <ski> well, addition and subtraction are sortof the same thing
07:08:26 <iqubic> Right. What I need is a way to do a sum of products.
07:08:31 <iqubic> Which IDK how to do.
07:08:41 <ski> you could define "sum" to be "a sequence of terms, interspersed with `+'s and `-'s"
07:08:48 <iqubic> I will.
07:09:00 <ski> (then you'd need to define "term")
07:09:09 <iqubic> Oh. I see.
07:09:16 * ski smiles
07:10:05 <iqubic> A term is "a sequence of atomic tokens interspersed with `*'s and `/'s"
07:10:17 <iqubic> Is that the trick to this?
07:10:20 <ski> well, atomic expressions, but sure
07:10:50 <iqubic> I have to go, but I'll work from there. Starting with a grammar of course.
07:10:54 <ski> (or, you could say "factors", if you want one more indirection)
07:12:29 * hackage aeson-value-parser 0.14 - An API for parsing "aeson" JSON tree into Haskell types  https://hackage.haskell.org/package/aeson-value-parser-0.14 (NikitaVolkov)
07:33:31 <fen> % :t build
07:33:31 <yahb> fen: (forall b. (a -> b -> b) -> b -> b) -> [a]
07:33:42 <fen> is this the scott encoding for lists?
07:34:11 <fen> reading, https://kseo.github.io/posts/2016-12-13-scott-encoding.html on the "list" section gives a slightly different type
07:34:59 <fen> hmm, scott encoding for foldable instances might be more accurate 
07:35:35 <fen> just wondering if they are compositional, like is there something like (++) ?
07:35:53 <fen> the blog post gives cons, but not sure if this works on arbitrary foldables 
07:36:21 <mniip> "scott encoding for foldable instances"
07:36:24 <mniip> that's not how that works
07:36:32 <mniip> and no, that is the *church* encoding
07:36:59 <fen> oh no! thats bad? https://ifl2014.github.io/submissions/ifl2014_submission_13.pdf
07:37:23 <fen> mniip: well it needs something which is like foldr
07:37:26 <fen> :t foldr
07:37:27 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
07:38:02 <merijn> fen: Church encoding
07:38:11 <fen> :t flip foldr
07:38:13 <lambdabot> Foldable t => b -> (a -> b -> b) -> t a -> b
07:38:42 <dmwit> Just for clarity: the first argument is the Church encoding.
07:38:52 <dmwit> The whole thing is not an encoding of lists at all.
07:39:14 <mniip> build is the inverse of foldr
07:39:25 <fen> :t (\xs cons basecase -> foldr cons basecase xs )
07:39:26 <dmwit> (The thing taken as a whole is an encoding transformer, from Church encoding to the builtin encoding.)
07:39:27 <lambdabot> Foldable t => t a -> (a -> b -> b) -> b -> b
07:39:31 <fen> :t build
07:39:33 <lambdabot> error:
07:39:33 <lambdabot>     • Variable not in scope: build
07:39:33 <lambdabot>     • Perhaps you meant ‘buildG’ (imported from Data.Graph)
07:39:36 <fen> % :t build
07:39:36 <yahb> fen: (forall b. (a -> b -> b) -> b -> b) -> [a]
07:39:54 <fen> so build is like that rearangenemt of foldr partially applied to a foldable
07:40:41 <fen> no, it takes something of the same type as foldr partially applied to a foldable container as its first argument
07:41:20 <fen> that is "of church encoding" type
07:41:22 <ski> @type flip (flip . foldr)
07:41:24 <lambdabot> Foldable t => t a -> (a -> c -> c) -> c -> c
07:41:48 <fen> so it should be compositional right?
07:41:59 <fen> like, because list is, and foldable things are iso to lists
07:42:15 <fen> :t (++)
07:42:17 <lambdabot> [a] -> [a] -> [a]
07:42:18 <fen> :t (:)
07:42:20 <lambdabot> a -> [a] -> [a]
07:42:29 <ski> @type GHC.Exts.build
07:42:31 <lambdabot> (forall b. (a -> b -> b) -> b -> b) -> [a]
07:42:38 <fen> it wants to refold to implement (++) in terms of (:)
07:42:55 <fen> but over these church encodings
07:43:26 <fen> compose :: (forall b. (a -> b -> b) -> b -> b)  -> (forall b. (a -> b -> b) -> b -> b)  -> (forall b. (a -> b -> b) -> b -> b) 
07:43:28 <fen> right?
07:43:40 <fen> and as there is a basecase, its a monoid?
07:44:25 <fen> not all church encodings, just those of things with get and set, like Int with pred, succ
07:44:31 <fen> (Int is like [()])
07:45:29 <fen> its a ring? as it has additive untiy (generator) (multiplicative identity)
07:45:37 <fen> with inverse... 
07:45:50 <ski> @where free-monoids
07:45:50 <lambdabot> I know nothing about free-monoids.
07:45:54 <ski> @where+ free-monoids "Free Monoids in Haskell" by Dan Doel in 2015-02-21 at <http://comonad.com/reader/2015/free-monoids-in-haskell/>
07:45:54 <lambdabot> I will never forget.
07:46:46 <fen> but it has inverse of mappend
07:46:59 <ski> (that's for fen)
07:46:59 <fen> at least, for 1 anyway...
07:47:08 <fen> thanks ski
07:47:25 <fen> just confused about how to write (++) for church encoded lists
07:47:56 <fen> and also about what to call this thing, as its more general than church encoded lists
07:48:58 <ski> fen : next thing you know, you'll write `zipWith' for church
07:50:34 <fen_> its a group?
07:51:07 <fen_> it cant be as its not cloded under repeat tail
07:51:14 <fen_> :t iterate tail
07:51:16 <lambdabot> [a] -> [[a]]
07:52:02 <fen_> just going to call them foldable containers for now
07:52:25 <fen_> mniip: it might be helpful if you can tell why thats not correct...
07:56:40 <fen_> maybe the real question is what things when scott encoded are compositional like list
07:57:44 <fen_> it seems like by deferring the specification of the (:) of build, that they dont even need to be get/set instances, just reqiering a foldr function...
07:58:33 <fen_> ski: not sure what lists not being free monoids has got to do with anything
07:59:35 <ski> "foldable things are iso to lists"
08:02:40 <fen_> ah
08:03:37 <fen_> well that just means list is defiantly not what the encoding is of
08:04:04 <fen_> thought the toList function can be used to cast the foldable thing into a list 
08:04:22 <fen_> but the idea is that it should be independent of the actual container
08:04:32 <fen_> like, thats the point of encoding it in the first place
08:05:00 <fen_> while encoded, its not sure what it is until eg build supplies the (:) and []
08:05:21 <fen_> so its not like its "an encoded list" its more like an encoded foldable thing
08:05:33 <fen_> but thats not clear from the types
08:05:53 <fen_> so there must be some extra information, which seems to be that it is compositional
08:06:12 <fen_> i.e. those encodings which form monoid 
08:06:30 <fen_> which then contains e.g. encoded lists
08:06:51 <fen_> and seems to be that foldable captures all possible instances with this property
08:06:58 <fen_> guess thats what we are trying to show
08:10:30 * hackage aeson-value-parser 0.14.1 - An API for parsing "aeson" JSON tree into Haskell types  https://hackage.haskell.org/package/aeson-value-parser-0.14.1 (NikitaVolkov)
08:19:33 <dminuoso> fen_: Here's a way to think about the church encoding:
08:21:09 <dminuoso> https://wiki.haskell.org/wikiupload/3/3e/Right-fold-transformation.png
08:22:29 * hackage cgi 3001.4.0.0 - A library for writing CGI programs  https://hackage.haskell.org/package/cgi-3001.4.0.0 (PeterSimons)
08:29:09 <__bo> I've been watching this video https://youtu.be/ZhuHCtR3xq8 and when Brian got to monoids all I could think of was 'Are monoids basically a partially applied functions?'
08:29:52 <dminuoso> __bo: That sounds... wrong.
08:29:59 <c_wraith> __bo, no.
08:30:06 <dminuoso> __bo: A monoid is just a 3-tuple.
08:30:24 <__bo> Brain_explode.jpg
08:30:35 <c_wraith> monoids are data types that support being combined associatively and have a neutral element.
08:30:44 <dminuoso> __bo: In simple terms, a Monoid is just the *set* of `mempty` and `mappend` (plus laws)
08:30:48 <dminuoso> __bo: So you could say that
08:30:52 <dminuoso> :t (mappend, mempty)
08:30:53 <c_wraith> I mean, that's just the definition, so it probably isn't useful
08:30:54 <lambdabot> (Monoid b, Monoid a) => (a -> a -> a, b)
08:31:06 <dminuoso> Uhh, that's not right wait
08:31:35 <dminuoso> __bo: Anyway. Monoid is just an interface that generalizes "smashing together in a meaningful way"
08:31:41 <__bo> Hang on, I'm scrolling through the video to get to the exact point where I got this idea
08:32:30 <dminuoso> __bo: For example: (1 + 3 + 4), (10 * 2 * 4), ("foo" ++ "bar" ++ "quux"), ((10 `min` 3) `min` 1)
08:33:33 <dminuoso> __bo: They are all somehow similar, and they are all associative, and they all have an identity (0 for sum, 1 for product, "" for string concatenation, and.. the last one is bad because you dont have an identity so it fails.
08:33:45 <__bo> 14:25, can someone watch one minute from that point? Isn't what he explains is partially applied function?
08:37:04 <bodisiw> dminuoso, can Infinity be the identity for min?
08:37:35 <c_wraith> only for types with an Infinity
08:37:58 <c_wraith> so for Double or Float, sure. but there is no largest Integer
08:38:04 <bodisiw> (10 `min` (1/0))
08:38:12 <bodisiw> i don't really know what i'm doing though
08:38:23 <bodisiw> i guess that's Fractional
08:38:35 <Taneb> Nope, would fail for Rational
08:38:39 <Taneb> > 1/0 :: Rational
08:38:41 <lambdabot>  *Exception: Ratio has zero denominator
08:39:28 <Taneb> There's not really a "Has Infinity" typeclass
08:39:41 <c_wraith> it's better to treat Min and Max as semigroups, though.
08:39:49 <c_wraith> then you don't need an identity
08:40:21 <__bo> dminuoso, I understand the 'smashing together' idea, but 'having an identity' lost me. Anyway, monoids and partially applied functions are different things, got it, thanks!
08:41:21 <Solonarv> > maxBound :: Double
08:41:23 <lambdabot>  error:
08:41:23 <lambdabot>      • No instance for (Bounded Double) arising from a use of ‘maxBound’
08:41:23 <lambdabot>      • In the expression: maxBound :: Double
08:41:30 <Solonarv> Hm.
08:41:50 <Lears> __bo: The guy is just giving one example of a monoid by showing how to combine two values of type `a -> a` (via composition). The identity is `\x -> x`.
08:46:16 <M5hadow_w1n5ton[> yee
08:47:49 <__bo> Lears, but what is monoid at the end of the day? A function?
08:48:43 <__bo> Nvm, I'll go read some wikipedia first
08:49:06 <__monty__> __bo: It's a set with an associated operation that adheres to a couple simple laws.
08:49:28 <__monty__> The set of integers with addition for example form a monoid.
08:53:52 <Welkin> is this a reasonable way to resolve this issue? https://bpaste.net/show/65d4a2e399c1
08:54:08 <Welkin> or is GHC just giving bad advice?
08:54:20 <patrl> Lears: "Having an identity" relative to an operation, just means that there's a value a, such that whenever you perform your binary operation on a and b, you always get back b
08:54:30 * hackage forma 1.1.1 - Parse and validate forms in JSON format  https://hackage.haskell.org/package/forma-1.1.1 (mrkkrp)
08:54:37 <patrl> the identity for addition on the set of integers is 0
08:54:38 <Welkin> I've always stayed away from the dubious sounding ghc extensions like "UndeciableInstances" and "Ambiguous*"
08:54:38 <merijn> Welkin: UndecidableInstances is fine
08:54:47 <patrl> since adding 0 to any integer returns that integer
08:55:05 <merijn> Welkin: UndecidableInstances just means "can't guarantee this will terminate during compilation" (in practice it will, because GHC has a timeout)
08:55:25 <merijn> Welkin: With UndecidableInstances IFF it compiles, it's fine
08:55:38 <patrl> where the identity for multiplication on the set of integers is 1, since multiplying any integer by 1 returns that integer
08:56:08 <Solonarv> AllowAmbiguousTypes is also fine now that we have TypeApplications
08:56:21 <__bo> __monty__, so... Can I say that monoid is a set of objects of some type and some operation? Provided that the function takes objects of this some type and returns something of the same type?
08:56:32 <Lears> patrl: I'm aware, you should direct your line to __bo.
08:56:41 <patrl> __bo: whoop sorry
08:56:45 <merijn> Solonarv: I disagree, since now you've made something that almost no one considers part of the public interface to be part of the public interface
08:56:51 <patrl> Lears: yeh I just noticed!!! sorry
08:56:57 <Welkin> any idea why I would get this error when using this library in my application, but building the library by itself gives no such error?
08:57:06 <patrl> __bo: see my messages above about "having an identity" ^^^
08:57:13 <__bo> patrl, thanks, reading them now
08:57:17 <Welkin> is there some kind of interaction between different extensions that could cause this?
08:57:18 <merijn> Welkin: It's basically saying it can't prove the instance resolution terminates
08:57:23 <Solonarv> alright, s/is/can be/
08:57:38 <merijn> Welkin: It might just be that the library doesn't use a problematic instance lookup internally
08:57:40 <__monty__> __bo: Oh, yeah, forgot about mempty/identity, was mixing up monoid with semigroup I think.
08:58:25 <merijn> Welkin: The default instance resolution mechanism is very constrained, but is guaranteed to terminate. UndecidableInstances uses a more flexible instance resolution algorithm, but that makes it impossible to guarantee termination
08:59:52 <__monty__> __bo: And yes, your interpretation is reasonable. Set would concretely be all values of a certain type in haskell. The only thing you're sweeping under the rug is the laws, which are the most important part.
09:00:10 <__bo> patrl, I see... So if I have a function that, say, searches for substrings in string, the empty string will be it's identity?
09:00:20 <patrl> __bo: that's exactly right
09:00:33 <__bo> __monty__, I'm trying to take it once at a time
09:00:48 <patrl> __bo: oh, uh hang on, the substring function...
09:01:04 <patrl> __bo: it's not a binary function, so not an example of a monoid
09:01:36 <patrl> __bo: the empty string is the identity for the string concatenation monoid
09:01:41 <patrl> __bo: for example
09:01:51 <fen_> dmniuoso: yeah, its just like replacing the cons with f in fold but backwards right?
09:02:05 <__bo> patrl, oh, I see, indeed
09:02:10 <__monty__> patrl: substring :: String -> String -> String seems like a binary operation to me.
09:02:19 <__monty__> Oh, right.
09:02:35 <__monty__> String -> String -> Bool
09:02:56 <__bo> Thank you gentlemen! Once again I leave this chat with more questions than I had when I came in :D
09:03:12 <fen_> probably the mappend is easy to see somehow
09:04:00 <fen_> but yeah, its via folding with cons, and the cons is abstracted away...
09:04:00 <Ariakenom> A colleague linked this saying "oh that's cool" https://clojuredocs.org/clojure.core/as-%3E
09:04:24 <Ariakenom> which inspired me to this abomination. comments? https://gist.github.com/Ariakenom/42fab6eef945a502f921e0d340e1e897 
09:04:37 <patrl> __bo: so technically, a monoid is a triple consisting of a type a, a binary operation of type a -> a -> a, and a value (the identity) of type a 
09:05:01 <patrl> that obeys certain laws
09:05:20 <fen_> Ariakenom: its a difference list?
09:05:27 <patrl> so a given type can have multiple monoid instances
09:05:42 <fen_> no it cant
09:05:49 <fen_> the laws prevent that surely 
09:05:55 <fen_> or is that monads...
09:06:03 <__bo> patrl, that's what dminuoso said at the very beginning, but now I understand it :) 
09:06:16 <patrl> Int is a good example
09:06:36 <fen_> oh because its a ring?
09:06:36 <patrl> Both (Int, (+), 0) and (Int, (*), 1) are monoids
09:06:38 <Ariakenom> fen_: no
09:06:53 <patrl> but (Int, (*), 0) isn't a monoid
09:07:30 <patrl> for technical reasons, each type in haskell actually has a unique monoid instance, but the choice is arbitrary, and additional instances are encoded using newtype wrappers
09:07:32 <__bo> patrl, But is it an actual tripple? As a structure in Haskell? Or do we just call this abstract collective entity a tripple to aid understanding?
09:08:06 <patrl> __bo: yeah, it's not actually implemented in haskell as a triple, as in the data structure
09:08:10 <Solonarv> it's a triple in the abstract sense ("three things")
09:08:30 <__monty__> __bo: Yeah, integers with addition are a monoid and integers with multiplication are a monoid too. Problem is type class resolution can't be ambiguous. So in haskell you're only allowed one.
09:08:55 <__monty__> I'll stop repeating what others already said now -.-
09:08:55 <Solonarv> To avoid ambiguity, integers in Haskell don't actually have a Monoid instance
09:09:01 <Solonarv> > mempty :: Integer
09:09:03 <lambdabot>  error:
09:09:04 <lambdabot>      • No instance for (Monoid Integer) arising from a use of ‘mempty’
09:09:04 <lambdabot>      • In the expression: mempty :: Integer
09:09:09 <__bo> I see, it's a (type, function, instance) that follows a bunch of rules
09:09:34 <__bo> Each of which follows a bunch of rules*
09:09:34 <xenon-> why was ambiguity avoided there, but wasn't for, say, lists?
09:09:39 <fen_> well its type is the first entry of this tripple, and thats a parameter to the class defining which they the instance is implemented for, and the other two values are the class defining functions, so this tripple resembles a haskell class really, except the classes can have more or less than 2 defining functions
09:10:07 <Solonarv> because for lists, one of the monoids is more obvious than the others
09:10:41 <__monty__> __bo: That's not a great way to look at it imo. It's more (Type, Monoid instance for Type) and the Monoid instance defines (function, identity) as mappend and mempty respectively.
09:10:45 <xenon-> I was talking about Applicative list instance
09:11:25 <Solonarv> ah - the 'Applicative []' instance in base is compatible with the 'Monad []' instance
09:11:29 <Solonarv> the zippy one isn't
09:12:14 <patrl> Solonarv: there is actually a zippy monoid corresponding to ziplist
09:12:22 <patrl> but it's not in base for whatever reason
09:12:52 <Solonarv> patrl: is it 'mempty = repeat mempty; (<>) = zipWith (<>)' ?
09:13:04 <patrl> it seems totally conceivable that the prelude devs could have given Int a default monoid instance, and wrapped the other in a newtype wrapper
09:13:11 <__monty__> Solonarv: Didn't consider it in detail, I guess that's why there's both Sum *and* Product.
09:13:15 <patrl> this is all a distraction from the underlying concept
09:13:20 <__bo> __monty__, so it's (Type, (function, identity)) where (function, identity) form a Monoid instance for the Type provided?
09:13:28 <fen_> class ? f where ? :: (forall b. (a -> b -> b) -> b -> b) -> (forall b. (a -> b -> b) -> b -> b) -> (forall b. (a -> b -> b) -> b -> b)
09:13:48 <__bo> __monty__, I'm basically just rewriting what you said in my own manner to confirm that I understood your point
09:14:07 <fen_> or maybe, data Church a = Church (forall b. (a -> b -> b) -> b -> b), instance Monoid Church where ....
09:14:17 <__monty__> __bo: You're kinda mixing things up. In mathematics you'd say (Set, op, unit), in haskell you say (Type, Monoid instance).
09:14:23 <fen_> where can this be found?
09:14:34 <xenon-> Solonarv, are you saying Monads couldn't have zippy instance as well?
09:15:15 <fen_> there was a bunch of work on dependant haskell for reifying local instances
09:15:24 <patrl> Solonarv: I *think* this is right
09:15:36 <Solonarv> I'm saying there isn't a "zippy" monad instance for lists, and there is a law that relates Monad and Applicative
09:15:37 <patrl> Solonarv: ignoring the newtype boilerplate
09:15:41 <fen_> for when more than one obvious choice exists and there is need to switch between them
09:15:46 <xenon-> for the record, I'm not arguing for zippy instance, just that the fact that there couldn't be two instances, doesn't mean that neither should be picked
09:16:11 <Solonarv> patrl: (Ap ZipList a) is what you're looking for
09:16:22 <fen_> its actually a really powerful pattern, allowing the class functions to be used to define another function, but alowing these class defining function to be overridden at runtime
09:16:25 <__bo> __monty__, thank you sir
09:16:26 <Solonarv> Ap is from Data.Monoid, and I forget where ZipList is defined
09:16:29 <xenon-> Solonarv, that just shifts the question from "Why isn't Applicative list instance zippy" to "Why isn't Monad list instance zippy?"
09:16:41 <patrl> Solonarv: aha, thanks!
09:16:46 <Solonarv> xenon-: because it can't be zippy and still be law-abiding
09:16:55 <Solonarv> I don't have a detailed proof ready, sorry
09:17:10 <xenon-> I don't see how that is the cases
09:17:16 <Solonarv> patrl: Ap is the newtype wrapper for "lift through an applicative"
09:17:29 <Solonarv> xenon-: what would a zippy monad instance look like? try defining it!
09:18:47 <fen_> if you cant answer your own question your not qualified to ask it!
09:20:31 <fen_> whats the mempty instance for church encoded foldable containers?
09:20:40 <fen_> or scott encoding, not sure
09:21:23 <Solonarv> fen_: Church (\_ z -> z) using the definition you posted above
09:21:45 <fen_> that is forgetful?
09:22:23 <fen_> if there were 2 church/scott encoded lists, would the mappend of the encoding be the encoding of the mappend?
09:23:00 <Solonarv> well, I don't know what your mappend definition is
09:23:16 <Solonarv> what I gave certainly denotes the empty list
09:23:17 <fen_> for list!?
09:23:37 <fen_> > "hello" ++ "world"
09:23:39 <lambdabot>  "helloworld"
09:23:47 <fen_> its fold with cons
09:24:09 <fen_> with the basecase as the snd arg
09:24:23 <fen_> > foldr (:) "world" "hello "
09:24:26 <lambdabot>  "hello world"
09:24:31 <Solonarv> right, what does that look like for your 'Church' type?
09:25:16 <fen_> the first arg to build
09:25:40 <fen_> so bulding 2 things and (++)ing them, is the same as mappend the 2 encodings
09:25:47 <fen_> > % :t build
09:25:50 <lambdabot>  <hint>:1:1: error: parse error on input ‘%’
09:25:51 <fen_> % :t build
09:25:51 <yahb> fen_: (forall b. (a -> b -> b) -> b -> b) -> [a]
09:26:20 <fen_> build f1 ++ build f2 = build (f1 <> f2)
09:26:48 <Solonarv> % newtype ListC a = ListC (forall b. (a -> b -> b) -> b -> b)
09:26:49 <yahb> Solonarv: 
09:27:53 <Solonarv> % instance Semigroup (ListC a) where ListC xs <> ListC ys = \k z -> xs k (ys k z)
09:27:53 <yahb> Solonarv: ; <interactive>:54:59: error:; * Couldn't match expected type `ListC a' with actual type `(a -> b0 -> b0) -> b0 -> b0'; * The lambda expression `\ k z -> xs k (ys k z)' has two arguments,; but its type `ListC a' has none; In the expression: \ k z -> xs k (ys k z); In an equation for `<>': ListC xs <> ListC ys = \ k z -> xs k (ys k z); * Relevant bindings include; ys :
09:28:08 <Solonarv> % instance Semigroup (ListC a) where ListC xs <> ListC ys = ListC (\k z -> xs k (ys k z))
09:28:08 <yahb> Solonarv: 
09:28:11 <fen_> guess this is a kind of special kind of monoid that has a unit generator where the mappend is defined in terms of it
09:28:27 <Solonarv> % instance Monoid (ListC a) where mempty = ListC (\_ z -> z)
09:28:27 <yahb> Solonarv: 
09:28:55 <Solonarv> % instance Foldable ListC where foldr f z (ListC xs) = xs f z
09:28:55 <yahb> Solonarv: 
09:29:26 <Solonarv> % toList (mempty :: ListC ())
09:29:26 <yahb> Solonarv: ; <interactive>:58:1: error:; Ambiguous occurrence `toList'; It could refer to either `Data.Foldable.toList', imported from `Data.Foldable'; or `GHC.Exts.toList', imported from `GHC.Exts'
09:29:39 <Solonarv> % Data.Foldable.toList (mempty :: ListC ())
09:29:39 <yahb> Solonarv: []
09:29:47 <Solonarv> fen_: does this help?
09:29:54 <fen_> % hello = ListC (foldr "hello")
09:29:54 <yahb> fen_: ; <interactive>:60:16: error:; * Occurs check: cannot construct the infinite type: b ~ a -> b -> b; Expected type: (a -> b -> b) -> b -> b; Actual type: b -> (a -> a0) -> b; * In the first argument of `ListC', namely `(foldr "hello")'; In the expression: ListC (foldr "hello"); In an equation for `hello': hello = ListC (foldr "hello"); * Relevant bindings include hello
09:30:15 <fen_> % hello = ListC (flip (flip . foldr) "hello")
09:30:15 <yahb> fen_: ; <interactive>:61:1: error:; * Could not deduce (Foldable t0); from the context: (Foldable t, IsString (t a)); bound by the inferred type for `hello':; forall (t :: * -> *) a. (Foldable t, IsString (t a)) => ListC a; at <interactive>:61:1-43; The type variable `t0' is ambiguous; * In the ambiguity check for the inferred type for `hello'; To defe
09:30:17 <Solonarv> % hello = ListC (\f z -> foldr f z "hello")
09:30:17 <yahb> Solonarv: ; <interactive>:62:1: error:; * Could not deduce (Foldable t0); from the context: (Foldable t, IsString (t a)); bound by the inferred type for `hello':; forall (t :: * -> *) a. (Foldable t, IsString (t a)) => ListC a; at <interactive>:62:1-41; The type variable `t0' is ambiguous; * In the ambiguity check for the inferred type for `hello'; To defe
09:30:22 <Solonarv> gah!
09:30:54 <fen_> not foldable?
09:30:59 <Solonarv> % hello = ListC (\f z -> foldr @[] f z "hello")
09:30:59 <yahb> Solonarv: 
09:31:00 * hackage servant-namedargs 0.1.0.0 - Combinators for servant providing named parameters  https://hackage.haskell.org/package/servant-namedargs-0.1.0.0 (CullinPoresky)
09:31:16 <Solonarv> just OverloadedStrings causing ambiguity
09:31:27 <Solonarv> % Prelude.toList hello
09:31:27 <yahb> Solonarv: ; <interactive>:64:1: error:; Not in scope: `Prelude.toList'; Perhaps you meant one of these: `Prelude.const' (imported from Prelude), `Prelude.showList' (imported from Prelude), data constructor `Prelude.Just' (imported from Prelude); No module named `Prelude' is imported.
09:31:33 <Solonarv> o rly?
09:32:05 <fen_> % toListC xs = ListC (\f z -> foldr @[] f z xs)
09:32:05 <yahb> fen_: 
09:32:42 <Solonarv> % ftoList = Data.Foldable.toList
09:32:43 <yahb> Solonarv: 
09:33:06 <Solonarv> % ftoList hello
09:33:07 <yahb> Solonarv: "hello"
09:33:13 <fen_> % test = foldMap toListC ["hello"," ","world"]
09:33:13 <yahb> fen_: 
09:33:29 * hackage typograffiti 0.1.0.3 - Just let me draw nice text already  https://hackage.haskell.org/package/typograffiti-0.1.0.3 (SchellScivally)
09:33:35 <fen_> % ftoList test
09:33:35 <yahb> fen_: "hello world"
09:33:39 <fen_> woot
09:33:50 <fen_> thanks
09:33:56 * Solonarv bows
09:35:52 <fen_> instance Semigroup (ListC a) where ListC xs <> ListC ys = ListC (\k z -> xs k (ys k z))
09:36:10 <fen_> so that folds over the first list?
09:36:18 <fen_> like the (++) implementation?
09:38:55 <Solonarv> yup
09:39:26 <fen_> ok right, it builds the ys with k, then builds the xs with k using ys as the basecase
09:39:38 <fen_> using the built ys*
09:41:28 <fen_> almost like the continuation monad instance
09:42:13 <fen_> so is it slow this implementation?
09:42:33 <fen_> does it have a get/set ?
09:42:43 <fen_> like pattern matching on cons
09:43:01 <fen_> or is that just k?
09:43:51 <xenon-> Solonarv, I tried, and failed. but I have a question: how is current Monad bind any more non-zippy than it is zippy?
09:44:17 <Solonarv> xenon-: >>= can be used to implement <*>
09:44:47 <Solonarv> for [], this gives the "cartesian product" variant of <*>
09:45:10 <xenon-> Solonarv, is that a requirement? that <*> has to be implementable with >>=
09:45:33 <Solonarv> xenon-: it's a requirement that <*> must match the implementation derived from >>=
09:46:51 <Solonarv> (this implementation is 'af <*> ax = af >>= \f -> fmap f ax', IIRC)
09:48:30 <fen_> setC :: a -> ListC a -> ListC a; setC x (ListC xs) = ListC (\k z -> x `k` (ys k z))
09:48:33 <fen_> is that right?
09:48:56 <xenon-> Solonarv, I'm looking at monad/applicative laws, and I'm not sure I can identify that requirement
09:49:17 <Solonarv> it should be phrased as "<*> must be equivalent to 'ap'" or something similar
09:49:27 <xenon-> one could argue that different liftA2 and liftM2 would be useful :P
09:50:03 <Amras> how would you argue that?
09:50:52 <xenon-> Amras, it would give liftM2 a purpose, instead of just being useless relic
09:51:05 <johnw> Amras: it's true in Haxl
09:51:46 <Amras> surely the solution would be to deprecate liftM2 rather than vary the behavior
09:51:54 <Lears> xenon-: liftM/liftM2/ap are pretty useful how they are.
09:52:22 <Amras> but I'll happily accept that I'm an inexperienced idiot
09:52:23 <Lears> They mean you don't have to write Functor and Applicative instances by hand if you're writing a Monad instance.
09:52:46 <Solonarv> they're already as minimal as it gets tbh
09:52:52 <Solonarv> Functor can be derived
09:52:58 <Lears> Not always.
09:53:04 <xenon-> Lears, that's actually a good point
09:53:23 <Solonarv> oh derp I misunderstood what you were saying
09:54:54 <xenon-> so.. is concatMap the only possible bind implementation for list?
09:55:17 <iqubic> ski: You said I wanted a sum of products.
09:55:39 <Solonarv> xenon-: there might be alternate ones which mess around with the element order somehow
09:55:48 <Solonarv> but I can't think of any concrete ones
09:56:05 <iqubic> You were right. That is exactly what I ended up creating to deal with things like "1 + 2 * 3" -> "1 + (2 * 3)"
09:56:11 <fen_> Solonarv: why were the examples using ftoList?
09:56:14 <fen_> why not build?
09:56:41 <Solonarv> fen_: ftoList is just an alias for Data.Foldable.toList
09:57:09 <Solonarv> I guess I could've called the alias 'build' instead, but I doubt that really matters
09:57:19 <iqubic> so I'm running into a roadblock with megaparsec.
09:57:20 <fen_> it does, one has fusion!
09:57:43 <xenon-> heh
09:57:55 <fen_> thats the whole point of this implementation
09:58:01 <Solonarv> ah, you went into this because you want to understand fusion?
09:58:02 <fen_> or encoding
09:58:10 <xenon-> I tried to follow Lears recommendation (the way I understood it, anyway), and ended up in infinite loop
09:58:29 <fen_> Solonarv: build uses this encoding
09:58:33 <iqubic> If I try to write: isJust $ optional $ char '-'
09:58:36 <Solonarv> yes, I'm aware of that
09:58:46 <fen_> so why use toList?
09:59:07 <Solonarv> ...so that we can see what the result(s) of operations on ListC are?
09:59:10 <iqubic> And it failed saying that it couldn't unify "Token m0 ~ Char" or somehthing like that.
09:59:16 <fen_> is there something going on with the Foldable instance?
09:59:29 <Solonarv> no, not at all
09:59:51 <xenon-> https://pastebin.com/c8pqYbXa <- infinite loop
09:59:59 <Solonarv> (forall b. (a -> b -> b) -> b -> b) is foldr with its list argument already applied
10:00:11 <xenon-> probably cyclic default definitions of some functions
10:00:11 <fen_> yeah but build would have returned a list as well, and whats more, if this list were folded over, it would replace the k and z which build sets to be (:) and []
10:00:22 <fen_> toList wouldnt do that, it wouldnt fuse?
10:00:44 <Solonarv> xenon-: you have pure = return, but there is a default 'return = pure'
10:00:54 <xenon-> ah
10:01:11 <Solonarv> fen_: toList is just 'foldr (:) []'
10:01:16 <iqubic> You need to define either pure or return your self.
10:01:56 <xenon-> yeah I know. I defined all three type classes, but then tried to define Functor and Applicative using Monad, without giving it much thought
10:03:22 <iqubic> xenon-: That will give you some infinite loops for sure.
10:04:02 <fen_> Solonarv: but the compiler cant tell that build should be used instead...
10:04:02 <Solonarv> only one loop, actually (between 'return' and 'pure')
10:04:35 <Solonarv> fen_: what is your point?
10:04:55 <iqubic> Solonarv: Ah, right.
10:05:05 <iqubic> So you either need to define return, or pure.
10:05:23 <Solonarv> the definitions I posted were an answer to your question about mappend/mempty for (forall b. (a -> b -> b) -> b -> b)
10:05:46 <fen_> Solonarv: the point is to have build fold fusion work over these things
10:06:25 <fen_> so that for instance if (forall b. ((i,a) -> b -> b) -> b -> b) were used instead, there would be a corresponding fusion
10:07:31 <fen_> this means containers could be converted between by functions on their structure directing indexes (extra args to get and set) without incurring a performance hit
10:08:25 <fen_> well, as long as the conversion is i -> i' = id, where anything else would be costly, but the point is that cost isnt the big issue, the saving is not having to fold over the thing rebuilding it a buch of times
10:08:54 <fen_> there was a thing earlier about mono containers?
10:09:09 <xenon-> it has been a while since I did something like this.. kind of awesome how little code it takes to make a fully usable container, that can use all the functions from Foldable, Monad, Applicative and Functor. https://pastebin.com/265ViUwy
10:09:12 <fen_> that is, get is just split where the lhs of the pair of things returned is mono
10:09:37 <fen_> and a representation for mono f is (a,forall b. f b)
10:09:52 <fen_> then if you can fold over f, but getting the shape along the way, then this is
10:09:59 <xenon-> 24 lines total, toList/fromList are just there for fun
10:10:00 <fen_> (a,[j])
10:10:04 <fen_> where j is the shape
10:10:07 <iqubic> Yes. This will work.
10:10:12 <Lears> xenon-: In this case you can even derive Functor and Foldable.
10:10:32 <Lears> And append can probably be written with a 1-line fold.
10:10:37 <xenon-> what gives us foldable?
10:10:38 <iqubic> If you enable the right LANGUAGE PRAGMAS
10:10:52 <fen_> but, then you would have to fold over that list of j's and thats were you would want to use fusion, to just modifies the original folding that returned the j's
10:11:15 <Lears> DeriveFoldable makes it a stock derivable class.
10:11:24 <fen_> so then get has type; f a -> ((a,Scott a),f a)
10:11:35 <Solonarv> xenon-: toList is a method of Foldable, actually
10:11:44 <Solonarv> no need to define it separately, you get it for free
10:11:51 <xenon-> I did deriving (Show, Functor, Foldable), and I'm getting       * Overlapping instances for Functor List         arising from the second field of `Cons' (type `List a')
10:11:55 <fen_> which has a trivial set instance, which uses the j's
10:12:01 <xenon-> oh, I didn't remove Functor instance
10:12:07 <iqubic> Where did Scott come from?
10:12:15 <fen_> oh sry
10:12:19 <fen_> um, ListC
10:13:17 <fen_> its for things like data Skip2 a = Skip1 (Skip a) | Skip2 (Skip a) | Value a | End
10:13:19 <sedeki> (<*>) :: f (a -> b) -> f a -> f b
10:13:34 <sedeki> what does `f ( a -> b)` mean?
10:13:34 <fen_> the `j' is then Bool
10:13:49 <fen_> for the 2 choices of empty gaps in the container (its shape)
10:13:56 <sedeki> is the return value of `a -> b` wrapped in a `f` ?
10:14:21 <Solonarv> sedeki: no, it's a function from 'a' to 'b' wrapped in 'f'
10:14:46 <sedeki> Solonarv what does that even mean?
10:15:00 <iqubic> :t Just id
10:15:02 <lambdabot> Maybe (a -> a)
10:15:09 <fen_> the point is that get will return a value always, but there is also something that deconstructs the "substructure" inbetween the values
10:15:11 <xenon-> can I put several LANGUAGE pragmas in a single line?
10:15:11 <sedeki> aha...
10:15:12 <sedeki>  i see
10:15:14 <Solonarv> sedeki: in Haskell, functions are values like any other
10:15:20 <iqubic> xenon-: Yes. 
10:15:26 <sedeki> Solonarv thanks
10:15:29 <fen_> and its something very similar to get..
10:15:35 <Solonarv> xenon-: {-# language Foo, Bar, Baz #-}
10:15:41 <fen_> more on this soon
10:15:44 <fen_> peace
10:17:10 <xenon-> 14 lines for a fully functional List datastructure, with Monad, Applicative, Functor and Foldable instances. https://bpaste.net/show/f596d238552a
10:18:53 <johnw> append = flip (foldr Cons)!
10:18:54 <hyperisco> xenon-, append forms a Semigroup
10:19:20 <xenon-> I could probably put foldr in Bind, would shave two more lines
10:19:27 <xenon-> and scratch append
10:21:18 <Lears> Append is probably more important than Monad though.
10:22:43 <Solonarv> you might also want MonadZip
10:23:00 * hackage servant-namedargs 0.1.0.1 - Combinators for servant providing named parameters  https://hackage.haskell.org/package/servant-namedargs-0.1.0.1 (CullinPoresky)
10:25:56 <hyperisco> to this day I feel reluctant about pulling in lenses… why
10:26:17 <Amras> good question, lenses are great
10:26:29 <Amras> maybe they feel too objecty?
10:27:05 <hyperisco> I thin I rue defining them
10:27:13 <mpwd> Amras, if you are using template haskell all the time to generate lenses, they add a lot of compile time in my experience
10:28:25 <hyperisco> that's why… there is a feature in VS called T4
10:28:39 <hyperisco> but generally speaking it is "design time compilation"
10:28:56 <hyperisco> I think there is a sore lack of that in software development
10:29:57 <geekosaur> or just https://ro-che.info/ccc/23
10:30:09 <Amras> compile time only applies while you're working on the specific module though; couldn't you just move the lenses out somewhere? Or am I misunderstanding
10:32:20 <hyperisco> lots of ways to trigger a rebuild
10:32:27 <mpwd> Amras, my company uses haskell for everything.  We avoid orphan instances so every data type declaration comes with some makelense boilerplate. We tend to use lenses everywhere, and it always slows down CI and fresh builds (which we have to resort to from time to time).
10:32:38 <Mrbuck> can we write c an c++ as beautiful as haskell ?
10:32:57 <Mrbuck> I mean code looking when we see shrt and sweet
10:33:23 <Amras> Mrbuck: sure, it's called Python
10:33:27 <hyperisco> C is short and sweet, just for different things
10:34:16 <hyperisco> for (int i = 0; i < sizeof(xs); ++i) ys[i] = xs[i];
10:34:24 <hyperisco> for an array copy, for example
10:34:41 <mpwd> hyperisco, Have you played with generic-lens? http://hackage.haskell.org/package/generic-lens
10:34:49 <hyperisco> nope
10:34:53 <johnw> fwiw, (int i = sizeof(xs); i--; ) can be faster
10:34:54 <mpwd> We plan to move to this
10:35:11 <Amras> --i you mean
10:35:17 <johnw> maybe I do
10:35:21 <Amras> >_>
10:35:25 <johnw> it's been a couple decades :)
10:35:25 <johnw>  
10:36:27 <johnw> if the size is 1, wouldn't --i fail to copy anything?
10:37:19 <hyperisco> you would start at  i = sizeof(xs) - 1  first off
10:37:29 <hyperisco> and your condition would be  i >= 0
10:37:40 <johnw> the trick is to not use a separate condition
10:37:46 <hyperisco> the decrement happens after
10:37:57 <hyperisco> not a separate condition for what?
10:38:06 <johnw> for (int i = sizeof(xs); i--; )
10:38:12 <hyperisco> oh I see, haha, damn C
10:38:20 <mpwd> johnw, for int I think 'i--' and '--i' will compile to the same assembly in that loop.  But for other data types `i--` can involve accessess i twice, and since access can have side effects its prerable to do `--i`
10:38:23 <johnw> a friend showed me that this reduces to like 3 Intel instructions
10:38:25 <hyperisco> sorry I just assumed you mistyped that
10:38:52 <zachk> johnw, whats the other way reduce to?
10:38:53 <hyperisco> okay but your assignment is  ys[i-1] = xs[i-1]  then
10:38:58 <Amras> oh right, so did I
10:39:09 <johnw> zachk: I think it was 7 or something
10:39:22 <Amras> i-- then, fair enough
10:39:27 <johnw> this was back in the day when it mattered, though
10:39:31 <hyperisco> johnw, i-- means to decrement after, --i means to decrement before
10:39:35 <johnw> nowadays, more instructions sometimes help the cache pipeline!
10:39:44 <hyperisco> johnw, before what and after what is an enigma
10:39:49 <johnw> hyperisco: yeah, I kind of know that :)
10:40:03 <hyperisco> johnw, well, just saying, you definitely meant i-- and not --i
10:40:20 <johnw> yep
10:40:32 <zachk> you still have branch prediction and pipelining though 
10:40:36 <johnw> sorry, didn't mean te infect #haskell with C golfing
10:40:49 <johnw> just took me back
10:40:58 <hyperisco> no I like it… Assembly programming through the mask of C
10:41:21 <saml> haskell is a good replacement to assembly in ph.d papers
10:41:30 <zachk> at least c is more portable then assembly 
10:41:56 <hyperisco> you know, that is terrifying to say zachk
10:41:59 * hackage servant-server-namedargs 0.1.0.0 - Automatically derive API server functions with named and optional parameters  https://hackage.haskell.org/package/servant-server-namedargs-0.1.0.0 (CullinPoresky)
10:42:20 <saml> what's portable mean?
10:42:56 <johnw> programming with servant these days makes C feel like an evolutionary cycle of yesteryear
10:42:56 <Welkin> you can carry it in one hand
10:43:13 <hyperisco> it weighs less than 12lbs
10:43:14 <Amras> saml: you can use the same code on multiple machines, ish
10:43:25 <saml> You can write a program in C, and write compilers to different target
10:43:40 <Welkin> portability is overrated
10:43:54 <Welkin> remmber when that was the promise of the jvm? "Write once, run everywhere!"
10:43:55 <Mrbuck> wow you genius people 
10:43:56 <saml> so you can compile to llvm  and let llvm generate code for target arch
10:44:05 <zachk> I have had ok luck with portable haskell code from windows to linux, if I don't *nix specific stuff 
10:44:06 <johnw> arguably, jvm did deliver on that promise
10:44:19 <zachk> Welkin, android kinda broke that :( 
10:44:20 <Mrbuck> I asked a question went to drink water and back I see a bg discussing  with small snippets on it 
10:44:34 <johnw> Mrbuck: we're bored, what can we say
10:45:07 <johnw> I'm looking forward to compiling Haskell to WebAssembly
10:45:12 <saml> you can build docker image and run everywhere
10:45:17 <Welkin> why?
10:45:20 <Mrbuck> johnw:  I wish I am such expert
10:45:21 <zachk> johnw, can we do that yet? 
10:45:23 <Mrbuck> I am bored always
10:45:24 <johnw> Welkin: I don't know yet
10:45:25 <Welkin> why do you want to run haskellin the browser?
10:45:30 <luite> why not?
10:45:34 <johnw> zachk: yeah, WebGHC or Asterius
10:45:38 <zachk> oh
10:45:44 <Chousuke> if you want a "run-anywhere" java application it means you have to include a framework that obfuscates all details about how the programs actually starts up, along with at least 600 lines of shell script to set the framework up properly :P
10:45:44 <saml> because haskell is declarative and makes you bug free
10:45:46 <Welkin> I didn't ask why not, I asked if you had a reason why
10:45:53 <johnw> Welkin: actually, I want WebAssembly to become a more universal vm than just browsers
10:45:53 * Chousuke has had some bad experiences lately
10:46:04 <Solonarv> saml: neither of those things are true in general
10:46:14 <hyperisco> johnw, thank-you, keep fighting the good fight
10:46:26 <johnw> at my work we're using WebAssembly as an execution platform, having nothing to do with browsers
10:46:47 <hyperisco> I am not sure what makes it so special… it seems like the nth stack based IL
10:46:57 <johnw> the fact that the standard for Wasm actually includes a formal semantics that's been machine-checked wins me over
10:47:09 <hyperisco> but if it lures web people into using it then I call that a victory
10:47:20 <johnw> other than that, it's just a stack based IL :)
10:47:29 <hyperisco> because that means JavaScript won't have to be the compilation target anymore
10:47:33 <johnw> exactly
10:47:45 <Welkin> saml: for haskell in the browser there are better options that you can use in production today, easily. Namely Elm
10:49:18 <hyperisco> though asmjs seems to have… well I am not sure what is going on with it but I'm not seeing much traction
10:49:38 <johnw> https://hacks.mozilla.org/2017/03/why-webassembly-is-faster-than-asm-js/
10:50:04 <hyperisco> NaCl is belly up and encourages wasm now
10:50:24 <hyperisco> well I am not sure the problem with asmjs was that it was too slow
10:50:31 <johnw> i wonder when we'll have an ISA that can execute Wasm directly
10:50:34 <hyperisco> there is even Emscripten which ports llvm to asmjs
10:51:51 <hyperisco> at any rate, for the way the web is today, having an IL makes way more sense than an ordained PL like JavaScript
10:52:15 <johnw> yes, an IL makes optimizations and transformations much saner
10:52:32 <johnw> btw, if anyone is interested my company is soon to open source a Haskell implementation of a Wasm interpreter
10:52:41 <johnw> it needs some optimization work, if anyone is interested in collaborating
10:52:53 <hyperisco> it also encourages a plurality of languages, and the web should be about such diversities
10:53:37 * hyperisco *shrugs*
10:53:41 <hyperisco> if you have a link I will at least look
10:53:53 <hyperisco> the antiquated platform I have to work with does not support wasm sadly
10:54:20 <johnw> I'll ping you in a few weeks or months; I still have to put the finishing touches on the docs, and get admin approval to flip the switch
10:54:41 <johnw> but it passes all of the positive spec tests aside from floating point (another area that needs some work)
10:54:46 <hyperisco> ah the "it'll be ready when it's ready" timeline, I like it
10:54:56 <johnw> it's not a priority
10:55:11 <johnw> we use V8 now, but we used this Haskell implementation for a while
10:55:21 <bsima> johnw: what does your company do with wasm? I might be interested in this interpreter
10:55:22 <hyperisco> why an interpreter
10:55:47 <johnw> it's an interpreter because we turn binary-encoded Wasm modules into AST representations, and then interpret the code within them
10:55:56 <johnw> but you could use this library as the basis for a real compiler
10:56:12 <hyperisco> you just described what an interpreter does
10:56:14 <johnw> bsima: I work at DFINITY, we're using it as the basis for a distributed computation network
10:56:34 <johnw> hyperisco: um, it's an interpreter because I didn't take the time to write a compiler? :)
10:57:11 <johnw> I think it could be a useful library for writing Wasm transformations
10:57:12 <hyperisco> modern browsers compile wasm, and though I am not sure I suspect that compiler can be divorced from the browser
10:57:19 <bsima> johnw: huh, i might be joing a startup doing a similar thing, and was also thinking of using wasm or a similar risc for edge devices...
10:58:45 <hyperisco> well lets say then that if Haskell ever wanted a wasm backend that what you have is a keystone for that
10:59:06 <johnw> I bet that WebGHC contains a far better backend than what I've done
10:59:07 <hyperisco> or any compiler implemented in Haskell for that matter
10:59:09 <bsima> granted i'm working on computer vision, not dapps
10:59:47 <hyperisco> never heard of webghc before
10:59:52 <johnw> the main thing writing this interpreter did was help me understand Wasm a lot better
10:59:56 <luite> hyperisco: the JS/Wasm engines are reasonably self-contained, quite usable as a library
11:00:22 <wroathe> Is it me or is TypeApplications a super clean syntax
11:00:25 <hyperisco> Ah it is luite the ghcjs guru! How be you?
11:00:30 <johnw> I _love_ TypeApplications
11:00:33 <johnw> I overuse them, definitely
11:00:48 <hyperisco> system F is chuckling
11:01:55 <MarcelineVQ> does cabal-install build with -O1 if it's not specified in ghc-options: ?
11:02:39 <johnw> MarcelineVQ: that's always been my understanding
11:03:02 <wroathe> MarcelineVQ: you can check by passing --verbose to your next build
11:03:33 <hyperisco> according to this https://webghc.github.io/roadmap the goal is to make an llvm backend for GHC which is compatible with wasm… I am guessing through a tool like Emscripten
11:04:06 <MarcelineVQ> Mine too but wanted to ask around. wroathe: Ah I'm not building with cabal-install because it's broken on my system but I can probably still check the flags that way so thanks for the suggestion
11:05:02 <Solonarv> there is also --dry-run (IIRC) to make it not actually do anything
11:05:14 <hyperisco> last I recall, and they touch on these issues too, is that LLVM is a square hole for the round peg of Haskell
11:06:19 <xenon-> sedeki, you get f (a -> b) when you partially apply a function to f
11:06:34 <hyperisco> also that timeline looks adorable
11:06:38 <Solonarv> xenon-: no, that's misleading and not true in general
11:06:43 <xenon-> > (+) <$> (Just 10)
11:06:45 <lambdabot>  Just <Integer -> Integer>
11:06:47 <hyperisco> so the first two weeks are about bikeshedding the website, lol
11:06:54 <luite> MarcelineVQ: the user can still override optimization through the configure options (--disable-optimization) or project file
11:07:19 <hyperisco> then apparently it will take just two months to complete
11:07:51 <xenon-> Solonarv, I don't think that is misleading at all, that is one of one of the main differences (that and pure) between Applicative and Functor, ability to have liftAN. <*> allows us to write liftAN
11:08:02 <xenon-> > (+) <$> Just 10 <*> Just 20
11:08:04 <lambdabot>  Just 30
11:08:06 <hyperisco> I'll check back in 3 years when they're finally pushing for the big 1.0 release
11:08:08 <MarcelineVQ> luite: thanks, I'm running into disparate behavior because a project is leaving off -O1 or -O2 in the .cabal file and stack doesnm
11:08:09 <Solonarv> xenon-: it's not necessarily partially applied
11:08:15 <Solonarv> > Just id
11:08:16 <MarcelineVQ> 't seem to add those in its own.
11:08:17 <lambdabot>  error:
11:08:17 <lambdabot>      • No instance for (Typeable a0)
11:08:18 <lambdabot>          arising from a use of ‘show_M150851699418850654900’
11:08:34 <Solonarv> > Just (id :: Integer -> Integer)
11:08:36 <lambdabot>  Just <Integer -> Integer>
11:08:39 <xenon-> Solonarv, I did not say that is the only way to get f (a -> b)
11:08:54 <johnw> > Just (id @Integer)
11:08:56 <lambdabot>  error:
11:08:56 <lambdabot>      Pattern syntax in expression context: id@Integer
11:08:56 <lambdabot>      Did you mean to enable TypeApplications?
11:08:58 <johnw> aww
11:09:00 <Solonarv> if you say "X is Y" that usually means "all X are Y"
11:09:10 <Solonarv> ah, but I see now - you didn't say that
11:09:57 <xenon-> yep
11:11:22 <wroathe> hyperisco: Who are you talking to :P?
11:11:28 <wroathe> hyperisco: Just everyone in particular?
11:11:35 <hyperisco> myself I guess
11:11:53 <bsima> hyperisco: i'm listening
11:11:57 <wroathe> Better answers that way
11:12:47 <hyperisco> I was advised to surround myself with smart people and this is the result of that
11:14:01 <wroathe> hyperisco: It resulted in you talking to yourself in a crowded room? :P
11:14:30 * hackage servant-client-namedargs 0.1.0.0 - Automatically derive API client functions with named and optional parameters  https://hackage.haskell.org/package/servant-client-namedargs-0.1.0.0 (CullinPoresky)
11:14:31 <hyperisco> no one advised I had to converse with them
11:15:58 <hyperisco> I have a feeling this is an undergrad research project being done over the summer
11:16:16 <luite> MarcelineVQ: ah I generally increase the verbosity and use -j1 to see what's being passed to GHC
11:16:22 <hyperisco> "From our preliminary research, we believe the first two main objectives should be able to be completed reasonably quickly (possibly ahead of schedule)."
11:17:03 <hyperisco> The optimism exudes from every statement.
11:20:55 <hyperisco> Has anyone sat back and admitted that it will take 16 months to produce their basic mobile app?
11:21:53 <hyperisco> Or is the knowledge of where the next year or two of your life will be spent too fatalistic?
11:25:45 <Welkin> did you tell them you can rebuild their 80k loc legacy system in 100 hours?
11:25:55 <Welkin> because I've heard that before
11:26:39 <boj> the optimistic words of the inexperienced
11:27:27 <Welkin> I actually delivered ahead of schedule on my first job
11:27:42 <boj> i think i did too. it was terrible, terrible software
11:27:53 <Welkin> I told thme 3 months when I had no idea how long it would take. I did work 80 hour weeks, but I delivered in 2.5 months with lots of feature creep
11:35:37 <suzu> were you rewarded for it?
11:51:01 <elvishjerricco> Anyone tried to log all requests / responses (including bodies) with http-client?
11:57:11 <johnw> elvishjerricco: I tend to just use mitmproxy
12:06:50 <elvishjerricco> johnw: Blegh. Having to setup a proxy server and a CA sounds like a major pain
12:13:29 * hackage cantor-pairing 0.1.1.0 - Convert data to and from a natural number representation  https://hackage.haskell.org/package/cantor-pairing-0.1.1.0 (identicalsnowflake)
12:15:03 <xenon-> why isn't Applicative deriveable, given Monad?
12:15:20 <xenon-> in the spirit of DeriveFunctor
12:16:03 <lyxia> You can use DerivingVia    deriving Applicative via (Ap MyType)
12:16:38 <lyxia> oh wait no it's not called Ap...
12:16:43 <xenon-> huh
12:16:59 <lyxia> via (WrappedMonad MyType)
12:17:37 <xenon-> how does this work? I thought we needed Monad and/or Applicative to be able to derive Functor, Foldable. https://bpaste.net/show/074c38995dc9
12:17:47 <lyxia> DeriveFunctor actually needs to look at the definition of your type, it doesn't use an Applicative instance even if you define one.
12:18:31 <lyxia> GHC derives instances for Functor, Foldable, Traversable by generating custom code for them.
12:19:15 <xenon-> so I guess it would not be able to do the same for a bit more complex type.. that's a bit disappointing
12:21:35 <xenon-> can foldr be written using just a Monad instance?
12:21:48 <byorgey> no
12:22:06 <lyxia> It is pretty rare that a type has a useful Traversable instance that can't be derived.
12:23:24 <geekosaur> this discussion suggests someone needs to go look at the typeclassopedia
12:24:01 <xenon-> I've read it, but would probably be useful to go through it again
12:24:11 <Solonarv> if foldr could be written using a Monad instance, Foldable would be a superclass of Monad
12:24:13 <xenon-> what typeclasses would we need to derive Foldable instance?
12:24:30 <Heffalump> Foldable :-)
12:24:41 <__monty__> Solonarv: Not the other way around?
12:25:07 <Solonarv> __monty__: <*> can be implemented in terms of a Monad instance, therefore Applicative is a superclass of Monad
12:25:30 <__monty__> Oh, right.
12:26:25 <__monty__> Wait, no, that aligns with what I thought. Applicative is now Monad and Monad is now Foldable, no?
12:26:44 <__monty__> Modulo the <*>.
12:27:32 <Solonarv> I made an analogy between Applicative and Foldable
12:27:34 <xenon-> every Monad is Applicative and Functor. every Applicative is a Functor
12:28:23 <__monty__> Solonarv: Yep, you're right, and I was wrong twice : )
12:28:41 <__monty__> Thank god I don't do OOP anymore...
12:29:14 <xenon-> it does seem a bit counterintuitive that Applicative is a superclass of Monad, not the other way around
12:29:39 <xenon-> instinctively, I would have thought that superclass == superset
12:29:57 <hyperisco> xenon-, it is a superset
12:30:06 <MarcelineVQ> If the methods of A can implement the methods of B, A must also be a B.
12:30:20 <xenon-> hyperisco, superset in terms of features and power
12:30:32 <zachk> I guess that is kind of confusing
12:30:53 <zachk> to me somethings descends/inherits from its superclass all features and may add new ones 
12:31:24 <Solonarv> yes exactly
12:31:38 <Solonarv> "cars" is a superset of "red cars"
12:32:05 <Solonarv> and a red car has all the features of a car
12:33:21 <zachk> i would more say vehicles is a superclass of cars 
12:33:35 <Solonarv> yes, that's a better example
12:34:01 <zachk> :) Solonarv just thought about your example a bit more and then never thought of english grammar and superset like that!
12:34:31 <xenon-> Objective C is a superset of C. every valid C program is a valid Objective C program
12:35:03 <zachk> c++ is a superset of C as well 
12:35:06 <MarcelineVQ> it doesn't help that super in common use means stronger/better but in stricter use just means above
12:36:46 <Welkin> is there an existing quasiquoter for multiline strings?
12:37:14 <Welkin> instead of having to do
12:37:17 <Welkin> "hello \"
12:37:29 <Welkin> "\world"
12:37:32 <nshepperd1> Superset of features vs superset of elements
12:38:23 <Solonarv> Welkin: yes, I don't recall its name though
12:38:55 <zachk> concat/join after you intecalate newlines into a list of strings 
12:39:31 <Welkin> I'm writing this in my code as a literal
12:39:37 <Welkin> imagine a database query
12:39:46 <MarcelineVQ> it's called raw-strings-qq
12:39:49 <Welkin> actually it would be nice to have interpolation too
12:40:10 <Welkin> is there a package for that?
12:40:19 <MarcelineVQ> yep, raw-strings-qq
12:40:20 <Welkin> there should be based on what I know about quasiquotes in lisp
12:40:28 <Solonarv> @hackage interpolate
12:40:28 <lambdabot> http://hackage.haskell.org/package/interpolate
12:40:54 <MarcelineVQ> Oh for your stronger question? dunno, sorry blanked there
12:41:01 <Solonarv> doesn't say anything about multiline, but that should "just work" I think
12:41:29 <Solonarv> @hackage neat-interpolation
12:41:29 <lambdabot> http://hackage.haskell.org/package/neat-interpolation
12:41:51 <Solonarv> ^ if you want Text
12:42:02 <Welkin> thanks
12:42:23 <Welkin> I'm going to need this to write a database driver
12:49:29 * hackage SecureHash-SHA3 0.1.1.0 - simple static linked SHA3 using private symbols and the ref impl  https://hackage.haskell.org/package/SecureHash-SHA3-0.1.1.0 (CarterSchonwald)
12:54:26 <trcc> I am working on my first hackage package, but before I do an upload, I would like to try it locally. Is there any way to package it locally and try to use it via cabal?
12:54:48 <Solonarv> just build it normally?
12:55:01 <Solonarv> that's what happens when you use a package from hackage, too
12:55:29 <trcc> Solonarv: yes, but how do I import it from some project then?
12:56:27 <Solonarv> trcc: cabal has support for local dependencies; check https://cabal.readthedocs.io to see how
12:56:33 <trcc> thank you
12:57:15 <dmwit> trcc: I would `cabal sdist` to make the thing you're going to upload, then unpack the generated tarball somewhere else and do the usual cabal dance in that new directory.
12:58:57 <trcc> thanks!
12:59:23 <__monty__> Hmm, yeah it's totally the superset of features vs superset of objects (all monads are applicatives but not vice versa) distinction that trips me up.
12:59:49 <hyperisco> it is the same reason people are confused about ⇒ vs ⇐
13:01:02 <hyperisco> in that there are two ways to explain things
13:01:48 <dmwit> (.) :: (c ⇐ a) ⇐ (b ⇐ a) ⇐ (c ⇐ b)
13:02:04 <hyperisco> you either see it as "Applicative plus these definitions gives you Monad", hence ⇒, or you read it as "Monad gives you these definitions and Applicative"
13:02:07 <hyperisco> hence ⇐
13:04:44 <__monty__> So, OOP inheritance *is* backwards right, where superclasses necessarily have *less* features?
13:05:19 <hyperisco> how is that backwards?
13:05:43 <hyperisco> it seems counterintuitive to extend something and reduce what it can do
13:06:46 <__monty__> Well, Monad is a *super*class of Applicative, right? Yet it can do more, not less.
13:07:03 <hyperisco> no it isn't
13:07:15 <doyougnu> no applicative is a superclass of monad
13:07:36 <__monty__> Wow, turned it around no less than 3 times now.
13:07:38 <doyougnu> or monad `entails` applicative
13:12:25 <geekosaur> "Applicative is a prerequisite for Monad"
13:13:11 <hyperisco> which could still be written ⇐ if so chosen
13:13:38 <__monty__> This feels like the most patient help #haskell has ever given : ) Even though it's just repeating the same thing basically.
13:14:52 <Amras> in the case of oop, you can use a subclass where a superclass is needed, but not vice versa
13:15:21 <Amras> you can use a monad where an applicative is needed but not vice versa
13:16:12 <Amras> a monad *has* everything that an applicative has, plus some extra
13:16:50 <hyperisco> if we had a powerful enough language we wouldn't need to stipulate Applicative is a superclass of Monad
13:17:03 <hyperisco> just sayin'
13:17:41 <Amras> hm?
13:18:23 <hyperisco> because that relationship is just a theorem
13:20:48 <fen> maybe build cant use the scott encoding
13:21:18 <fen> but maybe its fine because it just folds over it, and never does a tail call
13:21:40 <fen> scott is better than church as an encoding apparently because it has constant time get
13:22:36 <fen> but, build does not use this property, and cant use (forall b. a -> Scott a -> b), it has to be (forall b. a -> b -> b), which is Church
13:24:13 <fen> maybe thats wrong... can build use the scott encoding?
13:25:48 <fen> build xs = xs (:) []
13:26:04 <fen> :t (:)
13:26:06 <lambdabot> a -> [a] -> [a]
13:26:13 <fen> so it has to be Church?
13:26:40 <fen> [a] /= Scott a of the middle type of the signature of cons
13:27:58 <fen> seems confusing that Scott encoding is sold as the better encoding, but that the Church encoding seems to work better here
13:28:11 <fen> am i missing something?
13:28:30 <_deepfire> phadej: filed a PR against hackage.head -- I'm trying to get it working with fresh haskell-updates branch (that's got ghcHEAD == ghc-8.8 now)
13:30:34 <_deepfire> phadej: (all in context of Nixpkgs, of course..)
13:33:05 <fen> \query lambdabot
13:33:14 <fen> ...
13:33:46 <fen> :t \f s ->let churchUnfold f q c n = go q where go q = maybe n (\(x,q') -> x `c` go q') (f q) in churchUnfold f s (:) [] uncons
13:33:48 <lambdabot> error:
13:33:48 <lambdabot>     • Couldn't match expected type ‘([a0] -> Maybe (a0, [a0])) -> t1’
13:33:48 <lambdabot>                   with actual type ‘[a]’
13:33:58 <sedeki> how can I show the definition of a type class in GHCi?
13:34:05 <sedeki> e.g. Maybe
13:34:46 <fen> :t s ->let churchUnfold f q c n = go q where go q = maybe n (\(x,q') -> x `c` go q') (f q) in churchUnfold uncons s (:) [] 
13:34:47 <lambdabot> error: parse error on input ‘->’
13:34:50 <fen> :t \s ->let churchUnfold f q c n = go q where go q = maybe n (\(x,q') -> x `c` go q') (f q) in churchUnfold uncons s (:) [] 
13:34:52 <lambdabot> [a] -> [a]
13:34:53 <Solonarv> sedeki: Maybe isn't a type class
13:34:56 <fen> sorry...
13:34:56 <sedeki> eh
13:35:00 <sedeki> I mean the instance
13:35:23 <Solonarv> that isn't possible in GHCi
13:35:36 <Solonarv> you can see the instance head, but not the full definition
13:35:42 <sedeki> ok
13:35:51 <geekosaur> you can'y in general, unless you have loaded its source
13:39:53 <fen> % churchUnfold f q c n = go q where go q = maybe n (\(x,q') -> x `c` go q') (f q)
13:39:54 <yahb> fen: 
13:40:04 <fen> % :t \s -> build (churchUnfold uncons s)
13:40:05 <yahb> fen: [a] -> [a]
13:40:26 <fen> % :t churchUnfold
13:40:27 <yahb> fen: (t1 -> Maybe (t2, t1)) -> t1 -> (t2 -> t3 -> t3) -> t3 -> t3
13:41:03 <fen> (t2 -> t3 -> t3) -> t3 -> t3 -- thats church encoding, right? is there a way to write this with scott encoding?
13:41:11 <fen> or any reason not to?
13:42:04 <o1lo01ol1o> Is is there a pre-rolled catamorphism package for catamorphisms (and monadic catamorphims) on vanilla lists?
13:42:13 <johnw> recursion-schemes?
13:42:41 <lyxia> base has foldr...
13:42:55 <johnw> hahaha
13:42:58 <johnw> lyxia==
13:43:01 <johnw> lyxia++
13:43:39 <suzu> loll
13:43:44 <fen> :t foldr
13:43:45 <o1lo01ol1o> lol, yeah, but I can't get this scanM-to-any-monoid to work
13:43:46 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
13:44:01 <johnw> show us what you have so far?
13:44:18 <o1lo01ol1o> wait, which might actually just be foldlM for some monoid
13:44:44 <johnw> or just...
13:44:45 <johnw> :t foldM
13:44:46 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
13:44:54 <fen> wait what? thought it was not ok to mix aritys!?
13:45:28 <fen> all the examples treat lists and nats independently 
13:46:00 <fen> is that to change with QuantifiedConstraints ?
13:46:21 <fen> like, we can have forall a. Monoid (f a) => now
13:46:34 <Solonarv> fen: what are you confused about?
13:47:29 <fen> well like it would be fine to have Nat = [()] and just use get/set for pred/succ
13:47:42 <fen> but it mixes up the arities 
13:48:13 <fen> Nat is a Monoid. [()] is also a monoid, because forall a. [a] is a Monoid
13:48:15 <Solonarv> that has been fine since Haskell 98
13:48:40 <fen> couldnt write free Eq instances though
13:48:43 <fen> Free*
13:48:52 <fen> anyway, nvm
13:49:08 <xenon-> anyone else thinks it was a mistake to implemented IsList instance for NonEmpty?
13:50:07 <fen> but really its because [] is a MonadPluss
13:50:13 <fen> and thats the arity thing again
13:50:16 <Solonarv> there are unfortunately a lot of IsList instances like that
13:51:08 <fen> Solonarv: also confused about Scott encoded build
13:51:40 <pikajude> not really, i like IsList for NonEmpty
13:52:18 <xenon-> [] :: NonEmpty Int 
13:52:43 <fen> whats the point in that?
13:52:48 <fen> its wrong
13:53:09 <fen> Free Nonempty should not have empty leaves
13:53:21 <fen> otherwise you would just use Free []
13:53:30 <fen> and have all empty branches and stuff.
13:53:41 <fen> the whole point of nonempty is it strictly should not have empty!
13:53:54 <pikajude> sure
13:54:04 <pikajude> but i'm not likely to type [] :: NonEmpty Int
13:54:17 <pikajude> IsList is generally used for values that are known at compile-time
13:54:19 <fen> :t [] :: NonEmpty Int
13:54:20 <lambdabot> error:
13:54:20 <lambdabot>     • Expected a type, but ‘'NonEmpty Int’ has kind ‘NonEmptyList a0’
13:54:21 <lambdabot>     • In an expression type signature: NonEmpty Int
13:55:00 <Solonarv> uhhh... clearly this isn't the right NonEmpty
13:55:08 <pikajude> that looks like the wrong nonempty
13:55:24 <xenon-> fen, that's what I'm saying, OverloadedLists shouldn't work with NonEmpty (unless IsList interfaced can be fixed, so that types like NonEmpty can report compile-time errors)
13:56:02 <Solonarv> % [] :: NonEmpty Int
13:56:02 <yahb> Solonarv: *** Exception: NonEmpty.fromList: empty list
13:56:20 <pikajude> % let x :: NonEmpty Int = undefined
13:56:20 <yahb> pikajude: 
13:56:23 <fen> for list we have ([a] -> Maybe (a,[a])) that is, we cant write ([a] -> (a,Maybe [a])) safely, because there is not alway a value
13:56:25 <pikajude> fair enough yahb
13:56:31 <Solonarv> better support for compile-term errors related to overloaded literals would be nice, yes
13:56:33 <pikajude> is that a parse error?
13:56:35 <fen> for nonempty we have the second type for get
13:56:48 <Solonarv> (yahb is a bot btw)
13:57:03 <pikajude> right
13:57:32 <fen> interestingly, we can have (f a -> (Maybe a,Maybe f a))
13:57:36 <Solonarv> this problem isn't exclusive to IsList or NonEmpty, though
13:57:55 <pikajude> yeah, Data.List.NonEmpty also has a fromList function
13:57:57 <Solonarv> it also applies to numeric literals, for example
13:57:57 <fen> which corresponds to skip, something which can have empties all through the container
13:57:59 <pikajude> which suffers the same issue
13:58:14 <Solonarv> oh I mean partial *functions* are one thing
13:58:39 <Solonarv> literals which are a hidden error are a different annoyance
13:58:48 <pikajude> oh
13:59:06 <pikajude> that's true, although supercompilation in ghc is quite a difficult problem afair
13:59:19 <fen> and the next extension is to (f a -> (Either a j,Maybe f a)), where j is the index correpsonding to various different empty spaces...
13:59:46 <suzu> ｓｕｐｅｒｃｏｍｐｉｌａｔｉｏｎ
13:59:49 <suzu> that sounds so tremendous
13:59:55 <pikajude> it's like compilation, but more super-er
14:00:11 <suzu> should i feel guilty when i don't newtype wrap things
14:00:26 <suzu> i've got some Text -> Text -> Text -> Maybe User kinda shenanigans going on
14:00:47 <suzu> i should.. do something about that eventually
14:01:10 <__monty__> suzu: A simple "solution" is type synonyms. Then at least you can signal intent.
14:01:22 <suzu> that doesn't solve very much of anything
14:01:32 <fen> generally we have (Mono r => f a -> (r a,f a))
14:01:35 <suzu> it's all the same to the compiler. doesn't prevent bugs
14:01:51 <suzu> it does let me read my own code and spot the problem faster, i suppose
14:02:14 <Solonarv> supercompilation: main = print (fibonacci (10^21)) takes forever to compile but runs near instantly ;)
14:02:44 <fen> what about where iterate (+0) 0 completes instantly
14:02:53 <fen> > iterate (+0) 0
14:02:55 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
14:03:02 <__monty__> suzu: Hence words like simple, i.e. it doesn't really change anything and "solution" as in it doesn't actually solve the problem.
14:03:13 <suzu> hehe
14:03:14 <fen> > last $ iterate (+0) 0
14:03:20 <lambdabot>  mueval-core: Time limit exceeded
14:03:36 <Solonarv> ah yes, that's an actually useful example ;)
14:04:37 <Amras> does supercompilation on infinite sequences/loops fail, freeze up, or give up and fall back to non-super?
14:04:49 <fen> > foldMap (repeat mempty) :: Int
14:04:51 <lambdabot>  error:
14:04:52 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘[a1] -> m0’
14:04:52 <lambdabot>      • Probable cause: ‘foldMap’ is applied to too few arguments
14:04:58 <xenon-> > foldMap
14:04:58 <Solonarv> depends on the sequence - consider the collatz conjecture
14:05:00 <lambdabot>  error:
14:05:00 <lambdabot>      • No instance for (Typeable a0)
14:05:00 <lambdabot>          arising from a use of ‘show_M76300600538753274809274’
14:05:04 <xenon-> :t foldMap
14:05:05 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
14:05:19 <fen> > concat (repeat mempty) :: [Int]
14:05:22 <xenon-> > foldMap show [1..5]
14:05:25 <lambdabot>  mueval-core: Time limit exceeded
14:05:26 <lambdabot>  "12345"
14:05:43 * Clint squints.
14:06:49 <fen> > foldr (.) id (repeat id) 0
14:06:55 <lambdabot>  mueval-core: Time limit exceeded
14:07:49 <fen> it cant eve do id . id = id
14:08:03 <fen> hardly super
14:10:29 <fen> to be fair, all the most difficult problems are like this. e.g. a sin wave of some frequency has a pretty low complexity representation, but converging quickly on this with a learning algorithm starting from a discrete representation is pretty tough
14:11:29 <fen> you could *tell* it to do a fourier transform, but if it has to learn that...
14:17:06 <xenon-> > head $ 1 :| [2,3]
14:17:08 <lambdabot>  error:
14:17:08 <lambdabot>      • Data constructor not in scope: (:|) :: Integer -> [Integer] -> t
14:17:08 <lambdabot>      • Perhaps you meant one of these:
14:18:13 <zachk> > head $ 1 : [2,3] 
14:18:15 <lambdabot>  1
14:18:32 <Solonarv> % head $ 1 :| [2,3]
14:18:32 <yahb> Solonarv: ; <interactive>:92:1: error:; Ambiguous occurrence `head'; It could refer to either `Data.List.NonEmpty.head', imported from `Data.List.NonEmpty'; or `Prelude.head', imported from `Prelude' (and originally defined in `GHC.List')
14:18:58 <xenon-> % length $ 1 :| [2,3]
14:18:59 <yahb> xenon-: ; <interactive>:93:1: error:; Ambiguous occurrence `length'; It could refer to either `Data.List.NonEmpty.length', imported from `Data.List.NonEmpty'; or `Prelude.length', imported from `Prelude' (and originally defined in `Data.Foldable')
14:19:09 <xenon-> :-O
14:19:37 <Solonarv> grrr
14:20:01 <Solonarv> container modules defining monomorphic variants of typeclass operations is a pet peeve of mine
14:20:19 <fen> the problem is, the paper saying the Scott encoding should be used seems to justify that in a way that does not seem relevant to the use case above
14:20:29 <fen> which seems to discourage learning it
14:20:29 <Solonarv> % Data.Foldable.length $ 1 :| [2, 3]
14:20:30 <yahb> Solonarv: 3
14:20:58 <berndl> How do you guys which modules go under Data and which go under Control?
14:21:26 <berndl> It seems to me that data types go in modules under Data and type classes go in modules under Control.
14:21:28 <fen> but to be sure this was correct, that it is not the correct thing to use, and so not to bother learning it, you would have to learn about it well enough to trust that 
14:21:42 <xenon-> Foldable is typeclass
14:22:01 <Solonarv> berndl: the distinction is pretty arbitrary tbh
14:22:12 <berndl> Solonarv: oh no...
14:23:21 <fen> it would be nice to have design choices that are well justified, but if that means learning everything that is not the correct thing to use, it could take too long!
14:24:19 <geekosaur> it's Haskell; we often encode control as data, so it's a fairly meaningless distinction
14:24:25 <fen> normally when there are options, an abstraction is available, so is there something that captures both these types of encoding? or is that not sane...
14:25:01 <geekosaur> (consider that laziness lets you write as a function what normally would have to be a language construct)
14:26:46 <fen> its a nice class Mono r => Get_r r f where get_r :: f a -> (r a,f a) 
14:26:56 <fen> but then this Mono encoding is troublesome 
14:27:06 <fen> r a = (i,a) works
14:27:18 <Solonarv> @quote simple.linked.lists
14:27:18 <lambdabot> Solonarv says: simple linked lists are not a particularly great *data* structure, but in combination with laziness they make a pretty good *control* structure
14:27:35 <fen> then you get class Get_i i f where get_r :: f a -> ((i,a),f a)
14:28:02 <fen> but then there is this problem with the `i' that it is costly to convert to and from
14:28:14 <geekosaur> yep. also we have Control.Monad which seems hard to argue as "control" until you consider that the free monad encodes them as data
14:29:23 <fen> whereas if Mono r => r a = f a = (a,forall b. f b), then the container serving instead of `i' can be folded over with zero cost because of fusion
14:29:47 <berndl> I'm looking at the purescript prelude and they have Control.Monad and Data.Functor, which makes no sense to me.
14:30:28 <geekosaur> so do we
14:30:42 <fen> eg if there is a Skip container like [1,_,_,_,2_,_ ... ] then get_r should return ((1,3),[2,_, ...])
14:30:43 <geekosaur> and no, it doesn't make any sense, that's kinda the point. but we inherited much of this
14:31:06 <fen> but growing that 3 from dismantling the skip is slower than leaving a segment of the Skip
14:31:08 <geekosaur> the realization that it doesn't really make sense in a Haskell-related context came later
14:32:01 <fen> like; [1,_,_,_,2_,_ ... ] -> ((1,[undefined,_,_,_]),[2,_, ...])
14:33:23 <fen> like how Int === [()] it might not seem faster to do :() than +1, but when fusion is used, and the list already exists...
14:34:21 <fen> so then anything the `i' of get_i might be used for, such as for set_i, this now can fold over the container, instead of wrangling with Int
14:35:30 <fen> here the containers are strait lines, without right angles, but when shaped containers are used, its like forall a. f a === [j]
14:36:01 <fen> where the `j' are the extra information the shape gives to the values during a fold
14:36:13 <fen> so then there is the option of using a Church encoding of this fold
14:36:30 * hackage aeson-gadt-th 0.1.2.0 - Derivation of Aeson instances for GADTs  https://hackage.haskell.org/package/aeson-gadt-th-0.1.2.0 (abrar)
14:36:34 <fen> and that gives the fusion savings
14:38:44 <fen> basically its a default get_i instance where i = (j -> b -> b) -> b -> b
14:39:09 <fen> and the "substructure" or "shape" index j appears
14:39:36 <berndl> The Idris prelude is a lot saner.
14:40:29 * hackage constraints-extras 0.2.3.1 - Utility package for constraints  https://hackage.haskell.org/package/constraints-extras-0.2.3.1 (abrar)
14:40:42 <fen> `i' is like, how many skips after the head value until the next value, so when get is called, and the head value is retrived along with the reconstruction index, this could be an Int, but its faster if its a church encoded folding over substructure indexes
14:41:14 <fen> so instead of Int, we have the faster version (() -> b -> b) -> b -> b
14:41:26 <fen> (funky looking Int!)
14:41:57 <fen> for things that would loop incamenting a carry Int like a C++ for loop
14:42:58 <fen> if haskell has zero cost loop indexing ++ thats got to be a pretty powerful feature
14:43:52 <fen> (when the index being incremented is for a container traversal)
14:44:15 <fen> normally this is hidden in like map
14:44:17 <fen> right?
14:44:25 <fen> the recursive call...
14:44:55 <fen> but by implementing using traverse we can increment a carried thing 
14:44:59 <fen> :t mapAccumR
14:45:00 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
14:45:04 <xenon-> what is the point of () in (() -> b -> b) -> b -> b?
14:45:18 <fen> its the "shape" of the linear container
14:45:40 <fen> like there is no extra "shape" information from traversing a list
14:45:48 <fen> we just get another () at each place
14:46:01 <fen> which you cons onto the carried [()]
14:46:04 <fen> which is the Int
14:46:32 <fen> but by using the Church encoding, these shape args are made available to a folding function
14:46:58 <fen> which for Lists, and the incramented int, is just providing () to the folding function... 
14:47:32 <fen> might not seem so useful, but it could be doing a const (+1) :: () -> Int -> Int just to prove its equivalence
14:47:44 <comstar> mapAccumR is foldlr & fmap right
14:48:10 <xenon-> :t mapAccumR
14:48:12 <fen> it accumulates a carried argument
14:48:12 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
14:48:30 <comstar> :t fmap
14:48:31 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:48:41 <comstar> :t foldr
14:48:42 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
14:49:03 <comstar> :t *>
14:49:04 <lambdabot> error: parse error on input ‘*>’
14:49:09 <comstar> oh right
14:49:30 <xenon-> > mapAccumR (\acc x -> (acc+x, "w00t")) 0 [1..10]
14:49:32 <lambdabot>  (55,["w00t","w00t","w00t","w00t","w00t","w00t","w00t","w00t","w00t","w00t"])
14:50:08 <xenon-> I don't see where fmap comes into play
14:50:10 <fen> ok heres a good example, the j can be used to give j -> f a -> f a
14:50:36 <fen> then, a carried f a can be given the shape directions allowing it to be navigated to the next position
14:50:46 <fen> that way comonad results
14:51:01 <fen> by replacing the value with this navigated (Pointer) container
14:51:17 <xenon-> > foldl (\x (a, b) -> (a+x, "w00t":b)) (0, []) [1..10]
14:51:18 <fen> and further, this Pointer style navigation is implicit in all the normal recursions
14:51:19 <lambdabot>  error:
14:51:19 <lambdabot>      • Occurs check: cannot construct the infinite type:
14:51:19 <lambdabot>          a ~ (a, [[Char]])
14:51:23 <Solonarv> comstar: it's 'traverse' specialized to the State monad
14:51:31 <xenon-> > foldl (\(a, b) x -> (a+x, "w00t":b)) (0, []) [1..10]
14:51:33 <lambdabot>  (55,["w00t","w00t","w00t","w00t","w00t","w00t","w00t","w00t","w00t","w00t"])
14:52:10 <fen> to see an example of that phenomena, consider the implementation of insert
14:52:19 <fen> using fold
14:52:27 <fen> or direct recursion
14:53:15 <fen> if you use a zipper (a linear pointer) then you just navigate the zipper to the insert position and attach the thing you want to insert to the head of the tail at that postion
14:53:41 <fen> so then it can be seen how a pointer was implicitly at the heart of the recursive implementation
14:54:43 <fen> so that, just having normal cons or ++, coresponding insert things are available for the linear containers such as list, because there is a pointer over them
14:55:09 <fen> and the extra argument to insert, over (:) for example, corresponds to the navigational argument to the pointer
14:55:25 <fen> you move the zipper forwards n times before consing onto the tail
14:55:29 <xenon-> mapAccumR and foldMap are cool functions that I have never used before. any other folding function I should learn?
14:56:03 <fen> and this has a version for "shaped" containers such as Nd cartesian grids etc
14:56:33 <comstar> xenon-: "The mapAccumR function behaves like a combination of fmap and foldr; it applies a function to each element of a structure, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new structure."
14:57:00 <fen> the theorem with this Church representation of the overall navigational index is that its a church encoded list of the next neighbouring navigational index
14:57:06 <comstar> it's like fmap for binary operations instead of unary
14:57:12 <fen> hence i in terms of j
14:57:17 <comstar> w/ a fold
14:58:33 <fen> i = [j] because there is a hamiltonian path for traversable containers. so there is a simple list like sequence of local navigations
14:58:51 <comstar> Solonarv: thank you, btw
14:59:46 <begriffs> Is the Haskell 2010 Language Report available in printed form?
15:00:06 <fen> thats why you have a carried Int over normal recursive things, because its [()] because there is just a () to get navigate a linear zipper, but this extends to Pointers of more complex "shaped" containers, where the local navigations forming an overall navigation are i = [j] for j/=()
15:00:51 <fen> this can be used then for branching recursion, and even cycles
15:00:57 <MarcelineVQ> fen: who are you talking to?
15:01:13 <fen> just finished. big project, great result
15:01:19 <fen> you?
15:01:22 <MarcelineVQ> you
15:01:47 <fen> i know who your talking to! 
15:01:53 <comstar> yeah I was kind-of wondering that too lol
15:02:03 <comstar> I thought I just missed part of the conversation
15:02:10 <__monty__> Fen's the train of thought/life-blogging type.
15:02:17 <comstar> ah
15:02:21 <fen> what?
15:02:28 <fen> i need you guys help!
15:03:50 <__monty__> Questions might be a better way to get that than an essay though. I, like most I'd wager, gave up trying to keep up.
15:04:09 <fen> yeah cos it got real
15:05:48 <fen> its ok to read twice what took more than a few attempts to derive
15:05:53 <Solonarv> fen's the "pipe stream of consciousness into IRC" type ;)
15:06:07 <fen> no seriously though
15:07:23 <xenon-> comstar, I guess they mean that fst is result of fold, and snd of fmap
15:07:39 <iqubic> So I finally managed to learn about EBNF and left recursion and how to factor out said left recursion.
15:07:49 <__monty__> fen: Once not one, not two, but three people say the same thing you have to consider whether there's something to their claims : >
15:08:00 <comstar> you could really do well for yourself blogging about it since it'd give you stuff to put on a résumé
15:08:05 <comstar> fen: ^
15:08:09 <fen> yeah i should write a book pay me!
15:08:36 <comstar> ... LOL
15:08:42 <iqubic> And I managed to get a parser that parses left associative binary operators with precedendce.
15:09:02 <xenon-> any other useful folding functions I may be missing, besides foldr/l  foldMap and mapAccumR
15:09:38 <MarcelineVQ> xenon-: most everything in the Foldable class is useful
15:10:01 <comstar> https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List.html xenon- 
15:10:36 <comstar> I know you weren't really asking for a link to the manual, I'm not trying to be snarky about that
15:10:44 <xenon-> I think I know everything there besides mapAccum*
15:10:50 <xenon-> no, that's fine
15:11:09 <MarcelineVQ> unfoldr is pretty neat if you've not seen
15:11:28 <xenon-> seen it :)
15:11:38 <comstar> I like that foldable requires foldMap
15:11:50 <xenon-> foldr is enough
15:11:53 <MarcelineVQ> sounds like you're good to start using these things :>
15:11:56 <xenon-> to implement Foldable
15:12:16 <comstar> yeah it's one or the other
15:12:23 <Solonarv> (or both)
15:12:27 <comstar> or both!
15:12:37 <xenon-> asum, for_, traverse. these are new
15:13:02 <xenon-> foldlM
15:13:42 <MarcelineVQ> asum is, iirc, foldr <|> empty so if you want to know more about it you need to look at instances of Alternative which provides <|> and empty
15:14:30 <comstar> can ghc thread pure functions yet (just wondering)
15:14:41 <comstar> last time I did it I had to do some library stuff
15:15:07 <comstar> diving into https://wiki.haskell.org/Concurrency now
15:15:45 <Solonarv> it doesn't happen automatically, but you can cause pure computation to happen in parallel
15:15:49 <Solonarv> @hackage parallel
15:15:49 <lambdabot> http://hackage.haskell.org/package/parallel
15:15:51 <MarcelineVQ> you can get parallel operations without IO if that's what you mean but concurrency is a tougher nut to crack
15:16:26 <MarcelineVQ> condy: https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/ is the de facto source to learn these things, it's free on that page just gotta scroll down
15:16:35 <MarcelineVQ> *comstar
15:16:53 <comstar> thanks!
15:17:22 <iqubic> creating a parser for a left recursive grammar was a very interesting and eye opening task.
15:17:35 <MarcelineVQ> iqubic: very cool
15:18:41 <iqubic> Yeah. Ski helped me with that last night.
15:19:20 <iqubic> I managed to make a parser that can parse things like: "1 + 2 * 3 - 4 / 5" properly.
15:20:30 * hackage haskdogs 0.6.0 - Generate tags file for Haskell project and its nearest deps  https://hackage.haskell.org/package/haskdogs-0.6.0 (SergeyMironov)
15:20:31 <iqubic> As in, it has the correct assiativity and precedence.
15:20:46 <MarcelineVQ> What do you want to do next now that you can do this?
15:21:19 <iqubic> I'm going to make a program that can find derivatives.
15:42:16 <suzu> is there an idiom for string interp in hs
15:43:55 <MarcelineVQ> I'm a little dumb so it might just be me but that question seems like it's missing words/letters, are you looking for multi-line string literals?
15:44:25 <koz_> MarcelineVQ: I think suzu refers to string interpolation, a la Perl.
15:44:38 <suzu> yeah
15:44:40 <koz_> So you can write something like "I am a ${adjective} ${food}".
15:44:45 <suzu> but with type safety
15:44:54 <koz_> And if adjective = idiot and food = sandwich, it would produce... yeah.
15:45:12 <koz_> suzu: Is something printf-like sufficient for your purposes?
15:45:13 <suzu> so i normally do some nonsense like "(" <> toS . show (thing) <> "), " <> toS . show (another thing) <> ..
15:46:01 <suzu> i'd like to avoid a unchecked printf and just know how to do what i'm currently doing but cleaner
15:46:29 <suzu> i suppose i could concatMap toS over a list
15:46:33 <koz_> suzu: Who said anything about unchecked?
15:46:37 <suzu> :o
15:46:45 <koz_> http://hackage.haskell.org/package/base-4.12.0.0/docs/Text-Printf.html
15:47:12 <suzu> Mismatch between the argument types and the format string will cause an exception to be thrown at runtime. 
15:47:28 <suzu> i'd like a compile-time guarantee
15:47:32 <MarcelineVQ> There's likely a type-safe printf by now, https://hackage.haskell.org/packages/search?terms=printf
15:47:47 <koz_> suzu: Have you seen the one implemented in Thinking with Types?
15:48:00 <koz_> I think even the preview copy has that chapter.
15:48:06 <suzu> no, haven't seen it
15:48:10 <koz_> suzu: One sec then.
15:48:13 <MarcelineVQ> https://hackage.haskell.org/package/formatting-6.3.7/docs/Formatting.html being the most recent
15:48:34 <MarcelineVQ> though at a glance not quite as clean
15:48:58 <koz_> http://reasonablypolymorphic.com/blog/book-of-types/
15:49:00 <Welkin> > toJSON True
15:49:01 <koz_> suzu: ^
15:49:02 <MarcelineVQ> https://hackage.haskell.org/package/th-printf-0.6.0/docs/Language-Haskell-Printf.html is closer
15:49:03 <lambdabot>  error:
15:49:03 <lambdabot>      Variable not in scope: toJSON :: Bool -> t
15:49:15 <Welkin> > Data.Aeson.toJSON True
15:49:17 <lambdabot>  error:
15:49:17 <lambdabot>      Not in scope: ‘Data.Aeson.toJSON’
15:49:17 <lambdabot>      No module named ‘Data.Aeson’ is imported.
15:49:18 <koz_> It's in that PDF, but I forget which exact chapter.
15:49:20 <suzu> koz_: i own a copy, lol
15:49:27 <koz_> suzu: Oh, even better!
15:49:32 <suzu> i just haven't read it
15:49:33 <suzu> <_<
15:49:34 <koz_> (me too)
15:49:35 <koz_> (and I have)
15:49:40 <koz_> Let me get you a chapter reference then.
15:52:17 <koz_> suzu: Chapter 9.
15:52:29 <koz_> Sorry that took a while - it's not indicated in the contents.
15:52:31 <suzu> kk
15:52:41 <MarcelineVQ> help
15:52:47 <MarcelineVQ> I accidently ended up in spj's papers list again and I don't know how to get out
15:53:09 <koala_man> hahalol
15:53:17 <suzu> whats the most recent edition koala_man ?
15:53:20 <suzu> err koz_ *
15:54:40 <koz_> suzu: No clue. I bought on release day.
15:54:43 <koz_> So going by that copy.
15:56:31 <suzu> hmm
15:56:36 <suzu> will leanpub let me dl the latest ver
15:57:36 <koz_> Wait, there's a more recent one?
15:57:49 <suzu> there must be
15:57:56 <suzu> i know the author and i think he published some updates
15:57:58 <suzu> lol
15:58:36 <koz_> suzu: Hopefully some of my feedback got incorporated.
16:03:13 <suzu> ah yeah this is the latest edition
16:03:15 <suzu> ok
16:19:47 <suzu> formatting seems to be the best for my use
16:22:42 <koz_> suzu: Yeah, it is very good.
16:22:46 * koz_ reminds himself to use it.
16:30:25 <Solonarv> @hackage neat-interpolation - suzu
16:30:25 <lambdabot> http://hackage.haskell.org/package/neat-interpolation - suzu
17:28:00 * hackage num-non-negative 0.1 - Non-negative numbers  https://hackage.haskell.org/package/num-non-negative-0.1 (int_index)
19:17:10 <ar1a> why is the common style for lists having the comma at the start of the line instead of the end?
19:18:29 <MarcelineVQ> some people like to line them up with the [ ]
19:18:43 <Solonarv> also, leads to cleaner diffs when adding/removing lines at the end
19:19:22 <Solonarv> because adding/removing a line at the end is just adding/removing ', whatever' and doesn't touch the previous line
19:36:48 <DigitalKiwi> and that's the way hindent puts 'em innit
19:49:00 * hackage persistent-spatial 0.1.0.0 - Database agnostic, spatially indexed type for geographic points.  https://hackage.haskell.org/package/persistent-spatial-0.1.0.0 (gtsteel)
19:59:52 <suzu> can i get trailing commas in hask tho plz
19:59:59 <Welkin> yes
20:00:04 <Welkin> you can put the comma anywhere you please
20:00:11 <suzu> i mean having an extra one
20:00:19 <Welkin> oh, like in javascript?
20:00:19 <Welkin> no
20:00:22 <suzu> [a,b,c,]
20:00:34 <Welkin> in C the common way to do that is to use NULL at the end
20:00:47 <suzu> TIL
20:00:49 <Welkin> there is no such trick in haskell
20:01:32 <Welkin> if you put the comma at the beginning it makes that irrelevant
20:01:40 <Welkin> there is no need for a trailing comma
20:02:16 <Welkin> the standard way to format a list is
20:02:20 <Welkin> [ one
20:02:22 <Welkin> , two
20:02:23 <Welkin> ]
20:03:17 <maerwald> trailing commas are awesome
20:03:24 <maerwald> not sure if there is a bug report for it
20:03:37 <Welkin> why would it be a bug?
20:03:50 <maerwald> bug reports include feature requests
20:04:13 <Welkin> a trailing comma would not work for tuples
20:04:19 <Welkin> because of tuple sections
20:04:31 <Welkin> so there would be special cases
20:04:37 <maerwald> this was mainly for import lists and lists
20:04:39 <Welkin> I think it's better to not use it
20:04:55 <Welkin> I format everything with the comma at the beginning
20:04:56 <maerwald> tuples are not lists, and tuplesection is a GHC extension
20:05:36 <Welkin> if you add everything but the kitchen sink, you get c++
20:05:47 <leifmetcalf> why do you like trailing commas? I don't really have experience with languages other than lisp/haskell
20:06:00 <maerwald> Welkin: haskell is already going that route
20:06:19 <maerwald> no need to fight it
20:07:20 <maerwald> suzu: https://github.com/ghc-proposals/ghc-proposals/pull/87/files
20:08:09 <Welkin> leifmetcalf: it's for lazy people who don't want to rememebr to remove or include a comma when they add an element to the end of a vertically formatted list/object
20:08:38 <Welkin> I also hear the totally stupid excuse of "it results in fewer lines of diff in git"
20:08:57 <Welkin> typical programmer logic of making a big deal out of nothing
20:09:02 <geekosaur> the problem with trailing commas in haskell is it implies the list is actually a section
20:09:26 <leifmetcalf> you can have list sections?
20:09:29 <geekosaur> [1,2,3,] -- is this a trailing comma, or waiting to be applied to the final element?
20:09:31 <Welkin> the feature was recently included in javascript
20:09:41 <Welkin> geekosaur: my point exactly
20:09:52 <geekosaur> not presently, but there is other syntax that works that way (see TupleSections)
20:10:03 <maerwald> err
20:10:11 <maerwald> yes, so it's a non issue
20:10:13 <Welkin> however, and this is funny, javascript does not allow commas at the beginning
20:10:36 <geekosaur> so it's ambiguous to a reader, given TupleSections which makes it look like this could also be a section
20:10:46 <maerwald> TupleSections are not part of the standard
20:10:49 <maerwald> can be removed
20:11:09 <Welkin> haskell is already difficult enough to read with all the various extensions and operators (depending on who wrote it)
20:11:38 <geekosaur> it's mroe likely it's part of the next standard that it gets removed
20:11:42 <geekosaur> *than it gets
20:11:55 <leifmetcalf> Do extensions ever get removed?
20:11:56 <Welkin> which reminds me, scala takes that to a whole new level. It's like an ML version of perl
20:12:28 <maerwald> geekosaur: why so?
20:13:09 <geekosaur> leifmetcalf, occasionally. they also sometimes get reworked (compare PatternSignatures in 7.8 vs. 7.10)
20:15:21 <geekosaur> also note that TupleSections isn't needed for
20:15:24 <geekosaur> :t (,)
20:15:26 <lambdabot> a -> b -> (a, b)
20:16:20 <julianleviston> I found out the other day that the comma operator is also a thing in JS. Babel transpiles to that because it shifts the scope of execution / evaluation (0, someToken) will be executed within the global scope.
20:16:30 <geekosaur> the point being that this alread has an established meaning
20:17:22 <Welkin> and lisp only uses commas in quasiquotes to unquote something
20:17:34 <Welkin> don't you just love lisp lists? (1 2 3)
20:18:44 <maerwald> geekosaur: (,) is unambigous
20:19:28 <geekosaur> ecuse me, I do understand the "correct" answer here is "my special case that doesn't act like the rest of the language is obviously more important"
20:19:42 <maerwald> tuple sections are not part of the language
20:19:54 <geekosaur> ...
20:20:10 <geekosaur> that is irrelevant
20:20:23 <geekosaur> never mind, haskell is perl, everything has its own idiosyncratic syntax now
20:20:24 <maerwald> a proposal could include or exclude tuples from that or explain how it deals with backwards compatibility
20:20:27 <geekosaur> so you can have your list syntax
20:20:29 <maerwald> there is nothing preventing a proposal
20:20:44 <leifmetcalf> (1,) already works as a data constructor, right?
20:21:11 <maerwald> error: Illegal tuple section: use TupleSections
20:21:12 <Welkin> yes
20:21:27 <maerwald> it's an error ;)
20:21:32 <Welkin> although you can also write it as `(,) 1`
20:21:43 <Welkin> :t (,) 1
20:21:45 <lambdabot> Num a => b -> (a, b)
20:22:00 <Welkin> :t (1,)
20:22:01 <lambdabot> Num t1 => t2 -> (t1, t2)
20:22:02 <maerwald> it has little benefit, while trailing commas can be used in many situations and make formatting easier
20:22:11 <Welkin> > (1,) 2
20:22:13 <lambdabot>  (1,2)
20:22:41 <Welkin> formatting is already as easy as it could possibly be
20:22:46 <Welkin> put the comma at the beginning
20:23:00 <Welkin> most languages don't let you do that, but haskell does, and it is better in my opinion
20:23:03 <maerwald> and we already allow trailing commas in the main export list
20:23:14 <maerwald> so there is no inconsistency
20:23:53 <leifmetcalf> When would trailing commas be better than the current style?
20:24:01 <Welkin> never
20:24:07 <Welkin> trailing commas are a fad
20:24:27 <Welkin> they offer no actual benefit other than letting you be extra lazy
20:24:46 <maerwald> like tuple sections?
20:24:49 <maerwald> ;)
20:24:49 <Welkin> and the only reason languages like javascript have them now is because you cannot use commas at the beginning
20:26:13 <leifmetcalf> That was a serious question, I can't think of a case when trailing commas would be better
20:26:57 <Welkin> neither can I
20:27:10 <leifmetcalf> Maybe if you wanted the syntax to be more different to the syntax for defining records
20:27:46 <DigitalKiwi> Welkin: in lua you can have trailing commas in tables it's useful for machine generated tables is the reason and it actually makes sense there to have it
20:29:54 <leifmetcalf> You mean generated code? Or something else?
20:30:20 <DigitalKiwi> https://www.lua.org/manual/5.3/manual.html#3.4.9
20:30:36 <DigitalKiwi> last sentence
20:31:02 <DigitalKiwi> is common to dump/load tables to disk
21:31:38 <iqubic> ski: Thank you so much for helping me create my parse. Once you told me I wanted a "sum of products" then I was able to quickly modify my binOp code, that we worked out last night to use that same function to handle both multiplatican, addition, and precedence too.
21:50:04 <bryan1> WHat's the canonical way to write an Arbitrary instance for MyFutureTime that only generates times that are greater than `getCurrentTime`.
21:57:26 <bryan1> ahh runGenT looks useful for this
22:06:10 <comstar> is there a way to have haskell programs do the classic C-like return value outside of ffi
22:06:16 <comstar> for main
22:07:13 <comstar> like main :: IO () is a lot like void main()
22:08:09 <MarcelineVQ> comstar: not sure check System.Exit
22:08:09 <cocreature> comstar: https://hackage.haskell.org/package/base-4.12.0.0/docs/System-Exit.html#v:exitWith
22:08:24 <comstar> thx!
22:09:31 <julianleviston> comstar: does C let you return anything other than int from main?
22:09:53 <comstar> lemme go crack open the standard before giving you an incorrect answer
22:10:44 <julianleviston> comstar: hehe :) I’ve only ever returned an exit code (ie an int) or void (which translates to returning a success I think?)
22:11:17 <julianleviston> comstar: I was more just curious (because you were asking for the equiv in Haskell) so I assumed you’d been doing that in C and were looking for an equivalent here.
22:17:10 <comstar> julianleviston: the C11 & C99 standards both explicitly only define int main but allow any implementation defined manner so it'd explain why I've seen void main in the compiler docs for certain microcontrollers
22:17:43 <comstar> 5.2.2.1 for C11
22:20:31 <julianleviston> Thx. I just read some stack overflow on it. Seems a bit… messy. :)
22:21:49 <sedeki> how is it that "bit order" is not a concept (afaik), but "byte order" is?
22:24:08 <comstar> sedeki: you mean like why can't you receive a word with all the bits backwards?
22:24:18 <sedeki> yes
22:25:07 <sedeki> i guess this is a physical question. i don't know how words are represented. but it seems to me as if all platforms have agreed on the representation of a word.
22:26:02 <comstar> it's more that the transmission media can't really get confused with one another
22:26:35 <comstar> like no one is going to have a telex system hooked up to an rs485 where both are transmitting information that passes the sanity checks for those respective protocols
22:26:58 <comstar> mostly because the mediums are disparate
22:32:13 <sedeki> comstar are you saying that all platforms converged upon a interpretation of the word?
22:32:27 <sedeki> to conform to protocols etc (would make sense)
22:32:31 <comstar> sedeki: that is to say, I can't really think of a scenario that'd allow for the gsb of one system to be received and interpreted as the lsb of another, not to say there isn't any, just that all the mediums of communication sort of encapsulate that operation for encoding/decoding
22:32:42 <sedeki> but say why isn't there "bit order" in C
22:32:54 <sedeki> you have the sign bit which changes the interpretation
22:32:57 <sedeki> but nothing else
22:32:58 <Welkin> are you talking about endianness?
22:33:05 <Welkin> that is present
22:33:10 <comstar> Welkin: he's talking about bit-endianness
22:33:14 <Welkin> different architectures have different endianness
22:33:54 <comstar> sedeki: you can definitely interact with bits in C, just that those interactions are themselves dependent on the same bit order
22:33:54 <Welkin> C is not the best language to talk about bits
22:34:02 <Welkin> in fact most language sucks when it comes to bits
22:34:11 <Welkin> the only one that gets it right is erlang, and of course assembly
22:34:32 <comstar> sedeki: like 8>>1 gives you 4.  or 7&3 gives you 3
22:34:35 <sedeki> yes I know 
22:35:00 <sedeki> accessing individual bits is a thing, but the order of the bits is already given
22:35:26 <comstar> also as a follow-up it's not that all protocols converged on a single order, more that you have to be using the protocol to receive bits which means both the client and sender agree to the order of the bits
22:35:33 <Welkin> the bits are always in the same order
22:35:48 <Welkin> networks use "network byte order" aka big endian
22:35:59 <comstar> I'm talking about serial buffers not networks 
22:36:07 <comstar> because that's a situation in which you end up with bit transfers
22:37:06 <sedeki> Welkin that's byte order
22:37:33 <comstar> the implication of sedeki's original question is that he understands endianness Welkin "how is it that 'bit order' is not a concept [...] but 'byte order' is?"
22:37:38 <sedeki> why does "x & 1" give the lowest bit?
22:37:43 <sedeki> emphasis on lowest
22:38:28 <comstar> how is it possible for it to receive a word/byte with an incorrect bit order? 
22:38:38 <Welkin> because 1 is 0b00000001
22:38:41 <comstar> that's fundamentally your problem I think
22:40:56 <comstar> Welkin: you're assuming the least signficant bit is on the rightmost side.  For Teletex vs rs232 serial, for example, the order in which bits are transmitted are opposite.  But as I was telling sedeki, in both of those protocols, both ends are using the same protocol, and therefore... nvm he left
22:41:23 <comstar> frustrating
22:46:19 <comstar> sedeki: within the context of the cpu, when it's and-ing two registers, it wouldn't make sense for those registers to have a different bit order, so the question becomes how does x get stored backwards at any point down the line
22:46:42 <sedeki> no
22:46:43 <sedeki> ah
22:46:46 <sedeki> i'm still here
22:46:58 <comstar> nah welkin quit
22:47:11 <comstar> like he misunderstood what you were asking repeatedly
22:47:15 <sedeki> yeah
22:47:17 <sedeki> i saw
22:47:27 <sedeki> and-ing two registers is within one register
22:47:28 <sedeki> ehh
22:47:30 <sedeki> processor?
22:47:47 <sedeki> obviously the same "bit order" as it were would be the same within one processor
22:48:03 <sedeki> just as we have a native byte order
