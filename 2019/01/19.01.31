00:00:59 * hackage tonatona-google-server-api 0.1.1.0 - tonatona plugin for google-server-api  https://hackage.haskell.org/package/tonatona-google-server-api-0.1.1.0 (arowM)
00:08:32 <ddk> opqdonut: Yes thats what the problem, actually I was working to implemt more tests for the acid state library.
00:11:18 <dminuoso> ddk: You just creat it using the LogKey constructor?
00:11:42 <dminuoso> ddk: You just need to ensure that the phantom type is somehow visible (by inference, type annotation or type application)
00:12:14 <dminuoso> ddk: If you create a `FileLog object` with a logIdentifier, then it should be inferred.
00:12:34 <ddk> dminuoso: actually what should be the log identifier
00:13:47 <ddk> dminuoso: so object is just used as a phantom type and has no other importance
00:14:12 <dminuoso> ddk: Right, and the phantom type is carried over from FileLog.
00:14:39 <dminuoso> ddk: The relevance is that there might be a SafeCopy constraint on the phantom type.
00:15:03 <ddk> dominicusin[m]: Yes, there is a safeCopy Constraint
00:15:25 <dminuoso> ddk: Specifically if you did `readEntriesFrom` for example, it demands that this phantom type have an instance SafeCopy.
00:15:44 <ddk> dminuoso: Thanks a lot I think it will work now, give me two mins
00:16:21 <dminuoso> ddk: As for what logIdentifier should be, look at the implementations of `archiveFileLog` and `readEntriesFrom`
00:17:41 <ddk> dminuoso: so what should be that phantom type object
00:18:08 <ddk> dminuoso: should that be our state type
00:18:40 <dminuoso> ddk: Id say it should have a SafeCopy instance.
00:19:17 <dminuoso> "The centerpiece of this library"
00:19:50 <dminuoso> It seems that the library might not really be usable otherwise.
00:21:06 <ddk> dminuoso: okay
00:21:36 <ddk> dminuoso: Thanks a lot!
00:23:26 <dminuoso> ddk: Im still digging as to how it connects to the rest of the library. :)
00:28:00 <trcc> Woaw, I am reading about type level programming, and it seems quite amazing.
00:28:21 <dminuoso> ddk: The examples suggest that its supposed to be the state indeed.
00:28:28 <mniip> trcc, it is
00:28:30 <trcc> I should stop following Haskell people on twitter. I am never able to finish anything before I want to change it to adopt something cool
00:28:54 <ddk> ddk: Yes that's what I guessed
00:28:55 <trcc> This one is pretty good for beginners I think: https://www.parsonsmatt.org/2017/04/26/basic_type_level_programming_in_haskell.html
00:29:35 <ddk> dminuoso:  Yes that's what I guessed
00:30:01 <dminuoso> trcc: jle has a good series on singletons that is quite fun to read.
00:30:11 <ddk> dminuoso:  I feel there is huge chance to improve the documentation
00:30:28 <dminuoso> ddk: Considering there is none on Data.Acid.Log I suspect you are right. ;-)
00:31:03 <trcc> dminuoso: thank you. I will try and check it out. dminuoso I can see that he mentions that real dependant typing are comming to haskell. Any idea when?
00:31:16 <trcc> my haskell to read list is exploding...
00:31:36 <dminuoso> trcc: I dont know whether dependent typing will ever come to Haskell. But there's lots of work in progress to give us dependently typed haskell at the least.
00:31:53 <trcc> ough, what is the difference?
00:32:25 <ddk> dminuoso: can you help me to understand rollbackTo function
00:34:16 <ddk> dminuoso: that functions cuts the log entry to the given entryId, does this means that when we will resume the state we will get the state earlier, or the current state changes and becomes older
00:50:30 <dminuoso> trcc: As far as I understand it, in dependent typing you would not differentiate between terms and types.
00:51:28 <trcc> ah ok
00:53:39 <dminuoso> trcc: https://www.youtube.com/watch?v=wNa3MMbhwS4 this is a presentation by Stephanie Weirich showing what you can today already.
00:55:56 <trcc> Great! Thanks!
00:58:56 <Christienne> Test. Refresh
01:06:30 * hackage aeson-value-parser 0.16 - API for parsing "aeson" JSON tree into Haskell types  https://hackage.haskell.org/package/aeson-value-parser-0.16 (NikitaVolkov)
02:24:29 <dminuoso> Say I have a sized generator `Int -> Gen a`, is there a way to randomize the size within some boundaries?
02:25:36 <dminuoso> Something like `oneof (($ mySizedGenerator) <$> [1..10])` came to mind, is there a better solution?
02:29:57 <dminuoso> Without that ($) in there of course. :)
02:55:00 * hackage buffon-machines 1.1.0.0 - Perfect simulation of discrete random variables  https://hackage.haskell.org/package/buffon-machines-1.1.0.0 (mbendkowski)
03:12:43 <asheshambasta> So, I've been experimenting with Squeal and it seems like it is throwing too much type-level stuff at GHC and compiling a decently sized module that uses Squeal to define my DB schema seems to be outside the capability of my current computer (RAM goes up to 100% and compilation is impossibly slow). What is the most recommended Postgres specific library in the community? 
03:12:52 <asheshambasta> (or the most recommended libraries**)
03:13:13 <asheshambasta> Ideally: I'd like support for composite types, arrays etc. on postgres 
03:15:30 * hackage req 2.0.0 - Easy-to-use, type-safe, expandable, high-level HTTP client library  https://hackage.haskell.org/package/req-2.0.0 (mrkkrp)
03:35:28 <merijn> asheshambasta: Honestly, I think most people recommend either postgres-simple or opaleye
03:36:28 <merijn> I think Selda is (trying to?) competing with opaleye in terms of "higher level SQL", but honestly the more I've worked with databases (admittedly, SQLite, not postgres), the more I think "hand writing SQL" > "type level boilerplate death machines"
03:37:10 <dminuoso> merijn: Fully agree. Hand writing SQL is not cumbersome.
03:37:20 <dminuoso> Especially when Haskell makes it so simple to make your own combinators on the spot.
03:38:35 <nyc> Type-level boilerplate death machines sound like fun.
03:38:57 <merijn> I'd like some automatic schema validation (so there's a sanity check between the schema my code expects and the databases schema), and I hope Selda will help me deal with that (I haven't dug into it enough yet)
03:39:32 <merijn> My current codebase uses persistent, but all the non-trivial queries are just hand-written SQL
03:40:59 * hackage websockets 0.12.5.3 - A sensible and clean way to write WebSocket-capable servers in Haskell.  https://hackage.haskell.org/package/websockets-0.12.5.3 (JasperVanDerJeugt)
03:44:29 <arianvp> bgamari: what are the specs of ghc gitlab box?
03:44:30 <amx> merijn: I'd like to hear your assessment when you have made it. I use pg-simple for now and the initial errors due to schema mismatch are my only real concern.
03:45:00 * hackage iri 0.4 - RFC-based resource identifier library  https://hackage.haskell.org/package/iri-0.4 (NikitaVolkov)
03:47:17 <merijn> amx: Basically, that's the only reason I'm still using persistent. It creates the schema for me and checks it (plus migrating all the code away is busy work that doesn't help me atm), but I don't like it's design. Opaleye seemed decent, but it's postgres specific. Selda seems to be pretty directly inspired by opaleye, but properly parameterised over different SQL database
03:49:35 <amx> I used opaleye for a bit and found it painful to use once you reach something as basic as foreign keys
03:52:16 <merijn> I mean, SQL is already a pretty excellent DSL for managing databases and queries. Lots of people seem to be promoting BEAM, atm, but 5 seconds of looking at the docs of their modules already has me going "fuck this shit"
03:58:16 <dminuoso> merijn: I can understand why some people like to write an abstraction layer giving you more composability in terms of relational algebra so you can manipulate the arel tree.
03:58:22 <dminuoso> Those can be powerful tools.
03:58:53 <dminuoso> It's one of the things I thought was not bad about Rails.
03:59:13 <dminuoso> (relational algebra is really good)
04:00:41 <merijn> dminuoso: Sure, my point is just that the "weight to usefulness" ratio of the abstraction layers *so far* seems poor
04:01:23 <merijn> dminuoso: Just look at this one beam module: https://hackage.haskell.org/package/beam-core-0.7.2.2/docs/Database-Beam-Query.html
04:01:50 <merijn> dminuoso: I mean, really?
04:02:21 <Athas> Those instances are hilarious.
04:02:23 <merijn> Look at the type of 'outerJoin_'
04:02:27 <merijn> Athas: ^^^
04:02:37 <merijn> I mean, screw tha
04:02:40 <Athas> I am so happy I never have to touch anything more web-related than Hakyll.
04:03:27 <merijn> I mean, I've gone some pretty excessive lengths to get type safety, but even those were mostly for laughs
04:03:42 <merijn> Can you imagine the horrible type errors that produces
04:12:23 <asheshambasta> merijn: I tend to agree, Squeal is nice as an interesting direction to take, but the more I use it, the deeper I find myself sinking into the rabbithole 
04:12:55 <asheshambasta> So far I've not come across anything that is: 1. easy to use and understand, 2. represents the database as it should be 
04:17:13 <asheshambasta> merijn: I would say, however, that Squeal is orders of magnitude cleaner than Beam, *but* it requires a ton of type-level magic, that, if you are new to it, will make you significantly less productive towards achieving your end goal 
04:28:01 <asheshambasta> anyway, I started out this project using Squeal but I'm seriously considering backtracking to something much simpler
04:29:36 <asheshambasta> Do we have any success stories using Postgresql-simple? My use case is a large project with something like 30-40 tables 
04:30:12 <asheshambasta> but I think the type-level things with Squeal are seriously keeping me from feeling motivated and productive in Haskell 
04:30:46 <asheshambasta> I do understand most of it now, but it has just too many roadblocks: from understanding it, to actually compiling it
04:36:43 <amx> My project is of comparable size and I use pg-simple
04:41:28 <asheshambasta> amx: I see, the more I think about it the more I realise using pg-simple is better.
04:41:54 <asheshambasta> heck, I was using an ORM for the earlier version of this project. 
04:44:00 * hackage Unique 0.4.7.6 - It provides the functionality like unix "uniq" utility  https://hackage.haskell.org/package/Unique-0.4.7.6 (kapral)
04:45:10 <merijn> asheshambasta: You can ping tdammers, I think he's done quite a bit with postgres-simple
04:46:05 <merijn> The only thing I'm missing with the *-simple DB libraries is a nice SQL quasiquoter
04:48:08 <dminuoso> merijn: You mean beyond Database.PostgreSQL.Simple.SqlQQ?
04:48:15 <dminuoso> What particular features are you looking for?
04:50:51 <merijn> dminuoso: I don't use postgres, so that one doesn't help me :)
04:51:37 <dminuoso> merijn: Ah I see. Mind my asking, what do you use?
04:51:42 <merijn> dminuoso: sqlite
04:52:00 <merijn> I ain't got time to be installing and maintaining servers :)
04:52:51 <dminuoso> merijn: Looking at the implementation, it seems to be a very naive QQ that should also work for sqlite.
04:52:59 <dminuoso> It's just 20 lines or so.
04:54:00 <phadej> postgresql-sinple works well until you want to have optional where clauses etc
04:54:31 <amx> asheshambasta: you only need to learn/create some idioms to work around some of pgsimple's idiosyncrasies
04:54:33 <phadej> i.e. as far as queries have static shape it's fine
04:54:42 <dminuoso> phadej: what is an optional where clause?
04:54:57 <merijn> phadej: That doesn't seem well supported in any library I've seen so far, though
04:55:04 <asheshambasta> amx: from my understanding, there's also support for composite types, arrays etc. correct?
04:55:07 <merijn> phadej: I just resort to string interpolation for that
04:55:14 <phadej> dminuoso: sometimes you want an additional "AND age > 0"
04:55:26 <phadej> i wrote a query builder monad :)
04:55:46 <phadej> but it's barebones, so not on Hackage
04:55:51 <dminuoso> phadej: Do you maintain an relational algebra tree for that?
04:56:21 <phadej> dminuoso: no, some approximation of query ast though
04:56:42 <phadej> but it doesn't eve try to verify you don't typo field names
04:56:53 <phadej> or anything like thst
04:57:16 <phadej> only produce syntactically valid query, doesn't "type-check" it
04:58:02 <phadej> IMHO it's a good spot to be; modelling postgres "type-system" in Haskell's is just too difficult
04:59:16 <phadej> asheshambasta: postgresql-sumpke should support arrays etc
05:00:16 <amx> yeah, never used composite types, but use plenty of arrays
05:00:27 <phadej> there is PGArray for that
05:01:07 <phadej> and i dont't know why composite types won't work, but there might not be helpers for them
05:06:02 <tdammers> fear not; exactly because of the lack of quasiquoters, I wrote yeshql
05:06:50 <tdammers> but yes, quasiquoting only works if your queries are completely known at compile time (apart from parameters)
05:07:32 <tdammers> I usually use a mixed approach - yeshql for statically-known queries, and a domain-specific CRUD abstraction, ideally derived from plain old record types using TH or Generics
05:14:28 <asheshambasta> To my novice haskell eyes: I feel that most of these libraries start out with good intent, but how they feel when using everyday becomes very different. Before you know it, you start having to battle with the library itself because it is so cutting edge. So instead of being focussed on the problem you set out to solve, you're now focussing on making the library work for you 
05:15:17 <asheshambasta> So after using Squeal and running into so many problems, I feel exhausted and a little demotivated for having used it for a project that is meant to introduce Haskell to our team. 
05:15:31 <asheshambasta> I don't mean to sound ranty; and that is not my intention. 
05:18:36 <merijn> asheshambasta: Funny you say that, because I was just thinking how some of your questions remind me of the stereotype "new to strong typing and loving it"-beginner. I notice a lot of people that like the strong typing part gravitate to these really heavy weight "type safe" libraries that make a lot of things painful
05:18:58 <merijn> asheshambasta: I think an important part of learning Haskell is also learning that sometimes a little bit of type safety goes a long way :)
05:19:33 <merijn> asheshambasta: You have to find a sweet spot in "how much safety can I get" vs "how much type level boilerplate does it cost?" and developing such an intuition can take time
05:19:56 <asheshambasta> merijn: yeah, that was my perspective when I started out as well, so you are spot-on regarding that. 
05:20:14 <merijn> asheshambasta: And a lot of the ecosystem is people trying to sort this out
05:20:34 <asheshambasta> I was in the "new to type-level and loving it" phase, however, I come from Scala so I'm used to strong typing (albeit not as elegant as that of Haskell)
05:20:58 <merijn> asheshambasta: Compare, for example, MonadBaseControl (which I personally consider way too freaking complicated) and MonadUnliftIO
05:21:51 <merijn> MonadUnliftIO is considerably more limited/less powerful, but also *much* more lightweight and easy to use, but it took several years before the idea of MonadUnliftIO was crystalised into a concrete library
05:22:07 <merijn> (oh, and much easier to understand and reason about)
05:22:36 <asheshambasta> Yeah. What do you think about Servant, though? 
05:22:44 <merijn> Never used it, tbh
05:22:53 <merijn> I don't really do web things :)
05:22:59 <Logio> merijn: I think that's a dangerous dichotomy though, you should never sacrifice safety just to skimp on boilerplate
05:23:08 <merijn> Logio: I disagree
05:23:17 <merijn> Logio: Did you look at the BEAM docs linked earlier?
05:23:36 <Logio> the right question is, how much time are you willing to spend to write a library that can achieve the safety without the extra boilerplate
05:24:40 <Logio> merijn: I did not
05:24:46 <merijn> Logio: https://hackage.haskell.org/package/beam-core-0.7.2.2/docs/Database-Beam-Query.html#v:outerJoin_
05:25:03 <asheshambasta> so, to be specific, the problem with Squeal is not really boilerplate: it is really like writing queries, defining schemata at the type level, much like what postgresql-simple does as "strings" 
05:25:47 <asheshambasta> The problem is that given it employs a lot of type-level features, 1. it is hard to learn, 2. it is inefficient as hell to work with, since most type-level stuff seems to really push GHC at this point. 
05:26:03 <merijn> Logio: I'm sure that is very type safe compared to using postgresql-simple with string SQL queries, but I can tell you which one will be easier to work with
05:26:38 <merijn> And I'm pretty confident with only a small amount of tests the pg-simple code will be just as robust
05:27:06 <Logio> merijn: but are you saying that you it is not possible to write a library that has the same level of safety with less boilerplate? 
05:27:25 <merijn> Logio: It hasn't been done yet for SQL libraries, afaict
05:27:33 <asheshambasta> merijn: yes, in the end, Squeal is not going to help you also when your schema in the DB differs from the one you've defined in your codebase, but it will ensure that the way in which you interact with the schema you've defined at the type-level, is correct. 
05:27:40 <merijn> Logio: I'd be happy to be proven wrong, but until someone does...
05:42:23 <ddk> Hello everyone
05:44:08 <ddk> anyone here with a fair knowledge of `acid-state` library, Actually I'm implementing more tests for the library and I have some doubts about it, as there very few to no documentation for some parts of the library I need someone to discuss about, would someone will help me
06:25:33 <gentauro> ddk is the `acid-state` built on `STM`?
06:25:51 <hsn> why ghc takes so much memory?
06:27:27 <c_wraith> hsn: ghc usually doesn't.  if compiling a haskell library takes a ton of memory, it's usually actually the linker that's the problem.
06:28:01 <c_wraith> hsn: which is why modern versions of ghc *really* try to use gold instead of ld, if they can find it.  gold is a lot better.
06:28:37 <hsn> gold is from llvm?
06:28:39 <merijn> gentauro: No
06:28:53 <merijn> gentauro: And, as I recently learned, sadly acid-state isn't even properly ACID
06:29:16 <c_wraith> I'm not sure if it's part of llvm.  I haven't looked at its history.  All I know is that it's a redesign of the linker that threw away a lot of things that make ld complex
06:41:24 <hsn> that ld linker is running is separate process?
06:44:41 <dminuoso> c_wraith: Unless you toggle on LTO.
06:44:49 <dminuoso> Gold used to be hilariously broken with that.
07:04:30 * hackage pandoc 2.6 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-2.6 (JohnMacFarlane)
07:12:55 <gentauro> merijn then what's the point with that name? :|
07:34:13 <ddk> Hello everyone
07:34:20 <xdecimal> hi
07:35:03 <ddk> is there someone with fair knowledge of `acid-state` library, I'm implementing more tests for it and need help to clear some of the doubts
07:38:02 <ddk> mniip: do you know about it
07:41:05 <Amras> To pick up on yesterday's FRP topic, is timeTrans :: Behavior a -> Behavior T -> Behavior a achievable in Yampa? As in, can I take a SF and "slow it down" so each T of the new SF is evaluated at T/2 of the old SF?
07:43:27 <vaibhavsagar> hvr: your instructions for using `haskell-ci` are incomplete
07:44:05 <vaibhavsagar> it looks like it assumes Cabal <2.2, because Distribution.PackageDescription.Parse is unavailable from that version onwards
07:44:38 <vaibhavsagar> and when I try with Cabal 2.0.1.0 it complains about `Version`
07:45:14 <Amras> (implementations of time control I've found alter the dt provided to reactimate, but that only works on the "global" scale and is IO-bound)
07:45:20 <vaibhavsagar> the `make_travis_yml.hs` script says it takes pains to avoid non-default packages, but this is clearly false
07:53:54 <ddk> is there someone with fair knowledge of `acid-state` library, I'm implementing more tests for it and need help to clear some of the doubts
07:55:07 <c_wraith> ddk: people with knowledge of it have quit using it because it is not ACID, and it's quite slow.
07:55:24 <Boarders> I have a cabal project with an executable that depends on an internal library and get a weird error where it fails to identify the exposed type in the library with the internal type
07:55:26 <Boarders> even though they are the same
07:55:45 <Boarders> and so says it can't identify e.g. library:Types.MyType with MyType
07:55:57 <Boarders> is anyone familiar with this sort of error
07:56:03 <Solonarv> Boarders: can you post the error message (and ideally the code/a minimal example too)?
07:56:10 <adamCS> Boarders: any chance there are different versions of that library in the project somehow?
07:56:59 * hackage too-many-cells 0.1.2.0 - Cluster single cells and analyze cell clade relationships.  https://hackage.haskell.org/package/too-many-cells-0.1.2.0 (GregorySchwartz)
07:57:20 <Solonarv> the first thing to try is deleting the build directory (.stack-work, or dist-newstyle) and trying again; maybe there's some stale files
07:58:13 <ddk> c_wraith: hmm yes I agree but atleast they must have the knowledge gained earlier, I'm working on its enhancement.
07:58:41 <Boarders_> Solonarv: I can't produce a minimal example easily at the moment but I can link to the error
07:59:32 <Solonarv> that'd help
08:01:44 <Boarders_> Solonarv: the errors all look something like this: https://gist.github.com/Boarders/751fb98abadb1eb8d6170c6369676b34
08:02:08 <Boarders_> most importantly: Expected type: FinalDecorationDAG Actual type: phylogenetic-component-graph-0.1.0.1:Bio.Graph.Constructions.FinalDecorationDAG
08:06:18 <Solonarv> Boarders_: what does your cabal file look like? can you add it to the gist?
08:06:33 <Boarders_> I'll link you to it
08:07:26 <Boarders_> it is here: https://github.com/amnh/PCG/blob/refactor-sub-libraries/phylogenetic-component-graph.cabal
08:07:31 <hypnotic0088_> Hello Everyone, I want to contribute to the haskell community for GSoc 2019. I have a good background in C++ but don't know much about compilers and how programming languages work. Are there some pre-requisites to contribute? Will I have to study a lot?
08:08:19 <w0xy>  what is a good ide that can compile haskell within it, i've tried atom, but since ghc-mod doesnt work with ghc 8.6 it's not letting even install ghc-mod
08:09:50 <dminuoso> Hi hypnotic0088_! Happy to see folks interested into contributing. As far as I know Summer of Haskell has not been selected yet, or has it?
08:10:07 <recureion-ninja> hypnotic0088_: If you want to contribute to a compiler focus project for Google Summer of Code, then you should have a basic understanding of compilers. Here's a good, free course from Stanford: http://openclassroom.stanford.edu/MainFolder/CoursePage.php?course=Compilers
08:10:12 <dminuoso> hypnotic0088_: Any particular field you are interested into contributing?
08:10:37 <hypnotic0088_> The results for selection of organisations will come later in Feb I guess.
08:10:43 <tdammers> hypnotic0088_: depends what you are going to work on. there are certainly areas in the codebase that don't require much in terms of compiler theory, plus there are lots of things in GHC that aren't run-of-the-mill compiler stuff but rather specific to the implementation of a pure functional language
08:11:07 <hypnotic0088_> recureion-ninja: Will a basic knowledge be good enough? I have written a debugger before.
08:11:41 <dminuoso> hypnotic0088_: Depends on what parts you are working on really.
08:11:43 <tdammers> hypnotic0088_: outside of GHC itself, there is plenty of other stuff to work on - for example, improvements to the tooling would be extremely welcome
08:11:51 <dminuoso> hypnotic0088_: Working on the type system might require some domain specific knowledge for example.
08:12:09 <Solonarv> Boarders_: I have to admit this project is way too big for me to figure out where the error is coming from
08:12:14 <recureion-ninja> hypnotic0088_: You'll have one or more mentors that should be able to provide youwith the more specific resources you'll need to build on top of the basic compiler knowledge.
08:12:46 <tdammers> hypnotic0088_: also, if you want to contribute to GHC itself specifically, you may want to /join #ghc and ask there
08:13:12 <hypnotic0088_> recureion-ninja: That's nice. Where can I find the mentors? and where can I explore which projects I can work on?
08:13:19 <hypnotic0088_> Can someone please give me a link?
08:13:41 <tdammers> hypnotic0088_: ghc-devs mailing list, too. that might be a good place to fish for mentors, too.
08:14:14 <tdammers> hypnotic0088_: or the more general haskell-cafe, which is probably more appropriate for GSoC mentorship requests
08:14:15 <recureion-ninja> hypnotic0088_: tdammers is correct that there are usually more than just compiler focused projects, if that's more your interest. I beleive that the Google Summer of Code are still being proposed and mentors are volenteering to proposed projects. You can view the proposals here: https://www.reddit.com/r/haskell/comments/ae1i6z/reminder_please_submit_gsoc_ideas/
08:14:25 <hypnotic0088_> tdammers: I have no particular prefrence right now. 
08:15:36 <tdammers> hypnotic0088_: well, in that case, I believe working on the compiler itself with little prior experience in compiler development might prove challenging, you're probably going to have a more productive time with something where your existing expertise can be put to good use
08:15:45 <hypnotic0088_> Okay thanks a lot recureion-ninja and tdammers :)
08:18:07 <Boarders_> Solonarv: same
08:19:51 <Boarders_> Solonarv: have you come across any similar error before where it is somehow not able to identify the library qualified type with the exposed type?
08:19:57 <Solonarv> I'd suggest just deleting stuff (large chunks at a time, even) in order to produce a smaller example
08:20:04 <Solonarv> I've never run into that issue, no
08:28:59 * hackage instana-haskell-trace-sdk 0.1.0.0 - SDK for adding custom Instana tracing support to Haskell applications.  https://hackage.haskell.org/package/instana-haskell-trace-sdk-0.1.0.0 (basti1302)
08:34:17 <w0xy> i'm running into these issues a lot when trying to install packages, is there something i'm doing wrong
08:34:19 <w0xy>  Cabal-2.4.1.0 from stack configuration does not match >=1.10 && <2.3  (latest matching version
08:34:55 <w0xy> is cabal not backwards compatable?
08:41:01 <Solonarv> '>= 1.10 && <2.3' means that package (i.e. Cabal) must be within that version range
08:41:13 <Solonarv> clearly 2.4.1.0 does not belong to that version range!
08:42:07 <Solonarv> in Haskell, the convention for version numbers is the PVP; roughly speaking, if your version is x.y.z.t, breaking changes should increment x or y
08:42:57 <Solonarv> so according to the PVP (which Cabal follows), Cabal-2.4.1.0 is not necessarily compatible with any version other than 2.4.*
08:43:18 * geekosaur is more worried about 'from stack configuration'
08:43:35 <Welkin> just use cabal-install and avoud stack
08:43:37 <Welkin> avoid*
08:43:49 <Solonarv> "from stack configuration" just means "in the snapshot you're using", basically
08:44:07 <Solonarv> cabal-install uses a solver instead of curated snapshots, so it doesn't run into those issues
08:44:33 <w0xy> so is there a way to set up a specific version of dependancies within cabal so i can install the right setup 
08:44:41 <glguy> w0xy: If you share more information about what you're doing exactly you can get more help
08:44:55 <w0xy> i thought once cabal was installed it remained at that version
08:45:20 <w0xy> i'm trying to install ghc-mod
08:45:44 <Solonarv> so, you went and typed 'stack install ghc-mod', presumably?
08:46:09 <w0xy> correct
08:46:10 <Welkin> what does `cabal --version` say?
08:46:24 <w0xy> 2.4.1
08:46:28 <Welkin> okay
08:46:36 <Welkin> type `cabal install ghc-mod`
08:46:55 <geekosaur> this gets better and better. ghc-mod doesn't work in ghc8. so you're following some ancient set of instructions based on an ancient stack (newer ones would point you to stack's own intero. gotta stay in the garden y'know)
08:47:06 <Welkin> er
08:47:11 <Solonarv> it works on ghc8, actually; just not ghc8.6
08:47:15 <Welkin> type `cabal new-install`
08:47:25 <Solonarv> iirc ghc8.4 is the latest ghc supported by ghc-mod
08:47:28 <w0xy> right, i have ghc 8.6 so am i wasting my time even trying to install it?
08:47:49 <Solonarv> indeed.
08:47:52 <Welkin> ghc 8.8 is coming in a little over a month
08:48:04 <Solonarv> ghc-mod *will not* work with ghc-8.6 (until someone updates it)
08:48:17 <w0xy> ok understandable
08:48:45 <w0xy> i was trying to get something that allowed me to compile haskell within atom, but the only package that does depends on ghc-mod
08:49:24 <Welkin> really the best setup for haskell is emacs
08:49:32 <Solonarv> that seems strange, I recall seeing other plugins when I looked into atom
08:49:57 <w0xy> i can use vim i suppose, i dont know emacs
08:50:02 <Welkin> you can try ghcid https://github.com/ndmitchell/ghcid
08:50:21 <Welkin> w0xy: if you use spacemacs you get vim bindings (emacs with evil mode)
08:50:41 <w0xy> thanks for the help
08:51:15 <Welkin> ghcid works with emacs, neovim, and vscode
08:51:28 <Solonarv> ghcid also works by itself in a terminal, which is nice
08:51:33 <Welkin> if you want something like atom (but better that works) use vscode
08:52:07 <Solonarv> caveat for ghcid: it doesn't work very well/is finicky in cabal v2 projects with multiple internal libraries
08:52:21 <tdammers> I have found that compared to most other languages, Haskell is very usable with extremely minimal editor tooling
08:52:26 <Solonarv> otherwise it's great
08:52:31 <Welkin> I just use haskell-mode for syntax highlighting, so not a very high-tech setup, but it works for me
08:52:32 <Solonarv> w0xy: https://www.parsonsmatt.org/2018/05/19/ghcid_for_the_win.html
08:53:09 <tdammers> my usual setup is just two terminal side-by-side, with a vim session in the left, and a build-and-test loop continuously running in the right
08:53:16 <tdammers> scripting this up with inotifywait is fairly easy
08:53:22 <Solonarv> the build-and-test loop can just be ghcid, no?
08:53:42 <tdammers> sure
08:53:57 <w0xy> that makes sense, im sure i can set up a screen split window in my lxss and be able to do that on windows still
08:54:43 <Solonarv> the quick-and-dirty solution is to use win-<left arrow> and win-<right arrow> to move a window to that half of the screen
08:55:17 <w0xy> ah okay
08:56:07 <Solonarv> also, a prior warning: cabal new-install just plain doesn't work on windows
08:56:44 <Solonarv> (actually maybe it does on win10? it needs symlinks, so it has trouble on earlier versions)
08:57:20 <w0xy> i was able to use cabal new-install to get tidal cycles installed on my other windows machine
08:57:39 <w0xy> although i tried a few different ways of doing it at first
08:58:06 <Solonarv> ah, I see a relevant issue: https://github.com/haskell/cabal/issues/5837
08:58:59 * hackage wolf 0.3.46 - Amazon Simple Workflow Service Wrapper.  https://hackage.haskell.org/package/wolf-0.3.46 (markfine)
09:02:29 * hackage gitlib-libgit2 3.1.2.1 - Libgit2 backend for gitlib  https://hackage.haskell.org/package/gitlib-libgit2-3.1.2.1 (JohnWiegley)
09:03:58 <Solonarv> heh, that's a funny library name
09:04:13 <Clint> needs more git
09:06:21 <w0xy> i actually just installed idris and it's working well with atom
09:08:36 <Solonarv> yeah, I hear idris has fantastic editor integration
09:13:47 <conal_> _deepfire: can you tell what version of fran you got? i
09:30:55 <wroathe> Hah, HIE must have a memory leak somewhere. It's regularly consuming like 250MB of memory when idle
09:32:15 <wroathe> (and growing)
09:32:38 <Welkin> hie?
09:32:52 <Welkin> oh, some ide thing
09:33:10 <Welkin> that is a lot
09:34:16 <wroathe> Yeah, it's an IDE server that supports LSP
09:35:20 <Welkin> that reminds me of one thing I love about the beam/erlang
09:35:32 <Welkin> memory consumption is very stable
09:38:21 <bsima> Welkin: do you know how that compares to golang?
09:38:31 <bsima> just curious
09:39:07 <Welkin> I don't know enough about go, but I do know that it is nothing like erlang (which is a shared-nothing, gc-per-process architecture)
09:40:25 <bsima> fair point
09:43:18 <_deepfire> conal_: that was 1.16, at least that's what the archive name suggested
10:36:19 <aplainzetakind> wroathe: I abandoned hie because of that leak basically.
10:44:29 * hackage optparse-simple 0.1.1.1 - Simple interface to optparse-applicative  https://hackage.haskell.org/package/optparse-simple-0.1.1.1 (MichaelSnoyman)
10:50:44 <Felix> !list
10:50:44 <monochrom> Felix: http://okmij.org/ftp
10:51:48 <dmwit> Huh. Does the bot do that every time?
10:51:49 <dmwit> !list
10:51:49 <monochrom> dmwit: http://lpaste.net/browse
10:52:54 <geekosaur> slighty out of date, there :p
10:52:57 <dmwit> Oh. I was joking about there being a bot. But now it's clear that it's so. What an odd bot.
11:20:45 <_deepfire> What are the typical techniques for debugging instances of suspected UndecidableInstances sending GHC into infinite loops/OOM?
11:21:25 <[exa]> is there some tracing option for ghc?
11:21:35 <_deepfire> There's -ddump-tc-trace, yes
11:21:37 <glguy> Does rewriting the code not to use undecidableinstances make the loop go away?
11:21:46 <[exa]> +1 glguy
11:22:19 <_deepfire> glguy: problem is, I'm up to my ears in things like generics-sop, so I don't think I have choice
11:22:26 <glguy> yuck :(
11:22:42 <_deepfire> The cost of coming up with a rewrite is way heavy
11:24:43 <_deepfire> -ddump-tc-trace indeed shows a never-ending story, that keeps mentioning roughly the same actors
11:25:37 <_deepfire> But there's too many things involved relative to my brain size to get a sufficiently clear picture
11:26:40 <_deepfire> I guess I might need to start processing -ddump-tc-trace output (filtering for digestibility) if I have no other option..
11:26:58 <_deepfire> but before that I wondered what people do in similar situations
11:27:35 <_deepfire> In my case GHC simply OOMs in the end, after consuming all memory
11:28:27 <_deepfire> Minimising the repro is another way, of course
11:29:30 <OmegaDoug> Hi. I'm wondering if anyone knows of an example of how to serialize a ADT to a text file, kind of like how Lisp will serialize an s-expression almost verbatim. I'm curious how it would be represented as something other than JSON or XML
11:32:38 <Solonarv> it can't be done in general, because there are types (most notable, functions!) which can't be easily generalized
11:32:58 <_deepfire> OmegaDoug, read . show is identity for many things in Haskell, similar to Lisp's (lambda (x) (read (print x)))
11:33:35 <Solonarv> Show/Read are supposed to do this (i.e. show is supposed to output valid Haskell that will reconstruct its input), but in practice many types don't obey this
11:34:01 <kosmikus> _deepfire: it's a bit strange that GHC runs OOM. normally, you'd first get a reduction stack overflow. have you explicitly set -freduction-depth to 0 to disable that?
11:34:16 <OmegaDoug> It's OK for my purposes, I'm really just interested in how it looks, no intention of using it in a haskell program
11:34:29 <zachk> show!
11:34:45 <_deepfire> kosmikus: no, I didn't, in this case -- and indeed I've been using reduction stack tweaks in the past and had the problem
11:34:48 <Solonarv> > show (Just (Left 5))
11:34:50 <lambdabot>  "Just (Left 5)"
11:34:55 <Solonarv> ^ see?
11:34:56 <zachk> make sure your ADT has a deriving Show clause or you make a show instance for the ADT 
11:35:22 <zachk> > show "loook a mulitline string\noh no oh no\n really?"
11:35:25 <lambdabot>  "\"loook a mulitline string\\noh no oh no\\n really?\""
11:35:44 <zachk> that seems a bit strange
11:35:59 <Solonarv> that's because show's output is a string
11:36:16 <OmegaDoug> I know exactly what you're suggesting, I just have to get to my personal computer so I can hop on GHCi
11:36:16 <merijn> zachk: Why?
11:36:21 <OmegaDoug> Thanks 
11:36:31 <lyxia> > show (Just "foo")
11:36:32 <Solonarv> % print "look a multiline string\noh no oh no\n really?"
11:36:33 <yahb> Solonarv: "look a multiline string\noh no oh no\n really?"
11:36:34 <lambdabot>  "Just \"foo\""
11:37:05 <zachk> never noticed the quoted \" before 
11:37:06 <_deepfire> kosmikus: this is 8.6.3, and I almost made my way to porting the thing to 8.8, just to see if the behavior is different
11:37:24 <merijn> zachk: The quotes are part of string syntax, so showing a String adds quotes
11:37:35 <Solonarv> for more compact representations, there's Binary (from the 'binary' package)
11:37:59 * hackage machines-encoding 0 - Transcode encodings with machines.  https://hackage.haskell.org/package/machines-encoding-0 (davean)
11:38:10 <Solonarv> tangentially related: compact regions, which allow you to dump the in-memory representation of a type into a file and reload it later
11:38:23 <Solonarv> (doesn't work if the type contains functions, though)
11:38:59 * hackage machines-attoparsec 0 - Parse machines streams with attoparsec parsers.  https://hackage.haskell.org/package/machines-attoparsec-0 (davean)
11:41:01 <_deepfire> kosmikus: unrelated question, if I may -- are 'lens-sop' obsolete?  I made a PR with an implementation for sums, but it never received any comment.
11:42:17 <_deepfire> I imagine that optics is the next generation replacement by now..
11:43:02 <Solonarv> generic-lens, actually
11:43:11 <kosmikus> obsolete is perhaps too harsh. but I've never used lens-sop myself, so it's not very actively maintained, I guess. I'm sorry for overlooking your PR though. I'll try to take a look soon.
11:43:41 <_deepfire> Solonarv: generic-lens is another, not-directly-related thing, that's not based on generics-sop
11:43:56 <Solonarv> ah
11:43:57 <kosmikus> optics isn't "based" on generics-sop either
11:43:58 <_deepfire> kosmikus: thank you!
11:44:40 <_deepfire> sop-based, my bad!
11:44:55 <kosmikus> neither
11:46:19 <_deepfire> Oh, of all things in the optics/ repository, I only noticed optics/optics-sop, my fauly again
11:46:27 <_deepfire> *fault
11:47:01 <Solonarv> generic optics are really cool :D
11:47:02 <kosmikus> yes, ok, optics-sop derives optics via sop, but the rest of the libraries are unrelated
11:49:39 <_deepfire> I've read the paper, and have a general idea about the thrust (constraining polymorphism for better inference, type errors and user experience), but I also somehow managed to connect it to SOP for some reason
11:51:41 <kosmikus> heh. there's no paper, at least not one I know of :) do you mean the haskellx talk?
11:52:21 <_deepfire> Sorry, yes, the slides in https://github.com/well-typed/optics/blob/master/Talk.pdf
11:52:28 <_deepfire> I'm infinitely sloppy today
11:52:30 <kosmikus> ok
11:55:17 <wroathe> Hey, can someone here save me some digging and tell me if there's a generic function out that that lets you lookup up the value of a named ADT field using a string for the key?
11:55:36 <wroathe> and/or tell me to stop being lazy :P
11:56:50 <kosmikus> wroathe: well, with a type-level string, we're back at generic-lens ...
11:57:10 <wroathe> That is, foo = Foo { bar="baz" }, maybeBar = lookup "bar" foo
11:57:12 <wroathe> something like that
11:57:43 <wroathe> (if Foo is an instance of Generic, that is)
11:58:15 <kosmikus> with a term-level string, this would hardly be type-safe
11:59:10 <wroathe> kosmikus: In this case I don't care as much about type safety. The value I'm performing a lookup on can either be a HashMap or a user-supplied ADT
11:59:34 <wroathe> I'd right now I'm requiring them to implement a HasEnvField class
11:59:44 <wroathe> Which doesn't feel as ergonomic as I'd like
12:00:00 <kosmikus> so all fields have to be of the same type?
12:00:30 <wroathe> It would be better just to make an attempt at getting an "env" field from the value, and if it fails, or if the env field isn't a string, then so be it
12:01:17 <wroathe> I think this should be possible with Generics. I might need to implement my own.
12:01:46 <_deepfire> wroathe: what would be the return type of this lookup function?
12:01:54 <wroathe> Maybe String
12:02:47 <wroathe> getEnv :: FromJSON a => a -> Maybe String
12:02:54 <wroathe> Is specifically what I'm thinking
12:04:15 <wroathe> I'll just see what I can find/implement. 
12:05:20 <kosmikus> wroathe: well, if you're in a JSON context, and happy to require ToJSON a, then you can just turn the argument into a Value and do the lookup there.
12:05:24 <dmwit> (Shouldn't there be an argument for the key there?)
12:05:49 <wroathe> dmwit: That function already assumes I'm looking for "env" :D
12:05:51 <kosmikus> dmwit: I think it's implied that the key is "env"
12:06:59 <dmwit> I don't get it.
12:07:23 <dmwit> What's wrong with replacing `getEnv`, a thing implemented with generics and closing over the string `"env"`, with `env`, the name of the field you're selecting?
12:08:00 <dmwit> (This whole question makes my skin tingle.)
12:08:24 <kosmikus> I think that's a good question :)
12:09:02 <wroathe> The ADT the user supplies may not have an "env" field
12:09:38 <wroathe> So it's any ADT that is an instance of Generic, that may not have an "env" field, or that "env" field may not have the right type
12:09:47 <wroathe> And if they don't specify their own ADT, I default to a HashMap
12:10:00 * hackage hedis 0.11.0 - Client library for the Redis datastore: supports full command set,pipelining.  https://hackage.haskell.org/package/hedis-0.11.0 (k_bx)
12:10:16 <dmwit> I don't think it is sensible to try to be polymorphic in such a way that you can handle even types you know nothing about.
12:10:30 <wroathe> In this case, I know that it's an instance of Generic
12:10:36 <wroathe> Which I think is kind of the point of Generic, right?
12:10:42 <dmwit> I count that as "nothing", honestly.
12:10:58 <dmwit> At least for the duration of this discussion. ;-)
12:11:28 <wroathe> Then lets open a PR to remove GHC.Generics from GHC :P
12:11:32 <wroathe> Seems like it doesn't have value
12:11:51 <kosmikus> wroathe: what you want can certainly be done. I think it's still fair to ask whether you should really be doing it. do you really want to "silently" do something with a field of a specific name, without somehow making that obvious in the types?
12:13:06 <geekosaur> they want their javascript and they want it now. safety's not a thing
12:13:21 <wroathe> It's no more magical than the FromJSON/ToJSON machinery, which relies pretty heavily on GHC.Generics
12:13:30 <wroathe> That said, now that I think about it there's a much easier way to do this
12:14:04 <kosmikus> generic FromJSON / ToJSON is also "bad" if you plan to use the resulting JSON as part of an external API
12:14:12 <wroathe> Which is to first decode the JSON into a type I know something about (probably just the Aeson Value type), perform the lookup there, then fromJSON it to the user's type
12:14:55 <kosmikus> wroathe: I suggested doing the lookup on "Value" above
12:15:24 <wroathe> kosmikus: Ah, I think I missed that.
12:15:25 <wroathe> I see it now
12:15:52 <wroathe> I probably subliminally absorbed your good advice :)
12:16:11 <dmwit> Perhaps it would be sensible to `data WithEnv a = WithEnv { env :: Env, val :: a }` and `instance FromJSON a => FromJSON (WithEnv a) where {- pull out your env first, then pass the rest on to the underlying instance -}`.
12:17:02 <dmwit> Then you don't need to know magical things about the contained `a`.
12:18:15 <wroathe> dmwit: kosmikus suggested the right solution
12:18:23 <wroathe> dmwit: I appreciate your help though :)
12:20:56 <hsn> can i delete bootstrap compiler after stage1 compiler starts to compiling?
12:33:12 <Boarders> does anyone know if there is something like list-dependencies for cabal new
12:33:31 <Boarders> i.e. find out which particular versions of libraries your project depends on?
12:34:00 <davean> I mean, freeze would do that
12:34:41 <Boarders> ok thank you
12:34:51 <cocreature> Boarders: cabal-plan can also be helpful for that
12:37:37 <wroathe> kosmikus: Bah, that doesn't quite work for my needs.
12:37:41 <wroathe> kosmikus: It was almost a good idea
12:37:50 <wroathe> https://github.com/JustinChristensen/config-provider/blob/master/src/System/Environment/Config/Default.hs#L37
12:38:05 <wroathe> Wait, wrong branch
12:38:12 <wroathe> https://github.com/JustinChristensen/config-provider/blob/polymorphic-return-type/src/System/Environment/Config/Default.hs#L47
12:39:05 <wroathe> Basically the idea is that these are composable "configuration readers" that are in the state monad
12:39:33 <wroathe> So they take a configuration state #1 -> do some IO -> return a configuration state #2
12:39:48 <wroathe> And that happens via merging configuration states
12:39:57 <davean> yah, cabal-plan is better but not part of cabal
12:41:12 <wroathe> Actually, I'll just assume these configuration readers aren't as easily composable. That makes my life easier.
12:43:30 <aplainzetakind> What's the syntax to specify default implementations for some of the methods in a class I'm defining, and specify minimal complete definitions, etc.?
12:44:48 <kosmikus> aplainzetakind: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#minimal-pragma
12:49:00 * hackage too-many-cells 0.1.2.1 - Cluster single cells and analyze cell clade relationships.  https://hackage.haskell.org/package/too-many-cells-0.1.2.1 (GregorySchwartz)
12:49:18 <wroathe> Hmm, so I was kicking around the idea of using Monoid/Semigroup to constrain the user-specified type to those with "merging" semantics
12:49:49 <wroathe> But based on this problem I was if it would make sense to make a typeclass that is monoid-like, with this optional getEnv method
12:50:16 <wroathe> It might feel ugly writing <> for two values of an ADT
12:50:41 <aplainzetakind> kosmikus: Thanks.
13:25:48 <ahri> I don't understand how to use a `Data.ByteString.Internal.ByteString` - I'm not sure why I even see an "internal" type - can anyone explain this? Ultimately I'd like to concatenate it with another ByteString (I have OverloadedStrings on)
13:27:31 <geekosaur> ahri, it's the actual definition of it, Data.ByteString re-exports it
13:28:08 <geekosaur> if you are seeing a conflict, either you have a lazy ByteString or possibly you have two versions of the bytestring package in use somehow
13:29:18 <geekosaur> usually if it shows the internal one, it means you got it from a function when you don't have Data.ByteString imported
13:30:05 <ahri> it's quite possible I've imported a couple; I brought Warp & WAI in to play about and had trouble so I broght in Data.ByteString.Lazy too
13:30:09 <ahri> *brought
13:31:19 <geekosaur> maybe you should show the actual code and actual error, then
13:31:40 <Boarders> when you write some code with the ST monad and then do runST and you don't actually reference the type in the state thread what exactly happens when you run it
13:31:56 <Boarders> is the s type in ST s specialised to something or somehow never appears or?
13:32:37 <ahri> geekosaur: ok, I'll just try removing my qualified import, and then stick it in a gist
13:33:12 <geekosaur> Boarders, it's a phantom
13:33:36 <Boarders> geekosaur: ah ok
13:34:16 <bifunc2> Has someone here worked with Streaming.Prelude ?
13:37:30 <mitchellsalad> bifunc2: yeah
13:40:12 <bifunc2> mitchellsalad, do you know how to convert a    Stream (Of a) (Stream (Of b) m) m ()    into a    Stream (Of (a, b)) m ()   ?  (In the second stream, the a's would tend to repeat as the underlying b's appear.)
13:40:55 <ahri> geekosaur: https://gist.github.com/ahri/320c0420665c3afcc0108ed6a6abf4a5 is the code and the error - sorry it's probably really trivial, I just don't understand yet how the various bytestring bits link up, and the internal aspect is weird to me
13:43:11 <bifunc2> The only way I see is to use    unseparate, sumToEither, and groupBy.   But it seems too contrived. There has got to be a more simpler way of accomplishing this seemingly common task.
13:47:51 <teeAyy> howdy, i have a type along the lines of `data A = B Integer | C Integer`. IS there  a way i can have a function only accept B's? say `Foo :: B -> String` or something?
13:49:19 <mitchellsalad> bifunc2: Hm, not sure
13:50:07 <mitchellsalad> Perhaps the `MMonad` instance would help
13:51:29 * hackage tasty 1.2.1 - Modern and extensible testing framework  https://hackage.haskell.org/package/tasty-1.2.1 (RomanCheplyaka)
13:53:53 <Solonarv> teeAyy: no, just like you can't have a function which (for example) accepts only even integers
13:54:01 <Solonarv> you will need a separate type
13:56:07 <teeAyy> gotcha, chur
14:05:21 <wroathe> Is it possible to define instances in parts? Say if I have a minimal complete definition that I want to define, and then in another module add further definitions?
14:15:29 * hackage hw-json 1.0.0.0 - Memory efficient JSON parser  https://hackage.haskell.org/package/hw-json-1.0.0.0 (haskellworks)
14:15:55 <geekosaur> wroathe, no
14:16:11 <geekosaur> ahri, sorry, pulled off to dinner. I see code but no error there
14:38:14 <ahri> geekosaur the error is in a comment on the main bit :)
14:38:55 <ahri> you're perfectly welcome to eat ;) I'm about to sleep so may not respond
14:46:52 <ahri> I guess I should be using html-blaze or similar anyway so it may not be a big issue - just an interesting one for me as I feel like I've run into this before and not really understood any solutions very well
14:51:47 <geekosaur> I did not see any comment containing an error
14:56:00 * hackage cubicbezier 0.6.0.6 - Efficient manipulating of 2D cubic bezier curves.  https://hackage.haskell.org/package/cubicbezier-0.6.0.6 (KristofBastiaensen)
16:49:20 <aplainzetakind> I have a type I defined an Ord instance for, (and derived Eq). While chasing a bug I realized that for some pairs of values x y, I get True for x < y, False for x == y, but x <= y hangs. What could cause this?
16:52:33 <Solonarv> what's the Ord instance look like?
16:54:32 <aplainzetakind> This is the gist of it: https://paste.pound-python.org/show/9NFMdQVUjVjpknwpPsFn/
16:55:17 <aplainzetakind> Actually it's PitchClass that misbehaves. Checking only the Accidental component also works.
16:56:06 <hpc> what is Down? also is it intentional that 'a' and 'b' are reversed in the last case?
16:56:09 <MarcelineVQ> "but x <= y hangs." specifically what are the x and y you tried?
16:56:26 <Solonarv> hpc: Down is from Data.Ord
16:56:43 <hpc> ah
16:56:44 <aplainzetakind> Specifically, PitchClass C (Flat One) <= PitchClass C Natural hangs. `compare`ing the two gives LT. It's odd.
16:56:47 <Solonarv> instance Ord a => Ord (Down a) where compare (Down x) (Down y) = compare y x
16:57:13 <Solonarv> aplainzetakind: what about Flat One <= Natural?
16:57:33 <aplainzetakind> True
16:57:39 <aplainzetakind> It's pretty strange.
16:58:05 * geekosaur wonders if this is checking MINIMAL pragmas
16:58:10 <Maxdamantus> The minimal definition of `Ord` is either `compare` or `<=`
16:58:27 <Solonarv> well, I'm pretty sure the last line of your 'compare' definition is the culprit
16:58:38 <Maxdamantus> so either you haven't defined one of those, or there's a bug in the definition of it.
16:58:38 <geekosaur> ...yes
16:58:53 <geekosaur> because that unwwraps the types and invokes compare again
16:58:55 <Solonarv> I'm also pretty sure that the derived Ord Accidental instance would do what you want here
16:59:27 <Solonarv> compare a b = comparing Down b a = compare (Down b) (Down a) = compare a b -- that's a loop!
16:59:28 <hpc> not quite, there's some parameter reversals
16:59:33 <aplainzetakind> Solonarv: I want Flat (S One) to be smaller than Flat One.
16:59:43 <hpc> flats compare backwards
16:59:48 <Solonarv> oh I missed that
16:59:50 <geekosaur> hpc, which are irrelevant since it just reruns that loop again swapping them around again
17:00:04 <geekosaur> oh, you mean the derived one
17:00:11 <geekosaur> right, so this needs more thought
17:00:31 <Solonarv> tbh I'd just replace Accidental with a newtype around Integer
17:00:40 <Solonarv> since it's isomorphic anyway, and has the ordering you want
17:02:05 <hpc> aplainzetakind: fwiw, it works for me
17:02:19 <hpc> PitchClass C (Flat One) <= PitchClass C Natural -- is True, with your paste
17:02:57 <aplainzetakind> hpc: Well, what could interfere with this?
17:02:59 <hpc> you're probably not testing the code you're looking at
17:03:18 <hpc> try putting "lakjsdhlkjahsdlkjashdlkjhasdlkjhaslkdjhalskjdh" in the middle of the file and see if it still works
17:04:39 <hpc> or if you're in ghci/vim or similar, save the file and then :r
17:04:52 <aplainzetakind> hpc: It doesn't, I'm pretty sure I'm dealing with the correct file.
17:05:03 <hpc> hmm
17:06:22 <MarcelineVQ> PitchClass C (Flat One) <= PitchClass C Natural hangs here
17:07:00 <hpc> whaaaaaat?
17:07:05 <hpc> i'll just mail you my laptop then lol
17:07:17 <aplainzetakind> Could the ghc versions be relevant?
17:07:43 <hpc> unlikely, but fwiw 8.0.2
17:07:50 <aplainzetakind> 8.6.3
17:08:38 <hpc> when it gets to comparing (Flat One) with Natural, it should hit the case on line 10
17:09:01 <hpc> maybe the derivation changed or something
17:09:03 <MarcelineVQ> time to look at the deriving core for PitchClass I guess
17:09:08 <Solonarv> aplainzetakind: does this alternate representation still fail? https://gist.github.com/Solonarv/80cdeb1cbae4b43886d48505cccf06b9
17:09:26 <hpc> or the instance for Down changed
17:09:59 <hpc> try writing the last case explicitly
17:10:14 <hpc> Natural (Flat _) = GT; Natural (Sharp _) = LT
17:11:35 <hpc> Solonarv: i can imagine comparing Down b a = compare b a, then negate the Ordering
17:11:38 <hpc> which wouldn't loop
17:11:43 <hpc> but yours would definitely loop
17:11:50 <hpc> that might be the difference here
17:12:28 <aplainzetakind> > comparing Down 3 5
17:12:31 <lambdabot>  GT
17:17:20 <aplainzetakind> Solonarv: I'm removing the old Accidental to try yours, right?
17:17:39 <aplainzetakind> So the Accidental constructors in your paste should be MkAccidental?
17:18:51 <benzrf> > (compare `on` Down) 3 5
17:18:53 <lambdabot>  GT
17:18:57 <benzrf> :t comparing
17:18:58 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
17:19:37 <benzrf> comparing f = compare `on` f?
17:20:32 <Solonarv> aplainzetakind: er, yes, or just rename the constructor to Accidental
17:20:42 <Solonarv> benzrf: indeed
17:22:46 <aplainzetakind> Solonarv: I'm also getting some type errors, and since I'm not familiar with this pattern machinery I'm not sure how to fix them.
17:23:35 <Solonarv> aplainzetakind: post the errors as a comment on my gist, then I'll fix it
17:23:37 <MarcelineVQ> oh, okay. core is saying that x <= y is not (y < x) so we don't get the compare (Flat _) _ = LT case first when phrase as PitchClass
17:26:24 <aplainzetakind> `compare (PitchClass C (Flat One)) (PitchClass C Natural)` this nicely gives LT
17:26:41 <MarcelineVQ> That is to say that given PitchClass C (Flat One) <= PitchClass C Natural we check if Letter are <=, if they're EQ, we check if Accidental are <=, but the default x <= y is not (y < x), so when faced with PitchClass C (Flat One) <= PitchClass C Natural we are checking not (Natural <= Flat One) which is the infinite case of line 14.
17:30:25 <MarcelineVQ> oop, last part is mistyped: we are checking not (Natural < Flat One) which is the infinite case of line 14.
17:30:46 <MarcelineVQ> As < uses compare.
17:31:37 <MarcelineVQ> Is there not a hackage link to the default defintions for Ord? Can't see them, can't recall seeing them last time I looked as well.
17:32:16 <Solonarv> should just be the source code for Ord
17:32:18 <aplainzetakind> Indeed replacing comparing Down with a function that flips Orderings removed the issue.
17:32:55 <aplainzetakind> There's no link to the source of Ord on hackage, none I could find.
17:32:56 <MarcelineVQ> Solonarv: there's not a source link for Ord though, that I can find
17:33:18 <Solonarv> huh, you're right
17:39:06 <Solonarv> ah - Ord is actually defined in ghc-prim, not in base!
17:39:22 <MarcelineVQ> you monsters.
17:40:06 <Solonarv> https://hackage.haskell.org/package/ghc-prim-0.5.3/docs/src/GHC.Classes.html#Ord
17:42:42 <Solonarv> I guess it makes sense for Ord to be wired in deeply, since GHC needs to write derived instances for it?
17:43:01 <MarcelineVQ> you monsters.
18:37:25 <inkbottle> Weird: intero using 100%cpu 30%mem, minutes after emacs were closed; resisted to killall intero; but happily not to kill -9
18:39:25 <maerwald> You can't close emacs
18:42:42 <inkbottle> Like: Thou shall not kill emacs?
19:04:52 <DigitalKiwi> https://www.reddit.com/r/gaming/comments/alt6fp/computer_is_not_responding_oc/ this but emacs?
20:22:30 * hackage scrapbook 0.3.2 -   https://hackage.haskell.org/package/scrapbook-0.3.2 (matsubara0507)
20:33:29 * hackage scrapbook 0.3.3 - Automatically derive Kotlin class to query servant webservices  https://hackage.haskell.org/package/scrapbook-0.3.3 (matsubara0507)
20:54:23 <emmanuel_erc> Hello there.
20:59:50 <emmanuel_erc> Has anyone here ever worked with Serial instances before?
21:00:29 <emmanuel_erc> I am trying to write an instance where one of the underlying types has the shape [(f (g x),g x)].
21:02:10 <emmanuel_erc> It is seeming rather strange to do
21:02:19 <emmanuel_erc> s/strange/difficult/
21:49:37 <glguy> emmanuel_erc: What's the challenge?
22:08:31 <emmanuel_erc> hello there glguy
22:08:54 <emmanuel_erc> I'm wracking my brain trying to figure out how to write a Serial1 instance
22:09:02 <emmanuel_erc> well actually a particular part of it
22:11:00 * hackage hw-json 1.0.0.1 - Memory efficient JSON parser  https://hackage.haskell.org/package/hw-json-1.0.0.1 (haskellworks)
22:13:28 <emmanuel_erc> I'll just repeat my question again here: I am trying to write an Serial1 instance where one of the underlying types has the shape [(f (g x),g x)]
22:17:23 <jchia> megaparsec question: Is there a general way to convert a parser that takes Text input to one that takes ByteString input applying Latin1 encoding?
22:19:27 <glguy> emmanuel_erc: I think you'll get more help asking a specific question
22:33:22 <emmanuel_erc> glguy: There is business code that I'm protecting so I have to be a bit vague.
23:10:48 <glguy> Then you'll have to create a cleaned up example of the thing you don't understand
23:12:58 <ddk> Hello all! have a nice friday.
23:14:25 <ddk> I have doubt about the function `rollbackTo` defined in module Log.hs of `acid-state` library, would someone would like to help, actually I was implementing more tests for the library
23:24:59 * hackage mmtf 0.1.2.0 - Macromolecular Transmission Format implementation  https://hackage.haskell.org/package/mmtf-0.1.2.0 (zmactep)
23:34:15 <ddk> I have doubt about the function `rollbackTo` defined in module Log.hs of `acid-state` library, would someone would like to help, actually I was implementing more tests for the library
23:46:19 <Ariakenom> ddk: I don't think I can help, but I am interested in what doubts it raises.
