00:38:39 <oo_miguel> fromRational (1%3) :: Double obviously just shows very few first places of this fraction. How can I increase this to arbitrary precision? ...sorry I keep forgetting how the type conversions work.
00:39:49 <koz_> Does GHC even have a built-in BigDecimal or something equivalent?
00:40:05 <nyc> It would need an arbitrary precision library.
00:40:12 <oo_miguel> koz_:  "Integer" can be of arbitrary length right?
00:40:22 <sternmull> yes
00:40:36 <koz_> oo_miguel: Yeah, but that's _not_ a BigDecimal - that's a BigInteger.
00:40:36 <oo_miguel> so can a Ration represented by two Integers
00:40:50 <koz_> oo_miguel: Oh, you want Rational.
00:41:03 <koz_> Then why are you converting to Double?
00:41:15 <oo_miguel> koz_: hmm, just wanted to SEE it 
00:41:44 <koz_> oo_miguel: I don't understand. Did Rational lose its Show instance when I wasn't looking?
00:42:23 * hackage jwt 0.9.0 - JSON Web Token (JWT) decoding and encoding  http://hackage.haskell.org/package/jwt-0.9.0 (puffnfresh)
00:42:50 <oo_miguel> koz_: heh. It is shown as a ratio only right?
00:42:52 <nyc> I thought oo_miguel wanted an arbitrary-precision floating point type.
00:43:26 <oo_miguel> I have a number represented as a ratio and want to write it out with a point.
00:43:57 <koz_> nyc: That was my impression too.
00:44:27 <koz_> But now I'm confused.
00:45:22 <oo_miguel> sorry for the confusion. I can probably just transfrom the rational representation for my needs.
00:45:48 <oo_miguel> to a denominator of the form 10^something
00:53:23 <oo_miguel> hmm I still don't manage to accomplish it. maybe I try to rephrase my question.
00:54:41 <oo_miguel> let's say given a numerator and denominator I want to find the 100000000th digit of the fraction
00:55:52 <butterthebuddha> Is there a version of getArgs of type IO [Text]?
00:56:30 <jle`> butterthebuddha: `map T.pack <$> getArgs` ?
00:57:42 <butterthebuddha> I don't want to manually convert "String"s to "Text"s because that seems inefficient
00:58:06 <koz_> butterthebuddha: There are, but they basically work about the same way anyway.
00:58:57 <MarcelineVQ> there's not (or shouldn't be) a lot going on with straight up cli args, if efficiency is bottlenecking there it's time to change tactics
00:59:34 <koz_> That, and lists are lazy, so if you have a billion items but only ever use 3, GHC will only convert those 3.
00:59:45 <butterthebuddha> It shouldn't be a bottleneck but it seems wasteful
00:59:47 <jle`> butterthebuddha: try benchmarking if you think it'll matter :)
01:00:12 <jle`> if you feel like it's wasteful, it's good to quantify just how much you are wasting
01:00:22 * koz_ mumbles something about premature optimization and roots of all evil.
01:01:12 <butterthebuddha> koz_: you're right, but this feels like "premature pessimization" as a professor of mine used to say
01:01:36 <butterthebuddha> I suppose I don't care enough about it to spend more than 2 minutes looking for a solution, so I'll move on to more important things
01:01:37 <butterthebuddha> thanks!
01:01:42 <maerwald> if you don't know what you want, you'll end up solving hard problems for someone else, but not your own :)
01:01:51 <koz_> maerwald: Well spoken.
01:01:53 <koz_> (typed?)
01:02:36 <MarcelineVQ> premature generalization might be even worse, or not, I'd have to ask around
01:03:23 <MarcelineVQ> "I know I'm generic, but am I generic enough?"
01:03:37 <cocreature> as long as the hard problems you do end up solving are mine, I’m fine with that
01:04:41 <koz_> MarcelineVQ: Ultimate generic function type: [Dynamic] -> [Dynamic]
01:05:29 <cocreature> koz_: you don’t even need a list of Dynamic, just use a single Dynamic and it can be a list
01:05:36 <koz_> cocreature: Point taken.
01:05:46 <koz_> Or a tuple.
01:05:46 <cocreature> and at that point, why are you even using a function, just use Dynamic
01:05:49 <koz_> Or a list of tuples.
01:05:52 <koz_> Lol.
01:05:57 <koz_> So confirmed: Dynamic is most generic type.
01:06:02 <cocreature> Dynamic, the only type you will ever need
01:06:47 <MarcelineVQ> :k Dynamic
01:06:49 <lambdabot> *
01:08:51 <oo_miguel> koz_: nyc: thank you. Just found a solution that produces the ouptut I was looking for (using Data.Number.CReal): "hooray r = showCReal 1000 $ fromRational r"
02:01:38 <jollygood2> hi
02:01:51 <jollygood2> what is your goto way of handling errors when Maybe is not descriptive enough?
02:02:16 <lyxia> Either
02:02:19 <jollygood2> Either String? Either SomeError? EitherT? exceptions?
02:02:28 <merijn> jollygood2: Library or executable?
02:02:45 <jollygood2> merijn, I'm interesting in both cases
02:02:49 <jollygood2> interested
02:03:15 <merijn> jollygood2: Also, do you plan to recover from the error?
02:03:40 <merijn> jollygood2: If I'm writing an executable and don't plan to handle the error, I just define a new exception type and throwIO it to bail
02:03:59 <jollygood2> and catch in main? or just let it quit the program
02:03:59 --- mode: glguy set +v oao
02:04:16 <merijn> jollygood2: For my own stuff I just let it crash out of main
02:04:26 <Rembane> I'm a big fan of error and letting the program crash. 
02:04:33 <Rembane> Especially for errors that shouldn't occur
02:04:46 <merijn> jollygood2: I'm a firm believer that libraries should prefer Either based APIs allowing library users to handle errors themselves
02:04:52 <jollygood2> merijn what if you want to handle error?
02:05:07 <merijn> Rembane: I prefer throwIO over error, more reliably triggered
02:05:35 <Rembane> merijn: Interesting, why is it more reliably triggered?
02:05:36 <merijn> jollygood2: Errors in pure code I handle via Maybe/Either if I plan to handle them. What type I use in Either depends on what I need to recover
02:05:57 <merijn> Rembane: error is only raised when the expression containing it is evaluated, allowing it to escape catch/handle
02:06:09 <merijn> Rembane: throwIO guarantees exceptions don't escape handlers
02:06:47 <Rembane> merijn: Oh. Subtle and very Haskelly. Then I guess it's time for me to sed s/error/throwIO/
02:06:51 <merijn> jollygood2: If I'm writing IO based code and don't plan to directly handle the error (i.e. I have a main loop and errors mean "cleanup and start/retry the next loop"
02:06:59 <cocreature> Rembane: that’s often not going to typecheck :)
02:07:38 <merijn> Yeah, you can't avoid all uses of error without lots of work, but where possible throwIO should be preferred
02:08:08 <merijn> Although error has the advantage of just needing a string and throwIO means having to define an exception type
02:08:55 <cocreature> merijn: fail in IO is a throwIO :)
02:08:58 <jollygood2> merijn, do you often return IO (Either ...)? 
02:09:20 <merijn> jollygood2: It Depends (TM)
02:09:51 <merijn> jollygood2: Often I use exceptions with handlers way up in the logic (like a main loop) or some other error handling mechanism
02:10:55 <Rembane> cocreature: That's a part of the plan. Then I can use the typechecker to help me sort out the mess I create. :)
02:10:56 <merijn> jollygood2: Lots of "IO (Either ...)" things are basically "it worked or I give up" scenarios
02:11:31 <merijn> jollygood2: I think libraries should return Either (because tracking which exceptions are possible is a mess in Haskell), but for writing code I often prefer exceptions
02:12:36 <jollygood2> merijn I returned Either from IO from multiple functions, took a lot of care to propagate it, and then my program crashed when readFile threw "File does not exist" exception. so I felt kind of stupid going through all that work, and wondered if it would be better to just throw exceptions instead of returning Either.
02:13:21 <jollygood2> that way I'm handling all the errors in one place, instead of two places
02:13:23 <merijn> jollygood2: Like I said, if you plan to handle the error *immediately* Either is better. But stuff like "file unexpectedly doesn't exist" generally you don't really handle right away
02:13:45 <merijn> jollygood2: That can certainly be useful
02:14:35 <merijn> Some of my libraries I just have two modules, one returning Maybe/Either from IO and the other throwing exceptions, so people can "opt-in" to the throwing API if they prefer
02:17:30 <oao> i'm having a problem which seems to indicate that i don't understand the variable scoping rules. in the final line in this gist, the i' term is not in scope and i don't understand why. any clues would be appreciated! https://gist.github.com/unprolix/6484a20141d9d3cc942947d7e4620bd7 (the code in the example is nonsense example code but comes from something non-nonsense i was working on)
02:18:03 <jollygood2> what is your thoughts of using MonadThrow/MonadCatch to write a function that returns Maybe or Either if used in that context, or throw exceptions if used in IO context?
02:18:10 <jollygood2> are
02:19:00 <dmwit> oao: The `where` is associated with the definition `go i = ...`. No variables created in `...` are in scope, only `i` and whatever is in enclosing scopes.
02:19:44 <dmwit> oao: You could `go i = do { let { i' = i * 2; go' j = j + i' }; fmap go' [0..i+2] }` if you wanted.
02:19:58 <cocreature> jollygood2: imho MonadThrow for Either and Maybe shouldn’t exist. those instances are just as silly as the MonadError instance for IO
02:20:12 <oao> thank you, thinking...
02:20:25 <dmwit> oao: ...but I'd probably just write `go i = fmap (\j -> j + i*2) [0..i+2]`. =P
02:21:03 <oao> i've simplified the code from what i was actually working on, which is annoying numerical stuff
02:21:04 <oao> ;)
02:21:41 <dmwit> Or even `go i = [i*2 .. i*2+i+2]`.
02:22:31 <oao> i don't think i understand what the issue is with the `where`s yet
02:22:43 <jollygood2> cocreature, can you expand on that a bit? I thought it was interesting that we can use one function definition, and handle errors from that function in several different ways
02:23:31 <merijn> oao: That layout is super confusing in terms of how things are grouped
02:23:35 <oao> the second `where` defines go' which uses i', which looks like it should be in scope since it is defined inside the function definition body of the `go`
02:24:10 <dmwit> oao: Imagine for a moment that you had written this instead: `go i = do { i' <- someAction; fmap go' [0..i+2] } where ...`. Would you still expect `i'` to be in scope in `...`?
02:24:27 <merijn> oao: "where" blocks attach to definitions, they can't be in arbitrary places
02:24:55 <dmwit> oao: What about in `go i = do { i' <- [3,4,5]; fmap go' [0..i+2] } where ...`? If you expect `i'` to be in scope in `...`, do you expect it to have the value `3`, `4`, or `5`?
02:24:57 <merijn> oao: The let is only in scope *inside* the do block of "go"
02:25:08 <cocreature> jollygood2: as merijn already mentioned, Either-style error handling and exceptions are good for different things. Either is great when you want to be very explicit and handle the error somewhat locally. Exceptions are mostly for errors that should propagate up or even crash your program (because there is no reasonable way to continue). So given that the usecases are pretty different I don’t think you gain
02:25:11 <cocreature> anything by trying to abstract over them using MonadThrow
02:25:36 <merijn> oao: The where binding for go' is attached to "go". The contents of the do block of "go" are not in scope for the where block of "go"
02:25:47 <cocreature> jollygood2: if I use MonadThrow with Either I end up with a SomeException value that you can’t really do much with
02:25:52 <oao> this is making sense but my brain is being slow! ;)
02:26:34 <merijn> oao: The problem is that "let" inside do is just syntactic sugar for "let i = .. in .." (where i is only in scope in the second ...)
02:27:09 <oao> right, but isn't the go' definition taking place inside that context?
02:27:22 <merijn> oao: Whereas go' attaches to "go" and thus has the following in scope: All of the arguments to "go", all other values in the "where" block and all values in higher scopes
02:27:45 <merijn> oao: No, the "where" ends the do block, but due to your layout it (confusingly) doesn't look like it does that
02:28:05 <oao> aha
02:28:33 <merijn> oao: That parses as "do { let i' = i*2; fmap go' [0..i+2] } where { ... }"
02:28:41 <jollygood2> cocreature, what do you use in Either for errors? I see Either String used commonly to handle errors, and SomeException can do more than String
02:29:09 <merijn> oao: See also this very good wikibook chapter on how exactly do notation desugars: https://en.wikibooks.org/wiki/Haskell/do_notation
02:29:28 <oao> thank you both, this is very helpful! sounds like my next step is to convert syntax to {} and pound that into my head
02:29:32 <merijn> Wait...that's not that one I wanted >.>
02:29:37 <cocreature> jollygood2: usually I make some sumtype to represent the different errors
02:30:23 <merijn> oao: This one I meant: https://en.wikibooks.org/wiki/Haskell/Indentation
02:30:30 <maerwald> merijn: "error is only raised when the expression containing it is evaluated, allowing it to escape catch/handle" what do you mean by that? If the expression is not evaluated, then it's not an error?
02:30:46 <oao> thanks! i will scrutinize. much appreciated!
02:31:01 <cocreature> > fst ((), error "foobar")
02:31:03 <lambdabot>  ()
02:31:05 <cocreature> ^ maerwald 
02:31:08 <merijn> oao: Specifically, the 4th rule of the algorithm in this case "If you see something unexpected in a list, like where, insert a closing brace before instead of a semicolon."
02:31:42 <maerwald> cocreature: yeah, so there is no error
02:31:44 <merijn> oao: Incidentally, this is why I personally use (and would recommend) where to always go on a new line and indented slightly less than the preceding block
02:31:55 <maerwald> why would you use throwIO instead there
02:31:58 <merijn> maerwald: I mean that: error "foo" `catch` myHandler
02:32:13 <merijn> maerwald: Most people assume "catch" will catch that exception
02:32:30 <cocreature> maerwald: the problem is not that the error doesn’t arise if the expression is never evaluated. the problem is that it often blows up at a completely different point than where it was produced
02:32:35 <merijn> maerwald: But it won't, because will return before 'error "foo"' is evaluated (and thus the exception isn't raised)
02:33:13 <merijn> maerwald: So using error "leaks" errors outside of the handlers you installed to (potentially) handle them
02:33:28 <oao> merijn: can you show me an example of how you might indent the example (or some other code?)
02:34:11 <oao> oh now i think i see what's going on!
02:34:12 <merijn> oao: Lots of code (with many levels of nesting in where): https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/model-src/Evaluate.hs
02:34:49 <oao> i was trying to attach the second where to the second fmap, but it can't go there
02:35:46 <oao> tusen takk !
02:36:12 <merijn> oao: With my indent style your code would end up like: https://paste.pound-python.org/show/07wyGgaDR9rSOirifZWp/
02:36:30 <merijn> oao: Although I would probably not write it like that because of how short the definitions are
02:37:14 <oao> thank you! yeah, this code is my minimal-ish example of a much longer, much worse bit of numerical code which would have been confusing for no extra reason i think
02:38:14 <merijn> oao: Right, neither fmap's are bindings/definitions, so neither can have a where attached to them
02:38:49 <merijn> oao: Although you could trivially move the let into where too
02:39:04 <merijn> oao: Since the let doesn't actually use anything that's only in the do block in your example
02:39:09 <jollygood2> cocreature, I sometimes find myself wanting to handle all errors right away. for example, when I was busy handling Either in a loop that shouldn't quit, I completely forgot that readFile can throw exception. I think that argument that IO (Either MyError Data) gives false sense of security is pretty valid. also, if I kept my return type the same, it means I'd have to handle two different type of errors, in a different way, in th
02:39:49 <merijn> oao: Generally I *only* use let when dealing with values derived from earlier monadic binds, like here: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/model-src/Evaluate.hs#L266-L271
02:40:47 <merijn> oao: Because any bindings that don't use monadic results can always be moved into where blocks (which I find much nicer to read)
02:42:25 <oao> i've got a lot to learn about this and i appreciate your help, thank you!
02:42:27 <cocreature> jollygood2: I still don’t see how using MonadThrow for Maybe would help here
02:42:32 <cocreature> (or Either)
02:43:01 <cocreature> I’m not at all saying that you shouldn’t use Either or that you shouldn’t use Exceptions. I’m saying you shouldn’t use a typeclass intended for Exceptions (i.e. MonadThrow) for Either-style error handling
02:43:45 <merijn> ^^ agreed
02:43:53 <jollygood2> cocreature, because it allows caller to decide how to handle errors, and to easily compose them together. there's no boilerplate to turn Either into throwIO
02:44:01 <merijn> MonadThrow/MonadCatch are nice for transformers over IO
02:44:07 <maerwald> merijn: error "foo" `catch` (\(e :: SomeException) -> putStrLn "we catched it!") -- this works
02:45:09 <cocreature> jollygood2: but if I actually want Either-style error handling, MonadThrow is really inconvenient! All I get to know about your error is that it’s SomeException which would be anything at all. Whereas if you use MonadError you have a chance to introduce a proper error type and provide a lot more information to the user
02:45:22 <merijn> maerwald: Only through luck
02:45:48 <maerwald> Can you give an example where this is not the case?
02:45:55 <merijn> maerwald: I don't say it *always* escape, it *can* escape. Maybe this get compiled/optimised in a way that the evaluation doesn't happen later
02:46:14 <cocreature> (pure (error "foo")) `catch` …)
02:48:17 <jollygood2> cocreature, you're right, your custom error type can contain more information than SomeException. but it does that at the expense of composability. you can't easily compose Either OneError and Either SomeOtherError
02:48:47 <cocreature> sure there are always tradeoffs
02:50:40 <maerwald> cocreature: right, so the error will e.g. happen sometime later when I force the value, escaping the handler
02:52:24 <marvin2> SomeException can be converted to MyException, which can contain all the information you need
02:53:15 <cocreature> marvin2: yeah but I don’t know that SomeException is MyException. if I have "Either MyException a", I know MyException is all the error could be. If I have "Either SomeException a" it would be anything and I need to handle that somehow
02:53:22 * hackage morphisms-objects 0.1.2 - Algebraic structures  http://hackage.haskell.org/package/morphisms-objects-0.1.2 (iokasimovmt)
02:55:34 <dminuoso> lyxia: So the book Thinking with Types is rather annoying to build yourself. But it's not really an issue, it's a sweet bonus - I do not mind buying decent books.
02:59:30 <marvin2> cocreature, you know if you catch MyError instead of SomeException
03:01:31 <dminuoso> marvin2: If you have `Either SomeException T` then you cannot know that it would throw MyError, since it could also throw *any* possible exception - making it an otherwise effect-free variant of IO.
03:01:59 <dminuoso> Forcing you to *always* catch other cases (or re-propagate `Either SomeException T` in which case you lose the information that it cannot be MyError outside)
03:02:54 <dminuoso> Wouldn't row types somewhat address this?
03:03:27 <dminuoso> Or mmm row types is for product types, isn't it? Is there an equivalent for sum types?
03:05:19 <cocreature> marvin2: but the MonadThrow instance forces you to use Either SomeException
03:05:46 <cocreature> dminuoso: they’re often called variants
03:05:52 <cocreature> or open sum types
03:12:41 <marvin2> dminuoso, you are not forced to catch other cases. caller can only attempt to catch MyError, and let other errors fall through
03:14:22 * hackage morphisms-functors 0.1.5 - Functors, theirs compositions and transformations  http://hackage.haskell.org/package/morphisms-functors-0.1.5 (iokasimovmt)
03:18:58 <dminuoso> marvin2: The information that MyError has been caught is lost though. If you just look at types, everyone has to still catch MyError because SomeError *could* be any error.
03:22:30 --- mode: glguy set +v captKirk
03:24:42 <captKirk> Hello everyone, I'm trying to use Scientific instead of Double for higher accuracies and avoiding floating point errors,
03:24:57 <captKirk> first of all, does it work? :/
03:26:02 <captKirk> The main problem I've encountered is its lack of "Floating" instance
03:26:39 <captKirk> therefore there are many basic functions I can't use (sin, cos, pi, ...)
03:30:00 <joncol> Hi, so I just created a simple record datatype which I made some lenses for, using `makeLenses`. The datatype is a record of 4 registers (Advent of Code problem). I'd like to access the registers using both named lenses (e.g. `view r1 regs`), but also it would be nice to support indexes: `view 0 regs`. Is this complicated to accomplish, or easy? How?
03:30:27 <cocreature> captKirk: that’s the price you pay for getting higher accuracy
03:31:23 * hackage terminal-progress-bar 0.4 - A simple progress bar in the terminal  http://hackage.haskell.org/package/terminal-progress-bar-0.4 (RoelVanDijk)
03:31:37 <c50a326> in the typeclassopedia it says that for Foldable you only need to implement foldr or foldMap... But foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m ... So m needs to be a Monoid... But I can't write like `instance Monoid a => Foldable (List a) where ...` because of the kind of Foldable, right?
03:33:30 <[exa]> c50a326: you probably want instance 'Foldable List' without the 'a' argument -- Foldable is for kind (*->*)
03:34:11 <[exa]> and you don't care about 'm' monoid, the function given to foldMap converts your 'a' to it
03:34:12 <c50a326> [exa]: yeah that's what I'm saying. So how can you implement foldMap?
03:34:25 <cocreature> c50a326: the thing you are making the foldable instance for is "t" not "m". so you don’t need a Monoid instance on "t a"
03:35:05 <lavalike> @compose djinn type foldMap
03:35:06 <[exa]> c50a326: ie. using the first foldMap argument you can just convert your list of whatever to a list of monoids
03:35:06 <lambdabot> Error: Class not found: Monoid
03:35:37 * [exa] discovers djinn
03:35:52 <c50a326> maybe my code is wrong for some other reason then: https://ptpb.pw/LkWO/hs
03:36:19 <cocreature> c50a326: you forgot "f" in the recursive call to "foldMap"
03:36:19 <c50a326> oh shit
03:36:23 <cocreature> also please show us the error
03:36:24 <c50a326> yeah I just saw it >.
03:37:34 <c50a326> now this though https://ptpb.pw/NuMO/hs
03:37:38 <captKirk> So is there any way for converting a Floating to a Fractional?
03:38:18 <captKirk> of course it means defining an orphan instance for Scientific...
03:40:32 <cocreature> if you want to use operations not supported by Scientific don’t use Scientific
03:41:44 <captKirk> so what would be the point of Scientific if I can't use a function like sin?
03:41:47 <cocreature> The reason why Scientific doesn’t support these operations isn’t that the authors were too lazy to add it. you can’t represent things like "pi" precisely in Scientific and choosing some arbitrary approximation goes against the whole idea of having a library for representing arbitrary precision decimals
03:41:52 * hackage morphisms 0.1.1 - It's all about functions  http://hackage.haskell.org/package/morphisms-0.1.1 (iokasimovmt)
03:41:55 <cocreature> writing code that doesn’t use sin?
03:42:59 <captKirk> alright, that makes sense
03:43:07 <captKirk> thanks
03:44:27 <captKirk> its authors could've added Enum though, right?
03:44:50 <captKirk>  instance Enum Scientific where      toEnum x   = fromIntegral x      fromEnum x = round x
04:04:35 <xenon-> what is a good example of usefulness of monad transformers? IO + logger transformer is usually given as an example, but I'm not sure what benefits it has over log :: FilePath -> String -> IO ()?
04:06:06 <xenon-> not sure if my message went through.. <xenon-> what is a good example of usefulness of monad transformers? IO + logger transformer is usually given as an example, but I'm not sure what benefits it has over log :: FilePath -> String -> IO ()?
04:07:18 <merijn> xenon-: Sure, if you only have one log level into one file that'd work
04:08:08 <merijn> xenon-: But, for example, the LoggingT transformer has many different log levels that can be externally changed/filtered/etc.
04:08:58 <merijn> xenon-: So I can replace the entire logging mechanism with one that logs to a socket, to multiple different files based on log severity, only logs things from certain files/location, etc.
04:09:18 <sproingie> ReaderT is pretty common in real world use too
04:09:34 <merijn> xenon-: The point is to separate the high level "log X with severity Y" from all the operational details of "what to do with those individual log events"
04:09:49 <merijn> sproingie: LoggingT is basically a newtype of ReaderT :p
04:10:37 <sproingie> plus some sugar
04:12:54 <xenon-> merijn, logToSocket, logToFile(s), logToStdout, and have the functions accept logger function. or a Logger data type, that contains even more control. what does MonadTransformer buy me over that? not having to pass the function/logger type around?
04:13:19 <royal_screwup21> I don't quite understand how this is valid code: data NatF r =
04:13:19 <royal_screwup21>     ZeroF
04:13:19 <royal_screwup21>   | SuccF r
04:13:20 <royal_screwup21>   deriving (Show, Functor)
04:13:34 <royal_screwup21> don't you have to define a functor instance of NatF??
04:13:36 <merijn> xenon-: Not passing the logging type around, yes
04:13:49 <merijn> royal_screwup21: GHC has -XDeriveFunctor :)
04:14:26 <xenon-> merijn ant it is worth it for just that? maybe I'm underestimating how complex  they are
04:14:34 <xenon-> err, overestimating
04:14:34 <royal_screwup21> merijn: but...how can it just assume the implementation of the fmap function??
04:14:56 <hpc> there's only one valid implementation here
04:14:59 <merijn> royal_screwup21: Because lawful functor implementations are unique :)
04:15:33 <merijn> xenon-: It depends on what kind of code you write
04:15:56 <merijn> xenon-: In applications there can often be very many levels between "main" and "places from where I want to log things"
04:16:20 <merijn> xenon-: Manually passing the logging function through 20 layers of functions just so I can use it there is very tedious
04:17:10 <royal_screwup21> what are these lawful functor? Not even sure what to google, would love a pointer or two in the right direction :)
04:17:41 <merijn> royal_screwup21: There are two functor laws: "fmap id = id" and "fmap f . fmap g = fmap (f . g)"
04:17:55 <sproingie> royal_screwup21: the "theorems for free" paper comes to mind.  not quite the easiest read though.
04:18:01 <merijn> royal_screwup21: There is only one possible implementation for each type that follows both those laws
04:18:28 <merijn> Yes, Wadler's "Theorems for Free!" would be relevant to answer *why* there is only one lawful functor
04:18:49 <sproingie> basically when you have a fully polymorphic type (i.e. has no constraints on the type variables) then there's often only one valid implementation
04:19:14 <merijn> royal_screwup21: I mean, nothing stops me from writing "instance Functor [] where fmap f l = []" that'd typecheck, but it doesn't obey the functor laws
04:19:29 <royal_screwup21> ^yeah, I was wondering the same thing about that
04:20:28 <xenon-> first functor law guarantees that, if functor is some type of datastructure, that the structure remains the same. I'm not quite sure what are implications of the second functor law?
04:21:13 <merijn> xenon-: Composing two fmaps is the same as one fmap with the two functions composed
04:21:26 <merijn> xenon-: If that (intuitively) seems redundant to you, you'd be right!
04:21:38 <xenon-> it does seem redundant
04:21:44 <lortabac> royal_screwup21: you can read https://wiki.haskell.org/Typeclassopedia for the laws of the most common type classes
04:21:55 <sproingie> how that second law guides implementation is probably the question
04:22:04 <merijn> xenon-: In Haskell (but not in category theory in general!) the 2nd law can be proved as "free theorem" using the first one :)
04:22:44 <merijn> xenon-: So in category theory the distinction between the two functor laws is relevant. In Haskell it's redundant as you can prove one from the other
04:24:18 <merijn> xenon-: As mentioned earlier, Wadler's "Theorems for Free!" papers talks about this kinda stuff if you're curious
04:25:59 <jollygood2> yes, its on my to-read list
04:37:48 <mouse07410> Newbie question. I've been told that stack uses cabal under the hood. I wonder if stack would be able to see/use packages/libraries installed by cabal, and vs. versa.  By analogy, regardless of how a library for installed on a Unix system (make, cmake, manual copy, whatever), once it is installed - every build system can see and use it. Is there something like that in Haskell ecosystem? This question isn't an idle one,
04:37:48 <mouse07410> because some 3rd-party libraries are provided with cabal build, and some - with stack build.
04:38:23 <merijn> mouse07410: Important pedantic note: stack uses Cabal under the hood, which is *not* the cabal executable
04:39:24 <mouse07410> Ok, it's good to know - but how does it matter in the context?
04:39:24 <merijn> mouse07410: Cabal is commonly used to refer to three things: 1) Cabal the package description format/spec, 2) Cabal the library for reading those specs (which stack uses), and 3) the command-line executable cabal (properly named cabal-install), which *also* uses Cabal the library
04:40:33 <merijn> mouse07410: stack/cabal don't really care/deal with "how is this build", package registration is done in GHC package database. Conceptually both should be able to use packages registered by the other, BUT
04:41:22 <merijn> mouse07410: The big "but" here is that they don't all use the same registry for querying packages, and if/when they do, the query might specify limitations on what part of the register is considered
04:42:16 <merijn> mouse07410: That said, since they both use the same package spec/format (Cabal) it's not really relevant what the original author builds packages with
04:43:09 <merijn> mouse07410: Both stack and cabal-install have methods for including packages from outside sources, so as long as they have a proper .cabal file you should be able to build with either
04:43:23 <mouse07410> Ah. Different registries. And there's no way to make them both to either see both, or to agree upon which one to use (that both can see/use)?
04:43:55 <merijn> mouse07410: Specifically, stack works around the concepts of snapshots. It has a fixed set of packages of a specific version that it will uses (depending on your stack config) and it will override/hide any other versions of those packages
04:44:36 <mouse07410> But I've seen packages that only have "<package>.yaml" file, without "<package>.cabal".
04:44:42 <merijn> mouse07410: cabal-install OTOH fetches all known versions of all known packages on Hackage and will try to dynamically compute a build-plan for them. Of course, since those packages and versions are constantly in flux it might fail sometimes
04:45:24 <merijn> mouse07410: package.yaml is actually not really stack specific. That's for "hpack" a tool that create .cabal files which stack will call for you if you only have a package.yaml
04:46:02 <mouse07410> Aha. Understanding increases. 👍
04:46:32 <merijn> mouse07410: I would personally recommend against hpack, for two reasons: 1) It adds a gratuitous and unnecessary layer on top of the Cabal spec that might not support all modern Cabal features, and 2) as you noticed/pointed out, lacking a .cabal file will make it unnecessarily tricky (at least for non-stack users) to compile/build/depend on your package
04:47:12 <merijn> mouse07410: If you only have a stack.yaml and .cabal file stack should be perfectly happy to work and any cabal-install users will just fall back to the plain .cabal file
04:48:11 <mouse07410> What about packages/libraries that are locally written (aka not available on Hackage)? How can I make those visible by both?
04:48:33 <merijn> mouse07410: As for "making both use the same registry", stack explicit goal is to *not* do that. Their entire goal is to provide a single fixed snapshot of version that work together for you to use. Diverging from that blessed snapshot runs counter to the goals of stack
04:49:52 <merijn> mouse07410: With the recent addition of new-build/v2-build in cabal-install you can use cabal.project files to depend on local/unreleased packages. I know stack.yaml has support for something similar, but I don't know how it works
04:50:31 <merijn> mouse07410: In both cases it's basically "tell the tool to also look for .cabal files in this directory"
04:50:47 <mouse07410> Oh. So stack will clog my machine with piles and piles of versions, probably including the GHC snapshots if I don't forbid it? That seems to steer me towards cabal
04:51:26 <Athas> Cabal might do the same, if you have different projects that have different versions of dependencies (although it will likely stick to the same GHC version, at least).
04:51:40 <Athas> That kind of sandboxing is the only sane way to do things.
04:52:06 <Athas> Although it is quite important to clean your ~/.stack from time to time!  Mine has grown to 17GiB it seems.
04:53:37 <merijn> mouse07410: The main difference is: Do you want (by default) have build plans figured out dynamically from the bleeding edge on Hackage and your dependency ranges (and occasionally run into issues with conflicting dependencies) or do you want to (by default) use a fixed/blessed set of packages that may or may not be the bleeding edge releases
04:54:04 <mouse07410> Athas: yes, in theory. No in practice, because dependencies are rarely survivor like specified correctly (aka "don't use those with changed ABI or API").
04:54:24 <mouse07410> merijn: definitely the first
04:54:40 <c50a326>  https://ptpb.pw/NuMO/hs what do? D:
04:54:46 <merijn> mouse07410: Right, so then you want cabal-install (but make sure to use new-build/v2-build)
04:55:04 <mouse07410> Athas: "survivor"->"specified"
04:55:28 <merijn> mouse07410: new-build primer: https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
04:56:20 <mouse07410> merijn: got it. But it looks like products of v1-install are visible by ghc-pkg, and those from v2-install aren't???
04:56:38 <the_2nd> storing licenses of used libs in a "dependencies" folder in the root of the program. Is that naming fine, or what name do you suggest?
04:57:20 <the_2nd> "licenses"  "used libs" ... ?
04:57:58 <Athas> c50a326: I think it is wrong to return 'Nil' in the 'Nil' case.
04:58:23 <c50a326> I've tried with mempty, mempty also
04:58:28 <merijn> mouse07410: There is a separate (invisible to v1) ghc-pkg database in ~/.cabal/store which holds all v2-install build products
04:58:29 <Athas> mempty should work.
04:58:44 <merijn> mouse07410: THis to avoid v2 stuff breaking the behaviour of v1-install :)
04:58:52 <royal_screwup21> is there a "deriving hash" in haskell? Not sure how you'd store custom data structures in hashmaps otherwise...
04:59:02 <c50a326> ohhh
04:59:14 <c50a326> I was trying:   foldMap f mempty = mempty
04:59:17 <c50a326> but it's:   foldMap f Nil = mempty
04:59:23 <c50a326> why is this? :s
04:59:30 <c50a326> I mean, shouldn't it _not_ matter?
04:59:44 <merijn> c50a326: mempty is a variable in the first one :)
04:59:44 <Athas> c50a326: look at the type of foldMap:
04:59:46 <Athas> :t foldMap
04:59:48 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
05:00:09 <c50a326> ah yes okay lol
05:00:30 <Athas> Here, the 't' is fixed (is is the List type you are defining the instance for), while 'a' and 'm' are free.
05:00:47 <Athas> I do think Haskell's treatment of type variables in type signatures is stupid and makes this more confusing than it ought to be...
05:01:13 <mouse07410>  merijn: is there a way to manage that v2 database, ideally with ghc-pkg? Because it's very nice to be able to tell what packages are installed and available, and ghc-pkg seems to provide exactly that (asking other services :)
05:01:36 <mouse07410> "asking"->"among@
05:02:05 <sproingie> mouse07410: it's managed with cabal.  the point is for them to not be installed globally
05:02:10 <__monty__> royal_screwup21: Do you mean for `Data.Map`? That doesn't hash. It's based on some form of balanced tree.
05:02:50 <mouse07410> sproingie: managed with what?
05:03:03 <sproingie> mouse07410: the "cabal" command, aka cabal-install
05:04:28 <sproingie> cabal sandboxing is like npm install without the -g, it doesn't actually install anything globally.
05:04:56 <mouse07410> sproingie: so, for v1 I use ghc-pkg, for V2 I'll need to figure the parameters to list packages via "cabal" executive, and stack keeps whatever it installs in yet another DB?
05:05:20 <sproingie> it does keep a cache locally, which is just an optimization behind the scenes.  cabal constructs the monster command line that exposes individual packages as needed.
05:05:21 <mouse07410> P.S. I've no idea what npm is
05:05:28 --- mode: glguy set +v threadache
05:06:05 <merijn> mouse07410: I'm not entirely sure how to ask cabal that info, but I've also never needded to :)
05:06:13 <merijn> mouse07410: What do you want that info for?
05:06:53 <threadache> Hello! I am working on a program that reads maybe 80 files and processes them. I would like to use forkIO to take advantage of however many cores the user happens to have.
05:06:59 <threadache> My worry is about context switches. In my case, fairness does not matter at all. I just need throughput.
05:07:10 <threadache> Is there any way to tell RTS to switch less often?
05:07:17 <phadej> koz_ Strong Endo indeed uses first - the one from Bifunctor
05:07:38 <threadache> (I have noticed that for single core machines, compiling without -theaded is actually faster. That's what got me thinking of this!)
05:08:44 <Athas> threadache: if the problem is IO bound, then I would not worry about the context switches.
05:09:28 <threadache> Well, I will be compiling each file, so that should be relatively costly as well.
05:09:53 <threadache> (I will be experimenting with mmap'ing in the future, but I haven't seen what impact that has yet.)
05:10:01 <mouse07410> For packages that aren't in Hackage it's nice to know if they are installed before doing a build. For disconnected machines (think "closed areas") it's helpful to know what is available now. Having "build failed" as the main/only indicator that one or more of the dependencies aren't available (or are off the wrong version) isn't my kind of dev fun.
05:10:48 <mouse07410> So it seems odd be better off with v1 commands.
05:11:08 <mouse07410> "odd"->"I'd"
05:11:45 <sproingie> if it's not on hackage, it's going to be in a separate dependencies section, either in stack.yaml or using whatever cabal is doing for external deps now
05:13:03 <threadache> Hey, I found it! It is -C
05:13:05 <threadache> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-concurrent.html
05:15:35 <threadache> Is that flag new? I swear I have been looking at all the RTS flags relevant to concurrency for a while, and I only recall seeing stuff about number of threads, heap size, etc.
05:15:52 <threadache> Also, does anyone have experience using -C?
05:16:25 <threadache> It says it is in seconds, and that the default is 20 milliseconds. How do you set fractional seconds? Just -C0.02 or something?
05:16:45 <sproingie> TIAS
05:17:05 <sproingie> looks to me like the -C option refers to context switches on a single core
05:17:19 <merijn> threadache: I guess?
05:17:26 <merijn> threadache: Maybe also ask in #ghc?
05:17:26 <sproingie> -N is about how many cores you use.  the default for that is "all of them"
05:17:34 <lyxia> -C20m    ?
05:17:43 <merijn> Also, if you run the threaded runtime you might wanna try disabling parallel GC
05:17:50 <merijn> I've had massive speed up from doing that
05:18:28 <threadache> merijn: when did parallel GC get turned on by default? I am using 8.4 at the moment.
05:18:30 <Athas> The parallel GC is quite bad.
05:18:54 <threadache> sproingie: why do you say that?
05:18:54 <merijn> threadache: It's default with -threaded always, I think?
05:19:18 <merijn> threadache: I'm using 8.4 so definitely in that version :p
05:19:36 <cocreature> +RTS -s should tell you whether it is enabled
05:19:49 <cocreature> but yeah I don’t remember it ever not being enabled in the recent past
05:19:52 <merijn> threadache: "+RTS -qg" disables it
05:20:13 <merijn> Or you can use -with-rtsopts to disable it at compile time
05:20:21 <merijn> threadache: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/benchmark-analysis.cabal#L74-L75
05:20:21 <kuribas> Is using a streaming library purely faster than using lists?
05:20:30 <kuribas> (for example streamly)?
05:20:50 <merijn> kuribas: Probably not? Depends on how you generate and use the list?
05:21:23 <threadache> cocreature: nice tip! merijn: thanks for the example!
05:21:23 <kuribas> merijn: streamly is written using CPS, I heared that it's easier to optimize...
05:21:23 <Ashjkaell> Hey all, I'm writing a small haskell terminal application to practice my IO, but the System.Console.ANSI doesn't seem to have 8 bit colors. Is there a variant that does ? (I don't want to use a more advanced module to do the work myself) 
05:21:28 <threadache> I'll experiment with it a bit.
05:21:31 <sproingie> threadache: i say it after reading the docs.  the context switches of Control.Concurrent have nothing to do with cpu contexts
05:21:48 <kuribas> merijn: or did I misunderstand that?
05:22:09 <merijn> kuribas: There's list fusion rules inside GHC that can optimise list functions a lot too
05:22:14 <merijn> kuribas: So...yes, no, maybe?
05:22:29 <threadache> sproingie: I am concerned with switching between two forkIO threads. I just would rather not have any switching really. Just go till each forkIO is done or blocked on an MVar.
05:22:31 <merijn> kuribas: Streaming pure lists isn't really what most streaming libs were designed for anyway
05:22:45 <kuribas> true
05:22:49 <merijn> kuribas: They were more designed for streaming IO operations
05:23:04 <kuribas> I should benchmark it...
05:23:13 <merijn> threadache: Limie the number of forkIO threads to capabilities?
05:23:26 <merijn> threadache: Although that might leave you under capacity, I suppose
05:24:27 <kuribas> merijn: if you have a list monad, but only take the first element, would it avoid intermediate lists?
05:24:34 <__monty__> Ashjkaell: Doesn't the SGR stuff give you access to all the possible colors?
05:25:18 <cocreature> kuribas: talking about optimizations in full generality isn’t really possible. there are way too many factors that can come into play here
05:25:28 <jackboy[m]> kuribas:
05:25:44 <kuribas> cocreature: Like using a list monad for a backtracking computation.
05:25:59 <kuribas> cocreature: it's really elegant, but is it efficient?
05:26:52 <cocreature> a dumb bruteforce search (which is essentially what the list monad gives you here) is rarely efficient :)
05:27:05 <threadache> merijn: I have found that getNumCapabilities misreports on some OSes
05:27:26 <threadache> merijn: specifically on CI servers like TravisCI, it will report 32 even though you only have access to 1 or 2
05:28:35 <threadache> I'll mess around with -qg and -C and see what happens
05:28:41 <threadache> Thanks for the recommendations everyone!
05:28:50 <merijn> threadache: getNumCapabilites reports the number of capabilities, not actualy cores
05:29:32 <merijn> threadache: You'd want getNumProcessors (which, admittedly might still misreport, since I think -N just uses that)
05:29:47 <Ashjkaell> __monty__: Hmm, the way I understood it the sgr stuff was for things like: bold, italic, etc.. I can always output the escape code myself though :-), I'll look into it, thanks !
05:29:56 <merijn> threadache: The only solution would be to correctly said the -N value yourself on Travis
05:30:06 <merijn> s/said/set
05:30:19 <threadache> I believe https://ghc.haskell.org/trac/ghc/ticket/14781 is the bug about TravisCI
05:30:47 <threadache> It appears that Rust has some more reliable mechanism for that.
05:31:08 <merijn> threadache: In the short term you can fix it by detect TRAVIS and overriding the number of cores to run with
05:31:32 <__monty__> Ashjkaell: I thought you wanted low-level?
05:31:56 <threadache> Wait, will getNumProcessors just give you the value of -N though?
05:32:21 <threadache> That may be a nice practical limit such that people can still override things with +RTS later on
05:32:42 <merijn> threadache: Capabilities corresponds to the number of capabilities aka OS threads the RTS runs with
05:32:51 <merijn> threadache: So getNumCapabilities just reports that
05:33:00 <kuribas> cocreature: it's fine in this case
05:33:23 <merijn> threadache: That number is determined either via 1) the value of the -N flag or 2) the number of processors if -N has no argument
05:33:52 <merijn> threadache: Presumably in case 2, getNumProcessors is what it uses to determine how many capabilities to spawn (so the real bug in that ticket is in getNumProcessors)
05:34:29 <royal_screwup21> why doesn't this work? https://thepasteb.in/p/vghO1AAlBjjc3 (I'm not even sure what to google :( )
05:34:38 <merijn> threadache: You can query and change the number of capabilities from the code if you want, so, for example have main check whether you're running in travis and adjust the number of capabilities down if yes
05:35:14 <cocreature> royal_screwup21: the error message is pretty clear no? you can’t make an instance for a type synonym by default
05:35:15 <royal_screwup21> specfically, I guess my question is, is it not possible to parameterize a class on a haskell type?
05:36:05 <threadache> That seems to be correct about getNumProcessors being the root issue.
05:36:13 <lyxia> is that not what all classes do royal_screwup21 
05:36:35 <merijn> threadache: You can check for running in travis like this: https://github.com/merijn/tasty-travis/blob/master/Test/Tasty/Travis.hs#L126
05:36:42 <threadache> So far having folks set -N themselves based on experimentation seems to be best. If we build it in, it tends to not work for someone or other.
05:37:39 <threadache> E.g. maybe it's fine on free Travis, but someone has a paid version that has more cores.
05:37:43 <cemerick> is there any way to define an alias for a group of type constraints?
05:38:06 <lortabac> cemerick: -XContraintKinds
05:40:02 <cemerick> lortabac: yes, thank you :-)
05:40:24 <merijn> threadache: Well, like I said, you can make it conditional, i.e. only downgrade the number of capabilities if you're running on travis :)
05:40:38 <threadache> I'll experiment. Thanks again!
05:41:22 --- mode: glguy set +v sneakyweasel[m]
05:56:04 --- mode: ChanServ set +o Sigyn
06:12:23 <exarkun1> Anyone have any pointers on filtering out certain content-types for response examples with Servant.Docs?
06:12:53 <exarkun1> I have an api that returns cbor or json.  cbor (binary data) examples don't really make sense in html output.
06:15:47 <cemerick> is there no way to generically access immutable and mutable vectors (the latter in ST)?
06:19:02 <kuribas> cocreature: I have an algorithm to find dates according to some spec, for example all saturdays in januari of every year, every second and fifth of each month, ...
06:19:25 <kuribas> cocreature: the algorithm is stateful, and I wanted to show how elegant it is with a list monad.
06:19:38 <kuribas> cocreature: it would be also nice to show performance.
06:20:25 <cocreature> kuribas: my point is, that you need to show us code and benchmarks. “are lists fast” is just not a question that has a meaningful answer
06:20:36 <kuribas> cocreature: right...
06:25:51 <lortabac> exarkun1: you can split the API type in two, for ex. type API = DocumentableAPI :<|> UndocumentableAPI
06:26:12 <exarkun1> lortabac: Ick :/
06:26:14 <lortabac> and then only generate the docs for the documentable part
06:29:13 <lortabac> exarkun1: otherwise you can define dummy instances for cbor, but I prefer the split API solution
06:30:50 <exarkun1> What kind of instances do you mean?
06:33:15 <lortabac> exarkun1: I don't know Servant.Docs well, I guess you need to define instances for ToCapture, ToParam etc.
06:36:07 <exarkun1> indeed
06:37:43 <exarkun1> I have ToSample instances that provide the values to include in the generated docs.  So far I haven't seen anything in that area that lets me introduce any kind of differing behavior based on content-type.
06:38:08 <exarkun1> maybe I need to do some reading between the lines
06:42:15 <lortabac> exarkun1: can't you do write a dummy ToSample instance for CBOR? Does it make sense?
06:42:22 <lortabac> *can't you write
06:42:36 <alp> exarkun1, (servant dev here) I've got to run but feel free to open an issue and explain your problem there if lortabac and you don't manage to figure it out. cheers
06:42:57 <exarkun1> alp: thanks
06:44:23 <exarkun1> lortabac: if so I don't understand how.  So far what I've done is write ToSample instances for a type that my API returns, independent of content-type.  Then Servant.Docs, I guess, takes care of visiting each supported  content type and encoding those samples for it.
06:47:00 <csaurus> Is it an antipattern if a record type starts to get many type parameters? I'm designing a type and as requirements change I've been adding type parameters where the behavior has to change. I'm up to 3 but am wondering if this will get unmanageable in the future/isn't a best practice
06:47:54 <csaurus> I've been doing type parameters since some differences are exclusive to a particular combination of them and it lets me declare up-front what is happening when I need to
06:52:45 <cocreature> csaurus: in general, adding type parameters is not an antipattern but it can be worth asking yourself if it wouldn’t be easier to make separate records if you find yourself trying to reconcile too many conflicting requirements by adding type parameters.
06:53:21 <csaurus> cocreature: Thanks! that was the alternative I was considering and think it might be the best option here
06:54:48 <csaurus> cocreature: Somewhat related, do you know of any guides to designing types? Not necessarily type level programming, but best practices? I see really basic guides explaining the syntax and then guides to more advanced topics/extensions but not much in between.
06:55:40 <merijn> csaurus: Honestly, not really. Mostly just lots of practice
06:56:09 <merijn> csaurus: Are you referring to when/how to introduce your own ADTs or more about how to structure functions?
06:56:49 <cocreature> yeah I don’t know any guides either
06:57:11 <csaurus> merijn: The former, I'm generally comfortable with when to introduce them but sometimes find myself fighting against the OOP mindset of piling functionality onto a single type
06:57:53 <csaurus> merijn: The most I've really found at the level I'm referring to is "encapsulation considered harmful" but it's pretty specific: https://lukepalmer.wordpress.com/2010/11/23/encapsulation-considered-harmful/
06:57:56 <merijn> csaurus: Honestly, 90% starts out like "everything in one type and lots of 5-tuples, etc." and then I iteratively refactor stuff into something more understandable as I crystallise what I *actually* want
06:59:15 <csaurus> merijn: I  that makes sense since refactoring is really pretty safe in Haskell, I'll have to try applying it
06:59:43 <merijn> csaurus: The trick with writing generic code (this also ties in somewhat with that blogpost) isn't to *start* trying to write code that generic. It's to start by writing something super-hacky and specific, then keep factoring bits out
07:00:12 --- mode: glguy set +v ob_
07:02:20 <csaurus> merijn: okay, I'm starting to see. Thanks! I think I'll go with a new type, it'll be pretty similar to the old one but simplifies things
07:02:35 <mpickering> When I compile my application with -threaded the profiling output completely changes, is this expected?
07:03:56 <mpickering> I am using lots of bytestrings so I suppose lots of unsafe foreign calls are happening?
07:06:18 <williamrusnack> Just geting started with lens and am trying to generalize my functions above their current collection type. For example how would take the function replicate from list and use a lense for that instead
07:07:28 <mpickering> williamrusnack: I don't think you would? 
07:09:33 <merijn> There's no way to write "export everything except X" in an export list, right?
07:09:41 <williamrusnack> mpickering: Thanks. Would it be more along the lines of just creating a list with replicate and then using fromlist? If so, is there a gernalized fromlist?
07:11:38 <mpickering> You want to generalise `replicate` in what manner? 
07:12:27 <cocreature> merijn: if you’re willing to add an extra module, you can have the first module reexport everything, then import it from the second module hiding some things and reexport the first module from the second
07:13:11 <merijn> cocreature: That adds a lot of unnecessary modules for me (like, 10-20 eventually)
07:13:45 <cocreature> merijn: I never said it was a great solution but afaik it is the only way to achieve this :)
07:14:04 <williamrusnack> It would be nice to have a `replicate` function that can produce [], Seq, Vector, … so that the functions that use `replicate` can just have constraints instead of a specific collection type
07:15:36 <glguy> You could make a type class for that, but it doesn't have much to do with lens
07:17:46 <cocreature> there’s probably something in mono-traversable but abstracting over collection types doesn’t really seem to pay off
07:18:07 <williamrusnack> @glguy ok thanks. That’s what I currently have. I have made a lot of typeclasses and have noticed a lot of overlap with lens so I’m trying to use lens where I can
07:18:07 <lambdabot> Unknown command, try @list
07:18:22 <Gurkenglas> williamrusnack, you mean replicate would produce anything that ix can index?
07:19:01 <williamrusnack> Gurkenglas: that would be nice
07:26:02 <bo> Guys, is there any tool or command in ghci to help detect non-exhaustiveness in function?
07:27:27 <merijn> bo: -Wall should warn about that
07:28:24 <marvin2> or, if you want to be specific, -Wincomplete-patterns
07:29:20 <cemerick> a question about the semantics of Data.Vector's unsafeFreeze/thaw, thanks in advance 😄 https://stackoverflow.com/questions/54041813/just-how-unsafe-are-data-vectors-unsafefreeze-unsafethaw
07:30:19 <merijn> cemerick: Yeah, the only way in which they're unsafe is mutating after freeze
07:31:14 <merijn> cemerick: Are you sure the safe version of freeze is too slow, though?
07:36:31 <cemerick> merijn: the big operations are bulk loads/updates of spatial data indices, so if I'm to use the existing (read-only) APIs in the course of updating, that's millions of freeze/thaw cycles over a set of large vectors. Unless there's some deeper magic than memcpy under the hood, you really can't get around impurity here
07:37:53 <merijn> cemerick: Can't you simply do all operations in one freeze/thaw cycle?
07:38:27 <merijn> cemerick: I'm not saying you shouldn't use mutable updates. I'm just wondering why you need to freeze/thaw so often that it's to expensive to do it "properly"
07:39:06 <merijn> "millions of freeze/thaw cycles" sounds to me like "I'm using freeze/thaw entirely inappropriately"
07:39:36 <cemerick> merijn: there's a whole query apparatus that is used in the course of determining which regions within the index need to be modified, for each entity to be added to the index
07:40:00 <merijn> cemerick: I mean, if you're mutating a lot, why not just keep them mutable?
07:40:32 <cemerick> merijn: well, I don't really want my entire program in ST. Aside from this bit, everything else is pure
07:41:52 <merijn> cemerick: So you're what? Interleaving updates and pure lookups a million times?
07:42:22 <cemerick> basically, yeah
07:43:01 <cemerick> only when updating the indexes though, which is quite rare
07:43:14 <merijn> I dunno, I'd just make them read the mutable vector directly and if you don't want ST everywhere, just use IO...
07:45:54 <cemerick> If the vectors are mutable, then the entire API has to be in ST. Going to IO doesn't clean that up?
07:47:33 <merijn> cemerick: Nice pure API, efficient, sane. Pick 1 :p
07:48:43 <cemerick> merijn: If you're right about unsafeFreeze, then I get all 3, lucky me 😈
07:48:57 <merijn> No, that's very much not sane :)
07:49:23 <cemerick> meh, the essence of internal mutability 😘 👌
07:50:53 * hackage quickcheck-state-machine 0.5.0 - Test monadic programs using state machine based models  http://hackage.haskell.org/package/quickcheck-state-machine-0.5.0 (stevana)
07:54:19 <Solonarv> That can be fine in a language with a fixed evaluation order, which Haskell isn't.
08:23:23 * hackage structured-cli 2.5.0.2 - Application library for building interactive console CLIs  http://hackage.haskell.org/package/structured-cli-2.5.0.2 (erick)
08:24:39 --- mode: glguy set +v recursion-ninja
08:25:17 <cemerick> merijn: FWIW, a contrasting assessment: https://stackoverflow.com/a/54042624/11809
08:25:35 <recursion-ninja> I tried to send an email to the [haskell-cafe] mailing list but I keep getting "Mail could not be delivered" messages from my email service provider. Anyone have any idea why my email isn't going through?
08:28:34 <geekosaur> not without any detail
08:28:55 <lyxia> do you need to be subscribed to the list?
08:30:20 <joncol> Trying to understand some more about lenses, and while reading this tutorial: https://artyom.me/lens-over-tea-1, I saw this `<-` syntax for the first time in this context of defining a function using guarrds. What's the significance/meaning/name of the `<-` in that example? https://gist.github.com/joncol/b0c8150ade7f7a1040169679b25b4088
08:31:13 <c_wraith> joncol: it's the PatternGuards extension
08:31:14 <Solonarv> joncol: that's a pattern guard
08:31:27 <joncol> Sweet! Thanks. I'll read up on it.
08:31:51 <c_wraith> joncol: it lets you do a pattern match (binding names) on an arbitrary expression in a guard
08:32:35 <Twey> I thought PatternGuards made it into Haskell 2010 or so
08:35:20 <geekosaur> yes
08:35:51 <Twey> So not an extension any more :)
08:36:28 <geekosaur> people keep getting thrown off because since when do extensions become part of the language?!
08:36:41 <geekosaur> I mean, the last one before that was the FFI
08:37:08 <Twey> Haha :(
08:38:05 <merijn> cemerick: The linked email address in that post refers to Array, not Vector
08:39:08 <wroathe> https://gist.github.com/JustinChristensen/f7dbd5f81442a3f760f3888524fb8eb7#file-tinyservant-hs-L83 This right here is where the magic of DataKinds/PolyKinds somewhat breaks down for me. What good is creating a type with a string if you can't eventually retrieve that string to do a runtime equality check or other thing?
08:39:19 <merijn> Clearly we need to patch c_wraith to fix his feedback :p
08:39:24 <wroathe> symbolVal seems like cheating :P
08:39:52 <merijn> geekosaur: Similarly, there's some fairly recent blog posts I saw that enable -XEmptyDataDecls for their code, which is almost a decade obsolete too
08:40:26 <cemerick> merijn: correct, but Vectors just wrap arrays, so it seems pretty relevant w.r.t. GC
08:40:27 <merijn> wroathe: *points to Idris* Dependent types are that way ;)
08:40:42 <merijn> cemerick: Array (as in Data.Array) is completely unrelated to Vector
08:40:51 <Twey> wroathe: But you never get to retrieve it anyway, you can just force the user to pass in the same string at runtime :þ
08:41:31 <merijn> cemerick: Anyway, maybe it's right and it's unsafe with Vector too
08:41:50 <c_wraith> Huh.  I missed that.  Only happened like 9 years ago, barely any time to notice it.
08:41:56 <wroathe> merijn: Are you trying to scare noobs away :P?
08:41:59 <geekosaur> someone hasn't quite figured that types are not values. and types don't exist at runtime
08:42:21 <merijn> wroathe: DataKinds is just kinda tedious in Haskell if you wanna safely type input from external sources
08:42:30 <cemerick> merijn: not Data.Array, Data.Primitive.Array...which bottoms out in GHC.Prim, which is where I'll stop tyvm :-)
08:43:05 <cemerick> I'll either open a ticket or hit the ML for further clarification
08:43:21 <cemerick> probably just going to plow ahead and see what falls out of hedgehog anyway
08:46:20 <wroathe> geekosaur: Well, you're right, but Proxy is a value, and whatever symbolVal returns in this case must be a value for me to do an equality check
08:46:30 <wroathe> geekosaur: That's what I meant, sorry for miswording it
08:47:01 <wroathe> to do a *runtime* equality check
08:51:17 <hyperisco> so here is how you specify various ways to fit one rectangle in another with CSS https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit
08:51:39 <hyperisco> is there a better algebra for this?
08:56:33 <hyperisco> I think maybe there could be a small expression language
08:57:32 <Rembane> hyperisco: Like the diagrams monoids?
08:57:42 <hyperisco> I am not familiar
08:58:02 <Rembane> There's a paper lets see... *internetz away*
08:58:21 <hyperisco> so there are four input variables and two output variables
08:58:56 <lyxia> wroathe: why did you say you can't retrieve that string, isn't that what symbolVal does?
08:59:45 <Rembane> hyperisco: This could be the one: https://repository.upenn.edu/cgi/viewcontent.cgi?article=1773&context=cis_papers
09:00:09 <wroathe> lyxia: No, I'm saying the opposite. I was trying to understand how PolyKinds/DataKinds impacted runtime. This whole time I was thinking "what good is this if all of the type information goes away after I compile"
09:00:19 <hyperisco> thanks I'll have a squiz
09:01:43 <tomsen> having a list of a, can i filter all a's that fulfill Show a ?
09:02:35 <lyxia> nope
09:02:52 <hyperisco> it is either all or none of them, tomsen
09:03:51 <int-e> . o O ( filterShow :: Show a => [a] -> [a]; filterShow = id )
09:04:13 <monochrom> You're probably thinking that "[a]" means the same list can containt different element types.  No.
09:04:15 <merijn> Suppose I have to define a list of IDs and monadic blocks associated with each other, what's the cleanest way to write that? Naming each individual block is a hassle if I can get away without that...
09:04:30 <int-e> That fullfills the letter of the specification, but it's a rather pointless function as can be seen from the definition.
09:05:35 <wroathe> It seems to me that after turning on DataKinds/PolyKinds I should be able to define a function like: sayHello :: "hello" -> IO (), where it takes a value of type "hello" (namely the value "hello") and prints hello, but (->) has kind TYPE q -> TYPE r -> *
09:05:54 <merijn> wroathe: No
09:06:05 <merijn> wroathe: Values in haskell must always have a type of kind *
09:06:10 <tomsen> yes right, the example doesnt make sense. i actually have several data types in a tree. some of them implement "Show", others don't. So i thought i could maybe filter for those. But im not sure if that does make sense typewise.
09:06:14 <merijn> wroathe: So there are 0 values with kind "hello"
09:06:19 <c_wraith> wroathe: wait until we get pi types. Then you'll be able to do that. :)
09:06:27 <hyperisco> I am not sure you can use strings as type literals, but if you can then you just need a proxy, wroathe
09:06:37 <merijn> hyperisco: You can with DataKinds
09:06:43 <hyperisco> something like a  Symbol → Type  proxy
09:07:29 <hyperisco> note though how pointless sayHello is then
09:07:44 <wroathe> hyperisco: Yeah, I'm just using it to illustrate
09:07:58 <c_wraith> wroathe: alternatively, you can do this right now:  say :: forall a. KnownSymbol a => IO () and call it with say @"hello"
09:08:22 * hackage suavemente 0.1.0.0 - An applicative functor that seamlessly talks to HTML inputs.  http://hackage.haskell.org/package/suavemente-0.1.0.0 (isovector)
09:08:49 <hyperisco> oh right polykinds
09:09:06 <hyperisco> so  sayHello :: Proxy "hello" -> IO ()
09:09:50 <monochrom> I don't understand "several data types in a tree".  I think I need a concrete loadable-into-ghci example.
09:11:04 <HenryCH> i'm having a hard time getting the correct content root path for a web app that runs as a service. I can get the executable's folder at runtime which is fine if I've dotnet published, but not find if im just debugging locally. Anyone know how to do this?
09:11:18 <merijn> So...back to more Haskell2010 questions: How would I write a list of do blocks without going through the hassle of naming them all? Or is the conclusion "You don't, deal with it"?
09:11:29 <HenryCH> sorry, wrong channel
09:12:20 <Solonarv> merijn: [do foo bar, do bar baz] is legal IIRC
09:12:49 <merijn> Solonarv: My question is "What's the best way to format that in a way that doesn't suck ;)
09:12:50 <Solonarv> if you need to associate them with some ID, the nicest way is probably to use some infix operator
09:12:50 <hyperisco> Rembane, that is interesting but I don't think it fits the bill
09:12:59 <Solonarv> merijn: one sec, typing a gist
09:13:22 <koz_> phadej: Would you be able to help me derive the functor optic version of Traversal? It's doing my brain in.
09:15:52 <Solonarv> merijn: this looks reasonable to me: https://gist.github.com/Solonarv/7ac518b637cd59557b748d4831f2f9e7
09:17:22 <hyperisco> actually seems to be finite cases… 24 of them Rembane
09:17:48 <monochrom> merijn: I would do what Solonarv does too.  This is one of those few times when the SPJ punctuation-prefix format makes sense.
09:19:21 <merijn> Solonarv: Oh, that's a nice idea with the =.
09:19:26 <Solonarv> I actually use that style a lot. Almost every time I have a multi-line list, or record syntax, or export list, or chaining a bunch of & / <*> / >>=
09:19:57 <hyperisco> gr no, I forgot… when you resize stuff you're not sure if either the width or the height will clip first
09:20:28 <hyperisco> so… I just have to normalise the dimensions in that manner I guess
09:21:15 <merijn> I generally use prefix punctuation too
09:21:25 <merijn> But not with semicolons, that's for crazy people
09:21:36 <Solonarv> Yeah, agreed. I don't do that either.
09:22:03 <Solonarv> I only use semicolons for one-line case/do blocks
09:22:05 <merijn> Anyhoo, that's probably a good start. Now it's time to go home :)
09:26:22 <matheus23> Hi everyone, I'm streaming haskell programming on twitch if anyone is interested in watching https://www.twitch.tv/matheusdev23 I'll be working with the elm compiler and build some sourcecode reduction stuff with it
09:26:45 <kish> sounds like fun
09:32:17 <hyperisco> so instead of 24 options there are 48, mkay
09:32:27 <hyperisco> and CSS just gives you 5, phft
09:52:16 <wroathe> What am I doing wrong here? https://gist.github.com/JustinChristensen/7603fcc143018b0c9b24e855149ba75b
09:52:24 <ph88> is someone currently on windows ?
09:52:28 <ph88> got a quick question
09:52:39 <wroathe> Do I need to define an instance for s?
09:53:59 <geekosaur> wroathe, ScopedTypeVariables
09:54:01 <zachk> ph88 im on windows 10, whats your question?
09:54:30 <geekosaur> the "s" on line 10 is not related to the one on line 9 by default
09:56:34 <ph88> zachk, can you look if gcc is present in one of the subdirectories of %APPDATA%\Local\Programs\stack\
09:56:58 <zachk> i dont have stack i think 
09:57:04 <ph88> :/
09:57:04 <ph88> ok
09:57:07 <zachk> how do i Look up appdata
09:57:21 <ph88> just go to Explorer (file browser) and paste that paste
09:57:24 <zachk> i think some versions of the haskell platform come with a mingw toolchain on windows 
09:57:30 <ph88> %APPDATA% will resolve automatically
09:58:03 <zachk> never knew that
09:58:31 <zachk> how do i install stack? is there an easy way using the haskell platform?
09:58:31 <wroathe> geekosaur: Hrm, adding it doesn't seem to change the compiler error
09:58:34 <Rembane> hyperisco: Ach, I misremembered. 
09:58:42 <geekosaur> you also need to explicitly forall the s
09:58:51 <geekosaur> read the documentation for ScopedTypeVariables
09:58:57 <wroathe> geekosaur: Cool. Thanks!
09:59:30 <zachk> ph88, I have stack but don't have that directory, don't think i've used stack on this install of the haskell platform yet 
09:59:44 <zachk> ph88, i dont have that directory you gave
09:59:53 <ph88> hmm strange, stack should make the directory by default
09:59:56 <ph88> where is your stack stuff ?
10:00:04 <zachk> no idea
10:00:05 <geekosaur> once run and installs a ghc, which they said they haven't done
10:00:17 <ph88> zachk, maybe you have very old haskell tools
10:00:26 <zachk> 8.4.2 ghc i think
10:00:49 <zachk> i think my cabal stuff is somewhere in the appdata directory but I dont remember 
10:07:10 <wroathe> geekosaur: So the docs are stating the need for an explicit forall, but this tiny servant implementation I linked earlier didn't require it when following the same pattern: https://gist.github.com/JustinChristensen/f7dbd5f81442a3f760f3888524fb8eb7#file-tinyservant-hs-L83
10:07:28 <wroathe> geekosaur: Why is that?
10:07:53 <geekosaur> instance definition, not functon
10:08:02 <wroathe> Ah, thanks
10:08:10 <geekosaur> the instance types are necessarily in scope bnecause theyre the point
10:12:34 <wroathe> So if DataKinds automatically promotes all values to be types, does that not mean there's now an infinite number of types with the same cardinality as the unit type?
10:14:44 <lyxia> you already have that with Proxy
10:15:19 <wroathe> lyxia: Oh, boom
10:15:48 <wroathe> But in this case Proxy Int, "foo", and () all share similar properties then?
10:16:02 <lyxia> there is nothing of type "foo"
10:16:11 <lyxia> because "foo" is not a type
10:17:06 <lyxia> Proxy Int and () are indeed similar types
10:17:35 <Solonarv> ph88: yes, gcc is in there somewhere
10:17:53 <Solonarv> give me a sec to find it
10:19:06 <Solonarv> ph88: %appdata%\local\programs\stack\x86_64-windows\ghc-X.Y.Z\mingw\bin\gcc.exe
10:20:22 <wroathe> lyxia: Ah, "foo" has kind Symbol, and Proxy Int, and () both have kind *
10:20:36 <Solonarv> wroathe: DataKinds doesn't promote all values to types. It promotes all types to kinds, and all constructors to types.
10:21:05 <wroathe> Solonarv: Yeah, I'm just now getting that 
10:21:54 <adamCS> lyxia: Hi!  Thanks for the help yesterday.  Constraint synonyms turned out to be the right push.  Once I started trying to simplify that way, it all became clearer.  So there are still as many constraints but they are better organized and the functions are way easier to call with polymorphic arguments.
10:21:55 <Solonarv> "What's the difference?", you may ask - well, not all values are built only from constructors.
10:22:08 <wroathe> * is an unfortunate name for Type
10:22:15 <Solonarv> As a simple example, 'Int' is a constructor wrapped around the primitive 'Int#'
10:22:21 <Solonarv> wroathe: agreed, it'll be phased out eventually
10:23:07 <wroathe> * feels like it should designate something polymorphic in the context of kinds
10:23:47 <wroathe> Like * -> Type, rather than k -> *
10:24:54 <Solonarv> That'd also be misleading, for a different reason
10:25:03 <wroathe> Oh?
10:25:16 <Solonarv> (what if you have multiple kind variables?)
10:25:33 <wroathe> Ah
10:25:42 <Solonarv> % data Proxy2 (a :: k1) (b :: k2) = Proxy2 -- a somewhat silly example
10:25:43 <yahb> Solonarv: 
10:25:46 <lyxia> https://github.com/ghc-proposals/ghc-proposals/pull/143 Remove the * kind syntax
10:25:55 <wroathe> Then it does indeed make sense to use characters
10:26:08 <Solonarv> And having * be an identifier (instead of an operator) complicates parsing, too
10:26:25 <Solonarv> (don't forget that programmers also have to parse code! not just compilers.)
10:28:04 <dmwit> I'd like to add `ghc-options: -freverse-errors` to my `cabal.project.local`. What do?
10:28:24 <dmwit> I tried adding it to a `package *` stanza, and to a `package foo` stanza for the package that currently isn't building, but neither seem to have an effect.
10:28:33 <merijn> dmwit: Ah, yes
10:28:47 <merijn> dmwit: That's because I disabled triggering rebuilds for that :p
10:28:50 <dmwit> (Specifically: `cabal new-build all --verbose` lists a ghc invocation that does not include that flag.)
10:29:01 <Solonarv> And now consider what happens when you're using type-level numbers, and want to multiply them. Now '* means type' gets even more confusing!
10:29:03 <merijn> dmwit: dmwit Oh, that's weird
10:29:04 <dmwit> merijn: It is rebuilding, because there is an error. But the errors are not reported in reverse order.
10:29:10 <merijn> hmmm
10:29:53 <merijn> Then I happily conclude it's not my fault :p
10:30:00 <wroathe> Boy, AntC2 in that Github issue sure is spicy
10:30:08 <wroathe> Github PR*
10:30:49 <wroathe> https://github.com/ghc-proposals/ghc-proposals/pull/143#issuecomment-396006253 I guess I'm the evidence he wanted
10:32:49 <geekosaur> re *, a week or so ago we had someoen who was relly confused because an example had been "updated" via s/\*/Type/g ... and had type level multiplication.
10:33:00 <geekosaur> which was a lovely demonstration of why * as kind needs to go away
10:35:20 <nshepperd1> We can use that Unicode star instead
10:36:37 <Solonarv> Aye, that's mentioned in the proposal as well (★ continuing to mean Type)
10:36:50 <wroathe> The fact that these proposals are open to the public and so is the discussion via Github kind of invalidates AntC2's argument that the public might complain because they weren't warned
10:36:52 <dmwit> no no, you misunderstood.
10:37:10 <dmwit> * should still be type, it's *multiplication* that should be ★
10:37:30 <wroathe> This is just basic software deprecation practice. All things change.
10:37:51 <merijn> wroathe: There are a lot of programmers/users who DON'T read those proposals
10:38:15 <geekosaur> or even kno they exist despite being publicly announced
10:38:18 <koz_> I only became aware of these a few months ago, and I've been Haskelling for something like four years now.
10:38:30 <geekosaur> people don't pay attention to what doesn't seem to matter to them at the time
10:38:31 <koz_> (and unfortunately, I am still bad at it :P)
10:38:38 <ph88> thank you Solonarv 
10:38:47 <merijn> I like to think I keep up with GHC, but I was only vaguely aware the proposals are now public and formalised and I don't have time to track them
10:39:37 <wroathe> Well, as software developers we know that things are bound to change, and deprecation notices have been a thing for a long time now
10:39:38 <dmwit> cabal-install-2.4 appears to behave as I expected
10:39:40 * dmwit shrugs
10:39:41 <Solonarv> I don't properly track them, but I do browse /r/haskell often enough that I'll see all new proposals posted there (which seems to be a fairly large fraction)
10:39:53 <merijn> dmwit: What were you using before? 2.2?
10:39:55 <Solonarv> and anyway, that's why the proposal includes a lengthy deprecation schedule
10:40:01 <dmwit> 2.3
10:40:19 <merijn> dmwit: Ah, yeah, everything pre-2.4 is still kinda brittle wrt new-build
10:40:25 <wroathe> Updating GHC on your system implies accepting changes and being aware of what those changes are
10:40:48 <wroathe> "I updated GHC and things changed" is not a valid reason to complain
10:40:57 <merijn> wroathe: Yeah...you try and develop a compiler like gcc/clang with that attitude
10:41:28 <dmwit> ...and now when I revert back from 2.4 to 2.3 it also behaves as I expect.
10:41:29 <wroathe> merijn: There's certainly a balance to be struck
10:41:36 * dmwit shrugs his legs, too
10:41:48 <koz_> merijn: And even those two _do_ cause release breakage. Gentoo's bugtracker for GCC8 is _still_ full of build breakages.
10:42:14 <wroathe> merijn: Part of it is having a central place to document your intention to break things
10:43:17 <dmwit> By comparison: I have updated my kernel a lot of times, and the only change I've ever noticed is having to update my graphics driver at the same time.
10:43:36 <koz_> dmwit: Nvidia binary driver or something?
10:43:41 * dmwit nods
10:43:54 <merijn> wroathe: Sure, but gratuitously breaking things is to be avoided and many people will consider this gratuitous breakage
10:43:55 <koz_> Ah, yeah. In my case 'emerge @preserved-rebuild'.
10:44:00 <dmwit> Of course, there's a price to pay for that stability.
10:44:19 <dmwit> There are interfaces in the kernel that everybody agrees are just awful, but can't get rid of.
10:44:22 <koz_> wroathe: I might also add that _none_ (or almost none) of the breakages I just mentioned were ever documented in any way by the GCC devs.
10:44:33 <koz_> (or in any way that could have been indicative of anything like most of said breakages)
10:45:00 <koz_> (sorry, @module-rebuild, what am I even saying, argh)
10:49:21 <wroathe> How do these proposals move to the accepted state?
10:50:29 <wroathe> nvm, it's in the README
10:51:27 <wroathe> Is there a plan to host GHC on Github officially?
10:51:43 <wroathe> the ghc repo* I mean
10:52:02 <Solonarv> No, but it moved to Gitlab recently
10:52:49 <Solonarv> or maybe isn't quite done moving yet, I'm not sure
10:53:07 <wroathe> Ah, https://ghc.haskell.org/trac/ghc/wiki/WhyNotGitHub
10:54:15 <__monty__> Isn't the github mirror bidirectional?
10:54:27 <Solonarv> whew, that wiki page doesn't even mention the gitlab migration
10:55:27 <wroathe> Yeah, it just seems to weird to track the Haskell report and GHC proposals (as well as cabal and other things) on Github and just have GHC hanging out on Trac
10:56:36 <__monty__> It won't stay on trac though.
10:59:33 <lyxia> yes small patches can go through github
11:07:38 <wroathe> So what makes these kinds and not just uninhabited types? https://github.com/ghc/ghc/blob/master/libraries/ghc-prim/GHC/Types.hs#L57
11:08:30 <lyxia> this file is a stub
11:09:17 <lyxia> or parts of it are, such as this line.
11:10:21 <koz_> I don't think we _have_ a type corresponding to Constraint-the-kind.
11:10:22 <geekosaur> wroathe, the point of that file is to build info tables for wired-in stuff
11:10:37 <koz_> (unless you count Dict, which isn't really the same)
11:10:40 <geekosaur> koz_, secretly we do, and it causes problems
11:10:49 <geekosaur> internally Constraitn and Type are the same thing
11:10:57 <koz_> geekosaur: Oh, that's news to me.
11:11:00 <geekosaur> there's an open bug
11:11:20 <wroathe> geekosaur: Yeah, I'm trying to get an idea of what the possible values of k in k -> * can be
11:11:28 <geekosaur> (the bug still references * because it predates * becoming Type )
11:11:51 <geekosaur> wroathe, that's kinda open-ended
11:12:01 <geekosaur> practically speaking, a kind is the "type" of a type
11:12:32 <geekosaur> this becomes fuzzy when type and data constructors can be promoted
11:12:43 <koz_> wroathe: For a good, basic illustration of how non-Type kinds can be helpful, I encourage you to check out jle`'s Introduction to Singletons.
11:12:53 <koz_> Specifically Part 1 - it's literally _the_ first thing he makes a case for.
11:13:12 <wroathe> koz_: Thanks
11:13:16 <wroathe> Looking now
11:13:39 <wroathe> geekosaur: And yeah, without DataKinds is the set of possible values for k finite in Haskell 2010?
11:13:49 <wroathe> geekosaur: I see Type, Constraint, Nat, Symbol
11:13:49 <koz_> Admittedly the example is _somewhat_ contrived, but it should show you the utility of kinds which aren't Type.
11:14:09 <geekosaur> H2010 has only *, and things like (* -> *)
11:14:12 <koz_> wroathe: Type -> Type is also a kind.
11:14:20 <koz_> As is Type -> Type -> Type.
11:14:23 <koz_> And so on.
11:14:37 <wroathe> Ah
11:14:42 <koz_> (the former being the kind of Maybe, the latter of Either)
11:14:50 <geekosaur> and I don't think you can even talk about kinds as such in H2010
11:16:36 <williamrusnack> Anyone know of a type that I can wrap a collection in to ensure it has an exact length?
11:18:05 <merijn> williamrusnack: Not really, unless you define one
11:20:02 <Solonarv> which shouldn't be too hard:
11:20:36 <Solonarv> % let Exact (n :: Nat) f a = Exact { getExact :: f a }
11:20:36 <yahb> Solonarv: ; <interactive>:79:45: error: parse error on input `::'
11:20:46 <Solonarv> % newtype Exact (n :: Nat) f a = Exact { getExact :: f a }
11:20:46 <yahb> Solonarv: ; <interactive>:80:21: error:; Not in scope: type constructor or class `Nat'; Perhaps you meant `Pat' (imported from Language.Haskell.TH)
11:22:43 <williamrusnack> Solonarv: I have something very similar
11:22:46 <williamrusnack> newtype Exactly c t a = Exactly {getExactly :: t a}
11:23:02 <Solonarv> % let { toExact :: forall n f a. (KnownNat n, Foldable f) => f a -> Maybe (Exact f a); toExact fa = if length fa == natVal (Proxy @n) then Just (Exact fa) else Nothing }
11:23:02 <yahb> Solonarv: ; <interactive>:85:74: error:; * Expecting one more argument to `Exact f a'; Expected a type, but `Exact f a' has kind `k0 -> *'; * In the first argument of `Maybe', namely `(Exact f a)'; In the type signature: toExact :: forall n f a. (KnownNat n, Foldable f) => f a -> Maybe (Exact f a); <interactive>:85:80: error:; * Expecting one more argument to `f'; Expected kind `Nat',
11:23:08 <williamrusnack> The messy part is the `c`
11:23:11 <Solonarv> % let { toExact :: forall n f a. (KnownNat n, Foldable f) => f a -> Maybe (Exact n f a); toExact fa = if length fa == natVal (Proxy @n) then Just (Exact fa) else Nothing }
11:23:11 <yahb> Solonarv: ; <interactive>:86:117: error:; * Couldn't match expected type `Int' with actual type `Integer'; * In the second argument of `(==)', namely `natVal (Proxy @n)'; In the expression: length fa == natVal (Proxy @n); In the expression: if length fa == natVal (Proxy @n) then Just (Exact fa) else Nothing
11:23:19 <Solonarv> ugh, one sec
11:24:09 <williamrusnack> For the length type I have just been using `data One`, `data Two`, …
11:24:18 <Solonarv> % toExact @10 [1..10]
11:24:18 <yahb> Solonarv: Just (Exact {getExact = [1,2,3,4,5,6,7,8,9,10]})
11:24:30 <Solonarv> % toExact @10 [1, 2]
11:24:30 <yahb> Solonarv: Nothing
11:24:57 <Solonarv> If you want type-level numbers, you can find them in GHC.TypeLits
11:25:09 <williamrusnack> Oh, thanks
11:25:35 <Solonarv> % toExact @0 [1..] -- a slight problem with this approach
11:25:37 <yahb> Solonarv: *** Exception: heap overflow
11:25:57 <Solonarv> (because 'length [1..]' runs forever)
11:26:43 <Solonarv> But it'll work fine for finite datastructures.
11:28:26 <williamrusnack> Ok thanks. Very helpful
11:29:29 <Solonarv> Also, note that on sequences where 'length' is expensive (such as lists), toExact will also be expensive.
11:31:50 <williamrusnack> Is there a function that only checkes if it has a certain length rather than getting the length and then comparing it?
11:32:16 <williamrusnack> like `lengthEq :: Int -> [a] -> Bool`
11:32:43 <lyxia> you can write one easily enough
11:32:47 <Solonarv> Not one that works optimally on all foldables, AFAIK
11:33:15 <koala_man> would ghc optimize a simple f n = null . drop n ? 
11:33:28 <lyxia> there's no lengthEq anywhere I know
11:33:51 <Solonarv> It should, yes. But that only works on lists, and doesn't give you *exact* length - just at-most length
11:34:40 <koala_man> oh, I misunderstood. I didn't read the backlog 
11:36:12 <williamrusnack> If it doesn’t work optimally on all foldables could it be made a typeclass and then have a instance for the foldable constraint and then have better instances for specific types?
11:36:24 <Solonarv> Yes, with overlapping instances
11:38:22 <Solonarv> Or a rewrite rule, maybe
11:38:45 <Solonarv> {-# RULE "lengthEq/[]" lengthEq = lengthEqList #-}
11:39:30 <williamrusnack> I’ve never seen a rewrite rule. I’ll have look it up
11:41:48 <dmwit> :t \n xs -> null (drop (n-1) xs) /= null (drop n xs)
11:41:50 <lambdabot> Int -> [a] -> Bool
11:42:15 <Solonarv> Ah. but that traverses the list twice :/
11:42:18 <dmwit> :t \n xs -> let xs' = drop (n-1) xs in null xs' /= null (drop 1 xs')
11:42:19 <lambdabot> Int -> [a] -> Bool
11:42:33 <Solonarv> nice!
11:45:13 * dmwit . o O ( \n xs -> unsafeCoerce (drop n xs) )
11:46:03 <dmwit> oh man
11:46:12 <dmwit> `unsafeCoerce drop`
11:46:37 <Solonarv> % unsafeCoerce (1 :: Int) :: Bool
11:46:38 <yahb> Solonarv: False
11:46:38 <dmwit> Doesn't work, though. =P
11:46:53 <Solonarv> you want tagToEnum# :P
11:47:07 <dmwit> Nah, the idea is fundamentally broken.
11:47:16 <dmwit> It's lengthGT rather than lengthEQ
11:47:48 <Solonarv> True.
11:47:53 <dmwit> It's a pretty cute implementation of lengthGT, though. =)
12:04:21 --- mode: glguy set +v Boarders
12:04:36 --- mode: glguy set -v Boarders
12:05:04 <Boarders> Does anyone know if there is a library in haskell for maniuplating audio files e.g. that could take an mp3 file and split it into segments or that sort of thing?
12:05:52 * hackage semigroupoids 5.3.2 - Semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-5.3.2 (ryanglscott)
12:06:32 <sternmull> Boarders: hsndfile (but i never used it, just used libsndfile via is C API so far)
12:07:00 <Boarders> sternmull: thank you!
12:10:53 * hackage generic-data 0.5.0.0 - Utilities for GHC.Generics  http://hackage.haskell.org/package/generic-data-0.5.0.0 (lyxia)
12:14:28 --- mode: glguy set +v mreh
12:14:38 --- mode: glguy set -v mreh
12:15:16 <mreh> Axman6: saw you were struggling with Database.Beam.Migrate.Simple.bringUpToDate too
12:21:08 <Tranquil> hello
12:21:11 <Tranquil> hi everyone
12:22:01 <Tranquil> السَّلاَمُ عَلَيْكُمْ وَرَحْمَةُ اللهِ وَبَرَكَاتُهُ May the peace, mercy, and blessings of Allah be with you
12:22:03 <Tranquil> to you all
12:22:15 <Tranquil> my name is Yasir Shahzad
12:22:23 <Tranquil> nice to see you all
12:22:46 <koala_man> hello
12:24:35 <kadoban> Tranquil: Welcome. That's quite an introduction.
12:24:37 <jle`> wroathe: your original question is kind of like asking "so what makes Bool a type, and not a non-integer?"
12:25:24 <geekosaur> that was what I meant by open-ended, yeh
12:25:43 <geekosaur> also has a certain air of 'not even wrong' to it, re the concept
12:25:58 <lyxia> Speaking of open-ended, I wonder how fen's doing.
12:26:57 <bwe> How can I URL encode params with req? https://gist.github.com/benjaminweb/e067563f586b7d36f785ddd2d737747a
12:29:27 <lyxia> bwe: is that not what ReqBodyUrlEnc does
12:31:26 <shapr> Tranquil: are you learning Haskell?
12:33:53 <Tranquil> kadoban yup
12:34:02 <Tranquil> what is haskell ?
12:35:05 <mreh> http://haskell.org is looking very nice now
12:35:12 <kadoban> Tranquil: It's a programming language. It's quite interesting if you're into that kind of thing.
12:35:53 <mreh> it's not meant for production though /s
12:36:46 <Tranquil> kadoban like what ultimately we can get from it i mean what kind of programme ?
12:36:59 <Tranquil> kadoban what that programme will be generating ?
12:37:11 <kadoban> It's a general purpose programming language. You can use it for about anything.
12:37:30 <Tranquil> kadoban like for making high level pc game ?
12:37:57 --- mode: glguy set +v alphaz
12:38:03 <kadoban> Sure, though there's more common languages to use for games (they tend to be heavy on using libraries, and they're all in C++ or C)
12:38:04 <wroathe> jle`: I've lost track of my questions, which one are you referring to?
12:38:35 <c_wraith> it's capable for games, but it doesn't have the tooling or ecosystems that you get from using something established like unity3d or the unreal engine.
12:38:38 <alphaz> hi everyone
12:39:38 <alphaz> i had a few questions about the bound library and can't seem to find documentation that would help my questions
12:40:48 <lyxia> sure go ahead
12:40:50 <alphaz> the example at http://hackage.haskell.org/package/bound gives a good idea for it
12:40:58 <jle`> wroathe: "what makes this a kind and not an uninhabited type?"
12:41:12 <alphaz> but I can't seem to understand why it uses a polymorphic VAR type?
12:41:12 <Tranquil> okey
12:41:14 <Tranquil> sorry
12:41:18 <Tranquil> i am not into this
12:41:23 <Tranquil> i think i will be going
12:41:32 <Tranquil> is there any female who is interested to chat ?
12:42:01 <lyxia> alphaz: do you mean "V a"?
12:42:04 <Tranquil> will i really come like a Massiah ?
12:42:15 <Tranquil> never anyone seen like such before ?
12:42:15 <wroathe> jle`: Well, the way it's specified in ghc-prim just looks like the declaration of Void to me
12:42:26 <bwe> lyxia: Alright. Yet Req somehow url encodes the params, does it?
12:42:45 <Tranquil> do among you anyone have got pc game on his or her computer if can send it to me through dcc ?
12:42:46 <wroathe> jle`: But it's somehow documented that they're kinds
12:42:46 <alphaz> lyxia: yeah, sorry it was VAR in the other example at schoolofhaskell
12:42:48 <jle`> wroathe: a lot of low-level primitives in ghc are placeholder stubs
12:42:50 <lyxia> bwe: I was asking a question
12:43:00 <jle`> wroathe: i think (+) = undefined, essentially, for Int's
12:43:14 <Tranquil> @search pc shooting game to be sent through dcc ?
12:43:14 <lambdabot> Unknown command, try @list
12:43:19 <lyxia> bwe: you want to URL encode, and req does it, so what's the problem
12:43:25 <Tranquil> @list
12:43:25 <lambdabot> What module?  Try @listmodules for some ideas.
12:43:25 <wroathe> jle`: Got it
12:43:35 <Tranquil> oh no my bad
12:44:03 <Tranquil> okey do anyone have got any good music to share with me if any girl is there to share it with me ?
12:44:17 <Tranquil> because i am spending life from quite a very long time without a girl ?
12:44:22 <Tuplanolla> What is this?
12:44:26 <boj> Tranquil: sorry you are not in the right place. this is a technical channel
12:44:31 <Tranquil> perhaps i am the only Lion left in the world !
12:44:32 <lyxia> alphaz: the point is to be able to define "return" as variable and "(>>=)" as substitution
12:44:36 <lyxia> @ops
12:44:36 <lambdabot> Maybe you meant: pl oeis docs
12:44:43 <bwe> lyxia: I want to do it without performing the request (I need to build an URL to be served by a servant API).
12:44:50 <Tranquil> but leave it laugh out loudly
12:44:59 <monochrom> GHC is a renewed reason why everyone should read/listen-to Dennis Ritchie's Turing Award speech.  In which he describes how you can do sneaky things (even malicious) by hacking the compiler so that the source code looks completely benign.
12:45:10 <Tranquil> monochrom really ?
12:45:16 <mrm> Tranquil: Try this - http://blog.robertelder.org/bash-one-liner-compose-music/
12:45:20 <monochrom> Yes.
12:45:42 <Tranquil> maybe just in dreams
12:45:46 <Tranquil> hmmm
12:45:49 <alphaz> lyxia: I read that, but I have trouble understanding the implications
12:46:01 <Tranquil> i dont expect anything from anyone now
12:46:01 <monochrom> GHC is a great example because base source code has a lot of "foo = foo" that tells you nothing but ah the compiler is going to special-case them to fill in real code.
12:46:09 * Tranquil walk away
12:46:28 <monochrom> In GHC's case it fills in useful benevolent code.
12:46:52 <monochrom> But Dennis Ritchie tells you why not malicious code too while you're at it.
12:46:53 <alphaz> lyxia: i wrote my tree in open recursive style so the type parameter is used for recursion; does bound require me to create a different AST type just for name handling?
12:46:54 <Tranquil> laugh @ freenode
12:47:00 <Tranquil> hahahahahaha
12:47:03 <Tranquil> just namely
12:47:12 <Tranquil> empty freenode from inside
12:47:14 <Tranquil> fake
12:47:22 <Tranquil> i didn't like it at all
12:47:27 <Tranquil> full of garbage people
12:47:35 <Tranquil> untrue people
12:47:45 <Tranquil> in truth whom are just wastages 
12:47:53 <Tranquil> wastages tank
12:47:56 <lyxia> @where ops
12:47:57 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
12:48:01 <Tranquil> another one comes
12:48:04 <Tranquil> who cares
12:48:12 <monochrom> In fact he also describes how to do bootstrapping so that you no longer need to keep compiler's own malicious source code after a couple of versions.  (The exes will perpetuate themselves.)
12:48:16 --- mode: ChanServ set +o johnw
12:48:16 <Tranquil> here even a sweeper will come and slap me
12:48:20 <Tranquil> laugh out loudly
12:48:21 <monochrom> Ah OK
12:48:24 --- mode: ChanServ set +o shapr
12:48:24 --- mode: ChanServ set +o monochrom
12:48:27 <geekosaur> becaue it's fine to noise any channel
12:48:28 --- kick: Tranquil was kicked by shapr (Kicked by shapr)
12:48:34 --- mode: johnw set -o johnw
12:48:41 --- kick: Tranquil was kicked by shapr (Kicked by shapr)
12:48:42 <johnw> thanks shapr
12:48:45 <shapr> I forget how to ban :-/
12:48:49 <Clint> aww
12:48:55 <johnw> I have a /kickban macro
12:49:14 <shapr> use if tranquil returns?
12:49:22 <johnw> sure
12:49:53 <alphaz> lyxia: [reposting after the noise] i wrote my tree in open recursive style so the type parameter is used for recursion; does bound require me to create a different AST type just for name handling?
12:50:03 <lyxia> alphaz: I'm not sure how well bound supports the use case
12:50:21 <lyxia> in theory it's feasible but you might have to reimplement a lot of things
12:51:54 <alphaz> lyxia: thanks, so i guess the default use case for bound lib is to have an AST that does not use open recursion, instead using the type param for variable handling right?
12:53:29 <alphaz> i was thinking i could convert my current AST to another which uses the type param for naming
12:53:30 <lyxia> that's right. But there could be a way to support both by adding more parameters to your AST base functor. One for Fix, one for Monad.
12:54:18 <lyxia> I mean, a way to define an AST in open recursion style that works with bound.
12:54:27 <_deepfire> mpickering: submitted as https://ghc.haskell.org/trac/ghc/ticket/16127
12:57:00 <alphaz> lyxia: i could try adding more params, but i was under the impression that only the last paramater can be used for instances
12:57:39 <alphaz> in the same way that the instances for either are right parameter biased
12:58:07 <alphaz> oh you mean one only for recursing, that could work
12:59:52 * hackage cli 0.2.0 - CLI  http://hackage.haskell.org/package/cli-0.2.0 (VincentHanquez)
13:00:59 <lyxia> well you wouldn't define the bound-style Monad instance on your base functor, but on some variant of Fix that reorganizes the various parameters you have 
13:02:54 <alphaz> do you think it would be more reasonable to go to a different representation and use the monad instance there
13:03:05 <lyxia> bwe: req actually does the url encoding (i.e., conversion to an actual Bytestring or Text) by calling some function from http-types, and that is entirely hidden from the req API
13:03:24 <lyxia> alphaz: I think so.
13:04:03 <alphaz> like SyntaxExpr a -> NameExpr a -> other phases
13:04:16 <alphaz> so SyntaxExpr could be open recursive for parsing and stuff
13:04:35 <alphaz> but NameExpr could have the monad instance for bound and check names
13:04:42 <alphaz> other phases can follow suit
13:05:22 <alphaz> ** don't mean a function, intended to mean a pipeline with ->
13:05:25 <lyxia> Is open recursion helpful for parsing?
13:06:18 <alphaz> i found it easier to _add_ information to the AST _after_ writing out the parser with the open recursion style
13:06:32 <alphaz> like initially i just got some parsing working and later wanted to add src locations etc
13:11:43 <alphaz> lyxia: ill try out the options, thank you for all the help; some of this stuff was not obvious to me from the docs
13:33:52 * hackage hpio 0.9.0.7 - Monads for GPIO in Haskell  http://hackage.haskell.org/package/hpio-0.9.0.7 (dhess)
13:47:17 <Boarders> How do I use Type in kind signatures
13:47:24 <Boarders> I have TypeInType turned on
13:47:29 <Boarders> do I need to import something?
13:47:36 <Welkin> *
13:47:52 <Boarders> are you telling me to use * instead?
13:48:08 <Welkin> you can try
13:48:13 <monochrom> You could use * but if you want to use Type you have to import it from somewhere.
13:48:15 <Boarders> I just want to use Type
13:48:29 <Boarders> ah ok, thanks monochrom
13:48:31 <Boarders> I wasn't sure
13:48:57 <Boarders> It is defined in Data.Kind
13:49:10 <monochrom> Yeah.
13:51:33 <v0d1ch> I can't wrap my head around this one
13:51:33 <v0d1ch> ```
13:51:33 <v0d1ch> exFrom :: (Either a b -> c) -> (a -> c, b -> c)
13:51:33 <v0d1ch> exFrom f = (f . Left, f . Right)
13:51:33 <v0d1ch> ```
13:52:03 <v0d1ch> what is confusing is the composition part
13:52:14 <merijn> v0d1ch: How so?
13:52:15 <Welkin> please use a paste site
13:52:38 <v0d1ch> so `f` is a function that takes an `Either` and produces some `c`
13:52:42 <lyxia> what if you replace . by its definition    f . Left = \x -> f (Left x)
13:52:49 <Welkin> (.) f g x = f (g x)
13:52:58 <monochrom> What if I rewrote it as: ( (\a -> f (Left x)), (\b -> f (Right b)) ) ?
13:53:57 <Boarders> I have been trying to be able to use ¬ a = a -> Void in my code and I can't use the CPP to do this as #define can only replace legal identifiers which much be capitalised 
13:54:01 <Boarders> does anyone know the easiest appraoch
13:54:03 <Boarders> *
13:54:05 <monochrom> Err \a -> f (Left a)
13:54:11 <Boarders> could you do it with a source plugin for example?
13:54:59 <Solonarv> I'm pretty sure source plugins run after the parser, so... I don't think you could to it in a way that works reliably
13:55:10 <v0d1ch> lyxia: in your example what would be the type of `x` ? `Either a b` ?
13:55:20 <monochrom> x::a
13:55:30 <monochrom> Because you're aiming at a->c
13:55:46 <Boarders> Solonarv: ah ok, so is there no way to do it without running a script that goes through and does the replacement :(
13:55:59 <monochrom> Left :: a -> Either a b; then f :: Either a b -> c.  Now chain them up.
13:55:59 <Boarders> (that seems a bit wild to me)
13:56:11 <Solonarv> Yeah, I wouldn't recommend that.
13:56:17 <lyxia> a one-line script though
13:56:27 <monochrom> I would use an alphabetic name like "Not".
13:56:28 <Solonarv> Perhaps you could configure your editor to display 'not' as that symbol?
13:57:14 <v0d1ch> monochrom: thanks, I see it now derp
13:57:32 <williamrusnack> I’m looking at the definition `class Cons s t a b | s -> a, t -> b, s b -> t, t a -> s where` in Control.Lens.Cons and the differentiation of `s` and `t` seems unnecessary since all the functions and instances have the same type for `s` and `t`
13:57:32 <williamrusnack> What’s the point of defining both?
13:57:37 <Boarders> Solonarv: I just wanted it for display purposes for other people since it is a literate file really
13:57:45 <rain1> @src sequence
13:57:46 <lambdabot> sequence []     = return []
13:57:46 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:57:46 <lambdabot> --OR
13:57:46 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
13:58:30 <lyxia> williamrusnack: Cons [a] [b] a b    ?
13:58:58 <geekosaur> Boarders, you can run a custom preprocessor (pgmF)
13:59:13 <wroathe> Can you guys recommend a book on type theory that starts at the beginning and works through a breadth of the concepts used in Haskell?
13:59:39 <williamrusnack> lyxia: Right why wouldn’t [] be a type variable
13:59:50 <monochrom> I think that book doesn't exist.
14:00:02 <Boarders> geekosaur: thank you for the recommendation!
14:00:38 <Boarders> wroathe: probably the best you can do is learn about lambda calculus up to System F
14:00:41 <lyxia> williamrusnack: I was referring to the instance of Cons for lists
14:00:49 <geekosaur> I don't tink I'd recommend it though, i's not well integrated into tooling (or, I suspect, well tested with either stack or cabal-install)
14:01:21 <Boarders> geekosaur: it's ok I am just running a file into ghc and it is just me going out of my way to make it look fancy
14:01:34 <Boarders> the code won't isn't even for running
14:02:17 <williamrusnack> lyxia: Correct couldn’t it take in a (* -> *)? class Cons (t :: * -> *) (a :: *) (b :: *)
14:03:06 <Boarders> wroathe: two well liked books as a general intro are Types and Programming Langauges by Pierce and  Type Theory and Formal Proof by Nederpelt 
14:03:08 <lyxia> it's class Cons (s :: *) (t :: *) (a :: *) (b :: *)
14:03:26 <Boarders> it is hard to recommend either as it depends on your background but the Pierce book is quite approachable
14:04:17 <wroathe> Boarders: Yeah, it's probably time for me to pick up a book on lambda calculus
14:04:19 <williamrusnack> lyxia: Thanks for the input. I’ll have to think about it a bit more
14:04:37 <hyperisco> wroathe, it'll build your biceps
14:04:40 <wroathe> Boarders: And I've got Types and Programming Languages. Haven't quite made time to work through it yet.
14:05:23 <wroathe> But wait, I already lift... So will my biceps be twice as big if I learn the lambca calculus?
14:05:30 <merijn> wroathe: TaPL has an intro to the lambda calculus too ;)
14:05:46 <wroathe> lambda*
14:06:50 * merijn sighs
14:07:04 <koz_> This seems to call for a transformers-related joke.
14:07:32 <merijn> persistent happily supports non "id" primary keys, but then their migrations break because those naively assume that there is ALWAYS an id column
14:08:24 <Welkin> I would not use persistent
14:08:48 <shapr> what would you use?
14:08:57 <Welkin> postgresql-simple (or mysql, etc.) and postgresql-simple-migrations
14:09:17 <Welkin> optionally groundhog to check that the schema is as expected
14:09:18 <merijn> Welkin: That's not particularly helpful
14:09:22 <shapr> I've enjoyed persistent so far
14:09:28 <Welkin> I used to use persistent
14:09:29 <merijn> Welkin: I came to that conclusion, like, 1 year ago
14:09:36 <Welkin> but the power you get by writing actual SQL is unsurpassed
14:09:36 <Clint> it's good if you don't need sql
14:09:41 <merijn> Welkin: But I don't have the time to migrate to something built from scratch
14:10:44 <Welkin> you lost almost all of the functionality of your database by using persistent (or any ORM)
14:10:50 <Welkin> lose*
14:10:56 <OmegaDoug> With Megaparsec, is there a way to conditionally use parsers, such as, if we just parsed token X, then we can use parsers A or B, else use C
14:11:35 <koz_> Welkin: Agreed.
14:11:39 <merijn> Welkin: Not really, custom SQL together with persistent has been working out reasonably well
14:12:28 <wroathe> A good database migration library doesn't prevent you from writing raw SQL if you need it. It just makes it easier to map changes in your types to schema changes, and to version those changes
14:13:15 <wroathe> EntityFramework and ActiveRecord both make it easier to manage change, while at the same time letting you write SQL if you need it
14:13:23 <merijn> Ugh, looks like there's a patch for my problem, but like my own patch it hasn't been merged because no one appears to be handling persistent PRs atm
14:13:31 <wroathe> It should be the same for Persistent too
14:14:11 <Welkin> making things easier on the developer at the expense of the person using the software and the integrity/performance of the system
14:17:52 * hackage yaya 0.1.0.0 - Total recursion schemes.  http://hackage.haskell.org/package/yaya-0.1.0.0 (sellout)
14:17:55 <merijn> Anyway, this entire line of discussion is pointless, because as I said. I'm already well aware of the problems with persistent, but migrating this code to something else isn't happening, so any suggestion of that is a waste of everyone's time
14:18:37 <rain1> @src liftm2
14:18:37 <lambdabot> Source not found. Are you typing with your feet?
14:18:39 <johnw> esqueleto plays nicely with persistent
14:18:41 <rain1> @src liftM2
14:18:41 <lambdabot> liftM2 f m1 m2 = do
14:18:41 <lambdabot>     x1 <- m1
14:18:41 <lambdabot>     x2 <- m2
14:18:41 <lambdabot>     return (f x1 x2)
14:19:04 <merijn> johnw: Honestly, esqueleto was *awful*
14:19:12 <merijn> johnw: I've been using raw SQL instead
14:19:18 <johnw> yeah, but it's nice for when you need to occasionally dip down to raw(-er) queries
14:19:21 <johnw> i kind of liked it after a while
14:19:42 <johnw> gives you more type safety than raw SQL
14:20:08 <iqubic> :t liftM2
14:20:10 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:21:07 <johnw> i'm trying to get servant-quickcheck to work with streaming
14:22:41 <merijn> johnw: Not really, though...
14:22:57 <merijn> johnw: esqueleto isn't particularly type safe and complex queries are hell to write with it
14:23:26 <Clint> and it's been undermaintained for quite some time
14:23:45 <Rembane> I like Selda! 
14:25:53 <zachk> OmegaDoug, not sure, maybe you want to use parsers in a do notation block? 
14:26:53 <Boarders> I am trying to use -F -pgmF preProcessor.sh  with preProcessor.sh in the file but get: ghc: could not execute: preProcessor.sh
14:27:22 <Boarders> anyone know what the problem might be
14:27:45 <iqubic> try checking the file permissions.
14:28:11 <Gurkenglas> What should I do when I want to write something like StateT but don't want to have duplicate definitions for (execState, execStateT), (evalState, evalStateT), etc.?
14:28:34 <iqubic> Boarders: Does your user have permission to run preProcessor.sh?
14:29:07 <Boarders> yeah
14:29:20 <Gurkenglas> ie how do I make the user not have to juggle the Identitys?
14:33:22 * hackage yaya-unsafe 0.1.0.0 - Non-total extensions to the Yaya recursion scheme library.  http://hackage.haskell.org/package/yaya-unsafe-0.1.0.0 (sellout)
14:33:28 <Solonarv> Gurkenglas: I guess you could try using 'type family HKD f a where HKD Identity a = a; HKD f a = f a'
14:33:40 <pie__> Is there an easy way to cache a slow intermediate computation to disk for later?
14:34:12 <Solonarv> then your type would look like 'newtype StateT s m a = StateT { runStateT :: s -> HKD m (a, s) }'
14:34:16 <sclv> pie__: sure!
14:34:21 <sclv> just write it to disk then read it out
14:34:26 <sclv> assuming you have it in a datastructure
14:35:00 <koz_> pie__: That computation better be _real_ slow.
14:35:12 <Welkin> to disk, or in-memory?
14:35:25 <pie__> Welkin, to disk
14:35:29 <Welkin> why to disk?
14:35:52 <pie__> Welkin, im messing with stuff in GHCI and I want to be able to load some stuff if I restart it
14:35:55 <Welkin> in-memory data stores can give you the same functionality without the overhead of disk access
14:36:59 <pie__> well I could run a separate cache process and write a protocol to talk to it but thats not worth the effort right now :
14:37:00 <pie__> :p
14:37:22 * hackage yaya-hedgehog 0.1.0.0 - Hedgehog testing support for the Yaya recursion schemelibrary.  http://hackage.haskell.org/package/yaya-hedgehog-0.1.0.0 (sellout)
14:37:25 * hackage expresso 0.1.1.0 - A simple expressions language based on row types  http://hackage.haskell.org/package/expresso-0.1.1.0 (willtim)
14:37:28 <pie__> sclv, can I have GHC just dump its own internal representation or something? I dont want to care about the data structure
14:37:39 <pie__> its "just" some library output
14:37:52 <davean> pie__: that doesn't make sense in a lazy language
14:38:01 <davean> You can autoderive serializations though
14:38:21 <davean> GHC's "internal representation" is computation
14:38:29 <pie__> well I want the data to be strictly evaluated anyway because the whole point it to not have to wait for eval again later
14:38:40 <sclv> there's a fancy thing you can do with compact regions but it is not well documented or packaged up in any library yet
14:38:44 <sclv> also it is very invasive
14:38:54 <pie__> sclv, ok so nevermind about that then
14:39:04 <pie__> I mean...basically I just want someting like python's picke
14:39:05 <sclv> pie__: the easy thing to do is just use the binary package and use generic deriving on your structure
14:39:06 <pie__> * pickle
14:39:10 <sclv> it makes serialization a snap
14:39:21 <pie__> sclv, ok. I will try that, my stuff has generic instances anyway
14:39:52 <sclv> compact region stuff for reference: http://hackage.haskell.org/package/compact-0.1.0.1/docs/Data-Compact.html
14:40:01 <davean> pie__: python's pickle isn't the internal representation
14:40:15 <pie__> davean, yeah good point
14:40:16 <davean> pie__: Things like bytes, cereal, binary do what pickles does
14:40:37 <davean> which is what I was talking about with autoderiving serializations
14:40:53 <Boarders> getting compact regions to dump its internal representation is very dicey in my experience
14:41:03 <Boarders> you can only read it back in using exactly the same binary
14:41:11 <sclv> (actually it looks like the api is pretty reasonable)
14:41:16 <davean> Boarders: right
14:41:27 <OmegaDoug> zachk: I have some parsers in a do block, maybe I can use a let statement to set what the next parser should be
14:42:27 <davean> pie__: and to the above point theres a lot pickle can't serialize
14:42:32 <Gurkenglas> Solonarv, could one implement (forall f. C f => f a) -> (forall f. C f => HKD f a) if C includes Identity?
14:42:53 * hackage dualizer 0.1.0.0 - Automatically generate dual constructions.  http://hackage.haskell.org/package/dualizer-0.1.0.0 (sellout)
14:42:54 <Gurkenglas> simpler: f a -> HKD f a
14:44:10 <Solonarv> Not sure, tbh.
14:44:25 <Solonarv> You can definitely do it with an overlapping instance, but idk if there's a cleaner way.
14:44:31 <pie__> davean, yeah I'm not trying to do anything sketchy like serialize file handles or something
14:45:04 <pie__> also trying to figure out if I even need to do this...
14:45:05 <merijn> ugh...I wish the persistent repo didn't use submodules so I didn't have to resort to git everytime I have to commit something :\
14:45:29 <davean> pie__: 99% chance just adding a deriving makes it all work
14:45:50 <pie__> davean, I mean if I even need to cache this.
14:46:22 <pie__> I thought the operation was slow but it might have just been some other problem.
14:47:02 <Boarders> pie__: with binary literally all you do is turn on {-# LANGUAGE DeriveGeneric#-} data A deriving generic; instance Binary
14:47:40 <Boarders> and then use these functions: http://hackage.haskell.org/package/binary-0.8.6.0/docs/Data-Binary.html#v:encodeFile
14:47:55 <Boarders> so it is not much work at all if you want a quick and dirty option
14:48:11 <pie__> thanks
14:48:42 <Boarders> you might need to supply type signatures or use type applications or similar to get it going
14:48:53 <Boarders> if it can't figure out what you are trying to decode from the file
14:50:53 * hackage strict-tuple 0.1.2 - Strict tuples  http://hackage.haskell.org/package/strict-tuple-0.1.2 (mitchellwrosen)
14:53:10 <pie__> Does having the strictness declarations on all these data constructor fields mean that the data structure is alreday strict and i dont have to use deepseq on it or somesuch?: https://hackage.haskell.org/package/language-javascript-0.6.0.11/docs/Language-JavaScript-Parser-AST.html
14:53:27 <pie__> (to be fair, I'm not sure how you could even have a lazy parser)
14:54:07 <monochrom> !String does not deepseq the string. Ever.
14:54:44 <monochrom> Not sure about JSAnnot, it looks like a rabbit hole.
14:55:17 <pie__> I mean ! is used for all of the fields everywhere in there. Googling what ! means says it ensures that it has WHNF, and if you have WHNF recursively, that would mean its basicalyl strict, no?
14:55:18 <merijn> Anyone know how to check on github who has commit rights to a repo?
14:55:28 <merijn> I need to badger some people into merging my shit upstream >.>
14:56:08 <wroathe> merijn: There should be a "contributors" tab
14:56:12 <monochrom> Your sentence is correct but it is vacuous for String i.e. [Char]. [Char] isn't recursively !ed.
14:56:21 <merijn> wroathe: Contributors shows everyone who has commits in the repo
14:56:36 <merijn> wroathe: For large open source projects that number is far larger than the committers
14:56:36 <monochrom> But you could explore what happens to JSAnnot etc.
14:57:37 <Welkin> merijn: look at who has merged pull requests
14:57:59 <wroathe> merijn: https://developer.github.com/v3/repos/collaborators/#review-a-users-permission-level looks like the API can do that
14:58:03 <pie__> monochrom, ok i see what you mean
14:58:44 <pie__> monochrom, so its strict up to the strings in CommentAnnotation
14:58:50 <monochrom> You should also read my http://www.vex.net/~trebla/haskell/strict-field.xhtml for a gotcha.
14:58:53 <merijn> The good news is: Fixing my persistent problem consisted of a single 5 line patch that someone else already wrote. Now I just need to beat someone into merging it >.>
14:58:54 <pie__> what about ![...] ?
14:58:58 <pie__> monochrom, ok
14:59:15 <Welkin> merijn: the bad news is you are still using persistent
14:59:18 <pie__> monochrom, bad link?
14:59:38 <monochrom> TLDR just because the type has ! doesn't mean a producer always produces WHNF.
14:59:51 <merijn> Welkin: So?
15:00:07 <monochrom> Good link but many people need to keep trying.
15:00:26 <monochrom> As a general rule I always test URLs one last time before I dare to post at all.
15:00:35 <pie__> yeah i do that too
15:00:39 <pie__> weird, im getting a not found
15:01:28 <pie__> monochrom, what happens for ![...] fields?
15:01:32 <merijn> monochrom: Ah, looks like your link is broken with https
15:01:52 <pie__> ah. Im using Https Everywhere
15:01:53 <merijn> So pie__ probably (like me) has HTTPS Everywhere
15:01:54 <monochrom> But this time I also took the care of going http sans s
15:02:12 <monochrom> However I also got https to work.
15:02:31 <monochrom> At least last night.
15:02:35 <geekosaur> pie__, WHNF is either [] (emoty) or the (:) of the first element
15:02:44 <geekosaur> note, not the *value* of that element
15:02:51 <geekosaur> just its cons cell
15:02:59 <monochrom> [Char]'s non-strictness applies to all [a]'s
15:03:48 <monochrom> data !s is never the full story.
15:04:06 <pie__> ok. so the list of JSStatements in "JSStatementBlock !JSAnnot ![JSStatement] !JSAnnot !JSSemi" are not necessarily evaluated by the time I receive the structure?
15:05:13 <monochrom> If you have a ! field, a producer can still produce a parent thunk. The ! just means that when someone evaluates the parent for real, you get a chain reaction of also evaluating the child.  But nothing says the parent will be evaluated ever.
15:05:44 <monochrom> And if you don't have a ! field, a producer can still do its good deed of fully evaluating everything before handing it to you.
15:06:16 <monochrom> There are many moving parts. Do not trust one single annotation or lack-of.
15:06:30 <pie__> monochrom, yeah I got that
15:06:41 <pie__> thanks for clarifying
15:08:19 <monochrom> In particular parsers almost cannot avoid handing you a normal form.  It is not like it can hand you a substring without first checking it, for example.
15:09:44 <pie__> monochrom, exactly
15:13:22 <oo_miguel> excuse my inexperiecene.. but I just have written something as : grouBy (\x y->fst x==fst y) ... I assume there is a much more elegant way to write this, but I did not manage to find it.. experimented with comparing and curry/uncurry but without success
15:13:35 <oo_miguel> groupBy*
15:14:03 <merijn> oo_miguel: groupBy (comparing fst)
15:14:06 <merijn> :t comparing
15:14:07 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
15:14:08 <oo_miguel> nah
15:14:32 <oo_miguel> groupBy expexts a function that returns true or false
15:14:33 <oo_miguel> not an ordering
15:14:38 <merijn> ah
15:14:47 <monochrom> "on" may help.
15:14:48 <merijn> Then: groupBy ((==) `on` fst)
15:14:55 <oo_miguel> aah
15:14:57 <monochrom> Yeah, that.
15:15:01 <johnw> you need groupOn: https://wiki.haskell.org/List_function_suggestions#groupOn_and_sortOn
15:15:02 <oo_miguel> merijn: thenks a lot
15:15:22 <monochrom> Yes I want Groupon to come back, too. :)
15:15:37 <sproingie> use your groupOn to get 80% off your next haskell download
15:15:51 <monochrom> Groupon and CrowdSort.
15:17:47 <oo_miguel> merijn: monochrom: johnw  thank you very much for the answers. I will use the `on` solution for now. In fact now I remember already using it some time before, just forgot :(
15:17:54 <oo_miguel> :)
15:18:05 <oo_miguel> works perfectly, thanks again
15:18:50 <johnw> a proper groupOn would only call the accessor once per element
15:22:46 <oo_miguel> johnw: makes sense
15:24:47 <oo_miguel> oh
15:26:21 <oo_miguel> just tested : groupBy (<=) [1,2,2,3,1,2,0,4,5,2] 
15:26:30 <oo_miguel> and i get: [[1,2,2,3,1,2],[0,4,5,2]]
15:30:15 <jle`> nice :)
15:30:50 <oo_miguel> hehe, yeah sorry forget it. I confused two different groupBy
15:31:23 <oo_miguel> there is another one in Data.List.GroupBy and I was unaware it differs from the one in Data.List which I am actually using
15:58:46 <berndl> Say I have: type Implies = forall a b. (a -> b) -> Either (Not a) b
15:58:58 <berndl> and: f :: (a -> b) -> a
15:59:41 <berndl> I want to transform f into a function g :: Either (Not a) b -> a
16:00:05 <berndl> By the way: type Not a = a -> Void
16:01:35 <berndl> If I have a proofOfImplies :: Implies and apply it to f, I get Either (Not (a -> b)) a, which is not what I want.
16:01:50 <jle`> berndl: sounds like something djinn could tell you perhaps
16:02:19 <jle`> just to be clear, f is defined to work for *specific* A, B ?
16:02:36 <jle`> or is it forall b., or forall a. ?
16:03:03 <berndl> The latter.
16:03:15 <jle`> oh um, i gave three choices
16:03:26 <jle`> so the final one? f :: forall a. (a -> B) -> a ?
16:03:44 <berndl> Oops. I mean forall a b. (a -> b) -> a
16:04:16 <jle`> berndl: if that's the case, you can instantiate a as Void
16:04:21 <jle`> and use absurd to implement g
16:04:41 <berndl> Ah, true.
16:04:47 <berndl> What if they are specific though?
16:05:39 <jle`> then i have to ask about g; is g also forall a b., or specific based on f ?
16:05:51 <berndl> based on f
16:06:26 <jle`> if it is specific A, then you can call `f id` to get an A
16:06:32 <jle`> so g _ = f id
16:06:58 <jle`> if it is specific B, then you can instantiate a as Void and use absurd
16:07:46 <berndl> And if they are both specific?
16:09:48 <jle`> i'm not sure if there is a way in general
16:10:02 <jle`> but you can do it case by case based on what A and B you have
16:10:32 <jle`> hm oh, you're saying, if we have `proofOfImplies`
16:11:01 <berndl> Yes. Can't I somehow map proofOfImplies to the (a -> b) part of (a -> b) -> a?
16:11:33 <jle`> what do you mean by 'map'
16:11:36 <Solonarv> proofOfImplies is the wrong way around
16:11:51 <Solonarv> (or rather, its type is)
16:12:59 <berndl> jle`: like since (->) is a profunctor, maybe I can lmap it or something.
16:13:25 <berndl> Solonarv: wrong way?
16:13:30 <Solonarv> No, that still doesn't work. lmap on (->) is just function composition.
16:13:32 <jle`> lmap what?
16:13:44 <jle`> implies, or f ?
16:14:15 <berndl> implies
16:14:31 <berndl> I don't think that works though.
16:15:08 <berndl> FYI: I just want to write out a proof of https://en.wikipedia.org/wiki/Peirce%27s_law#Other_proofs_of_Peirce's_law in Haskell.
16:22:11 <Solonarv> berndl: you need to go from ((p -> q) -> p) to (Either (Not p) q -> p), so you need to go from (Either (Not p) q) to (p -> q)
16:22:59 <Solonarv> also, the the equivalence between (p -> q) and (Either (Not p) q) is a theorem, which means you can write a function of that type
16:23:06 <Solonarv> (well, two functions, one for each direction)
16:25:12 <berndl> Solonarv: You are right. I think it will be better to have functions for both directions.
16:25:44 <bwe> lyxia: import Network.HTTP.Types.URI (urlEncode) -- did the job
16:27:56 <Solonarv> Huh, I got stuck on proving double negation.
16:39:41 <Solonarv> ah, no wonder - ¬¬A doesn't imply A in intuitonistic logics! which I think System Fω (i.e. Haskell) corresponds to?
16:39:58 <monochrom> Yes.
16:40:13 <Solonarv> iow you can't write a (total) function '((a -> Void) -> Void) -> a' in Haskell
16:40:55 <berndl> That's right.
16:42:37 <Solonarv> er... can you even write a total '(a -> b) -> Either (a -> Void) b'?
16:43:04 <hpc> @djinn (a -> b) -> Either (a -> Void) b
16:43:04 <lambdabot> -- f cannot be realized.
16:43:10 <hpc> probably not
16:43:26 <Solonarv> I don't think so either
16:43:48 <Solonarv> so, uh.. I don't think that proof works in Haskell, berndl
16:43:50 <hpc> it's probably easier to say what you can write
16:43:55 <hpc> amusingly enough
16:43:59 <hpc> rather than what you can't not write
16:44:26 <berndl> Solonarv: The proof works if you assume double negation.
16:45:35 <Solonarv> Indeed, but double negation (or rather, the ¬¬A -> A half) isn't a theorem in the logic corresponding to Haskell
16:45:43 <berndl> Solonarv: https://softwarefoundations.cis.upenn.edu/current/lf-current/Logic.html#lab195 (scroll to the bottom of the page).
16:46:16 <monochrom> You can say "double negation elimination" for "¬¬A -> A" :)
16:46:58 <monochrom> "A short formula can be saved by a mouthful of a long phrase" :)
16:47:14 <Solonarv> heh
16:47:50 <monochrom> "double plus unungood considered not good enough"
16:48:12 <Solonarv> berndl: you did notice that the page you linked uses Coq, right? its type system is more powerful than Haskell's.
16:48:26 <Solonarv> I assumed you were trying to do the proof in Haskell, since this is #haskell.
16:48:53 <berndl> Solonarv: Yes. I was wanted to play around with this in Haskell.
16:49:01 <berndl> s/was/just/
16:49:08 <Solonarv> ah,, I see
16:49:36 <koz_> Solonarv: You're right about double negation elimination not applying in Haskell in general. jle` actually blogged about that someplace.
16:49:44 <koz_> I _think_ in Introduction to Singletons somewhere.
16:55:49 <lukelau> Is there a function like “[IO a] -> IO a” that runs a list of actions sequentially, returning the first one that doesn’t throw?
16:58:28 <Solonarv> lukelau: asum
16:58:35 <Solonarv> % :t asum
16:58:35 <yahb> Solonarv: forall {t :: * -> *} {f :: * -> *} {a}. (Foldable t, Alternative f) => t (f a) -> f a
16:58:46 <Solonarv> with t ~ [], f ~ IO
17:00:05 <lukelau> Solonarv: TIL Alternative IO. Thanks!
17:00:32 <Solonarv> yup, it's a useful instance that I often forget about
17:00:41 <koz_> % :t asum @[] @IO
17:00:42 <yahb> koz_: forall {a}. [IO a] -> IO a
17:00:51 <koz_> Yay for TypeApplications.
17:03:28 <lavalike> for sure
17:09:49 <Solonarv> hmm...
17:10:21 <Solonarv> @djinn ((a -> Void) -> Void) -> (a -> b) -> Either (a -> Void) b
17:10:21 <lambdabot> -- f cannot be realized.
17:15:24 <c_wraith> demonstrating Haskell is an intuitionist logic. 
17:16:40 <Solonarv> but I gave double negation elimination as an input?
17:17:31 <c_wraith> you gave not (not a) as an input. but in an intuitionist logic, just like in Haskell, that doesn't prove a
17:19:04 <Solonarv> er, oops, that's a typo
17:19:16 <Solonarv> @djinn (((a -> Void) -> Void) -> a) -> (a -> b) -> Either (a -> Void) b
17:19:16 <lambdabot> -- f cannot be realized.
17:19:25 <Solonarv> doesn't seem to change anything
17:19:39 <c_wraith> that'd more interesting, at least.
17:19:55 <Solonarv> Now I actually gave it double negation elimination, lol
17:20:07 <Solonarv> let's see if I'm smarter than djinn
17:20:07 <c_wraith> indeed
17:20:49 <c_wraith> I'm guessing that still depends on the law of the excluded middle.
17:20:55 <c_wraith> which you also don't have.
17:21:23 <c_wraith> you seem to need a or (not a) as a theorem to make that work.
17:23:26 <c_wraith> and if you give djinn *that*, the whole thing is probably trivial.
17:25:11 <Solonarv> oh, indeed
17:25:26 <Solonarv> The proof is just 'flip second excluded_midle'
17:25:37 <Solonarv> (with excluded_middle :: Either (Not a) a)
17:26:09 <Solonarv> well, here it is: https://gist.github.com/Solonarv/a21e1da8f5d55a68cce39bceeb9a90d6
17:26:27 <Solonarv> (nullary typeclasses are neat!)
17:27:00 <Solonarv> mind you, I haven't thrown this at a typechecker.
17:27:29 <Solonarv> (also, pointfree is nice for proving implications)
17:29:16 <berndl> Let me check.
17:30:13 <Solonarv> @djinn (((a -> Void) -> Void) -> a) -> Either (Not a) a
17:30:13 <lambdabot> -- f cannot be realized.
17:30:26 <Solonarv> @djinn (((a -> Void) -> Void) -> a) -> Either (a -> Void) a
17:30:26 <lambdabot> -- f cannot be realized.
17:32:30 <c_wraith> I suspect you actually can't prove the excluded middle from double elimination negation. but I'm not sure of that. I might be missing something clever.
17:32:31 <berndl> Solonarv: I get peirce.hs:3:23: error: parse error on input ‘>>>’
17:34:33 <systemfault> berndl: replace (>>>) with ((>>>)) perhaps
17:34:52 <berndl> Ah, right.
17:36:20 <berndl> OK, not it complains about ExcludedMiddle: GHC doesn't yet support impredicative polymorphism
17:36:25 <berndl> s/not/now
17:37:17 <Solonarv> give me a few minutes and I'll fix it
17:37:48 <monochrom> Prove (Either (a -> Void) a -> Void) -> Void
17:38:27 <monochrom> BTW does djinn know Not?
17:38:38 <c_wraith> it looks like it does
17:38:48 <monochrom> @djinn a -> Not a -> a
17:38:48 <lambdabot> f a b = void (b a)
17:39:20 <c_wraith> so yes. also, djinn at its finest
17:39:40 <monochrom> Yeah, prove Not (Not (Either (Not a) a))
17:40:32 <monochrom> Grand Classical-Intuitionistic Metatheorem: p is provable in classical logic iff not(not p) is provable in intuitionistic logic.
17:41:45 <c_wraith> I'm not sure if that helps in this particular weird case.
17:43:30 <monochrom> You were wondering how to go from double negation elimination to excluded middle.  So first prove double-negated excluded middle, then eliminate the double negation.
17:43:33 <c_wraith> p is not Either a (Not a). p is (Not (Not a) -> a) -> Either a (Not a)
17:44:41 <Solonarv> ooh, I see!
17:44:43 <monochrom> djinn didn't do it because you gave it a weaker premise.  Ideally you would give it the rank-2"(forall x. not(not x) -> x) -> excluded middle"
17:44:57 <c_wraith> hmm, that's true.
17:45:02 <monochrom> But djinn can't do rank-2 either.
17:46:00 <berndl> Here's my proof of Peirce: https://termbin.com/wxjv
17:46:10 <benzrf> monochrom: thats not true for FOL
17:46:14 <benzrf> only propositional
17:46:30 <benzrf> you need to do extra stuff at the quantifiers, for FOL
17:46:40 <c_wraith> berndl, bird tracks! don't see them too often. :)
17:47:17 <berndl> Really? I thought everyone uses them in lhs files.
17:47:42 <monochrom> Some people use "\begin{code}" instead.
17:47:50 <geekosaur> lhs itself has kinda vanished except as part of blog posts
17:47:52 <c_wraith> I feel like I see the latex-style just as much. and both are rare.
17:48:11 <Solonarv> geekosaur: I was about to say that
17:48:15 <monochrom> Ironically lhs is unsuitable for blog posts as I explained yesterday.
17:48:35 <Solonarv> I missed that, but I'm curious. Care to repeat yourself?
17:49:01 <monochrom> For good expositions, almost always: code order != exposition order.
17:49:47 <monochrom> In particular, yesterday some of us observed that if your very first lines of code is a dozen LANGUAGE pragmas it's offputting.
17:49:51 <berndl> But code order is a non-issue in Haskell.
17:50:11 <berndl> ...except for the pragmas
17:50:27 <Solonarv> I suppose you could just have collapsible sections
17:51:11 <Solonarv> Bah, mine doesn't typecheck even after fixing the helpers. I don't care enough to fix it.
17:51:29 <monochrom> I conjecture that people who use lhs for blog posts most probably have never seen a real literate programming system --- either Knuth's web or Ramsey's noweb.
17:52:14 <monochrom> Because real literate programmers actually knew this issue and built a mechanism for allowing article order != code order.
17:52:14 * Solonarv doesn't use lhs for blog posts, but has something else on the back-burner
17:52:27 <berndl> I use lhs for personal notes.
17:52:33 <Solonarv> I hadn't considered that issue, though.
17:53:22 <monochrom> Their tool chains also consists of two programs, not one.
17:53:47 <monochrom> For example Knuth's is a "weave" for emitting the article and "tangle" for emitting the code.
17:54:55 <monochrom> Yes that's right you actually neither post the file you wrote by hand nor give that file to the compiler.  You post the output of weave, and you give the output of tangle to the compiler.
17:55:16 <Solonarv> Well, that makes sense.
17:56:00 <monochrom> In comparison, Literate Haskell is a joke.
17:56:19 <berndl> Well, for small stuff, the Bird style lhs is perfect in my opinion.
18:01:05 * Solonarv reads the wikipedia article on Literate Programming
18:09:18 <monochrom> Whee idler purge.
18:13:00 <jackboy[m]> Anyone used or know excel macro?
18:13:26 <koz_> Someone needs to link that comonadic spreadsheet thingo. :P
18:15:18 <monochrom> Like this? http://blog.sigfpe.com/2006/11/from-l-theorem-to-spreadsheet.html
18:16:13 <monochrom> Oh, this: http://hackage.haskell.org/package/ComonadSheet
19:24:53 * hackage dualizer 0.1.0.1 - Automatically generate dual constructions.  http://hackage.haskell.org/package/dualizer-0.1.0.1 (sellout)
20:25:42 <AfC> Not sure why you're talking about literate programming just there, but if you haven't seen it:
20:27:16 <AfC> *inliterate*, https://github.com/diffusionkinetics/open/tree/master/inliterate (docs), https://github.com/diffusionkinetics/open/blob/master/plotlyhs/gendoc/GenDocInlit.hs (code example), https://glutamate.github.io/plotlyhs/ (rendered result) 
20:29:22 * hackage hw-dsv 0.3.3 - Unbelievably fast streaming DSV file parser  http://hackage.haskell.org/package/hw-dsv-0.3.3 (haskellworks)
20:29:57 <AfC> Looks really promising. It probably needs some work, but I like the mix of markdown and executable sections
20:30:08 <AfC> ^ Solonarv, monochrom 
20:30:33 <Solonarv> oh damn, that's surprisingly similar to my back-burner project
20:30:49 <Solonarv> (except mine's supposed to be polyglot and talk to REPLs)
20:42:31 <geekosaur> the discussion was because ghc has one "built in". except its rather sucktacular
20:45:55 <nyc> AfC: Spiffy!
20:48:33 <nyc> I'll have to try it out if I can get my laptop working again.
21:13:28 <fresheyeball> anyone know how to use a PrimaryKey with `in_` in Beam?
21:20:06 <jackdk_> Axman6, maybe, if he's around?
21:35:23 * hackage persist 0.1.1.1 - Minimal serialization library with focus on performance  http://hackage.haskell.org/package/persist-0.1.1.1 (minad)
21:42:51 <portnov> hi all.
21:44:46 <portnov> @src (++)
21:44:46 <lambdabot> []     ++ ys = ys
21:44:46 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
21:44:46 <lambdabot> -- OR
21:44:46 <lambdabot> xs ++ ys = foldr (:) ys xs
21:50:52 <dmwit> Hi, portnov.
22:06:35 <butterthebuddha> Given a type "data A = A1 Int | A2 String", how would I use lens to write a function "(Int -> Int) -> A -> A -> Maybe A"
22:07:19 <Solonarv> what is that function supposed to do?
22:07:44 <butterthebuddha> Whoops, the first arugment should be Int -> Int -> Int
22:08:24 <Solonarv> why is the return type 'Maybe A'?
22:08:36 <jle`> butterthebuddha: what is the function you want to write?
22:08:38 <jle`> without using lens
22:08:59 <jle`> remember, lens can't help you write any functions magically that can't be written without them
22:09:12 <butterthebuddha> Lets call the function "fun". An implementation without lens is:
22:09:13 <jle`> so if you can give us the 'by-hand' implementation
22:09:20 <jle`> we can maybe think about what lens can do to help
22:09:31 <butterthebuddha> fun f (A1 x) (A1 y) = Just $ A1 $ f x y
22:09:37 <butterthebuddha> fun _ _ _ = Nothing
22:10:02 <jle`> you can use preview _A1, maybe, to get an A -> Maybe Int
22:10:11 <jle`> and do f <$> preview _A1 x <*> preview _A1 y
22:10:58 <Solonarv> or: fun f = liftA2 f `on` preview _A1
22:11:36 <Solonarv> (actually, those will get you a 'Maybe Int', wrap the whole thing in 'fmap (review _A1)')
22:12:15 <jle`> yeah, instead of asking "how would i use lens to write this function", it might be more productive to have a specific function in mind already implemented, and ask how lens might be able to help simplify your implementation
22:13:19 <jle`> yeah, or also `review _A1` is just `A1`, so in this case the non-lensy version might be clearer for that last part
22:13:58 <jle`> hm, maybe you can do something clever with a double traversal
22:16:09 <Solonarv> is there a 'Prism s t a b -> Prism s' t' a' b' -> Prism (s, s') (t, t') (a, a') (b, b')' combinator? that seems like something that would exist.
22:19:11 <jle`> if a = b + q, and c = d + r, then a*c = b*d + b*r + q*d + q*r
22:19:46 <jle`> such a thing would only be possible if you could turn b*d + b*r + q*d + q*r into (b*d) + (some combination of things not involving b or d)
22:19:55 <Solonarv> Hm.
22:20:11 <Solonarv> what if they're simple prisms?
22:20:31 <jle`> what i said applies to simple prisms in specific
22:20:47 <jle`> if by simple you mean Prism'
22:20:54 <Solonarv> I did indeed. Hm.
22:21:38 <jle`> hm but actually i guess it would be possible if we take the b*d branch as success, and all b*r + q*d + q*r as failure
22:21:56 <Solonarv> Yes, that's what I was thinking.
22:22:41 <Solonarv> 'alongside' has the right shape, but doesn't accept prisms.
22:23:17 <jle`> we only need a Setter here
22:24:34 <Solonarv> I was being inexact, but I'm pretty sure alongside still won't accept a prism.
22:26:59 <Solonarv> nyeh, I'm too tired for type tetris
22:34:06 <Gurkenglas> (b -> t) -> (s -> Either t a) -> (b' -> t') -> (s' -> Either t' a') -> ((b,b') -> (t,t')) -> ((s,s') -> (Either (t,t') (a,a'))
22:34:37 <Gurkenglas> given s and s' we can construct an Either t a and an Either t' a', but that doesn't let us make an Either (t,t') (a,a'), because one might be left and the other right
22:34:53 <Gurkenglas> So what jle` said before he wrongfully corrected himself afaic
22:35:11 <jle`> i should have more faith in myself
22:35:29 <jle`> at best we can get a Traversal
22:35:36 <jle`> but actually in this case, a traversal might be all we need
22:35:48 <jle`> (actually, can we even get a traversal?)
22:36:08 <Gurkenglas> You could get a cross-producty traversal I think?
22:36:26 <Gurkenglas> but it would not fit with the laws we have
22:36:56 <Gurkenglas> You could lift grates like this, ie zipping recipes
22:37:49 <Gurkenglas> the way we zip ZipList Int and the way we zip ZipList String would let us zip (ZipList Int, ZipList String)
22:38:47 <Gurkenglas> ("doesn't fit with the laws" means "you could inhabit the Traversal' type, but not the Traversal type" i think)
22:40:37 <Gurkenglas> (s -> Either t a) and (s' -> Either t' a') could make an Either s s' -> Either (Either t t') (Either a a')
22:41:03 <Gurkenglas> And b -> t and b' -> t' don't have a problem with that form either
22:42:07 <Gurkenglas> ah, lens has that and calls it without
22:45:14 <Gurkenglas> when you are correct half the time and are 50% confident each time, you shouldn't keep correcting your estimate of your correctness on each anecdote :)
22:55:47 <hololeap> can i bring a constructor lifted by DataKinds back down to data level so i can pattern match on it?
22:57:32 <Solonarv> Not directly, but singletons probably has your back.
22:57:46 <hololeap> oh right
23:18:48 <jle`> hololeap: remember that lifted kinds and the original types are not linked by ghc at all
23:19:09 <jle`> their only relationship is that they have the same typed names
23:19:12 <koz_> jle`: Is this where one of us plugs Introduction to Singletons again? :P
23:19:41 <jle`> heh, solonarv already pointed in the right direction :)
23:24:07 <danso> is there any wizardry that can generalize functors, bifunctors, n-ary functors into one typeclass? 
23:30:58 <jle`> yes, Iceland_Jack has been tweeting some examples over the past months or so
23:31:05 <jle`> but it's not exactly user-friendly
23:31:25 <koz_> jle`: Has anyone written it up in a longer form (blog post or something)?
23:31:56 <jle`> hm, i don't think so. it's mostly just some exploring on his part i believe
23:31:59 <jackdk_> koz_ there was this from a year or so ago: http://gelisam.blogspot.com/2017/12/n-ary-functors.html
23:32:18 <jle`> oh hey that one is neat :)
23:33:13 <danso> haskell is insane
23:33:21 <danso> we are all lunatics
23:33:22 <koz_> danso: Haskell is _honest_.
23:33:34 <koz_> Other languages are as bad or worse, they're just not as honest about it. :P
23:34:09 <jackdk_> I'm reminded of that lovecraft quote: "The most merciful thing in the world, I think, is the inability of the human mind to correlate all its contents."
23:47:36 <Lycurgus> hs is a niche lang, it's good for where you need its purity but that's hardly all there is to what society wants out of computing. Peak hs is already vorbei.
23:51:48 <jle`> Lycurgus: hm, i wouldn't call purity haskell's main benefit
23:51:50 <jle`> it's up there though
23:52:09 <jle`> for me, it's the type safety and ability to help write (even imperative) code faster with type directed development
23:52:15 <jle`> that's the thing that makes me use it in the general case
23:52:32 <jle`> i end up using haskell for must of my imperative ('non-pure') code because of this
23:53:08 <Lycurgus> well that and concision but there's such an onerous curve to get to the point where the concision is easily wieldable that the purity become most prominent
23:53:12 <jle`> haskell isn't a niche lang, it's a general-purpose language :)
23:53:30 <jle`> eh, consiceness is probably the least "actually useful" part about haskell, i think
23:53:44 <jle`> it's cute at the surface level but doesn't provide nowhere near the benefit of the type safety
23:54:14 <Lycurgus> in a world where the typical programming generation is 10 years or less, a lang that is a beast to learn is going to be self limiting
23:54:31 <jle`> that's why i don't really like those 'show off haskell' snippets that are all code golfy
23:54:36 <jle`> it literally is the least useful part about haskell
23:54:37 <sternmull> jle`: If you just want a reasonably typesafe to write efficient imperative code then C++ would be the logical choice.
23:54:58 <jle`> C++ doesn't offer anything near the typesafety to be effective at any sort of safety
23:56:25 <jle`> compared to the expressivity of Haskell's type system, C++ might as well be python
23:56:36 <Lycurgus> "code golfy" code done like a golf game?
23:56:39 <sternmull> both languages have ways to escape the typesystem if you really want. What do you consider the strongest advantage of the Haskell typesystem?
23:56:51 <monochrom> C++ is more cumbersome to achieve the same type safety.
23:57:07 <jle`> sternmull: both languages have ways to escape the type system, but only in one can you embrace the type system
23:57:26 <jle`> if you want to be outdoors, you can live in a house, or in a backyard
23:57:32 <jle`> both let you equally access the unsafe outdoors :P
23:57:59 <jle`> sternmull: type inference, algebraic data types, type-directed development
23:58:02 <Lycurgus> how can you escape the type system in haskell?
23:58:11 <monochrom> And C++ lacks higher kinds.
23:58:18 <rotaerk> by running away really fast
23:58:23 <Lycurgus> lol
23:58:28 <jle`> yeah, higher-kinded abstractions in Haskell are a big deal
23:58:38 <jle`> Lycurgus: it's not necessarily "escape", but also "choose your degree of type safety"
23:58:48 <Lycurgus> ok
23:58:51 <rotaerk> C++ template-templates are sort of higher-kinded types
23:58:56 <jle`> for example, you can use a list if you want (0 or many) items, and you can choose Maybe if you want (0 or 1) items
23:59:28 <jle`> you can always use list instead of maybe
23:59:31 <sternmull> Lycurgus: unsafePerformIO, unsafeCoerce.
23:59:34 <jle`> but using maybe lets you guaruntee properties of your system
23:59:36 <monochrom> I would consider Rust today if I wanted the strength of C++.
