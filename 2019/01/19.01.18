01:13:56 <cocreature> dminuoso: even more amazing is that you don’t need `orElse` because you can just use <|> :)
01:15:13 <dminuoso> % :t (<|>) @STM
01:15:13 <yahb> dminuoso: STM a -> STM a -> STM a
01:15:26 <dminuoso> cocreature: Yeah, it's pretty neat indeed. :)
01:41:31 <jaarod2> hello
01:42:26 <Ariakenom> jaarod2: hello
01:43:08 <jaarod2> does a function like foldl' need to have a tail call to ensure that memory consumption will stay constant over time?
01:45:07 <Ariakenom> jaarod2: foldr is non tail call and can also run in constant time, I believe
01:45:32 <Ariakenom> I mean constant space
01:45:37 <jaarod2> not when used with a strict function
01:45:47 <jaarod2> strict in the second element
01:46:33 <jaarod2> ie, foldr (+) 0 [1..]
01:47:12 <jaarod2> I'm basically asking, if seq is enough for foldl', or do we also need tail call?
01:47:45 <jaarod2> intuition and limited testing says we need both, but then we have article saying that tail calls aren't important in haskell.
01:57:21 <inkbottle> data A = A {a::Int,b::Int,...f::Int}|B...; getd a @ (A _) = ...; "the constructor A should have 6 args but has been given 1"; can I deal with that w/o 6 underscores?
01:57:49 <tdammers> inkbottle: yes. getd a @ A { } = ...
01:58:10 <tdammers> inkbottle: it even works for non-record constructors
01:58:18 <inkbottle> thanks
02:02:11 <jaarod2> Ariakenom, you're right though that foldr runs in constant time if function is lazy in second argument, ie 
02:02:23 <jaarod2> foldr (\x acc -> x*x : acc) [] [1..]
02:03:46 <Ariakenom> jaarod2: foldr (:) [] runs in constant extra space I'd think
02:03:59 <jaarod2> yes
02:04:12 <jaarod2> that's what I meant to say
02:07:28 <WilliamHamilton[> how would I write the function b in this example? https://pastebin.com/raw/iivBqLK4
02:08:40 <WilliamHamilton[> do I have to use the constraints package to make the dependency explicit, or is there a lightweight way?
02:09:39 <WilliamHamilton[> the error if I try to use show is `Could not deduce (Show a) arising from a use of ‘show’ from the context: Bar a`
02:11:21 <MarcelineVQ> dunno about that but be sure to include any language extensions you're using in your paste if you're using any
02:11:48 <MarcelineVQ> That lets people who want to see what's wrong try it easily themselves, including the errors as comments is good too
02:16:04 <WilliamHamilton[> MarcelineVQ: right! updated: https://pastebin.com/raw/C1WfnchU
02:18:02 <dminuoso> Shouldn't `foldr` be linear over list size in stack consumpion?
02:19:07 <dminuoso> % foldr (+) 0 [1..100000000]
02:19:08 <yahb> dminuoso: *** Exception: heap overflow
02:19:17 <dminuoso> Oh well, what a small heap you have!
02:20:59 <dminuoso> WilliamHamilton[: I think you confused the instance context with superclass.
02:21:04 <jaarod2> > foldr (+) f [1..] :: Expr
02:21:06 <lambdabot>  1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + (11 + (12 + (13 + (14 + (1...
02:21:54 <WilliamHamilton[> dminuoso: what do you mean?
02:22:13 <jaarod2> > foldl' (+) f [1..15] :: Expr
02:22:15 <lambdabot>  f + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15
02:23:00 <jaarod2> s/f/0
02:25:23 <dminuoso> WilliamHamilton[: The fact that you wrote `instance (Show a, Foo a) => Bar a` does not allow you to conclude that Bar entails Show.
02:25:48 <dminuoso> WilliamHamilton[: It'd be `class Show a => Bar a` that describes this fact.
02:26:50 <WilliamHamilton[> dminuoso: right, thank you!
02:28:25 <dminuoso> WilliamHamilton[: More specifically your instance just brings the dictionary of `Show a` into scope, so that you could use that dictionary inside its `where` clause.
02:29:36 <jaarod2> your other problem: _show does not exist
02:29:53 <WilliamHamilton[> dminuoso: thanks for the clarification!
02:30:06 <dminuoso> jaarod2: If you start an identifier with an underscore to the right side its just a typed hole.
02:30:12 <WilliamHamilton[> jaarod2: if I write the correct class declaration I can just use show, which is what I wanted
02:30:27 <jaarod2> dminuoso, I doubt that was his intention
02:30:36 <jaarod2> and it only does that, if _show does not exist
02:30:38 <WilliamHamilton[> oh yes that was only a way of showing the error (I use holes during development)
02:31:11 <jaarod2> WilliamHamilton, oh, so that was intentional. nm
02:31:30 <WilliamHamilton[> jaarod2: thanks nonetheless!
02:34:57 * hackage slate 0.13.0.0 - A note taking CLI tool.  http://hackage.haskell.org/package/slate-0.13.0.0 (evuez)
02:39:07 <dminuoso> WilliamHamilton[: It's related to the fact that instance constraints are not taken into consideration for instance resolution.
02:40:58 <WilliamHamilton[> dminuoso: right, and so the only things I can use to reason about classes is the class declaration; I can never use the instances, right? Or can I with the constraints package? (just curious , in my case modifying class declaration suffices)
02:41:49 <dminuoso> WilliamHamilton[: No, the entailment (:-) from constraints just allows you to reify superclass relationships.
02:42:06 <dminuoso> (And it allows you to reflect on them)
02:42:35 <WilliamHamilton[> dminuoso: so it's just another way of writing the class instance (plus I can manipulate them)?
02:43:21 <v0d1ch> how did you understand continuations, lots of head banging or there is another path ? my head hearts from trying to write monad instance for `Cont`
02:43:48 <dminuoso> v0d1ch: I properly understood them when I understood the evaluation model of Haskell.
02:44:22 <v0d1ch> you mean lambda calculus basically
02:45:00 <dminuoso> v0d1ch: No more in the sense of "when I write a haskell program, how does evaluation really work" - in my case it was the excercise of understanding why the notion of "stack traces" is not helpful in how GHC implements Haskell.
02:46:17 <dminuoso> WilliamHamilton[: The only use case of entailment I can think of immediately is some borked parts of `hask` where edward just couldn't convince GHC enough about some entailment.
02:46:25 <v0d1ch> I got my hopes up when I implemented Functor instance fast but monad gave me a lot of grief
02:46:30 <dminuoso> WilliamHamilton[: You have to bend the type system pretty far to need `constraints` at all.
02:47:00 <dminuoso> v0d1ch: Just follow the types. :)
02:47:20 <v0d1ch> that's what they always say :)
02:47:44 <WilliamHamilton[> dminuoso: got it, thanks!
02:51:02 <dminuoso> v0d1ch: But if you are really stuck, I recommend letting it go and reapproaching it later.
02:51:52 <v0d1ch> oh no I already took a peek at a solution, I think if you spend 30 minutes trying to do it you are just not ready for it
02:52:28 <dminuoso> v0d1ch: I spent maybe an hour on Cont until I figured it out when I was a beginner.
02:54:05 <dminuoso> v0d1ch: In fact I spent the whole night writing Cont, then ContT, Maybe then MaybeT, List then ListT, Reader then ReaderT, State then StateT, Writer and WriterT
02:54:16 <v0d1ch> that's the problem, I didn't think I was a beginner ;)
02:55:02 <v0d1ch> but to be honest, I didn't practise enough writing instances, wow whole night
02:55:31 <dminuoso> v0d1ch: The theme of CPS style is rather common in various places of Haskell. It's just the idea that `A` is somehow equivalent to `(A -> r) -> r`.
02:56:30 <dminuoso> v0d1ch: Well let's say merijn told me to write Writer and then WriterT.. and I figured "why not do it for all the transformers"
02:56:48 <v0d1ch> yes I read about it and think I understand all, seems like a simple concept but man it can become hairy
02:57:01 <v0d1ch> yeah that is the right attitude
02:58:10 <v0d1ch> I recently got to attend some fp complete course where you revisit haskellbook all over again, I think it will be useful to go through it once more
03:02:23 <dminuoso> v0d1ch: I have an interesting example that might help illustrate the thought:
03:02:45 <dminuoso> A while ago someone came in here with some code that looked like this:
03:03:06 <dminuoso> % safeTail [] = Nothing; safeTail (x:xs) = Just xs
03:03:07 <yahb> dminuoso: 
03:03:08 <dminuoso> ^
03:03:28 <dminuoso> % loop f a = maybe a (loop f) (f a)
03:03:29 <yahb> dminuoso: 
03:04:04 <dminuoso> And then the person just forced `loop safeTail [1..1000000]`, and noticed it was suprisingly slow.
03:06:54 <v0d1ch> so what does loop do except, well ... loop through the list
03:07:14 <dminuoso> v0d1ch: It just loops through the list until the list is done.
03:07:27 <v0d1ch> ok that's what I thought
03:07:52 <v0d1ch> just trying to see the hidden meaning of the function which I guess does not exist
03:08:19 <dminuoso> v0d1ch: So the reason this is slow, is because you pattern match on the list, figure out whether it has a tail or not.. and then you encode that fact onto (Maybe a). But then the loop uses `maybe` to discriminate on the (Maybe a) whether you have a tail - that information you have already figured out, suddenly you end up pattern matching again.
03:09:01 <dminuoso> This style is using `ADTs` to control execution flow.
03:09:30 <dminuoso> That is expensive because you need to discriminate on your sum types to figure out something that you have already figured out.
03:09:53 <dminuoso> What you could do instead, is use a different encoding that looks like this
03:10:25 <dminuoso> % cpsTail :: [a] -> o -> ([a] -> o) -> o; cpsTail = _IleaveTheImplementationToYou
03:10:25 <yahb> dminuoso: ; <interactive>:1:1: error:; GHC internal error: `Ghci7.$trModule' is not in scope during type checking, but it passed the renamer; tcl_env of environment: [ry3k :-> Identifier[cpsTail::forall a o. [a] -> o -> ([a] -> o) -> o, TopLevelLet]]
03:10:32 <dminuoso> Not bad.
03:10:57 <v0d1ch> ha let me see
03:12:23 <dminuoso> (Its also slow because it needs to allocate lots of memory to create data structure just to have that data structure thrown away moments later)
03:14:57 <v0d1ch> `o` would be the default value to return ?
03:16:04 <dminuoso> v0d1ch: Ill let you figure that out. :-)
03:16:24 <dminuoso> v0d1ch: Once you have implement it, also implement an equivalent `cpsLoop` that can work with your `cpsTail`
03:17:11 <v0d1ch> ```cpsTail :: [a] -> o -> ([a] -> o) -> o
03:17:12 <v0d1ch> cpsTail [] def = def
03:17:12 <v0d1ch> cpsTail list _ = \f -> f list```
03:17:19 <v0d1ch> ?
03:18:00 <v0d1ch> oh man I am on a spare machine and my clipboard and tmux are not in love so had to commit to some repo, push and copy from browser :)
03:18:58 <dminuoso> v0d1ch: that doesnt look quite right!
03:19:13 <dminuoso> v0d1ch: try out the function, and see if it behaves similarly to safeTail
03:19:20 <dminuoso> Apply it to an actual list.
03:19:28 <v0d1ch> will do
03:19:38 <dminuoso> Also I do not think your solution type checks.
03:19:54 <dminuoso> Oh it does nvm! :)
03:20:13 <v0d1ch> oh but it doesn't
03:21:23 <dminuoso> v0d1ch: It might be helpful to write all the arguments to the left side of the = sign. :)
03:21:25 <v0d1ch> this compiles ```cpsTail :: [a] -> o -> ([a] -> o) -> o
03:21:25 <v0d1ch> cpsTail [] def = \_ -> def
03:21:25 <v0d1ch> cpsTail list _ = \f -> f list
03:21:31 <v0d1ch> this compiles ```cpsTail :: [a] -> o -> ([a] -> o) -> o
03:21:31 <v0d1ch> cpsTail [] def = \_ -> def
03:21:31 <v0d1ch> cpsTail list _ = \f -> f list```
03:21:56 <jaarod2> interesting, behavior of foldl' has changed at one point. https://ghc.haskell.org/trac/ghc/ticket/12173
03:21:56 <dminuoso> v0d1ch: try the code with lists, and compare with my `safeTail` above
03:21:57 <v0d1ch> I screwed it up but you get the point , I was missing that `\f`
03:22:04 <dminuoso> v0d1ch: Still try it.
03:22:11 <jaarod2> > foldl' (\_ y -> y) undefined [1]
03:22:13 <lambdabot>  *Exception: Prelude.undefined
03:23:25 <jaarod2> @src foldl'
03:23:25 <lambdabot> foldl' f a []     = a
03:23:25 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
03:23:38 <jaarod2> definition above will return 0 instead of undefined
03:24:13 <dminuoso> jaarod2: Do note that `lambdabot` lies.
03:24:18 <jaarod2> (it changed for the better)
03:24:26 <v0d1ch> dminuoso: wait my laptop is about to take off :)
03:24:35 <dminuoso> jaarod2: lambdabot @src is just a text file mapping identifiers to code, it does not tell you the actual implemenntation.
03:24:50 <jaarod2> dminuoso, that is the definition ghc used before 4.8, though
03:24:53 <dminuoso> (And some of those code snippets diverge from what is implemented in base greatly)
03:24:54 <MarcelineVQ> dminuoso: took me a little bit to figure out how to test cpsTail hehe
03:28:24 <v0d1ch> tried loop safeTail [1..10000] which yields [] ? how do I _force_ it ? `force` ?
03:29:09 <dminuoso> v0d1ch: You're one step too far.
03:29:20 <dminuoso> v0d1ch: Don't look at `loop` yet, just compare `safeTail` with your `cpsTail` in isolation.
03:29:41 <dminuoso> There's a subtle mistake that the type system couldn't protect you from, but it should be easy if you apply both to some list.
03:30:03 <dminuoso> And see the results.
03:36:34 <v0d1ch> they seem to work at similar speed, if I do `cpsTail [1..1000000] [] tail` for example
03:38:10 <v0d1ch> so it seams like safeHead is taking its time just to print the tail of the list, there is no looping involved
03:43:49 <MarcelineVQ> `cpsTail [1..1000000] [] tail` suggests a misunderstanding about the job cpsTail should be doing
03:45:40 <MarcelineVQ> for example, afaict, a correct cpsTail [1..3] [] tail results in [3]
03:46:00 <v0d1ch> `cpsTail [1..100000] Nothing Just` is pretty much the same, I think maybe the implementation could be different, it feels the same as with safeHead a part from that `f`
03:46:14 <dminuoso> v0d1ch: The mistake in your implementation is that cpsTail does nothing Taily.
03:46:43 <dminuoso> % cpsTail [] def _ = def; cpsTail list _ f = f list
03:46:44 <yahb> dminuoso: 
03:47:03 <dminuoso> % cpsTail [1,2,3] [0] id
03:47:03 <yahb> dminuoso: [1,2,3]
03:47:15 <dminuoso> v0d1ch: ^- this should be producing [2,3]
03:47:35 <v0d1ch> yes
03:47:41 <v0d1ch> back to the lab
03:50:14 <dminuoso> v0d1ch: And equivanelty `cpsTail [] [0] id = [0]`
03:52:27 <v0d1ch> ```cpsTail :: [a] -> o -> ([a] -> o) -> o
03:52:27 <v0d1ch> cpsTail [] d = \f -> d
03:52:27 <v0d1ch> cpsTail (a:as) d = \f -> f as
03:52:27 <v0d1ch> ```
03:52:42 <v0d1ch> this yields correct results
03:53:25 <dminuoso> v0d1ch: Okay. Now implement a `loop` equivalent called `cpsLoop` that uses `cpsTail`
03:53:32 <dminuoso> Remember that:
03:53:50 <dminuoso> % loop f a = maybe a (loop f) (f a)
03:53:50 <yahb> dminuoso: 
03:53:53 <dminuoso> % :t loop
03:53:53 <yahb> dminuoso: (a -> Maybe a) -> a -> a
03:54:03 <dminuoso> The type signature will vary a bit.
04:02:09 <tabaqui> https://wiki.haskell.org/Tying_the_Knot
04:02:28 <tabaqui> I have made double linked non-circullar list
04:02:40 <tabaqui> But have issues with implementing Semigroup instance
04:02:51 <tabaqui> and usual appendL, appendR functions
04:03:04 <tabaqui> Has anyone here working example or some fresh ideas?
04:03:13 <dminuoso> tabaqui: What is your implementation?
04:03:57 <tabaqui> dminuoso: Just the same as in this article (mutually recursive mkDList), but "go prev [] next = (DTip, DTip)" where DTip is an empty node
04:04:25 <tabaqui> data DList a = DTip | DNode (DList a) a (DList a)
04:07:47 <tabaqui> https://pastebin.com/mfLCc5aa
04:10:34 <Ariakenom> tabaqui: maybe its helpful to consider that insertion will copy the entire list
04:11:03 <tabaqui> Ariakenom: I know that we have to update the whole list
04:32:31 <v0d1ch> dminuoso: need to go back to this, didn't manage to do it and I am at work, supposed to write some industrial haskell :)
04:34:18 <v0d1ch> I appreciate the lesson, will send you the answer
04:44:23 <dminuoso> I have an event loop that looks like `loop = do msg <- recv; _ <- async (handle msg); loop` -- is there an idiomatic way to introduce a graceful shutdown of this?
04:46:52 <c_wraith> dminuoso: what's the trigger for the shutdown?
04:48:34 <dminuoso> c_wraith: Some `IO ()` action that is used by my test suite and future signal handlers.
04:52:21 <c_wraith> does it matter if you occasionally lose a message?  (ie, read message from socket at the OS level but shut down the thread before the handler is spawned?
04:52:35 <c_wraith> err, shut down the loop
04:52:42 <dminuoso> Right now Im thinking to a) ensure that worker threads are wrapped in `timeout`, b) the loop adds workers to a `TVar []` under the condition that an TMVar is not put into, and c) the async exception is emitted after putting into that TMVar and waiting until the TVar is empty
04:52:53 <dminuoso> c_wraith: Nope. Just want workers to complete their work.
04:55:44 <c_wraith> ok.  It's gonna get *way* more complex.
04:56:01 <c_wraith> Ideally you'd find a library that does this already. :)
04:56:13 <dminuoso> c_wraith: Yeah Ive been doing digging.. warp seems to do everything by hand..
04:57:28 <c_wraith> Since you've got to track everything, you probably want to change to a worker pool instead of spawning asyncs
04:57:41 <c_wraith> Bounding memory use is a good thing
04:58:03 <dminuoso> Also I guess I dont have unlimited LDAP resources... though it can handle a couple thousand connections just fine. :P
04:58:11 <dminuoso> I could live with it.
05:03:05 <Ariakenom> dminuoso: something like: finally loop waitThreads where loop = do msg <- recv; t <- async (handle msg >> removeThread t); addThread t; runThread t; loop;
05:03:52 <Ariakenom> async doesn't have runThread though. could do some masking to not need it I'd suppose
05:03:55 <c_wraith> no need for runThread, async does the spawning. :)
05:04:21 <dminuoso> Oh well I could just maintain a simple counter inside STM.
05:04:23 <Ariakenom> c_wraith: that can leak a running thread
05:04:30 <c_wraith> yeah, that's what I kept getting at.  You need to use mask
05:04:40 <c_wraith> so that you only accept exceptions during the recv
05:05:48 <c_wraith> There is the race condition there still, but dminuoso has declared that one doesn't matter.
05:06:53 <Ariakenom> finally loop waitThreads where loop = do msg <- recv; mask (do t <- async (handle msg >> removeThread t); addThread t;) loop;
05:06:58 <Ariakenom> c_wraith: which race condition?
05:07:26 <dminuoso> Ariakenom: Wait woah. Cyclic things are beautiful.,
05:07:33 <dminuoso> Ariakenom: I didn't see how to tie things together.
05:07:39 <c_wraith> Ariakenom: oh, that's what you had in mind.  You want mask_ then
05:08:02 <c_wraith> Ariakenom: the race condition is that you can pull a message off the OS network stack but fail to process it
05:08:09 <dminuoso> c_wraith: That is perfectly fine.
05:08:20 <dminuoso> c_wraith: 
05:08:22 <dminuoso> Oops.
05:08:23 <c_wraith> yes, I did say you were fine with it
05:08:34 <c_wraith> I just was pointing out that there *is* a data race there. :)
05:08:40 <dminuoso> Gotcha.
05:08:41 <Ariakenom> need to make sure removeThread waits for addThread. stm does that by default
05:09:36 <dminuoso> Ariakenom: It's missing a guard on an `MVar`.
05:09:47 <dminuoso> Or TMVar rather.
05:10:05 <dminuoso> Ariakenom: The thing is, I need to switch into `quit` mode, so I can actually wait for workers to finish.
05:10:17 <c_wraith> dminuoso: that's what the finally does
05:10:39 <dminuoso> oh.
05:10:49 <Ariakenom> also make sure that happens if a thread crashes
05:10:55 <Ariakenom> makes
05:11:34 <dminuoso> Ariakenom: Oh yeah, that should be fine if I did something like: handleMsg msg `finally` removeThread t
05:11:50 <dminuoso> No?
05:12:49 <dminuoso> Ariakenom: I have but one question left.
05:12:54 <dminuoso> Ariakenom: What is `t`?
05:13:10 <dminuoso> Just desugared that in my head, and that does not seem to be possible what you wrote.
05:13:37 <dminuoso> async (removeThread t) >>= (\t -> addThread)
05:13:39 <dminuoso> async (removeThread t) >>= (\t -> addThread t)
05:14:28 <Ariakenom> dminuoso: oh yeah good point. that would deadlock in my example
05:14:38 <Ariakenom> who'd a thought concurrency is hard
05:14:54 <dminuoso> Ariakenom: Not just deadlock, but `t` is not defined.
05:15:00 <dminuoso> It's invalid Haskell.
05:15:14 <Ariakenom> details
05:15:45 <dminuoso> The simplest technique I can come up is a counter.
05:16:23 <Ariakenom> I don't see any problems with that at first glance
05:16:48 <dminuoso> STM is a blessing, isn't it.
05:17:01 <dminuoso> Imagine having to do this with mutexes.
05:17:13 <Ariakenom> would this work
05:17:36 <Ariakenom> finally loop waitThreads where loop = do msg <- recv; mask (mdo t <- async (handle msg `finally` removeThread t); addThread t;) loop;
05:18:21 <Ariakenom> with a MonadFix addition
05:18:23 <dminuoso> Ariakenom: Wouldn't this blow up if I ever tried to look at `t`?
05:18:38 <Ariakenom> it exists before we look at it
05:19:01 <dminuoso> Well if anything I'd use mfix rather.
05:21:54 <dminuoso> Ariakenom: Anyway, Im not sure whether I like unsafeInterleaveIO in here.
05:22:10 <dminuoso> It sounds like great potential to screw with concurrency.
05:22:20 <Ariakenom> heh
05:22:28 <Ariakenom> A counter does seem better
05:23:54 <Ariakenom> mfix is fun stuff though :p
05:24:39 <Ariakenom> (I missed your "what is t question", so answered the question before. sry)
05:25:19 <dminuoso> Ariakenom: Ah now it makes sense.
05:25:50 <Ariakenom> message reordering. classic concurrency
05:27:51 <dminuoso> https://gist.github.com/dminuoso/6bf36fbc6d4ec39d3f32ea755fc35da0
05:28:09 <dminuoso> Some liftIOs missing I guess. 
05:29:28 <Ariakenom> when (c /= 0) retry = guard (c /= 0)
05:29:41 <dminuoso> Oh mzero = retry?
05:29:47 <dminuoso> Neat. :)
05:29:58 * hackage simple-vec3 0.4.0.10 - Three-dimensional vectors of doubles with basic operations  http://hackage.haskell.org/package/simple-vec3-0.4.0.10 (DmitryDzhus)
05:30:54 <dminuoso> And UnliftIO.STM is also I think, really love unliftio. :)
05:31:13 <Ariakenom> addThread-async race
05:31:29 <dminuoso> Ariakenom: Whats the race?
05:32:09 <Ariakenom> addthread - exception - counter can't reach zero
05:33:05 <dminuoso> Ah, so I need to mask while addThread and spawning.
05:33:10 <Ariakenom> yup
05:33:57 <dminuoso> Guess I want asyncWithUnmask then too
05:34:30 <dminuoso> I think.. 
05:34:49 <dminuoso> Otherwise the workers will be unkillable (since I intend to `timeout` them)
05:35:12 <Ariakenom> yes, maskiness is inherited I suppose
05:35:54 <Ariakenom> which exceptions are caught in dispatcher's (`finally`waitThread)?
05:36:26 <dminuoso> Ariakenom: recvFrom could throw.
05:36:42 <dminuoso> It's IO after all.
05:36:51 <Ariakenom> does it do finally on all exceptions?
05:36:59 <Ariakenom> I suppose
05:37:02 <dminuoso> Does it matter?
05:37:29 <Ariakenom> it probably shouldn't on most asynchronous?
05:37:37 <dminuoso> "probably", "most" 
05:37:46 <dminuoso> Concurrency programming like it should be!
05:38:15 <Ariakenom> most=every but one special for cancellingbutwait made especially for this function
05:38:25 <dminuoso> Ariakenom: Ah yeah! The async exception is what the `finally` waitThread is for.
05:38:41 <dminuoso> So the way I'd kill the server is by just using `throwTo`
05:38:52 <dminuoso> Or Ill rather use `async` and `cancelAsync`
05:39:16 <dminuoso> Escaped my mind for a bit when you asked.
05:39:49 <Ariakenom> how long does the tasks take? seems wrong to finally for a long while
05:40:23 <Ariakenom> to "finally" something a like a keyboardinterrupt or the general kill command at least
05:41:27 <dminuoso> Ariakenom: Usually no more than 10-100ms, the `finally` is rather in case some thread hangs.. or crashes..
05:41:47 <dminuoso> Ariakenom: the task will never receive async exceptions..
05:41:52 <dminuoso> at least they shouldn't..
05:42:05 <Ariakenom> composability damnit
05:42:14 <dminuoso> What do you mean?
05:43:56 <Ariakenom> I just wanted it to behave nicely wrt async exceptions. 
05:44:43 <Ariakenom> Needed for composing it to some other thing using async exceptions. But that may be the  nice behaviour.
05:45:08 <Ariakenom> and that was the "probably"
05:48:00 <Ariakenom> Am I even making sense?
05:55:12 <dminuoso> Im not sure.
05:55:20 <dminuoso> https://gist.github.com/dminuoso/bbdc359fb52dc7965f3e275c379a340b
05:55:24 <dminuoso> It type checks, so it's race free right?
05:56:01 <dminuoso> Im not bold enough to try and use `restore` from inside the thread. Something in me tells me that can't possibly have the desired effect.
05:57:16 <Ariakenom> dminuoso: c_wraith mentioned mask_ https://www.haskell.org/hoogle/?hoogle=mask_
05:57:26 <dminuoso> Ah, indeed.
05:58:47 <Ariakenom> dminuoso: LGTM
06:22:57 * hackage csg 0.1.0.6 - Analytical CSG (Constructive Solid Geometry) library  http://hackage.haskell.org/package/csg-0.1.0.6 (DmitryDzhus)
06:27:57 * hackage Stack 0.4.0 - Stack data structure  http://hackage.haskell.org/package/Stack-0.4.0 (rwlock)
06:37:17 <Ariakenom> A ... stack ... ?
06:37:44 <phadej> no, Stack
06:38:37 <dminuoso> That's a lot of.. code.. and modules..
06:39:28 <dminuoso> Unsure, what's wrong with a plain `TVar [a]`?
06:39:30 <Clint> the home page is a wikipedia article
06:39:53 <Ariakenom> dminuoso: yes. Clint yes.
06:42:55 <Ariakenom> dminuoso: it's a TVar Stack. where Stack is a list with size (literally Stack !Natural [a])
06:43:20 <Ariakenom> I just found it ... odd
06:44:19 <dminuoso> Ariakenom: I find it even more surprising that there's a total of 1446 downloads.
06:44:28 * hackage posix-api 0.2.0.0 - posix bindings  http://hackage.haskell.org/package/posix-api-0.2.0.0 (andrewthad)
06:44:30 <dminuoso> But I guess some people find the package useful.
06:44:37 <Clint> how many of those people thought they were downloading stack?
06:44:42 <dminuoso> Heh.
06:44:55 <Ariakenom> dminuoso: Oh, I missed that
06:45:59 <dminuoso> Ariakenom: So I did some decoupling, so I get some `data Server = Server { mainThread :: Async Void, workerCount :: TVar Integer }`, the `waitWorkers` is moved into a separate top level binding..
06:46:07 <dminuoso> It's quite nice now, thanks a lot for your insights and help. :)
06:48:10 <Ariakenom> dminuoso: np, sounds nice
06:54:28 * hackage sockets 0.1.0.0 - High-level network sockets  http://hackage.haskell.org/package/sockets-0.1.0.0 (andrewthad)
07:03:45 <asheshambasta> Any tips on keeping GHCI from leaking memory? I'm working on a large project (60 modules and counting) and GHCI is consiming a massive 7GB of memory 
07:04:20 <lordcirth_> asheshambasta, I doubt that's a memory leak, as such
07:04:39 <[exa]> asheshambasta: are you imporing all modules at once?
07:05:00 <inkbottle> f a @ A {} = ...; do I have to put parentheses around a @ A {}?
07:05:11 <asheshambasta> hitting `:r` over a period of time seems to exaggerate the problem 
07:05:59 <[exa]> asheshambasta: tried forcing a gc?
07:06:04 <asheshambasta> [exa]: yes, it seems that content from all modules are in scope; how does one disable that? I'm running ghci via `stack ghci`. 
07:07:05 <[exa]> not sure about stack but there should be a way for loading only one module directly
07:07:18 <dminuoso> c_wraith: If only there was a `recvFrom` that worked in STM. :-P
07:07:47 <dminuoso> c_wraith: Though I could trivially adapt the code to avoid the race condition we talked about earlier.
07:08:40 <c_wraith> dminuoso: yeah, you could have a dedicated thread for reading from the socket and writing to a queue (preferably bounded)
07:09:05 <inkbottle> Hum, the issue was elsewhere
07:09:44 <jaarod2> why is strictness analysis failing in the following code even with -O2 (getting out of memory exception), but works for foldl and sum even with -O0?  http://dpaste.com/2623RMA
07:09:57 <dminuoso> c_wraith: Interesting idea, I was rather thinking about trying to read off the socket while masked, but rather in a non-blocking fashion and then using something like `select`
07:10:16 <dminuoso> That way I could protect just the actual reading part with mask.
07:10:38 <dminuoso> c_wraith: Though your solution seems a bit easier to implement.
07:11:19 <Ariakenom> c_wraith: how does that solve the problem?
07:11:43 <c_wraith> Ariakenom, you don't stop the read thread until program shutdown
07:12:19 <c_wraith> Ariakenom, which is why it should be writing to a bounded channel
07:12:32 <dminuoso> c_wraith: Ultimately since this is UDP it does not matter regardless. If the socket is listening or not is not something you can detect.
07:13:23 <dminuoso> So whether messages are consumed by `read()` internally, or the messages just fall off the cliff from a non-listening UDP socket... it's the same anyway.
07:14:02 <Ariakenom> c_wraith: that would race against another process? but maybe that's not an issue
07:14:28 <asheshambasta> [exa]: AFAIK its the deriving generic over decently sized sum-types 
07:14:29 <c_wraith> Ariakenom, eh, that's up to the OS. out of the program's control.
07:15:36 <dminuoso> Like I said. UDP, so it's racy by design.
07:15:40 <c_wraith> (many OSes don't allow different processes to reuse the same port without cooperation between them anyway)
07:17:06 <Ariakenom> yeah, it's probably overkill. But it's what I understood your race condition to be about first.
07:17:24 <asheshambasta> Is there a way to unload all modules in GHCI? 
07:17:42 <asheshambasta> I know of :m -, but for a project this large, its quite unfeasible
07:19:12 <dminuoso> amx: just plain `:m`
07:21:46 <v0d1ch> dminuoso: I played a bit with that cps thingy, https://gist.github.com/v0d1ch/9eebe587109521238fef06fd8068f9fc
07:22:54 <dminuoso> v0d1ch: The type is still off.
07:23:18 <v0d1ch> what would be correct signature for cpsLoop ?
07:25:35 <dminuoso> v0d1ch: cpsLoop should somehow take `cpsTail` as an argument.
07:26:25 <dminuoso> v0d1ch: "cpsTail" itself takes a list and two "branches" as arguments, and follows the appropriate branch. So it's a kind of control structure.
07:26:29 <Gurkenglas> On what website do I write some Haskell and it shows me the corresponding 2D animation?
07:26:49 <g-erson> repl.it? 
07:27:03 <dminuoso> g-erson: CodeWorld?
07:27:06 <dminuoso> Err Gurkenglas.
07:27:17 <v0d1ch> what I did was `cpsLoop  [1..10] [0] cpsTail id`
07:27:18 <v0d1ch>  > [2,3,4,5,6,7,8,9,10]
07:28:15 <v0d1ch> ok I'll try again
07:28:43 <dminuoso> v0d1ch: your `cpsLoop` is not a loop.
07:28:51 <dminuoso> v0d1ch: it's just a fancy way of applying a function to two arguments.
07:28:56 <dminuoso> It doesn't do anything.
07:29:07 <v0d1ch> at least I get to say I am fancy :)
07:29:11 <dminuoso> v0d1ch: Hehe.
07:29:18 <dminuoso> 16:26         dminuoso | v0d1ch: "cpsTail" itself takes a list and two "branches" as arguments, and follows the appropriate branch. So it's a kind of control structure.
07:29:26 <dminuoso> ^- let that sink in :)
07:29:40 <v0d1ch> yes I realized that is important
07:30:02 <v0d1ch> lets hope it doesn't pass few days before that _sinks in_ :)
07:30:16 <dminuoso> v0d1ch: Essentially whatever your function does, it needs to take a whole `[a] -> o -> ([a] -> o) -> o` as a single argument.
07:30:28 <dminuoso> So whatever your type is, its going to be something like `([a] -> o -> ([a] -> o) -> o) -> ...`
07:31:08 <dminuoso> v0d1ch: Semantically how many things does a loop have?
07:31:56 <v0d1ch> a function and some value passed in
07:32:36 <dminuoso> v0d1ch: Ill give you a hint:
07:32:41 <dminuoso> cpsLoop :: (forall o. [a] -> o -> ([a] -> o) -> o) -> [a] -> [a]
07:32:45 <dminuoso> This is the fully generalized type.
07:33:50 <v0d1ch> thanks!
07:37:16 <dminuoso> v0d1ch: Or, if you want it specialized for `cpsTail`, it would just be `[a] -> [a]`
07:37:29 <dminuoso> The difference is trivial between them.
07:53:29 <jaarod2> @find forkIO
07:53:30 <lambdabot> error: Not in scope: type variable ‘forkIO’
07:53:34 <jaarod2> @hoogle forkIO
07:53:35 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
07:53:35 <lambdabot> GHC.Conc forkIO :: IO () -> IO ThreadId
07:53:35 <lambdabot> GHC.Conc.Sync forkIO :: IO () -> IO ThreadId
08:05:47 <v0d1ch> dminuoso: didn't get far and I need to run, i will look at it tonight probably 
08:05:54 <v0d1ch> darn it
08:11:37 <dminuoso> Arahael: modgud: Control.Concurrent.STM.atomically was nested
08:12:01 <dminuoso> And here I was, thinking "it typechecks, so it must work"
08:12:58 <monochrom> Wait, atomically is STM a -> IO a rather than STM a -> STM a or IO a -> IO a, so how did you nest it?
08:13:19 <mniip> unsafeIOToSTM?
08:13:22 <dminuoso> Oh haha!
08:13:25 <dminuoso> I know why.
08:13:31 <mniip> recipe for disaster
08:13:35 <dminuoso> Lazyness caught me.
08:13:51 <dminuoso> I did `cnt = unsafePerformIO (atomically (newTVar 0))`
08:13:57 * hackage propellor 5.6.0 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-5.6.0 (JoeyHess)
08:13:59 <dminuoso> And then used `cnt` inside an `atomically` block
08:14:02 <dminuoso> :)
08:14:06 <monochrom> Oh, that.
08:15:04 <dminuoso> Who could have known that unsafePerformIO was an unsafe thing.
08:15:33 <mniip> newTVarIO
08:15:35 <dmwit> Yes, this is why newTVarIO exists.
08:15:44 <dminuoso> Heh.
08:16:01 <dminuoso> Gotcha. :)
08:16:15 <dminuoso> I read this last week.
08:16:18 <dminuoso> IO version of newTVar. This is useful for creating top-level TVars using unsafePerformIO, because using atomically inside unsafePerformIO isn't possible.
08:16:20 <dminuoso> Today I learned it.
08:16:39 <dminuoso> Thanks mniip.
08:19:40 <Gurkenglas> dminuoso, can't import base? <.<
08:20:11 <geekosaur> huh?
08:20:16 <geekosaur> you import modules, not packages
08:20:47 <Gurkenglas> "import Data.List" -> "Failed to load interface for Data.List" "It is a member of the hidden package base-4.9.0.0.
08:21:04 <Gurkenglas> (referring to code.world)
08:21:45 * geekosaur wonders what kind of weird sandboxing it might be doing
08:22:20 <dminuoso> Gurkenglas: Really curious, on my shell I can.
08:22:39 <dminuoso> Gurkenglas: Perhaps the #... stuff in the url gives me a different sandbox: {-# OPTIONS_GHC -fno-warn-unused-binds #-}
08:22:44 <dminuoso> Uhh.. https://code.world/haskell#PKhbqz7puuj2QPDOCyn-4XA
08:22:47 <dminuoso> Weird clipboard. :(
08:23:32 <Gurkenglas> https://code.world/#PkCNcqJdt7fMuVgYe71F7gQ
08:23:51 <WilliamHamilton[> kosmikus: is there a way, in generics.sop, to detect when the `Code` type family remains unapplied, like in `:kind! Code Int`, which is `Code Int`?
08:23:51 <bor0> is there a better way to write this down? I want to make sure `Nand` can only be constructed when both values are not True. https://gist.github.com/bor0/82643e869b762e66e16f1dfed06e0303
08:24:23 <Gurkenglas> (Trying to transform https://78.media.tumblr.com/fbde47a13ba6693ce245f95a4ba8d528/tumblr_o0k7mkhNSN1uk13a5o1_500.gif to hold earth and sun fixed)
08:24:45 <WilliamHamilton[> kosmikus: or a way to say that `All2 Foo (Code Int)` could be (vacuosly) true, as far as I'm concerned?
08:24:46 <glguy> bor0: You could use two constructors, one with the first thing is false and the second is anything
08:24:54 <glguy> and one where the first is anything and the second is false
08:25:17 <bor0> how do I express `anything`? MkNandT :: Nand True ?
08:25:22 <dminuoso> Couldn't you use a type family as well?
08:25:34 <glguy> MkNandT :: Nand True a
08:25:40 <Gurkenglas> ((and was currently trying to memoize the picture as it grows so I don't lag after a few seconds))
08:25:43 <bor0> ah
08:27:44 <dminuoso> Gurkenglas: There's an interesting side to that story. Do you know the relationship between epicycles and fourier transform? 
08:39:10 <Jetien> Hi! I'm trying to learn GHC.Generics. If I try to compile the example code in the documentation in http://hackage.haskell.org/package/generic-deriving-1.12.2/docs/Generics-Deriving-Base.html I get the compiler error "Could not deduce (Encode' (Rep a)) arising from a use of ‘encode'’". Here is the code extracted from documentation: https://gist.github.com/smatting/6bcf883fb6b6d55907fd03bd3b17ecea
08:39:20 <Welkin> how can I define some rules to use when deriving ToJSON and FromJSON?
08:39:35 <dminuoso> Welkin: rules in what sense?
08:39:43 <Welkin> for a record that includes fields like `_personName` I want the json field to be `name`
08:40:39 <Jetien> @Welkin: https://artyom.me/aeson#generics-customising-field-names
08:40:39 <lambdabot> Unknown command, try @list
08:41:50 <Welkin> so I still need to write an instance declaration?
08:42:01 <Welkin> and will that direct encoding?
08:42:10 <Welkin> or will it convert to Value first?
08:42:41 <Jetien> Welkin: you need to write an instance declartion, but a very short one
08:42:55 <Welkin> this still doesn't seem quite right
08:43:12 <Welkin> I have to manually manipulate the field name by dropping parts of it
08:43:16 <Welkin> that istn' what I'm looking for
08:43:30 <dminuoso> Welkin: You could probably use gParseJSON
08:44:12 <dminuoso> Or `genericParseJSON` if you prefer a more neatly packed interface.
08:44:13 <Welkin> I noticed selda offers some functions for automatically deriving column names from field names by specifying the prefix to remove
08:44:16 <Jetien> Welkin: fieldLabelModifier is a generic String->String function. You can represent any name mapping as such a function. http://hackage.haskell.org/package/aeson-1.4.2.0/docs/Data-Aeson-Types.html#v:fieldLabelModifier
08:46:16 <Welkin> it looks like I can use genericToEncoding instead
08:49:06 <Welkin> and for FromJSON I can simply include it in my `deriving` directive, right?
08:49:24 <Welkin> as long as I also have a Generic instance derived
08:49:46 <dminuoso> Welkin: It'd overlap.
08:50:33 <dminuoso> Welkin: You could make a newtype wrapper and then use deriving via.
08:50:52 <Welkin> that sounds wrong
08:51:06 <Welkin> what about a standlone deriving?
08:51:20 <Welkin> or `instance FromJSON MyType`
08:52:00 <dminuoso> Wait a moment, I think I was confused.
08:52:05 <dminuoso> You can use `deriving` with FromJSON?
08:52:07 <Welkin> I think I can do the second
08:52:27 <dminuoso> How would that work?
08:52:45 <Welkin> it's in the aeson docs
08:52:52 <Welkin> as long as you have a Generic instance derived
08:53:17 <Welkin> I have so many Derive*/Deriving* languge pragmas turned on this is getting pretty funny
08:53:30 <dminuoso> Welkin: Where is that documented?
08:54:43 <Welkin> https://hackage.haskell.org/package/aeson-1.4.2.0/docs/Data-Aeson.html
08:54:51 <Welkin> 3rd blue box
08:54:51 <dminuoso> Welkin: Not seeing what you mean.
08:55:05 <dminuoso> Welkin: Yeah that's something different, that's not through the deriving mechanism.
08:55:19 <dminuoso> Welkin: The trick with `aeson` works by defining a regular instance but without any methods so that the default method kicks in, which itself uses genericParseJSON with default settings.
08:55:41 <Welkin> parsing the json doesn't matter though
08:55:48 <dminuoso> Welkin: same thing for ToJSON
08:55:52 <Welkin> or wait
08:55:54 <Welkin> would it?
08:55:57 <Welkin> I suppose it might
08:56:03 <Welkin> because it needs to know the field names to parse
08:56:31 <dminuoso> The class basically looks like `class FromJSON a where ... parseJSON :: Value -> Parser a; default parseJSON :: (Generic a, GFromJSON Zero (Rep a)) => Value -> Parser a; parseJSON = genericParseJSON defaultOptions`
08:56:35 <Welkin> I see now
08:56:36 <dminuoso> So essentially
08:57:04 <dminuoso> So by just typing `instance FromJSON YourType` you are implicitly doing: `instance FromJSON YourType where parseJSON = genericParseJSON defaultOptions`
08:57:18 <dminuoso> Now the idea is that you do this explicitly and change the options.
08:57:44 <dminuoso> Same thing holds true for ToJSON
08:57:48 <Welkin> it's al ittle bit of extra boilerplate, 3 lines for each instance, so not that bad
08:58:14 <Welkin> I was manually writing all isntances by hand before
08:58:43 <Welkin> I realized if I am using haskell, I may as well use as much of the compiler's abilities as possible
08:59:05 <Welkin> oh wait!
08:59:16 <Welkin> what about converting the first letter to lowercase too?
08:59:21 <Welkin> or do I need to do many manually
08:59:40 <dminuoso> Welkin: Do you keep ignoring the responses?
09:00:01 <dminuoso> Welkin: Jetien has pointed it out to you a while ago.
09:00:53 <Welkin> I have read all responses
09:01:31 <oo_miguel> I am playing with criterion and wonder how to benchmark a Pure expression. Should I simply add a bogus param, supply it through whnf and ignore it?
09:01:43 <Welkin> I know I can do anything manually in the String -> String function
09:01:50 <Welkin> I am asking if there is already something defined to do it for me
09:10:48 <hololeap> anyone know of a library that captures the notion of Applicative but for two different functors? i'm looking for: forall a b. f a -> g b -> Product f g (a,b)
09:12:57 <vaibhavsagar> when would I use `array` over `vector`?
09:12:58 * hackage qnap-decrypt 0.3.4 - Decrypt files encrypted by QNAP's Hybrid Backup Sync  http://hackage.haskell.org/package/qnap-decrypt-0.3.4 (alexkazik)
09:15:03 <infinisil> vaibhavsagar: array supports arbitrary indices, I'd use it if you need that
09:15:18 <Cale> vaibhavsagar: It doesn't have a whole lot of advantages apart perhaps from the machinery you get from Ix -- it's possible to have "rectangular" arrays indexed by pairs, or other datatypes.
09:16:23 <vaibhavsagar> Cale: can you do lazy things like http://jelv.is/blog/Lazy-Dynamic-Programming/ with Vector?
09:16:31 <c_wraith> yep
09:16:35 <vaibhavsagar> It seems like you can but I have never heard anyone talk about this
09:16:59 <vaibhavsagar> cool, good to know
09:17:02 <vaibhavsagar> thanks all
09:17:20 <Cale> Of course, not with unboxed vectors
09:17:27 * hackage unordered-containers 0.2.10.0 - Efficient hashing-based container types  http://hackage.haskell.org/package/unordered-containers-0.2.10.0 (dfeuer)
09:17:28 <Cale> (but the same is true with unboxed arrays)
09:18:49 <Welkin> is there a working extension for overlapping field accessors?
09:19:03 <Welkin> last I heard, OVerloadedRecordFields had some problems
09:19:44 <Cale> My opinion about that is "don't"
09:19:46 <Welkin> (hi Cale)
09:19:51 <Cale> hi
09:20:03 <dmwit> Welkin: Yes, the module system. ;-)
09:20:16 <Welkin> Cale: I've been looking at selda and beam lately to replace postgresql-simple
09:20:29 <Welkin> I know that you have been using postgresql-simple with grounhog for validation
09:20:33 <Welkin> what do you think of beam and selda?
09:20:44 <Cale> We're working on getting switched over to beam
09:20:50 <Cale> I'm not sure about selda
09:20:50 <Welkin> the selda api is the best I have ever seen, but the only issue is that ti doesnt support composite primary keys
09:21:13 <Welkin> I'm probably going with beam unless I can get composite primary keys working in selda
09:21:22 <Welkin> but beam also looks great, just not as nice fo an api as selda
09:21:47 <dmwit> > max LT GT
09:21:49 <lambdabot>  GT
09:24:19 <Welkin> hey look at this
09:24:21 <Welkin> https://hackage.haskell.org/package/greskell
09:24:30 <Welkin> there are haskell bindings to gremlin!
09:24:59 <Welkin> I was disappointed last night to find that there were no arangodb bindings, but at least there is gremlin, which can be used with other graph databases
09:26:57 * hackage hedn 0.2.0.0 - EDN parsing and encoding  http://hackage.haskell.org/package/hedn-0.2.0.0 (AlexanderBondarenko)
09:27:32 <the_2nd> I compiled a program with stack and some users report the issue '<stdout>: commitBuffer: invalid argument (invalid character)' . When searching for the message, I mostly find issues within ghc / stack. Any idea why my produced binary might have that problem (can't reproduce on my machine)
09:28:01 <unK_> Hey. Does anyone know when makeLenses from lens library generates Traversal for a field instead of Lens (or Fold instead of a Getter)? I can't seem to decipher the TH generating code.
09:28:11 <Cale> the_2nd: probably locale setting?
09:28:45 <the_2nd> Cale, what it looks like from other search hits
09:29:11 <the_2nd> maybe this might help? https://www.reddit.com/r/haskell/comments/43tmt8/commitbuffer_invalid_argument_invalid_character/czl2r3w
09:29:31 <Cale> yes
09:30:54 <the_2nd> I have to do this where ever I write to file / stdout/err ?
09:32:15 <the_2nd> any idea how I could reproduce this on my machine?
09:32:35 <the_2nd> I print a copyright symbol on start, maybe I just have to replace that
09:33:44 <Welkin> why?
09:33:49 <Welkin> use (C) instead
09:33:55 <Welkin> it's common to do that
09:33:57 <the_2nd> sure
09:34:07 <Welkin> unicode should work just fine
09:34:13 <Welkin> unless the user's terminal doesn't support it
09:34:20 <the_2nd> seems like it
09:34:27 <the_2nd> I need a way to reproduce it
09:35:03 <Welkin> I wonder how they use nodejs then
09:35:10 <Welkin> since npm uses lots of unicode symbols
09:35:11 <Welkin> haha
09:36:00 <the_2nd> https://en.wikipedia.org/wiki/Comparison_of_command_shells
09:36:09 <the_2nd> I guess I try getting one without unicode support? 
09:37:00 <bsima> > [ a:b:[] | a <- [1..3], b <- [10..13] ]
09:37:02 <lambdabot>  [[1,10],[1,11],[1,12],[1,13],[2,10],[2,11],[2,12],[2,13],[3,10],[3,11],[3,12...
09:37:24 <bsima> > concat [ a:b:[] | a <- [1..3], b <- [10..13] ]
09:37:26 <lambdabot>  [1,10,1,11,1,12,1,13,2,10,2,11,2,12,2,13,3,10,3,11,3,12,3,13]
09:37:33 <Welkin> bsima: you can do that in a private message
09:37:45 <Welkin> or in ghci directly without importing anything
09:37:58 <int-e> > sequence [[1..2],[4..5]]
09:38:00 <lambdabot>  [[1,4],[1,5],[2,4],[2,5]]
09:38:01 <bsima> i wanted to ask: is there a better way to put the concat inside the list comprehension?
09:38:17 <bsima> instead of doing 'a:b:[]'
09:38:42 <int-e> bsima: you can do [ x | ..., x <- [a,b] ]
09:38:57 <bsima> ah good idea, thanks int-e
09:38:58 <int-e> (of course [a,b] is equivalent to a:b:[])
09:49:52 <dmwit> > compare GT undefined
09:49:54 <lambdabot>  *Exception: Prelude.undefined
09:50:07 <dmwit> > max GT undefined -- this one makes me sad, though
09:50:09 <lambdabot>  *Exception: Prelude.undefined
09:54:11 <dmwit> :t \(x,y) (x',y') -> let cmps = zipWith compare [x,y] [x',y'] in maximum cmps <> fold cmps
09:54:12 <lambdabot> error:
09:54:12 <lambdabot>     Ambiguous occurrence ‘<>’
09:54:12 <lambdabot>     It could refer to either ‘Data.Monoid.<>’,
09:54:30 <dmwit> :t \(x,y) (x',y') -> let cmps = zipWith compare [x,y] [x',y'] in fold (maximum cmps:cmps)
09:54:31 <lambdabot> Ord a => (a, a) -> (a, a) -> Ordering
09:54:42 <dmwit> Oh, sure
09:54:54 <dmwit> :t \(x,y) (x',y') -> let cmps = [compare x x', compare y y'] in fold (maximum cmps:cmps)
09:54:55 <lambdabot> (Ord a2, Ord a1) => (a1, a2) -> (a1, a2) -> Ordering
09:56:29 <dmwit> But for it to be properly lazy you have to define a custom maximum. =(
10:39:56 <Welkin> a transient dependency has failed to build for my project with a type error
10:39:58 <Welkin> which is really odd
10:41:01 <Welkin> https://hastebin.com/ifufojuvem.hs
10:41:16 <Welkin> for vector-sized
10:41:20 <Welkin> has anyone else run into this?
10:42:00 <Welkin> all I ddi was add beam-postgres to my cabal file
10:42:17 <Welkin> it rebuilt pretty much everything after that
10:43:09 <cocreature> maybe try the latest version of vector-sized instead?
10:43:47 <Welkin> it's not one of my dependencies
10:43:53 <Welkin> it's specified by beam
10:44:41 <cocreature> that doesn’t change my suggestion
10:45:38 <Welkin> how does that solve my problem?
10:45:46 <Welkin> I can't change the dependencies of the library
10:47:13 <Welkin> unless I compile the library from source directly from github or something
10:47:15 <cocreature> sure you can, use --constraint "vector-sized >= 1.2" and if that fails try something like --allow-newer beam:vector-sized
10:47:20 <Welkin> it's been fixed there but not released
10:47:45 <Welkin> can I specify it in my cabal file directly?
10:47:52 <Welkin> with "allow-newer"
10:48:28 <cocreature> no you need to specify it as a cli arg (or in your cabal.project/cabal.project.local file)
10:51:09 <Lears> It looks like it wants NoStarIsType to use * as a type operator with recent GHC.
10:51:34 <Welkin> what's going on now?
10:51:53 <Welkin> after I added a cabal.project file new-build complains that it can't find my *.cabal file
10:55:21 <Welkin> I don't understand what's happening
10:55:44 <Welkin> if I add a cabal.project file, cabal suddenly can't find my *.cabal or my cabal.project file
10:58:27 <amalloy> why isn't join part of the Monad typeclass, with defaults for >>= and join implemented in terms of each other? 
10:59:58 <Welkin> cocreature: neither of your suggestions worked
11:00:30 <Welkin> what's really weird about the cabal issue I am having is if I add an explicit `packages` declaration to my cabal.project file, it can suddenly find the *.cabal
11:00:46 <Welkin> even though it's supposed to default
11:01:21 <sclv> where does it say that's the default?
11:01:55 <Welkin> in the docs
11:02:05 <Welkin> https://www.haskell.org/cabal/users-guide/nix-local-build.html?highlight=project#cfg-field-packages
11:02:30 <rain1> https://www.codewars.com/kata/last-digit-of-a-huge-number/train/haskell
11:02:55 <sclv> huh
11:04:58 <Welkin> I don't know if the author of beam is on irc
11:05:14 <Welkin> but they have not uploaded the latest version to hackage for some odd reason
11:05:30 <Welkin> can I upload it myself?
11:09:06 <cocreature> no you can’t but you can point to the git repo in your cabal.project file so it fetches it from there instead of from hackage
11:11:38 <Welkin> where do I do that?
11:11:48 <Welkin> the only place I see is `packages`
11:11:53 <Welkin> but that looks like it's for cabal files
11:12:00 <Welkin> the wording is not clear
11:12:45 <Welkin> also there is no tarball for this, just source code
11:13:55 <sclv> there's source-repository-package but i'm not sure what version of cabal-install you need for it
11:14:18 <Welkin> 2.4.1.0
11:14:22 <Welkin> ghc 8.6.3
11:15:16 <sclv> https://cabal.readthedocs.io/en/latest/nix-local-build.html#specifying-packages-from-remote-version-control-locations
11:15:28 <Welkin> I downloaded the beam-core sourcecode locally, compiled it and ran the tests, then copied the source into a local directory inside my project
11:17:25 <kosmikus> WilliamHamilton[: do you have a gist or repo with the problem for me to look at tomorrow?
11:18:35 <cocreature> 2.4 should be sufficient for source-repository-package
11:19:45 <Welkin> okay
11:19:50 <Welkin> I'm trying it now and it looks like it may work
11:19:51 <Welkin> thanks!
11:22:54 <sclv> if cabal.project works differently with our without packages specified even though there's a default, that might be worth filing a ticket over?
11:25:18 <Welkin> oh damn it
11:25:26 <Welkin> another beam package failed with another type error now
11:26:17 <Welkin> I guess the universe doesn't want me to use beam
11:26:41 <Welkin> and yes I'll file a ticket
11:35:11 <rain1> I cant solsve this problem
11:37:11 <infinisil> rain1: Well, what have you tried?
11:37:24 <infinisil> People here won't solve any problems for you
11:44:57 * hackage hakyll-images 0.2.0 - Hakyll utilities to work with images  http://hackage.haskell.org/package/hakyll-images-0.2.0 (LaurentRDC)
11:45:15 <NoidedSuper> rain1: what problem?
11:45:25 <rain1> https://www.codewars.com/kata/last-digit-of-a-huge-number
11:45:33 <rain1> basicaly a^(b^c) mod 10
11:46:29 <NoidedSuper> This is really a math problem and not a coding one imo
11:47:24 <codedmart> I can't remember answer that I got, but I have a `readCreateProcessWithExitCode` that never exits. How can I go about debugging that?
11:48:46 <Welkin> wow, I'm really liking everything about selda
11:48:58 <Welkin> super lightweight dependencies, extremely simple api/dsl
11:49:07 <dmj`> +1 for selda
11:49:13 <Welkin> it literally had to install just itself to update my project!
11:49:16 <NoidedSuper> rain1: use Euclid's algorithm 
11:49:21 <Welkin> beam re-compiled everything
11:49:35 <Welkin> dmj`: I found your servant example using it
11:49:39 <NoidedSuper> https://en.wikipedia.org/wiki/Modular_exponentiation
11:50:13 <Welkin> dmj`: there is only one thing that may be an issue in selda: no composite primary keys (but that can be fixed of course)
11:52:51 <dmj`> Welkin: some of the internals for encoding / decoding could be more efficient, that may have been changed. But postgresql-binary would be a nice addition
11:53:41 <dmj`> would be nice if a db library fully took advantage of GHC.Generics
11:54:36 <dmj`> do { select @Person >>= \p -> guard (p ^. age > 18) >> return (p ^. name) }
11:55:00 <dmj`> one came out recently that kind of did, but I don't think it supports joins yet
11:55:16 <infinisil> NoidedSuper: You sure that works? Because the exponent can't even fully be evaluated either
11:56:04 <NoidedSuper> Oh, right. Yeah that might not actually work, oops. 
11:56:58 * hackage hakyll-images 0.3.0 - Hakyll utilities to work with images  http://hackage.haskell.org/package/hakyll-images-0.3.0 (LaurentRDC)
11:58:48 <infinisil> I have a pretty clear idea on how to solve this one though, won't talk about the approach here though
12:05:34 <Welkin> oh wow
12:05:44 <Welkin> selda doesn't even use postgresql-simple, just libpq
12:10:06 <Welkin> dmj`: it doesn't look like selda supports json either right now
12:10:12 <Welkin> json/jsonb
12:12:57 * hackage np-extras 0.3.1.2 - NumericPrelude extras  http://hackage.haskell.org/package/np-extras-0.3.1.2 (BrentYorgey)
12:17:51 <tdammers> that's kind of my main beef with SQL abstractions - the simple stuff is usually great, but once you start wanting semi-advanced SQL constructs, the abstraction proves insufficient, unreasonably complicated, or slow
12:19:30 <Welkin> it can be added no problem
12:19:39 <Welkin> looking at beam, it supports everything you would want
12:19:47 <Welkin> except possibly the most advanced/newest features
12:19:57 <Welkin> but I can't get the damn thing to compile
12:20:40 <Welkin> one thing that is a bit bothersome about selda that I have come across reading issues and pull requests is the author is reluctant to add anything specific to postgres that cannot be mapped to sqlite in some way
12:20:45 <Welkin> which is a poor choice in my opinion
12:23:00 <Welkin> this is why gremlin is such a good idea
12:23:12 <Welkin> it's a graph query language that runs on tons of different databases
12:23:27 <Welkin> no need to re-learn some new hacked together query language
12:23:48 <Welkin> and graph databases don't have types other than json or binary
12:25:58 * hackage ttl-hashtables 1.3.0.0 - Extends hashtables so that entries added can be expired after a TTL  http://hackage.haskell.org/package/ttl-hashtables-1.3.0.0 (erick)
12:37:49 <dmj`> I want a DB interface that allows me to do joins on vanilla haskell data types (w/o any kind of annotation), just using the metadata available via GHC.Generics
12:38:25 <Welkin> that is how ActiveRecord and Ecto work in my experience
12:38:28 <Welkin> which is very nice
12:38:45 <Welkin> you can pretend that you are working with native data types and the database layer is an implementation detail
12:38:55 <Welkin> at least for simple joins
12:39:21 <Welkin> well, it looks like I can't get beam to compile at all
12:39:30 <Welkin> and selda doesn't support json
12:39:49 <Welkin> so that means workarounds storing it as a blob or something
12:39:52 <Welkin> and more work in servant
12:40:12 <dmj`> GHC.Generics can create SQL DDL statements from a Haskell data type very simply, already have code for that part. It's the query DSL using the Generics metadata that is the elusive holy grail
12:42:07 <Welkin> dmj`: do you have any examples of working with json in selda?
12:42:27 <Welkin> or should I just give up on that and decode it from the http request as a blob
12:43:05 <dmj`> Welkin: yea I'd just keep it all haskell types
12:43:34 <Welkin> the problem is I have a sum of products in elm, and the same kind of thing in haskell
12:43:59 <Welkin> but I would rather not have to complicate it by duplicating them entirely on both server and client
12:44:19 <dmj`> why not use ghcjs and share the code
12:44:20 <Welkin> so I have a simple record on the server with a content field of type Value
12:44:42 <Welkin> I chose elm for a reason and already wrote 14k lines of it. The app is done
12:44:58 <dmj`> I guess elm is a faster compiler
12:45:01 <Welkin> I was doing some weird tricks to store an adt in a single table
12:45:14 <Welkin> but now that I am not using postgresql simple anymore, I need another solution
12:45:36 <dmj`> Why not just use postgresql-simple
12:45:39 <Welkin> so I changed it to a single record with a `content` field
12:45:45 <Welkin> I was
12:45:53 <Welkin> the code was very complicated though
12:45:57 <Welkin> even though I had it working
12:46:40 <Welkin> I don't want to use it any more because it gives no type safety
12:46:49 <Welkin> and I have a collection of sql scripts with the schema in it
12:47:28 <Welkin> I actually tried to replace postgres with a suitable nosql store
12:47:35 <Welkin> but the biggest problem there is lack of client libraries in haskell
12:47:48 <Welkin> it could easily be replaced by rethinkdb or arangodb
13:04:21 <tdammers> let me tell you a secret
13:04:40 <tdammers> it's easier to start with the data model and then build application code on top than the other way aronud
13:06:18 <Welkin> I already have the data model. I did that months ago
13:06:26 <Welkin> relational databases don't support my data model
13:06:45 <Welkin> json or native types
13:06:58 <Welkin> so I have to use workarounds
13:07:07 <Welkin> I'd love to use a document store for this
13:07:14 <tdammers> or rethink your data model
13:07:18 <Welkin> the rethinkdb client in haskell is a bit old, but may work
13:07:28 <Welkin> how would I rethink my data model?
13:07:37 <Welkin> it's json because it's a javascript application
13:07:42 <tdammers> BEEP
13:07:49 <tdammers> that's a lousy reason
13:07:58 <Welkin> I map them to ADTs in elm
13:08:02 <Welkin> that part is easy
13:08:09 <tdammers> model your data after the problem, not after the technical implementation details
13:08:14 <Welkin> if I store them in a database as json then there is no issue
13:08:42 <monochrom> Yeah I would not use an input/output format verbatim as my internal data model.
13:09:03 <Welkin> I don't do anything with the data on the server
13:09:20 <Welkin> it's almost entirely for storage
13:09:28 <Welkin> when elm gets it, it gets decoded to ADTs
13:09:41 <tdammers> if that's the case, why not just dump it into json-encoded files and call it a day
13:09:56 <Welkin> because that is stupid
13:10:21 <Welkin> a document database can query and manipulate your json data *inside* the database
13:10:27 <Welkin> if you need to
13:10:32 <Welkin> and validate it
13:10:57 <Welkin> you can run mapreduce
13:10:58 <tdammers> I'm exaggerating a little here, but my point is that you seem horribly stuck in technical implementation details, when you should be thinking about the problem domain
13:11:08 <Welkin> yes
13:11:15 <tdammers> your problem domain isn't map/reduce, JSON, JavaScript, or any of that.
13:11:17 <tdammers> those are tools.
13:11:36 <tdammers> forget the tools, think about the problem, its structure, its components
13:11:54 <Welkin> I have been building this form onths and already did all of that a long time ago
13:11:58 <Welkin> for months*
13:12:02 <tdammers> what are the things you need to represent? what do they consist of? what are their shapes? how do they relate to one another?
13:12:12 <Welkin> they don't relate at all
13:12:18 <tdammers> impossible
13:12:24 <Welkin> they are literally json documents
13:12:32 <tdammers> uhm
13:12:34 <Welkin> sure, they have some foreign keys
13:12:36 <Welkin> I already modled that
13:12:39 <Welkin> modeled*
13:12:49 <Welkin> it was very easy to model in a document store
13:12:53 <monochrom> I wouldn't argue either, tdammers :)
13:12:56 <tdammers> so your json documents represent json documents?
13:13:07 <Welkin> I modeled it both in normalized relational models and as a document model
13:13:07 <tdammers> monochrom: yeah, you're probably right
13:13:39 <tdammers> oh, and did you know that with postgresql's jsonb type, you can have both?
13:13:48 <Welkin> I am already using that
13:14:18 <tdammers> so what exactly is the problem?
13:15:36 <Welkin> I am moving to a better library than postgresql-simple, but I can't get beam to compile, and selda doesn't support json
13:17:53 <tdammers> have you looked at couchdb btw.? it uses json-over-http(s) as its protocol, so you can essentially use your favorite json and http client libraries to talk to it, no special library needed (though you may want a lightweight abstraction layer on top)
13:18:15 <tdammers> provided that "a bag of json documents" really is the data model you want
13:18:20 <Welkin> I am using couchdb already
13:18:25 <Welkin> it is one part of the system
13:18:37 <Welkin> I would love to only use it and not have to deal with anything else
13:18:44 <tdammers> but?
13:18:45 <Welkin> but it doesn't support the authentication model I need
13:18:50 <Welkin> so I have to add this extra stuff on top
13:19:02 <tdammers> authentication or authorization?
13:19:06 <Welkin> both
13:19:23 <tdammers> hum
13:19:48 <tdammers> I don't understand why authentication has to relate to your document store at all
13:19:51 <Welkin> I do user account management in postgres
13:20:07 <Welkin> and well, I am storing messages there too
13:20:17 <tdammers> why?
13:20:36 <tdammers> I'd just keep the authentication stuff in a separate database entirely
13:20:48 <Welkin> I am
13:20:56 <Welkin> I do no authentication on couchdb
13:21:11 <Welkin> it's in admin party-line mode over a reverse proxy
13:21:35 <Welkin> my application checks the permissions during reverse proxying
13:21:36 <tdammers> yeah, makes sense. only the app server is ever going to talk to couchdb anyway
13:22:13 <Welkin> I tried to model storing all of this data in redis, and I came up with an okay model, but the client in haskell is so terrible it wasn't worth it
13:22:25 <Welkin> and data persistence in redis isn't great
13:22:54 <tdammers> who'da thunk
13:22:55 <Welkin> I modeled it for a document store like rethinkdb and it was much better
13:23:19 <tdammers> "let's store valuable data in a caching system and then complain that its persistence is shitty"
13:23:30 <Welkin> I'd like to store messages in couchdb but I see it not working
13:23:50 <tdammers> (or, alternatively, "let's store data in a search index and then complain about weird edge cases")
13:24:09 <Welkin> each client has a copy of the database (using pouchdb) and writes to its local database, which then syncs with the server (couchdb)
13:24:22 <tdammers> yeah, I'm familiar with the approach
13:24:28 <monochrom> Het tdammers, I store can't-afford-to-lose course material on shitty SSD in my cheapo Dell laptop and then complain that Dell's SSD is shitty! >:)
13:24:32 <Welkin> but the way revisions work means that if two people send messages around the same time, one will be rejected
13:24:35 <monochrom> s/Het/Hey/
13:24:38 <Welkin> because the revision id will be outdated
13:24:41 <monochrom> Also I still haven't done a backup!
13:25:04 <monochrom> Speaking of which maybe I should start doing backups again!
13:25:27 <Welkin> unless I store every message in its own separate document
13:25:42 <Welkin> but then I have no easy way of sorting them in order
13:25:53 <Welkin> instead of simply appending new messages to an array
13:25:57 <monochrom> Neat, duplicity is still a thing.
13:26:37 <tdammers> IIRC you can override the logic for merging couchdb documents
13:26:50 <Welkin> where does it say that?
13:27:12 <Welkin> the couch docs are pretty hard to follow, nd I had to figure out a lot of the behavior on my own or by asking around
13:27:27 <tdammers> it's been ages since I've used that stuff, but there is a way to say how exactly to resolve merge conflicts
13:28:07 <tdammers> I talked to a team who built a point-of-sale system on couchdb, and they had essentially been running into the exact same problem
13:28:15 <tdammers> only their "messages" were ledger lines
13:28:42 <tdammers> so initially, when two cash registers sent their data simultaneously, the system would throw away one of the two transactions
13:28:54 <tdammers> but they changed the merge conflict resolution to instead append both lists
13:29:06 <tdammers> I can't for the life of me remember how exactly you do that though
13:29:21 <Welkin> that would be perfect
13:29:39 <Welkin> because storing chat messages in postgres is stupid when I could just have them ready to go in a list
13:30:12 <Welkin> it would also simplify another part of the system: the message queue used to send out updates to clients
13:30:25 <Welkin> and I could probably use couchdb to store everything at that point
13:30:29 <Welkin> and get rid of postgres
13:30:45 <Welkin> I knew it had some kind of conflict resolution system, but I hadn't read anything about how to use it
13:30:50 <tdammers> arguably, the authentication part might be a better fit on postgres
13:30:54 <Welkin> why?
13:31:07 <Welkin> I can already hash passwords and generate uuids in haskell
13:31:13 <Welkin> also, couch generates uuids anyway
13:31:26 <tdammers> ACID tho
13:31:33 <Welkin> that doesn't mean anything
13:31:50 <Welkin> there is no standard
13:31:51 <Welkin> it's marketing
13:31:55 <NoidedSuper> You could technically get weird race conditions involving users changing their password
13:31:57 <tdammers> it's a concept
13:32:02 <NoidedSuper> and ACID stuff is like tested 
13:32:09 <Welkin> NoidedSuper: users cannot change their password
13:32:27 <tdammers> users must be allowed to change their password. not doing so is a security problem.
13:32:35 <Welkin> maybe at some point
13:32:38 <tdammers> means they cannot mitigate a compromised password
13:32:58 <zachk> how would one even know if their password is ever compromised?
13:33:19 <NoidedSuper> somebody logs in as you
13:33:19 <tdammers> zachk: "oh shit, I accidentally pasted my password into IRC"
13:33:22 <__monty__> zachk: One assumes it is and periodically changes their passwords : )
13:33:30 <Welkin> I haven't added an email server
13:33:36 <Welkin> email client*
13:33:36 <zachk> tdammers, yea I guess that would do it
13:33:41 <Welkin> that would make it even more complicated
13:33:58 <Welkin> better than a password would be a one-time login token you get via email
13:34:09 <Welkin> that expires in 24 hours or so
13:34:28 <Welkin> anyway, back to couchdb
13:34:34 <DigitalKiwi> zachk: password reuse and someone else gets hacked is common
13:34:43 <tdammers> Welkin: you could also piggy-back on someone else's password management, e.g. by implementing OAuth - then the whole rabbit hole is the problem of google, github, facebook, or whichever OAuth provider you or your users pick
13:34:47 <DigitalKiwi> https://haveibeenpwned.com/
13:35:05 <tdammers> Welkin: the downside of course is that you are then down the rabbit hole of implementing OAuth
13:35:12 <Welkin> auth is the biggest pain in the ass for every project I have worked on
13:35:30 <Welkin> but I found a happy path of some kind at least
13:37:28 <Welkin> okay then, I'll try this path, since the other dozen haven't worked
13:39:51 <dmwit> zachk: There are also big lists out there available of compromised passwords. You can check if yours is on it.
13:40:40 <dmwit> In some cases only the compromised password database (i.e. hashes and salts) are available but tech-savvy folks can still learn if their password is in that compromised DB.
13:42:02 <monochrom> Sometimes you just assume you're fight a Borg ship therefore you just randomly modulate your shield frequency without asking "is my shield frequency compromised?" because the answer is always "yes'. >:)
13:42:06 <DigitalKiwi> that site above lets you check
13:42:43 <zachk> oh ty
13:44:12 <DigitalKiwi> troy hunt has a few interesting posts about various parts of it too
13:47:18 <suzu> lol i just went through this
13:47:37 <suzu> i'm storing some files up in backblaze (aws s3 alternative)
13:47:56 <suzu> backblaze doesn't encrypt anything on your behalf, so if you'd like encryption it must be done yourself
13:48:21 <suzu> so you think, okay, i'll just make up a symmetric key and encrypt/decrypt with it. easy peasy
13:48:54 <suzu> nope, not good enough. suppose that your object store were compromised - your key can be revealed if an attacker is allowed to manipulate the ciphertext and watch what your server does, in many cases
13:49:36 <suzu> alright, so now you must also verify the integrity of the file so you know nobody is screwing around with the contents trying to catch you slip. so you say "oh i'll add an integrity check with a hash"
13:50:18 <infinisil> Security is pretty hard to get right
13:50:33 <suzu> not good enough. regularly hashing things opens you up to a key-length extension attack. if i have the hash of something and am able to append to the something, i can create new hashes without knowing the original content for messages that are longer
13:50:47 <suzu> okay okay, so you say "i'll use an HMAC!"
13:51:03 <suzu> alright, so do you hmac the plaintext? the ciphertext? the plaintext and encrypt the whole thing? encrypt hte plaintext and then hmac that?
13:51:11 <suzu> (there is only one correct answer)
13:51:22 <infinisil> The correct answer is to use AES in GCM mode :)
13:51:35 <__monty__> You could also use an authenticated encryption scheme, then all the thinking has been done for you.
13:51:37 <suzu> and THEN you gotta pick a crypto library in haskell. i picked saltine because it binds to libsodium
13:51:49 <suzu> and yep ^ it does all this thinking
13:52:13 <Guest10134> hi all
13:52:21 <suzu> aaaanyway yeah. security is hard
13:52:45 <Guest10134> How can I change my username again?
13:52:51 <Guest10134> with /username?
13:53:00 <suzu> in other news, all the tls stuff in haskell seems to rely on the `tls` package which is a pure haskell impl of tls schemes. this is likely susceptible to all kinds of attacks :(
13:53:03 <suzu> Guest10134: /nick
13:53:05 <koz_> Guest10134: /nick is what you seek
13:53:08 <nyc> With /nick
13:53:10 <koz_> suzu: I owe you a soda? :P
13:53:20 <suzu> haha ok :D
13:53:45 <zerocoding> thans
13:53:48 <zerocoding> thanks
13:54:06 <zerocoding> I have a question about spacemacs and hasekll mode
13:54:17 <Rembane> Shoot! 
13:54:26 <koz_> zerocoding: Don't ask to ask. :)
13:54:32 <koz_> (meta-ask?)
13:54:55 <infinisil> suzu: I'm a bit worried now, the tls package doesn't seem to have any security review done
13:54:58 <zerocoding> I followed this tut https://github.com/syl20bnr/spacemacs/tree/master/layers/%2Blang/haskell#install to install haskell mode
13:55:03 <infinisil> And no verification as far as i can see
13:55:07 * koz_ o O (ask to ask = Ask -> Ask)
13:55:09 <zerocoding> It does not work at all 
13:55:46 <zerocoding> for example autocompletion does not work
13:55:59 <zerocoding> I am using stack
13:56:06 <suzu> infinisil: yeah.. so am i
13:56:11 <zerocoding> I installed install apply-refact hlint stylish-haskell hasktags hoogle
13:56:24 <zerocoding> I installed `stack install apply-refact hlint stylish-haskell hasktags hoogle`
13:56:36 <koz_> zerocoding: Is ~/.local/bin on your PATH?
13:56:44 <monochrom> koz_: I think it's "Ask (Ask a)" instead. Like "IO (IO a)"
13:56:45 <suzu> infinisil: in fact.. https://github.com/vincenthz/hs-tls/issues/117
13:56:55 <koz_> monochrom: Is Ask a monad?
13:56:57 <suzu> > we (the Debian Haskell package maintainers) have been approached by the security team to find out whether haskell-tls is affected by CVE-2013-0169, and if so, what versions
13:56:59 <lambdabot>  <hint>:1:147: error: parse error on input ‘,’
13:57:07 <zerocoding> The content of spacemacs is:
13:57:09 <monochrom> Yes!
13:57:16 <zerocoding>   dotspacemacs-configuration-layers
13:57:16 <zerocoding>    '(
13:57:16 <zerocoding>      ;; ----------------------------------------------------------------
13:57:16 <zerocoding>      ;; Example of useful layers you may want to use right away.
13:57:16 <zerocoding>      ;; Uncomment some layer names and press <SPC f e R> (Vim style) or
13:57:18 <zerocoding>      ;; <M-m f e R> (Emacs style) to install them.
13:57:21 <zerocoding>      ;; ----------------------------------------------------------------
13:57:23 <zerocoding>      helm
13:57:25 <suzu> uhh
13:57:26 <zerocoding>      ;; auto-completion
13:57:28 <zerocoding>      ;; better-defaults
13:57:31 <zerocoding>      emacs-lisp
13:57:33 <zerocoding>      ;; git
13:57:33 <koz_> zerocoding: Gist or pastebin that please.
13:57:35 * suzu sighs
13:57:36 <zerocoding>      ;; markdown
13:57:38 <koz_> Don't spam the chat.
13:57:38 <zerocoding>      ;; org
13:57:41 <zerocoding>      ;; (shell :variables
13:57:42 --- mode: ChanServ set +o monochrom
13:57:43 <zerocoding>      ;;        shell-default-height 30
13:57:43 * Karrq omg that I joined into
13:57:45 <suzu> tey can't hear you
13:57:46 <zerocoding>      ;;        shell-default-position 'bottom)
13:57:46 <suzu> kick plz
13:57:48 <zerocoding>      ;; spell-checking
13:57:48 --- mode: monochrom set +q zerocoding!*@*
13:57:54 <Karrq> thanks
13:57:58 --- mode: monochrom set -o monochrom
13:58:00 <suzu> once the paste starts it just goes
13:58:13 <Karrq> what was that
13:58:22 <suzu> it looks like a spacemacs configuration file
13:58:25 <suzu> (i use spacemacs)
13:58:26 <Karrq> well yeah
13:58:27 <koz_> Karrq: Someone seeking help with Spacemacs and haskell-mode.
13:58:28 <monochrom> I'll do -q after a minute or something.
13:58:42 <suzu> sadly zerocoding can't write any responses until the paste is done
13:58:46 <infinisil> suzu: Oh, reading that tls issue
13:58:51 <suzu> as it all gets buffered and then doled out slowly in the channel
13:59:02 <infinisil> suzu: The owner doesn't really respond well..
13:59:08 <suzu> yeah that is a bad response
13:59:09 <infinisil> Bad sign
13:59:13 <koz_> infinisil: Link?
13:59:17 <suzu> "go make your own tls library wit hblackjack and hookers then"
13:59:20 <Karrq> oh so it was a paste done in spacemacs thru the spacemacs irc?
13:59:25 <suzu> koz_: https://github.com/vincenthz/hs-tls/issues/117
13:59:27 <koz_> suzu: For real?
13:59:29 --- mode: ChanServ set +o monochrom
13:59:42 <suzu> yes. "you're more than welcome to create your own library"
13:59:45 --- mode: monochrom set -q zerocoding!*@*
13:59:51 --- mode: monochrom set -o monochrom
13:59:54 <suzu> or "create an attack that will make you rich !"
13:59:56 <suzu> direct quotes
14:00:23 <koz_> suzu: Thanks for bringing that to my attention.
14:00:33 <koz_> _Is_ there an alternative to that library?
14:00:36 <zerocoding> koz_: this is my profile https://pastebin.com/r40zTY7h
14:00:38 <suzu> y.es
14:00:40 <Clint> no, there is no better alternative
14:00:44 <suzu> i think silk had one
14:00:59 <suzu> jk nope
14:01:01 <suzu> that is a fork
14:01:11 <zerocoding> what am I doing wrong?
14:01:11 <koz_> suzu: That's... pretty damn concerning to say the least.
14:01:21 <Karrq> so guys, I joined because I was looking to setup a Haskell IDE (or the closest thing to it). What would you recommend? I don't plan on using vim nor emacs, mind you
14:01:26 <suzu> there is no analog
14:01:28 <jaarod> what do you guys think of this?  
14:01:32 <sedeki> Karrq what OS?
14:01:46 <suzu> and if there were, it wouldn't matter because the ecosystem is built on `tls`
14:01:50 <sedeki> Karrq there is "Haskell for Mac" in the App Store on Mac, but it costs money
14:01:53 <suzu> warp-tls, http-client-tls
14:01:56 <koz_> suzu: Uhhh. If I knew how to do bindings to C things, _I would be writing one right now because omgwtfbbq_.
14:02:00 <zerocoding> and the content of spacemacs file https://pastebin.com/qV0pNQKc
14:02:04 <jaarod> what do you guys think of this?
14:02:08 <Karrq> Windows mainly. Linux is fine too
14:02:08 <jaarod> "The foldl function is broken. Everyone knows its broken. Its been broken for nearly a quarter of a century. We should finally fix it!  Today I am proposing that Prelude.foldl be redefined using the implementation currently known as Data.List.foldl'."
14:02:09 <suzu> binding to C isn't very difficult koz_. i've done it
14:02:16 <jaarod> from: http://www.well-typed.com/blog/90/
14:02:20 <zerocoding> Am i missing anything?
14:02:26 <suzu> if you could write openssl bindings and start selling people on it, that'd be glorious but it would be a large undertaking
14:02:28 <sedeki> Karrq can't help you there
14:02:37 <koz_> suzu: In an area I basically have _zero_ understanding of.
14:02:41 <suzu> you'd essentially need to go and port popular libraries to use your work
14:02:48 <suzu> "hey warp here's a PR that moves to using libopenssl"
14:03:02 <koz_> suzu: I'm down to collaborate if you are.
14:03:03 <Clint> there are openssl bindings but the problem with them is that they use openssl
14:03:13 <koz_> What else am I gonna do while I wait for recruiters and jobs to respond to me anyway?
14:03:14 <suzu> i'd love to but currently can't. i've got too much on my plate already :(
14:03:23 <suzu> are you looking for a haskell job?
14:03:45 <Rembane> Karrq: Visual Studio + HIE?
14:03:52 <koz_> suzu: I'd be OK to do this, but _only_ if someone whose understanding of security isn't https://imgur.com/Dv6pusI helps.
14:03:57 <koz_> suzu: In an ideal world.
14:04:01 <infinisil> Clint: If somebody depends on being as secure as possible, that shouldn't be a problem
14:04:09 <koz_> In reality, I'm more likely to end up a data grinder or doing something with my C knowledge.
14:04:13 <Karrq> sorry my connection dropped there
14:04:18 <suzu> hehe that doge
14:04:21 <koz_> Since around _here_, _nobody_ uses Haskell for anything that pays money.
14:04:27 <koz_> suzu: dogr.io is your friend.
14:04:27 <suzu> wrong! i do
14:04:29 <Clint> infinisil: if somebody depends on being as secure as possible, they should stay as far away from openssl as possible
14:04:30 <marvin2> zerocoding, consider also asking in #spacemacs and/or on their gitter chat
14:04:44 <koz_> suzu: Are you in New Zealand?
14:04:53 <suzu> my previous job was haskell. i made it so by never shutting the fuck up about how if you let me do haskell i'd get a bunch of shit done
14:04:54 <Karrq> Rembane: I've tried it but.... meh?
14:05:00 <infinisil> Clint: Oh? Maybe I'm not quite up to date
14:05:07 <suzu> i quit a few months back to try and start my own business now, which i'm working on
14:05:08 <Peaker> Is ghc smart enough to optimize away constraints' Dict, withDict, etc -- when using those on statically known types? perhaps with SPECIALIZE? Can a GADT pattern match with a constraint in it become a no-op?
14:05:09 <suzu> no, Canada :(
14:05:19 <koz_> suzu: Unfortunately relocation isn't an option for me.
14:05:21 <Rembane> Karrq: Then I don't know, I use Vim and it works well for me. 
14:05:22 <koz_> (family-related)
14:05:28 <MarcelineVQ> sure are a lot of haskellers in canada
14:05:33 <suzu> i'm not in a position to hire anyway, so no offence taken
14:05:34 <Clint> infinisil: it's not public knowledge
14:05:39 <suzu> i ain't got no customers yet
14:05:40 <koz_> suzu: None was intended. :)
14:05:43 <infinisil> koz_: suzu: I did take an information security and network security course, but I forgot most of it already :P
14:05:43 <suzu> :)
14:05:47 <suzu> infinisil: :(
14:05:57 <koz_> infinisil: That's quite a bit ahead of me.
14:06:20 <Karrq> any other suggestions? has anybody tried IntelliJ's plugins?
14:06:35 <zerocoding> aha
14:06:57 <zerocoding> marvin2: Thanks
14:07:02 <Peaker> In a generalized AST library, with type-class generic inference / unification (in the spirit of unification-fd, but generalized to more flexible AST types)  -- I'm seeing very bad performance, and 33% of runtime is within withDict. Would SPECIALIZE disappear that?
14:11:52 <v0d1ch> dminuoso: I don't think this is exactly what you had in mind but... https://gist.github.com/v0d1ch/9eebe587109521238fef06fd8068f9fc
14:12:32 <v0d1ch> it would be nice if only one thing typechecked so I know I nailed it
14:13:04 <DigitalKiwi> Clint: oh? do tell
14:13:31 <v0d1ch> anyway I am off for the night, will be dreaming about cps
14:15:11 <zerocoding> I tried to install ghc-mod and I've the following error https://pastebin.com/8xGSUdat
14:15:28 <zerocoding> Is it normal?
14:17:02 <infinisil> "normal" as in "would that error appear on other people's machines when they have the same set up as you?" Yes, because cabal is pretty deterministic in its behavior
14:17:51 <infinisil> "normal" as in "Does that error happen in a working haskell environment?" No, because errors shouldn't be there in a working environment, by definition, errors mean it doesn't work
14:19:34 <__monty__> DigitalKiwi: I suspect they're apprehensive because of heartbleed. Bugs having been found and solved doesn't mean something's untrustworthy though, you might say it makes it *more* trustworthy in fact.
14:19:37 <geekosaur> it is, however, expected because ghc-mod hasn't been updated for recent ghc
14:19:40 <zerocoding> Do I need ghc-mod for autocompletion
14:19:51 <zerocoding> aha ok
14:20:20 <suzu> if you're using spacemacs
14:20:22 <geekosaur> and generally fi youre using stack, you're using intero because it's part of the whole Stack Way(tm)
14:20:27 <suzu> don't bother with ghc-mod and just use intero
14:20:42 <zerocoding> yes I am using spacemcs
14:20:47 <suzu> yeah just get on intero
14:20:50 <suzu> and use stack
14:21:56 <Clint> DigitalKiwi: i'm not legally permitted
14:22:08 <suzu> infinisil | koz_: suzu: I did take an information security and network security course, but I forgot most of it already :P
14:22:12 <suzu> infinisil: just remember the golden rule
14:22:20 <suzu> verify an HMAC before you do anything else
14:22:56 <zerocoding> I've followed this tutorial http://spacemacs.org/layers/+lang/haskell/README.html
14:23:09 <__monty__> Clint: Upcoming CVE?
14:23:17 <suzu> and use saltine/libsodium.
14:23:20 <zerocoding> and did stack install apply-refact hlint stylish-haskell hasktags hoogle
14:23:37 <zerocoding> and it is still does not work
14:23:44 <suzu> Clint: do the openssl maintainers know and has it been patched
14:26:21 <Clint> i can't answer these questions
14:26:39 <Clint> but i can tell you i'd rather trust my data to the tls package than to hsopenssl
14:27:06 <zerocoding> How to open haskell project with spacemacs?
14:27:10 <suzu> you cannot answer to if you have responsibly disclosed it?
14:27:33 <zerocoding> Or it is only possible to open a file?
14:27:34 <suzu> okay
14:27:45 <suzu> Clint: are you talking about libopenssl or hsopenssl?
14:28:26 <Clint> i am talking about openssl == libssl and libcrypto
14:28:35 <suzu> gotcha
14:29:09 <DigitalKiwi> what other things are there than openssl in general anyway
14:29:14 <suzu> you are /not/ talking about libressl, are you?
14:29:17 <suzu> DigitalKiwi: libressl
14:29:22 <suzu> i mean there's a ton
14:29:40 <Clint> DigitalKiwi: https://curl.haxx.se/docs/ssl-compared.html
14:29:44 <suzu> Google wrote one called BoringSSL
14:29:55 <suzu> Apple has their own too
14:30:34 <infinisil> suzu: Oh I used apple's one at some point, it's a pain to use in Swift!
14:30:39 <suzu> fuck swift
14:30:50 <infinisil> suzu: ???
14:30:57 <DigitalKiwi> thanks
14:31:12 <suzu> i felt like their use of incorporating options/maybe into the language was not done well
14:31:46 <suzu> it is still perfectly possible for tons of shit to error out with a 'woops lol that thing was null' because of many libraries abusing option backdoors
14:32:07 <suzu> this was my experience.. two years ago
14:32:23 <infinisil> So it's Swift's fault that libraries use unsafe unwraps?
14:33:11 <suzu> when you put it that way i'm not so sure. so i'll retract my statement, and instead claim "fuck swift libraries"
14:33:13 <infinisil> Swift is probably the best general purpose imperative language out there right now, ignoring problems such as running on Linux and the apple ecosystem
14:33:38 <suzu> i mean, haskell lets you write partial functions. so i guess i cannot say that it is swift's fault
14:33:48 <infinisil> Language-wise, it's really well designed, I used it for multiple years
14:34:07 <chessai> https://gist.github.com/chessai/d44e7f167ec6ef5309e431cda83f4b6c
14:34:13 <chessai> does this function live anywhere?
14:34:26 <sm> infinisil: what other language is it most like ?
14:34:35 <infinisil> sm: I heard Kotlin is very similar to Swift
14:34:44 <sm> interesting
14:34:51 <koz_> infinisil: Rust isn't 'general-purpose'?
14:35:00 <koz_> (I doubt you could argue it's not imperative)
14:36:04 <infinisil> koz_: It is, but the memory model isn't very beginner friendly. Swift makes stuff really easy with automatic reference counting (so no tracing garbage collection), at the cost of potential memory leaks
14:36:42 <infinisil> All around, it's got everything one would need from a programming language, it doesn't have any big flaws as far as I can see
14:37:44 <chessai> infinisil: one thing i've disliked about rust is the lack of abstraction of effects
14:37:57 <chessai> infinisil: other than that i've enjoyed it very much
14:38:24 <infinisil> I see
14:38:48 <infinisil> if this continues on, let's take this to #haskell-offtopic shall we
14:41:30 <chessai> ok
14:48:00 <sm> how do you force brick to redraw the whole screen ? invalidateCache seems not enough
14:48:16 * koz_ saw 'brick' and 'screen' and laughed.
14:48:28 <koz_> It was like 'woah, that sounds angry'.
14:53:24 <suzu> sm: press Ctrl+L
14:53:32 <sm> doesn't work
14:53:36 <suzu> darn
14:53:41 <sm> nice try though :)
14:53:45 <suzu> yeah i thought that would've done it
14:53:50 <suzu> it works for vty iirc
14:54:21 <suzu> uhjhhh
14:54:25 <suzu> invalidate the cache and force a resize?
14:54:59 <suzu> i think that should do it, though it is kinda the nuclear method
14:57:33 <geekosaur> I'm not under the impression the cache is relevant here, since what's cached is not the actual screen state but individual widgets (and not all of those)
15:01:28 <sm> I see Vty provides a refresh :: IO ()..
15:05:22 <sm> that does it! nice!
15:05:58 * sm implements C-z suspend
15:36:14 <sm> suspend = raiseSignal sigSTOP; redraw st = getVtyHandle >>= liftIO . refresh >> continue st; suspendAndRedraw ui = liftIO suspend >> redraw ui
15:36:41 <sm> just need to restore the terminal attributes when suspending
16:02:00 <Muttsuri> Hello
16:05:33 <Muttsuri> Hello ?
16:05:48 <koz_> Muttsuri: Hola.
16:06:05 <Muttsuri> Hey this is my first time doing IRC
16:06:12 <Muttsuri> and I have a question
16:06:12 <koz_> Muttsuri: Congratulations!
16:06:27 <koz_> As long as it's (even tangentially) about Haskell, just ask.
16:06:39 <Muttsuri> It is XD
16:06:56 <Muttsuri> I just don't know how big of a rabit hole it is
16:07:08 <Solonarv> only one way to find out!
16:07:13 <Muttsuri> True XD
16:07:36 <Muttsuri> I know that haskell is very smart in figuring patters for list creation
16:08:20 <Muttsuri> I wonder how do you create a function on which you insert a list with part of the sequence and it generates the sequence
16:08:36 <Muttsuri> (I was thinking in the form of an infinite list but maybe there are more usefull data types)
16:08:47 <Muttsuri> (I haven't dabled that much beyond the Prelude)
16:11:28 <Solonarv> you mean, you'd pass [1, 4, 9, 25] and it would spit back [n^2 | n <- [1..] ] ?
16:11:57 <Solonarv> that's not actually feasible in general, from a mathematical PoV
16:12:10 <Muttsuri> humm....
16:12:12 <MarcelineVQ> reads to me like they might just want to see replicate and repeat
16:13:41 <Muttsuri> Alright then
16:13:57 <Muttsuri> I'm still not that aware of where haskell reaches it's limits
16:14:15 <Muttsuri> It's still a bit hard for me to see what seems valid in the middle of all the "magic"
16:14:34 <Solonarv> As a rule of thumb, if you can't do something on paper you can't do it in Haskell either
16:14:39 <Muttsuri> But thank you, sorry for the somewhat meh question
16:14:46 <Muttsuri> Alright, I'll take not of that
16:14:50 <Muttsuri> Thank you :)
16:15:00 <Muttsuri> If I have more doubts I'll return here
16:15:22 <Solonarv> (well, with the obvious "assuming an infinite supply of paper & pens, and infinite time" caveat)
16:15:29 <Muttsuri> HAHAHAHAHA
16:16:07 <Muttsuri> Well sadly I have to go, but I don't think this shall be the last time I land here
16:16:11 <Muttsuri> Thank you :)
16:16:13 <Solonarv> before you go:
16:16:17 <Muttsuri> yes ?
16:16:55 <Solonarv> I'd suggest just lurking in this channel (and #haskell-beginners) and reading what's being chatted about, you can pick up quite a lot of knowledge doing that
16:17:13 <Muttsuri> Thank you I'll add it to my list :)
16:18:09 <pgiarrusso> Muttsuri: Excel does that a bit
16:18:12 <pgiarrusso> 1:11 AM <Solonarv> you mean, you'd pass [1, 4, 9, 25] and it would spit back [n^2 | n <- [1..] ] ?
16:18:36 <Solonarv> yeah, I think I've heard of that
16:19:19 <pgiarrusso> https://www.microsoft.com/en-us/research/blog/deep-learning-program-synthesis/
16:19:28 <pgiarrusso> “Program synthesis” is the general area
16:19:32 <pgiarrusso> Tho this is by example
16:19:52 <Solonarv> Obviously it's possible to hard-code some patterns and recognize them, and you can do fancy analysis stuff, but the general problem is intractable for obvious information-theoretic reasons
16:21:41 <Solonarv> (if I give you [1, 4, 9, 25], how do you know if that's the start of [ n^2 | n <- [1..] ] or [ n^2 + n `div` 10 | n <- [1..] ] ?)
17:04:58 * hackage hspec-need-env 0.1.0.3 - Read environment variables for hspec tests  http://hackage.haskell.org/package/hspec-need-env-0.1.0.3 (debugito)
17:40:39 <NemesisD> expressions in a where clause are lazy, right? meaning if they are unused they won't be computed at all?
17:41:06 <geekosaur> correct
17:41:50 <dmwit> With the possible exception of unboxed bindings, I guess. I can't remember if they're allowed in where blocks or not.
17:46:37 <NemesisD> thanks!
18:30:42 <jle`> NemesisD: note that they are potentially non-lazy if you consider bang patterns
18:31:25 <jle`> `foo x = 10 where !z = x * 2` is sugar for `foo x = (x * 2) `seq` 10
18:31:48 <jle`> @let myFunc x = True where !_ = sum [1..x]
18:31:50 <lambdabot>  Defined.
18:31:54 <jle`> > myFunc 1
18:31:56 <lambdabot>  True
18:31:59 <jle`> > myFunc 1000000000000000000000000000
18:32:07 <lambdabot>  mueval-core: Time limit exceeded
18:32:07 <lambdabot>  mueval: ExitFailure 1
18:32:18 <jle`> i feel bad abusing mueval like this
18:32:38 <Cale> I understand why they made that decision, but I still sort of feel strange about bang patterns being able to do that.
18:33:12 <Cale> The original simple translation of bang patterns wasn't able to do that.
18:33:31 <Cale> (basically turn let into case)
18:42:18 <hololeap> weird question, but which is more idiomatic? `Product (Product t u) v` or `Product t (Product u v)`
18:42:59 <suzu> are those the same thing?
18:43:59 <iqubic> suzu: They are isomorphic.
18:44:00 <amalloy> presuming something like newtype Product a b = Product (a, b)
18:44:26 <iqubic> See.
18:45:24 <Lears> I would go with the former, purely because * associates left and you might want to use it as a type operator synonym.
18:46:21 <hololeap> Lears: great idea
18:47:53 <hololeap> also, is (:*:) from GHC.Generics essentially the same thing as Data.Functor.Product.Product?
18:49:28 <Solonarv> yup
18:55:58 <jle`> hololeap: yeah, and :+: is Data.Functor.Sum.Sum
18:56:16 <jle`> and :.: is Data.Functor.Compose.Compose
18:56:18 <jle`> fun stuff :)
19:07:58 * hackage debian 3.93.5 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.93.5 (DavidFox)
19:08:20 <koz_> jle`: Hihi!
19:08:23 <koz_> Nice to see you here.
19:09:36 <hololeap> @let (<#>) = (*)
19:09:37 <lambdabot>  Defined.
19:09:41 <hololeap> @let (:*:) = (*)
19:09:42 <lambdabot>  .L.hs:164:1: error: Not in scope: data constructor ‘:*:’
19:09:42 <lambdabot>      |
19:09:42 <lambdabot>  164 | (:*:) = (*)
19:09:56 <hololeap> how come (:*:) isn't a valid function name?
19:10:08 <c_wraith> it's a constructor name
19:10:17 <c_wraith> Same reason Foo isn't a valid function name
19:10:23 <hololeap> i want to set (:*:) = Pair
19:10:23 <c_wraith> It starts with a "capital letter"
19:10:45 <c_wraith> Where ':' is the only capital symbol character
19:11:00 <c_wraith> so..  data Pair a b = a :*: b
19:11:01 <koz_> c_wraith: Oh, so _that_ is how it works.
19:11:07 <glguy> Foo could be a valid function, just not a valid variable
19:14:12 <jle`> koz_: hi! :)
19:14:24 <jle`> hololeap: you could also make a type synonym
19:14:39 <jle`> hololeap: `type (:*:) = Pair`
19:15:03 <hololeap> jle`: wouldn't that be `type (:*:) = Product`?
19:15:05 <jle`> er, Product
19:15:18 <jle`> ah, yeah, i think i misread the level you were working on
19:34:39 <Amr> I'm Amr from Egypt, pm please
20:20:14 <iqubic> Also, you use : at the start of a constructor to make it infix.
22:16:11 <inkbottle> How can I get the AST for some Haskell snippet?
22:17:13 <inkbottle> It seems google already knows ;)
23:43:02 <maerwald> how do you run a specific hspec with cabal new-test?
23:47:29 <maerwald> Seems to only work with new-run, well
