00:34:23 * hackage yam 0.5.2, yam-datasource 0.5.2 (leptonyu): https://qbin.io/raised-menu-133m
03:58:53 * hackage parsec 2.0.0.1 - Monadic parser combinators  http://hackage.haskell.org/package/parsec-2.0.0.1 (HerbertValerioRiedel)
04:10:41 <lavalike> ^ how do you figure out what changed in this version?
04:21:12 <nyc> diff?
04:32:52 * hackage intero 0.1.36 - Complete interactive development program for Haskell  http://hackage.haskell.org/package/intero-0.1.36 (ChrisDone)
04:44:09 <lavalike> thought there was going to be a branch on the repo but no
04:44:22 <lavalike> (and releases only mention v3)
04:50:39 <Mrbuck> My life is so boring so do I need to start programming
04:53:16 <aplainzetakind> how does a fresh ghcup > cabal installation know a default author name when calling `cabal init`?
04:56:43 <aplainzetakind> it reads my git config it seems.
05:44:53 * hackage mediawiki2latex 7.33 - Convert MediaWiki text to LaTeX  http://hackage.haskell.org/package/mediawiki2latex-7.33 (dhun)
05:57:17 <aplainzetakind> is anyone successfully using ghc-mod in v2 style cabal projects?
06:17:27 <librerush>  /quit 
06:17:33 <librerush>  /quit 
06:17:38 <librerush>  /QUIT
06:57:10 <jackboy[m]> Are there any method to organize massive web? So that it is possible to 1) search/index data easily 2)control 3) measure 4) optimize by avoiding duplication info or data 5)etc. Or any other thoughts
07:02:00 <coldpress> aplainzetakind: I don't know what v2 style cabal projects are, but I've tried to install the 8.4 branch of ghc-mod, and although it installed, it didn't work: ghc-mod could not infer any types or expand any cases
07:02:10 <coldpress> so I switched to neovim and am using ghcid instead
07:02:34 <coldpress> wish there was another plugin that can do case expansion though
07:10:41 <coldpress> still trying to wrap my head around tagfiles and aloiscochard/codex
07:13:50 <ClaudiusMaximus> lavalike: http://hdiff.luite.com/cgit/parsec/diff/?id2=2.0&id=2.0.0.1
07:14:12 <z0> is there any difference in using mapM vs sequence $ map ?
07:15:51 <ClaudiusMaximus> @src mapM
07:15:51 <lambdabot> mapM f as = sequence (map f as)
07:16:20 <z0> well that answers it
07:17:03 <z0> @src mapM_
07:17:03 <lambdabot> mapM_ f as = sequence_ (map f as)
07:17:09 <z0> thanks
07:22:55 <lavalike> ClaudiusMaximus: nice, where did you find that website?
07:23:48 <ClaudiusMaximus> lavalike: i knew about hdiff already
07:24:00 <ClaudiusMaximus> lavalike: think from when luite was on irc
07:24:39 <lavalike> ClaudiusMaximus: appreciate it
08:22:59 <nshepperd> is there a thing like --build-depends for cabal new-exec
08:23:16 <merijn> nshepperd: Don't think so, what'd be the point?
08:24:19 <nshepperd> cabal new-exec --build-depends=some-library ./shell-script-that-calls-ghc.sh
08:24:46 <nshepperd> conversely, what's the point of new-exec if you can't get libraries with it?
08:26:36 <merijn> nshepperd: Presumably some-library would be listed in either your cabal file or you cabal.project, so it'd already be build automatically?
08:26:58 <Solonarv> I think the idea is that this would work outside a project too
08:27:32 <merijn> Solonarv: new-X only does something when there is a project (or alternatively an implicit project aka a .cabal file)
08:27:51 <merijn> The semantics of new-X don't make sense if you don't have either a cabal file of cabal.project
08:28:28 <nshepperd> new-repl works outside a project
08:28:36 <nshepperd> it seems to make perfect sense there
08:28:39 <merijn> Define "works"
08:29:52 <nshepperd> I can get a ghci shell with any set of libraries by calling cabal new-repl --build-depends=libraries
08:30:01 <nshepperd> outside a project
08:30:37 <nshepperd> if I can run ghci like that, why now ghc?
08:30:41 <nshepperd> *why not
08:32:12 <Solonarv> (note that currently, cabal new-exec doesn't work at all outside a project)
08:34:52 <Solonarv> but what you're looking for seems to belong to a sandbox-y model, not a nix-style model.
08:35:05 <__monty__> nshepperd: I think you can actually. If you use a cabal shebang for example.
08:35:12 <Solonarv> (and in fact the cabal sandbox feature-set does incude an 'exec' command)
08:35:42 <Solonarv> __monty__: that's for running a Haskell file, not for executing arbitrary commands with packages available in that command's environment
08:35:45 <__monty__> It's runghc maybe but that's still ghc, right?
08:36:05 <__monty__> Solonarv: Ah, hadn't read backlog.
08:36:27 <merijn> I'm not sure what nshepperd wants to do anyway, so I don't have any recommendations for alternatives
08:36:28 <__monty__> Sounds like a *weird* thing to wanna do with GHC rather than GHC*i* though.
08:36:30 <nshepperd> Yeah, I used to use cabal sandbox and cabal exec heavily
08:36:57 <Solonarv> Stack can do it, of course... because it uses a sandbox-y model
08:37:57 <nshepperd> isn't what I'm trying to do *more* nix-y?
08:38:13 <nshepperd> I'm basically describing nix-shell, but for cabal
08:38:33 <nshepperd> (cabal new-exec --build-depends=some-library bash)
08:44:31 <merijn> nshepperd: You can try asking in #hackage, but I'm not sure there's a solution
08:44:56 <merijn> Honestly, I think --build-depends existing is a flaw in new-repl and should probably be removed...but I guess I'm the only one :p
08:46:19 <nshepperd> having to go into a cabal project in order to get a ghci shell with libraries would be incredibly bad
08:46:40 <nshepperd> tch, typical kids these days, removing useful features
08:47:10 <merijn> nshepperd: I doubt it will be removed
08:58:35 <axxxa> hello~
08:59:25 <Solonarv> hello!
09:00:27 <metreo> Can someone explain why xs = [2,3,4]; xs = 1:xs; xs; returns an infinite stream of 1's
09:01:24 <Solonarv> the second definition shadows the first one, so the first definition is completely irrelevant
09:01:28 <merijn> metreo: The second binding is recursive and shadows the first
09:02:11 <metreo> Wow fascinating
09:02:27 <merijn> metreo: Basically, you have written "list = [2,3,4]; xs = 1:xs;" except list is called "xs" :p
09:02:30 <metreo> So the second is recursive
09:03:05 <merijn> metreo: You have defined "xs is a list of 1 consed to xs", which indeed ends up being an infinite list of 1's :)
09:03:51 <metreo> But I only ask for xs once
09:04:03 <merijn> metreo: Do you know C by any chance?
09:04:07 <metreo> Yes
09:04:38 <merijn> metreo: Right, so let's say : is sorta like "struct list { int val; struct list *next; }", right?
09:05:04 <merijn> metreo: You have effectively defined "struct list xs = { 1, &xs };"
09:06:01 <merijn> metreo: So when you call show (or whatever) to print it, it will print a list like it always will: Print one element, recurse to the tail. Except the recursion obviously never terminates, so it just keeps going
09:07:03 <metreo> Thanks I'll let that sink in
09:08:24 <metreo> let x = 1:xs; does not create this issue
09:08:58 <metreo> Yes because of infinate list recursion 
09:09:03 <metreo> Aha!! 
09:09:08 <metreo> :-D
09:10:31 <metreo> So generally Haskell will attempt to completely solve whatever expression is given
09:10:57 <Solonarv> define "completely solve"
09:11:11 <Solonarv> generally speaking, that isn't true at all
09:11:20 <metreo> Deterministic evaluation to a limit
09:11:32 <metreo> Ok 
09:11:42 <Solonarv> (if it were true, writing 'xs = 1 : xs' would immediately hang GHCi)
09:12:17 <Solonarv> clearly this does not happen!
09:12:22 <metreo> Well the REPL is smarter than that ... ? 
09:13:49 <Solonarv> it's not just the REPL, it's the language specification
09:14:07 <Solonarv> binding an expression to a name doesn't evaluate that expression
09:14:17 <Solonarv> So sayeth the Haskell Report.
09:15:31 <Solonarv> Values only get evaluated when something else demands it.
09:17:01 <merijn> Actually, that's not what the report says at all
09:17:12 <Solonarv> No? Oh, oops.
09:17:14 <merijn> The report is (very intentionally) silent on when things get evaluated
09:17:21 <Welkin> the report talks?
09:17:23 <merijn> Solonarv: It merely demands that code "works as if"
09:17:51 <merijn> Solonarv: If you decide to do it strictly, with a timeout or some other weird ass strategy, that's perfectly fine :p
09:17:58 <Solonarv> ah, almost right.
09:18:26 <Solonarv> (this does imply that 'let xs = 1 : xs' should not hang your program, right?)
09:18:34 <merijn> Solonarv: Always strict, but backtrack and retry lazily on hitting bottom would be a perfectly valid implementation (although, how would you detect bottom?)
09:18:52 <merijn> Solonarv: It implies that any partial traversal of xs shouldn't hang, yes
09:19:08 <Solonarv> well, you can detect *some* bottoms, obviously. The GHC runtime does as much.
09:19:16 <merijn> Solonarv: If the report actually said it had to be lazy then GHC optimisations like strictness analysis would be wrong
09:19:23 <Solonarv> Yeah, makes sense.
09:20:02 <merijn> metreo: This is a rather decent guide to thinking about lazy eval: https://hackhands.com/guide-lazy-evaluation-haskell/
09:20:15 <Solonarv> % last (fix (1:)) -- hmm...
09:20:21 <yahb> Solonarv: [Timed out]
09:20:34 <merijn> > fix error -- always a classic ;)
09:20:37 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
09:20:38 <metreo> merijn: Thanks! 
09:20:44 <Solonarv> hehe
09:20:52 * hackage bencoding 0.4.5.0 - A library for encoding and decoding of BEncode data.  http://hackage.haskell.org/package/bencoding-0.4.5.0 (SergeyVinokurov)
09:21:01 <Solonarv> I was wondering if I'd get a <<loop>>
09:22:43 <Welkin> frooty loops
09:23:01 <Solonarv> I don't really understand when the runtime will interrupt infinite loops, hmm.
09:23:15 <Solonarv> I thought 'fix id :: ()' would do it, at least!
09:23:32 <Welkin> on exceptions
09:24:02 <Solonarv> I'm talking about the <<loop>> exception which the RTS will sometimes throw at infinite loops
09:24:25 <merijn> Solonarv: Basically, thunks will (sometimes) be marked as "evaluating" before entering
09:24:29 <Solonarv> (it's printed as <<loop>>, I'm not sure what it's actually called)
09:24:40 <merijn> Solonarv: If it hits the same thunk again, during evaluation it will throw <<loop>>
09:24:52 <Solonarv> aaaah, that clears it up a bit.
09:24:59 <Solonarv> Is there somewhere I can read more about this?
09:25:00 <merijn> Solonarv: But since not all thunk access method marks it that way it's not guaranteed
09:25:12 <merijn> Solonarv: The GHC wiki, RTS commentary, etc.
09:26:06 <merijn> Solonarv: The idea is that some thunks are expensive to evaluate, while others are cheap
09:27:01 <merijn> Solonarv: If you run in the threaded runtime and multiple threads simultaneously try and evaluate the same thunk, you can either block all while 1 evaluates. But if it's cheap, you may just say "eh, screw it" and have each thread evaluate it redundantly
09:28:07 <merijn> Solonarv: So you have blackholing (entering a thunk, mark it as unreadable/unenterable), greyholing (mark it as being evaluated, but others can still evaluate it to (just don't update the result), I think there was also white-holing, but I don't remember the details
09:28:45 <wroathe> merijn: Where are those states documented?
09:28:59 <merijn> Solonarv: So the idea behind <<loop>> is "if you already detect it's infinite as a result of the implementation, might as well be nice and alert you", but it's far from fool-proof or reliable for detecting infinite loops
09:29:20 <merijn> wroathe: This is all deep internals of GHC and it's compilation model, so as I mentioned the GHC wiki and various notes in the source
09:29:34 <merijn> Subject to change, yada-yada
09:29:38 <Solonarv> yeah, I knew it wasn't reliable; I just had no idea where to even start figuring out when it happens
09:30:14 <merijn> Solonarv: When you hit a thunk your actively evaluating you're 100% you can never do anything useful, so then it's safe to error out
09:36:54 <jgt> how can I check if something is wrong with Hackage?
09:36:58 <jgt> I'm stuck on "Downloading index"
09:37:11 <merijn> jgt: Which version of cabal-install?
09:37:31 <kuribas> how do you use natVal?
09:37:33 <merijn> I vaguely recall there was one specific case where it'd get stuck indefinitely
09:37:35 <kuribas> natVal (Proxy :: Proxy anat) doesn't work
09:37:41 <kuribas> Couldn't match kind * with Nat
09:37:42 <jgt> oh… it seems to be working again
09:37:49 <jgt> it just took a *really* long time — no idea why!
09:37:56 <jgt> (much longer than usual)
09:38:12 <jgt> (how did it know to magically start working again right after I asked people on IRC?)
09:38:18 <jgt> merijn: thanks anyway!
09:38:23 <merijn> jgt: Magic!
09:38:40 <kuribas> jgt: that's how irc works :)
09:39:21 <merijn> kuribas: WHich GHC?
09:39:35 <kuribas> merijn: nevermind, I just needed ScopedTypeVariables :)
09:39:50 <merijn> kuribas: hah :)
09:39:51 <metreo> This https://wiki.haskell.org/Cookbook/Lists_and_strings points to this https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base/Prelude.html#v:head which obviously isn't there anymore, I can't seem to find the base docs in the index. Everything is fine up to here: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/
09:40:32 <cocreature> metreo: https://hackage.haskell.org/package/base
09:40:40 <metreo> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.12.0.0/Prelude.html#v:head
09:41:00 <metreo> So base => base-4.12.0.0 for those links
09:41:04 <Solonarv> kuribas: if you turn on TypeApplications you can write 'natVal (Proxy @anat)' instead ;)
09:41:28 <metreo> cocreature: Thanks!
09:41:29 <merijn> Solonarv: He'd still need SCTV to have anat in scope
09:41:33 <kuribas> Solonarv: ah right!  I even have it already enabled.
09:41:39 <Solonarv> yes, of course :>
09:42:01 <merijn> kuribas: Don't you have a value you can use directly?
09:42:16 <kuribas> merijn: what do you mean?
09:42:17 <merijn> kuribas: natVal doesn't require Proxy on purpose...
09:42:31 <merijn> kuribas: Note that the first argument to natVal has lowercase proxy :p
09:42:32 <kuribas> merijn: I just have a Nat 
09:42:56 <Solonarv> if you use natVal a lot, you can even enable AllowAmbiguousTypes and write: natVal_ :: forall n. KnownNat n => Integer; natVal_ = natVal (Proxy @n)
09:43:00 <merijn> kuribas: Where did it come from?
09:43:09 <Solonarv> so then the use site is just 'natVal_ @anat'
09:43:14 <kuribas> merijn: it's in a newtype
09:43:22 <kuribas> merijn: BoundedInt from to
09:43:43 <merijn> kuribas: For the 'to' case you can just pass the newtype directly to natVal
09:43:52 <kuribas> merijn: so I can do newtype Second = Second (BoundedInt 0 59)
09:43:54 <merijn> 'from' obviously needs a type variable still
09:44:17 <kuribas> maybe I need Proxy# instead
09:44:23 <merijn> kuribas: My point was that "natVal (foo :: BoundedInt 0 59)" == "natVal (Proxy :: Proxy 59)"
09:44:42 <kuribas> merijn: I have no foo in minBound though
09:44:54 <merijn> kuribas: Ah, right
09:45:10 <Solonarv> kuribas: Proxy# is the least runtime overhead, certainly.
09:45:46 <Solonarv> I can never remember where to import proxy# from, though.
09:46:42 <kuribas> Do I need an extension for the hash?
09:47:00 <Solonarv> yes, MagicHash
09:48:20 <merijn> -XMagicHash for when you feel like writing C :p
09:49:02 <kuribas> hmm DataConstructor not in scope
09:49:04 <Solonarv> I mean, I say use of proxy# is very C-like :P
09:49:14 <Solonarv> kuribas: there is no data constructor for Proxy#
09:49:37 <Solonarv> there is a value 'proxy# :: Proxy# a' defined somewhere which you're supposed to use
09:49:47 <Solonarv> but I don't remember where you're supposed to import it from
09:50:01 <kuribas> why isn't it just natVal @nat ?
09:50:36 <Solonarv> because TypeLits predates TypeApplications, I think.
09:51:01 <merijn> Solonarv: It does
09:51:07 <kuribas> heh I can do natVal @nat undefined
09:51:23 * Solonarv wags finger
09:51:25 <kuribas> > natVal @1 undefined
09:51:27 <lambdabot>  error:
09:51:27 <lambdabot>      Pattern syntax in expression context: natVal@1
09:51:27 <lambdabot>      Did you mean to enable TypeApplications?
09:51:29 <merijn> kuribas: Now you're back to pre-Proxy dark ages
09:51:41 <Solonarv> % natVal @1 undefined
09:51:42 <kuribas> it still cannot find proxy@
09:51:42 <yahb> Solonarv: ; <interactive>:1:1: error: Variable not in scope: natVal; <interactive>:1:1: error:; * Cannot apply expression of type `t1'; to a visible type argument `1'; * In the expression: natVal @1 undefined; In an equation for `it': it = natVal @1 undefined
09:51:45 <kuribas> proxy#
09:51:48 <merijn> The whole reason Proxy was introduced was to avoid passing undefined everywhere >.>
09:51:54 <Solonarv> kuribas: I think it might be in GHC.Exts
09:51:58 <Solonarv> % import GHC.Exts
09:51:59 <yahb> Solonarv: 
09:52:07 <Solonarv> % :set -XMagicHash
09:52:07 <yahb> Solonarv: 
09:52:11 <Solonarv> % :i proxy#
09:52:12 <yahb> Solonarv: proxy# :: forall k0 (a :: k0). Proxy# a -- Defined in `GHC.Prim'
09:53:06 <dminuoso> kuribas: You could use AmbiguousTypes though with TypeApplications.
09:53:38 <Solonarv> % import GHC.TypeLits
09:53:38 <yahb> Solonarv: 
09:53:47 <Solonarv> % natVal' @1 proxy#
09:53:47 <yahb> Solonarv: 1
09:53:52 <Solonarv> kuribas: ^
09:54:26 <Solonarv> you can write an ambiguously-typed wrapper around this to save you from having to type proxy# all the time
09:55:56 <dminuoso> What does `forall k0 (a :: k0).` mean?
09:56:13 <merijn> dminuoso: That type a has kind k0
09:56:25 <kuribas> ok it works finally
09:56:41 <kuribas> apparently natVal' (proxy# @from) doesn't work...
09:56:42 <dminuoso> merijn: but.. oh. Weirdly I keep getting confused when seeing kind variables and type variables in the same forall clause.
09:56:55 <merijn> dminuoso: I find TypeInType a super-confusing mess
09:57:05 <Solonarv> kuribas: yeah, but natVal' @from proxy# works
09:57:08 <dminuoso> merijn: Some people would disagree with that! :D
09:57:26 <dminuoso> I've talked with several people who claim that the type system can be quite confusing without the extension.
09:57:55 <dminuoso> merijn: Does that quantification require TypeInType?
09:58:00 <int-e> polymorphic kinds are already confusing. even quantifying over constraints is confusing.
09:58:09 <kuribas> It would be nice if DependendTypes could clean up the mess of type level programming.
09:58:37 <merijn> kuribas: Probably not happening
09:58:41 <geekosaur> ...dependent types are not known for cleaning up messy programming. rather the opposite
09:58:54 <merijn> dminuoso: Why would it be more confusing without TypeInType?
09:59:21 <merijn> geekosaur: I mean, stratified universes are fairly clean
09:59:33 <merijn> geekosaur: It's mostly retrofitting Dependent Types that's a mess
09:59:42 <merijn> Extended Calculus of Construction is pretty clean
09:59:42 <geekosaur> but everything has to carry around proof of its validity
09:59:43 <kuribas> geekosaur: it cannot be harder that the hurldles you have to go over to do simple things at type level in haskell.
10:00:04 <merijn> geekosaur: Oh, you mean actually using all that stuff. Sure.
10:01:15 <dminuoso> merijn: At any rate, `forall k0 (a :: k0). Proxy# a` is valid without TypeInType, although very much looking like TypeInType.
10:01:32 <merijn> dminuoso: The classical type theory solution to more complex kinds, etc. is to have an infinite hierarchy of "types"
10:01:52 * hackage intero 0.1.37 - Complete interactive development program for Haskell  http://hackage.haskell.org/package/intero-0.1.37 (ChrisDone)
10:02:06 <merijn> dminuoso: Where values have Type_0, Type_0 has Type_1, Type_1 has Type_2, ad infinitum
10:02:07 <dminuoso> merijn: Well in GHC you have that totally bogus `TYPE` construct that.. makes no sense unless you consider TypeInType.
10:02:28 <merijn> dminuoso: Where classically "Type_0 = type", "Type_1 = kind", and "Type_2 = sort"
10:02:48 <dminuoso> merijn: Yeah just like we have values, types, kinds, sorts.. (and no more)
10:02:58 <dminuoso> Right.
10:03:12 <merijn> Which is nicely consistent and simple
10:03:14 <Solonarv> the arbitrary stopping point seems weird, tbh
10:03:19 <merijn> Solonarv: Not really
10:03:27 <geekosaur> where's tim sheard when you need him >.>
10:03:30 <merijn> Solonarv: All kinds possible in GHC have a single sort
10:03:34 <dminuoso> Solonarv: You could imagine every level above to be just a singleton.
10:03:37 <Solonarv> shush! you offend my sense of symmetry! :p
10:03:51 <merijn> Solonarv: (Specifically, the sort "BOX", which you can find in GHC's code)
10:03:54 <infinisil> Is this simmilar to how we use +, * and ^ in mathematics?
10:03:58 <dminuoso> merijn: Can you tap into sorts at all in Haskell (without TypeInType)?
10:04:06 <merijn> dminuoso: No
10:04:13 <dminuoso> Well. By Haskell I mean GHC of course.
10:04:15 <dminuoso> ;)
10:04:16 <merijn> dminuoso: Not even in GHC -XKitchenSink Haskell
10:04:42 <Solonarv> I was under the impression BOX was more or less gone now?
10:04:42 <dminuoso> infinisil: No.
10:04:43 <monochrom> I prefer -XPresidentSuide
10:04:47 <geekosaur> standard haskell doesn't even give you kinds, except by inference from typeclasses
10:04:52 <monochrom> err, -XPresidentSuite!
10:04:53 <merijn> Solonarv: I suppose TypeInType eliminates it
10:05:30 <Solonarv> % :set -XNoTypeInType
10:05:30 <yahb> Solonarv: 
10:05:33 <merijn> Anyway, the problem with TypeInType is that it collapses this entire hierarchy into one level and no I'm constantly confused at what "level" things are
10:05:35 <Solonarv> % :k Type
10:05:35 <yahb> Solonarv: Type :: *
10:05:47 <Solonarv> % :set -XTypeInType
10:05:47 <yahb> Solonarv: 
10:05:49 <geekosaur> I thoughtt TypeInType was always on now
10:05:57 <dminuoso> That.. would be confusing.
10:06:01 <merijn> geekosaur: Eh, no?
10:06:02 <geekosaur> you can toggle it but it's a no-op
10:06:12 <merijn> geekosaur: I mean, the internals are always used, yes
10:06:15 <monochrom> No, two levels. The value level is still distinct from the type-kind-above level.
10:06:29 <Solonarv> well yes, internally it is. The extension just controls whether you're allowed to use it directly.
10:06:31 <merijn> geekosaur: But you can't mix up levels without TypeInType enabled
10:09:22 <nshepperd> eh. cabal new-exec fails with an incomprehensible error if new-build or new-repl hasn't been run first
10:09:35 <nshepperd> in a project
10:14:18 <geekosaur> not surprised from earlier description
10:16:04 <merijn> new-exec is by far one of the newest/least tested new-X additions :p
10:16:59 <nshepperd> ah, and it won't build dependencies either. well, fine
10:17:12 <merijn> nshepperd: Which cabal-install version?
10:17:17 <nshepperd> 2.4.1.0
10:17:21 <merijn> hmmm
10:32:30 <nshepperd> ...it also ignores --cabal-file
10:32:33 <nshepperd> good gried
10:46:33 <WWMD> Hello! Can I ask a quick question?
10:46:53 <__monty__> WWMD: Nope, we only do lazy questions here.
10:47:29 <WWMD> Haha fair enough :)
10:48:01 <__monty__> Do go ahead with the question though.
10:48:12 <WWMD> Will do, just a sec
10:48:12 <__monty__> Never ask to ask.
10:48:18 <WWMD> Noted.
10:49:03 <WWMD> I read in the haskell wiki-book that do-notation can process pattern match failures
10:49:28 <WWMD> is it good practice to say something like "True <- return $ inSector point"
10:49:35 <WWMD> as opposed to "guard inSector point"
10:49:42 <Welkin> no
10:49:44 <Solonarv> definitely not
10:49:47 <Welkin> that is a partial pattern match
10:50:02 <Welkin> partial functions/expressions are dangerous
10:50:11 <WWMD> Either way, the underlying monad will have its "fail" value called
10:50:24 <cocreature> not necessarily, e.g in Maybe they are totally fine and can be quite handy
10:50:30 <Solonarv> Indeed, but some monads can't usefully define "fail"
10:50:37 <cocreature> but if "guard" suffices use that
10:50:52 <Solonarv> I'd prefer guard because that one is explicit about needing the underlying monad to support failure
10:51:02 <cocreature> fail is too these days :)
10:51:14 <WWMD> That makes sense. I appreciate your help!
10:51:27 <Solonarv> fail is, partial pattern matches aren't.
10:51:52 <Solonarv> % :t do True <- pure False; pure ()
10:51:53 <yahb> Solonarv: Monad m => m ()
10:52:40 <Solonarv> see? no MonadFail constraint.
10:53:00 <WWMD> Would an incomplete pattern match be appropriate if I added a MonadFail constraint to my type signature?
10:53:12 <WWMD>     (x:_) <- return $ filter (flip inSectorMap point) ms -- Check that at least 1 sub-sector contains the point
10:53:29 <WWMD> That ^ is what I want to implement, and it seems like that's the simplest way
10:53:48 <cocreature> Solonarv: in 8.6 you get a MonadFail constraint
10:54:05 <Solonarv> cocreature: yahb is 8.6, so clearly not always
10:54:35 <Welkin> WWMD: the simplest way would be an explicit pattern match
10:54:36 <cocreature> Solonarv: you sure about that? if I type the exact same example in my local ghci instance, I do get the constraint
10:54:38 <Solonarv> WWMD: this too can be replaced with a guard
10:54:42 <Welkin> simple does not always mean less characters
10:54:45 <Solonarv> cocreature: perhaps there's a flag of some sort
10:54:52 <Welkin> explicit case expression*
10:55:02 <cocreature> % :showi language
10:55:03 <yahb> cocreature: base language is: Haskell2010; with the following modifiers:; -XBangPatterns; -XConstrainedClassMethods; -XConstraintKinds; -XDataKinds; -XNoDatatypeContexts; -XDeriveDataTypeable; -XDeriveFoldable; -XDeriveFunctor; -XDeriveTraversable; -XDisambiguateRecordFields; -XEmptyCase; -XExistentialQuantification; -XExplicitForAll; -XExplicitNamespaces; -XExtendedDefaultRules; -XFlexibleCont
10:55:08 <WWMD> I understand that I can replace it with a guard bet it seems to make the code a lot more complex/hard to read
10:55:13 <Welkin> it *should* mean easiest to understand and least prone to unknown behavior
10:55:22 <cocreature> :show language
10:55:29 <cocreature> % :show language
10:55:29 <yahb> cocreature: base language is: Haskell2010; with the following modifiers:; -XBangPatterns; -XConstrainedClassMethods; -XConstraintKinds; -XDataKinds; -XNoDatatypeContexts; -XDeriveDataTypeable; -XDeriveFoldable; -XDeriveFunctor; -XDeriveTraversable; -XDisambiguateRecordFields; -XEmptyCase; -XExistentialQuantification; -XExplicitForAll; -XExplicitNamespaces; -XFlexibleContexts; -XFlexibleInstance
10:55:45 <Solonarv> %% :show language
10:55:46 <yahb> Solonarv: http://qp.mniip.com/y/50
10:55:56 <Solonarv> cocreature: %% for longer outputs
10:55:59 <WWMD> the alternative is "let xs = filter ... ; guard . not . null $ xs ; return $ head x"
10:56:22 * hackage bencoding 0.4.5.1 - A library for encoding and decoding of BEncode data.  http://hackage.haskell.org/package/bencoding-0.4.5.1 (SergeyVinokurov)
10:56:26 <Solonarv> I'd just use a case expression there.
10:56:27 <WWMD> In that case I think I have to generate the entire list, while the incomplete pattern match only binds on the head
10:56:40 <cocreature> hm, I don’t see anything special here
10:56:51 <Welkin> WWMD: that's not a case expression
10:56:51 <cocreature> % :set -XQuantifiedConstraints
10:56:52 <yahb> cocreature: 
10:56:56 <cocreature> % :set -XQuantifiedConstraintsfoobar
10:56:57 <yahb> cocreature: Some flags have not been recognized: -XQuantifiedConstraintsfoobar
10:57:05 <cocreature> hm so it definitely is 8.6, weird
10:57:22 <Solonarv> WWMD: no, you don't have to generate the entire list
10:57:47 <WWMD> But binding on the entire list seems sort of clunky
10:58:10 <WWMD> But binding on only the first element requires an incomplete pattern match
10:58:10 <Welkin> mX <- case filter (flip inSectorMap point) ms of a:_ -> Just a; _ -> Nothing
10:58:40 <WWMD> Isn't that what the "<-" in do-notation desugars into?
10:58:43 <Solonarv> case filter blah blah of (x:_) -> pure x; _ -> mzero
10:58:44 <Welkin> no
10:59:13 <Welkin> `a <- ma` is operating in a monad and is really `ma >>= \a -> ...`
10:59:47 <WWMD> But it does a case split on an incomplete pattern match
11:00:12 <Solonarv> Oh. Yes, indeed.
11:00:39 <Solonarv> (all pattern matching turns into case expressions, so that's not saying much)
11:01:13 <cocreature> :set -XMonadFailDesugaring
11:01:15 <cocreature> % :set -XMonadFailDesugaring
11:01:15 <WWMD> My point is that incomplete pattern matching turns into a complete case expression when inside of a do-block, with the help of "fail"
11:01:15 <yahb> cocreature: 
11:01:41 <cocreature> % :t do True <- pure False; pure ()
11:01:41 <yahb> cocreature: Control.Monad.Fail.MonadFail m => m ()
11:01:44 <cocreature> ah there we go
11:01:51 <Solonarv> 'do Just a <- foo; bar' turns into: foo >>= \a_1234 -> case a_1234 of Just a -> bar; _ -> fail "pattern match fail"
11:01:52 <cocreature> dunno what evil person disabled that in yahb :)
11:02:14 <WWMD> Anyway, it sounds like what I'm looking for can better be expressed by a guard expression, even if that's a little longer.
11:02:37 <Welkin> what you want is expressed exactly and completely using a simple cas expression
11:02:46 <Welkin> why would you want to rely on possibly unknown behavior?
11:02:49 <Welkin> that is stupid
11:03:15 <WWMD> Because I know that the do-block is running in a monad that is an instance of MonadFail
11:03:22 <WWMD> I can make that a constraint
11:03:31 <Solonarv> in what world is the desugaring of 'do Just a <- blah' unknown behavior?
11:05:10 <stryder> Hello everyone
11:05:24 <Solonarv> hello!
11:06:06 <stryder> Trying to use Megaparsec with ByteStrings and going no where, any suggestions or blog posts describing this in general?
11:06:12 <Welkin> Solonarv: the fail implementation
11:07:04 <Solonarv> well, no matter what you do you need to handle failure *somehow*. Do you trust the MonadFail instance less than the Alternative instance (the latter is what is used by guard)?
11:07:09 <stryder> I found this https://stackoverflow.com/questions/15455084/matching-bytestrings-in-parsec but I am sure there is a better way 
11:07:15 <cocreature> how is the fail implementation more or less unknown that the implementation of "empty" that you’re relying on when you use "guard"?
11:07:48 <Solonarv> (note that I'm assuming you turn on -XMonadFailDesugaring)
11:08:04 <cocreature> which is the default in 8.6
11:10:09 <WilliamHamilton[> hi, question: say I want a map from `(Int, TypeRep a)` to `Foo a`, but where the a is allowed to change inside the map. For example (1, TyInt) -> (_ :: Foo Int) and (2, TyChar) -> (_ :: Foo Char)
11:10:40 <WilliamHamilton[> what's the right infrastructure for this? Do I have to wrap the result type in a Dynamic?
11:10:45 <glguy> WilliamHamilton[: You can use this package for that: http://hackage.haskell.org/package/dependent-map-0.2.4.0/docs/Data-Dependent-Map.html
11:10:59 <geekosaur> yes. or use an existing one, I think there's some already
11:11:26 <geekosaur> http://hackage.haskell.org/package/dependent-map
11:14:20 <WilliamHamilton[> glguy: geekosaur thanks! Is my understanding correct in that that library implements maps from `TypeRep a` to `Foo a`, and if I want something from `(Int, TypeRep a)` I have to partially modify it (or used nested maps)?
11:15:05 <dminuoso> stryder: A `string` primitive would have to assume some underlying encoding.
11:15:13 <Solonarv> nested maps are probably a good approach, WilliamHamilton[
11:15:27 <dminuoso> Although..
11:15:30 <dminuoso> stryder: string :: MonadParsec e s m => Tokens s -> m (Tokens s)
11:16:23 <WilliamHamilton[> Solonarv: I was (irrationally?) concerned that nested maps could be bad for performance. Is this concern unfounded?
11:16:36 <Solonarv> Probably.
11:17:10 <WilliamHamilton[> Solonarv: thanks!
11:17:28 <stryder> dminuoso: you mean something like this? string s    = liftM Char8.pack (tokens show updatePosString s)
11:17:47 <Solonarv> You can always reach for a more efficient data structure when you actually tun into performance issues.
11:18:12 <dminuoso> stryder: The ByteString is just ASCII encoded?
11:18:17 <Solonarv> WilliamHamilton[: for a map with Int keys, IntMap is probably your best bet
11:18:22 <stryder> dminuoso: yes
11:20:24 <koz_> I think someone even wrote a library which extends that to anything Enum instance.
11:20:54 <Solonarv> I dimly recall seeing that too
11:22:32 <koz_> http://hackage.haskell.org/package/EnumMap
11:35:31 <merijn> @hoogle [a -> m [b]] -> a -> m [b]
11:35:32 <lambdabot> Harp.Match foldComp :: [[a] -> [a]] -> ([a] -> [a])
11:35:32 <lambdabot> Test.LeanCheck.Tiers distinctPairsWith :: (a -> a -> b) -> [[a]] -> [[b]]
11:35:32 <lambdabot> Test.LeanCheck.Tiers unorderedPairsWith :: (a -> a -> b) -> [[a]] -> [[b]]
11:35:54 <merijn> bleh, that's not quite sequence :\
11:39:05 <suzu> @hoogle [a -> m [b]] -> a -> m [[b]]
11:39:06 <lambdabot> Test.LeanCheck concatMapT :: (a -> [[b]]) -> [[a]] -> [[b]]
11:39:06 <lambdabot> Test.LeanCheck.Core concatMapT :: (a -> [[b]]) -> [[a]] -> [[b]]
11:39:06 <lambdabot> Data.List.HT outerProduct :: (a -> b -> c) -> [a] -> [b] -> [[c]]
11:39:15 <suzu> this would be sequence
11:39:27 <suzu> @hoogle [a -> m b] -> a -> m [b]
11:39:28 <lambdabot> Test.QuickCheck shrinkList :: (a -> [a]) -> [a] -> [[a]]
11:39:28 <lambdabot> Test.QuickCheck.Arbitrary shrinkList :: (a -> [a]) -> [a] -> [[a]]
11:39:28 <lambdabot> Test.LeanCheck mapT :: (a -> b) -> [[a]] -> [[b]]
11:41:38 <Solonarv> :t (fmap mconcat . ) . sequenceA
11:41:39 <lambdabot> (Traversable f, Monoid b) => f (a -> [b]) -> a -> f b
11:42:13 <Solonarv> % :t (fmap mconcat . ) . (sequenceA @[])
11:42:13 <yahb> Solonarv: Monoid b => [a -> [b]] -> a -> [b]
11:42:25 <Solonarv> uhh, that's not quite right
11:44:46 <merijn> Solonarv: Sadly my monad isn't a monoid instance and wrapping it, etc. doesn't make a lot of sense for the limited use
11:45:36 <Solonarv> % :t sequenceA @[] @_ @[_]
11:45:37 <yahb> Solonarv: Applicative w1 => [w1 [w2]] -> w1 [[w2]]
11:45:57 <Solonarv> % :t sequenceA @[] @((->) _) @[_]
11:45:58 <yahb> Solonarv: [w1 -> [w2]] -> w1 -> [[w2]]
11:46:25 <Solonarv> er, let me move this to PMs
11:50:30 <Solonarv> % :t (fmap (concat @[]) .) . flip (fmap . flip ($)) -- is this right?
11:50:31 <yahb> Solonarv: forall {f :: Type -> Type} {a1} {a2}. Functor f => f (a1 -> [[a2]]) -> a1 -> f [a2]
11:51:42 <Solonarv> Hm, still not quite right.
11:59:12 <ddellacosta> so I'm trying to write a very basic eval for simple addition and multiplication with coefficient terms, and what I've ended up with is incredibly verbose and redundant it seems to me, but I'm having trouble figuring out how to reduce this down at all. Can anyone suggest any obvious refactoring approaches to take? FWIW I'd rather have suggestions like "look at GADTs" or etc. vs. someone re-writing this entirely for me: https://gist.gi
11:59:12 <ddellacosta> thub.com/ddellacosta/8a030ded5476252f086f9bba0452dac6
11:59:21 <ddellacosta> ugh sorry about the split: https://gist.github.com/ddellacosta/8a030ded5476252f086f9bba0452dac6
12:00:16 <ddellacosta> the basic problem is that I have to check both whether the coefficients match and if I've reduced the terms fully in a number of cases, and doing some and handling all the conditions means a lot of repetitive code
12:01:30 <Solonarv> ddellacosta: your expression type looks a bit confused to me, what is the 'Value' constructor supposed to represent?
12:01:51 <benzrf> ddellacosta: your mult looks wrong to me
12:01:58 <benzrf> you'd have c^2, not c
12:02:01 <ddellacosta> Solonarv: that is simply a number with a coefficient
12:02:24 <ddellacosta> benzrf: oh I'll have to review that, I copy and pasted the `Add` stuff without trying it yet, since I already knew I didn't like it :-p
12:03:26 <benzrf> i think it would be a good idea to start out with a clear notion of what a canonical form looks like for one of these expressions
12:03:27 <ddellacosta> benzrf: actually upon review I'm not sure I follow
12:03:39 <ddellacosta> benzrf: what do you mean?
12:03:50 <benzrf> cn * cm = c^2nm, not cnm
12:04:30 <benzrf> also it seems strange that your coefficients are symbols rather than the "values"
12:04:38 <ddellacosta> yeah this seems to be working fine actually, it's just verbose
12:04:43 <Solonarv> yeah, that's confusing me too benzrf
12:05:05 <benzrf> typically "coefficients" are actual numbers
12:05:11 <benzrf> eg the coefficients of a polynomial
12:05:12 <ddellacosta> oh yeah okay so ignore the Mult bit for now--pretend it's just Addition
12:05:24 <ddellacosta> let me re-write it to simplify for illustrative purposes, because this is beside the point
12:05:27 <benzrf> well, my advice is 15:03 <benzrf> i think it would be a good idea to start out with a clear notion of what a canonical form looks like for one of these expressions
12:06:19 <tombusby> hey all, I have a quick q: what's the best way to install a specific haskell version? I'm using arch and the version I need (8.4.4, though and 8.4 would be fine) isn't in AUR
12:06:30 <tombusby> s/haskell/ghc
12:06:47 <Solonarv> tombusby: ghcup is the usual recommendation, I think
12:06:48 <tombusby> s/and/any
12:06:58 <tombusby> thanks, I'll look into it
12:07:03 <__monty__> Or the haskell platform.
12:07:06 <__monty__> Or nix : )
12:07:12 <Solonarv> arch's Haskell packages are a bit broken because they insist on dynamic linking
12:07:16 <ddellacosta> benzrf, Solonarv so how about now: https://gist.github.com/ddellacosta/8a030ded5476252f086f9bba0452dac6
12:08:34 <benzrf> why not evaluate the arguments first and THEN match on them
12:08:48 <ddellacosta> and yeah, I'm probably using "coefficient" backwards here, sorry for butchering the language--it may make more sense to think of the numeric values as the coefficients and the characters as variables
12:09:08 <ddellacosta> benzrf: sorry, again I don't follow
12:09:40 <Anyno> hello
12:10:26 <__monty__> Hi there, Anyno.
12:10:47 <Anyno> boring
12:10:58 <Anyno> udpflood 5.83.161.139 9987 120 1
12:11:07 <Anyno> xD
12:11:11 <Anyno> prank
12:11:15 <Anyno> ahha
12:11:19 <Anyno> :c
12:11:41 <benzrf> ddellacosta: presumably the point of this function is to reduce expressions into some kind of canonical form
12:11:48 <Anyno> I will a botnet
12:11:55 <Anyno> :D
12:12:05 <benzrf> it's easier to figure out whether your function is doing the right thing, and how to do it, if you know precisely what your goal is
12:12:08 <ddellacosta> benzrf: ah, okay now I see what you mean. Yes I did start there, so I'm not sure that'll help here
12:12:40 <benzrf> for example, maybe your goal is to put them in standard polynomial form
12:13:32 <ddellacosta> benzrf: that's exactly why I've arrived at this in fact. if I have (Add (Value 1 'c') (Value 2 'c')) then I can get (Value 3 'c'), whereas when I have (Add (Value 1 'd') (Value 1 'c')) I cannot reduce further. That in turn engenders redundancy in how I'm writing the functions to evaluate, so what I'm asking about is if there is a way to simplify the pretty repetitive Add cases so I don't have all that code
12:13:34 <Anyno> hmmmmmmmm
12:13:54 <ddellacosta> benzrf: is that more clear in terms of what I'm asking help with?
12:14:01 <benzrf> ummmm, maybe
12:14:09 <benzrf> is there something you're using this for?
12:14:11 <Solonarv> ddellacosta: if those are supposed to be polynomials, perhaps that isn't the best representation?
12:14:28 <ddellacosta> this is part of a codewars problem, fwiw
12:14:40 <Solonarv> ddellacosta: could you link the problem?
12:14:58 <Anyno> ok?
12:15:00 <iqubic> rewrite rules are always a pain.
12:15:27 <iqubic> Also, modifying an AST is a pain.
12:15:49 <ddellacosta> I'm really just looking for help with how to simplify this bit of code. I'm not interested in interrogating my attempted solution further. If neither of you think this can be refactored or simplified that's fine though
12:16:02 <Anyno> guys
12:16:05 <Anyno> sorry
12:16:13 <Anyno> i must go
12:16:15 <Anyno> sorry
12:16:34 <__monty__> Anyno: Sorry we couldn't help you learn about haskell.
12:16:46 <Anyno> even though
12:17:00 <Solonarv> ddellacosta: I can't think of anything that isn't an entirely different approach, and it's hard to figure out what that approach should be if I don't know the problem better.
12:17:12 <Anyno> Guys
12:17:18 <Anyno> hi
12:17:27 --- mode: ChanServ set +q *!*@gateway/web/cgi-irc/kiwiirc.com/ip.46.92.185.101
12:17:29 <ddellacosta> Solonarv: okay, thanks for trying, I appreciate it
12:26:26 <libertyprime> hey guys. I noticided I am at the conclusion that ghc-mod works only for ghc up to 8.0. Should I downgrade my default ghc from 8.4.4? Or is it best to ignore ghc-mod
12:26:39 <tombusby> Solonarv: ghcup is perfect for my needs, thanks for telling me about it :D
12:27:03 <merijn> libertyprime: Are you using stack or cabal-install?
12:27:20 <libertyprime> stack
12:27:33 <Solonarv> libertyprime: are you sure you're using the latest version of ghc-mod?
12:27:34 <merijn> In that case, I don't know :)
12:28:04 <libertyprime> That's ok. I have cabal installed too. I'm open to using both side-by-side i guess..
12:28:26 <libertyprime> I just want my nice emacs tools to work
12:28:33 <merijn> libertyprime: With cabal-install you should be using new-build anyway and (tragically!) ghc-mod doesn't support new-build, so that makes the point moot ;)
12:28:55 <Solonarv> libertyprime: I've heard dante being recommended, it's emacs-specific
12:30:15 <libertyprime> that's good advice. thanks!
12:31:19 <Solonarv> There's also intero (stack-specific), haskell-ide-engine, and ghcid (low-feature, but works with all ghc versions and all build systems)
12:53:30 <libertyprime> Is cabal better than stack?
12:53:44 <libertyprime> Is this going to start a flame war?
12:53:50 <AfC> Yes
12:54:45 <Solonarv> Define "better".
12:54:54 <Welkin> stack uses cabal
12:55:00 <Welkin> cabal is a build tool, stack is a wrapper
12:55:01 <merijn> stack uses Cabal
12:55:05 <__monty__> The #haskell populace has mostly moved past the stack v. cabal thing ime.
12:55:11 <merijn> cabal-install *also* uses Cabal
12:55:18 <Welkin> I've moved on to cabal new-*
12:55:22 <merijn> cabal (the executable) is cabal-install
12:55:24 <AfC> stack uses *Cabal*. cabal uses *Cabal*.
12:55:46 <aplainzetakind> Does stack provide any functionality that cabal new-* (with ghcup) does not?
12:56:00 <merijn> Anyway, yesterday (I think?) I gave an longwinded answer to "what's the difference?", so if someone who is not lazy can look that up in the logs and link it ;)
12:56:30 <merijn> aplainzetakind: Think of stack as "new-*, except you use a freeze file that's shared by everyone else using stack"
12:57:03 <Solonarv> aplainzetakind: cabal new-*/ghcup is still a bit lacking on windows
12:57:48 <aplainzetakind> does cygwin help?
12:57:50 <Solonarv> notably: ghcup doesn't work at all on windows, and neither does cabal new-install
12:57:54 <merijn> libertyprime: I'm lazy, if you search http://tunes.org/~nef/logs/haskell/19.01.04 for cabal-install, you'll find my explanation
12:58:19 <merijn> I like to think it was fairly impartial
12:59:17 <geekosaur> "impartial" is not permissible in a world that has haskell.org vs. haskell-lang.org
12:59:23 <Solonarv> I don't think would help, I don't want my haskell stuff to live in a sandbox 
12:59:58 <Solonarv> I admit I haven't tried it, but I don't see how cygwin is *less* hassle than just using stack for the handful of things cabal doesn't handle yet
13:00:01 <merijn> geekosaur: Well, too bad! :p
13:00:12 <__monty__> Maybe I was wrong...
13:00:52 <Solonarv> I don't know, this doesn't seem very flamey to me.
13:01:41 <merijn> geekosaur: To be fair, *I* am not impartial, but my explanation tried to be :p
13:01:52 <aplainzetakind> Does anybody use ghc-mod in cabal new-* projects without issues?
13:02:02 <merijn> aplainzetakind: No, sadly
13:02:26 <merijn> aplainzetakind: ghc-mod doesn't support new-build and while DanielG said he started working on it recently, I wouldn't hold your breath
13:02:57 <aplainzetakind> Is there a good alternative for vim?
13:03:07 <merijn> aplainzetakind: No, also sadly
13:03:26 <merijn> aplainzetakind: I've resorted to a mix of ghcid and "just running 'cabal new-build'"
13:04:02 <merijn> aplainzetakind: I started working on one, but it's only like 1/3rd done, so don't hold your breath for that one either :p
13:04:51 <Solonarv> perhaps haskell-ide-engine? I don't use vim, so idunno
13:06:15 <aplainzetakind> Solonarv: it says it supports vim.
13:06:43 <merijn> Right, I need another git masterclass to help deal with the fact that people rudely use submodules so I can't use hg >.> If I have a git checkout with changes, how do I commit those to a new branch?
13:07:11 <hpc> git checkout -b new-branch-name
13:07:24 <hpc> git commit -m 'whatever'
13:07:27 <hpc> git push -u origin
13:07:39 <hpc> that'll create a new upstream branch named new-branch-name and link your local branch to it
13:07:46 <__monty__> Don't you get the "there's changes that would be lost." warning that way?
13:08:22 <hpc> oh, if you already have changes... ugh
13:08:45 <__monty__> Is it just stash, branch, pop, commit?
13:08:53 <merijn> Nope, this seems to work
13:08:54 <hpc> yeah, something like that
13:09:01 <merijn> Although he forgot "git add" :p
13:09:07 <hpc> heh
13:09:23 <hpc> i guess it's fine as long as you didn't commit anything to the old branch
13:10:07 <hpc> and if you're looking for what those -b/-u options mean...
13:10:11 <hpc> too damn bad, i don't know either
13:10:33 <__monty__> -b creates a branch while checking it out.
13:10:41 <__monty__> -u is short for --set-upstream.
13:11:01 <merijn> although it didn't push the new branch :\
13:11:16 <__monty__> Do you have a remote named origin?
13:11:17 <hpc> oh, maybe it was git push -u origin new-branch-name
13:11:32 <merijn> Ah, yes
13:12:00 <merijn> Right...this shit's pushed, I can go back to ignoring git exists :p
13:12:36 <Welkin> I didn't know about .gitattributes
13:12:46 <Welkin> I learned about it from an erlang project
13:12:51 <__monty__> You like hg that much more?
13:14:09 <merijn> __monty__: Much more than git, yes. I never have to wonder "wtf did -b with this command and why is it different from -b for that other command?!". Also, since my 1st week of using it I've never had to google "what was the way to do X?" because the commandline help has always answered that within like 2 minutes
13:15:27 <Welkin> I always need to look up how to do things in emacs because I always forget the key combinations or the command
13:15:58 <merijn> I'm sure that *after* you've sunk in 2 months of your life to memorise all the peculiarities git is just as good, but I can't be arsed if I have a perfectly functioning tool that will trivially let me interact with other people's git insanity
13:16:02 <xenon-> do x <- a; y <- b; z <- c; f x (g y z)   <- is there a nice way to shorten this?
13:16:10 <xenon-> @undo do x <- a; y <- b; z <- c; f x (g y z)
13:16:10 <lambdabot> a >>= \ x -> b >>= \ y -> c >>= \ z -> f x (g y z)
13:16:21 <xenon-> ^^ not that :P
13:17:09 <Solonarv> f <$> a <*> (g <$> b <*> c)
13:17:23 <Solonarv> xenon-: ^
13:19:13 <xenon-> moment, let me translate that to my actual code
13:19:52 <Solonarv> or: liftA2 f a (liftA2 g b c)
13:20:38 <xenon-> f takes two arguments and returns IO, so I don't think that is going to work?
13:21:38 <merijn> xenon-: Put "join $" in front? :p
13:21:56 <xenon-> or use =<<?
13:22:02 <xenon-> instead of join <$>
13:22:35 <tito_04> join $, not join <$>
13:22:47 <Solonarv> oh duh, I misread your initial example
13:22:48 <xenon-> join $ worked
13:23:03 <xenon-> join $ f <$> a <*> (g <$> b <*> c)
13:25:07 <xenon-> I think I prefer join $ liftA2 f a (liftA2 g b c)
13:27:26 <xenon-> on the second though, with nice multi-line alignment, <$> and <*> is actually more readable
13:27:47 <xenon-> thanks!
13:37:18 <xenon-> what would we need to avoid join there? =<< that takes two actions?
13:38:11 <xenon-> we'd need liftA2-like bind, as far as I can see?
13:38:44 <Solonarv> yeah, I guess
13:39:24 <xenon-> bind2 :: Monad m => m a -> m b -> (a -> b -> m c) -> m c
13:39:59 <Solonarv> :t f =<< a <*> (liftA2 b c)
13:40:00 <lambdabot> error:
13:40:01 <lambdabot>     • Couldn't match expected type ‘f b -> f c0 -> ()’
13:40:01 <lambdabot>                   with actual type ‘Expr’
13:40:10 <Solonarv> :t ?f =<< ?a <*> (liftA2 ?b ?c)
13:40:11 <lambdabot> (?f::a1 -> f b1 -> b2, ?c::f a2, ?b::a2 -> b1 -> c, ?a::f b1 -> f c -> a1, Applicative f) => f b1 -> b2
13:40:36 <monochrom> @type liftA2
13:40:37 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
13:40:37 <Solonarv> :t (?f =<< ?a) <*> (liftA2 ?b ?c)
13:40:39 <lambdabot> (?f::a1 -> f b1 -> f c -> b2, ?c::f a2, ?b::a2 -> b1 -> c, ?a::f b1 -> a1, Applicative f) => f b1 -> b2
13:40:45 <tito_04> bindM2 f a b = ((f <$> a ) =<<) b
13:40:59 <monochrom> Oh, I see the difference from bind2
13:41:15 <tito_04> (tito_04) bindM2 f a b = ((f <$> a ) =<<) <$> b
13:41:18 <monochrom> OTOH consider foldM :)
13:41:22 <monochrom> @type foldM
13:41:23 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
13:41:38 <monochrom> Hrm but that's missing the other bit too.
13:41:47 <tito_04> @let bindM2 f a b = ((f <$> a ) =<<) <$> b
13:41:48 <lambdabot>  Defined.
13:41:51 <gianmaryy> hi everyone
13:41:52 <xenon-> probably nicer if function comes first, yes
13:42:00 <tito_04> :t bindM2
13:42:01 <lambdabot> (Functor f, Monad m) => (a1 -> m b) -> (a2 -> a1) -> f (m a2) -> f (m b)
13:42:20 <tito_04> Mm something wrong
13:48:16 <xenon-> @hoogle Monad m => (a -> b -> m c) -> m a -> m b -> m c
13:48:16 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
13:48:16 <lambdabot> Text.XML.Cursor (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
13:48:17 <lambdabot> Text.XML.Cursor.Generic (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
13:48:46 <xenon-> anyway, doesn't look bad.   bind2 f a (liftA2 g b c)
13:49:34 <tito_04> Wait
13:49:58 <tito_04> join = (id >>=)?
13:50:28 <hololeap> join = (>>= id)
13:50:44 <tito_04> xenon-: ^^
13:53:05 <xenon-> not sure how I'm supposed to take advantage of that
13:58:50 <xenon-> > :t let bind2 f a b = join (liftA2 f a b) in bind2
13:58:53 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
13:59:00 <xenon-> :t let bind2 f a b = join (liftA2 f a b) in bind2
13:59:01 <lambdabot> Monad m => (a1 -> b -> m a2) -> m a1 -> m b -> m a2
13:59:10 <xenon-> ^ real liftM2 :P
14:01:57 <geekosaur> maybe someeday
14:02:11 <geekosaur> hm, why is this keyboard bouncing
14:02:24 <geekosaur> at least it's not the crappy one
14:02:52 <wroathe> What's the most straightforward way to prevent interleaving of output to stdout with putStrLn and multiple threads?
14:03:04 <comerijn> wroathe: Wrap a lock around it?
14:03:20 <comerijn> wroathe: Alternatively, designate a single thread that writes to stdout and have all others communicate to it
14:03:45 <comerijn> wroathe: For example, define a "Chan Text", one threads reads from it and prints to stdout, the others just write to the Chan
14:03:46 <wroathe> Ah, a "logger" thread
14:03:48 <wroathe> There's an idea
14:04:08 <comerijn> wroathe: Incidentally, monad-logger already has a bunch of stuff for doing that :p
14:04:33 <wroathe> comerijn: Gracias
14:32:20 <Bish> Prelude> :t take 1 [y| x<-[1..]::[Int], y <-[1 .. (fromIntegral (floor (sqrt x)))::Int]]
14:32:29 <Bish> im writing this now an then to show people haskell
14:32:42 <Bish> and everytime i get confused about Integral stuff
14:32:49 <Bish> how can make sense about this for me?
14:33:10 <xenon-> fromIntegral converts from integral to non-integral
14:33:11 <Bish> why does [1 .. floor $ sqrt 234923]
14:33:16 <Bish> work, while that doesn't
14:33:19 <xenon-> :t fromIntegral
14:33:21 <lambdabot> (Num b, Integral a) => a -> b
14:33:35 <aplainzetakind> *from integral to any Num.
14:33:40 <Bish> xenon-, yeah i know :t didn't help me by now
14:33:42 <xenon-> yep, was about to say
14:33:49 <aplainzetakind> it can be used to convert Int to Integer, for instance.
14:34:02 <xenon-> :t floor
14:34:03 <lambdabot> (Integral b, RealFrac a) => a -> b
14:35:06 <Bish> [ (x,y) | x<-[1..]::[Int], y <- [1 .. fromIntegral $ floor $ sqrt x]]
14:35:11 <Bish> what needs to be changed so this works?
14:35:40 <Bish> (without usuage of div pls)
14:36:16 <merijn> :t sqrt
14:36:17 <lambdabot> Floating a => a -> a
14:36:18 <xenon-> > [(x,y) | x<-[1..]::[Int], y <- [1 .. floor $ sqrt $ fromIntegral x]]
14:36:20 <lambdabot>  [(1,1),(2,1),(3,1),(4,1),(4,2),(5,1),(5,2),(6,1),(6,2),(7,1),(7,2),(8,1),(8,...
14:36:31 <merijn> Bish: sqrt doesn't work on Integrals, you need to fromIntegral before calling sqrt
14:37:02 <xenon-> > [(x,y) | x<-[1..], y <- [1 .. floor $ sqrt $ fromIntegral x]]
14:37:05 <lambdabot>  [(1,1),(2,1),(3,1),(4,1),(4,2),(5,1),(5,2),(6,1),(6,2),(7,1),(7,2),(8,1),(8,...
14:37:32 <xenon-> what merijn says, you used fromIntegral in the wrong place
14:38:22 <Bish> [1.. floor $ sqrt 5]
14:38:24 <Bish> why does this work then?
14:38:31 <Bish> in ghci that is
14:38:44 <xenon-> 5 is not int there
14:38:47 <geekosaur> nthing constraining it so it infers Double
14:38:56 <Bish> hm, so the 1 is double, too?
14:39:05 <geekosaur> if you have somethingt hat forces Int or Integer then you will need explicit coercion
14:39:13 <geekosaur> numeric *literals* are polymorphic.
14:39:18 <geekosaur> everhthing else you must convert
14:39:28 <xenon-> why literals in quotes?
14:39:34 <xenon-> aren't they literals?
14:39:38 <Solonarv> those aren't quotes
14:39:44 <xenon-> oh :)
14:39:49 <geekosaur> those are asterisks. bold for terminals
14:40:03 <geekosaur> (think markdown)
14:40:43 <Bish> [1.. floor $ sqrt 5::Int] works, tho?
14:41:16 <Solonarv> yes, because that parses as (floor $ sqrt 5) :: Int
14:41:36 <Bish> why? shouldn't :: bind hardest ?
14:41:40 <geekosaur> :: is not an operator
14:41:44 <geekosaur> it scopes as far as it can
14:41:46 <Solonarv> > [1 .. floor (sqrt 5 :: Int)]
14:41:48 <lambdabot>  error:
14:41:48 <lambdabot>      • Could not deduce (RealFrac Int) arising from a use of ‘floor’
14:41:48 <lambdabot>        from the context: Integral a
14:41:54 <geekosaur> which here is up to but not including the ..
14:42:04 <Bish> phew that's confusuing
14:42:05 <fen> Solonarv: there was something the abstraction of https://gist.github.com/Solonarv/ee6fdf1bfba5ded3c26cf27857abdda3 could not express...
14:42:10 <Bish> i expected it to "bind" superhard, like right next to it
14:42:12 <Bish> and infer the rest
14:42:39 <fen> there might actually be times when more than one value is returned along with the structure...
14:42:42 <Solonarv> that would be really annoying whenever you want to give a type to a long expression
14:42:53 * hackage sv-core 0.3.1 - Encode and decode separated values (CSV, PSV, ...)  http://hackage.haskell.org/package/sv-core-0.3.1 (qfpl)
14:42:56 <Bish> okay, thanks
14:43:20 <Bish> there is div there is divMod what do i use if i only want the rest?
14:43:29 <Solonarv> Bish: take a guess
14:43:34 <Bish> rest.
14:43:48 <Solonarv> then why is it called divMod and not divRest?
14:43:55 <fen> :t mod
14:43:56 <lambdabot> Integral a => a -> a -> a
14:44:01 <Bish> fuck im stupid
14:44:10 <Bish> maybe i should ditch programming all along
14:44:13 <Solonarv> there's also quot, rem and quotRem
14:44:22 <fen> :t rem
14:44:23 <lambdabot> Integral a => a -> a -> a
14:44:25 <Bish> yeah i knew all that, just confused
14:44:32 <xenon-> why don't TypeApplications work with Num a => a?
14:44:38 <Solonarv> (they differ in how they handle negative inputs, I can never remember which is which)
14:44:45 <Solonarv> % 5 @Int
14:44:46 <yahb> Solonarv: ; <interactive>:34:1: error:; * Cannot apply expression of type `p0'; to a visible type argument `Int'; * In the expression: 5 @Int; In an equation for `it': it = 5 @Int
14:45:13 <Bish> a more difficult question: are there machines(cpu) more suitable for pure functional code than von neumann?
14:45:32 <geekosaur> there's been a little work, but not much
14:45:42 <fen> Solnarv: there is a get instance for Free; get :: Structured i f => Free f a -> ((i,Free f a),Free f a)
14:45:46 <geekosaur> everything ends up von neumann because it has to interop at some level
14:46:01 <geekosaur> purely functional runtimes are ... difficult, or at least not very useful
14:46:32 <Bish> geekosaur, was just curious how that would look
14:47:00 <Solonarv> If you count VMs / abstract machines there's some more work that's been done
14:47:05 <geekosaur> there might be a ph.d theses or two in working that out :)
14:47:19 <fen> `r' was supposed to take values `a' , `(i,a)' and in this new case, `(i,Free f a)'
14:47:24 <Bish> Solonarv, no i would like to see it like a working machine :D
14:47:25 <Solonarv> Compiling to Categories (google it, with quotes) might be of interest?
14:48:09 <Bish> only thing i can think of is DNA computers, which do not exist(to that extend)
14:48:25 <Bish> was just wondering if i am missing something and you could build something useful with silicon
14:48:33 <Solonarv> fen: please stop mentioning me in your thought process, I don't understand what you're trying to accomplish and past experience tells me I'm not capable of understanding your attempts to explain.
14:48:34 <Bish> or even fp code ⇔ fpga does that stuff exist?
14:49:53 <xenon-> what name do you prefer for function   Monad m => (a -> b -> m c) -> m a -> m b -> m c?   bind2? bindM2? something else? M is superfluous, but on the other hand it highlights similarity with liftM functions
14:50:15 <conal> Bish: yes. you'll find some pointers at http://conal.net/papers/compiling-to-categories/ . see also https://clash-lang.org/ . 
14:50:43 <Solonarv> Hmm... the M is superfluous, but bindM2 still feels more natural to me.
14:51:14 <xenon-> liftM2 would be ideal, but it is already taken
14:51:33 <Solonarv> Indeed.
14:51:52 <Solonarv> I don't think it's a good idea to steal that name this decade
14:52:20 <fen> isnt that something like zip but for monads?
14:52:29 <fen> well, zipWith
14:53:11 <Solonarv> it's not related zip all that strongly
14:53:34 <fen> well, with an extra join...
14:53:41 <xenon-> it is like liftA2, except passed function returns m c instead of c
14:54:03 <Solonarv> fen: note that 'zipWith' is a valid implementation of 'liftA2' for lists, but it isn't compatible with any monad instance.
14:54:09 <Solonarv> (instead we have the MonadZip class)
14:54:12 <Bish> conal, well, where is the hardware that executes "categories" however that code looks
14:54:21 <Bish> that's where my question was going
14:54:59 <Bish> uh clash looks cool
14:55:04 <fen> % :t \ f a b -> join $ liftM2 f a b
14:55:04 <yahb> fen: forall {m :: Type -> Type} {a1} {a2} {a}. Monad m => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
14:55:50 * Solonarv screeches in AMP
14:55:56 <fen> isnt MonadZip = MonadPlus + Traversable ?
14:56:08 <Solonarv> No, where'd you get that idea?
14:56:10 <fen> :t fold
14:56:11 <lambdabot> (Monoid m, Foldable t) => t m -> m
14:56:45 <fen> but with the Alternative addition instead of mappend
14:56:52 <conal> Bish: one of the categories yields Verilog, which then becomes custom hardware for your code. Additional categories do other things (other execution platforms or other abilities, such as differentiation for machine learning etc).
14:57:20 <conal> Bish: it's not so much that hardware "executes" categories, but rather hardware *is* a category.
14:57:20 <Bish> super cool, thanks
14:57:34 <Bish> conal, which gets mapped, kinda like that?
14:57:43 <fen> just thought zip was something to do with traverse
14:58:03 <Solonarv> No, it isn't.
14:58:08 <conal> Bish: "mapped"?
14:58:18 <Bish> conal, nevermind
14:58:42 <Solonarv> conal: oh snap, that's cool!
14:59:02 <conal> Solonarv: :)
14:59:25 <Bish> [x | x <-[1::Int .. ], null $ filter (\y->mod x y == 0)[2..floor.sqrt.fromIntegral $ x] ] <= why is this example never listed when googling prime numbers haskell
14:59:30 <fen> hmm, maybe the list instance is giving some false idea that it is to do with a hamiltonian path
14:59:39 <Bish> i mean it's very inuitiv i get it's not the fasted out here
14:59:50 <benzrf> is a hamiltonian path a path that obeys hamilton's equations
14:59:57 <benzrf> cuz if so im always on a hamiltonian path
15:01:19 <fen> a lagrangian reference frame is not always a good idea... but no
15:01:57 <benzrf> > fix$scanl(+)0.(1:)
15:01:59 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
15:03:50 <fen> sometimes wonder if automatic differentiation has anything to do with computational algebra systems like mathmatica 
15:07:21 <fen> would be good to know how to use haskell for c_infinity categories of self-referential distributions...
15:07:23 * hackage milena 0.5.2.4 - A Kafka client for Haskell.  http://hackage.haskell.org/package/milena-0.5.2.4 (adamflott)
15:09:38 <suzu> what's a good haskell package for reading configuration values from a file?
15:11:31 <Solonarv> suzu: have you chosen a language for your config file yet?
15:11:46 <suzu> something ini-like is perfectly fine
15:11:52 <suzu> it does not need to do any computation
15:12:07 <suzu> i also dont need any nesting or any objects
15:13:03 <xenon-> there are several. this seems to be most popular one: http://hackage.haskell.org/package/ini-0.4.1
15:13:25 <suzu> how do you measure the popularity of a package on hackage?
15:13:27 <xenon-> at a glance I like syntax of this one. http://hackage.haskell.org/package/config-ini
15:13:40 <xenon-> suzu, see Downloads section
15:13:46 <suzu> ah
15:13:50 <fen> conal: is there a version for recurrent nets?
15:13:58 <suzu> i do like how the config-ini has an applicative form
15:14:02 <suzu> i'll roll with that
15:14:03 <suzu> thanks
15:14:24 <conal> fen: do you mean compiling recursive Haskell definitions?
15:14:29 <xenon-> suzu np
15:15:01 <fen> well if backpropegation is for DAGs, yes
15:15:48 <fen> does that mess up the categories?
15:16:41 <conal> fen: there's not yet support for explicit recursion in Haskell code. there will be. there is, however, already support for some functor-level operations, which might suffice for generating the equivalent of recurrent NNs.
15:18:19 <conal> fen: i don't think recursion messes up the categories. just needs an additional category subclass similar to ArrowLoop.
15:20:28 <fen> there are some genetic code finding novelty biased subnets. connecting these in a graph is like topological nets.. just wondering if lazily approaching the fixed point of Free nestings of such graphs has a natural representation via category theory
15:24:16 <fen> cant quite fathom MonadFix
15:27:40 <fen> well, not the lazy part, thats just for haskell
15:30:45 <fen> probably anything self referential will be plagued by limit cycles about stable attractors, but maybe damping might help bound the region of stability. something like artificial dispersion. 
15:31:25 <fen> such nested things need renormalisation group fixed points identifying 
15:36:35 <fen> uniqueness around bifurcation points using adaptive resolution is recovered in the limit that stochastic perturbations tend to zero...
15:38:29 <glguy> suzu: Have you tried https://glguy.net/config-demo/ ?
15:38:56 <fen> but the use of dicritisation schemes alongside closed form expressions for approximate integrable systems is tough. hence the interest in computational algebra systems in haskell
15:41:49 <fen> probably automatic differentiation and symbolic differentiation are totally different though. my bad, sry
15:42:09 <xenon-> f <$> a <#> (g <$> b <*> c)  <- what do you think? :)
15:42:14 <xenon-> (<#>) :: Monad m => m (a -> m b) -> m a -> m b
15:42:23 <glguy> I think I'd rather see do-notation
15:43:51 <xenon-> fair enough. what about <#> in general? monad's counterpart of <*>
15:44:27 <c_wraith> Monad already has ap and (<*>).  does it need a third symbol?
15:44:42 <xenon-> c_wraith, it doesn't do the same thing
15:44:43 <glguy> The third symbol smooshes in a join
15:44:51 <xenon-> yes
15:44:51 <c_wraith> Oh, I see
15:45:46 <Solonarv> does it chain well? hmm...
15:46:03 <xenon-> I made it infixl 4 <#>, same as <*>, so it should
15:46:33 <geekosaur> there's also, will I remember it? and do I want to incur a dependency for it?
15:46:42 <fen> Monad m => m (a -> m b) looks odd, where do those occur?
15:46:51 <geekosaur> or, reading someone else's code, how much will I want to throttle the author for doin g something unobvious?
15:46:57 <Solonarv> % let { mamb <#> ma = join (mamb <*> ma); infixl 4 <#> }
15:46:57 <yahb> Solonarv: 
15:46:59 <int-e> :t (join .) . ap
15:47:01 <lambdabot> Monad m => m (a1 -> m a2) -> m a1 -> m a2
15:47:23 <Solonarv> % :t ?f <$> x <#> y <#> z
15:47:23 <yahb> Solonarv: ; <interactive>:1:8: error: Variable not in scope: x :: m a0; <interactive>:1:14: error: Variable not in scope: y :: m a10; <interactive>:1:20: error: Variable not in scope: z :: m a1
15:47:35 <Solonarv> % :t ?f <$> ?x <#> ?y <#> ?z
15:47:35 <yahb> Solonarv: forall {m :: Type -> Type} {a} {a2} {a3} {a4}. (Monad m, ?f::a -> a2 -> m (a3 -> m a4), ?x::m a, ?y::m a2, ?z::m a3) => m a4
15:47:59 <Solonarv> uh, that doesn't work very well for longer chains
15:48:11 <xenon-> fen, it occurred to me earlier, I asked a question about it an hour or so ago
15:48:35 <Solonarv> I think I'd prefer bindM2, tbh
15:48:44 <int-e> % :t join (?f <$> ?x <*> ?y <*> ?z)
15:48:45 <yahb> int-e: forall {m :: Type -> Type} {a1} {a2} {a3} {a4}. (Monad m, ?f::a1 -> a2 -> a3 -> m a4, ?x::m a1, ?y::m a2, ?z::m a3) => m a4
15:48:50 <xenon-> fen you have two actions, and (a -> b -> m c), and you want to mash it all together
15:49:11 <int-e> % :t ?f <$> ?x <*> ?y <#> ?z
15:49:11 <yahb> int-e: forall {m :: Type -> Type} {a1} {a2} {a3} {a4}. (Monad m, ?f::a1 -> a2 -> a3 -> m a4, ?x::m a1, ?y::m a2, ?z::m a3) => m a4
15:49:50 <Solonarv> oh, hm.
15:50:04 <xenon-> Solonarv could it be fixed with a different precedence?
15:50:28 <Solonarv> no, the type is what I was worried about.
15:50:46 <Solonarv> but int-e's example shows how to use it for longer chains
15:51:40 <fen> oh right, Monad m => m (a -> m b) occurs after partial application, fair enough
15:52:02 <dminuoso> int-e: What are those magic curly braces?
15:52:30 <fen> -fprint-explicit-forall ?
15:53:21 <geekosaur> in the context? indicate which names are avalable for type application
15:53:25 <int-e> dminuoso: they are there to make kind annotations sane.
15:53:42 <Solonarv> -fprint-explicit-foralls, actually
15:53:44 <dminuoso> geekosaur: Oh. Is that new? I thought this was WIP
15:53:56 <dminuoso> I remember reading about it in #ghc
15:53:59 <geekosaur> it's been flipping around a bit, but with the right options has been around in all of 8.x
15:54:07 <geekosaur> with various bugs at times
15:54:34 <int-e> dminuoso: Anyway, that isn't my bot. (geekosaur, is it yours? I forgot.)
15:54:42 <geekosaur> yahb? mniip's
15:54:47 <int-e> ah.
15:54:48 <mniip> hi
15:55:41 <dminuoso> geekosaur: Do you happen to know which extension enables this?
15:55:47 <dminuoso> TypeApplication seems to not be enough.
15:56:00 <geekosaur> [06 23:53:20] <Solonarv> -fprint-explicit-foralls, actually
15:56:16 <fen>  :set
15:56:16 <geekosaur> not an extension as such
15:56:29 <geekosaur> (tht is, not a -X... or LANGUAGE pragma)
15:56:46 <dminuoso> Oh you misunderstand. I thought you could manually specify this with ExplicitForAll
15:56:57 <geekosaur> you can't write the braces
15:57:05 <dminuoso> Ah what a bummer!
15:57:36 <dminuoso> What's the point of this then anyway? Isn't every type variable applicable?
15:57:40 <geekosaur> no
15:57:42 <Guest17493> nick stilgart
15:58:01 <stilgart> (rha... sorry for this mess)
15:59:21 <fen> its a shame ghci errors dont give the type of the called function with the explicit foralls shown in addition to that of the calling function
16:00:57 <fen> means you have to enable that fprint option and call :t at ghci to find the correct order the variables are declared when the compiler generates the forall
16:02:23 <iqubic> Is there a better way to do this?
16:02:57 <iqubic> evalFunc :: ExprF (Either String Double) -> Either String Double
16:03:01 <iqubic> evalFunc (ASinF x) = either (\left -> Left left)  (\right -> if isNaN (asin right) then Left "asin failed" else Right $ asin right) x
16:04:06 <Solonarv> iqubic: I'm pretty sure there's a monadic variant of 'cata' that you can use instead
16:04:10 <rain1> iqubic: hwy dont you write it in monad do notation
16:04:23 <aplainzetakind> iqubic: not defining ExprF over Either?
16:04:43 <Solonarv> aplainzetakind: that wouldn't make any sense
16:04:53 <aplainzetakind> why?
16:05:09 <iqubic> Solonarv: I'm already using cata. This is just possible pattern match of the alg
16:05:10 <Solonarv> the actual expression AST is 'Fix ExprF', evalFunc is an argument to 'cata'
16:05:26 <aplainzetakind> OK I have no context.
16:05:36 <iqubic> And I'm using Either to show the errors in evaluation.
16:05:41 <Solonarv> @hackage recursion-schemes -- aplainzetakind
16:05:41 <lambdabot> http://hackage.haskell.org/package/recursion-schemes -- aplainzetakind
16:05:52 <Solonarv> iqubic: I know you're using cata, I was suggesting that you find a 'cataM'
16:06:24 <iqubic> I either want to propagete the error that might already be in x, or apply asin, while checking that for errors.
16:06:46 <Solonarv> yes, that's exactly how the Monad instance for (Either String) behaves.
16:06:52 <iqubic> Solonarv: I'll look into finding cataM. I'm not sure exactly how that would work.
16:07:07 <iqubic> Solonarv: I'm aware.
16:07:30 <iqubic> I can't use the Alternative instance for (Either String), because that doesn't exist.
16:07:35 <rain1> > do Left "a" ; return 1
16:07:38 <lambdabot>  Left "a"
16:07:43 <iqubic> I know how that works.
16:07:51 <xenon-> Solonarv, now I get it, only last operator can be <#>, since we only need one join. so not much point in that operator
16:07:53 <rain1> > do x <- Left "x" ; Left "a" ; return 1
16:07:55 <lambdabot>  Left "x"
16:08:08 <iqubic> rain1: Thank you.
16:08:54 <iqubic> I'm not sure how to deal with the fact that asin might return NaN. If asin returns NaN, then I want to put my own error message in at that point.
16:08:59 <Solonarv> Hm, there doesn't appear to be a cataM in recursion-schemes
16:09:11 <iqubic> Solonarv: That sucks a lot
16:09:20 <rain1> :t guard
16:09:22 <lambdabot> Alternative f => Bool -> f ()
16:09:37 <iqubic> Anyways, I have to go. Talk to you all in about half an hour to 45 minutes when I get home.
16:09:55 <iqubic> rain1: Thanks, but there's no Alternative instance for (Either a)
16:10:03 <iqubic> So that doesn't quite work for me.
16:10:31 <iqubic> I know because I tried that at first.
16:10:44 <rain1> we could define a guard like functio
16:11:07 <rain1> guardE _ True = Right () ; guardE msg False = Left msg
16:11:12 <iqubic> I feel like there must be a better way to do that.
16:11:31 <iqubic> Anyways I really do have to go now.
16:14:06 <Solonarv> @tell iqubic how about this (same type as your earlier approach): evalFunc (ASin r) = do x' <- asin <$> r; when (isNaN x') (Left "error"); pure x'
16:14:06 <lambdabot> Consider it noted.
16:15:59 <fen> is there a CoPointed class?
16:17:16 <Solonarv> I think so, let me check
16:17:28 <Solonarv> @hackage pointed -- yup
16:17:28 <lambdabot> http://hackage.haskell.org/package/pointed -- yup
16:17:38 <Solonarv> It has the same problems as Pointed, though
16:18:17 <fen> laws?
16:18:35 <Solonarv> lack thereof, yes
16:19:22 <fen> also, cant remember if there was an conclusion to the "is a class defined by <$ a valid superclass of Functor" question...
16:19:35 <fen> :t <$
16:19:36 <lambdabot> error: parse error on input ‘<$’
16:19:40 <fen> :t (<$)
16:19:42 <lambdabot> Functor f => a -> f b -> f a
16:20:01 <Solonarv> the answer to that is obviously yes, the real question is whether that's useful.
16:20:13 <fen> and whats the real answer?
16:21:33 <fen> :t fmap . const
16:21:34 <lambdabot> Functor f => b -> f a -> f b
16:21:42 <Solonarv> probably not, IMO.
16:22:39 <fen> guess if it has some kind of shape preserving law, which would make it almost just like functor
16:23:40 <Solonarv> that law is 'x <$ (y <$ a) = x <$ a'
16:24:46 <c_wraith> and it's "just like functor" because it is functor.
16:25:06 <c_wraith> Or rather, it's derived from functor, though weakened along the way.
16:25:12 <fen> oh yeah that was it, it was like CoPointed + (<$) = Functor, but then thats just for the one value container, which is then certainly a functor as f a <-> (i,a)
16:25:21 <Solonarv> Well yes, "a weaker Functor" is the point
16:25:52 <fen> then got confused by (i,Free f a)
16:25:55 <Solonarv> fen: if you can derive a law-abiding 'fmap' from your class' operations, that means your class should have Functor as a superclass.
16:26:00 <Solonarv> Not the other way around.
16:26:46 <jle`> hello i am writing an embedded scripting language in dhall. but i can't think of any example scripts to write that are simple enough to be generally applicable but complex enough to be non-trivial. anyone have any ideas
16:27:25 <Solonarv> and if your class is 'Copointed + <$', then it's 'Copointed + Functor', which is just Copointed because the only law relating Copointed's and Functor's operations is a free theorem.
16:27:50 <Solonarv> jle`: do you have a use-case in mind for the scripting language?
16:28:07 <jle`> just general scripting. and maybe also usable as an embedded scripting language for haskell applications
16:28:34 <jle`> i was insipired by https://www.reddit.com/r/haskell/comments/acc2qx/which_scripting_languages_can_i_embed_in_a/
16:28:45 <jle`> so maybe shell scripting
16:28:50 <jle`> (for now)
16:29:45 <fen> matrix inversion?
16:30:30 <jle`> hm, maybe i can re-implement the tutorial here http://hackage.haskell.org/package/turtle-1.5.13/docs/Turtle-Tutorial.html
16:30:36 <glguy> jle`: Extend my IRC client to be dhall scriptable
16:30:58 <glguy> Maybe that's better than Lua :)
16:31:01 <Solonarv> oh that's a cool idea
16:31:03 <jle`> ah that sounds like not a bad goal :)
16:32:48 <fen> "Copointed does not require a Functor, as the only relationship between copoint and fmap is given by a free theorem."
16:33:03 <fen> what does that mean!? there is no Functor superclass..
16:33:50 <Solonarv> Exactly. It doesn't need a Functor superclass for the reason you just quoted.
16:33:55 <hpc> the law they are omitting is probably "if f is also a Functor, blah blah blah"
16:34:20 <fen> free theorem?
16:34:35 <fen> sounds too good to omit 
16:35:12 <Solonarv> A free theorem (in the context of Haskell, it might have other meanings elsewhere) is a theorem that follows from the types alone
16:35:16 <hpc> a free theorem is a theorem you get "for free" from just the type of a function
16:35:37 <fen> yeah, but if you dont write down what that theorem is...
16:35:39 <hpc> it's impossible for a value of that type to disoebey the theorem without resorting to unsafe*
16:36:02 <fen> its not clear which theorem is free...
16:36:07 <Solonarv> I assume it wasn't written down because it's sufficiently obvious.
16:36:16 <hpc> @free f a -> a
16:36:16 <lambdabot> Extra stuff at end of line
16:36:25 <hpc> @free copoint :: f a -> a
16:36:25 <lambdabot> Extra stuff at end of line
16:36:31 <hpc> what's the syntax again?
16:36:45 <Solonarv> It certainly is to me: copoint . fmap f = f . copoint
16:36:49 <Solonarv> hpc: no idea
16:37:02 <fen> ohhh
16:37:16 <hpc> but yeah, it's THAT trivial, lambdabot can generate the theorem for you
16:37:39 <fen> so its just a law thats always satisfied 
16:37:48 <Solonarv> Indeed.
16:38:35 <hpc> documenting free theorems as laws is right up there with documenting "const doesn't use unsafeCoerce on the second argument"
16:38:42 <Solonarv> a simpler example of a free theorem: forall (id :: a -> a). id x = x
16:38:53 <hpc> @free id
16:38:54 <lambdabot> f . id = id . f
16:39:31 <Solonarv> that's another one :D
16:39:33 <fen> is there a loopy belief propagation implementation in haskell? 
16:39:49 <koz_> fen: What do you mean by 'loopy belief propagation'?
16:40:01 <fen> bp on a cyclic graph
16:40:04 <iqubic> So, did anyone have any clever insights on my either problem.
16:40:47 <hpc> what is belief propagation?
16:41:10 <iqubic> Solonarv: Thank you for your suggestion. I'll try it out when I get a chance.
16:41:23 <Solonarv> iqubic: ah-ha, lambdabot didn't eat it!
16:41:31 <iqubic> Nope.
16:41:37 <fen> hpc: https://arxiv.org/pdf/0812.4627.pdf
16:41:48 <iqubic> I got a PM from lambdabot as soon as I joined.
16:41:51 <nshepperd> @free copoint :: F a -> a
16:41:51 <lambdabot> f . copoint = copoint . $map_F f
16:42:04 <Solonarv> nshepperd: ah-ha!
16:42:53 <hpc> nice
16:43:17 <hpc> the output of @free could really be improved though
16:43:21 <nshepperd> i guess it's gotta be a capital F
16:43:39 <hpc> i'd like to see it as "forall f. f . copoint = copoint . fmap f" or similar
16:43:55 <iqubic> evalFunc (ASinF x) = do x' <- asin <$> x; when (isNaN x') (Left "asin failed"); pure x'
16:44:04 <iqubic> That works, but I'd like to know why.
16:44:32 <Solonarv> iqubic: what part of it confuses you?
16:44:39 <iqubic> the when part.
16:44:48 <hpc> @src when
16:44:48 <lambdabot> when p s = if p then s else return ()
16:44:49 <Solonarv> :t when
16:44:50 <lambdabot> Applicative f => Bool -> f () -> f ()
16:45:08 <iqubic> because shouldn't x' have type "Either String Double"?
16:45:08 <hpc> heh, nice example of @src being wrong
16:45:29 <iqubic> How do you apply isNaN to Either String Double?
16:45:50 <Solonarv> iqubic: no; x has type Either String Double, but x' has type Double
16:45:50 <xenon-> :t isNan
16:45:52 <lambdabot> error:
16:45:52 <lambdabot>     • Variable not in scope: isNan
16:45:52 <lambdabot>     • Perhaps you meant ‘isNaN’ (imported from Prelude)
16:45:55 <hpc> x' is being bound from the computation asin <$> x
16:45:57 <xenon-> :t isNaN
16:45:58 <lambdabot> RealFloat a => a -> Bool
16:46:09 <hpc> because it's "x' <- ..." and not "let x' = ..."
16:46:30 <hpc> @undo do x' <- asin <$> x; when (isNaN x') (Left "asin failed"); pure x'
16:46:31 <lambdabot> asin <$> x >>= \ x' -> when (isNaN x') (Left "asin failed") >> pure x'
16:46:44 <hpc> so that's (asin <$> x) >>= \x' -> doesn't matter
16:46:46 <hpc> :t (>>=)
16:46:48 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:46:57 <hpc> presumably asin <$> x :: Either String Double
16:47:06 <hpc> m = Either String, a = Double, b = b
16:47:07 <hpc> or
16:47:13 <iqubic> x :: Either String Double.
16:47:19 <fen> hpc: loopy bp https://arxiv.org/ftp/arxiv/papers/1301/1301.6725.pdf
16:47:39 <hpc> the second argument to (>>=) is (a -> m b), so \x' -> ... :: a -> m b
16:47:41 <hpc> so x' :: a
16:47:47 <hpc> a = Double, so x' :: Double
16:48:06 <hpc> that's how you work it out mechanically
16:48:19 <fen> its nice because its a message passing algorithm between adjacent nodes of a loopy graph
16:48:38 <Solonarv> % check p msg a = do a' <- a; if p a' then Control.Monad.Fail.fail msg else pure a'
16:48:38 <yahb> Solonarv: 
16:49:12 <fen> was thinking if it wasnt already existing it could work as an example of the convolution framework on trees that tie the knot
16:49:36 <Solonarv> iqubic: with that function you can instead write: evalFunc (ASin x) = (asin <$> x) >>= check isNaN "got NaN"
16:49:54 <Solonarv> uh, I messed that up slightly
16:49:57 <Solonarv> 'm tired
16:50:12 <hpc> heh
16:50:45 <fen> thought it might be possible on the algebraic graph library too...
16:51:13 <fen> though not sure how the API fairs for convolutions
16:51:36 <Solonarv> iqubic: anyway, you get the idea - you can leave the error-message plumbing up to abstractions defined elsewhere
16:55:06 <iqubic> Yes. Yes I can.
16:55:16 <iqubic> > 1/0
16:55:18 <lambdabot>  Infinity
16:55:23 <iqubic> > 0/0
16:55:26 <lambdabot>  NaN
16:55:50 <iqubic> Alright, so for division it's stil more practical to check the denominator first.
16:56:03 <iqubic> Like such:
16:56:06 <iqubic> evalFunc (DivF x y) = if y == Right 0 then Left "Divide by zero error" else (/) <$> x <*> y
16:56:22 <Solonarv> you could write 'isSane :: Double -> Bool'
16:56:33 <iqubic> Yeah. I suppose.
16:57:05 <Solonarv> with isSane NaN = False, isSane ±Infinity = False, isSane _ = True
16:58:45 <monochrom> \x -> not (isNaN x || isInfinite x)
16:59:21 <hpc> @let isSane ±Infinity = False
16:59:23 <lambdabot>  .L.hs:169:10: error:
16:59:23 <lambdabot>      Not in scope: data constructor ‘Infinity’
16:59:23 <lambdabot>      Perhaps you meant variable ‘infinity’ (imported from Data.Number.Natural)
16:59:39 <hpc> aw man, that's an operator character
16:59:44 <monochrom> ±Infinity was pseudocode :)
16:59:50 <hpc> yeah
17:00:07 <hpc> i just wanted to make a point that IEEE floating point is never sane
17:00:24 <xenon-> > 1 `div` 0 :: Integer
17:00:29 <lambdabot>  *Exception: divide by zero
17:00:52 <hpc> if only '±' was a lower-case letter codepoint
17:01:02 <xenon-> why not the same behavior for floating division? IEEE requires Infinity?
17:01:23 <Solonarv> to be fair, adding Infinity to the real number line is well-founded.
17:01:30 <hpc> IEEE defined a range of bit patterns that are collectively called NaN
17:01:40 <hpc> and one bit pattern for infinity, and another for negative infinity
17:01:41 <Solonarv> signed infinity and NaNs are whack, though
17:01:53 <hpc> and defined that certain operations evaluate to those
17:02:31 <hpc> collectively, they occupy what would normally be the highest exponent bit pattern
17:02:32 <xenon-> would throwing exception break IEEE standard? some languages do that even for floating point division
17:02:52 <hpc> (floats are divided into sign bit, an exponent of 13 bits, and mantissa of 52 bits)
17:02:54 <monochrom> No, IEEE 754 allows exceptions too.
17:02:58 <xenon-> s/throwing exception/returning error
17:03:28 <monochrom> In fact it probably even says it allows the user to configure whether to get NaN or get an exception.
17:04:18 <Solonarv> %lua 1 / 0
17:04:18 <yahb> Solonarv: inf
17:05:55 <nshepperd> :t GHC.Float.isDoubleFinite
17:05:57 <lambdabot> Double -> Int
17:06:20 <Solonarv> > GHC.Float.isDoubleFinite (0/0)
17:06:23 <lambdabot>  error:
17:06:23 <lambdabot>      Not in scope: ‘GHC.Float.isDoubleFinite’
17:06:23 <lambdabot>      No module named ‘GHC.Float’ is imported.
17:06:29 <hpc> what is that type
17:07:07 <Solonarv> something something primop something something no Bool allowed
17:07:46 <hpc> ugh, that makes sense
18:00:52 * hackage hpython 0.1 - Python language tools  http://hackage.haskell.org/package/hpython-0.1 (qfpl)
18:01:34 <gracie> Well hello
18:03:15 <vaibhavsagar> conduit question: is there a combinator which will give me the length of input consumed?
18:06:55 <mouse07410> Is this the right place to discuss cabal v1- vs v2- issues?
18:17:11 <monochrom> Yes.
18:17:14 <AfC> vaibhavsagar: as a side effect?
18:18:14 <vaibhavsagar> AfC: ideally something like `(len, a) <- withLength foo` would give me the result in `a` and the length in `len`
18:37:04 <jle`> vaibhavsagar: you can probably pre-pipe with a WriterT conduit
18:37:15 <jle`> i'm not sure if there is a 'pre-built' one
18:40:42 <vaibhavsagar> what if my input is e.g.  zlib-compressed?
18:41:04 <jle`> vaibhavsagar: `iterM (tell (Sum 1)) .| myNormalPipe`
18:41:19 <vaibhavsagar> so I consume it, but how do I tell the length of what I consumed?
18:41:52 <jle`> in the end when you `runConduit`, you'll get `WriterT (Sum Int) m`, instead of `m`
18:41:59 <jle`> so you can `runWriterT` the result
18:42:39 <mouse07410> Here's a problem with cabal. I want to install a package "saltine" (got it from GitHub to compile from sources) and run my own package that depends on "saltine". Need to mention that saltine v0.1.0.2 exists on Hackage. When I use cabal v1- command to configure, build, and install saltine, everything's fine. Library is built, registered, and my package find that dependency correctly.
18:42:47 <vaibhavsagar> thanks jle`
18:42:51 <jle`> vaibhavsagar: there's also `runWriterLC` which lets you run the writer results "within conduit" itself
18:42:57 <jle`> so you can get the count on intermediate options
18:43:02 <jle`> *intermediate conduits
18:43:09 <vaibhavsagar> cool!
18:43:14 <vaibhavsagar> I'm pretty new to conduit
18:43:26 <vaibhavsagar> but I'm trying to convert a pipes program I wrote much earlier
18:43:58 <vaibhavsagar> because the pipes libraries I depended on aren't really being maintained at all and break on certain inputs
18:44:02 <jle`> using monad transformers like this always felt a little hacky to me but i've done it many times for different things now, and i wonder if it's the canonical way to tack on things like this
18:44:10 <jle`> vaibhavsagar: yeah, i understand that
18:44:20 <maerwald> mouse07410: what's the problem?
18:44:36 <vaibhavsagar> and `iterM` will run on each byte?
18:44:52 <jle`> it'll run on each 'item'
18:45:12 <jle`> so if your conduit is streaming byte-wise, then it'll be each byte
18:45:50 <mouse07410> However, when I v2-configure, v2-build, and v2-install - cabal fails to locate this dependency for my package, complaining that it rejected 0.1.9.2, 0.1.0.1, and older. It fails to find 0.1.1.0 that I built.
18:47:43 <mouse07410> Somehow, even though this is on the same machine and under the same user ID, saltine 0.1.1.0 library I built from sources didn't get registered when I use v2- commands.
18:48:18 <c_wraith> v2 commands don't put packages in the ghc registry
18:49:45 <mouse07410> c_wraith: but the same cabal on the same machine under the same user ought to keep track of what it built and installed?
18:50:03 <maerwald> mouse07410: you add saltine to your dependencies in your .cabal file
18:50:11 <c_wraith> if it needs the same package, it'll find it in the same place it built it before.
18:50:31 <c_wraith> But its definition of "same package" is pretty narrow.  Exact same version, exact same build flags, exact same dependencies.
18:51:57 <mouse07410> maerwald: it *is* listed as dependency, with version constraint, ad I need to user the latest one (0.1.1.0) I built, rather than the older one (0.1.0.2) that cabal can get from Hackage
18:52:16 <maerwald> mouse07410: 0.1.1.0 is not on hackage yet?
18:52:26 <mouse07410> Nope, it isn't
18:52:32 <maerwald> Ok, then you can use cabal.project
18:52:33 <maerwald> sec
18:53:38 <maerwald> mouse07410: https://gist.github.com/hasufell/9535782f3132ecc69d5f3f0312a77099 add this file to your project folder
18:55:04 <mouse07410> I don't think I get the "same package" concept. Why would it have to be the same version, if I require ">= 0.1.1.0"? I'd be ok with 0.2.0.0 when it appears.
18:56:08 <maerwald> you can remove the file when hackage has 0.1.1.0
18:56:10 <fen> this works ok, for a question earlier; https://bpaste.net/show/504f6272318d
18:56:52 <maerwald> see https://www.haskell.org/cabal/users-guide/developing-packages.html#source-repositories
18:57:19 <maerwald> You can also omit tag afais
18:58:36 <mouse07410> maerwald: I see what you're suggesting. But it's disturbing that cabal seems unable to use packages I install locally, and must fuels them from a remote site. The proposed approach also don't work for cars when I not just download but modify a package (e.g., fixing bugs). So if rather not follow the cabal.project approach.
18:58:51 <maerwald> mouse07410: It's nix-style build
18:59:02 <maerwald> It's not disturbing, it's on purpose
18:59:20 <maerwald> https://www.haskell.org/cabal/users-guide/nix-local-build-overview.html
18:59:22 <monochrom> If you switch back to v1-install you can use packages you installed.
18:59:42 <fen> actually its strange that works, probably it only does because the type family does not fire
18:59:49 <mouse07410> Sorry, my ignorance shows. I don't know nix-.
18:59:54 <fen> this is a better approach... https://bpaste.net/show/fcff56a7ffe8
19:00:11 <maerwald> mouse07410: you can also clone saltine locally and add the folder to the packages variable in cabal.project, then randomly patch it
19:00:16 <fen> though it isnt so neat to use UndecidableInstances to fix the associated type.
19:00:18 <maerwald> That's maybe what you want
19:00:24 <monochrom> This is why I hate the name "nix-style build". It has nothing to do with nix except borrowing the idea.
19:00:52 <monochrom> Consider "a Canon brand Xerox".
19:01:08 <maerwald> https://www.haskell.org/cabal/users-guide/nix-local-build.html#cfg-field-packages
19:01:21 <monochrom> a Royale-made Kleenex
19:01:26 <mouse07410> maerwald: are you saying that the new (v2-) approach is to stop locating locally built packages and only retrieve them from remote sites like Hackage and GitHub?
19:01:34 <maerwald> no
19:01:57 <maerwald> I provided pretty much all links, happy reading :P
19:02:14 <maerwald> If you just want it to work right now, use the file I pasted
19:02:30 <fen> is this an ok way to use UndecidableInstances. cant see any other way to fix the associated type...
19:02:35 <mouse07410> monochrom: thanks - yes I think I'll have to constraint myself to v1- commands. I hope they aren't going to be deprecated?
19:02:36 <fen> ?
19:02:53 * hackage hpython 0.1.0.1 - Python language tools  http://hackage.haskell.org/package/hpython-0.1.0.1 (qfpl)
19:02:53 <maerwald> They are and you will soon find out why
19:02:54 <monochrom> They won't be.
19:03:06 <maerwald> Though note deprecated != removed
19:03:22 <monochrom> No it's only the old names that are deprecated.
19:03:40 <monochrom> "cabal install" is deprecated but "cabal v1-install" is not.
19:03:58 <Clint> and hopefully never will be
19:04:08 <monochrom> Or rather, one day, "cabal install" will mean "cabal v2-install".
19:04:30 <c_wraith> that'll be soon.  the next release of cabal, apparently
19:04:55 <monochrom> They are already writing the user guide of v3
19:05:08 <mouse07410> maerwald: thanks for the references - I'll study them. No, I don't need it to work immediately. I'll record your file for future use when conditions are right for it, but it's doesn't fit this project.
19:07:25 <fen> the idea is that a fundep on between two parameters of a class cant be used here, as the parameter is actually a type family 
19:08:18 <fen> and so writing a type synonym over the class to fix one of the parameters, to return a Constraint with one fewer parameters, is not possible
19:08:34 <fen> instead, this approach using UndecidableInstances can be used...
19:08:41 <fen> wondering if thats ok style
19:18:36 <fen> well it seems to work anyway...
19:27:43 <mouse07410> maerwald: I got the impression from the URL you gave that cabal might *locate* the local project this one depends on, but it will insist on *rebuilding* it
19:31:47 <maerwald> mouse07410: I don't really know what you mean
19:43:30 <mouse07410> maerwald: I mean - I haven't found a way to instruct cabal via the new commands to just use the package I built locally. Cabal seems intent on *rebuilding* it even when found
19:45:28 <maerwald> mouse07410: What's the problem with that?
19:46:24 <maerwald> Note that it doesn't build in the local directory, instead it runs 'cabal sdist' creating a hackage tarball, then unpacks it into a /tmp dir, then builds it there
19:46:24 <mouse07410> Also, there's flag "allow-newer:" in cabal config. But it's unclear to me whether it's value is Bool (True or False), or {all, none, XXX (don't recall the third choice}.
19:46:46 <c_wraith> it accepts true or packages/versions
19:47:54 <mouse07410> When I've built a package, I prefer it to be used as-is, saving time and dusk space, rather than thing it a-fresh whenever done project lists it as is dependency.
19:48:07 <mouse07410> c_wraith: thank you!
19:48:46 <mouse07410> "dusk"->"disk"
19:49:12 <maerwald> mouse07410: imo, it would be awful if it messes with the current state of the directory
19:49:27 <mouse07410> "thing"->"recompile"
19:50:34 <mouse07410> maerwald: does v2 do away with our-user DB of installed packages that have been installed and can be used as-is?
19:51:00 <mouse07410> "our"->"per"
19:53:00 <maerwald> mouse07410: I already linked the user guide page which explains it
19:53:04 <maerwald> https://www.haskell.org/cabal/users-guide/nix-local-build.html#how-it-works
19:53:05 <c_wraith> the thing is, trying to support that compilation pattern is what resulted in so much of "cabal hell"
19:53:11 <mouse07410> I like to be able to request "sdist" kind of processing - but I hate when it's shoved down my throat regardless of whether I need it or not
19:53:17 <c_wraith> the fact is, different things have different dependencies
19:53:25 <c_wraith> Trying to pretend otherwise results in things breaking
19:53:41 <maerwald> c_wraith: solvable problem, but not on tooling level
19:56:17 <mouse07410> I don't understand "different things have diff dependencies". My package either depends on saltine, or it doesn't. If it does - it may require a specific version. But if two packages depend on saltine 0.1.1.0 - then it's not a "different dependency"
19:58:08 <maerwald> mouse07410: read https://research.swtch.com/version-sat
20:03:24 <mouse07410> maerwald: yes, in general SAT is a tough problem. Still, that doesn't invalidate what I said.
20:03:50 <maerwald> It explains what you didn't understand
20:03:54 <monochrom> Hrm maybe I should give this as an assignment question!
20:05:50 <monochrom> BTW "Optimization: " accepts True, False, 0, 1, 2.
20:06:05 <monochrom> Also true and false, but generates a warning.
20:06:21 <maerwald> mouse07410: You're complaining about a tool that solves a tough problem in one of the few ways that are possible. Remove the solution and you get into "dependency hell". It's very simple.
20:06:26 <mouse07410> Based on the nix page, I want saltine *in this project/case* treated as "external package", but I want it taken from the local build Target than Hackage
20:06:38 <monochrom> I found this out when I accidentally read cabal-install source code.
20:06:47 <maerwald> mouse07410: I already showed you how to do it
20:07:33 <maerwald> monochrom: why did you do that??
20:07:42 <monochrom> It was an accident.
20:07:55 <monochrom> Or maybe I was looking for something else and ran into it.
20:08:47 <maerwald> mouse07410: https://github.com/haskell/haskell-ide-engine/blob/master/cabal.project#L1 
20:09:09 <maerwald> That should be enough of links and examples to solve all your problems
20:09:25 <maerwald> (unless the broken cabal --help pages start confusing you)
20:09:38 <maerwald> mish-mash of v1 and v2
20:10:08 <maerwald> and a few regressions here and there :D
20:13:44 <mouse07410> Thanks. So far I found v1- commands behaving to my satisfaction, and doing exactly what I want. At this point - unless a project requires a stack-style snapshot approach - I seem unable to get anything useful from v2- commands.
20:14:34 <maerwald> Yes, if you have only a single project on your entire machine, then v1- will work
20:15:59 <Clint> or if you have a curated set of projects
20:17:44 <mouse07410> In other ecosystems, like Linux package managers and MacOS Macports, we run plenty of projects that share common libraries and components without the need to replicate every dependency throughout the universe. There the v1-style approach works just fine for us. And yes, or project sets are usually curated.
20:21:15 <mouse07410> I guess my problem is achieving v1-style behavior via v2- commands, without keeping clones of dependencies in the lock project directory (or in the /tmp), and without rebuilding every local dependency by every project that needs it. But if that's too hard, at least there still are those v1-style commands.
20:21:40 <mouse07410> "lock"->"local"
20:21:53 <jle`> this isn't too bad for writing scripts in dhall, right... https://github.com/mstksg/dhallscript/blob/master/test/script.dhall
20:22:00 <jle`> maybe i should add in do notation
20:22:22 * hackage dovin 0.1.0.0 - A proof assistant for Magic: The Gathering puzzles.  http://hackage.haskell.org/package/dovin-0.1.0.0 (xaviershay)
20:22:53 <jle`> proof assisitant for MtG ... definiteily something i didn't realize i needed until now
20:26:22 * hackage waargonaut 0.5.2.0 - JSON wrangling  http://hackage.haskell.org/package/waargonaut-0.5.2.0 (schalmers)
20:27:48 <vaibhavsagar> which SAT solver does Cabal use?
20:28:22 * hackage dovin 0.1.0.1 - A proof assistant for Magic: The Gathering puzzles.  http://hackage.haskell.org/package/dovin-0.1.0.1 (xaviershay)
20:33:03 <vaibhavsagar> hmm, this seems to indicate that we've implemented our own: https://www.reddit.com/r/haskell/comments/30h8jx/qualified_goals_in_the_cabal_solver_includes_a/
20:33:03 <maerwald> mouse07410: "and without rebuilding every local dependency by every project that needs it" -- why do you assume this is the case?
20:33:17 <vaibhavsagar> would be cool to split it out into its own package
20:43:26 <mouse07410> maerwald: because the docs weren't very clear, and I haven't read them carefully enough yet, just browsed. And because there doesn't seem to be a global per-user DB of packages that I could instruct the new cabal to insert or remove packages from. I haven't figured yet how/where "external packages" DB is kept by the new cabal, and how to affect it.
20:46:22 <maerwald> Why would you tell cabal to insert or remove packages?
20:55:27 <mouse07410> Because it's convenient for me to tell cabal "this package is to be used my other packages/projects on this machine - make it available/visible", and "this package is not to be accessed by other projects at this time".
20:56:12 <maerwald> mouse07410: why?
20:56:20 <maerwald> You declare your dependencies in your .cabal file
20:56:27 <maerwald> new-build caches between projects already
20:57:27 <maerwald> You don't have an actual use case, you're just used to a different workflow, which doesn't apply here
21:02:35 <mouse07410> True - I'm used to a different workflow.
21:05:32 <mouse07410> But when I listed dependencies in the <project>.cabal file, they (actually the one package I built from the source - saltine) was not found. Cabal found it's older versions on Hackage (which I forbade it to use), but could not find the locally-cached result of the v2-build of saltine.
21:20:06 <mouse07410> Also, it's convenient to be able to tell what's cached locally at this time (aka "ghc-pkg list" for cabal)
22:09:42 <dminuoso> https://gist.github.com/dminuoso/741af5162d08b3a50f5d4153d345dd06 in line 11 of the desugarer output I see a second argument of FooInt `co_a1aX`. Is that the type equality proof that (a ~ Int) for `Foo a`?
22:12:23 <yyt16384> is there a String -> Integer parsing function that only accepts valid decimal numbers? read also accepts spaces and parentheses which i don't want
22:13:10 <dminuoso> yyt16384: You could write a miniature parser.
22:13:15 <iqubic> yyt16384: I think you'll have to write your own parser.
22:13:35 <yyt16384> oh well...
22:15:34 <dminuoso> To my question, I guess it has to be the type equality proof which is created by TestGADT.$tc'FooInt in there.
22:52:50 <maerwald> mouse07410: if cabal did not find your local package, you didn't tell it to use it
23:09:56 <koz_> maerwald: Is mind-reading coming to cabal's next major version?
23:10:11 <maerwald> Yeah, will have AI backend
23:10:27 <maerwald> At some point it will delete itself and install stack
23:10:29 <koz_> New error messages: "You don't want to import that library"
23:10:43 <koz_> "What are you doing, did you forget the functor laws?"
23:10:53 * hackage yam 0.5.3, yam-datasource 0.5.3 (leptonyu): https://qbin.io/raises-panama-8hdb
23:31:09 <royal_screwup21> is this definition of a parser accurate? A parser is a function takes in a list of chars and returns an item that was parsed, along with the unconsumed string
23:35:06 <jle`> royal_screwup21: that depends on the context, i think
23:35:30 <jle`> usually people think of a parser as an abstract type with some certain API
23:35:38 <jle`> royal_screwup21: what you described might be one way to implement a parser
23:36:07 <jle`> or one way you might describe a parser, maybe, depending on what you're going to be doing with that description
23:36:14 <jle`> it depends on context ultimately i think
23:36:40 <royal_screwup21> jle`: yup..this is in the context of parser combinators
23:37:19 <jle`> i still don't think that it's the *only* way of defining what a parser in the context of parser combinators is, but it's often one way to implement them commonly
23:37:48 <royal_screwup21> I've just started reading about it, and I wanted to make sure I was reading BS since it conflicts with the traditional implementation of a parser (List<Tokens> -> AST)
23:37:58 <royal_screwup21> wasnt*
23:38:20 <dminuoso> royal_screwup21: A parser is just some piece of software that analyses some text, producing a result based on some grammar rules.
23:38:24 <nyc`> An Arrow computation sounds reasonable.
23:39:04 <jle`> royal_screwup21: right, i don't think it serves too well as a "definition", but it's definitely an ok implementation
23:39:14 <jle`> royal_screwup21: as long as you include the possibility of failure
23:39:34 <jle`> `type Parser a = [Char] -> Maybe (a, [Char])`
23:42:56 <dminuoso> royal_screwup21: Consider though, that the defintion is very much like what you proposed.
23:43:20 <dminuoso> R0b0t1`: `List<Token> -> AST` vs `[Char] -> (AST, [Char]`
23:43:25 <dminuoso> Ops.. weechat is weird. :(
23:43:59 <dminuoso> The only difference is, that with this representation you *also* add how much was left unconsumed to the "result" (it does not have to be an AST really)
23:44:11 <royal_screwup21> ah I see..
23:44:13 <koz_> Yeah, parsers don't _have_ to produce an AST.
23:44:20 <koz_> (they usually do, but there's no requirement that they do so)
23:44:50 <dminuoso> royal_screwup21: And by keeping the "unconsumed" around, you can suddenly compose parsers.
23:45:58 <royal_screwup21> thanks for clarifying folks. Do y'all have any recommendations for learning to build/use parser combinators? Something in java/kotlin/python would be cool....I'm reading a haskell guide, but a lot of it is going over my head
23:46:52 <dminuoso> royal_screwup21: I liked http://dev.stephendiehl.com/fun/002_parsers.html when I was new to Haskell to get a grasp on parsers.
23:47:19 <dminuoso> It's essentially just recursive descent parsing in a composable way.
23:47:28 <nyc> I think you need a functional language for parser combinators.
23:47:49 <dminuoso> Depending on your definition of parser combinator I guess.
23:49:36 <coldpress> is there a graphics library in haskell that handles text positioning well? I'm using Gloss right now, and it's so hard to put the text in the top left corner
23:51:14 <mouse07410> maerwald: are you doing that v2- requires a different way of telling cabal what the dependencies are?  In my case, v1 commands deal with this dependency (saltine) fine. I thought it proves that .cabal file is correct?
23:51:51 <mouse07410> "doing"->"saying"
23:52:17 <laserpants> Does anyone know in which version <*> went into base?
23:52:59 <jle`> laserpants: base, or Prelude?
23:53:08 <jle`> if base, probably some time around 2008-2010
23:53:27 <jle`> (that's when we started using Applicative)
23:56:25 <laserpants> in Prelude I meant
23:57:00 <maerwald> mouse07410: no, at this point I have no idea what you tried, what happened and what you expected to happen
