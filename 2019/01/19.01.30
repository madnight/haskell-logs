00:05:38 <jackdk> I dunno, I switched over to hoogle
00:25:29 * hackage cabal2nix 2.14 - Convert Cabal files into Nix build instructions.  https://hackage.haskell.org/package/cabal2nix-2.14 (PeterSimons)
00:26:48 <v0d1ch> oh I didn't know there is the _new_ hoogle also https://hoogle.haskell.org/
00:32:40 <joncol> Hi, what do people generally use for a LIFO stack? Simple list? Are there any canonical data structure/package for stacks?
00:39:17 <superlinux> hello. I have a problem as follows: I use Debian Linux. my ghc is not producing an executable although there is function "main" in the code and it's only saying to me compiling and i don't see the line linking. I want to get the standalone executable file
00:40:34 <joncol> superlinux> what command do you use to run GHC?
00:42:16 <superlinux> I use ghc 8.x and i compile like : ghc myfile.hs
00:42:25 <superlinux> joncol, :)
00:43:39 <DasBrain> :t concatMap
00:43:40 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
00:44:11 <joncol> superlinux: OK, that weird. I usually use the `stack` tool to build stuff, but `stack ghc t.hs` with a simple main in t.hs works for me :D
00:44:36 <DasBrain> :t >>= 
00:44:37 <lambdabot> error: parse error on input ‘>>=’
00:44:43 <DasBrain> :t (>>=)
00:44:45 <lambdabot> Monad m => m a -> (a -> m b) -> m b
00:44:57 <superlinux> I know  what is stack.. 
00:45:04 <DasBrain> :t flip (>>=)
00:45:06 <lambdabot> Monad m => (a -> m b) -> m a -> m b
00:45:26 <superlinux> I wanted to test a hello world code
00:45:43 <joncol> superlinux: Can you gist your code?
00:46:12 <superlinux> module Print1 where
00:46:13 <superlinux> main :: IO ()
00:46:13 <superlinux> main = putStrLn "hello world!"
00:46:19 <superlinux> that's my code
00:46:24 <superlinux> nothing else
00:48:21 <joncol> superlinux: OK, then I have nothing. Maybe uninstall debian and try Arch Linux.
00:48:25 <joncol> ;)
00:52:11 <[Leary]> superlinux: You can set the output filename with the -o option. If you don't set the option, it should default to the base filename of the source file you asked it to compile.
00:56:21 <[Leary]> The module might also need to be called Main (or left implicit). Any other module name implies you're writing a library module, not an executable.
00:57:56 <superlinux> [Leary], yes! the module must be obligatory to have it called as Main
01:01:04 <superlinux> joncol, see the answer 
01:04:01 <superlinux> [Leary], it generates the exe file now. however, I know it looks silly, but just asking, is there a way to force it take any module name and make an exec file from it?
01:07:25 <[Leary]> Not that I'm aware of. I would just leave the module name implicit and call the file whatever you want.
01:08:18 <superlinux> [Leary], thanks.
01:10:30 <jchia> Megaparsec question: I have a parser A that takes a Text/String and I want to use it within a parser B that takes ByteString, decoding the ByteString with Latin encoding into Text/String for parser A. Can it be done easily?
01:11:44 <jchia> A related question: The input file for parsing is really just Latin1, so every character is one byte. Should I try to economize by avoiding using Text and using ByteString instead?
01:18:02 <superlinux> jchia, I want to say only this: if whatever you are testing has the answer is only YES or NO and has no risks or dangers, then try it.
01:19:30 * hackage gtk2hs-buildtools 0.13.5.0 - Tools to build the Gtk2Hs suite of User Interface libraries.  https://hackage.haskell.org/package/gtk2hs-buildtools-0.13.5.0 (HamishMackenzie)
01:20:59 * hackage glib 0.13.7.0 - Binding to the GLIB library for Gtk2Hs.  https://hackage.haskell.org/package/glib-0.13.7.0 (HamishMackenzie)
01:22:00 * hackage cairo 0.13.6.0 - Binding to the Cairo library.  https://hackage.haskell.org/package/cairo-0.13.6.0 (HamishMackenzie)
01:22:59 * hackage gtk3 0.15.1, pango 0.13.6.0, gio 0.13.6.0 (HamishMackenzie)
01:23:31 <kuribas> @hoogle (&)
01:23:31 <lambdabot> Data.Function (&) :: a -> (a -> b) -> b
01:23:31 <lambdabot> Control.Lens.Lens (&) :: () => a -> (a -> b) -> b
01:23:31 <lambdabot> Control.Lens.Operators (&) :: () => a -> (a -> b) -> b
01:24:00 * hackage gtk 0.15.1 - Binding to the Gtk+ graphical user interface library.  https://hackage.haskell.org/package/gtk-0.15.1 (HamishMackenzie)
01:24:08 <gentauro> @hoogle id
01:24:08 <lambdabot> Prelude id :: a -> a
01:24:08 <lambdabot> Data.Function id :: a -> a
01:24:08 <lambdabot> Control.Category id :: Category cat => cat a a
01:30:59 * hackage webkit2gtk3-javascriptcore 0.14.3.0 - JavaScriptCore FFI from webkitgtk  https://hackage.haskell.org/package/webkit2gtk3-javascriptcore-0.14.3.0 (HamishMackenzie)
01:41:34 <kuribas> Can liquid haskell be used for any haskell program?
01:41:48 <kuribas> or is it just a theorem prover that happens to work with haskell?
01:42:25 <figurelisp> would it be off topic if i ask how is type system of haskell and typescript differs
01:44:03 <merijn> kuribas: Liquid Haskell is just some annotation syntax on top off haskell + a solver
01:44:23 <kuribas> merijn: but will it work with more complicated haskell programs?
01:44:28 <merijn> figurelisp: I don't think that's offtopic, but I'm not sure anyone knows typescripts type system well enough to answer
01:44:30 <kuribas> that use extensions etc... ?
01:44:36 <merijn> kuribas: Depends on the complexity of your problems
01:45:21 <kuribas> or can I mix easier, provable with LH functions, with unproven non LH functions?
01:45:23 <figurelisp> merijn: ok, one question though. How does one know that a particular language has a sound type system
01:45:40 <kuribas> figurelisp: sound in what sense?
01:45:42 <merijn> figurelisp: By painfully writing a proof :p
01:45:49 <kuribas> terminating?
01:46:01 <kuribas> inferable?
01:46:07 <dminuoso> Indeed, "soundness" is not a well defined term in general.
01:46:22 <merijn> kuribas: afaik Liquid Haskell is just a bunch of predicates and then they throw a SMT solver at it to check they hold
01:46:24 <figurelisp> yes i know that is not well defined term so is strong type
01:46:37 <merijn> kuribas: It doesn't change the Haskell code at all
01:46:51 <kuribas> merijn: yes.  That means IMO they only support a subset of haskell.
01:47:07 <kuribas> merijn: or haskell without extensions
01:47:09 <figurelisp> I'm just new to this so i don't knwo how to explain properly kuribas 
01:47:10 <merijn> kuribas: I don't think so
01:47:11 <dminuoso> merijn: It's more than just predicates though. It's more like an automated theorem prover.
01:47:21 <merijn> dminuoso: Sure, that was a 1 line summary
01:47:47 <merijn> kuribas: I think they can handle all of Haskell + most extensions, it's just that depending on the properties you write they might just not be solvable
01:48:01 <kuribas> merijn: ah, cool
01:50:36 <figurelisp> can someone guide me to reading material so that i can understand what people talk about when they say this or that language has good type system
01:50:56 <figurelisp> or point me to another channel where i can ask these type of question
01:50:58 <kuribas> from my superficial examination it seems that write proofs and properties in LH is easier than in COQ, etc...
01:51:03 <merijn> figurelisp: Depends, is the goal to learn to program Haskell or to learn about type systems? :)
01:51:12 <figurelisp> merijn: both
01:51:44 <merijn> figurelisp: Here's a list of resources on learning Haskell: https://github.com/bitemyapp/learnhaskell
01:51:47 <kuribas> figurelisp: one of the ways to compare type systems is expressiveness.
01:52:07 <kuribas> figurelisp: the type system in haskell is more expressive than say Java, since you can express more in it.
01:52:23 <figurelisp> how do you define expressiveness
01:52:31 <merijn> figurelisp: As for type systems, I would recommend the book "Types and Programming Languages" by Pierce, which starts from the untyped lambda calculus and teaches you everything you wanted to know about type systems (and more)
01:52:32 <kuribas> Then lisp people will claim their language is more flexible, since you don't need to worry about types :)
01:52:57 <kuribas> figurelisp: the amount of information you can encode in the type system (and having it checked at compile time).
01:53:09 <figurelisp> merijn: can a beginner start reading TAPL
01:53:11 <kuribas> figurelisp: in that sense idris will be more expressive.
01:53:20 <dminuoso> figurelisp: Yes.
01:53:49 <merijn> figurelisp: Imagine a Venn diagram of all possible programs (where the set of useful/correct programs is a subset). Type systems (try) to force that all programs that typecheck belong to the set of correct programs
01:54:10 <dminuoso> figurelisp: As a beginner you will not understand the entirety of the book, but that shouldn't be your goal.
01:54:19 <kuribas> merijn: correct doesn't exist
01:54:21 <merijn> figurelisp: If your type system only allows 'print("hello world")', then clearly you can never write "wrong programs", but you also can't write many correct programs
01:54:34 <merijn> kuribas: Sure it does, it's not well defined or enumerable, but it does exist
01:54:39 <dminuoso> kuribas: It does up to some sense of "correct"
01:54:51 <kuribas> correct only makes sense in relation to some properties
01:55:19 <merijn> figurelisp: Expressiveness is a matter of "what percentage of correct programs does the type checker allow you to write?"
01:55:37 <merijn> kuribas: Except my argument works for any arbitrary definition of correctness/property, so it's not relevant
01:55:47 <figurelisp> ok, so if a language for ex: typescript/Javascript has number as a type but not int, float, double etc then it is not expressive, is that correct
01:55:58 <merijn> figurelisp: Yes, no, maybe
01:56:18 <dminuoso> figurelisp: Types go *way* beyond just classifying values.
01:56:24 <figurelisp> ok
01:56:45 <dminuoso> figurelisp: Types are ultimately a domain specific language that are used to statically verify program correctness up to whatever guarantees the type system gives you.
01:56:47 <merijn> figurelisp: Strictly distinguishing int/double might make it HARDER to write some programs that make sense, in which case that'd be less expressive
01:56:47 <kuribas> correct in the sense of "it does what the programmers expects it to do", is nice, but types cannot garantee it.
01:56:54 <dminuoso> figurelisp: For example Javas type system guarantees the absence of segmentation faults.
01:57:07 <dminuoso> (Ignoring some exotix backdoors you get to circumvent Javas type system)
01:57:08 <merijn> kuribas: Correct, but also not particularly helpful nor relevant for the point being made
01:57:43 <merijn> There's a time for pedantry about formal definitions and this is not it.
01:59:02 <figurelisp> ok i should start the book. Thank you all for the guidance
01:59:16 <kuribas> merijn: yes, because such claims can easily be disproven
01:59:27 <dminuoso> figurelisp: So in other words: As long as your Java program type checks, then it is segmentation fault free. Now expressiveness could be the ability to describe other invariants through the type system.
01:59:57 <merijn> figurelisp: As for "how hard is TaPL", it's not particularly hard. It was written as a text book for undergrad students. All the example code is written in Ocaml, though. So a bit of Haskell and/or Ocaml experience will be helpful for reading them
02:00:04 <dminuoso> figurelisp: For example in Haskell you can use the type system to enforce an invariant "User input is always escaped before being put into the database". We can express this idea in the type system, and have the type system generate a proof of this.
02:00:40 <dminuoso> merijn: You should add the remark that he might not make it through the end of the book. There's a some chapters that go beyond undergrad topics.
02:00:44 <figurelisp> I have little exp with haskell as I am on my 7th chapter to LYAH
02:01:01 <merijn> dminuoso: Hell, I've not made it through that book yet :p
02:01:06 <kuribas> merijn: and we must make strong arguments for haskell and types.
02:01:32 <dminuoso> figurelisp: So Ill make the note: You will not understand the entirety of the book. Perhaps you will only make it through the first 100 pages, and skip some excercises. This is fine.
02:01:58 <merijn> kuribas: Intuition must come before formal definitions. Especially since there isn't even a formal definition of "expressiveness", so insisting on keeping the explanation formal is uselss
02:02:05 <figurelisp> dminuoso: ok
02:02:22 <kuribas> merijn: I meant about "correctness", not "expressivity"
02:03:04 <merijn> kuribas: Except that the explanation works for any definition of correctness, so the exact details are irrelevant
02:03:34 <dminuoso> 10:54       dminuoso | kuribas: It does up to some sense of "correct"
02:03:50 <merijn> kuribas: "we must make strong arguments for Haskell and types" <- Sure, if you think the world is an objective debate that must be won using objective facts.
02:04:40 <merijn> I like to think that helping people understand and get an intuition for things is far more helpful in both not seeming rude and long term adoption
02:05:01 <merijn> I will pick pedagogy over correctness and objectivity any day
02:06:16 <kritzefitz> When I have a function like `(forall b. (FooRel A b) => A) -> A` it means that I can pass a polymorphic function to it and the function has to make sure that `FooRel A b` holds when it instantiates the argument, right?
02:06:42 <kritzefitz> Sorry, I meant “pass a polymorphic value”.
02:06:53 <merijn> kritzefitz: It means you *must* pass a polymorphic value
02:06:54 <dminuoso> kritzefitz: Not just can, you must.
02:07:32 <merijn> Incidentally, I'm not convinced that type has any useful implementations?
02:07:39 <dminuoso> kritzefitz: Its just like beginner haskell. `(forall b. (FooRel A b) => A) -> A` means the first argument *must* be of type `forall b. (FooRel A b) => A`
02:07:41 <merijn> oh, I suppose it might
02:07:53 <kritzefitz> Yes, that's what I actually meant. As in “I can pass a polymorphic value, but nothing else”.
02:07:55 <merijn> Since A is fixed
02:08:40 <kritzefitz> Then, can someone enlighten me, why I can't apply `runFoo` to `foo` in this snippet: https://gitlab.com/snippets/1806781
02:09:00 <merijn> kritzefitz: It'd help to include the error :)
02:09:07 <kritzefitz> Ah, yes sorry.
02:09:52 <merijn> kritzefitz: Although, just that example code makes me think "this is probably an unwise way to structure your code"
02:10:23 <kritzefitz> merijn, I added the error.
02:10:31 <kritzefitz> merijn, can you elaborate why you think that?
02:10:51 <dminuoso> kritzefitz: At the very least you are missing FlexibleContexts.
02:11:04 <kritzefitz> Ah, I had that active in my GHCi session.
02:12:00 <merijn> kritzefitz: MultiparamTypeClasses with values that only include 1 of the types? That's a bad idea asking for lots of working arounds. The relation style typeclass definition makes me suspicious too
02:12:31 <merijn> kritzefitz: Honestly, 90% of all user-defined typeclasses make me suspicious to begin with, because they're rarely things that should be typeclasses
02:13:05 <merijn> And AllowAmbiguousTypes and TypeApplications are both extensions that I'm way to paranoid to ever enable :)
02:15:28 <kritzefitz> The idea here is that the `a` in `FooRel a b` can “contain” multiple different `b`s (each with a different type) and I want to be able to produce a value depending on the `b` by having the `a` and knowing the type of `b`.
02:16:19 <merijn> Yeah, that sounds like a recipe for frustration and painful boilerplate in the long term, tbh :)
02:17:03 <merijn> kritzefitz: I think you'd probably be better of encoding something like that with a mix of DataKinds/TypeFamilies and GADTs than via typeclasses
02:17:03 <kritzefitz> The part that makes this useful (but is missing in my example snippet) is that the type of foo is not actually just `A`, but some reader monad that gives you access to the underlying `b`.
02:17:48 <dminuoso> I find this error still strange.
02:17:52 <merijn> So you'd encode the types "in" A via a type-level DataKinds list and define explicit accessors on those
02:18:48 <dminuoso> Oh I see the mistake.
02:19:24 <kritzefitz> merijn, My actual already encodes the types of the `b`s, but I don't think defining explicit accessors is feasible, as the `b`s themselves are variable.
02:19:48 <kritzefitz> *My actual `A` already encodes...
02:21:02 <kritzefitz> So it's actually something like `A (bs :: [*])`, but then I need `FooRel` to ensure that the `b` I'm looking for is in `bs`.
02:21:14 <merijn> kritzefitz: That's possible
02:21:42 <merijn> kritzefitz: I even have a gist doing that using closed type families :) https://gist.github.com/merijn/6130082
02:22:11 <merijn> (I should update the line 6 one to use the new custom type error machinery, but this gist predates that)
02:22:48 <merijn> Actually, this gist made me ask ghc-devs to add custom type errors and I was told "no, no one needs that", only to find out two years later someone ended up adding it anyway!
02:24:36 <dminuoso> Here's a question.
02:24:36 <dminuoso> What is 'it' in there?
02:24:47 <merijn> dminuoso: Custom type errors
02:25:09 <merijn> Somewhere around 8.0-8.4 that was added
02:25:09 <dminuoso> Is that an GHCi artifact?
02:25:30 <kritzefitz> dminuoso, You mean in my error message?
02:26:06 <dminuoso> merijn: What do you mean?
02:26:06 <dminuoso>     • Probable cause: ‘it’ is applied to too few arguments
02:26:06 <dminuoso>       In a stmt of an interactive GHCi command: print it
02:26:07 <dminuoso> This suggests it to be some GHCi artifact.
02:26:07 <dminuoso> kritzefitz: Yes.
02:26:17 <merijn> dminuoso: Oh, you were referring to the error, nvm :)
02:27:13 <kritzefitz> dminuoso, I can't find that part in the error I posted.
02:28:19 <kritzefitz> merijn, I would consider using that approach instead, but my `FooRel` is actually just a type synonym for `HasField` from `Data.HList.Record`.
02:28:26 <dminuoso> Oh, it was in my examples then heh.
02:30:34 <dminuoso> kritzefitz: In your case you get the type error because you have, quite frankly, a type mismatch. `foo` is too general, you'd have to do something like `runFoo (foo @B)`
02:32:37 <asheshambasta> I've been playing with These (http://hackage.haskell.org/package/these-0.4.2/docs/Data-These.html#t:These) and I seem to have come up with something I consider unexpected. Is my intuition correct here? https://gist.github.com/asheshambasta/3e4bd09ab18584b910879340e0fffa57
02:35:23 <asheshambasta> However: https://gist.github.com/asheshambasta/3e4bd09ab18584b910879340e0fffa57#file-these-hs-L10-L13
02:36:13 <asheshambasta> This seems very odd to me, so I'm not sure if this is what the author of the library intended. 
02:36:36 <asheshambasta> i.e. the failure accumulation seems biased in a particular direction. 
02:41:45 <MarcelineVQ> can't say for intent, but it matches what's written here https://hackage.haskell.org/package/these-0.7.6/docs/src/Data.These.html#line-374 This on either side stays This
02:42:12 <merijn> asheshambasta: You say "failure", but afaict These has no specific notion of failure
02:43:09 <asheshambasta> merijn: yeah, I'm considering the "left" as some sort of a failure (in my use case as well, and that is what ChronicleT seems to suggest also)
02:44:08 <asheshambasta> in the docs, ChronicleT c m a seems to refer to `c` as some sort of "record", and uses `confess` to add to it. 
02:44:34 <asheshambasta> MarcelineVQ: yeah, there's no discrepancy in the code per se, just that this behaviour seems unintuitive. 
02:46:07 <merijn> asheshambasta: File a ticket? Maybe there's a reason per the laws?
02:47:12 <asheshambasta> merijn: yeah, doing that.
02:47:15 <MarcelineVQ> it is a little weird to me tbh, that This stays this when combined with These but That doesn't stay That when combined with These, but I've not looked close to see why or even used this package :X
02:47:34 <merijn> MarcelineVQ: That makes sense, tbh
02:48:16 <merijn> MarcelineVQ: In apply you can't use the right hand side of "This" to actually build the result with a right hand side "These"
02:48:48 <merijn> MarcelineVQ: Keep in mind the functor is on the 2nd type variable, i.e. the one in That and These
02:48:50 <MarcelineVQ> Ah right the a is 'strucutural'
02:49:14 <merijn> But I think aggregating errors across <*> is still lawful an more sensible
02:49:23 <merijn> oh!
02:49:26 <typetetris> hakyll isn't on stackage any more?
02:49:36 <merijn> asheshambasta: I know why it's like that!
02:49:42 <kritzefitz> dminuoso, but then I don't get, what the difference between `(forall b. FooRel A b => A) -> A` and simply `A -> A` is.
02:49:55 <merijn> asheshambasta: Same reason Async doesn't have a Monad instance
02:50:18 <merijn> asheshambasta: If "These" aggregated across <*> then <*> would differ from "ap" in Monad
02:50:50 <merijn> asheshambasta: And it's generally considered bad to have a mismatch between Monad and Applicative instances, for obvious reasons
02:51:19 <MarcelineVQ> typetetris: It's on there. If you're asking why it's not on the latest resolver, it may have not been updated by whoever's maintains its stackage membership/status/some-appropriate-word
02:52:11 <merijn> Most likely, Hakyll depends on something that has been dropped from Stackage (because it wasn't updated)
02:52:34 <typetetris> MarcelineVQ: Thanks. It's just not searchable with hoogle.haskell.org atm, which is unfortunate :(
02:53:18 <__monty__> merijn: Stackage wouldn't drop any dependents if dropping something?
02:53:30 <merijn> typetetris: It is, you just gotta manually add the package to search
02:54:13 <merijn> __monty__: I don't see how they could NOT do that. Having a package in a snapshot that depends on something not in the snapshot would defeat the entire point of stackage/stack
02:54:40 <typetetris> merijn: How do I do that? The dropdown menu usually set to set:stackage doesn't offer hakyll .
02:54:48 <merijn> OTOH, my own package magically appeared in some stack LTS/snapshot and then disappeared and god knows why
02:55:10 <__monty__> merijn: Ah, assumed hakyll was in stackage.
02:55:56 <merijn> __monty__: It's no longer in stackage as of the latest LTS, I was just offering a possible cause
02:56:06 <merijn> typetetris: hmm, I recall that was possible, but don't remember how
02:56:18 <asheshambasta> merijn: hm, I see; I was using this for accumulative error json parsing. 
02:58:55 <mniip> if I configure GHC with --prefix=/foo/
02:59:03 <mniip> shouldn't ghc packages be installed somewhere under /foo/ ?
03:02:07 <MarcelineVQ> typetetris: wait what is not happening for you, what are you typing into the search bar and what are you expecting to see?
03:02:49 <MarcelineVQ> per your original issue, not what you're trying now
03:03:01 <typetetris> into the search bar I type "idRoute" and expect a hit in the hakyll package, which doesn't show up.
03:05:06 <MarcelineVQ> alright yeah, nothing useful found there. as something useful to add though if you know what package you need you can go to that package and press 's' on the page itself (not the search bar at the top) to search within the package
03:05:55 <MarcelineVQ> not quite as general a search but a useful thing to have, especially as a fallback
03:06:52 <typetetris> Where should I press 's'? on hoogle.haskell.org?
03:06:53 <MarcelineVQ> so like https://hackage.haskell.org/package/hakyll press 's', not in the search bar at the top (which stupidly focuses), type in what you're looking for
03:07:28 <typetetris> woa
03:07:37 <typetetris> Why isn't that advertised bigger somewhere.
03:07:44 <MarcelineVQ> right? it's a little silly
03:07:53 <typetetris> That is a cool feature of hackage I didn't know about.
03:08:06 <MarcelineVQ> especially since the search bar gets focused so you're fairly unlikely to stumble onto it
03:27:01 <__monty__> Yeah quickjump's pretty cool.
03:33:41 <mniip> it's not a feature of hackage
03:33:46 <mniip> it's a feature of haddock
03:43:06 <merijn> And the main reason it isn't advertised is that it isn't the default setting yet, afaik?
03:43:21 <merijn> I've just been building docs myself to get it for my packages
03:54:30 * hackage github-webhooks 0.10.1 - Aeson instances for GitHub Webhook payloads.  https://hackage.haskell.org/package/github-webhooks-0.10.1 (onrock_eng)
04:08:54 <mniip> hpc, apparently scientific-constants has a *very* old base constraint
04:14:15 <lortabac> asheshambasta: I think this applicative is more similar to what you are looking for http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Applicative-Lift.html#t:Errors
04:15:06 <hpc> oh, i see
04:15:24 <asheshambasta> lortabac: ah, thanks 
04:15:40 <lortabac> asheshambasta: https://teh.id.au/posts/2017/03/13/accumulating-errors/
04:16:11 <phadej> http://hackage.haskell.org/package/either-5.0.1/docs/Data-Either-Validation.html
04:17:49 <bahamas> hello. I'm working with language-python's Statement and Expr data types and I want to avoid displaying the annotations found on the nodes. the ones here https://github.com/bjpop/language-python/blob/98958701b6825e90bb4dbea9372dcee1eab92f2a/src/Language/Python/Common/AST.hs#L209. is there a way to do that?
04:18:43 <phadej> :t void
04:18:45 <lambdabot> Functor f => f a -> f ()
04:19:13 <phadej> will make all annotations ()
04:19:20 <phadej> it's still something, but not as bad
04:20:40 <bahamas> phadej: I use as fmap void statements?
04:20:45 <bahamas> *use it
04:22:12 <phadej> void = fmap (\_ -> ())
04:22:55 <asheshambasta> lortabac: nice, thanks
04:23:45 <asheshambasta> However, I've wrapped the `These c a` inside a newtype and modified its Applicative instance to be different than the one supplied by the library. 
04:24:19 <asheshambasta> I'm not sure if thats the most rigorous way going forward; moreover in my json validation stack, I'm using ChronicleT, which needs to operate on top of These 
04:24:45 <bahamas> phadej: do I have to pattern-match every value constructor? maybe there's a way around this using generics?
04:26:31 <phadej> bahamas: simply `void topLevelStatement`
04:26:38 <phadej> no need to recurse, or anything
04:28:54 <bahamas> phadej: that worked. thank you!
04:32:25 <bahamas> another related question. is there a way I can just get the value constructor and ignore its fields?
04:33:28 <merijn> bahamas: You can use record syntax (even for non-record datatypes!)
04:33:50 <merijn> > [x | x@Left{} <- [Right True, Left 'a', Right False, Left 'c']]
04:33:52 <lambdabot>  [Left 'a',Left 'c']
04:35:15 <bahamas> merijn: can I get away with not pattern matching against the constructors? there's a lot of them https://github.com/bjpop/language-python/blob/98958701b6825e90bb4dbea9372dcee1eab92f2a/src/Language/Python/Common/AST.hs#L205
04:37:16 <merijn> bahamas: That depends on what you wanna do?
04:37:40 <bahamas> merijn: I want to get a count of all the value constructors in some code I'm parsing
04:38:14 <merijn> If they don't implement some kind of traversal/whatever over the AST, then no you can't avoid it
04:38:31 <bahamas> merijn: well, I've forked language-python, so I could add that myself
04:39:08 <bahamas> is it enough to just add derive(Traversable) or do I need to also handle the actual implementation?
04:39:36 <merijn> It Depends (TM)?
04:50:54 <bahamas> universe from the uniplate library gives me a list of all the nodes. can I apply some transformation and get just the constructor name from that? maybe there's another uniplate function that does that?
04:54:35 <_deepfire> hvr, mpickering: re hackage.headhttps://github.com/hvr/head.hackage/issues/98
04:54:48 <_deepfire> hvr, mpickering: re hackage.head: https://github.com/hvr/head.hackage/issues/98
04:58:03 <lyxia> bahamas: how about toConstr
05:01:08 --- mode: ChanServ set +o Sigyn
05:10:30 <mpickering> _deepfire: I still don't understand that well
05:11:21 <mpickering> Is this to override packages the nix way as well as with patch files?
05:11:56 <bahamas> lyxia: that works. thank you!
05:14:38 <mpickering> _deepfire: So I don't understand the point as the script generates something you can compose with another extension
05:14:46 <mpickering> so if you have some more overrides you don't need these arguments
05:54:07 <statusfailed> which version of ghc added containers-0.5.8 ?
05:54:54 <statusfailed> (or: how do I figure it out)
05:55:34 <agander> https://www.stackage.org/package/containers/snapshots
05:56:29 <agander> found by clicking "See all snapshots containers appears in" on the stackage entry for containers
05:56:58 <Taneb> statusfailed: by browsing GHC user guides it was beteen 8.0 and 8.2
05:58:38 <agander> hmm I am wrong, it doesnt show it :(
05:58:44 <statusfailed> Taneb: ah ok, I saw it was at most 8.2 from the release notes, but wasn't sure if there was a better way
05:58:47 <statusfailed> thanks
06:06:44 <lortabac> hello, does anybody know if there is a Haskell adapter for Keycloak? (https://www.keycloak.org/)
06:11:01 <merijn> GHC release notes and user guide list the version of packages released with it
06:21:03 <mpickering> _deepfire: I still don't understand why this is necessary!
07:28:59 * hackage mono-traversable-keys 0.1.0 - Type-classes for interacting with monomorphic containers with a key  https://hackage.haskell.org/package/mono-traversable-keys-0.1.0 (recursion_ninja)
07:50:25 <aplainzetakind> ghcid output is constrained to the window height. Is it not possible to scroll?
07:56:15 <__monty__> aplainzetakind: I haven't found a way. Also doesn't gracefully resize the used area when I resize the tmux split.
08:00:59 * hackage cabal2nix 2.14.1 - Convert Cabal files into Nix build instructions.  https://hackage.haskell.org/package/cabal2nix-2.14.1 (PeterSimons)
08:02:15 <dmwit> If you want to scroll because there's too many success messages to see the failures, perhaps you can use a command that filters out the stuff you don't care about.
08:09:08 <typetetris> can someone help me with hakyll? I want to transform a bunch of markdown files with pandoc and combine the result, with the getting the intermediate files in my _site. 
08:13:45 <lyxia> typetetris: did you follow the hakyll tutorial
08:14:18 <lyxia> typetetris: have you asked on #hakyll
08:14:30 * hackage mmtf 0.1.1.0 - Macromolecular Transmission Format implementation  https://hackage.haskell.org/package/mmtf-0.1.1.0 (zmactep)
08:15:25 <Welkin> it looks like the protocol buffers libraries in haskell are pretty far behind
08:16:00 <Welkin> they don't support version 3.x which has been out for over 2 years
08:18:08 <Welkin> haskell is officially supported by thrift, which is nice
08:23:50 <typetetris> lyxia: I asked on #hakyll so far no answer. I followed the tutorial. But what I want to do now isn't covered by the tutorial.
08:24:52 <Welkin> hakyll is not the easiest library to use, and if you want to do anything custom, you'll need to dig into the internals to figure it out. But for a basic blog it should be really easy to set up
08:25:17 <Welkin> I use racket's pollen for static site generation instead
08:25:52 <Welkin> it let's me write my own markup language and is very flexible
08:26:04 <Welkin> lets*
08:28:27 <lyxia> typetetris: how are your files organized
08:28:32 <yushyin> Welkin: sounds nice.
08:30:56 <dmj`> functors, monads, applicatives, oh my
08:31:05 <typetetris> lyxia: I have a folder "snippets/*.markdown". Each files should be converted to html by pandoc and end up in an "<li></li>" element of a list. There should not be "snippets/*.html" files in _site somewhere.
08:31:16 <tsahyt> how would I go about forking off a new process from a haskell program? Ideally I'm looking for something similar to forkIO but instead of using threads I need it to spawn a new process
08:31:38 <dmj`> tsahyt: System.Process from the process package
08:32:00 <dmj`> :t createProcess
08:32:01 <lambdabot> error: Variable not in scope: createProcess
08:32:03 <Welkin> why would you want to spawn an OS process instead?
08:32:04 <dmj`> http://hackage.haskell.org/package/process-1.6.5.0/docs/System-Process.html
08:32:36 <tsahyt> dmj`: that looks closer to system in C rather than fork
08:32:37 <typetetris> lyxia: Now I have a "match "snippets/*"" thingy which convert them by pandoc and a match for the page combining them, constructing a context from loadAll. But the intermediate files also land in _site. 
08:33:08 <dmj`> tsahyt: you can use it with forkIO
08:33:35 <kritzefitz> typetetris, then you probably define a route in you rule for snippets/*. When you remove that the files should not end up in _site.
08:33:55 <Welkin> what is the benefit of spawning an OS process?
08:34:01 <kritzefitz> typetetris, don't forget to clean out you _site before checking if they are still there, because hakyll won't remove them if they are already there.
08:34:41 <tsahyt> Welkin: separate address spaces, I'm working with some C libraries underneath
08:36:13 <tsahyt> I'm getting some segfaults and have no real clue why, the code that I'm writing is really a mockup for a distributed system to begin with, so all communication between nodes (modelled as threads atm) runs via sockets already anyhow. but I'm running into some problems, and I want to see whether it's related to threading
08:36:29 <tsahyt> dmj`: what would that look like?
08:38:18 <kritzefitz> tsahyt, There is forkProcess in System.Posix.Process from the unix package.
08:38:44 <tsahyt> that looks about right, thanks
08:38:46 <tsahyt> I'll give it a go
08:40:27 <dmj`> main = doSomeThings >> (forkIO $ print =<< waitCatch =<< do async (system "ls -lah")) >> doOtherThings
08:42:27 <typetetris> kritzefitz: Thanks will try that!
08:44:54 <gentauro> dmj`: that looks like F# syntax for `async`
08:45:00 <gentauro> amirite?
08:46:53 <tsahyt> kritzefitz: that worked, and I can no longer reproduce the segfaults I was getting, so it seems like that was indeed the problem
08:46:59 <Solonarv> similar perhaps, but in Haskell it's just a library
08:47:02 <Solonarv> @hackage async
08:47:03 <lambdabot> http://hackage.haskell.org/package/async
08:47:21 <Solonarv> no special syntax involved.
08:47:54 <kritzefitz> tsahyt, huh, normally Haskell threads shouldn't just segfault :/
08:48:38 <Welkin> if you are using the c ffi there is no safeguard
08:48:59 <kritzefitz> Right
08:49:08 <tsahyt> yea, there are two C libraries underneath that I rely on
08:49:14 <kritzefitz> I see
08:49:15 <tsahyt> and for one of them, I'm using my own shoddy bindings :/
08:49:30 * hackage retry 0.8.0.0 - Retry combinators for monadic actions that may fail  https://hackage.haskell.org/package/retry-0.8.0.0 (MichaelXavier)
08:49:36 <Welkin> try writing them in rust
08:49:40 <Welkin> then you won't get segfaults
08:49:59 <tsahyt> Welkin: if I was to rewrite them I'd just rewrite them in Haskell instead
08:50:13 <kritzefitz> Maybe they use thread local storage? In that case using forkOS might fix the segfaults.
08:50:36 <tsahyt> hm
08:50:39 <tsahyt> I should have tried that first
08:51:10 <tsahyt> nope
08:51:16 <tsahyt> just got a segfault with forkOS
08:51:41 <Welkin> why is it segfaulting in the first place?
08:51:55 <Welkin> that sounds bad
08:52:35 <tsahyt> I'm not sure, and I haven't been able to conjure up a minimal example either. it's usually segfaulting in some std::vector code. (the C bindings are really binding to C++ code internally)
08:53:40 <tsahyt> the backtrace is also less than helpful
08:54:25 <tsahyt> here are the bindings that I use, just in case someone has way too much time on their hands. there are a few open issues but they generally work well enough for my use cases. https://github.com/tsahyt/clingo-haskell
08:55:04 <tsahyt> unfortunately I don't have the time to investigate this more deeply, I need to first get this prototype running, deadlines and all that
08:58:17 <nvt> any idea what could be wrong with this http://paste.dy.fi/INv - i'm trying to add the value 2 to the key 10 in the tree, so that in the end in this case I would have one root node with key 10 and list [3,3,3,2] on it
09:00:16 <lyxia> nvt: you're putting lists in your nodes, but there is no list in Tree k vs
09:02:14 <hololeap> Compiling Tests.Vector ... 10.3 GB of RAM usage and counting...
09:03:14 <hololeap> it finally got past that... i wonder why it needs so much RAM to compile that module
09:03:33 <gentauro> how people without `strong types` work -> https://twitter.com/shanselman/status/1090321856635101185
09:03:36 <gentauro> :| 
09:12:21 <[Leary]> nvt: Give treeInsert a type signature, and decide whether the second thing in the tuple it gets is a `t` or a `[t]`. The way you're using it on line 8 vs the other lines is inconsistent.
09:24:41 <DasBrain> Ok, I wrote a Brainf*ck interpreter in haskell in a very basic way: https://ideone.com/9HXyob Logic is implemented using pattern matching, but I believe I could make this more readable.
09:25:06 <DasBrain> And learn a few new techniques.
09:26:42 <nvt> lyxia: yeah the vs needs to be [vs] everywhere
09:26:47 <nvt> -lyxia
09:28:29 * hackage teardown 0.5.0.1 - Build safe and composable teardown sub-routines for resources  https://hackage.haskell.org/package/teardown-0.5.0.1 (RomanGonzalez)
09:28:45 <nvt> so I can't just call it like treeInsert (10, "test"), but should call it like treeInsert (10, ["test"]) (Node (10,["test"] EmptyTree EmptyTree) instead
09:28:56 <nvt> the signature should be treeInsert :: Ord k => (k, [vs]) -> Tree k [vs] -> Tree k [vs]
09:29:44 <DasBrain> :info Monoid
09:33:05 <[Leary]> nvt: Then what you're doing on lines 10 and 11 is wrong; wrapping the supplied list in square brackets produces a list of lists.
09:33:12 <nvt> yes
09:33:21 <nvt> but that data Tree I should not change I gess
09:33:23 <nvt> it's just fine
09:35:09 <nvt> at least without the whole treeInsert I could just run singleton (10,["test"]) EmptyTree EmptyTree without any errors
10:03:13 <hololeap> DasBrain: i think it is a little cleaner if you use LambdaCase like so: http://dpaste.com/17A162D
10:03:54 <hololeap> but there's probably a lot of different angles you could take for cleaning it up further
10:06:15 <DasBrain> I don't see why this should be an improvement.
10:08:31 <hololeap> it's a matter of taste
10:08:43 <lyxia> because you don't type the same function and argument names 10 times
10:08:44 <wroathe> IMO LambdaCase isn't that big of an improvement
10:09:06 <wroathe> It's convenient, but only slightly so
10:09:47 <boj> not having to declare a useless intermediate term is nice
10:10:33 <lyxia> oh nvm you still retype the arguments with LambdaCase, I was thinking of plain case.
10:16:34 <Solonarv> I'd suggest first doing a pass over the input turning it into an AST
10:16:55 <Solonarv> this would also let you detect e.g. mismatched [/] early
10:25:45 <wroathe> So I spent a bunch of time getting HIE set up with vscode early on because I wanted hover to show me the types of things. I'm finding I'm using that FAR less often than :t in ghci
10:26:04 <wroathe> So there appears to be some wisdom behind the way you old pros do things
10:29:14 <fresheyeball> sclv: I am around today
10:30:14 <c_wraith> wroathe, coming from an old guy in an attempt to be fair... type-at-point is more useful for reading code than writing.
10:31:23 <tabaqui> How can I get windows version at runtime?
10:33:24 <tabaqui> oh, nevermind :)
10:33:42 <tabaqui> I can use hSupportANSI function and others
11:01:32 <iqubic> I want to learn about the Cont monad and Call/CC
11:01:44 <iqubic> What resources exist to aid me in my quest?
11:02:05 <tabaqui> Stay away from Cont monad :)
11:02:26 <tdammers> tee hee
11:03:41 <Welkin> https://en.wikipedia.org/wiki/Call-with-current-continuation
11:03:48 <tabaqui> https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
11:04:00 <Welkin> learn about it through scheme
11:05:19 <tabaqui> Anyway, don't use it in shared space, CPS code is write-only
11:05:23 <wroathe> I read through that a while ago, and the thing that stood out to me is that it's basically the "callback" concept from Javascript. 
11:05:29 <wroathe> Am I right about that?
11:05:47 <tabaqui> not actually
11:06:14 <tabaqui> it is callbacks that are first order objects
11:06:21 <wroathe> In the sense that you're providing a function to a higher order function that handles the result of a computation eventually
11:06:30 <zachk> could you do cooperative multitasking/coroutines with the Cont Monad?
11:06:57 <tabaqui> and you can call continuation in somewhere different place
11:07:21 <Solonarv> well, Cont doesn't do any concurrency/parallelization, but you can certainly get concurrency with ContT over IO
11:07:35 <Solonarv> er, write concurrency primitives that way
11:07:42 <Solonarv> it's really hard to reason about though
11:08:31 <Solonarv> ContT is the spawn of the devil tbh
11:08:42 <Solonarv> CodensityT is slightly better-behaved
11:09:11 <dminuoso> Solonarv: What is CodensityT?
11:09:28 <wroathe> You could write most pure code in terms of ContT, but then someone might decide to put you out of your misery on behalf of the greater good
11:10:10 <Solonarv> newtype CodensityT m a = CodensityT { runCodensityT :: forall x. (a -> m x) -> m x }
11:10:12 <Solonarv> (IIRC)
11:11:20 <nshepperd1> That's normally just called Codensity
11:12:33 <Solonarv> oh, indeed
11:12:59 <Solonarv> https://hackage.haskell.org/package/kan-extensions-5.2/docs/Control-Monad-Codensity.html
11:13:08 <DasBrain> Why is CPS code write-only? And why should you stay away from the Cont monad?
11:13:30 <DasBrain> (should I implement it myself instead, so it's not the Cont monad?)
11:15:14 <geekosaur> try writing some, then making sense of the result
11:15:36 <Solonarv> the problem with CPS is basically just that it's hard to reason about (which extends to the Cont monad and the ContT transformer)
11:15:45 <geekosaur> CPS is the sort of thing you hide inside compilers so you don't have to deal with it directly (unless you maintain the compiler)
11:16:05 <Solonarv> the monad and the corresponding transformer also lack many nice properties that other monads/transformers have
11:16:29 <Solonarv> also: GHC doesn't actually use CPS for its intermediate representation! which is pretty cool :P
11:23:11 <Amras> anyone here familiar with Yampa that can help me get to grips with how FRP game logic is supposed to work, how to get a delta-time for each step, and what the hell reactimate is trying to do?
11:23:46 <Amras> I'm reading through the examples, diagrams, and documentaiton and it is just making no sense
11:38:05 <boj> Amras: are you familiar with Haskell in general? if so, how about Arrows?
11:39:15 <dmwit> "Should I implement [Cont] myself instead, so it's not the Cont monad?" A Cont by any other name...
11:40:16 <Amras> boj: fairly familiar with  haskell; I've made at least one gamejam game with sdl2 and a few projects beyond that. Arrows I've read up on and I understand them. I've also watched/read Conal Elliot's stuff and the Elm guy's talk
11:41:06 <tabaqui> Amras: Here is the brilliant introduction in game logic based on FRP
11:41:08 <tabaqui> https://dl.acm.org/authorize.cfm?key=N08599
11:41:20 <tabaqui> SpaceInvaders on Yampa
11:41:33 <boj> Amras: back when i experimented this video was quite helpful in understanding how to use Yampa primitives https://www.youtube.com/watch?v=T7XwTolu9YI
11:41:47 <iqubic> So, how about that Cont Monad and CallCC?
11:42:24 <iqubic> How shall I go about learning what it is, and how it workd
11:43:26 <conal> Amras: You won't find time delta in my FRP work, because it doesn't fit the FRP semantic model. (Also, "Elliott" with two "t"s.)
11:43:48 <Amras> sorry about that!
11:43:52 <Amras> I'm awful with names
11:44:27 <conal> Amras: No problem. I didn't use to mention it, but the single "t" misspelling seems to be contagious.
11:44:38 <systemfault> I wish there would be a less than 100 lines, single file, mini FRP lib just to show how its done.
11:44:52 <conal> Amras: (as do FRP misunderstandings)
11:45:14 <boj> we have bastardized your work conal, all is lost :)
11:45:34 <_deepfire> Reflex is a practical Haskell FRP implementation that people use in production.
11:45:38 <Amras> I only mentioned dt because the Yampa examples I was reading through all seemed based on a "game tick" model, rather than operations on behaviors
11:46:03 <tabaqui> It is not necessary
11:46:11 <tabaqui> Yampa implements push-based FRP
11:46:12 <conal> boj: some day, the truth will resurface! for now, software engineering and computer science seem to be in a dark ages of operational thinking.
11:46:28 <tabaqui> I use it at work, it handles buisness logic
11:46:28 <Amras> it was my intuition that dt *should* be unneccessary, I just saw it used so I figured i'd ask about it
11:46:33 <_deepfire> Reflex implements both push (events) and pull (behaviors), as well as their combination (event+behavior, Dynamic)
11:46:33 <boj> conal: one day indeed!
11:46:49 <iqubic> So what is the best way to get started with the Cont Monad?
11:47:06 <dminuoso> iqubic: Getting a feeling for CPS first.
11:47:10 <conal> boj: :)
11:47:24 <tabaqui> iqubic: read the two articles above and try to write some application with Cont
11:47:27 <_deepfire> conal: by the way, what is your opinion on Reflex?
11:47:34 <iqubic> dminuoso: I do have a feeling for how to use CPS.
11:47:57 <dminuoso> iqubic: If I told you to implement some simpler algorithm in CPS, could you do it?
11:48:15 <iqubic> tabaqui: I logged out due to spotty internet.
11:48:18 <iqubic> dminuoso: Yes,
11:48:34 <tabaqui> https://en.wikipedia.org/wiki/Call-with-current-continuation
11:48:36 <iqubic> tabaqui: I don't have the links for those two articles.
11:48:37 <conal> _deepfire: last i looked, Reflex abandons both fundamental properties of FRP. (https://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language#5878525)
11:48:40 <tabaqui>  https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style 
11:49:04 * tabaqui is afk
11:49:12 <_deepfire> conal: thank you!
11:49:21 <iqubic> dminuoso: Do you want to test me and see the limits of my knowledge?
11:49:49 <iqubic> I understand how CPS things work, and can write simple things with CPS.
11:49:50 <conal> _deepfire: you're welcome. i've had a few conversations with Ryan about these principles, and he seemed interested in trying, but i've not seen any progress.
11:50:39 <iqubic> :t \x -> ($ x)
11:50:40 <lambdabot> a -> (a -> b) -> b
11:50:58 <iqubic> And that's the type of a simple computation.
11:51:21 <_deepfire> conal: another question, then, what of the existing FRP implementations you would consider having both properties -- but also, practical to use?
11:51:22 <conal> trying to retrofit denotation into an operationally-motivated design usually suggests fundamental changes/improvements (very helpfully!), but not everyone wants to go there. so i recommend focus on denotation at the start of the design process.
11:52:53 <conal> _deepfire: i don't think there are any such implementations any longer. my early Fran implementation was crazy fast even running on Hugs (often hundreds or thousands of fps on a 1999 PC), and it was correct (faithful to the specification/denotation).
11:52:55 <_deepfire> (sorry about handwaving with this "practical" word -- without going into details, I'd any interpretation you choose)
11:53:35 <_deepfire> conal, that sounds shocking!
11:55:59 <_deepfire> Fran is not on Hackage.. that feels sad..
11:57:36 <phadej> _deepfire: reflex comes from pragmatic need to interact with HTML constructs. As far as I understand, Fran would force you to use canvas for all your site
11:58:02 <phadej> (or GTK or whatever, not as primitive as pixels on the screen)
11:59:11 <_deepfire> conal: another question (sorry for jumping on you all of a sudden..) How much collaboration was between you and Yampa authors?
11:59:16 <conal> _deepfire: The Fran Haskell sources are still around, but the low-level graphics stuff has long since bit-rotted. I now have an easy way to do crazy fast GPU-based graphics and much deeper optimization (both via compiling-to-categories), so it might be a good time for someone to recreate a simple, correct, and playful FRP implementation.
12:00:26 <conal> _deepfire: not much. antony & i started the exploration (http://conal.net/papers/genuinely-functional-guis.pdf), and then the Yale folks took it from there.
12:00:27 <_deepfire> conal, sounds interesting..  I've been playing with using Reflex + Lambdacube3d (which is a pure-functional GPU pipeline driver, like GPipe), but never got down to FRP implementation details
12:01:15 <_deepfire> conal: I asked because https://wiki.haskell.org/Yampa -- yet you didn't mention it as being faithful
12:01:28 <conal> _deepfire: sounds fun. 
12:02:09 <_deepfire> er, I asked because https://wiki.haskell.org/Yampa says "Yampa was originally developed by the Yale Haskell Group based on the original idea of Conal Elliott's Fran."
12:02:27 <_deepfire> So it was "based on", yet somehow managed to lose the concept..
12:02:53 <conal> _deepfire: yeah. ivan and I talk, and he knows my concerns about the aspects of Yampa that cannot agree with the semantics.
12:03:30 <iqubic> :t callCC
12:03:32 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
12:04:19 <wroathe> Anyone know of a terminal command that will print the export list for a module?
12:05:19 <Amras> sed -n -e '/(/,/)/ p'?
12:05:30 <wroathe> I mean with type signatures
12:06:00 <Amras> | grep $f | grep "::"?
12:06:02 <Amras> >_>
12:06:06 <conal> _deepfire: i don't think anyone has really gotten the semantics of interactivity (in general terms---in time, space, etc) right. fran was faithful to its simple denotation, but it has some fundamental usability issues (not any of the issues i hear discussed). i've been chatting with Steve Krouse lately, and maybe i'll get inspired to dive back in at some point.
12:06:43 <Solonarv> wroathe: :browse does that in ghci
12:06:58 <Solonarv> %% :browse Data.Function
12:06:58 <yahb> Solonarv: http://qp.mniip.com/y/0
12:07:27 <wroathe> Yeah, I just realized I can echo ":browse foo" to ghci to do what I want
12:07:29 <wroathe> Thanks
12:08:06 <Solonarv> you can even invoke: ghci -e ':browse Data.Function'
12:08:45 <_deepfire> conal, just above, a screenful back, phadej mentioned that Fran would've forced defining the visual output as a functional composition of pixels, does that sound right?
12:08:58 <Amras> It struck me that the problem of a "good" FRP implementation has been floating around for almost a decade now
12:09:05 <Amras> at least, based on my google searches
12:09:37 <_deepfire> phadej, also, did I manage to avoid distorting your statement too much? : -)
12:09:37 <Amras> stack overflow questions of that nature haven't really changed their content in that time
12:09:46 <wroathe> Solonarv: That's exactly what I wanted. You rock.
12:10:26 <Amras> boj: thanks for the yampy link, things are starting to click together in my head
12:10:40 <Solonarv> wroathe: note that you'll get qualified names that way
12:10:57 <Solonarv> (er, depends on how the module is imported)
12:11:53 <conal> _deepfire, phadej: Fran would have worked fine with something structured such as HTML. I got my crazy high performance by doing something similar with a retained-mode sprite engine and exploiting continuous time (http://conal.net/papers/padl99/).
12:14:08 <conal> _deepfire, phadej: people often conflate frp with some particular implementation strategy (thus missing the essence) and so come to false conclusions. instead, by defining it as a precise denotation without operational biases, one gets tremendous implementation freedom, which then enables outstandingly efficient implementations.
12:15:00 <_deepfire> conal: by the way, the "extended version" link on that page seems dead..
12:15:11 <johnw> conal: that whole sentence, replacing frp with '____', works very nicely :)
12:15:12 <conal> in contrast, efficiency-driven operational designs end up being relatively inefficient, because they can never transcend their operational assumptions, which are ultimately limiting. discreteness in space and time are examples.
12:15:56 <conal> johnw: exactly! :D the principle applies to all programming. especially nowadays, when performance comes from massive parallelism.
12:16:12 <conal> _deepfire: thanks! i'll replace that link. 
12:16:40 <phadej> conal: it would be very enlightning, if some paper didn't talk about "Picture" as outputs
12:17:01 <conal> phadej: ??
12:17:38 <phadej> conal: it's easy to get an impression that your FRP ideas are as is applicable only to animations
12:18:22 <iqubic> so CallCC sorta functions a goto statement of sorts.
12:18:25 <phadej> people want to make buttons and editboxes in their GUIs, but don't want to code the buttons themselves
12:18:43 <conal> phadej: i always thought of "animation" in much more general terms as anything that varies with time. but yeah, that word has been a source of misunderstanding. :/
12:19:16 <Solonarv> iqubic: that's a very apt comparison; they're similarly powerful, similarly unconstrained, and similarly hard to reason about
12:19:46 <conal> phadej: ideally (for me), the semantic model of GUIs can still be in terms images but the implementation can use sophisticated tools.
12:19:56 <iqubic> Solonarv: do you recommend using the Cont Monad at all?
12:20:19 <Solonarv> I can't think of situation where I'd want to use it, but that doesn't mean it doesn't exist
12:20:29 <phadej> conal, yes if there's some notion of "button image" primitive, I don't see why it couldn't work.
12:20:36 <conal> phadej: going down this path would reveal that their GUI toolkits could be redesigned much more compositionally!
12:21:09 <conal> phadej: ... with well-defined semantics (and thus rigorously predictable) even!
12:21:23 <iqubic> GUI toolkits are always a pain to use in my opinion.
12:22:17 <Amras> I think the thing I struggle most conceptually is keeping the semantics of a Time -> a function laying around while responding to user inputs in the same computational cycle
12:22:52 <Amras> I understand the benefits it gives denotationally but it's also really weird to wrap my head around
12:22:59 <phadej> not holding my breath that UIKit or GTK will get resigned with well-defined semantics
12:23:16 <Amras> I agree that GUI is a pita
12:23:48 <phadej> Amras: continuos time makes you forget an idea of "next frame"
12:24:19 <phadej> and when you get your head around that, you'll ascend ;)
12:24:27 <Amras> I think I saw a (python) project recently that converts console interfaces to an HTML form so you get a GUI for almost-free
12:24:44 <Amras> but obviously that doesn't solve the problem, just hides it
12:24:52 <conal> phadej: me neither! we could start over, however, building on denotation, GPU-code generation, and compililng-to-categories (for ideal API and optimizability) and start a whole new generation of GUIs. it'd be a big effort but could yield astounding new abilities.
12:25:05 <conal> phadej: :)
12:27:33 <phadej> conal: any way to connect that to blockchains or something where the money is right now?
12:27:45 <Amras> lol
12:27:50 <phadej> sad truth
12:28:05 <phadej> well-working GUIs won't make you rich
12:28:18 <phadej> at least not obviously
12:28:57 <conal> _deepfire: i'm struggling with my old darcs-based papers repo, but that extended version of the high-performance sprite-based frp paper is at http://conal.net/papers/padl99/tr-98-28.ps
12:28:57 <arsdragonfly[m]> hey, I'm trying to install xmobar with all extensions but alsa-mixer fails to compile with some errors on c2hs
12:29:01 <arsdragonfly[m]> https://paste.ubuntu.com/p/gQVhT2q74H/
12:29:07 <arsdragonfly[m]> here's the log
12:29:29 <Amras> I mean, if you can promise better efficiency to a bitcoin miner they'd save a ton on overhead
12:30:06 <conal> phadej: indeed, johnw and i are exploring how to apply the methodology (denotational design) to blockchain!
12:30:31 <Amras> I feel like you could fiddle around with more robust machine learning models, add a few layers before you hand your data into the matrices
12:30:40 <phadej> conal: i see, concat is also targeting AI people with AD; clever!
12:30:55 <Ericson2314> phadej: are you at dfinity now to?
12:30:57 <conal> everything i've seen in the blockchain space has been highly operational, so it's not at all clear what it's fundamentally about.
12:31:04 <Ericson2314> *oo
12:31:11 <phadej> Ericson2314: no, why you think so?
12:31:51 <Ericson2314> because @johnw is 
12:31:59 <conal> phadej: yeah. AD and machine learning in general is another area where operational thinking has left a terrible mess, including thinking in terms of graphs. (also arrays, but that's a different issue.)
12:32:03 <phadej> Ericson2314: conal said "john and i", not me
12:32:27 <Ericson2314> oh sorry my brain is permuting things
12:32:33 <phadej> Ericson2314: no worries
12:33:17 <Ericson2314> (Maybe I should get this client to use more colors too)
12:34:29 * hackage pandoc-citeproc 0.16 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.16 (JohnMacFarlane)
12:34:50 <phadej> Ericson2314: nickcolor.pl ftw
12:37:11 <Ericson2314> well I'm in the stock matrix client so it's nickcolor.css for me for now hehe
12:37:22 <_deepfire> conal: thank you!
12:37:46 <conal> :)
12:38:40 <phadej> I'm stuck with 10 years old irssi
12:39:21 <conal> _deepfire: thank you for pointing out the broken link! page fixed now.
12:43:16 <untseac> hello. is real world haskell still relevant or is it too old by now?
12:46:45 <codedmart> Hoogle isn't helping much how do I go from `[(a, [b])] -> ([a], [b])`
12:47:16 <codedmart> Or at least my hoogle foo is failing me. I though there was something for this already.
12:48:13 <aplainzetakind> taverse id . fmap swap
12:48:19 <aplainzetakind> traverse*
12:48:45 <aplainzetakind> ah and then another swap
12:49:28 <aplainzetakind> traverse id is just sequence of course.
12:49:44 <aplainzetakind> so `swap . sequence . fmap swap`
12:57:31 <Amras> boj: I think I got it stuck in my head that for such a simple project I should be able to stick to first-order FRP (per Czaplicki's taxonomy) and then I might be able to experiment with some of the resulting features - but it seems like switches actually help a lot with cleanliness when handling user input
13:06:07 <phadej> untseac: still is, basic Haskell havent' changed since. The "real world" part is outdated, as many ideas are actually implemented as libraries on Hackage; but it still valuable to understand how they work
13:09:01 <untseac> phadej, thanks. rwh can be complicated but it's free and I learned a lot so far.
13:27:30 * hackage bitvec 0.1.1.0 - Unboxed vectors of bits / dense IntSets  https://hackage.haskell.org/package/bitvec-0.1.1.0 (Bodigrim)
13:29:51 <pzp> Nomenclature question: association list is to dictionary as _______ is to set?
13:30:22 <hc> list of tuples?
13:30:28 <hc> no, never mind
13:30:43 <dminuoso> pzp: strictly speaking an association list is strictly speaking stronger than a dictionary though.
13:31:15 <dminuoso> s/strictly speaking//
13:31:26 <pzp> dminuoso: *an association list sans duplicate keys
13:32:23 <dminuoso> pzp: association lists are ordered, dictionaries not necessarily.
13:32:29 <Amras> _______ = list then?
13:32:29 * hackage snap-core 1.0.4.0 - Snap: A Haskell Web Framework (core interfaces and types)  https://hackage.haskell.org/package/snap-core-1.0.4.0 (GregoryCollins)
13:33:02 <pzp> dminuoso: true
13:33:13 <pzp> Right now I am calling it a "unique list"
13:34:41 <Amras> association list is ordered and contains multiples - a dictionary is unordered and unique. a unique list is ordered and unique - a set is unordered and unique
13:35:08 <dminuoso> pzp: What's the point you are trying to make?
13:35:27 <pzp> Trying to come up with good naming for a module I am writing
13:36:10 <dminuoso> pzp: What does the module contain?
13:36:51 <pzp> It's a set implemented using a list with the invariant that there are no dups
13:37:23 <Amras> unique-list sounds reasonable
13:37:52 <dminuoso> pzp: If the interface you expose is just a set-like interface, what's wrong with Data.Set?
13:38:49 <dminuoso> Though Data.List.Unique could work too if the point is rather to provide accessories for a unique list.
13:38:57 <_deepfire> conal: some day I'd like to ask you about http://hackage.haskell.org/package/reactive : -)
13:39:03 <pzp> dminuoso: It's mostly for academic purposes. I want to write an implementation and compare runtimes.
13:40:06 <conal> _deepfire: happy to discuss on another day. i'm very excited about my current research/hacking/writing project!
13:41:04 <_deepfire> : -)
13:45:46 <Solonarv> pzp: note that 'containers' is very optimized, so it'll be hard to draw strong conclusions from comparing to it
13:46:25 <Solonarv> unless you invest a similar amount of effort into optimizing your implementation; or perhaps showcasing how optimized 'containers' is is exactly your goal
13:57:37 <saml> > let a = a in a
13:57:39 <lambdabot>  *Exception: <<loop>>
13:59:58 <johnw> is it difficult to have cabal store its build products in a separate directory?
14:00:14 <johnw> I'm in ~/src/foo, and I'd like build products in ~/Products/foo
14:00:19 <merijn> johnw: new-build or old-build?
14:00:24 <johnw> either
14:00:24 <merijn> johnw: Also, why exactly?
14:01:05 <johnw> my ~/src gets backed up continually; rather than have rules to exclude binary products (which I need to replicate for the 5 different ways I backup), it's easier if the products live in a single directory that can be nuked
14:01:21 <johnw> also when rsync'ing source trees into VMs, etc., etc.
14:01:33 <johnw> the need to always exclude "fileset X" gets tiresome
14:01:40 <merijn> johnw: You can use --builddir to control where cabal builds things, but sadly you can't set it inside cabal.project yet
14:01:54 <johnw> that's just a configure time option?
14:02:17 <merijn> johnw: In my phd thesis codebase I'm using make for the C parts and I just have it set up to call cabal with --builddir set properly
14:02:25 <johnw> ah, it can be in CABAL_BUILDDiR
14:02:34 <merijn> oh? That's new...
14:02:42 <johnw> https://github.com/haskell/cabal/pull/2608
14:02:45 <johnw> 3 years new? :)
14:03:03 <merijn> johnw: Not documented anywhere, then :p
14:09:25 <johnw> yes, it works
14:09:30 <johnw> and with direnv, easy to setup for each project
14:15:18 <fen> so lists are the fastest container?
14:15:39 <fen> because of fusion
14:16:25 <fen> and anything that is foldable is like [a], except things that have shape which are like [(a,[j])]
14:17:41 <fen> wondering if there is a third layer, from linear to shaped and then to something else, which would have more lists (linear has one, shaped has 2 (the list of values shape list pairs))
14:17:58 <fen> maybe j = [?]
14:18:02 <Trollinator> I remember that GeneralizedNewtypeDeriving had some soundness issues. Is that still the case or is it sound these days?
14:18:19 <merijn> Trollinator: Yes, but only if you try and intentionally break things
14:18:29 <Welkin> how can it break?
14:18:39 <Trollinator> Is there a safer alternative? 
14:18:40 <merijn> Welkin: You can create unsafeCoerce with it
14:18:49 <Welkin> do you have an example?
14:18:50 <merijn> Trollinator: Sure "write everything by hand"
14:19:12 <Trollinator> that's not the kind of alternative I meant
14:20:01 <merijn> Oh, looks like it's safe IFF you use roles for everything (which, sadly, is not the default)
14:20:09 <Welkin> roles?
14:20:21 <Welkin> well, I don't see what's wrong with writing it by hand
14:20:31 <Welkin> sure it's more work, but you have 100% control over it
14:20:37 <codedmart> Lindsey7
14:20:40 <Solonarv> code you don't write is code you don't have to maintain
14:20:41 <codedmart> Oh sorry
14:20:44 <codedmart> Oops
14:20:55 <Solonarv> and the code generate by GND is extremely predictable
14:20:57 <merijn> Welkin: https://joyoftypes.blogspot.com/2012/08/generalizednewtypederiving-is.html
14:21:04 <Welkin> Solonarv: but code that is wrong that you can't see is worse than code that you write yourself
14:21:05 <Trollinator> Ah, whatever, I'll just go with GND
14:21:15 <DasBrain> Is it possible to write a function which has (basically) the signature [a] -> (a -> a -> ... -> a -> a) -> a?
14:21:22 <johnw> merijn: I've found a few cases where cabal new-configure --enable-tests won't work, but cabal configure --enable-tests does
14:21:29 <johnw> haven't been able to figure it out yet
14:21:45 <Solonarv> DasBrain: yes, but it won't be total (i.e. you can't do it in a way that rules out run-time crashes)
14:21:55 <merijn> johnw: You can't new-configure the use of builddir atm
14:22:04 <johnw> this is pre-builddir
14:22:08 <johnw> it happens with hnix, for example
14:22:10 <Welkin> I am always wary of metaprogramming
14:22:16 <johnw> new-configure says it can't find hspec-discover, but cabal configure can
14:22:27 <merijn> johnw: hmm, no clue about that
14:22:37 <fen> does build fold fusion work 2 levels out?
14:22:42 <DasBrain> Yeah, if I would do thatFunc [] id it would crash. I don't care.
14:22:50 <fen> like folding and then folding again
14:23:10 <fen> maybe have to assume the first fold was with (:) []
14:23:23 <fen> or at least, some constructors that return a foldable container
14:23:33 <Solonarv> fen: I don't think that's a "yes" or a "no" in general
14:23:46 <DasBrain> > foldl (flip (:)) "Hello"
14:23:48 <lambdabot>  <[Char] -> [Char]>
14:23:58 <DasBrain> > foldl (flip (:)) [] "Hello"
14:24:00 <lambdabot>  "olleH"
14:24:06 <fen> Solonarv: whats the scope?
14:24:29 <DasBrain> Solonarv, any hints how to approach that?
14:24:34 <Solonarv> fen: you can ask "do these two operations, involving this particular type, fuse together"
14:25:14 <Solonarv> DasBrain: cheeky answer: wait for dependent haskell
14:25:22 <fen> well can we assume that iterate (foldr (:) []) caches the first application?
14:25:43 <Solonarv> @src iterate
14:25:43 <lambdabot> iterate f x = x : iterate f (f x)
14:25:52 <Solonarv> hm, if that source is accurate then no
14:25:59 <fen> why?
14:26:01 <Solonarv> (not reliably, at least)
14:26:47 <Solonarv> DasBrain: less cheeky answer: use type class machinery
14:26:55 <fen> > (iterate (foldr (:) []) !! 100000) [1,2,3]
14:26:57 <lambdabot>  error:
14:26:57 <lambdabot>      • Couldn't match expected type ‘[[Integer] -> t]’
14:26:57 <lambdabot>                    with actual type ‘[a0] -> [[a0]]’
14:27:57 <DasBrain> > iterate (foldr (:) []) [1,2,3]
14:27:59 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,...
14:28:22 <fen> iterate (foldr (:) []) [1,2,3] !! 100000000
14:28:33 <DasBrain> :t foldr (:) []
14:28:34 <lambdabot> Foldable t => t a -> [a]
14:28:59 <fen> is it slow comiling or executing this?
14:29:18 <DasBrain> > iterate (foldr (:) []) [1,2,3] !! 10000000
14:29:21 <fen> hmmm, seems like a runtime kind of thing
14:29:25 <lambdabot>  mueval-core: Time limit exceeded
14:29:50 <DasBrain> > iterate (foldr' (:) []) [1,2,3] !! 10000000
14:29:57 <lambdabot>  mueval-core: Time limit exceeded
14:30:03 <fen> its suposed to fusion
14:30:29 * hackage snap-server 1.1.1.0 - A web server for the Snap Framework  https://hackage.haskell.org/package/snap-server-1.1.1.0 (GregoryCollins)
14:30:32 <fen> like replacing the (:) with (:) should take no time at all
14:30:32 <Solonarv> optimization is disabled in lambdabot (interactive evaluation in general, actually; that includes ghci)
14:30:55 <Solonarv> and anyway, fusion isn't GHC being super smart and figuring out "hey, this can be fused together"
14:31:29 * hackage wide-word 0.1.0.8 - Data types for large but fixed width signed and unsigned integers  https://hackage.haskell.org/package/wide-word-0.1.0.8 (ErikDeCastroLopo)
14:32:00 <fen> hmm, maybe the list wasnt created using build 
14:32:18 <Solonarv> fusion happens via rewrite rules, which in turn are straightforward pattern-matching on the expression AST
14:32:47 <fen> seems contradictory, that it can take no time and yet happen a certain number of times...
14:33:10 <Solonarv> what is "it" in that sentence?
14:33:30 * hackage hw-json-simd 0.1.0.1 - SIMD-based JSON semi-indexer  https://hackage.haskell.org/package/hw-json-simd-0.1.0.1 (haskellworks)
14:33:52 <fen> like, folding with some other thing over the original list returned by build, and over the list resulting from a million applications of foldr (:) [], should take the same time
14:34:03 <fen> maybe it has to count to a million or something
14:34:18 <fen> like, navigating through the list produced by itterate
14:34:19 <Solonarv> or maybe fusion happens in one case and doesn't in the other?
14:34:47 <fen> yeah, or it only happens when it is applied to the version returned by build, and then all the others dont fues
14:35:12 <fen> basically this itterate (foldr (:) []) should just be like repeat
14:35:22 <fen> when applied to a list returned by build
14:36:28 <Solonarv> that doesn't mean GHC can magically figure this out and rewrite 'iterate (foldr (:) [])' to 'repeat'
14:36:35 <fen> no
14:36:38 <fen> sure
14:36:52 <fen> well, it kind of does, but not exactly
14:37:00 <fen> maybe...
14:37:38 <fen> just like itterate id wont rewrite to repeat
14:38:13 <fen> the rewrite that we might could expect is from `foldr (:) []' to `id'
14:38:41 <Solonarv> and perhaps there's even a rule for that!
14:38:55 <fen> well thats the build fold fusion rule sure
14:39:05 <fen> ok, so it just applies that rule a million times
14:39:06 <Solonarv> but rules don't fire in ghci, so you'd have to *compile* the test code.
14:39:30 <fen> but what if it only applies it to the version returned by build, and not the others
14:40:16 <fen> ohhh, the rule is to make the result of fold as if it were a build...
14:40:21 <fen> hmm, maybe thats not right
14:40:22 <Solonarv> stop speculating and go look at the damn source
14:40:33 <fen> what?
14:40:37 <fen> the core?
14:40:46 <fen> its unintelligible 
14:41:09 <Solonarv> it's much more intelligible if you pass -dsuppress-all in addition to -ddump-simpl
14:41:25 <Solonarv> but no, I mean the code where the rewrite rules for foldr, build, etc live
14:41:46 <fen> the question is 2 things. does it work with repeated foldr (:) [], and does it work with some other constructor and basecase that also returns a foldable thing
14:42:22 <fen> http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#build
14:42:34 <fen> "fold/build"    forall k z (g::forall b. (a->b->b) -> b -> b) .                 foldr k z (build g) = g k z
14:42:44 <Solonarv> those answers are more easily found by writing a 10 line haskell program and compiling it with -O2
14:42:56 <Solonarv> uh, and -ddump-simpl
14:43:30 * hackage trim 0.1.0.0 - A command-line tool for trimming whitespace  https://hackage.haskell.org/package/trim-0.1.0.0 (ndrewtl)
14:43:45 <fen> think it would need just 2 layers to factor the itterate away?
14:43:52 <fen> like, that could confuse it?
14:44:33 <Solonarv> my laptop's being really slow right now, please wait
14:44:36 <fen> anyway, was doing something else, just wanted to mention
14:44:55 <fen> about [(a,[j])]
14:45:24 <fen> and was wondering if fusion allowed other foldable things to be as fast as lists
14:46:01 <fen> Solonarv: relax, the benchmarks needed were done already, have fast loops. its ok
14:46:14 <Solonarv> sure, you can define rewrite rules for whatever datatype you want
14:46:24 <Solonarv> vector for example has fusion as well
14:46:48 <fen> well atm am passing around [j]
14:47:04 <fen> but might wonder about if this could be Foldable f => f j
14:47:12 <fen> but this might not have the desired fusion
14:47:39 <fen> for sure though the original [j] was unfolded using build (the fast loops previously mentioned)
14:47:59 * hackage text-builder 0.6.5 - An efficient strict text builder  https://hackage.haskell.org/package/text-builder-0.6.5 (NikitaVolkov)
14:48:12 <fen> oh yeah, that was it, about being able to use Church j instead of [j] because it has a Foldable instance from last time
14:48:45 <fen> is that more fusionable?
14:48:56 <fen> than expecting any foldable to work?
14:49:15 <fen> because of Church's resemblance to build
14:49:38 <fen> Church a = forall b. (a -> b -> b) -> b -> b
14:50:18 <Solonarv> I mean... maybe? clearly some operations (e.g. appending) are asymptotically faster on Church
14:50:49 <fen> no but about its foldable instance being build
14:51:12 <fen> and if it preserves fusion
14:51:18 <Solonarv> well yes that's because it's identical to the argument to 'build'
14:51:28 <fen> or is a rout of it, like building the original list with build
14:51:32 <fen> like, unfolding
14:51:52 <Solonarv> you can probably make it fuse with list operations using a fairly small number of rewrite rules
14:52:15 <fen> Solonarv: but can we be sure that it uses the build fold fusion rule? because to make that work sure there needs to be mention of build at the rout
14:53:09 <Solonarv> if in the Foldable instance you write: 'toList (Church k) = build k', then that should fuse with foldr
14:53:15 <fen> so yeah, thats the point, dont really want to pass around [j] using Foldable f => f j, because the list version can use build, but there are not the rules for foldable
14:53:30 <Solonarv> oh, you'd want to add a '{-# inline toList #-}' in the instance as well
14:53:35 <fen> toList is defined using fold though
14:53:50 <fen> its not even about lists at this point
14:54:05 <Solonarv> toList is a class method so that you can override it with a more efficient implementation than foldr (:) []
14:54:25 <fen> could return a `Church j' container by unfolding without ever making a list using build
14:54:30 <Solonarv> well, yes
14:54:49 <Solonarv> and you can make operations on Church fuse together by defining appropriate rewrite rules
14:54:50 <fen> so its not really toList thats the thing here
14:55:26 <Solonarv> but the rewrite rules for [] operations won't fire on Church operations (why would they?)
14:55:29 <fen> well specifically that foldr should fuse on it
14:55:57 <fen> but thats confusing, because it means the target of the thing thats like build must be producing a foldable container by doing a fold
14:56:06 <fen> thats the new fusion rout
14:56:16 <Solonarv> at this point I'm going to ask:
14:56:36 <fen> like instead of a list returned from build, its some foldable container returned by folding something
14:56:43 <Solonarv> please provide an expression you would like to see fused, and what you expect the result of said fusion to be
14:56:49 <fen> and, is that something wider than just church
14:56:50 <Solonarv> (i.e. the resulting expression)
14:57:23 <Solonarv> Hm. At this point I feel like you're reinventing recursion schemes (specifically, hylo)
14:59:46 <fen> i want something that at constraint level can be sure to fuse
15:00:13 <fen> even using [a] isnt sound, unless the user is sure to produce this list using build and unfold
15:00:46 <Solonarv> rewrite rules fire whenever the types match; if your rewrite rules are written for polymorphic operations then they can fire at any type
15:01:19 <fen> here is the way these lists are being made; https://bpaste.net/show/d6e6aaee6974
15:01:20 <Solonarv> for example, {-# rules "fmap/fmap" forall f g x. fmap f (fmap g x) = fmap (f . g) x #-} is entirely valid and will work
15:02:18 <fen> but its a fold resulting in a foldable thing that was unfolded to begin with
15:02:38 <fen> its like, really.. um...
15:02:49 <fen> unclear
15:03:27 <Solonarv> again
15:03:51 <Solonarv> if there isn't a rewrite rule matching the expression you want to get fused (possibly after inlining), no fusion will occur
15:04:15 <fen> so if we need a new rewrite rule
15:04:21 <fen> just trying to phrase what its saying
15:04:23 <Solonarv> all the foldr-related rewrite rules I see in GHC.Base are specialized to [], so none of them will fire for a generic foldable
15:05:27 <fen> thats why church seemed good, because at the first place, we need something like build
15:06:36 <fen> like this is sort of a zero cost way to convert between foldables, but the rule seems to need that it started off as a church encoding
15:06:42 <Solonarv> how is a new datatype (which happens to have a Foldable instance) supposed to make generic Foldable operations fuse?
15:06:52 <Solonarv> you can't convert between Foldables in general
15:07:09 <Solonarv> that is not a thing the typeclass methods allow you to do
15:07:27 <fen> no thats the point, the Foldable constraint on the result is needed by the rewrite rule
15:07:30 <fen> no thats not right
15:07:38 <fen> it can result in anything
15:07:49 <pgiarrusso> fen: datatype-generic fusion does not exist
15:07:52 <fen> but if its going to be fusionalble *again* then ...
15:08:09 <fen> no we are making it
15:08:52 <Solonarv> no, you are attempting to make it
15:09:11 <pgiarrusso> Researchers have been working on fusion for ages, nobody has done it datatype-generically
15:09:17 <Solonarv> I am telling you that you can't do it with Foldable alone (Traversable probably isn't enough either)
15:09:55 <fen> "folds resulting in foldable containers have a rewrite rule like build/fold fusion where the resulting container takes the place of the list returned by build, as long as the original contaier was church encoded, or the result of a fusioned fold over such a result or church encoding"
15:10:42 <Solonarv> I'm fairly certain that you can't do this in a way that will automatically work for any Foldable
15:10:58 <pgiarrusso> fen: is that a quote or a research proposal?
15:11:11 <fen> the quote marks were eronious
15:11:30 <fen> Solonarv: but it works with any fold over build...
15:11:37 <Solonarv> what is "it"?
15:11:52 <pgiarrusso> you might want to start by reading the papers about shortcut fusion and successors
15:12:00 <fen> might could do that
15:12:23 <Solonarv> definitely do that
15:12:53 <Solonarv> it seems like you're doing novel research, and I'd wager being aware of prior work is helpful
15:12:57 <fen> ok, so just to get the answer of this first
15:13:09 <Solonarv> s/aware of/familiar with/, even
15:14:12 <fen> oh right yeah sure for years
15:14:20 <pgiarrusso> Being aware of previous work is a necessary starting point
15:14:27 <fen> but apparently this isnt done yet so...
15:14:53 <pgiarrusso> Yeah, but you need to understand what’s done now deeply before improving on it
15:15:22 <fen> like, could just keep starting with https://bpaste.net/show/d6e6aaee6974 and passing around lists as they are sure to fuse then
15:15:47 <fen> but just thought this way using church encoding instead of build might mean more than just lists could work
15:15:54 <fen> either way seems equivalent
15:15:56 <pgiarrusso> fen: that code doesn’t look too bad indeed
15:16:02 <fen> ...
15:16:15 <fen> well just if you want lists its ok
15:16:38 <pgiarrusso> fen: but I think using the church-encoding for lists will not help with other structures
15:16:51 <fen> but the use of build here isnt *really* needed, its just to use that fusion rule, but really the rule should be over the church encoding thats the point
15:17:04 <fen> what!?
15:17:07 <fen> its the same thing
15:17:13 <fen> thats the point
15:17:29 <pgiarrusso> You’d need to use the church-encoding appropriate to other structures
15:17:34 <fen> no
15:17:47 <fen> oh, unless they are not linear
15:17:54 <fen> but then you just nest it again
15:17:55 <pgiarrusso>  Try writing a function with build’s type to build a tree
15:18:10 <fen> thats [(a,[j])]
15:18:17 <fen> where the j encode the tree shape
15:18:23 <fen> and the [j] is unfolded 
15:18:24 <ongo> Hello, got a question, I use this player lollypop and it needs this library gi secret, from the googling I did, I think it's a haskell lib, is it? https://i.imgur.com/av9DGXP.png
15:18:30 <fen> so could also be church encoded
15:18:49 <fen> its important as this path between the leaves should also be 0 cost
15:19:08 <jbetz> I have a State + Alternative semantics that I want to encode but don't know how. the goal is to have a list of State actions that get performed in sequence. each of them can fail (i.e., `empty`), which means that that particular action will be shortcutted just like in a Maybe monad. the trick is, I don't want failure to be propagated to the next action in the sequence.
15:19:39 <pgiarrusso> 12:16 AM <fen> but the use of build here isnt *really* needed, its just to use that fusion rule, but really the rule should be over the church encoding thats the point
15:19:48 <pgiarrusso> that’s not quite how things work
15:19:55 <fen> hmm...
15:20:06 <lyxia> jbetz: s -> Maybe (s, a)  ?
15:20:09 <pgiarrusso> The fusion rule collapses a build that creates an actual list with a foldr that consumes it
15:20:29 <pgiarrusso> Then *inlining* happens
15:21:02 <pgiarrusso> Meanwhile, at the end the final build will not cancel out and will build the final list
15:21:08 <ongo> how do I install haskell packages? cabal install gives me warnings that it's legacy
15:21:10 <fen> right, but anything that was produced by folding and unfold should work
15:21:35 <fen> the fusion replaces the constructors resulting in the foldable container
15:21:40 <jbetz> lyxia: hmm
15:21:44 <glguy> ongo: The warning explains the answer
15:22:03 <pgiarrusso> fen: I’m explaining how it works for lists
15:22:04 <fen> well thats confusing since its actaully (:) but fold uses pattern matching on cons
15:22:26 <fen> its obvious how it works for lists, the problem is how this works for church encoded lists
15:23:02 <Solonarv> ongo: "GI" actually stands for "GObject introspection"; are you sure your google-fu didn't mislead you?
15:23:04 <pgiarrusso> For church encoded lists it’s just lots of inlining, not a fusion rule
15:23:18 <fen> huh, thats curious
15:23:19 <pgiarrusso> I have no clue why you talk about non-linear data structures here
15:23:19 <aplainzetakind> jbetz: Something like this? https://github.com/data61/fp-course/blob/master/src/Course/StateT.hs#L361
15:23:20 <ongo> Solonarv: what other library could it be? https://i.imgur.com/av9DGXP.png
15:23:40 <pgiarrusso> fen: that’s why I suggest to read the paper
15:23:50 <fen> ok, so the point about "shaped" as oppsed to non-linear
15:23:52 <jbetz> lyxia: it's actually `s -> (s, Maybe a)`. I think I need the state to be returned in order to feed it into the next action.
15:24:07 <fen> is that folding also gives access to the shape param
15:24:10 <pgiarrusso> ongo: isn’t it a gnome library ?
15:24:13 <fen> as well as the value
15:24:25 <fen> so if the values are discarded, then you just are left with [j]
15:24:36 <pgiarrusso> ongo: it probably has a wrapper for haskell, but that’s unlikely to be what you want?
15:24:52 <fen> just the shape between each value in a sequence 
15:24:56 <Solonarv> yes, that's what I was thinking
15:24:57 <ongo> ah it was a python lib called gobject
15:25:14 <Solonarv> there is indeed a Haskell library named "gi-secret", but it's just a wrapper around libsecret
15:25:24 <fen> if its "linear" then j = () and the [()] is like the natural number giving the position of the value in the linear container
15:25:30 <lyxia> jbetz: the way I see it is each action is (s -> Maybe (s, a)) because you don't care what the state is if it fails, but you can then embed that into (s -> (s, Maybe a)) in order to compose them the way you want.
15:26:05 <pgiarrusso> ongo: it’a probably a C library https://developer.gnome.org/gi/stable/gi-building.html
15:26:30 <fen> jbetz: you can have s -> Maybe (s,Maybe a)
15:26:39 <pgiarrusso> ongo with wrappers in various languages... look for your Linux distribution package manager probably?
15:26:52 <fen> then it can fail if it does not give a new state, or if the state fails to give a new value
15:27:16 <fen> looping over this gives another kind of state. one sec
15:27:28 <jbetz> aplainzetakind: something like that, yeah
15:27:58 <fen> https://bpaste.net/show/4dfb019fd230
15:28:24 <bkerin> I'm looking at an explicit functor implementation and got questions thought maybe people here could help
15:28:41 <pgiarrusso> fen: I’m gonna bow out from this topic... good luck on your research
15:28:53 <fen> thanks for the help
15:29:03 <pgiarrusso> bkerin: this channel is the right place
15:29:10 <Solonarv> bkerin: sure! ask away
15:29:18 <bkerin> it's basically a C implementation of CLOS and has a Functor type: https://github.com/CObjectSystem/COS
15:29:46 <aplainzetakind> jbetz: Thant's basically StateT over MaybeT over the monad providing the effect you want.
15:31:03 <bkerin> what I don't get even after a fair amount of reading is why Functor OBJ seems to boil down to a stack of OBJ plus a function
15:31:32 <bkerin> i can't relate it to the definition of Categories/Functors i'm reading on wikipedia
15:31:56 <Solonarv> bkerin: in C++, "functor" actually means something like "object that can be called as a functio"
15:32:24 <Solonarv> the project you're looking at seems to also use it with that meaning
15:32:34 <aplainzetakind> jbetz: This was my solution for that exercise if it would be useful: https://paste.pound-python.org/show/taF4fHRDND6OkDBZ1Wnu/
15:33:02 <jbetz> thanks :)
15:33:18 <aplainzetakind> That course reimplements most standard stuff, so Optional is Maybe, List a is [a], and Chars is String.
15:34:32 <Solonarv> bkerin: so, I think this isn't a functor in the categorical/Haskell sense, but instead a "function object"
15:34:42 <bkerin> ah... so maybe its not me.  well whatever they are seem nifty you can say   OBJ my_functor = aFun(some_func, some_OBJ, __1, __2)
15:35:15 <bkerin> and then OBJ another_functor = geval(my_functor, another_OBJ)
15:35:42 <Solonarv> thanks for the examples, I'm now utterly convinced that I was right :D
15:36:18 <bkerin> and finally OBJ actual_result = geval(another_functor, yet_another_OBJ)
15:36:23 <bkerin> ok
15:36:57 <Solonarv> actually, does that project have documentation online anywhere?
15:37:06 <Solonarv> I'm suddenly less certain
15:37:07 <bkerin> its nifty that you get another Functor after partial evaluation or a result if everything is know
15:38:04 <bkerin> there is a paper https://github.com/CObjectSystem/COS/blob/master/doc/cos-oopsla09.pdf 
15:41:08 <Solonarv> ah, I see - "functor" does indeed mean "function object"
15:41:08 <bkerin> its really pretty code too some of the cleanest I've ever seen
15:41:17 <Solonarv> (and they're curried, too)
15:41:33 <bkerin> ah good
15:42:03 <bkerin> i was feeling sort of dumb not being able to figure out how they related to Functors
15:42:28 <Solonarv> yeah, the way that term is used in C/C++ is a bit confusig
15:42:52 <fragamus> hi I need help with these few lines of code: https://gist.github.com/69bb9a5816f952c98f456f719b03deb7.git
15:43:46 <bkerin> COS is a tiny bin unfinished I've fixed some bit rot in it so far was going to fix the example but seems Functor got a refactor and now the gcompose generic is missing
15:43:47 <c_wraith> fragamus, what about them?
15:43:58 <bkerin> well doesn't have any implementations
15:44:05 <fragamus> The partially applied constructor
15:44:23 <Solonarv> line 5?
15:44:29 <fragamus> yes
15:44:51 <Solonarv> constructors can be partially applied like any other function
15:45:11 <c_wraith> the result needs to have the type Store s (Store s a)
15:45:14 <Solonarv> you can think of 'Schmore f' as '\x -> Schmore f x'
15:45:46 <fragamus> yeah ok
15:46:21 <c_wraith> so you need a function of type s -> Store s a
15:46:32 <c_wraith> which... you have.
15:48:25 <bkerin> but I'm not quite clear what gcompose of Functor of the type in COS would mean, when outer functor would need to have just one arg or whether the composition would concatenate free args (less 1) or what, maybe there is no obvious answer in this case
15:49:27 <Solonarv> curried functions always take one argument, so they can be composed no problem
15:50:24 <MarcelineVQ> Solonarv: that particular convo happened recently, something like \n -> appEndo . stimes n . Endo emerged as the interesting route rather than iterate since it skips the list
15:50:38 <MarcelineVQ> oh drat, my scrollback paused, that's a little stale.
15:50:47 <Solonarv> oh, I was about to ask
15:58:37 <bkerin> so sounds like in normal use anyway gcompose(ftor1, ftor2) would expect at least the outer ftor (ftor1 I guess) to have exactly 1 free arg  
16:00:02 <Solonarv> not necessarily
16:00:07 <bkerin> other args if any are 'curried' i.e. go on the stack and become fixed across evaluations of the composite ftor 
16:00:15 <bkerin> hmm
16:00:17 <Solonarv> that's not what "curried" means
16:00:25 <bkerin> o
16:00:57 <Solonarv> what I would expect is that 'geval(gcompose(f, g), x)' is equivalent to 'geval(f, geval(g, x))'
16:12:38 <bkerin> you're right.  I guess that implies that if f has two (or more) free vars the output of g goes in the first one.  after that I'm still not clear in which order one would expect additional values provided to geval() to fill in any remaining free parameters of f/g
16:13:17 <bkerin> I suspect it's irrelevant because these guys are always used with arguments of one function when composed at least
16:14:30 <bkerin> anyway ty so much for your help I really appreciate, one good outcome of all those functor web pages I've looked at I've become very interested in haskell will try soon :)
16:15:42 <Solonarv> hehe, welcome to the cabal!
17:17:30 * hackage swagger2 2.3.1.1 - Swagger 2.0 data model  https://hackage.haskell.org/package/swagger2-2.3.1.1 (phadej)
17:28:35 <aplainzetakind> Is it possible to easily tweak `GHC.Natural`s to start from 1?
17:33:00 * hackage network-arbitrary 0.4.0.2 - Arbitrary Instances for Network Types  https://hackage.haskell.org/package/network-arbitrary-0.4.0.2 (alunduil)
17:34:30 * hackage collection-json 1.3.1.0 - Collection+JSON—Hypermedia Type Tools  https://hackage.haskell.org/package/collection-json-1.3.1.0 (alunduil)
18:31:24 <sicklorkin> :t flip ((.).(.))
18:31:26 <lambdabot> (a1 -> a2 -> b) -> (b -> c) -> a1 -> a2 -> c
18:31:37 <sicklorkin> :t on
18:31:39 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
18:32:23 <jchia> My parser code using megaparsec, conduit and StateT does nothing. Not one line goes through lineParser. What's wrong? https://gist.github.com/jchia/89910ccc922c57e43026532ff9758116
18:34:07 <jchia> Because the CL.map is not actually running the parser from lineParser? How should I restructure the code?
18:34:34 <sicklorkin> jchia: where is the input comming from?
18:34:46 <jchia> sicklorkin: sourceList
18:35:04 <sicklorkin> but it's lazy
18:35:16 <jchia> normally it's an input file but this is a test case to illustrate the problem
18:35:26 <sicklorkin> oh i see now.
18:36:10 <sicklorkin> does it print any traces?
18:36:28 <jchia> nothing, only the output from "print parserState".
18:37:26 <sicklorkin> i don't see how that would ever evaulate
18:42:45 <DasBrain> @src liftM2
18:42:45 <lambdabot> liftM2 f m1 m2 = do
18:42:45 <lambdabot>     x1 <- m1
18:42:45 <lambdabot>     x2 <- m2
18:42:46 <lambdabot>     return (f x1 x2)
18:43:05 <DasBrain> @undo liftM2
18:43:06 <lambdabot> liftM2
18:43:20 <jchia> Fixed: https://gist.github.com/jchia/89910ccc922c57e43026532ff9758116/revisions?diff=split
18:46:27 <Solonarv> @. undo src liftM2
18:46:27 <lambdabot> liftM2 f m1 m2 = m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2);
18:46:30 <Solonarv> hah!
18:46:34 <Solonarv> DasBrain: ^
18:50:54 <Johannes13> @src >>= :: ((->) c a) -> (a -> ((->) c b)) -> ((->) c b)
18:50:55 <lambdabot> Source not found. Take a stress pill and think things over.
18:51:17 <Johannes13> @src Monad ((->) a)
18:51:17 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
18:51:36 <Johannes13> @inst Monad (->)
18:51:36 <lambdabot> Maybe you meant: instances instances-importing list
18:52:06 <geekosaur> @src (->) Monad
18:52:06 <lambdabot> Source not found. :(
18:55:21 <Solonarv> instance Monad ((->) e) where
18:55:21 <Solonarv>   return a = \_ -> a
18:55:21 <Solonarv>   a >>= k = \x -> k (a x) x
18:55:21 <Solonarv>   -- Johannes13
18:56:29 * hackage espial 0.0.7 - Espial is an open-source, web-based bookmarking server.  https://hackage.haskell.org/package/espial-0.0.7 (jonschoning)
18:56:49 <Johannes13> @pf f a k x = k (a x) x
18:56:49 <lambdabot> Maybe you meant: pl bf
18:56:53 <Johannes13> @pl f a k x = k (a x) x
18:56:54 <lambdabot> f = flip flip id . (ap .) . flip (.)
18:57:16 <Johannes13> @pl ap
18:57:16 <lambdabot> ap
18:57:55 <Johannes13> @pl (ap .)
18:57:55 <lambdabot> (ap .)
18:58:10 <geekosaur> no points to remove
18:58:11 <Johannes13> @src ap
18:58:11 <lambdabot> ap = liftM2 id
18:58:23 <geekosaur> @. pl src ap
18:58:23 <lambdabot> ap = ap
18:58:27 <geekosaur> heh
18:58:33 <geekosaur> not the swiftest of rewrite engines
18:58:41 <Solonarv> interesting, it doesn't come up with >>=
18:59:01 <Johannes13> @. pl src >>=
18:59:01 <lambdabot> Source not found . The more you drive
18:59:04 <geekosaur> no, it prefers things like ap, which is why it did that
18:59:05 <Johannes13> @. pl src (>>=)
18:59:06 <lambdabot> (line 2, column 1):
18:59:06 <lambdabot> unexpected end of input
18:59:06 <lambdabot> expecting space or simple term
18:59:09 <_deepfire> conal:  sorry for distracting once more -- I've repackaged the source (from http://research.microsoft.com/en-us/downloads/c9eff407-ce59-4a2a-90cb-de099a9bacbd/) as a local Git repo, with proper date and attribution, at point of v1.16 -- would you want to have it, so that you maybe can put it up on Github so people have easier access to it?
18:59:22 <geekosaur> and that won't work because (>>=) is different for every Monad instance
18:59:24 <_deepfire> conal: Fran source, that is
18:59:51 <Solonarv> does @pl really never use >>= at (->) ?
18:59:51 <Johannes13> @src liftM2
18:59:51 <lambdabot> liftM2 f m1 m2 = do
18:59:51 <lambdabot>     x1 <- m1
18:59:52 <lambdabot>     x2 <- m2
18:59:52 <lambdabot>     return (f x1 x2)
19:00:04 <Johannes13> @. pl src liftM2
19:00:05 <lambdabot> liftM2 = flip ((.) . (<-) . (do x1 <-) . ($ x2)) . flip ($ return) . flip ($ x1) x2
19:00:22 <Johannes13> @. pl undo src liftM2
19:00:23 <lambdabot> src liftM2
19:00:28 <geekosaur> Solonarv, it may sometimes, but if it sees the equivalent of ap it rewrites to ap
19:00:33 <geekosaur> which is why that 'ap = ap'
19:00:58 <Johannes13> @unpl liftM2 = flip ((.) . (<-) . (do x1 <-) . ($ x2)) . flip ($ return) . flip ($ x1) x2
19:00:58 <lambdabot> <unknown>.hs:1:8:Parse error: =
19:01:09 <Johannes13> @unpl flip ((.) . (<-) . (do x1 <-) . ($ x2)) . flip ($ return) . flip ($ x1) x2
19:01:09 <lambdabot> <unknown>.hs:1:14:Parse error: <-
19:01:31 <Solonarv> @. pl . undo src liftM2
19:01:32 <lambdabot> (line 1, column 64):
19:01:32 <lambdabot> unexpected ';'
19:01:32 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
19:01:36 <Johannes13> ok. I don't get it. You got me that nonsense and tell me you can't turn it back.
19:01:57 <geekosaur> this one is because there's a spurious semiccolon at the end of the def
19:01:57 <Johannes13> @help .
19:01:57 <lambdabot> . <cmd1> <cmd2> [args].
19:01:57 <lambdabot> . [or compose] is the composition of two plugins
19:01:57 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
19:02:08 <geekosaur> which @pl doesn't know how to deal with
19:02:19 <geekosaur> @. undo src liftM2
19:02:19 <lambdabot> liftM2 f m1 m2 = m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2);
19:02:35 <geekosaur> @src liftM2
19:02:35 <lambdabot> liftM2 f m1 m2 = do
19:02:35 <lambdabot>     x1 <- m1
19:02:35 <lambdabot>     x2 <- m2
19:02:36 <lambdabot>     return (f x1 x2)
19:02:42 <geekosaur> which looks like a bug in @undo
19:02:43 <Johannes13> @pl liftM2 f m1 m2 = m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
19:02:44 <lambdabot> liftM2 = liftM2
19:02:53 <Johannes13> you don't say
19:03:02 <Johannes13> @pl foo f m1 m2 = m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
19:03:03 <lambdabot> foo = liftM2
19:03:19 <geekosaur> it has those preferred patterns I mentioned. liftM2 is one of them
19:03:26 <Solonarv> chaining @do after it doesn't get rid of the semicolon either :/
19:03:36 <geekosaur> it's not really a smart program
19:03:51 <geekosaur> (there's the pointfree package on hackage if you want to poke at it)
19:03:52 <DasBrain> Is there a way to create liftM2 using only flip, const and (.)?
19:04:04 <DasBrain> ok, and id
19:05:47 <DasBrain> @pl S x y z = x z (y z)
19:05:48 <lambdabot> S = ap
19:06:06 <Solonarv> @pl \o f g x -> o (f x) (g x)
19:06:06 <lambdabot> liftM2
19:06:11 <Solonarv> hah!
19:09:03 <koz_> Solonarv: liftA2 could possibly work also?
19:09:17 <Solonarv> yes, liftA2 and liftM2 are the same thing after all
19:09:34 <Solonarv> (assuming an Applicative instance with (<*>) = ap)
19:09:46 <koz_> I.e. a correct one. :P
19:10:09 <geekosaur> but @pl doesn't know about Applicative and will rewrite it to liftM2 anyway
19:10:14 <Solonarv> indeed; well, you can do some handwaving regarding "morally correct" instances, but whatever
19:10:22 <geekosaur> or simply pass it through because it doesn't know what it is
19:16:21 <Solonarv> pl: a remnant of the Dark Ages :P
19:21:21 <geekosaur> no, the dark ages were main :: [Response] -> [Request] :p
19:23:08 <Solonarv> hmm, true
19:32:14 <DasBrain> main = WriteFile stdout "Hello World!"
19:32:38 <DasBrain> or was it main = [WriteFile stdout "Hello World!"]
19:32:57 <DasBrain> I wonder how the "switch" was done.
19:48:00 * hackage antiope-athena 6.3.0 -   https://hackage.haskell.org/package/antiope-athena-6.3.0 (alexeyraga)
19:49:00 * hackage antiope-core 6.3.0, antiope-contract 6.3.0 (alexeyraga): https://qbin.io/tn-strips-xbwb
19:50:00 * hackage antiope-dynamodb 6.3.0 -   https://hackage.haskell.org/package/antiope-dynamodb-6.3.0 (alexeyraga)
19:51:00 * hackage antiope-sns 6.3.0, antiope-s3 6.3.0, antiope-messages 6.3.0 (alexeyraga)
19:51:59 * hackage antiope-sqs 6.3.0 -   https://hackage.haskell.org/package/antiope-sqs-6.3.0 (alexeyraga)
21:29:51 <fen> https://pastebin.com/wFbFS8ds
21:29:54 <fen> whats this?
21:30:00 <fen> could be done with arrows?
21:30:08 <fen> or applicative...
21:32:02 <vaibhavsagar> fen: https://hackage.haskell.org/package/these
21:34:22 <fen> is that just the AndOr?
21:34:26 <MarcelineVQ> Both is reminscent of Profunctor
21:36:19 <fen> hmm, the last example has its types all wrong, never mind that example
21:36:47 <MarcelineVQ> or uhm, just Bifunctor I guess
21:37:25 <MarcelineVQ> dunno if the Kinds would line up though, just speaking about the impression of it
21:37:41 <fen> the "before and after" was supposed to reflect like if the function was used infix, that either argument could be acted on
21:38:16 <fen> (a -> a) . (a -> a) ... (a -> b -> c) . (b -> b) . (b -> b) ...
21:38:24 <fen> oh, wait thats wrong...
21:38:33 <fen> hmm
21:39:22 <fen> yeah, can see how Profunctor seems likely 
21:40:17 <fen> this version compiles, https://pastebin.com/AqGQfkXa
21:41:16 <fen> anyway, its not much of a class with only one instance...
21:41:22 <fen> but there was some other instance
21:42:00 <fen> things that could have (a -> a) composed with (.) on one side and (b -> b) on the other, or both
21:42:54 <fen> some kind of generalisation to (a -> b -> c)
21:43:50 <fen> if its profunctor then that `c' argument is totally spurious 
21:44:41 <fen> yeah, maybe its just profunctor
21:45:00 <fen> ever seen this with This/That/AndOr?
21:45:06 <fen> like folding like that
21:45:33 <fen> (a -> b -> b) of fold generalising to being able to act before or after...
21:45:37 <fen> sorry, tired
21:46:43 <MarcelineVQ> I've not really used these and profunctor
21:47:28 <fen> Bifunctor does not seem right, even though the restriction to isomorphisms lets it work, its more profucntoresque with how its supposed to map over the functions
21:47:34 <fen> but maybe thats just a vibe...
21:48:40 <fen> the idea is to fold, accumulating actions that are composed, and there are 2 natural compositions, before and after
21:49:10 <fen> the isomorphisms result from this needing to be done repeatedly so the types must remain constant
21:50:15 <fen> the thing in the middle, the basecase of the fold, can change the types though, seems like its a profunctor (this generalised accumulator)
21:50:51 <fen> yeah, seems to make more sense with 2 instead of 3 args, might could rewrite it.
21:50:53 <fen> thanks
22:11:00 * hackage texmath 0.11.2 - Conversion between formats used to represent mathematics.  https://hackage.haskell.org/package/texmath-0.11.2 (JohnMacFarlane)
23:34:21 <ddk> hello everyone
23:38:04 <ddk> anybody here with fair understanding of `acid-state` library
23:39:44 <opqdonut> I've used it once years ago
23:48:05 <ddk> opqdonut: Nice, if you remember can you tell me how do we create a `LogKey object` value 
23:52:36 <opqdonut> ddk: I don't remember ever using a LogKey, and I can't see it mentioned in the docs
23:59:00 * hackage google-server-api 0.3.1.0 - Google APIs for server to server applications  https://hackage.haskell.org/package/google-server-api-0.3.1.0 (arowM)
