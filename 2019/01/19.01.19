01:14:14 <jollygood2> hi. busy loop compiled with -O2 does not react to C-c. could this be considered a bug?
01:19:01 <inkbottle> If I put `_ = someCode` in a module, does that have absolutely no effect and act as mere documentation?
01:25:43 <hololeap> inkbottle: that would just drop the argument and return someCode. same as `const`
01:26:00 <hololeap> `const someCode`
01:27:15 <[exa]> jollygood2: do you have a tiny example of that?
01:27:27 <jollygood2> [exa] I'll make a test case
01:28:11 <hololeap> :t const putStrLn
01:28:12 <lambdabot> b -> String -> IO ()
01:28:55 <hololeap> the b is just a type variable given to an argument that is completely ignored. and then it returns putStrLn :: String -> IO ()
01:29:17 <hololeap> same as `_ = putStrLn`
01:31:49 <inkbottle> hololeap: yes, of course, if it prints something, it not without an effect (silly me) ;)
01:32:58 <inkbottle> but actually it is not what you said...
01:33:45 <hololeap> how so?
01:34:14 <MarcelineVQ> If you mean _ = someCode at the top level, that's legal and deosn't do anything useful. it would affect compile time, if only in a tiny way, I'm not sure what it'd be documenting though. you'd be better off with block comments for most things {- comment -}
01:35:01 <MarcelineVQ> not useful might be too strong a thing to say. rather, you can't do anything with directly it since it's un-named
01:35:08 <hololeap> oh, sorry, i interpreted it as `f _ = someCode`
01:38:04 <inkbottle> MarcelineVQ: Yes, not very good documenting; only, on a very short term view, it looks more beautiful in my editor 
01:40:28 <inkbottle> And might also print something... rather untidy
01:40:51 <hololeap> i was wrong on that... i don't think it actually would since it would never be called
01:41:18 <inkbottle> OK
01:43:26 <hololeap> like i said, i assumed you meant `f _ = someCode` but it might actually work as a clever way of documenting. but won't it be type-checked? seems like you wouldn't be able to be that expressive
01:51:25 <jaarod> here's the test case. if C-c can break busy loop depends on optimization level (and even more oddly, behavior of default optimization and -O0 (which should be the same as) differs https://bpaste.net/show/87c1222599e9
01:52:17 <jaarod> I'm on windows, so perhaps this is a windows-only issue
01:59:09 <Ariakenom> jaarod: try -fno-omit-yields https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html#ghc-flag--fomit-yields
02:02:04 <jaarod> with that flag C-c works, regardless of optimization level
02:02:37 <inkbottle> hololeap: No big deal, but I like that code: http://paste.debian.net/1061386/, and it looks nice in my emacs, better that {- -}; not for production, of course.
02:02:42 <jaarod> still, is it acceptable that optimization level changes the behavior of the program?
02:04:12 <Ariakenom> jaarod: Asynchronous exceptions can only happen when a thread allocates. The optimization made it so it never allocated. No omit yield add checks for asynchronous exceptions other than just allocations.
02:07:09 <jaarod> Ariakenom, I think my question is valid. should that optimization be done, if it changes the behavior of the program? btw, did anyone try to reproduce this on linux?
02:07:09 <Ariakenom> jaarod: I think it can only completely fail to stop it when the loop never ends (bottom).
02:08:02 <Ariakenom> It will be interrupted as long as the program doesn't have any infinite loops I think
02:17:11 <jaarod> Airakenom, ok fair point. but another question is, should C-c immediately make the program quit that doesn't go out of its way to prevent it? I think it should
02:18:08 <jaarod> if a program is doing some calculation for a minute, I should be able to stop it with C-c
02:25:48 <mightmosquito> How do I get stack install to update build dependencies to the cabal file?
02:39:29 <gentauro> mightmosquito: `stack` generates a new `.cabal` file based on your `stack` setup
02:39:32 <gentauro> :)
02:43:02 <oisdk> I vaguely remember reading that seq was reimplemented using bang patterns in base. I can't find anything about it now, but does anyone know what I'm remembering?
02:43:07 <oisdk> or did I imagine it?
02:44:06 <mightmosquito> gentauro: So whenever I need to install something, I do a stack install. From whatever I have been able to read ,stack downloads that package from stackage and puts it in a local project stack folder, but I still need to add it to the cabal file (or the stack file). I also manually need to put all the dependencies of that package in the cabal file (which is fine) but is there no option for making stack do it(kinda like
02:44:06 <mightmosquito> what npm install --save does??)
02:47:28 * hackage hw-kafka-conduit 2.6.0 - Conduit bindings for hw-kafka-client  http://hackage.haskell.org/package/hw-kafka-conduit-2.6.0 (alexeyraga)
02:49:33 <Ariakenom> jaarod: The reason -fno-omit-yields isn't on by default is probably performance. I believe it checks a flag each time it enters a function.
02:52:15 <Ariakenom> Running into it isn't super rare though, I answer questions about it in here every now and then. Changing defaults is a bit tricky though.
03:25:31 <t7> I want a function to return a lazy list
03:25:40 <t7> but i need to use the state monad inside it
03:26:00 <t7> like State x [y] or something but then the list will not be lazy
03:26:34 <t7> will sequence do what i want?
03:27:27 <t7> no
03:27:44 <t7> ListT ?
03:29:24 <Ferdirand> maybe you want Control.Monad.State.Lazy ?
03:29:54 <Ferdirand> or ST ?
03:30:25 <Ferdirand> or ST.Lazy ?
03:31:48 <Ferdirand> I have a stream cipher implementation that returns a lazy list of Word8 and keeps its state in an STUArray
03:31:56 <Ferdirand> if that's something like what you want
03:40:14 <the_2nd> I want to write to the same file I'm reading (after completing the read). http://hackage.haskell.org/package/strict-0.3.2/docs/System-IO-Strict.html should I use that, or are there alternatives in base?
03:42:48 <WilliamHamilton[> kosmikus: sure, here's the problem description and also a link to some code to put it in context https://pastebin.com/raw/XuCHbiLw
03:43:57 * hackage postgresql-simple-migration 0.1.14.0 - PostgreSQL Schema Migrations  http://hackage.haskell.org/package/postgresql-simple-migration-0.1.14.0 (ameingast)
04:13:28 * hackage hw-kafka-client 2.6.0 - Kafka bindings for Haskell  http://hackage.haskell.org/package/hw-kafka-client-2.6.0 (alexeyraga)
04:39:58 * hackage list-t 1.0.3 - ListT done right  http://hackage.haskell.org/package/list-t-1.0.3 (NikitaVolkov)
04:42:09 <hasky> How do I declare a list? I tried let nameOfList = ['A', 'B'] but it ruins my code and gives compilation errors. Learn you a haskell says that's how you do it though.
04:45:14 <hc> are you using "let" inside of a do block?
04:45:27 <hc> If you're using it outside of a do block, you need to finish with "in"
04:45:31 <hasky> Idk what a block is, but it's not in a function
04:45:40 <hc> like "let myList = [1, 2, 3] in print myList"
04:45:54 <hasky> What's print for?
04:45:55 <hc> > let myList = [1, 2, 3] in print myList
04:45:57 <lambdabot>  <IO ()>
04:46:37 <jaarod> hasky, can you paste the non-working code?
04:46:38 <hc> hasky: it's just an example. you use let to define something that's valid only in what follows after the "in". That is unless you use let inside a do block
04:47:39 <hasky> So unless I'm misunderstanding...I can't declare a list in some random place in the file and use it in several functions?
04:48:36 <hc> you can
04:48:42 <jaarod> outside of functions, you just do `myList = [1, 2, 3]', without a let
04:48:43 <hc> then you need to declare it at the top level and not use let
05:02:15 <dmwit> thaumavorio: That would be fine. Using just base, you could also explicitly open, read, and close the file. (readFile or hGetContents won't do.)
05:02:34 <dmwit> the_2nd: That was for you. (Sorry for the misnick, thaumavorio.)
05:02:35 <hc> hasky: as jaarod suggested, please paste some code that doesn't work
05:23:58 <joel135> Can this work? https://gist.github.com/JoelSjogren/a63e960a8c7c3c064bff14db860a3480
05:25:58 <joel135> (updated)
05:37:57 * hackage github-release 1.2.4 - Upload files to GitHub releases.  http://hackage.haskell.org/package/github-release-1.2.4 (fozworth)
05:38:58 * hackage Network-NineP 0.4.5 - High-level abstraction over 9P protocol  http://hackage.haskell.org/package/Network-NineP-0.4.5 (SergeyAlirzaev)
05:41:27 * hackage json-feed 1.0.6 - JSON Feed  http://hackage.haskell.org/package/json-feed-1.0.6 (fozworth)
05:47:00 <Lears> joel135: I don't really know what you're trying to do with this, but it should compile if you make Endo a newtype and eta reduce the last parameter of each Sn type synonym.
05:47:18 <Lears> Or if you really want to avoid the newtype you can use LiberalTypeSynonyms instead
05:49:03 <amalloy> i don't think it's Endo that needs to be a newtype, but Sn, isn't it? i would expect ghc to be unhappy with using S0 without its parameters
05:49:54 <Lears> % type S0 = []
05:49:55 <yahb> Lears: 
05:50:03 <Lears> % [3] :: S0 Int
05:50:03 <yahb> Lears: [3]
05:52:14 <Lears> S0 alone is fully applied if the type declaration itself took no parameters, so there's no issue; it's just a higher kinded synonym.
05:52:41 <Lears> % :k S0
05:52:41 <yahb> Lears: S0 :: * -> *
05:59:27 * hackage lackey 1.0.8 - Generate Ruby clients from Servant APIs.  http://hackage.haskell.org/package/lackey-1.0.8 (fozworth)
06:00:28 * hackage ratel 1.0.8 - Notify Honeybadger about exceptions.  http://hackage.haskell.org/package/ratel-1.0.8 (fozworth)
06:09:57 * hackage ratel-wai 1.0.5 - Notify Honeybadger about exceptions via a WAI middleware.  http://hackage.haskell.org/package/ratel-wai-1.0.5 (fozworth)
06:14:41 <t7> haskell ide engine is pretty smooth
06:22:27 <t7> ghcid vscode plugin is also very good
06:22:28 * hackage rattletrap 6.2.1 - Parse and generate Rocket League replays.  http://hackage.haskell.org/package/rattletrap-6.2.1 (fozworth)
06:36:58 * hackage strive 5.0.8 - A client for the Strava V3 API.  http://hackage.haskell.org/package/strive-5.0.8 (fozworth)
06:51:38 <ocramz> hullo!
06:51:58 * hackage hopenpgp-tools 0.21.3 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.21.3 (ClintAdams)
06:52:40 <ocramz> I was looking at Kleisli from Control.Arrow in base. Wondering why in addition to the ArrowPlus instance it doesn't have Applicative and Alternative instances?
06:57:36 <ocramz> hi o1lo01ol1o ^^
06:57:59 <o1lo01ol1o> hey ocramz
07:19:28 * hackage non-empty 0.3.1 - List-like structures with static restrictions on the number of elements  http://hackage.haskell.org/package/non-empty-0.3.1 (HenningThielemann)
07:23:06 <lordcirth> Wondering if anyone has used a tool like this to test their code? https://github.com/trailofbits/krf
07:34:27 * hackage network 3.0.0.0 - Low-level networking interface  http://hackage.haskell.org/package/network-3.0.0.0 (dukerutledge)
08:09:28 * hackage wai-enforce-https 0.0.1 - Enforce HTTPS in Wai server app safely.  http://hackage.haskell.org/package/wai-enforce-https-0.0.1 (MarekFajkus)
08:45:52 <sm> g'day all
08:46:24 <sm> isn't there a way to visualise Shake's rule dependencies ?
08:47:31 <__monty__> sm: Not that I know of but would be interesting.
08:57:54 <sm> it seems like the HTML profile report might have this capability but it's hard to tell
09:00:38 <sm> ah yes.. "Rule graph", once I figure out how to "group more aggressively"
09:05:08 <__monty__> Huh, TIL, thanks. https://cdn.rawgit.com/ndmitchell/shake/35fbe03c8d3bafeae17b58af89497ff3fdd54b22/html/demo.html
09:10:37 <sm> Shake makes me feel.. not smart enough :)
09:11:06 <__monty__> I'm pretty sure that's just par for the build system.
09:11:10 <sm> but it's impressive
09:11:55 <sm> I have more nodes than it wants to graph.. I can exclude some.. just need to figure out how to group 
09:12:48 <Welkin> why does threadDelay take the duration in microseconds instead of milliseconds like every other language?
09:13:01 <Welkin> I always forget that and think it's milliseconds and end up getting the wrong behavior
09:13:09 <__monty__> Sounds like a pretty big build system.
09:16:23 <sm> not really.. Shake wants to graph at most 250 nodes, and I'm generating a bunch of versioned docs. Excluding these helped: !name(/(doc|images|js|css|fonts)\//)
09:16:56 <sm> that's a useful graph
09:17:25 <Welkin> does anyone know why well-typed and other companies have stopped using cloud haskell, and what they are using instead? Bassed on a comment in paragrah 3 here https://github.com/haskell-distributed/distributed-process/wiki/High-Level-Redesign-Proposal
09:17:52 <iqubic> what's the point of comonads?
09:28:56 <wroathe> Wow, deleting the dist-newstyle directory basically causes HIE to explode in vscode
09:34:19 <sm> heh
09:34:39 <sm> haskell IDE tools explode easily
09:35:53 <wroathe> Doesn't really seem to be many options if you don't want to use EMACS :(
09:35:59 <wroathe> At least on OSX
09:36:05 <mmaruseacph2> vim ftw
09:36:34 <mmaruseacph2> but don't want this to turn into another editor flame, so I'll go back to other stuff
09:37:34 <wroathe> mmaruseacph2: What plugins are you using to make that bearable?
09:37:51 <lukelau> wroathe: VS code and languageclient-neovim work pretty decently with hie on macOS
09:38:32 <lukelau> Although generally VS code is typically the “best-in-class” client since its developed in tandem with LSP itself
09:39:39 <wroathe> lukelau: Yeah, in this case the thing that's causing the explosion is this: https://github.com/haskell/haskell-ide-engine/issues/1015
09:39:50 <wroathe> So the client itself isn't the problem
09:40:10 <wroathe> HIE and Cabal seem like a match destined for failure
09:40:12 <__monty__> wroathe: Practically none, just ghcid in a tmux split does the job for me.
09:41:09 <wroathe> __monty__: yeah, I've seen people doing that
09:41:42 <wroathe> __monty__: As a general rule of thumb I try not to keep things in my short term memory that I can look up later, and so I end up spending a lot of time hunting for types in GHCI
09:41:54 <wroathe> __monty__: It's nice to have the "hover and show me the type" feature of modern IDEs
09:42:01 <lukelau> Ah yes, we’re waiting on a lot of build-tools upstream, namely cabal-helper. Hopefully it should be coming soon. dxld has been making great progress on it
09:43:52 <__monty__> wroathe: The ones I actually use are easy-align (I like code alignment), haskell-vim (better syntax coloring or something, could probably live without) and haskellConcealPlus (frought with annoyances, especially if you like alignment). The only thing I think I'll still set up is some integration with brittany, that'd mostly replace easy-align but I actually use that outside haskell mostly : )
09:45:23 <__monty__> wroathe: I just replace with a hole and write the file if I really need that : ) Usually the errors are the type signatures I care about anyway though.
09:45:43 <sm> favourite editor + ghcid + a ghci prompt is what I use quite often
09:46:27 <__monty__> Yeah, I usually do a back and forth with ghcid, then load it up in ghci to test the functionality, rinse and repeat.
09:49:04 <wroathe> Yeah, I might have to commit to a process change here then
09:49:06 <wroathe> Thanks guys
09:52:10 <Welkin> how do you know everyone here is male?
09:52:48 <lordcirth> Welkin, https://www.thefreedictionary.com/guys 2. guys Informal Persons of either sex.
09:56:38 <Welkin> your ink to freedictionary.com does not convince me
09:56:40 <Welkin> link
09:56:48 <glguy> No, debating that is not in topic here
09:57:19 <aldum> not just the link, No Girls on the Internet rule
09:58:09 <lordcirth> It is indeed offtopic
09:59:04 <Welkin> so does anyone know why companies have moved away from cloud haskell?
09:59:23 <Welkin> I have found some possible reasons in a few redit threads
09:59:40 <Welkin> and also the fact that "cloud haskell is erlang-in-haskell" is a lie
10:00:24 <wroathe> What I meant to say was, "Thanks, presumably sentient beings of no specific gender, race, religion, creed, or dietary restrictions"
10:00:36 <Welkin> it implement an actor model with an api that somewhat resembles erlang, but does not have the same characteristics of erlang
10:04:26 <Welkin> it looks like the restart strategies are different too
10:04:29 <[exa]> Welkin: I'd suspect simpler reasons... distributed computing is hard already, so why would a company complicate it further with haskell when there's another industry-standard language for that?
10:04:53 <Welkin> well it's not like they switched to erlang
10:04:57 <Welkin> they are still using haskell
10:05:04 <pikajude> hey, what's the magic spell I need to pass to "cabal build" to give my linker the -v flag?
10:05:43 <Welkin> I read in a reddit thread that istead of an actor model, they are using normal haskell servers with rest apis managed by a (language agnostic) service discovery layer
10:05:52 <Welkin> which is totally fine too
10:07:28 <[exa]> Welkin: I'm reading the redesign proposal btw
10:08:40 <[exa]> it kindof looks like the distributed model of the apps isn't that central to their requirements
10:09:23 <[exa]> there are simpler ways to do distributed stuff that rely on much simpler requirements than cloud haskell imho
10:10:37 <[exa]> btw is there any material on process scheduling and load balancing in CH?
10:14:15 <Welkin> no idea
10:14:23 <Welkin> I find that resources on it are slim
10:14:37 <Welkin> there are at least several books on erlang, and the docs are extensive
10:14:46 <[exa]> that's a problem for sure
10:14:49 <Welkin> I learned erlang so I could "use cloud haskell"
10:14:55 <Welkin> but I don't know if I will even bother now
10:15:51 <[exa]> like, imagine you have a datacenter full of servers and you need to find an admin guy who will be on phone to keep it running, under the condition "we're running something largely undocumented that does funny distributed computation"
10:17:15 <Welkin> well yes, there is a consulting company that just does erlang called Erlang Solutions
10:19:17 <Welkin> they seem to by a top-level sponsor at every erlang-related conference
10:19:21 <wroathe> Is there a list of language extensions that will become part of "core haskell" as of 2020?
10:20:11 <Welkin> there is haskell 2020 in the works?
10:20:57 <__monty__> Haskell' (haskell prime) is supposed to be the next haskell standard. Afaik it's been in the works for years with no real conclusion in sight though.
10:21:14 <__monty__> So probably look for GHC planning documents or something?
10:21:39 <Welkin> look on trac
10:22:00 <Welkin> https://ghc.haskell.org/trac/ghc/wiki
11:05:39 <wroathe> So GHC.Generics introduces a data type, Meta, that has one value constructor, MetaData, that has type:
11:05:46 <wroathe> :i MetaData
11:05:56 <wroathe> :i GHC.Generics.MetaData
11:05:58 * hackage hakyll-images 0.3.1 - Hakyll utilities to work with images  http://hackage.haskell.org/package/hakyll-images-0.3.1 (LaurentRDC)
11:06:15 <wroathe> MetaData :: Symbol -> Symbol -> Symbol -> Bool -> Meta
11:06:34 <wroathe> Symbol is an empty type: 
11:06:48 <wroathe> data Symbol -- Defined in ‘GHC.Types’
11:07:21 <wroathe> From what I've gathered, the whole point here is to use DataKinds, to promote the value constructor MetaData
11:07:34 <wroathe> 'MetaData :: Symbol -> Symbol -> Symbol -> Bool -> Meta
11:07:48 <cocreature> the definition of Symbol is misleading. it’s the kind of type-level strings
11:07:49 <wroathe> So at the type level we're basically annotating a "Meta" type with 3 strings and a boolean value
11:07:53 <koz_> wroathe: Symbol is String, raised to the type level.
11:08:06 <koz_> Yikes, cocreature ninja'd me.
11:08:43 <wroathe> So the question is, is it possible to produce a VALUE of type Meta? MetaData :: Symbol -> Symbol -> Symbol -> Bool -> Meta
11:08:50 <wroathe> If Symbol doesn't have any values?
11:09:35 <cocreature> you can technically stuff bottom values in there (e.g. error "foobar") but we often pretend those don’t exist and in that case the answer is no
11:10:22 <wroathe> So it would be fair then to say that most of the data constructors in GHC.Generics only serve the purpose of being a specification for the promoted data constructor (i.e. at the type level)?
11:10:55 <cocreature> I haven’t counted if it actually applies to most but it certainly applies to some of them
11:11:31 <wroathe> I should specify that my statement would be true for data constructors that require values of uninhabited types
11:11:38 <wroathe> So Void, Symbol, etc
11:14:38 <wroathe> Now if that's all true, wouldn't it make more sense to just use phantom type params? Rather than creating useless data constructors?
11:14:50 <wroathe> e.g. data Foo (a :: Symbol) (b :: Symbol) (c :: Symbol) (d :: Bool)
11:15:00 <wroathe> Foo :: Symbol -> Symbol -> Symbol -> Bool -> *
11:16:12 <cocreature> the problem with that is that it doesn’t give you a new kind
11:17:00 <cocreature> so especially once you add multiple constructors it gets really awkward when you try to express that with type parameters
11:17:44 <Solonarv> Sure you can do that, that's how people did type-level programming before DataKinds
11:20:56 <nshepperd1> It's not a useless data constructor. It's useful, because it can be promoted :p
11:21:53 <wroathe> nshepperd1: It's useless in the sense that it can't be used to produce values
11:22:37 <nshepperd1> That's fine
11:22:55 <wroathe> cocreature: On the producing of a new kind...
11:23:06 <wroathe> :k Foo is Foo :: Symbol -> Symbol -> Symbol -> Bool -> *
11:23:08 <lambdabot> error: parse error on input ‘::’
11:23:23 <wroathe> k MetaData is MetaData :: Symbol -> Symbol -> Symbol -> Bool -> Meta
11:23:27 <nshepperd1> The difference between data constructors and their promoted versions goes away in DependentHaskell anyway
11:23:38 <wroathe> and :k Meta is Meta :: *
11:23:49 <wroathe> So really it just produces a kind alias, right?
11:23:58 <wroathe> Meta being an alias for Type
11:24:02 <nshepperd1> No
11:24:20 <nshepperd1> The kind of Meta is type
11:24:28 <nshepperd1> It's not equal to Type
11:24:43 <nshepperd1> You can't use them in the same spot
11:26:24 <cocreature> and importantly that kind is closed, once you have something of kind Meta, you know it was produced by one of the three constructors so you can pattern match on it in a type family, …
11:31:32 <wroathe> That distinction seems somewhat arbitrary though (I haven't yet gotten to type families and pattern matching at the type level though..)
11:31:53 <wroathe> ::k Maybe (MetaData "foo" "bar" "baz" False)
11:32:08 <wroathe> Gives me that usual "expected type, but got kind Meta
11:32:11 <Bixbox> Is there a way to move the config directory ".ghc", such as an environment variable?
11:32:23 <wroathe> ::k Maybe (Foo "foo" "bar" "baz" False) gives me Maybe (Foo "foo" "bar" "baz" False) :: *
11:34:45 <cocreature> wroathe: at the value-level it’s pretty useful to be able to narrow down the kind of values that users can possible pass to you to those that have a specific type. the type-level isn’t that different here. by having a separate kind you can limit the kind of types that users can pass to you to those of a specific kind
11:36:42 <nshepperd1> wroathe: yes, the fact that you can't apply Maybe to a Meta is a feature
11:40:48 <wroathe> So with my phantom types example earlier, is there a way to specific that applying Foo to four arguments of kind Symbol Symbol Symbol Bool actually produces a kind Foo instead of kind Type?
11:41:02 <wroathe> Without using the DataKinds approach?
11:41:26 <cocreature> no
11:41:47 <cocreature> DataKinds are the only way to introduce new kinds atm
11:42:08 <pie___> does anyone know when the next episode of https://blog.sumtypeofway.com/recursion-schemes-part-iv-time-is-of-the-essence/ is coming out? :P
11:43:49 <wroathe> As a newcomer to this kind of type level programming in Haskell it's been challenging to to connect these concepts to how they impact the program at runtime
11:44:07 <wroathe> It sounds like the last big missing piece for me is these type families
11:46:10 <cocreature> pie___: there are already two newer episodes?
11:55:13 <Welkin> episodes of True Detective?
11:55:16 <Welkin> that reminds me
11:55:26 <Welkin> that's already out!
11:59:42 <pie___> cocreature, oh i guess i somehow messed up navigating the site then
12:01:27 <wroathe> Right, so I'm still reading a bit on type families, but I did notice the type family instance that was derived by GHC for my custom datatype seems to be a way of translating one type into another type
12:02:08 <wroathe> So an instance of the typeclass Generic contains both 1. A way to convert values between two types and 2. A mapping of one type to another
12:05:07 <wroathe> To the "representation" type, that is
12:07:09 <wroathe> You can't really convert safely between two generic types then it seems to me. Converting a value of type A B C to type A B would discard C
13:00:57 * hackage red-black-record 1.0.0.2 - Extensible records and variants indexed by a type-level Red-Black tree.  http://hackage.haskell.org/package/red-black-record-1.0.0.2 (DanielDiazCarrete)
13:10:00 <PrimHelios> i'm using persistent and yesod, and one of my queries is just hanging. no errors, no timeout, it just never finishes. anyone know what might be the issue? relevant code: https://bitbucket.org/PrimordialHelios/hunters/src/e1096d87bd76829b314c80fef282b1e70be852d7/src/Application.hs?at=master&fileviewer=file-view-default#Application.hs-72
13:13:55 <zachk> how do I tell a user something using lambdabot, a message for when they are on? 
13:14:47 <[exa]> zachk: lambdabot is self-documenting, send him a @listmodules message in query
13:16:27 <[exa]> IIRC it's something like @tell zachk message
13:17:20 <QZI1> anyone know oasis or https://becausetheinternet.ga You should join, its a really good site with a calm userbase, plus its a clone of miiverse without the bad parts v@ChanServ @Sigyn _6a68 __4matter __monty__ _ceb _deepfire _flow_ _kwstas _lawlesseel a3Dman a_ ab9rf abbe abhir00p[m] abhixec abra0 abuss acarrico acidjnk acidrain_burns[m acowley acro adamCS adamse adarshaj Adeon adi2612[m] adius Adluc adw[m] adziahel[m] AfC agrif agschaid[m]
13:22:21 <iqubic> Can we ban this user?
13:25:48 <Solonarv> they already got kicked by freenode's spam etection
13:47:57 * hackage list-t 1.0.3.1 - ListT done right  http://hackage.haskell.org/package/list-t-1.0.3.1 (NikitaVolkov)
14:53:34 <utdemir> Hey. Quick question. How many MVar's are too many? I'm planning to use them for a projects, and trying to weight the scalability. Would Haskell's RTS handle 20 million MVar's and 20 million green threads (most of them are blocked on one of those MVar's)?
14:54:04 <zachk> whats your chance of a deadlock in your code with that?
14:54:15 <zachk> might want TVars instead
14:55:41 <zachk> that does sound like a bit much for a regular laptop though 
14:56:04 <utdemir> zachk: Hopefully I will be able to write those threads in a way they don't fail randomly.
14:57:22 <utdemir> The thing is each one of those MVar's will be written just once and read just a few times. I am trying to model a dependency graph, and planning to use lightweight threads as nodes and MVar's as "block this thread while the dependencies are not satisfied).
14:57:54 <utdemir> So my hope is that an empty MVar has no-cost to the scheduler and so as a thread blocked on a MVar.
15:05:28 * hackage haxr 3000.11.3 - XML-RPC client and server library.  http://hackage.haskell.org/package/haxr-3000.11.3 (BrentYorgey)
15:51:45 <ibloom> Is there a library function for composition within applicative functors f of type f (b -> c) -> f (a -> b) -> f (a -> c)
15:52:31 <hpc> :t (<.>)
15:52:32 <lambdabot> Indexable (i, j) p => (Indexed i s t -> r) -> (Indexed j a b -> s -> t) -> p a b -> r
15:52:37 <hpc> eh, worth a try
15:52:38 <ibloom> Hoogle didn’t seem to find one and I didn’t want to reinvent the wheel.
15:52:40 <hpc> ibloom: not sure
15:53:08 <hpc> :t \fs gs -> (.) <$> fs <*> gs -- it's pretty simple anyway
15:53:09 <lambdabot> Applicative f => f (b -> c) -> f (a -> b) -> f (a -> c)
15:53:15 <ibloom> Basically I have a vector of functions and I want to compose it with another vector of functions
15:53:34 <hpc> :t \fs gs xs -> (.) <$> fs <*> gs <*> xs -- it's pretty simple anyway
15:53:36 <lambdabot> Applicative f => f (b1 -> b2) -> f (a -> b1) -> f a -> f b2
15:53:57 <hpc> and easy to eta-expand even!
15:54:04 <ibloom> I’ll try that thanks.
15:55:28 * hackage network-bsd 2.8.1.0 - POSIX network database (<netdb.h>) API  http://hackage.haskell.org/package/network-bsd-2.8.1.0 (HerbertValerioRiedel)
15:58:03 <ibloom> hpc: I ended up with this: (<:<) :: Applicative f => f (b -> c) -> f (a -> b) -> f (a -> c)
15:58:04 <ibloom> f <:< g =  (.) <$> f <*> g
15:59:49 <wroathe> You should've named it <(^.^)>
16:00:37 <hpc> @let f 💩 g = (.) <$> f <*> g
16:00:38 <lambdabot>  Defined.
16:01:08 <amalloy> ibloom: (<:<) = liftA2 (.), right?
16:01:34 <ibloom> Aha
16:01:42 <ibloom> I think you may be right.
16:01:56 <hpc> yep
16:02:24 <hpc> (<*>) is a little bit closer to banana brackets though, so i prefer it
16:09:15 <__monty__> Isn't <:< = pure (.)?
16:09:46 <hpc> :t pure (.)
16:09:47 <lambdabot> Applicative f => f ((b -> c) -> (a -> b) -> a -> c)
16:10:27 <ibloom> liftA2 (.) compiles right
16:11:33 <__monty__> Thanks, hpc.
16:11:39 <__monty__> So many ways to be wrong.
16:11:53 <hpc> and the type system catches most of them :D
16:18:47 <wroathe> https://github.com/bos/aeson/blob/master/Data/Aeson/Types/ToJSON.hs#L703
16:19:06 <wroathe> So Generics + Multi param type classes is basically voodoo black magic of the highest order
16:44:58 * hackage network-uri-static 0.1.2.1 - A small utility to declare type-safe static URIs  http://hackage.haskell.org/package/network-uri-static-0.1.2.1 (snak)
16:46:07 <koz_> Is there anything written in Haskell similar to cookiecutter? Basically a CLI generator of multiple files based on some kind of file-based config.
16:49:58 <MarcelineVQ> sure seems like there would be something like that around somewhere
16:50:38 <MarcelineVQ> googling "haskell project generator" has http://hackage.haskell.org/package/rob as hit one, looks pretty recent
16:52:49 <koz_> MarcelineVQ: rob looks perfect.
16:52:51 <koz_> Thank you!
16:53:14 <MarcelineVQ> might use it meself :>
16:54:00 <koz_> MarcelineVQ: I prefer Haskell tools to Python tools, so yeah. :)
16:54:07 <koz_> (plus, cookiecutter can't generate single files)
16:54:12 <koz_> (which is a bit ridiculous)
16:58:08 <koz_> MarcelineVQ: I'm having trouble getting this to build with GHC 8.6 _or_ 8.4.
16:59:41 <koz_> If you have other suggestions or options, I am all ears.
16:59:46 <koz_> (and yes I have reported this problem)
17:07:53 <MarcelineVQ> I've not responded because I'm fighting my tooling unrelated to trying to test out rob
17:08:03 <koz_> MarcelineVQ: Sounds about right.
17:08:06 <koz_> I'll just PR a fix.
17:08:18 <koz_> (it's mostly overly conservative boundaries for no apparently sensible reason)
17:08:45 <MarcelineVQ> if that's all it is you can try --allow-newer or whatever
17:08:57 <koz_> MarcelineVQ: Yeah, it's more-or-less what I'm doing.
17:09:31 <koz_> I'll send a nice PR if it works.
17:48:00 <dmwit> koz_: https://github.com/kowainik/summoner (MarcelineVQ, too, maybe)
17:49:58 <koz_> dmwit: Isn't summoner for _Haskell_ projects specifically?
17:50:13 <koz_> cookiecutter is for anything you can provide a config and files for.
17:50:44 <dmwit> Yes, Haskell projects only.
17:51:48 <Welkin> so why would you use that instead of cabal init?
17:51:56 <Welkin> it looks like it does the same thing, but with a fancy tui
17:52:18 <dmwit> cabal init doesn't set up CI or stack stuff for you.
17:52:57 <koz_> Or .gitignore.
17:52:57 <dmwit> Even staying in the realm of cabal this does more things, like make a bare-bones test suite or benchmark, understands that a package can provide both libraries and executables, etc.
17:53:06 <Welkin> I don't see the value in doing that
17:53:13 <koz_> Welkin: Good for you then. :P
17:53:15 <Welkin> I mean, it takes seconds to add a .gitignore or a stack file
17:53:24 <koz_> Since for me, cabal and stack are both _woefully_ inadequate in this regard.
17:53:33 <Welkin> it just seems superfluous, but if you have fun with it thats fine too
17:53:49 <koz_> Welkin: Once again, if that's sufficient for your needs, great!
17:53:53 <koz_> Not mine, however.
17:54:44 <Welkin> it reminds me too much of create-react-app which people use without understanding how to do anything without it, and then they get stuck thinking they need a scaffolding tool for everything in every language
17:55:33 <Welkin> not quite at that level
17:58:04 * dmwit . o O ( Why would you use cabal init instead of vim? )
17:58:25 * koz_ . o O (Why would you use vim instead of echo? )
18:00:23 <Welkin> I wanted to understand what made summor different from a simple `cabal init`
18:00:27 <Welkin> summoner*
18:01:17 <Welkin> sarcasm isn't appreciated
18:01:50 <dmwit> No, you wanted to boast about how primitive of a tool you can use and get the same effect.
18:02:03 <dmwit> If it was a pure information request, you would have been pleased to learn the answer.
18:02:45 <Welkin> if it came out that way, it was not my intention
18:02:52 <geekosaur> cp -a. not that I usually bother with tools or frameworks, my use cases vary too much
18:03:26 <Welkin> it would be wise to assume no malice when interacting with other people through pure text
18:03:51 <Welkin> you lose all of the visual and verbal cues you get with face-to-face interaction
18:18:08 <Arahael> For some reason, when my parser enters an infinite loop during a unit test, when I hit ^c, I manage to "kill" the tests.  Yet, in the background, the infinite loop continues, burning CPU and memory.
18:18:20 <Arahael> How do I ensure that a unit test can't background the task like that?
18:18:47 <Arahael> I'm using Tasty.HUnit, if that matters.
18:25:00 <Cale> Arahael: Are you running it from ghci?
18:25:37 <Arahael> Cale: No - just 'stack test'.
18:25:57 <Cale> hm, interesting
18:26:33 <Cale> What process is still running?
18:27:28 <Arahael> Cale: The original test application, it's as if 'stack test' is a shell that runs the real unit tests.  Which is technically true, but bizarre.
18:28:00 <Cale> Yeah, that seems like it could possibly be considered a stack bug
18:28:50 <kadoban> Seems unlikely. Last I knew, 'stack test' did pretty much what running the test executable did, except it builds it first.
18:29:40 <Cale> kadoban: But if ctrl-C just kills stack test, but doesn't clean up the child process, that's kind of weird
18:29:58 <sm> Arahael: I get that constantly, but with ghcid. It's a real pain
18:31:18 <Arahael> Not just me, then. :(
18:32:05 <sm> I find it very easy to spawn one (or more) rogue ghc processes without noticing and heating up my machine or losing control as it starts swapping
18:32:15 <Arahael> Yep
18:32:37 <sm> was actually considering a cron job to kill big ghc processes
18:32:52 <Arahael> I quite often get these as I frequently have infinite loops
18:34:27 <sm> do you use threads in your code ? have you compiled with or without -threaded ?
18:35:05 <sm> it sounds unusual, but maybe there's something in stack's tracker
18:38:33 <geekosaur> I think part of the problem is that the ^C handler only sets a flag that is checked on the next allocation. if there's no allocation going on because tight loop, it effectively is ignored
18:40:14 <geekosaur> (normally, at least on POSIX, ^C is sent to all processes in the process group so "stack test" shouldn't be directly killing its child. Although it might be arguable here anyway. and if they run it in a different process group for some reason, they do have to kill it themselves)
18:43:58 * hackage dejafu 1.12.0.0 - A library for unit-testing concurrent programs.  http://hackage.haskell.org/package/dejafu-1.12.0.0 (barrucadu)
18:44:58 * hackage tasty-dejafu 1.2.1.0, hunit-dejafu 1.2.1.0 (barrucadu): https://qbin.io/phase-steps-ocon
18:46:55 <AfC> I've had zombie ghc child processes underneath ghcid (so, ghci) when I accidentally get myself into a blocked on MVar or STM fuckup.
18:47:41 <AfC> I keep an eye on CPU and `kill -9` the ghc process if it happens.
18:47:53 <geekosaur> yep. and ther have been reports of ghci doing it too, which is why I tracked this down
18:47:57 <geekosaur> without ghcid
18:48:21 <geekosaur> we kinda need a better way to handle SIGINT in ghc's runtime
18:48:52 <geekosaur> (I know why they do it that way, it's so they don't throw the exception when internals are in an undefined state. But still.)
18:49:07 <AfC> In my case, I have a SIGINT handler which then does MVar things. Asking for trouble, somewhat.
18:52:01 <AfC> Problem turned out to be lazy evaluation and an exception hadn't actually been thrown because laziness is awesome when I want it and awful when I don't. Really expect the compiler to ve smart enough to figure it out without me having to think about it, damnit.
18:57:57 <geekosaur> ..as if
19:30:04 <Arahael> sm: Not knowingly, no.  I think the HUnit framework might, though.
19:30:14 <Arahael> geekosaur: I think that might be it.
19:30:50 <Arahael> It's a bit annoying though because my application chews up 1.5 GB of memory... ANd then effectively busyloops.
20:46:25 <energizer> is this terminology correct? "(int -> int) is the type of a function that takes an int and returns an int"
20:48:27 <MarcelineVQ> Nearly, Int is a type, int is a type variable called int. by type variable I mean (int -> int) is equivalent to (a -> a) while (Int -> Int) is the type of a function that takes an Int and results in an Int
20:49:30 <energizer> ok
22:23:27 * hackage sets 0.0.6.1 - Ducktyped set interface for Haskell containers.  http://hackage.haskell.org/package/sets-0.0.6.1 (athanclark)
22:36:19 <ajk_> Hello, I am a bit of a beginner so forgive me if this is obvious but if i have a list [1..] does indexing say 5 mean that all values upto that index are also evaluated?
22:36:33 <c_wraith> no
22:36:50 <c_wraith> > [undefined, undefined, 'Q', undefined] !! 2
22:36:52 <lambdabot>  'Q'
22:37:32 <c_wraith> the (:) constructors are evaluted, but first arguments to that constructor are not
22:41:57 <ajk_> Thanks! I was having a hard time trying to understand the memoization with recursion example on the wiki, it's a pretty neat trick
23:35:23 <janat08> is there an article or book to tell how to navigate/administer a project as in with debugging testing and running it
23:37:30 <janat08> there's nix-env running in terminal for so long that I have no clue what I asked it to do
23:38:20 <koz_> janat08: That's rather too broad a question to have a sensible answer.
23:38:34 <koz_> What kind of project? What sort of testing? What problem are you trying to debug? Etc etc etc.
23:39:23 <janat08> well JS they'll have package.json that will have test/debug/run commands
23:39:34 <koz_> janat08: Package.json is a file format.
23:39:44 <koz_> It doesn't have any kind of commands by its very definition.
23:40:46 <janat08> well you're suppose to describe these kind of commands for npm to run for you
23:41:11 <koz_> janat08: Yes, but that's not the same thing. I'm being picky on your terminology and choice of words because this is _literally_ what I just chided you for.
23:41:23 <koz_> Sensibly phrasing things is a big first step to getting answers that you want.
23:41:48 <koz_> So, was your original question something like 'How do I define, in my Haskell project, how I want tests to be run?'?
23:41:52 <koz_> Or was it something else?
23:44:45 <janat08> I'm trying to contribute to a project, it has nix and stack. I don't see any top level scripts for running/testing in stack.yaml
23:44:58 <koz_> Because stack.yaml doesn't contain anything like that.
23:45:37 <koz_> Nor is it meant to.
23:45:44 <koz_> Since it doesn't serve that purpose.
23:46:13 <koz_> Have you looked at any of Stack's beginner documentation?
23:46:20 <koz_> Or any of Stack's documentation as such?
23:52:04 <janat08> I came from JS that is far to savage for me to have really considered that
23:52:25 <koz_> janat08: I don't even know how to parse that sentence.
23:52:38 <koz_> (and I take it the answer to my previous two questions is 'No', then?)
23:53:02 <janat08> ye im reading that
23:53:21 <koz_> Well, finish reading that, and if something still doesn't make sense after that, feel free to ask a more specific question.
