01:42:25 <Nexilva> maerwald: haha
01:42:27 <Nexilva> Hey guys
01:42:48 <Nexilva> https://prajitr.github.io/quick-haskell-syntax/ Whoever linked me this, thank you. This was by far the most helpful thing I've read about Haskell.
01:42:58 * Nexilva gives two thumbs up.
01:43:33 <Nexilva> Now I can actually start learning it and not feel like an idiot.
01:43:51 <Nexilva> I'm like, what am I even looking at this entire week. This doc makes it so clear cut. Wow.
02:23:40 <DigitalKiwi> the more i learn the more i feel like an idiot
02:24:29 <c_wraith> just remember https://patrickmn.com/software/the-haskell-pyramid/
02:25:53 <Nexilva> I have that bookmarked since yesterday
02:26:25 <Nexilva> See, this github doc explains things so clearly, that now when I read docs and books and stuff like gento intro, I know now what the heck I am looking at.
02:26:56 <Nexilva> I think this github link should be the very first #1 thing people are introduced to in Haskell, then you can start teaching them about all the concepts of functional programming.
02:27:18 <Nexilva> They NEED to be able to know what they are looking at when they read the books/docs/concepts etc. 
02:28:14 <Nexilva> For one solid week, reading did not help me. I could not grasp anything. I had no idea what code I was looking at or what the symbols/syntax did. So all the concepts went over my head. Now they're starting to be clear, because I know now what I'm looking at.
02:28:28 <Nexilva> I sincerely think this would be a much better learning approach to Haskell.
02:28:36 <Nexilva> Otherwise, it is simply just too confusing.
02:29:04 <c_wraith> I find it strange that doc helps  you, since it leaves out so many key things
02:29:18 <Nexilva> Man, I'm brand new.
02:29:54 <Nexilva> I don't know what's missing or not. As a programmer in other languages, I find this doc to be most helpful so far.
02:30:21 <Nexilva> allEqual :: (Eq a) => a -> a -> a
02:30:36 <Nexilva> Before this document, a weeklong of reading and I didn't know what the heck I was looking at.
02:31:03 <Nexilva> Now I know it's a type signature and what it's defining and expecting and all that, whatever the doc says. I'm sure there's tons more to learn, but this is what I needed.
02:32:23 <Nexilva> This should be step 0. Then step 1 should be however you want them to learn Haskell, gentle intro or learn you a haskell for greater good or whatever.
02:33:59 <c_wraith> many people succeed with the syntax intro in other sources.  You should be careful about assuming that what works for you is necessary for everyone.
02:34:12 <Nexilva> (\x -> x + x) <-- been using that in Xmonad, and had no idea this was anonymous function.
02:34:21 <Nexilva> I know anon functions, I've used them in other langs.
02:34:50 <cocreature> well any Haskell intro, e.g. lyah is going to teach you that this is an anonymous function
02:35:09 <Nexilva> c_wraith: I'm not unique or special. There are countless others like me who learn in this manner the best.
02:35:55 <c_wraith> Nexilva: I'm not saying "manner".  I'm saying that many people can read and understand the syntax explanations in other sources.  Because every single introduction covers syntax.
02:36:26 <Nexilva> Everything else failed me so far.
02:37:20 <Nexilva> If they also cover syntax, it's more spread out over many chapters and has a lot of reading before you can graasp it all, as they also teach you theory along with it.
02:37:47 <Nexilva> This document focuses only on the syntax part, condenses it, and that makes more sense to me, and now I can start reading all the other resources and won't feel lost.
02:38:45 <cocreature> a syntax guide is useful as a reference but on its own it’s not going to get you very far
02:39:12 <Nexilva> Very true, sir
02:49:01 <bwe> I have created servant API. I want to add one route returning HTML. For this I would like to use Spock. Can I integrate a Spock route in a servant API? Is it a good idea? Which would be better?
02:57:30 <c_wraith> bwe: Spock is based on WAI.  servant-server lets you create WAI middleware.  I'm sure you can hook those things together one way or another.
02:59:55 <bwe> I've just discovered servant-lucid. Looks like I do not even need Spock.
03:16:15 <larryba> hi. I think I recall there was some extension that lets you use same field names for different types, but I can't seem to find what it is called
03:16:38 <alp> yeah you can respond with HTML with any library of your chosing and teach servant about it: https://haskell-servant.readthedocs.io/en/stable/tutorial/Server.html#case-studies-servant-blaze-and-servant-lucid
03:16:49 <alp> and we have libs already for lucid abd blaze-html
03:17:30 <julianleviston> larryba: named field puns?
03:17:45 <alp> you could however use a 'Raw' endpoint to serve a wai Application built with another framework/library too (might be useful in the future). it uses the same mechanism that we use for serving static files (https://haskell-servant.readthedocs.io/en/stable/tutorial/Server.html#serving-static-files)
03:17:57 <c_wraith> larryba: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-DuplicateRecordFields
03:18:25 <larryba> do name field puns or duplicate record fields allow lens to create generic lenses that work with both types?
03:19:20 <julianleviston> field accessors aren’t lenses
03:19:59 <julianleviston> they’re simply functions. lenses are focuses that can be used by other parts of he lens library to build up getters or setters or modifiers, etc.
03:20:01 <larryba> I know they aren't. I am talking about makeLenses macro
03:20:11 <julianleviston> Oh. sorry.
03:26:08 <bwe> alp: Thanks for your responses, will incorporate them.
03:27:29 <larryba> c_wraith, that doesn't seem to work as well as I hoped it would. two types with _name field, and _name x gives me error
03:27:53 <larryba> makeLenses can't create generic lens out of those two fields either
03:28:22 <c_wraith> that's about what I expected.  The current state of that extension is that it doesn't really work too well.
03:29:16 <larryba> so what does everyone do? typeaName, typebName?
03:30:23 <c_wraith> That's the easiest to do, at least.
03:30:50 <larryba> I could swear there was a way to make lens make one lens that works with multiple types, though
03:31:00 <larryba> automatically
03:31:53 <c_wraith> there's makeClassy
03:35:30 <larryba> that wasn't it
03:35:31 <coldpress_> is it possible to define two arrows circularly, where only part of the output of one is the input of the other? 
03:35:43 <larryba> but makeFields with three extensions made it work!
03:37:04 <larryba> types need to have _typeField name, and lens creates generic field lens
03:38:09 <larryba> this needs FlexibleInstances TypeSynonymInstances FunctionalDependencies TemplateHaskell
03:40:31 <fendor> when having a more complex record, how can I make sure that the structure is fully evaluated?
03:40:40 <larryba> can makeClassy make this possible, while having _name field in both types?
03:40:45 <larryba> that would be even better
03:41:42 <larryba> fendor, you can use deepseq, which will require NFData instance for your type, 
03:42:05 <fendor> larryba, ok, will try
03:43:03 <larryba> I think there's a way to automatically generate NFData instances 
03:46:52 <fendor> what if I can not automatically derive NFData because one of its records does not implement, however, I know that this is already evaluated and I do not really care about it? E.g. is it ok to implement it manually and invoke `rnf` on the members I am interested in?
03:48:13 <lebalifant> :q!
03:48:17 <larryba> it will work, though I'm not sure that is in the spirit of NFData class
03:50:00 <fendor> larryba, I agree, but I do not care :D it is for an assignment and I'd like to timeout an action but after the timeout, evaluation of the thunks start which takes a long time 
03:51:00 <c_wraith> if speed is your real concern, note that running rnf usually takes O(n) time.  Doing it at every step of an algorithm is not how to be performant.
03:52:26 <fendor> c_wraith, while I want to be performant, I also want to stop any work at a given point, e.g. 10 seconds into the future. I write the currently best solution to an IORef and I want to only write it to the IORef, iff it is fully evaluated 
03:52:58 <c_wraith> That just means make sure your algorithm evaluates correctly at each step. 
03:54:26 <fendor> complicated.
03:54:36 <fendor> but I am pretty sure, you are right
03:58:37 <WilliamHamilton[> lyxia: I'm very pleased with your show-combinators library! Finally I can use showsPrec without having to think explicitly about precedences! https://pastebin.com/raw/af8nzCRF
04:18:50 <Ariakenom> fendor: when the instance is iffy you can write a function that uses rnf, without implementing NFData for the record?
04:25:36 <fendor> Ariakenom, would that to be considered better?
04:26:14 <Ariakenom> if it isn't a "proper" NFData instance that makes sense yeah
04:31:58 <fendor> would that be a correct way to evaluate only the parts i care about? https://pastebin.com/MjjgBh33
04:37:31 <larryba> can I make my own typeclasses automatically derivable with derive keyword?
04:46:01 <Ariakenom> fendor: looks good to me
04:46:37 <fendor> Ariakenom, unfortunately, does not work :/
04:57:53 <larryba> if anyone cares, this is best compromise for me, and I'm pretty happy with it! field name with no ugly _ perifx, and generic lenses that work with multiple types.
04:57:56 <larryba> https://bpaste.net/show/a769d4567538
04:58:10 <larryba> prefix*
05:01:23 <larryba> example that actually compiles: https://bpaste.net/show/69a0e5f33161
05:34:01 <Wizek> is there an equivalent lens to `isJust`, e.g. through using `_Just`, or is the simplest way to use `to isJust`?
05:39:59 <Ariakenom> % :t _Just -- Wizek 
05:39:59 <yahb> Ariakenom: (Choice p, Applicative f) => p a (f b) -> p (Maybe a) (f (Maybe b))
05:40:43 <lyxia> % :t matches _Just
05:40:44 <yahb> lyxia: ; <interactive>:1:1: error:; * Variable not in scope: matches :: (p0 a0 (f0 b0) -> p0 (Maybe a0) (f0 (Maybe b0))) -> t; * Perhaps you meant one of these: `catches' (imported from Control.Monad.Error.Lens), `catches' (imported from Control.Exception)
05:41:17 <lyxia> % :t is _Just
05:41:18 <yahb> lyxia: ; <interactive>:1:1: error:; * Variable not in scope: is :: (p0 a0 (f0 b0) -> p0 (Maybe a0) (f0 (Maybe b0))) -> t; * Perhaps you meant one of these: `C.id' (imported from Control.Category), `id' (imported from Prelude), `iso' (imported from Control.Lens)
05:42:01 <lyxia> https://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-Extras.html#v:is
05:43:15 <larryba> what is lens operator variant of use and modifying?
05:43:40 <larryba> and assign
05:44:14 <Wizek> hmm, so maybe I could use it like ``` Right 1 `is` _Left ```
05:44:51 <Wizek> I wonder if there is a Getter variant that can be used like `a ^. b . c`
05:45:09 <Wizek> or maybe `to` is exactly how to get that Getter
05:47:26 <edd_> Out of interest, do people know if the demographic here is primarily hobbyists, academics, or people using Haskell in industry? I'm hoping to start using Haskell on some projects but I'd love to talk to someone who's already used it "in the wild" on a commercial project.
05:48:36 <__monty__> If I had to guess I'd say mostly hobbyists. The other categories are definitely represented though.
05:49:13 <edd_> Okay cool, good to know
05:49:38 <edd_> If anyone is using Haskell at work, and you see this, let me know! :P 
05:52:18 <Taneb> edd_: hey, I use Haskell at work
05:53:09 <Ariakenom> I'm a hobbyist. I've just used it for some calculations at work.
05:56:07 <xelxebar> I sort of straddle the hoobyist/academic line. I'm a math guy by training, and one of the things that originally got me into Haskell was using it as a playground to munge category theory ideas.
05:56:30 <c_wraith> I've done professional work in Haskell.
05:56:51 <c_wraith> But that was a while ago now
06:03:41 <Gurkenglas> Wizek, what do you need the boolean for?
06:04:21 <Gurkenglas> :t has _Just
06:04:22 <lambdabot> Maybe b -> Bool
06:11:45 <larryba> is there some hack or extension or TH that I can use to allow me to have cyclic imports?
06:12:31 <c_wraith> the way ghc supports cyclic imports is worse than not having them.
06:12:54 <c_wraith> https://wiki.haskell.org/Mutually_recursive_modules
06:20:18 <larryba> doesn't seem very pleasant
06:23:07 <__monty__> Are there good reasons for mutually recursive modules though?
06:32:27 * hackage OpenGLRaw 3.3.2.0 - A raw binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGLRaw-3.3.2.0 (SvenPanne)
06:35:27 <_deepfire> Re fused-effects:  I tried (runM (liftIO $ putStr "")) and failed: https://github.com/robrix/fused-effects/issues/96
06:35:45 <_deepfire> ..and then came up with this:  https://github.com/robrix/fused-effects/pull/97
06:36:10 <tdammers> suppose I have a s :: Set a, and I want (x :: a, xs :: Set a) such that insert x xs == s, but I don't actually care which x I'm getting; is there a way of achieving that with better complexity than O(log n)?
06:36:29 <_deepfire> As mentioned, there's much not to like about the implementation, but I could find no better way..
06:37:22 <tdammers> for context, the Set is used as a pool of available indexes; the reason I'm using a Set rather than a list is that those pools need to combine, for which set unions and differences are extremely convenient
06:38:43 <mouse07410> Newbie question. I need to pass linker options to GHC, using stack. And I need the linker to search certain lib directories in a given order. What are the config file options to do that, and which of these can also be done via command line options? And if there's a conflict between the config file and command line - who wins?
06:39:38 <mouse07410> Also, can I tell stack which compost binary to use, but just the version but something like "/usr/local/bin/ghc"?  I tried to ask in the haskell-stack, but got no response.
06:39:57 <c_wraith> tdammers: not with that data structure.
06:40:30 <mouse07410> "compost"->"compiler" (Freudian slip of the spell-checker?)
06:40:57 <tdammers> c_wraith: I was afraid that would be the answer :D
06:41:10 <tdammers> c_wraith: so what do you think I should use instead
06:42:51 <c_wraith> tdammers: depends on the nature of those pool combination operations
06:44:27 <tdammers> c_wraith: well, what I do is I have a data structure that maps string keys to integer keys for serialization purposes (the protocol is stateful, so clients are supposed to remember the name -> int key mapping); int keys are assigned dynamically, and I want to pick them such that they stay as small as possible
06:44:50 <c_wraith> do you reuse ints?
06:44:52 <tdammers> yes
06:45:10 <tdammers> otherwise they'd keep growing forever
06:45:26 <tdammers> and keeping them small means that if you never have more than, say, 256 of them, you can send them as single bytes
06:45:31 <tdammers> the protocol automatically adapts to that
06:45:39 <tdammers> (and I send a lot of indexes, so it does matte)
06:46:35 <c_wraith> where do combine operations come into the picture?
06:46:49 <tdammers> I take these data structures and diff them on one end, send the diff over the wire, and apply it on the other end
06:47:56 <tdammers> so when new mappings are introduced, those also travel over the wire, and so I need to make sure the allocation pools on both sides stay in sync
06:49:32 <tdammers> or maybe O(log n) isn't so bad; fields don't get added a lot, the bulk of operations is updating them, which doesn't touch the pool at all
06:50:26 <c_wraith> that's certainly simpler than trying to optimize that. :)
06:50:55 <tdammers> yeah, I'll stick with this, in the spirit of "make it right, THEN make it fast"
06:51:34 <tdammers> also I believe network overhead is going to dwarf the overhead of the whole diffing business anyway
07:02:50 <Nexilva> c_wraith: when do you sleep?
07:02:59 <Nexilva> Today is  Sunday. Is today your sleepy day?
07:03:02 <Nexilva> :)
07:03:11 <Nexilva> Mr. God? :D
07:04:38 <c_wraith> I...  slept from like 10am to 10pm yesterday, local time.  No, it makes no real sense.  My goal at this point (7 am local time) is to stay up until 9:30 pm or so so that I can function at work tomorrow.  But it's a...  stretch. 
07:05:01 <c_wraith> I'm not great at weekends
07:06:16 <WilliamHamilton[> weird thing, I have a hs file which contains an error: if I try to load it in ghci, ghci get stuck while computing this error (I'm forced to reboot every time): if someone uses nix I'd like if you tried to reproduce the error (I can pass the right nix-shell invocation)
07:19:57 * hackage pixela 0.3.1.0 - Pixela client.  http://hackage.haskell.org/package/pixela-0.3.1.0 (kakkun61)
07:26:42 <larryba> (foo.bar) is a lens that returns Int, what is the proper way of writing (foo.bar.show) (lens that applies show to the resulting int)
07:27:12 <mniip> that wouldn't be a lens
07:27:25 <larryba> oh, you're right
07:27:31 <mniip> foo.bar.to show
07:27:32 <larryba> can it be a Getter?
07:27:33 <mniip> is a Getter
07:27:42 <larryba> nice
08:30:45 <wroathe> The whole String -> Text, Text -> String thing is really unfortunate
08:40:20 <Gurkenglas> feels less bad to me when I consider it the drawback of the tradeoff in a language between existing libraries and legacy baggage
08:42:02 <wroathe> Yeah, there are always reasons
08:52:46 <tdammers> String / Text is actually a symptom of something I really love about Haskell culture - not letting a fear of breaking changes keep you from doing what you know to be right
08:53:30 <tdammers> and at the same time, no mindless novelty cult either - we don't generally throw away old things in favor of new things just because the new things are new
08:57:32 <wroathe> Well, maybe instead of complaining I should just ask... Is there a better way of concatenating String values with Text values then doing this: "foo" ++ T.unpack bar ++ "baz"?
08:58:11 <wroathe> It seems like the (++) function in Prelude should be polymorphic for IsString types just for sanity's sake
08:58:36 <MarcelineVQ> you can use <> as a more general ++
08:58:59 <MarcelineVQ> But it won't turn Text into​ String and String into Text
08:59:57 <larryba> tdammers, what things were thrown away re String/Text?
09:00:45 <monochrom> String itself.
09:01:22 <larryba> huh? String was dropped or something? since when?
09:01:40 <monochrom> No, we were saying we wouldn't throw away String.
09:02:42 <wroathe> Well, you'd have to argue against people storing characters in singly-linked lists to get rid of String :P
09:02:46 <larryba> that doesn't seem what tdammers' implied.. "not letting a fear of breaking changes keep you from doing what you know to be right"
09:02:51 <wroathe> Seems like a steep hill to climb
09:03:31 <monochrom> Also, maybe you should do T.pack "foo" <> bar <> T.pack "baz" instead.  I mean which type do you want the final result to be? Aim for that.
09:03:40 <Lycurgus> is it alleged that "the right thing" is clearly objective rather than a matter of taste/judgement?
09:04:31 <monochrom> larryba, that part refers to conceiving Text.
09:04:55 <larryba> how was that a breaking change?
09:05:12 <__monty__> monochrom: Or maybe use T.++ with OverloadedStrings so you don't have to write any (un)packs? (Not actually sure you need the monomorphized version of <> for it to work.)
09:05:54 <monochrom> Or maybe "Monad was subclass of no one but now subclass of Applicative".
09:09:13 <monochrom> Here is how objective and matter of judgment (even context) can coexist. The objectively right thing is to provide choices so you can choose based on judgment and context.
09:09:43 <tdammers> indeed
09:10:19 <tdammers> in the Monad / Applicative case, it was clear that linking the two in the class hierarchy was the correct thing to do, and the community actually voted to do it, despite the breaking change
09:10:21 <monochrom> And this is why Python-cultured people will hate the Haskell culture.
09:10:27 * hackage failable 0.1.0.3 - A 'Failable' error monad class to unify failure across monads that can fail  http://hackage.haskell.org/package/failable-0.1.0.3 (erick)
09:10:44 <tdammers> the ongoing MonadFail effort, I think, is a similar thing
09:11:20 <geekosaur> and has been developing for even longer than Monad / Applicative
09:11:34 <tdammers> yep
09:11:54 <tdammers> Monad / Applicative is mainly a library thing; MonadFail runs a bit deeper into the core language
09:12:05 <c_wraith> MonadFail is actually making progress!
09:12:13 <tdammers> I know, and that's a good thing
09:12:27 * hackage ttl-hashtables 1.1.0.0 - Extends hashtables so that entries added can be expired after a TTL  http://hackage.haskell.org/package/ttl-hashtables-1.1.0.0 (erick)
09:13:40 <geekosaur> ...has that person not heard of priority search queues
09:16:54 <tdammers> anyway, what I meant is that we have this culture of trying to do "the right thing", according to current insight, even if it causes some transitional pain
09:17:36 <tdammers> and this instinct of doing the right thing has gotten us into a situation where we have two different types for representing strings, and both are in widespread use, with no hope of fixing this in the foreseeable future
09:19:01 <monochrom> geekosaur: Ah but all existing priority search queues use Ord not Hashable for search.
09:19:26 <__monty__> I like backpack's solution to the problem though. Use whatever string representation that fits the expected interface.
09:19:41 <geekosaur> so why isn't it hashed-psq or whatever?
09:19:52 <monochrom> That part I agree!
09:20:01 * geekosaur has noticed that people keep reinventing the psq concept badly. see for example nscd, which even Sun got wrong
09:20:44 <monochrom> Maybe I should teach psq next time I teach a data structure course.
09:21:09 <__monty__> Psq doesn't sound like a data structure that automatically erases entries though.
09:21:18 <cocreature> monochrom: nah, psqueues has Data.HashPSQ :)
09:21:31 <monochrom> Oh noes.
09:21:35 <cocreature> (in addition to Data.OrdPSQ and Data.IntPSQ)
09:21:43 <geekosaur> heh
09:21:49 <monochrom> Yeah psqueues is cool.
09:22:17 <geekosaur> __monty__, no, but the priority part lets you find the oldest entry immediately and remove if needed, so it does the hard part
09:22:55 <geekosaur> and makes sure everything remains consistent, which is what most of the ad hoc solutions get wrong in one way or another
09:23:26 <monochrom> Oh well the whole computing industry simply loves to drop out of school and then goes on to reinvent but screw up what's already taught in school.
09:23:35 <__monty__> geekosaur: But there's no way to find it as a TTL data structure if you don't already know that. Just saying the reimplementations are probably due to suboptimal SEO : )
09:24:26 <monochrom> __monty__, the reason people have not heard of "priority queue" is because they dropped out of school and are proud of it.
09:25:09 <monochrom> (Not that schools would teach psq.  But schools teach "dictionary" and "priority queue" separately so first off you know the right words.)
09:25:17 <tdammers> they didn't cover priority queues in highschool, I never had any formal CS education, and I still know about them
09:25:48 <monochrom> Hey I never had a course on category theory either!
09:25:49 <tdammers> I've also seen tons of shitty programmers with degrees who didn't know what a priority queue was
09:26:01 <monochrom> We are the exceptions. We are the freaks. OK?
09:26:12 <tdammers> don't blame formal education or lack thereof for individuals' ignorance
09:26:59 <wroathe> Hey, my father was an ignorant, and his father before him. I come from a long line of ignorants.
09:27:19 <monochrom> Oh I'm blaming something deeper than that.  I am blaming people choosing to circumvent school, i.e., choosing to be ignorant and be proud of it.
09:27:24 <__monty__> Priority queue sounds like something different from psq at first glance though. And even though I did learn about priority queues I don't look at TTL hashtables and instinctively go "Priority queues'd do this better."
09:27:26 <nshepperd1> I know what a priority queue is but i wouldn't google "priority queue" if i wanted an lru cache
09:28:11 <__monty__> And we aim to continue that proud lineage, right? : )
09:28:31 <tdammers> monochrom: yeah, I think people are cargo-culting the "genius programmer drops out of school and founds a business empire from his garage" career narrative
09:28:45 <__monty__> SPJ
09:28:49 <__monty__> : >
09:32:23 <MarcelineVQ> they always forget yo mention the, goes back to school to learn business part of the story
09:35:29 <geekosaur> among others
09:35:44 * geekosaur *is* self-taught. and has had nose rubbed in the resulting shortcomings far too many times
09:36:14 <geekosaur> (this said, teaching resources were hard to come by and not really accessible back then)
09:37:43 <nshepperd> how come psqueues doesn't come with a Monoid instance
09:39:00 <nshepperd> oh, they're using the wrong kind of heap
09:44:18 <__monty__> MarcelineVQ: Nah, many just partner up with a business type. Then get stabbed in the back later... : >
09:56:57 <estrom> Is there a more specific error to `throwIfNull` other than IOException? `display <- E.try $ openDisplay "" :: IO (Either E.IOException Display)`
10:04:26 <cocreature> estrom: no
10:04:46 <cocreature> estrom: see https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Foreign.Marshal.Error.html#throwIfNull
10:19:00 <Welkin> if I want to create an absctraction over IO for a runDB function, what are all of the typeclasses I should derive?
10:19:23 <Welkin> I want to avoid a situation where it can acceppt arbitrary IO computations
10:19:45 <Solonarv> is it a monad transformer or just a plain monad?
10:19:54 <Welkin> I thought of creating a newtype PGQuery = IO deriving (Funtor, Applicative, Monad, MonadIO)
10:20:11 <Solonarv> well if you derive MonadIO you're not forbdding arbitrary IO
10:20:14 <Welkin> perhaps it's best to use MonadIO
10:20:22 <Welkin> that's not what I mean
10:20:28 <Welkin> arbitrary IO is fine
10:20:44 <Welkin> I want to restrict the IO expressions allowd to be passed to runDB
10:21:06 <Welkin> so wrapping them in a newtype seems like it should work
10:21:14 <Welkin> because I have constructors for each operation
10:21:22 <Solonarv> what's the type of runDB supposed to be?
10:21:50 <Welkin> now that you mention it
10:21:58 <iqubic> What benefits do I get from giving my parser the underlying stream type of Text?
10:22:02 <Welkin> it's basically a lifted identity function
10:22:26 <Welkin> I have several prewritten database queries that are A -> B -> IO Result
10:22:31 <Solonarv> iqubic: it means you can run the parser on Text inputs
10:22:33 <infinisil> Welkin: I think creating a typeclass with exactly the allowed things is the way to go then
10:22:38 <Welkin> so I guess that is not what I want
10:22:56 <Welkin> actually, I don't need a runDB function
10:23:03 <Welkin> I just wasn't thinking straight at 3 am when I was writing this
10:23:11 <iqubic> Solonarv: So making the underlying stream type text doesn't change the type of the parser functions?
10:23:14 <iqubic> :t string
10:23:14 <monochrom> I wouldn't think in "benefit or not". You have stuff in Text to parse, therefore your stream type is Text. You have stuff in Foo to parse, therefore your stream type is Foo.
10:23:15 <infinisil> Welkin: Like `class MonadDB m where   query :: Query -> m Result`
10:23:15 <lambdabot> error:
10:23:15 <lambdabot>     • Variable not in scope: string
10:23:15 <lambdabot>     • Perhaps you meant one of these:
10:23:45 <Solonarv> iqubic: sure it does, for some of them (which parser library are you using, anyway?)
10:23:51 <Welkin> oh wait
10:24:10 <Welkin> I would benefit form something like that, because I still need to ask the Reader for the connection pool anyway
10:24:19 <iqubic> Solonarv: This is still going to parse a string, regardless of the underlying stream type, right:
10:24:36 <Solonarv> iqubic: again: which parser library are you using?
10:24:45 <iqubic> string :: Stream s m Char => String -> ParsecT s u m String
10:25:06 <iqubic> So that always going to parse a string, regardles of what stream s I chose.
10:25:21 <cocreature> if that’s your type signature then yes
10:25:31 <cocreature> for e.g. megaparsec, "string" has a different type
10:25:40 <cocreature> so what it returns depends on your stream type
10:25:42 <iqubic> That's a function from the parsec library.
10:25:56 <iqubic> Should I change to megaparsec?
10:26:02 <monochrom> Yes.
10:26:13 <iqubic> Why?
10:26:22 <cocreature> the readme of megaparsec has a comparison
10:26:24 <Guillaum> do you know a reason why haddock (and indirectly ghc) may tries to link package library using qualified names (libFOO-ghc8.6.3.so) and sometimes without the ghc version name. I have built haddock from source and it fails on some packages with a link error because it is looking at the wrong library name (it is looking form "unversionned" names but all my packages names have "versionned" names)
10:30:03 <Welkin> I think this will work just fine: no newtype, but runDB :: MonadIO m, MonadReader m => (Connection -> IO a) -> m a
10:30:31 <iqubic> How hard will it be to switch from parsec to megaparsec?
10:32:26 <von-strauss> hi
10:33:05 <Solonarv> Welkin: 'MonadReader m' is ill-kinded, did you mean: 'MonadReader Connection m'?
10:33:36 <Solonarv> iqubic: shouldn't be too hard; change the dependencies, change the imports, and let the compiler tell you what else needs changing/fixing
10:34:39 <mouse07410> Solonarv: can you help with stack config?
10:34:59 <cocreature> Welkin: didn’t you start out by trying to restrict the IO that can be performed? accepting Connection -> IO a doesn’t add any restrictions
10:35:14 <cocreature> mouse07410: just ask your actual question
10:37:05 <mouse07410> 1. I need GHC that's invoked by stack, to look into a directory I give, first - but after other directories were searched.
10:37:19 <von-strauss> whats a monad
10:38:20 <cocreature> mouse07410: what do you mean by “look into a directory” and what do you mean by “first but after other directories”? that sounds like you mean “last”
10:38:32 <mouse07410> 2. I want stack to invoke a specific GHC executable (like /usr/local/bin/GHC), not just a specific version.
10:39:49 <Solonarv> von-strauss: what kind of answer are you looking for? the typical flippant answer is "a monad is just a monoid in the category of endofunctors", but that's probably not very helpful
10:40:00 <cocreature> mouse07410: if you need stack to invoke a specific GHC executable, you’ll have to resort to system-ghc: true and change your path
10:40:34 <Solonarv> are you looking for examples of things that are monads? are you looking for analogies? ("a monad is a box", "a monad is a burrito")
10:40:59 <von-strauss> Solonarv, I'm looking for the most useful answer in the least technical terms
10:41:12 <von-strauss> what I have so far is it acts as a container for mutable data
10:42:10 <Solonarv> That is certainly *a* monad, but not all monads encapsulate mutable data
10:43:30 <mouse07410> cocreature: I mean - I pass a directory, like /opt/special/lib, and when GHC asks GCC to link executable - it looks into /opt/special/lib first, before, e.g., /usr/lib
10:43:44 <Welkin> cocreature: I wasn't clear earlier. I'm not trying to restrict IO operations. I only wanted to avoid a situation where runDB is passed something that is not a database operation, such as `putStrLn "hello world"`
10:44:03 <Welkin> but now, it requires a Connection parameter, meaning that it very unlikely to happen
10:44:27 <Solonarv> functions ignoring their parameter is unlikely?
10:44:51 <Welkin> the way I write it
10:44:56 <Welkin> there is probably a better way to do it
10:44:58 <Welkin> but this is simple
10:45:35 <mouse07410> cocreature:  "system-ghc: true" means that the first invokeable GHC on the PATH will be used?
10:45:55 <Solonarv> correct
10:46:11 <Welkin> postgresql-simple's query/query_ takes a string as the query
10:46:18 <Welkin> so there isn't much I can do there
10:46:20 <Solonarv> Welkin: if you don't want to allow arbitrary IO, hide the IO under a newtype wrapper and *don't* derive MonadIO
10:46:45 <Welkin> the only thing the query does it access postgres
10:46:47 <Welkin> is*
10:46:51 <Welkin> but that requires IO
10:46:58 <Welkin> query :: (ToRow q, FromRow r) => Connection -> Query -> q -> IO [r] 
10:47:19 <cocreature> mouse07410: yes
10:48:09 <Solonarv> Welkin: so, your library can have a function 'query' :: (Torow q, FromRow r) => Connection -> Query -> q -> NotIO [r]'
10:48:34 <cocreature> mouse07410: for your first question, there is extra-lib-dirs but I’m not sure they take precedence over the default directories
10:48:50 <Solonarv> where newtype NotIO a = NotIO { runNotIO :: IO a } deriving (Functor, Applicative, Monad)
10:48:57 <Solonarv> (don't export the constructor)
10:49:34 <Solonarv> Now you can use arbitrary IO (including postgres queries) when defining functions in NotIO, but users of your library can't
10:49:52 <mouse07410> cocreature: is there any way to force that precedence?
10:50:03 <cocreature> dunno
10:51:04 <Solonarv> sure: set up $PATH properly before calling stack
10:51:27 <cocreature> that doesn’t make extra-lib-dirs take precedence over /usr/lib
10:51:54 <Solonarv> e.g.: PATH="/path/to/ghc/you/want/:$PATH" stack build
10:52:09 <mouse07410> Solonarv: no, I'm asking about library search
10:52:28 <Solonarv> I'm pretty sure there's also an environment variable for libraries, so that'd be similar, but I don't know what it's called
10:52:29 <mouse07410> Though what you told is good to know
10:56:11 <Welkin> that is a good diea Solonarv 
10:56:31 <Welkin> this is what I have so far, but I'm not sure how to integrate the newtype in with my existing query 
10:56:33 <Welkin> https://hastebin.com/hehikifexu.hs
10:56:59 <cocreature> mouse07410: if all else fails, GHC has an -optl option that allows you to pass options to the linker (i.e. gcc in most cases)
10:57:02 <Welkin> I could create a wrapper function for createPerson that wraps it in PGQuery
10:57:57 <mouse07410> cocreature: great, thanks! Is it only a command-line option, or there are cabal and stack config file equivalents?
10:57:57 <Welkin> _createPerson reg = PGQuery $ createPerson reg
10:58:26 <Welkin> or si there a way to do it to the createPerson function itself
10:58:43 <cocreature> mouse07410: cabal/stack allow you to pass arbitrary options to ghc via --ghc-options
10:59:31 <Solonarv> Welkin: sure there is, just change the start to 'createPerson (Registration ...) = PGQuery $ \conn -> do ...'
10:59:37 <cocreature> but before you decend down that road, I would at least test if extra-lib-dirs doesn’t take precedence. if it does that seems like the easier solution
11:00:07 <mouse07410> cocreature: and GHC will figure which ones to pass to GCC who will figure what to pass to the linker?
11:01:34 <cocreature> mouse07410: no that’? what -optl is for
11:01:39 <cocreature> *that’s
11:01:59 <cocreature> so you use ghc-options to pass -optl=foobar to ghc which then passes foobar to gcc
11:07:58 <Welkin> Solonarv: ah, that's it. thanks
11:08:00 <wroathe> For performance, does GHC make an attempt to optimize away some of the laziness? It seems like major libraries all provide strict and non-strict versions of their functions to give you precise control over it...
11:08:15 <wroathe> Just how necessary is that practice?
11:09:03 <monochrom> Where a library provides a strict version, it is necessary.
11:09:03 <wroathe> For example: http://hackage.haskell.org/package/vector-0.12.0.2/docs/Data-Vector.html#g:30
11:09:55 <monochrom> GHC optimizes away some laziness and not some others.
11:12:01 <mouse07410> Ah, so I need to do "ghc-options: -optl=something", not just "ghc-options options: something" if I need to pass "something" to the linker?
11:12:53 <wroathe> So as a consumer how do I go about evaluating when it's necessary to use one or the other? Do I need to become well-versed with the optimizations that GHC applies under the hood? Or do most people opt for laziness until they notice something taking up more time or memory than it should?
11:15:03 <wroathe> As a newcomer to the language I'm starting to build up performance paranoia where every line of code I write causes me to look over my shoulder to see if laziness might be sneaking up on me with a knife :P
11:16:49 <Welkin> you almost never have to worry about it
11:17:28 <Welkin> also, make it work, then maybe --- only if you need to -- make it fast
11:19:07 <fresheyeball> anyone know how to use haskell beam with a postgres enum?
11:19:40 <Welkin> beam?
11:19:43 <Welkin> the erlang vm?
11:19:50 <fresheyeball> Welkin: the database lib
11:19:51 <mouse07410> wroathe: Welkin is right - worry about performance only if/when it becomes a factor.
11:20:06 <fresheyeball> https://tathougies.github.io/beam/
11:20:31 <Welkin> oh, on ORM
11:20:40 <fresheyeball> yeah
11:20:46 <Welkin> I use postgres enums (and all kinds of other features of postgres) using postgresql-simple
11:20:46 <monochrom> IMO that is not right because by then it will be too late. OTOH of course premature optimization solves no problem just creates more too.
11:21:12 <fresheyeball> Welkin: I think beam is based on postrges simple
11:21:56 <monochrom> My way is firstly highest priority I have good judgment of which part of the code actually needs to be fast, which other parts can be slow and no one will care.
11:22:00 <Welkin> fresheyeball: here is how I do it https://hastebin.com/iqujuduhud.hs
11:22:18 <monochrom> Then secondly I am well-versed with lazy evaluation.
11:23:42 <monochrom> Then thirdly, for every line of code, I know whether laziness is helping or hurting (because #2), but I let it be for now, until #1 says I should intervene.
11:23:50 <wroathe> In general that's how I've historically operated (avoiding premature optimization), but I often feel reasonably confident about the asymptotics of what I'm doing when it comes to strict imperative languages
11:24:05 <fresheyeball> Welkin: https://hastebin.com/jijemucasi.rb
11:24:08 <fresheyeball> this is what I have
11:24:11 <Welkin> I'm currently attempting to convert my ~2k line scotty application to servant, along with all kinds of other changes and new abstractions. I'm only going to run the compiler at the end when I am done
11:24:12 <wroathe> I'm guessing that same confidence will come with time working with Haskell
11:24:20 <fresheyeball> but I don't have a ToField somehow
11:29:46 <cocreature> wroathe: at some point you’ll have to get a rough understanding of how Haskell is actually being executed by GHC if you care about performance. The STG paper is a pretty good starting point for that
11:30:27 <mouse07410> cocreature: what's STG paper? Do you have a URL handy?
11:30:43 <cocreature> mouse07410: https://www.microsoft.com/en-us/research/wp-content/uploads/1992/04/spineless-tagless-gmachine.pdf
11:31:09 <wroathe> cocreature: Thanks!
11:31:09 <cocreature> also the "making a fast curry" paper
11:33:09 <mouse07410> Thanks!
11:35:46 <alp> Welkin, running the compiler only at the very end? that's brave =)
11:40:38 <Welkin> I did it with Elm when changing thousands of lines and it worked out fine
11:44:34 <wroathe> I'm always impressed by those smart enough and motivated enough to complete papers like these.
11:46:08 <cocreature> wroathe: I would only worry about the first 5 sections and note that at least in the first read of a paper you’re usually trying to get the overall idea and not every minor detail
11:55:04 <koz_> Yeah, a paper requires 3 readings at least in my experience, and your first reading really is just 'what's the overall thing they're on about'.
11:56:36 <wroathe> I'm surprised Data.Text doesn't have a Show a => a -> Text
11:57:12 <wroathe> Converting it to a String first with show, and then packing it into Text is cumbersome
11:57:55 <Welkin> https://hackage.haskell.org/package/text-1.2.3.1/docs/Data-Text-Internal.html#v:showText
11:58:05 <Welkin> you can also define it yourself
11:58:17 <fresheyeball> wroathe: do you know is postgres simple supports multiple schemas?
11:58:18 <Welkin> tshow = show . unpack
11:58:26 <Welkin> but really, Show is only for debugging
11:58:29 <Welkin> you don't use it otherwise
11:58:55 <Welkin> if you are working with Text, it stays as Text, or possibly gets converted to ByteString
12:03:45 <infinisil> Welkin: What annoys me is that monad-logger only defines log functions for text, so to print arbitrary expressions I always need to use unpack . show :/
12:04:47 <Welkin> why not use tshow?
12:04:53 <Welkin> just define it yourself or import it
12:08:02 <infinisil> Oh yeah hah, I should do that
12:08:11 <fresheyeball> wroathe: what is the significance of the Escape constructor in the ToField instance
12:09:19 <wroathe> fresheyeball: Don't look at me. I'm new here. Ask one of the other smarter guys.
12:09:37 <fresheyeball> wroathe: I might have been confusing you with Welkin 
12:11:04 <Welkin> fresheyeball: it says that the value is a safe/escaped string
12:11:33 <Welkin> I believe it is to prevent sql injections
12:15:07 <fresheyeball> Welkin: it's weird
12:15:18 <fresheyeball> with my Beam setup I have an explicit FromField
12:15:22 <fresheyeball> but no explict ToField
12:15:32 <fresheyeball> instead HasSqlValueSyntax seems to be the ToField
12:15:53 <fresheyeball> I don't know how that could even work
12:20:30 <fresheyeball> Welkin: I got it! This was the bump I needed
12:20:33 <fresheyeball> Welkin++
12:20:43 <fresheyeball> wat? colon or something
12:20:45 <fresheyeball> Welkin:++
12:23:00 <pgiarrusso> ski oh you mentioned my work :-)
12:23:15 <pgiarrusso> ski: lost track of the whole context there tho
12:23:59 <wroathe> So I'm trying to define a FromJSON instance for a specific type of list: [(String, Int)]
12:24:11 <wroathe> and I get the compiler error about FlexibleInstances
12:24:27 <wroathe> I also see others mentioning OverlappingInstances to handle specificity like this
12:24:36 <wroathe> What do you guys think is the right way to go about doing this?
12:26:57 <geekosaur> neetype, uually. you don't get a guarantee that the more specific instance will be used
12:26:57 <von-strauss> use scala
12:27:23 <geekosaur> which is why OverlappingInstances is an extension, and has warnings in the docs
12:27:49 <wroathe> Wait, so just by wrapping that in a newtype it'll work?
12:28:18 <wroathe> That list type, I mean
12:28:44 <geekosaur> that's the whole point of newtype, yes
12:29:08 <geekosaur> because it's not just a more specifi clist, it's a new type with its own constructor and type information
12:29:11 <geekosaur> and instances
12:29:48 <wroathe> geekosaur: understanding++, thanks
12:41:12 <larryba> when wouldn't OverlappingInstances use more specific instance?
12:54:50 <koz_> Basically, newtypes are often used to give different, or more specific, type class instances.
12:55:00 <koz_> Case in point is stuff like Down, Sum, etc.
13:13:15 <koz_> What's the 'default' PRNG in the random package? Like, the one you'd get if you used a PRNG in IO?
13:14:38 <Welkin> I like this one
13:14:38 <Welkin> https://hackage.haskell.org/package/entropy-0.4.1.3
13:14:48 <Welkin> I use it to generate random keys
13:16:41 <Welkin> https://hackage.haskell.org/package/random-1.1/docs/System-Random.html#t:StdGen
13:16:54 <Welkin> the one used by System.Random is not a good
13:17:09 <Welkin> as*
13:17:20 <Welkin> depending on what you need
13:22:10 <koz_> Welkin: I was just curious.
13:22:16 <koz_> I don't have specific needs.
13:50:25 <larryba> what is lens operator version of use, modifying and assign?
13:58:38 <Taneb> There's no operator for use
13:59:02 <Taneb> Modifying is %+, assign is .=
14:00:38 <larryba> Taneb, thanks
14:36:19 <larryba> @pl (\x acc -> add x =<< acc)
14:36:20 <lambdabot> (=<<) . add
14:40:25 <dexterfoo> why is this channel #haskell and not ##haskell?
14:41:08 <hpc> freenode's channel naming conventions
14:43:00 <glguy> dexterfoo: See https://freenode.net/kb/answer/namespaces
14:49:28 <dexterfoo> most other programming language channels on free node are "topical" (##c ##c++ ##javascript ##java ##php)
14:50:21 <glguy> This channel is attached to haskell.org
14:50:45 <glguy> Officially part of the community built around Haskell
14:51:02 <Welkin> yeah
14:51:08 <Welkin> not that haskell-lang nonsense
14:52:00 <dexterfoo> ok makes sense thanks. there actually is a ##haskell channel with one other person in it :D
15:55:21 <bor0> what is the difference between A, B |- A and A /\ B |- A. how do I interpret the former? (a -> b -> a) or ((a, b) -> a)?
15:59:27 <ddellacosta> I'm curious as well, because it seems like those are isomorphic?
15:59:41 <glguy> ddellacosta: Depending on the logical system you're using those things are the same
15:59:50 <ddellacosta> glguy: gotcha
15:59:54 <glguy> the stuff  x , y , z |-  a , b, c
15:59:57 <glguy> is part of the metalogic
16:00:13 <glguy> but the   A/\B is in the underlying logical system
16:00:20 <bor0> ok, great - because in both cases (a -> b -> a) and (a, b) -> a we have the same givens. I just wanted to confirm. thanks :)
16:00:25 <glguy> so you can have:    (A /\ B) -> C
16:00:45 <glguy> but it wouldn't make sense to write:  (A, B) -> C if , was the same comma from the sequent calculus system
16:00:56 <glguy> (as opposed to a tuple that was built into the language
16:01:07 <bor0> I'm solving the exercises from www.incredible.pm in Idris so I wanted to make sure I have the correct representation
16:02:27 * hackage purescript 0.12.2 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.12.2 (garyb)
16:02:50 <bor0> (https://github.com/bor0/idris-incredible.pm for those that are interested in the same things)
16:02:51 <ddellacosta> yeah, just to be clear I was only talking about the function types on the right as they relate to each other and the very first term
16:03:10 <ddellacosta> bor0: neat, I really have to poke at Idris some more
16:04:26 <bor0> I can't suggest it enough :) its syntax (which is really close to Haskell) was the biggest reason I picked it. I had also tried Coq but the syntax was just alien
16:05:45 <ddellacosta> yeah, I've heard some folks describe it loosely as an improved Haskell that integrates a bunch of syntax that appeared in extensions first but could stand to be the default (e.g. GADTs), along with small tweaks (:: -> :)
16:05:57 <ddellacosta> I mean, glossing over the dependent types, lol
16:06:37 <jackdk> I've heard it called "haskell, but with : instead of ::, oh, and it has dependent types"
16:06:49 <glguy> losing laziness and other stuff
16:06:55 <glguy> it's more different than improved
16:07:18 <Welkin> "improved" is subjective
16:07:25 <Welkin> it has a different type system
16:07:35 <bor0> yes, and the distinction between values and types (rel implementation: https://github.com/bor0/lambdapi/commit/4aca6421d547ef19f9a81369a4688c9a88bf416d#diff-799569a2d6272a3bb3f60219bc08044dR37)
16:07:53 <bor0> so e.g. there's no data Test = Test, but rather data Test = MkTest, etc
16:08:26 <bor0> (sorry I feel I should clarify - the "no" distinction between values and types in Idris)
16:21:11 <Welkin> any help with this? https://hastebin.com/ocegonemus.hs
16:21:24 <Welkin> I am trying to autoderive Functor, Applicative, Monad for a newtype
16:21:42 <Welkin> GeneralizedNewtypeDeriving doesn't seem to be enough
16:22:42 <jackdk> Welkin: try using a ReaderT Connection instead of (->) Connection?
16:24:47 <Solonarv> Yep, that'll do it
16:24:53 <Welkin> why?
16:24:59 <Welkin> that is not the best solution
16:25:07 <Welkin> it's not a ReaderT, it's a normal function
16:25:12 <Solonarv> No, it's not - the best solution is DerivingVia
16:25:18 <Welkin> will that work?
16:25:44 <Welkin> I added DerivingStrategies and am using `deriving newtype (Functor, Applicative, Monad)`
16:25:49 <Solonarv> yes, you need to derive via (ReaderT Connection IO a)
16:25:50 <Welkin> still not working
16:26:00 <Solonarv> the error tells you why it's not working
16:26:18 <Welkin> yes, but I don't know how to help it
16:26:34 <Solonarv> your options are:
16:26:35 <Welkin> do I add `derive via` on the newtype declaration?
16:27:24 <Solonarv> 1) change the representation from 'Connection -> IO a' to 'ReaderT Connection IO a'
16:27:24 <Solonarv> 2) change the deriving clause to 'deriving via (ReaderT Connection IO a) (Functor, Applicative, Monad)
16:28:28 <Welkin> isn't it `deriving (...) via (...)`?
16:28:35 <Welkin> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-DerivingVia
16:29:13 <larryba> person & name <~ getLine     shouldn't this work? or am I misunderstanding how this operator works?
16:29:15 <Solonarv> % newtype Foo = Foo Int deriving via (Sum Int) (Semigroup)
16:29:15 <yahb> Solonarv: ; <interactive>:42:32: error: parse error on input `via'
16:30:03 <Solonarv> % newtype Foo = Foo Int deriving (Semigroup) via (Sum Int)
16:30:03 <yahb> Solonarv: 
16:30:09 <Solonarv> ah, seems you're right
16:32:32 <Welkin> I got that working
16:32:37 <Solonarv> larryba: did you actually look at the documentation for <~ ?
16:32:38 <Welkin> now on to the next wall of errors
16:32:43 <Welkin> thanks
16:35:00 <larryba> Solonarv yes. I'm not getting it
16:35:18 <Solonarv> larryba: the monad you're working in needs to be a state monad
16:35:34 <larryba> oh
16:35:44 <Solonarv> usage is 'someLens <~ whateverAction'
16:36:47 <larryba> id <~ action is the same as put =<< action?
16:37:32 <larryba> or in other words, someLens is the lens of state?
16:37:46 <Solonarv> yup
16:45:22 <larryba> neat
16:45:59 <larryba> I'm not sure I understand the difference between <<~ and <~, both work  with my example. I can't follow the types
16:47:00 <larryba> one takes a Lens, and another Setter? Isn't every Lens also a Setter
16:58:04 <jle`> are there any tricks to getting around data types not being allowed to refer to their own lifted versions in their types?
16:58:29 <jle`> data Foo (a :: Foo) = ...
16:59:02 <Welkin> an Irish Setter?
16:59:10 <Welkin> sit boy!
17:00:38 <Solonarv> jle`: change it to 'data FooF k (a :: k)' and take a fixpoint, maybe?
17:00:58 <jle`> what would the fixed point combinator be?
17:01:13 <Solonarv> I'm not sure
17:01:27 <jle`> it's tricky because to ghc, the type and its lifted version aren't linked
17:01:45 <jle`> they're completely different types to the type system, so you can't really refer to one in terms of the other
17:01:56 <jle`> the only thing they share is the lexeme for their constructors
17:02:32 <jle`> larryba: it seems like (<~) returms `m ()`, meaning that it discards the result
17:02:43 <jle`> larryba: so (<~) is closer in nature to 'modify'
17:02:52 <jle`> larryba: (<<~) lets you access the result
17:03:22 <jle`> larryba: the '<OP' convention is that it's the same as 'OP', but it preserves the result for you
17:08:51 <larryba> jle`, got it.
17:10:00 <larryba> with <~, () is printed. with <<~, a string returned by getLine.  liftIO . print =<< (name <~ liftIO getLine)
17:14:29 <jle`> larryba: yeah. you can also compare it to mapM vs mapM_
17:14:51 <jle`> although the convention is backwards, since the "_" means "discard", and the presumed default is do-not-discard
17:15:12 <jle`> but for lens state operators, the default is discard, and the "<" means "do-not-discard".  presumably the default is chosen to match the behavior of 'modify'
17:21:52 <Solonarv> it also parallels the behavior of the non-state-y operators
18:02:28 <gvolpe> Hi there, I have a question WRT the `lens` package and specifically with `makeClassy`
18:02:49 <gvolpe> I have an ADT of configuration types
18:03:15 <gvolpe> `data AppConfig { server: ServerConfig, client: ClientConfig }`
18:03:52 <gvolpe> And I invoke `makeClassy` for all the config types
18:04:33 <gvolpe> Then I have a data type `data Env { _config :: AppConfig }`
18:06:12 <gvolpe> But when I try to use the `HasAppConfig` and `HasServer` typeclasses it cannot find the instances for `Env` even though this data type contains the `AppConfig` so I figured that maybe by just calling `makeClassy ''Env` I was going to get these instances for free but it doesn't happen
18:06:40 <gvolpe> I solved it by writing the instances myself but I'm wondering if there's any way to get these for free?
18:06:46 <iqubic> Converting my code from Parsec to Megaparsec is proving to be a bit tricky.
18:19:33 <Arahael> iqubic: Yeah?
18:19:48 <Arahael> iqubic: I've never used Parsec, as I started with Megaparsec instead.
18:20:24 <iqubic> arahael: Can you help me with something?
18:20:48 <Arahael> iqubic: Unlikely, I'm still very new ot this.
18:20:58 <Arahael> iqubic: (But do ask anyway, maybe I or someone else can help)
18:22:47 <geekosaur> gvolpe, check ordering in the file. most things in Haskell dont' care, but makeClassy is TH and (a) only sees what precedes it (b) is only visible to what follows it
18:22:52 <iqubic> I have this code: `type ParserError = ParseErrorBundle T.Text Void` and it gives me an error.
18:23:27 <geekosaur> although I don't know offhand if you get instances as such. might be able to use standalone deriving?
18:23:38 <iqubic> error: Not in scope: type constructor or class ‘ParseErrorBundle’
18:24:03 <iqubic> Which is odd, because I have Text.Megaparsec.Error imported.
18:26:00 <Arahael> iqubic: Yeah, that's still a bit beyond my level at the moment, that said, the Parser type is relatively complex in Megaparsec, mine is `type Parser = Parsec Void Text`
18:26:48 <iqubic> I have that set up.
18:27:07 <iqubic> What function are you using to run a parser?
18:30:22 <Arahael> Just 'parse'.
18:31:49 <iqubic> What is the type signature you have given that function?
18:33:13 <koz_> lyxia: Can your all-singing, all-dancing, all-deriving library derive NFData instances?
18:34:16 <iqubic> So can someone help me understand my Megaparsec issue?
18:35:14 <iqubic> the ParserErrorBundle issue.
18:35:46 <mouse074_> stack fails to build "ghc-paths" on MacOS when Macports is installed: https://pastebin.com/3CXXwu5u
18:36:08 <koz_> iqubic: Try spelling it 'ParseErrorBundle'.
18:36:46 <mouse074_> The conflict is with libiconv.dylib that's provided by both Macports and MacOS itself. I tried to force stack to use /usr/lib/libiconv.dylib, but failed to achieve that.
18:37:24 <mouse074_> Would be grateful if you could tell me how I could do that. "ghc-options: -optl=/usr/lib/libiconv.dylib" did not work.
18:37:28 <iqubic> koz_: I can verify that I am spelling correctly.
18:37:30 <MarcelineVQ> iqubic: https://hackage.haskell.org/package/megaparsec-7.0.4/docs/Text-Megaparsec-Error.html#t:ParseErrorBundle "data ParseErrorBundle s e" "Since: 7.0.0" is your version 7 or newer?
18:37:48 <iqubic> How do I check my version?
18:37:51 <mouse074_> "ghc-options: -optl="-L/usr/lib -liconv" did not work either.
18:38:00 <MarcelineVQ> idk, how did you get megaparsec?
18:38:06 <iqubic> from nix.
18:38:18 <MarcelineVQ> no clue :X
18:38:29 <koz_> You might have to wait for a nixpert.
18:38:40 <iqubic> I use nixos and nix handles my haskell libraries.
18:38:46 <iqubic> Let me go ask in #nixos.
18:39:04 <MarcelineVQ> I'd check your "ghc-pkg list" from your project's nix shell as a first stop
18:39:28 <MarcelineVQ> but idk if it'd be in there
18:39:40 <koz_> lyxia: Never mind, I am the dumbz.
18:41:12 <iqubic> MarcelineVQ: Looks like I'm using 6.5.0
18:41:16 <iqubic> Is that bad?
18:42:00 <MarcelineVQ> No, but it means you don't have ParseErrorBundle, so you should refer to docs that match your version
18:42:13 <iqubic> https://paste.pound-python.org/show/Q1fOwIp0nquBZax6mHKU/
18:42:44 <iqubic> How do I view the docs for 6.5.0?
18:43:23 <MarcelineVQ> I shouldn't have to tell you that by now, you're not entirely new here :> https://hackage.haskell.org/package/megaparsec click on the version you have
18:43:29 <iqubic> Right.
18:46:27 <iqubic> New issue: `testParse parser string = parse parser "" (T.pack string)`
18:46:43 <gvolpe> @geekosaur, thanks. Everything is on the same file with visibility but still...
18:46:43 <lambdabot> Unknown command, try @list
18:46:50 <gvolpe> geekosaur, thanks. Everything is on the same file with visibility but still...
18:47:22 <iqubic> http://dpaste.com/34DM09B
18:47:43 <iqubic> What is going on there?
18:48:15 <iqubic> Update: http://dpaste.com/2N1SR1X
18:49:50 <MarcelineVQ> Exactly what it says, you're asserting the wrong type for ParseError comapred to what you're actually giving your function
18:50:04 <MarcelineVQ> re-read the section below the ParseError example in the Text.Megaparsec docs
18:50:43 <iqubic> I see.
18:50:50 <iqubic> Yeah. That makes sense.
18:51:02 <iqubic> I wish I could just use the latest version of megaparsec.
18:52:41 <koz_> This is me right now: https://imgur.com/ZncQXFl
18:58:12 <iqubic> Does anyone know when version 7.0.0 of megaparsec was released?
18:58:59 <argent0> Tue Sep 4 19:31:06 UTC 2018
18:59:10 <argent0> from: http://hackage.haskell.org/package/megaparsec-7.0.0 
18:59:24 <argent0> I don't know if that's accurate though
19:02:33 <Welkin> what is the recommended resource pool library?
19:02:38 <Welkin> is it still resource-pool?
19:02:59 <Welkin> https://hackage.haskell.org/package/resource-pool-0.2.3.2/docs/Data-Pool.html
19:03:28 <Welkin> withResource looks like what I need to use to grab a connection fro mthe pool to perform a database query, but I'm not certain
19:03:56 <Welkin> it also looks potentially dangerous (pool resources are leaked in the event of an exception being raised, which will happen at times with postgres)
19:04:20 <Welkin> leaked => destroyed*
19:07:11 <jackdk> I use resource-pool for that purpose but catch postgresql exceptions before they get back to the handler. Note that if the pool destroys the resource, it will make a new one when you next use it.
19:07:23 <mouse074_> Any help?
19:08:10 <glguy> mouse074_: Ask your question and if anyone can help you with jump in.
19:08:32 <glguy> Or are you looking for help from that previous linker question?
19:08:41 <Welkin> jackdk: where do you catch the exceptions?
19:08:53 <Welkin> I am only checking in the case of datatype conversions
19:12:49 <jackdk> I have a Transaction monad, and when I runTransaction to convert Transaction a into App a (roughly), I catch pg exceptions
19:16:06 <Welkin> ah I see
19:16:22 <Welkin> I could do that inside of my runDB function I suppose
19:16:59 <Welkin> I just churn a thousand lines of haskell ripping this project apart and putting it back together again today
19:17:15 <Welkin> it's really fun to watch the compiler count up the modules to show your progress
19:17:22 <Welkin> 5 modules down, 3 to go!
19:19:42 <mouse074_> stack fails to build "ghc-paths" on MacOS when Macports is installed: https://pastebin.com/3CXXwu5u
19:20:21 <mouse074_> glguy: yes, that's the problem I'm seeking help with.
19:23:37 <glguy> mouse074_: Is this related? https://github.com/commercialhaskell/stack/issues/825
19:24:20 <mouse074_> glguy: yes it is - but the solution listed there doesn't seem to work. I keep getting that same linker error.
19:24:40 <mouse074_> And this: https://github.com/commercialhaskell/stack/issues/4504
19:30:09 <glguy> mouse074_: If you have a choice in the matter, homebrew is better about not installing libraries that introduce conflicts like this into paths that are automatically searched
19:32:04 <mouse074_> Unfortunately, I don't. I'm contemplating using Docker (though I'm a complete novice there too), but until then, I need to get this working. I must say that in general, Haskell packages seem to install fine. Cabal also seems to work correctly. Only stack is giving me trouble, and only on a few packages.
19:33:01 <sclv> so don't use stack
19:33:09 <sclv> you can get everything done with just cabal if you're careful
19:33:33 <glguy> What if you're not careful??
19:34:53 <sclv> well heaven help  you
19:35:32 <mouse074_> Well, I daresay that I can be careful enough. As for cabal vs. stack - my *only* reason for using stack at all is that the only decent IDE plugin that I'm aware of is IntelliJ-Haskell, and it only uses stack. Since I learned to love IntelliJ IDEA, I'd VERY MUCH prefer to keep using it as an IDE...
19:36:18 <mouse074_> Are there other alternatives, besides using Emacs/Spacemacs and running builds from a terminal window?
19:36:23 <Mrbuck> Hi haskell
19:36:55 <Solonarv> haskell-ide-engine supports cabal builds as well, and there are plugins for a variety of editors
19:37:58 <Solonarv> Mrbuck: hello!
19:38:41 <Mrbuck> Solonarv:  Happy Monday
19:38:56 <Mrbuck> Haskell run on web assembly on v8 ?
19:39:10 <sclv> no
19:39:19 <maerwald> hie support for cabal is not that great
19:39:29 <Mrbuck> sclv:  wher it runs then ?
19:39:34 <maerwald> see https://github.com/haskell/haskell-ide-engine/issues/1015 for example
19:39:43 <sclv> compiled binaries
19:39:48 <iqubic> Mrbuck: try lokking at ghcjs
19:39:59 <Mrbuck> iqubic:  why ?
19:40:08 <sclv> ghcjs compiles haskell to javascript
19:40:20 <sclv> but mainly haskell is used to compile binaries
19:40:30 <Mrbuck> sclv: Okay
19:40:48 <Solonarv> there is a wasm backend being worked on, actually
19:41:40 <Solonarv> it's not even close to production ready, but it exists!
19:42:19 <Solonarv> ah, I found it: https://github.com/tweag/asterius
19:44:49 <doyougnu> mouse074_: what is the problem you're having? Sorry I'm joining the convo late
19:47:38 <jackdk> doyougnu: I think it's this> stack fails to build "ghc-paths" on MacOS when Macports is installed: https://pastebin.com/3CXXwu5u
19:47:45 <jackdk> (aside: yes, I do GNU!)
19:50:53 <mouse074_> doyougnu: yes, that's the problem I'm having. I just took a look at haskell-ide-engine, but it doesn't seem ready just yet - as somebody pointed out, it's not great with cabal, and it doesn't integrate with IntelliJ yet. It might be good for Sublime, if it's cabal support is up to it, or maybe Emacs. But I guess I'm spoiled by a good IDE...
19:55:38 <doyougnu> does stack repl work?
19:56:15 <doyougnu> sorry "stack ghci"
19:57:24 <mouse074_> Yes, it works fine.
19:57:32 <maerwald> mouse074_: tooling support is still poor. You have the choice between things that lock you into a particular environment (e.g. intero or dante) and stuff that is half-broken (ghc-mod, hie) ;)
19:58:04 <Welkin> lock you in?
19:58:13 <doyougnu> i wonder if there is an issue with the cabal file. Can you force stack to rebuild the cabal file by mv-ing it to .cabalOld or something like that?
19:58:16 <Welkin> once you learn emacs, you never use anything else
19:58:21 <maerwald> lol
19:58:24 <doyougnu> Welkin: preach brother
19:58:43 <Welkin> I mean, emacs is frustrating all the time, but at least it works if you have patience
19:58:59 <mouse074_> I can build intero with cabal fine. Is it worth trying to rebuild cabal with stack???
19:59:20 <Solonarv> maerwald: you forgot to mention the minimal approach that is ghcid
19:59:31 <maerwald> Solonarv: doesn't work with cabal properly =)
19:59:33 <mouse074_> Welkin: I've been using Emacs since mid-1990-ties, so no need to explain what it can do. ;-)
20:00:16 <Welkin> I only use haskell-mode (syntax highlighting)
20:00:23 <mouse074_> With time, I found that I do prefer comfort to austerity. ;-)  IntelliJ is more comfortable to use, like it or not. ;-)
20:00:24 <Welkin> I've never felt a need for anything more
20:00:46 <Welkin> but I really like some of the features emacs has when editing erlang files, like automatically updating the module name when you change the filename
20:00:55 <mouse074_> Welkin: I didn't either, until I tried other things and found them more convenient. ;-)
20:01:04 <pikajude> i have a project that's restricted to ghc 8.4 and i'd like to haddock it
20:01:13 <pikajude> but i'm running into the "haddock: internal error: internal: extractDecl" bug that happens with ghc 8.4's haddock
20:01:14 <Welkin> recently I have been writing thousands of lines every single day
20:01:19 <pikajude> which i understand has been fixed in 8.6
20:01:25 <pikajude> does anyone know where i could go to backport the fix from 8.6 to 8.4
20:01:25 <Welkin> with just emacs and a few keyboard macros where necessary
20:01:54 <doyougnu> if you don't have a .cabal file in your project root directory stack will generate one for you from your stack.yaml and package.yaml
20:02:11 <Welkin> my hands/arms definitely feel the burn after that much typing
20:02:13 <doyougnu> I was thinking your error seems similar to this: https://stackoverflow.com/questions/19739395/cant-compile-haskell-project-linking-step-fails
20:02:34 <mouse074_> Yes, I can use Emacs or BBEdit (my organization didn't purchase Sublime license, so that's not an option). But while I *can* use it, I just find it more productive and convenient to use a real IDE, with error catching and warnings, rather than just syntax highlighting.
20:02:56 <jackdk> Welkin: Don't break yourself!
20:02:59 <Welkin> mouse074_: or nano!
20:03:17 <doyougnu> I quite like intero honestly, but it is pretty heavy
20:03:29 <jackdk> or ed, the standard text editor!
20:03:36 <pikajude> i don't know anyone named ed
20:03:40 <maerwald> also, intero may blow up your memory
20:03:47 <maerwald> Because it preloads all project type info
20:03:57 * hackage sv-core 0.4 - Encode and decode separated values (CSV, PSV, ...)  http://hackage.haskell.org/package/sv-core-0.4 (qfpl)
20:04:43 <Welkin> my IDE experiences in the past have been really bad (Eclipse, Xcode, various proprietary ones for game engines)
20:04:50 <doyougnu> yea that has bitten me a few times. I only have 4 Gigs!
20:04:55 <pikajude> my ide experience for haskell has been fantastic
20:05:07 <Welkin> I must say that working with assembly, an IDE is really nice to be able to view the state of your memory
20:05:33 <mouse074_> Well, small things I do in vi. I don't think I like nano commands all that much...
20:06:50 <mouse074_> Eclipse is promising, but unfortunately too buggy, and more plugins do not work with the current release. "ed" - I haven't seen in decades. "sed" is fine, but not for dev.
20:07:23 <mouse074_> Yes, direct access to debugger is another good reason to use an IDE.
20:08:07 <Welkin> for the handmade hero stream, Casey Muratori used emacs to program and visual studio to debug
20:08:32 <Welkin> (on windows)
20:10:25 <mouse074_> doyougnu: the symptom of the issue you mentioned is similar - but the cause is different. In my case the problem is that Macports mangles function names in libiconv.dylib. So the library name is the same for both, but the function names do not match - so if the wrong library is found (like in my case, stack-invoked ghc->gcc only finds /opt/local/lib/libiconv.dylib, despite my attempts to tell it to look elsewhere 
20:10:25 <mouse074_> first), linker fails with "unresolved references"
20:11:10 <doyougnu> ah
20:11:29 <mouse074_> If Haskell libHSbase.a was dynamic only, I'd be able to 're-orient' it towards the correct dnamic library with "install_name_tool", and that would've been it.
20:11:51 <maerwald> Welkin: yes, the problem is that most IDEs are poor editors =D
20:12:31 <mouse074_> Since it's a static library, there's nothing I can do, except rebuilding GHC from scratch. I did that, and everything worked - except that stack insists on downloading its own compiler, at least when used with IntelliJ-Haskell plugin.
20:13:20 <mouse074_> maerwald: respectfully disagree. For typing in and editing source code, I find most IDEs far better editors than "general purpose" tools like Emacs or vi.
20:13:56 <jackdk> mouse074_ IIRC stack has an option --use-system-ghc or something like that
20:14:27 * hackage sv 1.3 - Encode and decode separated values (CSV, PSV, ...)  http://hackage.haskell.org/package/sv-1.3 (qfpl)
20:15:23 <mouse074_> jackdk: It does - but for some reason something fails to connect... As I said, most of the packages build fine, but some fail. And the plugin I'm trying to use is very particular about that...
20:17:05 <doyougnu> you can also try making a custom snapshot and overriding the compiler version. I think you may even be able to point it to a specific ghc but I'm not sure. This is deeper into stack than I've delved before
20:17:19 <mouse074_> I also tried "--ghc-options -optl="-L/opt/local/lib/liconv -liconv", and "---ghc-options -optl=/usr/lib/libiconv.dylib". Neither one worked for "stack build ghc-paths"
20:17:40 <mouse074_> doyougnu: It looks like I can do what you suggest with cabal, but not with stack.
20:18:20 <Welkin> has anyone worked with generalized auth in servant?
20:18:52 <doyougnu> mouse074_: https://github.com/commercialhaskell/stack/issues/725
20:18:55 <Welkin> I'm trying to get it set up with a custom monad, but I'm stuck on authHandler :: Request -> Handler PersonId
20:19:26 <Welkin> that's the type it wants, but I need it to be my wrapper monad (which is naturally transfomed away elsewhere)
20:20:18 <Welkin> otherwise I don't have access to my database to perform the actual authentication
20:23:16 <mouse074_> doyougnu: thanks. Yes, that is a good one. But I already have all that - except for "extra-path:". Not sure if it would help, as I have only one GHC on the PATH. "stack" tends to download a separate GHC for whatever LTS a package specifies...
20:25:37 <mouse074_> Alright, I'll sign off to catch some sleep. The logger will track all the replies, if somebody has more suggestions to offer.
20:26:20 <ddellacosta> is it possible to manipulate arbitrary ADTs with lens?
20:27:18 <geekosaur> you need to use makeLenses, otherwise it has no general way to work with them
20:29:30 <ddellacosta> geekosaur: I guess what I'm asking then is, more concretely, if I use makeLenses with some arbitrary type like `data OneOrTheOther a b = One a | TheOther b`, what getters are then available to me?
20:30:46 <jackdk> Welkin: you can use your own monad and then provide a natural transformation (forall a . YourMonad a -> Handler a) via hoistServer
20:31:44 <geekosaur> that I don't fully know. I know it makes lenses named after the constructors
20:31:50 <jackdk> ddellacosta: because it's a sum type, you'll want to use makePrisms. It should then give you prisms _One :: Prism (OneOrTheOther a b) (OneOrTheOther c b) a c and _TheOther :: Prism (OneOrTheOther a b) (OneOrTheOther a d) b d
20:32:13 <geekosaur> ok, there you go
20:32:23 * geekosaur really needs to learn more about lens at some point
20:32:33 <ddellacosta> jackdk: thanks, that's exactly what I was looking for!
20:32:34 <geekosaur> lens over tea has been on my reading list for over a year :/
20:32:45 <ddellacosta> geekosaur: yeaaaah I feel like I've been trying to learn lens for years now
20:32:49 <jackdk> I nibble at it now and then. data61 has a neat set of lets-lens exercises
20:32:57 <ddellacosta> oh nice, will check it out
20:33:47 <jackdk> https://github.com/data61/lets-lens is the link. Honestly, you can get a long with with just lenses and prisms
20:33:57 <jackdk> s/with with/way with/
20:34:58 <ddellacosta> cool, thanks jackdk
20:35:00 <jackdk> ddellacosta: your type was isomorphic to Either, and you can see the _Left and _Right prisms at https://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-Combinators.html#v:_Left
20:35:44 <ddellacosta> jackdk: oh that was a super stupid example, I'm actually working with an AST kinda thing, so actually I need to now figure out how to apply what you've given me to this thing
20:36:56 <ddellacosta> that said, that makes me wonder if there's a bunch of stuff I can't use in there...
20:37:03 <Welkin> jackdk: I am doing that, but this is different. I figured it out with the help of this https://stackoverflow.com/questions/41320350/haskell-servant-passing-custom-data-to-auth-handler
20:37:39 <jackdk> Welkin: cool beans
20:38:38 <jackdk> ddellacosta: roughly: makePrisms on a sum type will give you a prism for each constructor, and pull out a tuple of the arguments. makeLenses on a record will give you a lens for each record, named by dropping the underscore
20:38:57 <ddellacosta> jackdk: thanks!
20:38:59 <adamretter_> I am trying to understand what happens to RealWorld with forkIO. Presumably the RealWorld given to a fork, is just discarded when the thread terminates? i.e. the forked RealWorld is not bought back to the main thread?
20:39:26 <c_wraith> adamretter_: RealWord isn't an actual value
20:39:38 <c_wraith> adamretter_: it's just a hack to keep the compiler from reordering IO operations
20:39:41 <adamretter_> c_wraith: yes I realise that, but I need to conceptually understand it
20:39:55 <c_wraith> The new thread just creates its own RealWorld
20:40:18 <adamretter_> c_wraith: it doesn't get a copy of "RealWorld" from the calling thread?
20:40:25 <geekosaur> there is nothing to copy
20:40:28 <c_wraith> there is no value to copy
20:40:40 <geekosaur> it's a dummy, "data" with size 0
20:41:21 <geekosaur> it exists for exactly one reason: by being passed to and returned from I/O actions "under the covers", it ensures they remain ordered 
20:41:38 <geekosaur> it's a phantim that creates a data dependency
20:42:00 <geekosaur> and then the compiler realizes afterward it has no size and removes it from the generated code, leaving it in the intended order
20:42:10 <adamretter_> Okay, so I am tying myself in knots here :-( The "RealWorld" of IO allows us to order IO actions.... But that is only within a single Thread
20:42:45 <c_wraith> Just remember that it's a hack.  You don't need to understand how GHC implements IO to understand IO
20:42:47 <geekosaur> correct. which means there has to be e.g. locking of Handles under the covers, in casemutiple threads try to use the same Handle
20:42:49 <geekosaur> which there is
20:43:03 <c_wraith> And other compilers have implemented IO in different ways
20:43:09 <adamretter_> So conceptually, with multiple threads, there are multiple "real worlds"
20:43:20 <geekosaur> every thread has its own sequencing, yes
20:43:27 <geekosaur> and sequencing is all this does
20:43:54 <geekosaur> but ultiple threads can still do things interleaved or "out of sequence", because, well, they're threads, that's what they do
20:44:04 <adamretter_> So writing the same file from two different threads, even if they are IO actions, is completely "unsafe"
20:44:24 <c_wraith> well, it's non-deterministic
20:44:24 <geekosaur> as I said earlier, there is locking in Handles. but you get no guarantees as to order
20:44:31 <c_wraith> as is writing to the terminal
20:44:48 <geekosaur> if you need ordering, you should probably use a TChan read by a dedicated writing thread
20:44:59 <geekosaur> this is no different from any other language with threads
20:45:12 <geekosaur> and, really, it can't be
20:45:40 <adamretter_> c_wraith: er... but er.. putChar is deterministic because it is an IO right?
20:46:02 <c_wraith> adamretter_: multiple threads calling putStr at once can interleave their output, though
20:46:07 <geekosaur> two putChar-s to the same handle in the same thread will be in order. in differen threads, will be n ondeterministic
20:46:46 <jle`> adamretter_: remember RealWorld doesn't have any conceptual meaning
20:46:55 <jle`> adamretter_: if you're trying to make sense of it, you should know that it doesn't make any sense
20:47:01 <jle`> adamretter_: it isn't meant to make sense because it has no semantics
20:47:31 <jle`> it isn't something that you're really supposed to be able to reason with, or to use
20:52:01 <adamretter_> Okay, so I have to use synchronization between threads if I wish to use the same real world resources like files in more than one thread. I guess this is MVar, and Chan etc?
20:52:07 <nshepperd> imo it's best to imagine that IO is a free monad of a sum of all the io primops
20:52:33 <adamretter_> nshepperd: I'm a beginner, so that doesn't help me :-/
20:53:30 <geekosaur> yes, if you intend some form of synchronization, you have to supply it because ther's no way for ghc or its runtime to guess what you intended
20:54:04 <geekosaur> so it doesn't try
20:54:18 <geekosaur> in modern Haskell, the usual way is using STM which provides a variety of ways to usefully do synchronization with retries etc.
20:54:52 <geekosaur> MVar is fairly low level and only useful for very simple programs or for building more useful synchronization mechanisms
20:55:28 <adamretter_> Okay last thing. So forkIO produces an IO just like getChar, which means that it is also sequenced in the "main" IO monadic chain and does not do anything until main is evaluated right, so no thread is forked until forkIO is later evaluated
20:55:53 <geekosaur> Chan is one of those more useful mechanisms, but still leaves yoy in many cases with the question of how to handle the case where something is busy; this is where STM shines
20:55:53 <jle`> adamretter_: i think the word you are looking for is 'executed', not evaluated
20:56:32 <jle`> adamretter_: and right, 'forkIO" is *itself* an IO action, that you can sequence alongside the rest of your IO actions
20:56:45 <Welkin> what is this crazy error?
20:56:46 <Welkin> Expected a type, but ‘Text’ has kind ‘Symbol -> ErrorMessage’
20:57:04 <Welkin> is there a dataind for Text I have imported somewhere I don't know about?
20:57:08 <jle`> Welkin: you probably are using the 'Text from GHC.TypeLits
20:57:08 <Welkin> datakind
20:57:14 <jle`> yeah, it's a -XDataKind thing
20:57:26 <Welkin> how can I use the type Text?
20:57:31 <jle`> you have to import it
20:57:35 <Welkin> or do I need to exclude it from the import
20:57:43 <Welkin> I can have both?
20:57:48 <jle`> GHC will check for a type Text first, and if it doesn't exist, it'll try any DataKinds things
20:58:00 <Welkin> I see
20:58:05 <jle`> you can have both, GHC will differentiate by the apostrophe; 'Text will always refer to the -XDataKinds one
20:58:28 <jle`> if Text a type is in scope then it'll default to that one first
20:58:57 <jle`> Welkin: if you turn on -Wall then ghc will warn you if you use Text but "accidentally" get the DataKinds version
20:59:09 <jle`> i always turn it on first thing :)
20:59:56 <Arahael> iqubic: You can get the latest version of megaparsec quite easily using stack.
21:00:00 <Welkin> why are there two versions of ReaderT?
21:00:06 <Welkin> mlt and transformers
21:00:09 <Welkin> mtl*
21:00:13 <jle`> Welkin: there should only be one
21:00:17 <glguy> Welkin: There is only transformers, mtl reexports
21:00:19 <jle`> mtl re-exports the transformers types
21:00:23 <jle`> mtl is basically just a typeclass library
21:00:27 <jle`> it doesn't define any monad transformers
21:00:34 <jle`> that's why i like to call it the "Monad Typeclass Library"
21:00:42 <Welkin> I have both in my project
21:00:51 <Welkin> but I don't know which is the canonical one to import
21:01:08 <jle`> you should import the ones with the functions you want to use
21:01:12 <Welkin> because I use ReaderT and MonadReader both
21:01:21 <geekosaur> mtl, usually; it reexports both of those
21:01:42 <jle`> Welkin: if you want ask :: ReaderT r r, import Control.Monad.Trans.Reader
21:01:55 <jle`> Welkin: if you want ask :: MonadReader m r => m r, import Control.Monad.Reader
21:01:59 <geekosaur> transformers provides the low level common implementation; there are various things that then reuse them in their own ways, including mtl, mtl-tf, monads-tf, et.
21:02:01 <jle`> the types are the same in both cases
21:02:11 <jle`> the modules export the same type, but different functions/API
21:02:12 <nshepperd> normally I just import (ReaderT(..)) from transformers and all the functions from mtl
21:02:15 <geekosaur> possibly some effects libraries reuse it the same way
21:02:23 <nshepperd> import 
21:03:11 <nshepperd> I guess just importing Control.Monad.Reader does that
21:08:03 <jle`> Welkin: basically all mtl does is offer its API for dealing with reader-like things. it hides the 'original' interface that transformers provides in favor its own own
21:08:30 <jle`> so importing mtl means you want to use mtl's special "reader-like things" interface
21:24:17 <adamretter___> is there anything like Fork/Join in Haskell - e.g. do a bunch of forkIO and when all complete gather the results back to the main thread?
21:24:40 <jle`> adamretter___: the 'async' library offers some abstractions like that
21:25:09 <Welkin> read Concurrent and Parallel Programming in Haskell
21:25:52 <Welkin> https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/
21:25:56 <Welkin> it explains it all
21:30:19 <adamretter___> jle`: ah ha! That looks very interesting as it builds on forkIO as far as I can see
21:30:34 <jle`> adamretter___: yeah, you can think of forkIO as a low-level primitive that ghc offers
21:30:44 <jle`> with the expectation that people build interfaces on top of it
21:31:10 <jle`> it's useful enough in simple cases, but for anything more complicated usually these higher abstractions are recommended
21:32:58 <adamretter___> jle`: so if I understand correctly ten an "IO a"  has the type  "RealWorld -> (a, RealWorld)", does Async have something similar, e.g. what type is "Async a" really ?
21:33:08 <adamretter___> s/ten/then
21:33:14 <jle`> adamretter___: an 'IO a' does not have the type "RealWorld -> (a, RealWorld)"
21:33:18 <jle`> adamretter___: an 'IO a' has the type 'IO a'
21:33:21 <jle`> it is an abstract data type
21:33:46 <adamretter___> jle`: I read here - https://wiki.haskell.org/IO_inside#Welcome_to_the_RealWorld.2C_baby  "To be exact, "IO" is a type synonym defined in the following way:
21:33:46 <adamretter___> type IO a  =  RealWorld -> (a, RealWorld)"
21:33:58 <jle`> that statement is neither exact nor correct
21:34:17 <adamretter___> jle`: wtf? It's in the documentation on haskell.org and it's wrong?
21:34:25 <jle`> to be more clear, it is neither exact, nor correct, nor useful
21:34:34 <jle`> adamretter___: it's not official haskell documentation, it's actually just a wiki page
21:34:42 <Welkin> to understand IO, read Lazy Functional State threads by Simon Peyton-Jones
21:34:44 <jle`> someone edited it with misleading information, although they probably have good intentions
21:34:47 <adamretter___> jle`: oh man, how am I ever meant to understand this
21:34:47 <jle`> *had good intentions
21:35:03 <geekosaur> you're really not supposed to
21:35:18 <jle`> adamretter___: admittedly, hosting a wiki under the haskell.org domain confers with it a lot of undeserved legitimacy
21:35:23 <geekosaur> you should *really* not be poking around under the covers
21:35:35 <jle`> a lot of people would rather the wiki be removed or moved to a less "canonical" domain
21:35:58 <jle`> adamretter___: you should understand `IO a` as an abstract data type with a specific and clear API
21:36:06 <jle`> adamretter___: it's a data type that describes an IO action
21:36:25 <Welkin> when will we get Europa actions?
21:36:42 <Welkin> or Ganymede actions?
21:36:45 <suzu> hehe
21:36:47 <adamretter___> jle`: so it really helped me to think of IO as a function. I am trying to create something equivalent to IO in a language which has no definable types, so I used a function that took a "realworld" and returned a "(realworld, a)"
21:36:53 <MarcelineVQ> Welkin: attempt no landing there
21:36:59 <jle`> adamretter___: thinking of IO as a function is going to mislead you
21:37:01 <suzu> Welkin have you seen The Expanse?
21:37:05 <Welkin> yes
21:37:08 <suzu> :D
21:37:10 <Welkin> I am reading the books
21:37:11 <suzu> Ganymede!
21:37:15 <Welkin> they go to Io in book 2
21:37:15 <jle`> adamretter___: it's neither accurate nor true, and it might be helpful in some situations, but in the majority of situations, it's going to mislead you
21:37:17 <Welkin> I loved that
21:37:22 <Welkin> yeah Ganymede too
21:37:27 <suzu> oh that's not in the show. i'll look forward to it
21:37:40 <jle`> it's honestly something better to not consider, because, along from it being false, it's also misleading
21:37:43 <Welkin> the show covers books 1-3 so far
21:38:31 <suzu> maybe i will get around to reading them. i've just started to read fiction again (just started The First Fifteen Lives of Harry August). maybe ill get to reading the expanse too
21:38:34 <jle`> adamretter___: if you want to create something similar to IO in a language with no types, the closest thing you can do is create an abstract data type
21:38:45 <jle`> adamretter___: one that *describes* IO actions
21:39:03 <adamretter___> jle`: the language does not permit abstract data types, which is why I used a function
21:39:18 <jle`> adamretter___: what language are you considering?
21:39:19 <Welkin> book 1 and 2 are really good, book 3 was a huge disappointment (very slow and not much happens, little to no character development), but I have high hopes for book 4 which I am just about to start
21:39:31 <jle`> it's hard to imagine a language that doesn't allow abstract data types
21:39:40 <jle`> even assembly allows abstract data types
21:42:09 <suzu> if i've seen the show, should i just start from book 1?
21:42:52 <adamretter___> jle`: Even in this Academic Paper from Simon Peyton Jones and Philip Wadler (2007) - a history of Haskell, Section 7.3 Monadic I/O. It uses exactly "type IO a = World -> (a, World)" - https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/history.pdf 
21:44:29 <jle`> adamretter___: that's an implementation
21:44:36 <jle`> but it's not a definition of the data type
21:44:41 <adamretter___> jle`: okay, but I am developing an implementation ;-)
21:44:56 <adamretter___> jle`: jle`: I am looking at something to develop for use in XQuery that allows one to chain IO actions together and also perform concurrent execution
21:45:13 <adamretter___> jle`: https://blog.adamretter.org.uk/haskell-io-and-xpath#can-we-exploit-this-in-xpdls
21:45:25 <jle`> adamretter___: it's not actually a real implementation, because GHC actually ignores this type when actually implementing IO
21:45:56 <adamretter___> jle`: Yes i read the GHC optimises away the RealWorld during compilation, but that other compilers are free to take other strategies
21:46:02 <jle`> it's basically something to make the typechecker happy
21:46:09 <jle`> it's a type system hack, for the most part
21:46:15 <adamretter___> jle`: I want a happy type checker ;-)
21:46:22 <jle`> but your language doesn't have types?
21:46:51 <adamretter___> jle`: the type system is sealed you can only use pre-defined types, you can't create new types, you can however create functions
21:47:06 <adamretter___> jle`: so functions are as close as I can get to types
21:47:32 <jle`> i still think that looking at RW -> (a, RW) is a misleading way to help you find your goal at implementing something like monadic IO
21:48:31 <adamretter___> jle`: if you have an alternative suggestion as how I could implement this in a language which does not allow you to define types I would be interested. You can see my implemetation which uses functions in that blog post (above)
21:49:26 <Welkin> how do you handle the auth result inside of endpoint handlers in servant?
21:49:54 <Welkin> the result is a PersonId, which I added as the first parameter to each of the protected endpoints, but the types are not working out
21:50:08 <Welkin> I am not sure if that is the way to do it or not, since the documentation is unclear
21:50:51 <Welkin> it may have something to do with nested routes as well
21:51:56 <jle`> adamretter___: note when i say that IO a is an abstract type, i mean that its underlying implementation (be it RW -> (a, RW)) is "too big"
21:52:07 <jle`> adamretter___: it describes things that *aren't* IO actions
21:52:34 <jle`> adamretter___: just like, say, a balanced Binary Search Tree is an abstract data type
21:52:52 <jle`> the underlying implementation contains things that *aren't* binary search trees
21:53:09 <jle`> but the API provided ensures that anything it ever returns will be a valid balanced binary search tree
21:53:53 <jle`> this is what i mean by abstract: the actual public interface is detached from the underlying implementation
21:54:07 <jle`> it seems like even in the blog post, you are implementing an abstract data type
21:54:08 <dminuoso> Welkin: How are you authenticating? Are you using BasicAuthCheck?
21:54:18 <jle`> even though it's not a privileged "type" in the language's type system
21:54:51 <Welkin> dminuoso: no, generalized auth
21:55:18 <Welkin> all of my auth functions typecheck
21:55:28 <jle`> adamretter___: that being said, you should look at what IO's interface really *is*, before you can start looking at writing the underlying implementation
21:55:36 <dminuoso> Welkin: Err, do you have some code example to look at?
21:55:45 <Welkin> but I'm having two problems with my API definition: nested routes and the auth result
21:55:48 <Welkin> yes, I'll put it up
21:55:57 <jle`> adamretter___: an 'IO a' is meant to be a value that "describes" an IO action.  how it describes it is up to you, but the essense is that it's an inert description
21:56:13 <jle`> adamretter___: the point is that "evaluating" it won't trigger any IO, because evaluationg it is basically asking "which IO action is this?"
21:56:47 <dminuoso> > putStrLn "Hello world!" `seq` ()
21:56:49 <lambdabot>  ()
21:56:51 <jle`> adamretter___: an IO action is only triggered when it is run through an interpreter that takes an IO action, looks at the description of the IO it encodes, and then executes it within the context of the interpreter
21:57:00 <dminuoso> ^- this is an example of how evaluating does not trigger evaluation. =)
21:57:05 <Welkin> dminuoso: https://gist.github.com/ericnething/926dba42d8b5213e4b1ef9a7144d72b6
21:57:28 <jle`> adamretter___: in this context, something like forkIO doesn't actually "fork" anything
21:57:32 <jle`> adamretter___: it's an *IO transformer*
21:57:39 <jle`> adamretter___: it takes a description of IO, and returns a new description of IO
21:57:59 <jle`> adamretter___: the description that it (purely) returns is "the same IO action that the original input described, but actually in parallel"
21:58:13 <Welkin> dminuoso: take a look at the API type spec
21:58:23 <Welkin> and the various server definitions that go with them
21:59:10 <jle`> adamretter___: so whatever your description of IO is, it has to be able to accurately express a 'forked io' description
21:59:27 <jle`> RW -> (a, RW) is not powerful enough to describe this, at least, or at least accurately express it as a description
22:00:04 <dminuoso> Welkin: I would expect the auth result to appear as the first argument.
22:00:19 <dminuoso> Welkin: Can you include the type error you are getting?
22:00:40 <jle`> adamretter___: the "classic example" of a 'description of IO' would be something like a plaintext C source file.  functions like `forkIO` would be `String -> String`, essentially transforming the C source file into a new C source file that is 'in parallel'
22:01:20 <adamretter___> jle`: hmm that is a lot to think about there.
22:01:30 <jle`> of course, implementing a C source file transformer is not practical
22:01:39 <jle`> *is not a practical way to implement IO
22:02:03 <Welkin> the nested routes are also confusing me though
22:02:20 <adamretter___> jle`: my next step before I even get to Async is to consider how to implement forkIO in my code. 
22:02:40 <jle`> adamretter___: right, if you can implement forkIO properly, then you get async for free, effectively
22:02:50 <jle`> since the async type in haskell is implemented in terms of IO and forkIO
22:03:07 <jle`> but, maybe, it could be useful to implement 'async' as something separate...and then go the other way around :)
22:03:47 <adamretter___> jle`: I can't implement forkIO in XQuery itself, because there is no primitive for starting a new thread, so I have to just define the function type signature in XQuery, but the real implementation has to happen in Java or C++ of the XQuery interpreter
22:04:19 <jle`> adamretter___: ah, XQuery is an interpreted language...do you have access to the interpreter side?
22:05:29 <adamretter___> jle`: yes there are several open source interpreters, of which I contribute to one. My goal though is to define a spec for IO in XQuery terms, which people can then implement in their interpreters. So far I have been able to implement something like an IO Monad, with bind, return, and lift all in pure XQuery
22:06:01 <Welkin> dminuoso: I added one of the errors to the gist
22:06:25 <adamretter___> jle`: the goal of the specification is to be functionally pure (hence taking inspiration from Haskell's IO)
22:06:44 <Welkin> this is like the example I saw in the documentation, but I'm obviously doing something wrong
22:09:57 <Welkin> oh!
22:09:58 <jle`> adamretter___: it's an interesting problem
22:10:15 <Welkin> I commented out my type declarations for the servers, and now I am getting somewhere
22:10:21 <adamretter___> jle`: thanks I have been working on it for 13 days straight - I am beging to loose my mind
22:10:22 <Welkin> I still have no idea wha tthe types are
22:10:42 <jle`> adamretter___: btw, monet.js does a good job of implementing an "monadic io abstract data type" without relying on RW -> (a, RW)
22:10:54 <jle`> if you're familiar with javascript syntax
22:11:05 <adamretter___> jle`: not particuarly familiar with JavaScript
22:12:01 <jle`> adamretter___: monet.js's IO doesn't support async (but then again, neither does JS technically), but it can lend some insight i think
22:12:25 <dminuoso> Technically JS supports async since.. oh well some ECMAScript specification.
22:12:25 <jle`> adamretter___: basically it wraps a nullary function that, when "called", performs IO
22:12:55 <jle`> adamretter___: looking at your blog post, i think you could implement it in a similar way
22:13:16 <jle`> instead of "RW -> (a, RW)", it's basically just a nullary function that doesn't do IO until it's called
22:13:58 <jle`> adamretter___: and i was a bit misleading about the purpose of RW -> (a, RW) before; it's not for appeasing the type system, it's for appeasing laziness/strictness and lazy evaluation
22:14:34 <jle`> it's hacking Haskell's runtime to bypass lazy evaluation, basically.  it doesn't have much to do with type safety
22:14:47 <jle`> if you're in a strict language, then RW -> (a, RW) doesn't serve anything
22:15:14 <jle`> that's why monet.js doesn't have RW -> (a, RW)....just "nullary function" returning 'a'
22:15:32 <jle`> since the RW doesn't serve any purpose in a strict language
22:16:25 <adamretter___> jle`: so regards my implementation, if I wanted to fake forkIO... I think I could just have a function like "forkIO :: IO () -> IO ThreadId" -- where its result is a new IO  which would immediately evaluate the passed IO and return a fake thread id. Does that sound reasonable?
22:17:15 <Welkin> dminuoso: could you check the hoistServerWithContext error here? https://gist.github.com/ericnething/926dba42d8b5213e4b1ef9a7144d72b6
22:17:25 <jle`> adamretter___: so just (fmap 0)? where does the concurrency come in?
22:18:02 <Welkin> I made a lot of the errors go away by simply commenting out the server type declarations and threading the parameters that (I thought) should be there through
22:18:04 <jle`> adamretter___: but yeah, i think, looking at how monet.js works, you can rewrite your implementation atm to just drop the RW argument, and the RW return value
22:18:11 <jle`> adamretter___: and it would work the same as it does now
22:18:50 <jle`> but you might have to rewrite some things about when statements are called
22:20:18 <jle`> adamretter___: how is forking/concurrency normally used in XQuery?
22:22:58 <dminuoso> Welkin: If you comment out the entire `app` binding, does it still typecheck?
22:26:14 <Welkin> dminuoso: yes, but it doesn't change any of the errors
22:26:40 <Welkin> you mean comment out the type declaration for app, correct?
22:27:26 <dminuoso> Welkin: So you are getting two type errors?
22:29:47 <Welkin> I am getting a lot
22:29:50 <Welkin> many more than I pasted
22:29:58 <Welkin> that is the topmost one though
22:29:59 <dminuoso> Welkin: Then put it all up.
22:30:23 <dminuoso> Welkin: Is it possible that you wrote a lot of code without compiling in between?
22:37:23 <Welkin> the other errors are just normal type errors unrelatd to this
22:37:26 <Welkin> and yes I did
22:37:45 <Welkin> I changed/wrote over a thousand lines without compiling
22:37:52 <Welkin> I'll update the gist
22:37:56 <Welkin> I'm getting a lot closer now
22:38:15 <Welkin> I had to add anothe Proxy and fix the API declaration by splitting it
22:39:53 <Welkin> I did a huge conversion from scotty -> servant today, and tons of extra cleanup work/extra abstractions, but it all worked out. It's just the API type definition that's giving me some trouble now
22:40:06 <Welkin> dminuoso: I updated the gist 
22:40:11 <dminuoso> Welkin: The `Tagged` bit looks wrong.
22:40:18 <Welkin> I know
22:40:31 <Welkin> I am kind of burned out after working all day
22:40:33 <Welkin> any ideas?
22:41:05 <dminuoso> Welkin: Rebuild the app bit by bit. If you refactor 1000 lines of servant code, you can't expect the type errors to guide you anymore.
22:41:52 <Welkin> that's what I've been doing
22:41:57 <Welkin> it's very close to working
22:42:08 <dminuoso> "very close to working" - how do you even determine that?
22:42:11 <Welkin> there was so much to change that I just did it all at once
22:42:24 <Welkin> I already have all the other modules typechecked/compiled
22:43:02 <dminuoso> Servant really is not ideal. :(
22:43:04 <Welkin> and any other non-servant errors left in this module are simple
22:43:24 <Welkin> not ideal for what?
22:43:30 <Welkin> doing a large conversion?
22:44:48 <dminuoso> Welkin: I found servant type errors to be very lacking and hard to debug.
22:47:27 <Welkin> that's true, but it only comes up when you change the API
22:55:10 <cocreature> dminuoso: fwiw the Generics stuff in servant helps a lot with that
22:57:19 <Welkin> cocreature: any idea what's wrong here?
22:57:23 <Welkin> I'll update the gist
22:57:28 <Welkin> I'm making progress though
22:57:56 <cocreature> don’t have time to look at the error atm, sry
22:58:54 <Welkin> there is a conflict between Tagged s0 (PersonId -> Application)’ and ‘PersonId -> Tagged (ReaderT Config Handler) Application’
22:59:23 <Welkin> I don't know how to get my Raw endpoint working with the auth result
23:00:22 <cocreature> these errors usually come from a mismatch between your handlers and your API type. in that case I usually comment most of my API type and my handlers and add them back step by step to find the one that has a mismatch
23:01:38 <Welkin> the difference here looks like the PErsonId parameter is outside of Tagged in the second case, but inside in the first
23:01:53 <Welkin> s0 should be the same as the ReaderT in the second
23:12:39 <Welkin> there is exactly one error left
23:12:43 <Welkin> just that Tagged one
23:36:31 <adamretter_> jle`: Sorry about that, we had a power cut
23:37:34 <jle`> no worries :)
