00:00:06 <koz_> It's just too darned convenient.
00:00:49 <jle`> if you already know you need it, then you should use it
00:00:56 <jle`> it's tautologically true :)
00:01:11 <jle`> i don't always have that kind of foresight in most situations, though
00:01:20 <koz_> It just leaps out at me these days.
00:01:39 <tdammers> IME ReaderT is vastly more useful than Reader
00:01:50 <koz_> tdammers: Could you elaborate?
00:02:06 <dminuoso> koz_: `Reader` is just a relatively useless newtype wrapper for (->)
00:02:09 <jle`> Reader itself has very little to offer as an abstraction, heh
00:02:14 <tdammers> if you have a monad stack going anyway, and you have wrapped it in a type alias or newtype
00:02:31 <dminuoso> koz_: The Functor/Applicative/Monad instance you might be interested in, you already have with (->).
00:02:46 <tdammers> then adding a ReaderT into the stack allows you to add context to your code without touching anything but the parts that need to know about it
00:03:11 <koz_> tdammers: I guess I need an example to grok this.
00:03:16 <tdammers> OK
00:03:24 <koz_> I kinda see both Reader and ReaderT as 'why would I ever need this?'.
00:03:25 <jle`> koz_: how about -- try to think of a situation where you would ever use Reader
00:03:33 <koz_> I can't, that's the point.
00:03:33 <jle`> ah, you're talking about why ReaderT might be useful
00:03:37 <koz_> For either Reader or ReaderT.
00:03:43 <tdammers> ReaderT is kind of like an alternative way of writing an extra argument
00:03:44 <jle`> well, the "uselessness" of Reader is that fmap for Reader is just fmap for (->)
00:03:55 <jle`> <*> for Reader t is just <*> for (->) r
00:04:01 <dminuoso> koz_: `Reader` you don't really. `ReaderT` makes argument passing implicit at the cost of "making it visible" explicit.
00:04:02 <tdammers> foo :: ctx -> a -> b vs. foo :: a -> Reader ctx b
00:04:05 <jle`> (>>=) for Reader r is just (>>=) for (->) r
00:04:06 <koz_> tdammers: But... why not just pass an extra argument?
00:04:10 <dminuoso> koz_: You can just fine.
00:04:15 <jle`> but this isn't the case for ReaderT
00:04:17 <tdammers> koz_: exactly, you can do that, and it works just fine.
00:04:19 <dminuoso> koz_: ReaderT is just a little bit of convenience.
00:04:28 <jle`> fmap for ReaderT is different than fmap for (r -> m a)
00:04:31 <dminuoso> koz_: Just so you dont have to pass your "global environment" into every function in your application manually.
00:04:40 <jle`> (<*>) for ReaderT is different than (<*>) for (r -> m a)
00:04:44 <tdammers> but when you have a more elaborate monad stack already, the extra argument can become inconvenient
00:04:49 <jle`> same for (>>=)
00:04:49 <tdammers> especially with deeply nested calls
00:05:00 <tdammers> because now you have to explicitly drag that argument along throughout
00:05:02 <jle`> ReaderT allows you to use fmap, <*>, >>=, etc. and have them work as you would expect
00:05:26 <dminuoso> koz_: Like I said. `ReaderT` makes argument passing implicit (this is your benefit!) at the cost of requiring some extra noise to make the argument visible again.
00:06:02 <tdammers> it becomes more obvious when you consider that code isn't static; it's not so much about reading and writing, but more about changing code
00:06:40 <tdammers> it becomes even more relevant when you write certain things in terms of MTL typeclasses, like, say, MonadReader
00:07:12 <koz_> tdammers, jle`: Hmmm, OK.
00:07:30 <koz_> I _kinda_ see it, but I guess I'll just have to run into a situation face-first that benefits from it.
00:07:43 <jle`> you'd need (fmap . fmap) instead of fmap, for instance
00:07:44 <koz_> I guess its benefits are less obvious to me than, say, the benefits of State. Or Cont.
00:07:54 <dminuoso> koz_: ReaderT is not a big gain, it's just convenience.
00:08:05 <jle`> i think to me it's similar -- you'd only use it if you are able to save significant pain
00:08:24 <dminuoso> I know some folks who dislike ReaderT completely and prefer explicitly passing arguments.
00:08:30 <jle`> i wouldn't use `Writer a b` over `(a, b)` in most situations
00:08:40 <jle`> it'd only use it over `(a, b)` if it saves a lot of pain
00:08:59 <jle`> actually, i keep on forgetting it's 2019, and there actually isn't any advatnage, becuase (a, b) has the right Monad instance, heh
00:09:03 <jle`> so maybe that's a bad example :)
00:09:15 <jle`> i wouldn't use `WriterT a m b` over `m (a, b)` in most situations
00:10:16 <jle`> > sequence [("hi",1),("bye",2),("thrie",3)]
00:10:18 <lambdabot>  ("hibyethrie",[1,2,3])
00:10:44 <koz_> jle`: When did that change?
00:10:49 <jle`> a few years ago actually
00:11:25 <koz_> So now the Monad instance for (a,) is the same as for Writer a?
00:11:35 <koz_> (sorry, (,) a, I guess)
00:11:35 <dminuoso> jle`: Every time I think I finally found a good use case of WriterT, I get disproved by lazyness/strictness.
00:11:37 <jle`> since ghc 8.0, apparently, so May 2016
00:11:42 <jle`> koz_: yeah
00:11:42 <koz_> Woo.
00:12:09 <jle`> well the main thing i was rooting for was the Applicative instance
00:12:31 <koz_> I guess (Monoid a) => Applicative (,) a where ... ?
00:12:38 <jle`> oh wait the Applicative instance has been there a while
00:12:44 <jle`> i guess the thing i was rooting for was the Monad instance after all
00:13:08 <jle`> yeah, Functor/Applicative/Monad treat (a,b) as a 'b' "tagged" with an 'a'
00:13:24 <dminuoso> I find it intertesting that the Applicative instance for `Monoid a => (,) a` looks *very* similar to Monoid m => Applicative (Const m :: Type -> Type) in a lot of ways.
00:14:33 <jle`> yeah, they're both specializations of (Const m :*: f)
00:15:10 <koz_> They only differ in <*> right?
00:15:24 <jle`> the difference is that `(a, b)` "has" a b
00:15:27 <jle`> but `Const a b` doesn't
00:15:33 <tdammers> I still kind of believe that Writer was only invented because having State and Reader but no Writer would feel unsatisfying
00:15:36 <dminuoso> jle`: poor choice of variable names. :P
00:15:40 <koz_> Yeah. it's just pretnding to have a 'b'.
00:15:43 <jle`> ha
00:16:17 <jle`> i actually realized this when i was playing around with implementing foldMap in terms of traverse, and also VL lenses
00:16:29 <dminuoso> jle`: So I guess `Const a b` could be considered morally equivalent to `(a, Proxy b)` in this sense?
00:16:30 <jle`> at first the "obvious" choice was to use Writer
00:16:43 <jle`> since we're accumulating all of the results
00:16:51 <jle`> but i had to peskily fmap () over all of the Writer's
00:16:54 <koz_> VL lenses?
00:16:59 <jle`> van laarhoven lenses
00:16:59 <dminuoso> jle`: What did you mean with `(Const m :*: f)` by the way?
00:17:23 <jle`> dminuoso: :*: as in Product, or `data Product f g a = Pair (f a) (g a)`
00:17:26 <jle`> it's a product of two functors
00:17:37 <jle`> the product of two Applicatives always yields another Applicative
00:17:47 <jle`> so it's a neat way to factor out applicatives in terms of each other
00:18:13 <jle`> and yeah, (,) w = Product (Const w) Proxy
00:18:22 <jle`> um, Identity, not Proxy
00:18:30 <jle`> and `Proxy` is the identity with respect to Product/:*:
00:19:03 <dminuoso> up to strictness?
00:19:11 <jle`> mhm
00:19:43 <jle`> i guess the point is that (,) w can be factored out in terms of Const w and some other functor f.
00:20:25 <jle`> but yeah, i tried to implement foldMapDefault in terms of Writer first until i realized you could use Const ... and then my whole world changed
00:20:44 <jle`> writers hate this one trick
00:22:15 <jle`> if anyone reading is interested in comparing and contrasting (,) w and Const w, try to see how their Monad instances (if they have any at all) differ
00:23:21 <jle`> you can also look at this from the perspective of (,) w = Product (Const w) Identity, as well, since the product of two monads is also always a monad
00:23:53 <jle`> hm actually, that's a bad way to look at it.
00:23:56 <dminuoso> Really need to start experimenting with this, Product is something I have been unaware of until now.
00:24:12 <jle`> a very bad way to look at it, sorry :)
00:24:31 <jle`> dminuoso: yeah, Product doesn't get as much attention as its related cousin, Compose
00:24:57 <jle`> and there's another related type, Sum f g a = InL (f a) | InR (g a), the sum of two functors.
00:25:07 <koz_> Compose is the 'series' composition right?
00:25:26 <koz_> While Product is 'parallel' composition?
00:25:28 <jle`> yes. there's a decent amount of buzz about it
00:25:44 <dminuoso> koz_: Compose f g a = Compose { getCompose :: f (g a) }
00:25:49 <jle`> Sum comes up a lot when dealing with interpreter patterns/free monad types of applications
00:26:17 <jle`> but i think it's always interesting to see when you can "factor out" a functor interms of sum, product, and compose
00:26:43 <jle`> just be careful that while Functor instances are always unique, Applicative and Monad instances aren't.  so the "free" Applicative and Monad instances you get out of Sum/Product/Compose aren't always the ones you want
00:26:48 <dminuoso> Or, the defintion I prefer, `newtype (:.:) f g a = Compose { unCompose :: f (g a) }`
00:27:08 <koz_> Yeah, I can see why.
00:27:30 <koz_> fmap for Compose is fmap . fmap
00:27:38 <koz_> For Product it's 'fmap each side'.
00:27:54 <dminuoso> koz_: well for `Functor f, Functor g => Compose f g`, but yeah.
00:28:21 <koz_> dminuoso: Same for Product; you need (Functor f, Functor g) as a constraint.
00:28:27 <jle`> the composition of two functors is always a functor, the product of two functors is always a functor, the sum of two functors is always a functor
00:28:49 <koz_> Functors are closed under ADT operators. :P
00:29:00 <koz_> Is it true of Applicatives too?
00:29:01 <dminuoso> jle`: I smell a category emerging here.
00:29:09 <jle`> the composition of two applicatives is always an applicative, the product of two applicatives is always an applicative ... but what about sums? :)
00:29:16 <dminuoso> It's a beautiful thing to see a category being given birth to.
00:29:50 <koz_> jle`: Wait, hold on. Sum was what again?
00:29:58 <dminuoso> 09:24        jle` | and there's another related type, Sum f g a = InL (f a) | InR (g a), the sum of two functors.
00:31:30 <MarcelineVQ> koz_: Either
00:31:45 <koz_> MarcelineVQ: With some extra type params.
00:31:46 <MarcelineVQ> oop timestamps :>
00:33:40 <koz_> jle`: Is pure the problem?
00:34:06 <jle`> i don't think pure alone is necessarily the problem
00:34:22 <jle`> but you have a big problem with <*>, if you have InL on one side and InR on the other (or vice versa)
00:34:42 <koz_> Yeah, but even pure is questionable - do you default to InL . pure or InR . pure?
00:34:58 * hackage shh 0.1.0.1 - Simple shell scripting from Haskell  http://hackage.haskell.org/package/shh-0.1.0.1 (lukec)
00:35:16 <jle`> that just says you don't necessarily have a "unique" applicative, but you can pick one or the other to make one of two possibilities maybe
00:35:28 <koz_> But <*> still doesn't work.
00:35:33 <jle`> yeah, <*> is the dealbreaker
00:35:47 <koz_> Since you can't <*> together different Applicatives like that.
00:36:02 <koz_> Well, I guess we can't always have nice things.
00:36:32 <jle`> you can sometimes
00:36:35 <jle`> but you can't in the general case
00:37:03 <koz_> Under what circumstances would Sum f g be an Applicative?
00:37:19 <jle`> `Sum (Const e) Identity` is a famous one
00:37:35 <koz_> How is <*> defined on that?
00:37:41 <jle`> you have two options
00:38:36 <jle`> one is InL (Const e) <*> _ = InL (Const e); InR _ <*> InL (Const e) = InL (Const e); InR (Identity f) <*> InR (Identity x) = InR (Identity (f x))
00:39:09 <koz_> Ah, so Const e 'wins'?
00:39:15 <jle`> yeah
00:39:20 <jle`> this is `Either e a`
00:39:38 <jle`> or, `Sum (Const e) Identity ~ Either e`
00:40:39 <koz_> And what's the other one?
00:41:06 <jle`> it only works if e is a monoid, but you can split out the first case into Left x <*> Left y = Left (x <> y); Left x <*> Right _ = Left x
00:41:20 <jle`> hm actually you only need e Semigroup
00:43:11 <koz_> Hmm, OK.
00:44:47 <jle`> it needs to be a semigroup otherwise <*> is not associative
00:44:48 <Ariakenom> #3: Left x <*> Left y = Left y; Left x <*> _ = Left x; _ <*> Left y = Left y; ..
00:45:07 <jle`> ah yeah, that too :)
00:45:51 <koz_> Haskell is full of gems.
00:46:05 <jle`> extra credit: which of these (if any) happen to also be 'ap' for some Monad on Either e
00:46:37 <koz_> You mean some newtype over Either e, or the 'default' Monad for Either e?
00:46:39 <mapShow> Hi, can someone explain me how to use <$> I know the meaning of $ but there are no docs about it surrounded with GT LT, for example, why does this work like a map: (*2) <$> [1..10]
00:46:50 <koz_> I thought ap = (<*>) always?
00:47:00 <jle`> koz_: any possible Monad instance over Either e
00:47:04 <koz_> mapShow: fmap = (<$>)
00:47:08 <koz_> It's just infix fmap.
00:47:15 <koz_> > fmap (+ 3) (Just 4)
00:47:16 <jle`> mapShow: are you familiar with typeclasses?
00:47:17 <lambdabot>  Just 7
00:47:23 <koz_> > (+ 3) <$> (Just 4)
00:47:25 <lambdabot>  Just 7
00:47:31 <Ariakenom> :t (<$>)
00:47:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:47:35 <jle`> mapShow: do you know what `fmap (*2) [1..10]` does?
00:47:38 <mapShow> jle` yes kinda
00:47:49 <jle`> mapShow: typeclasses let you "overload" operations over different types
00:48:11 <mapShow> not so familiar with functors and monads
00:48:14 <jle`> 'fmap' is one operation overloaded for many different types
00:48:16 <mapShow> but I get the gross idea
00:48:24 <jle`> just like how +/*/etc. are overloaded over different numerical types
00:48:26 <jle`> for lists, fmap = map
00:48:33 * koz_ . o O (Functors are a gross idea?)
00:48:45 <jle`> so fmap is overloaded to work with many different types, and for lists specifically, `fmap = map`
00:48:59 <jle`> so `fmap (*2) [1..10]` evaluates to `map (*2) [1..10]`
00:49:32 <jle`> mapShow: the other half of the puzzle: Haskell lets you define custom operators
00:49:49 <jle`> so you can define x *#*@%# y = x + y * 2
00:49:57 <jle`> @let x *#*@%# y = x + y * 2
00:49:58 <lambdabot>  Defined.
00:50:06 <jle`> > 3 *#*@%# 7
00:50:07 <lambdabot>  17
00:50:14 <koz_> jle`: Looks like something from lens. :P
00:50:27 <jle`> mapShow: so <$> isn't special syntax -- it's a "user defined" operator
00:50:36 <jle`> it's defined as `f <$> x = fmap f xs`
00:50:45 <jle`> so tracing the evaluation/substitution:
00:50:51 <jle`> (*2) <$> [1..10]
00:50:59 <jle`> = fmap (*2) [1..10]     -- definition of <$>
00:51:06 <jle`> = map (*2) [1..10]    -- definition of fmap for lists
00:51:45 <jle`> admittedly, allowing for user-defined operators can make reading code confusing in a lot of situations
00:52:11 <jle`> it also requires a different mentality for reading, compared to other languages where all operators are built-in parts of the language
00:52:36 <mapShow> thanks for the great explanation, you said that <$> is user defined, but why is it available as standard operator
00:52:38 <mapShow> ?
00:52:50 <jle`> mapShow: it's user-defined, but it's exported as a part of Prelude
00:53:01 <Ariakenom> for some value of user
00:53:04 <jle`> the module imported implicitly ny default in every haskell module
00:53:29 <koz_> mapShow: A lot of Haskell stuff is defined in Haskell itself.
00:53:35 <koz_> Even the boolean type isn't built-in.
00:53:44 <koz_> Since it's just data Bool = False | True
00:53:44 <mapShow> interesting, so that is why there is no "official" docs about it? or does it have some docs somewhere?
00:53:48 <jle`> ah yeah, by "user-defined", i mean that it's defined as a part of a library.  the library just happens to come included by default
00:53:52 <koz_> mapShow: It does.
00:54:00 <jle`> it does have docs, and looking up docs is the usual way to read code with custom operators
00:54:24 <jle`> you can look it up with stoogle if you arne't sure what library it's from
00:54:25 <jle`> https://www.stackage.org/lts-13.4/hoogle?q=%3C%24%3E
00:54:31 <mapShow> can someone point where to look the docs for <$> for example?, I couldn't find it
00:54:32 <jle`> but if you know the library, you can check out the index
00:54:39 <jle`> the library is base https://hackage.haskell.org/package/base
00:54:39 <koz_> mapShow: http://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:-60--36--62-
00:54:59 <jle`> in this case you can use the Quick Jump functionality
00:55:32 <jle`> from https://hackage.haskell.org/package/base , under the "modules" heading you can click on "Quick Jump"
00:55:44 <jle`> in general if you don't know the exact library you can use hoogle or stoogle
00:55:55 <jle`> um stoogle is my nickname for stackage hoogle
00:57:06 <mapShow> wow so cool, thanks @jle` and @koz_
00:57:14 <mapShow> I will keep reading and improving
00:58:09 <jle`> np. happy haskelling :)
01:01:01 <koz_> jle`: LOL@stoogle.
01:10:33 <e|f> hi
01:10:36 <e|f> guys and girls
01:10:50 <e|f> can anyone of you clever people give me with a pure math example of floor()
01:10:54 <e|f> ?? <3
01:10:54 <lambdabot>  <3
01:11:19 <e|f> like basically all functions are math at a base right
01:11:27 <e|f> cause computers are essentially math machines
01:11:48 <e|f> and floor(N) would return the lowest and closest integer
01:11:59 <e|f> but what would the function look like on a math level?
01:12:21 <tdammers> I'd say that computers are fundamentally incapable of doing actual math
01:12:59 <jle`> we're just really good at tricking computers to do math
01:13:07 <jle`> well, maybe we're so-so good at it
01:13:13 <e|f> like umm all the hyperbolic functions like sin() tan() etc are stuff like n ^ 2 + 1 or whatever
01:13:20 <e|f> but what would that magic floor() be
01:13:30 <jle`> why do you count sin() as a base function, but not floor() ?
01:13:50 <koz_> e|f: I can assure you, the hardware pain behind sin, tan and friends is _severely_ non-trivial with IEEE floats.
01:13:57 <e|f> well i'm just giving an example off the top of my head
01:14:23 <jle`> e|f: right, so, would you also ask for a pure math example of sin() ?
01:14:32 <e|f> nah
01:14:35 <koz_> e|f: I guess we're not very clear on what you mean by a 'pure math example' of anything.
01:14:38 <jle`> why not?
01:14:43 <jle`> why is sin() special, and floor() not?
01:14:54 <e|f> well Leonhard Euler that very clever math guy pretty much invented functions, didn't he
01:14:58 <jle`> i think really, if you're happy with sin(), you should be happy with floor() in the same way :)
01:15:07 <e|f> a way of simplifying stuff
01:15:10 <koz_> e|f: Wat.
01:15:15 <e|f> and a function is almost like a subroutine
01:15:29 <tdammers> it may be worth noting that the sin() and floor() functions as implemented on typical computers are an entirely different beast from sin and floor in math
01:15:37 <e|f> ok ok
01:15:44 <e|f> well forget my example of sin()
01:15:56 <e|f> just wondered if anyone knew how to express floor()
01:15:58 <e|f> :D
01:15:58 <jle`> e|f: you should really be looking inwards to ask why floor() is any different than, say, multiplication or addition
01:16:04 <koz_> e|f: In terms of what?
01:16:06 <jle`> in your mind
01:16:40 <tdammers> well, floor is just that. if you want implementation details, you need to decide on a numeric type, i.e., a binary representation of numbers that you want to work with
01:17:09 <koz_> Additionally, this tends to be done in hardware.
01:17:11 <tdammers> for example, if you pick 16.16 fixed-point, then floor() amounts to taking the absolute, zeroing out the lower 16 bits, and then reinstating the sign
01:17:19 <koz_> It doesn't _have_ to be, but it usually is.
01:17:27 <e|f> see tdammers knows what i mean
01:17:29 <e|f> :D
01:17:35 <koz_> Which obviously changes how it's implemented and in terms of what we're talking about.
01:17:43 <jle`> e|f: also, in math, your really only pick a definition that's based on what's most useful to you in your current situation
01:17:46 <koz_> e|f: So you specifically sought 16.16 fixed-point?
01:17:52 <koz_> That's... awfully specific.
01:18:17 <jle`> e|f: in real analysis, for example, it's useful to think of floor(x) as being the largest integer less than or equal to x
01:18:27 <jle`> math isn't about absolute definitions, but rather useful definitions
01:18:32 <e|f> well, i know for example some programming languages have a base() function to switch numbers between different bases
01:18:35 <jle`> and what is useful varies based on situations and situations
01:18:40 <e|f> and for that you use math, but i can't remember the math for it
01:18:44 <e|f> but i know it's math
01:18:53 <e|f> so floor() is a binary calculation!
01:19:08 <e|f> tdammers knew what i meant
01:19:18 <jle`> e|f: well, floor() is a binary calculation if its inputs are represented as binary
01:19:19 <tdammers> EVERYTHING is a binary calculation
01:19:25 <koz_> e|f: What tdammers said.
01:19:30 <tdammers> on a binary computer, anyway
01:19:32 <koz_> Unless you're on a Soviet-era ternary computer.
01:19:44 <jle`> e|f: that's "vacuously" true; everything that works with binary is a binary calculation. just like *, +, etc., if they operate on binary representations 
01:19:51 <jle`> so is sine, cosine, etc.
01:19:59 <koz_> And the 'math for it' depends on how you represent your numbers.
01:20:04 <e|f> i know what floor() does... just wondered what it looked like as a "calculation"
01:20:08 <koz_> Absent that being specified, there's not much we can tell you.
01:20:16 <tdammers> you can also pick a decimal representation, e.g. ASCII, where each decimal digit is encoded as its ASCII code; then you would keep taking digits from the left until you encounter end-of-string or a decimal point
01:20:21 <jle`> e|f: ah, you mean, what it looks like on binary representations?
01:20:27 <e|f> YES!
01:20:28 <e|f> :D
01:20:50 <jle`> okay. yeah, that's definitely different than asking about the 'math' of it, i think, but yeah, that's one way to implement it on binary encodings :)
01:21:00 <tdammers> if you pick a floating-point representation, you would take the mantissa, shift it to the left by the exponent, and then to the right by the mantissa size, dropping bits shifted "out" to the right
01:21:30 <tdammers> (actually you would also have to take the sign into account, as well as infinities, but that's essentially how it's done)
01:21:30 <jle`> e|f: note that if your numbers aren't encoded as binary, you will have a different implementation of floor
01:21:35 <e|f> like to do base(123, 10, 16) i can visualise in my mind the math for it and can easily find the math solution to it... convert decimal 123 from decimal to hexadecimal
01:21:46 <e|f> but floor(123.2) (123) i cannot visualise
01:22:06 <jle`> e|f: if you look at it at that way, it's just dropping everything to the right of the decimal point
01:22:06 <e|f> lol cool
01:22:15 <e|f> yea :)
01:22:18 <jle`> but yeah, i think you might be asking about algorithms, not functions
01:22:33 <jle`> and algorithms can be described in terms of what "primitive" operations you have, once you pick a set you want to use
01:22:44 <e|f> my question was a bit ambiguous, eh?
01:22:48 <jle`> for example, if you allow modulus, you can implement floor(x) = x - (x % 1)
01:22:52 <e|f> but you all know what i mean now
01:23:03 <tdammers> > let { floorStr :: String -> String; floorStr = takeWhile (/= '.') } in floorStr "123.5"
01:23:04 <jle`> @let myFloor x = x - (x `mod` 1)
01:23:05 <lambdabot>  "123"
01:23:05 <lambdabot>  Defined.
01:23:10 <jle`> > myFloor 123.2
01:23:12 <lambdabot>  error:
01:23:12 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M320991191474...
01:23:12 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
01:23:27 <jle`> > myFloor 123.2 :: Double
01:23:29 <lambdabot>  error:
01:23:29 <lambdabot>      • No instance for (Integral Double) arising from a use of ‘myFloor’
01:23:29 <lambdabot>      • In the expression: myFloor 123.2 :: Double
01:23:38 <jle`> oh heh, ignore that
01:24:05 <MarcelineVQ> you guys must be fairly bored tonight
01:24:05 <tdammers> anyway, if you want to know more about the implementation of floating-point primitives, I guess the first thing to do is read up on how floating-point numbers work
01:24:36 <e|f> and where can i find the reading material please ?? 
01:24:37 <e|f> :D
01:25:07 <tdammers> e|f: https://en.wikipedia.org/wiki/Floating-point_arithmetic is as good a starting point as any
01:25:34 <jle`> but yeah, be careful also not to confuse math with computaiton/algorithms :) it's a common confusion, and it's perpetuated by the state of math education in most of the world, i think
01:25:40 <koz_> MarcelineVQ: Aren't we always? :P
01:25:45 <koz_> What jle` said.
01:25:48 <koz_> Like, a thousand times.
01:26:38 <e|f> lol cool
01:26:52 <e|f> i tried to find the answer with google but it was way to ambiguous to find
01:26:56 <e|f> so i asked here
01:27:00 <e|f> thank you very much <333
01:27:01 <jle`> you could also try ##math
01:27:49 <e|f> thanks guys
01:27:50 <e|f> !
01:29:06 <tdammers> also I think it's sad how math education in most parts of the world is still stuck in the 19th century
01:30:48 <nshepperd1> @let verySlowFloor x = last $ takeWhile ((<=x) . fromIntegral) $ [0..]
01:30:50 <lambdabot>  Defined.
01:31:12 <nshepperd1> > verySlowFloor (157.75 :: Double)
01:31:14 <lambdabot>  157
01:32:25 <koz_> tdammers: You and me both.
01:37:39 <jle`> > verySlowFloor (-157.75 :: Double)
01:37:41 <lambdabot>  *Exception: Prelude.last: empty list
01:38:43 <koz_> such floor
01:40:48 <nshepperd1> Negative numbers? A proposterous concept!
01:42:14 <koz_> nshepperd1: God _did_ give us the integers.
01:42:37 <MarcelineVQ> god gave you the naturals, integers are a corruption
01:43:15 <nshepperd1> Negation is a power some might consider... unnatural
01:43:18 <koz_> MarcelineVQ: Not according to Kronecker.
01:44:04 <tdammers> in fact, one of my math teachers in highschool did briefly go down that route, when we discussed imaginary and complex numbers. essentially, he went, OK, so we have natural numbers and whole numbers and rational numbers and real numbers, so let's write down the rules we have for those so far, see, here's a problem, we can't take the square root of a negative number, so let's just pretend we can, and we don't
01:44:06 <tdammers> care about imagining that number, we'll just give it an arbitrary name, and then we'll go back and formally prove how all the rules we just wrote down are still consistent
01:44:52 <mniip> hmm, is there a version of TChan where I can explicitly query whether any readers are waiting for a value to appear?
01:45:19 <jle`> mniip: that sounds like a sign to switch to something other than tchan, heh
01:45:30 <jle`> oh, you asked if there was another version
01:45:38 <mniip> well I am making my own version of a queue anyway
01:45:47 <mniip> with TChan as one of the internal components
01:46:54 <tdammers> I think there are a few size-limited chan types around, those might be more appropriate
01:47:32 <mniip> size-limited?
01:47:42 <mniip> how is that relevant
01:50:07 <tdammers> well, *why* do you need to know about consumers?
01:52:15 <mniip> I push tasks to be completed into a queue, and when pushing I want to know whether the handling of the task has been started immadiately or if it was merely queued
01:52:20 <mniip> to update the "UI" appropriately
01:52:41 <tdammers> ah
01:52:48 <tdammers> then I don't think (T)Chan is the right abstraction
01:53:04 <mniip> right, what is, then
01:53:18 <Taneb> :t foldr (\a b -> pure a <|> b) empty
01:53:19 <lambdabot> (Alternative f, Foldable t) => t a -> f a
01:53:27 <Taneb> Does this exist anywhere in base?
01:53:37 <Taneb> It's almost but not quite asum
01:53:51 <mniip> :t asum
01:53:52 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
01:53:58 <jle`> Taneb: basically it's alternativeToFoldable, huh
01:54:01 <mniip> :t afoldr
01:54:02 <tdammers> I'd consider something like a Map or HashMap of job IDs to jobs, shared through a mutable primitive (MVar, TVar, whatever)
01:54:02 <lambdabot> error:
01:54:02 <lambdabot>     • Variable not in scope: afoldr
01:54:02 <lambdabot>     • Perhaps you meant one of these:
01:54:13 <tdammers> and then both consumer and producer would communicate job statuses through that
01:54:26 <jle`> er, `foldableToAlternative`
01:54:49 <jle`> i don't think it's anyhwere, no, but it looks like some sort of safe head?
01:54:55 <tdammers> or maybe not Map, but something that can cater for things like job priorities, idk
01:54:56 <jle`> it exists for a lot of specific types
01:55:04 <jle`> in particular, for t ~ [], f ~ Maybe, it's listToMaybe
01:55:18 <Taneb> I'm in particular looking for Maybe a -> MaybeT IO a
01:55:19 <mniip> tdammers, that would require the writing thread to wait for the reading thread to update the status
01:55:24 <mniip> that doesn't fit the abstraction
01:55:38 <jle`> Taneb: ah. yeab, for that one i use `maybe empty pure`
01:55:49 <jle`> and a lot of people use `MaybeT . pure` but i'm not a huge fan
01:56:29 <mniip> the "UI" is remote, so to display the queued status, and then let the reading thread undisplay it; would be the wrong thing to do
01:57:25 <Taneb> jle`: thanks, that works
01:59:13 <jle`> np
02:18:12 <mniip> so it all boils down to an MVar in which you can test whether anyone's reading
02:19:20 <mniip> I mean, this information should be available to the GHC runtime, but I don't see any APIs for that
02:26:32 <merijn> Anyone aware of a library doing text diffs?
02:32:28 <body> what is haskell programming language good to program with ?
02:33:15 <maerwald> body: web stuff
02:33:21 <maerwald> also other stuff
02:33:31 <body> maerwald: can u give me some examples pls ?
02:33:45 <maerwald> https://www.yesodweb.com/
02:34:19 <maerwald> It has good ecosystem coverage. Other areas are less well covered
02:34:30 <maerwald> The language itself is general purpose though
02:36:38 <mniip> tdammers, hmm, if I had access to Chan's internals
02:36:38 <merijn> I write basically everything in Haskell if I get the chance :p
02:36:48 <merijn> mniip: What do you want that for?
02:36:50 <mniip> I could test whether the MVar on the read end is taken
02:37:17 <mniip> merijn, I need a Chan with a quirk
02:37:21 <body> I know just python at the moment, but i'd like to learn haskell because my desktop wm config it's in haskell lol
02:37:26 <mniip> when pushing, I need to know whether it's immediately taken out
02:37:37 <mniip> i.e if there was a thread waiting on this chan
02:37:45 <merijn> mniip: Should be easy with an STM chan?
02:38:07 <mniip> how so
02:38:24 <merijn> hmm, actually I guess timing might be tricky...
02:38:34 <merijn> mniip: What do you want that for?
02:39:23 <mniip> I need to do a certain action if the input was "queued" rather than immediately started being executed
02:40:20 <merijn> mniip: Easiest solution is probably to just fork the Chan source?
02:40:36 <mniip> that's what I was thinking
02:40:36 <merijn> Unrelatedly: Float...y u no Bits instance?!?
02:40:45 <mniip> well, "fork" - the relevant code is about 20 lines
02:40:53 <tdammers> body: it's probably better to ask what Haskell is *not* a great fit for
02:41:50 <c50a326> it seems to me that all the lambda calculus does is say "things can go next to one another or be passed into one another"
02:41:53 <body> tdammers: i mean what can u do for web with it for example
02:42:32 <merijn> @hoogle Float -> (Int, Int)
02:42:33 <lambdabot> Data.Random.Internal.Words word32ToFloatWithExcess :: Word32 -> (Float, Word32)
02:42:33 <lambdabot> Graphics.Gloss.Interface.IO.Game EventMotion :: (Float, Float) -> Event
02:42:33 <lambdabot> Graphics.Gloss.Interface.Pure.Game EventMotion :: (Float, Float) -> Event
02:42:50 <mniip> merijn, do you want 2.0 .|. 4.0 = 6.0
02:42:52 <mniip> or = 4.0
02:43:15 <merijn> mniip: I want the actual bit representation of IEEE754
02:43:36 <merijn> mniip: i.e. "here's bits for the mantissa" and "here's bits for the exponent"
02:43:37 <maerwald> body: what do you mean? 
02:44:01 <merijn> mniip: i.e. I want this diagram: https://stackoverflow.com/questions/15685181/how-to-get-the-sign-mantissa-and-exponent-of-a-floating-point-number
02:44:42 <merijn> mniip: I'm not sure what that ends up computing for your example
02:44:43 <mniip> that's not exactly the abstraction provided by Bits, I think
02:45:20 <mniip> 2.0 = 0x40000000, 4.0 = 0x40800000
02:45:38 <merijn> I see we have "decodeFloat_Int# :: Float# -> (#Int#, Int##)" in GHC.Prim, but there doesn't seem to be a non-MagicHash wrapper
02:45:48 <mniip> of course there is
02:45:50 <mniip> :t decodeFloat
02:45:52 <lambdabot> RealFloat a => a -> (Integer, Int)
02:46:11 <merijn> mniip: Ok, rephrase: I couldn't find it :p
02:46:24 <body> maerwald: I mean, what can I write, like ... dunno for the web, how I would integrate haskell + html ?
02:46:38 <c50a326> what can I do with lambda calculus? at the start of this kmett talk https://www.youtube.com/watch?v=PA1Fc7DNKtA&t=2m he busts out a toy lambda calculus which I guess I can copy... and I guess it can probably be written in other ways too maybe... but what can I do with it?
02:46:39 <mniip> body, probably with an html eDSL
02:47:01 <mniip> c50a326, lambda calculus is the underlying theory of pure functional languages
02:47:02 <c50a326> body: haskell is supposed to be great at parsing and generating (templating)
02:47:12 <mniip> haskell is lambda calculus with bells and whistles
02:47:21 <c50a326> mniip: yes but what can i try/do?
02:47:28 <c50a326> I can't understand things without trying/doing things, so I need things to do
02:47:40 <mniip> well, you can experiment with chruch encodings of things
02:47:45 <c50a326> with LC I can't guess what I can do with it, specifically using a toy LC inside haskell
02:48:04 <mniip> you can encode boolean algebra, products, coproducts, numbers, in lambda calculus
02:48:20 <merijn> c50a326: Church encoding is very similar to CPS and can often speed up traversals/recursions
02:48:39 <merijn> (Or is it usually Scott encoding? I always forget which is which)
02:48:41 <c50a326> cool, thanks, I'll check it out
02:49:05 <merijn> c50a326: For example the builder from lists fusion rules basically encodes the list as a Church encoding to avoid materialising it
02:49:53 <mniip> scott encoding ~ uncons
02:49:57 <mniip> church encoding ~ foldr
02:50:04 <merijn> :t uncons
02:50:05 <lambdabot> [a] -> Maybe (a, [a])
02:50:15 <maerwald> body: frontend is probably not particularly nice in haskell. The things that let you do JS are rather heavy-weight. But backend and backend generated html is very nice
02:52:42 <phadej> maerwald: depends, https://launchpad.net/~hvr/+archive/ubuntu/ghcjs is e.g. easy way to get ghcjs if you happen to be on ubuntu :)
02:52:58 <merijn> phadej: ghcjs is still heavy weight for frontend
02:53:06 <merijn> 500kb-1mb results are common
02:53:22 <phadej> oh dear, nothing can be used if it's not perfect?
02:53:35 <phadej> and https://github.com/nomeata/hackage-ghcjs-overlay helps with avoiding nix too
02:53:41 <c50a326> body: elm is really nice for front-end... and there's purescript if you need it
02:53:50 <merijn> phadej: I didn't say that, but maerwald's comment was that frontend work is a bit to heavyweight in Haskell
02:54:10 <maerwald> phadej: ghcjs is a fast car without doors ;)
02:54:17 <merijn> phadej: So then trotting out ghcjs doesn't really seem to address that issue?
02:54:18 <phadej> I understood it's heavyweight as in setting things up is not simple
02:55:48 <mniip> reading the comment under http://hackage.haskell.org/package/base-4.12.0.0/docs/src/Control.Concurrent.Chan.html#writeChan
02:55:50 <phadej> fwiw, Elm and Purescript are completely different languages; the syntax tricks you to think they are similar; they aren't
02:55:57 <mniip> is that still true in presence of modifyMVarMasked?
02:56:01 <phadej> (similar to Haskell)
02:58:36 <merijn> mniip: Yes
02:58:43 <mniip> how so
02:59:08 <merijn> mniip: Lemme reacquaint myself with the code
03:01:39 <merijn> Actually I was thinking of a different part of the code. I think you might be right about modifyMVarMasked there
03:01:55 <mniip> perhaps that should be refactored then
03:02:05 <mniip> to match the other function
03:02:29 <merijn> Maybe
03:04:41 <mniip> /Either/ way
03:07:31 <xsperry> hi. is this a good example of higher kinded types (Unit type class)? or, in other words, would it be easy to replicate this in a language that doesn't have higher kinded types? https://bpaste.net/show/dc2d1c645198
03:08:10 <jle`> Unit is a higher-kinded typeclass, yes
03:08:47 <jle`> so it might not be very natural to express in a language without higher kinded types
03:09:02 <mniip> you can emulate it in a language with simple-kinded associated types
03:09:04 <mniip> e.g C++
03:09:24 <xsperry> jle' I know. I was actually struggling to express this, and then it got to me, it should be HKT
03:09:58 * hackage quickcheck-transformer 0.3 - A GenT monad transformer for QuickCheck library.  http://hackage.haskell.org/package/quickcheck-transformer-0.3 (HenningThielemann)
03:11:03 <xsperry> mniip, can you roughly explain how? if it wouldn't take too long, as I guess it isn't really topical
03:13:19 <mniip> xsperry, you require that a Unit be some class C with a member template associated type
03:13:23 <mniip> C::rebind<A>
03:13:33 <mniip> such that C::rebind<A>::value_type = A
03:13:41 <mniip> and C::rebind<A>::rebind<B> = C::rebind<B>
03:14:05 <mniip> well, it can be an associated type of C or an associated type of some "traits" class
03:15:42 <xsperry> ok, interesting. how about in a language like C#, or rust, or python?
03:18:33 <mniip> python has no types
03:18:51 <mniip> no idea about the generic programming capabilities of the other two
03:19:31 <maerwald> mniip: not correct https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy
03:19:36 <maerwald> types are part of the language spec
03:21:08 <xsperry> do you think this is a decent example when trying to explain non-haskell people what is possible with higher kinded types? since it is less esoteric and easier to understand to someone coming from other languages than something Functor or Monad
03:21:18 <xsperry> +like
03:24:10 <mniip> not really
03:24:10 <mniip> maerwald, what I meant is that python doesn't have static types in the sense of having useful computations on types
03:24:11 <mniip> xsperry, Functor is probably the most accessible one
03:24:15 <dminuoso> xsperry: I dont think higher kinded types are easy to explain because they are rather abstract.
03:24:20 <tdammers> maerwald: that's not what people mean when they talk about types in the context of type theory
03:24:26 <dminuoso> ^- fully agree that Functor is the most accessible one.
03:24:30 <Lears> I would go straight for Functor. Btw, in this case you should just make your data decs newtypes and use coerce.
03:24:51 <xsperry> Lears, for efficiency reasons?
03:24:54 <maerwald> tdammers: well, but the language *has* types. I don't think anything prevents you from introducing "compile-time type checking" in python.
03:25:00 <xsperry> I'm not sure how that would work
03:25:08 <dminuoso> The notion of "Functor represents things you can map over" is the easiest example of HKTs.
03:25:11 <maerwald> Except that this is not default behavior and will, if at all, only be opt-in in the future
03:25:47 <maerwald> it's like -fdefer-type-errors, basically
03:25:52 <maerwald> But the other way around
03:26:06 <dminuoso> In the end HKTs are useful for the same reason that higher order functions are useful, and its equally difficult to explain HOFs and why they are useful to someone who has never experienced them.
03:26:07 <mniip> fdefer type errors is nothing like dynamic typing
03:26:09 <Lears> Partially because it's free at runtime yes, but also because GHC gives you nice machinery for dealing with newtypes.
03:27:35 <xsperry> Lears, can you give me a short example of how that would look?
03:27:41 <Lears> % unwrap :: Coercible (f a) a => f a -> a; unwrap = coerce
03:27:41 <yahb> Lears: 
03:27:57 <Lears> % newtype Weight a = Weight { fromWeight :: a }
03:27:57 <yahb> Lears: 
03:28:07 <Lears> % unwrap (Weight 3)
03:28:07 <yahb> Lears: 3
03:28:33 <dminuoso> 12:24    maerwald | tdammers: well, but the language *has* types. I don't think anything prevents you from introducing "compile-time type checking" in python.
03:28:46 <dminuoso> maerwald: To be exact: The relevant Python PEPs even define it as a compile-time thinig.
03:28:48 <mniip> again, I wasn't talking about checking
03:28:59 <mniip> computation rather
03:29:23 <mniip> in C++ templates are a form of type-level computation: you have different type expressions that are equal types
03:29:50 <mniip> or well I guess that's not templates but (template) "using"s
03:32:33 <dminuoso> mniip: well Python offers forward type references, so you do get some kind of type computation
03:34:06 <dminuoso> It's a bit like TH except limited to the type level
03:37:28 <merijn> Anyone know where I can find a hexFloat parser for attoparsec (or megaparsec)
03:39:13 <infinisil> merijn: Nope, but can't you just compose one yourself? Should be pretty simple
03:40:05 <merijn> infinisil: I don't understand the representation, so *I* certainly can't compose one :)
03:40:06 <infinisil> Oh, hexadecimal float, maybe not so easy
03:40:07 <mniip> that's rather unsimple
03:40:19 <mniip> I'm sure I've seen one somewhere
03:40:31 <mniip> in 'base' perhaps? (well, not Parsec)
03:40:35 <merijn> mniip: I found parsec-numbers, but that's, well, parsec only
03:40:38 <infinisil> (my mind just thought, hex is easy, float is easy, so hex float should be easy too)
03:40:56 <__monty__> maerwald: I think all the gradual typing efforts hint at how hard statically typing python is. And you might not end up with a useful type system. If it's basically unityped+typed literals you don't gain much.
03:40:58 <merijn> Also parsec-numeric, but again, parsec
03:41:20 <Ariakenom> "float is easy [Citation needed]"
03:41:27 <mniip> someone was discussing it in here...
03:41:37 <merijn> Maybe just binary data would be simpler to deal with
03:41:54 <infinisil> Ariakenom: You have a point..
03:41:59 <merijn> But more annoying to generate/process :\
03:43:09 <merijn> mniip: I see proposals for hexfloat support in GHC and https://hackage.haskell.org/package/FloatingHex but nothing particularly nice to use with text/existing parsers
03:43:57 <mniip> grepping my logs
03:44:01 <mniip> will take a while
03:44:12 <merijn> oh, looks like the hexFloat proposal was already merged
03:45:59 <merijn> Humbug
03:46:18 <merijn> Looks like GHC itself supports them and there's showHFloat to render them, but no operation to read them...
03:46:28 * hackage guarded-allocation 0.0.1 - Memory allocation with added stress tests and integrity checks  http://hackage.haskell.org/package/guarded-allocation-0.0.1 (HenningThielemann)
03:47:04 <merijn> This is, like, the world's dumbest oversight ever...
03:48:47 <merijn> FML >.>
03:50:04 <__monty__> merijn: The proposal mentions the Read instance would break backwards compatibility, it hand waves this away but maybe the committee found it prudent to hold off on that?
03:50:27 <merijn> __monty__: My objection isn't the lack of support via Read
03:50:40 <merijn> __monty__: My objection is that Numeric doesn't have a function to parse it AT ALL
03:51:14 <merijn> There's readSigned, readInt, readDec, readOct, readHex, readFloat, but no one bothered to add readHexFloat
03:51:41 <__monty__> Maybe readHexRational?
03:51:59 <merijn> __monty__: Where would that be?
03:52:08 <__monty__> Utils >.<
03:52:14 <merijn> __monty__: That's in the *tests*
03:54:18 <__monty__> merijn: Tests? Not sure what you mean, I'm talking about this: https://hackage.haskell.org/package/ghc-8.6.1/docs/Util.html#v:readHexRational
03:55:55 <mniip> yes!
03:55:57 * hackage comfort-array 0.3 - Arrays where the index type is a function of the shape type  http://hackage.haskell.org/package/comfort-array-0.3 (HenningThielemann)
03:55:58 <mniip> that'e exactly the function
03:56:00 <mniip> I had in mind
03:58:05 <merijn> Yeah, but that's part of GHC itself, rather than base
03:58:21 <merijn> AFAIK you can't import that, at least not without depending on GHC which seems excessive
03:58:30 <__monty__> Oh, I know, hence the >.<
03:59:26 <__monty__> Does base depend on GHC? I assume so. So it shouldn't be hard to add there, right?
03:59:56 <merijn> __monty__: No, base ships with GHC, but that's not the same
04:00:08 <merijn> __monty__: Depending on GHC means linking all of actual GHC inside your application
04:00:48 <Taneb> merijn: sounds like you have a mailing list to email
04:01:27 * hackage data-ref 0.0.2 - Unify STRef and IORef in plain Haskell 98  http://hackage.haskell.org/package/data-ref-0.0.2 (HenningThielemann)
04:01:47 <__monty__> Taneb: https://ghc.haskell.org/trac/ghc/ticket/16216
04:04:58 * hackage unique-logic-tf 0.5.1 - Solve simple simultaneous equations  http://hackage.haskell.org/package/unique-logic-tf-0.5.1 (HenningThielemann)
04:14:27 * hackage lapack 0.2.1 - Numerical Linear Algebra using LAPACK  http://hackage.haskell.org/package/lapack-0.2.1 (HenningThielemann)
04:19:28 * hackage lapack-ffi-tools 0.1.2 - Generator for Haskell interface to Fortran LAPACK  http://hackage.haskell.org/package/lapack-ffi-tools-0.1.2 (HenningThielemann)
04:44:27 * hackage shh 0.1.1.0 - Simple shell scripting from Haskell  http://hackage.haskell.org/package/shh-0.1.1.0 (lukec)
04:46:40 <c50a326> ghc is building something and using a shed load of CPU on linux
04:46:44 <c50a326> well, I'm building haskell-ide-engine
04:47:08 <c50a326> it's kind of overheating my machine, I tried using renice to set the priority lower, but it's got several processes and I think it spins up more over time
04:47:27 <c50a326> is there some command I can run to make it only be able to use say 50% of CPU?
04:48:56 <mtesseract> c50a326 "ulimit" maybe?
04:56:15 <hpc> if nothing else works you could try a VM
04:56:25 <srk> or cgroups :)
04:56:40 <hpc> but yeah, something else is better to start with ;)
04:57:45 <hpc> it looks like ulimit sets the amount of cpu time in seconds with the -t flag
04:58:41 <hpc> i have a feeling that means it'll kill processes that exceed that
05:00:07 <hpc> cgroups look like the way to go here
05:06:57 * hackage shh 0.2.0.0 - Simple shell scripting from Haskell  http://hackage.haskell.org/package/shh-0.2.0.0 (lukec)
05:10:08 <amx> or maybe work from the other end and improve cooling
05:10:51 <mniip> Maybe Bool
05:10:52 <mniip> :/
05:11:46 <hpc> if you use Maybe (Maybe ()) you can use join to cover both failure cases
05:11:48 <hpc> much better :D
05:12:17 <mniip> they're not failures
05:12:21 <mniip> they're just... different results
05:12:29 <srk> Maybe Cool :]
05:12:34 <hpc> heh
05:12:39 <mniip> it's more of a
05:13:01 <mniip> Sigma_(a : Bool)  (if a then Bool else ())
05:13:38 <hpc> hmm, i thought i actually had an actual instance of Maybe Bool in my current project
05:13:42 <hpc> but i guess not
05:14:02 <hpc> i have a bunch of Maybe (other stuff) for config options that can default based on an external program
05:14:35 <mniip> These () ()
05:15:08 <hpc> data OneOf a b = LolJK
05:16:57 * hackage prolog 0.2.1 - A Prolog interpreter written in Haskell.  http://hackage.haskell.org/package/prolog-0.2.1 (JanisVoigtlaender)
05:28:57 <WilliamHamilton[> wrengr_away: in your package unification-fd, you mention that various optimizations have been applied: could you point me toward the papers that describe those optimizations? I only found Dijkstra's `Efficient Functional Unification and Substitution`
05:34:29 <phadej> WilliamHamilton[: iirc the "other optimisations" are local, the algorithm itself is the one described in that paper
05:38:21 <phadej> the path compression is something not in dijkstra's paper; I guess
05:39:13 <aplainzetakind> The only way to define something like `foo 0 = id; foo n = (.) . foo (n - 1)` is Template Haskell I suppose?
05:40:15 <phadej> what's that
05:40:43 <aplainzetakind> (.) . (.) . ... . (.) of arbitrary length.
05:40:56 <phadej> if you cannot write it's type...
05:41:12 <aplainzetakind> Yes.
05:42:02 <infinisil> aplainzetakind: You'd need a different function for each length, TH can write those for you, but it can't define a single function for all lengths
05:42:30 <Ferdirand> can't you abuse type classes to get something like that ?
05:43:34 <dminuoso> Ferdirand: Considering that you can write a generic `lift` version of liftAx that works for an arbitrary number of arguments.. it should be possible using the same technique.
05:44:14 <aplainzetakind> dminuoso: Isn't it impossible, is what I was thinking about actually.
05:44:19 <WilliamHamilton[> thanks phadej ! Do you happen to know names for the local optimizations, so that I can look them up? For example, where should I read about `path compression`? Is it important?
05:44:37 <dminuoso> aplainzetakind: Let me try the technique
05:45:04 <phadej> aplainzetakind: you can write https://gist.github.com/phadej/233fa6c20979b9b13cdd687b26145e23, but then you'd need to specify the argument types as GHC isn't able to infer it
05:45:13 <phadej> making that all inferable is really not worth it
05:46:07 <phadej> WilliamHamilton[: to my understanding the path compression is what `semiprune` does
05:46:44 <aplainzetakind> phadej: OK, I don't know about INLINE, nor type families, so that's a bit beyond me.
05:47:45 <WilliamHamilton[> phadej: I see, I'll dig through the sources of that package then (especially the *prune functions)! Thanks again
05:48:00 <dminuoso> aplainzetakind: Need to sit down in quiet, but Im fairly sure you can do it with typeclasses and fundeps.
05:49:32 <aplainzetakind> dminuoso: Why wouldn't such a function be in the library if it's possible?
05:50:26 <xsperry> sorry for being a bit OT, but it is hard to find people who know both haskell and C#. about my earlier haskell higher kinded type example. someone managed to reproduce similar code in C#. is the haskell code more general in any way that I'm missing, because it looks to me that it isn't (ignoring the fact that C# doesn't have Fractional typeclass equivalent, hence the need for MyDouble, as my interest is more about not needing higher kinded types to
05:51:01 <xsperry>  I thought we needed higher kinded types for that) haskell code: https://bpaste.net/show/dc2d1c645198  C# code: https://ideone.com/Yq8Ioc 
05:52:27 * hackage derive 2.6.5 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.6.5 (VladimirShabanov)
05:52:48 <merijn> xsperry: Your Unit example had a higher kinded typeclass, the Unit type itself is not higher kinded
05:54:49 <dminuoso> aplainzetakind: The solution might not cover all edge cases, would produce fairly impossible to understand diagnostics if something doesn't fit..
05:55:18 <dminuoso> It would drag pointless constraints through your program if you are missing some type signatures, adding more noise when debugging..
05:55:19 <xsperry> merijn. how would we express it in haskell without higher kinded types? I have a hard time following that C# code
05:55:21 <merijn> xsperry: Any language with generics can implement the Weight/Length types you had. A better example would be like "data WebForm f = Form { date :: f Date, name :: f String, email :: f String }" and then "validateForm :: WebForm Widget -> WebForm (Either ValidationError)" and then "WebForm (Either ValidationError) -> Either [ValidationError] (WebForm Identity)"
05:55:50 <merijn> xsperry: WebForm is higher-kinded (since 'f' has kind '* -> *')
05:55:57 <dminuoso> aplainzetakind: Also it would be needlessly hard to understand, so a beginner couldn't just look at it an gain insights from reading the source code.
05:56:28 <dminuoso> aplainzetakind: https://gist.github.com/dminuoso/f55bcd0516849397df536657be529e1c this is an example on a generic `lift`, it's not pretty at all.
05:57:26 <mpcsh> hey haskellers, so the code I'm writing right now is actually in SML, but I think this is the best place to ask as it's purely a theoretical question. I'm implementing a monadic parser for a language that allows for curried function applications like so: `times(n)(n - 1)`. So my question is, what's the "monadic" way to say: "parse as many of this thing as possible"?
05:57:45 <dminuoso> :t many
05:57:46 <lambdabot> Alternative f => f a -> f [a]
05:57:56 <xsperry> merijn, I see. as far as my example goes, what would the type of convert and Unit be if we didn't use higher kinded types?
05:58:03 <dminuoso> mpcsh: ^- This is the style we do in Haskell, so we focus on not just having monadic parsers, but having monadic parser combinators.
05:58:26 <merijn> xsperry: I don't really have an answer to that, because I don't really know what that'd look like
05:58:55 <xsperry> merijn, hmm, ok, I thought you did, as you said Unit is not a higher kinded type
05:59:14 <aplainzetakind> dminuoso: Thanks. I really can't follow that, but someday perhaps.
05:59:54 <dminuoso> aplainzetakind: Besides, (.) . (.) and its variants are not very common anyway. Chances are you are better off using a lambda or an extra function binding.
05:59:55 <merijn> xsperry: Your example had a typeclass Unit (which is higher-kinded), but the arguments to convert aren't higher kinded
06:00:04 <xsperry> merijn, oh
06:01:20 <xsperry> merijn, I'm failing to see how it is not higher kinded type? convert :: (Unit u, Fractional a) => u a -> u a -> a -> a
06:01:51 <xsperry> or rather, higher kinded
06:02:02 <mpcsh> dminuoso: nice, thank you. I'm reading through the source to get a better handle on how `many` is implemented, but it looks like that's exactly what I want to do
06:02:26 <merijn> xsperry: 'u' isn't higher kinded
06:02:39 <merijn> xsperry: Unit is (because it takes 'u' as argument)
06:03:21 <aplainzetakind> dminuoso: I had started from the observation that lift(N+1) f = [(.) composed with itself N times] (<*>) (liftN f)
06:07:25 <xsperry> :t sequence
06:07:27 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
06:08:10 <xsperry> merijn, I am super confused now. how is it any less higher kinded than above? Monad m => [m a] -> m [a].  isn't u = m?
06:08:21 <xsperry> HKT wise
06:08:41 <merijn> xsperry: 'm' isn't higher kinded there, either
06:08:56 <merijn> xsperry: higher-kinded types are types whose arguments have a kind other than *
06:08:58 <xsperry> I thought we needed HKT to write generic sequence function
06:09:21 <merijn> xsperry: Monad is higher kinded (it's argument is m, which has kind '* -> *')
06:09:33 <merijn> 'm' is not higher kinded, as it has one argument, which has kind *
06:09:54 <xsperry> m is concrete unit type behind the Monad instance. just like u is concrete type behind Unit instance
06:10:44 <merijn> I don't know what a "concrete type" is and neither does anyone else: https://gist.github.com/merijn/796b8e041885df870fbb53b7191644b6
06:10:45 <xsperry> is sequence higher kinded? is it writeable without HTK? and if it isn't, I'm not getting how it is different than my convert function
06:12:28 <xsperry> if we are in a list Monad, m's "concrete type" would []. I'll accept that it may be bad terminology, just clarifying what I meant
06:15:22 <merijn> Unrelatedly: Is there an efficient way for turning Text digits into a number?
06:15:27 <dminuoso> aplainzetakind: The real repeating theme is: pure f <*> x_1 <*> x_2 <*> ... <*> x_n
06:15:32 <dminuoso> aplainzetakind: and thats precisely what my gist captures.
06:15:39 <merijn> i.e. without going through unpack and read
06:17:29 <kritzefitz> :t decimal
06:17:30 <lambdabot> (Applicative f, Choice p, Integral a) => p a (f a) -> p String (f String)
06:17:41 <kritzefitz> Ah, that's the wrong decimal.
06:17:58 <kritzefitz> merijn: Apparently Data.Text.Read does such things.
06:18:30 <merijn> kritzefitz: Ah, yes
06:18:40 <dminuoso> merijn: I find myself wanting a `bytestring-read` or `text-read` package far too often.
06:19:41 <merijn> dminuoso: Data.Text.Read, apparently ;)
06:20:41 <dminuoso> merijn: Well, I want something that is deriving'able. :(
06:35:22 <adius> Hi, this is probably the wrong place for this question, but I remember there was a company with primarily Haskell developers, which had a kind of "personal project manager" offering. This included regular calls and help to get things done and move your projects forward. Can anyone direct me to their website?
06:36:12 <dmwit> Possibly https://monadfix.io/ ?
06:38:33 <adius> No that's not it. It was pretty similar, but more focused on general project management and not with focus on Haskell
06:39:43 <sm> aw
06:41:04 <adius> I think this wasn't their core business, it was just an additional "fun" offering, but I thought it was really cool
06:41:26 <sm> I think I signed up for monadfix once.. must investigate
06:42:34 <dmwit> In the other direction, I think beeminder offers a "life coach" setup. But they're not Haskell-specific folks.
06:50:26 <pgiarrusso> adius: boss as a service? (Not a joke)
06:50:37 <hc> lol
06:50:46 <hc> that does make sense, in a certain way
06:51:08 <pgiarrusso> https://bossasaservice.life/
06:51:57 <pgiarrusso> It’s very funny, but we humans are funny enough ourselves, so it sounds like it could be very sensible
06:52:29 <hyperisco> the #1 IDE feature I want is import management… what Haskell tooling can give me that?
06:53:07 <dminuoso> hyperisco: ghc-mod can do it afaik
06:54:39 <hyperisco> okay well ghc-mod is in limbo last I knew of
06:55:02 <hyperisco> and haskell-ide-engine is the new hotness, but it is broken in at least two ways on Windows
06:59:11 <hyperisco> whoa actually maybe it built today
07:03:33 <adius> pgiarrusso: I guess that's not the one I meant, but it's really close 😁
07:03:38 <adius> But I'd rather get help from Haskell folks. They normally know what they are talking about 😁
07:07:07 <xsperry> interesting comments on the difference between haskell and C# code in #programming
07:07:11 <xsperry> <beaky> xsperry: yes the c# example does not constrain the convert function the way the haskell example does: it does not encode the same type constraints of the unit parameter (in the polymorphic manner enabled by higher-kinded types). The C# convert defines conversion between IUnit instances that can be different types (since they're subclasses of IUnit), wheras in the haskell example they can only be the
07:07:32 <xsperry>  <beaky> same type u
07:08:06 <xsperry> because of this, converting from meters to grams compiles with C# code, but not with haskell code. https://ideone.com/i4uUY8 https://ideone.com/su6Xae
07:08:44 <hyperisco> I am trying to update my stack resolver
07:08:53 <hyperisco> I changed the resolver in stack.yaml and I ran stack build again
07:08:59 <hyperisco> Unable to parse cabal file for bhoogle-0.1.3.5@sha256:a3393794b22faabeb564c57f4a9506390b6b97b9792c6b4e130f15bf116099fd,1806: NoParse "license" 7
07:09:17 <hyperisco> I don't know where this package has been cached or how to clear the cache
07:09:56 <sm> stack upgrade is probably the easiest fix
07:10:25 <hyperisco> 1.6.1 to 1.9.3
07:10:32 <hyperisco> well I get a different error now at least
07:30:33 <inkbottle> data A = A {a :: Int}; x = A 1; x' = x {a = 2}; I'm looking for the description of that syntax in "haskell [98, 2010, ?] report" (mostly to put a name on the syntax, but also just to know where it is)
07:32:37 <inkbottle> seems I found it after all: https://www.haskell.org/onlinereport/exps.html
07:37:48 <hyperisco> what happened to MonadBaseControl in Conduit
07:38:26 <hyperisco> used to be in conduit-combinators and now is history
07:39:06 <hyperisco> oh the message was inaccurate… is in mono-traversable actually
07:39:32 <hyperisco> yet… not
07:40:30 <merijn> MonadBaseControl is a very brittle and super confusing/complicated abstraction that's overkill for most uses
07:40:51 <merijn> hyperisco: Snoyberg has been transitioning to MonadUnliftIO for a lot of his libs
07:41:34 * hyperisco sighs
07:41:52 <hyperisco> all I wanted was a simple way to download a file over HTTP and save it to disk
07:42:06 <merijn> http-conduit?
07:42:12 <hyperisco> and as I recall this was almost unhaveable until I found a package called simple-download
07:42:29 <hyperisco> which didn't build with stack but I copied the source code and made it work that way
07:43:01 <merijn> hyperisco: Like, http-conduit just has "simpleHttp :: MonadIO m => String -> m ByteString" to fetch a file from a URL...
07:43:08 <merijn> Not sure how much simpler you want/need?
07:43:55 <hyperisco> what I have here I think streams it into the file
07:44:52 <merijn> hyperisco: http-conduit has some other function for that too
07:45:07 <hyperisco> what is this https://hayoo.fh-wedel.de/?query=MonadUnliftIO
07:45:31 <merijn> @hackage unliftio-core
07:45:32 <lambdabot> http://hackage.haskell.org/package/unliftio-core
07:48:39 * hyperisco cries
07:48:43 <hyperisco> everything keeps breaking
07:49:09 <hyperisco> has backwards compatibility gone to the wind?
07:49:37 <merijn> If you want the old version, use the old version?
07:50:41 <hyperisco> I finally got hie built and it is a new version
07:53:43 <slack1256> Today I published a paper where its stated that the experiments where done on Haskell + hmatrix.
07:54:01 <slack1256> It is not the "use haskell on work" setup I had in mind, but it is something.
07:59:41 * noxecane hi everyone
08:00:32 <hyperisco> merijn, this is what I was basing my code on http://hackage.haskell.org/package/simple-download-0.0.2/docs/src/Network-HTTP-Client-Conduit-Download.html#download
08:00:40 <hyperisco> now I can't figure out what takes a Manager anymore
08:00:54 <hyperisco> withManager gives a Manager to something, but nothing seems to take a Manager
08:01:50 <hyperisco> this doesn't give something that takes a Manager http://hackage.haskell.org/package/conduit-1.3.1/docs/Conduit.html#v:runResourceT
08:02:07 <merijn> No clue, that code looks rather outdated, considering it hasn't been updated to a recent GHC or conduit release
08:02:14 * noxecane so I am wondering if there's a way to use for functions to indicate the exceptions they throw
08:02:28 <merijn> noxecane: Sadly, no, it's super annoying
08:02:50 <merijn> noxecane: Sadly, not annoying enough that anyone is willing to pay for me to work on a prototype to fix it :p
08:02:52 <hyperisco> yes it is old, that is why I had to copy the code, it didn't build anymore
08:03:06 <hyperisco> it doesn't seem to work with this unlift IO thing now
08:03:19 <merijn> hyperisco: It also seems rather...useless? Like, it's trivial to implement from scratch using http-conduit
08:03:27 <hyperisco> it uses http-conduit
08:03:36 <hyperisco> I also have zero ideas how to use conduit
08:04:08 <merijn> You don't have to for http-conduit, like I said it literally has "simpleHttp :: MonadIO m => String -> m ByteString"
08:04:30 * noxecane I have been taking a look at control-monad-exceptions
08:04:35 <merijn> So all you need to do is "take that ByteString and write it to a file"
08:04:44 <hyperisco> I'd like not to have to change what I have here
08:05:09 <Male50Single> how do i add server info and stuff to goto dalnet
08:05:11 <hyperisco> Manager is still part of http-conduit I just don't know where it goes
08:05:27 <hyperisco> or maybe it is not used anymore… I don't know
08:05:31 * noxecane sadly it's based on IO exceptions..I would have loved to use it for pure exceptions(either/except style)
08:06:07 <Male50Single> can anyone help me add dalnet data
08:06:29 <nshepperd> httpLbs :: MonadIO m => Request -> Manager -> m (Response ByteString)
08:06:34 <nshepperd> hyperisco: ^^?
08:06:50 <merijn> Yeah, but with simpleHttp you don't even need a Manager
08:07:02 <hyperisco> might need a runReaderT there
08:07:13 <hyperisco> you guys want to change the code
08:07:17 <hyperisco> I just want to port it to the new version
08:07:18 <nshepperd> ??
08:07:37 <Male50Single> can anyone please assist me with getting onto dalnet serve
08:07:41 <Male50Single> server..
08:07:54 <nshepperd> there's also 'http :: MonadResource m => Request -> Manager -> m (Response (ConduitM i ByteString m ()))' if you desperately want to use conduit
08:09:24 <hyperisco> yeah that was the problem
08:09:36 <hyperisco> I bet the old runResourceT baked Reader into it, or something
08:09:52 <hyperisco> adding runReaderT seems to be the only needed change
08:10:59 <hyperisco> looks like a couple deprecations too… $$ and withManager
08:11:00 * noxecane turns out I am absolutely wrong. there's a pure module. Plus it's actually a transformer.
08:11:28 <nshepperd> oh i see, you want to use this downloadWithManager thing but it uses 'MonadReader env m, HasHttpManager env' constraint instead of just taking a Manager argument
08:11:58 <nshepperd> that seems kinda silly
08:14:28 <hyperisco> nshepperd, that's conduitism
08:14:49 <hyperisco> all this package does is write the conduit program that streams a file over HTTP to a file
08:14:58 <hyperisco> anyways, I fixed it
08:17:37 <nshepperd> i see
08:18:04 <nshepperd> i think i really prefer lazy bytestrings. i haven't had much use for conduit stuff
08:18:27 * hackage prometheus 2.1.1 - Prometheus Haskell Client  http://hackage.haskell.org/package/prometheus-2.1.1 (wraithm)
08:22:27 <hyperisco> doesn't seem like HIE manages imports
08:30:28 * hackage git-annex 7.20190122 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-7.20190122 (JoeyHess)
08:32:39 <parkeraa> Howdy #haskell, I have a question about a single line of code, may I paste it in or should I use the gist?
08:33:13 <geekosaur> single line is okay, provided it's not too long at least
08:33:54 <parkeraa> Sure. I'm unclear about what the "<-" does in the following:
08:33:55 <parkeraa> smaller = [a | a <- xs, a <= x]
08:34:58 <parkeraa> Is it correct to say that the right hand side could be read as "a such that a is in xs, and a is less than or equal to x"?
08:37:02 <nbloomf> yes
08:38:56 <nbloomf> that is called list comprehension syntax, and it desugars to do-notation
08:39:45 <hc> xs >>= \a -> ( do { guard (a <= x) ; return a } )
08:39:53 <hc> That's what it looks like without the list comprehension syntax
08:40:06 <parkeraa> Jesus
08:40:38 <hc> xs >>= \a -> guard (a <= x) >> return a
08:40:40 <hc> without do notation
08:41:00 <p0lyph3m>  <- == ∈
08:41:14 <tdammers> sort of
08:41:14 <parkeraa> p0lyph3m: that's what I was beginning to thingk
08:41:24 <tdammers> like, informally
08:41:28 <parkeraa> Doesn't the arrow operator have other purposes
08:41:36 <tdammers> it's not an operator
08:41:39 <tdammers> it's syntax
08:41:50 <tdammers> and yes, it means different things in different contexts
08:41:58 <p0lyph3m> parkeraa: list comprehentions are closly modeleled after mathematical set comprehentions
08:42:13 <parkeraa> tdammers: that's a more accurate term, thank you
08:42:18 <tdammers> in do notation: do { x <- a; f x } -- desugars into: a >>= \x -> f x
08:43:11 <tdammers> you can also use <- in a guard context, where it works similarly to do notation: foo mx | Just x <- mx = print x
08:43:39 <hc> tdammers: that would require a case statement without sugar, right?
08:43:39 <parkeraa> My other question pertains to the following line:
08:43:46 <parkeraa> qsort :: Ord a => [a] -> [a]
08:44:28 <parkeraa> qsort is an implimentation of quicksort of course, but I'm not sure what I'm looking at
08:44:51 <nbloomf> that is a type signature
08:44:52 <Taneb> parkeraa: that says "qsort has the type [a] -> [a], as long as a is an instance of Ord"
08:44:55 <tdammers> hc: no?
08:45:14 <parkeraa> What is 0rd?
08:45:23 <tdammers> hc: or do you mean the guard sugar?
08:45:25 <nbloomf> Ord is a type class constraint
08:45:36 <nisstyre> parkeraa: Ord a => [a] -> [a] says that it's a function that takes a permutation of things that can be ordered and returns another (presumably sorted) permutation of those items
08:46:28 <nbloomf> If the constraint Ord a holds, it means the type a has some particular functions implemented, as specified by the Ord class
08:46:33 <Taneb> parkeraa: Ord is a typeclass representing things that can be compared, for instance with < and >=
08:46:40 <nbloomf> it is sort of like an interface in other languages
08:46:43 <nisstyre> although there is nothing in the type signature itself that says they will be sorted according to whatever order you have
08:47:53 <parkeraa> Oh I was reading it incorrectly, as 0rd (Zero rd)
08:48:03 <parkeraa> I was having difficulty finding information on it
08:48:53 <nbloomf> :) Here's the docs for Ord: http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ord
08:49:01 <parkeraa> Thanks very much
08:50:42 <parkeraa> I think based on what y'all have given me I can piece the rest together, thank you all very much
08:51:04 <Taneb> parkeraa: happy haskelling!
08:53:02 <nbloomf> high five!
08:55:57 * hackage yesod-core 1.6.10.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.6.10.1 (MichaelSnoyman)
09:04:38 <estrom> Is it possible to set the environment variable PS1 using System.Posix.Env.setEnv? It doesn't have any effect, seemingly.
09:05:18 <glguy> How are you checking if it had an effect?
09:06:23 <estrom> glguy: echo $PS1, after running my program
09:06:35 <estrom> `main = setEnv "PS1" ">" True`
09:06:41 <glguy> setEnv sets it in the current program, not the separate process that started the current program
09:07:28 <estrom> I see
09:07:34 <glguy> If you want to set environment variables in your shell you can have the program you write print out the commands that would cause that to happen
09:09:36 <amalloy> that's rather less portable though, since you don't know what shell is in use
09:09:48 <glguy> Well, it's more portable than not working at all
09:10:04 <amalloy> a philosophical question
09:11:38 <glguy> And if estrom's trying to set a particular PS1 line, then the shell is likely known
09:20:04 <wroathe> This might be a dumb question, but is there a good way to alias a typeclass? As part of something I'm working on I'd like to expose FromJSON-like functionality, and to begin with the implementation IS going to be FromJSON, but that could change
09:20:51 <wroathe> Such that the user of my library will think they're creating instances of MyCustomTypeClass(TM), when in reality they're creating an instance of FromJSON to begin with
09:22:35 <merijn> wroathe: Not really, tbh
09:22:58 <merijn> wroathe: Are we talking about a small set of custom types here, or?
09:23:09 <wroathe> Yeah
09:23:29 <wroathe> I'm working on something simplify reading configuration from a program's environment
09:23:38 <wroathe> And that could come from Xml, Ini, Yaml, JSON
09:23:41 <wroathe> Args, env vars
09:23:42 <wroathe> You name it
09:23:55 <wroathe> But right now the best intermediate representation seems to be Aeson's Value type
09:24:01 <merijn> wroathe: That doesn't sound like you need a typeclass, tbh
09:24:14 <wroathe> And I want the user to be able to call the function like so: config <- getConfig
09:24:20 <wroathe> and have config be a hashmap by default
09:24:20 <gentauro> Aeson, the father of Jason, I mean JSON (love the name :D)
09:24:37 <wroathe> or config <- getConfig :: MyCustomConfigType
09:24:48 <wroathe> And have it bind to the user's specified ADT
09:24:55 <merijn> wroathe: That sounds like you need to define a "MyConfig" record type and then just expose "configFromJson :: WhateverAesonHas -> MyConfig" "configFromXMLFile :: FilePath -> MyConfig", etc.
09:25:48 <wroathe> on something TO simplify* (I accidentally a word earlier)
09:25:48 <merijn> wroathe: Typeclasses are for when you want to write code that's polymorphic across instance. This just sounds like you want parse different things into MyConfig and then use that
09:26:14 <wroathe> merijn: Well, a key part of that is defining a new "merge" function for each type
09:26:33 <merijn> wroathe: You mean you wanna merge multiple configs?
09:26:48 <wroathe> Yeah, the user can specify a precedence order
09:27:01 <merijn> wroathe: Define a Monoid instance for MyConfig and then you can mappend multiple configs, regardless of where they came from
09:27:25 <wroathe> So that cli args have a higher precedence than environment variables, and environment variables have a higher precedence than configuration files
09:28:20 <merijn> wroathe: That seems easy enough without needing typeclasses and complications. Just write parsers/generators for each config format, define a Monoid instance, then "mconcat" the final list of configs into the actual one
09:28:35 <wroathe> Hah, why didn't I think of Monoid
09:28:36 <wroathe> That's perfect
09:29:01 <merijn> wroathe: You even have First and friends to make things left-biased, etc. for prioritising
09:29:57 <wroathe> merijn: That said, there's still some utility for Aeson in this
09:30:12 <wroathe> For one thing, I'm not going to write my own parser for each format if there's a decent option on the market already
09:30:25 * [exa] wonders about argmax monoid
09:30:30 <merijn> wroathe: I don't mean you have to write a parser from scratch :)
09:30:31 <wroathe> and for two, both the Yaml and Aeson libraries use that Aeson Value type
09:30:51 <wroathe> So it seems like an easy and quick win to parse XML and Ini into that type as well
09:31:05 <wroathe> and then just have the user define a FromJSON instance for their ADT
09:31:22 <wroathe> Monoid is perfect for the precedence semantics though
09:32:26 <merijn> Not sure how going through Value is going to help things, tbh
09:32:53 <wroathe> He's done a lot of the heavy lifting for mapping Value -> instances of Generic
09:33:47 <wroathe> Including helpful error messages if the conversion can't be performed
09:37:00 <wroathe> I was in here yesterday mentioning that it would almost make sense to split that work out into a separate JSON-independent library
09:37:14 <wroathe> There's plenty of utility in that on it's own
09:53:01 <wroathe> merijn: So Monoid sounds correct in theory, and the definition he uses for <> is almost correct for my needs, but I need some further specialization
09:53:27 <fragamus> hey is anyone around to explain a little bit about ((->)e) being a functor
09:53:38 <fragamus> like using lambdabot
09:53:43 <Wilhelm> Hello everyone :) I heard many good things about this channel
09:54:02 <fragamus> hello Wilhelm
09:54:32 <wroathe> merijn: Actually, nvm me, just rubber ducking. I think I've got my answer.
09:54:37 <glguy> % :t fmap
09:54:37 <yahb> glguy: Functor f => (a -> b) -> f a -> f b
09:54:42 <glguy> % :t fmap @((->) Int)
09:54:42 <yahb> glguy: (a -> b) -> (Int -> a) -> Int -> b
09:55:29 <glguy> ?djinn  (a -> b) -> (int -> a) -> int -> b
09:55:29 <lambdabot> f a b c = a (b c)
09:55:35 <fragamus> was that directed at me
09:56:24 <[exa]> fragamus: probably
09:56:31 <wroathe> merijn: Basically I need to do what Sum and Product do for Monoid :D
09:57:00 <glguy> fragamus: Kind of, what's up :)
10:00:22 <fragamus> is yahb a bot or a person
10:00:45 <glguy> yahb is a bot
10:00:54 <fragamus> oooh kewl
10:01:20 <nshepperd> instance (Ord b, Reifies s (a -> b)) => Monoid (Argmax s a)
10:02:23 <wroathe> nshepperd: Was that directed at me?
10:02:47 <nshepperd> no, [exa] 
10:03:31 <c_wraith> fragamus, "yet another Haskell bot". things that start with "ya" are always "yet another"
10:03:56 <fragamus> nice I'm on the inside now
10:04:42 <c_wraith> like a yak is just yet another cow.
10:04:57 <glguy> checks out
10:08:37 <delYsid> I didn't know @djinn, how cool is that.
10:18:27 <dmwit> % :t fmap @((->) _) -- in case you didn't want to specialize to Int
10:18:27 <yahb> dmwit: (a -> b) -> (w -> a) -> w -> b
10:19:18 <dmwit> Hah!
10:19:26 <dmwit> :exf (a -> b) -> (w -> a) -> w -> b
10:19:28 <exferenceBot> \ f1 f2 -> f1 . f2
10:21:09 <amalloy> is there a difference between exferenceBot and lambdabot's djinn feature?
10:21:53 <dmwit> Yes. Djinn only does first-order logic, but is sound and complete for that. Exference can handle higher-order logic (e.g. typeclasses I think are the main motivating use) but isn't complete.
10:22:16 <dmwit> ?djinn Monad m => a -> m a
10:22:16 <lambdabot> f = return
10:22:20 <dmwit> ?djinn Monad m => b -> m b
10:22:21 <lambdabot> -- f cannot be realized.
10:22:48 <dmwit> :exf Monad m => a -> m a
10:22:49 <exferenceBot> pure
10:22:52 <dmwit> :exf Monad m => b -> m b
10:22:53 <exferenceBot> pure
10:24:39 <Lycurgus> :exf what thing are you?
10:24:39 <exferenceBot> parse error: more than one input
10:46:42 <geekosaur> https://github.com/lspitzner/exference
10:48:11 <monochrom> Haha "Memory consumption is large (even more so when profiling)"
10:50:21 <monochrom> <A> I turned on profiling to find out why my program was using so much space, but this led to using even more space.  <B> Yo dawg we heard your program loves using space so we added using more space in profiling so you can use more space when you measure how you use space.
10:51:48 <wroathe> That's a lotta space
10:52:09 <monochrom> Yeah! I love using "space" too!
10:52:45 <Lycurgus> it has been said to be the place
11:00:16 <nshepperd1> Gotta use space to go to space
11:00:41 <glguy> youtube portal 2 space core quotes :)
11:00:47 <wroathe> So HashMap already has an instance of Monoid defined, where mappend is defined as being the union of two maps. I need a specialized version of this that uses unionWith, so that implies multiple Monoid instances. To accomplish that, I've seen that people typically wrap their types in a newtype (e.g. Sum and Product). Unfortunately that means that the user of the thing I'm building would have to call a 
11:00:53 <wroathe> function to unwrap my specialized hashmap before using it
11:00:59 <wroathe> I'm seeing that another approach is to use overlapping instances, but that they're also the devil...
11:01:19 <glguy> The choices are newtype or don't rely on Monoid and just using unionWith directly
11:01:42 <wroathe> Is there an elegant way of saying "My function returns either your monoidal ADT, or a HashMap with my monoidal semantics"
11:02:28 <wroathe> glguy: That's what I feared
11:03:01 <glguy> relying on arbitrary behavior choices of monoid instances is generally a bad idea anyway
11:04:45 <wroathe> Right, so that puts me back to where I started this morning, which was a new typeclass with a merge operator
11:08:29 <wroathe> Now that I think about how open-ended the semantics of monoid are, I'm wondering if it's a concept that should be used sparingly
11:08:31 <nshepperd1> You want to wrap HashMap to make a hashmap type with a different monoid instance?
11:08:53 <wroathe> nshepperd1: Yeah, the idea is that I've got special merging behavior for two hashmaps
11:09:10 <wroathe> And I want the return value to the end user to just be a hashmap, not a wrapped hashmap
11:09:41 <glguy> wroathe: So remove the newtype before you return it to the user?
11:09:51 <wroathe> sorry, that's not all
11:10:11 <wroathe> I meant to say "a hashmap or a user specified ADT with similar merging semantics"
11:10:24 <wroathe> So that tells me I have a class of types
11:10:25 * nshepperd1 takes a guess. The instance you want is (Hashable, Monoid v) => Monoid (HashMap k v)?
11:10:48 <wroathe> nshepperd1: No, that one just uses straight union for mappend
11:10:53 <wroathe> nshepperd1: And I need unionWith
11:11:12 <nshepperd1> That one uses unionWith mappend
11:11:50 <cocreature> to be clear, nshepperd1 is talking about a hypothetical instance that would have those constraints. not the actual instacne
11:12:24 <wroathe> https://github.com/tibbe/unordered-containers/blob/master/Data/HashMap/Base.hs#L202
11:13:28 <nshepperd1> Yeah, the real instance is sad and unfortunate
11:14:06 <wroathe> I'm not necessarily looking for a solution from you guys. Just to get a list of options to explore here
11:14:25 <wroathe> Overlapping instances seems to be a highly debated thing
11:14:36 <nshepperd1> Well, if the user chooses the output type, then i guess they do need to unwrap it theirself
11:14:40 <wroathe> and newtype clutters the API to the end user
11:14:55 <nshepperd1> Yeah i definitely wouldn't use overlapping instances
11:16:58 <nshepperd1> You *could* go whole hog and wrap the whole HashMap api to work with your newtype
11:17:24 <nshepperd1> So that the user could use it directly without unwrapping
11:17:40 <wroathe> Hah, I too like to live on the edge :P
11:17:43 <nshepperd1> Not sure if good idea
11:18:14 <wroathe> https://i.imgur.com/NlGYcKP.gif
11:19:08 <wroathe> Honestly I will probably end up needing to define some new functions for the newtype'd hashmap anyway
11:19:13 <wroathe> So that might just be the way to go
11:20:15 <nshepperd1> Would ordinary HashMap with the regular instance every
11:20:33 <nshepperd1> ...ever be a valid choice for the user?
11:23:10 <wroathe> It would, but rather than requiring the user to define their own newtype wrapper for HashMap to decide on the specific union behavior of the maps, I'm planning on just having that be configurable
11:24:27 <wroathe> As in, "the default implementation is my unionWith behavior, documented here: x, but if you want something else you can override the default options
11:24:30 <wroathe> "
11:25:13 <wroathe> If they want just regular union they can live with their choices :P
12:01:28 * hackage monad-dijkstra 0.1.1.2 - A monad transformer for weighted graph searches  http://hackage.haskell.org/package/monad-dijkstra-0.1.1.2 (ecramer)
12:02:20 <fen> reading simple essence of automatic differentiation, apparently d id = id. this seems more like an exponential...
12:03:29 <fen> https://arxiv.org/pdf/1804.00746.pdf
12:03:42 <amalloy> well, there are |a|^|a| possible implementations of a function (a -> a)
12:04:57 <fen> but then it says that (to avoid recomputation) it stores the differential alongside the original function. so its; 
12:05:09 <fen> d id = \a -> (id a,id)
12:05:43 <fen> and then as the `a' isnt applied to the rhs of the pair, it actually does not look like its the same 
12:06:36 <fen> and then its possible to understand id as more like 1, where id is like y = x and dy/dx = 1
12:07:04 <fen> but then, how to see something like d 1 / dx = 0 ?
12:07:32 <wrengr> WilliamHamilton[: there are twoish classes of things I did. First are representational optimizations; second are algorithmic optimizations. For the former, this includes both generic things like node fusion, and Haskell-specific things like strictness/unboxing and some ADT golfing. For the latter, the two key things are path compression (only for the "ranked" implementation) and balanced unions
12:08:12 <wrengr> WilliamHamilton[: The latter two should be described on https://en.wikipedia.org/wiki/Disjoint-set_data_structure along with references
12:08:49 <dmwit> fen: Where do you see d id = id?
12:08:52 <dmwit> That doesn't look right to me.
12:09:04 <fen> page 7
12:10:09 <hyperisco> amalloy, for |a| > 0?
12:11:08 <dmwit> In fact, it doesn't even look like it type checks.
12:11:15 <dmwit> I don't see that equation anywhere on page 7.
12:11:33 <hyperisco> amalloy, seems to follow through nicely for void now that I think about it
12:11:40 <amalloy> yeah, i was about to say it's fine for void
12:11:44 <dmwit> I *do* see a theorem that would imply d id x = id. Which is a very different equation.
12:11:46 <amalloy> f = absurd
12:11:50 <fen> this quote gives the type of d; "D+ :: (a → b) → (a → b × (a ( b)) -- better"
12:12:07 <fen> oh it didnt include a symbol...
12:12:10 <hyperisco> amalloy, we have to define 0^0 = 1 though
12:12:44 <fen> d :: (a -> b) -> (a -> (b,(a->b)))
12:13:19 <hyperisco> which apparently Windows calculator agrees with :P
12:13:22 <fen> so d id :: a -> (a,a -> a), d id a = (a,id)
12:14:29 <fen> dmwit: its there but with D+ instead of d
12:14:44 <fen> Now recall the following results from Corollaries 3.1 and 1.1: D+ id = λa → (id a, id)
12:15:37 <dmwit> I think your confusion arises from thinking of the derivative being computed here as being a traditional function from inputs to slopes.
12:15:46 <fen> still not sure how to differentiate this again though to give the second differential of id as 0
12:16:04 <dmwit> Instead the function is from inputs to functions with the derived slope.
12:16:13 <dmwit> Which, in a sense, is the *integral* of the derivative.
12:16:24 <dmwit> Which explains why id and id are so closely related.
12:16:33 <amalloy> hyperisco: i think it's pretty normal, isn't it? you could leave it undefined, but making it 1 is done for many domains
12:16:47 <fen> hmm, that almost makes sense
12:17:07 <hyperisco> > 0 ^ 0
12:17:09 <lambdabot>  1
12:17:18 <hyperisco> why not then
12:17:30 <dmwit> This quote after Theorem 3 is pretty much on the point about this: "D f a is a local linear
12:17:33 <dmwit> approximation of f at a, so we’re simply saying that linear functions are their own perfect linear approximations"
12:17:47 <dmwit> This is definitely not the usual definition of a derivative operator.
12:18:45 <fen> but what differentiates to give 0?
12:19:03 <fen> where is the notion of a constant? 
12:19:27 * hackage terminal 0.1.0.0 - Portable terminal interaction library  http://hackage.haskell.org/package/terminal-0.1.0.0 (LarsPetersen)
12:20:59 <fen> (normally we would want the slope of this linear approximation)
12:21:13 <dmwit> Correct. But this is not the normal setting. =)
12:21:43 <dmwit> In this setting, "What differentiates to give 0?" is an ill-typed question.
12:21:56 <dmwit> Things can only differentiate to maps, not numbers.
12:22:34 <fen> is there an exponential? both that and constant functions (with 0 slope) seem mixed up by this thing with d id = id, normally =0 and normall d e^x / dx = e^x
12:23:27 <dmwit> First of all, d id = id is not a correct equation, and it is not claimed to be a correct equation in this paper.
12:23:40 <fen> hmm, maybe its because its not dividing by dx
12:23:42 <dmwit> Second of all, in this setting, the derivative of the exponential is not itself.
12:23:54 <fen> oh yeah, its the one hole context
12:23:58 <dmwit> (Nothing can be its own derivative. The types don't match.)
12:24:01 <fen> like a list zipper
12:24:06 <dmwit> ...what
12:24:07 <dmwit> no
12:24:20 <fen> isnt list of x e^x here?
12:24:44 <dmwit> I don't think so. I doubt lists will be mentioned at all, except perhaps as a funny data model for R^n.
12:25:28 * hackage registry 0.1.2.3 - data structure for assembling components  http://hackage.haskell.org/package/registry-0.1.2.3 (etorreborre)
12:26:11 <dmwit> (Even in the *completely separate* formalism you're thinking of, list of x is 1/(1-x), not e^x.)
12:26:27 <fen> the types match on the first version of D which does not store the original function for computation savings; 
12:26:38 <fen> on page 3 D :: (a → b) → (a → (a -> b))
12:27:04 <dmwit> No, the types do *not* match in that version.
12:27:11 <fen> oh yeah
12:27:52 <fen> but all the good things are from differentiating exponentials to get at the variables stored within
12:28:29 <fen> or, differentiating some sum of things which their partial derivative in one variable vanishes because they are not functions of that variable
12:28:51 <fen> which would require vanishing partial derivatives...
12:28:58 <NoidedSuper> Do both sides of an Isomorphism have to be one-to-one?
12:29:04 <dmwit> NoidedSuper: yep
12:29:15 <NoidedSuper> Er, in the lens sense, not the mathematical one
12:29:23 <NoidedSuper> Should've specified
12:29:26 <NoidedSuper> Still yes?
12:29:29 <dmwit> The lens sense is modeled after the mathematical one.
12:30:44 <fen> eg in quantum mechanics where the wavefunction is expanded in complex exponential so the derivative gives the observable (momentum) or in thermodynamics where the free energy can be differentiated to give the observable thermodynamic variables
12:32:19 <fen> so we could have a program which when differentiated to give another program could have a partial derivative, requiring several variables, so differentiation wrt different variables would give different programs 
12:32:53 <fen> again, requiring vanishing partial derivatives
12:33:09 <fen> cant see why its ill posed to ask for a vanishing derivative 
12:34:22 <fen> (functions on a legendre manifold...)
12:34:59 <hc> tdammers: I meant the guard sugar with Just x
12:36:34 <tdammers> hc: right, yes. like most things, it'll desugar into a case {}
12:37:01 <hc> good :)
12:37:09 <hc> I was just wondering how else one would do it
12:37:22 <hc> (at first though, this one can't be done without the do syntax at all, until I thought of case)
12:37:31 <hc> s/though/thought/
12:38:39 <tdammers> do syntax is also just sugar
12:39:07 <hc> I know
12:39:19 <tdammers> and also desugars into case expressions as needed
12:39:20 <tdammers> so yeah
12:39:29 <hc> But if the case I was referring to couldn't be done otherwise, do wouldn't be entirely sugar, hence my wondering
12:39:43 <hc> So yeah. case is how it's desugared. :)
12:40:43 <fen> it says that D2 = D ◦ D :: (a → b) → (a → (a → a → b)), maybe differentiating id twice would be informative
12:41:47 <fen> if D+ id = λa → (id a, id) then whats D+ (λa → (id a, id)) ?
12:43:12 <xsperry> did some further modifications to my units module. now cm, inch, etc, are functions, so they can be used to input Unit values, as well as conversions. what do you think? too cute for its own good? :). https://bpaste.net/show/90b201ba8531
12:44:11 <fen> recalling that D :: (a → b) → (a → (a → b)) ...
12:47:05 <dmwit> xsperry: Not cute enough. ;-) https://github.com/goldfirere/units
12:49:00 <fen> what about D (const a) ? maybe thats 0 ...
12:53:07 <xsperry> dmwit, nice. is it meant to be used for real world projects, or is it just to showcase haskell's type system?
12:53:25 <dmwit> I expect the latter.
12:54:23 <dmwit> Anyway you can probably adopt a similar trick to avoid the Unit typeclass.
12:56:21 <xsperry> I'll take a look! also curious to find out how it does unit-aware calculations, dividing Length with Time to get Velocity.
12:57:08 <dmwit> (i.e. instead of `newtype Weight a = ...; newtype Length a = ...` you could `newtype Unit dim a = Unit { fromUnit :: a }; data Weight; data Length`.)
12:57:38 <dmwit> (and then `Unit Weight` is the new spelling of your old `Weight`)
12:58:28 * hackage fay 0.24.0.2 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.24.0.2 (swamp_agr)
12:58:57 <xsperry> ah I see
13:01:12 <xsperry> in my paste, are there any potential speed issues for using Floating a all over the place, instead of specializing everything to, say, Double?
13:01:28 <xsperry> s/Floating/Fractional
13:02:59 <dmwit> In a single module like this, I expect specialization and constant propagation will turn your whole program into "dump this exact byte array to screen".
13:03:13 <dmwit> Once you start doing cross-module stuff you'll likely have some issues, yeah.
13:04:32 <tdammers> if you know what you're doing, explicit inline pragmas and RULES go a long way though
13:31:02 <nshepperd1> Huh, the differentiable function type in that ad paper is exactly the thing i used all along for NNs
13:32:20 <nshepperd1> I didn't think of it as representing the derivative by a linear map, but that makes a lot of sense
13:35:14 <aware> \exit
13:35:41 <michalrus> Is there a syntax for multiple matches in `let`?
13:36:00 <michalrus> For     Pattern match(es) are non-exhaustive
13:36:00 <geekosaur> no, you'll have to use case
13:36:05 <michalrus> Ok, thanks!
13:36:07 <shapr> let x = 1\n    y = 2
13:36:11 <geekosaur> well
13:36:13 <shapr> oh, that kind of match
13:36:19 * michalrus ^.^
13:36:25 <geekosaur> actuaally I think you migth eb able to use multipledefinitions
13:36:27 <geekosaur> like at top level
13:36:28 * hackage tokenizer-streaming 0.1.0.0 - A variant of tokenizer-monad that supports streaming.  http://hackage.haskell.org/package/tokenizer-streaming-0.1.0.0 (implementation)
13:36:45 <geekosaur> let\n  foo pat1... = ...\n  foo pat2... = ...
13:37:06 <geekosaur> …derp, I'm even doing that in existing code
13:37:17 <michalrus> Yes, me too, but I mean like… 
13:37:21 <michalrus> let h:t = …
13:37:24 <michalrus>    | _ = …
13:37:45 <michalrus> I could define an f…
13:37:47 <geekosaur> that you can't
13:37:50 <michalrus> let f (h:t) = …
13:37:53 <michalrus>     f _ = …
13:37:57 <michalrus>  in f …
13:37:59 <michalrus> OK
13:38:28 * hackage tokenizer-monad 0.2.2.0 - An efficient and easy-to-use tokenizer monad.  http://hackage.haskell.org/package/tokenizer-monad-0.2.2.0 (implementation)
13:38:44 <ondrejs> hello. I am using servant for a web server. I have `server psql user = handlerA :<|> handlerB`. Now I'd like to do something like `server psql user = do; ask psql if user is an admin; if yes then handlerA :<|> handlerB else throwError e307`, which understandably does not typecheck. Is there a working way how to implement this idea please?
13:39:35 <[exa]> ondrejs: I think there's a documented standard way of decorating whole sub-trees of the APIs with authentication
13:40:56 <amx> it's the first google hit for servant authentication
13:41:06 <ondrejs> [exa]: I am using servant-auth for authentication, now I need to add authorization... maybe I could reuse servant-auth
13:41:07 <[exa]> ondrejs: ie, why wouldn't the 'generalized authentication' here https://haskell-servant.readthedocs.io/en/stable/tutorial/Authentication.html match your expectation?
13:41:45 <dmwit> michalrus: How would that work? If the two patterns you gave bound different variables, which (if any) of them would be available in the body of the let?
13:41:47 <[exa]> oh so
13:42:09 <[exa]> ondrejs: who do you define authorization in the api context btw?
13:42:58 * hackage tokenizer-streaming 0.1.0.1 - A variant of tokenizer-monad that supports streaming.  http://hackage.haskell.org/package/tokenizer-streaming-0.1.0.1 (implementation)
13:43:07 <[exa]> supposing some more complicated access rights than just "has password"?
13:43:25 <michalrus> dmwit: right! In such case that could be a compiler error, like in that proposed -XMultiCase, but… that’s too complicated. =)
13:43:58 <ondrejs> [exa]: I don't (at least yet) represent authorization in the api. There's some reasoning for not doing that here https://github.com/haskell-servant/servant-auth/issues/73#issuecomment-349737003
13:44:17 <dmwit> michalrus: But then the thing you asked for (`h:t = ...; _ = ...`) wouldn't be allowed anyway. =P
13:44:26 <michalrus> Yes. ^.^
13:44:40 <ondrejs> so I thought I'd go that way but then couldn't find a way how factor out the authorization code
13:49:04 <amx> ondrejs: I do both. Every endpoint requires Authentication as seen in the docs and I attach the user read from the DB to the Auth record. Then in the handlers I can check whether the user is an admin and act accordingly.
13:51:25 <[exa]> ondrejs: you'll probably need to dig into how to implement your own combinators for getting that to work the "nice way", I'm not aware there would be a good framework for doing that directly in types
13:52:27 <[exa]> (I'd recommend amx's approach though. Authorization should be close to what's authorized.)
13:52:40 <merijn> :ls
13:52:58 * hackage terminal-punch 0.1 - Simple terminal-based time tracker  http://hackage.haskell.org/package/terminal-punch-0.1 (EmilAxelsson)
13:54:26 <ondrejs> amx: that's pretty much what I am trying to do, except that I want to do this before `handleA :<|> handleB` as opposed to inside the handlers.
13:54:53 <__monty__> Is there a better way to branch on a boolean in a do block than using if-then-else?
13:55:14 <ondrejs> amx: the problem is I need IO there, simple if would work fine
13:55:24 <geekosaur> "better"?
13:55:39 <amalloy> depends what you want to do, i guess, __monty__. Data.Bool.bool can help for some cases, Control.Monad.guard for some...
13:56:00 <__monty__> geekosaur: Some prefer boolean guards over if-then-else on the rhs.
13:58:08 <iqubic> So I'm looking for a Haskell charting library. Like, let's say that I want use Haskell to create some mathematical plots. Can someone link me to a good library that will compile with a recent version of GHC (6.4.x or newer)?
13:58:09 <ondrejs> actually, I don't understand what data type `handleA :<|> handleB` is. Each `handleX` is a Handler which is MonadIO so I can get to the database inside.
13:58:53 <iqubic> ondrejs: Looks like that should have type Handler
13:58:55 <__monty__> amalloy: Neither seems what I'm after bool just shuffles the order and guard seems like something for fail-fast rather than branching to two potential results.
13:58:59 <iqubic> :t (<|>)
13:59:00 <lambdabot> Alternative f => f a -> f a -> f a
13:59:21 <iqubic> Unless :<|> is different from <|> in some way that I don't yet know.
13:59:30 <amalloy> iqubic: it must be
13:59:33 <iqubic> Sorry, I just joined here.
13:59:36 <__monty__> But I guess there's no opposition to using if-then-else in a do block then.
13:59:51 <amalloy> __monty__: do you have a specific code snippet you're looking to improve? a paste of that is easier to talk about than the large abstract space of "functions with if clauses in them"
13:59:53 <amx> ondrejs: you don't need to go to the database there if I understand correctly what you try to do
14:00:26 <iqubic> So, I'm not sure what the best plotting library is in haskell. Can I get some help with that?
14:00:27 <amx> ondrejs: you can go to the database when you check authentication
14:00:54 <amalloy> iqubic: (:<|>) must be a data constructor for some type. presumably this is defined in servant since the question was about servant
14:01:16 <amx> ondrejs: https://haskell-servant.readthedocs.io/en/stable/tutorial/Authentication.html#what-is-generalized-authentication
14:02:58 * hackage human-readable-duration 0.2.1.3 - Provide duration helper  http://hackage.haskell.org/package/human-readable-duration-0.2.1.3 (yogsototh)
14:03:30 <ondrejs> iqubic: It's :<|>
14:03:33 <amalloy> http://hackage.haskell.org/package/servant-0.15/docs/Servant-API.html#t::-60--124--62-
14:03:35 <ondrejs> :t (:<|>)
14:03:37 <lambdabot> error:
14:03:37 <lambdabot>     • Data constructor not in scope: :<|>
14:03:37 <lambdabot>     • Perhaps you meant one of these:
14:03:52 <ondrejs> oic
14:03:54 <wroathe> iqubic: Depending on how crazy you need to go you could just feed the data into gnuplot and call it good
14:03:57 <ondrejs> amx: I do need the database there
14:04:22 <wroathe> iqubic: Rather than having Haskell do the rendering
14:04:28 * hackage terminal-punch 0.1.1 - Simple terminal-based time tracker  http://hackage.haskell.org/package/terminal-punch-0.1.1 (EmilAxelsson)
14:04:47 <ondrejs> amx: or actually I get the authentication object (e.g. User) with every request, right...?
14:04:55 <amx> yes
14:05:11 <ondrejs> so I could just load "this is the list of things user has access to" and then check for membership
14:05:11 <ondrejs> neat
14:05:17 <ondrejs> thanks!
14:05:26 <amx> yeah this is also what I do :)
14:06:49 <amx> for multi-level and multi-lateral security
14:11:45 <__monty__> amalloy: I want to branch on base here: http://ix.io/1yZL
14:15:17 <amalloy> __monty__: you could define another function that takes base as input and produces that Number expression as output
14:15:54 <__monty__> amalloy: Good option. I'm just gonna split the Hex and Oct cases though I think.
14:19:08 <ondrejs> amx: actually, the user object is created on login, not with every request
14:19:45 <ondrejs> logged in, changed my username in the db, then asked the server for my username and it gave me the old one
14:19:57 <amalloy> i'm not familiar with ReadP, but if this were parsec i'd write something like: number = (char '0' *> (hexNum <|> octNum)) <|> decNum
14:20:39 <amx> ondrejs: huh? what is "login"?
14:20:50 <ondrejs> amx: sign in
14:20:56 <ondrejs> anyway, the generalized method will work
14:21:30 <ondrejs> just clearing up that my conclusion "user object will get loaded with the check credentials function with every request" was wrong
14:22:52 <sm> if I've got a Q FilePath (generated by https://hackage.haskell.org/package/file-embed-0.0.11/docs/Data-FileEmbed.html#v:makeRelativeToProject), how could I pass that to a QuasiQuoter that takes a file path ? (http://hackage.haskell.org/package/here-1.2.13/docs/Data-String-Here-Uninterpolated.html#v:hereFile)
14:23:37 <sm> I'm having path problems with hereFile that I think makeRelativeToProject would fix
14:23:38 <edmundnoble> Monod
14:23:46 <c_wraith> sm, extract the expr splice from the quasiquoter inside a TH splice.
14:23:46 <edmundnoble> :^)
14:24:58 * sm tries to do that
14:25:15 <c_wraith> sm, ie, quasiquotes aren't built for that. but TH is, and quasiquotes are also records of String -> Q Something functions.
14:27:37 <sm> something like: QuasiQuoter{quoteExp=hereFileExp} = hereFile ... $(makeRelativeToProject "Hledger/Cli/Commands/Close.md" >>= hereFileExp) ?
14:29:51 <sm> seems rightish to me, but GHC is very unhappy
14:35:18 <fragamus> what does the @ sign mean here:
14:35:20 <fragamus> % :t fmap @((->) Int)
14:35:21 <yahb> fragamus: (a -> b) -> (Int -> a) -> Int -> b
14:35:48 <dmwit> fragamus: It is "type application".
14:36:10 <dmwit> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=typeapplication#extension-TypeApplications
14:39:08 <Axman6> > read @Int "123"
14:39:10 <lambdabot>  error:
14:39:10 <lambdabot>      Pattern syntax in expression context: read@Int
14:39:10 <lambdabot>      Did you mean to enable TypeApplications?
14:39:20 <dmwit> % read @Int "123"
14:39:21 <yahb> dmwit: 123
14:39:30 <Axman6> yes, I did lambdabot, you know I did
14:40:01 <Axman6> % read "True" -- :(
14:40:01 <yahb> Axman6: *** Exception: Prelude.read: no parse
14:40:09 <Axman6> % read @Bool "True" -- :)
14:40:09 <yahb> Axman6: True
14:40:21 <wroathe> Someone should make lambdabot sassy
14:40:27 <wroathe> That would be way more entertaining
14:40:34 <dmwit> % read @Int "0x64" -- it's a power of 2!
14:40:34 <yahb> dmwit: 100
14:40:38 <dmwit> Okay, it's a power of 10
14:40:41 <Axman6> lambdabot: is already sassy enough
14:40:51 <dmwit> ?quote wroathe
14:40:52 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
14:41:05 <Axman6> @quote
14:41:05 <lambdabot> Speck says: "That's like cheating. It isn't even programming. You just tell it what to do and it does it." -- My friend upon seeing some Haskell code
14:41:06 <dmwit> Turn the sass down a notch, will you?
14:41:32 <MarcelineVQ> lambdabot has a sassy mode, but I think this one has that turned off
14:41:43 <MarcelineVQ> ​@vixen or something :>
14:41:44 <Axman6> I miss those days
14:41:54 <Axman6> vixen was pretty funny
14:42:16 <Axman6> but... not compatible with today's social environment
14:42:28 <MarcelineVQ> todays social environment should grow up
14:46:46 <jackdk> +1
14:47:02 <geekosaur> -1
14:47:10 <Axman6> 0
14:47:25 <zachk> i^2
14:47:28 <geekosaur> I know it's 'natural" that men are the ones who get to decide and what turns them on is therefore 100% appropriatte
14:48:03 <__monty__> Aha, so we know what the V stands for. Now all we need to find out is what the Q stands for.
14:48:06 <geekosaur> so of course anyone who thinks that's wrong needs t "grow up" / "be a man" / "get a pair"  etc. etc./ all of which says "penis is god"
14:48:14 <edmundnoble> Penis IS god
14:48:23 <edmundnoble> It tells me how to write Haskell
14:48:24 <wroathe> My penis is, anyways
14:48:26 <MarcelineVQ> uh
14:48:35 <zachk> -_-
14:48:39 <edmundnoble> Obviously I mean that in the shaivist sense
14:48:45 <Axman6> My pen is ok
14:48:55 <Clint> what the
14:49:09 <edmundnoble> :O
14:49:23 <wroathe> That being said, I think it's probably possible to make a bot sassy without making it sexist :P
14:49:38 <MarcelineVQ> a strange leap has been made
14:49:51 <Axman6> I always assumed @vixen was based on the classic 16/f/cali girl really being a fat hairy 40 year old man
14:50:15 <Axman6> @nixon
14:50:15 <lambdabot> Your boys will be home for Christmas.
14:50:25 <dmwit> ?yow!
14:50:26 <lambdabot> Isn't this my STOP?!
14:50:49 <Axman6> Yow!'s a pretty good conference
14:51:42 <edmundnoble> +1
14:54:12 <edmundnoble> Apparently there's a yow conference which *isn't* the one on FP, the FP one at least is very good
15:00:20 <Axman6> yeah original Yow! is pretty good too
15:01:30 <jackdk> I got to see Guy Steele talk at a yow many years back, that was a lot of fun. Also someone showing off cool stuff in smalltalk, including "I can't run this image for very long, it leaks memory and I can't work out why"
15:02:23 <jackdk> and writing that I literally just realised that my fear of image-based languages is because it makes the dev environment stateful and hard to predict
15:03:07 <jackdk> i.e., the opposite of the reason why I moved to FP
15:03:27 * hackage automata 0.1.0.0 - automata  http://hackage.haskell.org/package/automata-0.1.0.0 (chessai)
15:03:30 <zachk> image based languages, not my favorite thing
15:13:59 <c_wraith> jackdk, image-based like smalltalk?
15:15:46 <hpc> https://en.wikipedia.org/wiki/Esoteric_programming_language#Piet
15:16:43 <hpc> (but yeah, smalltalk was the main topic)
15:18:02 <c_wraith> yeah, every time I've heard about that, I've wondered why that's a thing someone would want.
15:18:25 <hpc> same reason people want docker nowadays
15:18:36 <hpc> it's the laziest path from "works on my machine" to "ship it"
15:18:44 <hpc> make production actually your machine
15:19:07 <rain1> hey
15:19:45 <c_wraith> at least docker gives you a theory about how to rebuild from scratch to get the same state.
15:20:07 <hpc> so does smalltalk source code
15:20:28 <metalrain> somehow image based makes me think a programming language where programcode is actually 2d picture, but I cannot really remember the name of the language
15:20:30 <hpc> but yeah, it's definitely possible to use it correctly
15:20:35 <wroathe> :t StateT
15:20:36 <lambdabot> (s -> m (a, s)) -> StateT s m a
15:20:54 <c_wraith> I was under the impression that smalltalk let's you create things, then change the source, but have the old code still running somewhere.
15:20:59 <c_wraith> *lets
15:21:01 <hpc> if you only use docker to package the stateless pieces of your program, and make those images in some reproducible way, that's fine
15:21:09 <wroathe> Is there a way I can alias this and provide types for m and a, but defer specifying s for later?
15:21:39 <c_wraith> wroathe, yes, but don't.
15:22:04 <c_wraith> wroathe, you can do that with a type alias, but it makes your code hard to read for no real gain.
15:22:15 <hpc> this sounds like an XY problem - what do you need this for?
15:23:26 <wroathe> Making the type of state going through my state transformers polymorphic
15:23:32 <wroathe> with a constraint
15:23:48 <hpc> you don't need this for that
15:24:16 <wroathe> type FromConfig a => EnvReader a = StateT a IO ()
15:24:20 <wroathe> I'm trying to do something like this
15:25:05 <c_wraith> why?
15:25:19 <c_wraith> even if it works, all it does is make things hard to understand
15:25:39 <c_wraith> just write the types where you actually mean them.
15:25:54 <hpc> type aliases don't make anything possible or impossible
15:26:03 <hpc> you might as well be running sed over your code before compilation
15:26:30 <wroathe> Yeah, this is literally just convenience
15:26:51 <c_wraith> I assure you, it is inconvenient to anyone using those types.
15:27:08 <hpc> i would take this inconvenience as a singla that you can structure your code better in some other way
15:27:15 <hpc> *signal
15:27:54 <wroathe> c_wraith: I mean, you might as well argue for them to remove the monad type aliases from base
15:27:59 <wroathe> As being "just a convenience"
15:28:10 <wroathe> :t State
15:28:11 <lambdabot> error:
15:28:11 <lambdabot>     • Data constructor not in scope: State
15:28:11 <lambdabot>     • Perhaps you meant one of these:
15:28:42 <wroathe> type State s = StateT s Data.Functor.Identity.Identity :: * -> *
15:28:57 <c_wraith> wroathe, those are kind of annoying too, but at least they don't remove the fact that it has the right kind to be a monad from the type.
15:29:13 <hpc> they aren't trying to hide a class constraint either
15:29:31 <wroathe> hpc: and yeah, I just realized that hiding the constraint in the alias is dumb
15:30:02 <hpc> if EnvReader is really something you want to think about as its own thing
15:30:02 <c_wraith> wroathe, when I read a type, a very important part is the kind of various constructors. seeing * -> * kinds is a huge hint to look for specific instances.
15:30:05 <hpc> make it a data type
15:30:53 <c_wraith> wroathe, I very much dislike aliases that suggest that instances that do exist can't
15:31:15 <hpc> using StateT a IO () seems like a mistake here too
15:31:19 <hpc> why not StateT () IO a?
15:32:40 <hpc> you could probably write this so it's not using StateT at all, even
15:33:04 <wroathe> :P I'm going to stick with my original design for now, and then open it up for code review for anyone who is interested later on
15:33:18 <wroathe> If I keep on bikeshedding on how to get this done it'll never get done
15:33:34 <hpc> heh
15:34:16 <xsperry> what is the point of StateT ()???
15:35:05 <hpc> xsperry: it was a sneaky hint ;)
15:36:46 <xsperry> that went over my head :)
15:40:25 <wroathe> The common example I see of how to use the state monad is something like a stack data structure, where s is the stack itself, and a is either () or the top of the stack
15:40:34 <wroathe> So there's this notion of carrying state (the stack) through a sequence of computations
15:40:37 <wroathe> https://gist.github.com/sdiehl/8d991a718f7a9c80f54b
15:40:59 <wroathe> In my case I'm modeling carrying a map through a sequence of computations that depend on the program's environment
15:41:49 <wroathe> There might be a better monad for this
15:46:22 <wroathe> Also, if this wasn't a valid usage for State I don't understand why they'd provide http://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Lazy.html#v:execStateT
15:47:28 * hackage aeson-gadt-th 0.1.0.0 - Derivation of Aeson instances for GADTs  http://hackage.haskell.org/package/aeson-gadt-th-0.1.0.0 (abrar)
15:49:21 <wroathe> Really I suppose I just need s -> s instead of a -> s -> (a, s)
15:49:28 * hackage json-pointer 0.1.2.2 - JSON Pointer parsing and interpretation utilities  http://hackage.haskell.org/package/json-pointer-0.1.2.2 (NikitaVolkov)
15:50:27 <hpc> :D
15:53:17 <infinisil> wroathe: You could just make your own monad, a stack monad, that only supports push and pop
15:53:49 <wroathe> infinisil: That was just the example I was using to describe why I chose the State monad for what I'm doing
15:54:02 <wroathe> infinisil: I'm being told that that wasn't the optimal choice
15:54:13 * infinisil reads more of the backlog
15:55:10 <wroathe> infinisil: That question was what the point of StateT s IO () is
15:55:42 <iqubic> So I'm looking for a good haskell library for plotting data and making charts is.
15:55:44 <wroathe> That is, if I don't need an "a", what would be the better way to represent s -> s
15:56:05 <infinisil> Hmm..
15:56:21 <infinisil> :t modify
15:56:22 <lambdabot> MonadState s m => (s -> s) -> m ()
15:56:34 <infinisil> How about just a function of type s -> s
15:56:35 <hpc> iqubic: diagrams?
15:56:43 <infinisil> wroathe: Then you can plug it into modify
15:57:30 <wroathe> I was thinking about that, but wrapping s -> s in a newtype would then mean I'd have to define a monad instance for it
15:57:45 <wroathe> When this seems like something that should be doable with the standard set of monads in base that already have instances defined
15:57:53 <infinisil> Why a newtype?
15:58:05 <wroathe> To define the monad instance?
15:58:10 <Clint> why do you need a monad
15:58:14 <infinisil> Yeah ^
15:58:31 <infinisil> I mean, for s -> s specifically
15:58:58 * hackage vector-space 0.16 - Vector & affine spaces, linear maps, and derivatives  http://hackage.haskell.org/package/vector-space-0.16 (ConalElliott)
15:58:59 <xsperry> wroathe GeneralizedNewtypeDeriving doesn't work for Monad? (never tried)
15:59:00 <wroathe> I'd like the user of this thing to be able to just write something like: result <- doThing1 >> doThing2 >> doThing3
15:59:16 <wroathe> (or in do notation)
15:59:41 <wroathe> actually, that's not quite right
16:00:18 <iqubic> hpc: I want a way to provide a list of X and Y coordinates and just have that plotted for me. With options to be able to change the scaling and color too.
16:00:25 <infinisil> Is there a predefined set of things a user can do? How is doThingN defined?
16:00:26 <dibblego> @type (cons, uncons) -- wroathe 
16:00:28 <lambdabot> Cons s s a1 a1 => (a1 -> s -> s, [a2] -> Maybe (a2, [a2]))
16:00:34 <hpc> ah
16:00:49 <wroathe> It's a predefined set of things that I'd be encouraging them to write more of if they need it
16:01:52 <wroathe> it would actually be something like result <- execStateT (doThing1 >> doThing2 >> doThing3) H.empty
16:01:57 <infinisil> wroathe: And what's the user allowed to write? Just a combination of the already defined ones or is there like IO behind it they can mess around with?
16:02:51 <wroathe> Alright, fine, go easy on me :P I'm just getting started with this:
16:02:58 <wroathe> https://github.com/JustinChristensen/config-provider/blob/master/src/System/Environment/Config.hs#L199
16:03:01 <infinisil> :P
16:03:13 <wroathe> First Haskell library attempt
16:03:20 <wroathe> Trying to model ASP.NET's ConfigurationProvider
16:03:35 <wroathe> https://github.com/JustinChristensen/config-provider/blob/master/src/System/Environment/Config/Default.hs#L49
16:04:04 <wroathe> Basically the user can specify sources for configuration in precedence order
16:04:21 <wroathe> There's more to this than just what you see here
16:04:22 <ni291187> h i I have the following code  let f n (xs) = if n < 0 then f (n-1) (n:xs) else xs  f (-3) [] !! 1  and I except it to print -4  but it does not print anything and keeps calculation in background  what is wrong with my code?
16:04:48 <wroathe> I'd like binding to custom data types (via something like FromJSON in Aeson), and the ability to derive CLI usage documentation from the expected configuration data type
16:04:53 <infinisil> wroathe: Have you seen the reader monad? I don't see you changing the state anywhere
16:05:15 <wroathe> reader is r -> a
16:05:17 <wroathe> afaik
16:05:38 <wroathe> Obviously I could write code to thread it the way I want
16:06:22 <ni291187> h i I have the following code  let f n (xs) = if n < 0 then f (n-1) (n:xs) else xs  f (-3) [] !! 1  and I except it to print -4  but it does not print anything and keeps calculation in background  what is wrong with my code?
16:06:42 <wroathe> ni291187: Chill winston, it's only been two minutes
16:06:46 <infinisil> wroathe: So, EnvReader is supposed to (in later code) change the environment?
16:07:20 <wroathe> It's supposed to model a step in a chain where the current configuration state is passed into a routine that can read from the environment, and produce a new configuration state
16:07:43 <xsperry> ni291187, your base case is never true if n is initially < 0
16:07:46 <wroathe> The "default" will be as I've defined it there, i.e. args > env > config files
16:07:57 <hpc> ni291187: start with (if n < 0 then f (n-1) (n:xs) else xs), then substitute in n = (-3) and xs = []
16:08:03 <infinisil> wroathe: And the config is part of the environment I assume?
16:08:04 <hpc> ni291187: and see what that evaluates to
16:08:19 <wroathe> But the user can define their own reader by composing the ones I've built or adding their own
16:08:48 <infinisil> wroathe: That sounds very lensy
16:09:07 <wroathe> I'd rather keep the API as conceptually simple as possible
16:09:34 <wroathe> Just config -> magic IO stuff -> new config
16:09:35 <wroathe> in a chain
16:09:49 <wroathe> until the process has the final configuration state
16:10:41 <wroathe> and the point of making the readers an instance of monad is to allow specifying that precedence order in do notation
16:10:48 <wroathe> As I've done in defaultReader
16:11:17 <infinisil> wroathe: Wait where's defaultReader
16:11:25 <wroathe> https://github.com/JustinChristensen/config-provider/blob/master/src/System/Environment/Config/Default.hs#L48
16:12:12 <infinisil> Hmm I see, this now sounds very ExceptT-ish
16:12:38 <wroathe> Sort of. I'm planning on supporting multiple models of error handling
16:12:43 <wroathe> Again, like Aeson does
16:12:49 <infinisil> Actually this doesn't sound like a good idea
16:13:05 <xsperry> wroathe, will you use MonadCatch & friends?
16:13:16 <xsperry> MonadThrow, even
16:13:27 <wroathe> xsperry: Haven't gotten that far
16:13:44 <infinisil> wroathe: In that function you just ignore the return values
16:13:47 <wroathe> I've deferred error handling for now until I've had time to survey the landscape
16:14:02 <infinisil> wroathe: And ignoring return values indicates that you don't want monads
16:14:06 <zachk> use a maybe or a an either perhaps, that what I use for simple error handling 
16:14:20 <wroathe> Yup, those are two options I've seen
16:14:45 <xsperry> why not both Maybe, Either? And add [] and IO for a good measure :)
16:16:42 <wroathe> For utility I could definitely see returning the current configuration state with >>=
16:16:52 <ni291187> i thought in my code f will populate the list forever, but as want value at index 1 the lazy evaluation will calculate it and stop
16:16:58 <wroathe> Right now the way I've designed it is just to chain with >>
16:17:23 <zachk> so you are calling your code for side effects only? 
16:17:34 <infinisil> wroathe: So you just want to use do notation and related operators because it looks good?
16:18:11 <wroathe> Because it's meant to be a library easily usable by people that don't live and breath this stuff :P
16:18:33 <wroathe> So that they can write their own simple function in a declarative way to sequence reading configuration from the environment
16:18:34 <infinisil> That will be a bumpy road then..
16:18:46 <infinisil> Monads have their laws for a reason
16:19:27 <wroathe> Well, this still is a law abiding monad
16:19:28 <edmundnoble> I'd recommend using a monoid
16:19:58 <edmundnoble> There's a great DSL, `<>`
16:20:20 <infinisil> Or Alternative
16:20:23 <wroathe> And if we want to get pedantic I'll just thread the configuration state through as the state AND return the state value in place of a
16:20:56 <wroathe> so I can legally say that >>= is now useful
16:21:06 <infinisil> Hmm maybe that works yeah
16:21:16 <infinisil> It just feels wrong!
16:21:24 <edmundnoble> How is >>= useful in that setting
16:21:33 <edmundnoble> It sounds like you are writing `s -> IO s`
16:21:44 <wroathe> edmundnoble: exactly
16:21:45 <wroathe> :D
16:21:59 <edmundnoble> Okay, so write `s -> IO s`!
16:22:02 <edmundnoble> Skip the middle man
16:22:03 <wroathe> I'm trying to decide what the right way to model that is. People here have objected to the use of StateT
16:22:44 <edmundnoble> You can write a monoid instance for it which does exactly what is being done to your `do` statements
16:23:11 <infinisil> wroathe: Maybe check out https://hackage.haskell.org/package/MonadCompose-0.8.4.2/docs/Control-Monad-IOT.html#t:IOT
16:23:27 <infinisil> Although, maybe not
16:23:43 <phadej> State(T) with execState(T) are handy when you are writing imperative-looking DSLs
16:24:01 <wroathe> phadej: Which is exactly what I'm doing
16:24:02 <amalloy> IOT? the internet of things has even gotten into monads now!
16:24:12 <infinisil> amalloy: Heh
16:24:43 <phadej> Monoid base API is ok when you actually have a monoid; but then you can also use Writer
16:24:57 <xsperry> wroathe, https://bpaste.net/show/1bf6adf60018
16:25:01 <phadej> (that's to first approximation what blaze-markup and lucid are)
16:25:07 <hpc> ni291187: you keep calling f with larger and larger lists, however the first element of the list is dependent on the result of f (f (f (f (f (f (f ...
16:25:08 <edmundnoble> The state computation here is the monoid
16:25:34 <edmundnoble> Though I think that the way it is right now, as StateT, is actually fine
16:25:37 <hpc> er, two different lists there
16:25:42 <hpc> the first element of the result list
16:25:58 <edmundnoble> What were people objecting about?
16:26:01 <edmundnoble> Why not use StateT here?
16:26:11 <hpc> ni291187: so, look at it this way
16:26:19 <hpc> ni291187: f n xs = some sort of list
16:26:27 <hpc> ni291187: what's the first element of that list?
16:26:31 <phadej> I feel that first you have to decide what you want your API look like
16:26:36 <wroathe> whether StateT s IO () "makes sense"
16:26:39 <edmundnoble> Sure
16:27:10 <edmundnoble> I mean if what you want is for users to have the full power of the StateT API, as well as do-notation, despite most of the time returning `()` in it
16:27:13 <wroathe> And to infinisil's point, it kind of makes >>= useless
16:27:16 <edmundnoble> There's no problem
16:27:38 <wroathe> But I can cheat and just say that a -> s -> (s, s)
16:27:47 <wroathe> Now you get two APIs for the price of one
16:27:50 <edmundnoble> Errrr
16:27:51 <phadej> >>= is not useless
16:27:59 <edmundnoble> You're using `>>=` to compose your stateful computations
16:28:08 <edmundnoble> So you're already using it
16:28:20 <phadej> you can do things like  ys <- forM xs $ \x -> do ....; return y
16:28:22 <edmundnoble> Also `get :: Applicative f => StateT s f s` 
16:28:47 <phadej> (which makes it imperative looking, as you have those forEach "loops")
16:29:28 <infinisil> wroathe: Ah, I think I get what you mean: You want something like StateT, but without the last return parameter, because you don't need it
16:29:43 <wroathe> Yup
16:29:55 <wroathe> edmundnoble was right about this essentially just being s -> IO s
16:30:02 <edmundnoble> The problem is
16:30:10 <edmundnoble> I am not convinced you really don't want the last param
16:30:16 <edmundnoble> Because you *could* want it later
16:30:27 <edmundnoble> And in fact when you use do notation you *prove* that you want it
16:30:30 <infinisil> wroathe: Ah, so it's essentially a state transformation where the user can just supply transformations but never gets the value, only the caller gets the resulting value
16:31:14 <wroathe> infinisil: Yeah, and again this is all very very early stage
16:31:15 <wroathe> So go easy
16:31:18 <wroathe> https://github.com/JustinChristensen/config-provider/blob/master/app/Main.hs
16:32:11 <edmundnoble> Using the version which is actually `newtype EndoM m s = EndoM {runEndoM :: s -> m s}` *could* have benefits
16:32:19 <edmundnoble> Because monoids compose pretty nicely
16:32:39 <edmundnoble> However you do want do-notation, and it's very possible that later you will end up instantiating `a` to things other than `()`
16:32:53 <wroathe> edmundnoble: That actually was my exact thought
16:33:00 <wroathe> edmundnoble: When I started this
16:33:01 <phadej> I have to repeat: sketch the program you want to write, and then fill the blanks
16:33:14 <edmundnoble> I have to repeat my agreement
16:33:17 <phadej> don't start with the library
16:33:22 <edmundnoble> You really don't know until you know what your programs need to do
16:33:29 <wroathe> phadej: Yup. I've already done so.
16:33:35 <wroathe> You just can't see my notes ;)
16:33:46 <edmundnoble> I'm still very curious why people were objecting to StateT
16:34:08 <wroathe> hpc: Care to chime in :)?
16:34:14 <phadej> (I can imagine that if you have StateT s IO you might just use Reader (IORef s))
16:34:21 <hpc> ooh, code
16:34:24 <infinisil> I wasn't really objecting it, it's just that half of StateT is useless when the result is always ()
16:34:35 <wroathe> haha
16:34:57 <phadej> err ReaderT (IORef s) IO
16:35:16 <phadej> infinisil: but it isn't always (), necessarily.... we haven't seen the notes
16:35:24 <wroathe> All of this being said, nothing I have here is final
16:35:44 <phadej> don't understimate how useful mapM/forM are
16:35:54 <wroathe> I'm pretty set on wanting imperative looking do notation for the end user to specify the sequence of configuration readers
16:36:05 <wroathe> And wanting the ability to bind to a custom ADT like Aeson lets you do
16:36:15 <wroathe> And deriving CLI usage documentation from that type
16:36:31 <wroathe> Just how to get from a to b is up in the air
16:36:32 <phadej> hmm... deriving CLI usage won't cut if you use Monad class
16:36:50 <infinisil> I smell extensible effects
16:37:01 <phadej> that's why it's e.g. optparse-applicative
16:37:06 <phadej> and not optparse-monad
16:37:19 <infinisil> And Free Monads
16:37:19 <phadej> you can cheat with ApplicativeDo though
16:39:16 <wroathe> phadej: I haven't fully explored optparse-applicative yet, but regardless of how they do it, one should be able to map an ADT to a String explaining it's fields, shouldn't they?
16:40:03 <wroathe> So if I say my Config ADT has a Maybe env field, I can print out for --help that --env is an optional flag
16:41:03 <wroathe> I haven't quite figured out how to do the rest though, because I'd like to add something like phantom types to annotate it with more metadata like a description, or whether a flag implies another flag
16:41:33 <wroathe> (This is all voodoo black magic that I'm still exploring)
16:41:41 <hpc> wroathe: your problem is making more sense now - i still think you could get by with (Config -> IO Config) as the type you're operating on instead of pulling in StateT
16:41:44 <hpc> check out (>=>)
16:41:48 <hpc> you could write something like
16:42:21 <hpc> (yamlFileReader "/etc/whatever/config.yaml" >=> jsonFileReader "~/.whatever/config.json") emptyConfig
16:43:26 <hpc> wroathe: if it also helps, instead of thinking in terms of stateful modifications to configs, think of it as merging two configs
16:48:06 <wroathe> After reading two "getting started" books on Haskell I still didn't really feel like I knew how to program in Haskell. So this is sort of my attempt at trial by fire for something I think might be actually useful to web application authors
16:48:11 <hpc> oh, and you'd still have do notation - do {c <- yamlFileReader "foo.yaml" emptyConfig; c <- jsonFileReader "foo.json" c; ...}
16:49:03 <wroathe> I'm finding that Haskell is a language with nearly infinite potential for bikeshedding
16:49:16 <hpc> you also picked a problem with a very open design space
16:49:26 <hpc> but it's definitely useful
16:49:47 <edmundnoble> Yes, you *can* do whatever you want
16:49:54 <edmundnoble> Usually a language will guide you into doing something crappy
16:50:05 <edmundnoble> :^)
16:50:14 <edmundnoble> Here you can have the space to start with what you want and work backwards
16:51:00 <wroathe> Well, I've got plenty to think on. Thanks for the feedback all.
17:00:40 <suzu> how can i piggyback on the auto-derived Show for a type?
17:00:50 <suzu> i wish to write a custom show for some cases, and use the derived for others
17:02:32 <aplainzetakind> write a show' ?
17:03:06 <amalloy> suzu: will your Show be compatible with Read? if not, consider not doing this
17:03:13 <suzu> yes
17:03:19 <suzu> it will be compatible
17:03:50 <suzu> aplainzetakind: i need it to be Show because i will derive other things from the Show instance
17:04:01 <jle`> what sort of other things?
17:04:03 <suzu> or rather, some functions i wish to use depend on it having a sane Show instance
17:04:16 <suzu> more specifically, i have an enum as an ADT that i wish to insert into a database
17:04:29 <jle`> to answer your original question, no, you can't really use the default Show without actually deriving Show
17:04:44 <suzu> but i wish to use "foo" "bar" "this-that" rather than the casing of the original terms
17:05:00 <suzu> i also wish to receive these fields as form url-encoded params on a servant endpoint
17:05:03 <jle`> that doesn't sound like something you'd use show for
17:05:08 <jle`> that sounds like a pretty printing or encoding thing
17:05:12 <jle`> Show is mostly for debugging
17:05:33 <suzu> yeah that is true
17:06:05 <suzu> is there a way to write show' without manually casing on each term and writing it out again wit ha different case
17:08:04 <aplainzetakind> show' x | x `elem` [ list of default stuff ] = show x; | otherwise = toLower . show $ x
17:08:17 <aplainzetakind> Would something like this do?
17:08:31 <suzu> oh yep
17:08:34 <suzu> ty
17:16:51 <nvt> http://codepad.org/YU01qU6r - any idea how to get this to print a list of tuples - I don't even understand where those floats come from 
17:18:18 <amalloy> that looks like a list of tuples of floats to me
17:18:47 <ClaudiusMaximus> :t sqrt
17:18:48 <lambdabot> Floating a => a -> a
17:18:48 <amalloy> it can't result in integers, because you use sqrt
17:18:49 <nvt> true, i would want a list of tuples of integers
17:18:54 <nvt> i tried to change the signature
17:19:06 <ClaudiusMaximus> add more fromIntegral
17:21:30 <ClaudiusMaximus> nvt: http://codepad.org/XeOntvPI
17:21:30 <nvt> I don't understand why that list includes flots because I only use the distance function to compare, I'm not using the result anywhere
17:22:02 <jle`> nvt: what tuples are you trying to print?
17:22:11 <jle`> i don't see any printing anyhwere, or any tuples going on
17:22:26 <jle`> oh i see, i misse dthe comment
17:22:51 <amalloy> nvt: because your distance function only works on floats, ghc infers that your inputs must be floats
17:22:58 <ClaudiusMaximus> :t (\x -> (x, sqrt x)) 5
17:23:00 <lambdabot> Floating b => (b, b)
17:23:05 <amalloy> and therefore your outputs must be floats as well
17:23:19 <amalloy> it doesn't instead assume that your inputs are ints and that you want it to implicitly convert to float in order to check distances
17:23:58 <dmwit> protip: instead of `sqrt x <= y` try `x <= y^2`
17:24:02 <jle`> you can use 'round' to convert a Double into an Int
17:24:17 <jle`> but yeah, that might be the better way :) ^
17:24:22 <nvt> hmm. is p in distance function parameter the same p as in the other func
17:24:31 <jle`> nvt: if it helps, try giving 'distance' a type signature
17:24:32 <nvt> ClaudiusMaximus: seems to work
17:24:37 <jle`> i mean, it might help to try giving 'distance' a type signature
17:24:54 <jle`> that way ghc can work with you to help oyu figure out the issue
17:24:54 <ClaudiusMaximus> dmwit++
17:25:11 <nvt> I think I need sleep, 6 hours of haskell today 
17:25:14 <nvt> :D
17:25:35 <jle`> :D
17:25:39 <nvt> maybe better to see tomorrow again with nouvel brain
17:26:17 <suzu> nouvel
17:36:27 * hackage red-black-record 1.1.0.0 - Extensible records and variants indexed by a type-level Red-Black tree.  http://hackage.haskell.org/package/red-black-record-1.1.0.0 (DanielDiazCarrete)
17:54:46 <Guest9692> Not sure if this is the right place to ask, but I have a quick question about if statements in Haskell
17:55:04 <Guest9692> Im trying to learn functional programming coming from imperative and it is pretty mind bending so far
17:57:26 <ph88> hi Guest9692 
17:57:49 <Guest9692> Hello :)
17:57:59 <Guest9692> Here is a link to a short file I am trying to figure out
17:57:59 <Guest9692> https://pastebin.com/RcKDpKMV
17:58:05 <ph88> Guest9692, i am not aware that there exists "statements" in haskell
17:58:13 <Guest9692> Everything works as expected, it is just some recursive math
17:58:20 <Guest9692> and oh my bad, are they called expressions?
17:58:26 <suzu> expressions, yeah
17:58:34 <ph88> Guest9692, if then else  is an expression
17:58:53 <ph88> they produce a value
17:58:55 <jle`> Guest9692: statements in haskell are more of a user-space idea/concept than something built into the language
17:59:20 <jle`> s/produce/represent
17:59:30 <Guest9692> Got it, so my question is, is there a way to combine the two If's at the bottom of the file, it seems silly to have them be the same case but broken up into separate blocks
17:59:53 <jle`> Guest9692: one trick people do is to produce a tuple and directly pattern match out
18:00:07 <jle`> (count, vf1) = if vf1_signed < 0
18:00:18 <jle`>    then (c + 2, abs vf1_signed)
18:00:30 <jle`>   else (c + 1, vf1_signed)
18:00:35 <ph88> i'll let jle` take over from here :P
18:00:48 <jle`> but also you should probably be aware that `if x < 0 then abs x then x` is just `x`
18:01:01 <jle`> er, is just `abs x`
18:01:17 <jle`> so the entre line 15 could be `vf1 = abs vf1_signed`
18:01:33 <jle`> but it's still good to practice doing tuply matches
18:02:35 <Guest9692> Oh that makes sense, and that was because I wanted it to run as fast and possible and I assumed an if statement is a faster check than an absolute value function
18:02:42 <Guest9692> I mean it wont make a noticeable difference lol
18:02:54 <jle`> i mean, how do you think abs is implemented in the first place? ;)
18:02:54 <Guest9692> I come from embedded systems where I try to make everything as efficient as possible
18:03:11 <ph88> Guest9692, m1 and m2 seem to be connected looking at how you named them, consider creating a type to put them together. Same for v1 and v2
18:03:29 <Guest9692> oh lol I guess you're right jle
18:03:38 <Guest9692> and ph what do you mean? Sorry I am still very new to Haskell
18:04:00 <ph88> data MyMs = MM Double Double
18:04:22 <ph88> func :: MyMs -> the rest of the stuff      func (MM m1 m2) ... = 
18:04:55 <ph88> i don't know if this is what you _should_ do because i don't know what these numbers represent. Just an idea of what you _could_ do
18:05:21 <Guest9692> That is interesting, but if anything I would pair it m1 v1 and m2 v2
18:05:29 <Guest9692> Im not sure if you are familiar with 3blue1brown on youtube
18:05:38 <ph88> no
18:06:07 <Guest9692> super smart guy, makes math videos that teach me more than college courses do about understanding fundamentals because he is so good at explaining things
18:06:15 <ph88> nice
18:06:59 <ph88> Guest9692, don't bother with performance when you are just starting out. Try to write "elegant" first. Because understanding performance things is not straight forwarded when you come from imperative code.
18:07:04 <Guest9692> but he recently released a video about perfectly elastic collisions and how these boxes that just bump into eachother will end up hitting eachother "Pi digits" of times
18:07:20 <Guest9692> and I wrote a processing simulation of it, then I wrote a just pure math simulation in C for fun, and then I wanted to try Haskell
18:07:39 <Guest9692> and yeah yeah I know but ugly code hurts my soul :)
18:07:46 <Guest9692> thanks for the help
18:08:46 <Guest9692> One last question, is there a dissasembler for haskell like Godbolt or something?
18:08:58 <Guest9692> I am curious in how it optimizes things like the tuples and pattern matching
18:10:02 <ph88> Guest9692, godbolt runs haskell too
18:10:13 <dmwit> There's a disassembler *just* like Godbolt for Haskell. =P
18:11:25 <ph88> Guest9692, probably not a good idea to start optimizing your code by looking at the disassembler at first
18:11:57 <Guest9692> oh no no it is out of curiosity, im not going to try and optimize and write horrible looking code for the sake of an extra 10ms
18:12:23 <ph88> Guest9692, don't forget to put flags https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-optimisation.html 
18:12:39 <ph88> Guest9692, code looks ok to me :)
18:14:13 <ph88> https://godbolt.org/z/8r0tnd
19:07:44 <iqubic> What is purpose of the Setup.hs file that is created when running `cabal init`
20:20:58 * hackage aeson-gadt-th 0.1.1.0 - Derivation of Aeson instances for GADTs  http://hackage.haskell.org/package/aeson-gadt-th-0.1.1.0 (abrar)
20:54:27 * hackage function-builder 0.1.0.1 - Create poly variadic functions for monoidal results  http://hackage.haskell.org/package/function-builder-0.1.0.1 (SvenHeyll)
21:39:28 * hackage ipynb 0.1 - Data structure for working with Jupyter notebooks (ipynb).  http://hackage.haskell.org/package/ipynb-0.1 (JohnMacFarlane)
21:42:46 <sm> c_wraith: I figured it out (add TH pragma!) Thanks for the pointer
21:45:33 * sm wonders if it makes any difference whether you use a QuasiQuoter or TemplateHaskell
21:47:42 <iqubic> sm: I think those are mostly the same thing.
21:48:17 <iqubic> Or rather QuasiQuoters desugar to standard TH.
21:48:50 <sm> so I guess not.. thanks
21:56:18 <iqubic> no. The main difference is that QuasiQuoters are nicer to read and write.
21:58:06 <benzrf> well, they are for the kind of use case they apply to
21:58:44 <benzrf> "QuasiQuote" is such a bizarre name for those, btw
21:58:48 <benzrf> it's completely backward!
21:59:08 <benzrf> ordinary TH quoting is quasiquotation in the lisp sense, whereas "QuasiQuotes" is just plain quotation
22:00:19 <iqubic> IDK what that means,
22:01:10 <benzrf> in lisp, an expression E can be turned into the expression 'E, which evaluates to the AST of E
22:01:16 <benzrf> like [| E |] in template haskell
22:01:23 <benzrf> except not quite!
22:03:25 <benzrf> because [| |] allows you to splice ASTs in, which is accomplished in lisp by "quasiquotation" - if you do `E rather than 'E, then you still get the effect of an expression that evaluates to the AST of E, _except_ that certain notation for 'splicing' will be interpreted specially - this is "quasi"quoting. example: `(1 ,l 3) <- this will splice whatever is currently bound to l into the list 1 2 3. this is akin
22:03:27 <benzrf> to [| [1, $l, 3] |]
22:04:35 <benzrf> sorry that probably wasnt very helpful
22:30:20 <kitlangton>  
23:49:59 <bryan1_> yay! Prelude.read: no parse. I fear having to build with `--prof` to use `-xb` may take a century.. Is there any tricks using CallStack to get a line number?
23:54:00 <jle`> bryan1_: not with how read is written, i think
23:54:22 <jle`> but you can probably just replace read with readMaybe and fromMaybe (error "my error here")
23:54:39 <jle`> error contains callstack in its message
23:55:28 <jle`> (or something like it)
23:59:40 <dminuoso> jle`: Only if you add HasCallStack though, doesn't it?
