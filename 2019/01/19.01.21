00:23:58 * hackage salak 0.1.8 - Configuration Loader  http://hackage.haskell.org/package/salak-0.1.8 (leptonyu)
00:48:28 * hackage salak 0.2.3 - Configuration Loader  http://hackage.haskell.org/package/salak-0.2.3 (leptonyu)
00:53:12 <pdxleif> maerwald: You could use the Generic instance for the product types and compare those? Filter out fields you don't want to compare on?
01:18:27 * hackage wai-extra 3.0.25 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.25 (MichaelSnoyman)
01:19:27 * hackage warp 3.2.26 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.2.26 (MichaelSnoyman)
01:30:10 <oldandwise> any existing good ERP in haskell?
01:30:35 <oldandwise> python has odoo.. so still choosing which lang to use
01:31:52 <dminuoso> erp is such a complicated and broad domain.. what exactly are you asking for?
01:32:14 <oldandwise> remittance solution
01:32:42 <dminuoso> oldandwise: can you be a bit more specific?
01:32:56 <oldandwise> money remittance solution
01:33:16 <dminuoso> Should I pretend to understand your usecase now?
01:36:37 <oldandwise> am curious how's java's standing recently, now that J2EE is no more (due to docker)
01:42:42 <dminuoso> cocreature: I cant stress enough how amazing UnliftIO is!
01:43:04 <dminuoso> Being able to lift and unlift things is so flexible.. =)
01:43:39 <dminuoso> Any mutable state is being dragged in my Reader environment as IORefs, works great!
01:55:27 * hackage HsOpenSSL 0.11.4.16 - Partial OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.11.4.16 (VladimirShabanov)
02:17:56 <coldpress> is it normal for Text.Parsec to parse only a part of the full input, but still terminate successfully?
02:18:24 <merijn> coldpress: If your parser completes succesfully without consuming all input, yes?
02:18:48 <coldpress> merijn: it consumes all input, but only outputs part of what it's supposed to output
02:19:19 <dminuoso> coldpress: You need to be more specific.
02:19:57 <kritzefitz> coldpress: If you want to force your parser to consume all given input, you are probably looking for eof: https://hackage.haskell.org/package/parsec-3.1.13.0/docs/Text-Parsec-Combinator.html#v:eof
02:20:01 <coldpress> I guess the main culprit is buildExpressionParser? where `;` is a recursive operand generated by buildExpressionParser, my second operand is not well-formed: this parses correctly: emp;garbage
02:22:09 <kritzefitz> Just out of interest: If I have two types like `data A = forall a. A (a -> String) a` and `data B = B {-# UNPACK #-}!A`, why can't GHC unpack the A in B as requested?
02:23:41 <merijn> Well, what does it say when you do that?
02:24:00 <kritzefitz> ‚ÄúIgnoring unusable UNPACK pragma on the first argument of ‚ÄòB‚Äô‚Äù
02:25:35 <merijn> I'm guessing the existential boilerplate gets in the way
02:27:38 <kritzefitz> That would be my guess too, but it seems unnecessary, because AFAIK the existential type doesn't have any class information associated with it and thus doesn't need a class dictionary or anything.
02:28:53 <Lycurgus> does anyone have any idea why "CIPD" would be mentioned in an alternation with "dev ops" ('CIPD or dev ops')?
02:29:22 <merijn> I have no idea what CIPD even is?
02:29:30 <Lycurgus> me neither 
02:29:38 <Lycurgus> the only thing that comes up is
02:30:00 <Lycurgus> https://en.wikipedia.org/wiki/Chartered_Institute_of_Personnel_and_Development
02:30:01 <nyc> An HR certification organization?
02:30:20 <Lycurgus> but the alternation is used in technical pitch by ansible on their shit
02:30:37 <merijn> Lycurgus: I'm guessing CI is continuous integration
02:30:43 <merijn> But who knows what the PD is
02:31:02 <Lycurgus> that's what I thought bue what about the "PD"?
02:31:20 <opqdonut> Lycurgus: CICD is a common acronym
02:31:26 <opqdonut> where CD is continuous deployment
02:31:42 <Lycurgus> ah, OK that works
02:31:46 <opqdonut> so maybe it's a typo, or PD is some deployment I haven't heard of
02:32:07 <opqdonut> continuous integration, perpetual deployment?-)
02:32:17 <Lycurgus> no it's that even with quite clear english, slowed down it's hard to distinguish the two
02:32:35 <opqdonut> probabilistic deployment?-)
02:32:41 <Lycurgus> https://www.ansible.com/resources/videos/quick-start-video 10:55 
02:33:01 <Lycurgus> it's surely CICD, ty opqdonut 
02:33:42 <Lycurgus> and neither google or ddg were doing enough soundex or whatever
02:34:54 <dminuoso> kritzefitz: It should have type information.
02:35:41 <dminuoso> kritzefitz: Consider a slightly more specialized case in which you have `data Q = forall a. Show a => Q a` - how would a function like `showIt :: Q -> String; showIt (Q a) = show a` work if there was no type equality proof rigged inside?
02:35:46 <Lycurgus> *but
02:37:15 <Lycurgus> and wiki says the D is development
02:39:27 <dminuoso> kritzefitz: Oh wait.. I think that makes no sense, ignore me.
02:45:05 <asheshambasta> So I'd like to somehow 'demote' my dataconstructor that has been promoted to a type-constructor: https://gist.github.com/asheshambasta/a1788637e36b8a08c9ca7477568d3f74
02:45:22 <asheshambasta> is there a way to do that, or am I missing something very obvious? (I feel like I am)
02:45:45 <merijn> asheshambasta: Can you do it? Yes. Is it super painful? Also yes.
02:45:56 <merijn> asheshambasta: Lookup the singletons package and the associated Hasochism paper
02:46:17 <asheshambasta> merijn: ouch, so basically, I was not missing something obvious :-) 
02:46:47 <merijn> asheshambasta: Correct :)
02:47:56 <lortabac> asheshambasta: short answer: make a "Demote" type class with an instance for each constructor
02:48:15 <asheshambasta> I think if its that painful, given the current time limitations I'm under, I'll stick to good old pattern matching at the value level
02:48:33 <asheshambasta> lortabac: ^ and that would be very similar to pattern matching at the value level, but instead at the type level
02:48:49 <asheshambasta> AFAICS, there's no real benefit to that, then. 
02:49:46 <lortabac> asheshambasta: it depends on whether you need to reuse that logic in other functions
02:51:45 <asheshambasta> I'm not sure I understand; basically, I'd want to be able to generate the "grouping key" of sorts based on the type of `MiscDataLabel`
02:52:01 <asheshambasta> and use that within a ToJSON instance, or a FromJSON instance 
02:54:47 <Lycurgus> *delivery (which is essentially deployment)
02:58:08 <opqdonut> Lycurgus: right yeah
03:08:35 <lortabac> asheshambasta: I mean, if you need to reuse the same groups for other types than MiscDataLabel, the Demote type class may make sense
03:09:17 <lortabac> asheshambasta: otherwise I would go for pattern-matching
03:19:05 <asheshambasta> lortabac: yeah, my use is going to be limited just for this type, I was just thinking if I could reflect this group at the type level and derive its data-constructor at the value level using something on the typelevel
03:29:57 * hackage failable 0.1.1.0 - A 'Failable' error monad class to unify failure across monads that can fail  http://hackage.haskell.org/package/failable-0.1.1.0 (erick)
03:32:34 <mightymosquito> exit
04:24:14 <gentauro> I would need some help with regard of Aeson (JSON father) and the parsing of a birthdate field (example: "06/24/1987") to data Birthdate = Birthdate Word16 Word8 Word8. Source code: https://pastebin.com/hhjTuxuZ Note: It looks horrible cos the usage of ' (prime) ... missing lpaste.net :'(
04:24:55 <gentauro> I would recommend that you copy/pasta the `raw` version and look at it locally :)
04:25:01 <merijn> gentauro: dpaste is better than pastebin, FYI
04:25:09 <dminuoso> Or perhaps gist from github
04:26:21 <gentauro> merijn: you are absolutely right -> http://dpaste.com/19SRE3S
04:26:21 <gentauro> :)
04:26:33 <dminuoso> gentauro: For ADTs this long, you might really want to use RecordWildCards just as a random tip.
04:27:23 <merijn> dminuoso: How would that help?
04:28:39 <dminuoso> merijn: Are you asking why RecordWildCards would be a sane language pragma to not fuck up the order of parsers?
04:28:45 <dminuoso> When you have 80 fields?
04:29:03 <merijn> dminuoso: How does RecordWildCards prevent you from messing up the order?
04:29:44 <dminuoso> merijn: Because you can do something like `... stamina <- x .: "stamina"; pure Item{..}`
04:30:00 <merijn> dminuoso: That doesn't stop you from writing the wrong order, though?
04:30:23 <dminuoso> merijn: It makes it independent of the order of fields in Item.
04:30:36 <dminuoso> merijn: Right now you have to *hope* you did the parsers in the exact same order as Item fields are specified.
04:30:52 <gentauro> dminuoso: does it match `stamina` or "stamina" with the function name in `Item`?
04:31:50 <gentauro> dminuoso: and I had a few issues where the `lastname` was the `firstname` cos I swapped the order in the parsing ...
04:32:01 <dminuoso> gentauro: Yes.
04:32:04 <gentauro> so yes, it would help if it actually do match the names
04:33:18 <dminuoso> gentauro: You have to name the variables exactly as the field names for it to work. The downside though is, with that construction style forgetting a field becomes a warning (whereas with the explicit style its a type error)
04:36:16 <dminuoso> merijn: With the extension you'd have to explicitly do `lastName <- x .: "firstName"; ...` to get the same effect. Ultimately the usefulness depends, tests should catch it if you have them.
04:36:22 <gentauro> dminuoso: I tried it out with the smaller `JSON` data type and it worked !!! Thx !!!
04:36:57 <dminuoso> gentauro: At any rate, it was orthogonal to your real problem
04:38:48 <gentauro> dminuoso: my problem was to parse a birthdate ("01/01/1970") to `data BD = BD Word16 Word8 Word8` (Year Month Day)
04:38:51 <gentauro> :)
04:39:04 <gentauro> but your tip helped a lot to maintain `sanity` :D
04:41:48 <dminuoso> gentauro: So the quickest way would be to just use `withText "birthdate" $ \x -> case parseBirthdate x of Right x -> pure x; Left err -> fail ("failed to parse: " <> err)` given some suitable `parseBirthdate :: Text -> Either String Birthdate`
04:42:22 <dminuoso> (So you just make use of the MonadFail instance of `Parser a`)
04:42:35 <dminuoso> Or *Parser* rather.
04:45:49 <gentauro> dminuoso: I tried the `withText` and `Data.Text.splitOn` but then complains when I apply the `read` on a `Text` field ...
04:46:19 <gentauro> I guess my issue is how do I go from `Text` to `Word` ...
04:46:26 <gentauro> without using `read` :-\
04:48:58 * hackage simple-log 0.9.11 - Simple log for Haskell  http://hackage.haskell.org/package/simple-log-0.9.11 (AlexandrRuchkin)
05:16:58 * hackage hsdev 0.3.3.0 - Haskell development library  http://hackage.haskell.org/package/hsdev-0.3.3.0 (AlexandrRuchkin)
05:22:30 <ghibe> hello everyone! could someone point me to an explanation of why this doesn't work ? https://rextester.com/LGCEO48577
05:27:05 <zincy> .
05:27:35 <zincy> Say you have two monadic actions with the following type sigs : Action :: Msg -> Model -> Effect Action Model
05:27:49 <zincy> Should I use Kleisli composition to compose them, and if so how?
05:31:37 <Lears> ghibe: Put the type signature and value declaration on separate lines, or put the type signature on the expression rather than the bound identifier. As for why, I couldn't really say.
05:32:18 <dminuoso> ghibe: Because you demand `a` to be polymorphic inside a context where it's actually monomorphic.
05:32:27 * hackage web3 0.8.3.1 - Ethereum API for Haskell  http://hackage.haskell.org/package/web3-0.8.3.1 (akru)
05:36:51 <ghibe> Lears: I don't think you can put on a different line, but putting it on the expression did work!
05:37:46 <Lears> You can, the syntax in let blocks is the same as in top level declarations.
05:37:59 <ghibe> but now that I think about it it's probably just cause the expression gets monomorphisised during the binding 
05:39:28 * hackage tintin 1.9.4 - A softer alternative to Haddock  http://hackage.haskell.org/package/tintin-1.9.4 (NickSeagull)
05:41:00 <ghibe> dminuoso: is there no way to have `a` polymorphic ?
05:44:46 <wz1000> does anyone know what happened to the zeno theorem prover?
05:44:52 <dminuoso> ghibe: Oh wait actually no I see it now.
05:45:28 * hackage tintin 1.9.5 - A softer alternative to Haddock  http://hackage.haskell.org/package/tintin-1.9.5 (NickSeagull)
05:45:31 <ghibe> simplified https://rextester.com/RZHA94484
05:45:49 <ghibe> I mean that's just extracting an expression into a variable
05:46:03 <dminuoso> % f :: forall n. Functor n => n Int = (1 :: Int)
05:46:03 <yahb> dminuoso: ; <interactive>:106:38: error:; * Couldn't match expected type `forall (n :: * -> *). Functor n => n Int' with actual type `Int'; * In the expression: (1 :: Int); In a pattern binding: f :: forall (n :: * -> *). Functor n => n Int = (1 :: Int)
05:46:36 <dminuoso> ghibe: Is it possible that you are accidentally using type signatures in pattern matching?
05:47:03 <dminuoso> % f :: forall n. Monad n => n Int = pure (1 :: Int)
05:47:03 <yahb> dminuoso: ; <interactive>:107:35: error:; * Couldn't match expected type `forall (n :: * -> *). Monad n => n Int' with actual type `f0 Int'; * In the expression: pure (1 :: Int); In a pattern binding: f :: forall (n :: * -> *). Monad n => n Int = pure (1 :: Int)
05:47:25 <dminuoso> ghibe: The reason I came up with this, is when I started this in a fresh GHCi shell, the first thing GHC complained about was:
05:47:33 <dminuoso>       Type signatures are only allowed in patterns with ScopedTypeVariables
05:47:51 <dminuoso> I mean the whole syntax looks weird.
05:48:10 <ghibe> this is the whole code https://rextester.com/FIDU92799
05:48:11 <CurryWurst> #clusterlabs
05:48:28 <ghibe> there's not pattern matching
05:48:53 <dminuoso> ghibe: `a` is formally an irrefutable pattern
05:49:41 <dminuoso> % (f :: Int) = 1
05:49:41 <yahb> dminuoso: 
05:51:03 <ghibe> https://prime.haskell.org/wiki/MonomorphicPatternBindings
05:51:13 <ghibe> it explicitly states: x     = e    -- NOT a pattern binding
05:52:49 <dminuoso> ghibe: Interesting, perhaps that is a clue to this.
05:53:02 <dminuoso> ghibe: What if the fact that adding a type signature (which you did) makes it a pattern binding?
05:53:54 <ghibe> how am I  supposed to tell ? :D
05:54:51 <cocreature> note that that wiki page documents a proposal for a future Haskell standard, not necessarily what GHC does today
06:01:33 <body> trying to install xmonad with cabal, but i'm getting this error someone have any ideea? http://ix.io/1yQN
06:03:16 <__monty__> body: Could you share the build log?
06:03:38 <body> __monty__: yes, could u help me figure out which will be ?
06:03:54 <dminuoso> ghibe: Okay your last code snippet is really interesting,.
06:03:59 <__monty__> /home/body/.cabal/logs/ghc-8.6.3/xmonad-0.15-EDtE3hF0kZLrgsp476An5.log
06:04:26 <body> __monty__: http://ix.io/1yQS
06:04:27 <ghibe> dminuoso: glad  you like it XD
06:04:33 <dminuoso> ghibe: But it fails for the same reasons it failed originally.
06:04:45 <dminuoso> ghibe: The return type is `IO Int`, but you are returning something polymorphic.
06:04:59 <dminuoso> Namely something of type `forall n. Monad' n => n Int`
06:05:41 <dminuoso> ghibe: And it cant unify this because no instance Monad' IO exists.
06:06:09 <ghibe> dminuoso: line 8 ?
06:06:20 <dminuoso> Oh.
06:07:54 <__monty__> body: Let's try v2-install instead to avoid conflicts with already installed packages. So cabal v2-install xmonad.
06:08:56 <dminuoso> > let a :: forall t. t; a = a; (g :: forall u. u) = a
06:08:59 <lambdabot>  <no location info>: error:
06:08:59 <lambdabot>      not an expression: ‚Äòlet a :: forall t. t; a = a; (g :: forall u. u) = a‚Äô
06:09:12 <dminuoso> > let a :: forall t. t; a = a; (g :: forall u. u) = a in ()
06:09:14 <lambdabot>  error:
06:09:14 <lambdabot>      ‚Ä¢ Cannot instantiate unification variable ‚Äòt0‚Äô
06:09:14 <lambdabot>        with a type involving foralls: forall u. u
06:09:28 <body> __monty__: okidoki trying now
06:09:48 <dminuoso> > let a :: forall t. Functor t => t (); a = a; (g :: forall u. Functor u => u ()) = a in ()
06:09:51 <lambdabot>  error:
06:09:51 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚Äòforall (u :: * -> *).
06:09:51 <lambdabot>                                      Functor u =>
06:09:58 <dminuoso> ghibe: ^- this is interesting.
06:10:04 <body> __monty__: then I'll install xmonad-contrib as well
06:10:38 <__monty__> body: If it worked, go ahead.
06:10:45 <body> __monty__: ok, xmonad installed completely
06:10:51 <body> __monty__: let's see contrib
06:11:37 <body> __monty__: where those files gonna be installed in different places?
06:11:42 <gentauro> dminuoso: I managed to make my birthdate parser for Aeson :-) http://dpaste.com/2MYV6FE
06:11:43 <body> or doesn't matter cuz it's creating simlinks
06:12:07 <dminuoso> ghibe: Is it possible that the second case has the same problem as the first, but with a significantly worse diagnostic?
06:13:59 <__monty__> body: It shouldn't matter, it's how the v2- commands work. It's possible v2-install is still rough though, I never really use cabal v1/v2-install.
06:17:25 <ghibe> dminuoso: It does feel like the same case - if that's what you were asking 
06:18:05 <dminuoso> ghibe: mm weird, then ImpredicativeTypes should fix it.
06:18:15 <dminuoso> ghibe: well this is really interesting either way =)
06:22:14 <ghibe> dminuoso: if {-# LANGUAGE ImpredicativeTypes #-} was supposed to fix it, it didn't
06:28:06 <ghibe> dminuoso: if you disable ScopedTypeVariables you get: Illegal type signature: ‚Äòforall n. Monad' n => n Int‚Äô       Perhaps you intended to use ScopedTypeVariables     In a pattern type-signature
06:28:23 <ghibe> so I guess it is treated as a pattern binding
06:28:39 <hyperisco> what's the awesome extension for vscode?
06:31:05 <Taneb> hyperisco: the only thing springing to mind is Haskell IDE Engine
06:31:37 <hyperisco> with the external dependency HIE
06:31:56 <hyperisco> well lets hope this isn't perpetually broken like unfortunately ghc-mod has been
06:32:10 <Taneb> Yes, let's hope
06:33:31 <hyperisco> honestly I don't know how to install things like HIE anymore
06:33:50 <__monty__> body: Did you get it to work? The problem was probably you'd somehow installed a dependency before and xmonad's version bounds claimed to be compatible with its version while it wasn't.
06:33:56 <hyperisco> is there a -g flag to stack or something to make it a global install
06:34:24 <body> __monty__: no, wait I'm trying to do something different
06:35:54 <ghibe> dminuoso: https://rextester.com/CJMV46170 here it gives a  pretty decent error message
06:36:51 <ghibe> Couldn't match expected type ‚Äòforall (n :: * -> *). Monad' n => n Int‚Äô with actual type ‚Äòm0 Int‚Äô
06:36:53 <ghibe> When checking that: m0 Int       is more polymorphic than: forall (n :: * -> *). Monad' n => n Int
06:37:27 <ghibe> but it doesn't say where did it come up with m0 and why it doesn't have a Monad' constraint
06:37:49 <dminuoso> ghibe: well `m0` is just an instantiated type variable
06:38:04 <dminuoso> ghibe: GHC generates these on its path to perfect unification.
06:40:04 <dminuoso> ghibe: https://ghc.haskell.org/trac/ghc/ticket/12587 SPJ gave some insights into what GHC might be doing at that particular moment.
06:41:11 <hyperisco> I am using Options Applicative to build a CLI tool. I have named all my subcommands, but when help info prints it prints "Usage: bison (COMMAND | COMMAND | COMMAND | COMMAND | COMMAND | COMMAND)"
06:41:16 <maerwald> 'hdevtools findsymbol sort' ... never finishes lol
06:41:30 <dminuoso> ghibe: I dont understand this much at all.
06:42:05 <hyperisco> That's the short help that prints when you get the command wrong
06:42:10 <hyperisco> the full --help shows the right thing
06:42:43 <dminuoso> ghibe: I think I can see some reasons why this shouldn't be working.
06:43:05 <hyperisco> Taneb, lol well that was short lived. Won't build.
06:43:07 <ghibe> dminuoso: ok, I'll try to fiddle with it a bit more and if I don't succeed I'll post it on SO. thanks a lot for your help!
06:43:32 <dminuoso> ghibe: You could also consider putting it on gitlab, or mailing to the haskell mailing list. :)
06:48:05 <maerwald> seems hdevtools is abandoned, hm
06:48:23 <dminuoso> > (f :: Floating f) = (undefined :: Floating g)
06:48:25 <lambdabot>  <hint>:1:19: error:
06:48:25 <lambdabot>      parse error on input ‚Äò=‚Äô
06:48:25 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
06:48:30 <dminuoso> > let (f :: Floating f) = (undefined :: Floating g) in ()
06:48:32 <lambdabot>  error:
06:48:32 <lambdabot>      ‚Ä¢ You cannot bind scoped type variable ‚Äòf‚Äô
06:48:32 <lambdabot>          in a pattern binding signature
06:48:59 <dminuoso> Err what?
06:49:14 <body> i'm using this config for xmonad but on recompile i'm getting this error, any ideea anyone ? https://github.com/bodyowns/dotfiles/blob/master/HOME/.xmonad/xmonad.hs, and error http://ix.io/1yRg
06:49:24 <dminuoso> Oh.
06:49:30 <body> __monty__: it worked differently , now I just need to fix a small thing ..
06:49:32 <dminuoso> > let (f :: Floating f => f) = (undefined :: Floating g => g) in ()
06:49:34 <lambdabot>  error:
06:49:34 <lambdabot>      ‚Ä¢ Illegal qualified type: Floating f => f
06:49:34 <lambdabot>        GHC doesn't yet support impredicative polymorphism
06:50:00 <dminuoso> > let (f :: Functor f => f ()) = (undefined :: Functor f => f ()) in ()
06:50:02 <lambdabot>  error:
06:50:03 <lambdabot>      ‚Ä¢ You cannot bind scoped type variable ‚Äòf‚Äô
06:50:03 <lambdabot>          in a pattern binding signature
06:52:05 * hyperisco laughs
06:52:13 <hyperisco> I think Haskell tooling is cursed
06:52:49 <__monty__> body: Try adding `import XMonad.Actions.Minimize` to the top.
06:52:50 <dminuoso> ghibe: This is curious, adding the `forall` quantifier somehow changes the diagnostics.
06:53:08 <dminuoso> ghibe: Whatever we are tapping into, I feel like there's a missing diagnostic.
06:53:40 <hyperisco> apparently even if I could get HIE to build on Windows it is broken on Windows anyhow
06:53:43 <dminuoso> ghibe: https://gist.github.com/dminuoso/21a7db758a9ce709f60a60857e38f16a
06:54:06 <body> __monty__: worked, not just one error
06:54:26 <dminuoso> ghibe: I mean the second error remains the same, but withbout `forall` you get an additional error which I find surprising.
06:54:31 <dminuoso> ghibe: Though.. that part could give a hint.
06:55:13 <body> __monty__: http://ix.io/1yRn this left
06:58:48 <__monty__> body: Hmm, seems like you have the required import XMonad.Layout.Minimize, maybe there's an #xmonad channel where you can get better help?
06:59:41 <body> __monty__: https://hackage.haskell.org/package/xmonad-contrib-0.14/docs/XMonad-Actions-Minimize.html
06:59:45 <body> have to figure out now
07:02:18 <body> __monty__: lol closed irc by mistakke
07:02:46 <__monty__> body: Found the problem. The constructor RestoreNextMinimizedWin *did exist* in xmonad-contrib 0.11 but in recent versions it doesn't.
07:03:34 <body> __monty__: so hmmm, how could I reproduce that :\\
07:03:55 <c_wraith> hopefully it was replaced with something else that does the same thing
07:04:25 <kritzefitz> body: I guess you want `withLastMinimized maximizeWindow` instead of `sendMessage RestoreNextMinimizedWin`
07:05:08 <kritzefitz> Ah, wait. I got ‚Äúnext‚Äù and ‚Äúlast‚Äù confused.
07:07:08 <body> ok waiting xD
07:07:56 <kritzefitz> body: Apparently I also got ‚Äúwait‚Äù and ‚Äúsorry‚Äù confused.
07:08:00 <kritzefitz> Sorry.
07:08:22 <body> kritzefitz: now I got confused, lol
07:08:28 <body> u found something?
07:09:25 <kritzefitz> My guess would be that either `withLastMinimized maximizeWindow` or `withFirstMinimized maximizeWindow` does what you want.
07:10:49 <body> kritzefitz: let me try it :)
07:10:50 <kritzefitz> Though I'm not sure what ‚Äúfirst‚Äú, ‚Äúlast‚Äù and ‚Äúnext‚Äù exactly mean in this context, especially because I don't use minimized windows myself. I would suggest you just try both and see which does what you want.
07:12:04 <body> kritzefitz: not it compiled with with last
07:12:18 <body> let me see if works
07:14:28 <body> kritzefitz: deffo will loose conn on weechat, we'll be back in a sec
07:20:32 <body> kritzefitz: it worked ! <3 thanks, __monty__ thank you too !!! thanks for the support
07:21:24 <__monty__> body: üëç
07:30:02 <body> __monty__: https://i.imgur.com/RJuulXY.png hehe
07:34:02 <dmwit> The URL says png, but the artifacts say jpg
07:34:45 <body> dmwit: looks bad isn't it ?
07:35:15 <__monty__> Artifacts? I figured the background was just a composition of differing resolution images.
07:37:05 <body> a bit better quality https://ibb.co/3sHVtsB
07:42:12 <hyperisco> I figured out my mistake
07:42:28 <hyperisco> I am supposed to use the command monoid, rather than disjoining subparsers
07:42:54 <g-erson> Hey, when I use the Proxy constructor, why do I have to prefix '@' to my data constructor? What does it mean? 
07:43:23 <dminuoso> g-erson: TypeApplications turn Proxy ad absurdum.
07:43:34 <hpc> it's a way of specifying type variables without a whole annoying type signature
07:43:36 <dminuoso> g-erson: Though I use them in combination because it saves myself a few characters when Im forced to use Proxy
07:43:36 <hpc> :t id @Int
07:43:37 <lambdabot> error:
07:43:38 <lambdabot>     Pattern syntax in expression context: id@Int
07:43:38 <lambdabot>     Did you mean to enable TypeApplications?
07:43:40 <hpc> % :t id @Int
07:43:40 <yahb> hpc: Int -> Int
07:43:49 <dminuoso> g-erson: TypeApplications are the modern solution to the Proxy pattern.
07:44:26 <g-erson> Ah okay, so the answer is read about TypeApplications ahah
07:44:28 <g-erson> thanks :)
07:44:30 <dminuoso> g-erson: `f (Proxy :: Proxy Int)` is semantically equivalent to say `f @Int` - the reason for the former is that the latter hasnt always been there. :)
07:45:01 <dminuoso> g-erson: So when you are forced to use `Proxy` you could instead of `f (Proxy :: Proxy Int)` also do `f (Proxy @Int)` giving you a slightly shorter version.
07:46:16 <g-erson> Oh I see, so it's kind of just a shorthand to save you writing out the type signature? 
07:47:05 <dminuoso> g-erson: Well you asked why you had to prefix "data constructors" (this is wrong, these are type constructors!) with @ for Proxy.
07:47:53 <dminuoso> g-erson: You don't, the traditional way to use Proxy is by `f (Proxy :: Proxy Int)`
07:49:08 <g-erson> ah okay, thankyou :)
07:49:55 <dminuoso> g-erson: So using TypeApplications together with Proxy is probably very confusing (the only reason for doing this is saving yourself a few characters). :)
07:58:03 <ghibe> dminuoso: I created the SO qst. https://stackoverflow.com/questions/54293485/ghc-fails-to-bind-polymorphic-function-without-monomorphising-it
08:02:05 <quicksilver> "I'm just extracting an expression into a binding which is one of the basic things that haskell claims should be always possible"
08:02:12 <quicksilver> it really isn't :(
08:02:32 <quicksilver> it's a thing which has always been impossible in haskell - due to various different kinds of polymorphism
08:02:54 <quicksilver> what your question amounts to is "is this supposed to still be impossible with RankNTypes?"
08:03:00 <quicksilver> I don't know the answer, though
08:03:38 <dminuoso>  let a :: forall n . Monad' n => n Int = g @n
08:03:46 <dminuoso> Wow, Im trying to wrap my head around what that even means.
08:04:01 <dminuoso> Or.. is supposed to mean rather.
08:08:06 <wroathe> So with functional dependencies... It's just a way of enforcing that there can only be at most one instance that satisfies the relationship on the right hand side of |?
08:08:18 <wroathe> class Foo a b | a -> b where
08:08:58 <wroathe> So for a unary typeclass like this there can only be one "b" for any given "a"?
08:09:23 <dminuoso> wroathe: correct.
08:09:34 <wroathe> And without a -> b, it would be valid, but illogical, to specify Int -> Char, Int -> Bool, Int -> Float, and so on...
08:09:44 <dminuoso> wroathe: It allows GHC to then infer that, if `b` has been inferred, to infer `a` from that fact.
08:09:54 <dminuoso> Bad sentence structure there. Bah.
08:10:09 <dminuoso> wroathe: Whether it's "illogical" depends on your problem domain.
08:11:25 <wroathe> So when would your problem domain require you to have ambiguous instances?
08:11:55 <dminuoso> wroathe: If you use the word "ambiguous" your domain already has the notion of functional dependency linked in.
08:12:21 <Lears> ghibe: I still don't know why you're trying to put the sigs and values on the same line. Is there some extra significance to that I'm missing? Your minimal example compiles just fine like this: https://gist.github.com/LSLeary/3de3800a149404cec22c1c5ab4c02307
08:13:01 <wroathe> dminuoso: Well, can you think of a practical use case for not requiring functional dependencies?
08:13:15 <wroathe> dminuoso: Admittedly my imagination is failing me here
08:15:10 <wroathe> As of right now it just seems like, "Aren't multi-parameter typeclasses cool!?!? Wait, how do we infer types when we've got conflicting instances... Shoot. We'll need syntax for that too."
08:16:05 <ghibe> Lears: I didn't understand properly how to add the type signatures - the code clarified it. thanks - but that's even weirder then right ?
08:16:59 <wroathe> Oh, I suppose it would be useful iff you want the end user of your routine to HAVE to explicitly specify the type...
08:17:18 <wroathe> i.e., you've got N candidate instances, pick one
08:17:53 <Lears> ghc probably just uses/checks pattern signatures differently from regular declaration signatures, maybe #ghc can tell you why that is.
08:21:48 <Lears> My best guess is that pattern sigs generate equality constraints visible in the scope of the match, but the machinery for dealing with decl sigs doesn't see that.
08:24:32 <kritzefitz> wroathe: I'm not sure I understand your question correctly. Whenever you have a class like `class Foo a b where frobnicate :: a -> b -> Bar` you can choose the instance to use for a call like `frobnicate x y` just by looking of the types of `x` and `y` without having to specify types explicitly.
08:25:14 <wroathe> What if frobnicate is a -> b -> b?
08:25:39 <wroathe> and you've got instance Foo Bool Char, and instance Foo Bool Float?
08:26:03 <kritzefitz> Do you mean frobnicate :: a -> b -> c?
08:26:33 <merijn> wroathe: That's unambiguous, though
08:26:42 <merijn> wroathe: The 2nd argument is either Float or Char
08:26:46 <merijn> wroathe: Can't be both
08:27:21 <kritzefitz> Ah, now I see why you meant a -> b -> b.
08:28:56 <wroathe> Hmm, I suppose for binary functions...
08:29:05 <wroathe> What if frobnicate is just a -> b?
08:29:19 <wroathe> and you say: frobnicate True
08:29:29 <wroathe> At that point you've got ambiguity, right?
08:29:58 <merijn> wroathe: Still trivially solved by inference on the result
08:30:08 <kritzefitz> I think it gets ambiguous when one of the instance types is part of the result of your function and GHC can't infer the returns type of the function from elsewhere.
08:30:17 <merijn> wroathe: That's not anymore ambiguous than:
08:30:18 <merijn> :t read
08:30:19 <lambdabot> Read a => String -> a
08:31:11 <wroathe> merijn: Yeah, but that's my point. Functional dependencies seems to be a way to tell the compiler that there can only be one b for a given a
08:31:24 <wroathe> To avoid that ambiguity
08:31:41 <wroathe> I'm just verifying my understanding
08:34:52 <kritzefitz> wroathe: I think that's basically correct.
08:35:22 <kritzefitz> Though there can be more than one type of each side of the dependency, e.g. `a b -> d e f`.
08:35:58 <wroathe> kritzefitz: Sigh. Haskell is the Billy Mays of languages.
08:36:31 <kritzefitz> I think that means that for each combination of (a, b) there can be only one combination (d, e, f).
08:38:22 <kritzefitz> But my experience with MultiParamTypeClasses and FunctionalDependencies is kinda limited. When I think about using them I pretty much always end up using TypeFamilies instead.
08:41:47 <wroathe> From the literature on some of this stuff, the way they throw around the word ambiguity is that it's some sort of flaw or wart in a design 
08:42:18 <wroathe> I'm starting to think that, used wilfully, it's more of a feature
08:43:00 <wroathe> Basically allowing overloading
08:49:15 <kritzefitz> I think maybe ambiguous is not the right word for this kind of thing? Normally I would call most of we things we talked about polymorphic. GHC only calls things ambiguous when it can't figure out their type and in that case you actually have a problem.
08:53:27 * hackage mpi-hs 0.5.1.1 - MPI bindings for Haskell  http://hackage.haskell.org/package/mpi-hs-0.5.1.1 (eschnett)
09:01:58 * hackage require 0.4.2 - Scrap your qualified import clutter  http://hackage.haskell.org/package/require-0.4.2 (NickSeagull)
09:06:08 <gentauro> what's the best way to perform the following (concurrent) computation: [ f_1, f_2, .., f_n ] (each f_i will retrieve some data from a website)
09:06:34 <gentauro> map or mapM_ ... forkIO / forkFinally?
09:06:35 <boj> gentauro: look into the async library
09:06:50 <wroathe> async++
09:07:53 <gentauro> [ async . f_1, async . f_2, .., async . f_n ]?
09:07:57 <gentauro> https://hackage.haskell.org/package/async-2.2.1/docs/Control-Concurrent-Async.html#v:async
09:08:28 <gentauro> or just `map async [ f_1, f_2, .., f_n ]?
09:08:33 <wroathe> mapConcurrently
09:08:43 <wroathe> if you want waitAll semantics
09:09:09 <gentauro> wroathe: yeah, i need all data to return before `reducing`
09:56:08 <dminuoso> @tell wroathe Here is an example of MPTC that doesn't need functional dependencies: `class Convertable a b where convert :: a -> b` which captures the idea of being able to convert from type `a` to type `b`.
09:56:08 <lambdabot> Consider it noted.
10:40:28 * hackage pretty-types 0.3.0.1 - A small pretty printing DSL for complex types.  http://hackage.haskell.org/package/pretty-types-0.3.0.1 (SvenHeyll)
10:47:20 <nvt> in the tutorial there is this signature: compareWithHundred :: (Num a, Ord a) => a -> Ordering - what does that part before => mean, I mean another example had only a -> a -> a-> without any =>
10:48:18 <hpc> those are type class constraints
10:48:21 <marvin2> nvt it is a type constraint. a must be a type that has both Num and Ord instance
10:48:31 <hpc> whatever the type 'a' is, it has to have those instances
10:48:37 <hpc> Num gives you (+) and such
10:48:41 <hpc> Ord gives you (<=) and such
10:52:28 * hackage type-spec 0.4.0.0 - Type Level Specification by Example  http://hackage.haskell.org/package/type-spec-0.4.0.0 (SvenHeyll)
10:55:01 <dminuoso> nvt: The type signature could be read aloud like this: for every choice of some type `a`, where `a` has both an instance Num and Ord, compareWithHundred has type `a -> Ordering`
11:02:21 <nvt> ok, thanks
11:03:20 <dminuoso> nvt: Could you pick `Bool` for that type variable `a`?
11:03:37 <dminuoso> Hint, you can use `:info Bool` in GHCi to tell you about the instances (it knows about)
11:08:45 <absence> i'm toying around with RankNTypes without really understanding what i'm doing :D say i have type Test = forall s. State s, and a function of type Test a -> a. i obviously can't call evalState on it, because i don't have an s, but even if i leave that detail aside and pass undefined, i get a type error "can't match 'forall s. State s' with 'State s'"
11:09:23 <occulti> I'm new here. I just want to use some of your advice. Actually I'm going through a learning experience (though I work as a software engineer), and my goal is to learn functional programming, but not just from a programmer's perspective. I want to learn what lays behind. To do that, I started now with Logic (Sentential Logic, Predicate Logic FOL, etc).  I'm just trying to figure out if the path I outlined is good, or if it requires o
11:09:36 <absence> it vaguely makes sense, but i'm not quite sure how to work with such values
11:09:53 <occulti> Here are the next topics I intend to tackle: - Lambda Calculus - Type Theory, Category Theory, Homotopy type theory  Is it OK? Does it seems coherent? Consistent? Enough? Any other topics I may have missed/excluded?
11:10:32 <c_wraith> absence: you're sort of stuck.  You're trying to do the opposite of the runST trick.  Which doesn't work.  If it did work, runST wouldn't.
11:11:13 <c_wraith> absence: whoops, nevermind.  misread
11:11:26 <cocreature> if you really have a "Test a" i.e. a "forall s. State s a" you can certainly call evalState on it
11:11:32 <cocreature> you can choose "s"
11:11:43 <c_wraith> absence: have you tried writing your types without type aliases?  Those really make it harder to understand what's going on with RankNTypes
11:11:58 <cocreature> such a value just doesn‚Äôt tend to be particularly useful since if it has to work for all state types it can‚Äôt do anything useful with the state
11:12:11 <cocreature> so you can just drop the whole State and get something equivalent
11:12:53 <absence> then why doesn't it typecheck when i pass undefined as the state value? maybe it's the type alias thing c_wraith suggests, i'll try without
11:13:44 <cocreature> it doesn‚Äôt typecheck because it needs to use some fixed state type
11:13:54 <cocreature> if you pass (undefined :: ()) it should work
11:14:06 <cocreature> (but then why are you using undefined, just use () directly :))
11:14:07 <zachk> occulti, just install the haskell platform and play around with ghci, the interpreter for ghc, it will get you onboard faster then that long path you have set out for you, good luck on it though :)
11:14:09 <c_wraith> absence: also, beware of using combinators like ($) or (.)
11:16:08 <absence> cocreature: if i pass (), it says can't match forall s. State s with State ()
11:16:38 <cocreature> absence: I think at this point, you‚Äôll have to show us the actual code you‚Äôre using
11:17:29 <absence> cocreature: it does work without the type alias like c_wraith suggested though...
11:20:19 <c_wraith> that means the aliases probably lead to a different type than you though
11:20:22 <c_wraith> *thought
11:21:37 <absence> cocreature: https://pastebin.com/fUmU5qWd
11:22:17 <absence> c_wraith: yeah, those parenthesis in test1's type look different
11:23:38 <cocreature> hm, I‚Äôm not actually sure what type (forall s. State s) a is
11:24:04 <cocreature> one more reason to dislike type synonyms I guess :)
11:25:21 <absence> can i somehow expand test2's type in ghci to see what it becomes? i imagined "(forall s. State s) a" as well, but if i use that type for test1, ghc complains about impredicative polymorphism not being supported, so i guess the type synonym expands to something else
11:25:24 <nshepperd1> Isn't that the same as forall s. State s a
11:25:39 <cocreature> nshepperd1: as that snippet demonstrates, GHC disagrees :)
11:26:24 <nshepperd1> Fascinating
11:27:57 <c_wraith> It can't help that State is also a type synonym
11:28:10 <nshepperd1> I don't see what else it could be. Except maybe 'State a'
11:29:53 <absence> https://pastebin.com/0u4qrxVh <- seems syntax highlighting goofed up, but anyway test1' shows what i was trying to say
11:29:58 <cocreature> if it was State a then it seems like "(forall s. State s) () a" should work but that returns a kind error
11:31:01 <absence> so the type synonym isn't equivalent with either of the types in test1 and test1'
11:31:52 <cocreature> which version of GHC are you using? for me (forall s. State s) a seems to be equivalent
11:31:59 <cocreature> I don‚Äôt get any error mentioning impredicate polymorphism
11:32:22 <absence> 8.4.4
11:33:05 <cocreature> interesting, seems to have changed in 8.6
11:33:52 <cocreature> quantifiers within types (or whatever you want to call this) seem to behave very weirdly. it never even occured to me to try this up until now :)
11:35:25 <absence> cocreature: so the type alias should be equivalent to "(forall s. State s) a"? maybe bug in ghc 8.4 then?
11:35:39 <cocreature> at least that‚Äôs my understanding
11:38:15 <absence> cool, i'll try 8.6 then. thanks!
11:40:34 <nshepperd1> Normally you'd just write Test a = forall s. State s a, since that's the only useful thing you can do with it (unless you enable impredicative types)
11:42:58 <absence> nshepperd1: hmm, is there a subtle difference in meaning between the two? maybe that's why it's complaining
11:44:18 <dminuoso> % type Test = forall s. State s
11:44:19 <yahb> dminuoso: 
11:44:22 <dminuoso> % :k Test
11:44:22 <yahb> dminuoso: Test :: * -> *
11:48:05 <absence> looks normal?
11:48:12 <zachk> % :t State
11:48:13 <yahb> zachk: ; <interactive>:1:1: error:; * Data constructor not in scope: State; * Perhaps you meant one of these: `StateT' (imported from Control.Monad.State), variable `state' (imported from Control.Monad.RWS)
11:48:26 <zachk> % :t StateT
11:48:26 <yahb> zachk: (s -> m (a, s)) -> StateT s m a
11:48:34 <dminuoso> Yeah why doesn't `:t` work on type synonyms?
11:48:45 <dminuoso> Oh wait. Im bad at this.
11:48:57 <absence> because they're not type constructors i think
11:49:05 <zachk> hmm not what I was looking for or is it, that goes over an Identity functor/monad somehow to create the State type alias correct?
11:49:26 <glguy> :t works on expressions, type synonyms aren't expressions
11:49:27 <lambdabot> error: parse error on input ‚Äò,‚Äô
11:49:41 <dminuoso> glguy: Yeah, my brain is damaged.
11:51:26 <cocreature> obviously :t should just return the kind when called on types :)
11:52:28 <nshepperd1> The main difference between type Test1 a = State () a and Test2 = State () is that you can write MaybeT Test2 but not MaybeT Test1
11:53:01 <nshepperd1> With the forall s, you can't write either, because that's impredicative
11:54:15 <dminuoso> cocreature: I keep falling into the trap expecting `:t` to just go up one universe and tell me something about it. And everytime I keep remembering that there's no lexical way to disambiguate identifiers from universes..
11:55:26 <cocreature> dminuoso: the closer we move towards dependent types, the more the disjunct namespaces seem like mistake
11:55:32 <cocreature> *a mistake
11:55:36 <absence> nshepperd1: adding the a parameter to the type alias fixes the problem
11:58:17 <absence> i.e. "type Test a = forall s. State s a" is required instead of "type Test = forall s. State s", for both 8.4 and 8.6
11:59:27 <zachk> i was wondering if it was the monomorphism restriction kicking in , now it sounds like it
11:59:49 <dminuoso> zachk: Where would it be kicking in?
12:00:13 <zachk> not sure, is there a link to absence's code somewhere? 
12:00:22 <nshepperd1> MR only applies to inferred types of values
12:00:36 <absence> nshepperd1: ahh, does "type Test = forall s. State s" actually mean "type Test a = (forall s. State s) a"?
12:00:38 <dminuoso> zachk: Its neither MR nor type defaulting here, it's something... different.
12:00:56 <zachk> oh, don't know that much about the MR really
12:01:12 <zachk> I have had code I couldn't get polymorphic enough no matter what I did to it 
12:01:13 <dminuoso> Question: What does `(forall s. State s) a` even mean? Im not well versed on impredicativity, so ...
12:01:37 <dminuoso> I mean the explicit way would be to state: `forall a. (forall s. State s) a`
12:02:33 <absence> nshepperd1: it seems like it, as it produces the same error messages in 8.6 (8.4 complains about impredicative polymorphism in one case and not the other, but it could be a bug)
12:03:23 <nshepperd1> absence: they're eta-equivalent
12:03:36 <nshepperd1> So yes, in this case they're equivalent
12:04:38 <nshepperd1> The only difference I'm aware of is that you can't instantiate a type variable with a partially applied type synonym
12:07:29 <absence> nshepperd1: thanks, this is getting clearer by the minute :)
12:09:17 <nshepperd1> dminuoso: i guess it depends whether you think you ought to be able to unify it with f b to get f ~ (forall s. State s); b ~ a
12:09:32 <nshepperd1> If so, it would be impredicative
12:10:49 <nshepperd1> It seems unclear what ghc thinks
12:12:58 <jzeus> man haskell is driving me insane
12:13:14 <jzeus> i cant do the simplest things
12:13:39 <edmundnoble> What do you want to do?
12:14:28 * hackage typograffiti 0.1.0.1 - Just let me draw nice text already  http://hackage.haskell.org/package/typograffiti-0.1.0.1 (SchellScivally)
12:17:11 <boj> i have a (orphan) instance in module A, and another in module B which imports A and uses a function from it. i am getting "Variable not in scope" error, and am not sure why
12:17:38 <jzeus> edmundnoble: read from stdin line by line, parse into list of integers
12:17:56 <dminuoso> jzeus: How do you want the reading to terminate?
12:19:42 <jzeus> EOF
12:19:54 <suzu> jzeus how are you approaching the problem right now?
12:20:09 <jzeus> rn im stuck at just printing a value from a list of strings
12:20:14 <dminuoso> jzeus: You might be interested in this utility function (it's absolutely amazing for writing small programs with)
12:20:16 <dminuoso> :t interact
12:20:18 <lambdabot> (String -> String) -> IO ()
12:20:35 <suzu> and also this
12:20:37 <suzu> :t lines
12:20:38 <lambdabot> String -> [String]
12:20:58 <jzeus> i do `a = words <$> getLine`, but when i try `print a[0]` i get an error
12:21:00 <marvin2> jzeus, what if string can't be parsed as an int?
12:21:28 <absence> jzeus: that's not the syntax for indexing a list
12:21:31 <suzu> are you literally writing a[0]
12:21:34 <absence> jzeus: also, a isn't a list
12:22:22 <marvin2> also, in a = words <$> getLine, type of a is IO [String], not [String]
12:22:56 <boj> ah, you have to explicitly export the typeclass functions
12:23:47 <jzeus> im sorry guys i dont deserve your help, still thinking in c++, needed `!!` operator
12:25:37 <freedan42x> has someone completed this kata: codewars.com/kata/odd-plus-even-equals-odd-prove-it/train/haskell? I need help
12:25:49 <absence> jzeus: note that in non-toy programs, it's worth considering what happens if the list is empty :)
12:27:06 <jzeus> right, im just writing a solution to a gcj problem rn
12:38:53 <absence> sooo, i guess with type Test a = .... i can't Compose it with anything because partial application of type synonyms isn't allowed?
12:39:21 <merijn> absence: If you can somehow lob off the 'a' argument it'd work
12:39:48 <dminuoso> merijn: Not possible because of how the quantifiers appear. 
12:40:44 <nshepperd1> absence: You can't compose it with anything anyway, because of the quantifiers
12:40:48 <dminuoso> merijn: Essentially the issue is that `type Test = forall s. State s` applied to some type variable behaves like: `(forall s. State s) a`
12:40:55 <dminuoso> (Which is what the subject is about)
12:41:25 <nshepperd1> If you want to, you'll have to make it a newtype
12:42:26 <xsperry> jzeus, not sure what you're doing with those numbers, but I thought this golf was neat looking..  main = print . sum . map read . words =<< getContents
12:42:51 <xsperry> safer:  main = print . sum . catMaybes . map readMaybe . words =<< getContents
12:43:33 <v0d1ch> dminuoso: can you tell me how this looks to you https://gist.github.com/v0d1ch/9eebe587109521238fef06fd8068f9fc , I probably don't really understand wery well the actual thing I am trying to see at the end
12:44:25 <absence> newtype it is, then. thanks again!
12:46:07 <dminuoso> v0d1ch: Heh still a bit off.
12:46:14 <dminuoso> v0d1ch: Though you are close.
12:46:47 <dminuoso> v0d1ch: Let me give you a small hint that might, hopefully, help. Rename `f` to `step` and `l` to `seed/start`
12:48:58 <dminuoso> v0d1ch: (Your only mistake is that unnecessary case statement, you can get rid of it entirely)
12:50:34 <dminuoso> (The *decision* process on how to deal with empty or non-empty lists is already built into cpsTail)
12:55:58 * hackage typerep-map 0.3.1 - Efficient implementation of a dependent map with types as keys  http://hackage.haskell.org/package/typerep-map-0.3.1 (shersh)
13:00:08 <ibloom> Is there a significant performance increase to using Data.IntMap versus Data.Map with a newtype (Int) key?
13:00:47 <ibloom> (strict versions of both)
13:03:07 <merijn> ibloom: IntMap is substantially faster with Int keys, yes
13:03:35 <merijn> ibloom: Map uses a balanced tree, IntMap uses a Patricia tree
13:04:15 <ibloom> Ah, so completely different algorithm
13:04:19 <ibloom> Good to know.
13:05:08 <ibloom> Too bad it kind of screws up the types in my program.
13:05:13 <merijn> ibloom: The worst-case complexity for IntMap is "O(min(n,W))" where 'n' is the number of elements, and W is the number of bits in Int
13:05:26 <merijn> ibloom: If it's just a newtype you can use coerce to convert before inserting
13:05:51 <NoidedSuper> ibloom: you could just make a little wrapper around IntMap that constantly wraps and unwraps your newtype as needed 
13:05:55 <NoidedSuper> Or coerces it, rather
13:06:44 <kadoban> One probably already exists. I seem to recall one existed for Enums at least
13:06:45 <ibloom> Yeah I can do that. Sigh ‚Ä¶. :)
13:06:48 <zachk> jzeus, mapM_ could be your friend here, I use it quite a bit when I need IO actions over a list 
13:08:23 <geekosaur> http://hackage.haskell.org/package/EnumMap
13:09:03 <geekosaur> (note that it's actually a rework of IntMap, not merely a wrapper)
13:10:07 <ibloom> Also out of curiousity: How is Data.Set implemented?
13:10:34 <[exa]> ibloom: afaik it's either finger tree or normal rbtree-zipper
13:11:24 <geekosaur> it's the same as Data.Map (and correspondingly for IntSet) per docs
13:11:39 <[exa]> oh, size-balanced trees, wow
13:12:25 <__monty__> Hmm, why did we both think it was fingertrees?
13:13:01 <ibloom> [exa]: thanks
13:13:54 <[exa]> __monty__: fingertrees are in Sequence, I guess they could work here as well
13:14:29 <[exa]> btw there they are marked by subtree size
13:15:35 <energizer> Is there a technical term for the combiner function that's the first argument to `fold`?
13:16:01 <[exa]> anyway, size-balanced trees have pretty nice k-smallest element lookup, maybe they use it somewhere
13:16:20 <[exa]> energizer: folder sounds too much filesystem-ish, right? :]
13:18:03 <energizer> it's not obvious to me whether the "folder" would be `(+)` or  `fold (+)`
13:19:53 <[exa]> energizer: I remember having heard a name similar to 'reducer', but that also doesn't quite fit
13:20:04 <zachk> does modern ghc run on mips architecture at all?
13:20:18 <Clint> barely
13:22:20 <hodapp> wait, GHC *ever* ran on MIPS?
13:23:25 * [exa] sees debian has ghc mips package?
13:24:58 <[exa]> (zachk: just out of curiosity, what kind of mips system do you have?)
13:25:59 <zachk> don't atm, just looking into longsoon laptops a bit 
13:26:05 <zachk> heard RMS had one 
13:26:17 <[exa]> mips laptops?!
13:26:26 * [exa] spending money soon
13:26:30 <zachk> didn't have much luck on getting all my code to actually work using ubuntu via userland app on android/arm 
13:26:56 <geekosaur> anciently there was even an alpha port, iirc. incomplete
13:28:58 <zachk> ghci and ghc with cabal compiled mine of my program suites just fine on userland app on android/arm, couldn't bind to a network port it seems, but my scotty webserver was semifunctional on serving pages, not sure if the websockets were working cause the sepearate backened to my webserver wasnt running
13:29:17 <zachk> ...one of my program suites...
13:31:37 <v0d1ch> dminuoso: ha! I knew it, I don't think I understood what kind of "problem" I need to solve in the first place
13:31:43 <v0d1ch> I'll give it another go
13:33:03 <geekosaur> on android I'd check if you need to do something special at OS / permissions level for non-web ports
13:33:33 <zachk> the userland app binds ssh to 2022 no problem, accesible via wifi lan just fine 
13:34:02 <zachk> I don't really know the ins and outs of android really good atm, just got another device that is android to tinker with , at least ghci works on it now :)
13:37:06 <v0d1ch> dminuoso: ```cpsLoop :: (forall o. [a] -> o -> ([a] -> o) -> o) -> [a] -> [a]
13:37:07 <v0d1ch> cpsLoop f l = f l l id```
13:37:12 <v0d1ch> that should be it
13:37:25 <dminuoso> v0d1ch: That's the non-looping implementation. It doesn't actually loop.
13:37:38 <dminuoso> v0d1ch: But it's a good one regardless because it uses the stepper right.
13:38:20 <v0d1ch> ü§¶
13:38:50 <dminuoso> v0d1ch: think about how `f` is to be used.
13:39:06 <dminuoso> v0d1ch: what is the third argument to `f`?
13:41:20 <v0d1ch> a function `([a] -> o)`
13:41:53 <dminuoso> v0d1ch: That function is the "action for how to proceed with the (modified) list"
13:44:36 <dminuoso> `id` is the "do nothing and finish" action here.
13:45:42 <dminuoso> So your implementation uses `cpsTail` which chops off the tail off the list and runs your action with it. Since you are using `id`, it stops and finishes. So if you did `cpsLoop cpsTail [1..100]` you'd get [2..100] as the result.
13:47:27 <v0d1ch> yeah
13:47:46 <Yuon> Is there a way to have a type constructor of kind (*->*) -> * ? Is it any different than the kind *->*->* ?
13:48:03 <hyperisco> Yuon, yes and yes
13:48:14 <dminuoso> :k StateT
13:48:14 <glguy> and it doesn't even have to be a constructor
13:48:15 <lambdabot> * -> (* -> *) -> * -> *
13:48:33 <dminuoso> :k MaybeT
13:48:34 <lambdabot> error:
13:48:34 <lambdabot>     Not in scope: type constructor or class ‚ÄòMaybeT‚Äô
13:48:34 <lambdabot>     Perhaps you meant ‚ÄòMaybe‚Äô (imported from Data.Maybe)
13:48:52 <dminuoso> % import Control.Monad.Trans.Maybe
13:48:52 <yahb> dminuoso: 
13:48:54 <dminuoso> :k MaybeT
13:48:55 <lambdabot> error:
13:48:55 <lambdabot>     Not in scope: type constructor or class ‚ÄòMaybeT‚Äô
13:48:55 <lambdabot>     Perhaps you meant ‚ÄòMaybe‚Äô (imported from Data.Maybe)
13:48:56 <dminuoso> % :k MaybeT
13:48:56 <yahb> dminuoso: MaybeT :: (* -> *) -> * -> *
13:50:02 <dminuoso> Yuon: `(* -> *) -> *` takes exactly one argument, namely one type of kind `* -> *`. `* -> * -> *` takes two types of kind `*` each.
13:58:29 <Yuon> dminuoso: Thank you for the explanation ! I think I understand it now.
14:07:58 * hackage radius 0.6.0.1 - Remote Authentication Dial In User Service (RADIUS)  http://hackage.haskell.org/package/radius-0.6.0.1 (erick)
14:09:44 <v0d1ch> dminuoso: what I think is that I need to provide lambda as the third param, that lambda function takes `[a]` and produces `o`. So since the funtion needs to loop I need to call cpsLoop recursively. Am I right so far ?
14:10:06 <dminuoso> v0d1ch: Follow that thought and see where it leads you.
14:13:02 <v0d1ch> yeah it leads me to something like `f l l (\l' -> cpsLoop f l')` but that yield an empty list, what I'd like to provide to cpsLoop is the result of cpsTail
14:13:07 <v0d1ch> you sound like yoda :)
14:14:11 <dminuoso> v0d1ch: That's it.
14:14:26 <dminuoso> v0d1ch: Now you can eta-reduce it if you like
14:14:35 <dminuoso> So you get `cpsLoop = f l l (cpsLoop f)`
14:15:29 <freedan42x> any idead, how to optimize this code: https://paste2.org/8dxbMJ3M? it takes more than 12 seconds to run
14:15:33 <freedan42x> idea*
14:15:39 <v0d1ch> oh man, I had that before at some point, just thought it didn't work since I got back an empty list
14:16:32 <dminuoso> v0d1ch: The idea is to have something akin to:
14:17:02 <dminuoso> [a] -> ([a] -> Maybe [a]) -> [a]
14:17:13 <dminuoso> Err, missing an argument there.
14:17:30 <dminuoso> step :: [a] -> ([a] -> Maybe [a]) -> [a] -> [a]
14:18:06 <dminuoso> v0d1ch: So instead of encoding "when to stop" and "when to resume" with Nothing and Just, we have now done it using only functions which is faster and requires less space.
14:19:33 <v0d1ch> why is it faster ? I though data constructors are basically just functions too
14:21:51 <Rembane> v0d1ch: dminuoso will probably explain their thoughts soon, but take this opportunity to benchmark the different solutions, because I'm curious too! 
14:21:54 <v0d1ch> oh cpsTail is basically step there
14:22:23 <v0d1ch> hahhahha yeah it is an interesting topic
14:22:41 <Rembane> ^^ I conjecture that if you enable all optimisations, they will be equally fast! 
14:23:19 <dminuoso> v0d1ch: It's faster in principle because you do not have to create Maybes and disciminate+toss them away them moments later
14:24:13 <v0d1ch> ah ok , so it has nothing to do with `(->) vs SomeDataConstructor`
14:24:13 <dminuoso> v0d1ch: and yes. cpsTail is a "stepper" that has the "how to step if we have an empty list" and "how to step if we have a non-empty list". it's a reified branch in a sense.
14:24:35 <dminuoso> v0d1ch: Right, it's more about how to encode control flow in the program
14:24:48 <dminuoso> Imagine you had some:
14:26:04 <dminuoso> `data Action x = Stop x | Proceed x`, then had a function `A -> Action A`, and then a loop that run that function until it hits a `Stop`. 
14:27:28 <dminuoso> If you think about it it makes sense that it's inefficient. That function has already done the testing, so it knows what to do. But instead of *doing* that next step, it builds some data and returns it. 
14:27:51 <dminuoso> The loop has lost that information and has to recreate it by discriminating on the data, which costs effort. And you end up with extra data on the heap.
14:29:06 <v0d1ch> nice, thanks for the free lesson, if you have any more shoot em my way
14:31:19 <dminuoso> v0d1ch: Remember how you had `id` and could swap it out for a different function?
14:31:48 <v0d1ch> yes
14:33:27 <dminuoso> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
14:35:06 <dminuoso> v0d1ch: You were just using continuations there. :)
14:36:14 <v0d1ch> yes I knew that :) I learned to spot that pattern ‚Äò(a ->r) -> r‚Äô
14:37:28 * hackage deriving-compat 0.5.4 - Backports of GHC deriving extensions  http://hackage.haskell.org/package/deriving-compat-0.5.4 (ryanglscott)
14:38:04 <v0d1ch> It is just that monad instance was hard for me. Need to do more exercises
14:39:43 <dminuoso> v0d1ch: Do you want some other interesting instance to write?
14:40:05 <PrimHelios> my linter occasionally recommends i use newtype instead of data. what's the difference?
14:40:33 <dminuoso> PrimHelios: newtype is a compile-time only wrapper, so it incurs no runtime cost and it is also strict.
14:40:53 <dminuoso> (well strict in the sense that you dont add a data constructor)
14:40:53 <merijn> PrimHelios: Constructors of newtypes only exist at compile-time/type-check time
14:40:56 <PrimHelios> ah, gotcha. thanks!
14:41:25 <merijn> PrimHelios: So "newtype Foo = Foo Int" looks different from an Int during type-checking but at runtime it's completely equivalent to just having an Int
14:41:42 <dminuoso> PrimHelios: Also newtypes are coercible with their contained types, so you get some extra freebie there too.
14:41:55 <merijn> dminuoso: Only if roles permit it :p
14:42:00 <PrimHelios> oh cool, that seems really useful
14:45:03 <dminuoso> merijn: I took the liberty to lie a bit. The moment when roles tell them "you cant do this" is the moment Ill make the addendum. :P
15:15:38 <newhoggy_> I'm stuck with getting my travis builds to work.
15:15:51 <newhoggy_> In particular:
15:15:56 <newhoggy_> https://www.irccloud.com/pastebin/apdv9i3v/
15:16:05 <newhoggy_> It works in CircleCI though: https://circleci.com/gh/haskell-works/hw-json/tree/move-json-simd-code-into-project
15:16:46 <merijn> newhoggy_: How did you setup the Travis config?
15:16:55 <newhoggy_> Even with `- "echo 'verbose: 3' > cabal.project.local"` in my `.travis.yml` I didn't get any additional information.
15:17:08 <merijn> newhoggy_: Also, got a link to the repo?
15:18:08 <newhoggy_> Here: https://github.com/haskell-works/hw-json/blob/move-json-simd-code-into-project/.travis.yml
15:18:38 <newhoggy_> The repo + branch is here: https://github.com/haskell-works/hw-json/tree/move-json-simd-code-into-project
15:19:07 <newhoggy_> The travis build on `master` works fine, but I added some code that contains `FFI`
15:19:27 <newhoggy_> So I tweaked the `.travis.yml` file until I got stuck here.
15:19:33 <merijn> newhoggy_: Using the Haskell-CI setup for travis?
15:19:49 <merijn> Ah, no, but your probably should :p
15:20:04 <newhoggy_> What is that?
15:20:04 <merijn> Because this looks based on the output of that
15:20:27 <merijn> newhoggy_: A haskell project for generating Travis-CI setups for your cabal projects :) https://github.com/haskell-CI/haskell-ci
15:21:27 <newhoggy_> Oooh
15:21:41 <newhoggy_> I'll give that a spin.  Thanks!
15:21:46 <merijn> newhoggy_: Anyway, I think I see the problem
15:21:59 <newhoggy_> What do you see?
15:22:13 <merijn> newhoggy_: You have specified "include-dirs: cbits" and then "includes: cbits/debug.h"
15:22:24 <merijn> newhoggy_: Which means it'll look for cbits/cbits/debug.h
15:22:45 <merijn> newhoggy_: As include-dirs are the directories it will try to find header files specified with includes in
15:23:13 <newhoggy_> Should it be `include-dirs: cbits` and `includes: debug.h`
15:23:36 <merijn> newhoggy_: That's what I have in my own code with FFI, but I'll admit I'm only about ~70% confident in this guess :p
15:24:35 <newhoggy_> Just just pushed the change ü§û
15:26:14 <merijn> newhoggy_: Anyway, Haskell-CI is cool, it does things like generate multiple parallel setups based on your "tested-with" field in the cabal file, setup caching, check the sdist tarballs are working properly, and generally ensures you don't really have to bother understanding Travis' yaml nonsense :p
15:30:22 <merijn> Unrelatedly: I know there's a package for diffing arbitrary datatypes and pretty printing the result, but I keep forgetting its name...
15:33:16 <merijn> (Or a package for diffing String/Text would work in this case, I suppose...)
15:35:28 * hackage leancheck-instances 0.0.3 - Common LeanCheck instances  http://hackage.haskell.org/package/leancheck-instances-0.0.3 (rudymatela)
15:38:02 <newhoggy_> Hmm no luck.
15:38:28 <newhoggy_> The more frustrating thing is it builds locally and in CircleCI, but not in travis.
15:41:15 <Heffalump> merijn: gdiff? tree-diff?
15:47:36 <merijn> Ah, yeah tree-diff is the one
16:01:48 <bsima> anyone know how to compile haskell using nix and not cabal?
16:04:06 <geekosaur> I don't think you do? nix generates a cabal file instead
16:04:19 <geekosaur> it does the same for other languages with specific build tools
16:04:29 <bsima> geekosaur: my makefile uses ghc directly
16:04:35 <bsima> can i just tell nix to use make?
16:04:49 <geekosaur> that I don't know. might have to look at how it builds ghc
16:09:19 <iqubic> bsima: I think you join #nixos and and ask there.
16:09:48 <bsima> yeah i didn't want to hijack the convo
16:09:52 <bsima> i will in a minute
16:10:09 <bsima> i'll look at how ghc is built first, that's a good idea, thanks geekosaur
16:25:11 <sclv> bsima: you _can_ compile using nix without cabal
16:25:16 <sclv> cabal just calls ghc commands anyway
16:25:20 <sclv> but the question is why you would
16:25:35 <sclv> the standard nix workflows all use cabal-install to manage a lot of details for you
16:26:32 <sclv> if you just have a simple project, and nix already ensures your libraries are in scope, then you can just call `ghc --make` on the main file and it just works
16:32:26 <newhoggy_> I have the same problem even with `.travis.yml` generated by `haskell-ci`: https://travis-ci.com/haskell-works/hw-json/jobs/171956476
16:33:34 <ar1a> hm, how can i rewrite stdout? i'm wanting to write an rpn calculator that shows the current stack, and when you run an operation like * it would remove the previous two lines and add a line with the result. would i need ncurses for this?
16:34:05 <dminuoso> ar1a: No. Strictly speaking you can just use escape sequences.
16:34:42 <dminuoso> (i.e. control characters)
16:35:18 <zachk> iirc there is an ansi-term package somewhere, but it only works good on *nixes 
16:35:24 <dminuoso> ar1a: A library like ansi-terminal is a thin abstraction layer over the ANSI control characters
16:35:48 <ar1a> im only gonna support linux so thats fine
16:38:15 <ar1a> dminuoso: thanks
16:39:58 * hackage brainfuck-monad 0.5.1 - BrainFuck monad  http://hackage.haskell.org/package/brainfuck-monad-0.5.1 (JoeyHess)
16:45:53 <alien> Hi. I'm having difficulties installing anything via stack. It tells me that version 8.6.3 is not in my indices. I've deleted ~/.stack directory and tried again, but no joy. Can someone point me to a right direction please? Thank you. https://gist.github.com/obszczymucha/6c3c1e1cf85d81b912103be740b80082
16:48:03 <infinisil> alien: Have you done stack update?
16:48:11 <alien> I have.
16:48:40 * infinisil is out of ideas
16:50:23 <sm> alien: have you tried installing other packages ? ghci might be special ?
16:52:14 <alien> sm: good point, I have and all is good. Seems it is special.
16:52:45 <sm> it probably comes with ghc and can't be reinstalled
16:54:30 <ar1a> how do you add a dependency to the .cabal file? :P
16:55:11 <sm> ar1a: with an editor.. unless there's a package.yaml file, in which case add it there (and then stack build, or run hpack)
16:55:49 <MarcelineVQ> sm: in fact ghci is just a shortcut to ghc --interactive
16:56:08 <ar1a> sm: no, i mean't where do you put it
16:57:22 <sm> under build-depends:
16:57:23 <alien> sm, MarcelineVQ: thank you
16:58:01 <sm> today I have succeeded in deploying a fairly substantial web app with 200 lines of make and 300 lines of propellor. Thanks joeyh..
17:01:03 <sm> one command creates a linode and configures apache/ssl/php/postgres/app, convergently
17:01:26 <sm> so I can run it from ghcid whenever the config script compiles
17:05:46 <wroathe> The FromJSON/ToJSON/Value stuff in Aeson should almost be split out into a different library
17:06:03 <MarcelineVQ> sm: :D
17:06:22 <wroathe> I noticed that the Yaml library also uses Aeson's Value type
17:09:52 <jackdk> it should not use typeclasses, imho. typeclasses for encode/decode say "here is THE canonical way to serialise/parse" the structure and that just isn't true. better to have parsers and encoders as values or functions that you pass around
17:11:25 <wroathe> I mean, isn't the opposite true? The whole point seems to be that they're giving us the freedom to write encoders/decoders from and to that generic Value type
17:11:58 <wroathe> Although, I do wonder why he didn't just directly deserialize the data into a generic Rep type instead
17:17:30 <infinisil> jackdk: Agreed
17:18:28 <infinisil> wroathe: Problem is, if you want more than one implementation for the same type, you need to use newtype wrappers (in order to make it an instance of the same class)
17:20:37 <ar1a> what's the number type i should use? needs decimals and arbitrary precision
17:22:59 <absence> ar1a: how do you want infinite decimals like 1/3 represented?
17:23:34 <ar1a> what are my options?
17:23:45 <ar1a> im writing an rpn calculator if that gives any insight 
17:23:46 <jackdk> infinisil: it's worse than that. if your core types are in some other library and you're writing a web service or something, then to avoid orphan instances your serialisation concerns (i.e. the outer layer of teh application) are buried in the innermost part
17:24:00 <jackdk> unless you newtype everything and hope people don't forget
17:25:33 <ar1a> absence: 
17:29:21 <absence> ar1a: these are the built in ones https://stackoverflow.com/a/31843034
17:29:43 <ar1a> probably Real then huh
17:31:33 <absence> ar1a: i think Double (or Float if you want less precision...) is the only one that can do normal calculator functions like trigonometry
17:31:45 <absence> but it's not arbitrary precision
17:32:08 <absence> a lot of calculator operations produce infinite decimals anyway
17:32:33 <geekosaur> there's CReal (numbers package), but you do realize that infinite precision is not a thing for e.g. trig?
17:33:19 <ar1a> i didn't until now
17:33:24 <ar1a> i'll use double, thanks for the help
17:34:20 <geekosaur> irrational and transcendental numbers can only be "exactly" represented by trickery, e.g. picking the appropriate irrational or transcendental base for representation. Which may be different for each one
17:34:44 <alien> Is there a working autocomplete solution for vim and haskell available? I can see that ghc-mod is stuck on ghc 8.0.2.
17:35:07 <geekosaur> i.e. you can use pi for most trig, but you're only representing sqrt(2) exactly in terms of itself
17:40:37 <ar1a> can someone tell me why im getting this parsing error? https://ptpb.pw/qxy-/haskell
17:40:58 * hackage servant-kotlin 0.1.1.6 - Automatically derive Kotlin class to query servant webservices  http://hackage.haskell.org/package/servant-kotlin-0.1.1.6 (matsubara0507)
17:41:15 <ar1a> well apart from the obvious runtime error because its on the wrong code path :P
17:44:04 <c_wraith> ar1a: an if/then/else inside a do block does not implicitly have do blocks for its branches
17:44:25 <ar1a> ah
17:48:29 <jle`> ar1a: iirc if/then/else doesn't have any special syntax in a do block, it's just a normal if/then/else expression
17:52:15 <ar1a> https://ptpb.pw/AgOv/haskell how can I pattern match that out?
17:52:49 <jle`> ar1a: you can do a where or let
17:52:57 <jle`> or maybe case here is better
17:53:03 <jle`> case pop stack of
17:53:09 <jle`>   (Nothing, stack) -> ...
17:53:27 <jle`> er, preferably with a different name
17:56:55 <koz_> jle`: (Nothing, stack') ?
17:57:00 <ar1a> https://ptpb.pw/XmAh is giving me the same error but on the = case ... jle` 
17:57:15 <jle`> perform stack op = case pop stack of
18:14:15 <leshow> Is it possible to use forM on a list and runSTArray in the funciton body? like forM somelist $ \foo -> runSTArray $ do ...
18:15:00 <leshow> I'm trying to learn how to use ST arrays but there's not a lot of information online, translating an algorithm into haskell
18:18:27 <ar1a> thing is i so im using getLine to get input, but it means i can't backspace or use arrow keys and whatnot. is there a better getLine or should i jump straight into readline
18:19:18 <jackdk> :t forM
18:19:19 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
18:19:22 <jackdk> :info ST
18:20:36 <leshow> I have a code example that won't compile, that's the reason i ask 'No instance for Monad (GHC.Arr.Array Int)' I can copy it to pastebin
18:20:52 <jackdk> leshow: I will take a look, see if I can help
18:21:34 <leshow> https://pastebin.com/6RVt2Aer
18:21:36 <leshow> thanks
18:21:55 <leshow> it's a hackerrank problem
18:22:20 <geekosaur> ar1a, bakspace should work, arrows etc. require readline or equivalent
18:23:26 <jackdk> leshow: before I think too hard about this, is the exercise to practice writing ST code or to port an algorithm to haskell?
18:24:10 <leshow> I know I could write it without ST, I just never really use ST in haskell and wanted to try to see what it'd look like
18:24:18 <leshow> I could do it without for sure
18:24:39 <jackdk> OK, cool.
18:25:01 <geekosaur> leshow, the result of runSTArray isn't necessarily in a monad. what did you intend with forM?
18:26:23 <leshow> iterate through queries creating an array for each query
18:26:39 <jackdk> leshow: I think you should try doing everything within a single `runST $ do ...`. Because you're not returning the array, the runSTArray stuff is a bit of a red herring
18:27:07 <leshow> I just noticed i'd be making a new array in each iteration instead of mutating the old one too
18:27:15 <leshow> yeah
18:27:21 <jackdk> the final part of that do block will probably be something like `readSTRref max`
18:30:54 <leshow> you can use STArray inside runST without explicitly calling like runSTArray?
18:32:26 <jackdk> leshow: yeah, they implement the MArray typeclass http://hackage.haskell.org/package/array-0.5.3.0/docs/Data-Array-MArray.html
18:38:04 <ar1a> how can i check if a string is a valid double, because if it isnt read panics and crashes the program
18:38:26 <edmundnoble> Just use `readMaybe`?
18:39:20 <ar1a> ty
18:39:29 <leshow> jackdk: I think I got it
18:39:43 <leshow> It's a big mess, but close
18:40:56 <leshow> https://pastebin.com/GR0jJHLa
18:44:45 <jackdk> don't ask me, ask the type-checker ;-)
18:44:58 <leshow> type checker is happy, i'm trying the test cases now
18:46:19 <leshow> yeah, that works, thanks for the help
18:47:08 <leshow> I think I'll try 'idiomatically' now
18:50:03 <alien> I'm inteermediate if it comes to Haskell, I want to learn more. I'd like to set up a development environment with vim + autocomplete that requires ghc-mod. This however binds me to ghc 8.0.2. Would you say it's ok to work with ghc 8.0.2 for learning purposes? Am I missing a lot from not using the latest ghc?
18:50:34 <leshow> IMO it's fine to be in 8.0 for learning
18:50:56 <leshow> If you want to learn type level stuff then maybe you need the latest
18:51:06 <leshow> That seems to be where the bleeding edge is required
18:51:22 <alien> leshow: I see. Thank you.
18:52:47 <MarcelineVQ> you can get ghc-mod for 8.4 if you search around a bit. ghc-mod ended up being more of a hassle than I preferred and recommend to people to try ghcid
18:53:59 <alien> MarcelineVQ: Thank you. I'll defo check these out. I got a little discouraged with the dev environment setup, I don't wanna miss out on the latest language capabilities.
18:54:47 <newhoggy_> I've figured out that I need my project to work with vanilla `cabal.project` in order to build with travis.
19:06:12 <ar1a> is there an alternative to `read` that can accept decimals without leading zeros? `.3` doesn't parse but `0.3` does
19:07:24 <jackdk> `read . ('0':)`? might turn all failed parses to zero though
19:07:28 * hackage grids 0.3.0.0 -   http://hackage.haskell.org/package/grids-0.3.0.0 (ChrisPenner)
19:08:50 <ar1a> mm that wont work for me then
19:15:17 <geekosaur> at this point you probably want an actual parser (possibly ReadP-based)
19:15:46 <geekosaur> using read for this is kinda abuse, in the same way trying to use show to prettyprint is abuse
19:16:11 <geekosaur> they're for debugging and read / produce Haskell source (and combine in ways that assume that)
19:16:26 <hololeap> what does "The constraint 'Blah' is no smaller than the instance head" actually mean?
19:17:41 <geekosaur> the constraint isn't doing anything / is meaningless
19:18:29 <geekosaur> anything that matches the instance head without a constraint, also matches the constraint in question
19:21:09 <hololeap> i know this isn't the way things are normally done and that usually you would wrap things in a newtype, but why is this frowned upon? http://dpaste.com/27FFZPX
19:22:37 <geekosaur> because it matches all types t, and only afterward checks the constraint.
19:22:42 <geekosaur> and it must be this way
19:23:23 <geekosaur> everyone always wants it to magically apply the constraint as part of matching the instance, but no, this requires the compiler to know every instance that will ever exist
19:23:55 <hololeap> ok that makes some sense to me
19:25:56 <geekosaur> (the instance head is compile time. the constraint comes from a runtime dictionary)
19:33:46 <ar1a> https://hackage.haskell.org/package/parsec-numbers-0.1.0/docs/Text-ParserCombinators-Parsec-Number.html im trying to figure out how to parse a float, but `floating3` wants me to pass in a Floating and a bool, and neither is documented?
19:35:39 <geekosaur> it doesnt want you to pass in a "Floating". Floating is a typeclass, and it's a constraint.
19:36:06 <geekosaur> and from the top of that haddock: A couple of parsers have been added that take a Bool argument, where False does not require any digit following the decimal dot. The parsers fractional3 and floating3 allow even to start a number with the decimal dot. Also parsers hexFract, binFract, hexFloat and binFloat for hexadecimal or binary fractions and floats have been added.
19:37:23 <ar1a> hm alright, im in a ghci and rn i'm running `floating3 Float False` but its throwing me the error     Data constructor not in scope: Float :: Bool
19:38:07 <monochrom> floating3 takes one parameter, of type Bool.
19:38:30 <monochrom> If you think it takes two parameters, you need to learn or re-learn type classes.
19:38:41 <ar1a> OH its a => 
19:38:43 <ar1a> i thought it was a ->
19:38:55 <geekosaur> ar1a, pleaase note that "Floating a" is followed by =>
19:38:59 <geekosaur> it is a constraint
19:40:03 <ar1a> okay, im not sure how to use the CharParser it returns 
19:41:39 <monochrom> It is used the same way any parser from Parsec is used.
19:42:40 <monochrom> What you may need is a Parsec tutorial like https://github.com/JakeWheat/intro_to_parsing
19:43:03 <monochrom> and an awareness that "CharParser st" is a monad and you get to use do-notation etc.
19:44:21 <monochrom> If you feel this is a deep rabbit hole for merely "I just want to accept .3" then you may need to accept a concession and postpone it.
19:44:28 * hackage unix-time 0.4.5 - Unix time parser/formatter and utilities  http://hackage.haskell.org/package/unix-time-0.4.5 (KazuYamamoto)
19:45:32 <monochrom> If you think "but a regex would be so easy" then regex is another deep rabbit hole in terms of Haskell libraries and bindings to regex libraries.
19:46:10 <geekosaur> I did try to suggest using ReadP instead of a full parser combinator library
19:46:21 <monochrom> If you say "but regex is like native in Perl" then let me tell you a Perl horror story I just heard today.
19:46:47 <ar1a> i googled around for "haskell float parser" but could only find this package
19:46:57 <geekosaur> also I'd like to point out that a regex to recognize a general number is far from trivial
19:48:18 <monochrom> If you try to open a file but it does not exist so opening is supposed to fail, Perl succeeds, as in no exception, you have to check some global variable to know. (OK, so far it sounds like C too, but the difference is next.)
19:48:44 <monochrom> It still returns a file handle, and you can use that file handle without error, you will be just reading \nul's.
19:49:21 <ar1a> this parsec thing is so confusing...
19:49:21 <monochrom> (Compared to C, where you will get the null pointer for FILE* so at least you get a segfault if you use it.)
19:49:56 <monochrom> Perl makes easy things easy and the erroneous things miraculous.
19:51:05 <ar1a> all this just to get it to parse floats where they start with a decimal
19:52:26 <geekosaur> the perl faq has a moderately hairy entry about parsing floats
19:53:11 <geekosaur> it's not the trivial thing people always think it "ought to be", unless the language exposes its own parser (which usually means interpreted languages, and in the case of perl is only exposed for integers)
19:54:32 <ar1a> alright i guess ill head back to read for now
19:56:00 <nshepperd1> regex-base and its collection of orphan instances in different packages for different "backends" is certainly an 'interesting' way of doing it
19:56:27 <monochrom> Those were the days before Backpack.
19:57:52 <nshepperd1> (i tried a few of those because i needed some fast regex library for a program with user supplied regex. Turns out regex-pcre is pretty performant)
19:58:17 <nshepperd1> I don't really understand backpack
19:59:16 <monochrom> Maybe someone should write a "Backpack for SML programmers" :)
20:00:11 <monochrom> Like "if you have been thinking 'functor F(sig X) : structure ...' here is how it looks like in Backpack"
20:01:14 <iqubic> What is Backpack?
20:05:00 <nshepperd1> I want "backpack for haskell programmers who have never heard of ocaml"
20:05:12 <monochrom> hehe
20:05:49 <monochrom> I'm a reductionist so I'll just reduce it to "learn SML or OCaml then read the Backpack-for-ML-programmers tutorial!"
20:08:24 <ar1a> https://github.com/ar1a/polishnt what i was writing if anyone is curious 
20:11:05 <iqubic> I'm finding it hard to figure out what exactly backpack has.
20:11:09 <iqubic> s/has/is/
20:18:29 <koz_> iqubic: http://blog.ezyang.com/2014/08/whats-a-module-system-good-for-anyway/
20:22:45 <koz_> iqubic: Once you're done with that: http://blog.ezyang.com/2014/08/a-taste-of-cabalized-backpack/
20:26:14 <iqubic> Nah, I'm not too fussed with reading a long long long text post
20:28:26 <koz_> iqubic: You asked.
20:30:10 <dmwit> It's okay to find it hard to understand something. Maybe that something is complicated!
20:30:48 <dmwit> But there are many hard things worth doing.
20:32:06 <iqubic> You sound like Richard Nixon talking about the moon landing..
20:32:29 <monochrom> Some people come to IRC because "I learn best from convos. Not going to read wall of text"
20:32:54 <MarcelineVQ> Yeah, or ghandi talking about having a dream
20:33:21 <koz_> Or Caesar talking about the only thing we have to fear is fear itself.
20:33:37 <monochrom> Fortunately, the reductionist in me notes that requesting a convo can be reduced to requesting a wall of text by taking a long article from the web and pasting it at the rate of, say, 15 seconds per line!
20:34:06 <dmwit> "We choose to go to the Moon" wasn't Nixon.
20:34:22 <dmwit> I guess everybody else made that point, too.
20:34:23 <koz_> dmwit: Hence MarcelineVQ and me.
20:34:24 <koz_> :D
20:34:25 <MarcelineVQ> Sure it was, good old flame hair nixon.
20:34:40 <MarcelineVQ> Nixon of troy
20:34:46 <monochrom> Nixon was like "we choose to pull out of Vietnam" instead.
20:34:47 <MarcelineVQ> Nixon the great
20:34:57 <koz_> Franklin Delano Caesar.
20:35:06 <MarcelineVQ> The holy trinity, nixon, nixon, and dixon.
20:35:13 <monochrom> Or maybe it was "we have no choice but to pull out of Vietnam" but meh.
20:35:33 <monochrom> Also, Moon Cheese is better.
20:35:48 <dmwit> I visited KSC over Christmas break. I'm pretty sure I heard "We choose to go to the moon... because it is hard" about 30 times that day. They *love* that quote there.
20:35:56 <koz_> dmwit: KSC?
20:36:03 <koz_> Ah, Kennedy Space Center.
20:36:05 <monochrom> Pre-order Moon Cheese for the next lunar eclipse!
20:36:08 <dmwit> One guess what the K is for. SC is for Space Center.
20:36:59 <MarcelineVQ> Kerbal
20:37:04 <monochrom> Haha
20:37:07 <MarcelineVQ> monochrom: the reductionist in me, if the term applies, rolls in a salt pile when googling the question as asked would have yielded an answer in the first 3 results.
20:37:12 <koz_> MarcelineVQ: Best. Trip. Ever.
20:39:43 <monochrom> I fear those who don't fear themselves. >:)
20:42:05 <dmwit> Ummmmm... true. I'll go true. I'll be honest, though, I may have heard that one before.
20:42:44 <MarcelineVQ> yay I get a reference
20:42:55 <MarcelineVQ> dear diary...
20:45:15 <iqubic> monochrom: You should fear me.
21:42:27 * hackage function-builder 0.1.0.0 - Create poly variadic functions for monoidal results  http://hackage.haskell.org/package/function-builder-0.1.0.0 (SvenHeyll)
21:51:34 <jle`> nice, poly variadic functions for monoidal results
21:51:36 * Arahael has no fear of himself.
21:52:32 <jle`> buzzword soup is good for the soul
21:52:44 <janat08> i was going to say so academic
21:55:42 <monochrom> It's just called "function builder" so it's not too bad.
21:57:48 <monochrom> Like, consider: "depedency-injection 0.1 - open union algebraic effect derived from tagless final codensity" >:)
21:58:27 <monochrom> "Requires 2 millioleges"
21:58:36 <monochrom> err, milliolegs!
22:09:17 <iqubic> jle`: Buzz words are the best.
22:09:58 <iqubic> We love matching patters in order to compile alebraic data types.
22:15:58 <Axman6> hmm, that library looks like it's just the Formatting library but a bit more general
22:52:40 <dminuoso> So I realized that apparently typeclasses just express the idea of relations.. is this a correct way to look at them?
22:53:20 <dminuoso> (Assuming you enable MPTC)
22:55:57 <jle`> i'd have issues with "just"
22:55:59 <opqdonut> dminuoso: yes. and if you enable FunDeps, you can even say "this relation is a function"
22:56:08 <jle`> i'd feel more comfortable replacing "just" with "can"
22:57:00 <opqdonut> yeah polymorhism makes them a bit different than relations
22:57:17 <jle`> "typeclasses can express the idea of relations"
22:57:46 <dminuoso> opqdonut: How so? Isn't polymorphism "any n types that are satisfied by the relation R are valid"
22:58:09 <iqubic> And aren't there a few different versions of polymorphism? Parametric and ad-hoc?
22:58:15 <dminuoso> opqdonut: And FunDeps is how I arrived at this conclusion by the way. :-)
22:58:45 <opqdonut> hmm yeah if you don't use (parametric) polymorphism in the parameters, you can specify an arbitrary relation
22:59:00 <opqdonut> (with a suitable extension)
22:59:24 <opqdonut> also, a class instance also has the implementation
22:59:39 <opqdonut> so it's more like a partial function from a tuple of types to some code
22:59:50 <dminuoso> Mmm. I guess I kind of ignored the possible body of classes...
23:00:22 <dminuoso> jle`: Fair enough, the modal verb "can" fits more nicely indeed.
23:02:57 <dminuoso> Mmm, the comparison also falls short on superclasse
23:03:28 <jle`> also note that a lot of MPTC + FunDeps are just convenient shorthand for using TypeFamilies
23:03:35 <jle`> which is why FunDeps can feel like "type functions"in a way
23:04:30 <jle`> what i mean is that MPTC + FunDeps is often just used to implement the same functionality that you might write using TypeFamilies instead
23:04:37 <jle`> but TypeFamilies is (iirc) strictly more powerful
23:04:47 <jle`> so the main advantage of using MPTC + FunDeps is syntactic convenience
23:05:44 <dminuoso> jle`: I haven't understood well enough why fundeps are used at all, take mtl for example.
23:06:01 <jle`> you mean, why fundeps as opposed to just plain mptcs ?
23:06:11 <dminuoso> Right.
23:06:30 <dminuoso> type families I can understand on many levels.
23:07:29 <dminuoso> And Im not talking about "using an auxiliary class to get access to fundeps just for the sole purpose of having type functions"
23:07:48 <jle`> well, it makes type inference possible in a lot of situations
23:08:15 <jle`> you have to ensure that if you sequence two `m ()`'s, that they both have the same state/log/environment/etc.
23:08:49 <jle`> also if uniqueness isn't enforced, you can't really reason about `Writer Int`
23:08:59 <jle`> what if someone wrote another `MonadWriter` instance for it?
23:09:00 <dminuoso> So that would suggest a fundep | m -> s
23:09:14 <dminuoso> that is, class Monad m => MonadState s m | m -> s
23:09:14 <jle`> yeah, without fundeps, you can ahve the same type have different logs/state
23:09:29 <jle`> fundeps assure that the same type always has the same log/state type
23:09:54 <jle`> that's why it's not just `class MonadState s m`
23:10:28 <jle`> if it was, you could legally write `instance MonadState Int MyType` and `instance MonadState Bool MyType`
23:10:57 <jle`> and a different instance wouild be picked based on type inference for modify/set/get
23:11:07 <jle`> modify/put/get
23:11:28 <dminuoso> 08:08        jle` | also if uniqueness isn't enforced, you can't really reason about `Writer Int`
23:11:45 <dminuoso> Can you elaborate on what you mean there? Im confused because we were talking about typeclasses, now there's a concrete simple Monad here.
23:11:59 <jle`> right, you could write:
23:12:08 <jle`> instance MonadWriter Int (Writer Int)
23:12:10 <jle`> and also:
23:12:16 <jle`> instance MonadWriter Bool (Writer Int)
23:12:18 <dminuoso> Oh.
23:12:27 <jle`> both instances couild live side-by-side, if it weren't for fundeps
23:12:45 <jle`> and `tell 9` would use the first instance, and `tell True` would use the second instance
23:12:48 <jle`> you can see how that can get pretty messy
23:12:51 <nshepperd> iirc, ekmett has suggested that the fundep for MonadReader should be removed, so that Proxy can have a MonadReader instance for every type
23:13:27 <nshepperd> for some cases like MonadReader you can get the expected type inference behaviour, even without the fundep
23:14:07 <jle`> dminuoso: also consider type inference for `tell x :: Writer Int ()`.  if it weren't for the fundep, we would have no clue what type `x` would have...it could be Int or Bool
23:14:38 <nshepperd> thusly: instance (r ~ mr) => MonadReader r (Reader mr a) where ...
23:16:04 <nshepperd> but, well, i think the fundep is nicer because it is uniform and applies even when you don't know the instance yet
23:17:08 <dminuoso> nshepperd: Ah so you could have multiple instances `MonadReader A (Reader A B)`, `MonadReader A (Reader A C)`, and so on..
23:18:07 <dminuoso> jle`: I think I understand the basic idea now. Thank you for the explanation, time to let that sink in. :)
23:20:00 <nshepperd> err
23:20:13 <nshepperd>  instance (r ~ mr) => MonadReader r (Reader mr) where ...
23:20:44 <dminuoso> nshepperd: Oh.
23:20:56 <dminuoso> Should have spotted that. :)
23:30:23 <v0d1ch> dminuoso: Yeah sure > Do you want some other interesting instance to write?
23:31:16 <dminuoso> v0d1ch: https://gist.github.com/dminuoso/0b426d447e438c29b2a64548ad5b2039
23:31:20 <v0d1ch> I am on a skiing trip though so things will go slow
23:32:05 <v0d1ch> great I will do those and ping you later on, thanks!
23:39:28 * hackage yesod-core 1.6.10 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.6.10 (MichaelSnoyman)
23:40:28 * hackage wai 3.2.2, yesod-form 1.6.4 (MichaelSnoyman): https://qbin.io/sweden-game-kjqd
23:49:52 <bahamas> hello. I have some functions that need to share state and they all return `Either e a`. what monad transformers stack should I use?
23:52:12 <koz_> bahamas: I assume the state is readable and writable?
23:52:21 <koz_> Or is it read-only?
23:52:24 <jle`> bahamas: it's situational, but you can just use `State s (Either e a)`, maybe. we'd have to see more to give an actual suggestion
23:52:43 <jle`> note, no monad transformer stack
23:52:58 <bahamas> koz_: I need to write to it yes. in one function I write to the state. in others, I read from it and do some checks
23:53:15 <koz_> bahamas: jle` makes a good suggestion. Like he always does.
23:54:02 <bahamas> alright. thanks. I'll see how this works
23:55:58 <jle`> bahamas: one suggestion i can make is to write your program without State, and just manually pass around the state as a function parmaeter and result
23:56:21 <jle`> bahamas: and you can paste it for us to review, and we can see what sort of benefits you might reap from refactoring with State or some other type
23:57:06 <jle`> remember that State/Writer/Reader/Except/etc. aren't magic, they are just covenient wrappers over common types of design patterns
23:57:21 <jle`> so you can't write anything with them that you can't already write without them
23:57:25 <bahamas> jle`: ok. yeah, they still feel a bit like magic to me
23:57:35 <jle`> so write your program normally, however you are comfortable, in a non-magic way
23:57:41 <bahamas> but yeah, I remember that I can pass state explicitly to every function
23:57:57 <jle`> and then we can show you what benefit you might get from using State/etc. to help reduce repetition or clean up your code
23:58:46 <tdammers> implementing those "magical" types and their monad/applicative/functor instances yourself is a great way of demystifying them
23:58:56 <bahamas> thank you for the advice. it's helpful
23:59:02 <tdammers> I'd start with Reader, which is probably the easiest to implement
23:59:29 <koz_> I never actually found a use for Reader.
23:59:29 <bahamas> I think I implemented them at some point, but I haven't used them in a while, so I forgot exactly how they work
23:59:31 <jle`> most of the times with me i start writing them 'by hand', and only switch to using State/etc. when the by-hand version gets unwieldy
23:59:57 <koz_> I guess I'm the total opposite to jle`, because I tend to go to State very quickly if I find I need it.
