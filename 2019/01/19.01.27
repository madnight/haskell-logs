00:21:07 <solrize> what's this about lpaste.net asking for a password?  is that still the haskell pastebin or did someone else get the domain or ... ?
00:23:00 * hackage tonatona 0.1.0.1 - meta application framework  https://hackage.haskell.org/package/tonatona-0.1.0.1 (arowM)
00:23:21 <[Leary]> @where paste
00:23:21 <lambdabot> https://gist.github.com
00:23:26 <[Leary]> lpaste was abandoned
00:23:31 <nshepperd1> The haskell pastebin is long gone
00:24:04 <solrize> thanks
00:24:59 * hackage tonatona-persistent-postgresql 0.1.0.1 - tonatona plugin for accessing PostgreSQL database.  https://hackage.haskell.org/package/tonatona-persistent-postgresql-0.1.0.1 (arowM)
00:26:00 * hackage tonatona-persistent-sqlite 0.1.0.1 - tonatona plugin for accessing Sqlite database.  https://hackage.haskell.org/package/tonatona-persistent-sqlite-0.1.0.1 (arowM)
00:27:00 * hackage tonatona-servant 0.1.0.1 - tonatona plugin for servant.  https://hackage.haskell.org/package/tonatona-servant-0.1.0.1 (arowM)
00:29:51 <pavonia> Too bad no one took over the hosting for lpaste, it really was one of best pastebins
00:31:08 <maerwald> after the rewrite, not so much
01:25:58 <c50a326> dammit... I wanted to follow along the hakyll types to understand the code... I've gotten to the Rules type, and its Monad instance is derived: http://hackage.haskell.org/package/hakyll-4.12.5.0/docs/src/Hakyll.Core.Rules.Internal.html#Rules
01:29:05 <c50a326> ah is it because we're just wrapping RWST which is already a Monad?
01:29:18 <[Leary]> It's using GND so the newtype wrapper's instance comes straight from underlying type.
01:29:58 <c50a326> yeah I was just reading about that
01:30:19 <c50a326> so to understand the behaviour of the program, I need to look at the behaviour of the underlying monad, presumably
01:44:27 <c50a326> are "type" and "data structure" synonymous?
01:45:52 <koz_> c50a326: Not really, no.
02:40:48 <[rg]> hello
02:41:13 <[rg]> how would you write a ppm P6 without anything external?
02:41:36 <[rg]> pointers are ok, just curious
02:42:31 <[exa]> do you mean the PPM picture?
02:42:40 <[rg]> yeah
02:43:32 <[rg]> i aware there is an asci format 
02:43:44 <[exa]> it's just a text, right? you can generate a string out of that using intercalate and just write it to a file (supposing your image data is in some kind of array)
02:44:59 <[rg]> yeah, its not reallly usefull, just wondering if there's a haskell way to do it for the binary format
02:45:19 <[rg]> what you said is what im doing currently
02:47:53 <[exa]> you wanted to write a PPM right? that's not binary
02:48:03 <[exa]> anyway, ByteStrings work pretty well for binary stuff
03:16:31 <c50a326> is there any difference between a "group" in group theory, and a monoid?
03:17:37 <[Leary]> Groups are monoids with inverses.
03:27:32 <c50a326> does this have a type-class in haskell?
03:27:47 <c50a326> ah http://hackage.haskell.org/package/groups-0.4.1.0/docs/Data-Group.html
03:34:42 <cocreature> it’s interesting how useful of an abstraction Monoid seems to be when it comes to programming whereas group seems to be far less useful
03:36:06 <Rembane> Semigroup is even more useful imo
03:36:58 <Rembane> And Monoid is amazing!
03:42:54 <phadej> group would be useful, but they are very rare
04:12:46 <Agata> I love when on my body cum, find me here - http://gmy.su/:45ny
04:26:27 <c50a326> phadej: how are they rare? here it gives several examples https://en.wikipedia.org/wiki/Group_(mathematics)#Definition_and_illustration
04:27:04 <c50a326> phadej: as well as ints with addition, do ints with multiplication not form a group as well, the inverse being division? or does that not work for some reason? ah I guess division isn't associative is it, damn...
04:27:28 <ski> rationals, excluding zero
04:27:30 <c50a326> ah yeah ints and multiplication does not form a group
04:29:10 <c50a326> the symmetry group example looks pretty cool though
04:29:30 <[Leary]> Groups are common when mathematicians are exploring the entire space of them, they're not common when you need them to crop up naturally in your program, on top of which you need the inverse to be computable, on top of which you need the algorithm to be better than brute force.
04:30:40 <elgoosy> hi, this is from the webghc blog: "Switching to the LLVM backend is becoming more and more important. It is likely to improve both performance and codesize dramatically." Which backend does it use currently then?
04:31:16 <elgoosy> ups sorry, i had to ask this on #ghc instead
04:32:20 <opqdonut> elgoosy: I think GCC is using the (custom) c-minus-minus backend by default
04:37:59 * hackage HsYAML-aeson 0.1.0.0 - JSON to YAML Adapter  https://hackage.haskell.org/package/HsYAML-aeson-0.1.0.0 (HerbertValerioRiedel)
04:53:12 <Blanca> I love when on my body cum, find me here - http://gmy.su/:45ny
05:05:59 <xsperry> > let f xs = replicateM (length xs) xs in f [1..2]
05:06:01 <lambdabot>  [[1,1],[1,2],[2,1],[2,2]]
05:06:05 <xsperry> > let f xs = replicateM (length xs) xs in f [1..3]
05:06:07 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,...
05:06:13 <xsperry> is there such a function in base?
05:06:47 <xsperry> :t let f xs = replicateM (length xs) xs in f
05:06:48 <lambdabot> (Applicative m, Foldable m) => m a -> m [a]
05:07:44 <opqdonut> > let f xs = xs *> length xs in f [1..3]
05:07:46 <lambdabot>  error:
05:07:46 <lambdabot>      • Couldn't match expected type ‘t b1’ with actual type ‘Int’
05:07:46 <lambdabot>      • In the second argument of ‘(*>)’, namely ‘length xs’
05:07:54 <opqdonut> oh right
05:08:00 <opqdonut> > let f xs = xs *> [length xs] in f [1..3]
05:08:02 <lambdabot>  [3,3,3]
05:08:03 <opqdonut> not quite as elegant
05:08:32 <opqdonut> no I'm raving, that's completely wrong
05:08:39 <xsperry> ;)
05:10:42 <xsperry> @hoogle (Applicative m, Foldable m) => m a -> m [a]
05:10:43 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
05:10:43 <lambdabot> Intro sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
05:10:43 <lambdabot> Data.Microformats2.Parser.Util expandSnd :: Foldable ? => ? ([?], ?) -> [(?, ?)]
05:11:43 <ski> > let f xs = mapM (const xs) xs in intercalate ";" (f "ab")
05:11:45 <lambdabot>  "aa;ab;ba;bb"
05:11:46 <ski> > let f xs = mapM (const xs) xs in intercalate ";" (f "abc")
05:11:49 <lambdabot>  "aaa;aab;aac;aba;abb;abc;aca;acb;acc;baa;bab;bac;bba;bbb;bbc;bca;bcb;bcc;caa...
05:19:00 <xsperry> > let f xs = mapM (const xs) xs in f [1..3]
05:19:02 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,...
05:19:11 <xsperry> of course..
05:20:29 * hackage first-class-families 0.5.0.0 - First class type families  https://hackage.haskell.org/package/first-class-families-0.5.0.0 (lyxia)
05:23:00 <ski> > map (const "abc") "abc"
05:23:02 <lambdabot>  ["abc","abc","abc"]
05:23:05 <ski> > map ((`map` "abc") . const) "abc"
05:23:07 <lambdabot>  ["aaa","bbb","ccc"]
05:24:38 <xsperry> of course, as in, I got it, and beating myself that I didn't think of it
05:24:43 <xsperry> > do x <- "abc"; return "abc"
05:24:45 <lambdabot>  ["abc","abc","abc"]
05:24:50 <xsperry> for each element, return whole list
05:28:57 <xsperry> > sequence $ do x <- "abc"; return "abc"
05:28:59 <lambdabot>  ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","bb...
05:31:18 * ski . o O ( `sequence : (a^m)^n -> (a^n)^(m^n)' )
05:31:30 * hackage hsimport 0.8.8 - A command line program for extending the import list of a Haskell source file.  https://hackage.haskell.org/package/hsimport-0.8.8 (DanielTrstenjak)
05:43:00 * hackage persistent-template 2.6.0 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.6.0 (psibi)
05:45:11 <xsperry> > liftA2 mapM const id "abc"
05:45:13 <lambdabot>  ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","bb...
05:58:41 <slack1256> I got the weirdest problem, I got a project (irc-core) that compiles with `cabal build` but not `cabal new-build`.
05:59:17 <lyxia> how odd. What's the error?
05:59:19 <slack1256> It fails on a specific file (which doesn't import anything related with openssl) with "<command line>: can't load .so/.DLL for: libssl.so (libssl.so: cannot..."
05:59:59 <slack1256> It seems a common cabal problem from 2015, anybody experiencing the same?
06:18:14 <ahri> I know I can parse Haskell 98 with haskell-src, but is there a way to parse a more modern flavour of Haskell from Haskell? I'd like to inspect the comments in a file
06:18:28 <ahri> (also pragmas)
06:19:47 <lyxia> haskell-src-exts
06:22:00 <slack1256> Nvm, I solved it adding a `shellHook = '' export LD_LIBRARY_PATH=${openssl.out}/lib:$LD_LIBRARY_PATH ''`
06:23:15 <michalrus> Should it be safe to unsafely run getCurrentTime in an STM transaction?
06:23:44 <michalrus> If I don’t really care about that time being super correct… much.
06:26:22 <ahri> lyxia: oh thanks, I'm not sure how I missed that :\
06:29:29 * hackage capnp 0.4.0.0 - Cap'n Proto for Haskell  https://hackage.haskell.org/package/capnp-0.4.0.0 (isd)
06:35:56 <ejt> can I create a list of different types that share a common class?  eg, (Show a) => [a]
06:37:11 <lyxia> existential types:    data Showable where Showable :: forall a. Show a => a -> Showable
06:37:20 <sicklorkin> ejt: what are you trying to do? 
06:37:41 <lyxia> most of the time it's an antipattern
06:37:50 <sicklorkin> seldomly do you want to use existential types
06:38:28 <ejt> I have a type class Target, with a couple of functions in it.
06:38:44 <ejt> and a type Table, that I want to hold a collection of these targets
06:39:05 <ejt> I've not used Haskell for a long time, and something's telling me I'm being stupid
06:40:14 <sicklorkin> ejt: if you have an example i can take a look and see if I can help steer u
06:40:38 <sicklorkin> (not that I'm an expert tho)
06:44:41 <ejt> sicklorkin: https://pastebin.com/mVRuN8zQ
06:45:06 <ski> ejt : what you asked for was not `forall a. Show a => [a]' (which is something else, in this case not useful), but `[exists a. Show a *> a]' (pseudo-code), which can be expressed/represented in current Haskell as `[Showable]', with the definition of `Showable' above
06:45:44 <ejt> sicklorkin: see line 16 and 20
06:45:53 <ski> @where existential-antipattern
06:45:53 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
06:47:50 <ski> presumably `tableTargets :: (Target ta) => [ta]' should really conceptually have been `tableTargets :: [exists ta. Target ta *> ta]' .. but in this case, that's equivalent to `tableTargets :: [(TableLine,[Device])]'
06:49:17 <ejt> ski: just reading the antipattern, which seems relevant thx
06:49:42 <ski> (the only thing you can do with a value of type `ta', of which you know nothing else than that `Target ta' holds, is to apply `toTableLine' and `toDeps' to it, yielding values of type `TableLine' and `[Device]', which you can inspect. you could pack these together into a pair of type `(TableLine,[Device])', and doing so for all the elements of the list will give you what i mentioned above)
06:51:03 <ski> (if you prefer, instead of using a pair, you could define a record type, with one field (called `tableLine' ?) of type `TableLine', and one (called `deps' ?) of type `[Device]')
06:51:57 <ejt> ok, thx, I get it
06:52:00 <ejt> will simplify
06:55:34 <ski> ejt : otoh, if any of the methods in `Target' had taken another number of `a's as input than exactly one, the matter would have been different
07:05:34 <ejt> ski: all works now thx
07:14:59 * hackage aeson-value-parser 0.14.2 - An API for parsing "aeson" JSON tree into Haskell types  https://hackage.haskell.org/package/aeson-value-parser-0.14.2 (NikitaVolkov)
07:59:19 <glaz77> Hi, I am an undergraduate pursuing a Bachelors in Computer Science at IIIT-Hyderabad. I was going through the project ideas on summer.haskell.org. The idea of 'issue-wanted: Web app for discovering potential contributions to the Haskell ecosystem' caught my eye. I have learnt haskell some time ago and am familiar with the idea of monads, have a good experience with sql too. It would be a great experience to work with you guys.
08:03:37 <[exa]> glaz77: hi. You should probably contact the Summer staff directly. Regarding the app, I guess you came across packages like Scotty or Servant?
08:05:39 <[exa]> glaz77: anyway, for the GSoC, there's probably still lot of time-- see the timeline here https://developers.google.com/open-source/gsoc/timeline
08:10:10 <shazb0t> what is  up
08:15:02 <glaz77> oh ok! I would still like to start contributing and work on it! Also, I have come across Scotty
08:23:44 <[exa]> glaz77: there are the mentors mentioned at the project description, write them an e-mail and you'll see
08:37:11 <philippD> What are the current solutions for overloaded records?
08:37:54 <fen> whats Cofree f (g a) ?
08:39:06 <fen> particularly, is having g a = (i,a) in this cofree then like having Cofree' f a = Cofree1 a (f (Cofree' f a)) | ... where these options are like i?
08:39:16 <Solonarv> philippD: there are some (unsatisfying, IMO) GHC extensions, and a handful of libraries (vinyl comes to mind, but there are others)
08:40:49 <fen> like if i = Bool then there are 2 constructors... basically, if `i' is a sum type, then this sum is lifted up into the cofree...
08:41:26 <Solonarv> fen: no. Cofree f (g a) is isomorphic to Fix (Λr. (g a, f r))
08:41:29 <fen> maybe it would not work if it was a product type...
08:41:39 <philippD> My current problem is that I want to create some datatypes to deserialize some JSON/YAML files that use common fields like `name` and such. What would be the best solution for this?
08:42:30 <Solonarv> my approach would be to not rely on auto-generated parsers at all, so there doesn't need to be any particular relationship between JSON field names and record field names
08:43:23 <fen> so Fix (Λr. ((Bool,a), f r)) /= Fix (Λr. Either (a, f r) (a, f r)) ?
08:44:01 <Solonarv> no, those are isomorphic
08:44:13 <fen> yeah, thats the point
08:44:22 <fen> would it work with product types?
08:44:42 <Solonarv> there are a lot of type variables involved here
08:44:46 <Solonarv> which of them is a product type?
08:44:58 <fen> oh, like how bool is a sum type, and corresponds to Either
08:45:19 <fen> could see it working if Bool was extended to Nat
08:46:46 <fen> ((Bool,a), x) === Either (a, x) (a, x)
08:48:00 <fen> but really, using fix kind of messed up the idea, because it was supposed to continue commuting the sum type into the overall recursive datatype
08:48:52 <fen> it was supposed to be able to represent e.g. Skip2 a = Skip1 (Skip2 a) | Skip2 (Skip2 a) | Value a | End
08:49:38 <fen> which looks like Cofree Maybe (Either Bool a)
08:50:20 <fen> no thats wrong...
08:50:30 <Solonarv> Cofree doesn't seem like a very natural representation of that tbh
08:50:59 <fen> thats why it was Cofree f (g a)
08:51:07 <Solonarv> ...that's still Cofree though?
08:51:22 <hodapp> Covfrefe?
08:51:38 <fen> but it can have things other than values at the nodes
08:52:05 <Solonarv> Free seems like a better factoring, or just use Fix directly
08:52:23 <fen> the g a = Either i a means it can have at most one value, or some other data, like the Skip2 
08:52:53 <Solonarv> yeah I guess it works, but it seems overly complicated to me
08:53:11 <fen> maybe it was ok... Cofree Maybe (Either Bool a) === Skip2 a
08:53:36 <fen> its just an idea to illustrait this commuting of the value into the shape of the container 
08:54:07 <fen> seems like we could get a notion of curvature if i was continuous
08:54:40 <fen> which would correspond to an infinite sum type 
08:54:54 <fen> if commuted to the outer datatype
08:56:07 <fen> and then if f of Cofree were more than just Maybe, like if it were [], then it would be a tree like thing, and maybe the curvature now could be over a surface
08:56:54 <fen> and then there would be something like parallel transport if paths along different directions were taken and the `i's encountered along the way were compared
08:57:22 <fen> (trying to get a geodesic or connection)
08:57:58 <fen> notion of distance for lambda terms between continuous input/output values seems natural
09:03:44 <iqubic> free and cofree confuse the heck out of me.
09:11:31 <[exa]> iqubic: that's a reasonable intuition, in fact
09:15:00 <Solonarv> % :t confusing -- couldn't resist
09:15:00 <yahb> Solonarv: Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
09:20:16 <nshepperd1> :t fusing
09:20:17 <lambdabot> Functor f => LensLike (Yoneda f) s t a b -> LensLike f s t a b
09:29:22 <iqubic> Solonarv: The heck???
09:30:09 <Solonarv> those functions are used to make large optics more efficient
09:30:49 <Solonarv> 'confusing l' does the same thing as 'l', but if 'l' is a lot of optics composed together, 'confusing l' can be more efficient
09:33:00 <iqubic> That's `confusing` for you.
09:37:04 <iqubic> When will dependent haskell become a thing?
09:40:37 <Solonarv> iqubic: that's Richard Eisenberg's (AKA goldfire here on IRC) thesis
09:44:07 <iqubic> Making dependent Haskell?
09:44:18 <Solonarv> yup
09:46:44 <Solonarv> let me see if I can find a useful link
10:06:01 <Solonarv> this is a bit old, but: https://typesandkinds.wordpress.com/2016/07/24/dependent-types-in-haskell-progress-report/ -- iqubic
10:07:47 <monochrom> Heh for a few seconds I thought "2019-20" meant "year 2019, month 20, wait how did we get 20 months?!"
10:08:18 <Solonarv> haha
10:09:23 <Solonarv> ah, I found a newer link: https://redd.it/8cp2zg -- the top comment links a bunch of relevant GHC proposals
10:12:42 <joncol> Hi, I get a weird type error when trying to switch to using monad transformers for my megaparsec parsers. Simple 2-line example at: https://gist.github.com/joncol/21a15b490057a51a61d0a6ca1c880cb9
10:13:27 <Rembane> joncol: What's the type of empty?
10:14:12 <monochrom> I think the error message says it all.
10:14:29 <cocreature> add a Token s ~ Char constraint
10:16:17 <iqubic> is `~` a GHC syntax thing?
10:16:58 <Solonarv> it's extension which GHC implements
10:16:59 <cocreature> iqubic: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#equality-constraints
10:17:15 <Solonarv> I don't know if any other (non-GHC-based) compilers implement it
10:19:07 <cocreature> there are no non-ghc-based compilers that anyone cares about anyway so it doesn’t matter all that much :)
10:19:45 <Solonarv> IIRC there's just uhc, which is used in one uni's courses
10:20:06 <Solonarv> (and a handful of outdated ones)
10:20:22 <merijn> And the internal ones at SBC, which, presumably, the SBC employees care about ;)
10:21:53 <cocreature> well they’re not even trying to be compatible with the Haskell standard given that they are strict
10:28:37 <iqubic> Does anyone use Hugs or jhc anymore?
10:30:17 <merijn> iqubic: I should hope not
10:32:53 <__monty__> There's also eta : >
10:33:51 <__monty__> What's SBC btw? SBC communications?
10:35:16 <wroathe> So GHC's warnings are flagging me for having "orphan" instances for ToJSON and FromJSON in my code
10:35:18 <cocreature> eta certainly doesn’t qualify as non-ghc-based
10:35:34 <merijn> __monty__: eh, SCB, I guess. Standard Chartered Bank
10:35:44 <wroathe> Being that I'm not the author of Aeson or the type that I'm defining a ToJSON instance for, what's the course of action here?
10:35:58 <Solonarv> wroathe: use a newtype wrapper, or turn off the warning
10:36:09 <merijn> wroathe: Define a newtype around the type your making the instance for, or learn to live with it
10:36:36 <Solonarv> or just write standalone thatTypeToJSON / thatTypeFromJSON functions
10:36:57 <wroathe> In this case the type is an XML libraries' "Node" type
10:37:31 <__monty__> merijn: Oh, : /, thought there was *another* big haskell user.
10:37:48 <monochrom> Perhaps find out what are the bad consequences of orphan instances, then make a judgment on whether they actually affect your use case (or even whether you care).
10:38:29 <wroathe> Yeah, I think I understand the bad consequences of orphan instances. In this case it's theoretically possible for a user of my thing to define instances for the types I'm defining instances for...
10:38:41 <wroathe> But I wonder how likely that is in practice
10:39:09 <wroathe> And to what degree other library authors are utilizing orphaned instances
10:39:17 <monochrom> If you're publishing a library, it is highly contentious.  If you're keeping your library private, or you are just having an exe, you are pretty safe.
10:39:44 <monochrom> The other bad consequence is orphan instances kill separate compilation.
10:40:30 * hackage aeson-filthy 0.1.3 - Several newtypes and combinators for dealing with less-than-cleanly JSON input.  https://hackage.haskell.org/package/aeson-filthy-0.1.3 (AlecHeller)
10:40:47 <wroathe> This to me seems like a huge wart on the concept of typeclasses
10:40:59 <wroathe> One that you run into almost immediately
10:40:59 <Solonarv> orphan instances are problematic, yes
10:41:10 <wroathe> (not that they're not a useful thing)
10:41:14 <Solonarv> there's a reason for the warning!
10:42:08 <wroathe> In this case I think the newtype wrapper might be my cleanest course of action
10:42:24 <wroathe> Because the user of my thing would not be providing values of the types I'm wrapping to my library
10:46:43 <wroathe> Are there any extensions that make GHC just pick an instance when there are conflicting instances?
10:46:55 <wroathe> The reason I ask is because that seems like it has the potential to be a huge security vulnerability
10:47:47 <joncol> cocreature: Thanks, adding that constraint helped.
10:51:22 <Solonarv> if there are multiple instances with the same head, GHC will barf an error at you
10:52:33 <gentauro> any alternatives to YQL to use as `test` service for examples? Apparently Yahoo pulled the plug and this doesn't work anymore :( `https://query.yahooapis.com/v1/public/yql?q=select ...`
10:52:34 <merijn> Solonarv: If you're lucky...
10:53:24 <Solonarv> if it *actually* the same head and they're both in scope at the location where they're used, yes... in other situations you'll get subtly wrong behavior :/
10:59:45 <Zvpun> How would one memoize `isInRange a b x = a <= x && x <= b`. I was reading wiki.haskell.org/Memoization but I none the wiser now.
11:10:19 <lyxia> why would you want to memoize that
11:10:34 <Zvpun> mostly to learn
11:11:38 <lyxia> memoized isInRange = memo2 isInRange    -- https://hackage.haskell.org/package/MemoTrie-0.6.9/docs/Data-MemoTrie.html#v:memo2
11:12:06 <lyxia> memoizedIsInRange  = memo2 isInRange
11:16:02 <wroathe> So it seems to be a common pattern to wrap types in a newtype just to define instances for them. Is there a generic way of doing this? And maybe a predefined generic "newtype Foo a" that people use?
11:16:34 <merijn> wroathe: Define "generic way of doing this"?
11:16:36 <wroathe> that is, so that I don't need to define newtypes in my own library/application
11:16:44 <glguy> No, if the point is to define your own instances then you wouldn't want a shared newtype
11:17:22 <wroathe> glguy: Oh, I see
11:17:26 <merijn> wroathe: Then they'd still be orphan instances ;)
11:17:35 <wroathe> Yup
11:17:37 <wroathe> I just realized that
11:17:57 <merijn> wroathe: But maybe you'll be happy to learn about GeneralizedNewtypeDeriving :)
11:18:09 <koz_> Or DerivingVia.
11:18:09 <wroathe> Sometimes saying something stupid just to hear the sound of your own voice leads to an epiphany
11:20:28 <wroathe> merijn: If I understand that extension correctly, the reason that won't work is that the inner type doesn't have an instance of the class yet
11:21:09 <wroathe> merijn: And deriving an instance for the inner type would lead to an incorrect implementation for my needs
11:21:11 <merijn> wroathe: It won't for the class you're implementing, but it means you won't have to manually reimplement all other instances
11:21:46 <merijn> wroathe: So, say you're wrapping Int with a newtype, you can derive Num, so you can still use * + etc with your newtyped value
11:25:22 <adius> Hi, what's a good way to keep a local SQLite database and a remote one in sync? It should be possible to work on the local one with automatic syncing as soon as it's back online. Is there some good package helping me to achieve this?
11:26:07 <wroathe> adius: It sounds like you don't want sqlite
11:26:20 <wroathe> adius: Now that you're getting the network involved
11:27:05 <wroathe> And if you just want backups you can literally just copy the db file to your backup directory
11:27:50 <wroathe> Otherwise https://www.sqlite.org/backup.html
11:29:05 <adius> SQLite data storage is an explicit feature, so yes, I want SQLite. It's not just a means to store some data in this case 😉
11:31:02 <merijn> adius: Just copy the file? :p
11:31:17 <merijn> adius: Or you wanna keep them in sync live?
11:32:01 <adius> In sync live. I'm hoping for some easy syncing package maybe based on https://raft.github.io/
11:33:14 <adius> But haven't worked with consensus algorithms before, so maybe there is something easier / more fitting
11:33:53 <merijn> adius: Yeah, I highly doubt you're going to find something existing and implementing such a thing will be HARD
11:34:40 <adius> Ideally it would be some kind of fault tolerant peer to peer syncing 😅
11:36:03 <wroathe> merijn: And also not really the use case sqlite is designed for
11:36:24 <adius> I guess I should look into https://github.com/rqlite/rqlite
11:36:31 <xsperry> why can't I use ~ as a function name? what is using it?
11:36:39 <xsperry> I don't remember ~ being part of haskell syntax
11:37:35 <c_wraith> it is a valid operator character
11:37:58 <c_wraith> > let x ~ y = x * y + 1 in 2 ~ 3
11:38:00 <lambdabot>  error: Pattern syntax in expression context: ~3
11:38:00 <xsperry> not what ghc is telling me!
11:38:10 <c_wraith> hah, by itself it isn't
11:38:14 <lyxia> it's the lazy pattern syntax
11:38:15 <xsperry> hmm
11:38:15 <c_wraith> > let x ~~ y = x * y + 1 in 2 ~~ 3
11:38:17 <lambdabot>  7
11:38:24 <c_wraith> it *is* a valid operator character
11:38:35 <c_wraith> but ~ is reserved syntax
11:39:15 <c_wraith> > case undefined of (a, b) -> 7
11:39:17 <lambdabot>  *Exception: Prelude.undefined
11:39:21 <c_wraith> > case undefined of ~(a, b) -> 7
11:39:23 <lambdabot>  7
11:39:35 <c_wraith> as lyxia says, lazy pattern match
11:39:54 <xsperry> hmm!
11:39:58 <xsperry> not sure when I'd want that
11:40:11 <xsperry> is that standard haskell?
11:40:15 <lyxia> it i
11:40:17 <c_wraith> yep, that's standard
11:41:03 <c_wraith> xsperry: https://stackoverflow.com/questions/42150614/why-is-the-lazy-pattern-match-version-of-splitat-function-faster/42151076#42151076
11:41:18 <nitrix> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html
11:41:31 <nitrix> See irrefutable patterns.
11:41:53 <xsperry> c_wraith, interesting
11:49:23 <nshepperd> > case undefined of { pair -> let a = fst pair; b = snd pair in 7 } -- basically equivalent to the lazy pattern match
11:49:25 <lambdabot>  7
11:50:55 <nshepperd> ~ is also type equality, but i think that theoretically wouldn't interfere with it being a function name
11:51:50 <hpc> the pattern language and type language are always easily distinguishable
11:56:59 * hackage language-oberon 0.2.1 - Parser, pretty-printer, and type checker for the Oberon programming language  https://hackage.haskell.org/package/language-oberon-0.2.1 (MarioBlazevic)
11:57:49 <xsperry> lenses compose backwards. was that a conscious choice or just a consequence of how they are implemented
11:58:11 <lyxia> happy coincidence
12:01:03 <hpc> happy coincidences are how you know you have the right abstraction
12:01:56 <xsperry> so that is the only way that they could compose?
12:02:06 <xsperry> weird, since, as I understand, they are just functions
12:04:42 <c_wraith> it's the direction functions compose
12:05:00 <c_wraith> lenses are functions from modifier to modifier
12:05:50 <xsperry> c_wraith, what do you mean?   (lensPerson.lensName) is backwards compared to (fieldName . fieldPerson) 
12:06:47 <c_wraith> but lenses aren't accessors, they're modifiers.
12:07:41 <c_wraith> actually, modifier transformers.
12:07:52 <lyxia> I'm sure you could devise a representation of lenses that "composes" the other way around with (.).
12:08:28 <lyxia> you could also use a non-functional representation of lenses, that wouldn't use (.) at all.
12:10:33 <Solonarv> a Lens' s a turns "actions on a" into "actions on s"
12:11:43 <iqubic> I suppose that's a way to think about it.
12:18:58 <joncol> So, next error: https://gist.github.com/joncol/21a15b490057a51a61d0a6ca1c880cb9. What am I missing?
12:23:35 <joncol> Oh, that was not at all right... The argument to `symbol` should be Text...
12:25:24 <joncol> Nvm, fixed it :/ (should sleep)
12:25:55 <monochrom> :)
12:26:59 * hackage rank2classes 1.2.1 - standard type constructor class hierarchy, only with methods of rank 2 types  https://hackage.haskell.org/package/rank2classes-1.2.1 (MarioBlazevic)
13:23:59 * hackage hoogle 5.0.17.5 - Haskell API Search  https://hackage.haskell.org/package/hoogle-5.0.17.5 (NeilMitchell)
13:24:15 <Amras> ooh, hoogle update
13:29:18 <hpc> hackagebot is like irc santa
13:30:21 <Ariakenom> ski: what was the name of the haskell scandinavia channel?
13:35:34 <phi> Hi, can anyone comment on the accuracy of Double (as opposed to flating-point numbers in other languages)? I've just implemented a simple euler-method function, but it seems it's far less accurate than what python or java would calculate. 
13:36:54 <hpc> Double is IEEE double
13:37:06 <hpc> it behaves exactly like double in other languages, for better or (often) worse
13:37:25 <phi> so that means it's most probably a mistake I made?
13:37:31 <hpc> most likely
13:38:08 <hpc> floating point math is sensitive to order of operations
13:38:16 <hpc> for instance, (huge number - huge number) + 1 = 1
13:38:22 <hpc> but (huge number + 1) - huge number = 0
13:38:30 <hpc> for sufficiently huge numbers
13:38:35 <__monty__> Double's actually "at least" as precise and big as IEEE doubles, technically.
13:38:45 <abhixec> Is "hakell book" good for someone  with programming experience to learn haskell? 
13:39:15 <iqubic> Which bood is that?
13:39:23 <iqubic> Can we get a link?
13:39:47 <MarcelineVQ> abhixec: yes
13:39:58 <phi> hpc: That shoudln't be the issue in my case, all the numbers are reasonably small...
13:41:40 <abhixec> MarcelineVQ: thanks :) 
13:41:41 <__monty__> iqubic: It's literally 'haskell book' afaik. Don't like it because of all the fighting between the authors though. I'd much rather promote the work of people who didn't allegedly exploit a co-author. Like hutton's.
13:42:23 <_lerk_> attribution notwithstanding, is the content and material presentation good?
13:42:32 <abhixec> iqubic: http://haskellbook.com/ 
13:43:43 <abhixec> __monty__: out of curiosity I would like to read about that if there is any article or blog post somewhere?
13:43:53 <MarcelineVQ> Not liking content due to things external to content is nonsensical. Prejudging based on allegations is further nonsensical, if not actually damaging. Where did you hear these things?
13:44:58 <phi> abhixec: I'm currently reading that book, and I think it's quit good. Some chapters are trivial but they can easily be skipped if one has general programming experience.
13:45:09 <abhixec> anyways I am going to embark on reading that book! thanks MarcelineVQ for vote of confidence :D 
13:45:14 <abhixec> phi: thanks! 
13:46:18 <__monty__> MarcelineVQ: From said co-author.
13:46:24 <__monty__> *on twitter though.
13:46:47 <__monty__> abhixec: I don't have a good link you might find something googling but it was mostly twitter.
13:48:02 <__monty__> MarcelineVQ: I don't say I don't like the content. But I won't support someone financially when there's doubt about the honesty of their intentions. And it's not as if the haskellbook is cheap. So yeah, it matters. Throwing money at it is like saying I'm fine with the way you treat people.
13:49:10 <MarcelineVQ> What was the intention of writing the book?
13:52:26 <__monty__> Making good haskell teaching material. And the concept was great for that.
13:52:59 <__monty__> I didn't like the cult following though. And I've heard quite a few critiques about the quality of the material being overblown.
13:53:27 <abhixec> Sorry for offtopic: this is one of side of story : http://bitemyapp.com/posts/2018-10-03-wrapping-up-haskellbook.html from one of the authors. I just want to learn haskell so I will drop out of this discussion at this point :P (why I posted that link? hope that there will be a finished book product for someone who spends $50 some time soon)
13:54:10 <__monty__> abhixec: Good luck learning haskell, it's great fun!
13:54:26 <__monty__> And you should feel welcome to join here with questions.
13:54:45 <__monty__> There's usually plenty of patient people around to help you.
13:55:15 <__monty__> And sorry for bringing up the ugly side of this but that's what ugly things do.
13:55:40 <abhixec> thanks! I want it for xmonad, xmobar, hakyll primarily
13:56:27 <jbetz> https://github.com/CoNarrative/precept <-- is a declarative framework like this possible in Haskell? I'm not sure what the requirements are exactly, but I know that Clara (the underlying rules engine) uses a lot of macros to build its network at compile time
13:56:28 <abhixec> good to know :) I certainly will not shy from asking dumb questions(if DDG can't answer it)!
13:57:00 <__monty__> abhixec: Sounds like pandoc'd suite you well too. Though hakyll probably already uses that.
13:57:10 <Solonarv> Indeed it does
13:58:50 <Solonarv> jbetz: seems vaguely similar to FRP
13:59:05 <jbetz> I know that at least the Rete algorithm has already been implemented in Haskell, but actually being able to define rule conditions that match on multiple slots seems like it'd be tricky
13:59:20 <__monty__> Also looks like the safe HTML DSLs, blaze for example.
13:59:33 <MarcelineVQ> __monty__: You've seen a cult following? that idea is weird to me, just about any time I've seen hpffp brought up on irc it's alongside suggestions to check out other texts as well, huttons being a popular/quality one like you mentioned earlier.
14:00:50 <jbetz> Solonarv: it could probably be layered on top of a FRP engine, but I don't think FRP alone is good enough
14:01:12 <Solonarv> I figured as much, that's why I only said "vaguely similar"
14:02:16 <jbetz> presumably if you could do prolog in haskell, that'd be enough, but I don't think you can?
14:02:36 <__monty__> MarcelineVQ: It's way less now but a while back it seemed like *everyone* was recommending haskellbook for people looking for material at *any* level.
14:04:32 <__monty__> jbetz: This goes in the direction at least: http://hackage.haskell.org/package/logict
14:04:34 <Solonarv> you can, actually
14:04:48 <__monty__> At the type level? : >
14:06:04 <jbetz> forward *and* backward chaining?
14:06:13 <Solonarv> type-level, or using lists
14:06:17 <abhixec> __monty__: that too :P I am kind of centering alot of daily driver applications to use haskell to give the push to learn and get good at it! :D 
14:06:22 <phi> Sorry for interrupting again, but can anyone recognize anything wierd with this function: http://ix.io/1znM/haskell
14:07:42 <Solonarv> or by (essentially) implementing a full "prolog engine"
14:07:51 <MarcelineVQ> phi: If it doesn't compile you need to include the error. If it compiles then you should say what input you gave it, what you expected to get, and what you actually got.
14:08:06 <MarcelineVQ> Unless you're asking about style. weird is a vague term :>
14:08:29 <phi> MarcelineVQ: It compiles corretly, and *seems* to work, it's just that it doesn't seem to calculate the same as other languages do...
14:09:50 <jbetz> Solonarv: I've heard people say that prolog's been implemented in haskell as an eDSL, but I've never found one, only pointers to the `logict` package that __monty__ mentioned
14:10:07 <__monty__> jbetz: hswip?
14:10:22 <MarcelineVQ> What does calculate the same mean?
14:10:27 <__monty__> There's also multiple prolog implementations on hackage.
14:10:59 <Solonarv> I don't know of any concrete implementations and I'm only vaguely aware of prolog as a whole, so I can't search efficiently
14:12:14 <phi> MarcelineVQ: I'm using this to play around with numerical algorithms for ode's, and a solver in python gives a lot better results with the same inputs (eg. timesteps) than the haskell programm. 
14:13:08 <phi> If it helps, this is the whole program: http://ix.io/1znT/haskell
14:13:45 <jbetz> __monty__: I think hswip is just passing in prolog programs as text?
14:14:27 <MarcelineVQ> so you wanted to ask "Can anyone tell me why my function is slow?"
14:15:00 <fragamus> what are quantifiers:    'Rank-n polymorphism is polymorphism in which quantifiers may appear to the left of arbitrarily many arrows."
14:15:10 <hpc> fragamus: forall
14:15:16 <fragamus> gotcha
14:15:32 <hpc> ((forall a. a -> a) -> a -> a) is an example of a higher-ranked type
14:16:03 <hpc> the first function has to be as polymorphic as the forall says it is
14:16:20 <hpc> so the only value of that type is ($), but the only function you can pass as the first parameter is id
14:16:28 <__monty__> jbetz: Well, basically. You can do prolog calls in the IO monad it seems.
14:19:36 <jbetz> yeah. I'm going to see how far I can get with `logict` before sinking to that sort of thing.
14:19:41 <MarcelineVQ> hmm, was kind of hoping for a response to that, should have put a ? at the end I guess
14:20:34 <hpc> fragamus: actually, to write that type without shadowing type variables, it's ((forall a. a -> a) -> b -> b)
14:21:50 <fragamus> ok cool
15:24:48 <ski> Ariakenom : #haskell.scandinavian
15:49:29 * hackage bv-embed 0.1.0 - Define embeddings of small bit vectors into larger ones  https://hackage.haskell.org/package/bv-embed-0.1.0 (benselfridge)
16:07:16 <Ariakenom> ski: thanks
17:48:17 <iqubic> ski: If I give you a string like: "1 + 2 ^ 3 * 4 + 3" How would you implicitly bracket that. Trying to figure out how my parser should work.
17:52:59 <Solonarv> iqubic: 1 + ((2 ^ 3) * 4) + 3
17:53:49 <iqubic> So (^) is a special snowflake?
17:54:59 <iqubic> No it isn't/
17:59:09 <Solonarv> not a special snowflake, it just has higher precedence than */
17:59:39 <iqubic> Why is it hard to make a right associative parser?
18:01:25 <iqubic> Like I don't know where to start with this.
18:09:25 <Amras> do you want your right-associative parser to respect operator precedence?
18:09:29 <Amras> I'm confused
18:10:31 <Amras> (also with my tongue a bit deeper in my cheek: building a right-associative parser is easy, just build a left-associative one and reverse your input)
18:11:50 <iqubic> Amras??? LOL.
18:35:25 <iqubic> So how do I make a right assoicative parser?
18:40:45 <iqubic> :t liftM2
18:40:46 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:40:57 <iqubic> :t liftA2
18:40:59 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
18:41:28 <Solonarv> liftM2 is mostly a historical artifact
18:41:33 <iqubic> It is?
18:41:35 <iqubic> I see.
18:41:45 <Solonarv> yes, from before Applicative was a superclass of Monad.
18:42:30 <iqubic> Solonarv: writting a parser that can parse "num^num^num" as "num^(num^num)" is hard.
18:43:07 <iqubic> I have a parser for num, and a parser for "^" of the type Parser (Expr -> Expr -> Expr) but I have no clue how to combine them.
18:43:24 <iqubic> num :: Parser Expr
18:43:32 <Solonarv> I'd just use do notation tbh
18:43:42 <iqubic> pow :: Parser (Expr -> Expr -> Expr)
18:44:00 <iqubic> Solonarv: I know that, but I'm not sure how to put the pieces together.
18:45:43 <iqubic> Solonarv: I have this, but IDK if it works.
18:45:55 <iqubic> http://dpaste.com/0YXQ1S5
18:46:57 <iqubic> does that look good?
18:47:06 <Solonarv> it will loop forever
18:47:27 <Solonarv> this parse expects and endless stream of num^num^num^num^num^...
18:47:38 <iqubic> So how do fix this?
18:48:20 <Welkin> > fix error -- iqubic 
18:48:22 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
18:49:10 <iqubic> Does that help me with my current problem of an infinite loop?
18:49:22 <Solonarv> no
18:49:39 <Solonarv> you need (<|>)
18:49:52 <Solonarv> I'm pretty sure you've used it before, for the rest of your parser
18:49:55 <iqubic> my grammar needs to be more complex than this, I think: "expr ::= number op expr"
18:50:01 <iqubic> Solonarv: Yes, I have.
18:50:33 <iqubic> I think I need something better than that current grammar.
18:50:39 <iqubic> But I'm not sure what.
18:53:51 <Solonarv> iqubic: mind posting your full parser so far?
18:54:38 <iqubic> I'd rather not. Sorry. It's a bit of a large mess.
18:56:01 <maerwald> we won't judge ;)
19:09:43 <iqubic> So how do I use alternatives to fix my parser?
19:10:14 <Welkin> it allows branching
19:10:41 <iqubic> I know, but how does this branching stop me from getting an infinite loop?
19:11:29 <Welkin> there are a finite number of branches to try, and then it should fail
19:11:34 <Solonarv> I'm too tired to explain properly, but I threw together a small example parser you can have a look at: https://gist.github.com/Solonarv/99826c2b472052c451b0f3b610bb9673
19:11:39 <Welkin> unless you are backtracking and retrying the same thing over and over again
19:11:53 <Solonarv> I didn't actually test it, mind.
19:36:50 <iqubic> Solonarv: Your parser works great, except for one slight flaw. All the operators have LEFT precedence.
19:37:07 <iqubic> I want to give (^) RIGHT precedence.
19:39:45 <Solonarv> heh
19:40:09 <Solonarv> remind me tomorrow if you want, I'm too tired to fix it now
19:41:09 <iqubic> I want to think on this myself. It's a good challenge for me to think about.
19:46:12 <Welkin> iqubic: then declare it as infixr
19:46:27 <Welkin> oh, you mean in your language that you are parsing
19:48:59 <wroathe> Do you guys have any nominations for libraries that do errors/exceptions in an good way?
19:49:26 <pfurla_> isn't there a `combinations :: Int -> [a] -> [[a]]` to produce a list of combinations of [a] with a size n in Prelude?
19:49:52 <Solonarv> sounds niche enough that it might not be in the prelude
19:49:59 <Solonarv> have a look in Data.List
19:50:44 <wroathe> There's obviously a few ways to model it... Maybe, Either String a, a sum ADT with all of the possible exception cases
19:50:45 <pfurla_> wroathe EitherT and ExceptT and Validation
19:51:41 <Solonarv> 'Either WhateverException a' (or the transformer equivalent) has ym vote
19:51:57 <Solonarv> WhateverException is an ADT describing the error
19:51:57 <monochrom> wroathe: If it's IO I would use IO's exception system (Control.Exception).  If it's pure functions I would use Except which is like Either (Control.Monad.Except IIRC)
19:52:40 <pfurla_> monochrom how is Except different from either?
19:52:50 <wroathe> These all sound like what I was thinking, but I was more interested if on if you guys have any libraries that you think do these well?
19:55:51 <pfurla_> oh, Hayoo is down :(
19:56:04 <Welkin> what do you need to search?
19:56:23 <Welkin> if you know which package it's in, you can go to the hackage docs and press 'S' on your keyboard
19:56:35 <Welkin> that brings up a very useful search tool
20:03:41 <Solonarv> (note: do *not* do this on large packages)
20:04:13 <Solonarv> I've killed my browser doing that on OpenGLRaw
20:04:35 <Welkin> in that case you'd be better off downloading the source and running grep/ag
20:05:29 <pfurla_> Hayoo answers are usually better and covers more libraries than Hoogle
20:27:29 * hackage continued-fractions 0.10.0.0 - Continued fractions.  https://hackage.haskell.org/package/continued-fractions-0.10.0.0 (rockbmb)
20:49:19 <iqubic> Yeah, so parsing binary operations with right precendence is a lot harder than parsing it with left precedence.
21:23:45 <dmj`> I have some extra object files I'd like to link with in my library, how can I tell cabal to pass these in on the command line i.e. get cabal to invoke ghc like `ghc lib/somelib.dylib -o main`
21:24:32 <dmj`> I've also noticed the foreign-library stanza in cabal, is there a way to use this, specifying a compiler
21:28:22 <dmj`> don't want to resort to a custom Setup.hs
22:54:06 <dminuoso> @tell v0d1ch Oh my, the type signatures of `seek` and `seeks` had a gross mistake which I just fixed. :|
22:54:06 <lambdabot> Consider it noted.
22:56:26 <dminuoso> @tell v0d1ch And maybe there was not any mistake! It's never a good idea to have grand revelations early on the morning before your first coffee.
22:56:26 <lambdabot> Consider it noted.
23:15:09 <charukiewicz> What's the difference between Wunused-imports and fwarn-unused-imports as far as GHC options go?
23:17:05 <libertyprime> could somebody please explain to my noobishness why it is that when i hoogle for -> it tells me "Unknown flag: ->"
23:20:14 <dminuoso> libertyprime: Which URL are you using?
23:20:47 <dminuoso> libertyprime: Or rather.. using what tool?
23:21:33 <dminuoso> Neither https://www.stackage.org/lts-13.5/hoogle?q=-%3E, https://www.haskell.org/hoogle/?hoogle=-%3E nor https://hoogle.haskell.org/?hoogle=-%3E give me that error =)
23:22:06 <libertyprime> just using the CLI hoogle binary. cant remember where it camt from to be honest! :P
23:22:17 <libertyprime> trouble is, emacs uses it too
23:23:09 <_deepfire> libertyprime: try "(->)" instead, I'm not sure, but it might work
23:23:39 <libertyprime> oh interesting. yeah im getting results now
23:23:54 <libertyprime> by the way, i am truly a noob. is -> only used when defining a lambda?
23:25:23 <dminuoso> libertyprime: As far as I know, though there might be some odd exception...
23:26:10 <libertyprime> i guess it make sense that it doesnt appear in hoogle if it's a really low level part of syntax
23:26:35 <dminuoso> libertyprime: Right, hoogle only gives you identifiers, data constructors, type constructors..
23:26:43 <dminuoso> (->) is part of Haskell syntax.
23:26:43 <_deepfire> (->) is also a type constructor of kind (* -> * -> *)
23:27:31 <glguy> As a type, -> is for functions. As syntax of expressions it's part of case alternatives, and anonymous function definitions
23:27:37 <dminuoso> libertyprime: Oh and typeclasses. Basically stuff you can export/import from modules. :)
