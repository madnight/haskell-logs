00:03:02 <charukiewicz> Does `stack build` not read ghc-options defined in a .cabal file?
00:08:44 <glguy> It should, but only for that package and not for any dependencies
00:09:42 <charukiewicz> So it's better to put any options into the project's stack.yaml?
00:13:17 <glguy> No not better, different
00:15:30 <charukiewicz> Well specifically I'm trying to add a -static flag somewhere
00:16:40 <charukiewicz> I run into an issue where I get the following error 'requires unsupported dynamic reloc 11; recompile with -fPIC', but I've tried adding -fPIC to stack.yaml, and my project.cabal under both executable and lib clauses
00:17:07 <charukiewicz> Looks like this might just be a stack issue: https://github.com/commercialhaskell/stack/issues/4194
01:02:22 <gentauro> I request some feedback on modeling `finite state machines` (FSM) with types in Haskell (minimizing implementation issues) http://blog.stermon.com/articles/2019/01/28/haskell-revised-model-state-machines-with-types.html
01:02:45 <gentauro> is this an OK approach or would you use another?
01:03:42 <gentauro> (the code snippet is "heavily" inspired in -> https://wiki.haskell.org/Smart_constructors#Enforcing_the_constraint_statically)
01:04:34 <dminuoso> gentauro: You might want to look at GADTs.
01:04:38 <gentauro> tl;dr We have to States (Off and On), which can Transition from Off -> On and viceversa
01:05:12 <gentauro> but if you are Off, you can only transition of On and if you are On, you can only transition to Off
01:05:29 <merijn> I second looking at GADTs, together with DataKinds :p
01:06:16 <gentauro> for the library, the logic is designed in to the type system. No implementation details whatsoever (all exposed functions, are implemented as `undefined`)
01:06:52 <dminuoso> gentauro: jle has a really nice series of blog posts on exactly that topic: https://blog.jle.im/entries/series/+introduction-to-singletons.html
01:07:54 <gentauro> dminuoso: `data DoorState = Opened | Closed | Locked` gonna read that :-)
01:10:57 <dminuoso> merijn: I guess the main power of using GADTs with singletons is type refinement?
01:14:21 <bahamas> hello. if I've pattern-matched a constructor in a function, is there a way to avoid pattern-matching again in other functions that take the same value and that I call inside the handler of the first pattern match? 
01:15:19 <opqdonut> yes, for example by passing the fields individually to the other functions
01:15:35 <opqdonut> so something like "f (Foo a b) = bar (quux a b)"
01:15:49 <opqdonut> instead of "f foo@(Foo _ _) = bar (quux foo)"
01:16:06 <opqdonut> GADTs and narrowing permit some fancier variants of this
01:16:31 <opqdonut> but I guess the short answer is "try to give the functions you call narrower types"
01:17:24 <gentauro> opqdonut: how are those to `snippets` of code equivalent?
01:17:40 <gentauro> the first takes `a` and `b`, while the second, takes `Foo`?
01:19:04 <dminuoso> gentauro: foo carries the same information as `(a, b)`
01:19:23 <dminuoso> % data Foo = Foo Int String
01:19:23 <yahb> dminuoso: 
01:19:43 <dminuoso> % answer = Foo 42 "universe"
01:19:43 <yahb> dminuoso: 
01:20:32 <dminuoso> gentauro: ^- whether you pattern match onto `Foo num str` and pass `num/str` separately, or you pass the whole data structure is the same.
01:20:57 <opqdonut> gentauro: if you want to express the invariant "quux is only called with constructor Foo", you need to give quux some other type
01:21:22 <merijn> dminuoso: tbh, I try and avoid singletons, because that just leads to pain :p
01:21:48 <bahamas> ok, I think I understand. in my case, I think I can't avoid foo@(Foo _ _), at least it's not obvious how, so I'll just live with this repetition for now
01:22:06 <merijn> bahamas: You can make it more future proof by writing "foo@Foo{}"
01:22:22 <bahamas> merijn: can you elaborate?
01:22:36 <merijn> bahamas: Fun fact most people forget: Record syntax doesn't only work for datatypes defined using record syntax. Empty record selectors work on any datatype
01:22:50 <dminuoso> bahamas: If you add a field to `Foo` you will have to change all pattern matches. :)
01:22:57 <merijn> bahamas: By using an empty record selector (the "{}") your pattern match is indepedent of the number of fields Foo has
01:23:04 <opqdonut> bahamas: one option is to restructure your types a bit, from "data MyType = Foo Int String | Other Bool" to "data MyType = MyFoo Foo | MyOther Other; data Foo = Foo Int String; data Other = Other Bool"
01:23:15 <merijn> So if you add/remove a field it will keep working without the need to update the number of _ entries
01:23:26 <opqdonut> bahamas: then your outer function can take a MyType, and your inner function can take a Foo
01:23:35 <opqdonut> bahamas: but this might make other parts of your code messier
01:23:40 <gentauro> merijn: `By using an empty record selector ...` that I didn't know. Thx !!!
01:23:56 <gentauro> I'm always pattern matching with `Foo _ _ _ _ `
01:24:02 <gentauro> which is kind of annoying !!!
01:24:28 <gentauro> merijn: do you need to enable any pragmas or is it just in Haskell?
01:24:36 <Ferdirand> merijn: how do you decide if this is morally correct, though ?
01:24:41 <merijn> gentauro: That's just standard Haskell
01:24:46 <gentauro> :o
01:25:12 <merijn> gentauro: It's one of those neat things many people never learn and/or forget :)
01:25:31 <Ferdirand> i mean, if you suddently change a constructor to have an additional argument, maybe you actually want to check all match sites for correctness afterwards ?
01:25:32 <merijn> Like how everyone always forgets that pattern guards haven't needed an extension for a decade by now :p
01:25:56 <merijn> Ferdirand: That's up to the programmer to decide
01:25:58 <dminuoso> merijn: I was really surprised to find out that pattern guards work not only on functions, but any value binding!
01:26:18 <dminuoso> merijn: I replaced many where bindings that before used if/then/else with pattern guards, which I find much easier to read. :)
01:27:02 <bahamas> merijn: I understand. thanks!
01:27:12 <dminuoso> Or wait. pattern guards is something different from normal guards, isnt it?
01:27:19 <bahamas> opqdonut: in this particular case, I can't restructure the types, because they come from a library
01:27:20 <merijn> Ferdirand: But there are plenty of times where you want to check a constructor, but then pass the whole field to further code, like the "foo@(Foo _ _)" example before. Especially when you need to pattern match a GADT to bring a type in scope
01:27:41 <merijn> dminuoso: Pattern guards used to be an extension, but is now a normal part of guard syntax
01:27:50 <merijn> dminuoso: Specifically, guards using pattern matching
01:28:11 <merijn> dminuoso: Which means they, also, can be used with any binding :p
01:29:32 <dminuoso> % a | Just x <- Just 10 = x
01:29:33 <yahb> dminuoso: 
01:29:35 <dminuoso>  % :t a
01:29:39 <dminuoso> % :t a
01:29:40 <yahb> dminuoso: Num a => a
01:30:22 <dminuoso> merijn: Cool. At any rate, guards on non-function bindings is a neat thing. :)
01:30:33 <bahamas> to be honest, I remember vaguely that you can transform a data constructor into a type using some extension. I thought I could use that here. is my memory wrong or that doesn't apply in this case?
01:30:41 <dminuoso> bahamas: DataKinds
01:30:56 <dminuoso> % :set -XDataKinds
01:30:56 <yahb> dminuoso: 
01:31:02 <dminuoso> % data State = Open | Close
01:31:02 <yahb> dminuoso: 
01:31:06 <dminuoso> % :k 'Open
01:31:07 <yahb> dminuoso: 'Open :: State
01:31:51 <bahamas> ok, that was the extension I was remembering. so, could I use that to define a function more narrowly as just taking the 'Open type?
01:32:25 <gentauro> merijn: pretty nifty trick !!! 
01:33:01 <dminuoso> bahamas: You should perhaps also take a look at https://blog.jle.im/entries/series/+introduction-to-singletons.html =)
01:34:54 <bahamas> alright
01:36:21 <dminuoso> Or maybe I misunderstand bahamas. Do you want something to just take a `State` that was constructed using the `Open` constructor?
01:36:32 <dminuoso> Then perhaps opqdonut's recommendation is what you want.
01:41:59 * hackage hlint 2.1.14 - Source code suggestions  https://hackage.haskell.org/package/hlint-2.1.14 (NeilMitchell)
03:36:02 <jhaj> I am looking for some advice on the idiomatic way to do the following: I have a type that contains a list of random numbers and the min values in the list, an update function that creates a new list of random numbers and finds the min value, and I want to repeatedly call that function on a given object and ultimately get back the min value
03:36:35 <jhaj> it seems replicateM might be the way to go, but I am having a hard time wrapping my head around how I would structure this as a Monad
03:39:14 <jhaj> the update function looks like `update :: Runner -> Runner` returning the updated object and my ultimate goal is to get update(update(update(...(update(runnerObj)))))
03:40:20 <Logio> is iterate not enough?
03:40:29 <p0lyph3m> jhaj: if update generates new random numbers it should be : update :: Runner -> IO Runner 
03:43:29 <jhaj> I pass in an infinite list of random numbers that I split to generate the new numbers so I can avoid the IO Runner return type. Is that a bad practice?
03:44:13 <jhaj> @Logio: the problem with iterate is it stores the intermediate results
03:44:13 <lambdabot> Unknown command, try @list
03:45:56 <p0lyph3m> if you want to go monadic you can use iterateM_ or iterateWhile from Control.Monad.Loops
03:48:10 <p0lyph3m> :t iterate
03:48:11 <lambdabot> (a -> a) -> a -> [a]
03:49:55 <jhaj> if each a contains a large list, [a] would be unnecessarily expensive with respect to memory right?
03:50:24 <jhaj> especially since each successive element of [a] is generated from the element before it, they all get generated
03:50:31 <jhaj> evaluated I mean
03:50:55 <Lears> :t until -- Maybe you'd prefer this, or a monadic version.
03:50:56 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
03:51:24 <Lears> Though depending on how you work with iterate, it might not use any more space.
03:51:31 <Lears> (I think)
03:53:04 <jhaj> I will experiment with these - I wonder if I can do iterateWhile with some do blocks
03:54:07 <p0lyph3m> jhaj: what do you want to achieve ? iterating and generating obj that you dont use , only the last one , or do you need to perform somthing on each iteration ?
03:54:26 <p0lyph3m> :t iterateWhile
03:54:28 <lambdabot> error: Variable not in scope: iterateWhile
03:55:38 <jhaj> p0lyph3m: I want to do the following some number of times: generate a list of random values, find the min, if the min is less than the min from the prior list of random values, update the min value. At the end of the n iterations I want to return the min value found
03:57:02 <p0lyph3m> jhaj: what about folds
03:57:09 <Ariakenom> jhaj: why are you doing it in chinks?
03:57:13 <Ariakenom> chunks
03:58:11 <p0lyph3m> :t foldl1
03:58:12 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
03:58:29 <jhaj> Ariakenom I am experimenting with the algorithm. Eventually the random values will be replaced with values that are not random
03:59:30 <jhaj> p0lyph3m: foldl1 looks promising
04:02:59 * hackage libraft 0.2.0.0 - Raft consensus algorithm  https://hackage.haskell.org/package/libraft-0.2.0.0 (sdiehl)
04:15:42 <Guillaum> I'm writing a library for which I want to ensure that some haskell expression are not compiling (and I want to compare the error message with a reference file). My test runner is an haskell program built by cabal, but this program must be able to call ghc and that ghc instance must know about the library defined in my cabal file. For now I'm hardcoding a `-package-db dist/package.conf.inplace -package 
04:15:48 <Guillaum> mypackage` but that's not robust because it does not work with new style cabal (directory was renamed to `new-dist`). I can hardcode many configuration, but I'm wondering if there is a known robust solution.
04:16:33 <merijn> Guillaum: I have a neat trick for you :)
04:17:28 <merijn> Guillaum: Instead of trying to compile the file from within your tests, write the failing expressions inside a source file of your tests and compile the test with -fdefer-type-errors
04:17:57 <merijn> Guillaum: That turns the type errors/compile failures into runtime exception, then you can use deepseq to force the expression and catch the exception
04:30:42 <duairc> I'm developing a webapp that uses the diagrams package to draw some charts with text based on user input. It uses SVGFonts, which is known to be rather inefficient, but I'm still baffled by the performance issues
04:31:32 <duairc> If I read NotoSans-Bold and NotoSans-Regular, it takes over 3G of RAM. I could live with that. What I don't understand is that even long after all the diagrams are rendered and served, my app is stick using 80% CPU forever thereafter
04:32:06 <merijn> duairc: Are you, per chance, using the threaded runtime?
04:32:38 <duairc> merijn: I compile with -fthreaded. I don't remember, do I need to pass some +RTS options as well to actually use it?
04:33:04 <merijn> duairc: -fthreaded sounds wrong, GHC normally uses just -threaded (but perhaps the -f version works too)
04:33:24 <merijn> duairc: I suspect you are a victim of "parallel GC is frequently really bad"
04:33:32 <duairc> merijn: Sorry, you're right, it's just -threaded
04:33:43 <merijn> duairc: Can you run the program with "+RTS -sstderr" and pastebin the output of that?
04:33:59 <merijn> (might have to turn on a flag to enable rtsopts)
04:34:17 <duairc> merijn: I tried that earlier and it told me I need to link with -rtsopts or something like that. I'm using nix to build things (which I'm also pretty new to) so I wasn't sure what I needed to do to enable that
04:34:47 <merijn> duairc: I'm assuming you're just using a cabal file to specify things?
04:35:22 <__monty__> Isn't there work on a parallel GC algorithm that might help in this case? Forget what it was called but I saw a talk by bgamari.
04:35:30 <duairc> merijn: Well, there is a cabal file, but that then gets compiled into a Nix expression... but yeah, if there's something I can put in the cabal file that will get put in the Nix expression.
04:35:58 <merijn> __monty__: That's an entirely separate thing for low latency GC, if you're referring to what I think you are
04:36:05 <duairc> But regardless, is there actually some way I can tell GHC "never garbage collect this"? Because I don't want to load and unload the font every time someone tries to draw a diagram, it's fine if it stays loaded forever
04:36:14 <merijn> duairc: Just adding -rtsopts and -threaded to the ghc-options in cabal should work
04:36:37 <merijn> duairc: There's some things you can do, but step one is to check that that *is* what's going on :)
04:38:43 <tombusby> Hi all, I have a quick Q: I'm when, but I'd like something like "whenM". Currently I'm doing this:
04:38:47 <duairc> I guess this is where I have to shamefully admit that I'm using unsafePerformIO to load the fonts. But they're part of data-files of a library I'm using, so it shouldn't ever fail. And it's several libraries deep in my dependency graph, it would be an enourmous pain in the arse to either make all of them depend on IO, or to pass the loaded fonts through all the dependencies, when I know it's going to be 
04:38:54 <duairc> the same every time
04:39:01 <tombusby> do; bool <- someCheck; when someCheck $ action;
04:39:13 <cocreature> tombusby: there is whenM in various packages, e.g., extra
04:39:26 <tombusby> is there a way that I can do something like: when somecheck $ action
04:39:37 <tombusby> cocreature: ok cheers, I'll have a look
04:40:25 <cocreature> or just define it yourself, it’s simple enough :)
04:40:34 <merijn> Or just define your own to skip the dependency
04:42:30 <__monty__> merijn: Ah, right, it was about low-latency.
04:42:59 * hackage registry 0.1.2.4 - data structure for assembling components  https://hackage.haskell.org/package/registry-0.1.2.4 (etorreborre)
04:43:09 <merijn> The problem with the parallel GC is that very high levels of parallelism can cause the synchronisation overhead to cost more than it gains you in performance
04:43:43 <merijn> I had an issue where the parallel GC had my program take 5 minutes to run and the version without parallel GC run in 5 seconds
04:44:29 * hackage registry 0.1.2.5 - data structure for assembling components  https://hackage.haskell.org/package/registry-0.1.2.5 (etorreborre)
04:46:32 <__monty__> Wow, is there any work on improving the parallel GC?
04:47:19 <merijn> __monty__: That assume there is something wrong. GC is "trade-offs all the way down"
04:47:50 <phadej> yes. Don't throw all cores at it: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-flag--qn%20%E2%9F%A8x%E2%9F%A9
04:47:59 <merijn> The assumption behind parallel GC is "you have enough data to make the parallelism worth it" which might not always be the case
04:48:29 * hackage registry 0.1.2.6 - data structure for assembling components  https://hackage.haskell.org/package/registry-0.1.2.6 (etorreborre)
04:49:35 <phadej> it's a myth that GCs doesn't need be tuned for particular programs (i.e. there aren't "super settings" which would work for all programs on all machines, or even for a program on all machiens or all programs on a machine)
04:50:03 <phadej> s/would work/result in the best possible performance/
04:50:15 <cocreature> There is a reason why you can basically make a living out of tuning jvm parameters :)
04:50:35 <phadej> cocreature: :)
04:51:28 <duairc> merijn: Okay, I've got it built with -rtsopts. What should I be looking for?
04:52:34 <__monty__> But a 5s single-threaded program taking 5min doesn't sound reasonable.
04:53:06 <phadej> well, in that case the parallel GC shouldn't been used at all
04:54:34 <phadej> 5s doesn't sound like a program where -N makes a difference at all
04:54:51 <phadej> doesn't make*
04:55:23 <phadej> __monty__: just read through https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-options-to-control-the-garbage-collector
04:55:29 <phadej> to get an overview what can be tuned
04:56:50 <__monty__> I should, but I haven't had a need to tune the GC yet. Not that far along the journey yet.
04:57:56 <cocreature> the +RTS -s output usually gives you a pretty good idea of whether GC makes up a significant amount of your program’s runtime
04:58:21 <phadej> that's good advice
04:58:25 <duairc> merijn: I ctrl+c'd my app after generating a few charts and 110.291s/114.157s is spent in the GC, as you suspected
05:06:25 <merijn> duairc: Next step, trying running with "+RTS -sstderr -qg"
05:06:50 <merijn> That disables the paralle GC and uses just a single thread
05:08:01 <mniip> hmm
05:08:25 <mniip> I wonder if anyone considered the idea of mutable setoids/quotient types/...
05:09:18 <mniip> suppose you have a type with hidden constructors and a limited API that allows working with the type
05:09:51 <mniip> sometimes you may wish to modify an otherwise immutable value in a way such that its internal structure indeed changes, but extensionally (in terms of the API) it's the same
05:12:22 <asheshambasta> am I the only one finding the choice of words here, strange? http://hackage.haskell.org/package/these-0.4.2/docs/Control-Monad-Trans-Chronicle.html#t%3aChronicleT
05:13:34 <duairc> merijn: I'm getting similar results with -qg, all but 3s in GC
05:15:30 <merijn> duairc: hmm, then you might need to resort to using profiling to figure out why GC is taking that long. It might be the font data, in which case maybe compact regions can help, but I'm not sure
05:17:09 <duairc> merijn: If I disable -threaded then it behaves completely reasonably
05:17:41 <Guest89> hello
05:17:51 <duairc> Is there some way I can tell it not to GC the font data at all though? I guess if I stop using unsafePerformIO to read it...
05:17:53 <hpc> asheshambasta: it sounds like it's using the two Monoid instances on http://hackage.haskell.org/package/these-0.4.2/docs/Data-These.html#t:These
05:18:01 <hpc> (involving Bind and Apply)
05:18:04 <merijn> hmmm, I wonder if you're getting screwed over by unsafePerformIO getting inlined somewhere and it redundantly reading in the fonts from scratch all the time
05:18:30 <hpc> oh wait, read that backwards
05:18:37 <duairc> merijn: No, it's not that, I'm using NOINLINE
05:19:26 <merijn> duairc: I wouldn't be so confident about NOINLINE's effectiveness in the presence of non-trivial unsafePerformIO actions :)
05:19:27 <asheshambasta> hpc: yeah, but I just find the function names (see chronicle operations section) quite dramatic and amusing 
05:19:38 <hpc> oh, i see what you mean
05:19:47 <merijn> duairc: Maybe part is getting floated to the top level and *then* inlined
05:19:49 <asheshambasta> confess, momento, condemn 
05:20:11 <asheshambasta> absolve 
05:20:26 <hpc> yeah, those are really goofy and i would have no idea what they meant if i saw them in code
05:20:50 <hpc> it reminds me of the carp package in perl
05:20:58 <__monty__> retcon : D
05:21:11 <hpc> (http://perldoc.perl.org/Carp.html)
05:21:14 * traxex croaks
05:21:34 <asheshambasta> hpc: I have trouble understanding what they do as is, even in the documentation 
05:21:52 <asheshambasta> if I do end up using this I'd probably alias these functions first 
05:24:05 <merijn> duairc: The fact that using the unthreaded RTS fixes it, implies to me there's some unsafePerformIO fuckery going around
05:24:08 <__monty__> I have to admit the vocabulary makes more sense than it seems to at first sight though.
05:25:13 <asheshambasta> __monty__: so far, absolve is my favourite 
05:26:16 <asheshambasta> I also don't know what the `record` in the documentation means, although it seems like they're talking about `c` being the record type 
05:28:37 <__monty__> I think of it as the calculations criminal record : )
05:33:29 * hackage ca-province-codes 1.0.0.0 - ISO 3166-2:CA Province Codes and Names  https://hackage.haskell.org/package/ca-province-codes-1.0.0.0 (lysergia)
05:36:35 <Ariakenom> Does anyone know about performance considerations of the chunked stack? I'd think if the code could allocate and deallocate to cause overflow very often.
05:37:28 <merijn> Ariakenom: Not sure what you're talking about?
05:38:20 <Ariakenom> ghc's non contiguous stacks
05:39:40 <Ariakenom> I was reading flags and was reminded of that question. Reading the next flag answered it though.
05:39:55 <Ariakenom> "When a stack chunk overflows and a new stack chunk is created, some of the data from the previous stack chunk is moved into the new chunk, to avoid an immediate underflow and repeated overflow/underflow at the boundary. "
05:42:21 <Ariakenom> worst case of new stack seems to be every 2*kc*kb =/default/=2 * 10% * 32kB = 6kB
05:43:22 <Ariakenom> no 2*kb = 2kB
05:45:41 <pzp> What is a minimal set of combinators that can be used to write any function in point-free style?
05:48:02 <Guillaum> merijn: thank you for the trick about -fdefer-type-error, this was actually what I was used until now. But now I want to check the error my library raises to ensure that there is no regression in the quality of error reporting (I'm using a mix of GHC.TypeLits.TypeError and template haskell liftIO . putStrLn)
05:48:36 <lyxia> pzp: S,K,I,fix sounds pretty good
05:49:01 <Ariakenom> lyxia: I=SKK
05:49:42 <lyxia> :t (<*>) pure pure
05:49:43 <lambdabot> error:
05:49:43 <lambdabot>     • Ambiguous type variable ‘f0’ arising from a use of ‘pure’
05:49:43 <lambdabot>       prevents the constraint ‘(Applicative f0)’ from being solved.
05:49:55 <lyxia> :t (<*>) const const
05:49:56 <lambdabot> b -> b
05:50:22 <lyxia> Ariakenom++ :)
05:51:56 <Ariakenom> :) I'd think you can do it in one though
05:52:59 <Ariakenom> pzp: related reading https://en.wikipedia.org/wiki/SKI_combinator_calculus
05:53:33 <Guillaum> merijn: I just realized that the TypeError exceptions CONTAINS the error, so I can compare it. Thank you!
05:53:54 <pzp> Yeah that seems like a pretty good answer, although I think that fix might also be redundant. Couldn't you use S and K to write a Y-combinator?
05:54:32 <lyxia> you can if you turn off the typechecker
05:56:05 <duairc> merijn: Sorry, I had lunch there. I'll see if I can refactor so I don't unsafePerformIO, I might try compact regions as well. Thanks a lot for your help so far!
05:57:52 <dminuoso> lyxia: Interesting, isn't fix=S(K(SII))(S(S(KS)K)(K(SII))) ?
05:58:03 <dminuoso> lyxia: Or is the point of `fix` the same as I: convenience?
05:58:41 <Taneb> :t id <*> id
05:58:42 <lambdabot> error:
05:58:43 <lambdabot>     • Occurs check: cannot construct the infinite type: a ~ a -> b
05:58:43 <lambdabot>       Expected type: (a -> b) -> a
05:58:50 <Taneb> dminuoso: that's the problem you run into in Haskell
05:59:28 <dminuoso> Oh now I get what lyxia meant there.
05:59:31 <dminuoso> Thanks Taneb.
06:00:37 <byorgey> duairc: hmm, it turns out there is also a call to 'unsafePerfomrIO' in SVGFonts itself.  I thought we got rid of all of them but there's still one in the Default instance for TextOpts
06:01:36 <byorgey> duairc: although it pertains only to loading the default 'lin' font so if you are using your own font it shouldn't affect anything
06:01:36 <duairc> byorgey: Yes, I was aware of that one :) I'm not actually using it though
06:01:48 <byorgey> duairc: right, ok
06:02:16 <duairc> I was wondering if that was intentional or not. Without it you can't really make a default instance of TextOpts
06:02:53 <Ariakenom> pzp: iota combinator https://en.wikipedia.org/wiki/Iota_and_Jot
06:02:53 <duairc> I guess you could inline the SVG file itself into the Haskell file as a string, then you don't need IO
06:03:59 * hackage xorshift-plus 0.1.0.0 - Simple implementation of xorshift+ PRNG  https://hackage.haskell.org/package/xorshift-plus-0.1.0.0 (syocy)
06:05:15 <byorgey> duairc: right, you can't make a default instance of TextOps without it, but if unsafePerformIO causes a lot of performance problems then it's probably worth just getting rid of the Default instance.
06:05:41 <byorgey> Or perhaps the default instance should have 'undefined' as the font or something, so you always have to at least load a font and specify it yourself, but you get all the other defaults
06:06:21 <byorgey> duairc: inlining the font into the code sounds icky.  ISTR GHC doesn't deal well with humongous literal values but maybe that's better now.
06:09:53 <duairc> byorgey: Yeah, definitely, it sounds awful, but technically it would be a solution
06:10:49 <duairc> Yeah, LinLibertine.svg is 637K
06:12:03 <phadej> byorgey: I did inline fonts into the code
06:12:05 <phadej> works ~well
06:12:58 <phadej> https://github.com/futurice/haskell-mega-repo/blob/master/servant-Chart/src/Servant/Chart.hs#L80-L153
06:14:02 <duairc> phadej: You're just using unsafePerformIO there, right? I don't see an actual literal SVG in the Haskell code
06:14:39 <phadej> duairc: embedDIr
06:14:42 <phadej> embedDir
06:14:55 <duairc> phadej: Ah
06:15:48 <phadej> unsafePerformIO is to put loaded data into compact region
06:16:20 <phadej> which helps a little, but not much iirc
06:16:56 <phadej> as PreparedFont is the big thing in memory, but it contains functions iirc
06:17:21 <duairc> You can't put functions in compact regions?
06:17:32 <phadej> cannot put closure, no.
06:17:52 <duairc> Oh, I didn't know that, that's a shame
06:18:22 <phadej> that boils down to (kind of) what's NFData (a -> b)
06:18:33 <duairc> That makes sense
06:19:20 <duairc> phadej: This servant-Chart thing, do you run an actual app with it and it works okay? Does it use the threaded runtime?
06:19:30 <phadej> duairc: yes, and yes
06:20:11 <phadej> https://github.com/futurice/haskell-mega-repo/blob/master/mega-repo-tool.config#L130 is RTS params used
06:20:47 <duairc> phadej: Okay, great. I guess I'll study your code and adapt it to my case. Don't know if you've been following my messages today but I'm trying to do something similar-ish and the combination of using unsafePerformIO to load fonts and the threaded runtime is causing all sorts of problems
06:20:52 <fryguybob> <p>
06:22:22 <phadej> duairc: we had 30% CPU constant usage because of idle GC and parallel gc
06:22:22 <fryguybob>  Oops</p>
06:22:40 <phadej> -qg (or -qn2 as we got to newer GHC) helped
06:23:08 <duairc> That sounds similar to the problems I was having, though -qg didn't help at all
06:23:22 <phadej> also -N might get wrong capabilities
06:23:39 <phadej> e.g. even your vm is allocated only 2 CPUs, getCapabilities will return all of the host
06:24:13 <phadej> or/and when you have more than one process hungry for CPU then locks will spin
06:24:25 <phadej> more locks: less lickely to unlock
06:24:33 <duairc> phadej: Were you able to overcome that or is it just something you manage by tuning the RTS params?
06:24:37 <dminuoso> phadej: regarding the chan/queue discussion yesterday, queue means you need to do it all in STM though. with just chan you can avoid any overhead from transactions. No?
06:24:42 <dminuoso> And by yesterday I mean fridya.
06:24:53 <merijn> dminuoso: Realistically STM is going to be much faster
06:25:00 <dminuoso> merijn: Really? o.o
06:25:18 <merijn> dminuoso: STM is pretty cheap if transactions are small and don't access many variables
06:25:52 <merijn> dminuoso: Depends on threaded vs unthreaded to
06:26:27 <merijn> dminuoso: I did a bunch of microbenchmarks at some point: http://files.inconsistent.nl/sync.txt http://files.inconsistent.nl/sync-threaded.txt
06:26:51 <dminuoso> merijn: Do you have the code you ran for the benchmarking?
06:27:20 <merijn> dminuoso: https://github.com/merijn/broadcast-chan/tree/master/broadcast-chan
06:27:52 <c_wraith> You just need to avoid the STM failure case of "every transaction modifies the same reference"
06:43:51 <merijn> c_wraith: Even that's fine if they don't contend very often
06:48:38 <Ariakenom> merijn: I'm getting Î¼s instead of μs in the threaded link, but not the other.
06:53:00 * hackage io-streams 1.5.1.0 - Simple, composable, and easy-to-use stream I/O  https://hackage.haskell.org/package/io-streams-1.5.1.0 (GregoryCollins)
06:53:50 <dminuoso> In the name `profunctor`, does the suffix "pro" just stand for product?
06:54:49 <ggole> "professional"
06:57:33 <dminuoso> Or perhaps its related to pro-objects.
06:58:10 <dminuoso> https://web.math.rochester.edu/people/faculty/doug/otherpapers/loregian2.pdf this at least suggests that the origin is pro-object.
07:02:56 <Ferdirand> is there something in the lab preferable to "fmap mconcat . sequence" ?
07:03:05 <Ferdirand> s/lab/lib/
07:03:22 <c_wraith> :t fmap mconcat . sequence
07:03:23 <lambdabot> (Monad f, Monoid b) => [f b] -> f b
07:03:56 <Ariakenom> :t traverse mconcat
07:03:57 <lambdabot> (Monoid (f b), Applicative f, Traversable t) => t [f b] -> f (t b)
07:04:25 <byorgey> Ferdirand: not that I know of
07:04:55 <souvikhaldar> Can someone suggest a good quickstart for a beginner like me who is coming from golang background?
07:04:58 <dminuoso> Ferdirand: Alternative perhaps?
07:06:02 <dminuoso> souvikhaldar: Do you have any other experience than golang?
07:06:03 <c_wraith> :t getAp . concatMap Ap
07:06:05 <lambdabot> error: Variable not in scope: getAp :: [b0] -> c
07:06:05 <lambdabot> error:
07:06:05 <lambdabot>     • Data constructor not in scope: Ap :: a -> [b0]
07:06:15 <c_wraith> @let import Data.Monoid
07:06:16 <lambdabot>  Defined.
07:06:18 <c_wraith> :t getAp . concatMap Ap
07:06:20 <lambdabot> error: Variable not in scope: getAp :: [b0] -> c
07:06:20 <lambdabot> error:
07:06:20 <lambdabot>     • Data constructor not in scope: Ap :: a -> [b0]
07:06:29 <dminuoso> % import Data.Monoid
07:06:30 <yahb> dminuoso: (0.01 secs, 0 bytes)
07:06:33 <dminuoso> % :t getAp . concatMap Ap
07:06:34 <yahb> dminuoso: ; <interactive>:1:9: error:; * Couldn't match type `[b0]' with `Ap f1 a1'; Expected type: t (f a) -> Ap f1 a1; Actual type: t (f a) -> [b0]; * In the second argument of `(.)', namely `concatMap Ap'; In the expression: getAp . concatMap Ap; <interactive>:1:19: error:; * Couldn't match type `Ap f a' with `[b0]'; Expected type: f a -> [b0]; Actual type: f a -> Ap 
07:06:34 <c_wraith> Hmm.  lambdabot must be on an older ghc
07:06:52 <[exa]> souvikhaldar: do you have a favorite simple problem that you want to solve in each programming language?
07:06:55 <dminuoso> concatMap looks wrong there
07:07:02 <c_wraith> err, yes
07:07:07 <lyxia> % :t getAp . foldMap Ap
07:07:07 <yahb> lyxia: forall k (t :: * -> *) (f :: k -> *) (a :: k). (Foldable t, Monoid (Ap f a)) => t (f a) -> f a
07:07:13 <c_wraith> foldMap is what I meant
07:07:15 <souvikhaldar> yes dminuoso with python. No functional language experience though.
07:07:15 <[exa]> souvikhaldar: (1- do it in haskell 2- ask us about how to improve the solution in novel/educative ways)
07:07:24 <c_wraith> Ferdirand: that works, but it's not really better
07:07:37 <dminuoso> souvikhaldar: Do you prefer something easy going, a bit more lecture focused or just a brutal "figure it out yourself" approach?
07:07:40 <c_wraith> Still, I'm happy the Ap wrapper exists
07:07:51 <dminuoso> c_wraith: Yes, Ap is really nice. :)
07:08:16 <[exa]> dminuoso: (is LYAH the 'easy going' or the brutal one? :] )
07:08:36 <souvikhaldar> I don't have any favorite problem as such [exa] :)
07:08:38 <asheshambasta> So the ChronicleT is some sort of a "Validation" monad; correct, which means I can wrap it inside of an ExceptT much like `ExceptT errFatal (Chronicle errValidation m a)
07:09:08 <dminuoso> [exa]: I was going to pick the gentle introduction as the brutal one. :-P
07:09:08 <souvikhaldar> dminuoso: Maybe something lecture focused. 
07:09:14 <Ferdirand> oh well. thanks everyone!
07:09:15 <dminuoso> @where cis
07:09:15 <lambdabot> I know nothing about cis.
07:09:20 <c_wraith> the type yahb reports for that is a bit confusing.  Why does it list a Monoid (Ap f a) constraint? 
07:09:24 <dminuoso> @where cis194
07:09:24 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
07:09:35 <dminuoso> souvikhaldar: ^- this is a really high quality series with good and deep excercises.
07:09:54 <souvikhaldar> dminuoso: Thank you so much :)
07:10:10 <c_wraith> That instance is defined.  It should list the transitive instances, Applicative f and Monoid a
07:10:17 <souvikhaldar> How would you rate "learn you a haskell for great good"?
07:10:20 <__monty__> asheshambasta: Wouldn't you just use condemn to make the Chronicle act like it uses fatal errors?
07:10:34 <dminuoso> c_wraith: It's PolyKinds
07:10:48 <[exa]> souvikhaldar: IMO it's good, but doesn't have many practical examples
07:10:50 <c_wraith> souvikhaldar: decent for picking up the syntax if you have something else to work on so that you can apply it
07:11:13 <rfold> A case expression that matches on consecutive integers is optimized into a jump table, such that each entry in the table is the address of a branch of the case expression. When doing a tail recursive call in such a branch, the call is optimized to a jump to the case expression, which then does a lookup in the jump table to do a jump. This means that on every tail recursive call there are two jumps.
07:11:15 <rfold>  Is it possible to have the tail recursive calls be optimized so that they directly jump to the next branch? In GNU C this can be achieved manually by using an array of label addresses.
07:11:16 <c_wraith> dminuoso: still weird. That type isn't polykinded.
07:11:32 <c_wraith> dminuoso: oh, nevermind.  It totally is.
07:11:34 <dminuoso> c_wraith: It's inferred to be.
07:11:37 <souvikhaldar> ah, i see
07:11:55 <asheshambasta> __monty__: I'm trying to do multiple things here. I'd like to be able to use the monad transformer provided by http://hackage.haskell.org/package/aeson-better-errors-0.9.1.0/docs/Data-Aeson-BetterErrors.html to get better errors than Aeson, which is built on top of ExceptT 
07:11:55 <Solonarv> % :k Ap
07:11:55 <yahb> Solonarv: Ap :: forall {k}. (k -> *) -> k -> *
07:12:01 <Solonarv> see? poly-kinded
07:12:06 <souvikhaldar> I'm going with the provided lecture, will ask questions here if the need be
07:12:08 <asheshambasta> __monty__: but I understand I'm going a bit off the deep-end here. 
07:12:23 <c_wraith> Solonarv: did you miss my next line? :)
07:12:52 <Solonarv> no, I just wanted to clarify  :D
07:12:55 <asheshambasta> __monty__: currently, writing an API with just Aeson's error support is impossible, and there doesn't seem to be any kind of validation accumulation support, or custom error type support in Aeson 
07:13:04 <dminuoso> souvikhaldar: It's really old and outdated. My personal recommendation is CIS194 and then diving into real code in parallel, so that when you are done with the lectures you have enough to bootstrap yourself.
07:13:26 <asheshambasta> in our API SLA, we _absolutely_ need to be able to dump all validation errors at once to avoid client-testing roundtrips 
07:13:44 <[exa]> souvikhaldar: foreseeing the problematic parts -- the explanation of IO/monads in LYAH is quite well digestible
07:14:20 <souvikhaldar> Which one is old and outdated? dminuoso 
07:14:38 <dminuoso> souvikhaldar: learn you a haskell
07:14:42 <c_wraith> rfold: jump tables are really inefficient anyway. I doubt GHC produces them except in really egregious cases.
07:15:03 <souvikhaldar> Oh, no I meant I'll go with the lecture provided above 
07:15:09 <souvikhaldar> i.e https://www.seas.upenn.edu/~cis194/fall16/
07:15:21 <souvikhaldar> ^
07:15:31 <dminuoso> souvikhaldar: Mmm, the link Ive shown you is a different course.
07:15:43 <dminuoso> souvikhaldar: https://www.seas.upenn.edu/~cis194/spring13/lectures.html
07:16:09 <dminuoso> I cant speak for the one you have right there.
07:16:17 <Solonarv> seems to just be a newer version of the same course? at least that's what I recall
07:16:33 <souvikhaldar> I just searched for the course on google and got that. 
07:16:50 <souvikhaldar> I'll go with the link you provided (y)
07:17:05 <__monty__> asheshambasta: Ah, then your intuition sounds right. It's over my head though.
07:17:37 <souvikhaldar> Solonarv: I didn't get you, sorry!
07:17:48 <asheshambasta> __monty__: the idea is to have this embedded inside another stack that allows for "short-circuiting" the validation.
07:18:25 <asheshambasta> so basically, throwError of errFatal types will just stop; however, doing things inside of chronicle will keep validation going. 
07:18:28 <dminuoso> Solonarv: And a different instructor.
07:18:50 <souvikhaldar> dminuoso: Any final comments?
07:18:53 <dminuoso> Solonarv: The content seems somewhat different too.
07:18:56 <Solonarv> hm. well, I haven't done either of these courses, so I can't speak about them.
07:19:12 <dminuoso> souvikhaldar: Not really. Feel free to hang around and ask if you have any questions?
07:19:37 <souvikhaldar> Sure :) Thanks for the warm gesture dminuoso [exa] Solonarv :)
07:20:34 <dminuoso> byorgey: Would you recommend the more recent course by Joachim over your old course?
07:23:22 <__monty__> asheshambasta: So you're using chronicle to add non-fatal errors, so you can collect many of them rather than having to run for one, fix, run for another?
07:23:36 <asheshambasta> __monty__: exactly, yes 
07:24:42 <__monty__> Sounds perfectly cromulent to me ; )
07:24:48 <tabaqui> hey all
07:24:55 <tabaqui> I'm trying to use FFI with hsc
07:25:18 <tabaqui> but I faced some troubles with a scope
07:25:25 <tabaqui> this code doesn't work:
07:25:31 <tabaqui> #include <termios.h>
07:25:37 <tabaqui> a = (#size termios)
07:25:52 <tabaqui> error: ‘termios’ undeclared 
07:26:46 <tabaqui> I dunno, I can provide full example with pastebin, but maybe I'm blind and the problem is much easier
07:27:38 <[exa]> the termios.h is a header of some kind of your wrapper, or a system header?
07:27:55 <tabaqui> it is a system header
07:28:10 <asheshambasta> __monty__: +1 for teaching me a new word, btw. 
07:29:01 <souvikhaldar> dminuoso: I'll wait for a response from byorgey :)
07:29:05 <[exa]> tabaqui: did you see the example here?  https://wiki.haskell.org/FFI_Introduction
07:29:09 <c_wraith> asheshambasta: cromulent has a fantastic history as a word, and is a powerful demonstration of how language works as a result. :)
07:29:23 <[exa]> tabaqui: you need to manually import all symbols you want to use
07:29:33 <tabaqui> [exa]: wow, thanks a lot!
07:30:09 <[exa]> tabaqui: somewhere around there is a complete example also with export and more complicated imports
07:30:28 <tabaqui> I hope that is enough for me
07:30:35 <tabaqui> I just want to turn raw console mode on
07:30:39 <[exa]> tabaqui: (can't find it right now and have to afk, sorry, hope this helps :] )
07:30:40 <asheshambasta> c_wraith: looking it up 
07:30:49 <[exa]> tabaqui: ok great :]
07:30:52 <tabaqui> [exa]: np, thank you
07:31:51 <c_wraith> asheshambasta: the short version is that it was invented by a TV show (the Simpsons) to be a made-up word that everyone immediately understood from context.  Almost immediately people started using it.  Now it's just part of the language.
07:32:38 <asheshambasta> c_wraith: the meaning wasn't immediately clear to me when __monty__ used it though. 
07:33:02 <c_wraith> asheshambasta: sure.  It was clear in the context of its use in the TV show.  I wasn't completely clear about it. :)
07:33:08 <asheshambasta> I assumed I was being noobish with Haskell again and he said it to mean "sounds unreasonable" 
07:33:32 <asheshambasta> c_wraith: sounds cromulent. 
07:36:53 <dminuoso> souvikhaldar: Well both are very involved people in the community, so I have no doubt that both are of high quality. Perhaps you could just try out both and see which one you prefer more, or maybe do them along in tandem. :)
07:37:58 <souvikhaldar> Do you think it might be better to go with the newer once since over the years maybe new stuffs have been added?
07:38:06 <souvikhaldar> Or maybe some other changes
07:42:59 <dminuoso> souvikhaldar: Haskell itself has not changed since then, the changes in GHC are minor. The 2016 course is up-to-date regarding idioms... it's up to you. Brent's course has no solutions, so it's easier to not get tempted to "cheat". =)
07:44:04 <dminuoso> souvikhaldar: Im going to say, pick whichever you prefer. :)
07:48:14 <souvikhaldar> Okay :)
07:49:28 <dminuoso> souvikhaldar: A quick glance at the more recent one suggests that it's relatively similar in quality and depth.
07:50:49 <souvikhaldar> Yes dminuoso it seemed so. Let me try out with the newer one, I'm hoping it is built on similar teaching pattern as the old one.
07:51:46 <monochrom> c_wraith: I thought you meant "smurf". >:)
08:07:49 <byorgey> dminuoso: I haven't really looked at it, but Joachim is a smart guy and a great teacher so I would assume his course material will be great.
08:08:32 <byorgey> dminuoso: looking at it quickly now it looks like he took a bunch of my material and changed it around a bit, added his own, etc.
08:09:30 <byorgey> the biggest pedagogical difference I can see is that he chose to put "real world" stuff, including monads and IO, much earlier, which is something about which teachers can reasonably disagree =)
08:11:10 <phadej> wasn't joachims target audience a bit different than the course's original students?
08:11:38 <phadej> i.e. "academics" but not CS-academics
08:18:56 <byorgey> phadej: I don't think so.  Maybe you are confusing it with http://haskell-for-readers.nomeata.de/
08:19:07 <byorgey> which is a completely different course by Joachim
08:19:11 <phadej> ah
08:19:14 <phadej> ok, I lost context
08:19:26 <byorgey> np
08:19:50 <wroathe> Is there a way to get a list of packages on hackage sorted by downloads in the last month?
08:20:01 <wroathe> (without specifying a search term)
08:21:06 <wroathe> Oh, nvm, I now see that I wasn't letting the full package list finish loading on hackage
08:21:28 <wroathe> Which was blocking the JS for sorting from being executed
08:24:13 <dminuoso> byorgey: Ah thank you for the insight. Yeah, I met him twice and he seems to know his stuff. :)
08:37:00 <kmelvn> trying to build a minimal binary with `cairo` package and it fails with "cabal: Could not resolve dependencies". Everything is at newest version, and I create a new project with "cabal init", and then add "cairo ^>=0.13.5.0" as dependency...
08:37:15 <kmelvn> any ideas what to do?
08:39:00 * hackage haven 0.2.0.1 - Recursively retrieve maven dependencies  https://hackage.haskell.org/package/haven-0.2.0.1 (abrar)
08:41:19 <duairc> phadej: byorgey: So I'm trying to use compact with SVGFont now, and I've tried a couple of different SVG fonts now (including the LinLibertine.svg that comes with SVGFonts) and every time during the compaction process I get: *** Exception: Data.Vector.Mutable: uninitialised element
08:41:29 <duairc> phadej: You've never run into this with servant-Chart?
08:42:44 <duairc> The only place in SVGFonts that seems to use Vector is Kern
08:45:07 <kmelvn> Guess cairo just doesn't work with GHC 8.6, oh well... 
08:45:26 <phadej> duairc: i did, and iirc my code does Data.Vector.force somewhere to get rid of bottoms
08:45:48 <duairc> phadej: Okay, great, I'll try to track that down
08:46:04 <duairc> Ah, I see it, I just completely overlooked it
08:47:33 <phadej> that's something which could had a comment...
09:08:39 <dminuoso> Is there something Im not seeing why monad-logger does not come with some instance Alternative m => Alternative (LoggingT message m)?
09:09:04 <dminuoso> Oops, strike that *message type variable, so it should be: instance Alternative m => Alternative (LoggingT m)
09:13:36 <lyxia> that looks like a reasonable instance to add
09:22:15 <wroathe> So if I'm understanding MonadIO correctly, the point is that by generalizing your function to allow it to return any instance of MonadIO, your function can be used in any monad transformer stack based on IO (that has an instance for MonadIO defined)
09:22:53 <wroathe> If that's true, is there ever a reason to explicitly return an IO?
09:23:04 <wroathe> Instead of MonadIO m => m a?
09:23:38 <glguy> You can always use liftIO when you actually need it and there can be a performance overhead to using MonadIO if things don't inline or specialize enough
09:23:39 <wroathe> Or could you consider usage of the IO type to be a sort of "legacy" thing?
09:24:17 <glguy> Similarly we don't bake a fromIntegral onto the end of length
09:25:54 <wroathe> The potential performance impact based on compiler behavior seems like a handy wavy argument against using MonadIO. Couldn't you generalize that argument to all monad transformer stacks in general?
09:26:25 <wroathe> (not that what you're saying isn't true, but this seems like the standard push/pull of tuning performance as you go)
09:26:51 <glguy> It's more about not polluting definitions with wrappers for casting their outputs
09:27:41 <wroathe> The reason I'm bringing this up is https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell this piece of writing
09:27:54 <wroathe> He's calling something that returns an IO String "overly restrictive"
09:28:14 <glguy> I'd say he's basically wrong
09:28:15 <wroathe> There seems to be a school of thought out there that all functions should support ad-hoc polymorphism
09:28:26 <wroathe> Via typeclasses
09:28:27 <glguy> You should stive to be specific in what you return and general in what you accept
09:29:20 <glguy> strive*
09:30:00 <wroathe> That was my original line of reasoning as I set out on this little project, but I can definitely see the utility of letting a libraries user call your function in any MonadIO context
09:30:46 <wroathe> (without using liftIO, that is)
09:30:47 <glguy> it can certainly result in fewer characters typed
09:31:27 <wroathe> Anyone else here have an opinion on this?
09:31:39 <Solonarv> anecdotally, I find littering my code with liftIO rather unpleasant.
09:32:16 <wroathe> That is, IO a vs. MonadIO m => m a
09:33:22 <boj> i can't remember where i saw it, but Simon M seemed pretty adamant about explicitly using IO. that seems to be reflected in his libraries, like async
09:36:58 <Solonarv> I should note that a library like async can't simply replace all occurences of IO with MonadIO m => m, because (IO a) occurs in negative position there
09:36:59 * hackage http-conduit 2.3.5 - HTTP client package with conduit interface and HTTPS support.  https://hackage.haskell.org/package/http-conduit-2.3.5 (MichaelSnoyman)
09:37:30 <wroathe> Solonarv: "negative position"?
09:37:33 <Solonarv> instead it would need MonadUnliftIO, or possibly MonadBaseControl IO
09:37:56 <Solonarv> "negative position" = to the left of an odd number of function arrows
09:38:43 <Solonarv> if you have a function of type 'Foo -> Bar', this function *consumes* Foo (so Foo is in negative position) and *produces* Bar (which is in positive position)
09:39:06 <wroathe> Ah, I see
09:39:25 <wroathe> But for anything that produces an IO a, it should be possible then to replace that with MonadIO m, right?
09:39:44 <Solonarv> Indeed.
09:40:01 <wroathe> And it sounds like that's probably the right thing to do, unless I notice it's crazy slow for some reason
09:40:04 <bsima> Solonarv: that's the best explanation of "neg/pos position" i've heard, thanks
09:40:41 <Solonarv> but in 'async :: IO a -> Async a', 'IO a' occurs in negative position, so MonadIO isn't helpful
09:42:13 <boj> that makes sense. the caller decides how the IO action is ran, not the library
09:42:20 <geekosaur> do consider also that overly polymorphic means the compiler can do things you don't expect (something you would want to be a type error instead succeeds because the compiler can find enough polymorphism)
09:43:20 <Solonarv> or more commonly, results in a more confusing type error (IME, this happens most often in relation to overloaded literals and/or functions that haven't been given enough arguments)
09:44:05 <geekosaur> or that, yes
09:44:51 <wroathe> My guess is that this is fertile ground for a vim/emacs style holy war debate
09:48:12 <Solonarv> I don't think anyone here wants a holy war, fortunately.
09:48:29 <wroathe> Indeed
09:49:43 <wroathe> I do notice that Simon Marlow's async library does not make use of MonadIO for return types
09:50:46 <Solonarv> there's not much point in making only half the API polymorphic, I think
09:50:56 <wroathe> https://github.com/simonmar/async/issues/16
09:52:52 <Solonarv> hmm, that issue is over four years old...
09:53:38 <wroathe> You're wondering if he's since changed his position on the matter?
09:54:23 <Solonarv> I'm wondering if it predates unliftio, and it does
09:54:54 <Solonarv> the first commit on https://github.com/fpco/unliftio is from july '17
09:55:30 <dyl> wroathe: re holy war potential, I think most people could be convinced that robustness is a good criterion.
09:55:41 <dyl> Be liberal in what you accept and conservative in what you emit. 
09:55:53 <dyl> (AKA weakest precondition and strongest postcondition.)
09:56:48 <dyl> (AKA contravariant in input, covariant in output.) 
09:56:57 <phadej> one is free to make async-unliftio package
09:57:32 <Solonarv> ..and there's the last piece of the puzzle: if a library is monomorphic, it's always possible to write a trivial polymorphic wrapper
09:57:37 <phadej> oh, in fact `unliftio` depends on async
09:57:45 <phadej> http://hackage.haskell.org/package/unliftio-0.2.10/docs/UnliftIO-Async.html
09:57:51 <phadej> so, what's the problem?
09:58:16 <wroathe> phadej: You keep popping in without context :P
09:58:47 <phadej> the 80x25 curse
09:59:09 <Welkin> not a curse
09:59:19 <Welkin> line-length matters for legibility
09:59:20 <wroathe> phadej: I'm fairly new here, and just discovering the MonadIO m => m a vs explicit IO a debate
09:59:30 <wroathe> via this article
09:59:30 <wroathe> https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell
09:59:42 <Welkin> what debate?
09:59:47 <wroathe> And I was just asking what people thought. We've been talking about this for 15 minutes or so
09:59:58 <Welkin> you start with something specific and move to something more general if you need to
09:59:58 <phadej> iirc I disagree with everything in that article
10:00:08 <Welkin> you don't start with a general abstraction
10:00:12 <Welkin> there is no debate
10:00:30 <wroathe> Yeah, I thought it was odd where he called IO String "overly restrictive"
10:01:22 <phadej> (mainly I disagree with exceptions + IO part though)
10:03:21 <Solonarv> yeah, that article's stance on exceptions seems overly zealous.
10:03:52 <Welkin> anything from fpcomplete is controversial
10:04:22 <Welkin> it's also written by snoyberg, who is well known for overusing typeclasses
10:04:39 <phadej> not everything; unliftio is infact good abstraction
10:04:49 <phadej> easier to grasp then `monad-control`
10:04:53 <phadej> inline-c
10:04:57 <bsima> i like most of what fpcomplete and snoyberg have done, fwiw
10:05:07 <Welkin> of course there is some good work
10:05:12 <phadej> but it's not black and white
10:05:18 <Welkin> wai, warp, and http-client for example
10:06:01 <phadej> it's just bad to believe everything blindly, because it's by "your idol" or whatever
10:07:07 <wroathe> I don't really know the guy. I'm just doing some research on the various models of producing exceptions in Haskell
10:07:26 <wroathe> Which seems like a long and sordid tale
10:07:37 <phadej> wroathe: i learned a good advice during my C++ life: don't use exceptions for control flow
10:08:09 <wroathe> Wasn't planning on it :D
10:08:18 <Welkin> I never touch exceptions unless the library demands it, and it makes sense  to crash and burn
10:08:42 <phadej> consider `catch` a code smell inside business logic. It's something say `warp` catches at renders a 500 page
10:08:47 <Welkin> an exception is an unrecoverable error
10:08:55 <phadej> I agree with Welkin.
10:08:59 <wroathe> Exceptions isn't the right word really
10:09:16 <boj> wroathe: error handling, perhaps?
10:09:20 <phadej> error handling: Either / ExceptT
10:09:28 <phadej> or your domain specific types
10:11:00 <wroathe> We've got Maybe, Either (which has been aliased in base to Except and the like), fail, error, a custom ADT with one Success case, and N error cases...
10:11:08 <wroathe> So many options for indicating failure
10:11:29 <Welkin> Maybe is like Either where you don't care about the error, only that it failed
10:11:29 <Solonarv> these are not disjoint, though
10:11:48 <Welkin> the standard is to use Either or ExceptT
10:11:58 <wroathe> Welkin: Yup. I'm just listing them all.
10:12:39 <bsima> Servant uses ExceptT, and it actually prevents me from using unliftio
10:12:40 <bsima>  
10:12:52 <bsima> I think its because ExcepT can't have a MonadIO instance
10:13:06 <bsima> (i learned this recently and it led to a few days of research and refactoring)
10:13:27 <wroathe> MonadFail, MonadThrow, MonadError
10:13:40 <Solonarv> it can have a MonadIO instance, did you mean MonadUnliftIO?
10:13:48 <bsima> oh, yeah
10:15:02 <Solonarv> which makes sense; you can't produce a 'ExceptT m a -> IO a' function whose return value doesn't loop forever/throw an exception
10:16:33 <dmwit> wroathe: Don't forget about ChronicleT, for when the error might not be fatal!
10:16:46 <phadej> bsima: use monad-control
10:16:47 <Solonarv> I keep forgetting that one exists
10:16:59 <phadej> it's slightly obscure
10:17:05 <phadej> (the ChronicleT)
10:17:16 <phadej> i'm quite sure it's reinvented often
10:18:01 <phadej> as well as http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Accum.html
10:18:36 <phadej> (not related to error handling, just a transformer you might now actually exists in the libs)
10:18:50 <dmwit> Huh, neat.
10:19:08 <dmwit> Do you get any fun benefits over StateT because of the restricted API?
10:20:35 <phadej> dmwit: it has different instances
10:21:05 <dmwit> Oh yeah??
10:21:13 <phadej> http://hackage.haskell.org/package/transformers-0.5.5.0/docs/src/Control.Monad.Trans.Accum.html#line-185
10:21:16 <phadej> spot the difference
10:21:29 * hackage toodles 1.0.3 - Manage the TODO entries in your code  https://hackage.haskell.org/package/toodles-1.0.3 (aviaviavi)
10:22:13 <Solonarv> oh, that's a neat transformer
10:22:15 <wroathe> For instance, many of the routines in Aeson return a Parser, which is an instance of MonadFail http://hackage.haskell.org/package/aeson-1.4.2.0/docs/Data-Aeson-Types.html#t:Parser. Calling fail raises an IOException.
10:22:30 <phadej> wroathe: it doesn't?
10:22:41 <wroathe> phadej: Huh?
10:22:55 <wroathe> https://github.com/ghc/ghc/blob/master/libraries/base/GHC/IO.hs#L82
10:23:08 <Solonarv> how is that related to aeson's Parser?
10:23:08 <phadej> > fail "foo" :: Maybe  Int
10:23:10 <lambdabot>  Nothing
10:23:16 <dmwit> phadej: IDGI
10:23:31 <phadej> dmwit: there's those `mappend`s
10:23:33 <Solonarv> 'fail' is a typeclass method, therefore it behaves differently for different monads.
10:24:05 <phadej> dmwit: also pure doesn't pass "state" through: 
10:24:06 <dmwit> phadej: Yeah, but you can do the same thing by dropping modify from the API and only exposing ```tell m = modify (`mappend` m)```, no?
10:24:06 <phadej> pure a  = AccumT $ const $ return (a, mempty)
10:24:09 <wroathe> Oh, good call
10:24:11 <wroathe> I was wrong
10:24:37 <dmwit> phadej: (And dropping `put` and `state`, too, of course.)
10:24:56 <wroathe> https://github.com/bos/aeson/blob/master/Data/Aeson/Types/Internal.hs#L294
10:24:57 <wroathe> Ignore me
10:25:37 <Solonarv> never!
10:25:39 <phadej> wroathe: this is good day, you're now smarter than yesterday
10:25:42 <elgoosy_> hi, https://pastebin.com/hz6evnqy can this longggg type restriction be given some kind of synonim, so one could write LongType m => m (Dynamic t T.Text) ?
10:25:44 <Solonarv> btw, you can view source on hackage too
10:26:04 <wroathe> phadej: That's been the plan since day one.
10:26:11 <dmwit> elgoosy_: Sure, `type WidgetCtx t m = (MonadIO m, DomBuilder t m, ...)`.
10:26:21 <Solonarv> elgoosy_: sure, just enable ConstraintKinds and you can write a type synonym as dmwit described
10:26:22 <wroathe> phadej: But it's impossible to do that without asking questions (even dumb ones) :D
10:26:33 <elgoosy_> nice thank you
10:27:11 <dmwit> Day one: today was a good day, I've planned to be smarter on day 8138 than on day 8137.
10:27:37 <phadej> dmwit: I guess the way AccumT is written makes it impossible to use API wrong, i.e. the type doesn't need to be abstract
10:27:54 <phadej> dmwit: as `mappend`s are in Monad instance, and not in `tell`
10:28:09 * dmwit nods agreeably
10:28:11 <phadej> telll i.e. add
10:44:51 <wroathe> Ha, that whole conversation made me realize having a foo :: MonadFail m => m a and fooM :: Maybe a in my API are completely redundant
10:44:59 <wroathe> knowledge++
10:50:28 <phadej> note that there is `MonadThrow Maybe` instance too
10:51:16 <phadej> unfortunately there aren't MonadError subclass with only throwError
10:51:50 <wroathe> phadej: When would you decide to use MonadFail over MonadThrow?
10:53:12 <infinisil> % :i MonadThrow
10:53:12 <yahb> infinisil: ; <interactive>:1:1: error: Not in scope: `MonadThrow'
11:09:39 <phadej> wroathe: that's something I'm not decided upon
11:10:33 <phadej> or actually, almost always MonadThrow when I have even a little more then bare String to throw
11:10:47 <phadej> Stringly-typed errors is like the worst
11:11:23 <wroathe> phadej: Yeah, after I asked you that I realized the immediate advantage of MonadThrow
11:11:29 <phadej> +1
11:11:34 <wroathe> phadej: But thanks for following up
11:11:39 <phadej> no worries
11:11:44 <phadej> this channel is good distraction
11:34:25 <kritzefitz> Huh, I just realized that the core of the application I'm currently developing should probably just consist of loading the plugins and initializing them. I'm not sure if that's a good thing.
11:58:29 * hackage MonadCompose 0.9.0.0 - Methods for composing monads.  https://hackage.haskell.org/package/MonadCompose-0.9.0.0 (JamesCandy)
12:08:53 <dmwit> kritzefitz: Sounds about as close to ethically neutral as it gets to me.
12:09:20 <dmwit> Fun to realize things like that, though. Could be a sign you've got a good architecture. =)
12:23:59 <dyl> kritzefitz That's pretty common, I think.
12:24:15 <dyl> Often the "core" of an application is really just the bit that loads all of the components, performs dependency injection, and presses "play".
12:24:40 <dyl> I'm with dmwit, that, imo, suggests good architecture. 
12:24:56 <kritzefitz> Hmm, right. Now that I think about it, many applications I know do that.
12:25:38 <dyl> I've found it's generally good to write an application as a library with a thin front-end.
12:25:50 <dyl> Pretty much all of my projects are Foo and FooCore/FooKit/FooLib.
12:26:01 <dyl> (+1 testability) 
12:27:20 <Solonarv> yup, I do that too
12:27:29 * hackage flac 0.2.0 - Complete high-level binding to libFLAC  https://hackage.haskell.org/package/flac-0.2.0 (mrkkrp)
12:28:13 <dyl> kritzefitz https://dl.acm.org/citation.cfm?id=361623
12:28:17 <dyl> The OG paper on the subject.
12:28:47 <dyl> Solonarv it's one of those conclusions that it seems like everyone naturally comes to.
12:28:49 <dyl> (with enough time.)
12:29:34 <Solonarv> it does seem that way, yes - even in languages other than Haskell
12:30:33 <slackcals> Hello.  I hope it is OK that I am cross-posting from the #xmonad channel.  Could someone advise on the following: https://gist.github.com/slackcals/5e84ee60ba36bd8e00cc2bf8b859f7e5 ?
12:31:10 <slackcals> perhaps there is a haskell best-practice that would suffice
12:31:58 <dyl> slackcals your cases don't overlap, so you could pattern match. 
12:32:41 <dyl> case curTag of "1:main" -> ...; "2:extra_terminals" -> ...; _ -> -- default case ... ; 
12:33:09 <monochrom> Hey! Just found out "cabal new-install" for exes doesn't strip the exes (on Linux)!
12:33:27 <slackcals> dyl: thank you much!  that definitely looks cleaner
12:33:48 <monochrom> I'm doing this on a school computer account so it would be nice to strip them so I don't hog all the disk space! :)
12:34:41 <dyl> slackcals and also, while you sadly cannot do disjunctive matches (match any of some cases) in Haskell, you could do...
12:35:26 <dyl> case curTag of t | t `elem` ["1", "2", "3"] -> ...; | t `elem` ["4", "5", "6"] ...
12:35:28 <Solonarv> slackcals: you could also do this: https://gist.github.com/Solonarv/fe2c14698a925a19ee3b8a7a92cb9595
12:35:43 <dyl> As your RHS seem to always be enable/disable, grouping them might be clearer.
12:35:55 <dyl> +1 to Solonarv's solution.
12:36:55 <slackcals> I really like that, Solonarv 
12:37:28 <slackcals> as always... you guys are extremely helpful!
12:52:26 <bryan1> I'm trying to generate a Haskell Servant stub from a swagger blob, online, and am kinda lost.  I don't actually see an option for haskell-servant on generator.swagger.io
12:58:10 <Guest62580> Are people active here? Kinda never used irc before :D
12:58:25 <MarcelineVQ> fairly. varies by time of day
13:03:17 <doyougnu> I've noticed that there are groups of the usual suspects at certain times of day. For example if I log in ~10 pm i'm almost certain to see iqubic working on a parser :p
13:14:59 * hackage wave 0.2.0 - Work with WAVE and RF64 files  https://hackage.haskell.org/package/wave-0.2.0 (mrkkrp)
13:18:14 <Younder> Got a new book on 'Asymptotic Analysis and Perturbation Theory' by William Paulsen. Seems pretty good so far. 
13:19:07 <Younder> Some of that O notation is familiar, but I am starting to realize that our coverage in CS was rather supreficial.
13:24:47 <__monty__> Younder: Yes, makes one doubt whether explaining big-O to non-CS programmers is a good idea at all.
13:26:53 <glguy> Guest62580: If you're going to be around a few times you might want to register your own nickname. jones_ was already registered by someone else.
13:27:01 <glguy> It's pretty easy to do; let me know if you need help
13:30:23 <Younder> Also I didn't really understand equivalence (~) before
13:32:02 <Younder> Funny after 30 years of mathematics I can still find holes in my knowledge, even in things I think I know, as big as a barn door..
13:35:33 <arsdragonfly[m]> hey I'm trying to install ghc with stack but it says 8.6.3 is not found in my indices
13:35:46 <glguy> arsdragonfly[m]: What command are you running?
13:35:52 <arsdragonfly[m]> The following package identifiers were not found in your indices: ghc-8.6.3
13:35:53 <arsdragonfly[m]> Possible candidates: ghc-8.6.1.
13:36:03 <arsdragonfly[m]> I'm running ```stack install ghc```
13:36:13 <glguy> arsdragonfly[m]: You use setup and not install to install new ghcs
13:37:55 <monochrom> The word "install" in the programmer world is like the word "smurf" in the Smurf world.
13:38:59 * hackage isobmff 0.13.0.0 - A parser and generator for the ISO-14496-12/14 base media file format  https://hackage.haskell.org/package/isobmff-0.13.0.0 (SvenHeyll)
13:39:59 * hackage io-streams-haproxy 1.0.1.0 - HAProxy protocol 1.5 support for io-streams  https://hackage.haskell.org/package/io-streams-haproxy-1.0.1.0 (GregoryCollins)
13:43:23 <doyougnu> monochrom: haha that just made my day
13:44:54 <monochrom> :)
13:45:17 <Solonarv> arsdragonfly[m]: you want 'stack setup --install-ghc --resolver ghc-X.Y.Z'
13:45:34 <Solonarv> also: if you happen to be on windows, install 8.6.2 instead of 8.6.3
13:45:54 <Solonarv> 8.6.3 has a bug which causes it to hang when compiling certain code
13:47:31 <monochrom> Yikes
13:48:04 <arsdragonfly[m]> <freenode_Sol "arsdragonfly: you want 'stack se"> It still says that it's using its sandboxed ghc
13:50:46 <Solonarv> yes? did you want it to install a global GHC?
13:51:59 <arsdragonfly[m]> I want a global GHC
13:52:12 <Solonarv> which OS are you on?
13:52:17 <dmj`> arsdragonfly[m]: are you sure you want a global ghc
13:52:21 <arsdragonfly[m]> Arch
13:52:31 <arsdragonfly[m]> Manjaro actually
13:52:41 <Solonarv> you probably want to install it using ghcup, then
13:53:11 <arsdragonfly[m]> Just curious, why is installing ghc globally discouraged
13:53:17 <glguy> It's not really
13:53:34 <glguy> If you're using stack, however, it works well to let stack manage its own ghcs
13:53:40 <MarcelineVQ> It's not but there's no particular thrust to do so when you're using stack. alias ghc="stack ghc"; alias ghci="stack ghci" is one easy route though
13:53:54 <dmj`> arsdragonfly[m]: conflicting ghc package lists
13:53:55 <Solonarv> (and even if you have a global ghc, stack won't use it unless you tell it to)
13:54:15 <dmj`> arsdragonfly[m]: having haskell platform ghc and stack ghc global can cause some surprises
13:54:28 <vaibhavsagar> MarcelineVQ: you mean alias ghc="stack exec --no-ghc-package-path -- ghc"
13:54:28 <arsdragonfly[m]> Basically I believe xmonad needs a global ghc to recompile itself
13:54:43 <dmj`> nix-shell -p haskell.compiler.ghc863 --run 'ghc --version' 
13:54:52 <Solonarv> if you have a stack-installed ghc, you can just add the output of 'stack path --compiler-bin' to your PATH; that's how I install ghc on windows, where ghcup isn't available
13:54:59 <vaibhavsagar> dmj`: <3
13:55:20 <dmj`> vaibhavsagar: pitchin' that nixos all day
13:55:36 <vaibhavsagar> errday
13:56:00 <dmj`> arsdragonfly[m]: and if you have multiple different ghc's then you're basically f'd with stack
13:56:23 <MarcelineVQ> dmj`: ?
13:58:21 <vaibhavsagar> stack seems convenient until you run into its hardcoded limitations
13:58:37 <vaibhavsagar> nix seems inconvenient until you need to do something even slightly complicated
13:58:59 * hackage openssl-streams 1.2.2.0 - OpenSSL network support for io-streams.  https://hackage.haskell.org/package/openssl-streams-1.2.2.0 (GregoryCollins)
13:59:06 <Solonarv> I would avoid stack completely were I not stuck on windows ATM
13:59:48 <vaibhavsagar> that's fair
14:00:04 <vaibhavsagar> although I'm skeptical that it's better than cabal
14:00:11 <vaibhavsagar> is this because it bundles mingw?
14:00:30 * hackage lame 0.2.0 - Fairly complete high-level binding to LAME encoder  https://hackage.haskell.org/package/lame-0.2.0 (mrkkrp)
14:00:39 <Heffalump> I'm quite happy with cabal on Windows
14:01:23 <Solonarv> I'm surprised at that; cabal v2-install doesn't even work!
14:01:25 <monochrom> http://danluu.com/web-bloat/
14:01:37 <dmj`> runghc Setup.hs build works great, not sure why more people don't use it
14:01:48 <Solonarv> the bundled mingw is certainly helpful, yes
14:02:06 <monochrom> oops wrong channel! should go to #haskell-offtopic
14:03:04 <Heffalump> Solonarv: I don't really care about installing, I just copy binaries I need
14:03:15 <Solonarv> yeah, I guess copying binaries works.
14:03:41 <Solonarv> it would be nice to see that added as a fallback for cabal v2-install, tbh
14:03:55 <monochrom> I think it's because "runghc Setup.hs" doesn't automate dependency chasing.  People want that.  Often I do too.
14:04:01 <Solonarv> (currently it tries to symlink and then gets mad that it can't)
14:04:21 <dmj`> monochrom: yea, that's what nix is for, but once you have that, you're set
14:05:38 <monochrom> So the question reduces to "nix works great, why don't more people go nix?" :)
14:06:04 <monochrom> Guess what, Haskell is better, why don't more people use Haskell? >:)
14:06:24 <dmj`> essentially :)
14:11:54 <Solonarv> nix works approximately not at all on windows, though :P
14:12:08 <Solonarv> (yes, yes, there's WSL and VMs)
14:12:48 <dmj`> you can cross compile things to Windows with nix
14:14:24 <Solonarv> yeah, but I mean actually working on windows, as your dev environment
14:17:24 <Heffalump> and building actual Windows executables
14:17:41 <Heffalump> oh, you said cross compiling. I didn't know that was possible.
14:17:46 <Heffalump> that might be quite interesting
14:18:11 <Heffalump> monochrom: did you mean that copying exes doesn't work because runghc Setup.hs doesn't do dependency chasing?
14:22:42 <piglet> oh! d-d-d-d-dear! A Heffalump 
14:34:58 <kritzefitz> Is there a way to have a type synonym `Foo a` that expands to `Bar (Baz a)`?
14:35:11 <johnw> type Foo a = Bar (Baz a)
14:35:33 <kritzefitz> Yes. I think I need to refine my question.
14:35:39 <johnw> :)
14:36:51 <kritzefitz> I need to make a “type function” `\a -> Bar (Baz a) :: * -> *`
14:37:11 <kritzefitz> Regular type synonyms don't work, because they always need to be fully applied.
14:37:39 <geekosaur> type functions aren't a thing
14:38:06 <geekosaur> (well, they are in core, but not in haskell)
14:38:13 <johnw> type family Foo a where a = Bar (Baz a)?
14:38:15 <geekosaur> aside from type families
14:38:19 <geekosaur> but those have limitations
14:38:43 <dminuoso> kritzefitz: `type Foo = Bar :.: Baz` though that gives you a Compose newtype layer.
14:38:47 <kritzefitz> johnw: I think type families also have to be fully applied, just like type synonyms.
14:39:14 <dminuoso> kritzefitz: What exact problem are you trying to solve?
14:40:25 <kritzefitz> I have a type `t :: (* -> *) -> *` and I would like to pass something like `(Foo (Bar a)`, so the type argument end up as an argument to `Bar`.
14:42:35 <Solonarv> Yeah, you're going to need a newtype.
14:42:53 <Solonarv> (you can use an existing one, e.g. Data.Functor.Compose.Compose)
14:42:56 <dminuoso> kritzefitz: The :.:/Compose solution would work.
14:43:08 <johnw> that's the newtype solution :)
14:44:10 <HenryCH> hi, I'm following along with a course (beginner) that's just a few lines using the scotty module, but when i run cabal install, several modules fail to install with errors like "conduit-extra-1.3.0-5SjnoBlAzliCtZLMf9mVi0 depends on conduit-extra-1.3.0 which failed to install.", any idea what I'm missing? i'm on windows
14:44:47 <glguy> HenryCH: Well be able to help better if you include the command you tried all the full error message in a paste bin like gist.github.com
14:45:47 <kritzefitz> Oh, I was hoping to get around the newtype. Thanks for clearing that up!
14:46:31 <HenryCH> i did "cabal init", then added scotty and text to build-depends, and then "cabal install --only-dependencies"
14:47:13 <HenryCH> ill paste the full install log one sec
14:47:15 <zachk> does cabal install work?
14:52:29 <HenryCH> https://gist.github.com/Trudodyr/43ee57e6e8509cf2dd18b27fe537ff87
14:56:03 <dmwit> HenryCH: Check out line 70
14:57:24 <HenryCH> do I need one of those two toolchains?
14:57:33 <dmwit> Sounds like it to me.
14:57:37 <HenryCH> i installed haskell platform, i guess thats not enough
14:58:37 <dmwit> HenryCH: You could try `cabal install --constraint 'old-time installed' --constraint 'network installed'` to see if it would be willing to avoid rebuilding those two packages.
14:58:39 <HenryCH> the presenter of the course is also on windows so i assume it's not a problem with the packages or the config
14:58:51 <dmwit> It might work, or it might give you an interesting error about what dependency conflicts that introduces.
14:59:19 <Solonarv> that's a really strange error to be getting, especially because GHC (and the Haskell platform) on windows come with a bundled mingw/msys
14:59:21 <dmwit> err... I don't really know how quoting works on Windows. It might need to be " instead of ' or something.
15:01:11 <HenryCH> where does cabal install packages to?
15:01:23 <sclv> check the cabal config file
15:01:37 <zachk> on windows it's under app roaming something I believe 
15:01:40 <zachk> :-(
15:02:24 <Solonarv> why does that merit a frown? it's %appdata% is the canonically correct place for programs to store data
15:02:26 <HenryCH> looks like i already have cygwin so that won't help
15:03:32 <HenryCH> could it be haskell platform didnt install it because it detected i already had it, but it's not in my path?
15:03:50 <Solonarv> that sounds really unlikely
15:05:38 <HenryCH> sclv: where can i find the cabal config file? (i didnt create any myself)
15:08:38 <dminuoso> So let's say I want to really change the Show instance for bytestring, what is the cleanest way of doing this? Right now my thought is to create some AltShow class with some `instance {-# OVERLAPPABLE #-} Show a => AltShow a ` and `instance {-# OVERLAPPING #-} Show ByteString`, but Im not a big fan of it.
15:09:24 <Solonarv> uhhh... fork 'bytestring'? I got nothing.
15:09:49 <Solonarv> (or did you mean 'instance {-# overlapping #-} AltShow ByteString' ?)
15:10:02 <dminuoso> Oh. Yes.
15:10:15 <Solonarv> that seems like the least bad option to me.
15:10:32 <dmj`> newtype?
15:10:55 <dmj`> newtype the bytestring you want to make a custom Show for, then do the dirty
15:11:06 <dminuoso> dmj`: That would be one major refactoring.
15:11:13 <HenryCH> dmwit: your suggested command didn't work, appreciate the effort though :)
15:11:24 <dminuoso> There's this pervasive ADT with about 130 constructors, many of which have ByteString glued in.
15:11:29 <dminuoso> And this leaks throughout the program.
15:11:57 <Solonarv> oof
15:12:07 <dmj`> dminuoso: You should probably always newtype any kind of stringly-typed data, for your own sanity 
15:12:13 <dmj`> so it sounds like a good refactor to do
15:12:29 <Solonarv> I'd expect that you can do a good chunk of the refactoring with sed, tbh
15:12:55 <dmj`> emacs find and replace in all buffers is amazing
15:13:00 <dmj`> dminuoso: ^
15:13:16 <dmj`> dminuoso: https://stackoverflow.com/a/271136
15:13:34 <dmj`> I just used this to modify 90 files
15:13:38 <dminuoso> dmj`: Mmm. Perhaps, Ill give it some thought. I am rather reluctant for some reasons, but it remains an option.
15:13:51 <dmj`> dminuoso: newtype liberally
15:14:11 <dmj`> newtype your newtypes
15:20:31 <bsima> M-x projectile-replace does the same thing
15:23:07 <sclv> HenryCH: see the windows install instructions here https://www.haskell.org/platform/
15:28:05 <HenryCH> looks like i already have those 3 lines in my cabal config
15:29:02 <sclv> Do they point to legit locations?
15:29:33 <HenryCH> i'll try a fresh install of haskell platform, i have 8.4.3, will try with 8.6.3
15:29:34 <sclv> And are you running from a cyg shell or just a dosprompt
15:29:40 <HenryCH> yes they are fine
15:29:44 <HenryCH> from powershell
15:30:02 <sclv> Hrm its weird but try a dosprompt
15:30:14 <sclv> Otherwise no ideas, sorru
15:32:33 <HenryCH> no luck with dos either
15:32:38 <HenryCH> no worries
15:32:39 <HenryCH> thanks for trying
15:34:59 <HenryCH> ill go sleep and resume tmrw, thks for the help, bye
16:07:41 <comstar> does the monolithic size of ghc make anyone else nervous
16:08:06 <c_wraith> should it?
16:08:11 <comstar> in terms of how it's de-facto the languages compiler, size as in prevalence/use
16:08:35 <c_wraith> it's not like production compilers are simple things.
16:09:26 <Solonarv> I don't think it's a problem, considering that it's not only open-source, but also no one party has an overwhelmingly large share in it
16:09:30 <c_wraith> there have been other compilers. they quickly fall away as they can't keep up with what people are doing with ghc.
16:09:31 <comstar> doesn't "production compiler" imply the ability to bootstrap
16:09:59 <Solonarv> define "bootstrap"
16:10:25 <c_wraith> the exceptions being the private compilers Lennart has made for his company, which do track features with ghc
16:10:25 <Solonarv> GHC is compiled by itself, after all
16:10:35 <comstar> you can't compile ghc with anything other than ghc, and even then there's breaks in which versions can compile what
16:11:02 <comstar> so you can't do the bootstrapping step that allows you to install compilers for a language like C on arbitary hardware/instruction sets
16:11:40 <Solonarv> ...that is the *exact opposite* of the usual meaning of "bootstrap"
16:11:52 <comstar> https://en.wikipedia.org/wiki/Bootstrapping_(compilers) not really
16:12:02 <c_wraith> you can build ghc for new architectures
16:12:12 <c_wraith> the arm ports are relatively new.
16:12:19 <comstar> using GHC, externally, and then copying it over
16:12:23 <comstar> which isn't bootstrapping
16:12:30 <c_wraith> it gets the job done.
16:13:12 <c_wraith> a platform which previously did not have ghc does afterwards
16:13:16 <comstar> so in spite of the fact that 'production compiler' implies the ability to bootstrap you're claiming that it's a non-issue
16:13:39 <c_wraith> production compiler implies it's suitable for building production software
16:13:44 <c_wraith> which it is.
16:13:51 <Solonarv> consider that most production use of Haskell (and lots of other languages!) does not involve targeting a novel platform
16:13:55 <wroathe> comstar: Seems like a good project for you
16:14:03 <wroathe> comstar: Let us know when you're finished :D
16:14:07 <comstar> wroathe I'm not the only person who has it in mind
16:14:22 <comstar> but I appreciate your sarcastic blessings on the topic
16:15:08 <wroathe> I'm not being sarcastic. Thing x doesn't do what you want it to do. Your choices are: modify thing x, make a thing y, or move on to a different problem
16:15:14 <phadej> comstar: what's your argument?
16:16:14 <c_wraith> I'm still not even sure what the problem is.
16:16:51 <phadej> indeed.
16:16:55 <c_wraith> ghc is used because it lets people keep up with fancy new features. ghc is a bear to port to a new platform, but it can be done.
16:17:11 <comstar> https://haskellweekly.news/issues/138.html was reading "thoughts on bootstrapping GHC"
16:17:17 <Solonarv> (I hear the LLVM backend is helpful for doing that)
16:17:53 <c_wraith> Solonarv, llvm is not as platform independent as you'd hope. it usually goes via the unregisterized C backend.
16:18:20 <Solonarv> oh? I thought that had gotten ripped out by now
16:18:40 <c_wraith> nah. -fvia-c was removed.
16:19:02 <c_wraith> but the unregisterized blackend is still around and very suboptimal.
16:19:18 <c_wraith> it's really only good for porting to a new platform.
16:19:40 <Solonarv> oh, I think I recall reading that article
16:20:12 <Solonarv> requiring itself to build is certainly an issue GHC has, but I think it's largely orthogonal to production use
16:21:03 <c_wraith> most languages see having a self-hosted compiler as a milestone.
16:21:38 <phadej> yes, and maintaining the boostrappability is really a pain
16:21:44 <c_wraith> that's one of the big things Blodwin is going for - compiling via itself, unlike Idris being written in Haskell
16:22:28 <phadej> you'd need to maintain two compilers (more work), or/and restrict the language used in compiler itself (not fun)
16:23:02 <phadej> I can imagine someone writes an interptetter which could bootstrap ghc-stage1 one though
16:23:08 <phadej> but it would be so slow...
16:23:11 <c_wraith> I guess ghc is more like two compilers, with the build-time backend selection
16:23:46 <phadej> (to use interpretted version of GHC to compile GHC itself)
16:24:03 <comstar> c_wraith: see but it's still not *technically* self hosted, see Perl 6's issue with that here (and why they tried GHC as their interim compiler) https://wiki.haskell.org/wikiupload/9/9d/TMR-Issue1.pdf
16:24:32 <comstar> everything under What Is Haskell is relevant here
16:24:43 <phadej> comstar: what's the benefit of boostrappability, or self-hostness?
16:25:03 <phadej> what's the problem you are facing?
16:25:04 <comstar> phadej: chain of trust is an easy one 
16:25:10 <comstar> not that it's a problem I'm facing
16:25:22 <phadej> is it a problem?
16:25:30 <phadej> like practical problem?
16:25:34 <comstar> yes
16:25:40 <phadej> I don't see it
16:26:08 <comstar> then you didn't read the article I linked from haskell weekly
16:26:34 <phadej> I did
16:26:38 <phadej> it starts with "The latest hottest thing within the reproducible-builds project seems to be bootstrapping: How can we build a whole operating system from just and only source code, using very little, or even no, binary seeds or auto-generated files."
16:26:55 <comstar> okay then I can link articles about chain-of-trust attacks
16:26:58 <nshepperd1> You mean, defending against ken Thompson's trusting trust attack by building with several different compilers?
16:27:22 <comstar> say spectre comes out tomorrow where it turns out someone put malicious code somewhere down the line in haskell's compilation, say, 15 years ago
16:27:43 <comstar> not spectre, but a spectre-like situation
16:27:47 <comstar> more like shellshock though
16:28:27 <phadej> and GHC keeps compiling backdoors into itself for all that time?
16:28:59 <comstar> there's the Ken Thompson situation outlined above and the proof-of-concepts using TCC/etc in the case of C compilers, yeah
16:30:50 <comstar> https://www.schneier.com/blog/archives/2006/01/countering_trus.html also here
16:31:42 <comstar> nshepperd1: but to come back to you yes exactly
16:34:13 <ned> anyone use bidirectional maps in haskell? which is preferable: the 'bimap' or 'bimaps' package?
16:34:16 <phadej> and is situation better with anything else, than C?
16:35:02 <comstar> I'm tired of you asking questions to lead me socratically somewhere while I link valid information here that you just push aside to ask more questions phade
16:35:18 <comstar> you can just say you don't care and move on
16:35:27 <phadej> comstar: no, I really worried, is the Haskell where this worry have to be started
16:35:35 <comstar> mp ot
16:35:39 <phadej> Haskell doesn't run this world (unfortunately)
16:35:48 <comstar> no it's a general issue, though I'm sorry that I misunderstood your intention
16:36:19 <phadej> it's really not a priority for a small community
16:36:40 <Solonarv> you're right that it's an area Haskell is lacking in, but it's also not a priority for the Haskell community
16:37:10 <Solonarv> It also doesn't prevent Haskell from being used commercially, which is how I understand "production"
16:37:59 <comstar> that's true
16:39:08 <comstar> phadej: but to follow up one of the ways of mitigating that kind of attack was described here https://dwheeler.com/trusting-trust/dissertation/html/wheeler-trusting-trust-ddc.html#0.Abstract but to do that he used two different compilers
16:39:30 <phadej> comstar: and what other languages are mitigating this problem?
16:40:05 <MarcelineVQ> Jokes on the software world when the linker turns out to be the actual vector.
16:40:14 <Solonarv> "any language which has a compiler not written in the language itself" is what I understand the answer to be
16:40:46 <phadej> joachim's blog post mentiosn ocaml and scala to be viable, but at least scala is even worse
16:41:26 <phadej> implementing haskell compiler in not haskell is not a popular idea :)
16:41:44 <comstar> everyone is in some way or another.  I'm not saying haskell is particularly vulnerable in any case, there's reasons to trust the chain from which everyone gets ghc because of its sheer distribution and that anyone could check against something they got offline
16:42:03 <comstar> MarcelineVQ linkers are terrible things even without malicious code injection 
16:42:38 <comstar> not terrible as in bad just terrible like a terrible tyrant or a terribly tall staircase
16:42:48 <phadej> in any case, it would be interesting to see another haskell compiler emerge
16:43:02 <phadej> but I don't really see _this_ discussion_ to be a motivation for that
16:43:08 <comstar> yeah
16:43:51 <comstar> I mostly just wish there was an alternative that traded 'optimal bytecode' for 'fast compilation' or a minimal compiler base system compared to ghc
16:44:25 <phadej> there's little (commercial) interest in having such
16:47:05 <phadej> even academics don't have interest in making new haskell compiler, they rather build compilers for new languages using GHC
16:47:21 <comstar> maybe.  but then I don't know if someone makes a cool piece of software if the foss community will be overjoyed with having to install ghc to run it, as is the case wiht xmonad and the people who aren't enthusiastic to install it for that reason
16:47:48 <comstar> when people review tiling window managers that's one of the first things they list as a caveat for xmonad
16:48:14 <phadej> that it's not made with self-boostrapping compiler?
16:48:29 <phadej> my problem with xmonad was that I needed to learn Haskell to be able to configure it
16:48:45 <phadej> (and keep an environment so it can be reconfigured)
16:49:03 <Solonarv> xmonad is rather unusual in that it requires GHC at runtime; most other software written in Haskell can simply be compiled once Somewhere Else and then you download a binary, without ever touching GHC
16:49:52 <Solonarv> for example, pandoc is also written in Haskell, and compiled using GHC; you don't see people complaining about that!
16:55:45 <koz_> Pandoc is generally very cool.
16:56:02 <koz_> It's more-or-less the first example I give when asked about 'what software's been written in Haskell?'.,
16:56:07 <Solonarv> yup, same
16:56:45 <Solonarv> I usually also mention that facebook uses it for its spam filter
17:00:08 <koz_> Did not know that.
17:00:10 <koz_> Thanks.
17:00:16 <koz_> I'll use that one too.
17:00:21 <rasusto> xmonad really is an exception because it has to be recompiled for configuration. That's an implementation choice, not a consequence of using haskell. It could also use config files if somebody wanted to implement that
17:01:00 <Clint> there are a handful of things that use dyre
17:01:19 <Solonarv> dhall would be neat for xmonad configuration
17:08:16 <koz_> What's a good Haskell library for HTML scraping?
17:08:28 <koz_> Like BeautifulSoup from Python, only with 100% more types.
17:08:56 <Solonarv> I think tagsoup has a similar concept?
17:09:22 <Solonarv> I haven't used it, though
17:09:32 <koz_> Solonarv: It looks like what I'm after, at least.
17:27:24 <AndrewR> So, this is the secret Haskell hideout huh. What are you rascals up to? 
17:29:22 <Solonarv> hiding our secrets!
17:29:25 <Solonarv> :>
17:31:00 <AndrewR> :-D
17:32:30 <dyl> AndrewR: avoiding success at all costs.
17:36:23 <AndrewR> At all costs? Implying Haskllers have costs to expend. You gotta program in JavaScript if you want to make money. Everyone knows that. 
17:37:23 <Solonarv> nono, you've got it wrong; "success at all costs" is the thing we're avoiding
17:38:12 <MarcelineVQ> implicit commas are almost as bad as implicit conversion
17:38:57 <jmcarthur> We "avoid (success at all costs)", not "(avoid success) at all costs".
17:39:22 <jmcarthur> But I'm not sure whether that's just a retroactive change of meaning.
17:40:38 <Solonarv> AFAIK it has always meant the former, but was intentionally phrased that way because it's funny
17:48:28 <iqubic> So, trying to make a right associative grammar remains a pain.
17:49:14 <iqubic> by which I mean, a grammar for parsing right associative infix binary operators.
17:49:51 <Solonarv> well
17:50:08 <Solonarv> the easy solution is to parse as an unassociated list, and reassociate later
17:50:25 <iqubic> yeah, I know.
17:51:30 <iqubic> I have a list of Tokens that have been found by my lexer already. I just need to parse it now.
18:59:30 * hackage continued-fractions 0.10.0.1 - Continued fractions.  https://hackage.haskell.org/package/continued-fractions-0.10.0.1 (rockbmb)
19:30:59 * hackage persistent-mysql-haskell 0.5.2 - A pure haskell backend for the persistent library using MySQL database server.  https://hackage.haskell.org/package/persistent-mysql-haskell-0.5.2 (naushadh)
19:36:00 * hackage continued-fractions 0.10.0.2 - Continued fractions.  https://hackage.haskell.org/package/continued-fractions-0.10.0.2 (rockbmb)
19:39:56 <_deepfire> hayoo down.. : -/
19:41:45 <iqubic> Been noted earlier.
20:14:33 <maerwald> anyone has a working example of ghcid with cabal new-build where cabal.project is not in the source dir?
20:17:22 <Solonarv> ghcid --command "cabal new-repl --project-file='path/to/project.cabal'" should work?
20:18:58 <maerwald> ghci already works
20:19:01 <maerwald> but not ghcid
20:19:57 <Solonarv> that's strange, what's going wrong? are you getting an error message, or is ghcid failing to reload?
20:20:25 <maerwald> No files loaded, GHCi is not working properly.
20:22:23 <Solonarv> hm.
20:22:44 <Solonarv> what are the command lines you're using?
20:25:33 <e2> -console
20:25:39 <e2> -shell
20:25:52 <e2> -port 443
20:26:55 <maerwald> Solonarv: it seems you have to tell ghci to :load a module or something. And cabal new-repl doesn't seem to work. It only loads one module and the shell prompt seems broken of ghcid
20:27:12 <Solonarv> hm.
20:28:03 <Solonarv> I don't have an immediate solution, and I think I need to sleep
20:28:07 <Solonarv> good luck!
20:29:08 <e2> guf luck
20:33:29 <maerwald> Isn't ghcid supposed to recompile when you change a module?
20:33:54 <maerwald> It seems this is all a mess, even prompt doesn't work lol
20:37:55 <glguy> ghcid doesn't have a prompt
20:38:06 <glguy> Did you get the cabal.project file working outside of the src tree?
20:53:12 <maerwald> of course it works outside of the src tree
20:53:17 <maerwald> as does ghci
20:54:33 <maerwald> but ghcid expects you to :load modules explicitlz as it seems
20:59:11 <gentauro> I asked a few days ago on feedback on `modelling state machines with types`. Based on my initial code, I created the following library that easily can represent FSM logic with the type system (no implementation needed) -> http://blog.stermon.com/articles/2019/01/29/haskell-model-finity-state-machines-fsm-with-types.html
20:59:25 <gentauro> why isn't Haskell used more (everywhere and by everyone?)
21:01:13 <maerwald> gentauro: because it doesn't strive for simplicity and ease-of-use, which are more valued in production than elegant solutions. In addition, project managers often have little understanding of maintenance cost. So the strongest point of haskell falls short.
21:02:47 <maerwald> glguy: ah, I thought I can inspect stuff?
21:03:18 <glguy> any time I've used ghcid it's been automatic, no interaction from me
21:03:46 <maerwald> firing up two reply is quite expensive
21:03:50 <gentauro> maerwald: it strives for robustness. I can understand that many IT-projects don't need this kind of approach, but many `business-critical` do.
21:04:01 <maerwald> gentauro: not sure that's true
21:04:06 <maerwald> depends how you define robustness
21:04:23 <maerwald> wide term
21:04:30 <gentauro> the amount of man(woman) hours spent on `magic` is sad
21:05:11 <gentauro> maerwald: robustness = if you are able to make `business people` model the domain (thoroughly)
21:05:21 <gentauro> you should be able to implement it afterwards
21:06:03 <gentauro> Philip Wadler mentioned the Danish Department of Deon Digital, where they have `financial engineers` (no coding background) maintaining the `smart contracs`
21:06:44 <maerwald> gentauro: how is that related to the programming language?
21:07:14 <gentauro> maerwald: DD have written a CSL (Contract Specific Language) in Haskell
21:07:24 <maerwald> There are many other ways to write specs
21:07:29 <maerwald> and even to derive code from them
21:07:39 <gentauro> which allow non-code-monkeys to write contracts in `code` instead of Word documents
21:07:44 <maerwald> I classify this as formal methods
21:09:52 <maerwald> e.g. https://en.wikipedia.org/wiki/Z_notation
21:11:09 <maerwald> I would argue it's not a language property of robustness, but more the fact that haskell is more suitable to write DSLs in the first place
21:11:19 <gentauro> i guess my point is that you can limit Haskell just to the domain you are working with.
21:11:28 <gentauro> yes, DSL are the keyword
21:11:40 <maerwald> And that is also the problem with it ;)
21:11:43 <maerwald> And why not everyone is using it
21:12:05 <maerwald> Proper DSLs are 1. hard and 2. you need someone to write it and 3. you need a clear picture of the domain and...
21:12:19 <gentauro> can we just say that Haskell has a very powerfull `linter`? Then all JS people will join
21:12:23 <maerwald> Most projects don't work that way
21:12:40 <bsima> haskell is a DSL for category theory
21:13:21 <gentauro> most projects just build layers of "best practices" based on systems that probably never should be used as a `template` in the first place
21:13:56 <maerwald> IMO, once the mindset changes to first modelling the domain, then writing proper specifications... it doesn't really matter anymore what language you use.
21:14:09 <maerwald> Then you have actual software engineering :)
21:14:47 <gentauro> I would disagree. If you can encapsulate your domain in algebraic datatypes. If you turn on `pedantic` Haskell, it's very difficult to code wrong ...
21:15:14 <gentauro> as Yaron Minsky says: "Make impossible states unrepresentable"
21:15:32 <gentauro> I find it hard to achieve that with OOPD or imperative languages ...
21:16:23 <maerwald> gentauro: Z and c++ has worked well for maeslant kering for example
21:17:31 <maerwald> https://pdfs.semanticscholar.org/ea42/130af08f4492e9dcbcbb0c81b164fc46b38d.pdf
21:18:08 <gentauro> https://en.wikipedia.org/wiki/Maeslantkering#cite_note-5
21:18:38 <gentauro> 200.000 lines of C++ code, for a project that important could be easily maintained (if generics are used)
21:18:44 <dmj`> has anyone used cabal-macosx
21:18:47 <dmj`> successfully
21:19:07 <glguy> yeah
21:19:15 <glguy> I use it for my cookie clicker calculator
21:20:00 <maerwald> gentauro: language specifities are not that important here imo. The point is to use formal methods. And I'm not sure haskell is actually that good for this, except when you write DSLs that output e.g. C code?
21:20:36 <maerwald> I am confident they would not have written it in haskell simply because it's unclear how the binary actually behaves
21:21:06 <dmj`> glguy: is your code open source? I'd like to inspect how you did it. I'm able to build, but no app bundle is produced unfortunately
21:21:50 <maerwald> gentauro: which is why I think "robustness" is a bit far fetched as a general selling point for haskell, since you are too detached from the low-level machinery for some things to be robust (e.g. cryptography)
21:21:51 <gentauro> maerwald: the problem with generating C code, is the cornercases that you don't handle
21:22:30 <maerwald> maintenance is the main selling point for haskell imo, but project managers don't care about it, you can't measure it up-front ;)
21:22:30 <glguy> https://github.com/glguy/CookieCalculator/
21:23:18 <gentauro> if you want to code on bare metal, use assembly (or C). If you can't live with long developing time, well you can go C++/Java/... but why nobody goes Haskell?
21:23:55 <maerwald> gentauro: well, as I already said ;)
21:24:07 <gentauro> maerwald: maintenance is many times a primary selling point as many companies make the money on the maitenance contract (they normally loose money on the project)
21:24:09 <maerwald> simplicity and ease of use are not priorities
21:24:46 <maerwald> gentauro: oh well, but that goes different, they sell you frameworks to reduce maintenance, they don't sell you languages
21:26:31 <gentauro> I mean, if you work with companies that only purchase stuff from MS, don't come with systems built on Java
21:27:23 <maerwald> gentauro: also, intellectual complexity and employment market is another problem
21:27:43 <maerwald> not that big, but big enough to never be able to compete with other languages
21:28:17 <maerwald> Although some would argue it's more a marketing problem
21:29:12 <maerwald> I don't think haskell needs more marketing though, a lot of people have heard of it by now and it has this "magical thing, smart people" association, even if no one knows what it is
21:29:12 <gentauro> a few weeks ago, I taught an intro course in Haskell and the participants complained a bit that the tasks were a bit `non-realistic`. So I saw a connection on LinkedIn like a blog post about `Open Banking`. I made this in almost no time (afternoon) -> https://gitlab.com/spisemisu/openbanking-sparnord/tree/master
21:29:25 <Welkin> please no marketing
21:29:37 <Welkin> look at language that get too much marketing or focus on it
21:29:38 <Welkin> no thanks
21:29:45 <Welkin> they turn into crap
21:30:19 <gentauro> I sent it afterwards to the bank and the guy from the bank (uses R) was like. Oh, type safe domain, just by copy/pasta from our spreadsheet? ME GUSTA ...
21:30:20 <maerwald> Not sure that is the reason. It's more that marketing usually goes with other assumptions
21:30:23 <Welkin> anyone learning haskell should be doing it to expand their knowledge
21:30:25 <Welkin> not to get a job
21:30:36 <Welkin> that's how you get apathetic programmers who write java and javascript
21:31:15 <Welkin> I don't think haskell has any kind of "marketing" problem
21:31:34 <Welkin> it was never meant to be a practical-use industry language
21:31:38 <Welkin> it's a research language
21:31:49 <gentauro> maerwald: how is this not simple enough for anybody to read? -> https://gitlab.com/spisemisu/openbanking-sparnord/blob/master/src/Main.hs#L42-54
21:32:20 <Welkin> it just happens to be very good for practical things as well
21:32:28 <gentauro> I mean. Can't we get more Haskellers (who know how to speak publicly) to go to main conferences and show stuff like this?
21:32:41 <Welkin> no
21:32:50 <Welkin> we have plenty of functional programming conferences
21:33:01 <Welkin> you don't go to a javascript conference and talk about c#
21:33:30 <gentauro> Welkin: I have been organizing the Meetup for Functional Copenhageners for the last 5 years
21:33:42 <gentauro> I know what happens when only FP people are together ...
21:34:20 <gentauro> Before, I used to give my talks at my own group, now I don't do it. We need to get this stuff out everywhere
21:35:01 <maerwald> gentauro: people like to experiment with haskell and those experiments usually don't end up as easy to understand and clear code and that is fine and expected. So the vibe people get when they go to FP conferences is "hey, look, did this crazy thing" ;)
21:35:04 <maerwald> Not sure what you expect
21:35:09 <maerwald> You can't have both
21:35:30 <gentauro> right now, one of the more popular guys in Copenhagen, he is giving a talk about how they went away from C# to F# (https://www.meetup.com/GOTO-Nights-CPH/events/258263614/)
21:36:03 <gentauro> and his numbers are pretty nice (80 - 100 people everytime).
21:36:38 <gentauro> I actually asked him why he never gave a talk at MF#K. And he said: "You FP guys `scare` me. I don't think I'm good enought to give a talk to you"
21:36:53 <gentauro> so that's where I learned MF#K was doing it wrong :(
21:39:20 <gentauro> maerwald: "avoid success at all cost"? :-)
21:42:09 <maerwald> haskell doesn't care to onboard more people and beginners, elm does and they have to make heavy sacrifices for that
21:42:30 <dmj`> glguy: cabal build just doesn't build a bundle for me, for some reason. Unsure why. I have a basic hello world app. 
21:42:40 <dmj`> with the Setup.hs and custom-setup defined
21:44:25 <gentauro> maerwald: and I personally think `elm` is doing it wrong
21:44:59 <gentauro> for everytime they "diminish" `elm`, they loose some of the people that know what they are doing
21:45:22 <gentauro> which I find kind of sad (I used to make libraries for `elm`)
21:45:57 <maerwald> Yes, so there you have the reason why haskell is not used more
21:46:33 <gentauro> but I don't think Haskell needs to compromise, we just need people who can take the time, with good teaching skills, to show how nice the language is
21:46:33 <maerwald> sometimes it's better that way ;P
21:47:27 <gentauro> people coming to mind like Oskar Wickstrom -> https://haskell-at-work.com/
21:47:44 <gentauro> and the russian guy solving coding problems (don't remember his name)
21:48:12 <gentauro> it's not "rockets science" what they are doing. It's basic Haskell with it's syntax
21:49:37 <maerwald> "there was a russian guy" xD
21:50:28 <gentauro> :D
21:50:51 <gentauro> the hackerrank "russian guy"
21:50:51 <gentauro> :D
21:51:02 <gentauro> (he is quite funny)
21:51:31 <gentauro> and he is also good at teaching (just watch the comments from his videos)
22:45:29 <maerwald> cabal new-repl doesn't read .ghci?
22:55:58 <linh> join #cjdns
