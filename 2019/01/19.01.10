00:07:28 * hackage conduit-algorithms 0.0.9.0 - Conduit-based algorithms  http://hackage.haskell.org/package/conduit-algorithms-0.0.9.0 (luispedro)
00:27:27 * hackage hyraxAbif 0.2.3.15 - Modules for parsing, generating and manipulating AB1 files.  http://hackage.haskell.org/package/hyraxAbif-0.2.3.15 (andrevdm)
00:31:43 <quicksilver> monochrom: actually I have a joke about UDP. I'd tell you but I'm not sure you'd get it.
00:34:22 <jacksap[m]> <freenode_qui "monochrom: actually I have a jok"> 🤣
00:34:56 <jacksap[m]> 🤣
00:35:16 <coldpress> where is liftA2 defined for arrows?
00:40:06 <lyxia> coldpress: what about (&&&)
00:40:48 <coldpress> lyxia: doesn't (&&&) split though? I want to unsplit, like in this diagram: https://wiki.haskell.org/Arrow_tutorial#An_Example
00:42:07 <lyxia> :t \f a b -> (a &&& b) >>> uncurry f
00:42:09 <lambdabot> (c1 -> c' -> c2) -> (a -> c1) -> (a -> c') -> a -> c2
00:42:13 <lyxia> how's that
00:44:17 <coldpress> thats great actually, thanks
00:45:45 <lyxia> yay
01:00:13 <hc> hi all
01:00:43 <hc> Languages that strictly separate their core semantics and make all interactions with the real world possible merely through APIs
01:00:56 <hc> vs languages that have, for example, intrinsic print statements that are unlike other function calls
01:01:07 <hc> I'm looking for terms to describe and differentiate between these two kinds of languageas
01:04:52 <lyxia> apricot languages: small and with a well-defined kernel, watermelon languages: big and with seeds all over the place.
01:06:38 <dminuoso> hc: On what basis are you looking to differentiate these languages?
01:07:17 <[exa]> hc: fat/slim/no runtime?
01:07:52 <hc> dminuoso: to refer to them as distinct classes of languages in a written text
01:08:35 <dminuoso> lyxia's classification is the first I've read to make that distinction.
01:08:46 <dminuoso> Henceforth there shall be watermelon and apricot languages.
01:08:52 <hc> ok, thanks!
01:09:43 <dminuoso> hc: It seems to me that the difference might be in the number of builtins.
01:10:07 <dminuoso> Or maybe even `keywords`
01:23:43 <hc> dminuoso: could you point me to lyxia's classifications?
01:23:51 <hc> dminuoso: google search kinda doesn't help me
01:24:00 * Ariakenom points up
01:24:13 <Ariakenom> lyxia> apricot languages: small and with a well-defined kernel, watermelon languages: big and with seeds all over the place.
01:24:34 <hc> oh
01:24:39 <hc> sorry, silly me
01:24:44 <lyxia> :)
01:24:47 <hc> i thought that was a kind of a paper :)
01:24:55 <hc> i had ignored the backlog ;/
01:26:45 <lyxia> I'm sure some languages are bananas too.
01:35:26 <Lears> Is there a common (or otherwise obvious) name for `f :: Either Void a -> a`?
01:38:25 <lyxia> fromRight? I mean, it may have a more general type, but the intention is the same.
01:42:33 <Lears> I read `fromRight` as `unsafeFromRight`. The point of having an ~equivalent function with a more restrictive type is to be safe and communicate that fact.
01:46:39 <lyxia> safeFromRight then
01:48:36 <jle`> Lears: it's `either absurd id` in code
01:49:03 <jle`> Lears: but also i guess it's "left identity of addition", as well
01:49:44 <jle`> Lears: it's the "left identity property of addition", being able to reduce (0 + x) = x
01:50:05 <jle`> that might be the high-level name you're looking for?
01:55:29 <Zvpun> I'd like to understand the difference between `<*` and `flip *>`. For `Maybe` they seem to be the same, but they differ for `[]`.
01:56:20 <Lears> It's true that's what it evidences, but I don't see a good identifier/name coming out of it. `leftZero`?
01:56:55 <Ariakenom> % (flip (*>)) (print 1) (print 2)
01:56:55 <yahb> Ariakenom: 2; 1
01:57:09 <Ariakenom> % (<*) (print 1) (print 2)
01:57:09 <yahb> Ariakenom: 1; 2
01:57:28 <Ariakenom> Zvpun
01:59:32 <Lears> Re `safeFromRight`, I considered that after I mentioned `unsafeFromRight`, but it's a bit clunky/ugly. I'm hoping for something shorter and sexier. Atm I have `extract`, and am ignoring the collision with Comonad. Though maybe there is a valid comonad there anyway.
02:00:28 <Taneb> Lears: have you seen http://hackage.haskell.org/package/perhaps-0/docs/Data-Perhaps.html ?
02:01:34 <lyxia> Either Void is isomorphic to Identity, which is a comonad.
02:01:53 <merijn> Isn't that just either + absurd?
02:02:03 <merijn> :t either absurd id
02:02:04 <lambdabot> Either Void c -> c
02:02:20 <merijn> Bam! No tricky business or nonsense
02:02:45 <merijn> That's the entire reason we have absurd
02:05:18 <Lears> I stumbled upon Perhaps recently but forgot about it -- I guess it is relevant. The equivalent there is `believe`, which isn't bad.
02:05:48 <Zvpun> Are there laws for (<*) and (*>)?
02:06:15 <merijn> Zvpun: Yes, in the sense that they're defined in terms of <*>
02:06:31 <merijn> Zvpun: What are you wondering about?
02:06:38 <jle`> Zvpun: x <* y = const <$> x <*> y
02:06:54 <jle`> Zvpun: x *> y = flip const <$> x <*> y
02:06:55 <Lears> merijn: I'm aware it's simple to define, I'd still prefer to write it once and minimise my direct use of `absurd`.
02:07:35 <Zvpun> I read the type signature and tried to give an implementation for them then I saw the default implementation and was confused. I am looking for the argument that rules out that `(*>) = flip (<*)`. Currently I think there could be laws for that.
02:07:38 <jle`> Zvpun: the difference between <* and flip *> is important for "non-commutative applicatives"
02:07:44 <merijn> Lears: If you want short and descriptive I think I'd just name it fromEither to imply totality and not be as unwieldy as safeFromRight
02:08:02 <merijn> Zvpun: "flip (<*)" also reverses the order of effects
02:08:23 <jle`> Zvpun: applicative <*> essentially "sequences" effects, and <* and *> sequences effects in opposite order
02:08:32 <Zvpun> merijn: Yes Ariakenom's example was helpful
02:08:35 <jle`> Zvpun: the difference only matters in Applicatives where sequencing of effects is not commutative
02:08:40 <merijn> jle`: Wut
02:08:51 <merijn> jle`: They don't sequence in opposite order
02:09:01 <merijn> They sequence effects in the exact same order...
02:09:05 <jle`> ah yeah, sorry :) i meean *> and flip <*
02:09:23 <jle`> answering the original question, "the difference between (<*) and flip (*>)"
02:09:53 <jle`> Lears: direct usage of absurd isn't something to avoid :)
02:10:00 <Zvpun> Ignore my question it comes from a confused mind. Sometimes asking the right question is already half the way to understanding and I don't think I am there yet.
02:10:08 <jle`> Lears: one thing you're running into here is the "fairnbairn principle"
02:10:24 <jle`> Lears: naming a combinator has a cost: the cost of remembering what the name is, or looking it up
02:10:44 <jle`> Lears: if the cost of remembering the name outweights the savings you get from using it, then it's better to just not define it
02:11:03 <jle`> Zvpun: for Applicatives like IO, `x *> y` is "do x, then do y"
02:11:13 <jle`> Zvpun: and `x <* y` is, also, "do x, then do y"
02:11:58 <jle`> Zvpun: flip (*>) x y = y <* x, so flip (*>) x y will "do y, then do x"
02:12:22 <Zvpun> yes, I think I understand the sequencing of events now.
02:12:41 <jle`> Zvpun: your observation earlier reflects the fact that some Applicatives are commutative in their effects sequencing
02:12:51 <jle`> which is something that is definitely interesting to note
02:13:17 <jle`> common commutative applicatives include Maybe, Identity, Writer over a commutative monoid ...
02:13:53 <jle`> ah, and `Reader r`
02:14:13 <Zvpun> Next question: flip (*>) has the same type signature as (<*), so what are the laws for (<*) and (*>). Somewhere earlier it was said that they are defined in terms of (<*>), this could be the answer.
02:14:15 <jle`> common non-commutative applicatives include `Either e` (in general), [], IO, State s, Writer over a non-commutative monoid, etc.
02:14:29 <jle`> Zvpun: yeah, i stated the "laws" earlier
02:14:58 <merijn> Zvpun: jle` already gave an implementation that defines those laws earlier
03:29:11 <lilili> hi
03:30:16 <ca1ek> so i started learning haskell and did the simple example of putting some text on screen then asking for input back
03:30:48 <ca1ek> but of course there's lazy evaluation, so the putStr happens as late as possible, so input is asked for before response
03:31:10 <ca1ek> how do I enforce execution order
03:31:24 <ca1ek> or force it to evaluate eagerly (but i probably don't want that)
03:35:09 <dminuoso> :t (<*)
03:35:10 <lambdabot> Applicative f => f a -> f b -> f a
03:35:25 <dminuoso> :t (*>)
03:35:26 <lambdabot> Applicative f => f a -> f b -> f b
03:35:41 <g-erson> :t (<*>)
03:35:43 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:35:45 <Boomerang> ca1ek: That might be a buffering issue, the output is line buffered by default. Have you tried with putStrLn?
03:36:17 <dminuoso> :t const
03:36:18 <lambdabot> a -> b -> a
03:36:20 <dminuoso> :t flip const
03:36:21 <lambdabot> b -> c -> c
03:36:51 <Boomerang> If you want control over the buffering you can use hSetBuffering or hFlush when you want to explicitely flush: https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#v:hSetBuffering
03:37:28 <Boomerang> But maybe it is just a laziness issue, can we see some code? :)
03:37:39 <lyxia> I'm betting on buffering.
03:37:58 <dminuoso> Don't be eager now.
03:38:01 <Ring0`> Can I somehow run function recursevily that runs until the next result is the same as the previous one and then return the accumulator?
03:38:14 <ca1ek> Boomerang, this works but I really don't want the newline
03:38:55 <lyxia> call "hFlush stdout" after "putStr"
03:38:56 <Boomerang> ca1ek: In that case change the buffering: hSetBuffering stdout NoBuffering
03:39:01 <dminuoso> Ring0`: What have you tried?
03:39:10 <Boomerang> Or hFlush :)
03:41:21 <ca1ek> Boomerang, doesn't compile for me, I guess I need to import something
03:41:27 <Boomerang> Maybe documentation for `putStr` should say something about buffering
03:41:40 <Boomerang> Yes ca1ek you need to import System.IO
04:07:09 <ideas_guy> does bytestring splitting/etc use structure sharing?
04:07:25 <ideas_guy> like just setting a pointer + length on an existing string region
04:07:53 <merijn> ideas_guy: I think it might
04:09:03 <merijn> ideas_guy: Quick look at the implementation of splitAt shows strict BS shares
04:09:23 <drb69> hi, 'stack install hat' gives me a compilation error: https://pastebin.com/Q1SUCLZr -- can someone help me with this?
04:09:30 <ideas_guy> wow awesome
04:10:47 <merijn> ideas_guy: If you look at the implementation of BS you see it's just a wrapper around a ForeignPtr: https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/src/Data.ByteString.Internal.html#ByteString
04:11:17 <merijn> ideas_guy: And the implementation of, for example, splitAt just shares the pointer with different offsets: https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/src/Data.ByteString.html#splitAt
04:11:53 <merijn> Probably there's some "repack" function in there to break sharing of large blobs too
04:25:05 <julianleviston> drb69: looks like you need to import somethign qualified. Apparently prelude now has Semigroup’s `(<>)` in it… so you’ll either need to hide that, or import your other lib qualified.
04:27:01 <julianleviston> drb69: but I’m guessing you didn’t write the library that’s having that issue?
04:27:10 <drb69> julianleviston: yes, i understand -- but "hat" is a haskell package - it isn't my library
04:27:16 <julianleviston> yup.
04:27:29 <drb69> so i am wondering why this occurs to me
04:27:37 <julianleviston> so maybe it’s assuming you’re using an earlier version of prelude?
04:27:48 <julianleviston> … one that doesn’t have (<>) or somethign? (guessing)
04:28:04 <drb69> hm. it is a fresh stack installation
04:28:26 <drb69> i don't know how the version selection of stack works
04:28:34 <julianleviston> mm
04:28:36 <lyxia> Semigroup.<> was added on base 4.11
04:28:47 <lyxia> hat says "base >= 4.9"
04:29:09 <julianleviston> maybe lock it to 4.9 then? (thx btw lyxia)
04:29:23 <merijn> You can't without switching LTS
04:29:28 <merijn> base is hard-tied to GHC
04:29:47 <drb69> base 4.11 should satisfy "base >= 4.9" - shouldn't it?
04:29:47 <julianleviston> oh weird. I thought you could switch it within the stack config
04:29:59 <lyxia> drb69: so the developers of hat were using 4.9 and didn't bother putting an upper bound
04:30:05 <julianleviston> yeah but the problem (probably) is 4.9 didn’t have <> in it, but 4.11 does.
04:30:12 <merijn> drb69: Basically, hat doesn't support/compile with the GHC used by your stack LTS, but due to hat screwing up the upper bound it claims to build with it
04:30:55 <drb69> well, by the way i have 'allow-newer: true' in my config.yaml
04:31:24 <merijn> drb69: That only works if the newer versions of dependency happen to actually work :)
04:32:50 <merijn> drb69: It should be fairly trivial to fix this issue in hat, so you could just quickly fix it and submit a PR. Stack supports building against local copies of packages, so you could use your fixed version to develop against
04:35:18 <drb69> merijn: thanks, i understand and i guess i know how to do it. But can you tell me the "official" way how to build hat?
04:35:43 <merijn> drb69: The official way would be: Pick an older GHC that the current code is compatible with
04:36:01 <drb69> and then how to build with ghc?
04:36:10 <drb69> without package system?
04:36:28 <Ariakenom> would removing allow-newer work?
04:36:37 <merijn> drb69: You can use stack or cabal-install to build, you just need to use a different GHC version
04:37:04 <merijn> Semigroup was changed in base-4.11 (aka GHC 8.4), so you need to use GHC 8.2 or 8.0 (which had base-4.9)
04:37:08 <drb69> can't i install a older version somehow using stack or cabal?
04:37:21 <merijn> With cabal-install you can just pick whatever GHC you like
04:37:31 <merijn> With stack the GHC version is tied to the LTS you're using
04:37:38 <merijn> So you will need to use an older LTS
04:38:48 <mouse07410> merijn: what about "allow-newer: true" and "system-ghc: true"?
04:38:59 <merijn> I don't use stack, so I can't say
04:39:19 <lyxia> allow-newer won't change your GHC version, which is the main problem here
04:39:39 <lyxia> it will also likely break the package in other ways by allowing breaking changes in dependencies
04:39:41 <merijn> mouse07410: allow-newer just says "feel free to ignore upperbounds"
04:39:44 <drb69> I am using ghc-8.6.3 -- it came with stack
04:39:57 <merijn> mouse07410: Which is...unwise, because upper bounds often exist for a reason :)
04:40:02 <drb69> which version should i try?
04:40:11 <lyxia> 8.0
04:40:22 <lyxia> resolver: lts-9.21
04:40:25 <mouse07410> I also prefer cabal, but Intellij-Haskell plugin that insists on stack.
04:40:38 <dmwit> Wow, did stack even exist when hat was last updated?
04:41:10 <lyxia> I think it did
04:41:17 <mouse07410> merijn: in my very limited experience, I observed that upper bounds are misused/abused most of the time.
04:41:52 <merijn> mouse07410: People put in upperbounds because relaxing them if they're too strict is easy, but fixing built plans if they're too loose is hard
04:42:38 <merijn> mouse07410: I always place PVP compliant upperbounds when creating packages, I can always relax them later
04:43:09 <merijn> mouse07410: If hat developer(s) had done that, this problem would have been easier to see "incompatible base version! :O"
04:43:20 <mouse07410> I hear you. I just observed that this relaxing, while easy, rarely happens.
04:43:33 <merijn> mouse07410: It depends (TM)
04:43:44 <mouse07410> :-)
04:44:07 <merijn> mouse07410: Core packages get updates quickly. I don't personally scan my dependencies for when to relax bounds. I relax them when 1) I find out I need to while coding or 2) someone sends me an email/PR to relax them
04:44:09 <mouse07410> What is PVP?
04:44:18 <merijn> mouse07410: https://pvp.haskell.org/
04:44:30 <merijn> The Package Versioning Policy
04:48:06 <dmwit> The thing about upper bounds is that it's easy to notice when too-strict upper bounds stop you from building something you wanted to build, but hard to notice when correct upper bounds prevented you from even attempting to build a thing in a non-working configuration.
04:48:17 <dmwit> So there's an observation bias on the two failure modes involved.
04:48:22 <mouse07410> merijn: Very useful reading, thanks!
04:48:24 <merijn> That too
04:48:46 <mouse07410> 👍
04:49:07 <merijn> mouse07410: It's not enforced, but strongly recommended to follow the PVP when releasing things on Hackage
04:49:35 <mouse07410> Oh yes, understood 100%.
04:52:33 <mouse07410> I guess I'm used to dealing with packages where breaking changes we considered the last resort, preferably/ideally never done. Here such a change seems to be an accepted norm ("just bump the A.B"). Illustrated one of the differences between academic and commercial research.
04:53:43 <hpc> i see it as, a whole lot of work was spent so you can put "just" at the start of that sentence
04:54:10 <merijn> mouse07410: It depends a lot on the package and who uploaded it
04:54:24 <mouse07410> Yeah, I guess so.
04:54:38 <merijn> mouse07410: Core things like BS, Text, etc. rarely break. base generally has a deprecation cycle around it with warnings, etc.
04:55:58 <merijn> mouse07410: I have a bunch of stuff on Hackage that I develop/maintain primarily for my usecases which I put on there because I feel they are more widely useful to others so they don't have to waste the same effort
04:57:14 <merijn> mouse07410: But I don't like the idea of permanently committing to some API if I turn out to need something else. People can either use upperbounds or pay me :p
04:58:40 <mouse07410> Yeah... But do you often find you need to introduce a breaking change? And do you update the bounds? ;-)
04:59:17 <dminuoso> mouse07410: Worst case just open up an issue and ask for it.
04:59:25 <dminuoso> Or better yet make a small MR.
04:59:26 <merijn> mouse07410: I've changed pretty dramatic API changes before :p
04:59:43 <mouse07410> 😱😆
05:00:09 <mouse07410> dminuoso: I hear you
05:00:18 <merijn> mouse07410: But they carefully follow the PVP and all my dependencies have PVP based upper-bounds that I relax on an "as necessary/discovered" basis. So either when I run into an upperbound or someone pings me to relax it
05:01:15 <merijn> So, if you have a PVP upperbound on my libraries you shouldn't hit any breakage
05:01:17 <mouse07410> I see. A different ecosystem. Will take a while to get used to.
05:01:56 <merijn> mouse07410: I like to think of it as an ecosystem that encourages making experimental (but useful!) packages reliably available faster ;)
05:02:13 <mouse07410> 😄🙄
05:02:23 <merijn> mouse07410: Designing a good API can be hard an require many iterations. If you can't release until you commit to a long term API, you can't release quickly
05:02:26 <lyxia> dminuoso: spotted the gitlab user
05:02:49 <merijn> mouse07410: Releasing quickly, getting some early adopters with API feedback can lead to a more refined/nicer API longterm
05:03:18 <mouse07410> merijn: yeah, there's that...
05:05:27 <hc> HI all, I'm looking for good examples where it is possible to achieve in haskell purely with libraries/APIs what requires changes to the language's core/grammar for many other languages :)
05:05:38 <hc> STM comes to mind, any other good ones?
05:06:24 <hpc> any Monad instance
05:06:25 <dmwit> do's programmable semicolon
05:06:38 <hc> heh
05:06:47 <hc> any concrete, "impressive" or easy to understand examples, though?
05:06:52 <mouse07410> merijn: Although I'm willing to bet that people prefer to depend on stable (mature?) packages, rather than experimenting with somebody else's early experiments. Also, could be a difference between an academic research, and a project that has to work by a certain date.
05:06:52 <dmwit> The other one is that Haskell makes creating new control structures easy and fun.
05:06:54 <hpc> Cont maybe
05:07:01 <hc> "understand" in the sense of "wow, that' scool", rather than "oh, I see how it works"
05:07:18 <hpc> if you want to give yourself a headache, there's a Tardis monad
05:07:24 <hc> lol
05:07:32 <dmwit> e.g. Maybe's <|> being a library function and still short-circuiting properly is pretty cool to most folks familiar only with eager languages.
05:07:35 <hpc> it combines State and a rarely used reverse state into one type
05:08:06 <hpc> parser combinators are another good one
05:08:08 <dmwit> People don't expect to be able to make their own short-circuiting forms. =)
05:08:13 <hc> hpc: good idea, thanks! :)
05:08:26 <dmwit> I hesitate on parser combinators. Many other languages have picked up the cause on that front.
05:09:00 <hpc> well, parser combinators with custom operators then :P
05:09:21 <hc> yeah, I don't care if a certain such feature is limited to haskell, so it's ok
05:09:21 <hc> :)
05:09:25 <hpc> you can get your source code very close to a BNF grammar
05:09:39 <dmwit> Seems like the main feature that's being impressive there is the "custom operators" bit, not the "parser combinators" bit.
05:09:55 <hpc> heh, i suppose
05:10:18 <hpc> if you count language extensions, everything around GADTs and DataKinds
05:10:23 * dmwit . o O ( What other language implemented its most popular record system as a library? )
05:10:43 <hpc> is technically "in-language", but in other languages would be enormously complicated preprocessors and specially formatted comment blocks
05:11:02 <merijn> hc: https://gist.github.com/merijn/dc00bc7cebd6df012c5e https://gist.github.com/merijn/39dc86e345e87276c523 https://gist.github.com/merijn/6130082 :)
05:16:13 <lyxia> hc: you can track resources in types with indexed monads, to get similar guarantees to Rust's borrow checker. That would probably be a pain to use compared to Rust though.
05:17:11 <lyxia> with a similar approach you can encode various protocols in an API
05:18:06 <hc> Thanks! I think the easiest to understand examples are STM and parser combinators, I'll stick to those for now
05:18:21 <dminuoso> hc: The ability to refer to IO as values I think is really valuable.
05:18:42 <dminuoso> Literally.
05:18:53 <hpc> ooh, that's a good one
05:19:26 <hpc> the async library makes pretty good use of first-class IO
05:19:55 <Ariakenom> hc: polymorphic literals might fit what you're looking for
05:19:56 <Ariakenom> :t 1
05:19:57 <lambdabot> Num p => p
05:20:11 <dminuoso> I think `STM` is a poor example because that's not something that comes out of Haskell naturally.
05:20:18 <dminuoso> It stems from the fact that it was built into the RTS by GHC.
05:20:26 <hpc> i once wrote a library that statefully built up an IO action for the purpose of short-circuiting if the result was already saved on disk
05:20:28 <Ariakenom> smooth library level number types
05:20:42 <hc> dminuoso: hmm, but "only" for performance reasons, right?
05:20:54 <merijn> dminuoso: I disagree, without Haskell, purity and the monad interface STM wouldn't work
05:21:08 <hpc> only a few STM primitives are built inn
05:21:15 <hpc> the rest of the library builds on those
05:21:23 <dminuoso> hpc: Yeah but you *do* need some STM primitives.
05:21:32 <dminuoso> It's not something you can simply bootstrap from Haskell 2010
05:21:55 <dminuoso> Well you could, but I guess then it becomes a usability/performance issue.
05:21:56 <hpc> sure, in the same way you need Int# and certain syscalls built in
05:21:59 <hc> Couldn't you implement the whole of STM (with very poor performance) just with MVars?
05:22:21 <hpc> it would have blocking semantics that way instead of transactional semantics
05:22:32 <dminuoso> merijn: I've seen numberous other languages implement STM without purity and monad interface.
05:22:38 <Ariakenom> hc: yes "only". not sure but, not allocating so you won't get a context switch is maybe practically necessary
05:22:44 <merijn> dminuoso: And they all suck to the point where no one uses them
05:25:28 <Ariakenom> (^ in some critical parts)
05:25:59 <Ariakenom> I think I fryguybob said so when I had similar questions
05:26:50 <merijn> And no, you can't built it with MVars
05:27:12 <merijn> Unless you mean "we can put a single giant MVar lock around all calls to atomically"
05:27:22 <drb69> when installing stack is there a way to tell which ghc version should be used? and to tell which gcc / clang compiler should be used?
05:27:29 <merijn> In which case, sure, we can do that, but then we basically have reinvented python's GIL
05:27:45 <merijn> drb69: Stack picks a GHC version per project, based on the LTS used
05:27:57 <drb69> what is LTS?
05:28:07 <Ariakenom> merijn: that wouldnt have the same semantics if the transaction loops 
05:29:28 <Ariakenom> merijn: you can have a first phase that reads but doesn't actually write and then a second phase that takes the lock and does the writes. that would have the correct semantics, I'd think
05:29:55 <g-erson> drb69: It's a big list of haskell library versions known to work together with a particular version of GHC
05:30:40 <Ariakenom> I never got around to <|> when I tried that, but it seemed doable. wasn't sure what guarantees it gave
05:31:02 <Ariakenom> It had Monad though
05:31:05 <julianleviston> drb69: stands for “Long-term Support”
05:35:55 <hc> merijn: I don't care about the implementation details, *so long as* it's possible to implement a (however terrible performance wise) pure haskell version of stm
05:36:02 <hc> Just for illustration purposes :-)
05:36:10 <lyxia> drb69: stack can install multiple versions of GHC for you, it does so automatically when you try to build a package with a new resolver.
05:36:48 <exarkun1> is there a Haskell library for formatting like Python's key/value-interpolation features - `"%(foo)s" % {"foo": "bar"}` or `"{foo}".format(foo="bar")`?  Or anything better than simple positional-based formatting?
05:37:26 <lyxia> drb69: GHC 8.0 is implied when you say "resolver: lts-9.21" in stack.yaml
05:37:57 <lyxia> exarkun1: how's PyF
05:38:54 <lyxia> or fmt
05:39:59 * ski . o O ( `let foo = "bar" in concat ["foo is ",foo]' )
05:46:02 <exarkun1> PyF looks okay, I guess... quasiquoting seems like the wrong approach but still better than printf, maybe
05:46:44 <lyxia> printf is bad indeed
05:47:50 <lyxia> ski's suggestion is quite nice
05:48:35 <exarkun1> I don't think I quite understand the premise of fmt.
05:48:41 <exarkun1> ski's suggestion is fine for very short strings
05:49:24 <exarkun1> for longer strings (think a dozen lines with 20 pieces of data being interpolated) I think it gets messy and unmaintainable
05:51:06 <Ariakenom> exarkun1: not what you asked for but I've happily used the library formatting
05:56:45 <ski> not sure i see why using `let' (or `where') breaking it (and possibly also the `concat' call) over multiple lines, would be that much worse than what you'd have to do with those string interpolation things in Python ..
05:58:36 <exarkun1> ski: because it mixes presentation logic with implementation details unnecessarily
05:59:56 <ski> in which way does it do that, that the Python snippets you gave doesn't ?
06:00:23 <exarkun1> the template string in the Python snippets can be maintained independently of the formatting operation
06:00:55 <exarkun1> not if the literal strings are used as in my examples (for brevity).  imagine `s.format(foo="bar")` instead.
06:01:10 <ski> oh, ok
06:01:37 <exarkun1> sorry if the question was misleading
06:02:23 <ski> hm, so i suppose if we had named parameters, we could do this
06:02:39 <exarkun1> the specific motivation for the question is code like https://github.com/erewok/servant-py/blob/master/src/Servant/PY/Requests.hs#L34-L44 which seems to me to be a total mess
06:03:57 <Ariakenom> "formatting" will let you do "format template arguments"
06:03:58 <[exa]> exarkun1: there is no python prettyprinter implemented for haskell?
06:04:18 <exarkun1> [exa]: I dunno!  Not that I found.
06:04:27 <exarkun1> Or, rather, yes there is one, sorry
06:04:55 <[exa]> exarkun1: the code you linked is basically prettyprinting-by-hand
06:04:58 <asheshambasta> How does one turn off -Wpartial-type-signatures? The flag doesn't seem to have been specified in my stack/package.yaml file.
06:05:00 <exarkun1> It is broken on recent versions of base and uses the Python AST which has almost nothing "A" about it
06:05:08 <[exa]> oh so
06:05:26 <exarkun1> That was the first thing I reached for, indeed, and it was just too painful
06:05:31 <lyxia> asheshambasta: -Wno-partial-type-signatures  it might be on by default
06:05:49 <asheshambasta> lyxia: ah, cool, thanks!
06:05:52 <[exa]> (shower thought: does python have anything abstract in the syntax?)
06:05:58 <exarkun1> http://hackage.haskell.org/package/language-python fwiw
06:06:04 <lyxia> asheshambasta: in fact it is https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wpartial-type-signatures
06:06:40 <exarkun1> Also it seems to take a month to compile, not sure what the deal is with that
06:07:37 <asheshambasta> lyxia: given that it is on by default, does it mean that using it is dangerous? 
06:08:09 <asheshambasta> I cannot see why, though, if the inferred types won't match up to what I'd expect/use them as, I'll get a compile error anyway
06:10:54 <lyxia> exarkun1: maybe you could make a string DSL that looks more like python, that just concatenates strings under the hood.
06:12:04 <lyxia> asheshambasta: it can cause your types to silently change and then you get an error much later
06:13:08 <mreh> how long has Applicative m been a requirement for Monad m?
06:13:25 <[exa]> mreh: quite a long time now
06:13:40 <lyxia> asheshambasta: it is still somewhat controversial that it's on by default, I've seen the complaint numerous times.
06:13:42 <[exa]> mreh: see here https://wiki.haskell.org/Functor-Applicative-Monad_Proposal
06:13:46 <julianleviston> [exa]: has it been more than a year?!
06:13:54 <julianleviston> wow.
06:14:06 <mreh> I feel old
06:14:16 <mreh> Monad in Prelude?!
06:14:18 <[exa]> "I remember it like it was tomorrow"
06:14:40 <mreh> kids these days
06:14:44 <lyxia> mreh: you can also check out the changelog https://hackage.haskell.org/package/base-4.12.0.0/changelog grep "superclass of Monad"
06:15:06 <julianleviston> mreh: haskell has IO now ;-)
06:15:25 <mniip> oh did you hear about typeclasses
06:15:26 <mreh> lyxia: hah, yes, good idea, I was manually reviewing the versions
06:15:28 <mniip> they're slick
06:15:36 <mreh> julianleviston: stream based IO
06:16:01 <lyxia> changelogs changed my life
06:17:18 <asheshambasta> lyxia: yeah, I see. Just that it gets quite a handful to type things out when dealing with type level libraries were the types are really like huge expressions in their own right. 
06:17:51 <asheshambasta> lyxia: https://github.com/morphismtech/squeal/issues/45#issuecomment-410414295
06:18:44 <asheshambasta> there can at times be quite some ceremony to just know what to "fill"; and in that case, PartialTypeSignatures is quite handy. 
06:19:08 <lyxia> Yeah, maybe the warning could be a bit more selective
06:19:21 <mreh> cycle.js has revived stream based I/O
06:19:27 <mreh> I quite like it
06:19:54 <lyxia> asheshambasta: you're right, in local bindings it's pretty handy. I was thinking about using it in toplevel signatures.
06:20:38 <mreh> it does have FRP though, which makes it much easier
06:22:58 <julianleviston> for some definition of FRP
06:23:03 <julianleviston> (no doubt)
06:23:42 <mreh> well, streams
06:24:10 <julianleviston> not behaviours?
06:24:34 <mreh> julianleviston: not really
06:24:54 <julianleviston> not really FRP then
06:25:21 <mreh> no
06:44:28 * hackage hinterface 0.8.2 - Haskell / Erlang interoperability library  http://hackage.haskell.org/package/hinterface-0.8.2 (SvenHeyll)
07:10:22 <infandum> When you upload your open source library, do you have the remote (like github) contain the entire commit history or just from the first upload?
07:12:57 * hackage modularity 0.2.0.2 - Find the modularity of a network.  http://hackage.haskell.org/package/modularity-0.2.0.2 (GregorySchwartz)
07:14:25 <exarkun1> infandum: You do whatever you want.  What's your goal?
07:15:16 <infandum> I'm not sure if I should show "there was a bug here, fixed it" before the initial release of code.
07:15:32 <infandum> After the initial release, fine, but I'm not sure about very early on.
07:15:43 <infandum> The question is how much people care
07:16:42 <exarkun1> History is information.  Destroying history is extra effort.  Why would you bother to go to extra effort to destroy information?
07:16:45 <merijn> infandum: I just have everything online
07:16:59 <merijn> infandum: Although I do tend to clean things up before pushing to github
07:17:03 <exarkun1> Personally, when I'm developing open source software, I almost always have pushed to a public repo a long time before I do the first release
07:17:16 <infandum> makes sense
07:17:16 <merijn> infandum: But I push to github even during early development as an extra free mirror/backup
07:17:31 <exarkun1> If you develop in private and do periodic code dumps, it might technically still be open source but you're not really encouraging the kind of collaboration that open source is useful for.
07:17:34 <infandum> yeah, I guess I'm just self-conscious about bugs
07:17:37 <infandum> squashed bugs
07:17:40 <dmwit> My 2c: Does Not Matter.
07:17:45 <exarkun1> All software has bugs, get used to it. :)
07:17:54 <dmwit> Nobody will ever, ever check out the code from before the first release.
07:18:02 <phadej> i sqush the initial "asdass commits"
07:18:05 <exarkun1> If you hide the evidence of past bugs, the future is less likely to learn from your experience.
07:18:14 <infandum> That's a good point, open source software is about collaboration, if it's finished then what's the point?
07:18:31 <exarkun1> Also, no software is ever finished.  Get used to it. ;)
07:18:33 <merijn> infandum: Also, if you ever work in system administration and see what kinda horribly broken shit gets deployed to production, you'll feel less bad about your own stuff :p
07:18:59 <phadej> but if I paid attention to make good commits, then why would I squash them
07:19:02 <infandum> merijn: haha I know, but that stuff isn't necessarily public
07:19:26 <merijn> infandum: I've seen systems deployed into production handling money transactions (gift cards) that would just, like, hang multiple times per day in ever single store >.>
07:19:39 <merijn> infandum: I'm just saying the baseline of expectations of most programmers is *low*
07:19:53 <exarkun1> which isn't to say you shouldn't do better
07:20:00 <exarkun1> but hiding your mistakes is not a necessary part of doing better
07:20:27 <exarkun1> mistakes are inevitable.  the goal isn't to never make a mistake, the goal is to respond to mistakes as productively as possible.
07:22:28 <tdammers> I think the most important reason for squashing is to lower the threshold for committing
07:22:48 <tdammers> write some code, tinker, commit, repeat a dozen times, squash, push
07:23:09 <tdammers> rather than, write some code, tinker, repeat a dozen times, push
07:23:58 * hackage vabal-lib 2.0.0 - Core algorithms and datatypes used by vabal  http://hackage.haskell.org/package/vabal-lib-2.0.0 (Franciman)
07:23:59 <tdammers> when you're in the flow, you just keep committing, with cryptic commit messages and all sorts of nonsense going on, but at some point the thing converges towards something more solid, so you squash it to clean up the mess
07:24:04 <exarkun1> I think that workflow ends up being a pretty personal thing and it's not clear there's one approach that's best
07:24:32 <exarkun1> but once you start squashing I do think it becomes extremely appealing to just rewrite all of your history to make yourself look like a perfect genius
07:24:51 <maerwald> if you don't use git rebase -i regularly, you haven't discovered git yet, imo :P
07:25:13 <exarkun1> maybe it has been discovered and found lacking :P
07:26:07 <maerwald> That doesn't compute
07:26:12 <exarkun1> I find that being able to write a coherent commit message means that I'm actually working productively and not wandering aimlessly with my high-level goals forgotten about
07:26:30 <exarkun1> but as I said, I don't think it's clear there's a single superior workflow
07:26:56 <tdammers> my workflow has fairly tight feedback cycles
07:27:40 <tdammers> but actually, I don't squash a lot; what happens more often is that I follow several trains of thought in parallel, and then I use commit -p to commit the changes separately
07:28:39 <exarkun1> I do that a lot too.  except I use magit which has a UI 100x better than commit -p.
07:29:58 * hackage differential 0.1.1.0 - Finds out whether an entity comes from different distributions (statuses).  http://hackage.haskell.org/package/differential-0.1.1.0 (GregorySchwartz)
07:30:40 <infandum> I have never squashed yet
07:30:47 <infandum> Don't know if that's bad or not haha
07:33:58 * hackage spectral-clustering 0.2.1.1 - Library for spectral clustering.  http://hackage.haskell.org/package/spectral-clustering-0.2.1.1 (GregorySchwartz)
07:40:37 <tdammers> squashing is nice when your coding is somewhat experimental
07:41:05 <tdammers> you do one thing that you think might work, then you do another thing, and then another, and then it turns out that the first thing has problems, so you revise that
07:41:20 <tdammers> so now you have 4 commits, but you actually did 3 things
07:41:33 <tdammers> rebase -i is great for situations like these
07:41:58 <infandum> ah
07:42:37 <Boomerang> tdammers: But do you squash with rebase -i or just fixup?
07:42:45 <maerwald> rebase -i can do everything: reorder, squash, delete, split, amend, ...
07:43:28 <fuzzy-id> help please! i have
07:43:30 <fuzzy-id> `withDevDb :: MonadIO m => ((forall a. MidasQuery a -> IO a) -> IO b) -> m b`
07:43:40 <fuzzy-id> and:
07:43:46 <fuzzy-id> `onMidasDb :: (forall a. MidasQuery a -> IO a) -> Test ()`
07:44:07 <fuzzy-id> i try to run this via: `main = withDevDb (run . onMidasDb)`
07:44:29 <fuzzy-id> (`run` comes from easytest)
07:44:35 <exarkun1> tdammers: Scientists are basically incentivized to throw out data from experiments that don't confirm their hypothesis (because such results are frequently not publishable).
07:44:53 <tdammers> exarkun1: I'm a programmer, not a scientist
07:44:55 <Boomerang> One annoying thing with rebase is that it updates the commit time to when you rebase and stupid GitHub sorts commit by time instead of git order. When all the times are the same I don't know what it uses to sort, hash, commit message? Either way the result is not good
07:45:00 <fuzzy-id> and get "Couldn't match type ‘MidasQuery a0 -> IO a0’ with ‘forall a. MidasQuery a -> IO a’"
07:45:35 <tdammers> exarkun1: and as far as documenting dead ends in development go, the git commit history is not a very good place for that. if you have gained progressive insight, put it in proper documentation
07:45:47 <fuzzy-id> i'm trying to wrap my head around rank-n-types but i'm totally stuck on figuring this stuff out
07:45:48 <ski> fuzzy-id : try eta-expanding
07:46:07 <exarkun1> tdammers: I disagree.  I think history is the best place we have for such things.
07:46:14 <maerwald> git history is rarely useful for browsing by human eyes
07:46:21 <exarkun1> tdammers: History is discoverable!  History is, _by definition_, out of date.
07:46:28 * hackage shake 0.17.4 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.17.4 (NeilMitchell)
07:46:29 <ski>   main = withDevDb (\runMidasQuery -> run (onMidasDb runMidasQuery))
07:46:36 <tdammers> History is discoverable to those who actively look
07:46:38 <exarkun1> tdammers: Documentation is frequently not discoverable and when it is out of date, people are angry.
07:46:49 <tdammers> but people don't pull up the git history until something goes wrong and they can't explain why
07:46:55 <exarkun1> Guess what, no piece of documentation ever jumped up on my desk and explained something useful to me all on its own.
07:47:11 <tdammers> no? well written documentation does that for me all the time
07:47:22 <fuzzy-id> ski: yeah, that compiles
07:47:29 <exarkun1> If you don't regularly look at the history of code you're maintaining to get a better understanding of how it got to be how it is, you're missing out on a very powerful tool.
07:47:43 <exarkun1> tdammers: No it doesn't.  You have to go find it.  You have to _actively look_.
07:48:39 <ski> fuzzy-id : the problem is that `a' in `(.) :: forall a b c. (b -> c) -> (a -> b) -> (a -> c)' can't be instantiated to the universal type `forall a. MidasQuery a -> IO a' (that would require `ImpredicativeTypes', which is broken)
07:49:21 <tdammers> exarkun1: I look up haddock all the time. I do read the documentation. That's a default thing, really. And the documentation often contains unexpected things that I didn't actively look for, explaining things like subtle design gotchas and such
07:50:18 <exarkun1> Sure.  And that's great (although for most projects I find what's in haddock to be sorely lacking).  It's just not everything.
07:50:27 <tdammers> also, documentation is much easier in terms of "I wonder why this has this particular signature - oh, there's a paragraph explaining that" vs. "I wonder why this has this particular signature - let's read the relevant commit history to reverse-engineer the process that led to it"
07:50:45 <exarkun1> Yes.  Great.  Keep all that.
07:50:49 <tdammers> yeah, I mean I'm not saying commit history is completely irrelevant - it most certainly is not
07:51:03 <fuzzy-id> hmm, so i'd have to write my own version of `(.)' to make this work if i want to stay point-free?
07:51:07 <exarkun1> Okay, and I'm not saying history is the only thing you need, either. :)
07:51:12 <tdammers> just saying that history is not necessarily the best place for documenting progressive insight
07:51:42 <tdammers> progressive insight just happens, and the commit history reflects that quite literally, but there is no narrative to it, you have to write that yourself
07:52:39 <tdammers> it only explains what you tried, not why 
07:52:45 <exarkun1> I guess what I think history is really useful for is that "progressive insights" being well-documented in HEAD is the best possible case scenario and the real world often falls short of that
07:52:56 <exarkun1> Commit messages explain why. :)
07:52:58 * hackage vabal 2.0.0 - the cabal companion  http://hackage.haskell.org/package/vabal-2.0.0 (Franciman)
07:53:13 <exarkun1> (well ... best possible case ...)
07:53:27 <tdammers> right
07:53:33 <exarkun1> Maybe more generally, programmers are bad at their jobs and programs are terrible things and history is a good tool to have at your disposal, along with all the others.
07:53:39 <tdammers> I sometimes forget that most people don't like explaining things as much as I do
07:53:47 <exarkun1> so spending extra effort to ruin that tool ... meh.
07:54:20 <tdammers> the way I see it, rebase -i is a tool that you can use to massage a chaotic series of commit messages into a more structured narrative
07:54:37 <tdammers> for the same reason, I'm not necessarily a huge fan of flat histories
07:54:48 <drb69> hi, is it possible to use stack setup with varying --resolver=lts-XXX arguments sequentially? 
07:54:49 <tdammers> keep those merge commits, they provide valuable information
07:55:14 <drb69> without loosing already installed programs?
07:55:17 <exarkun1> yea I didn't even want to get into that, seems everyone has strong feelings about merge commits vs not
07:55:18 <maerwald> tdammers: merge commits, unfortunately, are a hidden place for "code gone missing"
07:56:00 <tdammers> I think the concept is great, and the right thing, but it's unfortunate that merging often involves manual efforts, and thus manually introduced errors
07:56:29 <tdammers> the history says "this code went into this line of development", but it may not have due to manual conflict resolution
08:00:21 <exarkun1> I might believe that making the conflict resolution happen in the same commit as the conflict was introduced is a good idea and so rebasing so you can do that before you merge is a good idea
08:00:39 <exarkun1> not sure
08:02:05 <lyxia> drb69: that's already what stack does
08:03:38 <dmwit> Franciman: cute =)
08:04:14 <Franciman> hi dmwit, are you referring to vabal?
08:04:29 <drb69> ok here is what i did: stack setup --resolver=9.20; stack install hat; stack install cabal-install
08:04:55 <merijn> drb69: Why are you installing cabal-install if you're using stack?
08:05:23 <lyxia> drb69: ok I see, stack setup won't store that option anywhere.
08:05:30 <drb69> now i would like to do stack install pandoc but with resolver=lts-13.X or so
08:05:45 <tdammers> exarkun1: conflicts are rarely introduced in a single commit; they are generally the results of two commits independently touching the same code
08:05:46 <dmwit> Franciman: Yeah.
08:05:56 <drb69> the problem is that pandoc with lts-9.20 is version 1.19
08:06:01 <dmwit> Franciman: The whole thing seems hard. How do you know what constraints there are on base before you do constraint solving?
08:06:02 <Franciman> thanks hope it may be helpful.
08:06:24 <Franciman> dmwit, I documented it a bit here: https://github.com/vabal/vabal/wiki/How-the-vabal-solver-works
08:06:32 <drb69> merijn: i have written a pandoc-filter and setup only cabal for it
08:06:46 <Franciman> there is some backtracking involved. But fortunately pratically we don't use a lot of `if impl` conditions
08:07:14 <tdammers> base: `log "Hello"`; ours: `log LogLevelDebug "Hello"`; theirs: `log logger "Hello"`. This requires manual conflict resolution, even though neither commit by itself is objectionable, and it's not clear at all which one should "resolve" the conflict
08:07:47 <Franciman> also I use Cabal's finalizePD to get a PackageDescription: http://hackage.haskell.org/package/Cabal-2.4.1.0/docs/Distribution-PackageDescription-Configuration.html#v:finalizePD
08:08:25 <drb69> lyxia: so can i do stack setup --resolver=lts-13.2; stack install pandoc?
08:08:40 <dmwit> Franciman: Pretty cool. =)
08:08:59 <lyxia> drb69: stack install --resolver=lts-13.2 pandoc
08:09:34 <drb69> lyxia: ah great. and how can i uninstall the previous version?
08:10:29 <lyxia> I don't think you can, but the executable gets overwritten anyway
08:10:33 <Franciman> dmwit, if you want to try it and have any issues, or even better any ideas, please let me know!
08:10:44 <dmwit> Franciman: Will this still work in the v2-* style where there may be a ton of packages only available locally (and not, say, in Hackage or in cabal's index)?
08:10:44 <drb69> lyxia: and will hat work with on modules based on a different LTS?
08:11:02 <Franciman> dmwit, what do you mean?
08:11:11 <Franciman> you mean in presence of cabal.project ?
08:11:30 <dmwit> Yes, but more specifically in the presence of multiple subdirectories which are the only place you can find the cabal files for dependencies.
08:11:31 <lyxia> drb69: no, stack creates a sandbox for every resolver
08:11:47 <Franciman> ah ok, right now it only supports one cabal file. But it's my next goal
08:12:16 <dmwit> "Only supports one cabal file" means for dependencies it consults Hackage to find out the dependencies' constraints, or what?
08:12:43 <Franciman> ah wait, there is a misunderstanding, i guess. It doesn't do a full resolution of dependencies
08:12:49 <merijn> dmwit: It presumably means "uses the cabal library to parse and read a single cabal file and inspect that, not accounting for dependencies at all"
08:12:51 <Franciman> just reads base constraints
08:12:56 <Franciman> yeah :P
08:12:58 <dmwit> Oh.
08:13:02 <merijn> dmwit: afaict it just does "load cabal file, inspect base constraints, update GHC"
08:13:04 <Franciman> pretty disappointing
08:13:26 <drb69> lyxia: ok, here is what i would like to do: i would like to debug my pandoc-filter using hat. hat is only installable using lts-9.21. i need a new pandoc version, so this implies lts-13.2, right? how can i do that?
08:13:40 <Franciman> the best I could, so far, though. I think I'd need to hack on cabal's solver to get something more consistent
08:13:42 <dmwit> Okay. That seems like a pretty severe restriction, as deps will often narrow things down quite a lot more.
08:14:43 <merijn> Franciman: Or you can support v2- the ghetto way ;)
08:14:44 <merijn> Franciman: Use cabal-plan to query the entire build plan :p
08:15:26 <Franciman> merijn, lol. I am scared of times
08:15:26 <Franciman> but I tried that for a while
08:15:26 <Franciman> I shall try it 
08:15:26 <dmwit> merijn: You can do that, but to get a build plan you must choose a GHC version.
08:15:30 <dmwit> merijn: Which is why I was saying it seemed hard to do this right.
08:15:48 <merijn> dmwit: Sure
08:15:55 <Franciman> exactly. And right now to do that, vabal reads all if impl conditions
08:15:57 <lyxia> drb69: wait, hat is a code transformer, it only looks at the source, so it probably doesn't care whether you use the same dependencies as what you built hat with.
08:15:58 <dmwit> merijn: (...and the version probably has to be installed, too, to give cabal access to its ghc-pkg!)
08:16:03 <Franciman> and produces all possible assignments (exponential)
08:16:10 <merijn> But then again, I assumed this project wasn't for me anyway, since honestly it doesn't seem worth the bother :)
08:16:12 <Franciman> dmwit, that can be hacked around
08:17:05 <Franciman> yeah it's really simple. I did it because 99% of the time I don't need stack huge bloated stuff
08:17:13 <drb69> lyxia: yes, correct, but the question to me is whether the code that hat generates / transforms will be compliant to the target haskell compiler 
08:17:17 <Franciman> but just need to change ghc, and I am too lazy to read which one is needed
08:17:25 <dmwit> Franciman: When you step from single-cabal-file to full dependency tree, it might be worth looking at using an actual SAT solver. There are some native Haskell ones that are fairly pleasant and not that much slower than the industrial strength ones.
08:17:37 <Franciman> will do, thanks
08:17:39 <dmwit> It will be much better than looking at all possible assignments, anyway.
08:18:26 <dmwit> I think ersatz e.g.
08:18:46 <Franciman> perfect, thank you
08:19:04 <Franciman> dmwit, do you have any example, where other dependencies narrow down the ghcs supported?
08:19:12 <Franciman> by a lot
08:19:48 <dmwit> Smaller packages often don't get updated as frequently, and so don't (claim to) work on the newest GHCs.
08:20:03 <lyxia> drb69: from the description, it seems hat works with a rather conservative version of Haskell so if it outputs anything it should be pretty safe
08:20:26 <dmwit> Basically wherever the top-level cabal-file maintainer isn't paying super close attention. =P
08:20:41 <lyxia> drb69: a bigger potential issue is whether you use any extension hat doesn't recognize.
08:20:50 <Franciman> I tested it on the whole hackage, I was pretty happy
08:21:00 <dmwit> I have a few specific examples in mind but they're not publically available. I could try to find some on Hackage, but I doubt I'd be quicker at it than you would be...
08:21:10 <Franciman> yeah of course
08:21:31 <dmwit> Huh! If you tested it that widely then perhaps I am just paranoid.
08:21:37 <Franciman> nono, you're right
08:21:40 <Franciman> it fails a lot of times
08:21:49 <Franciman> but not as much as I expected
08:21:54 * dmwit nods
08:22:06 <Franciman> anyways another solution I was thinking is supporting lts.yml from stackage
08:22:40 <Franciman> instead of doing the full effort of doing full constraint solving
08:22:46 <dmwit> right
08:23:12 <Franciman> it is already supported by cabal, just downloading the cabal.config is fine. Plus I read the ghc version required and that's all
08:24:12 <Franciman> merijn, do you usually use stackage snapshot or you use other methods to solve this issue? (Or don't solve it at all?)
08:24:33 <lyxia> drb69: and now that I look even closer, hat contains some instrumented modules, and the generated code probably depends on it. If so, you're back to square one.
08:26:11 <drb69> lyxia: in other words: i cannot use hat to debug my pandoc-filter?
08:27:13 <lyxia> well there was the suggestion to try to fix the code to be compatible with your more recent GHC
08:27:41 <drb69> ah ok, so no way around it
08:27:44 <lyxia> besides that the chances of success are low. What led you to want to use hat to debug your pandoc-filter 
08:28:21 <drb69> i want some tracing output to find an programming error in my code
08:28:42 <drb69> i googled and the docs told me that hat is a quite powerful debugging tool
08:28:54 <merijn> Franciman: I usually just fix the upperbound of the package or manually switch to whatever GHC version needed
08:29:02 <drb69> so i thought i can learn how to debug haskell code
08:29:36 <merijn> Franciman: I don't use stack, I just use the method of "cabal-install + whatever GHC is first in my path" :p
08:29:38 <lyxia> I mean hat is very much a research project, I'd be surprised if it worked out-of-the box after a year of nonmaintenance for a new user.
08:29:55 <Franciman> makes sense
08:30:52 <Franciman> well, thanks a lot dmwit and merijn, this discussion helped me a lot
08:30:57 <drb69> oh - what do haskell experts use to debug their code?
08:31:16 <merijn> Honestly, mostly putStrLn and trace :p
08:31:58 <drb69> merijn: ok, thanks, then i know what to do
08:32:31 <Franciman> maybe ghci can help too?
08:35:58 * hackage hapistrano 0.3.9.0 - A deployment library for Haskell applications  http://hackage.haskell.org/package/hapistrano-0.3.9.0 (juanpaucar)
08:47:27 * hackage modularity 0.2.0.3 - Find the modularity of a network.  http://hackage.haskell.org/package/modularity-0.2.0.3 (GregorySchwartz)
08:48:57 * hackage spectral-clustering 0.2.1.2 - Library for spectral clustering.  http://hackage.haskell.org/package/spectral-clustering-0.2.1.2 (GregorySchwartz)
08:56:58 <fhdhsni> How do you define (:) with foldr? this does't give me the correct order http://ix.io/1xYd 
08:58:19 <merijn> fhdhsni: You mean "how do you define (++) with foldr?"?
08:58:38 <fhdhsni> sorry yeah. I mean ++
08:58:58 * hackage hierarchical-spectral-clustering 0.2.1.0 - Hierarchical spectral clustering of a graph.  http://hackage.haskell.org/package/hierarchical-spectral-clustering-0.2.1.0 (GregorySchwartz)
08:59:07 <merijn> fhdhsni: The second argument to fold is the "zero" element
08:59:19 <merijn> > foldr f z [1..5] :: Expr
08:59:21 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 z))))
08:59:43 <merijn> fhdhsni: So, if the 2nd argument to glue should be the tail of the list, you should be passing that as 2nd argument 
08:59:56 <merijn> > foldr (:) z [1..5] :: Expr
08:59:58 <lambdabot>  error:
08:59:58 <lambdabot>      • Couldn't match expected type ‘Expr’ with actual type ‘[Integer]’
08:59:58 <lambdabot>      • In the expression: foldr (:) z [1 .. 5] :: Exprerror:
09:00:13 <merijn> > foldr (:) z [1..5]
09:00:14 <lambdabot>  error:
09:00:15 <lambdabot>      • Couldn't match expected type ‘[a]’ with actual type ‘Expr’
09:00:15 <lambdabot>      • In the second argument of ‘foldr’, namely ‘z’
09:00:22 <merijn> hmm, sad times
09:00:28 <merijn> > foldr (:) [6..10] [1..5]
09:00:31 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
09:06:48 <fhdhsni> merijn: thanks. But I still don't know how to define it  so it looks as nice as (++) like [1,2] ++ [3,4] -- [1,2,3,4]
09:11:33 <merijn> fhdhsni: So just define "glue xs ys" and pass them in reverse order to foldr
09:14:27 * hackage birch-beer 0.1.0.0 - Plot a colorful tree.  http://hackage.haskell.org/package/birch-beer-0.1.0.0 (GregorySchwartz)
09:16:38 <infandum> stack install package will usually complain about setting versions in the yaml. However, the projects on github come with stack.yamls. Is there a way to have "stack install" use the yaml from github?
09:17:09 <Solonarv> infandum: yes, download it first
09:17:26 <Solonarv> or 'git clone whatever && cd whatever && stack install'
09:17:37 <Solonarv> but let's take a step back: what are you trying to accomplish?
09:18:40 <infandum> Solonarv: have people not need to clone the repository. So if it's on hackage, you can say "stack install package" without needing to clone anything. But the yaml is needed for people who are not in the haskell ecosystem and don't know how the global yaml works.
09:19:14 <Solonarv> I was asking which package you're trying to install
09:20:11 <infandum> It's not up yet
09:20:13 <infandum> It's mine
09:20:51 <Solonarv> In that case: put working version bounds in your package's .cabal file
09:24:06 <infandum> I see, I figured that would be the case
09:42:21 <lyxia> infandum: and tell your users to use your stack.yaml
09:43:50 <lyxia> Are you aware that your package also needs to be on stackage for "stack install package" to work?
09:44:46 <Solonarv> that isn't true, actually
09:45:04 <Solonarv> its dependencies need to be on stackage, but the package itself doesn't
09:45:33 <lyxia> then you need to mess with the stack.yaml
09:45:54 <lyxia> that's just more headaches for users 
09:46:24 <Solonarv> No. 'stack install <package>' will look for <package> in the Hackage index, not just Stackage.
09:46:39 <lyxia> oh?
09:47:12 <infandum> yeah
09:47:25 <infandum> It just requires a stack.yaml to specify versions
09:47:28 <lyxia> OK nvm then.
09:47:42 <Solonarv> You can pass a resolver on the command line to pick a specific one
09:48:04 <infandum> I would upload it to stackage and bypass this whole issue, but with all of the dependencies I highly doubt it would build as there are probably conflicts.
09:48:07 <Solonarv> e.g. if <package> builds with LTS 13.1 you do: stack install --resolver lts-13.1 <package>
09:48:40 <Solonarv> Ah, in that case I'd say you should just recommend 'git clone your-repo && cd your-repo && stack install' as the install process
09:48:54 <infandum> yeah, but... yeah...
09:49:30 <infandum> I don't know how used to this potential users would be. Installing stack is probably already a lot, so cloning is another additional step.
09:49:50 <infandum> I have a docker image as backup
09:50:23 <infandum> there's only so much I can do to make the installation as easy as possible, but I'm sure it won't be enough
09:50:53 <infandum> If I build the program, on, say, ubuntu 14.04, can I give the resulting binary to everyone with ubuntu 14.04 or will it not work?
09:51:02 <WilliamHamilton[> hi, I have a question about using the new `TypeRep a` approach in Data.TypeRepMap. I'd like to call the function https://hackage.haskell.org/package/typerep-map-0.3.0/docs/Data-TypeRepMap.html#v:lookup but instead of visibile type applications, I'd like to call it with a SomeTypeRep. Is this possible?
09:51:02 <Solonarv> Honestly there's not much difference between "install stack and run this command" and "install stack & git and run this command"
09:51:15 <infandum> Especially if using inline-r, which interfaces with R
09:51:47 <Solonarv> infandum: I'm not super familiar with package managers, so you may need to supply more than one variant of the binary, but essentially yes
09:52:29 <lyxia> WilliamHamilton[: pattern-match on SomeTypeRep and use withTypeable
09:52:38 <infandum> there's something special with linking though, right? Like static and dynamic
09:55:02 <WilliamHamilton[> lyxia: thanks, I'm trying to do that, but I must be doing something wrong: what does this error mean https://pastebin.com/raw/mWxVQyua ?
09:55:34 <WilliamHamilton[> (TR is Type.Reflection)
09:56:39 <lyxia> WilliamHamilton[: you must use 'case' to pattern match on GADTs.
09:57:27 * hackage crypto-enigma 0.1.1.5 - An Enigma machine simulator with display.  http://hackage.haskell.org/package/crypto-enigma-0.1.1.5 (Orome)
09:59:04 <Boarders> I have a module M.hs and want to import R.hs but use some types defined in M.hs so I have a bootfile M.hs-boot
09:59:25 <Boarders> but I am getting an error:  [recordField] is exported by the hs-boot file, but not exported by the module
09:59:31 <Boarders> is anyone familiar with this?
10:00:02 <Solonarv> Boarders: please upload your files somewhere. gist.github.com allows you to upload multiple files together, so I'd recommend it.
10:00:20 <Solonarv> But also, mutually recursive imports are known to be finicky
10:01:07 <dminuoso> It was really funny when at Munihac Ben asked around "Who here actually uses boot files?" and it was answered with just blank stares and silence..
10:01:29 <WilliamHamilton[> lyxia: thank you very much, solved! Can you give me the intuition on why you must use case to pattern match on GADTs (a fact that I seem to forget periodically)?
10:01:33 <Solonarv> I tried once and gave up after a few hours
10:02:56 <dminuoso> WilliamHamilton[: The best explanation is the error message you have gotten.
10:08:52 <lyxia> WilliamHamilton[: GADTs hide type variables and constraints, and they become available when you pattern-match on them. But 'let' does the pattern-matching lazily, so if that was allowed on GADTs the compiler would have to handle constraints that are kind of not there, and it's just not worth making the compiler more complicated in this way.
10:10:13 <WilliamHamilton[> lyxia: dminuoso I see, thank you very much!
10:12:27 * hackage too-many-cells 0.1.0.0 - Cluster single cells and analyze cell clade relationships.  http://hackage.haskell.org/package/too-many-cells-0.1.0.0 (GregorySchwartz)
10:35:35 <Boarders> Hey I am having a problem with boot files and wonder if anyone has had something similar
10:36:00 <Boarders> I have the following files: module: https://github.com/amnh/PCG/blob/text-rendering/src/Bio/Graph/PhylogeneticDAG/Internal.hs
10:36:12 <Boarders> boot of module: https://github.com/amnh/PCG/blob/text-rendering/src/Bio/Graph/PhylogeneticDAG/Internal.hs
10:36:28 <Boarders> and file I am trying to import into: https://github.com/amnh/PCG/blob/text-rendering/src/Bio/Graph/PhylogeneticDAG/Render.hs
10:36:35 <Boarders> I get the errors:
10:36:40 <Boarders> ‘virtualNodeMapping’ is exported by the hs-boot file, but not exported by the module
10:36:44 <Boarders>  ‘columnMetadata’ is exported by the hs-boot file, but not exported by the module
10:36:47 <Boarders> any ideas?
10:39:26 <Boarders> (btw I could not reproduce a smaller example)
10:47:32 <ski> % data Showables = forall a. Show a => Wraps [a]
10:47:32 <yahb> ski: 
10:47:50 <ski> % Wraps foo <- pure (Wraps "foo")
10:47:51 <yahb> ski: 
10:47:56 <ski> % :t foo
10:47:57 <yahb> ski: [a]
10:48:00 <ski> % foo
10:48:01 <yahb> ski: ; <interactive>:27:1: error:; * No instance for (Show a) arising from a use of `print'; * In a stmt of an interactive GHCi command: print it
10:52:16 <dmwit> ski: Cute bug.
12:07:22 <Boarders> @Solonarv_ : just in case you missed the issue I was having
12:07:22 <lambdabot> Unknown command, try @list
12:07:38 <Boarders> Solonarv_  : just in case you missed the issue I was having*
12:07:45 <Boarders> I posted it above with the files
12:07:52 <Boarders> if you have any ideas please let me know
12:07:58 <Solonarv_> ah, I had indeed missed those
12:08:36 <Boarders> (sorry for pinging but I have been staring at this for ages and can't make head nor tail of it)
12:15:40 <Solonarv_> Boarders: Hmm, I got nothing.
12:15:58 <Boarders> the error is weird, I am going to see if I can produce a minimal example
12:16:07 <Boarders> and then maybe it is a bug with boot files?
12:16:07 <Solonarv_> I was about to suggest that, yes
12:16:28 <merijn> Boarders: You're trying to use hs-boot files?
12:16:33 <Boarders> yes
12:16:41 <Boarders> and having a disaster
12:16:51 <merijn> Boarders: Honestly, I've never gotten it to work
12:17:19 <Boarders> ah, worrying
12:18:40 <merijn> Boarders: Honestly, the easiest solution is to usually put the type definitions in a single module together and import that in others
12:19:02 <Boarders> the problem is I want a module that gives some helper functions that I use in instances
12:19:13 <Boarders> and I dont want orphan instances
12:19:20 <Boarders> so this was an approach to get around it
12:19:26 <Boarders> but it is not going to work out I think
12:19:37 <merijn> Boarders: I missed the original link, what was it?
12:19:59 <Boarders> it is a bit unwieldy:
12:20:04 <Boarders> bootfile: https://github.com/amnh/PCG/blob/text-rendering/src/Bio/Graph/PhylogeneticDAG/Internal.hs-boot
12:20:14 <Boarders> module: https://github.com/amnh/PCG/blob/text-rendering/src/Bio/Graph/PhylogeneticDAG/Internal.hs
12:20:28 <Boarders> module I am trying to import bootfile to: https://github.com/amnh/PCG/blob/text-rendering/src/Bio/Graph/PhylogeneticDAG/Render.hs
12:20:37 <Boarders> I get the error: 
12:20:38 <Boarders> ‘contextualNodeDatum’ is exported by the hs-boot file, but not exported by the module
12:21:04 <Boarders> it might be something dumb since I have a great capacity for that
12:22:10 <merijn> Boarders: So what's the recursion? i.e. what are they importing from eachother?
12:22:14 <Solonarv_> I did notice that your hs-boot file doesn't seem to have an explicit export list
12:22:35 <Boarders> yeah I did add the explicit imports back but to no luck
12:22:57 <Boarders> merijn: Render.hs imports the types from Internal and then Internal imports the functions from Render
12:23:39 <merijn> And you can't get away with just moving the functions into Render?
12:24:29 <Solonarv_> (I think you meant "moving the functions into Internal")
12:24:39 <Boarders> I use the Render functions in the TextShow instances in Internal
12:24:46 <Boarders> I could move them back into Internal
12:24:54 <merijn> eh, yes
12:24:56 <Boarders> it was just an aesthetic choice so the file is not really long
12:24:57 <Boarders> so yes
12:25:05 <Boarders> that is what I will end up doing
12:25:14 <Boarders> punishment for trying to be """fancy"""
12:25:29 <dmwit> Boarders: At a guess, you are hitting this clause from the documentation:
12:25:40 <dmwit> "You can also write out the constructors but, if you do so, you must write it out precisely as in its real definition."
12:25:50 <dmwit> No skipping fields allowed.
12:26:09 <Boarders> hmm, do you have an example of what might be disallowed by that?
12:26:26 <Boarders> I suppose for just the type you are allowed to declare Data Type
12:26:41 <Boarders> but if you want the constructor you need Data Type = [ActualConstructors]?
12:27:00 <Boarders> (I don't think I am doing that but it is quite possibly what is going on)
12:27:31 <dmwit> Hm, never mind. I thought you were skipping fields, but you aren't.
12:35:18 <Boarders> Solonarv_: could not manage to make a small example O____0
12:35:25 <Boarders> oh well
12:35:33 <Boarders> time to abandon boot files for eternity
12:36:02 <dmwit> Did you start from scratch? Usually a saner approach is to start from the thing that displays the behavior you don't like and try deleting stuff.
12:36:27 <Boarders> yeah but the project is too intertwined for me to cut stuff out like that I think
12:36:28 <Boarders> idk
12:40:37 <ca1ek> does haskell platform install msys on it's own?
12:40:59 <ca1ek> because I would like it installed to my existing mingw64 environment rather than having another one just for haskell
12:43:34 <Solonarv_> it comes with an msys install, but you don't actually end up using that directly
12:45:56 <ca1ek> to be honest i could just use WSL rather than msys
12:48:28 * hackage hal 0.1.2 - A runtime environment for Haskell applications running on AWS Lambda.  http://hackage.haskell.org/package/hal-0.1.2 (nikeoss)
12:48:58 <Solonarv> it actually works just fine in the plain old windows terminal
12:49:54 <geekosaur> haskell doesn't work well in wsl
12:50:03 <geekosaur> its emulation leaves a *lot* tp be desired.
12:50:05 <merijn> Yet ;)
12:50:36 <geekosaur> I think there's a custom build without 2-stage memory allocation because that fails pretty comprehensively in wsl
12:50:36 <geekosaur> (might be hvr's?)
12:50:49 <Solonarv> Haskell on windows has some issues, but having to fuck around with msys/mingw/cygwin/whatever isn't one of them (fortunately)
12:57:40 <SomeGuy001> Hey, I just wanna make sure this is the right place to ask questions... is it?
12:57:50 <merijn> Depends on about what :p
12:58:02 <SomeGuy001> On if I should ask questions in here or not :P
12:58:08 <SomeGuy001> Nah, but for real... I'm having a linker error, I guess?
12:58:09 <Cale> Questions about haskell are very welcome :)
12:58:19 <Cale> okay
12:59:28 * hackage pusher-http-haskell 1.5.1.7 - Haskell client library for the Pusher HTTP API  http://hackage.haskell.org/package/pusher-http-haskell-1.5.1.7 (willsewell)
13:05:40 <SomeGuy001> https://gist.github.com/APIInterfacing/ee301442839bc08afede47b9b277b925 - At the top is me trying to load my HS file. That works fine and I can even display the type for printPrimes
13:05:55 <SomeGuy001> But as soon as I try to use printPrimes, GHCI crashes
13:07:11 <SomeGuy001> I have the primesieve program and the dev / library things for it installed, and cabal didn't give me any issues. The source code for the program is just me importing Foundation and Math.Prime.FastSieve
13:07:48 <SomeGuy001> (The three libraries I have are libprimesieve8, libprimesieve-dev, and libprimesieve-dev-common)
13:08:23 <geekosaur> right, so the symbol it's looking for is referenced from that library, but note the "U" next to it: undefined, expected to come from somewhere else
13:08:32 <geekosaur> and apparently it doesn't know where
13:08:50 <SomeGuy001> Yeah... I looked around online to figure this out, but TBH I'm not good with or know much about computers
13:09:18 <geekosaur> compiling might well work it out, from ghci you probably have to run it with a -l option spcifying the C library'
13:10:54 <geekosaur> so looks like you need to run: ghci (whatever other options you had here) -lprimesieve
13:11:01 <SomeGuy001> Just tried that, it crashed again :/
13:11:37 <SomeGuy001> And I do see primesieve when I run 'pkg-config --list-all' so I'm pretty sure it's there. I think...
13:11:43 <merijn> Anyone here know if you have to manually delete candidates on Hackage? I'm seeing a bunch of candidates on the management page
13:12:41 <geekosaur> that doesn't mean ghci knows how to find it, or even that it's needed as such
13:12:57 <geekosaur> builing a packge, there's enough inormation for that. ghci by itself, no
13:13:15 <geekosaur> if it's a cabal project, you can try cabal repl instead of raw ghci
13:14:02 <SomeGuy001> Is there a way to have all of this done automatically for me? I really don't like dealing with this stuff, I just want things to work :/
13:14:13 <SomeGuy001> Or is this just something I'd have to write a script for and figure out how to do?
13:16:36 <SomeGuy001> (Not trying to say I won't do what I need to do right now to get it to work, just that I never in my life want to have to do this again)
13:27:11 <koz_> SomeGuy001: What's the output of 'pkg-config --libs libprimesieve'?
13:27:20 <koz_> (or whatever name pkg-config knows libprimesieve under)
13:28:00 <SomeGuy001> primesieve                     primesieve - Fast C/C++ prime number generator
13:28:18 <koz_> So, what's the output of 'pkg-config --libs primesieve'?
13:28:19 <nonzen> SomeGuy001: To me it looks like you're using Haskell FFI bindings to https://github.com/kimwalisch/primesieve, but you don't have the C/C++ libraru installed?
13:28:52 <SomeGuy001> (One sec. If you @ me it's hard for me to see the message, gonna try to change these settings)
13:30:42 <SomeGuy001> When I use 'pkg-config --libs libprimesieve' I get 'Package libprimesieve was not found in the pkg-config search path.' and a few other things, but when I use 'pkg-config --libs primesieve' I get '-lprimesieve'
13:30:46 <SomeGuy001> Not sure if that makes any difference
13:31:10 <koz_> SomeGuy001: That's because 'primesieve' is the name that pkg-config gives to libprimesieve.
13:32:46 <koz_> SomeGuy001: And I guess you tried geekosaur's suggestion of doing 'ghci [your other options] -lprimesieve'?
13:32:47 <SomeGuy001> Nonzen: I'm not sure what you mean. I did install all the FFTW packages I could find earlier
13:32:53 <SomeGuy001> Yep, same issue
13:33:28 <koz_> SomeGuy001: FFTW has nothing to do with it. FFI /= FFTW.
13:34:08 <SomeGuy001> Like I said, it's hard to read when people mention me. I thought I changed the color setting but it didn't make any difference. Let me try changing another color...
13:34:19 <geekosaur> understand that the 'lib' is a fxixed part of the library name, and is supplied by the linker
13:34:33 <geekosaur> the package name is libprimesieve, that's because of how debian names its packages
13:34:52 <geekosaur> it isn't necessarily related to the library or libraries
13:35:03 <koz_> SomeGuy001: Could you also paste the PE0050.hs file for us?
13:35:10 <koz_> (well, gist, not paste, but yeah)
13:35:17 <geekosaur> and liekwise for pkg-config, which is *for* libraries so you normally don't say that
13:35:29 <geekosaur> or every single pkgconfig package would be named lib(something)
13:38:06 <SomeGuy001> https://gist.github.com/APIInterfacing/ee301442839bc08afede47b9b277b925
13:38:12 <SomeGuy001> (Same link, I updated it)
13:41:08 <koz_> import Math.Prime.FastSieve <-- what library is this from?
13:41:32 <geekosaur> hm, actually, ooking at this, I think the command line can't work around it. it would need to be in the conf file for the package it's loading
13:41:37 <merijn> Does anyone know how the MINIMAL typeclass pragma interacts with DefaultSignatures?
13:41:45 <geekosaur> i.e. wherever Math.Prime.FastSieve comes from
13:41:59 <SomeGuy001> http://hackage.haskell.org/package/primesieve
13:42:28 <geekosaur> ewwwwww
13:42:32 <Levy[m]> currently in a bit of a bind, any hints of how to get from `(Monad m, Functor f) => f (m (c, Wire m b c))` to `(Monad m, Functor f) => m (f c, f (Wire m b c))` ? 
13:42:33 <geekosaur> that package is broken
13:42:41 <koz_> And _horrendously_ under-docced.
13:42:56 <SomeGuy001> How can you tell it's broken?
13:43:01 <geekosaur> it puts the foreign library in the specification for its test executables, when it needs to be part of the library spec
13:43:25 <Levy[m]> assuming I'm within the context of the embedded monad
13:43:39 <geekosaur> http://hackage.haskell.org/package/primesieve-0.1.0.1/src/primesieve.cabal note the extra-libraries: lines. there should be only one such, and in the "library" part instead of "executable ..."
13:43:40 <SomeGuy001> (I see the failed builds thing on the bottom right, but I don't know how to interpret that TBH)
13:44:07 <geekosaur> and ghci simply isn't going to be able to get this right as a result
13:44:57 <SomeGuy001> So... do I have to write my own version, or this fixable?
13:45:18 <geekosaur> you can download the source, make the adjustmeent I just described, and build and install it locally
13:45:37 <geekosaur> ideally also report a bug against it so it'll be fixed by the author (hopefully)
13:46:17 <geekosaur> there's also  quick hack, but it won't help anyone else
13:47:18 <geekosaur> you can find the .conf file for this package in ghc's package database, edit it to add the extra-libraries part, then "ghc-pkg recache --local"
13:47:32 <geekosaur> but that requires some experience with how ghc's package database works
13:48:47 <SomeGuy001> Alright, I guess I'll try the other stuff out and hopefully not have to deal with this sort of thing anymore :/
13:48:49 <SomeGuy001> Thanks, everyone
13:53:26 <merijn> hmmm
13:53:37 <merijn> The new rendering of DefaultSignatures with haddock is a bit confusing...
13:53:53 <dmwit> Levy[m]: Can't. Gotta know something special about `f` -- say, that it's `Traversable`, perhaps.
13:55:35 <merijn> Apparently DefaultSignatures now causes haddock to list a class method twice...
13:55:36 <dmwit> :t fmap (\v -> (fst <$> v, snd <$> v)) . sequenceA
13:55:38 <lambdabot> (Applicative f1, Traversable f2) => f2 (f1 (a, b)) -> f1 (f2 a, f2 b)
13:55:39 <merijn> See: https://hackage.haskell.org/package/binary-0.8.6.0/docs/Data-Binary.html#t:Binary
13:55:41 <Levy[m]> Yep, noticed after asking
13:55:42 <Levy[m]> Thanks
13:55:44 <merijn> Which has two put and two get
13:55:55 <merijn> That seems...unnecessarily confusing
13:56:21 <Solonarv> *now*? I was under the impression it's worked that way for quite a while
13:57:03 <dmwit> merijn: You should fix it to display more cleanly! Maybe include some text indicating that it's a default signature somehow, and move the two next to each other or something.
13:57:13 <merijn> dmwit: Looks like someone already did!
13:57:18 <dmwit> yay!
13:57:20 <merijn> dmwit: https://github.com/haskell/haddock/pull/822
13:57:22 * dmwit high fives merijn
13:57:30 <merijn> dmwit: Now I just need to figure out how to generate my docs with that
13:59:26 <merijn> Can I update my local haddock somehow?
13:59:58 <dmwit> Perhaps you can just cabal install it. Wouldn't that be nice?
14:00:53 <merijn> dmwit: I recall it was tied to GHC somehow
14:03:53 --- mode: ChanServ set +o glguy
14:03:53 --- mode: glguy set -vvvv benl23_ coot__ corlock_ cyjiao_
14:03:54 --- mode: glguy set -vvvv exferenceBot fcse feepo Ferdirand
14:03:54 --- mode: glguy set -vvvv fingerzam Firedancer isacl_ koankeeper
14:03:54 --- mode: glguy set -vvvv kyagrd_ Logio mbeidler newhoggy_
14:03:55 --- mode: glguy set -vvvv nickoralias paf31_ Peter_Storm__ ranberry__
14:03:56 --- mode: glguy set -vvvv shiona simony_ spherinder[m] sppky
14:03:57 --- mode: glguy set -o glguy
14:05:07 <merijn> Guess I'll download 8.6.3 and try building docs with that
14:09:08 <merijn> "I'll just quickly upload the new release of this package..." 2 hours and a new GHC install later...
14:16:06 <merijn> So, anyone know how I tell cabal to use a different haddock?
14:26:51 <merijn> Welp, even that's not enough. It's "should I really build GHC from source or just give up?" o'clock...
14:33:13 <Welkin> write ghc from scratch?
14:50:06 <merijn> I give up...
14:51:08 <merijn> this branch doesn't build with 8.7 nightly and the haddock shipping with 8.7 doesn't solve the issue either
14:54:22 <Welkin> 8.7?
14:54:34 <Welkin> since when are there odd-numbered releases?
14:54:46 <glguy> Since GHC gets developed on odd releases
14:54:50 <merijn> Welkin: Odd numbered versions refer to HEAD
14:58:31 <tdammers> good old unix beard tradition
14:58:47 <merijn> hmmm, for some weird reason I'm now getting the new haddock style for my package haddocks and I can't get rid off it...
14:59:34 <merijn> I wonder if it got stuck in the fastly cache
15:03:28 * hackage validated-literals 0.3.0 - Compile-time checking for partial smart-constructors  http://hackage.haskell.org/package/validated-literals-0.3.0 (MerijnVerstraaten)
15:03:57 <merijn> \o/
15:08:55 <merijn> I guess "partial" is misleading there. Oh well
15:16:58 * hackage pinboard 0.10.1.3 - Access to the Pinboard API  http://hackage.haskell.org/package/pinboard-0.10.1.3 (jonschoning)
15:17:58 * hackage smtLib 1.1 - A library for working with the SMTLIB format.  http://hackage.haskell.org/package/smtLib-1.1 (IavorDiatchki)
15:35:05 --- mode: ChanServ set +o glguy
15:43:16 --- mode: glguy set -o glguy
16:35:23 <argent0> is there a class for things that can be built in sequence? I'm thinking in defining something like: quadTime :: forall a b c f . Foldable f => (a -> b -> c) -> f a -> f b -> [c]
16:35:50 <xsperry> hi. is there a way to access non-exported methods? I want to create an instance of some class. library exports the class, but not method required to create an instance of that class
16:35:58 <argent0> that applies f to all pairs a b
16:36:16 <geekosaur> xsperry, no. some packages provide an internals module for such things
16:36:49 <geekosaur> otherwise, if it wasn't exported, it's not identifiably there (it's there as machine code but no way to find it)
16:37:24 <Welkin> the purpose of a module is to expose an API
16:37:39 <Welkin> anything that is exported is part of that API, and anything that is not exported it meant to be internal only
16:37:40 <c_wraith> xsperry, that's something that's usually done explicitly to prevent creating instances
16:38:49 <xsperry> I'm trying to create PrintfType instance for MonadIO m => m. there doesn't seem to be an internals module
16:38:56 <geekosaur> and yes, if it's hding constructors it's usually for a reason
16:40:12 <argent0> Is there a `fromList` type class?
16:40:35 <dmwit> argent0: Yes, IsList
16:41:21 <dmwit> argent0: For your first question you might like https://hackage.haskell.org/package/these-0.7.5/docs/Data-Align.html#t:Align
16:42:06 <argent0> dmwit: Thanks, I'll check those out
16:45:48 <ski> argent0 : did you mean to combine every `a' in the `f a' with every `b' in the `f b' ?
16:46:23 <ski> or proceed in lockstep/parallel, combining corresponding pairs at corresponding "positions" (in some sense) ?
16:46:55 <xsperry> c_wraith, I realize that. was just wondering if there's an escape hatch, and I'm a bit surprised that there isn't one
16:46:57 <ski> ("applies f to all pairs a b" would seem to suggest the former to me, but perhaps you intended the latter. or maybe something else)
16:48:54 <argent0> ski: the first option
16:49:22 <argent0> thus, "quadraticTime"
16:49:44 <ski> ok, then i think you don't want `Data.Align'
16:49:58 <ski> @type foldMap (:[])
16:49:59 <lambdabot> Foldable t => t a -> [a]
16:50:28 <ski> you can convert your `f a' and `g a' to `[a]' and `[b]', and then combine those as usual, using `a -> b -> c', to `[c]' ?
16:50:52 <ski> (using list comprehension, or `concat'/`concatMap', or `liftA2')
16:51:20 <argent0> I have an implementation: quadTime f as bs = f <$> (DF.toList as) <*> (DF.toList bs)
16:51:21 <ski> (er, `f b', not `g a')
16:51:37 <ski> yea, that is the same thing
16:51:44 <ski> (as the `liftA2' version)
16:51:50 <argent0> yes
16:52:04 <ski> (the brackets are redundant, btw)
16:52:47 * ski would probably not bother with calling `toList' there, though
16:53:12 <argent0> ski, why not?
16:53:47 <ski> (if `quadTime' immediately throws away the extra `f' structure, only using the list of elements, then why does it need to deal with `f' at all, why not just pass it the lists ?)
16:55:23 <xsperry> is this syntax correct? I'm not seeing any effect. {-# OPTIONS_GHC -Worphans #-}
16:55:31 <ski> anyway, perhaps you think it's nicer to put the `toList' calls there, rather than in the caller (which might duplicate those calls) .. which would be fair enough
16:55:44 <xsperry> (I want to disable those warnings)
16:55:52 <ski> it's just that it looks suspicious to me
16:56:33 <argent0> ski, yes I'd like a "generic" quadratic time algorithm, that I can apply anywhere where it makes sense.
16:56:46 <argent0> e.g: map
16:56:54 <argent0> s/map/Map/
16:57:16 <dmj`> Does disabling optimizations (i.e. --disable-optimization) affect symbol resolution for the C FFI? Am running into an issue where it works w/ optimizations, but not w/o (get an undefined reference)
16:57:25 <ski> if your operation returned a `f c', instead of `[c]', it would be another matter
16:57:28 <Welkin> xsperry: use {-# LANGUAGE StandaloneDeriving #-}
16:58:34 <Welkin> that is if you are deriving the instance
16:58:38 <nshepperd> xsperry: note that you can't create an instance 'for' MonadIO m => m a, anyway
16:58:51 <ski> argent0 : fwiw, you could even have `forall a b c f g. (Foldable f,Foldable g) => (a -> b -> c) -> f a -> g b -> [c]', with your current implementation. no need to require `f' to be the same as `g'
16:59:14 <Welkin> if you want to turn off warnings you must use `no-orphans`, not `orphans`
17:00:12 <nshepperd> xsperry: if you could create it, it would be an instance for 'm a' and would overlap with all the other instances (and it would happen to induce a MonadIO constraint, once chosen)
17:00:13 <ski> argent0 : .. and this smells possibly similar to wanting to have e.g. a `(+)' operation which can accept arguments of different numeric types, in the same call
17:00:17 <argent0> ski, Right.
17:00:49 <ski> (which i'm not convinced is a good idea .. in any case in the way people usually seem to want that)
17:01:15 <ski> (e.g. adding a scalar to a matrix)
17:01:26 <argent0> ski: That's why I used f
17:01:32 <ski> ok
17:01:53 <xsperry> nsshepperd are you sure? I just did :)
17:01:56 <nshepperd> i imagine that overlapping instances would make type errors with usage of printf even more confusing than usual
17:02:15 <ski> argent0 : `exists f. Foldable f *> f a' is more or less the same thing as `[a]'
17:02:19 <aranea> Adding a scalar to a matrix? What would that even do? Add x to every entry, or add x*unit matrix?
17:02:35 <xsperry> > printf "test\n" :: MonadIO m => m ()   => test
17:02:38 <lambdabot>  error:
17:02:38 <lambdabot>      • Expected a constraint, but ‘m ()’ has kind ‘*’
17:02:38 <lambdabot>      • In an expression type signature: MonadIO m => m () => test
17:03:27 <argent0> ski: where does the *> comes from?
17:03:34 <argent0> s/comes/come/
17:03:50 <xsperry> nshepperd, I don't see any issues, String and IO instances still work
17:03:52 <jackdk> > printf "test\n" :: MonadIO m => m ()
17:03:54 <lambdabot>  error:
17:03:55 <lambdabot>      • Could not deduce (PrintfType (m1 ()))
17:03:55 <lambdabot>          arising from a use of ‘printf’
17:04:08 <dmwit> ski: (You know the standard objection to that claim?)
17:04:12 <ski> argent0 : so `quadTime :: forall a b c f g. (Foldable f,Foldable g) => (a -> b -> c) -> f a -> g b -> [c]' is basically `quadTime :: forall a b c. (a -> b -> c) -> (exists f. Foldable f *> f a) -> (exists g. Foldable g *> g b) -> [c]', which is then more or less the same thing as `forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]'
17:04:33 <ski> dmwit : yes, there's a blog post about it
17:04:37 * dmwit nods
17:04:49 <nshepperd> the standard object is the 'or less' part :p
17:04:53 <nshepperd> *objection
17:05:13 <dmwit> argent0: *> comes from ski's brain =)
17:05:18 <xsperry> jackdk, I downloaded printf's source and modified it. it can't be done from the user's space, as Text.Printf does not export PrintfType.spr
17:05:43 <jackdk> ah
17:05:45 <dmwit> argent0: Where you can think of => as being a "function" which takes a typeclass dictionary, you can think of *> as being a "pair" that includes a typeclass dictionary.
17:06:15 <ski> argent0 : anyway, so according to this argument, which is admittedly a bit shaky (as dmwit indicated), you don't buy more expressivity by this use of `Foldable', only some convenience (which may be enough to warrant your use)
17:06:17 <Welkin> you can transform => into ->
17:06:25 <dmwit> argent0: (It doesn't actually exist in GHC. But it's convenient shorthand for things that do exist.)
17:06:35 <Welkin> and all typeclass constraints into parameters separated by arrow functions ->
17:08:31 <ski> "Free Monoids in Haskell" by dolio in 2015-02-21 <http://comonad.com/reader/2015/free-monoids-in-haskell/> is the blag in question
17:09:16 <ski> argent0 : `forall a. (F a -> T)' is logically equivalent to `(exists a. F a) -> T', agree ?
17:09:36 <argent0> ski: yes
17:09:40 <ski> e.g. `length :: forall a. ([a] -> Int)' means the same thing as `length :: (exists a. [a]) -> Int'
17:10:10 <ski> the former says that, for every type `a', we can apply `length' to a value of type `[a]', and get a result of type `Int' back
17:10:51 <ski> the latter says that we get a result of type `Int' back, if we apply `length', as long as there exists some type `a' such that the argument we apply `length' to has type `[a]'
17:11:10 <argent0> ok
17:11:42 <ski> argent0 : now, i claim that `Constr => (T -> U)' is logically equivalent to `(Constr *> T) -> U'
17:12:29 <argent0> thats the typeclass dictionaries?
17:12:47 <ski> you can *use* (/consume/"call") a value of type `Constr => U', if you (the caller/user) provide evidence for `Constr', and in that case, you can use the value as if it had type `U'
17:13:14 <argent0> ok
17:13:38 <ski> (to produce/construct/define such a value, you (the callee/producer) just *assume* that the caller will provide evidence of `Constr'. you can just rely on it being there)
17:15:23 <ski> when *using* (/consuming/"calling") a value of type `Constr *> T', you (the caller/user) is provided with evidence for (/ gets to assume) `Constr', in addition to a value of type `T'
17:16:01 <ski> (while to produce/construct/define such a value, you (the callee/producer) need to both provide evidence for `Constr', as well as produce a value of type `T')
17:17:13 <ski> so, just as the roles of producer/consumer, or callee/caller, &c. are swapped, when using `forall' vs. when using `exists' (who gets to pick the type to use in place of the type variable, and who has to be content with any choice made)
17:17:58 <argent0> I don't follow
17:19:00 <ski> `Nothing' has type `forall a. Maybe a'. this means that the user of `Nothing' gets to pick any type to use in place of `a', say `Bool', so that the user may use `Nothing' as having type `Maybe Bool'
17:19:37 <ski> or, `reverse' has type `forall a. [a] -> [a]'. the caller/user may pick `a' as `Bool', so that they may use `reverse' as having type `[Bool] -> [Bool]'
17:20:21 <argent0> yes
17:20:26 <ski> otoh, the producer of `reverse', the callee, the implementation, does not get to pick `a', or assume anything about it. to the implementation, `a' behaves as an abstract data type, an opaque type
17:20:49 <ski> if we imagine
17:21:03 <ski>   silly :: Bool -> (exists a. (a,a -> a,a -> String))
17:21:23 <ski>   silly False = (False,not,show)
17:21:32 <ski>   silly True  = ("True",reverse,id)
17:22:12 <ski> then here the *implementation* gets to pick the particular type to use in place of `a', since `exists' was used, not `forall'
17:22:25 <ski> (in fact, the particular choice made can depend on run-time values, as you can see)
17:22:34 <argent0> yes
17:23:18 <ski> while the user, the caller, of `silly', now has to treat the type `a' in the return value as an abstract/opaque/hidden/forgotten type (sometimes called a "skolem type")
17:23:37 <xsperry> another useful printf instance.. for Text
17:23:52 <argent0> yes, he only know that there is a value a, a->a and a->String
17:24:06 <ski> so changing a `forall' into an `exists', or vice versa, flips around who gets to pick/choose the type, and who must treat it as abstract
17:24:12 <ski> argent0 : makes sense, now ?
17:24:21 <argent0> yes
17:24:54 <argent0> how does this apply to quadTime?
17:24:57 <ski> now the roles of who gets to *assume* (/require) evidence of the constraint `Constr', and who is required to *provide* said evidence, is swapped, when we use `Constr => U' vs. `Constr *> T'
17:25:01 <argent0> :p
17:25:24 <ski> so, just as
17:25:29 <ski> <ski> argent0 : `forall a. (F a -> T)' is logically equivalent to `(exists a. F a) -> T', agree ?
17:25:43 <ski> (because the left side of `->' is logically inverted)
17:25:47 <ski> we also have
17:25:53 <ski> <ski> argent0 : now, i claim that `Constr => (T -> U)' is logically equivalent to `(Constr *> T) -> U'
17:27:08 <ski> if you think in terms of the dictionary passing translation/implementation of type class evidence, you can think of `Constr => (T -> U)' as being the curried version, and `(Constr *> T) -> U' as being the uncurried version
17:27:25 <ski> conceptually, we're passed a separate argument encoding evidence for `Constr', with the former
17:27:57 <ski> while with the latter, conceptually, that evidence is bundled together (in a pair, so to speak) with the argument of type `T'
17:28:27 <ski> so one couls say that `*>' is to `=>' as `(,)' is to `(->)' (and also compare with how `exists' is to `forall')
17:28:36 <ski> argent0, ok ?
17:29:24 * ski assumes argent0 has heard of the dictionary passing translation for type classes, before
17:29:32 <argent0> nope
17:29:35 <ski> ok
17:29:42 <ski> consider e.g.
17:30:05 <ski>   elem :: Eq a => a -> [a] -> Bool
17:30:21 <ski>   elem _  [    ] = False
17:30:37 <ski>   elem x0 (x:xs) = x0 == x || elem x0 xs
17:30:49 <argent0> yes
17:30:51 <ski> and
17:30:52 <ski> @src Eq
17:30:52 <lambdabot> class Eq a where
17:30:52 <lambdabot>     (==), (/=) :: a -> a -> Bool
17:31:16 <ski> one way to implement this is to translate that type class definition into a data type, like
17:31:36 <ski>   data EqDict a = MkEqDict {eq,neq :: a -> a -> Bool}
17:31:53 <ski> and an instance like
17:31:59 <ski>   instance Eq Ordering
17:32:01 <ski>     where
17:32:09 <ski>     LT == LT = True
17:32:12 <ski>     ...
17:32:19 <ski> is translated into a value
17:32:30 <argent0> why are you instancing Eq Ordering?
17:32:42 <ski> just as an example
17:32:47 <ski>   instEqOrdering :: EqDict Ordering
17:33:08 <ski>   instEqOrdering = MkEqDict {eq = ...,neq = ...}
17:33:24 <ski> and then the definition of `elem' above is translated into
17:33:38 <ski>   elem :: EqDict a -> a -> [a] -> Bool
17:33:56 <ski>   elem _    _  [    ] = False
17:34:09 <ski>   elem dict x0 (x:xs) = eq dict x0 x || elem dict x0 xs
17:34:32 <ski> where `eq dict' just selects the function of type `a -> a -> Bool' in the `eq' field of the dictionary argument
17:34:58 <ski> so, now we explicitly pass around records of implementation of "type class methods", for particular types (here `a')
17:34:59 <argent0> what is eq type signature
17:35:01 <argent0> ?
17:35:17 <ski>   eq,neq :: EqDict a -> (a -> a -> Bool)
17:35:26 <ski> as field selector functions
17:36:03 <ski> the point is, `=>' in types gets translated to `->', with this translation
17:36:17 <argent0> yes
17:36:23 <ski> and explicit arguments are passed around, instead of implicit propagation of evidence for type class constraints
17:36:44 <ski> if there was any `*>', then it would get translated into `(,)'
17:37:11 <ski> so that e.g. `exists a. Eq a *> [a]' would get translated into `exists a. (EqDict a,[a])'
17:37:42 <ski> while `[exists a. Eq a *> a]' would get translated into `[exists a. (EqDict a,a)]'
17:38:23 <ski> in the former case, there is a single, unknown, type `a', about which is only known that it's an instance of `Eq'. and we have a list of values of that same common unknown type `a'
17:39:02 <ski> in the latter case, each element of the list could possibly be of a different type `a' (all instances of `Eq', however). and therefore a user must assume the worst, and can't compare different elements to each other
17:39:17 <ski> in the former case, we could compare different elements to each other, however
17:40:15 <ski> anyway, i forgot to say before that, combining the two logical equivalences, `forall a. (C a => (F a -> T))' is logically equivalent to `(exists a. (C a *> F a)) -> T'
17:40:25 <ski> which is exactly the step i used to get from
17:40:35 <ski>   quadTime :: forall a b c f g. (Foldable f,Foldable g) => (a -> b -> c) -> f a -> g b -> [c]
17:40:38 <ski> to
17:40:45 <ski>   quadTime :: forall a b c. (a -> b -> c) -> (exists f. Foldable f *> f a) -> (exists g. Foldable g *> g b) -> [c]
17:41:04 <ski> (with some additional rearrangment/reordering of arguments and constraints)
17:41:28 <ski> argent0 : making any sense, now ?
17:41:55 <xsperry> you managed to confused me (and I learned what Eq was two years ago)
17:41:56 <argent0> nope
17:42:24 <argent0>  while `[exists a. Eq a *> a]' would get translated into `[exists a. (EqDict a,a)]'
17:42:31 <argent0> this part ^
17:42:53 <argent0> and how all a, would be diffrent types
17:43:21 <ski> a value of type `[exists a. Eq a *> a]' is a list whose elements have type `exists a. Eq a *> a'. so, for every element of the list, there exists some type `a', known to be an instance of `Eq', such that the element has type `a'
17:44:26 <ski> e.g. `False' has type `Bool'. and we know `Eq False' holds. therefore we can (conceptually) bundle this value with this piece of constraint evidence, to claim that `False' also has type `Eq Bool *> Bool'
17:44:30 <argent0> yes, then, as you said, you can't compare
17:44:40 <argent0> elements
17:44:58 <ski> then, we can forget / abstract away the `Bool', into a type variable, claiming that `False' also has type `exists a. Eq a *> a'
17:46:18 <ski> (it also has type `exists a. Eq a *> Bool', and also has type `exists a. Eq Bool *> a', and also has type `exists a. Eq Bool *> Bool'. but neither of those are what i wanted in this case. we can choose *which* occurences of `Bool' we want to abstract away, and which we want to keep "transparent")
17:47:00 <ski> similarly, `"True"' has type `String', which is an instance of `Eq', hence `"True"' can also be given type `exists a. Eq a *> a'
17:47:36 <ski> so both `False' and `"True"' can be given the same type `exists a. Eq a *> a', so we can put them in a common list, `[False,"True"]', having type `[exists a. Eq a *> a]'
17:47:40 <argent0> So, your point is about whether I should use the Foldable contrain or not
17:47:59 <argent0> or be honest about it being a list
17:48:20 <argent0> is that it?
17:48:56 <Solonarv_> I believe so
17:49:17 <ski> i'm arguing that, upto `Foldable' essentially being `ToList' (which isn't quite the case, see the blag above), your formulation of `quadTime', involving `Foldable', would be equivalent in power to one only involving lists. so there would then be no expressive gain in using `Foldable'
17:50:10 <ski> but, there could still be a convenience gain. presumably you're going to put those calls to `DL.toList' *somewhere*, and in that case it may be that the best place to put them in your program is inside this operation `quadTime'
17:50:52 <ski> the decision/judgement is of course up to you
17:51:16 <ski> argent0 : i was just attempting to explain why it *looked* potentially fishy, to me
17:51:40 <ski> @where existential-antipattern
17:51:40 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
17:51:56 <ski> is another blag, doing a somewhat similar argument
17:52:10 <ski> in some cases, using existentials can be indispensible
17:52:50 <ski> but still, some uses of them could be considered "frivolous", unnecessary, overkill, however you want to say it
17:53:33 * ski . o O ( <https://en.wikipedia.org/wiki/Rule_of_least_power> )
17:55:02 <argent0> that is what you mean by power in: "would be equivalent in power to one only involving lists"
17:55:05 <argent0> ?
17:55:37 <glguy> People love calling things anti-patterns
17:55:42 <ski> more or less, yes
17:56:09 <Welkin> anti-anti-patterns
17:56:15 <xsperry> glguy you don't think it is justified in above case?
17:57:27 <ski> argent0 : here's another example
17:57:35 <ski> let's say you write
17:57:51 <ski>   frob :: IO Foo -> IO Blah
17:57:58 <glguy> xsperry: I think people learned from that post that when someone says ExistentialQuantification that they get to write "anti-pattern"
17:58:19 <ski>   frob act = do foo <- act
17:58:21 <ski>                 ..foo..
17:58:26 <Welkin> frobisher?
17:58:32 <Welkin> from Torchwood?
17:58:44 <ski> not using `act' anymore in the body of `frob', apart from that first line
17:59:28 <argent0> Welkin: frob.com
17:59:36 <argent0> ski: ok
17:59:38 <ski> one could argue that the type signature of `frob' is misleading, since it introduces the additional power of passing an I/O-action computing a `Foo', as an argument, instead of simply passing a plain `Foo'
17:59:57 * hackage gi-cairo-render 0.0.1 - GI friendly Binding to the Cairo library.  http://hackage.haskell.org/package/gi-cairo-render-0.0.1 (eyevanmalicesun)
18:00:34 <coldpress> if I have a monad m, and a bunch of Kleisli functions of the form a -> m b. How do I use arrow combinators on those Kleisli functions?
18:00:41 <argent0> I'm not sure I agree on the miseleading, as you said you have to put the toLIst somewhere
18:00:47 <ski> if one sees such a type signature, one would usually assume that the operation wanted to use the callback action in some "serious" way, like executing it more than once, or perhaps sometimes not executing it at all. or perhaps registering it to be (possibly) executed later
18:01:13 <argent0> ski, yes
18:01:15 <Solonarv> you wrap them in 'Kleisli', coldpress. Yes, it's cumbersome.
18:01:21 <argent0> that makes sense
18:01:27 <ski> or at least executing something else beforehand, or executing `act' in some dynamic context that `frob' introduces (and presumably tears down at the end)
18:01:52 <ski> e.g. `forkIO', or `bracket', or other operations of this sort
18:01:57 * hackage gi-cairo-connector 0.0.1 - GI friendly Binding to the Cairo library.  http://hackage.haskell.org/package/gi-cairo-connector-0.0.1 (eyevanmalicesun)
18:02:16 <Solonarv> :t runKleisli (Kleisli ?f &&& Kleisli ?g) -- coldpress
18:02:17 <lambdabot> (?g::a -> m c', ?f::a -> m c, Monad m) => a -> m (c, c')
18:02:26 <argent0> yes, for the current implementation if equivalent to just Foo -> IO Blah
18:02:44 <ski> seeing this implementation of `frob', the kneejerk reaction should be to refactor the invokation of `act' to occur not inside `frob', but just before the call to `frob', changing the signature of `frob' to just `Foo -> IO Blah'
18:02:51 <ski> right, exactly
18:04:29 <ski> `frob' doesn't (at least currently ?) need the extra power of being passed a callback action, and so, unless the particular interface (or "impedance mismatch" between different non-matching interfaces) is forced on us for some reason, we'd be inclined to do said refactoring
18:05:15 <ski> argent0 : still, if you have an `IO Foo', you have to put the invokation of that *somewhere*, getting a `Foo' out of it
18:05:31 <ski> (which is parallel to putting your `toList' *somewhere*)
18:06:44 <ski> (fwiw, i'd say that `frob act' was referentially transparent in `act', with the original type signature and definition of `frob')
18:06:59 <argent0> I think I see your point now
18:07:44 <ski> i'm sorry if i'm not able to explain it more shortly/clearly
18:08:38 <argent0> ski: the frob example made it clear to me
18:08:52 <ski> ok, good
18:13:43 <coldpress> Solonarv: thanks! I was lost in the type errors given by the compiler
18:19:18 <Welkin> I thought your name was coldplay for a moment
18:19:55 <coldpress> Welkin: Viva la Paradise
19:28:52 <jackdk> does anyone here know how to convert columns in a beam select? I have a column of bytea that I know is text in the rows I'm selecting, so I want to cast it
19:31:09 <iqubic> is there any guide on how to use Parsec's expression parsing features?
19:31:38 <iqubic> I'm trying to parse (pun intended) the contents of this page: https://hackage.haskell.org/package/parsec-3.1.13.0/docs/Text-Parsec-Expr.html
19:32:58 <iqubic> Like I understand how the rest of the library works, more or less, but this part feels like black magic.
19:33:04 <julianleviston> jackdk: I wish the docs showed you the types of each function on mouseover.
19:33:29 <jackdk> which docs?
19:34:02 <iqubic> I'm certain I could write a recursive parser for my Data type on my own, but that seems like a waste of time and effort if there is already built in functionality for that.
19:34:56 <julianleviston> jackdk: I assume you’ve been trying `as`?
19:35:03 <julianleviston> jackdk: these ones? https://tathougies.github.io/beam/user-guide/queries/basic/
19:35:47 <iqubic> I'm honestly surprised that it has taken me like 2 years of haskell development before breeching the subject of parsing. And of course I just had to start with a recursive data type, which just makes everything a lot harder.
19:35:51 <fen> % data A = A (A -> A)
19:35:52 <yahb> fen: 
19:36:06 <fen> % let x = A id
19:36:06 <yahb> fen: 
19:36:21 <fen> is that an infinity category?
19:36:35 <julianleviston> iqubic: why is that?
19:36:45 <jackdk> julianleviston: appreciate the pointer but `as` is `id` with type params reordered so you can use `-XTypeApplications`. I want to generate a call to a conversion function in my sql, I think
19:36:46 <iqubic> I think `A id` is the only way to construct a valid value of A
19:36:59 <fen> is there a space of this kind of thing? or is it forbidden russles paradox?
19:37:08 <julianleviston> jackdk: oh you want to use **SQL** to cast it?
19:37:54 <fen> iqubic: is there an easy way to prove id is the only inhabitant?
19:38:17 <iqubic> julianleviston: I'm not sure why I feel like recursive data types are harder to work with. Perhaps it's because this is my first parser and I'm having trouble seperating the difficulty of writing *A* parser with writing *a recursive* parser
19:38:27 <jackdk> julianleviston: I think so? I have a column that is bytea in the schema, and I know it's actually textual in the rows I'm querying and I want to use LIKE on it.
19:38:33 <julianleviston> iqubic: divide an conquer?
19:38:43 <iqubic> How would that work?
19:38:44 <julianleviston> iqubic: maybe tackle simple parsers and then expand?
19:38:57 <julianleviston> divide and* conquer (sorry, typo)
19:39:17 <iqubic> I see.
19:39:21 <julianleviston> jackdk: ah… so it’s kind of a postgres question?
19:39:41 <julianleviston> iqubic: I was actually curious about why/how if you’d been doing haskell for 2 years you hadn’t encountered parsers before...
19:39:48 <julianleviston> iqubic: not that it’s bad or anything. Just interested :)
19:39:52 <iqubic> I'm trying to write a parser for mathematical expressions and turn it into a data type of this kind: http://dpaste.com/381Y50Z
19:40:39 <julianleviston> Ah ok. An algebra.
19:40:42 <iqubic> julianleviston: I guess I've always felt like parsers were too complex or something. Also, I've never really taken the time to understand how parsers actually work.
19:40:44 <jackdk> julianleviston: postgresith. I know postgres can do the thing I want to do, but I don't know how to generate it with beam. see https://dba.stackexchange.com/questions/130812/query-bytea-column-using-prefix 
19:40:45 <iqubic> julianleviston: Yes.
19:41:07 <fen> there is normally a measure on function spaces, taking 2 functions and returning a real number. but is there a space with measures that return values in that space? so that the measure is like a monoid, or closed algebraic sum?
19:41:15 <julianleviston> iqubic: so, maybe start by writing a parser that parses a simpler value — like say String or Text… first?
19:41:18 <fen> (product)
19:41:21 <iqubic> Because I'm working with an algebra, I wanted to use this: https://hackage.haskell.org/package/parsec-3.1.13.0/docs/Text-Parsec-Expr.html
19:41:54 <julianleviston> or, if you *must* use that, maybe simplify the expression space before going the whole hog — maybe that will make it easier for you to just focus on learning parsing first...
19:41:58 * hackage gtk-sni-tray 0.1.6.0 - A standalone StatusNotifierItem/AppIndicator tray  http://hackage.haskell.org/package/gtk-sni-tray-0.1.6.0 (eyevanmalicesun)
19:42:13 <iqubic> But that documentation looks like a complete pile of spaghetti to me. I'm not saying it's poorly written, just that I can't understand it yet.
19:42:54 <iqubic> julianleviston: I don't have to use that. I'm looking for the easiest thing to do, and that seemed like the easiest. The more I think about it, less simple that looks.
19:43:19 <fen> thought maybe higher order measure spaces might be something category theory can cope with. but it seems like anything self referential invokes an infinity category, so not sure how to write it
19:43:35 <iqubic> I have no idea what a measure space is.
19:43:48 <fen> like Lp
19:43:54 <fen> with a norm
19:44:21 <iqubic> I know a tiny little bit of Catagory Theory, no Group Theory, and no Set Theory.
19:44:47 <julianleviston> iqubic: surely parsing one thing, then parsing two things, then parsing a single space of things, then parsing a recursive space of things a path that’s simpler to understand than going straight to parsing a recursive space of things?
19:44:54 <iqubic> So asking me about this isn't gonna be all that hard.
19:45:04 <iqubic> julianleviston: Yes. I believe that is correct.
19:45:31 <julianleviston> It looks like Text.Parsec.Expr is helper code for people who already have tried to do it manually at least a few times :) Just like going straight to lens before you’ve written your own getters and setters is ridiculous, this might be overkill :)
19:46:22 <julianleviston> that’s my two cents, anyway.
19:47:07 <julianleviston> (sorry, not “ridiculous” but “very difficult by comparison”)
19:47:45 <iqubic> Perhaps what I should start with is just parsing a number. And then work on parsing simple expressions like `BinOp (Const _) (Const _)` where BinOp is one of [Add, Sub, Mul, Div]. And then work my way up from there.
19:48:08 <iqubic> So start with parsing "5.3" and then try parsing "23 / 5"
19:48:53 <julianleviston> jackdk: it seems kind of limited — would you have to do this stuff in a custom?
19:48:58 * hackage taffybar 3.1.1 - A desktop bar similar to xmobar, but with more GUI  http://hackage.haskell.org/package/taffybar-3.1.1 (eyevanmalicesun)
19:49:09 <julianleviston> iqubic: sounds good.
19:49:09 <jackdk> possibly. I might give up and do that
19:49:15 <jackdk> thanks for your help
19:49:18 <fen> % let y = const x
19:49:18 <yahb> fen: 
19:49:29 <fen> thats not id...
19:49:30 <julianleviston> jackdk: well, look at the API… if it doesn’t have what you want, you have to do a custom, don’t you?
19:49:49 <jackdk> probably. I still find it hard to navigate
19:49:57 <iqubic> I feel like the hardest part will be dealing with parens.
19:50:07 <julianleviston> jackdk: I haven’t looked at it.
19:50:36 <iqubic> Like if someone gives me "(5 + 5) * 3" I want the AST to reflect the fact that addition happens first.
19:51:08 <fen> fixity?
19:51:15 <Solonarv> no, parentheses
19:51:31 <iqubic> No, not fixity, but parens.
19:51:46 <coldpress> iqubic: https://wiki.haskell.org/Parsing_a_simple_imperative_language
19:51:48 <julianleviston> iqubic: https://kseo.github.io/posts/2014-01-07-parsing-arithmetic-expressions-with-parsec.html here’s a tutorial by someone who’s doing essentially exactly what you’re doing
19:52:17 <iqubic> And actually, I want "5 + 5 * 3" and "5 + (5 * 3)" to produce identical syntax trees. So yeah, I also want fixity too.
19:52:57 <iqubic> Or precedence. But I think in haskell precedence and fixity are interchangable terms.
19:53:26 <Solonarv> if all your precedences are known at the time you write the parser, dealing with infix operators isn't that hard
19:53:50 <iqubic> Solonarv: Yeah. I know the precedences of all my infix operators.
19:54:04 <ski> fixity is whether it's `infix' (non-associative), `infixl' (left-associative), or `infixr' (right-associative), i'd say
19:54:49 <fen> % data B b = B b (B b -> B b)
19:54:49 <yahb> fen: 
19:54:59 <fen> maybe that has more inhabitants 
19:55:20 <iqubic> I only have a few infix operators anyways. [+, -, *, /, ^] I'm going to make the precedence and associativity the exact same as what a typical mathematician would expect.
19:55:36 <Solonarv> fen: it does, assuming |b| > 1
19:55:59 <iqubic> fen: Do you realize that `B` is now a two argument data constructor?
19:55:59 <fen> why need that?
19:56:52 <Solonarv> |B b| = |b| * |B b|^|B b| -- diverges to +infinity whenever |b| > 1
19:57:11 <fen> iqubic: thats an attempt to have something the function can actually act on, or recognise... like, how to tell different values of type B b apart 
19:57:44 <Solonarv> fen: what are you going for here? a shallow embedding of the untyped lambda calculus?
19:58:15 <fen> i want to study the tangent space.. the flows
19:58:18 <iqubic> See, this is math that I actually understand.
19:58:40 <iqubic> Solonarv: Why is bad to have something that diverges to +infinity?
19:58:46 <fen> under mild conditions there can be a steady-state distribution 
19:59:02 <Solonarv> iqubic: I never said it's bad
19:59:14 <Solonarv> that just means the type has infinitely many inhabitants
19:59:43 <fen> and then the dynamics are understood in terms of the spectra. like the energy has eigenvalue 1
19:59:44 <Solonarv> (which is rather common for recursive types)
19:59:50 <iqubic> Which is certainly more than the 0 we had with `data A = A (A -> A)
20:00:13 <Solonarv> zero? that has at least one inhabitant, 'A id'
20:00:54 <fen> and A const (A id)
20:01:07 <iqubic> Solonarv: Yeah. List is a good example of a recursive data type with an infinite number of inhabitants.
20:01:27 <Solonarv> You can construct others too, such as 'A (\(A f) -> A (f . f))'
20:01:45 <fen> and repeating const gives a strange representation of Nats maybe.. but the fact it cant be examined is a setback. bst to consider B
20:01:47 <iqubic> and A (const (const (A id))) too right?
20:01:59 <Solonarv> I'm not sure whether those are distinguishable, though, so I'm not confident in saying that |A| > 1
20:03:49 <fen> maybe there is a recursive version with a function over the Reals at the lowest level
20:04:06 <iqubic> I don't understand the notation |A|. Isn't that the absolute value function?
20:04:22 <Solonarv> it's also used for "size of a set"
20:04:32 <Solonarv> for example, |{1, 6, 8}| = 3
20:04:48 <Solonarv> here I'm using it as "number of inhabitants of a type"
20:05:04 <iqubic> Because I know absolutely no set theory, I didn't know that.
20:05:15 <Solonarv> heh
20:05:36 * ski . o O ( `[a] = 1 + a * [a]', `[a] - a * [a] = 1', `(1 - a) * [a] = 1', `[a] = 1 / (1 - a) = 1 + a + a^2 + a^3 + a^4 + ...' )
20:05:56 <fen> difficult to have a set with between 0 and 1 inhabitants 
20:05:58 <iqubic> I know a tiny bit of Category theory.
20:06:21 <iqubic> ski: That's just a Taylor expansion.
20:06:45 <iqubic> At that point you get weird things like "/" and "^"
20:06:57 <ski> yes. a list of `a's is either zero `a's, or one `a', or two `a's, or three `a's, or four `a's, or ...
20:07:17 <Solonarv> +*^ are very straightforward in the algebra of types
20:07:35 <Solonarv> -/ aren't, and take some gymnastics which I've mostly forgotten
20:07:58 <iqubic> I know how sum and product types work, but I'm not sure what a quotient type is, or what a difference type are.
20:08:16 <Solonarv> exponentials are functions
20:08:24 <Solonarv> a^b = b -> a
20:08:25 <iqubic> Yeah. I know that.
20:08:27 <fen> well it needs to be a product to cancel a factor
20:08:58 * hackage natural 0.3.0.4 - Natural number  http://hackage.haskell.org/package/natural-0.3.0.4 (qfpl)
20:09:12 <iqubic> but I'm not sure what the exponentials mean in: "[a] = a + a^2 + a^3 + a^4...."
20:09:18 <fen> and it needs to be a sum to be able to subtract something 
20:09:47 <Solonarv> iqubic: you can view 1, 2, 3, 4, ... as the types with that number of inhabitants
20:10:07 <koz_> You can also call them 'Finite 1, Finite 2, etc'. :P
20:10:07 <ski> `a^2' means the Haskell type `(a,a)' (with typical element a pair `(x,y)'). or, if you prefer, `Bool -> a' (with typical element `\b -> if b then y else x')
20:10:12 <iqubic> yeah. A list is isomorphic to `Either [] (a, [a])`
20:10:36 <ski> in more mathy notation, it'd be written `a * a'
20:10:53 <ski> and `a^3' means `a * a * a' (`(a,a,a)' in Haskell notation), &c.
20:10:57 <iqubic> ski: I understand how a^b is like b -> a
20:11:38 <iqubic> but I don't understand what 3 -> a means. "a^3"
20:11:49 <fen> so if you have the space of functions taking and returning real numbers, then there is a difference d(f,g)(x) = f(x) - g(x)
20:11:51 <ski> `3' is some type with three elements, e.g. `Ordering'
20:12:00 <ski> `2' is some type with two elements, e.g. `Bool'
20:12:29 <iqubic> I assume `3 -> a` means you are selecting 1 value from a group with 3 inhabitants.
20:12:38 <fen> d :: (R -> R) -> (R -> R) -> (R -> R)
20:12:39 <iqubic> Like Ordering, for example.
20:12:46 <ski> iqubic : it means we're selecting three values of type `a'
20:12:51 <iqubic> Oh.
20:12:56 <koz_> iqubic: 3 -> a means a function from every element of 3 to some element of a.
20:12:59 <ski> iqubic : one to give, for each possible value of `3' that we can be fed
20:13:18 <iqubic> So you seem to be using "a^3" to mean something other than 3 -> a
20:13:25 <ski> just like `a * a * a' means a type of triples of elements of type `a'
20:13:32 <iqubic> Right. I see.
20:13:49 <ski> they're isomorphic, just like `(a,a)' and `Bool -> a' are
20:13:52 <fen> 3 = Either (Either () ()) () ?
20:13:57 <ski> (ignoring bottoms)
20:13:59 <ski> sure
20:14:02 <Solonarv> that's one way of encoding it, yes
20:14:12 <ski>   Bool = Either () () = Maybe ()
20:14:35 <iqubic> Wait? 3 -> a is isomorphic to (a, a, a)?
20:14:46 <Solonarv> yes, can you see why?
20:14:48 <koz_> iqubic: Yeah.
20:14:52 <iqubic> Then I have no confusion anymore.
20:14:59 <fen> the problem is when instead of trying to take the difference between 2 functions over the reals, the difference between functions over functions is required
20:15:04 <fen> and the higher order varients
20:15:16 <koz_> 3 is also spellable 'These Unit Unit'.
20:15:17 <ski> a typical value of the latter type is `(x,y,z)'. a typical value of the former type is `\o -> case o of LT -> x; EQ -> y; GT -> z'
20:15:41 <koz_> Sorry, 'These () ()' I guess.
20:15:49 <ski> (or `\case LT -> x; EQ -> y; GT -> z', using `LambdaCase')
20:15:53 <iqubic> ski: I worked out something like that in my head. That's what I got.
20:16:19 <fen> right, so the particular value of 3 acts to select one value `a' from the tuple 
20:16:40 <ski> one can define a vector `v' of three components `x',`y',`z' as
20:16:43 <iqubic> koz_: It has been a really long time since I saw mention of These. It's like Either, except you have the possibility of getting both values.
20:16:44 <ski>   v = (x,y,z)
20:16:46 <ski> or as
20:16:49 <ski>   v_0 = x
20:16:52 <ski>   v_1 = y
20:16:56 <ski>   v_2 = z
20:17:25 <ski> the latter can be seen as defining a function `v : {0,1,2} -> |R' (assuming `x',`y',`z' were real numbers, say)
20:17:26 <iqubic> ski: Guess what. I have figured out what's going on here. I am no longer confused at al.
20:17:32 <ski> good
20:17:33 <Solonarv> woohoo!
20:18:19 <fen> in which case it would be possible to use sets instead of functions. like, instead of considering e.g. the real numbers, finite sets could simplify bith the discussion, and the representation
20:18:25 <ski> iqubic : now compute the derivative `d [a] / d a', and interpret it computationally
20:18:44 <iqubic> ski: I don't know how to do that.
20:18:54 <fen> david murfet has the differential of turing machines if that helps
20:19:19 <iqubic> I mean, I know how to do derivatives and such, but I have no eperience with Taylor series.
20:19:24 <fen> daniel*
20:19:40 <iqubic> I'm only in year 1 of Calculus.
20:21:17 <fen> so then maybe there is for example some Free representation using (Bool,Bool) -> Bool
20:21:56 <iqubic> I can think of 8 different functions of that type.
20:22:04 <ski>   d [a] / d a   =   d (1 + a * [a]) / d a   =   d 1 / d a  +  d (a * [a]) / d a  =  0   +   (d a / d a) * [a]  +  a * (d [a] / d a)   =   1 * [a]  +  a * (d [a] / d a)
20:22:14 <fen> or modular Integer groups, but then might as well set n=2
20:22:42 <iqubic> 2 ^ (2 * 2) = 16. Oh, wait... |(Bool, Bool) -> Bool| = 16
20:23:05 <ski> let's call `d [a] / d a', `DList a'. then we have derived `DList a = [a] + a * DList a'. so we can define `data DList a = Base [a] | Step a (DList a)' in Haskell
20:23:41 <fen> is that the level above (Bool = ((),())) -> Bool
20:23:54 <fen> oops, not product, sum
20:24:00 <fen> Bool = Either () ()
20:24:09 <ski> each (finite, total) value of type `DList a' has exactly one `Base' data constructor in its skeleton, so there's exactly one `[a]' at the "end" of it
20:24:47 <fen> hmm, thats not of the same pattern though... it was a product of bools like an uncurried function
20:24:50 <Solonarv> you can think of this as a "list with a hole"
20:25:00 <ski> then, there's some number of `Step's to get there, each having an `a'. we could factor out the `[a]' at the end, leaving zero or more `a's to begin with, then separately a `[a]'
20:25:13 <fen> sounds like spjs differential of a list
20:25:17 <ski> but "zero or more `a's" is just `[a]' again. so `DList a = [a] * [a]'
20:25:25 <Solonarv> fen: of course that's what it is!
20:25:38 <coldpress> anyone knows why cabal's impl condition does not enforce the GHC version?
20:25:42 <Solonarv> fen derived this from differentiating []
20:26:02 <Solonarv> er, s/fen/ski/ - dang three-letter usernames
20:26:18 <ski> as Solonarv mentioned, if you pick any list, and remove one element (remembering the position from where it was removed), you get one list of elements before this "hole", and one list of elements after it
20:27:13 <fen> ah, a "one hole context"
20:27:33 <fen> so what has that got to do with higher order spaces?
20:27:36 <ski> @google derivative one hole context McBride
20:27:38 <lambdabot> http://strictlypositive.org/diff.pdf
20:27:38 <lambdabot> Title: The Derivative of a Regular Type is its Type of One-Hole Contexts
20:28:04 <Solonarv> fen: not much! this discussion sprang from iqubic's questions, not your ramblings ;)
20:28:09 <coldpress>  I need to install a package only if the machine has a minimum GHC version, but the cabal tries to install it anyways: https://pastebin.com/AuiPU8jF
20:28:23 <fen> just thought it might lower the order by one or something
20:28:47 <fen> or however to call this `n' of how far up in the categories it is
20:29:16 <fen> thats why infinity categories seemed relevant 
20:29:45 <fen> Solonarv: what, for parsing algebraic expressions?
20:30:51 <ski> iqubic : "I know how sum and product types work, but I'm not sure what a quotient type is, or what a difference type are." -- it's not clear in general. the surprising thing is that one may perform such a "nonsense" calculation with types, and end up with something computationally intelligible at the end
20:30:58 <fen> is there something like an n-form that might be useful here?
20:31:07 * ski . o O ( "Objects of Categories as Complex Numbers" by Marcelo Fiore,Tom Leinster in 2002-12-30 at <https://arxiv.org/abs/math/0212377> )
20:31:57 <fen> a Co-something
20:31:58 <Solonarv> fen: I used |A| to denote the cardinality of the type A which you mentioned above, and iqubic asked about the | | notation. Cue discussion/explanation of type algebra.
20:32:31 <ski> iqubic : "I know absolutely no set theory" -- that might be considered an advantageous starting-point .. (cf. learning functional programming before imperative programming)
20:33:04 <fen> right, so thats just one measure right? and the normal dot product of L2 is a co-function or functional
20:33:22 <fen> well, partially applied
20:33:37 <fen> <x,>
20:34:30 <fen> and then there is something that would not take 2 objects and cast them down to the reals, but instead, to some lower dimensional space?
20:34:39 <fen> and thats like an n<m form...
20:34:51 <fen> between m dimensional things
20:35:31 <fen> in haskell, it would be returning a function on a type with fewer inhabitants?
20:35:52 <fen> basically just considering homomorphisms here
20:37:00 <fen> differentials are like forms right?
20:37:28 <coldpress> ahhh anyone knows in which cabal version that impl conditionals were introduced?
20:38:19 <fen> an exterior product?
20:38:37 <geekosaur> coldpress, the correct way to do that is to conditionalize it on the associated base version
20:38:53 <geekosaur> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Libraries/VersionHistory
20:39:33 <geekosaur> although impl should be in 1.24 and you really shouldn't run anything earlier than that due to bugs
20:40:16 <coldpress> geekosaur: thanks, I'm stuck with an older version of cabal. How exactly do I conditionalize on base? I see no such test at: https://www.haskell.org/cabal/users-guide/developing-packages.html#conditions
20:40:52 <fen> then the concept of a measure is like |p><p| from quantum mechanics, so that when applied to |p> you get |p><p,p> = |p| |p> and |p> is an eigenfunction with eigenvalue |p| 
20:41:43 <geekosaur> it's somewhat tricky, you use a flag condition and specify the flag as requiring that particular version
20:42:10 <geekosaur> cabal will solve the constraint and enable or disable the flag as appropriate
20:42:23 <geekosaur> lemme find an example
20:43:52 <geekosaur> but really, you're stuck with a cabal older than 1.24?
20:47:51 <geekosaur> actually everything I find uses impl now
20:48:11 <geekosaur> but I'd be surprised if you don't have it, it goes back pretty far
20:48:36 <geekosaur> you would hve much bigger problems than cabal version, I suspect
20:48:49 <geekosaur> like a ghc version that works with it
20:55:01 <fen> basically, if there is a difference between two functions like an L2 norm, (R -> R) -> (R -> R) -> R, it defines an energy of sorts, and some hamilton equations governing the flow which gives a lie algebra with a generator like (a -> a) -> (a ->a)
20:56:51 <fen> so basically, if you can measure the difference between functions, then a set of functions can be evolved over time
20:57:28 <c_wraith> there are other formulations of the same idea:  https://hackage.haskell.org/package/hamilton
20:57:44 <fen> which is good, because normally its not possible to generate functions of type A = A (A -> A)
21:00:58 <fen> c_wraith, hmm, thats slightly different. it has the vectors as R^m. its flowing vector representations, where here its trying to flow functions
21:01:46 <fen> notice the inner product on functions is required, while normally its just dotting vectors
21:04:11 <fen> it has position and momenta coordinates. the momenta are from differentiating the lagrangian, so only the energy and pottential are needed, if V=0 then just the magnitude of the measure on 2 functions is required to obtain the momenta
21:05:58 * hackage nakadi-client 0.7.0.0 - Client library for the Nakadi Event Broker  http://hackage.haskell.org/package/nakadi-client-0.7.0.0 (mtesseract)
21:07:28 * hackage cabal-file-th 0.2.6 - Template Haskell expressions for reading fields from a project's cabal file.  http://hackage.haskell.org/package/cabal-file-th-0.2.6 (NickPartridge)
21:21:44 <pi___> hellllloooo
21:21:49 <pi___> how is everyone
21:22:37 <pi___> stanly died again
21:26:20 <pi___> hiii
21:26:22 <pi___> how are you
21:30:48 <AYEBUDDYBOI> helllloo
21:30:51 <AYEBUDDYBOI> how are you
23:10:59 <coldpress> anyone know alternatives to Text.Parsec's buildExpressionParser? in terms of its ability to parse recursive grammars
23:11:32 <coldpress> i'm specifically looking for an invertible-parsing alternative to buildExpressionParser, so that I don't have to write my own lexer :)
23:33:36 <yoneda> quit
23:45:27 <delYsid> Hmm, any idea how the MonadLogic msplit laws are named?
23:45:51 <delYsid> msplit mzero == pure Nothing
23:46:32 <delYsid> msplit (pure a `mplus` m) == pure (Just (a, m))
23:56:30 <lyxia> I usually name laws after the main operations
23:59:24 <lyxia> msplit-mzero, msplit-mplus  I don't know any standard naming for them.
