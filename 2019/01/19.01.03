00:00:15 <jle`> it's a part of how haskell deals with memory layouting and stuff when compiling
00:00:36 <jle`> a "boxed type" is represented internally as a pointer, so all boxed types have the same machine size
00:00:40 <iqubic> :t (>=>)
00:00:42 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
00:00:43 <pounce> ooh, is it like a box is a thunk?
00:00:52 <jle`> siraben: i do, incidentally :)
00:01:09 <iqubic> Wait?!?! What? I thought that would be a kliesli thing.
00:01:09 <jle`> pounce: not necessarily, because a box type can be a resolved thunk
00:01:22 <iqubic> Do we not use kliesli anymore?
00:01:32 <jle`> iqubic: read on in the book :) it will be explained
00:01:37 <siraben> jle` I'm guessing that helps a lot :)
00:01:40 <jle`> siraben: oh yeah, so for the free category
00:01:41 <siraben> jle` did you read that book?
00:01:46 <jle`> do you understand how [] is the free monoid?
00:01:52 <siraben> No..
00:02:14 <Solonarv> iqubic: we never used Kleisli (the type from Control.Arrow) very much, too much cumbersome wrapping/unwrapping
00:02:22 <iqubic> I see.
00:02:31 <iqubic> :t (>>=)
00:02:33 <lambdabot> Monad m => m a -> (a -> m b) -> m b
00:02:36 <jle`> siraben: oh ah.  um, my whole demonstration was supposed to build off on that one
00:02:47 <jle`> but i guess i'd have to step back, then
00:03:10 <jle`> but the main point is that once you understand how [] is the free monoid, then it isn't a big step to construct the free indexed monoid, in an analgous way
00:03:21 <pounce> :k []
00:03:22 <lambdabot> * -> *
00:03:30 <pounce> :t []
00:03:31 <siraben> Is [] a type or value?
00:03:32 <lambdabot> [a]
00:03:34 <jle`> and because an indexed monoid is just another name for a category, then you have a construction of a free category
00:03:44 <jle`> siraben: it's both, coincidentally
00:03:53 <jle`> it's like writing:
00:03:57 <jle`> @let data Foo = Foo Int
00:03:58 <lambdabot>  Defined.
00:04:17 <jle`> you accidentally define both the type constructor (and type) Foo, and the data constructor (and value) Foo
00:04:32 <iqubic> I do that all the time.
00:04:39 <jle`> a little unfortunate, but luckily both live in different namespaces normally
00:05:58 <jle`> [] itself is actually special syntax in haskell and it's super overloaded
00:06:11 <jle`> [] is:
00:06:15 <jle`> * the list literal denoting the empty list
00:06:31 <jle`> * a concrete constructor/pattern for [a]
00:06:49 <jle`> * the type constructor where `[Int]` is sugar for `[] Int`
00:07:05 <siraben> Is this in a book somewhere?
00:07:30 <jle`> i think most haskell introductions should mention something like this
00:07:37 <pounce> til that `[] Int` is a valid type
00:07:38 <Solonarv> It's in the Haskell report, too
00:07:48 <iqubic> :t [] Int
00:07:50 <lambdabot> error:
00:07:50 <lambdabot>     • Couldn't match expected type ‘t0 -> t’ with actual type ‘[a0]’
00:07:50 <lambdabot>     • The function ‘[]’ is applied to one argument,
00:08:00 <iqubic> :t ([]) Int
00:08:01 <lambdabot> error:
00:08:02 <lambdabot>     • Couldn't match expected type ‘t0 -> t’ with actual type ‘[a0]’
00:08:02 <lambdabot>     • The function ‘[]’ is applied to one argument,
00:08:04 <jle`> :k [] Int
00:08:05 <lambdabot> *
00:08:08 <iqubic> Huh?
00:08:14 <jle`> `[] Int` is a type
00:08:15 <jle`> that has a kind
00:08:17 <iqubic> right.
00:08:20 <jle`>  :t asks for values, and gives types
00:08:28 <iqubic> That still confuses me.
00:08:29 <jle`> so `[] Int` is not a value/term, it's a type
00:08:34 <nshepperd> > 5:[] :: [] Int
00:08:37 <lambdabot>  [5]
00:09:47 <jle`> actually, referring to my super-overloaded statement, haskell tries its best to provide sugar to make sure that []-as-empty-list-literal and []-as-constructor-and-pattern are not something you can distinguish
00:09:56 <siraben> > [] 4
00:09:58 <lambdabot>  error:
00:09:59 <lambdabot>      • Couldn't match expected type ‘Integer -> t’
00:09:59 <lambdabot>                    with actual type ‘[a0]’
00:10:15 <jle`> haskell provides enough sugar to let you essentially treat all list literals as data constructors
00:10:20 <jle`> and patterns
00:10:47 <jle`> siraben: at the term-level, [] is a list literal
00:11:05 <jle`> so `[] 4` would be function application
00:11:17 <jle`> and so a type error, since [] does not have a function type
00:11:42 <pounce> > ():[]::[]()
00:11:44 <lambdabot>  [()]
00:12:18 <Solonarv> @let type (:) f a = f a
00:12:18 <lambdabot>  Parse failed: Illegal test declaration
00:12:23 <larryba> not sure that all this information is how necessary for someone asking if [] is a type or a value... [] is an empty list, [a] is a type, should go long way for a newcomer
00:12:54 <pounce> :t ():[]::[]()
00:12:55 <lambdabot> [()]
00:12:57 <pounce> hehehe
00:12:58 <jle`> lambdabot: yeah, but it becomes important when you talk about higher-kinded typeclasses like Functor
00:13:10 <jle`> er, larryba ^
00:13:59 <jle`> that's why we have a Functor instance for []
00:14:20 <iqubic> I think the term "Theorems for Free" just means that for every category theory theorem you prove, you get a free proof of the dual.
00:14:20 <jle`> where fmap :: (a -> b) -> f a -> f b, so fmap :: (a -> b) -> [] a -> [] b
00:14:41 <jle`> typically 'free theorem' means something different
00:14:43 <iqubic> so [a] is sugar for [] a
00:14:46 <iqubic> oh.
00:14:48 <siraben> iqubic:  and more, for every general theorem you prove you get the mores specific ones for free
00:14:54 <jle`> free theorem'
00:14:56 <iqubic> Oh.
00:15:05 <jle`> 'free theorem' in a technical sense usually means theorems from parametric polymorphism
00:15:09 <iqubic> I see.
00:15:25 <jle`> but that's different than 'theorems for free', which is a natural language thing
00:15:33 <jle`> it can mean whatever you want
00:17:39 <iqubic> so are "[a]" and "[] a" isomorphic?
00:17:49 <jle`> [a] as a type is sugar for [] a
00:18:11 <iqubic> cool
00:18:28 <iqubic> should I now go and refactor all my code to use [] a?
00:18:47 <jle`> siraben: but yeah, re: free categories, try looking up some things about how lists are free monoids in haskell (this is a common topic), and from there, you can generalize to free indexed monoids and get free categories
00:18:47 <iqubic> Or is that a pointless endeavor?
00:18:54 <jle`> iqubic: i mean, if you want to make your code less readable
00:19:05 <jle`> remember that the point of sugar is to help with code readability
00:19:16 <jle`> so eliminating sugar is basically making code less readable on purpose
00:19:48 <iqubic> man... I remember that time 2 years ago when I struggled to write a factorial function in Haskell. Now look where I'm at.
00:20:25 <iqubic> Back then I found it nearly impossible to figure out the difference between "a" and "[a]" as types.
00:20:47 <jle`> we've all come so far :)
00:20:56 <iqubic> Also, I kept wanting to do [1,2,3]:4 back then.
00:21:38 <iqubic> because I saw the case where you have a number and list and : and it made a longer list.
00:22:01 <iqubic> but I was too simple minded to understand that you can't do that. in that way.
00:22:23 <iqubic> anyways now I'm struggling to learn the basics of CT>
00:23:36 <nyc> > let fac (n :: Int) = product [1..n] in map fac [1..9]
00:23:38 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880]
00:24:00 <siraben> jle` I'll read up
00:24:55 <iqubic> Yeah. That's not how I did it.
00:25:01 <iqubic> I did:
00:25:07 <iqubic> fac 0 = 1
00:25:21 <iqubic> fac n = n * fac (n - 2)
00:25:28 <iqubic> -1
00:25:35 <iqubic> but you get the idea
00:32:57 <nyc> Direct recursion seems an odd way to do it.
00:34:23 <siraben> http://www.willamette.edu/~fruehr/haskell/evolution.html
00:37:37 <Solonarv> It's a decent introduction to recursion
00:38:09 <AstralDreams[m]> nyc, why is direct recursion an odd way to do it?
00:38:35 <siraben> Perhaps he wants to use recursion schemes
00:39:56 <nyc> AstralDreams: factorials have ways to avoid thunks etc.
00:40:54 <siraben> iqubic:  linked this after you left: http://www.willamette.edu/~fruehr/haskell/evolution.html
00:41:36 <iqubic> I've seen that.
00:41:54 <iqubic> I just got to the chapter on functors.
00:43:25 <iqubic> Time to completely fry my brain.
00:44:40 <merijn> iqubic: That's the feeling of learning ;)
00:44:52 <iqubic> I know it is.
00:47:59 <iqubic> jle`: Using your analogy of indexed monoids (M i j) you can say that a functor changes the type of M.
00:48:19 <iqubic> Because M is sorta like the category in that case.
00:48:30 <jle`> it changes M, not the type of M, i suppose.
00:48:45 <jle`> iqubic: and yeah, indexed monoid is synonymous with category
00:48:49 <jle`> they're the same thing
00:49:26 <iqubic> Cool.
00:49:41 <iqubic> I'm learning this stuff at a snail's pace.
00:50:04 <iqubic> but yeah. A functor changes what the M does.
00:50:04 <jle`> i don't really think i'd call this a snail's pace
00:50:13 <iqubic> You wouldn't
00:50:17 <jle`> some people take an entire semester to cover what you learned in a day
00:50:41 <iqubic> this is my second time reading this book. I stopped at functors last time. Hopefully I get farther today.
00:50:51 <jle`> iqubic: not what M does; it changes M.  so it'd be like `fmap :: M i j -> N i j`
00:51:03 <iqubic> Oh, right...
00:51:48 <jle`> or reather, fmap :: M i j -> N (F i) (F j)
00:52:22 <jle`> it maps the indices and the constructor
00:52:29 <jle`> the objects and the morphisms
00:53:04 <iqubic> Right. And then you'd hop that the an identity in M turns into an identity in N and that the new morphism still compose properly.
00:53:19 <iqubic> * hope. Not hop
00:53:41 <iqubic> s/an identity/all identities.
00:53:41 <jle`> yeah. to be more specific, composing-then-mapping should be the same as mapping-then-composing
00:53:52 <jle`> f x <> f y = f (x <> y)
00:54:10 <iqubic> Haskell's functor type class has a law which states just that, right?
00:54:26 <iqubic> I think.
00:54:26 <jle`> yeah, fmap f . fmap g = fmap (f . g)
00:54:42 <jle`> but the Functor typeclass is differant than the concept of functor we were talking about here
00:55:33 <jle`> the Functor typeclass abstracts over a specific class of functors -- in particular, endofunctors in Hask
00:56:01 <jle`> the indexed-monoid-homorphism i'm talking about here is a more general notion of functor
00:56:09 <iqubic> Right. In Hask objects are Haskell types and morphism are Haskell functions, right?
00:56:43 <jle`> mhm
00:57:39 <iqubic> :k Maybe
00:57:40 <lambdabot> * -> *
00:57:53 <iqubic> type constructors have kinds.
00:58:19 <jle`> yes
00:58:57 <iqubic> I was mainly stating that for my own benefit.
01:00:42 <iqubic> id . fmap = fmap . id
01:00:46 <iqubic> right?!?!
01:00:52 <iqubic> Is that correct?
01:01:44 <iqubic> I just realized that I have spent the last 3 hours reading about CT and it is now 1:00 here.
01:01:52 <iqubic> It is early morning here.
01:02:22 <[exa]> iqubic: anything piped through id stays the same, no matter from which side
01:02:48 <jle`> iqubic: f . id = f, and id . f = f, so it doesn't matter if you're fmapping or not
01:03:05 <iqubic> Oh, right.
01:03:27 <jle`> but maybe you mean to say id . fmap f = fmap f.  that's still true, but it's more interesting in this context
01:03:28 <[exa]> perhaps you wanted 'fmap id' which is a bit more interesting
01:03:42 <jle`> because id . fmap f = fmap id . fmap f = fmap (id . f) = fmap f
01:04:31 <jle`> so if you start from fmap id . fmap f, you can go fmap id . fmap f = id . fmap f = fmap f
01:04:38 <jle`> or you can go fmap id . fmap f = fmap (id . f) = fmap f
01:05:04 <jle`> two different ways of getting `fmap id . fmap f ==> fmap f`
01:05:34 <merijn> Something, something, free theorem
01:12:33 <iqubic> I love how this book shows programming examples in Haskell and in C++. The C++ examples are always really bloated and full of cruft.
01:26:32 <iqubic> So, what are bifunctors good for?
01:26:56 <merijn> iqubic: Ever wanted to apply a function to the first element in a tuple?
01:27:03 <iqubic> Yes.
01:27:07 <iqubic> Yes I have.
01:27:07 <merijn> iqubic: Or to all "Left" elements in a list?
01:27:13 <iqubic> Yes.
01:27:14 <merijn> iqubic: There you go :p
01:27:20 <merijn> :t first
01:27:21 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
01:27:24 <merijn> bah, wrong one
01:27:31 <merijn> :t Data.Bifunctor.first
01:27:32 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
01:27:45 <iqubic> now, time to learn what Category theory says about bifunctors.
01:27:46 <merijn> :t Data.Bifunctor.first even (1, 'c')
01:27:48 <lambdabot> (Bool, Char)
01:27:52 <merijn> > Data.Bifunctor.first even (1, 'c')
01:27:54 <lambdabot>  error:
01:27:54 <lambdabot>      Not in scope: ‘Data.Bifunctor.first’
01:27:54 <lambdabot>      No module named ‘Data.Bifunctor’ is imported.
01:28:20 <iqubic> @let import Data.Bifunctor
01:28:22 <lambdabot>  Defined.
01:28:30 <iqubic> > Data.Bifunctor.first even (1, 'c')
01:28:32 <lambdabot>  (False,'c')
01:28:37 <iqubic> There we go.
01:28:47 <merijn> iqubic: Basically just Bifunctor just generalises Functor to two type variables
01:28:55 <merijn> And instead of
01:28:57 <merijn> :t fmap
01:28:58 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:29:00 <merijn> You have
01:29:05 <merijn> :t Data.Bifunctor.first
01:29:06 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
01:29:09 <merijn> :t Data.Bifunctor.second
01:29:10 <lambdabot> Bifunctor p => (b -> c) -> p a b -> p a c
01:29:17 <merijn> And/or
01:29:19 <iqubic> I'm not sure how category theory handles this.
01:29:22 <merijn> :t Data.Bifunctor.bimap
01:29:23 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
01:36:01 <phadej> CT says that bifunctor is functor from C * C to C
01:38:10 <phadej> (all three can be different)
01:41:05 <phadej> ... i.e. there not much to learn than what Bifunctor docs say
01:42:17 <merijn> Any optparse users that can help me figure out how I can hide a single command from the help output?
01:43:28 <iqubic> :t fmap
01:43:29 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:45:21 <phadej> merijn: `hidden :: Mod f a` doesn't work?
01:45:22 <Boomerang> merijn: optparse-applicative has `internal`: https://hackage.haskell.org/package/optparse-applicative-0.14.3.0/docs/Options-Applicative.html#v:internal
01:45:34 <phadej> or internal
01:46:27 <merijn> phadej: Yeah, but it accidentally hid all subcommands. I think I need to make a separate subparser and use <|>
01:48:46 <phadej> commandGroup might help too.
01:49:03 <phadej> ar least its docs imply so
01:52:02 <merijn> phadej: That's about hiding entire groups of commands
01:52:37 <phadej> which can consist of one...
01:52:50 <merijn> phadej: Sure, but then I might as well just hide the one command :)
02:09:47 <aplainzetakind> what do I use to obtain a list of the files in a directory?
02:10:15 <reactormonk> aplainzetakind, https://www.stackage.org/lts-13.1/hoogle?q=FilePath%20-%3E%20IO%20%5BFilePath%5D
02:10:39 <larryba> :t listDirectory 
02:10:40 <lambdabot> error: Variable not in scope: listDirectory
02:11:10 <reactormonk> I don't think there's a very nice typed representation of paths
02:12:38 --- mode: glguy set +v Flyers
02:13:13 <merijn> there is one, but it's not very common yet, I think
02:13:34 <merijn> reactormonk: https://hackage.haskell.org/package/path-0.6.1/docs/Path.html
02:14:14 <aplainzetakind> reactormonk, merijn thanks.
02:15:19 --- mode: glguy set -v Flyers
02:18:48 <merijn> I'm confused...https://hackage.haskell.org/package/conduit-1.3.1/docs/Data-Conduit-Combinators.html#v:sinkFileBS implies sinkFileBS is different from sinkFile, but...it isn't?
02:20:34 --- mode: glguy set +v autoint
02:20:59 <lyxia> they look the same to me too
02:21:28 <mtesseract> merijn: From looking at the source it seems that the one ByteString is strict and the other one is lazy.
02:21:48 <mtesseract> But, the comment seems misleading to me.
02:22:46 <reactormonk> mtesseract, nope, they link to the same type
02:23:25 <mtesseract> sinkFileBS :: MonadResource m => FilePath -> ConduitT ByteString o m ()
02:23:27 <mtesseract> sinkFile :: MonadResource m
02:23:27 <mtesseract>          => FilePath
02:23:28 <mtesseract>          -> ConduitT S.ByteString o m ()
02:23:38 <mtesseract> import qualified Data.ByteString as S
02:24:03 <mtesseract> Woops, you are right
02:24:22 <reactormonk> I was lazy and just clicked on the type link on haddock :D
02:24:59 <mtesseract> Then the source is as confusing as the comment, when S.ByteString is used and ByteString is used and they are actually the same.
02:26:00 <autoint> Does anyone know  how to write the Persistent Splay
02:27:12 <kuribas> why does monad requires ap = <*> ?
02:27:35 <[exa]> autoint: how does the persistent version differ from normal splay tree btw?
02:27:39 <kuribas> <*> has the same type, but it has opportunities to be more specific.
02:27:48 <kuribas> For example calculate in parallel.
02:27:49 <merijn> kuribas: Human sanity's sake
02:28:24 <autoint> it can use the historical versions
02:28:30 <kuribas> merijn: what if you want monad *and* a parallel <*> ?
02:28:31 <[exa]> kuribas: wild guess- I thought `ap` is from Apply? (ie. doesn't imply that `pure` exists)
02:29:13 <merijn> kuribas: You can ask Simon Marlow why he decided against doing that for Async
02:29:17 <merijn> [exa]: ap is Monad
02:29:18 <merijn> :t ap
02:29:19 <lambdabot> Monad m => m (a -> b) -> m a -> m b
02:29:28 * [exa] surprised
02:30:34 <autoint> [exa] : And I want to know whether the Persistent Splay can be written without using functional Treap
02:30:35 <lyxia> Also "=" in laws is not that well defined.
02:30:42 <kuribas> [exa]: programmed to much purescript?
02:31:06 <[exa]> kuribas: no, I said it was _wild_ guess :]
02:31:43 <[exa]> autoint: so basically the usual functional implementation is persistent?
02:32:07 <[exa]> autoint: (btw how treap is related?)
02:32:58 <autoint> the treap can be used to realize it
02:33:50 <kuribas> IMO ap should be <*>
02:34:10 <kuribas> -- Since many Applicative instances define (<*>) = ap, we
02:34:10 <kuribas> -- cannot define ap = (<*>)
02:34:11 <lyxia> Feel free to define an abstract custom monad and decide that "=" means an observational equivalence that doesn't distinguish parallelism, so a parallel (<*>) would not contradict (<*>) = ap.
02:35:15 <lyxia> but you have to deal with the consequences if your program ever observes more than you thought.
02:35:18 <autoint> [exa] : well,the functional implementation can be easily improved to be persistent
02:35:49 <autoint> [exa] : do you know how to write functional splay
02:36:08 <kuribas> lyxia: I was thinking about collecting error messages for example.
02:36:17 <kuribas> lyxia: instead of halting at the first one.
02:37:54 <kuribas> lyxia: I see nothing in the laws that contradicts it.
02:38:45 <kuribas> but "ap m1 m2          = do { x1 <- m1; x2 <- m2; return (x1 x2) }" introduces a dependency that's not necessary.
02:38:54 <autoint> [exa]: so can the splay be implemented functionaly
02:39:24 <[exa]> autoint: ofcourse
02:39:37 <lyxia> kuribas: you can't define an error-collecting (>>=)
02:39:44 <autoint> [exa]: how
02:39:46 <kuribas> lyxia: that's my point
02:39:47 <[exa]> autoint: moreover I guess that the most basic functional implementation is already persistent
02:39:53 <[exa]> autoint: well just by coding it? :]
02:40:01 <lyxia> kuribas: that's exactly how the laws prevent you from doing that.
02:40:13 <kuribas> lyxia: I don't see that.
02:40:22 <autoint> [exa]: please use the paste or something else to show me
02:40:29 <kuribas> lyxia: ap could be defined in terms of <*> instead of >>=
02:40:47 <kuribas> lyxia: without breaking monad laws as far as I can see.
02:41:42 <lyxia> kuribas: "ap" is a shorthand for "the implementation of (<*>) you would get by default with Monad"
02:41:49 <[exa]> autoint: well you should understand that I'm not going to make the program for you.. do you have some kind of preliminary evrsion?
02:41:59 <[exa]> autoint: btw I guess there should be some implementation already on the internet
02:42:06 <lyxia> the whole point of ap is to be defined in terms of the Monad class.
02:42:09 <kuribas> lyxia: so?
02:42:17 <kuribas> lyxia: that's a broken definition.
02:42:28 <kuribas> lyxia: it weakens the implementation
02:43:02 <autoint> [exa]: interesting,there is nothing about that in our country
02:43:17 <kuribas> lyxia: or alternatively, the law <*> = ap shouldn't hold
02:43:20 <[exa]> cross the borders using internets :]
02:44:40 <lyxia> kuribas: I still think you're taking "=" too literally
02:44:41 <autoint> [exa]: so what is the website,give me the name
02:45:52 <kuribas> lyxia: if one version collects the errors, the other one returns the first, I'd say they are quite different.
02:47:17 <lyxia> ok maybe you're not.
02:47:43 <[exa]> autoint: google?
02:49:57 <kuribas> lyxia: I could also ignore the law ...
02:50:30 <autoint> [exa]: you are right,but limited to my English level, it may take a while to find some really useful information
02:51:01 <lyxia> Why not give the error-collecting operator another name
02:51:33 <lyxia> or use a newtype if you want to use Applicative combinators
02:52:36 <[exa]> autoint: first google: https://stackoverflow.com/questions/2861817/how-can-i-implement-a-splay-tree-that-performs-the-zig-operation-last-not-first
02:53:22 <larryba> why is there no Maybe instance for MonadCatch, but there is one for MonadThrow?
02:53:54 <[exa]> larryba: there's not much information to "catch" from Maybe, right?
02:54:27 <autoint> [exa]: thanks
02:54:28 <larryba> [exa], you might be right
02:55:19 <kuribas> lyxia: that's possible.  It's still a work around a broken implementation IMO.
02:55:22 <larryba> yep, you're right. we can catch from Either SomeException Data, but not from Maybe Data
02:55:45 <kuribas> lyxia: but "fixing" it would break existing code.
02:56:14 <lyxia> would you also argue that Semigroup should not be a superclass of Monoid
02:56:30 <kuribas> lyxia: me?
02:56:36 <lyxia> yes
02:56:36 <kuribas> lyxia: no, why?
02:56:54 <lyxia> Just curious.
02:57:02 <lyxia> I think it's a similar situation to this.
02:57:03 <kuribas> I don't see how they are related
02:57:21 <lyxia> Or (Semigroup.<>) = Monoid.mappend
02:57:39 <kuribas> lyxia: yeah, that's the wrong way around.
02:57:52 <kuribas> lyxia: just like in Monad
02:59:20 <lyxia> so Semigroup as a superclass of Monoid is OK, but (Semigroup.<>) = Monoid.mappend is not?
02:59:37 <lyxia> I'm just trying to understand your point of view better.
02:59:39 <kuribas> it should be Monoid.mappend = (Semigroup.<>)
02:59:48 <merijn> kuribas: Why?
03:00:07 <merijn> Semantically, those two statements are the same and pragmatically the former is better
03:00:34 <kuribas> well, in this case it probably doesn't matter
03:00:59 <lyxia> Equality is symmetric
03:01:10 <kuribas> mappend is redundant anyway
03:02:08 <kuribas> hehe it even says so in the docs.
03:02:12 <kuribas> it shouldn't be there
03:03:06 <kuribas> lyxia: and fact that's how it is even defined: http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#mappend
03:06:15 <lyxia> OK this seems a poor comparison.
03:06:41 <lyxia> but I don't think ap = (<*>) makes Applicative broken.
03:06:53 <kuribas> lyxia: I don't think either
03:07:21 <kuribas> lyxia: I think ap m1 m2 = do { x1 <- m1; x2 <- m2; return (x1 x2) } breaks applicative
03:08:03 <lyxia> how would you defined "ap" otherwise
03:08:41 <kuribas> lyxia: ap = (<*>)
03:08:52 <lyxia> I mean, to me "ap = (<*>)" is literally a shorthand for "do {...} = (<*>)"
03:09:26 <kuribas> lyxia: do {..} introduces a dependency of m2 on x1 that isn't there.
03:09:40 <lyxia> so if you have a problem with the definition of ap, you have a problem with the law
03:09:49 <kuribas> lyxia: that's right
03:11:10 <kuribas> lyxia: you're getting my point :)
03:11:30 <lyxia> Reluctantly.
03:18:43 <kuribas> lyxia: At least I'd like to know a good reason for having <*> = ap, other than that's what people expect.
03:19:22 <kuribas> The idea of Monad is to have a dependency of the computation on the result of the computation, while applicative doesn't.
03:19:33 <kuribas> So it makes sense for <*> to not be introduced in terms of >>=
03:23:01 <lyxia> it means we can freely mix applicative and monadic styles without thinking about whether our particular monad satisfies that law, because they all do.
03:23:51 <lyxia> we don't need to have monadic versions of applicative combinators
03:24:24 <lyxia> so we don't need to explain the difference to newcomers because they're all the same.
03:26:00 <larryba> especially now when Applicative is a superclass of Monad
03:26:39 <kuribas> lyxia: there is applicative do if you prefer do notation
03:26:53 <lyxia> too bad, I prefer applicative notation
03:27:34 <Philonous> Is there a fast way to marshal Text to UTF8-encoded, 0-terminated C strings? Going via ByteStrings works and is probably good enough for my case but it copies the data twice instead of once. 
03:30:02 <Philonous> Never mind, the marshalling functions in Data.Text.Foreign use ByteStrings as well
03:30:39 <Adeon> encodeUtf8 + unsafeUseAsCStringLen I think should only make one copy
03:30:51 <Philonous> Yes, thanks 
03:31:05 <Adeon> ah, that won't be guaranteed to be null-terminated though
03:31:18 <lyxia> kuribas: and ApplicativeDo would be highly dangerous without those laws.
03:32:15 <Philonous> Adeon, Well, at least IU can use unsafePackCString for one less copy in that direction 
03:32:19 <Philonous> It'll be good enough
03:39:28 <larryba> how can I omit "(line 1, column 5): unexpected end of input" from Parsec's ParseError? this doesn't make much sense when I am parsing a single line typed by the user 
04:07:54 --- mode: glguy set +v mreh
04:08:12 --- mode: glguy set -v mreh
04:20:52 * hackage type-map 0.1.6.0 - Type-indexed maps  http://hackage.haskell.org/package/type-map-0.1.6.0 (lyxia)
04:23:16 --- mode: glguy set +v loopspace
04:31:57 <ggerman> Hi
04:32:00 <ggerman> nice to meet you
04:33:37 <ggerman> Hello, I want to ask you wich is the main field of haskell
04:40:26 <earthy> "avoid 'success at all costs'"?
04:40:52 * hackage halma 0.3.0.1 - Library implementing Halma rules  http://hackage.haskell.org/package/halma-0.3.0.1 (TimBaumann)
04:41:05 <hpc> it's a general purpose language
04:41:11 <kuribas> ggerman: it's an academic language with no practical use
04:41:25 <hpc> you could write a web server, you could reimplement quake, or you could invent zygohistomorphic prepromorphisms
04:41:39 <kuribas> the main purpose is to see how you can implement category theory in a computer language
04:43:35 <kuribas> ggerman: any practical applications are completely accidental.
04:43:47 <kuribas> it's also supposed to annoy other programmers
04:43:54 <hpc> wut
04:45:50 <kuribas> ggerman: don't let anyone believe they actually run a webserver in haskell, it's python under the hood.
04:45:53 * hackage halma-gui 0.1.1.1 - GTK application for playing Halma  http://hackage.haskell.org/package/halma-gui-0.1.1.1 (TimBaumann)
04:46:28 <kuribas> In fact it's an elaborate hoax
04:46:47 <hpc> so elaborate, this channel doesn't even exist
04:46:54 <hpc> we're all just a figment of kuribas' imagination
04:46:56 <hpc> including you
04:47:55 <kuribas> haha
04:48:21 <merijn> I wish GHC had a way to warn about unnecessary extensions in files
04:49:33 <hpc> that would be neat
04:52:28 <kuribas> merijn: +1
04:52:50 <kuribas> doesn't it already sometimes?
04:53:06 <merijn> It warns for missing ones, not redundant ones
04:53:25 <hpc> well, it errors for missing ones :P
04:56:28 <c50a326> at the Typeclassopedia https://wiki.haskell.org/Typeclassopedia#Foldable it says that one only need define foldMap or foldr. I'm trying to find the foldMap or foldr definition for [] in the sources. foldl is defined in terms of foldr here http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.List.html foldr1 is defined, but not foldr?
04:58:18 <c50a326> in Data.Foldable it's got `foldr = List.foldr`, where List is GHC.List
04:58:20 <hpc> http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html
04:58:27 <lyxia> c50a326: http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#foldr
04:58:31 <hpc> oh, you already got that far
04:58:38 <hpc> yeah, that's it
04:58:40 <lyxia> c50a326: click on "foldr" at the top of GHC.List, it takes you to GHC.Base
04:59:05 <c50a326> oh you can click in the sources, cool, thanks
05:02:45 <kuribas> merijn: I remember a not used warning for some extension.  I cannot remember which though.
05:06:23 * hackage cabal-debian 4.38.4 - Create a Debianization for a Cabal package  http://hackage.haskell.org/package/cabal-debian-4.38.4 (DavidFox)
05:07:17 <merijn> @hoogle asum
05:07:17 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
05:07:17 <lambdabot> Data.Conduit.Combinators asum :: (Monad m, Alternative f) => Consumer (f a) m (f a)
05:07:17 <lambdabot> CorePrelude asum :: (Foldable t, Alternative f) => t (f a) -> f a
05:14:23 * hackage eventsource-api 1.5.1 - Provides an eventsourcing high level API.  http://hackage.haskell.org/package/eventsource-api-1.5.1 (YorickLaupa)
05:15:53 * hackage eventsource-geteventstore-store 1.2.1 - GetEventStore store implementation.  http://hackage.haskell.org/package/eventsource-geteventstore-store-1.2.1 (YorickLaupa)
05:21:14 <trcc> I have an .hsc file in my haskell project, that I use to generate some FFI stuff. When I run cabal new-build it cannot find the file added as #include within the hsc file. However, I would like cabal to ignore the hsc file entirely. Does cabal have a sort of ignroe list?
05:22:45 <hvr> trcc: is that .hsc file metioned in the cabal file?
05:23:07 <trcc> hvr: not specifically, but I have hs-source-dirs specifiying a folder, where the hsc file is located within
05:29:34 <hvr> ok, but that sounds like you either mentioned the name of that .hsc module in your exposed/other-modules, *or* you `import`ed it 
05:29:53 * hackage htssets 0.2.0.0 - Heterogenous Sets  http://hackage.haskell.org/package/htssets-0.2.0.0 (kelemzol)
05:30:06 <hvr> otherwise ghc wouldn't "see" it
05:30:33 <trcc> hvr well the hsc module should be turned into an hs module
05:30:43 <trcc> so the module definition in the hsc module is captured by cabal
05:30:52 <trcc> but it cannot find the corresponding h file, that the hsc file requires
05:33:30 <hvr> can't you either name the .hsc module different or place it into a different folder?
05:33:55 <trcc> cabal states that it is supported, so I would like to make it work
05:34:16 <hvr> ok, but what cabal does is, it sees you have a .hsc file , and now it will invoke hsc2hs on it
05:34:25 <hvr> *if* you requested the module name
05:34:50 <hvr> is your code public somewhere? it's maybe easier to look at the actual code
05:54:36 <Bish> haskelleers! what is your method to copy paste from tty without mouse
05:54:47 <Bish> i feel like this is the right place to ask, because basicially everyone here is crazy
05:55:40 <[exa]> Bish: from tty you mean plain tty of what system?
05:56:34 <Bish> no, emulators also
05:56:35 <[exa]> anyway, decent terminal emulators have keyboard shortcuts for that, and even in plain system console you can use eg tmux to get some sort of clipboard
05:56:50 <Bish> i know of tmux has something like that, but really that sucks
05:57:05 <Bish> what is a good terminal emulator?
05:57:08 <Boomerang> tmux works pretty well for that
05:57:18 <Bish> Boomerang: cumbersome if you ask me
05:57:31 <yushyin> and so is tty in usual
05:57:32 <Bish> should be way faster like it works with vim
05:57:51 <Bish> yushyin: wouldn't say that, i mean vim does it great, doesn't it
05:57:55 <Boomerang> You can get vim binding for the tmux copy mode
05:58:00 <Bish> or emacs that is(although using ctrl for that is crazy)
05:58:40 <larryba> spacemacs
05:58:58 <Bish> Boomerang: yeah well, will force me to save my dotfiles i guess
05:59:24 <Boomerang> But the default in tmux is <prefix>+[ to go to copy mode, space to start selection, enter to copy and then <prefix>+] to paste
05:59:45 <Bish> yeah feels incredible complicated if ask me
05:59:48 <Bish> i will try right now
06:00:27 <Bish> sure it's space to start?
06:01:23 <Putonlalla> With Vim keys enabled it's v to start, Bish.
06:01:49 <Bish> neither works for me :/
06:03:38 <Boomerang> Bish are you moving in copy mode to get your selection? h/j/k/l, and maybe arrows too
06:03:45 --- mode: glguy set +v nevde
06:04:16 <Bish> Boomerang: yes
06:04:42 <Boomerang> Also I think in default copy-mode (no vim bindings) v toggles between block selection and "normal" selection.
06:05:01 <Bish> bleh
06:05:54 <nevde> Hi everyone. Why can't I do stuff like "[1,2,3] !! length [1,2,3]" in Haskell? Each function functions well enough on its own, but when chained the 'index is' suddenly 'too large' for the compiler, which kind of seems like bs tbh
06:06:17 <mnoonan> :t length
06:06:18 <lambdabot> Foldable t => t a -> Int
06:06:20 <mnoonan> :t (!!)
06:06:22 <lambdabot> [a] -> Int -> a
06:06:28 <Bish> nevde: well, length is 3, isn't it?
06:06:32 <Boomerang> Bish are you trying to copy/paste from/to outside the tty? The tmux clipboard is separate from the X environment
06:06:48 <nevde> it is, but not according to the compiler, it's "too large" for it
06:06:49 <Bish> nevde: the "index" of the element "3" is 2, not 3
06:07:02 <Bish> nevde: yeah, because you're accessing the 4th element of a 3 element list
06:07:13 <nevde> ohh!
06:07:24 <larryba> > [1,2,3] !! length [1,2,3]
06:07:26 <lambdabot>  *Exception: Prelude.!!: index too large
06:07:29 <nevde> wait Haskell is not 0-indexed?
06:07:36 <larryba> > [1,2,3] !! (length [1,2,3] - 1)
06:07:37 <lambdabot>  3
06:07:38 <mnoonan> it *is* 0-indexed, that's your problem :)
06:07:39 <nevde> oh it is... maybe the other way around
06:07:40 <merijn> nevde: Sure it is
06:07:42 <nevde> i'm confused
06:07:51 <Bish> or you just do last [1,2,3]
06:08:01 <mnoonan> [1,2,3,4] !! length [1,2,3]
06:08:05 <mnoonan> > [1,2,3,4] !! length [1,2,3]
06:08:05 <reactormonk> nevde, I've never written code that uses `!!` - what are you writing exactly?
06:08:07 <lambdabot>  4
06:08:09 <merijn> nevde: Using !! with a list is generally a bad sign anyway
06:08:19 <merijn> nevde: What are you trying/wanting to do?
06:08:42 <nevde> [1,2,3,4] !! (length [1,2,3,4] - 1)
06:08:43 <nevde> i see
06:08:46 <nevde> it's all good now
06:08:58 <larryba> > last [1..4]
06:08:59 <nevde> yeah it's an index issue
06:09:00 <lambdabot>  4
06:09:03 <nevde> thank you so much
06:09:17 <julianleviston> as merijn points out, indexing into a list is a bad idea, generally.
06:09:18 <nevde> i'm kind of trying to reinvent the wheel larryba
06:09:21 <nevde> can't use last
06:09:21 <pong> insert caterpillar picture
06:09:30 <mnoonan> nevde, but also consider what merijn is asking ^, I don't think I've ever actually used (!!) in production code.
06:09:33 <nevde> it's some exercise
06:09:38 <pong> ohhh
06:09:46 <Bish> nevde: so... write your own last
06:09:54 <larryba> nevde, then don't use !! either, reinvent it from scratch.
06:10:02 <Bish> im guessing that's why you want to do
06:10:02 <pong> > last []
06:10:03 <nevde> exactly what I'm trying to do but i'm allowed to use the other functions
06:10:04 <lambdabot>  *Exception: Prelude.last: empty list
06:10:08 <nevde> just not last iself obviously
06:10:13 <reactormonk> nevde, just write some recursive function
06:10:33 <nevde> yeah that would be an ever better exercise
06:10:37 <pong> nevde: so define it yourself
06:10:41 <mnoonan> nevde: also consider that you're traversing the list twice here (length is O(n))
06:10:57 <pong> what's last of a singleton? last [x]
06:10:59 <nevde> good point!
06:11:07 <nevde> about complexity
06:11:30 <[exa]> nevde: last == foldr1 (const id)
06:12:30 <Bish> using pattern matching for the tail to be empty
06:12:32 <Bish> genius
06:12:49 * Bish google'd the last functions implementation
06:12:54 * Bish used an if instead
06:13:03 <reactormonk> [exa], nice
06:13:03 <[exa]> nevde: (decoding that to recursive code should serve as a better exercise than just "don't use last" :] )
06:13:04 <julianleviston> an if?
06:13:13 <Bish> julianleviston: if tail == []
06:13:21 <julianleviston> foldr is constructor repalcmeent on list.
06:13:36 <julianleviston> Bish: ah… not super haskellish
06:13:42 <Bish> julianleviston: still new :)
06:13:56 <[exa]> Bish: prolog on you! :D
06:14:53 <Bish> when having prolog in uni i remember it had something really cool, but i don't know what it was
06:14:56 <Bish> :/
06:15:46 <[exa]> reactormonk: can't decide between (const id) and (flip const)
06:15:47 <nevde> [exa] : i agree, i will try!
06:15:48 <Bish> when solving that with pattern matching it's weird you have to care about the order
06:16:11 <julianleviston> Bish: why is it weird?
06:16:12 <Bish> guess it makes sense if 2 pattern match
06:16:23 <julianleviston> Bish: how else will the compiler know which match to use?
06:16:25 <Bish> you'll have to have 1 that is stronger
06:16:26 <Bish> yep
06:16:27 <[exa]> it sometimes surprises the logicians that they're sitting at a computer
06:18:22 <ggole> It's possible to compile patterns according to specificity rather than textual order
06:18:33 <ggole> But that's not how most pattern matching facilities work.
06:22:51 <merijn> Also, much harder for programmers to understand what's going on
06:23:19 <[exa]> ggole: there are quite strong conditions (almost totality) that are required to reason about pattern reordering. But afaik GHC does that a bit
06:26:02 <ggole> [exa]: I'm talking about different semantics for pattern matching. My point is simply that the ones used in Haskell, ML, etc are not the only possible choice.
06:26:04 <kuribas> [exa]: \x y -> y
06:26:22 <[exa]> kuribas: but the variables...! :D
06:26:33 <kuribas> \_ x -> x
06:26:43 <kuribas> \_ foo1 -> foo1
06:26:54 <[exa]> '\_ -> id' probably
06:27:17 <kuribas> naming strategy: foo<n>, where n is an ascending number
06:27:30 <[exa]> :]
06:27:43 <[exa]> ggole: oh so, I misunderstood that :]
06:28:40 <ggole> Yeah, I was really aiming at answering <julianleviston> Bish: how else will the compiler know which match to use?
06:28:53 <ggole> My fault for not making that clear.
06:29:02 <julianleviston> the compiler would know by not being itself ;-)
06:29:20 <merijn> kuribas: You joke, but that's how a lot of my code starts
06:29:28 <julianleviston> but yeah, fair point. “there are other ways to pattern match”
06:29:41 <merijn> kuribas: I only name them something more understandable once they're starting to kinda shape up
06:34:04 <Solonarv> [exa]: use a bit of template haskell to randomly choose between 'const id' and 'flip const'. Now you can consistently write '$tsnoc' everywhere!
06:38:46 <hyperisco> is there an algebraic structure which describes no less than the reals?
06:40:06 <[exa]> hyperisco: field with suprema/infima closed on infinite sets?
06:40:17 <hyperisco> yeah sure
06:40:57 <[exa]> Solonarv: oh I forgot about snoc. good.
06:41:07 <Solonarv> no, no - tsnoc
06:42:08 <julianleviston> hyperisco: have you heard of “Cauchy sequences”?
06:42:23 --- mode: glguy set +v mreh
06:42:24 <hyperisco> rings a bell
06:42:35 <julianleviston> I know nothing about them… http://hackage.haskell.org/package/aern2-real-0.1.1.0/docs/AERN2-Real.html
06:42:53 <hyperisco> there are different ways to characterise the reals
06:43:00 <Bish> (iterate flip (+) !! 100000000000000000) 1 1 why doesn't haskell make this quick :p
06:43:06 <Bish> obvious troll question
06:43:08 <hyperisco> I am wondering if there is a popular view from abstract algebra
06:43:40 <mreh> I wonder if the issue described here is why ghcid isn't interrupted when I shut down my docker container  https://github.com/superduper/wai-handler-devel/blob/master/Network/Wai/Handler/DevelServer.hs#L52
06:44:30 <hyperisco> or from another vantage: if we had multiple implementations of real numbers, what type class would we unify them under?
06:45:39 <Solonarv> % let tsnoc = TH.runIO randomIO >>= bool [e| flip const |] [e| const id |]
06:45:39 <yahb> Solonarv: 
06:45:52 <Solonarv> % $tsnoc 3 4
06:45:52 <yahb> Solonarv: 4
06:46:15 <Solonarv> [exa]: ^
06:48:46 <Solonarv> hyperisco: wikipedia says the standard definition is: ordered field + every non-empty subset with an upper bound has a least upper bound
06:50:12 <hyperisco> with a type class we'd like to witness that property with some operation
06:51:14 <Solonarv> The issue there is: how to encode arbitrary subsets of the reals?
06:51:28 <Solonarv> Clearly Data.Set.Set won't do
06:51:41 <hyperisco> n → Bool
06:51:57 <Solonarv> Fair enough, but then how do you work with that?
06:52:04 <julianleviston> I always thought a predicate *was* a Set.
06:52:17 <julianleviston> at least, was isomorphic to Set.
06:52:24 <Solonarv> That is correct.
06:52:38 <hyperisco> I don't know, but the principle remains
06:52:41 <Solonarv> But in Haskell that's not necessarily a very useful encoding
06:52:47 <julianleviston> yeah. useful in math :)
06:53:40 <hyperisco> we may need a more computational description of the reals
06:54:38 <julianleviston> I just saw there was a brisbane haskell group discussion about representation fo reals in Haskell…. wonder if you’d be interested in that.
06:55:01 <julianleviston> I guess it depends what you want to do with them :) 
06:55:11 <Solonarv> You could do something like 'class Ord r => DedekindComplete r where sup :: (r -> Bool) -> Maybe r', with an additional law that isn't enforced by the type checker
06:55:13 <julianleviston> https://www.youtube.com/watch?v=LJQgYBQFtSE
06:55:53 <hyperisco> the basic idea is that you should be able to abstract away from a particular reals implementation, like Double
06:57:43 <Solonarv> (that law being: 'sup f == Nothing iff ∀N :: r ∃m :: r . m > N ∧ f m', or something)
06:57:53 <hyperisco> I suppose the Prelude/base way of doing things with Num isn't so clear about this
06:58:10 <Solonarv> but... Double isn't a valid implementation of reals, if you want to be mathematically rigorous
06:58:17 <hyperisco> but if you're comfortable working with the breakdown of Semirings, Rings, etc, then this is a natural curiosity
06:59:19 <julianleviston> purescript springs t mind :)
06:59:28 <hyperisco> it isn't and I'd love to see real approximations properly described, but until then we just assume it'll be good enough
06:59:29 <julianleviston> it has a bit more of a precise numeric tower
07:00:58 <julianleviston> (apparently) ;-)
07:01:15 <hyperisco> it does
07:02:37 <hyperisco> I'd love to see FPE properly described, rather than fudging
07:06:32 <hyperisco> not pretending bounded integers are unbounded is, I think, liberating
07:06:37 <kuribas> Solonarv: Double is a finitite set of discrete numbers.  The advantage is that it covers a large scale.
07:09:13 <kuribas> An unbounded Integer with unbounded exponent would be a better representation of the reals
07:10:02 <julianleviston> sounds like a description of Fractional.
07:10:21 <julianleviston> ugh not really.
07:11:47 <merijn> Rational
07:12:11 <merijn> > 0.1 + 0.2 :: Rational
07:12:13 <lambdabot>  3 % 10
07:12:26 <julianleviston> lol yeah… you’d think I’d know given the ticket I’ve been fixing :)
07:13:38 <julianleviston> but not all Real are rationals tho right
07:13:49 <julianleviston> ugh. I need to study math more.
07:14:55 <julianleviston> like… irrationals are reals… 
07:15:06 <merijn> julianleviston: Sure, but irrational reals have infinite length and thus can't be written in source code :p
07:15:29 <merijn> julianleviston: Any finite length decimal numbers is rational :p
07:16:17 <hyperisco> you can only write them as programs which produce the digits when run
07:17:06 <hyperisco> but see it'
07:17:17 <lieven> and there's only a countable bunch of computable numbers so most of the reals aren't
07:17:18 <julianleviston> sure
07:17:41 <hyperisco> d be nice to switch between an arbitrary precision real and a floating point
07:17:56 <hyperisco> granted that termination can vary
07:17:59 <julianleviston> this reminds me of FRP
07:18:23 <julianleviston> … and building a representation only at the end, when you know what you’re goign to do with the behaviours.
07:18:41 <hyperisco> yes that's right
07:19:42 <hyperisco> lieven, to our benefit, the noncomputable reals shouldn't be an observable problem
07:21:33 <petercommand> when are noncomputable reals needed?
07:21:48 <julianleviston> pi
07:22:07 <julianleviston> ? I don’t know. 
07:22:09 <hyperisco> we can compute that though
07:22:13 <petercommand> isn't pi a computable real number
07:22:14 <julianleviston> we can?!
07:22:25 <julianleviston> I thought it was only approximable
07:22:26 <hyperisco> absolutely… how do you think they figured out millions of digits of pi
07:22:36 <julianleviston> oh… you mean imprecisely
07:22:47 <hyperisco> the point is that if you let the program run forever it gives you pi
07:22:53 <hyperisco> so the program itself is a representation of pi
07:22:59 <petercommand> julianleviston: I think pi is computable to arbitrary precision
07:23:05 <julianleviston> right
07:23:07 <hyperisco> but there are real numbers for which there is no program that outputs them, even if run forever
07:23:24 <julianleviston> so when you say non-computable you mean you can’t ever compute any approximation of them?
07:23:33 <hyperisco> yes
07:23:49 <day> is there a simple example for such a problem?
07:23:56 <hyperisco> and that is just because there are less programs than real numbers :P
07:24:51 <petercommand> julianleviston: I don't think it's "can't compute any aproximation", it's can't compute to arbitary precision?
07:25:03 <julianleviston> I don’t really follow
07:25:18 <hyperisco> there are countably many programs
07:25:49 <petercommand> julianleviston: If I want a program to represent a real number, it has to actually represent that number
07:25:50 <hyperisco> this is quite easy to see if you go by, say, the language's syntax
07:25:53 <julianleviston> https://en.wikipedia.org/wiki/Chaitin%27s_constant
07:26:18 <exarkun1> How do I use Pandoc?  My efforts fall flat.  writeHtml5 returns "PandocMonad m => m Html".  I don't know what to do with any part of this. :/
07:26:22 <julianleviston> petercommand: can’t you represent unrepresentable things easily?
07:26:23 <hyperisco> you can enumerate all programs from the language grammar, and there is clearly countably many
07:26:28 <petercommand> julianleviston: not just a vague approximation saying that the number is greater than 3 and smaller than 4
07:27:13 <petercommand> julianleviston: Uh, by definition, something that is unrepresentable cannot be represented..am I misunderstanding something?
07:27:25 <julianleviston> petercommand: data Unrepresentable
07:27:36 <julianleviston> petercommand: I don’t know. :) Language is pretty great :)
07:28:11 <petercommand> julianleviston: you mean a datatype without inhabitants?
07:28:29 <petercommand> I don't get it
07:28:30 <hyperisco> representing the concept of something unrepresentable is easy, you just give it a name
07:28:35 <julianleviston> petercommand: you could give it enhabitants if you like. It’s still representing something that can’t be represented… coz language can lie.
07:28:42 <julianleviston> hyperisco: exactly :)
07:29:30 <petercommand> Can I understand it as...describable?
07:29:45 <petercommand> ex: finitely describable
07:29:50 <julianleviston> petercommand: I think that’s everything isn’t it?
07:29:56 <petercommand> no
07:29:57 <julianleviston> petercommand: Gödel springs to mind.
07:30:01 <julianleviston> petercommand: might be :P
07:30:05 <petercommand> it's countable
07:30:12 <julianleviston> doesn’t mean you can describe it.
07:30:58 <julianleviston> but I’m happy to defer to whatever description of things you’d like to settle on. Such discussions become… not so useful quite quickly.
07:32:11 <Solonarv> You can't describe every real, because the set of sentences is countable
07:32:18 <petercommand> julianleviston: I am just trying to understand what you mean by representable
07:33:03 <petercommand> julianleviston: and see if i am understanding it correctly
07:33:57 <petercommand> Solonarv: yes, that's what I am saying
07:36:39 <Denommus> why isn't there a haskell-stack package in Ubuntu 18.10?
07:36:50 <Denommus> is there a way to install stack from apt?
07:36:55 <petercommand> julianleviston: When I said "it's countable" I mean the set of describable things
07:37:05 <petercommand> does this make sense?
07:37:16 <julianleviston> petercommand: I don’t think this is a useful conversation.
07:37:39 <petercommand> julianleviston: uhh
07:37:52 <petercommand> alright
07:38:04 <julianleviston> petercommand: we can keep talking if you like, but I’m not sure why.
07:38:14 <julianleviston> petercommand: the reals are uncountable, sure.
07:39:22 --- mode: glguy set +v Flyers
07:39:53 <julianleviston> petercommand: as far as I understand it, any particular real is describable. That is, we can talk about it, and possibly write down an approximation of it.
07:40:25 <petercommand> yes
07:41:00 <hyperisco> that just isn't true
07:41:14 <julianleviston> isn’t it?
07:41:24 <hyperisco> there are more reals than sentences you can write
07:41:30 <julianleviston> sure. so what? :)
07:41:39 <hyperisco> so there are reals you cannot describe
07:41:47 <julianleviston> that doesn’t make sense to me.
07:42:03 <petercommand> wait I think I misunderstood
07:42:07 <julianleviston> we can spend infinity looking, right?
07:42:12 <hyperisco> yup
07:42:13 <Solonarv> Well, normally the solution would be to give an example of such a real, but...
07:42:18 <hyperisco> Solonarv, lol
07:42:21 <julianleviston> ;-)
07:43:04 <julianleviston> hyperisco: so are you saying there are reals we can’t conceive of?
07:43:09 <exarkun1> okay I finally found runIO
07:43:10 <petercommand> julianleviston: most reals are not describable
07:43:13 <julianleviston> hyperisco: or are you saying “you can’t write all the reals down” :)
07:43:23 <julianleviston> hyperisco: meaning… you can’t write EVERY ONE of them down...
07:43:29 <Solonarv> Human minds are finite, there are *natural numbers* we can't conceive of.
07:43:32 <hyperisco> I don't know the nature of conception, so I am not sure
07:43:32 <julianleviston> hyperisco: or are you saying there are some you can’t write down :)
07:43:50 <petercommand> julianleviston: you can't write most of them down
07:44:11 <julianleviston> I’m not sure why.
07:44:27 <petercommand> because of cardinality
07:44:28 <julianleviston> and i’m not sure what your definiton of “most of them” is :)
07:44:41 <_deepfire> There are also uncomputable numbers.
07:44:49 <julianleviston> what are they?
07:45:04 <_deepfire> Numbers for which no algorithm of writing them down exist.
07:45:17 <julianleviston> that’s not my understanding of computability
07:45:18 <Lycurgus> he wants names
07:45:23 <julianleviston> no, I don't.
07:45:30 <julianleviston> bottom is one, right?
07:45:40 <Solonarv> 'bottom' isn't a number
07:45:41 <Lycurgus> bottom isn't a number
07:45:42 <julianleviston> as in… the infinite program.
07:45:53 <julianleviston> isn’t it tho?
07:45:56 <Lycurgus> no
07:46:02 <Putonlalla> Typically programs are finite.
07:46:17 <julianleviston> Is this reasonable? A computable number is a number that can be calculated by a finite computer program.
07:46:21 <Lycurgus> numbers don't really figure in category theory 
07:46:41 <julianleviston> sorry when I say bottom I mean a neverending program. Imprecision on my part.
07:46:58 <petercommand> julianleviston: a never ending program does not represent a number
07:47:15 <_deepfire> Category theory doesn't discuss computability, does it?
07:47:16 <julianleviston> what’s 1/3 in decimal?
07:47:41 <petercommand> right
07:47:45 <Lycurgus> as many threes as you like
07:47:49 <julianleviston> lol
07:48:02 <petercommand> I should say a nver ending program without output
07:48:06 <petercommand> *never
07:48:09 <Solonarv> no, it's infinite threes.
07:48:21 <julianleviston> guess it depends when the output happens ;)
07:48:27 <_deepfire> Lycurgus: that's.. subtle : -)
07:48:43 <Lycurgus> is it? I must have slipped up.
07:49:39 <hyperisco> look, the reals are nasty
07:50:26 <hyperisco> if I could get through life without them I would
07:50:50 <julianleviston> aren’t they where reality is?
07:50:59 <hyperisco> apparently that is debatable
07:50:59 <Lycurgus> no
07:51:02 <petercommand> julianleviston: what does that mean?
07:51:07 <Lycurgus> reality is in the world
07:51:16 <julianleviston> Lycurgus: yes, exactly.
07:51:17 <Lycurgus> mathematics is all abstraction
07:51:26 <Cale> https://ncatlab.org/nlab/show/groupoid+cardinality -- numbers in category theory :)
07:52:08 <hyperisco> personally I am hoping down low the universe is discrete
07:52:09 <Solonarv> complex numbers are quite possibly "more real" than real numbers, given quantum physics
07:52:10 <julianleviston> petercommand: it means … the number 4, for example, never appears anywhere ever… integers don’t actually exist. It’s always struck me that irrationals and the reals between integers are more like reality than the numbers we “like”.
07:52:11 <Cale> It's a really pretty idea. Often we're first introduced to fractions by way of symmetrically cutting something into pieces.
07:52:47 <petercommand> julianleviston: and the reals don't appear anywhere too
07:53:00 <julianleviston> petercommand: lol. ok. I’m happy to be considered wrong. :)
07:53:15 <julianleviston> petercommand: like I said before, this conversation isn’t useful :)
07:53:21 <petercommand> :)
07:53:33 <_deepfire> what is? : -)
07:53:45 <Lycurgus> names like irrational and real are just cultural artifacts
07:53:55 <petercommand> julianleviston: but it's interesting :)
07:54:00 <Solonarv> quantum physics (again!) involves a lot of integers too
07:54:07 <Cale> Numbers are all equally human inventions.
07:54:10 <Lycurgus> some are more cogent than others
07:54:20 <petercommand> Cale++
07:54:24 <Lycurgus> irrational more so, real less so
07:54:49 <Lycurgus> well mathematics is not human dependent
07:54:57 <Lycurgus> it's valid for beings everywhere
07:55:12 <c_wraith> yeah, almost all real numbers require infinite information to specify uniquely. anything useful done with them requires working with the subset with finite representations.
07:55:46 <Lycurgus> that sounds false unless there's something about the density of the reals I'm missing
07:55:51 <kuribas> is there a real number that can be described, but not calculated?
07:55:55 <julianleviston> petercommand: well, I guess interest can be a use, so all good then :)
07:55:55 <_deepfire> Cale, invention vs. discovery -- that's an interesting debate!
07:55:58 <Lycurgus> dedekind and other procedures come to mind
07:56:06 <Cale> While people may have the sense that the natural numbers are somehow just one way as determined by the universe, this sadly isn't the case. Arithmetic has many models, and at least when it comes to universally quantified statements, different things may be true of them.
07:56:08 <c_wraith> kuribas, sure. Chaitan's constant
07:56:15 <_deepfire> Cale: f.e. the Curry-Howard-Lambek -- invented or discovered?
07:56:24 <_deepfire> people like to say discovered
07:56:28 <Cale> _deepfire: Very very invented.
07:56:31 <petercommand> kuribas: I would want to know that too
07:56:37 <Cale> In fact, contrived :D
07:56:47 <petercommand> Cale: how so
07:56:57 <petercommand> how is it contrived
07:57:00 <julianleviston> _deepfire: what’s the difference between invention and discovery? that implies a separate context can exist, doesn’t it?
07:57:10 <Cale> We make that one happen by way of constructing our logics and programming languages carefully to match :D
07:57:24 <c_wraith> petercommand, look up Chaitan's constant
07:57:56 <Cale> Perhaps the fact that we can do so at all is a discovery of sorts
07:58:11 <petercommand> c_wraith: thx
07:58:32 <Cale> But the distinction is always hazy, and when it comes to these things, they're all the product of human work, so they all at least count as inventions.
07:58:54 <Cale> It's hard for ideas not to be.
07:59:03 <c_wraith> iirc, it's roughly the probability that a randomly-selected Turing machine halts. but specified more precisely.
07:59:04 <_deepfire> "Came to our mind as a result of our interaction with the external world"?
07:59:13 <_deepfire> Doesn't everything?
07:59:17 <hyperisco> oh, so true random number generation can be seeded by a language grammar
07:59:18 <julianleviston> yeah.
07:59:46 <kuribas> c_wraith: is that something that we don't know how to calculate, or that's proven impossible to calculate?
07:59:58 <c_wraith> kuribas, the latter
08:00:04 <Lycurgus> there's a distinction between arbitrary abstractions, thoughts and those that have the properties of mathematics which as I said is valid for thinking beings everywhere
08:00:15 <c_wraith> kuribas, since it reduces to the halting problem.
08:00:31 <Solonarv> You could calculate it using a halting oracle, and there's some way to derive a halting oracle from it
08:00:40 <kuribas> c_wraith: so in a universe where you can solve the halting problem you can calculate this constant?
08:01:19 <Solonarv> Correct, since you can just enumerate all turing machines and ask your oracle if they halt
08:01:20 <Lycurgus> (everywhere doesn't mean just this pocket)
08:01:23 <c_wraith> the halting problem is more a feature of logic than the universe. so in a logic where...
08:01:37 <_deepfire> Lycurgus: we're in luck for not having met aliens with thinking orthogonal to ours -- yet..  that's an interesting concept for stretching the "valid for thinking beings everywhere"..
08:02:07 <_deepfire> ..and also, practically useless : -)
08:02:07 <Lycurgus> physics can vary in different pockets but mathematics can't
08:02:13 --- mode: glguy set +v Ulbrec
08:02:14 <julianleviston> or maybe people who don’t think in dialectics
08:02:15 <hyperisco> I wonder how someone came around to investigating the probability of a program halting
08:02:28 <petercommand> Solonarv: but if you enumerate all turing machines, the program won't halt
08:02:51 <Cale> Lycurgus: "pockets"?
08:03:05 <Solonarv> petercommand: Indeed, but if you let it run for a (countable) infinity of steps you'll have a full result
08:03:29 <Lycurgus> Cale: Guth's infinite inflation version of the multiverse, the one that makes any sense
08:03:35 <Solonarv> Which is what you're looking for, because that's also how (for example) pi is computable
08:03:42 <Cale> Lycurgus: Mathematics and physics can equally vary, depending on our needs. Physics is subject to the constraint that reasonably good predictions come out of it, while mathematics isn't.
08:04:03 <Cale> So in that way, physics is a bit more constrained than mathematics is.
08:04:04 <Solonarv> Math is too, it just has a different metric for "good"
08:04:20 <Cale> But otherwise, mathematics is just whatever we like it to be at any given moment :)
08:04:26 <petercommand> Solonarv: So, that means that the limit has to exist
08:04:40 <petercommand> Solonarv: for the number to make sense
08:04:44 <c_wraith> Solonarv, pi converges in a different way. you can always determine how much work you need to do to uniquely pi up to a certain precision.
08:04:52 <Lycurgus> i meant that physics could be different in a different pocket universe but mathematics couldn't although of course what actually develops could emphasize different things
08:04:58 <Solonarv> c_wraith: Same for chaitin's constant with a halting oracle, no?
08:05:10 <c_wraith> oh, with an oracle. yes.
08:05:25 <c_wraith> I forgot you were looking at that case.
08:05:44 <petercommand> Solonarv: does chaitin's constant converge with a halting oracle?
08:05:50 <Cale> Lycurgus: Why couldn't it? I would expect that human-analogous-creatures living in a universe with different rules (or even a universe with the same rules and a different history) would have different mathematics from us.
08:06:10 <Lycurgus> not physics the study, physics the actual laws of nature
08:06:19 <Cale> Humans *right now* have many different mathematical systems that don't agree with one another.
08:06:57 <Cale> So expecting alien mathematics to be the same as ours is foolish, when various mathematical systems we've constructed ourselves don't agree.
08:06:59 <Lycurgus> Cale, do you hold that truth is ineffable and there are fundamentally different kinds of it?
08:07:12 <c_wraith> Cale, but can they escape metamathematical results like Goedel's incompleteness theorem? that seems to be independent of the system actually used.
08:07:29 <_deepfire> Lycurgus: problem is, truth is relative to linguistic concepts
08:07:48 <Cale> Truth is a human tool as well, because it's a label that we apply to statements in our languages which we invented.
08:07:57 <Lycurgus> so if you do as _deepfire does and I do not then yes
08:10:30 <Cale> c_wraith: It's possible that there's some strange metamathematical result there which I suppose is actually almost a result of physics instead. Not Gödel's theorems directly, but almost something which more generally applies to any kind of system we're building out of symbols -- it's really hard to formalise anything at that point though.
08:11:11 <Lycurgus> in that case different ineffible factors can give rise to different concepts of truth in different places or ftm persons or even a single person at different times
08:11:31 * hyperisco returns
08:11:33 <Cale> c_wraith: I mean, Gödel's theorems as stated really only apply to first order theories of arithmetic -- but of course there are analogous results in other systems
08:11:40 * hyperisco promptly leaves
08:11:53 <Cale> It's just hard to formalise at that point what we mean by the generalisation :)
08:12:27 <c_wraith> Cale, well, the modern incarnation of the incompleteness theorem is more of a proof schema that applies in any logic satisfying a few well-enumerated conditions.
08:13:04 <Cale> c_wraith: Does it even reach as far as type theories? :)
08:13:36 <petercommand> Cale: does it not?
08:13:36 <c_wraith> second-order statements, a mechanical method of verifying proofs, and... one other requirement I can't recall offhand.
08:13:56 <c_wraith> does type theory often have second-order statements?
08:13:58 <Solonarv> I seem to vaguely recall that it applies to anything tht can encode the Peano axioms
08:14:06 <Cale> petercommand: Well, some version of it does, but my point is just that there are many "Gödel-style" theorems
08:14:22 <Cale> and it becomes hard to generalise sufficiently what's going on at some point
08:14:58 <c_wraith> well, that's certainly true.
08:15:14 <c_wraith> we don't work well with logics that have too many axioms.
08:15:31 <c_wraith> especially when they're weird higher-order axioms.
08:16:14 <c_wraith> we have enough trouble with Peano's 5th axiom. :)
08:16:52 * hackage collection-json 1.3.0.0 - Collection+JSON—Hypermedia Type Tools  http://hackage.haskell.org/package/collection-json-1.3.0.0 (alunduil)
08:16:58 <larryba> what is the nicer way of writing this? (\e -> return $ displayException (e :: MyException)) ? someone mentioned it in the channel the other day, using @ syntax, but I don't recall the extension name
08:16:58 <Cale> I don't deny that it seems like there's *something* there that we don't have words for, which applies to all our formal means of reasoning about things.
08:17:33 <julianleviston> larryba: would return . displayException work?
08:17:42 <petercommand> larryba: type application?
08:17:44 <Cale> But it's hard to say that it's like, part of our physical reality or something about the way that we've been constructing formal systems.
08:17:46 <petercommand> larryba: not sure
08:17:47 <julianleviston> larryba:  you might need to throw a type in there.
08:17:48 <larryba> julianleviston, no, as I have to specify what type I have to catch
08:18:04 <petercommand> larryba: https://ghc.haskell.org/trac/ghc/wiki/TypeApplication
08:18:07 <julianleviston> larryba: you can do that easily tho, no?
08:18:28 <larryba> petercommand, yes, that is the one!
08:18:35 <larryba> julianleviston, without that extension, or?
08:18:40 <petercommand> :D
08:18:44 <Lycurgus> *ineffable 
08:18:55 <julianleviston> I would have thought you could have just written a type signature on your expression… no?
08:19:23 <larryba> if I had to write signature of the function that would end up being longer than what I have above
08:19:47 <Solonarv> 'pure . displayException @MyException' is definitely nice and short
08:19:57 <julianleviston> larryba: right… need to specify why “nice” means :)
08:20:24 <larryba> Solonarv, yes
08:22:08 <c_wraith> julianleviston, same reason why any other string means (or doesn't mean). English speakers have a consensus that it does.
08:22:22 * hackage cabal-bounds 2.1.0 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-2.1.0 (DanielTrstenjak)
08:22:29 <Cale> Lycurgus: I wouldn't say that truth is ineffable, just that it's whatever we make of it. It's a useful part of many useful tools we've developed (logics) for taking statements we like and pasting them together into more statements we like.
08:22:49 <julianleviston> c_wraith: ? wow.
08:23:39 <c_wraith> julianleviston, sorry, I was probably-unfairly making fun of your typo. ("why" in place of "what")
08:23:40 <julianleviston> c_wraith: so you’re saying I don’t understand english?
08:23:58 <Lycurgus> Cale, "it's whatever I make of it" is what I call "ineffable"
08:24:04 <Lycurgus> my truth
08:24:13 <Lycurgus> not The Truth
08:24:20 <julianleviston> c_wraith: ah, sorry. Right. I’m a bit tired. Yeah, I meant to say “what’ :)
08:24:34 <julianleviston> “what” not “why”. 
08:25:05 <c_wraith> yes. no insult intended. just answering the wrong question.
08:25:11 <c_wraith> :)
08:26:01 <wroathe> Do type operators do anything to make haskell's type system more powerful? Or are they just nice syntactical sugar for pattern matching on expressions?
08:26:21 <julianleviston> what’s “timesNatural”?
08:26:29 <wroathe> i.e. a :<|> b could just be implemented as (a, b), right?
08:26:35 <Lycurgus> wroathe, haskell is just a programming lang
08:26:50 <larryba> pure . displayException worked, but why is it not working in ghci, even though I loaded the file that used relevant language pragma? is ghci ignoring pragmas in loaded file?
08:27:00 <larryba> pure . displayException @ExceptionType, even
08:27:07 <c_wraith> wroathe, it's only syntactic sugar
08:27:11 <julianleviston> or rather… what’s the PrelName for times for rationals?
08:27:27 <wroathe> c_wraith: Thanks
08:28:07 <julianleviston> I should ask in GHC.
08:29:58 <larryba> > map @ Int
08:30:01 <lambdabot>  error:
08:30:01 <lambdabot>      Pattern syntax in expression context: map@Int
08:30:01 <lambdabot>      Did you mean to enable TypeApplications?
08:30:25 <Solonarv> % map @Int -- try yahb instead
08:30:25 <yahb> Solonarv: ; <interactive>:51:1: error:; * No instance for (Show ((Int -> b0) -> [Int] -> [b0])) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
08:30:40 <Solonarv> % :t map @Int
08:30:40 <yahb> Solonarv: (Int -> b) -> [Int] -> [b]
08:30:58 <larryba> I have to manually enable all the extensions in ghci that are in the file?
08:31:49 <Solonarv> Yes, but you can automate this with a .ghci file
08:33:13 <larryba> Solonarv, I know, but it would be nice if language extensions in ghci matched those in the file I loaded
08:34:23 * hackage cabal-bounds 2.1.1 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-2.1.1 (DanielTrstenjak)
08:34:47 <Solonarv> I agree. It's not a problem I run into often, because I just dump all my extensions into blah.cabal - and if you do that, and start ghci with `cabal new-repl` or `stack repl`, they will be enabled.
08:35:25 <larryba> Solonarv, that leads to different issue. my file working while I am loading it in ghci, and then failing to compile with ghc
08:36:04 <Solonarv> That's why I don't compile with ghc directly, and neither should you if you have a cabal file
08:36:53 <Solonarv> (instead use `cabal new-build` or `stack build`)
08:36:56 <larryba> I have cabal file, of course, but I prefer to have per-file extensions
08:38:13 <larryba> > map @[Int]
08:38:15 <lambdabot>  error:
08:38:15 <lambdabot>      Pattern syntax in expression context: map@[Int]
08:38:16 <lambdabot>      Did you mean to enable TypeApplications?
08:38:25 <larryba> % map @[Int]
08:38:25 <yahb> larryba: ; <interactive>:53:1: error:; * No instance for (Show (([Int] -> b0) -> [[Int]] -> [b0])) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
08:38:36 <larryba> % :t map @[Int]
08:38:37 <yahb> larryba: ([Int] -> b) -> [[Int]] -> [b]
08:38:43 <larryba> this is such an awesome extension
08:39:01 <c_wraith> larryba, I think the reason ghci works that way is that you can load multiple source files at once into it, and there are some extensions that you really don't want to leak into your full ghci session if you're loading multiple files.
08:39:09 <Solonarv> % :t map @[_] -- it's even cooler!
08:39:09 <yahb> Solonarv: ([w] -> b) -> [[w]] -> [b]
08:39:30 <c_wraith> w? where did that come from?
08:39:43 <Solonarv> that's what GHC replaced my '_' with
08:39:59 <Solonarv> it's a fresh type variable
08:40:15 <c_wraith> yes, but I used to understand how ghc chooses type variables for display purposes. that one, on the other hand, is confusing.
08:40:23 <larryba> % :t map @[a]
08:40:23 <yahb> larryba: ; <interactive>:1:7: error: Not in scope: type variable `a'
08:40:37 <Solonarv> 'w'ildcard, I guess?
08:40:46 <dmwit> % :t map @[_] @[_]
08:40:47 <yahb> dmwit: ([w1] -> [w2]) -> [[w1]] -> [[w2]]
08:40:51 <c_wraith> oh, that's a good thought.
08:40:58 <larryba> roboobs
08:41:28 <Solonarv> % :t (<*>) @((->) _) -- a good example of this being useful
08:41:28 <yahb> Solonarv: (w -> a -> b) -> (w -> a) -> w -> b
08:46:00 <larryba> this is a bit countertuitive
08:46:06 <larryba> :t catch
08:46:07 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
08:46:22 <larryba> catch :: (Exception e, MonadCatch m) => m a -> (e -> m a) -> m a
08:47:37 <larryba> oh, first @Type fills first type variable after => (m in this case), not first mentioned in the constraints section? 
08:47:44 <merijn> larryba: What's counterintuitive?
08:48:18 <larryba> merijn, that catch @IO worked.   catch @IO :: Exception e => IO a -> (e -> IO a) -> IO a
08:48:42 <Solonarv> % :set -fprint-explicit-foralls
08:48:43 <yahb> Solonarv: 
08:48:46 <merijn> larryba: The order of type variables is (unless manually specified using ScopedTypeVariables and explicit forall) an implementation detail
08:48:53 <Solonarv> % :t catchM
08:48:53 <yahb> Solonarv: ; <interactive>:1:1: error:; * Variable not in scope: catchM; * Perhaps you meant one of these: `catch' (imported from Control.Exception), `catch#' (imported from GHC.Exts), data constructor `Match' (imported from Language.Haskell.TH)
08:49:01 <merijn> larryba: Incidentally, why I dislike -XTypeApplications
08:49:01 <larryba> merijn, then how does @ extension decide?
08:49:03 <Solonarv> % :t map
08:49:03 <yahb> Solonarv: forall {a} {b}. (a -> b) -> [a] -> [b]
08:49:17 <merijn> larryba: It uses whatever order GHC happens to (internally) use
08:49:25 <larryba> hmm
08:49:52 * hackage cabal-lenses 0.9.0 - Lenses and traversals for the Cabal library.  http://hackage.haskell.org/package/cabal-lenses-0.9.0 (DanielTrstenjak)
08:49:55 <merijn> -XTypleApplications makes this an explicit part of your API, which is brittle unless you explicitly forall everything
08:49:58 <Solonarv> I thought it tried to re-use the order given by "first syntactic appearance in the type sig", if you gave a type sig
08:50:12 <Solonarv> But yes, it's brittle.
08:50:18 <merijn> Solonarv: That may or may not be the logic GHC uses internally, I dunno
08:50:22 * hackage cal-layout 0.1.0.0 - Calendar Layout Algorithm  http://hackage.haskell.org/package/cal-layout-0.1.0.0 (bor0)
08:50:42 <larryba> Solonarv, so first type variable after =>? 
08:50:55 <hyperisco> are there interesting vector spaces on naturals?
08:51:23 <hyperisco> excuse me, integers
08:51:31 <larryba> catch @IO @SomeException :: IO a -> (SomeException -> IO a) -> IO a
08:51:51 <Solonarv> hyperisco: "vector spaces" over a ring are called modules, IIRC
08:52:01 <Solonarv> s/ring/ring instead of a field/
08:52:06 <hyperisco> interesting
08:52:25 <hyperisco> yeah I was reading the definition of a vector space and though they said it was on fields they didn't use any features exclusive to fields
08:52:35 <larryba> Solonarv, I'm playing around in ghci, and it seems to be consistently filling type variables in order, after => (ignoring order prior to =>)
08:53:19 <Solonarv> behavior described here: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-TypeApplications
08:54:01 <hyperisco> https://en.wikipedia.org/wiki/Module_(mathematics)
08:54:20 <hyperisco> I don't really get the hubbub over this… from the get-go it seems a vector space is not specific to fields
08:54:26 <hyperisco> so maybe this is just legacy math
08:55:07 <Solonarv> Vector spaces have a few extra "nice" properties compared to modules, IIRC
08:55:16 <hyperisco> what properties?
08:55:29 <hyperisco> http://mathworld.wolfram.com/VectorSpace.html
08:55:31 <larryba> my catch example isn't consistent with this:  If an identifiers type signature does not include an explicit forall, the type variable arguments appear in the left-to-right order in which the variables appear in the type. So, foo :: Monad m => a b -> m (a c) will have its type variables ordered as m, a, b, c.
08:56:19 <Solonarv> oof, my linear alg I/II course was like 5 years ago and I haven't touched it since then...
08:57:26 <hyperisco> the only thing it touches wrt scalars is multiplication
08:57:59 <hyperisco> assuming your vectors are a group, then you need merely add multiplication by scalars
08:58:06 <larryba> "If any of the variables depend on other variables (that is, if some of the variables are kind variables), the variables are reordered so that kind variables come before type variables, preserving the left-to-right order as much as possible. That is, GHC performs a stable topological sort on the variables."
08:58:12 <larryba> why the weird rule... wth
08:58:31 <hyperisco> oh and scalar sums are mentioned
08:58:34 <Solonarv> because in a 'forall', kind variables must be defined before they are used
08:58:37 <hyperisco> but that still falls within a ring
08:59:02 <larryba> Solonarv, I can't parse that. is that the reason why m is filled before e in catch :: (Exception e, MonadCatch m) => m a -> (e -> m a) -> m a ?
08:59:22 <Solonarv> No, that's because 'catch' is a class method
08:59:50 <larryba> of MonadCatch
08:59:53 * hackage cabal-bounds 2.2.0 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-2.2.0 (DanielTrstenjak)
09:00:37 <larryba> I think I'd prefer simpler, left-to-right rule, without exceptions
09:01:16 <Solonarv> But then you'd get illegal type signatures.
09:01:34 <larryba> I can't see why
09:01:38 <Solonarv> 'forall (a :: k) k. whatever' isn't allowed.
09:02:46 <larryba> on the second though, I would expect return @IO to work, instead of return @_ @IO. so I guess it does make some sense
09:03:49 <Solonarv> Ah, note that there are two different things breaking the left-to-right rule
09:04:36 <Solonarv> the rule for class methods - which makes the class' parameters come first - does indeed make code using TypeApplications less verbose a lot of the time
09:04:52 <hyperisco> Solonarv, perhaps fields are older than rings
09:05:10 <Solonarv> hyperisco: ah, I found something - modules don't always have a basis
09:05:12 <hyperisco> so it is like a Monad/Applicative coincidence
09:05:26 <hyperisco> okay but where does it say a vector space has a basis?
09:05:47 <hyperisco> " A consequence of the axiom of choice is that every vector space has a vector basis."
09:06:09 <hyperisco> According to Wolfram, so this needn't be part of the vector space definition
09:06:32 <Solonarv> Yes, but this proof doesn't generalize to modules
09:06:48 <Solonarv> So sayeth wikipedia
09:07:02 <hyperisco> yes but… it doesn't change anything
09:07:14 <hyperisco> I am thinking, maybe, fields were around first, or no one was interested in vector spaces over anything but fields
09:07:52 <hyperisco> so if one was to restate things sans history, one would just say vector spaces are modules over fields
09:07:54 <Solonarv> I don't know, having a basis seems like a pretty useful property to me.
09:08:15 <Solonarv> Ah. Yes, vector spaces could certainly be rephrased that way.
09:08:23 <hyperisco> that's what I'm getting at
09:08:40 <hyperisco> the way it is organised/stated right now feels awkward, like I'm missing something
09:08:52 <hyperisco> but I think I'm staring at something like Applicative vs Monad
09:09:06 <larryba> % :t map (+1) @Double
09:09:07 <yahb> larryba: ; <interactive>:1:1: error:; * Cannot apply expression of type `[b0] -> [b0]'; to a visible type argument `Double'; * In the expression: map (+ 1) @Double
09:09:13 <larryba> why not?
09:09:21 <hyperisco> where retrospectively people realised Monad should have just been Applicative plus an extra piece
09:09:48 <hyperisco> but the history has already been made, so we have definitions like liftM2
09:10:18 <Solonarv> % :t +v map (+1)
09:10:18 <yahb> Solonarv: forall {b}. Num b => [b] -> [b]
09:10:38 <larryba> hyperisco, they could be deprecated, now that liftA2 works with Monad
09:10:40 <Solonarv> larryba: the braces mean that type variable isn't available for type application
09:10:57 <Solonarv> so sayeth the GHC User's Guide
09:11:20 <larryba> okay
09:12:47 --- mode: glguy set +v petrem
09:20:22 * hackage steeloverseer 2.1.0.0 - A file watcher and development tool.  http://hackage.haskell.org/package/steeloverseer-2.1.0.0 (SchellScivally)
09:22:23 * hackage cabal-cargs 1.2.0 - A command line program for extracting compiler arguments from a cabal file.  http://hackage.haskell.org/package/cabal-cargs-1.2.0 (DanielTrstenjak)
09:31:39 --- mode: glguy set +v wroathe
09:31:53 --- mode: glguy set -v wroathe
09:31:54 <wroathe> So KindSignatures is just extra documentation about the kind of a type/type constructor?
09:33:11 <wroathe> https://gist.github.com/JustinChristensen/44ef40858c7b3fb5c7f2552dadc2ed1d
09:34:14 <lyxia> It's also necessary with PolyKinds, because some of the inferred kinds can be too polymorphic
09:34:18 <wroathe> I suppose if you don't define a value constructor it lets you manually set the kind, but without any value constructors that's kind of useless isn't it?
09:35:17 <wroathe> I just edited that gist to show Foo without a value constructor
09:36:00 <adamCS> I'm looking for general Vinyl/Frames advice.  I find that any relatively complex function on a set of records ends up with a lot of constraints, subset constraints and element constraints and some type equality constraints on various combinations of subsets.  Which is both messy on its own and then makes the functions hard to use with anything but concrete types.  Is there some general advice or good examples of how to keep
09:36:01 <adamCS>  the constraints simpler or more flexible?
09:36:14 <wroathe> lyxia: Got it. I'm just trying to evaluate each extension on it's own merits. Started working through https://www.well-typed.com/blog/2015/11/implementing-a-minimal-version-of-haskell-servant/ and the first thing they do is dump a bunch of extensions on you.
09:36:35 <wroathe> Type operators is simple enough, and so is KindSignatures if I understand it correctly
09:36:51 <lyxia> I'm not sure what you mean "without any value constructors that's kind of useless"
09:37:58 <wroathe> lyxia: Well, you're just redefining a version of Void that requires extra type information?
09:38:39 <lyxia> the type information is the point of such types
09:39:00 <wroathe> I suppose if the goal is to store extra type information in the type without ever creating a value of that type
09:39:09 <wroathe> Like type level documentation or something
09:40:20 <suzu> that is the goal
09:40:38 <lyxia> adamCS: I'm curious to see some examples of such complex functions
09:40:53 <suzu> servant lifts information into the type in an effort to abuse the typechecker in checking the correctness of the program
09:41:44 <adamCS> lyxia:  Okay. Do you mind if it is missing some of the context required to get it to compile?  I think the vinyl parts will be clear enough...
09:41:57 <lyxia> adamCS: I don't mind
09:44:20 <monochrom> Void is borderline unusable but only borderline because Ptr Void, Proxy Void, [Void], Maybe Void all still have values.
09:44:38 <adamCS> lyxia: Here you go. "scatterMerge" is the function that has gotten away from me.  It compiles and does the right thing but trying to call it with anything except concrete types is..hairy.  So I can't easily use it from another function. https://pastebin.com/dkb77trB
09:45:29 <wroathe> monochrom: [Void] is just the same as [] though and Maybe Void is the same as (), isn't it?
09:45:43 <wroathe> Not sure about those first two
09:46:05 <wroathe> I believe the fancy term is something like isomorphism 
09:46:35 <monochrom> And first-thing-is-dump-all-extensions-on-you is the disease of "my article is actually Literal Haskell" and this is why I refuse to use Literal Haskell for articles.
09:46:49 <amalloy> wroathe: only if you ignore bottoms, i think
09:46:54 <monochrom> [] doesn't even have the correct kind.
09:47:08 <monochrom> Either that, or [] isn't even a type.
09:47:25 <amalloy> let v = v in [v, v, v] :: [Void]
09:47:47 <monochrom> Ah I would avoid bottoms.
09:48:46 <lyxia> I recently figured out we can hide that ugly extension+imports header in a <details> block.
09:49:24 <wroathe> [Void] is somehat nonsensical though, right? A list comprised of elements of a type that can't have elements
09:49:29 <wroathe> somewhat*
09:49:32 <monochrom> I need to remember that reason next time someone asks me "why don't you format your article as Literate Haskell! I'm over-enthusiastic about Literate Haskell! I'm blind to its downsides I just want the whole world to religiously use Literate Haskell!"
09:50:02 <monochrom> (And yeah s/Literal/Literate/ # I'm illiteral! err illiterate!)
09:52:21 <wroathe> :t [] :: [Void]
09:52:22 <lambdabot> [Void]
09:53:46 <monochrom> And yeah the details-block idea brings me to: If you look at real literate programming systems (Knuth's web or Ramsey's noweb) they have an easy mechanism for re-ordering code blocks so the article can be in a different order than the code.
09:54:06 <monochrom> IMO if you don't have that mechanism you are not even close to doing literate programming.
09:55:10 <wroathe> monochrom: Well, for a guide like this maybe the thing to do is to try to implement it without any language extensions and see how far you get and how much pain it causes, then add a single language extension at a time and refactor to show how much simpler life can be
09:55:26 <wroathe> monochrom: Which is probably beyond the scope of articles like this
09:56:02 <monochrom> Standard Haskell suffers less of the problem because actually it is legal to, for example, write "x :: MyType; x = Foo" on line 3, then finally on line 5000 you introduce "data MyType = Foo".
09:56:50 <monochrom> Ah but another dogma of Literal Haskell is you have one single file and it loads fine into ghci!
09:57:23 * hackage cabal-bounds 2.2.1 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-2.2.1 (DanielTrstenjak)
09:57:26 <monochrom> IOW Literate Haskell is also against iterative corrections and refinements.
09:57:45 <monochrom> Sorry I keep typing "literal".
09:57:53 <wroathe> monochrom: So if I'm understanding you correctly you love literate haskell?
09:58:06 <wroathe> :troll:
09:58:07 <monochrom> The opposite.
09:58:12 <monochrom> Oh haha OK!
09:58:16 <lyxia> adamCS: hm, some of these constraints look simplifiable at the type-level, but doing so while keeping the necessary runtime information looks tricky.
09:59:14 <lyxia> adamCS: when it's only equalities, it might be worth making up some axioms by unsafeCoerce Refl. 
09:59:16 <adamCS> lyxia: Can you explain that more or a different way?  I also think they can be simplified but then had trouble when compiling which might be what you mean by "runtime information"
10:01:45 <lyxia> adamCS: sure. For example "(outKeyCols V.++ '[x,y,w]) ~ (ks V.++ '[Bin2D,x,y,w])" could be "outKeyCols ~ (ks V.++ '[Bin2D])", except that GHC can't prove they're equivalent.
10:02:12 <adamCS> right.  I tried some things like that.
10:03:14 <adamCS> And I am wondering if there are ways to use rcast or other vinyl functions within my functions so that the actual type equalities are not needed and I get away with equivalence.  And if that would simplify things.
10:03:51 <lyxia> you could define   axiom1 :: (outKeyCols ~ (ks V.++ '[Bin2D])) => (outKeyCols V.++ '[x,y,w]) :~: (ks V.++ '[Bin2D,x,y,w]) ;     axiom1 = unsafeCoerce Refl   and pattern-match on axiom1 when you need it.
10:05:33 <adamCS> yeah.
10:06:13 <adamCS> But would that simplify using this from another function?  For instance one where the type of the ks is not concrete?
10:08:08 <lyxia> maybe not by much
10:09:13 <adamCS> Yeah.  Okay.  I guess I can either have a zillion constraints all the way up the chain or just repeat things some at each concrete type.  Thanks for looking!
10:10:09 <lyxia> you can put the constraints in a synonym
10:10:42 <adamCS> lyxia:  That's true!  I might be able to make that work...
10:11:22 * hackage layers-game 0.6.0 - A prototypical 2d platform game.  http://hackage.haskell.org/package/layers-game-0.6.0 (DanielTrstenjak)
10:30:45 <fresheyeball> https://dpaste.de/UwKQ
10:31:01 <fresheyeball> If anyone wants to help with a very type level kinda thingy
10:31:10 <fresheyeball> This paste has all my relevant code
10:31:16 <fresheyeball> I can't find a way to get around this
10:31:37 <fresheyeball> I want a typeclass that takes a Haskell type and converts it into a Beam Table
10:34:00 <lyxia> the type of toTableRows is ambiguous, use some TypeApplications
10:36:06 <lyxia> oh wait, maybe not so ambiguous
10:36:25 <fresheyeball> lyxia: yeah, it's not the problem
10:36:37 <fresheyeball> it's that `forall s'` in Beam
10:37:11 <lyxia> fresheyeball: rewrite  f . g $ x  to  f (g x)
10:37:28 <fresheyeball> lyxia: I don't understand
10:37:30 <lyxia> (.) will not compose higher-rank functions
10:37:37 <fresheyeball> where?
10:37:41 <lyxia> recordAll
11:27:52 * hackage sbp 2.4.6 - SwiftNav's SBP Library  http://hackage.haskell.org/package/sbp-2.4.6 (markfine)
11:28:09 --- mode: glguy set +v MandA
11:28:44 <MandA> Hello! I am curious about the "Efficiency Note" in Data.Map.Merge.Strict
11:28:47 <MandA> http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Map-Merge-Strict.html
11:29:33 <hyperisco> am I right that an affine space does not require any particular features of point objects?
11:29:35 <MandA> As I am reading it, it is saying that using traverseMissing will be slow, but I cannot figure out why from looking at the implementation.
11:30:08 <hyperisco> it seems an affine space is only interested in features of vectors (their additive group) plus the vector relation between points
11:30:27 <glguy> MandA: It doesn't look like that note is saying anything about traverseMissing
11:31:52 <boj> it seems the result is WhenMissing, which is in the note
11:32:36 <glguy> The note is about "The Category, Applicative, and Monad instances for WhenMissing"
11:33:38 <boj> i am equally confused as MandA then. what does that actually mean?
11:34:32 <boj> travserseMissing is constrained to Applicative, wouldn't that note apply in that case?
11:34:40 <glguy> no
11:34:44 <boj> huh
11:36:30 <boj> could you clarify what is really going on there?
11:37:36 <glguy> Typeclasses have methods attached to them
11:38:01 <glguy> You're using a type's typeclass instance when you use those typeclass methods instantiated to the relevant type
11:38:49 <merijn> boj: It's saying the implementation of Applicative for WhenMissing is slow
11:38:50 <boj> they are saying stuff like <*> are used in conjunction with WhenMissing it is not efficient?
11:39:01 <MandA> glguy: Ohhh, so if you happened to define a WhenMissing operation using those instances, THAT will pay a performance penalty?
11:39:02 <merijn> boj: Yes
11:39:10 <boj> ok that makes sense, thanks
11:39:19 <glguy> % :t traverse @(Data.Map.Merge.Lazy.WhenMissing _ _ _)
11:39:20 <yahb> glguy: forall {w1 :: * -> *} {w2} {w3} {f :: * -> *} {a} {b}. (Traversable (Data.Map.Internal.WhenMissing w1 w2 w3), Applicative f) => (a -> f b) -> Data.Map.Internal.WhenMissing w1 w2 w3 a -> f (Data.Map.Internal.WhenMissing w1 w2 w3 b)
11:39:30 <hyperisco> type classes are just automatically unpacked named arguments
11:39:32 <glguy> That'd be using WhenMissing's traversable instance
11:39:34 * hyperisco scurries away
11:39:54 <glguy> % :t (>>=) @(Data.Map.Merge.Lazy.WhenMissing _ _ _)
11:39:55 <yahb> glguy: forall {w1 :: * -> *} {w2} {w3} {a} {b}. Monad w1 => Data.Map.Internal.WhenMissing w1 w2 w3 a -> (a -> Data.Map.Internal.WhenMissing w1 w2 w3 b) -> Data.Map.Internal.WhenMissing w1 w2 w3 b
11:40:09 <merijn> boj: Baiscally "we implemented this for completeness sake, not because you should use this"
11:40:09 * Solonarv_ mumbles something about coherence
11:40:10 <MandA> Okay, so it should be no worry to use in the typical way.
11:40:39 <MandA> I wonder if that message should be placed in the docs for WhenMissing more directly, so it will appear alongside the instances mentioned.
11:40:45 <boj> merijn: thanks for clarifying
11:41:20 <MandA> In any case, I appreciate the clarification! Thank you glguy and merijn!
11:45:44 <iqubic> Well I've gotten up to Limits and Colimits.
11:47:12 <iqubic> Haven't read that chapter. It's next my todo list.
11:47:36 --- mode: glguy set +v lambdamichael
11:56:56 --- mode: glguy set +v i8hantanu
12:01:43 <hyperisco> Solonarv, seems modules are more nuanced. I forgot fields were commutative rings… also there is inconsistency as to whether the ring has multiplicative inverses
12:02:03 --- mode: glguy set -v i8hantanu
12:02:09 <hyperisco> Solonarv, so you get left modules and right modules
12:02:40 <Solonarv> the "big important thing" you gain when going from ring -> field is multiplicative inverses, IMO
12:02:59 <hyperisco> well some authors assume rings have inverses
12:03:07 <hyperisco> so what you get is commutativity
12:03:24 <Solonarv> That seems really weird, I've never seen that.
12:03:39 <hyperisco> I'm just reading the Wikipedia
12:04:00 <hyperisco> PureScript has DivisionRing between Ring and Field which adds multiplicative inverses
12:04:57 <hyperisco> or EuclideanRing for commutative + inverses
12:04:58 <Solonarv> I want purescript's numeric hierarchy in the haskell prelude, tbh
12:05:24 <Solonarv> ...is that not just a field?
12:06:49 <artem> hi! I have a simple performance test case showing that, following HaskellWiki:Performance/Accumulating parameter, tail recursion is optimized much better than non-tail one. Question: is there simple explanation why? I'm speaking about really simple examples like the one on HaskellWiki or the one I was staring at: factorial on Peano numbers.
12:07:03 <artem> Links:
12:07:13 <artem> https://wiki.haskell.org/Performance/Accumulating_parameter
12:07:15 <hyperisco> Solonarv, excuse me, it does not add inverses
12:07:21 <artem> factorial: https://gist.github.com/ulysses4ever/3a53b34db17947bb7f5e984586e3c5e0
12:07:30 <hyperisco> Solonarv, it adds quotients
12:07:54 <wroathe> So with PolyKinds, by default a data type like data App f a = App (f a) has kind (* -> *) -> * -> *, which I understand to mean "give me a type constructor, then when given a concrete type will form a concrete type, and a concrete type, and I'll give you a concrete type"
12:08:11 <wroathe> After setting PolyKinds, the kind becomes (k -> *) -> k -> *
12:08:11 <Solonarv> oh I see. If you make it unital as well you get a field, right?
12:08:22 <merijn> bah...I've gone so long without using if/then/else that my use of it now looks ugly...
12:08:23 <hyperisco> Solonarv, right
12:08:31 <wroathe> What exactly is "k" here?
12:08:38 <hyperisco> Solonarv, their Field class has a singleton instance which is just EuclideanRing + DivisionRing
12:08:44 <Solonarv> A kind variable.
12:09:10 <wroathe> So you can sub k with (*, * -> *, * -> * -> *)?
12:09:25 <nyc```> Division rings can be noncommutative, like quaternions.
12:09:25 <merijn> wroathe: Incidentally, you should avoid using "concrete type", because it's poorly defined :)
12:09:36 <merijn> wroathe: https://gist.github.com/merijn/796b8e041885df870fbb53b7191644b6
12:09:46 <wroathe> merijn: lol
12:09:48 <hyperisco> nyc```, right, but EuclideanRing is commutative
12:10:24 <wroathe> Ok, so s/concrete type/type of kind type/
12:10:25 <hyperisco> at any rate, adding in modules as part of a geometric space hierarchy is too hairy for me at the moment
12:10:37 <Solonarv> wroathe: or Bool, or (Either Int), or Constraint, or...
12:10:44 <wroathe> How is * -> * different than k -> *?
12:11:02 <merijn> wroathe: Incidentally, App doesn't require a type constructor. It just requires a type
12:11:14 <Solonarv> compare: Int -> Int versus a -> Int
12:11:41 <merijn> wroathe: "App (Either Int)" is perfectly valid, but "Either Int" is not a type constructor (at least, not in most interpretations of the term)
12:11:49 <Solonarv> (try writing Type instead of *, maybe that'll make it all look less magical)
12:13:11 <wroathe> :k Either Int
12:13:13 <lambdabot> * -> *
12:13:22 <wroathe> Seems like a type constructor?
12:13:39 <hyperisco> or be like Miranda and use more *'s
12:13:47 <merijn> wroathe: I would say Either and Int are type constructors
12:13:48 <wroathe> App (Either Int) Int :: *
12:14:01 <merijn> wroathe: "Either Int" is a type expression
12:14:20 <wroathe> A type expression that evaluates to a type constructor?
12:14:22 <merijn> wroathe: Most people would say that "Just" is a type constructor but "Just True" is an expression/value
12:14:59 <merijn> wroathe: (Mind you, this is slightly pedantic, but I think keeping distinctions clearly defined is helpful)
12:15:21 <wroathe> merijn: I'll settle for intuition before I get too mired in pedantry :P
12:15:41 <cocreature> Just is not a type constructor, it’s a data constructor
12:15:47 <merijn> cocreature: Eh, of course
12:15:52 <merijn> cocreature: I'm tired :)
12:16:16 <wroathe> So what does k allow you to do that "Type" or "*" doesn't?
12:16:23 <merijn> wroathe: My point was that constructors (type or data) are atoms in the language, which expressions aren't
12:16:45 <hyperisco> Solonarv, oh you know what, I think I confused units and inverses in my reading
12:16:59 <hyperisco> they're saying not all authors require rings to be unital
12:17:46 <Solonarv> ah, that makes more sense
12:17:47 <hyperisco> I'm suffering definition overload… 7 years since I last studied linear algebra
12:18:59 <Solonarv> hey, not much better for me - 5 years
12:19:58 <nyc> I think it's been 25 years for me.
12:21:15 <dgpratt> I've never studied linear algebra. Do I win?
12:21:50 <nyc> I don't know if it's a contest.
12:22:57 <nyc> Inverses require units, but not vice-versa.
12:23:18 <hyperisco> mkay so here is what I'll do
12:23:30 <hyperisco> there shall be left modules and right modules and commutative modules
12:25:03 <hyperisco> where a commutative module is both a left module and a right module
12:26:11 <hyperisco> then a vector space is a commutative module over a field
12:26:43 <hyperisco> which yes is automatically commutative because it is a field but the type class hierarchy doesn't know that
12:27:32 <hyperisco> and this here has been an excellent reference btw http://hackage.haskell.org/package/vector-space-0.15
12:32:53 * hackage gi-gdkpixbuf 2.0.18 - GdkPixbuf bindings  http://hackage.haskell.org/package/gi-gdkpixbuf-2.0.18 (inaki)
12:34:14 <nyc> I think things can be left and right modules over different rings.
12:34:17 <jle`> wroathe: 'k' is a type variable
12:34:44 <jle`> so it's like the difference between `map :: (k -> j) -> [k] -> [j]` and `map :: (Int -> Bool) -> [Int] -> [Bool]
12:34:45 <hyperisco> yeah I think I am thinking about it slightly wrong so I should adjust
12:34:53 <jle`> er, a "kind variable"
12:35:08 <jle`> the first map is polymorphic for all types, but the second map only works for Int and Bool
12:35:21 <hyperisco> you can talk about either the left or right module, because if you have one you can define the other
12:35:21 <koz_> Hi jle`!
12:35:24 <Solonarv> hyperisco: perhaps you want a 
12:35:26 <koz_> Good to see you back around here.
12:35:31 <Solonarv> (premature enter, hold on)
12:35:34 <jle`> koz_: hi! :) it's good to be back :)
12:35:36 <hyperisco> so this sounds ideal for newtypes
12:35:47 <hyperisco> like Sum and Product, though here is Left and Right I guess
12:36:55 <jle`> wroathe: remember that there are other kinds than just Type/*, so it can be helpful to use a kind variable instead of fixing just to a specific kind
12:36:58 <Solonarv> class (Ring r, AdditiveGroup m) => LeftModule m r where ...; class (Ring r, AdditiveGroup m) => RightModule m r where ...
12:37:18 <jle`> even in "normal haskell", without any extra extensions, you have things that aren't kind-*
12:37:50 <Solonarv> then you can just have 'type Module m r = (LeftModule m r, RightModule m r)'
12:37:53 <hyperisco> yeah maybe… feels a bit silly because the only difference is which way you write the multiplication
12:37:59 <Solonarv> (my LA is too rusty to know if that's sound)
12:38:03 <wroathe> jle`: This statement is somewhat confusing to me: remember that there are other kinds than just Type/*
12:38:07 <hyperisco> that's basically what I did
12:38:12 <koz_> Solonarv: LA?
12:38:20 <wroathe> jle`: Let me see if I can articulate
12:38:24 <Solonarv> linear algebra
12:38:51 <koz_> Solonarv: Oh, right.
12:39:05 <wroathe> jle`: I think where I'm getting confused is that * already seems like a type variable to me, in the sense that * can be any nullary type constructor
12:39:34 <wroathe> jle`: then the difference to me between k and * seems like the difference in a decision to use x vs y in some algebraic expression
12:39:36 <jle`> is it the choice of the token *, then?
12:40:06 <wroathe> jle`: As in, they seem like names or aliases for the same set of nullary types
12:40:11 <hyperisco> Solonarv, it would at least make more sense to have one class for both left and right
12:40:22 <jle`> wroathe: yeah, "*" is meant to evoke "any nullary type constructor" , i think that is the intuition it is trying to provide
12:40:41 <jle`> wroathe: and along that path, it helps us see what's going on, too: there are things that *aren't* nullary type constructors
12:40:44 <Solonarv> hyperisco: can you construct a right module from any left module (and vice versa)?
12:40:53 <hyperisco> no what I am thinking is… well see you have Dual or w/e it is called to change the order of Monoid/Semigroup
12:41:11 <hyperisco> yes you can, because you just flip the multiplication
12:41:12 <jle`> consider the simple polykinded type `data Proxy a = Proxy`
12:41:29 <hyperisco> though I guess one wants to select which order they want, which is a newtype job
12:41:33 <jle`> `Proxy :: k -> Type`, or `Proxy :: k -> *`, to use old-style
12:41:48 <Solonarv> Ah but that's over  different ring then isn't it? (the dual ring, if that's the correct term)
12:41:49 <jle`> if Proxy was * -> *, then you could have things like `Proxy Int`, `Proxy Bool`, `Proxy String`
12:41:51 <wroathe> jle`: Can I PM you about this?
12:42:01 <jle`> but you can't have things like `Proxy Maybe`, `Proxy IO`, `Proxy Either`
12:42:24 <hyperisco> Solonarv, oh I suppose you're right, yes, it'd have to be on the ring
12:42:35 <jle`> this channel seems like a good place for the discussion :)
12:42:51 <hyperisco> Solonarv, maybe two classes is sensible design then
12:42:57 <jle`> if we had `Proxy :: * -> *`, you can do `Proxy Int`, but not `Proxy Maybe`
12:43:01 <Solonarv> I guess you could have 'instance LeftModule m r => RightModule m (Dual r)' or something
12:43:08 <Solonarv> and the same for Right => Left
12:43:16 <jle`> but since we have `Proxy :: k -> *`, we can do `Proxy Maybe` just fine, because `k` gets instantiated as `(* -> *)`
12:43:36 <hyperisco> well I was supposing you might just have a Module class, and then you change whether it is Left or Right by changing the Ring
12:43:37 <jle`> this is what I mean when I say that there are things that aren't kind-*.  some things aren't nullary type constructors.  Maybe, for example, is one of those things.
12:44:14 <wroathe> jle`: OH
12:44:24 <Solonarv> hyperisco: I think it's nice to have separate ^*. / .*^ operators for scalar multiplication from the right/left
12:44:29 <wroathe> jle`: So k is a specifier for a non-nullary type constructor!
12:44:32 <hyperisco> maybe that doesn't work the same though because the rings could have different units
12:44:40 <jle`> the fact that you had to quality with "nullary" implies that you, too, are aware that type consturctors might not be nullary
12:44:43 <jle`> wroathe: not necessarily
12:44:51 <wroathe> jle`: or maybe any type constructor?
12:44:53 <jle`> you can still use Proxy with Int
12:44:56 <wroathe> jle`: No reason it can't be nullary
12:45:04 <jle`> wroathe: it doesn't even have to be a type constructor
12:45:14 <Solonarv> If they're duals of each other, their units coincide, I think
12:45:16 <jle`> you can have `Proxy (Maybe Int)`
12:45:24 <jle`> or `Proxy (Either String)`
12:45:50 <hyperisco> Solonarv, well just talking about Rings, say I defined a newtype Dual and the idea was it was also a Ring but with multiplication flipped
12:46:00 <wroathe> Maybe Int has kind * and Either String has kind * -> *, so aren't they both still just type constructors?
12:46:11 <wroathe> jle`: One of arity 0 and another of arity 1?
12:46:24 <Solonarv> Yep, that's what I meant, hyperisco
12:46:26 <jle`> wroathe: Maybe is a type constructor, and Int is a type constructor
12:46:33 <jle`> wroathe: but `Maybe Int` is type application
12:46:43 <jle`> it's the application of one type constructor to another
12:46:56 <wroathe> * mind blown*
12:46:57 <hyperisco> oh right but the unit is both a left and right unit, so it still works if you flip, okay
12:47:03 <jle`> `Int`, `Maybe`, and `Maybe Int` are all "type expressions"
12:47:11 <jle`> type expressions are built using type constructors and type constructor application
12:47:24 <jle`> type constructors are the "building blocks" of type expressions
12:47:33 <jle`> this is all at the syntax level for the most part
12:48:04 <jle`> (this is what merijn was trying to say)
12:49:01 <jle`> by the way, with not-so-crazy extensions, you even can do things like `Proxy Show`, or `Proxy Monad`
12:49:17 <jle`> since 'k' can be the kind of any type expression
12:49:17 <wroathe> jle`: This distinction here: Int vs Maybe Int still confuses me when it comes to k
12:49:20 <wroathe> :k Int
12:49:22 <lambdabot> *
12:49:24 <wroathe> :k Maybe Int
12:49:26 <lambdabot> *
12:49:33 <hyperisco> Solonarv, do the rest of the ring laws still work though… I think I'm too tired to figure it out. Two classes it is then.
12:49:36 <jle`> wroathe: you can think of it as like how `5` and `8` have the same type
12:49:44 <jle`> 5 :: Int, and 8 :: Int
12:49:57 <jle`> hm, maybe that is a bad example since they look so similar
12:50:07 <jle`> you can think of it as how `5` and `negate 5` have the same type
12:50:09 <jle`> 5 :: Int
12:50:10 <subttle_> Hi, I'm trying to make a pull request for this ticket but I'm not sure what the best way to resolve the dependency on containers-0.5.11 is for this https://github.com/roelvandijk/containers-unicode-symbols/issues/6 ? Please and thank you :)
12:50:12 <jle`> negate 5 :: Int
12:50:14 <Solonarv> Unfortunately, I too am tired. But two classes seems like a reasonable approach to me.
12:50:18 <jle`> Int :: *
12:50:20 <jle`> Maybe Int :: *
12:50:36 <jle`> it's because `negate :: Int -> Int`, and `Maybe :: * -> *`
12:50:40 <subttle_> any help would be appreciated :)
12:50:52 <wroathe> Oh, I see
12:50:56 <wroathe> negate is to Maybe
12:50:57 <jle`> they're both functions that take something of a specific type/kind and return something of the same specific type/kind
12:50:59 <wroathe> In this example
12:50:59 <jle`> yeah
12:51:06 <wroathe> One operates at the value level, and another at the type level
12:51:16 <jle`> yeah. one is Int -> Int, the other is Type -> Type
12:51:28 <jle`> in the end, `negate 5` has the same type as `5`
12:51:34 <jle`> and `Maybe Int` has the same kind as `Int`
12:51:45 <jle`> because negate and maybe are both X -> X
12:52:13 <jle`> if you had a type-changing function, like `(+) :: Int -> (Int -> Int)`, things would be different
12:52:19 <jle`> (+) 5 :: Int -> Int
12:52:25 <hyperisco> also interesting… group actions act on a thing, but modules are a thing acting on a group
12:52:31 <jle`> and similarly, `Either String :: * -> *`
12:52:35 <jle`> Either takes a * and returns a (* -> *)
12:52:42 <jle`> (+) takes an Int and returns an (Int -> Int)
12:52:48 <hyperisco> does that make them vaguely related
12:53:39 <Solonarv> hyperisco: well, group actions can act on the group itself, so... maybe?
12:53:55 --- mode: glguy set +v Boarders
12:55:06 --- mode: glguy set -v Boarders
12:55:14 <wroathe> jle`: I think I see what's going on here. Need to mull it over some more. Thanks for the explanation!
12:55:19 <jle`> np :)
12:55:41 <Boarders> does anyone know if there is any way to have a symbol for a unary type synonym like: type * a = ...
12:55:49 <Boarders> (or anyway around it)
12:56:16 <Solonarv> wrap it in parentheses, like so: type (*) a = ...
12:56:21 <jle`> Boarders: you'd do it the same way as you'd write a function
12:56:31 <jle`> @let (***) x = reverse x
12:56:32 <lambdabot>  Defined.
12:56:36 <jle`> > (***) "hello"
12:56:38 <lambdabot>  error:
12:56:38 <lambdabot>      Ambiguous occurrence ‘***’
12:56:38 <lambdabot>      It could refer to either ‘Control.Arrow.***’,
12:56:41 <jle`> aw man
12:56:46 <jle`> @let (****) x = reverse x
12:56:48 <lambdabot>  Defined.
12:56:52 <Boarders> yes, but I mean to not have to use brackets
12:56:54 <jle`> > (****) "hello"
12:56:56 <lambdabot>  "olleh"
12:57:09 <hyperisco> unary type synonym?
12:57:15 <Boarders> like if I wanted to write: type ¬ a = a -> Void
12:57:30 <hyperisco> the devil is in the details
12:57:37 <dmj`> > join ["hello"]
12:57:40 <lambdabot>  "hello"
12:57:40 <Solonarv> Ah. Nope, can't do that with symbols.
12:57:50 <Boarders> rather than: type (¬) a = a -> Void
12:57:54 <jle`> > isLower '¬'
12:57:56 <lambdabot>  False
12:57:59 <Boarders> yes, I wanted to know if there is any way around it
12:58:18 <jle`> > generalCategory '¬'
12:58:20 <lambdabot>  MathSymbol
12:58:34 <jle`> ah yeah, no, symbolic identifiers must always be infix operators
12:58:39 <jle`> same as at the value level
12:58:44 <jle`> type level is no different
13:02:18 <Boarders> could you do this with a plugin that rewrites ¬ as a type synonym Not?
13:02:19 <wroathe> jle`: So with this example, what is the point of making z's kind polymorphic? https://en.wikipedia.org/wiki/Kind_(type_theory)#Kind_inference
13:02:23 <Boarders> I have never used plugins
13:02:56 <jle`> wroathe: the z there is phantom, so it's the same situation as Proxy
13:03:13 <wroathe> jle`: Where is phantom defined?
13:03:27 <wroathe> Sorry, I'll google
13:03:31 <jle`> a phantom type is a type where there isn't a value of that type ever used in any of the data constructors
13:04:01 <hyperisco> Boarders, I baked ¬ into another operator. Maybe that will work for you.
13:04:12 <jle`> so a much simpler example would be `data Proxy z = Proxy`
13:04:27 <hyperisco> Boarders, for example, A ∧¬ B
13:04:27 <jle`> the type variable is essentially ignored at the value level
13:04:40 <jle`> hyperisco: that's cute :)
13:04:49 <wroathe> jle`: THAT right there is the crux of what's been confusing me
13:04:57 <Boarders> hyperisco:  :)
13:05:05 <hyperisco> the one I used is ¬⇒ for "unless"
13:05:56 <Boarders> #define ¬  Not
13:06:00 <Boarders> what could go wrong O___0
13:06:17 <jle`> wroathe: phantom types have a lot of uses; one of them is to help with "Type safety"
13:06:20 <hyperisco> excuse me, ⇐¬
13:06:54 <wroathe> jle`: Battery is about to die. I'll keep on mulling this over. Especially how this relates to type safety.
13:06:57 <wroathe> jle`: Thanks again
13:07:02 <jle`> it's a tool sometimes used
13:07:13 <jle`> but you actually don't get too many poly-kinded phantom types in real life, either
13:07:21 <jle`> wroathe: no problem! :)
13:08:22 <Boarders> can't use CPP because macro names must be identifier :(
13:08:23 <Boarders> so sad
13:08:44 <hyperisco> Boarders, if it is aware of "" and '' and TH (if you use that) then… might be okay
13:09:14 <jle`> @tell wroathe by that i mean that using phantom types for type safety is usually better when the phantom types are not poly-kinded, and are restricted to a specific kind
13:09:14 <lambdabot> Consider it noted.
13:09:36 <jle`> @tell wroathe but most interesting usage of poly-kinded types to me involve non-phantom types
13:09:36 <lambdabot> Consider it noted.
13:09:45 <Boarders> hyperisco: ill give it a go (even though this is just for fun lol)
13:10:17 <jle`> @tell wroath an example, Compose f g x = Comp (f (g x)), which is poly-kinded on the return type of g
13:10:17 <lambdabot> Consider it noted.
13:10:34 <jle`> @tell wroath er, the kind of x, and the return kind of g
13:10:34 <lambdabot> Consider it noted.
13:10:46 <Solonarv> psst, you're mistyping the name
13:10:53 <jle`> :O
13:10:58 <jle`> thanks :)
13:11:03 <jle`> i'll lambdabot it
13:11:15 <jle`> and fix my typo too
13:25:43 <Boarders> hyperisco: you mentioned template haskell for doinng this, what did you have in mind?
13:25:56 <Boarders> seems like I would be writing $() everywhere which looks worse
13:27:01 <hyperisco> Boarders, well you might be able to use TH though I haven't used it in type positions before
13:27:20 <hyperisco> I was just saying if you use a macro you want it to be aware of TH, like quotes
13:27:56 <Boarders> ah I see
13:44:24 <cemerick> what is wrong with this instance, while the standalone function `what` checks out just fine? https://gist.github.com/cemerick/e8a94c279d932fbc35fa5aeccde0efc1
13:53:43 <Rembane> cemerick: I think it will work better if you in the instance say that s needs to be an instance of MVector.
13:56:25 <w1n5t0n> if I have a [(String, String)], can I not pattern match it like [(s1, s2):remaining]?
13:57:06 <amalloy> ((s1,s2):remaining)
13:57:19 <lavalike> w1n5t0n: [a] means list of 1 element, equivalently a:[], you want a:_ where a is a pair
13:57:24 <amalloy> [x,y] is a list with two items; (x:y) is a list of at least one item
13:58:09 <lavalike> @src head
13:58:10 <lambdabot> head (x:_) = x
13:58:10 <lambdabot> head []    = error "Prelude.head: empty list"
13:58:26 <w1n5t0n> sorry, I meant a list of pairs of strings, which is written like that in a type signature if I'm not mistaken
13:59:04 <[exa]> yes, but the pattern you wrote is matching type [ [ (String,String) ] ]
14:00:20 <cemerick> Rembane: s is ST or IO there though?
14:00:25 <w1n5t0n> ah I see, I got confused and thought the pattern matching on lists happens with the square brackets
14:00:49 <Boarders> it can but usually that means you are matching on a list of length 1 e.g.
14:00:58 <trcc> Does lenses offer anything in terms of updating records that are not nested?
14:01:12 <Boarders> f ls = case ls of; [] -> 0; [x] -> 1; _ -> 2
14:01:23 * hackage cal-layout 0.1.0.1 - Calendar Layout Algorithm  http://hackage.haskell.org/package/cal-layout-0.1.0.1 (bor0)
14:01:24 <Rembane> cemerick: Do you want to use it in ST or IO? 
14:01:32 <Boarders> trcc: what do you mean by that?
14:01:42 <Boarders> like is it at all worth it over just using record updates?
14:01:56 <trcc> Boarders: yes. 
14:02:12 <Boarders> trcc: I often have a type which has instances of a typeclass like HasField1 etc.
14:02:22 <trcc> I have a lot of updates to a record: i.e. state {x = y}
14:02:30 <Boarders> and then that makes it easy to refactor if I decide actually I want my record type to be split up in some way or etc
14:03:09 <trcc> could you give me an example_
14:03:09 <trcc> ?
14:03:27 <Boarders> sorry I can't at the moment as I am a bit busy, apologies
14:05:06 <trcc> no worries. Thank you for you answers still. I will look at bit more at lenses before deciding
14:05:47 <MarcelineVQ> "<w1n5t0n> ah I see, I got confused and thought the pattern matching on lists happens with the square brackets" the pattern matching is really on : the parenthesis are for the sake of parsing
14:06:54 * hackage cal-layout 0.1.0.2 - Calendar Layout Algorithm  http://hackage.haskell.org/package/cal-layout-0.1.0.2 (bor0)
14:06:59 <amalloy> cemerick: i'd ask ghci what type it thinks `what` has
14:07:39 <Lears> Suppose I want a Map-like data structure where more than one key can correspond to the same value, and that property is preserved through updates. Impurely, I could do this with mutable references e.g. `Map k (IORef a)`. Or inefficiently, I could use an assoclist like `[(Set k, a)]`. Is there a way that's both efficient and pure?
14:08:20 <[exa]> slightly unrelated-- is there a good algorithm to compute a _median_ of last K items of sequence that has quick update for getting the next value when the sequnce gets updated? Running averages are everywhere, but I could not find running medians.
14:08:22 <cemerick> amalloy: that's part of what's confused me. :i what prints:
14:08:26 <cemerick> `what :: GV.Vector (MV.MVector s) Int => Foo s -> Int -> Int`
14:09:14 <reactormonk> Lears, you could use a custom hash function that hashes multiple keys to the same inner key
14:09:56 <cemerick> I was expecting it to return `s Int`...that it doesn't means that I probably don't actually understand ST (shockingly :-P)
14:11:36 <[exa]> Lears: certainly make a two-level structure, first dictionary to a unique key and then simple key-value store (perhaps IntMap). Not necessarily a hash table.
14:11:58 <amalloy> cemerick: and what are the GV and MV imports short for? i guessed MV seems to be Data.Vector
14:12:37 <amalloy> oh, i see. MVector is both a class and a type
14:12:50 <Lears> Ah yes, that's probably the way. Thanks [exa], reactormonk.
14:13:33 <koz_> phadej: I was looking at this, and observed something: isn't your Flipped just Op from Data.Functor.Contravariant?
14:13:51 <koz_> phadej: http://oleg.fi/gists/posts/2017-12-23-functor-optics.html <-- this is what I meant to link
14:14:46 <[exa]> Lears: if you want some more elaborate sigle-level technique, you might want to see UnionFind structure
14:14:59 <c_wraith> > [(1,2),(3,4)] & traverse . _2 % show -- trcc
14:15:01 <lambdabot>  error:
14:15:01 <lambdabot>      • Couldn't match expected type ‘[(Integer, Integer)] -> b’
14:15:01 <lambdabot>                    with actual type ‘Ratio ((a0 -> f0 b0) -> [a1] -> f0 [b1])’
14:15:44 <[exa]> missing ~ ?
14:16:28 <c_wraith> > [(1,2),(3,4)] & traverse . _2 %~ show -- one missing character...
14:16:30 <lambdabot>  [(1,"2"),(3,"4")]
14:17:05 <c_wraith> trcc, that sort of updating many
14:17:30 <trcc> c_wraith: that changes the type as well?
14:17:36 <trcc> ah nvm
14:17:39 <trcc> thank you
14:19:27 <amalloy> cemerick: i think GV.! is just the wrong operation to use on an MVector, and `what` compiles by accident but has a silly type so you couldn't actually use it
14:19:51 <amalloy> but i am not very familiar with vector libraries so could be missing something - i'm figuring this just from reading the docs
14:20:33 <c_wraith> trcc, it depends on the specific optics in use. traverse and _2 do both support changing types.
14:25:22 <amalloy> or maybe it's the right operation, in which case you should give your instance the same constraints as ghc inferred for `what`: instance GV.Vector (MV.MVector s) Int => Bar (Foo s) where {...}
14:30:16 <koz_> phadej: Also, same place - your definition of Strong Endo makes use of 'first' (as opposed to first') in its definition, but I have no idea what that is or where it's from.
14:34:31 <lyxia> :t first
14:34:32 <lambdabot> error:
14:34:32 <lambdabot>     Ambiguous occurrence ‘first’
14:34:32 <lambdabot>     It could refer to either ‘Control.Arrow.first’,
14:34:39 <lyxia> % :t first
14:34:40 <yahb> lyxia: forall {a :: * -> * -> *} {b} {c} {d}. Arrow a => a b c -> a (b, d) (c, d)
14:34:41 <koz_> lyxia: Oh, the one from arrow.
14:34:47 <koz_> OK, never mind, I get it now, lol.
14:34:49 <lyxia> % :t Data.Bifunctor.first
14:34:49 <yahb> lyxia: forall {p :: * -> * -> *} {a} {b} {c}. Bifunctor p => (a -> b) -> p a c -> p b c
14:35:03 <lyxia> Bifunctor.first > Arrow.first
14:35:14 <koz_> lyxia: OK, thanks.
14:35:18 <w1n5t0n> given a .hs file of top-level code, is it possible to execute it all at once in GHCi?
14:35:18 <koz_> That clarifies things a bit.
14:36:29 <lyxia> w1n5t0n: what is there to execute?
14:37:05 <lyxia> do you mean that you have only IO actions? Or that your file is a big do-block?
14:37:24 <w1n5t0n> lyxia: some sort of IO setup code, in particular this file: https://github.com/tidalcycles/Tidal/blob/master/BootTidal.hs
14:39:25 <koz_> Also, phadej: Is it possible to define a functor optic version of Prism?
14:40:05 <lyxia> w1n5t0n: I'm still not sure what you want to do with this, can't you already load it in ghci
14:40:48 <w1n5t0n> will loading it with :load eagerly execute all lines? 
14:41:33 * lyxia looks at the word "eagerly" with suspicion.
14:42:12 <lyxia> it will start tidal and define 50 things without doing any IO.
14:42:27 <monochrom> No this is not ghci's job (unless you manually enter :main).
14:42:49 <w1n5t0n> that's the thing, I want all of these lines to be executed as if I had typed them in GHCi one by one
14:42:49 <monochrom> Use runghc if you have a script to run interpreterly.
14:43:03 <monochrom> ghci is not python.
14:43:15 <Clint> what a relief
14:43:51 <monochrom> And+But runghc expects you to have a "main" and that is the only entry point.
14:43:58 <lyxia> I know ghci does that with the .ghci file
14:44:01 <xsperry> what does python have to do with this? he wants to send file to ghci's input, including non-haskell bits like :set prompt "tidal> "
14:44:18 <monochrom> Also it won't get you very far if you think of a definition like "x = 5" to be "executable".
14:44:53 <merijn> monochrom: I think he basically wants to "replay" a series of inputs to ghci
14:45:07 <w1n5t0n> basically, yes
14:45:13 <lyxia> w1n5t0n: so it will start tidal and define 50 things without doing any IO, as I said.
14:45:48 <w1n5t0n> it will execute the first IO action though, which is necessary for the rest of the definitions
14:46:19 <lyxia> are you agreeing with what I said
14:48:55 <w1n5t0n> lyxia: I don't know, I don't think "a <- someAction" is legal Haskell code to have in the middle of a loaded source file, is it?
14:50:08 <w1n5t0n> all I'm asking is whether :load SomeFile.hs will actually run the action and bind its result to "a" or complain because do notation outside of do block is not legal in source files
14:50:43 <kadoban> w1n5t0n: It will not, unless it's some other place in the file where it's legal that I'm not thinking of.
14:50:51 <kadoban> It doesn't just run each line in ghci or anything odd
14:50:52 <monochrom> No, :load is for module files not transcripts.
14:52:04 <w1n5t0n> that's what I thought, so is there a way around that by treating the file as a series of lines to be run one-by-one inside GHCi's IO monad?
14:52:21 <monochrom> You can redirect stdin.
14:52:49 <lyxia> use the -ghci-script option
14:53:39 <lyxia> does the tidal docs not say how to run this file
14:57:27 <w1n5t0n> lyxia: at the moment it's not meant to run, just to show what should be used for boot up
14:57:49 <w1n5t0n> GHCi's ":script" seems to do what I'm looking for: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#ghci-cmd-:script
14:58:12 <lyxia> I see
15:04:52 * hackage avro 0.4.1.2 - Avro serialization support for Haskell  http://hackage.haskell.org/package/avro-0.4.1.2 (alexeyraga)
15:05:53 <bwe> Can I make a redirect with servant?
15:09:21 <jackdk> bwe I didn't see anything promising based on 5 seconds of checking hackage, but you could do it with a raw wai app, possibly using servant-rawm?
15:09:37 <mreh> bwe: can't you return a 301 with a location header?
15:10:40 <mreh> not sure how you would write the type
15:11:49 <mreh> it's technically an error so probably is unchecked
15:14:17 <mreh> failingHandler :: Handler ()failingHandler = throwError $ err301 { errHeaders = [(hLocation, "http://haskell.org")] }
15:14:20 <bwe> jackdk: The GET query returning a redirect is currently in Spock. I want to include that in the servant app instead having it alone. My aim is to have a single binary.
15:14:38 <mreh> rubbish formatting
15:15:28 <mreh> does anyone know how to write schema migrations with beam-migrate for my own datatypes?
15:16:19 <jackdk> bwe: you have have a servant app delegate to a wai Application in the same binary
15:16:25 <mreh> There's some discussion here but I'm in way over my head. https://github.com/tathougies/beam/issues/262
15:16:55 <bwe> mreh: That looks promising. So the returning type would be simply :> Get ()?
15:17:15 <suzu> the returning type could be anything for this handler
15:17:23 <bwe> mreh: I am referring to    type API
15:17:26 <suzu> because it is throwing an exception. it'll typecheck as returning whatever
15:19:12 <mreh> yeah, anything, throwError :: MonadError e m => e -> m a
15:22:41 <bwe> Alright. One more thing: I can't find hLocation on hackage doc for Servant. From which module can I import it?
15:28:25 <bwe> Okay. Got it: import Network.HTTP.Types.Header (hLocation)
15:36:31 <jle`> l
16:26:04 <koz_> jle` (or other clever folks): I'm trying to derive the functor-optic version of Prism, as per http://oleg.fi/gists/posts/2017-12-23-functor-optics.html. I've tried to specialize the one in Lens away from profunctors, but I'm not getting anywhere. Could someone throw me a clue?
16:28:27 <koz_> A sort-of related aside - why the need (as per the linked thing) for 'ASomething' and 'Something' both? For example, it defines AGetter and Getter, ASetter and Setter, etc. Is it just so that client code can avoid RankNTypes?
16:29:18 <geekosaur> worse than that, I think it requires impredicativity
16:30:26 <koz_> An example would be 'type Review s a = forall f . Functor f => Optic f s a' versus 'type AReview s a = Optic Identity s a'. Does that seriously require impredicativity?
16:30:43 <koz_> (where 'type Optic f s a = f a -> f s')
16:31:31 <geekosaur> if you re passing such as a function parameter, the function taking that parameter would need to be impredicative in that parameter, I think?
16:31:50 <koz_> So like, if you tried composing Getters versus AGetters or something?
16:32:14 <geekosaur> yes. something has tobe, effectively,"polymorphic in its rank"
16:32:33 <koz_> Ah, I get it. So then why have Getter, Review etc as such? Demonstration purposes?
16:32:44 <nshepperd> 'impredicative' is when you instantiate a type variable with something forall'd
16:32:50 <koz_> (as opposed to just defining Review as AReview, Getter as AGetter, etc)
16:32:58 <nshepperd> id (_ :: Review s a) -- impredicative
16:33:36 <geekosaur> because it's wrapped in an existential and would neeed to be unwrapped to be used
16:33:54 <nshepperd> in the other hand, writing your own function of type 'Review s a -> Foo' just requires Rank2Types
16:34:29 <koz_> geekosaur: Ah, so it's a form of safety to stop people taking apart Reviews, Getters and so forth?
16:35:59 <jle`> it's not quite safety (although RankN types are often used for safety), but it has to do with how haskell instantiates type variables
16:36:46 <jle`> for example, if you *use* a 'lens' as a getter or setter, you actually use one of its concrete instantiations
16:37:22 <jle`> however, if you want to use a lens as both a getter and a setter, you have to re-instantiate the type variable as two different things (or instantiate it as something that can serve as both)
16:37:37 <jle`> the former requires RankN types
16:37:48 <koz_> But the latter requires impredicativity?
16:37:49 <jle`> the latter is the Rank1 "trick" that the lens library uses to avoid RankN types everyhwere
16:37:56 <koz_> Oh, never mind.
16:38:04 <koz_> It's _lowering_ the requirements, not _raising_ them.
16:38:42 <koz_> So my own code should export Reviews, Getters etc for my structures, _not_ AReviews, AGetters etc?
16:39:02 <jle`> for profunctor lenses, we have `forall p. Strong p => p a b -> p s t`. using it as a getter means we instantiate p as Forget, and using it as a setter means we instantiate p as (->)
16:39:04 <nshepperd> also, note that while all Lenses are Traversals (subtyping relation), ALenses and ATraversals are monomorphic types and have no subtyping relation
16:39:20 <koz_> nshepperd: Oh, I see.
16:39:37 <koz_> Is this true of functor optics too, or just profunctor ones?
16:39:38 <shachaf> People are used to polymorphic types being more general than specific instances. But consuming a polymorphic type is less general than consuming a specific instance.
16:39:39 <jle`> but an ALens, we have GetSet a b -> GetSet s t, a specific p
16:39:54 <jle`> that can be used for both getting and setting
16:39:58 <koz_> shachaf: Yeah, because you can do less with it, right?
16:40:34 <nshepperd> koz_: i think the general rule of thumb is, use Getter in positive position, and AGetter in negative position
16:41:04 <koz_> nshepperd: Remind me what those are again? Is it that, for a -> b, a is negative position, b is positive position?
16:41:05 <nshepperd> when you're defining a getter, write "myGetter :: Getter …"
16:41:16 <shachaf> So writing "f :: (forall thing. Foo thing) -> ..." is less general than "f :: Foo SomeSpecificThing -> ...".
16:41:31 <jle`> nshepperd: "return" Lens, "expect" ALens (if you're planning on using it as both a getter and a setter)
16:41:32 <nshepperd> when you're accepting one as an argument, write "myFunction :: AGetter … -> …"
16:41:36 <shachaf> Hence nshepperd's rule of thumb.
16:41:36 <jle`> er sorry, that was for koz_ 
16:42:26 <shachaf> You should generally not demand ALens unless you want your argument to really be a lens. If you can get away with using something more specific your function becomes more general.
16:43:07 <koz_> OK, thank you, that was very helpful.
16:43:31 <koz_> Could one of you nice attractive folks also give me a hint about functor optic Prism? I'm really stuck here.
16:43:34 <shachaf> Also you probably never want to write a thing which is a Getter anyway. Just write a function.
16:44:10 <koz_> shachaf: Yeah, I realize that. I was just using it as an example.
16:45:54 <jle`> koz_: try comparing the form of profunctor lenses to profunctor prisms
16:46:04 <jle`> and seeing if you can make a similar analogy for 'functor' lenses
16:46:10 <shachaf> What's the question?
16:46:49 <koz_> shachaf: http://oleg.fi/gists/posts/2017-12-23-functor-optics.html specifies that functor optic versions of Prism and Traversal are left as exercises for the reader. I'm trying said exercise for the reader and not getting very far.
16:46:50 <shachaf> Oh, these are what I called "simple" optics a long time ago.
16:46:57 <nshepperd> I suppose usually what I actually do is just write my function 'foo l = …' assuming l is a lens, leaving off the type signature, then put in afterward whatever type signature ghc infers
16:46:58 <shachaf> http://slbkbs.org/s.hs
16:47:14 <koz_> jle`: Thank you, will try that.
16:47:19 <shachaf> This was actually quite useful for figuring out what the classes for profunctor optics should be!
16:48:02 <shachaf> The original class I came up with was class Profunctor p => Primsy p where prismy :: p a b -> p (Either b a) b
16:48:28 <nshepperd> which is usually something like 'foo :: LensLike f s t a b -> some stuff' either with a concrete f or some constraints on f
16:48:53 <shachaf> phadej: (Had you seen this?)
16:49:11 <jle`> (koz_: for some context, shachaf is one of the main people credited to formulating profunctor optics as they are today)
16:49:15 <nshepperd> but if I end up needing to use l as both a setter and getter, i get a type error which tells me I need to put in cloneLens, then the type ends up being 'foo :: ALens s t a b -> some stuff'
16:49:26 <jle`> and also for creating one of my favorite haskell puns, ForGet
16:49:37 <koz_> jle`: This is where I get confused. (profunctor) Lens is quantified over one thing, but (profunctor) Prism is quantified over two.
16:49:48 <shachaf> Oh, I guess that file gives away the exercise, so don't read it.
16:49:57 <jle`> koz_: they should both be quantified over one thing
16:50:01 <koz_> shachaf: I basically assumed that and did not read. :P
16:50:14 <jle`> koz_: the only difference is the constraint on p
16:50:24 <koz_> Yeah, it should be something like 'type Prism s a = forall f . ... -> Optic f s a'
16:50:34 <jle`> type Lens s t a b = forall p. Strong p => p a b -> p s t
16:50:46 <jle`> type Prism s t a b = forall p. Choice p => p a b -> p s t
16:50:49 <koz_> http://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-Lens.html <-- this is the lens I'm looking at, at the top.
16:50:54 <shachaf> Who wants more lens history? Before profunctor lenses, we had "symmetric lenses": forall f g. (Functor f, Functor g) => (g a -> f b) -> g s -> f t
16:51:00 <jle`> koz_: that's not a profunctor lens, that's a van laarhoven lens
16:51:02 --- mode: glguy set +v Fraus
16:51:11 <koz_> jle`: Ah, yeah, makes sense.
16:51:23 <shachaf> That's Iso. By adjusting the constraints on f and g you can get Lens, Prism, etc.
16:51:43 <koz_> phadej spelled out the functor version of Strong. So I guess I need a function version of Choice?
16:51:58 <koz_> s/function/functor/
16:52:19 <jle`> koz_: right, that's what i was hinting at
16:52:30 <koz_> jle`: OK, I'm looking at Choice here: http://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-Prism.html#t:Choice
16:52:45 <koz_> I'm guessing it'd start like 'class Functor f => Choice f where' ?
16:52:55 <koz_> And it'll have one method, not two?
16:53:11 <koz_> Something like 'choose :: f a -> f (Maybe a)' ?
16:54:44 <jle`> remember `Lens' a b` lets you treat an 'a' as '(b, c)'; you can 'factor out' a c
16:55:03 <jle`> and 'Prism' a b` lets you treat an 'a' as an `Either b c`; you can "subtract out" a c
16:55:18 <koz_> jle`: Yeah, that lines up with how Strong is defined in the link.
16:55:34 <koz_> So would I still need left' and right' then?
16:55:39 <jle`> so chooose :: f a -> f (Maybe a) might not be able to fully encapsulate that
16:56:14 <nshepperd> hmmm.. instance Functor f => Strong (Kliesli f)
16:56:30 <nshepperd> instance ??? f => Choice (Kliesli f)
16:56:46 <koz_> I'm just unsure what types those should have, since I have an f of kind Type -> Type, as opposed to their p, which has kind Type -> Type -> Type.
16:56:48 <jle`> nshepperd: ArrowPlus
16:57:04 <jle`> (as in, look at ArrowPlus for a hint)
16:57:21 <koz_> So wait, would it be something like
16:57:23 <jle`> i'm not sure if it's a particularly legal Choice though
16:57:33 <koz_> 'choose :: f a -> f (Either a b)' ?
16:57:59 <jle`> oh wait, ArrowPlus is different from Choice. i guess i mis-remembered ArrowPlus
16:58:04 <shachaf> nshepperd: You want UpStar, not Kleisli.
16:58:17 <shachaf> I mean, it's sort of the same type, but Kleisli is about monads which is kind of a different thing here.
16:58:32 <shachaf> And if you use UpStar you can see that the natural dual is DownStar.
16:58:56 <shachaf> I guess the documentation for Choice says all this.
16:59:11 <nshepperd> i didn't know about upstar, but i know kliesli :p
16:59:33 <shachaf> Strong is related to strong functors, and Choice is related to costrong functors.
16:59:48 <shachaf> But all Haskell functors are strong so you lose the distinction.
17:00:40 <Fraus> If someone is bored and want to help me I would be eternally grateful https://stackoverflow.com/questions/54031205/converting-from-one-representation-of-a-shape-to-another/54031635#54031635
17:01:55 <koz_> jle`: So, did I get it right?
17:02:07 <jle`> koz_: try it :)
17:02:26 <koz_> jle`: So what, try to write prism?
17:04:02 <jle`> mhm. or write its consumers, review and preview
17:04:29 <koz_> jle`: So 'review :: APrism s a -> a -> s' and 'preview :: APrism s a -> s -> Maybe a'?
17:04:44 <koz_> But then what's the functor version of Market?
17:04:50 <jle`> no, not APrism
17:04:59 <jle`> but with a specific instance of your Prismy typeclass
17:05:10 <koz_> jle`: You mean Choice?
17:05:11 <jle`> review :: ??? s a -> a -> s
17:05:19 <koz_> (as in, functor CHoice, not profunctor Choice)
17:05:23 <jle`> yes
17:05:34 <koz_> But that comes back to 'what's the functor version of Market'?
17:05:40 <koz_> s/'?/?'/
17:05:46 <jle`> er, review :: (?? a -> ?? s) -> a -> s
17:05:52 <jle`> you don't need the full power of Market
17:06:02 <jle`> you just need enough to write review
17:06:15 <nshepperd> i figure the basic thing here is that where profunctor lenses have p a b, van laarhoven lenses have a -> f b = UpStar f a b. so the trick is to find ??? where '??? f => Choice (UpStar f)'
17:06:43 <shachaf> nshepperd: You can't express Prism as (a -> f b) -> s -> f t
17:07:09 <koz_> jle`: So what you're saying is, figure out what thing needs to be in the '???' above?
17:07:14 <shachaf> (Easy to see because there's no way you can get (b -> t) out of it, a function :: (a -> f b) -> s -> f t has to take an s.)
17:07:51 <nshepperd> oh yeah
17:07:54 <shachaf> What you can do, which I alluded to, is (g a -> f b) -> g s -> f t
17:08:07 <shachaf> Exercise: Figure out the constraints on f/g for Iso, Lens, Prism, etc.
17:08:29 <koz_> jle`: Wait, is it seriously Identity?
17:10:36 <shachaf> It is Identity.
17:10:48 <shachaf> For one half of the prism.
17:10:57 <koz_> Yeah, I have that from the link as Review.
17:11:03 <koz_> But it's the other direction I'm not clear on.
17:24:49 <subttle_> Hi, I'm trying to make a pull request for this ticket but I'm not sure what the best way to resolve the dependency on containers-0.5.11 is for this https://github.com/roelvandijk/containers-unicode-symbols/issues/6 ? Could anyone give me some guidance? Please and thank you :)
17:25:04 <subttle_> I took care of the code part, I just need to figure out the cabal part
17:25:09 <subttle_> or if I need to use CPP
17:25:16 <subttle_> here is what I have so far
17:25:19 <subttle_> https://github.com/subttle/containers-unicode-symbols/commit/6bfc692e866f5b53471cab9204ee7ad379b9a346
17:40:57 <koz_> jle` and other friendly folks: My latest attempt. Am I on the right track? https://gist.github.com/kozross/9125ede6460d45735baa2bb3be35298e
17:43:36 <koz_> (updated to add Optic definition)
18:10:23 * hackage xmonad-vanessa 2.1.0.1 - Custom xmonad, which builds with stack or cabal.  http://hackage.haskell.org/package/xmonad-vanessa-2.1.0.1 (vmchale)
18:20:05 <koz_> OK, this isn't making any sense anymore. Am I incorrect in my definition of Choice as requiring a Functor constraint?
18:23:27 <koz_> Does it need something stronger?
18:28:03 <c_wraith> Functor is already Strong.
18:28:10 <c_wraith> ... sorry, bad joke.
18:28:29 <koz_> c_wraith: Yeah, I've heard that mentioned, but this is seriously doing my head in.
18:34:20 <iqubic> I'm not sure what Strong and Choice are.
18:34:32 <iqubic> Is that important to Haskell Coding?
18:35:04 <koz_> iqubic: I am unsure what you mean by Haskell Coding.
18:35:20 <koz_> By some arguments, I would say they're pretty damned essential, as jle` very nicely spelled out in his post.
18:36:53 * hackage Frames 0.6.1 - Data frames For working with tabular data files  http://hackage.haskell.org/package/Frames-0.6.1 (AnthonyCowley)
18:36:54 <iqubic> I haven't seen te post made by jle`
18:37:01 <iqubic> Do you have a link to that?
18:37:18 <koz_> https://blog.jle.im/entry/lenses-products-prisms-sums.html
18:37:46 <iqubic> Oh, yeah. The title makes sense.
18:38:34 <shachaf> Functor (or Contravariant?) is too strong
18:39:00 <shachaf> There's a hierarchy of classes you can define.
18:39:10 <koz_> shachaf: OK, so Invariant?
18:39:14 <shachaf> At the bottom is Invariant, with invmap :: (a -> b) -> (b -> a) -> f a -> f b
18:39:30 <koz_> I'm starting to slowly come to that realization, based on how that post defines Strong.
18:39:53 <shachaf> And you can strengthen that to fmap :: (a -> b) -> f a -> f b and contramap :: (a -> b) -> f b -> f a, and to phantom :: f a -> f b
18:40:04 <shachaf> (Figure out what "simple optics" you get from each one of those.)
18:40:12 <monochrom> I don't like prism because it converts sums back to booleans again.
18:40:30 <shachaf> But Lens and Prism are between Invariant and Functor/Contravariant.
18:40:42 <shachaf> monochrom: That's not really true. Prism s t a b = (b -> t, s -> Either t a)
18:41:14 <monochrom> The Either there is morally a boolean.
18:41:15 <shachaf> So if you match with the "s -> Either t a" half, it either gives you an "a", or it gives you a "t", which can give you a guarantee about the branch.
18:41:21 <shachaf> No, it can change the type.
18:41:43 <dibblego> @type _Left
18:41:45 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Either a c) (f (Either b c))
18:41:54 <shachaf> _Right :: Either Int Bool -> Either (Either Int a) Bool
18:42:19 <shachaf> Er, match _Right
18:42:53 <shachaf> That is stronger than a Bool. In particular you can use it as Either Int Bool -> Either (Either Int Void) Bool, and Either Int Void ~~ Int
18:43:44 <dibblego> > Left 89 & _Left %~ reverse . show
18:43:46 <lambdabot>  Left "98"
18:44:38 <shachaf> I think using Either here was confusing. But you get what I mean (?).
18:46:08 <shachaf> matching _Just :: Maybe a -> Either (Maybe b) a
18:46:14 <monochrom> It is not confusing but it is a confirmation bias.  An Either-based prism on a two-case type looks really nice of course.
18:46:40 <shachaf> I agree that it's not ideal, but it's not morally a boolean.
18:46:59 <monochrom> An prism on a 10-case ADT, say, would be illuminating on how well it scales.
18:47:25 <shachaf> It corresponds to one summand.
18:48:56 <monochrom> OK how about this.  I don't like prism because it converts sums back to chains of Eithers again.
18:49:18 <shachaf> OK, sure.
18:50:14 <koz_> shachaf: Mind having a look at my current effort and telling me if I'm totally off-base? https://gist.github.com/kozross/20e753e953fbf70d472b5c9e8f814940
18:52:43 <koz_> As an aside, is Endo a (my version of) Choice?
18:52:51 <koz_> I wrote up an instance and I _think_ it's law-abiding.
19:01:41 <koz_> Wait wait, I think I got it.
19:02:03 <nshepperd> monochrom: isn't having the Either the whole point of a prism, though?
19:02:21 <koz_> shachaf, jle`: https://gist.github.com/kozross/20e753e953fbf70d472b5c9e8f814940
19:02:24 <koz_> Did I get it right?
19:02:40 <nshepperd> if you focus on one case of a 10-case of an ADT, you have *either* the case you're focusing on, or one of the other cases
19:03:07 <shachaf> That sounds like the reason monochrom doesn't like a thing that focuses on one case!
19:03:58 <dibblego> prism is a god-send after all the trouble we had trying to achieve the same outcome with data-lens
19:04:10 <shachaf> In particular, prisms claim to be "first-class (sum) pattern matching". But they don't let you guarantee exhaustivity, which is one of the things you'd definitely want from pattern matching on sums.
19:06:48 <nshepperd> well, i don't know about that particular claim
19:09:05 <nshepperd> I can see how it would be a problem if you tried to completely replace pattern matching with prisms
19:15:22 <koz_> OK, I think I figured out Prism now. Thank you everyone who helped direct me.
19:29:14 <koz_> Now to try Traversal.
19:32:34 <jle`> koz_: did you write preview and review? :) and also 'over'/'set', but you should be able to re-use the one you wrote for lenses/setters if you define a Choice instance
19:32:43 <koz_> jle`: Let me paste what I did manage.
19:33:42 <koz_> jle`: https://gist.github.com/kozross/f95e02e67554cabdb7546e05e834e513
19:33:47 <koz_> (with Invariant for context)
19:33:53 <koz_> I had to resort to InstanceSigs to help me along.
19:33:55 <jle`> but yeah, for Review, you do use Identity, because you need review :: (Reviewer a -> Reviewer s) -> (a -> s), which implies Reviewer should be Identity, to get review :: (a -> s) -> (a -> s)
19:34:02 <jle`> you already "have" an (a -> s), the prism itself
19:34:08 <koz_> jle`: Review is already spelled in phadej's article.
19:34:20 <jle`> ah, nice
19:34:29 <koz_> I _think_ everything law-abides.
19:34:35 <koz_> Unless there's a simpler Market.
19:34:38 <jle`> now think of the newtype wrapper you need for Preview
19:34:40 <jle`> *preview
19:34:58 <jle`> preview :: (?? a -> ?? s) -> (s -> a)
19:35:05 <jle`> preview :: (?? a -> ?? s) -> (s -> Maybe a)
19:35:39 <jle`> the trick i like to use is to make `?? s` be (s -> Maybe a)
19:36:13 <koz_> So wouldn't ?? a analogously be (a -> Maybe a)?
19:36:23 <jle`> yeah
19:36:42 <jle`> newtype Previewer a s = (the rest fills in itself)
19:36:55 <jle`> newtype Previewer a s = Previewer (s -> Maybe a)
19:37:03 <jle`> sorry, not sure how to give a hint without giving the whole thing away in this case, heh
19:37:26 <jle`> but yeah, this is the general pattern I use for figuring out *all* of these newtypes
19:37:47 <jle`> you make (?? s) be a newtype wrapper over the result of the application of preview/get/set/etc.
19:37:59 <koz_> But if I wanted to write in the same style as this article, it'd have to be something of the form 'type Preview s a = forall f . ??? f => Optic f s a'?
19:38:03 <koz_> So what's ??? ?
19:40:42 <koz_> Oh wait, hold on. Is Preview s a actually Traversal s a?
19:52:16 <pie__> Um, if there's anyone with experience with generics related stuff I would really appreciate if someone could look at what I talked about in #haskell-beginners , or i could paste backlog
19:57:21 <koz_> Yeah, I'm stuck again trying to derive a functor optic Traversal...
19:57:37 <koz_> phadej: Your 'exercises to the reader' are seriously challenging. :P
20:00:43 <cemerick> amalloy: adding the same constraint as what bonks too, I get pointed at UndecidableInstances. Thanks for taking a shot tho.
20:16:53 * hackage publish 0.3.2 - Publishing tools for papers, books, and presentations  http://hackage.haskell.org/package/publish-0.3.2 (AndrewCowie)
20:19:38 <dmj`> how do I delete obsolete AWS resources w/ nixops, specifically key pairs no longer mentioned, nixops -k doesn't do it
20:19:46 <dmj`> whoops, wrong channel
20:22:20 <dmj`> nixops destroy --include <keypair> did the trick
20:23:42 <pie__> is there a name for this?: i want something like Functor for a tree but i want it to take the immediate children of a node as arguments
20:23:51 <pie__> *but i want the fmap equivalent to take
20:24:03 <koz_> pie__: Could you explain a little more?
20:24:10 <koz_> What does your tree look like?
20:32:18 <jle`> koz_: Preview is a newtype wrapper
20:32:22 <pie__> koz_, well this is pretty much the context https://bpaste.net/show/b03abaa8036c but uhh the shorter version is i want to reannotate a tree to have a superimposed hash tree
20:32:36 <jle`> koz_: not a type synonym
20:32:48 <koz_> jle`: Yeah, I get that. I'm wondering how it would be written in the style of http://oleg.fi/gists/posts/2017-12-23-functor-optics.html
20:32:51 <jle`> koz_: Previewer is in the same vein as Identity, Market, etc.
20:32:53 <koz_> (assuming it's doable)
20:33:25 <jle`> koz_: Previewer is not like Review, it's like Identity, Identity, Flipped, etc.
20:33:52 <koz_> Yeah, I get that with Preview_er_. What about _Preview_?
20:33:54 <jle`> koz_: see where 'newtype Flipped a b = Flip { unflip :: b -> a }` ?
20:34:05 <iqubic> jle`: I'm reading your post on lenses and getting my mind blown.
20:34:13 <koz_> iqubic: Join the club. :P
20:34:42 <jle`> koz_: oh, ah. well a direct way would be forall f. (f ~ Previewer a) => Optic f s a
20:34:54 <koz_> Yeah, but that's... a bit blunt. :P
20:35:05 <koz_> I assume there's some kind of typeclass constraint that would be possible here.
20:35:14 <koz_> I also get the feeling it may help me figure out how to define Traversal.
20:35:20 <iqubic> I just finished reading about how lens' s a is a witness that s <~> (s, q) with (<~>) meaning `is isomorphic to`
20:35:21 <koz_> (since I'm not sure how to even _start_ writing that one)
20:35:27 <jle`> a lot of the lens tricks are pretty much the same thing, except a little more subtle
20:35:53 <iqubic> jle`: how do you know what the type of q is?
20:36:05 <koz_> It depends on s I think.
20:36:16 <iqubic> in the witness that s <~> (s, q)
20:36:16 <jle`> iqubic: it's actually `s <~> (a, q)`
20:36:23 <iqubic> Oh. right.
20:36:28 <iqubic> But then what is q?
20:36:28 <jle`> iqubic: and the point is that s can be "factored out" into two types 
20:36:33 <jle`> so it's really the factorization you want to do
20:36:38 <koz_> This factoring doesn't have to be unique.
20:36:43 <jle`> for example, 20 can be factored out as 4 * 5
20:36:45 <jle`> but also as 2 * 10
20:36:46 <koz_> For example, consider (a,b).
20:36:49 <jle`> and also as 1 * 20
20:36:56 <koz_> Or, a better example, (a,b,c).
20:37:02 <iqubic> sure...
20:37:22 <iqubic> You have ((a,b),c) or (a,(b,c))
20:37:36 <koz_> iqubic: And (b, (a,c))
20:37:43 <jle`> iqubic: so a 'Lens s a' means that it is possible to factor out 's' as 'a * q' for some q
20:37:43 <iqubic> Right.
20:37:55 <jle`> usually whatever you pick as the 'a' will determine the q, for the most part
20:38:03 <jle`> like how if i factor out 20 into 4 * ???, the ??? will have to be 5
20:38:27 <iqubic> When you define data Len' you use forall q.
20:38:31 <iqubic> Why is that?
20:38:48 <jle`> i think i explain in the post, but it's an existential type
20:38:48 <iqubic> http://dpaste.com/3ZKP14K
20:38:57 <jle`> it "hides" the q type
20:39:01 <jle`> within the data constructor
20:39:18 <koz_> jle`: I think I might wait till phadej rematerializes and bother him. :P
20:39:20 <jle`> if we don't add the 'forall q.', then ghc will complain that q is not in scope
20:39:40 <iqubic> Right.
20:39:56 <jle`> koz_: hm yeah, figuring out constraints like that isn't something i have a mechanical method for
20:40:02 <iqubic> But I thought forall meant that you could use *ANY* q
20:40:14 <koz_> iqubic: In this case, you should read it as 'exists q'.
20:40:17 <jle`> iqubic: yeah, i think the usage of 'forall' is a bit misleading as a keyword
20:40:18 <koz_> It's confusing and annoying.
20:40:28 <iqubic> I see.
20:41:03 <jle`> it's really data Lens s a = Lens (exists q. (s -> (a, q), (a, q) -> s))
20:41:30 <iqubic> With RankN-Types when we use forall a. we mean *ANY* a
20:41:39 <iqubic> That's why I got tripped up.
20:41:44 <jle`> it trips me up too, heh
20:41:44 <coldpress> is it possible to use record syntax for recursive datatypes?
20:41:49 <koz_> iqubic: Not quite. We mean 'some a which we don't know anything about'.
20:41:53 <iqubic> coldpress: Yes.
20:41:59 <jle`> coldpress: sure, what happens when you try :)
20:42:00 <koz_> coldpress: Yeah, why ever not?
20:42:08 <iqubic> coldpress: Nothing is stopping you.
20:42:11 <koz_> iqubic, jle`: Enjoy your sodas. :P
20:42:18 <coldpress> iqubic: my brain is
20:42:23 <iqubic> what sodas?
20:42:32 <koz_> iqubic: For an example, consider runST :: (forall s. ST s a) -> a
20:42:56 <koz_> iqubic: We all said the same thing.
20:43:06 <iqubic> We don't have enough information to pin down the type of s, but we can pin down the type of a?
20:43:28 <iqubic> Where is the forall a.?
20:43:47 <koz_> iqubic: The _full_ spelling would be 'runST :: forall a . (forall s . ST s a) -> a
20:43:48 <koz_> '
20:44:00 <iqubic> Why do we need a rank 2 type thre?
20:44:06 <koz_> That _outer_ forall is 'actually' a universal quantifier, in the sense that the caller can have it be whatever.
20:44:08 <coldpress> iqubic: ok, my brain figured it out now
20:44:13 <coldpress> thanks all
20:44:23 <iqubic> but what is the inner forall doing?
20:44:24 <koz_> However, the _inner_ forall doesn't mean that - it, in fact, says that the caller _can't_ make any decisions about it.
20:44:34 <iqubic> Ah. Right.
20:44:36 <koz_> So, to rewrite it using jle`'s eminently sensible notation:
20:44:37 <rotaerk> the ST that's provided to runST could theoretically be used by runST for multiple arbitrary s's
20:44:47 <koz_> runST :: forall a . (exists s . ST s a) -> a
20:44:59 <iqubic> that makes a lot more sense.
20:45:10 <jle`> koz_: wait no, (exists s. ST s a) isn't the same thing here
20:45:20 <jle`> it has to be (forall s. ST s a)
20:45:29 <iqubic> why???
20:45:32 <nshepperd> GADT syntax seems saner there. data Lens' s a where { Lens' :: forall q. { split   :: s -> (a, q), unsplit :: (a, q) -> s } -> Lens' s a }
20:45:33 <jle`> (exists s. ST s a) means that `ST () a` is valid to pass in
20:45:55 <koz_> But isn't the whole point of this that the caller can't request a specific s?
20:46:03 <iqubic> I think so.
20:46:13 <koz_> (or, more exactly, 'smuggle' the s out)
20:46:30 <iqubic> the use of Rank2-Types in ST has always confused me.
20:46:43 <jle`> koz_: the point of the ST trick is that the caller can request a specific s, but the giver cannot specify one
20:46:51 <nshepperd> although the combination of GADT syntax with record syntax always makes me itchy
20:46:58 <jle`> koz_: the one who provides the `ST s a` can't commit to a specific s
20:47:04 <iqubic> nshepperd: Why is that?
20:47:05 <koz_> jle`: Wait, now I'm _really_ confused. How can the caller 'fish out' the s here?
20:47:14 <jle`> but the implementation of `runST` is allowed to pick whatever 's it wants
20:47:20 <jle`> hm, yeah, i guess it's a confusing who is who
20:47:28 <koz_> Isn't the whole point to avoid runSTing something with type 'ST s (s a)'
20:47:29 <jle`> runST's implementation can pick the s
20:47:39 <jle`> but the person who calls runST, and provides the ST s a, can't pick the s
20:47:52 <koz_> jle`: Yeah, that's what I meant.
20:48:19 <jle`> so `runST :: (forall s. ST s a) -> a` is the right signature
20:48:47 <jle`> but `runST :: (exists s. ST s a) -> a` is the wrong one, since that allows the person providing the ST s a to pick the s they want
20:48:57 <koz_> Ah, I see.
20:49:11 <dumbintel> vscode
20:49:27 <iqubic> I'm so confused by this conversation. I'm not even going to try and follow it.
20:49:32 <koz_> I always thought those signatures were (morally) equivalent, as it's tantamount to saying 'whoever cooked up that ST s a picked what s is, and you can't know about it'.
20:49:52 <jle`> koz_: (forall s. ST s a) means that whoever cooked up the ST s a is not allowed to pick s
20:50:03 <jle`> but whoever uses it can pick whatever s they want
20:50:13 <iqubic> Time to learn about how prisms are like sums.
20:50:34 <koz_> jle`: Just so we're clear, 'uses' means 'calls runST'?
20:50:46 <jle`> koz_: 'uses' as in, the implementor of runST
20:50:53 <koz_> Oh, OK.
20:50:56 <jle`> the person who calls runST is the person that provides the ST
20:51:05 <jle`> and the person who impelements ST is the person who uses the ST
20:51:11 <koz_> I meant 'uses' in the sense of 'calls runST to get a out'.
20:51:14 <jle`> *the person who impelements runST
20:51:20 <iqubic> UHHH??!?! [a] <~> Either () (NonEmpty a)
20:51:22 <iqubic> HOW???
20:51:24 <nshepperd> if there was an 'exists' keyword, you would be able to write 'runST :: forall a. exists s. ST s a -> a'
20:51:39 <koz_> iqubic: An empty list has nothing in it. There's only one of it.
20:51:45 <koz_> Any other list is non empty.
20:51:48 <jle`> iqubic: a "possibly empty list" is "either a non-empty list, or an empty list"
20:51:49 <koz_> The rest follows. :P
20:51:53 <iqubic> Right...
20:52:00 <jle`> so [a] <~> Either () (NonEmpty a)
20:52:07 <jle`> either it's empty (so ()), or non-empty (NonEmpty a)
20:52:20 <nshepperd> or maybe exists s. forall a.
20:52:25 <koz_> [] <~> () in the obvious way.
20:52:29 <nshepperd>  i guess it doesn't matter in haskell
20:52:30 <iqubic> jle`: You even go on to write the two functions that prove this isomporhism.
20:52:43 <jle`> yeah, so if you don't get it conceptually, you can see how the isomorphism works
20:52:53 <jle`> it might help to think of `Either () a` as `Maybe a`
20:52:59 <jle`> so it's `[a] <~> Maybe (NonEmpty a)`
20:53:37 <koz_> I _think_ Data.List.NonEmpty even provides a function with signature [a] -> Maybe (NonEmpty a).
20:53:52 <iqubic> The reason we have [a] on both sides of the (<~>) is because we have a recursive data structure.
20:54:11 <jle`> not necessarily, that's an implementation detail for `NonEmpty a`
20:54:27 <koz_> NonEmpty a could be implemented in other ways than the one they went with. It's just the most obvious.
20:55:30 <koz_> (for example, hiding a sized Vector of guaranteed length at least 1)
20:56:17 <jle`> yeah, or `data NonEmpty a = Last a | Consie a (NonEmpty a)`
20:57:01 <iqubic> Isn't that just the regular NonEmpty with the constructors renamed?
20:57:03 <koz_> Or 'data NonEmpty a = Leaf a | Internal (NonEmpty a) (NonEmpty a)'
20:57:22 <jle`> koz_: that one isn't the same, since there is too much structure
20:57:29 <jle`> iqubic: no, NonEmpty in Data.List.NonEmpty is different
20:57:35 <iqubic> How so?
20:57:37 <koz_> jle`: Yeah, agreed, but you _could_ implement it that way.
20:57:40 <jle`> data NonEmpty a = Consie a (NonEmpty a)
20:57:48 <jle`> er sorry
20:57:54 <jle`> data NonEmpty a = Consie a [a]
20:57:57 <koz_> jle`: Was about to say.
20:58:16 <jle`> koz_: i suppose, but you'd have to implement as an abstract data type
20:58:24 <jle`> and hide the constructors
20:58:29 <jle`> but true
20:58:36 <koz_> jle`: Yeah, it's not the best choice by far. But it _can_ work.
20:58:45 <koz_> (just figured I'd be needlessly clever :P)
20:58:59 <jle`> yeah, it'd just not be an algebraic data type
21:14:22 * hackage equational-reasoning 0.5.1.1 - Proof assistant for Haskell using DataKinds & PolyKinds  http://hackage.haskell.org/package/equational-reasoning-0.5.1.1 (HiromiIshii)
21:17:51 <pie__> koz_ do you have any ideas?
21:18:32 <iqubic> pie__: What are you doing here? I thought you were only in #nixos
21:18:42 <pie__> iqubic, im all over the place :P
21:19:03 <iqubic> jle`: What exactly is a profunctor?
21:19:20 <iqubic> How is `P a b` a relation between a and b?
21:19:26 <koz_> pie__: It's a lot of reading, and I'd appreciate it in a more concise form.
21:19:34 <koz_> iqubic: Look at the type of dimap.
21:19:37 <koz_> That'll give you a clue.
21:19:44 <iqubic> :t dimap
21:19:45 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
21:19:46 <jle`> iqubic: P here is just a placeholder
21:19:59 <jle`> `P a b` tautologically represents a relationship between a and b
21:20:05 <pie__> koz_, i want to reannotate a tree to have a superimposed hash tree
21:20:05 <jle`> that's just what we interpret it to mean
21:20:14 <jle`> for example, if p is (->), then we have `a -> b`
21:20:22 <jle`> (->) a b, which is `a -> b`
21:20:34 <jle`> and `->` is a "relationship between a and b", in that it is a function between a and b
21:20:43 <jle`> in short, it just depends on whatever instance we are talking about
21:21:02 <pie__> to be more specific im trying to figure out for the many-th time how to work with https://hackage.haskell.org/package/language-javascript-0.6.0.11/docs/Language-JavaScript-Parser-AST.html without going crazy, and I havent been able to figure out how to/how I should use generics
21:21:22 <iqubic> oh, right.
21:21:51 <pie__> s/going crazy/wasting tons of time writing code that doesnt even matter/
21:21:54 <koz_> pie__: What's a hash tree? Is your tree binary, rose, some other kind?
21:22:13 <pie__> its a rose tree, its an AST using the types/library in the link
21:22:16 <pie__> errrr
21:22:37 <iqubic> I usually think of a profunctor as a type that is covariant in one argument, and contravariant in the other. That way of thinking loses sight of the relationship between the two arguments.
21:22:41 <pie__> its a rose tree but specific types of children for each node. which is to say its an AST
21:22:49 <koz_> Yeah, it's a lotta patterns.
21:22:56 <koz_> So what's a hash tree?
21:23:02 <iqubic> Are there other profunctors besides (->) that are worth exploring?
21:23:37 <iqubic> :t dimap
21:23:38 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
21:23:38 <jle`> one that you might already know is `Kleisli m`
21:23:45 <pie__> koz_, i want to match substructures of two trees and the way i do that is i hash the nodes (for performance reasons mostly) and take the intersection of hashes. 
21:23:51 <iqubic> I do know of Kliesli m
21:24:09 <koz_> pie__: What's an 'intersection of hashes'? Aren't hashes just arbitrary bit blobs of a fixed length?
21:24:11 <iqubic> That's basically an embelished function.
21:24:14 <jle`> so a `(Kleisli m) a b` represents an "a to b", but in the context of m
21:24:47 <iqubic> Right. That makes complete sense.
21:24:50 <pie__> koz_, a hash contains (the information) of the structure of the current and child nodes, while ignoring any name information like variable names (so kind of like alpha equivalence i guess, but i think my case may have some irrelevant quirks)
21:25:04 <jle`> iqubic: one of my favorite standalone profunctors is `Fold`, from the foldl library
21:25:10 <jle`> where a `Fold a b` is a way of folding an [a] into a b
21:25:13 <pie__> by intersection of hashes i meant i take the intersection of the set of hashes of each tree
21:25:37 <koz_> pie__: So what you're saying is that you want the 'shape' of the tree, irrespective of what information it has in the leaves/internal nodes?
21:25:44 <jle`> so 'length' is a `Fold a Int`, and `average` is a `Fold Double Double`
21:25:46 <pie__> koz_, yeah more or less
21:25:54 <iqubic> iso :: Profunctor P => (s -> a) -> (a -> s) -> P a a -> P s s
21:25:55 <koz_> pie__: Then don't call it a hash, because that's seriously confusing.
21:26:00 <iqubic> iso = dimap
21:26:12 <pie__> koz_, ok its an implementation detail, i literally used hashes.
21:26:13 <jle`> iqubic: here's a nice article with examples of other profunctors https://ocharles.org.uk/guest-posts/2013-12-22-24-days-of-hackage-profunctors.html
21:26:24 <koz_> pie__: Anyway, let me see if I understand you correctly.
21:26:38 <koz_> Suppose I have one JSExpression which is 'JSIdentifier x y' for whatever x, y.
21:26:40 <iqubic> jle`: How the heck does "iso = dimap" make any sensie?
21:26:46 <jle`> just kidding, it only has (->) and Fold as examples
21:26:50 <koz_> And another which is JSDecimal z a in the same way.
21:26:55 <jle`> iqubic: dimap transforms both sides of the relationship
21:26:55 <koz_> Are they equivalent by your scheme?
21:27:13 <pie__> koz_, ive just been stuck on this too long and people usually dont get my problem until i go into the specifics (this is not my first attempt, i usually just run out of weekend time or something)
21:27:15 <jle`> iqubic: so you can use that to implement a profunctor transformer, P a a -> P s s
21:27:28 <jle`> you transform the input with the (s -> a), and you transform the output with the (a -> s)
21:27:29 <koz_> pie__: I'm currently trying to understand precisely what you want.
21:27:34 <pie__> yes of course, one sec
21:27:53 <iqubic> jle`: Yeah, that makes sense.
21:29:00 <pie__> koz_, i was typing too much, in short: I also need to match the data constructor
21:29:03 <iqubic> What does the Strong typeclass do exactly?
21:29:23 <pie__> koz_, which is to say, i match almost everything except certain data constructors
21:29:38 <koz_> So, the example I gave _wouldn't_ be equivalent?
21:29:43 <pie__> correct
21:29:44 <koz_> Since the data constructors are different?
21:29:48 <koz_> OK that makes sense.
21:29:48 <jle`> iqubic: it turns a relationship between 'a' and 'b' into a relationship between '(a, q)' and '(b, q)'
21:30:04 <koz_> How about this: JSIdentifier x y and JSIdentifier x z?
21:30:11 <jle`> iqubic: or, it is the typeclass of all profunctors that have this ability
21:30:15 <koz_> (where y /= z)
21:31:15 <pie__> those are equivalent by "alpha equivalence", the JSAnnot fields are not relevant to matching
21:31:17 <iqubic> jle`: Is there a similar thing for Either? taking a relation between 'a' and 'b' and turning it into a relation between 'Either a q' and 'Either b q'?
21:31:36 <koz_> OK, how about this: JSIdentifier x y and JSIdentifier x z, where y /= z?
21:31:53 <koz_> Sorry, wait
21:31:59 <koz_> OK, how about this: JSIdentifier x y and JSIdentifier z y, where y /= z?
21:32:07 <koz_> x /= z rather.
21:32:29 <pie__> they are used by the parser for annotating location information in the original file, it would benice if i can repurpose them to contain the hashes as well. I currently think it would be reasonable.
21:32:45 <iqubic> jle`: It turns out that's called Choice.
21:32:45 <pie__> koz_, yeah those should match
21:32:51 <koz_> pie__: OK, thanks.
21:33:15 <koz_> What about this: JSArrayLiteral x [] y and JSArrayLiteral x [z] y?
21:33:47 <pie__> ah, actually not sure i can repurpose the annot field without patching the library. it seems to use a hardcoded type.
21:33:59 <koz_> pie__: This is not relevant for what you are trying to do.
21:34:10 <koz_> What about this: JSArrayLiteral x [] y and JSArrayLiteral x [z] y? <-- how about this one?
21:34:52 <pie__> pretty sure those arent the same
21:34:52 <iqubic> jle`: Of all the things I have seen that try to explain lenses and prisms, your guide on relating them to isomorphisms has made the most sense.
21:35:07 <pie__> koz_, basically im trying to match pieces of javascript with renamed variables
21:35:17 <koz_> pie__: 'Pretty sure' isn't giving me too much hope, since I have nobody but you to go by. I don't know JS, _intentionally_.
21:35:32 <pie__> yeah me neither ;) 
21:35:39 <pie__> also ok, those are definitely not the same
21:35:44 <koz_> What I would suggest is this: forget implementing anything. Specify a list of rules, that is finite and clear, about what things are equivalent to what by your scheme.
21:35:49 <iqubic> jle`: Does that post of yours genralize to Len s t a b, or not?
21:35:52 <koz_> Once you have that, the implementation isn't hard.
21:36:04 <pie__> koz_, my problem is precisely with the implementation
21:36:07 <koz_> (you basically define a 'skeleton' AST type and project into it, then manipulate that)
21:36:31 <koz_> pie__: I suspect not. You can't tell me with certainty whether your scheme should treat two things as equivalent or not.
21:36:38 <koz_> This is _not_ an implementation issue as far as I can tell.
21:37:07 <pie__> I wrote this last round and I hated almost every minute of it https://bpaste.net/show/fb4913305fd4
21:37:23 <pie__> If I didnt have to write so much boilerplate I could probably figure out the exact semantics better as well
21:37:50 <koz_> pie__: Yeah, but that's precisely what I'm trying to avoid. _If_ I understand correctly, your 'skeleton' tree could be considerably simpler.
21:38:03 <koz_> Then the only place where boilerplate is required would be in the 'projection' from actual AST to skeleton.
21:38:24 <koz_> (I say 'if' because I'm not sure I get you honestly)
21:38:34 <koz_> (since I dunno JS, nor what you're trying to do beyond what you've told me)
21:39:00 <pie__> It doesnt sound wrong. but the fact that its javascript instead of some other language shouldnt matter
21:39:15 <pie__> hm.
21:39:29 <koz_> pie__: Fact of the matter is, you're working with _this_ AST, not some other one.
21:39:44 <koz_> I have no idea what it means. :P
21:41:49 <pie__> :P . with my current definition things are equivalent precsely if they are the same while ignoring JSIdentifier
21:42:21 <jle`> kkk
21:42:36 <jle`> sorry, ssh lag on vim :)
21:42:39 <koz_> pie__: ... so why didn't you just say that then? Also, it doesn't seem to gel with what you said before, 
21:42:40 <pie__> In my old python implementation I actually just replaced each instance with the variable name "a" :P
21:43:04 <koz_> Since you said that two JSIdentifiers with different JSAnnots were _also_ equivalent.
21:43:24 <pie__> koz_, * while also ignoring JSAnnot :p
21:43:49 <koz_> OK, is that _the only_ case for equivalence?
21:43:51 <koz_> No others?
21:44:31 <pie__> yes to the best of my current knowledge :P (which is rather limited)
21:44:34 <pie__> which is to say "yes"
21:44:39 <pie__> which is to say yes
21:44:40 <koz_> pie__: OK, so let's work with that.
21:44:55 <koz_> Observe that, under your constraints, for the first seven cases, we _only_ care about matching data constructors.
21:45:08 <koz_> Am I right in this regard?
21:46:13 <pie__> well no? for the various types of literals the String field should be matched
21:46:21 <koz_> ....
21:46:32 <koz_> This contradicts what you said before as well.
21:47:18 <koz_> So that means that for string literals, the contents matter.
21:47:27 <koz_> Same for decimal, hex and octal ones?
21:47:30 <pie__> sorry about the networking. for the ones other than JSIdentifier, the String field should be matched
21:47:32 <koz_> What about regexps.
21:47:32 <pie__> basically the thing to keep in mind is testing for equality up to alpha equivalence
21:47:34 <pie__> yeah
21:47:36 <pie__> yeah
21:47:40 <pie__> yeah
21:48:01 <koz_> OK.
21:48:44 <pie__> is there a reason these specifics matter so much though? my main problem (i think) it that I dont know how to traverse the tree bottom up in a sane manner
21:49:02 <koz_> I don't know why that even _matters_ in your case.
21:49:21 <koz_> I need to understand the problem you are trying to solve before I can even determine whether a solution makes sense.
21:49:47 <pie__> ok maybe we arent at the "why am i using hashes" part yet
21:49:55 <pie__> and im still in "im using hashes" mode
21:49:59 <koz_> We aren't even close. I question whether you even _need_ to.
21:51:05 <pie__> my rationale was im trying to partition two trees into sets of equal subtrees..thats a lot of equality checking to do over and over recursively
21:51:12 <pie__> im not algorithms expert though
21:51:40 <pie__> Anyway, where were we I guess?
21:51:41 <koz_> Equal subtrees? You mean 'equivalent up to alpha renaming' right?
21:51:44 <koz_> Please be specific.
21:51:53 <koz_> Muddying your own thinking using handwavey statements does not help.
21:51:58 <pie__> Yes that is what I mean
21:53:17 <koz_> Asymptotically it makes no difference - structure still needs to be preserved, so you're still bounded by node count unless you can 'cut free' whole subtrees.
21:53:31 <koz_> So I dunno what any hashing-based approach even nets you.
21:54:22 <pie__> its a pretty big tree. the JS file is like 5MB. Either my implementation was exceedingly bad (likely) or its going to take a while any case.
21:54:47 <pie__> s/its going to take a while/it's not necessarily negligible"/
21:55:07 <koz_> Your problem is that you're basically comparing every subtree to every subtree structurally.
21:55:08 <pie__> ok but i mean it doesnt matter right now, its an implementation detail
21:55:25 <koz_> That's... an awful lot of comparisons over structure _no matter what data you do or don't carry_.
21:55:34 <pie__> Ok I dont know if I made this clear:
21:56:04 <jle`> iqubic: it does generalize to Lens s t a b, but i only include the generalization in an aside
21:56:04 <pie__> the hash of each node is the hash of the hashes of its children and itself, so I'm only comparing everything once
21:56:24 <koz_> Suppose one of the trees has 11 nodes, the other 13.
21:56:30 <koz_> You still need to do 11 x 13 comparisons.
21:56:38 <koz_> Since none of your changes affect structure, only contents.
21:57:01 <pie__> Ok "everything once" is probably totally wrong, I mean I dont have to recurse on the rest of the subtree for each equality comparison
21:57:18 <koz_> How are you computing the hashes (let's say) if not by substructural recursion?
21:57:34 <iqubic> How does this function work for Either?
21:57:38 <iqubic> :t guard
21:57:39 <lambdabot> Alternative f => Bool -> f ()
21:57:56 <koz_> instance Alternative (Either e) where ...
21:58:00 <iqubic> Right.
21:58:19 <koz_> Wait, hang on.
21:58:27 <pie__> nodeHash = combineHashes $ [(hash myself)] ++ (fmap hash children)
21:58:33 <pie__> (pseudocode)
21:58:42 <koz_> pie__: Yes. This recurses on your structure, correct?
21:58:44 <pie__> yes
21:58:50 <koz_> So you're still hashing every subtree?
21:59:02 <iqubic> I have "Expr Double -> Either String Double"
21:59:05 <iqubic> evalFunc (ASinF x) = do {y <- asin <$> x; guard (not $ isNaN y); return y}
21:59:10 <pie__> and the reason (with this specific implementation) I want to build the tree bottom up is then i only have to build everything once
21:59:16 <iqubic> That type checks, but I'm not sure why.
21:59:32 <pie__> s/build/traverse/ (I accidentally a word again)
21:59:59 <pie__> and the reason (with this specific implementation) I want to build the tree bottom up is then I only have to traverse the entire tree once to build up the hashes.
22:00:00 <iqubic> http://dpaste.com/0KTJNPK Why does this typecheck, and what is this actually doing?
22:00:03 <koz_> OK, let's think about this. You have a tree. It has a root node with 5 children. Each of those children has has 10 children.
22:00:11 <koz_> How many hashes do you have to compute?
22:00:26 <pie__> 16?
22:00:40 <koz_> pie__: Please read carefully.
22:00:56 <pie__> Ok rationale:
22:02:38 <koz_> iqubic: I share your confusion, because as far as I can tell, (Either e) doesn't have an Alternative instance I can find.
22:02:57 <iqubic> Right.
22:03:08 <iqubic> But my thing still manages to typecheck.
22:03:36 <pie__> koz_, sorry, I was thinking the right way and did the wrong things. Tired + cold. I hash each leaf node: thats 5*10 = 50 (I only counted 10 here); the magic algorithm passes up the hashes to the parent node which computes "combineHash [myself] ++ myLeavesHashes": thats another 5; and similarly 1 for the root
22:03:40 <pie__> which is 56
22:04:03 <koz_> pie__: OK, and you need a tree that stores all 56, along with the structure.
22:04:11 <koz_> But then, you have another tree.
22:04:24 <koz_> Let's say, for the sake of argument, it has a root with 3 children, each one of which has 20 children.
22:04:31 <koz_> You now need to compare the hashes.
22:04:37 <koz_> How many comparisons will you have to make?
22:04:45 <pie__> currently Im actually just using IO with a mutable map so I dont explicitly build a second tree.
22:04:52 <koz_> pie__: This is not relevant.
22:04:58 <pie__> ok.
22:04:58 <koz_> Whether you build it or not you gotta hash anyhow.
22:05:01 <pie__> yeah
22:05:07 <iqubic> koz_: If I run this function and give asin an invalid argument, I get Left ""
22:05:09 <pie__> one sec
22:05:31 <iqubic> koz_: I have no idea how this Left "" came to be.
22:05:33 <jle`> iqubic: note that there is no canonical Alternative instance for Either, so using guard with Either is pretty shaky
22:05:43 <koz_> jle`: So where does this get its instance from?
22:05:49 <koz_> That's the part I couldn't figure out.
22:06:02 <jle`> there's an orphan instance defined in the 'transformers' library
22:06:12 <pie__> koz_, I will have to make as many comparisons as intersection(tree1hashes, tree2hashes) and I dont know how many comparisons the ideal algorithm does for that but I trust the implementation
22:06:16 <iqubic> I don't have transformers imported.
22:06:22 <jle`> it sort of pollutes the entire ecosystem
22:06:28 <jle`> iqubic: instances are global
22:06:31 <pie__> koz_, alternatively, n*m
22:06:38 <koz_> Where n and m are what?
22:06:38 <jle`> so if anything you use imports transformers, then you have it in yours
22:06:51 <pie__> koz_, the number of nodes in each tree
22:07:00 <iqubic> I'm not sure which of these imports is to blame. http://dpaste.com/1KNG96N
22:07:03 <koz_> pie__: Can you see why, irrespective of what you do, you're still gonna have a bad time?
22:07:21 <pie__> koz_, sure. but the difference between 1 minute and 10 minutes is still significant
22:07:30 <jle`> iqubic: recursion-schemes depends on transformers
22:07:34 <iqubic> Ah.
22:07:41 <pie__> koz_, but regardless, I'd be happy if i just had sane looking code for starters
22:07:45 <koz_> jle`: Does transformers define an instance?
22:07:49 <jle`> yes
22:07:53 <jle`> an orphan instnace
22:08:10 <koz_> jle`: Ah. I assume something to the tune of 'instance (Monoid e) => Alternative (Either e) where ...'?
22:08:16 <jle`> worse :)
22:08:20 <koz_> Wait _worse_?!
22:08:27 <iqubic> What is worse???
22:08:46 <iqubic> evalFunc (ASinF x) = do {y <- asin <$> x; guard (not $ isNaN y); return y}
22:08:50 <jle`> i won't ruin the surprise
22:09:16 <koz_> pie__: So what you need to do is basically this. Define a HashTree type, which has different constructors for nodes of different arities, as per the JSExpression, and stores a hash in each node.
22:09:28 <koz_> Then write a function to project a JSExpression into a HashTree.
22:09:37 <iqubic> So I want to do something like that, but where x :: Either String Double. And I want to be able to provide my own error string upon getting the result of NaN.
22:09:39 <koz_> Then you'll have something considerably saner.
22:09:48 <jle`> iqubic: guard False _ = empty; guard True x = pure x
22:09:56 <jle`> iqubic: you can use evalFunc with `Maybe`
22:10:01 <jle`> and then convert the Maybe into an Either
22:10:12 <koz_> jle`: Wtf is 'Error e'?
22:10:23 <koz_> Oh dear sweet Jeebus.
22:10:49 <iqubic> koz_: Care to give me the header?
22:10:59 <koz_> iqubic: Basically, it's a typeclass with zero laws.
22:11:05 <iqubic> jle`: I'm not sure what you are talking about.
22:11:10 <pie__> koz_, how do I write the function so that I dont have to write 500 lines of code that just swaps the data constructors
22:11:18 <koz_> So its implementation is 'lol it typechecks'.
22:11:24 <jle`> iqubic: right now evalFUnc is defined to work for all (Monad m, Alternative m)
22:11:47 <koz_> pie__: The first seven cases collapse into one.
22:11:50 <iqubic> Well, no, actuall.
22:11:50 <koz_> (just for starters)
22:11:59 <koz_> Yeah, you need a large pattern match, but at least you only need it _once_.
22:12:00 <jle`> iqubic: so you can use it with Maybe
22:12:06 <iqubic> I know that.
22:12:07 <jle`> iqubic: and then do whatever you want with the Maybe
22:12:14 <iqubic> I have actually used it with maybe.
22:12:18 <jle`> right
22:12:24 <koz_> jle`: You are right, it's worse.
22:12:26 <jle`> then you can take that Maybe and do whatever you want with it
22:12:36 <iqubic> jle`: I'm converting my code from using Maybe to using Either.
22:12:38 <jle`> you can pattern match on Nothing and return Left "myTHing"
22:12:42 <pie__> koz_, I think thats kind of dumb? /semantically/ I dont care which data constructor it is, do my code shouldn't either?
22:12:47 <pie__> s/do/so/
22:13:02 <koz_> pie__: You _just said_ that different JSExpression constructors aren't equivalent?
22:13:02 <jle`> iqubic: case evalFunc myThing of Nothing -> Left "hi"; Just x -> Right x
22:13:08 <koz_> Which assumes they'll have different hashes.
22:13:19 <koz_> (if we're still going by the definition of 'hash' that I understand)
22:13:52 <koz_> So no, semantically, you _very much_ care.
22:14:23 <pie__> koz_, ok I think I misunderstood you somewhere but we should still be in agreement about what I want to do. Let me think for a moment.
22:15:31 <pie__> koz_, I dont understand why I need to hash different data constructors differently
22:15:44 <koz_> pie__: Because you _just said_ that they are not equivalent.
22:15:58 <pie__> except for JSIdentifier which is a special case and gets the same value everywhere
22:16:24 <pie__> koz_, they are not equivalent so the values of the hashes should be different, but the algorithm for the hashing is the same.
22:16:35 <koz_> I'm not talking about the algorithm.
22:16:39 <koz_> You gotta feed _something_ to it.
22:16:55 <koz_> So I assume that you'll feed something _different_ to it depending on which data constructor you're getting.
22:17:23 <pie__> didnt Typeable have something that gives you the name of a data constructor as a string
22:17:42 <pie__> That one fact is approximately my level of knowledge on generics.
22:17:50 <koz_> pie__: Yeah, you could do this with Typeable, potentially.
22:17:58 <iqubic> jle`: I'm usin recursion-schemes here to implement an evaluator for a mathematical AST.
22:18:05 <iqubic> http://dpaste.com/
22:18:06 <koz_> You could do it with Generic too, potentially.
22:18:12 <iqubic> http://dpaste.com/0YCHCDX
22:18:33 <koz_> I dunno how either of those work for something like this though. To say nothing of the fact that JSExpression implements neither.
22:19:02 <iqubic> And I want to rewrite asin to return Left "ERROR" if asin return NaN.
22:19:11 <pie__> koz_, it has Data. but I can just hack DerivingSomethingorother into the file and it should work? :/
22:19:32 <iqubic> But if x is Left when passed as the input, I want to just propegate that down the chain.
22:20:12 <koz_> pie__: ... generally speaking, we don't modify other folks' modules like that. You certainly _can_ derive Typeable or Generic that way, but I wasn't assuming you wanted to fork language-javascript.
22:20:17 <iqubic> It worked with Maybe, because there is an Alternative instance for that. But I'll need to do something else for Either here.
22:21:18 <pie__> koz_, fair enough, but it probably brings me closer to what I'm imagining as "sane".
22:22:21 <pie__> if its the difference of 100 boilerplate lines or a single deriving in upstream that doesnt do weird things to semeantics...I'll probably add the deriving. and it's mostly a hobby project anyway.
22:22:40 <pie__> I mean my project is mostly a hobby project.
22:22:58 <pie__> but yeah I don't know how to use generics at all which is probably how I ended up here.
22:23:36 <koz_> pie__: You'll still need to construct a HashTree structure even then.
22:23:41 <pie__> I'm not against the skeleton idea though.
22:24:04 <iqubic> jle`: I'm not sure what I should do with my code here.
22:24:19 <koz_> Yeah, the JSExpression -> HashTree function might be easier to write (for some definition of 'easier') if you hack a Generic derive into your fork.
22:24:30 <koz_> But that doesn't save nearly as much work as you might think.
22:25:03 <koz_> (I also have to ask - why pick a language as complex as JS for this?)
22:25:17 <pie__> koz_, because I want to apply this to an actual codebase.
22:25:23 <pie__> I mean a specific codebase.
22:25:56 <jle`> iqubic: pattern match on the result
22:26:00 <jle`> as a Maybe
22:26:02 <jle`> and return an Either
22:26:40 <koz_> pie__: So what do you need to do an alpha-renaming equivalence class breakdown on two different JS expression trees for?
22:26:49 <koz_> It seems like an awfully specific thing to want.
22:27:32 <iqubic> jle`: What does that mean?
22:28:03 <iqubic> cata states that the type of x will be Either String Double.
22:29:01 <pie__> koz_, meh. deobfuscation based on older unobfuscated code :P
22:29:21 * koz_ wonders how exactly this will help deobfuscation.
22:29:36 <koz_> Obfuscation is usually structural to mean much of anything.
22:29:44 <pie__> A lot of things are intact other than variable names.
22:30:15 <koz_> You're 100% sure that the two are structurally the same that aside?
22:30:25 <pie__> not completely but sufficiently
22:30:25 <koz_> Or is this something you seek to find out?
22:30:36 <pie__> i mean they are sufficiently similar
22:30:40 <pie__> not that i am sufficiently sure they are
22:30:42 <koz_> What does that even mean?
22:30:56 <pie__> the code does not match completely but there are large stretches that should match
22:31:38 <koz_> Well, for what it's worth, I still recommend manual construction over forking an existing codebase just for this.
22:31:43 <koz_> Your mileage may vary.
22:31:44 <MarcelineVQ> are you wanting to do AST diffing?
22:31:59 <koz_> MarcelineVQ: Modulo alpha renaming, on every subtree.
22:32:02 <pie__> MarcelineVQ, kiiiind of?
22:32:05 <koz_> (at least, that's how I understood it)
22:32:20 <pie__> MarcelineVQ, not sure if I've complained to you about this yet. It's possible :P
22:33:04 <pie__> I've been sitting on this for a year.
22:33:06 <MarcelineVQ> Once or twice in different stages but I didn't have useful input
22:34:01 <unyu> Maybe this is a stupid question, but, does anything too terrible happen if I use a partially ordered type rather than a totally ordered one as the key type of a heap?
22:34:05 <pie__> koz_, once those stretches are found, due to a quirk of the compiler, it should possible to reapply the name mappings gained from the matching, to the rest of the file.
22:34:31 <pie__> koz_, also i just thought of a semi-massive optimization for the equality checking. 
22:34:36 <MarcelineVQ> Not an opinion on your problem, I just rarely have useful input :> AST diffint is a neat subject though, and sufficiently generalized would be useful for a lot of things. especially with alpha renaming machinery, ghc core diffing would be an application with broad benefits
22:34:45 <koz_> unyu: What should the heap do when confronted with incomparable keys?
22:34:45 <unyu> If the type is partially ordered, I still want to ensure that “a < b” implies “a” is retrieved before “b”, but I don't care about the relative retrieval order of two elements unrelated by the partial order.
22:35:05 <pie__> MarcelineVQ, <3
22:35:15 <koz_> Also,given that Ord is a total order, and all the heap implementations I know use Ord, I'm not sure what you're up to.
22:35:32 <koz_> pie__: Do share.
22:35:32 <pie__> MarcelineVQ, see the quirk about for why this is more useful for me than it would otherwise probably be
22:35:41 <pie__> koz_, sorry, too many things, one sec xD
22:36:39 <pie__> koz_, I've known about it but didn't know of a good way to do it. If you have a large subtree, you will also match its sub-subtrees. That's a lot of extra things to check. If you can check for equivalences top-down somehow, that should optimize things somewhat.
22:37:15 <pie__> Hm. However, I don't know how to make that similar to set intersection. I guess traverse one tree top down and check if the hash is in the set of the hashes of the other tree.
22:37:34 <koz_> You're still doing n * m comparisons.
22:37:38 <koz_> I don't see what you save or how.
22:37:41 <pie__> Ok in all that I failed to actually make the point
22:37:44 <pie__> sorry
22:37:56 <pie__> I mean you dont have to check any of the child nodes of a parent node that has matched
22:38:01 <unyu> koz_: I mostly just want to know if the usual heap data structures can withstand this broader requirement.
22:38:17 <koz_> unyu: If you define a tie-breaker, then yes, but then you've basically got a total order anyway if you're consistent.
22:38:37 <pie__> once a parent node has matched, you can remove all the children from both trees for the search
22:39:06 <unyu> Mmm. This is going to be problematic, then.
22:39:09 <koz_> Suppose you have parent nodes u and v that you've found equivalent by this.
22:39:18 <koz_> What if u has a subtree that is equivalent to a subtree of v?
22:39:27 <pie__> which has the advantage that you dont get a bunch of redundant results that you want to filter later anyway.
22:39:47 <pie__> koz_, if u and v are equivalent, all their subtrees are equivalent. (right?)
22:39:49 <unyu> Yeah, I can see the problem.
22:39:59 <unyu> I guess there's no way around defining a total order, then.
22:40:02 <unyu> Then that's it.
22:40:08 <koz_> pie__: Yes, but not necessarily to each of each other.
22:40:11 <koz_> You still have to check.
22:40:46 <pie__> koz_, well, you're not wrong. But I don't think I actually need those results.
22:40:46 <koz_> unyu: I'm not the _most_ heap-knowledgeable human being on the planet, but all the heaps I know require a way, given two keys, to decide which is 'first'.
22:40:54 <koz_> pie__: You never said that.
22:41:13 <pie__> koz_, well, I'm not sure why I would need them. If I need something, they will be in the same place in both trees
22:41:24 <koz_> How can you be so sure?
22:41:35 <koz_> There appear to be a lot of unstated assumptions.
22:41:48 <pie__> because they are the same up to alpha equivalence?
22:42:12 <pie__> I did however think of a (i think) different problem.
22:42:12 <koz_> Suppose u and v in the example above are binary nodes for the sake of argument.
22:42:27 <pie__> (which i will state once we finish this train of thought)
22:42:35 <pie__> ok
22:42:50 <koz_> Suppose both subtrees of u are equivalent to both subtrees of v.
22:43:05 <koz_> Do you not care that you have four equivalences here in addition to the one between u and v itself?
22:43:11 <pie__> * koz_, well, I'm not sure why I would need them. If I need something in the subtrees of the matching nodes, the thing I want will be in the same place in both subtrees
22:43:46 <koz_> My example states that you'll have that thing in _both_ subtrees, unless there's more happening _after_ you find these equivalences.
22:43:53 <pie__> yeah I'm thinkn
22:43:55 <koz_> Like, honestly speaking, I am totally lost about your assumptions at this point.
22:45:38 <pie__> xD I just realized I completely lost sight of my true original problem. The true original problem is to find the mapping from obfuscated JSIdentifiers to nonobfuscated JSIdentifiers. The structural matching is my way of acquiring this mapping.
22:45:48 <unyu> The fundamental problem seems to be that the underlying data structure is a tree or forest, which necessarily have a direction “towards the root”.
22:45:53 <jle`> iqubic: how are you using cata
22:46:11 <koz_> unyu: It's more fundamental than that.
22:46:19 <koz_> (binary heaps aren't typically implemented as trees for example)
22:46:31 <unyu> It's logically a tree.
22:46:34 <koz_> You must, at _all_ times, be able to state, of any non-empty heap, 'what is the lowest element?'.
22:46:48 <koz_> If you don't have a total order, this question becomes impossible to answer consistently without one.
22:46:55 <koz_> s/without one//
22:47:15 <koz_> Whether you implement is a tree physically, logically or whatever else doesn't change that basic fact.
22:47:34 <pie__> koz_, but to answer your question, I don't think I would care if theres cross-matches within a larger match.
22:47:38 <pie__> HOWEVER
22:48:04 <unyu> koz_: If the element type is partially ordered, I want findMin to return a minimal element w.r.t. the partial order.
22:48:41 <unyu> Specifications that don't uniquely determine a behavior are totally okay.
22:48:47 <koz_> unyu: What if your only elements are incomparable?
22:48:53 <pie__> If I delete the child matches from both the source and the target trees, I would prevent smaller finding matches in other trees. So I probably should do that some other way. 
22:48:57 <unyu> Then anything can be returned!
22:49:06 <unyu> All the more freedom for the implementor.
22:49:13 <pie__> anyway this is all largely irrelevant if I never write any code that even has the minimal functionality so I need to start with that...
22:49:13 <koz_> unyu: Then you can define the tiebreaker as 'always take whichever one happens to come first'.
22:49:18 <koz_> Or 'pick randomly'.
22:49:24 <dmwit> koz_: If all the elements are incomparable, then all the elements are minimal...
22:49:40 <dmwit> koz_: A nondeterministic semantics seems cleaner to me than one with an explicit tiebreaker.
22:49:47 <koz_> You still technically have a total order then - it just depends on the state of the PRNG.
22:49:55 <koz_> (or the universe in less pure languages)
22:50:03 <dmwit> what
22:50:05 <unyu> I don't really need a PRNG.
22:50:25 <koz_> dmwit: When you call findMin on a heap with two incomparable elements, which one do you give back?
22:50:37 <unyu> Even in an ordinary heap, what you actually have is a weak total order on the element type (i.e., a total order on equivalence classes).
22:50:38 <koz_> If it's nondeterministic, you still have to give back _something_ somehow. ANd only one something at that.
22:50:42 <dmwit> koz_: implementation defined
22:50:58 <dmwit> Two different implementations can make different choices while still adhering to the spec.
22:51:15 <koz_> dmwit: Sure, but your implementation will still have to define _some_ order.
22:51:20 <koz_> Even if it's 'pick randomly'.
22:51:36 <dmwit> The implementation must make a choice, but the specification need not.
22:51:36 <c_wraith> let me see if I am thinking about this properly - a partial order is essentially a DAG, and sorting by that order is the same as a topological sort of the graph?
22:51:50 <koz_> c_wraith: As far as I understand partial orders that sounds right.
22:52:16 <koz_> dmwit: As far as I was aware, this was a question of implementation, not specification.
22:52:20 <koz_> Maybe I was wrong.
22:52:21 <dmwit> What's more, the implementation's choice might not be consistent.
22:52:29 <unyu> ^
22:52:36 <dmwit> Perhaps the order that the elements got inserted influences the choice it makes, e.g.
22:53:06 <koz_> I mean, if consistency isn't important to you, then I guess it's possible. I clearly misunderstood the question then.
22:53:40 <c_wraith> unyu: it seems like the fact that most heaps use only local comparisons is going to cause problems.
22:54:53 <unyu> c_wraith: That's what I'm afraid of. :-|
22:56:35 --- mode: glguy set +v shwetaahuja
