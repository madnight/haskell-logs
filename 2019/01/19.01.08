00:03:13 <maerwald> dminuoso: https://github.com/elm/compiler/issues/986#issue-94421347 there was some reasoning for removing them completely
00:04:13 <maerwald> But not very strong reasoning imo
00:08:36 <nyc> maerwald: Very alien design goals and code aesthetics for me.
00:08:55 <maerwald> Well, there are design goals ;)
00:12:04 <dminuoso> If you limit the language in what you can do so beginners don't get confused, you automatically limit your experienced users in what they can accomplish however.
00:13:27 <dminuoso> But I guess there's a large trend of that since Go hit the scene.
00:15:32 <nyc> dminuoso: I'm unfamiliar with Go.
00:17:28 <maerwald> dminuoso: I would say it's the other way around. Experienced users now how to get around missing language features and what to do instead. It's inexperienced users who are confused about feature XY missing, because Java, C#, whatnot has it
00:17:36 <dminuoso> nyc: Go is designed on the premise to be as easy to learn as possible, so Google can hire people straight out of school with little training. The ceiling is intentionally kept so low in order to allow new employees to instantly read code of your senior developers.
00:17:53 <dminuoso> I say this without any feelings, since this was really the reason behind it.
00:17:59 <dminuoso> And it's fair enough I guess, I can understand the motivation.
00:18:35 <dminuoso> maerwald: You are only a beginner for a short amount of time, and experienced for the rest of the time. Catering a language to be easy to learn instead of powerful to use is shortsighted in my eyes.
00:18:52 * hackage versioning 0.3.1.0 - Type-safe data versioning.  http://hackage.haskell.org/package/versioning-0.3.1.0 (lortabac)
00:20:15 <dminuoso> Elm is trying to pierce the veil of "fp languages having a bit of a bad/hard rep" by trying to look easy. So it's not designed to create good code, but to attract many people.
00:20:38 <Bish> dminuoso: o/
00:20:43 <maerwald> If you cater a language primarly for "Powerful to use", you end up with C++ where you have to read an entire blog post to understand a line as simple as 'A = std::move(B)'
00:20:55 <dminuoso> I do not consider C++ to be powerful.
00:21:05 <dminuoso> C++ is just an organic mixture of bad design.
00:22:02 <maerwald> Also, if you think go is easy to learn: https://allegro.tech/2017/07/golang-slices-gotcha.html
00:22:22 <[exa]> maerwald: c++ is for people who can read the 2-line description of std::move in the standard ;]
00:22:25 <trcc> I am having a fall-out with the haskell type system. https://gist.github.com/CThuleHansen/f7d0733e88a1ec04dcfb2c7b24d20c0a impurePreComponentHandler :: FMIT.FMUStateType a -> (FMIT.FMIComponent a -> IO b) -> IO b works, while impurePreComponentHandler :: FMIT.FMUStateType a -> (FMIT.FMIComponent a -> b) -> b does not work. And I do not understand why. Both should just unify to the same types? or is it because FMIT.FMUStateType a lives in 
00:22:25 <trcc> the IO monad?
00:22:46 <nyc> I don't know. Language design isn't my specialty, though I could really use something like C but in continuation-passing style instead of a stack discipline.
00:23:01 <maerwald> nyc: Mars!
00:23:38 <lyxia> trcc: that do block has type (IO _)
00:23:41 <nyc> maerwald: That sounds hard to Google. Link?
00:24:06 <lyxia> trcc: and you're saying it has type b for whatever b the caller might choose
00:24:16 <maerwald> nyc: https://mars-lang.appspot.com/
00:24:58 <trcc> lyxia: but why does it not just choose IO b0 to stand for b?
00:25:39 * Bish read a bit elm and doesn't get how this is cool(er)
00:25:46 <nyc> maerwald: I'd need it to be first-order.
00:26:10 <lyxia> trcc: because that's not for the implementation to choose what b can be.
00:26:53 <trcc> hmm. I just find it weird, that to compile, b must be IO b0. Then why not make that unification, when nothing else prevents it?
00:27:03 <lyxia> trcc: for a simpler example, why does   foo :: a ; foo = 3   not compile
00:27:04 <dminuoso> trcc: `forall b. ... b` means *for any possible choice of b* (that the caller can make)
00:27:43 <dminuoso> trcc: If you claim something has type `b`, then the caller can without limitation pick *any* type. Int, `IO String`, `YourCrazyTypeWithNoConstructor`
00:27:57 <lyxia> trcc: what prevents it is that what you wrote does not mean what you think in Haskell
00:28:27 <trcc> Thank you both. I think I understand
00:28:36 <lyxia> and the compiler is asking you to clarify what you mean instead of taking a wild guess
00:29:42 <dminuoso> I take it a non-rigid type variable would be one inferred/instantiated by GHC?
00:30:26 <dminuoso> At least based on SPJs definition of "rigid type variable" in https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/gadt-pldi.pdf
00:31:14 <rts-sander> how do I curry a function by filling the 2nd parameter not the first
00:31:40 <maerwald> try lambda
00:32:21 <dminuoso> rts-sander: `flip f x`
00:32:32 <dminuoso> rts-sander: or maybe a section.
00:32:42 <rts-sander> cheers lambda works
00:37:53 * hackage hpqtypes-extras 1.7.0.0 - Extra utilities for hpqtypes library  http://hackage.haskell.org/package/hpqtypes-extras-1.7.0.0 (MikhailGlushenkov)
01:02:22 * hackage salak 0.1.5 - Configuration Loader  http://hackage.haskell.org/package/salak-0.1.5 (leptonyu)
01:16:10 <asheshambasta> Hi Haskell; how can I tackle something like this? https://gist.github.com/asheshambasta/6c008671e4ff342d3a01aac5e6123a56
01:26:29 <julianleviston> a class can have type aliases in it?
01:27:15 <julianleviston> ah, type families.
01:28:37 <julianleviston> section 5 in https://wiki.haskell.org/GHC/Type_families “associated type synonyms”. 
01:29:41 <julianleviston> asheshambasta: what is Bar’ and Baz’ ?
01:29:51 <julianleviston> asheshambasta: is that template haskell magic?
01:31:00 <comerijn> No, it's DataKinds
01:31:20 <julianleviston> Ah. I have so much to learn still.
01:32:36 <comerijn> asheshambasta: hmm, I'm honestly not sure whether it should work (although I know I'd like it too...)
01:32:58 <julianleviston> but why the single quote tho?
01:33:20 <comerijn> julianleviston: DataKinds lets you lift values to types, but the lifting can be ambiguous
01:33:26 <comerijn> the single quote disambiguates
01:33:37 <julianleviston> Ok. I’ll read more.
01:34:10 <julianleviston> Oh… it’s saying “this is definitely a value”. ok gotcha.
01:34:14 <julianleviston> https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/promotion.html
01:34:48 <comerijn> julianleviston: Those are really old docs, 7.8, might wanna go to a newer GHC version ;)
01:34:59 <julianleviston> :shrug: seems to be correct still, but thanks.
01:35:25 <comerijn> asheshambasta: You can try making it "instance (FromJSON (Output t)) => SomeClass (Input t) where" which I think should work in this case
01:35:39 <comerijn> asheshambasta: Might wanna mail haskell-cafe to check if this should work or not (and if not, why)
01:43:47 <xsperry> hi
01:44:07 <asheshambasta> julianleviston: there seem to be discrepancies in the old and new docs for GADTs for example
01:44:24 <xsperry> do lenses have some special code made for use with monad transformers?
01:44:35 <merijn> A bunch has changed, but not everything
01:44:54 <merijn> So it's not like stuff from 7.8 is *completely* wrong, but it's also not *completely* right :p
01:46:27 <asheshambasta> merijn: okay, I'll mail Haskell-cafe, to me this seemed like a pretty basic use case of type families. 
01:47:52 <merijn> asheshambasta: Like I said, I would *like* this to work, but I'm not sure what the reason it doesn't is. Hell, it might just be a GHC bug, where's its not correctly figuring out that kind Foo is Finite
01:48:02 <merijn> asheshambasta: Did you try adding the FromJSON constraint to the instance I suggested?
01:49:29 <asheshambasta> merijn: just did, and that "fixes" the problem
01:49:35 <asheshambasta> I don't know how, though. 
01:49:48 <lyxia> this can't work because GHC doesn't know how to decide whether to use the Bar or the Baz instance.
01:50:18 <asheshambasta> lyxia: yeah, I guess thats a better way of saying what I was hoping GHC would know
01:50:42 <merijn> asheshambasta: Basically you KNOW that all options (Bar and Baz) fullfill that constraint
01:50:57 <merijn> asheshambasta: But the class resolver doesn't have the logic to figure that out
01:51:28 <merijn> asheshambasta: Adding the constraint says "this instance only exists if this FromJSON instance exists" which is fine, 'cause you know it exists for both Bar and Baz
01:52:09 <merijn> asheshambasta: So instead of the resolver having to figure out "this will always be true" you tell it "only worry about the cases where this is true", which in your code has the same effect. It's not great, but I think it's a workable workaround for you
01:52:50 <asheshambasta> merijn: okay, understood; if I don't have a FromJSON instance for a particular data constructor of my Foo sum-type, using that for this typeclass would result in a compilation error. 
01:52:58 <asheshambasta> This is what I was trying to achieve, yes. 
01:55:30 <lyxia> knowing there's always an instance is not sufficient to be able to use it when you need it.
01:55:32 <merijn> asheshambasta: Right, if you try to use the class where FromJSON doesn't exist it will still fail at compiletime, because SomeClass instances won't exist (as it requires a FromJSON on the result)
01:56:04 <asheshambasta> lyxia: I'm not sure I follow 
01:57:12 <lyxia> basically you have  Value -> Output 'Bar   and   Value -> Output 'Baz   but that doesn't allow you to write   forall t. Value -> Output t   because you need to know what "t" is to decide which function to use.
01:58:19 <merijn> lyxia: Except you can in this case
01:58:23 <lyxia> you might want to do a case analysis on t, but that means you have to pass t at runtime
01:58:26 <merijn> lyxia: Because Foo is a closed size count
02:01:23 <lyxia> the problem is how you are going to compile that
02:01:48 <lyxia> This is not compatible with the way GHC erases types.
02:02:34 <lyxia> You could do specialization but that comes with other trade-offs that GHC did not choose to make.
02:04:40 <asheshambasta> The problem for me here was (as a beginner at type-level Haskell): the "fix" as merijn suggested seems counter-intuitive to me, which is fine and also highly subjective. To me, since the sum-type was "given" to GHC, and so were all the typeclass instances for all the types, it seemed to me that I was providing GHC with sufficient information to deduce this without problems. 
02:05:54 <merijn> asheshambasta: "given enough information" /= "someone has actually figured out how to implement the deduction logic" :)
02:06:46 <asheshambasta> Fair point, and like I said, my perception is highly subjective here. 
02:08:29 <asheshambasta> And maybe, its also being a little spoilt by GHC; (my only reference is Scala here) so far, I'm incredibly impressed with GHC. 
02:08:30 <merijn> asheshambasta: Keep in mind, you're at the cutting & bleeding edge of GHC here ;)
02:08:50 <merijn> There's a reason it's called the cutting edge, because you're gonna get cut playing with it ;)
02:08:59 <lyxia> IMO that's not a workaround, you have to tell GHC where to get the runtime information it needs anyway.
02:09:27 <asheshambasta> merijn: getting cut here isn't as bad when you compare it to the rusted blade of Scala. 
02:09:33 <merijn> ;)
02:09:57 <kuribas> asheshambasta: hi! can't you just do: instance FromJSON (Output t) where ... ?
02:10:36 <asheshambasta> lyxia: yeah, my perception here was subjective, I see the point in the "fix" as I may call it. 
02:10:47 <asheshambasta> kuribas: how would you implement that for all t?  
02:11:57 <bwe> https://youtu.be/cefnmjtAolY?t=247 -- 1st lens law: set l (view l s) s = s -- If I try to prove this, I end up with 'a' as the result, differing from expected 's'.  set l (view l s) = s   can be reduced to   set l (a) s = s  which I further reduce to   a ≠ s. What's the right way of proving the first lens law?
02:13:42 <lyxia> bwe: there's a typo in the law
02:13:47 <lyxia> set l s (view l s) = s
02:16:22 <kuribas> asheshambasta: hmm, not sure.  ToJSON would be possible though
02:17:11 <asheshambasta> kuribas: yeah, trying to implement a typeclass with something that returns the (Output t) type results in a "rigid type variable t" error
02:18:12 <asheshambasta> say, you have a FromJSON (Output t) and you'd like to have parseJSON :: Value -> Output t; and you'd like, in one case, to return Output 'Baz, that doesn't compile. 
02:20:40 <elmcrest> Is there a Haskell Web Framework which generates everything from Haskell including Javascript, HTML and CSS?
02:21:43 <bwe> lyxia: thx.
02:21:54 <elmcrest> especially Javascript I guess ... I just hate it :)
02:22:34 <lyxia> elmcrest: what about reflex https://github.com/reflex-frp/reflex-platform
02:22:40 <julianleviston> elmcrest: miso?
02:22:57 <elmcrest> lyxia julianleviston checking both, thx
02:23:01 <asheshambasta> elmcrest: Servant generates JS client code http://hackage.haskell.org/package/servant-js
02:23:03 <julianleviston> https://github.com/dmjio/miso
02:24:01 <julianleviston> elmcrest: reflex has a large learning curve. you might want to try purescript tho, TBH… it’s got a number of really nice options if you want to replace JS.
02:24:34 <elmcrest> ideally I'd like to have a single codebase to get a full web app ... but that's probably still dreaming
02:24:49 <julianleviston> then reflex. 
02:24:53 <julianleviston> obelisk
02:25:10 <julianleviston> https://github.com/obsidiansystems/obelisk
02:25:13 <elmcrest> julianleviston well, I'm about to get started with Haskell so I don't fear learning :D ... (coming from Python mainly)
02:25:36 <julianleviston> elmcrest: uhhh
02:25:36 <kuribas> asheshambasta: seems you can only write ToJSON (Output t), not FromJSON (Output t)
02:25:57 <julianleviston> elmcrest: that’s some major learning curve.
02:26:05 <elmcrest> julianleviston haha yeah :D 
02:26:10 <kuribas> asheshambasta: working around that would be more complicated than adding a simple constraint.
02:26:22 <elmcrest> julianleviston so currently I'm just looking around and try to figure if I'm on a sane path
02:26:22 <asheshambasta> kuribas: yeah, in the latter case GHC complains about the type variable 't'
02:26:39 <julianleviston> elmcrest: it’s incredibly rewarding. Who cares about sane.
02:26:52 * hackage push-notify-apn 0.2.0.0 - Send push notifications to mobile iOS devices  http://hackage.haskell.org/package/push-notify-apn-0.2.0.0 (hc)
02:27:12 <julianleviston> elmcrest: if you use reflex, you have to learn both haskell *and* FRP at the same time.
02:27:25 <julianleviston> elmcrest: I really wouldn’t recommend that being your first taste of haskell.
02:27:36 <elmcrest> julianleviston FRP examples response with 404 FYI
02:27:52 <asheshambasta> kuribas: one way to have just one typeclass instance is having a "wrapper type"; something akin to `data Output' where OutputAll' :: Output t -> Output'`
02:27:52 <julianleviston> elmcrest: eh?
02:28:01 <julianleviston> elmcrest: the thing you need to guard against is being burnt.
02:28:09 <asheshambasta> and having a typeclass instance
02:28:10 <kuribas> > let f :: Int -> a; f _ = undefined in const 1 (f 20) :: String
02:28:10 <elmcrest> julianleviston yeah sure, not goint that way in case I'm heading to it ... I'll just want to check what's possible at the end of the journey
02:28:12 <lambdabot>  error:
02:28:12 <lambdabot>      • No instance for (Num String) arising from the literal ‘1’
02:28:12 <lambdabot>      • In the first argument of ‘const’, namely ‘1’
02:28:23 <kuribas> > let f :: Int -> a; f _ = undefined in const 1 (f 20 :: String)
02:28:25 <lambdabot>  1
02:28:35 <julianleviston> elmcrest: if you can continue through what would otherwise burn you, you’ll be fine.
02:28:44 <elmcrest> julianleviston https://reflex-frp.org/examples
02:28:47 <kuribas> asheshambasta: it works just fine... The problem is that you cannot match on Baz or Bar
02:28:54 <julianleviston> elmcrest: I don’t know what that website is.
02:29:27 <julianleviston> oh it’s a new domain. I haven’t been there in a while :)
02:29:52 <elmcrest> ok that's probably then the reason why the examples don't work anymore
02:29:58 <julianleviston> elmcrest: https://github.com/reflex-frp/reflex-examples
02:30:12 <julianleviston> https://examples.reflex-frp.org
02:30:22 <julianleviston> Your first Pull Request! :)
02:31:20 <elmcrest> thx for the link
02:31:37 <kuribas> asheshambasta: perhaps you can write it by juggling with a lot of type families and type classes...  But it will not be pretty.
02:31:46 <elmcrest> julianleviston an Issue is enough I hope :P 
02:31:52 <kuribas> asheshambasta: certainly easier to just add the constraint.
02:31:54 <julianleviston> elmcrest: or you could fix it :)
02:32:00 <julianleviston> elmcrest: no harm in trying :)
02:32:07 <elmcrest> yeah yeah :P 
02:37:22 <elmcrest> ok this would take too much time for now, sorry ... 
02:37:32 <elmcrest> Issue has to be enough :P 
02:41:37 <kuribas> asheshambasta: you could return "Output t" as _|_, it would compile, but give a runtime error.
02:46:12 <elmcrest> julianleviston so Purescript == Haskell?
02:47:07 <elmcrest> oh no `npm install -g purescript`
02:47:42 <julianleviston> No, purescript is a different language, but it’s quite similar to haskell.
02:47:56 <asheshambasta> kuribas: yeah, I've tried some workarounds, none of them seemed satisfactory, so I'll just leave it at this for now. 
02:48:09 <julianleviston> tho it’s aim is to compile to readable understandable JS
02:48:35 <elmcrest> julianleviston hehe not a worthy aim :D
02:48:39 <kuribas> asheshambasta: what's your objection to adding the constraint?
02:49:08 <coldpress_> anyone using graphics-gloss knows why positioning text is so hard?
02:49:14 <julianleviston> elmcrest: well, it is if you want efficient nice javascript :P some of the stuff that GHCJS produces isn’t super efficient… tho it’s gettng better and better as we speak :)
02:49:50 <asheshambasta> kuribas: none, actually, just that it seemed "unnecessary" in this case. Given my sum-type is closed and I've given GHC all the information for all possible cases, I was expecting GHC to handle this without having some sort of proof, which the constraint provides. 
02:50:03 <asheshambasta> that is, look for the proof elsewhere, not in the instance head. 
02:50:25 <kuribas> asheshambasta: yeah, a lot of the type level stuff is added as an afterthought.
02:51:16 <kuribas> asheshambasta: it could do totality checking for datakinds, but doesn't...
02:51:24 <asheshambasta> kuribas: the more I get used to it, its quite nice actually. I still consider the design accomodations made for type-level stuff quite elegant. 
02:51:46 <kuribas> asheshambasta: considering it was never meant to do so much, yes :)
02:51:57 <asheshambasta> kuribas: yeah, but also as merijn mentioned: this is the cutting edge of GHC :-) 
02:52:17 <kuribas> I am still itching to learn idris...
02:52:53 <asheshambasta> yeah me too, but step by step. Haskell at our company is the first step towards more rigorous programming standards in my life. 
02:53:10 <asheshambasta> And tbh, Haskell is rigorous enough: whilst being production ready 
02:53:51 <asheshambasta> kuribas: moreover, the improvements Haskell is offering over the old Scala codebase for one of our critical services are mind-boggling. 
02:54:17 <kuribas> asheshambasta: cool :)
02:54:27 <asheshambasta> Haskell is a hard beast to tame, but once you start getting the hang of things, it is by far the most intellectually and professionally rewarding programming languages I've personally come across. 
02:54:59 <julianleviston> asheshambasta: have you tried idris?
02:55:16 <kuribas> asheshambasta: I'd like to hear those, maybe I can convince my coworkers :)  But he'll probably go like "that's all cool etc... But not necessary in practical life.".
02:55:20 <asheshambasta> julianleviston: no I haven't, I'd like to. 
02:55:54 <asheshambasta> kuribas: being rigorous has saved us quite some money and repute as a company :-) 
02:56:12 <asheshambasta> kuribas: and man-hours being put into the codebase fixing-understanding-improving things 
02:56:48 <julianleviston> asheshambasta: how long has your company been doing haskell? I wish I could convince our company to do that. 
02:57:58 <kuribas> asheshambasta: I implemented some library code for specifying datesets (a la cron) from lisp into haskell.  I think having the spec in a haskell type, versus an informally specified list structure makes you understand it faster.
02:58:15 <asheshambasta> julianleviston: about a year, and I'm the CTO so I make the shots :-) 
02:59:00 <julianleviston> asheshambasta: ah, privilege helps :)
02:59:26 <asheshambasta> julianleviston: we implemented a "lazy SSL" engine in Haskell that provides on the fly SSL certificate issuance for all websites our API powers (in the 1000s, for example: corica.be etc.) and we never looked back 
02:59:41 <julianleviston> kuribas: I had to write some pretty tricky data sieving code the other day, and I implemented it in Haskell before Elixir because it was so much easier and smaller ;-)
03:00:12 <asheshambasta> basically, this piece of code is doing a LOT of IO and every website hit invokes it, and the performance has also been very very good 
03:01:00 <kuribas> julianleviston: the lisp code uses a state machine... It's quite clever, but tricky to write and understand.  The haskell version just uses a list monad :)  But I should test performance, to see have much it changes.
03:01:53 <asheshambasta> kuribas: I think if you're just being clever with laziness, Haskell currently outperforms similar Scala code in my experience 
03:01:58 <julianleviston> kuribas: mmm list monad is pretty inefficient for some things.
03:02:16 <asheshambasta> kuribas: however, I'm yet to run detailed benchmarks comparing the old vs. new
03:02:21 <kuribas> I wonder if some streaming abstraction could give a performance improvement.
03:03:03 <kuribas> julianleviston: algorithmically it's the same computation
03:03:44 <kuribas> julianleviston: are you talking algorithmically, or about runtime?
03:05:48 <julianleviston> kuribas: ah if it’s the same, it’s the same.
03:06:39 <julianleviston> kuribas: just, as you no doubt know, easy to get into large complexity issues with LIst.
03:06:55 <kuribas> a lazy list has to keep all the state from it's computation alive, so it may be not efficient memory wise...
03:07:05 <julianleviston> kuribas: but if you’ve picked the right data structure, all good :)
03:07:41 <kuribas> julianleviston: the list monad first picks the right year, then month, then day, ...
03:07:51 <kuribas> julianleviston: it's a perfect match :)
03:08:23 <kuribas> julianleviston: on the other hand the lisp state machine runs in constant space
03:08:27 <julianleviston> you’re doing filter lookup? a map woudln’t be better?
03:10:03 <julianleviston> small number of items in it, most likely, so it makes no difference.
03:10:21 <kuribas> julianleviston: no, I generate them for each granularity
03:11:45 <safinaskar> mniip: https://gist.github.com/mniip/7e5fda039b81553c8796bb2c15faf8ed - is this compiler? for what language? for haskell?
03:12:25 <kuribas> julianleviston: and yeah, filtering days is fast.
03:12:46 <xsperry> how much reflection does haskell support? can I fetch all the fields, given a type, or an object of some type?
03:13:21 <Solonarv> xsperry: yes, there are multiple ways of doing that
03:14:02 <xsperry> I want to write pretty version of show someRecord. would that be a way to go about it? or would it be simpler to just parse show's output
03:14:39 <Solonarv> xsperry: it seems you're looking for a pretty-printing library, then. There are several of those.
03:16:10 <xsperry> I'm not sure if there's one that can write it in a way that it is still syntactically valid haskell? just indent and spread out show's output, basically (one field per line)
03:17:06 <Solonarv> that's pretty much exactly what pretty-show does
03:17:23 <xsperry> nice, I'll give it a try
03:17:27 <Solonarv> (assuming the type has a proper Show instance that actually produces valid Haskell)
03:17:43 <xsperry> it also works on nested records?
03:19:37 <Solonarv> Sure, why wouldn't it?
03:20:00 <Solonarv> (disclaimer: I haven't actually used it, I just don't see why it would fail on that specific case)
03:20:40 <dminuoso> safinaskar: Mmm that looks interesting. It's definitely not haskell.
03:21:30 <dminuoso> safinaskar: I wonder whether that's perhaps a Core clone.
03:21:38 <dminuoso> That is a miniature Core implementation.
03:21:49 <xsperry> it requires PrettyVal constraint on types, so it probably doesn't just parse show's output
03:23:20 <Solonarv> xsperry: actually, it works using the Show class too: https://hackage.haskell.org/package/pretty-show-1.9.5/docs/Text-Show-Pretty.html#g:2
03:23:36 <Solonarv> those functions do parse show's output.
03:24:45 <xsperry> what is PrettyVal type class about, then
03:27:06 <xsperry> nice
03:27:11 <xsperry> works great, just with Show
03:28:30 <Solonarv> PrettyVal skips the intermediate 'show' and just generates a syntax tree directly
03:31:05 <xsperry> also, I guess, I can use PrettyVal if I'm not happy with Show's instance
03:31:14 <BlackBloc> hi
03:32:17 <Solonarv> xsperry: exactly; after all, some types just have broken Show instances (i.e. they don't produce valid Haskell), and you can't exactly go fix them
03:32:20 <Solonarv> BlackBloc: hello!
03:32:41 <BlackBloc> comment ca vaa
03:34:25 <Solonarv> please try and stick to English in here
03:34:38 <BlackBloc> im sorry
03:38:50 <BlackBloc> who knows ferry corsten?
03:39:02 <xsperry> too much?  echo =<< valToStr . fromJust . parseValue . show  <$> get
03:39:58 <xsperry> I wonder if parseValue failing is type specific or value specific
03:42:00 <dminuoso> xsperry: I'd move `valToStr . fromJust . parseValue . show` into a separate binding at least, and then you could just do `echo . thatThing =<< get`
03:42:19 <dminuoso> Or something similar.
03:42:52 * hackage yam 0.5.5 - Yam Web  http://hackage.haskell.org/package/yam-0.5.5 (leptonyu)
03:43:04 <dminuoso> Or.. wait that won't typecheck.
03:43:38 <dminuoso> Or shouldn't it?
03:44:11 <xsperry> it looks fine I think
03:44:52 * hackage yam-datasource 0.5.5 - Yam DataSource Middleware  http://hackage.haskell.org/package/yam-datasource-0.5.5 (leptonyu)
03:44:53 <xsperry> it compiles
03:45:38 <xsperry> nicer than what I had
03:46:14 <dminuoso> xsperry: Over the past few months I've learned that the greatest tool to make code better.. is to move things into extra bindings.
03:47:53 <fen> if Identity were without runtime cost, wouldnt this function work? https://bpaste.net/show/9791a1312fa8
03:48:19 <fen> or is the problem something to do with Free not inlining? 
03:50:31 <xsperry> dminuose, agreed
03:51:44 <Solonarv> fen: Identity *is* without runtime cost
03:51:52 <dmwit> fen: No, ana cannot work the way you want it to. It can even be given type `ana :: a -> Free Identity b` which obviously must loop infinitely before producing any `b`s.
03:51:55 <fen> and if so, is there a way to make a version that does, by combining it with Identity instead of arbitrary `f'
03:52:57 <fen> smwit: curious
03:54:15 <coldpress> dminuoso: what do you mean by moving thingsn into extra bindings? like instantiate more variables?
03:54:23 <fen> the hope was that `a' could be replaced by a nesting of Identity to any depth
03:54:52 <dmwit> (And dually, cata must infinitely loop, because it can be given type `cata :: Free Identity a -> b`.)
03:55:17 <dmwit> What you have actually written is not a nesting of Identity to any depth, but a nesting of Identity to infinite depth.
03:57:05 <fen> so that (fmap . fmap ..) could be applied to `a'
03:58:12 <fen> so that any depth of nesting of Identity were equivalent to both the infinite and zero nesting
03:59:13 <fen> basically it was a question about lazy evaluation that had to get something from the last position of a otherwise empty "skip" structure
03:59:32 <fen> instead of as usual, returning it from the first 
04:01:20 <siers> i sometimes feel that "mby_do c f x = if c x then f x else x" would be nice to have around... does anyone else?
04:01:39 <Solonarv> yep
04:02:17 <fen> Free + Identity is something like data Skip0 a = Skip0 (Skip0 a) | SkipEnd a
04:02:59 <dmwit> siers: I have defined `ensure p x = x <$ guard (p x)` so many times. =P
04:03:31 <xsperry> wtf?  Warning: Build failed, but optimistically launching GHCi anyway
04:03:35 <fen> % :t \ p x = x <$ guard (p x)
04:03:35 <yahb> fen: ; <interactive>:1:7: error:; parse error on input `='; Perhaps you need a 'let' in a 'do' block?; e.g. 'let x = 5' instead of 'x = 5'
04:03:42 <fen> % :t \ p x -> x <$ guard (p x)
04:03:42 <yahb> fen: Alternative f => (t -> Bool) -> t -> f t
04:03:58 <Solonarv> fen: That's exactly what it is. Unsurprisingly, if you have an infinite nesting of Skip0 you can never actually get out an 'a'.
04:05:11 <royal_screwup21> I'm' trying to define a custom datatype like so: data Parser a = Parser (\String -> [(a, String)]) I'm getting an error: data Parser a = Parser (\String -> [(a, String)])
04:05:17 <royal_screwup21> what am I missing?
04:05:38 <Taneb> royal_screwup21: remove the \
04:06:03 <Taneb> Lambdas are values with function type, there's no lambda in the type
04:06:04 <royal_screwup21> ah cool
04:06:32 <mniip> safinaskar, just a language
04:06:46 <mniip> lambda calculus with a few bells and whistles
04:13:27 <safinaskar> mniip: hi. your compiler is very cool
04:13:43 <safinaskar> mniip: please, publish it somewhere with docs
04:13:57 <xsperry> @hoogle (a -> Bool) -> (a -> a) -> a -> a
04:13:58 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
04:13:58 <lambdabot> CorePrelude until :: (a -> Bool) -> (a -> a) -> a -> a
04:13:58 <lambdabot> NumericPrelude.Base until :: (a -> Bool) -> (a -> a) -> a -> a
04:15:29 <xsperry> > map (until even (*10)) [1..10]
04:15:32 <lambdabot>  [10,2,30,4,50,6,70,8,90,10]
04:15:33 <xsperry> > map (until odd (*10)) [1..10]
04:15:39 <lambdabot>  mueval-core: Time limit exceeded
04:15:40 <xsperry> ^^ weird
04:16:15 <Solonarv> Hmm, a bit
04:16:33 <xsperry> type matches myb_do
04:17:14 <dminuoso> coldpress: Yes. Creating variables allows you to decompose code, giving it concise names.
04:17:20 <Solonarv> xsperry: eh? no it doesn't
04:17:27 <dminuoso> It also helps with documenting the small subtle parts where lots of thought went into.
04:17:49 <dminuoso> coldpress: It also makes refactoring down the road much easier, and it's easier to read when you've forgotten what your code even does.
04:17:50 <xsperry> Solonarv where's the difference?
04:18:23 <xsperry> > map (until even (+1)) [1..10]
04:18:26 <lambdabot>  [2,2,4,4,6,6,8,8,10,10]
04:18:29 <Solonarv> xsperry: what are you referring to, actually?
04:18:31 <coldpress> dminuoso: makes sense
04:18:59 <xsperry> <siers> i sometimes feel that "mby_do c f x = if c x then f x else x" would be nice to have around... does anyone else?
04:19:36 <Solonarv> oh yes, those do have the same type
04:19:42 <Solonarv> that doesn't mean they do the same thing, though
04:20:01 <xsperry> they obviously don't
04:21:41 <Solonarv> I was confusing 'mby_do' with 'ensure' which was mentioned above. My bad.
04:22:14 <xsperry> that's ok
04:28:19 <julianleviston> seems like isNegativeZeroOverLit might be the winner.
04:28:32 <julianleviston> that’s where it seems to be pausing.
04:28:37 <julianleviston> Oops wrong channel.
04:30:54 <berndl> Are there functions in base for the associator/unitor of Compose? Or should I be using coerce?
04:32:37 <Solonarv> coerce seems right to me
04:34:53 <berndl> Great. The code was starting to look pretty bad with all the packing/unpacking.
04:51:02 <dmwit> > [1..10] >>= ensure even
04:51:05 <lambdabot>  [2,4,6,8,10]
04:51:39 <xsperry> :t ensure
04:51:40 <lambdabot> Alternative f => (t -> Bool) -> t -> f t
04:51:53 * hackage haskell-dap 0.0.10.1 - haskell-dap is a GHCi having DAP interface.  http://hackage.haskell.org/package/haskell-dap-0.0.10.1 (phoityne_hs)
04:54:48 <kuribas> :t guard
04:54:49 <lambdabot> Alternative f => Bool -> f ()
04:54:50 <merijn> What's the best way to encode a 3-way switch using cabal flags?
05:03:25 <fendor> in the directory packages how can I list all files in a directory with an absolute path?
05:04:55 <lyxia> listDirectory doesn't do that?
05:06:26 <phadej> merijn: manual flags: make three flags; and check that they are mutually exclusive (i.e. if any two is on => build-depends: base<0; or something like that)
05:06:31 <merijn> lyxia: It only lists the contents, it doesn't prefix the absolute path
05:06:40 <phadej> merijn: for automatic flags you can use less flags
05:06:49 <merijn> phadej: I found a simpler solution, actually :)
05:07:35 <merijn> phadej: One of the flags supercedes the others, so it just turns the other flag into a no-op if enabled
05:08:48 <phadej> well, then if you flip second flag, the configuration will change (i.e. cabal will try to recompile everything) when it actually doesn't
05:08:51 <phadej> not biggie
05:09:12 <merijn> Not ideal, but not worth the hassle of a more complex setup
05:09:16 <phadej> but might be confusing, you change the flag, but nothing happens
05:10:00 <phadej> https://github.com/phadej/functor-classes-compat/blob/master/functor-classes-compat.cabal is a beast
05:10:03 <phadej> flag-wise
05:10:33 <phadej> I was lucky as there are exactly 4 cases I need to (automatically) pick from
05:10:35 <fendor> lyxia, unfortunately not :/ i can hack it together with `getCurrentDirectory`
05:11:09 <merijn> phadej: I don't actually think this should be a flag, but upstream already uses flags for many similar things
05:11:37 <fendor> but I feel like, normally we would like behaviour `listDirectory ./src == ["./src/File.hs"]` instead of `listDirectory ./src == ["./File.hs"]`
05:15:07 <phadej> fendor: what you get when you $ ls ~/
05:15:25 <phadej> you don't get prefixes
05:15:28 <phadej> they are redundant
05:16:12 <phadej> the relative / absolute division (in types) would help that
05:16:28 <phadej> listDirectory :: Path any -> IO [Path Relative]
05:17:31 <fendor> phadej, but "find" has prefixes. 
05:17:40 <phadej> find also recurses
05:17:47 <xsperry> fendor:  do cwd <- getCurrentDirectory; map (cwd </>) <$> listDirectory "./"
05:18:07 <fendor> right. Can I do a listDirectoryRecursively?
05:18:54 <fendor> xsperry, yeah, that is my fix as well
05:19:15 <phadej> fendor: naive version is not hard to write yourself
05:19:19 <xsperry> fendor not sure, I wrote my own recursive version years ago
05:19:54 <phadej> I for (some reason) use machines so I can interleave processing the files with traversing the directory structure
05:19:58 <phadej> but I'm weird
05:20:23 <phadej> (you could use conduit or pipes for that)
05:20:56 <xsperry> and I used unsafeInterleaveIO to start getting files immediately, instead of waiting for entire tree to be processed.. not sure how safe that is, but I've not have any issues 
05:21:08 <xsperry> had*
05:21:09 <fendor> phadej, it has to work without pipes or condiuit. I think the naive version is fine and I can make listDirectory absolute.
05:21:49 <fendor> i am upgrading a library from system-fileio to directory but their respective `listDirectory` behaves differently. That is actually the problem I encounter
05:22:23 <phadej> xsperry: I don't have strong opinion on lazy-IO; with directory structure it's probably ok as you don't retain any resources (file descriptors e.g.)
05:23:12 <merijn> And you don't add/remove directories of the tree you're traversing!
05:24:26 <phadej> good point
05:32:36 <tdammers> or someone else might remove directories in the tree you're traversing, oh boy
05:47:04 <xsperry> a bit nicer than above: mapM makeAbsolute =<< listDirectory "./"
05:51:31 <merijn> What's wrong with that?
06:04:17 <xsperry> merijn, it is nicer than what I typed earlier
06:06:09 <o1lo01ol1o> Is there a (MonadSTM m) constraint lurking around?
06:06:34 <merijn> o1lo01ol1o: I doubt it, what would you expect it to do?
06:08:03 <c_wraith> that one actually seems well-defined
06:08:31 <o1lo01ol1o> merijn:  allow me to run STM actions without declaring MonadIO
06:08:34 <merijn> c_wraith: Well, for the only useful things I can think of for it, you wouldn't need it
06:08:36 <c_wraith> it's not trying to create an STM transformer, it's trying to abstract over all the possible wrappers around STM
06:09:16 <merijn> c_wraith: But you could just piggyback retries and fails over MonadPlus and Alternative?
06:10:07 <c_wraith> I've never used STM as the base of a transformer stack.  Don't know why you would
06:10:21 <c_wraith> But it at least seems as well-defined as MonadIO
06:15:38 <lyxia> there's MonadBase for that
06:16:05 <lyxia> "that" being an STM counterpart to MonadIO.
06:16:23 * hackage servant-subscriber 0.6.0.2 - When REST is not enough ...  http://hackage.haskell.org/package/servant-subscriber-0.6.0.2 (eskimo)
06:16:31 <Solonarv> Huh, that works I guess.
06:16:37 <Solonarv> % :i MonadBase
06:16:38 <yahb> Solonarv: ; <interactive>:1:1: error: Not in scope: `MonadBase'
06:16:52 <julianleviston> what is yahb?
06:17:00 <Solonarv> % :i MonadBase
06:17:01 <yahb> Solonarv: class (Applicative b, Applicative m, Monad b, Monad m) => MonadBase (b :: * -> *) (m :: * -> *) | m -> b where; liftBase :: b α -> m α; {-# MINIMAL liftBase #-}; -- Defined in `Control.Monad.Base'; instance [safe] (Monoid w, MonadBase b m) => MonadBase b (WriterT w m) -- Defined in `Control.Monad.Base'; instance [safe] MonadBase b m => MonadBase b (StateT s m) -- Defined in `Control.Monad.Base
06:17:03 <julianleviston> like lambdabot but different?
06:17:24 <lyxia> yet another haskell bot
06:17:25 <Solonarv> julianleviston: lambdabot evaluates Haskell expressions and has a bunch of miscellaneous other functions
06:17:28 <merijn> lambdabot, but allows IO and other unsafe stuff
06:17:40 <Solonarv> yahb is an actual GHCi session
06:17:44 <julianleviston> oh wow
06:17:56 <julianleviston> so it doesn’t just use hint or mueval. cool :)
06:18:16 <Solonarv> it also does lua and bash, but that isn't used quite as often, because guess what channel we're in ;)
06:19:06 <julianleviston> Solonarv: did it just load the missing MonadBase somehow? (when you asked it a second time I noticed it’s loaded now)
06:19:22 <Solonarv> julianleviston: I did that in a PM
06:19:26 <julianleviston> ah
06:26:08 <julianleviston> thanks :)
06:49:14 <Ariakenom> "Notationally, we say that Int∼Age, where we use ∼ for type equality [1]." "[1]: There are too many sorts of '='"
06:50:03 <Ariakenom> I like the use of "sorts" there :p
06:55:17 <hc> :)
07:01:52 * hackage morphisms-functors 0.1.6 - Functors, theirs compositions and transformations  http://hackage.haskell.org/package/morphisms-functors-0.1.6 (iokasimovmt)
07:02:52 * hackage morphisms-objects 0.1.3 - Algebraic structures  http://hackage.haskell.org/package/morphisms-objects-0.1.3 (iokasimovmt)
07:10:08 <geekosaur> which is itself another “sort of '='”
07:37:30 <siers> I've never really understood/used CPS, but would it be useful for stopping a lazy list?
07:39:41 <lyxia> The best way to stop a lazy list is to not wake it up.
07:39:51 <julianleviston> lol
07:40:41 <Taneb> Is there a nice way to annotate the type of a binding in a do-block?
07:40:57 <Taneb> Like "do {x :: String; x <- getLine; ...}"
07:41:20 <lyxia> x :: String <- getLine   should be legal with ScopedTypeVariables
08:20:52 * hackage lentil 1.1.1.1 - frugal issue tracker  http://hackage.haskell.org/package/lentil-1.1.1.1 (fffaaa)
08:42:44 <Boarders> I am trying to use the library Autobench but it is only on github so I added it to our stack file but our project uses a different incompatible version of megparsec so I get a build error, does anyone know a good solution to that
08:43:01 <Boarders> I have locally built it so is it possible to point at that locally built thing?
08:43:29 <glguy> specify a different version of megaparsec for your project
08:43:57 <Boarders> I don't know if I want to be using an older version though
08:43:59 <glguy> or update the components so they both support the same version of megaparsec
08:44:14 <Ucenna> I'm working on a game that saves things along the time axis. It would probably be an extremely big save file as time is a core component of the game. When working on an idea for managing the game, using an immutable data structure seemed like the way to go. so you think that would be a good idea to use Haskell as a bridge to access and manage the d
08:44:14 <Ucenna> ata structure, or is it not worth it? 
09:02:17 <lyxia> You're probably better off using an implementation of immutable data structure in the language you're already working with
09:12:52 * hackage hal 0.1.1 - A runtime environment for Haskell applications running on AWS Lambda.  http://hackage.haskell.org/package/hal-0.1.1 (nikeoss)
09:18:04 <hoppfull> Hello. If I have a state that I want to mutate but I don't want to accidentally access a previous state and I don't have linear types, is there some way of dealing with that? Like a stream of states but under the hood it's actually mutating?
09:20:00 <hoppfull> I've only recently started to understand FRP and as I understand it, each event has an id and if you try to access a past event we purposefully crash the program at runtime.
09:21:09 <Putonlalla> You can get an approximation of that by shadowing names with `do` notation, hoppfull.
09:21:55 <Ariakenom> yes it seems like just using State would be a decent guard against reusing the state
09:23:01 <Putonlalla> > flip execState 42 $ do {x <- get; x <- pure (1 + x); x <- pure (2 * x); put x}
09:23:03 <lambdabot>  86
09:23:13 <Ariakenom> can you get guarantees with ST maybe?
09:23:36 <hoppfull> Ariakenom: I'll have a look at that!
09:29:43 <lyxia> ST gives you mutation but if you want to build some illusion of immutability on top of that (like each variable you bind represents an immutable value) there's one way with indexed monads.
09:29:51 <lyxia> It's not very pretty though.
09:30:39 <lyxia> https://gist.github.com/Lysxia/6be7bd107e2b5863140acaa7556aa3a1 using indexed monads to prevent use after free.
09:55:59 <dsal> I'm in a bit of an unfortunate intersection of GHC and ARM.  Does anyone know how to get this built?  My current status is "Error: selected processor does not support `movw r7,:lower16:stg_enter_info' in ARM mode" which seems to be a missing armv7 declaration somewhere.
09:59:26 <ddellacosta> I'm trying to reduce/simplify an AST where I may be able to merge _some_ leaf nodes with each other in random locations in the tree, but not necessarily all leaf nodes (and therefore not necessarily all sub-trees). I've been looking into attribute grammars but I'm not sure how to use the kind of global data they support to do this. Are there any other approaches I should look into for incrementally reducing an AST where I need to esse
09:59:26 <ddellacosta> ntially do an O(n^2) round of comparing all the leaf nodes to each other (and rinse, repeat...)?
10:00:42 <ddellacosta> also I haven't found much on attribute grammars in Haskell other than this: https://wiki.haskell.org/Attribute_grammar ...which has a bunch of dead links
10:04:15 <Ucenna> @lyxia probably true. I forsee eventually adding multiplayer support and//or hosting multiplayer support. I don't really know Haskell's performance advantage if there are any, when working with immutable data structures. But rather than refactoring several times or going through the struggle of coding an immutable data structure in a nonpure functi
10:04:15 <Ucenna> onal language, i thought it might be worth while to just do it from the get go. 
10:04:15 <lambdabot> Unknown command, try @list
10:04:39 <Ucenna> also, I havent learned Haskell yet, so having an excuse to is definitely a motivator. 
10:04:54 <geekosaur> immutable is often slower. but it's cleaner and much easier to verify that nothing s messing with data except what you intend to
10:05:06 <geekosaur> basically, it's mot about speed, it's about correctness
10:05:07 <Ucenna> but performance concerns might make a difference. 
10:05:16 <geekosaur> large classes of bugs go away completely
10:05:57 <geekosaur> you can by construction ensure that multiple players can oly interact in the ways you specify, no hidden backdoors
10:06:29 <Ucenna> that's true. my game project is a time travel sand box game. and coding a save file that takes the fourth dimension into account is daunting. 
10:06:43 <geekosaur> this is not to say performaaance is impossible, but you can also provide the non-functional stuff walled off so it's safe
10:06:49 <geekosaur> so you get the best of both performance and reliability
10:07:22 <Ucenna> giving that the fourth dimension is a factor, do you think immutable structures might have a performance advantage, as they are already stateless? 
10:08:09 <Ucenna> my save file basically has to be able to render any given time that it's experienced, so intuitively immutable data structures are definitely the way to go. 
10:09:17 <conal> hoppfull: hm. doesn't sound remotely like FRP to me.
10:11:06 <Ucenna> what language would you recommend for performance with immutable data structures? 
10:13:27 <koz_> Ucenna: Haskell. :P
10:13:52 <Ucenna> :P
10:14:03 <Ucenna> Thought so
10:15:04 <koz_> Although I'm not sure what structures you care about or what you want done, which are both major performance considerations.
10:16:20 <Ucenna> I'd be using it for a game's save file. the kicker is that the game uses time travel, and I want the user to be able to restore to any previous point in the structure
10:16:32 <koz_> Hmmm.
10:16:37 <hoppfull> lyxia: I thought about that but isn't one of the monad laws broken if it is indexed? Like if I call bind with id?
10:16:42 <koz_> I read something by Eric Demaine which might be suitable.
10:17:06 <Ucenna> yeah? 
10:17:20 <koz_> Ucenna: Let me try and find it.
10:17:21 <hoppfull> conal: Maybe I'm doing it wrong. I'm still trying to figure this stuff out.
10:18:07 <koz_> Ucenna: http://erikdemaine.org/papers/ConfluentTries_SWAT2008/
10:18:43 <koz_> Ucenna: http://erikdemaine.org/papers/ConfluentTries_Algorithmica/paper.pdf <-- PDF version
10:19:11 <koz_> You may wanna check anything which cites that paper - this _was_ over a decade ago, so there might be other stuff more suited.
10:19:31 <Ucenna> awesome! thanks! 
10:19:45 <lyxia> hoppfull: the monad laws actually still hold
10:20:01 <lyxia> well at that level, the question is more whether they still make sense
10:20:29 <hoppfull> lyxia: I guess if I can't ever see the index it would be ok.
10:20:37 <lyxia> but the generalization from monad to indexed monad has a similar feeling to the generalization from monoid to category
10:20:51 <lyxia> hoppfull: the index is only in the types
10:21:22 <Ucenna> oh this looks sweet
10:21:25 <hoppfull> lyxia: ah so mutating is like doing a natural transformation
10:22:44 <hoppfull_> Damnit, accidentally shut down the tab.
10:22:53 <Ucenna> hoppfull_: I don't know if it helps, but I think of mutation as a lense with which to look at the original object.
10:23:43 * shapr hoppar
10:24:46 <hoppfull_> Ucenna: I don't have an intuition for lenses yet.
10:25:46 <Ucenna> hopefull_: I more ment like a physical lense. like a pair of glasses. say you want to turn a red dog blue. instead of dyeing the dog you look at it through a new pair of glasses
10:25:52 <hoppfull_> Anyway, thanks a ton guys! I always have a positive experience coming here!
10:28:43 <conal> hoppfull_: i apologize. i could have expressed that remark more gently. 
10:29:21 <hoppfull_> conal: No worries, I didn't think you meant anything bad by it.
10:30:34 <conal> hoppfull_: i'm glad; and yeah, you're right. :). there's a lot of fundamental confusion about FRP out there.
10:30:49 * koz_ is pretty sure he still doesn't get FRP.
10:31:04 <koz_> I suspect if I stared at it, or worked with it, enough I'd eventually 'get it'.
10:31:13 <Ucenna> reading this journal I now realize that time travel is basically just bad version control
10:31:50 <koz_> Erik Demaine is a pretty smart guy like that. :P
10:31:52 <conal> koz_: one starting point for understanding FRP: https://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language#5878525 (and follow the links there).
10:32:08 <koz_> conal: Thanks!
10:32:23 <Ucenna> haha yeah
10:32:47 <Ucenna> like it's literally just version control sans the sub versions. 
10:32:54 <conal> Other links in particular: http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming/1030631#1030631 and http://stackoverflow.com/questions/5385377/the-difference-between-reactive-and-functional-reactive-programming/5386908#5386908
10:33:03 <conal> koz_: you're welcome!
10:35:36 <johnw> is there a nice library for printing a line from a textual file, with an ASCII underline and arrow demarcating an interesting region of text? Sort of like how trifecta prints error lines, but as a general library...?
10:39:14 <leshow> can anyone explain why you'd want to construct an SMode here and not just match on Mode directly? https://github.com/owickstrom/komposition/blob/master/src/Komposition/UserInterface.hs#L42
10:39:39 <leshow> perusing some code on github and stumbled across it
10:40:25 <Ucenna> dang, this is giving me so many ideas. instead of loading my save file by time stamp, I could filter by time periods that have at least twelve pandas and get a totally different result. and then if a player interacted with this version and reloaded the original they would get a totally different result. 
10:44:51 <__monty__> johnw: Don't know of anything, maybe something like a cursor can help? http://hackage.haskell.org/package/cursor
10:49:32 <johnw> hmm
10:57:03 <johnw> i don't think that's the same type of cursor :)
10:57:55 * shapr curses
10:58:11 <shapr> unsafePerformIO !
10:58:25 <johnw> sudo find me a library
10:58:38 <shapr> evil mangler!
10:58:47 * shapr tries to think of more on-topic curses
10:58:58 <shapr> may your garbage never be collected in your lifetime!
10:59:04 <Welkin> the pronunciation of terms in programming
10:59:06 <Welkin> how about that?
10:59:07 <johnw> so now I have a standin function errorContext :: FilePath -> Pos -> Pos -> Pos -> Pos -> Doc a, which at the moment just give file/line/col info in the standard format. I was hoping that turning this into a pretty context cursor would be a one-liner.
10:59:11 <johnw> feels like it should be
10:59:16 <Welkin> and how people pronounce things so very wrong
10:59:22 * shapr reads johnw's "git from the ground up"
10:59:28 <johnw> shapr: !
10:59:34 <shapr> oh sorry, "git from the bottom up"
10:59:47 <shapr> johnw: I'm writing my own bus factor tool based on existing research
11:00:02 <johnw> are you researching by hitting engineers with busses?
11:00:13 <shapr> no, but the UI in one of the research papers lets you do that!
11:00:20 <johnw> have to run, chat in a bit
11:00:47 <shapr> johnw: last page of https://core.ac.uk/download/pdf/50614652.pdf has "Start Bus Hitting!"
11:06:25 <bsima> what is the best way to handle a record with different fields?
11:06:49 <bsima> for example, a Location type could have zipcode, or a country, or a lat/long
11:08:58 <bsima> in clojure, I would use multi-spec to handle the different dependencies between fields/keys https://clojure.org/guides/spec#_multi_spec
11:09:05 <Geekingfrog> bsima, with an ADT: `data Location = ZipCode Text | Country Text | LatLong Float Float` for example
11:09:25 <bsima> Geekingfrog: oh, that's pretty simple
11:09:38 <bsima> thanks
11:10:37 <__monty__> Combinatorial explosion though.
11:11:01 <lyxia> leshow: it allows you to associate different kinds of operations to different modes and have the typechecker ensure you don't mix them up
11:11:35 <bsima> __monty__: I think "classy lenses" can help with this, but i'm not an expert in those yet
11:11:46 <bsima> 'HasZipcode', 'HasLatLong' and so on
11:14:47 <__monty__> There's ways yes, was just pointing out a possible shortcoming of the approach.
11:14:52 * hackage yaya-unsafe 0.1.1.0 - Non-total extensions to the Yaya recursion scheme library.  http://hackage.haskell.org/package/yaya-unsafe-0.1.1.0 (sellout)
11:15:01 <leshow> lyxia: you could do that without SMode though, coudln't you? take modeTitle for instance. It could just take a Mode instead of SMode m. what's the advantage of SMode?
11:15:37 <leshow> I've used phantom types before, which is sort of what this is doing I think except with the DataKinds extension to restrict the Kind of m
11:19:30 <lyxia> leshow: well a more natural solution here would be to have only Mode with dependent types, but without dependent types the singleton technique (that's behind SMode) is the closest solution.
11:20:27 <lyxia> so instead of having a single Mode whose values can be both in types and in terms, we have Mode whose values are meant to be in types only (even though they could technically be used at term level) and SMode whose values are in terms.
11:21:42 <leshow> so is that what SMode is trying to do here? create some distance between how a mode is represented at the type vs term level?
11:22:12 <lyxia> it's not creating distance, it's connecting the type level and the term level
11:22:39 <leshow> i guess i don't see how that's different than using Mode's variants and 'TimelineMode or whatever at the type level
11:22:40 <lyxia> anyway gtg
11:22:45 <leshow> thanks
11:41:02 <WWMD> Hello!
11:41:11 <cocreature> hey WWMD 
11:41:35 <WWMD> I'm having trouble understanding dependent types -- are you guys familiar with Linear.V?
11:42:07 <WWMD> I'm trying make Repa n-dimensional arrays an instance of the Dim typeclass.
11:42:33 <WWMD> class Dim n where reflectDim :: p n -> Int
11:42:39 <WWMD> Now what I have so far is this:
11:43:00 <WWMD> instance Dim Z where reflectDim _ = 0
11:43:17 <WWMD> instance Dim sh => Dim (sh :. Int) where
11:43:31 <WWMD>   reflectDim _ = succ $ reflectDim (Proxy :: Proxy sh)
11:43:57 <WWMD> the trouble is, I get this error:
11:43:58 <WWMD>     • Could not deduce (Dim n0) arising from a use of ‘reflectDim’
11:44:27 <cocreature> show us the full code and the full error message in some pastebin
11:44:27 <WWMD> n0 I believe refers to the type of the argument I've bound to "_".
11:44:34 <WWMD> OK, will do.
11:44:38 <cocreature> my first guess would be that you’ve forgotten to enable ScopedTypeVariables
11:44:50 <cocreature> so the sh in Proxy sh isn’t the sh in your type signature
11:45:00 <WWMD> yep that's it you fixed it
11:45:03 <WWMD> thanks so much!!
12:02:53 * hackage yaya 0.2.0.0, yaya-hedgehog 0.1.1.0 (sellout): https://qbin.io/circus-charge-jluv
12:06:16 <sclv> what's the cmd again to launch new-repl with some package in scope?
12:06:59 <sclv> oh never mind i just pass build depends
12:07:28 <cocreature> sclv: it’s also in "cabal new-repl --help" :)
12:07:45 <sclv> the help output is so verbose in the new- stuff that i can't read through it usefully
12:07:56 <cocreature> just look at the examples at the end
12:07:59 <sclv> :-)
12:08:53 <dmwit> Perhaps there should be a cabal new-help that shows the shared options, and let --help show only the command-specific stuff.
12:09:09 <dmwit> (Perhaps with a short pointer to new-help as a reminder.)
12:09:26 <cocreature> iirc the problem is that the new-* doesn’t actually support command-specific stuff
12:09:47 <dmwit> That may be true. Nevertheless there is command-specific text in each command's --help message.
12:10:14 <cocreature> hm yeah there is at least a command-specific description
12:10:28 <dmwit> (Or, to respond in another way: why is that a problem?)
12:11:12 <cocreature> presumably the --help output is generated automatically from the available options
12:11:23 <shapr> I want new-* to just be the command now
12:11:37 <dmwit> What could be easier than automaticall generating nothing?
12:11:51 <Solonarv> the problem is that any time I invoke 'cabal new-whatever --help', I get a spew of unrelated options that don't even make sense for the command I ask about
12:11:51 <cocreature> well not showing any option at all is silly as well
12:12:37 <cocreature> we have things like --haddock-for-hackage that I would certainly expect to show up when I run "cabal new-haddock --help" but it’s a global option
12:12:49 <cocreature> cabal’s option parsing is just a mess
12:12:58 <dmwit> I can certainly agree with that.
12:18:45 <meinheld> so you kept asking what i thought the type of the function was, dmwit 
12:19:54 <meinheld> iirc?
12:20:40 <dmwit> Yep. That's one sensible way to start most Haskell developments.
12:20:46 <dmwit> Not the only one, but I think a pretty good habit.
12:21:39 <dmwit> ("that" = figuring out the types of the things you want to implement)
12:22:51 <meinheld> ok
12:23:33 <meinheld> so to drop in a connect 4 piece i'm evaluating a list to see if there's a piece in them, starting at the beginning of the list (bottom, gravity-wise :D )
12:23:48 <meinheld> it would seem recursiveness is guuuud for that
12:27:41 <sclv> someone should sugg
12:27:51 <sclv> suggest option parsing as a gsoc project
12:33:54 <dminuoso> sclv: optparse-applicative is already mindboggingly good.
12:34:14 <sclv> i mean the option setup for cabal-install
12:34:17 <sclv> not option parsing as such
12:34:22 <dminuoso> Oh.
12:34:41 <sclv> and i guess not really the parsing so much as the whole subcommands datastruture
12:35:02 <sclv> (i've long wanted options packed into a reader monad, e.g. rather than handed around explicitly, etc)
12:36:52 <Boarders> I have a module that is part of an executable that I want to use with another executable (the benchmarksuite) as part of the same project, is there any way to do that
12:37:01 <Boarders> like can I have an exposed module field on an executable or no?
12:37:39 <dmwit> Nope. Make it an exposed module of the library, or simple put the source file in a directory that both the executable and benchmark suite include in their hs-source-dirs.
12:38:00 <Boarders> ok thanks
12:39:25 <dmwit> I've sometimes wished that executables, tests, and benchmarks could use their library's other-modules. A sort of this-package-only internal API sort of thing.
12:39:33 <dmwit> But GHC don't work that way.
12:39:43 <meinheld> hmm. a better tack for me might be to ask what online free resource i should use to learn haskell as a first programming language.
12:39:48 <meinheld> dmwit
12:40:27 <dmwit> ?where cs394
12:40:27 <lambdabot> I know nothing about cs394.
12:40:27 <dminuoso> meinheld: What kind of programming background do you have?
12:41:03 <dminuoso> meinheld: Do you have any previous experience with functional programming? Do you have any experience with imperative programming? Maybe with robust type systems?
12:41:09 <dmwit> https://www.seas.upenn.edu/~cis194/spring13/ is written by a person I trust to have good pedagogical taste.
12:41:12 <Solonarv> @where cis194 -- FTFY, dmwit
12:41:12 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
12:41:42 <dmwit> I really liked the Gentle Introduction. But it probably isn't suitable for somebody who hasn't done any programming before.
12:41:59 <meinheld> literally i've done very literal. been kiddo-/whatever-does-it-hacking for decades.
12:42:07 <meinheld> very hit and miss.
12:42:29 <dmwit> I really didn't like Learn You a Haskell for Great Good. It was too flippant and full of irrelevant stuff for my taste. But other people seem to like it a lot, so you may try it and see what you think.
12:42:51 <meinheld> as for actual programming i did a couple lessons in javascript several years ago, and some pascal basic stuff decades ago in like 7th grade
12:43:05 <meinheld> dminuoso
12:43:28 <dmwit> ?where LYAH
12:43:28 <lambdabot> http://www.learnyouahaskell.com/
12:43:40 <dmwit> And there is an exhaustive (exhausting, more like) list of tutorials on the wiki.
12:43:43 <dmwit> ?wiki tutorials
12:43:43 <lambdabot> https://wiki.haskell.org/tutorials
12:44:02 <dminuoso> meinheld: The less experience you have, the easier Haskell may be for you. :)
12:44:25 <meinheld> cool!
12:44:42 <Welkin> lyah will confuse you and is not a great resource
12:44:50 <meinheld> dmwit 'taste' is an interesting word when used with 'pedagogical' haha
12:44:52 <Welkin> Programming in Haskell is a better book
12:45:21 <dmwit> Teaching well is hard. It definitely requires good taste.
12:45:22 <Welkin> lyah is okay to give you a brief introduction
12:45:48 <meinheld> (oh and dminuoso et al, i have done four or five videos in peter x's companion to lyah)
12:45:50 <dmwit> You must choose what to omit at least as carefully as what to include.
12:46:51 <Welkin> LYAH needs some serious editing
12:47:17 <Welkin> I don't know why it was never professionally edited, but was still published in print by a publisher
12:48:45 <meinheld> in programming, maybe, dmwit. but i've taught music for decades and it's more of a spiritual waypoint sort of thing. like guiding someone through a beautiful forest so that they can understand some things, yes, but moreso, 'get it'
12:48:50 <geekosaur> because that's the new model
12:49:07 <dminuoso> meinheld: music is taught by very different people.
12:49:18 <dminuoso> meinheld: My piano teacher was very non-spirtual, which I appreciated very much.
12:49:20 <geekosaur> it's like the early days of desktiop publishing when everyone thought  copy of pagemaker made them an instant exprt in design and layout
12:50:01 <meinheld> music has spirit. otherwise it's just button-pressing.
12:50:10 <dminuoso> Oh yeah, Im just saying that there's various teachers. :)
12:50:10 <meinheld> same with programming, imho
12:50:17 <geekosaur> not that that isn't currntly true of far too many javascript "experts" with their frameworks that make them instant experts (ugh)
12:50:40 <dmwit> Hm. I worry that we are straying into unhelpful ground.
12:50:55 <meinheld> i don't understand that last statement, dminuoso :]
12:51:04 <dmwit> I admit I had not expected it to be controversial to claim that some introductions to Haskell were good and some were bad.
12:51:10 <meinheld> concern>worry :D :P
12:51:55 <meinheld> anyway dmwit, you've helped me the most, so i'll listen to you for some reason.
12:51:57 <meinheld> haha
12:56:15 <meinheld> your class link evades my immediate understanding.
12:56:32 <meinheld> i take it you think i should use the 'resources'?
12:57:47 <fr33domlover> Data.List.NonEmpty doesn't have a singleton function, is that intentional? I can use 'pure' but it feels like abusing 'pure' and can be confusing in the code
12:58:07 <fr33domlover> Or is pure the intended way to make a singleton?
12:58:24 <Welkin> yes
12:58:29 <Welkin> that is the definition of pure
12:58:42 <fr33domlover> The more explicit way to do it is e.g. flip (:|) []
12:58:57 <fr33domlover> Which is fine but sort of more verbose
13:00:17 <__monty__> I'd say that's less explicit, not more.
13:00:31 <fr33domlover> Welkin, yeah I'm aware it's the definition, but is it clean when used in the code? because the name 'pure' refers to effect and 'singleton' refers to container
13:00:37 <fr33domlover> *clear
13:01:21 <fr33domlover> __monty__, yeah it's not pretty, I mean it has a more specific type
13:01:24 <meinheld> or maybe i should just go popular and do python
13:01:40 <dminuoso> meinheld: Maybe you should ask yourself what your goal is.
13:02:15 <meinheld> i have no goal other than to learn a programming language and lovingly help people by *sharing* tools and resources
13:02:48 <meinheld> fun is the biggest part of that.
13:03:10 <fr33domlover> meinheld, I'm not sure there's a goof way to learn that doesn't include actual usage, make sure you have actual programs to write etc.
13:03:11 <meinheld> and to me, math is fun. but so is rubber-meet-road.
13:03:15 <__monty__> Haskell's pretty good in the fun and sharing bits so far. Probably by virtue of industrial use still being limited.
13:03:36 <fr33domlover> *good
13:03:38 <meinheld> doesn't incl actual usage? i mean, did i say that?
13:04:08 <fr33domlover> meinheld, no no I'm not quoting, just saying that if you want to learn and help, start by writing stuff in Haskell :)
13:04:43 <meinheld> well yes i will of course learn to do by doing.
13:04:57 <meinheld> i didn't mean to say i didn't want to write programs or something
13:05:10 <meinheld> i want to learn to code. so i code.
13:05:29 <meinheld> (b nice to have a good intro though haha)
13:05:37 <meinheld> i'm looking at the wiki
13:06:05 <__monty__> fr33domlover: I see what you mean. But in the context of lists, pure has a much clearer meaning than the flip imo, it gets the intent across better. Declaring a singleton function with either of them as body may get the intent across even better but that's a matter of taste.
13:06:06 <meinheld> "still under construction but covers already much ground. Also a classic text. " lolwut
13:06:50 <dmwit> meinheld: No, not the resources page; the "Lectures and Assignments" page.
13:07:01 <dmwit> Solonarv linked directly to it.
13:07:34 <meinheld> k i'm there
13:07:47 <Welkin> meinheld: if you want to learn to program for fun anf fulfillment, Haskell is the perfect choice
13:07:55 <fr33domlover> meinheld, one insight I have about Haskell is that it's a big world to discover, and I thinl one of the first steps is to discover whether you enjoy functional programming and the type system features
13:08:18 <__monty__> meinheld: I think what they were saying was more along the lines of, don't read entire books and articles before trying to write *something*. Some people get stuck thinking they can't write anything useful/well designed and let it keep them from trying and failing, which is a very useful method of learning.
13:08:41 <Welkin> I hate sitting and watching lectures or reading books for days on end
13:08:47 <Welkin> doing a real project is much more fun
13:09:09 <Welkin> although I do tend to read books I *enjoy* cover to cover in record time
13:09:47 <Welkin> Haskell only started making sense to me once I started writing non-trivial programs
13:12:02 <meinheld> fr33domlover, the constant type errors can be annoying, but i understand the value of compile-time error-discovery, i think. 
13:12:27 <meinheld> oh __monty__ , i jumped right in
13:12:55 <meinheld> i've only looked at a few videos sf, and i've already written 10 functions and started on a game
13:13:26 <meinheld> i learn best by doing and being led. 
13:13:40 <meinheld> anyway break time for me. thanks every1
13:14:35 <fr33domlover> meinheld, I suppose you learn to appreciate it eventually, but even before that, there's the joy (or lack of joy) of writing in functional style, using partial application, modeling stuff with algebraic datatypes etc.
13:15:15 <fr33domlover> I've been implementing stuff in Haskell that was originally Javascript and the difference is so huge it's super frustrating
13:15:22 <meinheld> i only sort of understood that. but then again, that's how everything is, and it's just fine. ;]
13:15:24 <fr33domlover> Somehow I survived though
13:16:03 <meinheld> haha wow. i learned a tiny bit of javascript and i can already appreciate how crazy that ride would be
13:16:10 <meinheld> anyway kthxbai
13:16:14 <meinheld> :]
13:30:52 * hackage Craft3e 0.1.1.1 - Code for Haskell: the Craft of Functional Programming, 3rd ed.  http://hackage.haskell.org/package/Craft3e-0.1.1.1 (SimonThompson)
13:40:52 * hackage primitive-maybe 0.1.1.1 - Arrays of Maybes  http://hackage.haskell.org/package/primitive-maybe-0.1.1.1 (chessai)
14:02:34 <Guest27547> Hi, Is there a operation equivalent to (<operator>) = (<*> return) in base library?  I just found https://github.com/ghc-proposals/ghc-proposals/pull/64, but the problem can be alleviated if we have something like (<*> return)
14:03:05 <kadoban> :t (<*> return)
14:03:07 <lambdabot> Monad m => (a -> m a -> b) -> a -> b
14:03:48 <Guest27547> My mistake, I am thinking things like: a <**> b = a <*> return b
14:05:36 <lyxia> :t \a b -> a <*> return b
14:05:37 <lambdabot> Monad f => f (a -> b) -> a -> f b
14:05:42 <Guest27547> d/msg NickServ IDENTIFY JZ 48F1tY9XETh
14:06:02 <lyxia> fatal mistake
14:06:08 <Solonarv> Guest27547: uh oh, might want to change your password now
14:06:18 <Guest27547> Yes... lol
14:08:42 <zachk> I usually try not to type the identify comman in a channel window 
14:08:43 <lyxia> Guest27547: the proposal does discuss why applicative and monadic operators are not ideal, things like (<**>) are part of it
14:09:41 <lyxia> and (<**>) is not in base
14:19:24 <neggi> \filter add irc_smart * irc_smart_filter *
14:19:40 <__monty__> JZ`: Also note that *all* of that can be lowercase, well except for the password ofc.
15:13:12 <suzu> hmm
15:13:18 <suzu> i've got an f :: IO a
15:13:28 <suzu> inside f i have a value that is Maybe b
15:13:47 <suzu> i want to unwrap the Just, but throw an exception if it is a Nothing
15:13:57 <suzu> is there an idiomatic way of doing this nicely?
15:14:04 <merijn> :t maybe
15:14:06 <lambdabot> b -> (a -> b) -> Maybe a -> b
15:14:36 <suzu> default value and function to process the maybe?
15:15:03 <merijn> :t \myerror act -> maybe (throwIO myerror) return <$> act
15:15:04 <lambdabot> (Exception e, Functor f) => e -> f (Maybe a) -> f (IO a)
15:15:23 <merijn> suzu: Yup
15:15:29 <merijn> Oh, wait that should be >>= of course
15:15:45 <merijn> :t (>>= maybe (throwIO myerror) return)
15:15:47 <lambdabot> error:
15:15:47 <lambdabot>     • Variable not in scope: myerror
15:15:47 <lambdabot>     • Perhaps you meant one of these:
15:16:03 <merijn> Anyway, you get the idea
15:16:06 <suzu> hmm
15:16:40 <suzu> ok, got it! thanks
15:16:53 <suzu> i was using fromMaybe earlier and having problems with the IO / Maybe nesting
15:18:47 <suzu> r <- maybe (throw "oshit") return $ maybeval
15:18:49 <suzu> works nicely
15:19:15 <suzu> throwString*
15:24:16 <dysfigured> can someone tl;dr heteromorphisms?
15:24:52 * hackage clustering 0.4.1 - High performance clustering algorithms  http://hackage.haskell.org/package/clustering-0.4.1 (kaizhang)
15:26:06 <jackdk> suzu: hoist-error exists but may be too heavy for your needs: https://hackage.haskell.org/package/hoist-error-0.2.1.0/docs/Control-Monad-Error-Hoist.html
15:26:16 <suzu> yeah don't need tht
15:26:17 <suzu> that *
15:26:20 <suzu> :P
15:27:26 <merijn> jackdk: That wouldn't even do the same thing
15:45:23 * hackage tasty-wai 0.1.1.0 - Test 'wai' endpoints via Test.Tasty  http://hackage.haskell.org/package/tasty-wai-0.1.1.0 (schalmers)
15:46:52 * hackage mixed-types-num 0.3.2 - Alternative Prelude with numeric and logic expressions typed bottom-up  http://hackage.haskell.org/package/mixed-types-num-0.3.2 (MichalKonecny)
16:19:04 <crestfallen>  hi is there an error in this formula utilizing the golden ratio, to find fibonacci numbers ? something is amiss.. thanks    https://ptpb.pw/LsC0
16:21:14 <int-e> crestfallen: / has higher precedence than -. But also, this is not a good way of computing fibonacci numbers in practice due to rounding errors...
16:21:34 <crestfallen> int-e: thanks one moment pls
16:22:22 <Ucenna> can retroactive data structures be coded functionally? 
16:25:29 <crestfallen> int-e: yeah parens solved that around x-y   .. how would you account for rounding errors?
16:25:31 <int-e> > let f n = let x = (1 + sqrt 5)/2; y = (1 - sqrt 5)/2 in (x^n - y^n) / (x - y) in f 10
16:25:34 <lambdabot>  54.99999999999999
16:25:53 <int-e> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 10
16:25:55 <lambdabot>  55
16:26:22 <crestfallen> thanks yeah I've used the zipWith method 
16:26:48 <int-e> > fix ((0 :) . scanl (+) 1)
16:26:50 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
16:31:36 <crestfallen> int-e: thanks kindly, pretty satisfied with 54.999999999999  !
16:35:25 <int-e> > let g 0 = (1,0); g n | odd n = let (a,b) = g (n-1) in (b, a+b) | otherwise = let (a,b) = g (n `div` 2) in (a^2 + b^2, 2*a*b + b^2); f = snd . g; n = f 1000000 in text $ concat [take 10 (show n), "...", show (n `mod` 10^10)]
16:35:28 <lambdabot>  1953282128...8242546875
16:37:00 <int-e> crestfallen: That's a more serious implementation. However, the millionth fibonacci number is a bit too big for IRC ;-)
16:38:51 <crestfallen> int-e: I'm taking a number theory course. I've seen the goldenRatio before, but I wanted to write it in haskell. I'm thinking of giving up haskell and math. too time consuming. (read: fishes for encouraging words )
16:44:23 * hackage scotty 0.11.3 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.11.3 (ryanglscott)
16:45:12 <aplainzetakind> @where cis194
16:45:12 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
16:45:34 <aplainzetakind> crestfallen: ^take a look at homework 6 there maybe.
16:46:12 <crestfallen> will do thanks
16:46:19 <crestfallen> aplainzetakind: ^
16:48:52 * hackage oeis2 1.0.1 - Interface for Online Encyclopedia of Integer Sequences (OEIS).  http://hackage.haskell.org/package/oeis2-1.0.1 (23prime)
16:57:37 <dmwit> Ucenna: What are retroactive data structures, and why would they be especially hard in functional languages?
17:07:54 <widmur> Hello all. I was hoping to get some clarification about Haskell's type inference.
17:11:06 <dmwit> You'll get much better clarification if you say what isn't clear. ;-)
17:11:30 <widmur> Sorry, in the middle of drafting a question.
17:11:44 <hpc> he's sharing his deepest hope and dream here, jeez :P
17:15:04 <widmur> If I have a function someFunction :: (Ord a, Num a) => a -> a, why is someFunction 1 :: (Ord a, Num a) => a? If all numeric values are orderable, wouldn't it make sense for someFunction 1 to have type (Num a) => a?
17:15:34 <shachaf> If all numeric values are orerable, then it would make sense.
17:15:37 <shachaf> But they aren't, so it doesn't.
17:15:51 <widmur> Ah, whoops.
17:16:27 <widmur> What would be an example of an unorderable numeric type?
17:16:48 <shachaf> Complex numbers?
17:17:31 * dmwit grumbles
17:17:55 <shachaf> Is this some grumble about how there's still a possible order, that lets you put them in a Map or whatever, even if it isn't very mathematically meaningful?
17:18:21 <dmwit> the very same
17:18:40 <shachaf> I was going to say computable reals but it turns out CReal actually does have an Ord instance.
17:19:03 <dmwit> Heh. That one is more of a lie than the Complex one would be if it existed.
17:19:36 <Lears> How about `Num b => Num (a -> b)`.
17:19:54 <dmwit> `(Finite a, Ord b) => Ord (a -> b)` ;-)
17:20:39 <dmwit> But yeah, that seems the most clear-cut of the examples so far.
17:20:51 <dmwit> Except that no common library defines it. =)
17:24:17 <xsperry> I have   interactByLineIO' :: (String -> IO ()) -> IO ()   and   processLine:: String -> StateT Int IO ()
17:24:38 <xsperry> interactByLineIO' (flip evalStateT 0 . processLine)  typechecks, but expectedly it doesn't do what I want (State is back to 0 after every line). is there a way to turn   Char -> StateT Int IO ()   into   Char -> IO ()   that would keep the state, or do I need a new interactByLine function?
17:25:53 <dmwit> Sure, allocate a ref cell and stick it in the closure.
17:26:09 <widmur> Thanks for your help shachaf.
17:26:21 <xsperry> dmwit, IORef?
17:26:24 <dmwit> yep
17:27:20 <xsperry> so a closure with IORef that keeps last state, and passes it to evalStateT 
17:27:44 <dmwit> do { ref <- newIORef 0; return (\s -> do { old <- readIORef ref; new <- execStateT blah old; writeIORef old }) } -- or something like that
17:28:00 <dmwit> ...writeIORef ref new, of course
17:28:03 <xsperry> yeah, got it
17:29:29 <xsperry> if I decided to make a new interact function instead, how could I make this function more general? so that it works with other transformers.  (String -> Bool) -> (String -> StateT a IO ()) -> StateT a IO ()
17:30:12 <dmwit> That... is a surprisingly difficult thing to do.
17:30:48 <dmwit> People have tried a number of different things that all don't work well for one reason or another.
17:30:49 <xsperry> really? ghci inferred interactByLineStateT :: (MonadIO m) => (String -> Bool) -> (String -> m a) -> m ()
17:31:17 <dmwit> Sure. But then you aren't returning an IO (). If that's okay, then great.
17:31:27 <xsperry> that is fine
17:31:41 <xsperry> so that would work with all transformers?
17:32:14 <dmwit> Just about.
17:34:03 <xsperry> ok nice
17:44:45 <xsperry> what about making this more general? it works now, but if I add another transformer layer it won't work.  processLine :: String -> StateT StateData IO ()
17:45:08 <xsperry> ghci infers that same type
17:47:28 <Lears> With mtl you just replace each layer of the explicit stack with the respective constraint; e.g. you can use `MonadState StateData m => ...`.
17:51:20 <xsperry> I can't figure out the part after =>
17:51:57 <xsperry> instinctively I was thinking this, but I am getting errors. (MonadState StateData m) => String -> m ()  
17:53:13 <Lears> That looks fine as long as you only need to manage state purely. If you want to do IO as well you'll need the constraint for that too.
17:54:20 <xsperry> (MonadState StateData m, MonadIO m) => String -> m ()   gives me  * Couldn't match type `m' with `StateT StateData IO'.  I guess I have to change signatures of other functions?
17:57:21 <Lears> Or you're using values that actually imply precise transformers stacks inside the function. I'm about to be busy, but you'll probably get better help with this if you gist/paste your code.
17:58:08 <xsperry> I'll have to make a test case, my actual code is pretty big
17:58:22 <xsperry> I'll try changing all the types first
18:03:26 <Ucenna> dmwit: it's a data structure with version control were changes made to older versions ripple into the future. 
18:04:20 <Ucenna> I suppose the functional equivalent would be a persistent data structure with a mutation log
18:04:36 <xsperry> wow, it compiled :P
18:05:03 <xsperry> I also had to ask MonadMask m constraint, despite not knowing wth that is. but it compiles, and it works
18:20:55 <WinchellsM> How does one cast from Float to CDouble?
18:22:27 <xsperry> :t realToFrac
18:22:28 <lambdabot> (Fractional b, Real a) => a -> b
18:22:31 <xsperry> ^^ WinchellsM 
18:26:44 <WinchellsM> The following compiles: `CDouble (float2Double floatValue)`; however, I'm worried this won't actually be an edible value for a C function that expects a double.
18:27:56 <xsperry> your C function accepts a pointer to double?
18:31:53 * hackage project-m36 0.6 - Relational Algebra Engine  http://hackage.haskell.org/package/project-m36-0.6 (agentm)
18:50:57 <platz> is there a way to derive Generic for yesod's Route ?
18:51:26 <platz> having trouble because it's a data instance
18:52:41 <xsperry> is it possible to call   Char -> State Int Char    inside of    String -> StateT Int IO ()?  I am getting * Couldn't match type `Data.Functor.Identity.Identity' with `IO'
18:53:44 <xsperry> (MonadState Int m) => Char -> m Char made it callable, but I'm just curious if it is possible to mash the two together if I had State Int Char
18:57:22 * hackage termonad 1.1.0.0 - Terminal emulator configurable in Haskell  http://hackage.haskell.org/package/termonad-1.1.0.0 (cdepillabout)
18:59:00 <pavonia> xsperry: You could use mapStateT
19:00:00 <xsperry> :t mapStateT
19:00:02 <lambdabot> (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
19:00:37 <pavonia> :t (mapStateT (return . runIdentity)
19:00:39 <lambdabot> error:
19:00:39 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
19:00:49 <pavonia> :t mapStateT (return . runIdentity)
19:00:51 <lambdabot> Monad n => StateT s Identity b -> StateT s n b
19:01:08 <xsperry> :t runIdentity
19:01:09 <lambdabot> Identity a -> a
19:01:53 * hackage lens-regex 0.1.1 - Lens powered regular expression  http://hackage.haskell.org/package/lens-regex-0.1.1 (TakahiroHimura)
19:02:24 <platz> it appears I can do  deriving instance Generic (Route App) in ghci but not in the compiled app
19:03:37 <xsperry> my types were wrong above. I have f :: Char -> StateT Int IO ()  that is trying to call   g :: Char -> State Int Char. I tried just runIdentity g, and I got       Expected type: Identity (StateT Int IO t0)         Actual type: State Int Char
19:05:17 <platz> ah, i just had to move it below mkYesodData i guess
19:12:04 <geekosaur> yes, that's a template haskell splice, which has some positional dependencies normal code doesn't
19:12:16 <geekosaur> in particular, it's not visible to anything before the splice
19:12:37 <geekosaur> which is what happens with stuff that is run at compile time (which is what template haskell is about)
19:13:28 <pavonia> :t \g c -> mapStateT (return . runIdentity) (g c) *> pure 'x'
19:13:29 <lambdabot> Monad n => (t -> StateT s Identity a) -> t -> StateT s n Char
19:13:51 <pavonia> xsperry: ^ like this?
19:14:12 <pavonia> Hhm no
19:14:34 <xsperry> do we need mapStateT? both functions accept Char, the only difference is StateT vs State
19:15:01 <pavonia> which is an important difference
19:15:23 <pavonia> one state can do IO, the other one is pure
19:15:27 <xsperry> ok, I thought that was a leftover from my initial signature mistake (String instead of Char)
19:15:37 <xsperry> yes
19:18:09 <xsperry> I'm confused why this is an issue, though? Char -> IO Char  action can call Char -> Char  function without issues
19:20:47 <xsperry> actually, nm, both State and StateT are monads, with incompatible bind 
19:27:52 <geekosaur> State is StateT Identity
19:33:45 <POGtastic> very stupid question: why does this pattern matching match on any character and not the provided argument character? https://pastebin.com/GFcLiSJx
19:35:16 <julianleviston> POGtastic: because that’s the way pattern matching works. It binds to variables… and there you’re shadowing your c variable.
19:35:56 <julianleviston> POGtastic: the way it works in haskell, at least.
19:36:18 <POGtastic> julianleviston: in that case, I suppose I need to use guards and boolean statements to check for the empty list, one whose head matches c, and otherwise?
19:36:32 <julianleviston> POGtastic: sounds like a fine way to do it.
19:37:02 <julianleviston> or an if expression.
19:37:30 <julianleviston> (x:xs) -> if x == c then Just ([c], xs) else Nothing
19:37:54 <julianleviston> tho yeah, a guard across the whole thing would be nicer
19:38:23 <POGtastic> julianleviston: actually, i think your approach is nicer. one pattern match for the non-empty list, and one for the empty list
19:39:28 <POGtastic> perfect, it works. thank you
19:41:29 <julianleviston> POGtastic: could genMatchCharFunc c str | length str != 0 && c == head str = Just ([c], xs) and then | otherwise = Nothing
19:42:38 <julianleviston> not sure which is clearer
19:42:40 <POGtastic> yeah, that would work too. I think that your first approach looks nicer though - we don't really care about the actual length of the string, we just care about seeing if it's empty or not
19:42:54 <POGtastic> and pattern matching does that really nicely
19:42:56 <julianleviston> well there’s always null
19:42:58 <julianleviston> :t null
19:42:59 <POGtastic> true
19:42:59 <lambdabot> Foldable t => t a -> Bool
19:43:14 <julianleviston> POGtastic: sweet. as long as you’re happy :)
19:43:22 <POGtastic> :)
19:43:44 <julianleviston> POGtastic: I think I agree, readability should probably trump concision. :)
19:43:53 <julianleviston> I usually prefer things to be immediately obvious
19:44:07 <xsperry> POGStatic, not sure if you know this, but  "genMatchCharFunc c = \str -> "   is the same as  "genMatchCharFunc cstr"
19:44:20 <xsperry> "genMatchCharFunc c str =" even
19:44:46 <POGtastic> xsperry: in retrospect, this is very obvious. yay currying
19:45:56 <xsperry> yeah
19:45:58 <julianleviston> xsperry: also, no need for parens on the RHS of the Type signature ;-) (But I assumed they realised this, and it was just for clarity)
19:46:11 <julianleviston> POGtastic: I guess I’d probably create a helper function startsWith :: Char -> [Char]
19:46:12 <xsperry> indeed
19:46:22 <julianleviston> POGtastic: startsWith c [] = False and startsWith c (x:xs) = c == x
19:46:49 <dmwit> Ucenna__: You might like http://www.umut-acar.org/self-adjusting-computation
19:46:52 * hackage yaya 0.2.1.0 - Total recursion schemes.  http://hackage.haskell.org/package/yaya-0.2.1.0 (sellout)
19:47:18 <julianleviston> oops… flip and incorrect type signature startsWith :: [Char] -> Char -> Bool
19:47:36 <dmwit> startsWith c xs = [c] == take 1 xs
19:48:18 <Ucenna__> dmwit: thanks! that's right in line with what I'm planning to do? 
19:48:22 <julianleviston> dmwit: nice :)
19:48:35 <dmwit> :t stripPrefix
19:48:36 <lambdabot> Eq a => [a] -> [a] -> Maybe [a]
19:48:38 <julianleviston> dmwit: maybe ;-) unsure
19:48:47 <julianleviston> POGtastic: then we could say: genMatchCharFunc c str = if str `startsWith` c then Just ([c], xs) else Nothing
19:49:18 <dmwit> Oh, you just want stripPrefix anyway. =)
19:49:40 <julianleviston> dmwit: I don’t know… doesn’t he want split?
19:49:43 <julianleviston> :t split
19:49:45 <lambdabot> Splitter a -> [a] -> [[a]]
19:49:52 <julianleviston> eh that wasn’t what I was expecting :)
19:49:56 <dmwit> I don't know. I've only read about ten seconds worth of context. =)
19:49:59 <julianleviston> :t splitWith
19:50:00 <lambdabot> error:
19:50:00 <lambdabot>     • Variable not in scope: splitWith
19:50:00 <lambdabot>     • Perhaps you meant one of these:
19:50:12 <dmwit> > stripPrefix "foo" "foobar"
19:50:14 <lambdabot>  Just "bar"
19:50:20 <dmwit> > stripPrefix "foo" "notbar"
19:50:21 <julianleviston> dmwit: it just checks if the head is equal to a char, and if so, splits it into a pair, in a Maybe.
19:50:22 <lambdabot>  Nothing
19:50:55 <dmwit> :t \c cs -> (,)[c] <$> stripPrefix [c] cs
19:50:56 <lambdabot> Eq a => a -> [a] -> Maybe ([a], [a])
19:51:00 <julianleviston> Guh could have sworn tehre was a splitWith
19:52:10 <dmwit> :t \cs -> liftA2 (<$>) (,) (`stripPrefix` cs) . pure -- confuse and delight your readers
19:52:11 <lambdabot> Eq a => [a] -> a -> Maybe ([a], [a])
19:52:20 <julianleviston> dmwit: surely we don’t need to reinvent the wheel ;-)
20:08:47 <julianleviston> POGtastic: here’s a kind of elegant version if you put it on four lines, and if you like the Maybe monad… (untested) genMatchCharFunc c str = do { guard (not . null $ str) ; let splitVal @ ([c1], _) = splitAt 1 str ; guard (c1 == c) ; return splitVal }
20:09:09 <julianleviston> I can’t actually remember if you can use as patterns in let bindings.
20:09:30 <julianleviston> Oh you can. Sweet. :)
20:15:21 <geekosaur> sure
20:23:22 <julianleviston> I suppose if one is stripping the code down to its tightest semantics, it’s trying to say “when the first element matches this element, give me the split pair”, and it’s over maybe as failure against that being the case (for when there’s no first element, or when they don’t match). It’s interesting thinking about how to clearly encode that semantics in Maybe. Overkill for the question, I know, but still fascinating.
20:24:36 <julianleviston> In fact (of course) it has nothing to do with Maybe, per se. Just “failure” as a general abstract monadic concept.
20:25:05 <julianleviston> but the interesting piece is how to encode that meaning in a way that is completely obvious and clear when one sees it, I guess.
20:25:38 <julianleviston> given that part of the encoding is the conditionality of the first item being equal to the provided item.
20:26:16 <julianleviston> coz… whether the list is empty or not isn’t so important. What’s important is whether it matches, and that includes whether the list is empty.
20:33:41 <julianleviston> I suppose this might be a good version of it, assuming I understand when properly :) matchHeadItemMay x ys = do { result @ ([matchItem], _) <- maybeSplitAt1 ys ; when (matchItem == x) return result }
20:34:22 <julianleviston> bit more generic, too.
20:34:52 <julianleviston> where maybeSplitAt1 xs =  case splitAt 1 xs of res @ ([_], _) -> Just res ; _ -> Nothing
20:35:11 <POGtastic> i think we're getting waaaaaay ahead of ourselves here lol
20:35:25 <julianleviston> POGtastic: hehe I just found the thought exercise interesting :) sorry :)
20:35:48 <julianleviston> POGtastic: back to writing a test for my GHC bug fix :)
21:15:27 * hackage th-utilities 0.2.1.0 - Collection of useful functions for use with Template Haskell  http://hackage.haskell.org/package/th-utilities-0.2.1.0 (MichaelSloan)
22:28:58 * hackage salak 0.1.6 - Configuration Loader  http://hackage.haskell.org/package/salak-0.1.6 (leptonyu)
22:58:28 * hackage yam 0.5.6 - Yam Web  http://hackage.haskell.org/package/yam-0.5.6 (leptonyu)
22:59:27 * hackage yam-datasource 0.5.6 - Yam DataSource Middleware  http://hackage.haskell.org/package/yam-datasource-0.5.6 (leptonyu)
23:02:58 * hackage http-client 0.6.0 - An HTTP client engine  http://hackage.haskell.org/package/http-client-0.6.0 (MichaelSnoyman)
23:08:41 <dminuoso> % type instance F '[Int, Bool] = Float
23:08:42 <yahb> dminuoso: ; <interactive>:41:17: error:; * Expected a type, but '[Int, Bool] has kind `[*]'; * In the first argument of `F', namely '[Int, Bool]; In the type instance declaration for `F'
23:08:52 <dminuoso> Is there a reason for this?
23:12:13 <dminuoso> Oh, I think I see why.
23:12:28 <jle`> dminuoso: what's the kind signature of F ?
23:13:07 <dminuoso> jle`: My mistake lied in assuming GHC inferred the kind, but that clearly can't happen in an open type family.
23:14:34 <dminuoso> % type family G a where G '[Int, Bool] = Float
23:14:34 <yahb> dminuoso: 
