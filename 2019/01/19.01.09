00:10:58 * hackage web3 0.8.3.0 - Ethereum API for Haskell  http://hackage.haskell.org/package/web3-0.8.3.0 (akru)
00:22:28 * hackage genvalidity-hspec 0.6.2.2 - Standard spec's for GenValidity instances  http://hackage.haskell.org/package/genvalidity-hspec-0.6.2.2 (Norfair)
01:32:30 <jersey26> Hi, I'm new to Haskell
01:32:47 <jersey26> please someone help me with this function
01:36:27 <jersey26> https://gist.github.com/truong-pham/6fef21a3da7d878fee5b7d9a5a636e08
01:36:40 <jersey26> why does it say the function is not exhausted
01:38:06 <Rembane> jersey26: I think it needs a base case for the empty list. 
01:38:20 <Rembane> jersey26: Do you know what they look like?
01:38:44 <jersey26> Yep, I tried but it still doesn't work
01:39:01 <jersey26> I added mzip [] = []
01:40:50 <Rembane> jersey26: What error message do you get with that basecase? 
01:41:03 <v0d1ch> try this
01:41:04 <v0d1ch> ```mzip :: Eq a => [a] -> [(a,a)]
01:41:04 <v0d1ch>    mzip [] = []
01:41:04 <v0d1ch>    mzip a = do
01:41:04 <v0d1ch>         x <- a
01:41:04 <v0d1ch>         y <- a        
01:41:04 <v0d1ch>         return (x,y)
01:41:05 <v0d1ch> ```
01:41:05 <v0d1ch>    
01:41:24 <jersey26> Rembane: I got this  "helloworld.exe: helloworld.hs:(5,1)-(10,20): Non-exhaustive patterns in function  mzip"
01:41:58 <Rembane> jersey26: Even when you use something like v0d1ch just pasted?
01:43:20 <jersey26> Ah it works now, thanks Rembane, v0d1ch
01:44:23 <Rembane> jersey26: No worries! 
01:44:30 <dminuoso> jersey26: [a] is a pattern that refers to an array containing exactly one element, and that one element is bound to the variable `a`
01:44:37 <jersey26> one small question, why put "True <- return (x /= y)" before return break the do sequence?
01:44:39 <dminuoso> Sorry. *list*
01:44:45 <v0d1ch> jersey26: it didn't work before because you didn't pattern match on all possible cases
01:45:23 <dminuoso> jersey26: So you had two patterns: one for an empty list, and one for a list containing exactly 1 element. But what if the list had more than one elements?
01:47:23 <jersey26> dminuoso it's a mistake, I should pass just a as List into function not [a]. I'm new to Haskell and still make many mistakes like that
01:48:26 <jersey26> I'm reading about Monad and couldn't find out why "True <- return (x /= y)" before return break the do sequence?
01:48:59 <Rembane> jersey26: In which monad?
01:50:10 <jersey26> in the example I put before, if put that line before returning (x,y) it will not include x=y pair
01:50:32 <tdammers> Rembane: it shouldn't matter an awful lot, should it?
01:50:35 <Taneb> jersey26: incomplete pattern matches in do notation like that use the "fail" function, which is in the process of being moved from the Monad class to the MonadFail class. For the [] monad, which I think is what you're using, fail _ = []
01:52:02 <adamretter> Hey guys, I think I now have an idea of how Haskell the language handles I/O with the I/O Monad. i.e. IO[a] is really a function from RealWorld to (a, RealWorld). When exected, the runtime applies the main I/O function to a RealWorld state- passes a RealWorld state value. My question is - how is getChar: IO[char] and the such implemented, internally do they do something like call functions on RealWorld? 
01:54:07 <dminuoso> adamretter: Internally you can think of an `IO a` as just an `a` that when forced will do the side effects producing a result of type `a`.
01:54:16 <dminuoso> That's how GHC does it at least.
01:54:44 <adamretter> dminuoso: so there is no RealWorld object or value as such, it just serves for ordering computations when writing code?
01:54:49 <dminuoso> adamretter: Right.
01:55:08 <adamretter> dminuoso: hmm interesting
01:55:09 <dminuoso> adamretter: The token being passed is basically just an unlifted unit ()
01:55:26 <adamretter> dminuoso: er... ok
01:55:44 <jersey26> Taned: I've just checked the MonadFail but I don't want to use any recover function here. I just want to know why the do sequence is broke if <- not match
01:57:18 <dminuoso> adamretter: Functions like `unsafePerformIO` essentially have a way to produce such a `State# RealWorld` token, so they can extract the `a` out.
01:57:39 <adamretter> dminuoso: yes I saw that and ran away screaming
01:57:46 <dminuoso> With some additional housekeeping things to do this in a safe (in the sense that *really* bad things wont happen) manner. It's still unsafe because ordering is no longer respected.
02:05:53 <Rembane> tdammers: That's true, I was hoping for more context. 
02:08:35 <tdammers> jersey26: because a failed pattern match in do notation invokes the Monad fail method
02:09:45 <tdammers> jersey26: True <- action -- means "take the result of 'action' and match it against 'True'; if it succeeds, return the continuation, else return a 'fail'
02:11:11 <tdammers> action >>= \x -> case x of { True -> {- rest of the do block -} ; _ -> fail } -- is what it desugars to, approximately (and if you look at the intermediate compilation steps, you'll actually see code that looks very similar to this)
02:12:15 <jersey26> tdammers: so does do return the result of fail or just call fail as recover function and never return at all
02:12:40 <tdammers> I don't think 'return' means what you think it does here
02:13:23 <tdammers> it doesn't throw an exception, if that's what you mean (unless throwing an exception is how the particular Monad instance implements fail)
02:13:26 <tdammers> :t fail
02:13:28 <lambdabot> Monad m => String -> m a
02:13:55 <jersey26> tdammers: I meant, if fail is called then the result of do block is the result of fail right?
02:14:38 <tdammers> if you end up in the 'fail' branch, then the do block evaluates to whatever 'fail' returns, yes
02:15:00 <tdammers> which is a monadic value in the same monad as it was encountered in
02:15:06 <Boomerang> > fail "" :: Maybe Int
02:15:08 <lambdabot>  Nothing
02:15:26 <tdammers> > fail "oh dear" :: Either String Int
02:15:28 <lambdabot>  *Exception: oh dear
02:15:32 <tdammers> > fail "oh dear" :: [Int]
02:15:35 <lambdabot>  []
02:15:59 <adamretter> dminuoso: thanks :-)
02:18:50 <dminuoso> adamretter: It should be noted, that trying to do this manually like this https://github.com/haskell/bytestring/blob/master/Data/ByteString/Internal.hs#L592 has a great potential to do bad things.
02:20:56 <dminuoso> adamretter: So there's some additional things going on under the hood that provide boundaries for GHC optimizations. A random example would be: Imagine internally you had two expressions like `malloc 4096` in the same binding - GHC could apply common subexpression elimination.
02:21:28 <jersey26> tdammers: in this case https://gist.github.com/truong-pham/eb00bf67faf24765aad4c59ea7a3e98c fail for monad List will return [], how it it appended into [(x,y)]
02:25:52 <tdammers> oh.
02:26:01 <tdammers> it doesn't append at all
02:27:59 <adamretter> dminuoso: So I am a totally Haskell beginner, so I understand how to get the result with the IO Monday, because it is a function, it is applied to RealWorld. More generally are Monad's always functions? i.e. you can un-box them by applying them? 
02:28:10 <tdammers> if the pattern match fails, the entire do block will uncritically return []
02:28:16 <adamretter> dminuoso: I would appreciate a simple non-Haskell-expert rely ;-)
02:30:49 <Boomerang> > do { fail "hey"; undefined } :: [Int] -- jersey26, it doesn't even evaluate the rest of the monad
02:30:51 <lambdabot>  []
02:32:07 <dminuoso> adamretter: Monad is formally just an API.
02:32:08 <matheus23> Hi! Is it possible to configure ghci so that typed holes are only warnings, not type errors? I'm kind of scared of -fdefer-type-errors
02:32:09 <dminuoso> adamretter: An interface.
02:32:25 <merijn> matheus23: -fdefer-typed-holes :)
02:32:27 <dminuoso> adamretter: Monad is a set of two functions. :)
02:32:37 <matheus23> merijn: Awesome, thanks! :)
02:32:42 <dminuoso> adamretter: Some types happen to conform to that interface.
02:33:06 <merijn> matheus23: I hacked that in because I too, am scared of -fdefer-type-errors ;)
02:33:08 <adamretter> those functions being `bind` and `return`?
02:33:11 <dminuoso> adamretter: Right.
02:33:43 <matheus23> merijn: Hey nice! Thanks for that :) May I ask you what your real name is?
02:33:58 <adamretter> dminuoso: okay but if I have something like M[x] - how do I get the x? With IO[Char] I can apply the IO to real-world as it is a function
02:34:18 <dminuoso> adamretter: It's not part of the interface of Monad.
02:34:22 <merijn> adamretter: Two relevant and readable links: https://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity.html https://blog.jle.im/entry/io-monad-considered-harmful.html
02:34:24 <matheus23> nvm it is your real name, right? Haha okay, haven't you around yet it seems :D
02:34:50 <dminuoso> adamretter: So it depends. For `IO` there's no such way (pretend that unsafePerformIO does not exist for the purpose of this discussion)
02:35:04 <dminuoso> Or rather for `IO a` I should say.
02:35:19 <dminuoso> adamretter: For `[a]` there's also no such way. 
02:35:20 <merijn> I should write "RealWorld considered harmful", although I suspect someone else already has
02:35:22 <jersey26> tdammers: thanks, I'm not still quite sure but I'll read more about fail monad
02:35:45 <adamretter> dminuoso: I see, so if I wanted to get M[a] it would depend on what I implemented to make that happen?
02:36:00 <dminuoso> adamretter: Right. Also in Haskell you'd just write `M a`
02:36:25 <merijn> jersey26: fail is...in flux right now. It is currently a method in monad, which is widely considered a mistake. In recent GHCs there's work to check "partial" matches in do notation via the -XMonadFailDesugaring extension
02:36:39 <dminuoso> adamretter: You'd have to define the semantics of `M a -> a`, and see whether your datatype can conform to these semantics.
02:39:15 <adamretter> dminuoso: understood
02:47:15 <matheus23> How do I filter a list of values with lens? Using view (myLensIntoAList . filtered predicateFunc) ... makes predicateFunc :: [Things] -> Bool, which is weird to me
02:47:27 <matheus23> I expected predicateFunc :: Things -> Bool
02:49:19 <lyxia> What's the type of myLensIntoAList
02:50:37 <lyxia> oh wait no I misread the problem
02:52:10 <lyxia> myLensIntoAList . traverse . filtered predicateFunc
02:52:42 <matheus23> lyxia: ah nice I'll try that
02:58:28 <matheus23> lyxia: Unfortunately my code is a little more complex. If I understand the error message correctly, it seems traverse makes the whole expression live in an arbitrary monad (or applicative or something), so my expression that was BigThing -> [Thing] before, is now BigThing -> m0 [Thing]
03:01:08 <matheus23> lyxia: This is the "real" code: https://pastebin.com/ARAVJncw If the solution is not obvious, don't bother helping me, I've got another version (commented out there) that works and is okay from a code style perspective I think :)
03:01:28 <lyxia> I can probably fix it
03:02:20 <lyxia> (BTW Is that an elm error message?)
03:03:54 <lyxia> you probably don't want view, which is only for getters (that output exactly one element) whereas filtered gives you a Fold (0 or more elements and you're not supposed to put things back).
03:06:34 <lyxia> it seemed to work before because   myLensIntoAList . filtered predicateFunc   produces a list of the elements at once, as opposed to each element one by one (which traverse does).
03:07:13 <lyxia> (^..) (aka toListOf) is probably the right combinator here https://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-Fold.html#v:toListOf
03:17:57 * hackage ron 0.4 - RON, RON-RDT, and RON-Schema  http://hackage.haskell.org/package/ron-0.4 (cblp)
03:21:45 <berndl> General question: how do you go about debugging the types of subexpression in a bigger expression? The way I do it now is I break the big expression into a let/where with multiple variables and then put a _ (hole) somewhere so that ghci shows me the types.
03:22:46 <Boomerang> berndl: you can put a hole in a type annotation! :)
03:23:10 <Rembane> That's exactly how I do it. With some use of traceShow from Debug.Trace where I need the value of an expression.
03:23:15 <Boomerang>  (a :: _holeForA) + b * c + (d :: _holeForD)
03:23:37 <berndl> Boomerang: That's clever.
03:27:57 * hackage hyraxAbif 0.2.3.14 - Modules for parsing, generating and manipulating AB1 files.  http://hackage.haskell.org/package/hyraxAbif-0.2.3.14 (andrevdm)
03:30:58 * hackage haskell-tools-ast 1.1.1.0 - Haskell AST for efficient tooling  http://hackage.haskell.org/package/haskell-tools-ast-1.1.1.0 (lazac)
03:31:57 * hackage haskell-tools-backend-ghc 1.1.1.0 - Creating the Haskell-Tools AST from GHC's representations  http://hackage.haskell.org/package/haskell-tools-backend-ghc-1.1.1.0 (lazac)
03:32:58 * hackage haskell-tools-debug 1.1.1.0, haskell-tools-daemon 1.1.1.0, haskell-tools-cli 1.1.1.0, haskell-tools-builtin-refactorings 1.1.1.0 (lazac)
03:33:58 * hackage haskell-tools-rewrite 1.1.1.0, haskell-tools-refactor 1.1.1.0, haskell-tools-prettyprint 1.1.1.0, haskell-tools-experimental-refactorings 1.1.1.0 (lazac)
03:34:58 * hackage haskell-tools-demo 1.1.1.0 - A web-based demo for Haskell-tools Refactor.  http://hackage.haskell.org/package/haskell-tools-demo-1.1.1.0 (lazac)
03:40:17 <adamretter> dminuoso: would you have a moment to read what I wrote in "Haskell's I/O Monad" - https://blog.adamretter.org.uk/p/91d0d281-41c5-4f04-bf9a-cd06c0e72dc5/  I just want to make sure I haven't said something stupid. This is meant for non-haskeller's hence the pseudo-code
03:40:38 <Taneb> Is there any function like Maybe a -> String -> IO a, extract the value from the maybe or fail with a message
03:43:02 <Taneb> I guess you could have any MonadFail in place of IO
03:43:08 <merijn> adamretter: My main comment would be: Please consider reading this blogpost and think about editing the IO part of your post https://blog.jle.im/entry/io-monad-considered-harmful.html
03:44:30 <adamretter> merijn: huh interesting. I will be sure to read that and make edits if I think it will help (which it looks like it will) - thank you!
03:46:33 <Boomerang> :t \err -> maybe (fail err) pure -- Taneb :D
03:46:34 <lambdabot> Monad m => String -> Maybe a -> m a
03:46:56 <merijn> adamretter: Also, there was another blog post I linked earlier (which deals more with explanation than terminology) that I like (because I strongly dislike explanations involving RealWorld :)) https://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity.html
03:47:00 <berndl> adamretter: "All Haskell programs are an I/O Monad" <-- This makes no sense.
03:47:28 <Taneb> Boomerang: I think I'll stick to what I have for now :P Thanks, though!
03:47:40 <adamretter> @berndl The main of a Haskell program has to be of type IO? So does that not bean the whole program is an IO?
03:47:40 <lambdabot> Unknown command, try @list
03:47:59 <adamretter> berndl: The `main` of a Haskell program has to be of type IO? So does that not bean the whole program is an IO?
03:48:02 <merijn> adamretter: I think berndl's complaint is basically the same one made in the first link I gave :)
03:48:26 <merijn> adamretter: i.e. "All Haskell programs are an IO action" or something similar would generally be preferred
03:48:37 <berndl> ^ I like that better
03:48:58 <adamretter> merijn: okay I understand... But IO is a Monad, so is what I said technically wrong?
03:49:19 <berndl> IO has a Monad instance.
03:49:47 <merijn> adamretter: IO is an instance of Monad, yes. But that's just an interface. Haskell could've had the exact same IO approach it does now, even if Monad didn't exist :)
03:49:57 <Boomerang> :t flip maybe pure . fail -- Taneb was it not point free enough? :D
03:49:59 <lambdabot> Monad f => String -> Maybe a -> f a
03:50:03 <Ariakenom> let's not copy paste the linked text into IRC, go read it :)
03:50:15 <merijn> Ariakenom: Fair point ;)
03:50:28 <adamretter> berndl: Hmmm, I think my Haskell "terminology" is still very bad ;-)
03:50:38 <adamretter> I will read those articles
03:52:37 <mpickering> has anyone else ever seen criterion report negative numbers?
03:52:52 <merijn> mpickering: I think I have, lemme check
03:53:34 <merijn> mpickering: Yup: See the last set of benchmarks here: http://files.inconsistent.nl/sync-threaded.txt
03:53:44 <merijn> -3 and -5 milliseconds
03:53:51 <merijn> Never figured out wtf was going on
03:53:58 <mpickering> right, great stuff
03:54:19 <mpickering> my benchmarks look terrible anyway `(-1.932 s .. 6.005 s)`
03:54:45 <merijn> mpickering: I think it's basically the variance computed and it doesn't account for clamping to 0
03:55:18 <mpickering> my variance is very high anyway
03:55:26 <mpickering> https://www.irccloud.com/pastebin/i6GKGl4d/
03:55:30 <mpickering> need to figure out what's going on
03:55:45 <nyc> I mostly just timed runs. Figuring out where the overheads were was pure reason.
03:56:00 <merijn> mpickering: 302.3 μs  <- yeah, criterion gets very noisy at times that small
03:56:22 <merijn> mpickering: But that in itself isn't so bad
03:56:37 <merijn> mpickering: The reall issue is that your R^2 is shit :p
03:56:49 <nyc> merijn: t testing becomes necessary.
03:57:21 <merijn> mpickering: At very small measures gc and/or context switching become massive variance inducing events so at microsecond levels you will definitely have outlier inflated variance.
03:58:07 <adamretter> Thanks - bbl
03:59:02 <mpickering> still have 83% variance with 175ms runtime on another benchmark
03:59:24 <mpickering> https://www.irccloud.com/pastebin/x7cfwW3k/
04:00:03 <nyc> merijn: That's probably going to flunk statistical significance tests.
04:02:58 * hackage mbug 1.3.1 - download bugs mailboxes  http://hackage.haskell.org/package/mbug-1.3.1 (DmitryBogatov)
04:06:57 * hackage mbug 1.3.2 - download bugs mailboxes  http://hackage.haskell.org/package/mbug-1.3.2 (DmitryBogatov)
04:31:13 <royal_screwup21> could someone walk me through the concept of a skip list? I'm looking at  the wikipedia page but the diagram there seems to break the mental model in my mind
04:31:14 <royal_screwup21> I thought a skip list was basically a sorted linked list, except that a node could point to not just the next element, but also to an element further away
04:33:17 <ventonegro> It's a list of lists, each with a different coarseness
04:34:18 <ventonegro> So, during search, you started with the more coarse one. If you find a node that's supposed to come after the node you want, you back up a node and go to the next list, which may have your node
04:34:51 <royal_screwup21> ventonegro: by coarseness, you mean lengths?
04:34:57 <ventonegro> In the worst case you reach the final list, which is supposed to have all the nodes
04:35:10 <ventonegro> I mean "skips more"
04:35:46 <ventonegro> The base list has all the nodes. The next one skips every other node. The next one has every fourth node. And so on
04:36:22 <royal_screwup21> ah I see
04:40:18 <royal_screwup21> ventonegro: why is it a list of lists, as opposed to a sorted linked list, wherea node could point to not just the next element, but also to an element further away
04:41:51 <ventonegro> It's basically the same idea
04:44:30 <royal_screwup21> ok I see the diagram here and it's starting to crystallize https://prnt.sc/m4w35l
04:47:06 <royal_screwup21> hmm..."Expected number of elements we scan on level i is the expected number of times we
04:47:06 <royal_screwup21> have to flip a coin to get head"
04:47:47 <royal_screwup21> not sure I understand that...I thought the number of elements of every level was fixed? i.e, the bottomost level would have all nodes, the one above it would have every second node, the one above that every third node...
04:48:32 <royal_screwup21> oh wait, okay, it's talking about "scanning"
04:48:55 <royal_screwup21> still not sure what that has to do with flipping a coin to get heads
04:50:28 <ventonegro> According to wikipedia, most implementations are probabilistic
04:50:46 <ventonegro> So there is a chance a node will be part of the next-level list
04:58:00 <royal_screwup21> okay...so you decided whether to include a node in a list, S[i], depending on the outcome of a coin toss
05:00:33 <royal_screwup21> I still don't get how search time is logn as opposed to n
05:03:10 <nyc> Those are averages, not worst case.
05:05:58 * hackage qrcode-core 0.8.0 - QR code library in pure Haskell  http://hackage.haskell.org/package/qrcode-core-0.8.0 (alexkazik)
05:06:58 * hackage qrcode-juicypixels 0.8.0 - Converts a qrcode-core image to JuicyPixels  http://hackage.haskell.org/package/qrcode-juicypixels-0.8.0 (alexkazik)
05:11:47 <dmwit> royal_screwup21: Do you get why there are log n levels of the skip list?
05:12:52 <royal_screwup21> dmwit: yeah... so the bottomost has n nodes, the one above would have n/2 (because unbiased coin flips) and so on...
05:13:03 <dmwit> Right.
05:13:11 <dmwit> So now, how many nodes do you need to look at at each layer?
05:13:27 <dmwit> Certainly at the top layer it's just one, since there's only one node to look at, right?
05:13:31 <royal_screwup21> yup
05:13:52 <dmwit> At the second layer, you can use the information you got from looking at that one node to discard half of the second-layer nodes.
05:14:02 <dmwit> Since there's on average two nodes, there's still only one to look at.
05:14:25 <dmwit> That information lets you discard half of the remaining third-layer nodes, leaving just one to look at...
05:16:08 <dmwit> (et cetera)
05:16:09 <royal_screwup21> The top layer has 1 node. The layer below it  has 2 nodes. When you're at the top, you only have one pointer to the node below.  Thus, you'd have to visit both nodes, right?
05:16:21 <royal_screwup21> both nodes on the second layer*
05:17:25 <royal_screwup21> if the node at the top layer had pointers to both nodes on the layer below, then it would be easy to discard some nodes...but you only have one pointer to the node below, if I understand correctly
05:18:03 <dmwit> You have only the pointer to the node below. But you know whether to go "forward" or "backward" from it.
05:18:19 <royal_screwup21> ah yeah I see
05:24:29 <nyc> I'd be more interested in B or B+ trees than skip lists.
05:25:22 <royal_screwup21> hmm suppose the random number generator was broken so that instead of produce H or T with 50% probability, it produced an alternating sequence of one's and zeros (HTHT...) I'm curious what the structure of the skip list would look like
05:56:41 <RyanGlScott> Unusual question: is there any way to implement the `foo` function without using `coerce`? https://gitlab.haskell.org/snippets/2
05:57:59 <Solonarv> RyanGlScott: that's a 404 for me
05:58:08 <merijn> RyanGlScott: I don't suppose "Yes, unsafeCoerce" is the right answer? ;)
05:58:11 <RyanGlScott> Oh dear, I didn't realize you had to log in to see it. One second.
05:58:19 <merijn> Also that dumps me to a login screen, yes :p
05:58:27 <Solonarv> I did log in (via github), actually. Still a 404.
05:58:49 <Solonarv> (I should note that I'd never logged into gitlab.haskell.org before)
05:59:03 <RyanGlScott> Take two: https://gist.github.com/RyanGlScott/e03734d6388bb6ffe3f29ca61ca39e1b
05:59:03 <berndl> Say you have a newtype Foo. What should I call the destructor: unFoo, runFoo or getFoo?
05:59:23 <merijn> berndl: "Yes"
05:59:53 <RyanGlScott> merijn: Yes, `unsafeCoerce` is cheating ;)
06:00:08 <merijn> RyanGlScott: Simply pattern matching doesn't work?
06:00:08 <berndl> I guess there is no harm in having all three...
06:00:19 <Solonarv> RyanGlScott: does 'foo (MkT1 fa) = MkT2 fa' work?
06:00:25 <merijn> berndl: It depends a lot on what Foo is, conceptually
06:00:31 <RyanGlScott> Solonarv: try it
06:01:01 <RyanGlScott> Alternatively, I'll update the gist with the error message that you get
06:01:09 <berndl> merijn: I haven't noticed any pattern though.
06:01:46 <merijn> berndl: runFoo tends to be transformer stacks
06:01:57 <RyanGlScott> merijn Solonarv: Updated https://gist.github.com/RyanGlScott/e03734d6388bb6ffe3f29ca61ca39e1b
06:02:07 <RyanGlScott> Couldn't match expected type ‘F a’ with actual type ‘F a0’
06:02:12 <RyanGlScott> Is usually what stops me.
06:02:21 <merijn> Oh!
06:02:29 <Solonarv> ah yes, I got the same error
06:02:43 <merijn> oh, no, I though I had an epiphany but didn't
06:04:12 <Solonarv> Hmm.
06:06:50 <Solonarv> okay, I got nothing.
06:07:35 <RyanGlScott> This is really annoying since GHC clearly knows *some* way to make this work under the hood, but I can't seem to recreate (using plain old functions)
06:10:16 <Solonarv> Hm. Can you write foo' :: (forall a1. F a1) -> (forall a2. F a2) ?
06:12:32 <Solonarv> wait, that isn't the same thing.
06:12:47 <RyanGlScott> I can write `foo'' :: forall a2. (forall a1. F a1) -> F a2`, at the very least.
06:14:51 <Solonarv> Hmm, but that isn't the same thing as the foo in your gist.
06:15:10 <RyanGlScott> Sure. I only say that in case you had some crazy way of turning foo' into foo :)
06:15:36 <Solonarv> No, I just got confused by Haskell's use of 'forall' for existentials.
06:16:14 <RyanGlScott> Which existentials are you referring to?
06:16:38 <Solonarv> newtype T1 = MkT1 (forall a. F a), in this case
06:16:54 <RyanGlScott> Perhaps that's contributing to your confusion, then: there are no existentials in MkT1
06:17:12 <RyanGlScott> Otherwise, T1 couldn't be a newtype
06:17:20 <Solonarv> Bah. I'm clearly not awake enough for this!
06:17:39 <RyanGlScott> But I think your original claim had some truth to it
06:17:56 <RyanGlScott> `T1 -> T2` is inter-Coercible with `(forall a1. F a1) -> (forall a2. F a2)`
06:18:49 <berndl> RyanGlScott: That coerce is dangerous.
06:18:51 <Solonarv> oh of course, I see now - an existential would have the 'forall' outside the constructor.
06:18:52 <RyanGlScott> My original plan was to change the definitions of T1/T2 to some inter-Coercible thing that made `a` unambiguous
06:19:17 <RyanGlScott> I was somewhat hoping that `Proxy# a -> F a` and `F a` were inter-Coercible, since Proxy# is zero-width
06:19:32 <RyanGlScott> Sadly, that's not the case (at least, unsafeCoerce-ing between them doesn't work)
06:20:02 <Solonarv> if unsafeCoerce doesn't work, coerce shouldn't either (if it does, that seems like a bug to me!)
06:20:22 <RyanGlScott> To be clear, I'm talking about unsafeCoerce-ing on something entirely different from my gist.
06:20:48 <Solonarv> yes, I'm aware of that
06:21:14 <RyanGlScott> And I only resorted to unsafeCoerce because I (mistakenly) thought they had the same memory representation (they don't)
06:21:21 <RyanGlScott> So feel free to ignore what I just said there
06:21:28 * hackage hexpat-lens 0.1.8 - Lenses for Hexpat.  http://hackage.haskell.org/package/hexpat-lens-0.1.8 (OliverCharles)
06:21:49 <Solonarv> Hm. Define T1 and T2 in terms of a 'newtype Ft a = Ft (F a)'? That should work, I think.
06:24:07 <RyanGlScott> Solonarv: How do you fit Ft inside of `foo`? That's the part that I can't figure out.
06:26:59 <Solonarv> RyanGlScott: foo (MkT1' fta) = MkT2' fta -- works
06:27:30 <Solonarv> using: newtype T1' = MkT1' (forall a. Ft a), and the same for T2'
06:29:27 * hackage c-mosquitto 0.1.6.0 - Simpe mosquito MQTT binding able to work with the Amazons IoT  http://hackage.haskell.org/package/c-mosquitto-0.1.6.0 (tolysz)
06:31:28 * hackage notmuch 0.1.0.1 - Haskell binding to Notmuch, the mail indexer  http://hackage.haskell.org/package/notmuch-0.1.0.1 (frasertweedale)
06:37:39 <jang> hey there. I've a question about approaches one might use for a particular problem.
06:38:09 <jang> (this came from discussing taskell yesterday evening with its author)
06:39:10 <hyperisco> task hell
06:40:08 <jang> the question is: the software has a "model" - a nested datastructure that's navigated and edited using lenses - and regularly writes out a "view" (it renders the model into markdown, I think). For large models, that rendering step is expensive. I was wondering what people might suggest as approaches for managing updates to the view, in reaction to updates to the model, whilst doing as much structure-sharing as possible with the revious 
06:40:08 <jang> version of the rendered view (if you see what I mean)
06:40:57 <jang> it'd obviously be possible to use a data structure that merges both model and view and effectively update both bits at once, but this feels like it's conflating ideas. Was wondering if there are any common patterns or approaches to this.
06:43:53 <opqdonut> what React etc. do is have a structural view, and use sharing & purity to minimize updates
06:44:23 <opqdonut> so we know something like: this subtree of the view was computed from this part of the model, and that part of the model hasn't changed, so we don't need to rerender this subtree
06:46:26 <RyanGlScott> Solonarv: Indeed, that's pretty much the only thing I can think of at the moment.
06:47:03 <RyanGlScott> It's a shame that we have to change the definitions of T1/T2 to accomplish this feat, but I don't really see an alternative.
06:50:17 <jang> opqdonut: yeah. It seems a pity to have to do a large structural diff when we can effectively derive from the lens use which pieces have changed
06:51:15 <jang> but the question is whether there's a way to "translate" a lens on one data structure (the model) into an equivalent lens on the other (the rendered view) - that is, to derive a secondary lens from the primary.
06:51:23 <jang> at least, that's one question taht springs to mind.
06:53:17 <jang> (an issue here is that `x == x` will typically dive into the structure as opposed to short-circuiting via comparison of identity, so the re-rendering cost instead becomes a structure-comparison cost. maybe that's better; but since it'd still involve a bucket of textual comparisons, I'm not completely convinced)
06:54:36 <opqdonut> I guess the edit lenses could update explicit version numbers?
06:54:40 <Zemyla> I think I've found a way to zip two arbitrary Traversables together, though it really only works well with ones that are listlike.
06:55:59 <Zemyla> > zipTrav (,) [1, 2, 3, 4, 5] [6, 7, 8]
06:56:01 <Solonarv> jang: you can fix the "x == x is slow" issue by using ptrEq as a short-cirtuit
06:56:01 <hyperisco> jang, incremental computation, from my perspective, is tricky, so good luck
06:56:02 <lambdabot>  [(1,6),(2,7),(3,8)]
06:56:20 <Zemyla> > zipTrav (,) (Seq.fromList [1, 2, 3, 4, 5]) (Seq.fromList [6, 7, 8])
06:56:22 <lambdabot>  fromList [(1,6),(2,7),(3,8)]
06:56:57 * hackage notmuch 0.2.0.0 - Haskell binding to Notmuch, the mail indexer  http://hackage.haskell.org/package/notmuch-0.2.0.0 (frasertweedale)
07:00:30 <jang> okay, thanks for the suggestions. From a bit of a nose around it seems like there's potentially not a huge amount of stuff to lean on in this area. I'll think on't.
07:02:03 <jang> (one notion I had was reifying the navigation that constructs lenses into a set of navigation events; these could then be compressed (that is, attempting to remove redundant navigation) and used, zipper-like, to construct the relevant edit path in the rendered structure.)
07:02:30 <jang> … but that also feels like it's kind of an equivalent to the "tie these two data structures together completely" 
07:03:27 <hyperisco> I wouldn't focus so much on lenses
07:03:47 <Solonarv> using an explicit "path" seems like a decent approach, tbh
07:04:00 <hyperisco> you're right that you need to consider diffs, but lenses are just one manifestation of that
07:06:06 <jang> yup, agreed. the reason I've mentioned lenses half-a-dozen times is that that's what the code currently does for the structural editor, which seemed a natural fit, looking at the code. 
07:14:27 * hackage fast-downward 0.1.1.0 - Solve classical planning problems (STRIPS/SAS+) using Haskell & Fast Downward.  http://hackage.haskell.org/package/fast-downward-0.1.1.0 (OliverCharles)
07:16:18 <Synthetica> Is there a highlighting lib with support for Nix? Kate and Skylighting both don't seem to support it
07:24:28 * hackage tidal 1.0.6 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-1.0.6 (AlexMcLean)
07:47:49 <dminuoso> Is there some common way to rename `pure` for a monomorphized `a -> [a]`? `single` perhaps?
07:48:19 <dminuoso> Mmm, ghc calls it `singleton`
07:49:29 <Taneb> pure@[] :P
07:49:48 <mnoonan> dminuoso: `one`, sometimes
07:49:49 <dminuoso> Heh. 
07:49:51 <geekosaur> singleton seems the usual name
07:49:59 <Taneb> *pure @[] (I didn't realise a space was necessary)
07:50:02 <geekosaur> at least, containers likes it
07:51:21 <mnoonan> as in here: https://hackage.haskell.org/package/semiring-simple-1.0.0.1/docs/Data-Semiring.html#v:one
07:51:32 <mnoonan> whoops, no, sorry
07:51:42 <mnoonan> wrong "one" :)
07:52:33 <dminuoso> geekosaur: Alright, I guess singleton it is. :)
07:52:55 <Boomerang> :t (:[]) -- self descriptive bunch of symbols :D
07:52:57 <lambdabot> a -> [a]
07:53:03 <dminuoso> Thanks to all.
07:53:11 <geekosaur> @quote monkey
07:53:12 <lambdabot> shapr says: Always mount a scratch monkey
07:53:15 <geekosaur> bah
07:54:28 <geekosaur> @quote robot.monkey
07:54:28 <lambdabot> byorgey says: now we have the pig operator <^(++)^> as well as the robot monkey operator (:[])
07:54:43 <dminuoso> Boomerang: Oh heh. Curious how I did not think of that.
07:54:56 <dminuoso> Though singleton is still better I think, Im trying to reduce the amount of operators.
08:40:24 <g-erson> main = putStr $ cycle "e"
08:40:57 <seanparsons> Is there a halfway not-awful way of incorporating the assets for ekg into an application?
09:02:56 <DigitalKiwi> i saw an example that used nix somewhere
09:04:55 <DigitalKiwi> https://github.com/cmk/example-nix
09:05:40 <DigitalKiwi> no idea if it is halfway not-aweful or not but eh might be fine?
09:07:56 <DigitalKiwi> (the pkgs-make thing seems nice i just don't know if the ekg this is)
09:13:58 * hackage reactive-banana 1.2.1.0 - Library for functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-1.2.1.0 (OliverCharles)
09:19:25 <mreh> When I re-export a module it doesn't seem to export the associated types.  
09:21:56 <mreh> Or are they like instances in general, and you just get them for free when you import the module that export sthem?
09:22:45 <Solonarv> associated types are scoped the same way as a top-level open type family
09:22:58 <Solonarv> (declared in the module that declares the typeclass)
09:24:19 <fhdhsni> How do you write zip with list comprehension?
09:24:44 <mreh> Solonarv: this includes an associated type isntance?
09:25:14 <Taneb> fhdhsni: you need to use the extension ParallelListComprehensions
09:25:27 <Solonarv> mreh: I'm not actually sure what you're asking, could you perhaps post a gist?
09:25:29 <mreh> > [(x,y) | x <- [1,2,3], y <- ['a','b','c']]
09:25:32 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
09:25:32 <Taneb> fhdhsni: but with that you can just do [ (x, y) | x <- xs | y <- ys ]
09:25:36 <Solonarv> (gist.github.com allows multiple files)
09:25:38 <mreh> not that like that
09:25:39 <Taneb> mreh: right type, wrong implementation
09:27:51 <mreh> Solonarv: here's an example, which I'm trying to replicate, it's a migration in a database managed with beam.
09:27:56 <mreh> https://github.com/Znack/beam-demoblog/blob/6a477b4ddc8103ebfbc387865489bbc7f0bd4fc1/src/Schema/Migrations/V0005Post.hs
09:28:28 <mreh> I'm trying to import that constructor from line 45
09:29:12 <mreh> or something similar, and then re-export it from a super-module.
09:29:37 <Solonarv> mreh: ah! I would expect that constructor to be exported from the module you linked
09:30:18 <mreh> Yeah, it seems to be working. But when I have `module Schema (Schema.Migrations.V0005Post)` for example.
09:30:34 <mreh> I can't access that same constructor wherever I import `Schema`.
09:31:28 <Solonarv> uhh... aren't you missing a 'module' keyword there?
09:31:39 <mreh> Solonarv: ah, yes I am
09:32:29 <mreh> It works if I import the constructor directly from the original module, but not via another as a re-export.
09:33:17 <mreh> GHC says the import is redundant and it can't find the contstructor
09:33:42 <mreh> it's a little odd
09:36:50 <__monty__> Didn't even know it was possible to declare a data type in an instance declaration.
09:37:40 <mreh> __monty__: it's an extension called Type Families
09:39:23 <Solonarv> __monty__: associated data types are basically syntax sugar for top-level data families
09:39:38 <wroathe> Refactoring in Haskell is such a joy compared to other languages
09:43:16 <__monty__> Oh, ok, TIL.
09:46:18 <phadej> Solonarv: top-level (non-closed) type families are often a code smell
09:46:34 <phadej> type family ought to be closed, or constrained
09:47:24 <mreh> what's the difference between open and closed?
09:47:51 <phadej> open can be extended later (by anyone)
09:48:40 <Solonarv> closed: type family Blah where {- equations -}
09:49:16 <Solonarv> open: type family Blah a; type instance Blah Foo = Bar; -- multiple instances allowed, and they can be anywhere
09:49:37 <magicman> @hoogle (a -> Either b c) -> [a] -> ([b],[c])
09:49:38 <lambdabot> Agda.Utils.List mapEither :: (a -> Either b c) -> [a] -> ([b], [c])
09:49:38 <lambdabot> Util partitionWith :: (a -> Either b c) -> [a] -> ([b], [c])
09:49:38 <lambdabot> Agda.Utils.List deal :: (a -> Either b c) -> a -> ([b], [c]) -> ([b], [c])
09:50:12 <Solonarv> magicman: there's also partitionEithers :: [Either a b] -> ([a], [b])
09:50:12 <phadej> magicman: partitionEithera
09:50:22 <Solonarv> which you can combine with 'map'
09:50:23 <phadej> Eithers
09:50:54 <magicman> I'm aware of partitionsEither, but 90% of the usage of that function in my codebase is on a result from `map`.
09:52:12 <magicman> So I was wondering if there was a standard function that was just that composition somewhere. Similar to how we have mapMaybes and catMaybes.
09:52:37 <magicman> *mapMaybe
09:52:38 <geekosaur> not as such. but note that both of those are built from list comprehensions
09:52:53 <geekosaur> (well, catMaybes is, I think the other as well)
09:54:14 <phadej> partitionEithers is not list comprehension
09:54:14 <mreh> what does [(x,y) | x <- [1..] | y <- ['a'..]] desugar to?
09:54:16 <magicman> mapMaybe is defined through direct recursion with a rewrite rule to some list builder verion.
09:54:21 <Solonarv> are you talking about partitionEithers? I don't think that can be defined in terms of list comprehensions without traversing the input twice
09:54:28 <phadej> if you wanr to traverse the list only once
09:54:36 <Solonarv> mreh: it uses zip under the hood, IIRC
09:54:47 <mreh> Solonarv: makes sense
09:55:02 <Solonarv> mreh: there's documentation about the various list-comprehension extensions
09:55:12 <Solonarv> should be in the GHC user's guide
09:56:53 <dmwit> mreh: If you return These a b instead of Either a b, then foldMap is what you want.
09:57:35 <magicman> Hrm. And just not use the These constructor, only This and That.
09:58:12 <magicman> Or. Wait. No.
09:58:47 <magicman> This a <> That b = These a b.
09:59:05 <dmwit> Oops, not foldMap. The Semigroup version of foldMap. =)
09:59:15 <mreh> can I see what symbols are exported from a module?
09:59:41 <wroathe> mreh: :browse My.Module
10:00:00 <mreh> wroathe: I thought GHCi would come to the rescue
10:02:05 <magicman> Hrm, no, using These would be more verbose than just sticking with partitionsEither . map f.
10:02:39 <mreh> Okay the instance I'm after is exported: `data instance PrimaryKey UserT f = UserId (Columnar f ID)`
10:02:56 <magicman> May just define that function in some top-level Import module >_>
10:03:18 <Solonarv> that's probably a good iea
10:03:19 <mreh> how do I explicity import that UserId?
10:04:13 <Solonarv> mreh: import WhateverTheModuleIs (pattern UserId) should work
10:04:39 <mreh> Solonarv 'pattern' is a keyword here?
10:04:54 <Solonarv> yes
10:05:28 <Solonarv> same as 'type' or 'module'
10:05:42 <mreh> hmm, I get a parse error
10:06:06 <mreh> I explicity import everything because I'm particular :)
10:06:09 <geekosaur> need an extension
10:06:22 <Solonarv> ExplicitNamespaces is the one, I think
10:06:32 <mreh> aha, thank you chaps
10:07:04 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#explicit-namespaces-in-import-export
10:07:05 <geekosaur> yeh
10:07:27 <mreh> I have so many extensions enabled already.
10:07:34 <geekosaur> welcome to ghc :p
10:07:38 <Solonarv> yeah, that'll happen :>
10:07:47 <geekosaur> maybe someday the standard will be extended
10:07:53 <mreh> if you want nice ORM, it's either template Haskell or a million extensions
10:08:11 * geekosaur wonders if anyone has considered forking it, or at least defining multiple compliance levels
10:09:23 <Solonarv> technically every "code style guideline" that mentions a set of default/allowed/forbidden extensions is a fork, and so are alternative compilers
10:09:28 <mreh> sure that's the right extension?
10:09:43 <Solonarv> it could also be PatternSynonyms, I suppose
10:09:50 <Solonarv> I can't look at the docs right now
10:10:24 <WilliamHamilton[> hi, sometimes when I have to debug why a project doesn't compile with cabal new-build, I examine the cabal log: but since the execution is interleaved (e.g. I'm building packages a and b while building c's test suite) I find difficult to locate the dependency that failed. How can I resolve this problem? Maybe setting cabal to 1 core, in order to see the steps chronologically as they happen?
10:11:24 <mreh> WilliamHamilton[ I *think* there is a way
10:12:02 <mreh> is it the -j flag?
10:12:16 <mreh> PatternSynonyms did the trick
10:12:38 <Solonarv> WilliamHamilton[: pass -j1 to cabal to make it do one thing at a time, no parallelization
10:12:55 <Solonarv> (-j alone is equivalent to -j<number of CPU cores>, IIRC)
10:12:58 <WilliamHamilton[> mreh: Solonarv thanks!
10:13:52 <WilliamHamilton[> but where should I pass it? Can I put it in the cabal file? I ask because I'm actually dealing with a fairly complex situation in nix, and I'm not simply calling `cabal new-build`
10:14:43 <mreh> you could put it as a GHC flag in the cabal file maybe
10:14:50 <mreh> just for debugging
10:18:11 <WilliamHamilton[> mreh: Solonarv and will this work transitively? i.e. if I put the option in a package, will it work for the transitive dependencies?
10:18:38 <Solonarv> I think so?
10:25:27 <wroathe> Is there a way to pre-emptively check if a function doesn't have sufficient patterns to match an argument at runtime? Or do I just need to catch the exception?
10:25:58 <lyxia> how is that different from -Wincomplete-patterns
10:26:39 <wroathe> I'm playing around with Warp a bit and trying to write a dumb router
10:27:10 <wroathe> so something like (\["foo", "bar", pathvar] -> "Hello " ++ pathvar) pathSegments
10:27:37 <wroathe> pathSegments could be any [String], and so that will fail, and I understand I can catch that as an exception
10:27:58 <geekosaur> maybe they just want _
10:28:14 <geekosaur> you cn't do this with lambdaas, though
10:28:32 <geekosaur> well, you can, but not in the parameter; you need to write the case expression yourself
10:28:39 <geekosaur> \x -> case x of ...
10:29:30 <wroathe> geekosaur: You say that... https://gist.github.com/JustinChristensen/7efd21f5e09d1eded50c58f31f6724c1
10:30:08 <geekosaur> as I said, for lambdas you need to use case
10:30:42 <merijn> No, there's a warning that warns for potential incomplete lambda's too
10:30:42 <geekosaur> \ only allows one "shot" at the parameters, so you would need to capture the list and discriminate with case
10:30:55 <merijn> I just think it's not in -Wall
10:30:57 <geekosaur> there is, but no way to write the lambda with those cases
10:31:04 <merijn> Sure
10:31:18 <geekosaur> and it's not clear if they meant the warning, or were asking how to write the lambda with adefault case
10:31:47 <wroathe> geekosaur: Yeah, I'm aware of the case approach. This is just an experiment that I would never actually do in real code
10:32:10 <wroathe> The idea is to write a route function where you don't need to explicitly provide all of the patterns
10:32:43 <geekosaur> that should work like anything else, provide a default that captures any parameter
10:32:51 <c_wraith> if you want to be *really* evil, you catch the pattern match failure exception.
10:33:00 <c_wraith> I think spoon does that
10:33:07 <geekosaur> foo ["a", "b"] = ...; foo ["c"] = ...; foo xs = whateverDefault
10:33:12 <wroathe> so, route (\["greet", str] -> "Hello, " ++ str) paths
10:33:22 <wroathe> And yeah, c_wraith, I know this is evil :P I'm just playing around
10:33:34 <c_wraith> @hackage spoon
10:33:35 <lambdabot> http://hackage.haskell.org/package/spoon
10:34:29 <wroathe> Anyway, case it is
10:34:30 <wroathe> Thanks
10:37:48 <geekosaur> someday someone should try to figure out if there is an unambiguous way to add multiplee patterns to lambdas. sadly, I suspect there isn't
10:38:00 <geekosaur> or there is but it requires unbounded lookahead or etc.
10:38:22 <geekosaur> which is probably the real problem; the let / top level ones can be treated as distinct
10:38:58 <geekosaur> but lambda would be in the middle of an expression
10:41:00 <lyxia> Doesn't lambdacase solve this
10:41:29 <wroathe> lyxia: Makes it cleaner, at the least
10:48:10 <geekosaur> hm. yes, it probably does.
11:11:58 * hackage fused-effects-lens 0.1.0.0 - Monadic lens combinators for fused-effects.  http://hackage.haskell.org/package/fused-effects-lens-0.1.0.0 (patrick_thomson)
11:16:51 <exarkun1> How do you import from modules in a test suite?
11:16:55 <exarkun1> when using stack
11:19:00 <cocreature> exarkun1: add the library to the build-depends section of your test suite, add the modules you want to import to exposed-modules and import them
11:21:18 <exarkun1> sorry, I see that I worded my question poorly
11:21:37 <exarkun1> maybe this is better - How do you import from test modules in a test suite?
11:21:58 <exarkun1> Or even better yet, how do I add a new spec module to the servant-py test suite that imports from the existing Servant.PY.InternalSpec module?
11:22:31 <exarkun1> https://github.com/erewok/servant-py/blob/master/servant-py.cabal#L75
11:23:16 <lyxia> does this line not work?
11:23:38 <cocreature> add the module, put it in other-modules and things should work
11:23:55 <lyxia> I still don't understand the problem
11:26:17 <nshepperd> hm, lambdacase almost works as a multiple-pattern lambda, except not with multiple arguments
11:26:40 <exarkun1> Uh I'm not sure I understand either.  I think maybe this is just intero being broken.  Intero complains the module can't be found.  `stack build` doesn't.
11:26:52 <cocreature> restart intero
11:26:56 <nshepperd> with multiple arguments I tend to end up writing \x y -> case (x,y) of { patterns... }
11:27:07 <nshepperd> basically uncurrying it
11:27:28 * hackage yesod-auth-oauth2 0.6.1.0 - OAuth 2.0 authentication plugins  http://hackage.haskell.org/package/yesod-auth-oauth2-0.6.1.0 (PatrickBrisbin)
11:27:41 <exarkun1> cocreature: yea I did that a couple times already :)  thus convincing myself the error was legit.
11:28:53 <cocreature> exarkun1: then you might have activated the wrong components or something like that. if you can "stack test" can build your test suite something is wrong with your intero setup
11:29:33 <exarkun1> so it would seem
11:45:14 <rain1> idea for fixing cabal hell package installations are just edge nodes in a graph of package state hilbert space endofuctors
12:06:35 <pgiarrusso> rain1: nobody used Hilbert spaces for this, so at least it’s novel, is it also good? :-)
12:06:44 <rain1> :)
12:07:00 <pgiarrusso> (well *I think* nobody)
12:34:58 * hackage mercury-api 0.1.0.2 - Haskell binding to Mercury API for ThingMagic RFID readers  http://hackage.haskell.org/package/mercury-api-0.1.0.2 (ppelleti)
12:40:28 * hackage intero 0.1.38 - Complete interactive development program for Haskell  http://hackage.haskell.org/package/intero-0.1.38 (ChrisDone)
12:43:47 <Tuplanolla> That sounds dubious, rain1. Can you elaborate?
12:55:12 <merijn> Tuplanolla: Pretty sure that was a joke...
12:55:37 <Tuplanolla> You never know with this place, merijn.
13:03:00 <codedmart> Anyone with an idea of where I can look. I have a function that uses `readProcessWithExitCode`. If I run the function from ghci it works fine. But when ran from within my program (a web server) it stalls. No errors or anything.
13:06:47 <merijn> codedmart: I think the readProcess functions hang when not using the threaded runtime
13:07:31 <merijn> codedmart: See the docs for readProcess: "Users of this function should compile with -threaded if they want other Haskell threads to keep running while waiting on the result of readProcess."
13:08:26 <codedmart> merijn: I have `-threaded -rtsopts -with-rtsopts=-N`
13:08:34 <merijn> hmmm
13:09:57 <lyxia> what if you try with fewer capabilities, and then without threaded
13:10:47 <codedmart> lyxia: What do you mean fewer capabilities?
13:10:52 <lyxia> cores
13:11:05 <codedmart> Oh
13:13:18 <pavonia> codedmart: Make sure to read both stdin and stderr handles from the process regularily. I had a problem where one of these filled up the buffer after a while which made the process stall
13:13:37 <pavonia> Err, *stdout and stderr
13:14:23 <codedmart> pavonia: What do you mean read both? I have `(eCde, stdOut, stdErr) <- readProcessWithExitCode cmd' (opts <> [fp]) ""`
13:15:09 <pavonia> You have to actually read from the handles to make sure there isn't some output that just fills up the internal buffers
13:15:31 <merijn> pavonia: readProcess doesn't return handles
13:15:54 <pavonia> Oh, never mind then
13:20:38 <dmwit> what if [x..] was syntax sugar for \y -> [x..y]
13:20:59 <hyperisco> then what would you do for [x..]
13:21:22 <dmwit> what if x..y was fine without the square brackets
13:21:42 <hyperisco> that's already possible
13:21:47 <dmwit> hyperisco: x... ;-)
13:22:02 <hyperisco> > let (..) = enumFromTo in 1 .. 10
13:22:04 <lambdabot>  <hint>:1:6: error: parse error on input ‘..’
13:22:08 <hyperisco> or not
13:22:19 <hyperisco> right guess it makes sense that is reserved syntax
13:22:52 <dmwit> Like, I don't have to write `f [x] = ...` just because `x` is a list. Why should I have to write `[3..4]`.
13:23:23 <pavonia> x is not a list
13:23:24 <hyperisco> that is only a part of what you can do
13:23:38 <hyperisco> > [3,4..10]
13:23:40 <lambdabot>  [3,4,5,6,7,8,9,10]
13:24:12 <hyperisco> not a compelling example
13:24:36 <dmwit> pavonia: That is exactly my point.
13:24:57 <dmwit> pavonia: In *some* languages if x is a list, and you want to write a function that operates on it, you must surround it in square brackets.
13:25:38 <dmwit> That's just a design mistake.
13:25:48 <hyperisco> you could make .. an operator and remove the related sugar, but then you lose the other capabilities
13:25:53 <dmwit> Why aren't the square brackets that are required around .. a similar design mistake?
13:26:13 <hyperisco> I thought I was giving points to that already =\
13:26:33 <dmwit> hyperisco: Yeah. If we admit that enumFromThenTo is useful, then that's a compelling argument.
13:26:56 <dmwit> I'm not super sure I believe enumFromThenTo is useful yet. But I buy the rest of the argument. I haven't thought enough to decide what I think of eFTT
13:27:03 <hyperisco> what about enumFrom?
13:27:08 <dmwit> ... will do for that
13:27:13 <hyperisco> no it doesn't
13:27:28 <dmwit> Oh?
13:27:47 <hyperisco> if it is an operator then it is binary, and enumFrom is not
13:27:53 * dmwit looks at (-)
13:28:17 <pavonia> dmwit: Do you consider [1,2,3] instead of just 1,2,3 a design mistake too?
13:28:33 <dmwit> pavonia: No, because both [1,2,3] and (1,2,3) are possible.
13:28:38 <dmwit> (And mean different things.)
13:29:12 <hyperisco> so your ... is both binary and unary
13:29:19 <dmwit> No. ... is unary, .. is binary
13:29:21 <hyperisco> so not just a regular operator
13:29:38 <hyperisco> so you want a regular operator plus a special unary operator
13:29:50 <hyperisco> I'm not sure how this is getting better than what we already have
13:30:50 <dmwit> 30% less typing ;-)
13:31:09 <hyperisco> oh come now
13:31:14 <dmwit> Yes, that is joke.
13:31:39 <dmwit> I am objecting to using sigils to indicate type information, mostly.
13:32:49 <hyperisco> lol well that's completely unavoidable
13:33:04 <hyperisco> all terms have types, this is Haskell
13:33:22 <dmwit> Most terms do not have sigils, though.
13:33:37 <hyperisco> I don't get the distinction
13:33:53 <hyperisco> it is like complaining Just is information that the type is Maybe
13:34:05 <hyperisco> well, yeah, that's by design
13:34:10 <dmwit> Imagine if every Bool variable had to have a name starting with 🅱️
13:35:15 <hyperisco> I think you're getting too caught up over the reuse of [ and ] in the type name of lists
13:35:38 <hyperisco> how about we make the term brackets « and » just so they're different
13:35:57 * shapr circumflexes
13:36:06 * shapr lifts heavy lambdas
13:36:07 <hyperisco> or we can get rid of the [a] thing and just say List a
13:36:27 <shapr> You know what I want? MORE EXAMPLES!
13:38:34 <dmwit> If you made the term brackets << and >> then I would *definitely* want to know what you were thinking. At least if they're [ and ] I know you just didn't think about it super hard. But if it's << and >> you had to go out of your way to include a new syntactic form, so you must really think it's important.
13:39:32 <dmwit> s/form/token/
13:39:38 <pavonia> shapr: Examples for what?
13:40:42 <shapr> pavonia: most popular downloads on hackage
13:40:58 <shapr> but usually whatever package I'm just starting to use :-)
13:41:12 <__monty__> dmwit: The brackets are sugar for list construction. .. is part of that same sugar. What do we gain by not having them?
13:41:22 <shapr> I'd love to have equivalent parsers in both attoparsec and the very latest megaparsec version
13:42:36 <hyperisco> doesn't have to be a new token per se, can just equivocate [ and <<
13:42:44 <dmwit> [] isn't sugar for anything. There's no other term in the language you can substitute for that.
13:43:42 <__monty__> dmwit: True but I'm talking about non-empty brackets.
13:44:12 <dmwit> I don't know what to make of "[x..y] and [x,y] are part of the same sugar". I don't admit that it's true, and don't see why it would matter even if it were true.
13:45:22 <__monty__> They're both list construction sugar. Not sure why you'd deny that fact. Comprehensions are part of that same sugar too.
13:45:34 <__monty__> And it matters because of the Law of Demeter.
13:45:51 <hyperisco> it is standard maths notation to use an ellipse to indicate repetition, and that is what is being emulated with ..
13:45:55 <__monty__> If you have a convention for list construction you better have a damn good reason to deviate from it.
13:46:28 <dmwit> Should we also rename them [take], [drop], [splitAt], [!!] for Law of Demeter reasons?
13:46:42 <__monty__> Calling enumFromThen doesn't need the brackets, but it has good reason, function application takes precedence over list construction sugar.
13:46:48 <dmwit> Never mind, splitAt and !! don't construct lists. But take and drop do.
13:46:48 <hyperisco> that doesn't make any sense to me dmwit
13:47:12 <__monty__> dmwit: Clearly not because [take] would be a singleton containing `take` if you follow LoD.
13:47:14 <dmwit> We also have ++ which doesn't require brackets.
13:47:24 <hyperisco> do you accept that [1,2,3,4,5,6,7,8,9,10] is reasonable notation to construct a list?
13:47:37 <dmwit> __monty__: And I'm saying [0..2] should be [[0,1,2]] by LoD.
13:47:38 <Welkin> Data.List.Split.splitOn does
13:47:42 <Welkin> :t Data.List.Split.splitOn
13:47:43 <lambdabot> Eq a => [a] -> [a] -> [[a]]
13:47:53 <__monty__> dmwit: Again, ++ is an operator, which is more fundamental than list sugar.
13:48:06 <dmwit> I'm claiming that .. should be an operator, too.
13:48:08 <Welkin> (++) is just a function
13:48:11 <Welkin> a normal function
13:48:28 <cemerick> after refactoring some functions to be monadic, their performance has dropped by ~4x, and profile results point to a huge amount of allocation where source monads are fmapped and default values are `return`ed, etc. Is this to be expected?
13:48:47 <Welkin> cemerick: adding more indirection in your program, yes
13:48:52 <merijn> cemerick: Yes, no, maybe?
13:49:10 <hyperisco> cemerick, try using the SPECIALIZE pragma to emit versions for the specific Monad instances you are using
13:49:20 <dmwit> (Do you really think, given the evidence you have about me, that I do not know that (++) is a function...?)
13:49:43 <__monty__> dmwit: But that already exists, `enumFromTo`.
13:49:47 <Welkin> of course dmwit 
13:50:06 <Welkin> but operator is often assumed by people in other languages to be something special/built-in
13:50:08 <cemerick> merijn: /me throws pointy things at the compiler
13:50:11 <Welkin> the message wasn't meant for you
13:50:13 <__monty__> I'm pretty sure everyone still following the conversation knows operators in haskell are just functions.
13:50:14 <cemerick> hyperisco: thanks, will take a look
13:50:24 <dmwit> __monty__: So what?
13:50:32 <hyperisco> dmwit, I am just failing to understand the aesthetic judgement you're making
13:50:33 <merijn> I have a more interesting question than bikeshedding syntax that's not gonna change: I have K values between M and N that I would like to (cheaply) map to indices 0 through K-1, anyone got any suggestions?
13:50:44 <hyperisco> dmwit, I have no idea how you get from [1..10] to [take]
13:51:02 <Welkin> .. is enumFromTo
13:51:12 <hyperisco> .. is many things
13:51:27 <Welkin> > [1`enumFromTo`10]
13:51:30 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10]]
13:51:31 <nisstyre> .. could be an operator but you would lose the ability to do [1,1.5..10]
13:51:34 <Welkin> > 1`enumFromTo`10
13:51:36 <Welkin> ah
13:51:37 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
13:51:39 <Welkin> there is the difference
13:51:45 <Welkin> > [1..10]
13:51:48 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
13:51:51 <Welkin> [..] it is then
13:52:05 <nisstyre> unless it takes a different type as parameters
13:52:06 <dmwit> hyperisco: My understanding of __monty__'s claim was: since [] is used in many syntax forms for constructing lists, it should be used in x..y because LoD says it is less surprising for things that construct lists to uniformly use [].
13:52:18 <__monty__> dmwit: So what? So we would have to give up multiple features of the sugar just so you don't need to write a couple brackets?
13:52:27 <dmwit> hyperisco: From there, the logical next step is that take constructs a list, so LoD says we should write [take 3 x] instead of take 3 x.
13:52:31 <hyperisco> dmwit, you can't talk about .. without talking about the whole of it
13:52:46 <dmwit> __monty__: What features are we giving up? I don't object to comprehension syntax or concrete list syntax.
13:52:51 <__monty__> dmwit: That's not a logical next step imo.
13:52:54 <hyperisco> dmwit, so you have to acknowledge x,y..z and x,y.. and x.. and x..y
13:53:10 <Ariakenom> > [0.0,2..3]
13:53:13 <lambdabot>  [0.0,2.0,4.0]
13:53:17 <hyperisco> dmwit, if you don't then you're not giving yourself the same constraints the language designers had
13:53:22 <__monty__> dmwit: Both [1..], [1,3..] and [1,3..7].
13:53:44 <hyperisco> you can't just say you don't find enumFromThenTo useful… that's a completely different argument
13:53:48 <dmwit> hyperisco: Do you believe you can't design operators that cover those uses...?
13:53:52 <lightandlight[m]> If we had better operator support then `x,y..z and x,y.. and x.. and x..y` would all be fine
13:54:11 <__monty__> dmwit: Yes, because haskell's operator syntax only allows for binary operators.
13:54:11 <hyperisco> dmwit, we cannot define unary or trinary operators, so yes I believe that.
13:54:21 * dmwit looks at (<$>) and (<*>)
13:54:46 <nisstyre> lightandlight[m]: I believe you could solve that by using type classes, but you would have to use something other than "x,y" as the syntax
13:54:46 * ski notes `x : xs' is written `[X | Xs]' in Prolog,Erlang (also cf. "dotted pairs" in Lisps)
13:54:46 * lightandlight[m] wonders what he sees
13:54:47 <Tuplanolla> We should borrow the `Notation` mechanism from Coq. Then we could define all the silly operators.
13:54:47 <hyperisco> dmwit, if we had mixfix support then I would very much prefer this syntax to be defined in a list library.
13:54:57 <Welkin> I don't see the benefit of unreadable unmemorizable operators compared to plain-language functions
13:55:10 <dmwit> lightandlight[m]: I see two binary operators that are in practice used as a ternary operator.
13:55:12 <hyperisco> dmwit, what does <$> and <*> have to do with it?
13:55:26 <Tuplanolla> (As a side benefit, it also requires defining named functions for all the operators.)
13:56:02 <nisstyre> ski: that's one thing that threw me off in Elixir
13:56:09 <nisstyre> especially pattern matching on them
13:56:09 <lightandlight[m]> Right, so `x,y` might return some value that, when combined with `..z`, does everything one wants
13:56:14 <__monty__> The only place where I've personally wanted to type 1..x without brackets is in list comprehensions, it just seems like it should be possible to my brain.
13:56:38 <hyperisco> dmwit, out of the gate x.. isn't doable
13:57:10 <Mrbuck> hi how close scheme to haskell
13:57:17 <dmwit> > True .? 3 .: 4
13:57:20 <lambdabot>  3
13:57:27 <dmwit> hyperisco: That seems incredibly unlikely to me.
13:57:36 <hyperisco> you cannot define unary operators
13:57:39 <hyperisco> why do I have to tell you that
13:57:48 <Tuplanolla> You can define postfix operators, hyperisco.
13:57:56 <dmwit> You are talking about what *is*. I am talking about what *should be*.
13:58:05 <hyperisco> Tuplanolla, teach me
13:58:20 <dmwit> We have one unary operator. Why not more?
13:58:27 <hyperisco> dmwit, then if we're just wish listing then just ask for mixfix operators
13:58:34 <ski> > let (!) = product . enumFromTo 1 in (5 !)
13:58:36 <lambdabot>  120
13:58:56 <dmwit> hyperisco: Okay. Consider it asked. Now you are okay with eliminating brackets from x..y?
14:00:12 <Mrbuck> https://www.youtube.com/watch?v=TJkH1CSHg44&index=23&list=PL9D558D49CA734A02   hee professor compare haskell to python at 49.30 
14:00:24 <hyperisco> I wasn't aware that was allowed. Presumably falls out of operator sections.
14:00:38 <dmwit> It's an extension.
14:00:49 <__monty__> dmwit: In an new language? Sure. In haskell? It'd just be confusing because the sugar'd have to be kept around for backwards compatibility.
14:01:02 * ski wouldn't call it a postfix operator, though
14:01:10 <dmwit> __monty__: I am saying what should have been done 30 years ago, when Haskell was being created.
14:01:11 <Tuplanolla> It relaxes the typing derivation for sections.
14:01:27 <dmwit> (what *I think* should have been done, obviously)
14:01:29 <hyperisco> dmwit, yeah no problem but I haven't considered the possibly parsing ambiguities
14:01:49 <hyperisco> I disagree that [x..y] is a mistake as you put it nonetheless
14:01:56 <hyperisco> it is a well justified notation
14:02:02 <dmwit> Justified by what?
14:02:09 <hyperisco> I've explained it already
14:02:26 <__monty__> It basically falls out of the simple list sugar.
14:02:28 <dmwit> You've explained that there are other forms. I believe we can have multiple forms without having brackets.
14:02:36 <dmwit> Does that summarize the key point on which we disagree?
14:02:41 <hyperisco> no
14:02:56 <lyxia> Mrbuck: he says he hardly knows anything about Haskell, then says it's pythonesque. 
14:03:12 <hyperisco> what I said was that in mathematics it is standard to use an ellipse for repetition, and that is what .. is emulating
14:03:18 <lyxia> Mrbuck: that's hardly a comparison.
14:03:38 <dmwit> Hm. I missed that claim entirely. Can you help me see how to get from there to "and so we need brackets around it"?
14:03:58 <hyperisco> that is why I asked you if you thought [1,2,3,4,5,6,7,8,9,10] was reasonable notation for a list
14:04:26 <Welkin> (1 2 3 4 5) reasonable notation for a list?
14:04:44 <Mrbuck> lyxia:  yeah i am wondering what is python ask he is a great professir and why he dont know haskell :(
14:04:44 <__monty__> No, lispers are obviously insane.
14:04:50 <dmwit> I haven't thought deeply about it. My gut reaction is that [1,2] is reasonable syntax.
14:05:41 <hyperisco> well then [1..10] is eliding the repetition between 1 and 10
14:06:13 <dmwit> Interesting.
14:06:35 <__monty__> [1,2,3,4], [1,2..4], [1..4]
14:08:26 <dmwit> I think I'm not convinced.
14:09:05 <dmwit> In most of the examples I can think of, ... is used to elide operators. But since [x,y] is actually sugar, (,) is not an operator in that sense.
14:09:06 <hyperisco> can't help you there, but that's why it is
14:09:22 <hyperisco> it elides repetition of all forms
14:09:28 <ski> Mrbuck : Haskell has a static type system, Scheme doesn't. Scheme has side-effects (even continuation side-effects, which is unusual), Haskell doesn't. Scheme syntax is more regular, i'd say
14:09:30 <dmwit> Now if you wanted to write 1..10:[] I might find that argument more convincing, but nobody wants that...
14:09:56 <ski> Mrbuck : Scheme (in comparision to other Lisps, say) tends to encourage immutable programming and side-effect-free programming. Haskell mandates side-effect-free programming (by clearly separating effects from general computation of values), also encourages immutable programming
14:10:49 <__monty__> dmwit: How would that be convincing? I can't even interpret that in a way that doesn't lead to errors.
14:11:11 <hyperisco> __monty__, because it is eliding the repetitive use of :
14:11:35 <Mrbuck> ski: thank you
14:12:25 <wroathe> eliding must be the word of the day :P
14:12:28 <__monty__> Then wouldn't it be more mathy to state something like 1 : ... 10 : []?
14:12:41 <hyperisco> now we're going to say eschew
14:12:46 <dmwit> Sure. Maybe even an additional : in front of the 10.
14:13:00 <wroathe> you can't change the word of the day in the middle of the day
14:13:09 <dmwit> I think it's also a mistake to try to import too many rules from natural language to machine languages.
14:14:01 <dmwit> (One of the things people who do formal machine-checked proofs discover is that the informal, natural-language proofs are often imprecise and even slightly incorrect as a result.)
14:14:13 <ski> Mrbuck : .. perhaps you could ask #scheme what they think
14:14:43 <c_wraith> also, if you've ever used Applescript, you probably have a very good idea why natural languages are an awkward fit for programming.
14:15:05 <__monty__> dmwit: But that's not a consequence of the notation they use per se. Also, I wouldn't call mathematical conventions such as these "natural" language per se.
14:15:35 <hyperisco> I think we're a far cry away from masquerading as a natural language
14:16:23 <hyperisco> if the bracket notation was gone I would not shed a tear
14:16:58 <dmwit> (Would you call mathematical conventions such as these a formal language? If so, where can I download the spec, please?)
14:17:02 <c_wraith> I might ask for a shorter alias for enumFromTo
14:17:09 <hyperisco> for what it is though I think it is well conceived
14:17:46 <Mrbuck> okau ski 
14:17:53 <__monty__> dmwit: Pick up most any math textbook : > They usually start with a spec of the notation used : )
14:18:36 <hyperisco> dmwit, all sugar is to appease the human, so would you argue for no sugar?
14:18:59 <dmwit> I don't think I argued for no sugar anywhere.
14:19:18 <hyperisco> you seem to be upset that .. doesn't have a universal formalism
14:20:58 <hyperisco> just look at the shape of the glyphs we use… they are all chosen as an analogy to something
14:21:02 <dmwit> I'm pretty sure I only made claims about what Haskell should be like. So "universal" definitely seems too strong.
14:21:22 <dmwit> (Although I've got plenty of complaints about other things, too, if we want to go there. ;-)
14:21:40 <hyperisco> we write "enclose" things in parens (like this) rather than )like that( because the former resembles like a container around the contents
14:22:54 * ski . o O ⌜⟅0,0,1,2,2,2⟆⌝
14:23:05 <hyperisco> so the notion that .. is tainted because it borrows an intuition from elsewhere is silly
14:23:13 <dmwit> True (acknowledgment). But (connective) we (pronoun) rarely (adverb) indicate (verb) the (article) types (noun) of (...I don't even know) everything (pronoun??) explicitly (adverb).
14:23:30 <hyperisco> dmwit, preposition
14:23:35 <dmwit> thanks =)
14:24:06 <hyperisco> it is not indicating the type
14:24:19 <hyperisco> I don't know how you're so convinced of that either
14:24:59 <__monty__> dmwit: Have you considered defining (...) = enumFromTo?
14:25:12 <hyperisco> you can't have that operator because I've already used it
14:25:20 <hyperisco> dibs
14:25:21 <dmwit> hehe
14:25:25 <cemerick> hyperisco: alas, it looks like SPECIALISE doesn't play nicely with phantom types, so not really an option in ST
14:25:34 <hyperisco> cemerick, interesting
14:25:39 * ski thinks dmwit is irked not by having recourse to alternatives, but by the existence of `[x .. y]'
14:26:06 <hyperisco> cemerick, but yes what is probably happening is you're now running code which works universally on any Monad, which means it is now using indirection
14:26:48 <dmwit> Even "irked" is probably too strong. Idly amusing myself, mostly.
14:27:08 <cemerick> hyperisco: right, all motivated by a typeclass that has instances over Identity, ST, and IO. The perf hit is intense, unfortunately
14:27:08 <hyperisco> cemerick, whereas the monomorphic version does not require that indirection and can even benefit from inlining and other optimisations thereafter
14:27:14 <__monty__> I'm guilty to actually using it for fmap fmap fmap sometimes.
14:28:42 <Tuplanolla> :t (⣿) -- You need to step up your `fmap` game, __monty__.
14:28:44 <lambdabot> (Functor f1, Functor f2, Functor f3, Functor f4, Functor f5, Functor f6, Functor f7, Functor f8) => (a -> b) -> f1 (f2 (f3 (f4 (f5 (f6 (f7 (f8 a))))))) -> f1 (f2 (f3 (f4 (f5 (f6 (f7 (f8 b)))))))
14:28:52 <cemerick> hyperisco: I was hoping (expecting?) the call trees to be specialized automatically, since the root usage in _my_ code is always clearly in a concrete monad (e.g. ST when loading/updating data, Identity when querying)
14:29:05 <hyperisco> this is why I made control-dotdotdot… one operator to rule them all
14:29:55 <hyperisco> it always gives you the maximal of .'s possible in your situation, though sadly not generalised to Category
14:30:33 <merijn> Anyway, now that we're done discussing syntax, can we get back to my technical problem? ;)
14:31:07 <subttle_> Hi I have a question regarding implementing the Show class. I can define a Show instance just fine when I implement the `show` function but when I try to define the Show instance by implementing `showsPrec` it does not display the unicode correctly. Any ideas why? Thanks!
14:31:21 <hyperisco> cemerick, I do not know the rules for specialisation but it does not always happen and you wouldn't want it to either. If it always happened then your binary size could increase dramatically.
14:31:34 <merijn> There has to be some reasonably efficient way to maps a sparse set of values to a dense set of indices...
14:31:36 <delYsid> Just Nothing
14:32:01 <hyperisco> merijn, more detail required
14:32:21 <merijn> hyperisco: I have K integers between M and N that I want to map to 0 through K-1
14:32:42 <merijn> As efficiently as possible
14:32:50 <cemerick> hyperisco: perhaps, but I'm hardly worried about that atm
14:33:46 <merijn> The best I got so far is to have a N-M sized vector and storing a unique index at index value-M, but that's wasteful of M and N are far apart and K is small
14:34:09 <hyperisco> merijn, okay so you haven't a representation for your set yet then
14:35:17 <merijn> hyperisco: I get a (repeating) stream of numbers I need to lookup as they come in, so no there's no fixed representation
14:35:49 <hyperisco> merijn, to discern what is efficient you have to stipulate not just the data but the ways in which you want to use it
14:36:09 <hyperisco> for example, do you need to incrementally update the data? how do you intend on querying the data?
14:36:14 <merijn> hyperisco: Getting an index between 0 and N *is* the use
14:36:32 <hyperisco> I thought N was a lower bound on K
14:36:47 <merijn> hyperisco: eh, between 0 and K-1, yes
14:37:36 <hyperisco> so basically, given a number in your set, you want to determine how many numbers precede it in an efficient manner
14:37:38 <Welkin> haha
14:37:41 <Welkin> you're still on about this
14:37:50 <merijn> hyperisco: The values I have are keys for data, I'm building vectors and need to do so deterministically, despite getting values on non-deterministic order
14:38:07 <merijn> hyperisco: So I need to map the sparse key set to a dense index set
14:38:18 <hyperisco> this seems easily done with a balanced tree that stores tree size at every node
14:38:50 <hyperisco> which is actually a well known functional technique but my memory is foggy
14:39:18 <hyperisco> merijn, can you intuit the rest or should I explain more?
14:39:58 <merijn> hyperisco: I don't really see what the tree size is supposed to add?
14:40:14 <hyperisco> did you catch my rephrasing of your problem?
14:40:43 <merijn> oh, yes
14:41:24 <merijn> hyperisco: Although then I might as well just build a sorted array of keys and do binary search (which might work)
14:41:27 <hyperisco> right, so say we store lesser numbers to the left, then we just add up the left tree sizes as we drill down to your number
14:41:38 <merijn> Because then I get the size for "free"
14:42:19 <hyperisco> especially if you know K upfront then yeah, an array and bin search will give you better constants
14:43:04 <merijn> hyperisco: I don't know K up front, but I'm willing to pay the prize on the first repeat of the sequence if it saves me on all later repetitions. (I'm looking at about 300k repetitions, so...)
14:43:11 <hyperisco> also considering you do not need to incrementally change the map
14:43:23 <Welkin> what about a B tree
14:43:39 <hyperisco> merijn, so you can use an exponentially growing array
14:44:07 <merijn> hyperisco: Right, but even if I don't the cost of linearly growing once over 300k repeats is gonna be negligible ;)
14:44:22 <merijn> Welkin: I don't see how B trees would improve of binary searching an array
14:44:55 <hyperisco> merijn, linear growth is quadratic, so that really depends on how big K is
14:45:02 <hyperisco> merijn, repeating something 300k times is constant ;)
14:46:01 <merijn> hyperisco: K should typically be between 20-100, so that's fine. Might worth seeing if binary search is even worth it compared to sequential scan for those sizes...I'm just sad I can't figure out a direct indexing scheme :/
14:46:36 <hyperisco> merijn, sequential scan is very likely faster
14:47:04 <hyperisco> merijn, I am not sure what you qualify as "direct"
14:47:04 <Welkin> indexing in what way?
14:47:27 <Welkin> is this in memory or persistent?
14:48:07 <merijn> hyperisco: Well, the original scheme of just having an array from 0 through N-M, but I just dunno of the difference between those two will be small enough to get away with that
14:48:32 <hyperisco> merijn, I have an easy option for you to try first
14:48:35 <merijn> hyperisco: Because then you can get away with "read value from an array, index by value read"
14:48:39 <hyperisco> merijn, http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Map-Strict.html#v:findIndex
14:48:54 <hyperisco> memory served that Data.Map was implemented with such a tree and I think I'm right
14:49:43 <hyperisco> merijn, you have to decide what knowledge you have of M, N, and K
14:50:03 <hyperisco> merijn, if you want to keep them arbitrary then that is one problem, and if you want to know something about them then that is another problem
14:50:34 <merijn> hyperisco: That would be an easy option, if the implementation was Haskell ;) But the algorithmic brainstorming quality in other places was...low quality :)
14:50:50 <hyperisco> you know I suspected this wasn't Haskell
14:51:01 <Welkin> so why is it in #haskell?
14:51:11 <hyperisco> because smart like-minded people are here
14:51:23 <Welkin> also the constraints of the hardware must be accounted for
14:51:25 <merijn> Welkin: Because programming and algorithms are on-topic here too?
14:51:34 <Welkin> on embedded platforms you are stuck with flat arrays
14:51:50 <Welkin> e.g. game consoles
14:51:50 <hyperisco> you're not stuck, you can use trees
14:52:04 <Welkin> it's most efficient to use arrays for everything
14:52:14 <Welkin> cache performance
14:52:25 <hyperisco> it is often more efficient to use an array for small numbers of elements
14:52:30 <hyperisco> lets not exaggerate
14:52:46 <merijn> hyperisco: tbh, arrays are often also more efficient for large numbers
14:53:11 <Welkin> cache performance optimization can make a two order of magnitude difference
14:53:12 <merijn> I would argue that arrays are the one true high-performance data structure (maybe with a little bit of heap/sorting logic on top)
14:53:15 <hyperisco> it depends on what you're trying to do with the data
14:53:35 <Welkin> well you structure the data to solve the problem
14:53:47 <Welkin> just like with a (NoSQL) key-value store
14:54:00 <Welkin> lookup one key and you have everything you need
14:54:15 <hyperisco> you both can conceive of situations where it wouldn't be optimal to be memcpying huge arrays
14:54:37 <Welkin> it's not copied
14:54:58 <hyperisco> you're not being imaginative enough
14:55:08 <merijn> hyperisco: Sure, but also many situations where appending everything to a huge array, and sorting it once beats all sorts of fancy heap/set/etc. data structures
14:55:13 <hyperisco> not every problem is solved by in-place updates
14:55:47 <hyperisco> yes absolutely merijn 
14:56:35 <hyperisco> random example, here's sequence vs array in PureScript https://github.com/hdgarrood/purescript-sequences/blob/master/benchmarks/graphs/insert-lots.png
14:56:51 <hyperisco> you can see Seq makes some quick wins at 10k+ elements
14:56:54 <merijn> I think the importance of algorithmic complexity of many datastructures is actually of rather little importance. The main reason to use fancier data structures is ease of querying
14:56:54 <Welkin> purescript is implemented in javascript
14:57:06 <hyperisco> Welkin, Haskell
14:57:12 <Welkin> no
14:57:13 <hyperisco> and look this is wonderful https://github.com/hdgarrood/purescript-sequences/blob/master/benchmarks/graphs/append.png
14:57:21 <Welkin> the output and runtime is javascript
14:57:24 <merijn> Which is fine, ease of querying/writing stuff is imporant
14:57:28 <hyperisco> Welkin, yes it is
14:58:06 <hyperisco> but then here it really starts to hurt https://github.com/hdgarrood/purescript-sequences/blob/master/benchmarks/graphs/map.png
14:58:12 <Levy[m]> Well, doesn't it have multiple codegens?
14:58:21 <hyperisco> and this just makes one feel bad https://github.com/hdgarrood/purescript-sequences/blob/master/benchmarks/graphs/filter.png
14:58:47 <nshepperd1> Data structures don't have algorithmic complexity, operations on them do
14:58:58 <hyperisco> anyways, point is absolutely depends on what you're trying to do with the data
14:59:23 <merijn> nshepperd1: Fortunately we're all humans and understand the nuances and implied meanings that can exist in natural language...
14:59:26 <nshepperd1> Mutable arrays certainly do have some operations on them that are efficient
14:59:36 <nshepperd1> And other ones that aren't
15:00:10 <hyperisco> Levy[m], there is also a C backend in development but on the large it is a functional veneer over JavaScript
15:00:48 <merijn> hyperisco: Anyhoo, you gave me some ideas, so thanks
15:00:49 <Welkin> what's the point? use haskell
15:01:03 <hyperisco> consequently this has informed me that it is vital to have at least two backends upon language conception, else you end with unfortunate and unnecessary dependencies
15:01:14 <Levy[m]> Haskell is rather clucky for web
15:01:24 <Levy[m]> at least frontend
15:01:26 <Welkin> not at all
15:01:27 <Levy[m]> that's why
15:01:31 <Welkin> for the frontend yes
15:01:34 <Welkin> that is why I use Elm
15:01:35 <hyperisco> Welkin, first is that it is much more convenient to use for the web because it is easy to compile for the web.
15:01:47 <hyperisco> Welkin, second is that row types are a world of difference.
15:01:57 <Levy[m]> Welkin: Elm hurts (no type classes)
15:02:04 <Welkin> Levy[m]: that is bull
15:02:25 <Welkin> I have written over 16,000 lines of elm and have never had a problem that typeclasses would solve
15:02:32 <Welkin> typeclasses are not the missing feature you think they are
15:02:33 <hyperisco> Welkin, third is that it has some good web libraries that frankly I'd choose the language just to use.
15:02:37 <Levy[m]> Which is why I'm exploring Idris as a replacement
15:03:00 <hyperisco> yeah ever since Idris started the web game I've been keeping an eye on it
15:03:04 <Levy[m]> Welkin: There's quite a bit of duplication in elm
15:03:13 <Welkin> now, a more advanced type system might be helpful, but it's not necessary
15:03:32 <hyperisco> Welkin, I wrote three times that in C# and agree with you.
15:03:35 <Levy[m]> plus I like my fancy dependent types
15:04:11 <monochrom> merijn: Unfortunately we humans are not really all that smarter than monkeys so we mimick and cargo-cult what we don't understand (and we go on to assume we understand). So if a beginner sees two experts talking in inaccurate abbreviated wording (nothing wrong if it's kept between the two experts), the beginner actually believes the literal wording.
15:04:53 <Levy[m]> hyperisco: I'm mostly experimenting with AFRP for it at the moment. Rewrote this library about 5 times now (learning as I go)
15:05:00 <hyperisco> honestly I don't think the majority of Haskell programmers quite understand the uniqueness of type classes
15:05:22 <wroathe> What's up with Cabal having a ridiculous CLI?
15:05:25 <hyperisco> but it is something you figure out when you emulate a Haskellish functional style in other languages without TCs.
15:05:26 <Welkin> it's virtual functions in C++
15:05:31 <Welkin> just a dictionary that gets passed around
15:05:33 <Welkin> nothing special
15:05:44 <zachk> I rarely code my own typeclasses :-/ other then for experimenting around with ideas 
15:05:46 <merijn> wroathe: ridiculous how?
15:05:48 <wroathe> When I say ridiculous I'm talking about the v1- v2- subcommands
15:06:01 <merijn> wroathe: Because it's transitioning
15:06:19 <merijn> wroathe: it used to just be "build", but the that implementation has...issues
15:06:23 <Levy[m]> Welkin: It's convenient
15:06:24 <monochrom> wroathe: In the case of cabal-install I think there is no satisfactory CLI possible.  Much of cabal-install's functionality is really better off present by menus and checkboxes.
15:06:42 <hyperisco> Welkin, confluence and the global uniqueness of instances are not features to be omitted when describing type classes.
15:06:48 <monochrom> s/present/presented/
15:06:56 <merijn> wroathe: A new implementation has been in the works for a while as "new-build" (now aliased to v2-build)
15:06:57 <hyperisco> Welkin, neither of which are present in just passing around dictionaries.
15:06:57 <__monty__> Has anyone looked at Ur/web as a substitute for elm?
15:06:57 <jle`> Welkin: there's some advantages to typeclasses that you might run into when doing general purpose programming. but i agree that in certain domains, you might be better off without them
15:07:17 <jle`> wroathe: but yeah, typeclasses *themselves* are more than just dictionary passing. that's just an implemetnation
15:07:35 <jle`> just like how parsers are more than String -> [(a, String)] ... that type itself is "too big" (it can be used to describe non-parsers)
15:07:52 <merijn> wroathe: The next release will replace the default "build" with new-build/v2-build, but projects that can't/don't want to deal with that need a way to access the legacy implementation (aliased to v1-build)
15:08:13 <jle`> dictionary passing can be used to implement typeclasses, but the actual usage of typeclasses is an abstraction that is more than just passing dictionaries
15:08:23 <merijn> wroathe: So the current version supports v1-build and v2-build to allow people to future proof their scripts using cabal-install
15:08:31 <monochrom> There is much semantic difference between instancing and dictionary passing. Instancing is nailed by type and cannot varying by values of that type, dictionary passing can vary by values.
15:09:10 <hyperisco> what I think people overlook is that just because they use a class member doesn't mean they're using type classes in a meaningful way
15:09:26 <merijn> wroathe: Which, honestly, seems like the only reasonable way to do such a transition (at least, to me)
15:09:34 <monochrom> It is still useful to know about dictionary passing, of course. Becomes handy when explaining under-performance.
15:09:42 <hyperisco> once you instantiate a class member you're just talking about an instance, which isn't the same as talking about the whole class
15:10:11 <wroathe> merijn: In general, I prefer an approach based on keeping the interface the same, i.e. "build" remains "build", but signifying breaking changes with a new major version
15:10:12 <hyperisco> you can, for example, say pure instead of (:[]) but if the type is [a] anyhow you haven't done anything more special by saying pure
15:10:47 <hyperisco> it isn't until you write definitions for the whole class that you're actually working with type classes
15:10:47 <merijn> wroathe: Well, just "build" should still work
15:11:07 <merijn> wroathe: At least on my 2.4 and HEAD installs of cabal-install :)
15:11:17 <wroathe> merijn: So cabal v1 would retain the previous interface, and get minor patches if necessary, but v2 should implicitly use the v2 functionality for build
15:11:24 <__monty__> wroathe: What about all the legacy code that just won't work with the new version of build?
15:11:34 <hyperisco> and that is why type classes are not as missed as you might anticipate, because quite often you're just programming for one instance rather than the whole class
15:12:04 <wroathe> __monty__: You'd have to install v1 of Cabal to build it
15:12:13 <monochrom> Ahem, the 1.24 -> 2.2 change is a major version change.
15:12:27 <merijn> wroathe: But now you need to maintain two branches with all the hassle that entails
15:12:38 <hyperisco> and in my experience, the times where I wanted a general definition such as sequence were so few it really wasn't a problem to bang out the versions for each type
15:12:40 <merijn> wroathe: There's not enough manpower
15:12:44 <monochrom> Hell in fact recall that by the PVP even 1.x -> 1.(x+1) is already a major version change.
15:13:00 <__monty__> monochrom: Yeah, but wroathe's talking about maintaining the 1.xyz branch.
15:13:00 <hyperisco> anyways, later gators
15:13:05 <__monty__> Does cabal use PVP?
15:13:11 <monochrom> Yes.
15:13:23 <__monty__> I figured it'd do something more like GHC, since they're somewhat tied together afaik?
15:13:35 <monochrom> No.
15:14:01 <merijn> wroathe: Also, keep in mind that Cabal (the package format library) changes independently of cabal-install, so merely stick with cabal-install-1.24 means dealing with interface changes in Cabal, etc.
15:15:02 <wroathe> merijn: I've just never seen a package manager CLI accrue legacy versions of subcommands before. I suppose I can sympathize with argument of lacking manpower though.
15:15:03 <codedmart> Currently I am reading chunks of a file `hGetSome han defaultChunkSize`. But if I wanted to make that more concurrent. Like say 3 or 5 at a time. How would I could about that properly.
15:15:21 <merijn> wroathe: The intention is not to support v1 indefinitely
15:15:41 <merijn> wroathe: At least, not as far as I'm aware
15:15:45 <wroathe> merijn: Obviously. I'm just pointing out that it's very "non-standard" to take the approach that they took
15:15:57 <wroathe> it's fairly non-standard*, is what I meant to say
15:16:01 <wroathe> Not very
15:16:23 <__monty__> wroathe: I think scala's build tool is pretty much built around automatically delegating to legacy versions of itself?
15:16:28 <merijn> wroathe: Sure, but in the grand scheme of things, that seems like a very minor complaint ;)
15:16:57 * hackage influxdb 1.6.1.1 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-1.6.1.1 (MitsutoshiAoe)
15:17:45 <wroathe> __monty__: I can't speak for Scala, but I haven't seen this approach in use by NPM, Pip, Bundler, NuGet, Maven, etc
15:18:31 <glguy> Are those build tools that introduced a dramatically different system for building and toss out the old system then?
15:19:19 <wroathe> merijn: And my complaint really was just with the ergonomics of their CLI - not the tool itself. So you're right, it is a small complaint :P
15:20:11 <merijn> wroathe: That problem should go away in 3.0 when build will be v2-build (because you really shouldn't be using v1-build anymore now)
15:21:15 <monochrom> I don't know or understand the complaint, but I like this philosophy.  If a discontiuity will happen, firstly the discontinuity is scheduled one year (say) in the future, and secondly during that year the planned discontinuity is naggingly announced and in fact even goes through stages of "deprecated" "obsoleted" "will be removed real soon now" "will be removed in 3" "2" "1" "0.5" "0.25" "please note that it will be removed real soon now"
15:22:05 <monochrom> If you say other people just surprise you with instant discontinuity then other people are wrong.
15:22:45 <glguy> You could bake in obsolescence where instead of not having the command work at a certain version you could have it stop working on a certain date
15:22:51 <merijn> monochrom: I think the complaint is "typing v2-build instead of build looks ugly/funky" :p
15:22:52 <Welkin> v1? v2?
15:22:56 <Welkin> you mean new-build?
15:23:03 <freeman42x> is fclabels-2.0.3.3 supposed to take forever to compile?
15:23:11 <merijn> Welkin: v2-build is the "production" name for new-build
15:23:19 <Welkin> what does that mean?
15:24:46 <wroathe> Well, going back to deprecation... The typical approach I've been a fan of is to set a limit for the number of major versions the team is willing to support, and then maintaning them on separate branches. So in the case of cabal, you'd have a branch for 1.x, and a branch for 2.x. Using Cabal v1.x would print the preamble about upgrading to 2.x ASAP when using any command, and the v1 commands would not be 
15:24:52 <wroathe> present at all in 2.x
15:25:27 <wroathe> But to merijn's point, that does require some doing
15:25:42 <monochrom> That is the best way if no beginner question ever exists.
15:26:13 <merijn> Welkin: That it's the name which it now uses (and will keep using) across the transition to the new default
15:26:54 <wroathe> monochrom: In this context what do you mean by "beginner question"?
15:27:17 <monochrom> As soon as there are two beginners asking the same "hi I tried 'cabal install foo' I got into such and such problem" you're tossed because they are using two different versions (and semantics) and if you are experienced in talking to beginners you know it will take forever to wrangle that information (or any information at all) from them.
15:27:31 <merijn> wroathe: "Why is my thing broken when I follow this tutorial?"
15:28:04 <wroathe> monochrom: I feel that you'd be talking about absolute beginners to programming in general in that context. I'd argue that pattern I described is fairly widespread and idiomatic.
15:28:21 <monochrom> Hell in fact travel back in time to the hay days of python2->python3 and go to #python (or is it ##python) and see the confusion.
15:28:48 <monochrom> Or hell maybe those hay days are still not over yet.
15:29:27 <Welkin> merijn: since what version of cabal?
15:29:52 <monochrom> And yeah outdated blogs on the web never die.
15:30:11 <monochrom> Plus Google is pretty conservative about obsoleting old hits.
15:30:18 <merijn> Welkin: 2.4, I think?
15:30:30 <wroathe> monochrom: To some degree the burden of finding up-to-date information is on the consumer though in this field
15:30:31 <Welkin> dont ever learn programming from random blogs or from self-published books online
15:30:38 <Welkin> you will cry and scream
15:30:46 <Welkin> get a professionally published and edited book
15:30:51 <Welkin> and read the official guide/docs
15:31:03 <wroathe> monochrom: I don't know about you, but any time I'm reading a blog post one of the factors I consider is how old it is, and how out of date the information might be
15:31:22 <monochrom> It is not about me, it is about the unwashed mass out there.
15:31:40 <monochrom> You are preaching to the choirmaestro.
15:33:10 <Welkin> the churromaster
16:00:34 <widmur> So this is likely a trivial question. But why is a function of type (Ord a, Ord b) => a -> b -> Bool unresolvable? Can different instances of the Ord typeclass be compared?
16:01:02 <glguy> :t compare
16:01:04 <lambdabot> Ord a => a -> a -> Ordering
16:01:12 <Solonarv> No, because all the functions in 'Ord' require two arguments of the same type
16:01:17 <glguy> The Ord class gives you this function (and some specializations of it)
16:01:54 <glguy> :t \x y -> compare x x == compare y y
16:01:56 <lambdabot> (Ord a2, Ord a1) => a1 -> a2 -> Bool
16:03:25 <Solonarv> That seems spectacularly useless, since it's simply '\_ _ -> True' unless one of the Ord instances involved is broken
16:03:30 <c_wraith> widmur, from a more practical point of view, is False < Nothing?
16:03:54 <glguy> Solonarv: It's not useless, it infers to having the type in question!
16:04:03 <glguy> Solonarv: Yours is too general :)
16:04:14 <Solonarv> feh!
16:05:53 <widmur> Didn't think to look in the typeclass, thanks. I guess it's a bit nonsensical to attempt to do so.
16:09:56 <WWMD> Hello!
16:12:00 <aranea> Hello. I have a little trouble with cross-compiling GHC. According to https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling, it shouldn't be neccessary to pass a --host option to ./configure, but unless I do that, configure fails, complaining "configure: error: cannot run C compiled programs. // If you meant to cross compile, use `--host'.". That's easy enough to fix, but...
16:13:15 <aranea> ... even when I call configure with that option, make later fails with the same error when it runs another configure script for base-4.11.1.0. Did I miss something, or is this a bug in the GHC build system?
16:17:07 <glguy> aranea: That might be worth asking in #hgc
16:17:09 <glguy> #ghc
16:18:20 <aranea> Thanks, I didn't know there's a separate channel.
16:33:10 <WWMD> I'm having trouble with the PolyKinds extension.
16:34:59 <WWMD> Sorry, I'll elaborate in a sec. I'm just pulling up my code.
16:35:52 <dmwit> ?djinn (a -> a -> Ordering) -> (b -> b -> Ordering) -> a -> b -> Bool
16:35:52 <lambdabot> Error: Undefined type Ordering
16:36:00 <dmwit> ?djinn-add data Ordering = LT | EQ | GT
16:36:08 <dmwit> ?djinn (a -> a -> Ordering) -> (b -> b -> Ordering) -> a -> b -> Bool
16:36:08 <lambdabot> f a b c d =
16:36:08 <lambdabot>     case a c c of
16:36:08 <lambdabot>     LT -> False
16:36:08 <lambdabot>     EQ -> False
16:36:08 <lambdabot>     GT -> case b d d of
16:36:10 <lambdabot> [3 @more lines]
16:37:03 <dmwit> widmur: You may like this tool for double-checking claims of the form "such-and-such type is not implementable". It isn't perfect (esp. classes that method non-class variables in their method signatures are hard), but it can do a lot.
16:37:40 <dmwit> ?djinn Not (Not a) -> a
16:37:40 <lambdabot> -- f cannot be realized.
16:38:01 <ski> @djinn ((a -> b) -> a) -> a
16:38:01 <lambdabot> -- f cannot be realized.
16:39:15 <ski> @djinn NotNot (NotNot a -> a)
16:39:15 <lambdabot> f a = void (a (\ b -> void (b (\ c -> a (\ _ -> c)))))
16:40:08 <dmwit> jeez
16:43:09 <ski> @type \k -> k (\nna -> absurd (nna (\a -> k (\_ -> a))))
16:43:10 <lambdabot> ((((p -> t) -> Void) -> p) -> t) -> t
16:55:53 <dmwit> :t traverse
16:55:55 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
16:59:17 <dmwit> Traversable, the rank-3 constraint that everybody uses in day-to-day Haskell
17:02:37 <koz_> dmwit: Wait, rank _3_?
17:02:52 <dmwit> yeah =)
17:03:13 <dmwit> Are you on board with Applicative being rank-2-like?
17:03:20 <koz_> dmwit: No, not quite.
17:03:25 <koz_> Mind filling me in?
17:03:29 <dmwit> sure
17:03:45 <dmwit> So let's focus on just `pure` for now and forget about `(<*>)`.
17:04:00 <dmwit> You can think of `Applicative f => t` being a bit like `(forall a. a -> f a) -> t`.
17:04:20 <dmwit> Which is rank-2 polymorphism.
17:04:51 <koz_> The 'forall a. a -> f a' is basically 'has an implementation of pure' I take it?
17:04:58 <dmwit> Exactly.
17:05:04 <koz_> OK, now I get you.
17:05:07 <koz_> Thanks.
17:06:26 <dmwit> So yeah, `Traversable t => a` is rank-3-like because (focusing on `sequenceA`) it becomes something like `(forall f b. Applicative f => t (f b) -> f (t b)) -> a`, which has a rank-2-like type to the left of an arrow.
17:07:29 <Solonarv> Hmm. Now I'm wondering if rank-N types can be emulated using typeclasses alone.
17:07:59 <dmwit> It seems a natural question. *Something* must be lost, since Haskell inference is tractable and rank-N inference is undecidable.
17:10:06 <dmwit> (Also Haskell has principal types and rank-2 already loses that property.)
17:12:10 <dmwit> Ah, I see. The class method name chooses between the incomparable types.
17:12:53 <dmwit> So where in the rank-2 system a single term might be given two incomparable types, in Haskell one would need to change the term to mention a different class method to switch between them.
17:41:05 <phadej> you can always newtype Rank1 a b = Rank1 (forall c. c a -> c b)
17:41:15 <phadej> because there are these wrappers, the inference works out
17:41:43 <phadej> i.e. GHC doesn't infer where to "wrap/unwrap"
18:27:16 <dmwit> phadej: What problem does Rank1 solve?
18:31:07 <c_wraith> I don't think there are any useful values of that type except for Rank1 id
18:32:29 <c_wraith> on the o her hand, if you added a constraint on c, it could do something useful.
18:32:34 <c_wraith> *other
18:35:25 <dmwit> coerce, maybe
18:35:52 <dmwit> Which I guess is pretty id-like in some ways. ...but not in others.
18:36:00 <NemesisD> is there a typeclass or something i could use where if i've got something like data MyDict (m :: * -> *) { foo :: m Foo, bar :: A -> m Bar} that i could use with (forall a. m a -> n a) -> MyDict m -> MyDict n. natural transformation?
18:36:22 <dmwit> Hm, maybe even coerce wouldn't work. Never mind.
18:37:49 <dmwit> NemesisD: Functor1, though I don't know of a publically-available library for it
18:38:40 <dmwit> category-extras used to have Control.Functor.HigherOrder
18:38:50 <dmwit> But it didn't survive the explosion.
18:39:45 <NemesisD> that's unfortunate. i've been slowly pursuing this idea and i'm starting to get the impression that its stupid
18:40:52 <dmwit> Hoogle says hschema and fused-effects have it.
18:41:00 <dmwit> Which... seem like odd dependencies to have for this.
18:41:12 <monochrom> An explosive idea :)
18:41:23 <NemesisD> the idea is to have an extensible explicit dictionary. you write  capabilities that are always parameterized over the monad: data Terminal m = Terminal { putStrLn :: String -> m () }, clock Clock m = Clock { getCurrentTime :: m UTCTime }, then merge them using vinyl: type Dict (m :: * -> *) (caps :: [(* -> *) -> *]) = Rec (Cap m) caps
18:42:47 <NemesisD> but once things get complicated, you end up having to either be vague about m: realTerminal :: MonadIO m => Terminal m, or you need a way to lift the m so you can align the m type parameter all the parts of your dictionary
18:43:53 <Welkin> that sounds way, way too complicated
18:44:07 <Welkin> when would you use that? and who would use it?
18:44:40 <dmwit> At a guess: could be for mocking or similar.
18:45:52 <NemesisD> the implementation is pretty simple, just some type aliases and a simple newtype. the purpose would be to be able to have a partially (or fully) mockable capability system. the cost is carting an explicit dictionary around
18:47:05 <dmwit> As a backup plan: what if you carted an implicit dictionary around. =P
18:47:15 <dmwit> class Terminal m where putStrLn :: String -> m ()
18:47:21 <NemesisD> this is partly inspired by scrap your typeclasses. i got the idea for a refactoring i often do where i take a big hairy monadic block and decompose it into a separate version that takes its impure actions as parameters until m simply has a Monad constraint
18:47:54 <dmwit> Should be just as good for mocking, anyway.
18:48:08 <Solonarv> I've played around with that idea after you brought it up a few days ago, and it seems like another point in the effect-system space
18:48:21 <Welkin> or you can set up your test inside the scope where you define the dictionary
18:48:34 <NemesisD> i guess i'm just wary of having to universally quantify a mock like that. i find it only slightly uglier and much simpler to have a dictionary around, especially if there's only 1
18:48:51 <NemesisD> oh hi, Solonarv :)
18:48:55 <Solonarv> It's fairly similar to the (Has e Terminal, Has e Logger, MonadReader e m) => m a approach
18:49:19 <monochrom> You are just looking at the difference between a type-level forall and a value-level forall.
18:49:42 <monochrom> OK "just" shouldn't be there because the difference is very big :)
18:49:55 <NemesisD> Solonarv: yeah exactly, except that got a little messy when the rubber hit the road because my "real" monad is usually a ReaderT over a config and connection object, so adding another reader to the stack got kinda ugly. there may be a clean way to do it
18:50:35 <Welkin> in my lastest project I use no transformers
18:50:46 <monochrom> A value-level forall is more flexible, actually.
18:50:52 <Welkin> I pass around the config object, or have it in scope already
18:51:11 <Solonarv> yeah that's also an approach
18:51:35 <NemesisD> if you're passing a config around all over the place, maybe it isn't so bad to also pass a dictionary of capabilities, hehe
18:51:59 <Solonarv> my happy point is (MonadSDL m, MonadLogger m) => m a
18:53:30 <NemesisD> Solonarv: how do you inject your capabilities? data TestStack = { sdlStuff :: ..., loggingStuff :: ... }, instance MonadSDL (ReaderT TestStack m) where ... ?
18:53:59 <Solonarv> I don't actually do any mocking in that project, but that's how I would do it
18:55:05 <NemesisD> the only downside i see there is that mocking out some capabilities but not others for specific parts of the test suite requires a new specialized datatype and instance, plus i guess an instance for every one you're not mocking
18:55:34 <monochrom> Oh I have a cunning plan! I can do the worst of both worlds.  So the class way is "(CanDoX m, CanDoY m) => m ()" and the dictionary way is "DictX m -> DictY m -> m ()", right?  So how about passing a dictionary but be class-polymorphic about what methods the dictionary have: (HasMethodX dict, HasMethodY dict) => dict m -> m ()
18:55:47 <NemesisD> unless you were gonna do something like instance (Has SDLStuff r, MonadReader r m) =>  MonadSDL m where
18:56:53 <Welkin> wait
18:56:58 <monochrom> Hey that's even "better" than my version! :)
18:56:59 <Welkin> just use a record
18:57:03 <NemesisD> monochrom: i'm talking about only ever having one dict and then your functions look like (HasCap Terminal caps) => Dict m caps => m ()
18:57:12 <NemesisD> erm de-fat that second arrow
18:57:52 <Solonarv> (or turn 'Dict m caps -> m a' into a monad transformer)
18:57:53 <Welkin> or replace it with =&=>
18:57:56 <Welkin> the latest lens operator
18:58:09 <NemesisD> Solonarv: ooh!
18:58:14 <Welkin> I call it doing-yoga-on-a-rocket
18:58:29 <Solonarv> NemesisD: I posted a gist of that when you brought this up the last time, lmao
18:58:30 <Welkin> (in kabab-case of course)
18:58:34 <Solonarv> at least I think I did
18:59:09 <NemesisD> Welkin: lmao i literally had to check if you were joking
18:59:40 <NemesisD> Solonarv: do you happen to have that gist still? i basically only poke around at this idea on wednesday evenings at a coffee shop
18:59:56 <NemesisD> also: is this a stupid idea?
19:00:09 <Solonarv> it's probably a bit overcomplicated
19:00:15 <Welkin> why does it need to be a dictionary for each effect?
19:00:25 <Welkin> can;t you just have a single record that contains all effects?
19:00:53 <monochrom> It is not a stupid idea. It is just very general/abstract, you may not need it all that much.
19:01:23 <NemesisD> Welkin: more like each domain of effects. it allows different areas of the program to provide mockable operations that can be combined as needed. it allows you to look at a function and know what capabilities it uses, which ones it doesn't. don't need access to postgres? i could run that function without having a connection pool available
19:01:45 <Solonarv> we don't have language-level row types, so it can't be a single "native" record of all effects without being super clums
19:02:26 <Solonarv> and the tricks to get row types (i.e. vinyl) amount to wrapping each operation in a data type, so you might as well wrap related ones together
19:02:47 <NemesisD> right, but i was pretty happy with vinyl's ability to pull a field out by *type*, since it doesn't make sense to have a dictionary with duplicate capabilities. i'd be happy if i could hide most of the vinyl stuff in a module
19:03:04 <Welkin> oh, this is to place constraints on effects at the type level?
19:03:34 <Welkin> practically, how useful is that even? IO is IO
19:03:49 <Welkin> in a given program, you will want logging everywhere and database access almost everywhere
19:03:54 <Welkin> in terms of a web server
19:04:03 <NemesisD> Welkin: i think so? so functions that only need access to the Terminal effect record would be (HasCapability Terminal caps) =>  Dict caps m => m ()
19:04:14 <monochrom> Useful by the time you want to mock-test or dependency injection or strategy pattern or what they call it next week.
19:04:21 <Solonarv> (again, de-fat that second arrow)
19:04:26 <NemesisD> god damnit
19:04:43 <NemesisD> arrows too thicc. sorry, i should have ordered coffee
19:04:45 <jackdk> one thing that's nice is having database transactions being their own effect, and forbidding the injection of arbitrary IO. finish your transaction, then do your IO
19:04:50 <hadley> \join #haskell-fr 
19:04:54 <hadley> oops 
19:05:06 <Welkin> jackdk: what do you mean?
19:05:35 <Welkin> all database operations are wrapped in a transaction
19:06:04 <Welkin> at least the way I write mine, using begin/commit or with-as
19:06:20 <monochrom> Read my http://www.cs.utoronto.ca/~trebla/CSCC24-2018-Summer/FAM.hs  near the end.  (To jump ahead, look for "mock test example".)
19:06:21 <NemesisD> in the pit of my stomach i feel like this is probably a bust or too crufty :(
19:06:37 <monochrom> No, it's alright, NemesisD.
19:06:54 <monochrom> It is just more general so it takes more effort.
19:07:35 <jackdk> (roughly) in the code I'm working on, we have a Transaction monad. Transaction has no MonadIO instance, and the run function has a type like Transaction a -> App (Either DBError a)
19:07:39 <monochrom> Plus Haskell isn't great with row polymorphism.  (And we use classes to emulate it clumsily.)
19:08:01 <NemesisD> i doubt i'd publish this as a library because i wouldn't want to try to make it really performant. i started on this track when i had some success with using open unions to arbitrarily combine error types in composed ExceptT stacks
19:08:25 <Welkin> jackdk: what is the point of that if your database handles the transaction?
19:08:31 <maerwald> haskell error handling: here you have 2000 options
19:08:34 <Welkin> unless you are ignoring that feature of your database
19:10:01 <NemesisD> so you could have sections of your code that return very specific error types, foo :: m (Either FooError a), bar :: m (Either BarError a), and a way to lift those into Errors (FooError ': BarError ': otherErrors), plus a nice way to have total pattern matching once the errors list becomes concrete
19:10:15 <monochrom> That's still fewer than how many cold/flu relief drugs there are at a typical drug store.
19:10:26 <Solonarv> NemesisD: I found the gist, but I'm fixing up some holes in it first
19:10:34 <Welkin> you mean, email marketing software
19:11:03 <NemesisD> then i thought i could do this with effects until i realized that was a sum type, it must be precisely one of the error types, for effects, i needed a *product* type where it is *all* of the effect dictionary types
19:11:17 <monochrom> Did you know that they almost have every non-empty subset of {cough suppressant, nose decongestant, running nose suppressant, phlem easing, fever suppressant}?
19:11:56 <monochrom> Not to mention the plethora of brands.  And flavours in the syrup cases.
19:12:09 <monochrom> And don't get me even started on toothbrushes.
19:12:11 <NemesisD> and all the flavors just taste like the color they are
19:13:10 <monochrom> Or NVidia graphics chips.
19:13:40 <Welkin> well, there they just increment the number and call it a new product
19:14:02 <monochrom> Oh, I thought they just increment the price and call it a new number! >:)
19:14:12 <Solonarv> NemesisD: https://gist.github.com/Solonarv/328ad45c0674215938d08026a16efe07
19:14:23 <Welkin> that too!
19:14:43 <Solonarv> warning: I have not actually thrown this at a compiler, because my laptop is a shit
19:16:11 <NemesisD> Solonarv: thanks! i'll take a look. i've got about 45 minutes left here before they kick me out
19:16:22 <Solonarv> heh
19:22:25 <dmwit> Do they actually have all those subsets? Or do they just have the complete set advertised in many different ways?
19:23:03 <monochrom> I haven't done chemical tests of them so I won't know for sure.
19:25:38 <monochrom> I believe they cannot add more drugs than they advertise because there would be PR disaster if an unadvertised drug caused someone a high-profile side effect.
19:26:39 <Welkin> you mean death?
19:26:43 <Welkin> like heath ledger
19:26:48 <monochrom> BTW that sentence applies to programmer's kind of "PR" and "side effect" too, and also just s/drug/code/  >:)
19:27:49 <monochrom> I don't know of the circumstance of his death.
19:28:12 <Welkin> mixing sleep pills with flu drugs or something
19:28:23 <monochrom> Arguably death is not the biggest deal. Deformed newborns may be even bigger.
19:28:57 <maerwald> There won't be any newborns after death
19:29:37 <monochrom> Also sometimes high-profileness depends more on media opportunity than severity.
19:35:30 <NemesisD> Solonarv: this is pretty cool! the arity part is kind of rough but there's only so many you'd have to write before you cover your bases. would you use this yourself?
19:36:07 <Solonarv> Hmm, maybe? I'm not too sure what I'd need it for
19:36:20 <dmwit> I don't claim a mismatch between advertised drugs and actual drugs. I claim a mismatch between advertised list of positive effects and exhaustive list of actual effects.
19:36:47 <dmwit> (I also do not claim they avoid listing some known negative effects in tiny print where you must struggle to find and read it.)
19:37:00 <monochrom> :)
19:37:20 <monochrom> But I think you need an actual drug to get an actual effect.
19:38:47 <Solonarv> not true! placebo effect :>
19:39:01 <maerwald> Exactly, you can imagine effects and experience them
19:39:16 <maerwald> Not sure how to encode that on type level though
19:39:55 <dmwit> monochrom: Suppose drug A has effects X, Y, and Z. I market three pills. They all have drug A in them. On one box I say, "good if you have symptoms X and Y". On another I say, "good if you have symptoms Y and Z". Am I lying or unethical?
19:40:40 <dmwit> (What do I put on the third pill box? It is a mystery. Maybe what I put there affects your answer about whether I am ethical. I didn't think far enough ahead before picking the number three.)
19:40:43 <monochrom> You are not lying. I just haven't observed an example in the drug store.
19:41:02 <maerwald> dmwit: you are not lying, but manipulating :>
19:41:03 <NemesisD> i've been led to believe from reddit and other voices in community that everyone is doing all sorts of things to be mart about segregating effects from logic, but i don't know how people are actually doing it
19:41:12 <maerwald> You can manipulate and deceive without lying
19:41:22 <jackdk> dmwit: like this? https://www.abc.net.au/news/2016-04-29/nurofen-maker-fined-$1.7m-misleading-customers/7370022
19:42:00 <monochrom> Economics gives strong incentives for you to market "X and Y and Z all-in-one".  Like, if you don't, I'm going to be your competitor and I'm going to do that.
19:42:12 <maerwald> NemesisD: They segregate it with monad stacks, which in the end have MonadIO inside and break all guarantees xD
19:42:34 <maerwald> Over engineered until the initial motivation is void 
19:43:14 <monochrom> For a concrete example, see acetaminophen. Everyone selling it advertises both of "fever relief" and "pain relief".  No one actually omits either.
19:43:17 <NemesisD> maerwald: you're talking about granular, capability or domain-based stacks, like MonadAWS, MonadFilesystem, etc?
19:44:42 <dmwit> jackdk: I find the arguments (from both sides) in this article very strange. Perhaps they are misrepresented.
19:44:50 <NemesisD> in production code we just basically slap a big ass object with connections, configuration, etc in a ReaderT over IO and that's it
19:44:59 <monochrom> So let me twist it this way: How many dollars are you willing to invest in a packaging of acetaminophen that only advertises "fever relief"? >:)
19:45:28 * hackage status-notifier-item 0.3.0.1 - A wrapper over the StatusNotifierItem/libappindicator dbus specification  http://hackage.haskell.org/package/status-notifier-item-0.3.0.1 (eyevanmalicesun)
19:45:45 <NemesisD> lots of intermixing of effects, very hard to untangle logic from effects in a way that you can test exhaustively without making real network calls and stuff
19:46:07 <maerwald> NemesisD: if logic and effects are not separated then they should not be separated
19:47:25 <Welkin> using mocks is *not* testing the real system
19:47:32 <Welkin> if you are doing that it misses the point
19:47:35 <NemesisD> maerwald: sure, but it isn't always valuable when you're writing tests to be asserting that writing a file to S3 or something works as expected. you may want to have a few integration tests that do, but sometimes you just want to test the logic.
19:47:47 <Welkin> an integration test should be running on the exact same setup as your production system
19:47:56 <NemesisD> i'm not talking about integration tests or not having those
19:48:01 <maerwald> NemesisD: what logic is there in writing a file to S3?
19:48:12 <Welkin> maerwald: make sure it actually works
19:48:22 <Welkin> but there would be a million problems
19:48:29 <Welkin> the network could be slow or time out
19:48:30 <maerwald> Welkin: that's not *program logic*
19:48:33 <NemesisD> maerwald: none. i mean in a large monadic block that has a sequence of effects and logic it has to get through, write some files, write some logs, get something out of redis and do something with it
19:48:44 <Welkin> the file may not be replicated on the instance you connected to
19:48:55 <Welkin> exactly
19:49:01 <Welkin> you can't test everything like that
19:49:17 <monochrom> OK you can counter-twist me this way: You're going to sell water in 3 distinct mutually-exclusive packaging: "fever relief", "cough suppressant", "nausea relief", and you just have to put them in the homeopathy section and you'll win. >:)
19:49:36 <NemesisD> so if i want to write some more exhaustive tests that says "if the service returns A, B, C, and D should happen, if the service returns E.."
19:49:50 <maerwald> NemesisD: not sure there is much usefulness in making tests more granular, except for debugging purposes
19:50:03 <Welkin> I don't even write tests
19:50:15 <maerwald> I see that thing as a procedure
19:50:22 <maerwald> You test the procedure and it may have multiple failures
19:50:25 <Welkin> I probably should, but the type system handles most issues for me already, or the bugs that happen are showstoppers and I find them the moment I run the program
19:51:07 <NemesisD> maerwald: do you advocate testing your procedure with a full stack of integration services at all times?
19:51:14 <dmwit> monochrom: I also think you make a pretty strong assumption. If I see a box that lists exactly my symptoms, I might prefer it to one that lists additional symptoms on the grounds that perhaps fewer positive effects is correlated with fewer negative effects.
19:51:34 <maerwald> NemesisD: why not?
19:51:45 <maerwald> That's what actually runs in production
19:52:00 <maerwald> You're not executing only parts of it. That has only debugging advantages
19:52:02 <dmwit> monochrom: Or say another way. Say you see a box that promises to cure the common cold, AIDS, and hep-B. Do you pick it up instead of the one that's just for the cold?
19:52:14 <NemesisD> like when its possible if there's some hairy logic, you can extract the function that takes all inputs and returns a pure output and test it, but in production systems these tend to be spread out over a bunch of imperative code so testing them in full isolation may be too granular
19:52:38 <Welkin> NemesisD: that is when you switch to an actor model
19:52:42 <maerwald> Don't change your code to make it more "testable" imo, that causes weird design decisions
19:52:44 <monochrom> I didn't make that assumption. I actually visited drug stores.
19:53:05 <maerwald> Design decisions should be purely about things that make sense, you worry afterwards about how to test it
19:53:14 <dmwit> monochrom: cheater
19:54:02 <monochrom> I am going to be a bad surveyee because I actually know current scientific progress and I already know that we don't have the particular drug you described.  So if I saw one I would call it a scam.  But FDA would be way ahead of me.
19:54:06 <maerwald> There are a bazillion testing methods, you just pick the one that works best then
19:54:43 <NemesisD> i don't agree with not changing the code at all for testability. it has served me well in some scenarios. for example injecting a clock into a function i want to test
19:55:31 <dmwit> monochrom: I bet you could also invent a cocktail you wouldn't want to buy that fixed more things than ibuprofen does.
19:55:48 <Welkin> emergen-C make boatloads of money
19:55:50 <Welkin> it does nothing
19:55:58 <Welkin> it's a fizzy drink with some vitamin c in it
19:56:02 <Welkin> they admit it does nothing
19:56:13 <Welkin> the people who use it know it does nothing (at least some of them do)
19:56:19 <Welkin> but the placebo effect is strong
19:56:29 <Welkin> or no
19:56:32 <Welkin> it was airborne
19:56:36 <Welkin> same thing, different brand
19:57:27 <Welkin> techincally, it may help improve your immune response because of the effects of vitamin C, but it won't stop you from getting sick
19:57:28 * hackage taffybar 3.1.0 - A desktop bar similar to xmobar, but with more GUI  http://hackage.haskell.org/package/taffybar-3.1.0 (eyevanmalicesun)
19:57:38 <Welkin> vitamin C is a mild anti-histamine too
19:57:42 <monochrom> I actually did and will still do.  Every time I have any non-empty subset of flu symptom I just buy the all-in-one cocktail.
19:58:06 <monochrom> In fact I am taking it right now. Next pill is actually just half an hour away.
20:00:13 <monochrom> My consideration is that the price difference is non-existence. Plus I worry (unnecessarily) that if I don't need to finish the whole box I want to save it for the next time.  So if I buy an overfitting drug now it will be a waste next time.
20:01:18 <monochrom> I said that almost all non-empty subsets are on the shelf, but lately the full set is gaining an upper end.
20:01:28 <monochrom> err, s/upper end/upper hand/
20:01:45 <monochrom> Some subsets are disappearing.
20:02:50 <Welkin> the empty set is always there
20:03:01 <monochrom> Not exactly ibuprofen though. Never have had that.
20:03:30 <monochrom> Ah but they won't let me go through a transaction at the cashier for that
20:04:52 <monochrom> Err I guess the homeopathy section is full of that. Nevermind!
20:05:12 <monochrom> Damn I keep forgetting the bloody homeopathy section.
20:05:57 <monochrom> Adam Smith should come take a look and get a good laugh or something.
20:13:25 <monochrom> Ah I should have used the homeopathy section to my advantage.  Next time someone complains about too many ways of error handling, remind me to reply "that's still fewer than how many different ways homeopathy sells you water". >:)
20:13:57 * hackage net-mqtt 0.2.0.0 - An MQTT Protocol Implementation.  http://hackage.haskell.org/package/net-mqtt-0.2.0.0 (dustin)
20:32:27 <oscarcito> tsunami now 10/01/2019 in live: http://festyy.com/wVzrCn
20:33:00 <Welkin> who writes dates like that?
20:33:22 <monochrom> I do.
20:33:43 <Welkin> it's either (year, month, day) in international form, or (month, day, year) american form
20:33:56 <Welkin> to me that looks like october 1st
20:34:02 <monochrom> Or (day, month, year) in British form.
20:34:07 <jackdk> iso 8601 all the way
20:34:42 <Welkin> at least the spammer brought up a topic for discussion
20:34:49 <monochrom> And yeah sure you get to say British form should be deprecated in favour of international form.
20:35:34 <monochrom> But I also equally get to say your inches and feet you be deprecated in favour of metres. And it is spelled metres. That's international.
20:36:03 <monochrom> Like, even Britain gave up inches and feet (and being imperial).
20:36:37 <monochrom> So fix your measurement units before you tell me to fix my date.
20:43:50 <dmwit> Britain still uses miles.
20:44:04 <c_wraith> and gallons, and pints.
20:44:06 <dmwit> But also I use meters and Celsius and I am American.
20:44:11 <c_wraith> But a different pint than americans.
20:44:14 <dmwit> So I have fixed my measurements, now please fix your dates.
20:44:36 <monochrom> No, you spell metres and I fix my dates.
20:45:33 <dmwit> "meters"/"metres" mean the same thing. "01/10/2019"/"10/01/2019" don't mean the same thing.
20:45:35 <monochrom> (Actually I quit "a/b/c" long ago. I just write "January 9, 2019".)
20:51:01 <DigitalKiwi> the british can't even figure out brexit i don't care about their opinion on measurements or dates
20:51:31 <monochrom> haha OK!
20:51:48 <DigitalKiwi> :P
20:52:11 <monochrom> Meanwhile has your congress resolved its funding issues?!
20:53:04 <glguy> when did DigitalKiwi move?
20:53:22 <glguy> also let's not do politics even the making fun kind
20:53:31 <dmwit> If we fund Brexit, will you build a wall between you and the EU?
20:53:39 <DigitalKiwi> us is the new germany
20:53:54 <dmwit> ...yeah, okay. That's probably good advice.
20:54:08 <DigitalKiwi> dmwit: is the atlantic not impassable enough?
20:54:26 <dmwit> I don't think the Atlantic lies between Britain and the EU.
20:54:56 <dmwit> Geography *was* my worst subject in school, so I guess I could be wrong.
20:55:08 <glguy> I heard they moved it
20:55:09 <DigitalKiwi> but it is between the US and EU
20:55:47 <dmwit> I would be impressed indeed if the US managed to Brexit.
20:56:13 <DigitalKiwi> didn't the US have its own brexit a few hundred years ago
20:56:20 <dmwit> ^_^
20:58:28 <monochrom> I have a cunning plan. Build a wall in the Mariana Trench. This wall unifies, not divides, two sides!
20:59:18 <DigitalKiwi> and back to geography technically the north sea is between britain and the uk and it's difference between the atlantic ocean is merely semantics
20:59:30 <DigitalKiwi> er,, EU
20:59:34 <DigitalKiwi> UK and EU
20:59:53 <DigitalKiwi> whatever it's complicated enough that all of those statements are true :|
21:00:00 <glguy> Anyway, back to Haskell
21:00:37 <DigitalKiwi> i'm still wondering when i allegedly moved from where to where
21:22:40 <coldpress> i'm going through Stephen's Arrow tutorial https://en.wikibooks.org/wiki/Haskell/Arrow_tutorial, how does `proc` know that only one `n` should be accumulated for every `value`? https://pastebin.com/2pjQUMcs
21:23:00 <coldpress> *only one `1`
21:25:44 <jle`> coldpress: remember you're defining a Circuit
21:25:55 <jle`> you're defining one in terms of a composition of two other circuits
21:26:28 <jle`> proc is closer to ApplicativeDo than normal Monad do
21:26:49 <coldpress> but in this case the compiler is inferring the composition operators right? how do we know that the compiler correctly infers (&&&)?
21:27:01 <jle`> what else would it infer?
21:27:13 <jle`> (my point is that the actual underlying implementation doesn't matter)
21:28:11 <jle`> proc notation is also a "parallel" sort of thing
21:28:39 <jle`> each `y <- a -< x` is run "in parallel" of all of the others
21:29:16 <jle`> "in parallel" here as a dataflow context, not in an effectful context
21:30:40 <coldpress> oh, so each line of proc is an implied (&&&), right?
21:31:10 <jle`> it's actually kind of more like ***
21:31:24 <jle`> but the two are 'equivalent' anyway
21:31:42 <jle`> it's like (total *** total) (value, 1), to abuse some syntax
21:32:35 <jle`> in the end, basically, it's (a1 *** a2 *** a3 *** a4 ...) (x1, x2, x3, x4 ...) kind of thing
21:33:06 <jle`> assuming `y1 <- a1 -< x1; y2 <- a2 -< x2; y3 <- a3 -< x3 ...` etc.
21:38:10 <coldpress> I see, thanks!
21:41:51 <jle`> np!
21:45:15 <jle`> coldpress: note that ApplicativeDo is also "parallel dataflow", so the two have a lot in common
21:45:30 <jle`> which is fitting, since Applicative is the abstraction that more or less replaced Arrow
21:49:58 * hackage hpython 0.2 - Python language tools  http://hackage.haskell.org/package/hpython-0.2 (qfpl)
22:02:58 * hackage net-mqtt 0.2.1.0 - An MQTT Protocol Implementation.  http://hackage.haskell.org/package/net-mqtt-0.2.1.0 (dustin)
22:22:21 <concaveirc> test
22:22:24 <concaveirc> test
22:22:53 <jackdk> test received
22:26:31 <concaveirc> Thanks
22:31:57 <monochrom> This reminds me of: "Do you want to hear a joke about TCP/IP?"  >:)
23:18:22 <glguy> Connection refused
