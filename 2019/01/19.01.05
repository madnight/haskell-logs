00:00:15 * Lycurgus intends to use hs basically just for middleware
00:00:42 <jle`> using Haskell, you get to choose between the whole spectrum of unsafety and safety
00:00:47 <jle`> using C++, you are restricted to the unsafety part of the spectrum
00:01:24 <Lycurgus> you seem to be conflating c and c++
00:01:33 <sternmull> you have to learn a bunch of pitfalls, but then you can stay almost as safe with C++ as with haskell.
00:01:44 <jle`> Lycurgus: fine, C is the "even more narrow part of the spectrum" :P
00:01:54 <jle`> when you're used to Haskell, the variation in C and C++ seem insignificant
00:01:55 <Lycurgus> :)
00:01:57 <jle`> in terms of safety
00:01:57 --- mode: glguy set +v asdfasdfasdfasdf
00:02:31 <jle`> it's like [0,100] vs. [0,1] vs [0,0.5]
00:02:43 <sternmull> i also saw a bunch of thread-safety issues in Haskell. There are thing you just shouldn't do (modifying IORef from two threads is one i think)
00:02:46 <Lycurgus> is glguy just a bot now?
00:03:17 <jle`> you can still access 0, 0.5 in Haskell
00:03:18 <sternmull> And all the exception-crazyness in haskell. So there are dark places too.
00:03:21 <monochrom> Ah but atomicModifyIORef from two threads is fine.
00:03:36 <nyc> C and various architectures' assembly were my bread and butter languages.
00:03:56 <sternmull> monochrom: Yes, but you have to know the pitfalls. Just like in C++.
00:04:18 <jle`> haskell excells in refactorability and maintainability
00:04:30 <jle`> you can easily pick up a year-old project and refactor it without any fear
00:04:38 <jle`> all because of the type system. and purity helps too
00:04:51 <jle`> if i want anything to last any amount of time, i'd pick haskell
00:05:16 <jle`> good luck refactoring a large C++ project of any decent size
00:05:37 <nyc> Mostly I used Haskell for things like processing logs of debug output.
00:06:25 <unsymbol> i agree refactoring is where haskell excels
00:06:43 <monochrom> I am wondering if we are thinking of the same pitfalls.
00:06:56 <nyc> It's nice to have different languages for different things.
00:07:05 <unsymbol> tho i wish more of it was automated
00:08:09 <sternmull> Every language can be used to write bad code. But yes, i believe that Haskell has some features to write good code. But on the other hand in C/C++ you can also write clean code and will have very good debuggers to investigate if something goes wrong.
00:08:44 <jle`> there is no easy way you can have the same assurances in C++ that you'd have in Haskell
00:08:59 <nyc> I don't know if it's really all that much. Things like mutually recursive modules bedevil ghc authors etc.
00:09:51 <petercommand> what's the problem with mutually recursive modules?
00:10:33 <nyc> There are different kinds of guarantees. C is close to certain kinds of assembly etc.
00:10:48 <jle`> i guess my original point is that haskell is in no way a niche language; it's a general purpose language, and the type safety benefits apply in many, many general situations
00:11:07 <jle`> it's not just useful when 'you need purity'; in fact most of the "killer apps" of haskell don't involve purity
00:11:17 <nyc> petercommand: It seems to be a difficult refactoring task.
00:11:54 <jle`> the benefits of maintainability, refactoring, type-directed development, selective type safety, etc. are useful across-the-board
00:12:07 <jle`> the only time they aren't too useful is when you want to write a quick one-off script that you never expect to use again
00:12:26 <jle`> but even in that case it might be useful because the compiler and type inference can helkp you write it quicker
00:12:57 <nyc> jle`: I found it useful for that in particular myself.
00:13:50 <sternmull> i personally don't think that typesafety makes scripting in haskell problematic. Its more the 20 Lines of imports and extensions that are needed for even simple tasks. And the fact that stack script needs way to long to start up.
00:14:37 <monochrom> With C++ STL I need 20 #include's instead.
00:14:42 <jle`> right, i didn't say it is problematic, just that there might be less benefit in one-off scripting than in building larger applications
00:14:43 <sternmull> i am happy if the compiler says me t hat i messed up before i run my "script". And with typeinference most explicit types go away.
00:14:57 <nyc> jle`: Mostly it was that being "mathy" suited a lot of the statistics I was collecting.
00:15:35 <sternmull> monochrom: I don't say C++ is good for scripting. I am more thinking about Python vs. Haskell for scrpting.
00:16:23 <monochrom> Oh I didn't receive the memo that says we now talk about scripting.
00:16:38 <sternmull> jle`: Yes, of course. For larger programs i think type safety is very important. At least for maintainability.
00:17:17 <nyc> monochrom: I used Haskell for scripting anyway.
00:18:02 <monochrom> Yeah my gearbox progression is shell script first then Haskell if necessary.
00:19:21 <jle`> i don't feel comfortable using haskell for all my scripting, but for some reason all of my scripts recently have been haskell ... just by coincidence ... heh
00:19:30 <jle`> *i didn't think i felt comfortable
00:20:31 <nyc> I'll use other things in various situations, but a lot of things I scripted were mathy and I used Haskell for those cases.
00:21:14 <monochrom> An exception system is infinitely better than unix's signal and its analogue in shell scripts, "traps".  This is true of all languages that have exception systems.  Despite all you blackmouth about exceptions.
00:22:50 <sternmull> maybe. But i find exceptions in haskell more complex than in C++ and other languages. Exceptions during lazy evaluation, asynchronous exceptions, masking, ... oh man. So much to know, so much to do wrong.
00:23:24 <monochrom> And so if I am writing a shell script but it grows to look like I need to add "create tmp dir, work in it ... on success or failure, delete the tmp dir" it becomes a strong incentive to switch over to Haskell (or Java or C++ or SML or Scheme or Python or whatever).
00:24:11 <monochrom> Oh no one advocates exceptions during lazy evaluation.
00:24:34 <nyc> UNIX does have warts in that area. And tty's. And ioctl. And async IO. And so on.
00:24:56 <sternmull> but you have to think about it and the typesystem does not help you to detect potential exceptions in lazyness
00:25:08 <monochrom> On the complaint of "so much to know" C++ STL is so much more to know just to do basic functional programming.
00:26:02 <monochrom> Anyway I don't find Haskell exceptions all that confusing. Even under concurrency and async.
00:26:04 <pie_> can anyone recommend a dense but clear typeclass tutorial?
00:26:16 <koz_> pie_: What do you mean by a 
00:26:20 <koz_> typeclass tutorial?
00:26:51 <pie_> basics of typeclasses, I think I understand them but I probably dont.
00:26:52 <sternmull> monochrom: I don't think many use STL with a functional style. But you can learn about std::vector, std::shared_ptr and so on and then use ordinary control structures (loops and so on) to write your program.
00:27:29 <monochrom> I don't want to use ordinary control structures. I want to just write "map f xs" or "mapM_ print xs".
00:27:41 <koz_> sternmull: I find it interesting that you choose the word 'ordinary' to describe control structures such as loops, which often completely obscure what you want done.
00:27:47 <koz_> And are typically less expressive.
00:27:55 <koz_> Do I smell a certain bias? :P
00:28:19 <butterthebuddha> I have a type A that I have prisms for and a value of type Either Text A
00:28:45 <sternmull> pie_: https://en.wikibooks.org/wiki/Haskell/Classes_and_types to learn what a typeclass is and https://wiki.haskell.org/Typeclassopedia is nice to learn about the most important typeclasses.
00:28:51 <butterthebuddha> If I map preview over the Either, then I get an value of type "Either Text (Maybe B)"
00:29:10 <monochrom> I am tired of writing a for loop over an iterator, and I am tired of adding another #include and handwriting a constructor syntax just to emulate passing a function as a parameter.
00:29:12 <butterthebuddha> Is there a way to get prisms to work nicely with values wrapped in Either and avoid that? (WIthout having to write my own helpers for dealing with that?)
00:29:28 <jle`> butterthebuddha: what are you trying to do, instad?
00:29:30 <jle`> *instead
00:29:36 <koz_> monochrom: I think C++'s total absence of algebraic data types also makes a bunch of things totally harder than they need to be.
00:29:40 <jle`> what do you want, instead of Either Text (Maybe b) ?
00:29:47 <jle`> Either (Maybe b) Text?
00:29:53 <butterthebuddha> Well I just want a Either Text b
00:30:02 <jle`> what do you want to happen if there is Nothing ?
00:30:02 <koz_> I _shock and amaze_ people with the ability to write ASTs in something like ten lines without resorting to awful things like visitors or whatever that would be demanded by other languages.
00:30:05 <pie_> sternmull, thanks, looks like a start at least. The typeclassopedia isnt what im looking for. my problem is probably with syntax and the concepts of typeclasses in general
00:30:16 <butterthebuddha> Return a Left wrapping a value I provide
00:30:42 <monochrom> This is why I didn't attack C++ from the type angle, I attacked from the cumbersome angle.
00:31:03 <jle`> butterthebuddha: instead of fmapping preview, you should (>>=) preview
00:31:34 <jle`> fmap :: (a -> b) -> Either e a -> Either e b
00:31:41 <jle`> (=<<) :: (a -> Either e b) -> Either e a -> Either e b
00:31:46 <monochrom> C++ is of course very type-safe. In fact it is more dependently typed than Haskell because you can have a template of a numeric parameter.
00:32:02 <sternmull> koz_: The advantages of the "ordinary" (konwn from imperative languages) control structures is that you only need to learn about very few and then can write any program you want. For Haskell you have to learn many concepts (typeclassopedia) before you can really start to use the language.
00:32:05 <pie_> "Do not disturb my ADTs! - Archimedes"
00:32:44 <koz_> sternmull: I don't really agree with this statement at all. Yes, if you only want to do simple things, maybe. I also do not see how you draw an equivalence between the Typeclassopedia and loops.
00:33:00 <koz_> Plus, C++ has a whole _pile_ of weirdnesses you have to learn as well.
00:33:09 <pie_> sternmull, i feel like im running into the "need to learn a lot of things". but maybe thats because im trying to do things nicely
00:33:32 <pie_> or i just happened to pick a bad problem
00:33:45 <nyc> The Haskell wikibook's advanced track looks very helpful for me.
00:34:16 <monochrom> I am not sure why you compare control structures to typeclassopedia.
00:34:25 <sternmull> koz_: You have to understand things like sequence if you want to run a list of IO effects. In an imperative languages i can just use a loop and execute them.
00:34:49 <monochrom> Control structures are to be compared to either recursion or map, foldr, foldl... depending on your ideology.
00:34:52 <koz_> sternmull: Sure, at the cost of _incredible_ dishonesty in your type system.
00:34:58 <jle`> you don't need to understand the general form of sequence, you just need to understand what sequence does for IO
00:35:03 <koz_> And an incredible class of bugs.
00:35:04 <nyc> C is lazy language design. They just make behavior undefined whenever there's a significant question.
00:35:06 <koz_> Plus, what jle` said.
00:35:12 <koz_> nyc: Or better, implementation-defined.
00:35:23 <koz_> Has anyone here _tried_ reading the GCC manual? It's impossibly huge.
00:35:27 <jle`> nyc: also, you don't need to use sequence to execute all IO effects in a list ... you can just pattern match explicitly
00:35:54 <monochrom> At most you can complain about C++'s 3 loop kinds vs Haskell Data.List's plethoria of foldr foldl map replicate unfoldr etc.
00:36:06 <pie_> nyc, heh
00:37:04 <sternmull> pie_, nyc: I like the wikibook very much. I think together with some other references articles etc. it is a very effective way to get into haskell.
00:37:15 <koz_> On that, sternmull and I are in agreement.
00:37:58 <monochrom> If you want to compare I/O systems instead, C++'s iostream system is not exactly pedestrian either.
00:38:13 <koz_> It's also verbose beyond all reason.
00:39:01 <sternmull> The thing about "no control structures in Haskell" is that you have them in any imperative language and have to learn a lot of stuff before you can live painlessly without them in haskell.
00:39:23 <koz_> sternmull: Yes, almost every language blindly copies C.
00:39:30 <nshepperd> the c++ stl seems to go out of its way to make functional programming annoying
00:39:40 <koz_> Whether this is right, or good, or worthwhile is not a question anyone seems to ever ask.
00:40:03 <monochrom> No I think you have confused learning with unlearning. I claim that recursion is more natural.
00:40:04 <nyc> monochrom: A lot of people I've seen just use C stdio in C++.
00:40:24 <koz_> I agree with monochrom. It also ties nicely in with induction proofs in many cases.
00:40:32 <koz_> This is what I mean about Haskell being honest.
00:40:43 <nshepperd> you can't just turn a list into a set by passing the list to some function. no, you've got to use .begin() and .end() iterators
00:40:46 <koz_> I don't have to bend my understanding of something in terms of mathematics to fit the language's desire to emulate C.
00:40:56 <koz_> nshepperd: Being careful not to invalidate them.
00:41:41 <sternmull> monochrom: I am not so sure about that. The funny thing is that even with immutability and recursive algorithms the people keep to talk about "accumulator" and similar stuff... is if it would be a thing that changes... even if it can't change.
00:42:56 <nyc> koz_: Hmm? C is only really followed by a certain class of languages. ML and Prolog are the archetypes for functional and logic languages, and things like Fortran and Algol have been widely influential.
00:43:19 <c_wraith> in many ways Algol was a parent to C
00:43:29 <c_wraith> Insofar as it ever even existed.
00:43:41 <koz_> nyc: All the popular ones seem to blindly emulate it.
00:44:01 <koz_> I agree that there are alternatives out there though, you're right. I should have made that more clear.
00:44:40 <nyc> koz_; I may be too far out of touch to know what's popular.
00:46:53 * hackage futhark 0.8.1 - An optimising compiler for a functional, array-oriented language.  http://hackage.haskell.org/package/futhark-0.8.1 (TroelsHenriksen)
00:47:27 <monochrom> The "change" story is useful for beginners who have not completely unlearned imperative programming.  I would totally tell that to them.  I already did.
00:48:13 <monochrom> But to clean-slate kids I would just tell recursion and induction proofs on their own standing.
00:49:13 <monochrom> Hell I would not even mention "immutable, no change".  Why would I need to?  They already know it implicit from math.  If f(5)=6 the first time the f(5)=6 is still true the 10th time.
00:50:15 <monochrom> Clean-slate kids never imagined "5+1 means erase the 5 and write 6 in its place".  Only sick minds like Turing would think that up!
00:51:09 <sternmull> I understand that functional programming can be natural for people with no programming background or with a math background. But imperative programming is not really unnatural. In the end its what the hardware does. So people that hear a little bit about how CPUs work will start to think in an imperative style.
00:52:21 <sternmull> And in the real world we also plan sequences of our actions instead of evaluating recursively.
00:53:28 <koz_> sternmull: At the end of the day, everythng is done by moving electrons around. Anyone with a background in physics will immediately start thinking of computing that way.
00:53:41 <koz_> And in reality, electrons don't really exist anywhere - they're just _probably_ somewhere.
00:54:01 <koz_> (badly paraphrased from something Conal Elliot wrote that I cannot call up at this time)
00:54:26 <monochrom> It is not instead.  We make big plans divide-and-conquerly, and only by the time we have broken it down to small enough plans do we start planning sequentially.
00:54:40 <monochrom> Note that divide-and-conquer is a generalization of recursion.
00:55:26 <sternmull> koz_: Sure, everything we are thinking about is some kind of abstraction. But some abstractions and concepts are more natural than others.
00:55:42 <monochrom> If I have 100 large bookshelves and I need to find a book exhaustively (because I neglected to put them in a nice order earlier), I do not plan "for i=1 to 10 ...".  No one does.
00:56:01 <koz_> sternmull: Your assumption that imperative is somehow more 'natural' is one I take great issue with. Just because it's dogma to teach programming that way doesn't mean it's necessarily the best way, or the most useful way.
00:56:16 <koz_> If it's more natural _to you_, whatever, your deal. Don't generalize off a personal anecdote.
00:56:40 <sternmull> monochrom: I think most people just iterate over all the books. And using some kind of mental counter/iterator seems quite natural to me.
00:56:44 <monochrom> Instead I plan to hire 100 helpers so 1 helper can search 1 bookshelf.  Consider this one level of recursion.
00:56:55 <koz_> I also don't think 'naturality' or 'intuitiveness' is a good principle to base decisions on.
00:57:23 <c_wraith> Heck, the real world even seems like it doesn't have mutation, so long as you consider time to be part of the real world.  No one has ever edited something when time is considered, as far as I know.
00:57:29 <monochrom> Now each helper just has 1 small bookshelf to worry about. At this level you do have a for-loop.
00:57:54 <nyc> The von Neumann machine design postdated plugboard programming, i.e. dataflow.
00:57:58 <hololeap> if i think about walking to the park, i think "put shoes on, get hat, leave house, start walking, etc.", not "move left arm 40 degrees, place left foot forward, etc."  not that the latter way is wrong, it's just that i am better able to think about a smaller number of chunks
00:59:24 <nyc> And really, all the modern-day CPU's are the outputs of silicon compilers.
01:00:12 <jle`> when i teach Intro to Programming, i gave a list of things students should describe how to do, after telling them about imperative vs. declarative paradigms
01:00:19 <jle`> and i told them to pick the best one for each job
01:00:45 <jle`> for almost all of them (besides the 'obvious' ones), there was no real clear consensus about which way was more 'natural' or the best choice for each problem
01:00:54 <sternmull> I know i am spoiled by many years of imperative programming (and if find it fun to learn functional programming, its just hard for me). But i also saw people starting programming. And it is really difficult for them to understand recursive functions (and i remember it was to me too). Thats a strong hint to me that recursion is not natural. Learning how a sequence of steps is executed conditionally is much more simpler.
01:01:10 <koz_> sternmull: Or perhaps mathematics is just awfully taught?
01:01:19 <jle`> in any case, functional programming discourages explicit recursion anyway ;)
01:01:50 <monochrom> Yes recursion must be taught along with induction proof.  There is no other way.
01:02:05 <hololeap> "pull a bean out a the bag, repeat until the bag is empty" ... bingo, recursive function that anyone can understand
01:02:19 <monochrom> If you tell them "hand-execute the recursion" you have already lost.
01:02:58 <monochrom> Unfortunately that's what 99% of the teachers tell. "hand-execute the recursion".
01:03:42 <nyc> I usually break declarative down into logic, functional, dataflow, and string.
01:04:03 <mniip> monochrom, recursion is the same thing as induction
01:04:08 <mniip> just in different universes
01:05:02 <monochrom> You can now raise the point that "ah but induction proof is also a disaster in real world schools".
01:05:05 <mniip> also this probably has no relation to the current discussion
01:05:14 <monochrom> Ah but I also have an explanation and solution for that.
01:05:20 <mniip> but yeah, the problem with induction is that everyone only knows the N version of that
01:05:36 <monochrom> No, they screw up even the N version.
01:05:36 <mniip> as opposed to arbitrary inductive types
01:05:39 <mniip> oh?
01:05:42 <mniip> what do you mean
01:06:46 <monochrom> Recall that if you write it down carefully the induction step is "forall n. if p(n) then p(n+1)", not "if (forall n. p(n)) then (forall n. p(n+1))"?
01:07:12 <monochrom> But no teacher writes it down carefully.  They are too afraid to teach explicit foralls and scoping.
01:08:13 <c_wraith> given my experience in discrete math courses, I actually think most teachers don't know those things
01:08:22 <monochrom> Now also recall that one year (say) before they teach induction proofs, they taught proofs of identities, during which they so emphasized that "in x+y=y+x, we mean for all x and for all y"?
01:09:01 <nyc> Complete induction and such are floating around, too.
01:09:21 <monochrom> OK so during the induction lesson they just say "if p(n) then p(n+1)".  In which p(n) and p(n+1) are identifies (or soon-to-be-proved identities).
01:10:00 <monochrom> So now the students think the teacher means "if (forall n. ...) then (forall n. ...)".  And they wonder why are we doing this circular logic.
01:11:32 <jackdk_> oh yeah I remember being confused like that, but I also remember the teacher mentioning that because P(1) you have P(2) and because you have P(2) you have P(3) and so on, and seeing the chain cascade off into infinity
01:18:25 <nyc> Well, it's more like that any minimum m for which it would fail would be contradicted by it holding for predecessors.
01:20:52 * hackage tfp 1.0.1 - Type-level integers, booleans, lists using type families  http://hackage.haskell.org/package/tfp-1.0.1 (HenningThielemann)
01:23:46 <nyc> Structural induction is worthwhile to cover beyond induction on natural numbers, of course.
01:25:51 <nyc> Induction on the structure of proofs is particularly enlightening.
01:29:23 <pony> where can one read about all that?
01:30:53 <nyc> I remember there being good sections on it Foundations for Programming Languages by Mitchell.
01:36:23 * hackage recursion 2.2.1.0 - A recursion schemes library for GHC.  http://hackage.haskell.org/package/recursion-2.2.1.0 (vmchale)
01:40:51 <pdxleif> With the cabal new-* commands, can I point at some local directories to say my project depends on my own local fork of some libs?
01:41:34 <pdxleif> Amazonka requires a number of patches to be useful to me, so till now I've been cabal-installing my own local fork into $HOME/.cabal.
01:46:34 <cocreature> pdxleif: just add the directory to "packages"
03:02:28 --- mode: glguy set +v kakadu
03:02:47 <kakadu> I'm trying to play with non-regular data type and open recursion. I have issues with tying the knot. Are there any chances to success for me? https://paste.in.ua/3744/#43
03:03:01 --- mode: glguy set -v kakadu
03:16:39 --- mode: glguy set +v Donald90
03:18:23 * hackage massiv-io 0.1.5.0 - Import/export of Image files into massiv Arrays  http://hackage.haskell.org/package/massiv-io-0.1.5.0 (lehins)
03:21:23 * hackage comfort-array 0.2 - Arrays where the index type is a function of the shape type  http://hackage.haskell.org/package/comfort-array-0.2 (HenningThielemann)
03:30:00 <HenryCH> im going through guides and i've not yet seen an example where functions appear in the evaluation order, do people always just compose beforehand? seems cumbersome to always have to compose though
03:30:24 <merijn> HenryCH: Do you have an example of what you mean?
03:30:26 <nyc> kakadu: I can't tell what your code is trying to do from looking at it.
03:31:14 <HenryCH> e.g. i see f $ g $ x, is there a way to write something like x piped to g piped to f?
03:31:41 <merijn> HenryCH: Eh, that's what that is?
03:32:09 <HenryCH> yes but the functions appear in the opposite order
03:32:28 <merijn> HenryCH: oh, that
03:32:34 <merijn> :t (&)
03:32:35 <lambdabot> a -> (a -> b) -> b
03:32:46 <merijn> That's $, but reversed
03:33:26 <merijn> @check \f g x -> (x & g & f) == (f $ g $ x)
03:33:28 <lambdabot>  error:
03:33:29 <lambdabot>  • No instance for (Typeable a0) arising from a use of ‘myquickcheck’ • In th...
03:33:33 <merijn> bah
03:34:44 <HenryCH> so why would you want to use $ instead of &?
03:35:00 <merijn> Honestly, I wouldn't use either, but (.) instead :p
03:36:12 <HenryCH> using (.) wouldn't you often have to name the composed function to something very specific?
03:36:25 <merijn> HenryCH: Basically there's two, mostly historical reasons: 1) historically mathematicians have written the composition "f(g(x))" as "(f.g) x" for ages, Haskell's (.) follows that logic, and ($) follows (.)
03:36:48 <merijn> HenryCH: 2) (&) is a fairly recent addition to the standard library introduced via edwardk's work on lens
03:37:44 <merijn> (&) was only added to base in 2015, so since most people learned Haskell before that time, most people are used to . and $ :)
03:37:55 <HenryCH> i see
03:38:21 <merijn> HenryCH: I would normally write "f $ g $ x" as "f . g $ x" (the final $ avoiding the need to "name" the composition as you point out)
03:39:02 <HenryCH> wouldn't it have to be g . f?
03:39:17 <HenryCH> i didn't know that worked though
03:39:53 <merijn> HenryCH: There's an objective reason for preferring (.) to ($) and (&), which is: Given an arbitrarily long composition "f . g . h . i . j $ x" any arbitrary part of the composition can be lifted out and put in a local binding (via where/let) and everything still typechecks. If you do the same with $ and & it stops typechecking (because both of those work on "value and a function" rather than two functions
03:40:20 <merijn> So if/when you start writing long compositions that you plan to refactor later, (.) is easier to refactor.
03:40:22 <dminuoso> HenryCH: I have an alternative preference: *parens*
03:40:40 <merijn> HenryCH: "f . g = \x -> f (g x)"
03:40:45 <nyc> And I thought Haskell 98 was a hassle.
03:40:48 <dminuoso> HenryCH: And using more bindings. Ive come to the conclusion that long composition chains tend to be hard to read.
03:41:00 <merijn> HenryCH: So "f . g $ x" is "f (g x)"
03:41:22 <merijn> dminuoso: But parentheses are *also* hard to factor out :p
03:41:37 <dminuoso> merijn: If you use many bindings, it's a non-issue.
03:41:38 <merijn> dminuoso: That's why you refactor chunks of the composition into named bindings :)
03:41:50 <dminuoso> Heh. :)
03:41:56 <merijn> dminuoso: I *write* lots of long compositions, but I don't *keep* them
03:42:34 <merijn> dminuoso: If only because my "hard wrap at 80 columns" style naturally limits how long my compositions can be :p
03:43:02 <dminuoso> merijn: I find hard wrap at 80 col to be really useful for exactly the same reason.
03:43:36 <HenryCH> is there a composition operator that works in the opposite direction?
03:43:40 <dminuoso> I mean there's some odd exceptions, but forcing yourself to writing small things seems to be one of the best ways to write readable code.
03:43:52 <dminuoso> HenryCH: Yes. >>> but it's not very commonly used
03:44:00 <nyc> Oh, I only put one element of the pipeline on a line.
03:44:03 <HenryCH> why not?
03:44:34 <merijn> HenryCH: Longer than (.), requires an import, and the "reversed thinking" doesn't take very long to get used too
03:44:34 <dminuoso> HenryCH: Because (.) is in the same order that functions are applied in and because it's an already established convention I guess.
03:44:40 <HenryCH> if i want to do g on x, and then f on the result, isn't g >>> f $ x more readable than both (.) and $?
03:45:07 <merijn> HenryCH: I don't think so, because I have decades of familiarity with (.) :)
03:45:18 <dminuoso> HenryCH: I don't use ($) much at all.
03:45:29 <merijn> HenryCH: But yes, there is no real "hard" reason why your suggestion wouldn't work
03:46:09 <merijn> HenryCH: There's mostly a bunch of soft/cultural reasons why the current approach is more common. And since most code by others follows that style, most people just learn to adapt
03:46:30 <merijn> HenryCH: I know that, for example, F# has |> which is very often used, which does compose the way you suggest
03:47:06 <dminuoso> HenryCH: The readability part is just a way how you form your mindset. Like merijn has suggested, you get used to the "reversed" order very quickly.
03:47:13 <HenryCH> right, |> pipes so it's &, but it also has >> and << for composition
03:47:20 <dminuoso> It took me perhaps a week until it sank really deeply in.
03:47:39 <kakadu> nyc: https://paste.in.ua/3745/ I added some comments. Maybe it will be mor eunderstandable
03:47:45 <HenryCH> right that makes sense, im still in the left to right mindset
03:48:24 <Rembane> And after a while even arrow style becomes readable. 
03:48:34 <dminuoso> HenryCH: Also there's a conceptual advantage of the "reverse" (if you think about it, neither order is really the *right* one - it's just convention) order of (.)
03:49:13 <dminuoso> HenryCH: It's that when you read code from left-to-right, you get to see the most general/last operation first. It's a kind of "top-down" way of looking at the code.
03:50:19 <dminuoso> HenryCH: Besides, it's how you read code anyways: for example: foo(bar(quux(baz))) in a traditional language.
03:50:39 <dminuoso> so foo(bar(quux(baz))) still looks the same, but signaling the composition in this style: foo . bar . quux $ baz
03:50:59 <dminuoso> Or using parens `(foo . bar . quux) baz` if you prefer
03:51:37 <HenryCH> i guess you can get used to either, as you say
03:51:41 <dminuoso> Indeed.
03:52:16 <nyc> kakadu: I don't know enough to address the issues in your code.
03:53:31 <dminuoso> merijn: By the way, will you be attending zurihac?
03:53:44 <HenryCH> like most people i started with a language that uses the standard "reversed" order, like haskell, but i really like how the standard in f# is the logical/evaluation order
03:53:52 <trcc> Hi. I am building a shared object with FFI using cabal. In my c file I #include "HsFFI.h", but cabal gives me a warning: non-portable path to file HSFFI.h. Can someone explain this warning to me? The compiled shared object works fine
03:54:09 <merijn> dminuoso: Unless someone offers to pay my way, doubtful, and even then...
03:54:10 <dminuoso> HenryCH: Haskells evaluation order is *drastically* different from what you may be used to.
03:54:27 <merijn> dminuoso: I'm a bit time poor and soon to be money poor :)
03:54:27 <trcc> should I add HsFFI to my project or something similar?
03:55:13 <merijn> hmm, that's odd
03:55:32 <dminuoso> merijn: Oh that's a bummer.
03:56:24 <HenryCH> well, regardless of laziness, if f needs the result of g, then f cannot possibly evaluate before g, so in that regard all languages evaluate in the same order, which is the logical order, no?
03:56:44 <merijn> dminuoso: I just switched to fulltime at my new job, I still have a thesis to finish, and if all goes well I'm buying a house which means lots of arranging things, preparing to move, etc. so all of those compete for my limited time :)
03:57:22 <merijn> HenryCH: That's not true, though. Some functions can be evaluated before their results evaluate
03:57:33 <dminuoso> HenryCH: And you can have partially evaluated chains of thunks too..
03:57:50 <dminuoso> HenryCH: The evaluation model really is that different. 
03:57:53 <merijn> HenryCH: Consider "const x _ = x" "const 1 (myExpensiveComputation x)" <- here const never needs to evaluate the expensive computation
03:59:05 <HenryCH> right, but to compose you need to evaluate the whole function, not a parameter
03:59:17 <dminuoso> HenryCH: what do you mean?
03:59:49 <HenryCH> if you have something you want to compose with const, there's no way to not evaluate const?
04:00:00 <HenryCH> which is different from argument evaluation?
04:00:31 <dminuoso> I do not fully understand what you are saying. Do you have a conrete example?
04:02:32 <cocreature> > (const 1 . error "I’m not evaluated") ()
04:02:35 <lambdabot>  1
04:03:23 <HenryCH> cocreature: how does that work?
04:03:44 <dminuoso> HenryCH: Work by substitution. Substitute (.) by its definition.
04:04:02 <HenryCH> what does error return?
04:04:35 <dminuoso> HenryCH: error is a nasty primitive that raises an exception in pure code. You shouldn't generally use it, but it has some odd uses.
04:04:48 <cocreature> error doesn’t return, it throws an error if it is being evaluated
04:05:12 <cocreature> so if you don’t see the error, the expression is not evaluated
04:05:25 <HenryCH> why is it not evaluated in your example?
04:05:33 <dminuoso> It's commonly used for demonstration purposes, so that you can see whether an expression is evaluated or not.
04:05:38 <dminuoso> HenryCH: because it's not used.
04:05:56 <dminuoso> HenryCH: substitute (.) and const with their definitions, and you will see that it's not used.
04:06:13 <HenryCH> i thought it just threw an error, how can that be used?
04:06:34 <cocreature> (f . g) x = f (g x). if "f" doesn’t use its argument, then "g x" is never evaluated
04:07:14 <HenryCH> ah ok, so that only works for the special case of composing unit?
04:07:43 <HenryCH> no i still don't get how that works
04:07:59 <dminuoso> HenryCH: If you want to understand how simple things in Haskell work - *mechanically* substitute bindings with their definitions.
04:08:13 <dminuoso> By *mechanically* I mean.. 
04:08:22 <dminuoso> > (const 1 . error "I’m not evaluated") ()
04:08:24 <lambdabot>  1
04:08:28 <dminuoso> @src (.)
04:08:28 <lambdabot> (f . g) x = f (g x)
04:08:38 <HenryCH> oh i see const takes two param
04:09:24 <dminuoso> And then apply the substition to obtain: (const 1 (error "I'm not evaluated" ())
04:09:28 <dminuoso> @src const
04:09:28 <lambdabot> const x _ = x
04:09:39 <dminuoso> And then substitute again to obtain: 1
04:09:40 <dminuoso> Done.
04:09:53 <berndl> Is there a website or something that can show you the substitution steps when evaluating a piece of Haskell code?
04:11:10 <HenryCH> ok, understood, thanks
04:11:41 <dminuoso> berndl: Note that this is not about evaluation order.
04:12:18 <royal_screwup21> what am I doing wrong here? https://thepasteb.in/p/k5hYl58AEk6sE I'm trying to define the functor instance on a custom Tree type
04:12:41 <dminuoso> royal_screwup21: Do you understand what kinds are?
04:13:13 <royal_screwup21> dminuoso: not quite...:(
04:13:16 <dminuoso> royal_screwup21: Kinds are to types what types are to values.
04:13:17 <berndl> royal_screwup21: Tree is not type constructor.
04:13:54 <dminuoso> berndl: Tree is a type constructor.
04:14:24 <dminuoso> royal_screwup21: The idea is somewhat simple. Do you know the `Maybe` type?
04:15:02 <royal_screwup21> dminuoso: I've heard of it, I'll look it up
04:15:46 <royal_screwup21> ok it's like an Optional
04:15:51 <dminuoso> Yeah.
04:15:59 <dminuoso> royal_screwup21: So you might have a type like `Maybe Int` right?
04:16:03 <berndl> dminuoso: In my mind, a type constructor has kind * -> *, which is not Tree has and hence the error.
04:16:04 <royal_screwup21> yup
04:16:22 <dminuoso> berndl: The haskell report sadly has a different perspective. :-(
04:16:45 <dminuoso> royal_screwup21: Alright. So you could think of `Maybe` as a kind of "type level function" that takes one type argument.
04:16:52 <berndl> dminuoso: link?
04:17:20 <royal_screwup21> ok...
04:17:23 * hackage lapack 0.2 - Numerical Linear Algebra using LAPACK  http://hackage.haskell.org/package/lapack-0.2 (HenningThielemann)
04:17:34 <dminuoso> berndl: https://www.haskell.org/definition/haskell2010.pdf
04:17:55 <dminuoso> royal_screwup21: So imagine `Maybe Int` as `Maybe` applied to `Int`. It gives some "type back" in return okay?
04:18:04 <royal_screwup21> yup
04:18:23 <dminuoso> royal_screwup21: So we have a "type system for the type system"
04:18:38 <dminuoso> royal_screwup21: Regular "types" have type *. For example `Int :: *`, `Float :: *`
04:18:42 <merijn> dminuoso: It's type systems all the way down!
04:19:25 <dminuoso> royal_screwup21: In order to not confuse anymore, we shall call the "type of types" kinds.
04:19:47 <royal_screwup21> alright
04:20:16 <berndl> Ah, so the report implies that Tree is a nullary type constructor.
04:20:30 <cocreature> just like True is a nullary data constructor
04:20:39 <dminuoso> royal_screwup21: Now, since I hinted that there exist things you could consider as type level functions, would you be surprised to know there's also type things of kind `* -> *`?
04:21:07 <dminuoso> royal_screwup21: It's a type level construct that... takes a type of kind `*` and returns a type of kind `*`
04:21:54 <berndl> cocreature: is there a phrase for a nonnullary type/data constructor?
04:22:01 <royal_screwup21> I see...I'm wondering if this  would work then - data Tree a = Leaf | Node a Tree
04:22:09 <dminuoso> royal_screwup21: Try it! :)
04:22:12 <merijn> berndl: Not specifically, I think
04:22:21 <merijn> berndl: I mean, I've never needed to say that :p
04:23:13 <cocreature> berndl: yeah I don’t think there is a common term for this and I agree with merijn that it’s just not that meaningful of a distinction
04:24:33 <berndl> Maybe if it was, royal_screwup21 wouldn't be having a problem right now.
04:25:07 <dminuoso> berndl: Personally I think understanding the kind system is much more valuable than having the terminology here.
04:25:27 <merijn> Ugh...persistent has a "runMigrationSilent" and a "runMigrationUnsafe", but not UnsafeSilent >.<
04:25:50 <royal_screwup21> yeah I got something work https://thepasteb.in/p/O7h5Yvz6qynUq
04:26:20 <dminuoso> royal_screwup21: Looks good. Have you tested the relevant law `fmap id = id`?
04:26:30 <cocreature> merijn: what we really need is accursedUnutterableRunMigrationSilent
04:27:14 <royal_screwup21> dminuoso: I think the implementation would satisfy that law
04:27:22 <merijn> cocreature: I have a bunch of migration logic I wrote piggybacking on top of the migrations, rollbacking, versioning, etc. but it insist on blabbering through my careful message output >.>
04:27:44 <dminuoso> royal_screwup21: All good then. Carry on.
04:27:45 <berndl> I guess "parametrised type" is the phrase I'm looking for.
04:28:06 <royal_screwup21> what if I want to paramterize my implementation of fmap, based on the type of Tree a
04:28:22 <royal_screwup21> for example, I want one implementation for Tree  Int
04:28:23 <dminuoso> royal_screwup21: That's precisely what Functor avoids.
04:28:27 <royal_screwup21> another impl for Tree String
04:28:29 <dminuoso> royal_screwup21: You cannot.
04:28:57 <dminuoso> :t fmap
04:28:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:29:29 <dminuoso> royal_screwup21: Fundamentally this must work for any choice of `a` and `b`.
04:29:49 <royal_screwup21> ah I see
04:29:57 <berndl> royal_screwup21: If you need to do that, you will have to write specific map functions for each case.
04:32:12 --- mode: glguy set +v originalName
04:32:21 <originalName> oneJohnPost <- selectList [BlogPostAuthorId ==. johnId] [LimitTo 1]
04:32:26 <originalName> from the yesod book
04:32:32 <originalName> how can i find the definition of LimitTo?
04:33:17 <originalName> i cant find a definition in the persistent source code
04:33:42 <dminuoso> royal_screwup21: There's a lot of benefits coming from the fact that `fmap` must be agnostic of the types `a` and `b` - you can knowledge into what fmap definitely cannot do, so it lets you reason about code more easily.
04:33:48 <dminuoso> *you gain knowledge
04:34:09 <cocreature> originalName: https://hackage.haskell.org/package/persistent-2.9.0/docs/Database-Persist-Types.html#v:LimitTo
04:34:46 <originalName> cocreature: yes i mean the sourcecode where LimitTo is defined
04:35:06 <cocreature> originalName: scroll up a few lines and there is "source" link on the right
04:35:31 <cocreature> but in this case the docs tell you all there is to the definition. it’s just a constructor
04:35:40 <originalName> cocreature: ahh got it, thanks. i was looking for a "data LimitTo".. :D
04:52:56 <merijn> argh...wtf is this >.>
04:53:42 <merijn> persistent is having an aneurysm and deciding it should drop all my foreign keys in migration >.>
04:55:22 * hackage vt-utils 1.1.0.0 - Vector and Text utilities  http://hackage.haskell.org/package/vt-utils-1.1.0.0 (Wilton)
05:02:58 <merijn> oh, goodie...
05:03:14 <merijn> It only recognises foreign keys if they're defined in the same big blob of persistent schema...
05:03:22 <merijn> Well, that's fucking bollocks...
05:03:58 <hpc> ouch
05:04:57 <royal_screwup21> can someone explain to me what the Fix data type is?
05:05:23 <merijn> hpc: This SO suggests having it in separate files should work if "foreign_keys = ON", but that's already the case for me >.>
05:05:32 <berndl> royal_screwup21: Fix is the analog of the fix function for types.
05:05:33 <merijn> https://stackoverflow.com/questions/37182279/foreign-key-from-an-existing-database-with-persistent-haskell
05:05:42 <hpc> royal_screwup21: so, take the definition
05:05:55 <hpc> data Fix f = Fix (f (Fix f))
05:05:56 <royal_screwup21> berndl: data Fix f = In (f (Fix f))
05:06:08 <hpc> you can mentally remove the data constructor and "data" keyword
05:06:12 <hpc> Fix f = f (Fix f)
05:06:14 <hpc> @src fix
05:06:15 <lambdabot> fix f = let x = f x in x
05:06:19 <hpc> ah right
05:06:28 <merijn> hpc: And of course the issue is impossible to google >.>
05:06:39 <hpc> anyhoo, that's the same as fix f = f (fix f) at the value level
05:06:47 <hpc> so if you have Fix Maybe
05:06:56 <hpc> the type is effectively Maybe (Maybe (Maybe (Maybe ...
05:07:05 <royal_screwup21> yup..
05:07:58 <hpc> when something is shaped like a newtype the way Fix is, removing the data constructor and "data" keyword to make it look like a function is a really helpful tool
05:08:23 <hpc> you can unravel a good like, 70% of weirdly-categorical type definitions
05:10:32 <royal_screwup21> say I have data ListF a k = EmptyF | ConsF a k
05:10:36 <royal_screwup21> I
05:10:57 <royal_screwup21> I'm trying to figure out what would be an example of Fix (ListF)
05:11:15 <royal_screwup21> Empty?
05:11:30 <hpc> so, you have Fix (ListF Int) -- i think this is what you meant
05:11:51 <hpc> Fix (ListF Int) = ListF Int (Fix (ListF Int) -- by the equation above
05:12:22 <merijn> hpc: ugh...ok, so looks like there's a solution to keep them independent, but the problem is that the migration machinery requires all entities in one place. So I can work around this, but only by sacrificing my "partial migration" setup, which was the entire point of this >.>
05:12:37 <hpc> you can examine the definition of ListF now with a=Int, k=(Fix (ListF Int)
05:13:26 <hpc> data Something = EmptyF | ConstF Int (Fix ListF Int)
05:13:40 <hpc> er, with some extra parens there
05:14:23 <hpc> actually, the type needs to be properly for the next step:
05:14:46 <hpc> data ListF Int (Fix (ListF Int)) = EmptyF | ConstF Int (Fix (ListF Int))
05:14:49 <hpc> so!
05:15:05 <royal_screwup21> hpc: hmm yup...trying to write it down to understand...btw, it doesn't have to be an Int, does it? I'm trying to generalize with k
05:15:05 <hpc> going back to the equation Fix f = f (Fix f)
05:15:16 <hpc> (Fix (ListF Int)) on the right
05:15:23 <hpc> is the same thing as ListF Int (Fix (ListF Int)) on the left
05:15:47 <hpc> let's name both of them "IntList", because i know the answer to this already ;)
05:15:55 <hpc> and rewrite the data definition
05:16:02 <hpc> data IntList = EmptyF | ConstF Int IntList
05:16:08 <hpc> or [Int]
05:16:42 <hpc> that's all using a=Int, you can leave a as a variable and get [a]
05:16:44 <royal_screwup21> hpc: isn't the goal of Fix to "remove recursion"?
05:17:07 <royal_screwup21> data IntList = EmptyF | ConstF Int IntList  is recursive
05:17:10 <hpc> the way you rewrote ListF with the continuation type expaned out removes recursion
05:17:27 <hpc> Fix is what translates the expanded form back to a regular recursive type like []
05:17:41 <hpc> you can use other types with the same kind as Fix to do more interesting things
05:17:52 <hpc> by inserting other logic in the recursive call
05:18:56 <hpc> suppose instead of Fix, you had data ConstF f = StopImmediately (f ())
05:19:31 <hpc> work out what ConstF (ListF a) is
05:19:40 <xsperry> > realToFrac $ 0.1 :: Ratio Int
05:19:43 <lambdabot>  3602879701896397 % 36028797018963968
05:20:12 <xsperry> weird. realToFrac $ 0.1 :: Ratio Int   in my ghci is giving me *** Exception: Ratio has zero denominator  
05:20:26 <xsperry> and I can't figure out why
05:20:27 <royal_screwup21> thanks for explaining...a lot of it went over my head but I'll re-read it and ask questions as I try to grok it
05:21:11 <hpc> xsperry: welcome to Double
05:21:42 <hpc> royal_screwup21: this definitely benefits from interacting with it in ghci a bit
05:21:51 <xsperry> hpc, how does Double lead to 0 ending up in denominator?
05:22:29 <julianleviston> Int to Int.
05:22:58 <hpc> oh, i thought you meant the weird ratio
05:23:00 <hpc> hmm
05:23:11 <xsperry> nope, I'm getting zero denominator exception
05:23:39 <hpc> try :: Ratio Int64
05:23:39 <xsperry> if I change Ratio Int to Ratio Integer, I get weird ratio
05:23:54 <hpc> you have a 32-bit OS
05:24:06 <xsperry> I don't. but I might have 32 bit ghc
05:24:14 <merijn> xsperry: I don't understand what realToFrac does in your example?
05:24:17 <hpc> ah, or that
05:24:25 <hpc> realToFrac $ 0.1 :: Ratio Int32
05:24:29 <hpc> > realToFrac $ 0.1 :: Ratio Int32
05:24:30 <merijn> xsperry: like, why have it there?
05:24:32 <lambdabot>  *Exception: Ratio has zero denominator
05:24:37 <merijn> > 0.1 :: Ratio Int32
05:24:39 <lambdabot>  1 % 10
05:24:51 <merijn> Dunno wtf you guys are all on about
05:24:54 <xsperry> merijn, this is part of larger code, I trimmed it down for example and ended up with that
05:25:08 <merijn> > 0.1 :: Double
05:25:11 <lambdabot>  0.1
05:25:32 <merijn> That seems unlikely? Is 0.1 precisely representable?
05:25:36 <merijn> > 0.3 :: Double
05:25:39 <lambdabot>  0.3
05:25:41 <hpc> > 36028797018963968 :: Int32
05:25:43 <lambdabot>  0
05:25:45 <merijn> ok, so Show for DOuble lies
05:25:47 <hpc> > 36028797018963968 :: Int64
05:25:47 <xsperry> what seems unlikely?
05:25:48 <merijn> Of course it does
05:25:49 <lambdabot>  36028797018963968
05:26:01 <merijn> xsperry: "0.1" being exactly "0.1" as Double
05:26:10 <xsperry> yeah
05:26:19 <merijn> xsperry: 0.1 and 0.3 aren't exacatly representable as Double, but apparently show does rounding...
05:26:25 <hpc> so it's Double being imprecise for decimal fractions, producing an enormous denominator that overflows 32-bit ints
05:26:28 <xsperry> yep
05:26:31 <merijn> Because why not, all instances for Double where shit anyway
05:26:56 <julianleviston> Wow… numbers :)
05:27:02 <hpc> instance Num Double where shit -- :D
05:27:16 <julianleviston> Seems every week I learn a new fascinating thing about basic number types
05:27:43 <merijn> On the bright side, I think I can fix the persistent migrations with 1 lines without even understanding how they work.
05:27:49 <hpc> everything would be so much better if we used CReal everywhere :P
05:28:04 <merijn> On the down side, maintainers are so slow I have like 5 trivial dramatic QoL improvements not going anywhere >.>
05:28:09 <xsperry> hmm, wonder how I should handle this. change my type to Ratio Integer, or do something (what?) to make (0.1 :: Double) give me 1 % 10 or something
05:28:33 <hpc> don't use realToFrac
05:28:39 <hpc> > 0.1 :: Ratio Int32
05:28:42 <lambdabot>  1 % 10
05:29:04 <xsperry> I'm not writing a ratio literal, I'm converting Double to Ratio Int
05:29:10 <hpc> ooooooh
05:30:05 <hpc> a brute-force option that works is Ratio Integer, then *10, then round it, convert back to Ratio Int and /10
05:30:20 <hpc> s/10/however precise you want to be/
05:30:53 <xsperry> > realToFrac ((0.01 :: Double) * 10) :: Ratio Int
05:30:56 <lambdabot>  3602879701896397 % 36028797018963968
05:31:13 <xsperry> works with 0.1, but same issue if input is 0.01
05:31:21 <hpc> > realToFrac (floor (0.01 :: Double) * 10) / 10 :: Ratio Int
05:31:24 <xsperry> oh, I missed rount it part
05:31:25 <lambdabot>  0 % 1
05:31:27 <xsperry> round*
05:31:30 <hpc> > realToFrac (floor (0.01 :: Double) * 1000) / 1000 :: Ratio Int
05:31:32 <lambdabot>  0 % 1
05:31:39 <xsperry> nice
05:31:44 <hpc> close enough :P
05:31:52 <xsperry> :)
05:32:22 <hpc> oh
05:32:29 <hpc> > realToFrac (floor (0.01 * 1000 :: Double)) / 1000 :: Ratio Int
05:32:32 <lambdabot>  1 % 100
05:33:13 <xsperry> what type did it infer instead of Double?
05:34:04 <hpc> it just had the multiplication outside the floor
05:34:06 <hpc> > floor 0.01
05:34:08 <lambdabot>  0
05:38:22 <xsperry> interesting discussion and solution, and I learned something new.. but this was really an XY problem.. my parser was returning Double, which I then converted to Ratio Int. parsing to Ratio Int directly fixed the issue
05:39:32 <hpc> nice
05:39:52 * hackage hslua 1.0.2 - Bindings to Lua, an embeddable scripting language  http://hackage.haskell.org/package/hslua-1.0.2 (tarleb)
05:41:55 <merijn> %)&(&%(&(%&(%@&@%(
05:42:11 <lavalike> good day to you to merijn 
05:42:20 <merijn> A pox upon the moron who wrote this and his children
05:42:27 <merijn> God fucking dammit
05:42:55 <merijn> I just spend the past half hour trying to figure out why I got random ass errors about Text when appending two lists
05:43:25 <merijn> Only to find out this godforsaken terrible person alias ++ to be Data.Text.append
05:44:10 <merijn> WHO DOES THAT?!?!
05:45:18 <xsperry> actually no, changing parser only fixed this in my imagination :P
05:45:26 <xsperry> > read "0.1" :: Ratio Int
05:45:31 <lambdabot>  *Exception: Prelude.read: no parse
05:45:52 <xsperry> why doesn't that work?
05:46:29 <nyc> I think (++) used to be a method that now has an awkward name.
05:46:42 <xsperry> 0.1 is a valid Ratio Int literal in source, so read should handle it IMO
05:49:39 <julianleviston> merijn: oh wow
05:53:09 <julianleviston> xsperry: Wondering if Data.BigDecimal is any good? I’ve not used it in Haskell
05:54:29 <xsperry> julianleviston perhaps I can use that instead of Ratio? I am using Ratio Int instead of Double so they work as Map keys
05:54:33 <geekosaur> xsperry, not quite that simple
05:55:17 <julianleviston> isn’t 0.1 only a valid Ratio Int literal in source because it’s polymorphic?
05:55:21 <geekosaur> in particular, the compilation pathway is: 0.1 --> fromRational ((1::Integer) :% (10::Integer))
05:55:36 <geekosaur> except the Integer-s are in internal format
05:55:45 <julianleviston> ie… 0.1 is actually Fractional a => a
05:55:58 <geekosaur> but, in particular, the fromRational wrapper *is* there
05:56:24 <geekosaur> and read cannot do that, it is a parser not an evaluator
05:57:31 <geekosaur> nyc, no, (++) always was defined on lists. you may be thinking of (<>) aka mappend
05:57:41 <julianleviston> xsperry: BigDecimal has `fromString`.
05:57:50 <geekosaur> but that doesn't work on Text either, absent mono-traversable package
05:58:14 <xsperry> julianleviston, so it is safe to use BigDecimal as Map keys?
05:58:17 <julianleviston> eh? mappend doesn’t work on Text? I’m sure I’ve had it working on text.
05:58:25 <julianleviston> xsperry: safe? Uhm… I don’t know :)
05:58:30 <xsperry> :P
05:58:36 <geekosaur> hm, ctually, ...
05:58:38 <julianleviston> xsperry: what do you mean safe?
05:58:46 <geekosaur> Monoid doesn't have an extra type parameter, it should work
05:58:48 <nyc> geekosaur: Who knows? I haven't looked for so long.
05:59:07 <geekosaur> but in any case youaa re thiniing <> as the polymorphic one
05:59:26 <geekosaur> julianleviston, Double has a number of issues as a Map key
05:59:26 <xsperry> julianleviston, does it have same potential issues as Double? two numbers, which should be equal, aren't, because of rounding errors
05:59:35 <nyc> Maybe map vs. fmap?
05:59:37 <julianleviston> geekosaur: ooh, ok. Didn’t know that.
06:00:34 <julianleviston> xsperry: well, if you look at the implementaiton it seems to be two Integers, and uses the second as a scale of the first (ie how many decimal places are beyond the decimal place). I think.
06:01:33 <geekosaur> anyway BigDecimal should work, it's secretly a fixed point based on Integer
06:01:41 <geekosaur> so it should be stable
06:02:12 <geekosaur> but has the other problem s that come with fixed point impls
06:02:38 <xsperry> what problems?
06:02:40 <geekosaur> I haven't used that one, I have used BigFloat from the numbers package
06:02:53 <geekosaur> basically, what happens when there's no terminating representation
06:03:17 <geekosaur> square root, trig, depending on representation even division can get you into trouble
06:03:18 <julianleviston> geekosaur: what’s a terminating representation?
06:03:30 <julianleviston> geekosaur: oh so it’s not precise?
06:04:14 <hpc> imagine doing math on paper but your numbers are only allowed to have 3 digits after the decimal place, it's that kind of thing
06:04:20 <geekosaur> "terminating reprsentation" means at some point whatever the internal representation is reaches a stable point.
06:04:28 <hpc> pi is exactly 3.14, etc
06:04:35 <geekosaur> which may be a repreating decimal, or etc.
06:04:39 <julianleviston> it’s worth looking at the implementaiton of divide in its source IMO...
06:04:51 <geekosaur> this cannot represent pi unless pi is the basis of the representation
06:04:58 <julianleviston> > divide two BigDecimals and applies the 'MathContext' (i.e. a tuple of 'RoundingMode' and the specified precision) for rounding.
06:05:00 <geekosaur> (or something from which pi can be derived)
06:05:01 <lambdabot>  <hint>:1:68: error: parse error on input ‘of’
06:05:45 <julianleviston> xsperry: so it pretty much depends what you need to do with it, as always.
06:06:08 <xsperry> I don't think I'll have issues with that for what I'm doing. I'm a bit lost what type to use, though. Data.Decimal, Data.BigDecimal, Data.BigFloat?
06:06:17 <julianleviston> xsperry: BigDecimal is not too bad for addition and subtraction, and single currencies :)
06:07:57 <nyc> BigFloat sounds interesting to me.
06:08:53 <julianleviston> xsperry: I wonder if you could use a type alias to abstract over whichever type you were currently using, then try out a few and see which ones are better for you.
06:09:24 <julianleviston> sorry not rally abstracting over, just making a reference in a single place, to make it easy to change.
06:09:57 <geekosaur> also tbh I was using BigFloat, then decided to see if Rational was good enough. it was, plus ran about 20 times faster
06:10:12 <geekosaur> (BigDecimal may be better optimized or etc.)
06:14:26 <nyc> MPFR interfaces sound more promising.
06:15:06 <xsperry> it seems that Data.Number.BigFloat does not have String -> BigFloat e function. BigDecimal does
06:16:16 <geekosaur> pretty sure it uses a Read instance like everythng else
06:16:25 <geekosaur> does everything have to have a bespoke custom interface?
06:16:29 <xsperry> it doesn't have it
06:16:33 <xsperry> No instance for (Read (BigFloat Prec10))
06:23:57 <nyc> hmpfr looks like more of what I'm looking for so I can repeat various calculations in n-tuple precision to verify convergence etc.
06:24:30 <xsperry> anyway, it looks like BigDecimal will work
06:26:57 <merijn> Is it legal syntax to have quasiquoter being an expression that produces a quasiquoter? Or does it have to be a single identifier?
06:27:42 <julianleviston> I don’t get it. What would their reason be for not writing a Read insance?
06:28:52 <merijn> Read being a terrible class
06:29:09 <julianleviston> oh really? how come?
06:29:15 <merijn> julianleviston: Slow as fuck
06:29:20 <julianleviston> coz you have to do ad-hoc types to give it what type it should use?
06:29:24 <julianleviston> ah okay.
06:29:56 <xsperry> geekosaur, do you thinkBigDecimal did this right? fromString "0.1" returns BigDecimal 1 1.  read "BigDecimal 1 1" :: BigDecimal works, read "0.1" :: BigDecimal  doesn't
06:30:29 <geekosaur> if BigDecimal is th constructor, yes
06:30:41 <julianleviston> yeah read is supposed to be the reverse of show, right.
06:30:42 <xsperry> it is, but what is the argument for read "0.1" not working
06:30:43 <geekosaur> if you are still expecting it to be a full ghc implementation, sto pnow
06:31:02 <geekosaur> it is not going to evaluate an implictly inserted fromRational or etc.
06:31:26 <geekosaur> it is not, and does not pretend to be, the whole compiler implementation of numeric literals
06:41:07 <ggole> Reading and printing aren't inverses because of formatting, etc.
06:46:59 <geekosaur> xsperry, the argument is that read is something that can be n Prelude, not all of ghc 
06:47:40 <geekosaur> then again I suppose you are used to interpreters where the whole compiler environment is conveniently there as EVAL
06:48:02 <hpc> xsperry: read is the inverse of show, but there's no BigDecimal value that when shown produces the string "0.1"
06:58:23 <dminuoso> 15:57           ggole | [14:40:45] Reading and printing aren't inverses because of formatting, etc.
06:58:51 <dminuoso> ggole: By the definition of the Haskell report `read . show = id`
06:59:55 <dminuoso> Show is far too often abused for "pretty printing", it's not what it is for.
07:00:23 <ggole> % let x = "010" in show (read x :: Int) == x
07:00:24 <yahb> ggole: False
07:01:21 <ggole> That's what I meant.
07:07:12 --- mode: glguy set +v spherinder[m]
07:10:50 --- mode: glguy set +v purplepy
07:12:11 <purplepy> quick question: why does "let x::forall a; x=x" compile? What does "forall a" (NOT forall a. a) mean?
07:12:35 <merijn> purplepy: Because without extensions forall is not a keyword
07:13:06 <purplepy> good point:)
07:13:08 <geekosaur> so forall is just an unspecified typ variable
07:13:18 <merijn> purplepy: "x :: forall a" == "x :: f a"
07:13:43 <purplepy> thx
07:15:03 <butterthebuddha> I have a function of type "(a -> m a) -> (m a -> a) -> b -> [m a] -> n (b, [m a])"
07:15:42 <butterthebuddha> But I'd like to also use it to generate a function of type (a -> a) -> (a -> a) -> b -> [a] -> n (b, [a])
07:15:52 <butterthebuddha> Essentially, I'd like to pretend the "m" didn't exist
07:16:05 <lyxia> set m to Identity?
07:16:18 <geekosaur> best you can do there, I think. still needs runIdentity
07:16:22 <lyxia> coerce
07:16:27 <butterthebuddha> lyxia: Yes, but now I have to wrap everything in Identity explicitly when I want to ue the funcgtion
07:16:43 <butterthebuddha> use* function*
07:16:58 <geekosaur> it's structural, not a text macro that can be substituted with an empty "thing"
07:18:39 <lyxia> type MyFun ma a b = (a -> ma) -> (ma -> a) -> b [ma] -> n (b, [ma])     now you can give Data.Coerce.coerce this type:   coerce :: MyFun (Identity a) a b -> MyFun a a b
07:19:05 <lyxia> ah, if not for the n that would have worked...
07:19:20 <butterthebuddha> The n in this case is Either Text
07:19:22 <butterthebuddha> If that helps at all
07:19:25 <lyxia> it does
07:19:27 <lyxia> then that works
07:19:51 <butterthebuddha> Okay, I'm not very familiar with coerce. Can you walk me through this?
07:19:56 <lyxia> sure
07:20:29 <lyxia> Identity a   and   a   are represented the same way at runtime
07:21:07 <lyxia> and coerce is a function that can map between any two types that have the same representation
07:21:15 --- mode: glguy set -qo $~a glguy
07:22:02 --- topic: set to 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Identification or Voice(+v) require to chat during spam' by ChanServ
07:22:15 --- topic: set to 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org' by ChanServ
07:28:22 <spherinder[m]> Hi guys, I have a quick question: As I've understood, haskell is mostly based on system f with a few extensions like recursion. I'm wondering, how can the ad hoc polymorphism in haskell with type-classes be expressed using system f?
07:31:46 <lyxia> type classes are another feature on top
07:32:01 <merijn> spherinder[m]: It's fairly simple to make mechanical
07:32:19 <merijn> spherinder[m]: Suppose we have "fmap :: Functor f => (a -> b) -> f a -> f b"
07:32:32 <merijn> spherinder[m]: Functor has a handful of methods, right?
07:32:42 <merijn> (well, 1 for Functor, but other typeclasses differ, of course)
07:32:52 <spherinder[m]> yeah
07:33:11 <spherinder[m]> monoid has mempty and mappend etc
07:33:26 <merijn> spherinder[m]: So we simply say "data FunctorRec f = Functor { fmap :: forall a b . (a -> b) -> f a -> f b }"
07:33:55 <merijn> spherinder[m]: Then turn "Functor f => (a -> b) -> f a -> f b" into "FunctorRec f -> (a -> b) -> f a -> f b"
07:34:06 <merijn> spherinder[m]: Now we're just dealing with records and regular types
08:47:33 <spherinder[m]> So giving the fmap-definition for Maybe of type (a->b)->Maybe a->Maybe b to the fmap constructor, we get a value of type FunctorRec Maybe. 
08:47:34 <spherinder[m]> Now we can feed this value into your FunctorRec f ->.... function, which will have access to the fmap-definition for Maybe we previously gave the fmap constructor, and can apply it!
08:48:12 <spherinder[m]> merijn This is pretty astonishing
08:51:16 <dminuoso> spherinder[m]: This is in fact how GHC implements it behind the scenes sort of.
08:52:47 <merijn> spherinder[m]: I think there may be other ways to implement things, but that's how GHC does it, so typeclasses are completely eliminated before moving to the System F stuff
09:35:21 <jbetz> is it possible to extract existentially quantified type variables? I need them to call typeclass methods on elements in a heterogeneous list using type applications
09:37:11 <jbetz> I'm aware of the canonical Showable example, but that doesn't work for me since some of my typeclass methods have zero args and therefore only depend on type parameters
09:37:56 <jbetz> I'm also open to a completely different approach since this one does not seem at all clean, if it's even possible
09:47:57 <lyxia> jbetz: do you really have existentially quantified variables
09:49:48 <jbetz> lyxia: ? I have: `data State e where State :: forall e f. Structurable f e => { _structure    :: Structure f e .. } -> State e`
09:49:57 <lyxia> I mean, that doesn't seem implied by doing stuff with heterogeneous list
09:50:38 <lyxia> ok that looks pretty existential
09:50:58 <jbetz> and then a list of `[State e]` from which I need to extract `f`
09:51:23 <cocreature> so is the only reason that you make the type parameters existential so that you can put them in the list?
09:51:55 <jbetz> hmm, okay. it would have been clearer to say "list of existentially quantified values" rather than "heterogeneous list".
09:52:21 <jbetz> cocreature: yes
09:54:00 <cocreature> jbetz: so how do you want to process the list elements? if all you want to do is call some typeclass method, can you call that method when you add things to the list?
09:54:15 <jbetz> and e.g., `Structureable` has methods like `name :: String` that I'd need to call with `name @f @e`
09:54:31 <cocreature> e.g. the classic list-of-showables is usually better handled by calling show and using a list of String instead
09:55:35 <merijn> How do I "unquote" a TH value? Basically, I wanna pretty print source
09:58:15 <jbetz> cocreature: the problem is that I need to call three different typeclass methods, and they won't all have the same return type as with `show`, so I can't just put all three of them into a record
09:58:23 <merijn> ok, I found pprint, now I just need a...prettier print :p
09:59:11 <cocreature> jbetz: well you can make a record to store the result of the 3 methods
10:01:23 <cocreature> jbetz: to answer your original question, I don’t think you can capture an existentially bound type variable directly (although there is a proposal for it) but you could take the "Structure f e" you get out of the pattern match and pass it to some function of type "forall f e. Structure f e -> …" and use ScopedTypeVariables to get "f" and "e" within the body of that definition
10:03:13 <lyxia> jbetz: case state of State (_structure :: Structure f e) ... -> name @f @e
10:03:22 <lyxia> would this work with ScopedTypeVariables
10:03:42 <cocreature> if it does, then I forgot what the proposal was about :)
10:04:53 <jbetz> cocreature: what I meant was that method results depend on the typeclass parameters, which vary within the list
10:04:56 <lyxia> State @f @e   was the proposal
10:05:38 <cocreature> jbetz: that seems problematic. once you apply such a method you’re back to having a list of things that don’t have the same type
10:06:28 <jbetz> exactly. your second solution seems promising though.
10:06:57 <cocreature> that doesn’t solve the problem either if the result type of the function depends on the existentially captured type variables
10:07:08 <cocreature> and if it doesn’t, then you can apply that function when putting things in the list
10:07:33 <cocreature> lyxia: oh I didn’t realize the proposal was already accepted. is this part of 8.6 already?
10:08:58 <lyxia> I'm not sure whether it's been accepted yet actually, but if it was it's probably not yet implemented.
10:28:17 <jbetz> cocreature, lyxia I'm going to see if I can get my method result types to match and go from there. thanks for the advice :)
10:42:45 <wroathe> Is this a good place to ask specific library questions or is there a better channel for that?
10:43:23 <c_wraith> depends on the library.  best to just ask the question.  if there's a better channel, someone will probably mention it.
10:43:24 <wroathe> Is this a good place to ask specific library questions or is there a better channel for that?
10:43:40 <wroathe> whoops, lag and I didn't see my first message send
10:45:13 <wroathe> so http-client/conduit has an httpSource function that takes a request and a function that maps a response to a conduit source: http://hackage.haskell.org/package/http-conduit-2.3.4/docs/Network-HTTP-Simple.html#v:httpSource
10:45:35 <suzu> how do i make (foo =<< bar $ do \n ...) behave?
10:45:51 <wroathe> I'd like to check the last modified time in the response headers, and then if it's older than a file that already exists on my file system, return a "no op" source or something to that effect
10:45:56 <suzu> i could wrap the do in ()s and remove the $ i suppose..
10:46:19 <wroathe> Basically I'm trying to write a function that only streams the response body into a file if the last modified time is newer or the file does not exist
10:46:45 <wroathe> runConduitRes $ httpSource req getResponseBody .| sinkFileCautious target
10:47:03 <wroathe> My first incarnation always streams the response body into my output file
10:47:40 <wroathe> The thing to do might just be to dive into Conduit's docs a little more deeply
10:47:51 <Welkin> just add a case expression
10:53:08 <wroathe> Welkin: Was that directed at me or suzu?
10:53:43 <suzu> you
10:54:40 <wroathe> case on what?, what I'm unclear on is what I need to return to shortcircuit the conduit pipeline
10:55:28 <Welkin> I didn't see you were using conduit above
10:55:42 <suzu> you would want to write a function that gives you one of two conduits to run
10:57:18 <Welkin> I'm doing something similar, but using wai's ResponseStream, inside of which I have a loop using `fix`
10:57:42 <suzu> is the fix necessary? surely you could just name your loop?
10:58:04 <Welkin> sure
10:58:12 <monochrom> On the flip side, is naming your loop necessary? surely you could just use fix.
10:58:22 <suzu> hehe
10:59:10 <c_wraith> for purely local loops that close over a previously-bound value, I prefer using fix...  unless it gets complex enough that I confuse myself. :)
11:15:35 <dminuoso> suzu: What do you mean by "behave" ?
11:20:52 * hackage hmm-lapack 0.3 - Hidden Markov Models using HMatrix primitives  http://hackage.haskell.org/package/hmm-lapack-0.3 (HenningThielemann)
11:24:52 * hackage classify-frog 0.2.4.1 - Classify sounds produced by Xenopus laevis  http://hackage.haskell.org/package/classify-frog-0.2.4.1 (HenningThielemann)
11:29:17 <lyxia> suzu: -XBlockArguments
11:29:54 <lyxia> allows you to write (foo =<< bar do ...)
11:38:28 <suzu> thanks lyxia!
11:40:23 * hackage katip-syslog 0.1.2.0 - Syslog Katip Scribe  http://hackage.haskell.org/package/katip-syslog-0.1.2.0 (MikolajKonarski)
11:42:16 <dexterfoo> anyone here use shake? is my understanding correct that "priority" and "deprioritize" are completely unrelated with each other?
12:11:19 <fen> is there a way to use QuantifiedConstraints to get a fundep like | forall a. f a -> r
12:12:47 <c_wraith> fen, I don't think that even means anything.
12:13:13 <c_wraith> fundeps don't care about kinds
12:13:36 <c_wraith> they only care about the type variable
12:13:59 <fen> `f a' presents `a' so there is something like | f a -> a
12:14:11 <fen> | f -> a would be impossible
12:14:18 <c_wraith> but...  that still doesn't mean anything
12:14:38 <c_wraith> a fundep specifies a relation between the type parameters to a MPTC
12:15:03 <c_wraith> It doesn't mean anything if you specify a type that's not a parameter to the MPTC
12:15:47 <fen> here is the MPTC; class Get r f where get :: f a -> (r,Maybe (f a))
12:16:14 <fen> the list instance would have get :: [a] -> (a,Maybe [a])
12:16:17 <c_wraith> ok, you understand that that class is explicitly designed to not care what type a is, right?
12:16:41 <c_wraith> If you need it to care about `a', you need to make `a' a parameter to the class 
12:16:56 <fen> theres a contradiction with that
12:17:32 <c_wraith> well, yes.  your type for get is incorrectly specialized
12:17:59 <c_wraith> the class can't work for lists
12:18:08 <c_wraith> It's not about fundeps, it's about parametricity
12:18:10 <fen> it should be able to pass the parameter provided to f to something else
12:18:46 <c_wraith> the class *explicitly* says that the return type r cannot depend on a
12:19:02 <c_wraith> If you want r to depend on a, then you need to add a to the MPTC
12:19:02 <fen> class Get r f | f -> r ...
12:19:27 <fen> but then its not just a class over f
12:19:41 <fen> its fine for f to determine r, its not ok for it to determine a
12:19:59 <fen> it should work for all a
12:20:01 <c_wraith> but you want a to be determined by r?
12:20:04 <c_wraith> that's a contradiction
12:20:21 <fen> no | f a -> r
12:20:45 <fen> oh, same thing
12:20:47 <fen> ok
12:20:49 <nshepperd1> Fundeps don't do anything
12:20:49 <c_wraith> so put a in GET
12:20:53 <c_wraith> err, Get
12:20:59 <nshepperd1> They just restrict what instances are allowed
12:21:41 <c_wraith> that may be overstating it a bit.  they do a bunch for type checking, but nothing at runtime.
12:22:12 <fen> right, one instance per class, which is correct here, [a] -> (a,Maybe [a]) fixes r == a so that for lists, the type of r is specified
12:22:14 <c_wraith> checking and inference, I suppose.  those are not equivalent, and fundeps help both
12:22:36 <c_wraith> I'm telling you, your class doesn't allow that
12:22:55 <fen> the problem is that this would lead to e.g. the type of the contents appearing in the traversable class...
12:23:02 <nshepperd1> Restricting the instances that are allowed lets the compiler do some inference instead of failing with an 'ambiguous instance' error
12:23:04 <fen> which clearly seems wrong
12:23:19 <c_wraith> then fix your design
12:24:21 <fen> is there no way to say that "whatever the parameter applied to `f' is, apply it also to this other thing"
12:24:36 <fen> so then Get for lists could use Identity as this other thing
12:24:41 <c_wraith> there is no "the parameter applied to f"
12:24:58 <fen> its kind seems to indicate its waiting for a parameter
12:25:14 <c_wraith> except in the signature of get itself, in which case you have an easy way to specify what it is
12:25:19 <c_wraith> which is the name
12:25:52 <c_wraith> :t fmap
12:25:54 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:26:03 <c_wraith> there is no "the parameter applied to f"
12:26:06 <fen> its more than just fundeps, this also seems to make associated types have the same problem
12:26:16 <c_wraith> the problem is that your design is wrong
12:26:45 <c_wraith> look closely at the type of fmap there
12:26:49 <fen> a type can be returned using an associated type over f, so is the answer then to make this Identity?
12:27:11 <c_wraith> fmap controls the type parameters applied to f.  Functor does not.
12:27:39 <fen> and then have `R a' in the type of get :: f a -> (R a,Maybe (f a))
12:28:18 <fen> its just it would be good to somehow fix that `f' and `R' always have the same parameter applied to them
12:28:19 <c_wraith> fmap chooses two *different* type parameters, and links them by also requiring a parameter that links those two types.  that's how you work with higher-kinded type parameters.
12:28:39 <c_wraith> You relate them in the types of the members of the class.
12:28:46 <nshepperd1> fen: sure, that would work
12:29:32 <fen> but its only the type signature of get that makes this link between the parameters to `f' and `R'. there is no way else to do that?
12:29:35 <c_wraith> The notable thing about that change is that you no longer have an MPTC
12:29:43 <nshepperd1> If you want a to be available you've gotta use a
12:31:20 <fen> elsewhere in the code (which only showed up an error at testing due to some kind of strange error due to QuantifiedConstraints, where a type compiles but then throws an error if :t is used in GHCi - basically allowing a lot of code to be written using this wrong approach)
12:31:31 <fen> there were types such as a -> r -> r'
12:31:50 <fen> which would now become a -> R a -> R' a
12:32:04 <fen> where R' is the R associated to a different f
12:32:21 <fen> it was nice to work with the `a' "hidden" in the `r'
12:32:36 <c_wraith> not for anyone reading the code later.
12:33:05 <fen> this way with fixing the associated type to take the same parameter as f as specified by type signatures, makes this whole abstraction redundant
12:33:09 <fen> or, just, wrong
12:33:21 <c_wraith> yes, I've told you it was wrong several times...
12:33:38 <fen> but the compiler didnt
12:33:46 <c_wraith> it did eventually
12:34:07 <fen> it shouldnt have compiled if asking the type at GHCi would throw an error!
12:34:27 <c_wraith> GHC does let you go an awfully long way in the wrong direction before you finally hit an error you can't get past.
12:34:50 <c_wraith> In the past, people often did that with OverlappingInstances
12:34:57 <c_wraith> I did, when I was learning Haskell
12:35:08 <c_wraith> But there are apparently new paths you can take
12:35:17 <fen> its the first time this has happened, it might be a bug with QualifiedConstraints
12:35:36 <c_wraith> Could be.  It still has several issues.
12:35:49 <c_wraith> It's a considerably more complex extension than I thought at first glance.
12:36:05 <c_wraith> err.  QuantifiedConstraints, but I think that's what you meant.
12:36:22 <fen> yeah
12:36:33 <fen> it would be something like (Get r f,Get r' f) => ... 
12:36:55 <fen> really these should be the same (r = r')
12:37:21 <fen> but the compiler just truncates the forall, and then throws an unexpected error later
12:38:47 <fen> there was a synonym like Get' f = forall r. Get r f
12:38:49 <nshepperd1> You probably shouldn't be using quantifiedconstraints, i think
12:40:25 <fen> it was to get the type of traverse
12:40:29 <nshepperd1> It's very rare that something needs it
12:40:33 <fen> :t traverse 
12:40:35 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
12:40:46 <fen> to have (r -> f r')
12:41:10 <nshepperd1> Just piling up extensions that you don't understand isn't progress
12:42:20 <fen> which when restricted to types where | f a -> r=a, with the fundep f -> r fixes r = r' so that the applicative returning function gets type (r -> f r') = (r -> f r) = (a -> f a)
12:42:22 <nshepperd1> (forall r. Get r f) means that you can get any value you want out of an f
12:42:36 <fen> that was so it could be for `a' and `b'
12:42:48 <nshepperd1> It means there's an instance Get Void f
12:42:59 <nshepperd1> I'm sure that's not what you meant
12:43:05 <fen> true
12:44:20 <fen> but if there was an `f' that corresponded to r = Void, it would have to be R a = (), i.e. R = Const ()
12:44:38 <fen> so there is no problem extending r to R a
12:44:52 <fen> but there is a problem giving it the `a' 
12:45:53 <nshepperd1> In fact, I'm certain that you neither need nor want QuantifiedConstraints here
12:45:53 <fen> class Get r f where type R f;get :: f a -> (R a,Maybe (f a))
12:47:02 <nshepperd1> If you're going to write that, take away the r parameter
12:47:20 <nshepperd1> And it should be 'R f a' in the type signature of get
12:48:21 <fen> sure, QualifiedConstraints was just a way to use forall a. Get a f, which is wrong
12:48:50 <fen> oh yeah, forgot to omit the lower case r
12:50:20 <fen> is it worth trying to reproduce the buglike error encountered when trying to do this with QuantifiedConstraints?
12:55:03 <fen> https://bpaste.net/show/62b0adcae674
12:55:13 <fen> arguably, this should not have been able to compile
13:08:36 <c50a326> hey I'm having a crack at implementing dropWhile in terms of foldr, but getting this error even when trying to use a simple helper function and having it as undefined: https://ptpb.pw/rsgS/hs#L-4
13:11:52 <nshepperd> fen: you get the same error if you write "let traverse2 = traverse'" in ghci after loading the file
13:12:23 <fen> yeah, theres somthing not right
13:12:58 <nshepperd> it's probably some problem with type inference, which i'm sure is hairy with quantified constraints
13:13:14 <c50a326> changing the line to:  dropWhile' p = foldr (f p) mempty  -- compiles with undefined f at least, so I guess I can continue...
13:13:58 <fen> :t foldr
13:13:59 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
13:14:04 <nshepperd> or rather, it probably wants to infer a type *without* quantified constraints
13:14:31 <fen> x :: a
13:14:45 <fen> b :: [a]
13:15:17 <nshepperd> and hence tries to discharge the constraint and notices that in fact 'forall a. Convertable a t' isn't true
13:15:58 <fen> its strange how the type error is trying to determine a superclass constraint
13:17:25 <nshepperd> 'Could not deduce (Convertable a1 t)' says that it's trying to find the instance for "forall a. Convertable a t"
13:21:45 <fen_> is there a reason it compiles?
13:22:19 <fen_> it shouldnt, right?
13:25:00 <fen_> is there a good name for the class that specifies the associated type R with no other functions or associated types?
13:25:31 <fen_> class R (r :: * -> *) (f :: * -> *) | f -> r
13:25:51 <merijn> fen_: At that point why bother with a class?
13:26:58 <fen_> what if it was; class R' (f :: * -> *) where type R f :: * -> *
13:27:50 <merijn> fen_: Still? Why have a class rather than just defining a type family?
13:28:08 <fen_> because not all `f' have an instance?
13:28:18 <merijn> So, closed type family
13:29:13 <fen_> well, it should be a constraint to subclasses that it has this associated type
13:29:38 <merijn> fen_: Associated types are just syntactic sugar for regular type families
13:30:19 <fen_> hmm, well it would be better as an open type family as then instances can be defined in other modules
13:30:44 <fen_> and then better still to be able to use it as a constraint that this instance is written
13:31:49 <wroathe> The experience of writing that download file function has been humbling :P The solution was to stop thinking about how to do it in terms of Conduit, and use a function that didn't return a conduit source...
13:31:53 <wroathe> https://gist.github.com/JustinChristensen/97b5a338b333524cd9331784968437bc
13:32:03 <fen_> ok, well without knowing what it means its hard to think of a name... its supposed to capture the additional information retrived along with `a' of Traversable f => f a
13:32:13 <fen_> ok, well without knowing what it means its hard to think of a name... its supposed to capture the additional information retrived along with `a' of Traversable f => f a
13:32:52 <wroathe> Unless conduit has a way to handle shortcircuiting I can think of very few use cases for the httpSource function in http-client...
13:33:20 <fen> (R a -> f (R b)) -> t a -> f (t b)
13:36:49 <fen> maybe it would be reasonable to think of R as a "structure" so that the class providing it could be the "Structured" class...
13:37:02 <fen> in that it gives a structure to the container
13:37:25 <fen> and that the structure directing index R can be used during traversal 
13:38:45 <merijn> hmm, I need a data structure recommendation
13:39:21 <suzu> finger tree
13:39:23 <fen> and, if the structure director of another Structured container is given, then the traversal can be abstracted to "convert" between 2 Structured containers
13:39:32 <merijn> I have a series of key value pairs, when I lookup a key I want the value for the maximum key that's <= the key I'm asking for
13:39:57 <suzu> binary search tree
13:40:03 <Welkin> so it must have an Ord constraint then
13:40:35 <suzu> merijn: what kind of insert/delete performance do you desire?
13:40:42 <fen> class Structured t => Convertable t where converter :: (Structured t' ,Applicative f) => (R t a -> f (R t' b)) -> t a -> f (t' b)
13:40:45 <merijn> I was using Map + findWithDefault before, but that doesn't work
13:41:11 <merijn> suzu: They're compiletime static, I just want the least effort to implement this :p
13:41:20 <suzu> a sorted vector
13:41:23 <fen> how awesome is that!?
13:41:55 <suzu> if it's static you could just precompute the answers. lol
13:42:03 <merijn> suzu: But then I have to write all the binary searching logic myself >.>
13:42:21 <merijn> suzu: I was hoping someone had some cool trick with the Map API to do what I want
13:42:25 <suzu> how about a sorted vector
13:42:39 <suzu> you can ask the map for the keys in sorted order
13:42:56 <Welkin> a red-black tree using a zipper
13:42:56 <fen> Welkin: an Enum instance no?
13:43:14 <fen> :t pred
13:43:16 <lambdabot> Enum a => a -> a
13:43:52 <geekosaur> osm
13:43:52 <merijn> Welkin: I don't want to actually implement all that jazz, I don't care enough about performance..
13:44:02 <geekosaur> I thought Map had such a lookup already
13:44:19 <merijn> geekosaur: I dunno, I was hoping someone would tell me that :p
13:44:34 <Welkin> well, you could partition the Map, then take the maximum
13:44:46 <Welkin> paritition/filter
13:45:08 <geekosaur> http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Map-Lazy.html#v:lookupLE and friends
13:45:12 <geekosaur> also strict versions
13:45:17 <fen> hmm, that would give an Enum instance sort of
13:45:22 <merijn> geekosaur: \o/
13:45:24 <geekosaur> LT, LE, GT
13:45:52 <Welkin> I've not seen that function before
13:46:02 <geekosaur> been there for quite a while
13:46:08 <geekosaur> think it was even pre-containers
13:46:17 <geekosaur> (that is, when Data.Map was in base)
13:46:30 <Welkin> of course I don't know every function in any library
13:46:33 <Welkin> there are too many
13:48:36 <Welkin> has anyone changed the open file limit on macos before?
13:48:41 <wroathe> Welkin: And I had such expectations of you
13:48:48 <wroathe> such high*
13:49:23 <fen> is (b -> f a -> f b) anything other than Functor?
13:50:09 <fen> like, would a class providing this function be something Functor could have as a superclass?
13:51:44 <fen> oh, and is there any way to get `f a' to only contain 1 `a'. like so that; f a == return (extract (f a))
13:51:55 <merijn> fen: That already exists with just Functor
13:52:01 <merijn> :t (<$)
13:52:02 <lambdabot> Functor f => a -> f b -> f a
13:52:11 <merijn> > True <$ Just 'c'
13:52:12 <fen> so it would be a class defined by that function
13:52:14 <lambdabot>  Just True
13:52:27 <fen> and it seems strictly less powerful than Functor
13:52:54 <fen> as it might not be able to give anything of type b to act on
13:54:27 <fen> :t const . return :: Monad m => a -> m b -> m a
13:54:29 <lambdabot> Monad m => a -> m b -> m a
13:55:15 <fen> obviously a monad is a functor, but there could be a class defined by just something with the same type as return...
13:55:26 <merijn> fen: What would the laws be?
13:56:08 <fen> <$ a (create b) == create a
13:56:41 <fen> create :: Create f => a -> f a
13:57:14 <fen> not sure if the class defined by <$ would have a create superclass, probably not
13:57:47 <fen> so its difficult to give laws without needing disjoined constraint
13:57:56 <merijn> fen: But that's literally just the Functor law and <$ already exists with just Functor...
13:58:24 <fen> that was the law for create, not for <$
13:58:25 <merijn> Well, I guess technically Create would be Applicative
13:58:33 <Solonarv> Create is Pointed
13:58:42 <fen> ooh, wheres that?
13:58:43 <Solonarv> class Pointed f where point :: a -> f a
13:58:44 <merijn> Solonarv: Pointed is a shitty pointless class anyway
13:58:52 <hpc> Pointed was removed because its only law was a free theorem
13:59:06 <hpc> literally every definition with the type of point satisfied the law
14:00:08 <fen> that doesnt mean a class of just <$ is useless
14:00:22 <geekosaur> removed?
14:00:34 <geekosaur> thought it never existed as such
14:00:52 <fen> what about the 1 value container?
14:01:05 <fen> is there a way to implement that other than with laws? 
14:01:18 <fen> which hardley counts as an implementation...
14:01:37 <Solonarv> Pointed certainly exists, it's just not in base. And (AFAIK) not a dependency of any of the usual zoo of packages.
14:01:41 <hpc> geekosaur: hmm, maybe it never was in base
14:01:52 <Solonarv> fen: what do you mean by "implementation"?
14:01:55 <hpc> maybe it was a proposal?
14:02:23 <Solonarv> 'newtype Identity a = Identity { runIdentity :: a }' is a one-element container, but I assume that isn't what you're looking for.
14:02:25 <hpc> fen: the definition of a type class is its kind, any additional class constraints (like Applicative needing Functor)
14:02:26 <geekosaur> I mean, relative to Typeclassopedia implying it should be at the base of the standard typeclass hierarchy
14:02:29 <hpc> its methods and their types
14:02:33 <hpc> and the documented laws
14:02:35 <fen> Solonarv: wasnt there a way to get the monad laws to be satisfied by actual classes not just comments?
14:02:39 <geekosaur> after the fact is not necessarily helpful
14:03:01 <hpc> the laws exist because the type system isn't powerful enough to express their constraints
14:03:04 <fen> Solonarv: it would be a constraint that Identity would satisfy
14:03:23 * hackage chiasma 0.1.0.0 - tmux api  http://hackage.haskell.org/package/chiasma-0.1.0.0 (tek)
14:03:25 <hpc> in a language like agda, you have to provide mechanical proof when defining a functor that it's a law-abiding instance
14:03:34 <Solonarv> In Haskell, we can't do that.
14:03:37 <hpc> and the type system is powerful enough to know if it's right
14:03:57 <hpc> languages with that level of static analysis power are necessarily not turing-complete
14:04:26 <fen> huh, must have got confused about the result of having Monad defined over Categories
14:04:36 <fen> thought that made the laws kind of manifest somehow
14:04:51 <fen> never really uderstood how though...
14:06:07 <fen> hpc: isnt there a subset of haskell where halting proofs are given by the user?
14:06:38 <hpc> possibly, but i haven't heard of it
14:06:49 <hpc> liquid haskell is the closest i can remember, but it's still quite different
14:06:55 <hpc> it's just haskell with refinement types iirc
14:07:55 <fen_> ooh, that sounds good
14:09:13 <fen> {-@ LAZYVAR z @-}
14:09:19 <fen> not lazy by default?
14:09:42 <fen> hmm, this is getting too complicated 
14:10:16 <fen> not sure its even necessary to restrict R to have just one value...
14:11:04 <fen> what about the question about the class defined by <$
14:11:07 <fen> whats that?
14:11:22 <fen> some kind of not quite a functor
14:12:46 <fen> just not sure about giving the associated structure a functor constraint...
14:13:48 <fen> as it has only one value thats equivalent to `R f a -> a' and `a -> R f a -> R f a'
14:14:15 <fen> but then, maybe there are some R f that have only one of those but not the other
14:14:31 <fen> `a -> R f b -> R f a'
14:15:18 <fen> seems unlikely that `R f a -> a' wouldnt be available...
14:16:22 <fen> but certainly, getting he functor implementation by combining those types is more powerful than just demanding a Functor instance, as it gives extract
14:18:30 <Solonarv> not every '(a -> b) -> f a -> f b' is a valid fmap, it needs to be law-abiding too
14:19:13 <fen> was thinking it could give a good law to define the 1 value container
14:20:06 <fen> that a valid fmap is given by extract then create, but where create is <$ over the original container
14:20:19 <fen> wait thats confusing, 1 sec
14:20:36 <Solonarv> 'pure . extract = id' should characterize one-value containers, I think.
14:21:14 <fen> :t \f xs -> (f (extract xs)) <$ xs
14:21:16 <lambdabot> error:
14:21:16 <lambdabot>     Variable not in scope: extract :: f b -> t
14:21:28 <fen> % :t \f xs -> (f (extract xs)) <$ xs
14:21:29 <yahb> fen: forall {f :: * -> *} {b} {a}. Comonad f => (b -> a) -> f b -> f a
14:22:02 <fen> this doesnt need pure
14:22:09 <fen> as an inverse of extract
14:22:18 <fen> just a kind of replace given by <$
14:22:25 <dmwit> Why do we need laws for one-value containers?
14:22:45 <merijn> hmmm
14:22:52 <merijn> -dth-dec-file doesn't seem to do anything?
14:22:59 <fen> well, there was this R f associated type, which was got during a traverse, and so only had one value
14:22:59 <dmwit> And once you convince me of that, my next question is: Why is "there is an isomorphism to Identity" not sufficient?
14:23:10 <aplainzetakind> I once took an advice and used stack to install everything and not have any system-wide packages to avoid conflicts. But I'm tired of the headache stack keeps giving me. Can I use cabal sandboxes to achieve the same promised flexibility? How do you guys manage things?
14:23:27 <amx> just use cabal new-*
14:23:31 <fen> "
14:23:31 <dmwit> You can. But I recommend cabal's v2-* instead of sandboxes.
14:23:55 <fen> its not isomorphic to identity
14:24:17 <fen> because its obtained during trarversal, it has extra information describing the structure of the container
14:24:47 <fen> thats why its not nesacarily natural to consider the pure/point/return/create (cokliesli) function
14:24:56 <fen> its only created during a traversal
14:25:07 <Solonarv> dmwit: I think fen's looking for "a set of laws such that anything satisfying them is iso to Identity"
14:25:25 <dmwit> Solonarv: Does my proposed law not have that property?
14:25:41 <fen> Identity has pure
14:25:44 <fen> this doesnt
14:26:12 <Solonarv> dmwit: well, it does, but perhaps there are other sets of laws which are equivalent to yours?
14:26:20 <fen> if (i,a) is obtained during traversal at each value, and i is not a monoid, or at least, has no default
14:26:31 <fen> then there is no a -> (i,a)
14:26:32 <merijn> Solonarv: If they're equivalent, you might as well use his
14:26:40 <dmwit> Solonarv: No objection to that claim. But it doesn't answer the question: why should we care about other sets of laws?
14:26:51 <Solonarv> I don't know, I don't live in fen's head!
14:27:26 <fen> hang on, whats this question?
14:27:43 <dmwit> My question is: why is there a question being discussed at all here?
14:28:00 <fen> well thats certainly not to do with laws!
14:28:24 <dmwit> It has to do with laws iff the question being discussed has to do with laws. =)
14:28:33 <fen> seems like there is something that isnt a functor here
14:28:47 <merijn> fen: I don't think any of us follow where "here" is
14:29:08 <fen> such as this example of a one value container obtained during traversal
14:29:55 <merijn> A more pragmatic question: I'm trying to beat new-build into dumping my TH splices somewhere to read, but it doesn't seem to wanna obey
14:30:10 <fen> class Structured (f :: * -> *) => type R f :: * -> *
14:30:13 <fen> class Structured t => Convertable t where converter :: (Structured t' ,Applicative f) => (R t a -> f (R t' b)) -> t a -> f (t' b)
14:30:14 <dmwit> merijn: Oh, I know this.
14:30:22 <nshepperd> i sometimes thought it would be amusing to have 'class Traversable t => Lensable t where { lensit :: Functor f => (a -> f b) -> t a -> f (t b) }'
14:30:25 <dmwit> merijn: -ddump-splices -ddump-to-file, I think
14:30:39 <merijn> dmwit: Did that, can't find any actualy files
14:30:45 <dmwit> merijn: Then you need to convince it to re-execute the TH; I usually do this by deleting the appropriate directory from dist-newstyle
14:30:51 <merijn> dmwit: Also, how would I ensure they don't clobber eachother
14:30:54 <Solonarv> cabal -v should give you some more information about which directories cabal is doing stuff in
14:31:01 <monochrom> Hrm, would you need a lot of --ghc-options?
14:31:06 <nshepperd> which is basically the typeclass of one-value containers
14:31:15 <nshepperd> but in practice i don't think anyone would use it
14:31:16 <dmwit> merijn: What is "they"? Each splice gets dumped in a file named after the file that has the splice.
14:31:25 <dmwit> merijn: e.g. Foo/Bar/Baz.hs-splices
14:31:27 <dmwit> or something like that
14:31:39 <dmwit> merijn: (But they get dumped in dist-newstyle, of course.)
14:31:42 <Solonarv> nshepperd: oh-ho!
14:32:10 <merijn> dmwit: oh, I was under the impression the -ddump-to-file took a file argument
14:32:16 <dmwit> nope
14:32:42 --- mode: ChanServ set +o monochrom
14:32:58 <dmwit> :t each
14:33:00 <lambdabot> (Applicative f, Each s t a b) => (a -> f b) -> s -> f t
14:33:04 <fen> wait, it *is* a functor, but only if it has (f a -> a) and (a -> f b -> f a) as fmap can be defined using these, and the question was about these functions and how the second of them seems to be a Functor superclass
14:33:15 <vaibhavsagar> Is there an AArch64 build of GHC 8.6.3?
14:33:15 <nshepperd> you could make typeclasses for all the rest of the lens hierarchy too, I suppose, by just taking Traversable and blindly replacing Traversal with Lens, Iso, Prism, etc...
14:33:27 <vaibhavsagar> the downloads page implies there is but that link goes nowhere
14:33:34 <nshepperd> I suppose Iso gives you the typeclass for 'things isomorphic to Identity'
14:34:02 --- mode: monochrom set -o monochrom
14:34:47 <dmwit> nshepperd: Isn't `traverse` already `lensit`?
14:35:06 <nshepperd> traverse requires Applicative
14:35:09 <dmwit> I see.
14:35:29 <fen> but those are 1 value containers that are functors...
14:35:57 <Solonarv> fen: can you provide an example of a "one-value container" that isn't a functor?
14:36:28 <merijn> Literally every (parametric) 1 value container is a function
14:36:38 <fen> aha
14:36:41 <fen> proof?
14:36:50 <merijn> Proof by handwave
14:36:56 <dmwit> merijn: `(Bool, a)`?
14:38:18 <fen> a const like container could forget the value provided to it during create
14:38:20 <merijn> dmwit: That's a functor
14:38:41 <fen> but thats a 0 value container...
14:38:41 <hpc> ah, you typo'd functor as function
14:39:33 <fen> you could store it in a map and not store the key
14:39:42 <merijn> hpc: Typing well is for suckers
14:39:49 <merijn> wut?
14:39:52 <hpc> typing is what ghc is for :D
14:39:59 <fen> and then could create another but not fmap over it. and get <$ but not fmap
14:40:09 <merijn> "(,) Bool" is clearly a container of single values
14:40:35 <monochrom> It can be proved fairly easily.  Fix an object A.  Then F(X) = A*X is a functor because * is a bifunctor.
14:41:35 <monochrom> And this works for all A for example if you imaginae A = Bool*Char*Integer*(Double->String) it still works.
14:43:40 <fen> and every type can be decomposed into a pair of everything else and the type to be fmapped over?
14:44:03 <monochrom> \∩/ I killed the conversation!
14:44:11 <Solonarv> every one-value container, not ever