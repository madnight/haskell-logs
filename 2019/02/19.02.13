00:00:01 <cads2> looks like it
00:00:08 <cads2> lemme try in a new terminal
00:04:37 * hackage gnuplot 0.5.6 - 2D and 3D plots using gnuplot  https://hackage.haskell.org/package/gnuplot-0.5.6 (HenningThielemann)
00:04:52 <cads2> I misreported earlier - stack --version reports 1.5.1 in the terminal showing the error, even though `which stack` showed the correct path . So I created a new terminal, did cd ~/src/lang/futhark. Now stack --version reports 1.9.3
00:05:37 * hackage multipool-postgresql-simple 0.1.0.2 -   https://hackage.haskell.org/package/multipool-postgresql-simple-0.1.0.2 (IanDuncan)
00:05:42 <cads2> I did `stack setup` and it downloaded a copy of of GHC to an 'isolated location' - I'm going back to the futhark installation instruction to see if this was the expected behavior
00:05:52 <Athas> That PATH caching is the worst bash feature.
00:06:33 <cads2> I suspect that `which stack` was simply not reporting correctly, and bash was pointing to the global stack install
00:07:06 <Athas> Yes, 'which' is a separate program that is not affected by bash's PATH cache, so you cannot trust it.
00:07:10 <cads2> Athas, I never knew that bash and `which`  could disagree like that
00:07:28 <cads2> also, the $PATH variable is correct
00:07:55 <Athas> Yeah, but bash caches the contents of the variable (or rather, the contents of the directories it contains) for its lifetime, or until you run 'hash -r'.
00:08:06 <suzu> off-topic but bash is actually garbage
00:08:21 <suzu> zsh or fish or other shell replacements are years better
00:08:25 <cads2> I bet `which` resolves things according to the $PATH variable while.... holy shit Athas is that /actually/ the behavior?
00:08:53 <cads2> suzu, I feel like I will literally save years from my life if I make the switch, jfc
00:08:59 <Athas> cads2: as far as I have been able to determine over a handful of rage-filled epiphanies, yes.  I haven't checked the source code.
00:09:08 <suzu> cads2: i recommend fish, it's prob saved me years of life
00:09:19 <suzu> history auto-complete is A++
00:09:34 <Athas> From 'man bash': "Bash uses a hash table to remember the full pathnames of executable files (see hash under SHELL BUILTIN COMMANDS below).  A full search of the directories in PATH is performed only if the command is not found in the hash table."
00:09:34 <ivan> https://github.com/zsh-users/zsh-autosuggestions
00:10:01 <cads2> suzu, gonna try fish!
00:13:32 <cads2> wow suzu, I have been using fish for literally  30 seconds and already I feel much rejuvenated by the history completion feature!
00:13:59 <suzu> lol im glad
00:14:06 <suzu> yeah its real nice
00:14:21 <cads2> holy moly this thing knows the command options I want before I do
00:14:34 <suzu> try typing in `ls -<tab>`
00:14:48 <suzu> and watch it tell you what all the switches are
00:14:56 <suzu> that's parsed from the manpage iirc
00:15:04 <suzu> so it works with a lot of things
00:15:09 <cads2> PARSED FOMR THE FFFFFFF MANPAGE?!?!?!
00:15:15 <suzu> :D
00:15:17 <cads2> *EXPLODES*
00:15:39 <cads2> suzu, I will have to buy you a drink one day
00:15:47 <suzu> yeah just double checked, it is parsed from the manpage
00:15:58 <suzu> haha okay. you dont live in Canada, do you?
00:16:27 <cads2> noop, but I plan to one day become an internation cads of mystery
00:17:28 <suzu> okay
00:17:34 <suzu> now try this: `fish_config`
00:17:55 <suzu> it will spin up a web ui for configuring fish and navigate you to it in your browser
00:18:49 <cads2> I'm trying very hard to keep tears out of my eyes at this point, lol
00:19:10 <cads2> this is magnificent.
00:19:18 <suzu> bash is hot garbage
00:19:29 <suzu> i install fish on all my remote servers too <_<
00:19:43 <jstsmthrgk[m]> Hello, I would like to read a file of 16bit integers into an Array (as a function FilePath -> IO UArray Int16) , but I have no idea how.
00:20:13 <suzu> jstsmthrgk[m]: how far have you gotten?
00:21:15 <jstsmthrgk[m]> i can do FilePath -> IO [Int16], but I don't know how to efficiently put it into an array
00:22:04 <suzu> how large is your file?
00:22:19 <suzu> UArray will keep all of it in memory, fyi
00:23:10 <jstsmthrgk[m]> it's raw audio, so 88,2kB per second, not more than 10 seconds so less than 882kB
00:23:24 <suzu> okay
00:24:36 <suzu> do you know how many entries there are?
00:25:17 <suzu> i think you'll want to use listArray
00:25:24 <suzu> listArray :: Ix i => (i, i) -> [e] -> Array i e 
00:25:26 <jstsmthrgk[m]> 44100 per second, so less than 441000
00:25:51 <Ariakenom> computable from file size maybe?
00:25:58 <suzu> err my mistake
00:26:06 <suzu> you want /this/ listArray
00:26:08 <suzu> listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e 
00:26:32 <suzu> from Data.Array.IArray
00:27:43 <suzu> you give it a pair of bounds, the list of elements, and it'll produce an array in the array-type you want containing those elements
00:27:50 <jstsmthrgk[m]> so the
00:28:10 <jstsmthrgk[m]> sorry: so the list will be optimized away?
00:28:37 <suzu> n..o. i dont think so
00:28:59 <suzu> is the list lazy?
00:29:24 <suzu> how are you reading your elements into a list?
00:31:03 <jstsmthrgk[m]> just like the getTrades example in the Data.Binary.Get documentation
00:32:40 <suzu> yes, i think elements of the list are discarded from memory as the array is constructed - so long as you do not reference this list again, and that the list is not bound in a 'let' statement
00:34:30 <suzu> though to be certain of this you'd need to measure via prof / inspect the compiled Core, depending how much you care
00:35:14 <jstsmthrgk[m]> i don't really care that much, but thank you!
00:35:31 <suzu> yw
00:35:41 <suzu> you can be quite certain that it will be gc'ed when the list has completely left scope
00:35:46 <suzu> at the very least
00:37:36 <jluttine> What names are there for an operation like this: f m a -> m f a ? That is, it swaps the order of the structures. At least distribute and sequence I've found. Any other? I suppose Monad isn't enough to support this, right?
00:38:27 <Solonarv> jluttine: I'm pretty sure that doesn't kind-check, did you mean: f (m a) -> m (f a) ?
00:38:47 <suzu> isnt that traverseM or some shit
00:39:01 <Solonarv> :t sequenceA
00:39:03 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
00:39:04 <MarcelineVQ> suzu: sequence like jluttine mentioned
00:39:11 <suzu> oh yeh
00:39:27 <Solonarv> (sequenceA is more correct, really - you don't need Monad, Applicative is enough!)
00:40:50 <Lears> If I were looking for a name for a general `f (g a) -> g (f a)` the operation I'd call it transpose. sequence is overspecific.
00:40:58 <Lears> -the
00:42:52 <MasseR> :t distribute
00:42:53 <lambdabot> error:
00:42:53 <lambdabot>     • Variable not in scope: distribute
00:42:53 <lambdabot>     • Perhaps you meant ‘distrib’ (imported from Control.Lens)
00:43:14 <MasseR> distribute :: Functor f => f (g a) -> g (f a)
00:46:28 <Solonarv> no, it's: distribute :: (Distributive g, Functor f) => f (g a) -> g (f a)
00:46:37 * hackage comfort-array 0.3.1 - Arrays where the index type is a function of the shape type  https://hackage.haskell.org/package/comfort-array-0.3.1 (HenningThielemann)
01:00:20 <MasseR> Solonarv: true, I just copied the class method type
01:35:20 <gentauro> how does hackage handle `non-mantained` packages? For example in `elm-lang`, when a new `major release` is made, packages needs to be ported to it. If they don't, the package isn't available in the new version. That way they ensure `maintainers` care about their packages ...
01:36:03 <Athas> gentauro: Hackage does nothing about non-maintained packages.  They just stick around forever, and don't build.
01:36:28 <gentauro> Athas: pfffff, that's actually rubish :(
01:36:41 <Taneb> gentauro: it makes it more likely an unloved package will get a new maintainer
01:37:24 <gentauro> Taneb: that's how it goes with `elm-lang`. Somebody takes over (copy/pasta) and works with the package (if they really care)
01:37:33 <Athas> It's not a big deal in practice.  I don't think many people are picking packages by scrolling through the full Hackage list.
01:37:47 <phadej> gentauro: https://wiki.haskell.org/Taking_over_a_package
01:38:03 <Athas> Besides, GHC is so unstable that many people stick with older versions for a long time, so unmaintained packages on Hackage may work fine.
01:39:17 <gentauro> Athas: I tried GHC 8.6. .. and I had to revert back to 8.4 :|
01:39:40 <gentauro> I guess it's like Ubuntu LTS (or in other words `Debian`) ;)
01:41:30 <Athas> I tried GHC 8.6.3 and had to switch back to 8.6.2.
01:41:57 <Athas> There was a time when I had to use three different GHC versions simultaneously for the same program, but for different systems.  I did not enjoy that.
01:42:49 <Solonarv> yeah, I also had to switch back to 8.6.2 from 8.6.3
01:45:06 <Athas> My life would be a lot easier if I just didn't care about Windows!
01:45:47 <gentauro> phadej: I like there is like in business a `a hostile takeover` xD with regard of packages if the maintainers does not respond :o
01:46:07 <gentauro> have anybody done that and the maintaner was actually on holidays and got mad?
01:46:57 <gentauro> Athas: can't you just assume that Windows users have installed the `Linux` bash thingy?
01:48:13 <Athas> gentauro: I'm afraid not.
01:48:58 <Solonarv> that's just a different shell, it doesn't run linux-native binaries
01:49:28 <Solonarv> on win10 there is WSL for running linux binaries natively, but it has a bunch of restrictions ("on win10" is one of them!)
01:51:48 <tdammers> I think "the linux bash thingy" referred to WSL
01:52:40 <Solonarv> well I have a "linux bash thingy" and it certainly isn't WSL!
01:52:52 <Solonarv> (it's git bash, which is mingw + some bells and whistles)
01:55:38 <tdammers> yeah, I know that one
01:56:01 <tdammers> though that has absolutely zero linux in it
01:57:27 <Solonarv> "absolutely zero" is a bit of a strong claim, it does come with a bunch of linux-y tools
02:01:20 <tdammers> which aren't linux in any way, same tools can be had on OSX, FreeBSD, and a bunch of other OSes
02:01:46 <tdammers> it's just bash with a typical *nix userland ported to Windows
02:03:17 <yushyin> so WSULUL :D windows subsystem for unix-like userland
02:05:40 <gentauro> Solonarv: I don't use Windows anymomre, but people told me that they got a `real Linux bash`. That's why I refer to it as the `Linux bash thingy`
02:06:05 <gentauro> but I wouldn't know (or really care) :)
02:07:21 <Solonarv> WSL is almost but not quite entirely unlike a VM, by default it has some variant of ubuntu on it I think
02:07:34 <phadej> gentauro: holidays no: if you read properly the time spans are quite long
02:08:13 <earthy> WSL is a compat layer shimming as much of the linux kernel interface as is feasible onto a windows kernel
02:09:00 <earthy> in userland, for very many intents and purposes, WSL is indistinguishable from running on an actual linux kernel
02:09:21 <tdammers> it's kind of like Wine, but in the opposite direction
02:09:32 <earthy> by default, WSL furthermore installs a small ubuntu userland.
02:10:08 <aplainzetakind> When I write `data Foo = Bar` with DataKinds, I automatically get a type Bar with kind Foo right? But the value-level Bar has type Foo. Is there any value with type Bar then?
02:10:37 <Solonarv> aplainzetakind: no, there is not
02:11:12 <gentauro> phadej: so the only real thing to do is a `git clone` and then just call the package the initial name + prime? :-)
02:11:24 <Ariakenom> Solonarv: But how would you compare it to tea?
02:11:55 <Solonarv> if T is the type of a value, then T's kind must be Type (aka *)
02:12:00 <kritzefitz> aplainzetakind, AIUI there are only values with a type of king *.
02:12:08 <Solonarv> (note: this is a slight simplification)
02:12:42 <Solonarv> Ariakenom: I don't know, I haven't tried drinking it!
02:12:50 <Solonarv> I suppose that makes it quite unlike tea.
02:12:55 <aplainzetakind> :k Int#
02:12:56 <lambdabot> error:
02:12:57 <lambdabot>     Not in scope: type constructor or class ‘Int#’
02:12:57 <lambdabot>     Perhaps you meant one of these:
02:13:03 <Ariakenom> :)
02:13:07 <phadej> gentauro: no, real thing is to git clone and use that; and in parallel start the take over process if that's appropriate
02:13:21 <kritzefitz> Ah, yes. Unboxed primitive are an exception.
02:13:46 <phadej> the fact that something doesn't support GHC-8.6 yet, is really not a reason to make "public" forks
02:13:59 <Solonarv> the more general statement is: the type a value must have kind TYPE r, for some r
02:14:17 <Solonarv> *type of a value
02:15:07 <Solonarv> i.e. if (e :: t) then (t :: TYPE r) (for some r)
02:15:08 <aplainzetakind> So these non-* kinded types that are created are only useful to make types more expressive (very vaguely put)?
02:15:57 <Solonarv> they allow us to more precisely represent data at the type level
02:16:19 <aplainzetakind> Types become data?
02:16:22 <gentauro> phadej: well it's obviously not that it's not upgraded, it's more that the maintainer doesn't respond ... In my book, that's cos the package is unmaintaned
02:16:39 <Solonarv> aplainzetakind: data becomes lifted to the type level
02:17:05 <Solonarv> the classic example is vectors/lists with their length encoded in the type
02:17:17 <phadej> gentauro: have you tried to send an email to the maintainer?
02:18:57 <phadej> gentauro: note the difference, elm-lang "forces" everyone to use latest version of a compiler; on Hackage we don't
02:20:42 <aplainzetakind> Solonarv: I'm trying to understand that actually. But something else is needed to be able to say something like "vconcat is a function that takes an n dimensional vector and an m dimensional vector and produces an (m + n) dimensional vector", right?
02:21:48 <Solonarv> you can pretty much just write that down as a type: vconcat :: Vec m a -> Vec n a - Vec (m + n) a
02:23:52 <aplainzetakind> How does (+) get lifted?
02:24:05 <Solonarv> it doesn't (at least, not automatically)
02:24:32 <aplainzetakind> Ah, m + n the number gets lifted to a type
02:24:45 <Solonarv> also no!
02:24:55 <aplainzetakind> m the type and n the type gets added?
02:25:12 <Solonarv> assume a definition like 'data Nat = Zero | Succ Nat' (with DataKinds)
02:25:57 <Solonarv> then you can define 'type family (+) (m :: Nat) (n :: Nat) :: Nat where Zero + n = n; Succ m + n = Succ (m + n)'
02:27:11 <aplainzetakind> But this explicitly defines a type level operation.
02:27:19 <Solonarv> indeed.
02:27:49 <Solonarv> if you're using the Nat from GHC.TypeLits (and the accompanying operations), + is already defined
02:27:59 <Solonarv> (and implemented using compiler magic, essentially)
02:28:48 <aplainzetakind> Solonarv > you can pretty much just write that down as a type: vconcat :: Vec m a -> Vec n a - Vec (m + n) a  <-- so this doesn't automatically work with `Int`s, or does it?
02:29:19 <Solonarv> no, in fact there is no way (currently) to make it work with Int!
02:29:55 <aplainzetakind> Alright, I think I got it. Thanks.
02:30:10 <Solonarv> this is in part what Richard Eisenberg's thesis (Dependent Haskell) is about
02:31:18 <gentauro> tdammers: a few days ago I asked if there was a similar functionality to F# Code Quotations and you suggested `Haskell Template`. I have digged a bit into it and I don't think it's equivalent. In the following example, I write F# code (that doesn't compile, type-safety for the win) and therefore the `<@@ .. @@>` do as well. WHile with Haskell Template, it just seem to bypass any type-checking. Is this 
02:31:24 <gentauro> correctly understood? If yes, then Haskell Template is not it for me -> http://dpaste.com/13AH8MG
02:31:59 <gentauro> then I would rather go back to `Language.Haskell.Exts.parseFileContents` and go through all the branches
02:32:02 <tdammers> gentauro: no, TH doesn't bypass type checking. It produces Haskell AST and injects it into the compilation pipeline, but it still gets typechecked
02:32:28 <tdammers> that is, TH produces type-agnostic output, but that output still gets typechecked after it is injected into the pipeline
02:32:46 <tdammers> so TH won't keep you from generating ill-typed AST, but that AST will then be rejected later on
02:33:39 <Solonarv> there is also typed TH, which does *not* allows you to produce ill-typed quasiquotes IIRC
02:34:00 <Solonarv> typed TH quotes use [|| blah blah ||], splices use $$(thingToSplice)
02:34:07 <tdammers> ^ yes.
02:34:25 <gentauro> Solonarv: thx
02:34:27 <tdammers> though IMO the benefit is mostly cosmetic, as in, it's easier to figure out the errors
02:34:48 <gentauro> the `[|| .. ||]` did the trick !!! (`Could not deduce (Num [Char]) arising from a use of ‘+’`)
02:34:52 <Solonarv> indeed; neither will allow you to compile ill-typed code
02:45:06 <jdemler> I have a quick question about stack: If there is a package in lts-11.x but not in lts-12.x what might be the reason for that? The dependency to base seems fine (<5)
02:46:05 <jdemler> Also, if I want to build a package that depends on base >= 4.11 and also language-glsl that is not in 12.x anymore, how do I do that?
02:46:13 <jdemler> Build it with cabal?
02:47:56 <Solonarv> jdemler: perhaps keeping the package in lts-12 would've held back the versions of some other packages
02:48:19 <Solonarv> if you want to depend on a package that isn't in the snapshot you're using, that's what the 'extra-deps' field in stack.yaml is for
02:48:52 <Solonarv> switching to cabal is of course also a solution ;)
02:50:21 <sedfox> I've heard cabal has made some significant progress over the past few years, are there any good blogposts about that?
02:56:23 <jdemler> Solonarv: thank you! Looking into it.
03:03:16 <gentauro> tdammers: and Solonarv, this is exactly what I was looking for -> http://dpaste.com/19N4V0C (thank you both) !!!
03:03:52 <jdemler> Solonarv: got it working with stack! Thanks. 
03:06:06 <gentauro> btw, can we expand the `@ lambdabot` so besides remembering `quotes` it also has the functionality to add +1 on beers I owe to people helping out xD
03:06:31 <Solonarv> @help karma
03:06:31 <lambdabot> karma <polynick>. Return a person's karma value
03:06:38 <Solonarv> @help karma+
03:06:38 <lambdabot> karma+ <nick>. Increment someone's karma
03:06:57 <gentauro> karma+ Solonarv 
03:06:57 <Solonarv> (isn't used much, though)
03:07:06 <gentauro> karma+ tdammers 
03:07:30 <gentauro> Solonarv: they should rename it to -> `oweabeer+` xD
03:07:37 <Solonarv> you need to start your message with an @ so lambdabot sees it as a command, i.e.: @karma+ person
03:07:44 <gentauro> @karma+ Solonarv 
03:07:45 <lambdabot> Solonarv's karma raised to 8.
03:07:50 <gentauro> @karma+ tdammers 
03:07:50 <lambdabot> tdammers's karma raised to 19.
03:12:17 * tdammers goes off to drink 19 beers
03:12:47 <gentauro> xD
03:13:37 <gentauro> https://www.youtube.com/watch?v=ZEvQOPUHGH8
03:15:29 <seanparsons> I'm totally baffled, I have a script that runs `cabal new-build` ultimately, if I clear `dist-newstyle` and `~/.cabal` it works fine. If I clear those folders and trigger that script from `entr` then compiling the `network` package fails with `Bad file descriptor` in its configure script.
03:16:38 <seanparsons> Now tried this several times and it happens consistently each way round, run it straight no problems, run it with entr explodes with that error.
03:20:07 * hackage lapack 0.2.2 - Numerical Linear Algebra using LAPACK  https://hackage.haskell.org/package/lapack-0.2.2 (HenningThielemann)
03:28:37 * hackage interpolation 0.1.1 - piecewise linear and cubic Hermite interpolation  https://hackage.haskell.org/package/interpolation-0.1.1 (HenningThielemann)
03:35:32 <janiczek> How to understand / where can I find definition of (#.)? https://hackage.haskell.org/package/lens-4.15.4/docs/src/Control.Lens.Setter.html#over
03:35:36 * hackage magico 0.0.2 - Compute solutions for Magico puzzle  https://hackage.haskell.org/package/magico-0.0.2 (HenningThielemann)
03:36:05 <lyxia> janiczek: https://hackage.haskell.org/package/profunctors-5.3/docs/Data-Profunctor-Unsafe.html
03:36:30 <janiczek> lyxia: thanks! Hoogle didn't show anything :shrug:
03:36:50 <Solonarv> janiczek: more generally, look through the modules imported in the module you're looking a
03:37:30 <janiczek> Solonarv: right, that seems evident but I was starting to think it's some special syntax (like forcing strict with !)
03:38:06 * hackage resistor-cube 0.0.1 - Compute total resistance of a cube of resistors  https://hackage.haskell.org/package/resistor-cube-0.0.1 (HenningThielemann)
03:39:08 <absence> how can i access values that aren't exported from my own module in ghci? for example a function in Lib with the default stack template
03:39:37 * hackage linear-circuit 0.1 - Compute resistance of linear electrical circuits  https://hackage.haskell.org/package/linear-circuit-0.1 (HenningThielemann)
03:40:35 <Solonarv> absence: :m + *SomeModule
03:40:54 <Solonarv> that will bring into scope everything that's in scope at the top level of SomeModule
03:41:21 <lyxia> janiczek: this hoogle shows some things https://hoogle.haskell.org/?hoogle=.%23
03:55:54 <Boomerang> seanparsons: Any reason for using entr over ghcid? :)
04:56:54 <absence> Solonarv: thanks!
05:43:34 <Axman6> seanparsons: which OS are you on? if it happens to be FreeBSD and you upgraded 12.0, you'll need to find versions of tools (ghc, cabal, etc.) which were compiled on 12.0 - they changed the size of inode numbers and it broke the ability to read files...
05:43:53 <Axman6> the fix might be recompiling entr
05:53:48 <Bish> when i see people writing board games in haskell people tend to use multi dimensional arrays for the board
05:53:59 <Bish> why doesn't it bother people that using that type doesn't reflect the size?
05:54:11 <Taneb> Pragmatism, I believe
05:56:12 <Bish> can't see someone who values pragmatism values haskell :D
05:58:49 <Solonarv> it bothers me a little to not have array size in types, but it would bother me more to work with size-typed arrays
05:59:22 <Solonarv> type-level numbers are not very convenient to work with in today's haskell
06:00:09 <Solonarv> and if you want to use something other than (tuples of) natural numbers to index your array, oooh boy
06:00:34 <Bish> you could also have a 64 parameters constructor for a chess board a.e
06:01:02 * Bish is just asking stupid idealistic questions though
06:01:11 <Bish> shouldn't templatehaskell be able to do something like that?
06:01:23 <lyxia> Bish: you give up quickly after trying to teach GHC that addition is commutative and associative
06:02:06 <tdammers> constructors with 64 parameters is not something GHC can handle nicely right now
06:02:12 <tdammers> same goes for tuples
06:02:49 <tdammers> surprising, maybe, but using constructors this large hits some performance edge cases in the compiler and can cause compilation times to skyrocket
06:03:19 <Solonarv> it's *especially* bad if you're using generics
06:03:20 <Bish> too bad :/
06:03:25 <oak> I thought GHC 8 brought some extensions which would ease creating type-level fixed-size arrays, but haven't looked on that myself yet
06:03:27 <Bish> type constraint would be something cool
06:03:27 <lyxia> The more invariants you try to encode statically, the more effort you need to spend to prove to the compiler that your computations preserve those invariants.
06:03:53 <tdammers> not just that; more statically-encoded invariants also make the compiler do more work
06:03:55 <Solonarv> yes, if you're just working with the same array size everywhere that's not too painful
06:04:22 <tdammers> in an ideal world, the compiler would also be able to exploit that knowledge to speed things up elsewhere, but unfortunately, GHC is not Sufficiently Smart in this regard
06:04:35 <Solonarv> @hackage vector-sized
06:04:35 <lambdabot> http://hackage.haskell.org/package/vector-sized
06:05:35 <Solonarv> this is just a bunch of newtype wrappers and assorted functions over Data.Vector.*
06:06:13 <Solonarv> so for something like a chessboard it should actually be reasonable, since there's not much size-changing going on
06:06:24 <Solonarv> (and size-changing is what's painful, mostly)
06:07:57 <tdammers> "not much", hah
06:07:59 <Bish> that sounds like a good way to save game boards
06:08:01 <Bish> doesn't it?
06:11:03 <Solonarv> yeah
06:11:34 <Solonarv> the other thing is: that library just provides newtype wrappers + smart constructors/functions preserving some invariant
06:11:41 <Solonarv> you're probably already doing that anyway!
06:12:22 <Bish> no im too stupid for haskell, i never did something real in it
06:12:32 <Bish> but im trying something easy now: writing an android game with it
06:12:37 <Bish> </irony>
06:12:44 * Bish also has no game experience
06:16:15 <Solonarv> I spend too much time reading about galaxy-brain type level stuff and not enough actually doing stuff
06:16:17 <Solonarv> probably.
06:16:18 <oppp> Hello, I have a function dogIsTall :: [Dog] -> [Dog] which is supposed to return a list of [Dog] for which a certain feature (tooTall :: Dog -> Boolean) is true. 
06:17:11 <tdammers> :t filter -- oppp
06:17:12 <lambdabot> (a -> Bool) -> [a] -> [a]
06:17:21 <Bish> oppp: filter not.tooTall
06:17:42 <oppp> how do I give a single element from [Dog] as an argument to filter? like I'm looking for a correct way to write the function " dogTooTall x = filter ((tooTall dog)==True) x"
06:18:02 <oppp> as in how do I pass a single dog to the tooTall function?
06:18:17 <lyxia> filter tooTall x
06:18:21 <tdammers> you don't; you pass the tooTall function itself
06:18:45 <marvin2> > even 2
06:18:46 <Athas> Is there a way to ask stack (or cabal-install) to generate a static binary, *without* having to modify the .cabal file by hand?
06:18:47 <lambdabot>  True
06:18:48 <oppp> oh ok, thanks! You guys rock!
06:18:51 <marvin2> > filter even [1..10]
06:18:53 <lambdabot>  [2,4,6,8,10]
06:22:23 <lyxia> Athas: how's stack --ghc-options ?
06:30:01 <seanparsons> Axman6: NixOS, what's weird is that it compiles outside of entr, I switched to nodemon and it works with that so it must be some weird interaction between entr and the configure script.
06:31:03 <Solonarv> I'm seeing the following pattern a lot in the source code of base: instance Foo Ty where { foo = tyFoo; {-# INLINE foo #-} }; foo = _implementation
06:31:26 <Solonarv> er, I mean: tyFoo = _implementation
06:31:37 <Solonarv> what's the reason for it?
06:34:36 <Ariakenom> Solonarv: maybe to have a shorter instance declaration
06:35:32 <Athas> lyxia: I vaguely recall I had to put some things into the .cabal file as well last time, but let me try...
06:47:49 <glguy> Solonarv: example?
06:50:16 <Solonarv> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Enum.html#line-464 (the Enum Int instance)
06:57:51 <glguy> Is the pattern you're asking about just the use of inline?
06:58:38 <Solonarv> I'm basically wondering: why not simply inline the definition directly, instead of having a separate function?
06:59:57 <monochrom> I have a more cynical view. They wanted to write in the style "a = b; b = actual code". Now they need an INLINE to eliminate a.
07:00:55 <monochrom> Or even, now they think they need an INLINE. Because actually GHC already does this without being hinted.
07:01:36 <Solonarv> to be fair, base is a sensible place for a "braces and belt" approach
07:02:56 <glguy> I think it's for clarity, the actual implementations have enough to them that it would be a mess to nest then under the instance, but also it gives those definitions names that can be referred to in rules
07:03:40 <glguy> I don't know if it helps that the inlined wrapper removes the I#
07:18:20 <trevortknguyen[m> Someone suggested that I take a look at the bokk Category Theory for Programmers (2017). Does anyone have any opinions on this book?
07:24:39 <Athas> Statically linking Haskell is so frustrating.  I keep getting errors about "recompile with -fPIC", but I already am!
07:25:23 <merijn> Athas: Are you linking C things that aren't compiled with it? :p
07:26:01 <Athas> merijn: no, I have only pure Haskell dependencies.
07:26:36 <Athas> And I did in fact manage to get this to link statically some days ago, by adding enough crud to the .cabal file and my command line, but I don't remember how, because it fundamentally made no sense.
07:28:06 * hackage lapack 0.2.3 - Numerical Linear Algebra using LAPACK  https://hackage.haskell.org/package/lapack-0.2.3 (HenningThielemann)
07:55:28 <Gurkenglas> How do I read all currently available data from a handle?
07:56:19 <dmwit> https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString.html#v:hGetNonBlocking gets you partway there
08:02:15 <Ariakenom> dmwit: partway?
08:04:08 <dmwit> Sure. You have to loop if it keeps giving you however much you asked for.
08:04:38 <Ariakenom> ah yes ofc
08:20:55 <wroathe> It seems that sandboxes in Cabal are being deprecated. Is there a quick way to set up an isolated package environment in a directory with the new-* commands?
08:23:56 <Solonarv> you don't need an isolated package environment with new-*, that's their wholepoint
08:24:30 <Gurkenglas> yes, hGetNonBlocking is what I wanted, except for the part where it does not work on Windows. Is hGetSome what I'd use if it's not important that all data is available immediately?
08:26:21 <wroathe> Ah, that was my understanding too Solonarv, but it seems like it doesn't quite support this use case: https://github.com/haskell/cabal/issues/3730
08:26:59 <wroathe> (in the sense that I don't want to have to create a project in a directory just to play around with some packages in ghci)
08:27:12 <phadej> use cabal new-repl -b packages
08:28:04 <Solonarv> oh hey, I'd been typing out the full --build-depends
08:28:37 <wroathe> :O That's perfect phadej. Thanks.
08:28:56 <Solonarv> (for multiple packages, you want to list them with -b foo -b bar -b baz)
08:29:18 * Solonarv mumbling: damn xy problem again!
08:30:41 <phadej> Solonarv: i think we'll eventually support -b `foo,bar,baz` too
08:30:52 <phadej> normal quote
08:30:53 <Solonarv> yeah I think I saw that mentioned
08:36:17 <zonk59> If I want to use just a small function from a lib A in my lib B but don't want to depend on lib A, can I copy the source code over or do I have to copy the whole license text etc? It's only 3 LOC.
08:37:02 <zonk59> Specifically, I want a function from criterion-measurement, which is has contrary to it's description a big dependency tree.
08:37:37 <phadej> if you _copy_ than by the book you have to do what license says
08:39:16 <zonk59> Yeah, it just seems absurd because it's a such short function.
08:39:36 <dmwit> "absurd" is a good description of much (though not all, certainly) of copyright law.
08:41:10 <zonk59> Ok, thanks.
08:43:21 <zonk59> I'm writing a benchmark tool which continuously shows confidence intervals and std errors while increasing precision with time. So you can run it and as soon as you are satisfied, you can ctrl^c it or let it run for more precision.
08:43:45 <zonk59> like bench but with lazy precision :)
08:46:40 <sm> nice!
08:49:12 <zonk59> And it's more geared to comparing functions. I'll implement hypothesis tests, so you can use it as well in test-suites, testing that two functions have different or same perf with a given confindence.
09:00:45 <fen> (a -> b -> b) -> (a -> b) -> f a -> b
09:00:59 <fen> nonempty church encoding?
09:01:13 <fen> foldable1 class?
09:02:33 <fen> there is this, but it seems wrong; http://hackage.haskell.org/package/foldable1-0.1.0.0/docs/Data-Foldable1.html
09:02:55 <fen> ie it has; foldr1 :: (a -> a -> a) -> f a -> a
09:03:19 <fen> its just not what we need when folding, we need to change the type, and so need (a -> b)
09:03:36 <fen> its like, instead of a basecase, to swap with [] when folding
09:03:49 <fen> we need something to swap with the "last" value
09:03:53 <fen> which is "create"
09:04:26 <fen> or at least, create :: a -> f a, but more generally we have a -> b
09:06:00 <fen> and there should be a version of build for this also, build1
09:06:04 <fen> % :t build g = g (:) []
09:06:05 <yahb> fen: ; <interactive>:1:9: error:; parse error on input `='; Perhaps you need a 'let' in a 'do' block?; e.g. 'let x = 5' instead of 'x = 5'
09:06:09 <fen> % :t build
09:06:10 <yahb> fen: (forall b. (a -> b -> b) -> b -> b) -> [a]
09:06:12 <fen> build g = g (:) []
09:06:24 <fen> build1 g = g (:::) create
09:07:02 <fen> where, (:::) :: Linear  f => a -> f a -> f a, create :: Linear f => a -> f a
09:07:24 <fen> with the associated build1/fold1 fusion rules
09:07:46 <fen> {-# RULES "fold/build"    forall k z (g::forall b. (a->b->b) -> b -> b) .                 foldr k z (build g) = g k z
09:07:49 <fen> becomes;
09:08:21 <fen> {-# RULES "fold1/build1"    forall k z (g::forall b. (a->b->b) -> (a->b) -> b) .                 foldr1 k z (build1 g) = g k z
09:08:41 <wroathe> Is fen a bot or something?
09:10:30 <fen> :t build1 = Linear f => (forall b. (a -> b -> b) -> (a -> b) -> b) -> f a
09:10:31 <lambdabot> error:
09:10:32 <lambdabot>     parse error on input ‘=’
09:10:32 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
09:10:43 <fen>  :t build1 = Linear f => (forall b. (a -> b -> b) -> (a -> b) -> b) -> f a
09:10:48 <fen> or i that wrong?
09:10:52 <fen> is*
09:10:58 <fen> does it need to be;
09:11:09 <fen> :t build1 =  (forall b. (a -> b -> b) -> (a -> b) -> b) -> Nonempty a
09:11:11 <lambdabot> error:
09:11:11 <lambdabot>     parse error on input ‘=’
09:11:11 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
09:11:13 <fen> ffs
09:11:14 <fen> sorry
09:11:20 <fen> build1 =  (forall b. (a -> b -> b) -> (a -> b) -> b) -> Nonempty a
09:11:29 <fen> build1 :: (forall b. (a -> b -> b) -> (a -> b) -> b) -> Nonempty a
09:12:12 <fen> build1 g = g (:|) ((:[]) :: a -> Nonempty a)
09:12:18 <fen> % :t (:|)
09:12:19 <yahb> fen: ; <interactive>:1:1: error:; * Data constructor not in scope: :|; * Perhaps you meant one of these: `Seq.:<' (imported from Data.Sequence), `:<' (imported from Control.Lens), `Seq.:>' (imported from Data.Sequence)
09:12:35 <fen>  :t (:|) = a -> Nonempty a -> Nonempty a
09:13:08 <fen> wroathe: you asking me?
09:14:21 <wroathe> fen: Yeah, I'm wondering if this sort of whiteboarding your doing is appropriate in IRC. I don't really see you asking a question in any of this...
09:14:40 <fen> there are several questions there
09:14:45 <wroathe> (But maybe I don't understand, or someone else had asked you for this earlier)
09:15:02 <fen> 1. why is the current foldable1 class wrong, is it wrong?
09:15:07 <fen> 2. is this right?
09:15:23 <fen> 3. is that a good build1 definition 
09:15:38 <wroathe> Ah, I see, I didn't understand your shorthand
09:15:41 <fen> and obviously, any kind of comments on the utility of such a thing
09:16:47 <fen> wroathe: yeah, Linear is just for "nonempty like things", basically foladable1 definitions, but with the class over the constructors instead, as this gives traversable and comonad by default. but thats established earlier soz
09:17:52 <fen> and yeah, build is at the heart of GHC. would definatly like to run this kind of query past the relevant folks, as opposed to hiding it in some bleak repo
09:19:42 <wroathe> fen: Yeah, your earlier messages to me seemed like a professor standing at a whiteboard with his back to the class talking to himself and trying to figure out his mistake while the students watch on in silence and try to figure out if he's asking questions to himself or soliciting advice
09:19:50 <wroathe> fen: Which is why I asked :)
09:20:33 <fen> it seemed like the presentation of a complete theory without need of input?
09:21:18 <wroathe> fen: Yup. I didn't get that at first.
09:21:53 <wroathe> fen: Ignore me :D
09:23:33 <fen> if it seems right just say so
09:24:12 <fen> and also, it needs a contributer to GHC.Exts if its to be incoperated...
09:26:12 <fen> seems like it could be a valid replacement for the existing Foldable1 class
09:26:40 * hackage req-url-extra 0.1.1.0 - Provides URI/URL helper functions for use with Req  https://hackage.haskell.org/package/req-url-extra-0.1.1.0 (rcook)
09:27:30 <fen> i dont want to ignore you if your the only person available to answer these questions
09:28:08 <wroathe> fen: I'm not. I'm a beginner :). That's why I didn't understand your  presentation of a theorem earlier.
09:30:15 <fen> ok
09:35:36 * hackage tasty-quickcheck-laws 0.0.2 - Pre-built tasty trees for checking lawful class properties using QuickCheck  https://hackage.haskell.org/package/tasty-quickcheck-laws-0.0.2 (nbloomf)
09:58:57 <Gurkenglas_> how do i split the first line from a string?
09:59:32 <Gurkenglas_> does some gloss-like give me a handle for the characters coming in?
09:59:42 <Gurkenglas_> (or a pipe for the events)
10:02:27 <monochrom> I don't know gloss.  But try "break" or "span" or something in Data.List.Split.
10:04:30 <dmwit> Gurkenglas_: Huh. This, together with your last question, makes me nervous.
10:04:41 <dmwit> Gurkenglas_: Perhaps you should just be setting LineBuffering on your handle and calling getLine.
10:05:21 <boj> curious why this would error out:  let f = liftIO . makeJWT -- from servant-auth-server
10:05:24 <Gurkenglas_> ah no the last question was about the handle i have on a subprocess, this one is about the user input i'm getting
10:05:46 <Gurkenglas_> (*the output handle i have on a subprocess)
10:05:49 <monochrom> Actually getLine gives the program the same thing regardless of buffering. Bufferring here affects the human user instead.
10:06:29 <Gurkenglas_> I would also do span but wasn't there a thing about newlines being different between operating systems
10:06:29 <monochrom> OK OK, performance is affected too.
10:06:57 <monochrom> System.IO already shields you from this unless you set binary mode.
10:06:58 <monochrom> READ THE DOCS
10:07:21 <monochrom> or you set text mode but then manually choose the wrong newline mode
10:09:54 <monochrom> In fact, read the docs and don't read blogs. Many bloggers are wrong.
10:19:39 <glguy> Docs written by people who only just implemented the thing; blogs written by people who only just learned it \o/
10:21:40 <wroathe> glguy: Sometimes the latter group empathizes with what pain points a new user will encounter better :P
10:21:52 <wroathe> I'm finding https://markkarpov.com/tutorial/th.html to be a nice little intro to TH
10:22:03 <geekosaur> boj, my first suspicion would be monomorphism; doesn't nrmally affect let, but maany type level things turn on MonoLocalBinds
10:24:06 * hackage opml-conduit 0.7.0.0 - Streaming parser/renderer for the OPML 2.0 format.  https://hackage.haskell.org/package/opml-conduit-0.7.0.0 (koral)
10:24:52 <coldnine> what are good reasons to use haskell? do people achieve with it the same kind of productivity one can get using python? i'm coming from c/c++ and python background so i was always curious about haskell
10:25:48 <monochrom> I disbelieve claims of higher python productivity.
10:26:46 <dmwit> Taking an adversarial view on the question as asked: Yes, I believe there exists people A and B for whom A's productivity with Haskell is similar to B's productivity with Python.
10:27:22 <zachk> coldnine, you get safer code with the type system, and the type inference the compiler can figure out the types for a lot of your code, and if your types all line up, usually your program works if it successfully compiles, if the types don't line up it won't even compile
10:28:01 <boj> geekosaur: ok, i'll look into it. thanks
10:30:19 <coldnine> sorry for my abnoxiousness with the python part. i've been intrested in haskell for quite a while, how's the user-base (compared to python/javascript), do you usually find suitable packages for your work? and what are haskell's best/most popular use-cases?
10:30:51 <dmwit> Does runQ m >>= runQ . f = runQ (m >>= f) ?
10:32:10 <boj> coldnine: my team uses it for practical in house development of web apps (both api and spa), network gear interfaces, parsing custom config languages, etc.
10:32:14 <dmwit> (...and if so, why does Q exist at all instead of just using IO?)
10:32:45 <coldnine> monochrom: i was speaking from my own experience, when i play a ctf, use gdb or reverse things, python is a huge help, also in the crypto dimension, there are many gists and repos out there which are all written in either python / javascript
10:33:58 <boj> coldnine: the package ecosystem is quite robust, up until you cross the enterprise line, then you start missing things
10:35:38 <monochrom> Personal "experience" are more like feelings full of confirmation bias and selective memory.  I wouldn't even trust myself to say I'm productive in Haskell.
10:36:57 <monochrom> I am not sure why the lots of gists and repos out there are mentioned.  But I can guess it means there is a big networking effect so you don't have to write your own code.
10:37:33 <wroathe> When it comes to productivity, community size is another factor. When you've got more people contributing fundamental building blocks (gists, libraries, docs, blogs, etc) you need to get your problem solved, it becomes easier to solve your problem (which you could say makes you more productive)
10:37:44 <wroathe> (which is a roundabout way of saying what monochrom just said)
10:37:51 <ystael> coldnine: I lead a development group that consists of a Haskell (back end service) team and a Python (IoT client) team. The biggest single effect I can point to is that the Python team has consistently found their correctness and productivity improve by adopting practices that bring them closer to doing typed functional programming.
10:41:58 <monochrom> There is always the double-speak that when "python" "haskell" are mentioned, sometimes you mean the language design, some other times you mean the networking effect surrounding the language.  I can appreciate that.  But...
10:43:28 <monochrom> If you start with "I'm interested in haskell" I would think you mean the language design.  But then when you bring up "a lot of available code in python" suddenly it switches to networking effect.
10:45:17 <monochrom> Haskell has a much smaller networking effect.  Even though Hackage is big, it's still small compared to Python's and Perl's.  This part can't be helped.
10:45:57 <monochrom> Hell, Hackage didn't even exist for a while until someone said they really liked CPAN and actually did something about it.
10:47:42 <monochrom> Anyway, swtiching to personal anecdote despite what I said against it...
10:48:20 <monochrom> I was recently writing an algorithm to process a list of student names and their TA names.  Although both are strings at the end of the day...
10:49:19 <monochrom> I made its type signature the parametric-polymorphic [(s,g)] -> ... -> [(s,g)].  s for student, g for TA (because "grader").
10:50:13 <monochrom> Because s and g are different type variables, this means my algorithm will not be allowed to mix up the student role and the TA role.  Right here one class of bugs eliminated without even writing a test case.
10:51:33 <monochrom> So this is the kind of techniques we mean when we say "if it type-checks, a large class of bugs perishes".
10:52:06 <monochrom> I mean to be sure if I merely used [(String,String)] -> ... -> [(String.String)] I wouldn't be able to claim that.
10:54:36 <monochrom> See you later. I have to go to a guest talk from a group who will tell my students what's good about functional programming in the real world! (Except they use Clojure. It's OK! Better than drinking the OO Kool-Aid. Actually they switched from Java to Clojure!)
10:54:44 <c_wraith> I've seen a lot of people claim that type signatures cannot be documentation. it turns out they are almost always thinking of a signature like String -> String, not the sorts of things that actually appear in Haskell code.
10:54:52 <machinedgod> Happy
10:54:56 <machinedgod> Oups
10:56:58 <wroathe> c_wraith: All it takes is a little experience to disabuse someone of that notion
10:57:59 <coldnine> any recommended haskell learning materials for people who have advanced knowledge in other common programming languages?
11:01:40 <boj> coldnine: sadly that advanced knowledge won't get you far, and can possibly be detrimental
11:02:10 <boj> coldnine: that said, Learn You A Haskell is online and free, if not dated. nice intro to some of the language features at least
11:02:40 <bsima> coldnine: i liked haskellbook.com
11:02:56 <wroathe> I thought the exercises in "Programming in Haskell" were good
11:03:02 <kadoban> I'd second haskellbook.com it's long, but it'll go quick for the parts you can learn easily
11:03:23 <kadoban> LYAH I specifically don't recommend because it has no exercises. You come out the other end not really having learned a lot.
11:03:39 <coldnine> boj: well i'm simply looking for a learning material which doesn't cover the obvious and goes into too much details about things which might not be so obvious for new comers (e.g. what are variables, what are functions etc.)
11:03:51 <__monty__> I'll proffer Hutton's Programming in Haskell.
11:04:20 <boj> coldnine: you might appreciate haskell book as others have mentioned, it tries to build things up in a pedagogical fashion
11:04:51 <__monty__> coldnine: If you have enough programming experience, not just C or python or java experience the "Gentle" introduction might suit you.
11:06:27 <wroathe> That said, there's enough different about functional programming in general that it's worth accepting that you may need to redefine some concepts you think you already know
11:06:35 <wroathe> And go into it with a clean slate
11:08:56 <fen> would class Foldable1 f where foldr1 :: (a -> b -> b) -> (a -> b) -> f a -> b make a good superclass to Foldable?
11:10:05 <dmwit> Why is that the right type for foldr1?
11:10:40 <fen> because for nonempty there is no basecase
11:10:57 <dmwit> One of `(a -> a -> a) -> f a -> a` or `(b -> b -> b) -> (a -> b) -> f a -> b` seems much more natural to me.
11:10:57 <phadej> fen: Foldable is a superclass of Foldable1
11:11:46 <fen> phadej: but some containers dont have empty, just create, and things that do have empty can implement create, so they are a subclass
11:12:02 <phadej> so?
11:12:13 <phadej> non empty container can be converted `toList :: f a -> [a]`
11:12:34 <fen> yeah, because list has an empty constructor
11:12:36 <phadej> yet potentially empty container cannot be covnerted to `NonEmpty`
11:12:40 <phadej> foldMap1 :: Semigroup m => (a -> m) -> t a -> m
11:12:43 <phadej> toNonEmpty :: t a -> NonEmpty a
11:12:52 <fen> sure it can
11:13:02 <fen> thats what foldr1 is for
11:13:20 <fen> :t foldr (:) []
11:13:21 <lambdabot> Foldable t => t a -> [a]
11:13:23 <fen> :t toList
11:13:25 <lambdabot> error:
11:13:25 <lambdabot>     Ambiguous occurrence ‘toList’
11:13:25 <lambdabot>     It could refer to either ‘Lambdabot.Plugin.Haskell.Eval.Trusted.toList’,
11:13:36 <phadej> fen: write a foldr1 for a list
11:13:42 <phadej> if Foldable1 is a superclass of Foldable
11:13:49 <phadej> because [] is Foldable
11:13:56 <dmwit> fen: I think `data FenExample a = FenExample` can be made a fine instance of Foldable but not your Foldable1.
11:14:02 <fen> foldr1 (:|) create :: Foldable1 f => f a -> Nonempty a
11:14:29 <dmwit> fen: (Therefore Foldable1 should not be a superclass of Foldable.)
11:14:38 <phadej> but otherway around: and it is: http://hackage.haskell.org/package/semigroupoids-5.3.2/docs/Data-Semigroup-Foldable-Class.html
11:14:43 <fen> phdej: for list, create = :[]
11:15:07 <phadej> it's Foldable f => Foldable1 f
11:15:53 <fen> but things that can be "created" include things with empty and a constructor, but not the other way round
11:16:04 <phadej> foldable doesn't create, foldable folds
11:16:27 <fen> you can have create without empty, but not all things that can be created have empty, eg nonempty
11:17:07 <phadej> fen: think harder. foldMap :: (a -> m) -> f a -> m
11:17:09 <fen> well how would it end up backwards to containers with create forming a superclass of containers with construct and empty?
11:17:15 <phadej> we aren't creating "f a", we are consuming it
11:17:51 <fen> but foldr (:) [] is like foldr1 cons create
11:17:58 <phadej> I suggest you try to write "MyFoldable1 f" and "MyFoldable f" and see what fails
11:18:06 <phadej> writing instances for [] and NonEmpty
11:18:42 <phadej> it's MyFoldable f => MyFoldable1 f; not the otherway around, which you propose
11:19:01 <fen> dmwit: thats an example of a container with no elements at all, so it has empty, but not create, unless that uses const
11:19:23 <kuribas> is a catamorphism a generalization of Foldable?
11:19:42 <fen> phdej: foldable and foldable1 works for both [] and nonempty
11:20:11 <fen> kuribas: its the same no?
11:20:18 <dmwit> fen: Do you believe those facts bear on my claim that Foldable1 should not be a superclass of Foldable? I do not believe they are relevant at all.
11:20:26 <kuribas> fen: for a list only
11:20:30 <dmwit> fen: So if we disagree there, we should dig into why.
11:20:48 <fen> hmm
11:21:27 <fen> create undefined
11:21:39 <phadej> fen: you cannot write Foldable1 instance for []
11:22:00 <fen> sure you can!
11:22:18 <dmwit> Prove it. =)
11:22:19 <zachk> how?
11:22:28 <fen> it pattern matches on "last" just fine, (x:[])
11:22:30 <dmwit> No fair calling error or looping.
11:22:46 <dmwit> (Incomplete patterns count as calling error.)
11:22:53 <dyl> glguy heyo, quick question
11:22:56 <fen> no fair having a container with no ellements replaced entierly by the basecase!
11:23:02 <dyl> To what extent is irc-core mostly for library usage vs mostly for client usage?
11:23:06 <fen> just making the create function in the same way...
11:23:09 <dmwit> Why isn't it fair to have a container with no elements?
11:23:15 <boj> here's a minimun example of what i am trying to do and the error - https://gist.github.com/boj/eddb2d9f2d12b548ff1284180ee48324
11:23:15 <dmwit> That's a very useful concept.
11:23:21 <dyl> I'm looking for a solid IRC parser/utility library in Haskell to work from.
11:23:32 <fen> but i can write create for proxy, it just discards the input
11:23:43 <glguy> dyl: There's not much application logic in irc-core, but it is focused on client-side rather than server-side
11:23:47 <phadej> fen: no you cannot
11:24:01 <phadej> foldr1 f create [] = ???
11:24:11 <phadej> what would ??? be
11:24:21 <fen> ah
11:24:26 <fen> ok, thanks
11:24:34 <dyl> glguy thanks for the info
11:24:44 <dyl> Having a weird issue installing it with new-install :(. 
11:24:56 <dyl> Not your fault, I think my cabal is broken somehow. It's looking for liquidhaskell when it shouldn't be.
11:25:06 <phadej> fen: really, try to write things down and compile them
11:25:15 <phadej> with -Wall
11:25:37 <phadej> non-empty containers are a _sub_ class of "all containers"
11:26:05 <dyl> So is glirc the application, irc-core the library>
11:26:07 <dyl> ?*
11:26:07 <lambdabot> Maybe you meant: v @ ? .
11:26:16 <phadej> it might feel unnatural, but when you think hard enough, it will make sense
11:26:45 <phadej> you can convert NonEmpty a -> [a]; but you cannot [a] -> NonEmpty a
11:26:51 <fen> just some notation, streams have get and set, linear is stream + create and isLast, stack is linear + empty, thats a superclass hierarchy
11:26:56 <glguy> dyl: Yeah, irc-core is focused on parsing and generating IRC messages, has a type for case-insensitive identifiers, categorizing reply codes, etc
11:27:04 <fen> so all linear things are foldable1, and all stacks are foldable
11:27:26 <fen> linear is a superclass to stack, yet foldable1 is a subclass of foldable
11:27:32 <fen> thats why its confusing
11:27:53 <phadej> yes, foldable1 is a __sub__ class, not super class of foldable
11:28:28 <fen> just intrigued as to how it ends up backwards of the linear stack hierarchy direction
11:28:44 <phadej> i'm not following your streams linear stack hierarchy
11:29:07 <fen> nonempty is the archetypal linear container as list is to stack
11:29:18 <phadej> what is "linear container"
11:29:25 <dyl> glguy btw, have you run it on ircfuzz.c :)?
11:29:31 <fen> get+set+create+isLast
11:29:39 <glguy> nope, my primary concern is that it works on freenode
11:29:39 <phadej> where from this definitions come from?
11:29:47 <dyl> https://github.com/sandsmark/ircfuzz/blob/master/ircfuzz.c
11:30:00 <dyl> Breaks a lot of clients in interesting ways :).
11:30:12 <fen> get :: f a -> (a,f a),set :: (a,f a) -> f a,create :: a -> f a,isLast :: f a -> Bool
11:31:12 <fen> get and set of class Stream, create and isLast of stream subclass Linear
11:31:31 <fen> empty :: f a of Linear subclass Stack
11:31:37 <phadej> again, Foldable is only for consuming containers, set and create are cosntructing container
11:31:47 <phadej> you are mixing up things, which makes it confusing
11:31:52 <fen> but foldable has toList
11:32:08 <fen> oh right, its mixing anamorphisms and catamorphisms
11:32:15 <fen> because fold only needs get
11:32:20 <fen> and we are providing also set
11:32:42 <fen> basically they are traversable
11:33:01 <phadej> no, traversable doesn't allow changing shape
11:33:07 <phadej> you cannot add an element ot Traversable
11:33:09 <fen> maybe thats how the hierarchy ends up backwards but its difficult to see how
11:33:30 <fen> phadej: they are traversable though, if they are linear
11:33:48 <fen> as you can foldr1 with set and create
11:34:06 <phadej> there is the same relation between Foldable => Foldable1  and Traversable => Traversable1
11:34:19 <phadej> those four classes form a "commuting diagram"
11:34:29 <fen> just as they are traversable if they are stacks, where you can use the linear implementation provided by the superclass or foldr set empty
11:34:54 <phadej> there's no "set"-like operation in Traversable or Traversable1
11:35:00 <phadej> you really should write some code down
11:35:08 <fen> that wasnt claimed
11:35:21 <fen> just that linear containers implement traversable
11:35:35 <phadej> so does "everything" in your hierarchy
11:35:36 * hackage brick-filetree 0.1.0.3 -   https://hackage.haskell.org/package/brick-filetree-0.1.0.3 (ChrisPenner)
11:35:43 <fen> well yeah, thats the point
11:36:16 <fen> but thats why this creating things which was causing confusion earlier enters the picture
11:37:09 <fen> so Traversable1 is needed too?
11:37:26 <fen> because we cant write traversable1 for list
11:39:25 <fen> would this commuting diagram help understand how when unfolding the stack ends up as a linear superclass?
11:39:35 <fen> is that whats happening?
11:40:48 <fen> everything foldable1 is foldable and not the other way round, but everything unfoldable is unfoldable1 and not the other way round?
11:41:08 <phadej> when you fold things then "All Containers" => "NonEmpty Containers"; if you unfold/create things then "NonEmpty Containers" => "All Containers"
11:41:17 <phadej> if you want a hierarchy with both, then there are no relationship
11:41:26 <phadej> things become invariant
11:41:57 <fen> so traversable1 = traversable ?
11:42:01 <phadej> no
11:42:09 <phadej> traversable1 is not about creating things
11:42:15 <fen> well it cant be both a super and subclass...
11:42:26 <phadej> traversable1 doesn't change the shape
11:43:12 <fen> and traversable does?
11:43:20 <dmwit> Nope.
11:43:30 <cocreature> 203239           phadej │ no, traversable doesn't allow changing shape
11:43:46 <fen> then that doesnt disprove that traversable = traversable1
11:43:48 * dmwit . o O ( What about Traversable2 )
11:43:55 <boj> geekosaur: thanks again for the tip. i had to write a wrapper with a concrete type definition to make that work
11:44:19 <dmwit> fen: As before, `data FenExample a = FenExample` is the disproof of Traversable = Traversable1.
11:44:28 <dmwit> (Because this can be made an instance of Traversable but not Traversable1.)
11:44:29 <fen> dmwit: yes, its a shame that not everything traversable is linear, because of constructors with more than one value
11:44:52 <phadej> dmwit: theoretically there can be Traversable2 class, in practice it's hard to encode in Haskell
11:45:34 <fen> > traverse Identity []
11:45:36 <lambdabot>  Identity []
11:46:19 <fen> hmm so it must use pure [] somewhere, and thats where traversable1 would differ
11:46:51 <dmwit> phadej: Yeah, the encoding of Traversable1 is already pretty subtle -- it relies critically on Apply not having pure, which... is v. v. clever, I think.
11:47:38 <fen> but then how do the values end up in the applicative?
11:47:47 <dmwit> mu
11:47:57 <fen> ?
11:47:59 <dmwit> (There is no Applicative to be seen, necessarily!)
11:48:18 <fen> how do the values end up in the Apply then?
11:48:37 <dmwit> Via fmap and (<.>), of course.
11:48:55 <fen> % :t (<.>)
11:48:55 <yahb> fen: Indexable (i, j) p => (Indexed i s t -> r) -> (Indexed j a b -> s -> t) -> p a b -> r
11:49:05 <fen> oh well sure, simple
11:49:22 <dmwit> ...not that (<.>). =)
11:49:33 <dmwit> (<.>) :: Apply f => f (a -> b) -> f a -> f b
11:50:04 <fen> still seems like it would need to put things into the apply
11:50:30 <dmwit> What things, exactly?
11:50:46 <fen> :t \a -> pure (a:)
11:50:47 <lambdabot> Applicative f => a -> f ([a] -> [a])
11:51:17 <dmwit> Individual elements can be put "into" the Apply using the user-supplied callback.
11:51:42 <dmwit> traverse1 :: (Apply f, Traversable1 t) => (a -> f b {- this -}) -> t a -> f (t b)
11:51:59 <fen> when traversing, values are retrived (from a deconstructor) partially applied with a constructor, wrapped up in pure and folded up with <*>
11:52:23 <fen> oh right
11:52:42 <fen> they dont become applicatives via pure, but by the function supplied to traverse
11:52:46 <fen> that makes more sense
11:53:01 <dmwit> One way to write the `traverse f (x:xs)` is `pure (:) <*> f x <*> traverse xs`. But another way, that doesn't use `pure`, is `(:) <$> f x <*> traverse f xs`.
11:53:17 <fen> that it.
11:53:19 <fen> nice
11:53:42 <dmwit> `pure` is needed exactly for the empty base cases...
11:53:53 <fen> now confused about how the user is supposed to make these Apply returning functions though..
11:54:02 <fen> normally e.g. Identity would have pure
11:54:10 <fen> so we can traverse with Identity
11:55:02 <dyl> I'm getting really, really, tired of stack complaining it can't parse cabal output :(
11:55:10 <fen> ah, we dont traverse1 with pure :: a -> Identity a, but with Identity ::a -> Identity a
11:56:02 <cocreature> dyl: for the solver stuff?
11:56:06 <fen> still seems odd though, since a pure implementation can be given here
11:56:12 <dyl> Yeah.
11:56:23 <dyl> Every time I have to/want to use stack it's another nightmare.
11:56:33 <dyl> I know it makes a lot of people's lives easier but I'm apparently not among those blessed folk.
11:56:59 <cocreature> yeah I’m not sure the solver stuff ever did anything useful for me (but I haven’t used stack in quite some time so maybe things have improved)
11:56:59 <fen> dyl: cabal install works sometimes when cab new-install doesnt
11:57:07 <fen> cabal*
11:57:14 <dyl> And then you have haskell-ide-engine clobbering whatever cabal-install you have in ~/.local/bin... 
11:58:04 <fen> dmwit: does Foldable1 appear allongside the Traversable1 that uses Apply?
11:58:08 <dyl> Anyhow, currently I just can't make stack work at all.
11:58:30 <dyl> I want to use an extra-dep and it fails every time due to parsing cabal output.
11:58:38 <dmwit> fen: I don't understand the question.
11:58:39 <fen> its just that the version that has (a -> a -> a) and no basecase seems to be worse than (a -> b -> b) and (a ->b)
11:58:51 <fen> dmwit: looking for a better version of Foldable1
11:59:03 <fen> (as a subclass of Foldable)
11:59:06 <dyl> Not to mention that parsing the command line output of a cabal dry run seems... questionable?
11:59:12 <cocreature> dyl: ime trying to figure out the versions yourself tends to be a lot easier than trying to get solver to work.
11:59:21 <dyl> I just want my project to even build.
11:59:30 <dyl> Or install exactly the dependencies I want.
11:59:31 <dmwit> fen: ...better than what?
11:59:42 <fen> http://hackage.haskell.org/package/foldable1-0.1.0.0/docs/Data-Foldable1.html
11:59:50 <dyl> I'm just trying to use solver to get it to pick up what I'm putting down dep wise.
11:59:53 <fen> it has;
11:59:54 <fen> foldr1 :: (a -> a -> a) -> f a -> a
12:00:15 <fen> foldr1 :: (a -> b -> b) -> (a -> b) -> f a -> a
12:00:17 <fen> is better
12:00:25 <cocreature> dyl: right I’m suggesting to not use solver at all. add your extra-dep, run "stack build" and fix the errors manually. it’s annoying but at least it works :)
12:00:47 <dyl> That's what I initially did but it doesn't work.
12:00:49 <fen> then create can be used as the second argument to make id
12:01:01 <cocreature> dyl: if you show us the error, somebody might be able to help
12:01:03 <dyl> It also wants the dependency in package.yaml/foo.cabal, and solver generates those files.
12:01:03 <fen> forall a. f a
12:01:09 <dyl> I think I might have it figured out.
12:02:17 <dyl> I'm just a little salty about stack always being problematic for me :p.
12:02:47 <dyl> The nix-style builds (new-*) is great stuff, sadly it doesn't work for a lot of projects that have atrophied .cabal files because they use stack.
12:03:25 <fen> foldr set empty :: (Foldable f,Stack f) => f a -> f a; foldr1 set create :: (Foldable1 f,Linear f) => f a -> f a
12:03:33 <cocreature> dyl: if you’re willing to add a few constraints yourself (you can add them as cli flags with --constraint), you can usually make it work
12:03:46 <dyl> Neat, good to know!@
12:03:57 <vaibhavsagar> dyl: that's a blessing in disguise with stack
12:03:58 * vaibhavsagar ducks
12:04:04 <cocreature> dyl: stackage also has cabal.config files that you can use
12:04:29 <dyl> I really don't think 5-6 different config/yaml/cabal/... files is a marker of a sustainable and reasonable ecosystem.
12:04:49 <dyl> I'm currently just holding out until the new-* commands are stable, tested, and supported.
12:05:23 <fen> haskell needs cabal more than it needs stack
12:05:37 <cocreature> there isn’t that much overlap between these files. hpack is just a different syntax for cabal files and you can easily a cabal file from them regardless of whether you use stack or cabal
12:05:47 <cocreature> stack.yaml and *.cabal files are just different things
12:06:03 <dyl> Right, but a lot of projects end up having *all* of these files.
12:06:08 <cocreature> stack.yaml and cabal.project files overlap but both of them tend to be fairly small ime so it isn’t that big of a deal
12:06:22 <dyl> And it's not always clear which build systems are being maintained in a given tree and which aren't.
12:06:35 <dyl> cabal.project + foo.cabal is plenty imo. :/.
12:07:16 <cocreature> why? those files are orthogonal
12:07:28 <dyl> I mean as a set of files sufficient for a clean project that builds.
12:07:52 <dyl> I see a lot of projects that have those *and* Stack's *.yaml files, which sometimes aren't in sync.
12:08:22 <cocreature> I might just be suffering from stockholm syndrome :)
12:08:52 <dyl> I appreciate what stack does in theory, and I don't want this to come off as me criticizing the hard work people put into stack, or how much it benefits many person's and groups' workflows.
12:09:06 <dyl> It's just that personally, every time I have to dip my toes in that creek I get bitten.
12:09:19 <dyl> It's not stack itself, it's more the ecosystem as a whole.
12:09:42 <dyl> It reminds me of the issues in Python-land of yesteryear somewhat :p.
12:10:18 <dyl> Before pipenv came down from up on high...
12:10:34 <[exa]> dyl: don't worry, I guess many people share that view :]
12:10:45 <[exa]> dyl: it's not right but ATM it's practical
12:10:55 <dyl> On the other hand, despite the current chaos, it's super exciting to see all of this work going into improving the ecosystem.
12:11:38 <fen> this Foldable1 thing reall messes up the Linear Stack hierarchy. to have a subclass (Foldable1) as a superclass of Linear, but its subclass Stack has the superclass (of Foldable1) Foldable as its superclass
12:11:39 <dyl> I'm pretty sure it'll all shake out for the best.
12:12:19 <[exa]> dyl: in fact stack is luxurious, what's the last time you touched nodejs?
12:12:28 <fen> oh wait thats the right way round to have them! all confusion is alleviated 
12:12:30 <dyl> We don't speak of that place.
12:12:34 <[exa]> :]
12:12:56 <dyl> I really don't know what the gulp authors were thinking.
12:13:08 <dyl> Or the grunt authors for that matter.
12:13:21 <dyl> I continue to seek refuge in a Makefile and package.json scripts ;p.
12:13:34 <fen> no its still broken... that means stack inherits foldable1
12:13:56 <dyl> Ah, more concrete stack issue, as I've gotten a bit further...
12:14:00 <dyl> Trying to run hoogle, getting:
12:14:02 <dyl> Minimum version is hoogle-5.0. Found acceptable hoogle-5.0.17.5 in your index, installing it.
12:14:02 <dyl> WARNING: Ignoring out of range dependency (allow-newer enabled): haskell-src-exts-1.20.3. hoogle requires: >=1.21 && <1.22
12:14:06 <cocreature> I consume most of the Haskell ecosystem via Hackage and in that case, everyone seems to play reasonably well so that things either work out of the box with cabal or I tend to be able to fix them fairly easily by adding a few constraints
12:14:23 <dyl> (which is resulting in an issue with the number of constructors in GadtDecl, so I need to bump src-exts)
12:14:48 <fen> well its ok probably, you *can* foldr1 stacks, just as long as they arent [], so just use foldr! ok thanks
12:14:53 <dyl> How might I add a constraint here to push src-exts up to the right version?
12:16:18 <marcx> hi. what are your thoughts on binary package?  from hackage: " Binary serialisation for Haskell values using lazy ByteStrings"
12:16:24 <dyl> cocreature and yeah, same. Usually just a cabal file and hackage packages works great for me.
12:16:30 <cocreature> the adding constraints part is for when you’re building with cabal, for stack you have to figure out the versions
12:16:34 <dyl> Every so often I have a transitive dependency conflict, but it's usually workable.
12:31:07 <marcx> is there a human readable serialization library for haskell?
12:31:23 <cocreature> marcx: aeson?
12:31:31 <cocreature> depends on what exactly you mean by human readable
12:31:31 <tabaqui> marcx: what's wrong with cereal, binary, aeson and others?
12:31:58 <marcx> tabaqui, I don't know about other two, first time I hear about them. but binary is not human readable
12:32:05 <marcx> checking them out
12:32:16 <tabaqui> cereal is just binary for lazy strings
12:32:34 <tabaqui> aeson provides monad for json
12:32:56 <marcx> I was hoping something that looks more like pretty-printed haskell constants, than json. nothing like that?
12:33:33 <tabaqui> err, you can write custom parser with attoparsec
12:33:38 <tabaqui> yaml?
12:34:47 <marcx> I don't have a file to parse, I want to create a human readable and editable file that stores haskell objects. ideally, it should look something like well formated/pretty printed Show a output
12:34:51 <marcx> nothing like that I guess?
12:36:50 <marcx> I'm half tempted to write it myself just using Show/Read instances, but the problem is that not all types have Read instance that can produce valid haskell object out of it's Show output
12:38:48 <dyl> marcx there are some pretty printing libraries.
12:39:11 <dyl> Not sure which are kept up to date, but they exist.
12:40:06 <dyl> Sometimes I just use a default Show instance, paste into a buffer with scheme filetype and auto-format :p.
12:41:06 <marcx> serialization has to be done programmatically
12:41:49 <marcx> pretty printing libraries use Show, I guess?
12:46:51 <tabaqui> in most cases "deriving (Show, Read)" will work
12:47:19 <tabaqui> there are exceptions like type from "time" library
12:47:28 <marcx> yes :|. ZonedTime
12:47:36 <tabaqui> but you can use newtypes to fix them
12:50:50 <marcx> problem is, if you use such a type accidentally, or without knowing it is affected, your database becomes unreadable. so, unfortunately, Show/Read can't be used directly
12:54:42 <marcx> and, because of that, libraries like Text.Show.Pretty can't be used either 
12:58:43 <marcx> I think I'll just use binary serialization library, and give my program an option to dumb binary file to text file using pretty-show
12:58:49 <marcx> dump*
12:59:00 <marcx> should I go for cereal or binary?
13:02:28 <marcx> maybe a better question is, what are the pros/cons of each
13:03:11 <glguy> cereal mostly exists because of feature that binary didn't have when cereal was created
13:03:15 <glguy> features*
13:03:23 <marcx> which binary has now?
13:03:27 <glguy> Yeah
13:17:47 <WilliamHamilton[> is there a tool to (aid to) generate the haskell bindings for a c module? Or is it done entirely by hand? How do people keep the bindings up to date? By manual examination?
13:18:52 <vaibhavsagar> WilliamHamilton: http://hackage.haskell.org/package/c2hs
13:19:58 <WilliamHamilton[> vaibhavsagar: thanks! How much does it remain to do manually?
13:20:17 <vaibhavsagar> no idea, I've never had to do this myself
13:20:32 <WilliamHamilton[> vaibhavsagar: I'll try it out, thanks again
13:37:48 <adius> Is there a way to persists some data in a "parse free" data format?
13:38:24 <adius> So I mean somehting which gets directly loaded as a Haskell value without any parsing, like it's necessary for JSON o.s.
13:38:56 <vaibhavsagar> adius: like Python's "pickle" format?
13:38:59 <vaibhavsagar> I don't think so
13:40:05 <vaibhavsagar> although we do have CompactRegions
13:40:07 * hackage partial-semigroup-hedgehog 0.6.0.0 - Property testing for partial semigroups using Hedgehog  https://hackage.haskell.org/package/partial-semigroup-hedgehog-0.6.0.0 (chris_martin)
13:41:06 <adius> vaibhavsagar: Yeah, something like the pickle format (thanks for the pointer)
13:41:22 <zachk> prolly can't pickle pointers
13:41:47 <vaibhavsagar> I'm more concerned about the mechanics of pickling thunks
13:42:53 <zachk> wouldnt you need to evaluate them first?
13:45:20 <adius> > I don't think so
13:45:20 <adius> Well, that's unfortunate 😞
13:45:21 <lambdabot>  error:
13:45:22 <lambdabot>      Data constructor not in scope: I :: t0 -> t1 -> t2 -> terror: Variable n...
13:45:22 <lambdabot>      • Variable not in scope: so
13:45:53 <adius> Why the heck are quotes executed as code. That's just stupid.
13:46:49 <glguy> That's not how you typically quote on IRC
13:46:52 <MarcelineVQ> 3>calling it quotes
13:46:58 <glguy> but it is how you write literate source files
13:47:32 <vaibhavsagar> adius: you could use http://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-StablePtr.html
13:49:21 <adius> vaibhavsagar: But this doesn't help persist it between invocations of the program, oder it?
13:49:41 <vaibhavsagar> probably not
13:49:59 <adius> 😂 "oder it?" -> great mixture of German and English
13:51:24 <adius> I guess I could use `read` and `show`, but than I proabaly should rather use JSON
13:52:42 <vaibhavsagar> adius: you could probably hack together something that you could then `unsafeCoerce` to your desired type, but this is a terrible idea and is heavily discouraged
13:58:25 <adius> vaibhavsagar: I only want to use it for caching, so maybe that isn't such a bad idea
14:05:01 <pie___> if i try to  use omething that lets me compose typeclasses like monad transformers, on records containing disjunct attributes, would i be reinventing a crappy object system :V 
14:05:52 <pie___> hmm well i guess it wouldnt be at runtime (which i dont need/want)
14:06:19 <pie___> actually that doesnt matter though
14:06:22 * pie___  ponders
14:13:07 * hackage atom-conduit 0.6.0.0 - Streaming parser/renderer for the Atom 1.0 standard (RFC 4287).  https://hackage.haskell.org/package/atom-conduit-0.6.0.0 (koral)
14:13:52 <Thra11> I love how if you ask hoogle for a function between two types which it doesn't recognise, its top suggestion is unsafeCoerce
14:15:02 <wroathe> So I noticed that for users that want to define a datatype and make it an instance of FromJSON/ToJSON in Aeson, Aeson uses a configuration object to change small details of the instance implementation https://github.com/bos/aeson/blob/master/Data/Aeson/Types/FromJSON.hs#L252, and the API they provide for passing that configuration object uses TemplateHaskell to generate instance declarations: 
14:15:08 <wroathe> https://github.com/bos/aeson/blob/master/Data/Aeson/TH.hs#L590
14:15:27 <wroathe> What it seems like they're trying to get at is a way to somehow parameterize an instance with a value instead of a type
14:15:29 <adius> vaibhavsagar: I guess this might do it http://hackage.haskell.org/package/store
14:16:04 <wroathe> To avoid the need for the user to have to write their own instance body by hand. Are there others ways of accomplishing this?
14:16:18 <wroathe> maybe using Multi-Param type classes or something like that
14:16:34 <wroathe> So you'd do: instance MyClass myConfigurationObject
14:17:38 <wroathe> sorry, wrong syntax, instance MyClass MyType myConfigObject
14:20:29 <adius> Another question: Does anyone here have details how Haskell compilation times scale with the module / function ration. So 1 module with 100 functions vs 100 modules with 1 function
14:22:21 <vaibhavsagar> adius: 1 module would probably be faster, but that's not what usually makes Haskell compilation slow
14:22:50 <vaibhavsagar> it's usually TH and deriving that makes more of a difference IIRC
14:23:17 <adius> Is there any good reason why I shouldn't store Haskell code as 1 function per module?
14:23:36 <adius> Apart from it being cumbersome to maintain / write
14:23:38 <wroathe> adius: Besides maintenance-hell, you mean?
14:23:47 <wroathe> Heh :P
14:23:49 <adius> wroathe: Yeah 😂
14:25:34 <wroathe> Basically what that From/ToJSON options pattern is trying to get at is letting the user write something like: data Foo = Foo { bar :: String }} deriving (MyClass(myConfigurationObject))
14:25:59 <pie___> Thra11, haha
14:26:57 <pie___> also, random: the explicitness of the type system just saved me from having to figure out how to architect something (or i got lucky)
14:28:47 <pie___> ah wait no...oh well, almost. well...i can cheat but that might be a bit messed up
14:30:07 * hackage path-io 1.4.2 - Interface to ‘directory’ package for users of ‘path’  https://hackage.haskell.org/package/path-io-1.4.2 (mrkkrp)
14:39:31 <marcx> did binary package ever break backward compatibility (of the resulting binary file, not api)
14:41:14 <c_wraith> I think it did, though I'm not sure
14:41:24 <c_wraith> I also think the format isn't portable anyway
14:41:34 <bkerin> i'm wondering what iteration means in the contrext of a Functor class... I guess giterate(some_ftor, count=3) would yield a functor some_ftor(some_ftor(some_ftor(arg))) yes?
14:41:48 <c_wraith> ie, I think it represents Int differently between 32 and 64 bit systems.
14:42:09 <marcx> c_wraith, oh
14:42:36 <marcx> how about cross-OS compatibility?
14:45:04 <c_wraith> oh, I was wrong about that. Int is always written with 64 bits
14:45:15 <marcx> that's good
14:46:07 <bkerin> im looking at a system that talks about both giterate() and grepeat() as operatios on functors without saying quite what either means and I thought some haskell guru might have an idea
14:46:52 <c_wraith> marcx, but custom instances can be written to use host by order. that would make those instances write data that isn't portable between some system pairs.
14:47:10 <c_wraith> *byte order
14:52:52 <wroathe> So without using TH magic to inject a new options object you might think you could do something like this: https://gist.github.com/JustinChristensen/2e5f87fcc048f976bdc018c86ecc64c7
14:53:40 <wroathe> But obviously members of a class need to have the instance somewhere in their type
14:57:08 <wroathe> So I think TemplateHaskell might be about as good as you can get for injecting a config object into an instance
15:13:37 * hackage cpkg 0.1.0.0 - Build tool for C  https://hackage.haskell.org/package/cpkg-0.1.0.0 (vmchale)
15:16:13 <emmanuel_erc> Hello there! Does anyone here use haskell-mode in emacs?
15:16:56 <marcx> a lot of people do, I imagine
15:17:41 <emmanuel_erc> I am having this problem where when I load my project in the terminal with "cabal new-repl lib:<packagename>", then everything is hunky dorey.
15:19:15 <emmanuel_erc> However, if try to do this in emacs, by going to a particular file in the project and pressing "C-c C-z" (or whatever you press for `haskell-interactive-switch'), then I am unable to load the repl. 
15:19:27 <emmanuel_erc> I shall post the error message I get from haskell-process-log in a moment.
15:34:38 <emmanuel_erc> hello there again, my connection seemed to have been abruptly cut off?
15:34:42 <emmanuel_erc> cut off.*
15:39:10 <myname_> Hello, I'm a new Haskell developer trying to get a hold of the type system. Can anyone explain why I am getting an error here? https://gist.github.com/t94j0/7ae0b1d5699ec20b363704a498da32b7
15:39:56 <myname_> it's saying that it can't match String to ShadowEntry. Are type changing functions not recommended or supported?
15:40:18 <wroathe> :t putStr
15:40:19 <lambdabot> String -> IO ()
15:40:32 <wroathe> putStr requires a String, not a ShadowEntry
15:40:46 <wroathe> :t print
15:40:46 <lambdabot> Show a => a -> IO ()
15:40:55 <wroathe> print is probably what you want
15:41:29 <sm> print runs show on the Showable value first, unlike putStr
15:41:30 <myname_> Ahh, I see
15:41:57 <myname_> I thought that since I was deriving `show` it would work as well. Thanks for the help!
15:42:13 <koala_man> it won't automatically coerce, no
15:42:28 <sm> see also printf
15:43:08 <jpg> hi guys, have you referenced GHC user's guide in a paper? what kind of bibtex entry do you use?
15:45:58 <wroathe> So TemplateHaskell is sort of one way of paramterizing an instance declaration with a configuration value, I'm wondering if it's possible to use Proxy, DataKinds, and multi-param type classes to also do it
15:46:12 <wroathe> Is it possible to store a function's implementation at the type level?
15:46:50 <wroathe> like if my configuration object is data Options = Options { formatter :: String -> String }
15:52:22 <emmanuel_erc> I am using haskell-mode in emacs. I would like to have haskell-mode start a repl with the corresponding command "cabal new-repl lib:<package>". This commands works properly in th shell, however haskell-mode can't seem to do it when I set haskell-process-args-cabal-new-repl to "lib:chainweb".
15:52:35 <emmanuel_erc> Does anyone know how to accomplish what I am trying to do?
15:53:11 <myname_> I'm getting a Linker error (https://hastebin.com/raw/zemupexise) when I try to compile (https://gist.github.com/t94j0/7ae0b1d5699ec20b363704a498da32b7) Main.hs. I have the package `split` which exposes Data.List.Split. Does anyone know what could be causing the error? I'm on macOS if that helps.
15:53:28 <myname_> Google isn't very helpful because it just says to "install the package using cabal" which I"ve already done
15:58:00 <sm[m]> myname_: that looks like the sort of error that cleaning old build artifacts sometimes fixes. cabal clean ?
15:59:20 <emmanuel_erc> actually emacs seems to fail when I leave out all of the additional arguments I could via `haskell-process-args-cabal-new-repl'
15:59:37 <sclv> myname_: what is the actual command you're running?
15:59:47 <myname_> sm[m]: I just tried `cabal clean; ghc Main.hs`
15:59:58 <myname_> same error, but I may be doing it wrong
16:00:05 <sclv> run `ghc --make` to compile
16:00:11 <sm[m]> did you copy files from another machine with different architecture ?
16:00:26 <sclv> also `cabal clean` doesn't do anything if you're not in a cabal project
16:00:40 <myname_> sm[m]: No, I did not.
16:01:08 <emmanuel_erc> I get this error: https://pastebin.com/Ci7Jenrn
16:01:19 <emmanuel_erc> from the haskell process log
16:01:30 <wroathe> myname_: Just using ghc to build won't automatically link split
16:02:33 <myname_> wroathe: Are there flags I need to use? I tried using sclv's advice and did `ghc --make`, but that didn't work either
16:03:02 <myname_> (I ran `ghc --make Main.hs`, by the way)
16:03:25 <sm[m]> -package split
16:03:42 <sm[m]> ghc Main -package split
16:06:03 <sclv> myname_: do you have some brew stuff lying around?
16:06:08 <sm[m]> though wouldn't we expect a different error if that's the problem ? ("Could not find module ‘Data.List.Split’")
16:06:09 <sclv> i think that may cause issues
16:06:10 <sclv> cf https://github.com/commercialhaskell/stack/issues/3125
16:08:07 * hackage streaming-utils 0.2.0.0 - http, attoparsec, pipes and other utilities for the streaming libraries  https://hackage.haskell.org/package/streaming-utils-0.2.0.0 (chessai)
16:08:16 * sm[m] would move .cabal out of the way and retry
16:10:49 <marcx> is there a way to autogenerate Binary instance for types I did not write? here's my attempt, but still getting errors. https://bpaste.net/show/d77569d74b26
16:11:55 <marcx> I forgot to include errors, here's new link. https://bpaste.net/show/3817e1f76ecd
16:15:27 <sclv> marcx: use the StandaloneDeriving extension
16:15:34 <sclv> then write `deriving instance Generic Day`
16:15:40 <sclv> to force the generic deriving to work
16:15:56 <sclv> after that, the binary instance you have will make use of it
16:16:16 <marcx> nice!
16:16:57 <marcx> if I want to make my classes derivable like that, I guess it would involve TemplateHaskell?
16:17:13 <sclv> no, you can do it like Binary does, just using generics
16:17:27 <sclv> you can't add new builtin deriving -- that uses compiler magic
16:17:46 <sclv> but you can use the Generic library and default instances without TH
16:18:26 <marcx> good to know. I'll have to look into generics when I have more time
16:24:09 <marcx> I needed to derive Generic and Binary also for all the types that ZonedTime uses (TimeZone, TimeOfDay, Day, LocalTime). I don't suppose there's a shortcut to auto derive those classes for all the child types as well?
16:24:56 <marcx> probably not
16:29:58 <sclv> nope
16:30:51 <sclv> marcx: however, see https://hackage.haskell.org/package/binary-orphans
16:31:02 <sclv> i think that defines the "standard" binary instances for a ton of stuff in base
16:31:06 <sclv> and related
16:31:22 <sclv> or rather not base, but all the other stuff next to it that's "almost base"
16:32:28 <marcx> interesting that it includes aeson, a json library
16:33:02 <marcx> binary serializer, for json 
16:33:05 <marcx> serializer
16:34:32 <marcx> I'm actually deciding between aeson and binary, and testing both at the moment. speed vs human readability and a bit more relaxed type constraints (with json, you can write Int, and read any Num)
16:51:32 <marcx> Binary actually has one maintenance advantage.. you can change field name of the and still decode the file, while aeson fails to do the same
16:58:07 * hackage partial-semigroup 0.5.1.0 - A partial binary associative operator  https://hackage.haskell.org/package/partial-semigroup-0.5.1.0 (chris_martin)
20:23:27 <jackdk> anyone here good at lens in general and pandoc-lens in particular? I'm trying to pull out text strings where the text has a certain style. I was able to pull out all the text using `view (body . traverse . partsOf (template . _Str))`, but don't know how to match attributes without straying into unlawful lenses
21:31:36 * hackage multi-instance 0.0.0.4 - Typeclasses augmented with a phantom type parameter  https://hackage.haskell.org/package/multi-instance-0.0.0.4 (chris_martin)
21:48:41 <cocreature> jackdk: sounds like "filtered" might help
21:49:37 <jackdk> cocreature: thanks. I did get something out but was initially leery because of teh "not a lawful Traversal" thing. But I'm reading, not writing, so it's possibly ok?
21:50:11 <cocreature> if you’re reading, then you’re probably only using it as a Fold which is fine
21:51:23 <jackdk> ace, thanks mate
21:51:37 <cocreature> and even using it as a Traversal can be totally fine if you don’t modify how the filter evaluates, so in your example if you don’t change the attributes that you’re filtering on
21:55:08 <jackdk> true. I just flinch away from the word "unlawful"
22:10:07 * hackage hw-hspec-hedgehog 0.1.0.6 - Interoperability between hspec and hedgehog  https://hackage.haskell.org/package/hw-hspec-hedgehog-0.1.0.6 (haskellworks)
22:12:07 * hackage hw-hspec-hedgehog 0.1.0.7 - Interoperability between hspec and hedgehog  https://hackage.haskell.org/package/hw-hspec-hedgehog-0.1.0.7 (haskellworks)
22:18:37 * hackage arbor-monad-metric 1.1.1 - Core metric library for publishing metrics.  https://hackage.haskell.org/package/arbor-monad-metric-1.1.1 (arbornetworks)
22:27:07 * hackage wordlist 0.1.0.1 - Command-line tool to get random words  https://hackage.haskell.org/package/wordlist-0.1.0.1 (chris_martin)
23:07:15 <MasseR> Ohh, pandoc-lens sounds interesting
