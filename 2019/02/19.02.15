00:00:05 <trcc> sorry, b should be a
00:00:10 <tdammers> unless you have a MonadIO constraint on d
00:00:14 <trcc> og a should be d heh
00:00:19 <trcc> b*
00:00:21 <tdammers> no, that's not the problem
00:00:38 <trcc> a -> (a -> IO c) -> d and a function a -> (a -> c) -> d
00:00:44 <tdammers> it cannot apply the (b -> IO c) argument, because there is nothing you can do with the resulting IO value except ignore it
00:01:00 <trcc> a -> (a -> IO c) -> IO d and a function a -> (a -> c) -> IO d
00:01:02 <trcc> there you go
00:01:03 <trcc> sorry
00:01:05 <tdammers> right
00:01:13 <tdammers> that makes more sense
00:01:26 <tdammers> so let's fix the rest
00:01:28 <tdammers> say you have:
00:01:38 <tdammers> fIO :: a -> (a -> IO c) -> IO c
00:01:49 <tdammers> fPure :: a -> (a -> c) -> IO c
00:02:01 <tdammers> and you want to express fPure in terms of fIO
00:02:06 <tdammers> does that sound about right?
00:02:10 <trcc> let me think
00:02:14 <trcc> I think so yes
00:02:18 <tdammers> OK
00:02:32 <tdammers> so all you need, really, is a way of getting from (a -> c) to (a -> IO c)
00:02:49 <trcc> which does not seem too bad. Let me try for a sec
00:02:58 <tdammers> :t return -- this is going to help
00:02:59 <lambdabot> Monad m => a -> m a
00:03:11 <tdammers> :t pure -- or this, same thing really
00:03:12 <lambdabot> Applicative f => a -> f a
00:11:33 <trcc> tdammers: That just about removed 10 lines of code and made it much easier to understand: https://github.com/HFMU/HaskellFmu/blob/master/src/HaskellFMU.hs#L29-L37 Thank you for you help. I go into this mind-mess where I thought it was bad to lift to IO, when it was a pure function originally. But I am doing it in the next step anyways
00:12:55 <trcc> tdammers: to compare: https://gist.github.com/CThuleHansen/ca19a563870e0af1567b7873fa5f4fd4 :D
00:19:18 <tdammers> this is absolutely fine
00:19:26 <tdammers> going the other way around is what you shouldn't be doing
00:19:48 <tdammers> i.e., run IO actions upon evaluating non-IO expressions, via the unsafePerformIO backdoor
00:24:31 <trcc> great thanks
00:53:07 * hackage yam 0.5.12 - Yam Web  https://hackage.haskell.org/package/yam-0.5.12 (leptonyu)
00:54:07 * hackage yam-datasource 0.5.12 - Yam DataSource Middleware  https://hackage.haskell.org/package/yam-datasource-0.5.12 (leptonyu)
00:58:07 * hackage jailbreak-cabal 1.3.4 - Strip version restrictions from Cabal files  https://hackage.haskell.org/package/jailbreak-cabal-1.3.4 (PeterSimons)
00:58:34 <merijn> That...seems useless considering --allow-newer?
01:08:08 <MarcelineVQ> allow newer applies to all deps right? I guess you can be more selective with that tool. does seem a little silly to me, guess at least one person found it useful though
01:09:10 <MarcelineVQ> and a lot more than that if its download numbers means anything
01:09:22 <merijn> MarcelineVQ: With new-build you can selectively apply allow newer
01:09:31 <MarcelineVQ> in the project file?
01:09:50 <merijn> MarcelineVQ: Specifically, you can only allow newer versions of a specific package or only apply the "allow newer" to dependencies of a specific package
01:10:26 <merijn> Also via the commandline (or at least a subset of that functionality)
01:10:45 <merijn> MarcelineVQ: Exhibit #1: https://github.com/merijn/GPU-benchmarks/blob/master/cabal.project#L20 ;)
01:11:02 <merijn> That only relaxes the bounds on time
01:11:29 <MarcelineVQ> pretty cool
01:14:37 * hackage yam-datasource 0.5.13 - Yam DataSource Middleware  https://hackage.haskell.org/package/yam-datasource-0.5.13 (leptonyu)
01:15:37 * hackage yam 0.5.13 - Yam Web  https://hackage.haskell.org/package/yam-0.5.13 (leptonyu)
01:17:04 <trcc> When you submit to hackage, does it have to be "ready for production"?
01:17:53 <trcc> sorry, wrong channel...
01:18:24 <tdammers> "production ready" is a bit of a meme around here, because it doesn't really mean anything
01:18:44 <tdammers> opinions as to what the acceptable code quality on hackage *should* be differ rather violently
01:19:26 <tdammers> but in practice, it's mostly "free for all", for better or worse; it is considered good form to make sure at least that your package builds cleanly on all compiler versions it advertises to support though
01:19:27 <merijn> trcc: It should at least be somewhat usable, imo
01:20:00 <trcc> okay. Thakn you. Then I will wait. It is a library to implement simulation units, but it does not support all functions of the interface yet.
01:20:23 <tdammers> in fact, the hackage folks regularly build all packages against a selection of GHC versions, and they may slap you if it fails to build against one of them that it says to support
01:20:48 <tdammers> "does not support" how?
01:21:05 <tdammers> as in, does it just not have those functions? or are the functions there, but stubbed out?
01:21:11 <trcc> tdammers: there are about 20 functions of the c-interface, I have only implemented about 10
01:21:48 <tdammers> oh, so you're FFI-wrapping some C API then?
01:21:51 <trcc> But I think your answers has given me enough info to determine whenit is ready
01:21:52 <trcc> yes
01:23:54 <merijn> Some form of testing of the package would be good too before going on Hackage (see the Haskell-CI repo if you're too lazy to figure out how to set things up ;))
01:24:10 <heptahedron> Does anyone know what happens if the action you pass to `alloca` throws an async exception?
01:24:30 <trcc> merijn: Definitely. I will add that to my growing list of enhancements :D
01:24:58 <merijn> heptahedron: Is this question "do I leak memory?" in disguise? :)
01:25:14 <merijn> trcc: https://github.com/haskell-CI/haskell-ci
01:25:26 <merijn> trcc: Script for auto-generating Travis-CI configs for cabal packages :)
01:25:39 <heptahedron> merijn: Well I suppose, but if it's going to launch some nukes that would be nice to know as well lol
01:25:51 <trcc> Amazing
01:25:52 <trcc> thank you
01:26:21 <merijn> heptahedron: Scanning the implementation it's using GHC's builtin allocation primitives which are GCed, so should be fine
01:29:29 <heptahedron> merijn: Hmm, I saw that too and that's what I figured but I wasn't sure because I can't find any mention of the two
01:30:15 <merijn> heptahedron: "the two" what? :)
01:31:37 * hackage datadog-tracing 1.0.1 - Datadog tracing client and mock agent.  https://hackage.haskell.org/package/datadog-tracing-1.0.1 (fommil)
01:32:53 <heptahedron> merijn: sorry, the two together, referring to `alloca` and async exceptions
01:34:17 <merijn> heptahedron: Generally "bracket-style" things like alloca are fairly exception-safe (blocking cleanup and async exceptions can be a bit of a mess)
01:34:41 <merijn> heptahedron: Have you read Simon Marlow's Parallel & Concurrent Haskell book?
01:36:20 <koz_> :t bracket
01:36:21 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
01:36:31 <heptahedron> merijn: I think I read the SPJ paper on the design of exceptions in haskell and I've certainly read a lot now about sync vs. async and interruptibility but it's a lot to try and consider when designing a low level api like this haha
01:36:49 <koz_> What does 'bracket' do, intuitively?
01:37:32 <heptahedron> are you asking me this as part of some socratic exercise where you lead me to enlightenment or are you asking for help lol
01:37:37 <merijn> heptahedron: Simon Marlow's book is pretty good if you wanna do low level stuff
01:37:48 <koz_> heptahedron: The latter.
01:37:53 <merijn> koz_: Exception safely allocate a resource
01:38:05 <koz_> If it was meant to be a Socratic-method-type thingo, I'd have tagged you.
01:38:17 <merijn> koz_: Consider the following cases: What if an async exception arrives during allocation/cleanup of a resource?
01:39:00 <merijn> koz_: So bracket blocks all async exceptions, runs the allocation, installs a handler for the cleanup (that always runs, exception or not) and *then* runs the action with exceptions unblocked
01:39:10 <koz_> So in that context, what's the 'a -> IO b' argument meant to be?
01:39:19 <merijn> koz_: The cleanup
01:39:23 <koz_> Ah, I see.
01:39:28 <koz_> OK, thanks.
01:39:39 <merijn> koz_: So, the "IO a" is malloc and "a -> IO b" is free :)
01:39:42 <Ariakenom> bracket allocate deallocate use. example: withFile f use = bracket (open f) close use
01:39:59 <koz_> Makes sense.
01:41:44 <merijn> It's not quite safe yet, because bracket only uses regular mask (which unblocks during blocking operations, like reading an MVar) so you need to be careful or you can still leak if you block in the cleanup and get another exception
01:41:58 <heptahedron> thanks again!
01:42:53 <merijn> heptahedron: Simon's book (incidentally, available for free online) talks a lot about exception safety, implementation stuff and many of the low level things in base (Chan, MVar, STM, etc.) so very nice if you wanna write your own stuff dealing with async exceptions
01:44:47 <Ariakenom> oh I could find it without web archive https://learning.oreilly.com/library/view/parallel-and-concurrent/9781449335939/
01:51:24 <sicklorkin> I have a few newtype that wrap a normal lists e.g. newtype Users { fromUsers :: [User] } and I find myself writing this code `User . f . fromUsers` more than I'd care to. Is there soem major to get it to figure out that it's just wrapping a list so I can just use `fmap` for lsiting it in/out of the newtype wrapper? 
01:52:05 <sicklorkin> s/soem major/some way/
01:52:22 <merijn> sicklorkin: fmap only works if you could change the type (which can't be done with your type)
01:52:48 <sicklorkin> merijn: so what do I want?
01:53:01 <dminuoso> sicklorkin: Hard to say without knowing what you want.
01:53:09 <dminuoso> sicklorkin: What are you trying to do in general?
01:53:18 <dminuoso> Unrelated question:
01:53:21 <dminuoso> :t traverse
01:53:22 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
01:53:30 <merijn> sicklorkin: You could just define "mapUsers :: (User -> User) -> Users -> Users; mapUsers f = Users . map f . fromUsers"? 
01:54:13 <merijn> Also, why is it a newtype anyway if it's just [User]?
01:54:40 <sicklorkin> merijn: csv, json, textual instances
01:54:53 <dminuoso> Is there an equivalent for Comonad, where I can do something like: `(Comonad w, Monad m) => w a -> (w a -> m b) -> m (w b)`
01:55:08 <dminuoso> (Or with Applicative instead of Monad I guess)
01:55:52 <dminuoso> Although.. I guess I get that for free as long as my `w` type is Traversable..
01:55:55 <merijn> sicklorkin: Ah...I think mapUsers is the best thing you can do
01:56:27 <sicklorkin> merijn: I think that mapUsers is a fairly common pattern, at least in my code.. i am just trying avoid all the broiler plate
01:57:16 <sicklorkin> merijn: I apprecate the help
01:57:33 <sicklorkin> *appreciate
01:57:34 <merijn> sicklorkin: I mean, the only other solution would be to not have those newtypes in your core datatype and only add them right before serialising
01:57:56 <merijn> sicklorkin: Alternatively, don't derive the FromJSON, etc. instances and write them by hand so you don't need the newtype to override it
01:58:03 <sicklorkin> merijn: yeah, i have been leaning towards this for a hile now
01:58:38 <sicklorkin> merijn: this wrapper is essitentally used only for formatting
04:09:40 <Ferdirand> what's the modern, ergonomic way to constraint a type inside a do-block ?
04:10:15 <Ferdirand> let's say I'd like to have foo :: (Bar t) => m t, for some monad m
04:11:03 <Ferdirand> I can do do { x <- (foo :: m Baz); ... } but that's a lot of line noise
04:11:50 <Ferdirand> I was wondering if I can achieve something with proxies
04:13:48 <dminuoso> Ferdirand: TypeApplications.
04:14:27 <dminuoso> Ferdirand: Though this is going to be a bit messy. Maybe just create a seperate binding?
04:15:15 <dmwit> (Why messy?)
04:15:49 <dmwit> One of `x <- foo @Baz` or `x <- foo @_ @Baz` will probably work, which doesn't seem too messy to me.
04:15:57 <dminuoso> dmwit: well the @_ might be annoying. :)
04:16:07 <dmwit> eh
04:16:23 <dmwit> Feels hard to cry about three extra characters.
04:16:39 <dminuoso> dmwit: By the way I meant to ask you something about some SO answer a while ago.. it was about type unification involving pattern type signatures and universal quantification.
04:16:55 <dminuoso> (You answered to some question)
04:17:05 <dminuoso> Do you recall it?
04:17:30 <dminuoso> Ferdirand: You could also do a pattern type signature of course.
04:17:50 <Ferdirand> like (x :: Bar) <- foo ?
04:17:53 <Ferdirand> is that valid ?
04:18:03 <dminuoso> Ferdirand: you have to enable ScopedTypeVariables but yes
04:18:09 <dminuoso> (I think it was that extension)
04:18:30 <dminuoso> % :t do { (m :: Int) <- undefined; m }
04:18:31 <yahb> dminuoso: ; <interactive>:1:31: error:; * Couldn't match expected type `m b' with actual type `Int'; * In a stmt of a 'do' block: m; In the expression:; do (m :: Int) <- undefined; m
04:18:38 <dminuoso> % :t do { (m :: Int) <- undefined; pure m }
04:18:39 <yahb> dminuoso: Monad m => m Int
04:18:48 <dmwit> dminuoso: Perhaps https://stackoverflow.com/a/54295539/791604 ?
04:18:58 <Ferdirand> interesting, never read about TypeApplications before, thanks
04:19:28 <dminuoso> Ferdirand: TypeApplications are basically a more direct way to Proxy. :) 
04:19:35 <dminuoso> (Without fiddling with "fake parameters")
04:19:56 <dminuoso> dmwit: Oh Ill have to catch up some reading it seems. :)
04:20:26 <Ferdirand> i remember reading something about redefining :: to a specialized const
04:20:35 <dmwit> :t asTypeOf
04:20:36 <lambdabot> a -> a -> a
04:20:48 <dmwit> ?src asTypeOf
04:20:48 <lambdabot> asTypeOf = const
04:21:40 <Ferdirand> couldn't you also have asTypeOf :: a -> p a -> a, or something like that ?
04:21:54 <Taneb> :t asProxyTypeOf
04:21:56 <lambdabot> error: Variable not in scope: asProxyTypeOf
04:21:56 <Ferdirand> then (b -> b) becomes a valid proxy
04:22:09 <Taneb> :t Data.Proxy.asProxyTypeOf
04:22:10 <lambdabot> a -> proxy a -> a
04:22:50 <dminuoso> dmwit: Ah it seems as if the long answer contains the answers I was looking for. Thanks. :)
04:22:51 <dmwit> If you have `f :: b -> b`, you can either just apply it if it's already `id` or use ```id `asTypeOf` f```.
04:23:10 <dmwit> dminuoso: I'll be honest, I don't understand the long answer.
04:24:53 <dminuoso> dmwit: Ok. What exactly is that "generalization" process you referred to? (And is there any relationship to GADTs, or is that a different meaning of the word "generalization"?)
04:25:08 <dminuoso> (Ive read your answer a few times, but I couldn't make sense of it)
04:27:10 <dmwit> So, imagine for a moment a type system where foralls were never implicit.
04:27:37 <dmwit> The type `a -> a` is not implicitly `forall a. a -> a`, it is only `a -> a` and, if used like that, simply refers to a type variable that isn't in scope yet.
04:28:03 <dmwit> Kind of like at the term level where if you saw `x + y` you wouldn't implicitly make it `\x y -> x + y`, you'd just have an expression with out-of-scope term variables.
04:29:37 <dmwit> Type inference proceeds in two steps: first, for each declaration* you infer a type, using unification as usual to make the type more and more specific and allowing it to refer to fresh, out-of-scope unification variables.
04:29:58 <dmwit> (* Actually, declaration groups, because of mutual recursion. Ignore that quibble for now.)
04:30:35 <dmwit> In the second step, you generalize each declaration's type by making it polymorphic in any type variables which remain and are out of scope.
04:31:53 <dmwit> So, for `\x -> x`, the two steps are: 1. start with bare unification variable `a`, unify `a` with arrow type `b -> c` since it's a lambda, unify `c` with `b` since `x :: b`, get (say) `b -> b` as the top-level type, then 2. generalize to `forall b. b -> b`.
04:32:03 <dminuoso> dmwit: So any type it couldn't infer is implicitly universally quantified over?
04:32:15 <dminuoso> (in the second step)
04:32:24 <dmwit> yep
04:32:55 <dmwit> In other words: if nothing about how terms of that type was used restricted that type further than a type variable, well, then, it might as well be anything.
04:33:17 <dminuoso> I take it in Haskell that would happen after looking at the entire module GHC is compiling?
04:33:29 <dmwit> No, after each declaration group.
04:33:57 <dmwit> And declaration groups are toposorted, so that generalization of a definition happens before the use of the newly-defined thing has to look up its type.
04:33:59 <dminuoso> Ah. That makes sense I guess.
04:34:48 <dmwit> (Turns out it gets yet more complicated in the presence of TH, but... yeesh. Everything gets complicated in the presence of TH.)
04:35:18 <dminuoso> Oh yeah. Im fine pretending we dont have TH or mutual recursion for now.
04:35:59 <dmwit> Okay, right, so generalization happens after each declaration, then, and declarations are processed in an order that ensures we can just look up the (already-polymorphic) type of any name we see.
04:37:54 <dmwit> Okay, so now I ask you: the long answer says mine is wrong. What predictions do our two answers make that differ?
04:38:03 <dminuoso> So if we had that `f :: forall a. a -> a`, then some reference to `f` might introduce a fresh out of scope type variable, perhaps end up not inferring that type any further, then it would universally quantify that binding over some type `forall q. ...`, and then use `f @q ...` internally?
04:38:58 <dminuoso> Okay, let me take a moment. :)
04:40:13 <dmwit> Hm. There were a lot of existentials in that question.
04:40:46 <dmwit> And I'm not sure which binding "that binding" refers to.
04:40:52 <dmwit> So I'm not sure how to answer it.
04:40:57 <dminuoso> dmwit: Yeah perhaps I need to supply some concrete example.
05:33:20 <AndreasK> Anyone know if https://wiki.haskell.org/Taking_over_a_package is still accurate?
05:38:01 <dmwit> I think so, yes.
05:49:02 <AndreasK> thx
06:28:02 <infandum> The following results in a "resource busy (file is locked)" error: "withTempFile "." "tmp" $ \file h -> B.readFile "test.pdf" >>= B.writeFile file >>= const (hClose h)"
06:28:20 <infandum> This is a rookie error, but I totally forget what to do
06:28:30 <infandum> I know it's because of lazy IO
06:32:44 <infandum> They are two different files though
06:39:40 <ClaudiusMaximus> infandum: i'm guessing withTempFile gives you an open handle "h" to the filename "file", and reopening "file" fails - probably you should use "B.hPut h" instead of "B.writeFile file"
06:40:29 <ClaudiusMaximus> also suggest using ">> f" instead of ">>= const f"
06:45:58 <infandum> oh duh
06:47:01 <infandum> Fantastic, thank you
06:48:20 <Ariakenom> infandum: you seem to be closing the temp file twice too
06:48:29 <Taneb> infandum: I don't think you'd need to explicitly close the handle (assuming this is from System.IO.Temp)
07:13:37 <infandum> Taneb: I'm closing the handle because I'm reading it later
07:13:45 <infandum> So I want it to flush
07:16:07 * hackage pandora 0.1.3 - A box of patterns and paradigms  https://hackage.haskell.org/package/pandora-0.1.3 (iokasimovmt)
07:16:36 <Taneb> infandum: it gets closed automatically by withTempFile
07:21:16 <dmwit> ...but closing it twice is no big deal, as hClose already protects against that bug.
07:22:21 <dmwit> From hClose_help: case haType handle_ of ClosedHandle -> return (handle_,Nothing); _ -> ...
07:32:42 <cosimone> xmonad
07:43:13 <inkbottle> > l <- getLine
07:43:15 <lambdabot>  <no location info>: error: not an expression: ‘l <- getLine’
07:48:14 <dmwit> % getLine
07:48:20 <yahb> dmwit: [Timed out]
07:50:19 <kuribas> What would be better for an SQL API, using functions with &, or Endo with <> ?
07:50:51 <kuribas> For example: select ["name", "age" ] <> from "users"
07:51:13 <kuribas> Or: emptySql & select ["name", "age" & from "users"
07:51:23 <fen> is there a version of traverse for streams? maybe using conduit...
07:51:28 <kuribas> or select ["name", "age" ] . from "users"
07:52:18 <kuribas> fen: I am sure you can lift any action into a stream?
07:52:41 <fen> just worried about it trying to traverse to the end of the list
07:52:45 <fen> stream*
07:53:03 <dmwit> traverse itself works on streams, provided the Applicative you use is sufficiently lazy.
07:53:10 <fen> hmm
07:53:26 <fen> well, folding would use StateL
07:53:30 <fen> or StateR
07:54:01 <fen> so that it could be folded with the constructor (set) of another stream, and then you could do something like take on it...
07:54:03 <kuribas> fen: that would depend on the type of stream...
07:54:09 <fen> or a version of take that cast from Stream to List
07:54:51 <fen> kurbias, stream being defined as anthing with (a,f a) -> f a and f a -> (a,f a)
07:55:33 <fen> (thereare no maybes to handle the end, meaning, eg f a -> (a,f a) always returns a valid next "state" f a
07:55:49 <kuribas> fen: infinite streams can be lazy
07:55:51 <dmwit> % :m + Control.Monad.State.Lazy
07:55:52 <yahb> dmwit: 
07:56:10 <dmwit> % evalState (traverse (\a -> modify (+1) >> return a) [1..]) 0
07:56:16 <yahb> dmwit: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127
07:56:27 <dmwit> See? As lazy as you please, even on a stream.
07:56:50 <fen> just wondering, because the modules all seem to follow this pattern of (a,f a) for stream, (a,Maybe (f a)) for linear, Maybe (a,f a) for stack
07:57:08 <fen> and the foldable and traversable for stack become foldable1 and traversable1 for linear
07:57:19 <fen> so is there another traversable class for stram
07:57:21 <fen> stream*
07:57:35 <fen> or build
07:57:52 <kuribas> dmwit: does the state even have to be lazy?
07:57:53 <dmwit> Didn't I already answer that question?
07:58:07 <fen> just strange how there is a "hyloList" for stream, but no associated build that uses it, or traverse default
07:58:14 <dmwit> kuribas: yep
07:58:19 <dmwit> % :m - Control.Monad.State.Lazy
07:58:21 <yahb> dmwit: 
07:58:25 <dmwit> % :m + Control.Monad.State.Strict
07:58:25 <yahb> dmwit: 
07:58:31 <dmwit> % evalState (traverse (\a -> modify (+1) >> return a) [1..]) 0
07:58:31 <yahb> dmwit: ; <interactive>:3:1: error:; Ambiguous occurrence `evalState'; It could refer to either `Control.Monad.State.Strict.evalState', imported from `Control.Monad.State.Strict' (and originally defined in `Control.Monad.Trans.State.Strict'); or `Control.Monad.State.evalState', imported from `Control.Monad.State' (and originally defined in `Control.Monad.Trans.State.Lazy')
07:59:01 <fen> does yahb do qualified imports?
07:59:04 <dmwit> Whatever. Anyway it would time out. You can try it locally to se.
07:59:11 <fen> yeah sure i get all that
07:59:15 <dmwit> yahb does everything ghci does, because it is an interface to ghci.
07:59:19 <fen> cool
07:59:25 <Solonarv> % Control.Monad.State.Strict.evalState (traverse (\a -> modify (+1) >> return a) [1..]) 0
07:59:31 <yahb> Solonarv: [Timed out]
07:59:35 <fen> ok, forget traverse, thats confusing 
07:59:37 <fen> try build
08:00:22 <fen> ok, so there are generalisations to build 
08:00:40 <fen> because when get/set are defined, can use those constructors instead
08:00:44 <kuribas> so it evaluates the state before returning the answer
08:00:47 <fen> (instead of (:) [])
08:01:18 <fen> so there is another version like build1 that uses ((a,Maybe b) -> b) instead
08:01:50 <fen> with a rule like foldr1 k z (build1 g) = g k z
08:02:03 <fen> where foldr1 :: (a -> Maybe b -> b) -> f a -> b
08:02:05 <kuribas> :t build
08:02:06 <lambdabot> error:
08:02:06 <lambdabot>     • Variable not in scope: build
08:02:06 <lambdabot>     • Perhaps you meant ‘buildG’ (imported from Data.Graph)
08:02:12 <kuribas> :t unfold
08:02:13 <lambdabot> error:
08:02:13 <lambdabot>     • Variable not in scope: unfold
08:02:13 <lambdabot>     • Perhaps you meant one of these:
08:02:14 <fen> well, uncurrythat
08:02:38 <fen> so then, is there a corresponding version for streams?
08:02:55 <fen> or is there something strange happening with the Maybe being around the whole pair
08:03:07 <fen> so that the stack and stream versions end up the same
08:04:09 <fen> hmm, maybe the stream version also can use the linear getS and setS. because the Maybe is guarantted to be Just
08:07:33 <fen> oh, btw, the traverse default ended up like this; https://pastebin.com/raw/jmPWuNR6
08:08:17 <fen> might have to benchmark to see if the Maybe is ok on that Apply sequnce workaround
08:09:50 <fen> i guess the point about stream vs linear or stack is that the hylomorphism used to unfold and recombine the list has less maybes for stream
08:10:12 <fen> the benchmarking then should show the stream implementation to be no faster than using Stack or Linear
08:10:33 <fen> so what all the stuff with conduit?
08:10:44 <fen> how come it needs so much machinery to work with streams?
08:11:27 <fen> does lens do all that stuff too?
08:14:16 <fen> didnt coduit like, streamify the whole prelude?
08:18:07 <eacameron> Is there a way (without Typeable) to test equality of two types?
08:18:38 <merijn> eacameron: At runtime, you mean?
08:19:12 <eacameron> Yes. I have some GADT with an `a` in it and I want to conditionally run some `(b -> r)` on it if `a :~: b`
08:19:20 <merijn> eacameron: No, because types are erased
08:19:28 <kuribas> you could make a typeclass maybe?
08:19:41 <eacameron> I guess this is what singletons would do...
08:19:41 <merijn> kuribas: That'd just be reinventing Typeable, but poorly
08:19:46 <kuribas> merijn: true
08:20:53 <eacameron> merijn: I see...so Typeable is really the only way to do that; hm
08:21:08 <kuribas> merijn: but you can get more finegrained behaviour with typeclasses
08:21:18 <kuribas> Typeable is a big hammer
08:22:45 <kuribas> although my impression is that there might be a simpler way to solve this.
08:22:54 <kuribas> Not involving dark type magic.
08:24:07 * hackage pg-harness-client 0.6.0 - Client library for pg-harness-server  https://hackage.haskell.org/package/pg-harness-client-0.6.0 (BardurArantsson)
08:25:07 * hackage pg-harness-server 0.6.0 - REST service for creating temporary PostgreSQL databases  https://hackage.haskell.org/package/pg-harness-server-0.6.0 (BardurArantsson)
08:27:15 <kuribas> the recursion-schemes library doesn't seem well optimized
08:27:22 <kuribas> no inline pragmas...
08:34:07 * hackage pg-harness-server 0.6.1 - REST service for creating temporary PostgreSQL databases  https://hackage.haskell.org/package/pg-harness-server-0.6.1 (BardurArantsson)
08:34:22 <kuribas> I wonder if that's why they are slow according to: https://www.reddit.com/r/haskell/comments/9xg585/are_recursionschemes_no_longer_faster_than/
08:37:27 <kuribas> Which one could you prefer for a library: select ["name", "age"] <> from "users" (using Endo), or select ["name", "age"] . from "users" (using functions)?
08:37:58 <kuribas> I am thinking of a lightweight SQL library like clojure honeysql.
08:38:08 <kuribas> without type magick.
08:40:05 <kuribas> Endo is more indirect, but I like thinking of this as a monoid.
08:43:37 * hackage too-many-cells 0.1.3.0 - Cluster single cells and analyze cell clade relationships.  https://hackage.haskell.org/package/too-many-cells-0.1.3.0 (GregorySchwartz)
08:53:16 <lyxia> I'm not sure inline pragmas change anything if all your functions are one or two lines long.
08:55:50 <lyxia> kuribas: "Well-optimized recursion schemes should be as fast as well-optimized handwritten recursion." <- I stand by this claim with recursion-schemes in its current state.
08:57:39 <kuribas> lyxia: I would think so as well, after inline etc...
08:58:43 <kuribas> ghc is pretty good at inlining and removing abstractions
09:01:30 <kuribas> lyxia: how do you explain the slow benchmarks
09:01:32 <kuribas> ?
09:18:45 <lyxia> I don't know
09:24:58 <kuribas> maybe deforestation doesn't happen because the functions are to big?
09:28:53 <lyxia> Hmm, cata is actually not a one-liner...
09:29:15 <lyxia> you could try inlining that.
09:29:27 <kuribas> I mean the algebra
09:29:32 <kuribas> and coalgebra
09:29:51 <kuribas> I don't think deforstation happens when they don't inline, or does it?
09:44:37 <zincy> Dumb question - How should I calculate a percentage given two Ints?
09:47:07 * hackage cayley-client 0.4.9 - A Haskell client for the Cayley graph database  https://hackage.haskell.org/package/cayley-client-0.4.9 (MichelBoucey)
09:47:39 <cocreature> zincy: "fromIntegral x / fromIntegral y * 100"? I might be misunderstanding what your two Ints are supposed to represent
09:48:44 <zincy> cocreature: Thanks! would that approach give floating point related inaccuracies?
09:49:53 <fen> data Endo1 a = Endo1 {runEndo1 :: (Maybe a -> a)}
09:49:58 <fen> is that found anywhere?
09:50:21 <cocreature> zincy: not necessary, you can choose the result type so you can choose some non-floating point type
09:50:43 <cocreature> but also usually you probably don’t care since you’ll end up rounding the result to a fixed number of decimal places anyway
09:50:48 <fen> if not where does it go?
09:51:26 <zincy> So what do people mean when they say that when it comes to money you should use Ints instead of Floats?
09:52:12 <cocreature> > 0.1 + 0.2
09:52:14 <lambdabot>  0.30000000000000004
09:52:15 <cocreature> that
09:52:48 <zincy> Right
09:53:03 <zincy> In the case of division though you will always having rounding errors no?
09:53:31 <zincy> As long as there is a remainder > 0
09:53:35 <wroathe> https://floating-point-gui.de/formats/fp/
09:54:16 <zincy> wroathe: thanks
09:54:44 <fen> its part of the implementation of a new Foldable1 class
09:54:56 <fen> but it probably shouldnt go there
09:55:03 <fen> in the module defining that class
09:55:40 <fen> also, as well as this there are new traversable, traversable1, foldable and foldable1 classes
09:55:42 <cocreature> zincy: right but if you’re working with money you should be working with operations that you don’t have to round
09:56:01 <fen> the Data.Foldable module is huge, dont want to have to rewrite all that
09:56:09 <fen> how can this be incorperated?
09:57:18 <zincy> :)
09:57:39 <fen> it would be nice to be able to install it from cabal, but if it conflicts with uses of functions from Data.Foldable then it would be better to do it properly
09:57:40 <wroathe> zincy: Actually, this page gives some straight answers to the questions you probably have: https://floating-point-gui.de/basic/
09:57:43 <MarcelineVQ> fen: (Maybe a -> a) where a is a Monoid that's fold
09:58:08 <fen> want the newtype though for its Semigroup instance
09:59:04 <fen> the prototype code is here; https://pastebin.com/raw/QELutnfM
10:01:06 <fen> also, see here for the type of a generalisation of traverse, where Traverse is a synonym of r = Identity
10:01:07 <fen> https://pastebin.com/raw/jmPWuNR6
10:02:04 <fen> well, a synonym that also handles the Identity wrapping/unwrapping
10:02:08 <wroathe> :show packages
10:02:28 <wroathe> Hrm, is there a way to see which packages lambdabot has available?
10:02:39 <fen> bascically traverse_r :: (r a -> f (r' b)) -> t a -> f (t' b)
10:03:04 <fen> with some constraints with a t ->r and r' -> r' fundeps
10:03:35 <fen> sorry, thats convert_r
10:03:44 <fen> traverse sets r = r' and t = t'
10:03:51 <fen> traverse_r *
10:04:38 <fen> replacing the Foldable and Traversable modules has many functions...
10:04:54 <fen> maybe they all generalise to this added `r' parameter
10:05:05 <fen> maybe some dont...
10:06:04 <fen> but the question is how to approach this task of deploying things to cabal which use this alternative implementation of Traversable/Foldable classes
10:07:26 <fen> its easy to get the classes to compile, but the task of rewriting all the functions those modules deploy is daunting
10:08:16 <fen> and then, maybe that would affect compatibility of projects which use that version of these modules 
10:09:23 <fen> is there some other process than uploading to cabal that would allow code to be incorporated to such fundamental modules?
10:10:19 <fen> or is the only option to upload to cabal, and risk users of the module having compatibility problems...
10:10:27 <MarcelineVQ> Other than packaging your own prelude (which is somewhat common) I'm not sure how you'd go about changing the fundamentals people use
10:11:04 <dmwit> cocreature: I and my two friends head out to the local greengrocer and pick up some sandwich fixins for 10 cBTC. How do we compute our fair share of debt without rounding?
10:11:21 <fen> MarcelineVQ: its more a question of getting at the actual prelude
10:11:43 <fen> and having some help with all the many functions that need generalising
10:11:46 <MarcelineVQ> Rather more importantly to ask is, what is the gain of this thing you're making? What does it let you do that's special enough to warrant the changes you'd like to see
10:12:28 <fen> MarcelineVQ: can I show some code that might help answer that?
10:13:08 <MarcelineVQ> If you can, I often find your stuff a bit hard to follow because you don't comment the code itself ehe
10:13:32 <fen> https://pastebin.com/xiKaJDJd
10:14:02 <fen> https://pastebin.com/raw/xiKaJDJd
10:14:27 <geekosaur> @where L.hs
10:14:27 <lambdabot> what lambdabot has in scope is at http://silicon.int-e.eu/lambdabot/State/Pristine.hs
10:14:39 <geekosaur> if you mean what could be imported, no
10:14:58 <dmwit> Drat. I calculated 10mBTC and thought I'd be clever and use cBTC as the unit instead, but forgot to convert the number instead of just the units.
10:15:04 <geekosaur> (but the answer to that is "very, very little". yahb has more)
10:15:05 <wroathe> geekosaur: Ah. Thanks.
10:15:19 <dmwit> So please read 1 cBTC instead of 10 and stop thinking of me as splurging on sandwiches, thx.
10:15:51 <MarcelineVQ> dmwit: there's literally nothing wrong with getting exiting numbers of sandwiches
10:15:53 <fen> that imports this module https://pastebin.com/raw/pG0M67RN
10:15:56 <MarcelineVQ> exciting
10:16:19 <Solonarv> perhaps they're very good sandwiches.
10:16:24 * dmwit leaves stage right with his sandwiches
10:17:09 <geekosaur> <redacted>'s favorite sub shop costs about 3x as much as I'm willing to pay for a sub…
10:17:21 <fen> so the point of all this extra `r' parameter is that it generalises traverse from things which use r = Identity as the "shape" of the container
10:18:09 <wroathe> fen: Gist lets you add multiple files, which would be crazy easier to look at than multiple pastebins
10:18:46 <fen> and the foldable and traversable versions using this `r' can make it available during traversal, but for normal containers, like Lists, where r = Identity, we never see the point of accessing this while traversing or folding
10:19:03 <fen> like, the get/set dont need any extra information
10:19:27 <fen> get :: f a -> (a,f a) === f a -> (Identity a,f a)
10:19:53 <fen> get_r :: Get_r r f => f a -> (r a,f a)
10:20:39 <fen> so when the construuctor/deconstructor needs extra information (bundled up into `r'), then we get a generalised form of traverse/fold
10:20:56 <fen> the normal versions are just the restriction to r = Identity.
10:21:30 <fen> MacelineVQ: does that explain why it might be worth changing the Prelude versions of Foldable and Traversable
10:21:54 <fen> to incude Foldable_r and Traversable_r as its generalisations in a way thats compatable with existing code
10:22:27 <fen> wroathe: ok sure, will set up a github
10:23:42 <dmwit> I... actually like the idea of making a new Traversable-alike that gets to see some extra structure of the thing being traversed.
10:23:46 <dmwit> But I don't think this is the way to do it.
10:24:16 <fen> well, thats kind of an issue, sure
10:24:34 <dmwit> Ponder a type like `data TwoFour a = Two a a | Four a a a a`, where if you "take one away", you don't get something that fits nicely into the TwoFour type anymore, but would now need a (say) OneThree type.
10:24:36 <MarcelineVQ> I guess I'm the wrong person to look at this, really can't make heads or tails of https://pastebin.com/raw/xiKaJDJd
10:25:29 <fen> it would have to have a fixed form to retain compatibility, and if the form its submitted as is up for consideration and alteration it might mess not work... 
10:25:44 <dmwit> This seems to be a recurring weakness of your "get/set" approach to understanding data structures: most structures can't be cleanly decomposed in the way you're hoping.
10:25:53 <fen> dmwit: its just for one value constructors
10:26:05 <fen> otherwise it requires arity traversal, which sucks
10:26:18 <fen> and it would be just as well to use one value constructors were possible
10:26:42 <dmwit> What does "one value constructor" mean?
10:27:05 <fen> Two and Four above are 2 and 4 value constructors
10:27:07 <wroathe> dmwit: fen Wouldn't this be an appropriate topic for https://github.com/ghc-proposals/ghc-proposals?
10:27:15 <dmwit> fen: That doesn't actually answer my question.
10:27:40 <fen> the only reason there isnt a constraint that enforces there is only one value is because e.g. Free f a has a valid get_r
10:27:55 <fen> which is actually used in some pointer code - watch this space
10:28:07 <fen> wroathe: thanks
10:28:08 <dmwit> (For example, is (:) a one-value constructor? What about Bin in `data Tree a = Leaf a | Bin (Tree a) (Tree a)`?)
10:28:49 <fen> cons has "one value" yes, like cofree
10:29:09 <fen> data Cofree2 f a | Cofree2 a a (f (Cofree 2 f a)) wouldnt work
10:29:19 <dmwit> Okay. Then make my example `data OneThree a = One a | Three a a a; data TwoFour a = TwoFour a (OneThree a)` and we're back to square one.
10:29:24 <fen> s/|/=
10:29:36 <dmwit> "get"ing one value from `TwoFour` doesn't decompose it into `(r a, TwoFour a)` for any `r`.
10:29:52 <dmwit> Despite TwoFour being a one-value constructor.
10:30:09 <fen> there isnt much more that can be said to reitterate that its not valid for constructors with more than one value
10:30:20 <fen> the arity traversal is interesting, but its for later
10:30:22 <dmwit> The TwoFour constructor *doesn't have more than one value*.
10:30:26 <fen> if ever...
10:30:43 <dmwit> Which is kind of my point.
10:30:54 <dmwit> Your "one-value" property isn't actually meaningful.
10:31:15 <dmwit> And so I think you've misunderstood something basic and fundamental here.
10:31:17 <fen> well it has meaning which your not expressing sure
10:31:43 <fen> it cant handle those cases. simple
10:32:12 <dmwit> Okay. I think if you agree you can't handle those cases, then that's good evidence this is not a good approach to attaching extra info to traversals.
10:32:19 <fen> there are many useful datatypes which it handles well
10:32:20 <dmwit> Because those cases are, believe it or not, incredibly common.
10:32:49 <dmwit> I think you're wrong: I think there are in fact only maybe two or three commonly used data types which it handles well.
10:33:26 <fen> that does not mean a generalisation to include some types, but not those cases, isnt a good generalisation. its not all encompasing, which is a valid criticism, but that would take more work than is nesacary for this particular generalisation to work
10:34:23 <fen> dmwit: lists and nonempty lists, and those things that are isomorphic to them, including having additional shape, and the Free varients therof, are isompophic to every concievable type - conjecture
10:34:48 <fen> and thats what this library is the result of 
10:35:07 * hackage simple-smt 0.9.4 - A simple way to interact with an SMT solver process.  https://hackage.haskell.org/package/simple-smt-0.9.4 (IavorDiatchki)
10:35:27 <fen> yeah its easy to make a constructor with many values, like tuples, but this is for lists! and other containers with a hamiltonian path
10:36:01 <fen> the idea is basically, if you can write a traversable instance for it, then you *could* write it as a "one value constructor kinda thing"
10:36:22 <fen> so no, your counterexamples are not more common
10:36:49 <fen> sure it forces a particular style, but with it comes extra power
10:36:57 <tombusby> hi everyone, my project this weekend is to really nerd up on Monad Transformer stacks. Seems to be something pretty foundational to managing complexity in larger Haskell projects. However, I feel a bit out of my depth with them. Can anyone recommend any good resources. I've collected a few up myself and am working through them, but I figured I'd ask in here too. Videos and articles both welcome.
10:36:58 <fen> so its not a deterring criticism
10:37:56 <dmwit> TwoFour has a Traversable instance, but is not isomorphic to lists. Data.Map k has a Traversable instance and is not isomorphic to lists. Finger trees are recursive structures of arbitrary length that have subcomponents nearly identical to TwoFour, have Traversable instances, but are not isomorphic to lists.
10:38:06 <dmj`> tombusby: I'd focus on understanding kinds
10:38:23 <tombusby> I have a reasonable understanding of them
10:38:29 <fen> dmwit: trees are isomorphic to free lists
10:38:37 <dmj`> tombusby: ok without cheating, what is the kind of StateT
10:38:38 <fen> this is an important point here
10:38:40 <dmwit> Finger trees are not free lists.
10:38:56 <fen> no but they are free fixed length lists
10:39:09 <dmwit> No, they aren't that either.
10:39:11 <fen> which are still one value at a time things
10:39:13 <tombusby> Can't remember, I will admit. But I know the basic concepts
10:39:18 <dmj`> :k StateT
10:39:19 <lambdabot> * -> (* -> *) -> * -> *
10:39:26 <Solonarv> or: Type -> (Type -> Type) -> Type -> Type
10:39:44 <dmj`> once you get a grasp of this type, you'll be able to understand any transformer, be it StateT, WriteT, ReaderT, ContT
10:39:49 <dmj`> s/type/kind
10:39:52 <dmwit> tombusby: I enjoyed All About Monads.
10:40:07 <dmj`> :k StateT Int (StateT Int (StateT Int IO))
10:40:08 <lambdabot> * -> *
10:40:16 <fen> dmwit: instead of using tuples in you constructor use type lengthed lists, and to construct them value wise is possible
10:40:27 <fen> then use free to compose them
10:40:28 <dmj`> :k WriterT String (ReaderT String (ExcecptT String IO))
10:40:30 <lambdabot> error:
10:40:30 <lambdabot>     Not in scope: type constructor or class ‘ExcecptT’
10:40:30 <lambdabot>     Perhaps you meant one of these:
10:40:34 <fen> and the isomorphism is shown
10:40:43 <dmj`> @google monad transformers step by step
10:40:43 <lambdabot> https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/monad-transformers-step-by-step.pdf
10:40:46 <dmwit> fen: Even with all of that machinery, which *isn't in your original conjecture*, you still haven't reached finger trees.
10:40:58 <johnw> is that big step by big step, or small step by small step? ;)
10:40:59 <dmj`> ^ tombusby check that link
10:41:07 <tombusby> ok cool, thanks :)
10:41:13 <dmj`> johnw: heh :)
10:41:33 <dmj`> monad transformers are just monads in disguise as well
10:41:46 <fen> dmwit: really just did. 
10:42:03 <dmwit> No, because there are annotations at internal nodes.
10:42:07 <dmj`> tombusby: grok those kinds though, * -> (* -> *) -> * -> * is the kind for ExceptT, StateT, etc. 
10:42:07 <johnw> they're like type-level functions from Monad -> Monad
10:42:42 <tombusby> dmj`: cheers yeah I'm just doing a bit of refresher on kinds
10:42:49 <dmwit> (Minor quibble: ExceptT and StateT aren't monad transformers, but families of monad transformers. All monad transformers have kind (* -> *) -> * -> *.)
10:42:53 <dmj`> higher kinded-types, it's like a vortex whirlpool for endless monad construction
10:44:00 <MarcelineVQ> dmwit: that argument is even better with more parens (* -> *) -> (* -> *)
10:44:33 <johnw> StateT s and ExceptT e are the monad transformers
10:46:37 <fen> dmwit: ok fine its not isomorphic to everything, but its still useful in many cases
10:46:46 <fen> e.g Free HList
10:47:01 <fen> for nd cartesian numeric computations
10:47:11 <fen> which are the basis of a lot of work
10:47:25 <fen> and cyclic graphs, with unannotated nodes
10:47:32 <fen> which again, find many uses
10:47:52 <dmj`> tombusby: all about monads is good too https://wiki.haskell.org/All_About_Monads#Monad_transformers
10:48:35 <fen> anyway, if they are traversable thats fine, it doesnt stop the user writing traversable instances, they just cant derive them from the unannoted node case
10:49:27 <fen> it does however enable traversable instances in terms of valuewise deconstructable shaped containers to be derived from their matching on their constructor
10:49:34 <fen> and thats really useful
10:50:10 <fen> also not totally convinced that the annotations can be packaged into the `r' parameter wither
10:50:14 <fen> either*
10:54:16 <fen> the code again; https://pastebin.com/raw/xiKaJDJd https://pastebin.com/raw/pG0M67RN
10:54:37 <fen> will create a github and write a proposal when the basic foldable/traversable classes are done
10:57:49 <__monty__> That's dedication to open source contributions. Build your own source hosting solution first ; )
10:59:37 * hackage contiguous-fft 0.2.0.0 - dft of contiguous memory structures  https://hackage.haskell.org/package/contiguous-fft-0.2.0.0 (chessai)
11:00:00 <fen> here is the version for r = Identity https://pastebin.com/raw/HWDZ2muP
11:00:13 <fen> note that convert serves as a default for traverse
11:51:36 <monochrom> I'm wondering if the difficulty in learning monad transformers is the same difficulty as in learning recursion.
11:52:57 <c_wraith> I actually was able to understand monad transformers before I understood monads.
11:53:26 <shachaf> oh yeah, well, i was able to understand monad transformer transformers before i understood monad transformers
11:53:55 <c_wraith> ouch, my poor brain
11:54:32 <monochrom> Maybe also compounded with the hubris ambition run-before-walk of prematurely, misguidedly aiming for "what's the general idea?" before humbly working out specific ReaderT, StateT, ExceptT first.
11:56:05 <bsima> whats the difference between parsec3 and parsec on hackage?
11:57:27 <byorgey> bsima: I don't know, but parsec3 hasn't been updated since 2015.
11:57:43 <monochrom> parsec3 stopped in Feb 2015 probably because now we put that code in parsec.
11:58:22 <monochrom> So probably a transient intermediate state.
11:58:33 <byorgey> "You may want to develop your code using this subset of parsec3 modules and finally change the dependency from parsec3 to parsec in order to ..."
11:58:40 <monochrom> History is written by the old geezers!
11:59:32 <byorgey> bsima: these days, though, I don't know of any reasons to prefer parsec over megaparsec.
12:00:11 <byorgey> I mean if you were starting a project from scratch and wanted a parsec-like parser combinator library, I would recommend using megaparsec
12:04:00 <johnw> I concur with byorgey
12:04:21 <johnw> I really need to turn parsec-free into megparsec-free
12:04:32 <johnw> the level of debugging and analysis it allows still makes parsec attractive sometimes
12:05:12 <byorgey> woah
12:05:17 * byorgey did not know about parsec-free
12:05:33 <johnw> I've used on several occasions to optimize parsers and reduce backtracking
12:06:19 <byorgey> that sounds really cool.  I would find that useful too.
12:06:23 <byorgey> ...but I'm using megaparsec =)
12:06:36 <johnw> it's a purely mechanical activity, getting the idea shifted over
12:06:40 <johnw> just need a few hours of work to do it
12:07:22 <byorgey> sure
12:17:39 <monochrom> I prefer parsec over megaparsec simply because GHC comes with parsec >:)
12:18:04 <monochrom> But yeah that's only when it really doesn't matter for my use.
12:20:04 <gobby> I'm currently using `div` to divide two `Word64`. When I divide the `maxBound :: Word64` by a value in my code, it returns 0
12:22:37 <dmwit> ?quickCheck \x -> (maxBound `div` x :: Word8) /= 0
12:22:37 <lambdabot> Unknown command, try @list
12:22:43 <dmwit> ?check \x -> (maxBound `div` x :: Word8) /= 0
12:22:45 <lambdabot>  *** Failed! Exception: 'divide by zero' (after 2 tests):
12:22:45 <lambdabot>  0
12:22:53 <dmwit> Hah, yes.
12:23:06 <dmwit> ?check \x -> x > 0 ==> (maxBound `div` x :: Word8) /= 0
12:23:06 <lambdabot>  :-1:-1:Ambiguous infix expression
12:23:17 <dmwit> ?check \x -> (x > 0) ==> ((maxBound `div` x :: Word8) /= 0)
12:23:19 <lambdabot>  +++ OK, passed 100 tests.
12:23:30 <dmwit> gobby: Neat! What value do you divide by, specifically?
12:24:01 <gobby> I'll pastebin the code
12:24:21 <dmwit> Good idea! Bonus points for minimizing it first.
12:26:30 <int-e> > maxBound `quot` minBound :: Int64
12:26:32 <lambdabot>  0
12:29:06 <gobby> dmwit: https://pastebin.com/iv1ntZSA
12:29:35 <gobby> int-e: Why does that happen?
12:31:35 <Cale_> > minBound :: Int64
12:31:36 <lambdabot>  -9223372036854775808
12:31:41 <Cale_> > maxBound :: Int64
12:31:43 <lambdabot>  9223372036854775807
12:31:51 <EvanR> ?quickCheck (x :: Word8) /= 0
12:31:51 <lambdabot> Unknown command, try @list
12:32:05 <gobby> maxBound `quot` minBound :: Word64
12:32:11 <gobby> > maxBound `quot` minBound :: Word64
12:32:13 <lambdabot>  *Exception: divide by zero
12:32:15 <EvanR> ?quickCheck \x -> (x :: Word8) /= 0
12:32:15 <lambdabot> Unknown command, try @list
12:32:32 <EvanR> ?check \x -> (x :: Word8) /= 0
12:32:34 <lambdabot>  *** Failed! Falsifiable (after 2 tests):
12:32:34 <lambdabot>  0
12:32:40 <gobby> > maxBound `quot` maxBound :: Word64
12:32:42 <lambdabot>  1
12:32:48 <EvanR> eventually it divides by 0 because x might be 0
12:33:10 <gobby> > minBound:: Word64
12:33:11 <lambdabot>  0
12:34:06 <Cale_> > (maxBound `quot` minBound, maxBound `rem` minBound) :: Int64
12:34:08 <lambdabot>  error:
12:34:08 <lambdabot>      • Couldn't match expected type ‘Int64’ with actual type ‘(a0, b0)’
12:34:08 <lambdabot>      • In the expression:
12:34:16 <Cale_> > (maxBound `quot` minBound, maxBound `rem` minBound) :: (Int64, Int64)
12:34:18 <lambdabot>  (0,9223372036854775807)
12:34:42 <Cale_> > (maxBound `div` minBound, maxBound `mod` minBound) :: (Int64, Int64)
12:34:44 <lambdabot>  (-1,-1)
12:35:00 <int-e> > minBound `div` (-1) :: Int64
12:35:02 <lambdabot>  *Exception: arithmetic overflow
12:35:26 <monochrom> Hey you could use divMod and quotRem :)
12:35:35 <Cale_> ah, right, I could have
12:36:14 <gobby> >testFunc (Type1 3) (6148914691236517206*3) = Final {getFinalType = 0}
12:36:21 <gobby> that's what I get with my function
12:36:50 <Cale_> > 6148914691236517206*3
12:36:52 <lambdabot>  18446744073709551618
12:36:56 <Cale_> > 6148914691236517206*3 :: Int64
12:36:58 <lambdabot>  2
12:37:16 <int-e> > 6148914691236517206*3 :: Word64
12:37:17 <lambdabot>  2
12:37:28 <gobby> > maxBound :: Word64
12:37:29 <lambdabot>  18446744073709551615
12:38:01 <int-e> > 6148914691236517205*3 == (maxBound :: Word64)
12:38:02 <lambdabot>  True
12:38:40 <Cale_> Of course it would be divisible by 3.
12:38:45 <gobby> Literal 18446744073709551618 is out of the Word64 range 0..18446744073709551615
12:38:47 <gobby> there we go
12:38:53 <gobby> that error wasn't showing u[
12:38:56 <gobby> up*
12:38:58 <gobby> only in GHCi
12:39:52 <gobby> > -6148914691236517205*3 == 18446744073709551618
12:39:54 <lambdabot>  False
12:39:59 <gobby> > 6148914691236517205*3 == 18446744073709551618
12:40:01 <lambdabot>  False
12:40:08 <gobby> > 6148914691236517205*3 
12:40:10 <lambdabot>  18446744073709551615
12:40:34 <int-e> Cale_: it's tempting to say that it's divisible by all Fermat primes ;)
12:40:39 <Cale_> > showHex 6148914691236517205 ""
12:40:41 <lambdabot>  "5555555555555555"
12:41:03 <int-e> (and 641, and 6700417)
12:43:19 <gobby> how strange, so if I use 6148914691236517206*3 in my function, it defaults to zero, but if I use 18446744073709551618 GHC complains that its out of bounds
12:44:55 <koala_man> gobby: makes sense for an Int64
12:45:37 * hackage snap-server 1.1.1.1 - A web server for the Snap Framework  https://hackage.haskell.org/package/snap-server-1.1.1.1 (GregoryCollins)
12:46:33 <monochrom> Probably because the warning just checks individual literals.
12:48:54 <monochrom> Computers are no longer strange once you accept that they execute algorithms not neural networks.
12:50:00 <EvanR> still maybe strange in the sense that the behavior isnt congruent with what i think should happen
12:50:52 <monochrom> But that's why I use the stronger "accept" not the weaker "know".
12:50:53 <EvanR> if i were gobby and i thought everything in sight was an integer (Integer), then i too would call that strange
12:51:06 <monochrom> You really have to embrace it.
12:51:42 <monochrom> Not like what some of my students do: they "know" (because they heard me in the lecture) but they go on to disobey.
12:51:54 <gobby> really useful feedback guys
12:51:58 <gobby> thanks
12:53:39 <monochrom> I taught them pattern matching (f [] = ...; f (x:xs) = ...), in fact I taught them nothing else (none of null, head, tail, length).  They go on to write "f xs | null xs = ...   | otherwise = ... head xs .... tail xs ... head xs again ... tail xs again ... tail xs for the 3rd time ..."
12:53:54 <monochrom> And that's not the worst. Some of them used "length xs == 0".
12:55:58 <monochrom> But in this case the clue I noticed was "warning: [-Woverflowed-literals]".
12:56:34 <int-e> monochrom: . o O ( you should use genericLength and add ":: Nat" here, for an appropriate type of lazy natural numbers)
12:57:37 * hackage contiguous-fft 0.2.1.0 - dft of contiguous memory structures  https://hackage.haskell.org/package/contiguous-fft-0.2.1.0 (chessai)
12:57:54 * int-e has probably trolled enough for the day (though most of it happened in another channel)
13:10:40 <hyperisco> Haskell got universal quantification in constraints 9 months ago and I didn't hear about it?!
13:10:42 <adius> Hi, is there a way to reverse a `case of` expression?
13:10:42 <adius> So that `case x of "a" -> ValueA; "b" -> ValueB` becomes `case x of ValueA -> "a" -> ; ValueB -> "b"`
13:11:40 <hyperisco> adius, Well, you can use your text editor to swap it around. Probably not what you want.
13:11:44 <monochrom> In fact I didn't hear about overflowed literals warning either!
13:11:48 <EvanR> only if the first case of is injective
13:12:03 <adius> Yeah it's injective
13:12:45 <hyperisco> If this was at the type level then yes you could.
13:12:53 <adius> It's even Bijective
13:13:09 <monochrom> You probably have to handcode it.
13:13:16 <hyperisco> At the value level there is no such thing unfortunately.
13:13:51 <hyperisco> What you could do is construct a Map, and reverse that.
13:14:17 <adius> Mh, no rather not
13:14:36 <adius> I was thinkin about using Symbols to tag the Types and reuse this somehow. Might this work?
13:14:37 <dmwit> adius: https://stackoverflow.com/q/13404208/791604
13:15:12 <hyperisco> You could define your function at the type level and then reflect the implementations you're looking for :)
13:15:53 <EvanR> a script in another language to output your reversed code
13:16:24 <monochrom> Bird has books and articles discussing how to calculate inverses, because sometimes a good way to specify what a function should do is to say "it's the inverse of this other easily explained function".
13:17:02 <EvanR> this parser is just the inverse of this show function!
13:17:05 <adius> dmwit: Thanks for the link, I was searching for the wrong keywords apparently
13:17:16 <monochrom> I joked about it to my friend "so for example you have a staple remover and from it you can calculate what a stapler looks like".
13:17:54 <adius> monochrom: Bird?
13:17:56 <dmwit> adius: Also https://stackoverflow.com/q/30815107/791604 may be interesting to you.
13:17:59 <monochrom> Richard Bird.
13:18:34 <adius> Oh yeah right. Heard that name before.
13:18:36 <dmwit> No points for noticing the pattern in my SO links here. =P
13:18:49 <monochrom> Wait, there is a pattern?!
13:19:04 <Cale_> hyperisco: It's actually had a reasonably-usable version of that since ConstraintKind became usable, in the form of the ForallF type in the constraints package.
13:19:24 <monochrom> Oh yeah! There is this screaming guy picture!
13:19:41 <dmwit> =D
13:20:09 <hyperisco> Cale_, I didn't consider it so. Suppose it depends how desperately you needed it.
13:20:32 <Cale_> Well, it helps if you have TypeApplications too, so you can have:
13:20:46 <monochrom> Yes that's my opinion on dependent typing in Haskell too.
13:21:03 <Cale_> whichever :: forall c t a r. (ForallF c t) => (c (t a) => r) -> r
13:21:03 <Cale_> whichever r = r \\ (instF :: ForallF c t :- c (t a))
13:21:05 <monochrom> It will never be usable. But people are desperate enough to deny it.
13:21:19 <hyperisco> ah someone has put together invertible parser/printer combinators? excellent… was deep in my "things to do" pile
13:21:20 <Cale_> This makes ForallF way easier to actually use
13:23:27 <EvanR> the SO link to invertible parser/pretty printer is broken
13:23:56 <hyperisco> http://hackage.haskell.org/package/invertible-syntax
13:25:36 <hyperisco> if you had an invertible parser, you'd naturally solve the problem of the AST being 1:1 with the source
13:26:08 <inkbottle> data Hello = Hello {hello :: Int} -- would "hello" be the "standard" name for the accessor, when data constructor is "Hello", and there is only one field?
13:26:17 <monochrom> dmwit: I re-studied a bit of generating functions for combinatorics, and didn't see it coming:  "data F = T | B F F" is in exact correspondence with the defining equation for its generating function: f(x) = x^1 + x^1 * f(x) * f(x).
13:27:02 <hyperisco> inkbottle, there are many conventions. It could be hello, unHello, or runHello for example, and those are just ones I know of.
13:27:06 <dmwit> monochrom: data F a = T a | B a (F a) (F a) -- ?
13:27:09 <bifunc2> I want to create a new thread using forkOS.
13:27:09 <bifunc2> I have a bunch of IO actions (with different return types, e.g. IO Int, IO Bool, etc.) that I want to execute on this thread, such that I wait for the result and exceptions that occur on the new thread get back to me in the calling (main) thread.
13:27:10 <dmwit> monochrom: But yeah, so good!
13:27:11 <bifunc2> I have a hard time doing this because of the different return types. I can't get the types to work out using forkOS/MVar/Chan, etc.
13:27:11 <bifunc2> Can you point me in the right direction?
13:27:32 <hyperisco> actually the convention for something named hello would be to Church encode it
13:27:43 <inkbottle> hyperisco: thanks for the "list"
13:27:52 <hyperisco> so that'd be  hello :: (Int -> a) -> Hello -> a
13:28:06 <monochrom> And later I thought up: Hey suppose I am too lazy to find a closed form for f (or maybe it's too hard? consider what if you have a quintic equation instead...") and I just want the first 10 terms, then I can do:  f0(x) = 0 (for all x); f1(x) = x+x*f0(x)*f0(x); f2(x) = x+x*f1(x)*f1(x)...
13:28:47 <dmwit> EvanR: Thanks for the tip. I've fixed the link.
13:28:53 <EvanR> nice
13:29:00 <monochrom> In reality I have "data F a = Tip a | B (F a) (F a)" in mind but for the essence of my problem I set a=().
13:29:51 <hyperisco> if only when you hit f2 on a URL it updated all the links
13:31:08 <monochrom> Anyway it's x^1 (more detailedly, 1*x^1) for both T and B because let's say I count the total number of both T's and B's.  (Seems to be the convention everyone uses for "how to randomly generate binary trees of size n".)
13:31:54 <hyperisco> inkbottle, I think it'd be cute if you named it "goodbye".
13:32:19 <hyperisco> Because it is also an inverse.
13:33:29 <monochrom> I'm now also thinking, on the side, if I want to say "generating function that talks about how many trees are there that have 5 T's and 4 B's" I may do "f(t,b) = t + b*f(t,b)*f(t,b)"
13:38:37 * hackage discord-haskell 0.8.0 - Write bots for Discord in Haskell  https://hackage.haskell.org/package/discord-haskell-0.8.0 (Aquarial)
13:39:38 <merijn> bifunc2: Why not use the async library?
13:41:31 <monochrom> That still doesn't reconcile Async Int with Async Bool.
13:42:00 <monochrom> So I'm going to say IO (Either Int Bool) and Async (Either Int Bool)
13:42:54 <monochrom> And MVar (Either Int Bool) etc.
13:43:02 <bifunc2> merijn, monochrom, so is that the way to go here? data MyReturnableType = All | Of | My Int Int | Possible | Choices
13:43:21 <monochrom> Yes.
13:43:24 <bifunc2> Interesting.
13:44:09 <monochrom> @quote monochrom boat
13:44:09 <lambdabot> No quotes match. Are you typing with your feet?
13:44:31 <monochrom> Oh, river!
13:44:35 <monochrom> @quote monochrom river
13:44:35 <lambdabot> monochrom says: You are to send a boolean, a character, and an integer across the river. The list for transporting across the river can hold 3 items, in fact any number of items you like, but they
13:44:35 <lambdabot> must all be of the same type. On the bright side, after crossing the river, the boolean, the character, and the integer need only be put on show. How many trips do you need? Solution: one trip, [
13:44:35 <lambdabot> show the_boolean, show the_character, show the_integer]
13:45:30 <Solonarv> whoa, that's a long quote!
13:46:01 <Solonarv> another option, if you want all types to be possible choices: use Data.Dynamic
13:46:28 <EvanR> seems ironic that the particular abilities the bool character and integer need happens to be turned into a string, which is usually the default strategy to send different things over a pipe anyway
13:47:01 <Solonarv> data Dynamic = AnInt Int | ADouble Double | DoubleToInt (Double -> Int) | ...
13:47:17 <Solonarv> ^ not the real definition of course
13:48:08 <monochrom> Understandably we want to preserve types and structures for as long as possible before degenerating to the entropic string.
13:48:19 <EvanR> if you know everything they will need on the other side, good make a record. if you dont know, youre screwed anyway from experience in OOP land
13:52:55 <bifunc2> :D
14:36:07 * hackage network-api-support 0.3.5 - Toolkit for building http client libraries over Network.Http.Conduit  https://hackage.haskell.org/package/network-api-support-0.3.5 (MarkHibberd)
14:36:19 <dmwit> Why do you want to create a thread with forkOS?
14:52:37 * hackage postmark 0.2.7 - Library for postmarkapp.com HTTP Api  https://hackage.haskell.org/package/postmark-0.2.7 (MarkHibberd)
15:05:37 * hackage pandoc-citeproc 0.16.1 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.16.1 (JohnMacFarlane)
15:08:37 * hackage instana-haskell-trace-sdk 0.2.0.0 - SDK for adding custom Instana tracing support to Haskell applications.  https://hackage.haskell.org/package/instana-haskell-trace-sdk-0.2.0.0 (basti1302)
15:13:07 * hackage debian 3.95 - Modules for working with the Debian package system  https://hackage.haskell.org/package/debian-3.95 (DavidFox)
15:21:07 * hackage cabal-debian 4.38.5 - Create a Debianization for a Cabal package  https://hackage.haskell.org/package/cabal-debian-4.38.5 (DavidFox)
15:34:39 <fen> if class Funtor_r r f where fmap_r :: (r a -> r b) -> f a -> f b
15:34:52 <fen> then what if anything is Applicative_r ?
15:36:41 <fen> % :t (<*>)
15:36:42 <yahb> fen: Applicative f => f (a -> b) -> f a -> f b
15:37:41 <c_wraith> I think you'd need to look at more theoretical derivations of Applicative.
15:38:15 <fen> Applicative_r r f => f (r a -> r b) -> f a -> f b
15:38:21 <fen> that would give the right fmap right?
15:38:50 <fen> c_wraith: what do you mean?
15:39:31 <c_wraith> the shape of (<*>) is very tied to coincidences of Functor in Hask
15:39:37 <fen> hmm, or is the `r' implicity at each location...
15:39:54 <fen> maybe it just needs a Functor_r constraint...
15:40:03 <c_wraith> you might need to go back up to theory and walk back down.
15:40:26 <fen> still not sure what you mean
15:40:30 <c_wraith> things like Applicative is a monoid in the category of Day convolution.
15:40:39 <fen> brarg!
15:41:07 <c_wraith> also, you can't ignore pure when doing Applicative stuff.
15:41:32 <fen> oh, well at least there is a place to put the `r'
15:41:54 <fen> pure_r :: Applicative_r r f => r a -> f a
15:42:23 <c_wraith> if pure_r :: r a -> f a, then you need to be careful to get fmap_r back out
15:42:34 <fen> how so?
15:42:37 <fen> maybe its;
15:42:40 <fen> Applicative_r r f => f (r a -> b) -> f a -> f b
15:43:00 <fen> as its at the `a' where each of the `r' is
15:43:58 <fen> it wouldnt need the structure r alongside the `b' as there is already the structure of the `f' of `f a'
15:44:10 <c_wraith> :t \f x -> pure f <*> x
15:44:11 <lambdabot> Applicative f => (a -> b) -> f a -> f b
15:44:25 <c_wraith> you need to keep that relationship
15:45:40 <fen> :t \f x -> (undefined :: Applicative f => f  (a -> b) -> f a -> f b) ((undefined :: Applicative f => a -> f a) f) x
15:45:42 <lambdabot> Applicative f => (a -> b) -> f a -> f b
15:46:01 <fen> :t \f x -> (undefined :: f  (a -> b) -> f a -> f b) ((undefined :: a -> f a) f) x
15:46:02 <lambdabot> (a -> b) -> f a -> f b
15:46:13 <fen> :t \f x -> (undefined :: f  (r a -> b) -> f a -> f b) ((undefined :: r a -> f a) f) x
15:46:14 <lambdabot> r1 (r2 a -> b) -> f a -> f b
15:46:22 <fen> :-(
15:47:39 <fen> :t \f x -> (undefined :: f  (r (a -> b)) -> f a -> f b) ((undefined :: r a -> f a) f) x
15:47:40 <lambdabot> r1 (r2 (a -> b)) -> f a -> f b
15:48:02 <fen> :t \f x -> (undefined :: f  (a -> b) -> f a -> f b) ((undefined :: r a -> f a) f) x
15:48:03 <lambdabot> r (a -> b) -> f a -> f b
15:48:37 <fen> its supposed to be;
15:48:44 <fen> r a -> r b) -> f a -> f b
15:48:48 <fen> r a -> r b -> f a -> f b
15:48:56 <fen> (r a -> r b) -> f a -> f b
15:48:58 <fen> sry
15:49:12 <ProofTechnique> This may be better suited to a /query with lambdabot or a GHCi session
15:49:21 <fen> just thinking that
15:49:25 <fen> thought it might work...
15:49:49 <fen> and at least answers the questions that were "would this version work"
15:49:55 <fen> the answer being no...
15:50:06 <fen> and maybe give someone the idea of what might work
15:50:12 <fen> so they might tell me!
15:50:47 <fen> or at least, an idea of why this is a totally broken idea, again which would be helpful to know
15:50:57 <glguy> Unfortunately sometimes that results in you flooding the channel with a monologue which is less good
15:51:05 <fen> yah sure
15:51:12 <fen> its an interesting idea though, no?
15:51:22 <glguy> I don't know, I didn't read the flood
15:51:26 <wroathe> Haha
15:51:40 <fen> yeah lambdabot is harsh to read
15:52:29 <c_wraith> I think on order to make this work, you need to drop way back to categorical interpretations of Applicative.
15:53:06 <c_wraith> you're looking at a system in which a bunch of coincidences turned out nicely, and wondering why it's not nice when things don't coincide.
15:53:28 <c_wraith> you could even look at it historically.
15:53:34 <fen> this might be true, but applicatives are monoids in the Day category!? no chance
15:53:54 <c_wraith> Functor and Monad were accepted long before people found Applicative
15:54:03 <c_wraith> it was not an obvious thing.
15:54:30 <fen> c_wraith: no time for that! just broke the Functor class, so every class that has it as a Constraint now needs to be rederived ! 
15:54:43 <c_wraith> patience. :)
15:54:46 <fen> would quite like to still be able to fmap over the applicatives in the code
15:55:37 <fen> well, the most direct rout to getting the code working is either to just put Functor' f alongside Applicative f constraints, or make an Applicative_r class
15:55:44 <fen> which seems like a cool thing if it works
15:56:24 <c_wraith> https://bartoszmilewski.com/2017/02/06/applicative-functors/
15:56:36 <fen> type Functor' f = Functor_r Identity
15:56:46 <c_wraith> 3 distinct derivations of Applicative from category theory in there.
15:57:05 <c_wraith> including Day convolutions. :)
15:57:54 <fen> well maybe those able to understand such things could find a solution to this urgent thing!
15:57:56 <ProofTechnique> c_wraith: Was just going to paste that link. :)
15:58:44 <fen> these answers are not "something something Day convolution, your idea *cant* work" which at least would be something!
15:59:53 <fen> foldable is easy to understand. everywhere the container is deconstructed to get at the first value, it appears inside `r' as `r a'
16:00:20 <fen> simple, so foldr :: Foldable_r r t => (r a -> b -> b) -> b -> t a -> b
16:00:49 <fen> maybe if Applicative was defined in terms of traversable it would be easier to understand
16:02:21 <fen> is there something special about traversable applicatives?
16:02:51 <fen> seems like zipWith $ 
16:08:07 * hackage contiguous-fft 0.2.2.0 - dft of contiguous memory structures  https://hackage.haskell.org/package/contiguous-fft-0.2.2.0 (chessai)
16:10:27 <fen> :t \f x -> (undefined :: f  (a -> r b) -> f a -> f b) ((undefined :: r a -> f a) f) x
16:10:28 <lambdabot> r1 (a -> r2 b) -> f a -> f b
16:10:39 <fen> thats as close as it can be...
16:10:55 <fen> but thats the wrong type for fmap
16:11:02 <fen> fmap_r
16:11:34 <fen> seems like the problem is to do with the two fs being zipped might have different shapes
16:12:13 <fen> that is, the r's might not be the same at each position
16:12:44 <fen> then is it supposed to keep the shape of the f the functions were in or the shape of the arguments container
16:14:12 <fen> not sure even bartosz can help solve this!
16:14:54 <wroathe> fen: Maybe send him an email?
16:15:31 <fen> it seems like there is no way it can work
16:16:52 <fen> and its got to be even worse for monads...
16:17:10 <fen> maybe this zipWith way of thinking about it isnt helping...
16:18:09 <fen> but that seems like the only way to match up these extra information at each position..
16:18:27 <fen> is there a specialisation of Applicative or Monad to the zipWith case?
16:20:04 <fen> that wouldnt work either as its just regular Applicative in the Traverse signature
16:20:37 <fen> this is imposibe, will just have to brute force it by putting Functor' as a constraint to Applicative'
16:20:42 <fen> im losing the prelude here
16:20:49 <fen> sry for the flood 
16:24:59 <marcx> hi. is there fromJust, head, etc equivalent for Foldable?
16:25:32 <marcx> or even better, catFoldables (as an equivalent for catMaybes), which is what I'm trying to write with such a function
16:26:44 <glguy> :t null
16:26:45 <lambdabot> Foldable t => t a -> Bool
16:26:47 <glguy> :t foldr const (error "was empty")
16:26:48 <lambdabot> Foldable t => t b -> b
16:27:11 <marcx> > foldr const (error "was empty") $ Just 10
16:27:12 <lambdabot>  10
16:27:18 <marcx> nice
16:27:33 <glguy> :t head . toList -- another option
16:27:34 <lambdabot> error:
16:27:34 <lambdabot>     Ambiguous occurrence ‘toList’
16:27:34 <lambdabot>     It could refer to either ‘Lambdabot.Plugin.Haskell.Eval.Trusted.toList’,
16:28:14 <c_wraith> marcx, you might be interested in https://hackage.haskell.org/package/witherable
16:28:24 <marcx> glguy, that was my first instinct. is it likely that list is optimized away when doing things like that (converting Foldable to list)?
16:28:38 <c_wraith> marcx, it's specifically designed for things that are filterable in some way
16:28:49 <marcx> c_wraith, interesting, I'll take a look
16:28:49 <glguy> :t concatMap toList :: Foldable t => [t a] -> [a]
16:28:50 <lambdabot> error:
16:28:50 <lambdabot>     Ambiguous occurrence ‘toList’
16:28:50 <lambdabot>     It could refer to either ‘Lambdabot.Plugin.Haskell.Eval.Trusted.toList’,
16:29:03 <glguy> <_< not learning fast
16:30:17 <glguy> > foldr (flip (foldr (:))) [] [ Just 1, Just 2, Nothing, Just 3 ]
16:30:18 <lambdabot>  [1,2,3]
16:30:33 <glguy> :t foldr (flip (foldr (:))) []
16:30:34 <lambdabot> (Foldable t2, Foldable t1) => t1 (t2 a) -> [a]
16:31:01 <glguy> Yeah witherable would have the advantage of not turning things into [] at the end
16:32:07 <marcx> since I'm feeding the result to M.fromList, that's not really a concern. but witherable might be interesting for other things
16:32:48 <marcx> :t flip (foldr (:))
16:32:49 <lambdabot> Foldable t => t a -> [a] -> [a]
16:38:34 <marcx> is t the usual type variable name for Foldable? I thought it was f
16:40:45 <Welkin> traversable/foldable
17:01:53 <marcx> @pl \x -> x
17:01:53 <lambdabot> id
17:02:11 <marcx> @pl \xs = map (\(fst,snd) -> fmap (\x -> (x, snd)) fst) xs
17:02:12 <lambdabot> (line 1, column 5):
17:02:12 <lambdabot> unexpected "="
17:02:12 <lambdabot> expecting operator, pattern or "->"
17:02:17 <marcx> @pl \xs -> map (\(fst,snd) -> fmap (\x -> (x, snd)) fst) xs
17:02:17 <lambdabot> map (uncurry (flip (fmap . flip (,))))
17:02:33 <marcx> ok..
17:03:03 <michalrus> @type deleteBy
17:03:04 <lambdabot> (a -> a -> Bool) -> a -> [a] -> [a]
17:03:05 <michalrus> Umm… how’s that useful? Why not just `(a -> Bool) -> [a] -> [a]`?
17:03:45 <marcx> > deleteBy (==) 1 [1..10]
17:03:47 <lambdabot>  [2,3,4,5,6,7,8,9,10]
17:04:04 <michalrus> Well, I know how to use it as my type, but…
17:04:08 <michalrus> What’s the real point?
17:04:31 <marcx> michalrus, no clue, it appears that (a -> Bool) would do the same thing and be clearer.. maybe I am missing something
17:04:39 <michalrus> Same. =)
17:05:07 <michalrus> others: halp
17:12:51 <marcx> (Foldable ?, Functor ?) <- what would you call ? 
17:13:24 <suzu> uhh
17:13:31 <suzu> how about `f`?
17:13:35 <marcx> or t?
17:13:44 <suzu> sure? i mean who really cares
17:13:54 <marcx> me.. or I wouldn't ask :P
17:14:07 <suzu> oh. yeah f, t, a, any of those are fine
17:14:12 <suzu> /shrug
17:14:50 <marcx> the question wasn't what would be good for the compiler, but for the human reading the code
17:15:57 <Welkin> ti s always used for foldable/traversable
17:16:00 <Welkin> t is*
17:16:22 <Welkin> but it depends on that you are doing
17:16:33 <Welkin> if you need the same `f` to be a functor and a foldable, then you shuld call it f
17:16:37 <Welkin> or t
17:16:39 <Welkin> your choice
17:17:07 <Welkin> you could call it `bulbasaursmom`
17:17:14 <suzu> yeah bulbasuarsmom is a good one
17:17:17 <Welkin> go with that one
17:17:20 <suzu> gona put that in my next paper tbh
17:17:54 <marcx> how about ft?
17:17:56 <marcx> that's the ticket
17:18:08 <marcx> > let expandKeys xs = catFoldables $ map (\(fst,snd) -> fmap (\x -> (x, snd)) fst) xs in expandKeys [([1,2,3], "foo")]
17:18:10 <lambdabot>  error:
17:18:10 <lambdabot>      Variable not in scope: catFoldables :: [f (a, b)] -> t1
17:20:31 <marcx> > let expandKeys xs = foldr (flip (foldr (:))) [] $ map (\(fst,snd) -> fmap (\x -> (x, snd)) fst) xs in expandKeys [([1,2,3], "foo")]
17:20:33 <lambdabot>  [(1,"foo"),(2,"foo"),(3,"foo")]
17:20:45 <Welkin> > 60*60*24
17:20:46 <lambdabot>  86400
17:21:02 <Welkin> lambdabot makes an okay calculator
17:21:09 <marcx> @pl \xs -> foldr (flip (foldr (:))) [] $ map (\(fst,snd) -> fmap (\x -> (x, snd)) fst) xs
17:21:09 <lambdabot> foldr (flip (foldr (:))) [] . map (uncurry (flip (fmap . flip (,))))
17:21:22 <Welkin> sometimes I use ghci, sometimes the erlang shell, other times I open up lua, or python, or node
17:21:30 <Welkin> it just depends on how I feel that day
17:21:32 <Welkin> oh!
17:21:39 <Welkin> I should use racket or chicken scheme as a caluclator
17:23:40 <marcx> they are all shitty calculators
17:24:05 <glguy> That doesn't seem like a particularly constructive comment
17:24:26 <marcx> neither was bulbasuarsmom, but I didn't complain
17:24:37 * hackage tasty-quickcheck-laws 0.0.3 - Pre-built tasty trees for checking lawful class properties using QuickCheck  https://hackage.haskell.org/package/tasty-quickcheck-laws-0.0.3 (nbloomf)
17:25:05 <glguy> Well, I can't read all the messages
17:25:18 <Welkin> bulbasaursmom is the best
17:41:16 <michalrus> Ok, so regarding `deleteBy`, how do I delete a tuple by its first element?
17:41:29 <michalrus> This signature just doesn’t make sense, at least on the surface.
17:41:32 <michalrus> @type deleteBy
17:41:33 <lambdabot> (a -> a -> Bool) -> a -> [a] -> [a]
17:41:56 <michalrus> Where to take that 2nd arg `a` from, if I only have `fst a`…
17:43:34 <Lears> @src delete
17:43:35 <lambdabot> delete = deleteBy (==)
17:44:27 <Lears> So I guess you'd want something like deleteBy ((==) `on` fst)
17:45:52 <michalrus> I guess I could go with `deleteBy (const.(==uuid).fst) undefined` but 1/ that’s unreasonable, 2/ I don’t have (Eq a) required by deleteBy, just (Eq a1, a ~ (a1,a2))
17:46:02 <michalrus> Lears: I think this Eq a still applies to your solution…
17:46:36 <marcx> > deleteBy ((==) `on` fst) (1, undefined) [(1,"foo"), (2, "bar")]
17:46:38 <lambdabot>  [(2,"bar")]
17:46:53 <michalrus> Both Int and String have Eq in scope
17:47:17 <marcx> probably not the best way to use deleteBy!
17:47:43 <michalrus> > deleteBy ((==) `on` fst) (1, undefined :: IO ()) [(1,return ()), (2, return ())] 
17:47:44 <lambdabot>  [(2,<IO ()>)]
17:47:56 <michalrus> Hmm.
17:48:08 <michalrus> > (return () :: IO ()) == return ()
17:48:10 <lambdabot>  error:
17:48:10 <lambdabot>      • No instance for (Eq (IO ())) arising from a use of ‘==’
17:48:10 <lambdabot>      • In the expression: (return () :: IO ()) == return ()
17:50:01 <michalrus> Why doesn’t this `on` version require Eq a?
17:50:24 <marcx> mine? it does
17:50:28 <michalrus> Lears? =)
17:50:56 <marcx> it requires Eq on fst, which is not IO ()
17:51:18 <michalrus> @type deleteBy
17:51:19 <lambdabot> (a -> a -> Bool) -> a -> [a] -> [a]
17:51:21 <michalrus> Why just on fst?
17:51:42 <michalrus> We’re giving it [a] which is [(Int, IO ())]
17:51:53 <Lears> deleteBy is asking for a custom equivalence function in place of an Eq a constraint.
17:52:01 <Lears> :t (==) `on` fst
17:52:02 <lambdabot> Eq a => (a, b) -> (a, b) -> Bool
17:52:42 <Lears> The equivalence function itself only needs a constraint on the fst of the tuple, so there's no problem.
17:52:43 <michalrus> Ohhhhhh, I missed that it doesn’t take an Eq, sorry
17:52:49 <michalrus> I get it now, it’s obvious
17:52:52 <michalrus> Sorry once more.
17:53:01 <michalrus> It’s 3 am, but that’s hardly an excuse.
18:32:45 <bsima> what's the point of having go' in here https://github.com/dmjio/miso/blob/master/examples/todo-mvc/Main.hs#L147-L153
18:33:12 <bsima> why not just define filterMap with those guards?
18:37:28 <c_wraith> bsima, usually that's to allow better optimization
18:38:09 <c_wraith> bsima, the outer definition isn't recursive, so it can be inlined. then the inner loop can be specialized for know values of predicate 
18:38:16 <c_wraith> *known
18:45:04 <c_wraith> ie, that style is common in code written to play as nicely with how ghc optimizes as possible.
19:51:03 <bsima> c_wraith: thanks, i didn't know that
19:51:13 <bsima> had a feeling it would be about optimizing though
19:51:43 <bsima> why not just use the INLINE pragma though?
19:53:17 <c_wraith> Because GHC will never inline a definition that's directly recursive, whether the pragma is present or not
19:53:50 <bsima> oh ok, where do i learn about that?
19:54:25 <suzu> yeah me too
19:54:59 <c_wraith> Hmm.  I don't know of any place that pulls all the details together nicely
19:55:04 <suzu> top-level recursion is bad?
19:55:33 <c_wraith> Not bad.  Sometimes it can interfere with optimization, but that often is irrelevant
19:56:10 <c_wraith> very little code is in the hot path of an inner loop
19:56:45 <c_wraith> But moving to a worker/wrapper pattern is a good idea to try when you do have a slow hot path
20:07:07 * hackage network-arbitrary 0.4.0.7 - Arbitrary Instances for Network Types  https://hackage.haskell.org/package/network-arbitrary-0.4.0.7 (alunduil)
20:07:54 <maerwald> there is too little documentation about performance topics
21:03:02 <ggole> <c_wraith> Because GHC will never inline a definition that's directly recursive
21:03:04 <ggole> Why not?
21:03:41 <c_wraith> prevents nested inlining
21:04:23 <ggole> But you wouldn't inline it that way, you would inline it using join points (if applicable)
21:04:59 <ggole> eg, it turns into a loop instead of an unrolled loop.
21:05:06 <c_wraith> those are a *far* newer idea than GHC's inlining heuristics
21:05:23 <ggole> Contification is not a new idea
21:05:38 <ggole> (Although I guess it's new in GHC)
21:06:03 <ggole> It seems as if the inliner can be improved there
21:07:22 <maerwald> you just volunteered :P
21:07:53 <ggole> :)
22:20:02 <monochrom> You too.
22:36:40 <pdxleif> What was that package that had a bunch of single-letter variables defined that let you see how things like fold reduce bit by bit?
22:36:59 <ggole> Expr, I think
22:37:03 <koz_> > bunch of single-letter variables
22:37:05 <lambdabot>  <hint>:1:7: error: parse error on input ‘of’
22:37:05 <koz_> Argh why.
22:37:54 <Lears> I think it's simple-reflect
22:39:11 <ggole> > :t a
22:39:13 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
22:40:39 <pdxleif> Yeah, simple-reflect looks like it - thanks!
22:40:44 <pdxleif> Can never remember that name.
22:42:01 <pdxleif> It's under category "Debug" on hackage - I was looking under "Education", "Learning Haskell", etc...
22:44:47 <sneakybisky> Hi guys, new to Haskell. I think the learning curve of Haskell is really steep, but Haskell really blow my mind and its beauty is awesome. Need to learn it step by step. 
22:45:11 <sneakybisky> Any advice? practice makes perfect?
22:46:02 <maerwald_> Advice on?
22:46:21 <sneakybisky> learn Haskell for happiness
22:46:43 <maerwald_> Start coding :>
22:46:47 <maerwald_> or are you lookint for learning material
22:47:46 <nshepperd> my advice is to believe in yourself
22:48:40 <sneakybisky> Thanks. I think start coding is great advice. Concept always makes me crazy. I will believe in myself:)
22:49:23 <maerwald_> Don't get overwhelmed with all the extensions and stuff other people use. Stick to the basics 
22:50:54 <Lycurgus> also don't be overwhelmed by the hype, this god has clay feet too
22:53:53 <sneakybisky> Yes, I feel great for every little new thing I learnt from Haskell. Rome is not built in one day.
22:57:40 <koz_> I can confirm: Haskell is not something you can learn fast, but what you learn will help you a lot.
23:00:52 <pdxleif> I started with learning lambda calculus, and then though of how the haskell I wrote was essentially lambda calculus with syntax sugar - it's all functions.
23:08:22 <fiddlerwoaroof> I'm trying to start intero on osx, and I'm getting a "killed: 9" message from emacs
23:09:27 <fiddlerwoaroof> I didn't kill -9 intero and when I run the command shown in the buffer, I get this: 
23:09:27 <fiddlerwoaroof> https://fwoar.co/pastebin/7f69dff6d7a99c9dcb9b040ba033b100172c24c1.nil.html
23:17:32 <coldpress> wow, I wonder how xkb handles iso14755 codepoints: on a dvorak-programmer keyboard, I don't need to press shift to enter a number into the codepoint!
23:47:08 <coldpress> ah wrong channel :(
