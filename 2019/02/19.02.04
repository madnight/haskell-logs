00:18:56 <quantum2020> hi all
00:52:30 * hackage slack-web 0.2.0.10 - Bindings for the Slack web API  https://hackage.haskell.org/package/slack-web-0.2.0.10 (EmmanuelTouzery)
01:23:56 <day> list objects appear to be monads. my understanding is that monads are necessary to work around non deterministic behavior. does this mean lists are not deterministic?
01:25:39 <Ferdirand> no
01:26:10 <Rembane> Lists are otoh used as control structures in Haskell. So... 
01:26:12 * Rembane hand waves a bit
01:26:22 <Ferdirand> but you can use lists to model non-deterministic behaviour
01:26:46 <Rembane> That was what I was after... good.
01:27:18 <Ferdirand> but monads are not necessary to work around non deterministic behavior either
01:27:21 <Taneb> day: monads can do things other than work around non-deterministic behaviour, they're a pretty general API
01:27:27 <day> i read the chess example for that in schoolofhaskell
01:28:17 <Ferdirand> also, we don't call them list objects, we just call them lists
01:28:32 <Ferdirand> and it's not that list themselves are monad
01:28:41 <Ferdirand> or even that the type of lists is a monad
01:28:57 <Rembane> They are an instance of the monad type class
01:30:38 <t4nk899> I'm writing a parser for a simple datafile format, and I'm wondering how to represent it in data. Basically it seems like it would make sense to have a list of tuples, since each row will have the same number of entries with the same datatypes. But then to know the type of the tuple I need to start parsing the file first. Not sure how to deal with this. 
01:31:04 <tdammers> t4nk899: it would help to know more specifics about the file format in question
01:31:07 <Rembane> t4nk899: Don't you know the types of each column beforehand?
01:31:27 <t4nk899> Nope, that depends on the first line which is a header line
01:31:33 <t4nk899> and then every row after that is data
01:31:42 <dminuoso> day: Monad is just a generalized interface. It has no direct purpose other than the laws it gives you.
01:31:58 <dminuoso> day: It's not much different from say Monoid, which has no concrete usage beyond capturing things that all follow the same laws.
01:32:43 <Rembane> t4nk899: Cool, do you have a set of types the columns can be? Or can they be absolutely any type?
01:32:58 <t4nk899> There's a set. Simple stuff, basically Int Float or String
01:33:30 <Rembane> Then you can use a sum type to model that. 
01:33:57 <Rembane> data ColData = CDInt Int | CDFloat Float | CDString Text
01:34:12 <t4nk899> Alright, that makes sense. How to deal with not knowing the tuple length?
01:34:13 <Rembane> And save a list of [(col, ColData)]
01:34:24 <t4nk899> oh, ok
01:34:28 <t4nk899> yeah, I could do that
01:34:31 <Rembane> So you get a list of lists. 
01:34:43 <Rembane> Hm... maybe even [[(Col, Maybe ColData)]]
01:34:49 <Rembane> ...if the format allows for empty columns
01:35:04 <t4nk899> Nope, there shouldn't be empty columns
01:35:07 <t4nk899> thanks for the help
01:35:22 <Rembane> No worries. Good luck! 
02:36:36 <dminuoso> class ( Choice p, Corepresentable p, Comonad (Corep p), Traversable (Corep p) , Strong p, Representable p, Monad (Rep p), MonadFix (Rep p), Distributive (Rep p) , Costrong p, ArrowLoop p, ArrowApply p, ArrowChoice p, Closed p ) => Conjoined p where
02:36:52 <dminuoso> This class is so clear.
02:37:57 <lyxia> Of course
02:37:59 * hackage patat 0.8.2.2 - Terminal-based presentations using Pandoc  https://hackage.haskell.org/package/patat-0.8.2.2 (JasperVanDerJeugt)
02:41:27 <nshepperd> class ... => KitchenSink p
02:41:34 <dminuoso> Heh.
02:41:59 <dminuoso> Though... in the spots where `distrib` is used I think I can, for the most part, just replace it with fmap.
02:43:06 <dminuoso> Something like `duplicate = getCompose . experiment (Compose . fmap sell . sell)` is easy to understand. But when you start talking about conjoined profunctors.. dunno, it just exceeds my mental capacities. 
02:46:08 <phadej> conjoined is hack
02:46:16 <phadej> there's nothing deep behind it
02:50:47 <cooperactive> of course there is nothing deep behind it, its beneath
02:51:49 <nshepperd1> Representable p and Strong p are redundant
02:51:56 <nshepperd1> Weird
02:58:04 <nshepperd1> I see. Conjoined is really just the typeclass for i -> a -> b
02:58:19 <phadej> nshepperd1: or a -> b
02:59:38 <dminuoso> phadej: What is the hack for?
03:00:37 <phadej> from haddocks > This permits us to make a decision at an outermost point about whether or not we use an index.
03:01:48 <dminuoso> phadej: Im not sure I completely follow that. Even staring at the type signature the equality constraint seems pointless.
03:02:25 <phadej> conjoined x y = if p == (->) then x else y
03:02:39 <phadej> in pseudo language
03:03:05 <phadej> (the "deep" part is: http://hackage.haskell.org/package/profunctors-5.3/docs/Data-Profunctor-Mapping.html)
03:05:25 <Mrbuck> Now I see all those noobs who say haskell is very hard etc....I see even learning c from c++ is very hard no ?? I see every langauge channel say we need to unlearn previus paradigm ...I thought only with haskell
03:05:29 <nshepperd1> Some sort of Haskell koan: i didn't understand the 'ersatz' package until i invented it myself, then checked hackage to see if someone had built it first.
03:06:41 <dminuoso> phadej: But doesn't the `p ~ (->)` constraint prevent a usage where p is something other than (->)?
03:06:46 <nshepperd1> That someone was ekmett, of course
03:07:34 <dminuoso> phadej: I feel like there's something subtle Im missing.
03:08:38 <phadej> dminuoso: the (->) instance is implemented as, conjoined l _ = l; everything else as conjoined _ r = r
03:09:01 <phadej> it's a hack to have different implementation for (->) case
03:09:20 <phadej> of other stuff, e.g. traversed
03:09:28 <phadej> :t traversed
03:09:29 <lambdabot> (Applicative f2, Traversable f1, Indexable Int p) => p a (f2 b) -> f1 a -> f2 (f1 b)
03:09:54 <phadej> (Indexable requires Conjoined)
03:10:30 <dminuoso> phadej: But any usage of conjoined would require the constraint `p ~ (->)` to be satisfied. How could you possibly write an instance for a different type than (->) *and* use `conjoined`?
03:11:11 <dminuoso> % class Foo p where bar :: (p ~ (->)) => p a a
03:11:11 <yahb> dminuoso: 
03:11:19 <dminuoso> % instance Foo (->) where bar = id
03:11:19 <yahb> dminuoso: 
03:11:28 <dminuoso> % data Foo a b
03:11:28 <yahb> dminuoso: 
03:11:33 <dminuoso> % instance Foo Foo
03:11:33 <yahb> dminuoso: ; <interactive>:172:10: error:; * Expecting one more argument to `Foo Foo'; Expected a constraint, but `Foo Foo' has kind `k0 -> *'; * In the instance declaration for `Foo Foo'
03:11:36 <phadej> dminuoso: no
03:11:47 <phadej> (constraint => a) -> r -> r
03:11:52 <phadej> constraint is in negative position
03:12:02 <dminuoso> phadej: Ohhh. 
03:13:18 <dminuoso> phadej: So that explains: traversed = conjoined traverse (indexing traverse)
03:13:36 <phadej> yes
03:18:57 <dmwit> nshepperd1++ for LARNIN
03:45:03 <lyxia> I seem to remember there was a package that documented the time complexity of its annotations in LaTeX, might anyone know which one it is?
03:45:44 <Taneb> lyxia: containers does that
03:45:54 <Taneb> eg http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Sequence.html#v:-62--60-
03:46:14 <lyxia> oh, I was looking at the wrong modules (Map)!
03:46:16 <lyxia> Taneb: thanks!
03:46:32 <HenryCH> hi, has anyone written a token provider service in haskell? is there an existing stable haskell package for this?
03:49:08 <trcc> To avoid reposting my question, I created a reddit post: https://www.reddit.com/r/haskell/comments/an0wwg/first_advice_advice_for_assiting_devs_with/ It concerns a package for creating simulation units, where the compilation target is a shared library. What is the best approach for helping users to create the correct cabal configuration?
04:33:30 * hackage haskus-utils-compat 1.0 - Compatibility modules with other external packages (ByteString, etc.)  https://hackage.haskell.org/package/haskus-utils-compat-1.0 (SylvainHenry)
05:00:00 * hackage haskus-binary 1.3 - Haskus binary format manipulation  https://hackage.haskell.org/package/haskus-binary-1.3 (SylvainHenry)
05:21:50 <hsn> what application are you writing in haskell i see just lot of libraries, few apps
05:22:09 <hsn> is there widely used app writen in haskell
05:22:50 <merijn> hsn: pandoc is probably the biggest/well-known application
05:23:37 <merijn> hsn: As for "what application" I write basically everything I do in Haskell if I think can get away with it at work
05:27:14 <__monty__> hsn: There's some companies with web services backed by haskell in some way. Like facebook's spam system, Wire's backend, zalando does some haskell, bunch of blockchain companies.
05:29:09 <hsn> merijn: my friend is using haskel the same way
05:29:23 <tdammers> pandoc, git-annex, and obviously ghc itself are probably the most widely used open-source haskell applications; but it is fairly popular in a few non-free niches where high levels of certainty in complex problem domains are desirable, such as banking, insurance, etc.
05:29:37 <merijn> tdammers: xmonad
05:29:41 <tdammers> merijn: yeah, that too
05:29:56 <tdammers> merijn: that was my gateway drug actually
05:30:24 <merijn> Oh, I forgot: ShellCheck!
05:30:33 <merijn> purescript
05:30:37 <merijn> elm
05:30:55 <merijn> Idris (conclusion, people like to write compilers in Haskell ;))
05:31:26 <tdammers> yes, haskell is huge in programming language research
05:32:02 <tdammers> which isn't very surprising, considering how the standard problem solving approach in Haskell seems to be "let's start out by writing an EDSL to capture the problem domain"
05:34:14 <lantti> oh that reminds me, i should eventually characterize a problem domain and write and EDSL to capture it
05:34:27 <lantti> one of these days...
05:34:37 <tdammers> put it on your To Do list
05:34:55 <tdammers> of course that requires a ToDo-EDSL
05:43:05 <lantti> it is on my todo-list, i even have a ghc trac ticket for it, jos that my free time got scattered to such small pieces lately that i can't get anything done
05:44:00 <lantti> i seem to need several hours of uninterrupted focus to actually come to the point of making progress, until that it is just mental task switching overhead
05:48:59 * hackage haskus-web 1.0 - Haskus web  https://hackage.haskell.org/package/haskus-web-1.0 (SylvainHenry)
06:00:29 * hackage haskus-web 1.1 - Haskus web  https://hackage.haskell.org/package/haskus-web-1.1 (SylvainHenry)
06:03:08 <hsn> anybody of you has been hire specialy as haskell programmer?
06:04:37 <aldum> I've been asked for a haskell position in Warsaw
06:18:26 <Taneb> hsn: yes
06:21:55 * hackage ewe 0.3.1.1 - An interpreter for EWE programming language  https://hackage.haskell.org/package/ewe-0.3.1.1 (JuanFranciscoCardonaMcCormick)
06:27:47 <aplainzetakind> A language that only expresses data and does not get involved with execution would still be called a DSL right?
06:28:29 <tdammers> yes
06:28:31 <trcc> I do not see why not
06:28:38 <tdammers> it's still a language, just not necessarily a programming language
06:29:13 <tdammers> besides, the distinction is fairly arbitrary
06:29:32 <tdammers> whether you interpret it as something you can execute or not is largely up to you
06:30:03 <aplainzetakind> Is it possible to find an example of the process of designing and developing such a thing? Like a look-what-I-did blog post or something?
06:30:20 <tdammers> take, for example, ansible playbooks, a format based on YAML - YAML is considered a "data" language without any execution semantics, but ansible playbooks are essentially executable scripts
06:31:15 <aplainzetakind> Or an easy to follow codebase of one...
06:31:35 <tdammers> "one" being some DSL?
06:31:41 <aplainzetakind> Yes.
06:33:07 <tdammers> you may want to look into the Pandoc source code - it's fairly easy to follow, and follows the classic 2-part compiler architecture (parser -> AST -> writer)
06:33:38 <tdammers> "Write Yourself A Scheme in 48 Hours" is a nice palatable introduction to both Haskell and programming language implementation
06:34:23 <tdammers> if you're interested in how you'd implement a language like Haskell, I recommend reading Stephen Diehl's "Write You A Haskell"
06:35:02 <tdammers> those are all fairly large DSLs though, or actually full-blown programming langugaes
06:35:21 <tdammers> smaller DSLs can be found all over the Haskell ecosystem, you might not even notice
06:35:59 <koz_> For Haskell implementation details, SPJ's old-af book is also a fun read.
06:36:02 <tdammers> a famous example is the ubiquitous `lens` library, which you could consider an EDSL for manipulating nested data structures (among other things)
06:36:13 <koz_> The chapter on pattern matching (although not by SPJ) is particularly informative.
06:38:14 <aplainzetakind> Write You a Haskell seems very cool. I was wishing for something like that.
06:39:23 <aplainzetakind> koz_: Is the SPJ book Haskell 98 Language and Libraries?
06:39:46 <koz_> aplainzetakind: No, it's something else. The title eludes me, but it's pretty old (like, 80s old).
06:40:54 <Ariakenom> The Implementation of Functional Programming Languages https://www.microsoft.com/en-us/research/publication/the-implementation-of-functional-programming-languages/
06:40:55 <aplainzetakind> Implementing Functional Languages?
06:41:18 <aplainzetakind> OK.
06:42:29 <aplainzetakind> Thanks.
06:44:27 <Ariakenom> np. good reminder I should have a look at that sometime
06:45:24 <aplainzetakind> Ah, Write You a Haskell is unfinished.
06:49:07 <rts-sander> what do you mean unfinished, I was under the assumption that write you a haskell would give good foundational knowledge of haskell
06:49:33 <trcc> rts-sander: it does
06:50:17 <rts-sander> trcc, ah ok then it's all good, I'll continue with it at some point
06:50:27 <trcc> rts-sander: how far are you?
06:50:52 <rts-sander> trcc, Higher Order Functions
06:50:55 <trcc> ok
06:51:49 <trcc> After chap 12 I would start doing some actual coding. Maybe go on to https://github.com/data61/fp-course
06:53:48 <rts-sander> yeah thanks, writing some actual code will solidify the knowledge
06:54:19 <ski> @where CIS194
06:54:20 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
06:55:20 <trcc> ski: like that better? 
06:55:50 <ski> iiuc Data61 is a bit more advanced. or maybe more fast-paced
06:55:58 <ski> (than CIS194)
06:56:00 <trcc> hmm ye
06:56:08 <trcc> do both :P
06:56:15 <ski> you may want to try both
07:00:07 <aplainzetakind> I see no chapters beyond 10?
07:01:51 <rts-sander> aplainzetakind, you sure? http://learnyouahaskell.com/chapters
07:02:21 <aplainzetakind> Not Learn You a Haskell, http://dev.stephendiehl.com/fun/
07:04:31 <ski> is it in progress, or (currently) stalled ?
07:05:32 <aplainzetakind> The git repo hasn't seen commits in two years.
07:05:38 <__monty__> Diehl's thing's been stalled for year(s?) now.
07:07:51 <ski> @where WYAH
07:07:51 <lambdabot> I know nothing about wyah.
07:07:56 <ski> @where+ WYAH "Write You a Haskell" (unfinished) by Stephen Diehl in 2015- at <http://dev.stephendiehl.com/fun/>
07:07:57 <lambdabot> Nice!
07:54:47 * hackage vector-builder 0.3.7 - Vector builder  https://hackage.haskell.org/package/vector-builder-0.3.7 (NikitaVolkov)
08:15:42 <gentauro> if anybody lives in `Ørestad`, come and listen to `Oskar Wickström` at this months MF#K -> https://www.meetup.com/MoedegruppeFunktionelleKoebenhavnere/events/258032905/
08:15:46 <gentauro> gonna be good :-)
08:20:59 <ski> gentauro : perhaps that could be mentioned in #haskell.scandinavian as well
08:21:39 <gentauro> ski: done :-)
08:21:47 * ski smiles
08:21:47 <gentauro> ski: not so many people there ;)
08:22:02 <ski> one more, now
08:22:19 <gentauro> (quality, not quantity) xD
08:26:53 <gentauro> ski: updated my irssi config so I will auto-join ;)
08:38:17 * hackage hledger 1.13.2 - Command-line interface for the hledger accounting tool  https://hackage.haskell.org/package/hledger-1.13.2 (SimonMichael)
08:42:46 <jsc39> Hello
08:47:53 <shapr> good morning!
08:48:08 <iqubic> morning shapr
08:52:55 * byorgey waves at shapr 
08:53:40 <shapr> howdy byorgey !
08:53:48 <shapr> howdy iqubic !
08:54:18 <shapr> I guess my social responses are saved in a stack instead of a queue.
08:55:17 * hackage omnicodec 0.8 - Data encoding and decoding command line utilities  https://hackage.haskell.org/package/omnicodec-0.8 (MagnusTherning)
08:56:17 * hackage sandi 0.5 - Data encoding library  https://hackage.haskell.org/package/sandi-0.5 (MagnusTherning)
08:59:24 <byorgey> shapr: a queue would seem to make more "sense", but I feel like in practice humans usually default to a stack.
09:00:04 <byorgey> something about time as a list zipper...
09:01:22 <wroathe> But to be clear, how you self-identify is entirely up to you. We don't discriminate against containers here.
09:14:06 <__monty__> As long as they're immutable.
09:19:42 <Solonarv> hey, mutable containers can be useful too
09:20:21 <Solonarv> they have opportunity to be more performant than stuffing an immutable container into a {IORef,STRef,MVar,TVar}
09:26:32 <iqubic> I use a red-black auto-rebalencing binary tree.
09:27:12 <iqubic> How I traverse it depends on the day. Also, the sorting method depends on the situation. It's really a flexible way to manage social situations.
09:29:15 <Solonarv> I use an opaque primitive data structure that I don't have a name for, because the overhead of implementing something else is too big
09:31:42 <wroathe> I use a hash table with a perfect hash function. They didn't tell me how difficult it would be to assimilate new data using that strategy.
09:32:17 * hackage th-lift-instances 0.1.12 - Lift instances for template-haskell for common data types.  https://hackage.haskell.org/package/th-lift-instances-0.1.12 (BennoFuenfstueck)
09:41:56 <zzz> you can also ignore all stateful input and only output for testing purposes, guarding total control of mutability and keeping total referential transparency. we sometimes refer to this as the "ivory tower" approach.
09:47:55 <portnov> hi all
09:48:21 <portnov> Q: how to choose between Data.Vector and Data.Array?
09:48:35 <portnov> what are pro / cons?
09:49:40 <zzz> portnov: it depends on what you want to do
09:49:47 <portnov> obviously
09:49:49 <portnov> :)
09:50:00 <glguy> vector has an interesting fusion framework, it's good for making and consuming lots of bits of vector. It can efficiently slice vectors.
09:50:08 <glguy> array has a nicer indexng api
09:50:16 <portnov> but there are should be some guidelines like "arrays are good for X" and "vector is good for Y"
09:50:21 <portnov> i guess
09:52:14 <Solonarv> if your index is Int and starts at zero already, use Vector 100%
09:52:54 <glguy> array lets you do things like index by a pair of Int
09:53:01 <portnov> and if I have something like (Int, Int) or...?
09:53:10 <portnov> it can be converted to Int in many cases
09:53:30 <glguy> manually converting back to an Int is error prone
09:53:34 <wroathe> I love how the documentation on generics just glosses over handling metadata like, "this exists, but we're not going to show you how to work with it"
09:53:40 <Solonarv> everything you could use to index an Array can be converted to Int, that's how Array's indexing works
09:54:01 <portnov> so "Array is a Vector with nicer indexing API"?
09:54:32 <Solonarv> it has a more limited API in other ways, IIRC
09:54:54 <Solonarv> and probably has more overhead, and has worse slicing
09:55:22 <Solonarv> slicing Vector is (nearly) zero-cost
09:55:24 <geekosaur> vector is also optimized for various common use cases. but if your use case doesn't fit it, sometimes fusion backfires and you end up better off (faster) using Array
09:55:30 <glguy> sometimes you want the slicing, sometimes that's an easy way to hold on to too much memory, it's just all stuff to be aware of
09:55:58 <portnov> geekosaur: where to look for list of that use cases ?
09:55:59 <Solonarv> even if slicing retains too much memory, you can use 'Data.Vector.force' to explicitly copy
09:56:35 <glguy> Solonarv: Yeah, that's error-prone like getting indexing right
09:56:53 <Solonarv> fair
09:57:23 <geekosaur> I don't think there's a list as such
09:57:36 <glguy> I use both, I'm just sticking up for array because it's typically too quickly dismissed :)
09:57:38 <zzz> portnov: use cases are infinite, and there are many kinds of arrays (see https://wiki.haskell.org/Arrays) so what you are asking is a nearly impossible question to answer
09:57:54 <portnov> heh
09:58:06 <portnov> so this is like "try and select what you like"?
09:58:09 <portnov> okay
09:59:24 <zzz> more like a "understand how data structures work and how they can behave in solving your problem. that being said, nothing like testing for performance
09:59:35 <wroathe> portnov: Well, what specifically are you trying to do?
10:00:51 <zzz> i'm assuming that performance is what you're after
10:00:52 <portnov> my particular use case is a board, like in chess. Two-dimensional array. I prefer it to be immutable.
10:01:13 <portnov> zzz: not only, but mostly performance, yes :)
10:01:48 <portnov> so in my usecase i do not need slicing, only lookups and updates
10:03:08 <portnov> from API point of view, even Data.Map.Map (Int,Int) Piece would work :)
10:04:16 <Solonarv> I'd go with that or Array (Int, Int) (Maybe Piece)
10:04:50 <Solonarv> Map has better sharing
10:04:58 <portnov> so with Vector + custom indexing I would not gain anything?
10:04:58 <glguy> There's also mutable arrays if you're doing a lot of updating
10:05:02 <Solonarv> (which isn't difficult, since Array has no sharing at all)
10:09:40 <wroathe> So I must have mistyped something, because I'm getting an error stating that there's no instance of my typeclass for [Char]
10:09:43 <wroathe> https://gist.github.com/JustinChristensen/c139d76731b32dbdda5a27c22aa19afb
10:10:41 <portnov> Solonarv: so Map vs Array is "memory sharing" vs "faster indexing"...
10:10:42 <wroathe> Foo and Bar are both simple product types like data Bar = Bar { bar :: Bool, foo :: String } deriving (Generic)
10:11:14 <Solonarv> portnov: for an 8x8 chessboard it's unlikely to matter, unless you're writing a chess AI
10:11:28 <portnov> heh, why not? :)
10:11:48 <portnov> also, some games have a bit bigger board.
10:12:57 <Solonarv> Map's indexing is O(log(size of map)), so it's still very fast
10:13:30 <Solonarv> your choice of map vs. array is unlikely to have a big effect on performance if you're not accessing it in a tight loop
10:15:00 <portnov> from indexing perspective, i think so. But if i do a lot of updates, it can produce more or less work for GC
10:15:39 <portnov> and at least in some cases GC is able to eat all resources available :)
10:17:12 <Solonarv> wroathe: your K1 instance just recurses again; in fact all your GetFieldG instances except for V1 and U1 just recurse and never do any work
10:17:45 <Solonarv> the V1 and U1 instances are not involved at all, since Foo and Bar are simple product types
10:17:53 <wroathe> Solonarv: I was just about to come to that conclusion :P
10:18:53 <wroathe> Solonarv: Thanks again
10:19:13 <Solonarv> you also need 'b' to be somehow present at the type level; it should probably just be a parameter of the 'GetField' and 'GetFieldG' classes
10:20:23 <Solonarv> additionally you need more than one instance for M1: specifically, you need to have an instance for 'MetaSel' that looks at the field's name and compares it to the string argument of getFieldG
10:20:36 <wroathe> Solonarv: I was getting to that last bit
10:20:50 <wroathe> Solonarv: (Which is why I complained about the docs on MetaSel above)
10:24:14 <wroathe> I was thinking that the [Char] it was referring to was the String parameter in my function, and so I thought I mistyped a function application somewhere. While I was stating my problem here I started realizing that GetField c in my K1 instance really does imply that c really does have to be a GetField instance :D
10:24:28 <wroathe> Blinders again
10:24:50 <Solonarv> heh
10:25:51 <Solonarv> I'd just go with a 'GetFieldG (M1 i (MetaSel ...) (K1 i b)) b' instance, I thnk
10:26:07 <Solonarv> (also changing GetFieldG to be a two-parameter class)
10:26:59 <wroathe> Even though I'm implementing this, I don't really need it immediately for anything. I'm just trying to get more familiar with how Aeson does it's FromJSON black magic. This seems as good a problem to solve as any.
10:27:15 <Solonarv> yea that makes sense
10:28:08 <Solonarv> you can have a look at https://github.com/Solonarv/generic-serde - it's far from finished and I don't really intend to work more on it, but I wrote it fairly recently trying to get my head around generics a bit more
10:28:25 <wroathe> Thanks. I'll have a look.
10:32:48 <wroathe> In general specifying V1 and U1 are still probably a good idea because there's nothing stopping the user of this thing from trying to create instances for Void and Unit
10:33:08 <wroathe> (In my example that would obviously not be the case)
10:33:35 <Solonarv> oh of course
10:34:16 <Solonarv> a tip for the V1 instance: turn on EmptyCase and write 'getFieldG v1 _ = case v1 of {}'
10:34:31 <Solonarv> this will force the bottom in v1, instead of ignoring it and producing a new one
10:35:46 <wroathe> Solonarv: The net effect should be the same though, right? That said, I do like the idea of using the existing bottom. I wonder why the docs for GHC.Generics recommend just doing it this way?
10:36:01 <Solonarv> they probably predate EmptyCase
10:36:47 * hackage hoauth2 1.8.4 - Haskell OAuth2 authentication client  https://hackage.haskell.org/package/hoauth2-1.8.4 (HaishengWu)
10:45:00 <wroathe> So because b is arbitrary, I was originally thinking that it doesn't make sense to make it a typeclass param. Without a param for b, my program still compiles and forces the caller of getField to specify what the return type should be
10:45:35 <wroathe> My understanding of multi-param typeclasses is that you're specifying a finite set of relationships between types
10:45:53 <wroathe> So I'd have to say essentially Foo -> String, Foo -> Int, Foo -> Bool, etc...
10:46:19 <wroathe> So what's the value of making b a typeclass param here?
10:48:31 <Solonarv> you need to somehow check whether the type of the field you're looking at matches 'b'; making 'b' a typeclass param is one way of doing that
10:48:45 <Solonarv> (the other way is a 'Typeable b' constraint on getField and getFieldG)
10:59:35 <wroathe> Solonarv: One last question: https://github.com/bos/aeson/blob/master/Data/Aeson/Types/FromJSON.hs#L1059
11:00:08 <wroathe> It looks like he's using ScopedTypeVariables here to construct bottom with a specific type?
11:00:19 <wroathe> To pass to selName
11:00:41 <lyxia> yes
11:01:27 <Solonarv> selName is from the GHC.Generics API, and sadly doesn't use Proxy (perhaps it predates Proxy?)
11:01:27 <wroathe> lyxia: Stupid question, where is he getting t and p from?
11:01:47 <lyxia> nowhere, they're introduced there
11:01:48 <wroathe> lyxia: Or is just assumed to be any t and p
11:01:52 <wroathe> Ah
11:02:23 <Solonarv> at a guess, t is introduced there; p might be from parseRecord's signature
11:02:28 <lyxia> I think Proxy is pretty old, but the practice of it is quite newer.
11:02:56 <lyxia> no p is also from there, you need an explicit instance signature if you want to bind more variables.
11:02:59 <Solonarv> it being poly-kinded is a bit more recent, though
11:03:14 <lyxia> that's true
11:03:42 <lyxia> I think I would rewrite it as (undefined :: _t s _a _p) to make it clear which variable matters.
11:03:47 * hackage ghc-lib 0.20190204 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-0.20190204 (shayne_fletcher)
11:09:35 <wroathe> So, ignoring Data.Proxy, this bottom trick seems to be the original go-to mechanism for read type-level information into the term level
11:09:44 <wroathe> reading type-level
11:10:06 <wroathe> Which is one of the many things that makes DataKinds useful?
11:10:58 <Solonarv> eh, it's not that related to DataKinds
11:11:14 <wroathe> Meaning that one can annotate a term with all kinds of random metadata, and then use ScopedTypeVariables to fetch that data
11:11:16 <Solonarv> the Storable API uses that "trick" as well, no DataKinds in sight there
11:12:12 <Solonarv> but yes, that's right
11:12:40 <wroathe> Well, without DataKinds how do you go about storing things like numbers, strings, and booleans in types?
11:14:00 <Solonarv> there are more convoluted ways
11:14:04 <wroathe> MetaSel :: Maybe GHC.Types.Symbol -> SourceUnpackedness -> SourceStrictness -> DecidedStrictness -> Meta
11:14:12 <wroathe> For example
11:14:22 <Solonarv> 'data Z; data S n' is a way to get type-level naturals, for example
11:14:46 <wroathe> Ah, I see
11:14:57 <Solonarv> and sometimes you just need to pass around types anyway, e.g. 'sizeof (undefined :: Bool)'
11:18:46 <wroathe> The fact that bottom is a member of all of the lifted types is one of those sentences that seems obvious an unimportant at first read, but seeing tricks like this really makes you respect the importance and implications of that
11:19:08 <wroathe> The first time I read that I was like, "well, yeah, things can error, durr"
11:19:49 <wroathe> obvious and unimportant*
11:20:55 <Solonarv> tbh this is a really terrible use of bottoms
11:21:10 <Solonarv> I'm glad we have Proxy and TypeApplications so we don't need to do that anymore
11:21:24 <wroathe> I understand that, but the fact that bottom is an actual term present in all of the lifted types is kind of a neat concept
11:21:50 <wroathe> Instead of the abstract notion of an "exception"
11:22:20 <wroathe> Like, at the intersection of everything, there lies bottom
11:22:29 <wroathe> lays*
11:22:50 <Solonarv> yeah, it is nea
11:23:22 <Solonarv> falls naturally out of turing completeness, too
11:31:38 <Boarders> is there a way to quote a block of ASCII in a haddock comment
11:31:48 <Boarders> e.g. if I wanted to include an ASCII diagram
11:32:36 <lyxia> Use ">"?
11:32:49 <[exa]> Boarders: you can certainly copy the way from here https://hackage.haskell.org/package/brick
11:32:59 <[exa]> (down in the example)
11:33:24 <dyl> Somewhat silly question. Given a `Tree a`,  I'm looking for a nice pattern (lenses?) for mapping each root and it's immediate children to some value (e.g. a -> [a] -> b).
11:33:33 <dyl> For simplicity let's assume b is a monoid, so something like:
11:33:45 <dyl> f : Monoid b ⇒ Tree a -> (a -> [a] -> b) -> b
11:33:52 <Boarders> cool, thank you
11:34:12 <dyl> Basically foldMap over a tree, except including the immediate descendants in the accumulation function.
11:34:18 <[exa]> dyl: what happens with the rest of the tree??
11:35:05 <dyl> [exa] what I'm looking for is something like mapping over a sliding-window on a list, but with a tree.
11:35:09 <lyxia> dyl: have you seen recursion-schemes
11:35:12 <dyl> Yes.
11:35:14 <[exa]> dyl: ooh got it now.
11:35:14 <Boarders> http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Tree.html#v:foldTree
11:35:18 <Boarders> what about that?
11:35:24 <dyl> foldTree doesn't do what I want, that's [b]
11:35:39 <dyl> I do not want to propagate results up or down the tree.
11:35:48 <dyl> This is more akin to a map than a fold, really.
11:36:27 <dyl> foldTree :: (a -> [b] -> b) -> Tree a -> b, but I want mapSubtrees :: Monoid b ⇒ (a -> [a] -> b) -> Tree a -> [b] 
11:36:41 <dyl> or more generally foldmapSubtrees :: Monoid b ⇒ (a -> [a] -> b) -> Tree a -> b
11:37:12 <dyl> foldTree is close, but it feeds results upwards into the accumulator. 
11:37:51 <dyl> For context: I am computing visibility graphs for view hierarchies, so I only care about a "super" view and its immediate children, but I need to apply this process for every non-empty view in the hierarchy. 
11:37:59 * ski doesn't see how the latter is "more generally"
11:38:01 <dyl> (and then I mappend the results (graphs) together)
11:38:20 <[exa]> dyl: why not have a custom 1-line function that converts Tree a to Tree (a,[a]) and then fold.map f ?
11:38:46 * ski . o O ( `Tree a -> Tree (Tree a)' )
11:39:20 <dyl> Hmm, I like [exa]'s approach.
11:39:33 <[exa]> seriously go with ski's approach, it's nicer
11:39:37 <dyl> Haha.
11:39:38 <[exa]> and maybe even faster
11:39:55 <dyl> I was going to say that, but (full disclosure) I'm not actually working in Haskell :p.
11:40:02 <[exa]> lol
11:40:11 <dyl> I ported Data.Tree myself though, so my available functions are identical. 
11:40:42 <dyl> Typeclasses otoh... kind of a hack. 
11:40:49 <dyl> ski Are you suggesting using a comonad instance?
11:40:51 <[exa]> dyl: well depends on if your language's laziness is powerful enough then
11:41:07 <ski> hm .. maybe ?
11:41:12 <Boarders> given that it is not in haskell I would just write the recursion by hand
11:41:16 <Boarders> it is only like 5 lines
11:41:23 <[exa]> Boarders: too much! :D
11:41:26 <iqubic> I don't understand what's going on here.
11:42:02 <dyl> ski the thing that gives me pause about `Tree a -> Tree (Tree a)` is that I don't want all of the subtrees at each node, nor do I even want more than one layer deep.
11:42:10 <dyl> I just want (parent, immediate children).
11:42:28 <dyl> So, perhaps doing it [exa]'s way, while less... satisfying... might be more effective.
11:42:53 <[exa]> dyl: in fact, by constructing a new (,) and several new (:) my approach is in fact slower than ski's
11:42:59 <Solonarv> explicit recursion seems like a perfectly cromulent way to solve this tbh
11:43:41 <[exa]> dyl: (these might disappear in inlining but you never know)
11:44:24 <dyl> `Tree -> Tree (Tree a)` would (I think) have more frivolous constructors though. 
11:44:31 <dyl> My Tree type is eager, but has value semantics.
11:44:44 <dyl> So, it's going to be a lot of copies and a lot of Node [] a [].
11:44:48 <iqubic> I use recursion-schemes.
11:45:24 <dyl> (I'm using A-Certain-OCaml-Derivative-That-Must-Not-Be-Named :p)
11:46:30 <ski> (do you happen to like stockhausen ?)
11:46:34 <Boarders> dyl when you do:  Monoid b ⇒ (a -> [a] -> b) -> Tree a -> b
11:46:55 <Boarders> do you want it to compute that monoid value on each of the subtrees and <> it together with the top value
11:46:57 <Boarders> or what?
11:47:00 <Boarders> it is a bit unclear
11:47:25 <dyl> "subtree" here is a bit misleading.
11:47:41 <dyl> For each Node, I care about the root, and the *immediate children* only.
11:48:01 <ski> preorder ?
11:48:01 <dyl> (for all nodes)
11:48:05 <Boarders> like:
11:48:07 <dyl> Order is irrelevant. 
11:48:08 <Boarders> f : Monoid b ⇒ (a -> [a] -> b) -> Tree a -> b
11:48:15 <ski> oh, commutative monoid ?
11:48:21 <dyl> Yeah.
11:48:44 <Boarders> f fn tree = fn (rootLabel (childrenRoots tree))
11:48:47 <ski> (perhaps there should be a subclass for that)
11:48:49 <dyl> I'm building a visibility graph at each node, where the root is the "parent" view and the children are the immediate child views.
11:48:54 <Boarders> where childrenRoots = fmap rootLabel . subForest
11:48:58 <dyl> And I have a commutative monoid over graphs.
11:49:03 <Boarders> I don't think this is what you have in mind?
11:49:04 <ski> with less brackets
11:49:24 <ski> and applying at every subtree, combining with `(<>)'
11:49:59 <Solonarv> % import Data.Tree
11:49:59 <yahb> Solonarv: 
11:50:13 <Solonarv> % :i Tree
11:50:13 <yahb> Solonarv: data Tree a = Node {rootLabel :: a, subForest :: Forest a} -- Defined in `Data.Tree'; instance Applicative Tree -- Defined in `Data.Tree'; instance Eq a => Eq (Tree a) -- Defined in `Data.Tree'; instance Functor Tree -- Defined in `Data.Tree'; instance Monad Tree -- Defined in `Data.Tree'; instance Show a => Show (Tree a) -- Defined in `Data.Tree'; instance Read a => Read (Tree a) -- Defined in `Data.T
11:50:13 <dyl> I'm thinking about it more as mapping each subtree to a graph (built only from the 0th and 1st level) and then I'll handle reducing it after that.
11:50:37 <dyl> The "critical" issue is that map only operates over a single a, whereas I want the immediate children also. 
11:51:17 <ski>   f fn tree = foldMap flatten (tree =>> \subTree -> fn (rootLabel subTree (map rootLabel (subForest subTree))))  -- something like this, perhaps
11:51:33 <iqubic> dyl: That's where a paramorphism would help/
11:51:43 <ski> (er, sorry, i also managed to screw up brackets)
11:51:46 <Solonarv> % let { foldMapImmediate :: Monoid m => (a -> [a] -> b) -> Tree a -> b; foldMapImmediate f (Tree a ts) = f a (rootLabel <$> ts) <> foldMap (foldMapImmediate f) ts }
11:51:47 <yahb> Solonarv: ; <interactive>:175:91: error:; Not in scope: data constructor `Tree'; Perhaps you meant `True' (imported from Prelude)
11:52:00 <dyl> I'm thinking I could probably go from Tree a -> Tree (a, [a]) with an unfold, using the original tree itself as a seed.
11:52:47 <Solonarv> % let { foldMapImmediate :: Monoid b => (a -> [a] -> b) -> Tree a -> b; foldMapImmediate f (Node a ts) = f a (rootLabel <$> ts) <> foldMap (foldMapImmediate f) ts } -- fixed
11:52:47 <yahb> Solonarv: 
11:53:01 <Solonarv> direct recursion seems reasonable to me
11:53:10 <dyl> Yeah, if it works it works :p.
11:54:07 <dyl> I was hoping to see some neat recursionschemes/lens one-liner haha. 
11:54:21 <dyl> (even though I sadly only have lenses, and no recursion schemes, available to me.)
11:54:30 <dyl> no general recursion schemes library*
11:59:46 <wroathe> Solonarv: So now I'm in a state where I've got overlapping instances for S1
11:59:53 <wroathe> https://gist.github.com/JustinChristensen/49c1d7a39adb088d90db674924d7b443#file-overlapping-hs-L59
12:00:00 <wroathe> Which was to be expected
12:00:05 <iqubic> dyl: use a paramorphism.
12:00:18 <wroathe> The question is, is there a way to write the second instance declaration so it doesn't overlap with the more specific one above it?
12:00:25 <dyl> I do not have a general recursion scheme librarty available to me.
12:00:32 <wroathe> (so that I don't need to turn on OverlappingInstances)
12:00:58 <Solonarv> wroathe: just put a {-# OVERLAPS #-} pragma on the more specific one, or an {-# OVERLAPPABLE #-} pragma on the more general one
12:01:07 <Solonarv> you don't need to turn on OverlappingInstances for that
12:01:45 <aplainzetakind> Are there any caveats with DeriveAnyClass'ing Random?
12:02:00 <wroathe> Will GHC be able to find the correct instance in the more specific case?
12:02:12 <Solonarv> it should, yes
12:02:31 <Solonarv> aplainzetakind: yes: it makes you turn on DeriveAnyClass
12:03:05 <aplainzetakind> And what's bad about it?
12:03:19 <Solonarv> any use of 'deriving (SomeClass)' with DeriveAnyClass can be replaced by a standalone 'instance SomeClass MyType' declaration
12:03:55 <Solonarv> DeriveAnyClass means you end up with bogus instances if you accidentally write 'deriving Class' when an empty instance is not valid for Class
12:05:19 <aplainzetakind> So it only 'derives' empty instances?
12:05:23 <Boarders> if I have a record where each fo the fields has a monoid instance is there any easy way to get the product monoid instance?
12:05:52 <Solonarv> aplainzetakind: exactly; DeriveAnyClass just writes an empty instance declaration, basically
12:06:14 <aplainzetakind> How useful.
12:06:15 <aplainzetakind> Thanks.
12:06:36 <Solonarv> Boarders: yes, with recent GHC and the 'generic-data' package
12:08:15 <untseac> hey. is there an answer in pure haskell to something like elm? I really don't like other JS libraries. Well I don't like the web in general.
12:09:02 <Solonarv> Boarders: you can write 'data MyType = MyType { ... } deriving (Semigroup, Monoid) via (Generically MyType'
12:09:49 <Solonarv> untseac: yes, but I personally don't have a good overview of those libraries. Stick around and someone else may expand.
12:10:29 <Boarders> Solonarv: interesting, thanks
12:10:38 <untseac> Solonarv, alright, thanks. I know there's GHCJS but I have zero experience. I just want to know which to look at.
12:11:37 <Solonarv> Boarders: the extension you need is DerivingVia, it was added in ghc 8.6.1; docs here: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-DerivingVia
12:11:37 <dyl> Solonarv ran it through the ringer and... https://gist.github.com/DylanLukes/3b1625da67794505d879ea50322589f4
12:11:41 <dyl> It works though :p
12:13:19 <WilliamHamilton[> lyxia: I keep encountering what I think is a ghc bug for a function that I imho should be able to write (ghc starts leaking memory and I have to kill it quite fast). Here's the incriminating line https://github.com/meditans/unification-sop/blob/master/src/Generic/Unification/Substitution.hs#L287
12:14:20 <WilliamHamilton[> if you substitute the typed hole with the stuff behind the comment, and try to load it in ghci (or ghcid, or the like), you'll see the bug. I wonder if you have some insight on the matter
12:16:46 <WilliamHamilton[> also pinging kosmikus because the previous times I saw ghci leaking memory in this way it was linked to the use of hcmap from Generics.SOP (in particular when passing an incorrect proxy), so he could have more insights
12:17:23 <MarcelineVQ> WilliamHamilton[: is this looping + eating memory?
12:18:35 <WilliamHamilton[> MarcelineVQ: from `top` I saw ghc using 100-150% of the cpu and the memory usage progressed till I had to reboot because the pc was unusable (I learned to keep `kill -9` ready)
12:20:11 <hololeap> in reactive-banana, i have an event which updates a behavior using accumB. i want to print the new value of this behavior when the event fires. is this possible?
12:20:15 <MarcelineVQ> I guess that's a silly question since it's not obvious when something's looping or just doing more work than expected. yeah I made a haskell program for killing ghc and hot-keyed it for similar situations :X
12:20:52 <lyxia> WilliamHamilton[: I can't see a potential source of the problem, sorry :/
12:21:27 <hololeap> WilliamHamilton[, MarcelineVQ: look into Alt+SysRQ+F :p
12:21:49 <WilliamHamilton[> MarcelineVQ: I think in this case it's clear that's looping, because when the code is right memory and cpu usage are much lower and clearly spike, and then come down
12:22:02 <WilliamHamilton[> lyxia: np, thanks for watching!
12:22:04 <MarcelineVQ> hololeap: I wasn't able to get that kind of key combo do actually do anything in the past :>
12:22:50 <hololeap> i usually mash it a few times for good measure... but the system always returns to usability after a minute or so
12:23:15 * hololeap hasn't had to do that since a RAM upgrade tho! \o/
12:25:17 <WilliamHamilton[> hololeap: TIL about Alt+SysRQ+F, I only knew REISUB! Thanks!
12:25:29 <hololeap> \o/
12:30:15 <MarcelineVQ> be sure to learn about the other SysRQ's if that one works for you
12:30:48 <MarcelineVQ> not all especially useful but good to know of
12:33:01 <__monty__> They disabled SysRQ on our campus after we got creative.
12:34:14 <hololeap> campuses love to stamp out creativity
12:37:15 <Lycurgus> more like they think they can stamp it out like an assembly line product
12:43:43 <WilliamHamilton[> hmm, the error I was having went away, I'm non capable of crashing ghci with that code now, hmm
12:45:59 <wroathe> Is there a way to trace GHC's instance resolution process? Right now I'm seeing some strange behavior using trace to track the flow through my instances
12:49:05 <wroathe> Is there a way to trace GHC's instance resolution process? Right now I'm seeing some strange behavior using trace to track the flow through my instances
12:49:08 <wroathe> https://gist.github.com/JustinChristensen/05aba1594cf966f444c4b70ba6a9a34d
12:49:33 <wroathe> I've got a product type with two fields, and it seems to short circuit before it goes down the right path
12:50:13 <geekosaur> I feel like if you need this, you're doing things that aren't guaranteed anyway
12:50:19 <wroathe> I expect it to print something else after "right" in the output (the left path prints lift, general, and K1)
12:50:34 <wroathe> geekosaur: I don't need this. Right now I'm just playing with generics
12:51:44 <lyxia> wroathe: no, there's an open GHC ticket for that somewhere.
12:52:47 <lyxia> https://ghc.haskell.org/trac/ghc/ticket/15044
12:53:20 <wroathe> lyxia: So how do you typically debug in this circumstance? trace calls like I'm doing?
12:57:35 <lyxia> that sounds like the state of the art indeed.
12:57:44 <wroathe> :/
12:57:48 <lyxia> you could also look at the dictionaries generated in Core.
12:59:41 <wroathe> lyxia: Do you know the compiler flag for that off hand?
13:00:39 <Solonarv> -ddump-deriv will output generated instances
13:01:29 <lyxia> -ddump-ds (ds=desugar)
13:01:52 <wroathe> In this case it's the instances I've defined for handling those generic types that I'm trying to debug
13:01:55 <wroathe> https://gist.github.com/JustinChristensen/05aba1594cf966f444c4b70ba6a9a34d#file-trace-hs-L36
13:02:19 <wroathe> on a product type with two fields this is only taking the left side path
13:02:29 <wroathe> It prints "right", but doesn't seem to go any further
13:02:46 <wroathe> The output is in that gist
13:03:17 <Iceland_jack> hi #haskell!
13:03:34 <lyxia> Iceland_jack: o/
13:03:42 <wroathe> thanks lyxia 
13:04:12 <Iceland_jack> \o lyxia 
13:04:22 <MarcelineVQ> I've become a big fan of -dverbose-core2core but you need a pretty compact example
13:07:04 * shapr hugs Iceland_jack 
13:08:12 <lyxia> wroathe: have you turned off optimizations? it looks like trace is getting floated out
13:08:23 <Iceland_jack> Hi shapr! Big fat hug back
13:09:00 <lyxia> (And indeed if I compile it without optimization I see the traces from both branches)
13:09:28 <wroathe> lyxia: I did try disabling optimizations, but I never know what cabal is doing behind the scenes
13:09:42 <wroathe> I'll compile again and check what's being passed to GHC
13:09:48 * shapr hops cheerfully
13:10:01 <shapr> I bought new shoes with kangaroo leather, gives me that extra spring in my step.
13:11:01 <Iceland_jack> My shoes are made of springs
13:11:49 <shapr> I'm jealous.
13:12:06 <wroathe> *facepalm*
13:12:32 <wroathe> I've got a makefile with a "run" and a "build" target mapped to cabal v2-run and cabal v2-build respectively
13:12:50 <wroathe> I wasn't paying attention to the fact that v2-run was rebuilding it with optimizations turned on
13:12:56 <wroathe> when I've got them disabled in the build target
13:15:27 <WilliamHamilton[> I'm encountering this behavior when haddock generates documentation for default signatures https://github.com/haskell/haddock/issues/567 on haddock version 2.22.0
13:15:40 <WilliamHamilton[> is there something I should do instead (I'm just using `cabal new-haddock`)
13:15:47 * hackage hlivy 1.0.0 - Client library for the Apache Livy REST API.  https://hackage.haskell.org/package/hlivy-1.0.0 (ddonohue)
13:16:25 <merijn> wroathe: v2-run only reuses build artifacts that have the same config, so if you v2-build with optimisations disabled (while normally on) it will ignore those
13:17:23 <merijn> WilliamHamilton[: The solution is "wait for a new haddock release with the next GHC or downgrade to an older GHC before haddock changed"
13:19:59 <WilliamHamilton[> merijn: sorry, I thought that there might have been a workaround; I'll wait for the next ghc :)
13:20:34 <merijn> WilliamHamilton[: Sadly, no. I tried building 8.8 myself and building haddock from source to get it working "right", because it annoys me too, but I didn't succeed
13:21:03 <merijn> wroathe: Incidentally, the "proper" way of providing local overrides like "disable optimisations" is via cabal.project.local
13:21:45 <WilliamHamilton[> merijn: good to know, thanks!
13:22:45 <wroathe> merijn: Thanks. I'll look into that.
13:24:36 <merijn> wroathe: v2-* uses "cabal.project + cabal.project.local" (where it prefers settings in cabal.project.local), the idea being that cabal.project is the "normal" config that's checked into version control and everyone uses and .local lets you provide overrides for local development
13:25:00 <merijn> (like enabling profiling, disabling optimisations, etc.)
13:26:17 <Cale_> Anyone happen to know whether the solver ever makes use of forall'ed type equality constraints? You can write them now with QuantifiedConstraints, but there's a question on reddit where they appear not to be getting applied at all, and thinking about it, the instantiation problem in general seems rather tricky.
13:29:50 <Cale_> (even just discovering the instantiations that would make relevant equality constraints seems expensive enough...)
13:30:48 <Cale_> (nevermind that you might need to do it arbitrarily many times in general)
14:06:17 * hackage net-mqtt 0.2.3.0 - An MQTT Protocol Implementation.  https://hackage.haskell.org/package/net-mqtt-0.2.3.0 (dustin)
14:07:44 <wroathe> So when talking about overlapping instances what causes an instance to be "more specific"?
14:08:49 <wroathe> Specifically, GHC considers these to be overlapping instances: https://gist.github.com/JustinChristensen/0054d0d460d6ae0d45c5af48c18ebd12#file-overlapping-hs-L47-L53
14:09:11 <wroathe> And says that the decision rests on the instantiation of b's shoulders
14:09:23 <merijn> wroathe: I already knew the problem before opening the link :D
14:09:38 <dminuoso> wroathe: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-OverlappingInstances
14:09:39 <merijn> wroathe: Superclass constraints are *not* taken into account when checking for instances
14:09:52 <dminuoso> wroathe: The algorithm described for instance algorithm is covered there.
14:10:13 <merijn> wroathe: So the instance on line 47 overlaps with the case of 'f = (K1 i b)'
14:10:19 <wroathe> I was thinking that because I've constrainted the second field of K1's type to be the same as b in the second instance it would be considered "more specific"
14:10:54 <merijn> wroathe: GHC only consider the right hand side of => to check if an instance exists
14:10:58 <dminuoso> wroathe: constraints are not considered for instance selection.
14:11:12 <merijn> wroathe: The left hand side (i.e. superclass constraint) is only checked when it tries to *resolve* the instance
14:11:54 <wroathe> Got it, so these really are considered equal in GHC's eyes
14:12:26 <phadej> GHC constraint resolution doesn't backtrack
14:12:43 <phadej> at each point it has to select single instance, it doesn't "try"
14:13:17 * hackage net-mqtt 0.2.3.1 - An MQTT Protocol Implementation.  https://hackage.haskell.org/package/net-mqtt-0.2.3.1 (dustin)
14:13:33 * dsal probably could've fixed two separate issues with one release, but doesn't pay attention
14:13:56 <merijn> dsal: More releases make you look busier!
14:14:28 <dminuoso> merijn: https://twitter.com/stepchowfun/status/738231117933776896
14:14:40 <dsal> In my defense, the second one was "oh, my links on hackage are wrong" which I didn't notice until the first one.  Of course, they've been wrong... but yeah.
14:14:44 <dsal> Man, that used to be me...
14:14:47 * hackage haddock-api 2.22.0 - A documentation-generation tool for Haskell libraries  https://hackage.haskell.org/package/haddock-api-2.22.0 (harpocrates)
14:15:07 <merijn> dsal: Man, I hate it when that happens
14:15:15 <dsal> Me a couple years ago:  https://twitter.com/dlsspy/status/842167388153896960
14:15:22 <merijn> dsal: That's why you upload candidate releases first, man!
14:15:30 <dsal> merijn: I need to learn what that means.
14:15:37 <wroathe> merijn: So do you have any recommendations for a solution here? How do I tell GHC that, yes, this field does have the same type as b?
14:16:08 <dminuoso> wroathe: Write specific instances for non-K1?
14:16:09 <merijn> wroathe: My recommendation would be to not write code like this, so that's not particularly helpful xD
14:16:37 <phadej> dsal: http://hackage.haskell.org/upload
14:16:41 <merijn> dsal: If you upload via cabal-install it defaults to candidate uploads, you need to explicitly upload with --publish to publish them
14:16:47 * hackage control-iso 0.1.0.2 - A typeclass for type isomorphisms  https://hackage.haskell.org/package/control-iso-0.1.0.2 (fresheyeball)
14:17:10 <merijn> dsal: candidate release is just "upload package + docs and be able to view them on Hackage without committing to a release" :p
14:17:17 <dsal> phadej, merijn: thanks.   I'll hopefully try this on my next attempt.
14:17:22 <merijn> dsal: aka it's just a preview :)
14:17:47 * hackage haddock 2.22.0 - A documentation-generation tool for Haskell libraries  https://hackage.haskell.org/package/haddock-2.22.0 (harpocrates)
14:17:53 <phadej> Also, the .1 change you made could been a revision
14:18:03 <phadej> https://github.com/haskell-infra/hackage-trustees/blob/master/revisions-information.md
14:18:11 <dsal> Oh interesting.
14:18:27 <dsal> Oh yeah, that's great.  I didn't actually change any code.
14:18:35 <takanuva> huh... I've a question, not sure how to explain it... is there a name for the "functor" of an ADT?
14:18:53 <merijn> takanuva: Eh...elaborate? :)
14:18:56 <phadej> dsal: it's all there in the upload page
14:19:00 <Solonarv> takanuva: what *is* the "functor" of an ADT? can you give an example?
14:19:10 <phadej> you just don't read any manual when you use `your-tool upload`
14:19:20 <dsal> phadej: Thanks.  Now that I've got a bit more experience with this stuff, I might try to understand it.
14:19:22 <takanuva> ADTs are the smallest fixpoint of a functor, right?
14:19:24 <merijn> phadej: Reading is for suckers :)
14:19:36 <phadej> merijn: I don't like your language
14:19:46 * dsal isn't a ReaderT
14:19:47 <merijn> takanuva: Yes, no, maybe, it depends on the ADT?
14:19:55 <lyxia> takanuva: I've seen it called "base functor" or "pattern functor"
14:20:01 <merijn> phadej: ?
14:20:07 <Solonarv> takanuva: sure, in the trivial way - Foo is isomorphic to Fix (Const Foo) ;)
14:20:23 <takanuva> data Foo = X | Y Foo Foo... technically we'd have Foo = forall X, 1 + X * X
14:20:27 <Solonarv> if you're talking about *recursive* ADTs then lyxia's terms are the ones I've seen
14:20:29 <dsal> stack upload doesn't seem to have many features.
14:20:47 <takanuva> I'd like to replace the occurrances of Foo inside itself
14:20:52 <phadej> merijn: I'm personally really conserned that discoverability of that page is close to zero, so any constructive ideas how to improve that are welcome; your comment weren't helpful.
14:21:13 <takanuva> e.g., data Foo = ..., I'd like to replace "Foo" there for "Foo + 1", something like that
14:21:18 <takanuva> to "extend" recursively a type
14:21:22 <takanuva> it's hard to explain :'(
14:21:38 <Solonarv> @hackage recursion-schemes -- takanuva
14:21:39 <lambdabot> http://hackage.haskell.org/package/recursion-schemes -- takanuva
14:21:43 <takanuva> basically I want an fmap as if Foo was defined as a fixpoint
14:22:09 <Solonarv> you can do that with the pckage I linked
14:22:15 <takanuva> lemme see
14:22:17 * hackage hpqtypes-extras 1.6.4.0 - Extra utilities for hpqtypes library  https://hackage.haskell.org/package/hpqtypes-extras-1.6.4.0 (MikhailGlushenkov)
14:22:18 <dsal> phadej: "I made a package and want to share it." shouldn't have a large barrier of reading about foreign concepts.  It might be better to push more of that into the tools.  e.g., perhaps 'stack upload' could just upload previews unless I tell it I want to actually release something.
14:22:26 <merijn> phadej: It was intended as a joke comment on the fact that no one ever reads docs for anything
14:22:56 <takanuva> giving a concrete example: I have an abstract tree type for a language, I'd like to add an extra constructor to it recursively for all possible nodes
14:23:12 <merijn> dsal: Stack...doesn't seem like a likely candidate for improved Hackage integration
14:23:15 <Solonarv> phadej: FWIW, I had no problem discovering it when uploading through the web interface
14:23:36 <Solonarv> takanuva: search for 'data types a la carte', that should turn up some related articles/papers
14:23:51 <phadej> dsal: I disagree. > Because each package added to the main package index has a cost of operation and maintenance associated to it, your package should strive to provide value for the community by being intended to be useful to others,
14:24:00 <phadej> first sentence of second paragraph
14:24:25 <phadej> and it's **important** to know that cost model of releasing package version on Hackage, is different then in other ecosystems one might be familiar with
14:24:38 <merijn> phadej: As for methods to improve discoverability. Low hanging fruit would be the fact that "cabal upload --help" doesn't mention that page at all
14:24:40 <Solonarv> a drastic solution would be to completely disable non-candidate package uploads
14:24:40 <phadej> so "throw anything over a wall" might be ok there, it's not for Hackage.
14:24:49 <dsal> Why is it important to me?
14:24:49 <phadej> merijn: good, thanks!
14:25:17 <merijn> dsal: Tragedy of the commons and all that
14:25:19 <Solonarv> so that anytime you wish to upload a package you *must* upload it as a candidate, and can turn it into a regular package after reviewing it
14:25:25 <dsal> I mean, I could tell people to just use it from github (as I have to do for some packages).  It's mildly inconvenient for me to use other people's packages who don't release them to hackage, but making it more of a burden doesn't seem to improve things.
14:25:43 <takanuva> oh, data types a la carte... I didn't remember of that paper! thanks!
14:25:59 <Solonarv> that'd make it impossible to upload packages without being aware of the "package candidate" feature
14:26:02 <dsal> I agree with what Solonarv's saying.  If preview is useful, I don't know why I'd ever not do it (other than my tool not offering it as a feature)
14:26:09 <merijn> dsal: Note that phadej didn't say there should be some hard maintenance commitment to upload with Hackage
14:26:37 <merijn> dsal: But that there should be at least SOME attempt to have reusable value
14:27:05 <merijn> I've seen some stuff uploaded that's just name squatting and stuff that doesn't even compile and hasn't been touched in years
14:27:24 <dsal> Yes, I think I'm doing that.  I released this new package today because someone asked for a feature... so someone other than me is using this at least.
14:27:31 <dsal> It would be nice to prune things that can't work.
14:27:57 <phadej> dsal: that's the bit which is different than in other ecosystems. Hackage is append-only.
14:28:37 <dsal> Sure, but append-only can still have logical deletions.
14:28:53 <merijn> phadej: Incidentally, do you know if there's already a ticket/issue for candidate publishing to delete the candidate?
14:29:00 <merijn> dsal: That doesn't reduce cost, though
14:29:10 <dsal> I guess I don't understand what "cost" is here.
14:29:10 <merijn> dsal: In fact, adding logical deletions just makes it *more* costly
14:29:23 <dsal> As a user, it's costly to have to dig through a lot of package noise.
14:29:24 <merijn> dsal: The fact that the index grows and everyone has to download that
14:29:34 <dsal> Oh, I see.
14:30:17 <phadej> % ls -lh ~/.cabal/packages/hackage.haskell.org/01-index.tar
14:30:17 <phadej> -rw-r--r-- 1 ogre ogre 546M helmi  5 00:14 /home/ogre/.cabal/packages/hackage.haskell.org/01-index.tar
14:30:17 <yahb> phadej: ; <interactive>:181:1: error: Variable not in scope: ls :: Integer; <interactive>:181:5: error: Variable not in scope: lh :: Integer; <interactive>:181:8: error: Variable not in scope: (~/.) :: Integer -> (a0 -> a1 -> Int) -> t; <interactive>:181:11: error: Variable not in scope: cabal :: a0 -> a1 -> Int; <interactive>:181:17: error: Variable not in scope: packages :: a0 -> a1 -> Int; <interactive>
14:30:24 <merijn> dsal: 1 version times all machines to ever run Cabal is a considerable storage cost aggregated over the world ;)
14:30:28 <phadej> yahb: thanks :)
14:30:36 <dsal> merijn: I've seen bigger blockchains. :P
14:31:03 <merijn> dsal: Sure, it's not hugely problematic, but you wanna avoid it becoming so in the future...
14:31:10 <dsal> Agreed
14:31:17 <Solonarv> phadej: if you start your message with %! yahb will actually run it in a sh variant (I don't recall which)
14:31:25 <phadej> Solonarv: :)
14:31:47 <phadej> %! ls -h ~/.cabal/packages/hackage.haskell.org/01-index.tar
14:31:48 <yahb> phadej: ls: cannot access /var/lib/xsbot/sandbox/root/data//.cabal/packages/hackage.haskell.org/01-index.tar: No such file or directory
14:31:54 <phadej> :(
14:32:15 <mniip> what cha trying to do
14:32:44 <phadej> dsal: so my rule of thumb is "prepare the release, but upload it tomorrow"
14:34:50 <merijn> phadej: Also, maybe upload should output a reminder to "check this link about publishing on Hackage before using --publish"?
14:35:25 <merijn> Since candidates are already the default
14:35:31 <phadej> merijn: not in stack
14:36:03 <phadej> I also have seen travis scripts which upload on tagged commit
14:36:14 <phadej> you cannot solve that client side
14:36:20 <merijn> phadej: Sure, but stack doing stupid things is a trickier problem than I have useful suggestions for :)
14:36:22 <phadej> and you cannot make it too difficult to automate either
14:36:42 <phadej> (because uploading from travis script may be valid thing to do, sometiems)
14:37:12 <merijn> You asked for discoverability suggestions, which is the best I can do without the political minefield that is stack-hackage interaction :p
14:37:40 <phadej> merijn: that cabal upload --help is great suggesting
14:37:46 <dsal> phadej: man, I don't have that kind of patience.   I burn my mouth on the release while my hands are still burning from pulling it out of the oven.
14:39:17 * hackage language-python 0.5.6 - Parsing and pretty printing of Python code.  https://hackage.haskell.org/package/language-python-0.5.6 (BerniePope)
14:39:58 <day> console.log([ 2, 4, 6 ].map(x => x + 3)) this page im reading uses this example to demonstrate that arrays are functors. but wouldnt the map be the functor here and the array ?list? merely be the category?
14:41:47 <zachk> day: is that javascript?
14:41:48 <phadej> dsal: I like (unbaked/raw) cheesecakes; you need to wait until they set
14:41:57 <day> wait i hope not
14:42:10 <phadej> it is
14:42:17 <jackdk> the first thing to ask is what are the source and target categories? AIUI, we say [] is a functor because it takes objects in Hask (the cat. of haskell types) to objects in Hask (Int goes to [Int])
14:42:23 <day> that would explain why i just watched a javascript video :P
14:42:32 <Solonarv> day: "Array" is a functor. Neither "[2, 4, 6]" nor "map" are functors.
14:42:34 <dsal> phadej: Yeah, when I make vegan cheesecake, it's not even ready until I don't want it anymore.
14:42:53 <day> yeah i was a bit confused why he was writing array and not list
14:42:53 <Solonarv> (though sometmes we may colloquially call [2, 4, 6] a functor anyway, that isn't strictly correct)
14:43:02 <phadej> dsal: oh dear, than I cannot help you :(
14:43:26 <jackdk> fmap describes the way arrows (i.e. functions from a -> b) are mapped into the destination category (f a -> f b)
14:43:36 <day> but wiki says a functor is a map between two categories, isnt that exactly what map does?
14:43:50 <phadej> dsal: we should have "upload with undo" (like gmail has undo send)
14:44:21 <dsal> phadej: ha.  I'd be fine with upload not publishing.  It'd be great to look at it before it's ready.
14:44:33 <phadej> dsal: that's what candidates are
14:44:39 <phadej> (except they don't build docs)
14:44:52 <dsal> Yes.  I'm missing that feature currently, AFAICT.
14:45:07 <jackdk> note you can build docs and upload them to a candidate
14:45:31 <Solonarv> day: in Haskell, we usually talk about *endo*functors: functors where the source and target categories are the same
14:45:48 <Solonarv> specifically, endofunctors in Hask: the category of types
14:45:49 <dsal> https://github.com/haskell/hackage-server/issues/481
14:46:21 <Solonarv> objects in Hask are types, and arrows are functions
14:48:09 <Solonarv> in other languages, the correspondence is muddied, but still basically the same.
14:48:44 <phadej> one should remember that "programming language" is an example of category-theoretical concepts
14:49:25 <phadej> and if you want to learn CT "properly", you should look into other examples
14:52:21 <wroathe> merijn: Even then you've urged me not to do so, I've created frankenstein's monster. It lives! https://gist.github.com/JustinChristensen/81750c9f355a5193be78a989e16ff933
14:53:05 <jcob> Hey I have a lil question for FRPs. How hard is it to write the simplest frp system, and can anyone give me an example?
14:53:09 <wroathe> merijn: Now I'm going to publish this to hackage and open pull requests to introduce it to all of the major tools in the ecosystem. The blight will spread.
14:53:24 <merijn> wroathe: pfft, I write template C++ code, it takes more than that to scare me 
14:53:47 <wroathe> Solonarv: Ended up going the Typeable route. Couldn't figure out the multi-param typeclass thing.
14:53:52 <merijn> jcob: Depends, do you care whether it's efficient? :p
14:54:03 <jcob> not really, just want to get the very basics
14:54:23 <phadej> CT is very abstract, until one is comfortable with abstract stuff, it's tuff
14:54:31 <merijn> jcob: Then probably not too hard :p
14:54:42 <merijn> jcob: Have you seen Conal's papers on FRP?
14:55:17 <jcob> which one is a good place to start
14:55:52 <phadej> http://conal.net/papers/frp.html the '97 one
14:55:54 <argent0> hi, what is `_Just . (foo :: Lens' s a)` ?
14:55:59 <merijn> The Fran paper was the first (http://conal.net/papers/icfp97/) and Push-pull is good for more on making things more efficient (http://conal.net/papers/push-pull-frp/)
14:56:14 <dminuoso> argent0: A traversal.
14:57:13 <phadej> an affine one (if one wants to be precise, but `lens` cannot express that properly)
14:57:49 <MarcelineVQ> jcob: conal is also on here reasonably often and is very approachable if you find you have questions
14:58:30 <jcob> MarcelineVQ: thanks ^^
14:58:57 <Solonarv> hmm, could lens express affine traversals? or would that require currently-nonexistent type system extensions?
14:59:10 <argent0> dminuoso, phadej : thanks, I'll check those out (It is a Traversal' (Maybe s) (Matbe a))
14:59:17 * hackage PyF 0.7.0.0 - Quasiquotations for a python like interpolated string formater  https://hackage.haskell.org/package/PyF-0.7.0.0 (guibou)
14:59:23 <geekosaur> no extensions needed, but typeclass rearrangements
14:59:49 <phadej> argent0: Traversal' (Maybe s) a
15:00:10 <dminuoso> geekosaur: I think you need to rely on Pointed to do it right?
15:00:15 <argent0> phadej: right (^^)
15:01:03 <geekosaur> yeh
15:01:14 <Solonarv> Pointed being involved makes sense, I guess
15:01:20 <geekosaur> there's various things in lens that are done "wrong" because we don't have Pointed or Apply
15:01:34 <phadej> there's Apply in `lens`
15:01:54 <phadej> but it's not part of hierarchy, so it makes some things not smooth
15:01:58 <geekosaur> yes
15:02:36 <geekosaur> and retrofitting them would have a fairly high typechecking cost for everyone
15:06:55 <phadej> Apply isn't as cool as Applicative to go through AMP-like change
15:07:23 <qz> if i have a function that takes [a] as an argument, can i have special implementation for a case if a is a Maybe value?
15:07:30 <dminuoso> I think Kmett pointed out that the full lattice would require one to implement 6 typeclasses for the standard lattice (Functor, Pointed, Apply, Applicative, Bind, Monad)
15:07:40 <dminuoso> qz: No.
15:07:51 <dminuoso> qz: And this is a good thing.
15:08:07 <phadej> dsal: Applicative and Monad are empty
15:08:10 <Solonarv> surely Applicative and Monad could just be synonyms at that point?
15:08:13 <phadej> sorry dminuoso 
15:08:21 <phadej> Solonarv: no they cannot, they include laws
15:08:23 <qz> sad :( any clues how o design around such limitation?
15:08:23 <dminuoso> phadej: No they are not because they carry additional laws.
15:08:34 <Solonarv> oh right, and the laws aren't free
15:08:43 <Solonarv> qz: what is your function supposed to do?
15:08:56 <dminuoso> qz: Maybe describe your problem first. :)
15:09:21 <qz> Solonarv: serialize a list basically, and if values of list are Maybe's i need to do some extra work
15:09:22 <merijn> qz: You can trivially convert the Maybe to a list
15:09:26 <geekosaur> qz: type-case is not a thing. if your function claims to work on an unspecified 'a, that is all you can know about it
15:09:44 <merijn> qz: What sort of extra work?
15:10:04 <dminuoso> qz: Write a separate function that works on `[Maybe a]` then.
15:10:08 <phadej> Solonarv: concrete example, if you write code like pure (+) <*> pure a <*> pure b -- the (Pointed f, Apply f) would be inferred, but you probably want Applicative
15:10:26 <Solonarv> yeah fair point
15:11:17 * hackage compactable 0.1.2.3 - A typeclass for structures which can be catMaybed, filtered, and partitioned.  https://hackage.haskell.org/package/compactable-0.1.2.3 (fresheyeball)
15:11:31 <qz> basically function is :: (a -> ByteString) -> [a] -> ByteString   but if a is Maybe t i need to prepend something to resulting ByteString
15:12:18 <dminuoso> qz: Call a different function then.
15:12:21 <phadej> how it should work with a = Maybe (Maybe b) 
15:12:53 <merijn> qz: So, write a "transformer" function "(a -> ByteString) -> Maybe a -> ByteString" and partially apply that when calling your function?
15:13:48 <phadej> or even better, a = Option b (Option is Maybe)
15:13:49 <qz> merijn: i need to do that extra work only once, i.e. prepend a Word32 to resulting bytestring (that is result of serialization of a list)
15:14:19 <phadej> there's no such thing as type-case, you simply lie to yourself
15:14:48 <dminuoso> phadej: Sadly, if one is used to languages like C++ then it may feel very natural to do this.
15:15:00 <merijn> qz: So, then write a transformer for the overall function?
15:15:04 <qz> yeah, i'm coming from c/c++
15:15:12 <phadej> dminuoso: there aren't type-case either
15:15:18 <dminuoso> phadej: There are with template specializations.
15:15:23 <merijn> phadej: Sadly there is :)
15:15:29 <dminuoso> phadej: It's one of the worst parts of C++.
15:15:43 <merijn> dminuoso: What? You don't like std::enable_if? :p
15:15:43 <qz> merijn: transformer like what? 
15:15:44 <phadej> well, you can define instance MyClass (Maybe a) anbd instance {-# OVERLAPPABLE #-} MyClass a 
15:16:04 <phadej> that's pretty close to template specialisations
15:16:31 <merijn> qz: Well, if you have "(a -> ByteString) -> [a] -> ByteString" then presumably you want no output for the Nothing's, yes?
15:16:31 <dminuoso> qz: If you are new to Haskell you should probably just use a transformer/separate functions and manually pick them.
15:17:24 <phadej> C++ works as you don't have RankNTypes there :)
15:17:54 <qz> dminuoso: so 2nd function will be like (a -> ByteString) -> [Maybe a] -> ByteString ?
15:17:56 <phadej> (or maybe you do nowadays, but I don't want to know the syntax)
15:18:00 <merijn> So you have "yourFun :: (a -> ByteString) -> [a] -> ByteString" and "yourMaybeFun :: (a -> ByteString) -> [Maybe a] -> ByteString; yourMaybeFun f l = myPrefix <> yourFun f (catMaybes l)"
15:18:01 <dminuoso> phadej: C++ has higher kinded types... 
15:18:05 <dminuoso> phadej: there's template templates...
15:18:12 <merijn> dminuoso: Kinda, maybe, sorta, but not really
15:18:18 <dminuoso> merijn: No it really does.
15:18:36 <dminuoso> qz: That's what I would do yes.
15:18:47 <qz> i see, thanks
15:18:51 <merijn> dminuoso: Trust me, I know the limits of C++ templates: https://github.com/merijn/GPU-benchmarks/blob/master/TemplateConfig.hpp#L286-L297
15:19:17 <dminuoso> variadic template templates.
15:19:19 <dminuoso> Not bad.
15:19:34 <merijn> It's templates all the way down, man!
15:19:47 * hackage set-of 0.1.0.2 - Sets of fixed size, with typelits  https://hackage.haskell.org/package/set-of-0.1.0.2 (fresheyeball)
15:20:20 <merijn> This shit woulda been so simple, nice, and clean in Haskell :\
15:20:30 <dminuoso> merijn: Did I ever tell you about non-constant constexpr?
15:20:32 <merijn> Learn from my mistakes, boys & girls >.>
15:20:40 <merijn> dminuoso: No?
15:20:46 <dminuoso> merijn: You should love this then.
15:20:49 <dminuoso> merijn: http://b.atch.se/posts/non-constant-constant-expressions/
15:20:59 <dminuoso> merijn: This is a design quirk, not an implementation bug!
15:21:08 <Welkin> it's a quark?
15:21:12 <Welkin> does it quack?
15:21:50 <merijn> dminuoso: https://www.youtube.com/watch?v=-Lez_WdX7Oc
15:22:13 <comstar> haskell became a lot easier to learn once I realized there wasn't anything super cool or wildly different about applicative/monads/functors/etc
15:22:20 <Welkin> merijn: is that a link to Outkast's So Fresh and Clean?
15:22:30 <comstar> like the way people outside of its ecosystem esteem it I'd have thought it was fucking wizardry
15:22:54 <dminuoso> comstar: For what its worth, there are libraries full of wizardry.
15:23:34 <merijn> Welkin: No :p
15:25:08 <wroathe> comstar: I think when teaching beginners (myself included) it should be standard practice to avoid mentioning IO and Monad in the same sentence, because the whole unsafePeformIO thing muddies the waters of understanding
15:25:13 <wroathe> At least it did for me
15:25:31 <dminuoso> wroathe: No, unsafePerformIO is something you dont need to talk about.
15:25:35 <dminuoso> You can safely pretend it doesn't exist.
15:25:44 <comstar> what muddied the water for me was being around people who had been coding for 20 years acting like monads were the hardest thing on the planet
15:25:59 <dminuoso> In fact it's best you pretend it doesn't exist for the purpose of teaching or learning Haskell.
15:26:22 <hpc> in fact, it doesn't exist
15:26:32 <Welkin> what is existence?
15:26:32 <comstar> haskell doesn't exist
15:26:38 <comstar> anyone who tells you it does has been payed to do so
15:26:40 <Iceland_jack> This is news to me
15:26:46 <hpc> ceci ne'est pas une haskell
15:26:48 <comstar> Iceland_jack: how much are they paying you
15:27:03 <Iceland_jack> Too much
15:27:07 <Iceland_jack> :]
15:27:12 <Welkin> hi Iceland_jack 
15:27:16 <Iceland_jack> hi Welkin 
15:27:58 <Welkin> how many hours of sinlight do you get right now in iceland?
15:28:01 * shapr hops cheerfully
15:28:03 <Welkin> sunlight*
15:28:05 <dminuoso> So it occured to me that Iceland_jack might be from Iceland. I will not reveal my sources.
15:28:31 <merijn> My sources tell me that if there was an SPCA for Haskell compilers, Iceland_jack would be in jail.
15:28:54 <MarcelineVQ> dminuoso is from the dominion, it's a secret to everybody
15:28:58 <Iceland_jack> xO
15:29:07 <comstar> my sources once told me that if they had a choice between smashing their ship on the rocks, or having to encounter Iceland_jack's handywork, they'd choose the rocks
15:29:12 <wroathe> I guess what I'm saying is that I, somewhat foolishly, kept trying to imagine what the implementation for >>= might look like for IO. It's fairly trivial to write out >>= for Maybe and Either, and demonstrate why having a consistent interface for a thing that acts like a monad is useful
15:29:17 <Welkin> "FREE Spay/Neuter Day! The SPCA of Texas and Spay Neuter Network will offer FREE spay or neuter surgery for DOGS"
15:29:24 <Welkin> are you saying he is a dog?
15:29:29 * shapr tries to install haskell-ide-engine
15:29:37 <wroathe> But as soon as you also conflate that idea with magical IO happenings in an otherwise pure language, it gets tricky
15:30:32 <merijn> wroathe: Until you dig into the papers on the implementation details of IO in GHC, then it becomes simple again, but that teaches all sorts of bad assumptions about IO you don't wanna teach ;)
15:30:43 <Iceland_jack> comstar: this goes into my bragging file :)
15:30:47 * hackage hpqtypes-extras 1.7.1.0 - Extra utilities for hpqtypes library  https://hackage.haskell.org/package/hpqtypes-extras-1.7.1.0 (MikhailGlushenkov)
15:30:56 <merijn> wroathe: FYI, Haskell is pure *because* of IO, not despite ;)
15:31:01 <hpc> trick question, Iceland_jack's handywork is the rocks
15:31:11 <comstar> merijn: I thought it was pure because of do notation
15:31:13 <merijn> wroathe: That's the entire point of having IO :)
15:31:36 <merijn> comstar: do notation is literally redundant syntactic sugar that doesn't meaningfully affect the language or purity
15:31:37 <wroathe> merijn: Agreed. I'm just saying the learning path to that understanding is rocky.
15:31:49 <merijn> comstar: (aside from an ergonomics perspective)
15:31:54 <merijn> wroathe: Agreed
15:32:01 <ne> :)
15:32:02 <Welkin> is IO no longer implemented using ST?
15:32:09 <hpc> it never was
15:32:19 <merijn> Welkin: IO and ST are both specialisation of the underlying primitive monad
15:32:20 <Amras> I had a lecturer who tried to explain it as "IO needs to preserve ordering, so think of >> and >>= as preserving some incremented integer"
15:32:22 <Welkin> that's how I understood it from the paper
15:32:27 <merijn> wroathe: You'll approve of: https://blog.jle.im/entry/io-monad-considered-harmful.html
15:32:36 <dminuoso> Welkin: IO is just a type level trick to a) sequence evaluation and b) avoid evaluation by hand.
15:32:43 <merijn> Welkin: There's an ST# which specialises to both ST and IO
15:33:11 <merijn> Welkin: Actually, I think technically it's State#, whatever, names are for suckers
15:33:45 <merijn> Welkin: Which is why "stToIO :: ST s a -> IO a" can exist
15:34:17 <Solonarv> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
15:34:17 <Solonarv> newtype ST s a = ST (State# s -> (# State# s, a #))
15:34:17 <Solonarv> clearly very similar!
15:34:36 <hpc> wroathe: AVERT YOUR GAZE!
15:34:47 <aplainzetakind> I have a `foo :: a -> State s b`, I want to obtain `[a] -> State s b`, but I want the state change to happen only once. i.e. from (\x -> State (\s -> (f x, g s)) to get to (\xs -> State (\s -> (f <$> xs, g s)). This probably can't be accomplished with a general abstraction, since g could also depend on x, but I figured I'd ask anyway.
15:34:47 <wroathe> hpc: I've already seen these ;D
15:34:48 <Iceland_jack> deriving .. via (ST RealWorld) :)
15:34:55 <dminuoso> Solonarv: So why is `IO` not implemented in terms of ST?
15:35:18 <Solonarv> dminuoso: they're both implemented in terms of the same underlying mechanism
15:35:24 <wroathe> hpc: The RealWorld -> RealWorld thing actually was helpful to the abstract understanding of what they were trying to model
15:35:25 <aplainzetakind> s/[a] -> State s b/[a] -> State s [b]/
15:35:36 <merijn> wroathe: It's not really, though
15:35:38 <dminuoso> wroathe: It's actually a really bad model.
15:35:48 <Welkin> aplainzetakind: what is that noise?
15:35:52 <hpc> the point of IO being abstract is it has no model... to some extent
15:35:52 <merijn> wroathe: It *seems* helpful, until you start thinking: Wait...how does forkIO work?!
15:36:22 <dminuoso> Until you stop thinking about IO as a state thing. Then `forkIO` becomes just an IO transformer.
15:36:49 <Solonarv> it's helpful in that it shuts up the part of your brain that goes "but you can't understand IO without knowing how it's implemented under the hood! 
15:36:51 <wroathe> merijn: My first naive shot at answering that would be that the world is in one state, and then you call a function that creates a new thread doing some IO magic, and now the world is in a new state.
15:37:11 <dminuoso> wroathe: except in reality it's just an unlifted unit you cant easily produce.
15:37:18 <merijn> wroathe: The problem is that the forked thread and the original thread can both manipulate state visible to eachother :)
15:37:27 <dminuoso> so you end up with something akin to `data IO a = IO () -> ((), a))`
15:37:30 <Solonarv> the dirty secret is that at runtime, there is no such thing as IO and everything is essentially unsafePerformIO'd
15:37:58 <Welkin> I don't care how IO is implemented, since I only need to know the characteristics of using it and the guarantees the type system gives
15:38:01 <Welkin> of course
15:38:03 <Welkin> that is no secret
15:38:08 <Welkin> everything ism achine code eventually
15:38:49 <dminuoso> :t unsafePerformIO
15:38:50 <lambdabot> error: Variable not in scope: unsafePerformIO
15:39:46 <Solonarv> % :t unsafePerformIO
15:39:46 <yahb> Solonarv: IO a -> a
15:40:16 <wroathe> merijn: So then you'd have to state that RealWorld is actually a global synchronized mutable variable, and all of the threads need a consistent view of it
15:40:27 <dminuoso> ^- in the end GHC ties IO effects into the evaluation. The IO type prevents that from happening.
15:40:37 <merijn> wroathe: It which point the "RealWorld -> RealWrold" analogy is basically dead ;)
15:41:16 <Solonarv> yeah, the RealWorld -> RealWorld analogy breaks down once you bring in parallelism
15:41:28 <reygoch> Hey, I remember reading about a tool that can manage GHC versions recently, does anyone know what's it's called?
15:41:38 <phadej> Solonarv: concurrency
15:41:49 <dminuoso> Solonarv: It breaks furthermore on the basis that your program interacts with the external world.
15:41:55 <merijn> reygoch: ghcup? Although, tbh, on *nix I just do so "manually"
15:42:08 <Solonarv> ghcup *only* works on *nix :P
15:42:13 <reygoch> merijn:Yes, that's it
15:42:16 <wroathe> merijn: I'll read JLE's post on the matter a little later. Thanks for the link.
15:42:24 <merijn> Solonarv: Conclusion, I don't use ghcup ;)
15:42:24 <Solonarv> (notably, it doesn't work on windows)
15:42:26 <reygoch> merijn: unfortunatelly I'm on windows :)
15:42:37 <merijn> reygoch: Then you're apparently boned anyway ;)
15:42:46 <Solonarv> reygoch: you can use stack to install cabal/ghc
15:43:13 <Solonarv> 'stack setup --install-ghc --resolver ghc-X.Y.Z'
15:43:15 <reygoch> Solonarv: I'm exploring cabal only lifestyle ;)
15:43:39 <Solonarv> hmm, I was recently reminded that chocolatey exists
15:44:02 <Solonarv> I used it to install ghc+cabal after I had to reset my laptop recently
15:44:04 <Welkin> how useful is it to track IO in the type system? I think that is the weakest value proposition of haskell compared to the rest of the benefits of the language. Even the C ffi is a lie. For example, compared to rust. Only one language gets the purity correct: Elm.
15:45:04 <Solonarv> it doesn't do any of the "managing ghc versions" thing though, AFAIK
15:45:08 <dminuoso> Welkin: How is ffi a lie?
15:45:30 <Welkin> dminuoso: every call may as well be unsafePerformIO
15:45:36 <hpc> because you can lie about the type of something, if you really want to
15:45:51 <hpc> it might as well be unsafeCoerce ;)
15:45:55 <Welkin> and the called code can crash your program
15:46:02 <dminuoso> hpc: Sure, but there's enough backdoors in Haskell - so it's not just an ffi issue.
15:46:14 <hpc> yeah
15:46:16 <Solonarv> that sounds a bit like calling Haskell's type system useless because unsafeCoerce exists, or calling Rust's safety features useless because unsafe blocks exist
15:46:31 <hpc> personally, IO in the type system is the most valuable part of haskell
15:46:45 <hpc> because it means that value of type (IO ()) is... a value
15:46:46 <merijn> hpc: One of the, yes
15:46:47 <Welkin> I think the idea that referential transparency is a major benefit of haskell is odd, because it really doesn't have it
15:46:57 <hpc> nobody would ever write forkIO in java
15:46:57 <reygoch> hpc: to me it's the syntax
15:47:09 <Welkin> the type system? or the runtime?
15:47:12 <Welkin> the runtime is great
15:47:22 <Welkin> the syntax is great, the type system in general is great
15:47:38 <dminuoso> Welkin: If you start using unsafe primitives things can break, yes. And if you dont maintain referential transparency that's bad, but it's far outside the norm in Haskell.
15:47:44 <Welkin> I don't see what IO brings to the table compared to the other benefits
15:47:47 <hpc> i once wrote a library that short-circuited computation based on pre-existing intermediate stages
15:47:53 <merijn> dminuoso: That's his problem with it :p
15:47:57 <hpc> by statefully building up an IO computation from both the beginning and end
15:48:02 <reygoch> I was looking at idris recently and now I'm jelly about their type level function syntax
15:48:04 <dminuoso> Welkin: But in the end even Elm is not perfect. Strictly speaking any computation is side-effect ridden. 
15:48:11 <reygoch> and type level syntax in general
15:48:21 <Welkin> dminuoso: what do you mean?
15:48:53 <dminuoso> Welkin: Computers are not mathematical constructs. Your program consumes CPU time. It consumes memory.
15:48:54 <Welkin> elm has strict separation of effectful code from non-effectful code
15:49:07 <Welkin> dminuoso: that is a strawman
15:49:12 <dminuoso> Welkin: If I wire a missile launcher into `htop`, then I can launch missiles with your elm program.
15:49:18 <Welkin> of course everything ends up being bits flipped in a computer
15:49:33 <Welkin> this is nonsense
15:49:55 <hpc> merijn: my current second-favorite language is puppet, which has the same sort of notion but slightly different
15:50:00 <hpc> IO isn't first-class, but still separated
15:50:17 <hpc> the pure phase of a puppet program runs on one computer, and the effectful phase runs on a different computer
15:50:20 <dminuoso> hpc: puppet as in PE?
15:50:21 <Welkin> Io is a moon of jupiter
15:50:36 <Solonarv> reygoch: richard eisenberg is working on bringing some of that awesomeness to haskell
15:50:43 <hpc> dminuoso: yeah, but i don't know much about PE
15:50:50 <hpc> just the open-source version
15:51:18 <dminuoso> hpc: Sadly we drifted completely into Ansible because.. well reasons.
15:51:22 <hpc> ouch
15:51:55 <Welkin> why does everyone always want to talk about monads and IO in haskell when those are not even the big ideas?
15:51:58 <dminuoso> I maintain that manually fiddling in your infrastructure is less error prone and easier than all the mess my coworkers have with Ansible.
15:52:15 <reygoch> I know he's working on dependent types, but while idris has same sintax for type level functions and value level functions, haskell has type families :(
15:52:17 * hackage debug-tracy 0.1.0.3 - More useful trace functions for investigating bugs  https://hackage.haskell.org/package/debug-tracy-0.1.0.3 (fresheyeball)
15:52:26 <hpc> dminuoso: that's just because it's ansible though, and thus guaranteed to be messy
15:52:27 <reygoch> Solonarv: which looks kinda ugly
15:52:27 <Welkin> by everyone, I mean beginners
15:52:46 <Solonarv> reygoch: do you mean the 'ticks everywhere? yeah, those are a bit unfortunate
15:53:08 <Welkin> Solonarv: now that you mention it. they remind me of ocaml's ugly syntax
15:53:25 <Solonarv> it shouldn't be too much of an issue if it becomes possible to omit them in cases where it isn't ambiguous what's being referred to
15:53:26 <hpc> puppet is meant to make you think "what do i want a server to be" rather than running specific playbooks to do stateful operations
15:53:34 <hpc> and runs on a regular schedule
15:53:38 <Solonarv> (this is already how promoted constructors work with DataKinds, after all)
15:53:40 <reygoch> Solonarv: no, I mean that type families are just type level functions but they don't have the same syntax as regular functions.
15:53:42 <wroathe> Welkin: My first thought on that is that Haskell seems like the product of mountains of research, and people trying to teach beginners are proud to show off that research.
15:53:47 <hpc> a good puppet module can get your machine back into that state from almost any initial state
15:53:55 <hpc> just by being declarative
15:53:57 <Solonarv> reygoch: type families aren't *quite* type-level functions, in a variety of ways
15:54:01 <reygoch> sure
15:54:09 <wroathe> Welkin: Regardless of whether or not the beginner has need of that knowledge
15:54:16 <dminuoso> hpc: I know, but when you have a wealth of ansible folks and no puppet folks around.. and work in networking where the vast majority of vendors have good ansible support but not-so-good puppet/chef/salt support...
15:54:17 <reygoch> but in idris the syntax is quite similar and convenient
15:54:28 <hpc> ah, that'll do it
15:54:39 <Solonarv> with dependent haskell it'll be possible to use plain old value-level functions at the type level, though you might need a 'tick to disambiguate
15:55:06 <hpc> i don't know much about networking, but so far what i have learned is that it's total chaos unless you have a LOT of organizational skill
15:55:32 <hpc> even at the level of actual protocols themselves, there's enough mixing to make things complicated
15:55:35 <Welkin> hpc: people management?
15:55:52 <hpc> like dhcp decides your machine's ip address by sending... a tcp packet
15:56:08 <hpc> with a totally fabricated ip address and other flags, that everyone just agrees on being "dhcp"
15:56:27 <hpc> Welkin: organizing systems
15:56:39 <Welkin> something I learned recently is that runing on a VPS is not the same as bare metal. You can have noisy neighbors that cause heisenbugs in your software
15:56:41 <hpc> couldn't think of the right word, it's not quite abstraction
15:57:17 <dminuoso> hpc: networks are extremely stateful beasts that are constantly changing.
15:57:28 <Welkin> the network is unreliable
15:57:29 <MarcelineVQ> Solonarv: is that so? pretty neat. Might even be more convenient than idris since applying functions at the type level there requires proof of totality, so the type checker knows it'll eventually typecheck. haskell isn't going to be fussed about totality afaik :X
15:57:38 <hpc> dminuoso: i am working on a pf frontend in haskell at the moment, funny enough
15:57:59 <Solonarv> example dependent-haskell type signature: safeIx :: forall a. foreach (xs :: [a]) -> foreach (n :: Int) -> forall (prf :: (n >= 0, n < length xs)). a
15:58:04 <MarcelineVQ> convenience here being the version of the word that means nicer but with less guarantees
15:58:04 <hpc> i can't fix networking protocols themselves, but maybe i can present it in a way that's not miserable
15:58:25 <Solonarv> MarcelineVQ: that's explicitly called out as a difference between dependent haskell and other dependently-typed languages in eisenberg's thesis, in fact!
15:58:35 <MarcelineVQ> Yes I recall seeing that
15:58:52 <hpc> like not having to have 3 tabs open in order to configure one firewall allow (one for creating an address object, one for adding the rule, maybe another for copying from)
15:58:58 <dminuoso> hpc: Single machines is relatively simple. It gets mindboggingly hard when you need to orchestrate BGP, OSPF, MPLS, your overlay using EVPN with VXLAN.
15:59:03 <hpc> but wait, your frontend can't even run in multiple tabs
15:59:05 <dminuoso> Across hundreds of devices.
16:00:01 <dminuoso> hpc: Our solution is to limit ourselves to the most simplistic networking tools and solve networking problems within the limited featureset. That lets us automate everything without going crazy. Any performance problems are killed by throwing 100G ontop of 100G transceivers.
16:00:02 <hpc> i know some of those acronyms
16:00:18 <Welkin> they are meaningless to me
16:00:25 <Solonarv> more compact, unicode-y variant of that signature: ∀a. ∏(xs :: [a]) (n :: Int) -> ∀(prf :: (n >= 0, n < length xs)). a
16:00:46 <Solonarv> a list-indexing function that doesn't return a Maybe and yet remains total!
16:01:15 <Solonarv> I think this can be written in today's Haskell using singletons, but it's pretty ugly.
16:01:49 <hpc> dminuoso: you'd like https://github.com/headprogrammingczar/tubular/blob/master/Vagrantfile btw - automated build box, test box, and two linux hosts
16:02:10 <Welkin> hpc: what about kubernetes?
16:02:12 <hpc> all networked together in as close i could get to a couple of ethernet cables
16:02:15 <hpc> lol
16:02:30 <hpc> i want this on my laptop, not a $700 million cluster
16:02:49 <hpc> also docker doesn't bsd
16:03:18 <Welkin> that reminds me of a presentation on erlang/beam where a company had to settle for linux because they couldn't run bsd for osme reason
16:03:25 <Welkin> oh I remember
16:03:28 <Welkin> it is WhatsApp
16:03:34 <dminuoso> hpc: Heh. Virtualizing networks is a pain. GNS3 requires *so* *much* *ram*..
16:03:43 <Welkin> since facebook bought them they had to move to linux boxes from bsd
16:03:58 <hpc> dminuoso: oh man, this was awful to set up
16:04:05 <dminuoso> I think we tossed like 64GiB at our initial setup and it wasn't enough to run like half a dozen network devices...
16:04:19 <hpc> the makefiles for the ports-style build process is even worse
16:04:21 <hpc> i have 3 of them
16:04:53 <hpc> one to control VMs, one to define the package, and the third just calls /bin/true a couple of times
16:05:08 <hpc> because i couldn't get bsd to stop mucking with stack's CC
16:06:28 <hpc> at some point in this project i am going to have to write a packet simulator, and that'll be hella fun
16:07:25 <dminuoso> hpc: CC?
16:07:51 <hpc> as in CC=gcc make blahblah
16:07:53 <Welkin> why virtualize instead of running on bare metal?
16:08:07 <Welkin> I know some of the benefits, but it also comes with problems
16:08:26 <hpc> Welkin: in this case, i don't have a bsd box to spare but i really wanted to use pf
16:08:39 <Welkin> I meant in production
16:08:43 <hpc> ah
16:08:57 <hpc> mostly having tools that let you create VMs on demand
16:09:07 <dminuoso> hpc: Most of "ansible" seems to be "look I can provision a machine from scratch just fine"
16:09:35 <Welkin> the only killer feature I can thikn of besides on-demand instances is being able to move a VM to another physical server while it is running (pausing it of course)
16:09:38 <dminuoso> hpc: Once you start running playbooks on your fleet things usually blow up half way through a playbook. And then you're left with machines in unknown states...
16:10:25 <hpc> dminuoso: that works a lot better with puppet in my experience
16:10:34 <hpc> i'll still snapshot just in case, but 99% of the time it just works
16:10:48 <dminuoso> hpc: With Ansible it runs 100% of the time until it doesn't.
16:11:45 <hpc> or whoever wrote your ansible decided to just execute "blahblah >> /etc/blah.conf" and now you can't even run it twice on the same box in a row
16:11:49 <__monty__> How about saltstack? They recently added agentless (à la ansible) operation afaik.
16:11:57 <dminuoso> hpc: We had this extremely amusing case of two macbooks, both running same macOS, same vagrant, same ansible. `vagrant up` creates reproducibly different states (it crashes on my machine on the first playbook run) on both macbooks.
16:12:12 <NoidedSuper> orchestration seems like it's a nightmare in general 
16:12:28 <hpc> dminuoso: i bet it's order of operations
16:12:44 <dminuoso> hpc: Why would the order be different on my macbook? :)
16:12:50 <Welkin> haha
16:12:55 <Welkin> joe armstrong mentions this
16:13:06 <hpc> maybe the order rng is seeded from your machine id or something stupid like that
16:13:18 <Welkin> and let it crash and start fresh
16:13:41 <dminuoso> hpc: I see! So what you are saying I should rename my laptop to fix the problem!
16:14:00 <hpc> i mean, who knows what it is
16:14:01 <dminuoso> Or maybe it uses camera data for entropy, and Im not pretty enough.
16:14:15 <hpc> maybe it measures your distance from the wireless router
16:14:31 <dminuoso> hpc: I tried using it as a definite proof of how bad ansible is. His reaction was just a "shrug"
16:14:42 <hpc> lol, shrug
16:14:53 <hpc> who cares, it's only the thing that defines your ENTIRE vm
16:15:16 <Welkin> what are you running on it anyway?
16:15:27 <Welkin> it should be the exact same disk image
16:15:27 <hpc> and this is why you always give your language separate IO
16:15:43 <dminuoso> Welkin: I know right?
16:16:08 <dminuoso> hpc: Though I have an idea.
16:16:57 <dminuoso> hpc: It could be a different Python version. Perhaps some "in this x.y.y-r172 patch we changed dictionary order from "insertiont" to "memory usage hashed with MD5"
16:17:12 <dminuoso> It's probably even that.
16:17:26 <hpc> ooh, yeah
16:17:42 <hpc> like someone's depending on a dict iterator to be alphabetical but it's just random
16:18:45 <hpc> see if you can get them to use nix ;)
16:19:42 <dminuoso> hpc: If I can't even convince them that this is bad...
16:20:04 <Welkin> convince who?
16:20:27 <nshepperd1> What if it's the hardware
16:20:54 <Welkin> you are running this on macbooks, or on a server?
16:20:56 <dminuoso> nshepperd1: It's provisioned onto a VM.
16:21:11 <Welkin> because a VPS can cause heisenbugs like I said earlier
16:21:25 <Welkin> one company had huge problems until they moved to bare metal
16:21:32 <nshepperd1> Your macbook is on a vm?
16:22:06 <dminuoso> nshepperd1: No. We set up the test servers using vagrant and provision them with ansible.
16:22:38 <Welkin> try it on bare metal, or at least a dedicated server where you control all of the VMs
16:28:04 <hpc> FULL METAL MACBOOK
16:28:24 <Welkin> a body-on-frame macbook?
16:28:40 <Welkin> does it come with a snorkel?
16:30:45 <hpc> it comes with magsafe sunglasses and a built in pez dispenser
16:31:15 <dminuoso> magsafe?
16:31:29 <geekosaur> body on frame macbook? thought that was an imac
16:31:44 <dminuoso> hpc: I'd rather it came with wireless sunglasses.
16:32:05 <dminuoso> EyePods.
16:32:36 <hpc> polarized webcam, it can only see you if you rotate 90 degrees
16:37:38 <aplainzetakind> Is it possible to derive a class for a type that I'm importing?
16:37:55 <Welkin> that is called an orphan instance
16:38:00 <Welkin> yes
16:38:10 <Welkin> use StandaloneDeriving
16:38:24 <Pamelloes> Is there a good way to get all possible (Bool, Bool, Bool, Bool)?
16:38:50 <Welkin> Pamelloes: take the cartesian product of that as a list
16:38:58 <Welkin> then convert to 4-tuples using a lambda
16:39:06 <aplainzetakind> Welkin: Thanks.
16:39:09 <Pamelloes> Ooh, clever
16:39:20 <hpc> > (,,,) <$> [False..] <*> [False..] <*> [False..] <*> [False..]
16:39:22 <lambdabot>  <hint>:1:19: error: parse error on input ‘]’
16:39:45 <hpc> > (,,,) <$> [False ..] <*> [False ..] <*> [False ..] <*> [False ..]
16:39:47 <lambdabot>  [(False,False,False,False),(False,False,False,True),(False,False,True,False)...
16:39:49 <Welkin> > map (\[a,b,c,d] -> (a,b,c,d)) . sequence $ [[True, True, True, True],[False,False,False,False]]
16:39:51 <lambdabot>  [*Exception: <interactive>:3:6-28: Non-exhaustive patterns in lambda
16:40:17 * hackage function-builder 0.2.0.0 - Create poly variadic functions for monoidal results  https://hackage.haskell.org/package/function-builder-0.2.0.0 (SvenHeyll)
16:41:11 <aplainzetakind> Hmm, it says it can standalone derive only stock classes.
16:41:37 <aplainzetakind> I'm trying to get a ToJSON for HCodecs's Midi.
16:41:51 <dminuoso> aplainzetakind: who is "it"?
16:42:00 <Solonarv> aplainzetakind: standalone deriving works whenever a deriving clause on the datatype would work
16:42:03 <aplainzetakind> ghc(i)
16:42:14 <dminuoso> aplainzetakind: Show us your code and the full error.
16:42:16 <dminuoso> % :set -XStandaloneDeriving
16:42:16 <yahb> dminuoso: 
16:42:28 <dminuoso> % class Foo a
16:42:28 <yahb> dminuoso: 
16:42:33 <Welkin> you can derive Generic and then use `instance FromJSON Type`
16:42:36 <Solonarv> ToJSON is only derivable with the anyclass strategy, which is equivalent to writing down an empty instance; so you can just write down an empty instance
16:42:48 <dmwit> > replicateM 4 [False,True]
16:42:50 <lambdabot>  [[False,False,False,False],[False,False,False,True],[False,False,True,False]...
16:43:16 <Solonarv> (I lied, it's also derivable with newtype or via strategies if you have appropriate "helper" types)
16:43:39 <hpc> ah, replicateM is much better for this
16:44:05 <dmwit> > replicateM 4 "ft" -- it's more fun to see more of the output
16:44:07 <lambdabot>  ["ffff","ffft","fftf","fftt","ftff","ftft","fttf","fttt","tfff","tfft","tftf...
16:44:12 <aplainzetakind> Welkin: Yes it was because I skipped the Generic. It works now.
16:44:28 <iqubic> what the heck dies that di>
16:44:36 <iqubic> do*
16:45:05 <lyxia> it nondeterministically picks 'f' or 't', four times.
16:45:11 <iqubic> I see.
16:45:53 <Solonarv> replicateM n k = do x1 <- k; ... xn <- k; pure [x1, ..., xn]
16:46:10 <iqubic> Can we make a weighted list monad? Where the chances of picking each element is different from (1/length) but all probabilities add up to 1.
16:46:33 <iqubic> like so we can add randomness to our list monads.
16:47:08 <Solonarv> the "nondeterminism" expressed by []'s monad instance actually goes down all paths, it doesn't pick one randomly
16:47:10 <Welkin> > map (\[a,b,c,d] -> (a,b,c,d)) . sequence $ replicate 4 [True,False]
16:47:13 <lambdabot>  [(True,True,True,True),(True,True,True,False),(True,True,False,True),(True,T...
16:47:21 <Solonarv> but sure, that's possible
16:47:42 <Solonarv> Welkin: sequence . replicate n = replicateM n
16:47:54 <Welkin> I realized that
16:48:02 <Welkin> I'm more used to using the more basic forms
16:48:07 <lyxia> iqubic: WriterT Real [] is pretty close to that
16:49:15 <Welkin> Real? as in real numbers?
16:49:22 <Welkin> or the brasilian currency?
16:49:36 <Solonarv> real numbers, obviously
16:49:49 <Solonarv> although I'm not sure where you're getting that type from
16:50:00 <iqubic> I'm not sure how WriterT works though.
16:50:23 <Solonarv> it doesn't in this case, because this 'Real' almost certainly doesn't have a monoid instance
16:50:45 <dmwit> WriterT (Product Rational) []
16:50:53 <Solonarv> @unmtl WriterT (Product Rational) []
16:50:53 <lambdabot> Plugin `unmtl' failed with: `WriterT (Product Rational) []' is not applied to enough arguments, giving `/\A. [] (A, Product Rational)'
16:51:06 <Solonarv> @unmtl WriterT (Product Rational) [] a
16:51:06 <lambdabot> [] (a, Product Rational)
16:51:15 <dmwit> :t writer
16:51:16 <lambdabot> MonadWriter w m => (a, w) -> m a
16:51:35 <dmwit> :t WriterT
16:51:37 <lambdabot> m (a, w) -> WriterT w m a
16:54:00 <dmwit> > liftA2 (,) (WriterT [("heads", 0.75), ("tails", 0.25)]) (WriterT [("$100", 0.3), ("-$75", 0.7)]) :: WriterT (Product Double) [] (String, String)
16:54:02 <lambdabot>  error:
16:54:02 <lambdabot>      • No instance for (Fractional (Product Double))
16:54:03 <lambdabot>          arising from the literal ‘0.75’
16:54:42 <Solonarv> huh!? that's an oversight!
16:54:50 <dmwit> > liftA2 (,) (WriterT [("heads", Product 0.75), ("tails", Product 0.25)]) (WriterT [("$100", Product 0.3), ("-$75", Product 0.7)])
16:54:52 <lambdabot>  WriterT [(("heads","$100"),Product {getProduct = 0.22499999999999998}),(("he...
16:55:09 <lyxia> For the record, I made "Real" up.
16:55:18 <Welkin> is-real?
16:55:21 <Solonarv> I figured
16:55:39 <Solonarv> there's a CReal ("computable real") somewhere, or you can just use Rational
16:55:43 <dmwit> An oversight that has been fixed in later versions of base, I think.
16:56:12 <Solonarv> % liftA2 (,) (WriterT [("heads", 0.75), ("tails", 0.25)]) (WriterT [("$100", 0.3), ("-$75", 0.7)]) :: WriterT (Product Double) [] (String, String)
16:56:12 <yahb> Solonarv: ; <interactive>:185:32: error:; * No instance for (Fractional (Product Double)) arising from the literal `0.75'; * In the expression: 0.75; In the expression: ("heads", 0.75); In the first argument of `WriterT', namely `[("heads", 0.75), ("tails", 0.25)]'
16:56:13 <dmwit> Solonarv: But what if I want to use 1/(e+pi) as my probability? Can I use Rational for that or not?
16:56:46 <Solonarv> clearly not! (yahb isn't stuck on an old version of base)
16:56:51 <dmwit> Oh, perhaps not!
16:57:00 <dmwit> It's got Num but maybe not Fractional. Bummer.
16:57:20 <Solonarv> dmwit: you can round it first, which you'd have to do with almost any representation other than a symbolic one
16:57:37 <dmwit> Trick question. It is currently an open question whether e+pi is rational.
16:57:39 <Welkin> never use floating point =D
16:58:08 <Solonarv> that seems like an overly zealous stance
17:00:38 <Pamelloes> Is there a good way to produce a function with a finite domain from a list of tuples?
17:00:54 <shachaf> lookup?
17:02:36 <Pamelloes> That makes sense. I guess my domain is only 16 things so the lookup performance is negligible
17:03:44 <dmwit> Data.Map.fromList?
17:03:57 <Solonarv> you could slap a memoTrie or something over the lookup
17:05:31 <aplainzetakind> ByteString not having a ToJSON instance is causing problems: https://paste.pound-python.org/show/uVekF1pIYcr1oFwKgKoB/ If I import Data.ByteString.Lazy.Internal and derive Generic and declare ToJSON for ByteString too, I get the same error with the additional message "There are instances for similar types: " pointing to my declaration.
17:07:05 <Solonarv> aplainzetakind: ByteString not having a ToJSON instance is by design, though I don't recall the exact reasoning
17:08:22 <aplainzetakind> I'm not doing anything with ByteStrings myself, why is it suddenly needed?
17:09:02 <Welkin> there is no representation for bytestring in json since bytestrings are binary data
17:09:15 <Welkin> you can convert the bytestring to a Text first
17:09:48 <aplainzetakind> Ah, Message from Midi has some ByteString fields.
17:10:08 <Solonarv> if you're trying to automatically generate a {To,From}JSON instance for a datatype, all of its fields must also have a {To,From}JSON instance, yea
17:10:10 <Welkin> you can write your own instance
17:10:13 <Welkin> for Midi
17:10:48 <aplainzetakind> It has like 30 constructors.
17:11:09 <travv0> dmj` I'm playing around with miso, do you know of an example somewhere of how to send a request and get back JSON from the GHCJS side of things?  I've been using the elm docs to get the gist of how things are structured but I'm not sure how to do the equivalent of elm's Http.get  or whatever
17:11:09 <Solonarv> looks like you're out of luck then
17:11:27 <Solonarv> perhaps generic-data can help but I wouldn't expect t to
17:11:32 <midi[m]> ._. I keep getting called here but it is about the actual format, MIDI
17:11:55 <iqubic> LOL.
17:12:04 <aplainzetakind> I'll roll my own midi type, I'm using a fraction of the functionality anyway.
17:12:04 <iqubic> We like our audio.
17:12:32 <midi[m]> <freenode_iqu "We like our audio."> same
17:12:43 <dmj`> travv0: Awesome. I'd recommend servant-client-ghcjs if you're using servant, otherwise, there ghcjs-base has an AJAX model. There are some examples. 
17:12:46 <dmj`> travv0: https://github.com/dmjio/miso/blob/master/examples/xhr/Main.hs#L131
17:12:50 <Welkin> what is this library you are using?
17:13:08 <travv0> dmj` Great, thanks!
17:13:10 <dmj`> the package  ghcjs-base has an AJAX module*
17:13:12 <Welkin> I wrote a midi parser myself in lua and it was pretty easy, despite some weird undocumented edge cases
17:13:32 <aplainzetakind> https://hackage.haskell.org/package/HCodecs-0.5/docs/Codec-Midi.html
17:15:24 <aplainzetakind> I won't even need to parse, I just want a type to hold a bunch of note-on note-off messages.
17:15:49 <dmj`> travv0: feel free to join the slack too, lots of production miso users on there. https://haskell-miso-slack.herokuapp.com/
17:17:11 <travv0> dmj` will do, thanks again
17:17:19 <dmj`> travv0: np
17:24:59 <untseac> I only now realized there's a new ide engine thing and ghc-mod is dead.
17:25:18 <Clint> it sneaks up on you like that
17:25:23 <untseac> yeah good news travel really slow
17:25:47 <untseac> only the bad ones hit your face at full speed
17:26:26 <Welkin> at the end of the movie you'll realize you were dead the whole time
17:27:35 <untseac> oh boy. maybe we're just antennas to a distributed computer planet.
17:31:41 <infinisil> untseac: Nonono, ghc-mod is part of hie
17:32:22 <untseac> infinisil, yeah I noticed that but still, it's much easier to just install hie. it has everything I wanted and more. pretty awesome imo.
17:32:42 <infinisil> untseac: Yeah, but it's not like ghc-mod is dead, that would make no sense
17:33:04 <Welkin> ding dong, the witch is dead
17:33:10 <infinisil> I guess the "frontend" of ghc-mod might become deader though
17:40:58 <untseac> yeah you're right. I'm sad that atom manual tricked me into installing ghc-mod directly instead of this plugin. That's what I get for backstabbing neovim.
17:44:27 <infinisil> HIE does need lots of work though, it's not quite there yet
17:44:55 <infinisil> I am using it for my haskell development, but there's occasional problems
17:45:13 <infinisil> untseac: #haskell-ide-engine is the IRC channel for it fyi
17:46:31 <untseac> infinisil, thanks. that will be handy if I find bugs and such.
17:47:47 * hackage hw-mquery 0.2.0.1 - Monadic query DSL  https://hackage.haskell.org/package/hw-mquery-0.2.0.1 (haskellworks)
18:08:27 <mjrosenb> hey, all.  I'm trying to figure out hsx, and as far as I can tell, the happstacke examples are out of date.  Does anyone know of an up to date example of hsx in action?
18:53:06 <mjrosenb> I'm surprised there's so little traffic.
18:55:11 <sm[m]> mjrosenb: stretching "up to date", but darcsden uses hsx
18:57:39 <sm[m]> would anyone happen to know if hpack ever required the version: value in package.yaml to be in quotes ? It seems to work without quotes here, but I don't want to break older hpack versions
18:59:01 <Solonarv> I don't think that was ever required, no
18:59:31 <Solonarv> but if you're publishing your package for other people to use I would strongly recommend not using hpack at all, and using cabal instead
19:01:40 <jackdk> Agreed.
19:03:21 <sm[m]> I provide the cabal file, hpack is for me (reduces errors)
19:03:39 <sm[m]> thanks
19:04:30 <Solonarv> I'm a bit confused as to what error you can make with cabal files that you can't with hpack, tbh
19:05:02 <Solonarv> you can forget to list a module in {exposed,other}-modules, but cabal warns you about that
19:08:43 <sm[m]> in cabal files you have to repeat yourself; it's easy to miss one when bumping version numbers etc. I believe that's no longer the case if you require modern cabal
19:10:51 <Solonarv> indeed, if you use common stanzas that's no longer a problem
19:11:23 <Solonarv> also, IIRC you only need to mention a package's version once; all uses of a dependency will have the same version
21:06:13 <cain> i'm having trouble understanding reactive-banana's model implementation; has anyone here tried to make sense of it before?
21:07:47 <glguy> Specific questions are good if you want to be more likely to get help.
21:07:56 <cain> is it okay to be really specific?
21:08:11 <glguy> Open ended questions just tend to get ignored
21:08:24 <cain> alright
21:10:16 <cain> why is the type of the argument in the interpret function in Reactive.Banana.Model (Event a -> Moment (Event b)) and not just (Event a -> Event b)?
21:11:31 <cain> i'm trying to look through the source and it seems that interpret just runs the Moment your supplied function returns with time = 0
21:12:04 <cain> so why do we need to do things in the Moment monad?
21:14:17 <geekosaur> I would suspect the point is you're interpreting on the fly something that is normally triggered; that is, it's making something in the Moment monad usable "outside" it or "standalone"
21:14:56 <geekosaur> like runState or etc. but for Moment
23:21:47 * hackage jsaddle 0.9.6.0 - Interface for JavaScript that works with GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-0.9.6.0 (HamishMackenzie)
23:25:47 * hackage jsaddle-warp 0.9.6.0 - Interface for JavaScript that works with GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-warp-0.9.6.0 (HamishMackenzie)
23:26:47 * hackage jsaddle-wkwebview 0.9.6.0, jsaddle-webkit2gtk 0.9.6.0 (HamishMackenzie): https://qbin.io/sorts-pretty-ng36
23:27:47 * hackage jsaddle-clib 0.9.6.0 - Interface for JavaScript that works with GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-clib-0.9.6.0 (HamishMackenzie)
