00:01:48 <sneakybisky> * JOINS PARTS QUITS NICKS
00:02:03 <sneakybisky> sorry...
00:02:35 <Axman6> that was a good start to a poem, please finish it
00:04:52 <sneakybisky> HASKELL ROCKS. -- finished
00:07:08 <statusbot> Maintenance update: Various website migrations  in progress. Please let us know if there are issues. -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5c6915eaa517ad04b71ab9e5
01:32:37 * hackage imm 1.5.0.0 - Execute arbitrary actions for each unread element of RSS/Atom feeds  https://hackage.haskell.org/package/imm-1.5.0.0 (koral)
02:08:17 <old_Logan> hi
02:09:14 <old_Logan> whats do u think about Rhodesia?
02:25:00 <Axman6> the country?
02:31:37 * hackage direct-sqlite 2.3.24 - Low-level binding to SQLite3.  Includes UTF8 and BLOB support.  https://hackage.haskell.org/package/direct-sqlite-2.3.24 (sigrlami)
02:32:37 * hackage wai-app-static 3.1.6.3 - WAI application for static serving  https://hackage.haskell.org/package/wai-app-static-3.1.6.3 (MichaelSnoyman)
02:42:37 * hackage alist 0.1.0.5 - lists with O(1) append  https://hackage.haskell.org/package/alist-0.1.0.5 (AlanHawkins)
03:33:37 * hackage gi-gtk-declarative 0.4.2 - Declarative GTK+ programming in Haskell  https://hackage.haskell.org/package/gi-gtk-declarative-0.4.2 (owickstrom)
03:34:37 * hackage gi-gtk-declarative-app-simple 0.4.1 - Declarative GTK+ programming in Haskell in the style of Pux.  https://hackage.haskell.org/package/gi-gtk-declarative-app-simple-0.4.1 (owickstrom)
03:51:40 <cocreature> utdemir[m]: the clock package also ends up calling clock_gettime(CLOCK_MONOTONIC
04:08:36 <Edootjuh> @pl \testName prop -> localOption (QuickCheckMaxSize 10) $ QC.testProperty testName prop
04:08:36 <lambdabot> (localOption (QuickCheckMaxSize 10) .) . QC.testProperty
04:13:23 <Tourist> @help
04:13:23 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:13:33 <Tourist> list
04:14:13 <Tourist> help list
04:14:18 <[exa]> Tourist: you can /query lambdabot and get all the help privately
04:14:22 <[exa]> (highly recommended)
04:16:31 <sneakybisky> [exa]: Is there tutorial for labmdabot? Or QAF for #haskell. Thanks
04:23:17 <Tourist> @help list
04:23:17 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
04:40:30 <Edootjuh> quit
04:44:29 <jollygood2> @hoogle [Either a b] -> [a]
04:44:29 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
04:44:29 <lambdabot> CorePrelude lefts :: [Either a b] -> [a]
04:44:29 <lambdabot> Foundation lefts :: [Either a b] -> [a]
04:44:54 <jollygood2> @hoogle Either a b -> a
04:44:55 <lambdabot> Prelude Left :: a -> Either a b
04:44:55 <lambdabot> Data.Either Left :: a -> Either a b
04:44:55 <lambdabot> Data.Strict.Either Left :: a -> Either a b
04:45:11 <jollygood2> no fromLeft/fromRight?
04:45:55 <kritzefitz> Ther is Data.Either.fromLeft
04:46:09 <kritzefitz> :t fromLeft
04:46:10 <lambdabot> a -> Either a b -> a
04:46:16 <kritzefitz> :t fromRight
04:46:16 <jollygood2> :t fromRight
04:46:17 <lambdabot> b -> Either a b -> b
04:46:17 <lambdabot> b -> Either a b -> b
04:46:19 <jollygood2> huh
04:46:32 <jollygood2> could swear I tried that
04:53:36 <sneakybisky> [exa]:  ok, I googled it and found the manual in https://wiki.haskell.org/Lambdabot
04:57:43 <sneakybisky> @help todo
04:57:44 <lambdabot> todo. List todo entries
04:57:47 <sneakybisky> @todo
04:57:47 <lambdabot> 0. SamB: A way to get multiple results from a google search
04:57:47 <lambdabot> 1. dons: improve formatting of @dict
04:57:47 <lambdabot> 2. dons: write Haskell Manifesto
04:57:47 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
04:57:47 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
04:57:49 <lambdabot> [43 @more lines]
04:58:18 <sneakybisky> @joke
04:58:18 <lambdabot> Maybe you meant: vote more join
04:58:54 <sneakybisky> @quote
04:58:54 <lambdabot> ppot says: But I find the best data structures usually come in Java.lang etc.
04:59:03 <sneakybisky> @quote
04:59:03 <lambdabot> XavierLeroy says: When I was a child, I was told that Santa Claus came in through the chimney, and that computers were programmed in binary code.
04:59:23 <sneakybisky> @quote
04:59:23 <lambdabot> emu says: olegarithmic!
04:59:27 <sneakybisky> @quote
04:59:27 <lambdabot> sopvop says: Python be like "Feel the power of a duck side", and haskeller is like "No! NEVER!"
04:59:44 * tourist314159
05:04:39 <Solonarv> sneakybisky: if you want to play with lambdabot without flooding the channel, you can do it in a /query
05:04:48 <jollygood2> what's the idiomatic way to have Data.Map with case insensitive string keys? lowering all the keys on input and during lookup? newtype Text and then defining caseless Ord instance?
05:05:04 <jollygood2> or something else?
05:05:42 <Solonarv> @hackage case-insensitive
05:05:42 <lambdabot> http://hackage.haskell.org/package/case-insensitive
05:05:54 <Solonarv> use that as keys, I would say.
05:06:20 <Solonarv> (basically a ready-made "newtype Text and caseless Ord instance")
05:08:42 <jollygood2> that looks good
05:10:36 <jollygood2> it uses Data.String.IsString. what implications does that have when I use Text? (will it internally convert Text to String?)
05:11:42 <c_wraith> It uses IsString for the OverloadedStrings extension
05:11:59 <jollygood2> oh
05:12:13 <Solonarv> (that is in fact the entire purpose of IsString)
05:12:18 <merijn> jollygood2: OverloadedStrings/IsString is fine if the conversion from String to the result is total
05:12:42 <merijn> jollygood2: Which it is for Text (or case insensitive text, since all Strings can be mapped to those types)
05:13:49 <gspia> hey! Anyone hayoo users around? Is the service working ok for you? (I have had troubles with it for some time now but I really like hayoo which is the reason why I'm asking)
05:14:13 <hpc> it's got a better index than hoogle, but is much slower to load
05:15:55 <gspia> hpc are you using it locally? I have used https://hayoo.fh-wedel.de for very long time except some latest weeks 
05:16:15 <hpc> through the website
05:16:56 <hpc> specifically through duckduckgo's !hayoo
05:17:47 <gspia> ah, ok thanks, I'll try to find & try it (i had link to that fh-wedel.de-cite which seems to be down)
05:19:25 <hpc> if it could be hosted by haskell.org that would be ideal
05:19:47 <gspia> yep very much thinking likewise!
05:19:50 <cads> hey all, are there any debuggers for haskell which work in a friendly point-and-click way like the chrome debugger for javascript?
05:20:45 <gspia> the duckduckgo seems to refer to fh-wedel.de and seems to time-out (it is still trying to form the query)
05:21:07 * cads doesn't understand much of what this is talking about: https://wiki.haskell.org/Debugging
05:22:30 <jollygood2> it seems that case-insensitive converts Text to String internally.  http://hackage.haskell.org/package/case-insensitive-1.2.0.11/docs/src/Data-CaseInsensitive-Internal.html#mk
05:22:39 <jollygood2> foldCaseList = TL.unpack . TL.toCaseFold . TL.pack
05:23:28 <cads> also, before someone says that functional programming means I'll need a debugger less, please allow me to ready my most withering glare
05:23:54 <c_wraith> cads: glare away!
05:24:09 <hpc> you're gonna need more eyes ;)
05:24:31 <cads> well, I am still powering up my /finest/, most /soul expelling/ glare
05:24:35 <Solonarv> jollygood2: that's the FoldCase Char instance you're looking at! you should be using the instance for Text, which doesn't have that
05:24:43 <hpc> although at the same time, i have only ever used a debugger in any language when it was required of me for a course
05:25:23 <hpc> or maybe if you're really generous about definitions and include strace
05:25:43 <c_wraith> Technically, I've used gdb with haskell.  When trying to track down segfaults caused by bad ffi bindings.
05:25:45 <cads> well I'm doing something dumb perhaps 2 levels in on a recursion, and I don't know where. My current debugger is paste-binning it to you lot. I'm sure nobody wants that.
05:26:16 <hpc> feynman's method has never steered me wrong before
05:26:27 <Solonarv> what's that? stare really hard?
05:26:38 <cads> hpc, is that where I additionally get you lot stoned?
05:26:45 <hpc> Solonarv: step 1, write down the problem, step 2, think really hard, step 3, write down the solution
05:26:51 <hpc> the secret is all three steps are equally important
05:27:07 <jollygood2> Solonarv, you're right. it uses Data.Text.toCaseFold for Text
05:27:09 <hpc> cads: for your specific issue, i'd probably use ghci
05:27:32 <Solonarv> indeed: ghci has a debugger, it's just not graphical.
05:27:35 <gspia> on debuggers: I'm often in deep of something that I don't understand well, say, trying to find out solutions to ill-specified problems. A good debugger helps with that step 2. Especially when the first blow of algs has bee deviced for the problem
05:27:41 <hpc> set yourself up in it so you can have your test function defined as say, f
05:27:43 <merijn> cads: Have you used trace and friends?
05:27:44 <hpc> then see what f 0 is
05:27:45 <hpc> f 1, etc
05:27:58 <merijn> @quote refreshing.desert
05:27:58 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
05:28:00 <hpc> and just interact with your code until you are surprised
05:28:31 <Solonarv> A search turns up an Atom plugin that's a graphical haskell debugger (using the ghci debugger as a backend)
05:28:39 <hpc> if your code isn't structured so you can easily interact with it in that way, you know you have some refactoring to do too
05:28:56 <cads> Solonarv, that's fair enough
05:29:47 <cads> huh, how did you find that, lol
05:31:00 <Solonarv> I just typed "haskell graphical debugger" into duckduckgo
05:32:03 <cads> all the terms I'd be using were finding more research papers than that. Thanks!
05:33:53 <gspia> hpc: is the hayoo working for you atm (through duckduckgo)? On my trial it got time-outed now and I'm just checking if this is a more general problem
05:34:22 <hpc> times out for me too
05:36:17 <gspia> sighs, hopefully the haskell.org-maintainers get some extra energy to put it up 
05:37:17 <cads> merijn, I'm kind of bad at interpreting "walls of text", especially when there are numbers and symbols thrown in, so I get messed up pretty bad by stack traces, logs, and lots of other diagnostic data that many other programmers seem to think is just fine. I'm looking at the options for haskell traces, though
05:37:49 <merijn> cads: trace isn't so much a stack trace as it's just "printf debugging" :p
05:37:58 <cads> it looks like hat-observe tries very hard to show an easy to understand replay of a trace
05:39:07 <jollygood2> I'm having trouble autoderiving Generic instance.  https://bpaste.net/show/5d779b159adc
05:39:54 <cads> merijn, I was about to do the FP equivalent of just that, which would have been ugly (since I think I would have to lift all my pure functions into the IO monad, and figure out how to get them reporting during a computation)
05:40:20 <Solonarv> jollygood2: why are you writing that instance in the first place?
05:40:24 <merijn> cads: Right, trace is just a bunch of unsafePerformIO so you don't have to do that ;)
05:41:29 <jollygood2> Solonarv, so I can derive FromJSON and ToJSON, which require Generic
05:41:45 <jollygood2> is the proper syntax for standalone deriving deriving instance Generic (CI Text)?
05:41:49 <Solonarv> jollygood2: writing orphan instances like that is generally a bad idea
05:42:28 <Solonarv> in fact, the Generic-based To/FromJSON instances for CI s would be wrong!
05:42:41 <Solonarv> that's likely why CI doesn't already have a Generic instance.
05:43:08 <jollygood2> Solonarv, why? and how am I suppose to use CI with aeson if I don't write an orphan instance?
05:43:58 <cads> merijn, to be clear, you're talking specifically about Debug.Trace.trace, which provides a function trace:: String -> a -> a which I can add to function definitions, much in the spirit of printf debugging, right?
05:44:08 <Solonarv> jollygood2: data CI s = { original :: !s, foldedCase :: !s }
05:45:08 <Solonarv> mk "foo" :: CI Text would be encoded as the JSON { "original": "foo", "foldedCase": "FOO" } using the hypothetical Generic instance - clearly this is nonsense!
05:46:32 <jollygood2> while less than ideal (it would store more text than required), what makes it wrong?
05:46:57 <c_wraith> the two values aren't allowed to vary completely independently
05:47:11 <c_wraith> FromJSON would be totally broken
05:47:20 <Solonarv> toJSON (mk "foo") and toJSON (mk "FOO") would not compare equal, even though mk "foo" and mk "FOO" do
05:48:25 <Solonarv> instead you can write these instances: https://gist.github.com/Solonarv/86132526be482668cd3af22ed4d61923 which will behave correctly
05:49:01 <Solonarv> (they are still orphan instances, but they do not allow you to distinguish equal values!)
05:49:16 <jollygood2> nice
05:50:09 <cads> thanks for the valuable input, Solonarv, hpc, merijn, c_wraith 
05:50:11 <Solonarv> you're allowed to define the contents of To/FromJSON instances yourself, in fact that's often a better idea than letting Generic handle it for you :P
05:51:05 * cads is determined to make haskell their 'bread and butter' language (where previously this was node.js)
05:51:05 <jollygood2> shouldn't the complaint about orphan instances be directed toward aeson? unless you use aeson with only your own types (which would be pretty limited) you have to create orphan instances
05:51:39 <Solonarv> you can use aeson without using To/FromJSON at all, and just write plain old functions instead
05:53:04 <Solonarv> but this is in fact a valid criticism against aeson
05:53:33 <c_wraith> it's not really a criticism against aeson specifically.  It's a criticism of the entire type class system
05:53:37 <hpc> aeson's api definitely "wants" you to write instances
05:53:46 <c_wraith> Or at least, how it interacts with packages.
05:54:05 <Solonarv> c_wraith: good point
05:54:09 <c_wraith> You either end up with orphan instances, packages that depend on everything, or packages that are depended on by everything
05:54:28 <hpc> or you just don't get the instances at all
05:54:38 <hpc> or you hope that the class wiggles its way into base
05:54:40 <c_wraith> ah, right.  the fourth quadrant
05:54:49 <c_wraith> profunctors will be in base one day!
05:54:59 <Solonarv> I sure hope so!
05:59:10 <Solonarv> looking at their dependency footprints, it's possible that aeson could pick up a dependency on case-insensitive and provide To/FromJSON instances for CI
06:05:54 <deltasquared> would there be any reason in particular that doing a foldl' over lines from a readFile (where the file is moderately sized, about 100MB or so) would lead to a space leak on the order of a few GB at at time? (16GB RAM dev machine at work and I nearly caused it to OOM during a lunch break...)
06:06:12 <deltasquared> I don't have the code to hand right this second, I can get in a moment, need to sort something else out first
06:07:40 <c_wraith> deltasquared: sure.  easy to do if the accumulator can get big
06:08:19 <c_wraith> deltasquared: for foldl' memory use, the accumulator is the thing you have to look at
06:09:20 <ClaudiusMaximus> you might need stricter data, eg a regular lazy tuple will likely blow up as foldl' only forces the outermost constructor (WHNF)
06:10:31 <deltasquared> c_wraith: I'm doing an fmap to a "size" (1 or 0 depending on matching a predicate) then the accumulator is regular (+)
06:10:37 <deltasquared> let me guess, I need a strict +?
06:10:46 <c_wraith> (+) is strict on several types
06:10:58 <deltasquared> Integer?
06:11:00 <c_wraith> yes
06:11:19 <deltasquared> hrm, I will have to get the code out then. please allow me to finish sorting some laundry first...
06:12:14 <c_wraith> wait, fmap?  This is sounding wrong
06:13:01 <deltasquared> it is quite possible I was being foolish, but I will get the code out in question shortly
06:16:40 <lunabo> Does anyone know of a way to have Cabal make use of a stack-installed GHC? I am building a project which can only be built with Cabal, but it requires a specific GHC version, which I have installed using Stack
06:18:58 <merijn> lunabo: cabal-install just uses whichever GHC is first in your path
06:19:07 <merijn> lunabo: Although you can override it with -w
06:19:24 <merijn> lunabo: Also, note that "Cabal" is not the cabal executable
06:19:47 <merijn> lunabo: Cabal is the package building library used by both cabal-install (the "cabal" executable) and stack
06:20:11 <merijn> lunabo: So refering to cabal-install as Cabal (especially with that capitalisation!) is super confusing to people :)
06:20:38 <Athas> lunabo: 'stack exec cabal build', but I think it's a really bad idea.
06:21:04 <lunabo> merijn: thanks and in retrospect I can see how it might be confusing
06:21:29 <maerwald_> Athas: stack changes some env variables that can mess stuff up surprisingly :)
06:21:40 <Athas> Indeed!  That's why I think it's a bad idea.
06:21:51 <lunabo> Athas: Any ideas for a nicer way to have the specific GHC version (without it conflicting with my system -wide install)? I suppose I could use nix
06:22:08 <merijn> lunabo: Eh, you just install GHC into different subdirs :)
06:22:08 <Athas> It might work, but a better solution is just to install the right GHC outside of Stack, or to add a stack.yaml to that project.
06:22:26 <maerwald_> yes, use ghcup
06:22:34 <merijn> lunabo: All GHC's metadata is tagged with the version so you can have any number of installed GHCs as long as they are different versions
06:23:01 <maerwald_> lunabo: https://github.com/haskell/ghcup
06:23:08 <merijn> lunabo: Personally I just install various GHC binary distributions into $HOME/ghc80 $HOME/ghc82, etc.
06:23:19 <lunabo> maerwald_: I wasn't aware of the existence of ghcup, I'll try that :)
06:23:26 <merijn> lunabo: Then I switch version by adjusting my path or telling cabal which to use via -w
06:24:03 <maerwald_> ghcup automates that :)
06:24:30 <maerwald_> make sure to check the "known problems" section in the readme
06:24:37 <deltasquared> ClaudiusMaximus, c_wraith: https://ptpb.pw/Hrjh
06:25:08 <merijn> Maybe it does, but I've done this by hand for years, so I know how everything works and there's no breakage, so switching to something like ghcup will most likely only make things more brittle for me :p
06:25:11 <maerwald_> Athas: yeah, it sets GHC_PACKAGE_PATH
06:25:32 <merijn> Additionally, I only install GHC versions like once a year, so manually downloading + unzipping isn't too much hassle
06:25:47 <maerwald_> merijn: sure, but fore newcomers it's more work
06:26:56 <ClaudiusMaximus> deltasquared: that snippet looks unproblematic on its own.  but problem could occur if the input list is retained in memory (perhaps you are also calling length on it, to get an average, or similar?)
06:27:27 <deltasquared> ClaudiusMaximus: not retaining the list AFAIK, my usage of it was passing (lines file) to it (where file was from readFile)
06:27:39 <deltasquared> the predicate was (== ""), i.e. empty lines
06:28:01 <deltasquared> I'll try and re-assemble the entire thing, one moment
06:32:45 <deltasquared> ClaudiusMaximus: the input file is the raspbian repository file /dists/testing/main/binary-armhf/Packages - pick a mirror near you from https://www.raspbian.org/RaspbianMirrors/, I personally got it from http://mirror.ox.ac.uk/sites/archive.raspbian.org/archive/raspbian/dists/testing/main/binary-armhf/Packages
06:32:53 <deltasquared> it's about 66M at the time of writing.
06:33:08 <deltasquared> the idea was to count the number of packages, as their metadata is separated per package by a blank line.
06:33:32 <deltasquared> that 66M file became about 6GB in space leak :(
06:34:45 <deltasquared> ClaudiusMaximus: would running it in ghci have made any difference? at the time of first running I was unable to compile it (something was up with the ghc install on the windows work laptop, couldn't get it to compile...)
06:35:09 <deltasquared> the main file anyway: https://ptpb.pw/uK_N
06:35:12 <ClaudiusMaximus> deltasquared: if you bound the input to a name, it will be retained
06:35:32 <deltasquared> ClaudiusMaximus: but even with unicode expansion it'd only be a 4x factor surely?
06:35:42 <ClaudiusMaximus> deltasquared: ghci wouldn't know that you're not needing it later
06:35:42 <deltasquared> versus approx. x100 that I saw...
06:36:15 <deltasquared> I wouldn't have expected a retention of the input to lead to a x100 factor increase in space leak though
06:36:55 <dmwit> No, it's worse than that. Each Char takes one word, each (:) takes two, so 3*64 ~= 180 bytes per character in the String is possible.
06:37:12 <deltasquared> o.o
06:37:13 <ClaudiusMaximus> 8 bytes for (:) constructor tag, 8 bytes for (:) element pointer, 8 bytes for Char constructor, 8 bytes for Char# data, 8 bytes for pointer to rest of String, per code point of input data
06:37:17 <ClaudiusMaximus> iirc
06:37:38 <ClaudiusMaximus> (on 64bit, s/8/4/ for 32bit)
06:37:49 <deltasquared> good grief... (yes was 64-bit machine)
06:38:17 <dmwit> Oh, ClaudiusMaximus' estimate is even more pessimistic than mine. ^_^
06:38:41 * deltasquared goes to see what it uses in compiled form where intermediate list is not retained
06:39:16 <ClaudiusMaximus> even without -O it should run in small constant space
06:39:27 <deltasquared> ClaudiusMaximus: yeah, it seems to be more well behaved now
06:39:37 <deltasquared> note to self, beware binding things in ghci
06:39:38 <ClaudiusMaximus> as long as there is only one mention of the list so it can be gc'd while it is read
06:39:45 <dmwit> All that to say: yes, it is important to check that you're not forcing the whole thing into memory, and so please show us the rest of the code (minimized if possible please).
06:40:16 <deltasquared> dmwit: the two pastes constitute what I have so far.
06:41:02 <dmwit> Hm. Those look perfectly reasonable to me.
06:41:40 <deltasquared> I guess I was oblivious to the fact I was going to be hanging onto the reference to that file while experimenting in ghci <_>
06:41:54 <dmwit> ah
06:42:08 <deltasquared> it seems to run fast enough even unoptimised too. takes about 10 seconds for adformentioned input file
06:42:58 <deltasquared> not as fast as wc -l from shell (which just counts lines) yet, but I guess that could be worked towards
06:43:30 <deltasquared> oh, optimised it take 3 seconds, delightful
06:45:33 <deltasquared> re: the memory inflation mentioned earlier - at some point I will be retaining part of the input, not all of it though. mostly the package names and their dependency lines. felt like writing a dependency walker thing.
06:46:50 <deltasquared> (goodness, wait I'll have to parse the (>= $version) bits and solve those? travesty!)
06:49:13 <deltasquared> then again, maybe I can just ignore those for the exercise if by definition I've always got the most up to date package list...
06:49:37 <Athas> This sort of stuff makes be wonder whether there is a functional language that is particularly economic with space usage.  Sixten, maybe?
06:50:05 <deltasquared> Athas: I think it would just be better to have a version of lines that returns ByteStrings say
06:50:19 <deltasquared> (that said, still some copying out of the input buffer involved)
06:51:19 <deltasquared> it *would* be interesting to use some kind of region allocation on such contiguous strings though. no point in trying to GC them; they'd be kept until the program finishes walking dependencies, at which point you'd throw away the entire thing
06:52:01 <deltasquared> or as I like to call it, OS-assisted garbage collection :>
06:52:38 <ClaudiusMaximus> recent ghc has compact regions if i got the name right, not used them myself
06:52:56 <deltasquared> seeing as to find dependencies recursively you'd potentially need all of them in memory anyway (unlike what I'm doing currently which is just counting them)
06:53:45 <deltasquared> ClaudiusMaximus: https://downloads.haskell.org/~ghc/8.2.1/docs/html/libraries/ghc-compact-0.1.0.0/GHC-Compact.html ?
06:54:04 <deltasquared> unless this is something else older
06:54:05 <ClaudiusMaximus> and (strict) bytestring (and maybe text?) do slicing (so you have to explicitly copy if you only want to retain part of them)
06:55:20 <ClaudiusMaximus> yeah i think that's the one
06:55:37 <deltasquared> ClaudiusMaximus: right. that's not much different from having to copy from the input buffer if you did so imperatively though - if you need to hold on to a bit of the data, you need to copy it "out of the way" before more data lands in the input buffer.
06:56:18 <deltasquared> the only way you could beat that is if you mmap'd the entire file and just got pointers into it. for a 66MB file that's not too bad, though it wouldn't scale so well if it was say x10 that
06:57:09 <deltasquared> say, has anyone done much on doing efficient bytestring references to an mmap'd region like that?
06:57:55 <deltasquared> so I guess a byte string_view of sorts (data pointer + size)
06:58:08 <deltasquared> you could still preserve the functional-ness of the rest of the program even.
06:58:21 <deltasquared> (just return a list of such byte string refs say)
06:58:30 <ClaudiusMaximus> there's a bytestring-mmap package i think, but it's a bit risky (what happens if the file gets modified behind you)
06:58:31 <hpc> what's a good html templating package?
06:59:03 <jollygood2> @pl \x = f <$> g x
06:59:03 <lambdabot> (line 1, column 4):
06:59:03 <lambdabot> unexpected "="
06:59:03 <lambdabot> expecting operator, pattern or "->"
06:59:08 <jollygood2> @pl \x -> f <$> g x
06:59:08 <lambdabot> (f <$>) . g
06:59:44 <deltasquared> ClaudiusMaximus: I thought there were mmap flags that basically meant a private copy
07:00:04 <deltasquared> the OS could still read efficiently from storage that way (assuming e.g. page alignment requirements)
07:00:21 <ClaudiusMaximus> https://hackage.haskell.org/package/bytestring-mmap-0.2.2/docs/System-IO-Posix-MMap.html
07:01:36 <deltasquared> ClaudiusMaximus: that suggests to me they are not using the right mmap flags... I wonder if it's a portability thing
07:01:54 <hpc> heist seems pointlessly complicated
07:02:42 <deltasquared> mmap(2): "It is unspecified whether changes made to the file after the mmap() call are visible in the mapped region."
07:02:46 <deltasquared> damn
07:03:03 <deltasquared> and that's from linux's man pages too, even on one platform it's unspecified. well shoot
07:03:30 <deltasquared> guess I'd be copying to a private tmpfs copy and mmap'ing that then :>
07:03:41 <elgoosy> hi, for those using emacs, what do you use to align the stuff like this: https://pastebin.com/bw03M9WY ?
07:04:58 <Solonarv> elgoosy: I don't use emacs, but stylish-haskell can do that sort of aligning, and I'm pretty sure there's a convenient way to trigger stylish-haskell from within emacs
07:08:35 <elgoosy> Solonarv, thank you
07:09:39 <tourist314159> Hi , what is the gsoc channel for haskell?
07:12:15 <lunabo> tourist314159: think it's #haskell-gsoc
07:13:37 <tourist314159> lunabo: Thanks!
07:14:57 <deltasquared> ClaudiusMaximus: just looking at that package you linked. it is pleasingly simple to read, looks like I may try this at some point (with caveat of portability and external modifications...)
07:15:52 <deltasquared> reminds me of when somebody here linked me to getHostName, I found that nice to read to (that had portability by way of ifdefs for different systems)
07:15:56 <deltasquared> *too
07:17:38 <deltasquared> I guess I find it nice to read because it's more familiar to my imperative ingrained brain, versus some arcane type stuff seen elsewhere... (*remembers the refined package and shudders*)
07:18:55 * Solonarv muses:
07:19:05 <Solonarv> @quote spj finest.imperative
07:19:05 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
07:20:20 <Solonarv> gah, where is that quote!
07:22:48 <deltasquared> Solonarv: remember bits of it?
07:25:46 <Solonarv> something along the lines of "Haskell is the world's finest imperative language"
07:29:30 <hpc> @quote faq
07:29:30 <lambdabot> cmccann says: @faq is it possible to find things Haskell can't do?  <lambdabot> The answer is: Yes! Haskell can do that.
07:31:11 <hpc> @quote best.imperative
07:31:11 <lambdabot> i says: agree that Haskell isn't the worlds best imperative language (despite how many simon's may disagree)
07:31:25 <hpc> bah - SPJ says: Haskell is the world's best imperative language.
07:33:39 <jollygood2> Solonarv, I used your To/FromJSON, and I also declared empty ToJSONKey/FromJSONKey definitions (minimal definition is nothing), and decoding/encoding file works, but I get [] around every key in json file. should I refine To/FromJSONKey instances, or what?
07:33:57 <jollygood2> encode $ M.fromList [("foo" :: Text, 1)]  =>  {"foo":1}
07:34:19 <jollygood2> encode $ M.fromList [("foo" :: (CI Text), 1)]  =>  [["foo",1]]
07:35:01 <Solonarv> that's probably because the default To/FromJSONKey instances don't do what you want (they don't know that they're getting something string-y)
07:36:30 <jollygood2> I just noticed the same for my own types
07:36:48 <Solonarv> I would recommend reading the docs on ToJSONKey
07:37:15 <jollygood2> I'm on it, just wasn't sure if that was the right place to look
07:50:02 <jollygood2> this did it.  toJSONKey = toJSONKeyText (T.toLower . CI.original)
07:51:11 <jollygood2> it's probably possible to make that generic
07:54:13 <Solonarv> no! not 'CI.original'!
07:54:21 <jollygood2> I lowered it
07:54:30 <jollygood2> and just figured foldedCase already does that
07:54:34 <Solonarv> also no!
07:54:41 <jollygood2> why?
07:54:49 <Solonarv> case-folding is more complicated than just lowering/uppering
07:55:01 <Solonarv> the function you want is 'CI.foldedCase'
07:55:17 <jollygood2> I said foldedCase above :P
07:55:36 <Solonarv> yes, but you didn't use it to define your instance!
07:55:59 <jollygood2> I didn't, I just found out about it
07:56:30 <Solonarv> fair enough
07:57:47 <deltasquared> ah, the joys of having to handle international text
07:57:49 <jollygood2> I don't think I can make it generic, though
07:57:57 <jollygood2> toJSONKeyText accepts Text
07:59:02 <deltasquared> I should go actually. have a good remainder-from-whatever-time-of-day-at-your-location everyone
07:59:10 <Solonarv> don't make it generic, then :P
07:59:33 <Solonarv> just writing an instance ToJSONKey (CI Text) is perfectly fine
07:59:40 <jollygood2> I'm curious, when wouldn't T.lowerCase do the same?
08:00:40 <Solonarv> very vaguely: some non-english letters
08:01:22 <jollygood2> I'm surprised that T.lowerCase doesn't handle that
08:02:07 * hackage hebrew-time 0.1.2 - Hebrew dates and prayer times.  https://hackage.haskell.org/package/hebrew-time-0.1.2 (MichaelSnoyman)
08:03:12 <Solonarv> imagine you have the German word "Straße" ("street"). in all-caps, that becomes "STRASSE". If you lower-case both of those strings, you get "straße" and "strasse" - not equal, even though they should be!
08:05:59 <Solonarv> % (T.toCaseFold "Straße", T.toCaseFold "STRASSE")
08:05:59 <yahb> Solonarv: ("strasse","strasse")
08:06:19 <jollygood2> Solonarv, interesting! now I'm curious how CI handles that
08:06:21 <Solonarv> % (T.toLower "Straße", T.toLower "STRASSE") --wrong!
08:06:22 <yahb> Solonarv: ("stra\223e","strasse")
08:06:51 <Solonarv> jollygood2: CI Text just delegates to Data.Text.toCaseFold
08:09:14 <blackandblue> hi haskellers
08:09:25 <blackandblue>  is it worth buying macbook for macOS? or linux is fine enough ?
08:10:32 <Solonarv> for purposes of Haskell development? I don't think macOS has any significant advantage over linux
08:12:32 <blackandblue> yes and daily usage
08:12:46 <c_wraith> daily usage is all about your preferences.
08:13:36 <Solonarv> (personally, I think Apple products are pretty much all overpriced, but perhaps you don't think so)
08:13:59 <blackandblue> yea they are expensive
08:13:59 <blackandblue> :(
08:15:11 <wroathe> They absolutely are overpriced. Unfortunately many shops won't pay their end user IT guys to maintain corporate Linux images :(
08:15:28 <wroathe> IT people*
08:16:46 <maerwald_> GHC runs fine on mac and linux
08:16:52 <maerwald_> windows is more complicated
08:18:18 <sm> wow, https://github.com/Lemmih/reanimate is cool
08:26:31 <hpc> nice
08:27:59 <blackandblue> nice
08:28:37 <blackandblue> what do you guys do for a living?
08:29:05 <jollygood2> is there a better prefix for non-total functions (like head, fromJust) than unsafe?
08:29:38 <dmwit> how about partial
08:29:38 <jollygood2> prelude doesn't use anything, so I guess there's no convention for this?
08:30:14 <dmwit> unsafe is the closest we have to a convention
08:30:17 <hpc> some other packages use "unsafe"
08:30:33 <hpc> because being partial comes with violating some other invariant the package relies on
08:40:24 <wroathe> What are people's thoughts on using String in a public facing library API? Is it a case where everyone should be using Text regardless of circumstance, or do people sometimes make allowances for compatibility when performance isn't critical?
08:40:50 <c_wraith> If the length isn't expected to be huge, it's basically irrelevant
08:41:04 <wroathe> Right now I'm leaning towards using String in the public API, but converting to and working with Text behind the scenes
08:41:22 <wroathe> For the thing I'm working on, which isn't performance critical
08:45:03 <hpc> i would probably have the api use Text, if i was already using it internally
08:45:30 <hpc> it's less code for your package, and if it's good for your code it's good for the code calling it
08:46:21 <c_wraith> I'm just tired of "String bad" and "Strict data fields good" cargo cult behavior.  (I got really annoyed looking at the internals of case-insensitive earlier)
08:46:52 <hpc> heh, that's fair
08:47:51 <jollygood2> c_wraith how large is a huge string?
08:48:05 <wroathe> I like the idea of deferring the need to learn about OverloadedStrings and Haskell string hell to another package that actually makes use of the performance gains of the other string types
08:48:18 <c_wraith> jollygood2: a few thousand characters.
08:48:39 <wroathe> (not that those are heavy things to learn)
08:48:53 <jollygood2> what about many very small strings? <10 characters
08:50:12 <jollygood2> say, Data.Map with tens of thousands of string keys. would you use Text there?
08:50:24 <c_wraith> with only tens of thousands?  probably string.
08:50:47 <c_wraith> If you're getting up into hundreds of millions, I'd look into something like SmallString
08:51:00 <jollygood2> I'm using text for the first time and I'm finding it very frustrating. doubly so after I figured out that some libraries basically just use string internally.. so using Text could actually be SLOWER
08:52:22 <maerwald> jollygood2: where?
08:52:25 <maerwald> did you benchmark?
08:52:50 <jollygood2> maewald, TagSoup converts everything to String internally
08:54:16 <monochrom> Yeah tagsoup predates Text.
08:54:44 <dmwit> perhaps backpack will save us!
08:55:13 <maerwald> jollygood2: I don't see how that correlates to a performance benchmark
08:55:18 <c_wraith> Text is not great as keys for a Map, though.  For small values, it has a lot of overhead.
08:55:24 <jollygood2> monochrom, why even offer Text interface then, though? if you're just going to convert it to a String
08:56:44 <monochrom> I don't know. FOSS people just like to write code.
08:57:38 <maerwald> surprisingly (or not) haskell is usually not about performance, nor correctness... and base reflects that
08:57:39 <monochrom> I mean I wasn't the one doing it so I don't know why that person did it. How does a neural network work again?
08:58:44 <maerwald> performance is hard anyway, moreso with laziness, so people tend to not care about it (and there are few resources about it)
08:59:30 <wroathe> maerwald: And if you need performance, it becomes a feature that you design and implement anyways
09:00:00 <maerwald> I don't know about that
09:02:23 <monochrom> Data.Text.Short may help for small values.
09:17:53 <fendor> how can i turn off the behavior of stack, ghc, cabal, etc.. to care bout the local .ghc.environment file?
09:20:25 <fen> not sure if this is sane; https://pastebin.com/i0uUqsYT
09:20:42 <fen> https://pastebin.com/raw/i0uUqsYT
09:20:59 <mightyby1e> Hello!  I'd like to announce the Compose NYC Call for Presentations.  http://www.composeconference.org/2019/cfp/  We're looking for talks covering just about any topic related to strongly typed functional programming languages.
09:21:22 <maerwald> fendor: ghc by default doesn't use any, unless you specify one: https://downloads.haskell.org/~ghc/master/users-guide/packages.html#package-environments
09:22:08 <monochrom> maerwald: But note the "Additionally, unless -hide-all-packages is specified" clause.
09:22:20 <EricTCartman> hi. it seems http://learnyouahaskell.com/modules contains a misprint. is the author here?
09:22:31 <maerwald> for cabal, you can use --write-ghc-environment-files=never
09:22:31 <fendor> hm, is the behaviour different if I use nix-shell?
09:22:52 <nyc> mightyby1e: Apart from my being generally friendly to functional and logic languages, being in the city, and the initials of my name being the same as the city, I don't know that I really have much to offer.
09:23:13 <mightyby1e> nyc: lol, nice
09:23:52 <mightyby1e> In that case, keep a look out for when tickets are available and you can come and learn more!
09:24:04 <fen> could the set function used in cobuild be bypassing some of the code?
09:24:43 <fen> maybe it makes sense, really cant tell...
09:25:01 <fendor_> maerwald, even without nix-shell, this happens: https://hastebin.com/tabicunuro.sql with ghc 8.4.4
09:25:41 <geekosaur> EricTCartman, the author of that has been missing for some years. Regrettably, as there's a lot of stuff that needs to be fixed / updated.
09:25:50 <maerwald> fendor_: delete the file
09:26:47 <EricTCartman> oh, that's unfortunate. thanks for the info
09:26:52 <nyc> mightyby1e: I could offer to do kernel hacking for FPL implementors interested in doing papers on operating system features useful to their language runtimes.
09:27:35 <fendor_> maerwald, yeah, I know, but the file is generated by an invocation of `cabal new-build` in install.hs. Can I just turn off this generation file?
09:27:53 <maerwald> fendor_: see my comment above
09:28:33 <fendor_> maerwald, right, thanks!
09:31:29 <gksato> Hi, I've been suspecting that the layout rule in the Language Report 2010 is buggy.
09:34:25 <gksato> Is "x = y where { y = z where z = 2 }" meant to stand for "x = y where { y = z where { z = 2 } } "?
09:34:55 <c_wraith>  ui
09:35:15 <c_wraith> err.  sorry.  Dropped food on keyboard
09:35:28 <Solonarv> gksato: yes, that's how it parses in my head
09:37:13 <c_wraith> there's nothing else it can parse (correctly) as
09:38:01 <fen_> also "loop" does not inline properly, the stream version loops indefinitely, but its easier to check the idea of cobuild on the stack version. s/stream/stack in the paste
09:38:36 <gksato> Solonarv: c_wraith: Exactly! and that's GHC 8.4.4 does. but the problem is Section 10.3 of haskell report 2010 doesn't do that
09:40:12 <gksato> it returns parse-error for closing the implicit brace with the explicit blace
09:41:31 <Solonarv> ooh, so ghc8.4.4 incorrectly produces a parse error?
09:41:49 <gksato> That's the other way round.
09:42:38 <wroathe> Dumb question: To use a MonadReader constraint, do you need to use FlexibleContexts? 
09:42:53 <c_wraith> If you want to depend on a specific type r, yes
09:42:57 <glguy> wroathe: Only if you're not using it with a type variable
09:43:01 <Solonarv> wroathe: you probably need it fairly often, yes
09:43:01 <wroathe> i.e. MonadReader Config m => m a
09:43:15 <wroathe> Got it. Thanks!
09:43:24 <glguy> you end up needing FlexibleContexts if you try to use mtl like an effect system hack
09:43:40 <gksato> GHC 8.4.4 correctly compiles the snippet, but the report says it should spit parse error, incorrectly in my opinion.
09:43:55 <glguy> You can avoid this by making a class specific to the problem you're solving instead of reusing MonadReader
09:44:53 <Solonarv> gksato: ooh, now it makes sense. There are probably other places where GHC is more permissive than the standard, even without any extensions!
09:47:00 <wroathe> glguy: Do you know of a library that does what your suggesting to solve a similar problem?
09:47:10 <wroathe> you're*
09:47:21 <glguy> A library for doing what?
09:48:04 <Solonarv> Effect systems? there's a handful of them, yes, but they tend to perform worse than mtl-style classes
09:48:04 <fen_> redfines monadreader...
09:48:06 <glguy> If your application has more than one type that provides a configuration you can have a class HasMyConfig, for example
09:48:52 <Solonarv> but a library for an mtl-style effect system doesn't make much sense - you don't need a library to write 'class MonadConfig m where getConfig :: m Config'
09:50:49 <wroathe> Solonarv: This is related to the question I asked earlier that you suggested I parameterize my API with type convertors for. I'm trying to thread an options ADT through a subset of the routines in my library.
09:51:15 <Solonarv> 'MonadReader Options m' seems sensible, then
09:51:53 <glguy> reusing MonadReader means nothing else can due to functional dependencies
09:52:51 <glguy> It saves defining the class but makes a bit more of a mess
09:57:17 <hpc> it'd be neat to have a monoid-do extension
09:57:31 <hpc> so we can get rid of those phantom types in blaze and such
09:57:50 <Solonarv> we already do, it's called RebindableSyntax :P
09:58:12 <hpc> oh right
09:59:28 <Solonarv> (>>) = (<>); m >>= k = m <> k m -- ;)
09:59:38 <fen_> thinking maybe cobuild is isomorphic to build somehow...
10:00:38 <Solonarv> or just replace 'do a; b; c' with  'fold [ a, b, c ]'
10:00:55 <Solonarv> you can even give an IsList instance to allow dropping the 'fold' !
10:01:49 <fen_> oh, there is a ; (forall s. s -> Maybe (a,s)) which shouldnt be there... 
10:02:10 <fen_> figured that this was the only viable thing of that type
10:02:17 <fen_> or at least, to replace the hidden s
10:02:18 <fen_> data CoChurch' f a = CoChurch' {runCoChurch' :: Set f => (CoChurch' f a->Maybe (a,CoChurch' f a)) -> f a}
10:02:51 <fen_> chuch hides the f a that fold is applied to, cochurch hides the state s that unfold is applied to
10:03:12 <fen_> but it doesnt hide it properly because it still appears in the function which runs that state
10:03:18 <fen_> the second argument to unfold
10:03:40 <jollygood2> are get and put in StateT MyState IO () atomic?
10:04:05 <c_wraith> that depends entirely on what MyState is
10:04:23 <fen_> that crazy looking Cochurch' thing replaces the state with itself forming a recursion, in an attempt to be like how undefined is the only valid instance of (forall s. s -> Maybe (a,s)) 
10:04:50 <fen_> where this results from trying to "hide" the type of `s' in the continuation that is a partially applied unfold for cobuild
10:05:01 <jollygood2> c_wraith, something like this.. data MyState = MyState LocalTime [Int] (Map Text SomeObject)
10:05:44 <Solonarv> jollygood2: StateT S IO a behaves not-nicely in the presence of exceptions, I would use ReaderT (MutRef S) IO a instead
10:05:59 <Solonarv> (where MutRef is IORef, or MVar, or TVar, or perhaps something else)
10:06:40 <c_wraith> I mean, it's kind of irrelevant whether it's atomic
10:06:48 <c_wraith> As you can't observe partial writes
10:07:02 <Solonarv> true
10:07:18 <Solonarv> so in that sense they are "atomic"
10:07:30 <jollygood2> not sure I understand.d why can't you observe partial writes?
10:07:49 <wroathe> Solonarv: Are you talking about async exceptions, or just all exceptions?
10:08:05 <wroathe> Solonarv: For that not-nice behavior you mentioned
10:08:16 <jollygood2> Solonarv, in what way does it behave badly with exceptions?
10:08:25 <jollygood2> yeah I'm curious too
10:08:27 <Solonarv> all exceptions; async exceptions just mean you can never correctly "assume no exceptions occur"
10:09:20 <wroathe> Solonarv: You don't happen to have a source I could read more about this in, do you?
10:09:37 <Solonarv> I'm looking for one
10:09:38 <c_wraith> jollygood2: the state contains no mutable values.  StateT doesn't modify anything, it just passes new values down the line.
10:11:04 <wroathe> c_wraith: In that sense the notion of it being "state" is somewhat misleading
10:11:11 <cocreature> you also can’t really use State s IO a in a multi-threaded context and share the state
10:11:35 <jollygood2> c_wraith, I know, which sounds linear, so I'm just having a hard time wrapping my mind what that means when I use something like async's mapConcurrently
10:11:59 <Solonarv> https://www.fpcomplete.com/blog/2017/06/tale-of-two-brackets for a blog post; it's linked from the documentation of https://hackage.haskell.org/package/unliftio
10:13:02 <cocreature> jollygood2: there is a reason mapConcurrently is limited to IO :)
10:13:09 <jollygood2> if multiple threads are writting to State's Data.Map.Map, what happens at the end? are all the writes contained?
10:13:21 <c_wraith> jollygood2: you can't "write" to Data.Map.Map
10:13:33 <c_wraith> jollygood2: you can only create new ones that are like the previous one, but with a difference
10:13:43 <jollygood2> cocreature, I have StateT MyState IO ()
10:13:59 <Solonarv> you can't do anything like 'runStateT $ forkIO someStateT'
10:14:11 <jollygood2> c_wraith, i meant "modifying" map in State
10:14:38 <cocreature> jollygood2: look at the type of mapConcurrently. it forces you to produce something of type IO b, not something of type StateT MyState IO ()
10:14:54 <Solonarv> instead you end up with something like 'forkIO $ runStateT someStateT'; each thread essentially has its own state that is not shared with other threads
10:15:03 <jollygood2> hmm.. you're right, it wouldn't even compile
10:15:08 <Solonarv> (this still applies if you use async's higher-level functions instead of forkIO directly)
10:15:31 <cocreature> if you want actual shared state that you can access from multiple threads stuff it in an MVar, TVar, IORef, … as Solonarv suggested before
10:17:06 <wroathe> Solonarv: Thanks for the link
10:17:25 <jollygood2> which one would be most suitable? in case of a shared value being a Map, where multiple threads are reading from map, and modifying reference with new map
10:18:08 <monochrom> I use atomicModifyIORef for that.
10:19:07 * hackage shake 0.17.6 - Build system library, like Make, but more accurate dependencies.  https://hackage.haskell.org/package/shake-0.17.6 (NeilMitchell)
10:19:10 <hpc> TVar, probably
10:19:39 <Solonarv> to complete the circle, I must now recommend MVar.
10:19:44 <hpc> atomicModifyIORef works too, but it's more "accidental" than being something that IORef was designed to support
10:20:22 <hpc> i like MVar, but nothing here stands out as indicating you would want locking
10:20:28 <hpc> but maybe that's better than TVar
10:20:41 <monochrom> Hrm, I should change my opinion to favour TVar then.
10:20:46 <jollygood2> I never used ReaderT, I guess ReaderT combined with some mutable reference would mean I don't have to pass reference around manually? (in the spirit of StateT)
10:21:24 <Solonarv> exactly
10:21:34 <monochrom> Because I don't recommend MVar for this because it's the same reason: MVar is a message box, incidentally can emulate IORef.
10:22:23 <cocreature> I mostly default to stm stuff, i.e., TVar in this case since it’s easy to get right, easy to extend if requirements become more complex and usually it’s fast enough
10:22:29 <c_wraith> Sadly, MVar is the only option if you want pessimistic locking
10:23:02 <c_wraith> So, whatever it was designed for, it's what you've got.
10:23:34 <monochrom> Yeah I would use MVar as lock if I were to write the traditional imperative "acquire lock; work on 10 IORefs; release lock" critical section.
10:24:11 <monochrom> But we have STM now.
10:24:29 <c_wraith> Which is still optimistic locking
10:24:46 <c_wraith> If you have high contention with slow updates, pessimistic locking performs a lot better.
10:29:21 <monochrom> Also if I have a worker thread that takes orders from other threads and I believe that the queue length is mostly <=1. Because MVar is exactly that.
10:30:14 <cads> > let fiblist:: Int -> [[Int]]; fiblist 0 = [[]]; fiblist 1 = [[]]; fiblist n = (map ((n-1):) $ fiblist (n-2)) ++ fiblist (n-1); in fiblist 5
10:30:16 <lambdabot>  [[4,2],[4,1],[4],[3,1],[3],[2],[1],[]]
10:32:27 <jollygood2> to give a bit more context, I am scraping ads site concurrently, and state has two elements: 1) a list of ads I visited in the past (that I no longer want to visit again). every visited ad is added to this list. 2) a Map with name/telephone number of the people who created all the ads I visited, which helps me me determine if ad is from a company or a person. I wanted to use a database initially, but data I am expecting is smal
10:33:12 <jollygood2> and I'm loading that state at the program's beginning, and writing it back to the file again at the end
10:38:36 <cads> Consider a n x 1 board with square cells. The fiblist function creates a list of all the ways we can place dominos on that board such that the dominos do not overlap (see fig 1. https://imgur.com/a/BJTede6)
10:40:12 <cads> In the function's output, we have a list of lists, where each sublist gives us the left coordinate of a domino. Fiblist also includes the empty configuration, because it makes the function very easy to write
10:42:17 <cads> I'm concerned that - despite being very easy to write - the function may not be as efficient as it could be. It uses a lot of list concatenation, and under naive recursive it has a branching factor of 2.
10:43:44 <Solonarv> Probably true (but we can't see your code!)
10:43:53 <Solonarv> oh wait you posted it a bit further up
10:44:06 <cads> that's my code, made friendly for lambdabot ^^
10:44:49 <cads> I tried create a memoized version of this, and somehow managed to make it buggy; ideally I would leave the function as is, and ghc would properly memoize or otherwise optimize it during compilation. Does anyone know if that would happen?
10:45:21 <monochrom> No because you have a parameter.
10:45:38 <Solonarv> you can rewrite it to use 'fix' explicitly:
10:47:31 <Solonarv> > let fiblist :: Int -> [[Int]]; fiblist = fix \self n -> if n <= 1 then [[]] else map ((n-1):) (self (n-2) ++ self (n-1)); in fiblist 5
10:47:33 <lambdabot>  <hint>:1:46: error: parse error on input ‘\’
10:47:41 <Solonarv> > let fiblist :: Int -> [[Int]]; fiblist = fix $ \self n -> if n <= 1 then [[]] else map ((n-1):) (self (n-2) ++ self (n-1)); in fiblist 5
10:47:43 <lambdabot>  [[4,2],[4,2,1],[4,2,1],[4,3,1],[4,3,1],[4,3,2],[4,3,2,1],[4,3,2,1]]
10:47:52 <dmwit> Yes this is inefficient; it doesn't share work in the two subcalls.
10:48:12 <dmwit> You can fix this with the usual zip`ap`tail trick to switch it away from being a function to being a list of the function's outputs.
10:48:26 <Solonarv> > let fiblist :: Int -> [[Int]]; fiblist = fix $ \self n -> if n <= 1 then [[]] else map ((n-1):) (self (n-2)) ++ self (n-1); in fiblist 5 -- whoops! fixed
10:48:28 <lambdabot>  [[4,2],[4,1],[4],[3,1],[3],[2],[1],[]]
10:48:49 <Solonarv> then you can replace 'fix' with 'memoFix' and get memoization "for free"
10:49:20 <dmwit> > let fiblistlist = [[]] : [[]] : zipWith3 (\n l1 l2 -> map ((n-1):) (l1 ++ l2)) [0..] fiblistlist (tail fiblistlist) in fiblistlist
10:49:22 <lambdabot>  [[[]],[[]],[[-1],[-1]],[[0],[0,-1],[0,-1]],[[1,-1],[1,-1],[1,0],[1,0,-1],[1,...
10:49:26 <dmwit> nailed it
10:52:03 <rotaerk> https://store.steampowered.com/app/814870/Monads <3
10:52:09 <rotaerk> I wonder if this is written *in* haskell
10:52:17 <cads> I wonder why ghc wouldn't just say "hey, it looks like this would end making a whole lot of identical calls to fiblist, lemme just memoize a little here without telling anyone"
10:52:30 <cads> end up*
10:52:58 <dmwit> Because space/time tradeoffs are really hard to make correctly. So it leaves it to the programmer as much as it can.
10:53:33 <Solonarv> rotaerk: that seems to be a philosophical monad, not a CT/CS one
10:53:47 <dyl> dmwit: Zip`ap`tail? The Aztec god of consecutive numbers? 
10:53:47 <Solonarv> see https://en.wikipedia.org/wiki/Monad
10:54:00 <Solonarv> @quote zip.ap.tail
10:54:00 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
10:54:09 <Solonarv> eyyy
10:54:12 <monochrom> rotaerk: "The title means the fundamental solitude of a human being who can never fully understand others."
10:54:33 <dyl> @quote confluence 
10:54:33 <lambdabot> No quotes match. You type like i drive.
10:54:44 <dyl> I guess lambdabot doesn’t understand confluence either.
10:54:53 <dmwit> > let fiblistlist = [[]] : [[]] : zipWith3 (\n l1 l2 -> map (n:) l1 ++ l2) [1..] fiblistlist (tail fiblistlist) in fiblistlist
10:54:55 <lambdabot>  [[[]],[[]],[[1],[]],[[2],[1],[]],[[3,1],[3],[2],[1],[]],[[4,2],[4,1],[4],[3,...
10:55:03 <rotaerk> but one of the screenshots has dialog that says "Enemy is everywhere as long as the Haskells are present."
10:55:30 <dmwit> > let fiblistlist = [[]] : [[]] : zipWith3 (\n l1 l2 -> map (n:) l1 ++ l2) [1..] fiblistlist (tail fiblistlist) in fiblistlist !! 5
10:55:32 <lambdabot>  [[4,2],[4,1],[4],[3,1],[3],[2],[1],[]]
10:55:43 <monochrom> Wait what?! Haha
10:55:47 <rotaerk> lol
10:57:06 <dmwit> cads: ^
10:57:49 <monochrom> In fact Oleg was complaining that GHC was memoizing more than he wanted.
10:59:55 <wroathe> So apparently GHC doesn't like ad-hoc polymorphism with fields of ADTs? data Options = Options { envToConfig :: MonadReader Options m => [String] -> [(String, String)] -> m ConfigNode }
11:00:09 <wroathe> It's telling me that m is not in scope, which I'm guessing there's good reason for
11:00:20 <cads> so we have 100 percent, "put our hand in a the fire" certitude that GHC will not - in this case - see that the memoized version utterly dominates the naive version. Not that I doubt, but would it be hard to see what it actually comes up with? That is, would it require reading some very unreadable code?
11:00:28 <dmwit> The usual way is `data Options m = Options { envToConfig :: ... -> m ConfigNode }`.
11:00:37 <dyl> ^ 
11:00:41 <dmwit> Then put the `MonadReader Options m` constraint on functions that use `Options m` and need it.
11:00:45 <dyl> I would generally suggest avoiding —
11:00:51 <dyl> Yeah, what dmwit said.
11:01:03 <dyl> Putting constraints on constructors is generally an anti pattern.
11:01:24 <dyl> It’s a really pernicious habit to break, if you succeed, let me know how.
11:01:24 <dmwit> Another possibility is `data Options = Options { envToConfig :: forall m. MonadReader Options m => ... -> m ConfigNode }` but then you might as well just use `Reader` instead of `MonadReader`.
11:01:53 <wroathe> Hrm, removing the constraint still barks at me for m
11:02:01 <wroathe> data Options = Options { envToConfig :: [String] -> [(String, String)] -> m ConfigNode }
11:02:04 <monochrom> m is really not in scope.
11:02:05 <dmwit> wroathe: I didn't *just* remove the constraint.
11:02:08 <dyl> You still need to quantify the data type over m. 
11:02:11 <dmwit> wroathe: I *also* put `m` to the left of the equality.
11:02:16 <wroathe> Oh, I see
11:02:31 <wroathe> lol, duh 
11:02:42 <wroathe> thanks dmwit 
11:03:03 <wroathe> And yeah, having the constraint on the actual function that needs the Options m makes way more sense
11:08:22 <vides> hey guys, I'm on a world new to me with some ongoing task, and I need to ask for some help :)
11:09:28 <vides> basically, I have a REST web server, that receives a POST with a JSON description of a problem, and then can answer to GET requests with a JSON description of the solution
11:09:49 <vides> but it has to be async, as the problems can take extremely long to solve
11:10:40 <vides> so the server responds to the POST with an id, and then the client can do a GET with the previously given id any time he wants, and receive a "not yet" or a "here's the answer"
11:11:50 <vides> my problem is, I have no idea how to do the async and the storage of problems for later querying
11:12:23 <vides> databases? micro-services? State monads? I seem to have many possible answers and I don't know which one applies and how to do it
11:12:27 <vides> any advise?
11:13:40 <wroathe> vides: Generally you'd persist the long running process and generate a unique task id, then respond with a 202 Accepted and a header or body that contains that task id
11:14:28 <wroathe> vides: Then the client would provide that task id on subsequent requests and you'd look up the process state in your datastore
11:16:13 <wroathe> If you want to be fancy you can use HATEOAS and respond with the URL they need to hit to check on the state of the process
11:17:49 <wroathe> vides: Generally the complexity of what you're trying to do will very greatly depending on use case
11:17:52 <wroathe> vary*
11:20:37 * hackage shower 0.1 - Clean up the formatting of 'show' output  https://hackage.haskell.org/package/shower-0.1 (int_index)
11:25:53 <vides> wroathe, I'm just learning Haskell, so it doesn't have to be a full-blown fancy website
11:26:43 <vides> so I need to learn how to run a second process and persist it first I think
11:27:17 <wroathe> vides: I think you're taking on learning too many new things at once
11:28:20 <dmwit> Are you having trouble with the client code or server code?
11:29:02 <vides> for sure. Until yesterday I've never done a website before, nor Docker for that matter :D
11:29:41 <wroathe> Hahahaha. I also like to play on hard mode.
11:30:02 <vides> I already have a server using servant that parses all JSON input and returns meaningless JSON solutions
11:31:23 <dyl> It might be a good exercise to develop a little worker pool binary independently :) 
11:31:43 <dyl> (In isolation from the web request stuff.) 
11:31:52 <vides> dyl, what do you mean? What's that?
11:32:06 <wroathe> I think I might have misinterpreted what he was trying to do. It sounds like he just wants to set up persistence in general.
11:32:09 <dyl> (It’s also probably best to be able to restart the front end web server independently from the worker pool.)  
11:32:33 <dyl> I’m saying to make a little service you can send a “job” in some form, which then performs it asynchronously and allows polling for status.
11:32:37 <wroathe> I assumed he was asking about background jobs
11:32:54 <vides> dyl yes, that sounds just like what I wanted
11:33:15 <dyl> I’m saying try to do that in isolation with simpler inputs. 
11:33:42 <dyl> For a toy problem that wouldn’t always finish immediately, how about factoring large primes? 
11:33:54 <dmwit> Factoring primes is v. v. easy.
11:33:55 <dyl> Sorry factoring large integers*
11:33:59 <dmwit> yeah =)
11:34:01 <dyl> ;) 
11:34:06 <vides> I don't think need to write stuff to a database and keep things persistent (yet, but I may need that later), all data can just die once the server dies, who cares
11:34:19 <vides> dyl: I'm doing something worse: knapsack :D
11:34:21 <dyl> So a little server you send a large integer, and it returns a token you can use to query status/result. 
11:35:01 <dyl> hpc monochrom: we’ve come full circle on durability ;) 
11:35:49 <vides> so yes, I need that little service to send jobs to, that we can poll for status
11:35:55 <vides> how to do that? :D
11:35:59 <dyl> vides: still, I would consider the web server a front end, and the worker service a back end.
11:36:12 <dyl> The question becomes how do they communicate, and there are a few good answers to that. 
11:36:26 <dyl> I would pick a well known serialization format/wire protocol and use sockets. 
11:36:37 <dyl> You could also use a MQ but that’s overkill.
11:36:54 <dyl> But then you can start seeing fun little do Madison’s of the 
11:36:59 <dyl> expansions* of the project.
11:37:12 <dyl> (e.g. n web servers, m worker servers)
11:37:57 <vides> (silently consulting MQ with the oracle now)
11:38:38 <dyl> MQ is overkill for a first pass.
11:38:52 <dyl> It’s a sledgehammer for a nail.
11:38:58 <vides> question, for the backend and the frontend, how are they divided in the code? Two different projects for two different Docker containers? (I'm also new to docker)
11:39:29 <dyl> I don’t use docker, but you could see them as distinct containers. 
11:39:55 <dmwit> "all data can just die once the server dies, who cares" answer: your client cares, because he asks the server, "what was the answer to question 1?" and you say "no problem, here's the answer to question 1" and it's not the answer to the question he asked.
11:40:14 <dyl> ^ easy fix: use UUIDs. 
11:40:15 <vides> or is there a way to keep both services (processes?) in the same executable?
11:40:17 <wroathe> Divide and conquer. Build the backend that can handle jobs first, then worry about the front end and docker later
11:40:34 <dyl> vides you could but you probably wouldn’t want to. 
11:40:41 <dyl> Single responsibility principle! 
11:41:20 <dmwit> If there's a front-end and a backend, why not just expose the backend?
11:41:21 <vides> dmwit, it's a toy exercise, I'm aware of the flaws a client would hate me for, but one step at a time :P
11:41:40 <vides> dyl, thumbs up for the SRP!
11:41:57 <dyl> Consider that keeping them separate will also facilitate testing.
11:42:24 <vides> stupid question, so I should start creating another stack project, right?
11:42:42 <dyl> You could also add a new executable to your existing one, if you want to share code. 
11:42:46 <dyl> But yeah otherwise. 
11:43:03 <vides> hmm... that's a good one, how to add the executable in stack?
11:43:14 <dyl> They probably won’t really share much dependency wise anyhow.
11:43:41 <dyl> I once again do not know precisely, I don’t use stack much :p. 
11:43:51 <vides> they might share some servant API stuff I think
11:43:55 <dyl> But I know it’s pretty straightforward. Look for the current executable and just add another like it.
11:44:17 <MarcelineVQ> dyl: it's not really different, all that sort of thing goes in the cabal file
11:44:41 <wroathe> vides: Is this your first FP language?
11:44:59 <vides> wroathe, yes, sort of
11:45:32 <vides> I was fluent once in Standard ML for purely academical purposes, never did any real life software with it, and that was over more than a year ago
11:46:24 <vides> but nevermind FP stuff, I'm not scared of that, the internet is way harder to me
11:46:27 <dyl> Ahhh the Smell of New Jersey.
11:46:33 <dyl> (SMLNJ)
11:46:50 <vides> hehe
11:47:11 <vides> so back to the topic, how to deal with stack and multiple services-executables?
11:48:27 <vides> then I need to make them communicate and make the whole knapsack solving async
11:48:36 <wroathe> vides: Rather than worry about Stack, Docker, etc I'd suggest just building the backend component as a one-off cabal project. Once you've got that working and you've made the decisions about how you're going to persist your jobs (memory, file, db, network service) you can generalize to a stack project with multiple executables
11:48:54 <vides> (I take library recommendations or good links to read from you)
11:49:22 <vides> wroathe, I take that advise :)
11:51:04 <wroathe> vides: You can even solve the persistence problem independently of the network problem and defer dealing with Servant and HTTP until the next phase
11:51:55 <vides> wroathe, I'm in for that. I was just thinking about how to keep track of the open problems and their solutions, without, you know, mutation
11:52:34 <vides> (and then, how to launch solvers async...)
11:53:13 <Solonarv> mutation is allowed! and is actually the right approach here, I think
11:56:53 <vides> Solonarv, how's that?
11:58:05 <Solonarv> % how is what? how is mutation allowed?
11:58:06 <yahb> Solonarv: ; <interactive>:82:38: error: parse error (possibly incorrect indentation or mismatched brackets)
11:59:05 <vides> Hmmm... I'm imagining how it can be allowed, but I'm not sure. Also, why's it the right approach?
11:59:41 <Solonarv> the first hint: you must work in IO (or some other context, but most commonly it's IO)
12:00:18 <fen> yeah, pretty sure cobuild is not possibe
12:01:18 <fen> slowly getting through the list of code that shouldnt be written!
12:01:29 <fen> might end up with an alright library
12:02:46 <fen> "and heres why this crazy idea you might have doesnt work" said no paid teacher ever
12:04:43 <vides> I'm reading about Marlow's async library, may that help with the super long solver I need to launch asynchronously?
12:05:45 <Solonarv> if you're okay with running the solver in the same process, yes!
12:06:50 <monochrom> "super long" is informationless unless you compare it to, e.g., next time you reboot, next time powr loss, etc.
12:07:31 <monochrom> As Data said in a movie, 4.5 seconds felt like eternity for him.
12:08:10 <Solonarv> indeed
12:08:18 <hpc> Solonarv: no, that's stargate
12:08:25 <hpc> :D
12:08:31 <wroathe> vides: If you've got requests coming in that are scoped to new threads, where will you store the problems you eventually want to solve?
12:08:41 <hodapp> monochrom is thinking of Brian Eno's reflections on writing the Windows 95 startup sound
12:09:53 <Solonarv> the straightforward solution: every time you get a request, 'async' a fresh thread and stick all the threads (running and finished) into some long-lived mutable map
12:11:25 <wroathe> Solonarv: How will his solver access that map?
12:11:37 <Solonarv> the solver doesn't access that map
12:11:57 <MarcelineVQ> vides: it's worthwhile reading his book on the subject, along the way you'll learn how to parallelise solvers and to invent async yourself and other useful things: (just scrol down here) https://learning.oreilly.com/library/view/parallel-and-concurrent/9781449335939/
12:12:06 <vides> my goal for now is just that it works, as I said, until yesterday I've never done anything web related anyway :P
12:12:08 <wroathe> Solonarv: Oh, I see
12:14:26 <platz> I haven't really seen folks using Stratigies much, but they seem cool.
12:14:51 <vides> are async threads lightweight? I mean, if I make tons of requests, I'm not sure about creating tons of threads
12:14:56 <platz> I think it's more just that it's really hard to find parallelizeable cpu-bound workloads
12:15:01 <MarcelineVQ> vides: very very light
12:15:04 <Solonarv> they're fairly lightweight, yes
12:15:11 <Solonarv> certainly not as heavy as OS threads!
12:15:21 <vides> anyway, Solonarv, how to work with that Map?
12:15:35 <Solonarv> I'll write up some pseudocode
12:31:20 <dyl> hodapp: have you ever listened to the windows 95 startup sound slowed down 4000x?
12:31:42 <dyl> https://youtu.be/BnoX3E2WFcc
12:31:50 <hodapp> dyl: did my time already with Windows 95 slowdowns, thanks
12:34:16 <YottaiQ> Hey guys please read this from Nicaragua... https://pastebin.com/xEQXq9BN
12:34:24 <vides> dyl, you made my day :D
12:34:38 --- mode: ChanServ set +o monochrom
12:34:42 --- mode: monochrom set +b *!*@38.132.120.71
12:34:42 --- kick: YottaiQ was kicked by monochrom (YottaiQ)
12:34:48 --- mode: monochrom set -o monochrom
12:35:44 <fen> dyl: does that use this? https://en.wikipedia.org/wiki/Gabor%E2%80%93Wigner_transform
12:37:11 <fen> some kind of instantaneous frequency? https://en.wikipedia.org/wiki/Wigner_distribution_function
12:38:11 <fen> oh, thought of how you could view a probability distribution for lamda terms as soft membership for fuzzy functional programming
12:39:03 <fen> and then there would be correlation functions and stuff, like an integrated infinitesimal markov process, maybe with a steady state
12:40:13 <fen> some kind of mean field stochastic calculus 
12:41:38 <fen> not sure about conserved quantities... nice to have a tangent bundle to take sections of!
12:43:35 <dmwit> monochrom: Now you have made me wonder how often Data had to reboot to work out driver issues.
12:45:33 <monochrom> haha
12:51:38 <fendor> does cabal have a pendant to stack install on windows? cabal-new-install does not seem to work on windows
12:51:41 <heath> https://github.com/steshaw/fsharp-journal/blob/master/F%23%20Journal%20allocationless%20programming.htm
12:51:53 <heath> "Allocationless programming on .NET"
12:55:25 <Solonarv> vides: https://gist.github.com/Solonarv/da6401e780b71e7893117be2487a5f82
12:55:43 <M2tias> heath: that's not very readable :D
12:55:58 <Solonarv> there's a bunch of bikeshedding you could do here and I didn't write this code against any existing server framework, but hopefully you get the general idea
12:56:02 <byorgey> fendor: cabal does not use stack at all.
12:56:13 <Solonarv> byorgey: that wasn't the question
12:57:38 <Solonarv> fendor: see https://github.com/haskell/cabal/issues/5748, as well as https://github.com/haskell/cabal/pull/5684 and https://github.com/haskell/cabal/issues/5837
12:58:12 <Solonarv> TL;DR v2-install wants to symlink executables, but symlinking on windows is iffy
12:58:24 <vides> Solonarv, on it now, thanks a lot!!
12:59:51 <fendor> Solonarv, thanks for the links! is there an option to copy maybe?
13:00:27 <Solonarv> fendor: that's what #5837 is about
13:00:43 <fendor> Solonarv, ok, will read before furhter questions
13:03:07 * hackage keycloak-hs 0.0.0.4 -   https://hackage.haskell.org/package/keycloak-hs-0.0.0.4 (CorentinDupont)
13:05:37 * hackage smallcheck-series 0.6.1 - Extra SmallCheck series and utilities  https://hackage.haskell.org/package/smallcheck-series-0.6.1 (jdnavarro)
13:09:53 <Solonarv> vides: btw, if you have any questions about the gist I posted, ask away
13:13:21 <vides> Solonarv, I just understood what you're doing there, it's perfect :D
13:13:22 <Phyx-> Symlinks on any modern version of Windows is fine. besides, it can easily detect if the appropriate permissions are available before it does so
13:13:53 <Solonarv> cabal v2-install really should not require elevated permissions to work!
13:14:04 <vides> Of course, I'm totally new to TVars and STM, I've only superficially read about it, so there's a lot of stuff I don't know, but I get the idea :)
13:14:40 <Phyx-> and symlinks does not require elevation to work
13:14:43 <vides> Now I'm going to try to adapt that into my working code, but on the meantime I'm just curious, how to achieve the same with no mutation?
13:14:57 <fendor> Solonarv, yeah, that is kind of ridiculous
13:15:00 <Solonarv> they do on my (win8) laptop!
13:15:10 <Phyx-> and so it won't use it for you!
13:15:58 <Solonarv> currently it does (well, tries and fails), because that behavior isn't implemented yet :/
13:16:04 <trcc> So john de goes posted that IO is referential transparent. https://twitter.com/jdegoes/status/1091007568552574976. I cannot understand why. Can someone help me understand it?
13:16:06 <Phyx-> the key point is that it should be "auto", it detects when you're using a configuration that supports it without admin rights, and if not uses the copy method for those that don't
13:16:21 <trcc> my issue is with e.g. this example: https://twitter.com/jdegoes/status/1096404417094475776
13:16:28 <dminuoso> trcc: An action `IO String` can be evaluated many times, one time or never.
13:16:30 <Phyx-> Solonarv: and that's why it's not merged. no use in speculating then is there..
13:16:36 <dminuoso> trcc: Evaluating an action does not execute its effect.
13:17:08 <trcc> dminuoso: when is its effect executed?
13:17:21 <dmwit> Only when it is discovered as a subterm of main by the runtime system.
13:17:36 <trcc> but then all haskell functions are referential transparent?
13:17:37 <Solonarv> trcc: a useful analogy is to think of 'IO a' as a "a series of steps which will produce an 'a'"
13:17:42 <dmwit> trcc: Correct.
13:17:43 <dminuoso> trcc: Correct!
13:17:52 <dmwit> trcc: Only the runtime system itself does opaque things.
13:17:57 <dminuoso> trcc: That's one of the really useful properties of Haskell. :)
13:17:58 <Solonarv> correct! (ignoring unsagePerformIO and the like)
13:18:51 <dmwit> (Actually, there is one more spot of referential non-transparency. But it's so dumb that nobody cares.)
13:19:05 <jackdk> if you know OO, consider the "Command Pattern" - http://wiki.c2.com/?CommandPattern .
13:19:09 <jackdk> It's similar
13:19:09 <Ariakenom> dmwit: did you mean something by "opaque" in opposition to referentially transparent
13:19:16 <dmwit> yes
13:19:28 <dmwit> I meant "in opposition to referentially transparent".
13:19:42 <trcc> okay let me dig a bit deeper to understand this.. I thought referential transparency was, that a function given the same input, will return the same output. Take readfile for example. If you run the function at t 0, then it might have the content "abc". But if you evaluate it at time 100, then it might have the content "def". So the input to the function is the file name, but the output is most definitely different?!
13:19:51 <dminuoso> trcc: readfile is not a function!
13:20:01 <dminuoso> Well.
13:20:02 <dmwit> trcc: But readFile never, ever returns "abc".
13:20:10 <trcc> it returns IO String probably
13:20:11 <dminuoso> trcc: readfile returns an abstract description of an actino.
13:20:15 <dmwit> trcc: It only ever returns an IO action which says to read a file, and it's always the same instruction to read that same file.
13:20:38 <jackdk> the result from calling `readFile "foo"` is always the same, but when the runtime system performs the action it might do different things
13:20:47 <dmwit> trcc: It is up to the runtime system to interpret that action, see that it has asked to read a file, and *actually read it*.
13:20:50 <dminuoso> trcc: Think of `IO Something` as a piece of paper that has some instructions inscribed for the runtime. If the runtime ever executed those instructions, it would produce a result of type Sometype.
13:21:03 <dminuoso> trcc: Evaluating the `IO Something` amounts to figuring out what that paper says.
13:21:39 <dminuoso> trcc: `IO String` contains a string just as much as `/bin/ls` contains a list of files and directories.
13:22:06 <trcc> so I guess that readfile in whatever language is referential transparent then?
13:22:16 <dminuoso> trcc: In haskell it is.
13:22:21 <dminuoso> % :t readFile
13:22:21 <yahb> dminuoso: FilePath -> IO String
13:22:33 <monochrom> IO String is not String.
13:22:41 <dminuoso> readFile "/foo/bar" will *always* produce the same effect.
13:22:45 <monochrom> "x :: String" promises that it's the same string every time.
13:22:57 <trcc> ah yes, I get that monochrom
13:23:04 <Solonarv> dmwit: what's the other spot?
13:23:13 <monochrom> "y :: IO String" promises that it is the same program every time.
13:23:16 <trcc> dminuoso: so evaluating vs execution isss?
13:23:27 <dmwit> Solonarv: partial pattern matches in do syntax produce an error referencing the line number on which they failed
13:23:39 <dminuoso> trcc: It's more like `IO String` is not what you think it is.
13:23:54 <dminuoso> trcc: It's a set of runtime instructions.
13:23:54 <dmwit> Solonarv: You can observe this in pure code with Either (whose `fail` is `Left`).
13:24:24 <trcc> dminuoso: but that is the same for c, C++ and so forth, right?
13:24:28 <dmwit> Solonarv: So inlining a reference could change the line number, hence change the value produced...
13:24:29 <dminuoso> trcc: No.
13:24:35 <Solonarv> trcc: using the "IO String = series of instructions" analogy: "evaluate = figure out what the instructions are", "execute = actually perform these instructions"
13:24:44 <Ariakenom> dmwit: interesting
13:25:07 <trcc> So in execution it is not referential transparent, but in evaluation it is?
13:25:12 <dminuoso> trcc: Correct.
13:25:26 <dminuoso> trcc: You can use the pseq primitive to force evaluation of a term in Haskell.
13:25:48 <trcc> and evaluation happens when compiling the program?
13:25:54 <koz_> trcc: The easiest way to think about it (at least for me) is that 'IO String' is 'the code for a program which, when executed, gives you some string, while doing some other stuff'.
13:25:55 <dmwit> trcc: You can't get your hands on the execution from within Haskell, so "in execution it is not referentially transparent" is a bit weird as there are no references to see through any more.
13:26:01 <dminuoso> % import GHC.Conc.Sync (pseq)
13:26:02 <yahb> dminuoso: 
13:26:06 <dminuoso> % exitFailure `pseq` ()
13:26:07 <yahb> dminuoso: ; <interactive>:85:1: error:; * Variable not in scope: exitFailure; * Perhaps you meant `Q.expectFailure' (imported from Test.QuickCheck)
13:26:18 <dminuoso> % import System.Exit
13:26:18 <yahb> dminuoso: 
13:26:20 <dminuoso> % exitFailure `pseq` ()
13:26:21 <yahb> dminuoso: ()
13:26:29 <dminuoso> % :t exitFailure
13:26:29 <yahb> dminuoso: IO a
13:26:55 <koz_> trcc: If you want a better explanation of the whole IO thing, I recommend the SPJ paper on Lazy Functional State Threads or something.
13:27:00 <koz_> (I forget the exact title)
13:27:01 <dminuoso> trcc: ^- here I forced the evaluation of the `exitFailure` action. It clearly didn't terminate the GHCi session yahb is running.
13:28:22 <dminuoso> (Here you need to accept that pseq is somehow magical. You can trust that it evaluates the first argument and then returns the second)
13:28:25 <trcc> hmm thank you all. Let me think a bit.. MIght get back with more heh
13:30:07 <trcc> I think I need to read up a bit on evaluation vs execution. Becase I do not understand why C is not the same thing. ReadFile "filename" will also also always read the file with "filename"... But I will try to look into that paper
13:30:21 <dminuoso> trcc: `readFile "filename"` does not read any file.
13:30:28 <trcc> in execution it does
13:30:29 <jackdk> @koz_ I think you remembered the title perfectly: https://www.microsoft.com/en-us/research/wp-content/uploads/1994/06/lazy-functional-state-threads.pdf
13:30:29 <lambdabot> Unknown command, try @list
13:30:33 <dminuoso> trcc: yes but thats irrelevant
13:30:38 <jackdk> bah I forgot this is IRC
13:30:42 <dminuoso> trcc: `readFile "filename"` constructs an *action*. a series of instructions.
13:31:04 <dminuoso> trcc: every time you evalute `readfile "filename"` it constructs the same action. the same series of instructions.
13:31:06 <koz_> jackdk: Woo!
13:31:11 <dminuoso> and constructing that action has no effect on the real world
13:31:24 <dminuoso> its like you are just computing the assembly instructions needed to do it.
13:31:32 <dminuoso> 22:30        dminuoso | trcc: every time you evalute `readfile "filename"` it constructs the same action. the same series of instructions.
13:31:32 <koz_> trcc: Seriously, read that paper. It'll help you a lot.
13:31:33 <trcc> yes, I understand that. But why is the execution irrelevant? I thought it was the most interested?
13:31:37 <trcc> koz_: will do
13:31:45 <dminuoso> trcc: referential transparency is about what functions do.
13:31:54 <dminuoso> the function `readFile` produces the same set of instructions and does *nothing*
13:32:54 <dminuoso> evaluating things in haskell is effect free.
13:33:50 <Solonarv> trcc: you're not distinguishing between writing a cake recipe and baking a cake using that recipe
13:33:59 <Solonarv> 'IO Cake' is a cake recipe
13:34:31 <dminuoso> trcc: Just experiment with the `pseq` primitive.
13:34:36 <trcc> and what is baking a cake? executing the program and checking the value of cake?
13:34:41 <trcc> I am reading the paper currently
13:34:46 <dminuoso> trcc: `pseq` might be helpful because you can directly control evaluation.
13:34:46 <trcc> hopefully that will give me some insights as well
13:34:49 <Solonarv> the RTS
13:34:50 <trcc> ahh
13:35:02 <dminuoso> trcc: with pseq you can just simply see for yourself
13:35:08 <Solonarv> your program consists of one big recipe ('main'); the RTS takes that recipe and follows it
13:35:39 <dminuoso> trcc: the Monad instnace of IO is about how you can construct new recipies based on results of previous baking.
13:35:48 <dminuoso> :t (>>=)
13:35:49 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:36:00 <dminuoso> monomorphized this gives you: IO a -> (a -> IO b) -> IO b
13:36:54 <dminuoso> Given a recipe to bake some cake `a`, and a function that takes an actual cake `a` and computes a new recipe for `b`, we can construct a new recipe for a cake `b` 
13:37:48 <koz_> Solonarv: So is a cake recipe book [IO Cake] or IO [Cake]?
13:38:32 <dmwit> A cake recipe book is [IO Cake]. A cake book recipe is IO [Cake].
13:38:50 <koz_> dmwit: But wait, can't you sequence one into the other?
13:38:57 <Solonarv> koz_: it's an [IO Cake], but you can turn it into IO [Cake] (a recipe for many cakes) using 'sequenceA'
13:39:07 <hpc> if someone hands you a piece of paper that says "do everything in this book", that's IO [Cake]
13:39:25 <dminuoso> that is, the book contains many pages with recipes.
13:39:28 <dmwit> koz_: Yep! Why is "but" the right connective for that observation?
13:39:47 <koz_> dmwit: Not sure. I think I'm still waking up after my trip to Vietnam.
13:39:55 <koz_> (one reason I've been so scarce here for like, 2 weeks)
13:40:47 <Solonarv> (note that you can only sequenceA in one direction: [IO Cake] -> IO [Cake])
13:40:50 <dmwit> (Hypothesis: "but" is the right connective for cakes and recipes and books in the real world, and this is evidence that the analogy has gotten strained further than it should have been taken not that IO is strange or confusing.)
13:41:35 <dminuoso> https://www.cs.kent.ac.uk/people/staff/dao7/publ/codo-notation-orchard-ifl12.pdf
13:41:38 <dmwit> (Who ever heard of a book made out of cakes in the first place, let alone turning a book of recipes into a recipe for such a crazy contraption??)
13:41:43 <hpc> not that confusing
13:41:44 <dminuoso> Wow codo-notation is a thing :o
13:41:45 <hpc> if someone hands you a piece of paper that says "do everything in this book", that's IO [Cake]
13:41:52 <jackdk> I would point out that at no point does `(>>=)` "take out" the value "inside" IO: you can think of `m >>= f` as `join (fmap f m)`
13:42:13 <jackdk> not grokking that was a major impediment to my understanding, at least
13:42:17 <koz_> hpc: Monads are delicious?
13:42:37 <dminuoso> koz_: If thats the case, then Comonads are codelicious.
13:42:42 <hpc> the real confusion here is why you're making cakes and not burritos
13:42:48 <koz_> dminuoso: What does it mean to be 'codelicious'?
13:42:54 <dmwit> I've got a sweet tooth is all.
13:42:54 <shapr> maerwald: ghcup has saved me hours of frustration, thanks!
13:43:44 <dminuoso> koz_: So if delicious is a morphism in the category of Yummy, then codelicious is its dual in Yummy^op
13:44:11 <dminuoso> Clearly,
13:46:01 <janiczek> jackdk: Yeah! That made me wonder too. bind for Maybe could be done the `join (fmap f m)` way or the `case maybeVal of Nothing -> Nothing, Just value -> Just (f value)` ... interesting
13:47:23 <jackdk> it's true for any monad
13:47:31 <jackdk> :t \m f -> join (fmap f m)
13:47:33 <lambdabot> Monad m => m a1 -> (a1 -> m a2) -> m a2
13:47:41 <jackdk> et voila! bind
13:49:20 <dminuoso> janiczek: part of the reason this is not perfect yet, is because join is not a class method of Monad.
13:49:30 <dminuoso> Until we have QuantifiedConstraints, we cant sadly.
13:49:34 <janiczek> does it make sense to "specialize" it with the `case` approach (or another if it exists) for specific instances? or is it not worth it?
13:50:40 <Solonarv> you *must* define >>= yourself when writing a Monad instance
13:50:50 <Solonarv> there's no default that you could override!
13:51:31 <koz_> Delicious, delicious QuantifiedConstraints.
13:51:54 <Solonarv> join is a top-level function implemented in terms of >>=; setting m >>= k = join (fmap k m) in a Monad instance will just get you a infinite loop
13:52:37 <hpc> but if it makes the definition easier, you can do m >>= k = let join' = something easier in join' (fmap k m)
13:55:11 <dminuoso> janiczek: you can imagine monad to be: class Applicative m => Monad m where join :: ... (>>=) :: ... {-# MINIMAL join | (>>=) #-}
13:55:31 <dminuoso> janiczek: so join would be implemented in terms of >>= and >>= would be implemented in terms of join. You'd have to define *one* of them.
13:56:24 <Solonarv> (this will probably be in base some time from now)
13:56:27 <dminuoso> However. Because of technical reasons we cant move `join` into a class method (just yet, but soon), so `join` is always implemented in terms of >>=. The only way left for you is to implement >>= instead.
13:56:56 <hpc> Solonarv: it'll be implemented just in time for the /next/ haskell 98
13:57:55 <Solonarv> I believe the technical reasons are already solved, just waiting to see if any issues crop up with that solution
14:03:58 <koz_> hpc: You mean the one in 2098?
14:04:02 <koz_> Or 2198?
14:06:33 <hpc> i'll let https://www.youtube.com/watch?v=0_HGqPGp9iY answer that question :D
14:11:37 * hackage possible 0.1.0.6 - Three valued Data.Maybe  https://hackage.haskell.org/package/possible-0.1.0.6 (tolysz)
14:15:37 <xcmw> Is it possible to write a function with the following type signature?
14:15:41 <xcmw> Monad m => (a -> m b) -> m (a -> b)
14:16:44 <reygoch> Does anyone have experience building GHCJS on Windows?
14:17:54 <dminuoso> xcmw: What would that do?
14:18:34 <xcmw> Not sure
14:18:44 <janiczek> @djinn Monad m => (a -> m b) -> m (a -> b)
14:18:44 <lambdabot> -- f cannot be realized.
14:18:51 <hpc> xcmw: imagine applying that function to putStrLn
14:19:22 <dminuoso> hpc: then I can think of one way to implement that.
14:19:34 <hpc> you get back an IO (String -> ())
14:19:41 <hpc> which prints...
14:20:31 <xcmw> So it is not possible?
14:20:34 <dminuoso> though no..
14:20:40 <hpc> it's impossible, yeah
14:20:44 <xcmw> Okay
14:20:48 <xcmw> Thanks
14:24:29 <pie___> so i have the following typeclass, and im tryng to implement the instance for Widget: https://bpaste.net/show/4f90327b7101
14:24:51 <pie___> but ive run into an inconsitency in my codebase and im not sure how to patch over it for the moment
14:25:10 <pie___> all the types id written instances in so far were wrapped in an ioref on the outside, so it didnt matter
14:25:25 <pie___> but now this has the ioref on the inside and im not sure how to get this to work
14:25:53 <pie___> im trying to solve this:
14:26:01 <koz_> I recently saw a bunch of blog posts about the 'ReaderT pattern'. I've read them, and I still don't get the point.
14:26:09 <koz_> Could someone explain to me why this is a thing and what it's good for?
14:26:14 <pie___>       Expected type: CallbackStruct (Event -> IO ())
14:26:14 <pie___>         Actual type: IORef (CallbackStruct EventCallback)
14:26:53 <pie___> sorry, i cleaned that up wrong
14:26:55 <pie___>       Expected type: C.CallbackStruct (Event -> IO ())
14:26:55 <pie___>         Actual type: C.CBSRef EventCallback
14:27:07 <pie___> ^ thats the verbatim stuff. CBSRef is just IORef CallbackStruct
14:27:33 <pie___> obviously i cant just call readioref in the instance because im not in IO
14:27:51 <__monty__> koz_: It's basically just a more convenient way than threading certain things through basically all your functions.
14:28:18 <koz_> __monty__: Could you elaborate on that a bit more?
14:28:51 <__monty__> koz_: Don't look at it as a pattern to add to your toolbox please. Blind adherence to patterns is what has given the word a bad aftertaste for me.
14:29:11 <koz_> __monty__: I'm just trying to understand what the whole point of it is, because I can't see one.
14:29:48 <__monty__> koz_: Have you encountered a situation where you've had to thread some argument through a number of functions one of which calls the next, just so the final one can use it? Or each of them can use it?
14:30:02 <koz_> __monty__: I can't say I've ever felt that problem no.
14:30:56 <__monty__> Then you haven't run into a use case for the pattern yet. Or-more likely imo-you haven't recognized times it might've helped.
14:31:20 <koz_> __monty__: I would expect it's the latter as well. This is why I'm asking: I wanna understand where and why it helps.
14:31:34 <koz_> Because none of the blog posts I've read about it made that clear in any sensible way.
14:31:39 <koz_> (or in my opinion, any way at all)
14:32:14 <__monty__> Then I suspect you're just not ready for it yet. Don't worry, it's nothing revolutionary, you're not missing out.
14:32:56 <__monty__> Just to be clear, it's not the monad *transformer* part you have difficulty with, right?
14:33:02 <marvin2> someone remind me, what is foldr (<|>) Nothing  function called?
14:34:19 <marvin2> > asum [Nothing, Nothing, Just 5, Just 10]
14:34:21 <lambdabot>  Just 5
14:44:13 <c_wraith> marvin2: asum?
14:44:15 <c_wraith> :t asum
14:44:16 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
14:44:24 <marvin2> thanks, but I found it
14:44:31 <marvin2> see above :)
14:44:32 <c_wraith> Oh, sorry.
14:54:58 <dhs227> how does haskell work with python?
14:55:20 <c_wraith> Not a natural combination, but there probably are libraries to help
14:56:25 <c_wraith> https://hackage.haskell.org/packages/search?terms=python  reports a lot of things I'm unsure of the quality of :)
15:02:19 <koz_> dhs227: Do you wanna call Python stuff out of Haskell?
15:02:24 <koz_> Or Haskell stuff out of Python?
15:34:46 <libertyprime> Hey guys. Noob here. I'm converting a pipeline written in shell script to haskell. What would you say is the analog of propagating environment variables to subscripts. Would that be a 'world' monad which I pass around?
15:35:07 * hackage graphite 0.10.0.0 - Graphs and networks library  https://hackage.haskell.org/package/graphite-0.10.0.0 (alx741)
15:36:02 <hpc> take a look at ReaderT perhaps
15:36:24 <hpc> ultimately it's all just function parameters though
15:40:57 <nitrix> libertyprime, ReaderT lets you chain functions of the form :: env -> monad result. The environment is passed around implicitly within the monad instead of explicitly; it also reduces the risk of an evil function deciding to modify the environment before passing it around.
15:42:10 <ddellacosta> anyone know of a good IRC channel to ask questions about TaPL in?
15:42:21 <libertyprime> hpc: nitrix: thanks guys
15:42:57 <hpc> ddellacosta: there definitely exists someone who knows of a good IRC channel to ask questions about TaPL in ;)
15:43:27 <hpc> (probably -offtopic)
15:43:55 <nitrix> libertyprime, e.g. runReaderT yourEnv $ do { foo; env <- ask; bar env; baz }
15:44:13 <MarcelineVQ> ddellacosta, hpc: it comes up often in ##dependent
15:45:07 <ddellacosta> MarcelineVQ: thanks, I'll try there I guess. Looks like maybe there's also a ##typetheory channel
15:45:35 <nitrix> libertyprime, This would give you a `ReaderT YourEnv m a` monad, where you're able to call other functions normally, but also `ask` for the environment whenever something needs it (ideally those things would also be Readers so you can compose your operations nicely).
15:46:04 <nitrix> Err, `ReaderT YourEnv m` will be the monad actually. I'm rusty :P
15:47:39 <hpc> also it's flip runReaderT iirc
15:47:44 <hpc> but small details
15:48:10 <nitrix> I'm all for the small details. Haven't been on here in a while :)
15:48:35 <nitrix> I went down the Lisp rabbit-hole.
15:49:04 <hpc> small details are what types are for :D
15:50:55 <libertyprime> I asked my local haskell expert friend about using shell scripts inside of haskell. He advised me against doing this. I'm determined though to reuse all the shell script functions I made and create the beast. I just need to find that magic haskell syntax which wraps a shell script into a pretty haskell function, taking care of environment variables, stdin, stdout and exit code. Any suggestions?
15:51:56 <nitrix> I was trying to type lisp and learned that it uses heterogenous lists throughout (for that lovely homoiconic idea), which if you were to implement it in Haskell, would require existential quantification. Then, there's some form or reflection too at runtime, so suddenly you're in the realm of Dynamic.
15:52:23 <nitrix> And you throw your static type system out of the window.
15:54:17 <nitrix> I'm disappointed a little, though now I gained some respect for Lisp :P The closest we have to the macro system seems to be TemplateHaskell.
15:54:30 <hpc> libertyprime: System.Process is the place to start, i think
15:55:29 <hpc> nitrix: i only used lisp for a semester, but i never encountered anything where i went "it's a good thing i have macros instead of first-class functions"
15:55:55 <hpc> it was quite the opposite, where i wanted to pass a function to a function and oops, it's actually a macro
15:56:03 <libertyprime> thanks hpc. haskell seems much less scary if i can dip my toes into it first.
15:56:12 <hpc> it's only syntactically homoiconic
15:56:41 <nitrix> hpc, I'm with you on that. I think the benefits of the macros are when you want to do actually pre-processing stuff, like your own DSL maybe.
15:56:57 <nitrix> But then, Haskell's monads seems way better.
15:57:26 <hpc> you have to want a pretty gnarly eDSL though...
15:59:11 <hpc> my semester learning lisp was pretty fun though
15:59:36 <hpc> it was an AI class, and i ended up being the only one in the class who could train a neural network on the professor's data in under an hour
15:59:48 <hpc> because lisp is all cons cells, so i wrote it like i was in haskell using []
15:59:58 <nitrix> Hehe :)
16:00:05 <hpc> everyone else was doing things like making changes and testing overnight
16:00:13 <hpc> i was like "why? it goes so fast"
16:00:15 <libertyprime> Is there a way to write haskell with parentheses and then convert it into point-free form somehow?
16:00:34 <hpc> @pl \x -> f (g (h x))
16:00:34 <lambdabot> f . g . h
16:00:40 <koz_> @pl \x y z a -> (y, x, a, z)
16:00:41 <lambdabot> (flip .) . flip (,,,)
16:01:00 <hpc> @pl \usually it gets pretty nasty -> nasty it usually gets pretty pretty gets it usually
16:01:02 <lambdabot> flip =<< ((flip . ((flip . (flip .)) .)) .) . join . ((flip . ((flip . (flip .)) .)) .) . flip flip id . (liftM2 (flip . (flip .)) .) . flip flip id . ((flip . ((ap . (flip .) . flip) .) . flip) .) .
16:01:02 <lambdabot>  flip (flip . flip id)
16:01:04 <jaarod> @pl \f g h x -> (f x (g x (h x x x)))
16:01:04 <lambdabot> (. ((. (join . join)) . ap)) . (.) . ap
16:01:53 <nitrix> libertyprime, avoid being too clever with those. If you have to ask lambdabot, it's probably too complicated already :)
16:01:55 <jaarod> libertyprime, satisfied? :)
16:02:11 <DigitalKiwi> hpc: thanks i hate it
16:02:16 <hpc> @pl \f -> f f f
16:02:17 <lambdabot> join (join id)
16:02:19 <nitrix> libertyprime, you can make code extremely unreadable this way :)
16:02:27 <hpc> it also doesn't care about type errors
16:03:26 <libertyprime> I'm sorry I'm sorry! Please just stop the flips. I'm flipping out
16:05:06 <hpc> libertyprime: and now you know why it's sometimes called pointless style
16:10:37 * hackage HaTeX 3.20.0.0 - The Haskell LaTeX library.  https://hackage.haskell.org/package/HaTeX-3.20.0.0 (DanielDiaz)
17:30:59 <rcshm> hi, i am struggling with installing nixos on raspberry pi.  i keep trying to install the gui and only desktopManager.xfce and displayManager.auto would work.  but then it is pretty slow. and it keeps getting alloc_contig_range: [34e00, 35e00) PFNs busy from i try to update configuration and nixos-rebuild.
17:31:31 <rcshm> sorry wrong window.
17:44:21 <Yukkuri> -- what kind of fun programmer have? -- *
17:46:57 <DigitalKiwi> none
17:48:17 <Yukkuri> functions are first-class values.
17:48:49 <Yukkuri> monomorphic and not encapsulate any data
17:49:27 <julianleviston> Yukkuri: let x = 5 in y z = x + 10
17:49:49 <Yukkuri> kind of that expression would still be '*'
17:50:23 <julianleviston> oh, you’re asking a question about kinds.
17:50:31 <Yukkuri> i am not asking anytning
17:50:41 <julianleviston> you certainly used a question mark.
17:50:55 <Yukkuri> as a part of simulated dialog.
17:51:27 <julianleviston> functions can certainly encapsulate data, tho.
17:51:39 <Yukkuri> not as types
17:51:52 <julianleviston> why not?
17:51:57 <julianleviston> peano numbers?
17:52:16 <julianleviston> or are you talking about the apparently lack of dependent types?
17:53:08 <julianleviston> https://www.schoolofhaskell.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell 
17:53:15 <Yukkuri> or church coding. but joke was explciyly about `kind` mechanism with relation to `types`
17:53:23 <julianleviston> joke?
17:53:59 <julianleviston> I don’t think it translated very well into english.
17:54:17 <julianleviston> What kind of fun do programmers have? is how one would render that in english, and unfortunately “do” gets in the way there ;-)
17:54:32 <julianleviston> It only really makes sense in roughly translated japanese.
17:54:48 <Yukkuri> make it 'does'
17:54:48 <julianleviston> roughly translated english from japanese, I should say.
17:55:06 <julianleviston> ‘make it “does”’ doesn’t mean anything in english
17:55:17 <Yukkuri> and add 'a' article
17:55:54 <Yukkuri> if you're being intentionally dense, i can't help you
17:56:18 <julianleviston> I’m not being dense at all. I’m explaining that the joke doesn’t make much sense in normally rendered english.
17:56:37 <julianleviston> It happens to make sense to me… but that’s only because sukoshi nihongo de hanasemasu ne.
17:57:01 <slack1256> wat
17:57:02 <Yukkuri> or rather trying to defend sever case of woosh
17:57:08 <Yukkuri> severe*
17:57:38 <MarcelineVQ> I didn't get it at first, but when you said simulated dialogue it made sense :>
17:57:39 <julianleviston> “sukoshi nihongo de hanasemasu” means “I can speak a little japanese”
17:58:29 <Yukkuri> probably should have used better typography
17:58:34 <julianleviston> “What kind is the fun that programmers have? — *” might be a better version.
17:58:42 <DigitalKiwi> programmers do not have fun programming is real srs bizness
17:59:04 <julianleviston> it’s a pun on “kind” (type of type) and “fun” (for function)
17:59:14 <julianleviston> as far as I can see.
17:59:20 <Yukkuri> that doesn't sound like a human speech at all
17:59:22 <MarcelineVQ> that's kind of terrible
17:59:44 <julianleviston> it’s perfectly fine english, yukkuri :)
17:59:48 <ProofTechnique> This seems like some real #haskell-blah
17:59:54 <julianleviston> yes.
18:02:09 <MarcelineVQ> nothing wrong with a little OT when no one's seeking help
18:10:01 <maerwald> MarcelineVQ: people have been banned for saying that
18:10:44 <MarcelineVQ> Just for that? Seems unlikely but I'm okay with risking it since that's my honest opinion
18:10:54 <maerwald> Yes, just for that
18:16:19 <maerwald> MarcelineVQ: https://privatebin.net/?cea03476293a6ee5#aO48S7etxyOFr53S+CaswA1ELyDhkeoVSkn58h21pf0=
18:23:05 <MarcelineVQ> I do see that had at least one direct warning involved but not a whole lot of context otherwise to see why the response was so curt, though it's not a thrilling response.
18:23:47 <maerwald> I can't find online logs, it's from 2016-07-24. I was also not aware of such a policy
18:24:12 <maerwald> And there was no warning :)
18:24:28 <DigitalKiwi> mouthing off to glguy is probably not a good move
18:24:45 <maerwald> So it's probably better to switching directly to haskell-offtopic or the like 
18:30:39 <glguy> o.O ? I chose not to read whatever's above that mention
18:31:46 <DigitalKiwi> OH NO IT'S THE FUZZ
18:31:50 <maerwald> it was about confusion about channel policy :)
18:33:44 <maerwald> maybe it should be added somewhere here https://wiki.haskell.org/IRC_channel#Principles
18:34:07 <maerwald> although no one is probably reading that
18:42:32 <glguy> I feel like the channel moderation is pretty mild here, but maybe I feel like that because I'm on that side of the law
18:42:54 <glguy> I spent way more time fighting spam last year than telling people what to do
18:43:17 <maerwald> Yeah, I guess it's unlikely that you get banned as a mod ;P
18:43:30 <maerwald> Unless you are specifically looking for that experience
18:43:39 <sm> sometimes it's a bit hair trigger
18:43:57 <sm> sometimes, the ooposite
18:44:07 <sm> yikes don't ban me
18:44:32 * sm needs a spell checker
18:44:56 <maerwald> I don't mind channels with quick bans, as long as the policy is clear and visible
18:59:06 <monochrom> If you're looking for who banned OT and why, that would be usually me.  These days I'm busying teaching and playing games so you don't see it often.
19:02:30 <monochrom> But as usual, most IRC users are superficial and memoryless, they only look at the most recent sentence said, they won't understand the complex way I decide to ban including months of history, how long the conversation has been, whether it is ending by itself soon or getting out of hand, and second order and/or meta effect such as how much sense of entitlement the participants exhibit.
19:04:51 <monochrom> If you're looking for a clear and visible policy, it's going to be merely shapr's "be nice, or else".  But it won't be a simple algorithm.
19:05:45 <maerwald> if there is no clear policy, then the line between "mood" and "complex decision" is thin
19:06:05 <monochrom> Sure.
19:06:06 <maerwald> But I guess both works in one way or another
19:08:02 <maerwald> If you only care about policies, then people may abuse that as part of their trolling to not get banned
20:02:33 <fen> can Foldable be implemented in terms of Foldable1?
20:02:41 <fen> and similary for traversable
20:06:46 <jackdk> I think so, for similar reasons as you can write (<*>) in terms of (>>=)
20:07:16 <dibblego> foldMap = foldMap1 -- now that Semigroup => Monoid
20:07:43 <dibblego> wait, other way around
20:09:06 <fen> same for Apply => Applicative and traverse1 ?
20:10:46 <fen> so much simpler that trying to write foldr1 in terms of foldr
20:11:42 <fen> was trying that because then the foldr1Default wouldnt collide with foldMap1Default provided by Traversable1
20:13:01 <fen> (Maybe (a,b) -> b) -> ((a,Maybe b) -> b) 
20:13:28 <fen> \f (a,Nothing) -> f Nothing
20:13:47 <fen> seems like it discards the last value
20:14:17 <fen> :t \f -> foldr (\a b -> f (Just (a,b))) (f Nothing)
20:14:18 <lambdabot> Foldable t => (Maybe (a, b) -> b) -> t a -> b
20:17:58 <fen> dibblego: is that right? wouldnt foldMap need the mempty?
20:20:36 <fen> Foldable1 is a subclass of Foldable right? so you wouldnt expect Foldable1 to be implemented by Foldable...
20:21:00 <fen> like, we cant write; ((a,Maybe b) -> b) -> (Maybe (a,b) -> b) 
20:22:06 <fen> foldr1 :: ((a,Maybe b) -> b) -> t a -> b
20:22:36 <fen> beginning to think there isnt a default at all here
20:24:10 <fen> foldMap f = foldr (mappend . f) mempty
20:24:20 <fen> thats where it needs the mempty...
20:25:56 <fen> jackdb: yeah, sometimes a superclass can be implemented by its subclass, but it might not be the case here
20:40:39 <fen> foldMap = foldMap1 typechecks ok, might need to test it though, all this foldr stuff is causing trouble
20:40:51 <fen> thanks
20:43:36 <fen> ok, so the real reason for trying to write it in terms of foldr instead of foldMap is that when this defaulting happens again to Foldable0, the stream case, can we be sure that the foldMap will be lazy enough to allow us to fold over the stream and then take from it, without causing the whole stream to be evaluated?
20:44:30 <fen> basically, is foldMap0 sane for streams?
20:49:24 <fen> dont want to provide defaults that are going to cause infinite computations...
21:01:07 * hackage scalpel-core 0.6.0 - A high level web scraping library for Haskell.  https://hackage.haskell.org/package/scalpel-core-0.6.0 (fimad)
21:02:07 * hackage scalpel 0.6.0 - A high level web scraping library for Haskell.  https://hackage.haskell.org/package/scalpel-0.6.0 (fimad)
21:25:24 <haskellnoob> hello. I'm using stack, but I'm having trouble figuring out how to specify a version for a dependency . 
21:28:39 <glguy> version bounds go in your <project>.cabal file.
21:29:15 <glguy> If your resolver doesn't include a version of that package , you'll have to specify a particular in your stack.yaml in each build environment
21:29:28 <haskellnoob> ok thanks
21:31:32 <haskellnoob> I'm so use to java/maven that not specifiying explicit version number is strange 
21:33:01 <glguy> The stack model is that you manually specify versions
21:34:02 <glguy> Some are bundled in the resolver and then you can add additional
21:34:21 <glguy> It's up to you to make sure those choices satify your version constraints
21:35:31 <haskellnoob> so a resolver will only contain one version of a package ?
21:35:53 <glguy> yeah
21:36:43 <maerwald> you can overwrite dependencies, usually by specifying the git repo and hash
21:37:17 <maerwald> or local folder, or hackage version
21:37:24 <maerwald> usually causes trouble though :)
22:46:16 <mjrosenb> Is there a modern(ish) way to compile for android? 
22:46:38 <mjrosenb> I found a page with a bunch of links, but they were all from ~2012
22:48:34 <kadoban> mjrosenb: reflex has some cool looking stuff that I haven't looked at in detail
22:49:05 <kadoban> The default like recommended, "hey make a reflex project" setup mentions it
22:50:01 <mjrosenb> link?
22:50:15 <mjrosenb> reflex is kinda a generic name.
22:51:01 <kadoban> reflex-dom or reflex-frp will get you closer. Trying to find something that actually mentions the android stuff tho
22:52:54 <kadoban> https://github.com/reflex-frp/reflex-platform/blob/develop/docs/project-development.md#user-content-building-mobile-apps is what I was thinking of 
22:53:33 <kadoban> Just as a warning, I've never used it though (the android part). From what I've overheard it's actually in use by other people, but ymmv.
22:55:50 <mjrosenb> hrm, that appears to be for building a website, but I shall check it out.
22:59:03 <kadoban> That is one way to describe the purpose of reflex-frp, yes. I'm not really sure how the android stuff is implemented, if it goes through javascript or not.
23:00:07 * hackage odpic-raw 0.4.0 - Oracle Database Bindings  https://hackage.haskell.org/package/odpic-raw-0.4.0 (leptonyu)
23:10:59 <trcc_> Is a pure function the same as a referential transparent function? I seem to find both yes and no
23:14:07 * hackage hedn 0.2.0.1 - EDN parsing and encoding  https://hackage.haskell.org/package/hedn-0.2.0.1 (AlexanderBondarenko)
23:28:29 <sm[m]> I think yes
23:29:15 <trcc_> So IO is referential transparent, but not pure. It describes interaction with the outside world, and is therefore impure. But it is just a value, and can be replaced with its evaluation, and is therefore referential transparent?
23:33:29 <sm[m]> IO means “arbitrary side effects” so it pretty much means “not referentially transparent”. Though of course you can make a RT function that has IO in the type signature
23:33:52 <trcc_> what is RT short for?
23:34:54 <sm[m]> Trying not to retype referentially transparent. :)
23:35:02 <trcc_> ah haha
23:36:33 <trcc_> sm[m]: it is a follow-up from a discussion last night, where I was trying to understand why IO in haskell is referential transparent. It is, but the run-time is not. So in the context of evaluation, it is referential transparent. I.e. you can place: let x = readfile y in x >> x with readfile y >> readfile y
23:36:39 <trcc_> repalce*
23:36:41 <trcc_> replace*
23:38:16 <sm[m]> Well alright how about this: pure = without side effects. Referentially transparent = same result for same parameters. So you could have a routine with side effects that’s referentially transparent
23:38:53 <trcc_> hehe that is what I am asking. So pure != referential transparent
23:42:05 <sm[m]> But Wikipedia says it’s the first thing I said. (They’re the same) so I’ll go with that
23:42:28 <sm[m]> https://en.wikipedia.org/wiki/Referential_transparency
23:42:51 <trcc_> ok. I am not completely happy with wikipedia always. I also find quite a few definitions of referential transparency
23:43:15 <trcc_> but it might be right. I do not know
23:46:11 <sm[m]> Why do you say “IO in haskell is referential transparent” ?
23:48:25 <suzu> IO actions are referentially transparent
23:48:38 <suzu> getLine :: IO String is always equal to another value of getLine :: IO String
23:50:03 <suzu> theoretically speaking, running IO is pure
23:50:15 <sm[m]> Ok. I think most people would think you meant the behaviour of the IO action when evaluated.
23:50:35 <suzu> as you can model an 'IO a' action as really being a function RealWorld -> (RealWorld, a)
23:50:43 <suzu> where RealWorld is the "state" of the universe
23:50:43 <sm[m]> Which of course could vary by time of day, sunspots etc
23:51:28 <trcc_> as I understand it, the difference comes, when it gets executed. Not evalutaed
23:51:28 <suzu> so IO is pure in this sense
23:52:13 <trcc_> suzu - then the idea of mentally using IO as a notion of when some code is dependant on outside state is incorrect?
23:52:26 <suzu> no, it is correct.
23:52:40 <trcc_> But not in modelling context?
23:52:55 <suzu> modelling context?
23:53:14 <trcc_> It is because I am confused with something being pure AND dependant on the outside state at the same time
23:53:29 <trcc_> so if you take f = do
23:53:32 <trcc_> sorry, mkaing gist
23:54:21 <trcc_> https://gist.github.com/CThuleHansen/2d00cf38b602845a7d63496fa06c0a30 then it is no longer pure, because the x is extracted from getLine thereby executing it?
23:54:41 <suzu> you can write f = getLine btw
23:54:50 <suzu> no need for the do block
23:54:53 <trcc_> yes
23:55:04 <suzu> uhh so i don't know what 'pure' means here
23:55:15 <janat08> is there a way to unwrap value out of handler for yesod
23:55:35 <suzu> trcc_: imagine that getLine is really a function that takes in the state of the computer and returns a line from the terminal
23:55:51 <suzu> if you think of it in that sense, then it is a pure operation
23:55:51 <trcc_> yes, I understand that it does that
23:56:15 <suzu> but practically speaking - yeah that makes side effects
23:56:29 <trcc_> and that is where my pain point is
23:56:33 <trcc_> it is pure yet makes side effects
23:56:35 <suzu> and so all operations predicated on needing to know the state of the computer live in IO
23:56:38 <suzu> yep
23:56:50 <trcc_> but as I understand it, the difference is whether we are in evaluation or execution context
23:56:53 <suzu> so this "realworld" state model is how we can encapsulate the idea of making effects in a language with no effects
23:57:34 <suzu> IO is a trick
23:57:57 <suzu> if you could truly not make effects in haskell then it'd be useless
23:57:59 <trcc_> but is the notion of RT in terms of IO not a trick as well then?
23:58:03 <suzu> you'd just plug a box into the wall and it'd get hot and do nothing
23:58:15 <suzu> no, RT in terms of IO is legitimate
23:58:38 <suzu> i can say `foo = getLine` and foo is refererentially transparent. the value of `foo` is never different in any scope
23:58:53 <suzu> but `foo` is only describing an action to carry out that makes effects.
23:59:46 <trcc_> so the execution of the action is the effectful part, and the NON-RT part. 
23:59:58 <trcc_> And that is done by the runtime
