00:00:16 <sicklorkin> a bijection I guess
00:01:56 <opqdonut> an isomorphism and a bijection are basically the same
00:02:00 <opqdonut> (in this sense)
00:02:24 <opqdonut> and no, it's not a bijection since e.g. `Left False` and `Left True` both map to `Nothing`
00:03:22 <opqdonut> maybeToEither is an injection, and eitherToMaybe is it's (err, left?) inverse
00:03:55 <opqdonut> if you limit yourself to `Either () a`, then you have a bijection and an isomorphism between `Either () a` and `Maybe a`
00:04:00 <opqdonut> I wonder if that made any sense
00:07:08 <dminuoso> sicklorkin: maybeToEither is a natural transformation.
00:07:17 <dminuoso> However, it is not an natural isomorphism.
00:07:45 <dminuoso> Wait, eitherToMaybe is a natural transformation. maybeToEither is not even that.
00:07:54 <dminuoso> (At least I havent done the thinking yet, so I dont know)
00:08:30 <sicklorkin> opqdonut: dminuoso thanks. What about the fact that Left "MSG" is the only info that is lost in this transmation mean anything? 
00:08:52 <sicklorkin> s/tansmation/transformation
00:09:09 <sicklorkin> this is why I thought it was a bijection
00:13:31 <opqdonut> a bijection means that _no_ information is lost :)
00:14:10 <sicklorkin> opqdonut: opqdonut: sorry I missed your `Either () a` example.
00:14:32 <sicklorkin> I follow now
00:17:39 <dminuoso> sicklorkin: Either can be thought of as "adding two types together", creating a sum type. Maybe adds a singleton type (where you could think of `Nothing :: ()`) to an arbitrary type.
01:02:47 * hackage wkt-geom 0.0.7 - A parser of WKT, WKB and eWKB.  https://hackage.haskell.org/package/wkt-geom-0.0.7 (newmana)
01:04:48 <trcc> Getting closer and closer.. I have a cabal project, call it X, that builds to a shared library. It uses pacakge Y, which exports some FFI functions. I need to make the FFI functions from Y available to consumers of the shared library. I.e., then need to be outputted when I list the symbols from the so file - https://linux.die.net/man/1/nm. Any ideas?
01:17:17 * hackage DBFunctor 0.1.1.1 - DBFunctor - Functional Data Management =>  ETL/ELT Data Processing in Haskell  https://hackage.haskell.org/package/DBFunctor-0.1.1.1 (nkarag)
01:48:44 <trcc> I solved my ffi issue with wrapping the functions, but it seems like a suboptimal approach. The solution is described here: https://www.reddit.com/r/haskell/comments/apeoev/haskell_ffi_exporting_symbols_from_builddepends/ along with quest for alternative approaches.
02:37:46 <tsaka__> I'm having some trouble with numerical types. What's the best way to use types to get the n'th triangle number, which is given by "0.5 * n * (n - 1)", and which is always an Int? That is, I want triangle :: Int -> Int
02:41:21 <Maxdamantus> n*(n - 1) `div` 2
02:51:51 <[exa]> tsaka__: (it's often surprising that /2 and *0.5 is something completely different in computers)
02:52:25 <tsaka__> [exa]: which one to use in this case?
02:53:04 <[exa]> `div` 2, certainly, as Maxdamantus said. Your algorithm works with integers and you're sure that there will be no remainder after division
02:53:11 <[exa]> related fun:
02:53:22 <[exa]> > toRational 0.1
02:53:24 <lambdabot>  3602879701896397 % 36028797018963968
03:51:27 <gentauro> can lines 8-9 be merged into a one-liner like 13? (with `Control.Arrow` => `first` and/or `second`) -> http://dpaste.com/3VF5ME6
03:53:07 <lyxia> gentauro: what is action02
03:53:13 <lyxia> foo?
03:53:44 <lyxia> in which case that's a specialized map.
03:54:06 <gentauro> lyxia: yeah
03:55:06 <gentauro> lyxia: updated (and compiling) version -> http://dpaste.com/1VJK8G2
03:56:47 <gentauro> I'm guessing some `map ({- usage of `second` to `compare `fst` elem with `x` -} fst . box) bs`
03:59:35 <WilliamHamilton[> heath: ping!
04:03:10 <gentauro> oh well, nevermind `map (Box . (\(i,_) -> (i,compare x i)) . box)` (doh)
04:48:53 <tsaka__> is there a guide, or even just an example, anywhere, for using fixedpoint floats, with e.g. Data.Number.BigFloat or any other library?
04:49:04 <tsaka__> haskell library authors really despise simple examples
04:49:15 <tsaka__> or even examples at all
04:49:46 <hpc> if it has a Num instance, you generally use them like regular numbers
04:49:56 <hpc> > e / pi :: CReal
04:49:58 <lambdabot>  error:
04:49:58 <lambdabot>      • Couldn't match expected type ‘CReal’ with actual type ‘Expr’
04:49:58 <lambdabot>      • In the expression: e / pi :: CReal
04:50:02 <hpc> oh right, e isn't a thing
04:50:07 <hpc> > pi :: CReal
04:50:10 <lambdabot>  3.1415926535897932384626433832795028841972
04:50:21 <merijn> tsaka__: Also, why use a library for Fixed precision floats? Those are in base?
04:50:37 <hpc> > floor (pi ** 100 :: CReal)
04:50:39 <lambdabot>  51878483143196131920862615246303013562686760680405
04:50:41 <tsaka__> merijn: Well, there's no example usage of those either
04:50:58 <merijn> tsaka__: "example usage" like what?
04:51:13 <merijn> > 0.0001 :: Milli
04:51:15 <lambdabot>  0.000
04:51:21 <merijn> > 0.0121 :: Milli
04:51:23 <lambdabot>  0.012
04:51:30 <merijn> > 0.0121 + 0.53 :: Milli
04:51:32 <lambdabot>  0.542
04:51:38 <tsaka__> such as constructing a number with precision X ....
04:52:04 <merijn> tsaka__: From what? A literal? Or from some other fractional type?
04:52:12 <__monty__> Fixed precision floats? Isn't that a contradiction?
04:52:30 <merijn> __monty__: Yes, but you know what he means, so no point in being pedantic
04:52:32 <tsaka__> merijn: frrom e.g. sqrt(2)
04:52:52 <merijn> > sqrt 2 :: Milli
04:52:54 <lambdabot>  error:
04:52:54 <lambdabot>      • No instance for (Floating Milli) arising from a use of ‘sqrt’
04:52:54 <lambdabot>      • In the expression: sqrt 2 :: Milli
04:52:57 <merijn> ah
04:53:18 <__monty__> merijn: Was just asking because I saw something I didn't know and figured there might be a learning opportunity.
04:53:20 <merijn> tsaka__: The Swiss army knife for converting almost anything to almost anything is
04:53:25 <merijn> :t realToFrac
04:53:26 <lambdabot> (Fractional b, Real a) => a -> b
04:53:43 <merijn> > realToFrac (sqrt 2) :: Milli
04:53:45 <lambdabot>  1.414
04:54:15 <merijn> __monty__: There's only two "conversion" functions worth remembering for numbers: fromIntegral and realToFrac
04:54:35 <merijn> Well...maybe some of the rounding functions
04:54:41 <hpc> and fromRational for decimal literals
04:54:59 <hpc> really all you have to remember is that numbers are numbers, and all their operations are in type classes
04:55:09 <merijn> hpc: NumDecimals :p
04:56:39 <ququ> Hello guys! I have a very basic question: given a function which takes String and outputs [String], and a list of [String], how do I run this function on every element in the [String] List? I'm looking for something like the equivalent of map, but instead of being (a -> b) -> [a] -> [b], I want (a->[b])->[a]->[b] 
04:57:23 <__monty__> :t flatMap
04:57:24 <merijn> tsaka__: Anyway, the reason those types (and presumably also BigFloat, etc.) don't have docs is because the intended use is via the typeclasses in base, so their documentation is just "those typeclasses". Like Fixed has instance for Real, Fractional, Num, RealFrac, etc. so most numerical operation "just work" (sqrt just happens to require Floating which Fixed obviousl is lacking, so you need realToFrac 
04:57:25 <lambdabot> error: Variable not in scope: flatMap
04:57:29 <hpc> :t (>>=) @[]
04:57:30 <merijn> for that)
04:57:30 <lambdabot> error:
04:57:30 <lambdabot>     Pattern syntax in expression context: >>=@[]
04:57:30 <lambdabot>     Did you mean to enable TypeApplications?
04:57:35 <hpc> % :t (>>=) @[]
04:57:36 <yahb> hpc: [a] -> (a -> [b]) -> [b]
04:57:36 <merijn> :t concatMap
04:57:37 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
04:57:54 <hpc> % :t flip (>>=) @[] -- ququ
04:57:55 <yahb> hpc: ; <interactive>:1:1: error:; * Cannot apply expression of type `(a0 -> m0 b0) -> m0 a0 -> m0 b0'; to a visible type argument `[]'; * In the expression: flip (>>=) @[]
04:57:59 <hpc> aw
04:58:10 <hpc> but yeah, something along those lines
04:58:55 <tsaka__> In any case, merijn, Data.Fixed seems bugged: https://paste.ofcode.org/wbi7ekemndV7B8NeSWRaaW
04:59:14 <ququ> concatMap is what I was looking for! Thanks!
04:59:19 <merijn> tsaka__: No
04:59:30 <tsaka__> hmm
04:59:31 <merijn> tsaka__: That's because sqrt is returning a Double and then converting to Fixed E100
04:59:40 <merijn> tsaka__: The original Double doesn't magically get more precision
04:59:59 <merijn> tsaka__: You could try changing that to use the BigFloat library you mentioned earlier :)
05:00:01 <tsaka__> I get that, but sqrt doesn't accept Fixed X numbers
05:00:39 <merijn> tsaka__: Presumably BigFloat is an instance of Floating and sqrt works with it
05:02:27 <hpc> the nuclear option is http://hackage.haskell.org/package/numbers-3000.2.0.2/docs/Data-Number-CReal.html from the same package as BigFloat
05:02:32 <merijn> tsaka__: I'd be curious to know if you can get that working :)
05:02:56 <tsaka__> merijn: We're back to using Data.Fixed from base, remember. There's no bigfloat thre
05:02:58 <tsaka__> there
05:03:02 <hpc> > drop 90000 (showCReal 100000 (sqrt 2))
05:03:08 <lambdabot>  mueval-core: Time limit exceeded
05:03:13 <hpc> aw
05:03:52 <tsaka__> https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Fixed.html
05:04:05 <merijn> tsaka__: My point is that sqrt (and some others) require a Floating instance. You can't magically get precision that's not there. The only Floating instance in base (to the best of my knowledge) are Float and Double
05:04:35 <merijn> tsaka__: If the precision of those aren't sufficient, then you need something else (like BigFloat)
05:05:06 <tsaka__> merijn: So you can't use Data.Fixed for getting sqrt(2) with 100 digits precision?
05:05:38 <merijn> No unless you implement a sqrt from scratch, no
05:05:43 <merijn> :t sqrt
05:05:44 <lambdabot> Floating a => a -> a
05:06:03 <merijn> Fixed is not a Floating instance (because those two things are mutually exclusive)
05:11:20 <marvin3> tsaka__ numbers package has BigFloat with Floating instance
05:28:00 <gentauro> is there something similar in Haskell (lib) that does the same as F# `code quotations`? Example: `<@@ id @@>` becomes `> val it : Expr = Lambda (x, Call (None, Identity, [x]))`
05:28:52 <gentauro> info: <@@ .. @@> converts code to untyped lambda calculus, while <@ .. @> converts it to typed lambda calculus
05:29:45 <lyxia> template haskell?
05:30:13 <gentauro> lyxia: do you have a link to an example? thx in advance
05:31:24 <merijn> gentauro: The GHC user's guide?
05:32:23 <merijn> gentauro: Although Template Haskell can be a little intimidating
05:32:33 <gentauro> merijn: already there -> https://downloads.haskell.org/~ghc/7.8.1/docs/html/users_guide/template-haskell.html
05:33:27 <gentauro> just to clarify. F# code quotations takes `regular F#` code and transform it. Nothing fancy needs to be done. Just take compiling F# code and wrap it in either `<@@ .. @@>` or `<@ .. @>`
05:33:28 <merijn> gentauro: Might want to skip to a more recent one ;)
05:33:33 <merijn> gentauro: 7.8 is ancient :p
05:33:59 <merijn> gentauro: There are quasi-quoters for turning Haskell into a quoted AST
05:34:04 <merijn> [| |]
05:34:05 <tdammers> gentauro: converts it into *what*?
05:34:48 <tdammers> gentauro: a first-class representation of the AST?
05:35:14 <gentauro> tdammers: 14:27 < gentauro .. Example: `<@@ id @@>` becomes `> val it : Expr = Lambda (x, Call (None, Identity,Example: `<@@ id @@>` becomes `> val it : Expr = Lambda (x, Call (None, Identity, [x]))`
05:35:42 <gentauro> F# code becomes => typed and untyped lc
05:35:56 <gentauro> and yes, it's the AST representation
05:36:36 <merijn> gentauro: Right, so that's just QuasiQuotation
05:36:51 <tdammers> indeed. TH and QQ
05:37:57 <gentauro> eh, nah? https://wiki.haskell.org/Quasiquotation
05:39:36 <gentauro> I don't think it does the same. I mean, from the wiki, it looks like there needs to be modifications to regular Haskell code.
05:40:20 <tdammers> OK, forget the quasiquotation; it's just TemplateHaskell. $( ... ) goes from "meta" to "normal", [| ... |] goes the other way around
05:40:35 <merijn> gentauro: QuasiQuotation can be used for writing your own QuasiQuoter (which processes arbitrary text) and using GHC (Typed) Template Haskell quasiquoter from Haskell source
05:40:46 <gentauro> what I'm doing right now, is just to use `Language.Haskell.Exts` and `parseFileContents <$> readFile path` and then iterate through their AST
05:41:02 <merijn> % runQ [| Just 'c' |]
05:41:02 <yahb> merijn: ; <interactive>:43:7: error: parse error on input `|'
05:41:15 <merijn> % :set -XQuasiQuotation
05:41:15 <yahb> merijn: Some flags have not been recognized: -XQuasiQuotation
05:41:19 <merijn> % :set -XQuasiQuotates
05:41:19 <yahb> merijn: Some flags have not been recognized: -XQuasiQuotates
05:41:26 <merijn> ugh, spelling is hard
05:41:29 <merijn> % :set -XQuasiQuotes
05:41:30 <yahb> merijn: 
05:41:35 <merijn> % runQ [| Just 'c' |]
05:41:36 <yahb> merijn: ; <interactive>:47:7: error: parse error on input `|'
05:41:40 <tdammers> Prelude Language.Haskell.TH> runQ [| id |]
05:41:42 <tdammers> VarE GHC.Base.id
05:41:45 <tdammers> ^ this is in ghci
05:44:10 <gentauro> λ>:set -XQuasiQuotes
05:44:24 <gentauro> λ>import Language.Haskell.TH
05:44:32 <gentauro> λ>runQ [| id |]
05:44:45 <gentauro> <interactive>:11:7: error: parse error on input ‘|’
05:44:52 <lyxia> The extension you want is TemplateHaskell
05:44:54 <merijn> Oh, I know why it fails
05:44:56 <merijn> no
05:44:57 <tdammers> [| |] isn't quasiquotes, just TH
05:44:59 <gentauro> I might be doing something wrong ...
05:45:09 <tdammers> :set -XTemplateHaskell
05:45:31 <gentauro> tdammers: thx 
05:45:34 <gentauro> that worked
05:45:44 <cads2> > filter (\(a, b, c) -> a^c + b^b + c^a == 100*a + 10*b + c) [(a,b,c) | a <- D, b <- D, c <- D] where D = [0 .. 9]
05:45:46 <lambdabot>  <hint>:1:95: error: parse error on input ‘where’
05:46:29 <dminuoso> cads2: Since lambdabot expects an expression you have to use `let`
05:46:38 <cads2> > filter (\(a, b, c) -> a^c + b^b + c^a == 100*a + 10*b + c) [(a,b,c) | a<-[0..9], b<-[0..9], c<-[0..9]]
05:46:40 <lambdabot>  [(0,0,2)]
05:47:08 <cads2> > 0^0
05:47:10 <lambdabot>  1
05:47:30 <cads2> derp
05:57:21 <cads2> > let D = [0..9] in filter (\(a,b,c,d,e,f,g) -> a^g + b^f + c^e + d^d + e^c + f^b + g^a == 10^7*g + 10^6*f +  10^5*e + 1000*d 100*c + 10*b + a) [(a,b,c,d,e,f,g) | a<-D,b<-D,c<-D,d<-D,e<-D,f<-D,g<-D]  -- Dear Lambdabot, please lend me your cycles
05:57:23 <lambdabot>  error: Not in scope: data constructor ‘D’
05:58:29 <cads2> > let t = [0..9] in filter (\(a,b,c,d,e,f,g) -> a^g + b^f + c^e + d^d + e^c + f^b + g^a == 10^7*g + 10^6*f +  10^5*e + 1000*d 100*c + 10*b + a) [(a,b,c,d,e,f,g) | a<-t,b<-t,c<-t,d<-t,e<-t,f<-t,g<-t]  --Pretty Please?
05:58:31 <lambdabot>  error:
05:58:31 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ t -> a
05:58:31 <lambdabot>      • In the second argument of ‘(*)’, namely ‘c’
05:59:21 <cads2> > let t = [0..9] in filter (\(a,b,c,d,e,f,g) -> a^g + b^f + c^e + d^d + e^c + f^b + g^a == 10^7*g + 10^6*f +  10^5*e + 1000*d + 100*c + 10*b + a) [(a,b,c,d,e,f,g) | a<-t,b<-t,c<-t,d<-t,e<-t,f<-t,g<-t]  --This time with cherries
05:59:27 <lambdabot>  mueval-core: Time limit exceeded
06:00:02 * cads2 grumbles something about `sudo apt-get install ghc`
06:01:12 <foolswood> Hi, I'm having a strange (to me) issue where a .so in a directory specified in the extra-lib-dirs of a dependency becomes not found when using template haskell. Any pointers/ideas?
06:22:16 * hackage PyF 0.7.1.0 - Quasiquotations for a python like interpolated string formater  https://hackage.haskell.org/package/PyF-0.7.1.0 (guibou)
06:30:26 <shreyasminocha> hi
06:30:30 <xenon-> if two packages implement the same orphan instance, does GHC have any mechanism to determine which one is used?
06:30:31 <shreyasminocha> i'm noob mcnoob
06:32:18 <xenon-> or rather, does it have any mechanism to allow user of those packages to pick an instance 
06:32:34 <glguy> xenon-: yeah, import controls that. If you import a module that transitively imports the module that defines the instance ghc will try to use it
06:32:49 <xenon-> glguy, what if you have to import both modules?
06:33:03 <glguy> Then you messed up
06:33:44 <lyxia> luckily you'll get an overlapping instance error if you try to use them when both are in scope
06:34:39 <xenon-> glguy, surely the people who made orphan instances messed up then, and not the user of those packages?
06:34:52 <xenon-> I'm surprised haskell has no way of dealing with this
06:35:18 <xenon-> lyxia, but what if you need to use both packages? you are basically screwed
06:35:19 <cads2> hey all, would it be hard to make this code use multiple cores and my GPU to perform the work of filter?   https://gist.github.com/maxsu/abdc8ffd40e2c8bda03a5890303c51d8
06:36:02 <cads2> for the t7 version with 7 variables, it took a hefty 50 seconds to run through, but that is using only 1 core of my machine
06:38:13 <lyxia> xenon-: yes that means the packages are broken
06:38:58 <lyxia> the Haskell community "deals" with this by being vocal about orphan instances being bad.
06:39:29 <xenon-> lyxia, wouldn't a much better way of dealing with it be to allow you to pick an instance during import, if there's a conflict?
06:40:14 <cads2> Also I'm surprised it took nearly a minute to run through 10 million combinations, even on a single core. Could this be due to performing a 7 dimensional string comprehension?
06:41:59 <tdammers> that's pretty much the only way to deal with it
06:42:10 <xenon-> that being what?
06:42:26 <tdammers> allowing orphan instances, but being vocal about them being bad
06:42:32 <tdammers> the alternatives are all worse
06:42:37 <xenon-> why?
06:42:52 <xenon-> import Foo hideInstance (Bar)
06:43:14 <xenon-> import Foo hideInstance (Show Bar)
06:46:40 <lyxia> that's the wrong level at which to fix the problem. The whole typeclass business is based on the assumption that instances are unique.
06:48:36 <lyxia> A language feature whose only purpose is to provide an extremely short-term fix won't be well received.
06:49:01 <xenon-> lyxia, what do you propose as a better, long-term fix?
06:49:14 <cads2> lol, it took 9 minutes to complete the problem - it found two solution: [(4,4,1,9,6,0,1,0),(7,0,0,0,0,0,0,0)]
06:49:16 <lyxia> the packages are broken, so fix them.
06:49:35 <Orbstheorem> what's the name of the bot?
06:49:40 <lyxia> lambdabot
06:49:42 <Orbstheorem> Thanks
06:49:58 <cads2> I'm not going to run the problem for the 9 dimensional versions
06:50:32 <tdammers> one fix would be to abandon the uniqueness of typeclasses, but that would open up a huge rabbit hole
06:51:02 <tdammers> in fact, we can already do something very similar in straight-up Haskell simply by unlifting the typeclass mechanism to the term level
06:51:33 <tdammers> that is, instead of using Haskell's typeclass mechanism to pass typeclass dictionaries around implicitly, we just pass around records as arguments explicitly
06:51:56 <tdammers> so a typeclass mechanism that abandons the uniqueness thing wouldn't really buy us much anymore over that approach, and might as well go away entirely
06:52:21 <tdammers> another option would be to abandon the "open universe", but that, too, would more or less destroy the usefulness of the whole thing
06:53:53 <phadej> I read "one fix would be to abandon the uniqueness of typeclasses" and my instant reaction "what kind of a fix is the one which breaks everything else?"
06:54:08 <xenon-> I'm not sure I see the problem with abandoning the idea that typeclasses are unique. what's wrong with allowing the user to pick one out of multiple instances? how is that different than allowing the user to pick to use (+) from Data.Num or (+) form My.Num?
06:54:43 <phadej> xenon-: for not-so-short answer, watch https://www.youtube.com/watch?v=hIZxTQP1ifo
06:55:31 <phadej> but TL;DR, multiple-instances would make type-classes into something similar but very very different
06:55:59 <opqdonut> I guess how to scope the instance selection is hard
06:56:00 <phadej> xenon-: and in fact, we do pick different instances using `Product` and `Sum`
06:56:15 <phadej> opqdonut: yes, scala implicits is a good example of how difficult it is
06:56:33 <opqdonut> and also, if you have something like "Ord a => Set a", you have to keep track which Ord instance was used
06:56:35 <xenon-> phadej, that's not picking an instance, that's using a different type (with its own unique instance)
06:56:35 <phadej> i doubt there are many people in the world who can describe how "basic scala implicits resolution" works
06:57:15 <phadej> xenon-: I think that's a feature, not a bug: if one wants different instances one uses different types
06:58:24 <csaurus> I am working on a project where I am defining pipelines for some data extraction/transformation/loading - I want to have two versions of all the pipeline combinators, one for bulk ETL and one for on-demand. I was thinking that I could define a monad transformer which holds both types and then selects between them at runtime. I'm wondering if monads are a good fit for this problem, or if there's some other pattern that fits the bill
06:58:24 <csaurus> anyone can suggeste
06:59:20 <xenon-> anyway, until this issue is resolved, as far as good/bad practices goes, do you agree both of these? 1) It's never ok to create orphan instances in published library code 2) It is ok to create orphan instances in your private code
07:00:06 <phadej> xenon-: 1) has pragmatic exceptions, like base-orphans quickcheck-instances e.g.
07:19:45 <c_wraith> orphan instances are at least documented with modern haddock
07:20:42 <c_wraith> like... https://hackage.haskell.org/package/lens-aeson-1.0.2/docs/Data-Aeson-Lens.html#v:-36-fIxedValue
07:21:04 <c_wraith> and that package has a pretty good reason for hosting those orphans.
07:22:15 <c_wraith> ... of course, haddock still doesn't display type instances, which are kind of important!
07:23:49 <c_wraith> I really don't know about that Ixed instance. it sets type instance Indexed Value = Text
07:24:05 <c_wraith> but = Int would have been just as correct.
07:24:33 <c_wraith> I... not sure that instance should exist
07:24:42 <c_wraith> +am
07:27:39 <Taneb> c_wraith: I was wondering that the other day, the instance isn't even really necessary as key exists
07:28:39 <Taneb> (and _Object . ix k)
07:47:28 <xenon-> is anyone using emacs with haskell? there's a very useful haskell-hoogle function that I just found out about. is there something like haskell-auto-insert, that attempts to use output from hoogle to auto-insert imports? it wouldn't be hard to write such a function, but I don't want to reinvent the wheel
07:56:44 <Solonarv> xenon-: emacs is a fairly popular editor around here; I wouldn't be surprised if one of the haskell plugins for it had that function
08:13:14 <Ferdirand> little question about fundeps
08:13:20 <Ferdirand> class Monad m => MonadState s (m :: * -> *) | m -> s
08:13:38 <Ferdirand> what happens if I nest two StateT's ? 
08:14:05 <Taneb> Ferdirand: like StateT s (StateT s' m) a?
08:14:13 <Ferdirand> exactly
08:14:19 <Taneb> Ferdirand: that ends up with state of type s
08:14:46 <Ferdirand> i can still access the s' using lift, no ?
08:14:58 <Ferdirand> but I have to lift explicitely
08:15:00 <Taneb> Ferdirand: because the MonadState instance for StateT is "Monad m => MonadState s (StateT s m)", which doesn't care what the inner monad is
08:15:07 <Taneb> And yeah, you can lift explicitly
08:15:36 <Taneb> lift :: StateT s' m a -> StateT s (StateT s' m) a
08:15:55 <Taneb> Ferdirand: fundeps don't change anything abou this
08:16:15 <Ferdirand> okay maybe State was not the proper example
08:17:57 <Ferdirand> the point of MonadState is to allow get/put/state to operate on things that may be transformers over a StateT, right ?
08:18:08 <dminuoso> Ferdirand: No.
08:18:23 <Ferdirand> ah
08:18:28 <Ferdirand> what is it, then ?
08:18:28 <dminuoso> Ferdirand: mtl has a very misleading name.
08:18:42 <dminuoso> Ferdirand: it's the generic interface over monadic things that have a notion of state.
08:19:06 <dminuoso> transformers that have State layered in are *one* group of such things, but plenty of non-transformers fit too.
08:19:07 <Ferdirand> okay, fair enough, there might be other monads that have a notion of state
08:19:11 <dminuoso> Exactly.
08:21:26 <Ferdirand> let's take one step back: would a type like "StateT s (StateT s' m) a" ever make sense ?
08:21:49 <Ferdirand> run some local-stateful computations that also have access to a global state ?
08:22:26 <vaibhavsagar> sure
08:22:31 <Ferdirand> with well-defined points where you want to create or destroy a local state, passing the global one through
08:22:33 <vaibhavsagar> at least I think so
08:22:51 <Ferdirand> i mean i'm asking because i have the use case, but i'm wondering if maybe i'm doing this terribly wrong
08:23:08 <vaibhavsagar> seems legit to me
08:23:22 <vaibhavsagar> but I think that means you can't use mtl
08:23:37 <Taneb> It's equivalent to StateT (s, s') m a
08:23:39 <vaibhavsagar> this is doable with transformers directly though
08:23:40 <Ferdirand> i can hack around conversion from and to a StateT (s,s')
08:23:49 <Taneb> And you can use "zoom" from lens to do that
08:23:55 <Ferdirand> yes
08:24:23 <Ferdirand> but i was dreaming that if my s and s' types are distinct enough, instance resolution might be smart enough to let me omit the lifts
08:24:57 <dmwit> Not in Haskell. Sorry.
08:25:15 <Taneb> Sadly, it's very hard to do that without it being unbearable when their *not* distinct enough
08:25:16 * hackage libraft 0.3.0.0 - Raft consensus algorithm  https://hackage.haskell.org/package/libraft-0.3.0.0 (sdiehl)
08:26:04 <lyxia> well, nothing prevents you from experimenting with a copy of MonadState without the fundep
08:26:18 <dminuoso> Ferdirand: What you said about MonadState applies to all of mtl by the way. The whole library is not about transformers anymore.
08:27:19 <Ferdirand> i'm not sure I understand what that means
08:27:48 <dminuoso> Ferdirand: https://blog.jle.im/entry/mtl-is-not-a-monad-transformer-library
08:28:37 <xenon-> Warning: The following modules should be added to exposed-modules or other-modules ...  Missing modules in the cabal file are likely to cause undefined reference errors from the linker, along with other problems.
08:28:46 <xenon-> what is up with that? I always ignored that warning, and never had problems
08:29:15 <xenon-> why do I need to put a non-exposed module to other-modules? what does that accomplish, besides shutting this warning up?
08:29:18 <Ferdirand> dminuoso: okay, I get that, but
08:29:31 <merijn> xenon-: You never had problems because you never packed and distributed your code :p
08:30:01 <cads2> hey dmwit, is there anyone around that knows a bit of haskellish GPU wrangling? I have an embarrassingly parallel problem which runs embarrassingly slowly on a single cpu core, while in the meantime about 1092 cuda cores sit embarrassingly idle!
08:30:03 <merijn> xenon-: All modules used in an executable/library *must* be listed in either exposed-modules or other-modules
08:30:13 <Ferdirand> why would I want to write my own combined effect monad when I can get the FMA instances for free by plopping transformers together ?
08:30:19 <xenon-> merijn, so if I put my code to hackage, people would be getting linking errors?
08:30:24 <merijn> cads2: Something, something, Futhark, ask Athas ;)
08:30:38 <dminuoso> Ferdirand: FMA?
08:30:49 <merijn> xenon-: It won't even upload right, becuase it will not pack the source code in the tarball
08:30:52 <Ferdirand> functor/applicative/monad FAM sorry
08:31:04 <dminuoso> Ferdirand: The point of mtl is not transformers.
08:31:04 <xenon-> ok
08:31:13 <cads2> merijn, thanks!
08:31:32 <merijn> cads2: Also the accelerate library
08:31:34 <dminuoso> Ferdirand: It's basically an effect system. 
08:31:52 <xenon-> what is hackage's policy on uploading personal libraries? for example, I have xenon package, with a bunch of helper functions I wrote over the past, that probably wouldn't be intersting to anyone but me
08:31:54 <dminuoso> Ferdirand: (MonadIO m, MonadState m) => ... says you are using IO and State effects. 
08:32:16 <merijn> xenon-: Hackage is intended for packages that are supposed to be "generally useful"
08:32:39 <merijn> xenon-: So if the library isn't interesting to anyone else, that's maybe not the right thing for Hackage
08:33:02 <xenon-> what if I also upload a useful library that depends on xenon package?
08:33:04 <cads2> merijn, Futhark looks amazing!
08:33:16 <dminuoso> Ferdirand: It doesn't really say what you are working on. Perhaps your principle type is: data YourIO s a = YourIO (IORef s) (IO a)
08:33:28 <dminuoso> Clearly Im not using any monad transformers there.
08:34:00 <dminuoso> Okay the example sucked abit.
08:34:11 <Solonarv> dminuoso: don't you mean 'IORef s -> IO a'? I don't think (IORef s, IO a) is even a monad
08:34:19 <dminuoso> Solonarv: Yeah. :)
08:34:34 <cads2> futhark link (apparently futhark is some kind of old rune, and this url is like the 20th down): https://futhark-lang.org/performance.html
08:34:49 <dminuoso> Solonarv: It's clearly not for being unable to implement pure heh.
08:34:51 <cads2> acceleratehs.org looks cool too, thanks again merijn 
08:35:02 <merijn> xenon-: This is why many people avoid making "utility" libraries and just inline small utility things in the libraries
08:35:23 <Solonarv> dminuoso: I was thinking along the lines of "IORef s isn't a monoid", but same thing really
08:35:45 <xenon-> merijn, that leads to code duplication
08:35:57 <dminuoso> Solonarv: You could make it a trivial semigroup though.
08:36:00 <merijn> xenon-: What sorta stuff does your utility lib have?
08:36:17 <dminuoso> Solonarv: So it boils down to IORef is not Pointed.
08:36:47 <tsaka__> How to make a BigFloat type with 100 points of precision? https://paste.ofcode.org/MFSBudbEsZVHMzmqjZmPKY
08:36:51 <Ferdirand> dminuoso: okay, but that seems orthogonal to my issue
08:37:28 <dminuoso> Ferdirand: I was just pointing out that your observation regarding "MonadState not being about StateT" can be generalized.
08:37:38 <Solonarv> Ferdirand: it is, we were just quibbling about dminuoso's example
08:37:41 <adamCS> I have a cabal file which has a library stanza (hs-source-dirs: src) and an executable (hs-source-dirs: app) stanza.  There is just one module (MyLib.MyModule) in the library.  When I do "cabal v2-build exe:<appName>" it works fine.  But when I do "cabal v2-repl exe:<appName>", I get a warning about not specifying "MyLib.MyModule" in "other-modules" and an error about a missing dependency.  I think that v2-build is doing
08:37:41 <adamCS>  things correctly but v2-repl is somehow not getting the library module from the library but instead as an unspecified "other-module" of the exe.  Anyone seen this before?   
08:37:50 <WilliamHamilton[> heath: ping!
08:38:04 <xenon-> merijn, lets take Xenon.String for example, a few dozen String functions I commonly use: capitalize, stripLeft, stripRight, strip, etc. then for list, takeFromEnd, splitFromEnd, etc. not enough functions to make a library that would be considered generally useful, but certainly not something I would want to copy/paste in my every project
08:38:29 <merijn> xenon-: Most of those already exist, though? And the ones that don't are in split? :)
08:38:36 <merijn> @hackage split
08:38:36 <lambdabot> http://hackage.haskell.org/package/split
08:38:48 <Ferdirand> i'd like to nest two types of state, avoid manual lifting, and avoid writing monad instancds by hand
08:38:57 <merijn> xenon-: tbh I find stripLeft/stripRight to be below the Fairnbairn threshold
08:39:03 <Ferdirand> but this seems to be 3-choose-2
08:39:04 <dminuoso> Ferdirand: Mind my asking, whats wrongwith writing a monad instance by hand?
08:39:07 <xenon-> merijn, there's only one split function above. I don't think think split has that one
08:39:28 <Ferdirand> dminuoso: i dunno. it's boilerplate :/
08:39:38 <dminuoso> Ferdirand: How many types would you need to write it for?
08:39:49 <Solonarv> Ferdirand: note that you can often get instances for free via GND/DerivingVia 
08:41:03 <Ferdirand> yeah i tried that already
08:41:18 <Ferdirand> which brought me to the fundep issue
08:41:19 <Solonarv> e.g.: newtype YourIO s a = YourIO (IORef s -> IO a) deriving (Functor, Applicative, Monad, MonadIO) via ReaderT (IORef s) IO a
08:41:27 <xenon-> merijn, I don't think there's much point in discussing the usefulness of individual functions (that I used as examples), or whether they exist somewhere (if they do, I did not know at the time I wrote them). I have 65 modules in my personal library, and between several hundred and thousand functions
08:41:50 <Solonarv> if you want multiple states I'd go with a (s, s') state and use Control.Lens.Zoom
08:42:10 <dminuoso> `ReaderT (IORef s)` is one of the cooler things. :)
08:42:15 <Ferdirand> but then i have to zoom instead of list
08:42:19 <Ferdirand> lift*
08:42:47 <merijn> xenon-: Essentially this boils down to the similar problem of "almost no one actually uses custom preludes, because of the extra dependency"
08:42:47 <Ferdirand> ah
08:42:52 <Ferdirand> wait
08:43:26 <Ferdirand> i can use a custom typeclass to hide the zoom maybe
08:43:31 <xenon-> merijn, if hackage encourages people to inline such small functions in every project, I think that encourages code duplication, and discourages people like me to upload something
08:44:05 <Ferdirand> i guess it's not worth the headache
08:44:10 <Ferdirand> zoom it will be
08:44:15 <dminuoso> merijn: It's really interesting how custom preludes was something that seemed interesting in the beginning when I was just trying to "do everything right" and "work on best practices"
08:44:15 <Ferdirand> thanks all !
08:44:17 <merijn> xenon-: tbh, I've never really encountered duplicating any substantial amount of code
08:44:53 <maerwald> code duplication is fine
08:44:56 <dminuoso> merijn: A lot of it was bad habits from the JavaScript time.
08:45:30 <xenon-> maerwald, especially when you have to fix the bug you copy/pasted to several different places
08:45:56 <maerwald> When it's "deduplicated" the bug creeps into more codebases :)
08:49:48 <vaibhavsagar> xenon-: I'd recommend against putting a helper library on Hackage, but there is already http://hackage.haskell.org/package/extra so I guess you can really do anything you want
08:51:31 <rfold> Hi, I'm compiling with -fllvm, but I'm getting "Warning: Couldn't figure out LLVM version! Make sure you have installed LLVM 6.0" and "ghc: could not execute: opt" but when I run opt from the same command line it just works, and the version is 6.0.0. Is there a way to get more information about the error with GHC 8.6.3?
08:53:37 <xenon-> what about Extra.String, vs Data.String.Extra? I guess hackage encourages the latter naming convention?
08:54:16 <lyxia> Data and Control are quite meaningless now.
08:55:09 <lyxia> MyLib.MyModule is nicely predictable.
08:55:13 <dminuoso> Interesting, hierarchical modules were not originally in Haskell 98.
08:56:41 <earldouglas> Does anyone here know how to use [ci skip] on Cabal pull requests?  My PRs both triggered CI, which isn't needed for docs-only changes.
08:56:52 <Solonarv> xenon-: If you're going to put a personal utility library on hackage, at least make its name sufficiently unlikely to be taken - I wouldn't name it 'xenon', for example
08:57:49 <xenon-> Solonarv, extra2? :-D
08:57:59 <Solonarv> xenon-: it's perfect! :P
09:18:47 * hackage yesod-core 1.6.12 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.6.12 (MichaelSnoyman)
09:27:48 <untseac> hey. I have a silly question. Do you say "define a function", "declare a function" or something else?
09:28:15 <untseac> according to lyah a definition is a function that doesn't take parameters
09:28:26 <untseac> I don't really care that much, it's just out of curiosity
09:28:44 <Lears> Either is OK, but imo declare is better. This shouldn't have anything to do with parameters though.
09:29:06 <untseac> ok, thanks Lears 
09:29:16 <xenon-> all function take (a single) argument. so a function that doesn't take any, isn't a function :P
09:29:50 <untseac> yeah I also thought it was silly for lyah to say a function without arguments is still a function but whatever I guess
09:30:27 <untseac> it was probably just to be easier to understand. the whole book is meant to be easy to read
09:31:04 <Lears> It's a little /too/ easy to read. Do you have another resource that actually gives you exercises?
09:31:16 <Solonarv> "everything is a function" is one of those things people like to believe about Haskell even though it isn't actually true
09:31:18 <ski> failing to make important distinctions might be easier
09:31:19 <xenon-> was it talking about IO actions? like getLine
09:31:23 <xenon-> :t getLine
09:31:24 <lambdabot> IO String
09:31:29 <xenon-> ^^ not a function
09:31:35 <Solonarv> http://conal.net/blog/posts/everything-is-a-function-in-haskell <- a post
09:31:35 <xenon-> :t putStrLn
09:31:37 <lambdabot> String -> IO ()
09:31:38 <xenon->  a function
09:31:59 <Solonarv> xenon-: getLine actually *is* a function internally... a better example would be '5', or "hello"
09:32:02 <untseac> Lears, I have read real world haskell too. I'm just reviewing some stuff and lyah is shorter than rwh
09:32:04 <ski> Solonarv : i wonder whether it's partially because of the slogan "everything is an object" that's sometimes heard in OO
09:32:15 <Solonarv> ski: that certainly seems to be related
09:32:30 <ski> itym `putStrLn' is a function. `getLine' isn't
09:32:40 <Solonarv> even though it isn't true in many OO languages either! It certainly isn't in Java, for example
09:32:47 * hackage rating-chgk-info 0.3.6.3 - Client for rating.chgk.info API and CSV tables (documentation in Russian)  https://hackage.haskell.org/package/rating-chgk-info-0.3.6.3 (MZiatdinov)
09:32:56 <Solonarv> ski: no, I meant getLine; I said "internally" for a reason
09:33:24 <ski> ok, but that depends on implementation details
09:33:36 <xenon-> Solonarv, does it matter what it is internally/ that is implementation detail. from haskell's perspective, getLine is not a function
09:33:44 <untseac> well not everything being a function is just an unfortunate reality of legacy code
09:34:24 <Solonarv> Indeed. But it's still a bad example for "not everything is a function", because it is a function in a much more concrete sense than 5 or "hello"
09:34:29 <lyxia> that definitely has nothing to do with legacy
09:34:33 <Solonarv> untseac: read the post I linked
09:34:39 <Solonarv> It has nothing to do with legacy
09:34:48 * ski would say a value of type `State Blah T' is not a function
09:34:58 <ion> "hello" is not a function because of an unfortunate reality of legacy code? In the perfect utopia, what should "hello" take as a parameter and return as the result?
09:35:16 <untseac> if then else could be a function, right?
09:35:17 * hackage th-nowq 0.1.0.3 - Template Haskell splice that expands to current time  https://hackage.haskell.org/package/th-nowq-0.1.0.3 (DmitryDzhus)
09:35:24 <untseac> I mean, why not?
09:35:27 <ski> untseac, yes. iirc, it is, in Clean
09:35:29 <ion> @type bool
09:35:31 <lambdabot> a -> a -> Bool -> a
09:35:33 <xenon-> Solonarv, is LYAH arguing that everything is a function, or is it just calling IO actions functions? btw, 5 can be a function :-P
09:35:59 <untseac> lyah just says this: When a function doesn't take any parameters, we usually say it's a definition (or a name)
09:36:04 <Solonarv> xenon-: I don't know what LYAH says, I did read it but I tried to forget it
09:36:15 <untseac> it's not exactly calling everything a function but it is implying something like that
09:36:27 <Solonarv> untseac, ski: there's an ifThenElse somewhere in base too
09:36:27 <xenon-> same. it started fun, but got really confusing in the middle
09:36:53 <Solonarv> :t ifThenElse
09:36:54 <lambdabot> error: Variable not in scope: ifThenElse
09:37:43 <Solonarv> it's used in desugaring: 'if p then x else y' -> 'ifThenElse p x y'; you can supply your own ifThenElse by enabling RebindableSyntax
09:38:56 <ski> @pl ifThenElse p x y = if p then x else y
09:38:57 <lambdabot> ifThenElse = if'
09:40:34 <Lears> % let false = \t f -> f; true = \t f -> t; ifThenElse = id; in if true then "true" else "false"
09:40:35 <yahb> Lears: "true"
09:40:56 <Lears> Cool stuff. I didn't realise RebindableSyntax covered if-then-else.
09:41:37 <Solonarv> % let ifThenElse = id in if (++) then "hello" else "world"
09:41:38 <yahb> Solonarv: "helloworld"
09:42:03 <untseac> Solonarv, well there you have it, haskell could have less keywords (but if then else is convenient). I'm reading the link you sent and indeed values don't make much sense to be non argument functions. Interesting stuff.
09:46:46 * hackage term-rewriting 0.4 - Term Rewriting Library  https://hackage.haskell.org/package/term-rewriting-0.4 (BertramFelgenhauer)
09:52:17 * hackage term-rewriting 0.4.0.1 - Term Rewriting Library  https://hackage.haskell.org/package/term-rewriting-0.4.0.1 (BertramFelgenhauer)
09:57:56 <xenon-> I think I found a bug in either stack or cabal. if I add a flag in cabal's ghc-options line project is not recompiled, until I also modify one of the source files.
10:00:47 * hackage servant-xml 1.0.1.3 - Servant support for the XML Content-Type  https://hackage.haskell.org/package/servant-xml-1.0.1.3 (fosskers)
10:05:26 <kmelvn> how can I use `makeLenses` with records like `data Foo = Foo { fooSomeField :: Int }`? All my data types have fields in camel case and prefixed with type name
10:06:26 <xenon-> kmelvn, makeLensesWith camelCaseFields
10:06:31 <kmelvn> I know I should use `makeLensesWith` and pass in a configuration, but it's kind of confusing for a beginnre
10:06:45 <kmelvn> think I tried that, let me check ...
10:06:53 <xenon-> I use that all the time
10:07:53 <xenon-> fields must be prefixed with name of the type (which is what you have done in above example)
10:08:25 <kmelvn> oh, it does work - but it's not exactly equivalent to just `makeLenses ``Foo`
10:09:04 <kmelvn> one uses types classes and `HasName` ... the other does not
10:09:44 <glguy> kmelvn: You can get the normal makeLenses behavior with a different rule
10:09:45 <kmelvn> but I guess it doesn't matter that much... hopefully :) still don't know what are the trade offs in approach...
10:09:58 <glguy> these two things are independent
10:10:28 <glguy> The camel case naming rule is available 'camelCaseNamer :: FieldNamer'
10:10:36 <xenon-> kmelvn, this allows different types to share the same lens. so if you also had barSomeField, someField lens would work with both types
10:10:48 <kmelvn> is there an incantation that can create lenses for records with existential types? nothing I've tried works... and Google seems to indicate that it just doesn't work
10:11:04 <glguy> No, lenses don't make as much sense with that case
10:15:37 <kmelvn> thanks folks :)
10:15:46 <kmelvn> btw, the top example on http://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-TH.html does not compile?
10:15:56 <kmelvn> The `data Foobar ....`
10:16:05 <kmelvn> without some extensions or something else?
10:16:27 <phadej> it needs {-# LANGUAGE TemplateHaskell #-}
10:17:20 <kmelvn> phadej: actually I thought it needs DuplicateRecordsFields, but it seems to work without it...
10:17:36 <kmelvn> how can it work without it when two fields share a name? `_x`?
10:18:25 <glguy> kmelvn: DuplicateRecordFields is for duplicates across different datatype declarations, not within a single on
10:18:27 <glguy> one*
10:19:50 <phadej> the type of _x is :: Foo -> Int
10:20:01 <phadej> it would fail if _x fields had different types
10:20:08 <kmelvn> oh, I thought there would be some conflict between `_x` under Foo and `_x` under Bar ...
10:20:35 <kmelvn> now I get it :) silly, I've never used those kind of types...
10:20:44 <phadej> that example is there to illustrate that makeLenses makex x :: Lens, but y :: Traversal
10:21:04 <phadej> because x is in all constructors, y only in the first one
10:22:13 <kmelvn> yup, thanks, it's starting to make sense :)
11:06:13 <reygoch> can I only have one source-repository-package
11:06:13 <reygoch>  pragma in my cabal.project file?
11:07:06 <Solonarv> pretty sure you can have as many as you want
11:07:18 <reygoch> I'm getting some weird errors when I do
11:07:34 <reygoch> concretely: "fatal: '--detach' cannot be used with '-b/-B/--orphan'"
11:09:22 <Solonarv> reygoch: can you post your full cabal.project file and the full error?
11:09:32 <reygoch> sure, just a sec
11:11:34 <reygoch> Solonarv: https://pastebin.com/adxAXqfX
11:11:53 <reygoch> Solonarv: I've included the command I've run and the error at the bottom
11:14:05 <Solonarv> Huh, that's weird. Have you tried running cabal from a different shell (e.g. cmd, or mingw bash)?
11:14:47 <reygoch> just a sec, I'll try
11:16:45 <reygoch> Solonarv: nope, same error in both cmd and bash
11:19:30 <Solonarv> reygoch: try running cabal with -v2 so you can see which subcommand is failing, then
11:22:07 <reygoch> Solonarv: so, it seems like author of squeal set the `dev` branch to be the main branch, and `master` is used for releases and this configuration is somehow messing things up, because if I set `dev` branch in my cabal file than it works.
11:22:44 <Solonarv> Ah, that makes sense I suppos
11:22:46 <reygoch> Solonarv: weird, I guess this is worth reporting to cabal issues.
11:27:19 <xtsee> j ##security
12:09:22 <ph88> hey guys, does anyone ever heard of something to build a database of knowledge (like prolog) from haskell code? For example when you have in haskell  MyFunction a b = a || b    to prolog: myFunction(A,B):- is_true(A) ; is_true(B)     The goal is to reason about possible inputs given an output on simple cases of boolean logic and perhaps a bit more complex cases where the computer can spend some time to calculate them
12:10:59 <ph88> if i could read haskell source code as data perhaps i can translate it into some relational logic? Has something like this been done yet?
12:15:15 <sm> SourceGraph, hlint are some things that analyse haskell code
12:22:25 <shapr> hgrep does a bit of that https://teh.id.au/posts/2017/10/03/announcing-hgrep/index.html
13:00:05 <reygoch> So, I have a problem with cabal 2.4.1 when I'm trying to build haskell-chart locally. It has a cabal project with chart, chart-gtk and some other packages for the ecosystem. If I run cabal new-build Chart it first tries to build Chart-gtk which I'm not interested in. Only when I delete cabal.project file and enter the Chart dir and run cabal new-build will it actually start building Chart package. Is this intended behaviour or a bug?
13:06:58 <tabaqui> Hey all
13:07:13 <tabaqui> do you know some good howto for constraints library?
13:07:20 <tabaqui> and deferrable constraints in particular
13:08:39 <tabaqui> I didn't find usefull "Gradually typed DSLs with Deferrable constraints in Haskell"
13:08:46 <tabaqui> maybe because there is no sound :)
13:18:27 <ardin_agoy> how fast can you type?
13:32:25 <suzu> 200wpm
13:33:57 <ardin_agoy> suzu: aRE YoU hUmAN?
13:35:11 <suzu> no
13:35:58 <ardin_agoy> suzu: h0w d1d y0u g3t 2o0 w9m?
13:36:11 <suzu> press 'a' and the spacebar real fast
13:36:16 <suzu> ez 200wpm
13:36:35 <Lycurgus> 200 wpm is not unheard of 
13:37:00 <Clint> i've heard of it
13:37:03 <ardin_agoy> how do i just get half of that?
13:37:05 <Lycurgus> people can type faster than they should be able to 
13:37:11 <suzu> practice
13:37:12 <Lycurgus> it's a well known thing
13:37:17 <suzu> correct practice
13:37:18 <systemfault> Too bad that 25 WPM is actually fast enough for most developers.
13:37:20 <suzu> also maybe switching to dovrak helps
13:37:24 <suzu> dvorak*
13:37:25 <ardin_agoy> there must be secrets
13:37:44 <dminuoso> systemfault: Most programmers are not bottlenecked by their typing speed.
13:37:52 <systemfault> Right
13:37:57 <systemfault> Myself included.
13:38:01 <suzu> yeah they're actually bottlenecked by not using haskell
13:38:02 <kadoban> IME dvorak isn't really any faster. It's more comfortable, but ... speed I'd think you'd gain some other way
13:38:05 <suzu> :D
13:38:05 <Lycurgus> i think most developers can do at least 40 if they've been working decades
13:38:12 <dminuoso> I spend more time reading, deleting, compiling, debugging, in meetings, 
13:38:37 <kadoban> If your typing form is absolute trash, like you're 2-finger-pecking or something, maybe just practicing at actual typing would be worth it.
13:39:04 <Lycurgus> if you're still looking at the keys, something is wrong
13:39:17 <dminuoso> If you're still looking at any part of your computer, something is wrong.
13:39:22 * ardin_agoy must look at the f keys
13:39:26 <suzu> if your eyes are open, something is wrong
13:39:34 <dminuoso> If you know where the keys are, you don't need to look at your screen either.
13:40:46 <DigitalKiwi> i dnt evn have a ontior i just type what i want
13:40:58 <untseac> this is a weird conversation. Most programmers don't look at the keyboard and type fast. Also typing very fast isn't really that important in programming. Just my opinion.
13:41:16 <hyperisco> So do you use text-to-speech to read IRC chat?
13:41:21 <untseac> it's much more important to think before typing
13:41:22 <kadoban> Typing very fast isn't important. Typing ... not very slow is useful.
13:41:46 <untseac> kadoban, fair enough
13:42:15 <ardin_agoy> if you think before typing you can use a cat as your editor
13:42:36 <untseac> lol or ed or whatever it was called
13:42:42 <Clint> ed is still called ed
13:42:44 <untseac> that really weird one
13:42:46 <zachk> does TAPL by benjamin pierce, deal with interpreters, compilers, or both? 
13:42:48 <hyperisco> Real programmers use echo.
13:43:27 <ardin_agoy> printf can handle ansi escape codes
13:43:30 <untseac> I still wonder what was the point of ed. Was it network constraints?
13:43:34 <DigitalKiwi> cats make really bad editors they are not good at english and are bad typists
13:43:55 <zachk> terminals used to be character and line based and print stuff to paper 
13:44:05 <ardin_agoy> cats are like swiss pocket knives
13:44:10 <zachk> dog is my favorite editor
13:44:22 <untseac> I'm of the IDE era so I wouldn't know the point of ed. Call me a millenial if you want.
13:45:00 <DigitalKiwi> ed is the standard
13:45:04 <ardin_agoy> they use seeing eye dogs for computer vision
13:45:28 <Clint> i also used an IDE in the '80s
13:45:35 <untseac> ed? I thought it was vi
13:45:46 <untseac> huh I guess I was wrong
13:45:56 <ardin_agoy> vi vi vi = 666
13:46:27 <kadoban> vi is the new ed
13:46:34 <hyperisco> Not using Notepad for editing programs is also useful.
13:46:39 <untseac> well I use neovim
13:46:48 <iqubic> Emacs is better.
13:46:55 <ardin_agoy> emacs lets you do fp while using dysfunctional languages
13:47:01 <kadoban> neovim is quite nice
13:47:17 <untseac> eh.. I prefer neovim. I don't mind emacs though.
13:47:29 <DigitalKiwi> evil mode
13:47:39 <iqubic> evil mode is what I use.
13:47:54 <untseac> Clint, which IDE? Emacs doesn't count.
13:47:54 <dminuoso> emacs with evil mode.
13:48:13 <untseac> just out of curiosity
13:48:28 <untseac> I'm of the Eclipse era
13:48:29 <suzu> tfw you add freer effects to your project and now the build time is like 3x
13:48:34 <suzu> uhgghghggrhhghg
13:48:36 <suzu> GHC y u do this
13:48:49 <Clint> untseac: i was going to say TurboVision but I guess i'll have to think back further
13:48:51 * ardin_agoy uses unconfigured emacs
13:49:17 <Lycurgus> turbo was a thing (with IDEs) in the 80s
13:49:43 <untseac> Clint, tbh I don't know the difference between an IDE and a text editor with a lot of plugins. It's the same thing to me.
13:49:46 <Lycurgus> (pascal, c, prolog, etc)
13:51:00 <hyperisco> untseac, in IDEs you have project/solution/whatever files
13:51:55 <hyperisco> nowadays it is more fashionable to "open directory" and that's your project
13:52:28 <ardin_agoy> yi editor is written in haskell
13:53:03 <Lycurgus> and was embedded in leksah till they gave up on that
13:53:22 <hyperisco> and good riddance because the last thing I am interested in is another layer on top of the build system
13:54:14 <wroathe> hyperisco: You should give web development a shot
13:54:30 <hyperisco> why do you think I haven't?
13:54:56 <ardin_agoy> how do you hack js?
13:55:05 <wroathe> hyperisco: You probably have. I was just pointing out that if you want build system hell modern Javascript toolchains are as bad as anything
13:57:37 <dminuoso> wroathe: I tried putting all my rage about the JavaScript build ecosystem into an npm package, but I couldn't build the webpack project with gulp, babel, browserify because require.js interfered with grunt. After installing a middleware to run my jest driven mocha tests in jasmine and enzyme sprinkled ontop, I realized I was getting mad.
13:58:13 <wroathe> dminuoso: That sentence makes me want to hurt people
13:58:19 <ardin_agoy> was it left pad?
13:59:19 <ardin_agoy> https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/
14:01:32 <untseac> hyperisco, yeah I also prefer the text editor way
14:06:47 * hackage spectral-clustering 0.3.0.0 - Library for spectral clustering.  https://hackage.haskell.org/package/spectral-clustering-0.3.0.0 (GregorySchwartz)
14:15:16 * hackage hierarchical-spectral-clustering 0.3.0.0 - Hierarchical spectral clustering of a graph.  https://hackage.haskell.org/package/hierarchical-spectral-clustering-0.3.0.0 (GregorySchwartz)
14:16:03 <Denommus> hey
14:16:06 <Denommus> I'm trying to generate an infinite random list, but with one catch
14:16:33 <Denommus> the range to generate the new number is based on the previous number
14:16:48 <Denommus> and there's a minimum and maximum range acceptable
14:17:20 <Denommus> this is what I tried: https://gist.github.com/Denommus/d606e7c1b0163018c48c1a72fc6604b1
14:17:29 <Denommus> but take 10 randomList does nothing
14:17:40 <Denommus> I mean, take 10 <$> randomList
14:18:07 <geekosaur> putting it in IO more or less makes it strict, so it's trying to generate the entire infinite list..
14:18:10 <Denommus> what am I doing wrong?
14:18:28 <geekosaur> stuff the StdGen into a State or something instead of using the one hidden in IO
14:19:11 <geekosaur> e.g. randomR with a StdGen parameter, instead of randomRIO. (see also the MonadRandom package which can do this for you)
14:27:13 <zachk> Denommus, I think you ranges will converge towards smaller and smaller ranges over time
14:29:22 <zachk> your ranges, even 
14:29:48 <kadoban> Will they? Doesn't look like it can get smaller than [0.7, 1.2]
14:39:07 <Denommus> yeah, they won't
14:39:24 <Denommus> but nevertheless I cannot generate the list
14:39:35 <Denommus> I just tried MonadRandom instead, but no change
14:47:24 <lyxia> Denommus: your accumulate is strict in the accumulator
14:50:21 <Gurkenglas> Why aren't non-exhaustive case matches in do blocks handled by MonadFail?
14:50:40 <Denommus> lyxia: how would I make it lazy?
14:50:52 <Denommus> I tried both foldrM and foldlM and it still tries to evaluate strictly
14:51:30 <Amras> have you replaced RandomRIO?
14:52:25 <Denommus> Amras: yes, I'm trying MonadRandom now
14:52:50 <Denommus> just updated my gist
14:53:00 <Denommus> is MonadRandom also strict, perhaps?
14:54:31 <lyxia> MonadRandom is a class
14:54:40 <lyxia> how strict it is depends on the instance
15:01:09 <lyxia> also it seems even the lazy RandT is not lazy enough for some reason.
15:02:44 <suzu> so, (r -> ) is a monad
15:02:57 <suzu> can i make (r -> m) where m (* -> *) a monad?
15:03:10 <suzu> such that (r -> m) a = (r -> m a)
15:03:12 <Denommus> I updated the gist with a new implementation not using IO at all
15:03:26 <Denommus> it still doesn't evaluate
15:03:37 <Denommus> again, tried both foldl and foldr
15:03:40 <Denommus> maybe... foldl'?
15:03:41 <Solonarv> suzu: yes, but you need a newtype wrapper to make things line up
15:03:52 <suzu> ok. how do i do that?
15:03:59 <lyxia> Denommus: https://gist.github.com/Lysxia/d64bbfc4f7acb25a315f5ca605dd2ddc
15:04:17 <Solonarv> % newtype FunctionM r m a = FunctionM (r -> m a) -- suzu
15:04:17 <yahb> Solonarv: 
15:04:40 <suzu> oic
15:04:55 <Solonarv> better known under the name 'ReaderT'
15:05:40 <Denommus> lyxia: what is "choose"?
15:05:57 <Denommus> found it
15:06:35 <Denommus> thanks
15:07:27 <wroathe> I like to imagine that Haskell is the Snorlax of programming languages
15:08:04 <lyxia> Oh. I found what I missed. I was using evalRandTIO instead of evalRandIO...
15:08:30 <lyxia> Denommus: https://gist.github.com/Lysxia/ddf1ea3bb3b81cb7b6965a387c044984
15:09:17 <MarcelineVQ> wroathe: y
15:09:49 <wroathe> It's lazy
15:10:14 <wroathe> You've gotta poke it with an IO stick to make it do anything
15:11:54 <MarcelineVQ> a windy stick
15:12:03 <Denommus> lyxia: not having to depend on Test.QuickCheck is better, thanks
15:13:26 <lyxia> Denommus: the Gen monad is much more fun in the kind of infinite structures it can generate though.
15:15:06 <Arney> why is doing http(s) requests with haskell so artificially complicated?
15:15:20 <wroathe> Arney: We need code
15:15:39 <Arney> wroathe: i just google'd because i wanted to make a thing that is really easy in ruby in haskell ( to learn )
15:15:53 <Arney> i was really happy in seeing how haskell does http request
15:16:04 <Arney> but why the fuck is it so complicated to wrap that somehow in tls?
15:17:09 <Arney> well to be fair, that part of ruby standardlibrary does also suck.. but why does http core lib stuff has to suck, i don't get it
15:20:10 <wroathe> Making an http request with base probably would suck (if it's even possible), and if that's what you're doing then godspeed my friend
15:20:20 <nvt> how could I print a float value returned by a function here: putStrLn (funcThatReturnsFloat arg)
15:20:38 <Arney> wroathe: no, i mean HTTP.Client
15:20:42 <wroathe> But if you're using a non-base package then you'd have to be specific about what sucks
15:20:51 <Arney> why is it so hard to get tls support in that.. that should be transparent
15:21:09 <Arney> i'd rather open the socket myself, and use a already-made tls function to wrap it (so it's http)
15:21:14 <Arney> than do this weird tlsManager crap
15:21:41 <Arney> nvt: prefix it with show
15:21:51 <Arney> or more precicely, call show on it
15:22:16 <Arney> >putStrLn $ show 0.5
15:22:24 <MarcelineVQ> alternatively 'print' which is putStrLn . show
15:22:27 <nvt> yeah I think I missed some parentheses
15:22:40 <Arney> putStrLn (show 0.5) if you like parenthesis
15:22:49 <nvt> thx
15:24:12 <wroathe> Arney: I think http-client is regarded as being somewhat "low level" even though it's pretty simple. The "req" package builds on top of it and provides an even simpler API.
15:25:18 <wroathe> http://hackage.haskell.org/package/req-2.0.0/docs/Network-HTTP-Req.html
15:32:59 <Arney> wroathe: yeah but doesn't lead something like this to package constellations á la nodejs
15:33:09 <Arney> having extra second level packages for that
15:33:12 <Arney> simple task
15:33:53 <wroathe> Arney: AFAIK that wasn't orchestrated ahead of time by the package authors. The author of http-client had one API in mind, and the author of req had a different vision.
15:33:58 <suzu> Solonarv: no way of doing it without a newtype?
15:34:11 <Arney> wroathe: what's the point of having something low-level if it's abstraction can't make you easily usue it
15:34:23 <Arney> a.e. "that's my socket, that's my socket with tls.. do http on it"
15:34:41 <Arney> or is that what happens in the eternals... the Network.HTTP implementing the protocol, which then is used by req or whatever
15:34:51 <wroathe> Arney: http-client's API was probably snoyman's idea of a simple API
15:34:55 <Arney> internals*, they might be ternal though
15:35:14 <Arney> wroathe: yeah it can be simple as hell, if you cannot use it for the most prominent use case
15:35:20 <Solonarv> suzu: no, some kind of wrapper is needed
15:35:37 <suzu> ah okay
15:35:39 <suzu> sad
15:36:07 <suzu> was trying to do some type-level shenangians but i htink they wont work out
15:40:50 <Lears> Denommus: I'm a bit late, but it seems simpler to do something like this: https://gist.github.com/LSLeary/1a6a313a4c418ae76dabbc55c3d06dbe
15:41:59 <wroathe> Arney: req was implemented in terms of http-client and http-client-tls (as it says in his documentation)
15:42:15 <Arney> hm, okay, but this is not coming with haskell by default wroathe ?
15:42:39 <wroathe> http-client and req are both packages, neither "come" with Haskell
15:43:04 <Arney> wroathe: uhm, well my linux distribution installs ghc with HTTP.Request, doesn't it?
15:43:43 <wroathe> and if you think about the "why" of http-client's manager object, it's easy to empathize with what Michael Snoyman is doing
15:44:11 <wroathe> Arney: I have no idea what your linux distro has
15:44:16 <Arney> no i get it, i just have questions about the package system.. there are default packages that can be imported
15:44:23 <Arney> Network.HTTP is one of them
15:44:28 <Arney> i mean ghc ships with it, doesn't it?
15:45:07 <MarcelineVQ> that's a module not a package :O there's a set of fairly standard packages that should come with ghc, listed as core libs here https://www.haskell.org/platform/contents.html
15:45:53 <Arney> yeah is Network.HTTP.Req one of them?
15:46:34 <MarcelineVQ> the package req? not that I see
15:47:08 <Arney> okay, how can i install that package
15:47:22 <Arney> that question more precicesly: http://hackage.haskell.org/package/req-2.0.0/docs/Network-HTTP-Req.html
15:47:23 <wroathe> That's if you install the haskell platform, and not just GHC/Cabal though
15:47:36 <Arney> i mean.. whats that package to cabal?
15:47:40 <wroathe> Also, earlier he mentioned he was using Http.Client, which is probably http-client and not HTTP
15:47:41 <Arney> network-http-req
15:47:43 <Arney> req-conduit?
15:48:20 <MarcelineVQ> wroathe: the "Core Libraries, provided with GHC" ones will come with ghc installs regardless of source, afaik
15:48:21 <Arney> my question is, how do i get from that url to the command that installs that package, that always confused me
15:49:38 <Arney> if the module is named Network.HTTP.Req the package name in cabal is not necessarely network-http-req
15:49:41 <Arney> or is it?
15:50:28 <c_wraith> it's probably not.
15:50:31 <Arney> is the developer totally free in naming packages?
15:50:36 <MarcelineVQ> the name of the package is unrelated to the module name, the package is called req which you can find at the top-left of screen the link goes to
15:50:53 <MarcelineVQ> "req-2.0.0"
15:51:04 <Arney> ah okay
15:51:06 <MarcelineVQ> you can also see this in the url
15:51:12 <MarcelineVQ> now that you know what to look for
15:51:16 <c_wraith> beware: some packages use the same module names as other packages.
15:51:23 <Arney> yeah i somehow figured it might have one minus atleast
15:51:28 <wroathe> We say that a given package "exposes" modules
15:51:31 <Arney> that's why i overlooked that
15:51:43 <Arney> yeah thanks, i get it now
15:52:22 <Arney> thanks alot for answering my questions that makes me a let less mad :)
15:52:29 <Arney> good night everyone, or day or whatever
16:47:59 <NemesisD> has anyone been able to successfully build a docker image with a haskell package's binaries in it using nix? i'm having some trouble
17:07:10 <jackdk> NemesisD: I have done this once but never actually used the thing I built. Pastebin what you've got and I'll look after lunch
17:13:35 <jle`> the ghc api is ... quite the beast
17:14:25 <pie___> is it possible to have a cabal file ina side directry of my project and not in the root?
17:14:43 <hpc> usually you do it the other way around, and sequester your code in src/
17:17:07 <lyxia> that's definitely possible
17:19:04 <pie___> hpc, it might be misguided but hetes what I imagined: I want all my cabal stuff + mutable build states used during development to be in a cabal directory, another directory for Nix scripts, and another for src
17:19:10 <pie___> *here's
17:21:11 <hpc> hmm
17:21:40 <hpc> what's your ultimate goal that's being solved by how you structure your repo?
17:22:08 <pie___> hpc, separation of source code, declarative builds, and development builds (i guess)
17:22:15 <pie___> the separation of the last two is because nix builds are slow
17:23:25 <hpc> what are those two types of builds?
17:23:49 <hpc> usually with cabal and whatnot you'd have a build directory that's .gitignored or similar
17:23:51 <pie___> the separation of the source was i think something having to do with nix being sensitive to soem kind of file changes i was doing causing unnecessary rebuilds, but that was probably me using nix wrong, so this is probably wrong
17:24:16 <hpc> so your repo would be like /.gitignore, /src, /build, /foo.cabal, ...
17:24:27 <hpc> ah
17:24:31 <pie___> disclaimer: i dont know much about cabal and i was going to start reading the docs, but its way too late today for meto actuallystart on that
17:24:35 <hpc> that might be worth it then, but i don't know nix well enough to say
17:25:14 <pie___> the nix stuff works fine (so far), im just not sure hwo to use cabal like this 
17:25:23 <pie___> i told it to use ../src for the source, that seems fine
17:25:35 <hpc> maybe that's good enough then
17:25:43 <pie___> how do i tell it to use ./build or something like that for build outputs? (and then i just run cabal build in the "cabal" directory?)
17:26:13 <hpc> my current project's pretty bonkers too, i have three different Makefiles
17:26:20 <pie___> x)
17:26:29 <hpc> one controls vagrant, two control the freebsd packaging
17:26:48 <pie___> im very hip and have not written much make
17:26:56 * pie___ is very noob
17:27:49 <hpc> make has a pretty good model for building things without wasted work, i think
17:28:03 <hpc> it's definitely worth knowing, for the education if nothing else
17:28:28 <pie___> im not really against it though i heard it can be painful for complex things or something
17:28:36 <hpc> (the implementation of that model is very rooted in the 80s, but still)
17:28:37 <pie___> nix doesnt have incremental builds (or whats the word)
17:28:58 <pie___> i think there have been some experiments with doing incremental builds but not sure 
17:29:19 <pie___> but im no authority so dont take m word for anything
17:29:52 <hpc> the idea is the "build something" operation takes source files and produces a target file by some process written in almost-bash
17:30:04 <NemesisD> jackdk: i think i figured out the issue i was having. although in general i'm kind of confused how the docker container is working. its copying all of the built dependencies into the docker container right? my final image size is 323mb for a single executable
17:30:04 <hpc> and if the target is newer than the sources, it doesn't need to be rebuilt
17:30:18 <pie___> i think i read something like make is basically a DAG traversal-ish primitive
17:30:18 <hpc> now make a DAG of those
17:30:37 <pie___> which sounds pretty useful tbh
17:30:38 <python476> hi functors
17:30:46 <hpc> if you don't have something that fits the model of "take source, do thing, drop output file on disk", it doesn't fit quite as well
17:30:49 <pie___> if it can be coerced into doing what you want
17:31:07 <hpc> but it's still a fairly standard way to mash together a dozen different 3-line scripts
17:31:15 <python476> I was wondering about a pattern https://pastebin.com/cvFz9zxT
17:31:47 <pie___> aha.
17:31:51 <python476> tl;dr `x -> g^-1 (f g x)` <= is this a common thing and has it been named ?
17:32:09 <hpc> :t ala
17:32:10 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor f) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
17:32:31 <Lears> python476: group theoretically, conjugation.
17:32:34 <python476> his: this is for me ?
17:32:34 <hpc> hmm, that's not it maybe?
17:32:48 <python476> Lears: thanks gonna read about it
17:32:53 <hpc> python476: it's a thing iirc, just blanking on what it is
17:33:04 <Solonarv> hpc: ala from coercible-utils cheats ;)
17:33:11 <python476> hpc: no worry thanks for the void
17:33:38 <hpc> you'd usually have some kind of type class or function pair for g and g^-1
17:33:48 <hpc> with such and such identity laws
17:33:48 <python476> maybe even a basic monadic-like structure...
17:34:45 <Solonarv> python476: 'over' from the lens library is somewhat related
17:34:50 <hpc> lenses are a lot like that, for the special case of g and g^-1 being related to wrapping and unwrapping data structures
17:34:53 <hpc> :t over
17:34:53 <python476> googling for Category theory conjugation gives images of Arnold Schwarzenegger. fun
17:34:54 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
17:35:20 <Solonarv> 'over' is a bit more general than what you mentioned, actually
17:36:06 <python476> Solonarv:  I don't mind more generality
17:37:28 <python476> btw can compilers lift wrapping/unwrapping if given some laws ?
17:38:25 <Solonarv> what do you mean by "lift"? and which compilers are you talking about?
17:39:51 <python476> I meant optimize out and any haskell compiler, I was mostly curious about the feasability
17:40:13 <Solonarv> depends on the kind of wrapping/unwrapping
17:40:27 <python476> wondering if using fancy abstraction with pairs of function to wrap/unwrap all the time could lead to performance issues you know
17:40:54 <python476> feels a bit like ..stream fusion in a way
17:41:35 <Solonarv> It can, yes - but there are ways to avoid that
17:42:11 <python476> ok
17:52:03 <pie___> hpc, looks like i can just run cabal build and it will make a "dist" directory
17:52:10 <pie___> there appears to be a --builddir
17:52:21 <pie___> however i dont see a way to specify in the .cabal file
17:53:05 <c_wraith> for good reason
17:53:26 <c_wraith> the foo.cabal file is intended to be part of a source distribution
17:53:45 <c_wraith> it shouldn't include things like that
17:53:56 <Lears> cabal.project/.local on the other hand
17:57:01 <pie___> ok i guesss that makes sense
17:59:32 <hpc> :D
17:59:59 * pie___ crashes
18:14:10 <t4nk877> Is there a builtin function to do safe indexing on a list ?
18:14:52 <Welkin> don't index lists
18:14:59 <Welkin> use an array or vector
18:15:03 <Welkin> pattern match on lists
18:15:39 <Welkin> there is no total version of List.!! in base, but you can write one if you want to
18:18:43 <marvin3> t4nk877, no, but see safe package
18:21:36 <Lears> `drop` is a safe indexing function if you squint a bit.
18:21:54 <Welkin> take and drop are best friends
18:25:55 <Axman6> :t \n -> fmap fst . listToMaybe . drop n
18:25:57 <lambdabot> Int -> [(b1, b2)] -> Maybe b1
18:26:09 <Axman6> :t \n -> listToMaybe . drop n
18:26:10 <lambdabot> Int -> [a] -> Maybe a
18:31:47 <monochrom> But beware of how slow indexing on a list is.
18:32:40 <monochrom> I actually have students who just assume everything is constant time on lists.
18:34:02 <monochrom> And I was not teaching Haskell lists as an abstract data type.  I taught it as a concrete algebraic data type so they knew what is stored and what is not cached, e.g., length is not cached.
18:35:34 <monochrom> And I taught them pattern matching and nothing else.  I didn't even bring up head, tail, length.
18:36:32 <monochrom> So whereas I showed them "foo [] = xxx; foo (x:xs) = yyy" they ignored it and rolled their own "foo xs | length xs == 0 = ..."
18:37:33 <Solonarv> maybe make them use a custom prelude that doesn't export 'length' or any of those functions?
18:38:13 <MarcelineVQ> "foo xs | myLength xs == 0 = ..." :>
18:39:00 <Solonarv> yeah, but now they have to write myLength first.
18:47:18 <jackdk> NemesisD: you can call pkgs.haskell.lib.justStaticExecutables on your nix package to make that much smaller
18:49:16 <ion> Just make myLength return a Peano number, problem solved. :-P
18:54:27 <benzrf> :-D
18:55:17 * hackage postgresql-orm 0.5.1 - An ORM (Object Relational Mapping) and migrations DSL for PostgreSQL.  https://hackage.haskell.org/package/postgresql-orm-0.5.1 (AmitLevy)
18:55:27 <Solonarv> myLength = foldr (const S) Z -- ;)
18:56:30 <Welkin> ourLength = foldl' (const S) Z
18:56:41 <Welkin> yourLength = foldl (const S) Z
18:58:58 <Solonarv> meh, what's even the point of peano naturals in that case
19:03:26 <ion> thatsthejoke.jpeg
20:34:00 <jle`> myLength = map (const ())
20:34:31 <jle`> equivalent under `Nat ~ [()]`
20:37:34 <MarcelineVQ> myLength = 20 -- nice clean definition, should be right often enough, haskell isn't a consistent logic anyway I've heard from various completely reputable sources that surely meant this context
21:08:37 <juicyasf> hello, world
21:08:44 <glguy> Hello
21:09:41 <juicyasf> putStr “hello, world\n” I love Haskell how do I get a job writing Haskell code. what’s the general Haskell channel?
21:09:59 <glguy> This is the general Haskell channel.
21:11:09 <juicyasf> i thought there was a noob channel for people like me, maybe started with two hastags and included a dash
21:12:42 <Solonarv> juicyasf: the "noob channel" is #haskell-beginners
21:12:43 <MarcelineVQ> there's a quieter channel called #haskell-beginners but newcomer questions are entirely welcome here
21:14:18 <Axman6> How to get a Haskell job: 1) Learn Haskell, 2) Apply for Haskell jobs
21:14:33 <Axman6> This has worked for me four out of three times
21:14:46 <DigitalKiwi> alternatively turn your current job into a haskell job
21:14:52 <Axman6> (one Haskell job wasn't originally a Haskell job but I made it one)
21:15:02 <Axman6> DigitalKiwi++
21:15:07 <jackdk> you need to tell me that story some time
21:15:14 <glguy> juicyasf: You can read about the difference in # and ## here https://freenode.net/kb/answer/namespaces
21:15:29 <juicyasf> every job is to be an haskell job. any companies hiring haskell enthusiasts in Phoenix?
21:17:25 <Axman6> jackdk: which one?
21:17:44 <jackdk> converting an existing job.
21:19:41 <Axman6> It was pretty simple, it was just an initernship where you work now where I could use the tools I wanted so used Haskell to read from a serial port attached to a power meter
21:20:23 * Axman6 notes how fast that sentense is running on
21:21:50 <DigitalKiwi> no need to type 200wpm
21:28:48 <juicyasf> @Axman6 you were more satisfied with your Haskell program than your C candidate?
21:28:49 <lambdabot> Unknown command, try @list
21:29:05 <glguy> (@ is for bot commands)
21:29:40 <juicyasf> Axman6 you were more satisfied with your Haskell program than your C candidate?
21:32:10 <suzu> @pf f x y = g $ h x y
21:32:11 <lambdabot> Maybe you meant: pl bf
21:32:15 <suzu> @pl f x y = g $ h x y
21:32:16 <lambdabot> f = (g .) . h
21:32:37 <suzu> hmm no thanks
21:32:41 <suzu> ill leave it expanded
21:33:52 <juicyasf> what’s the at:pl mean?
21:34:57 <Solonarv> '@command' is for lambabot commands; 'pl' is short for 'pointless', also know as 'point-free'
21:35:43 <Solonarv> "point-free style" is a style of writing functions without mentioning their arguments (the "points")
21:36:26 <Solonarv> If taken to the extreme, it's very hard to read, so probably not a good idea in "real" code!
21:38:50 <Solonarv> @where pointfree
21:38:50 <lambdabot> http://haskell.org/haskellwiki/Haskell/Pointfree
21:49:47 * hackage asif 4.0.0 -   https://hackage.haskell.org/package/asif-4.0.0 (arbornetworks)
21:50:54 <margaritamike> How can I import http-client, for example, into the Lib of a fresh stack project
21:52:24 <MarcelineVQ> add http-client to the build-depends of the library section in your cabal file
21:52:53 <MarcelineVQ> then you'd say import Network.HTTP.Client in Lib
21:53:01 <MarcelineVQ> *Lib.hs
22:01:57 <margaritamike> Nice thanks
22:15:27 <trevortknguyen[m> I'm looking for potentially mathematically-based books from which to learn Haskell so that I can understand the language design from a more academic sense. Any recommendations?
22:16:17 <opqdonut> pierce's types and programming languages is a classic
22:16:34 <opqdonut> it doesn't actually teach you haskell but teaches you lambda calculus and its various type systems
22:17:26 <trevortknguyen[m> I'm currently taking a linear algebra class using Axler's Linear Algebra Done Right and I've read the first few chapters of Rudin's Principles of Mathematical Analysis. What sort of prerequisite knowledge in mathematics would be important?
22:17:50 <dminuoso> trevortknguyen[m: None really.
22:18:24 <trevortknguyen[m> <freenode_dmi "trevortknguyen: None really."> That's good to hear!
22:18:48 <trevortknguyen[m> <freenode_opq "pierce's types and programming l"> Thank you for your recommendation.
22:19:22 <dminuoso> trevortknguyen[m: Though if you want to study the design considerations, our trac contains links to hundreds of published papers that justified many parts of GHC.
22:20:58 <trevortknguyen[m> I'm mainly interested in just getting a better feel for Haskell as a language. I studied Java in high school and we would have to take exams that tested all of the language's idiosyncrasies and OOP paradigms, so I feel like I know it really well.
22:20:58 <trevortknguyen[m> I'd like to get that level of intimacy with Haskell, and I feel like I could only get there by understanding the mathematical rationale for its design.
22:21:32 <opqdonut> well TaPL is a good base for understanding Hindley-Milner, as well as the various extensions Haskell uses
22:21:49 <opqdonut> you might want to support that with an implementation paper, perhaps the original "spineless tagless g-machine" paper
22:22:00 <opqdonut> not sure what GHC uses currently, or if there is a nice description of it
22:22:23 <dminuoso> The spineless tagless g-machine is really useful from an implementation point of view, but it wont tell you much about Haskell and its semantics itself.
22:22:31 <opqdonut> TaPL also teaches you lots of type theory notation and terminology that will be useful when reading shorter papers
22:22:43 <dminuoso> I too recommend TaPL. :)
22:32:04 <cocreature> dminuoso: hm, I found that reading the stg paper was the thing that finally gave me a good handle on Haskell’s operational semantics
22:32:26 <dminuoso> YMMV :)
22:33:04 <dminuoso> cocreature: Im curious though, what operational semantics would that be?
22:33:34 <dminuoso> Haskell in its report is not defined to be lazy, mind you.
22:33:44 <cocreature> I don’t care about the Haskell report, I care about GHC
22:34:10 <cocreature> and understanding STG, gives you a pretty good mental model for how GHC executes your code, why you get spaceleaks, how you can avoid them, …
22:34:13 <opqdonut> dminuoso: only non-strict?
22:34:17 <dminuoso> opqdonut: Yeah.
22:34:49 <opqdonut> cocreature: I think learning graph reduction got me the biggest bang, stg was just implementation details
22:49:16 <cocreature> opqdonut: graph reduction doesn’t help you much with the order of evaluation, does it?
22:51:32 <opqdonut> I just apply the whnf rule I guess
22:52:17 <dminuoso> cocreature: If you want to study how GHC specifically runs your code, the STG paper is ideal. If you want to understand the semantics on a more abstract level graph reduction might yield more milage.
22:55:11 <cocreature> I prefer an operational semantics that is capable of explaining the difference between foldl (+) 0 and foldl' (+) 0
22:55:53 <cocreature> I’ve seen way too many people that get confused when it comes to explaining the differences between foldl (+) 0, foldl' (+) 0 and foldr (+) 0
22:56:32 <opqdonut> whnf is enough for that, right?
22:56:45 <opqdonut> and, well, the "reduction rule" for seq
22:56:55 <cocreature> I’m not really sure what precisely you mean by that but yeah probably
22:57:12 <dminuoso> opqdonut: What exact reductino rule for seq is that? ... :P
22:57:46 <dminuoso> opqdonut: One particularly funny thing about seq is that it does not impose an ordering..
22:57:48 <opqdonut> dminuoso: to reduce seq to whnf, reduce the first arg to whnf, then continue with the second arg
22:57:53 <opqdonut> well all right
22:58:02 <opqdonut> I guess I've been teaching pseq :)
22:58:09 <dminuoso> :)
22:58:11 <cocreature> the fact that a lot of people (myself included) end up picking up category theory books before they know enough about the operational semantics to explain the differences between those 3 statements is one of my biggest gripes with Haskell education.
22:58:31 <opqdonut> yeah
22:59:22 <cocreature> dminuoso: I still think that’s a lie when it comes to GHC. if that was the case, pretty much all code that tries to avoid spaceleaks would be broken and that doesn’t seem to be the case.
23:00:00 <dminuoso> cocreature: It's a curious case. Simon mentioned this frequently on mailing lists though. 
23:01:17 <cocreature> well he also mentions that if GHC would actually exploit this, it would fuck up foldl' https://mail.haskell.org/pipermail/glasgow-haskell-users/2006-November/011480.html
23:01:34 <opqdonut> indeed
23:05:08 <cocreature> so it seems to be something like “we don’t want to guarantee it but we won’t fuck it up in any of the cases where it matters”
23:08:40 <dminuoso> cocreature: Well he doesn't say it would fuck up foldl'
23:27:58 <jle`> phew, just wrote my first typechcker plugin using the ghc api
23:28:05 <jle`> this ghc api thing is a doosey
23:44:41 <cocreature> dminuoso: “It wouldn’t do what you want at all.” very much sounds like “fuck up foldl'” to me :)
23:57:25 <yoneda> cocreature: rotfl
