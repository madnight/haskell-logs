00:18:46 <Guest89> is it possible to publish a lib on hackage which will be compiled with llvm only if it is available
00:20:15 <Guest89> I've seen packages with flags to enable llvm, but I'm not sure how to activate these flags if I simply put these dependencies in my .cabal
00:25:53 <jackdk_> I am trying to assist a student dealing with the nondeterministic library id bug on osx. They installed the haskell platform (full), hit the bug, I had them try uninstalling and installing the haskell platform (core) but they still cannot build. Are there dotfiles they should remove?
00:46:11 <absence> it seems like stack repl ignores my ~/.ghci. do i have to do something in particular to configure stack repl?
00:52:28 <arjen-jonathan> Hi all. I can't find how one can enable a language extension using the stack project configuration.
00:54:50 <arjen-jonathan> Oh got it, 'default-exensions: []'
01:04:25 <trcc> dminuoso: sorry
01:04:35 <trcc> coworker walked in with important thing
01:09:16 <trcc> not to say that this is not important heh
01:17:36 <trcc> dminuoso: So what I need to do is: The log from writer monad from getLogic on line 4 must be returned from getLogicImpure in the writer format. So basically, I just need to change the non-log values within the writer monad and wrap it all in IO
01:18:08 <dminuoso> What do you mean by "wrap it all in IO"
01:18:21 <trcc> the return type is IO
01:18:28 <trcc> of getLogicImpure
01:18:31 <trcc> so it just has to match
01:18:32 <dminuoso> trcc: Do you just want the writer effect locally?
01:18:38 <dminuoso> Or do you want to keep writing to the log in other places?
01:18:49 <dminuoso> And also, do you ever want to do IO while doing writer effects?
01:19:22 <trcc> So in the future line 6 of  https://gist.github.com/CThuleHansen/6a24e7cc5912666fd3e95fd404775e49 might add to the same log
01:19:41 <trcc> the issue is, that my writer and io stuff is pretty mixed up currently, and I cannot really see a clever way out of it
01:20:07 <dminuoso> trcc: Maybe just an IORef?
01:20:20 <trcc> sorry where?
01:21:04 <dminuoso> trcc: If you want the effects bundled, you either have to manually keep fiddling the writer object through - or use WriterT.
01:21:27 <trcc> hmm maybe I should look at writerT then
01:21:39 <trcc> seems like the more "clean" option?
01:21:40 <dminuoso> trcc: Or just use IORef if you want some mutable state.
01:21:44 <trcc> I do not
01:21:52 <trcc> I would prefer to avoid it as much as possible
01:21:55 <dminuoso> Ive never heard much good about Writer.
01:21:59 <trcc> hmm
01:22:09 <trcc> thought it was sort of defacto approach to what I need
01:22:39 <trcc> I'll continue with writer for now. Then I might change it in the future.. need to get further heh
01:31:39 <trcc> dminuoso: could you help me a bit with https://gist.github.com/CThuleHansen/6a24e7cc5912666fd3e95fd404775e49 the nothing case on l. 6? I just need to to obey the types, but I cannot figure out how. I am choosing the "manually fiddling approach" for now. The error is in the gist
01:33:08 <merijn> trcc: Oh, that's straightforward
01:33:19 <merijn> trcc: Note that the return type of your function is "IO (...)"
01:33:23 <trcc> yes
01:33:42 <merijn> trcc: But branch on line 6 does "W.tell log" which is Writer, not IO
01:33:52 <trcc> yes, I need IO (Writer 
01:33:54 <trcc> ...
01:34:01 <trcc> and I am trying to figure out how to get that
01:34:12 <trcc> the type signature is what I would like
01:34:15 <merijn> trcc: Right, so the do block in your branch is currently "Writer .." and you need "IO (Writer ...)"
01:34:23 <trcc> yes
01:34:32 <merijn> trcc: Just do "return $ do ..." :)
01:34:56 <merijn> trcc: You wanna put the Writer do block inside IO, and we do that the same way we put anything into any monad. return :)
01:35:58 <merijn> trcc: Keep in mind that do blocks (since do notation it's just syntactic sugar for >>= and >>) is just a regular expression like anything else
01:36:22 <merijn> So you can do anything with them you can with expressions (such as return-ing them)
01:36:46 <dminuoso> merijn: The problem is he wants to discriminate on the writer log immediately afterwards.
01:36:56 <dminuoso> And then he wants to keep passing the writer thing further..
01:37:18 <trcc> if possible yes
01:37:23 <merijn> I only read the concrete code example and question, so I dunno about that :)
01:37:37 <trcc> but that will be next iteration i think, unless there is a good option for this
01:43:23 <merijn> Honestly I would probably ditch the Writer entirely and switch to using something like monad-logger for logging :)
01:43:38 <trcc> god dammit just started learning writer heh
01:44:01 <trcc> merijn: could you give me some insides as to why?
01:44:25 <c_wraith> in a sad twist, writer is almost never what you want in production software
01:44:32 <merijn> trcc: 1) It's trivial to perform logging while doing IO, 2) Writer is known for having tricky performance impact
01:44:48 <trcc> hmm
01:44:51 <merijn> trcc: tbh, I've never actually used Writer in like 10 years :p
01:44:55 <tdammers> also 3) because monad-logger takes care of all the pitfalls you haven't even thought about
01:45:55 <trcc> Does it function in the same way? i.e. appending to the log
01:46:04 <merijn> trcc: Also, monad-logger does a bunch of stuff that's nice to have for logging that you'd have to implement yourself with the writer approach (like filtering by verbosity)
01:46:33 <trcc> hmm I think I will switch then
01:46:42 <merijn> trcc: monad-logger is two things: 1) a generic API for doing logging, and 2) a specific simple implementation that logs to files/channels
01:47:11 <trcc> merijn: I need to invoke a callback with the log information. So I need it carried along until the end
01:47:19 <merijn> trcc: The nice thing is that you can use it "as-is" now and in the future if you want to replace it with something fancier you can just implement a custom logging interface and swap it into your code with minimal changes
01:48:07 <merijn> Hell, you could probably write your code using monad-logger then implement a simpler Writer based wrapper that does exactly what you do now :p
01:48:55 <trcc> okay. That will be in some later release
01:49:06 <trcc> staying with writer for now.
01:49:09 <trcc> Thanks!
01:55:07 * hackage halive 0.1.5 - A live recompiler  https://hackage.haskell.org/package/halive-0.1.5 (lukexi)
01:55:27 <slaterr> is there a way to get a better message than this? a filename and line number would be helpful..  Prelude.head: empty list
01:57:41 <Cale> slaterr: grep your entire project for occurrences of 'head' and replace every one of them with (\(x:xs) -> x)
01:57:50 <Cale> or (\(x:_) -> x) rather
01:58:08 <Cale> you'll get better error messages when they fail
01:58:51 <trcc> ah traverse_. Nice!
01:59:40 <statusfailed> Cale: neat idea!
02:00:08 <Cale> Of course, you should probably replace most of them with full case expressions
02:00:15 <Cale> and actually handle the empty list
02:00:39 <slaterr> I do when I think I need to. but sometimes I'm wrong, like this time
02:01:11 <Cale> There are very very few places where I'd actually write 'head', and all of them are idioms
02:01:24 <Cale> basically just stuff like  map head . group . sort
02:01:26 <slaterr> I wish there was a better way than rewriting all the non-total functions inline
02:02:33 <Cale> (and that one is only okay because it's an idiom using list library functions -- other code of that kind is not as okay)
02:04:49 <slaterr> can I perhaps do something like this? (betterErrors (head list))
02:05:04 <slaterr> where betterErrors would rethrow the error with file and line number
02:05:19 <slaterr> ideally it wouldn't return IO (but that is probably not possible?)
02:05:36 <tdammers> afaik there is no way to catch errors in non-IO code
02:06:15 <slaterr> though, since I'm only calling head, etc, when I'm sure it will work, that probably wouldn't be used match
02:06:23 <slaterr> s/match/much
02:06:37 * hackage halive 0.1.6 - A live recompiler  https://hackage.haskell.org/package/halive-0.1.6 (lukexi)
02:06:41 <tdammers> you may also be interested in https://wiki.haskell.org/Debugging#Stack_trace
02:08:39 <slaterr> tdammers, that's even better
02:09:31 <slaterr> why is that not on by default? too costly in some way?
02:09:42 <tdammers> runtime overhead, I guess
02:09:44 <merijn> slaterr: stack traces cost performance, yes
02:09:58 <merijn> slaterr: They also inhibit some optimisations which means the cost isn't linear
02:10:57 <tdammers> specifically, the required cost centers limit inlining, which is crucial to many of the optimizations that GHC can perform
02:30:32 <slaterr> why can't this be done statically? filename and line number are known statically are known at compile time
02:31:15 <merijn> slaterr: What would those things be attached too? Uses of head? That requires knowing head is partial
02:31:33 <merijn> slaterr: And determining which functions are partial is, well, notoriously hard ;)
02:31:41 <slaterr> yeah..
02:31:57 <slaterr> well, it could be attached to undefined/error
02:32:26 <merijn> slaterr: It is, but that gets you the location of the definition of "head", not where you use it, so that's not useful
02:33:09 <merijn> slaterr: So then you need to propagate that error/location through the callstack, which means actually maintaining such a callstack at runtime...and now we're back to "it has runtime overhead" :)
02:33:52 <merijn> slaterr: In C programms generally get away with attaching to the call stack (not so much in C++ which is why you often have to rely on -fno-omit-frame-pointer in C++)
02:34:02 <merijn> slaterr: But GHC doesn't *have* a callstack, so that idea is right out
03:50:07 * hackage validity 0.9.0.1 - Validity typeclass  https://hackage.haskell.org/package/validity-0.9.0.1 (Norfair)
03:51:07 * hackage genvalidity 0.7.0.1 - Testing utilities for the validity library  https://hackage.haskell.org/package/genvalidity-0.7.0.1 (Norfair)
03:59:41 <mrfincher> hello i have a question. where can i send it? :D
04:03:12 <yushyin> here
04:03:38 <pacak> Is it a haskell related question?
04:03:54 <mrfincher> yes
04:04:41 <mrfincher> im trying to use the library gogol to make google calendar api request, but i am struggling with the authentication
04:05:58 <pacak> Please state the nature of the struggle.
04:06:44 <mrfincher> do you understand how i can use oauth with gogol? http://hackage.haskell.org/package/gogol
04:08:32 <mrfincher> i got it to work with api authentication but i want to add events to my personal calendar
04:08:39 <mrfincher> for that i need oauth right?
04:09:28 <pacak> Seems so.
04:10:28 <mrfincher> looks like a need to construct creds using the the FromClient constructor
04:11:27 <mrfincher> for that i need the oauth client (which consists of the id and the secret) i have those but i also need the oauth code
04:11:43 <pacak> Do you have any ideas how to do that without haskell?
04:12:05 <berndl> Is there a way in GHCI to order the error messages in reverse?
04:12:26 <mrfincher> seems like i can get that using the formURL function, but that needs a proxy argument which i dont understand
04:12:35 <pacak> This library probably uses the same termonology as API it wraps and there migh be much better documentationss on that api itself.
04:12:41 <pacak> Let me look at formURL...
04:13:00 <mrfincher> it works with the online google test app where i log in using my google account
04:13:47 <pacak> :t Proxy
04:13:48 <lambdabot> forall k (t :: k). Proxy t
04:14:28 <pacak> So what you need is (Proxy :: Proxy ["Foo", "Bar"]) as an argument
04:14:39 <pacak> where Foo and Bar are allowed scopes.
04:15:07 <mrfincher> so how do i construct that?
04:15:16 <pacak> (Proxy :: Proxy ["Foo", "Bar"])
04:15:25 <mrfincher> oh ok
04:15:28 <mrfincher> i will try that
04:15:35 <pacak> @src Proxy
04:15:35 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
04:15:37 <pacak> Meh.
04:15:49 <mrfincher> :D
04:16:29 <[exa]> in 2019, lambdabot became self-conscious
04:19:00 <mrfincher> do i need language extensions for that?
04:19:19 <pacak> DataKinds
04:19:38 <pacak> maybe something else
04:19:50 <mrfincher> thc
04:19:52 <mrfincher> thx*
04:21:42 <pacak> afk
04:22:22 <trcc> what do you say in haskell-context: invoke function, call function, apply function? I.e.: This function recursively invokes function Y
04:24:05 <Cale> trcc: The most common thing you'll hear is apply, specifically in the sense that a function is applied to its argument. "Invoke" also seems totally fine informally. Some people will use "call", but it's kind of weird.
04:24:52 <trcc> Cale: thank you. But if one uses apply, then it sounds weird to write: applies function Y and stopping there. Then one would need: applies function Y to its arugments
04:24:59 <trcc> or is it just me
04:25:34 <Cale> You can say "applies the function" on its own
04:25:40 <trcc> great. Thank you
04:25:46 <Cale> assuming that it is actually being applied
04:26:01 <trcc> hehe yes of course
04:26:22 <Cale> "invoking" sounds more general, like -- does giving the function as an argument count as invoking it?
04:26:51 <trcc> I can see what you mean, althouh in that case I would say clearly no
04:34:07 <kritzefitz> IIRC a function `f` is called strict if `f ⊥ = ⊥`, is it correct, that `const ⊥` is strict? It seems counter-intuitive, because `const` doesn't actually have to evaluate its second argument to evaluate its return value.
04:37:53 <[exa]> kritzefitz: the definition with WHNFs is slightly better IMO
04:38:28 <hpc> it's denotationally strict, i suppose
04:39:26 <[exa]> kritzefitz: anyway 'const undefined' is \x -> undefined, which is not undefined.
04:39:48 <hpc> [exa]: the question is if \x -> undefined could be considered strict
04:40:07 <[exa]> oh so
04:41:39 <kritzefitz> [exa], I'm not sure which definition you mean. Is there a more elaborate description of it available somewhere?
04:43:30 <[exa]> kritzefitz: well the practical definition is 'does it become more strict if you put (seq argument) before its definition'
04:45:31 <dminuoso> kritzefitz: `const` is not strict in the sense that `const ⊥ = \x -> ⊥`
04:45:41 <dminuoso> (strictness is with respect to arguments)
04:45:59 <kritzefitz> dminuoso, yes, the question was not if `const` is strict, but if `const undefined` is strict.
04:46:24 <dminuoso> kritzefitz: It is not strict.
04:46:51 <kritzefitz> [exa], But ```x `seq` const ⊥ x = const ⊥ x``` if you assume that bottoms are indistinguishable, which would also lead me to believe that `const ⊥` is strict.
04:47:19 <kritzefitz> dminuoso, You say that and I think that it makes sense to say it is not, but by what definition can you say that?
04:47:24 <dminuoso> kritzefitz: Like you said
04:47:32 <dminuoso> f is strict iff `f ⊥ = ⊥`
04:47:45 <dminuoso> `const ⊥` is definitely not ⊥
04:48:08 <kritzefitz> Yes, but `const ⊥ x = ⊥`, which I would mean that `const ⊥` is strict.
04:48:27 <dminuoso> kritzefitz: Oh I see what you mean. Yes.
04:49:54 <kritzefitz> But I think considering `const ⊥` to be strict is not helpful for most cases, because usually thinking about strictness is done to know, when and if things will be evaluated, but in this case the definition of strictness doesn't mirror the evaluation.
04:51:06 <dminuoso> kritzefitz: f is strict iff `f _|_ = _|_` is for denotational semantics.
04:54:59 <kritzefitz> So, basically, when thinking about evaluation I shouldn't be thinking as much about strictness?
04:55:34 <merijn> kritzefitz: That depends on why you're thinking about it :p
04:55:37 <hpc> they're related, but at two different levels of thought
04:56:06 <hpc> so you can think about both of them, but not in /exactly/ the same way
04:58:56 <kritzefitz> Just to be sure I'm thinking about this right: This has to do with the “Lazyness and Non-Strictness are two different things” story, right?
04:59:33 <merijn> kritzefitz: laziness is a specific evaluation strategy that can be used to implement non-strictness
05:00:42 <merijn> kritzefitz: Non-strictness is a semantical constraint, i.e. "however you evaluate it, the result should not be bottom if a non-bottom evaluation strategy exists" (barring specific strictness annotations)
05:01:11 <merijn> kritzefitz: laziness otoh is a *specific* evaluation strategy that says "we won't ever evaluate something unless we absolutely have to to continue"
05:01:23 <kritzefitz> Yes, but does it make sense to say `const ⊥` is strict in its argument (because of the semantic definition), but also lazy in its argument (because it doesn't actually evaluate its argument)?
05:02:07 <merijn> kritzefitz: No, I don't think that makes sense, no :) Because it mixes two different meta levels
05:02:41 <merijn> kritzefitz: We either want to talk at the meta level of "what does code (abstractly) mean?" (this is the level "non-strictness" is defined on)
05:02:58 <merijn> kritzefitz: Or we want to talk on the specific operational level of "what does the code GHC generates do?"
05:03:10 <merijn> kritzefitz: GHC doesn't actually generate lazy code
05:03:41 <merijn> kritzefitz: Because the strictness analyser detects some common things that were evaluating arguments strictly is more efficient and generates strict code for those cases
05:04:18 <merijn> Incidentally, this is why the spec states "non-strict", rather than "lazy" because non-strictness allows the option of compiling code strictly IFF you know it's safe
05:05:19 <hpc> sometimes strict evaluation is non-strict :D
05:05:48 <kritzefitz> Okay, I think I asked the wrong question. When I want to say, that `const ⊥ x` when compiled by GHC and run will probably not evaluate `x`, what word could I use?
05:05:49 <merijn> kritzefitz: Concrete example would be the classical "foldl (+) 0" space leak. If you use Int as accumulator GHC can generate strict code (since it's faster)
05:06:16 <kritzefitz> *words
05:06:23 <hpc> kritzefitz: "does not evaluate x" or "does not evaluate its argument", probably
05:06:28 <merijn> ^^ that
05:06:58 <hpc> or you would say how far x is evaluated
05:07:07 <hpc> "null" evaluates lists to WHNF
05:07:20 <merijn> kritzefitz: Also, note that it's perfectly possible to write a correct Haskell implementation that *does* evaluate 'x'. An implementation that is strict by default and uses exceptions to backtrack in case strict evaluation hits _|_ is perfectly compliant with the spec :)
05:07:26 <hpc> "length" evaluates lists to something between WHNF and NF
05:08:44 <kritzefitz> Okay, I think most of my confusion was, that I conflated strictness and lazyness too much and tried to think about evaluation (in GHC) in terms of strictness.
05:09:45 <kritzefitz> I was hoping there was an easy terminology for the evaluation side too, but looking at the length example and various cases I remember from practical code, I think the evaluation side isn't really something that can be easily described in all cases.
05:09:52 <kritzefitz> Thanks for clearing that up!
05:12:20 <kritzefitz> merijn, Your example of a strict Haskell implementation assumes, that endless loops can be caught as exception, right? Otherwise I don't see how infinite lists work and AIUI they are guaranteed to work by semantics.
05:12:37 * hackage http-conduit-downloader 1.0.32 - HTTP downloader tailored for web-crawler needs.  https://hackage.haskell.org/package/http-conduit-downloader-1.0.32 (VladimirShabanov)
05:16:24 <merijn> kritzefitz: throw in a timeout in there or something ;)
05:16:46 <merijn> kritzefitz: But yeah, no one sane would implement Haskell that way. Just trying to clarify that you COULD
05:17:30 <kritzefitz> Yes, I think I understands what  you're trying to describe. I just wanted to nitpick on the practical feasibility.
05:17:43 <merijn> kritzefitz: I mean, people generally talk about evaluation as-if it behaves as the denotational semantics, but that's not quite right due to the fact that optimisation may strictify (or duplicate!) evaluations if GHC deems it necessary
05:18:43 <merijn> kritzefitz: Incidentally, have you read the STG paper? It's one of the better starting points for wanting to dive into the nitty-gritty details of "how do you even implement Haskell?" and evaluation stuff
05:19:44 <absence> it seems like stack repl ignores my ~/.ghci. do i have to do something in particular to configure stack repl?
05:20:12 <merijn> absence: Can you pass some verbosity flag to stack to see how it invokes ghci?
05:22:09 <absence> merijn: yes, what am i looking for? the output is quite long
05:23:21 <merijn> absence: Which flags are being passed to ghci, because there's a flag to disable readin ~/.ghci
05:23:42 <Cale> kritzefitz: It's worth noting that GHC will actually strictly evaluate a lot of things, if it can prove that the result will definitely be needed.
05:24:12 <mrfincher> hey guys. I could use some help with the google calendar api gogol. I got it working with the application default credentials but now i want to use oauth. I tried this but sadly got an exception: https://pastebin.com/Hsk4XciT
05:24:49 <Cale> kritzefitz: So while lazy evaluation (i.e. outermost-first evaluation with sharing) is a good approximation to understand how things will work, in practice, it will often not quite be what's going on.
05:26:07 * hackage http-conduit-downloader 1.0.33 - HTTP downloader tailored for web-crawler needs.  https://hackage.haskell.org/package/http-conduit-downloader-1.0.33 (VladimirShabanov)
05:29:28 <absence> https://pastebin.com/vENsB69E <- maybe that ghci-script
05:29:34 <absence> merijn: ^
05:30:26 <merijn> absence: Right, that overrides the config file to read
05:33:53 <gentauro> absence: it looks like you wrote your message in do-notation :P `14:29 < absence> https://pastebin.com/vENsB69E <- maybe that ghci-script`
05:33:57 <gentauro> xD
05:38:24 <mrfincher> does anybody got an idea? https://pastebin.com/Hsk4XciT
05:40:25 <kritzefitz> gentauro, It's a shame that `ghci-script` is not a valid identifier in Haskell, because `maybe that ghci-script` would even be a monadic value, given fitting type for `that` and `ghci-script`. This way it requires an instance for `Num (Maybe a -> b)` to work.
05:41:01 <absence> gentauro: with the maybe function and everything :)
05:45:12 <merijn> mrfincher: An idea for/of what?
05:45:34 <mrfincher> what i am doing wrong in this code
05:54:11 <mrfincher> if i let it use the creds in ~\.config\gcloud\application_default_credentials.json by using newEnv instead of newEnvWith it works so i guess the problem is with the oauth creds or the manager i had to create manually
06:01:38 <Guest23829> does anyone recommend a good library for 2d vector based animation?
06:03:18 <mrfincher> zzz: dont know much about this topic but maybe this is interesting: https://github.com/Lemmih/reanimate
06:23:18 <zzz> mrfincher: thanks ill take a look
07:08:36 <jackM> hello
07:10:20 <jackM> I'm learning Haskell and I defined a custom multiply function
07:10:28 <jackM> myMul :: Int -> Rational -> Rational
07:10:29 <jackM> myMul a b = toRational(a) * b
07:10:55 <jackM> to my surprise, (2 :: Int) myMul (3 :: Rational) did not work
07:11:25 <kritzefitz> jackM, For infix application you have to do 2 `myMul` 3
07:11:31 <Solonarv> if you want to use a function infix, you need to surround it with backticks ^
07:11:37 <kritzefitz> Note the backticks around the function.
07:11:39 <merijn> jackM: Functions are always prefix (unless backticked)
07:11:48 <jackM> ah... damn...
07:11:49 <merijn> jackM: You can define your own operator, though
07:11:55 <jackM> :) you are right. ty
07:12:00 <Cale> or if their name consists entirely of symbol characters
07:13:08 <merijn> > let (.*.) :: Int -> Rational -> Rational; a .*. b = toRational a * b in (2 :: Int) .*. (3 :: Rational)
07:13:10 <lambdabot>  6 % 1
07:13:29 <merijn> jackM: ^^ :)
07:13:52 <jackM> Thanks guys. It worked. I'm impressed. Never used IRC...
07:14:03 <jackM> I hope I'll not be tempted to abuse it :D
07:14:04 <merijn> jackM: (also note that the parentheses around 'a' are redundant in your initial example)
07:14:27 <jackM> true... Java reflexes
07:16:43 <lortabac> hello, I remember reading an article not so long ago about the mathematics behind algebraic data types
07:16:52 <lortabac> does anyone remember where it was?
07:17:09 <lortabac> it was a blog post IIRC
07:18:54 <jackM> lortabac: is not probably what you are looking for, but ... https://archive.is/xQcrX
07:20:02 <lortabac> jackM: thanks, it was not that one, but still useful
07:21:37 * hackage uuagc 0.9.52.2 - Attribute Grammar System of Universiteit Utrecht  https://hackage.haskell.org/package/uuagc-0.9.52.2 (DoaitseSwierstra)
07:30:36 <akersof> hi all, i am a new users of haskell, just installed it from the website. I am looking for a recommended IDE ? i am on macosx
07:31:02 <merijn> akersof: There's no real recommended IDE. Most people use whatever editor they're already comfortable with
07:31:04 <akersof> (i have a windows a linux machine too, something crossplateform would be perfect, i am thinking on intellij IDEA)
07:31:35 <merijn> akersof: This channel seems to be 1/3 vim, 1/3 emacs, 1/3 other (Sublime, Atom, VS Code, etc.)
07:31:48 <Solonarv> You could use IDEA, but last I checked its haskell plugin locks you into stack, which isn't ideal
07:32:18 <Solonarv> editor-with-syntax-highlighting + ghci/ghcid works plenty well enough for me, tbh
07:32:20 <akersof> merijn: indeed, i can use VIM, i know emacs from my Lisp knoweldge too
07:32:39 <tdammers> I think a fairly uncontroversial stance is that you probably don't want a full-blown IDE for haskell development; pick a powerful text editor and a shell and get cracking
07:33:26 <tdammers> both because Haskell's IDE story is kind of sad, and because the language itself is pretty damn good at making an IDE unnecessary
07:33:28 <akersof> indeed my objective is to explore how monads are implemented in haskell an try to close most of functionally on other mainstream langage
07:34:15 <akersof> ok ok i will start with vim then thx a lot
07:34:41 <ProofTechnique> lortabac: https://web.archive.org/web/20130213085518/http://chris-taylor.github.com/blog/2013/02/10/the-algebra-of-algebraic-data-types/
07:34:44 <akersof> but probably some IDE provides kind of "project management", integrated toochains etc?
07:34:46 <ProofTechnique> Is that the one?
07:35:23 <ProofTechnique> Also, https://bartoszmilewski.com/2015/01/13/simple-algebraic-data-types/ is very good, and https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types looks interesting
07:35:55 <merijn> binary doesn't really support sub byte data, does it?
07:36:05 <akersof> i know i can find everything on google, but as i am here, do you have a friendly introduction for haskell ? or something like from C++ / JAVA to haskell ?
07:37:10 <Solonarv> @where cis194
07:37:10 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
07:37:16 <Solonarv> this is recommended here quite often
07:37:53 <tdammers> akersof: wrt project management etc., both cabal and stack aim to provide a complete build and dependency management solution, so beyond putting things into directories and editing .cabal files, there's nothing you'd need from an IDE
07:38:04 <tdammers> so that's your "integrated toolchain"
07:38:10 <akersof> Solonarv: thx i was on it! well.. let's start!
07:38:48 <lortabac> ProofTechnique: yes! I think it was the one by Chris Taylor
07:38:52 <akersof> tdammers: nice i will check it. 
07:39:03 <lortabac> ProofTechnique: thanks
07:39:21 <Solonarv> building a project is as simple as 'stack build' or 'cabal v2-build', and specifying dependencies is quite simple too
07:39:42 <ProofTechnique> lortabac: The other parts should be available through Wayback, as well. Rather unfortunate that the source went away
07:40:52 <lortabac> ProofTechnique: strange that I remembered a recent post
07:41:07 <lortabac> ProofTechnique: maybe there is yet another one, or my memory is wrong
07:43:20 <merijn> Anyone know of a bit-level serialisation library?
07:47:23 <pagnol> a question from someone who only occasionally uses haskell: in the year 2019 what is the cleanest most hassle-free way to set up a fresh haskell project?
07:47:42 <ProofTechnique> Define "clean" and "hassle"
07:47:51 <pagnol> I don't want to spend hours wrestling with different cabal and stack config files
07:48:06 <pagnol> I remember wanting to hang myself in the past
07:48:26 <ProofTechnique> `cabal init` is pretty good. Can't speak to stack.
07:48:36 <byorgey> Also, define "project".
07:48:46 <ProofTechnique> I mainly use Nix+cabal, now
07:48:58 <pagnol> oh god, so stack is not yet the default choice?
07:49:14 <ProofTechnique> I'd say it's even less the default choice than a few years ago
07:49:19 <pagnol> oh god
07:49:33 <byorgey> pagnol: the reason is because cabal has gotten a lot better.
07:49:33 <pagnol> why?
07:49:37 <pagnol> ah ok
07:49:42 <byorgey> but stack is still great too.
07:49:55 <pagnol> so I go with cabal
07:50:12 <byorgey> cabal's 'new-style' commands work great.  cabal new-build, etc.
07:50:52 <Solonarv> rule of thumb: whenever a command has v1-foo and v2-foo variants, use v2-foo
07:51:03 <Solonarv> (v1- = unprefixed, v2- = new-)
07:51:24 <merijn> pagnol: What was your annoyance with cabal-install in the past?
07:51:53 <merijn> pagnol: The v2-* commands in cabal are basically like having automatic, transparent, shared sandboxes for all cabal projects :)
07:52:08 <merijn> pagnol: There
07:52:17 <merijn> pagnol: There's a quick overview here: https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
07:52:49 <mouse07410> I prefer "cabal v1-build", because I don't want/need per-project pile of dependencies, more often than not including the toolchain itself. I agree that "cabal v2-build" had it's place and use cases.
07:53:54 <Fabian_W> Is there some kind of check list or overview somewhere of what makes the "basics" of haskell? I really enjoyed using it in this semester's CS course and put quite some additional time into it. Somehow I don't feel I'm getting closer to actually being able to do fun stuff with it.
07:55:21 <merijn> Fabian_W: That depends a bit on how much you've already covered in class
07:56:00 <merijn> Fabian_W: There's the "Haskell from First Principles" book, which is certainly the most thorough one in terms of basics that I'm aware off. But if you already did a course using Haskell that might be too slow.
07:56:20 <merijn> Fabian_W: https://github.com/bitemyapp/learnhaskell has a lot of material/links too
07:56:38 <shapr> Fabian_W: or if you have a solid week of spare time, you could read "what I wish I knew when learning Haskell" http://dev.stephendiehl.com/hask/
07:57:13 <shapr> I've been writing Haskell for many years and I still find new stuff in that massive document
07:57:29 <tdammers> diehl's thing is amazing
07:57:46 <ProofTechnique> Fabian_W: "Get Programming With Haskell" is a bit more hands-on from the beginning than Haskell from First Principles, but both are good books
07:58:33 <merijn> Also, just hanging out here a lot is a good way to learn a ton :p
07:59:25 <shapr> Fabian_W: fpcomplete has a list of what they consider an intermediate Haskeller might know: https://www.schoolofhaskell.com/user/commercial/outline/intermediate-haskell
08:00:11 <merijn> Ah, looks like flat is pretty promising for sub-byte serialisation
08:00:26 <shapr> Fabian_W: if you have a specific fun thing you want to do with haskell, I agree with merijn, ask questions here and we can help!
08:00:40 <shapr> merijn: ooh, what are you serializing?
08:00:48 <merijn> shapr: ethernet, ip, and UDP frames
08:00:58 <Fabian_W> merijn: We did type-classes,evaluation, recursive design principles and run-time analysis, but we didn't start on Monads other than some IO without accessing the file system. I feel like we kind of stopped when Haskell was about to start becoming a "real" programming language and left it as more of a toy for thinking. Sorry, I am taking way too long to type this, thanks for your answers!
08:00:59 <shapr> merijn: hey that's what I was doing last night! how are you doing it?
08:01:23 <merijn> shapr: I *was* doing it in C++, that's sucks balls, so I'm planning to rewrite a simple frame serialiser in Haskell
08:01:23 <shapr> I'm trying to read a pcap and edit stuff
08:01:44 <merijn> shapr: So I'm gonna use flat to implement something. Just need a function to convert endianness
08:01:57 <shapr> merijn: already seen packet-sender? https://github.com/adamwalker/packet-sender/
08:02:30 <merijn> shapr: That looks like it actually sends packets, though?
08:02:37 <merijn> shapr: I need the binary data of the packet
08:03:43 <shapr> merijn: davean wrote a thing that does sub-byte de-serialization: https://code.xkrd.net/voip/rtp/blob/master/src/Data/RTP.hs
08:03:48 <merijn> Oh, wait!
08:03:54 <merijn> https://hackage.haskell.org/package/network-data
08:03:56 <merijn> Win
08:04:13 <merijn> Looks like I'm done :p
08:04:25 <shapr> merijn: I can't figure out how to make it go
08:05:09 <shapr> also, there's a fork of network-data that handles vlan tagging, you might end up needing that
08:05:31 <merijn> naah
08:05:40 <merijn> I just need bare minimum data generation
08:06:04 <merijn> A colleague is developing a hardware UDP implementation for FPGA and I need to generate test data to check we can receive it :p
08:06:14 <shapr> using clash-lang?
08:06:32 <merijn> No, in VHDL
08:06:37 <shapr> aw
08:06:55 <merijn> clash-lang is on the list of things I wanna introduce, but that's for later :p
08:07:02 <shapr> merijn: I'd like to see the code you end up with, since I'm not sure how to connect the pieces in network-data
08:07:27 <shapr> do I just make a serialize instance for a record that holds ethernet, ip, udp?
08:08:06 <merijn> shapr: There is already a Serialize instance
08:08:22 <merijn> So you just create values using the records then use Serialize
08:08:36 <Fabian_W> shapr: I've read about 3 random paragraphs of "What I wish I knew" and I already like the person who wrote it, thanks for the tip! It doesn't seem to have a preface, how much knowledge is assumed? 
08:08:44 <akersof> humm, what would be the structure of my haskell file if i just want to dot something like x :: Int x = 3 ?
08:09:16 <akersof> asking because i am getting the The IO action ‘main’ is not defined in module ‘Main’ when i try to launch the command "ghc myfile.hs"
08:09:17 <merijn> akersof: A file with just that would be legal haskell already :p (assuming a newline in between)
08:09:37 * hackage datadog-tracing 1.1.0 - Datadog tracing client and mock agent.  https://hackage.haskell.org/package/datadog-tracing-1.1.0 (fommil)
08:09:49 <shapr> merijn: I don't get it, perhaps I could see your code when it's done?
08:10:03 <shapr> ik begrijp het niet
08:10:13 <merijn> akersof: If you don't have an explicit "module MyName where" at the top it's (implicitly) assumed to be Main, which is supposed to have "main :: IO ()" (comparable to main in C)
08:10:20 <merijn> shapr: Sure, I'll ping you when it's done
08:10:49 <akersof> merijn: oh!!
08:12:12 <shapr> merijn: thanks!
08:16:32 <Fabian_W> "[With] Template Haskell [...]You can do some abolutely crazy things, like reading from the filesystem or doing network calls that informs how your code compiles, leading to non-deterministic builds" That sounds like _extreme_ wizardry. Is it?
08:17:07 <cocreature> Fabian_W: it’s not so much wizardry as dirty hacking :)
08:17:49 <shapr> I once figured out you could do runtime code reloading by running your entire program inside the Template Haskell build loop
08:17:52 <monochrom> I always joke about "use TH to play a movie during compilation" :)
08:18:10 <Fabian_W> cocreature: It does sound fun, though.
08:18:11 <shapr> My suggestion caused much horror.
08:18:57 <monochrom> Hey use TH to auto-correct your typos and bugs!
08:18:59 <Taneb> shapr: I... I would like to see that
08:19:15 <shapr> Fabian_W: In my head, Template Haskell is roughly equivalent to macros in lisp
08:19:50 <cocreature> Fabian_W: for reading files there are some decent usecases, e.g., embedding the git revision in your program
08:20:01 <cocreature> doing network calls is more questionable :)
08:20:06 <monochrom> Also I now realize I should extend my joke to "use TH to play a self-adventure movie during compilation, and the generated code depends on your self-adventure ending!"
08:23:02 <monochrom> A "serious" "application" of that is proof-as-self-adventure.  Use TH to implement the undecidable part of ideal DH!  When the type says "this function should do squaring" for example but the compiler can't prove it, ask the human to provide a proof, and the compiler just needs to check.
08:23:35 <Fabian_W> shapr: If I work through "what I wish I would have known when learning Haskell", is it enough to gain a working knowledge of Haskell? I have absolutely no sense of how far this rabbit hole goes.
08:23:43 <shapr> Taneb: it all started when Manuel Chakravarty decided the difficulty with runtime code reloading in lambdabot was that the types were all erased, and I realized that Template Haskell still has all the types available
08:24:00 <shapr> Fabian_W: what do you consider a working knowledge of Haskell?
08:24:49 <shapr> Fabian_W: I learn best when building a thing I need or want, so that's my suggested approach.
08:24:58 <Fabian_W> shapr: Being able to meaningfully contribute to open source projects, maybe? Or just generally having an idea of how to get Haskell to do work for me.
08:25:43 <shapr> When I learned Prolog I wrote a "degree solver" for my CS department, proving that our four year degree could not be completed in four years and irritating the faculty yet again.
08:26:00 <monochrom> haha
08:26:42 <shapr> Fabian_W: that sounds sensible, are you using any Haskell projects right now? xmonad? Shellcheck? pandoc?
08:27:05 <monochrom> It always amazes me how CS profs never apply CS to these things.
08:27:15 <cocreature> Fabian_W: step 1: read some introductory Haskell resource (there are various options for this but I don’t think “what I wish I would have known when learning Haskell” is an introductory resource, it’s more of an overview). step 2: Find a nice project and write some Haskell
08:28:03 <monochrom> Like "we're looking at our curriculum not the knapsack problem let's put on our average-layperson-on-the-street hat"
08:28:04 <shapr> oh, I like the cocreature approach. Perhaps you can use Haskell in the classes in your next term?
08:28:25 <Fabian_W> shapr: My next "ha ha only serious"-kind of question was actually "should I get get xmonad to become one with the Haskell?", so, not yet?
08:28:43 <cocreature> Since Haskell tends to be quite different from other languages, some upfront reading and learning tends to be more important whereas in other languages people often end up skipping step 1
08:28:46 <Fabian_W> I mean, I don't use any yet but I'm tempted.
08:29:03 <cocreature> but it’s equally easy in Haskell to never get to step 2 and keep on reading and reading without ever applying the knowledge
08:29:27 <shapr> yeah, find a balance between learning and doing
08:29:45 <aldum> >proving that our four year degree could not be completed in four years and irritating the faculty yet again
08:29:48 <aldum> hero
08:30:35 <kritzefitz> Fabian_W, my experience with xmonad is that xmonad doesn't help that much in learning Haskell, but more about how to configure xmonad with the building block from xmonad-contrib. But I was already quite familiar with Haskell when I started using xmonad, so my experience might not be that relevant to you.
08:32:15 <Fabian_W> I kind of feel guilty because I am absolutely avoiding step 2, as cocreature says. I really like the idea of using xmonad, is it hard to get started on using it? 
08:37:22 <rockbmb> Hello; does anyone know why the STM library depends on the `nats` package while Natural numbers are available through `base`?
08:37:58 <kritzefitz> Fabian_W, I think getting started isn't too hard, but it depends on what you want to achieve.
08:38:10 <Fabian_W> is learnyouahaskell.com/chapters a good "introductory resource"? I'm already halfway through it because it was assigned reading, but I got sidetracked by other books. 
08:38:30 <aldum> not hard, I used it for like a year without knowing what haskell even is
08:39:17 <kritzefitz> learnyouahaskell was my first contact with Haskell and I can really recommend it. Though, since you said you used Haskell in class already, I think you might not want to spend too much time on the earlier chapters.
08:39:18 <Fabian_W> kritzefitz: If we're talking about using it, probably just efficiency in managing my windows and not breaking my machine while setting it up.
08:39:37 <Taneb> rockbmb: on older GHCs, Numeric.Natural isn't available in base, and in newer GHCs, nats is empty, so it's a safe way to ensure support for newer and older versions of GHC
08:39:45 <kritzefitz> Basically you can install xmonad and use it without touching Haskell code at all. From there you can go as far as you want, step by step.
08:40:47 <Fabian_W> kritzefitz: Alright, I will try it soon, then. Thank you all for the help!
09:00:07 * hackage haskoin-store 0.11.0 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.11.0 (xenog)
09:00:38 <kuribas> Another question on (forall k. k -> (a -> k) -> k) as a catamorphism of (Maybe a)
09:01:48 <kuribas> since cata :: (Const (Maybe a) -> k) -> Maybe a -> k is basically the identity over (Maybe a -> k), wouldn't that be an algebra?
09:02:30 <kuribas> (forall k. k -> (a -> k) -> k) being basically another encoding for (Maybe a -> k)
09:02:55 <kuribas> and calling it a catamorphism not really wrong, but uninformative?
09:03:28 <lyxia> I think "catamorphism" in Haskell is overloaded.
09:03:32 <absence> is there a way to associate each type constructor of a sum type with a constant value, like an integer or string? i know i can make a function e.g. SomeType -> Int, but it feels brittle to have the definitions separate
09:03:52 <kuribas> lyxia: I thought it had a precise meaning
09:04:02 <lyxia> kuribas: in category theory it does
09:04:49 <lyxia> but as you noted, for constant functors it's kind of a pointless notion.
09:05:09 <lyxia> but in Haskell people still say  maybe  is a catamorphism
09:05:20 <kuribas> lyxia: is (Maybe a -> k) and initial algebra?
09:05:50 <kuribas> absence: why do you want that?
09:06:28 <lyxia> kuribas: an initial F-algebra is an object T of the underlying category (here Hask) + a morphism F T -> T + a universal property
09:06:55 <absence> kuribas: deserialisation
09:07:21 <kuribas> absence: there are libraries for that, like binary, cereal, ...
09:07:53 <absence> kuribas: my question is very specific though :)
09:07:57 <kuribas> lyxia: what's the property?
09:07:58 <lyxia> Here the functor is F = Const (Maybe a), the type is T = Maybe a and the morphism is (getConst :: Const (Maybe a) (Maybe a) -> Maybe a)
09:08:11 <kuribas> absence: then, other than writing SomeType -> Int, the answer is no.
09:08:32 <lyxia> To be rigorous an F-algebra should be given as a pair (T, f : F T -> T), but once you're used to it you tend to omit either one.
09:08:36 <kuribas> absence: though you could do it using generics
09:08:41 <kuribas> absence: or TH
09:10:22 <kuribas> lyxia: isn't the functor Const ?
09:10:47 <lyxia> kuribas: that for every other algebra (f : F T -> T), there is a *unique* function (cata_f : Maybe a -> T) (where (Maybe a, getConst) is the initial algebra) satisfying (cata_f . getConst = getConst . fmap cata_f)
09:11:28 <lyxia> kuribas: Const is not of kind Type -> Type
09:13:08 <slaterr> hi. what command line argument parser do you prefer, cmdargs or optparse-applicative?
09:13:48 <absence> kuribas: generics sounds interesting. i know i can convert to and from a representation of products and sums, but what part of it should i look into for what i had in mind?
09:15:19 <lyxia> absence: https://hackage.haskell.org/package/generic-data-0.5.0.0/docs/Generic-Data.html#v:gconIndex maps every constructor to a number
09:15:33 <lyxia> absence: https://hackage.haskell.org/package/generic-data-0.5.0.0/docs/Generic-Data.html#v:gconName maps every constructor to its name
09:18:07 <absence> lyxia: if i want to provide my own values, i guess TH would be necessary?
09:19:00 <lyxia> Would that be better than defining your function by hand?
09:19:29 <lyxia> I guess it's not clear what you are trying to automate.
09:22:19 <absence> lyxia: i think TH would be too heavy handed, just trying to get an overview of the possibilities. i haven't used TH, but i guess i could provide some data structure which TH can use to generate both the sum type and a SomeType -> MyValue function
09:22:43 <lyxia> kuribas: I'm sure "catamorphism" is sometimes used without the connection to category theory being particularly relevant. When you use maybe, you don't care that it's the catamorphism of a constant functor.
09:23:53 <kuribas> I am refering to this: http://blog.tmorris.net/posts/debut-with-a-catamorphism/index.html
09:24:33 <kuribas> lyxia: It led my coworker to believe this is a catamorphism, while I think that would be rather a CPS encoding of a datatype.
09:24:40 <lyxia> I would say that post proves my point
09:25:20 <lyxia> both are valid ways of understanding that function.
09:27:29 <lyxia> absence: if you're generating types from data then TH is indeed the way to go.
09:28:20 <kuribas> lyxia: it looks to me like the algebra without the catamorphism
09:29:35 <kuribas> this part: newtype Option a = Option { cata :: forall x. (a -> x) -> x -> x }
09:31:00 <lyxia> kuribas: if you flip around the parameters of cata, it's    forall x. (a -> x) -> x -> Option a -> x    i.e.    forall x. (Maybe a -> x) -> Option a -> x   i.e.,   forall x. (Const (Maybe a) x -> x) -> Option a -> x
09:31:38 <lyxia> kuribas: so cata maps an algebra (F x -> x) to a function (Option a -> x)
09:33:54 <kuribas> lyxia: how do you go from (a -> x) to Maybe a?
09:35:14 <lyxia> kuribas: I go from  (a -> x) and x  to  (Maybe a -> x)
09:35:48 <kuribas> hmm, right
09:36:41 <kuribas> lyxia: then going the other way around would be a catamorphism as well?
09:37:38 <lyxia> what other way around
09:38:35 <lyxia> Strictly speaking, the catamorphism is the function (Option a -> x)
09:38:44 <lyxia> there is one catamorphism for every algebra (F x -> x)
09:40:12 <lyxia> so what we usually see in code as "cata" is the higher-order function that maps algebras to their catamorphisms
10:00:36 <kuribas> ah right
10:01:37 <kuribas> If a Functor is a mapping between cathegories, doesn't the haskell functor only has the mapping between morphisms?
10:01:59 <kuribas> (a -> b) -> (f a -> f b)
10:02:02 <kuribas> but not a -> f a
10:02:05 <kuribas> that would be pire
10:02:07 <kuribas> pure
10:02:49 <Solonarv> a haskell 'Functor' is an endofunctor in Hask (the category of Haskell types)
10:02:58 <johnw> 'f' is the object mapping
10:03:09 <johnw> the objects are types, so 'a' is mapped to 'f a'
10:03:20 <johnw> a -> f a would be a mapping of values
10:04:01 <Solonarv> so when you write a Functor instance, you're associating a "morphism-mapping" with the preexisting "object-mapping" given by 'f'
10:04:09 <kuribas> so the category theory concepts apply only on the type level?
10:04:12 <johnw> which Applicative can do because that's the form of its natural transformation from identity to f
10:04:17 <johnw> no, they apply at any level
10:04:21 <johnw> but not in Haskell
10:04:30 <johnw> at least, not in the form of any common type classes
10:04:43 <johnw> regular functions are functors between discrete categories, for example
10:04:58 <johnw> (or, can be)
10:05:49 <Solonarv> when we apply category-theoretic ideas to Haskell, we *usually* work in the category Hask of Haskell types (where the objects are Haskell types, and the morphisms are functions)
10:06:13 <kuribas> then where do the laws come from?
10:06:16 <Solonarv> (this category is somewhat similar to Set, where the objects are sets and the morphisms are functions)
10:06:17 <kuribas> fmap id = id
10:06:28 <johnw> the functor laws come from the idea of a "category morphism"
10:06:40 <johnw> the functor laws are just showing that the categorical structure is preserved through the mappings
10:07:13 <johnw> so, because categories have lawful identity and composition, functors must not only map identities and composition, but also their lawfulness
10:07:48 <johnw> fmap id = id, and fmap (f . g) = fmap f . fmap g is just the identity and composition mappings
10:07:50 <kuribas> ah right
10:07:57 <johnw> the fact that both sides are categories gives you the laws on each side
10:08:14 <johnw> conal might call the functor laws "category homomorphisms" :)
10:08:32 <johnw> since you're denoting the structure of one category into another
10:08:49 <conal> yep
10:09:03 <johnw> yay, conal appears! :)
10:09:09 <conal> johnw: hi! :) 
10:09:44 <johnw> conalI
10:09:58 <johnw> conal: I spent yesterday finding out how the C stack moves when calling from Haskell->C and back again
10:10:37 <kuribas> cool, I am giving a short presentation on functors to my coworkers, and I'd like to focus on this structure preserving part.
10:10:49 <kuribas> I kind of dislike the Functors are containers analogy.
10:11:06 <johnw> kuribas: absolutely
10:11:10 <conal> kuribas: good! 
10:11:50 <conal> It strikes me as ironic that people make imprecise analogies about functors, since functors are about precise analogies.
10:11:56 <rockbmb> @Taneb, I understand now, quite useful - thank you!
10:11:56 <lambdabot> Unknown command, try @list
10:12:00 <kuribas> yeah
10:13:10 <rockbmb> Taneb, I understand now, quite useful - thank you!
10:13:50 <conal> johnw: do you like what you learned about the C stack and Haskell->C?
10:14:01 <johnw> I'm not liking it so far, no
10:14:14 <johnw> I still have an incomplete picture, so I'm writing a test project right now to explore all the combinations
10:14:15 <conal> “Every sufficiently good analogy is yearning to become a functor.” -- John Baez
10:14:31 <johnw> bound thread vs. un bound, re-entrant code, unsafe calls, etc.
10:14:51 <conal> eep
10:15:21 <johnw> what's happening to me right now is that when I call into the FFI at one point in my code, and ask for the current stack base, and then a little while later do so again (from within the same bound thread), my stack base has moved by 2.1 MB. But I don't evenk now if that's an arbitrary shift or not.
10:15:28 <johnw> operational stuff can sure suck
10:25:33 <vaibhavsagar> does anyone have experience working around `(ConnectionFailure Network.BSD.getProtocolByName: does not exist (no such protocol name: tcp))` when running tests in a Nix sandbox?
10:25:43 <johnw> yeah
10:25:54 <vaibhavsagar> I tried adding `pkgs.iana-etc` to `testSystemDepends` but that didn't seem to make a difference
10:25:58 <johnw> you need to add /etc/protocol to your sandbox-paths
10:26:14 <vaibhavsagar> aha
10:26:21 <vaibhavsagar> thanks johnw!
10:26:34 <johnw> i ran into the same thing very recently :)
10:26:41 <johnw> see https://github.com/NixOS/nix/issues/1238
10:28:15 <vaibhavsagar> I tried the libredirect thing listed there too actually, and that didn't work for me
10:35:08 <wroathe> Which combination of -d* flags to ghci gives the clearest view of the dictionary representation for typeclass instances?
10:35:16 <wroathe> to ghc I mean
10:44:50 <Solonarv> wroathe: try -ddump-ds or -ddump-simpl, in combination with -dsuppress-all and (optionally) -ddump-to-file
10:46:32 <wroathe> Thanks Solonarv 
10:46:51 <Solonarv> (generally a good default for looking at Core)
10:48:44 <cocreature> personally I usually don’t suppress type signatures but that’s up to you to decide if you find that helpful or noise :)
10:50:59 <monochrom> Turning on type signatures but suppressing others requires manually listing those 10 other things to suppress...
10:51:42 <monochrom> At some point you begin to appreciate a GUI on which you just tick/untick 12 checkboxes.
10:53:49 <Solonarv> actually, you can just pass -dsuppress-all -dno-suppress-type-signatures
10:53:57 <Solonarv> (in that order)
10:54:13 <wroathe> Solonarv: Yeah, I was going to say that I thought GHC supported both opt-in and opt-out in many cases
10:54:32 <wroathe> Generally a best practice for complicated CLIs with lots of flags like this
10:54:41 <monochrom> Aw the user guide is failing me. It doesn't say I can do that.
10:54:47 <Solonarv> oh, looks like the order actually doesn't matter
10:55:08 <Solonarv> I think somewhere in the user's guide it might say that most flags can be negated with no-
11:00:21 <cocreature> There is also https://github.com/yav/dump-core which outputs core as nice HTML if you prefer that
11:01:28 <eschnett_> is there a type similar to MVar that is only once-writeable? like a future in C++?
11:02:00 <johnw> you could create an MVar containing a bool and a value, and then create your own writing function that only lets it happen once
11:02:09 <johnw> and only export that API from your module
11:02:46 <monochrom> I would uproot that and use Async. Because "future".
11:03:07 <wroathe> Yeah, async basically functions like a future
11:03:29 <johnw> monochrom: good idea
11:06:01 <Solonarv_> there are one or two 'IVar' packages out there
11:08:05 <asthma[m]> is haskell from first principles the book to get started with haskell?
11:10:07 <yushyin> it is a well written book but not _the_ book, there is no _the_ haskell book
11:11:42 <wroathe> I liked Programming in Haskell for it's exercises
11:18:50 <sm> I like https://leanpub.com/haskell-cookbook
11:19:28 <slaterr> cmdargs or optparse-applicative for command line arguments parsing?
11:20:34 <johnw> latter
11:21:04 <cocreature> johnw++
11:22:45 <wroathe> FFI to getopt
11:23:59 <cocreature> no because no
11:24:25 <wroathe> Sorry, my inner stackoverflow was leaking
11:25:18 <kritzefitz> I just now learned about cmdargs and from its description I learned that there is System.Console.GetOpt in base.
11:25:18 <monochrom> If optparse-applicative looks too big to learn, options is much smaller (and can't do something) and still along the same line, i.e., Applicative.
11:26:32 <kritzefitz> System.Console.GetOpt looks kinda like wroathe's suggestion of using the FFI, just without the FFI.
11:26:56 <adius> Hi, is there a more idomatic solution to achieve `(accessToken :: Token) <- param "access_token"` without using `ScopedTypeVariables`
11:27:15 <cocreature> If optparse-applicative looks too big to learn, learn it anyway. You’re not going to regret it :)
11:27:23 <Solonarv> ScopedTypeVariables *is* the idiomatic solution as far as I'm concerned
11:27:44 <cocreature> Yeah, ScopedTypeVariables is totally fine for this
11:28:14 <cocreature> it’s slightly unfortunate that pattern signatures are part of ScopedTypeVariables but that’s just how it is
11:30:30 <adius> Solonarv, coreature: Cool, thanks 😁
11:31:42 <adius> My list of default-extensions just keeps growing and growing 😅
11:32:11 <wroathe> kritzefitz: My suggestion was me being a troll, and not something he/she should do
11:33:08 <jle`> adius, cocreature: there's a proposal to introduce PatternSignatures or something so you don't need the full power of scoped type variables
11:33:15 <kritzefitz> wroathe, I thought so. I also didn't actually want to suggest using System.Console.GetOpt.
11:33:25 <jle`> but yeah, ScopedTypeVariables is pretty idiomatic
11:33:46 <jle`> adius: fwiw, a lot of idiomatic haskell is only available with ghc extensions
11:34:05 <jle`> so it isn't really necessary to try to avoid them :)
11:34:22 <kritzefitz> That was what I was trying to convey, when I referenced your suggestion.
11:34:36 <adius> It's just very cumbersome to figure all this out. I hope Haskell 2020 will make things easier 
11:34:43 <jle`> adius: but, also default-extensions isn't really recommended, usually
11:35:01 <jle`> usually people like to put all their extensions in the files that use them
11:35:17 <monochrom> I think you're better off looking forward to Haskel 2030. Don't hold your breath. >:)
11:35:26 <jle`> adius: it might be cumbersome to add, but it's not that hard to figure out what extension to use usually :)  often times GHC will directly tell you
11:35:31 <jle`> what extension is required
11:35:37 <jle`> that should be the case for ScopedTypeVariables
11:35:57 <jle`> at least when using it for pattern signatures
11:36:28 <monochrom> Haskell 2020 is like me trying to make my midterm test now.  Every day I say "it will be done tomorrow" and that has happened for 5 days.  And the midterm is on next Monday.
11:36:31 <adius> Yeah, good point, it was proposed …
11:37:02 <wroathe> Hey jle`, I've asked others about this, but I think you might be better equipped to answer... What are my options for writing a type polymorphic function whose arity depends on the arity of it's first function argument: https://gist.github.com/JustinChristensen/364682896fe783ed632a2437bdb79ba0
11:37:08 <monochrom> And actually the accessibility department is on my back now because I'm supposed to send them my midterm test two-three business days before.
11:37:19 <wroathe> jle`: Others have suggested typeclasses, which is what I'm looking into now
11:38:25 <adius> monochrom: But I guess you still deliver it on time somehow. As long as Haskell 2020 is released until 2020-12-31T23:59 I'm happy 😂
11:40:39 <wroathe> monochrom: And yet you're procrastinating on IRC >:D
11:40:50 <jle`> wroathe: a typeclass might be a simple way to do it, yeah
11:41:07 <jle`> but you might also be able to pull something together with just simple partial application
11:41:20 <jle`> kind of like how we have liftA2/liftA3/liftA4 etc. with only <*> and <$>
11:41:30 <jle`> :t liftA2
11:41:31 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
11:41:33 <jle`> :t liftA3
11:41:34 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
11:42:02 <jle`> it doesn't directly react on the input function, but you can construct liftAN of arbitrary N with just adding more <$>'s
11:42:03 <slaterr> optparse-applicative looks pretty neat
11:42:05 <jle`> er, adding more <*>'s
11:43:09 <wroathe> jle`: Hmm, that might be another good route. Thanks for the suggestion.
11:43:27 <jle`> if you want something auto-magic, then maybe type families or typeclasses could work. things can get tricky though because it isn't always clear how many "arguments" a function expects
11:43:39 <jle`> for example, do you want to interpret Int -> (Bool -> String) as a one-argument function, or a two argument function
11:43:42 <wroathe> jle`: Yeah, I wasn't totally happy with that because of exactly that reason
11:43:50 <jle`> dealing with this in the polymorphic way is tricky.
11:44:16 <jle`> building them explicitly with chained <*>'s or something might be better. usually explicit is better than implicit :) unfortunately it does require a bit more creativity i think
11:45:13 <Solonarv> one way to resolve the ambiguity is to have a special argument to signify an "end"
11:45:34 <monochrom> Ah, Okassaki tried that.
11:45:57 <monochrom> Then he ran into causing GHC to take exponential time.
11:47:32 <Ariakenom> what's a few more hours of compile time
11:47:43 <wroathe> jle`: I'm trying to build up a small DSL for loading configuration data: merge @Yaml from file "config/app.yaml", merge @Json from requiredFile "config/app.json"
11:48:18 <wroathe> But the "source" function (file, requiredFile) should in theory be able to have arbitrary arity
11:48:39 <wroathe> The file sources just require a FilePath, but whose to say other sources can't require more arguments
11:49:01 <jle`> you can do something like merge @Json `from` foo blah blah blah
11:49:07 <jle`> and just have it return some data type
11:49:31 <jle`> as in (file :: FilePath -> FinalResult), (otherSource :: X -> y -> Z -> FinalResult)
11:50:59 <wroathe> jle`: You and your good suggestions :D
11:51:10 <wroathe> jle`: Using `from` as an operator is genius 
11:51:28 <jle`> or just merge @Json (fromFile "blah")
11:51:40 <wroathe> I wanted to avoid parens
11:52:37 <gwiley> how do I generate the package indices needed to host private packages on S3?
11:53:20 <wroathe> jle`: Thanks!
11:54:13 <gwiley> google searches seem to indicate it can be done and consumed by stack but I cannot find instructions how to generate
11:57:26 <javran> is there an upperbound of # of unbound threads for GHC?
12:04:03 <Solonarv> javran: I'm not aware of any concrete upper bound. I recall hearing that it can handle several thousand threads without too much trouble, though.
12:05:10 <MarcelineVQ> from a technical pov it'd be at most the pointer size of your computer since thread's have id's that are also pointers to them, but it could be smaller too
12:07:24 <Solonarv> threads take up more than 1 word, so it would stop way earlier
12:08:07 <javran> i see
12:09:23 <Solonarv> why do you ask? 
12:09:56 <javran> i'm just wondering, as bound threads have clear upper bounds in the doc
12:11:16 <monochrom> Bound threads will have to be capped by your OS eventually.
12:11:25 <MarcelineVQ> https://github.com/atemerev/skynet has comfortable use of 1 million threads if that's useful to you
12:11:57 <javran> I see
12:12:10 <fen> whats StateT ? is it like get and set for monads?
12:12:30 <Solonarv> No.
12:12:33 <pie___> why do haskell people love writing *completely* undocumented libraries so much. like, thanks for writing something that looks useful to me but now i have to go reverse engineer it first
12:12:38 <argent0> hi, how do I tell cabal where to find libz.so?
12:12:47 <javran> perhaps I should ask how many unbound threads are allowed to run concurrently at any point in time, is that bounded by # of capabilities?
12:13:02 <sm> fen: yes :)
12:13:05 <argent0> extra-lib-dirs: didn't work
12:13:05 <fen> pie: what library are you looking at?
12:13:10 <Solonarv> *actual* simultaneity, yes I thin
12:13:30 <monochrom> I think the undoc problem is prevalent throughout all programming. Sure maybe more noticeable in Haskell land.
12:13:42 <javran> yup, simulatneously was what i meant
12:13:45 <pie___> fen, https://github.com/tov/preprocessor-tools-hs
12:13:46 <argent0> also, can I see where does cabal looks for .so files?
12:13:59 <Solonarv> but even if you have only one capability, the RTS' scheduler will "interleave" your threads so it will still look fairly simultaneous
12:14:08 <pie___> fen, i want to write a horrible preprocessor because i have a ton of very structured imports
12:14:09 <fen> pie: thats not on hackage, where it would have hadock
12:14:32 <pie___> fen, it would be nice to have to write less boilerplate
12:14:32 <monochrom> However, in other lands the problem I see is that they write some junk that just tells you what you can guess from names and # of parameters already.
12:14:40 <javran> guess unbound threads are more like tasks scheduled on capabilities
12:14:44 <pie___> fen, https://hackage.haskell.org/package/preprocessor-tools-2.0.2/
12:15:14 <fen> ah thats really bad style, that contents page should have clickable links to the hadock
12:15:23 <javran> can I assume when threadDelay is called, it's automatically a yield?
12:15:31 <Solonarv> that's not "bad style", that's "docs failed to build"
12:15:31 <monochrom> In particular PHP library docs are written imprecisely with "you know what I mean" in mind.  And you actually don't know what they mean.
12:15:58 <Solonarv> threadDelay yields, I think
12:15:59 <fen> well better style would involve ensuring the documentation exists!
12:16:14 <Solonarv> there's also a 'yieldNow' (or similarly named) somewhere
12:16:23 <pie___> fen, :p
12:16:32 <monochrom> Yes threadDelay is a yield point. There are also a lot of other yield points.
12:16:35 <fen> maybe its a work in progress, are you sure you can rely on it for stability?
12:16:44 <javran> got it
12:17:04 <fen> sm, Solonarv: could you either elborate? 
12:17:06 <pie___> fen, nope but i dont really care, also last commit was 10 months ago
12:17:07 <Solonarv> the repo was last touched 10 months ago, not a good sign!
12:17:29 <Solonarv> javran: for example, any allocation is also a yield point
12:17:44 <fen> well, that would be fine if it was totally complete, but then it would probably have documentation
12:17:51 <Solonarv> (although it's not always obvious which "allocations" actually end up allocating in the final program)
12:18:04 <fen> isnt StateT likereader +writer or something?
12:18:44 <pie___> fen, https://bpaste.net/show/23bfe33b915a
12:19:00 <pie___> i "just" want to do that
12:19:09 <Solonarv> something like: fact n = go 1 n where go acc 0 = acc; go !acc n = go (acc*n) (n-1), actually doesn't allocate in the "inner loop"
12:19:12 <pie___> i guess i could write some horrible bash script or jus tstring replacement or something...
12:19:37 <Solonarv> pie___: there's already a tool for this I think
12:19:46 <pie___> Solonarv, oh?
12:19:56 <pie___> template haskell doesnt support messing with imports
12:19:56 <Solonarv> let me find it
12:20:01 <fen> if you want functions to help write that there are many alternative libs
12:20:01 <pie___> thanks :>
12:20:09 <Solonarv> https://theam.github.io/require/
12:20:16 <pie___> fen, im open to suggestions
12:20:30 <pie___> Solonarv, oooh
12:20:53 <fen> well, that would require some thought, otherwise it would probably start with data.list!
12:21:09 <fen> :t isSuffix
12:21:10 <lambdabot> error:
12:21:10 <lambdabot>     • Variable not in scope: isSuffix
12:21:10 <lambdabot>     • Perhaps you meant one of these:
12:21:15 <fen> % :t isSuffix
12:21:15 <yahb> fen: ; <interactive>:1:1: error:; * Variable not in scope: isSuffix; * Perhaps you meant one of these: `BSL.isSuffixOf' (imported from Data.ByteString.Lazy), `BS.isSuffixOf' (imported from Data.ByteString), `isSuffixOf' (imported from Data.List)
12:21:18 <fen> sorry
12:21:20 <fen> nvm
12:21:28 <monochrom> Pretty neat.
12:22:09 <fen> anyway, just trying to understand the StateT thing, hows it a Monad? because get and set is like list and list is a monad?
12:22:16 <fen> or a tranformer or whatever
12:22:25 <fen> why are they *monad* transformers
12:22:36 <fen> if it just had set it wouldnt be a monad right?
12:22:51 <Solonarv> 'StateT s' is a monad transformer because 'StateT s m' is a monad whenever 'm' is
12:22:58 <fen> i can implement monad for something with get *and* set though
12:23:03 <Solonarv> that's what "monad transformer" means
12:23:32 <fen> so we wouldnt be able to write a Set monad transformer?
12:24:15 <Solonarv> that sounds like 'WriterT (Last s)'
12:24:35 <fen> Last?
12:25:27 <Solonarv> % :i Data.Monoid.Last
12:25:27 <yahb> Solonarv: newtype Last a = Last {getLast :: Maybe a} -- Defined in `Data.Monoid'; instance Applicative Last -- Defined in `Data.Monoid'; instance Eq a => Eq (Last a) -- Defined in `Data.Monoid'; instance Functor Last -- Defined in `Data.Monoid'; instance Monad Last -- Defined in `Data.Monoid'; instance Monoid (Last a) -- Defined in `Data.Monoid'; instance Ord a => Ord (Last a) -- Defined in `Data.Monoid'; instanc
12:25:52 <fen> but the monad instance for some f requires both get set. like a list without get wouldnt be a Monad
12:26:12 <fen> http://hackage.haskell.org/package/first-and-last-0.1.0.1/docs/Data-Monoid-Last.html
12:26:28 <Solonarv> the "get" and "set" of StateT don't have much to do with the "get" and "set" you've defined
12:26:38 <Solonarv> also: Last is in base, has been for a while
12:27:08 <wroathe> :% :t StateT
12:27:13 <wroathe> % :t StateT
12:27:13 <yahb> wroathe: (s -> m (a, s)) -> StateT s m a
12:27:31 <javran> so the actual story is that I don't want to run into trouble when multiple threads are writing to stderr, and I end up having a dedicated logger thread listening on a channel where other threads can post logs, then suddenly i start to wonder what if I just let every resource (race-sensitive ones e.g. handle) to be held on a dedicated thread and would this be a problem
12:27:57 <fen> oh so `m' already has a monad instance
12:28:37 <Solonarv> if you run into issues with that approach I'm quite sure it won't be "too many threads"
12:28:37 <monochrom> Using unbound threads are cheap and having many isn't a problem.
12:28:43 <fen> the get and set would allow a monad instance for s, like if s=[a]
12:28:47 <monochrom> s/Using/Usually/
12:29:09 <pie___> Solonarv, hm. "ghc: could not execute: requirepp" im on nixos. i do have requirepp runnable from bash though, so its in the environment
12:29:23 <wroathe> fen: The thing that helped me understand State was https://gist.github.com/sdiehl/8d991a718f7a9c80f54b#file-state-hs-L49
12:29:30 <monochrom> However it's also OK to do a "lock, using Handle, unlock".
12:29:34 <Solonarv> I've never used require and never used nix, can't really help you
12:29:55 <monochrom> s/using/use/
12:30:03 <javran> right, for now my program consists of less than 10 threads so I'm just thinking about some extreme case xD
12:30:07 <wroathe> Solonarv: Doesn't GHC let you write and use C preprocessor macros? Couldn't that be used to emulate this?
12:30:41 <Solonarv> you can use the C preprocessor, and I suppose you could use it to hack together something require-like (but with less nice syntax)
12:30:41 <gmsh> Got a noob question about installing stack, if someone has time for such a thing...?
12:30:49 <Solonarv> @where justask
12:30:49 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
12:30:53 <Solonarv> gmsh: ask away!
12:30:54 <fen> Solonarv: just thought there might be stream linear and stack varients
12:31:11 <fen> and apparently now also skip
12:31:30 <fen> s -> (Maybe a,s)
12:31:58 <fen> and its linear and stack varients 
12:32:26 <fen> would this cover most if not all the different types of state transformer?
12:32:29 <gmsh> Trying to install stack for the first time on a Debian environment. Using the instructions from haskellstack.org. It seems to install some of the packages, but then issues this complaint:
12:32:43 <gmsh> The certificate of ‘github-production-release-asset-2e65be.s3.amazonaws.com’ is not trusted.
12:32:52 <javran> monochrom: by lock/unlock I assume you meant MVar related operations?
12:32:59 <monochrom> Yeah
12:33:44 <javran> i see
12:33:57 <fen> as the current version of StateT uses the stream version, how does the user deal with finite containers?
12:34:06 <gmsh> Probably more of a certificates configuration problem than a stack problem but Google hasn't been helpful so far.
12:34:31 <Solonarv> pie___: require is in nixpkgs, if you're building with nix and have it specified as a dependency I would guess it should work?
12:34:36 <javran> guess in some sense there're using the same mechanism given Chan is implemented on top of MVar
12:35:21 <fen> StateT1 where StateT :: (s -> m (a, Maybe s)) -> StateT s m a
12:35:43 <fen> s/StateT/StateT1
12:36:28 <fen> is StateT just for streams?
12:36:47 <pie___> Solonarv, yeah thats what i figured. re: i can execute it from the shell (which is also the environment im using ghc from..)
12:36:53 <pie___> weird.... :I not sure how to debug it
12:37:12 <Solonarv> StateT is not "for streams" any more than it's "for trees" or "for pairs"
12:37:35 <wroathe> gmsh: Are you running the curl command on that page?
12:37:36 <pie___> is it possible to make ghc output commands it calls during compilation
12:37:55 <wroathe> try doing | sh -Ox
12:37:57 <monochrom> Yeah, -v, but it's going to be also a lot other things.
12:38:06 <pie___> ah i think i can pass -v3
12:38:12 <pie___> https://downloads.haskell.org/~ghc/7.0.2/docs/html/users_guide/options-help.html
12:38:41 <wroathe> gmsh: That should at least tell you which command it's failing on
12:38:51 <wroathe> Which I suspect is the curl download of the actual package
12:39:25 <pie___> ok now it started working for some reason :I
12:39:41 <fen> Solonarv: but it always returns `s', so s unfolds a stream
12:40:03 <Solonarv> fen: what if 'm' is chosen to be 'Proxy'? then you never get anything back!
12:40:14 <pie___> Solonarv, idk it fixed itself somehow ;~; anyway thanks, it works perfectly!
12:41:55 <gmsh> wroathe: I ran the wget command. I will try the curl and see if it behaves any differently or provides more information.
12:42:48 <wroathe> gmsh: Yeah, use curl
12:43:50 <fen> can we have an m such that m (a,s) = m' (a,Maybe s) ?
12:43:50 <pie___> Solonarv, ohhh thats soooo much nicer ;~;
12:44:11 <fen> like, is the choice of m a way to encode the extent of the unfolding?
12:44:23 <Solonarv> fen: probably, but I'm not sure if it can be a monad
12:44:50 <fen> hmm
12:45:21 <fen> just wondering how people have made do with just a stream version
12:46:18 <fen> its easy to use a stream to make a finite container, but not the other way round
12:47:11 <Solonarv> Perhaps that's why
12:48:20 <fen> but then the extent of the unfold is always specified some other way, not via the ability of `s' to keep returning values
12:48:58 <fen> and if running get on a list for the state, this would be finite
12:49:17 <Solonarv> you could use 'StateT s Maybe'
12:49:18 <fen> s =[a] would alway cause an error
12:49:29 <Solonarv> or even 'StateT s (MaybeT m)'
12:50:18 <fen> Solonarv: right, ok, so streams and finite contaiers with empty are easy with this setup
12:50:30 <Solonarv> @unmtl StateT s (MaybeT m) a
12:50:30 <lambdabot> s -> m (Maybe (a, s))
12:50:32 <gmsh> wroathe: I think I'm around it now, having taken my chances with curl's --insecure option. :-)  Thanks for your help.
12:50:37 <fen> and the the problem is nonempty
12:50:48 <fen> maybe thats why they are not as common
12:51:00 <Solonarv> sounds plausible, yes
12:51:04 <fen> despite them being better as they are comonads!
12:51:49 <fen> StateT1 where StateT1 :: (s -> m (a, Maybe s)) -> StateT1 s m a, is well motivated then?
12:52:10 <fen> wonder how the comonad thing appears here
12:56:13 <fen> well, probably like how get and set give a monad on s, its s which is a comonad if its a nonempty containter of `a' for use with StateT1
12:56:54 <fen> can we have a zipper monad transformer?
12:57:25 <fen> zippers are over nonempty and give a nicer comonad than tail...
12:58:42 <fen> still not quite sure how get and set work for stateT
12:59:02 <wroathe> fen: :P Look at the implementation
12:59:37 <fen> the state type it wraps is just get
12:59:52 <fen> maybe it has a church like set
12:59:56 <wroathe> http://hackage.haskell.org/package/transformers-0.5.6.2/docs/src/Control.Monad.Trans.State.Lazy.html#get
12:59:56 <Solonarv> get = StateT (\s -> pure (s, s)); set s = StateT (\_ -> pure ((), s))
13:00:41 <Solonarv> (except it's called 'put', not 'set' - oops!)
13:02:15 <fen> oh, put is not like set, put replaces the state, set is dual to state = get
13:02:42 <fen> runStateT = get rather
13:02:51 <fen> dual
13:02:55 <fen> argh
13:03:36 <fen> so that stuff about writer last was wrong?
13:04:12 <Solonarv> I guess so, if I misunderstood what you meant by "StateT but only with set"
13:05:55 <fen> well if stateT is like set, whats the "get like" transformer?
13:06:32 <Solonarv> at this point I have no idea what you actually mean when you say "get" or "set"
13:07:19 <fen> data CoStateT s m a = CoStateT {runCoStateT :: m (a,s) -> s}
13:07:53 <koz_> fen: Shouldn't that be m (a,s) -> m s?
13:08:04 <fen> state is synonymous with get which is dual to set 
13:09:32 <mouse07410> wroathe: and I disliked Programming in Haskell because it's exercises weren't tightly coupled with the sections they were supposed to further understanding of, done of them were rather convoluted - and none came with an answer so the reader could gauge his thinking and see where his understanding lacks or diverges.
13:10:39 <wroathe> mouse07410: I also experienced that last bit. I actually hand to send the Professor an email for clarification :/
13:11:19 <wroathe> mouse07410: It seems like it's pretty rare for programming book authors to actually publish selected answers/guidance for their problems
13:11:39 <wroathe> mouse07410: But if you have a suggestion that you think has better exercises, I'm all ears.
13:11:41 <fen> koz,no
13:11:43 <fen>  % :t StateT
13:11:47 <fen> % :t StateT
13:11:47 <yahb> fen: (s -> m (a, s)) -> StateT s m a
13:12:07 <fen> its just that with the arrow flipped
13:12:24 <MarcelineVQ> It's almost like they know as teachers that students tend to just look at the answers if the option is presented :>
13:13:26 <monochrom> This is one of those cases where marking is the antithesis of teaching.
13:13:31 <Solonarv> fen: that's not a comonad!
13:14:13 <monochrom> For teaching purposes you always want to publish model answers. For marking purposes if you anticipate someone else to use your exercises for homework you can't publish model answers.
13:14:23 <fen> MarcelineVQ: and that option wasnt available to the writers of the book, so why should they save anyone else the time!?
13:14:33 <wroathe> MarcelineVQ: I can't speak for others, but I know that I usually take a good shot at a problem, and if I can't figure it out on first try I'd like to have hints available that get me closer and closer to the answer
13:14:56 <monochrom> Now enter this elaborate secret network of profs who are OK with exchanging model answers with each other.
13:15:30 <fen> Solonarv: no, its (s -> (a,Maybe s)) + ((a,Maybe s) -> s) which gives a comonad on s
13:15:41 <mouse07410> ^I meant "Haskell Programming from the First Principles"
13:15:42 <fen> this was just a get like transformer
13:15:54 <fen> to go with the set like StateT transformer
13:16:16 <Solonarv> fen: (a, s) -> s is contravariant in a, it's not even a Functor!
13:16:45 <fen> :t  (:)
13:16:46 <lambdabot> a -> [a] -> [a]
13:16:56 <fen> :t curry (:)
13:16:57 <lambdabot> a -> b -> [(a, b)] -> [(a, b)]
13:16:59 <wroathe> mouse07410: Ah, I haven't read that one and so I can't recommend it :P
13:17:03 <fen> :t uncurry (:)
13:17:03 <lambdabot> (a, [a]) -> [a]
13:17:08 <fen> that one^
13:17:42 <Solonarv> that's invariant in a, still not a Functor (let alone a Comonad)
13:18:12 <fen> oops, obviously state is get like, and CoStateT is set like, got that the wrong way round above
13:18:34 <fen> there was never anything about it being a comonad!"
13:18:40 <fen> nonempty is a comonad
13:19:38 <Solonarv> 'newtype CoStateT s m a = CoStateT { runCoStateT :: m (a, s) -> s }' isn't a monad either
13:19:43 <fen> oh! your trying to derive the comonad instance for a comonad transformer costate
13:19:53 <johnw> nonempty also a monadtoo
13:20:21 <fen> what are those called, monads which are comonads?
13:20:26 <Solonarv> (well, perhaps it's something interesting when 'm' is contravariant, idunno)
13:20:33 <fen> all linear containers are
13:20:40 <johnw> https://stackoverflow.com/questions/27171960/is-there-a-term-for-a-monad-that-is-also-a-comonad
13:20:55 <MarcelineVQ> a bromad
13:21:14 <fen>  (f a -> (a,Maybe f a)) + ((a,Maybe f a) -> f a) = Comonad f + Monad f 
13:21:29 <mouse07410> wroathe: this is not a "grading" book. It was supposed to help me understand the concepts better. It hinders that in two ways: the exercises aren't related closely enough to the sections they're supposed to help with, and there's no guidance for them whatsoever. I'm lucky to have a couple of good Haskell programmers at the next office, so I asked them for explanation. Without that it would turn out bad. I find other books
13:21:29 <mouse07410> both less encumbered and more reader-friendly.
13:21:36 <johnw> someday soon there should be an IRC AI that answers questions based on content it finds on stack overflow
13:22:08 <MarcelineVQ> johnw: Too much work, just have a bot with a canned response that critiques the way the question was asked.
13:22:15 <johnw> lol
13:22:22 <monochrom> That would be me.
13:22:24 <johnw> or questions the accuracy of the terminology used
13:22:33 <fen> but that SO post says they are rare and useless, wheras they seem to be common and awesome
13:23:03 <johnw> theoretically useless, practically awesome
13:23:34 <fen> well they are traversable and monadPluss too...
13:23:42 <johnw> for example with nonempty, extract . return = id, but return . extract != id
13:23:49 <johnw> so I dispute his claim that they are always meaningless
13:24:33 <mouse07410> wroathe: Donald Knuth published some. And I've never seen a book yet where the exercises were as divorced from the topics. Considering that I programmed in pretty much every language since Algol-60, and learned most of them from books - that's a tall bar to make! 😄🤬
13:24:40 <fen> anyway thats another issue, apparently the dual thing to StateT is not a monad
13:24:54 <fen> but this was the point anyway about why are they *monad* transformers
13:24:55 <Solonarv> https://stackoverflow.com/questions/16551734/can-a-monad-be-a-comonad has a bunch of examples
13:25:16 <Solonarv> there are different ways to "take a dual" depending on which arrows you flip around
13:25:37 <johnw> I took a duel and wasn't able to return
13:27:12 <fen> so its not a monad, can we lift? what other things are transformers for, are there any good compositional properties?
13:28:29 <pagnol> cabal keeps saying "rejecting: postgresql-simple-0.5.3.0/installed-6eT... (package is broken)"
13:28:55 <Solonarv> monad transformers were invented in precisely because monads don't compose very nicely
13:28:58 <pagnol> what can I do in this case?
13:29:38 <Solonarv> pagnol: what command did you run?
13:29:46 <pagnol> cabal build
13:29:51 <shapr> does new-build work?
13:30:02 <pagnol> new-build says "Up to date"
13:30:20 <fen> but whats the point of this get like StateT transformer? it can act like the source of a stream of values withing a Monad? why not a sink version?
13:30:24 <JonReed> Does anybody know how to `runTeletypeIO` inside `IO ()` from the `fused-effects` example? Putting it in the main just doesn't work and I can't understand types enough to figure out what's wrong. https://github.com/robrix/fused-effects/blob/master/examples/Teletype.hs 
13:30:45 <shapr> pagnol: I think that means it built successfully?
13:31:09 <johnw> fen: huh?
13:31:13 <JonReed> Essentially, I'm trying `main = runTeletypeIO (write "test")` and it complains that `No Instance for (Carrier sig IO) arising from the use of 'write'`
13:31:31 <dyl> Question: why don't we use "applicative transformers" often?
13:31:46 <dyl> We have applicative composition in transformers.
13:31:50 <zachk> fen, how would you compose or glue together the State monad and the IO monad? 
13:32:01 <pagnol> shapr, I don't think so
13:32:07 <dyl> zachk with unsafeCoarce, duh
13:32:11 <dyl> ;) 
13:32:11 <shapr> pagnol: ok, tell me more?
13:32:39 <pagnol> cabal new-run doesn't actually run anything
13:32:44 <zachk> dyl, I am reading that as unsafeCoarse
13:32:46 <pagnol> just tells me it's "up to date"
13:32:54 <shapr> what are you trying to run?
13:33:01 <pagnol> my... program
13:33:08 <shapr> heh, good answer
13:33:20 <Solonarv> what does your cabal file look like?
13:33:21 <shapr> pagnol: does your cabal file have an executable stanza?
13:33:26 <pagnol> I just added postgresql-simple to the deps in my cabal file
13:33:37 <fen> not sure transformers are useful to this project
13:33:52 <pagnol> oh, it did compile and run just fine before I added postgresql-simple to the deps
13:34:08 <dyl> shapr tangentially, I think we should extend the use of punctuation in the Prolog lineage of languages to 'metered programming languages'.
13:34:58 <johnw> dyl: applicatives compose naturally, so there's no need for a transformer concept
13:34:58 <shapr> pagnol: that's unexpected
13:35:17 <johnw> monad transformers can be seen as "known working monad compositions"
13:35:21 <shapr> pagnol: could you pastebin your cabal file?
13:35:33 <dminuoso> johnw: they are not really monad compositions though.
13:35:35 <johnw> and so we know, for any m, that m (Maybe a) is also a monad
13:35:50 <johnw> they are compositions of monads that are known to be monads
13:35:57 <pagnol> when I remove postgresql-simple from the deps, then it compiles and runs
13:36:11 <JonReed> Nevermind, I found how to do it (`main = runM $ runTeletypeIO (write "test")`). Will still have nightmares about those types though
13:36:20 <johnw> though maybe there are some that don't fit that pattern
13:36:21 <pagnol> shapr, one second
13:36:33 <shapr> pagnol: I'm certainly surprised by that
13:36:44 <Solonarv> for example, when '(Monad m, Monad n, Traversable n)' then 'Compose m n' is also a monad
13:37:16 <pagnol> shapr, https://pastebin.com/y30W18hF
13:37:23 <dyl> Is there a word for something that is a Traversable Monad?
13:37:37 <Solonarv> "a Travesable Monad" seems short enough to me
13:37:39 <dyl> Or, is there at least any deeper intuition as to what that implies about the type?
13:37:44 <pagnol> shapr, err that's without postgresql-simple as you can see
13:37:46 <johnw> Travesable is even more than you need
13:37:56 <dyl> i.e. that it's a "concrete" or "data-ish monad in some sense.
13:37:56 <dyl> '
13:38:03 <shapr> pagnol: doesn't look suspicious at all
13:38:34 <pagnol> shapr, it's the one cabal init spat out plus some deps
13:38:51 <shapr> pagnol: after adding postgresql-simple again, does running cabal new-update before cabal new-build help any?
13:39:13 <shapr> pagnol: do you happen to know which version of GHC and cabal you're using?
13:39:34 <johnw> the minimum (that I know of) is: (Monad m, Applicative n, Distributes m n) given class Distributes m n where prod : n (m (n a)) -> m (n a), satisfying 4 laws for prod (which are listed in Jones and Duponcheel's paper on "Composing monads")
13:39:55 <pagnol> cabal 2.0.0.1 and ghc 8.0.2
13:40:16 <shapr> pagnol: do you have the option to install more recent versions?
13:40:19 <pie___> Solonarv, looks like the preprocessor messes up file names in error messages, but since module names are redundant its still handleable
13:40:40 <shapr> pagnol: if that's an option, I'd suggest https://github.com/haskell/ghcup
13:40:50 <koz_> johnw: Has someone implemented Distributes in a library somewhere?
13:40:56 <pie___> actually no nevermind, i misread, not sure about the source of the errors anymore.
13:40:57 <shapr> though I don't know if ghcup supports Windows
13:40:58 <pagnol> shapr, should've done that right away... going to do so now
13:41:02 <johnw> not any Haskell one that I know of; it's in coq-haskell
13:41:11 <Solonarv> shapr: it does not, sadly
13:41:13 <koz_> johnw: I ought to remedy that, lol. :P
13:41:26 <shapr> pagnol: I think it's likely that will fix the problems, if it doesn't feel free to ping me
13:41:30 <trcc> ah sucks that travis wants to read all
13:41:37 <johnw> koz_: https://github.com/jwiegley/coq-haskell/blob/poly-universes/src/Control/Monad.v#L192
13:41:39 <pagnol> shapr, thanks!
13:41:41 <johnw> just translate that to Haskell
13:41:49 * shapr hops cheerfully
13:45:51 <johnw> koz_: the actual proof that monads compose under those conditions is here: https://github.com/jwiegley/coq-haskell/blob/poly-universes/src/Control/Compose.v#L76
13:45:56 <wroathe> Omg, jle's suggestion to use `from` as infix...
13:46:04 <wroathe> (EnvReader Options ConfigNode a -> EnvReader Options ConfigNode b) -> EnvReader Options ConfigNode a -> EnvReader Options ConfigNode b
13:46:09 <wroathe> Is just fmap
13:54:04 <jackdk> I am trying to assist a student on OSX who has been bitten by the nondeterministic package-id bug. This has persisted after uninstalling platform (full) and installing platform (core). Are there dotfiles I should ask him to delete, to rebuild affected libs?
13:56:40 <Solonarv> jackdk: nuking ~/.ghc and ~/.cabal should do it, I think
13:58:14 <jackdk> thanks Solonarv
14:00:22 <wroathe> The principal folks behind functor, applicative, monad, etc. are geniuses
14:02:11 <zachk> some where mathematcians I believe
14:02:15 <zachk> were
14:04:31 <wroathe> I've gone through lots of iterations of the API for the thing I'm building in hopes of building a simple DSL that reads like an imperative program, and I ended up designing myself into this "from" operation just being an alias for ap
14:14:24 <javran> to me it's more like iterations of design reaching a fixpoint (up to iso), discovering them is just a matter of time xD
14:33:46 <pagnol> somehow I have ghc and cabal on my ubuntu box, but don't remember how I got them, definitely not through the distribution package manager and neither through ghcup
14:40:33 <dmwit> pagnol: Perhaps a benevolent hacker broke in and installed all the finest development tools for you.
14:41:08 <pagnol> looks like he gave me a broken version of cabal
14:41:28 <dmwit> Maybe she was in a rush! The FBI was breathing down her neck.
14:41:34 <pagnol> that kind of implies that there are working ones... let's see
14:44:38 <jadrian> regarding zippers, is there already any explanation as to why derivatives "work"?
14:45:20 <sclv> jadrian: yes, a number of explanations, depending on which branch of math you start with
14:45:31 <sclv> the deepest and most thorough is via the theory of combinatorial species
14:45:44 <sclv> but the "d for data" paper gives another account that doesn't go via that route
14:45:48 <jadrian> sclv: is there any page listing them? would love to check them out
14:46:07 <sclv> i mean... read "d for data" and its references
14:46:11 <sclv> its dense stuff
14:46:31 <jadrian> thank you, will get it"
14:48:12 <sclv> for species, see e.g. this textbook: http://bergeron.math.uqam.ca/wp-content/uploads/2013/11/book.pdf
14:48:36 <sclv> the notion of the derivative of a species of structures coincides with the zipper stuff
14:49:00 <sclv> even though it was of course developed not for that purpose at all, but rather in a categorical account of combinatorics
14:49:38 <sclv> as an intro textbook, i don't think it includes all the proofs
15:08:29 <jadrian> sclv: ah! great! thank you so much
15:08:57 <jadrian> sclv: I'd never heard of species to be honest
15:09:43 <jadrian> sclv: is there then work connecting both, type theory and species? or is it just obvious from the categorical structure?
15:10:59 <sclv> there’s a little work. Brent yorgey has a thesis and a paper
15:11:18 <sclv> And there’s complicated connections to linear types
15:12:04 <sclv> But really its just a counting argument you need to understand the connection with derivatives
15:12:38 <jadrian> sclv: I've worked with linear types before
15:13:25 <sclv> so there’s research on models on linear types in species but I don’t understand it at all
15:13:25 <jadrian> sclv: well... kind of, not linear types per se since the language didn't have it, but the model I was working with did allow for a linear decomposition of the exponent
15:13:40 <jadrian> in the form A => B  =  !A --o B
15:14:05 <sclv> The d for data paper has a simpler connection to linear types and the so called differential lambda calc
15:15:09 <jadrian> sclv: the basic idea of linearity is relatively simple, you can't "reuse" your arguments, and the decomposition in the form !A --o B, where ! is a comonad, is done by building a context in the domain that allows for repetition
15:15:30 <sclv> Right I understand linearity
15:15:51 <jadrian> I see so it's what they do with it that gets complicated
15:16:04 <sclv> The models in species are complicated yes
15:16:11 <jadrian> right
15:17:18 <jadrian> wait! this reminds me of something... I have somewhere in my notes something neat that I found out related with combinatorics
15:18:30 <jadrian> I built up a type that was "more complicated", in that it was not covariant
15:18:49 <jadrian> or maybe it was some other complication not sure
15:21:06 <jadrian> and when I decomposed it via some Taylor like formula, I realised the coefficients did represent a known combinatorial sequence
15:21:09 <mouse07410> Solonarv: jackdk: in addition to the two dot directories, check ~/Library/Haskell - something could end up there...
15:21:16 <jadrian> I don't remember the details, need to dig that up
15:21:26 <jadrian> I didn't know what to make of it at the time
15:21:32 <jadrian> this could be interesting
15:21:45 <zardozm> hi. I'm having trouble parsing domain out of URL. I know why this happens, but not sure how to fix it. (haskell code). https://bpaste.net/show/87c10b52fe34
15:24:07 * hackage asif 4.0.1 -   https://hackage.haskell.org/package/asif-4.0.1 (arbornetworks)
15:24:21 <Solonarv> zardozm: try (string "https")
15:24:33 <Solonarv> or switch to megaparsec, where (IIRC) this isn't an issue
15:25:18 <Solonarv> option 3: instead of rolling your own URL parser, use an existing one
15:25:31 <zardozm> megaparsec automatically backtracks on a failed parse?
15:25:50 <pie___> if i have something like this copy-pasted across several files, should i use template haskell to generate it? https://bpaste.net/show/f9961d2d784c
15:25:58 <Solonarv> megaparsec's version of 'string' automatically backtracks
15:26:00 <zardozm> I'd rather not have extra dependencies just to fetch a domain out of url
15:26:08 <pie___> the widget type is freshly defined in each of those files
15:26:22 <zardozm> Solonarv, only string?
15:26:37 <Solonarv> a few other primitives as well, I think
15:26:38 <zardozm> anyway, I won't switch just for this, but I was curious
15:26:43 <pie___> here's an example: https://bpaste.net/show/b39c7577196f
15:26:49 <zardozm> try made it work
15:27:25 <zardozm> I guess string "http"   optional (char 's') would work too
15:28:37 <Solonarv> pie___: I'd write some sort of 'HasCallbacks' type class instead
15:28:46 <pie___> Solonarv, i have that actually
15:29:21 <pie___> Solonarv, the problem i think is that i need to type-specialize these to each one because otherwise the multiparam type class complains about not being able to deduce something
15:29:37 <pie___> functional dependencies dont work because i need to map to multiple instances
15:29:42 <hpc> as a regex, "([a-z]+)://" perhaps
15:29:59 <Solonarv> what does your class look like?
15:30:28 <pie___> Solonarv, one sec, i was just about to paste it :)
15:30:44 <pie___> Solonarv, https://bpaste.net/show/d400420a0dee
15:31:22 <pie___> Solonarv, repasted with the right highlighter https://bpaste.net/show/94f7e6eb5a44
15:32:55 <pie___> Solonarv, a possibly pending large-ish refactor is that i may be able to consolidate the two ways i pass ...actually you may be right about moving hook and unhook in there
15:33:22 <pie___> i would have to rename them, and the naming is a bit inconsistent right now...bt maybe that will work
15:33:24 * pie___ looks
15:33:55 <pie___> i guess i dont want to differentiate on the user side about using a CBSRef or a CallbackStruct
15:34:03 <pie___> and that depends on how i wrote the code that uses them
15:34:12 <pie___> (and i might be able to refactor that later)
15:34:53 <pie___> one case is the entire record of various things, including the callbacks, is in an ioref, the other thing is the callbacks being in an IORef-ed field of a record
15:35:20 <pie___> and im not sure it makes sense for both of them to do the same thing
15:35:50 <Solonarv> zardozm: specifically, for parsing URIs I would tell you to use network-ur
15:35:55 <pie___> im also kind of tired now so i might not be making sense
15:35:56 <Solonarv> @hackage network-uri
15:35:56 <lambdabot> http://hackage.haskell.org/package/network-uri
15:36:09 <Solonarv> pie___: I'm also tired, and therefore having a hard time parsing your code
15:36:13 <Solonarv> ;)
15:36:23 <Phyx-> shapr: windows supports chocolatey which does the same
15:36:34 <pie___> Solonarv, it definitely needs more cleanup. thanks anyway. maybe i should get back to this tomorrow/weekend
15:37:24 <pie___> i actually havent *understood* a decent part of this (for a noob; medium sized) codebase in a while due to an intermission so... 
15:38:16 <Solonarv> yeah that happened to my codebase too (it wasn't working right in the first place)
15:38:37 <Solonarv> my solution was/is: scrap it all and rewrite it with 2+ languages working together
15:39:09 <pie___> for me, theres enough iterative ppossibilities that it might not be total garbage in the end, and i have plenty i can learn
15:39:22 <zardozm> Solonarv, I wonder if there's a situation where one would prefer non-backtracking string, and if so, what is megaparsec's solution? with parsec, it is easy to get backtracking with try
15:39:25 <pie___> though i do happen to be somewhat skeptical about the underlying architecture i did
15:39:55 <pie___> but it seems like it might be usable if i manage to clean out some cruft
15:40:06 <pie___> or a lot of cruft...
15:40:08 <Solonarv> I have no idea what sort of situation you'd want a non-backtracking string in
15:43:07 <sm> sometimes you want to report a parse error and stop backtracking
15:43:20 <sm> megaparsec indeed is missing this feature
15:43:30 <sm> we had to mix in ExceptT
16:13:07 * hackage arbor-monad-metric 1.2.0 - Core metric library for publishing metrics.  https://hackage.haskell.org/package/arbor-monad-metric-1.2.0 (arbornetworks)
16:16:49 <pagnol> cabal update is taking incredibly long and there is no progress indicator...
16:24:59 <glguy> pagnol: I think the initial download is about 74M
16:25:12 <jackdk> thanks mouse07410
16:25:14 <magnetik[m]> it's like using dep ensure in a golang project that imports kubernetes
16:25:43 <magnetik[m]> does a tree search to resolve deps that would literally take longer than the lifetime of the universe
16:26:13 <pagnol> great, I'm on a slow connection tonight
16:26:22 <pagnol> I can just scrap it
16:26:44 <glguy> pagnol: and having a progress bar sounds pretty great to me, but I'm pretty sure that's not implemented
16:32:15 <Solonarv> pagnol: you can run 'cabal update -v' to see what cabal wants to download (by looking at the commands it's executing), then download those files manually however you want and plonk them in ~/.cabal/packages/hackage.haskell.org
16:32:26 <Solonarv> at least I think that should work.
16:33:45 <pagnol> Solonarv, I'll give that a try, thanks
16:43:45 <ril> hey~
16:45:18 <ril> I have a question from typescript that I'm not able to articulate in TS's type syntax, and I'm looking for help clarifying my thoughts
16:45:37 <ril> I have a function from (...args) => someMonad<T>
16:46:01 <ril> and I want a function to transform that to the corresponding function (...args) => someMonad<T> | otherMonad<T>
16:46:21 <ril> what is the language I use to describe this operation, and the type of the function that performs it?
16:47:20 <ril> (in this particular case, someMonad and otherMonad are promise types from two different libraries)
16:48:38 <suzu> lifting?
16:48:57 <ril> that sounds right, but I'm struggling to use that language precisely
16:49:19 <ril> I feel like lifting would be going from (...args) => T to (...args) => Monad<T>
16:49:41 <ril> but going from (...args) => Monad<T> to (...args) => differentMonad<T> is something else?
16:49:59 <suzu> well, you can define a third type "SomeOrOther<T> = (...args) => someMonad<T> | otherMonad<T>"
16:50:32 <suzu> and now given a (...args) => someMonad<T>, you extract the T and lift it into SomeOrOther<T>
16:50:47 <ril> so the operation is like, extract-then-lift
16:50:58 <suzu> yeah
16:51:45 <ril> and the type of the function that does that then is
16:52:44 <ril> extractAndLift :: (\args -> someMonad<T>) -> (\args -> someOrOther<T>) ?
16:53:03 <ril> I think I'm hung up on preserving the type of the arguments
16:53:28 <ril> and that this is like, not a thing that would even be a problem in a language where everything is curried and monads can be genericized
16:53:59 <Solonarv> actually this is a situation where currying is a bit inconvenient
16:54:17 <Solonarv> (really, any time you want to mess with a function's "final" return type)
16:54:22 <ril> can you say more?
16:54:35 <ril> we could pretend that it takes an args tuple of known type
16:54:51 <ril> that's essentially how typescript handles argument types
16:55:09 <Solonarv> in a non-curried language you a function type like '(foo, bar) -> result'; here the return type is clearly 'result'
16:55:53 <Solonarv> but if you curry that it looks like 'foo -> bar -> result'; now the return type is 'bar -> result', but you probably wanted 'result'
16:59:36 <ril> right
17:01:44 <noob101> Hi! I'm new to Haskell and I wanted to try out some programming challenges. However, I came up against something. In the following example, I'd expect 'makeTribonacci' to create a list lazily, so that when I call 'take n' on it, it only creates the list for the first n elements. However, it does not. Can someone explain me, why, please?
17:01:56 <noob101> makeTribonacci :: Num a => [a] -> [a] makeTribonacci xs = makeTribonacci $ xs ++ [sum $ take 3 $ reverse xs]  tribonacci :: Num a => (a, a, a) -> Int -> [a] tribonacci (a, b, c) n = take n $ makeTribonacci [a, b, c]
17:02:18 <noob101> Sorry for the formatting, I don't usually use IRC and this is a web client.
17:02:35 <kadoban> noob101: gist.github.com (or similar sites) are better ways to share code usually
17:02:48 <kadoban> You paste it there, press the button and it gives you a link you can share
17:02:49 <noob101> Thanks, I'll do that!
17:03:50 <noob101> https://pastebin.com/F2myHLiH  -- should have done this in the first place
17:04:16 <ril> so what does the implementation of my function look like?
17:04:59 <Solonarv> noob101: try working out (with pen&paper, if you want) how 'makeTribonacci [a,b,c]' is evaluated
17:06:00 <kadoban> noob101: Hm. So yeah, try that ^ try to figure out what the first value should be, what "take 1" would give you just by doing the procedure you're telling it to do
17:06:26 <noob101> Ok, I'll do that, brb!
17:09:52 <noob101> Ok, I get it why now! I wonder if I can somehow still use recursion but keep the laziness
17:10:35 <kadoban> noob101: Would you be interested in a spoiler, or would that ruin it for you?
17:10:57 <Solonarv> yes, you can still use recursion - you just need to not have makeTribonacci immediately call itself without ever stopping ;)
17:12:04 <kadoban> The hint version, mostly non-spoiler would be: Can you produce *one* element of the sequence (the first one), knowing a b and c, and then find a way to recurse?
17:14:44 <noob101> Thanks guys, I realized something like that would be the solution! Will report back!
17:14:55 <NemesisD> has anyone else experienced nix eating your haskell package's data files? it seems to create a space in the store like /nix/store/xxxx-my-package-0.0.0.1-data/, but its empty, and the data files are meant to be in /nix/store/xxxx-my-package-0.0.0.1-data/share/ghc-8.6.3/x86_64-linux-ghc-8.6.3/my-package-0.0.0.1/somefile
17:15:14 <kadoban> noob101: Cool, good luck
17:15:55 <NemesisD> i though reading through the haskell builder experessions that adding this function and applying it to my package would work but it doesn't seem to retain the data files: enableSeparateDataOutput = drv: hlib.overrideCabal drv ({ enableSeparateDataOutput = true; });
17:16:56 <NemesisD> i've verified that cabal new-sdist does include the data files, they just don't make it into the nix store
17:57:39 <noob101> @kadoban @Solonarv This is what I came up with: https://pastebin.com/wYvffajk Doesn't seem very 'haskelly'. Would it be possible to do this same thing with a lambda or a fold instead, do you think?
17:57:39 <lambdabot> Unknown command, try @list
17:59:08 <Solonarv> actually, that looks pretty idiomatic
18:02:21 <Solonarv> I'd write it roughly like this: https://pastebin.com/zgVBzzn8
18:02:53 <noob101> Solonarv: Thanks! In that case, I'll submit it. I have had enough Haskell for one day, I think! It's hard for my imperative brain *_* Thank you for your help, good night/day! 
18:05:25 <Eromenos> Hi all. I'm struggling a little with some very simple type mismatches to due with everything under Num. I've spent some time trying to figure this out and I'm really getting nowhere. My current iteration of this very simple function follows. I'm almost convinced a type annotation somewhere should clear this up but I fail to understand why inferring it isn't possible : https://pastebin.com/NtVy3Hnh
18:05:41 <noob101> Solonarv: This is better, thanks, it'll take me some time to come up with this on my own!
18:06:52 <Solonarv> Eromenos: the problem is simply that 'Num' only provides operations that work on integer-ish types
18:07:00 <Solonarv> :t sqrt
18:07:01 <lambdabot> Floating a => a -> a
18:07:18 <Solonarv> ^ see? sqrt needs Floating, Num isn't enough
18:08:22 <Eromenos> but isnt Num the super typeclass of Floating?
18:08:56 <Solonarv> yes, which means: "everything that is Floating must also be Num"
18:09:32 <Solonarv> an analogy: Num is "rectangle", Floating is "square"
18:10:30 <dmwit> If you need to check whether an integer is a square, check out http://hackage.haskell.org/package/arithmoi-0.8.0.0/docs/Math-NumberTheory-Powers-Squares.html
18:12:09 <Eromenos> I appreciate that dmwit thank you, but I want to understand why I havn't  grokked this yet. Its pretty embarressing since I thought I understood haskell type inference pretty well
18:12:37 <Solonarv> @let isSqrt x = sqrt x == (fromIntegral . truncate . sqrt) x
18:12:38 <lambdabot>  Defined.
18:12:42 <Solonarv> :t isSqrt
18:12:43 <lambdabot> (Floating a, RealFrac a) => a -> Bool
18:12:50 <dmwit> Okay, well, if you can pinpoint which bit of Solonarv's explanation is the first bit you don't understand, say so and we can expand further.
18:12:55 <javran> :t truncate
18:12:56 <lambdabot> (Integral b, RealFrac a) => a -> b
18:13:13 <Solonarv> as you can see, haskell is perfectly capable of inferring a type for your function - but you gave a different type!
18:15:15 <javran> :info RealFrac
18:15:26 <benzrf> > :i RealFrac
18:15:29 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
18:15:33 <benzrf> hm
18:15:37 <benzrf> % :i RealFrac
18:15:37 <yahb> benzrf: class (Real a, Fractional a) => RealFrac a where; properFraction :: Integral b => a -> (b, a); truncate :: Integral b => a -> b; round :: Integral b => a -> b; ceiling :: Integral b => a -> b; floor :: Integral b => a -> b; {-# MINIMAL properFraction #-}; -- Defined in `GHC.Real'; instance RealFrac a => RealFrac (Identity a) -- Defined in `Data.Functor.Identity'; instance forall a k (b :: k)
18:15:39 <javran> hm, haven't been using irc for a while
18:15:57 <fen> :t RealFrac
18:15:58 <lambdabot> error: Data constructor not in scope: RealFrac
18:16:20 <Eromenos> Solonarv, I don't understand? Which type have I incorrectly given?
18:16:28 <javran> :k RealFrac
18:16:29 <lambdabot> * -> Constraint
18:16:39 <fen> :t realToFrac
18:16:40 <lambdabot> (Fractional b, Real a) => a -> b
18:16:53 <Solonarv> fen, javran, benzrf: rule of thumb: if you think lambdabot is ghci, use yahb instead - that's actually a ghci ;)
18:17:12 <Eromenos> specifically, my error in ghci is " Could not deduce (RealFrac a) arising from a use of ‘truncate’      from the context: Num a
18:17:46 <fen> which Num is it?
18:17:58 <fen> which Num is it?
18:18:03 <Solonarv> Eromenos: you gave the type 'isSqrt :: Num a => a -> Bool'; this type says "'isSqrt' works for any type 'a', as long as this 'a' has a Num instance"
18:18:10 <javran> last time i was using irc, there was just lambdabot, not knowing yahb yet
18:18:12 <Solonarv> but a Num instance is not enough!
18:18:35 <fen> ah
18:18:47 <Eromenos> so I'll change the type to ' isSqrt :: Fractional a => a -> Bool' and go from there?
18:19:02 <javran> unless you can provide an instance to persuade ghc that Num a => RealFrac a
18:19:02 <Solonarv> to continue the earlier analogy: your type signature says "this function can accept any rectangle", but really the input needs to be a square!
18:19:44 <Solonarv> no: change the type to 'isSqrt :: (Floating a, RealFrac a) => a -> Bool'
18:20:31 <Eromenos> Yea, that makes sense
18:20:38 <Eromenos> I feel pretty inept now lol
18:20:58 <Eromenos> I think the error message was throwing me off, but what you said makes perfect sense
18:21:41 <Eromenos> Thank you, Solonarv 
18:22:44 <fen> x -> (x -> x) isnt Monoid is it?
18:22:52 <fen> x -> (x -> x) isnt Monoid is it?
18:23:06 <fen> Semigroup*
18:23:29 <Solonarv> I don't see an obvious and nice way in which it is
18:23:32 <javran> how would you define (<>) for it?
18:23:46 <fen> what is it?
18:23:56 <fen> what is it?
18:24:00 <Solonarv> f <> g = \a b -> f a b <> g a b
18:24:11 <Solonarv> (the semigroup instance for functions)
18:24:38 <Solonarv> (this needs 'x' to have a semigroup instance)
18:25:39 <fen> isnt that (x -> x) -> x ?
18:26:08 <Solonarv> no
18:26:09 <javran> x -> (x -> x) is the same as x -> x -> x as (->) associated to right
18:26:18 <Solonarv> ^ beat me to it
18:30:38 <javran> well
18:30:45 <javran> :t (<>) <> (<>)
18:30:46 <lambdabot> Monoid m => m -> m -> m
18:31:09 <fen> > (<>) <> (<>) 1 2
18:31:11 <lambdabot>  error:
18:31:11 <lambdabot>      • No instance for (Typeable m0)
18:31:11 <lambdabot>          arising from a use of ‘show_M52197001745300499631129’
18:31:22 <javran> I'm not sure how would this be useful though
18:31:36 <fen> % (<>) <> (<>) [1] [2]
18:31:37 <yahb> fen: ; <interactive>:57:9: error:; * Couldn't match expected type `a -> a -> a' with actual type `[Integer]'; * Possible cause: `(<>)' is applied to too many arguments; In the second argument of `(<>)', namely `(<>) [1] [2]'; In the expression: (<>) <> (<>) [1] [2]; In an equation for `it': it = (<>) <> (<>) [1] [2]; * Relevant bindings include it :: a -> a -> a (bound at <intera
18:31:42 <fen> !?
18:31:48 <javran> > ((<>) <> (<>)) (Sum 1) (Sum 2)
18:31:50 <lambdabot>  Sum {getSum = 6}
18:32:22 <javran> u need to specify which semigroup u are refering to, Sum or Product
18:33:01 <fen> > ((<>) <> (<>)) [1,2,3] [4,5,6]
18:33:02 <lambdabot>  [1,2,3,4,5,6,1,2,3,4,5,6]
18:34:18 <fen> its doing something like *2 ?
18:34:29 <fen> its doing something like *2 ?
18:34:33 <Solonarv> yes
18:34:51 <Solonarv> > ((<>) <> (<>) <> (<>)) "ab" "xy"
18:34:53 <lambdabot>  "abxyabxyabxy"
18:35:17 <javran> we are using instance Monoid b => Monoid (a -> b) here
18:36:03 <javran> :t stimes
18:36:04 <lambdabot> error:
18:36:04 <lambdabot>     • Variable not in scope: stimes
18:36:04 <lambdabot>     • Perhaps you meant ‘Semi.stimes’ (imported from Data.Semigroup)
18:36:44 <javran> > stimes 10 (<>) "a" "b"
18:36:46 <lambdabot>  error:
18:36:46 <lambdabot>      • Variable not in scope:
18:36:46 <lambdabot>          stimes :: Integer -> (m0 -> m0 -> m0) -> [Char] -> [Char] -> t
18:36:56 <javran> > Semi.stimes 10 (<>) "a" "b"
18:36:58 <lambdabot>  "abababababababababab"
18:37:03 * Solonarv shakes a fist at lambdabot: get with the times, old 'bot!
18:37:16 <benzrf> :t Semi.stimes
18:37:17 <lambdabot> (Integral b, Semi.Semigroup a) => b -> a -> a
18:37:34 <fen> > map (\(a,f) -> f a . fst) [(1,(+)),(2,(-))] <*> [(1,(+)),(2,(-))]
18:37:36 <lambdabot>  [2,3,1,0]
18:37:42 <benzrf> > Semi.stimes 0 "hi:
18:37:43 <benzrf> > Semi.stimes 0 "hi"
18:37:44 <lambdabot>  <hint>:1:19: error:
18:37:44 <lambdabot>      lexical error in string/character literal at end of input
18:37:45 <lambdabot>  ""
18:37:52 * benzrf is suspicious
18:38:07 <Solonarv> no, this is right
18:38:12 <benzrf> how did that happen??
18:38:22 <Solonarv> stimes 0 x = mempty
18:38:34 <Solonarv> (when there is a monoid instance, otherwise it's an error)
18:40:23 <benzrf> h
18:40:24 <benzrf> how can it tell
18:40:56 <benzrf> > Semi.stimes 0 ('a' :| [])
18:40:58 <lambdabot>  error:
18:40:58 <lambdabot>      • Data constructor not in scope: (:|) :: Char -> [a0] -> a
18:40:58 <lambdabot>      • Perhaps you meant one of these:
18:41:06 <benzrf> weak
18:41:38 <Solonarv> it's a class method
18:41:55 <Solonarv> (specifically, it belongs to Semigroup)
18:42:34 <benzrf> i mean how can it tell if it's a monoid
18:42:39 <benzrf> that hsouldn't be possible
18:42:53 <Solonarv> I misspoke a bit
18:43:05 <benzrf> ooh wait is it a class method
18:43:11 <Solonarv> yes
18:43:16 <benzrf> i see
18:43:25 <fen> how to get that^ to apply all the functions in the first list on the values in the "first" position of the second list? 
18:43:30 <fen> % :t first
18:43:30 <yahb> fen: Arrow a => a b c -> a (b, d) (c, d)
18:43:46 <fen> oh, meant bifunctor
18:44:40 <fen> to get [(1+2+1,(+)),(1+2+2,(-))]
18:45:49 <fen> um, (-) for the second
18:46:26 <fen> want :: [(a,a -> a -> a)] -> [(a,a -> a -> a)]
18:47:18 <fen> which is as close to [(a->a)] -> [(a->a)] as it should be reasonable to want...
18:48:16 <fen> sorry, L = L -> L, [L] -> [L]
18:48:25 <javran> sry but coud u elaborate what u want to do
18:49:26 <fen> apply all the functions 'created by partially applying each function in the pair to the value' to the values
18:49:52 <fen> all the functions to each value
18:50:05 <javran> perhaps step by step
18:50:20 <javran> > let xs = [(1,(+)),(2,(-))]
18:50:22 <lambdabot>  <no location info>: error:
18:50:22 <lambdabot>      not an expression: ‘let xs = [(1,(+)),(2,(-))]’
18:50:31 <javran> % > let xs = [(1,(+)),(2,(-))]
18:50:31 <yahb> javran: ; <interactive>:59:1: error: parse error on input `>'
18:50:44 <javran> % let xs = [(1,(+)),(2,(-))]
18:50:45 <yahb> javran: 
18:51:16 <javran> % :t fmap (uncurry id) xs
18:51:17 <yahb> javran: (Num a2, Num ((a2 -> a2 -> a2) -> b)) => [b]
18:52:38 <javran> % :t fmap (uncurry (flip id)) xs
18:52:38 <yahb> javran: Num b => [b -> b]
18:53:01 <javran> now that's first list partially applied
18:53:11 <fen> fold . map End
18:53:14 <fen> fold . map Endo
18:53:27 <javran> could use foldMap
18:53:30 <javran> :t foldMap
18:53:31 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
18:54:08 <fen> :t fmap (runEndo . foldMap Endo)
18:54:09 <lambdabot> error:
18:54:09 <lambdabot>     Variable not in scope: runEndo :: Endo a -> b
18:54:20 <fen> :t fmap (appEndo . foldMap Endo)
18:54:21 <lambdabot> (Foldable t, Functor f) => f (t (a -> a)) -> f (a -> a)
18:54:48 <fen> :t fmap . appEndo . foldMap Endo
18:54:50 <lambdabot> (Foldable t, Functor f) => t (b -> b) -> f b -> f b
18:55:46 <slack1256> :t fmap . coerce . foldMap Endo
18:55:48 <lambdabot> error:
18:55:48 <lambdabot>     • Variable not in scope: coerce :: Endo a -> a1 -> b
18:55:48 <lambdabot>     • Perhaps you meant ‘coerced’ (imported from Control.Lens)
18:55:49 <fen> thought there  might be some comonad or monad helper..
18:56:00 <fen> thought there  might be some comonad or monad helper..
18:57:49 <javran> what is the input and expected output?
18:58:10 <javran> some concrete example might help
18:58:57 <javran> > :t appEndo . foldMap Endo
18:58:59 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
18:59:08 <javran> :t appEndo . foldMap Endo
18:59:09 <lambdabot> Foldable t => t (a -> a) -> a -> a
19:00:25 <javran> > appEndo (foldMap Endo [(+ 10), (subtract 20), (* 30)]) 4
19:00:28 <lambdabot>  110
19:02:54 <fen> :t (\y -> fmap ((\f (a,b) -> (f a,b)) ((appEndo . foldMap (\(a,f) -> Endo (f a))) y)))
19:02:55 <lambdabot> (Foldable t1, Functor f) => t1 (t2, t2 -> a -> a) -> f (a, b) -> f (a, b)
19:03:05 <fen> :t (\y -> fmap ((\f (a,b) -> (f a,b)) ((appEndo . foldMap (\(a,f) -> Endo (f a))) y)))
19:03:06 <lambdabot> (Foldable t1, Functor f) => t1 (t2, t2 -> a -> a) -> f (a, b) -> f (a, b)
19:04:00 <javran> > (appEndo . getDual) (foldMap (Dual . Endo) [(+ 10), (subtract 20), (* 30)]) 4
19:04:02 <lambdabot>  -180
19:04:10 <javran> or do it left to right
19:04:24 <fen> @let f = (\y -> fmap ((\f (a,b) -> (f a,b)) ((appEndo . foldMap (\(a,f) -> Endo (f a))) y))y)
19:04:26 <lambdabot>  Defined.
19:04:45 <fen> > map fst (f xs)
19:04:47 <lambdabot>  error:
19:04:47 <lambdabot>      Ambiguous occurrence ‘f’
19:04:47 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f’,
19:05:22 <fen> there has got to be a better way!
19:06:02 <fen> :t (<*>)
19:06:03 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:08:32 <fen> % let selfMod = (\y -> fmap ((\f (a,b) -> (f a,b)) ((appEndo . foldMap (\(a,f) -> Endo (f a))) y))y)
19:08:33 <yahb> fen: 
19:08:50 <fen> % map fst (selfMod xs)
19:08:51 <yahb> fen: [2,1]
19:09:29 <fen> % :t selfMod
19:09:29 <yahb> fen: (Functor f, Foldable f) => f (a, a -> a -> a) -> f (a, a -> a -> a)
19:13:25 <fen> % let ys = [(7,(+)),(3,(-)),(5,(*))]
19:13:25 <yahb> fen: 
19:13:37 <fen> % let ys = [(7,(+)),(3,(-)),(5,(*))]
19:13:38 <yahb> fen: 
19:13:43 <fen> % map (map fst) $ take 5 $ iterate selfMod ys
19:13:43 <yahb> fen: [[7,3,5],[-25,-5,-15],[-405,-105,-255],[-103785,-27285,-65535],[-6801681045,-1788253545,-4294967295]]
19:16:46 <fen> trying to work with algebras with compose as a product...
19:17:27 <fen> trying to work with algebras with compose as a product...
19:17:44 <fen> makes a very nonlinear version of a basis. difficult to invert - no orthogonality
19:20:08 <fen> it unfolds an interacting sytem
19:20:21 <fen> it unfolds an interacting sytem
19:25:12 <fen> % let z = [(sin,(.)),(cos,(.)),(tan,(.))]
19:25:12 <yahb> fen: 
19:25:24 <fen> %  map fst (last (take 3 (iterate selfMod z))) <*> [1,2,3]
19:25:24 <yahb> fen: [0.7204812409463576,0.7051206990661302,0.8236955140616883,0.835420668289473,0.8414210648981868,0.6969000465585029,0.8136742368975379,0.6989504561665002,0.8238494788148149]
20:34:46 <ibloom> Anyone got an idea what this error means: module ‘x’ cannot be found locally
20:34:48 <ibloom> https://pastebin.com/GTveL9kZ
20:35:25 <ibloom> This is in local copy of a library that I’m trying to compile
20:36:07 <ibloom> Also what is the ‘cabal new-build’ version of `clean`
20:36:26 <slack1256> cabal new-clean
20:36:37 * hackage rattletrap 6.2.3 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-6.2.3 (fozworth)
20:36:55 <ibloom> @slack1256 that
20:36:55 <lambdabot> Unknown command, try @list
20:37:03 <slack1256> for a super deep clean, it is $ cabal new-new-clean
20:37:11 <ibloom> thats an unrecognized command
20:37:28 <slack1256> yeah, the last one was a bad joke
20:37:54 <ibloom> there should be a new-clean
20:38:00 <ibloom> that’d be great
20:38:33 <cocreature> ibloom: the new-build version of clean is rm -r dist-newstyle
20:38:38 <slack1256> there is a cabal new-clean
20:38:42 <slack1256> it actually exists
20:38:53 <slack1256> what doesn't exists is a cabal new-new-clean
20:39:44 <ibloom> @cocreature, thanks it looks like that solved my other problem :)
20:39:44 <lambdabot> Unknown command, try @list
20:40:00 <glguy> If you don't have 'cabal new-clean', your cabal-install might be out of date
20:40:12 <ibloom> I see.
20:40:17 <ibloom> Need to upgrade that.
20:40:20 <glguy> We're now on "cabal-install version 2.4.1.0
20:40:24 <cocreature> you might also want to upgrade your GHC
20:40:30 <slack1256> Also ibloom, lambdabot has all these commands prepended by @
20:40:30 <cocreature> at least to the latest 8.4 minor release
20:40:35 <slack1256> @let x = 5
20:40:37 <lambdabot>  Defined.
20:40:38 <cocreature> there is very little reason to use 8.4.2 instead of 8.4.4
20:40:41 <slack1256> > x + x
20:40:43 <lambdabot>  error:
20:40:43 <lambdabot>      Ambiguous occurrence ‘x’
20:40:43 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.x’,
20:40:56 <glguy> ibloom, you don't address people with @ on IRC.
20:41:23 <cocreature> ibloom: is OpenCL a dependency of your project or are you trying to build a local clone
20:41:37 <ibloom> glguy ah, good to know
20:42:11 <ibloom> cocreature: OpenCL is a dependency but I have a local clone because I’m on a mac and some special stuff is needed to get it to build
20:42:36 <cocreature> ibloom: which version have you cloned and what changes did you make?
20:43:01 <ibloom> let me see.
20:43:36 <cocreature> Those modules should be produced by c2hs
20:43:55 <ibloom> 1.0.3.4
20:44:41 <cocreature> did you download that exact version or did you just clone the git repo and nobody has bumped the version number since the last release?
20:44:43 <ibloom> The changes I made are this paragraph of the .cabal: https://pastebin.com/P9FpvMC0
20:45:19 <ibloom> It’s actually a clone I made a while back. It’s upgrading macOSX that broke stuff.
20:46:33 <ibloom> So I’d have to look closely. I don’t like to change stuff when it’s working for me. I just spend 3 hours in cabal error hell….
20:48:09 <ibloom> c2hs was breaking on some of the macros. But adding that -DGL_SILENCE_DEPRECATION macro fixed it.
20:50:37 * hackage waargonaut 0.6.0.0 - JSON wrangling  https://hackage.haskell.org/package/waargonaut-0.6.0.0 (schalmers)
23:28:36 <trcc> So I was looking up travis in order to use it for my open source haskell project on github. But seems like it requires access to all repos, also private. Am I missing something?
23:30:01 <c_wraith> as a potentially-unwelcome editorial - I'd consider not using travis anyway.  They were just acquired by a company with a reputation for buying businesses then never maintaining them - who laid off almost their entire staff today.
23:30:40 <glguy> Laid off the Travisci staff?
23:30:47 <c_wraith> yeah
23:31:02 <glguy> Ok. What are we switching to?
23:32:16 <c_wraith> No idea.  It's not an infrastructure piece I've ever dealt with.  https://www.reddit.com/r/devops/comments/at3oyq/it_looks_like_ibera_is_gutting_travis_ci_just_a/  as my source, btw
23:33:22 <dminuoso> CircleCI is going to be happy.
23:50:51 <trcc> c_wraith: thank you
23:51:07 <trcc> dminuoso: circleci instead of travis?
23:57:15 <trcc> think i'll try circleci
23:59:16 <trcc> seems like it is all the same. They require access to all repos. Also private... 
23:59:29 <trcc> Multiple github accounts then I guess
