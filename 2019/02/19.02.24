00:25:37 * hackage line-bot-sdk 0.2.0.0 - Haskell SDK for LINE Messaging API  https://hackage.haskell.org/package/line-bot-sdk-0.2.0.0 (moleike)
03:01:05 <akersof> hi all, 2 days of haskell and really enjoying the language. I have a question. i discovered the simplification of expression with partially applied functions. There is a statement or a rule, or a kind of theorem, that's explain how simplification can be applied?
03:01:37 <akersof> for example add a b = (+) a b can be simplified to add = (+)
03:02:25 <akersof> or increment a = add 1 a can be simplified to increment = add 1
03:03:53 <akersof> i partially understand it, but does a rule ( a grammatical rule) exist for explaining the simplification process?
03:04:21 <[Leary]> That's eta conversion.
03:05:54 <akersof> [Leary]: thx for the naming it i can search it on google now
03:06:25 <[Leary]> If you study the lambda calculus (from which functional languages like Haskell derive), then eta, alongside the alpha and beta rules determine when two expressions are equivalent.
03:07:05 <akersof> [Leary]: well i did lisp only, and only pratical lisp, so no i didn't study lambda calculus yet. 
03:11:37 * hackage yampa-gloss 0.2 - A GLOSS backend for Yampa  https://hackage.haskell.org/package/yampa-gloss-0.2 (IvanPerez)
03:34:37 * hackage http-types 0.12.3 - Generic HTTP types for Haskell (for both client and server code).  https://hackage.haskell.org/package/http-types-0.12.3 (AristidBreitkreuz)
04:20:14 <adius> Hi, I remember there was a website where you can search for Haskell documentation. But I don't remember the URL and can't find it on Google. Can someone point me to it? üòÖ
04:23:02 <ziman> hoogle, hayoo :)
04:24:37 <implementation_> in case you want to search for documentation on non-included packages, hackage.haskell.org is also useful
04:25:25 <haskyll> Hey I'm trying to do something using list comprehensions. Let's say I got the input [A,B,C] and I want the output [(A,A),(A,B),(A,C),(B,B),(B,C),(C,C)]. My attempt is: [(x,y) | head [x] <- ['A','B','C'], y <- ['A','B','C']] but it doesn't seem to work. Any ideas?
04:26:30 <dminuoso> let list = [liftA2 (,) 
04:26:47 <dminuoso> % let list = "abc" in liftA2 (,) list list
04:26:47 <yahb> dminuoso: [('a','a'),('a','b'),('a','c'),('b','a'),('b','b'),('b','c'),('c','a'),('c','b'),('c','c')]
04:27:12 <dminuoso> % let list = "abc" in [(x,y) | x <- list, y <- list ]
04:27:13 <yahb> dminuoso: [('a','a'),('a','b'),('a','c'),('b','a'),('b','b'),('b','c'),('c','a'),('c','b'),('c','c')]
04:28:00 <dminuoso> haskyll: what exactly should the behavior be?
04:29:30 <haskyll> Basically the list comprehension you did but without the elements reversed duplicate
04:29:43 <dminuoso> "reversed duplicate"?
04:30:04 <haskyll> IF the list has ('a','b') it shouldn't produce ('b','a')
04:30:41 <dminuoso> haskyll: what is the string had multiple occurences of the same element?
04:31:17 <haskyll> It doesn't
04:39:44 <dminuoso> haskyll: it seems like this is going to be some combination of inits/tails
04:44:20 <dminuoso> % let l = [1,2,3]; ts = init (tails l) in zipWith (,) l ts
04:44:20 <yahb> dminuoso: [(1,[1,2,3]),(2,[2,3]),(3,[3])]
04:44:42 <akersof> in https://en.wikibooks.org/wiki/Haskell/Lists_and_tuples we can read: "Unfortunately, we have a serious problem with head and tail. If we apply either of them to an empty list..."
04:45:02 <akersof> what would be the good alternative to head and tail ?
04:45:12 <dminuoso> akersof: pattern matching
04:45:32 <dminuoso> akersof: Or using NonEmpty if you know the list to be never empty.
04:45:57 <akersof> dminuoso: ok.. do you have some example? something i newbee can understard? 
04:46:04 <akersof> i mean for pattern matching
04:46:29 <dminuoso> akersof: Do you have a problem right now you would solve or have solved already with head/tail?
04:46:36 <kenshinCH> I'm lost in the regex libraries jungle. Can you recommend a good library that allows named capture groups?
04:47:10 <mouse07410> dminuoso: you mean - using "cons" in pattern matching?
04:47:31 <dminuoso> mouse07410: Yes. For example: f (x:xs) = ...; f [] = ...;
04:47:33 <akersof> dminuoso: no just following the tutorial.. just curious to know what is the alternative as it is written that head and tail can cause serious problem with head and tail
04:48:00 <dminuoso> akersof: So lets say inside a function you want to obtain the head and tail for some reason. Its better to just pattern match on the argument like this:
04:48:05 <mouse07410> dminuoso: yep, got it. Thanks!
04:48:18 <dminuoso> % f (x:xs) = undefined; f [] = undefined -- where undefined is some suitable implementation of the function
04:48:19 <yahb> dminuoso: 
04:52:07 <akersof> dminuoso: ok thx!!
04:54:29 <dminuoso> % let l = [1,2,3]; ts = init (tails l) in [ (\x -> (a, x)) <$> rs | (a, rs) <- zip l ts] -- haskyll 
04:54:29 <yahb> dminuoso: [[(1,1),(1,2),(1,3)],[(2,2),(2,3)],[(3,3)]]
04:54:58 <dminuoso> There's probably a simpler solution Im not seeing.
04:57:12 <dminuoso> % let l = [1,2,3]; ts = init (tails l) in do (a, rs) <- zip l ts; (\x -> (a, x)) <$> rs
04:57:12 <yahb> dminuoso: [(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
04:59:17 <dminuoso> % let l = [1,2,3]; ts = init (tails l) in zip l ts >>= uncurry ((<$>) . (,))
04:59:18 <yahb> dminuoso: [(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
05:01:54 <dminuoso> % let l = [1,2,3]; ts = init (tails l) in join (zipWith ((<$>) . (,)) l ts)
05:01:54 <yahb> dminuoso: [(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
05:04:03 <Gurkenglas> % [(a,x) | xs@(a:_) <- tails [1,2,3], x <- xs]
05:04:03 <yahb> Gurkenglas: [(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
05:06:02 <dminuoso> Gurkenglas: Oh yeah, thats a more elegant version of the same code. :)
05:06:57 <dminuoso> Nice trick pattern matching like that on tails
05:07:20 <Minijinski> Hello, I'm trying to learn haskell and I want to iterate through a list of string and then print each string but I have some hard time doing it
05:08:19 <Minijinski> I'm trying to do that on my main with getArgs and print each args, can you help me doing it ?
05:08:38 <dminuoso> Minijinski: forM/forM_/traverse/traverse_ might be of interest to you. :)
05:09:16 <dminuoso> Minijinski: https://www.postgresql.org/docs/11/auth-pg-hba-conf.html
05:09:32 <Minijinski> well, thank you I'll check that 
05:09:39 <dminuoso> Wow ops ignore that link.
05:10:20 <Lycurgus> did you mean "oops"?
05:10:59 <Gurkenglas> did you tell your client to alert you to any mention of ops for popcorn potential? :D
05:13:28 <DigitalKiwi> did someone say glguy?
05:13:58 <dminuoso> Lycurgus: What can I say. ThinkPad keyboards are wildly different from Macbook keyboards, this will take a bit getting used to.
05:14:04 <Lycurgus> no I wondered if he was addressing someone rather than making an interjection
05:14:25 <Lycurgus> dminuoso, ah
05:15:39 <Minijinski> Well, I've tried with forM_ and it's working now, thank you !
05:15:46 <haskyll> Thanks a lot dminuoso and gurkenglas. :)
05:17:54 <dminuoso> Minijinski: In fact forM_ is a bit overly restrictive, a plain for_ would have sufficed. :)
05:19:34 <Minijinski> I'll swap then :p 
05:32:30 <kenshinCH> Is there a regex library for haskell that supports *named* capture groups?
06:53:43 <higherorder> Hi! Is there a way to generically fold a tree (or any data-structure) while having access to some "context" on each node that depends on the "parents" of that node? e.g. for a tree, I would like to have access to the node's position (e.g. path from the root, in terms of child indices)
06:57:40 <chkl[m]> higherorder: Interesting question!
06:58:11 <higherorder> chkl[m]: :D, do you have an interesting answer? :P
06:58:34 <chkl[m]> Unfortunately not.
06:58:38 <higherorder> haha
07:02:12 <chkl[m]> higherorder: Data.Fix might work for?
07:02:52 <higherorder> chkl[m]: hmm I've no idea what Data.Fix does, not sure
07:03:07 * hackage pipeline 0.1.0 - Continuation patterns  https://hackage.haskell.org/package/pipeline-0.1.0 (iokasimovmt)
07:04:54 <geekosaur> that kind of "context" sounds vaguely comonad-ish. but only vaguely
07:04:54 <higherorder> ooh, I'v efound it
07:04:55 <higherorder> The Zipper is an idiom that uses the idea of ‚Äúcontext‚Äù to the means of manipulating locations in a data structure. 
07:04:59 <higherorder> https://wiki.haskell.org/Zipper
07:06:36 <chkl[m]> Data.Fix provides general "fold"-like functions that work on any Functor. E.g. trees. `cata` is the a generalized fold, but as I see it it's "bottom-up", not "top-down" as you would like to use it. 
07:11:37 <mmr_> Zipper sounds correct, the code exercise site exercism.io has a Zipper problem on its Elixir track that I just did yesterday
07:11:53 <mmr_> the Learn You a Haskell book has a chapter on Zippers that I used to help me understand the concept
07:13:59 <slaterr> @hoogle with
07:13:59 <lambdabot> Foreign.Marshal.Utils with :: Storable a => a -> (Ptr a -> IO b) -> IO b
07:13:59 <lambdabot> Data.Acquire with :: MonadBaseControl IO m => Acquire a -> (a -> m b) -> m b
07:13:59 <lambdabot> Data.Acquire.Internal with :: MonadBaseControl IO m => Acquire a -> (a -> m b) -> m b
07:14:09 <slaterr> @hoogle finally
07:14:09 <lambdabot> Control.Exception finally :: IO a -> IO b -> IO a
07:14:09 <lambdabot> Control.Exception.Base finally :: IO a -> IO b -> IO a
07:14:09 <lambdabot> Test.QuickCheck.Exception finally :: IO a -> IO b -> IO a
07:14:27 <slaterr> should I use that for cleaning up my messes, regardless if exception was thrown or not?
07:24:07 <kadoban> In haskell I dunno. In other languages, yeah you use "finally" when you want to do cleanup that must always happen, regardless of if you exit a block normally or via an exception
07:26:05 <chkl[m]> slaterr: Sure, use `finally`. Or do you have another solution in mind?
07:27:37 <chkl[m]> Oh, and don't forget that `finally` re-throws the exception, so you might still need a `catch`.
07:27:53 <sternmull> or use bracket
07:33:29 <jmcarthur> I find myself using bracket far more often than finally.
07:33:34 <jmcarthur> Or bracket_
07:42:25 <Welkin> is it true that WriterT leaks space?
07:44:48 <Welkin> I'm looking through an old codebase and it has all these odd comments and implementations. Instead of using RWST they use their own `RST` (no Writer) transformer
07:45:10 <Welkin> they could just as well use ReaderT and StateT together, and I see no difference other than a few more `lifts` required
07:45:45 <geekosaur> some people don't like monad transformers, that's why RWS(T) is still around
07:46:18 <Welkin> yes, but does Writer actually leak space?
07:47:10 <geekosaur> that I can't answer
07:47:42 <Welkin> and what is the performance penalty of using ReaderT and StateT vs some combined RST?
07:47:46 <geekosaur> think I've seen some complaints about lack of strictness?
07:47:48 <Welkin> I can;t imagine it's that much
07:48:11 <geekosaur> it used to be higher
07:48:59 <chkl[m]> In transformers there are also three versions of WriterT( Control.Monad.Trans.Writer.Lazy, Control.Monad.Trans.Writer.Strict, and Control.Monad.Trans.Writer.CPS)
07:49:01 <geekosaur> one of the reasons mtl2 had separate definitions for State, Reader, etc. instead of transformers over Identity is that ghc used to be unable to optimize the transformers away
07:49:14 <Welkin> according to this codebase, Snap used to have a RST transformer
07:49:22 <Welkin> but I can't find it at all today
07:56:18 <Welkin> is it better to use GeneralizedNewtypeDeriving or DeriveAnyClass with `deriving newtype (..)`?
07:56:34 <Welkin> for a newtype wrapping a monad transformer stack
07:58:30 <[Leary]> DeriveAnyClass just produces empty class declarations. If you want to derive through newtypes you need GND or DerivingVia.
07:58:35 <geekosaur> GND. DeriveAnyClass creates an empty instance that relies on default implementations, but newtypes don't have default implementations, GNDD generates wrap/unwrap code
07:58:37 <[Leary]> instance*
08:00:32 <geekosaur> well, rehrase, it's not the newtype, it'd require every derived-through class to know how to deal with the newtypes itself via default method implementations. GND generates the instance method itself from the newtype, which is formulaic and much faster than relying on every class to use Generics to figure out how to wrap/unwrap
08:01:38 * hackage Earley 0.13.0.1 - Parsing all context-free grammars using Earley's algorithm.  https://hackage.haskell.org/package/Earley-0.13.0.1 (OlleFredriksson)
08:05:31 <jmcarthur> Welkin: WriterT is not memory efficient. You can tell by looking at the definition of (>>=). It stows away the accumulator while it runs the right hand side and only after that returns does it combine the accumulators.
08:07:12 <jmcarthur> Welkin: There's a version of WriterT you can implement in terms of StateT that doesn't suffer from this problem.
08:09:37 * hackage rigel-viz 0.1.0.0 - A mid-level wrapper for vega-lite  https://hackage.haskell.org/package/rigel-viz-0.1.0.0 (ocramz)
08:11:49 <slaterr> I think finally is what I want (there are many exception constructs and I have yet to memorize how they differ)
08:12:13 <slaterr> finally will let the exceptions pass, while still ensuring that my cleanup code gets executed
08:27:06 <Welkin> are there any other routing libraries (or implementations) besides wai-route (and the implementations of course in scotty, servant, etc)
08:27:48 <Welkin> I notice that wai-routes uses type applications and type-level strings, which is cool, but then matching on the captured parameters is clunky (a ::: b ::: Nil)
08:28:09 <Welkin> instead of just having them in a tuple, for example, or uncurried
08:29:55 <Welkin> scotty has the simplest and easiest to use approach to writing route paths, but just need some type safety and automatic conversion
08:36:51 <sternmull> Welkin: i am starting with Spock at  the moment and i think it does what you want.
08:37:50 <Welkin> I've evaluated most of the available web libraries, and used many of them
08:38:04 <Welkin> right now I am trying to fix up Airship (WebMachine for Haskell)
08:38:38 <Welkin> spock feels too much like yesod to me: bloated and over-engineered
08:38:54 <Welkin> the router doesn't look bad though
08:39:43 <sternmull> really? In what sense? It feels pretty minimal to me. And i think i am already very sensible to webframworks that try to do too much.
08:40:20 <Welkin> my preference is to have WebMachine (model an http request/response cycle as a state machine) with the routing from soctty (but with type safety) and other nice functions from scotty
08:41:32 <Welkin> sternmull: spock is too opinionated and includes too many things that it shouldn't, like sessions
08:41:59 <Welkin> I like to write my own session handler and authentication/authorization layer, which can be done in very few lines of code for me
08:42:18 <Welkin> especially with the help of webmachine
08:42:27 <sternmull> you don't have to use its session support
08:43:46 <Welkin> the SpockM typ forces you to use it's built-in database and session handling
08:46:33 <sternmull> you can use PCNoDatabase to disable its database connection support. But ok it looks like you can't disable sessions completely and will always have a cookie and an entry in the session store.
08:55:01 <dminuoso> dmwit: (==) and (/=) are less interesting Monoid instances, is this more preferrable to "are less interesting monoids"?
08:55:18 <dmwit> No, I'm objecting to "less interesting", not to phrasing.
08:55:37 <dmwit> (/=) is addition mod 2, the basis of every computer on the planet.
08:58:05 <dminuoso> dmwit: It's much less interesting for higher level programming. I have not needed a `newtype Mod2Add = ...` yet.
08:59:23 <Solonarv> you could just use 'Sum (Mod 2)' if you did need one (Mod is from the arithmoi package I think)
08:59:24 <hpc> f = transistor (transistor transistor transistor) transistor transistor (transistor transistor)
09:00:40 <dmwit> I have used it on occasion for parity checks.
09:01:05 <dmwit> And (less convincingly) in programming contest-style challenges.
09:02:39 <dminuoso> dmwit: Fair enough. :)
09:09:28 <dminuoso> dmwit: I still feel they are less interesting than Any or All tohugh.
09:09:56 <dmwit> Search your feelings. You know it to be True!
09:31:47 <dminuoso> Can someone explain to me why I am getting this particular error message? https://gist.github.com/dminuoso/c218c3931fe939a6a1d2859bc1c203f5
09:32:02 <dminuoso> eta-extending experiment fixes the error, so Im a bit confused.
09:33:07 * hackage flat-tex 0.6.0 - flatten a latex multi-file latex document and remove all comments  https://hackage.haskell.org/package/flat-tex-0.6.0 (JohannesWaldmann)
09:35:27 <Solonarv> dminuoso: my guess is "something something existentials"
09:35:46 <dminuoso> Solonarv: There is no existentials here.
09:36:06 <Welkin> try adding ScopedTypeVariables
09:36:22 <Welkin> you have a forall in your newtype
09:36:37 <dminuoso> Welkin: Huh?
09:36:54 <Solonarv> STV shouldn't change anything
09:36:58 <dminuoso> Welkin: Perhaps you missed the part "eta-extending experiment fixes the error"
09:37:35 <dmwit> dminuoso: Same reason runST $ do doesn't fly.
09:37:47 <dmwit> (.) can't give you back a polymorphic thing at risk of offending the impredicativity gods.
09:38:32 <dmwit> s/doesn't/used to doesn't/ ;-)
09:38:50 <Welkin> point-free is overrated
09:39:42 <dminuoso> dmwit: Wait what?
09:39:54 <dminuoso> % import Data.STRef
09:39:54 <yahb> dminuoso: 
09:40:22 <dminuoso> % runST $ do ref <- new STRef "foo"; readSTRef ref
09:40:23 <yahb> dminuoso: ; <interactive>:61:19: error: Variable not in scope: new :: t0 -> [Char] -> ST s (STRef s a); <interactive>:61:23: error: Data constructor not in scope: STRef
09:40:29 <dminuoso> % runST $ do ref <- newSTRef "foo"; readSTRef ref
09:40:30 <yahb> dminuoso: "foo"
09:40:31 <Solonarv> the type of (.) in there is ((forall f. Functor f => (s -> f s) -> f a) -> Pretext s a) -> (forall f. Functor f => Store s a -> (s -> f s) -> f a)) -> Pretext s a -- this is indeed similar to the 'runST $ ...' situation, where '($) :: ((forall s. ST s a) -> a) -> (forall s. ST s a) -> a'
09:40:46 <dminuoso> Oh I missed the ($)
09:41:06 <Solonarv> 'runST $ ...' works because it's special-cased in the typechecker; (.) isn't
09:42:41 <dminuoso> dmwit: So iow type inference is the problem?
09:42:58 <dminuoso> I mean as far as I understand it, the main issue with impredicativity seems to be just type inference. :)
09:44:07 <Solonarv> it's not implemented in GHC, that's true
09:44:08 <Solonarv> https://ghc.haskell.org/trac/ghc/wiki/ImpredicativePolymorphism
09:44:36 <Solonarv> in fact, the first example on that page is a stripped-down version of your problem code
09:45:12 <dminuoso> Ah neat, thanks Solonarv and dmwit.
09:45:17 <Welkin> why would you put forall inside a type declaration?
09:45:18 <dminuoso> Taking a look now.
09:45:25 <Welkin> data/newtype*
09:45:44 <dminuoso> Welkin: The same reason you use type variables.
09:46:11 <Solonarv> in fact, putting foralls in a newtype is one way to get around this impredicativity problem!
09:46:12 <Welkin> that is not an explanation
09:46:52 <dminuoso> Welkin: I like to think of `forall` being an abstraction over a type, much like functions. 
09:47:19 <dminuoso> So `(forall a. ...) -> ...` has similar justificatoins like `(A -> B) -> C`
09:47:22 <Welkin> ST doesn't even do that
09:47:37 <Welkin> the forall lives in the extraction function
09:48:00 <dminuoso> Welkin: In case of ST it's just a trick to prevent you from sneaking the internal state out.
09:49:35 <Solonarv> the page I linked has an example of why you'd want to do that
09:50:29 <Solonarv> more generally speaking, passing around a (forall a b c. ...) can be inconvenient (because of impredicativity); you can work around this by stuffing it in an appropriate newtype
09:51:37 * hackage front 0.0.0.1 - A reactive frontend web framework  https://hackage.haskell.org/package/front-0.0.0.1 (swamp_agr)
09:52:00 <dminuoso> Solonarv: Oh indeed. The reason is quite simple reading the page.
09:52:10 <dminuoso> The knowledge had drifted into the back of my head.
09:52:21 <dminuoso> (.) :: forall p q r. (q -> r) -> (p -> q) -> p -> r
09:52:33 <Solonarv> same, I only remembered enough to know I had to google 'impredicative polymorphism' ;)
10:00:58 <dmwit> dminuoso: Yes, runST $ do ... works now, but it didn't always. I assumed you remembered enough history for that, but maybe not.
10:01:21 <dmwit> No, impredicative polymorphism troubles are not just about type inference. They're a fairly fundamental problem in the foundations of logic.
10:01:33 <dmwit> Allowing them leads to fairly straightforward self-reference paradoxes.
10:01:46 <dmwit> s/them/it/ I guess
10:03:07 <dminuoso> dmwit: Maybe I need to better understand how or why core allows impredicative polymorphism.
10:03:36 <dminuoso> I remember discussions here in #haskell where I was told, that the reason it worked in core was the absence of type inference (because all core expressions are explicitly typed)
10:04:00 <dminuoso> dmwit: And also I don't remember it, Ive been doing Haskell for only a bit over a year now.
10:06:16 <monochrom> Impredicativity conflicts with GHC's type inference (which has to cater for other extensions).  But at core there is nothing to infer, you annotate everything, so everyone lives happily together.
10:07:14 <monochrom> All problems can be solved by being told the answer. >:)
10:07:49 <dminuoso> monochrom: "answer" being a "type anotation"?
10:07:54 <monochrom> Yeah!
10:10:16 <WilhelmVonWeiner> Hey, I'm not writing Haskell but I have a question about functionality
10:11:02 <WilhelmVonWeiner> if every function accepts all the parameters that make up the state of the program and they're just passed around, back and forth and whatnot, is that really functional
10:11:28 <dminuoso> WilhelmVonWeiner: "functional" is a lose term that means different things to different people.
10:11:35 <WilhelmVonWeiner> Bollocks
10:11:47 <dmwit> Um. Are you double-plus sure that core allows impredicativity?
10:11:52 <monochrom> I am fairly open-minded for this so yes.
10:11:53 <dminuoso> dmwit: Yes.
10:13:18 <monochrom> In fact that's how my thesis could discuss lazy evaluation but I used an imperative programming language. (Hint: I have no I/O there.)
10:13:48 <dmwit> Traditionally "functional" means "can pass functions as arguments and construct functions via closure". No comment one way or the other on implicit global state.
10:13:58 <dminuoso> WilhelmVonWeiner: When we call Haskell a functional programming language, it might refer to a) functions being first-class citizens, b) functions satisfying the functional property (i.e. they are all referentially transparent)
10:14:16 <Welkin> the lambda calculus
10:15:33 <WilhelmVonWeiner> "referentially transparent" being "for input x the result is always the same"?
10:16:01 <dminuoso> WilhelmVonWeiner: Even stronger. Referential transparency doesn't care whether you call a function 0 times, 1 times or many times
10:17:39 <WilhelmVonWeiner> is referential transparency the only prerequisite for purity
10:18:22 <haasn> WilhelmVonWeiner: I would say so
10:19:14 <haasn> WilhelmVonWeiner: in simple terms it means "replacing an expression by its result doesn't change the semantics of the program"
10:19:57 <haasn> (although "result" is vague in this description)
10:20:05 * dminuoso chuckles as he has just experienced that replacing (.) with its definition changed the semantics from "does not type check" to "type checks and runs fine"
10:20:21 <dminuoso> But that's a different topics. :o)
10:21:09 <haasn> dminuoso: let me take a stab in the dark and guess it was related to # vs *?
10:21:14 <Solonarv> generally we only talk about the semantics of programs that actually compile, at lest that's what I thought :P
10:21:19 <Solonarv> haasn: no, not at all
10:21:22 <dminuoso> haasn: Nah, impredicative polymorphism.
10:21:28 <Solonarv> (also, # isn't really a thing anymore)
10:21:42 <haasn> ooh, it isn't? how does GHC handle unboxed values?
10:21:44 <dminuoso> Yes! (.) has levity polymorphism now.
10:21:54 <Solonarv> we have full levity polymorphism
10:21:56 <dminuoso> haasn: We have a completely magical TYPE primitive that shouldn't be able to exist.
10:22:16 <haasn> sounds like fun
10:22:17 <Solonarv> * is special syntax for Type, which in turn is a type synonym standing for TYPE 'LiftedRep
10:22:28 <dminuoso> type Type = TYPE 'LiftedRep
10:22:34 <dminuoso> Three mentions of type, this is juicy.
10:22:43 <nisstyre> Solonarv: are you including the DataKinds extension in that?
10:22:53 <Solonarv> the reason it's magical is that TYPE r :: TYPE 'LiftedRep
10:22:57 <dminuoso> nisstyre: And a deep and dark GHC primitive
10:23:13 <dminuoso> TYPE is a beast that crosses universes.
10:23:43 <haasn> does BOX still exist?
10:23:45 <dminuoso> haasn: I think it happened in 8.6 or 8.4, so its relatively recent.
10:23:51 <dminuoso> haasn: everything is moving towards TypeInType
10:23:58 <Solonarv> no (or rather, if it does it's just a synonym for Type)
10:24:06 <dminuoso> So the "infinite tower notion" is starting to crumble.
10:24:09 <Solonarv> % :k Int
10:24:09 <yahb> Solonarv: Int :: *
10:24:11 * haasn is out of the loop
10:24:22 <haasn> so can you have dependent pairs yet?
10:24:24 <dminuoso> haasn: TypeInType just means Type :: Type
10:24:27 <Solonarv> % :set -XNoStarIsType
10:24:27 <yahb> Solonarv: 
10:24:32 <Solonarv> % :k Type
10:24:33 <yahb> Solonarv: Type :: Type
10:24:40 <dminuoso> And `type Type = *`
10:24:47 <dminuoso> well.
10:24:52 <Solonarv> we can sort-of have dependent pairs using TypeRep
10:24:54 <dminuoso> Flip that around!
10:25:00 <Solonarv> and/or Typeable
10:25:55 <dminuoso> haasn: The thing about levity is that GHC hides it from you
10:25:57 <haasn> but can it type printf :: (s :: String) -> PrintfType s ?
10:26:01 <dminuoso> % :k (->)
10:26:01 <yahb> dminuoso: (->) :: Type -> Type -> Type
10:26:03 <Solonarv> no
10:26:06 <dminuoso> This kind signature is a lie.
10:26:12 <dminuoso> Its a blatant lie.
10:26:19 <dminuoso> (Or yahb runs an old GHCi version)
10:26:57 <Solonarv> but it could type 'printf :: forall (s :: Symbol). PrintfType s', using type-level computation to parse 's' and produce a type
10:27:08 <MarcelineVQ> % :! ghc --version
10:27:08 <yahb> MarcelineVQ: The Glorious Glasgow Haskell Compilation System, version 8.6.0.20180620
10:27:12 <haasn> can you actually use type level computation to parse 's' yet?
10:27:30 <Solonarv> yes, but it's very cumbersome and (probably) leads to enormous compile times
10:27:31 <haasn> last I tried you couldn't pattern match on Symbol
10:27:38 <Solonarv> you still can't, not really
10:27:40 <haasn> or turn it into a '[Symbol] or something
10:27:51 <dminuoso> % :i ($)
10:27:52 <yahb> dminuoso: ($) :: (a -> b) -> a -> b -- Defined in `GHC.Base'; infixr 0 $
10:28:08 <dminuoso> This should read: ($) :: forall (w :: Levity) a (b :: TYPE w). (a -> b) -> a -> b
10:28:32 <dminuoso> Oh well. Bad copy pasta!
10:28:36 <dminuoso> But its close enough
10:28:42 <Welkin> levity polymorphism?
10:28:49 <Solonarv> but you can use CmpSymbol to find the first character, and use AppendSymbol to decompose a Symbol if you know its start or end
10:29:02 <haasn> but what is Levity :: ?
10:29:10 <dminuoso> haasn: It's about kind polymorphism
10:29:19 <Solonarv> haasn: it's actually called RuntimeRep
10:29:21 <haasn> % :k! Levity
10:29:21 <yahb> haasn: unknown command ':k!'; use :? for help.
10:29:27 <haasn> % :k Levity
10:29:27 <yahb> haasn: ; <interactive>:1:1: error: Not in scope: type constructor or class `Levity'
10:29:29 <haasn> aaw
10:29:40 <dminuoso> haasn: Sorry that should have been RuntimeRep, I just copy pasted something rather old when it was still WIP
10:29:44 <Solonarv> data RuntimeRep = LiftedRep | UnliftedRep | IntRep | WordRep | DoubleRep | ...
10:29:45 <dminuoso> Without checking too closely
10:29:58 <Welkin> so what is # now?
10:29:59 <haasn> oh, so just a normal lifted type
10:30:20 <Solonarv> https://kcsongor.github.io/symbol-parsing-haskell/ -- here's a blog post on parsing Symbol
10:30:32 <Solonarv> AFAIK # doesn't really exist as a singular thing anymore
10:30:47 <Solonarv> it conflated all the unlifted representations; now they're separate
10:30:58 <dminuoso> Welkin: TYPE 'UnliftedRep
10:31:16 <dminuoso> Welkin: Perhaps (#) is kept as a type alias though.
10:31:16 <haasn> Solonarv: seems like a horrendeous hack. I love it
10:31:29 <Solonarv> oh yes, it's pretty hacky
10:32:01 <dminuoso> % import GHC.Exts
10:32:01 <yahb> dminuoso: 
10:32:05 <dminuoso> % :k Int#
10:32:05 <yahb> dminuoso: Int# :: TYPE 'GHC.Exts.IntRep
10:32:07 * haasn once implemented type-level strings and numbers before Symbol and Nat were a thing
10:32:22 <nisstyre> haasn: did it take 20 minutes to compile your code?
10:32:23 <dminuoso> Welkin: ^- or that even, there's a couple different RuntimeRep
10:32:33 <haasn> but then once I got to type-level rationals computing the error messages was too slow for further experimentation
10:32:39 <dminuoso> Welkin: just look at https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Exts.html#t:RuntimeRep
10:32:47 <nisstyre> haasn: can you use Farey sequences for that?
10:32:51 <haasn> nisstyre: no, but it took about that long to figure out any type error
10:32:55 <Solonarv> Symbol and Nat are pretty inconvenient to work with due to being primitives, so sometimes you still need to implement your own
10:33:20 * dminuoso wishes Natural had been there from the beginning in Haskell.
10:33:26 <Solonarv> (specifically, Nat isn't a peano construction, which makes it hard to decompose)
10:33:41 <c_wraith> I don't understand why Nat doesn't allow negative numbers, given how it works.
10:33:58 <Welkin> because that's not a Nat
10:34:01 <Welkin> it would be Int nstead :D
10:34:31 <Solonarv> implementing type-level Integer on top of Nat should at least be fairly simple
10:34:51 <Solonarv> (just represent them as (Nat, Bool) or something)
10:35:11 <haasn> Solonarv: I needed a unique representation for some reason or other
10:35:16 <nisstyre> it would be pretty sweet if you had types that represented rationals, and automatically found the reduced version of whatever you put in
10:35:22 <haasn> Farey sequences seem interesting, you mean using them as a bijection onto Nat?
10:35:30 <nisstyre> and then somehow checked equality between different representations of the same rational number
10:35:41 <nisstyre> does that exist already?
10:35:45 <haasn> Solonarv: but I guess you can implement all of your arithmetic primitives in a normalizing way
10:35:50 <Solonarv> not as far as I know
10:35:54 <nisstyre> haasn: yeah pretty much
10:35:54 <haasn> if the only special case is -0 -> 0
10:36:07 <Solonarv> yeah, or just roll your own equality instead of using ~
10:36:08 <haasn> nisstyre: I had that code
10:36:10 <dminuoso> haasn: By the way, I rethought what we talked about prism the other day
10:36:14 <nisstyre> haasn: awesome
10:36:17 <dminuoso> % :t prism
10:36:17 <yahb> dminuoso: (Choice p, Applicative f) => (b -> t) -> (s -> Either t a) -> p a (f b) -> p s (f t)
10:36:18 <haasn> it required computing the gcd in the type system
10:36:23 <haasn> on peano nats
10:36:36 <haasn> in a way that requires exhaustively evaluating all branches
10:36:36 <dminuoso> haasn: ^- I think you might have been confused about the type signature on this function.
10:36:41 <haasn> because GHC at the time was not lazy in the type system
10:36:43 <haasn> (is it now?)
10:36:49 <Solonarv> nope
10:36:51 <nisstyre> haasn: I guess with Farey sequences you could enter an "irrational" number like e or pi and then have it find an approximation in the rationals
10:36:57 <nisstyre> but that would be...intense
10:37:35 <haasn> you can do it with continued fractions ^
10:37:41 <haasn> are they related?
10:37:41 <Solonarv> @hackage ghc-typelits-natnormalise
10:37:41 <lambdabot> http://hackage.haskell.org/package/ghc-typelits-natnormalise
10:37:42 <nisstyre> yeah you c an
10:37:45 <nisstyre> yes they are related
10:37:49 <haasn> dminuoso: elaborate
10:37:53 <Solonarv> ^ this helps when you're doing a lot of stuff with Nat
10:38:47 <nisstyre> haasn: > Fractions that appear as neighbours in a Farey sequence have closely related continued fraction expansions
10:38:51 <nisstyre> https://en.wikipedia.org/wiki/Farey_sequence
10:38:58 <haasn> dminuoso: to me, the type signature reads "give me a review and a view, and I will give you a prism s t a b"
10:39:22 <dminuoso> haasn: it says "give me build and review"
10:39:23 <haasn> Solonarv: cool
10:39:51 <nisstyre> there's all kinds of stuff you could calculate with this
10:39:56 <dminuoso> haasn: so to construct _Just you would have to supply `Just` as the first function.
10:39:56 <Solonarv> dminuoso: 'b -> t' is a "review" in lens parlance
10:40:00 <haasn> review :: Prism s t a b -> b -> t
10:40:04 <dminuoso> oh
10:40:07 <dminuoso> I see.
10:40:22 <dminuoso> Im used to different terminology, that exlains the confusion.
10:40:27 <haasn> I see
10:40:32 <Solonarv> the other thing is called "match" IIRC (but isn't an optic by itself)
10:40:38 <Solonarv> again, in lens parlance
10:41:03 <haasn> I was wrong either way
10:41:17 <haasn> I mean to say preview rather than view
10:41:29 <Welkin> and a postview
10:41:47 <dminuoso> haasn: okay! so `match = preview` and `review = build` :)
10:42:32 <haasn> is there a preview based on MonadPlus?
10:42:43 <dminuoso> haasn: Suddenly the name `review` makes sense to me.
10:42:51 <dminuoso> I guess "coview" might have worked too
10:43:27 <haasn> what's the dual of viewing something? being watced?
10:44:05 <MarcelineVQ> commenting on something :>
10:44:25 <monochrom> "first post"
10:48:34 <haasn> hmm even an msum-like preview wouldn't be general enough to match the s -> Either t a type signature
10:48:46 <haasn> most likely it would end up having a Monoid t constraint
10:49:05 <haasn> and also missing the s -> t part
10:49:16 <Solonarv> it could be something like 'match :: MonadError t m => Prism s t a b -> s -> m a'
10:50:20 <haasn> at that point it might as well just m ~ Either t
10:50:35 <Solonarv> we recover the 's -> Either t a' variant via 'instance MonadError e (Either e)', but there are other instances too
11:23:04 <boeingx> Hi! What is the best practice to write Alex and Happy code with Stack? Not sure where to put these files and how to invoke alex and happy
11:23:35 <boeingx> I only found instructions on using Cabal
11:24:30 <fendor> is there a difference between GHCs installed by stack and those installed by package manager or built from source? except from compile time flags and such stuff?
11:26:55 <boeingx> fendor: to me stack manages its proper GHCs. You can have multiple versions of GHC, each for a different project, and they do not interfere with system GHC
11:27:02 <MarcelineVQ> some come with required static libs that might not otherwise be on your system, like different libtinfo versions
11:27:27 <Welkin> you can have multiple versions of ghc with cabal as well
11:27:43 <Welkin> if you really want to go nuts with it, use nix
11:27:49 <fendor> I see. Is it possible in general to let cabal use a GHC that has been installed by stack?
11:27:54 <Welkin> no idea
11:30:04 <Solonarv> yes, pretty easily
11:31:13 <Solonarv> 'stack exec --resolver whatever -- where ghc' will give you the path to stack's ghc, and you can point cabal at that path
11:31:44 <Solonarv> That's how I installed ghc before I remembered that chocolatey exists
11:32:25 <MarcelineVQ> there'll be a few options if you've been using stack for some time, can be found in ~/.stack/programs/
11:33:44 <Solonarv> no, that's what the '--resolver whatever' is for (replace 'whatever' with the resolver you want to use)
11:34:10 <Solonarv> e.g. to get ghc8.4.4 you can use '--resolver ghc-8.4.4'
11:37:59 <fendor> hm, thanks for all your answers!
11:39:24 <fendor> I think, I am facing a MacOS related problem... Building a project with a GHC installed via package manager succeeds, but the GHC installed by Stack fails.
11:40:00 <fendor> error message is shown here: https://hastebin.com/yeladumela.makefile
11:42:26 <Welkin> just install haskell platform
11:42:51 <Welkin> https://www.haskell.org/platform/
11:42:58 <Solonarv> That won't help stack, it manages its own ghc
11:43:13 <Welkin> yes
11:43:13 <Solonarv> (unless you tell it not to via 'system-ghc: true' in stack.yaml)
11:43:17 <Welkin> there is no need for stack
11:43:19 <fendor> also it is macos 
11:43:29 <Welkin> fendor: yes, haskell platform works on macos
11:44:10 <fendor> Welkin, ok, it doesnt matter though, the ghc is auto detected at install time, using it to build the project fails
11:44:23 <Welkin> cabal new-build
11:45:07 <fendor> the project should be built with multiple ghc versions, thus the auto detection of available ghc versions
11:45:18 <fendor> it is being built with cabal new-build
11:46:28 <Welkin> https://cabal.readthedocs.io/en/latest/installing-packages.html?highlight=ghc#cmdoption-setup-configure-with-compiler
11:47:09 <Welkin> or https://cabal.readthedocs.io/en/latest/installing-packages.html?highlight=ghc#cmdoption-setup-configure-with-prog
11:48:37 <fendor> I am using that, the problem is, when using the GHC installed by stack, the build fails
11:49:09 <Welkin> then don't use the one from stack
11:49:13 <Welkin> install it yourself
11:49:36 <Welkin> https://www.haskell.org/ghc/
11:49:52 <fendor> Can I detect whether a detected GHC has been installed by stack?
11:50:11 <Welkin> it probably has a symlink to the .stack dirctory
11:50:13 <Welkin> or whatever it's called
11:53:41 <hpc> if at compile time, i want to read in a text file and have it available as a value of type Text, how does one do that?
11:54:05 <hpc> i am at the point where i have a (Q Text), but liftData on that text is a disaster
11:54:49 <Welkin> hpc: use lisp?
11:58:21 <fendor> hpc, do you want to implement it yourself? I think there is a library embed-file or something like that.
11:59:21 <lyxia> hpc: use lift with the instance from here http://hackage.haskell.org/package/th-lift-instances-0.1.11/docs/Instances-TH-Lift.html
12:10:16 <hpc> ah, cool
12:32:07 <rotaerk> hmm if I have:  `f <$> g <*> g <*> g <*> g <*> g <*> g`, is there some way to reduce the explicit repetition of g
12:32:52 <rotaerk> though I guess that'd be equivalent to asking if I can eliminate the repetition in `f g g g g g g`
12:34:58 <haasn> rotaerk: you can, but I'm not sure if it'll be shorter
12:35:03 <rotaerk> k
12:35:22 <haasn> you can construct a typeclass to repeatedly apply $g until the type matches :p
12:35:40 <haasn> or in this case (<*> g)
12:36:01 <haasn> unfortunately you can't easily just foldr . replicate or something because the type keeps changing
12:36:19 <rotaerk> yeah
12:37:38 <lyxia> rotaerk: http://hackage.haskell.org/package/one-liner-1.0/docs/Generics-OneLiner.html#v:createA_   createA_ g f   if you can give g a polymorphic type.
12:38:26 <rotaerk> hmm neat
12:47:29 <hpc> in true programmer fashion, i realized i was being an idiot and /usr/local/share is the right place to put that sort of stuff
12:55:01 <haasn> hpc: or a string inside the data segment somewhere, depending on the contents?
12:56:03 <adius> Hi, has anyone here experience with the jose package?
12:56:03 <adius> I'm trying to extract an JWT field email from a jwt value: `jwtValue = decodeCompact (TL.encodeUtf8 jwtByteString) :: Either Error (CompactJWS JWSHeader)`
12:56:20 <adius> I just don't get how this lenses stuff works üò≠
12:57:58 <eschnett_> i recall there was a way to use "trace" or similar that can output variables without requiring a Show instance. what is the function or module called?
12:58:26 <adius> eschnett_: Debug.Trace
12:58:40 <c_wraith> everything in Debug.Trace requires Show.  There might be some crazy stuff that uses ghc internals instead, in some package
12:58:50 <eschnett_> adius: that requires a "Show" instance, which i don't have in my function.
12:59:11 <adius> `jwtValue ^? _Right . signatures` gives me the signature, but no idea how I get the payload
13:01:41 <c_wraith> adius: I think you want the varies claim lenses
13:01:53 <c_wraith> *various
13:01:57 <haasn> eschnett_: there might be some way to do this via the stacktrace mechanism?
13:02:09 <haasn> it's clear that you'll need assistance from GHC, which probably means some sort of constraint is involved
13:02:40 <c_wraith> adius: maybe claimSub, if the sub field is an email address (common, but not universal)
13:03:03 <haasn> I'm pretty sure the stack trace constraints let you get the current line number and module name, so maybe it can also get you the actual expression it's attached to
13:03:22 <Solonarv> you can add an orphan 'instance {-# overlappable #-} Typeable a => Show a', maybe
13:03:49 <c_wraith> adius: and use verifyClaims to get the ClaimSet value
13:03:56 <eschnett_> Solonarv: thank, i'll try this
13:04:28 <iqubic> so how does one get a reflex-dom development environment set-up on nixos?
13:05:42 <adius> c_wraith: But I can't use `verifyClaims`, because I need to look up the secret first with the email address which is contained in the JWT. That is my whole problem
13:05:53 <Solonarv> eschnett_: you do need to actually implement 'show' in that instance
13:06:27 <c_wraith> adius: the docs for verifyClaims say that it's the only way the library exposes to get the data.  Sounds like what you're doing isn't compatible with jose.  (also, really weird.  I've never heard of that sort of flow)
13:06:28 <Solonarv> you can do something like: show x = mconcat ["<", show (typeOf x), ">"]
13:08:16 <adius> c_wraith: Yeah, i know, that's why I have to do weird things. The flow is that each user has it's own secret for signing their JWTs. => I first need to get the secret of the user before I can check if the JWT is valid.
13:09:42 <c_wraith> You can always just do awful things.  split on '.', parse the url-safe base64, parse the json
13:10:49 <c_wraith> jwt isn't a complex format unless you care about the cryptography
13:11:07 <adius> c_wraith: Yeah, misusing the ToJSON instance looks like the best way. But I still think I should be able to extract the value with some lenses magic‚Ä¶
13:11:29 <c_wraith> there's always https://hackage.haskell.org/package/lens-aeson
13:14:14 <iqubic> reflex-dom just seems like a large pain to understand.
13:17:11 <iqubic> Also, I haven't written any reflex-dom code myself, because I haven
13:17:43 <iqubic> I haven't gotten a reflex-dom development environment set-up on nixos.
13:22:25 <iqubic> Also, does ghcjs transpile reflex-dom code into javascript?
13:26:11 <xacktm> #reflex-frp is their channel btw
13:29:28 <iqubic> I see.
13:42:09 <NJBS> Can someone please explain where [Char] enters the picture here? I'd imagine everything would be Text, no? https://hastebin.com/yaxecerovu.hs
13:43:53 <Solonarv> NJBS: 'isInfixOf' works on lists, not Text
13:44:09 <NJBS> Solonarv, ah, of course!
13:44:12 <NJBS> Thanks :)
13:44:29 <glguy> NJBS: (any $ isInfixOf "nsfw")  is better written   any (isInfixOf "nsfw"), once you fix up your imports like Solonarv has identified
13:45:08 <NJBS> glguy, yeah, thanks. I'll move to `words` as well, was just confused as to what was going on with that type error.
13:48:18 <Cale> iqubic: ghcjs is ghc with a backend that compiles to Javascript instead of x86 or ARM or whatever.
13:49:06 <Cale> iqubic: If you're more interested in making desktop applications, you can still just compile using GHC, and your reflex-dom programs will be compiled to native code that controls the DOM via jsaddle.
13:55:25 <pie__> can I write a show instance for something in an ioref that inspects the contents of the ioref?
13:55:58 <dminuoso> pie__: The problem is that Show must produce a valid Haskell expression that will produce the same value.
13:56:15 <pie__> dminuoso, ok whats the "Give me a string i can debug crap with" thing
13:56:21 <pie__> https://bpaste.net/show/a76859c6f025
13:56:42 * pie__ tries to find where in his code show is used
13:56:48 <pie__> i guess i might be able to just unwrap it
14:00:07 * hackage purescript 0.12.3 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.12.3 (hdgarrood)
14:02:21 <pie__> dminuoso, yeah idk, do I just write my own typeclass or what? theres nothing that prevents me from making a string representation of this
14:02:39 <dminuoso> pie__: Are you sure about that?
14:03:08 <pie__> yeah. but i only really want this for debug purposes anyway
14:04:12 <pie__> ah wait ok, yeah the QWidget might not be ideal but i think the library provides a Show for that for some reason
14:04:22 <dminuoso> If you're willing to fling around some unsafePerformIO, then sure. Some `Show a => IORef a -> String` shouldn't be an issue.
14:04:29 <pie__> but im not trying to use this for serialization/deserialization
14:04:39 <pie__> dminuoso, yeah thats what i was thinking
14:08:15 <pie__> I found this, could be helpful for later, but I'll keep in mind the stuff you said https://stackoverflow.com/questions/8332307/show-for-io-types
14:08:29 <pie__> i need to rewrite a lot of this code anyway :c
14:10:57 <pie__> hm, why do I need flexibleinstances for this? ghc is unhappy and I'm pretty sure im making a stupid mistake somewhere: instance Show (IORef Thumbnail') where
14:12:16 <dminuoso> pie__: Because haskell has an old and inflexible type system.
14:12:24 <dminuoso> pie__: With some very conservative rules.
14:12:48 <Solonarv> you need flexibleinstances because under the old rules, instances must be for (TypeCon tyvar1 tyvar2 ...)
14:12:58 <pie__> ok i figured something "this simple" would be fine ill just enable it the
14:13:01 <pie__> *then
14:13:18 <Solonarv> yes, flexible{instances,contexts} are fine to enable
14:13:23 <Solonarv> (many extensions are)
14:13:25 <c_wraith> It's just an explicit admission that you want behavior that differs from the spec
14:13:28 <dminuoso> pie__: FlexibleInstances and FlexibleContexts are perfectly fine to turn on whenever GHC tells you to.
14:14:03 <pie__> ok. from my limited googling i read that they arent unsafe, i just foolishly try to limit the extensions i use per file (so far anyway)
14:14:56 <dminuoso> pie__: They are mainly needed in conjunction with MultiParamTypeClasses
14:15:34 <pie__> yeah ive used that a bit for my callbacks stuff
14:15:43 <dminuoso> pie__: In your case actually you probably should have done:
14:16:04 <dminuoso> pie__: `instance Show a => Show (IORef a)` and `instance Show Thumbnail'`
14:16:15 <dminuoso> That would be a standard Haskell solution
14:16:24 <pie__> i guess that makes enough sense
14:16:47 <pie__> thats probably what the stackoverflow post did, i only skimmed it so fat
14:16:49 <pie__> far
14:17:38 <Welkin> people actually write software (web server applications?) with agda? https://github.com/larrytheliquid/Lemmachine/blob/master/src/Lemmachine/Lemmas.agda
14:17:51 <Welkin> I thought agda was a proof assistant like coq
14:18:18 <pie__> afaiu coq also has code extraction
14:18:32 <pie__> IIRC thats what its called, or something like that
14:19:07 <pie__> afaiu agda somehow results in haskell code
14:19:14 <Welkin> what is with all the acronyms?
14:19:21 <Welkin> afaiu? iirc?
14:19:33 <adius> c_wraith: Wrote it without lenses, but looking at the code, I probaly should have used it üòÖ
14:19:52 <pie__> sorry :D, reflexive IRC stuff: afaiu = as far as i understand, iirc = if i recall correctly
14:20:10 <pie__> oh wow that repo is 9 years old huh
15:34:07 * hackage strongswan-sql 1.0.0.0 - Interface library for strongSwan SQL backend  https://hackage.haskell.org/package/strongswan-sql-1.0.0.0 (erick)
15:53:11 <brunoo>  newtype RiskyT a = RiskyT {runRiskyT :: ReaderT (TVar GameHub) IO a }     deriving (Functor, Applicative, Monad, MonadIO, MonadReader (TVar GameHub), MonadTrans)
15:53:29 <brunoo>     ‚Ä¢ Cannot derive well-kinded instance of form ‚ÄòMonadTrans (RiskyT ...)‚Äô         Class ‚ÄòMonadTrans‚Äô expects an argument of kind ‚Äò(* -> *) -> * -> *‚Äô     ‚Ä¢ In the newtype declaration for ‚ÄòRiskyT‚Äô
15:54:08 <brunoo> Hi, I do not understand that compiler error, why does it think that MonadTrans have that kind?
15:58:00 <dyl> brunoo: It‚Äôs expecting a type with kind (* -> *) -> * -> *. 
15:58:25 <dyl> It other words, a t such that you can write ‚Äút m a‚Äù where m is a monad and a is some type.
15:58:43 <c_wraith> You don't need a MonadTrans instance, anyway.  The MonadReader and MonadIO instances cover everything that type can do
15:59:05 <dyl> Your RiskyT isn‚Äôt parametrized by a monad, so it doesn‚Äôt fit the bill.
15:59:43 <dyl> What c_wraith said. 
16:00:01 <dyl> But if you wanted a transformer you‚Äôd have to define RiskyT m a and type Risky = Risky Identity a 
16:00:08 <dyl> RiskyT Identity a*
16:00:31 <dyl> You probably don‚Äôt need to define such your own transformer though, just your own monad stack.
16:08:48 <brunoo> ooooh I replaced lift everywhere in my code to liftIO and now I don't even need monadtrans, thanks! :)
16:17:40 <Amras> if I want to expand <> into a tuple, `(Semigroup a, Semigroup b) => (a, b) -> (a, b) -> (a, b)` I have to write a pretty messy function which unwraps and re-wraps the two tuples and applies <> per argument; is there any simpler way of doing something similar?
16:18:04 <Amras> something like a type-variant fmap?
16:18:28 <Solonarv> uh, you can just use <> directly?
16:18:29 <hpc> check out bifunctors
16:18:35 <glguy> (x,y) <> (u,v) = (x<>u, y<>v)
16:18:39 <glguy> It's  going to be hard to beat that
16:18:41 <Amras> oh
16:18:46 <hpc> oh
16:18:54 <Solonarv> hah
16:19:00 <hpc> > ("a", "1") <> ("b", "2")
16:19:02 <lambdabot>  ("ab","12")
16:19:06 * hpc dies of embarassment
16:19:09 <Amras> oh wow yeah
16:19:14 * Amras too
16:19:29 <Amras> I cannot read instance lists
16:19:43 <Amras> that solves that, thanks >_>
16:20:59 <hpc> well, check out bifunctors anyway, they're pretty nifty
16:21:26 <Amras> ooh, they have their own website
16:21:38 <Solonarv> lens has some stuff for working with tuples too
16:21:53 <Amras> Traverser, you mean?
16:22:12 <Amras> s/er/al/
16:22:20 <c_wraith> some of them, sure.  like each
16:22:22 <c_wraith> :t each
16:22:23 <lambdabot> (Applicative f, Each s t a b) => (a -> f b) -> s -> f t
16:22:30 <c_wraith> it can do anything!
16:22:44 <c_wraith> > (1, 2) & each +~ 1
16:22:46 <lambdabot>  (2,3)
16:23:08 <c_wraith> It has instances for several sizes of tuples, as long as every tuple element is the same type
16:24:48 <jackdk> you can each tuples!? that's nifty.  I only knew about `both`
16:25:10 <koz_> I think they have to have the same type in each half for that, right?
16:25:51 <c_wraith> koz_: you are correct
16:26:11 <koz_> Good to know, lol.
16:26:12 <c_wraith> > (1 :: Int, 2 :: Integer) & each +~ 1
16:26:14 <lambdabot>  error:
16:26:14 <lambdabot>      ‚Ä¢ Couldn't match type ‚ÄòInt‚Äô with ‚ÄòInteger‚Äô
16:26:14 <lambdabot>          arising from a use of ‚Äòeach‚Äô
16:27:03 <Solonarv> you'd need some kind of fancy higher-rank polymorphism for that to work, yeah
16:27:18 <c_wraith> hmm.  higher-rank lenses!
16:27:28 <Solonarv> sounds impredicative
16:27:33 <c_wraith> it is very impredicative
16:29:21 <koz_> Such impredicative.
16:29:37 <Solonarv> much ow
16:29:44 <koz_> Amaze?
16:30:49 <Solonarv> I don't know, we don't have it!
16:31:02 <koz_> Yeah, that's true.
18:14:25 <ProofTechnique> Oh, wow, I didn't know you could each tuples! Looks like it works up to 9-tuples, which is more than enough for anyone, if you ask me
19:01:33 <JoeJo> Morning 
19:29:35 <bingye> hi
19:33:05 <Solonarv> bingye: hello!
19:34:29 <shapr> hi bingye
19:42:22 <maerwald> is it safe to 'read' Double from untrusted sources?
19:42:26 <maerwald> Can it blow up your memory?
19:42:57 <ibloom> If you enable profiling in your cabal.project file and use cabal new-run, where does it store the profiling statistics?
19:45:41 <JoeJo> Is anyone in HangZhou
20:03:11 <glguy> maerwald: The read implementation checks for exponents that are too large before converting to rational
20:09:31 <rotaerk> hmm can I use a class constraint on an associated type
20:10:35 <rotaerk> oh nm I see an answer on SO...
20:32:53 <iqubic> Installing reflex and reflex-dom is being a pain.
20:58:07 * hackage shh 0.2.0.1 - Simple shell scripting from Haskell  https://hackage.haskell.org/package/shh-0.2.0.1 (lukec)
20:59:46 <coldpress_> test?
21:00:34 <jackdk> coldpress_ yo
21:30:37 <suzu> c_wraith: worked
21:30:50 <suzu> err i meant coldpress *
21:31:01 <suzu> rip
21:31:03 <coldpress> hmm?
21:31:03 <suzu> sorry c_wraith 
21:31:06 <c_wraith> ah, that explains why I was so confused. :)
21:31:11 <suzu> hehe
21:31:12 <coldpress> i think i missed some messages there
21:31:21 <suzu> coldpress: i was replying to your 'test?'
21:31:24 <suzu> your test worked
21:31:34 <coldpress> thanks :)
21:45:24 <dyl> luke-clifton[m]: have you seen shqq?
22:00:07 * hackage bytestring-trie 0.2.4.3 - An efficient finite map from (byte)strings to values.  https://hackage.haskell.org/package/bytestring-trie-0.2.4.3 (WrenRomano)
22:07:42 <luke-clifton[m]> dyl: yes. At the moment shh is more focused on composition (piping and redirection).
22:08:27 <luke-clifton[m]> And preventing typos, and some other tricks.
22:16:02 <begriffs> How do you declare unicode codepoint literals? Like U+00F4? Using `chr` from Data.Char?
22:19:56 <glguy> > '\xf4'
22:19:58 <lambdabot>  '\244'
22:20:34 <begriffs> Oh nice. Just tried `putStrLn [chr 0x00f4]` and that worked, but the \x thing is simpler thanks
22:21:26 <dyl> begriffs: there‚Äôs also UnicodeSyntax, which if enabled (maybe even without?) would allow you to paste the Unicode character in directly.
22:21:50 <dyl> I‚Äôm sure I‚Äôll catch flak for this, but I don‚Äôt think there‚Äôs anything wrong with using UTF8 in sources.
22:21:59 <begriffs> dyl: Ah, given that my editor saves the source file as UTF-8, I could just paste it into the string?
22:22:16 <dyl> Yes, it would understand that just fine. 
22:22:25 <dyl> You can even use emoji for function names... 
22:22:32 <dyl> But only a Sith would do something so vile.
22:22:52 * dyl ignores that he is on and off working on an APL dialect written entirely in emoji.
22:22:53 <begriffs> My case is a little weird because I'm experimenting with building a grapheme codepoint-by-codepoint to test how to normalize and compare them.
22:23:09 <dyl> Oh good luck. I would suggest you don‚Äôt try and just use ICU4C.
22:23:10 <begriffs> Is text-icu the most capable package for manipulating unicode?
22:23:23 <dyl> ICU is the de facto (and de jure) standard. 
22:23:58 <dyl> ICU = international components for Unicode 
22:24:08 <begriffs> I was doing the experiment in C first with UText in libicu, but then wanted to see how it would feel in Haskell.
22:24:28 <dyl> I don‚Äôt know about the Haskell bindings, but ICU4C is what is used in most languages with sane Unicode handling.
22:24:36 <dyl> (I don‚Äôt know if they‚Äôre up to date, I mean.) 
22:25:12 <begriffs> Looking at this package - http://hackage.haskell.org/package/text-icu   "Haskell bindings to the International Components for Unicode (ICU) libraries"
22:25:38 <begriffs> But bos made it so it's probably been abandoned for a while maybe. Maybe that doesn't matter and it just works... ?
22:26:08 <dyl> If the libicu version it requires hasn‚Äôt gone through a major version change it should be fine.
22:26:21 <dyl> Even with more codepoints, the API would remain roughly the same. 
22:26:32 <dyl> ICU is part API, part database.
22:26:46 <dyl> Lots and lots of very tedious to write and maintain tables...
22:29:10 <begriffs> Interesting, I suppose ICU does need to know properties of new characters. Well I suppose I can try installing text-icu and see if it works with libicu on my system. Just didn't know if that or another package is the standard choice for wrapping the C library.
22:31:29 <begriffs> Actually the text package itself says, "To use an extended and very rich family of functions for working with Unicode text (including normalization, regular expressions, non-standard encodings, text breaking, and locales), see the text-icu package." So that's a pretty good endorsement. :)
23:01:39 <dminuoso> JK
23:02:04 <dminuoso> Okay, perhaps I should close weechat while getting used to xmonad.
23:17:22 <ibloom> Has anyone had any luck profiling with cabal new-run?
23:17:58 <ibloom> My program runs much slower but doesn‚Äôt seem to generate profiler statistics.
23:18:31 <dminuoso> ibloom: How do you profile your program?
23:20:12 <dminuoso> It shouldn't be any more than: cabal v2-run --enable-profiling your-app -- +RTS -p -RTS ...
23:22:35 <ibloom> I‚Äôll try that
23:24:35 <ibloom> That did it.
23:26:13 <ibloom> I‚Äôd never seen that incantation before
23:26:27 <dminuoso> ibloom: What particular part of it?
23:26:35 <ibloom> v2-run
23:26:51 <dminuoso> ibloom: Oh, think of v2 as just an alias for new.
23:28:05 <dminuoso> ibloom: --enable-profiling then instructs cabal to build the package and all necessary packages with profiling instrumentation. `--` allows us to pass additional flags to the program, `+RTS ... -RTS` are just delimiters for RTS flags, and `-p` instructs the RTS to actually profile the program.
23:28:44 <ibloom> I was trying to do it via the newer cabal.project file
23:29:01 <ibloom> But I think maybe I left out the RTS instructions
23:35:27 <ibloom> looks like cabal new-run my-application -- +RTS -p -RTS
23:35:32 <ibloom> also works
23:36:00 <ibloom> After I set `profiling: True` in the cabal.project file
23:36:34 <dminuoso> ibloom: indeed, `profiling: True` in your cabal.project.local file is equivalent to passing `--enable-profiling` to cabal commands.
23:37:10 <ibloom> ok great. 
23:52:22 <maerwald> dminuoso: is it? does --enable-profiling apply to dependencies that are built?
23:56:38 <maerwald> profiling: True at top level in your cabal.project will only apply to local packages afaik
