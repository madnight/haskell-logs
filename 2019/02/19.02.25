00:09:01 <ibloom> maerwald that appears to be true.
00:13:40 <maerwald> To apply to dependencies you need: package *\n   profiling: True
00:16:02 <trcc> So I have now understood how Haskell does IO to a degree, but someone might be able to help me clarify the last bits. I see these points of the way IO is modelled, i.e. with the IO monad. This model is necessary for lazy evaluation, it is necessary for referential transparency and it shows the developer when the real world interacts with your program. But what does this referential transparency buy you particularly in context of IO? Under
00:16:02 <trcc>  execution it will be based on the something external anyways
00:16:13 <dminuoso> maerwald: Yes.
00:16:38 <dminuoso> maerwald: It's documented here https://www.haskell.org/cabal/users-guide/nix-local-build.html#cfg-flag---enable-profiling
00:17:01 <trcc> I might be hoping for an example, where the benefit of referential transparency in context of IO is good compared to IO not being referential transparent
00:17:07 <Ariakenom> trcc: You can reason about your code, and changes in your code, using it.
00:17:24 <trcc> Ariakenom: yes under evaluation, but not under execution
00:17:37 <maerwald> dminuoso: right, so they are not the same
00:17:56 <trcc> so what is the benefit? 
00:18:28 <Ariakenom> You can reason about the source code in general. Introducing side effecting functions means you can't to that in general
00:19:03 <dminuoso> maerwald: Scroll one row up, and you will see it to be the same option.
00:19:51 <maerwald> dminuoso: yes, but the scope is not the same
00:19:57 <Ariakenom> trcc: you get to express, in code, something that has no effects
00:20:24 <trcc> Ariakenom: but it does when executed, and this is what matters no?
00:20:55 <Ariakenom> I don't look at x86 when figuring out what my program does
00:21:35 <Ariakenom> or when I change it
00:21:36 <trcc> no, but readfile in haskell will give you an IO string or throw an exception, and readfile in java will give you a string or throw an exception. Why is this much different?
00:21:45 <trcc> under execution
00:22:00 <trcc> I see that the IO helps the developer quite a lot to make it obvious where something interacts with the real world
00:22:09 <nshepperd> trcc: the separation of evaluation and execution is valuable because it means you can reason about execution without worrying about evaluation
00:22:29 <dminuoso> maerwald: "cabal new-build will ensure that all of its transitive dependencies are built with profiling enabled."
00:22:43 <trcc> nshepperd: is it not opposite? reason about evaluation with worrying about execution?
00:23:02 <maerwald> dminuoso: yes, which is still not the same
00:23:06 <Gurkenglas> Is "join (zipWith (+))" subject to list fusion?
00:23:50 <maerwald> as in: --enable-profiling applies to all dependencies, but profiling: True only to local packages (and their transitive deps)
00:25:34 <Ariakenom> trcc: Why would there be a difference during execution?
00:25:59 <Ariakenom> Which is basically your last question ... But I don't understand why you asked it.
00:26:24 <trcc> Ariakenom: I just do not see the benefit of reasoning about the real world in evaluation, when you cannot under execution. And I say, that you can do the same in whatever other language.
00:26:38 <trcc> so IO might just as well not be referential transaprent
00:26:54 <trcc> What would happen if it was not? 
00:28:16 <Ariakenom> You wouldn't get referential transparency during evaluation
00:28:21 <nshepperd> well
00:28:50 <nshepperd> referential transperency is really more like something the language as a whole has?
00:29:16 <trcc> Ariakenom: yes, you would not for the parts with IO involved. But so what? It does not work under execution anyhow?
00:29:27 <Cale> It depends on what you mean by "not be referential transparent" there -- does it end up causing functions of type Integer -> Integer to be able to cause IO to occur?
00:29:29 <maerwald> nshepperd: some people argue it can also be a property of a function, which I think is possible to define
00:30:12 <trcc> Cale: that parent I understand. it is there to signal to the developer that some IO happens. But that is separate from the referential transparency property I think
00:30:14 <maerwald> then a "referentially transparent" language would be one where you can only write referentially transparent functions
00:30:27 <trcc> parent=part
00:30:52 <Cale> Also, I really think it's important that the various control structures I use behave sanely. It's still really nice to be able to rewrite IO code and make use of the monad laws for refactoring purposes.
00:31:34 <Cale> In particular, the associative law for (>>=) effectively means that you can always factor out the middle of a do-block without even needing to look very carefully at what actions it contains
00:32:06 <Cale> (you just have to be careful about what's bound and where results get used, which the compiler is going to help you with anyway)
00:32:49 <nshepperd> in practice, 'non referential transparent IO' in haskell sounds it would probably be unsafePerformIO'd everything
00:32:55 <maerwald> referential transparency has little correlation to "easy to reason about". If your whole codebase lives in IO, it is still referentially transparent, but hard to reason about
00:32:58 <nshepperd> which has lots of well known problems
00:33:26 <nshepperd> especially because of laziness
00:33:26 <maerwald> because reasoning, in the end, always includes execution, yeah
00:33:58 <Cale> I like being able to reason about various means of combination like mapM, and know that manipulating the list up-front is equivalent to performing some transformation on the elements inside the function
00:34:08 <maerwald> stuff becomes easier to reason about if you divide effects, regardless of referential transparency
00:34:24 <maerwald> IO is the opposite of that
00:35:00 <trcc> thinking for a sec
00:35:01 <Cale> i.e. mapM f (map g xs) = mapM (f . g) xs
00:35:01 <maerwald> code that does this well, even in C, is nice to read
00:35:28 <Cale> The fact that we can still write equations like this is valuable when refactoring and optimising code.
00:35:38 <Cale> and just when understanding it
00:35:52 <trcc> ah, so it is in the refactoring and optimising code perspective. That I can understand
00:35:55 <nshepperd> reasoning about execution is not some kind of impossible feat
00:36:12 <maerwald> I would say systems programmers would disagree
00:36:17 <nshepperd> it can always be worse. for instance by using unsafePerformIO everywhere
00:36:28 <maerwald> yeah
00:36:32 <Cale> You can use RULES pragmas to automate that kind of thing (and the libraries do, to a fair extent)
00:36:48 <nshepperd> having IO be referentially transparent, prevents that aspect of worseness
00:37:10 <Cale> Without purity at the level of combining IO actions together, you wouldn't get many of those laws which allow for elimination of intermediate lists like that
00:37:43 <trcc> Cale: your examples is very interesting and I am trying to understand what it brings to the table.. 
00:40:24 <trcc> but what does this give you? Can you possibly realise it in an example?
00:40:26 <Cale> trcc: Also, when you start applying monad transformers, any little break in the monad laws tends to turn into a mess pretty quickly -- I don't know how to give a brief example, but failing one of the unit laws for instance, turns into bugs really quickly. So it's really important to be able to reason equationally and get things right.
00:40:34 <trcc> ok
00:40:38 <Cale> trcc: Well, the little example I gave above
00:40:47 <Cale> mapM f (map g xs) = mapM (f . g) xs
00:41:08 <Cale> this eliminates the construction of an intermediate list (which is immediately becoming garbage)
00:41:14 <trcc> ah
00:41:36 <sicklorkin> Cale: that's not optimzied out?
00:41:39 <Cale> and since we know this to be true, it's a transformation which we can give to the compiler to perform
00:41:47 <trcc> and this would not be possible if IO was executed directly in the program?
00:41:50 <merijn> sicklorkin: Yes, no, maybe, it depends :)
00:41:56 <Cale> It wouldn't be optimised out unless we told the compiler about it
00:42:16 <Ariakenom> trcc: can you give code for what you mean by not referentially transparent IO?
00:42:23 <sicklorkin> Cale: I thoguht deforestation took care of that.. oh man
00:42:35 <Cale> sicklorkin: It does, but what do you think deforestation consists of?
00:42:52 <sicklorkin> Cale: crystal balls
00:42:55 <Cale> sicklorkin: It's not applied automatically to every type -- it's a bunch of ad-hoc rules in the libraries
00:43:13 <Ariakenom> fsvo ad-hoc
00:43:21 <trcc> Ariakenom: well getchar in C 
00:43:24 <Cale> yeah, I mean, they're equational rules, that's pretty nice
00:43:27 <trcc> it is not referential transparent
00:43:36 <sicklorkin> Cale: I just assumed it was free to be verbose with continuations of maps.. 
00:43:41 <Ariakenom> getChar :: () -> Char
00:45:13 <trcc> Cale: you could do the same with IO not being referential transparent. 
00:45:34 <trcc> at least in that example
00:45:35 <Cale> trcc: But even just thinking about what the program means if IO is allowed to happen anywhere gets really strange
00:45:52 <Cale> trcc: Suppose g has effects, and we write the program like mapM f (map g xs)
00:46:01 <Cale> (in weird, broken Haskell)
00:46:05 <Ariakenom> trcc: that changes the order of execution of the functions (well if strict)
00:46:05 <trcc> ye
00:46:49 <Cale> If the evaluation happens strictly, then all the effects from g being applied to each element happen before any of the effects described by the results of applying f
00:47:10 <Cale> If it happens lazily, then perhaps you get a bit of g, then a bit of f, interleaved
00:47:38 <Cale> The compiler should be free to decide which order things get evaluated in, so long as it doesn't affect the termination behaviour of the program
00:48:03 <Cale> But if there are effects randomly firing off when things are evaluated, it screws that up
00:48:42 <trcc> so referential transparency is required in order to achieve lazyness
00:48:46 <Cale> GHC does *not* only do lazy evaluation, it strictifies a lot of things
00:48:53 <Cale> yes, well, practically so
00:49:01 <trcc> that part I understand
00:49:16 <Cale> If you only do lazy evaluation, very consistently, then it might be almost manageable
00:49:19 <Cale> (if bizarre)
00:49:43 <sicklorkin> trcc: do you understand laziness? https://www.parsonsmatt.org/2018/12/04/laziness_quiz.html
00:49:47 <Cale> But you're shooting yourself in the foot optimisation-wise then, because the compiler can't rearrange things to be stricter when it sees that the result will be consumed
00:50:49 <Cale> Basically, there are really a whole bunch of good reasons to encode effects as values of another type, and not many reasons not to do it.
00:50:54 <trcc> sicklorkin: I think I do. and I can see why the way IO is modelled in necessary for lazyness
00:50:57 <trcc> laziness
00:51:30 <trcc> so the benefit of the modelling of IO is: Signal interaction with the real world state to the developer. 
00:51:31 <trcc> sorry
00:51:33 <trcc> more to come
00:51:33 <nshepperd> it's necessary both for laziness and for other optimisations like common subexpression elimination
00:51:41 <merijn> trcc: Honestly, I think the way IO is done now is one of the major breakthrough, that in hindsight is a great idea for non-lazy languages too
00:51:59 <nshepperd> not just done by the compiler, but also by humans
00:52:04 <Cale> Yeah, once you're used to this, you'll want it for strict functional languages as well
00:52:16 <merijn> Cale: For any language :p
00:52:28 <Cale> well, you'll probably also want all your languages to be functional ;)
00:52:45 <merijn> I started designing a typed Python with IO at some point, although I stopped when I realised I was basically just designing Haskell with slightly different syntax :p
00:53:15 <Cale> trcc: Here's another reason -- are you aware of STM?
00:54:10 <nshepperd> ie. with ref-transparent IO, you can lift a common action to a let binding without worrying that you're breaking something
00:54:12 <Ariakenom> haskell with slightly different syntax sounds great. ofc haskell is better, but that's true for all languages :p
00:54:13 <Cale> We have a monad for software transactional memory, and it allows you to describe computations which are allowed to have effects, but only memory effects that can be rolled back if needed.
00:54:25 <trcc> so the benefit of the modelling of IO is: 1. Signal interaction with the real world state to the developer; 2. required for laziness; 3. to reason about your code in context of refactorings/optimisation - i.e. same meaning before an after. I find 2 a bit weak.
00:54:45 <trcc> Cale: I will look it up
00:54:46 <nshepperd> what! laziness is awesome
00:54:53 <Cale> I'll give you a paper
00:54:56 <trcc> thank you
00:55:31 <Cale> https://simonmar.github.io/bib/papers/stm.pdf
00:55:35 <trcc> nshepperd: could you, although I know it is a lot to request, give an example of why subexpression elimination is better with referential transparent IO that without?
00:55:36 <Ariakenom> trcc: I'm not sure if this was clear. you need IO for referential transparency of non-IO expressions too. otherwise a getchar :: () -> Char could sneak anywhere
00:55:51 <trcc> Ariakenom: you could probably do some other way of signaling no?
00:56:05 <merijn> Anyone got a good name for a sequence of Bits that *doesn't* clash with the 'Bits' typeclass?
00:56:35 <Cale> That paper will make it quite clear why it's very important to keep irreversible IO actions out of STM actions, which is quite similar to keeping them out of the construction of IO actions.
00:57:07 <Ariakenom> trcc: at that point you need a suggestion :p
00:57:10 <Cale> (basically, because we're going to be optimistically trying transactions and will need to roll them back and retry them, but missiles can only be launched once)
00:57:51 <Cale> If we couldn't do it for IO, it's unlikely we could do it for STM
00:57:56 <Cale> and it's important to do it for STM
00:58:03 <nshepperd> trcc: print(getchar(), getchar()) is different from let a = getchar() in print(a,a)
00:58:32 <nshepperd> trcc: common subexpression elimination is just invalid if you're not referentially transparent
00:59:22 <Cale> trcc: Once you come to wanting to restrict more finely what sorts of effects different parts of your program may have, it's important that the bare combinators you have for fitting the programs together don't themselves have any effects.
00:59:44 <Cale> (or at least, have minimal ones -- it turns out that they can typically have none)
00:59:53 <trcc> nshepperd: yes, it is different, but why does it matter under execution? Same thing will happen. What does this difference buy you?
01:00:05 <nshepperd> trcc: no, different thing will happen
01:00:11 <trcc> ah yes
01:00:13 <trcc> you get one char
01:00:15 <trcc> and repeat it
01:00:17 <trcc> in haskell
01:00:23 <trcc> whereas in C you get two 2 chars
01:00:31 <Cale> Well, in one program vs. the other
01:00:38 <nshepperd> trcc: in something like C, print(getchar(), getchar()) prints two different chars;  let a = getchar() in print(a,a)  prints the same char twice
01:00:40 <Cale> Neither of those was Haskell
01:00:53 <Cale> In Haskell, you're forced to be explicit about what gets executed.
01:00:58 <nshepperd> yes, these are both pseudo-C
01:01:50 <trcc> I do not see why this example shows the benefit of IO in haskell vs what this does in C
01:01:55 <Cale> do a <- getChar; print (a,a)  vs.  do a <- getChar; b <- getChar; print (a,b)
01:02:08 <Cale> It forces clarity of effects and order
01:02:46 <Cale> On occasion, I've sorted out bugs or otherwise understood the operation of C code by translating it into Haskell.
01:02:52 <Cale> (by hand)
01:03:33 <Cale> The fact that you're forced to be explicit about execution order is helpful (while evaluation order places no such demand)
01:03:36 <nshepperd> Haskell: 'do {a <- getChar; b <- getChar; print (a,b)}' -> 'let g = getChar in do { a <- g; b <- g; print (a,b) }' is perfectly valid
01:03:50 <Cale> Oh, yes, that too!
01:04:00 <nshepperd> eliminated the subexpression 'getChar' without changing the semantics
01:04:23 <Cale> The fact that we can reason about this kind of difference is key to writing higher order control structures that make any sense
01:04:32 <trcc> nshepperd: and this would not be possible if getChar was strict and not lazy
01:04:48 <Cale> If evaluation accidentally caused IO actions to occur too early, it would really suck
01:04:57 <trcc> so the main benefit of IO being referential transparent is in context of laziness?
01:05:02 <nshepperd> nothing to do with strictness and laziness
01:05:04 <Cale> This isn't so much about strict vs. lazy now
01:05:07 <trcc> hmm let me think again then
01:05:16 <Cale> It's about "did I execute this, or only refer to it?"
01:05:18 <merijn> trcc: I disagree, the main benefit is being able to treat "IO" as a first class value
01:05:59 <Cale> trcc: We want to be able to treat IO actions as first class values -- like program files that we can pass around and only execute when they're really needed.
01:06:16 <maerwald> that can be done in other languages too
01:06:34 <trcc> yes, i.e. making every IO action in C a function pointer instead
01:06:34 <maerwald> that's just a closure you don't execute immediately
01:06:45 <Cale> Sure
01:06:58 <maerwald> so not a huge benefit imo
01:07:00 <nshepperd> the equivalent of treating IO actions as first class values in C is writing '&getChar' instead, and that will make you gouge out your eyes
01:07:07 <slack1256> Nobody actually write those closures to be honest, too burdersome
01:07:31 <tdammers> the "closure" part is mostly irrelevant; even an anonymous procedure that doesn't close over anything exposes the same benefits
01:07:45 <tdammers> unless you take a liberal stance on the meaning of "close over"
01:08:03 <trcc> but being ablke to treat IO actions as first class values is "similar" to using &getChar in C. But if you used &getChar in C, then you made C referential transparent in this case. 
01:08:13 <tdammers> (or the equally liberal stance that "closure" includes things that close over zero variables)
01:08:20 <nshepperd> and nobody actually writes C or C++ by chaining delayed execution closures, so that's not really a compelling argument
01:08:21 <maerwald> trcc: not so easy :P
01:08:24 <merijn> trcc: Except in C you can't do that with arbitrary closures
01:08:35 <trcc> merijn: could you expand a bit?
01:08:52 <nshepperd> you can transpile haskell in C++ but that doesn't turn C++ into haskell
01:08:52 <Cale> trcc: Sort of, except that the surrounding code may still be full of effects, so it can be difficult to untangle when everything is occurring
01:09:05 <Cale> and the types tell you nothing
01:09:06 <merijn> trcc: "getChar" is easy, how do you make it work with fprintf?
01:10:02 <maerwald> nshepperd: well, then take python
01:10:18 <trcc> merijn: make a wrapper function perhaps
01:10:37 <trcc> then do &wrapperFunc and pass that around
01:10:48 <tdammers> trcc: what if you need to parametrize the wrapper function?
01:10:52 <tdammers> then things get awkward fast
01:11:01 <nshepperd> really, "you can contort your code so that in some situations this can be done" isn't really point
01:11:02 <Cale> (well, that's a bit of a lie, the types in C do tell you a little bit -- you can tell the difference between a function pointer and its result at the type level)
01:11:24 <Cale> But the types don't tell you much about when the effects are occurring or not
01:11:33 <trcc> nshepperd: valid point
01:11:35 <Cale> :t mapM
01:11:36 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
01:11:48 <Cale> okay, so that type is a little more general than I need it to be
01:11:49 <nshepperd> because of referential transparency, in haskell it is _always_ the case that you can take an expression and move it into a let
01:11:51 <Cale> but let's just go with
01:12:04 <nshepperd> (except when you deliberately use unsafePerformIO to subvert the system)
01:12:08 <Cale> (Monad m) => (a -> m b) -> [a] -> m [b]
01:12:15 <Cale> ^^ I know this doesn't perform IO
01:12:46 <Cale> But I can use it to combine my IO actions, and know that it's not sneakily taking the values in my list and sending them somewhere over the network
01:12:51 <tdammers> I'd say if you took C, but extended it with 1) a type system that can capture and enforce effects and their absence at the type level, 2) anonymous procedures, 3) partial application, 4) proper closures; then you could easily implement the equivalent of Haskell's IO type in C - but such a C would be quite similar to Haskell already
01:13:04 <Cale> (it can't even actually do anything with the values in the list, short of applying the given function to them)
01:13:23 <tdammers> (ignoring typeclass abstractions and such, which I believe are orthogonal to the whole IO issue)
01:13:38 <trcc> nshepperd: so that is the seperation of description of effects and execution of efefcts sort of
01:15:43 <nshepperd> sure
01:19:10 <trcc> okay... So I am starting to see that the fact that IO is referential transparent buys you a lot of composeability, optimisation/change potential and similar. And that you could make IO referential transparent in other languages, and then get the same benefits (a bit rough, but should work). So it is actually also the referential transparency, that gives you the seperation of effects and execution
01:19:56 <tdammers> trcc: I'd say it's the other way around - it's the separation of effects and evaluation that gives you referentially transparent evaluation
01:21:16 <trcc> tdammers: hehe yes. The problem that needed solving in the first place was probably that you need to separate effects and execution, and referential transparency was the solution. 
01:21:20 <Cale> Even if we want to write programs which do anything that computers can do, we want to at least ensure that evaluation of expressions carries no side effects and is deterministic (as much as possible)
01:21:35 <tdammers> in a way, it's like you write your entire code in a (pure) meta-language; then you evaluate the `main` expression in the metalanguage, and that yields a value that happens to be a valid program in the actual language (which is impure / effectful)
01:22:01 <trcc> Cale: yes I see that argument for anything else than IO stuff. In IO, it is not deterministic, because the real world can do whatever
01:22:27 <Cale> trcc: Of course, there's not much distinction -- IO can just be a data type
01:22:45 <merijn> trcc: Are you familiar with the "compromiseless reconciliation of IO and purity" blog post?
01:22:48 <Cale> If it helps, you can imagine that IO looks something like:
01:23:15 <trcc> merijn: no. I have come across more than 20 blog posts and other stuff the last week in my quest of understand this propler,y but not these I think
01:23:26 <Cale> data IO a = Done a | GetChar (Char -> IO a) | PutChar Char (IO a) | ... other effects ...
01:24:11 <merijn> trcc: The problem with blog posts is that...quality varies ;)
01:24:24 <merijn> trcc: Anyway, I think jle has two very good ones on IO and purity: https://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity.html
01:24:24 <Cale> Where all the effects that can be performed are just represented syntactically, and some part of the runtime system is munching on the IO value you called main, evaluating it, and carrying out the steps described
01:24:27 <trcc>   merijn hehe yes definitely
01:24:31 <trcc> I will read it immediately
01:24:40 <merijn> trcc: That one and this one: https://blog.jle.im/entry/io-monad-considered-harmful.html
01:25:14 <trcc> merijn: that would I have read many times. But between every read I have expanded my knwoeldge, so I get something new every time heh
01:25:20 <trcc> would=one
01:25:34 <trcc> Cale: ye
01:25:52 <Cale> trcc: Of course, GHC just cheats and uses impure functions under the covers in order to avoid having to rewrite a bunch of dependency analysis and optimisation stuff
01:25:59 <trcc> hehe yes of coruse
01:26:10 <Cale> But as a mental model, that's not so helpful
01:26:33 <trcc> well I think I have come to a big thank you to all of you. Really helped. Amazing to have some place to get input as you climb the ladder
01:35:06 <merijn> Anyway, back to my bikeshed question: What's a good name for a sequence of bits that is not "Bits" (since that collides with the typeclass...)
01:35:54 <Taneb> BitSequence? BitSeq?
01:36:02 <Taneb> BitString?
01:39:48 <merijn> RealBits ;)
01:40:17 <Ariakenom> eighthByte
01:40:19 <merijn> BitString sounds dangerously close to ByteString :\
01:40:48 <Taneb> merijn: what is a bytestring if not a sequence of bytes?
01:40:51 <Ariakenom> Bits2
01:41:09 <merijn> Taneb: A historical misnomes :p
01:41:16 <merijn> Ariakenom: Bitss >.>
01:41:28 <Ariakenom> Bits'
01:43:30 <Taneb> merijn: I was making a deliberate comparison
01:46:50 <tdammers> MySqlRealEscapeBits
01:53:40 <nshepperd> SomeBits
01:53:49 <nshepperd> BitSoup
01:54:05 <nshepperd> BitList
01:55:50 <merijn> Galaxy brain: "[Bit]"
01:56:35 <nshepperd> Bite
01:58:48 <nshepperd> 1: Bit 4: Nibble 8: Byte -> many: Chomp?
01:59:02 <tdammers> Integer
01:59:10 * tdammers runs away
01:59:50 <merijn> tdammers: tbh, it's just a newtype around Unboxed.Vector Bit :p
02:02:15 <nshepperd> a variable number of bites is a meal
02:04:44 <__monty__> CheckOutMyBits
02:10:42 <merijn> Does DeriveAnyClass warn if there's no suitable complete default implementation?
02:12:09 <slack1256> the network package deprecated the `ntohl` function in favor of getAddrInfo
02:12:19 <slack1256> I don't see how that is in anyway equivalent
02:12:35 <merijn> slack1256: What are/were you using ntohl for?
02:13:13 <slack1256> For its stated purpose, change a Word32 from network byte order to "host byte order"
02:13:41 <slack1256> What host byte order is depends on the architecture, so currently I am assuming everywhere this will run is little endian
02:13:51 <merijn> slack1256: Why do you need that conversion? Because this almost certainly impliess you're getting your original Word32 the wrong way
02:14:05 <slack1256> nah
02:14:12 <merijn> slack1256: like, are you getting the Word32 from file/network/etc.?
02:14:29 <slack1256> I am getting it for the DCC protocol for IRC, which is specified that way
02:15:10 <merijn> slack1256: Right, so you're getting it from a network protocol. You should use a proper library to just directly parse it as a host Word32
02:15:34 <merijn> slack1256: For example, binary (the package for parsing binary protocols/files) comes with proper conversion parsers for Word32 and co
02:15:35 <slack1256> that proper library was network
02:16:09 <merijn> network is newtorking library, not a parsing library
02:16:13 <merijn> You want, e.g. https://hackage.haskell.org/package/binary-0.8.6.0/docs/Data-Binary-Get.html#v:getWord32be
02:16:34 <slack1256> In fact the recognize that and offer the `hostAddressToTuple` function
02:16:43 <slack1256> which can be used to implement ntohl
02:20:33 <merijn> Data.List doesn't have a function to "chunk" lists, right?
02:20:43 <merijn> @hoogle Int -> [a] -> [[a]]
02:20:43 <lambdabot> Data.List.Split chunksOf :: Int -> [e] -> [[e]]
02:20:43 <lambdabot> Data.List.Split.Internals chunksOf :: Int -> [e] -> [[e]]
02:20:43 <lambdabot> Data.List.HT sliceHorizontal :: Int -> [a] -> [[a]]
02:32:55 <trcc> merijn: https://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity.html this one was really good
02:33:14 <trcc> the other - io monad considered harmful was more - it is fine.
02:33:49 <tdammers> the "considered harmful" one has less explanatory value for newcomers, I think it's more aimed at experienced haskellers trying to explain things to newcomers
02:33:56 <tdammers> or writing one of those infamous "Monad Tutorials"
02:33:59 <trcc> tdammers: yes definitely
02:34:59 <merijn> The considered harmful one is useful, because I think that *especially* for beginners it can be helpful to be really pedantic about naming to keep distinctions clear. Whereas the compromise one is more about actually explaining something
02:35:34 <trcc> merijn: Yes. And, in my own journey, I found it really annoying to be introduced to IO so late, becaause I need to know of bla bla bla first
02:36:40 <trcc> It is fine, if you want to learn the language from scratch. But if you just want to get into using it, not so much. I.e. learn you a haskell for great good, which I started with. You have to get to chapter 9 before input output
02:36:49 <merijn> trcc: There's two strategies: 1) introduce IO immediately with lots of handwaving or 2) introduce it really late after the prerequisites and have no handwaving. Both have pros/cons and it depends on the audience
02:36:59 <trcc> agreed
02:37:15 <tdammers> it is definitely useful in reassuring you that what you may already be suspecting, namely, that "Monad" and "being able to model real-world interactions" are orthogonal aspects of the IO type
02:37:27 <merijn> I tend to prefer number 2, but it doesn't work for everyone and I don't know what a good approach is for people who prefer category 1 :)
02:38:02 <tdammers> merijn: you can still keep the handwaiving minimal, and explicitly state it as such, if you pick approach 1. But many introductory materials don't even do that.
02:38:44 <tdammers> e.g., you could say something like "we will provide a more robust explanation for these things later; for now, assume that..."
02:38:48 <trcc> tdammers: definitely. However, the IO Monad is the first introduction to the word Monad
02:38:57 <tdammers> trcc: it shouldn't e.
02:38:59 <tdammers> *be
02:39:25 <trcc> Now, I agree
02:39:31 * Unhammer wants a Show instance that only works in the repl
02:39:35 <tdammers> even if you introduce >>= and do notation and all that for IO early in the process, you shouldn't be using the word "Monad" yet
02:40:00 <tdammers> or maybe use it as part of the "we will explain these things properly later" part
02:40:16 <tdammers> but definitely don't say "the IO Monad", because that doesn't even make much sense in the first place
02:40:42 <tdammers> fwiw, I haven't heard that phrase much in recent times
02:41:11 <tdammers> I get the impression that we have a new generation of Haskell teaching materials and teachers, that are more diligent about naming
02:43:15 <trcc> I was wondering about something related to IO, i.e. the fact that readFIle has the type FilePath -> IO String. There is no telling, that it might throw an exception
02:43:57 <merijn> trcc: Sadly, you're right
02:45:16 <trcc> this seems like an obvious enhancement to the type system, any reason for it sticking around?
02:45:44 <maerwald> what enhancement?
02:45:55 <merijn> trcc: It's not necessarily simple to add. I have Opinions (TM) on this. I want checked, but inferred exceptions
02:46:06 <merijn> trcc: Sadly, so far no one has offered to pay me to work on that :p
02:46:25 <Taneb> trcc: asynchronous exceptions are a thing that gets in the way, anything can raise any exception at any time if you've got another thread throwing them at you
02:46:49 <maerwald> how does rust solve it then?
02:46:57 <merijn> maerwald: Does Rust have async exceptions?
02:47:07 <maerwald> they have no exceptions afaik
02:47:09 <maerwald> just panics
02:47:25 <Taneb> You can't catch a panic, iirc
02:47:37 <trcc> okay thank you
02:47:55 <trcc> what do you guys do? Use a "safeFileRead" that models it with Either or?
02:48:11 <maerwald> that's not any safer
02:48:15 <merijn> trcc: So, in short, a lot of people agree with you, but adding something like this is non-trivial and finding someone to fund it is tricky
02:48:31 <trcc> yes i can understand
02:48:36 <tdammers> maerwald: it's "safer" in the sense that it becomes visible at the type level (and it only works with strict IO)
02:48:43 <maerwald> trcc: I document all exceptions and test them, that's all you can reasonably do
02:48:46 <Taneb> (here's some relevant Rust docs: https://doc.rust-lang.org/nomicon/unwinding.html )
02:48:53 <trcc> ok
02:48:54 <maerwald> tdammers: and it may still leak unknown exceptions
02:49:00 <merijn> trcc: Generally I use Either/Maybe in APIs with checkable errors and exceptions inside executables where I don't really handle things until my top level loop
02:49:01 <maerwald> you simply cannot trust it
02:49:04 <tdammers> maerwald: you can in theory catch SomeException
02:49:13 <tdammers> maerwald: though the type still doesn't tell
02:49:21 <maerwald> Yes, so I cannot trust the type
02:49:24 <tdammers> so yeah, you cannot trust it blindly from the outside
02:49:26 <maerwald> You still have to read the implementation
02:49:37 <merijn> It's safer in the sense that it rules out "library specific exceptions"
02:50:02 <tdammers> it still doesn't technically rule anything out
02:50:06 <maerwald> It's as safe as a C function, because I have to trust the programmer has not done any mistake :)
02:50:12 <tdammers> it just helps a bit with reasoning about certain exceptions, by convention
02:50:13 <Grumpus> I'm imagining that I want Compose (Writer e) (Validation e) so that I can write validation errors to the Writer if I'm using fallbacks in validators, say turning a failure into a Nothing to overcome inconsistent input data.
02:50:23 <Grumpus> Is there something wrong with this thinking?
02:50:57 <tdammers> you can easily have exceptions thrown from non-IO ("pure") code as well, so in fact, nothing you ever do is going to help. technically speaking.
02:53:09 <maerwald> tdammers: though, I have never encountered that, but I have encountered poorly documented IO code that throws this or that, sometimes with sometimes without funny Either types
02:53:52 <tdammers> yes, but I think in the case of IO, throwing exceptions for things like trying to read from files that don't exist is an unfortunate design decision
02:54:16 <tdammers> because due to the concurrent nature of filesystem access, it's the only way to reliably check whether the file you want to read from exists
02:54:36 <tdammers> so that's one of the situation where I would explicitly catch exceptions at the nuts-and-bolts level
02:55:27 <tdammers> otherwise, I prefer having exceptions bubble up and crash the entire process, or, in a more complex program, define process-like computations that will crash individually (but still treating exceptions as panics within the scope of each)
02:56:04 <tdammers> an example of that would be an HTTP web server, where each request handler is such a scope, and any exception thrown within it would be caught at the outermost level and turned into an HTTP 500 response
02:57:49 <Ariakenom> trcc: you can consider IO itself to mark that it can fail. like Maybe.
02:58:25 <maerwald> I find IO (Either a b) useless. If you deal with IO code, you already have to understand all possible exceptions properly. It gives a false sense of "hey, I handled the most well known for you already... or not... depends..."
02:58:37 * hackage rigel-viz 0.2.0.0 - A mid-level wrapper for vega-lite  https://hackage.haskell.org/package/rigel-viz-0.2.0.0 (ocramz)
02:59:42 <maerwald> So either move to a rust model with zero exceptions, or move to a proper exception system ala Java, maybe outside of the type system.
03:00:06 <tdammers> no, you don't have to understand all the exceptions individually. most of the time, it is enough to understand that exceptions can occur.
03:00:29 <tdammers> and you can still have the Rust model, simply by never catching any exceptions
03:00:49 <tdammers> then any exception becomes effectively a panic, crashing the process and dumping the exception.
03:02:33 <tdammers> a proper exception system like Java's would be nice, under the condition that exception inference would be a must-have (because otherwise you're going to clutter the entire call chain with explicit exception annotations, which is absolutely not what you want, because most of the time, you do want to treat exceptions as opaque panics; the exception annotations are only interesting on the extreme ends of the
03:02:35 <tdammers> chain: where you throw them, and where you handle them)
03:03:10 <tdammers> and then if you think things through, why stop at exceptions; ultimately, what you'd want is a full-blown fine-grained yet convenient effects system
03:03:27 <tdammers> but we've been biting our teeth on that one for like a decade now, without convincing enough results
03:04:47 <maerwald> because people want everything on type level, imo
03:06:57 <tdammers> at the type level, there is no fundamental difference between modeling "this action may throw exceptions of type X" and "this action may have effects of type X"
03:07:26 <tdammers> if you're going to have an exception system, you might as well generalize it to arbitrary effects, because the type-level mechanisms are the same
03:08:05 <maerwald> yes, but imagine changing effects doesn't change your type API. I think it can and should be more flexible
03:08:16 <phadej> row-polymorphism would give you some "exception inference", but I don't see it used e.g. in PureScrpt
03:08:26 <phadej> so not sure if it's that practical then
03:08:57 <tdammers> I think the problem is quite a practical one - our type-level language isn't nice enough to express the stuff we want in a concise, convenient manner
03:09:33 <tdammers> and IMO even the extensible records that we have in PureScript aren't good enough
03:09:52 <tdammers> at least I found using PureScript's Eff system rather unpleasant
03:10:19 <phadej> extensible records is a subset of row polymorphism, but I agree
03:11:06 <phadej> though, I haven't used PureScript for "big" stuff, so it hard to extrapolate any experiences
03:12:13 <tdammers> one thing I ran into repeatedly in PureScript is when you introduce your own effects; the problem then is that it's often impossible to relate effects at the type level that are actually related in the thing they model
03:12:39 <tdammers> for example, I wrote (incomplete) bindings to Leaflet.js, and for that, I introduced a custom Leaflet effect
03:13:11 <tdammers> all fine and dandy, but now I cannot express Leaflet in terms of any other effect, and anything that may or may not wish to have a Leaflet.js map anywhere must now declare the Leaflet effect
03:13:37 <tdammers> so just one widget in one remote corner of the application now has the potential of poisoning everything with that Leaflet effect
03:14:32 <tdammers> which makes it kind of useless, because when everything declares the Leaflet effect whether it actually needs it or not in practice, then declaring Leaflet doesn't really tell you anything anymore
03:14:42 <tdammers> ("if everything has priority, then nothing has")
03:16:32 <tdammers> in the end, what I actually wanted to express was that the Leaflet component would manipulate the DOM, capture input events, and issue network requests; but the PureScript ecosystem has no canonical API for those things, and thus no canonical effects to declare these as
03:17:18 <phadej> I think architecturally, we shouldn't have "leaflet" like feature "capability", and lower-level "algebraic-or-close-to" effects
03:20:22 <tdammers> PureScript's system is also unsatisfying in that it doesn't model effect sources, that is, effects appear out of nowhere, somehow. That's actually a nice thing about monad stacks: you have some `runFoobar` function that expresses the FoobarT "effect" in terms of the underlying stack
03:20:58 <tdammers> what I'm missing though is a way to go in the other direction, *restricting* IO down to a subset of IO operations
03:21:41 <tdammers> like being able to say "this action may touch IORefs, but it will not touch the filesystem"
03:22:08 <phadej> isn't Eff tried to solve precisely that?
03:22:57 <tdammers> yes, but IMO it fails
03:23:21 <tdammers> but this may not be due to the Eff approach per se, but due to the lack of a "mother of all effect" type like IO
03:23:46 <tdammers> and maybe also due to the lack of type-level set arithmetic
03:24:30 <phadej> yes, row-polymorphism can be done in various ways, and purescript's is only a way, hard to say what the way should be
03:25:24 <tdammers> one particularly annoying problem is that when you say "for any given set of effects e, this action has effect Foobar as well as all effects in e", then e must not already contain Foobar
03:26:15 <slack1256> maybe taking some equivalence classes can help?
03:26:49 <phadej> tdammers: in PureScript the { r | q } is not disjoint
03:29:10 <tdammers> it's not so bad if you write all the code yourself; then when you run into such a conflict, you just change your types to make it compile. but it does make using and authoring libraries much harder than it should be
03:30:18 <tdammers> although, again, I suspect that the most pressing problem is that there is no canonical set of "root" effects, which would allow expressing all other effects in terms of those
03:31:52 <tdammers> (whereas in Haskell, the "problem" is that our canonical set of root effects is a singleton set)
03:48:20 <gentauro> 12:20 < tdammers> what I'm missing though is a way to go in the other direction, *restricting* IO down to a subset of IO operations
03:48:25 <gentauro> 12:21 < tdammers> like being able to say "this action may touch IORefs, but it will not touch the filesystem"
03:48:34 <gentauro> tdammers: dude, do you even `uniprocess.org`?
03:48:36 <gentauro> :|
03:51:30 <trcc> thanks
03:51:38 <gentauro> I have been baffling about this for the last 2 years !!! (slides 30 - 34) -> http://blog.stermon.com/assets/talks/2018-11-18_Uniprocess_developing_applications_that_comply_with_the_EU_GDPR_by_technical_means.pdf
03:52:14 <slack1256> I feel that link is the final statements on a conversation I didn't know was happening
03:53:04 <trcc> nice gentauro
03:53:11 <gentauro> trcc: thx :)
03:54:20 <gentauro>  slack1256: neither did I, but I just looked over the last comments and I thought, hmmm, I recognize those statements ...
03:55:15 <gentauro> trcc: I made a snippet long time ago, where I show it in a very basic example -> http://blog.stermon.com/articles/2018/06/26/haskell-restricted-and-rec-granulated-io-effects.html
03:56:19 <byorgey> the person who made those slides and uniprocess.org (presumably the same person) really *likes* to *emphasize* every other *word*
03:56:41 <slack1256> well, he needs to sell the idea
03:57:00 <slack1256> idk if we need the concept of uniprocess, I got to read more
03:57:07 <gentauro> I spoke with prof Alejandro Russo from Chalmers University and he said that my approach is based on the "principle of least privilege" (enforced at compile time) -> https://en.wikipedia.org/wiki/Principle_of_least_privilege
03:57:24 <gentauro> byorgey: that person would be me :P
03:58:15 <gentauro> byorgey: If you don't make slides diff in some way, people fall asleep (and I will not use animations, that's a no-go)
03:58:35 <phadej> gentauro: isn't GDPR stuff is more of https://en.wikipedia.org/wiki/Information_flow_(information_theory)#Information_flow_control area?
03:59:05 <gentauro> phadej: that's Alejandro Russos approach (his mac-lib)
03:59:22 <gentauro> but I beg to differ ...
04:00:12 <gentauro> and I might be able to convince lawyers about it ;) -> https://synchlaw.se/da/daniel-kiil-er-oplaegsholder-til-goto-nights-cph-om-legal-tech-data-protection-ai-and-compliance-by-technical-means/
04:00:54 <gentauro> I just need my lawyers to "design" the effects, then we will take care of the rest ;)
04:00:55 <slack1256> So uniprocess is a set of effects at the base of a trusted (web) system?
04:01:13 <phadej> gentauro: a hint, i tried to your slides, but you spend the "beginning" to describe GDPR, and honestly, I find it hard to find what's your approach is
04:01:33 <phadej> tried to read*
04:01:35 <gentauro> slide 31 (design effects without "coding")
04:02:00 <phadej> too late. restructure it for better impact
04:02:04 <gentauro> phadej: come to CPH in March and I will give a talk on those slides
04:02:39 <gentauro> phadej: hehehe, you might think those slides are aimed to people here? I don't think you understand what I'm trying to achieve :P
04:03:13 <phadej> I tried to help.
04:03:47 <gentauro> phadej: thx. Really appriciate your 3 minutes read of my slides :P
04:06:29 <gentauro> phadej: https://www.linkedin.com/feed/update/urn:li:activity:6501434610818314240/ -> "Note: Since I gave a similar talk in Madrid, I had the opportunity to speak with a few legal experts. Have that in mind as my talk is aimed for: software architects, project managers, legal experts, business people and, of course, developers." :P
04:06:41 <slack1256> Wait, on uniprocess.org it's stated that ghc is deterministic
04:06:53 <slack1256> I thought that wasn't true (nixos has problems because of this)
04:06:54 <phadej> gentauro: well, those are people
04:07:00 <tdammers> gentauro: never heard of uniprocess, or maybe I have - but it sounds like it's a bit more domain-specific than a general-purpose effects system baked into a general-purpose programming language
04:07:32 <gentauro> phadej: are you claiming that lawyers are people? :o
04:07:53 <gentauro> you obviously haven't done any business with them :P
04:10:09 <phadej> gentauro: four groups your mentioned are probably aware enough of GDPR that you don't need to spend fifth of your slide (and time?) estate on that
04:10:31 <gentauro> tdammers: my approach was actually based on PureScripts way of limiting effects as you described. I just wanted it be to recursive
04:10:42 <phadej> but rather you should tell them up front what you are proposing, and then spend rest of the talk why it's important, how it works etc
04:11:16 <tdammers> gentauro: yes. I believe purescript's approach isn't fundamentally flawed, it just lacks better composability, a better type-level language, better primitives, and better "batteries"
04:12:16 <gentauro> phadej: I'm not a lawyer, but I show understanding of their domain if I'm able to explain what GDPR is in a few slides (I got nice feedback from Spanish lawyers). I been a IT-consultant for many years. If you tell the "customer" how their stuff works first time they meet you, you are always welcome to come back ;) (this tip is for free, next I will invoice you :P)
04:13:10 <tdammers> phadej: interesting observation as a German immigrant in the Netherlands is that there are two fundamentally incompatible discourse cultures. The German culture starts with the facts, and then proceeds through a series of arguments to arrive at a conclusion; the Dutch culture starts with an opinion, and then proceeds to explain its merits and rationale
04:13:19 <gentauro> tdammers: I'm guessing the code I'm doing, could easily be replaced with some `syntactic sugar` like: `granulated :: IO [ ConsoleCmd, SpecificWebsite "url", ... ] and so
04:13:41 <phadej> tdammers: I understand the "facts first", but it's simply boring
04:14:00 <phadej> I really like the separation of "paper for details" and "talk for the overview"
04:14:08 <tdammers> phadej: it is, and also quite inefficient in practice, but if you ever need to make your case to a bunch of Germans, I recommend doing it anwyay
04:14:20 <phadej> tdammers: good point
04:14:27 <merijn> tdammers: Wrong channel ;)
04:14:35 <gentauro> so who is the german? phadej ?
04:14:39 <gentauro> tdammers: ?
04:14:40 <tdammers> I am.
04:15:00 <tdammers> emigrated to the Netherlands in 1999 though.
04:15:26 <gentauro> I'm a Spaniard who went to Denmark in 2000
04:15:28 <gentauro> so ...
04:15:31 <tdammers> heh
04:15:40 <phadej> but I still think that "introduction" should include the end result
04:16:10 <phadej> I read throuh first 10-15 slides and didn't got an idea why I should read rest
04:16:16 <tdammers> maybe not the actual result, but at least a hint at what you're going to get out of reading it
04:16:21 <phadej> yes
04:18:55 <gentauro> ok, so this is my assumption. People have read `Synch` invitation to the talk -> https://www.linkedin.com/feed/update/urn:li:activity:6501434610818314240/ I'm guessing that they have read the `abstract` on the GOTO Meetup. And therefore, I'm guessing that they know the end-result
04:19:10 <gentauro> what I'm trying to "tell" is: why, how, ...
04:22:55 <phadej> gentauro: they don't
04:23:17 <phadej> or if they are, they have already forgotten :)
04:23:40 <gentauro> xD
04:24:55 <gentauro> btw, I noticed that my `main example` based on Yahoo QTY doesn't work anymore, cos Yahoo took all their `APIs` down :(
04:25:30 <gentauro> I'm actually looking for an alternative `free` service to make a basic example on (no singup/api-key/...)
04:25:33 <gentauro> :-\
04:32:46 <sshine> has anyone got something good to say about http://hackage.haskell.org/package/rio? I saw them featured in FPComplete's next webinar. I like how they include the N+1 competing standards XKCD in their docs and still argues that it reuses existing libraries as if that was something that many other alternative standard libraries don't. :-P
04:36:13 <gentauro> sshine: `Useful Prelude replacement` :'(
04:36:51 <hpc> seems pointless to me
04:36:51 <gentauro> `Enable the NoImplicitPrelude language extension (see below)` :'( :'( :'(
04:37:29 <hpc> they act like having a package depend on directory and bytestring and text is some kind of catastrophe
04:38:08 <gentauro> I have seen that library before and I really dislike it's name `RIO`. In Haskell (Safe Haskell) `RIO` means something else -> https://simonmar.github.io/bib/papers/safe-haskell.pdf
04:38:53 <cocreature> sshine: well if you look at foundation which is another fairly popular alternative standard lib, it falls exactly into the “does not reuse existing libraries” bucket
04:39:47 <gentauro> `newtype RIO a = UnsafeRIO { runRIO :: IO a }` to be more specific
04:40:16 <hpc> if it's named after the city, why not call it Rio?
04:41:16 <hpc> oh, they buried the reason, it's "Reader IO"
04:42:20 <hpc> apparently you're not supposed to use IO directly
04:43:12 <hpc> and instead of passing function parameters, use this monstrously complicated thing that is an instance of MonadUnliftIO, HasTheParameterYouWantedToPass, etc
04:44:35 <WilliamHamilton[> hi, I remember having read a blog post of someone trying to write `Compiling to Categories` as a library (instead of a plugin). Anyone remembers something similar?
04:49:34 <phadej> WilliamHamilton[: http://conal.net/papers/compiling-to-categories/
04:49:47 <phadej> ah, as a library
04:49:50 <phadej> nope
04:50:08 <gentauro> hpc: do you know if there is any `rio` code in `production`?
04:50:11 <WilliamHamilton[> phadej: yes, I remember someone trying to rewrite that work as a library; thansk though!
04:51:00 <phadej> WilliamHamilton[: it's not obvious, how it could work a library, if the idea is that you write "ordinary haskell"
04:52:07 <WilliamHamilton[> I don't remember the detail of the blog post, you sure lose all the nice ghc optimizations, I'll ping when I find it!
05:03:56 <hpc> gentauro: i bet fpcomplete is using it, but i doubt anyone here would
05:15:30 <gentauro> hpc: fair point
05:25:10 <v0d1ch> > sequenceA [Just 1, Just 2]
05:25:12 <lambdabot>  Just [1,2]
05:28:49 <dminuoso> % getConst . forwards . traverse (Backwards . Const) $ ["foo", "bar", "quux"] -- v0d1ch 
05:28:49 <yahb> dminuoso: "quuxbarfoo"
05:29:44 <v0d1ch> 👍
05:30:58 <dminuoso> traverse is an amazing primitive :)
05:34:01 <Ariakenom> can I get that in lens?
05:34:37 <dminuoso> Ariakenom: what do you mean?
05:35:06 <v0d1ch> dminuoso: do you think that one should only reach for custom typeclass only if it can satisfy certain laws or is it legit to just use it to abstract some things out ?
05:36:10 <Ariakenom> dminuoso: I assume there is a lens version without the unpacking
05:36:55 <Rembane> Ariakenom: Like traverseOf? https://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-Combinators.html#v:traverseOf
05:36:57 <dminuoso> Ariakenom: backwards is a fold
05:37:19 <dminuoso> Ariakenom: http://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-Fold.html#v:backwards
05:38:03 <Taneb> > ["foo", "bar", "quux"] ^. backwards folded
05:38:05 <lambdabot>  "quuxbarfoo"
05:38:08 <dminuoso> v0d1ch: It's hard to say. I have very few typeclasses, most of the time they wouldn't help.
05:39:08 <merijn> So...anyone wanna take a stab at making this suck less? http://dpaste.com/2TQKGPN :p
05:39:12 <v0d1ch> ok
05:39:42 <dminuoso> v0d1ch: A few people here have the opinion that typeclasses are greatly overused.
05:39:55 <merijn> A lot of people have that opinion ;)
05:39:58 <Taneb> merijn: what's carryover?
05:40:41 <merijn> Taneb: It's supposed to compute the one's complement sum of Word16 values, but that's annoying, so I'm computing the sum as Natural and then recursively adding the carry at the end
05:40:51 <dminuoso> v0d1ch: My main use of typeclasses is for Generics where they are forced down upon me.
05:41:55 <Rembane> merijn: Is a Natural and Int but >=0? 
05:41:58 <Rembane> *an
05:43:00 <merijn> Rembane: Natural is Integer, but for Word ;)
05:43:18 <Rembane> merijn: Oh. Sweet! :D
05:43:41 <Taneb> Part of me wants it to have been called "wordeger"
05:43:52 <v0d1ch> my scenario is just that I am writing to some excel cells and need to do bunch of
05:43:52 <v0d1ch> ``` 
05:43:52 <v0d1ch> writeString someString row col format
05:43:52 <v0d1ch> writeNumber someNumber row col format
05:43:52 <v0d1ch> ...
05:43:52 <v0d1ch> ```
05:43:52 <v0d1ch> so I though to ease the pain on the end user, use the typeclass that has the instances for String, Int or whatever value needs to be written
05:43:53 <v0d1ch> and also use MVar-s to hold row and column values as well as the format
05:43:59 <Rembane> Wordeger the Warrior. 
05:53:08 <merijn> Also, relatedly: Any recommendations for packages for computing CRC32?
05:54:57 <Ariakenom> merijn: the double fromInteger can be a mask
06:39:22 <merijn> Ariakenom: I know, but it was annoying to figure out how to quickly get the right mask :)
06:40:53 <Ariakenom> or mod 0x10000 as I've seen once
06:41:26 <Ariakenom> the mix of modulo and hexadecimal was so strange to me
06:44:07 * hackage flat-tex 0.6.1 - flatten a latex multi-file latex document and remove all comments  https://hackage.haskell.org/package/flat-tex-0.6.1 (JohannesWaldmann)
07:09:00 <merijn> hmm
07:09:11 <merijn> Which encoding does optparse-applicative use for data?
07:09:56 <Cale> c... continuation passing style?
07:10:31 <merijn> Cale: No, I meant like, the entire API uses Text, but I'm pretty sure execve doesn't have a specified encoding
07:11:05 <Cale> ahh
07:11:10 <Cale> yeah, I have no idea
07:11:30 <Cale> Possibly locale dependent
07:13:52 <wroathe> So, like, how big of a Haskell sin is it to define an instance of Monad that doesn't satisfy the monad laws :P?
07:14:01 <merijn> wroathe: Massive
07:14:07 <Cale> wroathe: don't do it :P
07:14:15 <merijn> wroathe: You will fuck up everyone trying to use your code
07:14:29 <Cale> wroathe: You'll always almost immediately regret it, and change your mind about how you're getting things done
07:14:40 <wroathe> Well, I'm trying to model a datatype with two fields (a -> b, a)
07:14:42 <opqdonut> don't some of the standard monads kinda skirt the edges of the monad laws?
07:14:48 <merijn> opqdonut: No
07:14:58 <merijn> opqdonut: Unless you mean in terms of strictness, but no one cares about that
07:15:03 <Cale> opqdonut: The closest thing I can think of is ListT from mtl
07:15:04 <wroathe> And the idea would be that >>= and >> apply a -> b to a
07:15:25 <opqdonut> merijn: yeah I guess I mean that. ISTR something about return >=> fail in IO
07:15:37 <merijn> wroathe: But why implement Monad? Why not write your own functions for that?
07:15:55 <Cale> If Monad doesn't fit, don't forget you can always write your own functions
07:15:55 <wroathe> Well, solely to support do notation
07:16:06 <Cale> Did you try the approach I outlined the other day?
07:16:07 <wroathe> Which you could argue is a downfall of do notation
07:16:17 <merijn> opqdonut: Not obeying strictness laws just means "more code works than expected" it doesn't change semantics of code that works in a correct strictness setting
07:16:18 <wroathe> I mean, does do notation necessarily HAVE to abide by the monad laws?
07:16:30 <Cale> where you just require *either* your `using` or another function?
07:16:38 <merijn> wroathe: Don't try to abuse do notation for other things
07:16:56 <Cale> wroathe: It will be extraordinarily confusing if your thing doesn't satisfy monad laws
07:17:03 <merijn> opqdonut: IOW, reasoning loosely about strictness wrt to laws doesn't invalidate existing correctness
07:17:15 <Cale> wroathe: you'll try to do simple refactorings on code and the behaviour of the program will change
07:17:22 <merijn> opqdonut: At worst some things turn from bottom into computable without affecting other semantics
07:17:29 <opqdonut> mmh
07:17:52 <merijn> opqdonut: In essence, that's the argument of the "Fast and Loose Reasoning is Morally Correct" paper
07:17:53 <opqdonut> maybe wroathe could work in some other monad... like `State (a -> b, a)`
07:17:57 <opqdonut> if he wants a nice do-y dsl
07:18:11 <wroathe> Cale: I don't remember your exact suggestion. I thought that we had landed on it not possibly working for one reason for another
07:18:28 <wroathe> Later on, I was thiking I'd make `merge` just a binary operator
07:19:08 <wroathe> and then I realized that `merge` could just as well be >>, since I want reaching the end of the line and continuing to merge things on one line to have the same semantics
07:19:36 <Cale> wroathe: I was suggesting that merge always work with plain monomorphic nodes, and then other functions convert toward that
07:19:53 <wroathe> opqdonut: Yeah, the real sin I was asking about would be that >> and >>= would read (a -> b) from the current state and apply it to a
07:19:59 <wroathe> Which breaks the rules
07:20:09 <Cale> wroathe: So you can still have `using`, but since it doesn't make sense to use using more than once, just have it produce a plain node
07:20:47 <wroathe> Cale: I'll write up a gist explaining the problem (or question, I should say) I have with that
07:21:01 <wroathe> Cale: and thanks for your help :)
07:21:04 <Cale> wroathe: and then have another thing that does effectively the empty "using", just applying the function to the value
07:21:58 <Minijinski> Hello, I'm using read to convert a string into an int, is it possible to check the ""return"" to verif if there is an error (like the string don't contain any int) ?
07:22:26 <Cale> Minijinski: There's reads/readMaybe
07:22:33 <merijn> :t Text.Read.readMaybe -- Minijinski 
07:22:34 <lambdabot> Read a => String -> Maybe a
07:22:44 <Cale> :t reads
07:22:45 <lambdabot> Read a => ReadS a
07:22:47 <merijn> > Text.Read.readMaybe "5" :: Maybe Int
07:22:49 <lambdabot>  error:
07:22:49 <lambdabot>      Not in scope: ‘Text.Read.readMaybe’
07:22:49 <lambdabot>      No module named ‘Text.Read’ is imported.
07:22:53 <merijn> pffft
07:22:55 <Cale> apologies for the annoying type synonym there
07:22:58 <merijn> :t readMaybe
07:22:59 <lambdabot> error: Variable not in scope: readMaybe
07:23:11 <merijn> @let import Text.Read (readMaybe)
07:23:12 <lambdabot>  Defined.
07:23:16 <Cale> type ReadS a = String -> [(a, String)]
07:23:19 <merijn> > readMaybe "5" :: Maybe Int
07:23:22 <lambdabot>  Just 5
07:23:25 <merijn> > readMaybe "foo" :: Maybe Int
07:23:28 <lambdabot>  Nothing
07:23:34 <Cale> gives you a list of all the possible parses, along with the remainder of the string
07:23:44 <Cale> usually this will consist of a string of 0 or 1 element
07:24:11 <Cale> but sometimes it's useful when you're writing implementations of Read instances to be able to use list comprehensions as a poor-man's parsing monad
07:24:32 <Cale> (or just use ReadP which has some functions that make a ReadS for you)
07:24:47 <Cale> But yeah, usually just use readMaybe :)
07:25:11 <Minijinski> so I just have to replace by readMaybe and it will do the job ?
07:25:18 <Minijinski> read by*
07:25:22 <Cale> Yeah, you'll get Nothing if the read fails
07:25:37 <Minijinski> Ok, thanks guys
07:25:38 <Cale> and Just x where x is the thing that got parsed otherwise
07:29:22 <merijn> Minijinski: Well, you need to add an import to get readMaybe from Text.Read, but yes, that's all you have to do
07:30:00 <wroathe> Cale: https://gist.github.com/JustinChristensen/5f0780e028c58e93954458ddb6e610a8
07:30:38 <Minijinski> Yeah, I've just figured that out 
07:31:07 <Cale> hrm
07:31:25 <Cale> wroathe: ouch, is it really necessary to use ambiguous types here?
07:31:55 <Cale> wroathe: I'd much prefer just to have 4 differently named functions and no ambiguity.
07:32:25 <wroathe> Cale: Ultimately that shouldn't matter, because part of my design goal is that it's an open class of types
07:32:36 <wroathe> There's another class that I haven't added to this gist called "FromSource"
07:33:22 <wroathe> The fact that file and requiredFile are polymorphic are just nice-to-haves for those 4 pre-supported data types
07:33:42 <wroathe> But they could just as easily be made monomorphic, or you could export a monomorphic API in terms of them
07:34:05 <wroathe> This doesn't have to be the final API for this
07:34:18 <Cale> Yeah, I think that would be simpler, but it's orthogonal to what we're trying to figure out at the moment
07:34:22 <wroathe> The reason I was asking about the monad laws is that I was thinking about making `merge` a binary operator
07:34:56 <wroathe> The pre-supported "source" functions I've got are: file, requiredFile, env, and args
07:35:00 <Cale> I also am willing to bet that EnvReader shouldn't be MonadState and MonadReader, but let's leave that for now as well
07:35:12 <wroathe> I'm thinking about also adding a descendantFile and an ancestorFile
07:35:25 <Cale> (it's always better to make another type class with the operations you really want and hide the implementation details)
07:35:49 <wroathe> But I always want the source functions to return some form of: m a so that the user can just use return or do notation to put an arbitrary value there (like the hashmap example on line 41
07:36:43 <Cale> So is there any downside in having...
07:36:58 <Cale> using :: EnvReader Options ConfigNode [(a -> Reader Options ConfigNode, a)] -> (a -> Reader Options ConfigNode) -> EnvReader Options ConfigNode [ConfigNode]
07:37:05 <wroathe> Cale: Actually, I have another function that's not in the gist named getConfig that takes an arbitrary EnvReader
07:37:27 <Cale> (I'm actually a little confused about how there's a ConfigNode in the state as well...
07:37:29 <Cale> )
07:37:54 <wroathe> I'll add more to the gist
07:38:09 <Cale> but the basic idea is, get the bit which makes things into ConfigNodes out of the way in one step
07:38:09 <wroathe> Sorry, the API for this thing has changed so many times that I've got lots of versions of the code piled up :P
07:38:17 <Cale> then do all your combination on ConfigNodes
07:38:35 <Minijinski> Another question : I'm using the "do" notation on a function that is not prototyped as IO () but as String -> Int, is it possible to "return" an int there ? 
07:38:37 <Cale> and you can have polymorphic things ahead of that conversion
07:38:44 <Minijinski> I'm totally new to haskell btw, sry
07:39:14 <Cale> Minijinski: No, return isn't a keyword, it's a function which produces an action which does nothing except to return the given value.
07:39:18 <wroathe> Cale: So I added getConfig to that gist, which gives you an idea of how the old API would have looked
07:39:33 <Solonarv> Minijinski: yes, using the Monad ((->) e) instance, but that's probably not what you had in mind
07:39:52 <Cale> Minijinski: If you were to apply return, the type would have to be of the form (m a) for some m and a. Perhaps a would be Int, but m would need to be something like IO or Maybe.
07:39:52 <wroathe> By basically getConfig takes an arbitrary EnvReader that models building up a ConfigNode (which is a tree structure of config), where the process that handles that building can depend on a few global Options
07:40:12 <Cale> Oh, sure, you could write return 5 :: String -> Int
07:40:22 <dminuoso> Minijinski: It may be helpful to remember that `pure = return`, then just use `pure` since it has a much less confusing name.
07:40:27 <Cale> but that's just the same as const 5
07:40:33 <Minijinski> oh
07:40:39 <Cale> dminuoso: I hate that tbh
07:40:42 <Minijinski> I see now
07:40:56 <wroathe> Cale: So it seemed easiest to me to make use of Reader and State to handle those parts of what EnvReader should do
07:41:00 <Cale> Whenever I see 'pure' in code where there could be 'return' it bothers me, because it forces me to wonder about why we're using Applicative
07:41:37 <Cale> 'pure' is like a signal that higher generality is required, and if that generality isn't actually needed, it's irritating :)
07:41:39 <dminuoso> Minijinski: `do` is just syntax sugar for using (>>=)
07:41:53 <wroathe> Cale: I updated the gist again with the definition of ConfigNode in the current codebase
07:42:08 <dminuoso> Cale: just like `return` is a like a signal that a less general type is needed. What is your point exactly?
07:42:47 <wroathe> Cale: Options you can think of as being a table of functions that control how the keys from the various sources are mapped to the ConfigNode Map keys
07:43:01 <Cale> dminuoso: I mean, I've come to like when code gives me more hints about the types of things. Just replacing all the occurrences of return by pure loses information locally, even if the types elsewhere are specified.
07:43:10 <Minijinski> I'll juste paste my piece of code to show you what I'm trying to do, it'll be easier to see
07:43:17 <dminuoso> Cale: I dont think that really applies, but YMMV.
07:43:58 <Cale> dminuoso: I'm just referring to the comment about using pure in place of return -- if we know that something is a Monad, I want to see return.
07:44:21 <dminuoso> Cale: `return` should be abolished.
07:44:24 <Cale> I only like to use pure when I am sure that I need the generality of Applicative
07:44:32 <Cale> I disagree
07:44:36 <dminuoso> Cale: return *is* pure.
07:44:44 <Cale> They have different types
07:44:47 <Cale> :t return
07:44:49 <lambdabot> Monad m => a -> m a
07:44:50 <Cale> :t pure
07:44:52 <lambdabot> Applicative f => a -> f a
07:44:56 <Cale> ^^ this is useful information
07:45:04 <Taneb> If return didn't exist and someone tried to propose it now, I don't think they'd get very far
07:45:19 <Cale> That's fair, but nothing exists in a vacuum :)
07:46:13 <Cale> Most things are actually monads, and having the signal that "oh, we're actually trying to generalise this to Applicative for some reason" is surprisingly useful.
07:46:49 <wroathe> Cale: So the original question I asked in here was just trying to reason through how this might look if there was no "merge" and instead the user wrote: xmlFile "foo.xml" `using` configMapper >> jsonFile "foo.json" `using` configMapper {newline} args `using` configMapper, etc
07:47:21 <wroathe> But that would mean that (>>) would have to apply the mapping function to the result of file "foo", and then merge the result into the current state
07:47:51 <Cale> wroathe: It could mean that `using` manipulated the state somehow
07:48:04 <fr33domlover> I have need a message queue with 1 reader and many concurrent writers: Should I prefer Chan or TChan?
07:48:38 <fr33domlover> (I never used TChan, wondering when to prefer it)
07:48:40 <wroathe> Cale: Because `using` is optional, that would mean that the source would somehow need to be able to manipulate the state too
07:48:45 <Cale> fr33domlover: I'd usually go with Chan until there was a reason not to.
07:49:11 <wroathe> Anyway, I think I just need to keep mulling this over. Sounds like the unlawful Monad thing is a no go :P
07:49:11 <Cale> fr33domlover: Usually that reason has to do with synchronisation with some other piece of concurrent state.
07:49:27 <Cale> wroathe: but using doesn't need to be optional
07:49:44 <fr33domlover> Cale, thanks :)
07:49:46 <Cale> wroathe: You can also make a simpler version of using which just collapses the thing down and gives you the ConfigNodes
07:49:52 <wroathe> Cale: It should. There's a default configuration mapper for the pre-supported types
07:49:58 <wroathe> `using` just overrides that
07:50:15 <Cale> fr33domlover: If you can, try to design things such that most of the program doesn't know or care which of Chan/TChan/etc. you're using.
07:50:38 <Cale> fr33domlover: You can pre-apply writeChan and pass the resulting function around, for example.
07:50:54 <merijn> fr33domlover: Do you want to eventually signal being done?
07:51:45 <fr33domlover> Cale, yeah I usually do that ^_^
07:52:29 <Cale> wroathe: Like, I know what you're currently after, I'm just (kind of repeatedly) suggesting that you can make the problem a lot simpler if you're not trying to unify the input to `using` with the input to merge
07:52:33 <fr33domlover> merijn, I'm not sure yet! I prefer to send-and-forget but possibly I'll need the queue reader thread to report to the writer threads every time it finishes processing the queue items
07:52:40 <fr33domlover> (I hope not but not sure yet)
07:52:42 <dminuoso> Cale: Do you also use `liftM` over `fmap`, or `ap` over (<*>) when you already are in a monad?
07:52:53 <dminuoso> Cale: Or do you create constrained liftM2 identifiers too?
07:53:09 <Minijinski> https://paste.ofcode.org/hy3AT6hGymBDk9v6wkkQdU So I'm trying to do something like returning either 1 or 0 if there is no problem when I use readMaybe..
07:53:10 <fr33domlover> merijn, or did you mean being done as in the queue getting empty?
07:53:24 <dminuoso> Cale: 
07:53:27 <dminuoso> Oops. Sorry.
07:53:27 <merijn> fr33domlover: Well, a queue being empty is not the same as done :)
07:53:37 <merijn> fr33domlover: Done would be "queue is empty AND won't be refilled"
07:54:07 <fr33domlover> merijn, ah nope no such case, the queue runs as long as the web app runs and does background tasks, it can always get more
07:54:17 <Cale> dminuoso: I don't often do that (though I will write liftM2 rather than liftA2)
07:54:23 <merijn> fr33domlover: So you don't have a "shutdown" signal? ;)
07:54:34 <fr33domlover> merijn, nope
07:54:54 <fr33domlover> merijn, I guess you mean if I needed one, I could use STM's <|> for that? ^_^
07:55:05 <fr33domlover> But nope I don't need a shutdown signal
07:55:08 <Cale> dminuoso: <*> is a weaker sign with regard to whether Applicative is really needed or not
07:55:13 <merijn> fr33domlover: Yeah, and I wrote a library that has a closable Chan :p
07:55:40 <Cale> dminuoso: If someone is using 'pure', it's a pretty strong signal that they really want to maintain Applicative-polymorphism
07:55:59 <Cale> because 'return' exists and is more common to write
07:56:38 <Cale> I don't deny that if things had been carved up differently all along, this signal wouldn't exist
07:56:45 <fr33domlover> When is return going away and pure replacing it? ^_^
07:56:49 <delYsid> As an unwashed bystander, I always keep wondering why people use Monad if Applicative or even functor is enough.
07:56:54 <merijn> fr33domlover: Realistically? Never
07:56:56 <Cale> But given that it already exists in a lot of code, I actually like it
07:56:56 <dminuoso> delYsid: Indeed.
07:57:06 <Cale> delYsid: Well, they shouldn't
07:57:07 <fr33domlover> merijn, yeah I'm just dreaming lol
07:57:15 <gentauro> Cale: you can have `Aplicative` that isn't a `Monad`. That's why sometimes you write `pure`
07:57:16 <merijn> delYsid: In many case you write code for a specific type, so that's not relevant
07:57:20 <dminuoso> delYsid: Sometimes its expressivity.
07:57:30 <delYsid> do { madeUpName <- action; return (f madeUpName) } -- huh?
07:57:37 <Solonarv> fr33domlover: there's already a warning if you define 'return' yourself in a monad instance (I don't know when it's enabled, though)
07:57:40 <dminuoso> delYsid: e.g. in the absence of ApplicativeDo, sometimes its convenient for parsers
07:57:57 <Cale> delYsid: But also, if you *know* that something is a Monad, there's no disadvantage to using the Monad operations
07:58:07 <Cale> delYsid: In most code, you know which Monad you're working with.
07:58:08 <dminuoso> delYsid: do { a <- foo; b <- bar; c <- quux; ... ; pure (Foo a b c d e f g h i) }
07:58:27 <Cale> (and there's very little code which really needs to be abstracted over Applicative or Functor)
07:58:39 <Solonarv> You still need ApplicativeDo for that to desugar using <*>, actually
07:58:54 <delYsid> Or, just stopped in GHCi/UI.hs: do { cs1 <- f1 line; cs2 <- f2 line; return (cs1 ++ cs2) } -- ouch, what is bad about <$> and <*>?
07:59:05 <Cale> ApplicativeDo is a very awkward extension
07:59:35 <Cale> Either you care about the difference between <*> and ap, in which case, you probably actually want to be careful about how things are being composed in terms of <*>
07:59:43 <Cale> or you don't in which case, ApplicativeDo is pointless
07:59:54 <jollygood2> I neve rused ApplicativeDo. is it exactly the same as regular do, except you can't use if/then/else, when, etc with the bound value?
08:00:09 <Cale> It's really only useful in weird cases where you don't really want to understand your program very well
08:00:31 <Solonarv> It's actually just a different desugaring of do-notation (with a few weird edge cases) which should be semantically equivalent
08:00:43 <Cale> jollygood2: No, it's the same as regular do, except that it does weird magical hackery to try to use <*> whenever possible
08:00:49 <Solonarv> the main point of it is that it lets you use do-notation for things that are applicative but not monad
08:01:06 <Cale> and it becomes impossible to describe concisely what the actual translation is
08:01:09 <phadej> I have used ApplicativeDo for that
08:01:13 <jollygood2> what if do this in applicative do:  do x <- foo; if x then pure 10 else pure 20
08:01:17 <phadej> (using for non-monads)
08:01:22 <adius> Hi, is there a function like `groupElements 2 [1,2,3,4,5] == [[1,2], [3,4], [5]]`
08:01:35 <Cale> jollygood2: It'll just use >>=
08:01:37 <phadej> adius: chunksOf
08:01:39 <jollygood2> > chunksOf 2 [1..5]
08:01:42 <lambdabot>  [[1,2],[3,4],[5]]
08:02:02 <jollygood2> Cale hmm, applicative do can use >>=? 
08:02:07 <dmwit> ?hackage split
08:02:08 <Cale> jollygood2: So that'll desugar to something different from  do x <- foo; pure (if x then 10 else 20)
08:02:08 <lambdabot> http://hackage.haskell.org/package/split
08:02:12 <Cale> jollygood2: yes
08:02:22 <Solonarv> yes, but it tries to use <*> instead whenever possible
08:02:23 <jollygood2> that doesn't make much sense
08:02:25 <Cale> jollygood2: It's compatible with normal do, it just uses <*> where possible
08:02:41 <Cale> jollygood2: It's almost always dumb, don't bother with it.
08:02:46 <delYsid> I gather it is just muscle memory.  However, overuse of 'do' sort of hurts my sense of asthetics.  I came here to dable in functional style, and keep seeing people happily escaping to a sequencial style, without any reason at all (except for having gotten used to 'ddo').
08:02:49 <jollygood2> so if it can get away with <*>, it uses applicative constraint, otherwise, monad constraint?
08:02:59 <dmwit> jollygood2: You are thinking the extension says, "Only use Applicative things when desugaring do". But it actually means "*Also* use Applicative things to desugar do".
08:03:05 <dminuoso> jollygood2: it tries to rewrite into using <*> as much as it can
08:03:07 <adius> phadej: Thanks! Haskell naming is always ... uhm ... a little too creative for my liking. Looking at you `nub`
08:03:14 <Cale> delYsid: Well, do-notation isn't really traditional imperative style
08:03:23 <phadej> adius: chunksOf exist in many libs, people converged to it
08:03:31 <phadej> to that name*
08:03:40 <Cale> delYsid: It's really just a convenient way to write a bunch of (>>=) and lambdas
08:03:59 <phadej> do introduces data-dependencies
08:04:08 <marvin2> adius, nub is a bit weirdly named.. I like chunksOf, though
08:04:15 <phadej> it's not "sequential" unless your data-depedencies for a chain
08:04:22 <phadej> form*
08:04:42 <phadej> e.g. do for Maybe is very convinient
08:04:42 <Cale> jollygood2: yeah, your code will end up with a random constraint depending on how successful it was at converting to applicative style
08:04:46 <Cale> lol
08:04:51 <tdammers> the fact that do notation roughly aligns with imperative sequencing and variable "assignment" for many Monad instances is really more like a happy coincidence
08:04:53 <delYsid> Cale: I get that, even more I wonder why someone hand-rolls a simple call to liftM2 via do.
08:05:12 <dminuoso> delYsid: Depending on the context it can be more expressive.
08:05:14 <Cale> delYsid: Sometimes it aids readability to give things names
08:05:21 <adius> phadej: It's just often differen to other programming languages ... but I guess the moto is "avoid access at all costs"
08:05:22 <jollygood2> Cale, random, as in, there are cases where applicative would be enough, but you still get a monad constraint?
08:05:26 <tdammers> that said, it does tend to give code a bit of an imperative vibe
08:05:30 <delYsid> Now, they are faced with the issue of naming variables.  And get a lot more of boilerplate.
08:05:32 <Cale> I honestly *hate* over-cute code in production.
08:05:39 <tdammers> e.g. when writing do-expressions over lists
08:05:42 <adius> *  "avoid success at all costs"
08:06:02 <dminuoso> delYsid: Sometimes being more verbose is better.
08:06:18 <dminuoso> delYsid: liftA2 is a great way to write point-free code.
08:06:19 <tdammers> the problem isn't really verbosity, but redundancy
08:06:23 <dminuoso> pointfree is not always better.
08:06:26 <Cale> There's a big difference between what's acceptable on IRC and in personal projects vs. what's acceptable in production code where you have a team of people working on it.
08:06:41 <Cale> It really pays to write far more plain, non-points-free code.
08:06:47 <delYsid> Cale: The only good argument against not avoiding do I found so far is that it appears to be easier to change things.
08:06:52 <Cale> Write case expressions instead of fancy combinators
08:07:07 <Cale> Name your intermediate results whenever possible
08:07:08 <Cale> etc.
08:07:11 * dmwit tries to parse "against not avoiding"
08:07:24 <dmwit> ="for avoiding"?
08:08:13 <Cale> I have a really good heuristic for finding shitty code in our projects: I just grep for '>>=' and any occurrence which isn't followed by \case is immediately suspect.
08:08:14 <delYsid> +1
08:08:37 * fr33domlover never uses liftA1, always uses f <$> x <*> y, ends up looking nicer because very often no need for parens around x and y
08:08:43 <fr33domlover> Oops I mean liftA2
08:08:45 <dminuoso> Good thing I prefer (=<<)
08:08:49 <dminuoso> You will never find my code.
08:08:54 <Cale> Yeah, =<< fits much better with do notation
08:09:09 <Cale> I might not even mind your code, depending ;)
08:09:31 <Cale> Also, any overly-clever uses of traverse
08:09:40 <jollygood2> Cale, you mind things like: getArgs >>= parseArgs ?
08:09:40 <Cale> They're usually actually wrong.
08:10:36 <delYsid> Cale: I just wrote "gets replPrompt >>= (`interpret` infer) >>= getInputLine" and I really prefer the expressivity of that little pipe over a do-block.
08:10:45 <delYsid> But yeah, I gather you can overdo everything.
08:10:56 <tdammers> wait what? building >>= pipelines is wrong? huh.
08:11:05 <Cale> delYsid: Yeah, see, I would want that written using do-notation.
08:11:07 <Cale> haha
08:11:37 <Cale> tdammers: Not so much *wrong* as troublesome in the context of team projects and production code.
08:11:39 <tdammers> I guess it depends - I quite like the "pipeline" approach
08:12:01 <tdammers> but it only works well if there's no additional logic beyond the actual pipelining, and each link in the chain is simple
08:12:12 <Cale> It depends on how much the code is going to change in the future
08:12:20 <jollygood2> I do too. but it is a bit annoying that <&> isn't in base. and when you start mixing <$> with >>=, things look weird. then =<< is often cleaner
08:12:45 <tdammers> e.g., liftIO getContents >>= lex >>= parse >>= generate >>= liftIO putStr -- I don't have a problem with this, really
08:12:50 <Cale> With business software, it's pointless to try to apply cute mathematical truths to try to simplify it into a crystalline form, because you're going to end up tearing it all apart again later anyway
08:12:51 <jollygood2> s/in base/in Prelude
08:12:52 <tdammers> ., actually
08:12:53 <merijn> jollygood2: But it's literally one line to define <&> yourself
08:13:41 <tdammers> and I wouldn't argue for this style from a math/logic point of view, but from psychology - it says "you probably want to think of this expression as a pipeline"
08:13:56 <Cale> In my experience, in such a context, any code which makes you feel clever now is going to make you look stupid later.
08:14:04 <dmwit> Cale: You would consider this bad code? http://hackage.haskell.org/package/sgf-0.1.3.1/docs/src/Data-SGF-Parse.html#line-130
08:14:38 * hackage fused-effects 0.2.0.0 - A fast, flexible, fused effect system.  https://hackage.haskell.org/package/fused-effects-0.2.0.0 (robrix)
08:14:51 <Cale> dmwit: That's not the worst. tbh, usually I'm thinking of cases where someone's partially applied >>=
08:15:05 <dmwit> ah
08:15:23 <Cale> dmwit: still, I'm not sure how much that code benefits from not just being a do-block :P
08:15:45 <Cale> I guess it does make sure that the results are chained through correctly, which might be good
08:15:51 <Taneb> (I think that code would look better with >=>)
08:15:54 <phadej> traverse (>>= k) is common
08:16:05 <dmwit> You would prefer `do { t <- foo; t' <- bar t; t'' <- baz t'; t''' <- quux t''; ...}`? It seems way too easy to make a mistake there.
08:16:10 <Cale> phadej: Is it? I'd have to think hard about what it means
08:16:11 <delYsid> I really by the changeablility argument.  However, in simple cases, a one-liner using <$> <*> or a >>=/=<< pipe is really preferable over a do-block for reasons of readability.
08:16:22 <tdammers> do { x <- liftIO getContents; x' <- lex x; x'' <- parse x'; x''' <- generate x''; liftIO (putStr x''') } -- like this?
08:16:25 <Cale> phadej: and probably end up rewriting it as a forM :P
08:16:36 <phadej> Cale: in a context of Foos xs >>= k = Foos <$> traverse (>>= k) xs
08:16:42 <Solonarv> forM is just traverse with a stricter constraint and the arguments flipped
08:17:02 <Cale> Solonarv: I know
08:17:15 <Cale> Solonarv: but that makes a difference readability-wise
08:17:19 <tdammers> if anything, I'd pull out individual parts of the chain that are too complex, and name those
08:17:21 <phadej> Cale: write that with forM, it won't be more readable
08:17:55 <tdammers> seems like a more useful refactoring than naming the intermediate values that probably don't interest us
08:17:59 <Cale> phadej: My first question in the context I'm talking about is "why are we writing a Monad instance"?
08:18:28 <Cale> Most of the monads you could possibly want already exist somewhere.
08:18:37 <Cale> or can be composed from transformers
08:19:51 <phadej> many ASTs are Monads (some are only applicatives, like optparse-applicative)
08:20:51 <Cale> any reason not to use free?
08:20:53 <delYsid> You mean edsls?
08:21:04 <phadej> Cale: boilerplate
08:21:18 <tdammers> ^ this.
08:21:21 <Cale> Doesn't free remove boilerplate?
08:21:30 <phadej> Cale: not if you pattern match on the structure
08:21:42 <Cale> I suppose that's fair.
08:21:54 <tdammers> free does introduce a bit of mental overhead IME
08:22:07 <tdammers> overhead/indirection
08:22:11 <Cale> I don't find a lot of occasion to encode abstract syntax trees while writing web applications
08:22:43 <tdammers> not all production code is web applications
08:23:18 <Cale> Sure, I'm just talking about generally code which doesn't tend to have mathematically-clean requirements
08:23:48 <Cale> It can be nice to factor things through the development of a language implementation for sure.
08:24:37 <phadej> I'm not sure where the eDSL and library boundary is
08:25:48 <phadej> but I agree that rarely you need fancy binders
08:26:05 <phadej> (like fancier than host lambda abstraction)
08:26:47 <Welkin> I just found this post this morning https://www.tweag.io/posts/2019-02-13-types-got-you.html
08:27:04 <tdammers> "mathematically clean requirements" isn't necessary for an EDSL to be a reasonable approach though
08:27:06 <phadej> blog post without a code snippet :O
08:27:09 <Welkin> and it is similar to how I have been feeling lately
08:27:50 <Cale> haha, I agree with phadej's sentiment, but also the blog post seems to be saying something that I too agree with
08:28:07 <Cale> (I think there are plenty of good examples which could fit and make it a better post)
08:28:43 <Cale> There are cases where you can use fancy types to get something you really couldn't have with plain types.
08:29:09 <Cale> But then there are cases where people use fancy types in order to enforce properties that nobody actually cared about in the first place and turn development into hell.
08:30:33 <Cale> Having a good sense of taste and only reaching for those things once you've exhausted what good old functional programming can do is really important.
08:31:16 <tdammers> a good question to ask yourself is "does this thing pull its weight"
08:31:40 <Welkin> recently I've been unhappy with haskell because it is almost required to deal with tons of ghc extensions because so many libraries use them and therefore force you to use them
08:31:47 <dminuoso> phadej: In london you presented a simple PoC for a dependently typed language. Do you recall which library you used for binders?
08:32:03 <phadej> dminuoso: bound(-extras)
08:32:09 <dminuoso> phadej: merci
08:32:41 <phadej> Welkin: funnily, Tweag is behind linear haskell ;)
08:32:44 <Cale> I've been finding more and more cases lately where GADTs used as keys of key-value pairs are able to pull their weight vs. traditional approaches -- it gives Haskell a lovely extensible record system.
08:33:04 <Cale> Yeah, I really feel apprehensive about the whole linear haskell thing
08:33:47 <Cale> It seems really unclear what benefit it will have on the average program, and at the same time, it will annoy the hell out of library maintainers who will be pestered by people playing with linear types
08:33:58 <Cale> (and wanting things generalised)
08:34:47 <fendor> is ghc 8.6.3 patched for windows? since it is the default for haskell platform and had a TH bug.
08:35:00 <phadej> fendor: nope :(
08:35:10 <Solonarv> just use 8.6.2 instead, 's what I do
08:35:23 <fendor> why does Haskell Platform ship with 8.6.3 then?!
08:35:31 <Welkin> it works on linux and mac
08:35:54 <Welkin> or do you mean the patch is for TH?
08:36:11 <Welkin> I don't use TH so I wouldn't notice
08:36:21 <Solonarv> "it works on linux and mac" isn't a good reason to ship a broken release for windows, tbh
08:36:40 <fendor> @inc Solonarv
08:36:41 <lambdabot> Maybe you meant: wn src rc ping kind id ghc
08:36:48 <pagnol> I'm using postgresql-simple and am trying to figure out how to get the thing to reconnect when the connection is interrupted
08:36:52 <fendor> damit, what was the karma again?
08:36:55 <Solonarv> I don't use TH much myself either, but I occasionally depend on libraries that do - and had a hanging compiler
08:37:09 <Solonarv> fendor: @karma+ I think
08:37:16 <dminuoso> Solonarv: Better have the compiler hang than the program crash.
08:37:17 <merijn> Just "name++"
08:37:18 <fendor> @karma+ Solonarv 
08:37:18 <lambdabot> Solonarv's karma raised to 9.
08:38:03 <fendor> dminuoso, but dont ship it as the default if it is broken for one of the three platforms it should support?
08:38:20 <Solonarv> I don't have any insight into why the only 8.6 haskell platform release is broken, I'd recommend installing it through a different method
08:38:38 <Solonarv> I used chocolatey, if you want a recommendation
08:38:45 <pagnol> or the haskell docker image
08:38:48 <fendor> Solonarv, thanks
08:38:51 <pagnol> without installing anything
08:38:53 <fendor> pagnol, docker on windows?
08:39:07 <pagnol> ok, then install some unix first
08:39:31 <fendor> pagnol, well, it is a gaming pc :P and it is supposed to validate that something works on windows
08:39:38 <pagnol> just joking, sorry
08:39:47 <fendor> pagnol, no problem :)
08:40:04 <pagnol> I didn't realize this conversation is about haskell on windows
08:40:52 <fendor> however, can we poke someone to change that? 
08:48:44 <akersof> hi all in the wiki book; https://en.wikibooks.org/wiki/Haskell/Simple_input_and_output, we have a little snippet: https://gist.github.com/akersof/1cbff10d66ea2ec126a7de4ea68d42e0
08:49:46 <akersof> there is a statement about the then clause of ou if/then/else construct: "Here, we are sequencing two actions: putStrLn and doGuessing. The first has type IO (), which is fine. The second also has type IO ()"
08:51:07 <akersof> i can understand that putStrln has type IO(), but how ca we know that 'doGuessing num' has type IO () ?
08:51:47 <dminuoso> akersof: Consider how that program branches.
08:51:54 <akersof> dminuoso: yes it is recusive
08:52:08 <akersof> dminuoso: and can just end at the final "else" clause
08:52:12 <dminuoso> akersof: The non-recursive branches however have a specific.
08:52:19 <akersof> oh..
08:52:45 <dminuoso> akersof: you could think of `if` as a function of this type: Bool -> a -> a
08:52:56 <dminuoso> akersof: you could think of `if` as a function of this type: Bool -> a -> a -> a
08:52:58 <dminuoso> Sorry! :)
08:53:10 <dminuoso> akersof: Do you notice how the two branches must have the same type?
08:53:54 <akersof> well following the signature yes but..
08:55:11 <akersof> the then has the type of do expression
08:55:26 <akersof> and the type of the do expression is the type of the last "action"
08:55:27 <dminuoso> akersof: do gives you just syntax sugar.
08:55:33 <dminuoso> akersof: You could have written it like this:
08:56:12 <dminuoso> if someCond then (putStrLn "Too high!" >> doGuessing) else (putStrLn "You win!")
08:56:15 <dminuoso> Parens added for emphasis.
08:56:26 <dminuoso> Now (>>) is just a function
08:56:43 <dminuoso> Whatever it returns, it must have the same type as `putStrLn "You win!"`
08:57:50 <akersof> dminuoso: the type of doGuessing is "inferred" or deduced because we know the type of the else expression?
08:57:57 <dminuoso> akersof: Yup.
08:57:58 <Solonarv> yes
08:58:03 <gentauro> % main = putStrLn "42" >> getLine >>= putStrLn
08:58:03 <yahb> gentauro: 
08:58:09 <dminuoso> akersof: we call it inference indeed.
08:58:10 <gentauro> % :t
08:58:10 <yahb> gentauro: ; <no location info>: error: not an expression: `'
08:58:13 <gentauro> % :t main
08:58:13 <yahb> gentauro: IO ()
08:58:21 <gentauro> % main
08:58:25 <akersof> else is IO () so doGuession has to be IO()
08:58:27 <yahb> gentauro: 42; [Timed out]
08:58:32 <gentauro> % 43
08:58:33 <yahb> gentauro: 43
08:58:35 <gentauro> :D
08:58:36 <dminuoso> akersof: That's precisely what GHC concludes too.
08:58:56 <dminuoso> akersof: If you load this code into GHCi, you can ask GHCi what type it has using `:t`
08:59:58 <akersof> dminuoso: so in the snipet i pasted.. the function is recursive..
09:00:34 <akersof> we can't know the type of the if/then/else until the last step of the recursion, am i wrong?
09:00:44 <akersof> by "we" i mean the compiler
09:00:45 <dminuoso> akersof: No we can!
09:00:54 <Solonarv> You are indeed wrong, because that's not how the typechecker works
09:00:57 <akersof> oh..
09:01:04 <dminuoso> akersof: Let's for the sake of simplicity assume if to be the function I talked about above.
09:01:15 <Solonarv> It walks over your code and generates a bunch of statements like 'these two types must be equal'
09:01:36 <akersof> ok ok
09:01:37 <dminuoso> akersof: GHC has inference rules that look like this: if `f :: a -> b`, and `x :: a`, then `f x :: b`
09:01:52 <Solonarv> then it collects all these equalities and solves them; this algorithm can deal with recursion just fine!
09:01:55 <dminuoso> akersof: Its very mechanical. :)
09:02:03 <akersof> indeed
09:02:08 <kuribas> dminuoso: it should have been a function.  Why did they make it syntax?
09:02:22 <dminuoso> kuribas: I do not know.
09:02:56 <kuribas> At least multiway if makes some sense as syntax.
09:03:11 <dminuoso> akersof: It's very easy to rig it into case discriminating unit though.
09:03:23 <dminuoso> So while a multiway if syntax is nice to have, its not very important.
09:04:02 <kuribas> neither is if
09:04:14 <kuribas> my only guess is because it's syntax in every other language.?
09:04:30 <Solonarv> seems likely
09:04:57 <akersof> dminuoso: thx!!
09:05:01 <akersof> Solonarv: thx :)
09:05:28 <dminuoso> akersof: Are you familiar with logic programming (pehaps with Prolog)?
09:05:49 <akersof> dminuoso: ahah no, i did prolog for fun 1 day only
09:06:01 <akersof> but i am know the principle i think
09:06:03 <Welkin> syntax is stupid
09:06:07 <akersof> i mean the big picture
09:06:56 <akersof> dminuoso: there is something familliar with prolog there?
09:11:48 <iqubic> Why is reflex-dom a pain to get started with?
09:13:11 <Welkin> because it uses ghcjs
09:13:53 <slack1256> and nix
09:13:55 <Welkin> if you just want to build a web app and are not a masochist use elm
09:15:40 <iqubic> slack1256: I'm fine with Nix. I run Nixos.
09:15:57 <iqubic> Welkin: I'm not a masochist, but I don't want to learn a new language.
09:16:13 <NickSeagull> iqubic: purescript is pretty nice too
09:16:19 <Welkin> you can learn elm in minutes
09:16:31 <Welkin> if you know haskell it is trivially easy to pick up
09:16:42 <iqubic> Welkin: I'd like to stick to reflex-dom.
09:16:43 <Welkin> if you only know javascript, it i trivially easy to pick up
09:19:18 <tdammers> if you already know haskell, then purescript is a lot easier to pick up than elm
09:19:30 <tdammers> also a lot less frustrating
09:19:41 <Welkin> we've been over this already, and in my experience purescript is the worst option
09:21:07 <tdammers> this isn't meant to be another debate about what is "better"; it's just that it doesn't take a genius to figure out that purescript is way more similar to haskell than elm is, and offers much the same problem solving strategies
09:23:33 <pagnol> Welkin, why is purescript in your opinion the worst option?
09:24:32 <dminuoso> pagnol: Welkin fits demographically into the Elm/Go scene. They favour simplicity in language, PureScript is like a modern version of Haskell which has very deep features.
09:24:41 <Welkin> pagnol: I'm not going to get into it here, but the tooling, the ecosystem, the compiler, the syntax, is all a big disaster compared to the extreme ease-of-use of elm and the fact that elm "just works"
09:24:57 <tdammers> (until it doesn't)
09:25:01 <Welkin> no
09:25:15 <Welkin> I know tdammers has some kind of bias against elm
09:25:23 <dminuoso> Welkin: just like you have a bias *for* it and against haskell.
09:25:26 <dminuoso> ;)
09:25:38 <Welkin> elm truly just works
09:25:44 <Welkin> it's never broken on me
09:25:50 <Welkin> purescript has broken on me again and again and again
09:25:51 <tdammers> I think it's more honest to say that we had different experiences with elm
09:25:52 <pagnol> Welkin, have you tried psc-ide?
09:26:10 <tdammers> elm's tooling has broken on me twice, in absolutely unacceptable ways
09:26:26 <Welkin> tdammers: 5 years ago?
09:26:40 <Welkin> anyway, let's not do this here
09:26:45 <tdammers> agree
09:26:48 <pagnol> it's fun, though
09:26:50 <Welkin> it's offtopic and I have no energy to waste on this
09:27:18 <pagnol> it should be possible to have this kind of conversation without getting so worked up
09:28:15 <Welkin> I'm certainly not worked up
09:28:17 <tdammers> off to -blah, then. or -offtopic, I don't mind either.
09:28:26 <Welkin> off to nowehere for me
09:29:22 <tdammers> even better.
09:30:27 <tdammers> just this one thing: going into #haskell and suggesting that people use elm to solve their haskell problems, and then getting mild amounts of flak for it should not come as a surprise
09:37:15 <asheshambasta> Why is this "ambiguous"? https://gist.github.com/asheshambasta/2d81c2cb1b0d7b9386470e41c3d58114
09:38:38 <dminuoso> asheshambasta: ScopedTypeVariables
09:38:52 <slack1256> ScopedTypeVariables
09:39:06 <asheshambasta> not sure I understand 
09:39:15 <asheshambasta> you mean I need to add hints using them? 
09:39:25 <dminuoso> asheshambasta: When you introduce a type variable in a signature and attempt to "reuse it" in a nested binding, its actually a *different* type variable
09:40:03 <dminuoso> If you want that `nid` and `a` inside your where bindings to be the same as in your `urn'` binding, you need to enable ScopedTypeVariables and explicitly bring it into scope using forall.
09:40:28 <asheshambasta> I see; interesting 
09:40:35 <dminuoso> asheshambasta: Just enable the extension and change the type signature to: urn' :: forall nid a. nid -> a -> URN nid
09:40:45 <asheshambasta> I've started to connect these dots in more and more cases, somehow this one had me stumped. 
09:41:01 <c_wraith> asheshambasta, you could also just use pure to create the proxies, instead of the constructor. that'd get the types right.
09:41:26 <asheshambasta> okay 
09:43:45 <mniip> @djinn f :: ((Either a (a -> Void)) -> Void) -> Void
09:43:45 <lambdabot> Cannot parse command
09:44:00 <mniip> @djinn ?f :: ((Either a (a -> Void)) -> Void) -> Void
09:44:00 <lambdabot> Cannot parse command
09:46:17 <c_wraith> you're mixing in the free syntax. just give it the type.
09:47:47 <dminuoso> @djinn ((Either a (a -> Void)) -> Void) -> Void
09:47:47 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
09:49:40 <dminuoso> Wait.. what is `void` here?
09:49:48 <dminuoso> Is that `absurd`?
09:50:31 <lyxia> it is
09:50:56 <Solonarv> seems unneeded here, though
09:51:42 <fendor> Can I get a stack trace when executing `cabal new-test` and an exception is thrown?
09:53:27 <mniip> void is probably :: Void -> a
09:53:28 <mniip> here
09:53:57 <mniip> but yeah brainlet me is trying to figure out the double negation monad
09:54:26 <c_wraith> isn't that just a special case of continuations?
09:54:34 <Solonarv> yes, it's Cont Void
09:59:01 <asheshambasta> thanks by the way (dminuoso, c_wraith)
11:15:28 <Psybur> Ive never seen it so dead in here! I guess everyones at work
11:17:16 <MarcelineVQ> and/or lunch
11:22:07 * hackage ribosome 0.2.0.0 - api extensions for nvim-hs  https://hackage.haskell.org/package/ribosome-0.2.0.0 (tek)
11:24:34 <sternmull> As no one else is saying anything: Just for fun i read some Haskell code to see how much i understand. I am now looking at this: https://spockdocs.s3.eu-central-1.amazonaws.com/Spock-0.12.0.1/src/Web.Spock.Internal.Types.html#SessionManager
11:24:43 <sternmull> I wonder if others find it hard too to see what the type parameters all stand for? For example in SessionManager i guessed that m would be a Monad. But you can't know that until you see the constraint for sm_clearAllSessions.
11:25:08 <fendor> it is evening here
11:25:50 <sternmull> And st is a parameter that doesn't even get used.
11:26:52 <Solonarv> there are some conventions for naming type variables, 'm' being a monad is one of these conventions
11:27:28 <dmwit> conn isn't used either ;-)
11:27:29 <sternmull> yes, that and its usage made me guess it would be a Monad. But it took a while to see that confirmed.
11:28:16 <sternmull> dmwit: right. Looks like almost everything just gets this three parameters, regardless if needed or not.
11:28:50 <dmwit> At a guess: this is reserving the right to use it internally in future versions, even though it isn't used now. Defensive programming, so to speak
11:29:36 <[exa]> Psybur: everyone coding!
11:29:49 <dmwit> (Also possible that this is a backwards-compatibility thing, but that seems less likely to me, because if it were back-compat then I would expect to see some field only needed for that back-compat API that used conn.)
11:32:12 <sternmull> I don't really understand why sess and conn are used in this API at all. At least database connections are totally orthogonal to the web-stuff. And sessions probably would also be more flexible (allow different designs) when not baked into the API.
11:58:41 <bsima> does haskell have a library like python's celery?
11:59:01 <bsima> out-of-the-box processing queue
12:00:08 <Solonarv> I think there are some libraries in that space, yes
12:00:20 <Welkin> you mean rabbitmq bindings?
12:00:22 <Welkin> of course
12:00:28 <Welkin> also zeromq
12:00:32 <Welkin> probably activemq too
12:00:35 <Welkin> and kafka
12:00:47 <Welkin> you can also write your own message queue using Chan
12:00:50 <bsima> celery is self-contained, those are separate systems
12:01:17 <bsima> celery has some instrumentation around it that makes it easy to work with, i was hoping someone wrote similar instrumentation for Chan
12:01:27 <Solonarv> celery isn't just {rabbit,zero,active}mq bindings; I'm not familiar with what it is, exactly
12:01:50 <bsima> celery is all-python job queue
12:02:15 <bsima> i can be run as a separate system, or as an in-process library
12:03:37 <bsima> i guess i'll just use Chan
12:09:17 <Welkin> I wrote my own message queue with Chan
12:09:21 <Welkin> it was not fun to use
12:09:34 <Welkin> I ended up scrapping it and using an external system
12:09:56 <Welkin> well, I ended up using an erlang server that did it for me (XMPP)
12:12:04 <bsima> idk, this is just a quick and dirty data processing thing
12:13:01 <bsima> i need a message queue because i need to retry http requests, i keep getting throttled by this api
12:13:36 <bsima> throttling seems to be 10k requests/min, although this isn't in their docs afaict
12:13:51 <EvanR> one thing about Chan is you can't see the state of the chan, access the queue, save and restore a queue, survive a restart
12:14:07 * hackage ribosome 0.2.1.0 - api extensions for nvim-hs  https://hackage.haskell.org/package/ribosome-0.2.1.0 (tek)
12:14:14 <EvanR> for throttling, you can't control the size of a Chan
12:14:20 <EvanR> it will grow "forever"
12:14:21 <bsima> i'll use TChan
12:14:37 <EvanR> this all also applies to TChan
12:14:48 <bsima> i thought TChan was bounded?
12:14:48 <Welkin> why not use redis?
12:14:52 <Welkin> should be easy enoough
12:15:02 * EvanR looks at Welkin 
12:15:05 <Welkin> wait, that's not great for haskell
12:15:13 <Welkin> the redis haskell client is a nightmare
12:15:36 <EvanR> TChan is not bounded
12:15:43 <johnw> why not use a TBQueue?
12:16:12 <Welkin> a TBBBQ
12:16:24 <johnw> i mean, underneath it's just a pair of `TVar [a]`, one for (mainly) reading and one for writing
12:18:07 <bsima> ok, looks like TBQueue is the winner
12:18:17 <bsima> i really thought Chan had a bounded version...
12:18:42 <EvanR> STM stuff is usually a better default choice ime
12:18:52 <johnw> EvanR: very much agreed
12:18:59 <johnw> I almost never use non-STM concurrency structures anymore
12:19:02 <johnw> never an actual need to
12:19:05 <EvanR> when "things change" you now have more options that are compatible with what you already have
12:20:11 <EvanR> MVar is cool but is a very specific use pattern among many
12:20:33 <johnw> it can be used to solve the "thundering herd" problem, but that's a rare situation anyway (for me, so far)
12:21:16 <bsima> ah, here's the bounded Chan i was thinking of http://hackage.haskell.org/package/stm-chans-3.0.0.4/docs/Control-Concurrent-STM-TBChan.html
12:21:54 <EvanR> what is the diff between that and TBQueue
12:21:59 <bsima> TBQueue is the better choice though, it seems the only benefit of Chan over Queue is the ability to broadcast, which I don't need
12:22:17 <bsima> EvanR: 'dupChan'
12:32:09 <lamba> hello!
12:32:17 <lamba> I have the function: seedToBool :: Int -> Bool
12:32:23 <lamba> seedToBool = fst . random . mkStdGen
12:32:37 <lamba> but whatever Int i give it i am getting True as a result
12:32:49 <lamba> is this a bug or am I doing something wrong?
12:33:36 <tdammers> the latter, almost certainly
12:34:06 <lamba> actually i just tried it a bit more
12:34:15 <lamba> and the larger ints result in false
12:34:39 <lamba> but I would think this would have a random output given consecutive ints
12:34:57 <tdammers> pseudorandom at best
12:35:11 <lamba> it's not pseudorandom even
12:35:13 <MarcelineVQ> to be fair it's a new seed each time
12:35:21 <tdammers> yese
12:36:02 <Solonarv> there might be some weirdness because it's the first value you're pulling out of the RNG, dunno
12:36:22 <tdammers> that would be my guess too
12:36:50 <tdammers> > let seedToBool = fst . random . mkStdGen in map seedToBool [0..10]
12:36:52 <lambdabot>  [9106162675347844341,7918028818325808681,-2493429425036973456,55418564053097...
12:37:01 <lamba> you want bools
12:37:04 <tdammers> > let seedToBool = fst . random . mkStdGen in map seedToBool [0..10] :: [Bool]
12:37:05 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True]
12:37:09 <lamba> yup
12:37:18 <lamba> it switches at 53668
12:37:24 <lamba> then they become falses
12:37:59 <tdammers> > let seedToBool = fst . random . snd . random . mkStdGen in map seedToBool [0..10] :: [Bool]
12:38:01 <lambdabot>  error:
12:38:01 <lambdabot>      • Could not deduce (Random a0) arising from a use of ‘random’
12:38:01 <lambdabot>        from the context: Random c
12:38:18 <lamba> ya i was thinking of chaining it twice
12:38:21 <tdammers> > let seedToBool = fst . random . (snd :: (Int, Int) -> Int) . random . mkStdGen in map seedToBool [0..10] :: [Bool]
12:38:23 <lambdabot>  error:
12:38:23 <lambdabot>      • Couldn't match type ‘StdGen’ with ‘Int’
12:38:23 <lambdabot>        Expected type: Int -> (Int, Int)
12:38:24 <lamba> i think that would fix it 
12:38:35 <tdammers> > let seedToBool = fst . random . (snd :: (Int, a) -> a) . random . mkStdGen in map seedToBool [0..10] :: [Bool]
12:38:37 <lambdabot>  [False,True,False,True,True,False,True,False,True,True,False]
12:38:41 <lamba> but still is the behavior a bug or what?
12:39:07 <tdammers> not a proper bug in the sense that neither random nor mkStdGen make explicit promises
12:39:17 <lamba> hmmm I see
12:39:32 <tdammers> it does seem to be a consequence of the seed being used more or less directly to derive the first output value from
12:40:17 <tdammers> that said, if you need more control over the RNG, you probably shouldn't be using System.Random anyway, exactly because it provides so few promises
12:40:57 <lamba> yeah it's not really for anything that's sensitive I just wanted random looking trues and falses
12:41:48 <lamba> I hope no  one relies on this
12:41:52 <tdammers> so the usual way you'd go about this is have one PRNG that you seed once, and then you'd pull a chain of bools out of that
12:42:01 <lamba> yeah 
12:42:15 <lamba> i also tried hashing the int first
12:42:15 <tdammers> > randoms . mkStdGen $ 0
12:42:17 <lambdabot>  [9106162675347844341,-5782012937088350469,3531325756418318423,-5618565702727...
12:42:20 <tdammers> > randoms . mkStdGen $ 0 :: [Bool]
12:42:22 <lambdabot>  [True,True,True,False,False,True,True,True,True,False,True,False,False,False...
12:42:29 <lamba> but hash from hashable keeps the ints the same in the beginning
12:42:49 <lamba> I needed Int -> Bool that's why im doing this
12:42:53 <lamba> same int, same bool
12:42:57 <tdammers> hash from Hashable isn't meant to produce a lot of entropy
12:43:17 <lamba> i think they might be using it in system.random
12:43:23 <lamba> but im not sure
12:43:31 <iqubic> Does ghcjs create readable JS files?
12:43:58 <lamba> iqubic: don't think so
12:44:00 <yushyin> no but does readable JS exist?
12:44:02 <[exa]> iqubic: i'd be extremely surprised
12:44:02 <tdammers> https://hackage.haskell.org/package/random-1.1/docs/src/System-Random.html#mkStdGen here you go
12:44:22 <iqubic> I see. That sorta sucks.
12:44:31 <[exa]> tdammers: hash can not produce entropy by definition right?
12:44:42 <lamba> right
12:44:58 <iqubic> I don't want to create a program that only I can maintain.
12:45:10 <lamba> but it can still satisfy the cryptographic definition of a hash function
12:45:11 <[exa]> iqubic: no one maintains compiled code
12:45:29 <lamba> which is given some seed the output is indistinguishable from random
12:46:20 <lamba> [exa]: I think he means js developers will work on it
12:46:20 <Solonarv> (but the one from hashable generally doesn't)
12:46:38 <iqubic> [exa]: right. But if I give this JS code to some other people, to live on their website, and they expect to be able to look at and help me find bugs and such.
12:46:53 <lamba> is there a simple Int -> Int hash function with that property I can use?
12:47:09 <lamba> I don't really need this but maybe if I one day did
12:47:11 <iqubic> These other people won't be expecting a garbled mess.
12:48:29 <lamba> iqubic: I think purescript tries to generate something reasonable (but i'm not sure)
12:49:30 <bifunc2> How do I serialize an Int (or Int32 or Int64) such that it's guaranteed to be the same representation as C's unsigned int or size_t?
12:50:00 <johnw> you fromIntegral to convert it to CUInt
12:50:21 <johnw> which means using Int32 or Int64 as the source
12:50:46 <bifunc2> and how to take that to ByteString?
12:51:00 <johnw> there is a ByteString builder for all the numerical types
12:51:00 <lamba> tdammer: thanks
12:51:11 <iqubic> lamba: I know, but I can't use reflex-dom in purescript, now can I?
12:51:18 <lamba> no
12:52:25 <merijn> bifunc2: You want to use the binary package for serialisation of binary data
12:52:25 <iqubic> But if I'm doing web development, I might as well learn something closer to JS.
12:52:42 <merijn> bifunc2: That also supports easy deserialisation, handling different endianness, etc.\
12:52:52 <paf31_> I think concur is quite similar to reflex but I’m not an expert
12:53:16 <yushyin> just pretend you ship compiled code and don't bother with the JS. In the future it will be real wasm bytecode.
12:53:21 <bifunc2> sweet
12:53:49 <johnw> I like `serialise`
12:53:53 <bifunc2> C's unsigned int and size_t on most CPUs nowadays are little-endian, right?
12:54:20 <iqubic> What is going to be real wasm bytecode?
12:54:30 <iqubic> yushyin: ^^^
12:54:35 <Solonarv> the web app you ship
12:54:49 * johnw is coding in Wasm at this very moment
12:54:57 <merijn> bifunc2: Note that the Binary class in Data.Binary has it's own specific encoding format with headers and isn't suitable for interoperation with other languages/existing formats. For serialising existing formats just explicitly use Data.Binary.Get and Data.Binary.Put, rather than the derived Binary instances
12:55:06 <yushyin> Solonarv: iqubic: at least sometime in the feature I hope ^^
12:55:17 <iqubic> johnw: What are you doing in Wasm?
12:55:32 <yushyin> wasm ghc backend <3
12:55:32 <johnw> I'm writing code to generate Fibonacci values at each call to a "next" method
12:55:43 <iqubic> Interesting. Sounds cool.
12:55:45 <johnw> coding against this stack machine feels weird after so much Haskell
12:56:07 <merijn> bifunc2: Data.Binary.Get/Put are just your regular parser combinator style API, should be pretty straightforward if you've ever looked at (mega)parsec
12:56:10 <iqubic> What is a stack machine?
12:56:19 <iqubic> Ah, I see.
12:56:22 <johnw> Wasm operational semantics are defined against a stack machine spec
12:56:27 <iqubic> The Wasm stack machine.
12:56:56 <johnw> yeah, and writing in this pseudo-Lisp is odd too
12:57:05 <[exa]> iqubic: if you want to actually touch javascript, go for purescript. People don't think in continuations.
12:57:08 <johnw> but it's almost working; Haskell code calls into it
12:57:21 <iqubic> [exa]: I'll look into that.
12:58:02 <iqubic> How hard is it to pick up purescript coming from a background in haskell?
12:58:30 <[exa]> lambdabot: cryptographically, there are functions that generate `keystream' which, given some time after the initial seed is forgotten, can not be predicted efficiently from just observing the values
12:58:46 <[exa]> lambdabot: (all stream ciphers are such functions)
12:58:52 <[exa]> oh noes
12:58:59 <Solonarv> (why are you talkng to lambdabot ?)
12:59:07 <merijn> [exa]: I'm sure lambdabot appreciates the explanation ;)
12:59:09 <[exa]> lamba parted and I didn't notice tab
12:59:15 <MarcelineVQ> Bots that don't get attention start to rust
12:59:36 <gentauro> and another "FP" gets "bullied" out of his job position. I guess my logo, made in 2014, will forever stay relevant :'( -> http://blog.stermon.com/articles/2014/03/29/software-equality.html
12:59:42 <lambdabot> neat!
12:59:51 <gentauro> I hope one day, we get nominated for the Oscars xD
13:00:50 <bifunc2> merijn that's perfect, thanks!
13:01:00 <MarcelineVQ> I too speak almost exclusively in non-sequiturs purple monkey dishwasher.
13:08:07 <koz_> MarcelineVQ: LOL.
13:17:49 <gentauro> any built-in function that can transform strings from `PascalCase` to `camelCase`? Example: `FooBar` => `fooBar`?
13:18:37 <merijn> gentauro: "\(c:cs) -> toLower c : cs"? ;)
13:18:59 <merijn> Add another case for empty list, and done :p
13:19:10 <gentauro> merijn: was just going to write that :P
13:20:13 <Solonarv> uncurry (<>) . first (fmap toLower) . splitAt 1 -- unnecessary pointfree
13:21:16 <nshepperd1> over _head toLower
13:22:45 <gentauro> % :t _head
13:22:45 <yahb> gentauro: (Cons s s a a, Applicative f) => (a -> f a) -> s -> f s
13:23:54 <nshepperd1> :t over _head toLower
13:23:55 <lambdabot> Cons t t Char Char => t -> t
13:24:11 <Solonarv> > over _head toLower "BlahBlah"
13:24:13 <lambdabot>  "blahBlah"
13:24:21 <Solonarv> > over _head toLower ""
13:24:23 <lambdabot>  ""
13:27:47 <iqubic> What does "Const t t a a" do?
13:28:17 <iqubic> Or rather what does that constraint imply.
13:28:37 <merijn> iqubic: Note: it's Cons, not Const
13:28:53 <iqubic> I did not note that.
13:29:17 <iqubic> So what does "Cons s t a b" imply?
13:29:31 <gentauro> and we got a winner -> 22:19 < Solonarv> uncurry (<>) . first (fmap toLower) . splitAt 1 
13:29:40 <Solonarv> iqubic: it's a typeclass from lens
13:29:44 <gentauro> Solonarv: how do you come up with this? :|
13:30:06 <Solonarv> it's for sequence-ish things where you can "take off" the first element
13:30:18 <iqubic> So like a list?
13:30:26 <Solonarv> yes
13:30:33 <iqubic> Or a stack I'd assume.
13:30:37 <slack1256> or Data.Sequence
13:30:38 <Solonarv> or a Text, or a ByteString, or a Vector, ...
13:30:49 <iqubic> Where you can pop and push the top.
13:31:04 <Solonarv> actually, [] (lists) is pretty stack-like already ;)
13:31:54 <iqubic> I know. Heh.
13:32:12 <MarcelineVQ> \xs -> concat [toLower c : cs | (c:cs) <- [xs]]
13:32:25 <iqubic> We have (:) = push, and head = pop.
13:32:43 <iqubic> If I'm thinking about this properly.
13:32:58 * EvanR cringes at pop = head
13:33:21 <EvanR> friends don't let friends pop with head
13:36:13 <slack1256> Mmmmm I don't know if that is an actual advice against `head` or some double-entendre
13:37:34 <EvanR> pop (x:xs) = x, pop [] = monkeysFlyOutOfYourNose
13:43:02 <iqubic> attempting to pop an empty list would be an ill advised thing to do.
13:43:13 <iqubic> I think it would result in a stack underflow error.
13:43:15 <EvanR> agreed
13:43:25 <iqubic> Stack underflows are no good.
13:43:27 <EvanR> about ill advised
13:43:31 <iqubic> Ah.
13:43:38 <iqubic> What is a stack underflow?
13:44:00 <EvanR> a thing in C implementations
13:44:03 <iqubic> I know that a stack overflow is a place to ask coding questions.
13:44:17 <iqubic> That's a joke response.
14:30:55 <monochrom> Haha today's xkcd is great. Next time someone gives you screenshot of code here (instead of code) you can point them to today's xkcd!
14:31:11 <EvanR> link?
14:31:20 <monochrom> https://xkcd.com/2116/
14:33:09 <merijn> monochrom: As of 2 years ago our compiler construction has a rule in the syllabus that source code can only be submitted as plain text, due to multiple 3rd year CS students submitting code as a PNG embedded in a PDF...
14:33:30 <merijn> I argued that was sufficient reason to fail them, but apparently I'm not allowed to do that without a rule in the syllabus...
14:33:51 <monochrom> Oh wow. I've only got students doing screenshots when they ask me questions in email.
14:34:44 <jackdk> I've had those too
14:34:51 <EvanR> you laugh now, but future browser developers who must support that format are crying
14:35:50 <jackdk> merijn: I'm scared to ask, but have you used that rule since it was introduced?
14:36:10 <EvanR> also source code in the form of printed listings in the back of a book are not unheard of
14:36:14 <merijn> jackdk: I wasn't involved with grading last year, so I don't know what happened
14:36:23 <monochrom> But if the assignment is non-code written work, e.g., proofs, some sent in Word files. 
14:36:37 <merijn> monochrom: We switched to a whitelist of formats
14:37:12 <merijn> monochrom: Because people would use all sorts of weird ass archive/compression formats that we'd have to install tools for (like 7zip, rather than just using something everyone has)
14:37:27 <monochrom> Yeah the only sane way to go as soon as you get more than 100 students and the law of large numbers kick in and you will get an intractible number of disobedient students.
14:38:01 <merijn> monochrom: So as of 4 years ago we only allow plain text and PDF documents and only tar/bzip2/gzip/zip for archiving (or a mix of those)
14:38:12 <monochrom> And yeah remember to state it in the course policy on the very first day!
14:38:57 * EvanR submits a PDF archived in a nested gzipped, bzipped, zip file to merijn 
14:39:05 <merijn> monochrom: Hell, this was just 30 students >.>
14:39:43 <jackdk> note to self: send merijn assignment written in works 2.0 for DOS, compressed with a 16-bit PKSFX
14:40:03 <monochrom> haha that's krad
14:41:47 <monochrom> Consider http://www.retroarchive.org/cpm/text/text.htm >:)
14:42:10 <merijn> EBDIC or whatever the right spelling was
14:46:11 <EvanR> what is the idiomatic variable name to use instead of keyword "class"
14:46:39 <edmundnoble> `klass` is the Java answer
14:46:54 <EvanR> kool
14:47:08 <monochrom> Interesting.
14:50:45 <Solonarv> also vaguely acceptable: cls, clazz, clz
14:51:36 <edmundnoble> qlass if you're fancy
14:51:38 <monochrom> klaß
14:58:24 <EvanR> after writing 5% of the basic routines for a database consisting of a big record of IntMaps, i suddenly want to write a language to generate the haskell code 
14:58:56 <EvanR> is that weird
14:58:57 <Solonarv> you can generate Haskell using Haskell
14:59:03 <Solonarv> that's what template haskell is
15:00:06 <EvanR> makes too much sense
15:03:26 <geekosaur> although if it's one-shot I may write a quick script to generate it instead, possibly in a different language
15:05:23 <EvanR> well then you might add to the result manually, need to change the seed, then have to manually merge the updated output with your manual additions
15:06:04 <EvanR> but yeah having readable haskell code in the end would be nice, TH does not look that way
15:10:25 <bsima> does anyone use mapConcurrently in the real world? I always hit throttling limits
15:15:58 <yushyin> geekosaur: https://www.reddit.com/r/haskell/comments/aur7hz/help_wanted_on_haskell_wiki_skin/ so I didn't imagine it.
15:16:31 <slaterr> Yes | No | Uknown <- how would you name this type?
15:16:43 <slaterr> Unknown*
15:17:28 <bsima> slaterr: Triplean
15:17:35 <bsima> as opposed to boolean
15:17:41 <geekosaur> I'd be tempted to use Maybe Bool, depending on context
15:17:46 <MarcelineVQ> Asking what name would you give it, or what is that pattern called?
15:17:53 <geekosaur> (this of course would partake of boolean blindness though)
15:18:03 <EvanR> the road to FHIR "null flavors"
15:18:35 <bsima> data Quadrean = Yes | No | Maybe | Probably
15:19:06 <slaterr> MarcelineVQ, both
15:19:55 <slaterr> googling triplean gives odd results :P
15:19:58 <MarcelineVQ> naming-wise since you went to the trouble of making a new datatype I would name it something that relates to the context you're using it in, like FooResult where Foo is something that uses or creates a FooResult
15:20:16 <Solonarv> UncertainBool :P
15:21:27 <MarcelineVQ> You see that a lot with custom error types for example
15:21:39 <yushyin> slaterr: 3 valued logic, sometimes called trilean?
15:21:49 <Solonarv> go even further and use 'newtype LogOdds = LogOdds Double' instead :P
15:21:54 <Solonarv> now you can do math with it!
15:21:58 <MarcelineVQ> data InputError = NoParse | NoInput | InputTooLarge etc
15:22:57 <MarcelineVQ> parse :: String -> Either InputError a
15:23:48 <slaterr> MarcelineVQ, the value I am using now is boolean, defaulting to False (which is a bit problematic). so I think a generic Triplean/Trilean data type would suffice
15:24:10 <slaterr> the type I am using now is Bool, even
15:24:48 <Solonarv> if you don't mind the boolean blindness, Maybe Bool seems reasonable
15:39:32 <wroathe> Cale: I decided the problem was StateT and do notation: https://gist.github.com/JustinChristensen/cbbf8ee1903662831626796b035732b7
15:40:08 <wroathe> and ended up taking your advice
15:40:31 <boj> @hackage theese -- slaterr 
15:40:32 <lambdabot> http://hackage.haskell.org/package/theese -- slaterr
15:41:19 <boj> @hackage these -- slaterr 
15:41:19 <lambdabot> http://hackage.haskell.org/package/these -- slaterr
16:08:09 <MarcelineVQ> who knows what letter this is at a glance without googling 𝒮
16:10:59 <hpc> i blame cursive for that one
16:11:12 <MarcelineVQ> the cursive I learned didn't look like that :(
16:11:22 <hpc> mine did i thiiiiiiiink
16:11:26 <hpc> but that was like 20 years ago
16:11:27 <MarcelineVQ> mine looked more like flipped &
16:11:42 <MarcelineVQ> Anyway that's right, it's your old friend, the 2nd most common letter in english use, s.
16:12:10 <MarcelineVQ> unicode, why do you let people do this to each other ;_;
16:12:45 <clever> MarcelineVQ: it doesnt even render in my irc client
16:14:27 <glguy> clever: https://imgur.com/a/qNH7oFJ
16:14:46 <MarcelineVQ> I much prefer that font you have there
16:15:49 <clever> glguy: ah, now it sorta looks like an s
16:15:51 <MarcelineVQ> the one I have makes it look like f, or p, or j, or y
16:15:55 <geekosaur> yeh, in my current font that looks more like an "illuminated" italic J
16:16:02 <clever> but thats the job of a font, not unicode!
16:16:13 <clever> just choose a cursive font, dont make up a whole new unicode range!!
16:16:42 <glguy> Next you'll tell me I need a capital letter font
16:40:23 <dyl> MarcelineVQ that's Mathematical Script Capital S, no?
16:40:36 <dyl> (or just Script Capital S if it's one where the sets overlap.)
16:41:19 <dyl> aka \mathcal{S} :p
16:46:37 <MarcelineVQ> could be. it's unfortunate, whatever it is
17:26:45 <mjrosenb> if a set is tree-like internally, I wonder if there's something faster than deleteFindMax / deleteFindMin which operates on whatever node is easiet to access
17:27:45 <Solonarv> what's that supposed to do? just more-or-less arbitrarily pick a node to remove?
17:27:56 <mjrosenb> yup.
17:28:13 <clever> i'm trying to make a list of data records, that hold functions, each item in the list can operate on a different type from other elements in the list, how would i do that?
17:28:14 <Solonarv> what do you want this for?
17:28:57 <Solonarv> clever: do these different types have anything in common?
17:29:42 <Solonarv> mjrosenb: are you perhaps trying to process a set in parallel somehow?
17:29:47 <clever> Solonarv: not really, https://gist.github.com/cleverca22/c3067ae427ef36a68ff35cfb5e55dfd7 is what ive started with, but i think that will force every s to be the same type
17:30:05 <mjrosenb> graph theory stuff, I have a set of nodes and a set of edges, and I want to find the connected components
17:30:30 <mjrosenb> so pick a node, search until the entire component is found, rinse repeat
17:31:01 <mjrosenb> I don't care what order I process the nodes in, since it'll only change the order of the results, and they're going back into a Set anyway
17:31:43 <Solonarv> splitRoot looks like it might be what you want
17:31:51 <mjrosenb> and the fact that there is an ordering on them is completely irrelevant to what they represent, so using the min or the max arbitrarialy seems silly.
17:32:26 <Solonarv> ah, not quite
17:32:29 <clever> Solonarv: i'm thinking i could change Dialog to be a class instead, and then not require s to be part of the type on line 7?
17:33:19 <Solonarv> clever: do you need to change the 's' anywhere?
17:33:41 <clever> Solonarv: i want to have the list contain both a `Dialog Foo` and a `Dialog Bar`
17:33:49 <Solonarv> yes, I got that part
17:33:56 <clever> and only the methods on Dialog care what the type is
17:34:07 <Solonarv> okay, that's what I was asking
17:34:28 <Solonarv> in that case you can change Dialog to 'data Dialog = forall s. Dialog { ... }'
17:34:35 <Solonarv> (the inside of { ... } is unchanged)
17:34:37 <clever> ah
17:34:46 <Solonarv> and remove the type parameter everywhere else
17:35:21 <clever> data Dialog = forall s. Dialog
17:35:25 <clever>     Not a data constructor: ‘forall’
17:35:25 <clever>     Perhaps you intended to use ExistentialQuantification
17:35:37 <clever> flip that on?
17:35:38 <Solonarv> yes, turn that on
17:36:07 <Solonarv> somewhat confusingly, we encode existentials using 'forall' 
17:36:15 <clever> typechecks, though i now need to fill in all the missing code to actually use this
17:36:27 <Solonarv> aye
17:41:20 <dyl> Style question: when you have to go to a new line, do you leave = and -> on the same line, or drop it to the next one?
17:41:39 <dyl> f x =\n ... or f x\n= ...?
17:41:41 <dyl> (and likewise for case/->)
17:41:49 <sm> same line
17:41:56 <sm> for the love of god
17:42:41 <dyl> sm just wait, someone will come along and suggest the opposite :
17:42:44 <dyl> :p *
17:42:46 <sm> :)
17:43:16 <Solonarv> I actually can't recall a time I've had to newline immediately after/before a =
17:43:17 <sm> you can always obey whatever stylish-haskell does out of the box
17:43:35 <Solonarv> unless there was a do-block or other large construct involved, that is
17:43:41 <Solonarv> -> I leave on the same line
17:44:27 <mjrosenb> hrm, there does not appear to be a way to calculate (a \\ b, a `intersection` b) in one go.
17:45:38 <Solonarv> partition (`elem` b) a ?
17:45:44 <Solonarv> that should do it
17:46:18 <Solonarv> er, s/elem/member/
17:46:30 <Solonarv> assuming you're still talking about sets
17:47:44 <mjrosenb> yes, but I can't imagin that is actually more efficent.
17:48:38 <ibloom> Is there a library that allows you to map between an arbitrary lens traversal to an index and back?
17:49:00 <mjrosenb> huh, and sets don't have the powerful join-with-chaos functions that maps do.
17:49:25 <ibloom> Well say for example I have a tree and I want to assign an index to each node
17:49:45 <ibloom> I have lenses for each branch of every node.
17:50:10 <ibloom> I want to map from a composition of lenses to an index and from an index to a composition of lenses
17:50:30 <ibloom> Does that make any sense?
17:50:50 <Solonarv> I think so, but that mapping only work in one direction (index -> lens)
17:51:02 <Solonarv> at least with any of the common lens representations
17:51:34 <ibloom> Ok I have an idea for a typeclass that could maybe go the other way.
17:51:55 <ibloom> Still thinking about it but I was wondering if I’m reinventing the wheel
17:52:03 <lyxia> I don't understand what it means to go the other way.
17:52:08 <Solonarv> You still wouldn't be able to use any of the usual lens representations, you'd have to handroll something fairly complicated
17:52:21 <Solonarv> lyxia: imagine an inverse of 'ix'
17:53:22 <lyxia> Well there's no way you can do that, so I was assuming there was a less literal interpretation.
17:53:27 <ibloom> If I define a typeclass for each node that allows me to get the inverse though it seems like I could do it.
17:53:33 <Solonarv> i.e. 'unIx :: Traversal' m (IxValue m) -> Index m'
17:53:40 <Solonarv> No, it's not possible
17:54:21 <Solonarv> I'd suggest passing around indices instead and converting those into optics as needed
17:54:29 <Solonarv> (instead of the other way around, which is impossible)
17:55:36 <ibloom> Well I need to do both. I’m attaching an index to a foreign object and getting indices back, I’d like to use the exact same lens machinery on both sides.
17:56:16 <Solonarv> I still don't see why you can't just convert the inde to an optic when you need an optic
17:57:24 <ibloom> If it was just one layer of indexed optic that would make sense to me, but if the optic is a composition of various lenses, it seems less straightforward.
17:57:50 <Solonarv> If you pass the same index to the same <index-to-optic> function, you will get the same optic back anyway
17:58:18 <Solonarv> "less straightforward" is an understatement, it's impossible
17:58:47 <lyxia> This is starting to sound like an XY problem.
17:58:57 <Solonarv> yes
17:59:40 <dyl> sm It occurs to me I actually do put a newline before = sometimes.
18:00:07 <dyl> When I'm writing LH proofs I align "  =", "===", "***", etc
18:00:31 <ibloom> Ok, let me restate the problem. I have an arbitrary structure that I can traverse with a lens composition.
18:01:08 <ibloom> I have a traversal of the structure that generates a foreign object for each part of the structure and assigns an index to it.
18:01:33 <ibloom> My foreign code sends me back messages about objects and includes the index.
18:02:13 <ibloom> From that index I’d like to access the right part of the structure, using a lens composition.
18:03:06 <Solonarv> that's all very straightforward and doesn't require recovering an index from an optic
18:03:32 <ibloom> How would you go about it?
18:04:56 <Solonarv> step 1 is figuring out what the "index" type is
18:05:17 <Solonarv> step 2 is writing a function which turns an index into an optic
18:05:40 <Solonarv> that's most of the work done
18:06:47 <ibloom> Is there a way to get an index with just an optic?
18:07:03 <ibloom> And the structure of course.
18:07:22 <Solonarv> No
18:10:23 <clever> Solonarv: `Cannot use record selector ‘dHandleEvent’ as a function due to escaped type variables`, but i think i can work around it, by storing a partially applied function (pre-give it s), and then the type wont care
18:10:23 <Solonarv> clever: yes, that works
18:10:23 <Solonarv> or you could pattern-match instead of using record selectors
18:10:24 <clever> Solonarv: the issue, is that i need to run dRender with the current value of sState, but i dont care what the type of the 2 is
18:10:51 <Solonarv> that's what I thought
18:11:00 <Solonarv> both approaches work
18:12:03 <clever> `go (Dialog{dRender,dHandleEvent,dState} : rest) = do` appears to also typecheck, i'll see how far this goes
18:12:25 <Solonarv> yup, that's what I meant by pattern-matching
18:12:41 <clever> partial application feels worse, because i have 2 functions that need the state
18:13:03 <clever> and then the one updating the dialog has to know the un-applied version of the other
18:15:47 <clever> `foo <- dHandleEvent dState event` yeah, seems to work, even when i dont directly have access to the type
18:17:55 <clever> dang, Brick.Types.Internal isnt exported!!
18:26:37 * hackage b9 0.5.62 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-0.5.62 (SvenHeyll)
18:29:06 <mjrosenb> ugh, are sets not monads?
18:29:34 <lyxia> nope
18:30:13 <lyxia> not in Haskell
18:30:36 <mjrosenb> Is there a function on set that does the equivalent of join on sets?
18:31:01 <mjrosenb> hrm, /me looks at unions again
18:31:34 <mjrosenb> oh, it just takes a Foldable (Set a), not a [Set a]
18:33:20 <maerwald> mjrosenb: are you looking for forM?
18:33:36 <Solonarv> actually, the type of join would be: Set (Set a) -> Set a
18:34:21 <mjrosenb> yeah, unions does what I want.  As stated, I thought it took [Set a], not something which a Set is.
18:34:29 <mjrosenb> I sincerely hope that sets are foldable.
18:36:05 <Solonarv> they are
18:36:46 <mjrosenb> good good.
18:41:34 <mjrosenb> ugh, did Set.unions *used* to have a different type?
18:42:13 <Solonarv> it was probably less general at some point
18:42:48 <mjrosenb> I bet the version of GHC that I'm using actually took a list rather than a foldable
18:42:51 <mjrosenb> :-(
18:43:03 <Solonarv> what version are you on?
18:43:45 <mjrosenb> 7.10.3, it would appear.
18:44:05 <Solonarv> wow, that's quite old
18:44:30 <Solonarv> I'd suggest upgrading, unless you have something tying you down to that version
18:45:27 <mjrosenb> I'm using the nix pkg provided by miso
18:45:34 <mjrosenb> and I have absolutely no clue how it works
18:45:43 <mjrosenb> so I'm kinda afraid to randomly touch it.
18:45:49 <Solonarv> huh
18:46:01 <Solonarv> seems weird that that would come with such an old ghc, but I've never used t
18:50:22 <geekosaur> if thta was current when you installed nix, you have to explicitly install a later one
18:51:23 <geekosaur> and then specify which one you want to use in particular nix formulas
18:51:31 <mjrosenb> no, miso provides a nix file that pins itself and ghc
18:51:39 <mjrosenb> well,
18:51:40 <mjrosenb> ghcjs
18:51:54 <geekosaur> oh. ghcjs is a problem with respect to versioning, yes
18:52:10 <rotaerk> really don't understand why runReaderT, runStateT etc expect the ReaderT/StateT value *before* the environment or initial-state
18:52:11 <geekosaur> there's apparently some ghc8 branches, with problems
18:52:26 <rotaerk> would be so convenient to just say:  runReaderT blah $ do ...
18:52:40 <rotaerk> but no, gotta flip and such
18:52:53 <geekosaur> because you might apply the same computation to different vlues
18:52:59 <geekosaur> which I've done in a number of cases
18:53:55 <rotaerk> I suppose
18:54:01 <Solonarv> more practically: because they're record selectors
18:54:03 <geekosaur> think about applying a computation representing a simulation to different initial states
18:54:46 <geekosaur> which is what I was doing. also computing timelines for various time periods, where the timeline description is invariant
19:06:09 <dmj`> Is it known that the frameworks field in Cabal is broken?
19:13:37 * hackage confcrypt 0.2.3.0 -   https://hackage.haskell.org/package/confcrypt-0.2.3.0 (ChrisCoffey)
19:14:20 <dmj`> I forget if there is a cabal channel
19:14:38 <sclv> #hackage
19:15:04 <Solonarv> there is also a cabal channel, but its topic tells you that #hackage is more active
19:20:52 <dmj`> sclv: thanks
19:59:44 <Axman6> ANyone know if there's ever been a proposal for OverloadedChars? parser combinators woulod be even nicer with it; (,,) <$> 'a' <*> 'b' <*> 'c'
20:03:44 <iqubic> How would overloaded chars work?
20:04:29 <iqubic> Would it be like overloadedStrings, but for chars?
20:10:20 <Axman6> yes...
20:17:41 <slack1256> That actually looks like a sensible extension
20:20:07 * hackage antiope-athena 6.4.0 -   https://hackage.haskell.org/package/antiope-athena-6.4.0 (arbornetworks)
20:21:07 * hackage antiope-contract 6.4.0 -   https://hackage.haskell.org/package/antiope-contract-6.4.0 (arbornetworks)
20:22:07 * hackage antiope-core 6.4.0 -   https://hackage.haskell.org/package/antiope-core-6.4.0 (arbornetworks)
20:23:07 * hackage antiope-s3 6.4.0, antiope-messages 6.4.0, antiope-dynamodb 6.4.0 (arbornetworks)
20:24:07 * hackage bytestring-trie 0.2.5.0 - An efficient finite map from (byte)strings to values.  https://hackage.haskell.org/package/bytestring-trie-0.2.5.0 (WrenRomano)
20:24:08 * hackage antiope-sqs 6.4.0, antiope-sns 6.4.0 (arbornetworks): https://qbin.io/reform-shield-0lsa
20:43:29 <jpg> Hello guys. Is lhs2TeX broken when dealing with promoted lists and tuples (using -XDataKinds)?
20:44:09 <jpg> I can compile my doc only with --verb
20:47:04 <jackdk> Axman6: your mission, should you choose to accept it, is to write the proposal
20:47:07 * hackage servant-namedargs 0.1.1.0 - Combinators for servant providing named parameters  https://hackage.haskell.org/package/servant-namedargs-0.1.1.0 (CullinPoresky)
20:51:39 * hackage servant-server-namedargs 0.1.1.0 - Automatically derive API server functions with named and optional parameters  https://hackage.haskell.org/package/servant-server-namedargs-0.1.1.0 (CullinPoresky)
20:52:37 * hackage servant-client-namedargs 0.1.1.0 - Automatically derive API client functions with named and optional parameters  https://hackage.haskell.org/package/servant-client-namedargs-0.1.1.0 (CullinPoresky)
22:32:12 <maerwald> what's the idiomatic way to build a uri where components of the uri could be of different types and stuff shouldn't break randomly during refactoring
22:32:28 <maerwald> currently there is 'show', which works for Int, but not for String
22:32:55 <maerwald> I was expecting something like that to be in network-uri
22:33:04 <maerwald> but I guess a printf-like library would be the better way?
22:34:31 <Axman6> I think servant provides something for that
22:35:21 <maerwald> I don't use servant
22:37:39 <Axman6> well, it has a type class for exactly what you're after: https://hackage.haskell.org/package/servant-0.15/docs/Servant-Links.html
22:40:01 <Axman6> Also, in case you weren't away, Servant is for much more than just making web services - the servant package itself is basically just for describing APIs, independant of whether you implement them or if it's some other services' API
22:52:27 <maerwald> I'm not using servant for a utility
22:52:37 <maerwald> it's an entire framework, I'm not using it
22:53:46 <Axman6> Servant itself has very few deps, it's all the setuff your project is already going to pull if it's going to talk HTTP and use JSON already
22:54:19 <Axman6> if you just want string formatting, use formatting
22:54:42 <Axman6> but you asked asbout building URLs safely w3hich you can't guarantee with that
23:02:38 <maerwald> I am not going to use servant :)
23:08:06 <dminuoso> Axman6: Wow that is pretty nifty. Servant is really a micro library. :)
23:08:27 <dminuoso> I just understood why there were so many libraries.
23:15:00 <maerwald> I don't know how this turned into servant advertisement :o
23:16:02 <dminuoso> Frankly I don't care whether you use servant or not.
23:16:43 <maerwald> It's not a useful suggestion to install an entire framework for simple functionality ;)
23:16:48 <dminuoso> maerwald: It's not an entire framework
23:17:04 <maerwald> and too many dependencies and compile time are already a problem
23:17:19 <dminuoso> maerwald: servant consists of multiple small modular library. servant the base library is just a miniature URL as type API library.
23:23:30 <Axman6> maerwald: are you making HTTP requests?
23:23:39 <Axman6> are you using Aeson?
23:23:54 <Axman6> if so, you already have all the seme deps the servant library would bring it
23:24:22 <Axman6> you sweem to be dismissing it based on your impression of what it is, not the reality of what it is
23:24:39 <maerwald> Huh? no
23:24:49 <maerwald> I find it simply overkill 
23:26:40 <maerwald> And we use it for a pdf and email service
23:37:33 <abiduzz420> join
23:37:42 <abiduzz420> Hello
23:37:54 <abiduzz420> trying out freenode
23:40:13 <iqubic> It seems to be working. We can see what you are typing.
23:47:20 <chaoxu> so nub:: Eq a => [a] -> [a], one can define a nub:: Ord a => [a] -> [a]. Is there a haskell extension that allow both to exist, and the compiler automatically pick the stronger one depend on the type class of a?
23:52:35 <abiduzz420> Hello Hasekllers
