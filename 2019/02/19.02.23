00:00:34 <glguy> If you generate the subsequences from largest to smallest, you just need the first result that isSidon?
00:00:37 <cads> So maxSidon looks for the lorgest sidon set it in {1..n} as in this question:  https://math.stackexchange.com/questions/3123378/is-there-a-cleverer-way-to-find-the-largest-sidon-set-in-1-n
00:00:40 <cads> ?
00:00:50 <perfo> sorry, I'm a little lost here [ | x:xs <- list, y <- xs ] what is this doing?
00:01:07 <glguy> Oh, I left out tails
00:01:09 <perfo> yes I tried sorting by largest subseqence to smallest, but it decreased the runtime by x2
00:01:26 <glguy> Typing in Android is slow
00:01:47 <glguy> x:xs <- tails list
00:02:30 <glguy> Decreased runtime sounds great, I'm guessing you didn't mean that
00:03:11 <glguy> Did you still check them all after sorting or start finding the first match?
00:04:00 <perfo> Oops, yea I meant increased the runtime. I sorted the subsequences then filtered then did head
00:04:22 <unrooted[m]> morning
00:05:43 <glguy> Instead of sorting you ought to be able to generate them in the right order
00:08:15 <perfo> ah hmm lemme think about that for a bit
00:09:05 <unrooted[m]> so this is the Haskell Matrix chat, richtig?
00:09:33 <perfo> is there a clean way to do that in haskell? I can think of a way to do that with arrays and messing with bits
00:10:07 <sm> unrooted[m]: yes, also bridged to the main #haskell IRC channel
00:10:43 <cads> unrooted[m], whaaaaat, I could be in matrix instead of IRC?
00:10:55 <cads> that is amazing!
00:11:09 <unrooted[m]> nice then
00:11:28 <unrooted[m]> so, my name is Konrad, I've came here because I like Haskell and I'm just beginner, but I like it
00:11:41 <perfo> Thank you, glguy for your help, I'll use these tips and try to optimize the code more
00:11:58 <sm> cads, yup it's quite nifty
00:12:12 <sm> welcome unrooted[m] 
00:13:36 <utdemir> I want to create haddock documentation for multiple packages. What's the command I should use for that?
00:13:46 <utdemir> Using cabal-install btw.
00:22:01 <cads> perfo, I'm looking for OEIS entry for size of the largest sidon subset of [n] = {1..n}
00:28:41 <cads> perfo: It looks like there might be a greedy algorithm which generates the maximal sidon set
00:28:45 <AfC> unrooted[m]: Haskell is terrific, but it's also multiple overlapping communities across a huge design space. If something seems confusing or contradictory (ie when searching for advice "how do I") it probably is. Don't worry. It's definitely worth the learning curve.
00:29:32 <cads> wait, perfo is gone. Nooooooo! My brand new combinatorics friend! :(
00:30:20 <AfC> "my brand new combinatorics friend is gone". I should tweet that.
00:56:38 <dminuoso> Mmm, is (
00:57:05 <dminuoso> Mmm, is every lens representable by this? (\x -> ... x ...) <$> f x'
00:57:35 <dminuoso> (where f :: forall f. Functor f => a -> f a), and Im ignoring polymorphic lenses here.
01:00:45 <nshepperd> :t \get set f s -> set s <$> f (get s)
01:00:47 <lambdabot> Functor f => (t1 -> t2) -> (t1 -> a -> b) -> (t2 -> f a) -> t1 -> f b
01:06:16 <dminuoso> nshepperd: Oh interesting.
01:10:27 <dminuoso> nshepperd: Okay I think I can see the connection now.
01:11:17 <dminuoso> So if we consider: Lens s a ~ a -> Store a s ~ a -> Pretext a s
01:12:28 <dminuoso> Then we could encode some lens l with Store as: \a -> Store (set a) (get a), yours gives us the Pretext encoding.
01:12:38 <dminuoso> Am I somehow on the right track here?
01:15:00 <nshepperd> I was just thinking that basically, any lens is just a combination of getter+setter. and given a getter and setter you can write a lens in that form easily
01:16:10 <dminuoso> Well consider that: newtype Pretext s a = Pretext { runPretext :: forall f. Functor f => (a -> f a) -> s -> f s } deriving Functor
01:16:22 <nshepperd> so it seems like there's indeed a simple algorithm for writing any lens in that form you wrote
01:16:40 <dminuoso> Is equivalent to Store, and lenses are just coalgebras for Store
01:16:57 <dminuoso> so lenses are also coalgebras for pretext
01:18:20 <dminuoso> (Lens uses some Profunctor variant of Pretext I cant quite grasp)
01:19:01 <dminuoso> nshepperd: But your solution helped me get a real good hold I think.
01:19:04 <dminuoso> Thank you.
01:20:02 <dminuoso> So then I get: mkStoreLens get set a = Store (set a) (get a)
01:20:08 <nshepperd> I bet you could even algebraically prove that any lens is equivalent to '\f s -> set s <$> f (get s)' by using the lens laws and parametricity of the functor
01:20:55 <dminuoso> You have shown me: mkPretextLens get set f s = set s <$> f (get s)
01:21:11 <nshepperd> for some functions set,get
01:21:30 <dminuoso> Oh yeah, I tried to imply that with the variable names. :)
01:25:10 <dminuoso> nshepperd: Im going to figure out the Store ~ Pretext isomorphism (which I know already holds, but I want to see the from/to morphisms)
01:25:23 <dminuoso> Visually there's plenty of beauty here already.
01:26:09 <dminuoso> I had this thought where `\x -> ... x ...` was a representation of "the whole with a hole", and `f x` was a representation of `what went into the hole`
01:28:30 <dminuoso> And it occured to me, that the "splitting of data into a whole with a hole, and what went in there" is already described by setter/getter
01:38:07 <nshepperd> (Actually, it seems that parametricity of f and the Functor law by itself already tells us that myLens :: forall f. (Functor f) => (a -> f a) -> s -> f s... has to be equivalent to `myLens g s = _ <$> g _`)
02:11:31 <delYsid> Hmm, haskeline InputT does deriving (..., MonadIO, MonadCatch, MonadThrow, MonadMask), but these instances never appear.  Can those even be dervied automatically?
02:11:49 <dminuoso> delYsid: GND
02:12:23 <dminuoso> delYsid: GHC has an extension called GeneralizedNewtypeDeriving, which basically "copies" instances through the newtype wrapper.
02:14:18 <delYsid> ok, but that doesnt really explain why the instances are missing in (InputT IO)
02:14:28 <dminuoso> What do you mean by "missing"?
02:16:40 <delYsid> :i InputT doesn't have a MonadMask instance
02:17:25 <dminuoso> delYsid: Why would it need one?
02:18:02 <delYsid> I mean, (InputT IO) misses MonadMask, which is strange to me, since it appears to be derived, and IO has a MonadMask instance.  So I wonder, what is going on, and why didn't the compiler complain?
02:18:10 <dminuoso> delYsid: Oh. Are you sure you are looking at the correct version?
02:18:22 <slack1256> Is the documentation version correct?
02:18:28 <merijn> delYsid: Haskeline almost ertainly does not derive those
02:18:45 <merijn> delYsid: Haskeline does not depend on the exceptions package that defines those classes
02:18:49 <slack1256> checkout ghci :info to check the actual instances
02:18:59 <merijn> delYsid: I think you are looking at something very wrong
02:19:17 <delYsid> hmmm
02:19:43 <dminuoso> delYsid: What you may be looking at, is functions imposing MonadMask on m which is transformed by InputT.
02:19:45 <dminuoso> Say
02:19:53 <dminuoso> getInputCmdLine :: (MonadIO m, MonadMask m) => InsertMode -> TermOps -> String -> InputT m (Maybe String)
02:20:09 <delYsid> github.com/judah/haskeline System/Console/Haskeline/InputT.hs
02:20:19 <delYsid> so I picked the wrong repo at random again maybe
02:20:35 <dminuoso> delYsid: I find it useful to always look at hackage.
02:20:41 <dminuoso> You can usually view the source from there.
02:20:48 <dminuoso> It's less error prone. :)
02:21:11 <delYsid> bummer, because what I actually need is a MonadMask instance :-)
02:21:15 <merijn> delYsid: Oh, looks like the github version has started depending on exceptions *very recently*
02:21:22 <delYsid> so maybe this guy figured out how
02:21:26 <merijn> delYsid: Which means it's probably not released yet
02:21:34 <merijn> delYsid: What do you need MonadMask for?
02:21:57 <delYsid> merijn: InterpreterT
02:22:02 <delYsid> (hint)
02:22:22 <merijn> I have no clue what InterpreterT is
02:24:57 <delYsid> so I can probably pull this pkg via git with stack?
02:24:58 <dminuoso> Clearly an Interpreter monad transformer!
02:25:01 * dminuoso chuckles
02:26:25 <merijn> I think there are easier solutions than the difficulty you're attempting now, but without knowing what you are, in fact, trying to do it's hard to say
02:27:00 <dminuoso> nshepperd: Okay I worked out the other half of the Store s a ~~ Pretext s a isomorphism, things fit so nicely together.
02:27:23 <dminuoso> By the way, is there a non-profunctor encoding of Prisms?
02:27:35 <dminuoso> Or is Choice necessary?
02:54:18 <haasn> dminuoso: you can represent it as a review / view pair
02:54:23 <haasn> same as you can represent lenses as a get / set pair
02:57:31 <haasn> :t prism
02:57:32 <lambdabot> (Applicative f, Choice p) => (b -> t) -> (s -> Either t a) -> p a (f b) -> p s (f t)
02:59:15 <dminuoso> haasn: Im looking for a representation that gives me composition.
02:59:57 <haasn> You can compose a review / view pair, no?
03:01:06 <haasn> (using (.) and (>=>), respectively)
03:14:04 <dminuoso> haasn: the analogy is off though, since the first function to `prism` is not akin to view, its rather "build` since it's b -> t
03:14:06 <dminuoso> :t lens
03:14:07 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
03:15:33 <dminuoso> And for the (get, set) pair, those are definitely not composable.
03:16:28 <dminuoso> Anyway, I was just looking for something where you could freely compose prisms and lenses
03:22:02 <dibblego> you can, you just get a traversal
03:24:12 <slack1256> you can compose prisms and lens freely
03:25:19 <dminuoso> % second :: (Int -> Either Char Int, Either Char Int -> Maybe Int); second (Right, (\x -> case x of Right x' -> Just x'; _ -> Nothing))
03:25:19 <yahb> dminuoso: ; <interactive>:7:67: error:; Parse error: module header, import declaration; or top-level declaration expected.
03:26:13 <dminuoso> % second :: (Int -> Either Char Int, Either Char Int -> Maybe Int); second = (Right, (\x -> case x of Right x' -> Just x'; _ -> Nothing))
03:26:14 <yahb> dminuoso: 
03:26:42 <dminuoso> % right :: (Int -> Either Char Int, Either Char Int -> Maybe Int); right = (Right, (\x -> case x of Right x' -> Just x'; _ -> Nothing))
03:26:42 <yahb> dminuoso: 
03:26:46 <haasn> dminuoso: the first function to `prism` is the `review` half
03:27:00 <haasn> also what do you mean by compose? you can write your own `composeLens` function to compose any lens representation
03:27:08 <haasn> unless you meant composable by (.) directly?
03:27:39 <dminuoso> haasn: Oh sorry, you are right.
03:29:48 <dminuoso> haasn: but why do you say its review/view, what would "view" for a prism even be?
03:30:18 <adius> Hi, has anyone here used acid-state in a larger production setting? I know some people really dislike it, but I haven't heard any production hell insight yet.
03:31:19 <dminuoso> I learned that a prism could be considered as just data Prism s a = Prism { build :: a -> s, match :: s -> Maybe a }
03:31:33 <slack1256> adius: search for blog post on the old version of hackage that was backed by acid-state
03:31:45 <slack1256> they offer some insights on the scalability
03:31:55 <dminuoso> Or for a polymorphic version: data Prism s t a b = Prism { build :: s -> t; match :: b -> Either t a }
03:32:57 <dminuoso> the type is off
03:33:18 <dminuoso> % data Prism s t a b = Prism { build :: b -> t; match :: s -> Either t a }
03:33:18 <yahb> dminuoso: ; <interactive>:10:45: error: parse error on input `;'
03:33:27 <dminuoso> % data Prism s t a b = Prism { build :: b -> t, match :: s -> Either t a }
03:33:27 <yahb> dminuoso: 
03:33:37 <dminuoso> :t prism
03:33:38 <lambdabot> (Applicative f, Choice p) => (b -> t) -> (s -> Either t a) -> p a (f b) -> p s (f t)
03:34:31 <adius> slack1256: That's a good pointer, Thanks!
03:35:31 <dminuoso> % data Lens s t a b = Lens { view :: s -> a, update :: Either b s -> t }
03:35:31 <yahb> dminuoso: 
03:36:25 <dminuoso> haasn: these things dont look composable in that representation.
03:36:51 <dminuoso> Not in a generic fashion anyway
03:37:39 <dminuoso> % data Lens s t a b = Lens { view :: s -> a, update :: (b, s) -> t }
03:37:39 <yahb> dminuoso: 
03:46:07 * hackage ffunctor 1.0.0 - FFunctor typeclass  https://hackage.haskell.org/package/ffunctor-1.0.0 (fommil)
03:48:01 <Henson> does anyone have experience returning strings or arrays of strings from C functions to Haskell using the FFI?
03:57:07 * hackage language-ats 1.7.0.6 - Parser and pretty-printer for ATS.  https://hackage.haskell.org/package/language-ats-1.7.0.6 (vmchale)
04:16:02 <Henson> I finally figured it out.  I have to malloc a space for the string inside the C function, pass a pointer to it back to Haskell, and then get Haskell to call free on the string memory area once it's finished with it.
04:24:07 <Phyx-> No, don't do that. Allocate and free on the same side
04:24:25 <Phyx-> the memory allocators at the C side and Haskell side may not be the same
04:28:00 <Henson> Phyx-: I made a C function that frees the memory that is called by Haskell, so both the malloc and free occur on the C side, but the C-side free is initiated by Haskell.
04:28:12 <Henson> Phyx-: I can't allocate on the Haskell side because i don't know the size of the string a-priori
04:28:26 <Henson> Phyx-: the returned string, that is
04:31:46 <Phyx-> Henson: ah ok, that's fine then. An another approach that is often used is having the function return the lentgh of the string and take a pointer to the buffer for the string. when called with NULL, it'll just tell you how much space you would need to reserve to contain the string. It's not necissarily better than what you have now, but it means you keep things in one heap. less fragmentation.
04:33:35 <c_wraith> there's no fragmentation caused by mixing C-side allocation with haskell allocation.
04:33:48 <Phyx-> of course there is
04:33:53 <c_wraith> they use different heaps
04:34:11 <Phyx-> yes and both will allocate based on allocation granulatiry
04:34:26 <c_wraith> GHC reserves a chunk of memory for its own heap at program startup.  Nothing native code does will interfere with that
04:34:27 <Phyx-> both will reserve more memory then they need, while it could have easily fit into one page
04:34:46 <Phyx-> that's only for the MegaBlocks allocator
04:34:49 <Henson> Phyx-: I was trying to avoid multiple function calls, as the call to the function to get the list of strings is somewhat expensive, and I wanted to the function to be atomic
04:34:52 <Phyx-> the C allocators does its own thing
04:37:10 <FabianW> How come there's both fmap and map? Doesn't fmap basically do the same thing without being limited to lists?
04:37:59 <Phyx-> Henson: that's fair enough
04:41:59 <Henson> FabianW: fmap maps a function onto the contents of a Functor
04:42:33 <FabianW> Is a list not a Functor?
04:43:22 <Henson> FabianW: it is, and the implementation of fmap for list is just map.  But fmap can be used for other functors too, like Maybe.
04:43:48 <__monty__> FabianW: map is basically just there to provide clearer error messages to newcomers, along with a bunch of others like the folds.
04:45:18 <FabianW> __monty__: Oh alright, I was just wondering about why there's redundancy when some other functions are mercilessly abstract.
04:46:48 <FabianW> __monty__: The folds actually confused me when starting out, every book shows the type signature of it operating on lists, but the Prelude has the implementation for Foldables, so the type signatures don't match up when checking
04:47:34 <Henson> FabianW: "mercilessly abstract", I like that.
04:49:07 * hackage red-black-record 2.0.0.0 - Extensible records and variants indexed by a type-level Red-Black tree.  https://hackage.haskell.org/package/red-black-record-2.0.0.0 (DanielDiazCarrete)
04:50:49 <__monty__> FabianW: Ah, that must've changed at some point.
04:51:24 <__monty__> But yeah, fmap would've been named map in any other world.
05:09:37 * hackage red-black-record 2.0.0.1 - Extensible records and variants indexed by a type-level Red-Black tree.  https://hackage.haskell.org/package/red-black-record-2.0.0.1 (DanielDiazCarrete)
05:48:51 <TimoMeijer> For an exercise we were asked to implement a Traversable instance for a data type that wraps a function type, and I'm struggling to see if this is something that is even possible. If anyone could point me in the right direction, that'd be great! Code snippet: https://gist.github.com/TimoMeijer/23c9de7f9397838e3f2ded8a4b139260
05:58:41 <cads> hey is anyone here a fan of R?
05:59:54 <hpc> haven't used it for a while, but i enjoyed it when i had to use it for a class
06:00:10 <hpc> although that was in comparison to matlab/octave so who knows if i /actually/ like it
06:00:20 <cads> hehehe
06:00:47 <cads> I might have had a more relevant followup but I gotta run!
06:05:04 <dminuoso> TimoMeijer: Have you tried writing out the Foldable instance?
06:05:17 <dminuoso> TimoMeijer: (Because remember, Foldable being a superclass you need to try this first anyway)
06:11:28 <dmwit> TimoMeijer: http://hackage.haskell.org/package/universe-reverse-instances-1.0/docs/src/Data-Universe-Instances-Traversable.html
06:11:41 <dmwit> um
06:11:44 <dmwit> spoilers
06:12:21 <__monty__> hpc: You must like perl.
06:12:24 <dmwit> If you want a hint rather than the answer entire: you can run the function on every possible Char.
06:12:53 <dmwit> There's only a million of them or so. ;-)
06:14:14 <dminuoso> At that point, implementing the instance should beg the question of "what do I want this to do"
06:14:24 <dmwit> I'll admit I find it a bit surprising that you were asked to do this in an exercise. Are you sure you understood the exercise correctly?
06:15:11 <hpc> __monty__: i do like perl
06:15:59 <dminuoso> dmwit: Also running the function over every possible Char opens up the question of "in what order do you go over the Chars"
06:16:13 <dminuoso> Or do you even go over all of them?
06:16:33 <dmwit> (Like, even if you use my proposed solution, Get (\c -> Get (\c -> Get (\c -> Return ()))) is already trying to run the input function 1e18 times, not gonna happen.
06:16:36 <dmwit> )
06:16:55 <dmwit> dminuoso: Yes, you must go over all of them to satisfy the laws.
06:17:51 <dminuoso> dmwit: Which law would be violated?
06:17:59 <dmwit> runIdentity . traverse Identity = id
06:18:26 <dminuoso> Oh I can see why
06:20:05 <TimoMeijer> dminuoso: With Foldable you can still 'cheat' by using mempty for the get, but that trick doesn't work anymore for Traversable, and isn't a nice solution either, so the same problem arises here
06:21:39 <TimoMeijer> But as this is surprising to you alltoo, I'll bring it up with the teacher, if he might have made a mistake with the exercise ;)
06:26:08 <deltasquared> man, I love the concurrency that falls naturally out of IO and monads basically being continuation passing style transformation...
06:26:13 <dmwit> ?pl (,) x <$> f x
06:26:13 <lambdabot> (,) x <$> f x
06:26:17 <dmwit> ?pl \x -> (,) x <$> f x
06:26:17 <lambdabot> liftM2 (<$>) (,) f
06:27:11 <deltasquared> after much knocking around on #nixos to resolve some cabal problems, finally wrote my own HTTP hello world of sorts using warp... https://ptpb.pw/Klj1.hs
06:27:14 <dmwit> Dang. I could have made my code even *more* unreadable and I missed my chance.
06:27:29 <deltasquared> dmwit: securing your future job role? ;)
06:27:56 * deltasquared wonders what could be made more unreadable, haskell or perl
06:28:05 <dmwit> :t traverse . liftA2 fmap (,)
06:28:06 <lambdabot> (Applicative f, Traversable t) => (a1 -> f a2) -> t a1 -> f (t (a1, a2))
06:56:37 * hackage shellmet 0.0.0 - Out of the shell solution for scripting in Haskell  https://hackage.haskell.org/package/shellmet-0.0.0 (shersh)
07:56:55 <shardguy> Hey, I've written a tail recursive function that lists all directories within a list of directories. It works really well and it's fast, but my question is, what "pattern" is this? It's not really a fold, maybe someone can recognize it?
07:57:07 <shardguy> https://pastebin.com/Rn6bych9
07:57:36 <Welkin> this package is giving me trouble https://hackage.haskell.org/package/bytestring-trie-0.2.4.1
07:57:54 <Welkin> the base upper limit is too low. I'm using 4.12
07:58:13 <Welkin> but also, what is with the crazy version spec? `base (<2.2 || >=3 && <4.11)`
07:58:30 <Clint> pretty crazy
07:58:42 <Welkin> how do I get thi bumped?
07:58:49 <Welkin> the source repo (on darcs) doesn't even load
07:58:52 <Welkin> and it's on darcs
07:59:37 <Welkin> last updated 2015, last bumped a year ago
07:59:37 <Clint> since phadej set the upper limit i would assume it probably needs the source fixed
07:59:58 <Welkin> I've never seen this library before, but one library I want to use requires it
08:00:15 <Clint> file an issue with the trustees
08:00:29 <Welkin> where is that?
08:01:12 <Clint> https://github.com/haskell-infra/hackage-trustees/issues
08:01:28 <Clint> although there's already one
08:02:03 <Clint> so you just need to wait for february 52
08:02:51 <Welkin> lol
08:03:02 <Welkin> 25th I think he means
08:03:09 <Welkin> so there is at least a process
08:03:11 <Welkin> that's good
08:03:25 <Welkin> so abandoned packages won't be abandoned forever
08:03:41 <Welkin> I'm not waiting though, so I'l fork it
08:04:32 <Welkin> oh wait
08:04:39 <Welkin> how do I fork a darcs repo in git?
08:04:55 <Welkin> download the files manually and start a new one I guess
08:05:37 <Athas> There used to be a Darcs-to-Git converter that worked OK.
08:11:43 <shardguy> nobody recognizes this pattern? https://pastebin.com/Rn6bych9
08:12:11 <shardguy> I'm trying to find out what common pattern this is, e.g it's not a fold but similar.
08:12:35 <Solonarv> I recognize it, but I don't have a name for it
08:18:49 <shardguy> hmm I thought this would be a common pattern
08:20:38 <Heffalump> shardguy: you can probably write it as  afoldM
08:21:21 <Welkin> is this a correct suggestion? https://bpaste.net/show/73e4a4bafffa
08:21:30 <Welkin> replace inlinePerformIO with unsafePerformIO?
08:22:06 <Welkin> I've never heard of inlinePerformIO, but supposedly it's deprecated
08:27:09 <Welkin> since when was Data.Semigroup.append .++. ?
08:27:17 <Welkin> what happened to <> ?
08:27:18 <arjen-jonathan> If I combine ST with other monads, like error and state, should ST be on the inside?
08:27:27 <shardguy> Heffalump: I don't think that's possible though, as foldM only updates the result, whereas this function also updates its input list as it traverses the directories.
08:27:30 <Welkin> :t (<>)
08:27:31 <lambdabot> Monoid m => m -> m -> m
08:27:37 <Welkin> :t (.++.)
08:27:37 <lambdabot> error: Variable not in scope: .++.
08:30:07 * hackage ffunctor 1.1.0 - FFunctor typeclass  https://hackage.haskell.org/package/ffunctor-1.1.0 (fommil)
08:33:29 <Welkin> ah, I see now
08:33:42 <Welkin> Data.Semigroup from base, not from the Semigroup package
08:33:48 <Welkin> damn namespaces!
08:34:47 <merijn> Welkin: Pretty sure that package has been obsolete for decades (Semigroup used to be in semigroups, which moved to base now)
08:36:03 <Welkin> got it
08:36:10 <Welkin> it compiles now with 8.6.3 :D
08:37:48 <Welkin> adding a local cabal package is done by just including it in cabal.project under `packages:` right?
08:45:58 <ProofTechnique> Is there a straightforward way to download the mailing list archives? I have the last couple of years of -cafe, but I'd like to have the whole thing indexed, if possible
08:46:26 <ProofTechnique> Usually there'll be a maildir download link, but I can't find one
08:47:43 <monochrom> I think no.
08:48:18 <ProofTechnique> That's unfortunate. I suppose I'll have to go look for a mailman scraper or something
09:13:02 <butter1[m]> best resources for learning haskell besides learnyouahaskell?
09:14:15 <Solonarv> @where cis194
09:14:15 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
09:14:22 <Solonarv> butter1[m]: this one is recommended here often
09:14:30 <Solonarv> there's also a 2016 version
09:14:50 <butter1[m]> ty
09:15:17 <butter1[m]> i'll take all the reccs I can get ngl, if you are willing to share more
09:18:20 <monochrom> The wikibook.
09:18:38 <__monty__> Hutton's book.
09:19:41 <Welkin> and the fish book
09:19:49 <Welkin> and the typeclassopedia
09:20:02 <Welkin> there is no single resource
09:20:04 <Welkin> you need a lot of them
09:20:12 <DigitalKiwi> hutton's book++
09:20:29 <Welkin> haskell is also a huge language in practice (especially with ghc extensions)
09:20:34 <Welkin> so also read the ghc user's guide
09:20:44 <__monty__> What's the fish book?
09:20:52 <Welkin> parallel and concurrent programming in haskell
09:21:18 <Welkin> it explains the runtime system, stm, threads, etc
09:23:10 <Solonarv> @where parconc
09:23:10 <lambdabot> https://www.safaribooksonline.com/library/view/parallel-and-concurrent/9781449335939/
09:23:15 <Solonarv> @where pih
09:23:15 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
09:23:20 <Solonarv> @where wikibook
09:23:21 <lambdabot> http://en.wikibooks.org/wiki/Haskell
09:23:36 <Solonarv> @where typeclassopedia
09:23:37 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
09:23:47 <Solonarv> butter1[m]: ^ links to the mentioned resources
09:29:33 <butter1[m]> Ty
09:31:49 <Solonarv> is there proper documentation somewhere for cabal's script support?
09:32:53 <ProofTechnique> Can you be more specific?
09:33:09 <monochrom> I don't know, but the cabal user guide is at https://cabal.readthedocs.io/en/stable/  note also there is a "latest" version.
09:36:02 <Solonarv> oh, it's actually in the user guide now
09:36:25 <Solonarv> https://cabal.readthedocs.io/en/latest/nix-local-build.html#cabal-new-run (the "script files" format)
09:36:40 <Solonarv> I could swear it wasn't there last time I looked!
09:55:34 <bifunc2> Anyone here using Haskero on VS Code? Have you figured out how to always show all warnings? -Wall just in the .yaml file has no effect.
09:55:51 <Welkin> I got airship working :D
09:55:54 <bifunc2> I'm particularly interested in those redundant modules/functions warnings.
09:58:16 <RecursiveG> Does anyone know if there's a command to check the kind of the type of an expression, similar to ":t" or ":k", in GHCi?
09:58:30 <shapr> Is there a suggested library that's good for writing both a parser and unparser together?
09:59:17 <Welkin> RecursiveG: :kind!
10:00:44 <Solonarv> RecursiveG: the kind of the type of an expression is (nearly) always 'Type' (also written '*'), so that's kind of pointless
10:00:51 <hpc> shapr: invertible-syntax is on my list of packages to read up on
10:00:58 <hpc> at a glance it seems quite sensible
10:01:06 <Solonarv> (unboxed/unlifted/primitive types have a different kind, but you're not likely to run into those)
10:01:08 <shapr> hpc: I'll look at it, thanks
10:01:58 <lyxia> shapr: boomerang and rountrip (the latter is a newer reimplementation of invertible-syntax)
10:02:09 <bob___> hi how do I compile using 'stack ghc' but with -O2?
10:02:19 <hpc> lyxia: oooooooooh
10:02:34 <shapr> lyxia: I'll check those out too!
10:02:39 <hpc> i think i can use roundtrip-aeson
10:02:39 <monochrom> haha boomerang is a cool name
10:03:00 <MarcelineVQ> there's also https://hackage.haskell.org/package/waargonaut-0.6.0.0 if you're after json
10:03:23 <lyxia> shapr: and I have some experimental stuff here that I've been wanting to generalize https://github.com/Lysxia/unparse-attoparsec https://github.com/Lysxia/profunctor-monad
10:03:58 <RecursiveG> Solonarv: I particularly interested in the "(Right True) :: Either a Bool" case. Does "(Either a Bool)" have kind * or kind *->* ?
10:04:33 <hpc> *
10:04:34 <monochrom> *
10:04:34 <Solonarv> RecursiveG: it has kind *. You can tell because it's the type of a value.
10:05:01 <shapr> I'm looking to edit packet captures, and I vaguely remember reading the 2010 paper on invertible syntax
10:05:42 * shapr reads lyxia's links
10:06:22 <hpc> shapr: i plan on writing a packet simulator for a firewall frontend soon, if you can share the code once it's finished definitely ping me :D
10:06:46 <shapr> hpc: sure, sounds like fun!
10:06:46 <Welkin> it's troubling how the majority of questions these days are about "how do I use stack/stack is broken" or "my <editor> doesn't work with <IDE thing>"
10:07:07 <shapr> bob___: I think you can edit ghc-options in your cabal file?
10:07:13 <Welkin> maybe we should have a big red notice on join that says "don't use stack"
10:07:20 <shapr> but we do!
10:07:27 <hpc> Welkin: direct them to #haskell-lang
10:07:30 <hpc> :P
10:07:43 <shapr> I'm not anti-stack, I'm willing to help anyone who's writing Haskell code
10:08:35 <bob___> oh is there a war or something
10:08:36 <Welkin> hpc: is that where the hostile takeover faction fled to?
10:08:52 <hpc> it's a reference to the website, i doubt the channel exists
10:08:57 <Welkin> okay
10:08:58 <monochrom> haha
10:09:05 <shapr> bob___: do you have a cabal file that includes a ghc-options line?
10:09:39 <hpc> i like stack, but it's definitely a very specialized tool that gets misused
10:09:53 <hpc> learning cabal first is the solution to almost every stack problem
10:10:32 <MarcelineVQ> that and updating
10:10:38 <MarcelineVQ> /upgrading
10:11:07 <monochrom> Learning is the solution to almost every problem.
10:11:57 <hpc> ah yes, the feynman method
10:12:17 <hpc> 1 - write down the problem 2 - think really hard 3 - write down the solution
10:12:21 <hpc> every step equally important
10:12:34 <monochrom> Even when stack is suitable, it still requires learning and due diligence, not the prevailing Internet entitlement attitude that someone or some search engine will just serve you a recipe on silver platter.
10:13:02 <bob___> shapr: i see the line thanks
10:13:47 <bob___> in a cabal file, how do I specify a module dependency? I want to use Data.IntSet
10:14:11 <Solonarv> bob___: you depend on *packages*, not modules
10:14:14 <hpc> bob___: you depend on the package that module is in
10:14:25 <monochrom> Can't. Specify package dependency. Data.IntSet is in containers.
10:14:54 <bob___> oh containers is a package that has the module intset?
10:14:59 <shapr> yup!
10:15:12 <bob___> ahhhh thankss
10:15:15 <Welkin> bob___: https://cabal.readthedocs.io/en/latest/index.html
10:15:25 <Welkin> the cabal manual explains everything
10:15:42 <shapr> I've been lobbying for cabal to suggest packages to add to build-depends when it finds an import that doesn't match the list of build-depends
10:16:11 <Welkin> it does
10:16:20 <shapr> I'd like to be able to just "import Data.IntSet" and then cabal new-build would say "would you like to add containers to your build-depends" ?
10:16:21 <Welkin> at least for hidden packages
10:16:58 <Amras> heh, \c -> (c:)
10:17:00 <Amras> it's a smile
10:17:40 <Amras> one of the times where non-pointfree actually looks better
10:17:58 <Welkin> I think you mean the other way around
10:18:06 <Welkin> point-free looks worse 99% of the time
10:18:30 <Welkin> is more difficult to understand
10:18:52 <Amras> for complex stuff, sure
10:19:08 <Amras> but for something as simple as (:) it just looks messy
10:19:54 <monochrom> (\x y -> x : y) 1 []
10:22:56 <RecursiveG> One more question on types. Since "Nothing :: Maybe a" can be passed to any functions that accepts "Maybe Bool", does that mean Maybe a and Maybe Bool is the same type?
10:23:19 <Welkin> no
10:23:33 <Welkin> the `a` is some specific type after compilation
10:23:52 <__monty__> monochrom: Kind of a prisoner's dilemma though. Imagine how much time you can save if someone feeds you the solution : ) (programmers/people in general are really bad at integrating cost over time)
10:24:43 <Welkin> in your case, that `a` ia actually Bool
10:24:46 <Welkin> is*
10:24:50 <Welkin> not `a`
10:25:11 <RecursiveG> Welkin: so the compiler automatically fills in a proper type?
10:25:17 <geekosaur> RecursiveG, ghci hides this because of some fancy defaulting, at the price that sometimes you see an unexpected () in a type. if you compile something, you'll find that not only is it specific but itll refuse to compile a Nothing where it can't figure out what 'a is in (Maybe a)
10:28:07 * hackage yak 0.2.0.0 - A strongly typed IRC library  https://hackage.haskell.org/package/yak-0.2.0.0 (tsahyt)
10:31:46 <monochrom> Hey I have a great corollary.  Machine learning is the solution to almost every machine problem!
10:32:50 <geekosaur> RecursiveG, this said, type inference is a thing, so if it can infer that the type has to be Maybe Bool, it'll use that. if it can't guarantee a specific type, it will throw an error
10:34:48 <RecursiveG> geekosaur: got it
10:35:33 <bob___> hi y'all a little new to haskell. Say I have a list [1..largenumber] and I want to parallel apply an operation. I heard that there is parMap?
10:37:18 <Welkin> bob___: read parconc
10:37:22 <Welkin> ?where parconc
10:37:22 <lambdabot> https://www.safaribooksonline.com/library/view/parallel-and-concurrent/9781449335939/
10:37:31 <hpc> it's in the parallel package
10:37:43 <c_wraith> note that lists aren't a very good structure to apply operations to in parallel
10:37:52 <monochrom> I don't know what "parallel apply" means but yeah read the parconc book and read the doc of Data.Parallel you may easily find what you mean.
10:38:31 <bob___> oh wow it's free thanks Welkin!
10:40:20 <koz_> I third that book. It's very useful and well-written.
10:40:36 * nshepperd . o O (PAC-learning is the solution to almost every PAC problem?)
10:48:02 <bob___> could someone explain what this rdeepseq is in "parMap rdeepseq (*2) [1,2,3,4,5,6]"
10:48:03 <bob___> ?
10:50:12 <hpc> it has documentation in the parallel package
10:58:08 <Solonarv> I'm trying to use cabal script for building with shake, but cabal doesn't seem to recognize the dependencies I specified. What am I doing wrong?
10:58:18 <Solonarv> code & error here: https://gist.github.com/Solonarv/e9fc9bfbda7d871ccf3ae44dc1a87e6b
11:02:37 * hackage zenhack-prelude 0.1.1.0 - @zenhack's personal custom prelude  https://hackage.haskell.org/package/zenhack-prelude-0.1.1.0 (isd)
11:04:19 <monochrom> nshepperd: That borders on being tautological but yeah I'd totally stand behind it!
11:08:38 <sternmull> Does anyone have experience with digestive-functors? I wonder if it is worth to get into it for form validation. But don't know if it will pay off or if there are alternatives.
11:14:37 * hackage newsynth 0.3.0.5 - Exact and approximate synthesis of quantum circuits  https://hackage.haskell.org/package/newsynth-0.3.0.5 (PeterSelinger)
11:14:55 <Welkin> this is cool too https://hackage.haskell.org/package/scotty-rest
11:17:39 <Welkin> it's too bad such great packages go unmaintained
11:32:06 <Welkin> is the fad of using alternative preludes finally ending? Or are people still doing that in libraries?
11:34:44 <yushyin> side note, I do like a non-standard prelude in my ghci
11:35:28 <Welkin> in libraries it just leaves them broken and unusable when the maintainer disappears
11:43:52 <monochrom> What we need is a preprocessor or GHC plugin that adds the 10 common extensions automatically. >:)
11:46:18 <Welkin> I see enough of that already where a library has a nunch of language pragmas at the top and they never get used
11:46:21 <Welkin> bunch*
11:46:35 * dyl puts on thick framed glasses and tweed jacket.
11:46:45 <Welkin> ghc should warn about unused pragmas
11:46:49 <dyl> Actually, what we need is ML style signatures and structures.
11:47:10 <Welkin> what does that mean?
11:47:19 <dyl> (That was sarcasm, by the way.)
11:47:29 <dyl> Fad solution for a fad problem ;p.
11:47:59 <amx> hlint warns about them
11:49:29 <Solonarv> we have those, actually - that's what backpack is
11:49:43 <Welkin> I thought backpack was ml-style modules
11:50:10 <Solonarv> signatures & structures are part of that system
11:51:54 <monochrom> Backpack is over both modules and packages.
11:55:14 <ProofTechnique> I'd love to see more Backpack use, or at least posts about it. Most of my exposure is in ekmett's streams
12:02:43 <dyl> Huh, backpack looks neat.
12:06:53 <amx> http://blog.ezyang.com/category/haskell/backpack/
12:34:42 <dyl> When I get a "constraint from user target requires ..." error from cabal, is there any way to get it to tell me where that constraint is?
12:36:57 <Welkin> it should in the output
12:39:54 <dmwit> dyl: "user target" is the thing you asked cabal to build.
12:39:59 <dmwit> thing(s)
12:59:26 <trcc> hmm I need to return a StablePtr OR a null ptr. How the hell do I go about this?
12:59:31 <trcc> from a haskell function
12:59:57 <koz_> trcc: Returning Either not an option?
13:00:50 <trcc> koz_: it is an FFI function. If everything suceeds, then I must return a pointer to a structure, that is used subsequently, therefore a StablePtr. If it fails, then I must return a nullPtr
13:00:57 <koz_> Ah.
13:02:27 <hpc> is StablePtr not nullable?
13:03:26 <trcc> hpc: not that I can find
13:04:07 * hackage red-black-record 2.0.1.0 - Extensible records and variants indexed by a type-level Red-Black tree.  https://hackage.haskell.org/package/red-black-record-2.0.1.0 (DanielDiazCarrete)
13:04:19 <dmwit> Wait, where do the two requirements you state come from?
13:04:22 <c_wraith> wait...  how does the C code get the StablePtr in the first place?
13:04:25 <otulp> trcc: Are you sure you really want a StablePtr instead of a normal Ptr (or possibly ForeignPtr)?
13:04:47 <trcc> I'll try to explain a bit more, maybe there is a better option
13:07:24 <pie___> meh. a problem with callback systems might be lack of first class support in IDEs for whatever thing you implemented...but im not sure because i dont have emacs set up properly or know how to use it to see if i can have it find references in my code
13:07:34 <trcc> The first call (instantiate) to my library returns a pointer. This pointer is passed to every subsequent function call to my library. The subsequent library functions only returns a status. I am therefore using StablePtr (IORef Component), where I create a new Component, when I need to update the state between function calls. It is stated in the standard that my library must adhere to, that instantiate must return a null p
13:07:34 <trcc> ointer if instantiation failed
13:09:09 <c_wraith> so you're creating haskell library to call from C?
13:09:14 <trcc> c_wraith: yes
13:10:29 <Rip___> Would appreciate some hints. I want to generate all the subsequences of a list but in order of size. For example the reverse sort subsequences of list. 
13:11:10 <Rip___> Is there a methodology to do this efficiently? 
13:11:46 <koz_> Rip___: So, if I understand correctly, given [1,2,3], you want to generate [[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]]?
13:12:30 <Rip___> Or I want to generate [[1,2,3], [2,3], ...etc]
13:12:40 <hpc> the powerset
13:12:45 <koz_> Well, given a list of n items, that's 2^n amounts of work no matter what you do.
13:12:50 <koz_> So 'efficient' is a highly relative term here. :P
13:13:08 <Solonarv> > subsequences [1, 2, 3]
13:13:09 <hpc> > replicateM (\x -> [False,True]) [1,2,3]
13:13:10 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
13:13:10 <lambdabot>  error:
13:13:11 <lambdabot>      • Couldn't match expected type ‘Int’
13:13:11 <lambdabot>                    with actual type ‘p0 -> [Bool]’
13:13:31 <koz_> hpc: Yeah, I remember someone (might have even been you?) showing me how the list monad can do this.
13:13:33 <Rip___> Uh so lemme describe the problem 
13:13:41 <c_wraith> trcc: you might be able to use (castPtrToStablePtr nullPtr).  It's not defined as valid, but it has a decent change of working
13:14:03 <Rip___> I have a filter I want to apply on a huge list of subsequences. I want the largest subsequences that matches that filter 
13:14:08 <hpc> i only remember it had replicateM
13:14:36 <hpc> subsequences is better though
13:15:01 <koz_> Rip___: So you wanna enumerate the powerset in _reverse_ order of size?
13:15:13 <Rip___> Yes! That’s a better way of phrasing it 
13:15:17 <Rip___> :)
13:15:23 <trcc> c_wraith: I'll try it!
13:15:47 <koz_> Hmm.
13:16:37 * hackage aws 0.21.1 - Amazon Web Services (AWS) for Haskell  https://hackage.haskell.org/package/aws-0.21.1 (AristidBreitkreuz)
13:16:49 <Rip___> In an imperative language, I would probably sort the numbers of 1000 bits by their number of 1s in binary then use the bits to select from the set
13:17:18 <koz_> That would require you to enumerate _the entire powerset_.
13:17:26 <koz_> Which is a pretty terrible idea from first principles.
13:17:37 <koz_> You want something that's lazy (like subsequences), but enumerates in reverse order.
13:17:41 <koz_> @src subsequences
13:17:42 <lambdabot> Source not found. Sorry.
13:17:44 <koz_> :(
13:17:50 <koz_> Solonarv: Where's subsequences from?
13:18:01 <c_wraith> probably Data.List
13:18:02 <Solonarv> Data.List
13:18:38 <hpc> > replicateM 3 [True, False]
13:18:40 <lambdabot>  [[True,True,True],[True,True,False],[True,False,True],[True,False,False],[Fa...
13:18:51 <c_wraith> hpc: it's filterM, not replicateM
13:18:59 <c_wraith> And it doesn't work
13:19:05 <c_wraith> (for solving this)
13:19:11 <Rip___> it’s in data.list 
13:19:11 <hpc> ah
13:19:44 <hpc> why not?
13:19:53 <c_wraith> it gives back the wrong order
13:20:01 <otulp> trcc: Could you do a C-side wrapper which gets a StablePtr and a bool from Haskell-land, checks the bool, and yields a nullptr if needed?
13:20:02 <trcc> c_wraith: thank you. It worked perfectly
13:20:04 <c_wraith> > filterM (const [True, False]) [1..4]
13:20:06 <lambdabot>  [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4]...
13:20:23 <koz_> c_wraith: What _is_ the order in that case, out fo interest?
13:20:27 <hpc> oh, it's not sorted
13:20:30 <hpc> yeah
13:20:40 <trcc> otulp: I have a C-side wrapper for other reasons, but I would prefer to have all that is possible in haskell.
13:22:07 * hackage red-black-record 2.0.2.0 - Extensible records and variants indexed by a type-level Red-Black tree.  https://hackage.haskell.org/package/red-black-record-2.0.2.0 (DanielDiazCarrete)
13:22:24 <otulp> trcc: According to doc, you really cannot trust that castPtrtoStablePtr nullPtr will keep working. You may be relying on an implementation detail here, which is maybe not so good if you have a standard to adhere to?
13:23:59 <Rip___> Hmm generating all subsequences of size 3 from a list of four elements is equivalent to if I have 4 buckets and 3 balls to place. Is there a haskell functiont that would do this?
13:24:11 <trcc> hmm otulp good point
13:24:17 <trcc> for now I will stick with this
13:24:40 <otulp> trcc: ... though I guess it is most likely to be tied to architecture, so if you stay at x86 or whatever you'll probably be fine. *shrug* :)
13:25:01 <Rip___> Oh is that equivalent to generating the permutations of 0111 
13:25:13 <trcc> I'll try it on linux, mac, win32, win64
13:25:49 <koz_> Rip___: The biggest issue with what you want is avoiding having to materialize the entire powerset, or combinations.
13:25:57 <koz_> Since 2^n is a harsh mistress.
13:26:00 <Rip___> Yep
13:26:13 <Rip___> It’s kinda killer on the performance of the program 
13:26:19 <koz_> I _am_ thinking of how to do what you want, but the reverse order thing is giving me some issues.
13:27:21 <koz_> You could do something similar to what you want using repeated applications of https://wiki.haskell.org/99_questions/Solutions/26
13:27:42 <koz_> Like, start with 'test the original list', then 'test everything but one element in all possible variations' etc.
13:27:58 <koz_> It's probably not _wonderful_, but at least it'll only be bad when only something small fits.
13:28:05 <koz_> Which is inevitable no matter _what_ you do.
13:28:51 <koz_> At least this you could conceivably do in parallel.
13:29:08 <c_wraith> Rip___: there's always the non-clever direct approach:  https://termbin.com/xmav
13:29:38 <koz_> c_wraith: What order does this enumerate in?
13:29:42 <Rip___> So I tried parallel using parlistchunks 4 but it is slower I even specified RTX options and multithreading 
13:29:44 <c_wraith> the expected
13:29:57 <koz_> c_wraith: So smallest-to-largest? Or largest-to-smallest?
13:30:03 <c_wraith> largest-to-smallest
13:30:10 <koz_> Oh. Well, that works.
13:30:14 <Rip___> WHOAH lemme process that
13:30:20 <Rip___> U are a legend 
13:30:23 <c_wraith> It's not clever in any way
13:30:26 <koz_> c_wraith is indeed a legend.
13:30:45 <c_wraith> I once wrote an O(n!^2) sorting algorithm.  Is that why?
13:31:02 <koz_> c_wraith: Lolwat.
13:31:13 <c_wraith> it took 20 minutes to sort 8 ints in java
13:31:16 <hpc> that's even worse than the sort function in acme-php
13:31:23 <koz_> That's... terrifying and hilarious.
13:31:31 <koz_> Since brute force is O(n!).
13:31:35 <Rip___> Also why is the multithreading overhead so large?
13:31:50 <koz_> Rip___: If you don't give it enough work to do, it'll dominate.
13:32:06 <Solonarv> c_wraith: how even
13:32:09 <c_wraith> Rip___: mostly because [] is a lazy data structure that's inherently serial.  It needs very specific problems to play nicely with parallelism
13:32:26 <Rip___> Ah alas 
13:32:34 <koz_> Yeah, I too am curious how you managed to get O(n!^2).
13:33:08 <Rip___> I’ll analyze your reverse subsequence algorithm at a later time. Thank you all for your help 
13:33:17 <Rip___> Have a good day
13:33:29 <koz_> Rip___: Tell us if you get any improvement.
13:33:35 <koz_> I'm curious.
13:33:48 <Rip___> Will do when I’m back. R u an admin on the Haskell chat
13:34:02 * koz_ isn't.
13:34:08 <Solonarv> for(int i = 0; i < factorial(xs.length); i++){ bogosort(xs) } :p
13:34:18 <koz_> Solonarv: Egads I think I just died.
13:34:32 <wroathe> c_wraith: Your sorting algorithm involved human beings transporting floppy disks between machines for each run, didn't it?
13:34:46 <koz_> wroathe: I don't think that impacts on the asymptotics. :P
13:34:51 <c_wraith> I don't recall exactly what I did.  Just that it somehow did the O(n!) algorithm multiple times for every candidate order.
13:35:11 <koz_> Worse than brute force is quite an achievement.
13:35:12 <c_wraith> I was actually trying to write the O(n!) algorithm and messed it up.
13:35:27 <c_wraith> This was like...  20 years ago.
13:36:07 <Welkin> what is the !
13:36:15 <Solonarv> factorial
13:36:15 <c_wraith> factorial
13:36:23 <koz_> Damn, beaten to the punch.
13:36:40 <wroathe> koz_: Sure it does. Ignoring bottom (the human transporter dies in a horrific car accident), there's a theoretical worst case running time for a living human being to transport a piece of data from one location to another :P
13:36:57 <Lycurgus> 0_0
13:36:59 <trcc> ahh that null thing removed my very last warning... amazing
13:37:20 <c_wraith> A key factor in my algorithm was that I didn't shortcut when I got a correct order.  I just noted it and kept going.
13:37:50 <c_wraith> It required some deliberate bad choices.
13:41:40 <hpc> you never know when you'll find a list that's even more sorted
13:52:14 <rip__> koz_ it looks like it's slow by 33%
13:52:44 <monochrom> c_wraith: w00t was that bogosort?!
14:03:42 <dolio> You can't shortcut when you get the correct order. That leaves you open to a timing attack.
14:04:54 <c_wraith> true
14:23:27 <Welkin> what is the point of all this nonsense?
14:23:27 <Welkin> https://github.com/helium/airship/blob/master/airship/src/Airship/Internal/Date.hs#L41
14:24:07 <Welkin> who optimizes a function to print a timestamp using C pointers
14:24:36 <benzrf> lmao
14:24:39 <Welkin> by the way
14:24:41 <Welkin> it's wrong
14:24:52 <Welkin> or at least it is with ghc 8.6.3
14:24:59 <Welkin> it adds a random unicode character to the end
14:25:15 <Welkin> I like the library other than that one thing
14:26:30 <Welkin> there is already a library for that
14:26:31 <Welkin> https://hackage.haskell.org/package/http-date-0.0.8/docs/Network-HTTP-Date.html
14:26:34 <trcc> I understand the idea of IO, I think. But I am lacking some examples where it is actually "better" than its counterpart in i.e. C, besides making it obvious to the developer. Can anyone point me to some?
14:26:41 <Welkin> while I'm at it I may as well replace it with this
14:27:12 <Welkin> trcc: IO is IO regardless of language
14:27:25 <Welkin> in haskell you can track whether a function is allowed to perform IO
14:27:32 <trcc> yes, that part I understand
14:27:36 <Welkin> and enforce those resctrictions
14:28:00 <Welkin> it's not nearly the most important idea in haskell
14:28:19 <Welkin> the lambda calculus, immutable data, and the rest of the type system is
14:28:55 <geekosaur> well, IO is why the rest can be immutable and why you can trust the type system
14:28:58 <trcc> Is it fair to say that the main purpose of the way IO is modelled in haskell, i.e. with the IO monad, is to show which functions does IO and which does not?
14:29:37 <Welkin> trcc: read the paper Lazy Functional State Threads to understand
14:30:31 <mouse07410> Welkin: A pointer, please? (No pun intended ;)
14:30:54 <Welkin> https://www.microsoft.com/en-us/research/wp-content/uploads/1994/06/lazy-functional-state-threads.pdf
14:31:14 <trcc> hehe
14:32:08 <trcc> btw. how does readfile work? it returns IO String - what if the file does note exist? Exception?
14:32:15 <trcc> will do Welkin
14:32:16 <trcc> thanks
14:32:28 <trcc> Is it an example of why this approach is good
14:32:37 <koz_> Yay another recommendation for that paper!
14:32:44 <dolio> If the file doesn't exist an exception is thrown.
14:33:52 <Solonarv> % readFile "doesnt.exist"
14:33:52 <yahb> Solonarv: *** Exception: doesnt.exist: openFile: does not exist (No such file or directory)
14:34:12 <benzrf> % readFile "/etc/passwd"
14:34:12 <yahb> benzrf: *** Exception: /etc/passwd: openFile: does not exist (No such file or directory)
14:34:19 <benzrf> 🤔
14:34:24 <Solonarv> % readFile "doesnt.exist" `catch` \(_ :: IOException) -> putStrLn "whoops!"
14:34:25 <yahb> Solonarv: ; <interactive>:16:25: error:; Ambiguous occurrence `catch'; It could refer to either `System.Console.Haskeline.catch', imported from `System.Console.Haskeline' (and originally defined in `System.Console.Haskeline.MonadException'); or `Control.Exception.catch', imported from `Control.Exception' (and originally defined in `GHC.IO')
14:34:36 <Solonarv> % readFile "doesnt.exist" `Control.Exception.catch` \(_ :: IOException) -> putStrLn "whoops!"
14:34:37 <yahb> Solonarv: ; <interactive>:17:74: error:; * Couldn't match type `()' with `[Char]'; Expected type: IO String; Actual type: IO (); * In the expression: putStrLn "whoops!"; In the second argument of `Control.Exception.catch', namely `\ (_ :: IOException) -> putStrLn "whoops!"'; In the expression: readFile "doesnt.exist" `Control.Exception.catch` \ (_ :: IOException) -> putStrLn "whoo
14:34:43 <mouse07410> Welkin: thanks!
14:34:45 <Solonarv> Bah
14:34:49 <trcc> is there a "safe" readFile, where the type system enforced you to handle potential errors?
14:35:05 <Solonarv> I think there's a library like that somewhere
14:35:35 <trcc> ok
14:35:44 <Welkin> haha, the http-date library has been around for 7 years. I guess the authors of the airship package never bothered to look for it
14:35:50 <Welkin> 8 years*
14:35:59 <koz_> Welkin: What does the airship package do?
14:36:11 <Welkin> it is a WebMachine-style library for haskell
14:36:17 <koz_> What's WebMachine?
14:36:50 <Welkin> WebMachine is an erlang library for implementing http servers using a state machine, so you write your endpoints in a very declarative way
14:36:59 <koz_> Ah, I see.
14:37:07 <Solonarv> @hackage unexceptionalio
14:37:07 <lambdabot> http://hackage.haskell.org/package/unexceptionalio
14:37:09 <koz_> That's very cool-sounding.
14:37:11 <Welkin> https://github.com/webmachine/webmachine/wiki
14:37:15 <Solonarv> but seems to have been abandoned for a little while
14:37:21 <Welkin> it is the best way of building http servers I have found
14:37:25 <koz_> Solonarv: There's a lost opportunity to name it 'mundaneIO'. :P
14:37:51 <Welkin> Solonarv: it's not so much abandoned as it is "completed"
14:37:58 <Welkin> it could use some polish though for sure
14:38:30 <Solonarv> fair enough
14:38:50 <Welkin> I'm surprised that the original WebMachine is still actively worked on too
14:41:37 <Welkin> in fact I may as well update it tonight
14:45:11 <platz> does unexceptionalio do something different from not catching async exceptions?
14:54:57 <Solonarv> It doesn't seem to catch async exceptions, no
14:55:03 <Solonarv> That is correct behavior!
14:55:58 <Solonarv> if you catch an async exception, you should promptly exit or re-throw it
14:57:15 <platz> right, that's what safe-exceptions & unliftio do
14:58:35 <Rip___> How smart is haskell garbage collection? Say I did this maximum [1..1000000] would the left side of the list still be kept in memory despite it not containing the max?
14:59:05 <dmwit> GHC will collect the beginning of the list before that finishes.
14:59:14 <Cale> No, each cell is garbage the moment it's looked at
14:59:39 <Cale> But if you did something like  let xs = [1..1000000] in (maximum xs, head xs)
14:59:40 <dmwit> Of course it is very sensitive to exactly what you do. If you `let x = [1..1000000] in (maximum x, length x)` that changes the story a lot.
14:59:57 <Cale> haha, almost the same
15:01:02 <Rip___> So I have this complex expression snd $ maximum [(length x,x) | x <- listoflsts ] 
15:01:32 <dmwit> :t maximumBy
15:01:33 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
15:01:35 <Solonarv> why not use maximumBy ?
15:01:36 <Rip___> Say Listoflsts is larger than my ram can hold. Do I have to worry?
15:01:39 <dmwit> :t maximumOn
15:01:40 <lambdabot> error:
15:01:40 <lambdabot>     • Variable not in scope: maximumOn
15:01:40 <lambdabot>     • Perhaps you meant one of these:
15:01:42 <dmwit> too bad
15:01:59 <Cale> maximumBy would be different
15:02:02 <Solonarv> :t maximumBy (comparing length)
15:02:03 <lambdabot> (Foldable t2, Foldable t1) => t1 (t2 a) -> t2 a
15:02:11 <Rip___> Oh sht I didn’t know there was that function, but regardless 
15:02:12 <dmwit> You only need worry if you also use listoflsts elsewhere in the expression in a way that forces it to remain in memory.
15:02:16 <Cale> That'll recompute lengths which you probably don't want to do
15:02:25 <Solonarv> true
15:02:27 <dmwit> Cale: That's why I immediately followed it up by hoping for a maximumOn. =)
15:02:40 <Cale> and if it's maximumBy fst, that's a little different too (it won't compare the lists of the same length)
15:02:53 <Cale> maximumBy (comparing fst) rather
15:03:24 <Rip___> Wait so what’s the computation difference between maximumOn and maximumBy?
15:03:46 <dmwit> Well... hard to answer that, since maximumOn doesn't exist. =)
15:04:14 <dmwit> But if it did, I would expect it to do essentially exactly the decorate-compute-undecorate pattern that your code did.
15:04:17 <Cale> maximumOn :: (Ord b) => (a -> b) -> [a] -> a would be able to do the pairing trick you were already doing with length
15:04:24 <dmwit> (With Cale's caveat that it would ignore the lists themselves, probably.)
15:04:38 <Cale> maximumBy takes a comparison function
15:04:44 <Cale> :t maximumBy
15:04:46 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
15:05:00 <Rip___> Ah so it’s jusr prettier but would roughly have the same runtime?
15:05:07 <Cale> yeah
15:05:10 <dmwit> :t foldMap (\xs -> Arg (length xs) xs)
15:05:11 <lambdabot> error:
15:05:11 <lambdabot>     • Data constructor not in scope: Arg :: Int -> t1 a -> m
15:05:12 <lambdabot>     • Perhaps you meant ‘Args’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
15:05:19 <dmwit> too bad
15:05:57 <Rip___> Cool well thanks y’all I’ll use maximumBy 
15:06:02 <Rip___> Or *on
15:06:07 <Cale> Rip___: I think you're okay if listoflsts is larger than memory can hold
15:06:17 <dmwit> Oh, it would need a Max anyway, and it's only Semigroup not Monoid... using this thing is well annoying.
15:06:22 <Cale> The trouble is if any individual list is too large
15:06:40 <Cale> yeah, just do it the way you were doing it, I'd say
15:06:41 <Rip___> Ah I don’t think I have that issue. Thanks 
15:07:17 <Cale> Of course, that's a lot of lengths to compute as well
15:07:37 <Cale> If you need to compute a length longer than the size of your memory, that's going to take some time
15:07:43 <dmwit> % :t foldMap1 (\xs -> Max (Arg (length xs) xs))
15:07:43 <yahb> dmwit: (Foldable1 t1, Foldable t2) => t1 (t2 a) -> Max (Arg Int (t2 a))
15:07:58 <Cale> (which you're effectively doing, in pieces)
15:09:55 <dmwit> haha
15:10:02 <dmwit> :t head . sortOn (Down . length)
15:10:03 <lambdabot> Foldable t => [t a] -> t a
15:11:04 <dmwit> That has the nice O(n) runtime. I wonder if it has the nice O(1) memory footprint. Probably not.
15:18:01 <benzrf> :t Down
15:18:02 <lambdabot> a -> Down a
15:18:23 <benzrf> > Down 3 > Down 2
15:18:25 <lambdabot>  False
15:18:28 <benzrf> ah
15:19:15 <yushyin> oh, the haskell wiki changed appearance? It wasn't that 'white' before.
15:43:37 * hackage adtrees 0.1.0.0 - Modelling, rendering and quantitative analysis on attack defense trees  https://hackage.haskell.org/package/adtrees-0.1.0.0 (umazalakain)
15:44:10 <geekosaur> hm? it's always been that color. I do see a slight font difference
15:44:21 <geekosaur> maybe you'd been using something from userstyles.org and it broke?
15:47:51 <lyxia> Are we talking about https://wiki.haskell.org/Haskell ? It did change recently-ish.
15:48:18 <yushyin> lyxia: yes that wiki.
15:48:20 <koz_> lyxia: Yeah, I see the changes too.
15:48:25 <koz_> Like, noticeably brighter.
15:48:28 <Taneb> c_wraith: it's bugging me, can't you make a sorting algorithm without timing attacks that runs in O(n^2)?
15:48:41 <ibloom> Hi, I just open sourced a rasterizer that is 50% haskell 50% opencl.
15:48:56 <ibloom> You can find the repository here: https://github.com/ianmbloom/gudni
15:49:39 <ibloom> And here is a reddit thread I started about it: https://www.reddit.com/r/haskell/comments/atsngn/gudni_a_haskellcentric_fast_accurate_rasterizer/
15:49:59 <koz_> Taneb: Do you also require Omega(n^2)?
15:50:05 <koz_> Or is it OK to be better?
15:50:28 <Taneb> koz_: I require the number of operations to not depend at all on the values in the list, only the length
15:50:32 <dmwit> Taneb: What's the timing attack on mergesort?
15:50:37 <Taneb> Although this is wildly off-topic
15:50:41 <koz_> dmwit: Was about to ask exactly this.
15:52:04 <Taneb> dmwit: well, now c_wraith's O(n!^2) algorithm is going to bug me even more
15:52:44 <geekosaur> huh. I opened a bookmarked wiki page. that front page has indeed changed
15:53:11 <c_wraith> Taneb: sure.  selection sort is O(n^2), and is timing-attack resistant unless caching effects play into it
15:53:27 <c_wraith> the timing attack thing was just a joke
15:53:35 <Taneb> c_wraith: ah, I see
15:53:43 <Taneb> c_wraith: well, you put me in a creative mood, so thanks
15:53:54 <c_wraith> Taneb: in fact, if you are careful, I bet you could make a timing attack resistant merge sort run in O(n log n)
15:54:35 <yushyin> geekosaur: and so have all the other pages for me.
15:55:13 <geekosaur> they've always been fairly white for me. I see only a font change
15:56:11 <monochrom> Wait, how could you even coming up with n!^2?! :)
15:57:11 <Taneb> monochrom: bogosort variant where checking if it's sorted is by running traditional bogosort then comparing
15:57:33 <Taneb> Would be one way, although I imagine not c_wraith's way
15:58:41 <dmwit> (comparing to what?)
15:59:29 <monochrom> This is beginning to sound like "protection against timing attacks by DoSing the adversary's timer". Like if your algorithm always takes more than an hour who will actually keep counts? >:)
16:00:16 <Taneb> dmwit: 1) shuffle the list, 2) make a copy of the list, 3) bogosort the copy, 4) check if the two lists are equal, if not go to 1
16:00:38 <dmwit> yeesh
16:01:06 <geekosaur> that sort of is one way such protections work: instead of constant time, random time. but that's even trickier to do
16:01:53 <Taneb> Anyway, this evening I wrote an implementation of bogosort (and then the more obscure bogobogosort) in Haskell
16:02:49 <koz_> Taneb: What the (extensible) eff is 'bogobogosort'?
16:03:04 <Taneb> http://dangermouse.net/esoteric/bogobogosort.html
16:03:15 <Taneb> Third IRC channel I've linked that in this evening :D
16:03:23 <Taneb> Here's my code: https://gist.github.com/Taneb/70ae81b63db811495ca2783cf6a54afb
16:03:33 <koz_> Egads.
16:03:38 <monochrom> "This is far too efficient."
16:06:41 <Ariakenom> geekosaur: As long as it's uniformly random. At which point you probably have the ability to make it constant
16:07:20 <Ariakenom> well doesn't have to be uniform. But sufficiently random
16:07:22 <geekosaur> Ariakenom, no, the point is every path is random time, so timing doesn't tell you anything. but doing that right is really hard
16:07:34 <wroathe> foo $ "arg1" `binop` "arg2, is there a way to tell avoid $ and parenthesis in this expression and tell GHC that applying foo has lower predence than the expression on the right?
16:07:36 <geekosaur> oh, I see what you're saying. and yes, it doesn't need ot be uniform distribution
16:07:52 <wroathe> Wow, I butchered that question
16:08:06 <Taneb> wroathe: I think the answer is no
16:08:12 <clever> what does servant have, in the form of html templating?
16:08:14 <geekosaur> but the distribution has to not combine with any particular path in a way that might leak information (uniform can still do this in some cases)
16:08:44 <Ariakenom> I used uniform to mean "of good quality" but then realized it had actual meaning.
16:08:52 <dmj`> clever: nothing really, but there are companion packages like servant-lucid that uses lucid and or blaze 
16:09:09 <dmj`> @package servant-lucid
16:09:10 <lambdabot> http://hackage.haskell.org/package/servant-lucid
16:09:13 <clever> dmj`: and no, i dont want to go full miso :P
16:09:16 <geekosaur> wroathe, there isn't a "precedence" for prefix function application
16:09:22 <dmj`> clever: you must!
16:09:23 <clever> at least not right away
16:09:26 <dmj`> ;)
16:09:39 <dmj`> clever: go big or go home is what grandpa always said to me
16:09:40 <wroathe> geekosaur: I figured as much, just wanted to be sure
16:09:40 <geekosaur> and there is no way to change normal application to have a different precedence
16:10:04 <monochrom> I like parentheses. Just use parentheses.
16:10:16 <dmj`> clever: go full miso, do interactive dev in a nix-shell with nix-shell -p entr -- run 'ag -l | entr cabal build'
16:10:34 <dmj`> the world will be a good place
16:10:39 <clever> dmj`: i want to reproduce the old interface first, witout too many drastic changes
16:10:58 <dmwit> Challenge problem: at what size of list does n! outstrip the state space of your PRNG, making your algorithm O(∞)? n!^2?
16:11:12 <dmj`> clever: smart, sounds like a good plan
16:11:17 <dmj`> clever: what does the current interface look like?
16:12:13 <clever> dmj`: hydra :P
16:12:19 <monochrom> > head [ n | n! > 2^64 ]
16:12:21 <lambdabot>  <hint>:1:15: error: parse error on input ‘>’
16:12:31 <dmj`> clever: I'm gonna slide into your DMs right now my boy
16:12:52 <monochrom> Oh haha Haskell doesn't use ! for factorial
16:13:00 <monochrom> > head [ n | product [1..n] > 2^64 ]
16:13:02 <lambdabot>  *Exception: not an integer: n
16:13:33 <dmj`> clever: typhon is already there
16:13:40 <dmj`> clever: I'll give you admin 
16:13:40 <monochrom> Oh!
16:13:45 <dmwit> > head [ n | n <- [1..], product [1..n] > 2^64 ]
16:13:47 <lambdabot>  21
16:13:49 <dmj`> clever: ;) I just need to setup prerendering
16:13:49 <benzrf> lol
16:13:50 <dmwit> So not very big!
16:13:59 <Ariakenom> % (n !) = product [1..n]
16:13:59 <yahb> Ariakenom: ; <interactive>:24:2: error: Parse error in pattern: n !
16:14:05 <dmwit> But also many popular PRNGs have more than 64 bits of state space.
16:14:18 <benzrf> % (!) n = product [1..n]
16:14:18 <yahb> benzrf: 
16:14:19 <monochrom> Yeah. Maybe 2^128 is better.
16:14:23 <benzrf> % :set -XPostfixNotation
16:14:23 <yahb> benzrf: Some flags have not been recognized: -XPostfixNotation
16:14:26 <benzrf> hmm
16:14:28 <dmj`> clever: already have websockets, github status pushing
16:14:31 <monochrom> > head [ n | n <- [1..], product [1..n] > 2^128 ]
16:14:34 <lambdabot>  35
16:14:38 <clever> dmj`: this isnt a DM :P
16:14:40 <dmwit> e.g. Mersenne Twister has a period of 2^19937 - 1
16:14:58 <benzrf> oh wait what that doesnt require an extension? :o
16:15:00 <Ariakenom> % let (!) n = product [1..n]
16:15:01 <yahb> Ariakenom: 
16:15:05 <benzrf> % (3!)
16:15:06 <yahb> benzrf: 6
16:15:08 <benzrf> huh
16:15:13 <Ariakenom> % head [ n | (n!) > 2^64 ]
16:15:14 <yahb> Ariakenom: ; <interactive>:34:8: error: Variable not in scope: n; <interactive>:34:13: error: Variable not in scope: n :: Integer
16:15:24 <dmwit> > head [ n | n <- [1..], product [1..n] > 2^19937 - 1 ]
16:15:28 <lambdabot>  2081
16:15:36 <dmwit> I'm... kind of surprised that finished in time.
16:15:44 <benzrf> was it using ints
16:15:49 <benzrf> > 2^19937 - 1 :: Int
16:15:51 <dmj`> clever: typhon doesn't aim to replace hydra, postgresql schema compatibility is not a priority :) 
16:15:51 <lambdabot>  -1
16:15:54 <dmwit> Also 2081 is big enough that it might just work for many of the lists people use sort on in practice!
16:16:00 <Ariakenom> % head [ n | n <- [1..], (n!) > 2^19937 - 1 ]
16:16:01 <yahb> Ariakenom: 2081
16:16:06 <benzrf> > head [ n | n <- [1..], product [1..n] > 2^19937 - 1 ] :: Integer
16:16:10 <lambdabot>  2081
16:16:15 <benzrf> oh huh, nice
16:16:18 <dmwit> benzrf: Definitely not. Or else it would have returned 1 straight away.
16:16:27 <Ariakenom> % :set -XPostfixOperators -- benzrf 
16:16:27 <yahb> Ariakenom: Some flags have not been recognized: --, benzrf
16:16:27 <benzrf> wait right haha
16:16:38 <benzrf> hehe
16:16:47 <Ariakenom> yes yahb, I get that
16:19:37 * hackage inspection-testing 0.4.1.2 - GHC plugin to do inspection testing  https://hackage.haskell.org/package/inspection-testing-0.4.1.2 (JoachimBreitner)
16:21:13 <wroathe> Ok, here's another dumb question: What are some ways I can go about writing a function [a] -> [b] -> heterogonous list of a's and b's?
16:21:51 <wroathe> I could make them cases of a datatype, but that means the list of types would be closed
16:22:11 <wroathe> And I'd like it to be an open class of types that get concatenated into a list
16:22:28 <Solonarv> what sort of heterogenous list do you want?
16:22:57 <Solonarv> there's Data.Dynamic which is "fully open", i.e. can be any (lifted?) type
16:23:04 <wroathe> Foo a => [a] where a could be any instance of Foo
16:23:18 <Solonarv> you'll need a wrapper for that
16:23:22 <Cale> wroathe: What are you going to do with the values when you take them out again?
16:24:10 <wroathe> apply a function that maps each type to a single type
16:24:15 <Cale> wroathe: Usually that is the key to figuring this sort of problem out -- instead of listing the values of different types directly, you list the results of whatever operations you'd intended to perform on the elements once they came out on the other side.
16:25:13 <Cale> If it's a few different things, then you can build records of whatever those things are.
16:25:14 <wroathe> I'm trying to model a heterogonous list of types that can be mapped to a single type, where instances of that coercion can be added
16:25:30 <wroathe> list of values of types*
16:25:50 <Cale> If they can be mapped to a single type, then why not simply apply the function which does that before putting the elements in the list?
16:26:20 <Cale> You almost never actually want a heterogeneous list.
16:27:22 <Cale> wroathe: What does the program you're writing actually do?
16:27:28 <wroathe> Alright, you guys are probably getting sick of hearing about this, but I changed my project's API yet again, and I'm trying to implement something like this:
16:27:44 <zuserm> Anyone know how to relate output units in diagrams to physical units?
16:27:59 <wroathe> merge $ file @Json "foo.json" `using` toConfig arg1 arg2 `and` file @Xml "foo.xml" `using toConfig arg1 arg2
16:28:20 <wroathe> missed a tick on that second using
16:29:14 <wroathe> so each file foo `using` toConfig x y term represents a configuration source and a mapping function that I want to model as a tuple
16:29:27 <wroathe> and then I want to allow the user to concatenate these with `and`
16:29:51 <wroathe> and eventually merge will iterate the list, apply the mapping function, and then merge it into the current config state
16:30:43 <wroathe> using :: EnvReader Options ConfigNode [(a -> Reader Options ConfigNode, a)] -> (a -> Reader Options ConfigNode) -> EnvReader Options ConfigNode [(a -> Reader Options ConfigNode, a)]
16:31:07 <wroathe> The reason it's a list in this operation is to cover the case where they don't use `and`
16:31:15 <wroathe> merge will expect a list in either case
16:32:16 <wroathe> So the question is, what type should `and` have in that example expression?
16:32:35 <Cale> What type should using have?
16:32:48 <Cale> ah, you gave it
16:32:48 <wroathe> I just pasted it above
16:32:55 <Cale> But perhaps it should eliminate the 'a'?
16:33:24 <iqubic> Are fudgets still in use today? If not, what haskell GUI toolkit should I be using?
16:33:38 <Cale> Were fudgets ever really in use?
16:33:48 <iqubic> I'm not sure.
16:33:50 <Cale> iqubic: What kind of GUI do you want to make?
16:33:50 <iqubic> LOL.
16:34:05 <iqubic> Cale: I'm not sure what the different types are.
16:34:07 <Cale> I use reflex-dom a lot.
16:34:42 <iqubic> Isn't that mostly used in combination with GHCJS?
16:34:44 <dmj`> can anyone recommend some good finance FIX parser libraries, preferable with tests. Not referring to the fix point combinator.
16:35:13 <Cale> iqubic: It can be, but it can also compile native applications that control the contents of the DOM
16:35:15 <iqubic> I mean I want to make web pages using haskell, but I don't think that's really possible.
16:35:33 <wroathe> Cale: Thing is, I want to allow the user to write merge $ file @Json "foo.json" without having to supply a configuration mapper
16:35:42 <Cale> iqubic: I do it as a full time job, so I think it's possible ;)
16:35:42 <wroathe> i.e., no using
16:36:06 <iqubic> Cale: Can you point me in the direction of some good tutorials?
16:36:07 <zuserm> output units are points and therefor 1/72 in
16:36:08 <dmj`> iqubic:  https://www.polimorphic.com/ <- this website was written with Haskell
16:36:26 <Solonarv> wroathe: something like 'and :: (ToSomething a, ToSomething b) => a -> b -> Something', and use a similar technique for the other functions
16:36:33 <wroathe> so if: file "foo.json" can't yield a ConfigNode, that means that file "foo.json' `using` configMapper arg1 arg2 can't yield a configNode
16:37:40 <Cale> There's https://blog.qfpl.io/posts/reflex/basics/introduction/ -- you should also try the tutorial here, perhaps even first: https://github.com/reflex-frp/reflex-platform/blob/develop/README.md
16:38:22 <iqubic> Does anyone in here use Emacs?
16:38:47 <iqubic> I'd like to be able to view hoogle documentation from inside emacs, but I can't figure that out.
16:39:55 <Cale> wroathe: and why don't they already just produce Reader Options ConfigNode?
16:40:01 <iqubic> Furthermore, I have a hoogle server running on port 8080, set up in a way that lets me access the documentation while offline. I'm wondering if there's a way to view that in emacs.
16:40:08 <wroathe> Solonarv: The problem is that the output of: file "foo.json", file "foo.json" `using` configMapper and file | file + mapper `and` file | file + mapper needs to be something that `merge` can work with
16:40:26 <wroathe> if I go with this API :P
16:40:34 <Cale> Maybe I just don't understand what merge does...
16:40:45 <wroathe> Which, I'm getting sick of Haskell's type system tell me what to do XD
16:40:52 <Cale> It feels like we're holding on to irrelevant distinctions between types
16:41:37 <Cale> If you can convert things to a uniform type earlier, and they need to be converted eventually anyway, there's probably not much point in trying to retain that type information.
16:41:38 <wroathe> Cale, merge takes a list of values of some type that can be mapped to a ConfigNode (which is a tree data structure), and then merges them all into one ConfigNode
16:41:41 <zuserm> iqubic: I don't emacs, but as far as I know you can do it with haskell-mode
16:41:52 <Cale> Why doesn't it simply take a list of ConfigNodes?
16:42:57 <zuserm> iqubic: https://github.com/haskell/haskell-mode/blob/master/haskell-hoogle.el
16:43:13 <iqubic> zuserm: That desn't query the local webserver I have set-up on 8080
16:43:45 <wroathe> Cale: if: file "foo.json" produces a ConfigNode, I'll have lost the ability to let the user configure the mapping with `using` configMapper
16:44:56 <Guest48> pl myAny p = foldr ((||) . p) False
16:45:40 <zuserm> iqubic: change haskell-hoogle-url to return your local server?
16:46:42 <iqubic> I'll try that.
16:46:55 <Cale> wroathe: Okay, so is there something we can apply to the result of file "foo.json" which would produce a suitable ConfigNode when the user doesn't want to use using?
16:47:07 <Guest48> @pl myAny p = foldr ((||) . p) False
16:47:08 <lambdabot> myAny = flip foldr False . ((||) .)
16:47:41 <wroathe> Cale: Yup, it'll return a tuple containing the default mapper and the a
16:48:01 <wroathe> Cale: and then using produces a new tuple with the new mapper and the a
16:48:03 <Cale> Right, so we could have something like  simply = uncurry ($)
16:48:56 <Cale> ah, okay
16:48:57 <wroathe> I should say they both return a singleton list containing the tuple
16:49:07 <wroathe> and then `and` concatenates the two lists together
16:49:26 <Cale> Is there a reason you'd want to replace it multiple times over?
16:49:30 <wroathe> and I'd prefer to allow the user to specify an arbitrary source of data (and accompanying type) for each term in the expression
16:49:36 <Cale> Perhaps using should immediately apply the function
16:49:55 <Cale> and there should just be some straightforward way to say you'd rather skip that step
16:50:10 <wroathe> source, and source `using` mapper should both return something that merge can operate on
16:50:56 <Solonarv> wroathe: I'll type up a gist
16:51:06 <wroathe> so source, source `using` mapper, and source `and` source `using` mapper should all return the same type of value
16:51:21 <Cale> wroathe: Why not just have something like...
16:52:07 <wroathe> Solonarv: The coffee shop I'm in is about to close. I'll be back on in 5-10 minutes here.
16:52:15 <Cale> okay
16:52:15 <wroathe> brb
16:52:48 <Cale> I think it'll be simpler if there's just some explicit option which collapses to a ConfigNode, and then have merge take a list of those
16:52:57 <Cale> s/option/operation/*
16:53:08 <Cale> and have using also do so
16:53:39 <Cale> So that you either apply using, or you apply this other function
16:55:20 <Solonarv> ...bleh, I can't come up with anything concise
16:55:45 <Cale> If I had his original source, I think the edit would be tiny
16:55:46 <Cale> heh
16:56:22 <Solonarv> same
16:57:04 <Cale> I'd also love to know what the difference between EnvReader and Reader are
16:57:07 <Cale> is*
16:57:35 <wroathe> back
16:58:02 <Guest48> @pl myMap f = foldr (\a b -> f a : b) []
16:58:02 <lambdabot> myMap = flip foldr [] . ((:) .)
16:58:36 <wroathe> Cale: Solonarv This is sort of a "nice to have"
16:58:55 <wroathe> I could just say that the entire expression needs to source the same type of data
16:58:58 <wroathe> But that's no fun at all
17:00:43 <h123> hello, i'm trying to do some profiling of my haskell program.  I'm using stack, and have
17:00:43 <wroathe> I've got that tuple I mentioned earlier aliased:
17:00:45 <wroathe> type Source a = (a -> Reader Options ConfigNode, a)
17:00:49 <h123>     - -with-rtsopts=-p -t --machine-readable -hT
17:01:08 <wroathe> so I'm thinking something involving existential quantification could give me the list type I want
17:01:10 <h123> in my executables: ghc-options: line in my package.yaml file
17:01:16 <h123> but when I compile, I get an error saying:
17:01:29 <h123> ghc: unrecognised flag: -t
17:02:12 <h123> i'm under the impression that the options I put in the -with-rtsopts line will be passed to GHC RTS
17:02:31 <Solonarv> h123: I think you might need to quote them
17:02:35 <h123> but I don't understand why -t isn't recogised -- it is a flag in GHC 8.4.3, which is the GHC I'm using
17:02:50 <Solonarv> i.e. -with-rtsopts='-p -t --machine-readable -hT'
17:02:58 <h123> oh, OK, let me try that
17:03:37 <h123> hmm that didn't seem to help 
17:04:19 <h123> and I even tried double quotes, and that didn't work either
17:05:38 <Solonarv> alright, let's back up a little
17:05:50 <Guest48> @pl myFilter p = foldr (\a b -> if p a then (a : b) else b) []
17:05:51 <lambdabot> myFilter = flip foldr [] . flip flip id . (ap .) . (`ap` (:)) . (((.) . if') .)
17:05:54 <Solonarv> which program are you running, and what do you want those optios to be passed to?
17:06:21 <h123> I'm running stack build
17:06:43 <h123> and I want to profile my haskell program because it is leaking about 1 GB per minute...
17:07:24 <h123> so I was doing some online reading, and it seems I should add some options for the GHC runtime
17:08:02 <h123> looking at the GHC documentation, I should be able to pass those at compile time with the -with-rtsopts argument...
17:08:35 <h123> and using stack I am assuming that I put those in the ghc-options: area of my executables: area in my package.yaml file
17:08:59 <Solonarv> that is something you can do, but probably not a good way of going about it
17:09:03 <h123> I want to add the "-t --machine-readable -hT" arguments
17:09:11 <Solonarv> you can just pass RTS options to your program when you run it
17:09:16 <Solonarv> https://stackoverflow.com/a/32130002
17:09:42 <h123> that's true but then I'll have to remember those arguments every time I want to run it...
17:10:28 <wroathe> Solonarv: Cale I admit that I don't fully get why this works, but I think data Source = forall a. ToConfig a => Source (a -> Reader Options ConfigNode) a might be what I'm after
17:10:32 <zachk> shelll script?
17:10:49 <h123> oh - I see, it must be some pecularity with stack that I can't put it in the package.yaml file like I would have assumed
17:10:50 <wroathe> which lets me do a = [Source toConfig Json, Source toConfig Xml]
17:11:16 <MarcelineVQ> what do your package.yaml and generated cabal file look like?
17:11:18 <Solonarv> shell script, alias, or just pressing ↑ to repeat the previous command
17:11:40 <h123> I'm not sure what a generated cabal file is :)
17:11:51 <h123> but my package.yaml file has
17:11:59 <Solonarv> no! stop!
17:12:01 <geekosaur> package.yaml is an oversimplified version of a cabal file. and you can't put that kind of thing reliably even in a package cabal file, but fi you use cabal v2 commands there's cabal.project and cabal.project.local
17:12:08 <MarcelineVQ> cabal files are what inform a project about how to be built, the package.yaml is a format used to generate cabal a file
17:12:08 <Solonarv> don't copy-paste a big old file in here
17:12:35 <h123> oh man you caught me just in time :)
17:12:38 <MarcelineVQ> And I'm wondering whether there's some mistranslation between the two
17:12:56 <Solonarv> use a site like pastebin, or gist.github.com
17:13:28 <wroathe> Shoot, but if I hide the type of "a", then I have no way of indicating which instance "file" should use :/
17:13:50 <h123> it seems strange that the package.yaml file has lines for adding ghc-options and yet they don't actually work...
17:14:32 <h123> my package.yaml file defaulted to having -with-rtsopts=-N and that worked fine (I assume)...
17:16:51 <Cale> wroathe: Existentials rarely help more than just picking a fixed record type of operations
17:17:39 <h123> solonarv: thanks for that stack overflow link --- I'll try that as you all suggest
17:19:44 <MarcelineVQ> looks like it is some flag passing issue, passing them separately worked on my end. e.g. "-with-rtsopts=-N -with-rtsopts=-t" This does seem to be a stack issue. since even the ghc example of -with-rtsopts="-H128m -K64m" fails here
17:20:53 <MarcelineVQ> *the ghc example https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#setting-rts-options-at-compile-time
17:20:59 <Solonarv> ergh, that's a bit annoting
17:21:35 <geekosaur> it being yaml, I suspect it wants a list format instead of a quoted string
17:21:56 <wroathe> It just seems like this should be an easy use case for Haskell's type system
17:22:11 <MarcelineVQ> geekosaur: No I did it in my cabal file
17:22:31 <wroathe> that is, list of values of any type that I know all share a thing in common
17:22:40 <geekosaur> ah. yes, it didn't handle quotes last I checked
17:24:45 <MarcelineVQ> h123: so it's annoying but not insurmountable, include your flags as separate lines of - -with-rtsopts=-N
17:24:59 <geekosaur> wroathe, newtype wrappers around existentials can do it, otherwise it's too easy to shoot yourself in the foot by forgetting what's not visible because of the forall
17:25:28 <MarcelineVQ> meaning, one flag per line of - -with-rtsopts=-flag
17:26:22 <MarcelineVQ> I'm not sure how nicely that plays with -t --machine-readable I guess you'll find out
17:27:07 <wroathe> Cale: I could make monomorphic versions of file for each type I natively support, (jsonFile, xmlFile, etc), but that's no fun :P
17:27:19 <MarcelineVQ> That it to say I don't know if they need to be together, or just that the documentation happened to use them together
17:27:35 <h123> marcelineVQ: That works well -- that's fine that I have to put them each on a separate line... I did not think to try that myself, thanks.
17:27:48 <wroathe> and then my existential quantification hack should work
17:28:07 <MarcelineVQ> h123: you shouldn't have to, you don't have to on CLI, but it's some sort of bug or lingering cruft it seems like
17:29:32 <h123> marcelineVQ: hmm, when I do it with one argument per line, the -t and --machine-readable don't work together it seems.  When I do it as in the stack overflow article, I do see the output of -t...
17:29:47 <h123> and when I say don't work together it seems I don't see anything
17:30:28 <MarcelineVQ> I think stack adds -ddump-to-file to things on its own, so you might need to look around for files it has made if you didn't get any error.
17:31:10 <MarcelineVQ> It might not do that anymore but that's something I've had to deal with in the past
17:32:09 <MarcelineVQ> how are you running the executable when you don't see anything?
17:32:16 <h123> marcelineVQ: OK, thanks.  I have another question.  I now have a file with an ".hp" extension that I'd like to render with the "hp2pretty" program that apparently is part of stack, but I don't have it on my path.
17:32:35 <h123> I was just running stack exec <my program>
17:34:25 <h123> with the options -t, --machine-readable, as separate lines with the - -with-rtsopts=...
17:34:40 <h123> when i hit ctrl-c in that configuration, I don't see any output from -t at all
17:35:08 <h123> however when I run with all of those arguments as part of the stack exec -- ... command, I do see the machine readable -t output when I push ctrl-c
17:36:37 <MarcelineVQ> I'm not sure what could be at issue there aside from it possibly dumping to files and perhaps not doing that if it's interrupted before finishing, complete guesses there
17:36:47 <h123> if I want to use the hp2pretty program in stack, should I do "stack install hp2pretty"?
17:36:54 <wroathe> Solonarv: Are you working on a gist? (not trying to be pushy, but if you decided to punt on this one I'm going to head out)
17:37:28 <Solonarv> wroathe: I was, but couldn't come up with anything concise that didn't seem overcomplicated
17:37:41 <wroathe> Solonarv: Yeah :/ I'll just go back to the drawing board
17:38:01 <Solonarv> if I had your code to go off of that might help
17:38:38 <wroathe> Honestly I'm just trying to design the API right now. What I've got is somewhere between the previous iteration and this next iteration and it doesn't compile yet
17:38:55 <MarcelineVQ> h123: you'll probably have to, afaik it doesn't come with installs, hp2ps comes with ghc installs which is what ghc has in its documentation https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#hp2ps-rendering-heap-profiles-to-postscript
17:39:15 <wroathe> https://gist.github.com/JustinChristensen/c17cc76133ceae897982bb050e547a0b
17:39:18 <MarcelineVQ> if you have some tutorial explaining to use hp2pretty then you should give it a try
17:40:24 <h123> I'm just not sure how to install it
17:40:28 <wroathe> Solonarv: It's one of those cases where every time I change the API, I see a new way I can generalize things, and then I run into a new problem
17:40:38 <Solonarv> hah
17:40:46 <wroathe> Originally I was fine with having one "merge" or "get" operation per line 
17:40:59 <h123> oh, i would also use hp2ps if I knew how to invoke it
17:41:10 <wroathe> And then I thought, "well, this kind of reads like I should be able to chain `from file` clauses together
17:41:13 <h123> would I do stack exec hp2ps?
17:41:29 <MarcelineVQ> h123: I think so yeah
17:41:35 <wroathe> And then I thought, "wouldn't it be great to also let them specify the configuration mapping function for each term?"
17:41:42 <h123> ooh that worked, thanks!
17:41:58 <wroathe> And then "Wouldn't it be great if each source + mapper term could have a unique type?" :P
17:42:09 <wroathe> And now I'm in this mess
17:42:25 <wroathe> https://gist.github.com/JustinChristensen/c17cc76133ceae897982bb050e547a0b#file-configapi-hs-L97
17:43:33 <wroathe> Solonarv: This is the primary motivating example for being able to specify a mapping function in this way: https://gist.github.com/JustinChristensen/c17cc76133ceae897982bb050e547a0b#file-configapi-hs-L157
17:44:28 <wroathe> Solonarv: That said, don't worry about producing a gist for this. I'm just rubber ducking a bit and soliciting advice. 
17:44:43 <Solonarv> yeah, I think I sort of get what your goal is here
17:44:54 <MarcelineVQ> h123: note that you'll want to use exec with -- most of the time, e.g. stack exec -- hp2ps this -- says that everything after it isn't for stack to worry about, iow any additional the arguments are just for hp2ps
17:46:14 <wroathe> Solonarv: the comment on line 97 is the new "goal" API
17:47:02 <wroathe> So you see, file x y, x `using` y, and x `and` y would all need to have the same type for merge to be able to do it's work
17:47:40 <Solonarv> well, not exactly - 'merge' could be polymorphic
17:49:24 <wroathe> Just by forcing this to be one type of source per line I'd be able to move on and actually implement the damn thing :P
17:49:44 <wroathe> But where's the fun in that
17:52:36 <wroathe> Anyway, I'm heading out. Thanks for the help Solonarv, Cale 
17:53:25 <h123> marcelineVQ: ok, thanks for all the help...
18:30:15 <wroathe> Solonarv, after I walked away I realized that merge can probably become a binary operator
18:31:41 <wroathe> and maybe I can define my own implementation of (>>) that also merges for that tuple
18:44:08 <wroathe> Actually, maybe merge isn't necessary. Maybe I just want >> and >>= to have the semantics of merge and get respectively
18:48:10 <wroathe> file @Json "foo.json" `using` mapper arg1 arg2 >> env `using` envFilter [] >>= \config -> ...
20:45:07 * hackage codeworld-api 0.3 - Graphics library for CodeWorld  https://hackage.haskell.org/package/codeworld-api-0.3 (ChrisSmith)
22:07:25 <bob___> how can I convert from integral type to realfloat? I have this issue where I want to turn two integrals to RealFloat a => Complex a
22:08:34 <iqubic> Why can't you just turn them directly into compex numbers?
22:09:27 <bob___> so I want to do modular exponentiation in complex numbers
22:09:45 <bob___> but the multiplication operator is only defined between items of RealFloat a => Complex a
22:43:41 <iqubic> how hard is it to learn reflexive-dom?
23:00:12 <slack1256> What would be the haskell equivalent of async/await?
23:00:25 <slack1256> I don't understand why are they neccesary, so maybe I'll understand by analogy?
23:00:57 <iqubic> I don't think haskell has this concept.
23:01:38 <iqubic> Those conecpts seem to work better in strict language.
23:01:58 <iqubic> But then again, I'm not too such what those things do either.
23:13:06 <ggole> Async/await is more or less syntactic sugar for CPS
23:13:57 <ggole> The haskell equivalent would probably be some monadic thing
23:15:19 <koz_> If you wanna do stuff like this in a _concurrent_ sense, there's the async package, slack1256.
23:15:34 <koz_> You can read the parallel and concurrent Haskell book's intro on that.
23:16:08 <koz_> If you wanna do stuff like that in a producer/consumer IO sense, there's like, a dozen takes on that theme, from pipes to conduit to potoki to whatever else is new in that space today.
23:16:26 <koz_> The CPS-like thing is if you want coroutine-like stuff, I guess.
23:16:35 <koz_> So it depends in what sense you're referring to async/await.
23:30:57 <iqubic> How hard is it to get a development environment/nix-shell with the haskell reflex-dom library on nixos?
