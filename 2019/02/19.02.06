00:00:48 * hackage amazonka-transcribe 1.6.1, amazonka-marketplace-metering 1.6.1, amazonka-elasticache 1.6.1, amazonka-cost-explorer 1.6.1, amazonka-certificatemanager-pca 1.6.1, amazonka-medialive 1.6.1 (BrendanHay)
00:01:48 * hackage amazonka-sqs 1.6.1, amazonka-devicefarm 1.6.1, amazonka-s3 1.6.1, amazonka-mediaconvert 1.6.1, amazonka-ecr 1.6.1, amazonka-resourcegroupstagging 1.6.1 (BrendanHay)
00:02:48 * hackage amazonka-xray 1.6.1, amazonka-mediapackage 1.6.1, amazonka-marketplace-analytics 1.6.1, amazonka-health 1.6.1, amazonka-directconnect 1.6.1 (BrendanHay)
00:03:48 * hackage amazonka-cloudhsm 1.6.1, amazonka-sms 1.6.1, amazonka-servicecatalog 1.6.1, amazonka-migrationhub 1.6.1, amazonka-codestar 1.6.1, amazonka-iam 1.6.1 (BrendanHay)
00:04:48 * hackage amazonka-kinesis 1.6.1, amazonka-marketplace-entitlement 1.6.1, amazonka-mq 1.6.1, amazonka-discovery 1.6.1 (BrendanHay)
00:16:44 <suzu> Athas: yes
00:17:22 <suzu> i just asked circleci to `stack build && stack test` and if that works then it works
00:17:47 <suzu> it takes forever though, so you might want to use docker images and caching
00:19:56 <spots> Hi, how can I append to a Right list (and skip if its left)?
00:20:24 <suzu> fmap over it
00:20:52 <suzu> > (++ [3]) <$> Left "hi"
00:20:54 <lambdabot>  Left "hi"
00:21:02 <suzu> > (++ [3]) <$> Right [1, 2]
00:21:04 <spots> tried that, but then i got Right [[1,2,3],[4,5,6]]
00:21:04 <lambdabot>  Right [1,2,3]
00:21:10 <tdammers> > fmap (++ [4,5,6]) (Right [1,2,3])
00:21:12 <lambdabot>  Right [1,2,3,4,5,6]
00:21:21 <tdammers> must have tried something else then
00:23:21 <spots> oh, yeah. that works. i tried fmap (:) a <*> Right b
00:23:31 <spots> which didn't work :)
00:23:51 <quicksilver> (++) is not (:) indeed! :)
00:29:04 <tdammers> > fmap (1 :) (Right [2,3]) -- would work too
00:29:06 <lambdabot>  Right [1,2,3]
00:29:34 <tdammers> > fmap (: [2,3]) (Right 1) -- or like this
00:29:35 <lambdabot>  Right [1,2,3]
00:31:46 <spots> what actually happens if you tell to bot to evaluate repeat 'x'?
00:32:04 <quicksilver> try it
00:32:11 <quicksilver> no harm will come to you :)
00:32:25 <spots> > repeat 'x'
00:32:27 <lambdabot>  "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
00:32:32 <spots> ah, nice :)
00:33:55 <sicklorkin> how about length $ repeat 'x'?
00:34:32 <quicksilver> > let xs = 1 : 1 : zipWith (+) xs (tail xs) in xs
00:34:34 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
00:35:18 * hackage hnetcdf 0.5.0.0 - Haskell NetCDF library  https://hackage.haskell.org/package/hnetcdf-0.5.0.0 (DominicSteinitz)
00:35:29 <suzu> > length $ repeat 'x'
00:35:37 <lambdabot>  mueval: ExitFailure 1
00:35:51 <suzu> > length $ repeat 'x'
00:35:59 <lambdabot>  mueval: ExitFailure 1
00:36:03 <suzu> 7s timeout i guess
00:36:06 <spots> i guess it has a timeout
00:36:15 <quicksilver> it has time, CPU and memory limits
00:36:24 <quicksilver> actually maybe not CPU because time is enough
00:36:30 <quicksilver> but time and memory
00:36:35 <suzu> > "\r\n"
00:36:35 <sicklorkin> and a restriction of 78 char output
00:36:37 <lambdabot>  "\r\n"
00:36:43 <suzu> > "\\r\\n"
00:36:45 <lambdabot>  "\\r\\n"
00:36:52 <suzu> > "\\\r\\\n"
00:36:53 <quicksilver> in private message it will do 5 lines of output not just one
00:36:54 <lambdabot>  "\\\r\\\n"
00:37:00 <suzu> hmm
00:37:08 <quicksilver> run my fibonacci one in PM for example
00:37:49 <suzu> > chr <$> [13,10]
00:37:52 <lambdabot>  "\r\n"
00:37:56 <suzu> oh you clever lambdabot 
00:38:25 <merijn> suzu: If you want unescaped text you need to use "text", but I think even then it filters line breaks out
00:38:39 <sicklorkin> > 
00:38:41 <lambdabot>  <hint>:1:1: error: lexical error at character '\SYN'
00:38:46 <cinimod> Climate scientists and sequential Monte Carlo enthusiasts will be pleased to know that I have uploaded a new version of http://hackage.haskell.org/package/hnetcdf
00:38:49 <suzu> > Data.Text.pack $ chr <$> [13,10]
00:38:51 <lambdabot>  error:
00:38:51 <lambdabot>      Not in scope: ‘Data.Text.pack’
00:38:51 <lambdabot>      No module named ‘Data.Text’ is imported.
00:38:54 <merijn> > '☃︎'
00:38:56 <lambdabot>  <hint>:1:2: error: parse error on input ‘☃’
00:39:11 <merijn> What, no utf8 input?
00:39:19 <suzu> @import Data.Text
00:39:19 <lambdabot> Unknown command, try @list
00:39:22 <suzu> wat
00:39:24 <suzu> @list
00:39:25 <lambdabot> What module?  Try @listmodules for some ideas.
00:39:28 <cinimod> But the haddocks don't build because libnetcdf is not present on the hackage server
00:39:48 <cinimod> Is my only option to upload the haddocks manually?
00:39:59 <merijn> > "☃︎" -- like this then?
00:40:01 <lambdabot>  "\9731\65038"
00:40:03 <merijn> Right
00:40:09 <merijn> > text "☃︎"
00:40:12 <lambdabot>  ☃︎
00:40:22 <merijn> suzu: I meant the literal function "text" :)
00:40:25 <suzu> > text $ chr <$> [13,10]
00:40:36 <merijn> > text "foo\rbar\nbaz"
00:40:39 <lambdabot>  foobar
00:40:39 <lambdabot>  baz
00:40:44 <suzu> ruh oh
00:40:46 <merijn> oh, wow
00:41:05 <merijn> I can't believe no one tried that one before :)
00:41:06 <suzu> > text $ "foobar\r\nPRIVMSG #haskell :exploitable"
00:41:09 <lambdabot>  foobar
00:41:09 <lambdabot>  PRIVMSG #haskell :exploitable
00:41:27 <merijn> suzu: lambdabot is less naive than you think ;)
00:41:27 <suzu> guess it isn't exploitable
00:41:29 <sicklorkin> > length"T̗o̪̰ ̡̥i̺̪n͉̖̺̱̲̳̭v͉̰̹̦̝̟o̠͙͉̜͈k̤̘͈̥̝̰͖͝e͇̝̲̝̱̤ ̥͈̭̩͟t͓͚̠h̵̬̳̲̙e ̢͔̰̦̭̳͓ͅh̨̻̰ị̱̠͎̞͎̟v̟̝̯͍͢e̤̜̜̖-͟m͉̼͙̦̟i̭̲̳̼̦͟ͅn̤̖̗̘d̞̜̭̩ ̺̫̣"
00:41:31 <lambdabot>  127
00:41:38 <spots> does it support imports?
00:41:52 <suzu> trusted modules iirc yeah
00:41:53 <merijn> spots: In some limited way, yes
00:41:55 <sicklorkin> > length "m̰̭ͅi̢̘̜n̡d̼̲͢ ̹͙̦̦̥̫̼o̩̦f̧̘͈̣̰̘͉͎ ̦͓͓̞̥͓c̲̺͎h̥͖͡ạ̩́o͕͡s͓̕.̖̟̠̼̪̠͉ ̳̘͓̺̘͙̝́Z̺̙̖̬̞͖͠a͉̬l̬͟ǵ̞̝̯̗͇̳o̵.̢͔̱̫
00:41:57 <lambdabot>  <hint>:1:114: error:
00:41:58 <lambdabot>      lexical error in string/character literal at end of input
00:41:59 <sicklorkin> ̳͟H͟e̼̦̬̮̱͉͠ ̗̩̬̗w̴̭̥̩͈ͅh̗̩̟͈̭͙̦͢ọ̴̖ͅ ̸̠̞̘͈W̴a̯̞i̟̭̤̤̫t̜̲̹͉̩̰͘s̶̳̠ ̴B͎͖͚͔e̤̮h̺̭̟̪̱͓͙͘i̠̫͢n̠̪̹d ̼T̜h̜̤͍ȩ ͎ͅW̛͖͙̟a͝l͓̜̰̭̻̪̻ĺ̫̱͈̦̖̙.͓
00:42:03 <sicklorkin> ̙͢ͅZ̧A͕̘̬͉L̸̠͚̲̦͓G̬̪͉O̡̝̳͓̘!̪"
00:42:08 <spots> i hope System.Process is blocked :)
00:42:14 <suzu> it is
00:42:17 <merijn> There's also yahb which does allow unsafe code but runs sandboxed
00:43:02 <sicklorkin> > U
00:43:03 <suzu> > throwString "fk"
00:43:04 <lambdabot>  <hint>:1:1: error: lexical error at character '\SYN'
00:43:05 <lambdabot>  error:
00:43:05 <lambdabot>      • Variable not in scope: throwString :: [Char] -> t
00:43:05 <lambdabot>      • Perhaps you meant one of these:
00:43:23 <suzu> > error "fk"
00:43:25 <lambdabot>  *Exception: fk
00:43:32 <suzu> > error $ repeat 'x'
00:43:34 <lambdabot>  *Exception: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
00:43:38 <merijn> Anyway, better play with lambdabot via private messages :)
00:43:52 <merijn> So the channel remains actually useful :p
00:44:03 <suzu> if TH is allowed then i think you could do some exploits
00:44:08 <merijn> Although, bonus easter egg:
00:44:11 <merijn> > fix error
00:44:13 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
00:44:23 <suzu> hehe
00:44:38 <suzu> wait why is that in quotes
00:44:47 <merijn> suzu: You can try, but it's pretty battle hardened by now. Also pretty sure TH is blocked
00:44:53 <merijn> :t error
00:44:54 <lambdabot> [Char] -> a
00:45:01 <merijn> :t fix
00:45:02 <lambdabot> (a -> a) -> a
00:45:09 <suzu> i see
00:45:25 <merijn> :t fix `asAppliedTo` error
00:45:27 <lambdabot> ([Char] -> [Char]) -> [Char]
00:45:36 <suzu> wtf
00:45:39 <suzu> :t asAppliedTo
00:45:41 <lambdabot> (a -> b) -> a -> a -> b
00:46:05 <suzu> i see
00:46:32 <merijn> suzu: asAppliedTo is const with more specific type signature to help type inference
00:46:42 <suzu> neat trick
00:47:01 <merijn> suzu: You should look up simple-reflect :)
00:47:09 <suzu> ok!
00:47:13 <merijn> > foldr f z [a,b,c]
00:47:15 <lambdabot>  f a (f b (f c z))
00:47:29 <merijn> Magic!
00:47:55 <[exa]> asAppliedTo is not in any library?
00:48:01 <sicklorkin> My glyphs tiggered some unwanted attention from the irc police
00:48:19 <merijn> [exa]: asAppliedTo isn't, afaik
00:48:33 <merijn> [exa]: But it's two lines to define it yourself :)
00:48:41 <[exa]> oh just realized what it does
00:48:47 <[exa]> what trickery
00:50:57 <[exa]> (side not: I'm always kind of sorry for using #haskell for this kind of problem solving that almost always turns into me getting a rubber duck solution, but it helps so much)
00:58:02 <spots> is there a way to turn of the type-defaults warnings in ghci?
00:58:17 <merijn> spots: The same way you turn them off with ghc? ;)
00:58:43 <spots> never turned them off for ghc, because there it's useful :)
00:59:02 <merijn> spots: All warnings respond to -Wno-the-warning
00:59:14 <merijn> spots: So -Wtype-defaults is disabled via -Wno-type-defaults
01:06:16 <archie> any idea if we can still get at TMR code like: https://archives.haskell.org/code.haskell.org/~byorgey/TMR/Issue17/Convert.lhs
01:06:47 <archie> ?
01:06:53 <archie> the link works up to https://archives.haskell.org/code.haskell.org/
01:13:08 <|{ame> hello, I cannot figure how I can use whenJust / whenJustM
01:13:20 <|{ame> I can write it by cases
01:13:24 <|{ame> mscreenWorkspace:: Maybe ScreenId -> X(Maybe WorkspaceId)
01:13:24 <|{ame> mscreenWorkspace (Just x) = screenWorkspace x
01:13:27 <|{ame> mscreenWorkspace Nothing = return Nothing
01:14:05 <|{ame> but if I try any combination like mscreenworkscape = whenJust x screenWorkspace
01:14:16 <|{ame> it is incorrect
01:15:08 <sicklorkin> whenJust, isJust, isNothing should be avoided imo
01:16:29 <sicklorkin> if you must.. case maybeSomething of Nothing -> ... ; Just something -> ...
01:18:33 <tdammers> why would you avoid them?
01:18:49 <sicklorkin> tdammers: i find it leads to unmanagable code
01:19:32 <tdammers> got an example? because I can't think of a situation where they are problematic
01:19:45 <tdammers> fromJust is a different story though
01:20:24 <tdammers> and obviously if you are actually interested in the value in a Just, then you shouldn't be using ifJust / whenJust
01:20:26 <sicklorkin> tdammers: whenJust $ fromJust m'foo
01:20:28 <merijn> tdammers: isJust means "should've used pattern matching, generally"
01:20:43 <merijn> |{ame: FYI "whenJust" is basically just "forM_" :)
01:20:50 <merijn> Or "traverse_"
01:21:05 <maerwald> except now more obfuscated
01:21:12 <tdammers> sometimes you really only want to know whether something is a Just, and don't care about what's in it
01:21:25 <sicklorkin> > mapM id [Nothing, Just 1, Just 2]
01:21:26 <tdammers> plus you can't easily pass pattern-matching contexts as predicates
01:21:28 <lambdabot>  Nothing
01:21:51 <merijn> sicklorkin: No, you traverse_ the Maybe, not a list of them
01:22:17 <sicklorkin> merijn: I'm just warning of possible misuses
01:22:46 <tdammers> so the problem is the misuse of the thing, not the thing itself
01:22:49 <sicklorkin> tdammers: i guess it's just about personal preference.. 
01:24:09 <cinimod> Well I uploaded the haddocks manually but the hyperlinks to other packages are screwed
01:24:20 <merijn> cinimod: How did you generate them?
01:24:27 <cinimod> That will have to do as there are only so many hours in the day
01:24:34 <cinimod> stack haddock
01:24:58 <merijn> cinimod: I dunno what stack does, I know cabal-install has a "--haddock-for-hackage" flag to generate proper hyperlinks
01:25:26 <cinimod> Sadly cabal does not work for me - I get lots of "can't find iconv" errors
01:25:39 <cinimod> OTOH stack does work so I used it
01:26:31 <cocreature> You can’t use stack to generate proper haddocks for hackage. There is an open issue for it but nothing has happened there for years
01:26:42 <merijn> cinimod: Lemme guess, your on OSX, using MacPorts libraries and installed GHC yourself?
01:27:29 <cinimod> almost right: OSX, homebrew and it's so long ago I can't remember
01:28:02 <cinimod> My methodology is to try cabal, stack and nix and hope one of them works
01:28:13 <merijn> cinimod: I know MacPorts insist on linking against libiconv different from the system one which breaks everything when combined with the default GHC build (which uses the system version)
01:28:26 <merijn> I thought Homebrew should "do the right thing", but I dunno
01:28:31 <cinimod> Yes that's the problem
01:29:11 <merijn> AFAIK Homebrew uses the system libiconv too, but that should only affect you if your using C libraries installed via homebrew/macports anyway
01:30:14 <spots> how can i convert an Int to an Integral type?
01:30:16 <cinimod> It seems to get stuck trying to build happy
01:30:43 <merijn> cinimod: On OSX I just install the GHC bindist and cabal myself and build everything via cabal, although I have to admit I'm not using any C libs via macports/homebrew, because that might screw with things
01:30:48 <merijn> spots: fromIntegral
01:30:50 <merijn> :t fromIntegral
01:30:52 <lambdabot> (Num b, Integral a) => a -> b
01:31:20 <merijn> spots: (Num is a superclass of Integral)
01:31:30 <cinimod> merijn: thanks very much I may try later when I have time
01:32:05 <cinimod> At least the world is a slightly better place now (admittedly it could be even better)
01:32:06 <spots> ah thanks. i tried fromInteger, but then i got an error that haskell couldn't match Int with Integer
01:34:47 * hackage ridley 0.3.1.3 - Quick metrics to grow your app strong.  https://hackage.haskell.org/package/ridley-0.3.1.3 (MikolajKonarski)
01:35:08 <Taneb> spots: the reason for that is in Haskell, Integer is an unbounded integer, and Int is some machine-ish sized int
01:36:36 <spots> Taneb: that's why i would expect a function which handles Integer to be able to handle Int :)
01:37:04 <phadej> there's no subtyping in Haskell
01:37:19 <phadej> there is explict conversion functions though
01:37:22 <phadej> :t fromIntegral
01:37:23 <lambdabot> (Num b, Integral a) => a -> b
01:37:28 <sicklorkin> what are the common use cases for using Integer? 
01:37:55 <sicklorkin> I can only think of one package in base that uses it, UTCTIme
01:37:57 <tdammers> any whole numbers that may grow too large to fit safely in a machine-sized-ish integer
01:38:10 <sicklorkin> erro.. no.. gregorian 
01:38:23 <maerwald> isn't there optimisation anyway wrt Integer?
01:38:24 <Taneb> sicklorkin: interchange formats when you don't want to care about how big things can get (ag. the aeson library uses it for JSON integers)
01:38:27 <maerwald> Some end up as Int
01:38:50 <tdammers> sort of - Integers that fit inside a single Int have very very little runtime overhead
01:38:51 <Taneb> maerwald: I think it tries to keep them in Int-sized boxes as long as it can
01:39:17 <tdammers> but I believe there is still a tiny bit of logic to handle that special case in the first place
01:39:55 <sicklorkin> Taneb: I see.. so if I had some generation number that I expect to increase, even when i die, i'd use an Integer?
01:40:01 <merijn> cinimod: tbh, I actually use that on every single *nix OS as it's been the most reliable/robust method for me :)
01:40:18 <tdammers> but GHC is most definitely not smart enough to infer the maximum size at compile time and secretly turn those Integers into Ints for you
01:40:39 <unit73e> I've been trying to find a good solution to make games in haskell. Anyone found one yet or not really? Last time I checked the best thing was FRP.
01:40:54 <spots> is it possible to define two variables in one line with let?
01:41:07 <merijn> sicklorkin: Integer is just a wrapper around libgmp (albeit a super fast and efficient one)
01:41:15 <sicklorkin> spots: let (a,b) = (2,3)
01:41:44 <merijn> sicklorkin: In fact, GHC's Integer is arguably the fastest libgmp binding in the world ;) http://www.wilfred.me.uk/blog/2014/10/20/the-fastest-bigint-in-the-west/
01:42:07 <maerwald> let [a, b] = [2, 3] is also cool but it confuses some ghc checks lol
01:42:42 <sicklorkin> spots: (,) will allow you to use different types
01:43:10 <merijn> Or, you know, braces and semicolons :p
01:43:26 <merijn> > let { a = 2; b = 3; } in a + b
01:43:28 <lambdabot>  5
01:43:30 <Ariakenom> > let a = 2; b = 3; in a + b
01:43:32 <lambdabot>  5
01:43:58 <spots> i like the last one :)
01:44:07 <Ariakenom> > let a = 2; b = 3 in a + b
01:44:09 <lambdabot>  5
01:44:13 <Ariakenom> on less ;
01:44:19 <Ariakenom> one less ;
01:45:44 <sicklorkin> merijn: does it use SIMD?
01:46:37 <merijn> sicklorkin: It uses whatever libgmp does. There's work on SIMD support in GHC, but it's still early stages. You should ask carter in #numerical-haskell if you like that sorta thing
01:47:19 <merijn> Also, browsing through the contents of ghc-prim can be fun if you care about low level details :)
01:47:32 <Ariakenom> sicklorkin: "On the x86 chips, MMX has so far found a use in mpn_rshift and mpn_lshift, and is used in a special case for 16-bit multipliers in the P55 mpn_mul_1. SSE2 is used for Pentium 4 mpn_mul_1, mpn_addmul_1, and mpn_submul_1."  https://gmplib.org/manual/Assembly-SIMD-Instructions.html
01:49:21 <merijn> sicklorkin: https://hackage.haskell.org/package/ghc-prim-0.5.3/docs/GHC-Prim.html#g:29 :)
01:49:25 <Ariakenom> I've found the gmp docs interesting
01:50:11 <merijn> People who think Haskell is too high level don't spend enough time with GHC.Prim and -XMagicHash ;)
01:50:12 <sicklorkin> merijn: i find this work very exciting
01:51:05 <sicklorkin> merijn: i have worked on a few projects in my day
01:51:43 <merijn> sicklorkin: If you have a bit of background with this sorta stuff, GHC could use more people working on it, I'm sure carter can point you to good starting points :)
01:52:17 * hackage ridley-extras 0.1.0.2 - Handy metrics that don't belong to ridley.  https://hackage.haskell.org/package/ridley-extras-0.1.0.2 (MikolajKonarski)
01:53:58 <sicklorkin> merijn: i'll keep that in mind.
01:54:42 <sicklorkin> merijn: i'm just rying to get my own project running first.. :P
02:36:10 <fr33domlover> TVar question: I have a pair of values I periodically update using an IO action. One thread updates, and all other threads just read the values. Should I keep the values in 2 TVars or in 1 TVar holding a tuple?
02:37:23 <kadoban> Are the values related, must they be kept in sync?
02:43:37 <fr33domlover> kadoban, they're related but the updates happen like this: Sleep for 1 hour, update value A, sleep 1 hour, update value B, sleep one hour, update value A... and so on
02:44:35 <kadoban> Probably doesn't matter at all then really
02:44:37 <fr33domlover> kadoban, one read access of the values is that I generate HTTP responses that include both of them, but it's hard to get our of sync I think? Because there is always a whole hour between changes
02:45:23 <fr33domlover> kadoban, if instead of 1 hour it was something much smaller, would you say keep them in 1 TVar to make sure they're in sync?
02:46:06 <merijn> fr33domlover: Do you ever wanna update them independently?
02:46:58 <kadoban> If there's a danger of one getting updated but not the other (yet) and reads getting mangled partial updates, then you definitely want them combined. Otherwise I don't think it matters really, you should pick based on how convenient or performant or whatever either choice is.
02:47:14 <kadoban> Could be missing some consideration
02:50:26 <merijn> kadoban: Less TVars == more efficient, because smaller transaction log, less chance of one being changed, etc.
02:51:04 <merijn> fr33domlover: Also, how many threads are reading updates and does every thread have to process every update?
02:52:57 <fr33domlover> merijn, all the threads that read the values are short lived. They start, read the Tvar (soe threads need just one of the values, some need both) and shortly after they die. It's an HTTP server so those threads are request handlers, they get spawned all the time
02:53:27 <fr33domlover> merijn, hmmm so theoretically you can keep all your TVar-needing application state in a single big TVar?
02:53:38 <fr33domlover> (And practically? :P)
02:53:49 <merijn> fr33domlover: Theoretically? Sure. Practically? It depends
02:53:53 <tdammers> it really boils down to what "consistency" means for your problem domain
02:54:35 <fr33domlover> I'm guessing using separate TVars is better if there is a mix of independent updates?
02:54:38 <tdammers> does it make sense to change those two variables independently, or does consistency hinge on both of them relating in a certain way
02:54:54 <merijn> fr33domlover: GHC's STM is based on optimistic locking, which means that efficiency is affected by "odds of someone running a conflicting transaction while this is processing"
02:55:48 <fr33domlover> merijn, well in my case 1 thread does the once-an-hour updates, all other threads just read
02:56:19 <merijn> fr33domlover: So, shrinking the size/duration of transactions and limiting the number of TVars accessed improve performance (smaller chance of conflicting transactions). Larger transactions (in time and TVars accessed) result in more conflicts and thus more retries, lowering performance
02:56:34 <merijn> fr33domlover: Honestly, with "once an hour" updates it really doesn't matter a thing what you do :p
02:57:44 <fr33domlover> Ok I'll use 1 TVar then ^_^
02:57:51 <fr33domlover> Thanks tdammers merijn kadoban :)
02:58:02 <merijn> I mean, even an MVar or whatever would be completely negligible overhead
03:02:13 <tdammers> if it's once per hour, you could probably even use a file on disk, and be fine
03:40:17 * hackage vector-builder 0.3.7.2 - Vector builder  https://hackage.haskell.org/package/vector-builder-0.3.7.2 (NikitaVolkov)
04:07:47 * hackage fields-json 0.2.2.4 - Abusing monadic syntax JSON objects generation.  https://hackage.haskell.org/package/fields-json-0.2.2.4 (MikhailGlushenkov)
04:26:00 <aplainzetakind> I want a type of natural numbers starting at 1. It seems there's no such library. I could newtype an existing one and override every relevant thing shifting by one I guess. In that case, once I write Num and Read instances, can I immediately work with literals?
04:26:40 <kritzefitz> aplainzetakind, AFAIK you only need a Num instance to use literals.
04:26:41 <merijn> aplainzetakind: Honestly, that sounds like probably a terrible idea :)
04:27:13 <merijn> aplainzetakind: I would probably just do the usual newtype with unexported constructor and "smart" constructor approach
04:28:21 <aplainzetakind> merijn: I only intend to use it as an index of sorts. I have data Foo = Foo Nat , and Foo 0 existing is kind of nonsense.
04:28:32 <aplainzetakind> What's that approach exactly?
04:29:00 <merijn> aplainzetakind: Have a newtype, don't export the constructor, export "mkMyNewtype :: Int -> Maybe MyNewtype"
04:29:04 <Taneb> newtype Foo = Foo Nat -- dont export constructor, foo :: Nat -> Maybe Foo
04:29:16 <merijn> aplainzetakind: And anything value < 1 just returns Nothing
04:31:17 <aplainzetakind> Hmm. That would give rise to a lot of Maybes to handle.
04:31:35 <merijn> aplainzetakind: For user input you have to handle those anyway
04:32:02 <merijn> aplainzetakind: Or do you have to write literals in the source code?
04:33:00 <aplainzetakind> I don't have to but I'd really like to. I mean otherwise I could just use any old Nat and just mentally be aware of the fact that zero means one.
04:33:02 <merijn> aplainzetakind: Because I already solved that issue because it annoyed me ;)
04:33:09 <merijn> @hackage validated-literals
04:33:10 <lambdabot> http://hackage.haskell.org/package/validated-literals
04:34:10 <merijn> Although validInteger might be a bit long to type, maybe I should define shorter names for that
04:34:17 * hackage failable 1.1.0.0 - A 'Failable' error monad class to unify failure across monads that can fail  https://hackage.haskell.org/package/failable-1.1.0.0 (erick)
04:34:32 <merijn> aplainzetakind: Even has an example of how to compile-time check that integrals or Even ;)
04:34:46 <merijn> s/or/are
04:38:13 <aplainzetakind> Nice.
04:40:13 <aplainzetakind> Ah, but what I'm doing may be a bit more problematic.
04:40:50 <sicklorkin> aplainzetakind: How is `Nat` used?
04:41:31 <aplainzetakind> I have `Foo = Foo Int`, and pattern synonyms Neg n, Zero, Pos n, for three ranges of values.
04:42:06 <aplainzetakind> Neg :: Nat -> Foo, etc.
04:42:33 <aplainzetakind> I'd like to rule out Neg 0
04:43:18 <sicklorkin> aplainzetakind: I see.. 
04:48:30 <merijn> aplainzetakind: tbh, that requires Dependent Types (or faking it with GADTs) and is not going to be particularly pleasant or easy
04:48:48 <merijn> aplainzetakind: oh, actually, you know what you need? LiquidHaskell
04:51:24 <cocreature> don’t we all need a bit more liquidhaskell in our lifes :)
04:51:39 <merijn> cocreature: Do you know how LiquidHaskell affects compile times?
04:53:48 <cocreature> merijn: it shells out to an SMT solver, so given experience with SMT solvers I’d say “you’re lucky if it terminates within your lifetime” :)
04:55:22 <hpc> like some kind of super-agda
04:55:38 <hpc> instead of "if it compiles, it works", it's "if it takes more than an hour without failing, it works"
04:56:07 <merijn> hmm, that kinda rules out my idea of "I should use it everywhere" :p
04:58:20 <cocreature> it’s probably not so bad. I would expect that they do a fairly good job at not sending weird things to z3
04:58:53 <merijn> Next time I have time (ha! funny joke!) I should extend haskell-ci to allow auto running of liquid haskell on Travis :p
05:01:00 <hpc> merijn: https://youtu.be/MqiiCD7ECVk?t=20 - your patch notes when you get around to it
05:05:56 <xenon-> how can I see what -N defaults to on my computer? it doesn't appear to be -N4 (my CPU has 4 cores) or -N8 (8 hyperthreads)
05:06:37 <merijn> xenon-: By default the RTS uses "1", unless you pass in -N with no arg, then it will use getNumProcessors
05:07:08 <merijn> % GHC.Conc.getNumProcessors --I wonder...
05:07:08 <yahb> merijn: 1
05:07:10 <xenon-> I compiled with -O2 -threaded -rtsopts -with-rtsopts -N
05:07:12 <merijn> :)
05:07:21 <merijn> xenon-: That is...probably a bad idea ;)
05:07:29 <xenon-> oh? why
05:08:03 <merijn> xenon-: Because the RTS doesn't scale linear with number of cores and that approach is fairly naive (always use number equal to core count). Better to set the number programmatically
05:09:01 <merijn> xenon-: You can use getNumProcessors and setNumCapabilities (from GHC.Conc) to query the processor count and programmatically set the RTS thread count
05:11:48 * hackage brok 0.1.2.0 - Finds broken links in text files  https://hackage.haskell.org/package/brok-0.1.2.0 (smallhadroncollider)
05:14:10 <dminuoso> xenon-: You should read Simon Marlows book on "Parallel and Concurrent Programming in Haskell"
05:14:55 <xenon-> I did this.   case args of     ["cpu"] -> getNumProcessors >>= printf "getNumProcessors => %d\n"
05:14:59 <dminuoso> It's available for free a pdf on archive.org, or as print. That book is really fine. :)
05:15:22 <xenon-> and it always prints 8, even if I do program +RTS -N4
05:15:32 <xenon-> dminuoso I'll take a look
05:15:48 <dminuoso> xenon-: Perhaps intel bullshitting?
05:16:13 <xenon-> 4 cores, 8 hyperthreads. but that doesn't explain why -N<any number> has no effect?
05:16:59 <srhb> xenon-: Are you confusing getNumProcessors and getNumCapabilities?
05:17:11 <xenon-> looks like I am!
05:17:45 <dminuoso> xenon-: Do take note that the notion of "logical cores" is greatly misleading, a real big marketing trick.
05:20:00 <xenon-> would -N4 be a better default for my machine?
05:20:24 <dminuoso> xenon-: No, because of what merijn said.
05:20:28 <dminuoso> xenon-: You should read the book. :-)
05:20:29 <xenon-> user can then change it, but I need some default. (and, if I'm compiling for other machines as well, is there a better default than -N)?
05:22:06 <xenon-> I must be missing something. isn't this exactly what -N is doing? xenon-: You can use getNumProcessors and setNumCapabilities (from GHC.Conc) to query the processor count and programmatically set the RTS thread count
05:24:36 <xenon-> I am not reading a book to figure out what to set num capability too (at least not at this moment :) ).  I don't see why -N is any worse of a default than some other number. it is certainly better than -N1
05:25:34 <srhb> xenon-: You could arguably avoid HT inflating the core count by doing it programattically, but I too think it's difficult to set a very sane default no matter the program and hardware.
05:26:05 <merijn> xenon-: My suggestion wasn't to use that value directly :)
05:26:50 <merijn> xenon-: I've benchmarked the threaded runtime on several machines with >16 physical cores and performance can drop *drastically* if you use more than 8-12 threads without further tweaking
05:27:09 <xenon-> merijn, I have no clue what to set it too, other than what numProcessor returns. and wouldn't exact optimal value be very depepndant on the machine, the number of cores on that machine, and what the program is doing? I have a single multithreaded haskell program, and a single machine I'm testing this one
05:27:23 <xenon-> on*
05:28:11 <merijn> xenon-: Finding the optimum will be machine dependent yes, but for larger core counts the number of cores is almost certainly "not it" :p
05:28:17 <xenon-> merijn oh, you meant that. I've actually read something about that while googling about -with-rtsopts
05:28:23 <dminuoso> xenon-: Well you can use ThreadScope to profile your program.
05:28:28 <merijn> xenon-: I'd probably do something like "min numCores 4" or "min numCores 8"
05:30:10 <merijn> xenon-: If you're letting the user specify the actually number I'd advice to err towards "too low" instead of "too high"
05:30:17 <merijn> s/actually/actual
05:34:02 <xenon-> ok, this is weird
05:34:12 <xenon-> compiled with ghc-options:     -O2 -threaded -rtsopts -with-rtsopts -N
05:34:18 * hackage brok 0.1.3.0 - Finds broken links in text files  https://hackage.haskell.org/package/brok-0.1.3.0 (smallhadroncollider)
05:34:39 <xenon-> getNumCapabilities >>= printf "getNumCapabilities => %d\n"  prints 1
05:34:53 <xenon-> unless I specifically set it to something else
05:35:15 <xenon-> +RTS -N prints 1 too. is that the new default?
05:37:29 <xenon-> everything I've read earlier says -N should use the num capabilities to the number of cores. and, yes, I realize that this can be a bad idea. but why isn't it doing what it should?
05:37:43 <xenon-> s/use/set
05:38:34 <merijn> I wonder if capabilities are spawned "on demand"?
05:38:51 <merijn> xenon-: Do you actually fork any threads in that code? :)
05:39:55 <xenon-> yes. I'm using mapConcurrently on 20 objects 
05:40:07 <sicklorkin> merijn: i think you're right.. i saw some patch for this a while back
05:40:29 <merijn> mmm
05:42:58 <sicklorkin> merijn: i must be mis-remembering i can't find it
05:43:46 <sicklorkin> but i'm pretty sure cap will be tossed around between core
05:44:40 <xenon-> benchmark wise, -N and -N1 perform the same. -N4 cuts the runtime down several times
05:50:17 * hackage taskell 1.3.5.0 - A command-line kanban board/task manager  https://hackage.haskell.org/package/taskell-1.3.5.0 (smallhadroncollider)
05:54:03 <xenon-> weirdness of -N aside, changing mapM to mapConcurrently and compiling with -threaded support, reduced the runtime from 157 seconds to 30 seconds :P
05:54:59 <merijn> xenon-: Are these tasks IO bound?
05:55:25 <xenon-> they should be, but since I'm using String I'm not entirely sure (about to convert my code to Text)
05:55:53 <merijn> xenon-: Curious what happens if you just use mapConcurrently without -threaded :)
05:56:27 <merijn> xenon-: If they're IO bound you might get the exact same performance with that
05:57:47 * hackage metar-http 0.0.2 - HTTP for METAR  https://hackage.haskell.org/package/metar-http-0.0.2 (TonyMorris)
05:58:56 <xenon-> 30 seconds with -N4 and -N8. 39 seconds without -threaded (same as with -threaded and -N1, so pretty expected)
06:00:21 <merijn> Still pretty good increase :)
06:00:22 <xenon-> I wonder if numbers would change if I started launching more than 20 haskell threads (which I could do with little modification on the code)
06:00:26 <xenon-> yes
06:01:21 <merijn> xenon-: Threads are pretty cheap, but you might (over)saturate your IO throughput (or, speaking from personal experience, accidentally take out a poor webcomic hosted on a cheap server with a single machine...)
06:01:51 <merijn> Turns out some servers don't like several thousand concurrent requests :)
06:02:33 <Solonarv> huh, no server-side limit on connection count?
06:03:13 <merijn> Solonarv: Hitting the server-side limit is indistinguishable from taking out the server, as you've effectively DOS'ed it :)
06:03:43 <Solonarv> merijn: not if the limit is separate for each peer!
06:03:57 <xenon-> I'm scraping a web page. mapConcurrently scrapePage urls. there are 20 urls per page. I could also advance to the next page concurrently (there are 10 pages, each with 20 links I'm following). it is a big website, so it could probably handle it. but I'm not sure I want to hammer it so much 
06:03:59 <merijn> Solonarv: See "cheap server" :)
06:04:35 <Solonarv> xenon-: IIRC there's an async-pool library which seems perfect for this
06:04:56 <Solonarv> you could make sure you only have, say, 10 worker threads, so you're not hammering the server
06:04:56 <merijn> ALso, I wrote a library perfect for this, because I kept having this issue ;)
06:05:46 <Solonarv> oh? what's it called?
06:05:50 <merijn> It even comes with a conduit wrapper so you can easily stream/feed in data ;)
06:06:12 <merijn> Solonarv: I'm mostly using the conduit wrapper: https://hackage.haskell.org/package/broadcast-chan-conduit-0.2.0.1/docs/BroadcastChan-Conduit.html
06:06:38 <merijn> Solonarv: Even comes with handling for failures (ignore, exception, or retry!)
06:07:07 <Solonarv> niiice
06:07:24 <merijn> Solonarv: parMapM basically spawns N threads and functions as a rate limited conduit, i.e. it backpressures to whatever feeds into it
06:08:23 <merijn> Solonarv: So if you spawn N threads it will consume 2N values from the Source (N to saturate the workers and N as "buffer" to keep processing immediately) and then only consume new values from the Sink when one of the N in flight values has finished and been yielded downstream
06:09:09 <c_wraith> conduit is pull-based, right?  So the yield will only return after the downstream has consumed it?
06:09:15 <merijn> I've been thinking about making a non-rate limited version too, but lack of backpressure might "blow up" the memory of the queued task
06:09:29 <c_wraith> yeah, backpressure is good.
06:09:36 <c_wraith> Too easy to blow up queues otherwise
06:09:53 <c_wraith> Been there, done that, crashed servers in production
06:10:07 <merijn> c_wraith: I could make it more independent and keep back pressure, but then you (effectively) need two threads (one for the source, one for the sink)
06:10:28 <merijn> This one runs the entire conduit in one thread and only farms out the function
06:12:45 <c_wraith> Hmm.  Two threads would have advantages if waiting for upstream ever blocks
06:13:18 <merijn> c_wraith: Right, but this is good enough for what I have now, I might add that later. There's other items on my wish list I should finish first
06:14:11 <merijn> c_wraith: I just got tired of half my projects having the same half-baked parallel data processing with cleanup code, so I figured I'd just implement it properly once. Although I'm starting to feel that over time the package name has slowly become somewhat misleading :p
06:14:23 <c_wraith> it is, a bit.
06:15:10 <merijn> c_wraith: To be fair, the main package is still a broadcast channel, but slowly morphing more into a "batteries included Chan library that will obsolete base and take over the world!"
06:15:28 <merijn> Especially if/when I get around to STM based versions
06:16:22 <merijn> otoh, thinking up a new name is hard :p
06:17:59 <c_wraith> also, you can't remove the old name
06:20:14 <merijn> c_wraith: Yeah, but it could at least deprecate and point to a better named package
06:20:26 <merijn> Oh well, you live, you learn
06:23:15 <gentauro> I once asked how to change `Prelude>` to `λ>` in `GHCi` and somebody told me how to do it with a `config` file placed in `~/`. I seem to have `/bin/rm` it (anybody can help) xD
06:23:45 <Taneb> ":set prompt λ> "
06:23:55 <sshine> https://coderwall.com/p/13h9bw/colored-ghci-prompt-with-and-modules-on-separate-lines
06:24:30 <gentauro> sshine: :o
06:24:32 <gentauro> that is nice
06:25:51 <gentauro> oh, maybe not ...
06:26:06 <gentauro> (I mean the second one)
06:27:55 <gentauro> btw, I will use Taneb as I'm not able to see the color sshine (color blinedes, here we go again)
06:29:25 <Solonarv> bleh, ansi escape codes are broken in windows cmd/powershell
06:29:32 <Solonarv> this really shouldn't surprise me...
06:30:38 <gentauro> Solonarv: so you haven't use `patat` amirite? :P
06:30:57 <c_wraith> I miss writing directly to memory space that was mapped to VRAM in text mode.  Alternating bytes were the character to display and the color to use.   The good old days....
06:31:20 <Solonarv> I don't know what patat is, so I probably haven't used t!
06:32:31 <gentauro> Solonarv: another nice project from Jasper -> https://github.com/jaspervdj/patat
06:34:26 <Solonarv> oh, neat!
06:34:34 <gentauro> tl;dr -> "Nerdy" way of making slides in ASCII
06:34:52 <gentauro> I'm amazed on how good code snippets look :o
06:35:21 <c_wraith> and there were glyphs for bytes 0-31!  Skipping the standard IO routine made them display, instead of being treated as control codes!
06:37:11 <hsn> assignment to variable returns value? so it can be used in expression
06:37:37 <Solonarv> hsn: no
06:37:46 <Solonarv> 'foo = bar' is not an expression
06:37:54 <merijn> hsn: There is no assignment
06:38:20 <Solonarv> it's either a top-level declaration, or part of a syntactic construct
06:38:52 <merijn> Solonarv: Everything is a syntactic construct >.>
06:40:11 <Solonarv> well, fair. 'foo = bar' is only part of specific syntactic constructs: 'let', 'where', 'class' and 'instance' declarations, as well as top-level bindings
06:40:17 <Solonarv> (let me know if I've forgotten any)
06:42:03 <merijn> data, type family declarations, data family declarations ;)
06:42:52 <Solonarv> I was assuming 'foo' is a variable identifier (is that the right term?), so those don't count.
06:43:17 <merijn> Solonarv: Except that let and where don't require foo to be an identifier :)
06:43:21 <kritzefitz> Solonarv, Record constructors.
06:43:35 <Solonarv> ah! yes, I'd forgotten about record syntax
06:43:45 <c_wraith> easy to do
06:44:06 <merijn> Solonarv: Fun fact "[a,b,c] = [1,2,3]" is perfectly valid at the top level to created bindings 'a', 'b', and 'c' :)
06:44:46 <Solonarv> I know. The question was about *variable* assignment, so I was only talking about 'foo = <whatever>' where foo is syntactically a variable
06:44:59 <hsn> why it is that way? it is lisp herritage? In C assignment returns value and is not selling point of functional laguages that everything has return value?
06:45:37 <c_wraith> hsn: it's because it's a very low-value feature when you don't have mutation
06:45:43 <Solonarv> "variables" are immutable: once assigned you can't change their value
06:45:59 <kritzefitz> `let` is an expression, though.
06:46:12 <c_wraith> in c you have good reasons to write a = b = c = 0;
06:46:12 <kritzefitz> But I think in a different way than you were thinking when you asked.
06:46:18 <Solonarv> so if you bind two variables to the same value, they will always be bound to the same value; then, what's the point in having two names?
06:46:20 <c_wraith> in Haskell, that's entirely useless.
06:47:03 <Solonarv> kritzefitz: 'let' isn't an expression. 'let { <bindings> } in <expr>' is.
06:47:14 <kritzefitz> touchè
06:47:16 <xenon-> it wouldn't be entirely useless, assuming this was initialization and not assignment (since haskell doesn't have assignments). let a = b = c = 0 in (a,b,c)
06:47:26 <c_wraith> it would have more value to be able to name subexpressions inline, but it also introduces scoping rules.
06:47:44 <Solonarv> xenon-: sure, but how's that better than 'let a = 0 in (a, a, a)'?
06:48:26 <rotaerk> the more you cram into a language, feature wise, the more complicated the language gets, and the more the features have to play well with each other ... so you have to be selecctive about what you include
06:48:29 <c_wraith> as-patterns give you somewhat similar functionality in the context of pattern matches.  Scoping and evaluation order are a lot better defined in that context.
06:49:05 <Solonarv> % let a@b@c = 0 in (a, b, c) -- oh right, you can just do this
06:49:06 <yahb> Solonarv: (0,0,0)
06:49:12 <Solonarv> but please don't.
06:49:20 <rotaerk> lol
06:49:34 <rotaerk> why not?
06:49:46 <c_wraith> because you're still assigning three names to one value
06:49:53 <c_wraith> err.  binding three names
06:50:01 * Solonarv : you feel your sins crawling down your back
06:50:06 <c_wraith> it can only cause confusion
06:50:13 <rotaerk> I guess there's no value in it since you can just re-use the same name multiple times
06:50:22 <Solonarv> aye
06:50:46 <xenon-> Solonarv, it isn't any better in that case
06:50:55 <rotaerk> the thing that should be comparing to a = b = c = 0 isn't haskell bindings, but mutation, say, of IORefs
06:51:16 <Solonarv> indeed; for those the question at least isn't malformed
06:52:33 <rotaerk> a -> [IORef a -> IO ()] -> IO ()
06:53:04 <c_wraith> that doesn't give you a bunch of refs in scope, though.  it takes a bunch.
06:53:09 <c_wraith> Kind of the opposite
06:53:10 <Solonarv> you can write: [a, b, c] <- replicateM 3 (newIORef blah)
06:53:44 <rotaerk> oh thought we were just talking about assigning to multiple refs in one expression
06:54:00 <rotaerk> but yeah for creation, what Solonarv said
06:54:23 <c_wraith> Not precisely low-syntax.  Then again, syntactic unwieldiness of mutation is a feature of haskell.  It makes you want to do something else instead. :)
06:54:24 <Solonarv> you could write a more type-safe variant of it that won't fail at runtime, if you want
06:55:14 <rotaerk> yeah, there's no need for special, concise syntax for something that should be relatively uncommon in the language...
06:55:32 <rotaerk> adds complexity to the language for little benefit
06:58:10 <xenon-> does TagSoup use string internally even if you pass Text everywhere? this is post from 2012, so I'm not sure if it is still relevant. https://stackoverflow.com/questions/2292729/with-haskell-how-do-i-process-large-volumes-of-xml/12954187#12954187
06:58:35 <xenon-> "You could try my fast-tagsoup library. It's a simple replacement to tagsoup and parses at speeds of 20-200MB/sec.  The problem with tagsoup package is that it works with String internally even if you use Text or ByteString interface. fast-tagsoup works with strict ByteStrings using high-performance low-level parsing while still returning lazy tags list as output."
06:58:38 <c_wraith> it sounds kind of dumb to say it, but I actually think syntactic difficulty is a really important part of a language.  A language should have an opinion of the best way to do things, and use its syntax to convey that to the programmer.
06:59:13 <merijn> xenon-: One way to find out :)
06:59:17 <c_wraith> Haskell's opinion is "use pure functions and pattern matching"
06:59:24 <merijn> xenon-: Open the source of tagsoup
06:59:55 <c_wraith> merijn: I thought you were going to say "write a program using it, hand it a huge document, and look for (:) constructors in the heap profile." :P
07:00:08 <Solonarv> although you can make mutation *quite* convenient by writing a bunch of helpful operators/functions
07:00:26 <rotaerk> c_wraith, I don't know if I explicitly agree with that, but I can't say I disagree either.  I will say that a side-effect of that is that the language becomes a harder sell to people stuck in the frame of mind that this syntactically-unwieldy way of doing things is the best way
07:00:28 <merijn> c_wraith: "Trick someone else into looking it up for me" is more "on brand" for me :p
07:01:13 <rotaerk> like if someone things programming is all about pointers, and you show them a language without special pointer syntax, they might just automatically consider it inferior
07:01:20 <xenon-> merijn, I tries, but I'm not quite sure what to make out of it. there's String here and there, but that is normal (even Data.Text.readFile takes a string as path)
07:01:22 <c_wraith> rotaerk: Haskell is a hard sell for a lot of reasons.  :)
07:01:26 <rotaerk> hehe
07:01:38 <rotaerk> tell me about it...
07:01:42 <merijn> We like pointers so much, we have like 5 different kinds!
07:01:45 <xenon-> tried*
07:01:54 <merijn> Ptr, ForeignPtr, StablePtr, Compact, Addr#...
07:02:13 <Solonarv> FunPtr...
07:02:18 <c_wraith> ForeignPtr feels different from the rest
07:02:18 <merijn> C programming suckers with their one type of pointer...
07:02:20 <merijn> Solonarv: Oh, right
07:02:35 <merijn> c_wraith: Just import it's internals and use MagicHash
07:02:39 <tdammers> I remember being super confused when learning Java, coming from C++ - I was used to pointers and references being explicit, and it took me a while to understand that in Java, almost everything is implicitly a reference, and so "." usually means "->"
07:02:40 <Solonarv> I mean, they're *all* different from each other
07:02:49 <Solonarv> that's why we have so many different ones
07:02:57 <merijn> c_wraith: Feels pointery enough for me! https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/Utils.hs
07:02:58 <[Leary]> I tried writing Haskell without pattern matching at some point, as a bit of an experiment. It's actually fine, you just start giving GHC lambda calculus.
07:03:06 <c_wraith> It's like string types in modern languages.
07:03:20 <c_wraith> There aren't 10 string types because the language made a mistake
07:03:31 <c_wraith> there are 10 string types because there are 10 different ideas of what a string should be
07:03:45 <tdammers> 10?
07:03:56 <c_wraith> I picked a number out of a hat.
07:04:02 <c_wraith> (it was the only number in the hat)
07:04:08 <tdammers> I can think of 5, or 9 if you squint a lot
07:04:08 <Rembane> I raise! 12!
07:04:29 <merijn> tdammers: "Ptr CChar" :p
07:04:35 <merijn> There you go, another one!
07:04:36 <tdammers> ooooh, yeah, uh
07:04:57 <tdammers> let's say ByteString doesn't count
07:05:33 <c_wraith> I also wasn't referring to only Haskell
07:05:45 <c_wraith> rust is often criticized for "too many string types"
07:06:00 <tabaqui> Erlang has the greatest strings ever
07:06:10 <c_wraith> But that's because they're all different things and you can't just conflate them in a language that cares about getting things right.
07:06:38 <c_wraith> tabaqui: you mean the part where you can pattern match on individual bits?
07:06:57 <veverak> string types?
07:07:04 <veverak> let's take an array (not list!)
07:07:12 <tabaqui> no, it's "string is just an array of bytes, where each byte looks like a char"
07:07:23 <veverak> there are more than 10 types of array you can want in C++ and it makes sense ;)
07:07:33 <tabaqui> but if it doesn't, hmm, I cannot tell is this a string or not
07:10:09 <aplainzetakind> Is it possible to have postfix unary data constructor operators? Like Foo = (:#) Int; 3:# :: Foo.
07:10:41 <merijn> Well, I sure hope not :)
07:10:58 <aplainzetakind> What would be the downside?
07:10:59 <xenon-> unit library does something like this to kind of fake it.   10 # cm
07:11:17 <xenon-> where # is a plain function taking a number and unit 
07:13:35 <aplainzetakind> > data Foo = (:#) Int
07:13:37 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
07:16:49 <aplainzetakind> Heh, it works with PostfixOperators.
07:17:31 <aplainzetakind> merijn: Why would it be bad though, because I'm about to use it.
07:18:00 <merijn> aplainzetakind: Hard to read and unexpected/uncommon
07:18:21 <Ariakenom> % :set -XPostfixOperators
07:18:21 <yahb> Ariakenom: 
07:18:29 <Ariakenom> % data Foo = (:#) Int
07:18:29 <yahb> Ariakenom: 
07:18:50 <Ariakenom> % :t 3:# :: Foo
07:18:51 <yahb> Ariakenom: ; <interactive>:1:5: error: parse error on input `::'
07:19:00 <xenon-> % 10 :#
07:19:00 <yahb> xenon-: ; <interactive>:228:6: error: parse error (possibly incorrect indentation or mismatched brackets)
07:19:06 <aplainzetakind> % :t (3 :#)
07:19:06 <yahb> aplainzetakind: Foo
07:19:20 <aplainzetakind> PostfixOperators work only with parentheses.
07:20:16 <Ariakenom> ah it's a relaxation of operator sections https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/basic-syntax-extensions
07:21:24 <Ariakenom> % (%%) x = x / 100
07:21:24 <yahb> Ariakenom: 
07:21:31 <Ariakenom> % (10 %%)
07:21:31 <yahb> Ariakenom: 0.1
07:27:17 <Ariakenom> % let x = -1 in (x `abs`)
07:27:17 <yahb> Ariakenom: 1
07:27:21 <Ariakenom> %kill
07:27:21 <yahb> Ariakenom: Done
07:27:23 <Ariakenom> % let x = -1 in (x `abs`)
07:27:29 <Ariakenom> % let x = -1 in (x `abs`)
07:27:29 <yahb> Ariakenom: 1
07:27:30 <yahb> Ariakenom: 1
07:28:03 <Ariakenom> % (%%) x = x / 100
07:28:03 <yahb> Ariakenom: 
07:28:06 <Ariakenom> % (10 %%)
07:28:06 <yahb> Ariakenom: 0.1
07:28:11 <Ariakenom> huh?
07:28:36 <Ariakenom> % data Foo = (:#) Int
07:28:36 <yahb> Ariakenom: 
07:28:44 <merijn> Ariakenom: What's wrong with that?
07:29:27 <Ariakenom> I suppose PostfixOperators is default. lambdabot is just old
07:30:00 <merijn> Or yahb just has more extensions on by default
07:32:37 <Ariakenom> fair point. tested and it's probably that yahb has more defaults
07:33:46 <aplainzetakind> How do I export my pattern synonyms from a module?
07:41:10 <aplainzetakind> OK I need to put them as `pattern Foo` in the exports list.
07:58:47 <xenon-> having a hard time escaping String. first tagsoup vs fasttagsoup, and now this.. all the combinators accept String. http://hackage.haskell.org/package/scalpel-0.5.1/docs/Text-HTML-Scalpel.html#v:match
07:59:11 <xenon-> all attribute predicates, even
08:08:55 <dmwit> xenon-: That complaint is a bit too vague to really elicit help.
08:09:17 <dmwit> So if you want help, you should be more specific about what escaping you're trying to do, and exactly how it isn't working right.
08:09:30 <dmwit> (The standard format is, "I tried X, expecting Y, but Z happened instead.".)
08:11:32 <merijn> xenon-: Have you looked into xml-conduit? I've had decent success with it for dealing with schema-less XML and that uses Text everywhere, afaik
08:11:42 <xenon-> dmwit, I did not expect help, just venting out. I'm trying to use Text instead of String, and I'm hitting obstacles everywhere. originally I used HXT, which only works with Strings. then I switched to TagSoup and Scalpel, only to find out that TagSoup uses String internally (so I would not be getting the full benefit of using Text). now that I'm using FastTagSoup over TagSoup, I find out that Scalpel has String-only functions
08:13:29 <xenon-> merijn, I haven't, and not sure I'm willing to figure out the api of third scrapping library at this point
08:13:38 <merijn> xenon-: Yeah, I understand :)
08:13:55 <merijn> I'm not too impressed with most of the XML libraries, tbh
08:15:32 <dminuoso> Im not too impressed with most of XML.
08:16:26 <merijn> Also true
08:27:07 <nvt> isn't this enough to run a function from cmd line? main = do (command:args) <- getArgs command 
08:27:20 <nvt> command being the name of the function to do something
08:27:37 <merijn> nvt: getArgs doesn't take arguments, though?
08:28:17 <xenon-> and you aren't ending do with an action
08:28:56 <Taneb> nvt: if you meant to have a newline between getArgs and command, bear in mind command is a string
08:28:59 <nvt> 'command' is on the next line after getArgs
08:29:06 <dminuoso> nvt: What do you mean by "command" exactly? Your explanation did not make sense to me.
08:29:21 <Taneb> Haskell won't convert that into executable code in any way
08:29:28 <Taneb> And there's not really a way to do that, either
08:29:44 <nvt> I would just like to run my haskell program like ./program insert and that would run function insert where I have somethng happening
08:29:59 <xenon-> there are libraries that can evaluate haskell expressions at runtime, but I'm not sure that is what nvt is after
08:30:10 <merijn> nvt: You need to somehow map that String to the corresponding function
08:30:50 <merijn> tbh, you should just use case-of or a Map to dispatch on the first argument String to the function you want
08:31:25 <nvt> is there any simple example code anywhere to take a look
08:31:29 <nvt> simplest possible
08:31:30 <xenon-> for simple programs I usually do something like this:  main = do args <- getArgs;  case args of ["insert"] -> insert insertArgument; _ -> putStrLn "usage ..."
08:32:40 <dminuoso> Or just use optparse-applicative.
08:33:09 <dminuoso> Ive come to appreciate it even for small programs.
08:33:28 <merijn> optparse-applicative is nice, but maybe not the most beginner friendly library for super simple things ;)
08:33:37 <xenon-> nicer library, but with just an argument or two, and no keyword options, I don't bother
08:33:40 <xenon-> nice*
08:34:16 <dminuoso> merijn: Mmmm. Perhaps I am not a beginner anymore then, it seems *so* simple and intuitive..
08:38:48 <Ariakenom> dminuoso: congratulations
08:40:08 <wroathe> I feel like some sort of party or certificate is in order
08:42:58 <merijn> wroathe: Why's that? :)
08:43:40 <Taneb> merijn: for dminuoso advancing from beginner!
08:43:52 <merijn> ah :p
08:44:29 <Ariakenom> You must now resist writing a tutorial on Monad :)
08:46:37 <tabaqui> But Monads are so simple. Just imagine a box...
08:47:03 <Ariakenom> ... with half circles in it ...
08:47:27 <wroathe> tabaqui: I actually think that's a reasonable analogy for ELI5 absolute beginners
08:47:33 <Solonarv> ...and fish swimming in it that eat each other
08:47:59 <Solonarv> wroathe: like most monad analogies, it breaks down in that it doesn't work for all monads, only some of them
08:48:00 <wroathe> tabaqui: As long as you don't go too far 
08:48:26 <wroathe> Solonarv: Yup, that's why I qualified that with ELI5 absolute beginners
08:49:03 <tabaqui> Dunno, I prefer to use something and hope that my intuition and imagination do the rest
08:49:04 <hackeryarn> I find it helpful to see how monads are used in another language, without people realizing they are using them. Then abstracted as hey here is why it's important that it's a monad.
08:49:29 <wroathe> Solonarv: Also, most things break down the further down the rabbit hole you go
08:49:47 <tabaqui> But usually I start explaining Monad from the "join" operator
08:50:01 <hackeryarn> wroathe it's ultimatesly all a function
08:50:23 <Ariakenom> I had all my students learn Monad by repeating the monad laws on the white board.
08:50:32 <Ariakenom> Luckily I have 0 students.
08:50:50 <Solonarv> hah! I had all my students learn Monad through interpretive dance.
08:50:57 <hackeryarn> Ariakenom: now I want to see Bart writing out the monad laws.
08:51:37 <Ariakenom> same, somebody write an email
08:52:11 <Solonarv> which formulation? fmap/pure/join?
08:52:26 <wroathe> Solonarv: Alternate between the two
08:52:37 <wroathe> I'm in full support of this
08:52:40 <Solonarv> two? there's like at least three
08:53:17 <wroathe> The two I know of are the return/bind and the fmap/pure/join ones
08:53:25 <Solonarv> fmap/pure/join, pure/>=> (there may be another operator, not sure), and the ungodly mess that is pure/bind
08:54:03 <wroathe> For the purposes of Simpsons whiteboarding I don't know that we need to be that exhaustive
08:54:26 <dminuoso> A monad is just the composition of two adjoint functors, whats the problem?
08:54:34 <Ariakenom> I vote some nice category theory diagram
08:55:17 <dminuoso> And if that doesn't help you can think of a monad as a single object category enriched over endofunctors.
08:56:11 <Solonarv> the pure/>=> form is very nice: pure >=> f = f = f >=> pure, f >=> (g >=> h) = (f >=> g) >=> h
08:57:48 <Solonarv> I actually like the "monoid in the category of endofunctors" definition now
08:58:24 <wroathe> Solonarv: Where does one acquire your level of mastery over all of this?
08:58:28 <dminuoso> Solonarv: But that is not verz clear.
08:58:38 <dminuoso> Solonarv: That could be Applicative too.
08:59:01 <dmj`> type level doubles, is it possible
08:59:04 <Solonarv> mine? uhhhh... hang out in #haskell for a while, read /r/haskell, read the occasional book or paper
08:59:16 <Solonarv> dmj`: yes, but you have to build them 'manually'
08:59:17 <dminuoso> Solonarv: So it should be "A monad is a monoid in the monoidal category of endofunctors equipped with endofunctor composition as its tensor"
08:59:23 <dmj`> Solonarv: so no then :)
08:59:41 <Solonarv> dminuoso: indeed
08:59:42 <dmj`> Solonarv: we got type level symbol append, we need type level Char, and type level double
08:59:56 <wroathe> Solonarv: Where'd you get your category theory understanding from?
09:00:15 <dmj`> Solonarv: I want to use type level doubles for deriving via instances
09:00:21 <Welkin> type-level double would be broken
09:00:25 <dminuoso> Solonarv: But indeed I much prefer the kleisli category perspective for Haskell. :)
09:00:34 <Solonarv> wroathe: mostly bartosz milewski's blog post series/book, and the occasional wikipedia article
09:00:42 <Welkin> you can't say if two doubles are equal
09:01:06 <unit73e> did anyone watch killing bites? the ending was the most retarded thing I've seen
09:01:09 <Ariakenom> dmj`
09:01:10 <Ariakenom> @quote edwardk type.level.ieee
09:01:10 <lambdabot> edwardk says: type level ieee floats are a crime against nature. i had to implement them in c++ for template meta programming once. never ever again
09:01:14 <unit73e> nvm wrong channel xD
09:01:24 <unit73e> but you might have!
09:01:40 <dminuoso> What possible reason might edward have had to implement them at the type level for template meta programming.. 
09:01:48 <dminuoso> At times I wonder whether ed gets paid to do crazy things.
09:01:56 <dmj`> We need type level doubles that use approximate equality
09:01:59 <dmj`> then
09:02:06 <Taneb> Why not type rationals?
09:02:09 <dmj`> Data.AEq or whatever
09:02:09 <dminuoso> dmj`: So you need a type checker plugin
09:02:16 <Taneb> dminuoso: I think he pretty much is, these days
09:02:26 <Solonarv> dminuoso: you do remember he got hired by MIRI right? :P
09:02:30 <dmj`> dminuoso: I need GHC to have type level doubles
09:02:48 <dminuoso> dmj`: Mind my asking... but why?
09:03:53 <dmj`> dminuoso: For cleaner Arbitrary instances with deriving via
09:03:56 <Solonarv> if you don't need the exact semantics of IEEE doubles, you can probably use dyadic fractions instead
09:04:07 <Welkin> dyads?
09:04:12 <Welkin> like tree nymphs?
09:04:24 <Welkin> or are those dryads
09:04:27 <Solonarv> n / 2^d <-- that's a dyadic fraction
09:04:33 <Solonarv> tree nymphs are dRyads
09:05:15 <dminuoso> Solonarv: I actually did not.
09:09:52 <Solonarv> They're even hiring more Haskellers
09:09:53 <dmj`> dminuoso: as long as you specified a threshold of equality I don't see a problem
09:15:30 <nvt> so if I do: let y = ((search 5) x) inside a function, how could I print "OK" if that search function returns ok?
09:16:23 <Solonarv> missing context, what does the rest of the function look like? what's the return type of 'search'?
09:16:48 * hackage ats-pkg 3.2.4.6 - A build tool for ATS  https://hackage.haskell.org/package/ats-pkg-3.2.4.6 (vmchale)
09:17:18 <nvt> Solonarv: it returns True or False, and that function does nothing else
09:17:50 <nvt> search2 = do let x = Node ... let y = ((serach 5) x) .. if else here ..
09:18:19 <wroathe> omg I just realized that ekmett does twitch streams
09:18:23 <Solonarv> you can just use if/then/else
09:18:32 <wroathe> time to realize just how little I know about the world
09:18:41 <Solonarv> 'if y then <print OK> else <do something else>'
09:19:13 <xenon-> where <do something else" needs to be of IO () type
09:21:25 <Taneb> wroathe: I enjoy Ed's streams, they're fairly follow-able although he tends to work in a way which makes me lose sight of the big picture
09:22:19 <Solonarv> last I checked his streams were only available in the highest resolution, which my poor internet can't handle :/
09:34:59 <dsal> Does anyone have any advice on introducing timeouts to conduit?  I'm reading from a network socket and should expect traffic at a particular period.  I'd like to tear down the whole thing if I don't get something.  Similarly, I may want to do something a bit further down the chain (e.g., not just bytes from the network, but particular types of parsed values should occur with some regularlity).
09:35:39 <dsal> I don't understand how 'timeout' could fit into such a chain, but I could imagine, adding a .| feedWatchdog sort of operation.
09:37:08 <infinisil> dsal: Should be pretty simple to write a conduit that remembers a time and stops with an error when a timeout has been reached
09:37:17 <infinisil> As in, manually writing one
09:37:51 <infinisil> Oh, I guess you'd need to stop it even if no item is coming anymore
09:39:37 <dsal> Right. I'm kind of surprised this isn't obviously available somewhere.  It seems unlikely anyone would want to stream data across a network without a timeout.
09:41:26 <c_wraith> dsal, typically one would apply a timeout right at the read, so that instead of having a conduit producing ByteString, you'd have one producing Maybe ByteString
09:42:44 <dsal> Sure, but the conduit network stuff doesn't seem to offer that.
09:43:31 <dsal> When I started using conduit, I got tls for nearly free, but lost my old timeout functionality.
09:44:07 <dsal> The timeout functionality was theoretical when I wrote it, but last night, my server went all wonky and the client didn't seem to notice.
09:44:37 <dsal> (kind of interested in why the server went wonky, but I didn't write that code)
09:49:45 <quicksilver> well people using stream-based protocols often like to pretend that network errors can't happen
09:49:51 <quicksilver> obviously it makes code easier to read about
09:50:06 <quicksilver> but since conduit is about having good ways to do things I'm also surprised..
09:50:38 <Guest28> I'm searching for a function  f :: (a -> IO a) -> a -> IO ()
09:50:50 <Guest28> Is there some other way than explicit recursion?
09:51:31 <mniip> Guest28, what would the function do
09:51:53 <Guest28> Like iterate, but monadic
09:52:06 <mniip> :t \f -> fix (f >=>)
09:52:08 <lambdabot> Monad m => (a -> m a) -> a -> m c
09:53:16 <Guest28> mnip: interesting, I wonder why this isn't a more common idiom with a proper name, like iterateM_
09:53:46 <Iceland_jack> You will find many a result for iterateM
09:54:06 <ski> @hoogle iterateM_
09:54:06 <lambdabot> Control.Monad.Loops iterateM_ :: Monad m => (a -> m a) -> a -> m b
09:54:35 <Solonarv> there it is!
09:54:40 <Guest28> oh!
09:54:49 <Solonarv> it even has exactly the name you expected
09:55:23 <Guest28> I searched the online instance which hasn't got that many libs.
09:57:46 <Solonarv> there's hoogle.haskell.org and haskell.org/hoogle; they don't have the same set of libs and features, for reasons I don't recall exactly
09:57:49 <Solonarv> there's also:
09:57:51 <Solonarv> @where hayoo
09:57:52 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
09:58:22 <Clint> hayoo's been unresponsive for like a week
09:59:04 <Solonarv> oh, right
09:59:06 <Solonarv> I'd forgotten
10:00:57 <suzu> anybody know the details on how servant integrates with wai/warp?
10:01:00 <gentauro> when defining custom `data types`. If I just derive `Show`, the output is one line all chunked up (which makes it difficult to read. Is there a `pretty-printer` that is able to infer the underlaying `tree structure`?
10:01:06 <suzu> i'm looking to write something to catch exceptions raised from handlers
10:01:27 <suzu> if i used the warp onException this works for uncaught exceptions from handlers
10:01:42 <suzu> but if i'm deliberately returning a ServantErr i'd like to know about that too
10:01:54 <Solonarv> gentauro: several, in fact
10:02:12 <Solonarv> there is 'pretty-show' which reformats the output of 'show'
10:02:22 <Solonarv> @hackage pretty-show
10:02:22 <lambdabot> http://hackage.haskell.org/package/pretty-show
10:02:37 <alp> suzu, https://github.com/haskell-servant/servant/issues/1111 seems relevant
10:03:05 <alp> (note that there's a #servant channel too, where you're more likely to get an answer and less to see your questions get lost in the middle of other conversations)
10:03:21 <alp> suzu, however, ServantErr is really not an exception
10:03:28 <alp> it's just the Left branch of an Either
10:03:34 <suzu> yeah, it isn't an exception
10:03:36 <alp> Handler ~ ExceptT ServantErr IO
10:03:45 <suzu> is there some way to sit 'outside' the handler and see if it was Left?
10:03:56 <suzu> and then just log that down and pass it upwards
10:04:08 <alp> suzu, you can use hoistServer maybe?
10:04:10 <suzu> preferably with the wai Request as well
10:04:11 <alp> from Handler to Handler
10:04:17 <suzu> that wont give me the request :(
10:04:18 <alp> but just run whatever code you want on the result of the handler
10:05:32 <suzu> do you know how i could get the request at that level?
10:05:39 <alp> nope
10:06:12 <suzu> hm
10:06:13 <suzu> okay
10:06:15 <alp> servant won't give you the request unless you're in a Raw endpoint, or you're sticking a middleware in front of your app or if you implement your own combinator (and an accompanying HasServer instance)
10:06:43 <alp> otherwise we can't give you clients/docs/etc, since the endpoint could be using anything in the request and we wouldn't know about it
10:06:49 <suzu> right
10:07:49 <alp> but I think you can "catch" ServantErr with a Handler-to-Handler hoistServer. you just won't have all of the request's data available, just the bits accessible to that particular handler
10:08:31 <suzu> i could be really gross and throw an exception from there and let my warp exc handler catch it
10:08:32 <suzu> lol
10:10:54 <suzu> i'll save this trick for last
10:11:00 <suzu> i'll look at implementing a combinator
10:12:39 <gentauro> Solonarv: `pretty-show` looks like a winner ;)
10:14:11 <gentauro> oh, but I need to implement the instance? :| (meh)
10:18:05 <Solonarv> gentauro: not if you use the functions under this section: https://hackage.haskell.org/package/pretty-show-1.9.5/docs/Text-Show-Pretty.html#g:2
10:25:42 <wroathe> The more and more Haskell I write the more I feel like it's guiding me towards less repitition more than any other language I've used. Some OOP languages almost feel like they encourage you to write and maintain boilerplate.
10:26:40 <wroathe> There's like a constant nagging feeling that I've written code in my project that is slightly similar to other code I already wrote, and so I can generalize and compose to get to a less repetitive implementation 
10:27:25 <shapr> wroathe: I agree, that came up in my weekly class Haskell today
10:28:15 <shapr> In Haskell I use partial application to do dictionary searches, I'm usually searching one key in a bunch of maps, or looking for a bunch of keys in one map.
10:28:31 <shapr> In Python I'd write two separate chunks of code, one specific to each use
10:30:01 <gentauro> `ppShow` Solonarv ?
10:30:10 <wroathe> I also get the feeling that if I return to this some time later I'll be extremely confused by the code that original me wrote. I find myself converting code to point-free style as I'm doing this refactoring
10:30:19 <Solonarv> gentauro: yes
10:30:25 <sicklorkin> shapr: ixset-typed ftw
10:30:25 <wroathe> Which makes perfect sense to me right now, but when I return to it I'll be like, "wtf man"
10:31:04 <Welkin> point-free is usually a bad idea
10:31:10 <Welkin> unless you really know what you're doing
10:31:21 <Welkin> or it is a very simple pipeline
10:31:35 <wroathe> These are mostly simple
10:31:37 <Welkin> if you can do it without using (.).(.) and `flip` you might be okay
10:31:41 <gentauro> Solonarv: :o, just what I needed !!!
10:31:44 <gentauro> thx
10:31:44 <wroathe> I wouldn't say I'm overusing it
10:31:48 * hackage modular-arithmetic 1.2.1.5 - A type for integers modulo some constant.  https://hackage.haskell.org/package/modular-arithmetic-1.2.1.5 (TikhonJelvis)
10:32:17 <wroathe> Yeah, this is just simple composition to avoid mentioning function params
10:32:25 <Solonarv> flip f x < (`f` x) IMO
10:54:53 <inkbottle> Is there good practice for choosing a name for a Maybe Int, Maybe [a]...?
10:55:17 * hackage pandoc-citeproc 0.16.0.1 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.16.0.1 (JohnMacFarlane)
10:55:34 <dsal> inkbottle: In general, I don't think the type of a variable should have that much to do with its name.
10:56:15 <inkbottle> OK
10:56:17 <amx> I sometimes prefix Maybes with an 'm', when it seems appropriate
10:56:25 <Solonarv> ^ same
10:56:31 <inkbottle> got it
10:59:34 <inkbottle> I'm googling a more general search: haskell ident good practices (I've noticed some people here always find identifiers that are simple and intuitive)
10:59:34 <Welkin> or Either with an `e`
10:59:44 <Welkin> or an Either Maybe with `em`
11:00:32 <dsal> I find it most useful to name my variables whatever it is they're supposed to represent, and not how they represent it.  The type does that.
11:01:10 <inkbottle> that's true
11:07:05 <zachk> I name mine maybeSomeNameHere at times 
11:08:20 <Welkin> of course, but when I get back an intermediate result from some computation that is a Maybe or Either, it makes sense to name it by consing an `m` or `e`
11:08:23 <Ariakenom> consecutively, I'm currently at variable11342
11:08:39 <Welkin> it's not the data itself, but an intermediate result that will not be used once I unwrap it
11:09:20 <zachk> I use long names at times with the types sometimes affecting the variable name for intermediate types
11:11:14 <wroathe> Say I've got ADTs with constructor overlap such that there seems to be a subtype/supertype relationship. Is there a way to create a new ADT by extending an old one?
11:11:21 <wroathe> In particular I'm working with defining Exception types
11:11:39 <wroathe> So they have a tendency to "wrap" one another
11:12:03 <zachk> i was thinking of something like that last night, i think you can pass in a functor into your adt and use identity functor for the base version of the adt
11:13:13 <dmwit> wroathe: You might be interested in the Trees that Grow paper.
11:13:27 <wroathe> I can do something like data MyException = InnerError InnerException | AdditionalError String
11:13:37 <wroathe> But that means that they need to unwrap InnerError and do a case analysis on that
11:14:28 <wroathe> It would be better to write something like MyException = InnerException + AdditionalError (pseudocode)
11:14:47 <wroathe> InnerExceptionCases I should say
11:15:01 <Solonarv> the "complete overkill" answer is to use something like 'variant'
11:15:53 <dmwit> zachk: https://www.benjamin.pizza/posts/2017-12-15-functor-functors.html
11:16:25 <wroathe> dmwit: is that a paper of some sort or you being sarcastic :P?
11:16:41 <gobby> A haskell module is complaining that it doesn't export a function that I am explicitly exporting
11:17:02 <wroathe> OH LOL
11:17:14 <wroathe> I thought you were saying "trees that grow paper" as a logical impossibility
11:18:10 <dmwit> wroathe: Good news! The answer to your question is "yes" no matter whether you meant inclusive or or exclusive or!
11:19:00 <dmwit> gobby: Perhaps the function is a constructor, and you believe you are exporting the data constructor but are in fact exporting the type constructor.
11:19:17 <dmwit> gobby: If not, you know the drill. Post some minimal code together with the exact error to a pastebin and send us a link.
11:19:56 <dmwit> wroathe: https://pdfs.semanticscholar.org/59c1/8f377a566d2949dd5f44ad658c5ad3f6db67.pdf
11:21:07 <wroathe> Yeah, I found it. Thanks for the recommendation.
11:23:45 <gobby> dmwit: cheers I'll just move the function
11:26:17 <zachk> b
11:26:20 <zachk> oops
11:59:55 <day> im trying to parse an xml dom tree. i managed to work with json via the aeson library. but im not getting anywhere with xml. should i use HXT or xml-conduit or... the thing i don't understand why similar tasks appear to be totally different
12:01:58 <[exa]> xml has a gazillion of standardized side features that the parsers need to somehow implement
12:02:13 <[exa]> downside of having a standard.
12:02:24 <Rembane> And having a huge one at that.
12:03:14 <day> i see. i knew it was a bit more complex, but didnt expect it would make things that much more complex on the haskell side
12:03:47 <[exa]> day: btw there is this thing: http://hackage.haskell.org/package/really-simple-xml-parser
12:03:49 <day> each IO library feels like i have to relearn a programming concept
12:04:15 <byorgey> day: the 'xml' package is probably the easiest to get started with.
12:04:27 <byorgey> day: don't use HXT.
12:04:29 <day> Text.xml?
12:04:47 <byorgey> day: http://hackage.haskell.org/package/xml
12:05:24 <Rembane> I'm fond of Xeno: https://github.com/ocramz/xeno
12:05:47 <day> im like, the one with the best example code wins
12:07:13 <byorgey> that is a very reasonable criterion.
13:17:59 <c_wraith> Unless it leads you to pick hxt
13:18:33 <c_wraith> the thing about xml is that it's so simple that it can't do anything the api doesn't make obvious.
13:19:00 <c_wraith> so it doesn't need examples. hxt can do anything but it's all super complicated. everything needs examples.
13:48:35 <dsal> I used xeno once and it worked out pretty well.
13:48:53 <dsal> (except for the part where the service I wrote all the bits for shut down right after I made really awesome working code)
14:04:48 <yayforj> where can i find documentation for cabal.project file?
14:05:58 <MarcelineVQ> could anyone tell me in which package to find something that returns my current local-network ip? like 192.168.0.1
14:08:20 <MarcelineVQ> not really sure what tags to search for
14:08:20 <Solonarv> yayforj: https://cabal.readthedocs.io, check the "nix-style local builds" chapter
14:08:31 <Solonarv> MarcelineVQ: sounds like something that would be in 'network'?
14:08:44 <__monty__> Not afaics.
14:08:56 <__monty__> Also not in `ip`.
14:08:59 <MarcelineVQ> Solonarv: if it is it's not obvioius to me, looking at ip tag atm
14:09:29 <MarcelineVQ> can just ifconfig | grep inet and take it from there but I'd prefer not to :>
14:13:14 <MarcelineVQ> network-info looks like it'll get me on the way
14:19:48 <yayforj> Solonarv: thank you
14:26:13 <jcob> Hey i'm having this bizzare problem where every time i try to use ghc to compile anything at all, i get a bunch of link errors
14:26:29 <jcob> (This is with a locally installed version of stack)
14:26:48 <jcob> anyone ever experience that b4?
14:26:54 <KaneTW> i'm currently struggling with some weird behaviour that's driving me nuts
14:26:55 <KaneTW> so
14:27:13 <KaneTW> a library i'm using allocates some C memory and tosses it into a ForeignPtr with a finalizer
14:27:30 <KaneTW> then a specific function puts that ForeignPtr into a StablePtr so that it doesn't get GC'd
14:27:42 <KaneTW> yet for some reason the finalizer is still called
14:27:42 <boj> jcob: double check that you listed all of your code modules in your cabal file
14:27:47 <MarcelineVQ> jcob: Almost certainly, but it'll depend on the sepcific errors
14:27:57 <KaneTW> i'm fairly sure the StablePtr is never freed.
14:30:11 <MarcelineVQ> general statement: network-info was very painless, can recommend
14:30:41 <z0> i was wondering, since learning haskell has introduced me to category theory; is there a name for having absorbing elements, like numbers under multiplication have 0, that makes it something more than a monoid?
14:32:04 <dsal> MarcelineVQ: Hmm...  There's rarely one local network IP these days.  Curious what you're doing with it.
14:33:11 <MarcelineVQ> dsal: I'm being lazy. I have a fileserver for local computers and Instead of affixing the server computer's ip I'm just displaying the dynamic ip when the fileserver starts so I know what to connect to
14:33:37 <MarcelineVQ> z0: it's really likely that's a thing. where 1 is an identity I'd almost want to call 0 a terminal but I really doubt that's the word for it
14:34:01 <MarcelineVQ> z0: if you don't get an answer here it might be a good question for #math
14:36:46 <sclv> jcob: using arch?
14:39:27 <Solonarv> z0: some wikipedia diving turns up "Null semigroup"
14:39:43 <Solonarv> oh wait no, I spoke too soon.
14:40:04 <__monty__> MarcelineVQ: Why not avahi?
14:40:33 <jcob> sclv: yes
14:40:56 <MarcelineVQ> I don't want a broad solution, I just wanted to write something I could use to read pdf's on my wii-u
14:41:04 <jcob> haskell on arch is driving me up a wall tbqh
14:41:40 <jcob> its obvious arch's brand of source-based package management doesnt work well for hask
14:41:44 <boj> jcob: that tends to be a common theme. some people in here know how to make it work, but you have to fight for it
14:42:44 <MarcelineVQ> I wonder if there's an inverse monoid, where instead of identity `op` m = m you get identity `op` m = identity in which case the above would be a monoid with identity 1 + an inverse monoid with identity 0
14:44:12 <MarcelineVQ> All the people who can point out why this is silly are stuck in traffic right now :>
14:44:15 <__monty__> jcob: I'm happily using nix for haskell development on arch. If you don't want nix I *think* there's a ghc-static or is it -dynamic in the AUR? Otherwise you could just download the haskell platform, platform.haskell.org. Whatever you do, don't install *any* haskell program with pacman.
14:44:27 <jcob> oh great i just started mkpkging nix :D
14:44:44 <MarcelineVQ> before we start reccomending solutions it'd be best to get the actual errors jcob is having
14:45:07 <__monty__> jcob: mkpkg? Don't manage nix with pacman, that's a bad idea too.
14:45:17 <boj> i dunno MarcelineVQ, arch seems to be the error :D
14:45:18 <jcob> dammit
14:45:28 <jcob>  tbh this is the needle that broke the camels back, im ready to ditch my stack installation
14:45:42 <__monty__> MarcelineVQ: Nah, let's blindly assume it's something that happened to us sometime. We'll all be happier that way.
14:46:18 <Solonarv> My wikipedia dive didn't turn up any shorter name for "monoid with an absorbing element"
14:46:20 <__monty__> jcob: Yeah, I don't use stack anymore. Happy with nix + cabal new/v2-*.
14:46:40 <boj> i can second nix + cabal new/v2
14:46:59 <dibblego> me2
14:47:33 <Solonarv> MarcelineVQ: so this "inverse monoid" is just "magma with an absorbing element" (upgrade "magma" to "semigroup" if you add associativity)
14:48:15 <MarcelineVQ> Oh I see I didn't realize absorbing element was already a technical term
14:49:58 <z0> Solonarv: this becomes interesting when thinking about binary operations involving binary types
14:50:13 * boj looks up the association between geology and math
14:50:49 <boj> magma, or groupoid
14:50:51 <MarcelineVQ> boj: you'll find that magma never becomes lava because math doesn't leave the mountain
14:51:11 <boj> :o
14:51:59 <boj> Solonarv: so a magma is a semigroup without associativity?
14:52:07 <Solonarv> exactly
14:52:23 * boj writes up a magma superclass proposal
14:52:37 <phadej> please don't :)
14:52:42 <boj> haha
14:52:47 <Solonarv> well that'd be a lawless class so it's rather pointless
14:52:57 <c_wraith> it's a useless class. it contains no information beyond the type.
14:53:12 <nshepperd> the lawless frontier of algebra
14:53:12 <Solonarv> if you have a type A, *literally* any function 'A -> A -> A' defines a magma
14:53:30 <zachk> i thought magmas had the commutative property?
14:53:33 <c_wraith> nope.
14:53:44 <c_wraith> no useful properties!
14:54:12 <Solonarv> well, the set is closed under the operation, but that's usually given by the operation's type anyway
14:54:28 <z0> since when is Hask an instance of Useful? jk
14:55:16 <shachaf> Perhaps undefined and const undefined aren't valid instances.
14:55:21 <c_wraith> z0, it lacks an instance because there are too many distinct potential implementations
14:55:32 <Solonarv> % class Useful (a :: k)
14:55:32 <yahb> Solonarv: 
14:55:39 <Solonarv> % import Control.Category
14:55:39 <yahb> Solonarv: 
14:55:47 <boj> i have an embarrassingly non-existent math background, so learning these things is fun
14:55:47 <c_wraith> main = beUseful
14:56:10 <Solonarv> % instance Useful Hask
14:56:10 <yahb> Solonarv: ; <interactive>:9:17: error: Not in scope: type constructor or class `Hask'
14:56:13 <Solonarv> gah!
14:56:29 <MarcelineVQ> now you've done it
14:56:54 <Solonarv> % instance Useful Hask
14:56:54 <yahb> Solonarv: 
14:56:58 <Solonarv> hah!
14:57:13 <boj> so the moral here is that coming up with Useful Hask takes some effort :p
14:57:54 <z0> well, give me a typeclass type system so that I can compose classes and have Monoid be an instance of Associative.HasIdElement.Commutable
14:58:32 <phadej> monoid doesn't need to be commutative
14:58:53 <jackdk> AbelianMonoid
14:59:02 <phadej> also Int is associative using (+), but has 0 as id element of (*)
14:59:11 <phadej> so there are coherence conditions to make Monoid
14:59:27 <jackdk> isn't that Ring stuff?
14:59:31 <phadej> Monoid is more then Default + Semigroup
15:00:17 <z0> phadej: you are right and we just proved my point
15:00:28 <jackdk> often when I see uses of Default, I think "did you want Monoid?" because there's usually some operation that their default is neutral with respect to
15:00:47 <jackdk> (see also, the "null object" pattern from OO, which is usually very close to a mempty)
15:00:56 <Solonarv> jackdk: a ring is just two monoids on (nearly) the same underlying set that interact nicely
15:01:11 <phadej> in which other is abelian!
15:01:18 <Solonarv> but there are other ways to have multiple monoids on the same set
15:01:26 <phadej> like lattice!
15:01:42 <Solonarv> indeed!
15:02:00 <phadej> (which are idempotent monoids + stuff)
15:02:09 <phadej> jackdk: null object is Nothing + Just a
15:02:09 <z0> the typesystem itself coukd 
15:02:15 <z0> sorry
15:04:43 <wroathe> So say I've got a new tree datatype like data MyTree = Config Value (H.HashMap String MyTree), and I want to implement mkdirp-like functionality where I create new nodes in this tree given some string path. I've got an implementation in place that works, but this seems like this datatype should fit neatly into some of the typeclasses we've got in base, and let me implement that functionality using far 
15:04:43 <jcob> LOL im so glad yall said "fudge archlinux just use nix" already have hie installed in no time :DD
15:04:49 <wroathe> less code. Is there something like an inverse of fold that takes a value and "unfolds" it into the tree?
15:05:05 <wroathe> Whoops, I misspelled the constructor in that, should be data MyTree = MyTree ...
15:06:15 <Solonarv> wroathe: yes, and it's called unfold :P
15:06:25 <Solonarv> or, if you're using recursion-schemes: ana
15:06:45 <Solonarv> (the full name is "anamorphism")
15:06:49 <wroathe> Solonarv: That's not part of base though, is it?
15:06:53 <Solonarv> no
15:07:08 <Solonarv> there's an 'unfoldr' in base but it's just for []
15:08:03 <Solonarv> you can write your own 'unfoldMyTree' if you don't want to use recursion-schemes
15:08:04 <wroathe> So loosely speaking anamorphism captures the concept of generating part of a data structure from an initial value?
15:08:07 <c_wraith> am I the only one who always misread hylomorphism as hyrulemorphism?
15:08:11 <Solonarv> exactly
15:08:23 <wroathe> Gracias
15:08:57 <rockman37> c_wraith: lol
15:09:44 <Solonarv> the type should be: unfoldMyTree :: (a -> (Value, H.HashMap String a)) -> a -> MyTree
15:10:56 <wroathe> I've always wondered if there was a better way of naming operations like this when I've done it in other imperative languages :P
15:11:03 <wroathe> Or even talking about the behavior of it
15:12:01 <Trollinator> is it possible to write a Lens' for a list that will reverse the list? 
15:13:01 <iqubic> What's the point of the Singletons library?
15:13:09 <wroathe> Solonarv: Given that we've got a Foldable typeclass in base, is there a reason why we also don't have an Unfoldable?
15:13:18 <c_wraith> Trollinator, there's an Iso for that
15:13:35 <Trollinator> what's an Iso? Can I compose it with a Lens?
15:13:38 <Solonarv> iqubic: pretending that we have dependent types, basically
15:13:57 <iqubic> Really
15:14:09 <Trollinator> I've only used very basic lenses so far for record field access
15:14:16 <Solonarv> Trollinator: it's an isomorphism, which means "two-way conversion". yes, if you're using the lens library.
15:14:31 <Solonarv> wroathe: less demand for it, I guess?
15:14:32 <c_wraith> https://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-Iso.html#t:Reversing
15:14:43 <iqubic> I thought it was for writting functions where the type of the argument was only know at runtime.
15:15:01 <Trollinator> Ok cool
15:15:10 <Solonarv> well, it's related to that too
15:15:28 <Solonarv> because that's also something dependent types allow
15:15:47 <c_wraith> > over reversing tail [1..10]
15:15:47 <iqubic> It is? How so?
15:15:49 <lambdabot>  error:
15:15:49 <lambdabot>      • No instance for (Reversing ([Integer] -> Identity [Integer]))
15:15:49 <lambdabot>          arising from a use of ‘e_1110’
15:16:00 <Solonarv> the optic you want is 'reversed'
15:16:08 <c_wraith> ah, OK.
15:16:14 <iqubic> > over reversed tail [1..10]
15:16:16 <lambdabot>  [1,2,3,4,5,6,7,8,9]
15:16:22 <Solonarv> 'reversing' is the polymorphic version of 'reverse'
15:16:32 <iqubic> Huh? How does that work?
15:16:53 <c_wraith> with a class.
15:17:02 <Solonarv> % :t reversed
15:17:02 <yahb> Solonarv: (Reversing a, Profunctor p, Functor f) => p a (f a) -> p a (f a)
15:17:14 <Solonarv> (check c_wraith's link)
15:19:18 * hackage jmacro 0.6.16 - QuasiQuotation library for programmatic generation of Javascript code.  https://hackage.haskell.org/package/jmacro-0.6.16 (GershomBazerman)
15:19:39 <iqubic> How can you get a function that works with values only known at runtime?
15:20:19 <johnw_> doesn't that describe most functions?
15:20:40 <johnw_> "+" doesn't know what the values will be
15:21:57 <iqubic> But what about if the type of the input is only known at runtime?
15:22:10 <johnw_> you could use Dynamic
15:22:20 <c_wraith> perhaps it was about functions that work on values whose type isn't known concretely at compile time. like when doing polymorphic recursion or singleton stuff.
15:22:42 <iqubic> I thought this is what Singletons were for. Am I wrong?
15:23:01 <c_wraith> singletons handle some of that space, in a rather awkward way.
15:23:26 <johnw_> A singleton is a type with a only one value, which lets you use "values" at the type level
15:23:48 <iqubic> It does?
15:24:08 <c_wraith> in a particularly awkward way!
15:24:20 <johnw_> sure, a singleton nat is resolved to one type, with one value, so it's natural that you could "reflect" the value from the resolved type
15:24:53 <johnw_> so when you say Sing n, you're relying on `n` being unified with something meaningful to your type-level function
15:25:21 <iqubic> Right. But is there a better way of doing this sort of thing?
15:25:30 <johnw_> this all of this is pure hackery to work around the lack of dependent types
15:25:54 <johnw_> in a language like Agda, what you would do with singeltons in Haskell is so completley natural that it's hard to think of it as something special
15:26:54 <iqubic> I wish we had official support for Dependent types in Haskell.
15:27:47 <c_wraith> iqubic, if you have a bunch of time and a bit of disposable income, I'd recommend The Little Typer as an approachable intro to dependent typing in a mostly language-independent way. (it uses a racket dialect that has mandatory dependent typing of all terms)
15:28:12 <Solonarv> iqubic: it's being worked on!
15:29:52 <iqubic> c_wraith: That's a little bit more expensive than I would like.
15:30:09 <iqubic> But thanks for the recommendation.
15:30:29 <c_wraith> no worries. it's why I made it a conditional recommendation.
15:33:18 * hackage sexpr-parser 0.1.1.1 - Simple s-expression parser  https://hackage.haskell.org/package/sexpr-parser-0.1.1.1 (rcook)
15:33:23 <iqubic> I have the time, but not the money.
15:34:59 <zachk> why does exiting a gloss function in ghci kill ghci? 
15:36:09 <iqubic> Because it's an issue that is known and has no fixes.
15:36:27 <iqubic> In other words IDK.
15:36:48 <wroathe> Solonarv: Doesn't that type signature you wrote need to wrap a Maybe around the return value for the function argument?
15:37:26 <Solonarv> wroathe: no; to terminate the unfolding, return an empty HashMap
15:38:32 <Solonarv> data MyTreeF r = MyTreeF Value (HashMap String r) -- you could use this instead of a tuple
15:38:54 <Solonarv> this is the "base functor" or "pattern functor" for your MyTree type
15:38:56 <iqubic> how does unfolding work?
15:39:07 <iqubic> :t unfold
15:39:08 <lambdabot> error:
15:39:08 <lambdabot>     • Variable not in scope: unfold
15:39:09 <lambdabot>     • Perhaps you meant one of these:
15:39:20 <iqubic> :t unfoldr
15:39:21 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
15:39:23 <johnw_> it generates a value from a seed until a final condition is reached
15:39:36 <iqubic> I see.
15:39:36 <johnw_> or set of values, in this case
15:39:46 <johnw_> in Haskell, could be infinite
15:39:55 <wroathe> Solonarv: Oh, now that I think about it, that makes way more sense
15:40:02 <wroathe> Solonarv: Thanks yet again
15:40:43 <iqubic> So it's like a stateful computation being iterated until it reaches the end, with the results being aggregated in a list?
15:40:59 <wroathe> iqubic: In my case a tree
15:41:02 <c_wraith> in a Foo, in general.
15:41:06 <iqubic> I see.
15:41:13 <c_wraith> unfoldr just happens to be specific to lists
15:41:22 <aplainzetakind> Can I mix synonym patterns and bona fide patterns in a pattern match and go through without completeness complaints? Something like `pattern First x <- (x, _); case foo of First 1 -> bar; (a, b) -> baz b`.
15:41:55 <c_wraith> aplainzetakind, if there is a COMPLETE pragma listing the set of things you check, sure.
15:42:02 <wroathe> I'm going to walk around spouting that "mkdir -p is just an anamorphism on filesystems" like I know what I'm talking about
15:42:20 <iqubic> wroathe: How does that work?
15:42:31 <c_wraith> it's... true-ish
15:42:44 <wroathe> how does mkdir -p work? "man mkdir"
15:43:09 <iqubic> No... Why is "mkdir -p" an anamorphism?
15:43:17 <wroathe> Ha, you got me there
15:43:25 <wroathe> That's the "like I know what I'm talking about" part of my sentence
15:43:52 <wroathe> My plan is to leave the room before someone can ask me that question
15:44:00 <Solonarv> too late!
15:44:13 <iqubic> wroathe: I see. Well, I asked you the question before you left.
15:44:15 <wroathe> Fool me once
15:44:42 <c_wraith> if you imagine a filesystem is just a tree, it converts a seed to a tree.
15:44:55 <c_wraith> it's not a very good analogy.
15:45:48 <c_wraith> it's more like a catamorphism over file path segments which generates a compound IO action to modify the filesystem. :P
15:45:59 <iqubic> Yes. Yes it is.
15:46:08 <wroathe> c_wraith: nerd
15:46:28 <c_wraith> well, I hang out here...
15:46:33 <wroathe> :)
15:46:57 <aplainzetakind> c_wraith: What would a COMPLETE list that works for the example above look like?
15:47:40 <aplainzetakind> (Suppose I also have a `pattern Second y <- (_, y)`.
15:47:42 <aplainzetakind> )
15:48:02 <c_wraith> aplainzetakind, I've never written one. I'd have to check the docs or find a library using them.
15:48:28 <aplainzetakind> Ah, OK.
15:49:00 <c_wraith> wroathe, there is often a sort of dual interpretation of a function as either cata or ana available.
15:49:16 <c_wraith> wroathe, consider take, for instance.
15:50:35 <c_wraith> you can look at it as an unfold where the state is the combination of list not produced yet and the number remaining to produce.
15:51:10 <c_wraith> or a fold producing a function that provides n elements of the list.
15:51:40 <slack1256> Even when dealing with just physical cores, is it worth it to run the parallel GC with less than max cores?
15:51:44 <wroathe> Oh, I see
15:52:00 <Solonarv> aplainzetakind: your 'First' pattern is already complete by itself, actually
15:52:17 <wroathe> c_wraith: I'll be on the lookout for more places where I can recognize that pattern. Thanks!
15:55:26 <aplainzetakind> Solonarv: True. My simplified example was ill conceived.
15:55:52 <Younder> I do recommend * Asymptotic Analysis and Perturbation Theory' by William Paulsen
15:56:33 <Solonarv> {-# COMPLETE Pat1, Pat2, Pat3 #-} is the syntax for complete pragmas IIRC
15:57:16 <c_wraith> Solonarv, with a pragma for each covering set?
15:57:20 <Younder> Remember that O notation.. now let's take it school..
15:57:21 <aplainzetakind> pattern First <- (x, True); pattern Second y <- (True, y); pattern Fff <- (False, False)
15:57:29 <Solonarv> c_wraith: that's my understanding, yes
15:57:33 <aplainzetakind> There are complete among themselves now.
15:58:01 <aplainzetakind> But I can pick just one and match the rest of the cases with a non-synonym pair.
15:58:23 <aplainzetakind> Can ghc reason about such a thing and decide it's fine?
15:58:31 <aplainzetakind> s/There/These/
15:59:07 <Solonarv> maybe?
16:00:24 <Solonarv> I don't know if you can include "regular" constructors in a {-# COMPLETE #-} pragme.
16:01:05 <Younder> You might just be a bit over the top with -- he is just a man.
16:01:45 <aplainzetakind> Can I have more than one COMPLETE pragma?
16:02:44 <aplainzetakind> Because a lot of the subsets of mixed patterns can be complete.
16:02:54 <Solonarv> yes, you can have as many as you want.
16:03:18 <aplainzetakind> Ah. And I can put them anywhere in the code?
16:03:36 <aplainzetakind> Not necessarily in the same module where I define the synonyms?
16:03:50 <Younder> simon petre jones
16:04:14 <Solonarv> example: https://hackage.haskell.org/package/containers-0.6.0.1/docs/src/Data.Sequence.Internal.html#line-288
16:04:31 <Solonarv> I'm not sure if they have to be in the same module, check the GHC user's guide
16:05:21 <aplainzetakind> OK. Thanks.
16:14:26 <wroathe> So Solonarv, I think I've got the implementation correct, but is the type of my unfold function too general? https://gist.github.com/JustinChristensen/4437923c1bb1d1884df58d3f07bc4660
16:14:43 <wroathe> Solonarv: The only valid a would be Config in this case, right?
16:15:17 <Solonarv> no! this is almost exactly right
16:15:31 <wroathe> ignore that H.empty
16:15:33 <wroathe> Just fixed that
16:15:38 <Solonarv> you don't actually need the guards, yeah
16:16:03 <Solonarv> if you remove those it's exactly right
16:16:30 <wroathe> OH
16:16:30 <wroathe> DUH
16:16:35 <wroathe> mapping over an empty map lol
16:17:40 <wroathe> So basically this: unfoldConfig f x = let (v, m) = f x in Config v (unfoldConfig f <$> m)
16:19:30 <Solonarv> yup
16:27:37 <wroathe> Hrm, where this gets interesting is that in order to implement mkdir -p like functionality I need the seed value then to be the previous state of the tree, but I also need the path I'm following
16:28:14 <wroathe> So would you typically model that as "a" being a tuple with unfolds?
16:30:48 * hackage asif 3.3.4 -   https://hackage.haskell.org/package/asif-3.3.4 (arbornetworks)
17:27:18 * hackage network 3.0.1.0 - Low-level networking interface  https://hackage.haskell.org/package/network-3.0.1.0 (dukerutledge)
17:47:26 <inkbottle> `do {let a = b; ...}` equ? `do {a <- return b; ...}`; or are there cases when it is not true.
17:48:31 <geekosaur> I think it would be a non-law-abiding Monad (and Applicative)
17:49:14 <Solonarv> they can behave differently if 1) >>= is strict, or 2) 'a' is a partial pattern match
17:50:05 <Solonarv> % do { let True = False; putStrLn "fine" }
17:50:05 <yahb> Solonarv: ; <interactive>:14:40: error: parse error on input `}'
17:50:26 <Solonarv> % do { let { True = False }; putStrLn "fine" }
17:50:27 <yahb> Solonarv: fine
17:50:43 <Solonarv> % do { True <- return False; putStrLn "fine" }
17:50:43 <yahb> Solonarv: *** Exception: user error (Pattern match failure in do expression at <interactive>:16:6-9)
17:52:38 <inkbottle> reading you...
17:54:37 <Solonarv> % do { a <- return (error "boom"); return 42 } :: Strict Int
17:54:37 <yahb> Solonarv: *** Exception: boom; CallStack (from HasCallStack):; error, called at <interactive>:22:19 in interactive:Ghci17
17:54:59 <Solonarv> % do { let { a = error "boom" }; return 42 } :: Strict Int
17:54:59 <yahb> Solonarv: Strict 42
17:56:01 <Solonarv> (excuse the delay; I had to define Strict first)
17:56:06 <Solonarv> % :i Strict
17:56:06 <yahb> Solonarv: data Strict a = Strict !a -- Defined at <interactive>:18:1; instance [safe] Monad Strict -- Defined at <interactive>:20:10; instance [safe] Applicative Strict -- Defined at <interactive>:19:10; instance [safe] Show a => Show (Strict a) -- Defined at <interactive>:18:46; instance [safe] Functor Strict -- Defined at <interactive>:18:37
17:57:01 <Solonarv> inkbottle: make sense?
17:57:13 <inkbottle> yes, it does
17:57:32 <inkbottle> I was hoogling Strict
17:58:46 <Solonarv> I'm sure it exists somewhere, but I don't know where.
17:59:32 <Solonarv> Of course it's also possible for other monads to be strict! I just used the simplest one.
18:04:40 <inkbottle> % do { let { a = error "boom" }; return 42 } :: Identity Int
18:04:41 <yahb> inkbottle: Identity 42
18:05:14 <Solonarv> that's never going to error, no matter which monad you use
18:05:26 <inkbottle> indeed
18:08:12 <Solonarv> % do { a <- return (error "boom); return 42 } :: Identity Int
18:08:12 <yahb> Solonarv: ; <interactive>:27:60: error: lexical error in string/character literal at end of input
18:08:26 <Solonarv> % do { a <- return (error "boom"); return 42 } :: Identity Int
18:08:26 <yahb> Solonarv: Identity 42
18:08:56 <inkbottle> Hum
18:09:02 <inkbottle> hum hum
18:10:55 <inkbottle> So I'm quite safe in replacing let by a<- return; a not too bad approximation
18:11:03 <inkbottle> for many cases
18:12:10 <inkbottle> % (\x -> 3::Int) undefined
18:12:11 <yahb> inkbottle: 3
18:12:28 <inkbottle> as expected
18:14:57 <Solonarv> inkbottle: for mental desugaring, you should translate 'do { let a = expr; stmts }' to' let { a = expr } in do { stmts }'
18:21:43 <inkbottle> yes, that `let` w/o `in` seems very strange.
18:24:59 <Solonarv> I mean the alternative is ...really weird looking
18:27:39 <inkbottle> the more so with the indentation
18:29:35 <Solonarv> https://gist.github.com/Solonarv/4983f287b24570e0f58e6426a160629e
18:30:18 <Solonarv> this is not legal syntax - it confuses the parser, because the 'let' starts a let-statement - but it would be legal if let-statements didn't exist, I think
18:31:33 <Solonarv> note that the indentation is actually not crazy
18:31:56 <Solonarv> you basically just have to insert 'in do' after every 'let'
18:38:22 <aplainzetakind> I sometimes see >>> prefixed properties in comments, which test library works with those?
18:38:34 <Welkin> doctest?
18:38:43 <Welkin> oh
18:38:51 <Welkin> that could be repl input examples
18:39:03 <Welkin> or doctest if I remember right
18:39:20 <Welkin> https://hackage.haskell.org/package/doctest
18:39:54 <Welkin> in fact, it's both
18:40:48 <aplainzetakind> OK, I didn't remember where I last saw such a thing, so couldn't check.
18:41:48 <aplainzetakind> I thought it could also test properties, but I guess I'll have to go to quickcheck for that.
18:42:03 <Welkin> and smallcheck
18:42:19 <Welkin> and golden tests
18:42:26 <Welkin> and the rest of the testing zoo
18:42:52 <Welkin> there are too many
18:43:37 <aplainzetakind> Which would you recommend for a smallish project and an inexperienced author?
18:44:51 <Welkin> no idea
18:44:55 <Welkin> I don't use any of them
18:45:07 <Welkin> the basics are quickcheck and hspec/hunit
18:45:11 <Welkin> but unit tests are not very useful
18:45:18 <Welkin> just stick with quickcheck
18:45:39 <aplainzetakind> OK.
18:46:03 <Welkin> all the different types of tests have slightly different use cases
18:46:14 <Welkin> golden tests are apparently only for testing IO actions
18:49:19 <aplainzetakind> Is it sloppy to use QuickCheck's Gen, generate, elements etc. to generate random things in an actual program?
18:50:14 <Solonarv> yes
18:50:18 <Welkin> you can use the Random instance of a type for that
18:50:26 <iqubic> very much so.
18:50:30 <Welkin> with a generator
18:53:46 <lyxia> How is that sloppier than using Gen
18:54:03 <Welkin> it's not
18:54:14 <iqubic> It's less sloppy.
18:54:19 <Welkin> yes
18:54:32 <iqubic> Never use a test suit in the final code.
18:54:34 <lyxia> how is that less sloppy than using Gen
18:54:34 <Welkin> it's a little piggy
18:54:39 <Welkin> instead of a big piggy
18:54:39 <maerwald> quickcheck is probably the most abused thing in haskell :P
18:54:50 <iqubic> why do you say that?
18:55:02 <Welkin> haha
18:55:17 <lyxia> Gen is a perfectly suitable monad for random generation
18:55:22 <maerwald> I wouldn't be surprised if someone uses quickcheck to generate their program
18:55:27 <Welkin> that reminds me of Casey Muratori wearing a pig hat when he does some sloppy hacking in his sourcecode on stream
18:55:38 <iqubic> maerwald: Why do you say that quickcheck is the most abused thing in Haskell?
18:55:53 <maerwald> iqubic: oh well, it's often misused for unit tests
18:56:08 <iqubic> Is it supposed to be used for Unit Tests?
18:56:12 <Welkin> no
18:56:16 <Welkin> it is property tests
18:56:21 <iqubic> Yeah that.
18:56:32 <maerwald> Yep and if you cannot define a clear property, then you shouldn't use it just for the sake of having more input
18:57:01 <Welkin> however understand that people from other languages only have unit tests (usually)
18:57:19 <Welkin> so they write property tests with hardcoded inputs as unit tests
18:57:32 <aplainzetakind> `elements` is such a convenient thing. Looking at System.Random, it looks like I'd have to jump through a lot of hoops to achieve similar functionality.
18:57:55 <Welkin> what do you mean?
18:59:35 <aplainzetakind> All the functions there seem to pass around the random number generator explicitly.
19:00:25 <Solonarv> there's a monad-random package for that
19:00:37 <Solonarv> (or is it MonadRandom? I forget)
19:02:36 <aplainzetakind> MonadRandom it appears.
19:03:10 <lyxia> Gen has many more combinators than MonadRandom
19:03:51 <lyxia> The fact that it is in a testing library does not make it less of a perfectly usable library for random generation.
19:05:26 <Welkin> the intent matters
19:05:36 <Welkin> a testing library should never be a dependency
19:07:28 <MarcelineVQ> why
19:09:15 <aplainzetakind> I can write stuff like `foo = elements [1,6,8]` and combine such things very easily and call `generate` on them when the time comes. Is there no other library that achieves such convenience without having to pass around transformer stacks?
19:12:12 <lyxia> AFAIK random-fu comes closest but it takes a while getting around in there. In the meantime one could have finished their job with QuickCheck.
19:15:45 <Welkin> what do you need transformer stacks for?
19:15:51 <Welkin> generate everything you need up front
19:15:56 <Welkin> > take 10 . randomRs (0,1000) $ mkStdGen 3 :: [Int]
19:15:58 <lambdabot>  [244,572,709,111,336,668,386,284,360,302]
19:30:52 <aplainzetakind> :t \xs -> let l = length xs in fst . first (xs !!) . randomR (0, l - 1)
19:30:53 <lambdabot> RandomGen g => [c] -> g -> c
19:31:21 <aplainzetakind> Is this how to pick an element from a list then?
19:31:48 * hackage sc2-proto 0.1.0.1 - A protocol buffer model for the Starcraft II bot API  https://hackage.haskell.org/package/sc2-proto-0.1.0.1 (spacekitteh)
19:40:47 * hackage sc2-proto 0.1.0.2 - A protocol buffer model for the Starcraft II bot API  https://hackage.haskell.org/package/sc2-proto-0.1.0.2 (spacekitteh)
20:38:47 <jeb> so what exactly is a monad?
20:40:17 <kadoban> It's (>>=) and return with some rules they have to follow together
20:40:25 <pacak> It's like a burrito...
20:41:04 <pacak> In java's terms it's an interface that contains a few methods, each implementation of which must obey some laws.
20:42:44 <jeb> ah
20:43:14 <jeb> recently got into haskell, I think its pretty neat
20:43:26 <pacak> When you hear "List monad" or "Maybe monad" - people are talking about specific implementations of this interface.
20:50:20 <Iceland_jack> It is jeb 
20:52:32 <Iceland_jack> As with good ideas there are many equivalent formulations of monads
20:53:42 <nshepperd> monads, like burritos, make me feel warm and happy
20:55:18 <Iceland_jack> jeb: If you can make sense of
20:55:19 <Iceland_jack>   concat :: List  (List  a) -> List  a
20:55:19 <Iceland_jack>   join   :: Maybe (Maybe a) -> Maybe a
20:55:19 <Iceland_jack> and are not hostile to the idea that something similar is going on, you're half-way there already
20:55:22 <Iceland_jack>  
20:55:23 <Solonarv> monads, like boxes, make me feel safe and comfortable
20:56:39 <pacak> Solonarv: You must be a cat then.
20:57:03 <Solonarv> meow.
21:04:58 <slack1256> What about the (e ->) monad then?
21:06:09 <glguy> What about it?
21:10:14 <slack1256> It is not very boxy
21:40:48 * hackage net-mqtt 0.2.4.0 - An MQTT Protocol Implementation.  https://hackage.haskell.org/package/net-mqtt-0.2.4.0 (dustin)
21:54:56 <iqubic> What does the Reader Monad even do?
21:55:32 <iqubic> I know there's that Reader, Writer, State monad RWS. I only know 1/3 of the components there. State.
21:57:07 <leungbk> after peeling off the constructor, you have a s -> 
21:57:13 <leungbk> oops, wait
21:57:25 <leungbk> you have s -> (a, s)
21:57:28 <leungbk> for the state monad
21:57:31 <leungbk> but for reader
21:57:38 <leungbk> you have instead
21:57:44 <leungbk> s -> a 
21:58:07 <aplainzetakind> The characterization that I think is most defining is "a monad is a class of computations which can be sequenced in a way that what the subsequent ones are may depend on the results of the preceding ones."
21:58:35 <iqubic> aplainzetakind: I think that works well.
21:58:53 <leungbk> so the state monad's inner fn will give you an updated state in addn to the return value, whereas the reader monad gives only the return value
21:59:29 <aplainzetakind> I realized that this was the defining element when ApplicativeDo told me what I can't do in it.
22:06:18 * hackage asif 3.4.0 -   https://hackage.haskell.org/package/asif-3.4.0 (arbornetworks)
22:16:42 * lambdacalculus[m sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/JHFIWSMgWDxsClqvlWXmAuXW >
22:17:15 * lambdacalculus[m sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/xcrCqsqdwHjkiRUnarvHvUaA >
22:17:30 <lambdacalculus[m> seems lacking.
22:36:38 <Mrbuck> I ahve soem frtran code which does things like Gausian elimination etc .....I see haskell not right replacement for fortran 
22:54:01 <aplainzetakind> Cabal won't build my test.
22:54:02 <aplainzetakind> [__1] rejecting: foo:!test (constraint from config file, command line flag, or user target requires opposite flag selection)
22:54:59 <dminuoso> aplainzetakind: Except that characterization is off.
22:55:45 <dminuoso> aplainzetakind: Between Codensity, Reader and Tardis there's a few monads that dont fit the scheme. 
22:55:59 <dminuoso> Ultimately that's why Monad might be harder to grasp because it's fully characterized by just its laws.
23:04:22 <hyou> Hey guys! A question about stack. Can I make stack download the .hs source to its library directory? I'm not talking about `stack unpack`. The .hs, .hi and .o should coexist in the same dir
23:05:46 <iqubic> What does Codensity do?
23:07:46 <iqubic> :t ask
23:07:48 <lambdabot> MonadReader r m => m r
23:09:47 <iqubic> :t tell
23:09:49 <lambdabot> MonadWriter w m => w -> m ()
23:11:40 <dminuoso> iqubic:     newtype Codensity f a = Codensity (forall r. (a -> f r) -> f r)
23:12:58 <aplainzetakind> (>>=) :: m a -> (a -> m b) -> m b; this type signature basically produces another m thing determined by (in the way specified by the second parameter) the m thing that is the first parameter.
23:14:35 <aplainzetakind> I'm not familiar with Codensity or Tardis, but the desription I gave is not based on the behaviour of any paricular instance.
23:16:49 <iqubic> dminuoso: That looks similar to a continuation.
23:17:36 <iqubic> not sure what the forall does there, but that looks like a continuation.
23:19:06 <c_wraith> it's a more restricted form of a continuation.  One where you have to call the provided function to get the types to line up.
23:20:38 <iqubic> Huh? I'm not sure what that means.
23:21:19 <c_wraith> compare to ContT  -   newtype ContT m a b = ContT ((a -> m b) -> m b)
23:21:40 <c_wraith> you can write values of that type which never call the provided function
23:21:51 <iqubic> How so?
23:22:30 <c_wraith> ContT (const (return 3)) :: (Monad m, Num b) => ContT m a b
23:23:03 <iqubic> I notice that all you are doing is removing the b from the parameter list and putting it into forall. Plus an eta conversion, but that's isomorphic.
23:23:07 <c_wraith> err, I got the args in the wrong order on the type.  All of those should be ContT m b a
23:23:38 <iqubic> So why can't you do that sort of a thing with the Codensity?
23:23:52 <c_wraith> You don't know what type r is
23:24:00 <c_wraith> You can't just create a value of that type.
23:24:19 <c_wraith> So you have to actually call the provided function
23:24:35 <iqubic> Can you show me what that might look like?
23:25:05 <trcc> I have created a package with cabal sdist, is there a way to add it to ones loacl cabal repo, so I can try it out without uploading to hackage?
23:25:45 <iqubic> *local
23:25:51 <trcc> hehe yes
23:28:38 <[Leary]> % :t Codensity \_ -> Right 'a'
23:28:38 <yahb> [Leary]: ; <interactive>:1:17: error:; * Couldn't match type `b' with `Char'; `b' is a rigid type variable bound by; a type expected by the context:; forall b. (a1 -> Either a b) -> Either a b; at <interactive>:1:1-25; Expected type: Either a b; Actual type: Either a Char; * In the expression: Right 'a'; In the first argument of `Codensity', namely \ _ -> R
23:28:48 * hackage char-qq 0.1 - Quasiquoters for characters and codepoints  https://hackage.haskell.org/package/char-qq-0.1 (NikitaVolkov)
23:29:08 <[Leary]> % :t Codensity \_ -> Left 'a'
23:29:08 <yahb> [Leary]: Codensity (Either Char) a
23:29:26 <Iceland_jack> (>>=) :: M ~> Codensity M
23:29:28 <dminuoso> Or even the Free monad is a good example that doesn't talk about "sequencing of computations" but building structure rather.
23:29:28 <dminuoso> aplainzetakind: My point is, `m a` might not even be talking about computation. A really good example is Free.
23:30:03 <Iceland_jack> curried version of join :: Compose M M ~> M
23:36:25 <iqubic> What does '~>' do?
23:37:59 <dminuoso> iqubic: It's a natural transformation..
23:38:21 <dminuoso> type (~>) m n = forall a. m a -> n a
23:38:45 <iqubic> Right. I keep forgeting that that thing exist.
23:41:36 <dminuoso> 08:29     Iceland_jack | curried version of join :: Compose M M ~> M
23:41:36 <dminuoso> iqubic: Wow that is amazing, I never thought of that. :)
23:41:37 <dminuoso> I meant, Iceland_jack. :)
23:42:02 <iqubic> It makes sense though.
23:42:47 <dminuoso> Well I just never thought to express Monad in terms of (~>) in Haskell like you would do in category theory.
23:46:18 <iqubic> How does (>>=) :: M ~> Codensity M work?
23:46:38 <iqubic> like why is that?
