00:22:32 <lmy9901> How to convert Float to Int32
00:22:41 <Ariakenom> :t round
00:22:43 <lambdabot> (Integral b, RealFrac a) => a -> b
00:23:45 <Ariakenom> > (floor 1.9, round 1.5, ceiling 1.1)
00:23:47 <lambdabot>  (1,2,2)
00:24:13 <Ariakenom> > round 0.5
00:24:15 <lambdabot>  0
00:24:34 <Firedancer> What would be good place to read about how Hackage package building and index-states work? 
00:24:38 <Firedancer> My specific problem is that gogol was recently updated to 0.4.0, but some subpackages like gogol-apps-calendar are not found if I fix index-state to for example yesterday
00:24:39 <Ariakenom> lmy9901 ^
00:25:56 <dminuoso> iqubic: Just substitute the types.
00:26:10 <dminuoso> iqubic: (You have to squint a bit and ignore newtype wrappers)
00:26:37 <lmy9901> The conversion principle is to convert Float to bits and then to Int32?
00:27:18 * hackage include-file 0.1.0.4 - Inclusion of files in executables at compile-time.  https://hackage.haskell.org/package/include-file-0.1.0.4 (DanielDiaz)
00:27:18 <dminuoso> lmy9901: The conversion principle is to round the number.
00:27:26 <Athas> Just remember that the conversion behaves oddly with infinities and nans.
00:29:10 <lmy9901> bits := math.float32bits(float_value)
00:29:35 <lmy9901> final = int32(bits)
00:30:22 <lmy9901> Is there an operation like the go language?
00:31:47 <Ariakenom> > round (0/0)
00:31:50 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
00:32:02 <Ariakenom> Athas: ... but whyy
00:34:02 <lmy9901> 。。。
00:34:37 <dminuoso> lmy9901: Im still convinced you probably should be using Storable rather.
00:34:49 <dminuoso> lmy9901: It's a XY problem.
00:35:36 <lmy9901> ok
00:38:03 <Athas> Ariakenom: it's a badly designed API.
00:38:38 <Athas> 'round' should have type 'RealFrac a => a -> a'.
00:42:35 <merijn> Athas: How would you convert to an integral, then?
00:43:10 <Athas> merijn: with a dedicated funtion just for that.
00:43:37 <Athas> Rounding in its various forms is orthogonal to converting to an integer.
00:43:42 <merijn> Athas: Except you'd just end up having to duplicate all rounding functions to also have a version that goes to Integral
00:44:13 <Athas> Sure, but isn't Haskell supposed to make meaning clear in the types?  Or are numbers excluded?
00:44:26 <kadoban> Ya, how would the new convertToIntegral function differ from what round currently does?
00:44:29 <Athas> Right now the rounding functions (or at least their instances for floats) will return garbage in some cases.
00:45:17 <Athas> kadoban: I think you'd have two functions: one for Rational-ish types that will always work, and one for RealFloat (or whatever it's called) that returns a Maybe.
00:46:55 <Athas> I often see it argued that the point of type classes is to have laws, and right now I'm quite skeptical that the intuitive laws hold for the Float/Double instances.
00:47:32 <kadoban> Ya, they're exceptions to pretty much every typeclass they're an instance of
00:47:36 <merijn> Athas: I think the classes for Float/Double (and even Num in general) are a fucking mess
00:47:48 <merijn> But I also don't know how we'd do it better
00:49:13 <merijn> Athas: Incidentally just 5s ago I read an email by carter about how he wants to fix up the messes of Float/Double instances :)
00:49:45 <Athas> Realistically, it can't be fixed, I think.  I do believe it would be an improvement if the rounding functions would at least throw an error if you try to convert a nan or infinity to an integral type.
00:49:56 <Athas> Sure, partial funtions suck, but just returning garbage is pointless.
00:50:16 <dminuoso> Athas: The problem though is that you might want to round floating point numbers without forcing an error.
00:50:30 <dminuoso> i.e. RealFrac a => a -> a is equally as useful.
00:50:44 <merijn> Clearly we all just need more LiquidHaskell in our lives ;)
00:51:04 <dminuoso> Athas: Things *might* be better if we could toggle IEEE 754 exceptions on.
00:51:34 <Athas> dminuoso: yes, but that would break a lot of code.  I agree it would have been a better design back in primordial times.
00:51:48 <Athas> As soon as I get a time machine, I'll go right back and tell them!
00:52:22 <merijn> Athas: Tell them to make exceptions checked too and to not hard wire fucking String everywhere ;)
00:53:35 <Athas> FWIW, in my own language I have the rounding functions be type-preserving, but the to-integer conversions turn nans and infinities into zeroes, so I'm no saint either.
00:53:47 <Athas> But then I don't focus as much on correctness as Haskell is supposed to!
00:54:17 * hackage char-qq 0.1.1 - Quasiquoters for characters and codepoints  https://hackage.haskell.org/package/char-qq-0.1.1 (NikitaVolkov)
01:22:35 <gentauro> merijn: one of the authors to LiquidHaskell moved to Madrid and she offered phd to work on it ;)
01:28:18 * hackage parseargs 0.2.0.9 - Parse command-line arguments  https://hackage.haskell.org/package/parseargs-0.2.0.9 (BartonMassey)
01:29:06 <Ariakenom> merijn: "email by carter about how he wants to fix up the messes of Float/Double instances" Is it on a mailing list? link?
01:30:22 <merijn> Ariakenom: "is it on a mailing list?" yes, but I just get those in my mail and I can't be arsed to look it up right now :)
01:30:29 <merijn> probably ghc-devs or libraries
01:30:58 <Ariakenom> ok then. I may go search
01:31:34 <oo_miguel> is ghc-mod still used? Can somebody redommend alternatives? It does not seem to build via 'stack install ghc-mod' anymore
01:32:15 <butterthebuddha> I have finite (sum) types A and B. Is it possible to generate a list of all possible functions A -> B?
01:32:49 <kritzefitz> oo_miguel, you might want to try haskell-ide-engine. It's IMO not exactly easy to build, but once you get it running its quite nice.
01:33:00 <kadoban> butterthebuddha: Any helpful typeclasses? Are they Enum and Bounded perhaps?
01:33:06 <butterthebuddha> They are Enum
01:33:43 <butterthebuddha> On that note, is there an implementation of Enum for (A, B) given an implementation of Enum for A and B? I.e. is there a package which implements that? 
01:34:14 <kadoban> I think there already is one in the Prelude, isn't there?
01:34:26 <oo_miguel> kadoban: Ill have a look, thank you!
01:34:46 <oo_miguel> I also came across haskellmode-vim. not sure how popular this one is, but will play with this one as well
01:35:12 <MarcelineVQ> kadoban: Just Bounded at a ghci glance
01:35:20 <kadoban> butterthebuddha: I dunno how you're going to write such a thing without Bounded too, in general. Unless you do it specifically for A and B, and you know what the bounds are
01:35:31 <kadoban> MarcelineVQ: Hm, interesting
01:36:11 <butterthebuddha> Since my types are Enum I can derive Bounded
01:38:53 <kadoban> If you have Bounded, then you should at least have enough. How to actually implement it ... uhmmm. So one function from A -> B corresponds to ... for every value of A, pick a value from B. Hm. There's gotta be a cute way to enumerate all of those functions
01:40:24 <kadoban> So there's A^B of them. I guess you could just do something like, have a "number" with B digits, each of them from 0 to A-1, inclusive, and then you increment that number to get the next function.
01:41:18 <kadoban> And to actually run the function, you'd just take the input A value, figure out what "digit" that is, just use fromEnum I suppose, and then you toEnum the digit to a B
01:41:34 <kadoban> Should work
01:42:25 <lmy9901> type LocalVariableTable :: [Int32]   push :: LocalVariableTable -> Float -> ()    push :: LocalVariableTable -> Int32 -> ()   push :: LocalVariableTable -> Int64 -> ()   push :: LocalVariableTable -> Double -> ()
02:01:15 <lmy9901> For an int64 value, how to separate it into two int32, high and low
02:15:04 <Ariakenom> lmy9901: shifts and fromIntegral. and something for dealing with the sign
02:15:53 <lmy9901> thank you 
02:16:41 <Ariakenom> a mask for the low part I'd think
02:26:35 <Digit> eeheheheh, tickles.
02:35:15 <lmy9901> how convert Int32 to Word32?
02:36:44 <merijn> It depends on what you want to happen
02:37:57 <lmy9901> I split Int64 into two Int32s, and I need a function to combine two Int32s into one Int64.
02:40:41 <lmy9901> var low = uint32(int32_v1)
02:40:41 <lmy9901> var high = uint32(int32_v2)
02:40:41 <lmy9901> int64(high << 32) | int64(low)
02:44:42 <lmy9901> fromIntegral (-1297042716 :: Int32) :: Word32  This seems to be ok. .
02:46:14 <Ariakenom> some float changes  discussion if someone else was interested https://mail.haskell.org/pipermail/libraries/2019-February/029362.html
02:49:17 * hackage fraxl 0.3.0.0 - Cached and parallel data fetching.  https://hackage.haskell.org/package/fraxl-0.3.0.0 (willfancher)
03:12:08 <fsharper> me aburroooooooo
03:28:17 * hackage resistor-cube 0.0.0.4 - Compute total resistance of a cube of resistors  https://hackage.haskell.org/package/resistor-cube-0.0.0.4 (HenningThielemann)
03:58:04 <waern> Which generic programming libraries do you guys prefer when manipulating languages these days in haskell?
03:59:33 <dminuoso> waern: What do you mean by "manipulating languages" exactly?
04:01:02 <Athas> I prefer not using generic programming (at least not the syb style).  I used it early on in my compiler, and I found it overly complicated and slow.
04:01:19 <Athas> In the end, I wound up hand-writing some generic traversal/folding functions for my AST.
04:02:15 <waern> dminuoso: Good question. In my case I'm working on a specification language, represented by an AST indexed by phase a bit similar to the trees that grow pattern. 
04:02:38 <waern> Athas: Yeah, I have a bunch of handwritten traversals right now
04:03:17 <waern> I was thinking something uniplate-like may be handy
04:04:42 <waern> My AST is separated into a Desc type and an Expr type where the actual syntax is in the Desc type and the Expr contains annotations like type and ID from hash-consing
04:14:18 * hackage char-qq 0.1.1.1 - Quasiquoters for characters and codepoints  https://hackage.haskell.org/package/char-qq-0.1.1.1 (NikitaVolkov)
04:19:24 <int-e> @hoogle [a] -> Int -> Maybe a
04:19:25 <lambdabot> Safe atMay :: [a] -> Int -> Maybe a
04:19:25 <lambdabot> Agda.Utils.List (!!!) :: [a] -> Int -> Maybe a
04:19:25 <lambdabot> CLaSH.Util indexMaybe :: [a] -> Int -> Maybe a
04:31:18 * hackage pandora 0.1.2 - A box of patterns and paradigms  https://hackage.haskell.org/package/pandora-0.1.2 (iokasimovmt)
04:37:49 <dminuoso> So does the TypeError primitive have a type theory interpretation? It seems to be that it shouldn't exist.
04:39:11 <merijn> dminuoso: It's just "doesn't type check"
04:39:28 <merijn> Except you get to specify slightly more specifically why not :p
04:39:57 <dminuoso> merijn: No I understand what its used for.. but if I was to ask you to formalize the type system of Haskell, what would TypeError be?
04:41:15 <merijn> dminuoso: The same thing as "'c' :: Int" i.e. it just corresponds to the typing judgement being false
04:41:53 <Ariakenom> . o O (The type judgement being 'False)
04:43:03 <Ariakenom> (that's terribly wrong ofc. just what I thought of first)
04:43:28 <merijn> dminuoso: Remember that a typing judgement is just a proposition that is either true or false
04:43:48 <merijn> dminuoso: TypeError can be handled as any judgement involving it being false
04:43:58 <merijn> (true being "this term is well-typed")
04:44:55 <merijn> dminuoso: So you don't really need too much extra machinery (Dependent Types might change that, but I live in a world where those aren't part of Haskell yet :p)
04:47:23 <inkbottle> :t (undefined :: b -> c) <$> (undefined :: a -> b)
04:47:24 <lambdabot> a -> b
04:47:25 <inkbottle> :t (undefined :: b -> c) <$> (undefined :: a -> b) :: a -> c
04:47:26 <lambdabot> a -> c
04:47:32 <inkbottle> ?
04:47:39 <tsahyt> I think I got my brain into a bit of a knot about the n^2 instances problem with mtl style classes
04:48:11 <dminuoso> merijn: Could I implement TypeError in terms of Haskell (including extensions of course) without the help of GHC?
04:48:25 <tsahyt> what prevents one from just writing something like this https://paste.fedoraproject.org/paste/z5uqYVzrMQVc~UtzIX0O2Q
04:48:53 <tsahyt> i.e. using an existing MonadTrans instance to create "passthrough" instances for all further layers of a stack
04:49:58 <merijn> dminuoso: If you're willing to throw out the helpful errors GHC generates from it, you mean?
04:50:01 <tsahyt> this might be a bit of a silly example, but creating some class that provides a subset of IO isn't all that uncommon, and with the second instance here I can access it in an arbitrary transformer stack. at least the one example here works
04:50:06 <dminuoso> merijn: Sure.
04:50:19 <merijn> dminuoso: Yes, see: https://gist.github.com/merijn/6130082
04:50:32 <merijn> dminuoso: That code triggered me to campaign for having something like TypeError
04:50:47 <tsahyt> so where would this fail?
04:51:06 <dminuoso> merijn: Mmm, okay so you moved it into constraints.. could you do it without ConstraintKinds?
04:51:34 <merijn> dminuoso: Any type family that conditionally evaluates to a type mismatch works
04:52:00 <merijn> dminuoso: i.e.: 'c' :: MyTypeFamily Arg1 Arg2
04:52:09 <merijn> And then have MyTypeFamily evaluate to () to fail
04:52:45 <dminuoso> merijn: You'd need a completely uninhabitated type for that to work.
04:53:20 <merijn> dminuoso: No?
04:53:28 <merijn> You just need the type to not match the term
04:53:37 <dminuoso> merijn: let a = a in a :: MyTypeFamily Arg1 Arg2
04:53:50 <dminuoso> Let's say for the sake of argument I wanted this to fail.
04:54:26 <lyxia> tsahyt: I don't remember what the technical problem was but you at least need an overlapping instance to implement the MonadFoo Foo at the bottom of the stack.
04:54:54 <tsahyt> lyxia: so I got lucky with my example?
04:54:56 <lyxia> tsahyt: and many of mtl's classes require something stronger than MonadTrans
04:54:59 <dminuoso> lyxia: Didn't edward talk about this in his warsaw talk about monad transformer lenses?
04:55:11 <tsahyt> ah, well that'd be a bigger issue then
04:55:12 <lyxia> dminuoso: maybe
04:55:41 <lyxia> tsahyt: oh no sorry you don't need an overlapping instance in general
04:55:54 <tsahyt> well, at least for this type of restricted-IO class that I sometimes use to get more expressive types, this seems to work well enough
04:56:10 <lyxia> tsahyt: only if your "base monad" has the form (t m) for some t and m with the same kinds as in that instance
04:56:32 <tsahyt> ah right, that's not the case in my example
04:56:35 <lyxia> which is quite rare indeed
04:57:06 <tsahyt> well, I'll put this away into my toolbox of things that might come in handy one day
04:57:20 <lyxia> I agree it can work pretty well though
04:57:36 <tsahyt> lyxia: but why would MonadTrans be insufficient in some cases though?
04:57:56 <dminuoso> % let a = a in a :: TypeError
04:58:02 <yahb> dminuoso: [Timed out]
04:58:20 <dminuoso> % :t (let a = a in a :: TypeError)
04:58:21 <yahb> dminuoso: TypeError
04:58:38 <dminuoso> Okay not what I meant. One moment. ;)
04:59:33 <dminuoso> % let a = a in a :: GHC.TypeLits.TypeError (Text "foo")
04:59:33 <yahb> dminuoso: ; <interactive>:6:19: error:; * foo; * In an expression type signature: GHC.TypeLits.TypeError (Text "foo"); In the expression: a :: GHC.TypeLits.TypeError (Text "foo"); In the expression: let a = a in a :: GHC.TypeLits.TypeError (Text "foo")
04:59:51 <lyxia> tsahyt: whenever the class methods take an (m _) as an argument, you have a problem, see MonadError(catchError), MonadReader(local), MonadWriter(pass)
04:59:56 <dminuoso> merijn: ^- this is what I meant.
05:00:45 <tsahyt> lyxia: right, that does at least ring a bell. those are the ones that tended to give me some troubles writing manual instances too. i.e. I've found that I can't just use lift for them
05:00:47 <tsahyt> so that makes sense then
05:01:57 <kritzefitz> % let a = a in a :: (a ~ Char, a ~ ()) => a
05:01:57 <yahb> kritzefitz: ; <interactive>:7:14: error:; * Couldn't match type `Char' with `()' arising from an expression type signature; * In the expression: a :: (a ~ Char, a ~ ()) => a; In the expression: let a = a in a :: (a ~ Char, a ~ ()) => a; In an equation for `it': it = let a = a in a :: (a ~ Char, a ~ ()) => a
05:02:02 <carter> Library mailing list
05:02:05 <kritzefitz> dminuoso, does that qualify?
05:03:02 <inkbottle> I think substitution is a functor; How can I get that: `((\c -> c : "45") :: Char -> String) <$> (read :: String -> Int)` == `(read :: String -> Int) . ((\c -> c : "45") :: Char -> String)`?
05:03:38 <carter> merijn: we def could / should add may throw info into Haskell interface files
05:04:00 <dminuoso> kritzefitz: Im not sure, because that actually defers type errors on usage.
05:04:42 <kritzefitz> % let a = a :: (a ~ Char, a ~ ()) => a
05:04:42 <yahb> kritzefitz: ; <interactive>:10:9: error:; * Couldn't match type `Char' with `()' arising from an expression type signature; * In the expression: a :: (a ~ Char, a ~ ()) => a; In an equation for `a': a = a :: (a ~ Char, a ~ ()) => a
05:06:23 <kritzefitz> I see
05:07:42 <kritzefitz> I think I'm slightly confused about polymorphic kinds. If I have a type `forall a. a` GHC introduces a variable kind for it like `forall k (a :: k). a`, right?
05:08:01 <kritzefitz> (Given that PolyKinds is active)
05:09:45 <lyxia> i guess it does
05:09:56 --- mode: ChanServ set +o Sigyn
05:09:59 <kritzefitz> Then, what is the kind of k?
05:10:19 <dminuoso> kritzefitz: kinds have sorts and the only sort we have is box
05:11:07 <kritzefitz> dminuoso, really? I thought GHC's approach of making types and kinds the same thing, that kinds had kinds too.
05:11:16 <kritzefitz> *meant that
05:11:25 <dminuoso> Ah with TypeInType yeah.
05:11:35 <lyxia> k :: Type
05:11:35 <merijn> kritzefitz: See, this is why I think TypeInType is confusing as fuck :p
05:12:25 <kritzefitz> I was more thinking about DataKinds.
05:12:44 * kritzefitz didn't know about TypeInType until now.
05:12:57 <lyxia> a :: k    so    k :: Type     anything that's directly to the right of :: must have kind Type (unless you're messing with low-level primitives, which you don't at the type-level)
05:13:37 <dminuoso> kritzefitz: So without TypeInType you have (semantically) an infinite tower of types. But there's no point to talk about things beyond kind because kinds have sorts and there exist only one sort - and beyond that there's only singletons.
05:14:14 <dminuoso> kritzefitz: With TypeInType you conflate the whole tower into just one level such that Type :: Type
05:14:23 <lyxia> (I'm taking TypeInType as a given)
05:17:34 <kritzefitz> I was mostly wondering, because I recently had a problem where `data Foo = Foo (forall a. a)` was seen by GHC as `data Foo = forall k. Foo (forall (a :: k). a)`, which meant I had to enable ExistentialQuantification...
05:18:08 <dminuoso> % :set -XPolyKinds
05:18:08 <yahb> dminuoso: 
05:18:15 <dminuoso> % data Foo = Foo (forall a. a)
05:18:15 <yahb> dminuoso: 
05:18:25 <dminuoso> % :t Foo
05:18:25 <yahb> dminuoso: (forall a. a) -> Foo
05:18:35 <kritzefitz> Writing `data Foo = Foo (forall k (a :: k). a)` solved the problem and I was confused why GHC didn't think I meant `data Foo = forall k1. Foo (forall (k :: k1) (a :: k). a)`
05:20:22 <lyxia> yet another interpretation would be data Foo k = Foo (forall (a :: k). a) !
05:20:59 <kritzefitz> Yes, but I think GHC can't just make up type parameters for Foo, when I didn't specify any.
05:21:15 <kritzefitz> Whereas making up existentials is apparently fine.
05:22:28 <inkbottle> 3rd line section 2: https://wiki.haskell.org/Functor ((<$>) :: a -> f b -> f a). Is that a mistyping?
05:22:55 <merijn> Yes
05:23:35 <merijn> inkbottle: Oh!
05:23:44 <merijn> inkbottle: That's supposed to be <$ :)
05:23:50 <inkbottle> OK
05:23:53 <merijn> :t (<$)
05:23:54 <lambdabot> Functor f => a -> f b -> f a
05:27:17 <inkbottle> `instance Functor (-> b) where`: parse error on `b`.
05:27:32 <inkbottle> I want my substitution functor
05:29:39 <merijn> inkbottle: Don't you mean "instance Functor ((->) b)"?
05:29:50 <kritzefitz> I just noticed my earlier example of Foo is wrong. I actually meant `Foo = Foo (forall a. ())`
05:29:57 <kritzefitz> % :set -XPolyKinds
05:29:58 <yahb> kritzefitz: 
05:30:06 <kritzefitz> % data Foo = (forall a. ())
05:30:06 <yahb> kritzefitz: ; <interactive>:26:12: error: Cannot parse data constructor in a data/newtype declaration: (forall a. ())
05:30:07 <merijn> inkbottle: Even if section syntax would work for types, then that still couldn't be a functor :)
05:30:14 <inkbottle> merijn: no I want the mirrored thing
05:30:18 <kritzefitz> % data Foo = Foo (forall a. ())
05:30:18 <yahb> kritzefitz: 
05:30:23 <kritzefitz> % :t Foo
05:30:23 <yahb> kritzefitz: (forall (a :: k). ()) -> Foo
05:32:20 <inkbottle> merijn: I think I'll use bifunctor, or sth
05:33:15 <merijn> inkbottle: But that can't be a functor because it's in the contravariant position
05:33:23 <merijn> inkbottle: Don't you just want Contravariant, then?
05:33:47 * hackage pipes-http 1.0.6 - HTTP client with pipes interface  https://hackage.haskell.org/package/pipes-http-1.0.6 (GabrielGonzalez)
05:33:49 <merijn> inkbottle: (->) also isn't a Bifunctor, because, well, the first argument is contravariant
05:34:10 <merijn> inkbottle: And "Bifunctor, but with a contravariant first argument" would be Profunctor
05:34:33 <inkbottle> d...
05:34:47 * hackage ngx-export 1.7.0 - Helper module for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-1.7.0 (lyokha)
05:35:08 <merijn> :t contramap
05:35:10 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
05:37:41 <inkbottle> I've got (a -> a -> IO a) (a -> IO a) (a -> IO a); I want to have (IO a) without having to go a far as a 'do' notation; seems that thing should be sorted out w. plain functors (possibly contravariant)
05:38:22 <merijn> inkbottle: eh, how exactly wo you wanna combine them? :p
05:38:34 <merijn> inkbottle: Because I can fit those types together in like 20 different ways :p
05:39:28 <inkbottle> hang on, need to type...
05:41:07 <merijn> Also: avoiding do notation isn't generally a sensible goal, and 2) it's always possible to rewrite any do block using >>= :)
05:42:34 <inkbottle> merijn: :t do { a <- undefined :: IO a; b <- undefined :: IO a; (undefined :: a -> a -> IO a) a b } -- I want to avoid monads, because they seem overkill (functor might be not enough, though)
05:42:47 <inkbottle> :t do { a <- undefined :: IO a; b <- undefined :: IO a; (undefined :: a -> a -> IO a) a b }
05:42:49 <lambdabot> IO b
05:42:58 <merijn> inkbottle: That's not really sensible, though?
05:43:13 <merijn> inkbottle: I mean, IO is already a Monad *anyway*, so why would it be "overkill"
05:43:15 <inkbottle> ?
05:43:17 <mniip> your function is about as strong as Monad is
05:43:26 <mniip> if it were slightly more poylmorphic
05:43:34 <inkbottle> OK
05:43:35 <mniip> you could implement bind with it
05:43:43 <mniip> so you can't use anything weaker than a monad
05:43:48 <inkbottle> OK
05:43:48 <merijn> inkbottle: Overkill would imply your using "more than needed", but since we're dealing with IO specifically, there's no real reason to avoid Monad
05:44:25 <inkbottle> :t do { a <- undefined :: a; b <- undefined :: a; (undefined :: a -> a -> a) a b }
05:44:27 <lambdabot> Monad m => m b
05:44:40 <inkbottle> like... remove the IO
05:44:50 <merijn> inkbottle: If you were dealing with an arbitrary 'f' then "avoiding Monad and sticking to Applicative" might make sense (since it'd be more reusable), but since your code isn't generic to begin with, that point is moot :)
05:44:52 <inkbottle> Anyway, it might be a monad though
05:45:39 <inkbottle> It seemed so obvious ;)
05:46:25 <merijn> inkbottle: I generally prefer writing simple heavy weight code (so, assuming Monad or whatever) first, then try and generalise it later when it works
05:49:01 <inkbottle> merijn: Looking for a puzzle sheet: "replace do notation by sth weaker, when possible in the following snippets". Anything like that?
05:49:27 <merijn> hlint, maybe? ;)
05:49:47 <inkbottle> hum
05:50:15 <Clint> what's weaker than do notation?
05:50:32 <merijn> Clint: Applicative and Functor
05:50:34 <Taneb> don't notation
05:50:43 <inkbottle> (plus why do we have to fill-up the "undefined" in the first place)
05:50:45 <kritzefitz> Taneb, that's exactly what I thought.
05:50:47 <inkbottle> good one
05:50:50 <merijn> @hackage acme-dont -- Taneb
05:50:51 <lambdabot> http://hackage.haskell.org/package/acme-dont -- Taneb
05:50:58 <Taneb> merijn: I was about to link that :D
05:51:15 <merijn> inkbottle: What do you mean "why do we have to fill-up the undefined"?
05:52:52 <int-e> > let please = id in please $ do { return 42 } :: Identity Int
05:52:54 <lambdabot>  Identity 42
05:53:20 * int-e leaves "abstain" as an exercise to Taneb
05:53:34 <Taneb> acme-monad-intercal
05:53:46 <inkbottle> merijn: well, if the type system is strong enough... you know, "proof irrelevance" (the program is the proof, and if the proposition is true, why bother)
05:54:20 <Taneb> inkbottle: because sometimes you want your proofs to have computational semantics
05:55:36 <inkbottle> Yes, not versed in computational semantic; I should look-up this one ;)
05:58:06 <inkbottle> "except that, instead of executing the block it controls, it... well... doesn't." It seems the solution to every programming problems ;)
05:58:48 * hackage metar-http 0.0.3 - HTTP for METAR  https://hackage.haskell.org/package/metar-http-0.0.3 (TonyMorris)
06:09:49 <matsurago> I wonder what level of Haskell knowledge is required to successfully land a job in it? Like knowing the standard + some libraries + GHC extensions?
06:10:05 <trcc> matsurago: great question
06:10:19 <merijn> matsurago: None, if you're willing to relocate to Alaska ;)
06:10:24 <trcc> haha
06:11:16 <matsurago> I hate cold ._.
06:11:16 <trcc> matsurago: Have you released anything in haskell that you can show?
06:11:32 <trcc> I love cold! You can dress for the cold, not the heat
06:11:42 <trcc> you can only undress to a certain degree
06:11:43 <merijn> That's actually not a joke, there was a company looking to recruit someone to do Haskell that in the opening said they'd accept people with no prior Haskell experience
06:12:02 <merijn> But it's in Alaska with no remote options, so...
06:12:23 <matsurago> trcc: I just have the repo with some simple examples illustrating the syntax and some easy algorithms
06:12:29 <dminuoso> Well if you need them to be in Alaska, lowering the bar to "no prior experience" is needed.
06:12:35 <merijn> masaeedu[m]: See also: https://patrickmn.com/software/the-haskell-pyramid/
06:12:37 <merijn> eh
06:12:44 <merijn> s/masaeedu[m]/matsurago
06:13:23 <trcc> ah yes, remembe that merijn. It is great
06:14:04 <merijn> matsurago: It depends on a couple things: Are you willing to move? What kinda position/company do you wanna work at? etc.
06:14:26 <merijn> The really big banks and Facebook generally want considerably more Haskell experience than some smaller ones
06:14:46 <dibblego> I hire people with no prior Haskell experience.
06:14:50 <matsurago> merijn: that pyramid is pretty cool, thanks
06:15:08 <merijn> dibblego: Where and doing what? :p
06:15:18 <trcc> matsurago: ok. In my view, I find that companies like to see "ability to release". I.e. make software that is releasable. That indicates you have been around the basic stuff required to make a piece of software, and not only looked at the interesting bits
06:15:21 <dibblego> merijn: http://qfpl.io for Data61/CSIRO
06:16:04 <trcc> so although the software you write have a lot of potential for improvement, it is there, and it does its job.
06:16:16 <trcc> there is always goldplating to do ^^
06:16:38 <merijn> dibblego: Ah, wrong side of the world ;)
06:16:51 <dibblego> ahem, no mate, you're on the wrong side
06:17:18 <merijn> trcc: tbh, it's all "It Depends"
06:17:29 <trcc> merijn: definitely. Just giving my two cents
06:17:35 <merijn> What do you wanna work on? What are your constraints? etc.
06:17:49 <dminuoso> 15:09  matsurago | I wonder what level of Haskell knowledge is required to successfully land a job in it? Like knowing the standard + some libraries + GHC extensions?
06:17:55 <matsurago> trcc: So you think that creating a Git repo with some useful software written in Haskell may be a good start?
06:18:03 <merijn> I mean, I've been contacted by recruiters way before I had any form of substantial open source stuff on github
06:18:05 <dminuoso> matsurago: I think one of the main factors might actually be availability of jobs nearby.
06:18:27 <dminuoso> matsurago: Haskell jobs are not found as easily as some others.
06:18:45 <merijn> matsurago: Sure, but so would contributing patches to programs/projects (cabal-install, GHC, whatever)
06:19:22 <matsurago> Hmm, it does make sense
06:19:31 <trcc> matsurago: definitely. Get a package on hackage
06:20:34 <matsurago> dminuoso: few jobs available + a lot of candidates = makes it quite difficult I guess
06:21:05 <merijn> matsurago: A bigger issue is jobs not being uniformly distributed geographically :p
06:21:06 <dminuoso> matsurago: There are not a lot of candidates, honestly.
06:22:37 <matsurago> merijn: I hope it is changing for the better though as more and more people started to recognize the importance of functional programming
06:22:39 <trcc> matsurago: is there any way of addging haskell to your current job?
06:23:06 <trcc> I am currently writing a package in my spare time, that when finished, will allow be to do Haskell in my current job
06:23:14 <matsurago> trcc: no way, unless *eta* is ready. The shop is making JVM stuff.
06:23:39 <trcc> haha, my job is 50% JVM, 50% not JVM. I am addressing the 50% not JVM right now :D
06:24:08 <matsurago> mine is unfortunately almost 100% JVM besides some bash for devops
06:24:47 <matsurago> so I am learning Haskell for fun
06:24:52 <dibblego> alternatively, make your job a Haskell job, or specifically, a "use the right tool" job, where Haskell often falls out. WFM for the last 15 years
06:26:09 <dminuoso> That's what I did. :)
06:26:35 <dminuoso> My boss is happy with the rapid development speed and software stability, which strengthened my position.
06:26:38 <Taneb> matsurago: one of my coworkers got a Haskell job here without having used Haskell before
06:26:42 <Taneb> (although he did know OCaml)
06:29:52 <matsurago> So, probably, as many said, the main factor is the geographical availability...
06:30:30 <matsurago> Thanks for the suggestions, I think for now I will try to contribute to some Haskell project :)
06:34:29 <Taneb> matsurago: ooi where are you based?
06:36:50 <matsurago> Taneb: um, at the moment, Japan
06:37:41 <Taneb> I'm pretty sure there are Haskell jobs there :)
06:39:48 <merijn> If you're willing to relocate there's more options
06:40:04 <merijn> Standard Chartered seems to be looking for people for the Singapore office near permanently :p
06:46:16 <tdammers> the Haskell job market is much smaller than the mainstream ones, on both sides, so you may have to wait longer, but Haskell jobs do exist
06:47:00 <matsurago> merijn: that's actually quite interesting...
07:27:10 <dminuoso> Mmm "List is the free monoid" really seems to mean that "List is left adjoint to some forgetful functor from Hask to Mon", is this about right?
07:54:01 <lyxia> yes
07:54:38 <lyxia> the forgetful functor goes the other way around
07:57:18 * hackage sexpr-parser 0.1.1.2 - Simple s-expression parser  https://hackage.haskell.org/package/sexpr-parser-0.1.1.2 (rcook)
08:25:19 <binq> damn it why won't `stack solver` install compact!
08:25:19 <binq>      * Dependencies to be deleted
08:25:19 <binq>          extra-deps:
08:25:21 <binq>          - compact-0.1.0.1
08:26:03 <merijn> binq: Are you perhaps trying to install it for an unsupported GHC?
08:27:02 <binq> ahhh yes
08:27:17 <phadej> binq: just use ghc-compact
08:27:22 <binq> it must only be for 8.2 and I am on 8.6
08:28:20 <binq> @phadej oh nice thanks!
08:28:20 <lambdabot> Unknown command, try @list
08:28:26 <merijn> Weird that it doesn't work with a newer GHC...
08:28:36 <binq> phadej: oh nice thanks!
08:28:48 <phadej> merijn: compact works, but it doesn't add any value over ghc-compact
08:29:56 <phadej> merijn: i.e. see https://github.com/ezyang/compact/blob/master/Data/Compact.hs
08:30:17 <phadej> it does wrap ghc-compact, but I'm not sure what the plan was
08:30:47 * hackage brok 0.1.4.0 - Finds broken links in text files  https://hackage.haskell.org/package/brok-0.1.4.0 (smallhadroncollider)
08:30:57 <phadej> (serialize module or what, not sure)
08:31:07 <binq> same problem
08:31:13 <binq> Using compiler: ghc-8.6.2
08:31:13 <binq> Using resolver: ghc-8.6
08:31:13 <binq> Using compiler: ghc-8.6.2
08:31:15 <binq> Asking cabal to calculate a build plan...
08:31:17 <binq> Trying with packages from ghc-8.6 and 19 external packages as hard constraints...
08:31:19 <binq> Successfully determined a build plan with 18 external dependencies.
08:31:21 <binq> The following changes will be made to stack.yaml:
08:31:23 <binq> * Dependencies to be deleted
08:31:25 <binq>     extra-deps:
08:31:27 <binq>     - ghc-compact-0.1.0.0
08:31:38 <binq> such an unhelpful error message
08:32:32 <phadej> ghc-compact is bundled with ghc
08:32:37 <phadej> yo udon't need to add it to extra-deps
08:33:05 <phadej> (and if you want to use solver, use cabal new-build)
08:35:47 <binq> phadej: ok that works, thanks!
08:38:14 <nick34348> hey guys, I'm trying to modify XMonad, and I want to write the following function without the parentheses around the flip union and fromList functions, but when I omit those two pairs of parentheses, it gives me an error https://pastebin.com/vE41y7yh
08:39:33 <nick34348> Here's the error message https://pastebin.com/u7d6dsfD
08:39:34 <petercommand> nick34348: I think that's because $ is right associative
08:39:43 <lyxia> flip union (XMonad.keys def conf) $ fromList ...
08:40:12 <nick34348> ok, thanks
08:40:39 <infinisil> Is union not commutative?
08:40:51 <merijn> infinisil: Left biased usually
08:41:02 <infinisil> Ah
08:41:27 <merijn> infinisil: Which (shouldn't) matter for, Set, but does for Map and similar
08:41:42 <nick34348> I didn't know  $ was right associative, now I get why it didn't work
08:42:34 <nick34348> Yeah, basically, I want the list of key bindings at the end of the function to override the default ones. That's why I used flip union
09:20:56 <mreh> secureRandomBytes :: (DRG g, MonadState g m) => Int -> m ByteStringsecureRandomBytes = state . randomBytesGenerate
09:21:17 <mreh> oops
09:22:06 <mreh> This doesn't seem to generate new random bytes when sequenced
09:22:55 <mreh> secureRandomBytes = state . randomBytesGenerate -- randomBytesGenerate from Crypto.Random
09:27:24 <mreh> I guess it's something to do with how Servant evaluates requests. It;s probably not sequencing the request handlers.
09:28:14 <alp> state isn't shared among handlers
09:28:40 <mreh> alp: damnit
09:28:41 <alp> unless you use some form of thread-safe, mutable shared variable
09:28:59 <alp> because what happens if two people hit your endpoint at the same time? what state to use? what if the code updates the state? etc
09:29:22 <mreh> I didn't think seeding a gen from system entropy every request was such a good idea 
09:29:26 <alp> the problem would be identical with any other web framework, of course, none of this is specific to servant
09:29:57 <alp> just the fact that you have a server that potentially processes loads of requests simultaneously
09:30:06 <mreh> it's just a PRNG, no biggie if two requests come in an unspecified order
09:30:18 <mreh> but, they would block right?
09:30:40 <alp> if you make them, yes
09:30:42 <phadej> mreh: the problem is the same as with sharing database connection, opening new connection to database per request is wasteful; therefore people use resource-pool
09:30:48 <phadej> so you can pool PRNGs too
09:31:09 <alp> e.g waiting for RNG resource to be available (released by another request thread)
09:31:23 <mreh> is it wasteful to seed a CPRNG every request?
09:31:27 <phadej> it is
09:31:41 <mreh> is it potentially a DOS attack vector?
09:31:56 <phadej> yes
09:32:11 <phadej> system can run out of entropy
09:32:54 <asfff> Hi, is Haskell Platform currently not the recommended way to install haskell on Ubuntu?
09:33:00 <phadej> (i don't know how luckily it is, but in theory it's possible)
09:33:04 <phadej> asfff: no
09:33:21 <phadej> asfff: everyone I know uses https://launchpad.net/~hvr/+archive/ubuntu/ghc
09:33:56 <mreh> Ideally I'd like to see a CPRNG for the lifetime of the server and use that, could I use an IORef or something?
09:34:00 <Ariakenom> phadej: running out of entropy is not a thing
09:34:17 <Ariakenom> https://www.2uo.de/myths-about-urandom
09:34:39 <mreh> but if I'm calling getEntropy lots it could block right?
09:34:49 <Ariakenom> well it is with /dev/random but just use urandom
09:37:31 <phadej> entropy uses /dev/urandom
09:38:04 <mreh> right, 'u' being unlimited
09:40:02 <phadej> if one doesn't need particular PRNG then one could just read /dev/urandom; is it correct Ariakenom ?
09:40:25 <Ariakenom> what do you mean?
09:41:21 <phadej> say I make a service which generates passwords, I can just read /dev/urandom; no point of using some PRNG (seeded with data from /dev/urandom?)
09:42:11 <Ariakenom> yeah urandom uses a cryptographically secure PRNG on linux 
09:43:00 <Ariakenom> (and so does /random)
09:43:18 <Ariakenom> note that my info is this article that someone linked around here at some point
09:44:14 <phadej> yeah, I'd like some more credible source
09:44:27 <phadej> and also if one runs programs on non-linux then there's a difference
09:45:03 <phadej> referring to "On Linux, unlike FreeBSD, /dev/urandom never blocks."
09:46:22 <Ariakenom> yeah it may block within like the first second of booting. which seems like the right thing to do and should hopefully be fine
09:48:14 <Ariakenom> ... I thought about how long it would take was in there but I can't find it
09:59:48 * hackage pandoc-citeproc 0.16.0.2 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.16.0.2 (JohnMacFarlane)
10:00:46 <gentauro> is it possible to create `type alias` with context? For example: `type Foo a = (Ord a) => Bar a`?
10:03:32 <gentauro> it somehow can be done with `newtype` like this -> `newtype Foo a = Bar { bar :: (Ord a) => a }` by using the `RankNTypes` pragma
10:03:36 <Solonarv> gentauro: you can write 'type Foo = forall a. Ord a => Bar a'
10:04:44 <gentauro> Solonarv: thx
10:04:56 <lyxia> % type Foo a = Ord a => [a]
10:04:56 <yahb> lyxia: 
10:05:18 <lyxia> % [] :: Foo Int
10:05:19 <yahb> lyxia: []
10:05:36 <Solonarv> oh, that works - I had assumed you'd tried it and gotten an error message
10:08:56 <gentauro> I missed the `RankNTypes` at the top ;)
10:09:33 <inkbottle> [intero] When remaining too long time with messy code; when starting providing types, provide qualified types, where there should be "short". (I try and restart it see if it helps..)
10:09:52 <inkbottle> it did help
10:12:18 * hackage milena 0.5.3.0 - A Kafka client for Haskell.  https://hackage.haskell.org/package/milena-0.5.3.0 (adamflott)
10:15:17 * hackage foldl-exceptions 1.0.0.0 - Exception handling with FoldM  https://hackage.haskell.org/package/foldl-exceptions-1.0.0.0 (chris_martin)
10:23:35 <dminuoso> lyxia: What is that forgetful functor then?
10:24:21 <lyxia> dminuoso: maps a monoid to its carrier
10:24:37 <gambpang> if there are any Turtle users here, is there a way to compute the list of symlinks under a directory without listing the files and using isSymbolicLink (in bash e.g. find . -type l)?
10:24:55 <dminuoso> lyxia: So freeness is directly linked to the amount of information lost then?
10:25:14 <dminuoso> lyxia: I mean what if I forgot just about the unit (turning a monoid into a semigroup)?
10:26:12 <lyxia> you can't forget about a unit...
10:26:47 <lyxia> given a binary operation, there is at most one unit determined by it.
10:27:29 <lyxia> but yes, freeness is relative to what you forget.
10:31:05 <lyxia> I guess the free monoid for a semigroup is still worth thinking about, hmmm...
10:31:49 <lyxia> that's probably Option
10:33:43 <geekosaur> gambpang, that's the only way the OS provides to do it, unless you mean did someone write that for you already
10:37:47 <gambpang> geekosaur: Ok got it.  It looks like there it is not written for me in Turtle itself, but if I'm wrong about that I would love to know!
10:38:42 <dminuoso> lyxia: Oh I think I just understood the missing piece of the puzzle. [] is not considered an Endofunctor, but a Functor from Set to Mon!
10:39:18 <dminuoso> Or Hask -> Mon (the difference seems to be irrelevant here) 
10:40:07 <gambpang> geekosaur: another thing that I don't see in Turtle but seems like a nice-to-have is impure filtering of Shell a, like (a -> m Bool) -> Shell a -> Shell a
10:40:31 <dminuoso> This is exciting now. :)
10:41:06 <geekosaur> gambpang, I don't actually know much about Turtle. I know the OS side of things
10:41:51 <gambpang> geekosaur: it's pretty nice.  I'm using it for the first time atm.
10:46:48 * hackage cursedcsv 0.1.3 - Terminal tool for viewing tabular data  https://hackage.haskell.org/package/cursedcsv-0.1.3 (GershomBazerman)
10:49:17 * hackage lazysplines 0.3 - Differential solving with lazy splines  https://hackage.haskell.org/package/lazysplines-0.3 (GershomBazerman)
11:15:38 <gentauro> btw, anybody going? https://monadic.party/ :)
11:16:26 <gentauro> what better to spend your holidays (june) with Haskell xD
11:18:44 <Solonarv> whoa, I was expecting this to be US-based like every other meetup I hear about
11:19:54 <gentauro> Solonarv: nobody is going to the US while `the orange man` is in charge :P
11:20:39 <gentauro> btw, does anybody know if this makes a new pointer or does it update the previous pointer (ref vs val) -> https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Ptr.html#v:plusPtr
11:20:41 <Solonarv> oof, a bit more than I can afford though
11:20:50 <gentauro> % :t plusPtr
11:20:50 <yahb> gentauro: ; <interactive>:1:1: error: Variable not in scope: plusPtr
11:21:05 <gentauro> % import Foreign.Ptr
11:21:05 <yahb> gentauro: 
11:21:08 <gentauro> % :t plusPtr
11:21:08 <yahb> gentauro: Ptr a -> Int -> Ptr b
11:21:12 <Solonarv> it's a Plain Old Function (tm), so it gives you a new pointer
11:21:23 <gentauro> cool
11:21:37 <Solonarv> a function that just mutates its argument without warning you? what is this, java?
11:21:55 <gentauro> Solonarv: you never know when you FFI :P
11:22:38 <Solonarv> well FFI functions that mutate their arguments should really be imported as 'a -> b -> IO c'
11:23:28 <gentauro> I agree
11:24:11 <gentauro> my lib does `:: (... , ForeignMemoryInterface io) -> ... -> io ()`
11:24:18 * hackage shellwords 0.1.2.2 - Parse strings into words, like a shell would  https://hackage.haskell.org/package/shellwords-0.1.2.2 (PatrickBrisbin)
11:24:36 <Solonarv> presumably that's a wrapper around the 'foreign import' declaration?
11:24:43 <gentauro> but if you trust me, you can `unsafePerformIO . fun` at your app and ake the consequences :P
11:25:36 <gentauro> `class FMI m => ForeignMemoryInterface m where` (`malloc`,`free`,`peek`,`pook`) ;)
11:25:58 <gentauro> so you know that I will only look into your `mem`, nothing else (matters)
11:26:27 <gentauro> btw, my neighbor is singing that song right now. He sings like the programing language that Solonarv mentioned before :o
11:26:28 <Solonarv> 'pook'? that's a funny name.
11:27:50 <gentauro> poke
11:28:03 <gentauro> `peek` = read from me
11:28:04 <gentauro> m
11:28:10 <gentauro> and `poke` = write to mem
11:28:12 <gentauro> e
11:28:33 <Solonarv> ah, that's less funny but makes more sense
11:32:39 <SrPx> Hello. Does anyone have any reference explaining how to check if two terms are equal (for type checking) in a pure type system with equirecursive types?
11:33:30 <lyxia> is that supposed to be decidable
11:43:48 <DasBrain> > bit 5
11:43:51 <lambdabot>  32
11:44:36 <DasBrain> is there a way to reverse that? I want to get the most significant bit (or -1 if no bit is set)
11:46:08 <kadoban> DasBrain: That's the log base 2 (except the -1 part), modulo some off-by-ones.
11:46:30 <DasBrain> :t log2
11:46:31 <lambdabot> error:
11:46:31 <lambdabot>     • Variable not in scope: log2
11:46:32 <lambdabot>     • Perhaps you meant ‘log’ (imported from Numeric)
11:46:34 <DasBrain> :t log
11:46:35 <lambdabot> Floating a => a -> a
11:46:46 <DasBrain> Floating? Nah.
11:47:05 <Solonarv> there's a package somewhere for integer logarithms
11:47:36 <Solonarv> @hackage integer-logarithms
11:47:37 <lambdabot> http://hackage.haskell.org/package/integer-logarithms
11:48:35 <Solonarv> https://hackage.haskell.org/package/integer-logarithms-1.0.2.2/docs/Math-NumberTheory-Logarithms.html#v:integerLog2
11:48:59 <Solonarv> or maybe intLog2, depending on what the input is.
11:50:36 <DasBrain> Integer -> Int
11:53:08 <booku> hello, if I do a runhaskell setup configure, and it tells me dependencies are missing, is there a command to auto-download and install them all?
11:53:49 <Solonarv> booku: that's cabal's job, usually
11:54:12 <booku> Solonarv: okay, so how do I get cabal to do its job? ;)
11:54:53 <Solonarv> 'cabal v2-build' should download & build all needed dependencies and then your package
11:56:00 <booku> cabal v2-build is unrecognized, should I do a cabal upgrade or something?
11:58:19 <Solonarv> what's cabal --version?
12:00:15 <booku> Solonarv: 1.22.7.0
12:00:26 <Solonarv> yeah that's pretty outdated
12:00:29 <zachk> do you have a something.cabal file in the directory
12:00:34 <booku> zachk: yes
12:00:35 <zachk> if so just: cabal install 
12:00:44 <zachk> that will make and install it globally
12:01:04 <booku> zachk: should I do a cabal sandbox init first then?
12:01:22 <zachk> i dont i just break stuff though, you can if you want to :)
12:01:34 <Solonarv> I'd really recommend updating to a less outdated cabal first, then you won't have to futz around with sandboxes
12:01:46 <zachk> if I break stuff bad enough I will just reinstall the haskell platform 
12:01:55 <Solonarv> cabal install cabal-install --constraint='cabal-install >= 2.4'
12:02:01 <Solonarv> ^ should get you the newest version
12:02:15 <DasBrain> ok, popCountDefault had some interesting stuff.
12:02:22 <zachk> but then you have to change the .exe/binary don't you? 
12:02:39 <Solonarv> change what exactly?
12:02:43 <booku> Solonarv: could not resolve dependencies for cabal-install :(
12:02:59 <Solonarv> oh no! uhh...
12:03:05 <Solonarv> out of curiosity, what's ghc --version?
12:03:15 <booku> 7.6.3
12:03:21 <Solonarv> that's also really old
12:03:25 <zachk> thats kind of old as well
12:04:06 <Solonarv> if you're on linux/mac, you can use https://github.com/haskell/ghcup to painlessly get up-to-date ghc+cabal
12:04:31 <booku> okay, should I purge things first?
12:05:03 <Solonarv> remove the system-installed ghc+cabal? probably a good idea just to avoid any crossed wires
12:05:41 <booku> Solonarv: thanks, going to try ghcup!
12:12:10 * bwe searches the name of the function `f [1,2,3,4] 2` that returns [[1,2],[2,3],[3,4]] -- I would call it moving window, but that's not precise. 
12:15:23 <kadoban> bwe: It's in the split package IIRC. chunksOf maybe?
12:15:41 <kadoban> Oh, wait ... no
12:15:44 <geekosaur> no, chunksOf doesn't do that
12:15:46 <kadoban> Sorry, ignore that
12:15:50 <geekosaur> divvy, with permuted parameters
12:16:52 <geekosaur> divvy 2 2 [1,2,3,4] -- I think
12:17:08 <geekosaur> > divvy 2 2 [1,2,3,4]
12:17:11 <lambdabot>  [[1,2],[3,4]]
12:17:19 <geekosaur> hm, no, wrong set of parms
12:17:27 <geekosaur> > divvy 2 1 [1,2,3,4]
12:17:29 <lambdabot>  [[1,2],[2,3],[3,4]]
12:17:41 <cocreature> slidingWindow seems like a significantly better name for that function than divvy
12:18:14 <kadoban> Yeah, sliding window is the general algorithmic technique. But usually you avoid doing O(n*k) work to do that
12:21:55 <bwe> Alright, sliding window seems to fit! Thanks.
12:24:41 <bwe> (But I can't find divvy on hackage nor via hoogle?!)
12:25:00 <binq> sort . nub $ [[x, y] | [x, y] <- (map (take 2) $ permutations [1,2,3,4]), x+1 == y]
12:25:12 <booku> How do I uninstall cabal? I tried removing ghc, stack, but it won't go away! :(    [Solonarv?]
12:25:29 <Solonarv> booku: I don't know, how did you install it originally?
12:26:00 <booku> Solonarv: as is probably clear, I did it a long time ago (~3 years?) and have no memory at all
12:26:13 <Solonarv> what's the output of `where cabal`?
12:26:44 <booku> Is there a 'where' command on ubuntu?
12:27:04 <Solonarv> should be
12:27:08 <booku> do you mean whereis? it returns: cabal:
12:27:13 <booku> that's it
12:27:35 <Solonarv> uh, try `which cabal` then? I haven't used a proper *nix in a while
12:28:09 <adius> Short question: Is there a native Haskell Database?
12:28:10 <booku> Solonarv: yeah, works, it's in ~/.cabal Should I just delete that?
12:28:46 <adius> For a simple internal database it feels like such an overkill to make it work with SQL.
12:28:59 <Solonarv> booku: I think can simply delete that binary, then
12:30:02 <dmwit> The answer to "how do I uninstall cabal" depends a lot on why you want it uninstalled.
12:31:14 <dmwit> Just deleting the binary will make it not available to run any more, but leave all kinds of tidbits lying around in ~/.cabal and ~/.ghc, possibly also in /usr somewhere depending on your cabal config and possibly also in /root somewhere depending on whether you ever mistakenly used sudo cabal or similar.
12:32:04 <Solonarv> nuking ~/.cabal and ~/.ghc is safe, but may result in later having to rebuild packages that would've been cached otherwise
12:32:43 <dmwit> You may want to save ~/.cabal/config before nuking ~/.cabal, in case you want to consult it later to discover what other paths cabal might have stuck things in.
12:35:37 <dmwit> > [[x,y] | x:y:_ <- tails [1..4]]
12:35:39 <lambdabot>  [[1,2],[2,3],[3,4]]
12:36:03 <Ariakenom> nice one
12:36:18 * hackage hapistrano 0.3.9.2 - A deployment library for Haskell applications  https://hackage.haskell.org/package/hapistrano-0.3.9.2 (sestrella)
12:37:52 <dsal> adius: sqlite is my default file format.  I wouldn't say it's "native" but it's got literally billions of deployments and works pretty well.
12:38:17 <adius> dsal: Yeah, that's what I'm currently working with
12:38:44 <dsal> sqlite-simple is working pretty well for me.
12:38:45 <adius> And I find all the solutions to work with SQL in Haskell not really satisfying.
12:38:47 * hackage hierarchical-spectral-clustering 0.2.2.1 - Hierarchical spectral clustering of a graph.  https://hackage.haskell.org/package/hierarchical-spectral-clustering-0.2.2.1 (GregorySchwartz)
12:39:19 <adius> But I want to write Haskell and not SQL 😭
12:39:26 <geekosaur> bwe, as mentioned earlier it's in Data.List.Split, in the split package
12:39:28 <dmwit> > traverse ZipList . take 2 . tails $ [1..4]
12:39:31 <lambdabot>  ZipList {getZipList = [[1,2],[2,3],[3,4]]}
12:39:37 <geekosaur> adius, you and everyone else
12:40:00 <booku> Solonarv: thanks for your help, that worked. do you have an ETH address I can buy you a coffee at?
12:40:09 <adius> So why is there no solution =P. acid-state could work, but I have heard many people complaining about it
12:41:26 <geekosaur> because there are already umpteen other databases that work and designing a new one from scratch and getting it to the point of being usable (haskell doesn't help here if it's to support distributed use, even across processes much less network) is a lot more work than improving nterfaces to existing ones
12:41:29 <dsal> adius: You just have to abstract over that.  Most of my app isn't writing SQL, it's doing stuff like "insertSpool spool ts excuse l"
12:41:51 <DasBrain> Is there an other version of zipWith that uses default values if one of the input lists is exhausted?
12:41:52 <Solonarv> booku: you're welcome. I don't, but thanks for the offer!
12:42:06 <dmwit> DasBrain: malign =)
12:42:17 <booku> Solonarv: cheers :)
12:42:19 <adius> dsal, Yeah, but it's basically impossible to abstract migrations
12:42:38 <adius> And migrations in SQLite really suck
12:42:40 <dmwit> DasBrain: https://hackage.haskell.org/package/these-0.7.6/docs/Data-Align.html#v:malign
12:44:22 <dsal> adius: Ah.  Maybe http://hackage.haskell.org/package/safecopy
12:45:45 <DasBrain> Meh. Not in base.
12:46:06 <dsal> It's hard to get very far with just base.
12:46:15 <dsal> But you can always   (<> repeat default)
12:46:41 <DasBrain> :t (<> repeat False)
12:46:42 <lambdabot> [Bool] -> [Bool]
12:46:58 <Solonarv> well, you need to a) know which of the input lists is shorter or b) be okay with an infinitely-long result
12:47:34 <binq> > sort . nub $ [[x, y] | [x, y] <- (map (take 2) $ permutations [1,2,3,4]), x+1 == y]
12:47:37 <lambdabot>  [[1,2],[2,3],[3,4]]
12:47:39 <DasBrain> or write it myself.
12:47:49 <DasBrain> It could be so easy.
12:48:07 <binq> dmwit: yours is better of course :-P
12:48:25 <DasBrain> > zipWith (/=) [True,True,False,False,True] [True,False,True]
12:48:27 <lambdabot>  [False,True,True]
12:51:03 <dmwit> > [True, True, False, False, True] + [True, False, True]
12:51:05 <lambdabot>  [False,True,True]
12:51:40 <dsal> > let df x = (<> repeat x) in     zipWith (/=) [True,True,False,False,True] (df False [True,False,True])
12:51:42 <lambdabot>  [False,True,True,False,True]
12:51:59 <dsal> Doesn't help you if the other one is the short one, though.
12:52:18 <geekosaur> DasBrain, haskell is not python, base is as *small* as possible, not as large
12:52:26 <dmwit> > [True,True,False,False,True] + ([True,False,True] ++ 0)
12:52:26 <DasBrain> addField [] [] = []; addField [] bs = bs; addField as [] = as; addField (a:as) (b:bs) = (a /= b) : addField as bs
12:52:28 <dsal> heh, base seems pretty large.
12:52:28 <lambdabot>  [False,True,True,False,True]
12:53:26 <booku> So what do I do when cabal can't resolve dependencies? I cloned this package https://hackage.haskell.org/package/Persistence ; ran cabal v2-build
12:53:32 <geekosaur> base is wired into the compiler in various ways, so it can only be upgraded by upgrading ghc
12:53:42 <zachk> booku did you upgrade cabal and ghc yet?
12:53:46 <booku> It gave me this error "(constraint from non-upgradeable package requires installed instance)", dunno if this is the relevant one
12:53:49 <booku> zachk: yes, all done
12:55:20 <dmwit> asjo: You might also like my first two comments on https://stackoverflow.com/a/50702253/791604
12:55:24 <dmwit> uh
12:55:26 <dmwit> DasBrain: ^
12:59:00 <booku> here's the error in full, if someone is willing to look: https://paste.ofcode.org/4F6EZzeBLnP2LWguRn7J4B
12:59:21 <DasBrain> > take 5 $ iterate (False:) []
12:59:24 <lambdabot>  [[],[False],[False,False],[False,False,False],[False,False,False,False]]
13:00:16 <Solonarv> booku: you need `base` between 4.9 and 4.11; ghc 8.6 (which is what you have installed) comes with base 4.12
13:00:34 <Solonarv> downgrading to ghc 8.4 should make it work
13:00:36 <aplainzetakind> I have a function which doesn't make sense for negative input (integral). If I make the argument Natural, users of my function would need to import naturals, or I could check and throw an error. What's a good choice here? Is it best to use and also reexport naturals?
13:01:14 <Solonarv> (ghcup was in part made exactly for this sort of situation: it lets you have multiple ghcs installed without huge pain)
13:01:22 <booku> Solonarv: should I try editing the build-depends?
13:01:23 <booku> Solonarv: oh
13:01:51 <booku> and how does it solve the sandbox problem, I think someone mentioned, that you don't need to bother with sandboxes anymore?
13:02:18 <Solonarv> I mentioned that, yes
13:02:37 <Solonarv> basically it's smarter about how it manages multiple versions of the same package
13:03:19 <booku> Solonarv: okay, so that happens automatically, and I can go around installing whatever willy-nilly?
13:03:20 <aplainzetakind> Solonarv: does ghcup manage any packages? Isn't what you said a function of Cabal 2.x?
13:03:48 <Solonarv> you can read the cabal docs at https://cabal.readthedocs.io (section "nix-style local builds") for more info
13:04:09 <Solonarv> aplainzetakind: ghcup doesn't manage any packages, I was talking about cabal v2 functionality
13:04:34 <Solonarv> (well I suppose in some sense ghcup "manages" ghc and cabal-install, but that's it)
13:04:43 <aplainzetakind> Oh OK, "it" was cabal.
13:06:38 <Solonarv> booku: note that you need to be using the v2-* commands to use the new nix-style builds; they're not the default yet
13:10:12 <booku> v2-* and new-* are the same, yes?
13:12:16 <Solonarv> yes
13:18:30 <gentauro> why does `plusPtr` have another type when adding an `offset`? -> `plusPtr :: Ptr a -> Int -> Ptr b`. Kind of annoying :(
13:20:55 <Solonarv> gentauro: there's nothing preventing 'a' and 'b' from being the same
13:23:05 <gentauro> `Could not deduce (Storable a0) arising from a use of ...`
13:23:21 <gentauro> :(
13:23:28 <ClaudiusMaximus> :t Foreign.advancePtr
13:23:29 <lambdabot> Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> Int -> GHC.Ptr.Ptr a
13:23:46 <ClaudiusMaximus> one works in bytes, one in items, iirc
13:23:52 <ClaudiusMaximus> check the docs
13:26:27 <gentauro> ClaudiusMaximus: I'm not interested in getting an array
13:26:35 <monochrom> gentauro: I would like that type change if I started with x = Ptr MyRecordType and I used "x `offset` 3000" to access Ptr My2000thFieldType.
13:27:45 <gentauro> monochrom: so how do you define you `type signature`? I mean, I have bounded it to `Storage a`
13:28:22 <monochrom> WTF is "Storage a"?
13:28:40 <gentauro> primitive types that can be stored as `bytes`
13:28:50 <gentauro> http://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html
13:29:08 <gentauro> so if you provide a `Word`, it "should" work
13:29:16 <gentauro> and if you provide `Int` it should work as well
13:29:24 <monochrom> I can't reproduce your error message?
13:29:49 <gentauro> fair enough
13:29:55 <gentauro> I can't compile my code ...
13:29:59 <monochrom> And "Storable" is not "Storage"?
13:30:14 <monochrom> And "Storable" is not a type?
13:31:08 <gentauro> `Storable` is context
13:31:24 <gentauro> `foo :: (Storable a) -> Ptr a -> ...`
13:31:59 <gentauro> and yeah, I wrote wrong, but linked correctly (to late)
13:36:39 <geekosaur> so you use something else to constrain it
13:36:41 <geekosaur> :t asTypeOf
13:36:43 <lambdabot> a -> a -> a
13:41:01 <gentauro> geekosaur: that helped. thx
13:56:47 * hackage leancheck 0.9.1 - Enumerative property-based testing  https://hackage.haskell.org/package/leancheck-0.9.1 (rudymatela)
14:06:17 * hackage rss-conduit 0.4.3.1 - Streaming parser/renderer for the RSS standard.  https://hackage.haskell.org/package/rss-conduit-0.4.3.1 (koral)
15:06:20 <adius> Hi, I'm not getting any warnings for `let` variables which are not used, altough I've set `-Wall`. Any ideas?
15:07:12 <merijn> adius: How are you building the code?
15:07:23 <adius> `stack build`
15:07:44 <merijn> Ah, then my ideas don't apply :p
15:07:56 <merijn> adius: Are you sure it's actually building?
15:09:26 <adius> Yeah 😂. My tests failed and the bug was that I forgot to use a `let` variable I defined. I fixed it and now everything works. But I'm really surprised why I wasn't warned about it
15:10:28 <Welkin> where did you set this ghc-option?
15:10:31 <Welkin> in your cabal file?
15:10:34 <Welkin> does stack ignore that?
15:11:05 <Welkin> maybe it uses its own settings from stack.yaml
15:11:06 <Welkin> who knows
15:11:13 <adius> https://www.irccloud.com/pastebin/nLWpJ6Xk/package.yaml%20excerpt
15:11:25 <Welkin> what is package.yaml?
15:11:29 <merijn> Welkin: hpack
15:12:01 <merijn> Stack for some misguided reason defaults to automatically calling hpack causing people to actually use it >.>
15:12:03 <Welkin> if you just use cabal you will very likely have fewer issues
15:12:16 <Welkin> stack is obsolete
15:12:33 <Welkin> it also adds much more complexity than necessary
15:12:36 <adius> I rarely have issues, and this doesn't look like a stack problem anyways
15:12:36 <merijn> As much as I like cabal-install, I don't think telling people to completely switch build tools is particularly helpful
15:12:59 <merijn> adius: I would strongly recommend moving away from package.yaml and hpack usage, though
15:13:24 <adius> YAML instead of this weird .cabal format is enough reason to stay ^^
15:13:30 <Welkin> what?
15:13:48 <Welkin> they are basically the same thing
15:13:55 <Welkin> except yaml can break way more easily
15:14:43 <adius> Except .cabal is some ad-hoc hacked together language. YAML is complex, but at least it has a proper language specification
15:14:58 <merijn> The cabal format does have a spec though?
15:15:04 <merijn> It's actually rather trivial too
15:15:12 <Welkin> cabal format is way simpler than yaml
15:15:32 <adius> Sure, in code, but nothing official (at least nothing I'm aware of
15:15:39 <hpc> yaml has the most ridiculous nonsense
15:15:50 <Welkin> I stay away from yaml whenevr possible
15:15:55 <Welkin> it's bitten me too many times
15:16:04 <hpc> if we were going to pick an existing format, i'd use json and learn to write quotes and braces like some sort of a....
15:16:07 <hpc> programmer
15:16:09 <merijn> adius: Like https://cabal.readthedocs.io/en/latest/developing-packages.html#pkg-desc ?
15:16:33 <adius> I only use YAML core, and config files are no user input, so it's OK
15:16:34 <Welkin> hpc: I'd use lua
15:16:46 <Welkin> tables
15:16:53 <Welkin> or lisp
15:17:28 <adius> ANYWAYS … didn't want to start a build tool war here. Can anyone help me with my original question? 😅
15:17:34 <merijn> adius: Anyway, if you insist on using package.yaml, please commit the produced cabal file to your repo. Nothing's annoying as trying to fix an upstream package and realising I can't even build it without extra tooling :)
15:17:49 <adius> I'm using GHC 8.4, is this a problem?
15:18:01 <merijn> adius: Well, like I asked: Are you sure it's actually building anything?
15:18:30 <merijn> adius: i.e. did it produce warnings once in the past and then never rebuild due to lack of changes (and thus not producing warnings)
15:18:39 <adius> It's building everything and it's working like it should, buuut I don't get a warning if I randomly but let expressions into the code
15:18:40 <Welkin> you can always invokes ghc directly with the options, or better yet try building with cabal-install
15:18:41 <merijn> That's tripped me up a few times
15:19:15 <kadoban> adius: Try changing something in the file just to be sure it's actually building the file in question, and doesn't have it cached?
15:22:08 <kadoban> adius: What about 'stack build --pedantic' , by the way?
15:25:38 <adius> Are we actually sure that GHC warns about unused `let`s ? 😳
15:26:16 <adius> `--pedantic` just give me a few extra orphans warnings, but otherwise the same
15:27:07 <Welkin> you can eithr keep trying the same thing expecting a different result, or you can try building it with cabal or ghc directly
15:27:18 <Welkin> -fwarn-unused-binds or -Wall will warn you
15:27:35 <kadoban> "a few extra orphans warnings" sounds like it's actually taking effect (it's short for -Wall and -Werror), so if you're getting different output, they weren't taking effect before for sure
15:28:12 <kadoban> adius: Have you looked in the .cabal file by the way, made sure the ghc-options are making it into there? I don't see why they wouldn't, but ...
15:28:46 <Welkin> writing a configuration file to generate your configuration file is the most ridiculous thing I have heard all day
15:29:10 <kadoban> Any chance you can get over the tooling thing any time soon? You realize that's just offputting, right?
15:35:21 <adius> kadoban: Yeah, they make it to .cabal, and the orphan warnings came because I had them disabled otherwise.
15:35:21 <adius> *sigh*, I have all warnings enabled. Believe me. 
15:36:23 <adius> Can anyone post a snippet how a warning about an unused let variable looks like? I'm starting to doubt that this is actually a thing.
15:38:18 <kadoban> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wunused-binds I found these, if they help. But ya, they should be set by -W for sure, and especially by -Wall
15:38:46 <kadoban> adius: So the ghc-options: syntax ... it does need the - in -Wall right? Probably stupid suggestion, but what if you remove that?
15:39:05 <kadoban> I'd really imagine *something* would be complaining if it were wrong, but I'm fairly stumped myself otherwise.
15:40:39 <Solonarv> unused.hs:1:12: warning: [-Wunused-local-binds]
15:40:39 <Solonarv>     Defined but not used: `unused'
15:41:04 <Solonarv> the contents of unused.hs are just 'main = let unused = 42 in putStrLn "hello"'
15:43:56 <zachk> I believe I read somehwere once, -Wall is not all warnings , might be wrong though
15:44:42 <kadoban> It's not all possible warnings, but it does seem to include the one(s) in question, if I'm reading the docs right (my most recent link a few lines above)
15:46:12 <kadoban> Or wait, I didn't link the thing I mean: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html that shows what -W and -Wall mean
15:46:44 <jjb> for cryptographic algorithms, it is sometimes important to have an operation complete in constant time. i'm trying to make a constant-time if/then in haskell. assuming the evaluation of the parameters is strict, does this seem legit to you more experienced than i?
15:47:01 <adius> Ok I'm really confused. When I use ghcid I get the warnings. So it's indeed something with stack
15:47:06 <jjb> constantTimeChoose v a b = mappend (if v then a else mempty) (if not v then b else mempty)
15:47:24 <adius> But ghcid also runs stack, so not sure what it does differently 🙈
15:48:24 <zachk> different options maybe?
15:48:53 <merijn> zachk: -Wall in GHC (unlike gcc's -Wall) is all warnings you should have. The (very few) not in -Wall are very debatable warnings
15:52:33 <adius> When I run `stack ghci` it also works, but not when I run `stack build`. What the heck?
15:53:52 <kadoban> Sounding really bizarre
15:58:15 <MarcelineVQ> how do you run ghcid
15:58:48 <jackdk> `ghcid -c 'cabal new-repl target'`
15:59:13 <MarcelineVQ> oop. how do you run ghcid, adius?
15:59:58 <adius> `$ ghcid` and it says  `Loading stack ghci --test --ghci-options=-fno-code ...`
16:00:23 <MarcelineVQ> does stack exec ghcid do anything differently?
16:01:02 <MarcelineVQ> or better: stack build ghcid && stack exec ghcid
16:01:26 <adius> `stack exec ghcid` is the same
16:09:22 <dibblego> foldl is to fold1 as minimum is to ?
16:11:07 <adius> I got no more ideas. I'll get some sleep and if I got no more ideas tomorrow I'll open an issue in the stack repo. Thanks for everyones help so far!
16:11:40 <kadoban> dibblego: minimumDef from the safe package?
16:12:27 <dibblego> kadoban: yeah I was hoping for Foldable1 instead, but I think it might not exist. Fortunately I have a libraries guy next to me.
16:12:39 <jackdk> dibblego: there's Foldable1 in semigroupoids
16:12:45 <jackdk> http://hackage.haskell.org/package/semigroupoids-5.3.2/docs/Data-Semigroup-Foldable.html
16:13:19 <dibblego> jackdk: right, but I was looking for something like minimum1 = foldl1 min; I realise it's trivial, but I'm trying to help out someone else who is confused, and it would help with explanation. No biggie.
16:13:40 <jackdk> ahyep.
16:17:07 <jake> Hi all :) 
16:17:26 <Solonarv> hi jake!
16:17:32 <dmwit> dibblego: http://hackage.haskell.org/package/monoid-extras-0.5/docs/Data-Monoid-Inf.html#v:minimum
16:17:51 <dmwit> dibblego: But I think you got your relation backwards.
16:18:05 <dmwit> dibblego: foldl1 is to foldl as minimum is to what I linked.
16:18:17 <dibblego> dmwit: oh great thanks
16:21:10 <dmwit> For a beginner, I think I might prefer a slight tweak on kadoban's suggestion: https://hackage.haskell.org/package/safe-0.3.17/docs/Safe.html#v:minimumMay
16:22:08 <dmwit> Phantom types + pre-DataKinds data kinds as in monoid-extras might just muddy the explanation, unless your misdirection skills are v. v. good.
16:23:08 <dmwit> (But for the advanced user, PosInf and NegInf are better because one of their Ord instances is better. I can't remember which, and that's kind of the point.)
18:35:05 <iqubic> I finally understand what DataKinds does. I was just thinking about it and I had a wonderful epiphany.
18:36:57 <benzrf> :)
18:38:19 <maerwald> data kinds is like sugar
18:38:31 <maerwald> destroys the gut barrier
18:38:45 <maerwald> so now you have value level and type level mixed up
18:40:05 <iqubic> maerwald: Doesn't DataKinds mix types and kinds?
18:40:21 <maerwald> see, I'm already confused
18:40:36 <maerwald> -XLessGHCExtensions
18:41:05 <iqubic> Speaking of extensions, what the heck does -XPolyKinds do?
18:43:36 <benzrf> kind polymorphism :-)
18:43:55 <iqubic> Why do we need that?
18:44:10 <benzrf> https://downloads.haskell.org/~ghc/7.8.1/docs/html/users_guide/kind-polymorphism.html
18:44:15 <benzrf> check out the first heading
18:44:50 <benzrf> :k Typeable
18:44:52 <lambdabot> k -> Constraint
18:45:22 <benzrf> w/o polykinds, that would have to be * -> Constraint or (* -> *) -> Constraint or something similar
18:45:26 <benzrf> as described on that page
19:09:16 <maerwald> what is foldr' good for?
19:14:24 <MarcelineVQ> iqubic: in a sentence what does DataKinds do?
19:15:58 <Solonarv> maerwald: for when you want to strictly consume an infinite list? ;)
19:17:58 <maerwald> sounds... useful
19:35:33 <nilOps> i'm working my way through typeclassopedia and i'm having trouble figuring out a proof for `pure f <*> x = pure (flip ($)) <*> x <*> pure f`
19:35:37 <nilOps> anyone have a hint?
19:40:01 <pacak> expand flip, look at type signature of <*>
19:40:09 <pacak> and pure
19:42:06 <iqubic> in fact, just rewrite (flip ($)) with a lambda that contains only no use of flip or of '$'
19:46:38 <glguy> nilOps: did you figure it out?
19:47:45 <maerwald> uhm, can brackets change evaluation order??
19:48:16 <Solonarv> if they're not redundant, maybe?
19:48:22 <maerwald> they are redundant
19:48:55 <Solonarv> huh. What's the example?
19:48:58 <pacak> maerwald:  1+2*3 is different from (1+2)* 3
19:49:25 <pacak> And if you are doing something strange with fixity and priorities - it might be not obvious.
19:49:30 <maerwald> https://gist.github.com/hasufell/fb2913e291f2693c8b8e79d4cef72e48
19:49:57 <maerwald> yeah, could be something with <$!>
19:51:03 <pacak> maerwald: function application binds tighter than <$!>, no?
19:53:08 <maerwald> the result is still quite confusing
19:53:17 <pacak> 'trace "bind" (trace "insert" $ insert x) <$!> b' is 'trace "bind" (trace "insert" $ insert x)) <$!> b'
19:55:53 <maerwald> for some reason I cannot force insert to interleave with the action
19:56:04 <maerwald> even with strict <$!>
20:03:48 <Majorhacker> Hi
20:04:21 <glguy> Hi
20:07:02 <nilOps> oh sorry, got pulled away for a sec. i think i follow the types, but i'm still not sure how to prove the interchange law using other applicative laws
20:08:14 <glguy> You don't have to prove interchange, you get it
20:09:08 <nilOps> it seemed like that was the implication by `fmap g x = pure g <*> x`. but i don't really understand why
20:09:34 <nilOps> (but thanks for confirming that glguy, was kinda unsure about it)
20:09:49 <glguy> I imagine you've looked at http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Applicative
20:10:12 <nilOps> brb reading
20:20:56 <jackdk> nilOps: it's when you are implementing an instance of a class that you need to ensure that your implementation follows the laws, because they form part of the contract people expect from the class
20:24:17 <nilOps> Hmm, I think i'm over thinking it; i thought we got interchange for free by virtue of applicative being a functor, but seems like its just what we define an applicative to be?
20:28:48 <nilOps> ohh wait... i just misread the page :/
20:30:48 * hackage bytestring-to-vector 0.3.0.0 - Convert between ByteString and Vector.Storable without copying  https://hackage.haskell.org/package/bytestring-to-vector-0.3.0.0 (SvenHeyll)
20:38:53 <maerwald> https://gist.github.com/hasufell/418f7ffaa50846a46cb1cb7d2712ea27 why is there no way to make the second forM implementation strict in so far that insert would happen incrementally?
20:41:54 <maerwald> using <$!> over <$> does change something, but doesn't actually make insert incremental
20:54:17 * hackage bytestring-to-vector 0.3.0.1 - Convert between ByteString and Vector.Storable without copying  https://hackage.haskell.org/package/bytestring-to-vector-0.3.0.1 (SvenHeyll)
20:56:17 <glguy> :t \f -> foldM (\s x -> do y <- f x; return $! Data.Set.insert y s) Data.Set.empty
20:56:19 <lambdabot> (Ord a, Monad m, Foldable t1) => (t2 -> m a) -> t1 t2 -> m (S.Set a)
20:56:31 <glguy> maerwald: Is that closer to what you're trying to do?
20:56:49 <maerwald> glguy: doesn't answer my question though
20:56:56 <glguy> What's the question?
20:57:00 <maerwald> I know how to write a strict version as seen in the paste
20:57:20 <maerwald> the fmap is strict, so why is insert not evaluated
20:58:07 <Solonarv> just spitballing, but perhaps you need deepseq?
20:58:30 <glguy> deepseq doesn't really fit in there
20:58:51 <glguy> maerwald: What's an example that you're using that shows it doesn't insert?
20:59:15 <maerwald> glguy: that's not what I meant, the insert is not incremental
20:59:47 <glguy> OK, what's some code that shows that it's not "incremental"
20:59:52 <glguy> I don't understand the issue
20:59:54 <maerwald> the paste
21:00:26 <maerwald> if you run it, you will see that it doesn't interleave
21:00:36 <maerwald> insert is done after all monad actions are run
21:00:38 <glguy> Run what? The paste just has 3 functions
21:01:01 <maerwald> Bar.forM (fromList [1,2,3]) (\x -> putStrLn "lol" >> pure (x + 1))
21:01:21 <glguy> maerwald: The definition of <$!> is that the value is sequenced *after* the action produces a result
21:01:31 <glguy> err, evaluated/forced
21:01:50 <maerwald> yes, but insert happens after ALL actions are run 
21:01:51 <glguy> and because you used foldr, the 'b' is the whole remaining action
21:02:08 <glguy> so the outermost insert has to happen after all the other actions have run
21:02:15 <maerwald> ah
21:03:05 <glguy> With something like: \f -> foldM (\s x -> (`Data.Set.insert` s) <$!> f x) Data.Set.empty
21:03:15 <glguy> The insert happens right after the action (f x)
21:04:49 <maerwald> and in the other foldr we don't fmap into an action
21:05:04 <glguy> well, it's still "an action" but it's not a single one
21:05:24 <glguy> it's the action that is the composition of all the remaining ones (I think that's what you understood, just restating)
21:05:53 <maerwald> yes, it runs all actions and then "bounces" back inserting
21:07:55 <maerwald> but it builds the list regardless of whether the value is looked at, so there is a slight difference between <$> and <$!> here
21:08:14 <maerwald> in ghci it can be seen that it starts running the show instance of Data.Set and then inserts
21:08:28 <maerwald> for normal fmap
21:09:16 <glguy> > show (undefined :: Data.Set.Set Int)
21:09:18 <lambdabot>  "fromList *Exception: Prelude.undefined
21:09:33 <glguy> You don't learn much from that, however. As you can see the show implementation doesn't force anything at all to print the first few characters
21:09:45 <glguy> so just the fact that GHCi knew it was showing a Set was enough to get started
21:30:30 <jgt> how can I format a number like `8.11-2 :: Fractional a => a` as "0.08"?
21:30:47 <jgt> sorry, that should be 8.11e-2
21:33:35 <MarcelineVQ> have a look at the options in Numeric such as showFFloat
21:34:22 <jgt> MarcelineVQ: ah, that's helpful. Thanks.
21:34:30 <jgt> Looks like I can do `showFFloat Nothing 8.11e-2 ""`
21:34:32 <MarcelineVQ> in that particular case showFFloat (Just 2) 8.11e-2 "" would work
21:35:01 <jgt> (Just 2) is even better!
22:19:09 <Camdar> Is there a good way to derive Show1 instances for types of kind (* -> * -> *) ?
22:19:22 <Camdar> template haskell is not cooperating with me and I can't seem to find anything on google
22:20:01 <Camdar> (specifically, I have some type T a b, and I want to make a Show1 instance for T a, but ghc isn't liking it)
22:21:02 <slack1256> Generics?
22:21:33 <Camdar> I'm not using Generics, should I be?
22:23:06 <johnw_> Camdar: have you tried: http://hackage.haskell.org/package/deriving-compat-0.3/docs/Text-Show-Deriving.html
22:23:17 <Camdar> I've been staring at this documentation for hours
22:23:36 <Camdar> I've tried variations of $(deriveShow1 ''T) and $(deriveShow1 ''(T a)) etc
22:23:42 <johnw_> example: https://github.com/haskell-nix/hnix/blob/pending/src/Nix/Expr/Types.hs#L453
22:23:43 <AfC> Do you mean deriving (..., Show1, ....) doesn't work?
22:23:54 <johnw_> no, you need template haskell to use deriving-compat
22:24:19 <johnw_> but maybe deriving (Show1) could work, if you try DeriveAnyClass
22:24:58 <Camdar> johnw_++
22:25:03 <Camdar> (is that how to do it?)
22:25:11 <Camdar> thanks! DeriveAnyClass worked
22:25:14 <johnw_> nice
22:25:17 <johnw_> it's awesome when it works
22:25:28 <coldpress> how hard is it to write Template Haskell for GADTs?
22:25:48 <johnw_> no harder than anything else, I'd think
22:51:48 * hackage skylighting-modding 1.0.0.0 - Utilities for modifying Skylighting syntaxes  https://hackage.haskell.org/package/skylighting-modding-1.0.0.0 (chris_martin)
22:52:48 * hackage pandoc-highlighting-extensions 1.0.0.0, skylighting-extensions 1.0.0.0 (chris_martin): https://qbin.io/sake-rated-fubb
22:52:49 <dminuoso> Given F |- U with F :: D -> C and U :: C -> D, I have read statements like "For some object x from D and y from C, there exists a natural isomorphism between `F x -> y` and `x -> U y`"
22:53:15 <dminuoso> My question is, what does "natural isomorphism" even mean when the functors involved are flipped in their domain/codomain?
22:53:33 <dminuoso> Or was that playing fast and lose with terminology?
22:54:31 <dminuoso> I would understand a natural isomorphism saying `η :: F => U` but that's clear saying something different.
22:56:01 <johnw_> I believe that a natural isomorphism here means that the two homsets are isomorphism, natural in x and y
22:59:16 <dminuoso> johnw_: Okay I guess this is only approachable if you look at the 2-category above, so you can even talk about homsets?
22:59:40 <johnw_> I mean the homsets F x -> y and x -> U y
23:00:45 <johnw_> the fact that it's a natural isomorphism gives rise to four equalities
23:01:12 <johnw_> example: |f ∘ fmap[F] g| = |f| ∘ g
23:01:25 <johnw_> where |x| is the forward projection through the isomorphism
23:01:37 <johnw_> all four are given here: https://github.com/jwiegley/category-theory/blob/master/Theory/Adjunction.v#L47
23:06:22 <dminuoso> johnw_: Mmm, is that Coq code?
23:06:29 <johnw_> yes
23:06:52 <johnw_> I have proofs for five different ways, so far, of formulating adjunctions
23:07:39 <dminuoso> johnw_: Ah I see, so essentially this just amounts to saying hom(F x, y) ~= hom(x, U y)
23:07:52 <johnw_> exactly, ∀ x y
23:14:07 <dminuoso> johnw_: Mind my asking, what does the naturality condition mean then?
23:15:28 <johnw_> because this is an isomorphism between functors, the naturality condition arises from the functoriality
23:15:44 <johnw_> as Wikipedia says: "In order to interpret Φ as a natural isomorphism, one must recognize homC(F –, –) and homD(–, G –) as functors. In fact, they are both bifunctors from D^op × C to Set (the category of sets)."
23:16:15 <dminuoso> johnw_: Ah, so its a naturality condition between the hom functors.
23:16:30 <dminuoso> Gotcha. :)
23:16:46 <johnw_> yes, the isomorphism can't change the functoral nature
23:20:27 <dminuoso> johnw_: https://en.wikipedia.org/wiki/File:Natural_phi.svg this seems like it might help. :)
23:20:45 <johnw_> yep
23:25:40 <coldpress> why doesn't DataD in Template Haskell have a record type? passing in 5 underscores is so troublesome
23:25:56 <johnw_> DataD {}?
23:29:03 <johnw_> dminuoso: also Wikipedia: "If, for every object X in C, the morphism ηX is an isomorphism in D, then η is said to be a natural isomorphism (or sometimes natural equivalence or isomorphism of functors). Two functors F and G are called naturally isomorphic or simply isomorphic if there exists a natural isomorphism from F to G."
23:32:18 <dminuoso> johnw_: Right, for `F -| U` I was originally looking for a natural transformation ηX : F X -, but that didn't make sense since they mismatched in cod/dom.
23:32:21 <dminuoso> oops, that should have been `ηX : F X -> U X`
23:33:08 <dminuoso> johnw_: I was reading https://www.reddit.com/r/haskell/comments/2znhjk/what_is_the_difference_between_free_monads_and/cpkt6je for reference.
23:33:43 <johnw_> ah, right, that would be something else
23:34:14 <johnw_> you only get X -> U (F X) and F (U X) -> X
23:34:33 <johnw_> or, Id => U . F and F . U => Id
23:34:35 <dminuoso> johnw_: Yeah, and I just couldn't see where you'd get to naturality from that (without thinking about hom functors). :)
23:34:51 <johnw_> sometimes, coming to clarity through confusion is the best way
23:35:27 <dminuoso> johnw_: What does => denote here?
23:35:38 <johnw_> natural transformation
23:35:50 <johnw_> I use ⟹ in my source
23:49:47 <maerwald> is there a good reporting framework in haskell, which you could use in your backend to push errors to and then decide in the framework configuration what will happen with it? (e.g. create emails or send to slack or ...)
23:54:05 <maerwald> basically like django
