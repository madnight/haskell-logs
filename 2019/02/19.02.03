00:00:21 <Athas> q6AA4FD: yes, but the drawing here should be pure.  You should do the IO in the function that creates/updates the state.
00:00:30 <Athas> Probably the appHandleEvent function.
00:00:39 <Athas> That one does run in a monad transformer stack that has IO at the bottom.
00:05:15 <q6AA4FD> i don't understand what you mean about the monad transformer stack, but i need to IO somewhere in the process. are you saying that i can fit IO into appHandleEvent? if so, could you go into more detail, i don't really see how. i understand that EventM has IO in it, but i can't tell how i'd access that.
00:07:04 <Athas> q6AA4FD: EventM is an instance of MonadIO, which has a 'liftIO' method.  Specialising the type for EventM, it has type 'IO a -> EventM a'.
00:07:15 <Athas> So with 'liftIO' you can perform arbitrary IO inside the EventM monad.
00:09:58 <q6AA4FD> Athas: so if i run liftIO (ioState) >>= continue at the event handler, i can get IO into the state
00:19:25 <Athas> q6AA4FD: yes.
00:26:56 <q6AA4FD> Athas: alright, i just got it working. i really appreciate your help, thank you very much.
00:28:15 <Athas> Have fun!
00:34:58 <wefkl> Whenever I install new package with cabal new-install, it keeps telling me
00:35:01 <wefkl> "cabal: symlink-bindir is not defined. Set it in your cabal config file or use --symlink-bindir=<path>"
00:35:24 <wefkl> and in fact I can't use the package (simple-reflect) within ghci
00:35:37 <wefkl> What do I do?
00:35:58 <wefkl> The package installs fine both with cabal install and new-install
00:36:12 <glguy> You can load a ghci with that library with: cabal v2-repl --build-dep simple-reflect
00:36:12 <wefkl> but cannot be found by ghci no matter what way I use
00:36:27 <glguy> new-install is really only for executables at this point, it's not for getting libraries available with ghci
00:36:40 <glguy> I'm surprised that 'cabal install simple-reflect' didn't work out
00:37:00 <wefkl> cabal v2-repl --build-dep simple-reflect    results in
00:37:12 <wefkl> Build profile: -w ghc-8.6.3 -O1 In order, the following will be built (use -v for more details):  - fake-package-0 (lib) (first run) Configuring library for fake-package-0.. Preprocessing library for fake-package-0..
00:37:30 <wefkl> Prelude> import SimpleReflect  <no location info>: error:     Could not find module ‘SimpleReflect’     It is not a module in the current program, or in any known package.
00:37:41 <wefkl> I feel it's some sort of path issue, but idk
00:37:45 <glguy> what version of cabal-install ?
00:37:58 <wefkl> 2.4.1.0
00:38:19 <glguy> import Debug.SimpleReflect
00:38:23 <glguy> http://hackage.haskell.org/package/simple-reflect
00:38:54 <glguy> Importing the wrong module is a good reason that it won't work with any of the methods :)
00:39:11 <wefkl> oh that worked
00:39:46 <wefkl> yes
00:40:00 <wefkl> thank you
02:07:29 * hackage imm 1.4.0.0 - Execute arbitrary actions for each unread element of RSS/Atom feeds  https://hackage.haskell.org/package/imm-1.4.0.0 (koral)
02:35:07 <joehh> I remember a blog post or a package that permitted calculation of multiple statisitcs (as monoids?) via applicatives. Does anyone have a link or reference like that?
02:36:04 <joehh> reason is I have a map with some data in it and am currently performing 15 "loops" over it to calculate various statistics, and I'm sure a more efficient process exists
02:37:08 <joehh> "loops" are currently done with travese and a prism, then calculating the length of the remaining structure
02:39:40 <dmwit> If there is a function for each statistic that takes a single data point and returns a suitable monoid that summarizes the data point, then you can do that with
02:39:43 <dmwit> :t foldMap
02:39:45 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
02:40:34 <joehh> that is the idea - is there a way to then do all of the stats in one pass?
02:40:42 <joehh> I'm kind of thinking something like:
02:40:49 <dmwit> Yes, monoids combine pointwise.
02:41:03 <dmwit> > ("abc", Sum 3) <> ("def", Sum 5)
02:41:05 <lambdabot>  ("abcdef",Sum {getSum = 8})
02:41:06 <joehh> foldMap ((,,,) <$> calcMin <*> calcMax <*> etc...)
02:41:40 <joehh> that is obviously very incorrect, but hopefully conveys the idea  I'm trying to acheive
02:41:50 * dmwit nods
02:42:46 <dmwit> I wouldn't try anything fancy, personally. Just define a record that contains all the stat monoids you care about, write a pointwise Monoid instance for it by hand, and write a single super-function by hand that produces each field with your various single functions.
02:43:08 <dmwit> allStats x = Stats { statMin = calcMin x, statMax = calcMax x, ... }
02:43:10 <joehh> I think you are right, I'll give that a go - thanks
02:44:13 <dmwit> But your (,,,) thing would probably work just fine too.
02:44:33 <clever> :t (,,,)
02:44:35 <lambdabot> a -> b -> c -> d -> (a, b, c, d)
02:44:43 <clever> ah, neat
02:45:01 <joehh> one of my favourite tricks with applicatives
02:45:29 <dmwit> > mempty :: (String,String,String,String) -- do we have Monoid instances for longer tuples?
02:45:31 <lambdabot>  ("","","","")
02:45:34 <dmwit> guess so =)
02:45:59 <clever> > mempty :: String -- maybe its automatic, based on the contents?
02:46:01 <lambdabot>  ""
02:59:03 <merijn> clever: The monoid instance for tuples is just pointwise mappend with mempty being the mempty of each element
02:59:30 <merijn> clever: Tuples with more than 2 elements sometimes just lack instances because of politics...
03:00:21 <clever> i cant remember which library it was, but they had added their own Singleton type, because haskell doesnt allow a tuple of 1 item
03:00:33 <clever> (String) is just String, and not a tuple
03:00:43 <mreh> seems kind of redundant
03:00:45 <dmwit> ?hackage OneTuple
03:00:45 <lambdabot> http://hackage.haskell.org/package/OneTuple
03:01:06 <clever> mreh: the package accepted tuples of various lenghts, based on the needs
03:01:18 <clever> but String isnt a tuple, and the type-system gets upset
03:02:29 <mreh> clever: gotcha
03:02:59 <mreh> Are these RNGs suitable for reset tokens? https://hackage.haskell.org/package/cryptonite-0.25/docs/Crypto-Random.html
03:03:29 <mreh> I remember StdGen used to block when your system was running out of entropy.
03:04:11 <mreh> I definitely don't want that.
03:04:59 <clever> mreh: depends on if it reads /dev/random, /dev/urandom, or uses the newer entropy syscall
03:05:05 <clever> only /dev/random will block, i believe
03:05:11 <mreh> clever: yeah
03:05:23 <dmwit> Are you sure you remember that correctly?
03:05:25 <merijn> argh
03:05:33 <mreh> dmwit: it was a while ago
03:05:36 <merijn> "running out of entropy" is not a thing
03:05:55 <mreh> merijn: running low on entropy?
03:06:01 <merijn> StdGen isn't a CPRNG anyway
03:06:16 <merijn> mreh: That's not a thing and the blocking random device in linux is a horrible mistake
03:06:41 <merijn> https://www.2uo.de/myths-about-urandom
03:07:02 <clever> now its bothering me, what has that tuple thing in it...
03:07:30 <merijn> There was a more in-depth/authorative essay on this by Thomas Ptacek (a cryptographer running a security company) but I can't quickly find it
03:07:42 <clever> this might have been it: https://hackage.haskell.org/package/mysql-haskell-0.8.4.2/docs/Database-MySQL-Base.html#t:Param
03:07:58 <clever> and also explains why i cant see an obvious way to type a tuple of unspecified size, it was a list
03:08:26 <mreh> boohoo, I just want someone to tell me what to do
03:08:33 <merijn> mreh: In summary /dev/random and /dev/urandom both use data from the same CSPRNG and as long as the system has gathered enough initial entropy (i.e. it's not less than 1 second after boot) it's literally not possible to run "low on entropy", because that's not how CS-PRNGs work
03:08:52 <mreh> merijn: okay
03:09:07 <mreh> do you know what the source of StdGen is? It's a PRNG IIRC.
03:09:12 <mreh> How is it seeded?
03:09:23 <mreh> (on unix)
03:09:41 <merijn> mreh: StdGen is definitely not a CSPRNG, so the fact that the seeding might be broken is pretty irrelevant, since it's already broken for crypto purposes anyway :p
03:09:45 <clever> mreh: the timing of unpredictable events (ethernet packets, hdd response, keyboard input) is used to scrambled the entropy every time an event happens
03:10:14 <clever> mreh: so an attacker would need to know the exact microsecond those events are happening at, to recreate your entropy, along with how many reads are occuring
03:10:48 <merijn> Sure, more entropy gets added to the pool, but that affects both /dev/random AND /dev/urandom, and that's just because "it can't hurt", but CSPRNG *should* be secure even without additional seeding
03:10:53 <clever> i believe "running low" on entropy, refers to an attacker heavily reading your /dev/random to get a long stream of bytes, and try to work backwards to compute the entropy pool
03:10:58 <clever> so he could then guess future bytes
03:11:08 <merijn> clever: That's not actually a thing, though
03:11:11 <clever> /dev/random blocks, to ensure its sufficiently random
03:11:41 <dmwit> clever: As far as we know, there is no way to do what you are proposing.
03:11:55 <dmwit> Sorry, no efficient way.
03:12:09 * clever waits for pocket sized quantum computers
03:12:15 <merijn> clever: I've talked to several cryptographers and security people online, they all agree "that's not a thing, and the people who wrote the linux manpage/implemented /dev/random to say that/account for that weren't actual cryptographers or security people"
03:12:20 <clever> then all your crypto will be bust!
03:12:45 <dmwit> 1. quantum computers are like, in the stone age right now 2. no, we know how to do post-quantum crypto
03:12:51 <merijn> mreh: I'm guessing StdGen is seed with current time when the RTS starts
03:12:53 <clever> merijn: ah, sounds like the linux devs where maybe just a little too paranoid? lol
03:13:34 <clever> merijn: that reminds me, the WPA key for the onboard wifi in some cars, was seeded by the unix epoch at first boot
03:13:34 <dmwit> We (as a species) have built more powerful computers *out of wood* than out of quantum effects.
03:13:48 <merijn> clever: See the link I posted earlier :)
03:13:53 <clever> merijn: except, you can deduce the time of first boot, from the manufacturing date in the VIN code
03:14:06 <mreh> Crypto.Random has the right words, and it seems to seed from the "system entropy"
03:14:08 <clever> merijn: except, it seeds the rng, before ntp set the time, so the unix epoch is how many seconds it took to boot!!
03:14:32 <merijn> clever: nice
03:14:34 <mreh> which, is /dev/[u]random on *nix
03:14:51 <clever> mreh: said car also has dbus listening on a tcp port, and has a command to execute things as root...
03:15:09 <clever> merijn: so, you can brute-force the wifi password in seconds, then run anything you want as root on the radio
03:20:17 <mreh> it's strange how Crypto.Random doesn't work with the existing typeclasses for random stuff
03:21:01 <mreh> anyway, I can generate what I need with a bytestream
03:22:13 <clever> mreh: reminds me of https://hackage.haskell.org/package/acme-memorandom
04:46:43 <Ariakenom> merijn: the random v urandom text was interesting, thanks. Don't think I've used them directly in the past, but I now know for the future.
04:52:37 <[exa]> Ariakenom: mindre-posting the link? /me can't find it in scrollback
04:54:20 <deltasquared> I confess I've lived dangerously before now and have just ln -s urandom random in /dev. it seems recent kernel changes though have improved the situation somewhat re: waiting for suitable amounts of entropy for urandom... I think it was covered by LWN
04:55:08 <deltasquared> in theory though, as long as the state wasn't leaked urandom should good for crytography stuff as long as it is sufficiently seeded.
04:56:36 <deltasquared> I recall it being the "sufficiently seeded" part that urandom was considered bad for on account of it wouldn't block if it didn't have enough entropy.
04:57:30 <deltasquared> supposedly the BSDs did it right first time...
04:59:07 <deltasquared> Ariakenom, [exa], merijn: dunno if it was the one posted before (didn't see the backlog either) but found this: https://sockpuppet.org/blog/2014/02/25/safely-generate-random-numbers/
04:59:22 <deltasquared> I wish it wasn't so hard to find out if people are talking crap about crypto stuff >_>
04:59:52 <deltasquared> or if they're not. ironically for us mere mortals we have to trust the advise given to us in most cases
05:01:55 <[exa]> deltasquared: 'trust no one' is a valid cryptography advice
05:01:56 <[exa]> :]
05:02:56 <deltasquared> [exa]: alas doing so with crypto advice itself requires taking a course in it, something requiring a lot of investment of several resources (money, time etc...)
05:02:58 <[exa]> generally I'm going with that any crypto done automagically is predestined to be vulnerable, which kindof covers the previous random/urandom failures
05:03:17 <[exa]> deltasquared: yeah
05:10:43 <day> but what is the solution? Wouldn't diy be even more problematic than reusing?
05:12:18 <deltasquared> day: I'm not implying roll your own crypto (don't do that, never do that), I mean knowing what *advice* to trust on what to use and what not to use
05:12:56 <deltasquared> not having to trust advice on implementations involves really understanding the crypto, caveats and implementation details etc. it's quite messy
05:14:05 <day> i would probably just try to replicate the implementations from high profile programs like chromium etc. if i ever were to run into that :^)
05:14:19 <deltasquared> otherwise you're reduced to taking the word of web pages like the one I linked above, or e.g. one I've used in the past for an ssh config: https://stribika.github.io/2015/01/04/secure-secure-shell.html
05:14:36 <Athas> Hm.  Can anyone here think of a nice non-recursive/data-parallel way of writing catMaybes (or equivalently mapMaybe)?
05:21:30 <gentauro> Athas: Monoids?
05:21:55 <gentauro> hmmm maybe not there is a `reduce`
05:21:59 <gentauro> (or fold)
05:23:42 <Athas> I guess by reduction to concatMap, but that is cheating!
05:25:06 <Ariakenom> [exa]: deltasquared: https://www.2uo.de/myths-about-urandom
05:25:32 <gentauro> Athas: gonna be difficult to do without recursion ...
05:25:52 <Rembane> Is there a parallell fold out there?
05:25:53 <Ariakenom> it's for futhark I suppose? so you have loop
05:26:38 <Ariakenom> rldr; Just use /dev/urandom!
05:27:49 <Ariakenom> and yes BSDs got it right. urandom and random are apparently the same there.
05:27:56 <gentauro> Athas: it reminds me of this -> http://sparetimeteaching.dk/challenges/ch7.pdf but you are still allowed to use `recursion` once
05:28:36 <Athas> It can be done with a 'filter' and then a 'map' with either a partial function, or the availability of a dummy value.
05:29:08 <gentauro> Athas: `filter` = recursion FYI
05:29:22 <Athas> gentauro: not necessarily, although it is implemented that way in Haskell.
05:30:03 <gentauro> `filter` should be build on `fold` amirite?
05:30:16 <gentauro> how is it done in Futhark?
05:30:24 <Athas> A 'filter' on lists in Haskell should be done with recursion, as it is.
05:30:45 <Athas> In Futhark (and Accelerate, for that matter), it is decomposed into scan/scatter.
05:31:03 <gentauro> cos you use `arrays` right?
05:31:11 <Athas> Yes.
05:31:18 <gentauro> fair enough
05:32:05 <gentauro> Athas: so you just answered your own question right?
05:32:38 <Athas> Not to my greatest satisfaction, I feel.
05:32:51 <gentauro> `mapMaybe = filter isSome`
05:32:59 <Athas> That has the wrong type.
05:33:20 <Athas> :t filter isJust
05:33:21 <lambdabot> [Maybe a] -> [Maybe a]
05:33:45 <Athas> :t catMaybes
05:33:46 <lambdabot> [Maybe a] -> [a]
05:34:06 <gentauro> oh, you are right ..
05:34:37 <deltasquared> *reads the 2uo.de blog post*
05:34:59 <deltasquared> Ariakenom: the thing about it being sufficient to be unpredictable, I can't +1 that enough
05:36:51 <Ariakenom> deltasquared: I mean that's what randomness is afaict
05:37:43 <gentauro> deltasquared: you sound like somebody who uses this `webcam cover` -> https://twitter.com/EFF/status/1091449476613468160 (just saying)
05:37:46 <gentauro> :P
05:37:48 <deltasquared> Ariakenom: yeah, if you don't want to get philosophical about it I guess
05:38:06 <deltasquared> gentauro: actually I probably would. I did tape it before but kept falling off xD
05:39:09 <gentauro> deltasquared: I mean, if you ever want to use something to cover a webcam, I guess using something made by the NSA would be wrong :D
05:40:08 <deltasquared> hmm, didn't actually read that post so didn't know who made it, but def. a webcam cover I'd use if it were low profile enough.
05:40:21 <gentauro> I once got really mad cos my web camera didn't work (new laptop) and then somebody told me: "Aren't you sure that the video doesn't work cos of the tape" xD
05:40:26 <deltasquared> shame microphone toggling requires more involved hardware mods
05:40:53 <deltasquared> also, does anyone else read CSPRNG as "C-spring"? almost like "crypto spring"? :D
05:41:01 <gentauro> deltasquared: I use Qubes OS so daily usage of mic/USB just became `rocket science`
05:41:13 <deltasquared> oof
05:43:28 <_deepfire> gentauro: how much did the user experience improve in the last year or so, by the way?
05:44:28 <gentauro> Athas: `mapMaybe = (fmap fromJust) . (filter isJust)`?
05:44:50 <gentauro> Athas: `mapMaybe = fmap fromJust . filter isJust`?
05:44:55 <Athas> gentauro: sure, that's the solution with a partial function I mentioned.
05:45:55 <gentauro> _deepfire: From 3.2 to 4.0, much worse, but they did a lot for UX/UI though (and made it more difficult for terminal). So it's better for `normal` people, but worse for people like me who live in a `terminal` :|
05:46:12 <gentauro> but Qubes OS is aimed for journalist, so it's probably fine
05:48:57 <gentauro> Athas: ...
05:50:30 <gentauro> no recursion and how many iterations? I guess you need at least two right?
05:55:56 <Solonarv> uh, what was the question? different implementations of mapMaybe?
05:56:30 <gentauro> Solonarv: implement a parallel version of `catMaybess
05:56:50 <Solonarv> 'fmap fromJust . filter isJust' is two passes normally, but should be turned into one pass in the optimizer (thanks to list fusion), FWIW
05:57:13 <gentauro> `filter = recursion` right?
05:57:22 <Solonarv> filter is recursive yes
05:57:27 <gentauro> so that will not do. Athas works with `arrays` and not `lists`
05:58:18 <gentauro> 14:14 < Athas> Hm.  Can anyone here think of a nice non-recursive/data-parallel way of writing catMaybes (or equivalently mapMaybe)?
05:58:30 <Solonarv> oh good, I don't think it's usefully possible for lists
05:58:32 <gentauro> Solonarv: that's the question 
05:59:24 <Solonarv> I'm confused. Is the question about arrays, or lists?
06:00:16 <gentauro> Solonarv: I'm guessing `arrays` as list aren't a parallel datastructure in Haskell
06:01:06 <Athas> For the purpose of this question, 'filter' is not recursive.  It is just a building block.
06:01:29 <Athas> I'd not get too hung up on the distinction between arrays and lists here, except that the question is only interesting if you don't use lists.
06:02:04 <Solonarv> something like: catMaybes = foldMap (mapConcurrently catMaybes') . divideIntoChunks n
06:03:16 <Solonarv> where catMaybes' is a non-parallel version of catMaybes, divideIntoChunks n divides an array into n chunks of (roughly) equal size, and n is how many threads you want to use
06:05:38 <Solonarv> does that seem like a reasonable approach?
06:06:43 <Amras> I still can't shake the feeling that Yampa is married to the idea of frames - `repeatedly` (according to docs) refuses to generate multiple events if they occur within the same sampling interval
06:06:44 <Athas> It would probably work fine in the specific context of Haskell, but it's not useful for my purposes (since catMaybes' is still unexpressible).
06:07:23 <Solonarv> you need to *somehow* loop over the input and copy over only the 'Just' entries
06:07:59 <Athas> The 'map fromJust . filter isJust' solution is nice and parallel, I just don't like the partial function.  But maybe there is no other way.
06:08:00 * hackage hakyll 4.12.5.1 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.12.5.1 (JasperVanDerJeugt)
06:08:11 <Athas> Conceptually data-parallel, anyway.
06:09:02 <Solonarv> what purpose is this for, then? (I hopped in midway through the conversation, so I'm missing context)
06:09:43 <Athas> We're adding sum types to Futhark, so I'm considering how to write various common utility functions in a parallel style.
06:10:20 <Athas> Haskell is fine as a vocabulary for exploring how to phrase them.
06:11:19 <Solonarv> oooh, I see! that's the context I was missing, thanks
06:11:24 <deltasquared> haskell is certainly good as a modelling language. being able to capture data types, multiplicity etc. quickly is always nice
06:11:43 <deltasquared> if only I could use it at work and they'd go "you can write programs for that so quickly! write $product in it!"
06:13:01 <Solonarv> of course one option would be to make mapMaybe a primitive and implement filter in terms of it: filter p = mapMaybe (\x -> x <$ guard (p x))
06:13:37 <Athas> Yes!  However, I think n-way partitioning is a better primitive, as it is more general.
06:13:58 <Solonarv> 'map fromJust . filter isJust' also needs to 'case' twice, on top of being partial; it seems very inelegant to me
06:14:10 <Athas> But then the question becomes how to express mapMaybe in terms of that.  N-way partition can be used to implement filter, and filter can then be used to implement mapMaybe.
06:16:05 <Solonarv> N-way partition is the 'divideIntoChunks' I mentioned above?
06:17:27 <Athas> No, N-way partition is something like '(a -> Int) -> [a] -> [a]', where the functional argument is used to compute an equivalence class for each element, and elements are then grouped according to their equivalence class.
06:17:40 <Athas> A bit like 'groupBy' if 'groupBy' did not consider only adjacent elements, and also flattened its output.
06:17:53 <Solonarv> oh, I see
06:17:56 <Athas> It is the most general filtering primitive I know of.
06:18:00 <int-e> Athas: should the result be [[a]]?
06:18:12 <Solonarv> int-e: 'and also flattened its output'
06:18:18 <int-e> oh
06:18:27 <Athas> int-e: no, but I forgot that it also returns an auxiliary array [Int] that indicates the size of each class.
06:18:34 <Solonarv> ah, I was going to ask about that
06:18:37 <Athas> Conceptually it is [[a]], but for technical reasons it is flattened.
06:20:18 <Solonarv> there is an obvious more general variant: '(a -> (Int, b)) -> [a] -> ([Int], [b])'
06:20:24 <gentauro> Athas: is `O(log^2(n))` fast enough with O(1) mem?
06:21:53 <Solonarv> but that variant is also (possibly?) less efficient, since it can't just swap 'a's around and *always* needs to allocate a new array
06:21:53 <gentauro> `bitonic sort` in parallel
06:22:00 * hackage patat 0.8.2.1 - Terminal-based presentations using Pandoc  https://hackage.haskell.org/package/patat-0.8.2.1 (JasperVanDerJeugt)
06:22:35 <gentauro> then `O(n)` with a subset of the array (I'm assuming that you use immutable data structures right?)
06:22:44 <Athas> Solonarv: correct!  I think in the core language, we will use that representation.  (But now we are venturing into compiler design more than parallel programming...)
06:23:21 <Solonarv> well, if this more general primitive is available then mapMaybe becomes pretty simple
06:23:44 <Athas> And the *fully* general version can't even be expressed in Haskell's type system, because it needs dependently sized tuples (one input element may produce multiple output elements, each of which may belong to a different equivalence class).
06:24:28 <Solonarv> pass (\case Just x -> (0, x); Nothing -> (1, undefined)) as the functional argument and then just extract the correct prefix from the result
06:25:42 <Solonarv> actually, that's totally doable in Haskell, though not very efficient - Data.Dynamic.Dynamic is already a (t : Type, x : t) tuple, effectively
06:29:52 <Solonarv> hmm, of course there is still partiality there, which is unfortunate
06:32:20 <Athas> Sometimes that is unavoidable.  It's like there is a hierarchy of constructs: those that require compiler support/magic, those that use partiality, and those that are all nice and proper.
06:32:29 <Solonarv> yup
06:32:33 <Athas> But users should only be expected to define those in the last category on their own.
06:33:35 <Solonarv> well mapMaybe is definitely something that should be in the base library/prelude/whatever-you-call-it, IMO
06:34:06 <Athas> Sure, but *someone* still has to write it, and that someone tends to be me!
06:34:49 <Solonarv> fair :P
06:38:22 <Solonarv> what I meant is that mapMaybe would reside in the base library, which means users don't have to write it, which means the "internal" partiality is not an issue
07:50:22 <monochrom> I think I saw mapMaybe in base the other day.
07:51:32 <Solonarv> it is in Haskell.
07:51:49 <Solonarv> but we were talking about how it could be added to Futhark
08:06:32 <hololeap> i've got a personal cabal project in my home directory that doesn't exist on hackage. how can i depend on it from another cabal project in my home directory?
08:07:11 <glguy> hololeap: Add it to your cabal.project packages: list
08:09:10 <Solonarv> hololeap: also works for packages on github or similar, btw
08:29:46 <orion_> I'm currently reading https://wiki.haskell.org/Type_arithmetic. What are some calculations that can be done on the value level that can't be done on the type level?
08:30:52 <hololeap> i don't know why, but i'm not having any success with editing cabal.project, it still can't find the dependency
08:31:00 <lyxia> orion: In theory, none, the type system with enough extensions is turing complete.
08:31:35 <c_wraith> evaluation at the type level is *really* slow, though.
08:31:47 <c_wraith> For some reason, GHC didn't think it was worth optimizing.
08:32:09 <orion> Is it possible to have GHC fire the missiles without Template Haskell?
08:33:08 <lyxia> I think not.
08:33:26 <c_wraith> there are other things you can put in source, though
08:33:38 <c_wraith> Like, there is support for running arbitrary preprocessors
08:34:34 <c_wraith> The plugin mechanism probably allows arbitrary IO, too, given the existence of type checker plugins that run external SMT solvers
08:45:59 <Solonarv> indeed it does
08:48:46 <hololeap> it only worked if i use `cabal new-build all`
08:54:36 <cocreature> hololeap: cabal.project files only apply to new-build
08:58:02 <dminuoso> orion: You can always load a type checker plugin and do naughty things there..
09:35:38 <srk> cocreature: https://github.com/cocreature/diagrams-miso <3
09:35:57 <srk> pretty handy
09:38:29 <mouse07410> I'm trying to pass options to the linker via stack (--ghc-options). It works in general, but when I try to install intero, "ghc-paths" package fails on linking - and I observe that my options were not passed. Anybody could help figure what's wrong and how to remedy it?
09:38:33 <dminuoso> So let's say I want to have a) ACID properties and b) manage IP address assignments (carve out prefixes of arbitrary size or reclaim prefixes). The latter I would just do with a radix tree, but how would you stuff this into a database?
09:39:59 <srk> with acid-state you can use your favorite data structure as a database
09:40:53 <dminuoso> srk: acid-state is not enough, I want the guarantees that come with a mature database. 
09:41:41 <dminuoso> Backups, PITR, actual atomicity guarantees..
09:41:47 <dminuoso> Consistency.
09:43:12 <srk> with acid-state you can surely do PITR as the data are just files. you can also do replication with it
09:44:28 <dminuoso> srk: acid-state would require me to re-implement everything databases do by default, I do not see how this would be beneficial.
09:44:37 <srk> not sure how stable / constistent it is tho, it powers hackage which is a nice indicator :)
09:45:16 <hpc> postgres has a json column type, if you're feeling silly
09:45:33 <srk> well yeah, if you want (or need) actual relational database
09:45:36 <dminuoso> srk: It begins with simple things like: acid-state does not give me actual duration. A lot of thought went into how WAL logs are written and transactions managed in PostgreSQL, it's rather complicated if you want to safeguard your store against random hardware failure.
09:45:55 <hpc> or for the ip problem, write out the netmask as an integer and do bitwise querying?
09:46:06 <srk> I love postgres too, don't get me wrong :)
09:46:38 <hpc> or not even that, you know the min and max numbers in that range if you are using netmasks sanely
09:47:20 <hpc> so like, 127.0.0.0/24 would be 0x1ffff00 (or whatever it is)
09:47:36 <srk> dminuoso: are WAL logs enough to protect you from hardware failures or random disk errors?
09:47:45 <hpc> select * from ranges where netmask >= 0x1ffff00 and netmask <= 0x1ffffff
09:48:05 <srk> I would say you still need like md array or zfs for that
09:49:11 <hpc> nothing running on the hardware can protect you from the hardware failing
09:49:28 <srk> is there any lib for mask/prefix conversion and ip validation?
09:49:42 <dminuoso> srk: Postgresql has some features to ensure reliable writes, yes.
09:49:47 <hpc> srk: probably
09:50:07 <hpc> it's not hard to write yourself either
09:51:34 <dminuoso> srk: mask/prefix is just simple high school arithmetic..
09:51:53 <srk> for ipv6 it's no fun
09:52:00 <srk> validation part mainly
09:52:15 <dminuoso> srk: even for ipv6 its simple
09:52:27 <hpc> ipv6 is the same thing but more times
09:52:33 * srk stumbled upon this again https://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
09:52:34 <dminuoso> you just have to consider that ipv6 consists of *two* halves.
09:52:37 <dminuoso> nothing more.
09:52:38 <hpc> the hardest part is parsing "::"
09:52:41 <srk> yup
09:52:47 <dminuoso> Oh you are talking string validation.
09:52:59 <srk> yes, that's what I meant
09:53:28 <dminuoso> srk: Probably easiest to just parse it with some `StateT IPState Parser`?
09:53:45 <srk> you can probably eliminate lots of errors by validating your addresses with some lib
09:53:50 <dminuoso> (Regex is something horrible to express simple ideas)
09:53:56 <srk> :)
09:54:05 <hpc> regexes aren't that bad
09:54:24 <hpc> you just very rarely have an actually finite state machine, and you usually don't want to write it so compactly
09:56:59 <haasn> regexes are a decent interface language for specifying simple languages (e.g. in a UI)
09:57:42 <dminuoso> hpc: The shortest RFC822 compliant perl regex to validate mail addresses.
09:57:45 <dminuoso> https://gist.github.com/dminuoso/f90083cf532cb7fac2df5a11e1cc61c7
09:57:56 <haasn> was there a haskell stand at FOSDEM?
09:58:12 <monochrom> But email addresses are not simple. :)
09:58:19 <hpc> i thought email addresses were context-free
09:58:40 <srk> I wonder why I have to annotate most of the regex matches (Text.Reges.Posix) like x =~ (".*" :: String)
09:58:45 <srk> even with overloadedStrings
09:58:59 <dminuoso> Probably *because* of OverloadedStrings?
09:59:04 <monochrom> I would think especially OverloadedStrings.
09:59:19 <srk> ah!
09:59:21 <glguy> Especially because of OverloadedStrings
09:59:27 <cocreature> also because the regex API is the worst
09:59:29 <srk> ok ok.. :D
09:59:53 <dminuoso> srk: You should try out pcre-heavy. :)
10:00:07 <hpc> or maybe learn parser combinators :D
10:00:09 <dminuoso> From all the regex libraries I've tried, it's the one that feels most Haskellish.
10:00:18 <srk> nice
10:00:42 <cocreature> I’m still convinced that whoever made the regex-base API was trying to make something particularly disgusting
10:01:39 <srk> hpc: I need tons of simple regexes in guards and that would grow the code too much
10:01:40 <marvin2> has anyone used scalpel web scraper? is it possible to advance to previous/following siblings in the HTML tree? I'm looking at the api, and it appears that you can only fetch children within the current tree position
10:01:50 <srk> simple ones like .. "MCO[0-9]?PRE"
10:02:01 <haasn> http://0x0.st/suFt.txt I use this beautiful regex in practice to detect clickable URLs
10:02:03 <monochrom> Don't attribute to malice what can be attributed to over-enthusiasm. >:)
10:02:45 <geekosaur> cocreature, I've decided that's ot quite it. They made an API as brutally efficient as regexes are
10:02:56 <monochrom> Also it was before Backpack. It was a time when people used multiple-parameter type classes to fake real module systems.
10:02:57 <cocreature> monochrom: over-enthusiasm for ugly APIs?
10:03:01 <dminuoso> srk: so with pcre-heavy you would write something like: f x | x =~ [re|.*|] = blabla
10:03:14 <monochrom> For MPTC!
10:03:19 <hpc> haasn: that regex could use some work, it has a very limited list of TLDs
10:03:30 <geekosaur> if you know what you're doing, it does the job with minimal verbiage. otherwise, well, it's as impenetrable as regex :)
10:03:35 <haasn> hpc: yes, need to add .ninja, .sexy, .horse and .wtf
10:03:38 <srk> dminuoso: nice, I've hacked around it like this - fix x | fieldName x `matchesRe` "MCO[0-9]?" = ...
10:04:11 <hpc> haasn: i suggest taking inspiration from http://svn.apache.org/viewvc/spamassassin/trunk/lib/Mail/SpamAssassin/RegistryBoundaries.pm?view=markup
10:04:30 * hackage gscholar-rss 0.2.0.0 - scrapes google scholar, provides RSS feed  https://hackage.haskell.org/package/gscholar-rss-0.2.0.0 (fffaaa)
10:04:52 <hpc> oh wait, that's not it
10:04:59 <dminuoso> srk: And because it uses QQ, there's a function `mkRegexQQ` to make customized quasiquoters.
10:05:00 <haasn> this is ontopic because I used http://0x0.st/zsTF.hs to generate it
10:05:30 <monochrom> haha great
10:06:35 <dminuoso> haasn: At that point.. why exactly are you not using monadic parser combinators?
10:06:58 <dminuoso> Like Megaparsec I mean.
10:07:37 <monochrom> I think it's because urvxt terminal wants a regex, and haasn is writing a haskell program to pretty-print such a regex.
10:07:56 <dminuoso> Ah.
10:08:15 <hpc> haasn: anyway, there's a monster list of TLDs and some code that generates an 
10:08:19 <haasn> dminuoso: because I need a regex :)
10:08:20 <hpc> "efficient" regex for it
10:08:41 <dminuoso> haasn: gotcha so you feed that regex to urvxt so that URLs in the terminal matching that regex become clickable/
10:08:42 <hpc> so matching .aa or .ab would be (a(a|b))
10:09:14 <haasn> hpc: I specifically don't watch to match every TLD though, to avoid over-matching on raw filenames with extensions
10:09:16 <hpc> the resulting regex is so long vim can't format it
10:09:28 <haasn> (the TLDs are only used for "bare" domains, like example.org)
10:09:37 <haasn> the "example.org" part of that line gets matched
10:09:37 <hpc> ah, makes sense
10:09:42 <dminuoso> haasn: Do you have many filenames starting with `http://`? :D
10:10:05 <hpc> it's similarly used in spamassassin, to run blacklist checks against bare domains
10:10:21 <hpc> and there you want to catch everything because the iffiest registrars also have the most obscure TLDs
10:10:25 <haasn> also here's the interesting part http://0x0.st/zsAs.hs
10:10:41 <haasn> dminuoso: anything starting with http:// is matched as a URL regardless of the TLD :)
10:11:01 <dminuoso> haasn: Ah, is `:|` an "or"?
10:11:07 <haasn> yes, exactly
10:11:13 <dminuoso> haasn: That explains it then. :)
10:11:19 <haasn> :* is a "followed by"
10:11:43 <dminuoso> I see, your latest link includes the details.
10:12:00 <hpc> you could have used :+ and taken advantage of regexes forming an algebra
10:12:08 <hpc> or well, at least a ring
10:12:39 <haasn> | to mirror the regex syntax
10:12:44 <haasn> but yes, good point
10:13:02 <haasn> (also the constructor syntax)
10:13:36 <monochrom> Do you plan to have a special case for command.com? >:)
10:14:13 <monochrom> Actually I wonder whether someone registered that.
10:14:56 <monochrom> Oh yes someone did.  www.command.com "decorate fearlessly with Command(TM) Brand"
10:17:29 * hackage timer-wheel 0.2.0 - A timer wheel  https://hackage.haskell.org/package/timer-wheel-0.2.0 (mitchellwrosen)
10:20:05 <haasn> monochrom: nice
10:21:39 <dmwit> Hah, cmd.com is a Linux tool. That's a bit ironic.
10:23:23 <monochrom> Oh wait, so now there is DevSecOp too.
10:23:53 <haasn> hpc: what is the additive inverse of a regex?
10:24:38 <hpc> ah good point, definitely just a ring then
10:24:39 <haasn> (does the inverse have to be unique?)
10:25:22 <haasn> wait it doesn't matter if the inverse is unique or not, you still can't make an additive inverse at all
10:25:30 <haasn> so a semiring :)
10:26:00 <hpc> whatever you pick, a - b + b must equal a
10:26:25 <hpc> or more non-trivially, b + a - b
10:26:31 <hpc> yeah
10:27:00 <haasn> ah yes, because associativity
10:27:48 <hpc> regexes are one of those things that it'd be really cool to see the numeric hierarchy expanded for
10:28:17 <monochrom> That would be like "grad school algebra course hierarchy".
10:28:42 <hpc> well, yeah
10:29:23 <monochrom> The detractors can now revive their "you need a PhD to use Haskell". And improve it with "and it is not even CS, it is Math".
10:30:30 <monochrom> Not to use that I'm against it. >:)
10:30:34 <monochrom> s/use/say/
10:30:35 <haasn> 0 has to be a regex that matches nothing
10:30:39 <haasn> what is 1?
10:30:46 <monochrom> The empty string.
10:30:49 <haasn> if 1 is the multiplicative identity then it has to be the empty regex
10:30:59 <haasn> so 1+1 is the empty string or the empty string
10:31:03 <haasn> 1+1=1 in regex land
10:31:13 <hpc> it just wouldn't support numeric literals
10:31:34 <monochrom> Someone actually did.
10:32:41 <haasn> in general, for any regex n, n+n=n
10:33:20 <haasn> so just pick any order you want, there's not much structure
10:33:51 <lysgaard> I am writing a sort of compiler. My compiler outputs source code in text format. I am currently using https://hackage.haskell.org/package/pretty to do this task. Lately the documents I am generating are very big 10-100MB, and it semes like the pretty package is making my program go out of memory getting killed by the Linux kernel. Is there a more efficient way to generate text that still "feels" like the pretty library?
10:34:42 <cocreature> lysgaard: prettyprinter is more efficient in most cases iirc if you want to keep your output format
10:35:13 <cocreature> although if you’re generating 100mb of output, you might want to consider whether there is really any point in generating that in some textual pretty printed format as opposed to some binary encoding
10:35:19 <monochrom> Hrm, I guess I misremembered. No one made a Num instance for regex.
10:36:44 <haasn> if n+n=n then 2*n=n+n=n
10:36:54 <haasn> so 2 has to be the empty string
10:37:02 <haasn> and so on for all numeric literals
10:37:08 <dmwit> How did you define n in the first place?
10:37:18 <haasn> so there's no sane implementation of Num Regex
10:37:43 <nshepperd> who says 2 being the empty string is not sane :p
10:37:45 <lysgaard> cocreature: thanks, I'll look into prettyprinter to see if it performs better. I completely agree on the binary format note, my program is just in an very alpha state where text is very easy to use because of external constraints.
10:37:56 <dmwit> I don't see how you can go from "fromInteger = const epsilon" to "there's no sane implementation of Num Regex".
10:38:00 <haasn> there's also no "negate"
10:38:01 <hpc> who says 2*n = n+n?
10:38:14 <dmwit> Just because not all regexen can be reached as "number literals" doesn't mean the instance is insane.
10:38:30 <dmwit> For example: not all Complex numbers are in the codomain of fromInteger either.
10:38:31 <nshepperd> hpc: because 2 is 1+1, and 1 is the empty string
10:38:36 <dmwit> (Nor even in the codomain of fromRational.)
10:39:04 <hpc> who says 1+1 = 2? :P
10:39:09 <cocreature> lysgaard: what does your output even represent? some kind of IR?
10:39:24 <haasn> fair enough, it's just that I don't see how this Num instance adds anything of value over e.g. Semiring
10:40:09 <haasn> I don't think Num actually has any laws attached to it anyway
10:40:34 <iqubic> It has one.
10:40:34 <nshepperd> 1+1 has to be 2 if you want fromInteger to be a homomorphism
10:40:50 <haasn> (then again we don't have Semiring in base yet)
10:40:59 <iqubic> abs n * signNum n = n is the only law on numbers.
10:41:51 <dmwit> Most people expect Num instances to be a ring homomorphism from Z.
10:42:25 <dmwit> Those laws are now documented (though they're broken by the Float and Double instances, of course).
10:47:25 <monochrom> Onoes Word is in Prelude now too.
10:47:42 <monochrom> "Word is out that Word is in Prelude now."
10:47:54 <haasn> Word.
10:47:58 <hpc> class PowerPointed where ...
10:48:20 <iqubic> dmwit: what is Z?
10:48:26 <haasn> Integer
10:48:48 <monochrom> haha hpc
10:48:49 <nshepperd> dmwit: only for Doubles bigger than 2^53!
10:49:42 <hpc> nshepperd: is (0/0) bigger than 2^53? ;)
10:50:08 <haasn> hpc: False
10:50:13 <hpc> wait yeah
10:50:18 <hpc> my joke wasn't mathematically sound
10:50:22 * hpc dies of embarassment
10:50:25 <nshepperd> (0/0) isn't in the domain of fromInteger so we're safe anyway :)
10:51:17 <lysgaard> cocreature: it's symbolic math
10:51:17 <nshepperd> err, range
10:52:14 <wroathe> I regularly see people in here talking about monomorphisms/isomorphisms/whatevermorphisms. I assume that's from category theory. Did you all have a class on the subject or is there a text book you recommend?
10:53:09 <amx> I think I read https://github.com/hmemcpy/milewski-ctfp-pdf once upon a time
10:53:35 <gentauro> % :i Word8
10:53:35 <yahb> gentauro: data Word8 = W8# Word# -- Defined in `GHC.Word'; instance Eq Word8 -- Defined in `GHC.Word'; instance Ord Word8 -- Defined in `GHC.Word'; instance Show Word8 -- Defined in `GHC.Word'; instance Read Word8 -- Defined in `GHC.Read'; instance Enum Word8 -- Defined in `GHC.Word'; instance Num Word8 -- Defined in `GHC.Word'; instance Real Word8 -- Defined in `GHC.Word'; instance Bounded Word8 -- Defined in `GH
10:53:57 <haasn> dmwit: where does Double violate this?
10:54:05 <gentauro> how would you define `Word1` (0 and 1 or just a bit)?
10:54:16 <iqubic> > (0/0)
10:54:18 <lambdabot>  NaN
10:54:49 <gentauro> % 256 :: Word8
10:54:49 <yahb> gentauro: ; <interactive>:82:1: warning: [-Woverflowed-literals] Literal 256 is out of the Word8 range 0..255; 0
10:55:09 <gentauro> I would like the same for `2 :: Word1`
10:55:11 <haasn> gentauro: Bool, perhaps
10:55:13 <nshepperd> Float violates the ring homomorphism thing for integers that are bigger than 8388608
10:55:19 <nshepperd> 2^23 is pretty small, huh
10:55:29 <gentauro> haasn: yeah, I though of that
10:55:32 <iqubic> I don't know what a ring is. I should learn about that.
10:56:06 <haasn> > (8388608 + 1 :: Float) == 8388609
10:56:08 <lambdabot>  True
10:56:26 <iqubic> what's the issue?
10:56:42 <nshepperd> eh, did i get it wrong
10:56:53 <iqubic> Perchance
10:57:02 <haasn> > (2^30 + 1 :: Float) == fromInteger (2^30 + 1)
10:57:04 <lambdabot>  True
10:57:23 <nshepperd> oh, it's 2^24 because of the denormalization thing
10:57:42 <monochrom> You need to figure out the machine epsilon but once you do you can demonstrate (1+e)+e /= 1+(e+e)
10:57:51 <nshepperd> > (16777216 + 1 :: Float) == 16777216
10:57:53 <lambdabot>  True
10:58:28 <haasn> λ quickCheck $ \a b -> fromInteger (a+b) == (fromInteger a + fromInteger b :: Float)
10:58:29 <haasn> +++ OK, passed 100 tests.
10:58:41 <iqubic> > length $ takeWhile (\x -> x == x + 1) ([1...] :: [Float])
10:58:43 <lambdabot>  error:
10:58:43 <lambdabot>      A section must be enclosed in parentheses thus: (1 ...)
10:58:50 <nshepperd> > round (16777216 + 1 :: Float)
10:58:52 <lambdabot>  16777216
10:59:12 <iqubic> > length $ takeWhile (\x -> x == x + 1) ([1..] :: [Float])
10:59:14 <lambdabot>  0
10:59:17 <haasn> > find (\x -> x == x+1) [1..] :: Maybe Float
10:59:17 <iqubic> Huh?
10:59:23 <lambdabot>  mueval-core: Time limit exceeded
10:59:59 <iqubic> > length $ takeWhile (\x -> x /= x + 1) ([1..] :: [Float])
11:00:06 <lambdabot>  mueval-core: Time limit exceeded
11:00:18 <iqubic> I see. So it must be a really big number.
11:00:58 <haasn> 16777216 on my machine
11:01:51 <haasn> > 16777216 + (1+1) == ((16777216+1)+1 :: Float)
11:01:53 <lambdabot>  False
11:02:37 <haasn> what actually does the ring homomorphism require?
11:02:59 * hackage tapioca 0.1.1.0 - A tasty enhancement to cassava for easy csv exporting  https://hackage.haskell.org/package/tapioca-0.1.1.0 (cfraz89)
11:03:02 <haasn> obviously f x + f y = f (x + y) as well as f 0 = 0 and f 1 = 1
11:03:09 <haasn> and f x * f y = f (x * y)
11:03:14 <nshepperd> > (fromInteger 16777219 - 1 :: Float) == fromInteger 16777218 -- haasn
11:03:16 <lambdabot>  False
11:03:21 <monochrom> Also f (-x).  I think that's it.
11:03:30 <haasn> actually the issue is that Float isn't a (semi)ring
11:03:45 <haasn> so fromInteger is not a ring homomorphism because it's not mapping to a ring :)
11:04:01 <iqubic> What is a ring?
11:04:10 <haasn> iqubic: do you know what a monoid is?
11:04:15 <iqubic> Yes.
11:04:25 <iqubic> It's a semiring with an identity element.
11:04:29 <haasn> and a group?
11:04:36 <haasn> semigroup with identity*
11:04:42 <iqubic> I don't know what a group is.
11:04:53 <haasn> A group is a monoid with inverse elements
11:05:03 <iqubic> What does that mean?
11:05:10 <nshepperd> > let f i = fromInteger i :: Float in f 16777219 + f (-1) == f (16777219 + (-1))
11:05:12 <lambdabot>  False
11:05:20 <iqubic> What is an inverse element
11:05:27 <haasn> i.e. for each member x in your group, there exists a (unique) value -x such that x <> -x = identity
11:05:33 <iqubic> Ah. I see.
11:05:45 <haasn> for example, the additive inverse is literally just -x, hence the symbol
11:05:49 <iqubic> I see.
11:06:16 <haasn> (uniqueness can be proven given only monoid laws and existence)
11:06:19 <haasn> (exercise to the reader)
11:06:20 <iqubic> And for multiplication the inverse is recip
11:06:27 <haasn> yes
11:06:36 <iqubic> So no, that's what a group is.
11:06:50 <iqubic> s/no/now/
11:07:01 <iqubic> Now what is a ring?
11:07:08 <haasn> now a ring is like a combination of a group with a monoid, as two different operations
11:07:15 <haasn> with the added law of distributivity
11:07:51 <iqubic> I thought a ring was already a moniod by the definition of what a ring is.
11:07:59 <iqubic> I'm now a little confused.
11:08:18 <haasn> the motivating example of a group is the group formed by the Integer set and the (+, 0, negate) group with the (*, 1) monoid
11:08:40 <dmwit> ?let big = numerator (fromRational (1/0))-1
11:08:42 <lambdabot>  Defined.
11:08:45 <haasn> iqubic: say you have some group and some monoid, both over the same set
11:09:00 <dmwit> > fromInteger big + fromInteger 1 == (fromInteger (big+1) :: Double)
11:09:02 <iqubic> Sure. Like (+, 0, negate)
11:09:03 <lambdabot>  *Exception: Ratio has zero denominator
11:09:11 <dmwit> ?undefine
11:09:12 <lambdabot> Undefined.
11:09:15 <haasn> but as two different operations (typically denoted * and +)
11:09:22 <dmwit> ?let big = numerator (fromRational (1/0 :: Double))-1
11:09:24 <lambdabot>  .L.hs:157:32: error:
11:09:24 <lambdabot>      • Couldn't match type ‘Double’ with ‘Ratio Integer’
11:09:24 <lambdabot>        Expected type: Rational
11:09:32 <sirqwit> Hi
11:09:34 <dmwit> oops =)
11:09:38 <dmwit> ?let big = numerator (toRational (1/0 :: Double))-1
11:09:39 <lambdabot>  Defined.
11:09:43 <dmwit> > fromInteger big + fromInteger 1 == (fromInteger (big+1) :: Double)
11:09:45 <lambdabot>  False
11:09:48 <dmwit> haasn: ^
11:10:13 <haasn> iqubic: the law combining the two together is distributivity, which is that a*(b+c) = a*b+a*c
11:10:48 <iqubic> I see.
11:11:23 <haasn> and I think also 0*x = 0
11:11:32 <haasn> although that one might be provable from the other laws, I'm not sure
11:12:12 <dmwit> gentauro: 
11:12:15 <dmwit> ?quote dmwit Num.Bool
11:12:16 <lambdabot> dmwit says: ?let instance Num Bool where (+) = (/=); (*) = (&&); negate = id; abs = id; signum = id; fromInteger = odd
11:12:23 <haasn> iqubic: a semiring is similar but you don't have an additive inverse, so it's just two different monoids + distributivity
11:12:29 * hackage apecs-stm 0.1.0 - STM Stores for apecs  https://hackage.haskell.org/package/apecs-stm-0.1.0 (jonascarpay)
11:13:02 <sirqwit> Where haskell is mostly use?
11:13:07 <[Leary]> 0*x = 0 is automatic for Rings, axiom for Semirings
11:13:14 <haasn> iqubic: an example of a semiring is sets: set union and set intersection distribute
11:13:42 <dmwit> (Amusingly that works equally well whether you were hoping for Word1 or Int1.)
11:14:04 <haasn> (I think)
11:14:37 <dmwit> sirqwit: http://industry.haskell.org/partners might be a start at answering that
11:14:57 <haasn> 1 being the set of all sets, of course :p
11:15:16 <haasn> iqubic: more rings: Bool form a ring with (&& and ||)
11:15:40 <dmwit> sirqwit: https://wiki.haskell.org/Haskell_in_industry looks more comprehensive. Both are probably out of date to some extent.
11:15:48 <[Leary]> && and xor*?
11:15:53 <sirqwit> Thanks dmwit
11:15:55 <haasn> haskell types form a sort of pseudo-ring, with Either and (,)
11:16:00 * hackage apecs-stm 0.1.1 - STM stores for apecs  https://hackage.haskell.org/package/apecs-stm-0.1.1 (jonascarpay)
11:16:48 <sirqwit> I am looking for good resource or book to learn functional program, do you suggest anything?
11:19:02 <dsal> sirqwit: I liked haskellbook.com a lot.  I've done fp for a long time, but the structure is really great for starting from ~nothing
11:19:25 <sirqwit> Ok thanks
11:19:56 <inkbottle> stack install --resolver lts-13.6 haskell-src-exts; did work, though the project (git's) doesn't seem to have a "stack.yaml" file. The stack build has been using "Cabal-2.4.1.0: download, configure, and build": Not sure I've noticed that on other builds.
11:20:41 <haasn> [Leary]: if we want an actual ring, then I think we need xor, yes. (||) has no additive inverse for True
11:20:53 <haasn> otherwise it would only be a semiring
11:21:15 <cocreature> inkbottle: you might only end up downloading and compiling Cabal for packages that have a custom Setup.hs
11:21:27 <inkbottle> OK
11:21:53 <inkbottle> all in the setup.hs; forgot to look into that ;)
11:22:25 <haasn> dmwit: okay, but only because NaN /= NaN
11:22:30 <haasn> I mean Infinity
11:22:39 <haasn> dmwit: they still both map to Infinity
11:23:09 <nshepperd> > big
11:23:12 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
11:23:15 <haasn> the fact that Eq Double violates reflexivity is, of course, another matter :)
11:23:24 <nshepperd> hmm
11:25:25 <dmwit> > fromInteger big :: Double
11:25:27 <lambdabot>  1.7976931348623157e308
11:25:31 <dmwit> haasn: not Infinity
11:26:04 <dmwit> > fromInteger (big+1) :: Double
11:26:06 <lambdabot>  Infinity
11:26:09 <dmwit> (yes, this one is Infinity)
11:26:36 <dmwit> > (1/0 :: Double) == (1/0)
11:26:38 <lambdabot>  True
11:26:55 <dmwit> Infinity == Infinity anyway, so that's not the problem.
11:27:05 <haasn> ah, you're right
11:27:35 <haasn> but `big` is the largest representable non-infinite double?
11:27:55 <inkbottle> haasn: what is your example contradicting reflexivity?
11:28:00 <haasn> inkbottle: NaN
11:28:03 <dmwit> haasn: I think so, yeah.
11:29:41 <nshepperd> > let f i = fromInteger i :: Double in f 9007199254740993 - 1 == f (9007199254740993 - 1)
11:29:43 <lambdabot>  False
11:29:48 <haasn> if we made `fromInteger` round numbers larger than `big` down to `big` instead of up to `Infinity` (until big2 = big + n as the smallest n where fromInteger big + fromInteger n == Infinity), it should satisfy f (x + y) = f x + f y now, no? (you can still break it with lack of associativity though)
11:30:10 <nshepperd> haasn: ^^
11:30:37 <haasn> I give up :)
11:31:21 <haasn> negative integers break rounding down
11:32:08 <nshepperd> > let f i = fromInteger i :: Double in f 9007199254740993 + 1 == f (9007199254740993 + 1) -- also
11:32:10 <lambdabot>  False
11:34:34 <dmwit> ?quote dmwit.*IEEE
11:34:35 <lambdabot> No quotes match. stty: unknown mode: doofus
11:34:40 <dmwit> ?quote dmwit IEEE
11:34:40 <lambdabot> dmwit says: For basically all good properties P, IEEE 754 is not P.
11:36:29 <doyougnu> hahaha
12:10:36 <Tuplanolla> Corollary: let P be "is IEEE 754"; if P is a basically good property, then "IEEE 754 satisfies not P" is equivalent to "IEEE 754 satisfies not being IEEE 754", which is a contradiction; therefore P, or "is IEEE 754", must be a bad property.
12:20:05 <dmwit> Tuplanolla: the logic checks out
12:21:02 <Tuplanolla> This also goes through if P is "is not IEEE 754", which is worrying.
12:21:40 <dminuoso> 21:09           haasn | [19:15:32] haskell types form a sort of pseudo-ring, with Either and (,)
12:21:58 <dminuoso> haasn: I think you meant to say "Hask is a subcategory of Set", right?
12:34:56 <wroathe> So I'm trying to write a function that does simple case analysis on a value of a generic representation type, and I start with something like: case from val of; M1 m0 -> ...
12:35:10 <wroathe> Obviously this gives me an error saying that the type of from val is ambiguous
12:35:37 <wroathe> So I need to specify teh generic representation type, and so I try to write something like case (rep :: Rep Foo ) of...
12:35:55 <wroathe> The problem is that Rep has kind * -> * -> *
12:36:11 <wroathe> The first type is my type that I have a generic instance for
12:36:16 <wroathe> But what is the second type?
12:37:17 <Solonarv> usually you need to use typeclasses when writing functions on generic representation
12:37:41 <Solonarv> the second type argument is a dummy variable, it isn't used
12:37:43 <wroathe> If I :t from foo in terminal I see something like D1 ... x
12:38:00 <Solonarv> it exists because Generic and Generic1 use the same representation
12:38:59 <wroathe> Yeah, I see that you generally use instances for this, but I'm trying to start from first principles and build up to that. In theory I should be able to specify the precise type of "from foo" in my code and be able to do case analysis on it
12:39:52 <wroathe> https://gist.github.com/JustinChristensen/6129325533770f8e7d77abf9c1b5e1ac
12:40:13 <wroathe> Somehow I have a value of this representation type, where that second type variable is just specified to be "x"
12:41:15 <wroathe> So in my function can I just specify that rep :: Rep Foo ()?
12:42:01 <Solonarv> no, you write your function for 'Rep Foo x'
12:42:38 <Solonarv> just leave it polymorphic
12:43:25 <wroathe> https://gist.github.com/JustinChristensen/09f935ba2c04408353a8fedcd636bf0e
12:44:07 <wroathe> Tells me that it couldn't match type Rep a with M1 ...
12:44:15 <wroathe> for rep
12:45:15 <wroathe> In this example Foo is a type with a single unary data constructor that contains a String
12:45:26 <Solonarv> well obviously you can't turn an arbitrary 'a' into 'Rep Foo'!
12:45:53 <Solonarv> your function's signature is more general than its implementation
12:45:58 <wroathe> doh
12:46:34 <Solonarv> getFoo :: Foo -> Maybe String, then the implementation will work
12:46:56 <wroathe> I'm an idiot. Thanks!
12:47:20 <Solonarv> also: you can nest constructors in patterns, so you could write 'case rep of M1 (M1 (M1 (K1 k0))) -> Just k0'
12:48:12 <wroathe> I've apparently had the blinders all day, because I knew that
12:48:23 <wroathe> But somehow I didn't do that :P
12:48:31 <wroathe> Thanks Solonarv 
12:48:43 <Solonarv> heh
12:50:09 <wroathe> What a surprise. It works.
13:02:11 <WilliamHamilton[> hi, I'd like some help in understanding how to adapt a monad transformer I found in a paper by prof. Hinze
13:02:16 <WilliamHamilton[> the definition is:
13:02:39 <WilliamHamilton[> type CPS a ans = (a -> ans) -> ans
13:02:40 <WilliamHamilton[> newtype BacktrT m a = BacktrT { (>>-) :: forall ans. CPS a (m ans -> m ans) }
13:03:13 <Solonarv> let's start by unpacking that type synoym:
13:03:23 <WilliamHamilton[> and it is meant to add backtracking behavior to a monad m
13:03:38 <WilliamHamilton[> Solonarv: wait, I understand what that means, let me tell where I'm stuck:
13:03:51 <Solonarv> newtype BacktrT m a = BacktrT { (>>-) :: forall r. (a -> m r -> m r) -> m r -> m r }
13:04:11 <Solonarv> (this is the same thing as the definition you gave)
13:05:57 <WilliamHamilton[> my problem basically is that I want to use a monad that threads state at the bottom, and I don't understand how to get a proper "extraction function"
13:06:08 <WilliamHamilton[> so, let's say that the monad I want to put at the base is
13:06:51 <WilliamHamilton[> StateT S (Except E) a
13:07:13 <WilliamHamilton[> the eliminator for BacktrT is:
13:07:41 <WilliamHamilton[> run (BacktrT m) = m (\a _ -> pure a) (error "no solution")
13:07:59 <WilliamHamilton[> where run :: BacktrT m a -> m a
13:08:09 <WilliamHamilton[> so if I have:
13:08:45 <WilliamHamilton[> BacktrT (StateT S (Except E)) a
13:09:46 <WilliamHamilton[> I can use the eliminator to get a `StateT S (Except E) a` and then use the run functions from mtl to unwrap that to a 
13:10:31 <WilliamHamilton[> Either E (a, S)
13:11:34 <Solonarv> tbh I don't quite understand this BacktrT
13:11:39 <Solonarv> can you link the paper?
13:11:41 <WilliamHamilton[> wow I'm winning the prize for muddy question, sorry
13:11:48 <WilliamHamilton[> sure
13:13:09 <WilliamHamilton[> https://www.cs.ox.ac.uk/ralf.hinze/publications/Prolog.ps.gz
13:14:05 <Solonarv> is there a pdf version?
13:14:07 <WilliamHamilton[> Solonarv: the derivation of that monad is very interesting because it's done completely by equational reasoning. The derivation begins at page 34
13:14:31 <WilliamHamilton[> I converted it locally with ps2pdf, where can I upload it?
13:14:51 <WilliamHamilton[> (I didn't find it online)
13:15:28 <Solonarv> urrr no idea, probably best not to anyway
13:15:32 <Solonarv> I'll convert it myself
13:16:49 <WilliamHamilton[> Solonarv: here in any case https://ufile.io/vgkve
13:18:04 <lyxia> WilliamHamilton[: what's the problem with run
13:18:13 <lyxia> other than the fact it uses error...
13:18:41 <WilliamHamilton[> lyxia: to not use error it suffices to wrap the extraction function in "sols", if you are reading the paper
13:19:03 <WilliamHamilton[> my problem is that this monad is meant to represent backtracking on an underlying monad which has state
13:19:19 <WilliamHamilton[> (not in the paper, but in my case), and I get an extraction function of type
13:19:29 <WilliamHamilton[> runLogic :: Logic a -> Either UnificationError ([a], Substitution)
13:19:30 <WilliamHamilton[> runLogic = runUnification . down . sols . unLogic
13:20:24 <WilliamHamilton[> look at the type: I don't want a list of solution with a single substitution, I want probably something like [(a, Substitution)]
13:21:07 <WilliamHamilton[> in other words, I want the state of the monad to be rolled back with the backtracking monad, while it seems that the state is brought always forward
13:21:48 <lyxia> is Logic defined in the paper
13:23:05 <lyxia> If all BacktrT operations are parametric in the monad m, without additional assumptions, that's the natural way of things.
13:23:59 <WilliamHamilton[> no, logic is a definition made by me, but equivalent to
13:24:13 <lyxia> I think I would see the problem much more clearly if you had some code in a gist and example of expected vs desired output.
13:24:46 <lyxia> rather than jumping around in a 30page PDF...
13:24:50 <WilliamHamilton[> `CutT (StateT S (Except E)) a` (CutT is in the paper)
13:25:52 <WilliamHamilton[> right, I have some code, but I don't know properly what the desired output is, other than I want it to behave "like a prolog". Let me throw it on github
13:28:02 <lyxia> to rollback state when backtracking, the standard way is to transform the nondeterminism monad with StateT, rather than the other way around (transform State with the nondet. transformer).
13:28:04 <dminuoso> Mmm, so `sell :: a -> Pretext a a` is a kind of "identity" for pretext? Im thinking about this: `id' :: Pretext s a -> Pretext s a; id' = experiment sell`
13:29:58 <WilliamHamilton[> lyxia: here's the file with the code https://github.com/meditans/unification-sop/blob/master/src/Generic/Unification/Hinze.hs#L256-L257
13:30:29 <WilliamHamilton[> if you use nix do `nix-shell` but first update the channel
13:31:14 <WilliamHamilton[> lyxia: so along the lines of `StateT S (BacktrackT ...) a`?
13:31:22 <lyxia> yes
13:32:22 <lyxia> @unmtl StateT s []
13:32:22 <lambdabot> Plugin `unmtl' failed with: `StateT s []' is not applied to enough arguments, giving `/\A. s -> [] (A, s)'
13:32:24 <lyxia> @unmtl StateT s [] a
13:32:25 <lambdabot> s -> [] (a, s)
13:32:40 <lyxia> @unmtl ListT (State s) a
13:32:41 <lambdabot> s -> ([] a, s)
13:32:54 <dminuoso> unmtl should be called untrans or something. :|
13:37:51 <WilliamHamilton[> lyxia: do you have in mind some code examples for the `StateT S (BacktrackT ...) a` approach?
13:38:19 <WilliamHamilton[> I'm not sure on how I would lift some operations in BacktrackT
13:43:29 <lyxia> what kind of operations? The Backtr class?
13:43:58 <WilliamHamilton[> lyxia: yes, exactly
13:46:23 <lyxia> amb (StateT f) (StateT g) = StateT \s -> amb (f s) (g s)    unwrap StateT arguments, and give them all the same state.
13:48:00 <WilliamHamilton[> lyxia: right, let me try that, I'll report back
13:50:17 <iqubic> What does amb do?
13:52:33 <lyxia> It's a class method, but the idea is that of Alternative's (<|>)
13:53:12 <lyxia> nondeterministic choice
14:05:58 <ottidmes> Is there an existing library that provides a command line confirm prompt? I looked at haskeline and managed to create something that does some of what I want it to do, but I was unable to recreate what I have in Bash: https://gist.github.com/ottidmes/01dc5fa29ff036f18c81b4793eeee892 
14:07:20 <ottidmes> The most important thing I seem to be missing is the ability to silently read the input, rather than see what I type in the terminal itself (i.e. Bash read its -s option)
14:27:26 <dmwit> ottidmes: https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#v:hSetEcho
14:35:04 <haasn> who disables terminal echo for a confirm prompt?
14:35:20 <ottidmes> dmwit: thanks! adding `hSetEcho stdout False` achieved what I wanted, for the escape character I could just try and see if I can replicate the getInputChar function without the filtering for printable chars, not sure how to handle enter yet though
14:35:23 <haasn> isn't it usually "Proceed? (y/n/?) " and then followed by your input
14:36:32 <ottidmes> haasn: yeah, but I want to allow Esc, Space, and Enter, too as alternatives, so I just want to print y or n for those too
14:36:58 <haasn> enter is dangerous
14:37:03 <haasn> so is space
14:37:04 <WilliamHamilton[> lyxia: in these  last instances https://github.com/meditans/unification-sop/blob/master/src/Generic/Unification/Hinze.hs#L281-L304 what should be the trick (expecially once and sols for StateT)
14:37:31 <haasn> ottidmes: if you want to allow enter as input then make sure to fully clear the input buffer before checking
14:37:54 <clever> haasn: i saw a reddit post about somebody helping their father setup the computer to rip some old audio tapes
14:37:58 <haasn> but that's also annoying because sometimes I just type "y<CR>" ahead of time
14:38:06 <clever> haasn: but when he left it to the father, it would stop recording after 5mins, every time
14:38:20 <clever> haasn: turns out, he was spamming space bar, every time the screensaver kicked in
14:38:37 <clever> space told the recording software to pause
14:39:10 <haasn> I often just spam <CR> into a terminal to insert vertical spacing
14:39:34 <clever> that reminds me of my own dad on an old unix like system (back in the 90's)
14:39:48 <clever> there was a lot of garbage being printed to the console (like echo foo > /dev/tty1)
14:39:56 <clever> and he would spam enter to get the screen clear
14:40:16 <clever> but, i can see why he did that, having come from a c64 background, where garbage on the screen actually gets ran when you <enter>
14:40:58 <ottidmes> haasn: for this use case I like being able to just hit enter or space, since its used more like a continue than some big decision
14:41:06 <clever> but now that ive been using linux for years, i can just blindly type into the spew of a background& process, and it still work perfectly
14:41:23 <clever> ottidmes: then just wait for the any key?
14:41:53 <day> i learned that i can access arbitrary datatype fields with their names. e.g. 'property_name data'. the reason this doesn't work for 'utSeconds getUnixTime' is because getUnixTime isnt guaranteed to return something?
14:41:56 <haasn> ottidmes: then it sounds like you definitely want to clear the input queue
14:42:21 <gentauro> what does the `hash` mean in this piece of code -> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Word.html#Word8
14:42:21 <haasn> if the user already has garbage in stdin when you ask the user to confirm if they want to continue, then there's no point in asking the question
14:42:38 <gentauro> % data Word4 = W4# Word
14:42:38 <yahb> gentauro: 
14:42:42 <ottidmes> haasn: yep, makes sense, thanks, I will look into doing that
14:42:45 <haasn> gentauro: it means it's a compiler built in
14:42:50 <haasn> usually
14:42:59 <gentauro> haasn: it doesn't work locally for me :(
14:43:02 <dmwit> It's a naming convention for unboxed primitives.
14:43:03 <haasn> -XMagicHash
14:43:08 <dmwit> You need MagicHash for it to work.
14:43:16 <gentauro> thx
14:43:25 <haasn> and yeah on constructors it's just a naming convention
14:44:06 <haasn> But the Word# part is a compiler built in I believe
14:44:45 <gentauro> % data Word8 = W8# Word#
14:44:45 <yahb> gentauro: 
14:44:58 <gentauro> only the first `magic hash works` not the second ...
14:45:05 <gentauro> do I need more LANGUAGE pragmas?
14:45:20 <haasn> do you have Word# in scope?
14:45:52 <ottidmes> clever: I want it to be reusable outside just confirming to proceed, so I stick with specific keys for yes and no
14:45:53 <gentauro> isn't `Word` always in scopre?
14:45:55 <Solonarv> # as part of identifiers has no special meaning at all, it's purely a naming convention
14:45:59 <Solonarv> Word is, Word# isn't
14:46:14 <Solonarv> (er, perhaps Word isn't either, I'm not sure)
14:46:23 <gentauro> `Not in scope: type constructor or class ‘Word#’`
14:46:24 <haasn> Word is in Prelude now, I've heard
14:46:33 <gentauro> ahh
14:47:25 <ottidmes> haasn: would `hSetBuffering stdin NoBuffering`, be enough to make sure nothing is already in stdin?
14:47:44 <haasn> ottidmes: I don't think that applies retroactively?
14:47:53 <haasn> But I don't know, test it
14:48:33 <ottidmes> haasn: I think it does, if I read the description right: https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#v:hSetBuffering
14:49:41 <haasn> ottidmes: yeah seems like it
14:49:50 <gentauro> % data Word8 = W8# Word#
14:49:50 <yahb> gentauro: 
14:49:55 <gentauro> can get it to work :-\
14:50:26 <haasn> ottidmes: what if the input mode is already NoBuffering?
14:50:51 <gentauro> I looked in `Data.Word` and `Prelude` and no `Word#`.
14:51:04 <haasn> ottidmes: also, what if the source pipe has more data buffered on the send side than your line/block buffer size?
14:51:23 <haasn> I think there's no way around exhaustively reading from the handle
14:52:49 <gentauro> oh, found it (hoogle) -> https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Exts.html#t:Word-35-
14:52:59 <ottidmes> haasn: hmm, too many cases to consider indeed, so you would suggest just doing `getContents` before my confirm, right?
14:53:30 <haasn> That won't work either (lazy I/O, blocking)
14:53:39 <haasn> you would have to do non-blocking reads
14:53:41 <haasn> until they fail
14:54:00 <ottidmes> "which is read lazily as it is needed" right
14:54:15 <haasn> or just give up the idea of forcing users to press a key to make your program continue doing work :p
14:56:15 <ottidmes> haasn: well it works fine in both Bash and Rust, even if I dont consider those cases you mentioned, I am fine with that
14:56:38 <haasn> I mean in terms of a UX thing, not an implementation thing
14:56:56 <monochrom> I wouldn't give up, but I would learn Unix tty technicality, and then how much of it corresponds to System.IO's hSetEcho and buffering etc.
14:57:39 <monochrom> Litmus test: If you haven't heard of "cooked mode" you are not ready.
14:57:49 <lyxia> WilliamHamilton[: once (ExceptT t) = ExceptT (once t)
14:57:56 <ottidmes> I am surprised this is not already in some library
14:58:02 <haasn> :t untilM
14:58:03 <lambdabot> error:
14:58:03 <lambdabot>     • Variable not in scope: untilM
14:58:03 <lambdabot>     • Perhaps you meant ‘until’ (imported from Prelude)
14:58:06 <haasn> :(
14:58:56 <monochrom> Well I think basically people either do very simplistic stdin getLine putStr or they go all out to complete terminal programming e.g. curses or vty.
14:59:10 <lyxia> WilliamHamilton[: sols is strange
14:59:53 <WilliamHamilton[> lyxia: wait `once (ExceptT t) = ExceptT (once t)` doesn't typecheck
15:00:08 <haasn> untilM isEOF getChar
15:00:24 <haasn> (with suitable untilM)
15:00:33 <WilliamHamilton[>     • Couldn't match type ‘Maybe (Either e a)’ with ‘Either e (Maybe a)’
15:01:08 <lyxia> ohhh
15:01:39 <WilliamHamilton[> lyxia the problem is that in sols and once none of the types seem isomorphic. Could it be a good idea to scrap once and sols from the typeclass and use them only in the `run..` functions?
15:01:58 <WilliamHamilton[> lyxia: because it seems to me that the problem is semantic here
15:02:28 <WilliamHamilton[> (unless there is a way of writing those functions, of course)
15:02:45 <lyxia> I'm not sure what it would mean to use them only in the run functions
15:02:57 <monochrom> Hrm interesting, isEOF attempts reading, can block.
15:03:05 <lyxia> but there doesn't seem to be a way to write those functions without constraints on e and s.
15:03:13 <WilliamHamilton[> lyxia: like in this function https://github.com/meditans/unification-sop/blob/master/src/Generic/Unification/Hinze.hs#L285-L286
15:03:30 * hackage gscholar-rss 0.2.1.0 - scrapes google scholar, provides RSS feed  https://hackage.haskell.org/package/gscholar-rss-0.2.1.0 (fffaaa)
15:03:57 <haasn> monochrom: I think that's only really relevant for actual files
15:04:09 <haasn> for example a Handle pointing at a network share file
15:04:22 <WilliamHamilton[> lyxia: what constraints on e and/or s would make that function work? Do you have something in mind?
15:04:23 <haasn> simply checking to see if you're at eof can and will block indefinitely
15:06:00 <lyxia> WilliamHamilton[: not anything concrete, I'm not familiar enough with the intended semantics of that class, and I wouldn't hope that the constraints would fit your use case anyway.
15:06:03 <monochrom> Yeah there have been two schools for the semantics of "test for eof".  The Pascal one and the C one.
15:07:02 <monochrom> The Pascal one is like intuitionistic constructivist logic.  If not eof, it means it has ascertained that your next read is non-empty.  So the test itself already has to read for 1 byte.
15:08:08 <monochrom> The C one is like double negation of that.  If not eof, it means it does not have proof that you have hit the end.  So it just has to look at history, e.g., "oh last time you read it was non-empty".
15:08:27 <monochrom> So IIRC GHC or base used to be the C kind.
15:08:59 <monochrom> But right now I am taking a look at the current source code and it looks like the Pascal kind.
15:10:28 <Tuplanolla> Perhaps this absurd example from mathematical philosophy will help, he thought.
15:12:23 <monochrom> Oh bringing up intuitionistic logic always helps in a channel full of Curry-Howard fanatics.
15:13:35 <iqubic> In the set of possible Isomorphisms, that one is my favorite.
15:13:46 <monochrom> QED
15:14:12 <iqubic> Huh??
15:14:18 <iqubic> Oh, I see.
15:14:24 <koz_> monochrom: Lol.
15:14:43 <iqubic> You are saying that my statement proves your point, which it totally does.
15:21:03 <ottidmes> haasn: probably should try and do your input cleaning, but this now at least works: https://gist.github.com/ottidmes/01dc5fa29ff036f18c81b4793eeee892#file-confirm-hs I dropped the use of Haskeline, did not seem to fit my use case
15:23:40 <monochrom> chr 27 can be written as '\27'
15:24:42 <ottidmes> monochrom: ah, thanks! and I guess putStrLn is safe to be putStr '\n' considering hSetNewlineMode's default of converting them
15:24:56 <monochrom> Yes.
15:24:58 <geekosaur> "" not ''
15:25:11 <ottidmes> geekosaur: yeah meant putChar '\n'
15:26:40 <monochrom> > "\^@ \^[ \^\ \^] \^_"
15:26:42 <lambdabot>  "\NUL \ESC \FS \GS \US"
15:27:11 <monochrom> > map ord "\^@ \^[ \^\ \^] \^_"
15:27:13 <lambdabot>  [0,32,27,32,28,32,29,32,31]
15:27:32 <monochrom> Aw, pardon for all the 32 fillers!
15:27:59 <monochrom> > ord '\^^'
15:28:01 <lambdabot>  30
15:28:23 <WilliamHamilton[> lyxia: just for curiosity, here's how the instances probably should look like https://github.com/meditans/unification-sop/blob/master/src/Generic/Unification/Hinze.hs#L295-L313 (it's based on my semantic intuition, not sure they're right). Anyway, thanks for the help, the turning point for me was realizing that Backtr was morally ListT and so it should have been on the bottom of the stack!
15:29:58 <ottidmes> monochrom: cool, I will be using \ESC then, much more readable then some number :)
15:30:15 <monochrom> Yeah!
15:52:50 <haasn> ottidmes: monochrom: it can also be written as '\ESC', which is what I would recommend
15:53:05 <monochrom> Already did!
15:57:00 <haasn> oops
15:57:56 <isTofu> :|
15:58:05 <isTofu> I like how if i spell haskell wrong
15:58:11 <isTofu> it brings me here still 
15:58:12 <isTofu> lol
15:59:50 <ottidmes> haasn: monochrom: now I got https://gist.github.com/ottidmes/01dc5fa29ff036f18c81b4793eeee892#file-confirm-hs which makes it match the Bash version. I did test writing to stdin beforehand and it does indeed use that as expected. I tried clearing it, but both attempts failed (but I do not consider it a must, am already happy I managed to get it working the way I wanted it to work :))
16:05:26 <monochrom> ottidmes: I wonder if hReady helps.
16:15:59 * hackage waargonaut 0.5.2.2 - JSON wrangling  https://hackage.haskell.org/package/waargonaut-0.5.2.2 (schalmers)
16:20:29 * hackage leanpub-concepts 1.0.0.0 - Types for the Leanpub API  https://hackage.haskell.org/package/leanpub-concepts-1.0.0.0 (chris_martin)
16:21:30 * hackage leanpub-wreq 1.0.0.0 - Use the Leanpub API via Wreq  https://hackage.haskell.org/package/leanpub-wreq-1.0.0.0 (chris_martin)
16:22:03 <ottidmes> monochrom: if I just do this: tty <- openFile "/dev/tty" ReadMode, it does have an empty input
16:23:40 <dmwit> I did not know about \^
16:27:30 * hackage leanpub-concepts 1.0.0.1 - Types for the Leanpub API  https://hackage.haskell.org/package/leanpub-concepts-1.0.0.1 (chris_martin)
17:01:14 <fen> can we do profunctors over (++) ?
17:02:36 <fen> there seem to be 3 lists we can get at, and one function from list to list. is that a different function? are there 3 or 4 different functions here?
17:09:19 <fen> % :t \ a b -> (a ++ b)
17:09:19 <yahb> fen: [a] -> [a] -> [a]
17:09:50 <fen> % :t (\ f a b -> (f a ++ b),\ f a b -> (a ++ f b),\ f a b -> f (a ++ b))
17:09:50 <yahb> fen: ((t1 -> [a1]) -> t1 -> [a1] -> [a1], (t2 -> [a2]) -> [a2] -> t2 -> [a2], ([a3] -> t3) -> [a3] -> [a3] -> t3)
17:10:31 <fen> :t % (\ f a b -> rmap f (++ b),\ f a b -> rmap f (a ++ ))
17:10:32 <lambdabot> error: parse error on input ‘%’
17:10:42 <fen> % :t (\ f a b -> rmap f (++ b),\ f a b -> rmap f (a ++ ))
17:10:42 <yahb> fen: (([a1] -> c1) -> p1 -> [a1] -> [a1] -> c1, ([a2] -> c2) -> [a2] -> p2 -> [a2] -> c2)
17:11:09 <fen> % :t (\ f a b -> (rmap f (a ++ )) b,\ f a b -> a (rmap f (++ b)))
17:11:10 <yahb> fen: (([a1] -> t1) -> [a1] -> [a1] -> t1, ([a2] -> c) -> (([a2] -> c) -> t2) -> [a2] -> t2)
17:11:33 <fen> % :t (\ f a b -> a (rmap f (++)) b,\ f a b -> a (lmap f (++)) b)
17:11:33 <yahb> fen: ((([a1] -> [a1]) -> c) -> (([a1] -> c) -> t1 -> t2) -> t1 -> t2, (a2 -> [a3]) -> ((a2 -> [a3] -> [a3]) -> t3 -> t4) -> t3 -> t4)
17:11:50 <fen> so much profunctors
17:12:34 <fen> probably could do the with lmap too
17:12:47 <fen> sure some of these must be the same as each other
17:13:34 <fen> seems to be like the key point is about (++) :: [a] -> [a] -> [a] being equal to [a] -> ([a] -> [a])
17:14:00 <fen> so there can be functions over ([a] -> [a]) as well as just over each of the input and the output list
17:14:59 <fen> not sure what the other varients correspond to
17:15:36 <fen> or if there is one with ([a] -> [a]) -> [a], which seems backwards of how haskell does things
17:16:07 <utdemir> dmwit: I just saw your messages. You're looking for the 'foldl' library.
17:17:53 <fen> argh one of those is wrong, which does not use both a and b
17:32:41 <fen> hmm, maybe its this one;
17:32:42 <fen> % :t \ f a b -> ((rmap f ( ++)) a b)
17:32:42 <yahb> fen: (([a] -> [a]) -> t1 -> t2) -> [a] -> t1 -> t2
17:35:43 <fen> % :t \ a b -> ((rmap id (++)) a b)
17:35:43 <yahb> fen: [a] -> [a] -> [a]
17:36:06 <fen> % :t \ a b -> ((rmap (\f -> f . f) (++)) a b)
17:36:06 <yahb> fen: [a] -> [a] -> [a]
17:36:38 <fen> (rmap (\f -> f . f) (++)) "hello" "profunctor"
17:36:46 <fen> % (rmap (\f -> f . f) (++)) "hello" "profunctor"
17:36:46 <yahb> fen: "hellohelloprofunctor"
17:37:36 <fen> can this be done on the other side too?
17:39:23 <dmwit> utdemir[m]: What messages are you talking about?
17:39:33 <dmwit> utdemir[m]: (What makes you say I'm looking for the foldl library?)
17:39:57 <fen> % flip ((rmap (\f -> f . f)) (flip (++))) "hello" " profunctor "
17:39:57 <yahb> fen: "hello profunctor profunctor "
17:41:28 <fen> it would be good to be able to understand this like instead of applying something to the arguments before they go in to (++), that the (++) is applied to the argument and then the function goes inbetween it and the next argument
17:41:49 <fen> ie not like;
17:41:49 <fen> % :t (\ f a b -> (f a ++ b),\ f a b -> (a ++ f b),\ f a b -> f (a ++ b))
17:41:49 <yahb> fen: ((t1 -> [a1]) -> t1 -> [a1] -> [a1], (t2 -> [a2]) -> [a2] -> t2 -> [a2], ([a3] -> t3) -> [a3] -> [a3] -> t3)
17:46:11 <fen> % :t \ f a b -> (rmap f) (++) a b
17:46:11 <yahb> fen: (([a] -> [a]) -> t1 -> t2) -> [a] -> t1 -> t2
17:46:34 <fen> :t \ f a b -> (f (a ++)) b
17:46:36 <lambdabot> (([a] -> [a]) -> t1 -> t2) -> [a] -> t1 -> t2
17:46:41 <fen> right?
17:48:56 <fen> basically, want to be able to say that (++) is some other function created from (:) with some profunctoring
17:49:24 <fen> and then extend this process to more general containers
17:50:04 <fen> gona have to take this up some other time
19:20:08 <mniip> hololeap, and he replied!
19:40:21 <fen> append :: Append f' f => f' a -> f a -> f a
19:41:03 <fen> set_r :: Set_r r f => r f => r a -> f a -> f a
19:41:24 <fragamus> In this article it talks about DeriveFunctor:
19:41:24 <fen> type Set_r r f = Mono r => Append r f
19:41:25 <fragamus> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/DeriveFunctor#DeriveFunctor
19:41:39 <fragamus> and I want to understand the use of $ in that
19:42:30 <fen> type Set_i i f = Set_r ((,) i) f
19:43:26 <fen> obvious instance Mono ((,) i)
19:44:21 <fragamus>  $(fmap 'a 'b)          =  \x -> x     -- when b does not contain a
19:44:27 <fen> type Create f = Set_r Identity f
19:44:32 <fragamus> what is that $
19:44:46 <MarcelineVQ> it's a template haskell splice
19:44:53 <fen> fragmus, looks like how to create a continuation?
19:45:21 <fragamus> ooooohhhhhhkaaaayyyyy
19:45:44 <MarcelineVQ> that is to say it's the syntax for one, I'm not sure if it is one on the page
19:46:22 <MarcelineVQ> kind of looks like its own notation here
19:46:37 <fragamus> so $(pattern in here) = gets replaced by this over here
19:48:01 <fen> now if there is a Create f' instance, and an Append f' f instance, then if there is also functions i -> f' a -> f' a, or i -> f a -> f a, then these can be composed on either side of append
19:48:32 <fen> and it would be nice to see how this is actually a way to kind of make something like Create_i
19:48:36 <MarcelineVQ> in this case that's what it looks like, I'm not sure if there's more significance to why they chose this notation that so resembles th or not
19:51:44 <fen> \ i i'. (a -> f' a) . (i -> f' a -> f' a) . (f' a -> f a -> f a) . (i' -> f a -> f a) = \ ((i,i'),a) -> f a -> f a, that is set_i = set_r when r = ((,) (i,i'))
19:52:45 <fen> then if there is like [j] and j -> Either i i' , then can have ([j],a) -> f a -> f a
19:53:20 <fen> and then seek get_i :: Get_i [j] f => f a -> (([j],a),f a)
19:53:46 <fen> which is again the mono restriction of the inverse of Append
19:57:24 <fen> and then there is an example of appending to Free [] where its just (:) fmapped to some depth
19:57:39 <fen> that doesnt use the i'
19:58:51 <fen> but if its a pointer over Free [] left navigated to the first value, then it has to go up to the depth, using i' = [()] === Int
19:59:33 <fen> then attatch is used, on some column shaped thing, just nested Free [] with one value per [] until Pure a 
20:00:33 <fen> thats create === Pure (modulo Identity) and then i = [()] === Int applications of Free . (:[])
20:02:01 <fragamus> Thank you MarcelineVQ
20:02:41 <fen> these 2 examples show how all "one value" appends (set_i) are made from a deafult unparametrised append, and default unparametrised create, and then actions on either side of the append
20:02:42 <fen> (s/attach/append)
20:03:21 <geekosaur> More formally, we write the derivation of fmap code over type variable
20:03:21 <geekosaur> 'a for type 'b as ($fmap 'a 'b)
20:03:31 <geekosaur> in the text just above that
20:04:06 <geekosaur> which looks like they typoed either that or the example, so I'm guessing the above because there's only one of it
20:04:26 <fen> the index [j] === (Int,Int) === ([()],[()]) with j -> Either () ()
20:05:45 <fen> maybe thats not a good way to split the `j' into index over "things that go before or after" the append...
20:06:16 <fen> the idea is that as its a hamiltonian path for traversable containers, there are only 2 choices
20:06:28 <fen> before the append, navigate a pointer if it is one
20:07:07 <fen> and after the append (to the left of it), grow a one value container to be appended 
20:08:09 <fen> and the example of the Free [] which isnt a pointer, where the fmap to some depth is instead of navigating the pointer up to that place, its an action on the partially applied append, instead of on the second argument
20:08:18 <fen> hence the profunctor madness
20:10:33 <fen> and despite there only being these 2 options (j spliting into actions before and after the append) it need not be j -> Either () (), and things more complex than () can be used to sequentially grow the one-valued f' or navigate over the f
20:11:48 <fen> so there is something like insert over lists, where an Int governs where the extra list is inserted (for lists its just (:[]) there is nothing else to do to grow the one value container being appended)
20:12:47 <fen> but here, with this Int being like [()] and the () navigating between successive positions in the list, it can be then seen how a Tree could be navigated over to some position to insert something with [j] with j /= ()
20:13:16 <fen> and here of course there is something to do on the lhs of the append to make a shaped branch to insert also
20:50:00 * hackage function-builder 0.1.1.0 - Create poly variadic functions for monoidal results  https://hackage.haskell.org/package/function-builder-0.1.1.0 (SvenHeyll)
21:43:59 <utdemir> Does anyone know a compression library which allows starting decompression from an arbitrary point in the file?
21:58:02 <fresheyeball> error:ghc: internal error: Unable to commit 1048576 bytes of memory
21:58:09 <fresheyeball> because I am using `encode` from Aeson
21:58:11 <fresheyeball> WTF
22:17:29 * hackage basement 0.0.9 - Foundation scrap box of array & string  https://hackage.haskell.org/package/basement-0.0.9 (VincentHanquez)
22:18:30 * hackage foundation 0.0.22 - Alternative prelude with batteries and no dependencies  https://hackage.haskell.org/package/foundation-0.0.22 (VincentHanquez)
23:26:59 * hackage assoc 1 - swap and assoc: Symmetric and Semigroupy Bifunctors  https://hackage.haskell.org/package/assoc-1 (phadej)
23:30:24 <trcc> So I have this package for creating simulation units (SU) that I am developing. The final result must be in shape of a shared library. I therefore have some FFI as well. My question is, how do I pass the C files required along and ensure the developer uses them in their cabal file? Should I do something similar to hakyll, where there is an init function that creates a starting cabal file, or are there any good ideas?
23:35:31 <utdemir> trcc: Is using Nix an option?
23:35:39 <trcc> utdemir: Unfortunately not
23:37:20 <fen> whats the version of rmap for functions of 2 variables?
23:37:37 <fen> % :t rmap
23:37:38 <yahb> fen: Profunctor p => (b -> c) -> p a b -> p a c
23:37:40 <utdemir> trcc: Sorry, other than looking at the existing libraries with FFI, I don't have any ideas then.
23:38:03 <trcc> utdemir: are you familiar with any ffi libraries that I could look at?
23:38:26 <fen> Profunctor p => (c -> d) -> (p a (p b c)) -> (p a (p b d))
23:39:23 <utdemir> trcc: zlib and hsopenssl come to my mind that use FFI.
23:39:32 <trcc> ok thank you.
23:39:42 <trcc> but they probably do not require compilation to a shared library
23:40:03 <fen> % :t rmap . rmap
23:40:03 <yahb> fen: (Profunctor p1, Profunctor p2) => (b -> c) -> p1 a1 (p2 a2 b) -> p1 a1 (p2 a2 c)
23:40:04 <trcc> I'll probably try to approach with generating a initial cabal file
23:42:42 <fen> % :t rmap . lmap :: Profunctor p =>  (a -> b) -> p a (p b c) -> p a (p a c)
23:42:42 <yahb> fen: Profunctor p => (a -> b) -> p a (p b c) -> p a (p a c)
23:43:45 <fen> :t lmap  :: Profunctor p =>  (x -> a) -> p a (p b c) -> p x (p b c)
23:43:47 <lambdabot> Profunctor p => (x -> a) -> p a (p b c) -> p x (p b c)
23:46:25 <fen> % :t rmap  :: Profunctor p =>  (p b b -> p b b) -> p a (p b b) -> p a (p b b)
23:46:25 <yahb> fen: Profunctor p => (p b b -> p b b) -> p a (p b b) -> p a (p b b)
