00:56:30 <Orbstheorem> How do you read `<*>`?
00:57:48 <pavonia> "applied over" according to https://wiki.haskell.org/Pronunciation
00:58:36 <Orbstheorem> Oh, thanks for the link!
01:04:17 <mniip> do people pronounce f . g   "f ring g"
01:04:25 <mniip> I kinda got used to calling it "f circ g" xD
01:04:37 <tdammers> I have a better solution
01:04:41 <tdammers> don't pronounce them at all
01:04:43 <tdammers> write them down
01:05:21 <mniip> ye but when talking to people
01:05:26 <mniip> with your mouth
01:05:26 <M2tias> tdammers: so you talk to someone then stop in the middle of sentence, write a couple of words on the paper and then continue?
01:05:50 <M2tias> mniip: f dot g? that's how I thought it was
01:05:58 <merijn> Honestly, the answer to "how do you read <*>?" for me is "I don't"
01:06:02 <mniip> well
01:06:06 <M2tias> mniip: or "compose"
01:06:11 <mniip> in mathematics it's spelled with a circle
01:06:19 <mniip> which is TeXed with \circ
01:06:34 <merijn> M2tias: "use applicative"
01:06:49 <merijn> M2tias: I don't think I've ever had to literrally read code out loud
01:06:54 <M2tias> merijn: sorry?
01:07:28 <merijn> M2tias: Any combination of <$> or <*> I'll just summarise as "via applicative" or whatever
01:07:43 <M2tias> oh, it was mniip who asked but ok
01:08:10 <M2tias> mniip: as far as I know, in math f . g is pronounced "f-compose-g" or somehting like that
01:08:34 <tdammers> M2tias: yeah, pretty much. The kind of situation where I'd go into this much detail, I generally have a computer, pen and paper, or a whiteboard at hand anyway
01:08:52 <M2tias> I guess that makes sense
01:09:08 <tdammers> I'd go, "OK, so I'd use composition in this case, like so:" *writing* `let h = f . g in ...`
01:09:33 <bor0> "f-oh-g" is also a common pronunciation
01:09:44 <M2tias> if I'd talk about code (Java or something else) I'd probably talk about it in a very high level way, or in pseudoish kind of way that doesn't have to care about the syntax
01:09:52 <Orbstheorem> I use "f-oh-g" in english
01:09:53 <M2tias> but Haskell is different for me
01:10:23 <Orbstheorem> or “composed”
01:10:24 <mniip> eta is a natural transformation from F to G if forall h, Gh circ eta = eta circ Fh
01:10:25 <tdammers> what makes Haskell so different?
01:11:38 <mniip> tdammers, because in java to talk about a concept that fits in a sentence you need a page of code
01:11:44 <mniip> and in haskell you can get away with a single line
01:11:49 <mniip> that is sometimes easy to pronounce
01:12:03 <M2tias> tdammers: I don't know much about it. I read a book and then haven't done anything in 2 years, so if I talk about it, it's basics and syntax
01:12:39 <ion> mniip: "f after g" is one option.
01:12:58 <esp32_prog> this is function composition, f.g(x) = 'f of g' or 'f after g' or 'f on g' accroding to wikipedia
01:13:41 <ion> I would think "f of g" is f g.
01:14:07 <esp32_prog> or 'f composed with g' or 'f aboug g', or 'f circle g'
01:16:22 <M2tias> so basicly "f <anything> g" works
01:18:29 <bkerin> i got a functional programming sort of question thought this channel might be able to help
01:19:40 <bkerin> I'm looking at a C language Functor class, and trying to add an iterate method
01:20:35 <bkerin> I'm wondering if it makes sense to allow e.g. iterate(some_ftor, 0)
01:29:39 <merijn> Yes, no, maybe? I'm not even sure what you intend that to mean?
01:29:57 <merijn> Also, do you mean a functor as in Haskell, or C++ "functors"?
01:30:45 <tdammers> Also, do you mean "class" like in C++, or "class" as in Haskell typeclass?
01:41:42 <kuribas> Suppose I have an record type, representing attributes that are set in different stages of the program.  I could use Maybe, but then I don't get a garantee that the attribute is set.
01:42:32 <kuribas> I could use a functor for each attribute, like "time Time", where time can be Maybe, Const (), or Identity
01:42:52 <kuribas> But then I get a lot of type variables, making it unwieldy...
01:43:17 <tdammers> one popular approach is to make the data structure polymorphic over some functor f, e.g. data Options f = { optionTime :: f Time, optionPlace :: f Place, ... }
01:43:34 <merijn> kuribas: Just take the functor approach in type alias them?
01:43:42 <kuribas> tdammers: yeah, that's what I mean, but with different type variables
01:43:53 <tdammers> why do you need different ones though?
01:44:12 <kuribas> because I have different attributes
01:44:21 <kuribas> which are set at different times
01:44:26 <tdammers> but the functor is going to be the same, no?
01:44:33 <kuribas> no
01:44:37 <tdammers> or do you want to enforce the staging at the type level too?
01:44:40 <kuribas> yeah
01:44:46 <olligobber> good idea
01:44:51 <tdammers> in that case I'd split up the data structure, one record type per stage
01:44:59 <tdammers> and then assemble them into the final thing later
01:45:21 <kuribas> hm, and maybe lenses to make it managable
01:45:25 <tdammers> sure
01:45:39 <kuribas> maybe even overloaded records
01:45:40 <tdammers> or maybe record wildcards and/or name puns
01:45:47 <tdammers> something like that, yeah
01:47:42 <kuribas> ok, thanks
02:20:33 <kuribas> I had a crazy idea: what if I use a type level map for containing the functors...
02:20:46 <kuribas> MyStruct (m :: Map Symbol f)
02:20:52 <merijn> kuribas: That is, indeed, a crazy idea :)
02:21:07 <merijn> And I will go ahead and predict that you will regret having it ;)
02:22:01 <kuribas> possibly
02:22:04 <tdammers> not if you use a dependently typed language
02:22:11 <tdammers> dependent types will make all problems go away
02:22:18 <tdammers> just like nuclear fusion
02:22:25 <kuribas> yeah, I should write my program in idris...
02:23:01 <kuribas> why do people dislike dependent types?
02:23:10 <maerwald> dislike?
02:23:21 <maerwald> That's like asking why you dislike using a microscope for reading a book
02:23:43 <maerwald> because most of the time that's not really what you want nor need
02:23:45 <merijn> kuribas: Who said anything about dislike?
02:24:00 <maerwald> The question is why would you want this in a general purpose language
02:24:17 <maerwald> It introduces a lot of complexity and forces you to have another layer of reasoning
02:24:27 <maerwald> You want this more in specialized domains, not everywhere
02:24:34 <kuribas> maerwald: because of enforcing invariants.  Because you don't need a second language for type level computations.
02:25:28 <maerwald> doesn't sound like a good argument to clutter an entire language and ecosystem with it
02:25:53 <maerwald> expressivity always comes with a price. It's not about whether you like a feature or not
02:26:07 <maerwald> It's about balance. If there is no balance, you get Scala/C++/...
02:26:48 <maerwald> there are nice languages that already have dependent types
02:27:20 <kuribas> haskell is already cluttered at the type level
02:27:38 <maerwald> I even remember edward saying he is not too fond of having dependent types in haskell (because he would use Coq for those problems), but don't quote me on that. Will have to grep the irc log for it
02:28:37 <maerwald> yes, it is already cluttered
02:28:53 <maerwald> we could just give up and throw the haskell report out of the window ;)
02:29:08 <maerwald> reasoning and specs? No, I want features!
02:29:20 <kuribas> I want both
02:30:05 <maerwald> imo, dependent types is not something you can retrofit into a language, but that's just my opinion. It's like you start with an untyped language, develop it for 2 decades and then start trying to retrofit strong types (see python)
02:30:12 <maerwald> doesn't work well, is not pretty
02:30:15 <kuribas> perhaps not
02:30:16 <tdammers> I'm not fundamentally opposed to dependent types, it's just that current implementations have some awkward downsides to them (the popular "Is Idris production-ready?" meme kind of hints at that)
02:30:45 <tdammers> retrofitting dependent types onto Haskell is awkward, and I don't expect it to become comfortable anytime soon
02:30:47 <kuribas> tdammers: doesn't that have more to do with availability of libraries, ecosystem, etc... ?
02:30:56 <ziman> what you say sounds like the problems you'd solve with dependent types ("i'd use Coq for them") are different from those you'd solve with Haskell
02:31:19 <maerwald> Yes, I think that's basically the point
02:31:28 <kuribas> It's just that to do cool stuff like generic-lens, you need so many type level hacks.
02:31:31 <tdammers> yes, but also with the fact that building a performant compiler for a dependently typed language that produces performant code turns out to be quite difficult
02:31:34 <maerwald> There are some "higher level" features that shouldn't be part of a "general purpose language"
02:32:15 <kuribas> tdammers: the type level language is more like a logic language, right?
02:32:36 <kuribas> those exist and are performant enough
02:32:49 <tdammers> kuribas: there is no "type level", really, it all collapses into the same language, really. That's the whole point of dependent types.
02:33:24 <kuribas> then how does type inference work in a dependent language?
02:33:33 <__monty__> kuribas: It doesn't : )
02:33:43 <kuribas> ah :)
02:34:04 <ziman> it does and it's more powerful
02:34:26 <ziman> because it can infer your programs from types for you, not just the types, plus fill in missing terms, not just the types
02:34:29 <__monty__> ziman: It's undecidable, right?
02:34:30 <merijn> "It does, but with caveats and limitations"
02:34:54 <merijn> __monty__: You can have decidable type inference "in context" but not for the full program
02:34:57 <__monty__> ziman: Program inference is not type inference.
02:35:00 <ziman> SMT solving is also NP-complete, yet we have performant solvers
02:35:10 <merijn> So basically, you need *some* types to be able to infer
02:35:33 <__monty__> merijn: Yes, but it seemed to me when working in agda that type inference was basically never possible?
02:36:07 <__monty__> ziman: NP-completeness is not the same thing as undecidability.
02:36:07 * hackage TypingTester 0.1.0.5 - Command Line Typing speed tester  https://hackage.haskell.org/package/TypingTester-0.1.0.5 (AlanHawkins)
02:36:22 <phadej> because Agda doesn't infer, it elaborates and unifies omitted pieces
02:36:22 <kuribas> I'd be happy to have the burden of termination on the programmer.
02:36:23 <merijn> __monty__: The fact that it is theoretically possible doesn't mean Agda does that :)
02:36:32 <ziman> in theory, yes, things are undecidable; in practice, they work alright
02:36:51 <ziman> in agda, you get loads of inference going on, filling in all implicits and stuff for you, too
02:37:02 <ziman> whether they are terms or types
02:37:04 <phadej> i'd call that elaboration
02:37:07 <phadej> not inference
02:37:22 <phadej> e.g. agda doesn't "infer" the types whe nyou do pattern match
02:37:26 <phadej> those have to be provided
02:37:41 <phadej> but there are also not so explicit ways to give that information
02:38:06 * hackage timeconsole 0.1.0.4 - time each line of terminal output  https://hackage.haskell.org/package/timeconsole-0.1.0.4 (AlanHawkins)
02:38:43 <ziman> i prefer to write types and have my programs inferred from my intention, rather than having agda guess what i meant with this program
02:38:57 <phadej> for example ,agda doesn't ever generalise signatures
02:39:16 <phadej> neither it specialise, the implicit arguments are annotated
02:39:43 <phadej> and you have to be careful what arguments you leave implicit; because it often doesn't know what would fit
02:40:06 <kuribas> yeah, the future of programming is write just types and properties, and have the compiler write the code :)
02:40:38 <phadej> TL;DR the "convienence" of not writing the raw "Core" is quite different in Haskell and Agda
02:41:19 <phadej> raw = fully explicitly type-annotated
02:44:42 <maerwald> no, the future of programming is not types nor properties, it's pictures, models and specifications
02:45:09 <maerwald> text is already awful for programming
02:45:11 <ziman> anyway, i don't see a reason to switch to Coq when all i want is a nicer and simpler version of Servant or Esqueleto
02:46:02 <kuribas> maerwald: there have been quite a few non-textual programming language experiments, and all of them have failed
02:46:12 <kuribas> ziman: +1
02:46:13 <maerwald> there are some in use in automotive industry :)
02:46:19 <maerwald> But it's all proprietary
02:46:21 <maerwald> and domain specific
02:49:07 * hackage alist 0.1.0.4 - lists with O(1) append  https://hackage.haskell.org/package/alist-0.1.0.4 (AlanHawkins)
02:51:00 <tdammers> one great thing about text is that it can fold multiple dimensions of structure into a 2-dimensional (or even 1-dimensional) representation
02:51:28 <tdammers> it is by no means "awful"
02:51:37 * hackage JSONParser 0.1.0.3 - Parse JSON  https://hackage.haskell.org/package/JSONParser-0.1.0.3 (AlanHawkins)
03:00:07 * hackage lapack 0.2.3.1 - Numerical Linear Algebra using LAPACK  https://hackage.haskell.org/package/lapack-0.2.3.1 (HenningThielemann)
03:32:49 <adius> Hi, is there a way to merge records with Maybe fields, so that it overwrite the field when its Just and keeps the original one when it is Nothing?
03:34:14 <adius> No wait that's not what I want to do 🙈. Nevermind …
03:34:43 <adius> But actually that's still an interesting question I don't know the answer. 🤔
03:35:07 <Henson> adius: by records do you mean a type defined with record syntax?
03:35:26 <Henson> adius: and were you looking for a syntatic-sugar way of merging them?
03:35:29 <kuribas> adius: you mean fmap?
03:36:05 <adius> Uhm yeah, I guess so
03:36:10 <kuribas> or with lens: set (myfield . _Just) 2
03:36:37 <adius> Damn, Haskell records are confusing. I just wish they were like PureScript's Records
03:36:59 <kuribas> :t set
03:37:00 <lambdabot> ASetter s t a b -> b -> s -> t
03:37:40 <Lears> If the record is sufficiently polymorphic and it has a Semigroup instance when its fields do, you can wrap each field so it combines with the Last semigroup.
03:37:49 <adius> I'm looking for Haskell's equivalent to JavaScript's `Object.assign({}, defaultConfig, userConfig)` 😅
03:37:53 <kuribas> > set (_1 . _Just) 2 (Just 3, 4)
03:37:55 <lambdabot>  (Just 2,4)
03:39:42 <Lears> % (Last (Just 'a'), Last Nothing, Last Nothing) <> (Last Nothing, Last (Just 'c'), Last Nothing)
03:39:42 <yahb> Lears: (Last {getLast = Just 'a'},Last {getLast = Just 'c'},Last {getLast = Nothing})
03:40:20 <kuribas> adius: or with genericLens: set (field @"myfield" . _Just) 2
03:44:45 <Henson> hi everyone, I'm struggling with understanding MultiParameterTypeClasses.  I don't know if I even really need it for my application.  I'm trying to implement a simple wrapped over C++ OpenCV calls, and am trying to emulate the style of the Haskell Image Processing library, specifically in this area where colour space and pixel depth are related together
03:44:47 <Henson> http://hackage.haskell.org/package/hip-1.5.3.0/docs/Graphics-Image-Types.html
03:45:08 <Henson> I've heard and read that MultiParamTypeclasses are something I should do and they're not a good idea
03:45:18 <Henson> somebody else said what I'm trying to do seems like a Haskell anti-pattern.
03:45:37 <Henson> I don't know enough about the coding style of HIP to do it properly.
03:45:53 <Henson> I guess my question is, is the way HIP does things a good idea, or is it something I should actually be avoiding?
03:46:20 <Henson> or is it actually a good idea, and I just need to keep learning to figure out how to do it properly?
03:50:05 <Henson> oops. "are something I should do" -> "are something I shouldn't do"
03:53:18 <tdammers> who says MultiParamTypeclasses are a bad idea?
03:56:30 <Henson> tdammers: When I was reading about TypeFamilies and MultiParamTypeclasses, several articles said it complicates things, adds ambiguity, and there are better ways of doing it without the language extensions.
03:56:51 <Philonous> Henson, MultiParamTypeclasses are unproblematic and used all over the place. They might possibly be a bad idea _for your use case_ (I haven't looked into it at all), but not in general
03:56:59 <kuribas> Henson: if there is an easier way, use the easier way.  If there isn't, use the advanced stuff
03:58:07 * hackage haskoin-store 0.10.1 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.10.1 (xenog)
03:58:39 <tdammers> typeclasses always introduce some ambiguity, multi-param or not
03:58:48 <tdammers> > show . read $ "1"
03:58:49 <Henson> are TypeFamilies a good idea to use?  This is something else that's required
03:58:50 <lambdabot>  "*Exception: Prelude.read: no parse
03:59:12 <Henson> "good idea" -> "bad idea"
03:59:20 <tdammers> type families are a good idea when they solve your problme
03:59:34 <tdammers> if you can solve the problem elegantly without them, do it
03:59:51 <tdammers> most of these things are a matter of balancing pros and cons
04:00:11 <tdammers> stronger type-level guarantees often lead to more complex types
04:00:24 <tdammers> so you need to ask yourself whether they still pull their weight
04:09:29 <maerwald> simplicity is vastly overlooked :)
04:09:38 <Henson> ok, thank you for your inputs.
04:10:01 <Henson> I didn't want to be struggling down a road I really shouldn't be going down.  But it looks like it might be worth going down.
04:11:05 <maerwald> If you go down, go all the way. I often prefer to not understand something at all as opposed to understand it a little. If you understand something a little, it usually ends up as a mess
04:11:24 <Henson> maerwald: yeah, that's kind of where I am now.
04:11:27 <Henson> in the mess
04:11:47 <Henson> or at least, totally not understanding why things aren't working
04:12:34 <Henson> maerwald: are there good resources for learning about MultiParamTypeclasses and TypeFamilies?
04:13:08 <Henson> maerwald: I've found the haskell wiki pages to be a little hard to read, and the language extensions descriptions are very brief
04:14:07 <jollygood2> is there a way to derive Show when record contains a function? ignoring the function field would be good enough
04:14:12 <maerwald> MultiParamTypeclasses yes imo, TypeFamilies for some things too. There are often multiple ways to solve a problem
04:14:27 <maerwald> It's hard to say and building an intuition when what to use can be very hard
04:14:48 <maerwald> And yeah... the more language features you have, the harder it gets to build that intuition
04:15:05 <maerwald> Also a vastly overlooked problem ;)
04:23:07 <Lears> jollygood2: If you can wrap your function field in something like `newtype Opaque a = Opaque { runOpaque :: a }; instance Show (Opaque a) where show _ = "Opaque"`
04:24:05 <Lears> But I think people will usually say you should be using a custom show function for this sort of thing, rather than the Show class.
04:29:26 <lyxia> jollygood2: Text.Show.Functions has a dummy instance for functions
04:31:38 <merijn> Time to repeat the good old mantra of "Show is for displaying valid Haskell syntax"
04:32:43 <lyxia> except that you're never going to manage that in general for functions, and having a Show instance at all can be sometimes more helpful than no instance.
04:32:45 <Solonarv> to be fair, I'm a lot less opposed to "wrong" Show instances when a correct one isn't possible
04:34:51 <hpc> you're not supposed to use show in actual functionality, so i guess if it assists in a repl and you can't write the correct instance i agree
04:51:07 <lambdacalculus[m> Hello! Goodevening. I was wondering how I can generate a list of random sequences of words in Haskell with limited length.
04:51:58 <lambdacalculus[m> It's sort of like the wordsearch, except the letters would be random and the words wont make sense, repitition of letters is preferable
04:53:08 <hpc> start by looking at http://hackage.haskell.org/package/random-1.1/docs/System-Random.html - the top half is how to get an RNG, the bottom half is how to get values out of it
04:53:21 <Henson> lambdacalculus[m: you might be able to use the abilities of the QuickCheck library to make them for you
04:53:39 <lambdacalculus[m> I don't know how to do this since Haskell is my first language, and so I have  experience. I've checked forums, and have seen System.Random, but I really don't know my way around making a function that would generate a list of random letter sequences
04:53:55 <lambdacalculus[m> no experience*
04:56:26 <hpc> so to start with, the thing you want a random source of is Char
04:56:36 <hpc> and specifically ['a'..'z'] presumably
04:57:19 <hpc> randomRs looks like the most direct way to do that, you get as many characters as you'll ever need in one list and they're only in the range you give it
04:57:19 <lambdacalculus[m> Oh wait, I found something.
04:57:26 <hpc> but it needs a StdGen
04:57:50 <hpc> which you can get from getStdGen (which uses IO), or mkStdGen (which uses an Int that you just give it)
04:58:41 <hpc> that'll give you an infinite stream of random characters, which you can transform into words with just a function
05:00:02 <Henson> lambdacalculus[m: is Haskell the first language you're learning, or is this your first time learning Haskell?
05:00:19 <bwe> *** Exception: Prelude.!!: index too large
05:00:37 <bwe> How can I use the debugger to show me where the exception is raised?
05:02:36 <hpc> i would fix that by breaking the program down into steps, and using ghci to make sure each step is correct
05:03:01 <hpc> or by replacing uses of (!!) with pattern matching
05:05:22 <bwe> hpc: pattern matching with lists?
05:05:46 <hpc> yeah
05:07:12 <bwe> hpc: I wonder how that look like?
05:07:45 <hpc> > case "abc" of [] -> "empty string"; (x:xs) -> (xs, x)
05:07:46 <lambdabot>  error:
05:07:46 <lambdabot>      • Couldn't match expected type ‘[Char]’
05:07:46 <lambdabot>                    with actual type ‘([Char], Char)’
05:07:50 <tdammers> > case [1,2,3] of { x:xs -> show x; _ -> "empty list" } --bwe
05:07:52 <lambdabot>  "1"
05:08:00 <hpc> er yeah, that
05:08:16 <hpc> i don't know why i thought that would work
05:08:40 <Solonarv> you can also use [x, y, z] as a pattern - that'll match lists with exactly three elements
05:09:04 <hpc> and you can use the same patterns in a function definition too
05:09:12 <hpc> > let f [x, y, z] = y in f "abc"
05:09:13 <lambdabot>  'b'
05:09:37 <hpc> > let f [x, y, z] = y in f "" -- this error has location info
05:09:38 <lambdabot>  *Exception: <interactive>:3:5-19: Non-exhaustive patterns in function f
05:09:52 <bwe> hpc: Got it! Thanks.
05:10:06 <hpc> :D
05:11:41 <bwe> hpc: Can I match for the exact length?
05:12:14 <hpc> [x, y, z] matches for exactly three elements
05:12:23 <hpc> (x:y:z:_) matches for at least three elements
05:12:46 <bwe> cool!
05:13:19 <bwe> Solonarv: sry, I did overlook it.
06:03:47 <trcc> I consistently have a big problem with the Maybe type. But it is probably just because I did not do enough null checks previously. 
06:19:58 <kritzefitz> trcc, If you tell us what exactly your problem is, someone may be able to help you.
06:20:37 <trcc> kritzefitz: mainly the problem is, that I am using a dictionary, where values that has been present once, will be present forever.
06:20:47 <trcc> so extracting them again and again seems like a waste
06:21:21 <trcc> but I am confident that I can find some way of solving it, if I spend enough time on it.. so not really a question, just a every-day beginner commment I guess :)
06:22:26 <[exa]> trcc: if you've got lots of maybes, perhaps your data structure would deserve re-thinking
06:23:00 <trcc> [exa]: might be. Though a hashmap seems like the best option on first sight
06:23:53 <kritzefitz> trcc, so I guess you look up some key k in a map m and later do the same lookup again? In that case, why not just keep the value from the first lookup and pass it around?
06:24:53 <[exa]> trcc: are you after performance?
06:25:27 <trcc> kritzefitz: that is difficult, because the value will be a new one, but ever-present. The dictionary is part of a record passed to/and from the application through FFI.
06:25:44 <trcc> [exa]: just ideas really. Nowhere near considering performance just yet. And I will never be able to compete with barebone c implementations anyways
06:26:07 * hackage criterion 1.5.4.0 - Robust, reliable performance measurement and analysis  https://hackage.haskell.org/package/criterion-1.5.4.0 (ryanglscott)
06:26:34 <trcc> I am thinking something in terms of exploiting the haskell-way of macros. (template haskell?)
06:28:03 <kritzefitz> trcc, If I understand your problem correctly, I'd also guess that you just need a different kind of structure, that already guarantees in it's type that the value you're looking for is present.
06:28:25 <kritzefitz> Maybe you want something like a State monad or an IORef or STRef?
06:28:25 <tdammers> it would probably help to learn what the problem at hand is
06:28:29 <cocreature> trcc: you might be interested in http://kataskeue.com/gdp.pdf
06:29:36 <trcc> cocreature: seems ideal to many of my cases on first sight actually! 
06:31:25 <trcc> tdammers: The dev using my package gives a hashmap from name -> value. An external entity passes via FFI an array with [name->value]. If the name is not present in that array, then the original name->value remain. Otherwise the name->value is updated (i.e. a new hashmap is created) 
06:31:51 <trcc> I am using stableptr ioref currently to return the hashmap to the caller, and get it again from the caller
06:40:21 <goodays> hello?
06:40:44 <Bish> hi.
06:43:00 <goodays> I thought nobody was there
06:43:35 <Bish> how could you know
06:43:49 <Bish> ... and he left, the fuck
06:44:01 <tdammers> it happens
06:44:14 <Bish> irc isahelluva drug
06:44:39 <tdammers> trcc: I don't think you're going to find an elegant solution there
06:45:01 <trcc> tdammers: probably not.. who knows
06:45:08 <trcc> I'll see later on in the project heh
06:45:16 <trcc> current closed milestone 0.1 :P
06:55:21 <asheshambasta> Advice needed: I need to serialise and deserialise data to cache in redis. We're speaking of large datatypes (with a decent bit of nesting and so forth) here. Whats the preferred serialisation format? I'm thinking JSON 
06:56:15 <tdammers> does anything else need to consume the data?
06:56:26 <dmj`> asheshambasta: do you need to query the data after its in redis
06:56:45 <tdammers> if not, I'd consider a custom binary serialization format, e.g. through binary or cereal
06:57:02 <tdammers> otherwise, cbor might be a more efficient alternative
06:57:11 <asheshambasta> No, just the party caching the data, and retrievals are just based on the key 
06:57:37 * hackage lapack 0.2.4 - Numerical Linear Algebra using LAPACK  https://hackage.haskell.org/package/lapack-0.2.4 (HenningThielemann)
06:57:40 <trcc> cocreature: that paper is really interesting. Thank you for linking
07:00:35 <asheshambasta> tdammers, dmj`: binary looks interesting, indeed, thanks!
07:00:41 <asheshambasta> for now, this will be more than enough. 
07:02:22 <dmj`> asheshambasta: aeson is probably fine.
07:03:51 <matheus23> Hi! Is there a lens function similar to over, but with the type ":: Monad m => ASetter s t a b -> (a -> m a) -> s -> m t" ?
07:06:48 <Taneb> :t (%%~)
07:06:49 <lambdabot> LensLike f s t a b -> (a -> f b) -> s -> f t
07:07:06 <Taneb> matheus23: you need a Traversal rather than a Lens, but it works for any Applicative
07:07:28 <matheus23> Ah so over works for applicatives?
07:07:45 <Taneb> Yeah!
07:07:46 <matheus23> oh or is that only (%%~)?
07:08:03 <lyxia> :t over
07:08:04 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
07:08:07 <Taneb> (%%~) is an operator that does it but its dark secret is that it's just id
07:08:32 <lyxia> "over" only takes simple functions, no effects.
07:08:52 <Taneb> > [1,2,3] & traverse %%~ \x -> [x,x+1]
07:08:54 <lambdabot>  [[1,2,3],[1,2,4],[1,3,3],[1,3,4],[2,2,3],[2,2,4],[2,3,3],[2,3,4]]
07:12:10 <matheus23> Okay thanks for your help! :)
07:12:21 <asheshambasta> dmj`: does it entail a higher serialisation/deserialisation cost than Binary? 
07:12:42 <asheshambasta> AFAICS Binary clearly states it is very performant (haddocks)
07:13:17 <dmj`> asheshambasta: I wouldn't worry about performance until it's a problem, I'd optimize for dev. time to get the task done
07:13:24 <merijn> asheshambasta: binary is nice, yes
07:14:14 <lyxia> if you don't care about other aspects JSON, it doesn't get the task done faster than binary, does it
07:14:25 <asheshambasta> dmj`: either option takes me the same amount of time, since I can derive Generic instances and therefore the ToJSON/Binary instances automatically in either case. 
07:15:19 <dmj`> asheshambasta: the nice thing about json is that its a well known standardised format. Binary is a haskell specific serialization format
07:15:33 <merijn> Hold up
07:15:39 <dmj`> asheshambasta: if you're using generics then performance really doesn't matter probably
07:16:05 <merijn> Binary is two things: 1) an encoding/decoding class that's Haskell/binary specific and 2) a set of combinators for serialising/deserialising
07:16:15 <asheshambasta> wait, how does using Generic to derive instances affect runtime performance? 
07:16:23 <merijn> Binary is *not* "just a haskell specific format"
07:16:45 <merijn> It's perfectly suitable for cross language binary serialisation
07:17:00 <dmj`> asheshambasta: using Generics introduces intermediate data types... lots of M1 / K1's in the core probably. You'll have to inspect core to see if they're getting eliminated
07:17:29 <asheshambasta> I see
07:17:38 <tdammers> using binary indiscriminately however will produce an application-specific binary serialization format
07:18:13 <merijn> tdammers: Using the class, sure
07:18:22 <merijn> You should just use Get and Put directly
07:18:34 <dmj`> merijn: if you want another language to consume the data that binary produces you'd have to reimplement the deserialization / serialization of binary in that language. 
07:18:37 * hackage katip 0.8.0.0 - A structured logging framework.  https://hackage.haskell.org/package/katip-0.8.0.0 (MichaelXavier)
07:18:40 <dmj`> merijn: he's planning on using generics
07:18:41 <tdammers> if you want to keep things compatible, yes
07:19:32 <lyxia> it's pretty easy to check that the source does not mention M1/K1/(:*:), whether by hand or with inspection-testing.
07:19:56 <lyxia> and once optimized, the generic binary serializer is definitely faster than the generic aeson serializer.
07:20:59 <asheshambasta> the one benefit I see with json is that if I'm just going to respond to the client in JSON, I might as well just not deserialise the data from redis. 
07:21:21 <asheshambasta> (since the cached values may be used for an HTTP API)
07:23:01 <dmj`> asheshambasta: an astute observation
07:25:07 * hackage katip-elasticsearch 0.6.0.0 - ElasticSearch scribe for the Katip logging framework.  https://hackage.haskell.org/package/katip-elasticsearch-0.6.0.0 (MichaelXavier)
07:26:37 * hackage katip-datadog 0.1.0.0 - Datadog scribe for the Katip logging framework  https://hackage.haskell.org/package/katip-datadog-0.1.0.0 (MichaelXavier)
07:28:06 * hackage katip-logzio 0.1.0.0 - Logz.IO scribe for the Katip logging framework  https://hackage.haskell.org/package/katip-logzio-0.1.0.0 (MichaelXavier)
07:34:20 <bwe> how can I define a local function in two function definitions (pattern matching) only once? https://bpaste.net/show/77c1308f5a3d
07:34:54 <bjs> bwe: why is it local if you want to use it in multiple functions
07:34:54 <bwe> i.e. I want to define subF once only, but use it in the same function (defined with different patterns) multiple times.
07:35:07 <bjs> bwe: or well multiple clauses
07:35:27 <lyxia> f xs = case xs of ... where subF = ...
07:35:37 <bjs> bwe: you could do one clause and case split
07:35:50 <bwe> bjs: Exactly. Thanks!
07:36:42 <bwe> For each case split match, can I use guards, to match on level2?
07:37:45 <lyxia> yes you can use guards in a case
07:38:18 <bwe> lyxia: something along the lines of https://bpaste.net/show/16c2418ed3e0 ?
07:38:56 <lyxia> with -> instead of =
07:39:02 <bjs> bwe:  for example `case [1,2,2] of { [1,x,y] | x == y -> True; _ -> False}` is True.
07:39:42 <bwe> bjs: Excellent.
07:45:37 * hackage xcb-types 0.10.0 - Parses XML files used by the XCB project  https://hackage.haskell.org/package/xcb-types-0.10.0 (TychoAndersen)
07:46:37 * hackage mpi-hs 0.5.1.2 - MPI bindings for Haskell  https://hackage.haskell.org/package/mpi-hs-0.5.1.2 (eschnett)
07:48:30 <wroathe> So I'm playing around with the idea of injecting a configuration value into an instance declaration via Template Haskell (just as an experiment), and I'm getting a compilation error. https://gist.github.com/JustinChristensen/5d470655d9ff2a0e9c35d54478c72f04
07:48:50 <wroathe> Can someone help me unpack what this is telling me?
07:51:40 <fen> here is an attempt at a new Foldable1 class; https://pastebin.com/raw/QELutnfM
07:52:10 <lyxia> wroathe: you are trying to construct an AST that uses "options" as a variable
07:52:40 <lyxia> wroathe: but "options" here is an argument to deriveFormatter
07:53:08 <lyxia> wroathe: what do you expect "deriveFormatter (Options id) ''Foo" to expand to
07:53:22 <lyxia> there's no variable you can use here.
07:53:53 <wroathe> lyxia: So is there a way to inject this value into the AST? (Which is probably not a good idea, but this is just an experiment)
07:54:07 <wroathe> I understand that you can "lift" values into Q
07:54:19 <wroathe> But that doesn't quite work for function values
07:54:26 <fen> having foldr1 :: (a -> Maybe b -> b) -> f a -> b instead of foldr1 :: (a -> b -> b) -> (a -> b) -> f a -> b allows foldMap1 to be used to define foldr1
07:55:10 <fen> and that means that the default implementation in terms of Traversable1 works
07:55:16 <wroathe> I'm trying to take this experiment to it's conclusion before I start on some of the ideas in http://homes.sice.indiana.edu/ccshan/prepose/prepose.pdf
07:55:19 <lyxia> wroathe: the other way is to quote it when users call deriveFormatter, so instead of taking an Option, the argument is a "Q Exp"
07:55:47 <wroathe> Ah
07:55:52 <wroathe> I'll give that a shot, thanks!
07:57:55 <Solonarv> you can even have the argument be a 'Q (TExp Options)', then users write [|| whatever ||] and you get somewhat nicer type errors
07:59:59 <lyxia> nice!
08:00:42 <wroathe> That paper I linked mentions that implicit parameters (one approach to threading configuration state through a program) "weakens equational theory", but if the configuration state contains functions I don't fully understand how that's any different than function values being in scope that your function is defined in terms of
08:01:08 <wroathe> If the function has the right type, you can effectively swap out it's implementation without the compiler complaining
08:03:04 <williamrusnack> Is there a better way to write `fmap sequenceA . sequenceA . fmap sequenceA`?
08:03:28 <williamrusnack> I’m looking for `t (f1 (f2 a)) -> f2 (f1 (t a))`
08:04:32 <lyxia> wroathe: the problem with implicit anything is that it adds side conditions to make "replace equals with equals" true, and those side conditions are not always easy to satisfy.
08:05:01 <lyxia> wroathe: if you don't understand what you are replacing code with in the first place, then all bets are off anyway.
08:05:49 <Solonarv> williamrusnack: sequenceA . getCompose . traverse Compose is slightly better, I guess?
08:06:01 <zachk> wroathe, here is some dynamic scoping/implicits I have seen before https://www.haskell.org/hugs/pages/users_guide/implicit-parameters.html , but never used
08:06:38 <wroathe> What I mean is that something like constrain x y = (max x 0.1, min y 1.0) could be seen as constrain x y ?max ?min = (max x 0.1, min y 1.0) (pseudocode)
08:08:23 <williamrusnack> Solonarv: thanks, no shortcuts for this one
08:08:27 <wroathe> So in that sense, function values are a form of global configuration state
08:11:55 <Solonarv> williamrusnack: my version should be a little more performant because it only walks through whatever-datastructures-those-are twice, instead of five times as yours does
08:13:30 <williamrusnack> Solonarv: Good point that I hadn’t considered. Thanks I’ll switch to yours
08:39:12 <wroathe> Solonarv: Can I use a quasi-quoter expression to create a TExp a?
08:39:51 <wroathe> Doing just [|options{formatter=id}|] is giving me the type error you might expect
08:39:56 <Solonarv> wroathe: the only way to create TExp's is [|| some expression ||]
08:40:12 <Solonarv> note the *double* |
08:40:21 <wroathe> Ah, perfect! Thanks again.
09:23:29 <Darwin226> Hey guys. Can someone explain how these two instances manage to compile in servant internals? http://hackage.haskell.org/package/servant-server-0.15/docs/src/Servant.Server.Internal.html
09:23:43 <Darwin226> The one for HasServer (Verb a) and HasServer (Verb (Headers a))
09:23:54 <Darwin226> They give comflicting associated type definitions
09:25:06 <Darwin226> I mean they are marked as overlappable/overlapping but this shouldn't be enough for the associated types
09:25:28 <Darwin226> and when I try to do the same (HasServer (Verb (SomethingElse a))) I indeed get a compile error
09:25:40 <Darwin226> "Conflicting family instance declarations"
09:27:02 <Darwin226> Oh, I see, because their type family definitions actually match up...
09:27:07 <Darwin226> Never mind then
09:58:07 * hackage datadog-tracing 1.0.0 - Datadog tracing client and mock agent.  https://hackage.haskell.org/package/datadog-tracing-1.0.0 (fommil)
10:24:44 <eschnett> what is the name of the type that holds two elements of the same type? like "data Double a = Double a a"?
10:25:22 <glguy> The linear package has V2
10:26:20 <vaibhavsagar> eschnett: V2
10:26:36 <vaibhavsagar> http://hackage.haskell.org/package/linear-1.20.8/docs/Linear-V2.html
10:28:20 <eschnett> thanks!
10:39:38 * hackage hlrdb-core 0.1.3.0 - High-level Redis Database Core API  https://hackage.haskell.org/package/hlrdb-core-0.1.3.0 (identicalsnowflake)
10:50:55 <wroathe> So I've got two typeclasses in my project that exist to perform conversion between a source type to a common representation of all of those types, and then translate from that representation to another type that the user specifies. I want to give the user the ability to control certain aspects of the conversion process both from and to without requiring them to completely rewrite the implementation. To 
10:51:01 <wroathe> that end, I've got functions in each class that, by default, pass a "defaultOptions" to the routine that does the actual work. The user could then override just that function and provide their own options object. 
10:51:05 <wroathe> https://gist.github.com/JustinChristensen/230245179597d0af2b2b0cbd9247d283
10:51:13 <wroathe> My two questions are, 1. In order to allow them to override the instances for the "to" part of the conversion, I'll need to allow them to define their own duplicate instance that overrides my instance. Is there a more elegant way of doing this? and 2. Is there a better way of doing this than using typeclasses?
10:54:22 <wroathe> Also, is there already a "pattern" in place that Haskellers typically follow for this sort of thing?
10:55:05 <Solonarv> you can just use plain old functions, instead of classes
10:55:28 <ne> that
10:55:33 <cryptomonad> There was a talk by George about this
10:56:19 <cryptomonad> https://www.youtube.com/watch?v=zP-DgjIcCho YOW! Lambda Jam 2018 - George Wilson - Lessons From the Design and Implementation of a CSV Library
10:56:35 <Solonarv> you can still provide a 'fromConfigJSON :: FromJSON a => ConfigNode -> a' as default implementations, even!
10:57:25 <wroathe> Solonarv: How would that work from the point of view of the end user?
10:58:17 <Solonarv> wroathe: instead of a 'FromConfig a' constraint, the functions in your API take a 'ConfigNode -> a' argument
10:58:29 <wroathe> Actually, the general problem here is that I want a sane default implementation with default options, and the ability for the user to hand me their own options object if they don't like the default way I'm doing things
10:58:50 <Solonarv> you don't need typeclasses for that!
10:59:21 <wroathe> Oh, I see
10:59:34 <cryptomonad> You could use a default record which the user can overwrite for example
11:00:14 <dmwit> Even if you keep the typeclasses, the user can just... not use it.
11:00:18 <dmwit> And write whatever function they want.
11:00:24 <wroathe> So every function my API would accept functions that control the behavior, and then a duplicate function that does my default thing
11:00:37 <Solonarv> that function wouldn't be duplicate
11:00:44 <wroathe> duplicate-ish
11:00:45 <Solonarv> (what would it be a duplicate of?)
11:02:11 <wroathe> Well, it would be something like fnWith :: (ConfigNode -> a) -> a and then fn :: ConfigNode -> a (that calls fnWith with my default mapping functio)
11:02:12 <dmwit> (I mean there's nothing saying that every function whose type unifies with `ConfigNode -> a` *must* be named `fromConfig`, you know?)
11:02:55 <wroathe> Yeah, as I think about it this is way better
11:03:04 <wroathe> If I'm understanding Solonarv correctly
11:03:41 <dmwit> Is it better if you aren't understanding Solonarv correctly?
11:05:46 <dmwit> (I know. The fear is that Solonarv may be describing something that's better than both the old way and the thing in your head, and you might be missing out. But it's more fun to intentionally misinterpret you. ;-)
11:06:00 <wroathe> dmwit: :P dmwit Well he's saying this basically, right? https://gist.github.com/JustinChristensen/ab455ad17bc95b744efe7b3e0e86cbf3
11:06:31 <dmwit> I doubt he's saying that, since that doesn't type-check.
11:06:55 <wroathe> And defaultXmlMapper is missing too :D
11:07:00 <wroathe> How's it ever going to compile
11:07:11 <dmwit> No, I'm serious. This is not just a quibble. I really don't think he's suggesting that.
11:07:31 <wroathe> Re-reading
11:07:53 <Solonarv> I was indeed not suggesting that
11:11:52 <wroathe> Solonarv: So here's a current function in my API: getConfig :: forall a m. (MonadIO m, FromJSON a) => EnvReader ConfigNode -> m a
11:12:04 <wroathe> With this new thing I'm working on that would become FromConfig instead of FromJSON
11:12:14 <wroathe> And aren't you saying: getConfig :: forall a m. MonadIO m => EnvReader ConfigNode -> (ConfigNode -> a) -> m a?
11:12:23 <wroathe> Instead?
11:12:40 <Solonarv> yes, that's what I'm saying
11:14:09 <wroathe> Right, so that neatly covers the "from" case, but for the "to" case I'd need them to also provide functions for Xml -> ConfigNode, JSON -> ConfigNode, etc.
11:14:20 <wroathe> Which I think is basically what I captured up above in that gist?
11:18:46 <wroathe> In general you're saying it would be a stronger pattern to use higher order functions for this instead of typeclasses, aren't you?
11:18:59 <Solonarv> yes, that is what I'm saying
11:19:19 <Solonarv> Plain Old Functions are really versatile!
11:19:36 <wroathe> So I think we're on the same page, even if my earlier attempt at explaining my understanding was poor
11:19:37 * hackage wordlist 0.1.0.2 - Command-line tool to get random words  https://hackage.haskell.org/package/wordlist-0.1.0.2 (chris_martin)
11:25:55 <wroathe> So because that getConfig routine can potentially call any of those "to" mapping routines as well as the "from" that means I'd probably want to use an ADT that contains these mappers instead of creating functions with large arity for my public API. In that sense I'm essentially replacing the use of typeclasses with explicitly passing around the dictionary, aren't I?
11:27:17 <Solonarv> that's certainly an approach you can take!
11:30:52 <Solonarv> if you want to be extra fancy you can make it a profunctor and implement all sorts of useful instances
11:32:47 <wroathe> Solonarv: I figured there was a class that captured this idea already, but didn't know what the name was :P
11:32:51 <wroathe> Solonarv: Thanks again
11:34:14 <Solonarv> 'data ConfigCodec f t = ConfigCodec { encode :: f -> ConfigNode, decode :: ConfigNode -> Maybe t }'
11:34:17 <Solonarv> something like that
11:40:48 <wroathe> This API is targetting absolute beginners (so basically me). I wonder if forcing the end user to configure it's behavior by defining a profunctor instance might be a little too advanced
11:41:40 <wroathe> The higher-order function thing seems like it's somewhat simpler
11:41:45 <Solonarv> that's why I said "if you want to be extra fancy"
11:44:20 <wroathe> Solonarv: Is there a certain naming convention you typically follow when defining APIs that make use of higher order functions? 
11:44:30 <wroathe> Solonarv: Just out of curiosity
11:44:41 <Solonarv> I'm not aware of any
11:44:50 <wroathe> I've seen people do *With and make* and all sorts of things
11:55:00 <wroathe> Dude, profunctors are neat
12:03:10 <Solonarv> they sure are!
12:08:17 <dmwit> With cabal, can I change which directory it looks in for a project?
12:09:02 <dmwit> I've already built an executable in foo/bar, and would like to run that executable with baz/quux as the cwd.
12:10:00 <dmwit> So I'm imagining something like `cd ~/baz/quux; cabal v2-run --project-dir ~/foo/bar my-exe` or similar.
12:12:58 <Solonarv> there's a flag to specify a cabal.project file
12:16:30 <Solonarv> (--project-file)
12:18:40 <slack1256> Does -threaded interact well with -prof? I know they use different rts as said by +RTS --info?
12:21:58 <Solonarv> I would expect so; after all, you might want to profile a threaded program just as you'd want to profile a non-threaded one!
12:40:43 <Boarders> does anyone know how I create an unsafe lens that indexes into a structure like vector or list
12:41:34 <Solonarv> depends, what kind of "unsafe" are you talking about?
12:42:04 <zachk> would "safe" work?
12:42:07 * hackage nonlinear-optimization 0.3.11 - Various iterative algorithms for optimization of nonlinear functions.  https://hackage.haskell.org/package/nonlinear-optimization-0.3.11 (FelipeLessa)
12:42:12 <zachk> > [1,2,3] ^? ix 1 
12:42:14 <lambdabot>  Just 2
12:42:23 <Boarders> what about if I want to set?
12:42:37 <Solonarv> > [1, 2, 3] & ix 1 .~ 5
12:42:39 <lambdabot>  [1,5,3]
12:42:40 <Boarders> I just meant unsafe because I know I can index into the vector but that is not static
12:42:52 <zachk> static?
12:42:55 <Boarders> Solonarv: thanks that is what I am looking for
12:43:03 <Boarders> it is not in the types
12:44:10 <Solonarv> you mean because the index could be out of bounds?
12:44:22 <Solonarv> that would indeed make such a lens unsafe
12:51:54 <int-e> hmm, what parsec derivative should I be using if I want to have more control over the positions where errors are reported? I just wrote http://paste.debian.net/1067878/ and I'm not happy :)
12:52:22 <sm> megaparsec
13:01:07 * hackage uulib 0.9.24 - Haskell Utrecht Tools Library  https://hackage.haskell.org/package/uulib-0.9.24 (DoaitseSwierstra)
13:03:07 * hackage mmark-ext 0.2.1.2 - Commonly useful extensions for the MMark markdown processor  https://hackage.haskell.org/package/mmark-ext-0.2.1.2 (mrkkrp)
13:25:29 <slack1256> What other languages offer stm concurrency?
13:25:47 <slack1256> This tech is just so great
13:26:49 <zachk> clojure I have haerd
13:28:09 <_deepfire> What is the purpose of module reexports limiting the set of names to the intersection available both qualified and unqualified? (Clause 5 of https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1000005.2)
13:29:49 <dmwit> _deepfire: I suspect to avoid exporting ambiguous names.
13:30:30 <dmwit> Imagine `module M (module N, x) where import N hiding (x); x = 3`.
13:31:32 <dmwit> It also avoids exporting imported names with `module M (module M)`.
13:32:17 <dmwit> (The former motivates requiring the unqualified name; the latter motivates requiring the qualified name.)
13:32:40 <_deepfire> But 5.2 already says "The unqualified names of the entities exported by a module must all be distinct (within their respective namespace)."
13:33:41 <_deepfire> So it's explicitly forbidden to have ambiguity, unless I'm missing some nuance..
13:34:29 <dmwit> _deepfire: `module M (module N, x) where import N hiding (x); x = 3` *is allowed* because N.x is not exported.
13:34:51 <dmwit> Dropping the restriction that the unqualified name must be present would *stop that from compiling*.
13:35:00 <_deepfire> Good point..
13:35:13 <_deepfire> So it allows to have a finer selection
13:37:09 <_deepfire> curious.. so having a qualified import should preclude names from the module being reexportable
13:37:33 <_deepfire> because "qualified" is really a negative property (should be named "qualified-only", really..)
13:37:35 <dmwit> If you have only a qualified import, yes.
13:37:47 <dmwit> Recall that you may import a module multiple times if you like.
13:37:52 <_deepfire> yes, sure
13:38:03 <dmwit> (And this is fairly common; e.g. I often `import qualified Data.Map as M; import Data.Map (Map)`.)
13:38:16 <_deepfire> yeah, done same thing many times as well
13:39:21 <_deepfire> By the way, am I the only person who finds the "qualified" keyword to be horrible misnamed?
13:39:31 <_deepfire> *horribly
13:39:53 <dmwit> I can see it.
13:55:15 <_deepfire> dmwit, by the way wouldn't "module M (module N, x) where import qualified N hiding (x); x = 3" also work, even without the restriction?
13:55:40 <_deepfire> ..with the semantics that we re-export just the qualified names, for example
13:56:05 <_deepfire> er, make that, "just the set of names available as qualified"
13:59:08 <_deepfire> actually, if we pick that "just the qualified set defines re-exports" idea, even your original option works, I think
13:59:55 * _deepfire checks if 'hiding' hides from the qualified namespace as well
14:00:13 <dmwit> Hm, yeah.
14:04:28 <shachaf> Did you know you can import qualified multiple things "as" the same name?
14:05:10 <_deepfire> (just checked, yes, "hiding" is a universal ban-hammer, both qual/unqual are covered)
14:05:33 <shachaf> Or nonqualified, I guess.
14:05:38 <_deepfire> shachaf: yes, I explicitly make this point in the StructuredImports proposal
14:05:49 <crobbins> Isn't there a function already out there that'll get the count of record/fields for a product type via Generic?
14:06:24 <_deepfire> shachaf: more specifically, the point that the locally-structured namespace is distinct from the module namespace, and should be treated as such
14:08:22 <_deepfire> shachaf: but you're raising an interesting point I keep forgetting -- the latent import conflicts in the top-level namespace are ignored until ambiguity is explicitly in play, due to user triggering it by referencing an ambiguous name
14:08:23 <fen> is there a function to commute Apply f => f and Maybe ?
14:08:52 <fen> Apply f => Maybe (f a) -> f (Maybe a)
14:09:05 <dmwit> No.
14:09:20 <fen> sequnceA wont work because f isnt Applicative
14:09:26 <dmwit> Correct.
14:09:38 <fen> and this is being used above an implementation of Traversable1
14:09:49 <dmwit> More precisely: nothing will work, because Nothing can't be made to work.
14:10:02 <fen> hmm
14:10:26 <fen> fmap Just . fromJust
14:10:35 <fen> but yeah, that breaks on Nothing
14:11:08 <fen> so there is no pure Nothing, and thats the problem?
14:12:44 <MarcelineVQ> yes, when we have Nothing as our argument where do we get an f for our result.
14:17:53 <fen> not sure how to solve this, maybe there is a way because where it appears in this paste;
14:18:24 <fen> https://pastebin.com/raw/13aiPDmj
14:19:30 <fen> curry setS_r <$> f ra <.> sequenceA xs
14:21:44 <fen> might be something to do with composing things like (Maybe a -> a)
14:23:03 <fen> instead of apply which is like f (a -> b) ... might need f (Maybe a -> b), but the types are really difficult 
14:23:14 <fen> to work with
14:24:34 <fen> like how (<?>) was needed to define Traversable1 here; https://pastebin.com/raw/QELutnfM
14:25:30 <trcc> I have the case, that I am currently in an IO do context, and I need to call a function, that returns something in the Writer Monad. How do I go about this?
14:26:26 <geekosaur> let ... = runWriter ... ?
14:27:30 <trcc> geekosaur: thank you
14:28:05 <jackdk> Isn't that `(<?>)` one of the kleisli operators from Control.Monad?
14:28:28 <Solonarv> don't think so
14:28:33 <fen> probably its already used, just didnt know what to call it, hence the ?
14:29:41 <jackdk> no it's backwards, it'd be kinda like the cokliesli ones I think, with `a` for every *-type variable
14:29:51 <fen> any reasonable renaming ideas would be appreciated also. SafeState isnt exacly great
14:30:41 <fen> like colift2?
14:31:02 <fen> probably from Comonad 
14:31:19 <jackdk> https://hackage.haskell.org/package/comonad-5.0.4/docs/Control-Comonad.html#v:-61--60--61-
14:32:13 <fen> % :t (=<=)
14:32:13 <yahb> fen: Comonad w => (w b -> c) -> (w a -> b) -> w a -> c
14:32:18 <fen> yeah thats it
14:33:32 <fen> looks like a really sleepy programmer if you squint
14:34:05 <jackdk> although Maybe is not a comonad so you won't be able to use it for your current thing, I don't think
14:34:55 <fen> at this point its not very easy to see how to solve that one
14:35:43 <fen> the correct implementation of g in this; https://pastebin.com/raw/13aiPDmj
14:35:47 <fen> not using sequenceA
14:35:53 <fen> which does not work
14:37:37 * hackage jvm-binary 0.3.0 - A library for reading Java class-files  https://hackage.haskell.org/package/jvm-binary-0.3.0 (kalhauge)
14:40:54 <fresheyeball> anyone out there know how to combine parsers in Dhall?
14:41:23 <fresheyeball> Basically if I have function `(a -> Maybe b)` and `InputType a` I should be able to get `InputType b`
14:50:13 <trcc> So I have these two functions witth the signatures: a -> (a -> IO b) -> IO C and a -> (a -> b) -> IO c. There must be some pattern to merge that into one function. Can anyone provide a link or clue on how to do that?
14:50:52 <fen> that does not look like it can be done
14:51:09 <trcc> hmm ok
14:51:16 <trcc> I was hoping there was some magic way
14:56:33 <fen> ok this works, https://pastebin.com/raw/aHASVbwa
14:56:43 <fen> any way to combine that into one line?
15:00:05 <fresheyeball> can anyone think of an example of an `f` such that we can define `(b -> Maybe a) -> f a -> f b` ?
15:00:35 <fen> thats the other way round to your question above
15:00:48 <fen> more like a profunctor kind of thing
15:01:19 <MarcelineVQ> Contravariant in this case which is what InputType provides
15:01:36 <MarcelineVQ> *fen: Contravariant
15:01:44 <fen> thats it
15:01:51 <fresheyeball> I am starting to wonder if anything contravariant can have such a function
15:01:57 <fresheyeball> I am thinking "no" actually
15:02:24 <fresheyeball> The only think I can think of is Proxy
15:04:08 <fen> cant you use maybe (error "") id ?
15:04:15 <fen> or fromJust?
15:05:19 <MarcelineVQ> usually a person wants the program to not crash as well :>
15:05:23 <fen> if it was the other way round (a -> Maybe b) is like where a default `b' is provided for use with the Nothing case
15:06:27 <fen> maybe there is some kind of continuation style for storing an `a' for this 
15:07:50 <fen> MarcelineVQ: well its either throw an error or store a value to use with the first argument of maybe
15:08:15 <fen> like if it was a Monoid, or more specifically, a Default instance
15:09:44 <fen> but yeah, (b -> Maybe a) -> f a -> f b without extra constraints on `a' can only throw an error for the Nothing case
15:10:26 <fen> well it seems like that should make sense as it does for the case that isnt Contravarient 
15:39:07 * hackage aeson-gadt-th 0.1.2.1 - Derivation of Aeson instances for GADTs  https://hackage.haskell.org/package/aeson-gadt-th-0.1.2.1 (abrar)
15:40:37 * hackage constraints-extras 0.2.3.3 - Utility package for constraints  https://hackage.haskell.org/package/constraints-extras-0.2.3.3 (abrar)
15:45:07 * hackage dependent-sum-aeson-orphans 0.2.0.0 -   https://hackage.haskell.org/package/dependent-sum-aeson-orphans-0.2.0.0 (abrar)
16:32:02 <Lears> % newtype PredF f a = PredF { appPredF :: f a -> Bool }
16:32:02 <yahb> Lears: 
16:32:12 <Lears> % :t \f p -> PredF \ma -> appPredF p (f =<< ma)
16:32:13 <yahb> Lears: Monad f => (a1 -> f a2) -> PredF f a2 -> PredF f a1
16:32:32 <Lears> fresheyeball -^
16:33:16 <fresheyeball> Lears: interesting
16:33:23 <Lears> A little contrived, but potentially usable.
16:36:25 <fresheyeball> Lears: so what is the `f`? I don't think this works actually
16:36:51 <Lears> The f is PredF Maybe
16:37:48 <fresheyeball> oic, and it works because `join`
17:34:07 * hackage xcffib 0.7.0 - A cffi-based python binding for X  https://hackage.haskell.org/package/xcffib-0.7.0 (TychoAndersen)
17:36:46 <dmwit> % :t \f p b -> maybe False p (f b)
17:36:47 <yahb> dmwit: (t -> Maybe a) -> (a -> Bool) -> t -> Bool
17:37:03 <dmwit> Another example, possibly simpler.
18:25:17 <fresheyeball> anyone know how encode with dhall?
18:25:35 <fresheyeball> roughly I am looking for `a -> InputType a -> Text`
18:25:43 <fresheyeball> I can't find a lick of docs on this use-case
18:26:45 <infinisil> fresheyeball: Not sure why this would take InputType?
18:27:16 <fresheyeball> I have `Type a` as well, maybe I am misunderstanding 
18:27:27 <fresheyeball> but `input thing text` appears to parse
18:27:31 <fresheyeball> and I want to encode
18:27:43 <fresheyeball> (where `thing :: Type a`)
18:28:42 <infinisil> Hmm..
18:29:02 <fresheyeball> Anyway, I just can't find any docs on going from a Haskell rep to Text encoding Dhall
18:29:28 <fresheyeball> I think we are using Dhall as basically a JSON replacement
18:29:39 <fresheyeball> and it's way harder to learn than Aeson
18:29:43 <fresheyeball> I can't figure out this bit
18:31:48 <infinisil> I think you'll probably want to go over Expr
18:32:17 <infinisil> So something like `toExpr :: a -> Type a -> Expr .. ..` maybe
18:32:42 <fresheyeball> infinisil: that is why I was thinking InputType
18:34:50 <infinisil> Ah yeah just found that too
18:35:11 <infinisil> Yeah you probably want that
18:36:30 <monochrom> Haha I fork-bombed my GHC and emacs.  (Really emacs; GHC survived.)
18:38:52 <monochrom> So I was randomly generating a binary tree by saying: Let probLeaf and probBranch be given, probLeaf+probBranch=1.  With probability probLeaf chance, make a leaf; else (with probability probBranch) make two random binary trees by recursion, put them together with a parent node.
18:39:51 <geekosaur> "oops"
18:40:23 <monochrom> I forgot to do the math and calculate good values for the probabilities. Because like, if probBranch is high enough that I get a tree of depth 10 or more, we're talking about thousands of nodes, and if I tell emacs haskell mode to print that, emacs will suffer.
18:41:52 <monochrom> In fact I was like "why probBranch=0.7 and probBranch=0.6 be so different?! 0.6 gives me a pretty small tree all the time, 0.7 hangs emacs all the time?..."
18:42:50 <monochrom> Because 0.6^5 (probability of depth>=5) is like tiny 0.08 but 0.7^5 is like 0.17 whoa that's big.
18:43:26 <dmwit> 0.6^5 severely underestimates the probability of depth>=5
18:43:43 <monochrom> Oh, true too.
18:44:05 <monochrom> Gosh I suck at this. I need to put this on the assignment for my students!
18:44:06 <dmwit> Anything over 0.5 has an infinite expected tree size...
18:44:13 <monochrom> Yikes
18:44:54 <dmwit> This is why Boltzmann generators are such a big deal. =)
18:44:58 <monochrom> Oh let me send this to my colleague so she can inflict this on her students right this term!
18:47:29 <monochrom> Thanks, I think I should learn that and use it!
18:49:29 <dmwit> https://byorgey.wordpress.com/2013/04/25/random-binary-trees-with-a-size-limited-critical-boltzmann-sampler-2/ and https://byorgey.wordpress.com/2016/03/23/boltzmann-sampling-for-generic-arbitrary-instances/ are relevant.
18:49:37 <dmwit> There's Hackage packages that do the hard work for you.
19:00:01 <fresheyeball> infinisil: show $ pretty $ embed inputTypeThing thing
19:00:04 <fresheyeball> that does it
19:00:21 <infinisil> Nice
19:07:23 <geekosaur> heh heh. was wondering...
19:07:36 <geekosaur> ("oops" was mostly that, in fact)
19:16:16 <slkdfjslkfj> After `new-install`ing I'm getting one of those "Couldn't match expected type foo-Bar with actual type Bar" errors (I've ended up with 2 different "foo" package hashes in my ~/.cabal/store)
19:16:37 <slkdfjslkfj> Anyone know how to track down which package is the problem?
19:16:58 <slkdfjslkfj> i.e. is using a different version of "foo"?
19:17:13 <slkdfjslkfj> and does fixing it just involve re-"new-install"-ing that package?
19:18:53 <byorgey> monochrom, dmwit: see this very nice library (& paper): http://hackage.haskell.org/package/dragen
19:27:07 * hackage dbus 1.2.4 - A client library for the D-Bus IPC system.  https://hackage.haskell.org/package/dbus-1.2.4 (blaze)
19:47:33 <pie__> hmm https://github.com/jyp/styx
20:18:37 * hackage odpic-raw 0.3.1 - Oracle Database Bindings  https://hackage.haskell.org/package/odpic-raw-0.3.1 (leptonyu)
21:00:30 <lambdacalculus[m> What library should I import for my game to show the time the player has finished a game?
21:09:12 <glguy> lambdacalculus[m: The time package can get the current time and has functions for formatting times as strings
23:57:27 <trcc> Is it bad practise to lift something into IO that is not IO?
23:57:51 <tdammers> define "lift into IO"
23:57:58 <trcc> hehe ye, I was thinking htat myself
23:58:32 <tdammers> normally, "lifting" refers to taking a value of some type t, and converting that into a value of a type that is based on t, typically in a monad transformer situation
23:59:00 <tdammers> e.g., suppose you have type MyStack = StateT Foo IO, then you can "lift" a value of type IO Int to MyStack Int
23:59:08 <tdammers> :t lift
23:59:09 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
23:59:11 <tdammers> :t liftIO
23:59:12 <lambdabot> MonadIO m => IO a -> m a
23:59:13 <trcc> I have a function a -> (b -> IO c) -> d and a function a -> (b -> c) -> d. I need to do some of the same stuff, so therefore I would like to wrap these. But it is difficult, since one has to deal with IO c, whereas the other does not. Therefore I currently have two functions
23:59:52 <trcc> so I am thinking of taking the second function, b->c and lifting it into (b -> IO c)
23:59:53 <tdammers> the former function cannot apply its second argument anyway, so those types don't make a lot of sense
