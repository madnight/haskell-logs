00:02:17 * hackage uniq-deep 1.1.1 - uniq-deep  https://hackage.haskell.org/package/uniq-deep-1.1.1 (ncaq)
01:10:10 <sssilver> People of Haskell, I face a conondrum that perhaps you can advise me on
01:11:13 <sssilver> Let me start by saying that I am 34, and I get paid to write programs. I know various programming languages and even possess some Haskell knowledge, albeit minimal
01:11:40 * rockman37 is listening.
01:12:04 <rockman37> But if this requires much haskell knowledge, I won't be of much use, for I am a noob.
01:12:52 <sssilver> Recently I casually got acquainted with a book titled "Category Theory for Programmers", and while the first few chapters were fascinating and made me feel wonderful, a few chapters in I was overwhelmed
01:13:41 <sssilver> since then, life would sometimes land me on Wiki pages on topics like "Initial algebra", or "F-Algebra", and I would read the whole thing, and 99% of it would go over my head
01:14:04 <sssilver> but that 1% that I would get felt the closest I have ever been to knowing God
01:15:07 <sssilver> so now I have this loud inner call that says "you can only know God by learning this stuff"
01:15:25 <sssilver> and yet "this stuff" is too hard for me to learn, because I simply don't feel intelligent enough to fathom the sheer level of abstraction
01:15:40 <sssilver> I have never been particularly mathematics-inclined
01:16:30 <sssilver> And don't get me wrong, I can return a function if I need to.. but this is something else. Too hard. It crushes my teeth.
01:16:30 <merijn> sssilver: Honestly, I don't get any of that stuff and I'd consider myself in the "fairly advanced to expert" category of Haskell programmers :)
01:17:13 <merijn> sssilver: The problem with that level of abstraction is that it requires LOTS of practice to get comfortable with, not necessarily intellect
01:17:34 <sssilver> So my conondrum is -- what should I do? Should I pursue this? If so, where should I start to be ready to chase it? Is it possible that some people like myself simply don't have the brain capacity to fathom it?
01:17:48 <sssilver> Don't worry about offending me -- be direct
01:17:53 <[exa]> sssilver: category theory is for abstracting abstracted abstractions. And CT+programming books don't have even 1% of the good examples of the concepts they should have to be beginner friendly
01:18:17 <merijn> sssilver: Also, consider the fact that "this shit is way to confusing and complicated" is a natural feeling when reading papers and advanced math
01:18:33 <cocreature> “Should I pursue this?” depends on what your goal is
01:18:37 <merijn> sssilver: It's not that all those researchers and mathematicians don't feel like that, you just get used to feeling clueless and lost :p
01:18:42 <[exa]> sssilver: so, well, don't worry if you don't get it straight ahead, and even more don't even mind if you are a haskell beginner (knowing haskell pretty good is "a good basic introduction" to CT)
01:18:47 <cocreature> if your primary goal is becoming a better Haskell programmer there are far better ways to spend your time
01:18:52 <merijn> And then after awhile you feel slightly less clueless and lost :p
01:19:17 <[exa]> +1 for the clueless
01:19:22 <sssilver> cocreature: no, my goal is not to become a good Haskell programmer. My goal, in all honesty, is to understand category theory very well.
01:19:22 <__monty__> If you like category theory all that's standing between you and becoming "mathematically inclined" is time spent with maths. I've been recommended Algebra: Chapter 0 by Paolo Aluffi, Kmett has a quora post about resources from beginner to advanced. I suggest you start on one of the materials.
01:19:51 <cocreature> well if your goal is to understand category theory you’re not going to get around learning category theory :)
01:20:48 <sssilver> cocreature: but it's also possible that a 34 year old man with average (or perhaps even below-average) intelligence is incapable of "getting it"
01:21:15 <dminuoso> sssilver: CT is a deep well, your goal should not be "understanding everything"
01:21:26 <__monty__> sssilver: Note that you might find you lack certain concepts but if that's the case you just look for materials on those, take a step down the ladder and keep climbing. You'll get there eventually.
01:21:32 <sssilver> in which case you guys should tell me and I would accept it and move on, although something inside of me would be broken forever
01:21:49 <cocreature> I highly doubt that you are incapable of understanding it
01:21:51 <cocreature> it just takes time
01:22:19 * sssilver writes down "Algebra: Chapter 0"
01:22:29 <cocreature> and practise, you don’t learn math just by reading a book
01:23:32 <__monty__> Also, even if you're "just too dumb." You could still learn a ton along the way. (I don't think many people are too stupid to learn maths. It's mostly about how willing you are to submit to learning and practice.)
01:24:22 <sssilver> __monty__: I wish there was a litmus test for intelligence and brain capability
01:25:47 * hackage libraft 0.2.1.0 - Raft consensus algorithm  https://hackage.haskell.org/package/libraft-0.2.1.0 (sdiehl)
01:25:50 <__monty__> And another thing, it might be a good idea to learn the basics of calculus, numerical algorithms, (robust) statistics, machine learning, and other fields you might find you like those more than you thought too.
01:26:34 <__monty__> sssilver: Well, there *is* a test for intelligence. For all the shortcomings of IQ tests they're still *an* indicator that correlates with intelligence.
01:27:00 <__monty__> That being said intelligence has more to do with how quickly you can pick something up rather than your ability to pick it up at all.
01:33:47 <tdammers> both, in a way
01:33:49 <tdammers> they go hand in hand
01:35:16 <tdammers> short-term memory is limited, so if you take longer to figure something out, you will eventually hit that limitation and be unable to figure it out at all
01:36:06 <tdammers> re IQ tests and measuring intelligence: before we can even discuss the merits of IQ and IQ tests, we'll first have to find a useful definition of "intelligence", which has proven fairly difficult
01:36:27 <dminuoso> tdammers: I'd ask you to define "useful" then.
01:36:42 <dminuoso> Whether a given definition is useful or not depends on what you are trying to determine/state.
01:36:42 <merijn> Not to mention that IQ tests are trivially gamed and suffer from inflation
01:37:06 <tdammers> dminuoso: rigid, objective, unambiguous, yet more or less consistent with our everyday intuition of what intelligence should be
01:37:25 <tdammers> but yes, it does depend on the goals as well
01:37:40 <tdammers> and those are somewhat vague / unclear as well
01:37:41 <sicklorkin> I'm exploring various build systems and am wondering if there are any I should consider that are outside the norm (cabal, stack, shake)
01:37:44 <dminuoso> tdammers: I think `objectivity` is the part you can't get to.
01:38:02 <Ariakenom> -offtopic
01:38:06 <tdammers> ^ yes
01:38:07 <dminuoso> tdammers: Since intelligence seems to be fundamentally intuitive notion.
01:38:09 <merijn> sicklorkin: For what? Building Haskell?
01:39:14 <_deepfire> Does anyone know who is "Malcolm" on the Haskell Wiki?
01:39:44 <_deepfire> I'm trying to track down the author of https://ghc.haskell.org/trac/ghc/wiki/Commentary/Packages/PackageNamespacesProposal?action=history
01:39:49 <sicklorkin> merijn: Only haskell at the moment
01:40:09 <merijn> sicklorkin: Then I'd just stick with cabal-install or stack
01:40:53 <cocreature> _deepfire: my guess would be malcolm wallace
01:41:09 <_deepfire> sicklorkin: there's also Nix, if you want reproducibility -- it essentially pins down the world & uses Cabal-the-library under the hood
01:41:32 <_deepfire> cocreature: thank you!
01:41:33 <__monty__> Pretty sure it uses cabal-install.
01:41:52 <_deepfire> __monty__: right, yes
01:43:34 <sicklorkin> _deepfire: i'm looking into this right now.. i guess what I'm really looking for are ways to speed-up the write/develop/test cycle. stack seems to do a lot of unnecesary compliation and coping of executables which kills me
01:44:05 <merijn> sicklorkin: Shake isn't a buildsystem as such, it's a DSL for writing build systems, so you can't really use it directly
01:45:10 <sicklorkin> merijn: Shake + ghc --make is a build system
01:45:12 <merijn> sicklorkin: Both stack and cabal-install use the CABAL spec for specifying how to build things. So either of those are the most sensible options
01:45:27 <merijn> sicklorkin: You need to setup all the dependencies, etc. by hand
01:45:51 <merijn> afaik you can't just "magically build CABAL packages" using Shake
01:46:02 <sicklorkin> merijn: cabal-install
01:46:51 <merijn> sicklorkin: If Shake has some add-in for cabal-install, then it'd work but then you're using cabal-install so Shake doesn't really add anything
01:47:11 <merijn> So then you're just adding Shake boilerplate and overhead for no particular reason
01:47:47 <sicklorkin> merijn: it add flexibility
01:47:54 <__monty__> Cabal-install is definitely the best incremental build tool for haskell ime.
01:48:11 <__monty__> I do use it with nix though, cause nix is awesome : )
01:48:17 <merijn> sicklorkin: But do you need flexibility? I thought your problem was "build times are too long"?
01:48:17 <sicklorkin> Is bazel worth investigating?
01:48:42 <merijn> sicklorkin: Like...in the past 10 years I've never needed any "additional flexibility" over cabal-install
01:48:53 <sicklorkin> merijn: yes, flexibility to cache things like my profile build in a separtate work-dir and -O1..N in antoher.. for eample
01:49:10 <merijn> sicklorkin: But cabal-install can already do that
01:49:24 <sicklorkin> merijn: i guess i'm movign to cabal-install then..
01:49:35 <merijn> sicklorkin: Make sure you use v2-build and friends
01:50:01 <sicklorkin> merijn: I don't parse what you just said but i'll google what it means
01:50:18 <cocreature> cabal only does that for dependencies by default. for local deps you still end up nuking your cache if you switch between profiling/non-profiling by default
01:50:33 <cocreature> but you can change the work dir with both stack and cabal
01:50:34 <sicklorkin> cocreature: ah... thanks
01:50:46 <sicklorkin> cocreature: yes i have a bunhc of aliases that I use..
01:50:46 <merijn> sicklorkin: cabal-install is in the middle of transitioning to a new implementation of the way builds are done, v2-build is the new (superior) approach
01:51:11 <sicklorkin> merijn: I see thanks.
01:51:37 <merijn> sicklorkin: See: https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
01:52:08 <sicklorkin> merijn: ty
01:53:20 <[Leary]> sssilver: Based on what you've said I do think you'd find learning more to be a profitable venture, but I'd suggest you look into Abstract Algebra first. There's a lot of really beatiful and relatively simple mathematics around Group-like and Ring-like structures, and it can be a good stepping stone to CT.
01:53:48 <dminuoso> And basic algebra knowledge has much more practical use in programming. :-
01:54:21 <sssilver> [Leary]: awesome, would I just YouTube "abstract algebra" and go from there?
01:56:03 <[Leary]> I learnt what I know of it from lectures/notes/assignments in university, so unfortunately I don't have a good resource to recommend. There are probably some good introductions on YT, but you probably want to look around the internet for what textbooks are popular.
02:15:14 <wz1000> how would you define show for data Coproduct :: [* -> *] -> * -> * where This :: f a -> Coproduct (f ': xs) a; That :: forall f a xs. Coproduct xs a -> Coproduct (f ': xs) a
02:18:54 <phadej> wz1000: see how show is defined for NS in sop-core
02:22:27 <u0_a17> whois
02:36:53 <phadej> wz1000: you could also write instance (Show (f a), Show (Coproduct xs a)) => Show (Coproduct (f ': xs) a); and instance Show (Coproduct '[] a)
02:37:47 <Jetien> Hi! I'm looking for a libraries / framework recommendation: In my project i've written a repl that spawns an external process and communicates with it via stdin/stdout. I'm looking for a framework/library to that loop into a web service where I can control the number of workers (each one with its own spawn).
02:38:08 <phadej> feels quite special case
02:38:44 <phadej> but for workers, there's e.g. resource-pool
02:38:47 <phadej> @pkg resource-pool
02:38:47 <lambdabot> Maybe you meant: pl ping msg bug
02:38:55 <phadej> :(
02:39:06 <phadej> https://hackage.haskell.org/package/resource-pool
02:39:56 <merijn> Jetien: I have something like this for my benchmarking tool, based on resource-pool and my own library
02:40:05 <Jetien> thank you. my initial though was to put a proper queue (like rabbitmq) between the web service and the workers
02:40:29 <merijn> Jetien: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/ingest-src/Main.hs#L276-L289
02:42:08 <merijn> Jetien: I'm using resource-pool to deal with the setup/cleanup of worker processes (you can find that in the ProcessPool modue of the repo, but it's kinda application specific) and mix that with parMapM to feed multiple parallel processes (note that the implementation of that is rate limited, though, i.e. it will only ever have N request in flight if you have N parallel processes
02:42:12 <cocreature> phadej: it’s @hackage
02:42:52 <merijn> Jetien: Where parMapM is https://hackage.haskell.org/package/broadcast-chan-conduit-0.2.0.1/docs/BroadcastChan-Conduit.html#v:parMapM
02:43:03 <merijn> Jetien: Although there's a non-conduit version too
02:43:57 <Jetien> merijn: thank you. i'll check it out
02:44:55 <merijn> The non conduit versions are https://hackage.haskell.org/package/broadcast-chan-0.2.0.1/docs/BroadcastChan.html#v:parFoldMap and parFoldMapM
03:42:49 <WilliamHamilton[> what is a common idiom with which I could simplify expressions like
03:42:50 <sicklorkin> My program is spending 1/3 of the time doing GC.  The program uses fsnotify which triggers a parser to incrementally parse the changes from prev offset to EOF then finishes and waits for another file change.  The actual decoding takes a fraction of this time. Does this sound like typically GC behavor or is GC actually doing useful clean-up?
03:42:52 <WilliamHamilton[>     union' (Constrained (Comp m1)) (Constrained (Comp m2))  = Constrained $ Comp (IM.union m1 m2)
03:43:15 <WilliamHamilton[> I'd like to simplify all the wrapping and unwrapping
03:43:25 <merijn> sicklorkin: Threaded runtime system?
03:43:59 <merijn> sicklorkin: And can you paste the output of "+RTS -sstderr" somewhere?
03:44:07 <sicklorkin> merijn: sure just a sec
03:44:08 <WilliamHamilton[> I know there is http://hackage.haskell.org/package/newtype-0.2/docs/Control-Newtype.html and I could do it with _unwrapped from lens if I were using lens, but I would like to know what you would use
03:44:22 <merijn> WilliamHamilton[: Did you define those newtypes?
03:44:40 <WilliamHamilton[> I defined `Constrained`, but not `Comp`
03:44:55 <sicklorkin> merijn: Most RTS options are disabled. Link with -rtsopts to enable them
03:45:06 <lyxia> WilliamHamilton[: what are Constrainted and Comp
03:45:15 <merijn> sicklorkin: Yeah, you need to build with that flag to make that work
03:45:57 <WilliamHamilton[> lyxia: `Comp` is the constructor for `:.:` in Generics.SOP, basically composition of functors (f :.: g)
03:46:24 <WilliamHamilton[> lyxia: constrained is `Constrained c f a = c a => Constrained (f a)`
03:46:33 <merijn> WilliamHamilton[: Some common solutions: 1) Implementing Functor/Applicative for those newtypes and just use those to apply IM.union, 2) change the newtypes to have a record accessor like "runComp" or whatever and define an alias for "runFoo . runComp" to unwrap things
03:47:10 <lyxia> well Constrained not being a newtype kind of messes things up
03:47:24 <merijn> Functor/Applicative would still work ;)
03:48:18 <lyxia> pure needs to come up with a (c a) dictionary
03:50:52 <WilliamHamilton[> lyxia: also Functor would need a dictionary for `c b`
03:51:42 <merijn> lyxia: Ah, I didn't see the actual definition :)
03:56:28 <sicklorkin> merijn: Any idea why this doesn't work?  stack --work-dir .stack-work-prof --profile build --ghc-options "-rtsopts" -v
03:56:44 <merijn> sicklorkin: I don't use stack, so: Not a clue :)
04:00:30 <sicklorkin> merijn: i should have recognized they typo `-sstderr`
04:00:35 <sicklorkin> *the
04:00:41 <merijn> What typo?
04:01:10 <sicklorkin> merijn: -s<space>stderr worked for me
04:01:25 <merijn> I use it without spaces all the time...
04:01:26 <sicklorkin> or just `-s` which defaults to stderr
04:02:02 <sicklorkin> merijn: uh.. must be meh stack
04:03:18 <sicklorkin> ` -s[<file>]` so looks like sometinng is broked
04:04:55 <sicklorkin> merijn: https://pastebin.com/7H8048kY 
04:05:59 <merijn> sicklorkin: What's the code doing? (trying to figure out if that residency number makes sense)
04:06:39 <sicklorkin> merijn: it stores some rather large objects in an IORef(state)
04:07:57 <merijn> sicklorkin: It's the threaded runtime, yes? Oone simple thing to try is running with "+RTS -qg" and see if that improves things
04:08:12 <merijn> sicklorkin: Although that depends how many capabilities you're running it with
04:08:35 <merijn> sicklorkin: What are those big objects? And do they get updated/changed frequently?
04:09:23 <sicklorkin> merijn: those large objects only get added once and containe telemetry data that used for everything else..
04:09:44 <merijn> sicklorkin: Right, so maybe compact regions can help with that
04:10:02 <sicklorkin> merijn: is that was `-qg` is?
04:10:20 <merijn> sicklorkin: No, that disables parallel GC, but if it's big immutable data that might not be the issue
04:10:54 <merijn> sicklorkin: So it looks like 90% of the time (119s) is spend on the 136 collections of Gen 1. Compared to 7s for the 19616 collections of gen 0
04:11:32 <merijn> sicklorkin: GHC's GC is a "copy & compact" GC, so it copies the entire "live" set. Which in your case is probably this single large data structure (you have 700 MB residency)
04:11:47 <merijn> sicklorkin: So, repeatedly copying 700 MB is, obviously, slow
04:12:07 <sicklorkin> merijn: I see.. 
04:13:00 <merijn> sicklorkin: Compact regions are a way to tell GHC "perform a copy and compact on this entire data structure, and treat it as a GC root". So instead of copying the entire thing it will just check "is this pointer still alive? Yes. Ok. No? GC the entire thing in one go"
04:13:43 <merijn> sicklorkin: So GC ends up only copying it once during the construction of the compact region. Of course this only makes sense for static large data, but that's exactly what you said you have
04:14:24 <merijn> sicklorkin: See the GHC user guide on compact regions for details, but that could considerably speed things up
04:14:37 <sicklorkin> merijn: thanks! looking now
04:32:40 <sarna> hey, is haskell news down?
04:33:37 <lyxia> it's been down for a few months
04:33:49 <lyxia> https://github.com/haskellnews/haskellnews/issues/75
04:34:36 <sarna> lyxia: oh, I see. thanks
04:41:17 * hackage shake 0.17.5 - Build system library, like Make, but more accurate dependencies.  https://hackage.haskell.org/package/shake-0.17.5 (NeilMitchell)
04:48:13 <tabaqui> Why we define Monad class with ">>=" operator, not with "join"
04:48:15 <tabaqui> ?
04:48:27 <tabaqui> I mean >>= is just a composition of fmap and join
04:48:46 <tabaqui> and in math, Monad defines as a tuple with two natural transformations
04:48:50 <tabaqui> return and join
04:49:01 <tabaqui> *is defined
04:49:04 <opqdonut> tabaqui: a) >>= is usually the one you want to use b) for many monads >>= is easier/more efficient to implement
04:49:22 <lyxia> (>>=) is more efficient and join doesn't work well with GeneralizedNewtypeDeriving
04:51:33 <lyxia> newtype MyAppT m a = MkMyAppT (StateT Int m a) deriving (Functor, Applicative, Monad)  -- doesn't work because (StateT Int m (StateT Int m a)) is not coercible to (MyAppT m (MyAppT m a)) for any m.
04:51:38 <tabaqui> opqdonut: a) it is not the first class from which we want secondary methods, not the main ones, b) "m >>= f" is equal to "join (f <$> m)"
04:51:46 <tabaqui> lyxia: so it is about ghc and implementations
04:51:50 <tabaqui> not about math
04:52:02 <opqdonut> yes, definitely
04:52:15 <opqdonut> from the math perspective it doesn't matter whether you implement >>= or join, they are equivalent
04:52:18 <opqdonut> (given Functor)
04:52:41 <opqdonut> I hadn't thought about the newtype point, that's interesting
04:53:17 <lyxia> tabaqui: I don't understand what you meant by a)
04:54:35 <tabaqui> lyxia: I mean that we constantly use ">>=", not join. But it doesn't matter, because we usually don't need "wrap" from MonadFree
04:55:03 <merijn> tabaqui: It matters because more frequent use == more relevant to implement efficiently
04:55:33 <merijn> tabaqui: There's no semantic difference, but there are operational differences
04:56:03 <tabaqui> probably it is better to write {-# REQUIRES join | (>>=) #-}
04:56:27 <merijn> tabaqui: That's one of the long term plans, I think. But there are pragmatic difficulties with join in Monad
04:56:31 <merijn> Although I forgot what they were
04:56:51 <tabaqui> *I mean MINIMIAL directive
04:57:31 <tabaqui> ok, I got it, thanks guys
04:58:19 <merijn> tabaqui: Join in Monad was originally proposed for the AMP proposal, but the wiki suggest it was dropped over "Left out due to nontrivial breaking interaction with Roles. Will "probably be fixed in the future", but for now it's off the table."
05:00:45 <phadej> I'd say it's unluckily it will be there any time soon: http://ryanglscott.github.io/2018/03/04/how-quantifiedconstraints-can-let-us-put-join-back-in-monad/
05:00:52 <phadej> unlikely
05:03:03 <hpc> huh, i wouldn't have expected that to have any issue at all
05:18:02 <phadej> roles were introduced to make safe GND, not being able to GND `Monad` because of roles would be sad :)
05:22:56 <tdammers> that quote really just means "let's try to not blow up the scope of the AMP too much"
05:23:58 <merijn> phadej: Since roles aren't even on by default they don't make GND that much safer
05:26:45 <phadej> I don't know why default role aren't nominal. I guess it would make people angry
05:27:18 <merijn> phadej: "We *might* break hackage and people will be mad, so lets just eliminate any possible type safety we could've had"
05:27:38 <phadej> merijn: have you pushed through ghc-proposal? please try.
05:27:51 <phadej> a _controversial_ one
05:28:18 <merijn> phadej: Look, I'm not saying I don't appreciate how whiny a lot of the backwards compat people are
05:29:19 <merijn> phadej: You should consider that comment as more of a complaint about the overly conservative parts of the community, rather than a complaint about the proposal initiator saying "fuck it" and giving up
05:30:36 <phadej> well, roles to begin with are controversial, making breaking defaults is even worse
05:31:00 <merijn> Arguably the status quo is broken and roles just make detection and fixing possible
05:31:13 <opqdonut> what are roles?
05:31:30 <merijn> opqdonut: The ability to control whether "coerce"ing newtypes is safe or not
05:31:48 <phadej> opqdonut: or rather that you cannot coerce Set Int into Set (Down Int)
05:31:53 <phadej> but can List Int into List (Down Int)
05:32:16 <opqdonut> huh
05:32:34 <phadej> https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/coercible.pdf
05:33:14 <opqdonut> Coercible sounds much more understandable than Roles
05:33:19 <opqdonut> thanks for the link
05:34:01 <Ariakenom> that's one hell of a sentence "In particular, we can change it so that when inferring constraints for derived instance, it infers quantified Coercible constraints whenever the class has a method with a type signature in which a higher-kinded type variable bound by the instance is applied to some type."
05:35:01 <Ariakenom> if only it had a reference to kinds
05:36:00 <phadej> sentences like that, is why there are formal languages
05:38:37 <phadej> on the other hand, I hope that practical language pops up out of HoTT work, so we won't need to have opaque (abstract) types at all
05:39:02 <phadej> but I guess one have to wait few decades
05:40:18 <Ariakenom> haskell type notation is quite pleasant. I had never seen quantified constraints, but the syntax was intuitive
05:41:05 <phadej> wait until dependent and linear stuff will be there too. than the pleasure will be gone :)
05:41:06 <Ariakenom> as in the notation helped understand the gist of it
05:44:03 <Solonarv> oof yeah I really don't want to see all the matchability+linearity annotations on arrows
05:44:41 <Ariakenom> phadej: nah the rest will be as before afaik. that, eh, modularity is nice
05:46:43 <Solonarv> safeHead :: forall a. foreach (xs :: [a]) -> forall (prf :: null xs :~: False). a
05:46:43 <Solonarv> is that still pleasant to you? It doesn't seem too terrible to me, even better with unicode
05:47:47 <Solonarv> safeHead :: ∀a. ∏(xs :: [a]) -> ∀(prf :: null xs :~: False). a
05:48:16 <qlobbe> Hello there ! I'm trying to edit my .ghci file but within a stack --docker integrated package. The problem is that ghci don't take my edited .ghci in account. Does any one of you know how to link a .ghci file through docker  ? Thx !
06:08:58 <phadej> https://www.fileformat.info/info/unicode/char/03a0/index.htm vs. https://www.fileformat.info/info/unicode/char/220f/index.htm
06:10:14 <phadej> Solonarv: what's the difference between forall and foreach? that makes my head hurt
06:10:39 <phadej> (i vaguely remember, but it makes me think; that's unpleasant)
06:11:21 <merijn> phadej: forall is subset of pi types
06:11:52 <merijn> phadej: Specifically, forall is the case of any Pi type where the actual value of the Pi argument does not occur in the result type
06:12:23 <merijn> phadej: "forall a . ?" == "Pi (_ :: a) . ?" (with _ being a wildcard/non-binding variable)
06:13:13 <merijn> I've never seen pi types written as "foreach", though
06:13:47 * hackage curry-base 1.1.0 - Functions for manipulating Curry programs  https://hackage.haskell.org/package/curry-base-1.1.0 (CurryLanguage)
06:14:47 * hackage curry-frontend 1.0.2 - Compile the functional logic language Curry to severalintermediate formats  https://hackage.haskell.org/package/curry-frontend-1.0.2 (CurryLanguage)
06:15:47 * hackage function-builder 0.2.0.1 - Create poly variadic functions for monoidal results  https://hackage.haskell.org/package/function-builder-0.2.0.1 (SvenHeyll)
06:16:47 * hackage curry-frontend 1.0.3 - Compile the functional logic language Curry to severalintermediate formats  https://hackage.haskell.org/package/curry-frontend-1.0.3 (CurryLanguage)
06:17:06 <Solonarv> phadej: that's the proposed syntax for dependent haskell
06:17:26 <Solonarv> the argument is that naming the quantifier 'pi' instead makes no sense to anyone who isn't a type theorist
06:17:59 <phadej> merijn: that's wrong. please read through https://github.com/ghc-proposals/ghc-proposals/pull/102
06:18:51 <phadej> Solonarv: /I know/, and my unicode links pointed you to lexical syntax of https://github.com/goldfirere/ghc-proposals/blob/pi/proposals/0000-pi.rst#proposed-change-specification
06:18:53 <merijn> phadej: If that's wrong, then they're deliberately deviating from the established meaning of forall and Pi, which might be the case, but that's on them
06:19:22 <Solonarv> oh, I missed those - I was AFK for a bit
06:19:29 <phadej> merijn: forall a. a -> a == Pi (a :: Type). a -> a
06:19:34 <phadej> not Pi (_ :: a)
06:19:38 <merijn> phadej: oh, right
06:19:49 <merijn> phadej: I was just making up syntax as I go along
06:20:27 <phadej> :/
06:21:30 <merijn> That's what I get for trusting my memory :)
06:23:31 <Solonarv> I went and set up compose-key sequences for u+220f (∏) and u+2200 (∀) after reading the DH thesis ;)
06:25:17 * hackage acid-state 0.15.0 - Add ACID guarantees to any serializable Haskell data structure.  https://hackage.haskell.org/package/acid-state-0.15.0 (AdamGundry)
06:26:38 <Ariakenom> always prepared
06:27:06 <metalrain> How did the thesis convince you to do that? I've always found hard to type characters like forall bit off putting. 
06:27:36 <merijn> I have hijacked the pinjin input method on OSX to allow typing unicode via LaTeX commands
06:27:54 <merijn> So I can switch keyboards modes and write '\forall' to get ∀
06:28:06 <Solonarv> It's convinced me to make them not hard to type ;)
06:29:00 <Solonarv> ∏ is just <compose><compose>P for me; ∀ is <compose><compose>A
06:30:22 <phadej> Solonarv: you really should use N-ary product
06:30:43 <phadej> not a "greek capital letter pi"
06:31:58 <phadej> and seems you have
06:32:27 <phadej> my font is just don't differentiate them well, which is sad
06:32:50 <phadej> ∏ vs. Π
06:33:46 <phadej> don't write dependent haskell for greek businesses
06:35:39 <Ariakenom> don't do math in greece
06:39:38 <Solonarv> I took care to look up the right unicode symbol when configuring the compose sequence :D
06:40:02 <lyxia> Maybe in Greece they use S and P instead.
06:42:47 * hackage ron 0.5 - RON  https://hackage.haskell.org/package/ron-0.5 (cblp)
06:43:47 * hackage ron-schema 0.5, ron-rdt 0.5 (cblp): https://qbin.io/speed-punk-sedz
06:44:47 * hackage ron-storage 0.5 - RON Storage  https://hackage.haskell.org/package/ron-storage-0.5 (cblp)
06:46:04 <Ariakenom> maybe a Cyrillic P: П
06:47:13 <c_wraith> I need to remember Cyrillic comes from Greek, and I shouldn't be surprised that its P looks like Pi
06:58:23 <reygoch> Doesn't cabal on windows support executing pacman commands for fetching necessary binaries?
06:58:34 <reygoch> and libs
06:58:45 <Solonarv> that would be news to me!
06:59:44 <reygoch> Hmm... I was hoping for something like what is available in stack
06:59:59 <reygoch> stack exec -- pacman -Syy, etc...
07:00:29 <merijn> reygoch: Does it support executing pacman commands on any platform?
07:00:38 <reygoch> merijn: no
07:01:19 <reygoch> Actually, not sure. I guess that exec can execute what ever is in the environment, so I guess pacman would be available on archlinux?
07:01:23 <merijn> reygoch: I meant that in a sense of "does cabal even support that on *nix?", which I think it doesn't
07:01:49 <reygoch> merijn: no, I don't think so
07:02:21 <reygoch> merijn: although, msys2 and mingw are distributed along with haskell platform for windows so I'd expect that to be working
07:03:15 <merijn> msys2 and mingw are compiler/linkers and necessary for GHC to work, so not sure why pacman would be included since it's an ArchLinux specific tool?
07:03:45 <reygoch> marijn: they provide pacman as a tool to install packages
07:03:54 <Solonarv> *stack* brings pacman along; I'm not sure where it lives, but it's definitely come in useful
07:04:02 <Solonarv> (on windows, I mean)
07:04:22 <reygoch> I have global msys installation and it has pacman
07:05:05 <reygoch> Since platform has msys and mingw I was expecting to be able to use pacman with cabal
07:09:34 <tdammers> stack installs msys, and that included pacman as the msys package manager
07:09:39 <tdammers> includes*
07:10:05 <tdammers> unfortunately it doesn't always work, I've even seen it brick the entire msys
07:10:31 <tdammers> so then you need to manually clean out stack's cache, have it pull in a fresh msys, and try again
07:18:43 <dminuoso> newtype S x y z = S (x y (y z))
07:18:49 <dminuoso> Is there a name for this in Haskell?
07:19:12 <Taneb> I can't recall having seen it
07:19:47 <Philonous> Also, isn't it usually x z (y z) ?
07:19:56 <dminuoso> Philonous: Mmm. Yeah you are right.
07:37:42 <phadej> c_wraith: latin script is ancestor of greek too.
07:37:44 <phadej> .. It is generally believed that the Romans adopted the Cumae alphabet, a variant of the Greek alphabet, in the 7th century BC from Cumae, a Greek colony in Southern Italy. 
07:38:29 <phadej> arg, descent - otherway around
07:40:51 <tdammers> I was about to say...
07:44:54 <Philonous> I'm trying to profile a program (using stack build --bench --profile). I haven't set -fprof-auto anywhere but I'm still getting thousands of cost centres in the output 
07:45:20 <Philonous> Can I disable them somehow? I tried adding -fno-prof-auto to the ghc options, but it doesn't seem to do much
07:48:26 <monochrom> dminuoso: There had not been a Haskell name for S until Applicative came along and so ((->) e)'s <*> turns out to be S.
07:49:45 <dminuoso> monochrom: Okay I need to digest this.
07:50:56 <Philonous> Except that (<*>) lives in the wrong universe 
07:51:36 <dminuoso> Philonous: Yeah I was looking to do SKI combinator calculus.. kind of in the type system.
07:51:41 <dminuoso> I mean Const and Identity already exist.
07:57:17 <[Leary]> Speaking of LC combinators, I wrote something pretty cute today.
07:57:24 <[Leary]> % newtype Y a = Y { ($$) :: Y a -> a }
07:57:24 <yahb> [Leary]: 
07:57:38 <[Leary]> % yfix = \f -> (Y \y -> f (y $$ y)) $$ (Y \y -> f (y $$ y))
07:57:38 <yahb> [Leary]: 
07:57:45 <[Leary]> % yfix (const 2)
07:57:45 <yahb> [Leary]: 2
07:57:49 <[Leary]> % take 10 $ yfix (0:)
07:57:49 <yahb> [Leary]: [0,0,0,0,0,0,0,0,0,0]
07:58:03 <[Leary]> Who needs explicit recursion anyway!
07:58:23 <joeyh> #stack
07:58:25 <joeyh> oops
07:58:53 <Solonarv> whoa, I knew there was a newtype vaguely like that somewhere!
08:00:09 <phadej> if you squeeze enough: http://hackage.haskell.org/package/recursion-schemes-5.1.1.1/docs/Data-Functor-Foldable.html#t:Mu
08:00:17 * hackage proto-lens 0.5.0.0 - A lens-based implementation of protocol buffers in Haskell.  https://hackage.haskell.org/package/proto-lens-0.5.0.0 (JudahJacobson)
08:01:16 <phadej> Mu Identity gives you ~ fix
08:01:17 * hackage proto-lens-optparse 0.1.1.5, proto-lens-arbitrary 0.1.2.6, proto-lens-protobuf-types 0.5.0.0, proto-lens-setup 0.4.0.2, proto-lens-runtime 0.5.0.0, proto-lens-protoc 0.5.0.0 (JudahJacobson)
08:01:21 <Solonarv> I wonder, can you write a functor instance for Y ?
08:01:57 <phadej> there's `a` in negative position
08:02:58 <Solonarv> oh, right. I'd somehow convinced myself the recursion made that go away.
08:08:17 * hackage equational-reasoning 0.6.0.0 - Proof assistant for Haskell using DataKinds & PolyKinds  https://hackage.haskell.org/package/equational-reasoning-0.6.0.0 (HiromiIshii)
08:08:51 <xsperry> are there any ghc-specific profiling tools that I can use to monitor memory usage of a haskell program? I'm processing a significant amount of text, and I'm about to convert my code to use Text instead of String, and I'm be curious to know how much I'll gain by switching to Text
08:10:12 <merijn> xsperry: You mean besides GHC's profiling features? >.>
08:10:18 <Ariakenom> xsperry: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
08:11:02 <merijn> The simplest method is "+RTS -sstderr" which reports GC statistics, but the other profiling stuff can produce way more detailed info
08:11:42 <xsperry> merijn, I don't know, are they good enough for what I want? I'm doing this to satisfy my curiosity, so not looking for something extremely precise or detailed. even just max/average memory usage would be good enough
08:12:17 * hackage haskoin-store 0.10.0 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.10.0 (xenog)
08:12:19 <Solonarv> yes, it's good enough for that
08:13:00 <merijn> xsperry: "+RTS -sstderr" reports: total allocations, garbage collected, residency (i.e. max simultaneously used memory), number of GCs and how long those took
08:13:10 <merijn> You have to compile with -rtsopts to make it work, though
08:13:42 <xsperry> ok, I'll give it a go
08:14:43 <Ariakenom> xsperry: this is probably a more relevant link. https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-options-to-produce-runtime-statistics
08:14:52 <Ariakenom> for parsing the output and whatnot
08:15:19 <Ariakenom> parsing as in understanding
08:15:21 <xsperry> thanks. was just wondering if I need both -prof and -rtsopts 
08:15:52 <merijn> xsperry: -rtsopts is for specifying options to the runtime, -prof is for a profiling build. -sstderr works with non-profiled builds to, but still requires -rtsopts
08:22:25 <xsperry> hmm, I got a bunch of errors like this:            Failed to load interface for `Text.HTML.TagSoup'         Perhaps you haven't installed the profiling libraries for package `tagsoup-0.14.2'?
08:22:59 <xsperry> time to read the fine manual :P
08:23:03 <asheshambasta> has anyone used composite types with Opaleye? 
08:23:34 <__monty__> asheshambasta: You trying out opaleye? Cool. Did you compare Tisch to Squeal?
08:24:08 <asheshambasta> __monty__: yes, so far the experience has been great. And no, haven't really compared Tisch. 
08:24:54 <asheshambasta> I'd have probably stuck to Squeal but compiling modules with large schema types was becoming painful, and my time constraint didn't allow me to "fix" the problem somehow, but I'll give it another shot in the near future when my workload subsides a bit. 
08:25:58 <asheshambasta> I was even considering -simple, but decided against it in the end since I ran some stats. on the bugs we've had in the last 3 years, and 75% of them were due to handwritten SQL :-) 
08:26:16 <xsperry> stack install --executable-profiling    did it
08:30:05 <Ariakenom> xsperry: were you trying the profiling or just the statistics?
08:31:42 <xsperry> stats
08:31:53 <xsperry> no need for -prof?
08:32:24 <xsperry> it has been compiling since then, and installing a bunch of profiled libs that i don't otherwise need :P
08:33:52 <Ariakenom> I was just surprised anything was needed for the stats
08:34:39 <xsperry> I added this to cabal. ghc-options:     -prof
08:35:04 <merijn> xsperry: cabal and stack will add -prof for you when you enable profiling
08:35:47 * hackage yesod-markdown 0.12.6.1 - Tools for using markdown in a yesod application  https://hackage.haskell.org/package/yesod-markdown-0.12.6.1 (PatrickBrisbin)
08:54:45 <lysgaard> I have a compiler-like program that takes inputs parametrized by a size parameter. For a certain size, n, it runs fast and uses little memory, then for size n+1 it will use all available memory and get killed by the Linux kernel for misbehaving. I want do debug this problem, but I do not know how to do it. How do I debug the memory usage of a program that is killed?
08:58:06 <dminuoso> lysgaard: Have you used the GHC profiler?
08:58:11 <dminuoso> Well I guess it's rather an rts profiler. :)
08:59:26 <lysgaard> dminuoso: Yes, I am using stack with the --profile option. It generates nice profiles for when my program works correctly. My problem is that the problem is only present when the program is killed, and that seems to also cut any profiling output.
09:01:11 <lysgaard> Maybe a more general question: What other tools are there for analyzing the performance (memory,cpu,time,concurrency etc.) of Haskell programs? I only know of the GHC rts profiler output which is nice, but quite basic.
09:02:06 <lysgaard> I find it especially hard to debug because of laziness making it hard to pinpoint what code causes memory bloat/slowness.
09:05:04 <berndl> lysgaard: it helps if you know how lazy code is evaluated.
09:07:04 <lysgaard> berndl: my mental model is that values are evaluated by need. A very crude way of putting my understanding: when you pattern match something, it is evaluated enough to decide if the pattern matches.
09:08:55 <Lus3rJ4m3s> Hay yall?
09:10:48 <Lus3rJ4m3s> Hmm 
09:10:55 <Lus3rJ4m3s> Silence
09:11:20 <berndl> Hello.
09:11:22 * Ariakenom fakes an echo
09:11:37 <Lus3rJ4m3s> Hello berndl what's up?
09:12:44 <berndl> Well, for oen thing I now understand that arrows are monoids in a suitable category of profunctors.
09:13:26 <wroathe> https://www.youtube.com/watch?v=pBWcRqPesws
09:13:53 <Lus3rJ4m3s> So i got that going for me
09:13:57 <Lus3rJ4m3s> Which is 
09:13:59 <Lus3rJ4m3s> Noice
09:14:40 <Lus3rJ4m3s> Try this wroathe > https://youtu.be/mXnJqYwebF8
09:22:49 <__monty__> asheshambasta: Woah, missed the stats. If Opaleye or Squeal/Tisch can fix most of those that's a pretty ridiculous improvement.
09:27:03 <asheshambasta> __monty__: yeah, we used to have an ORM (Scala) before, and we often needed to use the escape hatch and write plain SQL. For a large project, that gets ugly pretty fast, at least in my experience. 
09:27:39 <asheshambasta> But from what I see, -simple seems to be the most feature complete, given postgresql's features like composite types etc. 
09:30:47 * hackage keycloak-hs 0.0.0.0 -   https://hackage.haskell.org/package/keycloak-hs-0.0.0.0 (CorentinDupont)
09:33:14 <hpyCdr> is there a combination of drop and dropWhile which drops at most n elements while condition true?
09:49:25 <dmwit> :t \n p xs -> let (b,e) = splitAt n xs in dropWhile p b ++ e
09:49:26 <lambdabot> Int -> (a -> Bool) -> [a] -> [a]
09:49:36 <dmwit> hpyCdr: No, but it's easy to cook up. ^
09:51:33 <dmwit> :t \n p -> uncurry (++) . first (dropWhile p) . splitAt n
09:51:34 <lambdabot> Int -> (a -> Bool) -> [a] -> [a]
09:54:39 <Mrbuck> I find haskell super productive and very nice and easy than c++........If you want to get productive in 1 language do you still choose hskell than c++ despite poor performance compared to c++
09:55:29 <boj> Mrbuck: you choose the right tool for the job
09:55:36 <Mrbuck> haskell really beautiful code  tahn any langueg I see
09:56:04 <Mrbuck> boj: rightn tool is so wrong word I feel
09:56:26 <boj> Mrbuck: you wouldn't write a hard realtime system in Haskell for example
09:56:48 <hpyCdr> Mrbuck, performance not that critical : Haskell, performance matters : Rust
09:57:07 <Mrbuck> boj:  example ? 
09:57:12 <hpyCdr> dmwit, yeah, I ended up implementing my own. Just trying to avoid doing that if it's already hidden in the standard
09:57:21 <hpyCdr> thanks, tho
09:57:43 <boj> Mrbuck: moon lander, car AI, game graphics engine, fly by wire missile system
09:58:05 <Mrbuck> hpyCdr:  you mean rust as fast as c and as beautiful as haskell...bbut when I say eauty I mean syntax
09:58:14 <Mrbuck> rust syntax still c+= like right ?
09:58:19 <MarcelineVQ> Well you can, you'd just use haskell to generate code in a language that does have a suitable realtime rts
09:58:43 <hpyCdr> Rust is closer to Haskell concept wise, tho. It's kinda a mixture of C++ and Haskell
09:58:48 <dminuoso> MarcelineVQ: The performance of Haskell is not that bad really.
09:58:55 <dminuoso> Oops, you responded too fast.
09:58:57 <Mrbuck> ok boj  thanks 
09:58:58 <dminuoso> I meant Mrbuck. :)
09:59:20 <boj> as MarcelineVQ points out, you could use something like https://ivorylang.org/
09:59:37 <dminuoso> Mrbuck: In general you can expect perhaps half of the speed you could get with say C++ or Rust. It's en-par with Java, and most of the time program code is not your bottleneck anyway. :)
10:00:51 <Mrbuck> dminuoso: ok
10:01:23 <hpyCdr> Mrbuck, if your task is to create a program / algorithm as fast as / faster than Foo, I'd avoid Haskell. But as soon as you have some space for performance degradation, sure, go for it 
10:01:54 <dminuoso> Also Im going to argue that the vast majority of programmers write bad C++ code too.
10:02:05 <hpyCdr> but once you're done and have to squeeze 2x or 4x speed out of it, things can get ugly
10:03:02 <phadej> I could argue that first write in Haskell to get it right
10:03:09 <phadej> and if it's slow, then rethink
10:03:44 <MarcelineVQ> even for a specific Foo I'd be choosing haskell first since it's easier to be fast when doing something specific
10:03:50 <dmwit> First write in math on a whiteboard to get it right. Then do in Haskell to make it executable.
10:04:06 <hackeryarn> It all depends on the problem too. You will have an easier time dealing with parallel and concurrent things in Haskell. That can make a big difference in speed.
10:04:13 <phadej> dmwit: those two can be somewhat combined :)
10:04:19 <hackeryarn> at least easier time than C++
10:04:23 <phadej> or at least interleaved
10:04:25 <hpyCdr> hackeryarn, those are pretty nice in Rust too, tho
10:04:26 <monochrom> Then re-do in Agda to lift it all to the type level? >:)
10:04:31 <hpyCdr> at least hard to do it wrong
10:05:27 <phadej> really, how many write hard realtime systems in any language
10:05:27 <hpyCdr> hackeryarn, you specified C++ after I started writing ;)
10:05:44 <phadej> it's a bit niche argument, isn't it?
10:06:00 <hpyCdr> I e.g. write erosion simulation currently
10:06:09 <hpyCdr> I wouldn't touch that in Haskell
10:06:40 <phadej> someone did maths for you already? :)
10:06:43 <MarcelineVQ> That seems like a really good fit actually :X
10:06:55 <monochrom> I think it's like people haggering when they buy houses.
10:07:01 <Mrbuck> hpyCdr:  what is erosion simulation ?
10:07:33 <phadej> i'd guess a simulation of some physical/chemical system
10:07:40 <MarcelineVQ> erosion sim would be a good match for a haskell gpu combo
10:08:22 <MarcelineVQ> in fact you should ask jle about it when he's around, he'd have good idea on it I'm sure
10:08:22 <Mrbuck> volcano ?
10:09:08 <dyl> MarcelineVQ or Athas, I think he does GPU stuff.
10:09:22 <dyl> e.g. http://hiperfit.dk/pdf/pldi17.pdf
10:12:52 <MarcelineVQ> dyl: yeath athas has done some cool gpu stuff, good link
10:24:03 <Ariakenom> web page for Athas' cool gpu stuff https://futhark-lang.org/
10:31:18 <zincy> How do you perform an IO action in Miso?
10:39:17 * hackage heaps 0.3.6.1 - Asymptotically optimal Brodal/Okasaki heaps.  https://hackage.haskell.org/package/heaps-0.3.6.1 (ryanglscott)
10:49:09 <dmj`> zincy: updateModel action model = model <# SomeAction <$> ioAction
10:49:22 <dmj`> zincy: you might need a 'do' after <#
10:53:38 <zincy> dmj`: thanks! How do you use the result of the action to update the model?
10:54:34 <dmj`> zincy: you'd create another case in the updateModel function for SomeAction like this...
10:54:43 <zincy> say my model field is a timestamp and I want an action called updateTimestamp to get the current  timestamp inside IO monad then update the timestamp field in the model
10:55:01 <dmj`> updateModel (SomeAction val) m = noEff m { field = val }
10:55:48 <dmj`> zincy: for that I'd use a subscription and fork a thread that runs in an infinite loop and delays at an interval, writing the current timestamp to a sink (a function with signature :: a -> IO ())
10:57:40 <zincy> Ok what if its a tx log from a server and you want to timestamp when the msg was received?
10:58:26 <zincy> So the event would be intermittent, the ServerAction would fire when a msg from the server comes in and then you want to update the a server transaction log and timestamp i?
11:02:30 <johnw_> is there a way to put --disable-executable-dynamic inside a .cabal file, so that it's always the default when using cabal configure?
11:04:56 <monochrom> I think no. And I think it is already the default.
11:07:47 * hackage sexpr-parser 0.1.0.0 - Simple s-expression parser  https://hackage.haskell.org/package/sexpr-parser-0.1.0.0 (rcook)
11:08:24 <sicklorkin> :ty (a,Maybe b) -> Maybe (a,b)
11:08:32 <sicklorkin> :type (a,Maybe b) -> Maybe (a,b)
11:08:41 <geekosaur> I think you can do it in cabal.project, which requires v2-* commands
11:09:03 <dmj`> zincy, you can use websockets or server sent events for that
11:09:10 <dmj`> zincy: the examples should show how to use both
11:09:14 <sicklorkin> :t (a,Maybe b) -> Maybe (a,b)
11:09:16 <lambdabot> error: parse error on input ‘->’
11:10:07 <geekosaur> that's a type, it has a kind not a type
11:10:27 <geekosaur> but I don't think that's what you were actually looking for
11:10:57 <sicklorkin> geekosaur: i don't either.
11:11:10 <sicklorkin> :t (.).(.)
11:11:12 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
11:13:15 * Solonarv hoot hoot
11:14:16 <Solonarv> (that operator is sometimes called 'owl'
11:14:28 <sicklorkin> Solonarv: I was gonna say something else
11:14:36 <Solonarv> shhh
11:14:53 <sm> Shake users: when implementing script/command-like targets, have you got a good approach for providing command line arguments ? Do you sacrifice the ability to shake multiple targets at once ?
11:15:00 <sicklorkin> Solonarv: and what about flip owl?
11:15:10 <sicklorkin> is that on?
11:15:23 <sicklorkin> :t on
11:15:24 <Solonarv> I don't know, but check out this package:
11:15:24 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
11:15:29 <Solonarv> @hackage aviary
11:15:29 <lambdabot> http://hackage.haskell.org/package/aviary
11:15:33 <sicklorkin> :t flip (.).(.)
11:15:34 <lambdabot> (b -> c1) -> ((a -> c1) -> c2) -> (a -> b) -> c2
11:15:52 <sicklorkin> :t flip ((.).(.))
11:15:53 <lambdabot> (a1 -> a2 -> b) -> (b -> c) -> a1 -> a2 -> c
11:16:17 <sicklorkin> flip owl is slightly relaxed i guess
11:16:26 <Solonarv> it doesn't do the same thing
11:16:48 <sicklorkin> Solonarv: indeed
11:17:20 <Solonarv> @hackage data-aviary -- grumble grumble arbitrary prefixes
11:17:21 <lambdabot> http://hackage.haskell.org/package/data-aviary -- grumble grumble arbitrary prefixes
11:18:17 <sicklorkin> Solonarv: owl `owl :: ((a -> b) -> a) -> (a -> b) -> b`
11:18:55 <Solonarv> Huh.
11:19:47 * hackage gogol-core 0.4.0 - Core data types and functionality for Gogol libraries.  https://hackage.haskell.org/package/gogol-core-0.4.0 (BrendanHay)
11:20:16 <sicklorkin> i was just looking for some function to lift Maybe from inside my tuple to the outside.. now i'm scratching my head wondering how to use all these birds
11:20:47 <hackage> ACTION gogol-fitness 0.4.0, gogol-mirror 0.4.0, gogol-translate 0.4.0, gogol-monitoring 0.4.0, gogol-remotebuildexecution 0.4.0, gogol-webmaster-tools 0.4.0, gogol-chat 0.4.0, gogol-digitalassetlinks 0.4.0, gogol-serviceconsumermanagement 0.4.0, gogol-tpu 0.4.0, gogol-appstate 0.4.0, gogol-servicenetworking 0.4.0, gogol-admin-datatransfer 0.4.0, gogol-composer 0.4.0, gogol-admin-reports 0.4.0, gogol-qpxexpress 0.4.0, gogol-spectrum 0.4.0, gogol-apps-re
11:21:01 <day> element names in datatypes are not allowed to start with capital letters?
11:21:19 <[exa]> day: no, these are accessors not data constructors
11:21:47 <hackage> ACTION gogol-apps-activity 0.4.0, gogol-surveys 0.4.0, gogol-streetviewpublish 0.4.0, gogol-slides 0.4.0, gogol-storage-transfer 0.4.0, gogol-testing 0.4.0, gogol-speech 0.4.0, gogol-debugger 0.4.0, gogol-safebrowsing 0.4.0, gogol-partners 0.4.0, gogol-servicebroker 0.4.0, gogol-poly 0.4.0, gogol-runtimeconfig 0.4.0, gogol-cloudprofiler 0.4.0, gogol-redis 0.4.0, gogol-storage 0.4.0, gogol-cloudiot 0.4.0, gogol-adsense 0.4.0, gogol-apps-calendar 0.4.0, 
11:21:54 <day> sounds a bit...random
11:22:48 <hackage> ACTION gogol-compute 0.4.0, gogol-androidmanagement 0.4.0, gogol-prediction 0.4.0, gogol-groups-settings 0.4.0, gogol-youtube-reporting 0.4.0, gogol-cloudsearch 0.4.0, gogol-youtube-analytics 0.4.0, gogol-firebase-dynamiclinks 0.4.0, gogol-iamcredentials 0.4.0, gogol-cloudtrace 0.4.0, gogol-adexperiencereport 0.4.0, gogol-dns 0.4.0, gogol-identity-toolkit 0.4.0, gogol-deploymentmanager 0.4.0, gogol-genomics 0.4.0, gogol-admin-directory 0.4.0, gogol-dou
11:22:52 <Solonarv> sicklorkin: you don't need a bird for that! also, as the description states, you probably shouldn't use data-aviary for anything serious.
11:23:07 <Solonarv> % :t sequenceA @((,) _) @Maybe
11:23:07 <yahb> Solonarv: (w, Maybe a) -> Maybe (w, a)
11:23:35 <Solonarv> sicklorkin: I believe this ^ is what you were looking for
11:23:47 * hackage gogol-books 0.4.0, gogol-toolresults 0.4.0, gogol-oslogin 0.4.0, gogol-searchconsole 0.4.0, gogol-serviceusage 0.4.0, gogol-adexchange-buyer 0.4.0, gogol-acceleratedmobilepageurl 0.4.0, gogol-people 0.4.0, gogol-games-management 0.4.0, gogol-groups-migration 0.4.0, gogol-manufacturers 0.4.0, gogol-ml 0.4.0, gogol-sheets 0.4.0, gogol-script 0.4.0, gogol-fusiontables 0.4.0, gogol-logging 0.4.0 (BrendanHay)
11:24:14 <sicklorkin> Solonarv: I would never use birds for anything other than gazing at.
11:25:08 <sicklorkin> Solonarv: mission accomplished.. Thanks!
11:25:34 <[exa]> day: not at all; data constructors are creating something, field names are (outside of the datatype definition) functions for taking the same thing apart
11:27:02 <sicklorkin> Solonarv: oh is `traverse id` the same thing?
11:27:36 <[exa]> yes
11:27:43 <Solonarv> sicklorkin: yes; 'sequenceA = traverse id' and 'traverse f = sequenceA . fmap f'
11:28:00 <sicklorkin> I think i've learned something..
11:28:00 <Solonarv> that's why you only need to define one of 'sequenceA' and 'traverse' when writing a Traversable instace
11:29:42 <sicklorkin> Looks like either Finkle or Einhorn 
11:30:49 <Solonarv> huh?
11:31:13 <sicklorkin> Ace Ventura?
11:31:17 <MarcelineVQ> sicklorkin: that's showing your age :>
11:31:40 <sicklorkin> MarcelineVQ: Finally someone gets the reference
11:32:13 <MarcelineVQ> shucks son, I've got references about that reference
11:37:11 <zincy> dmj`: Thanks I have managed to get it to compile using the reversed smart constructor seemed to work. What is the easiest way to print show the model for debugging purposes?
11:39:37 <day> [exa]: well it comes down to enforcing coding styles. some like it some dont
11:46:52 <dmj`> zincy: you can print the model after any action, updateModel action model = model <# do print model >> HandleResult <$> ioAction 
11:48:43 <Disavowed> Morning all. Anyone have any preferred or noteworthy plugins they use for Haskell development in Vim?
11:49:06 <sicklorkin> Disavowed: hdevtools ftw
11:49:31 <zincy> dmj`: Does the printing occur in the browser console?
11:50:05 <Disavowed> sicklorkin: This is exactly what I was after - the plugin I didn't even know I needed!
11:50:17 <sicklorkin> Disavowed: ghcid is always a good alternative but is meant to be run in a separate terminal.
11:50:17 <dmj`> zincy: ah, I forgot, as of ghcjs 8.2 I believe, print does not show up in the console. It's a bug. You might need to use the miso consoleLog function 
11:51:02 <Disavowed> sicklorkin: But you prefer hdevtools?
11:51:17 <dmj`> zincy: foreign import javascript unsafe "console.log($1);" consoleLog :: MisoString -> IO ()
11:51:18 <sicklorkin> Disavowed: combine hdevtools with Ale.
11:51:25 <sicklorkin> Disavowed: i use both.. 
11:51:31 <dmj`> zincy: consoleLog $ ms (show model)
11:52:25 <Disavowed> sicklorkin: I could see that working well with Ale. Thank you so much for this. 
11:53:10 <sicklorkin> Disavowed: *but* if you are using stack / hpack you may run into issues.. since upgrading a few months ago it no longer works as designed.. i now have to remove my cabal file contents before it will start..
11:54:37 <sicklorkin> Disavowed: I haven't looked into the details enough to know how to fix it.. there's also M$'s opensource IDE protocol (I forget the name of it) but Haskell supports it so I suspect there will be a lot of cool plugins coming in the near future.
11:55:16 <sicklorkin> Language Server Protocol
11:55:28 <Disavowed> sicklorkin: Good tip - thank you. I'm using Stack as well so that would surely have burned me
11:55:37 <zincy> dmj`: Seems like consoleLog expects a ghcjs-prim-0.1.0.0:GHCJS.Prim.JSVal and not a MisoString
11:55:54 <zincy> How would I do the conversion to that type?
11:56:47 <dmj`> zincy: you can either use the foreign import I defined above, or define a ToJSVal instance for your model and use the function miso exports
11:57:42 <dmj`> zincy: instance ToJSVal model will require that your model derives Generic from import GHC.Generics and you have {-# LANGAUGE TemplateHaskell #-}
12:00:11 <sicklorkin> Disavowed: g'luck.. https://pastebin.com/RJPiZXE6
12:01:29 <Disavowed> sicklorkin: This is so helpful! Thank you so much mate. I bet the output redirect alone would have taken me ages to figure out! 
12:01:40 <Disavowed> Really appreciate that. Nice one.
12:01:44 <sicklorkin> Disavowed: in the root of your repo drop hd.sh; run ./hd.sh... if it successfully starts (no errors) then it started
12:02:45 <sicklorkin> Disavowed: if you happen to fix the issue I'm having above please tell me the fix ;)
12:03:14 <zincy> dmj`: Oh toJSVal in GHCJS.Marshal is inside the IO monad? Would that mean I would need to add a new action for printing to the console?
12:05:14 <dmj`> zincy: you just need a way to create a JSVal from your model, and then consoleLog will take care of the IO that prints it to the console
12:06:05 <Disavowed> sicklorkin: Naturally! Though I'm a neophyte - I suspect instead of rewarding you with a solution, I'll just have more dull-witted questions! 
12:07:06 <zincy> dmj`: Am I correct in saying you need to marshal the model string to a JSVal inside IO?
12:09:13 <dmj`> zincy: yes, but the IO that does that is derived for you, in the ToJSVal instance
12:09:44 <dmj`> zincy: (consoleLog <=< toJSVal) model
12:10:18 <zincy> dmj`: Gotcha - it makes it quite fiddly doesn't it? It is actually easier to just render the showed model string as an html element? :D
12:10:52 <dmj`> zincy: you can definitely embed the model as a text node in the DOM
12:11:29 <zincy> Yeah that works for me.
12:11:31 <dmj`> zincy: that works well too, good idea ;)
12:11:52 <zincy> Laziness can be productivity enhancing.
12:12:19 <dmj`> :)
12:15:00 <spots> Hi, I stuck with a problem and hoping that some might be able to help me. When I have a 'Right [Char]', how do convert that to a list again so I can apply functions to it?
12:15:42 <suzu> pattern match on the `Right` to pull the [Char] out
12:16:02 <geekosaur> also consider what happens if you have a Left instead; presumably the Maybe is there for a reason
12:16:05 <geekosaur> also
12:16:07 <geekosaur> :t maybe
12:16:08 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:16:09 <geekosaur> er
12:16:13 <suzu> you mean either
12:16:14 <geekosaur> :t either
12:16:15 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
12:16:16 <spots> It's Either
12:16:18 <geekosaur> and Either
12:16:22 <spots> Left is the error case
12:16:26 <geekosaur> yeh
12:16:33 <geekosaur> you're expected to handle it, not ignore it
12:16:53 <geekosaur> so pattern match or use the either function as above
12:17:07 <geekosaur> (providing a function for the Left case and one for the Right case)
12:19:47 <zincy> dmj`: What are subs for in Miso?
12:20:37 <dmj`> zincy: They're like long-running actions that aren't necessarily event-based, but time-interval based. 
12:22:12 <zincy> dmj`:  The use of [  websocketSub uri protocols HandleWebSocket ] in the websockets example looks event based?
12:25:23 <dmj`> zincy: subscriptions use websockets since a websocket connection is long-lived. The subscription will store the websocket connection in a global IORef, and connect the websocket receive callback to the subscription action sink.
12:25:43 <dmj`> zincy: maybe it'd be better to say subscriptions are for long-lived IO actions
12:34:31 <spots> pattern matching worked for me, thanks.
12:40:41 <NoidedSuper> Here's a question: What packages have you guys used recently that need better documentation?
12:40:54 <NoidedSuper> I'm looking for projects to contribute to and improving docs is always a great way to go about this.
12:49:49 <sm> hledger!
12:50:15 <sm> stack
12:50:26 <sm> how many do you want :)
12:52:19 <NoidedSuper> Hledger seems to have a lot of issues open!
12:52:23 <NoidedSuper> That should keep me occupied for a bit
12:53:10 <sm> NoidedSuper++
12:53:24 <NoidedSuper> sm++
12:53:31 <NoidedSuper> Thanks for answering the question
13:12:17 * hackage licensor 0.3.0 - A license compatibility helper  https://hackage.haskell.org/package/licensor-0.3.0 (jpvillaisaza)
13:21:02 <MarcelineVQ> NoidedSuper: never seen someone that noided before. I​ mean, I've seen footage, but I never though I'd meet anyone
13:21:39 <NoidedSuper> I've got static on my blindside
13:23:15 <MarcelineVQ> crazy shit man, crazy shit :>
13:25:17 * hackage sexpr-parser 0.1.1.0 - Simple s-expression parser  https://hackage.haskell.org/package/sexpr-parser-0.1.1.0 (rcook)
13:29:47 <suzu> so i'm using stack
13:29:53 <Welkin> bad suzu
13:29:54 <suzu> i'm on an LTS that has containers ver 6
13:30:03 <suzu> i want to use a dep that needs containers ver 5
13:30:05 <suzu> tf do i do
13:30:11 <Welkin> burn it to the ground
13:30:28 <Welkin> use cabal
13:30:32 <Solonarv> use a different snapshot, and/or use a different (newer) version of that dep
13:30:33 <suzu> use cabal??????????????????????
13:30:36 <Welkin> yes
13:30:42 <suzu> there is no newer dep that supports the newer contaniers
13:30:52 <suzu> wdym use cabal, i thought stack was to solve cabal
13:31:02 <Welkin> that was 4 years ago
13:31:07 <suzu> oh snap
13:31:07 <Welkin> cabal is better than stack now
13:31:15 <suzu> ok, what do
13:31:29 <Solonarv> use cabal, stick to the v2-* commands ("nix-style local builds")
13:31:44 <Welkin> if necessary you can force newer versions in your cabal.package file
13:32:08 <Welkin> but try by starting with a *.cabal with your dependency list and run `cabal new-build`
13:32:43 <suzu> cabal: failed to parse output of 'ghc-pkg dump'
13:32:45 <suzu> wut
13:33:00 <Solonarv> suzu: what's cabal --version?
13:33:02 <Welkin> cabal --version
13:33:08 <suzu> cabal-install version 1.24.0.2
13:33:09 <suzu> compiled using version 1.24.2.0 of the Cabal library
13:33:11 <Welkin> wow
13:33:12 <Solonarv> woof
13:33:15 <Welkin> install haskell platform
13:33:19 <suzu> i use arch
13:33:20 <Welkin> it will take a few seconds
13:33:30 <Welkin> oh boy
13:33:37 <suzu> cabal seems to have been installed by stack
13:33:37 <Solonarv> system packages have a tendency to be broken
13:33:43 <Solonarv> *especially* the arch packages
13:33:44 <Welkin> at least install the cabal binary
13:33:49 <Welkin> cabal is on 2.4.1
13:33:51 <suzu> > which cabal
13:33:53 <suzu> /home/user/.local/bin/cabal
13:33:53 <lambdabot>  error: Variable not in scope: which :: t0 -> terror: Variable not in scope: ...
13:34:09 <Solonarv> oh good, at least it's managing itself already
13:34:10 <suzu> > /usr/bin/cabal --version
13:34:12 <suzu> cabal-install version 2.4.0.0
13:34:12 <lambdabot>  <hint>:1:1: error: parse error on input ‘/’
13:34:14 <suzu> compiled using version 2.4.0.1 of the Cabal library
13:34:16 <suzu> the system cabal is up-to-date
13:34:29 <Welkin> kill the old version
13:34:57 <suzu> can i just delete it from there? is that safe?
13:35:23 <Solonarv> should be
13:35:30 <suzu> i'll rename it just in case
13:35:31 <suzu> to _cabal
13:36:09 <merijn> Welkin: 1.24 isn't that old
13:36:58 <merijn> Welkin: 1.24 was released around the same time as 2.0, and since cabal-install follows GHC habit of odd version = dev, that means it's only two releases behind
13:37:10 <Welkin> it's from May 2016
13:37:16 <merijn> I mean, you really want 2.4 because of v2-amazingness
13:37:18 <Welkin> that is almost 3 years old
13:37:19 <merijn> But still
13:38:40 <MarcelineVQ> k like <_<
13:38:50 <MarcelineVQ> a yaml with "allow-newer: true" is a lot less of a step than changing the build-chain, at least it lets a person determine if the only issue is with version difference
13:38:53 <suzu> uh okay so i just let 'cabal new-build' loose and it seems to be working hard
13:39:09 <suzu> do i just expect cabal new-* to just work and be smart?
13:39:12 <suzu> is there anything i need to know?
13:39:33 <merijn> suzu: If the cabal files of packages are done right, then yes, you just wait :)
13:39:52 <suzu> do i need the cabal file of my own project to be done right?
13:40:28 <merijn> suzu: Right enough to find a correct buildplan :p
13:40:39 <suzu> i don't really add desired dep versions..
13:40:50 <spacekitteh[m]> anyone know how to do this correctly in Stack? i get an this error: error: undefined variable 'arg' at (string):1:3. the command i actually run is: stack build --nix-shell-options --arg testDeps 'false'
13:40:54 <suzu> maybe that's important. lol
13:41:05 <suzu> uh oh shit didnt build
13:41:06 <Solonarv> kind of, yeah :P
13:41:14 <suzu> There are files missing in the ‘base-4.12.0.0’ package,
13:41:33 <Solonarv> I blame arch
13:41:47 <merijn> suzu: How did you install GHC?
13:41:48 <MarcelineVQ> That is the correct thing to blame here
13:41:54 <suzu> via arch
13:41:57 <Solonarv> recommended solution: remove system haskell packages, use ghcup
13:42:00 <merijn> suzu: ghc or ghc-static?
13:42:13 <suzu> ghc
13:42:17 <suzu> /usr/bin/ghc is owned by ghc 8.6.3-1
13:42:23 <NoidedSuper> arch has a lot of problems with GHC doesn't it?
13:42:25 <merijn> suzu: IIRC you want ghc-static on Arch
13:42:30 <suzu> fucking arch
13:42:33 <suzu> alright lemme swap that out
13:43:03 <merijn> NoidedSuper: Arch's Haskell maintainers intentionally setup things differently from the "regular" workflow used for Haskell because of pedantic (and wrong) reasons and insist on keeping it that way, so yes
13:43:14 <suzu> hmm, i can install 'ghc-static' alongside ghc..?
13:43:24 <NoidedSuper> That's highly irritating lol
13:43:27 <spacekitteh[m]> NoidedSuper: death grips fan?
13:43:32 <suzu> xmonad needs 'ghc'
13:43:40 <NoidedSuper> Yes spacekitteh[m]
13:44:30 <merijn> NoidedSuper: Basically, Arch maintainers want everything linked dynamically, which is not the default for GHC/Haskell, so they changed the default GHC to work that way and then magically all the normal Haskell workflows break because dynamic linking isn't normally done
13:44:37 <Welkin> don't nobody got time to deal with arch
13:44:57 <NoidedSuper> I mean there are benefits to dynamic linking but if nobody uses it
13:45:04 <NoidedSuper> then it's pretty stupid to make that the default on your distro 
13:45:08 <merijn> NoidedSuper: Not for Haskell, though
13:45:24 * hololeap uses haskell on gentoo ... with everything dynamically linked <_<
13:45:31 <merijn> NoidedSuper: The usual benefits of dynamic linking are "packages can be shared" and "packages can be updated independently"
13:45:40 <NoidedSuper> And that doesn't work with Haskell?
13:45:49 <merijn> NoidedSuper: But the way GHC compiles packages makes it hard, if not impossible to upgrade dependencies transparently
13:46:11 <NoidedSuper> Has there been any effort to give it a more stable ABI or whatever? 
13:46:17 <NoidedSuper> Or has that generally been seen as pointless? 
13:46:27 <merijn> NoidedSuper: To get better performance GHC inlines and specialises across package boundaries, which means that dependency details leak into dependent APIs
13:46:42 <merijn> NoidedSuper: The problem is that stabilising the ABI will cost performance
13:46:56 <NoidedSuper> which is not worth it 
13:46:58 <NoidedSuper> rip
13:47:22 <merijn> NoidedSuper: Well, there is some work on things now, hence why dynamic linking is a thing. It's just not a recommended default now
13:47:27 <spacekitteh[m]> gentoo
13:47:31 <spacekitteh[m]> or nix :P
13:47:56 <hololeap> yeah on gentoo if any package gets an upgrade, you have to recompile every reverse-dependency, so it gives its fair share of headaches as well
13:48:20 <spacekitteh[m]> yeah. i ran gentoo on a netbook for a couple of years. that was fun.
13:48:24 <merijn> NoidedSuper: Basically, suppose you use ByteString, right now GHC can basically dump parts of the ByteString functions into interface files, inline them in libraries using it and then optimise those libraries further. But the cost (obviously) is that internals of ByteString leak into that library
13:48:45 <NoidedSuper> (Also uh. That question I had about good packages to contribute to stands again because I think HLedger is a bit more than I can chew right now lol. So if you have a package that needs better docs or w/e pls let me know thanks)
13:49:07 <hololeap> but apparently there's no way around it because of the way GHC handles ABIs
13:49:15 <merijn> NoidedSuper: So now you can't update ByteString without updating the other library too, so "independent upgrades" are out. Sharing is still an advantage, but only really if you *really* care about disk space AND have lots of Haskell packages installed
13:49:26 <NoidedSuper> Even in C if you use LTO you can't also use dynamic linking 
13:49:27 <NoidedSuper> IIRC 
13:49:41 <merijn> NoidedSuper: What GHC does is very similar/reminiscent of LTO, yes
13:49:47 <Welkin> Low Transfer Orbit?
13:49:52 <NoidedSuper> Link time optimization
13:49:53 <merijn> Welkin: Link Time Optimisation
13:50:17 * hackage jsaddle-dom 0.9.3.0 - DOM library that uses jsaddle to support both GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-dom-0.9.3.0 (HamishMackenzie)
13:50:25 <hololeap> luckily portage allows you to compile packages in parallel as long as they are not dependent on each other
13:50:57 <NoidedSuper> actually are there any like
13:50:58 <merijn> hololeap: Well, the recommended way to install Haskell applications on user systems would be to just have cabal build a single binary for the application and install that. By exposing the Haskell dependencies as part of the package manager things are made more painful
13:51:27 <merijn> hololeap: Because now you only rebuild things when the actual application changes, rather than churning on any change in any part of the dependencies
13:51:32 <NoidedSuper> Er, this is unrelated to the current optimization/linking discussion, but does this IRC have any ongoing "group projects" or whatever?
13:51:48 <merijn> NoidedSuper: GHC and similar tooling? ;)
13:51:52 <dmj`> how do I cap the number of threads the GHC RTS uses?
13:51:58 <hololeap> it works well enough, though. there's a tool to convert .cabal files into gentoo packages
13:52:00 <NoidedSuper> Well yeah but I am uncertain if I'm smart enough to work on GHC
13:52:04 <merijn> dmj`: You mean the number of OS threads?
13:52:17 <dmj`> merijn: yes
13:52:39 <Solonarv> +RTS -N4 -RTS on the command line IIRC
13:52:51 <NoidedSuper> I did submit a patch re-writing an internal hash table in the RTS but it wasn't up to snuff
13:52:57 <merijn> dmj`: The magic term you want is "capabilities". The  GHC.Conc modules have a bunch of functions and the GHC user guide has a bunch of stuff on setting runtime options
13:53:39 <dmj`> merijn: I am not referring to the number of OS threads a haskell program uses to evaluate green threads, but rather the number of OS threads the GHC RTS itself uses. Is there any way to set a cap on those
13:54:05 <merijn> dmj`: That's related to foreign calls being done, afaik
13:54:27 <merijn> dmj`: I'd still consult the user's guide :p
13:54:53 <merijn> Also, related question: Why specifically "RTS threads" rather than all threads?
13:55:28 <dmj`> merijn: the program I have in question is not compiled with the -threaded flag
13:55:44 <merijn> That's not an answer to "why", though :)
13:56:37 <dmj`> The code runs faster without -threaded, yet still performs FFI calls (that I assume the RTS spawns additional OS threads to handle, I'd like to cap these, via a setting, if possible)
13:58:06 <merijn> What is the purposes of limiting those?
14:01:18 <dmj`> merijn: We are running on a large computer with 96 cores, we want to run multiple single-threaded processes, but each one spawns an OS thread pool for the RTS of size 96 (afaik), so it causes contention for resources, and runs a lot slower
14:02:40 <merijn> dmj`: That...doesn't sound right? Relatedly, with that many cores, the threaded version was probably slow as shit due to parallel GC (generally) being a net performance loss on machines with very many cores
14:03:20 <merijn> dmj`: You can try using the threaded runtime with paralle GC disabled and see if performance becomes similar to the unthreaded one
14:04:35 <merijn> dmj`: I had to do that for my code on the cluster machines (32 cores or more) to avoid ridiculous slowdown from parallel GC. Reduced the runtime from several minutes to 10s for me
14:04:56 <phadej> dmj`: so you run with `+RTS -N1` ?
14:05:16 <merijn> Which doesn't solve the "unthreaded runtime spawning 96 threads" problem, but that sounds like the runtime doing something horribly wrong
14:05:19 <dmj`> merijn: That's exactly what I tried (one giant haskell process without parallel GC), but it did not yield results that were faster than running multiple individual haskell processes
14:05:20 <phadej> if you run process single-threaded, don't use threaded RTS?
14:05:39 <merijn> phadej: He said the non-thread RTS is spawning 96 threads
14:05:56 <dmj`> phadej: It's my understanding that -N1 is only for -threaded, and does not cap the number of OS threads the RTS uses
14:06:16 <merijn> Now I know the "non-threaded" runtime spawns threads for foreign calls, but spawning 1 per CPU sounds horribly wrong
14:06:21 <dmj`> merijn: specifically the GHC RTS was spawning 96 threads, not the Haskell program
14:06:59 <dmj`> merijn: I agree, the way I capped it was by setting OMP_NUM_THREADS
14:07:05 <dmj`> to the number of virtual CPUs available
14:07:18 <dmj`> the GHC RTS abided by this
14:07:20 <merijn> dmj`: Maybe ask in #ghc to see if anyone knowledgable on the RTS is around
14:10:43 <dmj`> merijn: ok, I'll ask
14:12:43 <merijn> dmj`: Or dive into the RTS and find out for us! ;)
14:13:00 <merijn> dmj`: Oh, incidentally, how long running are these C calls?
14:13:03 <phadej> hmm, a small program (which doesn't do any ffi) has only single thread on my machine
14:13:32 <merijn> phadej: I think the RTS spawns them on demand, and in #ghc he mentions doing lots of FFI calls
14:13:55 <merijn> I wonder if -threaded for unsafe foreign calls might be better...
14:14:20 <merijn> dmj`: And how many forkIO threads is your program using?
14:14:36 <dmj`> merijn: 0 forkIO's
14:14:44 <dmj`> merijn: ag 'forkIO' shows nothing
14:15:18 <merijn> dmj`: Yeah, but are you using async or similar?
14:15:43 <merijn> Your code not calling forkIO doesn't mean no one else is ;)
14:16:12 <dmj`> merijn: sure, we are doing some network IO with amazonka, but we're not compiled with -threaded
14:16:33 <merijn> dmj`: So? The unthreaded runtime system still allows arbitary numbers of green threads
14:17:07 <merijn> dmj`: The reason I ask is that using unsafe foreign calls would eliminate the issue, but whether that's safe or sensible depends on lots of things
14:17:35 <dmj`> merijn: the network IO calls are issued synchronously
14:18:00 <merijn> Specifically, unsafe foreign calls will block the (single, in the unthreaded RTS) capability until they return. This means not a single forkIO thread (via async or otherwise) can run, nor will GC be able to run until the foreign calls return
14:18:12 <dmj`> merijn: all the foreign imports are unsafe
14:18:44 <merijn> dmj`: Then the problem might not be your foreign calls, but those by libraries
14:18:55 <merijn> dmj`: unsafe foreign imports do not use extra RTS threads
14:22:10 <dmj`> merijn: really... that's good to know
14:22:17 <dmj`> merijn: are you positive
14:22:28 <merijn> dmj`: Also, all your foreign imports being unsafe is...questionable
14:23:28 <merijn> dmj`: http://blog.ezyang.com/2010/07/safety-first-ffi-and-threading/ and http://blog.ezyang.com/2014/12/unintended-consequences-bound-threads-and-unsafe-ffi-calls/
14:23:42 <dmj`> merijn: it's all hmatrix, every foreign call there is unsafe
14:23:47 * hackage ghcjs-base 0.2.0.0 - base library for GHCJS  https://hackage.haskell.org/package/ghcjs-base-0.2.0.0 (HamishMackenzie)
14:25:41 <merijn> dmj`: Specifically Simon Marlow's comment on one of those: "An unsafe foreign call is implemented as an inline C function call, no synchronisation or anything happens around it."
14:25:49 <dmj`> merijn: the majority of foreign calls in network are also unsafe
14:26:00 <dmj`> merijn: which is what amazonka would be using iirc
14:35:47 * hackage oset 0.1.1.0 - An insertion-order-preserving set  https://hackage.haskell.org/package/oset-0.1.1.0 (rcook)
14:37:00 <dmj`> merijn: without -threaded the parallel GC isn't on
14:37:17 <dmj`> merijn: and all the foreign calls are unsafe, so therefore, I have no idea why this many OS threads are being spawned
14:38:00 <merijn> dmj`: *something* must be doing foreign calls to spawn those, but I dunno the best way to investigate
14:38:07 <phadej> dmj`: then you have to try to miniize your program to see removing what removes the threads
14:38:14 <ClaudiusMaximus> dmj`: that OMP_NUM_THREADS works makes me think some foreign code is using openmp to spawn its own threads?
14:38:23 <merijn> ClaudiusMaximus: Oh!
14:38:27 <twm_> Hello! I have a general FP question (not haskell specific) anyone know of a better channel for such a question?
14:38:35 <merijn> Wow, I didn't think of that
14:38:54 <merijn> dmj`: Is hmatrix maybe using OpenMP internally?
14:39:11 <phadej> DwarfMaster: you can get haskell specific answer here
14:39:27 <merijn> twm_: FP in generaly is still on topic here, if you don't mind Haskell specific answers ;)
14:40:08 <dmj`> merijn: the nix derivation and hmatrix source don't show open mp 
14:40:30 <dmj`> merijn: wait!
14:40:48 <dmj`> I found this in the pkgconfig for openblas
14:40:54 <dmj`> openblas_config= USE_64BITINT= DYNAMIC_ARCH=1 DYNAMIC_OLDER= NO_CBLAS= NO_LAPACK= NO_LAPACKE= NO_AFFINITY=1 USE_OPENMP=1 ATHLO\
14:40:54 <dmj`> N MAX_THREADS=64
14:41:24 <dmj`> is openmp inside of openblas?
14:41:24 <merijn> Mystery solved ;)
14:41:33 <dmj`> no I don't believe it
14:41:38 <merijn> dmj`: It wouldn't surprise me?
14:41:54 <twm_> Lets say I need map a list of one type (X) to another type (Y). Type Y depends on information from X as well as a dictionary lookup. I would like to write map that accepts one of the X and the dictionary, and produce Y. Is this function a common pattern?
14:42:16 <twm_> Or would it just be map with the dictionary partially applied?
14:42:53 <merijn> dmj`: Quick google suggests openblas can use OpenMP
14:43:21 <dmj`> merijn: it must be yea
14:43:48 <merijn> dmj`: Which would also explain why (I forgot who? phadej?) couldn't reproduce more than 1 thread earlier
14:44:26 <merijn> I also don't see why OMP_NUM_THREADS would affect the RTS at all
14:44:28 <dmj`> merijn: is libgomp.so.1 open mp
14:45:13 <merijn> Yes, no, maybe? :)
14:46:35 <dmj`> it is :)
14:46:45 <dmj`> merijn: thanks a lot for this
14:46:47 <dmj`> ClaudiusMaximus: you as well
14:46:49 <dmj`> phadej: and you
14:47:20 <suzu> k so i didn't switch off cabal-newbuild
14:47:26 <suzu> i stayed on stack
14:47:34 <gentauro> % let foo = 42; bar = 'c'; baz = "meh"; qux = [] in (foo,bar,baz,qux)
14:47:34 <yahb> gentauro: (42,'c',"meh",[])
14:47:35 <suzu> and i fixed the issue by using newer vers of the deps from gh
14:47:46 <gentauro> how would you re-write that statement in `lambdas`?
14:47:52 <merijn> dmj`: I wonder if the performance gains from different processes is just OpenMP barriers forcing your parallel threads to sequentialise ;)
14:48:00 <gentauro> (convert `let .. in` to pure lambdas?
14:48:15 <merijn> gentauro: For what purpose?
14:48:40 <gentauro> I have read that `let .. in` is just `syntactic sugar` for lambda calculus, but I can't see it :(
14:48:42 <suzu> > (,,,) 42 'c' "meh" []
14:48:44 <lambdabot>  (42,'c',"meh",[])
14:49:05 <gentauro> suzu: I'm looking for something like `\ x -> ...`
14:49:09 <suzu> okay
14:49:16 <merijn> gentauro: Whether that is true depends on various definitions of "true", "syntactic sugar", and "lambda calculus" :)
14:49:26 <suzu> > (\a b c d -> (,,,)) 42 'c' "meh" []
14:49:28 <lambdabot>  error:
14:49:28 <lambdabot>      • No instance for (Typeable a0)
14:49:28 <lambdabot>          arising from a use of ‘show_M39893673987810676695810’
14:49:32 <suzu> err oops
14:49:38 <suzu> > (\a b c d -> (a,b,c,d)) 42 'c' "meh" []
14:49:40 <lambdabot>  (42,'c',"meh",[])
14:49:46 <merijn> gentauro: Where did you read/hear that? :)
14:50:21 <gentauro> "In addition to application, a construct known as a let binding is often added to the lambda calculus syntax. In the untyped lambda calculus, let bindings are semantically equivalent to applied lambda expressions."
14:50:34 <gentauro> http://dev.stephendiehl.com/fun/lambda_calculus.html
14:50:47 * hackage failable 1.0.0.0 - A 'Failable' error monad class to unify failure across monads that can fail  https://hackage.haskell.org/package/failable-1.0.0.0 (erick)
14:50:56 <gentauro> suzu: thx
14:51:49 <Solonarv> note that it gets slightly more complicated for recursive let-bindings
14:52:04 <merijn> gentauro: Right "let foo = xyzzy in bar" can be translated to "(\foo -> bar) xyzzy" (given appropriate parentheses around xyzzy if it's a compound expression
14:52:16 <gentauro> Solonarv: yeah, I'm about to reach -> http://dev.stephendiehl.com/fun/lambda_calculus.html#recursion ;)
14:52:42 <merijn> gentauro: Incidentally, if you like that series, I can strongly recommend having a look at TaPL :)
14:52:45 <merijn> @where tapl
14:52:45 <lambdabot> "Types and Programming Languages" by Benjamin C. Pierce in 2002-02-01 at <https://www.cis.upenn.edu/~bcpierce/tapl/>
14:53:16 <merijn> gentauro: It starts from untyped lambda calculus and builds up to "more than you ever wanted to know about typechecking and inference" :)
14:53:32 <gentauro> merijn: I have it on my list of books to read ;)
14:53:52 <merijn> :)
15:31:11 <iqubic> Let's say that I want to state in my *.cabal file that my project depends on gnuplot. How would I do that?
15:32:11 <sclv> The gnuplot binary program?
15:32:47 <iqubic> Yes.
15:33:21 <iqubic> I'm writting a project that uses this library: https://hackage.haskell.org/package/gnuplot
15:35:09 <Solonarv> I don't believe there is a way to state that in a cabal file
15:35:25 <Solonarv> (you can depend on the 'gnuplot' package that you linked, of course)
15:39:09 <jackdk> build-type: Configure and write a configure.ac?
15:39:22 <Solonarv> I guess that could work
16:04:28 <iqubic> Solonarv: That kinda stinks.
16:04:50 <iqubic> jackdk: Is it possible to get nix to grab gnuplot for me?
16:05:05 <Solonarv> That seems to be exactly what nix was invented for.
16:05:23 <iqubic> I know.
16:05:25 <jackdk> probs. it's in nixpkgs
16:05:30 <iqubic> I'm running nixos.
16:06:31 <jackdk> it's in my channel on my nixos machine
16:07:43 <jackdk> I'd try calling overrideAttrs on a derivation you're building
16:08:26 <iqubic> Right... But how do I write a shell.nix that puts gnuplot into my sandbox environment?
16:11:43 <jackdk> https://git.sr.ht/~jack/libtelnet-haskell/tree/master/shell.nix#L6 is how I add tools for my shell. For your case (it sounds like your package finds and calls a gnuplot executable?) I'd override in default.nix to fiddle the attrs of the expression generated by cabal2nix
16:12:15 <iqubic> Yeah. That's right.
16:12:43 <jackdk> also I should probably be using overrideAttrs and not overrideDerivation, according to the nixpkgs manual
16:12:51 <jackdk> but it might point in the right direction
16:20:01 <iqubic> sure.
16:24:47 * hackage function-builder 0.3.0.0 - Create poly variadic functions for monoidal results  https://hackage.haskell.org/package/function-builder-0.3.0.0 (SvenHeyll)
16:27:17 * hackage function-builder 0.3.0.1 - Create poly variadic functions for monoidal results  https://hackage.haskell.org/package/function-builder-0.3.0.1 (SvenHeyll)
16:28:43 <aplainzetakind> What are good tutorials to get into type level stuff? (particularly, my most immediate goal is to understand servant).
16:31:35 <hpc> the ghc manual's language extension docs are a good start
16:31:46 <iqubic> jackdk: Yeah. I was looking through the haskell gnuplot haskell library code and it turns out that it calls: readProcessWithErrorCode using gnuplot as the first input.
16:31:48 <iqubic> https://hackage.haskell.org/package/process-1.2.0.0/docs/System-Process.html#v:readProcessWithExitCode
16:31:53 <hpc> it won't give you much theory, but being able to use the extensions helps for learning the theory later
16:34:43 <aplainzetakind> hpc: Thanks.
16:35:29 <spacetato> n/quit
16:47:44 <lukelau> When using {-# LANGUAGE TemplateHaskell #-} it always seems to use the types from template-haskell on Hackage. Is there a way to get it to use the types from https://hackage.haskell.org/package/ghc-lib?
16:50:31 <Solonarv> If RebindableSyntax doesn't do it then probably not
16:51:45 <Solonarv> remember: the TH code needs to be executed; ghc-lib can't do that
16:54:17 * hackage jsaddle-dom 0.9.3.1 - DOM library that uses jsaddle to support both GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-dom-0.9.3.1 (HamishMackenzie)
17:06:34 <lukelau> Solonarv: RebindableSyntax worked, thanks. Interestingly enough ifThenElse isn’t supported in ghc-lib
17:09:30 <lukelau> Nevermind: rebindable syntax was just throwing off if then elses in TH, types are still different
17:16:54 <NoidedSuper> test
17:19:56 <Solonarv> NoidedSuper: test success?
17:20:13 <NoidedSuper> Yes.
17:58:01 <z0> > show $ recip 7
17:58:03 <lambdabot>  "0.14285714285714285"
17:58:17 <z0> > (show . recip) 7
17:58:19 <lambdabot>  "0.14285714285714285"
17:58:24 <z0> > show . recip 7
17:58:26 <lambdabot>  error:
17:58:26 <lambdabot>      • Could not deduce (Fractional (a1 -> a0))
17:58:27 <lambdabot>          (maybe you haven't applied a function to enough arguments?)
17:58:53 <z0> ah ok i had a question but immediatly lightbulbed. sorry about that
17:59:07 * Solonarv pats lambdabot
17:59:12 <Solonarv> good rubberduck :>
17:59:26 <[Leary]> @botsnack
17:59:26 <lambdabot> :)
17:59:42 <z0> you bet
18:20:47 * hackage shimmer 0.1.3.4 - The Reflective Lambda Machine  https://hackage.haskell.org/package/shimmer-0.1.3.4 (BenLippmeier)
18:26:58 <coldpress> aplainzetakind: what is this servant, that you're trying to understand?
18:28:23 <geekosaur> http://hackage.haskell.org/package/servant
18:34:18 <jackdk> aplainzetakind: http://www.well-typed.com/blog/2015/11/implementing-a-minimal-version-of-haskell-servant/
18:35:00 <jackdk> for type-level stuff in general, jle's blog is usually good (and the series on singletons particularly so)
18:35:08 <jackdk> https://blog.jle.im/entry/introduction-to-singletons-1.html
18:54:36 <iqubic> jackdk: How does one use nix to specify a dependency on a binary program?
18:55:23 <jackdk> add it to nativeBuildInputs, I think
18:55:46 <suzu> add it to a parent derivation, yeah
18:56:14 <iqubic> can I see an example of that?
18:56:57 <iqubic> https://paste.pound-python.org/show/PN9mdkg9LfOSu9AejA12/
18:57:01 <iqubic> https://paste.pound-python.org/show/NyYrYRrvQfDjYXFZToS2/
18:57:06 <iqubic> https://paste.pound-python.org/show/Nfe7dkhC6qojIPLA8CbU/
18:58:59 <iqubic> I would like to be able to manage bohmian.nix with cabal2nix and just have this work?
19:06:39 <gentauro> how would you write an infinite sequence of `a .. z` string. Example: starts with `a` and when `z` is reached, it jumps to `aa` and when `zz` is reached it starts with `aaa` and so ...
19:06:51 <gentauro> a list comprehension perhaps?
19:08:13 <dyl> gentauro: such strings are just 1..infinity in base 26 with digits a-z, no?
19:08:33 <gentauro> dyl: yeah
19:08:49 <dyl> Probably not the best way to do it, but it’s one way :p
19:08:56 <iqubic> LOL.
19:09:17 * hackage servant-waargonaut 0.5.0.1 - Servant Integration for Waargonaut JSON Package  https://hackage.haskell.org/package/servant-waargonaut-0.5.0.1 (schalmers)
19:12:05 <Solonarv> [ cs | n <- [1..], cs <- replicateM n ['a'..'z'] ] -- here's one way
19:12:55 <jackdk> iqubic: something like https://pastebin.com/dXa5tbRi , maybe? try asking #nixos, I won't have much more time today
19:12:59 <Solonarv> [1..] >>= (`replicateM` ['a'..'z']) -- the short incomprehensible version
19:14:01 <gentauro> Solonarv: beautiful !!!
19:14:37 <Solonarv> @. pl undo [ cs | n <- [1..], cs <- replicateM n ['a'..'z'] ]
19:14:37 <lambdabot> flip replicateM ['a'..'z'] =<< [1..]
19:14:49 <Solonarv> heh ;)
19:15:17 * hackage servant-avro 0.1.0.0 - Avro content type for Servant  https://hackage.haskell.org/package/servant-avro-0.1.0.0 (jessekempf)
19:15:51 <gentauro> Solonarv: `pl` stand for `point free right?`
19:16:07 <Solonarv> % take 5 . drop 26 $ flip replicateM ['a'..'z'] =<< [1..]
19:16:07 <yahb> Solonarv: ["aa","ab","ac","ad","ae"]
19:16:10 <Solonarv> gentauro: correct
19:16:27 <Solonarv> hey, it's even the right order! I wasn't entirely sure if that would happen
19:16:35 <gentauro> xD
19:16:38 <gentauro> `magic`
19:16:49 <Solonarv> (well, "pointless", not "pointfree")
19:16:49 <Clint> the "l" does not stand for "free"
19:17:03 <Solonarv> a much better name xD
19:17:53 <gentauro> but it's to rewrite `pointfree` expr amirite?
19:17:58 <Solonarv> also, @undo desugars do blocks and list comprehensions
19:18:12 <gentauro> like the `pl` lambdabot `thingy`?
19:18:27 <Solonarv> yes, @pl rewrites an expression into point-free style
19:18:42 <Solonarv> there is also @unpl which reverses the process
19:18:45 <gentauro> and `@pl undo` well ...
19:18:59 <gentauro> oh, so it's `@unpl`
19:19:01 <gentauro> got it
19:19:15 <Solonarv> it's @. pl undo -- note the dot! that's a plugin for composing other plugins ;)
19:19:43 <Solonarv> @help .
19:19:43 <lambdabot> . <cmd1> <cmd2> [args].
19:19:44 <lambdabot> . [or compose] is the composition of two plugins
19:19:44 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
19:20:31 <jackdk> @. help help
19:20:31 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:20:44 <gentauro> btw, why is this expr not suggested? `[1..] >>= flip replicateM ['a'..'z']`
19:21:01 <Solonarv> dunno. the ways of @pl are strange and mysterious.
19:21:07 <gentauro> instead of `flip replicateM ['a'..'z'] =<< [1..]`
19:21:20 <gentauro> `magic`
19:21:22 <gentauro> xD
19:31:38 <iqubic> What exactly does the DataKinds pragma do/
19:31:44 <iqubic> s./.?
19:31:53 <gentauro> it's kind to data? :P
19:32:04 <iqubic> Not really what I wanted.
19:32:26 <Solonarv> it "lifts" 'data' declarations to the type level
19:33:03 <Solonarv> normally, 'data Bool = True | False' creates a type 'Bool' and two values 'True :: Bool' and 'False :: Bool'
19:33:47 <Solonarv> with DataKinds, it also creates a kind 'Bool' and two types 'True and 'False (which have kind Bool)
19:33:47 <iqubic> Right. I get that.
19:34:02 <iqubic> why do we care about having corresponding Kinds?
19:34:49 <Solonarv> because it lets us carry around data at the type level in a "kind-safe" way
19:34:58 <Solonarv> let's say you want to have type-level natural numbers
19:35:19 <iqubic> Sure. That is the example the GHC user's guide gives.
19:35:20 <Solonarv> without DataKinds you need to do:
19:35:20 <Solonarv> data Zero
19:35:20 <Solonarv> data Succ n
19:35:49 <Solonarv> but then 'Succ Bool' is valid, even though that's nonsense!
19:35:56 <iqubic> Sure. But then you don''t have a way to specify that `n' must be `n::nat'
19:36:13 <Solonarv> Exactly 
19:36:22 <iqubic> So how do you make that type-safe and sensible?
19:36:42 <Solonarv> you use DataKinds and write 'data Nat = Zero | Succ Nat'
19:36:55 <iqubic> And then what happens there?
19:37:33 <iqubic> I mean, why can't you do that without DataKinds? That looks like a bog standard data declaration.
19:37:41 <Solonarv> now you've created a new kind Nat, with the following inhabitants: 'Zero, 'Succ 'Zero, 'Succ ('Succ 'Zero), ...
19:37:52 <Solonarv> indeed it *is* a bog standard data declaration
19:38:10 <jackdk> because you also get the type 'Zero of kind Nat and the type 'Succ of kind Nat -> Nat
19:38:26 <iqubic> but what benefits does that give you over Nat just being a data type?
19:38:27 <Solonarv> DataKinds makes it so bog standard data declarations also create the corresponding kind
19:38:41 <iqubic> But why would you ever want the corresponding kind?
19:38:52 <iqubic> I'm not sure I see what benifit that gives us.
19:38:55 <Solonarv> so that you can have a 'Nat' in a type signature
19:39:10 <Solonarv> e.g. 'data Vector (len :: Nat) a = ...'
19:39:28 <iqubic> You can't do that with a standard data type declaration?
19:39:37 <Solonarv> you can't do that if there is no 'Nat' kind!
19:40:09 <iqubic> Is there a kind for Bools?
19:40:43 <iqubic> Because I can do `flag :: Bool' and it works just fine.
19:42:32 <iqubic> So I'm reading jle's introduction to singletons and getting a bit perplexed by the use of DataKinds.
19:42:44 <iqubic> https://blog.jle.im/entry/introduction-to-singletons-1.html
19:42:46 <Solonarv> yes, that's because you can think of DataKinds as being always on "internally"
19:43:16 <iqubic> He starts by introducing a simple API for a type-safe door like such: http://dpaste.com/0KE7VAF
19:43:42 <iqubic> I'm not sure why DataKinds would be needed to make that snippet compile.
19:44:30 <iqubic> Like I get that he's creating a phantom type, and I understand how and why that works. I just don't understand why DataKinds are needed.
19:44:37 <Solonarv> in 'data Door (s :: DoorState) = ...', DoorState is used as a kind; without DataKinds, that kind doesn't exist
19:44:58 <iqubic> How can you tell that DoorState is being used as a kind?
19:45:19 <iqubic> In fact, what are the ways that you can create new kinds in Haskell?
19:45:38 <jackdk> because you're applying a kind signature to a type variable
19:46:12 <iqubic> Couldn't you also write, (s :: *) instead?
19:46:34 <jackdk> no, because * is the kind of types that have values
19:46:34 <iqubic> I know that breaks the type safety that is being created here, but would that work?
19:46:47 <iqubic> Huh?
19:47:00 <iqubic> Doesn't DoorState have values already?
19:47:07 <jackdk> 'Open has kind DoorState, not *
19:47:25 <Solonarv> well, you could write (s :: *), but then (Door 'Closed) would be a kind error
19:47:27 <jackdk> so if you give that variable the kind signature * you will get a kind error if you try to pass in 'Open
19:47:35 <jackdk> what Solonarv said
19:48:02 <Solonarv> the kind of 'Opened is DoorState
19:48:02 <Solonarv> the kind of DoorState is Type (also known as *)
19:48:31 <iqubic> So a kind can have a kind?
19:49:33 <iqubic> Because it seems like the hierarchy is 'Opened -> DoorState -> Type where "a -> b" means a has kind b.
19:49:54 <iqubic> but perhaps I am thinking about this incorrectly.
19:50:48 <Solonarv> no, that's correct
19:50:56 <Solonarv> and the symbol you're looking for is ::, not ->
19:51:02 <iqubic> Right.
19:51:23 <iqubic> so 'Opened :: DoorState :: Type
19:51:27 <Solonarv> indeed.
19:51:50 <iqubic> I'm just so used to seeing kinds written as: Maybe :: * -> *
19:52:06 <iqubic> I'm not sure what a named Kind means.
19:52:44 <iqubic> What's the difference between DoorState and *?
19:56:11 <Solonarv> I don't know, what's the difference between 5 and Int?
19:57:05 <iqubic> Is it really like that?
20:00:50 <monochrom> And the most confusing part about DataKinds is suddenly you have two different things both called DoorState.
20:02:21 <iqubic> If I write something like "Data Foo (a::*) = MkFoo Int" then what would a valid type be?
20:02:31 <iqubic> Like what does that even mean?
20:03:40 <Solonarv> it means the same thing as 'data Foo a = MkFoo Int'
20:04:17 <iqubic> I see. So why are DataKinds helpful? Do they just give us a way to restrict the Kind of a?
20:05:40 <[Leary]> % data Foo a = MkFoo Int
20:05:40 <yahb> [Leary]: 
20:05:44 <[Leary]> % :k Foo
20:05:44 <yahb> [Leary]: Foo :: k -> *
20:06:14 <iqubic> Huh? What is k and what is * and how do they differ?
20:07:01 <[Leary]> Looks like it doesn't infer kind Type (nor should it, really). Might depend on whether PolyKinds is enabled.
20:07:23 <iqubic> IDK what that is.
20:07:27 <[Leary]> k is a kind variable
20:07:39 <[Leary]> % MkFoo 3 :: Foo Maybe
20:07:40 <yahb> [Leary]: ; <interactive>:213:1: error:; * No instance for (Show (Foo Maybe)) arising from a use of `print'; * In a stmt of an interactive GHCi command: print it
20:07:52 <[Leary]> Well, no Show instance, but that's valid.
20:07:57 <iqubic> Right.
20:08:17 <iqubic> So what exactly is the difference between a type and a kind?
20:08:17 <MarcelineVQ> yahb does have polykinds on
20:08:17 * hackage oset 0.2.0.0 - An insertion-order-preserving set  https://hackage.haskell.org/package/oset-0.2.0.0 (rcook)
20:08:21 <Solonarv> DataKinds give us a way to define new kinds, with the inhabitants we choose
20:08:22 <iqubic> Ah.
20:08:34 <Solonarv> iqubic: actually, there sort of isn't one anymore
20:08:58 <iqubic> and * is just the kind with all types as inhabitants?
20:09:17 * hackage avro 0.4.2.0 - Avro serialization support for Haskell  https://hackage.haskell.org/package/avro-0.4.2.0 (alexeyraga)
20:09:26 <Solonarv> no; after all, Maybe is a type too, and its kind certainly isn't Type!
20:09:41 <Solonarv> Type is the kind of *inhabited* types: types which have values
20:09:58 <iqubic> % :k Maybe Int
20:09:58 <yahb> iqubic: Maybe Int :: *
20:10:01 <iqubic> I see.
20:10:11 <Solonarv> if 't :: Type', then 'x :: t' is valid
20:10:26 <iqubic> % :k Monad
20:10:26 <yahb> iqubic: Monad :: (* -> *) -> Constraint
20:10:30 <iqubic> I see.
20:11:09 <iqubic> And I know what a Constraint is already. It's a special type of Kind for Types that go on the LHS of =>
20:11:52 <Solonarv> indeed
20:12:24 <iqubic> So the inhabitants of 'DoorState are the things with Type DoorState?
20:13:15 <iqubic> That is things with the Kind 'DoorState MUST 100% of the time have Type DoorState, right?
20:13:56 <Solonarv> I don't like that uppercase Type you've got there
20:14:01 <Solonarv> what do you think it means?
20:14:27 <iqubic> Yeah that was wrong.
20:15:50 <iqubic> If something has kind 'DoorState, then can we say anything definitive about the type? type as is what ":t" tells us. Not the uppercase Type which is the same Kind as *.
20:16:59 <iqubic> In other words: What are the inhabitants of the kind 'DoorState?
20:18:26 <Solonarv> if something has kind 'DoorState, then it's not a term, so it doesn't have a type
20:18:59 <Solonarv> terms have types, types have kinds
20:19:16 <Solonarv> 'DoorState has no inhabitants; you can see this because its kind isn't Type
20:20:01 <iqubic> Ah. That's the thing I wasn't getting. I thought that ALL kinds had inhabitants.
20:20:24 <Solonarv> heh ;)
20:21:31 <iqubic> so what do we mean when we say s has kind DoorState, like such: "s::DoorState"?
20:22:32 <Solonarv> we mean "s is one of 'Opened, 'Closed, 'Locked"
20:22:44 <Solonarv> actually, wait
20:22:57 <Solonarv> we don't mean anything, because 'DoorState is nonsense
20:23:15 <Solonarv> I should've noticed that sooner
20:23:17 <iqubic> It is?
20:23:41 <iqubic> How so?
20:23:43 <Solonarv> yes; the tick is only needed on the datatype's constructors
20:23:59 <iqubic> Oh. I see.
20:51:17 * hackage units 2.4.1.1 - A domain-specific type system for dimensional analysis  https://hackage.haskell.org/package/units-2.4.1.1 (RichardEisenberg)
20:52:17 * hackage oset 0.3.0.0 - An insertion-order-preserving set  https://hackage.haskell.org/package/oset-0.3.0.0 (rcook)
21:06:11 <iqubic> % :t (->)
21:06:11 <yahb> iqubic: ; <interactive>:1:2: error: parse error on input `->'
21:06:20 <iqubic> % :k (->)
21:06:20 <yahb> iqubic: (->) :: * -> * -> *
21:06:29 <iqubic> % :k (=>)
21:06:29 <yahb> iqubic: ; <interactive>:1:2: error: parse error on input `=>'
21:06:40 <iqubic> % :t (=>)
21:06:40 <yahb> iqubic: ; <interactive>:1:2: error: parse error on input `=>'
21:06:45 <iqubic> Huh???
21:25:11 <slack1256> If I have a datatype `Foo Int String`, is there a combinator (maybe on lens) that returns a `(Int, String)`?
21:25:24 <iqubic> Not that I know of.
21:25:35 <iqubic> :t curry
21:25:37 <lambdabot> ((a, b) -> c) -> a -> b -> c
21:25:52 <iqubic> Actually don't use that.
21:26:12 <slack1256> Nope.
21:26:25 <iqubic> yeah, I said that wouldn't work.
21:26:44 <iqubic> I'm not sure such a combinator exists. Sorry.
21:27:03 <iqubic> You have to write your own.
21:27:23 <iqubic> toPair (Foo i s) = (i, s)
21:27:34 <iqubic> fromPair (i, s) = Foo i s
21:28:32 <iqubic> that's the simplest I can see working.
21:28:52 <slack1256> Yeah, I thought maybe there was a general combinator on lens that could do the trick.
21:29:24 <iqubic> nope.
21:29:54 <iqubic> I mean, if there is, it would have to use Template Haskell
21:30:52 <slack1256> Maybe it could be derived using Generics + a type class.
21:50:57 <suzu> a combinator won't work
21:51:01 <suzu> you need a typeclass
21:52:39 <suzu> (if you wish for it to work on types isomorphic to Foo a b)
21:53:23 <suzu> you can do this with generics
22:02:09 <aplainzetakind> What's the most reasonable way to obtain naturals that start from 1?
22:04:21 <mjrosenb> [1..] ?
22:04:33 <aplainzetakind> Sorry, I meant as a type.
22:12:30 <mjrosenb> so, has anyone used hsx and knows of an up-to-date tutorial/examples/specification?
22:12:46 <mjrosenb> I'm trying the example from happstack, and it is unhappy.
22:30:39 <alp> aplainzetakind, https://arow.info/blog/posts/2015-07-10-servant-intro.html might help too
22:34:47 * hackage vector-builder 0.3.7.1 - Vector builder  https://hackage.haskell.org/package/vector-builder-0.3.7.1 (NikitaVolkov)
22:43:17 * hackage sc2-proto 0.1.0.0 - A protocol buffer model for the Starcraft II bot API  https://hackage.haskell.org/package/sc2-proto-0.1.0.0 (spacekitteh)
22:44:18 * hackage sc2-lowlevel 0.1.0.0, sc2-support 0.1.0.0 (spacekitteh): https://qbin.io/match-don-xj7f
22:45:47 * hackage sc2hs 0.1.0.0 - An interface to the Starcraft II bot API  https://hackage.haskell.org/package/sc2hs-0.1.0.0 (spacekitteh)
22:46:42 <suzu> sometimes i like to `r <- return foo` instead of `let r = foo` in a `do` block
22:46:46 <suzu> am i the only one who does this
22:48:19 <dminuoso> suzu: Why not just use foo? ..
22:48:34 <dminuoso> suzu: At any rate, I tend to prefer where bindings. :)
22:48:44 <c_wraith> same reason you'd name any expression
22:49:47 * hackage basement 0.0.10 - Foundation scrap box of array & string  https://hackage.haskell.org/package/basement-0.0.10 (VincentHanquez)
22:49:59 <suzu> because i wish to reuse the value
22:50:06 <suzu> or pattern match on it or whatever
22:50:20 <suzu> compute it and use it later
22:50:22 <suzu> etc
22:50:47 * hackage foundation 0.0.23 - Alternative prelude with batteries and no dependencies  https://hackage.haskell.org/package/foundation-0.0.23 (VincentHanquez)
22:51:17 <c_wraith> I have use (Pat x) <- return (foo bar baz)
22:51:34 <c_wraith> when I want to take advantage of fail desugaring if the pattern doesn't match
22:51:47 * hackage cairo-core 1.16.5 - Cairo Haskell binding (core functions)  https://hackage.haskell.org/package/cairo-core-1.16.5 (magicloud)
23:38:17 * hackage amazonka-core 1.6.1 - Core data types and functionality for Amazonka libraries.  https://hackage.haskell.org/package/amazonka-core-1.6.1 (BrendanHay)
23:40:17 * hackage amazonka 1.6.1 - Comprehensive Amazon Web Services SDK.  https://hackage.haskell.org/package/amazonka-1.6.1 (BrendanHay)
23:41:17 * hackage amazonka-route53-domains 1.6.1, amazonka-sagemaker-runtime 1.6.1, amazonka-ecs 1.6.1, amazonka-serverlessrepo 1.6.1, amazonka-test 1.6.1 (BrendanHay)
23:42:17 * hackage amazonka-kinesis-video-archived-media 1.6.1, amazonka-cloudsearch 1.6.1, amazonka-storagegateway 1.6.1, amazonka-mediastore 1.6.1, amazonka-elastictranscoder 1.6.1, amazonka-lex-runtime 1.6.1 (BrendanHay)
23:43:17 * hackage amazonka-waf-regional 1.6.1, amazonka-inspector 1.6.1, amazonka-rds 1.6.1, amazonka-dynamodb-dax 1.6.1, amazonka-iot 1.6.1, amazonka-ses 1.6.1 (BrendanHay)
23:44:18 * hackage amazonka-cloudwatch 1.6.1, amazonka-rekognition 1.6.1, amazonka-cognito-identity 1.6.1, amazonka-ssm 1.6.1, amazonka-ml 1.6.1, amazonka-organizations 1.6.1 (BrendanHay)
23:44:29 <Athas> I'm getting a bit tired of Travis.  Does anyone have experience running Haskell CI on CircleCI?
23:45:18 * hackage amazonka-dms 1.6.1, amazonka-dynamodb-streams 1.6.1, amazonka-ds 1.6.1, amazonka-guardduty 1.6.1, amazonka-certificatemanager 1.6.1, amazonka-cur 1.6.1 (BrendanHay)
23:46:18 * hackage amazonka-cloudsearch-domains 1.6.1, amazonka-workmail 1.6.1, amazonka-elasticbeanstalk 1.6.1, amazonka-apigateway 1.6.1, amazonka-datapipeline 1.6.1 (BrendanHay)
23:47:18 * hackage amazonka-cloudwatch-events 1.6.1, amazonka-sdb 1.6.1, amazonka-iot-analytics 1.6.1, amazonka-autoscaling-plans 1.6.1, amazonka-codedeploy 1.6.1, amazonka-cloudfront 1.6.1 (BrendanHay)
23:48:18 * hackage amazonka-cloudformation 1.6.1, amazonka-importexport 1.6.1, amazonka-batch 1.6.1, amazonka-greengrass 1.6.1, amazonka-dynamodb 1.6.1, amazonka-stepfunctions 1.6.1 (BrendanHay)
23:49:18 * hackage amazonka-polly 1.6.1, amazonka-opsworks-cm 1.6.1, amazonka-iot-jobs-dataplane 1.6.1, amazonka-kinesis-video-media 1.6.1, amazonka-mobile 1.6.1 (BrendanHay)
23:50:18 * hackage amazonka-cognito-sync 1.6.1, amazonka-kinesis-video 1.6.1, amazonka-shield 1.6.1, amazonka-sts 1.6.1, amazonka-efs 1.6.1, amazonka-athena 1.6.1 (BrendanHay)
23:51:17 * hackage amazonka-lex-models 1.6.1, amazonka-translate 1.6.1, amazonka-pinpoint 1.6.1, amazonka-kinesis-firehose 1.6.1, amazonka-route53-autonaming 1.6.1, amazonka-elasticsearch 1.6.1 (BrendanHay)
23:52:18 * hackage amazonka-codepipeline 1.6.1, amazonka-cloudwatch-logs 1.6.1, amazonka-kinesis-analytics 1.6.1, amazonka-secretsmanager 1.6.1, amazonka-pricing 1.6.1, amazonka-emr 1.6.1 (BrendanHay)
23:53:18 * hackage amazonka-redshift 1.6.1, amazonka-lambda 1.6.1, amazonka-cloud9 1.6.1, amazonka-codebuild 1.6.1, amazonka-config 1.6.1, amazonka-waf 1.6.1 (BrendanHay)
23:54:48 * hackage amazonka-ec2 1.6.1, amazonka-budgets 1.6.1, amazonka-cognito-idp 1.6.1, amazonka-kms 1.6.1, amazonka-elbv2 1.6.1 (BrendanHay)
23:55:05 <sicklorkin> need to solve an argument.. `gets $ view $ foo.bar` or `_bar <$> gets _foo`
23:55:48 * hackage amazonka-workdocs 1.6.1, amazonka-sagemaker 1.6.1, amazonka-workspaces 1.6.1, amazonka-glacier 1.6.1, amazonka-mediastore-dataplane 1.6.1, amazonka-route53 1.6.1 (BrendanHay)
23:56:48 * hackage amazonka-iot-dataplane 1.6.1, amazonka-sns 1.6.1, amazonka-cloudtrail 1.6.1, amazonka-opsworks 1.6.1, amazonka-connect 1.6.1, amazonka-lightsail 1.6.1 (BrendanHay)
23:57:48 * hackage amazonka-glue 1.6.1, amazonka-codecommit 1.6.1, amazonka-gamelift 1.6.1, amazonka-elb 1.6.1, amazonka-clouddirectory 1.6.1, amazonka-support 1.6.1 (BrendanHay)
23:58:03 <sicklorkin> and `Map.lookup baz . _bar <$> gets _foo` vs `gets $ view $ foo.bar >>= Map.lookup baz`
23:58:48 * hackage amazonka-alexa-business 1.6.1, amazonka-appsync 1.6.1, amazonka-swf 1.6.1, amazonka-application-autoscaling 1.6.1, amazonka-appstream 1.6.1, amazonka-autoscaling 1.6.1 (BrendanHay)
23:59:47 * hackage amazonka-mechanicalturk 1.6.1, amazonka-resourcegroups 1.6.1, amazonka-cloudhsmv2 1.6.1, amazonka-snowball 1.6.1, amazonka-fms 1.6.1, amazonka-comprehend 1.6.1 (BrendanHay)
