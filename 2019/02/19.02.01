00:04:29 * hackage servant-lucid 0.9 - Servant support for lucid  https://hackage.haskell.org/package/servant-lucid-0.9 (phadej)
00:08:57 <hsn> i do not understand haskell concept of variables. they are evaluated at most once?
00:09:52 <hsn> or immutable variable is just alias for expression
00:10:38 <[exa]> yeah, the 'variables' are not variable
00:11:35 <[exa]> they are the variables in the mathematical sense, representing a constant object at the scope delimited by binding
00:13:09 <hsn> what if you have variable like: val a = random(5) it will keep always the same value?
00:14:56 <phadej> if it helps, "variables are assigned (bound) only once"
00:17:07 <phadej> as [exa] said there are variables as in math; f(x) = x * x -- x is a variable, a placeholder for some value which is determined later
00:21:32 <[exa]> hsn: it will, from the time of binding it can't change
00:22:10 <[exa]> hsn: you can only do stuff like do {a<-something ; a<-somethingElse } which looks like changing a variable, but in fact it just shadows the original variable with a new one
00:25:02 <hsn> easiest way is to compile using ghc --make ?
00:32:00 * hackage prolog 0.3 - A Prolog interpreter written in Haskell.  https://hackage.haskell.org/package/prolog-0.3 (MarcelFourne)
00:45:20 <dminuoso> @quote /bin/ls
00:45:20 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
00:45:31 <dminuoso> hsn: ^- This might be a good intuition. =)
00:46:02 <dminuoso> You canextend the notion to some `randomInt :: IO Int` 
00:53:42 <Digit> hi.  how do i get ghci to show numbers full, and, why did it do to in this second example unlike happens in the first of these two?  Prelude> 3840*3840*1000*3.14*2500 = 1.1575296e14, Prelude> 4693670257711*2666 = 12513324907057526
00:53:42 <Digit>  
00:54:14 <Digit> s/why did it do to/why did it do so/
00:54:20 <Ariakenom> Digit: those are of different types. Double, Integer
00:54:27 <Ariakenom> add type annotations
00:54:35 <Ariakenom> you can do
00:54:36 <[exa]> Digit: the first defaulted to approximate; you want to specify a precise type if you need precise computation
00:54:38 <Ariakenom> default ()
00:54:47 <Ariakenom> to get a type error when it's ambiguous
00:55:12 <Ariakenom> % 3840*3840*1000*3.14*2500
00:55:13 <yahb> Ariakenom: 1.1575296e14
00:55:23 <Ariakenom> % 4693670257711*2666
00:55:23 <yahb> Ariakenom: 12513324907057526
00:55:26 <Ariakenom> % default ()
00:55:26 <yahb> Ariakenom: 
00:55:30 <Ariakenom> % 3840*3840*1000*3.14*2500
00:55:30 <yahb> Ariakenom: ; <interactive>:25:1: error:; * Ambiguous type variable `a0' arising from a use of `print'; prevents the constraint `(Show a0)' from being solved.; Probable fix: use a type annotation to specify what `a0' should be.; These potential instances exist:; instance Show a => Show (ZipList a) -- Defined in `Control.Applicative'; instance Show NestedAtomically -- Defined in 
00:55:54 <Ariakenom> A long error message. But it means that the type is ambiguous.
00:56:00 <Ariakenom> :t 3840*3840*1000*3.14*2500
00:56:02 <lambdabot> Fractional a => a
00:56:30 <Ariakenom> I said ambiguous but I should have said polymorphic
01:02:00 * hackage hasbolt-extras 0.0.0.16 - Extras for hasbolt library  https://hackage.haskell.org/package/hasbolt-extras-0.0.0.16 (ozzzzz)
01:03:12 <Digit> i see.  thanks.   so, with an inclusion of a fraction in the calculation, is there a way to keep the answer displayed in full as in the 2nd example?
01:05:39 <[Leary]> % 3840*3840*1000*3.14*2500 :: Rational
01:05:40 <yahb> [Leary]: 115752960000000 % 1
02:08:03 <kuribas> is there a name for something that supports set operations (union, difference, intersection), or is that just a set?
02:09:30 * hackage servant-blaze 0.9 - Blaze-html support for servant  https://hackage.haskell.org/package/servant-blaze-0.9 (phadej)
02:16:39 <mniip> kuribas, predicates
02:16:56 <kuribas> mniip: how so?
02:17:26 <mniip> :t liftA2 (&&)
02:17:27 <lambdabot> Applicative f => f Bool -> f Bool -> f Bool
02:17:31 <mniip> :t liftA2 (||)
02:17:32 <lambdabot> Applicative f => f Bool -> f Bool -> f Bool
02:17:53 <mniip> :t liftA2 (>)
02:17:55 <lambdabot> (Ord a, Applicative f) => f a -> f a -> f Bool
02:18:17 <mniip> where f is of course Reader
02:18:21 <mniip> and in the last a=Bool
02:20:12 <Taneb> mniip: that's ane example, not a name for the whole class
02:22:49 <Taneb> Maybe "boolean algebra"?
02:23:08 <mniip> I thought preidcates are universally recognized as presheaves onto bool idk
02:30:42 <phadej> semiring or lattice
02:31:14 <phadej> boolean algebra if you need a complement
02:33:06 <Taneb> phadej: kuribas mentioned difference which I think means you need complement
02:33:18 <Taneb> Although maybe not?
02:33:53 <kuribas> Taneb: as in union of the complement?
02:34:45 <kuribas> but difference may be more efficient
02:35:21 <kuribas> for example the difference between two lists is easier than the union of a list with the complement of another list (which may be infinite).
02:36:02 <kuribas> that's why I use difference instead of complement.
02:36:29 <kuribas> or is complement easier algebraically?
02:38:45 <ddk> hi all
02:39:23 <ddk> could someone help me with acid-state library's rollbackTo function
02:43:14 <ddk> is there someone with fair knowledge of the library acid-state
02:55:05 <asheshambasta> So, I'm back at the drawing board when it comes to the DB layer of my project. It is a reasonably sized web-app that has to deal with around 40 tables, ideally on postgres. The 2 options I've come across are -simple and opaleye, both seem attractive and very different to me. 
02:56:12 <asheshambasta> considering -simple has a huge advantage because of its simplicity, but having used the SQL escape hatch in the past (writing raw SQL), I'm aware of the problems that occur when the DB schema and your types do not match. 
02:57:14 <asheshambasta> I've tried to use Squeal for this project, which is a nice SQL embedding at the type-level, but that has serious limitations since GHC refuses to compile a decently sized module using Squeal without blowing up my RAM 
02:57:37 <asheshambasta> so, in short: advice needed. :-) 
02:58:38 <ddk> is there someone with fair knowledge of the library acid-state
02:59:05 <srhb> ddk: You are more likely to get a response if you pose your actual question :)
03:00:25 <ddk> srhb: I'm not getting the behavior of `rollbackTo` function defined in Log.hs module of the acid-state library
03:03:06 <srhb> ddk: Things the channel might want to know: What did you do, what did you expect would happen, what happened instead?
03:10:47 <ddk> srhb: I am implementing tests for the library, I used this function by creating a state and then applying updates, now rollbacked to the starting point and then match both the states, I thought it should have matched but they didn't, thats why I think I'm missing something as there is almost no documentation
03:11:47 <Taneb> ddk: bear in mind it's possible that acid-state is just broken
03:12:12 <ddk> there are more things which I can explain once I get some one who have fair knowledge of the library acid state
03:12:27 <Taneb> And have you tried emailing the developers?
03:12:43 <ddk> Taneb: I am writing the tests to expose the same
03:13:08 <ddk> Taneb: no I have not contacted them yet, I thought I would find someone here
03:16:59 <hsn> variables are lazily evaluated?
03:17:59 * hackage structured-cli 2.5.0.3 - Application library for building interactive console CLIs  https://hackage.haskell.org/package/structured-cli-2.5.0.3 (erick)
03:20:38 <kuribas> asheshambasta: I don't think there is no interest in getting better errors in Aeson, it's more a question of someone finding the time to do it well, and in a backwards compatible way.
03:22:02 <kuribas> asheshambasta: about the DB, my impression is that they are either very simple, of very softisticated.
03:22:12 <kuribas> asheshambasta: there isn't anything in between.
03:22:30 <kuribas> asheshambasta: there is already a PR with Validation.
03:22:42 <kuribas> asheshambasta: but not with JSON errors AFAIK
03:22:48 <asheshambasta> well, my point wasn't if the interest exists or not, there is indeed some interest, and I am in the interested parties. My point was that the choice of String as the reasonable type to represent all errors. That falls short even for the most trivial of use cases when it comes to JSON validation. 
03:24:11 <kuribas> asheshambasta: probably not, but historical reasons...
03:24:32 <asheshambasta> In any even simple use cases of JSON validation, Aeson's choice of String's has serious limitations. So while I am thankful for people contributing to these libraries (I'd love to do the same, and will do the same), I also want to emphasise that the choice was far from ideal. 
03:27:38 <kuribas> in hindsight...
03:27:39 <asheshambasta> The problems arise, because of these design decisions, and because theses libraries are used elsewhere. For example, my assumption is that Servant also uses Aeson under the hood to validate request payloads, so you're going to end up with these errors even at your routing level. That is, unless, you replace it with something else (something that requires time-investment), or just resort to validating as `Value` at Servant 
03:28:36 <asheshambasta> http://hackage.haskell.org/package/servant-0.15/docs/Servant-API-ContentTypes.html#t:JSON 
03:28:59 <kuribas> asheshambasta: make your own JSON type with better errors?
03:29:17 <asheshambasta> I did, but that is not my point. 
03:29:44 <kuribas> asheshambasta: so JSON parser in all other language return JSON errors?
03:30:32 <asheshambasta> kuribas: I'm not aware of all other languages, but the ones used most often in Scala have reasonably good support for: 1. validation & error accumulation; 2. custom error types. 
03:31:41 <asheshambasta> Probably not as lawful or elegant as in Haskell, but yeah. And in my 8-9 years writing web-API's, custom error messages are pretty much the standard for any usable/elegant REST API you'd like to design.
03:32:54 <asheshambasta> Also, my point is not: "it exists in other languages", my point is: it ought to be improved
03:33:21 <kuribas> asheshambasta: sure
03:33:46 <kuribas> asheshambasta: then you can improve it, right?
03:34:06 <asheshambasta> I'll sure try to, yes.
03:34:08 <kuribas> asheshambasta: also if ghci blows up, send bug reports
03:35:12 <asheshambasta> kuribas: but in the end, I have to deliver this project on time, so I'd like to draw a balance between contributing back, and keeping my business afloat. 
03:35:47 <kuribas> asheshambasta: in that case, fork aeson and make your own changes?
03:36:12 <kuribas> asheshambasta: and worry about it getting into the original later?
03:36:51 <kuribas> you don't need to fork servant, as you can extend it.
03:36:59 <asheshambasta> kuribas: either you can fork something as large as Aeson and spend a month on making changes to it, or you can develop a layer on top of its primitives that do the job as you desire. And then contribute back when time permits. For me, currently, the choice is the latter. 
03:37:35 <kuribas> I don't think adding validation and JSON errors is a month work...
03:38:42 <kuribas> asheshambasta: I spoke with the maintainer and he was interested in such changes.
03:39:01 <asheshambasta> It is some work, and it will consume some time, neither of which I have. Writing a thin layer on Aeson for me took me a couple of hours. And it gave me valid pointers in the direction I'd like to go if I were to port this to Aeson. So, one thing at a time. 
03:39:22 <kuribas> ah, so you got it working?
03:39:59 <asheshambasta> Yes. I used ChronicleT and particularly Data.These, and it works as per my expectations
03:40:49 <asheshambasta> What I can promise is that I will definitely "share" my ideas, if they are worth anything. I don't know if my expertise in Haskell at this time permits contributing to something as complex as Aeson. 
03:41:37 <kuribas> Aeson isn't that complex, unless you could generics and TH.
03:55:38 <kuribas> count, not could
03:55:53 <kuribas> asheshambasta: most of it is just combinators
03:56:11 <kuribas> the lower level parsing is done by attoparsec
04:10:08 <kuribas> asheshambasta: don't underestimate your abilities...
04:20:58 <kuribas> asheshambasta: or be falsely modest
04:27:45 <asheshambasta> kuribas: well, looking into Aeson is on my mind and I will get to it whenever time permits, but I am just being mindful of my inexperience in Haskell. But I will try. 
04:34:15 <kuribas> asheshambasta: I'll have a look at it in the weekend.  I cannot justify it doring work hours.
04:34:50 <kuribas> asheshambasta: although they allowed me to make a model from some part in haskell :-)
04:34:55 <kuribas> and then port to clojure
04:38:25 <asheshambasta> kuribas: why port to clojure when your model is going to work? (and probably better)
04:38:55 <kuribas> asheshambasta: because it is only a small part of the whole rest API
04:39:25 <kuribas> asheshambasta: and the rest is already in clojure
04:39:57 <kuribas> we are generating queries based on a tree model, and I found it easier to do in haskell
04:58:02 <asheshambasta> kuribas: interesting, on my side, I'm still working on this rather large service written in Haskell. 
05:10:42 <kuribas> asheshambasta: I have a set algebra datatype, which I apply over queries.
05:11:27 <kuribas> asheshambasta: to do alias substitution, all I need is to derive traversable, and traverse over the sets
05:11:42 <kuribas> I doubt it's that easy in clojure
05:25:30 <hc> Is there a canonical way to filter things in a conduit?
05:26:18 <hc> specifically, I'm using persistent's selectSource function to select items from a database and would like to apply a custom filter afterwards, because persistent's filter system is not powerful enough to support SQL's "like" statement. (I know of esqueleto and would like to avoid using it if possible)
05:28:48 <kuribas> asheshambasta: What I miss in the tooling is the ability to immediately see the type of any function.
05:29:03 <kuribas> asheshambasta: or value
05:29:14 <kuribas> without going to ghci first
05:32:27 <kuribas> but there is probably some emacs extension that does this, and I just need to take time to integrate it.
05:41:57 <aplainzetakind> kuribas: There's a hack to have approximate functionality. If you have a macro to replace foo with (foo :: ()), when you save ghicd immediately gives you an expected type error.
05:42:51 <kuribas> aplainzetakind: sure, there are workarounds.  But still miss having information that is there more easily.
05:53:24 <hc> Data.Conduit.List.mapMaybe seems to be the function I need
06:05:45 <__monty__> aplainzetakind: Replacing foo with a hole `_foo` sounds like a safer hack.
06:20:14 <kuribas> aplainzetakind: I'll use you hack for now :)
06:23:36 <__monty__> kuribas: Not a fan of typed holes?
06:24:10 <kuribas> __monty__: yes, I am!  But then don't work when the buffer doesn't typecheck, and it's then when I need annotations the most.
06:26:26 <kuribas> __monty__: at least emacs could remember the types from the last time the buffer typechecked.
06:27:27 <__monty__> kuribas: Hmm, not sure what you mean? GHCid checks my holes perfectly well even when I have type errors.
06:28:42 <kuribas> true, but often it cannot find the right type anyway.
06:28:51 <kuribas> mostly because of a "rigid typevariable"
06:29:32 <__monty__> Why would it be able to determine the type when using `:: ()` but not for a hole?
06:29:53 <Philonous> What's up with the code search engines? hayoo.fh-wedel.de seems to be down and www.haskell.org/hoogle doesn't find anything in base or a large subset of hackage. 
06:30:07 <__monty__> Genuine question, that sounds counterintuitive. I haven't run into problems with holes but I'm not very advanced either.
06:30:08 <Philonous> Is there one that still works?
06:30:29 <__monty__> Philonous: Have you tried hoogle.haskell.org?
06:30:39 <lyxia> hoogle.haskell.org, or the same thing on stackage
06:30:44 <kuribas> __monty__: you mean like (traverse :: _) ?
06:31:00 <__monty__> kuribas: No, (_traverse).
06:31:14 <Philonous> Oh, that works. Thanks __monty__, lyxia 
06:31:15 <kuribas> __monty__: that doesn't give me the type of traverse...
06:31:57 <__monty__> kuribas: Guess I misunderstood what you wanted.
06:32:28 <__monty__> Still, I'd expect `:: _` to be at least as good as `:: ()` so what's going on there?
06:36:08 <kuribas> > (traverse :: _) 20 "20"
06:36:10 <lambdabot>  error:
06:36:10 <lambdabot>      • Found type wildcard ‘_’
06:36:11 <lambdabot>          standing for ‘(a -> f b1) -> [a] -> f [b1]’
06:46:14 <kuribas> > getFirst $ traverse First [1..]
06:46:16 <lambdabot>  error:
06:46:17 <lambdabot>      • No instance for (Enum (Maybe ())) arising from a use of ‘e_11’
06:46:17 <lambdabot>      • In the expression: e_11
06:48:54 <kuribas> > getFirst $ foldMap First [1..]
06:48:56 <lambdabot>  error:
06:48:56 <lambdabot>      • No instance for (Enum (Maybe ())) arising from a use of ‘e_11’
06:48:56 <lambdabot>      • In the expression: e_11
06:50:01 <Ariakenom> %kill
06:50:02 <yahb> Ariakenom: Done
06:51:40 <Ariakenom> :t First
06:51:41 <lambdabot> Maybe a -> First a
06:52:01 <Ariakenom> was that supposed to make sense kuribas?
06:52:01 <kuribas> > foldr1 const [1..]
06:52:04 <lambdabot>  1
06:52:13 <kuribas> Ariakenom: yes
06:52:36 <Ariakenom> > getFirst $ foldMap (First.Just) [1..]
06:52:39 <lambdabot>  error:
06:52:39 <lambdabot>      Not in scope: data constructor ‘First.Just’
06:52:39 <lambdabot>      No module named ‘First’ is imported.
06:52:43 <Ariakenom> > getFirst $ foldMap (First . Just) [1..]
06:52:45 <lambdabot>  Just 1
06:52:59 <kuribas> Ariakenom: what if I have a NonEmpty?
06:53:28 <Ariakenom> What are you looking for? head?
06:53:35 <kuribas> yes
06:53:39 <kuribas> but over a foldable
06:53:44 <kuribas> which isn't empty
06:54:51 <Ariakenom> :t head . toList
06:54:53 <lambdabot> error:
06:54:53 <lambdabot>     Ambiguous occurrence ‘toList’
06:54:53 <lambdabot>     It could refer to either ‘F.toList’,
06:54:58 <Ariakenom> :t head . F.toList
06:55:00 <lambdabot> Foldable t => t c -> c
06:55:25 <kuribas> :t foldr1 const
06:55:27 <lambdabot> Foldable t => t b -> b
06:55:39 <kuribas> Ariakenom: I was expecting I could use First...
06:56:17 <Ariakenom> > getFirst $ foldMap (First . Just) [1..]
06:56:20 <lambdabot>  Just 1
06:56:34 <Ariakenom> > getFirst $ foldMap (First . Just) []
06:56:37 <lambdabot>  Nothing
06:57:51 <kuribas> Ariakenom: but it's nonempty, so never Nothing
06:58:04 <kuribas> I suppose I'll need liquid haskell to proof it :)
06:58:45 <Ariakenom> Saying from Foldable and from NonEmpty doesn't make sense. Foldable gives no such guarantee.
06:59:16 <kuribas> well foldr1 is basically for nonempty
07:00:17 <Taneb> :t firstOf folded
07:00:19 <lambdabot> Foldable f => f a -> Maybe a
07:00:36 <kuribas> that one is nice also
07:00:43 <Taneb> If you're into lens ;)
07:01:14 <kuribas> still would need fromJust though
07:02:55 <Taneb> :t firstOf folded ^?! _Just
07:02:57 <lambdabot> error:
07:02:57 <lambdabot>     • Couldn't match type ‘Maybe a’ with ‘[a0] -> Maybe a0’
07:02:57 <lambdabot>       Expected type: Getting (Endo a) ([a0] -> Maybe a0) a
07:03:00 <Taneb> :t firstOf folded ^?! id
07:03:02 <lambdabot> Foldable f => f a -> Maybe a
07:03:05 <Taneb> ??
07:03:15 <Taneb> Oh, I know what's up
07:04:42 <Taneb> :t head . toList
07:04:43 <lambdabot> error:
07:04:43 <lambdabot>     Ambiguous occurrence ‘toList’
07:04:43 <lambdabot>     It could refer to either ‘F.toList’,
07:04:46 <Taneb> :t head . F.toList
07:04:47 <lambdabot> Foldable t => t c -> c
07:08:30 * hackage buffon-machines 1.1.1.0 - Perfect simulation of discrete random variables  https://hackage.haskell.org/package/buffon-machines-1.1.1.0 (mbendkowski)
07:11:28 <kuribas> Taneb: but foldl1 const avoids the creation of a list
07:12:53 <Ariakenom> kuribas: of one list cell
07:13:06 <kuribas> Ariakenom: all bits help :)
07:13:23 <kuribas> maybe it gets fused away
07:13:48 <Ariakenom> yeah I have no idea
07:14:34 <Ariakenom> an instantly thrown away small allocation probably has a stupidly tiny time cost
07:15:39 <kuribas> ah toList uses build
07:17:03 <ziman> hello, I've got a (class Coerce a b where coerce : T a -> T b) in my DSL. I'd like to be able to say (coerce @targetType foo); is there a way to declare the ordering of implicits in the method different from the class?
07:17:17 <Ariakenom> maybe ... if we allocate 1GB/s and a cons cell take 20B then it costs 20ns
07:17:39 <Ariakenom> that calculation may or may not make sense
07:17:59 <kuribas> it gets fused away
07:18:27 <Ariakenom> you've checked?
07:18:36 <kuribas> head/build"    forall (g::forall b.(a->b->b)->b->b) . head (build g) = g (\x _ -> x) badHead
07:18:48 <Ariakenom> in collection time, there's allocating and writing too.
07:20:22 <Ariakenom> ziman: explicit foralls should work I would think
07:22:05 <ziman> Ariakenom: if I say (... where forall b a. coerce : T a -> T b), then GHC complains that the forall-bound names shadow the names bound in the instance head
07:22:08 <Ariakenom> coerce :: forall b a. T a -> T b -- not that I've ever used explicit forall
07:22:23 <Ariakenom> oh right
07:22:53 <ziman> but then (class forall b a. Coerce a b where ...) is just a parse error
07:23:37 <kuribas> Ariakenom: so it rewrites to foldr const badHead
07:25:55 <Ariakenom> coerce :: forall b' a'. (a ~ a', b ~ b') => ... -- an idea, I have no idea about the syntax even
07:26:20 <ziman> uh :)
07:27:00 <Ariakenom> I used new names a' b'. But said they're equal a ~ a'.
07:27:25 <ziman> yeah, i could even leave a' out
07:28:46 <Ariakenom> Oh, I got the syntax right, cool :p
07:29:10 <ziman> so it turns out that GHC puts the class params first, it seems, which is probably quite understandable
07:29:31 <ziman> i'll  go with (coerce @_ @targetType) for now, I guess
07:29:33 <ziman> thank you :)
07:42:05 <[Leary]> ziman: You can always just declare an alias outside of the typeclass: `coerce' :: forall b a. Coerce a b => a -> b; coerce' = coerce`
07:51:16 <gentauro> if you have a list of tuples `[(1,1), ...]` is it possible to apply a function to the second part without having to write a lambda?
07:51:59 <gentauro> % map ((+ 1) . snd) [ (1,1) ]
07:52:05 <yahb> gentauro: [2]
07:52:08 <gentauro> :(
07:52:48 <gentauro> % map (\(x,y) -> (x, y + 1) [ (1,1) ]
07:52:49 <yahb> gentauro: ; <interactive>:2:36: error: parse error (possibly incorrect indentation or mismatched brackets)
07:52:54 <gentauro> % map (\(x,y) -> (x, y + 1)) [ (1,1) ]
07:52:54 <yahb> gentauro: [(1,2)]
07:52:55 <Clint> % map (second (+1)) [(1,1),(2,2)]
07:52:55 <yahb> Clint: [(1,2),(2,3)]
07:53:07 <gentauro> Clint: thx 
07:53:13 <gentauro> I second that !!!
07:53:27 <gentauro> I guess if I want to do something to the first element, its `first` amirite?
07:53:40 <Ariakenom> :t first
07:53:41 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
07:54:32 <travv0> you can also use fmap
07:54:59 <gentauro> % :t second
07:55:00 <yahb> gentauro: Arrow a => a b c -> a (d, b) (d, c)
07:55:26 <gentauro> travv0: how would you use `fmap`?
07:56:02 <travv0> % map (fmap (+1)) [(1,1)]
07:56:02 <yahb> travv0: [(1,2)]
07:56:11 <dmj`> :t fmap.fmap.fmap.fmap
07:56:12 <lambdabot> (Functor f4, Functor f3, Functor f2, Functor f1) => (a -> b) -> f1 (f2 (f3 (f4 a))) -> f1 (f2 (f3 (f4 b)))
07:56:23 <dmj`> :t fmap fmap fmap
07:56:24 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
07:56:29 <dmj`> :t fmap . fmap
07:56:30 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
07:56:41 <dmj`> :t fmap `fmap` fmap
07:56:43 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
07:56:45 <travv0> % (fmap . fmap) (+1) [(1,1)]
07:56:45 <yahb> travv0: [(1,2)]
07:57:11 <gentauro> travv0: how does it know I want to apply `(+1)` to the second element :| 
07:57:35 <Ariakenom> Also Lens.
07:57:44 <travv0> the first is "part of the structure" of the typeclass or whatever the proper wording is
07:58:24 <travv0> so things that work on functors can only modify the second element
07:58:26 <gentauro> travv0: so you can only use that `trick` if you want to update the second element. What if I want to update the first element of the tuple. Can I use `fmap` as well?
07:58:34 <gentauro> travv0: fair enough
07:58:55 <[Leary]> (,) is a bifunctor, you can use first or bimap.
07:58:56 <gentauro> I think I will stay with `second` cos the naming actually makes the `code` readable ;)
08:00:07 <Ariakenom> % (_2 %~ (+1)) (1,2)
08:00:07 <yahb> Ariakenom: (1,3)
08:00:20 <gentauro> Ariakenom: the funk was that :|
08:01:17 <Ariakenom> % (0,(0,(0,0))) & _2 . _2 . _2 %~ (+1)
08:01:18 <yahb> Ariakenom: (0,(0,(0,1)))
08:01:52 <Ariakenom> Good sir! Have you ever missed . access in Haskell. Have everything you've ever wished for and more. With Lens!
08:03:00 <gentauro> That code is not readable
08:03:43 <Ariakenom> % view _2 ('a','b')
08:03:43 <yahb> Ariakenom: 'b'
08:04:59 <Ariakenom> I can see it being a bit much at first :). It's quite nice though.
08:05:56 <[Leary]> % fmap (unFlip . fmap (+1) . Flip) [(1,1)]
08:06:35 <[Leary]> Hmm, got past yahb somehow?
08:06:52 <travv0> good job, you broke it
08:06:54 <Ariakenom> it was a bit slow when I PMed earlier
08:07:16 <Ariakenom> % "hello?"
08:07:37 <Ariakenom> %kill
08:11:09 <Ariakenom> > [(1,2)] & each . _2 .~ 3
08:11:11 <lambdabot>  [(1,3)]
08:14:39 <Ariakenom> > [([[(1,7)]],3)] & each._1.each.each._2 .~ 2
08:14:41 <lambdabot>  [([[(1,2)]],3)]
08:21:11 <gentauro> "off topic" is this SPJ son? https://iohk.io/team/michael-peyton-jones
08:21:19 <gentauro> I mean the company and the surnames ...
08:21:44 <gentauro> or is PJ just common in the UK
08:21:46 <gentauro> ?
08:23:11 <Heffalump> gentauro: yes, it is his son
08:23:25 <gentauro> roger
08:38:35 <kuribas> it's a functional family :)
08:39:09 <kuribas> much better than a disfunctional family
09:07:22 <gentauro> I think I saw him talking about his daughter when he had the old sweater on again
09:08:03 <gentauro> and iirc he was saying something about two things he did well :D
09:22:52 * Digit starts wondering about some means of "learn haskell while you sleep", realising the prior lazy learning fantasy of "just swallow a pill and know haskell" will unlikely happen.   ~ considers just playing haskell video tutes at high speed before sleep to let the brain sort it before morning.
09:24:26 <__monty__> Digit: That'll never work. Your brain has no reason to sort it out before you request the information.
09:26:49 * Digit scratches head, not sure he's following __monty__'s meaning correctly, seemingly contrary to what a sleep expert said in interview on jre#1109, and wonders about the certainty of "never"
09:27:43 <geekosaur> sounded like a laziness joke to me
09:28:09 <__monty__> Digit: It was a lazy evaluation joke, it sounds like your brain is lazy, since you're looking for learn haskell quick schemes ; )
09:28:09 * ski . o O ( strictness analyzer <https://ro-che.info/ccc/11>)
09:28:10 <Digit> lazyness, yes.  whimsy, yes.  but do want to learn haskell.
09:28:27 <Digit> oh!  that was~  i c.  sorry.  sleepy.
09:29:12 <__monty__> Maybe you'll laugh in the morning.
09:29:16 <Digit> lol. yeah.
09:36:29 * hackage pandora 0.1.1 - A box of patterns and paradigms  https://hackage.haskell.org/package/pandora-0.1.1 (iokasimovmt)
09:38:00 * hackage postgresql-simple-typed 0.1.1 - Typed extension for PostgreSQL simple  https://hackage.haskell.org/package/postgresql-simple-typed-0.1.1 (tolysz)
09:44:00 * hackage postgresql-simple-typed 0.1.1.1 - Typed extension for PostgreSQL simple  https://hackage.haskell.org/package/postgresql-simple-typed-0.1.1.1 (tolysz)
09:52:16 <wroathe> How does QuickCheck perform as a test suite's size grows?
09:53:06 <wroathe> Like if I had a few hundred functions to test
09:53:45 <wroathe> Seems like it would be slow to test with 100s of randomized input values
09:54:00 * hackage typedquery 0.1.1.2 - Parser for SQL augmented with types  https://hackage.haskell.org/package/typedquery-0.1.1.2 (tolysz)
09:58:25 <wroathe> Well, that's not quite right. What I meant to say is that it seems like you'd spend a lot of time carefully calibrating just how many randomized values you test each function with to ensure that your test suite doesn't run dog slow
09:59:38 <Welkin> why would it be slow?
09:59:42 <Welkin> 100 is the default
09:59:45 <Welkin> and the functions are pure
09:59:50 <Welkin> they don't do any disk access
10:00:00 <Welkin> well, "pure"
10:00:06 <Welkin> I shouldn't throw that around so lightly
10:00:29 <Welkin> it also runs on multiple cores/threads
10:00:33 <wroathe> It depends on the time complexity of your routines
10:00:48 <Welkin> no it doesn't
10:00:51 <__monty__> Nothing stops you from selectively unit testing though.
10:00:51 <Welkin> what matters is cache
10:01:15 <__monty__> So the time saved writing unit tests is probably worth it.
10:01:18 <Welkin> unit testing is not very useful
10:01:18 <wroathe> So there's nothing inherently slow about QuickCheck I suppose. This is just a different approach to unit testing than I'm used to.
10:01:36 <Welkin> integration and property tests + a good type system is all you need
10:01:42 <Welkin> quickcheck is not unit tests
10:01:46 <Welkin> it's property tests
10:01:57 <wroathe> Yay for pedantry
10:02:05 <Welkin> it's not
10:02:08 <Welkin> they are different things
10:16:22 <iqubic> Properties and Units are different.
11:11:34 <orion> Hi. I'm attempting to get the haskell-vim neovim plugin working inside xfce-terminal. In this screenshot, the window on the left shows what I want. The window on the right shows what I have: https://i.imgur.com/3N32f26.png
11:11:49 <orion> Does anyone know what I could do to achieve this color scheme?
11:13:04 <Tuplanolla> I think `xfce4-terminal` doesn't support 24-bit colors, orion.
11:33:12 <orion> Ah, hmm.
11:38:39 <geekosaur> http://www.robmeerman.co.uk/_media/unix/256colors2.pl fwiw
11:39:21 <geekosaur> and xfce4-terminal supports 256 colors here. (do check what $TERM is set to, though; must be xterm-256color for apps to know about it)
11:39:45 <geekosaur> script from http://www.robmeerman.co.uk/unix/256colours#so_does_terminal_insert_name_here_do_256_colours
11:39:52 <geekosaur> which shows sample outputs
11:53:30 * hackage bv-little 1.0.0 - Efficient little-endian bit vector library  https://hackage.haskell.org/package/bv-little-1.0.0 (recursion_ninja)
12:00:18 <herden> @pl \x y -> f (g y) x
12:00:18 <lambdabot> flip (f . g)
12:04:55 <fragamus> hi I need help with these few lines of code: https://gist.github.com/69bb9a5816f952c98f456f719b03deb7.git
12:05:20 <fragamus> I am trying to export the constructor Schmore
12:06:04 <fragamus> Not in scope: type constructor or class ‘Schmore’
12:06:24 <Solonarv> that's clearly not your entire code, please update that gist or make a new one
12:06:32 <fragamus> ok
12:06:42 <lyxia> module Foo (Store(..)) where
12:06:45 <MarcelineVQ> the ex/import identifier of Schmore is Store(Schmore)
12:07:02 * Clint twitches.
12:07:03 <fragamus> ooohhhhhkaaaaaayyyyy
12:07:06 <MarcelineVQ> or .. as lyxia has shown to export all constructors
12:07:27 <fragamus> thank you that's what I needed
12:07:59 <Solonarv> you can mention the constructor by itself with 'pattern Schmore', too (need ExplicitNamespaces or PatternSynonyms extension)
12:20:16 <herden> @pl \x y -> x { f = y : f x}
12:20:16 <lambdabot> (line 1, column 11):
12:20:16 <lambdabot> unexpected '{'
12:20:17 <lambdabot> expecting variable, "(", operator or end of input
12:20:55 <Solonarv> herden: there's no point-free equivalent of record syntax
12:20:59 <Solonarv> (not built-in, anyway)
12:23:11 <herden> Solonarv: cheers
12:23:29 <Solonarv> you can do this with lenses, though:
12:24:13 <Solonarv> @pl \x y -> over _f (y:) x
12:24:13 <lambdabot> (line 1, column 14):
12:24:14 <lambdabot> unexpected '_'
12:24:14 <lambdabot> expecting variable, "(", operator or end of input
12:24:28 <Solonarv> @pl \x y -> over _f ((:) y) x
12:24:28 <lambdabot> (line 1, column 14):
12:24:29 <lambdabot> unexpected '_'
12:24:29 <lambdabot> expecting variable, "(", operator or end of input
12:24:36 <Solonarv> oh ffs
12:24:39 <herden> lol
12:24:51 <Solonarv> @pl \x y -> over f ((:) y) x
12:24:52 <lambdabot> flip (over f . (:))
12:24:55 <herden> wow
12:25:19 <Solonarv> the operator-y version:
12:25:38 <Solonarv> @pl \x y -> x & f %~ (y:)
12:25:38 <lambdabot> (line 1, column 16):
12:25:38 <lambdabot> unexpected "~"
12:25:38 <lambdabot> expecting white space or simple term
12:25:58 <Solonarv> well, apparently lambdabot can't parse it, but there you go
12:27:02 <herden> we're talking about the lens package? a bit new to haskell
12:27:22 <Solonarv> indeed
12:27:30 <herden> cheers that's amazing
12:27:52 <Solonarv> there are a few other lens packages too, but lens is the biggest one
12:29:46 <fragamus> Thank you Lyxia, MarcelineVQ, and Solonarv
12:41:06 <vaibhavsagar> where does Data.Text.IO.readFile handle encodings?
12:41:42 <merijn> vaibhavsagar: Implicitly, the same way all GHC's String functions do
12:41:57 <merijn> vaibhavsagar: If you wanna do things properly use readFile from bytestring and use Data.Text.Encoding to decode
12:42:53 <vaibhavsagar> thanks merijn
12:42:59 <vaibhavsagar> I had a quick look at the source but didn't see anything there
12:45:03 <Solonarv> FWIW hSetEncoding should let you pick an encoding, I think
12:45:09 <merijn> vaibhavsagar: You can chance the encoding setting in the RTS which Text will use, but that's not very robust since it's program wide
12:45:29 <geekosaur> since it's using a Handle, it's using GHC.IO.Encoding under the covers
12:46:18 <geekosaur> and what Solonarv said re encoding. but readFile doesn't expose that, so you'd have to use a a Handle-based action instead
12:47:27 <Athas> Out of curiosity, is there a guide or set of libraries for handling things like pathnames and argv correctly in the Unix sense (as byte sequences)?
12:48:34 <Solonarv> @hackage unix I would assume
12:48:35 <lambdabot> http://hackage.haskell.org/package/unix I would assume
12:50:08 <Athas> If I could, I'd flip a compiler switch that would make my program instantly barf on anything not UTF-8...
13:24:17 <kritzefitz_> When I have a constructor `data Foo = Foo (forall a => a)` that's universal quantification instead of existential quantification, right?
13:24:51 <kritzefitz> Err, I meant `forall a. a`
13:25:55 <Solonarv> indeed
13:26:46 <kritzefitz> When I enable PolyKinds GHC complains at me that it's an existential and I need to enable ExistentialQuantification to use it.
13:26:53 <kritzefitz> Without PolyKinds it compiles fine.
13:27:16 <Solonarv> Hm, interesting
13:27:31 <Solonarv> % data Foo = Foo (forall a. a)
13:27:31 <yahb> Solonarv: 
13:27:42 <Solonarv> % :t Foo 'a'
13:27:42 <yahb> Solonarv: ; <interactive>:1:5: error:; * Couldn't match expected type `a' with actual type `Char'; `a' is a rigid type variable bound by; a type expected by the context:; forall a. a; at <interactive>:1:1-7; * In the first argument of `Foo', namely 'a'; In the expression: Foo 'a'
13:27:58 <Solonarv> yup, still a universal
13:28:25 <Solonarv> *shrug* the naming is a bit messed up, since Haskell only has a universal quantifier ('forall')
13:28:47 <Solonarv> there are existentials of course, but they're encoded as universals
13:29:54 <dmwit> kritzefitz: Could not reproduce
13:30:46 <dmwit> kritzefitz: If I include your line plus the two extensions RankNTypes and PolyKinds in a file, ghci accepts it just fine here.
13:30:59 <dmwit> kritzefitz: Are you sure you didn't write `data Foo = forall a. Foo a`?
13:31:10 <kritzefitz> Pretty sure, yes.
13:31:18 <dmwit> Well, show us an MCVE, then.
13:31:27 <dmwit> Maybe: what version of ghc are you using?
13:31:47 <kritzefitz> 8.6.3
13:31:54 <kritzefitz> dmwit: I will try to produce a more minimal example. I have boatloads of extensions enabled that might interfere with this.
13:32:26 <dminuoso> kritzefitz: Existential quantification would be if we had something like `exists t. ...`
13:32:43 <kritzefitz> Interestingly just adding PolyKinds without changing anything else makes my code not compile anymore.
13:34:14 <dmwit> Are you sure it's complaining about `Foo` and not some other part of the file?
13:36:26 <kritzefitz> It starts complaining about other things and I'm not sure if they're related to `Foo`.
13:36:58 <dmwit> With all due respect, this question could use a little work. =P
13:37:27 <kritzefitz> Yes, I'm working to reproduce this with a m
13:37:33 <kritzefitz> ... better example.
13:37:38 <dmwit> =D
13:38:41 <monochrom> Hey dmwit, "MCVE" is a cool name! What does it stand for?
13:39:25 <dmwit> minimal, complete, verifiable example
13:39:51 <dmwit> https://stackoverflow.com/help/mcve is like, the cliff notes for esr's Asking a Question the Smart Way
13:40:12 <monochrom> I wonder if it's OK to re-order the first 3 letters arbitrarily.
13:40:18 <dmwit> sure!
13:40:33 <dmwit> If only you could get all four to be in alphabetical order. =)
13:41:11 <dmwit> monochrom: What is your bot thing about, by the way?
13:41:18 <dmwit> Is it an inside joke of some sort?
13:41:30 <monochrom> Err which bot thing?
13:41:33 <dmwit> !list
13:41:33 <monochrom> dmwit: http://okmij.org/ftp
13:41:34 <geekosaur> that "!list" thing tends to mean people looking for a warez bot
13:41:54 <monochrom> Yes it is a joke.
13:42:05 <iqubic> What is a warez bot?
13:42:33 <boj> well iqubic 
13:42:41 <dmwit> People still use IRC for warez discovery? And freenode in particular??
13:42:53 <geekosaur> yes. and come here a lot for some reason
13:42:56 <dmwit> wild
13:43:48 <boj> i feel like understanding that dates a lot of us
13:44:22 <MarcelineVQ> one of gods own prototypes
13:51:49 <Gurkenglas> What Haskell IDE should I currently use? I would like <=15 mins of setup.
13:52:27 <Welkin> windows notepad
13:52:40 <johnw_> you could use that commercial Haskell IDE
13:52:45 <johnw_> i forget what it's called
13:52:58 <Gurkenglas> that means paid? nah
13:53:01 <Solonarv> ghcid + an editor with syntax highlighting should be all you really need
13:53:11 <johnw_> ah, you didn't say "free Haskell IDE" :)
13:53:25 <Solonarv> editor integrations are pretty hit-and-miss tbh (a lot of miss actually)
13:54:30 <Gurkenglas> would we have better free haskell ides if there wasn't a paid haskell IDE to keep potential developers complacent?
13:55:24 <Solonarv> I doubt it, I'm not even sure what the paid haskell IDE is
13:55:58 <Solonarv> ah, Haskell for Mac is a paid Haskell IDE
13:56:32 <Solonarv> but as the name suggests, it's mac-exclusive, so it clearly can't be dominating the market!
13:57:23 <monochrom> The paid one is Haskell for Mac.  Although, if you don't already have a Mac, you will need a day to first buy a Mac >:)
13:58:22 <monochrom> FWIW I don't even think the developers of Haskell for Mac are breaking even.
13:58:25 <Solonarv> intellij has a haskell plugin (or maybe more? not sure), but I couldn't get it to work
13:59:31 <Solonarv> there are also plugins for atom, vscode, sublime, vim, emacs, ... with various backends
14:00:02 <monochrom> Also in the 10 years that everyone wanted an IDE and yet Haskell for Mac didn't exist yet, no IDE happened whatsoever, free or paid.  Therefore the "complacent" theory is bunk.
14:00:17 <travv0> whatever spacemacs uses is the only thing that's consistently worked for me
14:00:19 <Welkin> most of use use emacs
14:00:19 <Solonarv> there's a standalone haskell IDE, actually (written in haskell, even!)
14:00:39 <Welkin> for th others there is vim (or evil mode in emacs)
14:00:44 <Solonarv> but IIRC it hasn't been updated (leksah)
14:00:45 <monochrom> Instead I say that the appearance of Haskell for Mac means that IDE developers finally wake up and are no longer complacent to the notion of free labour!
14:01:34 <Welkin> I don't use any fancy IDE thing, just basic syntax highlighting, so I could just as well use any text editor
14:01:41 <Welkin> although I prefer emacs bindings
14:02:29 <Solonarv> monochrom: an IDE has actually happened: http://leksah.org/ -- emphasis on *has*, though
14:02:41 <Welkin> I wonder if there is a measurable improvement in development speed/ease of use with an IDE or integration of some kind (like ghc_mod) or if it is placebo
14:03:02 <Welkin> for haskell or other similar languages that don't require an IDE to use (unlike java)
14:03:24 <Solonarv> that sounds really hard to measure tbh
14:03:30 <Welkin> learning an IDE is probably more work than learning emacs
14:03:43 <Welkin> every time I had to use xcode I had no idea wtf I was doing
14:04:31 <kritzefitz> dmwit, When I have RankNTypes and PolyKinds enabled `data Foo = Foo (forall a. ())` seems to trigger this strange behaviour.
14:08:29 <kritzefitz> Though the newtype I originally discovered this on, didn't have type variables in the forall that weren't used on the right hand side.
14:12:10 <Boarders_> I have some code like this: https://gist.github.com/Boarders/e69e1810f0e49688cec9e6ffe9e73eba
14:12:16 <Boarders_> (that example is not complete)
14:12:41 <Boarders_> GHC infers the type as Canvas Integer though I have NoMonomorphismRestriction on
14:12:59 <Boarders_> anyone know what I need to do to keep the type polymorphic>
14:13:08 <Boarders_> if I explicitly add the type as in the comment it doesn't help
14:13:09 <lyxia> you can't
14:13:18 <lyxia> every use of getCanvas needs a specific a
14:13:47 <Boarders_> oh ok
14:13:48 <lyxia> Num a => RenderContext (Canvas a)  is not equivalent to  RenderContext (forall a. Num a => Canvas a)
14:14:03 <Boarders_> hmm yeah
14:14:04 <lyxia> in the former, the RenderContext could depend on the Num instance.
14:14:17 <Boarders_> thank you
14:22:13 <kritzefitz> dmwit, I figured the problem out, I think.
14:22:29 <Solonarv> what was it?
14:22:49 <kritzefitz> When one of the universal types has a variable kind, GHC introduces that kind as an existential.
14:22:57 <Solonarv> oh, makes sense
14:23:55 <aplainzetakind> I have I have `x, y :: Maybe a`. For `x = Just x'`, and `y = Just y'`, I want to get `[x..y]`, otherwise `[]`. I did `catMaybes . sequence $ enumFromTo <$> x <*> y`, but I have a nagging feeling there's a more direct way to express this.
14:24:15 <aplainzetakind> s/I have //
14:24:38 <Solonarv> :t fromMaybe
14:24:39 <lambdabot> a -> Maybe a -> a
14:25:13 <aplainzetakind> > fromMaybe Nothing
14:25:15 <lambdabot>  error:
14:25:15 <lambdabot>      • No instance for (Typeable a0)
14:25:15 <lambdabot>          arising from a use of ‘show_M649221780159806394226705’
14:25:22 <Solonarv> 'fromMaybe [] $ enumFromTo <$> x <*> y' should do what you want
14:25:36 <aplainzetakind> Ah, sure. Thanks.
14:25:37 <kritzefitz> > fromMaybe 42 Nothing
14:25:40 <lambdabot>  42
14:25:51 <kritzefitz> > fromMaybe 42 (Just 5)
14:25:53 <lambdabot>  5
14:26:10 <Solonarv> you could replace 'fromMaybe []' with 'fold' or (I think) 'mconcat'
14:26:20 <Solonarv> 'asum', too
14:26:37 <kritzefitz> :t fold
14:26:39 <lambdabot> (Monoid m, Foldable t) => t m -> m
14:26:53 <Solonarv> % :t fold @Maybe @[_]
14:26:53 <yahb> Solonarv: Maybe [w] -> [w]
14:27:13 <Solonarv> % :t asum @Maybe @[_]
14:27:13 <yahb> Solonarv: ; <interactive>:1:14: error:; * Expected kind `* -> *', but `[_]' has kind `*'; * In the type `[_]'; In the expression: asum @Maybe @[_]
14:27:24 <Solonarv> % :t asum @Maybe @[]
14:27:24 <yahb> Solonarv: Maybe [a] -> [a]
14:28:48 <aplainzetakind> fold is nice
14:29:14 <aplainzetakind> > fold Nothing :: [Int]
14:29:17 <lambdabot>  []
14:43:15 <dmwit> :t concat
14:43:17 <lambdabot> Foldable t => t [a] -> [a]
14:43:23 <dmwit> many ways to skin this mconcat
14:43:24 <d0liver> Why is it that in ghci if I issue ":t show" I get "show :: Show a => a -> String" but if I do "let f = show" and then ":t f" I get "f :: () -> String"? I can't even convince it if I tell it explicitly "let f = show :: (Show a) => a -> String".
14:43:51 <dmwit> d0liver: https://stackoverflow.com/q/32496864/791604
14:44:28 <dmwit> d0liver: The correct way to give an annotation in a `let` is `let f :: Show a => a -> String; f = show`, by the way.
14:44:40 <d0liver> Ah, okay
14:44:42 <d0liver> Thanks!
14:45:01 <Solonarv> dmwit: nice pun
14:46:08 <d0liver> I guess the way I did it it's just applying it to the RHS (which is already the type of show) and then doing the normal thing again?
14:46:58 <geekosaur> correct, it doesn't use that to set the type of , only the type of show
14:47:02 <geekosaur> type of f
14:51:00 <jaarod> reading this ancient challenge, and I can't escape the feeling that b) requirement was designed to deliberately exclude `foo n i = n + 1' haskell example, which would be by far the most concise and elegant. http://www.paulgraham.com/accgen.html
14:52:01 <johnw_> also, atomicModifyIORef lets you get the value before modification in one step
14:54:53 <MarcelineVQ> use succ to get around b :>
14:54:57 <hololeap> is there any way to make something like Product but with the guarantee that Functors f and g contain the same data?
14:55:15 <johnw_> "contain"?
14:58:12 <geekosaur> jaarod, it's looking for a canonical C-style += op, not simply +
14:58:32 <hololeap> :t let n = 5 :: Int in \f g -> Product $ (f $> n) (g $> n)
14:58:34 <lambdabot> error:
14:58:34 <lambdabot>     • Variable not in scope: ($>) :: t -> Int -> t0 -> a
14:58:34 <lambdabot>     • Perhaps you meant one of these:
14:59:13 <jaarod> geekosaur, I know. but that is a pretty specific and weird requirement, stating that local variable needs to be mutated, just before it is returned, instead of simply returning addition
14:59:24 <hololeap> nvm i think i have an idea of what to do
15:00:08 <geekosaur> given C and other langiages have the operator, and it's fairly widely used in them, I dont see what's weird about it
15:01:15 <jaarod> geekosaur, because it serves no purpose to increment the variable you're returning it, as opposed to returning var + 1
15:02:20 <jaarod> "serves no purpose to increment the variable just before you're returning it, as opposed to returning var + 1", even
15:02:22 <Solonarv> hololeap: it's <$ not $>
15:02:24 <geekosaur> ok, it doesn't fit your universe. it's still a common operator
15:02:54 <geekosaur> and was common before haskell, which suggests maybe ther's something more to it than "exclude haskell"
15:02:56 <jaarod> geekosaur, I never said it wasn't. I said it was a weird and very specific requirement, that he repeated twice
15:02:58 <nshepperd1> :t concat -- this type makes me weirdly uncomfortable
15:02:59 <lambdabot> Foldable t => t [a] -> [a]
15:03:02 <johnw_> jaarod: you don't want the variable to change its value until you call the returned function
15:03:06 <hololeap> Solonarv: no, i meant ($>)
15:03:12 <Solonarv> also, in languages with C++'s model of operator overloading 'n += i' doesn't necessarily mean the same thing as 'n = n+'
15:03:33 <jaarod> johnw_, what purpose does that serve?
15:03:52 <johnw_> it's effectively: initialize n to a value, and then return the capability of adding something value to n
15:04:00 <johnw_> agreed, since you can't otherwise inspect n, not much
15:04:03 <jaarod> why does it have to change the value at all? caller does not care, or sees the difference, between local mutation, vs adding 1 to local variable
15:04:04 <johnw_> in fact, all you can ever do is modify it
15:04:12 <johnw_> so it's only useful if someone else could see n
15:04:22 <jaarod> right
15:04:31 <johnw_> i imagine the varagies of logic were not foremost in mind when designing this "puzzle"
15:06:01 <glguy> The point is to return the accumulated value along the way
15:06:06 <glguy> For example: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=599ce642ab9c4cbfffffbf47805d4088
15:06:11 <glguy> that prints 1 3 6
15:07:34 <johnw_> ah, right
15:07:38 <johnw_> increment, return prior value
15:07:55 <glguy> It's an ill-formed problem in Haskell as it asks you to do something that a function can't do by definition
15:09:19 <nshepperd1> That's just because they said "function" when they meant "procedure"
15:09:39 <johnw_> have we been nerd-sniped across the reaches of time?
15:09:59 <nshepperd1> Or whatever the proper term is for imperative-world 'functions'
15:10:27 <jaarod> glguy, if that was the example, it would make more sense. as described, it doesn't, there's no visible difference between mutating captured variable vs adding 1 to it (so no reason to prefer mutation, and even less reason to require it)
15:11:28 <nshepperd1> jaarod: you can call the returned function multiple times to increment it further
15:12:17 <Solonarv> in Haskell the type of the requested function would be 'Num a => a -> IO (a -> IO a)' - which is a bit unusual
15:12:18 <jaarod> oh!
15:12:30 <Solonarv> (s/IO/ST s/  would work too)
15:12:36 <jaarod> nshepperd1, I completely missed that
15:14:53 <nshepperd1> The description of the problem is quite poor imo, since it requires you to infer that just from it saying "incremented by, not plus"
15:15:18 <nshepperd1> 'clear as mud'
15:16:00 <koz_> nshepperd1: wow, such clear, very explain, amaze?
15:16:48 <iqubic> Except that mud is translucent
15:17:49 <koz_> iqubic: Depends how much mud I guess. And what kind.
15:24:30 * hackage sendfile 0.7.10 - A portable sendfile library  https://hackage.haskell.org/package/sendfile-0.7.10 (JeremyShaw)
15:24:44 <jaarod> can we do better (better being defined as shorter :) )?  foo n = do r <- newIORef n; return (\i -> atomicModifyIORef r (\x -> (x+i, x+i)))
15:25:28 <koz_> jaarod: Wouldn't this be better done in ST instead of IO?
15:25:32 <gentauro> jaarod: what's the point with that function?
15:25:41 <koz_> Heck, in _State_ even.
15:25:44 <jaarod> koz_, maybe
15:26:35 <jaarod> gentauro, it returns a function that, when called (possibly repeatedly), increments value stored in IORef 
15:27:04 <jaarod> koz_, can it be more concise?
15:28:58 <koz_> jaarod: What's the goal here? Code golf?
15:29:05 <jaarod> original example is probably clearer. foo n i = do r <- newIORef n; return (\i -> do modifyIORef r (+i) readIORef r)
15:29:05 <koz_> If so, I don't think Haskell is the right choice.
15:29:20 <jaarod> koz_, the goal is to have the shortest possible example in haskell
15:31:39 <hololeap> foo = fmap (\i -> flip atomicModifyIORef (\x -> (x+i,x+i))) . newIORef
15:32:22 <hololeap> well, not quite
15:33:01 <jaarod> foo is a function that returns IO function
15:33:11 <jaarod> foo :: Num a => a -> IO (a -> IO a)
15:34:55 <koz_> foo n i -> put n >> return (\i -> modify (+ i) >> get)
15:34:58 <koz_> Using State?
15:35:25 <koz_> If you want increment specifically, just eliminate the i and replace with 1.
15:35:29 <johnw_> and then use lens :)
15:35:43 <koz_> johnw_: Yeah, if you want even more golfy, lens operators are hard to beat.
15:36:10 <jaarod> koz_, is it supposed to be = instead of ->? (doesn't compile either)
15:36:20 <koz_> jaarod: Yeah, sorry, I was messing with it in yahb.
15:36:25 <koz_> foo n i = put n >> return (\i -> modify (+ i) >> get)
15:37:08 <glguy> > runState (id <+= 1) 10
15:37:10 <lambdabot>  (11,11)
15:37:30 <koz_> glguy: Thank you for the lens-fu.
15:37:36 <iqubic> eww. I don't like the (<+=) operator.
15:37:39 <jaarod> should probably be? foo n = put n >> return (\i -> modify (+ i) >> get) . that was my mistake, foo accepting both n and i
15:38:07 <koz_> % :t \n -> put n >> return (\i -> modify (+ i) >> get)
15:38:07 <yahb> koz_: (MonadState b m1, MonadState s m2, Num b) => s -> m2 (b -> m1 b)
15:38:12 <koz_> Yeah, that'd work.
15:38:28 <jaarod> yeah, ti works
15:38:44 <jaarod> evalState (do x <- foo 0; x 1; x 2; x 5) 0  => 8
15:39:12 <koz_> This is one case where _not_ using do-notation is probably called for.
15:39:22 <iqubic> it is?
15:39:54 <koz_> iqubic: Does that look kinda fold-y to you?
15:40:49 <iqubic> I'm not sure which line you are commenting on.
15:41:04 <koz_> evalState (do x <- foo 0; x 1; x 2; x 5) <-- this one
15:41:31 <jaarod> how would you write it?
15:41:45 <iqubic> looks sorta fold-y, but IDK what foo is.
15:42:00 <koz_> jaarod: Something like 'evalState (foldM ...) 0'. You can fill in the ...s yourself, I'm about to rush off.
15:42:26 <koz_> iqubic: foo n = put n >> return (\i -> modify (+ 1) >> get) -- from before
15:42:38 <iqubic> I don't know what that does.
15:42:42 <iqubic> Sorry.
15:43:26 <iqubic> I *REALLY* need to learn how State works.
15:43:28 <jaarod> koz_, I think that would obscure the spirit of the assignment
15:52:39 <jaarod> with lenses :P
15:52:46 <jaarod> foo n = put n >> return (\i -> id += i >> get)
15:53:44 <jaarod> @pl (\i -> id += i >> get)
15:53:45 <lambdabot> (>> get) . (id +=)
15:56:21 <iqubic> Are there lenses to manipulate State?
15:56:50 <jaarod> yes
15:57:13 <Solonarv> well, operators, not lenses
15:57:30 <Solonarv> generally speaking, the operators ending with = are State-y
15:57:34 <jaarod> right. += is one out of many such operators
16:05:45 <jaarod> data Person = Person { personAge .. } was State value, and age was the lens, you would do age += 1 to increment personAge field by 1
16:05:59 <jaarod> +if
16:13:22 <Gurkenglas> :t let go guess = guess $ ?x $ go $ ?y . guess in go id -- it seems to me that this can be simplified
16:13:24 <lambdabot> (?y::t -> t, ?x::t -> t) => t
16:14:30 * hackage transformers 0.5.6.0 - Concrete functor and monad transformers  https://hackage.haskell.org/package/transformers-0.5.6.0 (RossPaterson)
16:17:15 <Solonarv> :t fix \go guess -> guess (?x (go (?y . guess)))
16:17:17 <lambdabot> error: parse error on input ‘\’
16:17:28 <Solonarv> :t fix $ \go guess -> guess (?x (go (?y . guess)))
16:17:30 <lambdabot> (?y::t1 -> t1, ?x::t1 -> t2) => (t2 -> t1) -> t1
16:18:11 <Gurkenglas> it's accumulating on id, isn't that superfluous somehow?
16:19:43 <Gurkenglas> thinking something like "go guess = guess in go $ ?x $ go $ ?y guess" but that moves a guess out of scope
16:20:36 <Solonarv> I'm not actually sure what this even does
16:21:08 <Gurkenglas> that's the spirit :D
16:23:37 <jaarod> I looked at HTX and I'm not sure I like the arrows syntax (nor do I know much about arrows)
16:24:14 <jaarod> what other web scrapping libraries are commonly used (that handle malformed html)
16:24:28 <aplainzetakind> tagsoup?
16:25:15 <jaarod> thanks I'll take a look. any other?
16:34:43 <jaarod> tagsoup looks good
16:50:00 * hackage transformers 0.5.6.1 - Concrete functor and monad transformers  https://hackage.haskell.org/package/transformers-0.5.6.1 (RossPaterson)
17:04:30 * hackage transformers 0.5.6.2 - Concrete functor and monad transformers  https://hackage.haskell.org/package/transformers-0.5.6.2 (RossPaterson)
17:08:58 <Gurkenglas> :t let go guess = foldr ($) (?x $ go $ ?y : guess) guess in go [] -- hmm
17:08:59 <lambdabot> (?y::t -> t, ?x::t -> t) => t
17:37:06 <iqubic> Would anyone be able to explain to me how the State Monad works?
17:42:00 * hackage hledger-lib 1.13 - Core data types, parsers and functionality for the hledger accounting tools  https://hackage.haskell.org/package/hledger-lib-1.13 (SimonMichael)
17:42:40 <hololeap> :t runState
17:42:42 <lambdabot> State s a -> s -> (a, s)
17:43:00 * hackage hledger-api 1.13, hledger-web 1.13, hledger-ui 1.13, hledger 1.13 (SimonMichael)
17:43:51 <hololeap> State s a = s -> (a, s)
17:44:50 <hololeap> basically, you start with an initial state `s`, and with each monadic bind (each line in a for loop), it generates a value `a` and a new state `s`
17:46:18 <hololeap> the monadic part comes in when you have something that can do: `State s a -> (a -> State s b) -> State s b)
17:46:21 <jaarod> iqubic, conceptually, State monad does this for you:   (newStateValue, x) = function oldStateValue arg
17:46:47 <hololeap> s/for loop/do block/
17:46:50 <hololeap> oops
17:49:09 <hololeap> in other words, it allows you to compose functions, with the added bonus that you have something of type `s` that goes along with it
17:50:27 <hololeap> and it after each function runs, you must return a value of `s`... which can be the same or different from the previous value of `s`
17:53:12 <aplainzetakind> I think an example which is more natural than the canonical pseudonumber generator convenience thing and not completely trivial is what is needed for State exposition.
18:03:06 <dmwit> Wait, do people use State for things other than RNG and unique name generation?
18:03:08 <dmwit> ;-)
18:05:20 <hololeap> my impression is that most of the time you can use a fold instead of State, so it isn't used that much
18:06:54 <c_wraith> sometimes I tack StateT onto a monadic computation when I'm feeling too lazy to thread values around manually
18:08:26 <dmwit> I have a few examples in mind that are more complicated, but... they are *much* more complicated.
18:10:22 <shachaf> > over (partsOf (each.each)) reverse ("this kind of","thing uses","State")
18:10:24 <lambdabot>  ("etatSsesu gn","ihtfo dnik"," siht")
18:10:49 <shachaf> I think?
18:11:25 <dmwit> yikes
18:11:55 <dmwit> If the goal is a good motivating example... that ain't it.
18:12:25 <dmwit> (At least not without a bit more exposition about why that's an operation you might actually want to do.)
18:12:33 <shachaf> It's not.
18:12:57 <shachaf> I mean, the real thing is that you might be able to traverse a thing with an arbitrary applicative.
18:13:06 <c_wraith> it's closely related to "sort the elements in this tree without changing its shape", though
18:13:24 <shachaf> Sure, something like that.
18:14:24 <c_wraith> though, iirc, someone found a cleverer Applicative for that than State
18:14:55 <shachaf> That's the real problem with Haskell right there.
18:15:02 <shachaf> Not enough cleverness involved in doing simple things.
18:15:03 <c_wraith> (one that doesn't depend on a partial pattern match that you just happen to know won't fail)
18:17:05 <c_wraith> I once spent 10 hours making a pretty solution to something for which I had a fine solution in 15 minutes.
18:17:12 <c_wraith> Haskell!
18:18:44 <c_wraith> iqubic, Sorting elements isn't a bad example, though.
18:19:26 <jaarod> C# got pattern matching?! https://docs.microsoft.com/en-us/dotnet/csharp/pattern-matching#the-is-type-pattern-expression
18:19:45 <aplainzetakind> Removing duplicates from a list?
18:20:13 <c_wraith> iqubic, you can write something like traversableSort :: (Traversable t, Ord a) => t a -> t a
18:20:50 <c_wraith> iqubic, that one is a fun puzzle. it has multiple answers, but StateT is a good approach
18:21:01 <c_wraith> err. State is enough
18:21:45 <c_wraith> but see about writing that one. it's good practice.
18:22:18 <Solonarv> can you do it in one pass? I don't remember
18:22:32 <c_wraith> you can, but not with State.
18:22:45 <c_wraith> so... don't worry about it. :)
18:22:53 <Welkin> there is a clever iplementation using radix sort from edwardk
18:23:05 <Welkin> speaking of him, I haven't seen him around lately
18:23:53 <Solonarv> must be busy at miri ;)
18:25:28 <Welkin> miri?
18:26:17 <Solonarv> Machine Intelligence Research Institute / https://intelligence.org
18:26:36 <Welkin> oh, he got a new job?
18:26:46 <Solonarv> there was an announcement that they'd hired him, yes
18:27:00 <Solonarv> was posted on /r/haskell 2-3 months ago IIRC
18:27:33 <Welkin> so that means we might see more AI libraries in haskell
18:27:33 <Solonarv> they're actually hiring more haskell people too
18:27:51 <c_wraith> he said something about wanting to make sure they had a foundation upon which they could reason, rather than totally opaque ML techniques
18:28:19 <Welkin> I know what you mean
18:28:32 <Welkin> most AI is just brute force statistics
18:28:59 <Welkin> run it on the gpu and it spits out a trained model
18:29:48 <Solonarv> MIRI's mission can basically be summed up as "make safe AGI before someone makes unsafe AGI (and turns us into paperclips)"
18:31:26 <c_wraith> hmm. has anyone proposed pattern synonyms for the transformers types to emulate the non-transformer versions of everything? mostly, this would allow old tutorials that use constructors like State directly to work again.
18:32:59 <Solonarv> oh that's a great idea!
18:33:28 <widmur> Hello all. One of the things I find most baffling about Haskell is its strict whitespace. I'm sure you eventually develop an intuition for it, but in the mean time I would greatly appreciate some help with this parse error: https://gist.github.com/widmur/98229d63b6afd27f53ef48696727df72.
18:33:58 <Solonarv> I don't see anything in https://hub.darcs.net/ross/transformers/issues
18:34:34 <Welkin> whitespace is not strict
18:34:41 <Welkin> you can be very messy with it
18:34:54 <Welkin> but simply using a syntax mode in your editor will solve the problem
18:35:11 <Solonarv> widmur: have a look at the haskell report: https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7
18:35:51 <Welkin> also generally avoid where clauses and prefer let...in
18:36:01 <Welkin> `where` has a lot of gotchas
18:36:45 <MarcelineVQ> widmur: the report is good to read. in the meant time, the case needs to be indented farther than foldDatabaseItem to signify that it belongs to foldDatabaseItem
18:37:03 <MarcelineVQ> I think anyway, didn't try
18:37:16 <Welkin> install a syntax mode for your editor and it will correctly indent the code for you
18:37:29 <Solonarv> the wikibook explains it in some more detail: https://en.wikibooks.org/wiki/Haskell/Indentation
18:37:54 <Welkin> it is good style to have `where` or `let` on the line above the bindings, as in your second version
18:41:05 <widmur> Thanks Solonarv and Welkin. I guess strict isn't appropriate. It just doesn't feel as intuitive as indenting a sequence of instructions as in imperative languages. Thanks for the resource.
18:44:49 <Welkin> you will get the hang of it pretty quickly
18:44:59 <Welkin> but like I said, let your editor guide you
18:45:15 <Welkin> there should be a haskell-mode you can install that auto-indents (or at least let's you cycle indentation)
19:00:21 <aplainzetakind> Isn't the purpose of other-extensions: in the cabal file to spare the hassle of typing the extensions in every file?
19:00:49 <aplainzetakind> I have TupleSections there but in a module file it still complains that it's required.
19:04:06 <Solonarv> no, other-extensions allows cabal to tell you ahead of time "this package requires extensions that your compiler doesn't support!"
19:04:19 <Solonarv> the behavior you want is default-extensions
19:05:13 <aplainzetakind> Ah, alright.
19:45:55 <hololeap> is it possible to make a datatype that can represent a power-set of an arbitrary number of types?
19:47:01 <glguy> So given a list of types the values of this would contain 0 or 1 values of each type in the list?
19:48:24 <hololeap> glguy: i don't know if you have heard of the library `these`, but it contains a datatype These a b = These a b | This a | That b
19:48:43 <hololeap> i would like to extend that for more than just two types, but an arbitrary number
19:48:52 <glguy> That would be missing the None case for a powerset, right?
19:49:05 <hololeap> right... i think that would be isomorphic to () ...?
19:49:23 <hololeap> in any case, the None case isn't important
19:49:59 <glguy> I think you'd have something like: data Powerset :: [Type] -> Type where Hasnt :: Powerset xs -> Powerset (x : xs); Has :: x -> Powerset xs -> PowerSet (x : xs); Nil :: Powerset []
19:51:15 <Solonarv> that's just 'Rec Maybe' (from vinyl)
19:51:36 <hololeap> wha... ok, i'll have to check that library out
19:51:58 <Solonarv> yea vinyl is cool
19:53:33 <Solonarv> the core type is data Rec (f :: u -> Type) (rs :: [u]) :: Type where RNil :: Rec f '[]; (:&) :: f r -> Rec f rs -> Rec f (r:rs)
20:05:09 <Trollinator> Hi. There's something called `FunctionK` in Scala, which is essentially `newtype FunctionK f g a = FunctionK (f a -> g a)`. Is there something equivalent in Haskell?
20:07:28 <hololeap> Trollinator: it's a natural transformation. i'm not sure of where the best library to pick up an actual type for it is, though
20:07:47 <Solonarv> actually the type of natural transformations is (forall a. f a -> g a)
20:08:04 <hololeap> true...
20:08:10 <hololeap> that is less general
20:08:29 <Solonarv> % type (~>) f g = forall a. f a -> g a
20:08:29 <yahb> Solonarv: 
20:08:49 <Solonarv> if the 'a' isn't universally quantified then it's not the type of natural transformations
20:08:58 <Trollinator> Uh yeah, actually Scala's FunctionK type is equivalent to that Rank-2-type. I translated it wrong
20:09:56 <Solonarv> so yeah in Haskell you just turn on RankNTypes and write that
20:10:07 <Trollinator> So yeah, I'm looking for a natural transformation, but apparently there's no “standard” implementation, right?
20:10:23 <Solonarv> there's no real need for one, so there isn't one
20:10:36 <hololeap> Trollinator: the only one i have used is (:~>) from `natural-transformation`, but it seems like most people don't like it much
20:10:44 <Trollinator> OK, I see
20:10:46 <Trollinator> thanks
20:10:51 <Solonarv> hololeap: is that a type synonym or a newtype?
20:12:02 <Solonarv> ah, I see it has both
21:08:32 <iqubic> What does the natural trasformations package do?
21:11:18 <Solonarv> iqubic: 'type f ~> g = forall a. f a -> g a', 'newtype f :~> g = NT (f ~> g)', instances and a handful of functions for working with those types
21:13:14 <iqubic> Ah. That lines up with the category theory definition of a natural transformation.
21:14:48 <iqubic> So `[a] ~> Maybe' could be `safeHead' I suppose.
21:16:02 <glguy> [] ~> Maybe ?
21:16:28 <iqubic> glguy: Yes that.
21:17:04 <iqubic> it's a natural transformation.
21:17:16 <Solonarv> indeed
21:18:28 <Solonarv> other natural transformations (if you squint a bit): 'pure', 'join'
21:18:41 <iqubic> :t pure
21:18:43 <lambdabot> Applicative f => a -> f a
21:18:56 <iqubic> :t join
21:18:58 <lambdabot> Monad m => m (m a) -> m a
21:19:03 <iqubic> How???
21:20:26 <Solonarv> pure :: Applicative f => Identity ~> f
21:20:38 <Solonarv> join :: Monad m => Compose m m ~> m
21:20:44 <iqubic> I see.
21:24:37 <iqubic> Is Compose used all that often?
21:26:13 <Solonarv> not for monads, since '(Monad m, Monad n) => Monad (Compose m n)' doesn't always hold
21:26:49 <Solonarv> but this is one category-theoretical definition of monads, so it's nice to see that reflected in haskell
21:27:31 <Solonarv> (incidentally, this is why we need monad transformers - we can't just compose them directly)
21:29:10 <iqubic> I'm not quite sure how monad transformers work
21:29:36 <dmwit> A fun exercise: can you come up with a succinct description of the class of total inhabitants of `[] ~> Maybe`?
21:30:28 <iqubic> I'm not even sure what that question means.
21:31:18 <dmwit> That probably means I am asking an unfair "guess the teacher's password" function.
21:31:24 <Solonarv> Natural -> Natural almost works
21:31:44 <dmwit> Natural -> Natural is pretty good. It's just slightly too big.
21:31:57 <dmwit> (n : Natural) -> Fin (n+1) is pretty much it, I think.
21:32:28 <Solonarv> ignoring infinite lists, yes
21:32:47 <Solonarv> if you allow infinite lists it gets a bit messier to write but doesn't really change
21:32:49 <dmwit> Total inhabitants can't notice the list is infinite.
21:33:08 <Solonarv> oh, true
21:34:03 <dmwit> So I guess that means that even (n : Nat) -> Fin (n+1) is a bit too big.
21:34:16 <dmwit> You want the finitely supported (n : Nat) -> Fin (n+1)'s. =P
21:36:00 <hololeap> iqubic: monad transformers are monads that actually do compose. they have to do it like that because there's no general way to do it for any instance of Monad
21:36:11 <Solonarv> (n :: Nat, foreach (l :: Fin (n+1)) -> Fin (l+1)) works, I think?
21:36:15 <dmwit> (Where by "finitely supported", I mean, "there is some output for which only finitely many inputs differ", not the usual and ugly "finitely many inputs produce non-0 outputs".)
21:37:13 <dmwit> What's foreach?
21:37:27 <Solonarv> proposed notation for dependent haskell
21:37:54 <Solonarv> it's the ∏ quantifier, basically
21:38:13 <dmwit> That characterization looks pretty good.
21:38:46 <Solonarv> there might be an off-by-one error and there's obviously some abuse of notation but it seems right to me
21:39:05 <hololeap> iqubic: for instance `MaybeT m a` is `m (Maybe a)`. it just wraps Maybe in another monad and adds its effects (the ability to short-circiuit and return Nothing)
21:39:19 * dmwit irritably waves his hands at off-by-one quibbling
21:39:38 * Solonarv furious handwaving
21:40:59 <dmwit> I think I want (n :: Nat, f :: foreach ..., f n /= f (n+1))
21:41:22 <Solonarv> oh yeah I was thinking about adding that proof
21:42:18 <hololeap> iqubic: honestly, writing a Functor/Applicative/Monad instance for MaybeT is a good exercise
21:44:06 <Solonarv> iqubic: if you want an intuition for why monads in general don't compose: you have to write 'join :: m (n (m (n a))) -> m (n a)' given 'join :: m (m a) -> m a' and 'join :: n (n a) -> n a', which is obviously impossible
21:44:25 <Solonarv> you would need some way to swap 'm' and 'n'
21:45:10 <dmwit> (Swapping is sufficient but not necessary. There are other operations that would let you recover a monad.)
21:45:20 <Solonarv> fair
21:45:37 <mniip> I think I remember someone here spitting out that "forall" is right adjoint to delta
21:45:51 <Solonarv> definitely wasn't me
21:46:24 <dmwit> http://web.cecs.pdx.edu/~mpj/pubs/RR-1004.pdf discusses some alternatives to swap, including the lovely-named "dorp construction"
21:47:00 <Solonarv> Mark P. Jones? any relation to Simon?
21:47:43 <glguy> No
21:49:22 <mniip> I just arrived at a construction of "forall" as a particular cone
21:49:31 <mniip> however I don't yet quite see it being a *limit*
21:55:18 <hololeap> isn't forall an end?
21:55:32 * hololeap knows not much about CT
21:56:00 <hololeap> but i remember something like that
21:56:57 <Solonarv> I vaguely remember ends/cones/limits being special cases of each other in some way
22:00:28 <hololeap> ends use wedges, which are like cones but use dinatural transformations instead
22:01:25 <hololeap> the end up being like a universal product, which is essentially what forall means (if i understand it correctly)
22:02:08 <hololeap> coends are like the existential quantifier
22:03:22 <hololeap> a universal sum type
22:21:53 <mniip> hololeap, relating foralls to ends is exactly what I'm trying to do here
22:22:37 <mniip> wedges can be constructed as particular cones anyway
22:23:16 <mniip> I suspect I am looking at a totally surjective subobject of the infinite product though
22:23:49 <mniip> this notion probably has a morphisms only definition
22:23:54 <mniip> I should look for that
22:31:01 <mniip> hmm
22:31:03 <mniip> it's not a cone
22:32:28 <mniip> maybe it is
22:37:56 <hololeap> mniip: have you seen this? https://bartoszmilewski.com/2017/03/29/ends-and-coends/
22:38:54 <mniip> I know what ends are
22:39:29 <mniip> I have an issue with another blog post of his https://bartoszmilewski.com/2017/04/11/profunctor-parametricity/
22:41:54 <mniip> he writes
22:41:56 <mniip> if             xs <=(p b c)=> xs'
22:41:56 <mniip> then   (p f g) xs <=(p a d)=> (p f' g') xs'
22:42:07 <mniip> but he doesn't explain what the symbol 'p b c' means
22:42:15 <mniip> where p : Set^op x Set -> Set
22:42:21 <mniip> b in Hom_Rel
22:42:28 <mniip> c in Hom_Rel too
22:44:09 <mniip> I can believe a suitable functor : Set -> Set can be extended to one : Rel -> Rel
22:44:24 <mniip> but there's a particular issue that arises once you introduce contravariance with (->)
22:44:50 <mniip> "related functions map related values to related values" simply isn't a profunctor on Rel
22:47:03 <mniip> I don't remember now but there's a really simple counterexample to the preservation of composition
22:47:12 <mniip> with relations on like 1- and 2-element sets
22:48:20 <hololeap> maybe leave that as a comment on that page so others can see it
22:49:27 <mniip> be much simpler if bartosz was on IRC ;)
22:51:23 <mniip> hololeap, again I'm not expert enough to authoritatively advertise my conclusion
22:51:27 <mniip> maybe I'm just not seeing something
22:51:45 <mniip> I'd rather just converse with someone who knows this stuff
22:51:52 <hololeap> i'm even less expert so i can only take your word for it
22:52:04 <mniip> I know people who know this stuff exist here
22:57:05 <mniip> I wonder if he responds to fanmail
22:58:46 <hololeap> probably
23:15:59 * hackage cairo-core 1.16.3 - Cairo Haskell binding (core functions)  https://hackage.haskell.org/package/cairo-core-1.16.3 (magicloud)
23:32:00 * hackage gi-cairo-again 1.16.0 - Bridge between packages gi-* and cairo-core.  https://hackage.haskell.org/package/gi-cairo-again-1.16.0 (magicloud)
23:37:16 <fengshaun> where would one learn beyond "learn you a haskell for great good"?
23:45:52 <ion> fengshaun: Try https://github.com/bitemyapp/learnhaskell#readme
23:48:14 <fengshaun> ion, thanks
