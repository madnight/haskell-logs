00:00:04 <suzu> yes. except that even that is RT
00:00:36 <trcc_> yes, if you consider the state of the entire universe to be an input
00:00:38 <suzu> `getLine >>= \line -> print line` 
00:00:45 <suzu> `line` is referentially transparent
00:00:59 <suzu> if i take line and pass it around to some other functions, they will all have exactly the same value
00:01:39 <trcc_> yes. but, gimme a sec to make an example
00:01:57 <suzu> here's a function that is not RT
00:02:18 <suzu> `randNum :: Int; randNum = unsafePerformIO randomIO`
00:02:56 <trcc_> https://gist.github.com/CThuleHansen/2d00cf38b602845a7d63496fa06c0a30 in this one, readFile "abc" will return two different results when executed no?
00:03:08 <trcc_> or no sorry
00:03:11 <trcc_> it will not
00:03:16 <trcc_> but x and y will have different values
00:03:22 <trcc_> in execution
00:03:30 <suzu> this is fine too
00:03:59 <suzu> `x` will not change value from repeated reads of `x`, and nor will `y`
00:04:00 <trcc_> but why is that referential transparent? everything is given the same inputs, but the results differ
00:04:18 <suzu> technically, deleting the file is a change of input
00:04:26 <suzu> the 'state of the computer' changes
00:04:31 <suzu> and that's an input to IO
00:04:41 <suzu> so.. all of that is ok
00:04:46 <trcc_> so it is because you consider the state of the computer - or lets go beyond, the state of the universe to be an input
00:04:53 <suzu> as far as the language is concerned
00:04:54 <suzu> yes
00:05:50 <suzu> i have an example above of a function that is not referentially transparent
00:05:54 <suzu> `randNum :: Int; randNum = unsafePerformIO randomIO`
00:05:56 <suzu> this
00:06:23 <trcc_> because it does not store it in IO and therefore does not take RealWorld as input?
00:06:28 <suzu> that's right
00:06:32 <suzu> it breaks the rules
00:06:49 <suzu> and so `randNum` could have different values between uses in functions
00:06:55 <suzu> and will differ between compilations
00:07:00 <trcc_> So my argument against that is, that realworld is just a trick, since you can never restore a previous realworld state
00:07:01 <suzu> and will just generally be screwy and fuck
00:07:22 <suzu> yes, you can't restore a realworld state. so?
00:07:53 <suzu> the laws still work out
00:08:23 <trcc_> hmm 
00:08:29 <trcc_> god this is mind-bending
00:08:34 <suzu> i love haskell
00:08:43 <trcc_> right now I hate that I like it
00:08:47 <trcc_> :P
00:08:55 <suzu> i literally can't go back to writing python or anything like that probably ever again
00:09:01 <suzu> the matrix has been opened
00:09:30 <lunabo> Also, RealWorld is pretty much an implementation detail and I'm not sure whether it's a very good conceptual model for IO (although some might disagree)
00:09:33 <trcc_> suzu: but what is the impure part then? there must be some impure part, because it affects the real world
00:09:47 <suzu> yeah that's the compiler doing the actual effects for you
00:10:05 <suzu> writing to memory, making allocations, peeking on stdin
00:10:27 <trcc_> is it not wrong for Haskell to hide this away in the IO monad? This "hidden" dependency on RealWorld
00:10:47 <suzu> as lunabo mentioned, whether the model is good is debatable
00:10:55 <maerwald> trcc_: IO is not impure
00:11:03 <suzu> but does the model satisfy haskell? yeah the language is fine iwth it
00:11:18 <trcc_> maerwald: I am slowly understand that
00:11:39 <trcc_> Now I have reached the level on considering whether the model is a good approach or not
00:11:48 <maerwald> impurity is defined in terms of evaluation (usually)... if evaluation doesn't cause execution, then purity is still met
00:12:00 <suzu> "haskell is completely pure and has no side effects" and "you can write a program in haskell to launch the nuclear missiles" is hard to reconcile at first
00:12:05 <trcc_> exactly
00:12:22 <maerwald> evaluation IO actions usually does nothing
00:12:36 <trcc_> that reconcilation is difficult for me
00:12:37 <suzu> but putting them in `main` will do something
00:12:40 <maerwald> if you unsafePerformIO around, then yeah, you just broke purity
00:12:53 <suzu> ye
00:13:26 <trcc_> because in my head it is still. "yes haskell is completely pure, but when you execute it, it is not" sort of
00:13:30 <suzu> trcc_: for the longest time haskell actually /could not/ make side effects
00:13:38 <suzu> like IO didn't exist at all
00:13:51 <suzu> it was a research language that you'd work with in the repl and you'd make functions of String -> String
00:13:58 <trcc_> hehe interesting
00:14:03 <trcc_> then people wanted more
00:14:07 * hackage github 0.21 - Access to the GitHub API, v3.  https://hackage.haskell.org/package/github-0.21 (phadej)
00:14:11 <suzu> then this guy named Philip Wadler came along and said "hey i think i know some math tricks to make effects pure"
00:14:24 <suzu> and he brought IO (and monads) to Haskell
00:14:34 <maerwald> IO didn't have monadic interface in the beginning though
00:14:39 <suzu> right
00:14:51 <dminuoso> 09:13            suzu | [08:13:08] trcc_: for the longest time haskell actually /could not/ make side effects
00:14:51 <dminuoso> That's simply false/.
00:15:00 <suzu> no it isn't
00:15:00 <lunabo> trcc_: You could perhaps compare it to combining cooking recipes. Combining a recipe for making A with a recipe for making B from A is entirely pure, since given the same recipes you will always get the same combined recipe. But of course actually baking the actual cake is not pure. (I may have just committed the monad burrito fallacy ;) )
00:15:14 <trcc_> lunabo: went over the recipe idea yester. hehe
00:15:22 <suzu> IO flat didn't exist for a while dminuoso 
00:15:46 <maerwald> lunabo: it's easier to understand if you explain evaluation vs execution as opposed to coming up with cakes and burritos and ramen
00:15:47 <maerwald> :P
00:16:00 <maerwald> enough with the food
00:16:15 <lunabo> maerwald: that is what I was referring to by monad burrito fallacy ;)
00:16:36 <trcc_> maerwald: I think that is my exact issue point. evaluation vs execution. No program, that is never executed, is really useful (in my view). So why have the focus on evaluation instead of execution
00:17:26 <dminuoso> Haskell had no monadic IO back then, but we very much had a (poorer) abstraction for managing side effects.
00:17:26 <dminuoso> Specifically a program was `main :: [Request] -> [Response]` 
00:17:26 <dminuoso> Err, flip those around! :)
00:17:27 <dminuoso> Issuing an effect amounted to appending a request and reading the result just meant reading from there response list.
00:17:51 <suzu> oh. ok. TIL
00:18:04 <suzu> i know that in spj's escape from the ivory tower talk, he said that it was String -> String
00:18:28 <dminuoso> suzu: Nope.
00:18:34 <maerwald> trcc_: evaluation you can do on paper
00:18:35 <dminuoso> suzu: Perhaps that was the case in the earliest of all days.
00:18:37 <suzu> he didn't say that?
00:18:43 <suzu> that may be right
00:18:45 <dminuoso> suzu: Or you misremember.
00:18:53 <Ferdirand> shouln't that be [Response] -> [Request] ?
00:18:57 <dminuoso> suzu: Either way, pre-IO we had the `[Response] -> [Request]` scheme.
00:19:09 <dminuoso> Ferdirand: yes, I followed it up with "flip those around" :)
00:19:23 <Ferdirand> ah sorry
00:19:26 <dminuoso> suzu: It was not ergonomic and obviously highly error prone.
00:19:27 <Ferdirand> need more coffee
00:19:34 <suzu> yeah i believe that
00:20:09 <Ferdirand> by the way, don't we have a result that any user-writeable monad can be encoded into Cont ?
00:20:10 <dminuoso> But it worked.
00:20:28 <dminuoso> Ferdirand: What do you mean by "user-writeable monad can be encoded into Cont"?
00:21:14 <Ferdirand> i mean not IO
00:23:34 <trcc_> If you allow some pseudo code, is this sort of correct? https://gist.github.com/CThuleHansen/a69e080050a685479669d73cf5f068aa
00:23:38 <dminuoso> Ferdirand: Any chance you can rephrase that question? I cannot understand what you are trying to ask.
00:23:55 <Ferdirand> dminuoso: it was with respect to the monad burrito fallacy
00:24:41 <Ferdirand> would it be correct to say that do-notation is just sugar for continuation passing ?
00:25:03 <dminuoso> trcc_: Imagine for a second that IO had the type `[AsmInst]`
00:25:25 <dminuoso> trcc_: Would you believe that given `putStrLn :: String -> [AsmInstr]`, then any invocation of `putStrLn "Hello World!"` returns the same action?
00:25:29 <trcc_> dminuoso: I think I have understood that part
00:25:37 <trcc_> yes
00:25:38 <trcc_> I would
00:25:59 <trcc_> Based on your answers yesterday and my reading in bed and this morning got me so far
00:26:37 <dminuoso> trcc_: In C evaluation and execution are inherently tied together.
00:26:42 <dminuoso> trcc_: In Haskell they are separated.
00:26:53 <trcc_> dminuoso: yes. So my example https://gist.github.com/CThuleHansen/a69e080050a685479669d73cf5f068aa - is that correct?
00:27:05 <trcc_> of course, difficult to say with pseudo code >P
00:27:32 <dminuoso> trcc_: Really not sure what (+) is supposed to denote there.
00:27:37 <lunabo> Ferdira: I think there is a paper saying that you could translate almost any monad into delimited continuations, but I don't think the encoding is very nice and you wouldn't want to actually implement monads that way. Pretty sure it was more of an argument for not needing monads in theory if your language has delimited continuations.
00:28:01 <trcc_> hehe that idea is, that evaluation differs. + could be ++
00:28:10 <dminuoso> trcc_: In C you could imagine that `void ~ ()` (where ~ denotes type equality), and that *every* function returns `IO a` for some choice of a.
00:30:00 <trcc_> I think it understand it
00:30:12 <trcc_> wild ride hehe
00:30:16 <dminuoso> trcc_: So in C `printf :: *Variadic Args* -> IO ()`
00:30:40 <trcc_> but now you are encoding haskell into c
00:30:44 <trcc_> no?
00:30:52 <dminuoso> If you apply that reasoning, you can trivially transform any C program into Haskell code.
00:30:52 <dminuoso> Ferdirand: No. do-notation is supar for bind.
00:31:54 <trcc_> so I would go more like saying that readFile fileName in Haskell compares to a function pointer in C
00:38:28 <Ferdirand> dminuoso: sure, but pedagogically, that doesn't help much
00:39:24 <Ferdirand> if just throwing around the signatures of bind/join/return was enough, we wouln't be talking about monad burritos in the first place
00:44:13 <phadej> I think RWH-approach is quite nice. They introduce bind-like operator for Maybe and a parsing library (and maybe even some 3rd example)
00:44:20 <phadej> before even mentioning Monad as a word
00:44:48 <phadej> and IMHO you cannot really get monads faster
00:44:56 <comerijn> Looks like ICFP might actually be doable for me this year \o/
00:45:17 <tdammers> I think diehl gets it mostly right with the "eightfold path to monad satori"
00:45:37 <phadej> (and do-notation for IO is introduced as an opaque syntax at first - which should be enough for beginners)
00:46:11 <tdammers> something about problem-solution ordering
00:46:25 <phadej> tdammers: :)
00:46:31 <phadej> http://dev.stephendiehl.com/hask/#eightfold-path-to-monad-satori
00:46:39 <tdammers> that's the one
00:47:01 <tdammers> steps 1, 2 and 8 are arguably the most important ones
00:48:39 <phadej> 7. and it's more general instance of it "do exercises, practice" is important too
00:49:00 <dminuoso> trcc_: A rough analogy, but it works.
00:49:13 <trcc_> great! 
00:49:21 <dminuoso> trcc_: If you think of it as an "action" you will have much easier time later on.
00:50:12 <dminuoso> trcc_: In some way you could say that it's not IO that makes Haskell special, but the fact that you can have functions *without* IO.
00:50:24 <trcc_> I am writing a blog with the title "First Package on Hackage - A Beginner's Journey." I will probably include this as part of it.
00:50:39 <trcc_> hmm interesting point of view
00:50:39 <dminuoso> So it's the ability to not have effects that is powerful.
00:51:48 <dminuoso> trcc_: At the same time, the ability to have functions producing pure IO effects gives us powerful combinators.
00:52:21 <trcc_> I think I need more hands-on to understand it more thoroughly for now. I have read about a lot of constructs in haskell, but something like you just said "the ability too... gives us powerful combinators" sounds fancy, but I do not really understand it until I've tried it some times
00:52:28 <tdammers> they're all important obviously
00:52:37 <trcc_> I also keep going back to reading about various concepts as my knowledge progresses
00:53:35 <dminuoso> trcc_: One of the nice things is, if you ever see some type signature like `f :: Int` or `f :: Double -> Char`, you know instantly it can never launch missiles, access a database or do HTTP requests.
00:53:43 <trcc_> definitely!
00:53:53 <tdammers> fsvo "know" and "never"
00:54:34 <dminuoso> Barring some misuse of unsafe primitives.
00:54:36 <dminuoso> ;)
00:56:45 <lunabo> trcc_: what is also really nice is being able to pass IO actions as arguments, as in doTwice act = act >> act
00:56:54 <elgoosy> hi, is there a specific case or any example where the first (the reader monad) is better/clearer way than the second (function accepting arg + let expression) https://pastebin.com/XNfPYUuu ?
00:57:42 <lunabo> trcc_: I think this is one of the primary situations where it is nice to have the distinction between the time of evaluation and the time of execution. If you wanted something like that in C or Python, you'd have to wrap the action in a function
00:58:36 <maerwald> which is not really difficult
00:58:47 <dminuoso> But unwieldy and noisy.
00:58:52 <maerwald> *shrug*
00:59:03 <lunabo> maerwald: true, it is not meant to be a slight against C or Python, just an illustration of the difference
00:59:18 <maerwald> I don't consider that a strong selling point though
00:59:18 <dminuoso> In C you are forced to wrap it. In Haskell you can just take the action and pass it to timeout: timeout 5 getLine
01:00:22 <trcc_> lunabo: deifnitely. Thanks
01:01:02 <dminuoso> elgoosy: Reader is generally not that useful. There are odd situations where monad combinators (say traverse/sequence/foldM/others) may lead to more compact or expressive code. ReaderT seems to be more useful.
01:01:17 <fr33domlover> In do notation, when I want to use a monadic action and ignore the result, what's the best practice for expressing that? Should I use 'void' or something like _result <- doSomething
01:01:32 <comerijn> fr33domlover: I just disable the warning :p
01:02:07 <dminuoso> fr33domlover: Both are fine. Id prefer the second.
01:02:32 <fr33domlover> comerijn, I do want the warning :p dminuoso, can you explain why the second? :)
01:02:57 <merijn> fr33domlover: Why do you want the warning? Seems rather marginal
01:03:00 <dminuoso> fr33domlover: Because void has a weird and unfitting name, and the latter is more likely to be understood by more people.
01:03:42 <Ariakenom> My favourite example regarding the distinction between pure functions and effects is STM. Where, for example, you can type check against nested transactions.
01:05:48 <fr33domlover> merijn, it's totally possible for me to accidentally forget to use the result value, and later possibly fetch it in other ways, forgetting I already had it. Or forget some important check on that result value. I prefer to be explicit about ignoring the result value
01:06:00 <fr33domlover> dminuoso, good point, thanks :)
01:06:24 <dminuoso> fr33domlover: If in doubt, use the simpler and more expressive version! :)
01:07:48 <fr33domlover> dminuoso, I will ^_^
01:07:57 <MarcelineVQ> dminuoso: void should be the eliminator for Void, like maybe and either and bool etc, but people like how absurd sounds more :O
01:08:13 <merijn> fr33domlover: Honestly, in 10 years of haskell that's never happened to me, so :)
01:09:42 <dminuoso> MarcelineVQ: The desire to show people how much superior Haskell is, to have such strange evocations from the mathematical bag of magical tricks.. 
01:10:10 <fr33domlover> merijn, you mean you *think* it never happened ;) Seriously though, I get that, but I just feel more calm knowing that *if* this happens, the compiler will tell me. And _ <- doStuff is explicit about it. If I did that implicitly it would be less clear to people reading the code, including myself
01:10:56 <fr33domlover> MarcelineVQ, dminuoso, are void and absurd named after mathematical concepts?
01:11:06 <fr33domlover> I wonder why void isn't named discard or something
01:11:16 <merijn> void is named after "void" in C, presumably
01:11:35 <dminuoso> Or it's named after the meaning of the verb void.
01:11:51 <dminuoso> As in "void the result"
01:12:01 <dminuoso> Presumably.
01:12:45 <fr33domlover> dminuoso, at least they didn't name it obilivion :P
01:14:45 <dminuoso> MarcelineVQ: At least the name of `absurd :: Void -> a` is not as bad as `void :: Functor f a -> f ()`. :)
01:15:43 <fr33domlover> Also in Haskell you don't really discard the value, it just gets its type changed into () with the value ()
01:15:57 <fr33domlover> So it's a bit more confusing than, say, in C
01:16:13 <fr33domlover> I mean, you discard the value but there's still a return type
01:19:52 <MarcelineVQ> absurd isn't a bad name at all, it is absurd to have a value of Void, the type without values, so since we're in the realm of absurdity we might as well produce whatever we like. It's just that void as a name fits the pattern nicer
01:21:00 <merijn> MarcelineVQ: Pretty sure it derives from "reductio ad absurdum"
01:21:10 <MarcelineVQ> ye
01:29:13 <lunabo> Perhaps absurd should be called explode instead, referring to the principle of explosion (from falsehood anything follows) ;)
01:29:23 <trcc_> haha I am slowly but steadly dragging my collegue into haskell
01:49:04 <fr33domlover> Hmm does a monad transformer for the following exist: I'd like to do some monad actions, each returning a number, and I'd like the overall action to fail if the sum of these numbers reaches some threshold. The most simple code is to do these actions, sum the numbers and check, but, that's wasteful because I could detect the number going too high earlier
01:50:03 <fr33domlover> I suppose I could build it with StateT and MaybeT, just wondering if anything closer already exists
01:50:34 <lunabo> fr33domlover: I was about to say that
01:51:36 <gentauro> is it possible to run `stack script` with package flags? I have looked into the `docs` and it doesn't seem that it's covered -> https://docs.haskellstack.org/en/stable/GUIDE/#flags-and-ghc-options
01:51:38 <merijn> Well, there almost certainly can't be a monad transformer for this
01:51:48 <gentauro> my question is, why isn't it a "thing" :)
01:51:48 <merijn> Because I'm pretty sure this doesn't obey the monad laws
01:52:44 <lunabo> merijn: if the number that is being bounded is kept in state, then I think it does work?
01:52:56 <fr33domlover> merijn, sure it does! You can do it with StateT and MaybeT ^_^ each action updates the state which is a number (StateT) and checks if it's above the threshold, causing an error if yes (MaybeT or ExceptT)
01:53:21 <lunabo> merijn: might be different if you want to perform the check on every intermediate value of the computation
01:53:23 <merijn> fr33domlover: You can implement a function that does this on top of existing transformers, yes
01:53:25 <fr33domlover> merijn, and using 'lift' you could do any other actions that are unrelated to the number  etc.
01:53:36 <merijn> lunabo: He wants to check at every intermediate step
01:54:06 <fr33domlover> I don't mean the checking should be magically automatic, it can be explicit which actions need a check and which don't
01:54:31 <merijn> fr33domlover: Right, but then you're no longer talking about a transformer :)
01:54:37 <fr33domlover> Just like ExceptT has throwE for errors and otherise you can use plain reglar return and lift and so on
01:54:57 <merijn> fr33domlover: They're called "monad transformers" because they "tranform" one monad into another. But that means both sides need to obey the monad laws :)
01:56:37 <fr33domlover> merijn, well, I mean I'd do that on top of StateT and MaybeT ^_^ Just like in MaybeT you can apply 'MaybeT' function, in my case you'd apply some 'CheckSumT' to lift a number-returning action into this sum tracking thing :p
01:57:41 <fr33domlover> I suppose instead of sum tracking I can use any Semigroup/Monoid
01:57:57 <fr33domlover> So it's a bit like WriterT with intermediate checks of the value accumulated
01:59:07 * hackage equivalence 0.3.4 - Maintaining an equivalence relation implemented as union-find using STT.  https://hackage.haskell.org/package/equivalence-0.3.4 (PatrickBahr)
01:59:22 <lunabo> fr33domlover: the only caveat which I guess merijn was referring to is that you can write a monad instance that works (sometimes), but does not respect the monad laws
02:00:48 <lunabo> fr33domlover: but it is not obvious to me that any monad laws would be violated (although at first I also thought they might be)
02:00:56 <fr33domlover> lunabo, hmmmm why would it not respect the laws? I mean, it seems I can use a transformer that is simply a newtype wrapper of MaybeT-on-StateT ?
02:01:23 <fr33domlover> And then I don't need to write any Monad instances at all
02:01:43 <lunabo> fr33domlover: If you only want to check the threshold after certain functions instead of all of them, yes
02:03:02 <fr33domlover> lunabo, all changes to the threshold value would explicit so yeah that hopefully makes things simple
02:03:35 <lunabo> fr33domlover: and in fact it would probably also work even if you did write a custom StateT that checks it at every state transformation
04:01:37 * hackage madlang 4.0.2.15 - Randomized templating language DSL  https://hackage.haskell.org/package/madlang-4.0.2.15 (vmchale)
04:18:15 <dminuoso> MarcelineVQ: I like to think of Void not as the type without values, but Void as the type of _|_ in some sense.
04:19:14 <dminuoso> MarcelineVQ: It might sound like hair splitting, but I really like to carry `IO Void` around rather than `IO a` in some instances to denote infinite computations/infinitely running threads.
05:07:08 <lyxia> those last two sentences seem to contradict each other...
05:07:45 <merijn> lyxia: How so?
05:07:57 <lyxia> IO Void works to denote divergent computations *because* Void is empty
05:08:28 <lyxia> but it's not empty if you consider _|_ as a legal inhabitant
05:10:28 <__monty__> lyxia: I disagree. If bottom means (among other things) "this diverges", it being a legal inhabitant isn't contradictory.
05:12:35 <phadej> lyxia: one can go from "forall a. IO a" to "IO Void" and back
05:13:19 <phadej> Maybe Void is a value which isn't ever Just
05:13:30 <phadej> similarly IO Void is a value which never returns ;)
05:13:54 <phadej> is an actuin*
05:13:59 <lyxia> __monty__: I mean if you give me (t :: IO Void), I will expect (t >> throw MyError) to *not* throw MyError, unless t does it itself.
05:15:12 <lyxia> t = return undefined   is bad Haskell so it doesn't count.
05:15:44 <phadej> won't that throw UserError which one can catch in IO :)
05:16:03 <lyxia> phadej: I don't understand your point?
05:16:10 <lyxia> return undefined   doesn't throw
05:16:14 <__monty__> lyxia: I don't see the problem. If `t` diverges it won't ever throw that error.
05:17:04 <phadej> I'm not sure if "diverges" is right term
05:17:06 <lyxia> __monty__: If Void has an inhabitant, then an IO Void could return it.
05:17:23 <phadej> there's subtle difference between `forever (return 'a')` and `forever (print 'a')`
05:17:44 <phadej> former is mistake, latter is valid code you would like to write
05:17:54 <lyxia> The reason nobody expects IO Void to terminate successfully then is that Void has no inhabitant, or at the very least that "undefined" is not a "normal" inhabitant.
05:17:55 <phadej> (maybe not with `print 'a'`)
05:18:59 <__monty__> lyxia: Not if that inhabitant is something that diverges. From my pov this is just a matter of words. You seem to presuppose that any inhabitant must be something that doesn't diverge. And you conclude from that that even a diverging inhabitant (_|_) does not diverge.
05:20:05 <lyxia> Yes we have been splitting hairs since the beginning of the discussion.
05:21:04 <__monty__> Well that's what happens when you start a discussion by splitting a hair.
05:23:11 <lyxia> I did not conclude that a diverging inhabitant does not diverge though.
05:26:03 <lyxia> phadej: I agree with your point of view.
05:27:24 <phadej> lyxia: which one :D
05:27:33 <lyxia> phadej: all that you said since I started speaking.
05:28:01 <phadej> uh, good combo for today; better to not spoil it ;)
06:01:17 <__monty__> lyxia: I think you did. By assuming that if it's a legal inhabitant, then I should be able to pass it to you and that anything I could possibly pass you wouldn't diverge and therefore continue and throw the error.
06:04:10 <zepingwu> anybody?
06:04:51 <Clint> everybody
06:06:02 <ProofTechnique> How would one express `reverse` using `recursion-schemes`? I'm reading some tutorials and thought that'd be an instructive thing to do, but it's not clicking for me.
06:06:28 <phadej> ProofTechnique: have you tried writing reverse using foldr?
06:07:12 <ProofTechnique> foldr (flip (++) . pure) []
06:07:37 <phadej> well, cata ~ foldr
06:11:32 <ProofTechnique> Oh, I see, now
06:11:52 <ProofTechnique> algReverse (Cons x xs) = xs ++ pure x
06:12:08 <ProofTechnique> And now I can `cata algReverse`. Neato :)
06:12:11 <ProofTechnique> Thanks, phadej
07:07:15 <delYsid> Hmm, big up for haskell-gi, very nice!
07:09:25 <dmwit> ProofTechnique: If you want efficient, you might look into difference lists.
07:09:57 <dmwit> algReverse (Cons x f) = f . (x:); cata algReverse xs [] -- or something like that
07:10:43 <kritzefitz> Has anyone else trouble sending mails on Haskell-Cafe when the sending server has greylisting enabled?
07:10:58 <dmwit> > foldr (\x f -> f . (x:)) id [1..5] []
07:10:59 <lambdabot>  [5,4,3,2,1]
07:11:52 <kritzefitz> Specifically, mail.haskell.org apparently tries to verify the sender address, runs into the greylisting and then caches the temporary failure for several hours, thus refusing the sender address repeatedly.
07:32:59 <marvin2> > foldr (flip (:)) [] [1..10]
07:33:01 <lambdabot>  error:
07:33:01 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ [a]
07:33:01 <lambdabot>        Expected type: [a] -> [a] -> [a]
07:33:09 <marvin2> > foldl' (flip (:)) [] [1..10]
07:33:11 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
07:39:21 <fen> does foldMap work for strams?
07:39:31 <fen> streams*
07:41:19 <lyxia> > take 10 $ foldMap (:[]) [0..]  -- yes
07:41:21 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
07:41:41 <ProofTechnique> dmwit: That's a neat idea, but I'm having trouble working out the Nil case. :/
07:41:47 <fen> > take 10 $ foldMap undefined [0..]
07:41:49 <lambdabot>  *Exception: Prelude.undefined
07:42:03 <fen> oh nvm
07:42:09 <fen> thankslyxia
07:43:43 <fen> so does that mean for a Foldable0 class (foldable for streams, where foldr doesnt need a basecase), can provide a default for Foldable1 safely using foldMap1 = foldMap0, where there is again a default for foldMap = foldMap1
07:44:09 <fen> was worried the Endo Monoid might not be sufficently lazy
07:44:52 <dminuoso> > length (take 10 (foldMap undefined [0..]))
07:44:53 <lambdabot>  *Exception: Prelude.undefined
07:45:12 <fen> the undefined can seve as a basecase for foldr...
07:45:22 <fen> as it would never reach the end of the stream
07:45:42 <fen> no use with foldMap
07:45:48 <dminuoso> fen: better to use `error` with some error message instead.
07:46:33 <fen> error "unreachable" serves well for that case, it never is called, but can show the reader of the code what the undefined is doing
07:47:37 <fen> anyway, was considering not having a foldMap0 for the Foldable0 class, but lyxia's example seems to show it could work
07:47:46 <ProofTechnique> dmwit: Oh, wait, I get it. I had to specify the types a bit more explicitly
07:48:06 <fen> are there not cases where it could cause an infinite loop though, so the computation just hangs?
07:48:21 <fen> and where using foldr would solve this
07:49:23 <fen> its just an unjustified feeling of caution because sometimes its not clear why these infinite loops happen, namely, why it is forced (probably by strictness) to try and reach the end of the loop
07:49:28 <fen> end of the stream*
07:51:05 <fen> it would be nice to include a foldMap0 function in the Foldable0 class, and provide the default for foldMap1, is there any reason to be worried that this might result in hanging computations if the user is not careful in some way?
07:51:30 <fen> and, what kind of comment would inform the user how to use this function correctly?
07:52:09 <fen> lyxia: guess there is a case where that would not have worked, like if it was strict cons or something?
07:52:52 <fen> good to know the Endo monoid does not force strict evauation of the tail though
07:56:04 <fen> :t seq
07:56:05 <lambdabot> a -> b -> b
07:56:46 <fen> :t ($!)
07:56:47 <lambdabot> (a -> b) -> a -> b
07:56:55 <cocreature> is there an easy way to detect if I’m running in ghci? (please don’t ask why I need that :))
07:57:09 <lyxia> fen: yeah, but you always have to be careful about strictness with infinite structures anyway
07:57:38 <fen> > take 10 $ foldMap (($!) (:[])) [0..] 
07:57:40 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
07:57:45 <dminuoso> cocreature: Asking to not ask why is like begging to ask!
07:57:46 <fen> hmm
07:57:51 <dminuoso> cocreature: I want to know your dirty little secrets.
07:58:51 <cocreature> dminuoso: weird build process and I need to detect ghci since I need to access runfiles differently in that case
07:59:26 <dminuoso> cocreature: How portable does it need to be?
07:59:46 <fen> lyxia: why does making (:[]) stric in the above example still work?
07:59:49 <Solonarv> if you have control over how the GHCi is invoked you could just set some environment variable
07:59:49 <dminuoso> cocreature: And is the `ghci` invocation under your control (and potentially modifiable)?
08:00:26 <dminuoso> fen: Because strictness only applies up to WHNF.
08:00:26 <fen> does Endo somehow make it lazy again?
08:00:27 <cocreature> dminuoso: that’s actually a good point, I think I can just set an env var
08:00:41 <ClaudiusMaximus> https://hackage.haskell.org/package/base-4.12.0.0/docs/System-Environment.html#v:getProgName maybe one hack (but someone might rename ghci to hugs)
08:00:59 <Solonarv> env var certainly seems like the cleanest approach to me
08:02:24 <cocreature> yeah, I’ll see if I can get that work
08:02:44 <cocreature> ClaudiusMaximus: that’s what I was using up until now but it doesn’t actually seem to work in some circumstances :)
08:02:57 <int-e> > (length $ foldMap (($!) (:[])) [0], length $ foldMap (($!) (:[])) [undefined])
08:02:59 <lambdabot>  (1,*Exception: Prelude.undefined
08:03:50 <fen_> specifically break as a result of trying to apply all the monoids together and as a result attempt to reach the end of the stream 
08:04:27 <int-e> fen: ^^ the $! is really forcing the list elements when packing them into singleton lists. foldMap ends up concatenating an infinite list of singleton lists, which it does lazily.
08:05:06 <fen_> oh, so that is making the wrong thing strict
08:05:17 <int-e> well "wrong"
08:05:44 <fen_> the idea was that it would break if the monoid was strict, but this is just making the thing that returns the monoid strict
08:05:53 <int-e> > take 10 $! [0..]
08:05:55 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
08:06:05 <int-e> $! will only force the outermost constructor anyway
08:06:22 <fendor> When installing an executable with `cabal new-install` how could I change the name of the installed binary? e.g. Add a suffix or prefix?
08:06:39 <fen_> :t ($!) . (:[])
08:06:40 <lambdabot> error:
08:06:40 <lambdabot>     • Couldn't match type ‘[a]’ with ‘a1 -> b’
08:06:40 <lambdabot>       Expected type: a -> a1 -> b
08:06:45 <fen_> nvm
08:07:08 <fen_> so is foldMap always safe to use with streams?
08:07:33 <Taneb> Depends on the monoid
08:07:45 <Taneb> > foldMap (Last . Just) [0..]
08:07:50 <fen_> the Monoid is always Endo
08:07:52 <lambdabot>  mueval-core: Time limit exceeded
08:07:52 <lambdabot>  mueval: ExitFailure 1
08:08:09 <fen_> ah, ok maybe just concerned with the foldr default
08:08:31 <fen_> so if thats always safe then its ok, because its not the library code which would provide a bad monoid
08:09:59 <fen_> @let foldr' f z t = appEndo (foldMap (Endo . f) t) z
08:10:01 <lambdabot>  Defined.
08:10:16 <fen_> so maybe try breaking that
08:10:57 <fen_> getting it to make a strict evaulation of the tail and cause a hanging computation when used on a stream
08:11:22 <fen_> or will it always be ok?
08:11:24 <Solonarv> > foldr' (\e !a -> [e] ++ a) [] [0..]
08:11:26 <lambdabot>  error:
08:11:26 <lambdabot>      Ambiguous occurrence ‘foldr'’
08:11:26 <lambdabot>      It could refer to either ‘F.foldr'’,
08:11:41 <fen_> @let foldr_ f z t = appEndo (foldMap (Endo . f) t) z
08:11:42 <lambdabot>  Defined.
08:11:48 <fen_> > foldr_ (\e !a -> [e] ++ a) [] [0..]
08:11:55 <lambdabot>  mueval-core: Time limit exceeded
08:12:11 <fen_> :-(
08:12:21 <Solonarv> you could come up with less contrived strict-in-the-second-argument functions, of course
08:12:32 <fen_> endo does not save us here
08:12:37 * hackage dynamodb-simple 0.6.0.1 - Typesafe library for working with DynamoDB database  https://hackage.haskell.org/package/dynamodb-simple-0.6.0.1 (ondrap)
08:12:43 <Solonarv> > foldr_ (+) 0 [0..] :: Int
08:12:50 <lambdabot>  mueval-core: Time limit exceeded
08:12:51 <lambdabot>  mueval: ExitFailure 1
08:13:24 <fen_> nah but that would break with the normal foldr
08:13:39 <fen_> its got to return something that can have take written over it
08:14:07 <fen_> so that we can use the lazyness to recover a tractable computation
08:14:23 <dminuoso> 17:00             fen | does Endo somehow make it lazy again?
08:14:25 <dminuoso> fen_: You should be able to answer *that* part yourself.
08:14:27 <dminuoso> Endo is a newtype.
08:14:39 <dminuoso> newtypes are erased at runtime, so it couldn't introduce any lazyness by virtue of being erased.
08:14:39 <fen_> so no?
08:14:44 <fen_> ok
08:14:51 <fen_> nice thanks
08:15:39 <fen_> Solonarv: the question is about being worried that providing a default for foldr0 in terms of foldMap0 might be sketchy because its working on streams
08:15:59 <Solonarv> it seems to me like you'd be fine
08:15:59 <fen_> that example did not break because of the use of foldMap
08:16:06 <dminuoso> fen_: One additional thing to remember, is that (:) is an infix Cons. That is you could imagine that `data [a] = Cons a [a] | Nil. 
08:16:25 <dminuoso> fen_: So each (:) introduces a constructor layer (which is the boundary for WHNF)
08:16:47 <fen_> right, so a list is not WHNF
08:16:57 <dminuoso> fen_: Huh?
08:17:06 <Taneb> "undefined : undefined" is WHNF
08:17:16 <fen_> !?
08:17:17 <dminuoso> Well it might not be.
08:17:38 <Taneb> fen_: because it's reduced as far as its outermost constructor
08:17:41 <dminuoso> But what Taneb is trying to point out, is that evaluating `undefined : undefined` to WHNF will not diverge.
08:18:05 <Taneb> > (undefined:undefined)`seq`()
08:18:07 <lambdabot>  ()
08:18:50 <dminuoso> fen_: In my data type that would be written as: Cons undefined undefined
08:19:08 <dminuoso> % data List a = Cons a (List a) | Nil
08:19:08 <yahb> dminuoso: 
08:19:53 <dminuoso> fen_: Some functions like `length` never need to force the value of a list, only its spine. Which is why something like this will not diverge either
08:20:10 <dminuoso> % length (undefined : undefined : undefined : nil)
08:20:11 <yahb> dminuoso: ; <interactive>:90:9: error: Variable not in scope: undefined; <interactive>:90:21: error: Variable not in scope: undefined; <interactive>:90:33: error: Variable not in scope: undefined; <interactive>:90:45: error:; * Variable not in scope: nil :: [a0]; * Perhaps you meant one of these: data constructor `Data.Functor.Foldable.Nil' (imported from Data.Functor.Foldable), data constructor `Nil' 
08:20:14 <dminuoso> % length (undefined : undefined : undefined : [])
08:20:15 <yahb> dminuoso: ; <interactive>:91:9: error: Variable not in scope: undefined; <interactive>:91:21: error: Variable not in scope: undefined; <interactive>:91:33: error: Variable not in scope: undefined
08:20:31 <wroathe> With something like foo :: (MonadReader Options m, MonadState ConfigNode m, MonadIO m) => m a; foo = undefined, where does the order of transformers on the stack get determined? Is it just done by inference on the order runStateT and runReaderT get called?
08:20:34 <ski> @slap yahb
08:20:34 <lambdabot> I'd rather not; yahb looks rather dangerous.
08:20:36 <dminuoso> % let undefined = undefined in length (undefined : undefined : undefined : [])
08:20:36 <yahb> dminuoso: 3
08:21:10 <wroathe> This mtl classes style of writing codes seems like it just generally makes monadic code less fun to write
08:21:13 <dminuoso> wroathe: MTL is *not* about monad transformers.
08:21:19 <dminuoso> wroathe: The *user* supplies the stack.
08:21:25 <dminuoso> wroathe: Or not even a transformer stack.
08:21:49 <ski> .. strange how `undefined' (exported from `Prelude') is not in scope in yahb
08:21:59 <fen_> so cons does not evaluate the values and that has something to do with WHNF
08:22:05 <dminuoso> ski: Someone probably messed with the GHCi session in a private chat.
08:22:06 <dminuoso> % :q
08:22:07 <yahb> dminuoso: 
08:22:14 <wroathe> Yeah, so when you say "supplies the stack". That's based on type inference on how that function is used?
08:22:16 <dminuoso> % undefined
08:22:17 <yahb> dminuoso: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:1:1 in interactive:Ghci4
08:22:30 <fen_> thats the correct error
08:22:33 <dminuoso> wroathe: Not necessarily inference.
08:23:08 <fen_> why would anyone undefine undefined!?
08:23:46 <wroathe> dminuoso: In practice the order of monad transformers on the stack matters though, right?
08:23:49 <fen_> anyway, seems like foldMap0 default for foldMap1 is safe to provide to the user, which is a good conclusion, thanks
08:24:08 <ski> wroathe : in general, yes. but some particular transformers commute
08:24:13 <wroathe> dminuoso: I guess what I'm wondering is if this style of code is introducing ambiguity that should be used with healthy skepticism
08:26:23 <wroathe> Actually writing out ReaderT Options (StateT ConfigNode IO) () in the type signature is less general than the classes I used above, but when you use the classes approach you then need to rule out transformer stacks that might cause bugs
08:26:31 <ski> (hm, perhaps there should be a table of which common transformers commute ?)
08:27:39 <dminuoso> 08:23:46 <wroathe> dminuoso: In practice the order of monad transformers on the stack matters though, right?
08:27:39 <dminuoso> Again this is irrelevant.
08:27:40 <dminuoso> wroathe: mtl does not talk about stacks.
08:27:42 <dminuoso> data MagicMonad a = MagicMonad { runMagicMonad :: IORef Int -> IO a }
08:27:53 <dminuoso> This gives a valid `MonadState Int` instance`
08:28:14 <merijn> dminuoso: Except not really :p
08:28:22 <dminuoso> merijn: Hum why?
08:28:30 <merijn> dminuoso: Pretty sure the mutability of IORef invalidates the Monad laws :)
08:28:50 <merijn> Because it can be concurrently mutated
08:29:06 <dminuoso> Okay yeah fine. Let's pretend forkIO is not a thing!
08:29:50 <ski>   data MagicMonad a = MagicMonad { runMagicMonad :: forall s. STRef s Int -> ST s a }  -- perhaps ?
08:30:03 <wroathe> dminuoso: So I'm following what you're saying about the scope of mtl's concerns, but in practice the programmer DOES need to be concerned with what the actual monad stack could be when writing code like this, don't they?
08:30:19 <dminuoso> wroathe: mtl has nothing do with monad stacks.
08:30:26 <dminuoso> wroathe: the user picks the stack in whatever order he likes
08:30:33 <dminuoso> or the *monad* rather.
08:30:55 <dminuoso> wroathe: Think about Functor. Would you say that Functor is about lists?
08:31:04 <merijn> wroathe: dminuoso's point is that you use mtl to write code agnostic of the underlying monad, which (in applications) is not very common
08:31:28 <merijn> wroathe: If you're writing application code, you need to pick a specific stack, at which point mtl doesn't get you much
08:31:43 <dminuoso> wroathe: lists are just one instance of Functor. maybe is just one instance of functor.
08:31:50 <dminuoso> monad transformer stacks form a *subset* of valid mtl class instances
08:31:56 <wroathe> When I say that "the programmer needs to be concerned", I'm saying "the producer needs to be concerned with how the consumer will use the thing"
08:33:02 <dminuoso> wroathe: https://hackage.haskell.org/package/exceptions-0.10.0/docs/Control-Monad-Catch.html#t:MonadThrow this might be a good example (imagine this was in mtl, it might as well have been)
08:33:11 <dminuoso> wroathe: There's plenty non-transformer instances there. :)
08:33:57 <wroathe> Yeah, I think I'm following. I'll think on this some more. Thanks dminuoso.
08:34:20 <dminuoso> wroathe: well sure. picking different monads gives different effects
08:35:02 <dminuoso> and not all monad transformers commute like ski has implied
08:35:23 <wroathe> dminuoso: Yeah, phrased another way: How can I ensure that every monad that satisfies the constraints I specify will yield the runtime behavior I intend?
08:35:36 <merijn> wroathe: "You can't"
08:35:39 <wroathe> dminuoso: I'm skeptical about leaving that up to the consumer
08:35:59 <dminuoso> wroathe: MonadState is about saying: look I dont care about what monad.
08:36:01 <dminuoso> "I just need to put/get/modify some state"
08:36:24 <dminuoso> Just like MonadIO is about saying "I dont care about what monad, but I need to do IO..."
08:37:05 <wroathe> That one seems easier to reason about to me for some reason
08:37:51 <wroathe> It's the interplay of reader/writer/state-like monad stacks that have me concerned
08:38:11 <dminuoso> wroathe: fair enough, that is unrelated to mtl then. :)
08:38:20 <dminuoso> its a transformers topic
08:38:46 <wroathe> Well, I wasn't exactly criticising MTL, but the two concepts are related. I think you're focusing too much on the MTL aspect of what I'm talking about :P
08:39:13 <wroathe> There's a broader minefield here that newcomers to Haskell need to navigate
08:39:51 <merijn> wroathe: If your application relies on a specific ordering of operation the solution is to use that specific stack, rather than mtl classes
08:41:07 <wroathe> I suppose it's no worse than making your public API rely on interfaces in an OOP language
08:41:28 <wroathe> It's not like you can guarantee that the consumer won't do something pathological with that
08:41:33 <merijn> wroathe: If you don't want to make the stack public you can
08:41:51 <merijn> wroathe: You can just define a newtype for your transformer stack and export that in libraries
08:42:19 <merijn> wroathe: The newtype then functions as an opaque interface preventing users from relying on implementation details
08:43:51 <wroathe> merijn: Yeah. The first step then is to determine if I actually care what the monad is :P
08:44:40 <wroathe> merijn: As long as it walks/talks/smells like what I expect
09:03:07 * hackage stdio 0.1.1.0 - A simple and high performance IO toolkit for Haskell  https://hackage.haskell.org/package/stdio-0.1.1.0 (winterland)
09:03:35 <fen> is there an Apply superclass of Applicative proposal like the Semigroup superclass of Monoid proposal?
09:06:01 <fen> or any place to import a version of Applicative with Apply as a superclass?
09:06:41 <[exa]> fen: as far as I remember from asking around, pure-less Apply doesn't really occur very much so I wouldn't expect that to materialize
09:06:52 <[exa]> but some of the alt preludes have it, lemme google
09:07:25 <fen> guess asking for all Applicatives to be rederived is more of an ask that the same for Monoids...
09:07:32 <fen> reimplemented*
09:07:51 <fen> but yeah, dont want to write one because it wouldnt have all the instances
09:08:13 <fen> seems to apply fairly often... as often as nonempty containers
09:08:15 <[exa]> do you have a good example of Apply for which pure doesn't make sense?
09:08:26 <fen> its used to define Traversable1
09:08:36 <fen> thats all..
09:08:54 <fen> and there are a lot of Traversable1 instances
09:09:19 <fen> again, as many as nonempty containers
09:09:30 <fen> well, ok thats not quite right
09:09:43 <fen> as many as nonempty Traversable1 instance, which isnt saying much...
09:09:50 <fen> but there are enough of them, thats the point
09:10:13 <fen> like, Free Nonempty is a Traversable1 instance
09:10:21 <fen> and thats the basis of this Pointers library
09:10:43 <fen> isomorphic to all nonempty leaf trees...
09:10:48 <fen> cyclic graphs etc
09:11:36 <[exa]> hmm never thought of that
09:12:43 <[exa]> oooh they have examples, maps are Apply but not Applicatives
09:12:46 * [exa] rejoices
09:13:53 <fen> streams?
09:14:44 <phadej> streams are applictives
09:14:59 <fen> they dont have pure
09:15:05 <phadej> at least data Stream a = a :> Stream a
09:15:20 <fen> oh, repeat
09:15:26 <phadej> yes
09:15:34 <phadej> if applicative is ZipList like
09:15:50 <fen> yeah
09:16:26 <fen> well its not going to be diagonal like!
09:16:41 <fen> then you would need an infinite evaulation to get the first value
09:17:53 <phadej> you can write concatMap for Stream, but it's boring
09:17:57 <phadej> you won't get past first stream
09:18:51 <fen> cant seem to find a prelude with Apply as a superclass to Applicative
09:19:25 <phadej> one need to be very crazy to override wired-in classes (and Monad is)
09:20:14 <fen> well, the code just depends on prelude and not any imported modules (other than Apply!)
09:21:44 <fen> and the code is to override Traversable, which is wired in
09:22:10 <phadej> I'm not sure what you are trying to do, but newtype WrappedApplicative f a = WrapApplicative (f a) would probably help you do what you want without altering the hierarchy
09:22:40 <fen> ah, sounds like an alright workaround in the mean time
09:23:02 <benzrf> :t WrappedMonad
09:23:03 <lambdabot> error:
09:23:03 <lambdabot>     • Data constructor not in scope: WrappedMonad
09:23:03 <lambdabot>     • Perhaps you meant ‘WrapMonad’ (imported from Control.Applicative)
09:23:06 <phadej> (and instance Applicative f => Apply (WrappedApplicative f) )
09:23:08 <benzrf> :t WrapMonad
09:23:08 <lambdabot> m a -> WrappedMonad m a
09:23:36 <phadej> yeah, WrapMonad is what was used for similar thing before AMP/GHC-7.10
09:24:57 <Taneb> http://hackage.haskell.org/package/semigroupoids-5.3.2/docs/Data-Functor-Apply.html#t:WrappedApplicative
09:25:31 <phadej> Taneb: cool!
09:25:42 <phadej> it's all there
09:25:50 <Taneb> Handily, it's right there with the Apply class
09:27:23 <fen> traverse'Default f = unwrapApplicative . traverse1' (WrapApplicative . f)
09:28:07 <fen> the primes are just to avoid conflicing with existing functions and classes such as traverse
09:28:54 <phadej> same package defines Traversable1 too
09:29:08 <fen> the full code is huge! 3 specialisations from r a, to (i,a) to a === Identity a, and 3 classes of classes, streams linear and stack
09:29:23 <fen> so each module has like a 3x3 block of classes.
09:30:02 <fen> feels like some kind of tensor network!
09:30:41 <fen> will github it soon
09:32:10 <fen> there are 2 things it provides, comonad defaults for linear (nonempty) via zipper/pointer. and traverse/fold/fmap _r giving access to the structure or shape at each value. 
09:32:28 <fen> oh, and defaults for all the many classes from the corresponding get/set pair
09:32:50 <fen> stencils are still a way off
09:36:24 <fen> needs a serious proof read
09:49:34 <Unode> when building a projext with ghc, is there any way to tell it not to build functions/code that isn't used? or at the very least not fail if these functions are incomplete or fail to type-check
09:50:01 <dminuoso> Unode: You could use typed holes or `undefined/bottom`
09:50:28 <Solonarv> there is -fdefer-type-errors
09:50:31 <monochrom> typed holes still error out.
09:50:44 <Unode> I tried typed holes but, what monochrom said
09:50:48 <Solonarv> which turns ill-typed code into something like (error "type error")
09:51:06 <monochrom> But perhaps combine with -fdefer-type-errors
09:51:23 <dminuoso> Unode: I'd just comment code out.
09:51:38 <dminuoso> Unode: Forgetting deferred type errors or bottom in your code is just asking for crashes down the road.
09:51:41 <monochrom> But it probably doesn't defer some things you want deferred.
09:51:43 <EvanR> interesting it seems holes and defer type errors doesnt exactly match this feature
09:51:46 <Unode> this might just be bad practice from my part but I often find myself commenting and uncommenting code such that the code evaluation engines such as HIE can provide type information when code is half broken on the document
09:52:23 <Solonarv> if you just want type errors, using holes for anything unimplemented should work
09:52:33 <EvanR> if code never runs should it need to check
09:52:33 <wroathe> This must be the pattern merijn was talking about above: https://github.com/haskell-servant/servant/blob/master/servant-server/src/Servant/Server/Internal/Handler.hs
09:52:45 <wroathe> For monad transformer stacks
09:53:17 <dminuoso> wroathe: This is what I do too. Provide a concrete stack, newtyped and using GND to gain access to all the fun instances.
09:53:21 <Unode> EvanR: I assume this approach comes from the 'library' context where you only know you'll need a function when you call it.
09:53:34 <monochrom> I would use error "TODO" when I just want ghci to succeed.
09:53:47 <dminuoso> wroathe: Though these days it's always just LoggingT (ReaderT Env) ...
09:53:50 <Unode> monochrom: error "TODO" ?
09:53:55 <wroathe> dminuoso: Yeah, seems way better 
09:53:57 <EvanR> good point
09:53:58 <monochrom> error "TODO"
09:54:00 <dminuoso> Screw other transformers... I want unliftio
09:54:18 <Unode> monochrom: hum... I see
09:55:15 <monochrom> But there are times even error "TODO" is too hairy.
09:55:37 <Solonarv> yeah, if it has IO at the base I want unliftio
09:55:43 <monochrom> When that happens, I run two ghci processes, and do a kind of two-phase commit.
09:55:49 <Solonarv> that means no ContT, no StateT, no WriterT
09:55:58 <dminuoso> Solonarv: Who needs that anyway.
09:55:59 <monochrom> One of them is ghcid actually.
09:56:05 <Solonarv> exactly!
09:56:07 <dminuoso> Solonarv: Any mutable state can be deal with by keeping some IORefs in your Env.
09:56:15 <Solonarv> (ContT is a beast from hell)
09:56:17 <dminuoso> WriterT seems to have no uses
09:56:21 <dminuoso> and ContT.. you said it.
09:56:30 <Unode> monochrom: yeah I thought of having two code basis for that same reason but it's too cumbersome to handle
09:56:36 <Unode> bases*
09:56:48 <monochrom> No, not two code bases.  Two ghci's.
09:56:51 <dminuoso> Solonarv: I just tend to use StateT/MaybeT/ExceptT/etc locally when I need some effect. :)
09:57:01 <Solonarv> yeah, fair
09:57:06 <dminuoso> so inside some part of the application I might do `runMaybeT $ ... `
09:57:23 <Unode> monochrom: right, can't do that with something like HIE. It just re-evaluates on any change.
09:57:23 <wroathe> The whole monad/monad transformer/mtl classes/GND story is a deep rabbit hole indeed :/
09:57:42 <monochrom> HIE would have to do its own two-phase commit then.
09:57:48 <dminuoso> wroathe: I misunderstood it as "you need transformers to solve problems in Haskell"
09:58:01 <dminuoso> wroathe: transformers are just a cool trick you can do because Haskell is special, but you dont need them at all.
09:58:06 <monochrom> But I don't care for anything more ambitious than ghci so meh.
09:58:15 <dminuoso> once I learned that, transformers became somewhat lackluster and boring :P
09:58:18 <Unode> monochrom: :)
09:58:32 <Unode> I'm still a newbie at haskell so any IDE help is most welcome
09:58:55 <tdammers> IDE help isn't
09:59:09 <Unode> Though I find it surprisingly hard to get type-checking information to work once you start changing the code and thing start erroring
09:59:31 <Unode> tdammers: how so?
09:59:47 <monochrom> ghci already has new commands for tab completion, type of arbitrary subexpression, go to definition.  emacs haskell mode already uses them.
10:00:07 <dminuoso> Unode: Writing small modular code helps a lot.
10:00:32 <dminuoso> Unode: If it takes more than 3 lines with 80 characters width, perhaps split into more identifiers. Then you can write lots of annotations. :)
10:00:33 <Unode> monochrom: I don't use emacs. Guess that might be half the issue. Seems like a lot of haskellers do
10:00:50 <dminuoso> Unode: Plenty use vi, atom, vscode too.
10:00:56 <monochrom> And the only difference between emacs haskell mode and dante is that dante has default keyboard bindings for those, emacs haskell mode doesn't.
10:01:13 <Unode> I jump between vim and vscode. Not quite happy with either for haskell.
10:01:54 <Unode> but thanks for the feedback, I'll give the suggestions a try
10:02:20 <tdammers> IME the kind of learning approach where you type things into an IDE and "see what they do" doesn't help a lot with Haskell
10:02:44 <wroathe> dminuoso: Yeah, as someone going through this learning path for the first time, it's been quite challenging to continually have to generalize your understanding of a concept just to write some decently elegant Haskell code
10:03:01 <dminuoso> wroathe: hah turns out not generalizing as much is better
10:03:08 <bodisiw> when i create a new stack project to test an old library, there's a conflict resolving the language extension (TH)... any way to know how to resolve that? should i change my resolver lts to some other version?
10:03:42 <dminuoso> wroathe: this whole business of "write cool mtl polymorphic type-trick pony lens code with traversals, comonads and quasiquotes just to be able to prove laws about your coends and codensities.." tends to just stop you from being productive for a long time.
10:03:50 <Solonarv> bodisiw: probably, yes
10:04:19 <dminuoso> wroathe: the parts that keep me productive are the things I learned on day one.
10:04:54 <Solonarv> IIRC 'stack init' tries to find a resolver compatible with what's in the cabal file
10:05:16 <tdammers> you're better off figuring out the basics using pen and paper, even
10:06:55 <bodisiw> Solonarv, ah thanks!  putting the dependency in my cabal file and running `stack init --force` seems to be trying all the lts plans
10:06:58 <wroathe> dminuoso: I'll keep that in mind. Thanks.
10:09:58 <fen> here is the gist! https://gist.github.com/fen-hs/6bb03486008a8a31b9edf95f8bd35f46
10:18:38 <wroathe> fen: I'm so proud of you (making gists and all) :P
10:33:27 <fen> wroathe: aye,cheers
10:47:07 * hackage siren-json 0.3.1.1 - Siren Tools for Haskell  https://hackage.haskell.org/package/siren-json-0.3.1.1 (alunduil)
11:01:57 <sarna> hey, are there any materials on refactoring functional programs? refactoring as in Martin Fowler's book
11:19:57 <zachk> sarna, I have found successful refactoring of my code in haskell the easiest out of any languages, because your code will not type check as you break it into smaller chunks, and then you need to satisfy the type checker with your refactoring, and it is usually valid when you do 
11:27:11 <sarna> zachk: hm, yeah, it seems to be easier than in OO langs :) thanks
11:27:32 <zachk> sarna, it is for me at least :) 
11:27:54 <zachk> dynamic language programs are especially easy to break when refactoring 
11:30:23 <sarna> zachk: yeah, mutability tends to be a pain too
11:31:27 <zachk> I tend to need a mutable global shared state for say a multiplayer game and maybe not that much else 
11:33:03 <zachk> I guess with multithreaded programs, I only know of shared state for communication, and message passing 
11:34:50 <sarna> yeah, there's STM, locks or message passing
11:34:57 <sarna> or going full commando :)
11:35:07 * hackage hierarchical-spectral-clustering 0.3.0.1 - Hierarchical spectral clustering of a graph.  https://hackage.haskell.org/package/hierarchical-spectral-clustering-0.3.0.1 (GregorySchwartz)
11:44:38 <fen> class Unfoldable0 f where unfoldr0 :: s -> (s->(a,s))       -> f a
11:44:48 <fen> class Unfoldable1 f where unfoldr1 :: s -> (s->(a,Maybe s)) -> f a
11:44:58 <fen> class Unfoldable  f where unfoldr  :: s -> (s->Maybe (a,s)) -> f a
11:46:21 <fen> there should be constraints to form a superclass hierarchy, and possibly defaults implementing the superclasses using the subclasses
11:48:12 <fen> like, if you can unfold a stream, then you can unfold linear or stack, so given unfoldr0 it should be possible to write unfoldr1 and unfoldr
11:48:54 <fen> similarly unfoldr in terms of unfoldr1. that is, if you can unfold nonempty then you can unfold a list
11:50:53 <fen> sowe can demand that an Unfoldable instance implements Unfoldable1 and 0, and give defaults
11:52:05 <ddellacosta> I'm trying to build GHC as part of setting up a Haskell env on NixOS, and it's failing with the error "The 'ghc-flag' directive is already registered to domain std" https://gist.github.com/ddellacosta/788407aa6568ec77e26b07c82fbfe96d anyone have any ideas?
11:56:52 <sm> fiatjaf: your hledger-ghcjs demo is pretty cool and I'm happy you keep it running, any plans to do more with it ?
12:00:07 <slaterr> asdf
12:01:00 <MarcelineVQ> I agree
12:04:34 <Zvpun> `MonadIO (ReaderT r m)` implements `liftIO = lift . liftIO`. This confuses me, can someone please explain a little?
12:09:18 <ski> Zvpun : that `lift' has type `m a -> ReaderT r m a', the `liftIO' on the right has type `IO a -> m a' (note that `MonadIO m' is assumed). composed, these yield a definition for `liftIO' on the left, of type `IO a -> ReaderT r m a'
12:09:38 <Solonarv> Zvpun: https://gist.github.com/Solonarv/921344bb09d2179cdb3f974608dcf7c5
12:09:48 <ski> the `lift' comes from the `MonadTrans (ReaderT r)' instance
12:09:51 <Solonarv> (the same definition, with type signatures added)
12:12:07 * hackage toodles 1.1.0 - Manage the TODO entries in your code  https://hackage.haskell.org/package/toodles-1.1.0 (aviaviavi)
12:13:07 * hackage interp 1.0.0.0 - Tracery-like randomized text interpolation  https://hackage.haskell.org/package/interp-1.0.0.0 (swizzard)
12:14:21 <parsnip> call to arms: someone please port hledger executable to android
12:14:57 <parsnip> i am a perpetual newb, but wish i could help
12:16:04 <parsnip> context: there's two new ledger apps coming to f-droid, and an hledger executable could springboard this ecosystem
12:16:26 <parsnip> *the first two ever, in fact, afaik
12:17:21 <parsnip> assuming this port is in fact an ideal leverage
12:19:34 <fen> is the problem with giving a version of Applicative with Apply as a superclass something to do with its only function being pure, and that this might as well be a valid superclass Create?
12:20:37 * hackage interp 1.0.0.1 - Tracery-like randomized text interpolation  https://hackage.haskell.org/package/interp-1.0.0.1 (swizzard)
12:21:20 <zachk> parsnips, have you tried installing the userland app on android, using an ubuntu system from it and apt-get install haskell-platform, then cabal update && cabal install hleddger?
12:25:42 <neosimsim> is it possible to install docs outside .store using `cabal new-install`? --docdir does not seem to work.
12:28:19 <fen> here is the resulting Unfoldable hierarchy https://gist.github.com/fen-hs/0e01cf44b066804433b24a64429f2400
12:30:08 <fen> unfortunately the defaults for the undirectional version in terms of the _r versions is not possible as it is for Traverse and Foldable 
12:31:25 <camsn0w> What are the best resources to start learning haskell?
12:32:01 <neosimsim> http://learnyouahaskell.com/ did it for me
12:32:20 <ski> you could try
12:32:24 <ski> @where CIS194
12:32:24 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
12:32:34 <ski> if you want exercises
12:32:52 <ski> a textbook probably wouldn't hurt
12:32:53 <ddellacosta> camsn0w: I'm a big fan of http://www.cs.nott.ac.uk/~pszgmh/pih.html 
12:33:19 <suzu> the haskell book is alright
12:33:23 <ddellacosta> O
12:33:44 <zachk> @where pih 
12:33:45 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
12:33:53 <zachk> that cleared it up for me ^ 
12:33:57 <ddellacosta> I've heard a lot of folks recommend Richard Bird as well: https://www.cs.ox.ac.uk/publications/books/functional/
12:34:08 <ski> (suzu, i assume you mean "Haskell Programming: from first principles - Pure functional programming without fear or frustration")
12:34:14 <suzu> yes
12:36:30 <gentauro> ski: nice link
12:37:14 <neosimsim> is it possible to install docs outside .store using `cabal new-install`? --docdir does not seem to work.
12:39:37 * hackage interp 1.0.0.2 - Tracery-like randomized text interpolation  https://hackage.haskell.org/package/interp-1.0.0.2 (swizzard)
12:39:45 <ski> gentauro : CIS194 ?
12:45:54 <zachk> if I am using a Comonad store focused over a list, how do I change the focus of it? 
12:45:57 <gentauro> yeah
12:48:30 <slack1256> zachk: What focus have the list when you `extend :: w a -> w (w a)` them?
12:50:44 <zachk> you mean duplicate?
12:51:54 <slack1256> Oh yes, duplicate
12:54:14 <zachk> not sure where the focus is on a duplicate , cant show it
12:54:15 <zachk> % let s = store (!!0) [1,2,3] in extract s 
12:54:16 <yahb> zachk: 1
12:54:18 <zachk> like so 
12:55:00 <zachk> do I need to unwrap/runStore my s and repackage if with a new focus function to change the focus function or is there another way, also what about mutating the value where it is focused at 
12:55:04 <slaterr> is anyone familiar with a launcher program, that will 1) run my program periodically (say every 1 hour) 2) check my program for any output (stdout for normal output, and stderr for unhandled exceptions or other issues) 3) send email to predetermined addresses of both outputs, if they exist
12:55:11 <slaterr> I can do #1 with OS-specific scheduler, but I'd still want a launcher (decoupled from my main program) to do #2 and #3
12:55:18 <slaterr> sorry if this is too offtopic
12:55:59 <zachk> you could write it in haskell maybe and call it from cron or whatever the latest scheduler is, slaterr 
12:56:10 <neosimsim> have you tried cron?
12:57:07 <slack1256> zachk: Read about the ComonadStore class on Control.Comonad.Store
12:57:15 <sm> parsnip: yes what about what zachk said ?
12:57:16 <slack1256> That is how you change the focus
12:57:33 <zachk> slack1256, its not clear to me
12:57:34 <slaterr> neosimsim, I know cron can do #1, but can it do #2 and #3?
12:57:46 <Ferdirand> yes, cron can do #2 and #3
12:57:47 <slaterr> zachk that's my plan, if nothing like that exists already
12:57:53 <slaterr> oh? interesting
12:57:55 <slack1256> zachk: Let me try to craft an example
12:57:58 <Ferdirand> in fact it does by default
12:58:09 <Ferdirand> on most environments
12:58:39 <slaterr> most usually means not on windows :P 
12:59:12 <[exa]> slaterr: in the name of good engineering, any decent syslog implementation shall handle what you asked :]
12:59:35 <slaterr> [exa], perhaps, but I thought it would be good to decouple logger program from my main program
13:00:36 <[exa]> so your program is collecting stuff?
13:00:42 <slaterr> I'm curious though if there's a haskell logging library that does that all for me
13:01:05 <[exa]> (hsyslog?)
13:01:08 <slaterr> [exa], yes
13:01:29 <ineff[m]> hello everyone. I am sorry to interrupt the flow but I am having a problem with `cabal new-*` is this the right place where to ask for help?
13:01:33 <[exa]> anyway, you can always use mail-sending utils, just piping the output to sendmail is usually safest
13:01:59 <[exa]> slaterr: (imagine there's some different admin than you trying to get the program configured for his reporting setup)
13:02:11 <monochrom> Yes ineff[m]
13:05:17 <slaterr> [exa], what happens if unhandled exception crashes my haskell progrma that is using hsyslog?
13:07:33 <nyc> https://hackage.haskell.org/package/llvm-hs <-- hmm, so if you can get code to that kind of IR, then you pretty much automagically have native machine code?
13:08:22 <[exa]> slaterr: not much, syslog message will not be complete and that's pretty much it
13:08:47 <slaterr> [exa], exactly.. it won't do its job
13:09:04 <slack1256> zachk: let s = store (!! 0) [8,9,10] in extract (seek [2,3,1] s)
13:09:38 <slack1256> The CommonadStore doesn't let you change the "focus", it lets you change what are you looking at.
13:09:39 <zachk> %  let s = store (!! 0) [8,9,10] in extract (seek [2,3,1] s) 
13:09:39 <yahb> zachk: 2
13:09:55 <zachk> oh
13:10:13 <slack1256> The focus is fixed at construction
13:10:49 <slack1256> Weird, uh?
13:11:15 <zachk> yea, guess I don't really get the point of it, for now :( 
13:11:18 <slack1256> I mean you can always `runStore` and construct again.
13:11:39 <slack1256> Yeah, comonad aren't that useful, unless you are doing some kind of OO-like system
13:11:47 <zachk> yea, I remember seeing a blogpost changing the focus the other year, I guess they were using a helper function to unwrap and rewrap the store 
13:12:11 <slack1256> I guess you could define a Store where like this
13:12:36 <slack1256> let s = store ([9,10,11]) (\e -> e !! 0)
13:12:45 <slack1256> or something along the lines that typecheck
13:13:02 <[exa]> slaterr: well why would you let it produce an unhandled exception then?
13:13:18 <slack1256> there it would be possible to change the function via ComonadStore
13:14:33 <w1n5t0n> hey friends, I'm trying to make an Expr data type to be able to represent and compare simple mathematical expressions, it looks like: "data Expr a = X | Const a | Add a a | Mult a a ..."
13:14:45 <fen> there *are* actually valid defaults for when the `r' values can be unfolded; https://gist.github.com/fen-hs/0e01cf44b066804433b24a64429f2400
13:15:00 <zachk> w1n5t0n, whats X in your ADT? 
13:15:13 <w1n5t0n> X = \x -> x
13:15:46 <w1n5t0n> I'm trying to make an Eq instance that checks both arguments for equality (e.g. "Add 1 2 == Add 2 1 = True")
13:16:00 <w1n5t0n> but I find myself manually pattern matching all of the possible constructors
13:16:25 <slaterr> [exa], the whole point is to email unanticipated, unexpected errors so that they can be fixed
13:16:37 <w1n5t0n> is there a way to abstract that? The problem is that some constructors take two arguments (Add, Mult, Mod), while others take only one (Const, Negate)
13:16:43 <fen> one of the cases is unfolding a stream of streams which is pretty cool
13:17:07 <zachk> w1n5t0n, eval two ast's first, then check to see if they are equal perhaps? 
13:18:18 <w1n5t0n> zachk: can you explain that a bit more? I'm not sure I get what you mean
13:20:14 <w1n5t0n> what I have so far looks something like this: https://gist.github.com/lnfiniteMonkeys/afd922d4d86888b0231ed01234061002
13:20:41 <dmwit> w1n5t0n: It might actually be easier to write an Ord instance first. Then you can sort the two arguments to Add before comparing them.
13:21:21 <w1n5t0n> that's true, but it's not like it's too tedious to compare them when it's only two
13:21:28 <w1n5t0n> my problem is having to pattern match all possible constructors
13:21:43 <dmwit> Oh. I've just looked at your paste.
13:21:48 <nyc> Oh wow, there's a special calling convention in llvm just for ghc.
13:22:07 <w1n5t0n> for those constructors that only take one argument, I'd like to be able to say "(_ a) == (_ b) = a == b"
13:22:10 <dmwit> Here's an idea: `data UnOp = Exp | Log | Sin | Abs | ...` and `data Expr a = X | ... | UnOp UnOp (Expr a)`.
13:22:19 <dmwit> Similarly make a separate type for the binary operators.
13:22:42 <dmwit> data BinOp = Add | Mult; data Expr a = ... | BinOp BinOp (Expr a) (Expr a)
13:23:24 <dmwit> Well you also say Negate (Negate x) == x? =)
13:24:23 <dmwit> What about Cos x and Sin (Add (ConstExpr pi) x)...?
13:24:56 <w1n5t0n> good question, haven't gotten that far yet!
13:25:02 <ineff[m]> monochrom: thanks. I'm having the following issue I have just installed ghc and cabal through ghcup. After that I have tried to install the vector package via `cabal new-install --lib vector`. It seems everything works, but if now if I try to run ghci I get an error message that basically says that GHC cannot find libHSprimitive
13:25:11 <dmwit> w1n5t0n: yeah, I figured =)
13:25:52 <w1n5t0n> dmwit: I think the path of UnOp and BinOp is probably the most promising one, then UnOp can also become an instance of Functor to simplify some things (right?)
13:26:16 <dmwit> Hm? No, UnOp is an enumeration and doesn't even take a type parameter so doesn't have the right kind for Functor.
13:27:01 <w1n5t0n> oh wait, yeah I was thinking of something like "data UnOp a = UnOp (a -> a)"
13:27:16 <dmwit> Oh, right. That's a lot harder to reflect on, though.
13:27:38 <byorgey> it's also not a Functor =)
13:27:48 <w1n5t0n> yeap I just realised that too
13:28:24 <w1n5t0n> another question, why does the constructor appear twice in "UnOp UnOp (Expr a)" and "BinOp BinOp (Expr a) (Expr a)"?
13:28:46 <fen> oh no! there would be so many of the correponding types of default for Traversable... https://gist.github.com/fen-hs/6bb03486008a8a31b9edf95f8bd35f46
13:29:01 <byorgey> w1n5t0n: one is the name of a constructor of Expr, the other is the name of the enumeration data type
13:29:14 <fen> but that raises the question of if the `r' being eg, traversable as a stream slinear or stack is really possible
13:29:28 <byorgey> it might be less confusing to name them differently, like  data Expr a = ... | EUn UnOp (Expr a) | EBin BinOp (Expr a) (Expr a)
13:29:30 <fen> can `r' be anything but linear?
13:29:38 <w1n5t0n> okay I see
13:30:18 <byorgey> but they live in different namespaces so it's legal (and not uncommon) to pun on the names of such things
13:31:03 <fen> "its traversable if its made of traversable things" but there are 3 types of traversable things, and 3 types of traversable, each with corresponding foldable, thats like over 9 defaults!
13:31:10 <fen> arethey useful enough to write
13:31:12 <fen> ?
13:32:21 <fen> eg line 42 of Traversable_r.hs
13:33:01 <fen> no line 53
13:33:10 <fen> of Traversable.hs
13:33:16 <fen> https://gist.github.com/fen-hs/6bb03486008a8a31b9edf95f8bd35f46
13:34:06 <fen> there are only 9 cases for unfoldable and they are written here for comparison; https://gist.github.com/fen-hs/0e01cf44b066804433b24a64429f2400
13:35:10 <fen> "unfolding a container full of states which are then unfolded at each place"
13:35:36 <fen> again, with 3 types of unfoldable things
13:36:16 <fen> corresponding to 3 different states thatcan be unfolded as the values of 3 different types of unfoldable, giving the 9 cases
13:38:27 <fen> it might also be worth mentioning why this code is happening at all given that we have libraries which handle all such cases abstractly using continuations 
13:39:04 <fen> the idea is that when that is done, it is sometimes possible to exhaustively give all the different cases covered by that abstraction 
13:39:49 <parsnip> zachk: thank you for tip!
13:40:01 <parsnip> sm: indeed, interesting :)
13:40:01 <glguy> fen: Who are you talking to?
13:40:06 <parsnip> thanks for highlight
13:40:37 <fen> glguy: people mentioning recursion schemes or lenses as an alternative higher level approach  
13:41:13 <fen> it happens quite commonly, and thats an important justification for actually providing explicit rationalisations of the abstractions
13:41:23 <fen> realisations*
13:41:27 <glguy> fen: Like which users?
13:41:36 <zachk> parsnip, you are welcome :) alot of stuff compiles, but I have had some stuff not run on via haskell on android with the method I described, not too many though 
13:42:02 <fen> maybe some who might read the log, such as those normally working with lenses or recursion-schemes
13:42:28 <glguy> fen: For this format it could work better for you to write a blog article and share the link
13:43:15 <fen> to make the point that higher level abstractions can be completely implemented by a lower level appraoch?
13:43:21 <fen> thats said in one line!
13:43:28 <fen> hardly blog worthy
13:44:02 <fen> anyway, the paste above gives such cases for unfold, and there was a question about if it seemed useful
13:44:13 <fen> and so if it was worth doing for the traverse paste, also provided
13:45:34 <fen> "providing explicit realisations of the abstractions" is a better way to put it, like lenses or recursion-schemes
13:45:53 <fen> which are continuation based
13:56:36 <slaterr> is there a better way to do this?  map (foo . fromJust . bar) $ filter (not . null . bar) xs
13:57:32 <Clint> maybe
13:58:37 * hackage haskell-src-meta 0.8.1 - Parse source to template-haskell abstract syntax.  https://hackage.haskell.org/package/haskell-src-meta-0.8.1 (DanBurton)
13:59:06 <hpc> map (foo . fromJust) . filter (not . null) $ map bar xs -- this at least explicitly factors out the duplication of bar
13:59:43 <hpc> catMaybes might be useful here
14:00:02 <MarcelineVQ> :t mapMaybe
14:00:03 <lambdabot> (a -> Maybe b) -> [a] -> [b]
14:00:26 <byorgey> map foo . mapMaybe bar ?
14:00:46 <merijn> byorgey: or "mapMaybe (fmap foo . bar)"
14:01:12 <merijn> Bikeshed-o'clock
14:01:35 <byorgey> somehow I prefer the version that doesn't have to fmap foo, but sure, the same bikes will fit in there too =)
14:02:32 <ClaudiusMaximus> isn't bar being called at two different types there?  or is null polymorphic these days?
14:02:39 <byorgey> ClaudiusMaximus: the latter.
14:02:43 <aplainzetakind> This is a contrived simple analog for what I actually want to achieve (which I think should be impossible anyway, so just want to confirm). Say I want to handle collections of points of the integer lattice, doing things like taking unions and shifting them. I care about their diameter on the x axis, because eventually I'll shift the resulting collection to fit a certain vertical strip. I thought I 
14:02:43 <byorgey> :type null
14:02:49 <byorgey> @type null
14:02:49 <aplainzetakind> could encode the known lower and upper bounds in types, so a collection could have some type like `Col (min :: Nat) (max :: Nat)`. Then a union function could have the result type that has the minimum of the minimums as the minimum and likewise for the maximum. However, with such a setup, there would be no way to make the argument of something like `shiftX` effect a shift in the bounds of the 
14:02:50 <lambdabot> Foldable t => t a -> Bool
14:02:55 <aplainzetakind> return type of the function, right? Such a thing would completely defeat the purpose of compile-time type checking I suppose.
14:02:58 <ClaudiusMaximus> fancy :)
14:02:58 <aplainzetakind> Pff.
14:03:00 <aplainzetakind> Sorry for the wall of text.
14:03:56 <byorgey> aplainzetakind: I think you could do it with singleton types to connect the runtime argument to shiftX with the type level
14:07:07 <aplainzetakind> byorgey: What would be a good intro to their use (I don't know anything about them)?
14:08:12 <slaterr> re my earlier question (better way to write  map (foo . fromJust . bar) $ filter (not . null . bar) xs), I'm thinking I can somehow take advantage of list comprehensions Just x <- ... behavior, but I'm not sure how?
14:12:04 <Solonarv> slaterr: yes, you could write that as [ foo y | Just y <- fmap bar xs ]
14:12:42 <Solonarv> I would go with 'mapMaybe (fmap foo . bar) xs' (which was already suggested above)
14:13:04 <slaterr> oh! I missed that one
14:13:10 <slaterr> :t mapMaybe
14:13:11 <lambdabot> (a -> Maybe b) -> [a] -> [b]
14:13:32 <slaterr> nice. I did not know about that one
14:13:57 <Solonarv> it's almost tailor-made for that use case!
14:14:04 <slaterr> yes
14:14:53 <slaterr> Solonarv any reason you used fmap over map there?
14:15:21 <slaterr> in the list comprehension example
14:15:24 <Solonarv> yes: I generally prefer not using overly-monomorphic functions
14:16:14 <geekosaur> there's arguments in both directions. I tend to use more specified ones to help the type system help me.
14:17:53 <merijn> geekosaur: map doesn't type check there
14:18:01 <hpc> i just write what i think, and i always think of fmap first
14:18:02 <merijn> The fmap is over the returned Maybe
14:18:16 <hpc> since [] isn't terribly special
14:19:12 <MarcelineVQ> merijn: imagine he's asking about the comprehension
14:19:18 <Solonarv> merijn: I believe the question was about 'fmap bar xs' in the list-comprehension example I gave
14:19:21 <merijn> oh, yeah
14:19:48 <geekosaur> yeh, I didn't look that closely at it
14:29:49 <bsima> do any Num types implement Semigroup?
14:29:59 <bsima> I would think 1 <> 1 = 2
14:30:08 <c_wraith> > 1 <> 1 :: Sum Int
14:30:10 <lambdabot>  Sum {getSum = 2}
14:30:22 <c_wraith> > 2 <> 5 :: Product Int
14:30:23 <Solonarv> bsima: the problem is that there are at least two valid Semigroup instances: addition and multiplication
14:30:24 <lambdabot>  Product {getProduct = 10}
14:30:41 <Solonarv> so instead we have 'Sum' and 'Product' newtypes, which pick one
14:30:47 <bsima> why are they both valid?
14:30:48 <c_wraith> > 2 <> 5 :: Max Int
14:30:50 <lambdabot>  error:
14:30:50 <lambdabot>      Not in scope: type constructor or class ‘Max’
14:30:50 <lambdabot>      Perhaps you meant ‘M.Map’ (imported from Data.Map)
14:31:01 <merijn> bsima: They both obey the semigroup laws?
14:31:05 <c_wraith> @let import qualified Data.Semigroup as Semi
14:31:06 <lambdabot>  Defined.
14:31:10 <c_wraith> > 2 <> 5 :: Semi.Max Int
14:31:11 <lambdabot>  Max {getMax = 5}
14:31:17 <c_wraith> > 2 <> 5 :: Semi.Min Int
14:31:18 <lambdabot>  Min {getMin = 2}
14:31:21 <merijn> bsima: Hell, there's a whole bunch more valid Semigroups on numbers
14:31:26 <c_wraith> 4 instances just in base!
14:31:27 * bsima is reading semigroup laws again
14:31:33 <merijn> c_wraith: More!
14:31:40 <merijn> c_wraith: You forgot to include Dual :)
14:31:49 <c_wraith> There's also First and Last
14:31:53 <c_wraith> ...  So, a *lot* more
14:32:03 <Solonarv> Dual doesn't actually behave any differently on those 4, though
14:32:16 <Solonarv> (assuming the base type is still Int)
14:32:17 <merijn> bsima: In short, there are approximately a bazillion legal semigroups for numbers ;)
14:32:21 <phadej> GCD LCM
14:32:29 <bsima> yeah i see that now
14:33:16 <bsima> lots of ways to associate (<>) numbers together
14:33:43 <c_wraith> yeah. turns out there are a lot of associative operations on numbers. :)
14:36:35 <c_wraith> even sillier things. x <> y = x * y * 3, for instance
14:37:03 <c_wraith> that one's not a monoid, but it is a semigroup
14:37:39 <c_wraith> (so long as the type has multiplication be associative)
14:38:50 <zachk> what about something like x <> y = x + y + 4 ? 
14:39:02 <ski> works too
14:39:12 <Solonarv> semigroup-but-not-a-monoid, again
14:40:36 <ski> hm, i suppose we also require commutativity of `(*)' resp. `(+)' there
14:40:58 <c_wraith> oh, probably
14:41:46 <ski> (otherwise we don't get associativity)
14:42:29 <Solonarv> x <> (y <> z) = x * (y * z * 3) * 3; (x <> y) <> z = (x * y * 3) * z * 3; need commutativity to move the 3's around
14:44:44 <ski> i suppose with `x <> y = x * 3 * y', we don't need commutativity
14:45:22 <Solonarv> oh true!
14:46:05 * ski mumbles something about inorder traversal
15:18:27 <slaterr> what packages do you recommend for running external programs and capturing their stdout/stderr output? I found process and typed-process on hackage
15:19:02 <monochrom> I use process. Comes with GHC.
15:21:02 <Solonarv> there is typed-process which is a slightly more type-safe wrapper over it
15:21:18 <MarcelineVQ> :B
15:21:37 <slaterr> Solonarv, I'm reading its hackage page, but I'm not quite sure what they meant by that
15:22:18 <c_wraith> Mostly that the io streams have different types, they're not all just handles
15:22:28 <c_wraith> So you can't mix up which one is which
15:23:01 <Solonarv> process "start a process" functions all give you back a 'Maybe Handle', no matter what you specified for the child process' 0/1/2 handles
15:23:10 <monochrom> I think the provided examples help. Prerequisite: You can read code that uses DataKinds.
15:25:32 <monochrom> Another prerequiste: Ability to ignore "#!/usr/bin/env stack" shenenighans >:)
15:26:45 <azztex> This might be more of a C question than Haskell but I am trying something like this https://pastebin.com/dsfUkSbM
15:27:03 <azztex> despite mallocing 0 bytes
15:27:23 <azztex> I am able to write to a pointer location and get the same value back
15:27:33 <azztex> shouldn'i I be getting garbage valuee
15:27:34 <ski> that's UB, afaiu
15:30:39 <dmwit> azztex: Nobody promises that reading more than you allocated gives you garbage. You might get really good stuff, like maybe encryption keys and stuff. See: heartbleed
15:30:40 <slaterr> so is there a consensus that typed-process is better, if one doesn't have a problem the fact that it doesn't ship with ghc?
15:31:09 <ski>   "If _size_ is 0, then *malloc*() returns either NULL, or a unique pointer value that can later be successfully passed to *free*()."
15:31:58 <dmwit> c_wraith: 1/3 is a fine identity for that operation
15:32:02 <ski> (together with `mallocBytes size  = failWhenNULL "malloc" (_malloc (fromIntegral size))', that seems to imply it didn't yield `NULL' in your case)
15:33:16 <azztex> yeah it definitely doesnt yield null
15:33:51 <Zvpun>   /quit
15:33:52 <ski> dmwit : nice. doesn't exist in e.g. `Int', though (which was used in an example)
15:41:25 <d34df00d> Hi! I have a Data.Vector.Unboxed (Float, Float, Float) and I'd like to save it to a file (in the PPM format). Can I do better than https://github.com/0xd34df00d/hrt/blob/4371297e8b87ba4c902881eb28660d1d81526b61/src/Data/Framebuffer.hs#L40 ?
15:41:28 <d34df00d> The above is _slow_.
15:42:10 <d34df00d> Namely, for a vector of 1024×768 elements it takes 0.05 s of MUT time and 0.15 s of GC time, which I think is too much.
15:43:15 <Solonarv> the low-hanging fruit is "use Data.ByteString.Builder"
15:43:58 <d34df00d> Yay a chance to learn builders!
15:45:14 <d34df00d> On the other hand... Won't I end up having the same lazy list of builders internally?
15:45:31 <d34df00d> I'd expect BS.pack to do something similar.
15:47:05 <dmwit> ski: For Int, -6148914691236517205 is a fine identity for that operation.
15:47:25 <dmwit> ?check \x -> -6148914691236517205 * x * 3 == (x :: Int)
15:47:27 <lambdabot>  +++ OK, passed 100 tests.
15:47:37 <monochrom> You're using the strict Bytestring. I wonder if switching to the lazy ByteString makes a difference.
15:48:06 <monochrom> > -6148914691236517205 :: Int
15:48:07 <lambdabot>  -6148914691236517205
15:48:30 <hpc> > -6148914691236517205 * 3
15:48:32 <lambdabot>  -18446744073709551615
15:48:36 <dmwit> Good thought, but the funny business is elsewhere, deep in the structure of the universe.
15:48:38 <hpc> > -6148914691236517205 * 3 :: Int
15:48:40 <lambdabot>  1
15:48:43 <monochrom> This is like someone's lucky number since a few days ago.
15:48:43 <Solonarv> if you're creating a ByteString to pass to further functions, perhaps
15:48:49 <hpc> nice overflow
15:49:08 <Solonarv> but if you're shoving it into a file, Builder can write to the file handle directly
15:49:16 <dmwit> It's more obvious what's going on if you write it in binary. 0b1010101010101...11
15:49:18 <d34df00d> I'm just BS.writeFile'ing it, indeed.
15:49:22 <d34df00d> So that makes sense I guess...
15:49:37 * hackage fltkhs 0.7.0.0 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.7.0.0 (deech)
15:49:38 <dmwit> > 0b1010101010101010101010101010101010101010101010101010101010101011 * 3 :: Int
15:49:40 <lambdabot>  error:
15:49:40 <lambdabot>      Variable not in scope:
15:49:40 <lambdabot>        b1010101010101010101010101010101010101010101010101010101010101011
15:49:45 <dmwit> Oh, yeah.
15:49:49 <dmwit> % :set -XBinaryLiterals
15:49:50 <yahb> dmwit: 
15:49:55 <dmwit> % 0b1010101010101010101010101010101010101010101010101010101010101011 * 3 :: Int
15:49:55 <yahb> dmwit: ; <interactive>:9:1: warning: [-Woverflowed-literals] Literal 12297829382473034411 is out of the Int range -9223372036854775808..9223372036854775807; 1
15:50:40 <hpc> heh, you have to two's complement it yourself
15:50:46 <dmwit> Just think about adding that number to 2*that number.
15:51:08 <ski> dmwit :)
15:51:26 <d34df00d> Solonarv: thanks, that was a very fruitful idea! I have used strict bytestrings, and after trying with the builders I've also tried with just constructing lazy BS directly (akin to my original option) — the speed is just the same as with builders, with no GC overhead, and maybe 0.04 s in MUT (which is tolerable I think).
15:51:31 <monochrom> Oh neat hPutBuilder
15:51:55 <Solonarv> yes, hPutBuilder is the "exactly right" approach for this
15:52:03 <dmwit> (That is actually how I came up with it. I wrote down 0wxyz+wxyz0 = _0001 and worked out what the digits had to be.)
15:52:40 <Solonarv> for larger / more complex stuff you might actually see a difference
15:53:10 <monochrom> Haha great Data.ByteString.Lazy.Builder = Data.ByteString.Builder.  Bikeshed solved.
15:53:24 <Welkin> hold on
15:53:32 <Welkin> what about Data.Binary.Builder !
15:53:51 <Solonarv> yes, you could use binary too
15:54:04 <Welkin> no I meant what's the difference?
15:54:11 <Welkin> I have used all of these interchangeably I think
15:55:37 * hackage fltkhs-themes 0.1.0.2 -   https://hackage.haskell.org/package/fltkhs-themes-0.1.0.2 (deech)
15:55:58 <monochrom> Perhaps just historically the builder idea appeared in Binary before appearing in ByteString.
15:57:00 <Solonarv> oh, I have no idea what the difference is.
15:57:28 <MarcelineVQ> when did vector builders show up I wonder, think they call them bundles
15:57:44 <MarcelineVQ> when compared to bytestring and/or binary I mean
15:58:01 <c_wraith> dmwit, hmm, yes. apparently arithmetic is hard.
15:58:31 <Solonarv> the Vector / Bundle stuff is even more complicated because it juggles like 4 different implementations
15:58:41 <Solonarv> * representations
16:05:28 <d34df00d> Haha passing a handle and writing the builder to it is even less efficient (more GC for some reason).
16:16:36 <d34df00d> Uh. What's a reasonable prelude with a reasonable numeric typeclass hierarchy?
16:16:43 <d34df00d> abs for my vectors doesn't make sense.
16:16:54 <d34df00d> No subhask pls!
16:17:08 <slack1256> What fpcomplete uses
16:17:16 <d34df00d> How do I know what they use?
16:17:21 <slack1256> google
16:17:40 <slack1256> but I would also look for the `vector` or lineal-algebra package of ekmett
16:17:57 <slack1256> there are defined norms for the vectors on there
16:18:02 <slack1256> oh and hmatrix
16:18:17 <slack1256> @whereis linear
16:18:17 <lambdabot> Maybe you meant: where+ where
16:18:19 <slack1256> @whereis lineal
16:18:19 <lambdabot> Maybe you meant: where+ where
16:18:27 <slack1256> @where lineal
16:18:27 <lambdabot> I know nothing about lineal.
16:18:29 <slack1256> @where linear
16:18:29 <lambdabot> I know nothing about linear.
16:18:33 <slack1256> >:-(
16:18:36 <d34df00d> http://hackage.haskell.org/package/linear-1.20.8/docs/Linear-V3.html
16:18:39 <d34df00d> Yay lenses.
16:19:35 <Solonarv> you don't have to use them, you can just pattern-match
16:20:30 <Solonarv> but also, basic lens usage is really simple: 'thing ^. lens' to get, 'thing & lens .~ val' to set, 'thing & lens %~ func' to modify
16:21:37 <slack1256> Also, learning the non-operator names: view, set, over, preview is good
16:21:44 <d34df00d> The problem I have with lenses is the lack of discoverability.
16:22:28 <d34df00d> A lot of times I've found myself knowing that a certain thing exists, but the huge amount of modules along with not-google-friendly naming makes it hard to find them both by a quick signature search and by a reasonable guess at names.
16:24:15 <glguy> A lot of the lens package is particularly discoverable because so much of it is generalizations of things you might already know about it where the thing you know about is suffixed with -Of
16:24:50 <d34df00d> Maybe I just don't have enough experience with it.
16:24:50 <glguy> A lot of my use of lens is tab completion in GHCi to see if the thing I want has a lens generalization
16:25:18 <d34df00d> Definitely worth playing around some more. But, for now they rather scare me than give a productivity boost.
16:28:37 * hackage fltkhs 0.7.0.1 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.7.0.1 (deech)
16:36:37 * hackage fltkhs-themes 0.1.0.3 - A set of themed widgets that provides drop in replacements to the ones in FLTKHS.  https://hackage.haskell.org/package/fltkhs-themes-0.1.0.3 (deech)
16:37:04 <bsima> i'd like to serialize a (HashMap ByteString ByteString) to a simple json map, can Aeson do this?
16:37:22 <Welkin> just use toJSON
16:37:38 <Solonarv> actually, ByteString doesn't have a toJSON instance
16:37:53 <Solonarv> there might be a base64 newtype somewhere
16:37:54 <Welkin> it should just be `id`
16:38:06 <Welkin> oh, I do remember running into this
16:38:21 <bsima> right its the missing instance i'm running into
16:38:32 <Solonarv> no, it is not 'id' - BS.pack [0] is not a valid JSON key!
16:39:03 <Welkin> I don't see why this is such an issue in haskell
16:39:09 <bsima> i'm okay with that as a work around
16:39:09 <Solonarv> it might be with some conversion (escaping) but that's not id
16:39:09 <Welkin> string handling is the biggest issue for me personally
16:39:34 <Welkin> in other language (erlang for example) binaries(bytestrings) are happily transformed to and from json no problem
16:39:45 <inkbottle> stack build 2>&1 | less # How do I keep my colored output?
16:39:55 <Solonarv> it is a little annoying, but not treating text and bytestrings interchangeably is not a mistake
16:40:10 <slack1256> inkbottle stack build 2>&1 | less -R
16:40:22 <Solonarv> oh yes, the lack of aeson instances for bytestrings is a bit annoying
16:40:42 <inkbottle> slack1256: yes, doesn't seem to work on my side
16:41:17 <bsima> i guess i could just encode it as Text
16:44:20 <slack1256> inkbottle: try $ echo perro | grep --color=always | less -R
16:45:26 <Welkin> try that one `kill` command I copied and pasted from the postgres docs to stop my postgres instance, which instead crashed my computer
16:46:24 <monochrom> What would an aeson instance for bytestring do?  To and from base64 text?
16:46:38 <Solonarv> I don't know! perhaps that's why there isn't one
16:46:45 <Welkin> no
16:46:46 <inkbottle> slack1256: echo perro | grep --color=always '.*' | less -R # that does work
16:46:48 <Welkin> it is already a bytestring
16:46:51 <Welkin> just `id`
16:47:02 <Welkin> the problem is even if you know the data is valid, the type system doesn;t
16:47:07 <Welkin> and trying to teach it will be painful
16:47:09 <slack1256> inkbottle: try $ echo perro | grep --color=always perro | less -R
16:47:23 <slack1256> then less -R is not the problem
16:47:28 <monochrom> This sounds like SQL injection all over again.
16:47:41 <slack1256> maybe stack is detecting that is being pipes and supress the ANSI color codes
16:47:43 <Solonarv> aeson's internal representation for a json object is HashMap Text blah, and for a string value it's a Text
16:47:44 <Welkin> monochrom: not even close
16:47:57 <Welkin> Solonarv: not for Encoding
16:48:00 <inkbottle> slack1256: yes, might be
16:48:02 <Welkin> that is just a ByteString
16:48:09 <monochrom> Whoever that makes a big fuzz out of it is making a pretty specialized niche use case a big fuzz like it should be inflicted on the rest of us.
16:48:29 <inkbottle> slack1256: git does that
16:48:34 <slack1256> I don't know how they do it, but I know grep does it unless you use --color=always
16:48:44 <MarcelineVQ> tried stack --color always ?
16:48:52 <inkbottle> ;)
16:48:59 <Welkin> or try rm -rf $(which stack)
16:49:34 <monochrom> One day I may like to have my idea of aeson instance for bytestring, but it still won't be json injection thank you very much please don't standardize it and please don't make it sound like a good standard thanks but no thanks.
16:50:10 <inkbottle> MarcelineVQ: stack build --color=always 2>&1 | less -r # does work ;)
16:50:22 <Welkin> ByteString <-> Text is a linear operation that involves copying all of the memory
16:50:32 <Welkin> which is annoying and unnecessary in some cases
16:50:50 <monochrom> To be sure the irony is that JSON itself was born of javascript injection. Someone said "let's just call eval".
16:51:09 * slack1256 doesn't know stack 
16:51:25 <monochrom> Yeah, stack1256 would know stack.  <duck>
16:51:26 <Welkin> I would prefer to send s-expressions insteado f json
16:51:53 <Solonarv> if you control both ends you can Just Do That (tm)
16:51:56 <Welkin> but these days we have better options anyway
16:52:01 <Welkin> protocol buffers is one example
16:52:03 <Welkin> binary formats
16:52:06 <bsima> my ToJSON ByteString instance is just "Aeson.String . Text.encodeUtf8"
16:52:12 <slack1256> monochrom: 6/10 points
16:52:29 <bsima> er, "Text.decodeUtf8"
16:52:49 <Welkin> json should only be used at the interface between your system and the outside world
16:52:54 <Welkin> internally you can use protobuf
16:52:56 <monochrom> Do you know that your ByteString content is valid UTF-8?
16:53:20 <dh_work> just use ASN.1
16:53:24 <monochrom> Internally I use my own algebraic data type thank you very much.
16:53:26 <dh_work> problem solved
16:53:36 <Welkin> monochrom: to communicate between network services?
16:53:36 * dh_work whistles innocently
16:53:53 <monochrom> Sorry you call that "internal"?
16:53:57 <Welkin> yes
16:54:00 <Welkin> internal network
16:54:05 <dh_work> microservices are all the rage
16:54:29 <dh_work> anyhow, I have a wee problem: I tried to create a cabal sandbox according to the directions for some research code I'm trying to use
16:54:39 <bsima> monochrom: yeah, its just really simple CSV fields
16:54:42 <Welkin> dh_work: don't use cabal sandbox
16:54:45 <dh_work> and it tried to install Cabal (are cabal and Cabal different?) and it failed with a parse error
16:54:51 <Welkin> use `cabal new-build`
16:55:03 <bsima> monochrom: i don't need a lot of safety, this is just an interanl tool
16:55:06 <Welkin> also install a new version of cabal
16:55:13 <Welkin> which version are you on?
16:55:18 <MarcelineVQ> Cabal is a library, the cabal executable is from the package cabal-install
16:55:30 <dh_work> what ubuntu shipped me, which is 1.22.6.0
16:55:35 <dh_work> the failing Cabal is 2.something
16:55:35 <Welkin> very old
16:55:38 <Welkin> 3 years old
16:55:39 <monochrom> That's pretty old.
16:55:42 <dh_work> 2.4.1.0
16:55:45 <dh_work> yeah not surprising for ubuntu
16:55:48 <Welkin> install new cabal
16:56:08 <Solonarv> (how? use ghcup!)
16:56:17 <Solonarv> (that also gets you an up-to-date ghc)
16:56:30 <Solonarv> @where ghcup
16:56:30 <lambdabot> I know nothing about ghcup.
16:56:34 <dh_work> I don't have any idea how all this crap works :-) I last used ghc in about version 6.8
16:56:34 <Welkin> '(you forgot to quote your s-exp)
16:56:43 <monochrom> I'm OK with staying with ubuntu's cabal, on which sandboxing is likely a right thing to do.
16:56:45 <Welkin> https://github.com/haskell/ghcup
16:56:48 <Welkin> ghcup is pretty cool
16:56:51 <Welkin> I haven't used it myself
16:56:55 <Solonarv> @where+ ghcup https://github.com/haskell/ghcup
16:56:56 <lambdabot> Okay.
16:57:02 <Welkin> but it looks like a good laternative to haskell platform
16:57:19 <dh_work> also this code is from 2014
16:57:26 <slack1256> let the sir/madam stay on their distro cabal, it works for him/her.
16:57:27 <dh_work> so if I get the latest ghc it probably won't build
16:57:35 <Welkin> new cabal figures out dependencies for you
16:57:38 <dh_work> slack: it does not work, is the problem
16:57:39 <Welkin> so you don't get cabal hell
16:57:57 <monochrom> sandboxing still doesn't get cabal hell
16:58:27 <dh_work> the directions say to do "cabal install gtk2hs-buildtools"
16:58:41 <dh_work> apparently that depends on Cabal-2.x, and that doesn't build
16:59:19 <Welkin> right, because it is fetching the latest version
16:59:26 <Welkin> probably
16:59:34 <Welkin> those instructions sound bad
16:59:39 <monochrom> I think now you're looking at old code needing some work to become compatible with new tools and libraries.
16:59:39 <dh_work> it fails with a silly parse error that I might be able to patch around, but I'm not sure where it's hiding the source it's building
16:59:49 <dh_work> and it's probably only the tip of the iceberg
16:59:56 <dh_work> monochrom: yes
17:00:02 <dh_work> but it hasn't even got to failing on their code yet
17:00:03 <monochrom> But if it's old code, maybe you can manually tell it to go for old gtk2hs-buildtools version.
17:00:05 <Welkin> time warp back to 2014 and then run the compiler
17:00:20 <dh_work> I probably can, if I knew how to do that
17:00:24 <Solonarv> no need to time warp, ghcup should be able to fetch older ghcs as well
17:00:31 <Solonarv> and cabal-install is backwards compatible
17:00:36 <dh_work> no man page for cabal
17:01:12 <monochrom> cabal install xxx-0.2.0.3
17:01:55 <monochrom> This is going to be a rabbit hole whether you use older tools and libraries or today's tools and libraries.
17:02:18 <dh_work> yes, quite likely
17:02:18 <monochrom> If older, you may also have to switch to older GHC, older this, older that...
17:02:25 <dh_work> I can beat on their code if necessary
17:02:31 <monochrom> If newer, you will have to modify this codebase.
17:02:34 <dh_work> it's a bit different when the infrastructure tanks :-)
17:03:01 <dh_work> ok, I got a gtk2hs-buildtools that doesn't trigger this issue
17:03:33 <dh_work> since it nicely listed the possible versions for me when I asked for a nonexistent one.
17:03:45 <dh_work> could readily name some other package tools that suck more :-)
17:04:19 <Welkin> why were v1-/v2- added to cabal anyway?
17:04:26 <Welkin> who would type that over new-?
17:04:33 <Welkin> that is much harder to type
17:04:36 <monochrom> There is --dry-run so you can preview without damage.
17:04:37 <MarcelineVQ> because new wasn't extensible I guess
17:04:50 <MarcelineVQ> newer newerer newererer
17:04:53 <Welkin> about about no prefix?
17:05:05 <Welkin> deprecate the old commands and replace them with the new ones
17:05:14 <Solonarv> yes, that is the plan for cabal 3.0
17:05:24 <monochrom> Yeah someone learned from the "HD", "full HD", "UHD", "what will you call the next one now?" fiasco.
17:05:30 <Solonarv> and you already get a warning when you use un-prefixed v1 commands
17:05:31 <glguy> ng-build
17:05:41 <MarcelineVQ> I'd call the next one brondo
17:05:52 <Welkin> glguy: google is so lazy they just left ng- everywhere
17:05:56 <Welkin> it's all over angular
17:06:21 <Welkin> when is cabal 3 coming out?
17:06:43 <monochrom> When the ice sheets melt.
17:06:54 <slack1256> So soon?
17:06:56 <Welkin> I didn't say half-life 3
17:07:09 <Welkin> also the ice sheets are already melted
17:07:10 <Welkin> a lot
17:07:32 <dh_work> yeah it didn't get much further
17:07:47 <dh_work> now it's refusing to build its own library because of a version conflict of some kind
17:07:54 <dh_work> ls
17:07:56 <dh_work> oops
17:08:11 <monochrom> You may have to specify an older version number for the library too.
17:08:33 <monochrom> Anyway there is a --constraint (or it is constraints?).
17:08:37 <Welkin> there should be version bounds in the .cabal file
17:08:44 <Welkin> or even a cabal freeze file
17:08:46 <monochrom> "cabal install --help" is going to be your man page.
17:09:14 <Welkin> also using cabal new-build shouldn't have that issue
17:09:21 <Welkin> did you try that?
17:09:54 <dh_work> yeah there's 11 .cabal files in this tree and afaict they all say base >=4.6 && <4.8
17:10:12 <Welkin> base is not likely the issue
17:10:42 <dh_work> base is the immediate issue, it rejects because base is 4.8.2.0
17:10:56 <Welkin> then your ghc is too new
17:11:01 <Welkin> have to go back further in time
17:11:02 <monochrom> You have to gamble for that one.
17:11:12 <Welkin> or just bump all the base constraints to 4.8.2.0
17:11:18 <dh_work> that was what I was thinking
17:11:25 <Welkin> hell
17:11:25 <monochrom> Use an older GHC. Or, change 4.8 to 4.9 and hope it's harmless.
17:11:32 <Welkin> you can probably safely go to 4.9
17:11:55 <dh_work> average code is reasonably likely to work with newer stuff
17:12:09 <dh_work> the chances of getting an older ghc to run are not high
17:12:13 <monochrom> To make that gamble safe and backtrackable, now you need a transactional file system!
17:12:18 <Welkin> try ghc 1.0
17:13:06 <monochrom> Please don't be ridiculous. GHC 1.0's base is much less than 4.6.
17:13:28 <monochrom> Probably not even any notion of "base" or "package" at all.
17:13:35 <Welkin> but, but, it's all about that base!
17:13:53 <dh_work> none of this really existed yet when I last used ghc, and that was ghc 6.x
17:14:11 <monochrom> Look I would be very happy that you churn out more of these ridiculous distracting advice so you lose credibility.
17:14:14 <Welkin> dh_work: the whole ecosystem has changed drastically even in the last couple years
17:14:35 <dh_work> yeah so I've heard
17:14:41 <Solonarv> usually going from ghc x.y -> ghc x.(y+2) will make base go a.b -> a.(b+1)
17:14:47 <Solonarv> at least recently-ish
17:15:49 <dh_work> I got severely disenchanted after a dismal 40000-line project and fled to ocaml
17:16:01 <dh_work> so you're welcome to mock :-)
17:16:02 <Welkin> 40k loc haskell?
17:16:04 <dh_work> yes
17:16:08 <dh_work> "dismal"
17:16:12 <Welkin> and you fled to ocaml!?
17:16:21 <Welkin> did your eyes survive?
17:16:23 <monochrom> What happened?
17:16:47 <Welkin> I bet there were too many typeclasses
17:16:49 <Welkin> typeclass abuse
17:16:52 <Welkin> and TH
17:17:03 <dh_work> well, it was partly just a large project
17:17:16 <Welkin> today the issue is type-level programming abuse (and including every extension that exists in ghc)
17:17:36 <dh_work> partly I was unable to get various abstraction mechanisms to do what they were supposed to do to avoid lots of cutpaste
17:18:09 <Welkin> I've never worked on a haskell codebase that large
17:18:17 <dh_work> (neither I nor various more experienced folks)
17:18:18 <Welkin> I don't think I've even cracked 10k loc in haskell for one project
17:18:26 <Welkin> but then again I write them all by myself
17:18:30 <MarcelineVQ> dh_work: well once you get going feel free to ask here about things you get stuck on
17:18:31 <dh_work> I wrote that all myself
17:18:39 <Welkin> the largest codebase I have ever written myself is 14k loc in elm
17:18:39 <dh_work> it was dismal
17:18:48 <Welkin> which was easy of course
17:19:31 <dh_work> it was a compiler; the main problem was that there were like 8-10 layers of IR
17:19:38 <Welkin> I don't think I've even seen a haskell codebase that large
17:19:38 <dh_work> (almost all of which were needed)
17:19:42 <Welkin> okay
17:19:52 <dh_work> none of them were simple
17:19:54 <Solonarv> 8-10 layers of IR? not even GHC uses that many!
17:19:59 <Welkin> '(besides ghc of course)
17:20:17 <dh_work> could probably have done without a couple of them
17:20:30 <dh_work> it was also graph stuff for which haskell was a poor choice in the first place
17:20:33 <Solonarv> ghc has like 4 - parsed haskell, core, stg, c--
17:20:56 <Welkin> something sounds wrong
17:21:10 <monochrom> Yeah I think I see, can't be helped. GHC with 4 is already a jungle.
17:21:18 <Welkin> the Elm compiler is less than 20k loc (not including comments/blank lines)
17:21:21 <dh_work> anyway the result was a lot of cutpaste or not-quite-cutpaste between the layers
17:21:23 <Welkin> I just checked it myself with tokei :D
17:21:28 <Welkin> my favorite new cli tool
17:21:41 <dh_work> 40k is wc -l (and an estimate, I forget the exact size, it was years ago)
17:21:47 <Solonarv> out of curiousity, what sort of language were you compiling?
17:22:06 <dh_work> graph processing/query language
17:22:33 <dh_work> so it was first compiling graph stuff to relations and then compiling relations to query plans
17:22:35 <Welkin> you mean gremlin?
17:22:39 <monochrom> To be sure, it can be helped if you can find some way to eliminate some of the IR's
17:22:45 <dh_work> somewhat like gremlin yeah
17:23:13 <Solonarv> in modern Haskell you could also share the same AST type between at least some of these IRs
17:23:29 <Solonarv> GHC does this for at least parsed haskell & core, IIRC
17:23:47 <Welkin> what is the "Spineless-Tagless G-machine" anyway?
17:24:01 <Solonarv> amusingly enough, a graph reduction thing
17:24:15 <dh_work> hmm, actually quite a bit like gremlin
17:24:31 <Welkin> I was just reading this dh_work so why not just use gremlin?
17:24:43 <Welkin> someone wrote gremlin bindings for haskell
17:24:54 <dh_work> more like cypher than gremlin
17:24:56 <Welkin> oh, this was like a decade ago right?
17:24:59 <dh_work> yeah
17:25:12 <monochrom> Yeah the GHC people try very hard to have type-parameterized AST types so at least "AST that has line numbers" vs "AST that has another decoration" is merely "AST LineNumber" vs "AST SomethingElse".
17:25:36 <dh_work> monochrom: some stuff like that would have helped me had I thought if it beforehand
17:25:50 <monochrom> It is easier said than done!
17:26:10 <Solonarv> GHC didn't use that approach right from the beginning (obviously - it wasn't always possible!)
17:26:21 <dh_work> anyway the project ultimately got cancelled
17:26:28 <Welkin> I never realized how good the errors are from ghc (and elm) until I got to experience the pain of a language without a type system again (hello giant stacktraces with the relevant information buried hidden somewhere)
17:26:45 <Solonarv> ghc errors are okay but like
17:26:49 <Solonarv> have you seen rust errors
17:26:50 <Welkin> I was reading this http://www.aosabook.org/en/ghc.html
17:27:04 <Welkin> Solonarv: have you seen elm errors?
17:27:09 <Welkin> they are the best
17:27:15 <dh_work> I've found ocaml's type errors to be significantly more comprehensible than ghc's, not sure why since they're much the same
17:27:18 <Solonarv> I have not; never used elm
17:27:19 <MarcelineVQ> with https://www.microsoft.com/en-us/research/uploads/prod/2016/11/trees-that-grow.pdf being the modern ast direction, afaik
17:27:20 <Welkin> similar to rust errors as far as I see
17:27:29 <Solonarv> dh_work: IIRC ghc errors used to be way worse
17:27:35 <dh_work> at least when ocaml actually produces a message and not "(null)" :-)
17:27:37 * hackage language-asn 0.1.0.0 - ASN.1 encoding and decoding  https://hackage.haskell.org/package/language-asn-0.1.0.0 (chessai)
17:27:42 <dh_work> oh quite likely
17:28:31 <dh_work> anyway there were several things that made me pick non-haskell for the next project
17:28:41 <Welkin> or actually worst of all is no errors and silent runtime failure
17:28:55 <dh_work> probably the biggest one was repeatedly having to change non-monadic code to monadic, which means retyping all the syntax
17:29:08 <Welkin> dh_work: use picolisp!
17:29:19 <Welkin> it has a built-in datalog query interface
17:29:26 <Welkin> and a cool name
17:29:44 <Welkin> I wonder if anyone uses esolangs in production
17:29:50 <Welkin> like mercury (haskell + prolog)
17:30:13 <dh_work> probably depends what you mean by production
17:30:34 <Solonarv> is dhall an esolang?
17:30:40 <Welkin> there are so many programming languages today it's overwhelming
17:30:43 <hpc> it's a DSL
17:30:44 <Welkin> I'd say yes Solonarv 
17:30:55 <Solonarv> then yes! there are a few companies using it
17:31:01 <Solonarv> let me see if I can dig up a link
17:31:17 <Welkin> even for embedded scripting languages you have a lot of options
17:31:40 <Welkin> the coolest is gluon (HM type system, ML-style syntax, written in rust)
17:32:07 <Welkin> you eve have staticaly-typed lisps with linear types
17:36:30 <Solonarv> I found this: https://github.com/FormationAI/dhall-bhat
17:36:45 <Welkin> sounds indian
17:37:10 <Solonarv> I'm pretty sure they actually use dhall (which is why they wrote this library) in production somehow but I was too lazy to find out how exactly
17:37:27 <Solonarv> yes, it's an indian (food?) pun?
17:37:36 * Solonarv speaks no indian
17:38:19 <Welkin> haha
17:38:23 <Welkin> dhall is an indian food
17:38:26 <Welkin> figures
17:38:39 <dh_work> it's not "dining hall"? ;-)
17:40:17 <ski> (hm, i thought "dhall" was from a well-known RPG)
17:40:37 <ski> (but i suppose they could have gotten it from somewhere else ..)
17:40:48 <Welkin> quote your s-ecps!
17:40:51 <Welkin> quote your s-exps!
17:41:09 <Welkin> '(quote your s-exps!)
17:41:12 <Welkin> '(I mean)
17:41:14 <ski> this is data, not code :)
17:47:07 * hackage snmp 0.3.0.0 - SNMP protocol library  https://hackage.haskell.org/package/snmp-0.3.0.0 (chessai)
17:50:02 <dh_work> ugh, version conflict on template-haskell
17:50:08 <dh_work> I kinda don't think this is going to work.
17:50:28 <Solonarv> TH version is also tied to GHC version
17:50:39 <Welkin> code rot
17:50:55 <dh_work> I told it to accept the version I've got, but I suspect it'll choke
17:50:56 <Welkin> it's worse because ghc changes rapidly
17:51:11 <dh_work> also it's annoying how long this deps phase takes
17:51:56 <Welkin> 1 fish, 2 fish
17:52:00 <Welkin> 3 fish, blue fish!
17:52:17 <blue-fish> :D
17:57:34 <aquarial>  
18:03:37 * hackage irc-core 2.6.0 - IRC core library for glirc  https://hackage.haskell.org/package/irc-core-2.6.0 (EricMertens)
18:04:37 * hackage glirc 2.30 - Console IRC client  https://hackage.haskell.org/package/glirc-2.30 (EricMertens)
18:07:07 * hackage conduit-extra 1.3.1 - Batteries included conduit: adapters for common libraries.  https://hackage.haskell.org/package/conduit-extra-1.3.1 (MichaelSnoyman)
18:39:32 <rprije> I have a haskell program attempting to build on Nix and cross-compiling targetting android. It depends on JOSE. Compilation is blowing up with a ghc panic (Index out of range). Can anyone recommend how to go about debugging an error like this?
18:44:10 <blue-fish> convince jose to do it for you
18:53:36 <dh_work> so yeah, unsurprisingly, after finally dealing with all the deps complaints, this thing does not begin to build 
18:54:06 <dh_work> Ambiguous occurrence 'die'
18:54:08 <dh_work> ... in glib
18:54:28 <dh_work> WE MUST DIE IN ONLY THE APPROVED MANNER
18:55:42 <dh_work> elsewhere it objects to <> not being in scope deep in the middle of a prettyprinter full of linenoise operators
18:58:37 <dh_work> the type signature is "AST Doc Doc Doc -> Doc"
18:58:40 * dh_work boggles
18:58:53 <dh_work> ok I give up
18:58:58 <dh_work> I have no idea what this was supposed to do
19:01:11 <dh_work> also, if it's complaining about errors in a file it's unpacked (from upstream I guess) into /tmp, is there any way to patch the file?
19:02:07 <Solonarv> yes: fork it and point cabal at the fork (much easier with an up-to-date cabal)
19:02:14 <Solonarv> which package are you trying to build, btw?
19:03:28 <dh_work> overall, or the upstream one that's failing?
19:03:42 <dh_work> overall is termite2, the device driver synthesis thing from unsw
19:03:59 <dh_work> the offending upstream packages are cairo and glib, both with the same error about die
19:06:25 <Solonarv> that doesn't seem to be a haskell package?
19:10:49 <jackdk> dh_work: I only just joined. what package are you trying to build?
19:13:22 <dh_work> solonarv: which?
19:13:30 <dh_work> it's using haskell cairo and glib2 bindings of some kind
19:14:25 <dh_work> jackdk: https://github.com/termite2/Termite/
19:20:47 <jackdk> that looks like a more complicated build system than I'm prepared to dig into on my lunch break, sorry
19:21:21 <dh_work> it's mostly a cabal sandbox
19:21:35 <dh_work> but it's a large number of moving parts and they are all bitrotten
19:25:16 <dh_work> it's about 35k lines of haskell
19:25:31 <dh_work> there's also 120k lines of C in there but it built fine
19:40:46 <jgt> how do I print a Double to a varying amount of precision? i.e., I'd like to turn `15.0` into "15", `5.5` into "5.5", and `3.765` into "3.765"
19:42:57 <glguy> DigitalKiwi: This one's for you: https://github.com/glguy/irc-core/commit/d8cb59f71ec09e0be1d400125575349497e7fc55
19:43:49 <glguy> jgt: How's this look? http://hackage.haskell.org/package/base-4.12.0.0/docs/Numeric.html#v:showFFloat
19:46:32 <jgt> > showFFloat (Just 2) (15.0 :: Double) ""
19:46:33 <lambdabot>  "15.00"
19:46:43 <jgt> glguy: not quite right, unless I'm using it wrong
19:47:08 <glguy> OK, I don't know what you want then
19:47:18 <jgt> :/
19:47:18 <glguy> What's the specification you're trying to achieve?
19:47:42 <jgt> I thought my question was quite well formed. I want `15.0` printed as "15"
19:47:55 <jgt> and `15.5` as "15.5"
19:48:19 <kadoban> jgt: Not really clear what logic you want to decide the number of digits shown
19:48:27 <c_wraith> Do you want java's logic for printing doubles?
19:48:40 <c_wraith> that is, shortest decimal representation that leads to the same bit pattern?
19:48:51 <jgt> kadoban: If the next string of numbers are all zeroes, they can be truncated
19:49:02 <jgt> c_wraith: that sounds like what I want
19:49:07 <jgt> (never written any Java though)
19:49:20 <c_wraith> I don't know of any function that does that, but at least it's a specification
19:49:25 <jgt> kadoban: I use the word "string" here not in the programming sense
19:49:41 <kadoban> The thing with floats is, they're usually not all zeros. There's zeros with a spurious 1 somewhere in there. Yeah there's an algorithm for it, but I don't know where it lives in haskell myself
19:49:50 <DigitalKiwi> glguy: haha nice thanks
19:50:07 <monochrom> Pretty sure you have to code it yourself.
19:50:35 <kadoban> That's a little unfortunate. No library either? I wonder if I could throw a crude one together ...
19:51:02 <geekosaur> hm. the docs for both showFFloat and showGFloat imply they should do that (but do no more than imply, and the current behavior does fit the spec)
19:51:27 <geekosaur> (no, showGFloat doesn't either)
19:52:14 <geekosaur> presumably so an impl can use snprintf
19:52:53 <kadoban> I think I remember seeing a paper on how that's done for real. I wonder how hard it actually is ... edge cases are probably murder.
19:53:48 <geekosaur> if you just lop off trailing zeroes until a decimal point (and use the original if you don't hit one), you have the ...Alt versions
19:55:23 <kadoban> https://www.cs.indiana.edu/~dyb/pubs/FP-Printing-PLDI96.pdf looks possible, from a quick skim
19:55:45 <kadoban> If I can't find a library later, I'll probably implement one myself.
19:56:00 <monochrom> showFFloat omits the . when and only when showFFloat (Just 0).  But then it also means round to nearest integer, always.
19:58:16 <monochrom> I would say that showGFloat giving you "5.0" is right because its default (i.e., when Nothing) needs to be consistent with show, and show needs to mimic Haskell literals.
19:58:18 <jgt> here's a naïve implementation. How will this explode in my face?
19:58:23 <jgt> reverse . dropWhile (\c -> c =='0' || c == '.' ) $ reverse $ showFloat (15.765 :: Double) ""
19:59:55 <monochrom> Consider what happens to 1e7
20:00:35 <monochrom> Besides, showFloat x "" is just show x
20:01:45 <jgt> monochrom: I see. Good point. I could test that the value is between 0 and 100 (I'm trying to show percentages here), and return a Maybe
20:02:45 <monochrom> Then you're in good shape.
20:03:17 <jgt> ಠ_ರೃ
20:12:05 <jgt> ended up with this: http://ix.io/1Bs5
20:14:56 <dmwit> > let f x = reverse $ case reverse (show x) of '0':'.':rest -> rest; rest -> rest in map f [15, 15.5, 15.765]
20:14:58 <lambdabot>  ["15","15.5","15.765"]
20:15:01 <dmwit> > let f x = reverse $ case reverse (show x) of '0':'.':rest -> rest; rest -> rest in map f [15, 15.5, 15.765, 1e7]
20:15:03 <lambdabot>  ["15","15.5","15.765","1.0e7"]
20:16:06 <dmwit> jgt: I... don't think your implementation is a good idea.
20:16:18 <dmwit> jgt: showPercent 90 = Just "9"...?
20:17:41 <dmwit> Better to check for exactly the suffix ".0" and throw only that away (as I did above). Maybe even then it will blow up in your face, though I can't think of how.
20:18:57 <jgt> ah, yes
20:19:30 <c_wraith> split on '.', process the second half only
20:24:24 <dmwit> c_wraith: Even that will probably blow up in your face.
20:24:40 <dmwit> Depending on how you do it, exactly.
20:24:57 <dmwit> e.g. it would be wrong to throw away the final 0 in 1.1e10 just because it came after a .
20:30:00 <geekosaur> only if you start from showGFloat; showFFloat never produces that
20:30:52 <dh_work> it sounds like what's wanted is the default behavior of %g, which I presume is showGFloat
20:31:21 <geekosaur> except showGFloat doesn't suppress trailing zeros in decimal format
20:31:29 <geekosaur> at least, in ghc
20:31:31 <dh_work> hmm
20:31:32 <geekosaur> (it does in C)
20:31:44 <dmwit> % Numeric.showGFloat Nothing 15 "" -- still has a .0 at the end
20:31:44 <yahb> dmwit: "15.0"
20:31:46 <geekosaur> which is why I made the comment about the spec permitting snprintf
20:33:01 <dh_work> if it's always .0 when unwanted, probably best to remove exactly and only that
20:33:04 <dh_work> but then I see someone already said so
20:33:44 * dmwit pats himself on the back
20:45:37 * hackage wkt-geom 0.0.8 - A parser of WKT, WKB and eWKB.  https://hackage.haskell.org/package/wkt-geom-0.0.8 (newmana)
21:25:12 <dr34m> Hello, I heard this is a good IRC to join
21:27:37 <glguy> dr34m: Particularly if you want to chat about Haskell!
21:28:24 <DigitalKiwi> but what if you want to talk about other things?
21:28:49 <dr34m> yeah, I found this looking for information security
21:29:09 <heptahedron> make a compelling abstraction around those things and then come back
21:41:27 <heptahedron> are case expressions only compiled down to if/else chains or can they be constant dispatch like switch statements
21:54:59 <osa1> heptahedron: switch statements are also compiled to the same test-and-branch instructions like if-else chains, right?
21:55:15 <osa1> unless you're generating lookup tables, which we don't
21:56:10 <heptahedron> oh you're right, I'm not sure what I was thinking
21:56:51 <heptahedron> I've lost myself in premature optimization once again
22:20:32 <dh_work> jump tables for switches are bad on most modern arches because of branch predictor issues
22:20:39 <dh_work> so nowadays most compilers don't
22:20:48 <heptahedron> interesting.
22:21:41 <dh_work> anyway unless you're writing a compiler backend, that's the compiler's problem
22:54:37 <dminuoso> heptahedron: Keep in mind that GHC employs a wide set of program transformations/optimizations. First GHC will compile your code into a reduced language called Core. That new program is fed continuously into the simplifier. After that is done, the code is compiled into STG code, then compiled into C--, and then machine code is generated.
22:54:58 <dminuoso> heptahedron: So it's hard to talk about a very isolated language feature and wonder how it's compiled. It might not even be there after you compile your program.
23:09:39 <jle`> is there a way to "call" an injective type family in reverse?
23:11:22 <dminuoso> jle`: Isn't that just the functional property?
23:11:46 <dminuoso> Or did you mean "call" as in "use"?
23:12:27 <slack1256> jle`: How do you know the reverse argument in on the image of the type family?
23:12:54 <jle`> slack1256: it's injective, so ghc has to know right?
23:13:12 <slack1256> jle`: but not surjective, so it doesn't have to know
23:13:15 <jle`> i guess in normal haskell i could just ask to unify with an equality constraint
23:13:24 <jle`> but i'm actually looking for a way in template haskell
23:13:25 <slack1256> Exactly
23:17:39 <Wizek> Does anyone know if/how I can refactor splitEventWriter1 to splitEventWriter2? https://gist.github.com/Wizek/46d3988aaa53c539a55dd7b16e1c3df6
23:18:09 <Wizek> I am wondering because it seems that using sEW1 ties me to a concrete monad stack and requires me to use `-> EventWriterT t c m a` everywhere
23:19:22 <Wizek> Related reflex-frp documentation: http://hackage.haskell.org/package/reflex-0.5/docs/Reflex-EventWriter-Base.html#t:EventWriterT
23:20:29 <Wizek> this question might be more related to mtl than reflex though, hence me asking here
23:21:22 <Wizek> Or maybe I am only missing some `lift`s?
23:22:31 <slack1256> When speaking on FilePath sanization, where should I look at?
23:22:53 <slack1256> I can enumerate some pitfalls but I guess somebody already thought long about this
23:23:45 <maerwald> sanization?
23:23:47 <Wizek> slack1256: maybe here? http://hackage.haskell.org/package/pathtype
23:24:02 <maerwald> try https://hackage.haskell.org/package/hpath
23:24:26 <slack1256> maerwald: Sorry, I'm not a native english speaker, sanitation maybe is correct?
23:25:34 <maerwald> pathtype still uses String under the hood afais, which is a misrepresentation of filepaths
23:25:35 <Wizek> slack1256, maerwald I believe the correct term might be 'sanitization'
23:25:46 <slack1256> Got it
23:26:08 <maerwald> I think hpath is the only attempt to unify both "low level correctness" and strong types
23:26:44 <maerwald> it is a fork of https://hackage.haskell.org/package/path
23:28:15 <Wizek> maerwald: could well be.
23:28:47 <Wizek> slack1256: Another way for you to search if you want to search further would be here: https://hackage.haskell.org/packages/search?terms=path
23:28:58 <Wizek> and sort by DLs and/or Rating
23:29:27 <maerwald> that's not always a good indicator of correctness ;P
23:31:02 <Wizek> maerwald: not always, but can be a good start to gather a list of competing top packages.
23:31:04 <maerwald> most people use directory and filepath, which are the least correct implementations
23:34:44 <Wizek> As do I. Since I don't actually often deal with file paths coming from user input that could be considered risky. It's good to have simplicity when one does not need extra safety. Their popularity might reflect this disposition. And when one does need extra safety as slack1256 seems to want, then they can look beyond the simpler solutions.
23:36:47 <maerwald> I prefer a correct foundation over an incorrect one 
23:38:07 <Wizek> maerwald: and that is perfectly fine as long as you are willing to put up with some additional hoops to jump through for yourself, as you seem to be.
23:39:45 <maerwald> Wizek: no, I mean I prefer that the ecosystem is built on a correct foundation
23:40:03 <Wizek> "the"? You mean all of hackage?
23:40:04 <maerwald> Correctness and incorrectness propagates
23:40:07 <maerwald> yes
23:40:31 <maerwald> if the main ecosystem TLS implementation is vulnerable (it is), then all packages that use it are as well
23:40:40 <maerwald> as an example
23:42:08 <Wizek> I don't think that's a good example, because that is likely a vulnerability that doesn't affect user facing code. On that front we would likely agree, that should be fixed. I am talking about significant user-facing complexity overhead for the sake of an extra 1-10% of safety.
23:43:24 <maerwald> Wizek: how does it not affect user facing code? :o
23:43:34 <Wizek> on the API level
23:44:24 <Wizek> E.g. we might have a date-time library that works 99.9% of the time, but some very rare edge cases trip it up, all the while having a simple, elegant user facing API. Contrast that with one that has more static checks and guarantees, complicating its API significantly and providing correctness in 99.99% of cases
23:44:31 <maerwald> that additionaly safety is not hard and rather trivial
23:44:33 <Wizek> for many people the former might be sufficient
23:44:38 <maerwald> there is no additional complexity involved
23:44:59 <maerwald> Not caring about that is that kind of laziness that makes ecosystem go "npm" ;)
23:44:59 <Wizek> And only having the latter might put them off of learning haskell to begin with
23:45:30 <maerwald> So you want an incorrect 'base', because it is easier to pick up by newcomers? :>
23:46:14 <Wizek> I am in favor of a simple Prelude, yes.
23:46:33 <Wizek> complex preludes can be substituted for non-beginners
23:46:34 <maerwald> Simple doesn't mean it must be incorrect
23:46:45 <Wizek> Did I say that it does? 
23:46:53 <maerwald> You're implying it wrt filepath
23:46:56 <Wizek> I am only talking about when these two are in conflict
23:48:00 <maerwald> it should be totally the other way around
23:48:08 <maerwald> If your only goal is learning, pick a simplified Prelude
23:48:17 <Wizek> defaults matter
23:48:23 <Wizek> especially for beginners
23:48:24 <maerwald> Companies are using that code in production
23:48:27 <maerwald> That matters
23:48:48 <Wizek> that matters too, and for them, swapping prelude, at that level is trivial
23:48:53 <maerwald> It's not
23:49:01 <maerwald> Because the entire ecosystem uses those Prelude types already
23:49:24 <Wizek> Not the entire, but some section, yes.
23:49:28 <maerwald> Switching filepath type is a huge pain :)
23:49:41 <Wizek> maerwald: So let's flip it around, are you saying `hpath` is as simple as using `FilePath`? 
23:49:52 <Wizek> you seem to be saying not even close by mentioning huge pain
23:50:50 <maerwald> I was saying that Prelude and "base libraries" often don't have a focus on correctness, which causes a lot of pain and difficulties in the long term (and in production)
23:51:06 <maerwald> Those are mostly historical errors though, I would say
23:51:19 <maerwald> So if someone would design Prelude today, half of it would not be as it is
23:51:34 <maerwald> So no one is really disagreeing on those problems
23:51:46 <maerwald> It's just not easy to provide an upgrade path without breaking everything
23:52:17 <Wizek> sure, and we might even have `map :: forall f a b. Functor f => (a -> b) -> f a -> f b`
23:53:21 <Wizek> Are you saying that everyone agrees that we would have hpath-like paths in prelude if it was written today?
23:54:06 <maerwald> https://ghc.haskell.org/trac/ghc/wiki/Proposal/AbstractFilePath
23:54:08 <maerwald> pretty much
23:54:25 <maerwald> in terms of String vs "ByteString" at least
23:58:16 <Wizek> Insofar as only moving from String to ByteString, that might be worthwhile if we don't incur other complexity. But then BS would need to be in base. And I do wonder how beginners would fare with the distinction between String, Text and BS. Many other languages only have a single widely used string type.
23:59:01 <Wizek> maybe `cs` can help them from http://hackage.haskell.org/package/string-conversions-0.4.0.1/docs/Data-String-Conversions.html
