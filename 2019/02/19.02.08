00:01:02 <dminuoso> maerwald: You could do the same thing monad-logger does.
00:01:50 <dminuoso> That is, consider some `newtype ReportingT m a = { runReportingT :: (Err -> IO ()) -> m a }`, sprinkle some unliftio over it...
00:02:27 <dminuoso> (Or even use monad-logger directly)
00:02:32 <maerwald> I don't see how that is a framework :>
00:03:09 <dminuoso> maerwald: Im suggesting you may not need some "full flegded framework", the problem can easily be tackled by having a reporting function in your environment.
00:04:16 <maerwald> That's not really what I have in mind. The point is to push reports somewhere and then be able to decide what to do with them dynamically based on configuration with existing integration for emails, slack, ...
00:04:48 <maerwald> I don't see how a newtype gives me that
00:06:01 <dminuoso> maerwald: I was just thinking of something like `ReaderT (Error -> IO())`, where if you at some point need to report an error you'd just ask for the reporting function and put your error in.
00:09:48 <maerwald> but katip looks a little bit more like it
00:23:17 * hackage openssh-protocol 0.0.1 - Haskell implementation of openssh protocol primitives.  https://hackage.haskell.org/package/openssh-protocol-0.0.1 (MarkHibberd)
00:30:17 * hackage smith-client 0.0.1 - API client for <https://smith.st/ Smith>.  https://hackage.haskell.org/package/smith-client-0.0.1 (MarkHibberd)
00:43:21 <coldpress> are Template Haskell users expected to write functions like deriveFunctor easily? https://wiki.haskell.org/A_practical_Template_Haskell_Tutorial#Reification
00:48:49 <absence> is it necessary to provide a content type for GetNoContent in servant?
00:50:26 <alp> absence, yes, for now, unfortunately. servant issue #841 might pave the way to getting rid of this unnecessary constraint.
00:53:04 <absence> alp: i see, thanks!
00:57:31 <alp> absence, no problem, sorry for the inconvenience :-)
01:07:42 <absence> how do i set the cabal fields like license, license-type, extra-source-files in stack.yaml? the defaults are wrong, and web search fails me...
01:09:37 <gentauro> anybody good working with `Ptr`? I looks like I'm doing something wrong (line 76) -> http://dpaste.com/380DR07
01:09:54 <gentauro> the algorithm is a `bitonic sort`.
01:11:21 <gentauro> I put a list of `Storable` elements `a` into memory, and from there I do comparisons between elements. Once it has gone through the `log n` steps, I `query` the memory to persist it in a `list`
01:12:07 <gentauro> next step after I get this to work, is to add `concurrency` (a lot of lightweight threads to speed up `parallel` parts) :-)
01:15:55 <merijn> absence: That question doesn't make sense? stack.yaml does not replace a cabal file holding that info
01:18:26 <merijn> absence: Note that cabal (confusingly) gets used to refer to several different things: 1) CABAL (the Common Architecture for Building Applications and Libraries) spec (which describes packages, used by both stack and cabal-install), 2) the .cabal file format describing 1, 3) Cabal the library for interacting with 1 and 2, and 4) cabal-install the build tool. Both stack and cabal-install are build on top 
01:18:32 <merijn> Cabal (i.e. number 3), so the way to set those fields is, well, add them to your .cabal file
01:22:24 <gentauro> btw, with regard of `Ptr a` in Haskell. They are quite amazing :o
01:22:27 <merijn> absence: A complicating factor is hpack, which is a tool for generating .cabal files from YAML (i.e. package.yaml) which is completely unrelated to stack, but stack does automatically call it if you have a package.yaml, I would strongly recommend against use of hpack, though on account of: 1) yaml being a terribly inconsistent format, 2) it not supporting everything CABAL does, 3) making it hard for 
01:22:33 <merijn> people without hpack to build/work with your packages
01:22:43 <merijn> gentauro: Yeah, you can just write all your C in Haskell! ;)
01:22:55 <gentauro> once you have bound them to a specific type, they keep telling you that your `a` doesn't match with `Char` or `Word` :o
01:23:06 <merijn> @quote merijn debugging
01:23:07 <lambdabot> merijn says: Haskell is debugging the ptr/type errors in my C interface for me \o/
01:23:12 <gentauro> merijn: you should write your C in Haskell and then just transpile it back to C :P
01:23:50 <gentauro> merijn: LOL, you have stored quotes in `lambdabot`? xD
01:24:04 <merijn> Transpile is a stupid word that just means "compile" :p
01:24:14 <gentauro> merijn: :P
01:24:27 <merijn> gentauro: Pretty sure most regulars have been quoted in lambdabot
01:24:34 <gentauro> in Denmark, we don't use the word `compile`. We use the word `translate` ;)
01:25:00 <gentauro> @quote gentauro n00b
01:25:00 <lambdabot> No quotes for this person. Wrong!  You cheating scum!
01:25:03 <gentauro> :'(
01:25:37 <gentauro> and when I say Denmark, I mean Copenhagen, more specifically DIKU xD
01:26:07 <ggole> 'Compile' used to be the right word when the job was arranging collections of hand-written assembly routines
01:26:13 <ggole> Unfortunately it stuck
01:26:49 <gentauro> ggole: I agree
01:27:08 <dminuoso> merijn: The word "transpilation" is, at its core, not necessarily bad as you may want to convey more information than the "translation of code".
01:28:02 <Athas> What more information is in "transpilation" as compared "compilation" or "translation"?
01:28:09 <trcc> Any of you guys using emacs with haskell mode and dante? I have an issue, where changes done to file X are not registered in the buffer holding file Y, even though Y imports module from X
01:28:19 <gentauro> btw, I'm also playing around with `Language.Haskell.Exts`. It's kind of nice how you just `parseFileContents <$> readFile path` and you just have all your `Haskell` code in an `AST` :o
01:28:23 <dminuoso> Athas: Transpilation suggests that the target language is of comparable "height" (in the sense of high/low level languages)
01:28:52 <gentauro> trcc: what is `dante`?
01:28:58 <trcc> an emacs plugin
01:29:02 <trcc> wrapper around ghci
01:29:05 <Athas> dminuoso: don't people also say "transpilation" for things like turning C into Javascript?
01:29:27 <gentauro> I just use intero with `emacs`
01:29:34 <trcc> So you use stack?
01:29:35 <gentauro> it seems to work `meh` 
01:29:39 <gentauro> yes
01:29:44 <trcc> ok. Cabal here
01:29:54 <merijn> dminuoso: Except that people use it for everything now
01:30:03 <trcc> I am a bit tired of things that work `meh` hehe. Already spent too much time on tooling
01:30:03 <gentauro> the problem with this approach is when working with `scripts`, it can't `autoload` local modules
01:30:11 <Flonk> If I want to read a file line by line without reading the whole thing into memory at once, how would I go about that?
01:30:26 <merijn> Flonk: Depends, how robust do you want to be?
01:30:35 <Flonk> one-off script, so I don't really care
01:30:41 <tdammers> "transpilation", from what I gathered, is a synonym for "compilation", but suggests that the target is a language suitable for humans, by some metric
01:30:41 <gentauro> :t getLine
01:30:42 <lambdabot> IO String
01:30:46 <merijn> Flonk: Honestly, lazy Text should work
01:30:55 <merijn> Flonk: That'll just read on demand via lazy IO
01:31:03 <dminuoso> tdammers: That may be implied too, indeed.
01:31:13 <trcc> gentauro: does that make it possible to i.e. load a haskell file, which contains a hashmap, and then iterate through its entries?
01:31:13 <merijn> Flonk: The more robust/proper way would be via something like conduit
01:31:28 <gentauro> tdammers: I think that is a valid definition
01:31:31 <tdammers> so not necessarily "comparable height" or "comparable abstraction level", but rather just that the target is also a "programming language", by some definition
01:31:31 <merijn> dminuoso, tdammers: Have you ever looked at code generated by compiling to a high level language?
01:31:34 <Flonk> merijn, ah, true! That'll do :)
01:31:40 <Flonk> Thanks
01:31:45 <tdammers> merijn: yes, I have stared into that abyss
01:31:54 <dminuoso> merijn: Worse! I've even build such tools before.
01:31:55 <merijn> I have, I worked on a compiler compiling to C, it's not "human readable" in any traditional sense
01:32:07 <dminuoso> Corba IDL generators. Fun stuff.
01:32:16 <tdammers> merijn: note that I didn't say the *output* was supposed to be human-readable, just that target (as in, the target language) would be one that humans can also use
01:32:45 <Athas> I don't really buy that "transpilation" provides any meaningful information over "compilation".  It's all too vague.  It's better to just be precise about the source and target languages (that's usually obvious in context already).
01:32:58 <gentauro> if you want thousands of `ugly C`, use Kleenex :P -> https://github.com/diku-kmc/kleenexlang
01:33:22 <merijn> tdammers: That's a super useless definition, though
01:33:25 <Athas> I wouldn't say that the unregistered C backend in GHC is a "transpiler".
01:33:27 <dminuoso> Athas: At that point you might avoid using "compilation too", as that is assumed by many people to mean "translate to machine code"
01:33:33 <merijn> People will write in anything
01:33:43 <tdammers> Athas: it doesn't, it just signals a certain intent or expectation
01:33:51 <merijn> dminuoso: Don't give into the demands of dumb semantic terrorists
01:34:09 <Athas> dminuoso: usually I will clarify "X-to-Y compiler", but I do prefer simply saying "translator" (although not in English, because it will confuse people).
01:34:35 <Athas> I think I saw in a very early paper that the first uses of "transcompiler" were for compilers were the output was supposed to be human-readable/editable.
01:35:00 <Athas> But that is not at all the usage now.  I'm not even sure we have a word for that.
01:35:04 <gentauro> Athas: `transcompiler` => `transpiler` there you go
01:35:10 <gentauro> you solved the problem !!!
01:35:11 <tdammers> so far, my heuristic has been that someone who uses the word "transpiler" is probably either a hyped-up javascript hipster, or a fresh beginner in desperate need of guidance
01:35:12 <piyush-kurur> jjb: you may look into https://github.com/raaz-crypto/raaz/blob/master/core/Raaz/Core/Types/Equality.hs on timing safe equality 
01:35:12 <dminuoso> Athas: And "decompiler" is frequently suggested to mean a compiler from machine-suitable to human-suitable languages.
01:35:24 <dminuoso> tdammers: +1
01:35:29 <Athas> tdammers: hah, that's my heuristic too, but I didn't want to be too offensive!
01:35:39 <rockman37> tdammers: Agreed.
01:35:46 <Athas> "Transcompiler" means that one of the ends is Javascript.
01:36:05 <tdammers> likewise, if you say "dedent" (instead of "remove indentation" / "reduce indentation"), then you are probably a one-trick-pony type Python person
01:37:30 <gentauro> and once again the `haskellers` are looking down on the `peps` of the world from their ivory tower ...
01:37:41 <gentauro> so clever, so good at using terms they only understand
01:38:04 <gentauro> oh, we just farted and smelled it. Delicious :P
01:38:13 <rockman37> tdammers: I say dedent :(
01:38:13 <Rembane> Shiboleths! 
01:38:30 <gentauro> rockman37: obviously you are a n00b, what are you even doing here?
01:38:33 <gentauro> get out :P
01:38:50 <Rembane> I think it's a good strategy to be kind to people.
01:38:50 <rockman37>  /part
01:39:08 <Rembane> Even though it might help to know their background.
01:39:10 <rockman37> gentauro: I'm trying to become less noobish by listening in on conversatons.
01:39:30 <rockman37> gentauro: But it's a bit harder with haskell than other languages I've done that with.
01:39:30 <Rembane> Lurking for knowledge ftw! 
01:39:31 <Athas> Can "dedent" be used as a verb?  I actually like that word.
01:39:38 <dminuoso> Obligatory: https://ro-che.info/ccc/20
01:39:39 <Rembane> Athas: Give an example! 
01:39:42 <ent> tdammers: shouldn't it be outdent? :)
01:39:44 <rockman37> Athas: For me it's only a verb.
01:39:45 <Athas> It is more elegant than "unindent".
01:39:45 <merijn> Athas: Obviously
01:39:55 <merijn> Athas: I think it's is ONLY a verb
01:39:56 <gentauro> rockman37: just kidding xD
01:40:02 <merijn> Athas: It doesn't make sense as a noun
01:40:05 <rockman37> gentauro: I know :)
01:40:10 <Athas> Rembane: "dedent that definition; it is for the top level"
01:40:20 <merijn> Athas: What would it refer to as noun? A smaller indent?
01:40:20 <dminuoso> 10:37     gentauro | and once again the `haskellers` are looking down on the `peps` of the world from their ivory tower ...
01:40:27 <dminuoso> gentauro: You see, at least we have an ivory tower.
01:40:30 <Rembane> Athas: Damn legit! 
01:40:36 <Rembane> Now... how do you save quotes?
01:40:39 <gentauro> dminuoso: you wish :P
01:40:42 <Athas> merijn: I don't think it works as a noun.
01:40:43 <rockman37> merijn: A thing that sticks out the left margin?
01:41:02 <Rembane> Tungur dentur.
01:41:09 <Athas> Except to describe a decrease of indentation from one line to the next: "there is a dedent here".
01:41:23 <rockman37> Athas: True.
01:41:30 <tdammers> ent: etymologically speaking, "outdent" is nonsense
01:41:30 <Athas> "The dedent is invisible because you fucked up and mixed tabs and spaces"
01:41:33 <gentauro> dminuoso: I spoke once with Filinski from DIKU (while I was drunk) and I said, if I ever succed, I would go to Malmø and buy "El Torso" and then I would have my "ivory tower" xD
01:41:51 <tdammers> (so is "dedent")
01:41:56 <Rembane> Will a dedent put a dent in the source code?
01:41:57 <dminuoso> exdent.
01:42:08 <dminuoso> or codent.
01:42:09 <rockman37> While we're on the subject, what is the opposite of assemble for you guys?
01:42:15 <dminuoso> rockman37: disassemble.
01:42:16 <tdammers> dminuoso: maybe, but that would suggest moving the beginning of the line to the left past column 1
01:42:17 <merijn> disassemble
01:42:30 <Athas> "Disassemble" is too newspeak-y.  We need a more poetic term!
01:42:46 <dminuoso> tdammers: no?
01:42:47 <rockman37> dminuoso, merijn: For me too, but I have a colleague who says "dissemble".
01:42:57 <Athas> If "disassemble" was used frequently over a century or so, it would definitely become "dissemble".
01:42:58 <dminuoso> tdammers: oh I see what you mean.
01:43:15 <ggole> assembln't
01:43:24 <Athas> You could even use "dissembly" as a term for gross source code that came about as a result of dissembly.
01:43:27 * ggole will see himself out
01:43:47 <Rembane> Every day I'm ssemblin'!
01:43:57 <dminuoso> tdammers: I know. We should take wisdom from million web developers. We should call it "pull-right" and "pull-left"
01:44:06 <rockman37> Athas: Don't diss my disassembly! :p
01:44:08 <gentauro> Rembane: what about `bling'`?
01:44:19 <gentauro> that will catch with the youth !!!
01:46:39 <gentauro> btw, found my error (line 254 should be `w p q`) -> http://dpaste.com/380DR07
01:46:40 <Rembane> gentauro: I need more bling in my code! 
01:46:47 <gentauro> damn !!!
01:57:56 <maerwald> applicative doesn't allow incremental cons in traverse?
01:58:51 <dminuoso> What is incredemental cons?
01:59:35 <maerwald> element is added to the output structure after running the effect
02:08:07 <merijn> maerwald: Traversable doesn't allow adding/removing elements, only changing
02:09:01 <maerwald> What I mean is that the output structure is constructed after all effects are run, right?
02:15:22 <gentauro> maerwald: are you allowed to perform effects in an `Applicative`? (`pure` and `<*>`)
02:16:05 <maerwald> I don't understand that question
02:17:45 <Unhammer> Is there a combinator like
02:17:47 <Unhammer> mapHist :: ([a] -> t -> a) -> [t] -> [a]
02:17:49 <Unhammer> mapHist f lst = reverse $ foldr go [] (reverse lst) where go elt acc = f acc elt : acc
02:17:51 <Unhammer> already in the regular libraries? Like a restricted foldr where you know it'll return a list of the same length
02:17:53 <Unhammer>  
02:18:15 <Unhammer> (but you have access to the already-processed elements in the passed function)
02:21:20 <gentauro> maerwald: `10:59 < maerwald> element is added to the output structure after running the effect`
02:21:28 <gentauro> what do you mean by `effect`?
02:23:36 <maerwald> @type traverse
02:23:38 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
02:23:40 <maerwald> f
02:54:15 <oo_miguel> how would I optimize (as an example) something like this: let f=something_slow_and_complicated in map (\x->(f x,f (x+1)) [1..]
02:54:32 <oo_miguel> coming from structured programming I keep struggling with such constructions in haskell
02:56:04 <oo_miguel> hmmmm. not sure if my example is not too trivial :P
02:56:28 <oo_miguel> ok, forget it (for now) sorry
02:58:43 <day> oo_miguel: i believe the [1..] is a bigger issue there than the "complex function". appending to lists is iirc O(n)
03:01:24 <oo_miguel> day: I imagined that `map` just traverses the [1..] list and builds a new one with (:)
03:02:15 <reygoch> so a quick question, once I have ghcjs all set up, how do I compile cabal project with it? Do I just do cabal new-build --ghcjs or do I have to do something else?
03:09:44 <day> oo_miguel: based on my advent of code day one experience, i would think it doesnt do "(:) x []". But i could be wrong
03:19:09 <dminuoso> oo_miguel: It's easy to see that it cant do it differently.
03:19:45 <dminuoso> If you had θ(n) time complexity in length n for an infinite list, then that would simply hang.
03:20:05 <oo_miguel> dminuoso: good point
03:20:15 <dminuoso> oo_miguel: As for "how would you optimize", it's hard to say without knowing what the problem is. Did you profile your code?
03:21:08 <oo_miguel> dminuoso: yeah, I already managed to 'optimize' this fragment so I am happy and I do not recalculate the "complicated_slow_thing" for each pair twice. 
03:21:42 <oo_miguel> dminuoso: but the type of 'problem' that I keep recalculating something, I already calculated before is something I encounter often in my haskell-adventures
03:21:59 <dminuoso> oo_miguel: Do you have a concrete example?
03:23:08 <dminuoso> oo_miguel: In general you can share recalculating by naming that thing and then reusing that name.
03:23:15 <oo_miguel> I hoped the example I just posted would be representative. but this time I managed to solve it myself easily. simply by calculaing a list of [f 1,f 2,f 3....] and constructing my list of pairs [(f 1,f 2),(f 2, f 3,.... ] afterwards
03:23:34 <dminuoso> For example: `let f = expensive_thing in (f + 1, f - 1)` would compute `f` only once.
03:23:45 <dminuoso> (Assuming you demanded any part inside)
03:24:51 <dminuoso> Ah I can see what you meant.
03:24:59 <oo_miguel> dminuoso: oh right. I would not be sure about how your example is resolved. I think that my biggest problem is, that I am not fully aware of how ghc resolves what I tell it to do
03:25:13 <oo_miguel> WHEN examples are STORED, and when they get recalculated
03:25:35 <dminuoso> oo_miguel: In principle whenever you name it.
03:26:03 <dminuoso> So if you do (f 1, f 1), barring any sharing optimizations GHC might apply you can expect `f 1` to be recalculated (if demanded)
03:26:34 <oo_miguel> so: "let f=complicated_func in [f 1,f 1]" differs from "let f=complilacted_func 1 in [f,f]" ?
03:26:43 <dminuoso> Yes.
03:26:46 <oo_miguel> ooh
03:26:49 <oo_miguel> ok
03:27:48 <oo_miguel> this already helps me quite a bit. I will have to play with it/use it in practice to get a hang of it
03:29:10 <dminuoso> oo_miguel: Consider this naive and very inefficient implementation:
03:29:16 <dminuoso> % fac n = if n == 0 then 1 else n * fac (n-1)
03:29:16 <yahb> dminuoso: 
03:31:02 <dminuoso> oo_miguel: You should be able to experiment with this comparing snippets like `let x = fac 20000 in (x, x)` against `(fac 20000, fac 20000)`
03:32:43 <oo_miguel> dminuoso: hehe, just tested..  for some reason they seem to result in the very same runtimes ;)
03:32:54 <oo_miguel> maybe ghci makes some optimizations in such trivial cases
03:33:05 <oo_miguel> or WORSE
03:33:13 <oo_miguel> it recalculates in the first case!
03:37:37 <oo_miguel> dminuoso: anyway, this is a good starting point to experiment with. thank you very much.. I'm out for a walk now. Will keep on playing later.
03:44:20 <[Leary]> oo_miguel: There's the added complication that typeclass constraints incur hidden arguments, so an overly polymorphic value like `x :: Num a => a` may not be able to be shared in (x, x) inferred as (Num a, Num b) => (a, b)
03:45:11 <oo_miguel> [Leary]: I will try giving it an explicit type
03:46:07 <oo_miguel> let x = fac 30000::Integer in (x, x)
03:46:11 <oo_miguel> seems to work faster
03:46:13 <oo_miguel> thanks
03:46:33 <gentauro> oo_miguel: memoization perhaps?
03:46:52 <gentauro> `map (\x->(f x,f (x+1)) [1..]`
03:48:06 <gentauro> I don't think there is a `memo` function in Haskell as it, but you can find SPJ paper on the paper matter and copy/pasta ;)
03:48:17 <merijn> People often like to say/imply GHC does memoisation, but it doesn't. At best it shares results
03:48:42 <gentauro> merijn: I noticed that ...
03:49:42 <merijn> oo_miguel: In general if you care about performance, specialising types (like you did with Integer) is a good idea, because it helps GHC immensely
03:50:22 <merijn> The strictness analyser works best for known types like Int/Integer/etc.
03:51:16 <gentauro> :t memoize f = (map f [0 ..] !!)
03:51:17 <lambdabot> error:
03:51:17 <lambdabot>     parse error on input ‘=’
03:51:17 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
03:51:31 <gentauro> :memoize f = (map f [0 ..] !!)
03:51:36 <gentauro> % memoize f = (map f [0 ..] !!)
03:51:37 <yahb> gentauro: 
03:51:41 <gentauro> :t memoize
03:51:43 <lambdabot> error: Variable not in scope: memoize
03:51:48 <gentauro> > memoize f = (map f [0 ..] !!)
03:51:51 <lambdabot>  <hint>:1:11: error:
03:51:51 <lambdabot>      parse error on input ‘=’
03:51:51 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
03:51:59 <gentauro> >meh
03:52:14 <merijn> GHC knows about integers, so a recursive loop that sums/multiplies integers make the strictness analyser go "huh, this entire things is just strict computation, and throw out all the laziness and indirection and generate a tight loop
03:56:30 <WilliamHamilton[> what's the right combinator of type `(a -> b -> m c) -> m a -> m b -> m c`
03:56:42 <merijn> WilliamHamilton[: applicative + join
03:57:12 <merijn> WilliamHamilton[: You can simply <$> and <*> to end up with "m (m c)", then use join to collapse the nesting
03:57:31 <WilliamHamilton[> right merijn , thanks
04:01:09 <reygoch> is there some haskell dev server app that allows me to start a simple file server in current directory?
04:01:24 <reygoch> something like http-server for nodejs?
04:03:07 <merijn> I thought there was something in warp?
04:03:49 <reygoch> Is there?
04:03:53 <reygoch> I'll have to check
04:05:03 <reygoch> merijn: No, no executable file in warp cabal file
04:05:40 <merijn> I meant, like a simple IO action to do that
04:07:00 <reygoch> I've found sws
04:07:10 <reygoch> Hopefully it'll work :D
04:13:03 <cads2> Hey all, I have a neat graph theory problem: Acquaintance time! let P_n be a path graph with n nodes. A "swap strategy" is a matching on P_n - a collection of pairs of nodes which are disjoint. For example, P_4 has swap strategies (12), (23), (34), and (12)(34).
04:13:20 <cads2> Nodes start out "acquainted" with its neighboring node or nodes. We then apply a swap strategy, and allow the nodes to acquaint each other with their new neighbors.
04:14:01 <cads2> An acquaintance strategy is a sequence of swap strategies which acquaints each node with every other node. Let AC(n) be the length of the shortest acquaintance strategy for P_n.
04:16:00 <adius> Hi, is there a way to enable/disable GHC options on a per file basis?
04:16:56 <Taneb> adius: you can add a pragma like {-# OPTIONS_GHC -fno-warn-orphans #-} in the file
04:17:07 <cads2> For example, AC(3) = 1, where both swap strategies are acquaintance strategies. For P_4, we have AC(4) = 2, where the shortest acquaintance strategy is (23), (12)(34).
04:17:27 <adius> taneb: Thanks!
04:17:48 <Taneb> :)
04:18:07 <adius> taneb: You also already correctly guessed which warning I want to disable 😂
04:18:36 <Taneb> :O
04:18:44 <cads2> My question is - does anyone want to help me work on this cooooool (and currently open!) problem?! I was going to code up a basic brute force AC function in python, but I decided I love myself too much for that - so haskell it is!
04:23:04 <cads2> A paper with a way better intro, introducing the acquaintance time for general graphs. It has some very nice complexity results. For instance, see prop 3.1 for a proof that AC(n) = O(n) in our case of path graphs   https://arxiv.org/abs/1302.2787
04:24:21 <adius> taneb: But there is no way to make it even more fine granular, like on a per function basis, is there?
04:24:29 <Taneb> adius: no
04:25:09 <merijn> I suggested an ADOPT pragma to silence orphans, but people were more in favour of disabling arbitrary warnings for a number of lines
04:25:17 <cads2> The way I see the problem at this point is in two parts   1. For a given n, enumerate all the swap_strategies for n. this should be nice and recursive
04:25:32 <adius> 😞   Hurts me to say, but ESLint is way better in this regard than anything for Haskell
04:26:44 <Taneb> adius: I'm not familiar with it, how does it compare with hlint?
04:27:00 <merijn> The trick is to just avoid orphans :p
04:27:41 <cads2> 2. After I have swap_strategies, begin lazily enumerating [swap_strategies]  and searching for the shortest one
04:38:14 <Aaryan> Hello, can someone help me get started with https://summer.haskell.org/ideas.html#algebraic-graphs 
04:38:51 <Aaryan> I am undergraduate freshman, and know very basic Haskell and have it installed 
04:39:38 <lyxia> I would guess the next step is to build/install alga to try it.
05:00:10 <cads2> is there a monad for exhaustive brute force search over some complicated space?
05:01:07 <hpc> what sort of complicated space?
05:01:20 <hpc> since you say "brute force", i assume it's enumerable?
05:01:31 <hpc> in which case put it in a list and use that perhaps
05:02:26 <cads2> yeah, it's the space [Matching(G)], lists of matchings on some graph G
05:03:52 <lyxia> have you tried the [] monad.
05:06:28 <cads2> I don't think the [] monad gives me a way of enumerating stuff (it does give me a way of lifting ordinary functions onto list function, right?)
05:07:37 <hpc> > join (join (\a b -> if length a == length b then [(a, b)] else []) <$> ["cat", "dog", "egg", "apple"])
05:07:40 <lambdabot>  [("cat","cat"),("dog","dog"),("egg","egg"),("apple","apple")]
05:07:46 <lyxia> > do x <- [1,2,3] ; y <- [1,2,3] ; guard (x < y) ; pure (x, y)
05:07:48 <lambdabot>  [(1,2),(1,3),(2,3)]
05:07:50 <hpc> er
05:08:01 <lyxia> that's very much an enumeration.
05:08:09 <cads2> Also, Matching(G) is a really dependent type - a matching is some set of edges in G such that no two edges share an endpoint, and I'm not sure how to express that with a ADT
05:08:23 <hpc> > let words = ["cat", "dog", "egg", "apple"] in (\a b -> if length a == length b then [(a, b)] else []) <$> words <*> words >>= id
05:08:25 <lambdabot>  [("cat","cat"),("cat","dog"),("cat","egg"),("dog","cat"),("dog","dog"),("dog...
05:08:56 <hpc> lyxia's example is better
05:09:32 <hpc> cads2: that set of edges can be a list of edges when searching
05:10:42 <cads2> okay, so if I can get a list of matchings then I can do some applicative bullshit or whatever that was, and make short work of any kind of list building / processing
05:10:52 <adius> taneb: Really powerful and you can basically configure anything, e.g. switch every warning to an error and vice versa, create exact rules when you code is supposed to pass, auto-fixing for a lot of warnings, ... I guess hlint has most of this too, but ESLint still seems more polished (but it has a big community behind it, so it's less of a surprise)
05:11:23 <cads2> and I can probably do something similar to actually generate a list of matchings to begin with
05:11:34 <hpc> you'll probably prefer do-notation but yeah
05:15:08 <cads2> hpc, I bet there are nice recursive matching generation algorithms. Take any edge E_1 out of G, and delete that edge, its vertices, and any edges incoming, to get G'; that removed edge forms a 1 edge matching, and if G' has any edges remaining, we can remove another edge E_2 as before; [E1, E2] is now a two edge matching
05:17:16 <cads2> there would be some backtracking or high branching recursion involved, but I bet there are efficient algos in the literature
05:17:31 <cads2> okay, I will sleep on it and then give it a shot
05:18:07 <cads2> thanks for that frankly impressive demonstration lol... I will analyze that code and learn its secrets
05:18:30 <hpc> that's getting away from pure brute force, but yeah
05:19:47 <cads2> well, coming up with a set of all matchings shouldn't be brute force (that's just the pre-phase of the main problem)
05:20:17 <cads2> the main problem is to find some sequence of matchings - and for that, I know of nothing but brute force
05:21:52 <cads2> I know for a fact that finding the optimal sequence of matchings is NP-complete (the paper I linked embeds graph coloring into the acquaintance time problem)
05:22:26 <cads2> anyways, thanks again! I look forward to my work tomorrow!
05:30:47 * hackage ngx-export 1.7.0.1 - Helper module for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-1.7.0.1 (lyokha)
05:45:45 <lyxia> cads2: if you need something fancier, you can use trees instead of lists
05:47:47 * hackage isobmff 0.14.0.0 - A parser and generator for the ISO-14496-12/14 base media file format  https://hackage.haskell.org/package/isobmff-0.14.0.0 (SvenHeyll)
05:50:47 * hackage equational-reasoning-induction 0.6.0.0 - Proof assistant for Haskell using DataKinds & PolyKinds  https://hackage.haskell.org/package/equational-reasoning-induction-0.6.0.0 (HiromiIshii)
05:53:45 <dminuoso> Is there an idiomatic way to turn `data Foo = Foo Word8 Word8 Word8 Word8` into (Word8, Word8, Word8, Word8)?
05:53:58 <dminuoso> Or do I have to do this... manually?
05:54:55 <dminuoso> (Sadly this appears to not be Coercible)
06:00:21 <cocreature> dminuoso: you have to do it manually
06:00:36 <cocreature> you might be able to leverage some generics trickery but I highly doubt it’s worth the effort
06:03:34 <phadej> generis trickery is 'to . from'
06:04:11 <phadej> > to . from $ ('a', 'b')
06:04:14 <lambdabot>  error:
06:04:14 <lambdabot>      • Couldn't match type ‘(Char, Char)’
06:04:14 <lambdabot>                       with ‘Control.Lens.Internal.Iso.Exchange a b a (Identit...
06:04:18 <gentauro> dminuoso: aren't those two equivalent? I mean both represent "records" right?
06:04:23 <phadej> > GHC.Genercs.to . GHC.Generics.from $ ('a', 'b')
06:04:26 <lambdabot>  error:
06:04:26 <lambdabot>      Not in scope: ‘GHC.Genercs.to’
06:04:26 <lambdabot>      No module named ‘GHC.Genercs’ is imported.error:
06:04:31 <phadej> > GHC.Generics.to . GHC.Generics.from $ ('a', 'b')
06:04:34 <lambdabot>  error:
06:04:34 <lambdabot>      Not in scope: ‘GHC.Generics.to’
06:04:34 <lambdabot>      No module named ‘GHC.Generics’ is imported.error:
06:04:38 <phadej> cannot demo :(
06:04:55 <gentauro> phadej: try to import the modules first :P
06:05:03 <gentauro> % import GHC.Generics
06:05:03 <yahb> gentauro: 
06:05:12 <gentauro> GHC.Genercs.to . GHC.Generics.from $ ('a', 'b')
06:05:20 <gentauro> % GHC.Genercs.to . GHC.Generics.from $ ('a', 'b')
06:05:20 <yahb> gentauro: ; <interactive>:3:1: error:; Not in scope: `GHC.Genercs.to'; Perhaps you meant one of these: `GHC.Generics.to' (imported from GHC.Generics), `GHC.Generics.to1' (imported from GHC.Generics), data constructor `GHC.Generics.U1' (imported from GHC.Generics); No module named `GHC.Genercs' is imported.
06:05:35 <phadej> gentauro: yahb and lambdabot are different
06:05:39 <gentauro> % to . from $ ('a', 'b')
06:05:39 <yahb> gentauro: ; <interactive>:4:1: error:; Ambiguous occurrence `to'; It could refer to either `GHC.Generics.to', imported from `GHC.Generics'; or `Control.Lens.to', imported from `Control.Lens' (and originally defined in `Control.Lens.Getter'); <interactive>:4:6: error:; Ambiguous occurrence `from'; It could refer to either `GHC.Generics.from', imported from `GHC.Generics'; 
06:05:42 <gentauro> meh
06:05:57 <gentauro> % GHC.Genercs.to . GHC.Generics.from $ ('a', 'b')
06:05:58 <yahb> gentauro: ; <interactive>:5:1: error:; Not in scope: `GHC.Genercs.to'; Perhaps you meant one of these: `GHC.Generics.to' (imported from GHC.Generics), `GHC.Generics.to1' (imported from GHC.Generics), data constructor `GHC.Generics.U1' (imported from GHC.Generics); No module named `GHC.Genercs' is imported.
06:06:23 <gentauro> yahb: is broken -> Not in scope: `GHC.Genercs.to'; Perhaps you meant one of these: `GHC.Generics.to' (imported from GHC.Generics),
06:06:26 <gentauro> :|
06:06:38 <phadej> do you have dyslexia? :)
06:06:44 <phadej> genercs vs generics
06:06:50 <gentauro> :D
06:06:58 <gentauro> I probably do
06:07:15 <gentauro> % GHC.Generics.to . GHC.Generics.from $ ('a', 'b')
06:07:15 <yahb> gentauro: ; <interactive>:6:1: error:; * Couldn't match type `U1' with `S1 ('MetaSel 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy) (Rec0 Char) :*: S1 ('MetaSel 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy) (Rec0 Char)'; Expected type: M1 D ('MetaData "(,)" "GHC.Tuple" "ghc-prim" 'False) (C1 ('MetaCons "(,)" 'PrefixI 'False) (S1 ('MetaSel 'Nothing 'NoSourceUnpacke
06:07:29 <notzmv> hmm
06:07:31 <gentauro> phadej: or I just `copy/pasta` your code ...
06:07:41 <gentauro> phadej: do you have dyslexia?
06:07:50 <phadej> gentauro: my latter version if fixed
06:08:05 <phadej> I guess, I'm just bad at typing
06:08:09 <phadej> reading is fine
06:09:49 <gentauro> phadej: I'm assuming when I copy/pasta that it's OK. I therefore turn of my brain
06:09:50 <notzmv> oof klined
06:09:52 <gentauro> :P
06:12:16 <gentauro> I just saw a video on youtube about a documentary of climbing `El Capitan in "Free Solo" (no ropes)`. And I thought to myself. That looks just like somebody coding in JavaScript. Amirite?
06:14:12 <phadej> that's a bit of a sick attempt
06:14:18 <phadej> not even a bit
06:14:24 <phadej> (the climbing)
06:15:45 <gentauro> phadej: absolutely a nutcase in my book
06:16:02 <gentauro> (I'm speaking about people coding in JS ofc)
06:19:03 <byorgey> say what you want about Alex Honnold but he is definitely not a nutcase.  People who code in JS, however... =)
06:19:43 <maerwald> gentauro: I totally disagree
06:20:00 <maerwald> The guy who did that free solo trained it for a year or more
06:20:08 <maerwald> JavaScript people just start typing xD
06:20:53 <maerwald> Free solo is a huge amount of repetition until perfection, and then they do the actual solo
06:21:22 <maerwald> he memorized every single movement of the entire climb
06:21:26 <maerwald> anyway, OT lol
06:21:48 <tabaqui1> I dunno, if I can do such thing with Type.Reflection or similar
06:22:03 <tabaqui1> I have a function with signature (a -> IO ())
06:22:40 <tabaqui1> And I want to print (show a) if a is an instance of Show or another string elsewhere
06:22:46 <tabaqui1> without typeclasses
06:23:20 <tabaqui1> Actually I have a heterogeneous list with given constraint
06:23:55 <byorgey> tabaqui1: what's the constraint?
06:23:56 <tabaqui1> and want to call some function if an element satisfy another constraint
06:24:39 <tabaqui1> It is just common "Wrap :: (constraing a) => a -> Wrap constraint"
06:24:52 <byorgey> tabaqui1: there's no way around the fact that somehow you need to store some extra information along with each element so you can tell at runtime whether it satisfies the constraint you want or not
06:25:40 <tabaqui1> usually I use "maybe (return ()) myFunc eqT"
06:26:06 <tabaqui1> but I have to copypaste 5 lines of code with different eqT signatures
06:26:28 <byorgey> sure, that works fine, and if you want to use eqT that requires storing a Typeable constraint
06:26:31 <tabaqui1> maybe there is some clearer way
06:27:27 <byorgey> I could also imagine just making something like   data MaybeConstrained where AnyOldThing :: a -> MaybeConstrained; ConstrainedThing :: (TheConstraint a) => a -> MaybeConstrained
06:27:32 <byorgey> and then wrapping all your elements in that
06:30:04 <Ulrar> Hi, is there an "good" way of buffering reads from a file descriptor ? Basically I just want to process the lines one by one, so I need to store the result of read somewhere until there's a full line (or store the following lines if I received a bunch of them at once)
06:30:43 <Ulrar> In C I'd probably use a chained list of buffers or something, just wondering what the proper way would be in haskell
06:31:17 * hackage hinterface 0.9.0 - Haskell / Erlang interoperability library  https://hackage.haskell.org/package/hinterface-0.9.0 (SvenHeyll)
06:31:27 <lortabac> tabaqui1: I remember seeing a GHC plugin doing exactly that
06:31:36 <lortabac> however I forgot the name
06:32:56 <janat08> i get error: Exception when trying to run compile-time code for stack build
06:34:04 <lortabac> tabaqui1: you may also have a look at http://hackage.haskell.org/package/constraints-0.10.1/docs/Data-Constraint-Deferrable.html
06:34:42 <janat08> for some static assets
06:37:15 <lortabac> tabaqui1: oh, I found the plugin I was talking about: https://hackage.haskell.org/package/constraints-emerge
06:38:26 <tabaqui1> byorgey, lortabac: thanks
06:41:49 <yayforj> when using nix, is there a way to get binary cache for haskellPackages with profiling enabled?
06:42:40 <aib> Is there a way to apply a constraint to a type displayed with :t in ghci? ":t (+) where a::Int" or ":t (+) :: Int -> *" or something?
06:43:46 <tabaqui1> aib: :t ((+) :: Int -> Int -> Int)
06:43:54 <tabaqui1> you can type the whole type directly
06:43:54 <phadej> > (+) @Int
06:43:57 <lambdabot>  error:
06:43:57 <lambdabot>      Pattern syntax in expression context: +@Int
06:43:57 <lambdabot>      Did you mean to enable TypeApplications?
06:44:14 <phadej> enable TypeApplications and it might do what you want
06:44:23 <tabaqui1> oh, it is even better :)
06:44:28 <aib> aha!
06:46:02 <aib> wow, that's great. thanks! (<*>) @((->) Int) :: (Int -> a -> b) -> (Int -> a) -> Int -> b
06:57:21 <Ulrar> Hum, is there a CInt -> Int somewhere ?
06:57:30 <Ulrar> hoogle seems to say no, so I must be missing something
06:57:31 <c_wraith> fromIntegral should do
06:57:35 <Ulrar> ah
06:58:00 <c_wraith> It's so polymorphic that it's hard for Hoogle to find
06:58:45 <Ulrar> That does seem to work
06:58:47 <Ulrar> thanks !
06:59:12 <c_wraith> you're welcome
06:59:57 <hyperisco> I want to chop a Text into pieces based on a grammar. Is there something more direct than, say, parsec, which first chops the Text into Chars and then burdens me to pack the Chars back together?
07:00:17 <hyperisco> I would typically solve this problem with regexp capture groups.
07:00:29 <searock> Hi, I was wondering if I could use a composite datatype as the argument on a phantom type
07:00:52 <hyperisco> searock, what is a composite datatype?
07:00:54 <searock> e.g mate :: Animal Panda -> Animal Panda -> Animal Panda
07:00:58 <searock> ADT
07:01:17 <hyperisco> searock, as long as the kinds match, yes.
07:01:18 <searock> Where Animal = Panda String Int | Whale String Int
07:01:57 <searock> Sorry about the examples btw
07:02:23 <searock> But yeah, I'm getting a compile time error
07:02:33 <hyperisco> I am not sure what Animal is. You showed it initially as having a type parameter but then showed it without one.
07:02:56 <searock> Just give me a sec, I'll put on pastebin :)
07:03:02 <searock> Btw thanks a lot!
07:03:05 <hyperisco> Okay, thank-you.
07:03:29 <searock> https://pastebin.com/kZxf9K4U 
07:03:55 <searock> I know the examples are silly, I'm mostly trying to learn the concepts and am just writing rubbish for that :p
07:04:06 <hyperisco> searock, Unless there is another type declaration you are not showing, Panda is just a data constructor, not a type.
07:04:27 <searock> I see
07:05:16 <searock> So Panda is not considered a type and thus will not be able to be put in the type parameter
07:05:21 <hyperisco> searock, If you would like Panda and Whale to be types then you would declare each, such as  data Panda = Panda String Int
07:05:42 <searock> I want them to be union types as well though. 
07:05:55 <searock> Such that I both can be considered an animal
07:06:08 <hyperisco> searock, There is a difference between unions and disjoint unions. Haskell only has the latter.
07:07:13 <searock> I'm not entirely sure how to imagine that. But thank you Hyperisco. 
07:08:33 <hyperisco> searock, Well it is a longer discussion to explain ADTs so I recommend reading, say, a Haskell book or the Haskell wiki or something like that.
07:09:07 <searock> Yeah, I figured the same
07:09:14 <searock> Thanks, though. 
07:10:34 <hyperisco> searock, Regular unions are idempotent, so  X | X = X . Disjoint unions do not have this property.
07:12:06 <hyperisco> searock, So to know which X one is referring to we give each term a tag. Panda is such a tag as is Whale.
07:13:17 <hyperisco> searock, Which is why they are also called "tagged unions".
07:22:05 <searock> Hyperisco I see.
07:22:24 <Denommus> hey
07:22:29 <Denommus> is there a way to get an option by using a prompt with optparse-applicative?
07:22:32 <Denommus> like for passwords and such
07:23:25 <tdammers> I think that would be somewhat impossible
07:23:33 <searock> HyperIsco, While reading about Phantom type All the examples given where on simple types as the type parameter, a was always Int or Bool. So I was wondering if it is possible to make a some more complicated type
07:23:46 <Denommus> ok. Just to be sure
07:23:59 <tdammers> I guess the best thing you can do is have optparse-applicative return a placeholder that tells the consumer to query for that particular value
07:24:09 <hyperisco> searock, The only requirement is that the kinds match. You can go as crazy as you'd like.
07:24:11 <searock> Hyperisco, I think I understand what you mean, meaning a can be Animal, but not panda. 
07:25:13 <hyperisco> Animal :: Type -> Type  or  Animal :: a -> Type  with PolyKinds
07:25:25 <hyperisco> Maybe that is on by default nowadays. Haven't been keeping track.
07:55:29 <Welkin> @ops
07:55:29 <lambdabot> Maybe you meant: pl oeis docs
07:55:33 <Welkin> ?ops
07:55:33 <lambdabot> Maybe you meant: pl oeis docs
07:55:37 <Welkin> or whatever that trigger is
07:56:09 <Welkin> we've got a pm spammer named mattie18 in here
07:57:40 <Solonarv> @where ops
07:57:41 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
07:57:47 <Welkin> lol Solonarv 
07:57:54 <normal_user> Hi, Welkin
07:58:14 <glguy> Solonarv: I'm up
07:59:31 * shapr awakens
08:00:02 <Solonarv> Welkin: ops are here! now why did I call them?
08:02:20 <saml> how do you build lambda?
08:02:24 <saml> aws lambda
08:02:49 <merijn> saml: That seems like a...not Haskell topic?
08:04:49 <saml> yeah it's cloud serverless. but haskell might be able to do this as well
08:10:34 <xenon-> hi. what http package has the ability to: 1) set custom user agent 2) connect through tor?
08:10:58 <gentauro> saml: serach for AWS, Haskell and Nike. U welcome ;)
08:11:14 <gentauro> (I kind of find it amazing that Nike as a company uses Haskell)
08:11:50 <gentauro> saml: https://github.com/Nike-Inc/hal
08:12:05 <saml> i wanna build aws lambda like thingy on my own, instead of using aws lambda
08:12:16 <gentauro> oh
08:14:17 * hackage keycloak-hs 0.0.0.1 -   https://hackage.haskell.org/package/keycloak-hs-0.0.0.1 (CorentinDupont)
08:20:35 <gentauro> anybody know why there isn't a `waitAll` (`[Async a] -> IO [a]`)? -> http://hackage.haskell.org/package/async-2.2.1/docs/Control-Concurrent-Async.html#v:waitAny
08:21:10 <merijn> gentauro: That's just "mapM wait"? :p
08:21:17 * hackage ftree 0.1.5 - Depth-typed functor-based trees, both top-down and bottom-up  https://hackage.haskell.org/package/ftree-0.1.5 (ConalElliott)
08:21:29 <gentauro> xD
08:21:56 <merijn> gentauro: You need waitAny for fancy short-circuiting, for waitAll you have to wait for all of them anyway, so there's no fancy logic needed
08:22:17 <Solonarv> yea 'traverse wait' is all you need
08:23:20 <Welkin> isn't wait waitAny the same as race?
08:23:23 <gentauro> and I'm guessing then that `mapM_ wait` will just wait for all to finish, but dischards return values
08:23:54 <nihilsh> does anyone know how to ensure executables produced by a package dependency doesn't end up in your .stack-work folder? 
08:24:09 <Solonarv> Welkin: they're similar, yes
08:26:46 <merijn> gentauro: Yes
08:27:18 <Solonarv> Welkin: roughly: either id id <$> race x y = snd <$> waitAny [async x, async y]
08:29:52 <infandum> I am getting a different eigenvectors (different sign grouping of positive and negative, not just negated vectors) between R and Haskell's hmatrix library. Why?
08:30:57 <feuerbach> There was recently a clever blog post about implementing list functions like 'tail', which I cannot find. Does anyone remember it?
08:32:11 <hyperisco> tail is not a clever function. Doesn't ring a bell sorry.
08:32:31 <feuerbach> sorry, not tail, init
08:32:56 <feuerbach> and/or last.
08:33:26 <hyperisco> Ah well I remember reading something clever about lists. I think an example was taking every other element starting from the last. I read that years ago though.
08:36:17 <c_wraith> feuerbach, I don't know what post you are referring to, but do you mean fun with zipWith const?
08:36:29 <hyperisco> (Char -> Bool) -> Parsec Text () m Text  seems like a reasonable Text parser. Is it not available or am I missing it?
08:36:50 <feuerbach> c_wraith: some kind of zip was definitely involved!
08:37:03 <merijn> oh, quchen's post on zipWith const
08:37:17 <merijn> feuerbach: https://github.com/quchen/articles/blob/master/2018-11-22_zipWith_const.md
08:37:34 <c_wraith> huh, that's way more recently than I learned about that trick.
08:37:34 <feuerbach> yes, that is it! thanks everyone
08:40:09 <merijn> c_wraith: It's a super old trick
08:40:30 <merijn> c_wraith: Hell, I wrote an example 3 years ago and I learned it from some source that was several years old at the time
08:40:33 <merijn> c_wraith: https://gist.github.com/merijn/c163cc106fd245d1cf2e
08:41:30 <c_wraith> yeah, I picked it up in... 2012, I think.
08:42:30 <Solonarv> hyperisco: should be names something like 'satisfy', perhaps?
08:42:36 <hyperisco> Someone should apply the thinking of those tricks to "tie" https://hackage.haskell.org/package/data-list-zigzag-0.1.1.1/docs/src/Data-List-ZigZag.html#line-424
08:42:38 <Solonarv> s/names/named/
08:42:47 * hackage keycloak-hs 0.0.0.2 -   https://hackage.haskell.org/package/keycloak-hs-0.0.0.2 (CorentinDupont)
08:43:38 <c_wraith> Solonarv, only if the right instances exist. I think I recall megaparsec instances for Text being... not what I expected.
08:43:47 <hyperisco> maybe with  These a b -> Maybe c  instead so it was more like an unfolding you could do some interesting things
08:44:22 <hyperisco> with that it would also generalise zipWith
08:44:48 <hyperisco> mm actually not quite, with infinite lists
08:45:17 * hackage brok 0.1.5.0 - Finds broken links in text files  https://hackage.haskell.org/package/brok-0.1.5.0 (smallhadroncollider)
08:48:16 <hyperisco> Solonarv, satisfy gives one Char at a time, which then must be packed.
08:48:26 <Solonarv> ah, right
08:49:28 <hyperisco> Parsec is fundamentally built on the Steam, so what I am talking about would have to be special to Text.
08:49:28 <day> dminuoso: regarding the infinite list time complexity O(n) from earlier. If it isnt O(n) what is it? (11:18 utc)
08:50:01 <hyperisco> What is the time complexity of an infinite list?
08:50:15 <hyperisco> Sounds like one of those unladen swallow questions.
08:50:46 <day> which is why it was directed to a specific person + a time stamp to give context
08:51:40 <hyperisco> Sometimes humour is only possible with context and sometimes it is only possible without it. :)
08:51:56 <Welkin> on the Steam?
08:52:02 <Welkin> does it run CS:GO?
09:05:07 <hyperisco> Is HIE supposed to let me automatically add imports? I ask because when I hit ctrl+space after a name such as "pure" I receive no intelligent suggestions. I am using VSCode.
09:05:49 <hyperisco> I am seeing compiler errors reported as red squiggles though.
09:08:21 <hyperisco> ghcmod is correctly reporting where I can import these definitions from.
09:08:28 <xenon-> c_wraith, can you expand on what you said earlier? "I think I recall megaparsec instances for Text being... not what I expected."
09:08:42 <xenon-> does it use String internally, or something?
09:13:00 <c_wraith> xenon-, nothing like that. literally all I remember is being surprised at the instances that existed, rather than their implementation.
09:15:20 <MarcelineVQ> I was surprised there wasn't a Stream [a] instance since parsec has one
09:32:47 * hackage dmcc 1.1.0.1 - AVAYA DMCC API bindings and WebSockets server for AVAYA  https://hackage.haskell.org/package/dmcc-1.1.0.1 (DmitryDzhus)
09:38:47 * hackage diagrams-builder 0.8.0.4 - hint-based build service for the diagrams graphics EDSL.  https://hackage.haskell.org/package/diagrams-builder-0.8.0.4 (BrentYorgey)
09:44:16 <infinisil> MarcelineVQ: xenon-: c_wraith: I once made two WIP PRs (<https://github.com/mrkkrp/megaparsec/pull/335> <https://github.com/mrkkrp/megaparsec/pull/336>) for two approaches to be able to use ~ [a] with megaparsec, but they were no good (for reasons I understand)
09:44:22 <infinisil> And then I got bored and didn't do the way that would've been accepted :P
09:50:17 <Denommus> just want to share how much I love Haskell
09:50:30 <Denommus> I've been more productive in scripting in Haskell than in either Ruby or Python
09:50:46 <Denommus> and thanks to optparse-applicative, my CLI is beautiful
09:51:30 <Welkin> what you mean to say is the joy of functional programming with a good type system
09:52:50 <Welkin> but yes, haskell has some really great libraries
09:54:30 <c_wraith> infinisil, yeah, I did that once too. it also was bad, so I didn't even create a PR
09:58:40 <Ariakenom> Denommus: Nice to hear! How did you get started?
09:59:22 <Denommus> Ariakenom: I got started like 4 or 5 years ago, doing programming challenges to learn it
09:59:35 <Denommus> now I use it professionally whenever I can
10:06:32 <Ariakenom> Denommus: nice. second favourite library? after optparse-applicative
10:07:08 <Denommus> Ariakenom: lens, probably
10:07:18 <Denommus> or wires
10:09:26 <c_wraith> huh. is that a different take on the ideas from netwire?
10:10:11 <Denommus> c_wraith: it doesn't have inhibition (which makes it better by a mile)
10:10:27 <NemesisD> folks that use nix: do you use it to actually build your packages or just to set up system dependencies? 
10:10:32 <Denommus> if you want to have something like inhibition you need to use Maybe
10:10:47 <Welkin> wires was ertes' evolution of netwire
10:10:53 <Denommus> NemesisD: I use stack with it, so that I can include my external dependencies in stack.yaml
10:12:34 <NemesisD> Denommus: so you use the stack nix integration? do you use the `shell-file` option? my concern with the `packages` option is that it just forces all nix interactions to go through stack. you can't drop into the environment that stack is using to build
10:17:17 * hackage brok 0.1.6.0 - Finds broken links in text files  https://hackage.haskell.org/package/brok-0.1.6.0 (smallhadroncollider)
10:17:33 <infinisil> NemesisD: I use it to both build it and set up a dev environment
10:18:01 <infinisil> So I have two ways to build: nix-build (pure, but slower), or nix-shell and then cabal build
10:18:11 <NemesisD> and those are equivalent?
10:18:28 <infinisil> NemesisD: Mostly, cabal build just has lots of potential impurities
10:18:37 <infinisil> But it's faster
10:18:49 <NemesisD> infinisil: are you using cabal2nix to translate your local cabal packages into nix derivations?
10:18:51 <cocreature> and it will pick up your dependencies inside the nix shell
10:18:54 <infinisil> While nix-build provides an actual nix build, which you can use in your other nix stuff
10:19:17 <infinisil> NemesisD: Implicitly yes, through pkgs.haskellPackages.callCabal2nix
10:20:30 <infinisil> NemesisD: Here's a typical Nix file i use for Haskell: https://github.com/Infinisil/soph/blob/master/default.nix
10:20:52 <infinisil> And the shell.nix next to it
10:25:20 <johnw> infinisil: ah, you can do much better :)
10:25:56 <infinisil> johnw: Like?
10:25:56 <johnw> try this for a template: https://github.com/jwiegley/recursors/blob/master/default.nix
10:26:05 <johnw> no shell.nix needed (it works for both nix-build and nix-shell)
10:26:30 <johnw> it also allows an `overrides = self: super: {};` attribute, for even trickier overrides
10:26:31 <infinisil> johnw: I couldn't use developPackage for some reason
10:26:40 <infinisil> It's not very flexible
10:26:46 <infinisil> Maybe that was for a different project
10:26:49 <johnw> maybe
10:26:57 <johnw> i've been using it for about 15 different projects so far
10:27:12 <infinisil> But these nix files I have these are like my 5th revision, working great for everything I need
10:27:20 <johnw> sourdough nix
10:27:23 <johnw> i totally understand
10:27:53 <infinisil> Maybe it's time to make the One-Ultimate-Way for Nix + Haskell
10:28:05 <infinisil> :o
10:29:09 <boj> sourdough nix. as an alaskan i can appreciate that
10:29:16 <johnw> I've found that for most Haskell packages, I don't need a default.nix at all
10:29:52 <johnw> I have a global function called `packageDeps`, and run `nix-shell -p "$NIXPKGS.packageDeps $PWD"` (where NIXPKGS is in my environment, and imports my custom config)
10:30:02 <Denommus> NemesisD: I do not use shell-file
10:30:06 <johnw> as long as no overriding is needed, it's like having the default
10:30:08 <johnw> boj: :)
10:30:13 <Denommus> I don't mind having to go through stack, because I'm the only in the company who uses nix
10:30:27 <Denommus> nix just makes the job of external dependencies easier and that's it
10:31:20 <boj> well, it also helps pin your whole set of hackage packages for consistency
10:31:36 <infinisil> johnw: I wish we'd have an automatic haskell package fixer for nixpkgs
10:31:59 <johnw> infinisil: you mean, automatically try doJailbreak and then dontCheck and then both, etc.?
10:32:08 <Solonarv> stack pins packages too by default, IIRC
10:32:10 <infinisil> johnw: Yeah something like that, but a bit more smartly
10:32:16 <infinisil> Like looking at the error messages
10:32:27 <infinisil> Or trying to do some version resolution
10:33:17 * hackage wai-cli 0.2.0 - Command line runner for Wai apps (using Warp) with TLS, CGI, socket activation & graceful shutdown  https://hackage.haskell.org/package/wai-cli-0.2.0 (myfreeweb)
10:35:56 <NemesisD> infinisil: do you have any tips for debugging expressions. i find i have to do overrides and such but if i make a mistake, the error message usually doesn't help me. i feel like i need a way to inspect the expression to see how my overrides are being evaluated
10:51:21 <hyperisco> Hrm, HIE on VSCode seems really buggy. It is frequently replacing what I type with random stuff =\
10:53:58 <glguy> hyperisco: Just to check... were you not typing random stuff in also?
10:54:35 <hyperisco> I want it to keep *my* random stuff though, not substitute its own!
10:55:00 <hyperisco> It seems to erroneously trigger undo actions and paste actions.
10:57:00 <hyperisco> No features seem to work other than putting red squiggles under error sites. That's better than nothing though.
10:58:31 <hyperisco> The #1 productivity booster for me is automatically managed imports. I am spoiled by this in PureScript, but it really does save substantial time.
10:58:53 <hyperisco> I don't have to use an external tool to lookup a symbol to recall the package name to type it into my imports list manually.
10:59:50 <hyperisco> Well, that after the red squiggles.
11:11:44 <dogui> Is there any website where one can inspect GHC sources? e.g. in the spirit of: https://elixir.bootlin.com/linux/latest/source
11:12:08 <dogui> perhaps I should ask in #ghc instead..
11:12:16 <ammar2> http://git.haskell.org/ghc.git/tree
11:12:38 <ammar2> github mirror here https://github.com/ghc/ghc
11:12:54 <dogui> right, but those are not linked to definitions and whatnot
11:13:00 <dogui> (forgot to mention that :) )
11:13:28 <Welkin> '(you forgot the ')
11:13:29 <dogui> in the linux one above you click on some identifier to go to its definition and uses
11:13:37 <ammar2> aah
11:13:51 <ammar2> probably nothing like that just hosted on the web
11:13:56 <ammar2> you'd likely have to make one locally
11:16:23 <dogui> right.. I usually use ctags, but I'm regenerating them now and have to wait :)
11:16:26 <dogui> thanks!
11:30:53 <Solonarv> ammar2m, dogui: GHC development has moved to https://gitlab.haskell.org/ghc/ghc
11:31:46 <Welkin> what happened to trac/phabricator?
11:33:02 <infinisil> NemesisD: Can we go to #nixos? It's much more topical there
11:33:47 <Solonarv> I don't remember the details, tbh. You can check the ghc-devs mailing list archives, and I think there might be a blog post or two summarizing the rationale.
11:44:27 <Ari123> ?
12:02:37 <hyperisco> Well, that after the red squiggles.
13:07:37 <gentauro> is there any way to profile how many `lightweight` threads are beeing spawned? (`forkIO`/`forkFinally`)?
13:08:35 <Rembane> I think Threadscope can tell you.
13:08:37 <Rembane> IIRC.
13:08:53 <Rembane> https://wiki.haskell.org/ThreadScope
13:09:17 * hackage invertible-grammar 0.1.2 - Invertible parsing combinators framework  https://hackage.haskell.org/package/invertible-grammar-0.1.2 (EugeneSmolanka)
13:11:17 * hackage sexp-grammar 2.0.2 - Invertible grammar combinators for S-expressions  https://hackage.haskell.org/package/sexp-grammar-2.0.2 (EugeneSmolanka)
13:11:57 <gentauro> Rembane: cool, I will give it a try
13:15:06 <Rembane> gentauro: Good luck! 
13:19:46 <gentauro> `Recommended action: try adding the following to your extra-deps in ...` - template-haskell-2.13.0.0
13:19:54 <gentauro> already added, no work :-|
13:20:06 <gentauro> I will look at it tomorrow
13:20:16 <gentauro> to tired to fight stack/cabal issues atm
13:52:47 * hackage beam-core 0.7.2.3 - Type-safe, feature-complete SQL query and manipulation interface for Haskell  https://hackage.haskell.org/package/beam-core-0.7.2.3 (TravisAthougies)
14:07:47 * hackage beam-migrate 0.3.2.2 - SQL DDL support and migrations support library for Beam  https://hackage.haskell.org/package/beam-migrate-0.3.2.2 (TravisAthougies)
14:16:17 * hackage beam-postgres 0.3.2.3 - Connection layer between beam and postgres  https://hackage.haskell.org/package/beam-postgres-0.3.2.3 (TravisAthougies)
14:17:47 * hackage smith-cli 0.0.1 - Command line tool for <https://smith.st/ Smith>.  https://hackage.haskell.org/package/smith-cli-0.0.1 (MarkHibberd)
14:32:47 * hackage beam-sqlite 0.3.2.4 - Beam driver for SQLite  https://hackage.haskell.org/package/beam-sqlite-0.3.2.4 (TravisAthougies)
14:40:14 <o1lo01ol1o> I have a few nested records that, for debugging purposes, I'd like to format stderr-friendly way.  Are there any packages around for that?  Something like a `ShowStylishASCII` typeclass or something?
14:40:46 <zachk> ppShow ?
14:40:53 <zachk> @hoohle ppShow
14:40:54 <lambdabot> Text.Show.Pretty ppShow :: Show a => a -> String
14:40:54 <lambdabot> Hledger.Utils.Debug ppShow :: Show a => a -> String
14:40:54 <lambdabot> Hledger.Utils.Debug dbgppshow :: Show a => Int -> String -> a -> a
14:41:31 <zachk> import Text.Show.Pretty 
14:41:41 <zachk> its quite readable
14:42:34 <sm> Hledger.Utils.Debug has some helpers built on pretty-show
14:43:18 <o1lo01ol1o> ah, cool, i'll look at it
14:43:46 <o1lo01ol1o> thx
14:45:46 <sm> because pretty-show's pPrint and ppShow are impossible to remember 
14:47:15 <zachk> ppShow just seems like a bad name to me 
14:47:21 <zachk> I like the function though
14:49:26 <sm> it's really useful
14:49:53 <sm> but it can't print everything, sometimes you have to mess with your Show instances to help it
14:51:57 <sm> eg showing things it can't handle, like Day, as a string instead
15:44:47 * hackage hlivy 1.0.1 - Client library for the Apache Livy REST API  https://hackage.haskell.org/package/hlivy-1.0.1 (ddonohue)
16:14:24 <NemesisD> how do you override the ghc version in a nix package? i'm using shellFor in my shell.nix but its using a newer GHC than i can support
16:24:02 <Zemyla> Is there a mutable hashmap with an amortized O(1) read/write time?
16:25:06 <Solonarv> Zemyla: https://hackage.haskell.org/package/stm-containers
16:25:32 <Zemyla> I was wanting something that worked in ST, not STM.
16:26:52 <Solonarv> @hackage hashtables
16:26:52 <lambdabot> http://hackage.haskell.org/package/hashtables
16:27:18 <Solonarv> seems like what you're looking for
16:35:20 <c_wraith> Zemyla, only with a finite key set.
16:36:32 <c_wraith> which is a silly version of big-O analysis.
16:40:25 <gentauro> :i ST
16:40:33 <gentauro> > :i ST
16:40:36 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
16:40:41 <gentauro> % :i ST
16:40:41 <yahb> gentauro: type role ST nominal representational; newtype ST s a = GHC.ST.ST (GHC.ST.STRep s a); -- Defined in `GHC.ST'; instance Applicative (ST s) -- Defined in `GHC.ST'; instance Functor (ST s) -- Defined in `GHC.ST'; instance Monad (ST s) -- Defined in `GHC.ST'; instance Monoid a => Monoid (ST s a) -- Defined in `GHC.ST'; instance Semigroup a => Semigroup (ST s a) -- Defined in `GHC.ST'; instance Show (ST s a
16:40:58 <gentauro> % :i STM
16:40:58 <yahb> gentauro: newtype STM a = GHC.Conc.Sync.STM (State# RealWorld -> (# State# RealWorld, a #)) -- Defined in `GHC.Conc.Sync'; instance Alternative STM -- Defined in `GHC.Conc.Sync'; instance Applicative STM -- Defined in `GHC.Conc.Sync'; instance Functor STM -- Defined in `GHC.Conc.Sync'; instance Monad STM -- Defined in `GHC.Conc.Sync'; instance MonadPlus STM -- Defined in `GHC.Conc.Sync'; instance MonadFix STM --
16:43:24 <gentauro> and the winner is yahb 
16:48:11 <zachk> @info ST
16:48:11 <lambdabot> ST
16:48:16 <zachk> @info STM
16:48:16 <lambdabot> STM
16:48:23 <zachk> @info Anything
16:48:23 <lambdabot> Anything
16:48:32 <zachk> echo echo echo :(
16:51:01 <geekosaur> @info do { a <- b; return a }
16:51:01 <lambdabot> b >>= \ a -> return a
16:51:22 <geekosaur> there is no @info, edit correction finds @undo
16:53:02 <slack1256> I got a list like [TMVar], I want to read the first TMVar that is not empty (sort of like a select/poll).
16:53:32 <slack1256> I've got problems trying to come with a Foldable/Traversable way to do that. The `retry` side-effect and blocking get in the way.
16:54:13 <Solonarv> where's TMVar from?
16:54:29 <slack1256> Control.Concurrent.STM.TMVar 
16:58:56 <AfC> How does one talk to an Oracle database from Haskell?
16:59:04 <hpc> hdbc
16:59:20 <AfC> All things being equal I would prefer not to have to, but is what it is.
16:59:34 <hpc> there might be better packages nowadays, but that's the one i am familiar with
16:59:46 <Solonarv> slack1256: it sounds like 'asum . fmap takeTMVar' should work
17:00:19 <Solonarv> % :t asum . fmap takeTMVar
17:00:19 <yahb> Solonarv: (Foldable t, Functor t) => t (TMVar a) -> STM a
17:00:41 <Solonarv> if you feel the need to be very slightly more general:
17:01:04 <Solonarv> % :t getAlt . foldMap (Alt . takeTMVar)
17:01:04 <boj> AfC: look at odbc by fcomplete as well, we are using it to talk to MSSQL and IBM DB2. the hdbc library is buggy from what i understand
17:01:04 <yahb> Solonarv: Foldable t => t (TMVar a) -> STM a
17:01:28 <hpc> what bugs does it have?
17:01:39 <AfC> boj: thanks
17:01:40 <slack1256> Solonarv: The Alt newtype is what I needed, thanks!
17:03:53 <AfC> I was kinda hoping to find an hasql backend for Oracle
17:04:58 <boj> AfC: sadly you won't find much support for stuff beyond postgresql (mysql, sqllite)
17:05:23 <AfC> Yeah
17:05:26 <AfC> Hm
17:19:50 <AfC> boj: well, we have a production Oracle installation we can test against, so we can give your package a try.
17:23:46 <boj> AfC: i stake no claims to that package, we just use it to access legacy databaes :)
18:05:37 <DrLambda> :t sepBy
18:05:38 <lambdabot> Eq a => [a] -> [a] -> [[a]]
18:06:34 <DrLambda> :t noneOf
18:06:36 <lambdabot> Getting Any s a -> (a -> Bool) -> s -> Bool
18:14:39 <Solonarv> DrLambda: what are you looking for? perhaps someone knows the function you're trying to find
18:27:37 <Barnabas[m]> Is there a way to search hackage (or any collection of packages) for usage of a function? Say if I wanted to find all modules which use Data.Text.unpack
18:28:49 <Solonarv> you could download the sources and use 'grep' or a similar tool
18:29:20 <Solonarv> you can make this faster by only downloading the source of packages that actually depend on (for example) text
18:35:41 <Barnabas[m]> I'd like it to understand the structure of haskell source instead of doing plain text search
19:00:48 <maerwald> Barnabas[m]: you could create a project which depends on acme-everything and then use codex to search for tags in dependencies
19:06:57 <Barnabas[m]> maerwald: thanks, I'll take a look at codex
19:19:19 <Barnabas[m]> oh, here's something: https://github.com/alexwl/haskell-code-explorer
19:21:08 <Welkin> nice link
19:52:55 <maerwald> unfortunately it's not static site
20:06:28 <slack1256> Anyway to visualize the haskell threads on the rts?
20:11:15 <Welkin> threadscope
20:48:08 <timt0m91> >
20:49:47 * hackage oset 0.4.0.0 - An insertion-order-preserving set  https://hackage.haskell.org/package/oset-0.4.0.0 (rcook)
22:39:17 * hackage stylish-cabal 0.5.0.0 - Format Cabal files  https://hackage.haskell.org/package/stylish-cabal-0.5.0.0 (JudeTaylor)
