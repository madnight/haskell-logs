00:07:12 <[exa]> chaoxu: a bit of work with overlapping/flexible instances or something similar should allow you to define a proper Nub class with automagic instances derived from Eq and Ord
00:09:03 <[exa]> chaoxu: btw the 2 method possibilities are not comprehensive, consider e.g. string-like things that can be efficiently nubbed using tries, other things can be hashed, and for some types (like floats) I'd consider nub=id a valid implementation
00:16:56 <chaoxu> [exa]: thanks, I see this is more complicated than I thought...
00:17:06 <dminuoso> I wonder, couldn't you supply rewrite rules that trigger if a contraint is satisfied?
00:19:12 <dminuoso> i.e. {-# RULES "nub" forall (x :: Ord a => a). nub x = nubWithOrd' x #-}
00:20:16 <[exa]> dminuoso: the type system works exactly the other way though
00:22:38 <dminuoso> [exa]: What do you mean?
00:22:40 <[exa]> chaoxu: the main problem is that there's no single obvious choice of the nubbing algorithm for any data, so I guess the whole thing should _not_ be completely transparent for the programmer
00:22:58 <dminuoso> [exa]: Oh I dont care about the usefulness here, just wondering from a technical perspective.
00:23:09 <dminuoso> Just tried a demo program with such a rewrite rule, but it didnt fire.
00:24:03 <[exa]> dminuoso: iirc the typesystem first asks 'nub' about what constraints it requires, then uses the constraint everywhere. So when it's finally known whether eg. the Eq can be satisfied, you can't get Ord there without backtracking
00:25:15 <[exa]> (but perhaps you could pass in a coercion and let nub use it. this ^^^ is how it would work with a simple THIH-style system)
00:26:12 <chaoxu> I was thinking of having default nub, and switch to more specific nub for different types, but then that is exactly why one should implement a typeclass Nub...
00:26:25 <dminuoso> [exa]: The rewriter could go back into the typechecker.
00:27:11 <[exa]> dminuoso: not sure about that, I always thought that the whole main purpose of good typesystems is to avoid this sort of backtracking :]
00:27:55 <[exa]> dminuoso: but certainly not saying it's not somehow possible, it's just a bit anti-patternish for the normal way of inference
00:28:05 <[exa]> chaoxu: well that's a perfect definition of overloading, right? :]
00:28:34 <dminuoso> [exa]: But you cant select instances based on typeclass membership, right?
00:29:16 <dminuoso> Or is something like `instance Foo (forall a. Ord a => a)` possible?
00:29:30 <dminuoso> % class Foo a
00:29:31 <yahb> dminuoso: 
00:29:39 <dminuoso> % instance Foo (forall a. Ord a => a)
00:29:39 <yahb> dminuoso: ; <interactive>:7:10: error:; * Illegal polymorphic type: forall a. Ord a => a; * In the instance declaration for `Foo (forall a. Ord a => a)'
00:30:46 <[exa]> dminuoso: well having 2 instances `Eq a => Nub [a]` and `Ord a => Nub [a]` is certainly forbidden by default
00:30:50 <dminuoso> I think this would not work in an open-world assumption right?
00:31:04 <dminuoso> [exa]: Right, thats because the instance constraint has no effect on instance selection.
00:31:17 <dminuoso> I guess you could work around it with newtype wrappers
00:32:05 <[exa]> dminuoso: there's no problem with that if you can survive the fact you're programming prolog by then
00:32:11 <[exa]> :]
00:33:48 <[exa]> it probably qualifies for UndecidableInstances though
00:34:15 <[exa]> newtype wrappers or associated types would be much better I guess
00:37:25 <dminuoso> [exa]: How does instance Foo (forall a. Ord a => a) relate to prolog?
00:37:35 <dminuoso> though wait..
00:37:42 <dminuoso> The forall quantification here does not mean what I think it means.
00:38:13 <[exa]> not sure how that would be matched
00:38:39 <dminuoso> [exa]: Well, usually the quantification is to the lfet.
00:38:45 <dminuoso> So instance forall a. Foo a
00:38:57 <dminuoso> In the instance head `a` is not polymorphic
00:39:25 <dminuoso> It has some type `exists a. a`
00:40:35 <dminuoso> % :set -XImpredicativeTypes
00:40:35 <yahb> dminuoso: 
00:40:41 <dminuoso> % instance Foo (forall a. Ord a => a)
00:40:41 <yahb> dminuoso: ; <interactive>:9:10: error:; * Illegal polymorphic type: forall a. Ord a => a; * In the instance declaration for `Foo (forall a. Ord a => a)'
01:26:07 * hackage elm-street 0.0.0 - Crossing the road between Haskell and Elm  https://hackage.haskell.org/package/elm-street-0.0.0 (shersh)
01:35:56 <PragCypher> could anyone recommend a library for printing text nicely to the console?  For instance, I would like to set a max width, and avoid breaking words on new lines.
01:36:33 <haasn> I can't seem to make GHC's brain explode anymore :9
01:36:36 <haasn> did they remove this feature?
01:36:37 <haasn> :(
01:36:58 <haasn> http://git.haskell.org/ghc.git/commit/15b9bf4ba4ab47e6809bf2b3b36ec16e502aea72 NOOOOOOOO
01:40:45 <Taneb> PragCypher: maybe "pretty"?
01:40:48 <Taneb> @hackage pretty
01:40:49 <lambdabot> http://hackage.haskell.org/package/pretty
01:43:08 <PragCypher> Taneb: thanks, checking it out
01:43:41 <sicklorkin> Does anyone have `rename` working with haskell ide engine (LSP backend)
02:05:07 * hackage sv 1.3.0.1 - Encode and decode separated values (CSV, PSV, ...)  https://hackage.haskell.org/package/sv-1.3.0.1 (qfpl)
02:27:52 <zincy> How does one determine the cardinality of functions?
02:28:09 <zincy> Say for example Bool -> Maybe Bool
02:28:22 <bor0> length domain + length codomain?
02:28:35 <zincy> would it be |2| * |4|
02:28:41 <zincy> sorry not * but exp
02:29:19 <bor0> why 4 for Maybe Bool?
02:29:28 <zincy> Is it not length domain to the power of the length of codomain?
02:30:00 <zincy> Since for every inhabitant of the domain any possible inhabitant of the domain can be given
02:32:32 <Ariakenom> zincy: I think so yeah
02:33:13 <zincy> Thanks
02:36:21 <phadej> |A -> B| = |B| ^ |A|
02:39:34 <bor0> phadej, can you elaborate on that? the cartesian set of f : Bool -> Maybe Bool is [ (True, Just True), (True, Just False), (True, Nothing), (False, Just True), (False, Just False), (False, Nothing) ] which is exactly 6 elements (|2| * |3|)
02:40:32 <Taneb> bor0: that's (Bool, Maybe Bool)
02:40:48 <bor0> yes, but how is it different from Bool -> Maybe Bool?
02:41:14 <bor0> it's just f uncurried, no?
02:41:27 <phadej> how (1,2) is different from "succ"
02:41:51 <phadej> how (1,2) :: (Int, Int) is different from "succ :: Int -> Int"
02:42:50 <PragCypher> Taneb:  Any idea how I would use the Pretty Print library to print a paragraph with a set width?
02:43:26 <hc> Hi all, can anyone recommend a production ready haskell library for logistic regression? :-)
02:43:56 <Taneb> PragCypher: combination of unwords, hsep, and renderStyle?
02:43:57 <phadej> PragCypher: check fsep and unwords
02:44:21 <PragCypher> phadej, Taneb: great, thanks guys :)
02:47:38 <bor0> phadej, well, (1, 2) is just a single element, but to be complete with that example I don't see how [ (a, a + 1) | a <- [0..] ] ++ [ (-a, -a + 1) | a <- [0..] ] is different from succ
02:48:43 <phadej> bor0: that collection of pairs describe a single value of "Int -> Int", namely succ
02:48:49 <phadej> not all possible Int -> Int's
02:48:57 <phadej> so you'll need a list of lists of pairs
02:50:47 <phadej> returning to the Bool -> Maybe Bool, a function f True = Just False; f False = Nothing can be described by associative list: [(True, Just False), (False, Nothing)]
02:51:32 <phadej> but to enumerate all fucntions of type Bool -> Maybe Bool you'll need a list of such associative lists
02:51:47 <bor0> ok, I see it now :) thank you!
02:52:53 <bor0> just to be complete, I always thought |Maybe a| = |a| + 1, is that correct? (I was confused why they mentioned 4 earlier, instead of 3)
02:54:45 <zincy> Yeah that is  right
02:55:19 <zincy> Maybe is a sum type consisting of the additionally type variable a as well as the nullary constructor of Nothing.
02:56:47 <zincy> I mistakenly said 4 but it should have been 3
02:56:54 <zincy> For Maybe Bool
02:57:40 <zincy> So |Bool| -> |Maybe Bool|  is 2 ^ 3
02:57:56 <bor0> makes sense!
02:58:33 <zincy> Does isomorphic mean equivalent?
02:58:46 <tdammers> "isomorphic" means "of the same shape"
02:59:03 <zincy> Is there anything apart from shape at the type level?
02:59:15 <zincy> Shape being cardinality
03:00:33 <phadej> zincy: 3 ^ 2
03:01:20 <phadej> or wait
03:01:43 <phadej> yes, Bool -> Void has zero inhabitants
03:01:47 <phadej> 0 ^ 2 = 0
03:02:12 <zincy> Is Void not an inhabitant?
03:02:13 <phadej> Void -> Bool has one inhavbitant, absurd
03:02:43 <phadej> zincy: I fail to parse your question
03:02:46 <zincy> Void -> Bool must be 2 possible inhabitants
03:02:57 <phadej> please write me two :)
03:03:17 <zincy> Oh 
03:03:23 <zincy> Am I confusing types and terms
03:03:24 <phadej> ah, I see const True and const False
03:04:04 <zincy> so 3 ^ 2 ? :P
03:04:07 <phadej> no
03:04:11 <phadej> it's still `absurd`
03:04:19 <zincy> 2 ^ 3?
03:04:32 <bor0> 2 ^ 0 = 1, undefined :: Bool?
03:04:40 <phadej> ah, |A -> B| = |B| ^ |A|
03:05:00 <phadej> they flip
03:05:09 <phadej> you have to think it through and write examples
03:05:11 <phadej> don't use bool
03:05:15 <phadej> because 2 ^ 2 = 2 * 2
03:05:19 <phadej> that only confuses
03:05:23 <zincy> Yes
03:05:24 <phadej> use 0, 1 and 3
03:05:40 <zincy> Do the examples count as a proof?
03:06:03 <phadej> counter-examples count as refutal
03:06:24 <phadej> 3 ^ 2 = 9, 2 ^ 3 = 8
03:07:34 <zincy> Its weird how you can poke at the truth with proofs but you never really see truth.
03:09:29 <bor0> > [ ((True, a), (False, b)) | a <- [Nothing, Just False, Just True], b <- [Nothing, Just False, Just True] ]
03:09:31 <lambdabot>  [((True,Nothing),(False,Nothing)),((True,Nothing),(False,Just False)),((True...
03:09:38 <bor0> > length [ ((True, a), (False, b)) | a <- [Nothing, Just False, Just True], b <- [Nothing, Just False, Just True] ]
03:09:40 <lambdabot>  9
03:13:54 <zincy> Is the cardinality of `Either Bool (Bool, Maybe Bool) -> Bool` equal to 64?
03:23:15 <asheshambasta> Why does this happen? https://gist.github.com/asheshambasta/ad900e225cc05399df25c92a90052523 (basically, I'm trying to unwrap the URNCtx data-constructors; but somehow the types do not match up.)
03:24:30 <zincy> So is Void the type which has zero values?
03:24:47 <asheshambasta> (the level of nesting I'm expecting will be just one, so I can add a case statement there, but still, I'd have expected the types to check out trivially here. Or am I missing something?)
03:24:49 <zincy> What would its constructor look like?
03:25:26 <Axman6> void is defined as `data Void`
03:25:28 <asheshambasta> zincy: https://hackage.haskell.org/package/void-0.6.1/docs/Data-Void.html
03:25:42 <Axman6> the only values of type Void are bottom
03:26:29 <c_wraith> Note that there are at least three ways to write Void.  EmptyDataDecls gives you the most direct approach
03:26:46 <zincy> What is bottom?
03:26:58 <c_wraith> But there is also  newtype Void = Void Void  or newtype Void = Void { absurd :: a }
03:27:05 <Axman6> zincy: also I don't think it's 64, it should be: 2^(2 + (2 * 2 + 1))
03:27:27 <Axman6> bottom is things which don;t return, so errors of infinite loops generally
03:27:32 <Axman6> :t error "Hello"
03:27:34 <lambdabot> a
03:27:42 <zincy> Thanks
03:27:51 <zincy> So bottom isn't a value
03:27:58 <zincy> just a thunk returning an error
03:28:15 <Axman6> or one which never returns a value
03:28:23 <Axman6> > fix (1+)
03:28:26 <lambdabot>  *Exception: <<loop>>
03:28:51 <zincy> Back to my previous question apparrantly a->b in cardinality is actually b^a can someone confirm this?
03:28:56 <zincy> :t fix
03:28:57 <lambdabot> (a -> a) -> a
03:30:07 <opqdonut> zincy: yes
03:30:09 <asheshambasta> (got the issue, qualified imports do not affect class definition, but to call the function from the qualified import, you need to ensure that.)
03:30:24 <Axman6> it's the number of possible outputs to the power of the number of possible inputs
03:31:18 <zincy> Im confused why isnt it the other way around
03:32:42 <Axman6> have a go at enumerating all the possible functions of type: (Bool, Maybe Bool) -> Bool
03:32:53 <Axman6> (it may take a while)
03:33:05 <opqdonut> :D
03:33:34 <opqdonut> zincy: how many functions are there of type Bool -> ()? What about () -> Bool?
03:33:38 <bor0> https://gist.github.com/bor0/298469d5c3b054d4428684d0fe5cc6a8
03:33:54 <Axman6> that's probably a better question
03:34:29 <zincy> 1 and 2
03:34:47 <opqdonut> so 1^2 and 2^1
03:35:32 <Axman6> how about Maybe Bool -> Bool?
03:36:16 <zincy> 8
03:36:45 <Axman6> Did you try writing them all out?
03:36:52 <zincy> No
03:36:55 <zincy> maybe that is instructive
03:36:59 <zincy> ?
03:37:12 <c_wraith> opqdonut: oh hey, great examples.  I always have trouble remember which way the exponent goes, and () -> Bool/Bool -> () is a good reminders
03:37:14 <c_wraith> *reminder
03:37:29 <Axman6> it masy be... I haven't done it myself :)
03:37:33 <Axman6> may*
03:37:55 <zincy> It looks like a Tree!
03:38:44 <zincy> Each term that goes in can have any term from the resulting type outputted
03:39:04 <zincy> a ->b -> c
03:39:06 <zincy> :P
03:39:10 <zincy> Nested trees
03:42:33 <__monty__> data A = A | B (1 
03:43:58 <jaarod> I'm using typed-process like this: (out, err) <- readProcess_ (proc prog args); BS.putStr out; BS.putStr err
03:44:17 <jaarod> and, every now and then (it is unpredictable), program I am running deadlocks, and never returns
03:44:37 <jaarod> what can I do to avoid this?
03:44:41 <Axman6> probably because stderr isn;t being consumed
03:45:15 <Axman6> possibly a buffer filling up and the process waiting for the data to be read before continuing
03:45:27 <jaarod> Axman6, so what can I do? read stdout and stderr concurrently?
03:45:38 <jaarod> or read them line by line?
03:47:10 <jaarod> documentation says this, though: "One thing to point out is that, even though this is a lazy ByteString, it is not using any lazy I/O. When readProcess exits, the output has been fully generated, and is resident in memory. We only use a lazy ByteString instead of a strict one for better memory configuration (chunking into multiple smaller bits instead of one massive chunk of data)."
03:47:13 <Axman6> there's a few things you could do, yopu could fork a thread to read stderr while steoud is being read
03:47:31 <jaarod> so both stderr and stdout should have been read by the time readProcess_ returns
03:51:52 <Axman6> yeah not sure then
03:57:29 <c_wraith> jaarod: out of curiosity, do you have the same issues with process instead of typed process?  I've seen some other people reporting issues with typed-process and I'm wondering if it has an internal race condition somewhere.
03:58:04 <jaarod> c_wraith, interesting, I'll give process a try
03:58:29 <c_wraith> No guarantees, of course.  :)
04:02:36 <jaarod> I'm looking at process, and it seems I have to read from handles myself? I see no functions that read from stderr and stdout simultaneously
04:04:46 <c_wraith> that's correct.
04:05:07 <c_wraith> But that's exactly the part we're wondering if typed-process is getting wrong
04:05:26 <jaarod> indeed
04:22:37 * hackage ribosome 0.2.2.0 - api extensions for nvim-hs  https://hackage.haskell.org/package/ribosome-0.2.2.0 (tek)
04:27:37 * hackage alist 0.1.0.6 - lists with O(1) append  https://hackage.haskell.org/package/alist-0.1.0.6 (AlanHawkins)
04:32:10 <__monty__> zincy: You can represent a function B -> C as a tuple of length #(B), #(B) = 2 -> (C,C), #(B) = 3 -> (C,C,C); #(B) = 2 -> #(B -> C) = #((C,C)) = #(C) * #(C), #(B) = 3 -> #(B -> C) = #((C,C,C)) = #(C) * #(C) * #(C), so it's obviously #(C)^#(B). Does that help?
04:33:02 <zincy> wht does # denote?
04:33:23 <__monty__> Cardinality/size.
04:35:26 <zincy> What is (C,C) ?
04:54:33 <pagnol> the structure of dist-newstyle makes it so convenient to get at the binary
04:58:19 <__monty__> zincy: The tuple type (C,C).
05:22:43 <pong> isn't exponentiation defined as the size of the function space? so a^b = #(b -> a)
05:49:37 <dmwit> zincy: https://stackoverflow.com/q/54057022/791604
05:53:39 <dmwit> pagnol: v2-run makes it easier if what you want is to execute it; v2-install makes it easier if what you want is to put it in your PATH; v2-exec which executable-name makes it easier if what you want is to create a distribution tarball.
05:54:10 <dmwit> (I am assuming here there was a heavy note of sarcasm in your fingers as you typed that.)
05:56:59 <pagnol> dmwit, since my first attempt to dockerize my app resulted in a 2.5 gb image, I'm now using a multi-stage build where cabal is no longer there by the time I run the executable
05:57:46 <pagnol> I'm using $(find -executable) to get hold of the binary now
05:58:21 <pagnol> hadn't thought of v2-install... I guess I'll use that
05:58:35 <pagnol> oh haha
05:58:38 <pagnol> no cabal...
06:02:05 <pagnol> the image size is down to 150 mb, though
06:08:13 <fr33domlover> Is it a good idea to place functions/monadic actions in a Chan, as a way to send actions to another thread to compute?
06:08:38 <fr33domlover> (As opposed to sending some ADT and the receiving thread figures out the actions from that type)
06:09:10 <c_wraith> fr33domlover: nothing wrong with that
06:10:12 <fr33domlover> Thanks c_wraith :) I'm not sure I'll do that, because it doesn't capture the specific actions I want to send, instead the type allowing any action, but it's good to know it's okay to do that :)
06:10:19 <c_wraith> fr33domlover: in fact, it's a pretty common pattern when you want to isolate thread management from business logic as much as you can
06:10:24 <oo_miguel> I am overwhelmed by the number of available packages on hackage with overlapping functionality. Can someone give me some hints how to select a library (without having to ask here everytime :P )? I thought about checking if a hackage package is also present in stackage and favour this ones over others. Probably indicators as number of downloads, rating and last update are also significant.. Any other ideas? 
06:11:30 <c_wraith> oo_miguel: author is a big factor, though it's kind of circular.  You have to know who the good authors are to recognize the good authors.
06:11:36 <fr33domlover> oo_miguel, check which packages are maintained, how much documentation there is, how many depedent packages, and also experience from asking here :P
06:11:45 <fr33domlover> (And generally experience)
06:11:57 <fr33domlover> (Which you'll just get over time naturally)
06:12:25 <oo_miguel> c_wraith: fr33domlover: heh ,yeah. so I will just keep asking here... till I have the experience ;) thanks.
06:12:42 <bergey> oo_miguel: The usual ways that work in all languages - how long has it been around, are tickets / PRs getting addressed, does it have more than one contributor.
06:12:51 <bergey> I like http://packdeps.haskellers.com/reverse for understanding whether others have been willing to depend on a package. (And I agree with the other answers above.)
06:13:28 <c_wraith> An easier method than just "author" is to see if something is a dependency of any of the major packages.
06:13:42 <oo_miguel> ... but.. should I recognize  the presence of a pacakge on stackage, or is this arbitrary?
06:14:10 <oo_miguel> c_wraith: good idea, I did not think of that, thank you.
06:14:45 <oo_miguel> c_wraith: major projects I know of are: pandoc, parsec, ghc itself.. 
06:14:54 <c_wraith> most anyone can get their package on stackage easily enough.  It does imply the author is paying attention to keep it there, though.  So that matters.
06:15:53 <oo_miguel> c_wraith: ok I will keep that in mind
06:16:40 <oo_miguel> bergey: thank you for your suggestion and this valuable link!
06:24:38 * hackage panhandle 0.2.1.0 - Pandoc filter to unwrap nested blocks  https://hackage.haskell.org/package/panhandle-0.2.1.0 (chriswarbo)
07:09:02 <Guillaum> Does it exists an alternative at haskell-src-meta? I need to parse a String containing haskell source code and transform it to template haskell Exp. I had a look at the `ghc` library, and I found how to replace haskell-src-exts for parsing, but I don't find a solution to tranform an HsExpr to template haskell Exp.
07:49:41 <rfold> Does the address of a value inserted into a compact region with compactAdd ever change?
07:50:51 <rfold> I
07:51:31 <rfold> I'd like to store pointers to objects inside compact regions in a mutable unboxed vector in the hope to solve GC problems with mutable vectors. But I don't know if this is safe. :D
08:08:06 <mjrosenb> Does Data.Array not have a map function?
08:08:35 <Taneb> mjrosenb: it has a Functor instance so you can use fmap
08:09:33 <Taneb> There's also Data.Array.IArray.amap in case you want to use unboxed arrays too
08:09:45 <jaarod> are you sure you want Data.Array, and not Data.Vector?
08:10:23 <mjrosenb> ahh, sweet.
08:10:36 <mjrosenb> interesting, I have not heard of Data.Vector, let me investigate
08:11:56 <mjrosenb> I want array, since I'm using (Int,Int) as the index; I'd have to use Vector (Vecotr a) to do the same thing, and that has some drawbacks.
08:15:45 <dminuoso> mjrosenb: What drawbacks is that?
08:16:58 <Taneb> Raggedness, for one (you can't guarantee the inner vectors are the same length)
08:17:10 <mjrosenb> the type does less to guarantee that all of the rows are the same length
08:24:07 <heebo> just reading a the book , thinking in types really excellent for any intermediate haskell dev like myself
08:24:16 <rfold> The memory layout is inferior for some applications. But you can always use just Vector a and index with (i + w * j).
08:24:36 <dminuoso> heebo: Truth be told, even Python developers think in types all day long.
08:24:37 <heebo> just dont understand where all the advanced haskellers learned this stuff from.....
08:25:14 <Taneb> heebo: experimentation and listening to other advanced haskellers describe their experimentation
08:25:23 <locallycompact> also maths textbooks
08:25:29 <mjrosenb> hrm, Functor doesn't have something like zip :-(
08:25:39 * tdammers hasn't read a single math textbook that was relevant to Haskell
08:26:02 <locallycompact> the HoTT book cleared a lot of stuff up for me
08:26:12 <heebo> dminuoso: agreed .... but this is so much more revealing, I used to throw up a little bit whenever i saw the type applictor symbol (~) used, now not so much
08:26:31 <rfold> mjrosenb: Just fmap is insufficient to implement zip. You may want to look at MonadZip.
08:27:05 <rfold> mjrosenb: In some cases Applicative is sufficient, e.g. ZipList.
08:27:06 <dminuoso> mjrosenb: Functor encapsulates the mere notion of "being able to map over something" in some sensible way.
08:27:06 <dminuoso> mjrosenb: How would you zip two `IO Int` together?
08:27:07 <Taneb> mjrosenb: you might benefit from something whose type carries the size, like the vector-sized library
08:27:20 <Taneb> dminuoso: liftA2 (,)
08:27:23 <Taneb> ;)
08:27:29 <heebo> zip implies there is more than one element inside the context, Functor doesnt presume this
08:27:44 <dminuoso> heebo: it doesn't, strictly.
08:27:56 <dminuoso> Id say Applicative is what you are asking for.
08:28:02 <dminuoso> Applicative is just a twisted form of Monoidal.
08:28:19 <Taneb> mjrosenb: sadly Array doesn't have all that much functionality
08:28:53 <dminuoso> class Monoidal f where (<**>) :: f a -> f b -> f (a, b); unit :: f ()
08:29:02 <dminuoso> Which is isomorphic to Applicative.
08:29:17 <Taneb> dminuoso: only if you also have a Functor constraint
08:29:29 <dminuoso> Taneb: Oh mmm. Yeah true
08:29:34 <rfold> dminuoso: would need a Functor f constraint, otherwise you can't implement pure in terms of (<**>) and unit
08:29:37 <dminuoso> class Functor f => Monoidal f where (<**>) :: f a -> f b -> f (a, b); unit :: f ()
08:29:45 <dminuoso> rfold: Indeed yeah. :)
08:30:52 <rfold> (<*>) a b = uncurry ($) <$> (a <**> b); pure a = a <$ unit
08:31:25 <rfold> (<**>) a b = (,) <$> a <*> b; unit = pure ()
08:32:23 <dminuoso> Though I guess in a dream world we'd have Semimonoidal and Pointed
08:33:02 <rfold> Why is it not called Semigroupal?
08:33:11 <Welkin> groupoid?
08:37:07 <Solonarv> we do have Apply
08:37:26 <Solonarv> (but it's not in base)
08:37:38 <Solonarv> @hackage semigroupoids
08:37:39 <lambdabot> http://hackage.haskell.org/package/semigroupoids
08:37:54 <zincy> heebo: I second that. Thinking in types is amazing.
08:38:00 <zincy> Pun intended.
08:38:30 <zincy> Haskell is the gift that keeps giving.
08:38:56 <zincy> The first plateau is writing real programs. The second is type level programming.
08:39:28 <dminuoso> rfold: I was already in a dream world, so I fixed the "semigroup should be called semimonoid" issue too.
08:39:43 <rfold> And category should be called monoidoid.
08:39:57 <Welkin> a monodoid
08:40:08 <dminuoso> rfold: no?
08:40:20 <rfold> dminuoso: to be consistent with groupoid and semigroupoid
08:40:50 <dminuoso> rfold: What is is semigroupoid in your terminology?
08:41:30 <dminuoso> rfold: In my dreamworld "semimonoid" is just a "half monoid" that's missing the identity. "semigroup" would include semimonoids, magmas and monoids. ;)
08:42:14 <tdammers> semihemidemimonoidoidoid
08:42:39 * hackage cabal-rpm 0.13.1 - RPM packaging tool for Haskell Cabal-based packages  https://hackage.haskell.org/package/cabal-rpm-0.13.1 (JensPetersen)
08:42:41 <tdammers> given sufficient grant money, we can generate arbitrary concepts from those
08:43:35 <rfold> dminuoso: a Semigroupoid is Category without id
08:43:38 <dminuoso> given sufficient grant money we can also build a big laser.
08:44:13 <tdammers> tempting.
08:44:22 <dminuoso> rfold: Wasnt sure since I was in a made up world with new terminology, so..
08:44:40 <dminuoso> rfold: Then yes! A category would be a Monoidoid.
08:45:01 <[exa]> why not quartergroup
08:45:10 <Taneb> What's a mon?
08:45:29 <dminuoso> [exa]: well which part of the group would it be?
08:46:17 <dminuoso> Taneb: Are you suggesting we should establish new wordstems?
08:46:36 <[exa]> dminuoso: no idea, but some grant money could bring the answers!
08:46:52 <dminuoso> [exa]: The grant money is already budgeted towards the big laser.
08:46:58 <[exa]> anyway, are you guys writing grants too?
08:47:17 <Taneb> dminuoso: absolutely
08:48:44 <Taneb> So, there must be a correspondence semigroup : semigroupoid :: group : groupoid :: mon :: monoid
08:48:45 <dminuoso> Taneb: Since Algebraic structures are about abstract concepts, I propose abstract words. How do you like Fritzelbutz instead of Algebra?
08:49:02 <rfold> What would a semiringout be?
08:49:10 <rfold> What would a semiringoid be?
08:49:18 <Taneb> dminuoso: I prefer my vaguely Arab sounding maths terms to vaguely German ones
08:49:51 <dminuoso> Taneb: Im all ears.
08:50:00 <rfold> Taneb: such as "algebra" and "Algebra"?
08:50:22 <Taneb> If we're making up new words I'll suggest allagw
08:50:36 <Taneb> Anyway this is wildly off topic
08:52:39 <dminuoso> How do you folks work with cabal v2-* and nix at the same time? Do you ship your projects with a default.nix that provides ghc and cabal-install (plus any native libraries that are needed)?
08:53:05 <dminuoso> Do you rather supply a derivation to build the entire package?
08:53:20 <Cale> rfold: I found a reference that uses the term semiringoid to refer to a category whose Hom sets are commutative monoids, and whose End sets are semirings.
08:53:23 <rfold> dminuoso: I usually make the derivation build the package, but also allow the use of cabal through nix-shell, which I need for ghcid.
08:53:43 <Cale> (commutative monoids with bilinear composition)
08:54:02 <dminuoso> rfold: Do you still use v2-* inside the derivation?
08:54:14 <dminuoso> Or do you just rely on nix for deterministic builds?
08:54:35 <rfold> dminuoso: I just use haskellPackages.mkDerivation or haskellPackages.callPackage
08:55:14 <Cale> https://arxiv.org/pdf/1108.0375
08:55:18 <rfold> dminuoso: for example: https://github.com/rightfold/kroket/blob/master/default.nix#L8 and https://github.com/rightfold/kroket/blob/master/frituur/default.nix
08:57:07 <byorgey> Cale: ?
08:57:40 <rfold> Cale: thanks, will read
08:58:13 <Cale> (I don't know how much of that will be comprehensible otherwise, but the definition is there)
08:58:21 <byorgey> ah, sorry, I think I missed the context
08:58:38 <rfold> I don't understand anything it says, as expected
09:01:59 <dminuoso> rfold: Let me take a look, I switched to nix very recently so this is somewhat difficult still. :)
09:29:18 <Geraldus> Hi folks!
09:30:05 <Solonarv> Geraldus: hello1
09:30:55 <Geraldus> Looking for a way to display UTCTime stored in DB in local time for client users with Yesod
09:31:07 * hackage b9 0.5.63 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-0.5.63 (SvenHeyll)
09:31:25 <Geraldus> I believe there was some guide, question or article but can't find it out
09:34:51 <Geraldus> I believe there was some cookie based solution
09:39:35 <Geraldus> Can anyone share their experience how to render UTCTime date in local time?
09:41:31 <glguy> Geraldus: First get it into a ZonedTime: http://hackage.haskell.org/package/time-1.9.2/docs/Data-Time-LocalTime.html#v:utcToZonedTime
09:41:48 <glguy> Then you can format it as a string with http://hackage.haskell.org/package/time-1.9.2/docs/Data-Time-Format.html#v:formatTime
09:42:13 <Geraldus> glguy: many thanks!
09:43:10 <glguy> You can get the current time zone: http://hackage.haskell.org/package/time-1.9.2/docs/Data-Time-LocalTime.html#v:getCurrentTimeZone
09:44:21 <Geraldus> glguy: This is not exactly what I need, but I was unclear.  I have Yesod web app, which stored time in UTCTime.  I'm going to show dates in local time for web users (clients)
09:44:40 <Geraldus> So the question is how can I determine client timezone on server side
09:45:09 <glguy> Typically you'd ask the client to set their preferred time zone to see times displayed
09:45:38 <zincy> UTC is timezone agnostic no?
09:47:05 <Geraldus> glguy: Yeah, so I think the best way is to set timezone cookie
09:47:25 <Geraldus> I believe there was an article about this use case
09:48:18 <Geraldus> zincy: Maybe, what do you mean?
09:48:23 <glguy> Geraldus: You could also look to see if there is JavaScript functionality in browser for getting a preferred time zone
09:48:29 <c_wraith> if you don't mind using js, you can also just send a utc time and render it in the correct locale via js
09:49:53 <zincy> UTC values refer to the same time anywhere
09:49:55 <Geraldus> c_wraith: I looked for JS solution, but I don't like when things "magically" changing on page after loading.  This is a bit confusing for users
09:50:36 <glguy> zincy: The point is to *not* show the times in UTC
09:51:22 <Geraldus> Ok, thanks friends!
09:51:22 <zincy> glguy: My question was separate
09:51:47 <glguy> zincy: It's not really timezone agnostic, it's just a particular timezone
09:52:03 <zincy> So a universal timezone?
09:53:19 <glguy> zincy: Maybe this will help: https://www.timeanddate.com/time/gmt-utc-time.html
10:03:49 <Amras> is there a convenient (well-defined) way to specify a function and its inverse in a single type? Ideally something that already has definitions for common arithmetic
10:05:15 <hololeap> is there an equivalent of head and last for Seq?
10:06:42 <Amras> viewl, viewr, probably?
10:07:14 <Solonarv> Amras: Iso (from lens)
10:07:29 <hololeap> oh, ok
10:07:46 <MarcelineVQ> https://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Sequence.html#t:Seq note the patterns
10:10:27 <MarcelineVQ> can be used just like constructors, (\(x :<| xs) -> x) (fromList [1..5]) --> 1
10:18:37 <Amras> >:t iso
10:18:50 <dmwit> :t iso
10:18:51 <lambdabot> (Functor f, Profunctor p) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
10:19:15 <vaibhavsagar> do `encodeUtf8` and `decodeUtf8` roundtrip?
10:19:22 <Solonarv> or: (s -> a) -> (b -> t) -> Iso s t a b
10:19:23 <Solonarv> or: (s -> a) -> (a -> s) -> Iso' s a
10:19:49 <vaibhavsagar> i.e. is it true that `encodeUtf8 . decodeUtf8 = id`?
10:19:59 <Solonarv> vaibhavsagar: probably, if there aren't any invalid characters involved
10:20:13 <dmwit> decodeUtf8 is partial. So definitely no.
10:21:26 <Solonarv> that doesn't follow: it certainly seems like 'encodeUtf8' should only produce valid inputs
10:21:29 <vaibhavsagar> okay, what about the scenario in which we are starting with text?
10:22:50 <dmwit> I'd also be nervous about the codepoint 0xFFFD REPLACEMENT CHARACTER
10:24:37 <Solonarv> % textUtf8Roundtrip = (==) <*> (T.decodeUtf8 . T.encodeUtf8)
10:24:37 <yahb> Solonarv: ; <interactive>:10:31: error:; Not in scope: `T.decodeUtf8'; No module named `T' is imported.; <interactive>:10:46: error:; Not in scope: `T.encodeUtf8'; No module named `T' is imported.
10:24:41 <dmwit> A quick test says that works okay, though.
10:24:49 <Solonarv> % import Data.Text.Encoding as T
10:24:49 <yahb> Solonarv: 
10:24:51 <Solonarv> % textUtf8Roundtrip = (==) <*> (T.decodeUtf8 . T.encodeUtf8)
10:24:51 <yahb> Solonarv: 
10:26:09 <Solonarv> % textUtf8Roundtrip $ T.pack [chr 0 .. chr 65535]
10:26:09 <yahb> Solonarv: True
10:28:49 <vaibhavsagar> cool
10:33:20 <dmwit> % textUtf8Roundtrip $ T.pack [minBound .. maxBound] -- why not?
10:33:20 <yahb> dmwit: True
10:33:50 <dmwit> % T.unpack (T.pack [minBound .. maxBound]) == [minBound .. maxBound]
10:33:51 <yahb> dmwit: False
10:33:54 <dmwit> whoops
10:34:01 <Solonarv> Yeah, that's not surprising
10:34:14 <Solonarv> T.pack does some normalization (not sure what exactly)
10:34:51 <Solonarv> % T.pack [ '\0' ]
10:34:52 <phadej> [Char] might be invalid unicode code point sequence
10:34:52 <yahb> Solonarv: "\NUL"
10:35:02 <Solonarv> phadej++
10:35:04 <dmwit> % let validcs = [c | cs <- [minBound .. maxBound], c < '\xd800' || c > '\xdfff'] in T.unpack (T.pack validCs) == validCs
10:35:04 <yahb> dmwit: ; <interactive>:18:16: error: Variable not in scope: c; <interactive>:18:50: error: Variable not in scope: c :: Char; <interactive>:18:66: error: Variable not in scope: c :: Char; <interactive>:18:100: error:; * Variable not in scope: validCs :: String; * Perhaps you meant one of these: `validcs' (line 18), `S.valid' (imported from Data.Set), `M.valid' (imported from Data.Map); <interactive>:
10:35:24 <dmwit> % let validcs = [c | c <- [minBound .. maxBound], c < '\xd800' || c > '\xdfff'] in T.unpack (T.pack validCs) == validCs
10:35:24 <yahb> dmwit: ; <interactive>:19:99: error:; * Variable not in scope: validCs :: String; * Perhaps you meant one of these: `validcs' (line 19), `S.valid' (imported from Data.Set), `M.valid' (imported from Data.Map); <interactive>:19:111: error:; * Variable not in scope: validCs :: String; * Perhaps you meant one of these: `validcs' (line 19), `S.valid' (imported from Data.Set), `M.valid' (imported fr
10:35:37 <dmwit> ok ok I'll take it to privmsg first
10:36:00 <dmwit> % let validcs = [c | c <- [minBound .. maxBound], c < '\xd800' || c > '\xdfff'] in T.unpack (T.pack validcs) == validcs
10:36:01 <yahb> dmwit: True
10:36:15 <phadej> that's even documented! http://hackage.haskell.org/package/text-1.2.3.1/docs/Data-Text.html#g:2
10:36:21 <phadej> that's even documented! https://hackage.haskell.org/package/text-1.2.3.1/docs/Data-Text.html#g:2
11:00:08 * hackage compact-mutable-vector 0.0.0.1 - Mutable vector with different GC characteristics  https://hackage.haskell.org/package/compact-mutable-vector-0.0.0.1 (rightfold)
11:05:56 <javran> i'm wondering if there's `(Ord k, Eq v) => Map k v` whom is smart enough to figure out that the whole structure can be left intact if value isn't changed at all
11:06:19 <Solonarv> javran: Map (from 'containers') does that
11:07:53 <javran> but type signature of insert doesn't put an Eq constraint on values, so I assume it still try to replace the old node
11:08:24 <Solonarv> oh that's what you mean
11:08:38 <Solonarv> sorry, I misread your initial thing
11:10:22 <javran> I guess there should be an Eq if the data structure supports that, otherwise if cannot do anything to the value (by parametricity?)
11:11:33 <Solonarv> actually, you can check whether two values are *the same* using the 'reallyUnsafePtrEquality#' primitive
11:11:41 <Solonarv> (which isn't quite as unsafe as its name implies)
11:12:15 <Solonarv> % let y = "hi" in ptrEq y y
11:12:15 <yahb> Solonarv: True
11:12:25 <Solonarv> % ptrEq id id
11:12:25 <yahb> Solonarv: True
11:12:26 <javran> I didn't know this primitive, by the looks of it it's referential equality?
11:12:42 <Solonarv> yes
11:13:01 <Solonarv> it might give false negatives, but IIRC it won't give false positivies
11:13:14 <javran> indeed
11:13:36 <Solonarv> (ptrEq is a simple wrapper around it that I defined for yahb)
11:14:09 <EvanR> see also the stable names library which is built around that
11:14:15 <EvanR> which is less gross
11:14:23 <rfold> Using reallyUnsafePtrEquality# can violate parametricity if someone passes a broken Eq instance such as Eq Float.
11:14:30 <javran> (without false negative is halting problem solved xD
11:15:21 <rfold> And purity, even.
11:15:38 <javran> I think there are still tricks to do that
11:18:22 <javran> nvm, I thought instead of storing v, we can store `v -> v` so if value end up being equal we can put id there
11:18:48 <javran> but this doesn't leave the structure intact
11:18:50 <Solonarv> % myInsert k v m = M.alter (\case old@(Just v') | v == v' -> old; _ -> Just v) k m
11:18:50 <yahb> Solonarv: 
11:18:54 <Solonarv> % :t myInsert
11:18:55 <yahb> Solonarv: (Ord k, Eq a) => k -> a -> M.Map k a -> M.Map k a
11:19:05 <Solonarv> that should do what you want
11:19:37 <EvanR> yeah alias patterns are you friend
11:20:29 <Solonarv> % let ex = M.fromList [("five", 5), ("ten", 10)] in ptrEq ex (myInsert "five" 5 ex)
11:20:30 <yahb> Solonarv: False
11:20:40 <Solonarv> uh oh
11:20:45 <javran> I think using alter is still the same
11:21:08 <javran> http://hackage.haskell.org/package/containers-0.6.0.1/docs/src/Data.Map.Strict.Internal.html#alter
11:21:45 <Solonarv> hm, yea
11:21:45 <javran> it still trys to do  "x' `seq` Bin sx kx x' l r" for that EQ case
11:22:43 <Solonarv> yeah, there's no special-case for when the function's result is identical to its input
11:24:39 <javran> not a big deal though, just could be something nice to have
11:25:41 <Solonarv> indeed
11:26:10 <Solonarv> I guess you could write it yourself by pulling in Data.Map.Strict.Internal
11:30:58 <javran> that's also true
12:06:29 <Gurkenglas> Can Idris say "partitionM f = foldrM (\x -> bool second first !(f x) (x:)) ([], [])"?
12:11:52 <ziman> wrong channel? :)
12:12:07 * hackage fltkhs 0.7.0.3 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.7.0.3 (deech)
12:18:34 <shapr> Was reading through the yesod docs this past weekend, it's refreshing to have a real actual tutorial
12:18:44 <shapr> one day was yesod, the other day was cereal
12:18:55 <shapr> I'm gonna say that yesod was way easier to learn stuff
12:19:41 <MarcelineVQ> Gurkenglas: Probably, I can't quite follow the function, syntacticly though you might need a pure around that bool expression there, e.g.: gor : Maybe Bool -> Maybe Int; gor x = pure $ bool 1 2 !x
12:20:02 <shapr> I've heard that from a bunch of people who've learned Haskell but couldn't figure out libraries
12:20:18 <shapr> I wish we had more documentation that's not just a list of function names and their types
12:20:41 <MarcelineVQ> shapr: libraries without tutorial modules are sadface
12:21:08 <[exa]> shapr: libraries' docs often lack motivation
12:21:13 <shapr> yeah
12:21:18 <sm[m]> shapr++
12:21:31 <kadoban> Yeah, only problem with that is that kind of documentation is the hardest to do well and the most time consuming. I think everyone wants it, just nobody wants to actually do it.
12:21:32 <[exa]> I'm kindof trying to make a picture of "before vs after" in all software I write
12:21:43 <[exa]> but it's always so hard to get back to "before"
12:22:27 <javran> (off topic) it bugs me that `partition` put positive stuff left and negative right, opposite to `bool` or `partitionEither`
12:22:28 <shapr> kadoban: I'd be happy to do it for the libraries I use
12:22:49 <MarcelineVQ> javran: does 'if' bug you?
12:22:56 <sm[m]> a fair number of libs have tutorial docs now but it needs to be more discoverable, presented in a consistent way etc.
12:23:03 <sm[m]> that will encourage more of it
12:24:40 <[exa]> ....is there some metric on example code coverage?
12:24:40 <kadoban> shapr: Nice. I find as the author of a library I'm often ... the worst at that too, because I have a hard time remembering which parts will be confusing to a new person.
12:24:40 <nisstyre> sometimes libraries will have "tutorial docs" that are badly out of date and don't even compile
12:24:41 <nisstyre> that's worse than no docs at all imo
12:24:41 <nisstyre> well, it's more anger inducing at least
12:24:41 <[exa]> like, everyone has test coverage, we could have "percent of API covered in a reproducible example"
12:24:41 <kadoban> [exa]: I don't think it works like that, personally. IMO what's most important is motivating the most fundamental parts, not exercising every possible code path.
12:25:13 <nisstyre> tutorial docs are just like comments, you have to maintain them, and they can't be checked by the compiler unless you use lhs
12:25:26 <kadoban> Probably depends what the library is, but like most I look at there's probably 5x as many functions as I'll ever use, but I can figure out 90% of them if I know what the main ones do.
12:25:30 <sm[m]> [exa]: we have percentage of haddock coverage. You could extend that to count haddocks with examples easily I think
12:25:30 <javran> MarcelineVQ: I'll argue if-expr is syntactic rather than a function
12:25:37 * hackage fltkhs-themes 0.1.0.5 - A set of themed widgets that provides drop in replacements to the ones in FLTKHS.  https://hackage.haskell.org/package/fltkhs-themes-0.1.0.5 (deech)
12:25:44 <nisstyre> how many people are actually writing lhs?
12:25:52 <nisstyre> that would be interesting to know
12:26:35 <javran> just that whenever there's a function that uses, say `partition` and `bool`, there'll be a reverse somewhere in code
12:26:37 <[exa]> kadoban: I was going extreme (sorry :] ) but having a working example that allows you to play with the function/whatever in action really helps to quickly get how it behaves
12:27:58 <sm[m]> I forget, why do people put tutorial docs in haddock rather than the (more prominent) readme ? Is that a holdover from when haddocks where all that hackage showed ?
12:29:24 <Solonarv> haddocks allow you to have compiler-checked examples (via doctest) and have the documentation next to the thing it's documenting
12:29:35 <sm[m]> when you come to a hackage page, you shouldn't have to dig for the docs, and it should be instantly obvious what docs there are
12:30:37 <sm[m]> which I think suggests that docs should always be or at least start in the README (and that should always be visible on the hackage page, which isn't a given)
12:31:11 <Solonarv> yeah, that'd certainly be nice
12:31:20 <burningwitness> Speaking of poorly documented libraries: are there any reflex tutorials that don't use reflex-dom? Getting into reactive-banana was pretty simple, yet reflex looks like a collection of monad transformers with no clear usage guidelines.
12:31:42 <sm[m]> and we should have routine example checking in READMEs too, not just in API docs
12:36:33 <[exa]> Solonarv: doctests looks great, thanks!
12:36:38 <phadej> sm[m]: "tutorial" docs in a main module or separate .Tutorial has benefits of being able to cross link to the haddocks
12:36:41 <phadej> with readme that is lost
12:37:15 <phadej> (and working on haddocks is one workflow, writing readme is another, which might explain too)
12:39:12 <phadej> and with `doctest` one can easily write examples in haddock too
12:39:35 <phadej> so that's not a reason to prefer readme (which you should compile with `markdown-unlit` too, if you put examples there)
12:40:41 <sm[m]> readme is the most discoverable and standard entry point for docs, so I think we should make it work better
12:41:45 <sm[m]> eg hackage could apply some of these haddock features (doctest, linking) to it. But I think those are niceties, not essentials
12:43:10 <phadej> IMHO tutorial doesn't belong to README. it's something a new user could read through to learn what to read next.
12:43:21 <phadej> i.e. i'd keep it short
12:43:33 <Rembane> One example of usage instead?
12:44:20 <sm[m]> I think in simple projects, README is the natural place for it and you'll often see that. With more complex docs, it'll be linked elsewhere. But README should be the docs home page
12:48:32 <phadej> sm[m]: for me README is a file which I'd expect every user to read before using the library, and I decide (not very systematically though) what to put there based on it
12:49:11 <phadej> so I try to keep it terse, so they actually read it before e.g. opening issues about say installation problems
12:51:36 <sm[m]> yes.. it's (should be) the starting point
12:53:13 <sm[m]> packages which aren't showing a complete readme (complete self contained docs, or complete links to other docs) should be treated as incomplete and flagged by hackage
12:54:02 <sm[m]> or users, when hackage can't know
12:55:57 <phadej> "complete readme"?
12:56:16 <phadej> note, that a policy which cannot be objectively and automatically enforced, won't be enforced
12:56:40 <sm[m]> complete = containing complete docs, or complete links to other docs
12:56:54 <sm[m]> eg if you have a tutorial in your haddocks, or a website, your readme links to them
12:57:32 <Solonarv> I'd be very impressed if you managed to check that automatically
12:58:51 <sm[m]> obviously there's some things can be easily machine checked and others that would require human bug reports/social pressure. Tools can help make the latter easy and efficient
13:00:39 <phadej> one point to remember, is that most of hackage is done by people on their free time
13:00:58 <phadej> one have to be very careful with any "quality" requirements
13:01:08 <sm[m]> I hadn't forgotten :)
13:03:01 <sm[m]> we're just chatting, but there's always the chance that might help build some consensus and energy to do things
13:03:43 <phadej> if you want something to be done, make it easier to do.
13:04:16 <phadej> writing good documentation is difficult
13:04:34 <sm[m]> eg I hope we could get some consensus that readmes are important and encouraging them on hackage would be a step forward. That seems pretty basic to me
13:05:00 <sm[m]> phadej: agreed
13:05:59 <phadej> i'd really like if people wrote something in description: of their packages
13:06:09 <phadej> the first paragraph of their readme
13:07:31 <sm[m]> Some do. The package description and readme compete with/duplicate each other though, which is a bit of a problem
13:07:54 <sm[m]> it adds to the confusion
13:08:04 <phadej> i think description as an abstract
13:08:15 <phadej> where readme is "introduction"
13:08:24 <phadej> and everything else is rest
13:09:23 <lyxia> The problem is you see the cabal description first if you come from Hackage, and the README first if you come from Github..
13:09:23 <sm[m]> that's something else we need some consensus/guidelines on
13:10:12 <phadej> well, if GitHub is a problem, I can move my packages to gitlab :)
13:10:26 <sm[m]> so people focus on on or the other, or repeat themselves like http://hackage.haskell.org/package/lens
13:10:44 <Solonarv> I mean, that doesn't display the description: field either, so really it's no different
13:10:58 <phadej> Solonarv: it doesn't display readme either
13:11:08 <phadej> going to github for a documentation is wrong place
13:11:11 <phadej> it's where code is
13:11:12 <phadej> not docs
13:11:32 <lyxia> My point was really not about github in particular.
13:11:35 <EvanR> but github has such great webhosting
13:11:40 <Solonarv> actually gitlab does display the readme as well
13:11:56 <phadej> Solonarv: oh! true, I was looking at a project without README :)
13:12:03 <phadej> my bad
13:12:09 <sm[m]> projects start on github/gitlab, that's where the docs need to start too. And they do a good job showing the readme. Hackage should do the same
13:12:11 <lyxia> The cabal file is really not an intuitive place to put any form of documentation IMO
13:12:31 <sclv> the description is not documentation -- it is a description!
13:12:37 <sm[m]> currently maintainers and users have to choose between cabal description ; readme ; module haddock ; website
13:12:37 * hackage servant-reflex 0.3.4 - servant API generator for reflex apps  https://hackage.haskell.org/package/servant-reflex-0.3.4 (imalsogreg)
13:13:13 <sclv> "projects start on github/gitlab, that's where the docs need to start too. And they do a good job showing the readme. Hackage should do the same"
13:13:15 <sclv> this logic is bad
13:13:22 <sclv> projects _today_ start on github
13:13:30 <sclv> who knows what microsoft might do to it tomorrow
13:13:38 <sclv> when hackage started there was no github
13:13:44 <sclv> i bet some version of hackage will outlive github
13:13:45 <Solonarv> they're generally going to start on <not hackage>, though
13:14:13 <sm[m]> that's beside the point, replace "github/gitlab" with "code hosting systems"
13:14:35 <sclv> the synopsis, description, and readme all serve different purposes
13:14:40 <sclv> there's no reason to set them against one another
13:14:43 <phadej> sclv: my point is that description should contain some description, importantly having readme is not a reason to leave it empty
13:14:51 <sclv> and having documentation in a readme vs a tutorial module vs the main module
13:14:55 <sclv> is totally a choice of the developer
13:15:22 <sclv> phadej: of course, i agree. except that having a readme _may_ be redundant with a tutorial module.
13:15:37 <sclv> i think its fine if devs want to put docs in one of a few places
13:15:47 <sclv> the problem is just when they don't put them anywhere
13:15:52 <sm[m]> In practice they do fight with each other, and are used diffferently by different packages. To avoid that, we need more best practice/conventions/guidelines/enforcement
13:15:53 <lyxia> I still don't see what content goes in the description that wouldn't fit just as well in the README
13:16:10 <sclv> the description describes what the package is -- it summarizes it
13:16:13 <sclv> so it goes at the _top_
13:16:16 <sclv> before the module listing
13:16:47 <sclv> a single sentence synopsis might not be enough to tell me "hey this package does what you want"
13:16:50 <sclv> but a description might
13:16:59 <sclv> and then a readme would explain some details to me
13:17:04 <lyxia> the first three lines of the readme also do that
13:17:38 <sclv> but i can't split a readme to have "the first N lines, who knows how many" followed by the module listing, followed by the rest of the readme
13:17:46 <sclv> so if you have three lines in two places
13:17:51 <sclv> i don't think that's... an issue at all?
13:19:51 <lyxia> I'm sure we can come up with a convention of sorts if we wanted.
13:19:59 <sclv> i just told you the convention
13:20:01 <sclv> we have it
13:20:55 <lyxia> except this convention is only visible for code hosted on Hackage.
13:21:14 <sclv> yes
13:21:16 <lyxia> whereas readmes are pretty much universal
13:21:20 <sclv> it is a convention for hackage packages
13:21:50 <sclv> or rather, for cabal packages
13:27:53 <tdammers> if it really bothers you that much, write a 6-line bash script that copies the first 3 lines of your README into the cabal file, or the other way around
13:29:42 <bifunc2> For serialization, binary vs. serialise?
13:29:46 <bifunc2> :)
13:29:54 <bifunc2> both look good
13:29:56 <bifunc2> so which to pick?
13:40:02 <Cale> bifunc2: I think probably binary has subsumed serialise
13:40:04 <Cale> er...
13:40:09 <Cale> wait, I was thinking of cereal
13:40:35 <EvanR> wasn't CBOR going to subsume binary at some point
13:40:46 <Cale> ah, I see
13:40:49 <Cale> yeah, this is newer
13:41:57 <bifunc2> ah so now i know of cereal.
13:41:59 <bifunc2> 3rd choice :S
13:44:58 <Cale> serialise looks quite a lot like binary, but with a bit more principles about what the precise binary format is going to be
13:45:11 <Cale> I wouldn't sweat the difference too much
13:45:25 <Cale> You can probably change between them quite easily if it ever turns out to matter
13:46:43 <phadej> if the binary blobs are meant for long term storage, than serialise is beetter
13:47:01 <phadej> as self-descriptievenss of CBOR might help in the future
13:50:04 <Cale> yeah, the fact that it's even described by an RFC is probably useful for that as well
13:50:29 <Cale> Binary might have some advantages just because it's been in the ecosystem for longer, so you'll find more code for interacting with it
13:50:51 <Cale> But whatever code was written to work with it also shouldn't be hard to adapt to serialise.
13:56:29 <phadej> yes, at least e.g. `Cabal` and `github` come with binary instances
13:59:48 <bifunc2> makes sense
13:59:48 <bifunc2> thanks
14:07:27 <zachk> uhh so getChar doesn't work correctly on windows at all it seems :( maybe 8.8 or 8.10 they say https://ghc.haskell.org/trac/ghc/ticket/2189
14:09:56 <phadej> there's quite few people working with Windows, it shows :(
14:10:16 <phadej> I mean "there aren't many people"
14:17:47 <geekosaur> thught so. the new I/O manager is still pending, sadly; there's basically only one rather busy person who knows enough to write and maintain it
14:18:02 <Solonarv> holy crap, over 10 years old bug :/
14:18:11 <geekosaur> win32 is a very different beast from posix, it's not a matter of just substituting the right calls in
14:29:07 * hackage sitepipe 0.4.0.0 - A simple to understand static site generator  https://hackage.haskell.org/package/sitepipe-0.4.0.0 (ChrisPenner)
14:36:32 <soc> where can I find the source of the Eq typeclass?
14:37:11 <phadej> soc: https://hackage.haskell.org/package/ghc-prim-0.5.3/src/GHC/Classes.hs
14:37:21 <phadej> class  Eq a  where somewhere there
14:38:07 <soc> thanks
14:41:52 <soc> phadej: what are all these operators with one or two # appended? e. g. ==##
14:42:14 <phadej> soc: GHC implementation details
14:42:19 <soc> ok
14:43:43 <soc> what is the best way to check whether two doubles are identical (not equal)? Numeric.IEEE.identicalIEEE?
14:45:42 <koala_man> 23:43 < soc> what is the best way to check whether two doubles are identical
14:45:45 <koala_man> oops
14:46:58 <koala_man> soc: how do you want it to behave for identical unnormalized values?
14:47:10 <koala_man> acidjnk!!
14:47:49 <soc> koala_man: just compare the bits – different bits are different
14:48:45 <Solonarv> % import GHC.Exts
14:48:45 <yahb> Solonarv: 
14:52:25 <Solonarv> % identDbl (D# x#) (D# y#) = W64# (unsafeCoerce# x#) == W64# (unsafeCoerce# y#)
14:52:26 <yahb> Solonarv: 
14:52:33 <Solonarv> % identDbl 5.0 5.0
14:52:33 <yahb> Solonarv: True
14:53:06 <Solonarv> soc: that's the "immediately reach for MagicHash" solution ;)
14:53:55 <soc> is "(===) = Numeric.IEEE.identicalIEEE" valid haskell?
14:54:18 <Solonarv> sure is
14:54:22 <soc> thanks!
14:54:43 <Solonarv> (why wouldn't it be?)
14:56:17 <soc> Solonarv: my haskell isn't that good
14:57:06 <soc> Solonarv: just had a discussion about Eq less than useful guarantees and wanted to make sure that the code example is not detracting from the main point with syntax mistkes
14:57:17 <soc> /s/Eq/Eq's/
14:59:49 <soc> % elem (0.0/0.0) [0.0/0.0]
14:59:49 <yahb> soc: False
14:59:54 <soc> Solonarv: stuff like that
15:03:19 <wroathe> % any isNaN [0.0/0.0]
15:03:20 <yahb> wroathe: ; <interactive>:37:1: error:; Ambiguous occurrence `any'; It could refer to either `T.any', imported from `Data.Text'; or `Prelude.any', imported from `Prelude' (and originally defined in `Data.Foldable')
15:03:29 <wroathe> % Prelude.any isNaN [0.0/0.0]
15:03:29 <yahb> wroathe: True
15:07:51 <soc> wroathe: yep. the point is not that == is wrong, but that == is not sufficient to implement elem
15:09:37 * hackage th-abstraction 0.2.11.0 - Nicer interface for reified information about data types  https://hackage.haskell.org/package/th-abstraction-0.2.11.0 (ryanglscott)
15:20:03 <zachk> found a workaround to windows that is windows specific , https://code.i-harness.com/en/q/2d8826 , first answer to the top left 
15:20:12 <zachk> for getChar on windows
15:57:37 <zachk> my windows getChar solution uses the c ffi and it doesnt seem to place nice with multithreaded use, using -threaded, no -threaded is even worse
16:00:05 <wroathe> So if I've got a datatype that represents a container, like data ConfigNode = ConfigNode Value (M.Map String ConfigNode) I can't define or derive instances for classes that require higher-kinded types like Functor, Traversable, etc
16:00:40 <wroathe> Even though I know the use-case for this structure is to store my ConfigNode, is it generally considered good practice to paramterize this type anyways, just so I can make it act like a standard container type?
16:01:06 <wroathe> is to store my Value*, sorry
16:01:47 <EvanR> you could generalize it like data ConfigNodeF a = ..., then define type ConfigNode = ConfigNodeF Value
16:02:06 <wroathe> That is, should I make it data ConfigNode a = ConfigNode a (M.Map String (ConfigNode a)), just so I can define those instances?
16:02:30 <EvanR> actually you want to do this kind of thing when using free monad libs
16:02:36 <wroathe> EvanR: Would you say that's considered good practice by library authors?
16:03:03 <EvanR> i'm only thinking of this from an application author
16:03:06 <wroathe> It's sort of an opaque type from the user's point of view, but I'm wondering if that's good enough reason to skip defining instances for the type
16:04:02 <EvanR> pretty sure you want functor, traversable etc without making a bunch of specialized mono morphic functions that do nothing special 
16:04:46 <wroathe> EvanR: Yeah, you're probably right. I'll just do it.
16:17:02 <Guest31808> what's better - clojure or haskell
16:17:42 <benzrf> Guest31808: haskell
16:17:56 <benzrf> now go to #clojure and ask them :-
16:17:58 <benzrf> :-)
16:18:35 <EvanR> haskell has a type system. clojure has lispisms. both have java
16:19:07 <zachk> the type system is quite nice, the compiler can often figure out which types you need all by itself
16:19:54 <EvanR> neither one has a record system :(
16:26:12 <zuserm> what's the deal with hayoo being down forever?
16:26:32 <hpc> something about nice things, and the having of them
16:29:24 <hpc> it might come back at some point
16:29:53 <hpc> someone else was here maybe a week or so ago, who might know what's up with it
16:35:07 * hackage barbies 1.1.1.0 - Classes for working with types that can change clothes.  https://hackage.haskell.org/package/barbies-1.1.1.0 (DanielGorin)
17:40:26 <dyl_> “Data.Barbies.Bare”... 
17:40:33 <dyl> Weird. 
17:40:54 <dyl> I shouldn’t have gotten bumped from my nick :/.
19:22:37 * hackage haskell-src-meta 0.8.2 - Parse source to template-haskell abstract syntax.  https://hackage.haskell.org/package/haskell-src-meta-0.8.2 (DanBurton)
19:26:34 <zuserm> look what I got diagrams to do: https://i.imgur.com/o36YEWe.png
19:28:17 <iqubic> How???
19:31:11 <zuserm> iqubic: calculating the intersections with Diagrams.TwoD.Segment.segmentSegment and splitting the the segments with code I hound in Geom2D.CubicBezier.Basic. Will upload it after I clean it up.
20:04:40 <argent0> when building documentation of installed libs with cabal, is there any reason not to set `html: True`? Is there a way to browse `.haddock` files?
20:16:37 <Cale> argent0: There are some tools which can make use of them, like hdocs
20:18:07 <Cale> haddock exposes an api that you can use to read .haddock files and extract usefully structured data from them
20:20:15 <argent0> Cale: Thanks, now I see.
20:21:16 <Cale> hsdev, which is a tool that's behind some of the attempts at better editor support for Haskell also uses that
20:35:28 <inkbottle> [git in haskell ;) ] printf "blob 16\0what is up, doc?"|stack -- zpipe.hs|stack -- zpipe.hs -d (https://git-scm.com/book/en/v2/Git-Internals-Git-Objects; https://raw.githubusercontent.com/haskell/zlib/master/examples/zpipe.hs)
20:44:50 <jackdk> gzip? zcat?
21:08:37 * hackage waargonaut 0.6.1.0 - JSON wrangling  https://hackage.haskell.org/package/waargonaut-0.6.1.0 (schalmers)
