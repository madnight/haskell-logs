00:02:17 <Wizek> maerwald: And I do agree with your earlier point as well about in/correctness propagating through an ecosystem. I am merely arguing for both very simple and very correct implementations being available even within a single ecosys. And let users choose which one makes more sense for what they do.
00:04:05 <dminuoso> Wizek: ByteString is not a string type
00:04:14 <dminuoso> The name was poorly chosen.
00:04:23 <dminuoso> It should have been named ByteArray instead.
00:05:00 <dminuoso> At that point you are left with just String vs Text.
00:07:59 <Wizek> dminuoso: I am aware, it does add to the confusion indeed. Especially if we talk about filepaths being `ByteArray`s, users who want a simple api might wonder why they couldn't just do `"/path/to/" ++ value ++ "/file.ext"`. Or would you say that even if FilePath would be ByteArray, `"/path/to/" <> value <> "/file.ext"` would still work?
00:08:41 <dminuoso> Wizek: What does "/path" even mean in terms of ByteArray?
00:08:54 <yushyin> in some parts of CS a bit string means the same as bit array and I always thought the same for byte string (but I do understand why it can be confusing)
00:08:59 <dminuoso> Wizek: OverloadedStrings with ByteString is silly and dangerous in my point of view.
00:09:32 <Wizek> dminuoso: I thought as much. So how would that api look like in your mind?
00:11:52 <Wizek> dminuoso: E.g. `readFile ("/path/to/" ++ value ++ "/file.ext") >>= putStrLn`
00:51:37 * hackage elm2nix 0.1.1 - Turn your Elm project into buildable Nix project  https://hackage.haskell.org/package/elm2nix-0.1.1 (domenkozar)
01:38:31 <Wizek> In case someone will know an answer to my above question (prior to the last topic) related to monad transformers: https://stackoverflow.com/questions/54762831/how-can-i-use-eventwriter-instead-of-eventwritert
01:48:41 <__monty__> Didn't know repeating => was valid syntax.
01:51:49 <__monty__> I have no idea really, but aren't the constraints too loose? What if m1 ~ IO?
02:37:44 <slaterr> hi
02:37:53 <slaterr> can this be a monad? data Entry a = Any | Every a | Exactly a | Many [a]
02:39:09 <slaterr> I'm having trouble writing (Many (xs)) >>= f, and I'm starting to wonder if it is even possible to write a lawful monad
02:40:51 <lyxia> that looks possible to me
02:41:27 <slaterr> f returns a -> m a, and I have a, and need m [a]
02:41:44 <slaterr> I have [a], even
02:42:58 <lyxia> you can write and use toList :: Entry a -> [a]
02:44:08 <slaterr> @hoogle toList
02:44:08 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
02:44:08 <lambdabot> Data.List.NonEmpty toList :: NonEmpty a -> [a]
02:44:09 <lambdabot> GHC.Exts toList :: IsList l => l -> [Item l]
02:44:48 <slaterr> toList $ fmap f xs ?
02:45:12 <_sras_> When I try to derive some instance for a type alias, using template haskell, as `$(deriveBoth defaultJsonOptions ''MyType)`, where `MyType` is a type alias,  I get the error  `normalizeDecFor: DataD or NewtypeD required`. Is there anyway to work around this?
02:47:42 <feuerbach> Is there a canonical @Either a b@-like type whose semigroup instance uses the semigroup instances of a and b (and chooses, say, Left when a Left and Right collide)?
02:48:04 <feuerbach> where by canonical I mean defined in one of the more-or-less standard packages
02:48:21 <merijn> feuerbach: So...Validation?
02:48:27 <lyxia> _sras_: I'm not sure that's possible
02:48:44 <merijn> feuerbach: Not sure about the semigroup instance of Validation, but the applicative works like that
02:49:06 <merijn> @hackage either -- feuerbach 
02:49:06 <lambdabot> http://hackage.haskell.org/package/either -- feuerbach
02:49:37 * hackage req 2.0.1 - Easy-to-use, type-safe, expandable, high-level HTTP client library  https://hackage.haskell.org/package/req-2.0.1 (mrkkrp)
02:49:58 <slaterr> if I was to write my own sequence, that gives me the type I expected to be able to get out of this, Entry [b], and that gives me this error:  Couldn't match type b with [b];  Expected type: Entry b;  Actual type: Entry [b]
02:50:36 <_sras_> lyxia: I see. But why is this restricition in place? Is there some fundamental difficulty with what I am trying to do?
02:52:09 <lyxia> _sras_: in the restricted cases where it would actually work, you might as well use the underlying type
02:53:12 <merijn> slaterr: put your code + error in a paste site? :)
02:53:21 <slaterr> moment
02:55:22 <feuerbach> merijn: yeah, it's sort of similar. That particular Validation is not lazy enough. In the @Failure e1 <.> b@ case, I wish it could return @Failure (e1 <> ...)@ (that would require a Monoid instance on e)
02:55:56 <feuerbach> (not lazy enough for my needs that is; I don't think you can improve it while keeping only a Semigroup constraint)
02:56:10 <slaterr> oh, I don't need sequence
02:56:17 <slaterr> I need [Entry a] -> Entry a
02:56:22 <slaterr> let me try writing it myself first
02:56:48 <feuerbach> no, actually you could improve it, but the code would become somewhat hairy :)
02:58:37 <slaterr> this compiled (Many (xs)) >>= f = join $ Many $ toList $ fmap f xs
02:58:46 <slaterr> I'll probably have to write my own join
03:00:26 <slaterr> here's the code, if someone can see that everything is ok before I continue. https://bpaste.net/show/cd9ecd294156
03:01:28 <slaterr> (I'd have to write myJoin, as I'm using it in >>= definition)
03:03:11 <lyxia> this toList is applied to a list, so it's just   id :: [a] -> [a]   and you can remove it.
03:04:02 <slaterr> it compiles with toList, without it gives me Expected type: Entry (Entry b)         Actual type: [Entry b]
03:04:41 <Wizek> __monty__: I'm back. It is valid syntax indeed. And AFAIU m1 cannot be IO, because then it couldn't satisfy `EventWrtier t w1 m1` It could however be `EventWriterT t w1 IO ()`, and that I think would be fine.
03:04:47 <slaterr> I can still remove it, and just write [Entry b] -> Entry b instead of Entry (Entry b) -> Entry b
03:06:16 <Wizek> __monty__: if you are approaching this from an MTL point of view, you might be able to just think of these as Writer and WriterT as they are strongly analogous AFAIR.
03:06:17 <lyxia> slaterr: this instance is not lawful, you need (m >>= pure) = m   but here   (Every x >>= pure) = Exactly x
03:07:07 <slaterr> lyxia, good catch
03:07:34 <lyxia> slaterr: I just removed toList and it compiles
03:07:51 <__monty__> Wizek: Ah, I was thinking of it as going from a stack of monads, to m1 -> m2.
03:08:48 <slaterr> lyxia, you're right, I probably removed too much when I tested
03:09:09 <slaterr> so my type can't be lawful Applicative?
03:09:40 <lyxia> and if you're going to be implementing join separately you might as well write m >>= f = join (fmap f m)
03:09:56 <Wizek> __monty__: how do you mean?
03:10:07 <slaterr> I thought join uses bind, leading to an infinite loop
03:10:28 <lyxia> slaterr: ah, I meant, myJoin
03:11:40 <lyxia> slaterr: I still think a lawful instance is possible.
03:11:57 <slaterr> how? I can only pick one of Every, Exactly in pure
03:13:03 <lyxia> indeed, and that's no problem.
03:14:46 <slaterr> so what is a lawful pure?
03:16:25 <lyxia> either one can work
03:16:48 <lyxia> the issue is implementing (>>=) or myJoin to satisfy the laws
03:18:15 <__monty__> Wizek: That's what it looks like to my layman's eyes. You go from `w1Tow2 -> stack1 -> stack2` to `w1Tow2 -> m1 -> m2`. That looks like a function between arbitrary monads. But I'm probably just misinterpreting the constraints.
03:18:45 <lyxia> slaterr: Given the names of the constructors there's probably one of Every and Exactly which is morally preferable as pure, but I don't know what this type means to you so I can't tell.
03:19:30 <dminuoso> lyxia: I dont see how you could implement (>>=) lawfully
03:19:37 * hackage lucid-extras 0.2 - Generate more HTML with Lucid  https://hackage.haskell.org/package/lucid-extras-0.2 (ocramz)
03:20:22 <dminuoso> lyxia: while he is gone, any hint at to what you were thinking?
03:20:24 <slaterr> lyxia, it is a cronetab entry.  * => Any.  5 => Exactly.  /5 => Every 5.  5,6 => Many [5,6]
03:20:35 <lyxia> dminuoso: too late :P
03:20:38 <dminuoso> Heh. :)
03:21:52 <lyxia> slaterr: are these meant to be filters of some sort
03:22:16 <dminuoso> Though seeing what the data type means, I have an idea at least.
03:24:48 <slaterr> lyxia, yes. if Entry is a minute,  Exactly 5  matches 5th minute of every hour.  Every 5  matches every 5th minute.  Many [5,6] matches 5th or 6th minute. And Any matches any minute
03:25:07 * hackage lucid-extras 0.2.1 - Generate more HTML with Lucid  https://hackage.haskell.org/package/lucid-extras-0.2.1 (ocramz)
03:26:04 <Wizek> __monty__: Yes, I was wondering about similar things there too. We do constrain m1 and m2 to both have EventWriter in their stacks, but not much beyond that. I wonder if we could instead do something like ... Or wait a sec...
03:27:25 <Wizek> __monty__: so continuing from what you wrote, I tried simplifying as such: https://gist.github.com/e97df5f5f8830f962a0a414e1dd580bb
03:27:45 <Wizek> we still get `Couldn't match type ‘m1’ with ‘EventWriterT t w1 m0’`
03:29:25 <Wizek> I wonder if the type of `runEventWriterT` might make this harder
03:30:03 <lyxia> slaterr: I'm not sure there's any Monad instance which is going to behave intuitively with respect to these semantics.
03:30:34 <Wizek> __monty__: as that does mention the concrete type `forall t m w a. (Reflex t, Monad m, Semigroup w) => EventWriterT t w m a -> m (a, Event t w) S`
03:34:15 <narff> I have time series of temperature measurements (newest at the head). I want to take while the diff between min and max of what we scanned so far is less then two degrees. how can I do that?
03:35:53 <Wizek> __monty__: I just got two ideas. The worse idea is that maybe there is some fundamental limitation of haskell that makes this hard/impossible. Since IIRC we have similar issues with regular runWriterT as well. And the better idea is that it seems EventWriterT is really more like EventStateT under the hood, as it builds upon StateT. That way I might have a polymoorphic way of getting at the contained event!
03:36:01 <slaterr> lyxia, I see.. still, I'm curious to see any instance where (m >>= pure) = m  is true for all the possible values
03:38:35 <__monty__> Wizek: I don't understand why you're trying to use runEWT though, m1 *can* be an EWT but that's just *an* implementation that fits, no? That's also what the error seems to be saying, you're trying to use something that requires an EWT but all you have is an m1.
03:39:08 <__monty__> Wizek: I'm not familiar enough with transformers but can't you apply them to the Identity monad? Then work from the types you get?
03:40:14 <Wizek> __monty__: Because I want to use this function to split events that are bubling up. So what we pass to this has `n` number of events, and since we split one off, we still want to let pass `n - 1` up.
03:40:48 <lyxia> slaterr: dminuoso: https://gist.github.com/Lysxia/a6c953f7aafd6775b8d279337dc7040a
03:40:49 <Wizek> __monty__: so both the parameter and the return monads have to have EWT
03:41:39 <Wizek> __monty__: Imagine that you have a Writer that collects in a list, and you want to have a split function that pops the head and gives it to you, but keeps the rest in the Writer context still bubling up
03:41:42 <__monty__> Wizek: I'm still not clear on why that is? Is it in the constraints already or is that in your head?
03:43:33 <Wizek> __monty__: for sEW1 it's in the constraints, and that compiles and works as expected. For sEW2 I am not as sure, m1 and m2 can introduce some ambiguity that would be nice to resolve.
03:44:39 <Wizek> or are you asking something else?
03:45:18 <__monty__> Wizek: Well that's my point. I don't see it in the constraints. So either you need to add it, or you can't use rEWT. I may be overlooking something though.
03:45:33 <slaterr> lyxia, thanks, I'll try to digest that when I'm back.
03:48:45 <Wizek> __monty__: sure, that's possible. I wonder if we can figure out how to add that to the constraints. I was thinking of something along the lines of https://gist.github.com/922ad86d10e0e3f6da0b35ec68c612f1
03:49:14 <__monty__> Wizek: I think you'd just end up with version 1.
03:50:14 <Wizek> __monty__: in that case maybe only the StateT route is viable
03:52:37 * hackage lucid-extras 0.2.2 - Generate more HTML with Lucid - Bootstrap, Rdash, Vega-Lite, Leaflet JS, Email.  https://hackage.haskell.org/package/lucid-extras-0.2.2 (ocramz)
04:46:00 <amx> :t (<=<)
04:46:00 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
04:51:14 <phadej> I imagine dancing person
04:51:16 <phadej>  o
04:51:18 <phadej> <=<
04:51:22 <phadej> >=>
04:51:23 <phadej> <=>
04:51:51 <phadej> that explains why I'm smiling when coding :)
04:55:28 <Rembane> :t (<=>)
04:55:29 <lambdabot> error:
04:55:29 <lambdabot>     • Variable not in scope: <=>
04:55:29 <lambdabot>     • Perhaps you meant one of these:
04:58:41 <Rembane> phadej: You need to define the last dance operator! 
04:59:47 <dminuoso> Yeah why don't we have a (<=>) arrow
05:00:19 <phadej> I thinking adding one to lattices
05:00:25 <phadej> as two-side ==>
05:03:58 <stiell> I'm trying to use the singletons package, but I'm getting type errors like "Couldn't match type ‘() == ()’ with ‘'True’", as if Data.Singletons.Prelude.Eq.== doesn't properly translate to 'True or 'False. Any idea What I'm doing wrong?
05:04:48 <Ariakenom> % (>=<) = \ma mb -> mdo a <- ma b; b <- mb a; pure ();
05:04:48 <yahb> Ariakenom: 
05:04:56 <Ariakenom> % :t (>=<)
05:04:56 <yahb> Ariakenom: MonadFix m => (a -> m t) -> (t -> m a) -> m ()
05:16:47 <lyxia> stiell: It might be confused about () being a type or a constraint.
05:19:51 <stiell> lyxia: I don't think so, the () comes from something explicitly declared as Type.
05:20:13 <phadej> does Int == Int reduce?
05:20:42 <stiell> No, same error with Int == Int.
05:29:07 * hackage useragents 1.0.0 - A collection of user agents  https://hackage.haskell.org/package/useragents-1.0.0 (Jappie)
05:30:38 * hackage wikicfp-scraper 0.1.0.10 - Scrape WikiCFP web site  https://hackage.haskell.org/package/wikicfp-scraper-0.1.0.10 (debugito)
05:30:52 <phadej> DefaultEq Int Int reduces
05:32:46 <phadej> stiell: I needed to import Data.Singletons.TypeRepTYPE
05:32:54 <phadej> to get orphans from there
05:32:57 <phadej> then it works
05:39:45 <stiell> phadej: importing Data.Singletons.TypeRepStar in singletons-2.4.1 fixed the problem. Thanks!
05:46:07 * hackage eccrypto 0.1.0 - Elliptic Curve Cryptography for Haskell  https://hackage.haskell.org/package/eccrypto-0.1.0 (MarcelFourne)
05:56:31 <kuribas> is there a generic or TH implementation for bifunctor?
05:56:52 <zero_coding> Hi all
05:57:11 <zero_coding> Could someone please explain me, what is a CAF?
05:57:42 <dminuoso> zero_coding: Do you understand what super combinators are?
05:57:59 <dminuoso> zero_coding: Also I should ask: Are you just learning Haskell right now?
05:59:06 <zero_coding> Am I in a wrong channel?
05:59:37 <dminuoso> No, but you may be straying into topics not relevant to the learning process if you're just a beginner who is trying to get comfortable with the language
05:59:53 <dminuoso> Im asking because I know what we talked about earlier in #haskell-beginners 
06:00:43 <phadej> kuribas: yes, in bifunctors
06:01:09 <zero_coding> dminuoso: supercombinators are functions that passes the result to another functions
06:01:28 <zero_coding> I would say, it is like function composition
06:02:07 <zero_coding> Wait
06:02:13 <kuribas> phadej: ah, great :)
06:02:57 <zero_coding> dminuoso: it is like g (f (h x))
06:03:50 <kuribas> Why isn't there a Bifunctor f => Functor (Fix f) instance?
06:04:30 <phadej> kuribas: because kinds don't align
06:04:43 <phadej> Fix :: (* -> *) -> *
06:04:52 <phadej> where f is * -> * -> *
06:05:05 <kuribas> Fix (f a) then?
06:05:26 <phadej> that's wrong kind still, Fix (f a) :: *, not * -> *
06:05:33 <kuribas> ah sh**
06:05:45 <kuribas> it's not possible then?
06:06:11 <phadej> no: https://github.com/ekmett/recursion-schemes/pull/23 for more back and forth (between me and Edward)
06:07:19 <phadej> TL;DR in math we can just say (_,x) for fixed x is a Functor. But in Haskell we cannot
06:08:14 <kuribas> because type variables are curried?
06:09:12 <phadej> because we don't have type-level lambdas
06:09:40 <phadej> e.g. \y -> (y,x) :: * -> * would be
06:09:53 <phadej> but then, writing instances for type-level functions...
06:10:20 <phadej> let someone smarter think about how that could work
06:10:25 <kuribas> yeah
06:12:39 <kuribas> I could make a FixFunctor typeclass
06:12:51 <kuribas> then fixmap
06:13:44 <kuribas> actually I can write Bifunctor f => fixmap :: (a -> b) -> Fix (f a) -> Fix (f b)
06:17:37 * hackage streaming-base64 0.1.1.0 - Streaming conversion from/to base64  https://hackage.haskell.org/package/streaming-base64-0.1.1.0 (koral)
06:22:59 <dmwit> How about fixmap :: Functor (Flip f ignored) => (a -> b) -> Fix (f a) -> Fix (f b)
06:23:14 <dmwit> hm
06:23:32 <dmwit> May need to be fixmap :: Functor (Flip f (Fix f a)) => ... -- or something
06:23:32 <kuribas> dmwit: https://gist.github.com/kuribas/6313a64a91297c8dbe4a61c8dcd97c22
06:24:06 <dmwit> Yes, I worked out basically that from the conversation here.
06:24:19 <dmwit> I'm proposing an alternative that doesn't require the too-strong constraint Bifunctor.
06:24:41 <kuribas> isn't that constraint necessary though?
06:25:00 <dmwit> No, a weaker constraint will do; you only use first and not second.
06:25:13 <kuribas> well, cata uses second
06:26:06 <dmwit> Okay. Morally correct.
06:26:10 <dmwit> I concede.
06:26:56 <kuribas> I do have an annoying (Functor (f a)) constraint.
06:27:07 <kuribas> but that comes from the Bifunctor definition
06:30:43 <kuribas> Maybe for Compose Fix f ?
06:33:03 <slaterr>  re my earlier CronEntry question, I had this before:  data Entry a = Any | Every a | Exactly a | Many [a]
06:33:17 <slaterr> but I'm thinking it would be simpler if I just had this?  data Entry a = Any | Many [a]
06:33:32 <slaterr> both Every and Exactly can be represented with Many [a]
06:33:38 <slaterr> what do you think?
06:34:09 <slaterr> for every function I'd have to handle just two cases, instead of 4
06:36:59 <Solonarv> [a] can be an empty list, so you could even switch to 'newtype Entry a = Some [a]'
06:37:54 <slaterr> indeed
06:38:30 <kuribas> slaterr: are you creating crontabs?
06:38:31 <byorgey> slaterr: how can you tell the difference between Every and Exactly if both are encoded as Many [a] ?
06:38:34 <slaterr> kuribas, yes
06:38:59 <kuribas> I ported a lisp library from our production code into haskell
06:39:35 <kuribas> with a little combinator library for creating date ranges
06:39:39 <slaterr> byorgey, I wouldn't expose constructors directly, instead I'd have everyDay, etc, where everyDay 10 would create [0,10,20,30]
06:39:53 <slaterr> [10,20,30], even :)
06:40:23 <slaterr> kuribas, is it on github/hackage?
06:40:37 <byorgey> slaterr: oh I see, you expand into a concrete list of times before creating an Entry value
06:40:44 <slaterr> yes
06:40:54 <kuribas> slaterr: no, not yet.  It needs some work, as I found I could simplify it
06:41:07 <kuribas> slaterr: I can put it on github and let you know
06:41:12 <byorgey> slaterr: that sounds like it works, as long as you don't want to pretty-print back into nice crontab syntax
06:41:59 <slaterr> kuribas,go ahead :)
06:42:07 <kuribas> slaterr: ok, after work :)
06:42:17 <slaterr> ok!
06:42:43 <slaterr> byorgey, you mean taking Entry, and producing crontab line?
06:42:50 <kuribas> slaterr: do you have a github account?
06:43:34 <slaterr> kuribas, I don't
06:43:54 <kuribas> slaterr: pm your email?
06:43:56 <byorgey> slaterr: right, I mean it depends on whether you care about the crontab line looking nice like  */5  or if you're ok with it looking like 0,5,10,15,20,25 whatever
06:48:44 <slaterr> byorgey, I'm actually reading crontab file, not reading it. I'm writing a cron for windows. I  tried a couple of cron ports for windows, but they all had issues
06:48:53 <slaterr> err, I'm actually writing crontab file, not reading it
06:49:24 <slaterr> no, I'm doing the opposite. :). fear my typing after a couple of beers
06:49:52 <marvin2> tried nncron?
06:50:28 <slaterr> yes. it runs fine for a while, and then it segfaults
06:51:15 <byorgey> slaterr: haha, ok, I see =)
07:02:21 <kuribas> slaterr: ah, then my library won't help.
07:02:41 <kuribas> slaterr: it's meant for scheduling, not for parsing.
07:07:17 <slaterr> kuribas, ah, I see. I probably wasn't that clear when I asked my original question
07:10:45 <kuribas> the library isn't meant to be compatible with crontab syntax
07:10:50 <kuribas> thought it probably isn't hard to add
07:20:05 <wfehewn[m]> /help
07:22:08 <joeyh> anyone know where to find htonl now that it's been removed from network-3.0.0.0?
07:22:46 <merijn> joeyh: What do you wanna use it for? Data serialisation?
07:23:32 <joeyh> extracting an IPv4 address embedded in an IPv6 address
07:28:58 <joeyh> hmm, I could just use hostAddressToTuple and then "reverse" the tuple
07:29:18 <joeyh> still it seems an odd omission, sometimes you really do need lowlevel network order conversion
07:38:13 <slaterr> there's probably a nicer way of writing >>= in the =
07:38:15 <slaterr> there's probably a nicer way of writing >>= in the =
07:38:17 <slaterr> sorry
07:38:30 <slaterr> there's probably a nicer way of writing >>= in here, but I can't figure it out: https://bpaste.net/show/a129ba7f714e
07:39:45 <rotaerk> never seen someone stutter in IRC before
07:40:14 <slaterr> first time for everything :P
07:40:22 <Taneb> @unmtl MaybeT [] a
07:40:22 <lambdabot> [] (Maybe a)
07:41:23 <rotaerk> your implementation of (>>=) looks fine to me; not sure what you're looking for when you say you want something "nicer"
07:41:43 <rotaerk> you mean without having to write some separate concatEntries function?
07:42:28 <slaterr> I thought I could somehow avoid converting everything to Maybes, and use functions that were already defined for my type
07:42:37 <dmwit> I like Taneb's answer best.
07:42:59 <Taneb> dmwit: it's also wrong
07:43:08 <dmwit> ...Oh, so it is.
07:43:37 <Taneb> @unmtl ListT Maybe a
07:43:37 <lambdabot> Maybe ([] a)
07:43:40 <Taneb> Don't use that
07:48:22 <dmwit> slaterr: I believe this is the swap construction from http://web.cecs.pdx.edu/~mpj/pubs/RR-1004.pdf with swap = sequenceA
07:51:37 * hackage cabal-rpm 0.13 - RPM packaging tool for Haskell Cabal-based packages  https://hackage.haskell.org/package/cabal-rpm-0.13 (JensPetersen)
07:52:45 <EvanR> setting up a network comm channel is pretty easy with just Network and Handles right
07:53:05 <EvanR> but what about an authenticated encrypted channel. SSL bindings?
07:53:49 <magicman> Is there something in conduit like concatMapAccum that also gives back the final value of the accumulator? Or how would I go about constructing that?
07:54:57 <dmwit> slaterr: https://gist.github.com/dmwit/44afc00dd3e58609084f43357db4003d
07:55:09 <dminuoso> magicman: Can you explain what you want to do?
07:55:20 <dminuoso> magicman: (Reason Im asking is that there may be a different route)
07:56:17 <slaterr> dmwit, nice!
07:56:38 <dminuoso> magicman: What you asked for is probably best described by traverse.
07:59:42 <magicman> I have a source of update-events of the form Update { updateFor :: SomeID, updateDetails :: Details}.
08:00:13 <magicman> I could do some foldl kind of thing and reconstruct a Map SomeID SomeValue, but I'd hate keeping that entire map in memory.
08:00:42 <magicman> So those updates are ordered by ID (and chronologically, but Details), so I only have to keep one SomeValue in memory.
08:01:33 <magicman> My processing function uses concatMapAccum with that one SomeValue in its accumulator, and the output is a list of stuff that's relevant to SomeValue, but not directly.
08:01:49 <magicman> (err, by output, I mean the downstream type)
08:02:56 <magicman> It checks if the ID of the new update is the same as the ID for the SomeValue we're working on, and if not, replace it with a "default" SomeValue.
08:03:46 <magicman> However, this requires an update to come in to know when the current SomeValue is finished to pass it downstream (new ID /= current ID). If the upstream is empty, no new update comes in, and I'd still like to get at that last SomeValue.
08:07:46 <tuv_>  
08:09:14 <tuv_> @help
08:09:14 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:09:28 <tuv_>  
08:09:36 <tuv_> @help list
08:09:36 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
08:09:46 <tuv_> @type EXPR or ':t' EXPR
08:09:47 <lambdabot> error: parse error on input ‘:’
08:09:52 <tuv_> @pl FUNCTION 
08:09:52 <lambdabot> FUNCTION
08:10:26 <Solonarv> tuv_: what are you looking for?
08:10:38 <Solonarv> if you have a question, you're best off just asking it
08:10:54 <ProofTechnique> @pl f x y = x y
08:10:54 <lambdabot> f = id
08:11:01 <ProofTechnique> :t I’d
08:11:02 <slaterr> what are the name of the functions that list ranges use? [1..10]
08:11:02 <lambdabot> error: lexical error at character 'd'
08:11:03 <slaterr> etc
08:11:07 <ProofTechnique> :t id
08:11:08 <lambdabot> a -> a
08:11:12 <ProofTechnique> For example
08:11:43 <magicman> Hrm. I guess I could do stuff like do {x <- mapAccum stuff moreStuff; yield (relatedTo x)} and then .| concat that.
08:11:47 <Solonarv> slaterr: [x..y] -> enumFromTo, [x..] -> enumFrom, [x,y..] -> enumFromThen, [x,y..z] -> enumFromThenTo
08:11:54 <slaterr> thanks!
08:12:07 <tuv_> Ok thanks , i just joined the channel  to explore , i dont have a real question but thank you for help 
08:12:16 <magicman> Thanks for the rubber ducking >_<
08:13:08 <ProofTechnique> tuv_: You can also /query lambdabot if you want to experiment with it
08:16:31 <gagbo> Hello, noob question here : I'm trying to cabal install iwlib, and I can't because iwlib tries to look for iw but can't find it. I have all the needed files, in /usr/include and /usr/lib64; ldconfig -p yields libiw. Is there anything I should do to make the compilation work ?
08:17:19 <gagbo> I tried cabal install --extra-lib-dirs=/usr/lib64 iwlib and it didn't work. Now I'm looking at actually cloning the repo and change the .cabal file, but I'm not really sure what I should do
08:17:57 <wroathe> It's looking for the executable iw?
08:18:15 <gagbo> https://github.com/jaor/iwlib for the sake of completeness (The unique issue is exactly my issue, I bumped it, but I don't know what it will become)
08:18:56 <gagbo> wroathe: it's "cabal: Missing dependency on a foreign library:\n* Missing C library: iw"
08:19:09 <gagbo> So I think it's really just looking for the .so/.h combo
08:19:42 <slaterr> my third attempt at representing crontab.. what do you think? https://bpaste.net/show/6bfbbb93f540
08:21:03 <slaterr> a lot less boilerplate than with data Entry x = Any | Many [x]    or     data Entry a = Any | Every a | Exactly a | Many [a] 
08:21:26 <slaterr> and when checking if things match, I just look the relevant part in the list
08:21:45 <ClaudiusMaximus> gagbo: maybe it's looking for pkg-config stuff, .pc etc?
08:22:18 <wroathe> gagbo: Try running cabal install with -v and see if that sheds any light
08:22:37 * hackage git-annex 7.20190219 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-7.20190219 (JoeyHess)
08:23:01 <gagbo> I thought it might be the case, but the people who repro the issue were able to compile on Arch linux, and the package delivering iwlib there does not yield a .pc file
08:26:25 <gagbo> Nothing special comes out of -verbose : https://paste.fedoraproject.org/paste/ggvs~H0~VVeMjVMWIgC7Zw
08:29:07 <gagbo> I'll try to craft a .pc file and see *shrug*
08:29:22 <wroathe> which version of cabal are you using?
08:33:37 <wroathe> `q
08:33:46 <gagbo> whoops
08:34:11 <gagbo> cabal-install version 2.0.0.1
08:35:07 * hackage vinyl-generics 0.1.0.0 - Convert plain records to vinyl (and vice versa), generically.  https://hackage.haskell.org/package/vinyl-generics-0.1.0.0 (GagandeepBhatia)
08:36:23 <wroathe> gagbo: A shotgun approach would be to try updating Cabal to the latest and see if that fixes your problem
08:37:37 <wroathe> gagbo: Otherwise, it looks like it's failing on this environment sanity check: https://github.com/haskell/cabal/blob/master/Cabal/Distribution/Simple/Configure.hs#L1686
08:38:51 <gagbo> I'll try that
08:38:55 <kuribas> any good slides for explaining functor?
08:39:32 <gagbo> Maybe I really need to build that pc file
08:40:36 <gagbo> kuribas: I've heard good stuff about this course https://www.seas.upenn.edu/~cis194/fall16/
08:40:47 <gagbo> Week8 is about functors apparently
08:41:18 <dmwit> What goes wrong if you don't explain Functor, and just explain your functor instead?
08:44:37 <sclv> gagbo: you need to pass in extra-lib-dirs and extra-include-dirs both if they're not showing up
08:44:53 <gagbo> I have the same results with the flags
08:45:15 <sclv> hrm
08:45:40 <gagbo> Maybe going to cabal-install 2.4 will help, it's over soon
08:46:02 <kuribas> gagbo: it doesn't have slides, does it?
08:46:53 <ProofTechnique> kuribas: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass
08:47:00 <gagbo> It's html pages, I didn't think the exact slide support was important
08:51:05 <wroathe> gagbo: That work?
08:51:34 <gagbo> no, I have the same error :(
08:51:48 <gagbo> Apparently I can give v3 to get a little more verbosity
08:52:17 <gagbo> oh, indeed
08:52:54 <gagbo> '/usr/lib64/libiw.so : erreur : référence à « floor » non définie' I can work with that
08:53:29 <gagbo> I'm fully expecting this error to be an eventual gcc9 problem, but at least I'm starting to understand
08:55:17 <Solonarv> localized errors, ew (I get them too, too lazy to figure out how to turn them off)
08:55:23 <slaterr> probably annoying everyone with crontab by now.. but I think I'm going with this one. there's no reason why I can't have both nice representation of crontab with haskell types, and simplicity when comparing various things. https://bpaste.net/show/74067756a7c4
08:57:32 <Solonarv> slaterr: perhaps the 'every*' should take a Field instead of a Range?
08:58:35 <slaterr> Solonarv. you're right. that was leftover from 30 minutes ago, when I completely ditched Entry type and just went with [Int]
08:59:20 <kuribas> Representing (Maybe a) by forall r. (r, a -> r) isn't a catamorphism, is it?
08:59:31 <gagbo> Solonarv: I think "LANG=C command" will unlocalize iirc, but this one is short enough to be grokkable (or so I assumed) so I didn't rerun the command
09:00:23 <Solonarv> kuribas: Maybe a isn't recursive, so AIUI talking about a catamorphism for it is a bit ill-defined
09:00:28 <gagbo> So new question that might solve everything : can I add a -lm flag on the gcc command directly from cabal ?
09:00:47 <Solonarv> caveat: every type T is "recursive" if you use 'Const T' as the base functor  ;)
09:01:22 <Solonarv> 'forall r. (r, a -> r)' can't be realized, btw
09:06:11 <Solonarv> did you mean: 'forall r. (r, a -> r) -> r'? if you curry that you get 'forall r. r -> (a -> r) -> r', which is a Scott encoding
09:06:18 <kuribas> Solonarv: I had a strange discussion with a coworker, turns out someone told him this was a catamorphism.
09:06:52 <kuribas> Solonarv: I suppose...
09:07:04 <kuribas> Solonarv: yes, that's it
09:07:17 <kuribas> Solonarv: isn't that a CPS transform?
09:07:26 <Solonarv> yes, it's also a CPS transform
09:08:27 <gagbo> wroathe sclv : final log with the actual error (probably a missing -lm in the gcc command to build some stuff with iw) https://paste.fedoraproject.org/paste/cugdGPBP3bUconaRzRpJ9Q
09:08:37 <gagbo> thank you for your time
09:09:46 <lyxia> with Const T as the base functor, you can get  cata :: forall r. (Const (Maybe a) r -> r) -> Maybe a -> r
09:10:27 <dmwit> FWIW I'm perfectly happy calling that a catamorphism.
09:10:49 <dmwit> :t maybe -- this, specifically
09:10:50 <lambdabot> b -> (a -> b) -> Maybe a -> b
09:11:13 <Solonarv> ... which is 'forall r. (Maybe a -> r) -> Maybe a -> r' after you strip the newtype - kind of unenlightening, IMO
09:11:30 <dmwit> forall r. r -> (a -> r) -> r -- is both the Scott and Church encoding, and a partially-applied catamorphism.
09:11:44 <dmwit> (The only difference between the Scott and Church encodings are how they handle recursive occurrences anyway.)
09:12:17 <lyxia> Maybe a -> r   ~~   (r, a -> r)
09:13:24 <kuribas> Solonarv: so `id`?
09:13:46 <Solonarv> id-up-to-newtypes, AKA coerce :P
09:14:17 <Solonarv> (that's a yes)
09:14:42 <dmwit> (Specifically, the "shape functor" for Maybe is `data MaybeF a b = NothingF | JustF a`, and then Maybe ~~ Fix MaybeF and the standard generic catamorphism is exactly `maybe`.)
09:15:25 <kuribas> I got it from: http://blog.tmorris.net/posts/further-understanding-scalaoption/index.html
09:15:33 <kuribas> well, my coworker did
09:15:39 <kuribas> So it's not wrong then...
09:16:14 <kuribas> Though a bit weird 
09:16:22 <kuribas> Like a recursion scheme where you don't recurse
09:17:14 <Solonarv> that shape functor is just 'Const (Maybe a)'
09:17:41 <Solonarv> and of course T ~ Fix (Const T)
09:18:01 <kuribas> Data.Functor.Foldable has type Base (Maybe a) = (Const (Maybe a) :: * -> *)
09:18:09 <Solonarv> so it does
09:18:11 * dmwit nods agreeably
09:20:18 <wroathe> Anyone here have any projects on Github that makes heavy use of free monads?
09:23:43 <boj> wroathe: maybe not heavy use. i am currently modifying this to make it a fully functional project as an example - https://github.com/alasconnect/haskell-web-app-freer
09:26:25 <wroathe> Thanks boj. I'll take a look.
09:27:25 <slaterr> Solonarv, I forgot to add Many [Int] Field. I'm not sure what a good name would be? Many [10, 12] Hour?  EachOf [10, 12] Hour?
09:28:00 <Solonarv> what does that constructor mean?
09:28:51 <Solonarv> if I have a task scheduled to 'EachOf [10, 12] Hour' does that mean "wait 10h, fire task, wait 12, fire task, repeat"? or something else?
09:29:57 <slaterr> it means to run the command when current hour is 10 or 12
09:30:05 <slaterr> (if everything else also matches)
09:30:26 <Solonarv> AtEachOf makes sense, I guess?
09:31:37 * hackage toodles 1.1.1 - Manage the TODO entries in your code  https://hackage.haskell.org/package/toodles-1.1.1 (aviaviavi)
09:33:29 <slaterr> OneOf?
09:33:41 <ProofTechnique> I'd lean toward OneOf, as well
09:36:01 <sclv> gagbo: the dumbest way is to just add "libm" explicitly to the cabal file as an additional c dep :-) 
09:37:30 <slaterr> parse parserCronTabLine "" "/15 10 * * * ls -a"  =>  Right (CronTabLine {ctlMinute = Every 15 Minute, ctlHour = ExactlyOn 10 Hour, ctlDayOfTheMonth = EverySingle DayOfTheMonth, ctlMonth = EverySingle Month, ctlDayOfTheWeek = EverySingle DayOfTheWeek, ctlCommand = "ls -a"})
09:37:33 <slaterr> :P
09:37:57 <wroathe> It seems like every time I find a package on Hackage that encodes some crazy strange new idea Edward Kmett's name is somehow attached to it (recursion schemes, free monads, lens)
09:38:07 <wroathe> Guy's an actual mad scientist
09:38:43 <sclv> gagbo: you can also pass `-lm` to ghc as a ghc option which should pass it to the c compiler in the right phase
09:39:01 <sclv> you may also want to file an upstream report suggesting they add -lm to the file, since i don't think that'll break for anyone?
09:39:13 <Solonarv> Ed is awesome :D
09:39:20 <gagbo> I don't think I can pass ghc flags in cabal new-install command; can I ?
09:39:29 <gagbo> I'll submit a patch if I get it to compile for sure
09:39:36 <sclv> wroathe: recursion schemes and free monads both predate ed
09:39:57 <wroathe> sclv: The packages or the concepts?
09:39:59 <sclv> he's good at assimilating academic lit fast and well and then banging it into a really usable and abstract library
09:39:59 <Solonarv> but he did write/do a lot of work on the corresponding Haskell packages!
09:40:03 <sclv> wroathe: the concepts!
09:40:11 <sclv> also lenses predate him and the twanvl formulation to
09:40:13 <sclv> too
09:40:19 <sclv> but he did a _ton_ of work popularizing it
09:40:20 <wroathe> sclv: Well yeah. I didn't assume he created the concepts :P
09:40:35 <wroathe> I'm just impressed with his ability to realize theory into actual code
09:40:48 <sclv> and was part of the development of the "profunctor perspective" which was an actual innovation
09:41:25 <sclv> gagbo: see `cabal new-build --help`
09:41:33 <sclv> you can pass in --PROG-option
09:41:37 <sclv> with PRG being something like ghc
09:41:58 <ProofTechnique> Though also https://github.com/haskell/cabal/issues/5788
09:42:00 <gagbo> I tried gcc-option but it didn't work, didn't think to test ghc
09:42:23 <gagbo> yeah, basically I got the issue linked
09:42:40 <sclv> you can build it with new-build
09:42:42 <sclv> then symlink by hand
09:42:46 <sclv> new-install is just a shortcut
09:43:25 <slaterr> I wonder if it would be possible to make this type safe? now, all my ranges are Entry, and Field = Minute | Hour | Month ... .  Maybe I should make Field a class, and Minute, Hour types, and turn Entry into Entry field?
09:43:58 <ProofTechnique> sclv: Got any links on the "profunctor perspective"?
09:45:43 <lyxia> ProofTechnique: http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/poptics.pdf
09:45:45 <gagbo> Well, another error message (with 'cargo new-build iwlib --gcc-options"-lm"') Relink `/lib64/libiw.so.29' with `/lib64/libm.so.6' for IFUNC symbol `floor'
09:45:53 <gagbo> I think it's just too much haskell for me today
09:46:14 <__monty__> Cargo?
09:46:15 <EvanR> slaterr: do you mean that every Entry is a Minute AND Hour AND Month AND ..., not OR
09:46:17 <slaterr> class Range a where range :: a -> (Int, Int).  data Minute. data Hour.  instance Range Minute where range _ = (1,59) ?
09:46:30 <ProofTechnique> slaterr: I think it'd make sense for your `Minute`, `Hour`, etc. to take an Int, as well. When I write a crontab, I think of it as "run this at Hour 4, Minute 0", etc. Also, maybe Maybe, since then `*` is just Nothing.
09:46:32 <sclv> ProofTechnique: https://bartoszmilewski.com/2017/07/07/profunctor-optics-the-categorical-view/
09:47:06 <sclv> gagbo: and you didn't even get to the haskell :-/
09:47:06 <EvanR> * isnt the only special value there, see */5
09:47:17 <ProofTechnique> Ah, true
09:47:38 <ProofTechnique> sclv: lyxia: Thanks for the links!
09:47:53 <slaterr> my CronTabLine is this: data CronTabLine = CronTabLine { ctlMinute :: Entry, ctlHour :: Entry .. }. so I could mistake minute Entry with dayOfTheWeek Entry, and it would compile. I'd like to make it  data CronTabLine = CronTabLine { ctlMinute :: Entry Minute, ctlHour :: Entry Hour.. }.
09:47:58 <gagbo> yeah cabal __monty__ my bad, I just keep mixing all those "I'm running all the language in a $HOME dotfolder" together :(
09:48:09 <sclv> (i reviewed the gibbons paper and was unhappy with how it gave the acknowledgements for the development of the ideas, so linked bartoz instead)
09:48:14 <EvanR> you want a special ADT for an entry, which could be a number, a *, a slashed star, and whatever else can go in 1 slot
09:48:28 <sclv> (it doesn't lay wrong claim to originality, but it doesn't credit as clearly, which makes me saad)
09:48:28 <EvanR> then an entry is just (That,That,That,That,That,DayOfWeek)
09:48:50 <EvanR> no type classes involved
09:49:32 <EvanR> representing a crontab is the easy part... interpreting them is another
09:53:08 <slaterr> EvanR, I didn't quite get what you meant. this is what I have now. https://bpaste.net/show/37e4d8c9031e
09:54:10 <EvanR> you more or less have what i was talking about, except the ADT for each entry seems to have extraneous stuff in it
09:54:39 <slaterr> like what?
09:54:57 <EvanR> you are effectively packaging upper and lower bounds with your fields, which must be a certain value. they arent configurable, so they arent really data
09:55:22 <EvanR> instead you can have a separate validation step, required to build your entry values
09:55:36 <EvanR> aka the smart constructor technique
09:56:59 <slaterr> what about making Entry type safe? Entry Minute, Entry Hour, etc. I'm not quite sure how to represent that the best way
09:57:19 <EvanR> and you need an overall validation for the whole crontab line, since months have different number of days
09:57:32 <slaterr> yes
09:58:01 <EvanR> the smart constructor is a simple way to get "type safety" without needing advanced complex type system features
10:04:10 <EvanR> if you have a number type indexed by upper bound, you could encode the 0-59 into the type. Example type Minute = Fin 60, type Hour = Fin 24, but this opens a large can of worms and still doesnt address days-in-month validation
10:04:48 <slaterr> yeah, I don't want to go that far
10:08:39 <slaterr> does cron complain if crontab contains 2nd month, 30th day?
10:09:10 <EvanR> try it and see, my money is on yes
10:09:22 <EvanR> but i think it accepts 2nd month 29th day in any year
10:09:40 <slaterr> since it doesn't have a year field, it has to
10:10:13 <byorgey> but will it actually happen on March 1 in a non-leap year, or will it only happen during leap years??
10:10:41 <EvanR> in a broken cron, yes :)
10:13:11 <byorgey> fair enough, I guess I am really asking what the cron *specification* says.  But perhaps there is no such thing, only implementations.
10:13:40 <Chousuke> is cron part of POSIX?
10:15:16 <int-e> ... #haskell, really? https://pubs.opengroup.org/onlinepubs/9699919799/utilities/crontab.html
10:15:51 <EvanR> yeah i have that manpage, no mention of leap years
10:15:59 <int-e> but no "leap" in there
10:16:58 <byorgey> it's a bit vague.  I would interpret it as saying that 2 29 will not match in a non-leap year.
10:16:59 <EvanR> putting 29 means it only happens in leap years, but I don't have the proof from BSD gods
10:17:20 <byorgey> I demand a denotational semantics!
10:17:20 <EvanR> with that out of the way we can decide to find the proof
10:17:21 <wroathe> slaterr: Is this just an experimental thing you're building or something you intend to use in production?
10:17:50 <Chousuke> so I guess the crontab format has no way of specifying "last day of February" :P
10:18:27 <int-e> relatedly: https://stackoverflow.com/questions/6139189/cron-job-to-run-on-the-last-day-of-the-month (eww)
10:18:43 <asheshambasta> is using Lenses/Prisms to this extent considered harmful? https://gist.github.com/asheshambasta/523fb55e1feefb4d0008cb4205456dd0 
10:18:44 <slaterr> wroathe, not in production, just for my personal use. I need a cron-like daemon on windows that actually works (I tried two, and had issues with them). and I'm using this as an opportunity to use haskell/learn something new
10:18:45 <Chousuke> though you could just have two crontab entries, for 29th and 28th
10:18:55 <EvanR> thats so terrible
10:19:01 <EvanR> (the SO)
10:19:06 <int-e> Chousuke: but then it will run twice...
10:19:26 <Chousuke> oh, true. duh
10:19:48 <wroathe> slaterr: Doesn't windows already have a scheduler?
10:19:52 <EvanR> run at midnight of the first of march, its pretty close to right
10:20:11 <EvanR> in fact distance to right = 0
10:20:39 <wroathe> slaterr: You can even use the scheduler programatically
10:21:23 <slaterr> wroathe, it does, but in my experience it often doesn't fire, and it has no ability to send output to predetermined email address
10:23:06 <gentauro> it's kind of nice that you get `the flair of Liquid Haskell` on top of Haskell (comments) without going to a hole new language: http://goto.ucsd.edu:8090/index.html#?demo=evens.hs
10:23:57 <slaterr> it also annoyingly asks for password every time you change some option (and, from recollection, if you don't enter the proper password, you will not be notified about it, it will just silently fail to run the program)
10:25:23 <gentauro> wroathe: the command is called `at` and it's pretty rubish (yeah the pwd issue is bad)
10:28:19 <wroathe> gentauro: Is that the same thing as https://docs.microsoft.com/en-us/powershell/module/psscheduledjob/register-scheduledjob?view=powershell-5.1?
10:29:30 <gentauro> wroathe: I think that's the powershell version. If you are old school, you will be using the `cmd.exe` version ;)
10:30:05 <gentauro> but I haven't been using `Windows` for more than 3 years (profesionally) so they might have dropped that and went all-in with PowerShell
10:30:07 <wroathe> gentauro: AFAIK the new windows APIs for programmatically working with the Scheduler are pretty good
10:30:22 <EvanR> MS DOS 3.31 pls
10:31:37 <slaterr> at gives me this: The AT command has been deprecated. Please use schtasks.exe instead.
10:32:33 <gentauro> slaterr: fair enough
10:36:04 <dmwit> int-e: I'm pretty sure this one is my favorite answer there: "Set up a cron job to run on the first day of the month. Then change the system's clock to be one day ahead."
10:36:35 <wroathe> dmwit: Some programmers just want to watch the world burn
10:37:11 <EvanR> that deserves a green checkmark
10:37:19 <int-e> dmwit: sounds good to me
10:37:47 <int-e> bonus point for setting up your own one-day-ahead NTP servers for the purpose
10:37:53 <int-e> *points
10:38:09 <EvanR> i could have sworn that day 0 stood for the day before day 1
10:39:19 <EvanR> april 0 = march 31
10:40:51 <slaterr> every manual I've checked lists day of the month range to be from 1 to 31
10:41:22 <EvanR> another great idea goes out the window
10:42:15 <gentauro> I was looking into a blog post I wrote back in 2006 when I was using Windows and I can recognize the `crimson editor` (dog icon) xD
10:42:22 <gentauro> those where the days :P
10:52:44 <wroathe> That PowerShell cmdlet I linked just serializes the flags you specify into an XML file in the scheduled jobs directory that the windows task scheduler uses as a job database
10:54:58 <wroathe> slaterr: You should just be able to wrap your job in an exception handler that sends an email notification failure, right?
10:55:08 <wroathe> slaterr: Instead of reinventing cron for windows with Haskell
11:00:49 <wroathe> slaterr: You could even make your task return a meaningful exit status, and then compose your task with https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/send-mailmessage?view=powershell-6
11:01:12 <wroathe> But this is offtopic for Haskell, so I'll shut up now :P
11:04:55 <boj> is anyone aware of an example of running a monad transformer in something like freer-simple?
11:06:00 <searock> Hi! anyone here who is familliar with Gloss?
11:06:24 <glguy> searock: There are such people, yes.
11:06:37 <searock> I'm trying to render a sprite and am struggling with the type. 
11:07:10 <searock> Thanks glgguy! I'mCurrently using loadBMP which returns IO Picture, but that does not fit the structure of my program. 
11:07:59 <searock> My function needs to return Picture and not IO picture
11:09:26 <glguy> OK, then you'll need to load the Picture ahead of time or change the function you're writing to return IO Picture instead of Picture
11:10:33 <searock> Well, yeah. You're right
11:10:48 <wroathe> searock: Once you're in IO, there's no getting out (ignoring certain things), and for good reason
11:11:22 <searock> But I'm using the play function (built in Gloss) and I don't think it accepts IO
11:11:27 <searock> Wroathe, Thanks. 
11:11:45 <glguy> searock: You can load the bitmaps before you use play, or you can use playIO
11:12:23 <searock> What do you mean by loading them before play, loading them at main?
11:12:30 <Solonarv> exactly
11:12:31 <glguy> yeah
11:13:11 <searock> Holy shit, that somehow feels dirty :p
11:13:16 <searock> But thanks guys
11:13:20 <glguy> No, it's not dirty
11:13:22 <Solonarv> something like: main = do sprite <- loadBMP "sprite.bmp"; play ... sprite ...
11:13:37 <dmwit> You've never clicked on a game and sat at the loading screen for five minutes waiting? =)
11:13:45 <searock> I get what you mean, thanks guys. Really really appreciated! 
11:14:01 <Solonarv> in fact, it's the opposite of dirty - dirty would be sneakily loading a file even though we aren't in IO!
11:14:05 <glguy> dmwit: Time to get an SSD!
11:14:28 <dmwit> Every time I upgrade my hard drive they make the game bigger to compensate!
11:14:40 <glguy> hard drives have been winning lately
11:14:43 <searock> Solonarv, well, yeah. Actually yeah. I suppose keeping all the dirty bits at main makes sense
11:16:18 <dmwit> I dunno. I got an SSD, and not a budget one, about 3.5 years ago, and even games from 12 years ago sit at the loading screen for a while.
11:16:59 <glguy> I've managed to kill lots of the "loading time" by deleting the branding videos at the beginning
11:17:16 <dmwit> Of course I don't count the branding videos in that.
11:18:31 <dmwit> Five minutes was an exaggeration. But my point was just that "the first thing the program does is load a bunch of stuff" is a common pattern that even the top professionals use.
11:18:44 <searock> By the way, the gloss documentation refers to data type world, is that an own defined datatype ref http://hackage.haskell.org/package/gloss-game-0.3.3.0/docs/Graphics-Gloss-Game.html
11:19:01 <dmwit> Nope. world is just a type variable.
11:19:06 <dmwit> You can pick it to be anything you want.
11:19:14 <searock> Oh my, that is amazing. 
11:19:22 <Solonarv> type variables don't have to be a single letter ;)
11:19:25 <glguy> searock: The type constructors are the capitalized things. Those are predefined.
11:19:50 <wroathe> The world is what you make it :D Something something deep philosophy.
11:20:03 <searock> Massive thanks guys. 
11:20:59 <searock> I wanted to make something which felt more like a "real world" project rather than some interpreter for a toy language in Haskell and found it quite difficult, you've been massive help!
11:35:30 <argent0> hi, in servant, how do I append a ".json" at the end of a query string, but before the arguments (?q=foo). Eg:  https://hacker-news.firebaseio.com/v0/item/8863.json?print=pretty. `"items" :> Capture "itemid" Integer  :> ".json" :> Get '[JSON] Value` adds a '/'.
11:36:32 <argent0> resulting in: https://hacker-news.firebaseio.com/v0/item/8863/.json?print=pretty (?)
11:36:58 <boj> not really sure you can, since you are technically making a String there
11:41:02 <argent0> boj: that seems to be the case
11:44:57 <boj> argent0: maybe you could make a fromHttpApiData instance which parses the Integer and drops the .json part?
11:45:30 <argent0> boj: better yet, "curl  https://hacker-news.firebaseio.com/v0/item/19199647/.json
11:45:35 <argent0> " works regardless
11:45:40 <boj> change Integer to some custom IntegerWithJson type.
11:45:49 <boj> ah
12:03:39 <slaterr> :t intersperse
12:03:40 <lambdabot> a -> [a] -> [a]
12:03:58 <slaterr> @hoogle Foldable t => a -> t a -> t a
12:03:58 <lambdabot> Yi.Syntax.Tree toksAfter :: Foldable t1 => t -> t1 a -> [a]
12:03:58 <lambdabot> Safe.Foldable minimumDef :: (Foldable t, Ord a) => a -> t a -> a
12:03:58 <lambdabot> Safe.Foldable maximumDef :: (Foldable t, Ord a) => a -> t a -> a
12:04:03 <slaterr> is there such a thing?
12:07:31 <[exa]> slaterr: it would probably need a generic way to lift 'a' to 't a'
12:07:54 <argent0> slaterr: how would that work for a tree?
12:08:52 <slaterr> good point.. anything else than Foldable that could used to write generic intersperse?
12:09:05 <[exa]> slaterr: monoid?
12:09:05 <argent0> I believe its related to: http://comonad.com/reader/2015/free-monoids-in-haskell/
12:10:22 <argent0> s/its/it's/
12:13:03 <dmwit> slaterr: What other type do you want to use intersperse with?
12:13:48 <[exa]> slaterr: anyway, there's one (weird) intersperse in foundation with intersperse::Sequential c => Element c -> c -> c
12:13:52 <[exa]> (not a fan of that)
12:14:36 <[exa]> and another one from mono-traversable, probably almost same sans type renaming: intersperse :: SemiSequence seq => Element seq -> seq -> seq
12:15:36 <slaterr> dmwit, any sequential list-like type, Array, Vector, etc. I'm writing a function using it, and wondered I could make it more generic
12:17:24 <[exa]> slaterr: do the sequential list-likes have a common generic function that can convert 'a' to a singleton 't a'?
12:17:30 <dmwit> It is hard for me to imagine an collection of class methods that would enable an efficient implementation of intersperse for both [] and Array (other than intersperse itself).
12:17:59 <slaterr> [exa], I don't know
12:18:37 * hackage consumers 2.2.0.0 - Concurrent PostgreSQL data consumers  https://hackage.haskell.org/package/consumers-2.2.0.0 (MikhailGlushenkov)
12:22:02 <[exa]> btw. there's a whole bunch of 'singleton' functions for all containers around, but no Singleton class. Probably for a reason though.
12:22:41 <dmwit> :t \v' -> M.deleteMax . M.fromAscList . concatMap (\(k,v) -> [(2*k,v), (2*k+1,v')]) . M.toAscList
12:22:42 <lambdabot> (Num k, Eq k) => a -> M.Map k a -> M.Map k a
12:22:49 * dmwit nods sharply to himself
12:24:09 <dmwit> Oh, that Eq is because I should have used fromDistinctAscList, I guess.
12:24:28 * [exa] scared
12:25:37 <dmwit> Ask a weird question, get a weird answer...
12:26:05 <[exa]> :]
12:26:13 <ch2db[m]> possible to create infinite arrays for learning algorithms?
12:26:28 <dmwit> Infinite arrays, no. Infinite lists, yes.
12:27:18 <dmwit> But see:
12:27:20 <dmwit> ?hackage total-map
12:27:20 <lambdabot> http://hackage.haskell.org/package/total-map
12:36:50 <ch2db[m]> array=infinite list -> name of next array
12:40:40 <kadoban> That wouldn't be so good for lookup by index, without some kind of table-of-contents structure
12:43:34 <monochrom> I am not sure what "array=infinite list -> name of next array" means actually.
12:44:04 <monochrom> Especially since I had experience with students in math channels writing like "x^2 = 2x -> x+x".
12:44:41 <monochrom> In other words what they wrote has nothing to do with what they thought.
12:46:18 <ch2db[m]> thought was create an array infinite list and adopt binary search tree algorithm to create new arrays
12:59:43 <fen> have added defaults for Unfoldable; https://gist.github.com/fen-hs/0e01cf44b066804433b24a64429f2400
13:00:03 <fen> and Foldable and Traversable; https://gist.github.com/fen-hs/6bb03486008a8a31b9edf95f8bd35f46
13:01:06 <fen> would be interested if anyone can has any ideas about the functions such as;
13:01:07 <fen> defaultTraverse_r :: (Traversable_r r' r,Traversable_r r t,Applicative f) => (r' a -> f (r' b)) -> t a -> f (t b)
13:01:25 <fen> where the r' parameters seem slightly mysterious 
13:02:16 <eacameron> Can someone explain why I am failing to either do this correctly or convince GHC that I am doing it correctly: It's a toy attempt at polymorphic variant: https://gist.github.com/3noch/74b47bf45fc4403278e698edb3fe3dc9
13:03:47 <Cale> eacameron: DSum not good enough? ;)
13:04:07 <eacameron> Cale: This is honestly just to learn, not for a real use case
13:04:16 <Cale> ah, cool
13:04:54 <Cale> Yeah, this looks like you need to somehow prove to GHC that Concat is associative
13:04:58 <Cale> which... is painful
13:05:30 <Cale> Maybe there's a way to sidestep it though
13:05:34 <eacameron> I took that error and just pasted it into ghci with "5 :: erorr => Int" and it didn't complain ...
13:06:43 <eacameron> Well, I replaced some of it with example lists of types but anyway
13:06:56 <eacameron> Hm, I wondered if that was it
13:07:07 <Cale> ah, yeah
13:07:17 <Cale> If you have a *specific* list of types
13:07:26 <Cale> then it will be able to tell that it's the same by computation
13:07:34 <Cale> but if you have variable lists, it can't compute
13:07:59 <Cale> Concat as _  can't reduce
13:08:14 <eacameron> Ah I see
13:08:18 <eacameron> That's interesting.
13:09:03 <eacameron> The way vinyl does this is it actually produces proof at each match of a slightly refined Sum
13:09:43 <eacameron> But I thought I could do it like this...
13:09:43 <Cale> This is the fundamental frustration of dependently typed programming: that it matters intensely the precise manner in which functions match on their arguments, because it affects which terms with free variables in them are definitionally equal, and can be treated as such while typechecking
13:11:59 <eacameron> Interesting.
13:12:05 <Cale> eacameron: Is the order relevant?
13:12:24 <eacameron> The order only matters when matching. The ctor of the Sum gadt throws order away
13:12:29 <Cale> hm, I suppose it is
13:12:50 <Cale> also just because you need the things to be equal when typechecking
13:12:57 <eacameron> I really wanted to avoid that but I couldn't think of a way without introducing some sort of "ord" constraint on my types
13:13:07 * hackage free-algebras 0.0.7.2 - Free algebras in Haskell.  https://hackage.haskell.org/package/free-algebras-0.0.7.2 (coot)
13:13:10 <eacameron> which would be painful
13:13:26 <Cale> One thing you could maybe do is just to introduce something like...
13:14:19 <Cale> concatAssoc :: forall as bs cs. Dict (Concat as (Concat bs cs) ~ Concat (Concat as bs) cs)
13:14:58 <eacameron> Hmm... how would I produce this `Dict`?
13:15:07 <Cale> unsafeCoerce? :D
13:15:11 <eacameron> 😂
13:15:12 <Cale> concatAssoc = unsafeCoerce (Dict :: (Int ~ Int))
13:15:24 <Cale> er
13:15:29 <Cale> concatAssoc = unsafeCoerce (Dict :: Dict (Int ~ Int))
13:15:51 <Cale> It might be possible to do better, and actually prove it
13:16:32 <eacameron> I might try that just for fun but of course I'm now curious how to actually prove it.
13:16:33 <YottaiQ> Dear guys, the operation #SOSNicaragua needs help of all #Anonymous people, please do not leave us alone. Data here =>>https://pastebin.com/hBbEZLrK
13:17:28 <Cale> Well...
13:18:59 <eacameron> `askCale = unsafeCoerce` is a much more palatable name
13:44:55 <Athas> How many packages are using Backpack these days?
13:46:31 <Boarders> does anyone know how I enable turn on RTS using cabal new-run?
13:46:43 <Boarders> or can point me to an example for how to do it
13:47:05 <aplainzetakind> I am using ghcup and new-style cabal projects to avoid system-wide packages in general. Can I make certain libraries always available in `cabal new-repl` executed outside a project?
13:49:39 <sm> it's pretty funny.. after so much time working with immutable values, I add a couple of mutable variables and days of hard thinking and debugging ensue
13:52:15 <Cale> eacameron:  https://gist.github.com/3noch/74b47bf45fc4403278e698edb3fe3dc9#gistcomment-2842000
13:52:40 <Cale> eacameron: I'm not sure how to get the rest of the way there...
13:53:29 <Cale> eacameron: but at the very least, you can parametrise everything by ConcatAssoc as bs cs, and eventually those instances will always resolve...
13:54:50 <Cale> Also, I tried using AllowAmbiguousTypes and TypeApplications, and something was going wrong -- seems like you can't use TypeApplications to choose types of a kind that's not *
13:55:57 <c_wraith> that doesn't seem right.
13:56:39 <Cale> It didn't seem right to me either.
13:56:39 <__monty__> aplainzetakind: The intersection of "not system-wide" and "not in a project" sounds pretty empty to me.
13:56:51 <c_wraith> Prelude> :t fmap @Maybe
13:56:51 <c_wraith> fmap @Maybe :: (a -> b) -> Maybe a -> Maybe b
13:57:00 <Cale> Ah, yeah
13:57:41 <c_wraith> Ah, looks like it doesn't work with Polykinds, though
13:57:51 <c_wraith> that certainly a bug
13:58:23 <c_wraith> Oops, nevermind.  My test was broken.  It works with polykinds
14:02:01 <dmwit> Boarders: Put ghc-options: -rtsopts in the appropriate cabal file stanza, I think.
14:02:14 <eacameron> Cale: haha oh interesting. So this just sort of side-steps the need to prove anything and allows GHC to defer the "convincing" until the types are fully known?
14:02:51 <Cale> Well, with a version of concatAssoc without the Proxy arguments, when I tried concatAssoc @as @bs @cs in the instance for ConcatAssoc (a : as) bs cs, it complained • Expected a type, but ‘as’ has kind ‘[k1]’
14:03:20 <Cale> and various other ways of saying the same thing, depending on exactly how much I annotated things with types
14:03:30 <Cale>  Couldn't match kind ‘[k1]’ with ‘*’, etc.
14:04:53 <Cale> eacameron: yeah
14:05:31 <Cale> eacameron: It's exactly the proof that one would want to give, apart from the *actual* application of the induction principle
14:05:44 <Cale> It's the arguments to the induction you'd want to perform
14:07:58 <eacameron> Meaning, the typeclass let's you say "Given a proof of X" and then when GHC can fully determine the concrete type it can do the "proof" itself by just running testing for equality?
14:08:02 <dmwit> Cale: It's got to be `concatAssoc @_ @as @bs @cs` because of PolyKinds.
14:08:13 <Cale> ohhhhhh
14:08:15 <Cale> I see
14:08:34 <Cale> sweet
14:08:36 <eacameron> kind variables end up floating before type variables
14:08:41 <eacameron> so I read
14:08:48 <dmwit> (How did I determine this? With :set -fprint-explicit-foralls and :type +v concatAssoc. I would never have guessed it myself.)
14:09:35 <Cale> right, I should have expected that there was a kind parameter as well, but the errors that GHC gave were very confusing
14:09:53 <dmwit> I can agree with that.
14:09:57 <Cale> so that's a bit nicer
14:10:00 <eacameron> Poly kinded things probably shuold just require explicit foralls 
14:10:23 <Cale> https://gist.github.com/3noch/74b47bf45fc4403278e698edb3fe3dc9#gistcomment-2842025
14:10:48 <nshepperd1> I'd have thought that type applications would only touch the type variables explicitly mentioned with forall
14:10:51 <Cale> Possibly everything should require explicit foralls all the time
14:10:52 <dmwit> Interestingly, GHC really didn't like @*. =)
14:11:09 <Boarders> like how do I pass +RTS -xc -RTS to cabal new-run
14:11:10 <dmwit> nshepperd1: Classes have slightly different rules because there's no place for foralls to go.
14:11:14 <Boarders> I just get Invalid argument
14:11:21 <Boarders> probably doing something dumb
14:11:47 <dmwit> Boarders: cabal new-run +RTS --RTS foo +RTS -xc -RTS
14:11:54 <eacameron> nshepperd1: They don't. They work for any type variable whether or not the definition used explicit forall
14:12:13 <Cale> Boarders: It's genuinely tricky ;)
14:12:24 <eacameron> Which makes things really fun when you change add the explicit forall and do a minor version bump
14:12:35 <Cale> You may need an additional -- there
14:12:43 <Cale> in addition to dmwit's args?
14:12:58 <dmwit> Oh, yeah, maybe. I haven't used raw cabal new-run in so long I forget what an awful interface it has.
14:13:02 <Cale> in order for the RTS arguments intended for the program to go through to it
14:13:18 <dmwit> cabal +RTS --RTS foo -- +RTS -xc -RTS
14:13:54 <dmwit> yeesh
14:13:57 <Boarders> ah I think that does it
14:13:59 <Boarders> good grief
14:14:03 <eacameron> Cale: So is it possible to do the inductive proof for GHC?
14:14:03 <Boarders> thank you very much for your help
14:14:05 <Cale> It's imo really bad that TypeApplications work to specify types that were not explicitly forall'ed
14:14:17 <Cale> eacameron: That's what I'm not sure about.
14:14:40 <Boarders> Cale: I agree especially because it introduces an arbitrary order of the vars
14:14:54 <eacameron> yes...I made an issue on safe-exceptions about it and heard tha snoyman was tempted to ban type applications because of it lol
14:15:22 <Cale> eacameron: We have the parts, but I'm not sure how to go from this to "arbitrarily discharge any ConcatAssoc constraint because its type parameters are closed kinds, and we have full instance coverage"
14:15:56 <dmwit> I think there is currently no way.
14:16:37 <dmwit> I also think it would require a pretty serious reworking of type families to make a way, because you think those are closed kinds but they're not.
14:17:16 <nshepperd1> E
14:17:29 <nshepperd1> eacameron: yeah, that's pretty inconve
14:18:11 <nshepperd1> Inconvenient when even rearranging typeclass constraints on a thing can change the visible type variable order
14:19:14 <eacameron> Clearly what we need is *named type variable arguments*
14:19:16 <Cale> dmwit: Right, it's not really about closed kinds, but rather, the ability to apply an induction principle
14:19:22 <dmwit> https://gist.github.com/ekmett/ac881f3dba3f89ec03f8fdb1d8bf0a40 shows how to inject a fresh type into any kind
14:20:03 <dmwit> I think the kind being closed is pretty important for induction principles' correctness.
14:20:39 <dmwit> Unless you have infinite base cases in your principle...
14:20:53 <Cale> oh, I see what you mean
14:21:10 <Cale> I thought you were referring to the fact that we're still parametric on the k
14:21:20 <Cale> in the case of ConcatAssoc
14:21:34 <Cale> This is just... blah
14:21:37 <dmwit> yeah
14:21:47 <dmwit> Something with type families is fundamentally wonky.
14:22:08 <eacameron> where "wonky" has a precise meaning
14:22:15 <johnw> if I call a "safe" FFI function, is there a chance it will run in a different thread?
14:23:04 <eacameron> johnw: different thread than what?
14:23:22 <johnw> the Haskell side and the C side
14:23:34 <johnw> so, that if C calls a Haskell callback, then myThreadId of the former /= the latter
14:23:49 <slaterr> does cron execute jobs at 00 second? (its timer resolution is 1 minute)? if so, how would one implement that functionality? count delay from now until next full minute, then sleep for that period?
14:24:23 <Cale> dmwit: The fact that instances can pull apart application in the presence of type families is perhaps the truly wonky part.
14:24:42 <Cale> It made sense for them to be able to do that when everything was a type constructor
14:24:56 <Cale> But now that we have proper type functions, it... doesn't.
14:25:10 <eacameron> johnw: Oh hm...my impression was that it's possible for the scheduler to move haskell code to any thread it likes so it seems that the *os* thread ID would not be guaranteed the same. But the *haskell* thread ID likely would be
14:25:40 <johnw> hmm.. it seems to not be stable
14:25:42 <johnw> (the Haskell id)
14:29:07 <dmwit> Cale: yep
14:31:28 <fen> here is the FIFO module https://gist.github.com/fen-hs/9772c2ce27a355984add2e5b7d352fbb
14:33:52 <geekosaur> my understanding re threads is there are pools used for normal Haskell threads, bound threads, and I/O manager threads. bound threads are fixed, the others can switch between both Haskell threads in the same pool and OS threads likewise
14:35:14 <ProofTechnique> Is there an existing “case analysis on ListF” convenience function for recursion schemes? Like I could say `cata (listAlg 0 (+))` for `sum`, for instance. Or other such convenience functions?
14:36:09 <ProofTechnique> I can write one, I’m just curious if there’s something already floating around
14:50:44 <Gurkenglas> ProofTechnique, seen http://hackage.haskell.org/package/catamorphism ?
14:53:14 <ProofTechnique> I have not, but I’ll definitely look it over. Looks like a pretty nice tool if you don’t mind TH.
14:55:40 <ProofTechnique> Thanks
15:29:02 <fen> here is a module with Church_r (etc), showing how FIFO instances are used to derive Unfoldable instances 
15:29:04 <fen> https://gist.github.com/fen-hs/a71ab735bf977d9b948a62416662fe57
15:29:25 <fen> it also has some build functions, and associated "loops"
15:30:02 <fen> the fusion rules should appear in the Unfoldable class.
15:31:23 <fen> build :: Set f => Church a -> f a; build (Church f) = f set
15:31:36 <fen> loop :: Set f => s -> State s a -> f a; loop s = build . unfoldr s
16:10:18 <libertyprime> Hey guys. Are missing .so files a common occurrence running stack? I've noticed this kinda thing a few times. https://ptpb.pw/ePNR.org/org If so, how do people usually deal with this? NixOS instead of stack on ubuntu?
16:10:32 <slaterr> what package for sending emails do people usually use?  I see several on hackage
16:10:59 <libertyprime> https://ptpb.pw/ePNR.org
16:18:59 <ProofTechnique> libertyprime: It looks like you've somehow ended up with GHC 8.4.3, but libs for GHC 8.4.4
16:19:10 <ProofTechnique> That's bizarre
16:19:40 <ProofTechnique> My guess would be to update the `compiler` field in your stack.yaml, but I dunno stack
16:19:46 <ProofTechnique> I'm all Nix, these days
16:33:26 <fen> have added fusion rules for build; https://gist.github.com/fen-hs/a71ab735bf977d9b948a62416662fe57
16:33:47 <fen> its a lot of code but if anyone could check it would be much appreciated 
16:46:12 <zachk> can I define instances of type synonyms made with the keyword type? 
16:46:28 <johnw> if you turn on TypeSynonymInstances
16:46:39 <johnw> otherwise in general, you have to ask yourself if this is a good idea
16:46:50 <hpc> type synonyms are like running a string replace over your code before you compile it
16:46:54 <MarcelineVQ> you can but it gets really easy to make clashing instances
16:49:10 <fen> its not a good idea for multiparameter typclesses
16:49:29 <fen> because the type synonyms cant be partially applied
16:49:57 <hpc> if you ever want something like "it's this type, but treat it differently", use newtype
16:50:01 <fen> or the parameters commuted easily inside the tynonym
16:50:12 <hpc> like Sum and Product are both newtypes over other numeric types
16:50:23 <hpc> and certain operations either are in terms of addition or multiplication
16:50:30 <hpc> but you can't do fooSum + barProduct
16:51:16 <wroathe> Can't type synonyms sometimes make types more self-documenting for an end user?
16:51:23 <wroathe> For example: type EnvReader o s a = ReaderT o (StateT s IO) a
16:51:28 <hpc> they usually don't
16:51:47 <wroathe> I don't want them to care that it's a Reader + State + IO type
16:51:56 <hpc> users don't expect EnvReader to actually be ReaderT
16:52:02 <hpc> they expect it to be an instance of MonadReader
16:52:15 <hpc> and then when they use your library they're going to see ReaderT all over their type errors
16:52:19 <hpc> or when they :t something
16:52:44 <hpc> it's too transparent to be informational because that same transparency makes it display differently everywhere
16:54:04 <wroathe> Well, originally that was a newtype, and I was using GeneralizedNewtypeDeriving
16:54:11 <hpc> that's the way to do it
16:54:20 <hpc> and then don't export the constructor
16:54:28 <hpc> the best way to not care is to not even /know/
16:54:35 <wroathe> But then I realized that that's silly because I don't need to define any new instances
16:54:37 <hpc> true abstraction
16:54:41 <jackdk> what's the currently recommended pastebin for #haskell?
16:54:47 <wroathe> @where paste
16:54:47 <lambdabot> https://gist.github.com
16:54:47 <hpc> jackdk: in the topic
16:54:47 <MarcelineVQ> that's kind of deep
16:55:11 <hpc> MarcelineVQ: deeper than deepseq
16:55:35 <jackdk> oh hey that's a thing. thanks hpc, wroathe. and for a non-gh option?
16:55:48 <wroathe> Just use gh
16:56:33 <finlay> Hi #haskell!
16:56:41 <hpc> if you use an alternate one, my rule of thumb for a good paste site is i don't have to allow javascript
16:56:56 <wroathe> See, if you don't need to define any "custom" instances for your monadic newtype, there's really no point in making it a newtype, right?
16:56:56 <slaterr> is there ignoreAllNonAsyncExceptions function?
16:57:02 <slaterr> finlay hi
16:57:07 <finlay> Does anyone know if it is possible to try out the linear types in ghc yet ? some dev version ?
16:57:12 <zachk> so I can't make instances of multiparameter type synonyms? 
16:57:13 <hpc> wroathe: it's an abstraction
16:57:30 <hpc> wroathe: if you think you're going to change it later, making it a newtype constrains the type's API to exactly what you say it is
16:57:49 <finlay> slaterr hi
16:58:04 <hpc> when you change the implementation, it can be a semantic minor change depending on how you do it
16:58:19 <hpc> if you don't abstract it away, the whole of ReaderT, StateT, and IO are its API
16:58:32 <wroathe> hpc: But a type synonym for an existing monad also constrains the API to exactly what I say it is...
16:58:34 <hpc> and any change to the definition of EnvReader is a semantic major change
16:59:07 <hpc> wroathe: it's a reexport rather than you defining the API, which is a subtle difference
16:59:17 <wroathe> Where I'm saying that this thing as exactly the API of a ReaderT r (StateT s IO) ()
16:59:42 <hpc> usually it's not /that/ important in haskell, but in other languages you get burned pretty quickly so i've gotten in the habit of knowing my API to that level anyway
17:00:18 <hpc> in javascript for instance, dependencies get pulled into a project by bundling, and it's per-dependency instead of a global consistent state
17:00:28 <hpc> so you depend on foo and bar, both using different versions of baz
17:00:44 <hpc> if foo and bar both reexport baz's API, but are semantically major versions apart
17:00:49 <hpc> you can't use foo and bar together
17:01:24 <wroathe> later on, I can make it a newtype EnvReader o s a if I feel so included
17:01:37 <hpc> sure, but you haven't really made the user not care
17:01:56 <hpc> you've said "in order to use this type alias, these are all the other things you concern yourself with instead"
17:02:12 <wroathe> As long as I derive instances of all of the Monad* classes it was originally using they should be able to continue not caring, right?
17:02:23 <hpc> no
17:02:33 <hpc> there are things in the ReaderT API above and beyond MonadReader
17:04:45 <wroathe> I suppose in that sense it is more restrictive
17:05:29 <wroathe> In practice though, if they still want to use those non MonadReader operations all they'd need to do is unwrap the newtype
17:05:35 <finlay> guess not. Everyone have  great day haskelling!
17:06:58 <wroathe> hpc: So at the type level, nothing would change
17:07:11 <wroathe> It would still just be an EnvReader o s a
17:07:30 <wroathe> The difference would be the need to "runEnvReader" or something like that to use the non-MonadReader non-MonadState operations
17:08:45 <wroathe> And if they stick to the API that is the intersection of the type synonym and newtype EnvReader's operations from the beginning, nothing would change
17:23:00 <wroathe> hpc: I might just change that to a newtype now. Even though it feels silly to define a new type that is exactly the same as ReaderT it DOES future proof the public API a bit
17:28:37 <[Leary]> The newtype is only silly if you export the constructor. The suggestion is that you don't, if you want full control over the API.
17:29:59 <hpc> (afk)
17:30:24 <hpc> yeah, it's definitely superficially silly, but a lot of API / code factoring problems are like that
17:30:52 <hpc> i've surprised a few people before by taking the idea of good/bad code to its logical extreme
17:31:16 <hpc> and saying that it's possible for code to be outright wrong, if it produces the right result but doesn't properly express the idea behind it
17:31:37 <hpc> two pieces of code can be quickcheck identical, and one of them is still wrong :D
17:34:34 <geekosaur> makes sense to me, if it leads to the next person touching it breaking things
17:35:36 <hpc> let's take it to specifics for extra fun
17:35:43 <wroathe> So on a different topic, learning about free monads made me realize that you basically actually write your program at the type level in Haskell, and the definitions are just an interpretation of those types
17:35:53 <hpc> you're writing a json printer and you want it formatted nice, so you use putStrLn
17:36:09 <hpc> but now you're writing an irc bot or email client, so you use putStr and '\n'
17:36:19 <hpc> (or perhaps "\r\n" and binary mode)
17:36:31 <hpc> because newlines are more significant to express in different contexts
17:36:48 <hpc> wroathe: yep
17:37:34 <hpc> it's a different path towards the same conclusion that DBAs like to say, that data is more important than code working on the data
17:38:46 <hpc> i've never written anything that actually used free or free-like types, but it definitely changed how i thought
17:42:09 <hpc> wroathe: have you learned anything about dependent types yet? that's a whole other world of meaning behind types and values
17:43:59 <wroathe> hpc: I've had the elevator pitch, but I've decided to defer looking into that while I complete my current project
17:44:27 <wroathe> Also, I've got TaPL on my bookshelf, but I don't have nearly the math background to make heads or tails of it :P
17:44:43 <hpc> heh
17:50:29 <Fuuzetsu> Does anyone know how I can get ASM output if I'm compiling with -fllvm? The obvious things like `ghc -O2 -fllvm -optlo=-O3 -optc=-O3 -ddump-asm -ddump-to-file` don't seem to work at all.
17:53:25 <geekosaur> -ddump-asm probably only works with the asm backend. You probably need to arrange for some dump option to reach llc
17:54:52 <geekosaur> and -optc is unlikely to do much of anything
17:56:46 <geekosaur> (-optlc--print-machineinstrs maybe)
17:58:55 <Fuuzetsu> Neither "ghc -fforce-recomp -O2 Term.hs -fllvm -optlc='-O3 -filetype=asm --x86-asm-syntax=intel' -optlo='-O3'" nor "ghc -fforce-recomp -O2 Term.hs -fllvm -optlc='-O3 --print-machineinstrs'" seem to leave an assembly file around
17:59:08 <geekosaur> (but that won't know about -ddump-to-file)
17:59:20 <Fuuzetsu> (nothing prints)
17:59:31 <Fuuzetsu> oh, wait a second
17:59:39 <geekosaur> I on't think those options work that way
17:59:57 <Fuuzetsu> yeah, if I put them in separately it seems to work
17:59:59 <geekosaur> it's liable to pass the whole option as a single parameter which on nonwindows may cause an error
18:03:01 <Fuuzetsu> I have the print-machineinstrs output but that's quite a lot worse than doing something like clang -S...
18:07:10 <fresheyeball> I am trying to figure out the dhall ast for `< Foo : {} | Bar : {} >`
18:07:34 <dmwit> Fuuzetsu: You want to look at the -keep family of options.
18:07:57 <dmwit> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/separate_compilation.html#keeping-intermediate-files
18:08:41 <dmwit> In particular I think -keep-s-files is what you want?
18:09:06 <maerwald> bisecting haskell code is hard
18:09:35 <Fuuzetsu> dmwit: That was the magic trick. Thank you!
18:10:47 <fresheyeball> I thought `UnionLit None mempty` but that does not work
18:21:30 <wroathe> Is there a way to make a higher order function accept a function of variable arity, to make the higher order function's arity depend on the variadic function it accepts?
18:21:51 <wroathe> like a generalized flip
18:21:53 <wroathe> :t flip
18:21:54 <lambdabot> (a -> b -> c) -> b -> a -> c
18:23:43 <nshepperd1> wroathe: With typeclasses, probably, but you'll literally go insane in doing so
18:26:10 <wroathe> So: a -> b, (a -> b) -> a -> c, (a -> b -> c) -> a -> b -> d, (a -> b -> c -> d) -> a -> b -> c -> e, and so on...
18:27:17 <julianleviston> feels like some kind of thing you’d want to write in Idris
18:27:20 <wroathe> nshepperd1: I've been insane before. I'll think about how I can apply typeclasses to this problem
18:28:06 <wroathe> The use case is that I'm writing this little imperative DSL for loading configuration data from the environment
18:28:23 <wroathe> So: merge @Json fromRequiredFile "config/app.json"
18:28:32 <wroathe> as an example
18:28:47 <wroathe> fromRequiredFile is a "source" with a potentially variadic number of arguments
18:29:01 <wroathe> In this case it's just FilePath -> IO a
18:29:08 <fresheyeball> \quit
18:29:31 <julianleviston> I don’t see the variadic bit.
18:29:51 <ProofTechnique> See if you can write it in Agda and extract to Haskell :v
18:30:02 <wroathe> other "sources" include fromEnv, fromArgs, fromMemory, etc
18:30:10 <julianleviston> you could use a datatype to capture over the possible combinations (say up to 10) and tehn call it with the right value.
18:30:22 <julianleviston> (ie make an algebra of your possibilities)
18:30:56 <wroathe> so fromArgs is a nullary "source", and fromMemory is a unary "source", because it would require a single arbitrary piece of data
18:31:05 <julianleviston> then your functions build your algebraic values… 
18:31:43 <wroathe> So I want to be able to write: merge @Pairs fromArgs, or merge @Json fromFile "foo.json"
18:31:46 <wroathe> That's the variadic bit
18:32:03 <julianleviston> did you understand what I was suggesting?
18:32:25 <julianleviston> I don’t know what @Pairs means, tho. What’s @ there?
18:32:34 <wroathe> type applications
18:32:35 <ProofTechnique> I think e’s trying to avoid manual bookkeeping like that
18:33:08 <ProofTechnique> TypeApplications and DerivingVia May be my favorite hot new things
18:33:13 <julianleviston> but… s/he has to write the functions at some point.
18:34:02 <wroathe> so merge is actually a more specific version of 
18:34:06 <julianleviston> seems to me like the problem solves itself — so long as all the functions build the same type, merge only needs to take that type and do whatever it does.
18:34:41 <wroathe> julianleviston: Would you mind quickly writing a bit of pseudocode for your suggestion?
18:34:55 <wroathe> julianleviston: I'm not quite sure how this would form an "algebra"
18:35:14 <julianleviston> data types are an algebra.
18:35:26 <julianleviston> that’s all I was suggesting — unifying your disparate stuff with a single type.
18:36:03 <wroathe> I'll share a gist, uno momento
18:36:17 <wroathe> There's no implementations yet. I'm completely changing my API around.
18:36:34 <julianleviston> doSomethingWithJson :: Text -> Text -> Config -> ProcessableEntity then doSomethingWithFile :: String -> ProcessableEntity then doSomethingWithScreenScraping -> Url -> Something -> ProcessableEntity
18:36:57 <wroathe> julianleviston: https://gist.github.com/JustinChristensen/7bbe421d4e9cfea234a1e987ba91b184
18:36:58 <julianleviston> then merge :: ProcessableEntity -> IO ()
18:37:29 <wroathe> To get that to compile I made fromArgs have the same arity as the other sources
18:37:47 <wroathe> https://gist.github.com/JustinChristensen/7bbe421d4e9cfea234a1e987ba91b184#file-config-hs-L96
18:38:11 <julianleviston> wroathe: I would just use regular functions, but maybe that’s just me.
18:39:28 <wroathe> That's the specific function I want to generalize, so instead of a -> ConfigNode, I can have a -> b -> ConfigNode and so on
18:39:33 <wroathe> same for the "source function"
18:40:13 <wroathe> the idea is to have merge take on the parameters of the underlying toConfig and source functions
18:40:25 <julianleviston> Ok. good luck. Too complex for me :)
18:41:12 <wroathe> I think nshepperd1 might be on to something with using a typeclass for this
18:43:09 <ProofTechnique> wroathe: The only lib I can think of that does crazy stuff with arity is formatting: https://hackage.haskell.org/package/formatting-6.3.7/docs/Formatting.html
18:44:05 <wroathe> ProofTechnique: Thanks. I'll take a look.
18:45:47 <julianleviston> What about Lens?
18:45:51 <julianleviston> ;-)
18:46:53 <wroathe> The cool thing about using TypeApplications here is that there's nothing stopping me from exporting a monomorphic form of merge for each type I support in another module :D
18:47:41 <ProofTechnique> Lens isn’t the solution to everything... yet. Eventually there will be a “do what I mean” optic and we can all just retire
18:48:04 <julianleviston> I was talking about how it does “crazy things with arity” :) even tho it doesn’t really.
18:48:33 <ProofTechnique> Oh. :) Yes
18:49:52 <wroathe> I started out trying to build a version of https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-2.2 for Haskell
18:50:08 <wroathe> And it's led me down some truly dark and twisted roads :P
18:51:10 <julianleviston> why so dark and twisted?
18:51:29 <julianleviston> trees are nice data structures to use for such things, I’d reckon, no?
18:51:38 <wroathe> I started out trying to make the API of my library match a lot of the things in that
18:51:52 <wroathe> But the .NET way of doing things doesn't map cleanly to Haskell
18:51:56 <julianleviston> feels like shoehorning imperative code into FP.
18:52:04 <julianleviston> maybe.
18:52:56 <ProofTechnique> julianleviston: Surely you mean Option, since it’s C#
18:53:41 <julianleviston> ProofTechnique: I can see how you might be Maybe confused with maybe, but in this case I didn’t mean the data type, *or* the function from Data.Maybe :P I meant the english word maybe. 
18:54:19 <wroathe> If I can get this piece working, the last major design decision will be be allowing the use of something like optparse-applicative for the CLI handling
18:54:54 <wroathe> and generating CLI usage and completions
18:56:07 <wroathe> Anyway, thanks yous.
18:57:37 * hackage yesod-gitrev 0.2.1 - A subsite for displaying git information.  https://hackage.haskell.org/package/yesod-gitrev-0.2.1 (DanBurton)
19:27:07 <dstromboli> Howdy, #haskell. I'm trying to understand the following line: data Tree2 a b = Leaf2 a | Branch b (Tree2 a b) (Tree2 a b)
19:27:40 <Fuuzetsu> What do you not understand about it?
19:27:54 <dstromboli> It looks to me like the tree only has one branch from any particular node, and a branch
19:27:58 <dstromboli> and a leaf*
19:33:32 <maerwald> Network.BSD.getHostByName: does not exist (no such host entry)
19:35:44 <jackdk> dstromboli: can you write out three example values of type Tree2 Int String for us?
19:36:22 <dmwit> dstromboli: | is not "and", but "or"
19:37:32 <dmwit> A value of type `Tree2 a b` fits into exactly one of the following two patterns: either it is labeled by `Leaf2`, in which case it contains a value of type `a` (and nothing else); or else it is labeled by `Branch`, in which case it contains a value of type `b`, a value of type `Tree2 a b`, and another value of type `Tree2 a b`.
19:38:13 <dstromboli> That makes much more sense, I was reading it as a pattern guard which makes it uninterpretable
19:38:20 <dmwit> That's the mechanical translation from Haskell to English. The idiomatic translation is that a `Tree2 a b` is a binary tree whose leaves have `a` labels and internal nodes have `b` labels on them.
19:40:18 <dstromboli> dmwit: that makes a great deal of sense, thanks very much
19:41:37 <jackdk> dmwit: I like that use of "labeled" - explaining constructors to people who don't have much programming experience and do not get an intuitive handle on constructors is one of the weaker parts of my teaching practice
19:42:41 <dmwit> Yeah, it's not an easy thing to teach.
19:43:25 <dmwit> I remember seeing (lisp? racket? scheme?) atoms for the first time and thinking, "Yeah, but... what is the actual BITS that thing means?".
19:46:26 <jackdk> taking a detour into language semantics rules is not satisfying, but there's really not much below constructors as far as primitives are concerned
19:46:55 <jackdk> I mean, it's fine if you know that stuff, but for freshmen or cross-training industry programmers that's not something they're likely to know either
19:47:30 <monochrom> I also explain it as "tag" and "label" to my students. You get to choose how you label the different cases. Done.
19:48:14 <monochrom> In fact I don't think it's healthy to give any further semantics than that.
19:50:25 <dstromboli> I hadn't even considered that this is a constructor, I come primarily from C++ so the parallel between a Haskell constructor and a C++ constructor is a difficult line to draw
19:51:06 <monochrom> Yeah don't draw a parallel. There is none. Just coincidence in "I want to call this 'constructor'".
19:51:29 <monochrom> C++ constructor is a piece of arbitrary code you write. Haskell constructor you write no code at all.
19:51:48 <monochrom> Right there you see the two are completely related.
19:51:58 <monochrom> Next: C++ functors vs Haskel functors!
19:52:15 <monochrom> err completely unrelated!
19:52:51 <dstromboli> It certainly feels like relearning programming altogether, but understanding something in Haskell is very gratifying in its elegance
19:52:59 <monochrom> Well apart from being complete opposites in almost every aspect.
19:54:22 <monochrom> C++ constructor: For the same class, every constructor must have the same name, and must differ in parameter types.  Haskell constructor: For the same type, every constructor must have a different name, and no restriction on common and uncommon parameter types.
19:54:50 <monochrom> Like every aspect is antipodal like they run away from each other.
20:42:07 * hackage simple-cmd-args 0.1.0 - Simple command args parsing and execution  https://hackage.haskell.org/package/simple-cmd-args-0.1.0 (JensPetersen)
21:26:37 * hackage kafka-device 1.0.0.0 - UI device events via a Kafka message broker  https://hackage.haskell.org/package/kafka-device-1.0.0.0 (BrianBush)
21:28:03 <dumptruckman> Anyone have much experience with Eta?
21:28:04 <dstromboli> ^^ what are those?
21:28:20 <dstromboli> sorry dumptruckman, not you
21:28:58 <glguy> dstromboli: hackage.haskell.org is how Haskell package are distributed. That bot announces new uploads
21:29:35 <dumptruckman> trying to understand "Prelude.read: no parse" but I can't be sure what types I'm even working with here
21:31:06 <glguy> dumptruckman: Put a type signature on the result. If the type you thought it was was incorrect you'll get a type error with what was expected
21:31:54 <dumptruckman> oh nice
21:32:15 <dumptruckman> eh, i figured it out anyway
21:32:39 <dumptruckman> Eta java interop is kind of painful
21:32:53 <koz_> You're asking Haskell to play along with Java.
21:32:58 <dumptruckman> :)
21:33:00 <koz_> It's not gonna be pretty no matter what you try.
21:33:09 <dumptruckman> Well hey, I got a discord bot running
21:33:30 <dumptruckman> But only just... can't quite get it to shutdown
21:33:57 <dumptruckman> https://hastebin.com/ovupilelol.coffeescript
21:41:43 <parsnip> uh oh
21:41:59 <parsnip> https://pastebin.com/h8eayARN
21:43:08 <glguy> hledger-web doesn't support the version of GHC you picked
21:43:09 <iqubic> Can you run "cabal-update" and try again?
21:43:33 <glguy> But there's a newer version on hackage 
21:45:11 <parsnip> thank you all, trying these.
21:49:17 <dstromboli> glguy: that's pretty neat
21:50:07 <parsnip> i've updated, nothing
21:50:21 <parsnip> glguy: this is an old hledger-web, you sure i need a newer ghc?
21:50:33 <sm> you need an older one, with base < 4.12
21:50:47 <sm> cabal new-install -w ghc-8.2 ... eg
21:51:08 <sm> (or a newer hledger-web)
21:54:56 <glguy> parsnip: No, your GHC was too new
21:55:26 <parsnip> ah right. trying to tweak a docker image that starts with `FROM haskell as dev`
21:55:53 <parsnip> i mean, the cabal new-install i tried locally, but now i'll try to just focus on this docker approach
21:56:27 <sm> why building your own docker image ?
21:57:01 <parsnip> so that it will work with MoLe
21:57:40 <sm> oh right you need master
21:58:15 <parsnip> or 1.10
21:58:46 <parsnip> hmm, master might be easier to leverage given docker preimage
21:58:47 <sm> well I feel some of the images on docker hub might be of that vintage
21:59:01 <sm> but I clicked a few and they had no tags
21:59:11 <sm> maybe they have dates
22:00:33 <parsnip> oh nice, `FROM haskell:8.2 as dev` is pulling
22:17:42 <iqubic> Movie Monad is a cool thing.
22:18:03 <iqubic> It's a video player written haskell.
22:22:59 <EvanR> does every application written in haskell need to be Something Monad
22:23:07 <glguy> nope!
22:23:18 <koz_> EvanR: So... food delivery app, Food Monad go? :P
22:28:41 <iqubic> XMonad. Movie-Monad. What's next?
22:28:49 <parsnip> you can just call it Burrito
22:29:22 <parsnip> a Burrito is kinda like a Food Monad
22:29:31 <iqubic> Heh. I still need to watch that video.
22:31:33 <EvanR> o_O the video ?
22:34:56 <iqubic> I swear there *is* a video, but I can't seem to find it right now.
22:36:40 <dysfigured> relevant https://blog.plover.com/prog/burritos.html
22:38:32 <iqubic> I just saw that
22:40:04 <iqubic> https://chrisdone.com/posts/monads-are-burritos
22:41:39 <parsnip> is there a command line argument to tell stack to use the same resolver for all the dependencies?
22:41:57 <glguy> As opposed to what?
22:43:54 <parsnip> as opposed to having to tell it explicitly all the dependencies? https://pastebin.com/raw/21Atq708
22:44:24 <parsnip> i keep prepending my list with the dependency it fails on
22:44:38 <parsnip> seems not elegant
22:44:41 <glguy> stack will only use one resolver at a time, but that doesn't mean any of the resolvers have the right s et of packages
22:45:01 <glguy> stack solves the hard problem of finding a build plan by giving your a small set to choose from
22:45:19 <glguy> and then you manually add additional packages to it
22:46:18 <glguy> It's easy because now its your job to find the build plan instead
22:46:37 <parsnip> okay, that was the approach in the dockerfile i'm forking, so i see that's the common wisdom
22:47:23 <parsnip> is this like, dependenices that aren't strictly curated?
22:47:38 <parsnip> whereas the curated parts stack will pick for you?
22:48:10 <glguy> "curated" just means that they're in the resolver, which is a list of packages and specific version numbers
22:48:30 <glguy> It doesn't pick for you; you still have to pick a resolver
22:48:56 <parsnip> hmm, i just don't remember ever having to select out like this
22:49:08 <sm> parsnip: best thing is to try the latest stackage lts resolver at the time of package release
22:49:30 <parsnip> i'm using lts 11.6
22:52:38 <sm> that sounds about right. hledger download page at the time said --resolver=lts-12
22:54:02 <sm> the exact command was stack install --resolver=lts-12 hledger-lib-1.10 hledger-1.10 hledger-ui-1.10.1 hledger-web-1.10 hledger-api-1.10`**\
22:57:15 <sm> minus the junk at the end
22:59:34 <foobarbazquux> I'd like to try writing my own FRP system (the continuous-time type). Where should I start?
23:02:09 <dmwit> Read Conal's Push-Pull FRP paper.
23:03:09 <foobarbazquux> dmwit: Thanks. I'll take a look.
23:03:21 <dmwit> https://scholar.google.com/scholar?cluster=2877645425530853977&hl=en&as_sdt=0,9
23:05:51 <foobarbazquux> dmwit: Is it the 13-page second result I want?
23:06:26 <dmwit> Any of them should do. But "conal.net" sounds like an especially promising domain to get it from.
23:07:09 <foobarbazquux> Cool. Thanks.
23:12:02 <koz_> dmwit: Any implementations of that (meaning 'push-pull FRP') around?
23:12:56 <foobarbazquux> koz_: I think reflex is push-pull. Correct me if I'm wrong.
23:57:33 <dmwit> koz_: http://hackage.haskell.org/package/reactive
23:58:37 <koz_> dmwit: Thanks.
23:58:42 <dmwit> (And see also https://packdeps.haskellers.com/reverse/reactive )
