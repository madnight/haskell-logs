00:22:44 <A1kmm> I'm looking for something like Data.ByteString.Lazy.hGetContents which doesn't automatically call hClose if it reaches the end of the buffer (since I am using it with hSeek and want to be able to read more things from the handle later). Does it exist?
00:54:07 * hackage peregrin 0.3.0 - Database migration support for use in other libraries.  https://hackage.haskell.org/package/peregrin-0.3.0 (BardurArantsson)
01:07:40 <parsnip> hmm, in gitit, why does the logout button disappear when javascript is enabled?
01:08:40 <parsnip> oh, this might be a noscript issue, conflicting with umatrix
01:10:13 <parsnip> oh it's a template, that should be easy to fix
01:19:51 <mikosty> hiay good morning! If I have getBy (UniqueIdentifierType arg1 arg2) >>= \case 
01:19:58 <mikosty> Nothing -> insert ....
01:20:11 <mikosty> Just e -> return e
01:20:32 <mikosty> what happens to the the case that getBy returns Just something?
01:21:01 <mikosty> getBy https://hackage.haskell.org/package/persistent-0.3.1/docs/Database-Persist.html
01:32:59 <kuribas> A SPECIALIZE pragma should always work right?  As long as it has the body of the function you specialize?
01:35:10 <merijn> kuribas: I think so, yes
01:35:38 <kuribas> Then why is reddit so full of shit?
01:36:39 <kuribas> I would never ever like to write code like this: http://mpickering.github.io/posts/2019-02-14-stage-3.html
01:37:10 <mpickering> ????
01:37:51 <kuribas> mpickering: In other words, I want the compiler to do that for me
01:38:26 <kuribas> mpickering: I was refering to people writing comments like, "cuz it doesn't work", without qualification
01:38:33 <merijn> kuribas: Sometimes you can't
01:39:12 <mpickering> I have seen some very big code bases where some dictionaries have failed to be eliminated
01:39:47 <kuribas> mpickering: even with a SPECIALIZE pragma?
01:39:55 <mpickering> kuribas: The point of the post was to explain how to be 100% sure your abstraction is eliminated rather than rely on the brittle automatic optimiser
01:40:17 <mpickering> yes
01:40:33 <kuribas> you actually need to do this?
01:40:59 <mpickering> and also writing specialise pragmas everywhere is not "the compiler doing it for you"
01:41:26 <kuribas> mpickering: correct, but it is low syntactic noise
01:41:56 <mpickering> and this only helps you when you are using a type class
01:43:08 <mpickering> as soon as you start writing any recursive functions in your code then the automatic optimiser will stop working as well
01:44:15 <kuribas> mpickering: It does some optimizations on recursive code
01:44:30 <mpickering> like?
01:45:19 <mpickering> I'm referring to inlining here I guess
01:45:23 <kuribas> I don't remember the details, but it does sometimes inline recursive calls.
01:45:25 <mpickering> recursive functions are not inlined
01:45:35 <kuribas> or rearrange functions so they can be better inlined
01:45:47 <mpickering> not by default
01:47:38 <kuribas> mpickering: any way, my objection with the TH is that it introduces a lot of problems, like removing type safety, creating hard to understand code.
01:47:49 <mpickering> how does it remove type safety?
01:48:15 <kuribas> A TH function isn't garanteed to generate correct code.
01:48:27 <kuribas> or even typesafe code
01:50:10 <kuribas> mpickering: personally, I'd be happy with a small performance loss over elegant and safe code.
01:50:19 <mpickering> Yes it is?
01:50:57 <mpickering> If you have a value of `TExpQ Int` then it will produce code which evaluates to an Int 
01:51:29 <mpickering> I agree that is assuming that people don't misuse the API but that's the same as assuming library authors don't use unsafeCoerce in unexpected ways
01:52:07 * hackage qrcode-core 0.9.0 - QR code library in pure Haskell  https://hackage.haskell.org/package/qrcode-core-0.9.0 (alexkazik)
01:56:27 <kuribas> mpickering: I just find all that code a lot harder to understand than the original
01:56:38 <kuribas> WHich is just four lines
01:57:43 <mpickering> that's true.
02:00:02 <kuribas> I can see the advantage of being able to run code at compile time, but I find that making a function INLINEABLE and adding a SPECIALIZE pragma is much more lightweight.
02:02:35 <kuribas> But I am just annoyed by people making comments like "cuz it doesn't work", and "your mistaken".
02:02:44 <kuribas> At least qualify it, and show a counterexample.
02:04:07 <kuribas> mpickering: I am sorry, but this feels like writing low level code, more like Java or C than haskell ...
02:19:37 * hackage ekg-bosun 1.0.15 - Send ekg metrics to a Bosun instance  https://hackage.haskell.org/package/ekg-bosun-1.0.15 (OliverCharles)
02:21:43 <kuribas> mpickering: no offense, my main beef is with the stupid comments "you are mistaken", not with the article.  At least they could try to give a counterexample?
02:22:37 <mpickering> You're welcome to think what you like. My personal experience is that it took a long time to make sure something like `generic-lens` got optimised correctly
02:22:55 <mpickering> looking at the core, looking at the code in the simplifier and working out the small tweaks necessary
02:23:37 * hackage digestive-functors-aeson 1.1.27 - Run digestive-functors forms against JSON  https://hackage.haskell.org/package/digestive-functors-aeson-1.1.27 (OliverCharles)
02:26:22 <kuribas> yeah sure.  Same as Vector fusion stuff, it often optimizes, but isn't very predictable.  What I would like to know however is why the SPECIALIZE pragma doesn't work, see it for myself and understand why...
02:28:57 <merijn> kuribas: GHC has to be able to see the specialisation applies, which it might not be able to with typeclass polymorphism
02:29:55 <kuribas> merijn: seeing if it applies, isn't that the same as typechecking?
02:30:15 <merijn> kuribas: No, as in, you need to statically know which instance is used at runtime to specialise it
02:30:35 <merijn> kuribas: In complex expressions it might not be trivial to see that it will always be one specific type
02:30:39 <kuribas> >(5 :: a) :: Int -- like this
02:30:49 <kuribas> erm...
02:30:59 <kuribas> >(5 :: Nam a => a) :: Int -- like this
02:31:12 <merijn> kuribas: Space after >
02:31:21 <kuribas> > (5 :: Num a => a) :: Int
02:31:22 <merijn> kuribas: Anyway, sure, in trivial examples like that it's trivial
02:31:23 <lambdabot>  5
02:32:06 <merijn> With polymorphic recursion it might not be trivial to see that something could specialise, though
02:32:08 <kuribas> merijn: you mean at compile time?
02:32:22 <kuribas> merijn: do you have an example?
02:33:43 <kuribas> specialisation is done at compile time, not runtime
02:34:29 <merijn> kuribas: Specialisation is done at compile time yes, but which typeclass instance applies at runtime isn't always possible to sort out at compile time
02:35:05 <merijn> kuribas: Typeclass resolution is *not* always at compile time, and there are cases where the resolution doesn't succeed at compile time, even when it theoretically could, because GHC is not infallible
02:35:28 <kuribas> merijn: AFAIK typeclass dictionaries don't use specialised versions?
02:35:31 <merijn> kuribas: In those case specialisation can't kick in, because you can only specialise/use specialised versions if you can statically resolve the instances
02:36:20 <kuribas> merijn: what I do is transitively specialise my functions.
02:36:55 <kuribas> If I have (Num a => a), and want Double, I specialise the ones I want to have Double
02:36:56 <merijn> kuribas: The value of specialisation for typeclasses is that it allows removing all the typeclass machinery entirely, by inlining all of it
02:37:05 <kuribas> yes
02:37:08 <merijn> kuribas: mpickering's comment was about code bases where that failed
02:37:33 <kuribas> ok.  It's still not clear to my why that would fail.
02:37:49 <merijn> kuribas: Which can happen since that specialisation only works if GHC can figure out what type that is at compile time
02:38:08 <kuribas> merijn: so then you give a explicit annotation?
02:38:11 <merijn> kuribas: It would fail because GHC doesn't always know what specialisation will be used at runtime at compile time
02:38:29 <merijn> kuribas: SPECIALISE just says "please generated code for a specialised version of this function"
02:38:38 <kuribas> merijn: yes, that's why you'ld use INLINEABLE or explicit SPECIALIZE pragmas
02:38:46 <merijn> kuribas: To *use* that specialisation GHC still needs to figure out that it applies
02:39:03 <kuribas> So it's a bug in ghc...
02:39:07 <merijn> kuribas: No
02:39:39 <kuribas> merijn: then you write an explicit type signature, to make sure ghc picks the right specialized instance.
02:39:47 <merijn> kuribas: That isn't always decidable
02:40:23 <merijn> kuribas: The only way you can guarantee that works if you basically say "well, just monomorphise literally everything in the application/codebase"
02:40:33 <merijn> kuribas: Which is a completely infeasible approach to this problem
02:40:47 <merijn> kuribas: There is a reason we don't do that, because it has a negative effect on performance
02:41:05 <merijn> It blows up your code size and makes compilation and linking take millions of years
02:42:48 <merijn> So, sure, we can do what you suggest if we throw out any pragmatism and usability, but that'd obviously defeat the purpose of trying to optimise via specialisation in the first place
02:43:39 <c_wraith> (also it doesn't work with RankNTypes or existentials)
02:44:09 <kuribas> c_wraith: it doesn't?
02:45:01 <kuribas> merijn: I'd still like to see an actual, concrete example where it doesn't work, other than "you have to believe me".
02:46:08 <kuribas> merijn: polymorphic recursion, you mean like Fix?
02:46:18 <merijn> kuribas: Like printf
02:46:25 <kuribas> ah right
02:48:18 <kuribas> IMO if you want performant code, you shouldn't write very polymorphic code anyway.
02:50:07 * hackage heyting-algebras 0.0.2.0 - Heyting and Boolean algebras  https://hackage.haskell.org/package/heyting-algebras-0.0.2.0 (coot)
02:50:24 <merijn> kuribas: That line of reasoning leads down "just write it in C!"
02:50:46 <kuribas> merijn: that TH code doesn't look much better than C IMO...
02:58:49 <fen> does this work;
02:58:50 <fen> class Unfoldable s where  unfoldable :: s a -> s -> ((a,b) -> b) -> b  
02:58:51 <fen> ?
02:59:23 <fen> sorry that seccond s should have a `a' parameter
03:00:16 <kuribas> fen: you mean a b?
03:00:53 <kuribas> fen: where do you get the first b?
03:02:52 <kuribas> fen: actually, what's that suppose to do?
03:03:26 <kuribas> fen: unfoldable sounds like an anamorphism in recursion schemes
03:03:48 <fen> its supposed to be a continuation encoding of a set function
03:04:00 <fen> like how foldable is a continuation encoding of a get function
03:04:20 <fen> so that traversable is unfoldable and foldable
03:05:10 <fen> where the only reason its not just get + set is because the continuation encoding allows any implementation of those 
03:06:28 <fen> well, ok that version if for streams 
03:06:47 <fen> thats why it has `b' like that
03:07:33 <kuribas> fen: you should have a look at recursion-schemes
03:07:55 <fen> class Unfoldable1 s where unfoldable1 :: s x a -> x -> ((a,Maybe b) -> b) -> b
03:08:39 <fen> s is supposed to be like a function, there is an implementation for (x -> (a, Maybe x))
03:11:11 <fen> kuribas: that library is intense
03:11:37 <kuribas> fen: https://blog.sumtypeofway.com/an-introduction-to-recursion-schemes/
03:12:30 <fen> yeah, but thats not how to discuss foldable
03:14:00 <kuribas> fen: then I misunderstood what you want...
03:14:23 <fen> well its good material, but maybe there is a simpler way to understand this
03:15:10 <kuribas> fen: you want to generate a b out of an initial value x?
03:15:14 <fen> foldable is like; "given functions to replace constructors with, a foldable thing can have its constructors replaced by these and give an overall return value"
03:15:47 <kuribas> fen: that's a catamorphism
03:16:17 <kuribas> :fen: if you replace the constructors of list by functions, you get foldr
03:16:19 <kuribas> :t foldr
03:16:20 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
03:16:45 <kuribas> fen: the opposite is an anamorphism
03:16:50 <kuribas> :t unfoldr
03:16:51 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
03:17:25 <kuribas> fen: and Foldable is an catamorphism for list
03:17:29 <fen> this is supposed to be like; "given some unfoldable - an unfolding function on a value, and a value to unfold, then return a ..." oh wait i see where it went wrong now
03:17:56 <fen> this has instead of list, the encoding of foldable, which means that thing written is traversable
03:18:07 <fen> that is, it hides both the constructor and the deconstructor
03:18:26 <fen> there need not be the demand that the thing it unfolds is foldable, it mightnot have a deconstructor
03:18:27 <kuribas> fen: the Foldable typeclass basically flattens any structure to a list, then applies a catamorphism on it.
03:18:42 <fen> just like how foldable might not have a constructor, just a deconstructor
03:19:49 <fen> kuribas: yeah foldable is simple, your explanation is perfect, and did not reference complex material. just wondering why unfoldable doesnt have the same easy explanation
03:20:24 <kuribas> fen: because flattening a structure loses information.
03:20:45 <kuribas> fen: you cannot flatten a tree, then build it up again.
03:20:46 <fen> the unfoldr above takes *one* instance of unfoldable, the state like function, and returns a list, but it need not return a list, and could use any unfoldable thing instead of state
03:21:28 <Rembane> There are some unfoldables hiding in Data.List. 
03:21:28 <fen> kuribas: its possible to unfold a list, and it will "retain" the structure, that is, the thing unfolded will be foldable
03:21:35 <fen> but thats not nesacarily the case
03:21:48 <fen> the set function could be irriversable
03:21:58 <fen> there need not be a get function and resulting foldable
03:22:03 <kuribas> fen: also the b in your example can only be bottom
03:22:36 <fen> with this version? class Unfoldable1 s where unfoldable1 :: s x a -> x -> ((a,Maybe b) -> b) -> b
03:22:44 <kuribas> yes
03:23:09 <fen> not sure if thats really expressing what it should, its a hylomorphism...
03:23:44 <kuribas> erm wait...
03:24:12 <fen> well no, if s b a = (b -> Maybe (a, b)) -> b
03:24:36 <fen> then this unfolds a list, which could be folded by (Maybe (a,b) -> b) 
03:25:52 <fen> maybe so it doesnt have to return a foldable container its just;  s x a -> x -> f a
03:25:56 <fen> forall f.
03:25:59 <fen> no..
03:26:01 <fen> nvm
03:26:06 <haskull> I've got a list of a list of tuples like this: [ [a,1], [b,2]] etc. I want to keep the list the same but double the second element. How do I do that? Been trying to figure how I can use map for this but I can't do it.  map (map (fst, snd) theList) doesn't work etc.
03:26:10 <fen> for some f
03:26:47 <fen> % :t map (fmap (*2))
03:26:47 <yahb> fen: (Functor f, Num b) => [f b] -> [f b]
03:27:12 <fen> % map (fmap (*2)) [('a',1),('b',2)]
03:27:13 <yahb> fen: [('a',2),('b',4)]
03:27:48 <Ariakenom> map (\(a,b) -> (a, b*2))
03:27:53 <fen> :t (fst,snd)
03:27:54 <lambdabot> ((a1, b1) -> a1, (a2, b2) -> b2)
03:27:57 <fen> !?
03:29:48 <kuribas> fen: so Maybe (a, b) is your List Base Functor, like ListF
03:30:00 <kuribas> http://hackage.haskell.org/package/recursion-schemes-5.1.1.1/docs/Data-Functor-Foldable.html#t:ListF
03:30:35 <kuribas> fen: then (b -> Maybe (a, b)) is the coalgebra, and (Maybe (a, b) -> b) the coalgebra
03:30:56 <kuribas> fen: erm, the latter the algebra
03:33:36 <fen> % map (\a -> bimap ((: "").($a)) (\f-> (f a)*2) (fst, snd)) [('a',1),('b',2)]
03:33:36 <yahb> fen: [("a",2),("b",4)]
03:35:04 <kuribas> fen: what would be a instance of "unfoldable"?
03:35:07 <fen> kurbias: yeah thats difficult to express, for defining hylo, that theco algebra needs to be of the algebra
03:35:36 <fen> kuribas: state
03:35:50 <kuribas> fen: StateT ?
03:35:59 <fen> that unfolds stream like things, but possibly without deconstructors
03:36:30 <fen> kuribas: not sure about arbitrary monads, its restricted to just Maybe over (,)
03:36:39 <fen> it might not make sense for more general things
03:36:51 <fen> so there seems to just be 3 cases
03:37:04 <kuribas> fen: Maybe (a, b) in your example is just ListF, do we agree on that?
03:37:17 <fen> ((s,a) -> a) , ((s,Maybe a) -> a) , (Maybe (s,a) -> a)
03:37:36 <fen> streams, nonempty and possibly empty containers respectivly
03:38:02 <fen> fen: sure
03:38:06 <fen> oops..
03:39:14 <fen> actually no
03:39:24 <fen> list has a constructor that can be pattern matched on
03:40:05 <fen> this could like, insert values at random positions in the f a in a nondeterministic way among some empty space, so you wouldnt be able to find them again
03:40:47 <fen> we can unfold a state-like unfoldable thing into a container which has only got constructors
03:40:58 <kuribas> fen: sorry, it's very confusing.  Can you give an actually, worked out instance for you typeclass?
03:41:15 <fen> no because at the moment its phrased only in terms of hylo!
03:42:25 <fen> could try with; class Unfoldable s where unfold :: s x a -> x -> f a
03:42:40 <kuribas> fen: state-like unfoldable thing, and container is all very vague
03:43:38 <fen> yeah that wont work either
03:43:45 <fen> it needs the constructor of f
03:44:14 <fen> thats what the hylo version achieved, as it consumed the f immidiatly, so was independent of f, 
03:44:15 <kuribas> if all you are trying to do is find an inverse to foldable, then the answer is anamorphism
03:44:58 <kuribas> fen: but it's weird that your typeclass abstracts over the s, instead of the value you return
03:45:11 <fen> thats the point!
03:45:19 <fen> state is an unfoldable instance
03:45:23 <ocharles> Anyone good with quantified constraints?
03:45:27 <ocharles> I can't decipher this:
03:45:28 <ocharles> Could not deduce (Generic (e (t m))) arising from a use of ‘to’ from the context: forall (t :: (* -> *) -> * -> *) (m :: * -> *). (GEffect (Rep (e m)) (Rep (e (t m))), Generic (e m), Generic (e (t m)))
03:45:34 <ocharles> It's right there in the context!
03:46:48 <ocharles> https://gist.github.com/ocharles/688dc7f2910b050fff76d29f65546203 is the code
03:47:07 <fen> but yeah, that wont abstract the notion of a constructor... maybe its just anything that can be returned from a coalgebra
03:47:58 <fen> kuribas: this is the original code; https://pastebin.com/raw/pG0M67RN
03:48:10 <fen> with hylo things
03:48:16 <fen> but there are 3 versions
03:48:21 <fen> and maybe more
03:48:34 <fen> if so, then perhaps there is a class over the state like things
03:50:10 <fen> ocharles: yeah, this seems to be a bug with GHC where sometimes it prints the wrong error
03:50:45 <fen> it must not be able to solve for some reason, and worse, even solve for a correct error message!
03:52:10 <haskull> :t /
03:52:11 <lambdabot> error: parse error on input ‘/’
03:52:20 <haskull> :t '/'
03:52:21 <lambdabot> Char
03:52:26 <haskull> :t div
03:52:27 <lambdabot> Integral a => a -> a -> a
03:53:11 <fen> :t (/)
03:53:12 <lambdabot> Fractional a => a -> a -> a
03:54:22 <kuribas> ocharles: oh, that's the new ghc 8.6 feature
03:54:33 <kuribas> must be still buggy then...
03:55:13 <ocharles> Yea, maybe...
03:55:32 <ocharles> Every time I actually try and use it it seems to fall own
03:55:33 <kuribas> it's looks right to me...
03:59:37 <ocharles> I will see if #ghc thinks it's a bug
04:00:29 <vagrant1> exit
04:03:25 <haskull> I'm trying to divide two ints. int/int (second int is from length). It says no instance for fractional int. It doesn't work even if I use fromIntegral? I want 1/2 to be 0.5 etc
04:04:16 <haskull> fromIntegral(int)/fromIntegral(int) also gives the same rror
04:04:56 <fen> > (1::Int) / ((length [1,2]) :: Int)
04:04:57 <lambdabot>  error:
04:04:57 <lambdabot>      • No instance for (Fractional Int) arising from a use of ‘/’
04:04:57 <lambdabot>      • In the expression: (1 :: Int) / ((length [1, 2]) :: Int)
04:05:12 <cocreature> > fromIntegral (1 :: Int) / fromIntegral (2 :: Int)
04:05:14 <lambdabot>  0.5
04:05:19 <cocreature> haskull: what error do you get?
04:05:55 <haskull> No instance for (Fractional  int) arising from use of /
04:06:09 <cocreature> please show us the full error message and the code producing it
04:06:19 <cocreature> (on some pastebin site)
04:07:38 <kuribas> :t (/)
04:07:39 <lambdabot> Fractional a => a -> a -> a
04:07:47 <kuribas> haskull: (/) doesn't work on integers
04:07:57 <kuribas> :t div
04:07:58 <lambdabot> Integral a => a -> a -> a
04:08:01 <haskull> That's why I use fromIntegral right?
04:08:15 <kuribas> :t fromIntegral
04:08:16 <lambdabot> (Num b, Integral a) => a -> b
04:08:46 <kuribas> haskull: if the result is fractional yes
04:09:37 * hackage stdio 0.1.0.0 - A simple and high performance IO toolkit for Haskell  https://hackage.haskell.org/package/stdio-0.1.0.0 (winterland)
04:09:44 <cocreature> my guess would be that you’re trying to use the result as if it had type Int but this would really be easier to answer if we could see the code and the full error
04:10:33 <fen> :t (1/2) :: Int
04:10:35 <lambdabot> error:
04:10:35 <lambdabot>     • No instance for (Fractional Int) arising from a use of ‘/’
04:10:35 <lambdabot>     • In the expression: (1 / 2) :: Int
04:11:01 <fen> :t (1/2)
04:11:02 <lambdabot> Fractional a => a
04:13:07 <haskull> (fromIntegral(3)/fromIntegral((length [1,2]))) this shoulfd work right?
04:13:34 <fen> we have covered that
04:13:55 <haskull> So yes? But it doesnt
04:14:08 <fen> you were asked to show how
04:14:22 <haskull> how what?
04:14:29 <cocreature> > fromIntegral 3 / fromIntegral (length [1,2])
04:14:31 <lambdabot>  1.5
04:14:45 <haskull> this is literally what is in my code ):
04:14:48 <cocreature> haskull: as I’ve asked you before, show us the exact code you are using and the full error message on some pastebin site
04:15:01 <fen> well it clearly works, so how your code manages not to
04:16:44 <fen> ok, there is a better question regarding unfold
04:16:55 <fen> class Unfoldable f => (Maybe (s,a) -> a) -> f a
04:17:24 <fen> sry, thats the type of unfold1
04:17:28 <fen> unfoldr*
04:17:41 <haskull> :t map (map (\(x,y) -> (x, (fromIntegral(3)/fromIntegral((length [1,2])))))) ([['a',1], ['b',2]])
04:17:42 <lambdabot> error:
04:17:42 <lambdabot>     • Couldn't match expected type ‘(a, b0)’ with actual type ‘Char’
04:17:42 <lambdabot>     • In the expression: 'a'
04:18:19 <fen> class Foldable where foldr :: f a -> (b -> Maybe (f a,b)) -> b
04:18:34 <fen> then is traversable class just unfoldable + foldable?
04:19:01 <fen> class Unfoldable f => unfoldr ::  (Maybe (s,a) -> a) -> s-> f a
04:19:11 <kuribas> fen: no, traversable is structure preserving.
04:19:13 <cocreature> haskull: you can’t put things of different types (e.g. 'a' and 1) in the same list
04:19:37 <kuribas> fen: like I said before, you cannot flatten (unfold) a structure then build it again.
04:20:06 <fen> by flatten you mean toList?
04:20:15 <fen> there was no list in the unfold above
04:25:55 <fen> class Foldable1 where foldr1 :: f a -> ((a,Maybe b) -> b)) -> b
04:25:56 <fen> class Unfoldable1 f => unfoldr1 ::  (s -> (a,Maybe s)) -> s -> f a
04:28:45 <fen> class Foldable where foldr :: f a -> (Maybe (a,b) -> b)) -> b 
04:28:52 <fen> class Unfoldable f where unfoldr ::  (s -> Maybe (a,s)) -> s -> f a
04:31:08 <fen> kurbias: oh ok, is as long as the fold produces values, then the extra information from the constructor is lost
04:32:23 <fen> well that was the idea of a constructor/deconstructor having more information, i.e. taking and returning `r a'
04:32:49 <kuribas> fen: I still have absolutely no clue what you are trying to do...
04:33:10 <fen> and this idea of hiding the constructor/deconstructor must have some extra properties when both happen at once in the traversable class
04:33:54 <fen> by specifying that what we get between unfolding and folding is `a' on its own, we lose information
04:34:23 <jgt> if I have a `data Foo = Bar | Baz | SpamEggs`, how do I derive a ToJSON instance where each constructor is rendered in snake_case?
04:34:42 <jgt> i.e., I'd like my SpamEggs to appear in JSON as `spam_eggs`
04:35:16 <fen> kuribas: trying to add unfoldable to this hierarchy; https://pastebin.com/HgZZxJQf
04:35:32 <jgt> I've seen things like `genericToJSON` and `defaultOptions`, but I'm not sure which options give me snake_case
04:35:49 <kuribas> fen: I have no idea what unfoldable is, or is meant to do
04:36:01 <fen> looks like the idea of traversable_r might be a bit more subtle than previously thought. like if r = Identity, its not nesacarily a list like thing
04:36:32 <fen> kuribas: well this motivation was just that its whatever you need to add to foldable to get traversable
04:36:57 <fen> and there are subtleties on this actually requiering the extension to foldable_r 
04:37:04 <kuribas> fen: you can go from traversable to foldable, but not the other way
04:37:35 <fen> you can if you go from foldable_r to traversable, by adding unfoldable_r
04:37:37 <Solonarv> jgt: you'll want to modify fieldLabelModifier
04:37:57 <fen> class Unfoldable_r r f where unfoldr_r ::  (s -> Maybe (r a,s)) -> s -> f a
04:38:18 <jgt> Solonarv: ah, ok. So is it `fieldLabelModifier = camelTo2 '_'`?
04:38:34 <Solonarv> i.e. 'genericParseJSON defaultOptions{ fieldLabelModifier = camel2snake }'
04:38:54 <jgt> Solonarv: also a bit confused between fieldLabelModifier and constructorTagModifier
04:39:26 <jgt> Solonarv: is there a camel2snake? I don't see it in the Aeson docs
04:39:39 <fen> but unfortunatly all this shows that Traversable /= Traversable_r Identity
04:39:45 <Solonarv> fieldLabelModifier says how to transform field names for records; constructorTagModifier says how to transform constructor names for types with multiple constructors
04:39:58 <Solonarv> you'll have to write camel2snake yourself, or find it somewhere
04:40:27 <jgt> ah, so it sounds like constructorTagModifier is the one I want
04:40:33 <jgt> though I am easily confused!
04:41:00 <Solonarv> oh right, yes
04:41:11 <Solonarv> I'm the one that got confused ;P
04:41:54 <fen> otherwise this code would be valid; https://pastebin.com/raw/pDJCNYQ5
04:42:05 <jgt> Solonarv: thanks so much for the help!
04:42:06 <fen> in conjunction with the paste above
04:42:31 <kuribas> fen: you can go from cata to traversable though
04:48:20 <fen> how is that different?
04:52:06 <fen> or, how can we understand this?
05:21:27 <Lope> Anyone here use linkedIn?
05:33:26 <hodapp> sorta
05:33:29 <hodapp> why?
05:34:20 <Lope> hodapp, what's the deal with connections? It seems to be a metric that people judge you by. Like how many connections you have (if you have less than 500) but if you have more than 500, then you tick some kind of box? But I've read that you should not accept linkedin requests from random people, because they could be fake profiles who are just trying to gather your personal information. But even if they are, or they're just some other random 
05:34:20 <Lope> people looking to increase their connections... I don't see any downside to having meaningless connections, but the upside is it shows I have more connections? Can you make sense of this?
05:36:19 <__monty__> Lope: This is the reason I don't like linkedin. People think it means anything but really it's just something that's super easy to game.
05:36:21 <hodapp> Lope: when you understand that the network is first and foremost an endless series of people trying their hardest to make a public display out of saying what they think employers want to hear and never disagreeing with anything, ever, you know most of what you need about LinkedIn.
05:39:35 <hodapp> which is probably why 90% of the posts are people repeating utterly banal things and then acting like they are fearless martyrs for saying them, and then other people mindlessly agreeing with those posts without reading them
05:42:29 <jgt> is there a generic way to create these ToJSON/FromJSON instances? http://ix.io/1BbR
05:44:54 <jgt> hodapp: that's quite accurate; reminds me of this: https://theoutline.com/post/5495/how-to-beat-linked-in-the-game?zd=1&zi=wziod5cy
05:45:26 <fen> what constraint on r yields; (a -> f b) -> (r a -> f (r b)) 
05:45:28 <fen> ?
05:46:28 <hodapp> jgt: "Since its founding in 2002, LinkedIn has quickly become one of the most popular video games of all time." bahahaha
05:48:30 <lyxia> jgt: do you have more examples that you want to generalize
05:48:34 <fen> its like Functor, which gives r a -> r (f b) and then commuting the r and f in the result...
05:49:07 <fen> % :t sequenceA
05:49:08 <yahb> fen: (Traversable t, Applicative f) => t (f a) -> f (t a)
05:49:22 <lyxia> :t traverse
05:49:23 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
05:49:36 <fen> doh!
05:49:55 <fen> thanks, gone screen-blind
05:50:51 <fen> ok so traverse is traverse_r where r is itself traversable...
05:51:18 <jgt> lyxia: sure, if you did s/Risk/User/g, that'd be another example
05:51:33 <jgt> lyxia: every model in my system has its own UUID type
05:51:48 <Lope> hodapp, "Work your way through the corporate food chain like an intestinal parasite at a gratis conference buffet."
05:52:19 <lyxia> jgt: if UUID already has the right instance you can use GeneralizedNewtypeDeriving, otherwise DerivingVia
05:53:04 <jgt> lyxia: ah, ok. Thanks. This is a good opportunity for me to check out DerivingVia.
05:55:45 <fen> so is it somehow not a good idea to make everything traversable specify a traversable `r' - "shape" parameter?
05:56:02 <fen> recalling earlier comments about constructors with many values...
05:56:06 <fen> tuples...
05:56:43 <davidlopez> how does one develop the ability to look at things like this without getting dumbfounded? :(    let p x = (\s -> (const $ pure (x == 'c')) =<< put (1+s)) =<< get in runState (findM p $ listh ['a'..'h']) 0
05:57:14 <davidlopez> like i can sit down to write the types and understand why it is valid
05:58:08 <davidlopez> but i still can't tell what exactly it is doing, i find it confusing 
05:58:18 <fen> that means it might not be good code
05:58:41 <davidlopez> they are the test cases from the data61 fp course
05:59:03 <fen> like the pointless-style bot pl, it can rewrite anything in a very difficult to understand way
05:59:18 <fen> we should always try to do the opposite of that
05:59:44 <fen> if its a test, maybe they want you to be able to rewrite it in a better way
06:00:34 <fen> to test you equational reasoning capabilities 
06:00:39 <__monty__> Doesn't look all that convoluted to me.
06:01:30 <__monty__> Sure, you need to know what findM and listh and get and put, etc. do but most of these you'll learn just by exposure.
06:01:49 <lyxia> I don't think that's a good piece of code though.
06:02:16 <lyxia> there is no reason to use (=<<) here, it only obscures the code by separating s from its source.
06:02:56 <nshepperd1> const (pure _) =<< is a heck of a code smell
06:02:59 <lambdacalculus[m> It has a lot going on, it's not clear at all.
06:03:18 <davidlopez> i guess they use it because they don't want to introduce many new things since its sort of an introductory fp course
06:04:00 <lambdacalculus[m> I don't understand why they have to use bind
06:04:24 <fen> sometimes a pretty complex one liner is better understood by its type signature, you can be like, well thats a heck of a lot of symbold, but i know exactly what it does from its type
06:04:27 <kuribas> davidlopez: that's a rather convoluted way of doing things
06:04:50 <fen> but the point where the type signature doesnt help might be reached if too much is crammed into one expression
06:05:23 <fen> in which case, breaking it up into parts where the type of each part gives a better idea of what its doing, and how they compose to give the overall type
06:05:37 <fen> well, thats a better way to write 
06:06:20 <davidlopez> well its just a test case to check that my implementation of findM works correctly. I was just trying to understand exactly what it is doing so that i can have some general idea of what findM is useful for
06:06:57 <kuribas> > map fst $ find ((== 'c') . snd) $ zip [0..] ['a'..'h']
06:06:59 <lambdabot>  error:
06:06:59 <lambdabot>      • Couldn't match expected type ‘[(b, b0)]’
06:06:59 <lambdabot>                    with actual type ‘Maybe (Integer, Char)’
06:07:35 <Solonarv> 'const (pure _) =<< blah' should probably be rewritten to '_ <$ blah'
06:08:35 <kuribas> > fmap fst $ find ((== 'c') . snd) $ zip [0..] ['a'..'h']
06:08:37 <lambdabot>  Just 2
06:09:52 <fen> is there a counterexample to the theorem that every traversable has an associated traversable r?
06:10:04 <fen> so that we always have; traverse_r :: (Applicative f) => (r a -> f (r b)) -> t a -> f (t b)
06:10:07 <OnlyHaskell[m]> pure here means return?
06:10:16 <fen> yes
06:11:18 <Solonarv> pure and return are the same thing, they both exist because Applicative (which pure belongs to) is much newer than Monad (which return belongs to)
06:12:24 <OnlyHaskell[m]> Ooh! Thanks
06:12:31 <kuribas> davidlopez: I'd write that as: let p x = state $ \i -> (x == 'c', i+1) in runState (findM p ['a'..'h']) 0
06:13:40 <kuribas> or just: runState (findM (\x -> state $ \s -> (x == 'c', i+1)) ['a'..'h']) 0
06:15:20 <dmwit> > lookup 'c' (zip ['a'..'h'] [0..])
06:15:22 <lambdabot>  Just 2
06:15:41 <dmwit> kuribas: (Dunno what you're after, but...)
06:16:06 <kuribas> dmwit: yeah :)
06:16:21 <kuribas> dmwit: but he needed to use findM
06:17:38 <OnlyHaskell[m]> Wow. Now, that's clear.
06:18:25 <dmwit> davidlopez: Do you feel like your question got answered?
06:18:31 <davidlopez> sorry, internet died thanks for the help simplifying the code earlier though, made it clearer
06:18:40 <davidlopez> yess i didnt get to see the last texts
06:18:44 <davidlopez> but yeah
06:18:46 <davidlopez> thank you
06:18:51 <kuribas> davidlopez: if I would use get and put, I'd use do notation
06:19:01 <dmwit> Okay, cool. *I* don't feel like your question got answered, but I'm glad you do. =)
06:20:48 <kuribas> davidlopez: like this: let p x = do i <- get; put (i+1); pure (x == 'c') in runState (findM p $ ['a'..'h']) 0
06:20:55 <davidlopez> i mean my question for that specific example got answered. Though it is true that i was looking for more general advice on how to understand things like that. I suppose that I just have little exposure to haskell code.
06:20:55 <kuribas> davidlopez: isn't that clearer?
06:20:56 <dmwit> jgt: Consider `data UUIDFor a = UUIDFor { _uuid :: UUID }` so that you can write your instances once and for all.
06:22:02 <dmwit> davidlopez: Right. I think more generally there's simply no replacement for experience. So write as much code as you can in monadic style, even if it's unnecessary, to practice. One thing that could be an interesting thing to try would be to take some pure code, and rewrite it to use the Identity monad everywhere instead.
06:22:22 <davidlopez> kuribas wow that is much nicer 
06:22:37 <dmwit> davidlopez: Try to stick to using the Monad interface (`(>>=)`, `(<$>)`, and `pure`) rather than using `Identity` and `runIdentity`.
06:23:34 <ZORR0W> Since arrays are objects, I can add functions as property to array. Now when I console log an array literal, it also prints the funtion property name. How to console log on the elements in array and not property.
06:23:37 <dmwit> jgt: (Then you would have e.g. `UUIDFor Risk` and `UUIDFor User` as your two types rather than `RiskUUID` and `UserUUID`.)
06:23:53 <dmwit> ZORR0W: You might be in the wrong channel.
06:24:05 <fen> ZORROW: the show instance?
06:24:08 <ZORR0W> oh oops sorry!
06:24:19 <kuribas> davidlopez: a good way to try understanding complicated code is to rewrite it in something you do understand.
06:24:34 <Guest88> Hi I was wondering could you help me?
06:24:43 <fen> just ask!
06:24:43 <dmwit> ?where justask
06:24:43 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
06:24:59 <kuribas> davidlopez: like manually inlining cons or (.)
06:25:12 <kuribas> davidlopez: higher order functions in general
06:25:13 <Guest88> how do I export records?
06:25:26 <fen> dubplates?
06:25:31 <dmwit> module Foo (RecordType(..)) is the easiest.
06:25:50 <Guest88> whats in the brackets?
06:26:01 <Guest88> in the parentheses I mean?
06:26:25 <fen> the functions defined as record accessors 
06:26:48 <dmwit> Guest88: That was quite literal. You can actually put the text `.` and then `.` to mean all the constructors and fields.
06:26:48 <kuribas> and accessor fields
06:26:52 <marvin2> .. means expory all 
06:26:53 <Guest88> Oh I see, I can just literally type (..)
06:27:03 <fen> yes
06:27:07 <Guest88> thanks!
06:27:12 <Guest88> that worked
06:27:22 <dmwit> Guest88: If you want to export some but not all of the constructors and fields, you can list them explicitly in the parentheses instead, separated by commas.
06:27:51 <dmwit> e.g. module Foo (RecordType(Constructor1, Constructor3, field1, field3))
06:28:11 <Guest88> the explicit naming doesn't seem to work for me, perhaps I'm doing something wrong
06:28:18 <dmwit> https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1000005.2 has the full details
06:28:30 <dmwit> If you'd like help with a specific code snippet, feel free to paste it online and send us a link.
06:29:08 * hackage free-algebras 0.0.7.1 - Free algebras in Haskell.  https://hackage.haskell.org/package/free-algebras-0.0.7.1 (coot)
06:29:46 <fen> is there a Traversable instance that cant be written using Traversable r => Traversable_r r ?
06:30:17 <fen> class Traversable_r r t | t -> r where   traverse_r :: (Applicative f) => (r a -> f (r b)) -> t a -> f (t b)
06:30:45 <fen> i.e. can we always asign a traversable `r' to every traversable `f' ? 
06:30:59 <fen> basically saying that traversable things are made up of traversable segments
06:31:24 <Guest88> Oh I see now, for a record type Actions { f :: Int} I would have to define Module(Actions(Actions, f))
06:32:07 <dmwit> fen: Yes, as you've already identified yesterday I think, r ~ Identity is the way.
06:32:36 <fen> didnt you have a counterexample?
06:32:52 <fen> thats whats thrown me
06:33:00 <dmwit> for any Traversable foo (now foo is a metavariable, not a type variable!), instance Traversable_r Identity foo where traverse_r = coerce traverse -- with suitable type annotations
06:33:26 <fen> is that a proof! wow
06:33:45 <fen> thanks, now just got to understand what it meant!
06:33:49 <dmwit> No. I had a counterexample to data types being able to cleanly represent their extra structure in such a setting.
06:34:08 <fen> oh right, thats just for Identity...
06:34:40 <fen> not going with that now... it isnt as good as a Traversable constraint
06:35:26 <fen> basically, all Traversable_r have a traverse function, as long as r is traversable. but setting r = Identity is like saying its linear, or list like
06:35:35 <fen> which is wrong, since shaped things have traversable instances
06:35:52 <dmwit> Setting r = Identity is not like saying it's linear.
06:36:14 <fen> it means the "shape" encountered had no information
06:36:14 <dmwit> It's just saying that the user of the instance doesn't get to use any of the extra structure that the data type has lying around.
06:36:31 <dmwit> It doesn't mean there is no shape information, just that the caller of traverse_r doesn't get to see it.
06:37:06 <dmwit> (In particular: the instance writer still gets to (and usually has to) see and maintain it.)
06:37:12 <fen> hmm, but the defaults in terms of get_r and set_r with r set to identity are exactly linear things
06:37:36 <dmwit> Yes, well, I don't think get_r and set_r are a good idea in the first place, so I won't argue with you much about those. =)
06:37:57 <fen> this `r' is what goes inbetween unfold_r and fold_r in a default definition of traverse
06:38:17 <fen> so if r = Identity, then it loses the shape information upon traversal, or it never had any
06:38:27 <dmwit> You might be interested in reading about zippers? The key difference (in my opinion) between the good idea of zippers and the bad idea of get_r is that zippers give you both an element and a shape, but the shape can be of a *different* data structure than the input.
06:39:09 <dmwit> Whereas in get_r you demand that the "leftovers" be of the same data structure as the input.
06:39:44 <fen> well sure, it just gets the first value and the shape, why would it change the shape of the tail?
06:40:00 <fen> (shape associated to the first value)
06:41:16 <fen> anyway, if traverse_r is just unfoldr_r then foldr_r, its implicitly using the deconstructor get_r to unfold_r, and the constructor set_r to foldr_r
06:41:30 <dmwit> Because the data type that represents a one-hole context for structure F is rarely the same as F itself.
06:41:43 <fen> setting r = Identity then results in an unshaped container
06:41:46 <dmwit> (You know, like the derivative of a function f is rarely the same as f itself. ;-)
06:42:09 <fen> just from unfold_r and fold_r defining traverse, where the implementations in terms of get_r and set_r are not needed
06:42:12 <dmwit> I think your insistence that traverse_r *must* be unfoldr_r followed by foldr_r is probably also misplaced.
06:42:47 <fen> ah fair
06:43:09 <fen> but there are traversable laws which might help show this?
06:43:12 <hpc> i just wrote a thing that redirects stdout/err to syslog, and it's nicer than the same operation in C :D
06:43:32 <Solonarv> hpc: share!
06:43:44 <hpc> instead of forking to a logger process like most people recommends, it uses a forkIO thread and calls syslog()
06:44:24 <hpc> Solonarv: i have more i want to do with this, but packaging this is definitely on my mind
06:45:24 <fen> dmwit: all zippers are just ([r a],f a)
06:45:46 <Solonarv> I mean, I mostly said that out of curiosity. Dumping it into gist.github.com or something would satisfy me
06:46:24 <fen> for Linear_r r f = (Get_r r f,Set_r r f)
06:47:47 <hpc> oh, yeah
06:48:00 <hpc> let me make sure this builds and commit it :D
06:50:51 <hpc> Solonarv: https://github.com/headprogrammingczar/tubular/blob/master/tubular/src/Main.hs#L87
06:52:39 <Solonarv> hpc: oh that's what your username stands for!
06:53:05 <hpc> hahahaha
06:54:10 <hpc> i've gotten so used to it i forgot how bonkers it really is
06:55:46 <Solonarv> (should stdout messages really be logged as Warning? Info or Notice seems more correct to me0
06:57:37 <hpc> nothing should be writing to either of those at all when i am done
06:57:55 <hpc> so it's not quite an error, but it's definitely a bug if it happens
06:58:02 <hpc> so it should be visible
06:58:12 <Solonarv> oh, I see.
07:09:22 <b3o1> Hey
07:09:38 <lyxia> hello
07:10:06 <b3o1> Is there anyone who uses Haskell for network things?
07:10:30 <hpc> what kind of network things?
07:11:04 <b3o1> I mean
07:11:07 <b3o1> All things
07:11:20 <b3o1> Except driver programming
07:11:32 <b3o1> All simple things...
07:12:29 <dmwit> Yes. In fact at my company we've even gone so far as to use it for driver programming...
07:12:58 <b3o1> Then it's a good ideia to use ?
07:13:05 <yushyin> https://hackage.haskell.org/packages/tag/network ^^
07:14:25 <b3o1> Thanks yushyin, btw.
07:17:07 * hackage Win32 2.8.3.0 - A binding to Windows Win32 API.  https://hackage.haskell.org/package/Win32-2.8.3.0 (TamarChristina)
07:18:07 * hackage hedis 0.11.1 - Client library for the Redis datastore: supports full command set,pipelining.  https://hackage.haskell.org/package/hedis-0.11.1 (k_bx)
07:30:07 * hackage pontarius-xmpp 0.5.6 - An XMPP client library  https://hackage.haskell.org/package/pontarius-xmpp-0.5.6 (PhilippBalzarek)
07:49:07 * hackage hedis 0.12.0 - Client library for the Redis datastore: supports full command set,pipelining.  https://hackage.haskell.org/package/hedis-0.12.0 (k_bx)
08:40:26 <moreira> hello, can I get a doubt about my code here?
08:41:35 <cocreature> moreira: not quite sure what you mean by that (which might be due to me not being a native speaker) but you’re certainly welcome to ask questions about your code :)
08:42:29 <moreira> tanks
08:43:23 <[exa]> moreira: if you expect us to review your code and start nitpicking on the weirdest details, you're in the right place. :]
08:44:30 <Sheilong> cocreature: He is having a issue with return type on main function 
08:45:02 <Solonarv> we do need to actually see your code in order to help, though :>
08:45:09 <Sheilong> His code https://uploaddeimagens.com.br/imagens/captura_de_tela_em_2019-02-16_12-58-12-png and the error https://uploaddeimagens.com.br/imagens/captura_de_tela_em_2019-02-16_12-36-05-png 
08:45:22 <Sheilong> I tried to help, but I am too noob in Haskell
08:45:28 <Sheilong> I knows almost nothing .
08:45:41 <Philonous> Why would you post code as a picture, though 
08:45:50 <Philonous> @paste
08:45:50 <lambdabot> Haskell pastebin: http://lpaste.net/
08:46:09 <Sheilong> However if some kind soul help him I will make sure to translate the help to him since I speak his native language as well.
08:46:18 <[exa]> Sheilong: just a wild first guess-- void$close conn 
08:46:32 <cocreature> the code doesn’t match the error
08:47:06 <Solonarv> Philonous: lpaste is down, actually
08:47:11 <cocreature> you are apparently trying to load some different code which has something like "main :: return ()" in line 11
08:47:56 <cocreature> use https://gist.github.com if you want to paste some code
08:50:58 <fen> streams have foldr' :: (a -> b -> b) -> f a -> f b
08:51:20 <fen> does this mean there should be a foldable like class with this function for stream like things?
08:52:09 <fen> Foldable0?
08:54:00 <Solonarv> that function is only possible if 'f a' contains no 'a's at all
08:54:21 <fen> its supposed to be an infinite stream
08:54:53 <fen> so it never reaches the end, and there is some fixed point magic that allows these types to work... 
08:54:59 <fen> i think...
08:55:06 <Solonarv> [X] doubt
08:55:51 <cocreature> doesn’t seem like a very useful abstraction to me. the types certainly work out but I’m not sure what code you would write in terms of this abstraction
08:56:02 <fen> well you can fold streams
08:56:17 <fen> no point providing a basecase and using the normal foldr if its never going to be reached
08:56:52 <Solonarv> oh, I see.
08:56:57 <Solonarv> yeah, I agree with cocreature
08:57:06 <fen> oops its supposed to read foldr0 :: (a -> b -> b) -> f a -> b
08:57:26 <fen> so is the problem that this is going to be strict somehow by needing to producea resulting b
08:57:40 <fen> so there is no chance of anything like take folding over it
08:57:51 <Solonarv> no, I think this is actually fine
08:58:09 <cocreature> it is fine but I still don’t see a compelling usecase for it.
08:58:13 <fen> consider folding with (:) and then doing take on the resulting f b
08:58:27 <fen> cocreature: you never use streams?
08:58:28 <cocreature> if you’re folding with (:) you do have a basecase
08:58:33 <Solonarv> % class FoldableInf f where foldrinf :: (a -> b -> b) -> f a -> b
08:58:33 <yahb> Solonarv: 
08:58:58 <fen> cocreature: yeah but you were folding over a stream, so there is no place to use it..
08:59:00 <Solonarv> % data Stream a = s :<: Stream a deriving (Show, Functor)
08:59:00 <yahb> Solonarv: ; <interactive>:34:17: error: Not in scope: type variable `s'
08:59:06 <Solonarv> % data Stream a = a :<: Stream a deriving (Show, Functor)
08:59:06 <yahb> Solonarv: 
08:59:31 <fen> the take function can use the basecase to return a proper list
08:59:32 <Solonarv> % instance FoldableInf Stream where foldrinf f (a :<: as) = f a (foldrinf f as)
08:59:33 <yahb> Solonarv: 
08:59:54 <cocreature> fen: I’m not saying there aren’t things that you could use this abstraction for. my point is that I don’t see a whole lot of usecases that you couldn’t also solve using another abstraction, e.g., the already existing Foldable
09:00:06 <fen> Solonarv: your going to need to unfold
09:00:31 <fen> cocreature: consider a state function as a stream
09:01:08 <cocreature> just give me a concrete example. so far the only one that you provided is folding with (:) and for that you can just use Foldable with [] as the basecase
09:01:43 <fen> ok, well folding with Solonarvs (:<:) stream constructor above
09:02:10 <fen> we can convert between stream types now, even if their data decleration does not have a basecase or last case
09:02:13 <fen> for Fix thing
09:02:35 <fen> otherwise you would have to foldr constructor undefined
09:02:55 <fen> which would work, but there is no need for the concept of the basecase when working with streams
09:03:08 <Solonarv> sure; so, use cata instead of the Foldable class.
09:03:14 <cocreature> I guess the main reason why I’m skeptical about it, is that most of the time my code is perfectly capable of handling finite data structures as well and in that case Foldable gives me the option to write code that works on finite and infinite data structures.
09:03:38 <fen> sure, i never use streams, finite containers are normally fine
09:03:53 <fen> but its an abstraction that exists, and maybe there are nice stream things
09:04:02 <fen> like maybe 1d lists with boundary conditions
09:04:09 <fen> like, cyclic loop things
09:04:16 <Solonarv> % type instance Base (Stream a) = ((,) a)
09:04:16 <yahb> Solonarv: 
09:04:25 <cocreature> it is certainly an abstraction that exists but whether it is a useful abstraction isn’t clear to me
09:04:44 <fen> the cyclic list seems like a good example
09:04:55 <Solonarv> % instance Recursive (Stream a) where project (a :< as) = (a, as)
09:04:55 <yahb> Solonarv: ; <interactive>:38:46: error:; * No instance for (Cons (Stream a) (Stream a) a a) arising from a pattern; * In the pattern: a :< as; In an equation for `project': project (a :< as) = (a, as); In the instance declaration for `Recursive (Stream a)'
09:05:03 <Solonarv> % instance Recursive (Stream a) where project (a :<: as) = (a, as)
09:05:04 <yahb> Solonarv: 
09:05:25 <fen> instead of a basecase it just has a different constructor the same as cons, but the different name can be used to detect the point that it loops back to the start
09:05:33 <Solonarv> % instance Corecursive (Stream a) where embed (a, as) = (a :>: as)
09:05:33 <yahb> Solonarv: ; <interactive>:40:58: error:; * Data constructor not in scope: (:>:) :: a -> Stream a -> Stream a; * Perhaps you meant one of these: `Seq.:>' (imported from Data.Sequence), `:>' (imported from Control.Lens), `:<:' (line 35)
09:06:00 <Solonarv> % instance Corecursive (Stream a) where embed (a, as) = (a :<: as) -- wow, I'm bad at typing today
09:06:01 <yahb> Solonarv: 
09:06:18 <fen> similrly we have an unfoldable0 class for making these things from states
09:06:31 <fen> or coalgbras in the recursion-schemes parlance 
09:10:40 <fen> maybe by working with streams it forces knot tying...
09:11:46 <fen> they are all defined recursively without a basecase, but thats basically tautological to the definition...
09:14:09 <fen> periodic boundary conditions are quite common
09:14:26 <fen> with Free streams giving Nd periodic domains
09:15:15 <fen> and if Fix f is used instead, that gives cyclic graphs when f is finite
09:15:54 <fen> anyway...
09:20:37 * hackage glue-core 0.6.2 - Make better services and clients.  https://hackage.haskell.org/package/glue-core-0.6.2 (seanparsons)
09:21:55 <reallymemorable> I'm now being shifted into a lot of Haskell work at my firm.  I'm wondering if it's worth switching from OSX to NixOS given that I'm on Mojave and there are known issues with Nix package manager and Mojave.
09:22:07 * hackage glue-example 0.6.2, glue-ekg 0.6.2, glue-common 0.6.2 (seanparsons)
09:23:06 <hpc> presumably this is just for your workstation?
09:23:21 <reallymemorable> hpc: yes
09:23:23 <hpc> i'd take a look at vagrant
09:23:43 <Solonarv> Nix officially supports OSX, doesn't it?
09:23:51 <Solonarv> oh wait I can't read
09:23:55 <reallymemorable> There is a known issue with Mojave
09:24:07 <reallymemorable> My company likes Nix package manager
09:24:21 <reallymemorable> but I don't want the headache of dealing with broken dependencies every time one or the other upgrades
09:24:34 <reallymemorable> So I'm wondering if I should just jump into NixOS
09:25:32 <fen> surely a different package manager is less of a switch than a different operating system...
09:27:29 <hpc> fen: if they're using nix on their servers, that's a lot more set in stone than some random workstation
09:27:58 <reallymemorable> our servers are Nix
09:28:11 <fen> ah fair
09:28:13 <cocreature> using the same setup as your colleagues is going to remove some pain but whether that outweighs the pain of switching to a different OS is something you’ll have to decide for youreslf
09:28:13 <hpc> plus however much code they have wrapped up in nix expressions that they'd have to switch to rpm or whatever
09:28:32 <reallymemorable> I know the company heavily uses Nix
09:28:43 <reallymemorable> I was thinking to set my MacBook Pro as a dual boot
09:28:45 <reallymemorable> OSX and Nix
09:29:13 <cocreature> we use nix at work but we have roughly an equal amount of devs on macos and on linux
09:29:36 <reallymemorable> Also I have a spare Macbook Air
09:29:41 <reallymemorable> that currently runs Ubuntu
09:29:44 <cocreature> but if you’re going to be the only macos guy, you’ll probably have to deal with some issues that your colleagues won’t stumble into
09:29:49 <reallymemorable> yeah
09:29:58 <reallymemorable> so it sounds like a dual boot OSX / NixOS
09:30:02 <reallymemorable> is worth it in the long run
09:37:07 <mouse07410> As a MacOS guy, I don't think there would be many Mac-specific issues. The main/only problem I encountered was because of Macports libiconv conflict with Apple libiconv.
09:39:13 <nyc`> I'm unfamiliar with NixOS. 
09:40:26 <fen> its a linux
09:41:08 <nyc`> Ah, it's a Linux distro. I was expecting an independent kernel. 
09:45:54 <geekosaur> they're not interested in kernels, they're interested in package management
09:46:06 <geekosaur> so nixos is a distro built around nix
09:46:40 <fen> would foldMap0 be possible on streams?
09:46:49 <nyc`> I wonder what kernel features etc. would be good for logic and functional programming language runtimes. 
09:46:55 <fen> foldl0 doesnt seem like it would work...
09:47:53 <fen> nyc` you mean like ghci? or like a fp os ?
09:48:19 <nyc`> My first guess is proper aio and M:N threading support. 
09:48:31 <nyc`> fen: FP OS
09:48:49 <hpc> make as many syscalls as you can as stateless as you can
09:49:35 <hpc> so like for files you have the state of opening the file, where you are in the file, etc
09:50:11 <nyc`> I may need guidance as to how that helps the language runtimes. 
09:50:25 <hpc> oh, for runtimes
09:50:39 <hpc> i was thinking in general
09:51:53 <fen> does that use all TVars and stuff?
09:52:38 <fen> not sure how parallel or asynchronous threading fits over an immutable fp-language 
09:53:36 <fen> ghc relies on OS threading right?
09:54:21 <nyc`> AIUI the runtimes want cheap user threads to autoparallelize speculatively etc.
09:54:22 <cocreature> mouse07410: it’s not so much actual Mac-specific issues but if all of your devs use the same setup it is very easy to either accidentally or out of laziness make a lot of assumptions about the system the code is being developed on.
09:54:29 <fen> seems recursive to then use the threading of the language for the OS..
09:56:18 <fen> sure there is some stuff in the concurrent programming in haskell world
09:57:09 <nyc`> I'm not sure I would use an FPL to implement the kernel. I would just want to do good things for Haskell, Mercury, Ocaml, SWI-Prolog, etc. 
09:58:08 <nyc`> ghc doesn't emit privileged instructions AIUI.
09:58:19 <fen> might be nice to have the same haskell concurrency libs being used for the OS threading too, at least then we could read them, to make sure they work as expected and desired...
09:58:24 <mouse07410> cocreature: you're correct. But Haskell appears to be a "closed" ecosystem that minimizes interactions with OS, "channelizing" them through Haskell packages?
10:00:27 <cocreature> mouse07410: depends on how you write your code. even in Haskell you can make assumptions about file locations, call external processes, …
10:00:53 <cocreature> all of that is solvable but it can add a fair amount of friction if you are the only one with a diverging setup
10:01:31 <Solonarv> ...or use the C FFI to call whatever foreign code you want (as long as it's callable from C, which most languages are)
10:03:17 <nyc`> fen: No idea. I just do the dirty things like assembly language and device drivers.
10:03:27 <Solonarv> so really, it's not "closed" at all - it's just that working with the FFI directly is often cumbersome, because the FFI does not have ADTs and pointer-juggling and annoyingly mutable state are all over the place
10:03:52 <Solonarv> so usually it's more convenient to have a layer of Haskell "on top of" the FFI calls
10:12:14 <reygoch> Is it possible to specify in cabal.project file that you only want to ever build a lib of some library. Similarly like you can write cabal new-build lib:jose? I can't use jose on windows because it's executable has some dependency on unix package.
10:16:25 <nyc`> Async pagefaults might also help, so a protection fault or whatever triggers an upcall to the GC. 
10:26:24 <cocreature> reygoch: did you add jose to the packages section in your cabal.project or is it just in the build-depends section of one of your packages?
10:27:25 <reygoch> cocreature: I've added jose to constraints in my .project file and to packages in my .cabal file
10:27:53 <vides> hi guys, I have a question about Haskell and servant I haven't managed to find an answer on the web, could I ask you for some help?
10:28:17 <reygoch> cocreature: *I've added jose to the build-depends field of my .cabal package file
10:28:37 <Solonarv> ?where justask
10:28:37 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
10:28:42 <Solonarv> vides: ask away!
10:28:53 <cocreature> reygoch: so it’s not in packages in cabal.project?
10:29:14 <reygoch> cocreature: no, but I can add it if it'll help
10:29:29 <cocreature> no it won’t
10:29:32 <reygoch> :)
10:29:34 <vides> post :: Problem -> Handler Task
10:29:34 <vides> post = do
10:29:34 <vides>     taskid <- liftIO (randomString randomASCII 8)
10:29:34 <vides>     return $ Task taskid Submitted
10:29:43 <cocreature> I’m just asking because I thought that cabal already only built the libs for dependencies
10:29:50 <vides> stack can't stop complaining about an error there :/
10:29:58 <cocreature> so the only reason how I could see you trying to build the executable is by adding it to packages
10:30:15 <vides> I've just learn about the liftIO stuff so I thought maybe I'm doing something wrong there (?)
10:30:16 <cocreature> but that might just be wishful thinking on my side
10:30:24 <reygoch> cocreature: hm... well, I've downgraded it to the previous version for now
10:30:37 <cocreature> reygoch: anyway, there is no solution for this in general but in jose’s case it looks like there is a cabal flag that toggles buildable: False on the executable
10:30:46 <cocreature> so turning on that flag will probably work
10:31:04 <reygoch> cocreature: I can turn on flags through cabal.project file?
10:31:11 <reygoch> or is it only command line?
10:31:30 <cocreature> reygoch: you can! https://cabal.readthedocs.io/en/latest/nix-local-build.html#cfg-field-flags
10:31:52 <reygoch> cocreature: Ho ho Ho!
10:32:00 <reygoch> cocreature: nice! :)
10:32:32 <cocreature> you can also specify them as constraints https://cabal.readthedocs.io/en/latest/nix-local-build.html#cfg-flag---constraint which should be equivalent afaik
10:34:25 <reygoch> cocreature: ah... unfortunatelly this is on the head version on the github. it is not released yet :(
10:34:42 <reygoch> cocreature: jose flag I mean
10:36:46 <cocreature> reygoch: good thing that cabal lets you depend on git projects now :)
10:37:06 <reygoch> cocreature: yes, I already do and it's wonderful
10:37:16 <reygoch> cocreature: no need for stack no more :P
10:38:29 <cocreature> reygoch: actually it looks like the default value of the flag is such that you shouldn’t even need to do anything with the git version
10:38:43 <reygoch> yes
10:40:39 <cocreature> I’m still confused by why cabal tries to resolve the dependencies of an executable only because you depend on the library of that package
10:40:56 <cocreature> I really thought cabal changed to only resolving the deps of the components that it actually needs
10:41:06 <reygoch> I think it tries to build the whole package
10:42:11 <reygoch> Is there some function with the type of (m a -> ( a -> m b ) -> m a)? I often find my self wanting to pass some monadic value to some intermediate function but continue using it afterwards. This seems like a very useful construct for chaining yet I can't find anything on hoogle.
10:42:52 <Solonarv> I haven't seen it anywhere
10:44:27 <cocreature> looks like https://github.com/haskell/cabal/issues/4087 is the issue for this
10:45:52 <ClaudiusMaximus> @undo \ma amb -> do{ a <- ma ; amb a ; pure a }
10:45:52 <lambdabot> \ ma amb -> ma >>= \ a -> amb a >> pure a
10:46:03 <ClaudiusMaximus> @pl \ ma amb -> ma >>= \ a -> amb a >> pure a
10:46:04 <lambdabot> (. flip (liftM2 (>>)) pure) . (>>=)
10:46:08 <ClaudiusMaximus> hm
10:52:51 <reygoch> ClaudiusMaximus: yes, that's what I have implemented, but it would've been cool if it were a part of standard library like (>>=) or (>=>)
10:54:52 <Solonarv> ClaudiusMaximus: reygoch: \ma amb -> ma >>= \a  -> a <$ amb a
10:55:06 <Solonarv> @pl \ma amb -> ma >>= \a -> a <$ amb a
10:55:06 <lambdabot> (. ap (<$)) . (>>=)
10:55:22 <reygoch> Solonarv: :)
10:55:34 <reygoch> Solonarv: such minimalism
10:56:25 <Solonarv> :t \ma amb -> ma >>= (<$) <*> amb
10:56:26 <lambdabot> Monad m => m a -> (a -> m b) -> m a
10:56:30 <Solonarv> hah!
11:00:37 <cocreature> reygoch: probably doesn’t cross the Fairbairn threshold especially given the existence of do-notation
11:00:41 <vides> I have a different question, perhaps easier for you to respond
11:01:03 <vides> there're a lot of time formats in Haskell! EpochTime, UTCTime, UnixTime, POSIXTime...
11:01:05 <cocreature> vides: you’ll have to actually show us the error
11:01:32 <cocreature> (for your first question)
11:01:49 <reygoch> vides: use UTCTime
11:01:53 <vides> so, I need a simple numeric time I can use for tagging things and calculating diffs between two different events
11:01:54 <ProofTechnique> I expect that it’s missing an argument of type `Problem`
11:02:10 <Solonarv> UTCTime is probably the right default
11:02:26 <vides> what's the difference between all those time formats, and what should I use (why UTC then?)
11:03:07 <vides> ProofTechnique heck wait a second! 
11:03:07 <reygoch> vides: It tells you in the documentation. UTC is general standard and will fit most purposes.
11:03:53 <cocreature> if you only care about differences something like the monotonic clock in https://hackage.haskell.org/package/clock-0.7.2/docs/System-Clock.html is probably the right choice
11:04:39 <ProofTechnique> https://wiki.haskell.org/Time
11:04:43 <cocreature> that saves you from having to worry about whether users/ntp/… adjusts the time between your two measurements
11:04:53 <ProofTechnique> Somewhat extensive discussion of time in Haskell
11:05:06 <vides> ProofTechnique, you're right, I was missing the stupid parameter!
11:05:51 <vides> must have missed it being tired anyway, thanks! :)
11:05:56 <ProofTechnique> No sweat
11:06:06 <vides> ProofTechnique, cocreature, thanks for the links, reading now
11:34:53 <Guest49264> has anyone got "command "join" must be executed on irc buffer (server or channel)" when trying to join haskell?
11:35:04 <Guest49264> has anyone got "command "join" must be executed on irc buffer (server or channel)" when trying to join haskell?
11:36:14 <Solonarv> Guest49264: what?
11:36:21 <Heffalump> Guest49264: not here
11:37:53 <int-e> Apparently that's a weechat error.
11:40:37 * hackage keycloak-hs 0.0.0.3 -   https://hackage.haskell.org/package/keycloak-hs-0.0.0.3 (CorentinDupont)
11:40:43 * shapr hugs Heffalump
11:58:00 <pie___> so im tryin gto learn emacs
11:58:28 <pie___> are ghc-mod and dante mutually exclusive? ghc-mod seems to support case splitting which im interested in
12:00:04 <geekosaur> dante doesn't know how to use ghc-mod
12:00:43 <pie___> i mean will they conflict if i try to use them
12:00:52 <pie___> https://github.com/projectional-haskell/structured-haskell-mode also seems to be a thing but that also seems orthogonal
12:01:30 <Solonarv> this is just guessing on my part, but I don't see why they would conflict
12:01:49 <Solonarv> (apart from the obvious "overlapping keybinds", I suppose)
12:23:17 <grayson> I have a few `IO (Maybe Foo)` values. How can I get an `IO (Maybe Foo)` that's just the first Just found?
12:24:23 <grayson> Alternative looks nice, but I wasn't sure how to deal with IO and Maybe together
12:25:15 <grayson> Should I use MaybeT?
12:25:30 <grayson> 12:21 *** NAMES @ChanServ @Sigyn [df] [exa] ^W _6a68 __4matter __monty__ _ceb _deepfire _flow_ _lerk_ _Tristan_ A1kmm a3Dman a_ ab9rf_ abbe abhir00p[m] abhixec abra0 absence abuss Achylles acidjnk acidrain_burns[m acowley acro adamCS adamse adarshaj Adeon adi2612[m] adius Adluc adw[m] AfC affinespaces agentofuser[m] agrif agschaid[m] ahihi ahri aib42 aidecoe ajmcmiddlin AJTJ akermu Akii alana[m]1 alanz alanz[m] albe
12:25:30 <grayson> l727 albertsg[m] albertus1 aldum Aleksejs alexelcu alexknvl alextes alp alyptik Amadiro amatecha ambrosia amiri ammar2 Amras amuck amx ancarda anderson andjjj23 AndreasK andreypopp angerman anishathalye Annihitek anohigisavay aoeupl[m] APic aplainzetakind apoc aporia[m] applecluster[m] aquarial[m] Aquazi Arahael aramiscd Arcaelyx ArchieT[m] Arguggi_ arianvp arkeet armyriad arsdragonfly[m] artify[m] arw_ asayers[m]1 
12:26:22 <Amras> what the hell are you doing grayson
12:26:30 <hpc> that looked like a pasteo
12:26:32 <zachk> I use mapM_ sometimes 
12:26:48 <hpc> drag over the wrong thing in your terminal and right-click (if you're using say, irssi over putty)
12:33:53 --- mode: ChanServ set +o ski
12:34:06 --- mode: ChanServ set -o ski
12:51:51 <fen> is it possible to show that something traversable is unfoldable?
12:52:09 <fen> class Unfoldable f where unfoldr ::  (s -> Maybe (a,s)) -> s -> f a
12:53:22 <fen> seems like it needs to get at the "hidden" constructor...
12:54:03 <fen> maybe it needs something dual to foldmap
12:54:28 <nshepperd> data Void a deriving (Functor, Traversable); -- not unfoldable
12:54:54 <fen> just use const?
12:55:09 <nshepperd> const what
12:55:15 <nshepperd> there are no values of Void a
12:55:20 <fen> the first two arguments of unfold
12:55:50 <fen> if the idea is to return something of that type, this case requires no informationto do so other than the type 
12:56:02 <nshepperd> unfoldr ::  (s -> Maybe (a,s)) -> s -> Void a
12:56:16 <nshepperd> unfoldr _ _ = ???
12:56:18 <nshepperd> what is ???
12:56:33 <fen> oh it has no way to construct a value
12:56:48 <fen> well cant we doubt that its a reasonable traversable!?
12:56:58 <nshepperd> no
12:57:36 <nshepperd> it's a perfectly reasonable traversable
12:57:52 <fen> what good is traverse :: (a -> f b) -> Void a -> f(Void b) ?
12:58:45 <nshepperd> it's probably very important for implementing isomorphisms in lens or something
12:58:50 <fen> lol
12:58:55 <EvanR> what good is a resistor with R = 0 ohms? because you dont need special robot machinery to handle that case, robots can place 0 ohms as easily as a "useful" resistor
12:58:56 <fen> butyou cant create it
12:59:12 <fen> so what is the good of functions which demand it as an argument?
12:59:17 <nshepperd> fen: the fact that t appears both before and after the arrow in traverse :: (a -> f b) -> t a -> f (t b) is very important here
13:00:18 <fen> you cant create it, so you cant unfold it, and you cant traverse it
13:01:14 <fen> and, if its the *only*counterexample, that might say something important
13:01:21 <EvanR> in APIs where you are asked for functors, in some cases you may want to choose Void a because you dont need the particular feature, and coming up with some other functor would be artificial
13:01:46 <fen> doesnt mean it can be created or traversed...
13:02:07 <EvanR> nonetheless traversable polymorphic machinery still works
13:02:27 <Guest79319> So are VPN connections not allowed on freenode?
13:02:42 <fen> you can just gove it an instance for any class and have undefined, and never wory about reaching it
13:03:11 <fen> just saying its not the best counterexample
13:03:36 <nshepperd> it's a great counterexample, you're just looking at it really narrowly
13:03:38 <EvanR> proof required that slapping undefined on some other type doesnt actually crash your program
13:03:55 <fen> nshepperd: but it has a valid unfoldable instance
13:04:01 <fen> undefined
13:04:05 <nshepperd> no it doesn't
13:04:10 <nshepperd> undefined isn't valid
13:04:16 <fen> neiter is Void!
13:04:22 <fen> they have the same utility
13:04:25 <nshepperd> no
13:04:32 <nshepperd> Void is a type, they're not even the same kind of thing
13:04:46 <nshepperd> if you accept undefined in instances you can give anything and instance of anything
13:04:53 <nshepperd> that proves far too much
13:04:54 <Solonarv> note: you can't actually call traverse @Void without passing it undefined
13:05:12 <fen> regardless, without another counterexample, there is still an only slightly weakened theorem
13:05:54 <nshepperd> fen: instance Traversable Void where { traverse _ v = absurd v }
13:05:58 <nshepperd> no undefined required
13:06:14 <EvanR> you can hypothetically call stuff which requires non existent arguments, bound variables are hypothetical
13:06:17 <fen> wtf is that absurd doing there
13:06:25 <fen> no this is not reasonable
13:06:44 <ProofTechnique> https://hackage.haskell.org/package/void-0.6.1/docs/Data-Void.html
13:06:46 <Solonarv> alright: instance Traversable Void where { traverse _ v = case v of {} }
13:06:57 <fen> its not a good counterexample, end
13:06:58 <nshepperd> fen: think of a function :: Traversable t => Maybe (t a) -> something else
13:07:08 <Solonarv> note that this is *not* a partial pattern-match!
13:07:13 <ProofTechnique> absurd is just “false implies anything”
13:07:19 <Solonarv> (it forces the bottom in 'v')
13:07:22 <fen> ...
13:07:22 <nshepperd> fen: because Void is Traversable, that function can call traverse on its input, no problem
13:07:40 <fen> but itmight be the only counterexample
13:07:41 <EvanR> big diff between having dangling undefines that might crash everything, and valid use of Void which can't crash anything
13:08:07 <fen> why argue its validity? just find another counterexample
13:08:19 <nshepperd> why be wrong when you can not
13:08:30 <ProofTechnique> You don’t need to find another counterexample if you already have one
13:08:31 <nshepperd> fen: and because Void is Traversable, you can pass Nothing :: Maybe (Void a) and everything works
13:08:45 <fen> thats as bad as undefined!
13:09:14 <ProofTechnique> undefined is radioactive, Void is well-defined
13:09:15 <nshepperd> fen: or how about an empty list of Voids? []
13:09:30 <fen> prooftechnique, only if the counterexample is not some totally unique subset of some other class of theories
13:09:38 <ProofTechnique> What?
13:09:45 <nshepperd> fen: Nothing has nothing (lol) to do with undefined, that's ridiculous
13:09:59 <ProofTechnique> Void is just the uninhabited type (modulo bottom, because Haskell)
13:10:15 <fen> that doesnt sound unique and peculiar at all
13:10:30 <fen> conjecutre: thats the only counterexample
13:10:31 <isaac_clarke> does anyone use haskell-ide-engine and neovim here? I've been having some issues
13:10:39 <ProofTechnique> Prove that there’s more than one uninhabited type up to isomorphism, then :)
13:10:44 <nshepperd> fen: but fine, you want another example? data MyGADT (b :: Bool) a where { Cons :: a -> MyGADT True a }
13:11:18 <fen> so whats happening here, its a proxy type
13:11:23 <fen> just like Void
13:11:28 <fen> but now it has a constructor
13:11:43 <Solonarv> fen: Identity is another counterexample
13:11:55 <nshepperd> fen: instance Traversable (MyGADT b) where { traverse f (Cons a) = Cons <$> f a }
13:12:08 <fen> what!? Solonarv, you can unfold identity from state just fine
13:12:10 <nshepperd> fen: MyGADT False is traversable. you can't unfold it
13:12:17 <Solonarv> unfoldr f s = case f s of Just (a, _) -> Identity a; Nothing -> ???
13:12:34 <fen> oh, its Unfoldable1
13:12:56 <nshepperd> fen: MyGADT b is also traversable, and you can't unfold it, and it has values
13:13:02 <fen> class Unfoldable1 f where unfoldr1 ::  (s -> (a,Maybe s)) -> s -> f a
13:13:20 <Solonarv> data Pair a = Pair a a, same argument
13:13:53 <SailFun> Hey! I'd like to learn Haskell, and I think it's best to do that with a project (or not?), would a SMTP server be viable? Or hard due to I/O? My background is bachelor's level maths (second year), and I know some algebra (groups, rings), but no category theory...
13:14:14 <Solonarv> unfoldr f s = case f s of (a, s') -> case f s' of { (a', _) -> Pair a a; Nothing -> ??? }
13:14:24 <fen> Solonarv: no, you can unfold the state into a list, take 2 and return the pair
13:14:28 <EvanR> a simple SMTP server would be pretty easy
13:14:46 <fen> oh, right that might need Unfold0
13:14:47 <Solonarv> fen: but what if the list you get back only has one element?
13:14:55 <fen> the stream version
13:15:12 <fen> to guarantee it wont fail before your done retriving as many values as required
13:15:25 <Solonarv> perhaps the fact that you're inventing a new unfold variant for every counterexample should tell you something's fishy about your original statement
13:15:26 <fen> class Unfoldable0 f where unfoldr0 ::  (s -> (a,s)) -> s -> f a
13:15:34 <fen> no there are only 3 varients
13:15:42 <fen> and we have now an example for each
13:15:45 <nshepperd> fen: so you agree your original claim was wrong
13:16:02 <fen> is it possible to show that something traversable is unfoldable?
13:16:06 <nshepperd> you can't implement unfoldr for every traversable
13:16:11 <nshepperd> no, because it's false
13:16:29 <fen> so far only for proxy types
13:16:33 <SailFun> EvanR: Ah, that's good to hear! Just starting out while simultaneously reading LYAH/another Haskell book would be best I guess?
13:16:47 <EvanR> probably another haskell book
13:16:58 <nshepperd> 'proxy types' isn't a thing
13:16:59 <dminuoso> SailFun: CIS194 is also very popular and comes with high recommendations from many.
13:17:05 <dminuoso> ?where cis194
13:17:05 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
13:17:06 <Solonarv> MyGADT from above is not a "proxy type" in any sense
13:17:15 <fen> well what is the thing that describes this class of counterexamples then?
13:17:30 <Solonarv> "traversables that aren't unfoldable"
13:17:31 <dminuoso> Solonarv: Also let me reassure you: Contrary to what I consider very bad press, you do not need any mathematical knowledge to learn Haskell.
13:17:31 <fen> and whats the version of unfold that needs to be invented to capture them
13:17:35 <dminuoso> Err. SailFun %-
13:18:00 <fen> Solonarv: bah!
13:18:29 <fen> data MyGADT (b :: Bool) a where { Cons :: a -> MyGADT True a }
13:18:32 <Solonarv> I don't think there's a shorter name, and I don't think it's a particularly interesting class of data structures either
13:18:32 <fen> where is the b?
13:18:35 <ProofTechnique> https://github.com/data61/fp-course
13:18:43 <ProofTechnique> SailFun: ^
13:18:50 <SailFun> dminuoso: Thanks! Looks more compact than most books on the internet, which is really nice!
13:18:52 <dminuoso> SailFun: Category theory is sadly perceived as being useful or even required for Haskell - it's sadly completely bogus and wrong.
13:19:11 <Solonarv> fen: you can write that as: data MyGADT (b :: Bool) a where { Cons :: (b ~ True) => a -> MyGADT b a }
13:19:15 * geekosaur has picked up some abstract math via haskell. it wasn't there to begin with
13:19:39 <fen> some kind of injective but not surjectiveness
13:19:55 <fen> idont know whats going on anymore
13:20:02 <ProofTechnique> Type theory is definitely more intuitive than set theory, at least for me.
13:20:05 <fen> these counterexamples are complicated
13:20:13 <fen> why cant they be unfolded?
13:20:15 <Solonarv> Void is about as uncomplicated as it gets
13:20:19 <ProofTechnique> Void a is about as simple as you can be
13:20:23 <Solonarv> but you keep moving the goalposts!
13:20:37 <dminuoso> SailFun: There's a newer version by Joachin Breitner. Both authors are very respectable people in the Haskell community and CIS194 comes with many useful and real world excercises.
13:20:42 <nshepperd> fen: here's another counterexample. IOVector
13:20:58 <nshepperd> er, Coyoneda IOVector
13:21:09 <SailFun> ProofTechnique: Thank you! It seems like a program you run in GHCi and it's sort of a tutorial?
13:21:11 <nshepperd> i guess
13:21:17 <fen> if by doing so it makes versions of unfold that capture all traversables then thats moving the goalposts right up to the ball..
13:21:29 <nshepperd> eh, that's only Functor
13:21:31 <ProofTechnique> Yeah, it’s quite good. They have one for lens, too, if you want to tread that road :D
13:21:41 <dminuoso> SailFun: At any rate: You can become a haskell expert with just basic high school math knowledge. :)
13:21:41 <nshepperd> there's probably a traversable version in there somewhere
13:21:46 <ProofTechnique> I’d recommend leaving that for later, though
13:21:59 <SailFun> dminuoso: Well, I could follow a course on category theory/algebraic topology in order to become more familiar with the concepts, but if it isn't required I'd rather not do it ;)
13:22:13 <SailFun> ProofTechnique: Lens is a lib right?
13:22:16 <dminuoso> SailFun: If you are genuinely interested into those topics, feel free to.
13:22:21 <fen> basically there must be a simplest counterexample of the thing thats happening here to make them not be unfoldable
13:22:21 <ProofTechnique> Lens is a state of mind
13:22:26 <dminuoso> SailFun: But it's not required in the *slightest*.
13:22:28 <ProofTechnique> But yeah, it’s a lib :)
13:22:35 <ProofTechnique> Also not at all required
13:22:55 * ski . o O ( "Category Theory is bunk." )
13:22:59 <fen> and probably a name or way to describe whats happening
13:23:53 <ProofTechnique> ski: Bunk has some very interesting morphisms, I’ll have you know!
13:23:54 <SailFun> dminuoso: I'll play around then, figure it'll take some time to become somewhat proficient in Haskell
13:23:56 <SailFun> :)
13:24:09 <dminuoso> SailFun: Yes. Writing Haskell is the way to become good at Haskell.
13:24:21 <dminuoso> Solve programming problems. Writing useful programs.
13:24:26 <ProofTechnique> fen: What *is* happening? I’m not sure what you’re observing that’s so distressing
13:24:28 <dminuoso> It's no different from any other language.
13:24:38 <ski> ProofTechnique : it's an expression of admiration ;)
13:25:13 <ProofTechnique> The category of hogwash and puffery, Bunk
13:25:16 <SailFun> I'm kind of afraid that some problems will be nearly unsolvable without using advanced techniques, while not knowing those features exist...
13:25:17 <mouse07410> Besides CIS194, what other good Haskell books do you recommend for a beginner?  I looked at "Haskell Programming" by C. Allen, but wasn't impressed: unnecessarily verbose in some cases, too terse in other cases, and worst of all - none of the exercises (which aren't always covered by the chapter they're for)  come with an answer, so it's annoying to be stuck with no hint or solution to align your thinking to.
13:25:21 <Solonarv> Category Theory AKA Generalized Abstract Nonsense
13:25:24 <Solonarv> :p
13:25:34 <dminuoso> SailFun: https://patrickmn.com/software/the-haskell-pyramid/
13:25:49 <dminuoso> Solonarv: This sadly tends to give Haskell bad reputation, making the language seem so complicated and mathy.
13:25:56 <Solonarv> aye
13:25:57 <dminuoso> Wow. What's wrong with weechat. :(
13:25:59 <ProofTechnique> mouse07410: Manning has some good books. I heard good things about Get Programming with Haskell
13:26:02 <dminuoso> That was supposed to go to SailFun.
13:26:21 <Solonarv> it looks like it did on my screen!
13:26:26 <ProofTechnique> And the data61 courses
13:26:39 <fen> MyGadt seems to be proxy on one half of the bool...
13:26:54 <ProofTechnique> You keep using this word...
13:27:05 <mouse07410> ProofTechnique: thanks - I'll check what Manning has (liked their other books, and they provide soft copies as well - convenient)
13:27:11 <SailFun> dminuoso: that's encouraging :) 
13:27:15 <dminuoso> SailFun: The productive bar in Haskell is really low. You can write highly stable and maintainable production code without any type extensions or math crazy stuff. :)
13:27:16 <Solonarv> I think fen is trying to say "phantom", but that isn't even correct here
13:27:52 <fen> oh right because thereis choice over which half is phntomed
13:28:30 <nshepperd> fen: a value of type MyGADT b a is a value of type a, together with proof that b is True
13:28:50 <kritzefitz> SailFun, When I started writing Haskell code, I didn't ave much knowledge of of the underlying mathematical concepts either (not that this has changed much).
13:29:03 <dminuoso> SailFun: The real difficulty in Haskell is for people who are used to imperative languages. This is not because you can't write "python-style code" in Haskell, in fact you can! 
13:29:06 <kritzefitz> My experience is, that you learn of more advanced features over time.
13:29:20 <fen> so its like a void when b is false?
13:29:23 <SailFun> dminuoso: I once tried to use ws-sockets or something like that to process a webstream, it wasn't that easy (converting ByteStrings/Strings/Text was pretty hard). 
13:29:27 <dminuoso> SailFun: But it's that Haskell has certain semantics that may seem very strange, and idioms you may not be used ot.
13:29:31 <fen> you cant create it, but its traversable
13:29:33 <nshepperd> fen: you can't create such a value with an 'unfold' because doing so requires you to prove that b is True
13:29:56 <fen> you cant create it at all?
13:29:58 <kritzefitz> But many of the advanced features aren't really required for most things anyway.
13:29:59 <ProofTechnique> The real difficulty is getting over the Text hump and figuring out what list-like thing you want to use
13:30:03 <dminuoso> SailFun: Ah! ByteString/Text is a very interesting topic, because it brings up an issue that languages have started to "hide from programmers"
13:30:22 <SailFun> kritzefitz: Seems like many haven't :) I have some algebra knowledge, but nothing too fancy :)
13:30:25 <nshepperd> fen: you can't create it without knowing b
13:30:32 <nshepperd> fen: but you can traverse it without knowing b
13:30:42 <kritzefitz> SailFun, Algebra will be very useful for Haskell.
13:30:46 <dminuoso> SailFun: Having algebra knowledge is advantageous because it might allow you to think in more abstract terms
13:30:51 <fen> hmm, interesting
13:30:52 <Solonarv> dminuoso: idk about "have started to hide from programmers"
13:31:10 <Solonarv> python for example has had separate types for bytestrings and text for quite some time
13:31:19 <dminuoso> SailFun: For example, there is a Monoid class. It doesn't serve any particular purpose other than to capture the idea that you have some (Type, (+), 0) tuple following some laws.
13:31:25 <hpc> well, "types"
13:31:37 <EvanR> SailFun: yeah String, ByteString, Text is half historical baggage half "oh yeah, many other languages are doing it wrong"
13:31:40 <ProofTechnique> I just wish ByteString didn’t have the String part in the name. I think it leads to treating it like text, when it definitely doesn’t make any such guarantees
13:31:43 <nshepperd> fen: this is not some special case, the whole point of GADTs is that they can carry information about types, as well as values
13:31:51 <SailFun> dminuoso: I'm indeed used to C++/Java, and I stumbled upon ReactiveX, which I found so awesome that I wanted to learn a functional programming language :p 
13:31:55 <Solonarv> hey, python has types - they just aren't checked at compile time, and often not at runtime either
13:32:08 <fen> well thats because in the case where b is true, it can be created and traversed, and when b is false, its like void, cant be created and has undefined traversable instance 
13:32:14 <dminuoso> SailFun: You're in for a big story then. ReactiveX is a.. weird.. not very reactive... thing.
13:32:17 <nshepperd> fen: so you usually can't create them ex nihilo, because you don't have that information
13:32:19 <hpc> ProofTechnique: yeah, there would be a nice sort of directness to the default stringy types being "Text" and "Bytes"
13:32:32 <dminuoso> SailFun: But that is probably a big too deep for now.
13:32:32 <Solonarv> fen: the Traversable instance is not undefined!
13:32:53 <dminuoso> 22:30        Solonarv | dminuoso: idk about "have started to hide from programmers"
13:32:54 <SailFun> EvanR: How did that develop?
13:33:04 <dminuoso> Solonarv: Quite a few languages hide the fact that "encoding" is a thing.
13:33:04 <nshepperd> fen: it has only one Traversable instance, which doesn't care which case of b
13:33:27 <dminuoso> Solonarv: And it's annoying because libraries start with implicit contracts about encoding.
13:33:27 <EvanR> SailFun: String = [Char] was simple and good enough for a hot minute a long time ago. ByteString and Text exist for better performance and sanity
13:33:42 <fen> there is a subset of haskell without these constrained gadts?
13:33:42 <Solonarv> oh, that's certainly true
13:33:58 <dminuoso> Solonarv: And then you get into a hell of mojibake, trying to guess what library XYZ has done.
13:34:05 <dminuoso> Or worse: what encoding your favourite API uses.
13:34:06 <fen> we used to not have them
13:34:15 <dminuoso> (Because why bother documenting)
13:34:20 <Solonarv> At least if they all defaulted to utf8 or something it would be okay
13:34:31 <Solonarv> but they don't!
13:34:31 <fen> or at least ghc gave some error saying such style was frowned upon!
13:34:36 <SailFun> EvanR: Ah! Guess I should read about it! :)
13:34:39 <fen> can we call them dictionary like things?
13:34:48 <dminuoso> Solonarv: In fact Im a bit annoyed that Haskell is not clear about source file encoding.
13:34:51 <dminuoso> It just says unicode.
13:35:03 <fen> thats phantom types again?
13:35:10 <SailFun> Anyway, thank you (all) for your great advice :)
13:35:13 <nshepperd> fen: how do you unfold data TwoOrFive a = Two a a | Five a a a a a
13:35:15 <fen> nono, its a constraint.
13:35:37 <SailFun> (Oh! An IDE! What would you recommend? I have Intellij Ultimate)
13:35:50 <Solonarv> SailFun: honestly, IDE support for haskell is a bit spotty
13:35:52 <fen> nshepperd, same as the simpler pair case, given that we can have a stream of infinitly many a's by demanding the state is returned for sure along with each a
13:36:04 <Solonarv> these days I just use an editor with syntax highlighting + ghcid
13:36:11 <SailFun> Solonarv: So, Atom would do fine?
13:36:12 <EvanR> SailFun: ByteString are packed arrays of bytes (Word8). Text is arrays of Char with an efficient implementation that you shouldnt usually care about
13:36:16 <dminuoso> SailFun: Also ignore people talking about seemingly complicated topics in here! If you ever have a seemingly trivial problem - just drop it in the middle of people discussing CT weirdities you dont understand.
13:36:23 <nshepperd> fen: and which constructor do you choose?
13:36:29 <fen> oh, and its as shape
13:36:30 <ProofTechnique> Solonarv: I’ve been very happy with LSP in Emacs, but getting it working was a minor chore, admittedly
13:36:34 <Solonarv> SailFun: sure, you might even find a Haskell plugin for it that works to your satisfaction
13:36:36 <MarcelineVQ> yes atom works fine, as does intellij
13:36:41 <fen> so its actually unfoldable_r0
13:36:49 <dminuoso> SailFun: Pick the editor you are most comfortable with.
13:36:52 <SailFun> EvanR: Ah, clear :)
13:36:52 <Solonarv> last I checked the intellij plugin was welded to stack (via intero)
13:36:56 <dminuoso> Even if that's joe or textmate.
13:36:59 <EvanR> SailFun: the difference between bytes and text really does come up... like everywhere
13:37:17 <fen> class Unfoldable_r0 r f where unfoldr_r0 ::  (s -> (r a,s)) -> s -> f a
13:37:25 <nshepperd> fen: do you return Two or Five?
13:37:29 <EvanR> hence the encoding and decoding you have to do
13:37:33 <fen> thats what r will tell you
13:37:50 <nshepperd> what
13:37:52 <dminuoso> Maybe ByteString should have been called ByteArray instead.
13:38:03 <SailFun> dminuoso: Will do, when I really can't figure something out :)
13:38:04 <fen> r will either be a tripple of 5-tuple
13:38:11 <fen> or*
13:38:21 <ProofTechnique> ByteArray would be much better
13:38:25 <EvanR> it seems pretty obvious what ByteString ... is
13:38:29 <SailFun> Solonarv: There's one, https://plugins.jetbrains.com/plugin/8258-intellij-haskell Don't know how good it works
13:38:45 <ProofTechnique> Bytes seems nicer to read, though
13:38:45 <dmwit> dminuoso: I think we already have a ByteArray somewhere deep in the GHC guts.
13:38:59 <Solonarv> fen: well that's trivial, because then you just have 'unfoldr_r0 :: (s -> (TwoOrFive a, s)) -> s -> TwoOrFive a'
13:39:01 <EvanR> in other news [Char] is shorter than String :)
13:39:12 <nshepperd> fen: that's just baking the answer in, lol. your function reduces to id?
13:39:18 <dminuoso> dmwit: Yeah but.. just because we have it in the guts of GHC doesn't mean that fact should prevent us from using another similarly named type.
13:39:20 <fen> damn
13:39:26 <Solonarv> more generally, with that definition any 'f' can be given an instance by setting r ~ f
13:39:31 <fen> well it would work for unfolding Free TwoOrFive
13:39:34 <dminuoso> dmwit: The folks that *do* work on GHC are smart enough to keep two ByteArray's apart. The folks who dont wont care.
13:39:40 <dmwit> dminuoso: Perhaps. I think it's reasonable to make a best effort to avoid name clashes and the confusion they cause.
13:39:49 <fen> or something...
13:39:57 <nshepperd> fen: next: how do you unfold data Env b a = Env (IORef b) a
13:39:59 <ProofTechnique> EvanR: Aren’t they the same length?
13:40:10 <EvanR> ... dang youre right
13:40:13 <dminuoso> dmwit: By the way sorry I had to drop out suddenly yesterday, had an important call. Ill follow up on the discussion at som epoint.
13:40:33 <dmwit> If it makes you feel any better, I didn't even remember that you dropped out on me.
13:40:36 <fen> data TwoOrFiveTree a = Two a a (TwoOrFiveTree a) | Five a a a a a (TwoOrFiveTree a)
13:40:50 <fen> like, thats something better for unfolding...
13:41:06 <fen> no wonder the constructor without recursion was trivial
13:41:16 <nshepperd> fen: you don't get any points for handling something that's not the counterexample
13:41:21 <dmwit> fen: Perhaps it is time for you to sit down with a pencil and paper and do a bit of work on your own to figure things out carefully.
13:41:36 <ProofTechnique> It is a truism of mathematics that if you’re doing this much work for a formalism, you’re dancing around the real problem. Or you’re a model theorist
13:41:47 <fen> just explaining why it seemed like `r' would help, but yes, was confused
13:42:40 <fen> dmwit: perhaps!
13:42:43 <dmwit> If you know the standard algebra of types (sums, products, 0, 1, and recursion), that should give you a good starting place for checking yourself that your construction handles all types.
13:43:17 <fen> might start there
13:43:46 <dmwit> Mmm. I guess there's exponentials, too, but even without them you'll run into plenty of complications. =)
13:43:49 <dminuoso> SailFun: Sadly Haskell tooling is rather poor. 
13:43:54 <fen> might even derive all the cases where it does work!
13:44:00 <nshepperd> exponentials, primitives, GADTs
13:44:06 <fen> and then i can check to see the extent they cover
13:44:24 <fen> it would be obvious then
13:44:34 <Solonarv> primitives can mostly be modelled as ADTs if you're willing to handwave performance
13:44:39 <nshepperd> if you're programming haskell you can't just ignore things like IORefs
13:44:47 <dmwit> Sure you can!
13:44:50 <Solonarv> oh right *those* primitives
13:44:50 <dminuoso> SailFun: Intero was way too buggy for me, which is why I just use raw emacs with some syntax highlighting now. :)
13:45:04 <Solonarv> I thought you were talking about Int, Char, &c
13:45:19 <dmwit> A construction that handles only basic ADTs is already a construction worth paying attention to.
13:45:20 <EvanR> newtype IORefs = IORefs Int :)
13:45:28 <fen> its not just programming in haskell though, its specifically determining the realm of unfoldables
13:46:01 <fen> which happens to be a good place to not consider things which are not unfoldable?
13:46:04 <nisstyre> "realm of unfoldables" sounds like another dimension where you can't fold laundry
13:46:25 <fen> ill fold you!
13:46:32 <fen> *shakes fist*
13:46:33 <ProofTechnique> dminuoso: Have you tried haskell-ide-engine with lsp-mode. It’s been pretty good
13:46:34 <nisstyre> I can fold myself
13:46:42 <ProofTechnique> *?
13:46:53 <dmwit> #haskell is now ##poker, go
13:46:54 <hpc> nisstyre: that's the next doctor strange movie plot :D
13:47:31 <nisstyre> hpc: I actually was thinking more of Ant Man but yeah
13:47:33 <nisstyre> they could team up
13:48:03 <dminuoso> ProofTechnique: lsp-mode seems like the first modern approach that could work, but I havent tried it yet
13:49:26 <fen> fold me - you cant get folded again
13:50:29 * ski . o O ( "Fold me once, shame on you. Fold me twice, shame on me !" )
13:51:02 <hpc> fold me left, shame on you
13:51:05 <ProofTechnique> That’s the 1 and 2 case; who gets shamed in the infinite case?
13:51:09 <hpc> unfold me right, also shame on you
13:51:25 <fen> call!
13:52:48 <dmwit> ProofTechnique: I have a lower bound on the first fold which shames somebody a second time, but the margin is too small to contain it.
13:52:59 <mouse07410> dminuoso: you're absolutely right about difficulties fur one coming from imperative languages. But I disagree that knowledge of Algebra helps - I've a degree in Math, but don't feel like it's helping me writing Haskell programs to solve problems.
13:53:08 <dmwit> (Oh, drat! I always get those mixed up. I mean upper bound.)
13:54:00 <ProofTechnique> Depends how constructive your math program was :)
13:54:14 <__monty__> mouse07410: Maybe that's because you don't realize the algebra useful in haskell is math because it's too simple : >
13:54:28 <Solonarv> __monty__: I was about to say something like that
13:55:37 <ProofTechnique> Intuitionistic type theory: it’s not that kind of intuition, but yeah it is.
13:55:38 <dminuoso> mouse07410: You misunderstand.
13:56:06 <dminuoso> mouse07410: Im claiming some preexisting algebra knowledge might help understand things like basic typeclasses easier on the basis that they are just abstract things.
13:56:08 <Solonarv> in contrast, my math education is first semester of uni + a hodgepodge acquired from wikipedia and the odd paper/book, and it sure seems like it's been helpful for Haskell
13:56:25 <dminuoso> mouse07410: Say if you have studied algebraic structures before, then Monoid will be no surprise to you.
13:56:32 <fen> anyway, cant seem to implement any of the unfoldables using traverse!
13:56:39 <dminuoso> You wont go looking for "what problem exactly does monoid try to solve"
13:57:42 <dminuoso> (But it's not worth learning algebra for Haskell in the first place)
13:58:10 <ProofTechnique> It is worth learning algebra, but just for fun
13:58:15 <ProofTechnique> Not for Haskell
13:58:21 <MarcelineVQ> when people say algebra helps for haskell they mean highschool algebra
13:58:27 <ski> if you have learned solving first degree equations, then (some of) the symbolic manipulation skill will be helpful for learning to reason in Haskell
13:58:31 <ski> yes
13:59:44 * ski . o O ( "Prerequisite for Learning Haskell" by monochrom at <http://www.vex.net/~trebla/haskell/prerequisite.xhtml> )
13:59:57 <dminuoso> MarcelineVQ: SailFun said they have preexisting uni knowledge about algebraic structures. So my point was actually "then grokking Functor is probably going to be much easier because you're already used abstract structures before"
14:00:11 <ProofTechnique> The only prerequisite for learning Haskell is not knowing Haskell yet
14:00:16 * ProofTechnique nods sagely
14:01:06 * ski idly wonders whether some variant of that would fit the tautology page
14:01:14 <dmwit> ProofTechnique++
14:01:29 <mouse07410> ProofTechnique: oh, I love Algebra since college - my only point is that it didn't seem to apply to most anything in doing with computers nowadays.
14:01:50 <dminuoso> mouse07410: it applies to computer programs though.
14:01:55 <mouse07410> *I'm doing
14:01:56 <iqubic> What is the tautology page?
14:02:09 <fen> what isnt it!
14:02:16 <hpc> iqubic: it's the tautology page
14:02:16 <iqubic> And don't you dare say "The tautology page is the tautology page"
14:02:17 <dmwit> iqubic: http://www.vex.net/~trebla/humour/tautologies.html
14:02:52 <mouse07410> dminuoso: not to the programs in writing for my projects.
14:03:16 <mouse07410> "in" -> "I'm"
14:03:26 <dminuoso> mouse07410: There are fundamental algebraic structures whether you see them or not.
14:03:44 <dmwit> I have personally had to remind people of 0, 4, and 5 many times.
14:03:50 <dminuoso> You might not invoke them explicitly.
14:04:16 <ProofTechnique> Once in a while I get to simplify some code in legacy projects because “oh, this is just <some structure>”, but yeah, it’s not an everyday thing
14:04:17 <Solonarv> (but you probably do: consider how many specializations foldMap has)
14:04:34 <Solonarv> (foldMap is one of my favorit functions for this reason!)
14:04:39 <dmwit> dminuoso: That... makes me think of that Feynman story about how he's got an upturned horseshoe over his door on the grounds that "supposedly it works whether I believe in it or not".
14:04:50 <hpc> every time you refactor your code, there's a little bit of algebra in the way you make sure you did it correctly
14:04:55 <dmwit> dminuoso: If you don't see the fundamental algebraic structures, then it hasn't helped you to learn algebra.
14:04:58 <__monty__> MarcelineVQ: Groups was past highschool algebra for me, so not necessarily just highschool algebra. Matrices are an algebra thing that hasn't helped me with haskell at all so far.
14:05:02 <ProofTechnique> In Haskell I do it much more explicitly, and that helped me recognize those opportunities in other languages
14:05:32 <fen> like jobs
14:07:09 <fen> and runtime errors
14:07:12 <mouse07410> ProofTechnique: since you've made a good point - I'll try to pay attention and see if I can recognize and constructively use any of algebraic structures in my Haskell programs, and maybe from there - in other languages.
14:07:14 <fen> maybe there is a connection...
14:08:14 <dminuoso> mouse07410: Note though that even just algebraic structures is not the goal. It's when you draw useful conclusions from seeing those structures. 
14:08:25 <fen> monty: we cant do linear algebra in haskell because the types are too complicated
14:08:31 <dminuoso> mouse07410: One thing we often like to reason about (whether you know it or not) is associativity.
14:08:37 <EvanR> analytical thinking can either help you or drive you nuts because the situation youre in makes analytical thinking so useless
14:09:08 <dminuoso> mouse07410: that simple thought of `(f . g) . h = f . (g . h)` is omnipresent in writing code.
14:09:16 <dminuoso> Even though you might not think about it explicitly.
14:09:35 <hpc> that associativity shows up in how do-notation is translated to (>>=)
14:09:50 <dminuoso> And we reason based on that associativity every day!
14:10:02 <hpc> er, i was thinking (>=>), but still
14:10:14 <dminuoso> hpc: Same thing really, they even call it associativity for Monad. :)
14:10:55 <fen> then we get a lambda lie algebra 
14:11:02 <hpc> or when you translate to applicative, or when you fmap a big function pipeline
14:11:33 <dminuoso> Recognizing laws can help you understand whether a code transformation is a correct thing to do. :)
14:11:56 <fen> quantum information theory anyone?
14:12:35 <Solonarv> "Recognizing laws can help you understand whether a code transformation is a correct thing to do. :)" - in fact this is also how many of GHC's optimizations work!
14:13:01 <ProofTechnique> When I was but a sprout, I truly hoped that Lie algebras would be some kind of fibbing formalism
14:13:07 <fen> there was a horrible idea of gradient flows over lamda distributions at one point 
14:13:58 <fen> stochastic mean field games and type uncertainty
14:15:35 <ProofTechnique> There are some linear algebra libs I’ve heard are good, but I haven’t used any of them enough to say they actually are
14:16:46 <fen> there was some work on sparse optimisation too
14:17:01 <mouse07410> dminuoso: I see your point, sort of... But in my apps associativity was almost never possible, and refactoring was rarely a factor (pun only partially intended). I'm dealing with communication protocols and crypto.
14:21:35 <dminuoso> mouse07410: Consider hpc's example.
14:22:27 <jstorb> I have a question:
14:22:36 <jstorb> I can't load this into ghci
14:22:36 <dminuoso> mouse07410: So whether you write `do { f; z }` or `do { x; g }` where f = do { x; y }; g = do { y; z }` 
14:22:47 <jstorb> cat _ _ = []; a = cat [] [] == []
14:22:52 <mouse07410> __monty__: maybe you're right about "too simple", I can't tell.
14:23:13 <dminuoso> mouse07410: That seems like a trivial fact, both clearly seem equivalent.
14:23:14 <monochrom> "refactoring" doesn't have to refer to big changes.  Something a "trivial" as "hey I have do { x <- m; return x } I'm going to just simplify that to m" already requires monad laws.
14:23:15 <jstorb> however, without the second line (after the ";"), it works and I can write the second line directly in ghci without issues
14:23:22 <__monty__> mouse07410: What are you working on actually? Crypto for comms sounds interesting.
14:23:35 <jstorb> but when loading from file I get: "Ambiguous type variable ‘a0’ arising from a use of ‘==’"
14:23:38 <ProofTechnique> It also helps, when working in less persnickety languages than Haskell, to satisfy yourself with moral correctness if you can’t have formal correctness. Collections in PHP behave enough like a Functor that I can use some of the same thought processes, but I definitely wouldn’t trust it to be law abiding
14:24:30 <ProofTechnique> Though I’m also happy that the days where I had to write that at all are over :)
14:24:44 <mouse07410> dminuoso: yeah, but I don't deal with HPC.
14:24:58 <dminuoso> mouse07410: You dont have to?
14:25:18 <dminuoso> mouse07410: It's that reasoning in your head where you could move any part of your "IO heavy program" into a seperate routine.
14:25:26 <hpc> mouse07410: you can't escape me!
14:25:33 <monochrom> https://wiki.haskell.org/Monad_laws has the monad laws written in do-notation so you can see how you have always taken them for granted.
14:26:08 <dminuoso> mouse07410: Moving things into bindings tends (and thinking "this is clearly no different") is simply based on associativity usually.
14:26:14 <dminuoso> *tends to be based
14:26:14 <Solonarv> jstorb: in GHCi, type defaulting is more aggressive; those lists literals will have type [()]
14:26:21 <Solonarv> Not so in a source file.
14:26:46 <mouse07410> __monty__: yeah it's comms, but in wider sense -consider anything from, e.g., a network management protocol riding on top of UDP or DTLS, or a true waveform like what SDR is about...
14:27:24 <mouse07410> hpc: but I sure can try! 😆😈
14:28:14 <fen> argh coulour! 
14:28:37 <ProofTechnique> I’m so looking forward to the context on that
14:30:51 <dminuoso> mouse07410: Another common example might be recursive algorithms. Somewhat frequently you might have some algorithm that perhaps produces a list - perhaps at the base case you produce an empty list, and in the recursive step you just concatenate lists.
14:31:38 <dminuoso> Suddenly you find yourself using a monoid, where you take the associativity and identity law for granted.
14:36:18 <mouse07410> dminuoso: your are correct that we always deal with the issues of how to best group and order components of a system we're working on. But so far (in the last 30+ years or so) I did not feel that the formal training in received in Math (Algebra and such) helped at all.
14:39:21 <fen> ha! i cant even think how to write a function over every value in a continuous domain
14:40:12 <fen> though a dyson expansion is close...
14:42:52 <mouse07410> Re. Formal Correctness - IMHO it's a big buzzword, but little more, because it's impossible to capture and realistically depict all the assumptions that a real-works system makes/requires. As a result - you have a formal proof that covers part of your system under unrealistic assumptions...
14:43:39 <fen> lossy compression?
14:44:20 <EvanR> fen: in terms of other continuous functions
14:44:32 <ProofTechnique> mouse07410: I suppose I should say “morally/formally lawful”, really
14:44:38 <EvanR> the two easiest are const something and id
14:44:56 <fen> well it would have infinite parameters
14:45:09 <EvanR> what else you need depends on domain
14:45:11 <ProofTechnique> Since program transformations on an incorrect program keep being incorrect, even if the transformations are lawful
14:46:10 <fen> not on all the values one at a time, like, would work on any value, as id would, but just simply to write f(x1,x2 ... xn) as n -> infinity
14:46:20 <fen> well ok thats one way to write it... 
14:47:11 <EvanR> by continuous domain you mean a countable number of params?
14:47:21 <EvanR> lost
14:47:31 <fen> it would have a really large taylor expansion, with cijk...... weights
14:48:09 <ProofTechnique> Also lost
14:48:13 <fen> well we can integrate continuous domains fine, but thats like a linear combination, the continuous version of a sum
14:48:41 <fen> and for a function, you need to cross multiply all the combinations
14:48:53 <fen> in the taylor expansion...
14:49:09 <ProofTechnique> I think the only meaningful function up to isomorphism *in* a continuous domain (i.e., it has every member of the domain as an argument) is the function which constructs the domain
14:49:19 <fen> just wondering why there is no mathmatical symbol for that, seems like something that would be pretty common
14:49:40 <ski> (hm, is there should be an FRP implementation, but for (continuous) space, rather than time ?)
14:49:58 <EvanR> a shader language?
14:50:07 <ski> possibly
14:50:13 <MarcelineVQ> ski: what's the difference, dimensionality?
14:50:36 <fen> prooftechnique: what!?
14:50:40 <ProofTechnique> Continuous spacetime, while we’re at it
14:50:50 * ski . o O ( Fran )
14:51:09 <EvanR> the function that constructs the domain, is that normally a thing? didnt think so
14:52:01 <ski> MarcelineVQ : well, in theory, yes
14:52:01 <conal> ski: see http://conal.net/Pan/, http://conal.net/Vertigo/, and the graphics examples in https://github.com/conal/concat (generates gpu code). All based on simple denotation as functions of continuous infinite space.
14:52:13 <fen> do you mean the coordinates of an embedded surface?
14:52:14 <ProofTechnique> Exactly :|
14:52:22 <ProofTechnique> To EvanR
14:52:39 <ski> conal : nice :)
14:52:42 <ProofTechnique> It’s basically just a very dumb huge id
14:53:27 <monochrom> mouse07410: What is a better alternative then? Do you just give up any reasoning about your code at all?
14:53:45 <ProofTechnique> While also having the benefit of being ill-defined, ill-formed, and icky :D
14:54:57 <monochrom> I mean it sounds like how people learn of Godel incompleteness etc and then scorn "haha see what's wrong with being logical".  Dude what's the alternative, being illogical?
14:55:07 <fen> well you could have a matrix acting on a vector, and take the continuous limit as the rank -> infinity, but that is still linear, it does not give cross multiplication of terms for the taylor expansion - ie to express an arbitrary nonlinear function over all of the arguments of the infinite vector, instead of just mixing them linearly with an infinite square matrix
14:56:20 <fen> it was just supposed to be an example of how math language does not capture really common ideas
14:56:44 <EvanR> for smooth functions you certainly could treat them as infinite vector of coefs
14:56:54 <EvanR> of taylor expansion
14:57:04 <fen> in 1d?
14:57:10 <EvanR> R -> R
14:57:14 <fen> what about infinite dimension?
14:57:33 <fen> we just dont have that
14:58:42 <fen> the infinite dimensional taylor expansion of a function from R^infinity to R
14:58:47 <EvanR> smooth function from smooth functions on R to itself...
14:58:57 <EvanR> head explode
14:59:23 <fen> arity fail
15:00:11 <EvanR> whatever were talking about, changing R to C probably fixes it
15:00:41 <monochrom> Are you OK?
15:00:42 <fen> the point is we cant write f(x1,x2....xn) as n -> infinity
15:01:38 <fen> its so simple, why is it missing?
15:02:32 <fen> its similar to the problem of type L = (L -> L)
15:03:20 <fen> you want to define a collection of things just in terms of how the change the other things in the collection
15:03:30 <EvanR> you cant do what you want in haskell? or
15:03:40 <fen> so you need a function over all the things in the collection
15:04:02 <EvanR> try (Integer -> R) -> R
15:04:07 <fen> EvanR: apparently it was some form of lambda calculus
15:04:52 <fen> EvanR: thats just over one of the values
15:05:33 <EvanR> you can use the "lookup" function many times
15:05:50 <fen> thats basically the dyson series
15:06:13 <fen> its an infinite nesting of integrals (time ordered to prevent double counting)
15:06:18 <fen> but thats so convoluted!
15:06:56 <dyl> @remember monochrom Functional programmers had the wisdom to delegate the cache problem to hardware, the naming problem to mathematicians, and the off-by-one problem to recursion!
15:06:56 <lambdabot> Okay.
15:07:03 <dyl> Thanks love <3.
15:08:11 <fen> and it still needs a function of infinitly many arguments as the integrand 
15:08:49 <fen> so is of no help at all.
15:08:59 <fen> there is no literature on this
15:09:07 * Solonarv waves vaguely toward hilbert spaces
15:09:21 <fen> they are infinite dimensional but linear!
15:09:49 <fen> unitary opperators
15:09:50 <Solonarv> ∞-tuples form a hilbert space, you can totally do calculus in those
15:10:42 <fen> with matrix representations
15:11:07 <fen> we can factor matricies fine, but you try that with nonlinear functions
15:11:54 <fen> probably the only thing we can relate back to haskell from that is non-commuting opperators
15:12:30 <fen> and even matricies, linear opperators, are non-commutative
15:13:54 <fen> the closest math gets in nonlinear dictionary manifold learning 
15:14:22 <fen> c.f. eigenface interpolation
15:14:47 <mouse07410> monochrom: one alternative is to stop this hype pretending that formal proofs are something they either aren't ready to be or can't be at all. Use them, as it didn't hurt to have at least some components verified against at least some assumptions - but it does no good painting formal methods as the solution to all software rentability and security problems (as, e.g., seL4 was doing).
15:15:42 <monochrom> OK that's fair.
15:15:58 <monochrom> But really I haven't seen formal proofs hyped up for decades.
15:16:25 <monochrom> And no, when someone here brings up monad laws it is not a case of hyping up formal proofs.
15:17:31 <fen> formal proofs such as existence and uniqueness? or like proving bounds?
15:17:46 <monochrom> If anything, what I have seen for decades is hyping up agile and using it to argue against formal proofs. Like people actually need to.
15:18:28 <fen> what has agile got to do with proofs?
15:18:48 <monochrom> Anyone trying to teach formal proofs to students already know: Just look at the students' faces, you know they won't use it for real.
15:18:49 <fen> or do you mean formal methods? like linear logic?
15:19:34 <mouse07410> Three-four decades ago it was AI (and all the programs were supposed to be out of job by 1995 or so). Now it's formal methods - and no program is supposed to be "good" or "reliable" unless formally verified (and it seems to bother nobody that the assumptions that make the proof possible have little to do with reality).
15:19:46 <fen> yeah but advances in real proof are like really important
15:20:20 <monochrom> OK where did you see that hype? Because I could use a bit of reading that propaganda to make myself feel better!
15:20:23 <fen> oh your griping about coq agda and idris
15:20:25 <mouse07410> fen: no I am *not* taking about proving bounds.
15:21:01 <fen> there are some good proofs in universality!
15:21:22 <fen> but ok..
15:21:48 <monochrom> Because the propaganda I've been reading is "be agile" "don't prove" and even "don't even use static types".
15:21:59 <monochrom> I mean just look at Python propaganda.
15:22:03 <fen> yeah, but if you cant machine check your code for completness/ corner cases, then people just have to trust it based on heuristics 
15:22:11 <monochrom> Even PHP propaganda.
15:22:31 <monochrom> like "don't even learn how to design a programming language properly"
15:22:39 <wroathe> Agile is an idea that in theory should work out just fine (taking an iterative approach to design and implementation of software), but the current practice of agile in industry is almost universally a disaster
15:23:35 <fen> like "well everybody else uses cblas, its unbeatable, made by prodigious indevours lost in the fog of history, unreadable to modern humans, but of great perfection"
15:23:39 <dminuoso> "agile" is a buzzword that means different things to different people.
15:24:41 <wroathe> dminuoso: True, it's overloaded, but framed in the context of waterfall vs agile there's usually a common implication of being somehow more iterative than waterfall
15:25:05 <dminuoso> wroathe: or maybe faster.. or maybe less formalized.. or maybe having a flipper in the meeting room...
15:25:10 <dminuoso> wroathe: all three I've heared already.
15:25:24 <fen> and anything at all to do with proof assistants? 
15:25:42 <wroathe> dminuoso: Yeah. I've seen it all too. :( So many scars.
15:25:54 <wroathe> dminuoso: We should start a support group.
15:26:29 <dminuoso> wroathe: I was at a dockerconf last year. There were some really great talks there, but so much cargoculting - and tons of clueless followers singing the mantras.
15:26:42 <fen> its a slight improvement on random
15:27:04 <dminuoso> Between a technical rundown of "how docker works" (which was enlightening) and "cloud native apps" (with the cloud cheering at every mention of "cloud native") it was a bit weird.
15:27:06 <fen> they might even rederive how to be organised
15:27:27 <fen> "good meating today, we have decided we need a goal!"
15:27:29 <dminuoso> well crowd. but the crowd is a cloud.
15:27:53 <fen> very important concept, also, we need to work together on this goal!
15:28:07 <fen> #agile
15:28:46 <eqnom> hiya
15:29:15 <wroathe> dminuoso: Conferences can be absolutely horrifying
15:33:15 <mouse07410> monochrom: mostly in academic publications (which seemed to be spawn by the principle "publish or perish" :), and from uneducated customers that foolishly ask for "formal proofs" without any clue... As dminuoso puts it - a good example of cargo cult (don't confuse with Rust :)
15:34:10 <fen> genetic lambda calculus
15:36:24 <mouse07410> fen: I'm a bigger fan of simpler genetic concepts - like the Darwin law (and Darwin awards) 😈
15:52:00 <dminuoso> mouse07410: my point is not exactly formal proofs.
15:57:49 <mouse07410> dminuoso: understood. I think we're on the same page.
16:07:59 <ProofTechnique> dminuoso: The new Docker stuff for shrinking image size (I think it’s multi-stage builds) is really neat.
16:34:44 <bkl[m]> This is a bit off topic, but any recommendations for following Haskell people on fediverse?
16:43:30 <therik> hello, i'm following the "write yourself scheme" book and I'm getting Failed to load interface for ‘Monad’ error
16:44:09 <therik> and google is giving me 3 results, I haven't got much of a clue of what I'm doing, can somebody give me some pointers?
16:44:39 <Solonarv> therik: could you post the full error message? 
16:44:50 <Solonarv> (preferably using an external site, if it's long)
16:45:26 * ski suspects `import Monad' should be replaced by `import Control.Monad'
16:46:46 <therik> ski: thank you! 
16:47:36 <Solonarv> ski: you can't just accurately guess newbies' errors! that's illegal!
16:47:40 <Solonarv> :p
16:47:49 <ski> therik : hierarchical modules. weren't around when that tutorial was written. ask again, if you encounter another one you can't resolve
16:48:08 * ski grins
16:49:22 <therik> ski: gotcha, thanks a lot!
16:51:41 <Solonarv> somehow I keep forgetting how young hierarchical modules are
16:52:49 <hpc> only 20 years old!
16:53:16 <sheks[m]> they can't even drink yet :v
16:53:25 <Solonarv> they can in most countries!
16:54:20 <hpc> it's like that famous novel, i have no mouth and i must structure code
16:54:37 <hpc> it was about drinking the whole time!
17:04:55 <dmwit> Hierarchical modules crack me up.
17:05:00 <dmwit> They're not even hierarchical.
17:05:24 <blackdog>  just a whole sort of general mish-mash...
17:05:30 <hpc> it's hungarian notation
17:05:30 <dmwit> Literally the only change to the language itself was that . was added to the lexical syntax of module names, but it's not even given any meaning at all.
17:05:51 <eqnom> first impressions of haskell: wow, this is a lot faster than python
17:06:13 <Solonarv> that's not true: the source code for the module Foo.Bar can be in Foo.Bar.hs or Foo/Bar.hs
17:06:37 <hpc> import Control.Monad.tar.gz
17:06:45 <Solonarv> so the dot does have meaning! (admittedly, perhaps not in the language itself)
17:07:08 <geekosaur> ghc doesn't even obey the spec with qualified module names
17:07:18 <hpc> eqnom: :D
17:07:40 <Solonarv> geekosaur: how so?
17:08:43 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/bugs.html#lexical-syntax
17:09:36 <eqnom> its honestly really cool
17:09:45 <geekosaur> I think this is also why [False..True] is an error in ghc
17:10:16 <dmwit> False..True being an error is actually in the spec.
17:10:30 <geekosaur> huh
17:11:04 <dmwit> Solonarv: The mapping from module name to file on disk isn't part of the language at all. A different compiler could demand you store module sources in a SQL database if it wanted.
17:16:23 <ProofTechnique> That is kind of the Unison model
17:21:34 <ski> eqnom : .. any questions, so far ?
17:21:43 <eqnom> not yet :0
17:21:45 <eqnom> :)
17:22:04 <ski> i suppose you have a textbook, or at least a tutorial, to follow
17:22:13 <eqnom> just started on the learn you a haskell book
17:22:17 <eqnom> well
17:22:24 <eqnom> i say book, but i mean online guide
17:22:47 <eqnom> its just such a cool langauge
17:23:05 <ski> i think people here tend to say that LYAH isn't really that good of an introduction (e.g. lacks exercises)
17:23:14 <eqnom> i agree with that
17:23:23 <eqnom> as i am going through
17:23:30 <eqnom> ive been trying to find some exercises to do
17:23:37 <ski> (i remember it being likened to a multiple-hour long trailer)
17:23:40 <eqnom> and experiementing with the functions that it teaches as i go
17:23:41 <ski> you could try
17:23:45 <ski> @where CIS194
17:23:45 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
17:25:48 <eqnom> as im going right now, im actually really enjoying the LYAH guide
17:26:09 <eqnom> if only because i feel as though the material is presented in a way that isnt boring
17:28:20 <hpc> how far in are you?
17:28:59 <eqnom> not very if im being honest
17:29:10 <eqnom> just finished first section
17:31:25 <hpc> no spoilers then ;)
17:37:14 <drew1> Does anyone know of a way to run haskell-ide-engine with debug option inside neovim?
17:37:30 <drew1> for instance, have the plugin exec `hie -d -l mylog.log`??
17:43:36 <ProofTechnique> eqnom: Also check out the data61 fp-course on GitHub. It’s an interactive course
17:44:04 <shapr> I'm a big fan of fp-course
17:44:10 <shapr> I love watching the count of failing tests decrease
17:44:28 <shapr> and it has videos: https://www.youtube.com/playlist?list=PLly9WMAVMrayYo2c-1E_rIRwBXG_FbLBW
17:44:33 <ProofTechnique> The lens course is also illuminating
17:44:41 <eqnom> i'll check it out!
17:45:00 <shapr> eqnom: direct link - https://github.com/data61/fp-course
17:45:16 <shapr> some of those still blow my mind
17:47:47 <ski> @where Data61
17:47:47 <lambdabot> Data61 Functional Programming Course <https://github.com/data61/fp-course>,<https://qfpl.io/links/2017-october-fp-course/> by Tony Morris,Mark Hibberd
17:52:37 * hackage jord 0.6.0.0 - Geographical Position Calculations  https://hackage.haskell.org/package/jord-0.6.0.0 (CedricLiegeois)
17:54:54 <kark> any thoughts on how someone who already knows Scheme + ML should learn Haskell?
17:56:07 * hackage chell 0.5 - A simple and intuitive library for automated testing.  https://hackage.haskell.org/package/chell-0.5 (chris_martin)
17:57:07 * hackage chell-quickcheck 0.2.5.2, chell-hunit 0.3 (chris_martin): https://qbin.io/fee-vpn-x5d0
17:59:23 <ski> kark : perhaps you could take a look at the "gentle tutorial"
17:59:57 <ski> @where tutorial
17:59:57 <lambdabot> http://www.haskell.org/tutorial/
18:00:48 <ski> (it's a bit dated, perhaps, but should get you up to speed on the basics, hopefully)
18:01:08 <kark> ski: this looks perfect, thanks a bunch
18:01:35 <ski> you probably will want to follow up that with more, later
18:01:45 <ski> e.g. Typeclassopedia
18:02:38 <kark> i'm sure
18:17:58 <slack1256> I never thought I would say this, but exception are fun.
18:18:11 <slack1256> Specially when dealing with Async and withAsync.
18:20:37 * hackage snaplet-redis 0.1.6 - Redis support for Snap Framework  https://hackage.haskell.org/package/snaplet-redis-0.1.6 (DmitryDzhus)
18:38:03 <drew1> how can i add a stack.yaml to an existing repo/directory?
18:38:13 <drew1> without remaking the whole thing and using stack new?
18:38:27 <drew1> it's just a random assortment of haskell files for book exercises
18:38:42 <drew1> but i'd like them to use the GHC version that stack has, not my system ghc
18:43:34 <ProofTechnique> stack init?
18:45:10 <DigitalKiwi> kark: do the scheme in 48 hours
18:46:29 <DigitalKiwi> kark: there are at least 2 of them that are good https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours https://wespiser.com/writings/wyas/00_overview.html
18:49:25 <drew1> stack init wants a .cabal file
18:49:28 <drew1> which i dont have
18:49:52 <kadoban> drew1: How are you using the random assortment of files? Are they individual scripts?
18:56:48 <Solonarv> super simple solution: echo 'resolver: lts-X.Y' > stack.yaml
19:23:36 <ProofTechnique> You could also use that stack shebang thing
19:42:17 <Solonarv> oh, yeah - just add that to each of the scripts
19:42:27 <Solonarv> that also allows them to use different resolvers and dependencies
20:25:44 <iqubic> I love the Slate reviews for XMonad. Top Pro: Can be fully extended with Haskell. Top Con: Uses 700MB of Haskell deps. LOL.
20:25:58 <iqubic> People have a love hate relationship with haskell.
20:39:36 <glguy> Pro: Haskell; Con: Too much Haskell
20:44:44 <iqubic> Yeah.
20:45:07 <slack1256> Can you provide a link for such review?
20:45:51 <iqubic> https://www.slant.co/topics/1902/viewpoints/2/~best-tiling-window-managers-for-linux~xmonad
20:46:15 <glguy> Hi slack1256, I'm marking up the next great glirc pr :)
20:47:16 <slack1256> Niceee!, I am gonna check it out
21:05:12 <slack1256> Oh, I was searching Slate
21:11:55 <slack1256> Hahah my compatibility hack was not that smart lol
21:18:54 <utdemir> Hey. I want to measure how long a specific IO action took in milliseconds. So I am planning to do the obvious (start <- getNow; act; end <- getNow; return $ end - start) thing. Which `getNow` function should I use here to not get messed up with DST, leapseconds, system time changing or stuff like that? 
21:19:40 <utdemir> So I want 'monotonically increasing counter that ticks every millisecond'.
21:21:56 <dyl> What I do is open up the case and then directly watch the CPU registers with a magnifying class in one hand and a stopwatch in the other. 
21:22:21 <dyl> (I have no idea, sorry.) 
21:22:45 <lyxia> utdemir: look at how criterion does it
21:22:46 <MarcelineVQ> there's some choices of clocks here https://hackage.haskell.org/package/clock-0.7.2/docs/System-Clock.html not sure if there's a more reccomended lib tho
21:24:30 <MarcelineVQ> lyxia: does criterion getCurrentTime and diffUTCTime?
21:24:50 <MarcelineVQ> or just call out to C? :>
21:24:55 <utdemir> lyxia: Just checked criterion, turns out it does FFI to call 'clock_gettime(CLOCK_MONOTONIC, &ts);' function on POSIX systems.
21:29:33 <utdemir> MarcelineVQ: Probably I'll use 'clock' package, even though I don't understand how it works on Linux.
21:32:58 <MarcelineVQ> it also calls out to clock_gettime
22:22:34 <jle`> is there any difference between `| a -> b, a -> c` and `| a -> b c` fundeps?
22:31:37 <MarcelineVQ> doesn't seeeem like it
23:21:52 <jle`> MarcelineVQ: thanks :)
