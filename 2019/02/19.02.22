00:23:37 * hackage simple-cmd-args 0.1.0.1 - Simple command args parsing and execution  https://hackage.haskell.org/package/simple-cmd-args-0.1.0.1 (JensPetersen)
01:00:37 * hackage protocol-radius-test 0.1.0.0 - testsuit of protocol-radius haskell package  https://hackage.haskell.org/package/protocol-radius-test-0.1.0.0 (KeiHibino)
01:57:21 <merijn> What's the best way to handle fixed size blobs?
01:57:33 <merijn> ByteString + smart constructor?
02:02:57 <merijn> No one?
02:03:56 <Taneb> merijn: handling fixed size blobs is not something I do all that frequently I'm afraid
02:04:11 <Taneb> Bytestring and smart constructor doesn't sound unreasonable
02:04:43 <Ariakenom> Are ByteStrings always pinned?
02:04:45 <maerwald> I like go arrays for that, where the size is part of the type :>
02:06:39 <merijn> Sucks that no one has rolled like Storable.Vector Word8 with typed size
02:10:22 <Taneb> merijn: there's http://hackage.haskell.org/package/vector-sized
02:12:15 <merijn> Ah, that looks reasonably usable :)
02:15:45 <merijn> Somewhat relatedly, anyone know a good library implementing CRC32? cryptonite doesn't seem to have it in the hash functions
02:20:02 <AfC> Ariakenom: yes
02:20:34 <Ariakenom> ok thanks
02:21:09 <AfC> Ariakenom: if you want something that is on GHC's managed heap try "short bytestring" (it's in there somewhere)
02:21:45 <AfC> Only thing I'm aware of that uses it is *text-short* which is a really nice library.
02:22:10 <AfC> (we use that under our Rope type)
02:23:42 <AfC> c_wraith: I've been experimenting with Google Cloud Builder. Looks promising.
02:50:58 <Henson> does anyone know of a library or something that will let Haskell create and interact with C++ STL containers via foreign pointers?
02:51:21 <merijn> Henson: Interacting with STL code will be a PITA
02:51:31 <merijn> Henson: The problem is that C++ does not have a stable ABI
02:51:44 <merijn> So interacting template code is hell
02:51:45 <Henson> merijn: due to templating?
02:51:59 <merijn> Henson: Amongst other things
02:52:25 <merijn> Henson: Do you only want to interact with STL containers with a specific internal type?
02:52:30 <Henson> merijn: yeah, I didn't think of templating.  I tried creating a Haskell interface to Boost's ODE integration library, and it's pretty much impossible to make a generic solution.
02:53:12 <merijn> Henson: The sanest approach is generally to wrap the C++ bits with an 'extern "C"' API, and then use that
02:53:18 <Henson> merijn: yes.  I have a function from which I want to return an array of strings by reference, and doing this requires pointers to pointers to pointers, which is a huge pain.  Being able to interact with a vector<string> would be very convenient.
02:53:57 <Henson> merijn: that's what I've been using.  I'm successfully interacting with a C++ camera library via the "extern "C"" API
02:54:51 <merijn> Henson: Interacting with extern "C" code from Haskell is trivial, though
02:55:04 <merijn> Henson: So if that's an acceptable restriction you're fine
02:55:37 <Henson> merijn: yeah, that's what I've been doing so far.
02:55:57 <Henson> merijn: but in the future I'm going to have to pass more complex stuff to/from C++ to interface with other code I've written in C++.  If nobody has done an STL interface, then I'll probably need to do it myself, or face down a terrible array of pointers to pointers to pointers to pointers......
02:58:24 <Henson> merijn: it's hard to believe that C++, being more advanced and newer than C, is pretty much impossible to interface with other languages.
02:58:45 <Rembane> Didn't you just say why that is? :)
02:58:56 <Ariakenom> Was thinking the same :)
02:59:18 <Ariakenom> Also the way to do it is extern C though? So not exactly impossible.
02:59:28 <Henson> Rembane: yeah, but it's hard to believe that the creators of C++ didn't foresee this difficulty
02:59:46 <Henson> I'm just talking about C++ templating making things so much more difficult
03:00:10 <Rembane> Henson: That is true. Maybe nobody had FFI in mind when implementing templating for C++
03:00:19 <Henson> C++'s way of introducing abstraction via templating is to break any external language interaction
03:00:58 <Henson> well, not to break exactly, but to make it very difficult and non-generic
03:01:19 <veverak> wat
03:02:20 <veverak> Henson: I believe that problems with ffi for templates is quite logical given what it tries to achieve
03:03:07 <veverak> => i don't think this is error in design :)
03:05:46 <Henson> veverak: I would agree that the problems are logical and it's not an error in the design.  I suppose I'm just lamenting that the only way to interact with the nice abilities of C++ is through a C API, which precludes making direct use of the nice abilities of C++
03:06:04 <veverak> hmmm, one of the libraries does it right I think, you specify C++ thing in haskell
03:06:32 <veverak> and it generates C overlay over C++ thing and ffi interface to haskell as lib
03:06:43 <veverak> which seems as right approach to me
03:08:53 <Henson> veverak: can you tell me what the library is?
03:10:21 <veverak> fficxx
03:10:36 <veverak> but I hated it for some reason
03:10:46 <veverak> but the general idea is nice
03:12:45 <veverak> yeah
03:12:56 <veverak> they use C macros to generate the c overlay
03:13:03 <veverak> which pisses me off
03:14:41 <Henson> veverak: thanks for letting me know about the library
03:14:58 <veverak> Henson: the idea is good i believe
03:15:22 <veverak> http://khumba.net/projects/hoppy/
03:15:29 <veverak> this seems cool too
03:22:40 <merijn> Ariakenom: extern C can't really usefully be used with templated code
04:01:56 <merijn> Ugh, is there really no library with support for bit level (de)serialisation?
04:12:34 <amx> merijn: yeah I think when I had the need for one I just settled for Word8 and Bits
04:14:29 <merijn> I actually realised that a couple of libraries play together rather nicely: bitvec (has a Bit newtype which implements Unboxed Vectors with actual 1 bit storage), there's vector-sized which wraps Vector with fixed sizes (in the type) 
04:15:57 <merijn> So I can basically just concat a whole bunch of unboxed bit vectors together into a single vector representing the final result, then just convert that into (padded) Word vector, and go through Storable to get my data
04:16:58 <merijn> That just leaves the annoyance of building a bit vector for my values
04:19:53 <hpc> some kind of symmetric parser combinator would be ideal, where you could write do {length <- word16; debug <- bit; newlinemode <- bit; ...}
04:20:08 <hpc> and that would implement both parsing and printing
04:21:18 <merijn> I don't suppose we have numeric types with sizes less than 8 bits anywhere, I suppose?
04:21:41 <__monty__> Do you suppose or not, make up your mind!?
04:21:57 <merijn> Typing is hard while doing many things at once :p
04:22:12 <hpc> that's why i type with a telegraph thingy
04:22:20 <hpc> only one button to keep track of, much simpler
04:22:43 <Solonarv> hpc: someone in the Haskell discord is working on that, actually
04:23:08 <hpc> heh
04:23:17 <merijn> Because I need like 4bit words, and wrapping Word8 with a newtype seems annoying :p
04:25:19 <DigitalKiwi> how can a word be only 4 bits when even a single letter is 8 bytes?
04:25:40 <amx> http://hackage.haskell.org/package/binary-strict-0.4.8.3/docs/Data-Binary-Strict-BitGet.html    I used this btw
04:25:49 <amx> for some stuff, but not all
04:26:59 <amx> there is also BitPut
04:27:03 <merijn> amx: That looks rather unmaintained, though
04:27:33 <Solonarv> hpc: if you search for "bidirectional parser" you should find some examples of the general technique
04:28:08 <hpc> i already did that search once i realized what i was supposed to search for
04:28:11 <hpc> and my favorite is https://hackage.haskell.org/package/invertible-syntax
04:41:06 <steven1> good morning
04:47:06 <bwe> *** Exception: Prelude.read: no parse
04:47:32 <bwe> -> how can I let ghci tell me the location of the call?
04:48:37 <Solonarv> bwe: you probably just shouldn't be calling read at all if your program is big enough for that question to come up
04:49:26 <dminuoso> Solonarv: Or its not their fault because library authors use read.
04:49:39 <Solonarv> true, I hadn't thought of that
04:51:12 <bwe> Solonarv: Then, how would you transform a String into an Int?
04:51:19 <dminuoso> bwe: readMaybe if at all.
05:00:21 <bwe> dminuoso: Alright, how then, may I avoid to use readMaybe at all?
05:07:46 <dminuoso> bwe: Why do you want to avoid it?
05:08:07 * hackage show-prettyprint 0.2.3 - Robust prettyprinter for output of auto-generated Showinstances  https://hackage.haskell.org/package/show-prettyprint-0.2.3 (quchen)
05:15:16 <bwe> "readMaybe if at all." -- I understood the "if at all" part along those lines.
05:22:55 <merijn> How do I properly import a pattern synonym? I keep getting "not exported" despite it being in scope when using qualified notation
05:24:12 <Solonarv> turn on ExplicitNamespaces and list it as 'import Module (pattern Foo)' ?
05:24:34 <Solonarv> I haven't tried it but that *should* work
05:28:59 <dmwit> merijn: import Module (TypeName(PatternSynonym))
05:29:27 <dmwit> It's supposed to appear to the user as if it's any other constructor.
05:37:34 <merijn> dmwit: Tried that, didn't work
05:38:42 <[Leary]> Iirc that approach depends on the exporter having explicitly associated the pattern with the type (or perhaps it's automatic if the module has no export list).
05:44:03 <[Leary]> Testing on GHC863, with no import list you need to turn on PatternSynonyms in the importing module and use the import Module (pattern Foo) syntax.
05:44:12 <[Leary]> no export list*
05:44:24 <Solonarv> ExplicitNamespaces should be enough, no?
05:45:30 <[Leary]> Perhaps, but it's giving me a parse error on the import.
05:46:01 <dmwit> merijn: Huh, you and [Leary] are right, I have to explicitly modify the export list of the module with the pattern definition in it for that to work. That's awkward.
05:46:48 <dmwit> http://mpickering.github.io/posts/2015-12-12-pattern-synonyms-8.html discusses your options in the "Bundling Pattern Synonyms" section.
05:48:19 <zincy> What are functional dependencies?
05:54:05 <merijn> Given a FiniteBits instance is there an easy way to get a sequence of Bool from them?
05:54:37 <Taneb> > (1000 :: Word16) ^.. bits
05:54:39 <lambdabot>  [False,False,False,True,False,True,True,True,True,True,False,False,False,Fal...
05:54:50 <Taneb> merijn: how much do you like lens
05:54:59 <merijn> Taneb: Not much :p
05:55:54 <Taneb> :t \b -> [testBit b i | i <- [0..finiteBitSize i - 1]
05:55:55 <lambdabot> error:
05:55:55 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
05:55:58 <Taneb> :t \b -> [testBit b i | i <- [0..finiteBitSize i - 1]]
05:55:59 <lambdabot> error:
05:55:59 <lambdabot>     • Could not deduce (FiniteBits Expr)
05:55:59 <lambdabot>         arising from a use of ‘finiteBitSize’
05:56:07 <Taneb> :t \b -> [testBit b i | i <- [0..finiteBitSize b - 1]]
05:56:08 <lambdabot> FiniteBits a => a -> [Bool]
05:56:19 <Taneb> merijn: that's one way
05:58:52 <Chorhizo> Hey, if I'm checking a list is longer than length 5, does length always count every element of the list, or is there a way to get it to automatically short circuit past 5? For a really long list surely (length $ take 6 list) would be faster if this is the case?
05:59:46 <lyxia> you can also drop 5 elements and check the result is nil
06:00:19 <Chorhizo> lyxia: that's probably a better way to do it, cheers.
06:00:25 <lyxia> length does require to traverse the whole list to produce the length of type Int
06:00:34 <Chorhizo> Ah, I thought as much
06:00:41 <kritzefitz> Chorhizo, I think I once saw a library on hackage that does support this, but I don#t remember the name.
06:00:41 <lyxia> another approach might be to use genericLength with a peano-encoded number
06:01:08 <Chorhizo> I wasnt sure if the lazyness in haskell would work with an implementation of list that composes itself
06:01:34 <Chorhizo> aka length (list of length 3) = 1 + length (list of length 2) +...
06:02:23 <Chorhizo> but I guess I'd have to use tail recursion would make that more reasonable
06:07:02 <dmwit> That's not the problem.
06:07:08 <dmwit> The problem is that + isn't lazy.
06:07:19 <dmwit> ...ok
06:08:00 <kritzefitz> Chorhizo, I think Data.List.Extras.LazyLength from list-extras does what you want, if you're willing to accept the extra dependency-
06:11:50 <dmwit> They're gone.
06:12:49 <dmwit> Most likely they were gone by the time I started commenting, though the ping timeout didn't announce that fact until, well... until a few seconds before I said "...ok" =P .
06:13:00 <kritzefitz> Ah, I didn't see. Thanks for pointing it out.
06:55:42 <Athas> Anyone moved their Haskell project away from TravisCI yet?  What'd you recommend?
06:57:43 <_nate_> What is the normal way of turning `Maybe a` into whatever MonadFail or MonadPlus it occurs in?  Is there some predefined `guardMaybe` or something?
06:57:53 <[exa]> Athas: depends on what features of the CI you used most
06:58:48 <Solonarv> _nate_: 'asum'
06:59:03 <Solonarv> :t asum
06:59:04 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
06:59:17 <Athas> [exa]: mostly that someone has already written the utility script for installing Stack!  Beyond that, it has to be something that has enough memory and time budget to run GHC.
06:59:48 <Athas> For example, I see that sr.ht limits memory to 2GiB, which is a bit on the low side for compiling Haskell.
06:59:52 <_nate_> Solonarv: Sadly, I don't have a `Maybe (m a)`, just a `Maybe a`
07:00:24 <Solonarv> 'asum . fmap pure' works I guess ;)
07:00:33 <_nate_> That's what I was afraid of.
07:00:57 <_nate_> In other words, that doesn't have a nice name.
07:00:58 <Ariakenom> at that point maybe empty pure
07:01:43 <_nate_> Ariakenom: yeah, that's basically what I started with.
07:02:12 <_nate_> Guess it's what I'll end with!
07:03:06 <Ariakenom> A bit ambiguous where code begins in my msg there :)
07:03:17 <Ariakenom> have to know what I'm saying to know what I'm saying
07:03:27 <_nate_> Know what I'm sayin'?
07:04:15 <_nate_> Athas: As someone with a project on Travis that doesn't know why I would leave, is there a reason I should be leaving?
07:04:46 <Athas> _nate_: Travis got bought by some investment fund or whatnot, and have apparently fired half the workforce.
07:04:52 <_nate_> Ew
07:05:06 <Athas> So the value of the function has not changed yet, but the derivative sure has.
07:05:30 <[exa]> Athas: gitlab's CI isn't sufficient?
07:05:42 <_nate_> Indeed... I was already frustrated with their lack of support for more recent distros... bad signs
07:05:45 <Athas> Switching is not urgent, but I'd prefer to do the switch *before* it does become urgent.
07:05:54 <Athas> [exa]: I'm on GitHub.
07:06:07 <DigitalKiwi> people have mentioned Circle CI
07:06:53 <Athas> Yeah, I'm looking into Circle CI, and it seems decent.  I'm just waiting for someone to figure out the YAML gobbledydook to test with multiple stack.yaml's, like Travis supports with their poorly documented Build Matrix.
07:07:10 <Athas> I assume some Haskell hacker with more devops chops or motivation will figure it out at some point.
07:11:28 <__monty__> Athas: GHC isn't on travis afaik. I know they were looking at Circle CI recently because of the move away from phab.
07:13:15 <Athas> Aren't they using their own GitLab stuff?
07:13:31 <Athas> Anyway, GHC has much more complex needs than I (or most other pure Haskell applications) do.
07:14:54 <Athas> Of course, maybe I just just stop supporting more than one Stack snapshot at all.  This is really a relic of when I used Cabal and it was important to support multiple versions of GHC.
07:16:42 <glguy> Ll
07:24:36 <berndl> Is it possible to implement free functors in Haskell?
07:25:48 <Solonarv> yes, in fact there are several ways to do it
07:26:01 <Solonarv> (at least I think so; what do you mean by "free functor"?)
07:26:38 <berndl> Well, if I give you a function (Monoid a, Monoid b) => a -> b, can you give me the same function without the constraints?
07:26:44 <berndl> I can do it on a case-by-case basis.
07:27:29 <Solonarv> that's definitely not what I thought you meant
07:27:40 <berndl> But it would be nice if I had a functor that can do it for me in general.
07:27:51 <lyxia> I don't understand what that Monoid example means
07:27:57 <Solonarv> neither do I!
07:27:59 <berndl> OK, I fucked up.
07:28:06 <berndl> I meant "forgetful" functor.
07:28:52 <Solonarv> ah, that makes more sense
07:29:07 <berndl> Sorry about that.
07:29:45 <lyxia> If you have two monoids X and Y, and a morphism X -> Y, the forgetful functor just witnesses the fact that that morphism is also a regular function.
07:30:17 <berndl> Right.
07:30:21 <lyxia> If you really want to write it as a function in haskell it would be id :: (Monoid a, Monoid b) => (a -> b) -> (a -> b)
07:30:32 <berndl> No, that's not going to work.
07:30:43 <lyxia> but most of the time it's just not worth thinking of it as a proper Haskell function.
07:30:52 <lyxia> why is that not going to work
07:30:58 <Solonarv> I'm pretty sure those are fairly trivial in Haskell - we can freely forget additional structure, so making that explicit is rarely useful
07:31:58 <Solonarv> % data c *> a where Constr :: c => { forget :: a } -> c *> a
07:31:59 <yahb> Solonarv: 
07:32:43 <Solonarv> % let (sumIntMonoid :: Monoid (Sum Int) *> Sum Int) = Constr 5
07:32:44 <yahb> Solonarv: 
07:32:56 <Solonarv> % :t forget sumIntMonoid
07:32:56 <yahb> Solonarv: Sum Int
07:33:21 <berndl> lyxia: because the constraints are "carried" over to the result
07:33:55 <Solonarv> ah, but '(Monoid a, Monoid b) => a -> b' is not "(a -> b) with extra structure"
07:34:11 <berndl> What I want is something like forget :: ((Monoid a, Monoid b) => a -> b) -> (a -> b)
07:34:30 <Solonarv> it's "if you give me some extra structure (the '(Monoid a, Monoid b)' bit), I can give you an (a -> b)"
07:35:46 <lyxia> Note that ((Monoid a, Monoid b) => a -> b) is inhabited for a = Void, which is not a monoid.
07:36:00 <Solonarv> % let { monMap :: (Monoid a, Monoid b) => (Monoid a, Monoid b) *> (a -> b); monMap = Constr (const mempty) }
07:36:00 <yahb> Solonarv: 
07:36:08 <Solonarv> :t monMap @String @String
07:36:09 <lambdabot> error: parse error on input ‘@’
07:36:16 <Solonarv> % :t monMap @String @String
07:36:16 <yahb> Solonarv: (Monoid String, Monoid String) *> (String -> String)
07:36:21 <lyxia> the function I wrote can only be applied to monoids.
07:36:55 <lyxia> The fact that the constraints are "carried over" is not an issue.
07:37:18 <berndl> lyxia: It is an issue.
07:37:53 <Solonarv> berndl: '(Monoid a, Monoid b) => a -> b' does not contain a (Monoid a, Monoid b) structure
07:38:06 <Solonarv> instead, it *requires* such a structure
07:38:28 <berndl> Solonarv: Right. So maybe that's ultimately the problem.
07:38:54 <Solonarv> if you have some extra structure, you can freely throw it away (in Haskell, anyway) - but that's not the case here!
07:39:16 <berndl> Right. I would need to define monoids without type classes.
07:40:03 <Solonarv> "(a -> b) with an extra structure consisting of '(Monoid a, Monoid b)'" is '(Monoid a, Monoid b) *> (a -> b)'
07:40:28 <Solonarv> which you can also write as '(Dict (Monoid a, Monoid b), a -> b)'
07:40:42 <Solonarv> clearly you can throw away the "extra structure": just use 'snd' !
07:40:58 <berndl> The thing is, if I have a function that relies on mempty and mappend to do its thing, I can't really forget these functions in general.
07:41:32 <berndl> I would need to reimplement the function by replacing mempty and mappend with their underlying definitions.
07:41:50 <berndl> And I can do this on a case-by-case basis, but not in general.
07:46:13 <berndl> I figure that to implement forgetful functors, I would need the inlining facility available as a function.
07:46:54 <lyxia> I guess I disagree with whatever you think "forgetful" means. The structure is always there even if you "forget" it.
07:48:08 <berndl> lyxia: forgetful means that the constraints disappear.
07:48:53 <lyxia> I don't think we'll ever reach agreement so I'll wait to see what solution you find.
07:49:08 <berndl> I don't think there is one in Haskell.
08:03:37 * hackage collection-json 1.3.1.3 - Collection+JSON—Hypermedia Type Tools  https://hackage.haskell.org/package/collection-json-1.3.1.3 (alunduil)
08:04:37 * hackage network-uri-json 0.3.1.1 - FromJSON and ToJSON Instances for Network.URI  https://hackage.haskell.org/package/network-uri-json-0.3.1.1 (alunduil)
08:17:16 <dmwit> berndl: What are the source and target categories you claim this "forgetful functor" is operating on?
08:17:34 <dmwit> (I put "forgetful functor" in scare quotes because I think you don't have one except in the hand-waving modality.)
08:18:36 <dmwit> N.B. (Monoid a, Monoid b) => a -> b is *not* the type of an arrow in the category of monoids and monoid homomorphisms.
08:21:13 <berndl> dmwit: I agree, but it's the closest thing I have to it in Haskell.
08:21:19 <dmwit> No, it isn't.
08:21:26 <dmwit> There are closer things.
08:22:17 <dmwit> In particular, `data MH a b where MH :: (Monoid a, Monoid b) => (a -> b) -> MH a b` is pretty close; compared to a dependently-typed language, it misses only a proof of homomorphism.
08:23:19 <dmwit> And it is easy to write `forget :: MH a b -> a -> b`, namely, `forget (MH f) a = f a`.
08:23:24 <dmwit> Or even `forget (MH f) = f`.
08:23:39 <berndl> Let me try it and see what I get.
08:28:20 <dmwit> (Credit where it's due: Solonarv told you the exact same thing. You just didn't understand him, I think because he used nonstandard syntax.)
08:28:34 <berndl> dmwit: well, that doesn't forget the constraints though
08:28:42 <berndl> :t forget (Mon id)
08:28:43 <lambdabot> error: Variable not in scope: forget :: t0 -> t
08:28:43 <lambdabot> error:
08:28:43 <lambdabot>     • Data constructor not in scope: Mon :: (a0 -> a0) -> t0
08:28:47 <berndl> forget (Mon id) :: Monoid b => b -> b
08:29:25 <dmwit> It forgets the constraints. You just haven't supplied them yet.
08:29:43 <dmwit> You have to prove that `id` is a well-typed argument to `Mon` still.
08:30:03 <dmwit> In other words, that constraint isn't coming from `forget`, it's coming from `Mon id`.
08:30:20 <berndl> Right. But I don't want the constraint at all.
08:30:24 <dmwit> Too bad.
08:30:31 <dmwit> You get it even in boring old category theroy.
08:30:32 <berndl> I want it to say forget (Mon id) :: a -> a
08:31:10 <dmwit> Even in category theory, for `id_A` to be a suitable monoid homomorphism you must first prove that `A` is a monoid.
08:31:11 <berndl> No. In category theory with set-theory foundations, functions are just sets of pairs.
08:31:26 <dmwit> That's true. But monoid homomorphisms are not just sets of pairs.
08:31:47 <berndl> Sure.
08:32:07 <dmwit> In particular, monoid homomorphisms include a proof that their source and targets are monoids.
08:32:16 <dmwit> You haven't yet supplied that proof, so it can't yet be forgotten.
08:39:29 <berndl> dmwit: so basically it's polymorphism that is screwing me over.
08:41:13 <dmwit> Sure, at any monomorphic type `forget (Mon id)` will not have a `Monoid` constraint.
08:41:25 <berndl> Yep
08:42:13 <dmwit> I don't know that "screwing you over" is necessarily the right term.
08:42:29 <inkbottle> Example of simple text replacement using plain recursive descent parser? Spec. I want to replace /* blah */ by {- blah -}.
08:42:33 <dmwit> But surely you weren't expecting to be able to write `forget (Mon (\x -> mempty))` and get an arbitrary `a -> b`...?
08:43:10 <dmwit> inkbottle: I'd probably use regex-applicative.
08:43:10 <Ariakenom> is it a scoping issue? forall a b. (Monoid a => Monoid b => a -> b) -> (a-> b)
08:43:32 <dmwit> No, it is not a scoping issue.
08:43:35 <berndl> dmwit: not an arbitrary one, but one where the mempty is already replaced by its definition at the call site.
08:43:50 <inkbottle> dmwit: roger that
08:43:58 <dmwit> berndl: What is the type of `\x -> mempty`?
08:44:34 <berndl> Monoid b => a -> b
08:44:47 <dmwit> Do you agree that it can also be given type `(Monoid a, Monoid b) => a -> b`?
08:45:28 <berndl> No.
08:45:40 <dmwit> :t \x -> mempty :: (Monoid a, Monoid b) => a -> b
08:45:42 <lambdabot> (Monoid b, Monoid a) => p -> a -> b
08:45:59 <dmwit> Oh, lol.
08:46:06 <dmwit> :t (\x -> mempty) :: (Monoid a, Monoid b) => a -> b
08:46:07 <lambdabot> (Monoid b, Monoid a) => a -> b
08:46:18 <dmwit> berndl: Do you trust yourself enough to contradict GHC? =)
08:46:44 <berndl> Well, you can force it. But you can probably also force (Show a, Monoid b) too
08:47:06 <dmwit> Okay. So I have now written down `foo :: (Monoid a, Monoid b) => a -> b; foo _ = mempty`.
08:47:13 <dmwit> Now, what type do you expect `forget foo` to have?
08:47:30 <berndl> a -> b
08:47:38 <dmwit> Okay. Do you see why that would be a problem?
08:47:47 <dmwit> This says for any two types, it can convert from the first type to the second.
08:48:32 <dmwit> Like, it can convert Double to Tree String or whatever.
08:48:59 <EvanR> forall a b . a -> b  could be seen as ultimately powerful, or ultimately useless depending on your mood :)
08:49:06 <berndl> Hmm... that was too quick for me.
08:49:14 <berndl> I don't see where the conversion happens.
08:49:24 <Ariakenom> EvanR: ultimately impossible
08:49:31 <dmwit> If `x :: a -> b`, then `x 3.0 :: Tree String` typechecks.
08:49:50 <Ariakenom> ultimately immoral
08:50:03 <dmwit> :t let x :: a -> b; x = undefined {- we can't *really* have something of this type! we're just faking it for pedagogy -} in x (3.0 :: Double) :: Tree String
08:50:04 <lambdabot> Tree String
08:50:09 <EvanR> pretty sure unsafeCoerce is at the heart of some of these crazy libs
08:50:17 <EvanR> immoral yes
08:50:32 <dmwit> Rarely. Much more often it's a coerce from before coerce existed.
08:51:10 <berndl> dmwit: OK. I understand that, but I don't understand how forget is involved.
08:51:17 <dmwit> berndl: You don't see where the conversion happens because it can't happen. I'm trying to convince you that your starting axioms are in conflict.
08:52:35 <Taneb> berndl: if you can define forget the way you want to, you can get functions that shouldn't exist
08:52:37 <berndl> OK, so your saying that forget can give me a polymorphic function a -> b that I can use to convert any type to any other type, right?
08:52:46 <dmwit> Right.
08:53:17 <berndl> OK, that is problematic.
08:53:28 <dmwit> (And this is not just Haskell quibbling. forget doesn't have that type in category theory or set theory, *either*.)
08:55:18 <berndl> Related question: How can create a Category instance of Mon without getting screwed by the constraints?
09:14:07 * kiren[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/qqpqJsnLUIqWpsDaeXajpsRG >
09:16:25 <Solonarv> kiren[m]: please don't copy-paste large code blocks directly into IRC; use some external pastebin-like instead
09:16:41 <kiren[m]> sorry
09:17:21 <Solonarv> as to your question: what do you mean by " there is an infix on s' " ? that phrase doesnt even make sense
09:18:16 <kiren[m]> yes
09:21:06 <MarcelineVQ> Solonarv: but they did use a paste-bin like, does your client expand matrix links?
09:21:30 <Solonarv> it does not
09:22:05 <Solonarv> but matrix "automatically" converts messages above a certain threshold into paste-links
09:22:09 <MarcelineVQ> ah just a preventative line then?
09:22:31 <EvanR> matrix saved us this time
09:23:06 <MarcelineVQ> kiren[m]: ' is just a letter in this case, s' is a name just like x or foo or s''
09:23:51 <MarcelineVQ> infix uses ` (the ~ key) which isn't ' (the " key)
09:26:27 <EvanR> your milage may vary on where ` and ~ are
09:30:58 <kiren[m]> ty
09:32:49 <wroathe> What's the best way to go from a ReaderT r Identity a -> ReaderT r (Some Other Monad) a?
09:33:24 <wroathe> What's the best way to go from a ReaderT r Identity a -> ReaderT r (Some Other Monad) a?
09:33:46 <Solonarv> wroathe: 'hoist' from mmorph, at a guess
09:34:06 <Solonarv> actually scratch that
09:34:10 <wroathe> The use case is ToConfig a => (a -> Reader Options ConfigNode) -> a -> EnvReader Options ConfigNode ()
09:34:12 <Solonarv> % :t reader . runReader
09:34:13 <yahb> Solonarv: MonadReader r m => Reader r a -> m a
09:34:27 <Solonarv> (note: Reader r a = ReaderT r Identity a)
09:34:59 <wroathe> Ah, perfect. That's what I thought, but I was hoping there wasn't something that let me unify without explicitly calling runReader
09:35:25 <Solonarv> % :t hoist (pure . runIdentity)
09:35:25 <yahb> Solonarv: ; <interactive>:1:1: error: Variable not in scope: hoist :: (Identity a0 -> f0 a0) -> t
09:35:50 <Solonarv> % import Control.Monad.MMorph (hoist)
09:35:50 <yahb> Solonarv: ; <no location info>: error:; Could not find module `Control.Monad.MMorph'; Perhaps you meant; Control.Monad.Catch (from exceptions-0.10.0); Control.Monad.Co (from kan-extensions-5.1); Control.Monad.Cont (from mtl-2.2.2)
09:35:58 <Solonarv> aw, it's not there
09:36:11 <wroathe> I'll just do it this way. I'd rather not depend on another package.
09:37:19 <Solonarv> % :t mapReaderT (pure . runIdentity)
09:37:19 <yahb> Solonarv: Applicative n => ReaderT r Identity b -> ReaderT r n b
09:37:49 <Solonarv> ^ also works (and is more useful when the "input" has something more complicated than Identity)
09:39:06 <wroathe> Thanks
09:39:57 <Solonarv> most (all?) of the transformers in 'transformers' have an analogue to mapReaderT
09:42:40 <wroathe> Yeah, those map* functions are nifty
09:55:32 <dmwit> ?tell berndl instance (Monoid a, Monoid b) => Category (HM a b) where id = Mon id; HM a . HM b = HM (a . b) -- seems the most natural way to me
09:55:32 <lambdabot> Consider it noted.
10:02:43 <[Leary]> ````````````````````````````````````````````````````````````````````````````````````````````````````````````
10:07:48 <kritzefitz> exit
10:29:57 <elgoosy> hi, i have a problem evaluating the expressions with dante emacs. maybe someone knows what the issue might be https://pastebin.com/y4WwZpZH
10:31:46 <ProofTechnique> Dante resets the underlying GHCi session if there's a light breeze, so it's likely that it reset during a period when your program couldn't be loaded by GHCi (in the middle of typing an identifier, while it couldn't typecheck, etc.)
10:32:29 <ProofTechnique> Usually `M-x dante-restart` (or whatever the command is) helps
10:32:49 <ProofTechnique> Worst case, `M-x dante-destroy` and then `M-x dante-restart`
10:34:02 <Boarders> if I have a function in haskell with some subfunctions defined in a where clause and those functions compute some of the same stuff is that likely to be shared across the funtions or recomputed?
10:34:31 <Boarders> I would guess that haskell will inline where clauses and then share common computations but I'm unsure
10:34:38 <elgoosy> ProofTechnique, thanks. It is really weird. I eval those expressions first time and it's ok, but then the following evals on those same expressions throw those errors
10:35:40 <ProofTechnique> The easiest thing is probably to eval the function definition when you get an error like that. That should get it back into scope for evaluating the other expressions
10:35:58 <elgoosy> another thing i've noticed is the my undo tree does not well with haskell-mode + dante. Anyone has noticed that?
10:36:16 <elgoosy> *has had the same issue i meant
10:48:41 <Solonarv> Boarders: depends; if the computation is completely independent of function parameters I suspect it would usually get shared if large (inlining is much more likely to happen on "small" functions)
10:49:22 <Boarders> Solonarv: yeah, just to be sure I just refactored to make all computations I want shared visible to both subfunctions
10:50:15 <Solonarv> to ensure sharing you may sometimes need to rewrite 'f a b = expr' to 'f a = \b -> expr'
10:51:31 <Boarders> Solonarv: forgive the naivety but what is the difference between those two things?
10:51:44 <Solonarv> they have the same meaning, but will get inlined differently
10:51:58 <Boarders> oh ok
10:52:35 <Boarders> why is that, do you know?
10:52:39 <Solonarv> functions can only be inlined when they are given at least <arity> arguments; <arity> is simply how many arguments are written to the left of the =
10:52:48 <J_Arcane> Is there some method or language extension to allow for typing a function/value to a specific sub-type of an adt. ie. given `data Foo = A | B | C` could I somehow write a function that was specifically `F :: B -> a` or the like
10:53:24 <glguy> You can name the more specific type
10:53:24 <Boarders> I see, thanks for the info
10:53:43 <glguy> data Foo = A | B SomeB | C; data SomeB = .... ; f :: SomeB -> a
10:54:08 <Solonarv> you can also do trickery with GADTs, but that's probably not a good idea
10:54:32 <Solonarv> 'A' is not a subtype of 'Foo' any more than '2' is a subtype of 'Int'
10:55:27 <J_Arcane> Solonarv: I suppose that makes sense; I suspected I was using the wrong word there
10:56:15 <J_Arcane> And actually that insight makes me realize what I'm asking for is dependent types in a sense, as I'm basically asking the equivalent of "Can I type a function such that in `f :: a -> b`, a must = 2.
10:56:24 <J_Arcane> which of course is nonsense. 
10:57:40 <Solonarv> it's not quite nonsense, but not particularly useful
10:59:07 <Solonarv> it's more useful if the conditions are more complicated, e.g. 'f :: Int -> Int -> Int' but the first arg must be a prime
11:00:31 <Solonarv> you can actually encode this sort of thing using Liquid Haskell
11:11:08 <J_Arcane> Solonarv: yeah, I meant "nonsense" only in the sense of "Haskell doesn't really do that, it's what Idris is for", but I actually didn't know about LiquidHaskell
11:13:20 <c_wraith> liquid haskell adds refinement types with SMT solving to automatically derive lots of details
11:14:50 <sternmull> I am thinking about using Spock for a hobby project. But looking at the documentation of Web.Spock.Config it seems the documentation is very rudimentary. For example how i am supposed to use the database connection pooling? I can see something is prepared for that... but how to use it? And that is only one thing...
11:17:15 <EvanR> hobby project, database connection pooling, mmhmm :)
11:18:30 <sternmull> why not? I don't think pooling connections is such an advanced topic.
11:20:16 <sternmull> Also its just an example to describe the problem i have: There is a small tutorial and a few blog posts about Spock. The API documentation looks very sparse. So i wonder if someone could give an advise on how to get started efficiently.
11:20:25 <wroathe> sternmull: it's sort of cart-before-the-horse though, right? Shouldn't a single connection suffice to get you started building your hobby project :P?
11:20:39 <c_wraith> Spock just doesn't care whether you use a pool or not
11:20:49 <c_wraith> The way you interact with it is identical either way
11:20:58 <c_wraith> So why should it have tutorials for every case?
11:22:36 <sternmull> the point is that there is a PoolCfg in the API and its fields are undocumented. And i see other places that miss documentation too. So i wonder how others learn how to use it.
11:24:30 <Boarders> say I want to do something like
11:24:33 <Boarders> do
11:24:36 <Boarders> sorry
11:25:46 <Boarders> https://gist.github.com/Boarders/51edc782b4f2126303198cd615e4635a
11:26:01 <Boarders> I want to do something like this where the where clause has access to those variables scoped in the do block
11:26:06 <Boarders> does anyone know a good approach
11:27:02 <`O_O`glguy> Boarders: You can use a let in the do-notation instead
11:27:23 <Boarders> glguy: I really want to avoid it because the actual where block has loads of stuff in it
11:27:33 <Boarders> and it puts the main logic to the bottom of the code
11:27:49 <`O_O`glguy> OK, then you can pass the parameters through as function parameters
11:29:04 <Boarders>  glguy: what sort of thing do you mean?
11:29:30 <meinhof_> would you guys like to roast my first-ever fp project, which is unfortunately in scala? https://github.com/mehmetcc/gene-tonic
11:29:33 <glguy> candidateEdgesListWhere tgt1 tgt2 = ...
11:29:41 <glguy> and put that as a top-level definition or in the where
11:29:53 <Boarders> ok thanks
11:29:58 <Boarders> I think I'll have to go with the let bindings
11:30:02 <sm> thanks awfully meinhof_ but not really
11:30:12 <Boarders> because there is a bunch of shared data between different functions in the where clause
11:30:22 <sm> :-)
11:30:23 <meinhof_> sm: oh ok
11:30:31 <glguy> meinhof_: There's a separate channel for scala, fortunately
11:30:43 <meinhof_> glguy: yeah i know, but it seems pretty inactive
11:31:36 <dmwit> It's a tempting thought pattern, but in fact whether your question gets answered in another forum doesn't affect whether it's on-topic here.
11:32:51 <glguy> The correct take-away is to give up on learning Scala and switch to Haskell
11:33:18 <dmwit> =D
11:34:01 <meinhof_> glguy: i actually know some haskell, but the fact that scala runs on jvm opens so many doors so
11:34:10 <glguy> In that case you can use Eta
11:34:32 <meinhof_> glguy: i assume this is like haskell on jvm?
11:35:40 <meinhof_> but scala would always be better supported compared to haskell's jvm implementation, and you can actually find more resources when you are in trouble, it is like the case against Jython where several important bugs never get fixed and project dies out eventually
11:36:09 <glguy> Alright, #scala it is, then!
11:36:28 <EvanR> more support is good reason for using something else entirely i'm guessing
11:36:34 <EvanR> neither scala or haskell
11:36:45 <EvanR> kind of serious
11:37:10 <shapr> meinhof_: join us!
11:38:21 <shapr> Haskell is pure awesome
11:38:39 <meinhof_> shapr: i would like to learn more about haskell actually, last semester i was trying to read lyah but midterms started and i returned the book afterwards
11:38:50 <shapr> @where cis194
11:38:50 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
11:38:59 <meinhof_> and lack of proper ide support kinda ruins it if you are a starter
11:39:03 <meinhof_> and cabal
11:39:28 <amx> cabal is awesome
11:41:29 <Solonarv> not if you break your package db with excessive use of 'cabal install foo'
11:41:43 <c_wraith> very soon that won't break anything!
11:42:07 <c_wraith> v3 will default to v2- commands instead of v1-.
11:42:18 <c_wraith> ....  Yeah, that was a confusing sentence.
11:42:30 <c_wraith> cabal 3 will default to v2- commands.  there
11:42:58 <shapr> I'm excited about cabal 3
11:43:52 <amx> admittedly v1-* was kinda rough, to the point where I thought about throwing in the towel :)
11:44:50 <shapr> still better than no cabal
11:45:03 <shapr> compiling packages by hand that depended on other packages was way less fun
11:45:26 <Solonarv> oof yes that sounds terrible
11:45:34 <dmwit> Welcome to C land!
11:46:04 <shapr> dmwit: weren't you doing Haskell around ghc5?
11:46:16 <dmwit> How come we still haven't arrived at a world where configure can print out all the dependencies you need to install instead of just the first one it finds that you don't have yet?
11:46:28 <dmwit> cabal has been around longer than me
11:46:30 <shapr> oh ok
11:46:42 <shapr> I was in the room when SyntaxNinja came up with the idea
11:46:51 <dmwit> ha!
11:47:07 <shapr> he was like "we need pip for Haskell" and I was like "yeah!"
11:47:14 <shapr> and he said "Do you think people would use it?"
11:47:17 <shapr> I said YES PLZ NOW
11:47:44 <shapr> but I failed to convince the community to rename cabal packages to cabbages, and I'm still sad about that.
11:47:54 <dmwit> oh dear
11:47:58 <dmwit> That *is* a shame.
11:48:01 <shapr> I agree!
11:48:12 <shapr> anyway, Isaac got together a bunch of people and did a bunch of work
11:48:20 <shapr> and I think I just moved to another country
11:48:41 <shapr> he's running that new javascript validation company last I checked
11:48:45 <Solonarv> my cabbages!
11:48:50 <shapr> tozncy or something?
11:48:55 <shapr> Solonarv: ISN'T THAT A GREAT NAME?
11:49:00 * shapr slices cabbages
11:49:08 <Solonarv> it is!
11:49:44 <shapr> cabal-install could have been called salad-toss or something
11:50:43 <shapr> at least I convinced jlouis to rename his bittorrent client combinatorrent
11:51:18 <shapr> merijn: oh hey, did you do the thing? I want to see how you mixed Ethernet, IP, and UDP with cereal?
11:51:51 <shapr> dmwit: I don't think I've met in person you since hacphi
11:52:03 <shapr> I am sad about that.
11:52:04 <dmwit> Sounds right. It's been a while.
11:52:25 <shapr> I did get to see byorgey at this past ICFP !
11:53:19 <geekosaur> (v2-* should be called coleslaw instead of "nix style" >.> )
11:54:08 <shapr> whoaaa
11:55:36 <slack1256> Does anybody know of a matrix.org implementation on haskell? (probably on github but not on hackage)?
12:02:02 <merijn> shapr: It wasn't quite what I needed, so I'm in the process of rolling my own hacky network data structures :p
12:03:04 <shapr> aw ok
12:03:18 <shapr> merijn: did you get something working based on network-data?
12:03:58 <merijn> shapr: I wasn't quite happy with the level of control the headers gave me, especially since I needed fairly detailed control over the output frames
12:04:21 <merijn> shapr: But can't you simply call the cereal serialisation function and be done?
12:04:23 <shapr> but you sewed together all the pieces in such a way that you could parse ethernet, ip, udp from the same bytestring?
12:04:49 <merijn> shapr: I don't really care about parsing, tbh. I just need to *produce* frames
12:05:00 <Solonarv> slack1256: github search turned up only https://github.com/plapadoo/matrix-bot
12:05:05 <shapr> ah ok
12:05:33 <slack1256> Solonarv: Yeah, I found that one too
12:05:34 <Solonarv> that's on page 2, I'm too lazy to scroll further
12:05:53 <slack1256> Hahha, no probs
12:05:58 <slack1256> thank you
12:18:09 <sm> lol shapr I'm glad your vegetable naming scheme didn't happen
12:19:20 <hackeryarn> Vegetable naming scheme like sayan names?
12:19:31 <shapr> sm, aw why not?
12:19:41 <shapr> hackeryarn: I wanted to call cabal packages "cabbages"
12:19:54 <sm> there's such a thing as being too cute with names, we'd have looked silly
12:20:15 <sm> like homebrew!
12:20:18 <s00pcan> sm: what, you mean like testacular?
12:20:28 <shapr> wow, that's actually too silly
12:20:29 * sm picks on homebrew
12:20:33 <shapr> never thought I would say that in my life
12:21:07 * hackage zenhack-prelude 0.1.0.0 - @zenhack's personal custom prelude  https://hackage.haskell.org/package/zenhack-prelude-0.1.0.0 (isd)
12:22:16 <EvanR> is portmanteauing a semigroup?
12:22:59 <shapr> EvanR: wat?
12:23:10 <Solonarv> EvanR: yes!
12:23:23 <byorgey> yes, it's referred to as the semimanteau
12:23:53 <EvanR> hackage + package = hackage. package + hackage = package
12:24:43 <pie__> to come full circle, hackage + package is also package is also hackage also.
12:25:19 <Lycurgus> to actually be a semigroup every portmanteau would have to work like that
12:25:48 <EvanR> hmm. cabal + (haskell + package) = cabbage. (cabal + haskell) + package = ?
12:26:15 <EvanR> cabbage. works
12:26:38 <Solonarv> note: only associativity is required, commutativity is optional
12:27:21 <Lycurgus> since natural langs aren't logically formed it would always have to be a conjecture
12:27:39 <Solonarv> true
12:27:45 <EvanR> morally, when you do a portmanteau you forget the inside of the concatenation
12:27:46 <Solonarv> it certainly seems fairly semigroup-ish
12:27:49 <Lycurgus> except a counterexample in a given or whole lang is prolly pretty easy
12:27:57 <Lycurgus> not sure chinese even has em
12:28:08 <Lycurgus> prolly does though
12:28:22 <EvanR> just like you forget the inner types in a category arrow operation
12:28:35 <EvanR> semigroupoid i mean
12:29:16 <pie__> so, cabel and haskal
12:29:46 <pie__> dolan pls.
12:30:07 <EvanR> no
12:31:02 <pie__> unrelated, which thing can I get compiler feedback about my broken code in emas with
12:31:07 <pie__> *emacs
12:34:24 <pie__> <blink>tooling</blink>
12:34:49 <Solonarv> there's a handful of tools which do that
12:35:26 <Solonarv> off the top of my head: ghci, ghcid, dante, intero, haskell-ide-engine
12:35:53 <sm> run don't walk to ghcid!
12:36:10 * Solonarv is not an emacs user
12:36:16 <sm> and fiddle with the others at your leisure
12:36:59 <Solonarv> I've found the editor integrations to be somewhat spotty, so I'm just using ghci/ghcid/rebuilding manually
12:37:18 <sm> ghcid is my #4 haskell tool (after ghc, Cabal, stack)
12:37:21 <rhodeable> ghcid is really nice
12:37:36 <rhodeable> I hear good things about intero, but I haven't gotten it to work with spacemacs yet
12:38:03 <Solonarv> intero locks you into stack, unfortunately
12:38:13 <Solonarv> I head dante is basically the same thing but without the lock-in
12:39:47 <hackeryarn> I've been using hie with ALE for vim lately and it's been working pretty great
12:40:12 <rhodeable> interesting, I'll look into dante
12:40:56 <hackeryarn> hie=haskell-ide-engine it seems that they made a lot of progress lately. Great for editors that have LSP integration.
12:41:30 <hackeryarn> Works with emacs LSP support too
12:53:51 <dyl> Where did cabal get its name anyhow?
12:54:42 <Lycurgus> wasn't it an acronym?
12:55:01 <Lycurgus> common arch for building apps oder
12:55:49 <Lycurgus> building and linking perhaps
12:56:17 <Clint>     The Common Architecture for Building Applications and Libraries 
12:57:31 <EvanR> i guess common in the sense of lazy functional ecosystem, not common in the microsoft sense
12:59:39 <Lycurgus> generally though the decisive factor for choosing an acronym is word it will be conflated with
12:59:47 <Lycurgus> *is the
13:00:24 <Solonarv> surely it's a backronym, yea
13:00:30 <Solonarv> at least partly
13:16:18 <dyl> Also, is megaparsec still the in-vogue *parsec?
13:20:28 <sm> yup
13:20:54 <sm> for general needs
13:22:52 <_deepfire> there are two libraries that are better than megaparsec at something important:
13:22:59 <_deepfire> 1. attoparsec is faster
13:23:26 <_deepfire> 2. trifecta has tooling for very pretty error messages, and has them better by default
13:23:40 <Cale> Attoparsec also has symmetric choice
13:23:48 <dyl> Yeah, I'm familiar with all of them, just not sure what's in vogue right now.
13:23:52 <Cale> and thus no need for 'try'
13:24:00 <dyl> I'm just throwing together a toy prolog implementation, so anything should be good.
13:24:21 <sm> _deepfire: only slightly faster, apparently ? https://github.com/mrkkrp/megaparsec#performance
13:25:03 <_deepfire> interestingly, megaparsec has a different take on features on its README: https://github.com/mrkkrp/megaparsec#comparison-with-other-solutions
13:25:13 <sm> megaparsec 7 also improved support for pretty error messages
13:25:50 * _deepfire 's advice is out of date, apparently
13:26:00 <dyl> I could also play with Earley finally.
13:26:11 <dyl> Prolog's grammar is mercifully context-free :p..
13:35:16 <slack1256> I changed where I put the `makeLense ''MyAdt` declarations on my file, that somehow changes if the module compiles or not
13:35:22 <slack1256> Has anyone experienced this?
13:35:25 <geekosaur> recent versions of megaparsec have much nicer error messages
13:35:48 <geekosaur> slack1256, that's a TH splice; since TH is done while compiling, a splice can only "see" what precedes it
13:36:05 <geekosaur> unlike most of Haskell which is order independent
13:36:07 <slack1256> Ooh
13:36:31 <slack1256> That explains it
13:51:07 * hackage libarchive 0.2.1.0 - Haskell interface to libarchive  https://hackage.haskell.org/package/libarchive-0.2.1.0 (vmchale)
13:55:28 <JonReed> Hi, is there a bind operator or elegant trick in Haskell which has the following signature `m a -> (a -> b) -> m b`, so that I can chain an `f :: (a -> b)` into a monadic sequence like `m1 >>= m2 >>? f >>=`, where `>>?` is that magic operator. But it doesn't have to be an operator.
13:55:52 <shachaf> :t (<&>)
13:55:53 <lambdabot> Functor f => f a -> (a -> b) -> f b
13:57:11 <JonReed> shachaf: Thanks!
13:58:17 <pagnol> I'd like to dockerize a small cabal project, I found that one way is to use the 'haskell' docker image as a base and then run cabal update etc. ... the problem is that I live in alaska and have a veery slow connection, so running cabal update is hell
13:59:20 <zachk> how slow are the connections in alaska pagnol?
13:59:32 <pagnol> I live in the mountains, in a hut
13:59:50 <zachk> oh
13:59:53 <pagnol> you can count the bits as they travel through the wire
14:00:01 <pagnol> one, two...
14:00:02 <zachk> 300 baud ? ;) 
14:00:13 <koala_man> is it possible/simple to set up a local mirror?
14:00:30 <pagnol> hmm
14:03:29 <Solonarv> if you're able to successfully 'cabal update' once, you *should* be able to pack the resulting configuration into a docker image and use that as a base
14:12:57 <trcc> I have a HashMap a b and I need to go through each element and create an IntMap String. Is the best approach to convert the HashMap to a list and then map over it?
14:18:48 <zachk> for each element in the hashmap you want an IntMap , or you want to convert a hashmap to an intMap?
14:21:09 <JonReed> trcc: Perhaps `foldWithKey` the `Hashmap a b` into `IntMap String`?
14:21:45 <Lycurgus> e left
14:22:45 <zachk> if its one map to another I would just use the qualified A.fromList . B.toList 
14:27:34 <inkbottle> C comments to Haskell comments, can't imagine simpler, shorter, or more reliable, let alone useful: https://paste.debian.net/1069734/ (use w. emacs)
14:28:00 <inkbottle> however I find it too deterministic, and not intuitive enough to write
14:28:48 <inkbottle> I wish I could have considered */ more as a block
14:29:24 <inkbottle> like left delim, blah, blah, blah, right delim
14:29:29 <inkbottle> anyway
14:29:50 <Lycurgus> oh, didn see the join
14:30:05 <JonReed> Would GHC fuse `A.fromList . B.toList` together and remove the intermediate tuple and list representations, i.e. be equivalent to manually folding and using `insertWithKey`?
14:31:59 <pagnol> hmm my attempt to dockerize my app by using the haskell image as a base failed because  postgresql-libpq is missing
14:32:41 <pagnol> ah, it's based on plain debian
14:37:20 <dyl> Hmm.
14:37:47 <pagnol> dyl, what are you contemplating?
14:38:01 <dyl> I have an Earley parser `term` s.t. `many term` on "x y z" yields [Atom x, Atom y, Atom z], all good...
14:38:14 <dyl> But when I try to add comma separation with `(liftA2 (flip (:)) (many (term <* comma)) term)`
14:38:21 <shachaf> @pinky Are you contemplating what I'm contemplating?
14:38:21 <lambdabot> Well, I think so Brain, but what if we stick to the seat covers?
14:38:30 <dyl> Then I am instead getting "x , y , z" ⇒ [Atom z, Atom y, Atom x]
14:39:16 <dyl> Is there some rewrite rule coming into play here with respect to flip/many?
14:39:49 <dyl> Ah wait, never mind.
14:40:13 <dyl> Unrelated issue.
14:46:37 * hackage libarchive 0.2.1.1 - Haskell interface to libarchive  https://hackage.haskell.org/package/libarchive-0.2.1.1 (vmchale)
14:53:29 <JonReed> Is there some helper or neat trick that is similar to `maybe` or `either` functions but for monoids in general? If something is an identity element then use default `b`, but if something is not then map (`a -> b`) it
14:53:37 * hackage patience 0.2.1.1 - Patience diff and longest increasing subsequence  https://hackage.haskell.org/package/patience-0.2.1.1 (chessai)
14:56:55 <JonReed> I have a couple of `case a of; [ ] -> return []; c -> f c` that I want to make less verbose
14:58:25 <Solonarv> JonReed: foldMap? fold?
14:59:05 <Solonarv> traverse, perhaps?
15:06:55 <c_wraith> JonReed, you'll get better advice if you ask about a polymorohic type than about generalizing an implementation
15:07:03 <c_wraith> ... polymorphic
15:08:43 <koz_> c_wraith: I read that as 'polymoronic' and giggled.
15:09:45 <c_wraith> I'm just really bad at hitting the 'p' key on my phone. I usually depend on autocorrect to take care of it, but autocorrect isn't so good when I start talking about Haskell.
15:09:58 <koz_> c_wraith: Fair.
15:10:59 <delYsid> Why is it so hard to stack InterpreterT with InputT?
15:11:15 <delYsid> neither way appears to work.
15:11:43 <c_wraith> like.. Hint's InterpreterT?
15:11:49 <delYsid> yeah
15:12:47 <delYsid> one way it misses MonadMask and the other way round it misses MonadException
15:13:03 <delYsid> or I am mightily confused, which is likely.
15:13:54 <c_wraith> I don't even know where InputT comes from. haskelline?
15:14:14 <delYsid> yeah
15:15:20 <c_wraith> ah, OK. so haskeline defines its own MonadException type.
15:15:47 <c_wraith> just create an instance of it for InterpreterT
15:16:19 <c_wraith> it'll be orphan, but it'll work.
15:16:35 <delYsid> hmm, lemme look at that.
15:17:29 <c_wraith> oh, that's one of those "fun" ones to write.
15:17:56 <c_wraith> looks a bit easier than something like MonadBaseControl, but still tricky.
15:18:39 <c_wraith> wow, you might not really be able to write that.
15:18:55 <c_wraith> alternative plan: don't nest them. :)
15:19:44 <c_wraith> Run an interpreter in a second thread, and just ship commands back and forth between the threads. :)
15:20:20 <c_wraith> yes, it's a bit silly, but it's easier than getting those classes to play together.
15:30:50 <delYsid> Hmm, you would thinks these two types want to be stackable :-)
15:31:00 <JonReed> c_wraith: Yeah, I wrote down types and implementation of such function and understood why there isn't one. What I wanted to to map lists so that if its `case []` then return the default and if it's not empty then run a function over it, and generalize it to Monoid in general. So I hoped for something like `mapMonoid :: (Monoid m) => b -> (m -> b) -
15:31:00 <JonReed> > m -> b;` but when I started writing it I realized that I can't use case expression and have to use the guard. `mapMonoid _default f m | m == (mempty m) = _default | otherwise = f m`, which also needs `Eq` constraint and it seems like would do another thing internally than `case`, so it seems that generalizing it would have a performance detriment
15:31:00 <JonReed> .
15:31:02 <lambdabot>  <hint>:1:3: error: parse error on input ‘->’
15:31:31 <delYsid> c_wraith: Thanks for taking a look.
15:32:37 <JonReed> and this is why Haskell doesn't have this thing to begin with
15:33:20 <c_wraith> ah, I see what you were going for, now. yeah, that doesn't really work.
15:51:37 * hackage palette 0.3.0.2 - Utilities for choosing and creating color schemes.  https://hackage.haskell.org/package/palette-0.3.0.2 (BrentYorgey)
16:49:33 <inkbottle> I says here that ParserP is an instance of Alternative; however I can't find in the sources where <|> is defined as +++; or similar. https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Alternative
16:49:38 <inkbottle> it*
16:50:55 <inkbottle> Fount it, sorry
16:52:36 <int-e> inkbottle: where was "here"?
16:52:57 <inkbottle> the link, end of the line
16:53:11 <inkbottle> https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Alternative
16:54:50 <Solonarv> eh? there's no ParserP mentioned in that entire module
16:55:07 <int-e> yeah that is my confusion as well
16:55:46 <c_wraith> haddock will gather instances from the whole package
16:55:54 <inkbottle> sorry, ReadP
16:56:03 <inkbottle> my bad
16:56:18 <inkbottle> not ParserP but ReadP
16:56:25 <Solonarv> you can click the "Source" link next to the instance to see the definition of the instance
16:57:08 <int-e> inkbottle: Ah, maybe I should've made that leap. Sorry.
16:57:16 <Solonarv> and the sources themselves are hyperlinked, so in '(<|>) = (+++)' you can click on (+++) to jump to its definition
16:57:19 <inkbottle> yes, I did
16:57:46 <inkbottle> Hum, missed that so far, looking again
16:57:52 <c_wraith> so, haddock will list instances in the documentation for a module even if the instance is defined somewhere else in the package. :)
17:00:06 <inkbottle> Solonarv: at last I fount it, thanks
17:31:49 <ProofTechnique> Is there a way to specify ((->) r) in an explicit type application?
17:33:25 <ProofTechnique> someFunc @((->) r) doesn't work because r isn't in scope, and I'm not sure if there's a way to bring it into scope
17:33:45 <koz_> ProofTechnique: Are you using ScopedTypeVariables?
17:34:11 <ProofTechnique> I'm just messing around in GHCi, but no, I'm not using STV at the moment
17:34:31 <c_wraith> try @((->) _)
17:34:39 <koz_> ProofTechnique: For explicit type applications, ScopedTypeVariables becomes almost a necessity, unless all your applications are of 'type constants'.
17:34:49 <koz_> Or what c_wraith suggests I guess.
17:35:15 <koz_> (is 'type constant' even the right word to use?)
17:35:37 * hackage pandoc-citeproc-preamble 1.2.4 - Insert a preamble before pandoc-citeproc's bibliography  https://hackage.haskell.org/package/pandoc-citeproc-preamble-1.2.4 (spwhitton)
17:35:50 <ProofTechnique> Oh, perfect. Thanks, c_wraith. Also, koz_. :) Using TypeApplications with ScopedTypeVariables does seem quite necessary in serious cases
17:37:07 * hackage posix-api 0.2.1.0 - posix bindings  https://hackage.haskell.org/package/posix-api-0.2.1.0 (andrewthad)
17:37:24 <ProofTechnique> koz_: It seems like the phrase you're looking for is "concrete type"
17:38:05 <koz_> ProofTechnique: Thank you, I knew there was a better term.
17:38:22 <koz_> (I just couldn't remember it)
17:38:25 <koz_> (been away too long :P)
17:52:07 * hackage sockets 0.3.0.0 - High-level network sockets  https://hackage.haskell.org/package/sockets-0.3.0.0 (andrewthad)
17:56:12 * shapr tricks the eye
17:56:15 <shapr> hoi tromp
18:36:46 <Henson> I'm having some difficulty returning a CString from a foreign function.  I have a function in C++ that is declared in an 'extern "C"' block with the return type "const char *" with C++ string called "foo" on which I do "return foo.c_str()".  This should return the C-string equivalent of the "foo" string, and I should be able to use "peekCString" in Haskell to get a String.  But I'm running...
18:38:28 <Henson> into a problem where the value of the string, since it wasn't allocated using "new" is being overwritten.  It's correct when the C function exist, but incorrect after the "peekCString" call.  Am I doing this incorrectly?  Is it necessary to "malloc" a memory region for the string in the C function and then free it after calling "peekCString" in Haskell?  Is there some way of not using malloc?
18:38:35 <Henson> or am I missing something that is causing this problem?
18:40:09 <bob___> I want to add ints to a set from a list of ints, until I get a collision. Is there a haskell idiomatic way to do this without making a new function?
18:40:28 <koz_> bob___: Check the size before and after?
18:41:41 <bob___> I have a set, because I do not want to iterate through the whole list. Is there a way to shortcut execution? If I compare the resulting size afterwards, I believe that is an expensive operation. 
18:41:52 <koz_> The size of the _set_?
18:41:54 <koz_> It's O(1).
18:42:07 <bob___> Sorry, let me rephrase. 
18:43:49 <bob___> Effectively, I just want to check if there exist a collision in my original list of integers. Normally, this would involve just iterating through the list an adding to a set until a collision is found. However, if I turn the whole list into a set and compare the sizes afterwards, this would be more expensive.
18:44:19 <koz_> bob___: I assumed the 'iterate though list and add to set' is what you were doing.
18:46:58 <bob___> koz_: hmm, forgive me if I am misinterpreting something. If I do the first method [1,2,3,3,4,5,6,7,8] will stop after 3 steps, and "size (fromList xs) == length xs" will take 9 steps.
18:48:10 <koz_> bob___: For each number, you check the size of the set before the insert, and then after; if they match, you have a collision.
18:48:14 <sternmull> bob___: I don't know about a function that does exactly this. But wouldn't explicit recursion be good enough?
18:48:47 <koz_> sternmull: You don't even need one. A fold would do.
18:49:00 <sternmull> can a fold abort?
18:49:10 <koz_> sternmull: Good point.
18:49:10 <bob___> @koz_, wouldn't a fold have to iterate through the whole list?
18:49:10 <lambdabot> Unknown command, try @list
18:49:22 <koz_> bob___: Yeah it would.
18:50:21 <bob___> sternmull_: yea, I think a recursive solution would be god enough. I was just wondering if there was something available already like the ~takewhile, until, iterate sort of train of functions
18:50:26 <bob___> *good
18:50:27 <koz_> This is of some relevance to this: https://stackoverflow.com/questions/24226074/terminating-a-monadic-fold-early
18:51:43 <bob___> koz_ & sternmull: thanks for the advice. I think I'll just write an extra function for this. 
18:53:12 <Henson> a fold might work if it's a monadic fold in the Either monad.  That could break out as soon as it encounters a duplicate.
18:54:33 <Henson> I suspect a solution that would not require writing a new function would be more complicated to compose and understand that writing a new function
18:54:48 <bob___> yea, that sounds about right
18:55:20 <bob___> Could someone break down this syntax for me? I am a little puzzled "((([] :) .) . map . (:))" what does this function do?
18:55:52 <Lears> @unpl ((([] :) .) . map . (:))
18:55:52 <lambdabot> (\ x x0 -> [] : map (((:)) x) x0)
18:56:03 <Lears> That's not very helpful..
18:56:16 <sm[m]> is that from real code ?
18:56:30 <Henson> omg, my IRC client is putting smileys everywhere!
18:57:09 <bob___> It is from this inits = foldr ((([] :) .) . map . (:)) [[]]
18:57:39 <bob___> it has type t -> [[t]] -> [[t]]
18:58:11 <sm[m]> ((([] :) .) . map . (:)) 'a' ["bc","de"]  ->  ["","abc","ade"]
18:58:11 <bob___> I am confused on how the syntax works.
18:58:37 <Lears> :t \x xs -> [] : map (x:) xs
18:58:38 <lambdabot> a -> [[a]] -> [[a]]
18:58:42 <sm[m]> bob___: well you're not the only one.. but Tuple Sections is what it's using
18:58:43 <Lears> That's better.
18:59:22 <sm[m]> well no.. just "sections"
18:59:50 <bob___> is sections some syntatic sugar thing?
19:00:16 <sm[m]> https://wiki.haskell.org/Section_of_an_infix_operator
19:00:46 <sm[m]> (x:)  means prepend x to a list
19:01:56 <bob___> what does (:) mean?
19:02:25 <sternmull1> it is the name of the colon-operator
19:02:30 <Lears> > 0 : (1 : (2 : []))
19:02:32 <lambdabot>  [0,1,2]
19:02:36 <sm[m]> just the (:) function/operator, without even the one argument
19:02:52 <sm[m]> so it will take two arguments
19:04:04 <Lears> > (:) 0 ((:) 1 ((:) 2 []))
19:04:06 <lambdabot>  [0,1,2]
19:04:27 <Lears> Just using an infix operator as a regular function value.
19:05:56 <bob___> hmm how this composition of the map function with the (:) operator do this? (map . (:)) 2 [[1], [1,2,3]] == [[2,1],[2,1,2,3]]
19:06:20 <bob___> *how does the
19:06:35 <Lears> (map . (:)) 2 = map ((:) 2) = map (2:)
19:07:47 <bob___> oh whoah, let me process that for a moment
19:10:15 <bob___> hmm does this imply that if I map a function that takes two arguments, that (map . foo) bar = map (foo bar) ?
19:10:28 <Lears> @src (.)
19:10:28 <lambdabot> (f . g) x = f (g x)
19:10:34 <Lears> By definition of (.).
19:10:56 <bob___> OOOOH okay that makes so much more sense thank you
19:18:07 <bob___> ((([] :) .) . map . (:)), so in this what is (([] :) .)? why is that composition operator left by itself at the end?
19:19:22 <Lears> @unpl (([] :) .)
19:19:22 <lambdabot> (\ g x -> [] : g x)
19:20:31 <Lears> The . is used as another section, just like the :
19:26:13 <koz_> I'm trying to do a thing that sounds reasonable, but Haskell doesn't seem to agree. Given (Coercible a b, Unbox a), it _should_ follow that (Unbox b). However, I'm having great trouble writing something like this as per https://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector-Unboxed.html.
19:26:20 <koz_> Am I missing something in my reasoning?
19:31:55 <geekosaur> it "should" follow, but Coercible isn't actually implemented as a typeclass and it does some extra things like refusing to proceed if it can't prove a compatible type role
19:35:26 <Lears> % class Unbox a; type role Unbox representational
19:35:26 <yahb> Lears: ; <interactive>:47:16: error:; * Roles other than `nominal' for class parameters can lead to incoherence.; Use IncoherentInstances to allow this; bad role found; * while checking a role annotation for `Unbox'
19:35:33 <Lears> Woo, incoherence!
19:35:41 <koz_> geekosaur: I've made this start, but I'm already confusing GHC: https://gist.github.com/kozross/d2b989ee8ebbe5fbdd9fac0383533ae1
19:36:50 <geekosaur> yep, that's it, it's complaining about representations
19:36:52 <koz_> Do I also need to assure it that VGM.MVector VU.MVector a or something?
19:37:18 <koz_> I'm not sure I can even spell basicLength...
19:39:03 <geekosaur> hm, actually no, this is Coercible not being able to prove something, and that a0 is suspicious
19:39:09 <koz_> Can I even write basicLength, and if so, how?
19:39:23 <geekosaur> it's seeing two applications of possibly that, and can't prove the 'a is the same in both
19:39:33 <geekosaur> but I'm kinda out of my depth at that point
19:39:46 <koz_> geekosaur: OK, thanks for your help anyway. I'll see if someone materializes who can help.
19:40:29 <geekosaur> I don't even see where that function it's complaining about comes in, aside from a typeclss dictionary lookup
19:41:00 <koz_> VGM.MVector is a multi-parameter typeclass, so that would make sense.
19:41:23 <koz_> I could actually write that method I think.
19:41:31 <geekosaur> ...right, and there's no mention of 'a there, so it can't prove it's getting the same 'a
19:41:37 <geekosaur> hence a0
19:42:32 <koz_> Looks like I'm gonna need some TypeApplications to help that along.
19:45:52 <ym555> :t ((([] :) .) . map . (:))
19:45:53 <lambdabot> a -> [[a]] -> [[a]]
19:49:27 <koz_> geekosaur: Oh, I see. The a1,a2...a5 were for different typeclass methods.
19:49:35 <koz_> If I implement them all, it should deconfuse itself. I hope.
19:50:19 <geekosaur> only if it can tell they're all supposed to be the same thing. but this usually means it's using two values and can't constrain the unreferenced typeclass var
19:50:47 <koz_> Can't I hammer it into shape with TypeApplications somehow?
20:00:56 <koz_> Nope, that's not going very well, lol.
20:01:39 <geekosaur> koz_, I'm not sure you can because there's no "hooks". I think it has to somehow get to that internal MVector, btu there's no tyvar exposed there at the level of this typeclass
20:01:48 <geekosaur> so no way to apply TypeApplications to it
20:10:53 <koz_> Hmm, yeah. I'm gonna see if I can (ab)use Data.Vector.Unboxed.Deriving to do what I want.
20:11:18 <koz_> That... also doesn't seem to go too well, and I get a weird TH error.
20:11:56 <koz_> (something about an exact Name not being in scope)
20:19:45 <koz_> How can I ask a cabal new-build to -ddump-splices?
20:40:55 <libertyprime> Not sure why I ask here, but does anyone have a function they use to replace whitespace with escape-codes?, And ideally, consecutive whitespace with a run-length encoding variant of escape code. Ideally resulting in a string that is readable with backslash codes such as \n and \t
20:41:17 <libertyprime> Looking for an easy way to make one-liners out of anything
21:18:46 <bob___> hey does any use intereo for neovim? I'm having a little difficulty using it
21:24:09 <koz_> bob___: I use Neovim, and I _massively_ prefer ALE.
21:25:34 <bob___> hmm I'm using intero for the repl, but for the life of me, I cannot find how to navigate to the repl in vim / :help intero is showing not found
21:27:28 <libertyprime> bob___: have you done a :Helptags to update help?
21:29:01 <bob___> libertyprime: you are my saviour 
21:47:37 * hackage discord-haskell 0.8.1 - Write bots for Discord in Haskell  https://hackage.haskell.org/package/discord-haskell-0.8.1 (Aquarial)
21:53:46 <jle`> i wonder if there's a way to re-encode Either so that you can annotate anticipatory error messages for pattern match fails in do notation (MonadFail)
21:56:10 <jle`> Just x <- inCaseOfFail WasntJust (theAction :: Either X (Maybe Y))
22:31:57 <koz_> Hi jle`!
22:44:39 <jle`> koz_: hi! :)
23:16:18 <aeyxa> is .. considered an operator?
23:22:19 <glguy> > let (..) = (+) in 1 .. 3
23:22:21 <lambdabot>  <hint>:1:6: error: parse error on input ‘..’
23:22:24 <glguy> Nope
23:22:50 <glguy> It's part of the enumeration syntax: [1 .. 10]
23:23:02 <aeyxa> so it's an expression?
23:24:17 <glguy> On its own it's nothing
23:24:38 <glguy> Combined with [ and ] it's part of the syntax of expressions
23:24:48 <aeyxa> alright
23:37:40 <perfo> am I allowed to post links to questions to ask about them?
23:40:10 <koz_> perfo: Go ahead.
23:40:37 <perfo> https://www.reddit.com/r/haskell/comments/atsvp1/performance_sidon_set_generation/
23:40:54 <koz_> perfo: I just see [removed].
23:41:09 <perfo> oh riperoni
23:41:14 <aeyxa> I see it
23:41:28 <perfo> hmm can i pm on irc?
23:41:59 <aeyxa> could be his client that is removing it
23:42:05 <perfo> might be
23:42:22 <aeyxa> their client*... 
23:42:50 <aeyxa> ohhh he means inside the link, lol
23:42:56 <aeyxa> yeah it says [removed]
23:43:33 <aeyxa> https://i.imgur.com/vwu2sjc.png
23:44:05 <perfo> oh wow that's pretty savage. did I break some rules? hmm
23:46:05 <perfo> is the reddit a moderated community? Like your post must be approved first? It doesn't look deleted on my side hm
23:46:17 <perfo> r/haskell in particular
23:46:57 <glguy> I think it is
23:48:04 <glguy> So put your question on a paste bin so people can see it in the meantime (preferably not one covered in ads like pastebin.com)
23:48:15 <cads> I am looking at using aivika to simulate some basic markov chains, and I wonder if there is a simpler alternative. Aikika looks like a powerful and worthy investment, and it seems more popular than any other simulation package on hackage. Should I stick with it?
23:50:46 <perfo> here is my question: https://pastebin.com/r0HL3U85
23:50:53 <aeyxa> kik
23:50:55 <aeyxa> lol
23:51:05 <glguy> Disappoint
23:51:09 <aeyxa> https://pastebin.com/raw/r0HL3U85
23:52:04 <aeyxa> it's pretty easy to misread what you meant actually
23:52:26 <perfo> oh what did it appear like
23:52:38 <aeyxa> I was talking to glguy
23:52:46 <aeyxa> he was saying don't put it on pastebin
23:52:57 <aeyxa> though his message could sound like he was suggesting pastebin
23:53:21 <perfo> OH lmao i just reread that
23:53:23 <aeyxa> you would have to know that people don't like pastebin because of ads to know which direction he meant
23:54:19 <glguy> isCollision' is IntSet's fromList, recomputing list lengths sounds slow
23:55:14 <glguy> isCollision is just checking for duplicates?
23:55:17 <perfo> are you talking about the 'length xs' or the 'size (set)' part?
23:55:26 <perfo> yep it's just checking for duplicates
23:55:35 <perfo> i wanted to terminate execution earlier than just doing a fold
23:55:56 <glguy> Combine those to together so you actually get early termination
23:56:08 <perfo> combine what sorrt
23:56:10 <perfo> *sorry
23:56:15 <glguy> As soon as you see a number in the set already, return True
23:56:39 <perfo> OH lol that's a good point
23:56:45 <perfo> thanks for that
23:57:21 <perfo> I see that IntSet has O(min(n,W)) does that mean it's constant time lookup?
23:58:13 <glguy> Don't create all pairs filtering out the ones that are ordered by >, just generate the unique pairs directly like; [ | x:xs <- list, y <- xs ]
23:59:10 <glguy> That doesn't reuse a number with itself like yours so you might have to adapt according to the spec
