00:00:37 <cocreature> gentauro: should work just fine with aeson if you write your own FromJSON instance
00:00:45 <gentauro> I tried with some `maybe` fields, but the (generic) `json` parser just gives the `Main.hs: fromJSON: bad constructor encoding` :(
00:00:53 <cocreature> gentauro: you just can’t reuse the instance for lists
00:01:16 <gentauro> https://api.met.no/weatherapi/locationforecast/1.9/.json?lat=55.676098&lon=12.568337
00:01:34 <cocreature> you can use the instance for lists to decode to [Value] and then work from there
00:01:45 <gentauro> cocreature: good point
00:02:40 <gentauro> cocreature: once it's a `json value`, I could just filter the list to those elements that have all my desired fields
00:02:51 <gentauro> then I could convert it to my `record type`
00:02:54 <gentauro> I will give that a try
00:06:07 * hackage servant-pagination 2.2.1 - Type-safe pagination for Servant APIs  https://hackage.haskell.org/package/servant-pagination-2.2.1 (KtorZ)
00:09:07 * hackage servant-pagination 2.2.2 - Type-safe pagination for Servant APIs  https://hackage.haskell.org/package/servant-pagination-2.2.2 (KtorZ)
00:39:38 * hackage servant-ekg 0.3 - Helpers for using ekg with servant  https://hackage.haskell.org/package/servant-ekg-0.3 (phadej)
02:05:05 <Franciman> Hi, I'm writing a program for the terminal, is there a way to detect key presses of Ctrl, Alt ?
02:05:46 <Franciman> for example I'd like to detect when the user presses Ctrl+d 
02:09:01 <dminuoso> Franciman: Can you elaborate a bit more on what you want to do?
02:10:33 <Franciman> dminuoso, I want to write a small text editor
02:11:01 <Franciman> and I want to bind Alt-<char> and Ctrl-<char> to particular actions (like save, paste, copy)
02:11:37 <dminuoso> Franciman: Do you want to use the help of a library like `brick`?
02:11:45 <dminuoso> Or do you want to handle it all by yourself?
02:12:02 <Franciman> I'm fine with doing it all by myself
02:12:19 <Franciman> I wanted to use ansi-terminal for the User Interface (since it's going to be very simple)
02:13:11 <dminuoso> Franciman: If you want to catch those keyboard events you have to run the terminal in raw mode.
02:15:01 <Franciman> dminuoso, and can I run the terminal in raw mode from haskell?
02:15:08 <Franciman> I suppose it's OS dependent
02:16:15 <dminuoso> Franciman: GHC offers IODevice
02:18:06 <dminuoso> Franciman: Im not sure whether the needed instances are already supplied, but perhaps it might be a useful lead.
02:18:48 <dminuoso> Franciman: You could also just look how `brick` does it.
02:19:13 <Franciman> Thank you
02:19:32 <Franciman> Yes, I gave a look at how brick does, but I hoped in something easier, that maybe was less portable
02:20:27 <dminuoso> Franciman: It seems to delegate that responsibility to `vty`
02:21:43 <Franciman> yup, I saw how vty does
02:23:36 <Franciman> I'm going to use it, ok
02:23:39 <Franciman> thanks dminuoso 
03:24:13 <im0nde> Hi, I have been developing in more common programming languages like java, c, ruby etc. for a while and just watched a video on lamda calculus. Was more about the math behind it, but it mentioned funcional programming languages like haskell or lisp as a application of it. I find the idea very interesting and would like to learn a functional language to fully grok it. I realise there might be some bias in
03:24:15 <im0nde> this channel towards haskell, but should I go with haskell, lisp or something else as first funcional programming language?
03:24:53 <im0nde> Also, I don't want to count "hard to learn" as a downside. The main point is to get the concepts behind those languages and way of thinking and maybe become a better programmer overall
03:25:08 <locallycompact> definitely haskell 
03:25:35 <im0nde> locallycompact: could you explain what it has to offer over something like lisp?
03:25:37 * hackage PyF 0.7.3.0 - Quasiquotations for a python like interpolated string formater  https://hackage.haskell.org/package/PyF-0.7.3.0 (guibou)
03:25:49 <locallycompact> a solid type theory
03:26:29 <locallycompact> lisp is very simply typed, haskell's type system is much richer and has a wealth of research behind it
03:27:03 <locallycompact> and it means the compiler can help you figure out what you're doing
03:27:18 <locallycompact> once you are familiar with how it can do that
03:28:22 <locallycompact> a common trap is that beginners often fight with the type checker, but the right way to think about it is as an assistant that tells you "something of this shape goes here", or "that doesn't fit here"
03:28:57 <locallycompact> that's basically the big difference
03:29:00 <im0nde> I see, that seems definitly to be a plus. Another point what would be the most "pure" language from a funcional aspect? I suspect it would be wise to learn something that actually *forces* me to think in a functional way, rather than just allowing to do so
03:29:55 <im0nde> I read lisp e.g. can be (mis-)used to write in a non-functional way, I don't want to fall in this trap.
03:30:18 <tdammers> anything can be misused that way
03:30:27 <TMA> the downside is of course that the field is levelled -- simple things are hard, conversely next-to-impossible things are merely hard too
03:30:39 <tdammers> there's lots of imperative Haskell out there, and I've done a bit of object-oriented Haskell, even
03:31:10 <tdammers> but Haskell definitely does making it easier than most languages to maintain a pure functional programming style
03:31:20 <im0nde> I see.
03:31:35 <tdammers> and of course there's also the question of which definition of "functional programming" you subscribe to
03:32:18 <tdammers> from the Haskell point of view, most Lisps don't qualify as "functional" programming languages, and when lispers talk about "functional", they often don't mean the same thing as haskellers
03:32:32 <im0nde> tdammers: I don't know that much of it yet, I'm thinking "lamda-calculus" in a mathematical sense.
03:32:42 <im0nde> btw. the y-combinator blew my mind
03:33:11 <tdammers> right, so that's the "strong" definition of FP: programming with actual functions (pure, unary, pretty much the lambda calculus definition of a function)
03:33:23 <TMA> im0nde: do not forget to look into (common) lisp next. the notion that programs are just another data is not emphasized as much in haskell as it is in lisp; that's another insight that I personally find valuable
03:33:58 <tdammers> whereas the "weak" definition uses a "function" concept that is closer to the imperative "procedure", and focuses on more concrete aspects of functional programming, such as higher-order procedures, immutable data structures, and declarative programming
03:34:15 <tdammers> TMA: I'd say it's emphasized from a different angle.
03:34:33 <im0nde> TMA: I'm sure both languages have a lot to offer, it's more of a question of what to learn first.
03:34:49 <TMA> tdammers: sure. that's another way to put it. 
03:35:14 <tdammers> in the end, lots of core Haskell concepts clearly transcend the code/data duality
03:36:44 <im0nde> from what I hear, haskell seems to be what I want to learn first. I understand the basics of lamba calculus if I think about it, but I want to be "fluent" in this. (Don't know a better/more specific way to put it)
03:37:09 <tdammers> both are worth learning
03:37:47 <im0nde> tdammers: TMA I will look at both, but you have to start somewhere and I don't have the time to learn them both at once
03:38:57 <tdammers> matter of brain capacity more than time, methinks
03:39:27 <tdammers> you could try Write Yourself A Scheme, that one teaches you both by having you implement a Scheme interpreter in Haskell
03:39:30 <tdammers> @where scheme
03:39:30 <lambdabot> https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
03:40:25 <locallycompact> im0nde: I put together something of a compendium of haskell material that I've yet to finish. I only recommend it inso far as it has lots of useful links to other things in it, YMMV but if you're interested in the philosophy behind the type theory then the links in some of these sections may be interesting to you. https://locallycompact.gitlab.io/ANLGTH/
03:40:51 <locallycompact> it's a bit of a mess but also - it's supposed to be
03:42:35 <im0nde> tdammers: Thank you! That seems a really good a approach to get started indeed. I will try to go throught that
03:42:47 <im0nde> locallycompact: thank you too, looking at it!
03:50:41 <tdammers> no guarantees given, it seems to work well for some people and not at all for others
03:50:47 <tdammers> but I get the impression that it might work for you
04:18:12 <ski> im0nde : some people like SICP. it uses Scheme (a Lisp dialect)
04:18:18 <ski> @where SICP
04:18:18 <lambdabot> "Structure and Interpretation of Computer Programs" <http://mitpress.mit.edu/sicp/>,<http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/>,<https://github.com/sarabander/sicp-pdf> | "
04:18:18 <lambdabot> Storage and Identification of Cabalized Packages" <http://www.vex.net/~trebla/haskell/sicp.xhtml>
04:18:37 <ski> (the last link is something else)
04:19:20 <tdammers> .oO(Structure and Identification of Computer Packages)
04:19:58 <hpc> Something I Can't Pronounce
04:23:02 <c50a326> howcome `stack init` doesn't make a package.yaml ?
04:23:27 <hpc> package.yaml is unrelated, and probably shouldn't be used
04:23:54 <hpc> it crosses the abstraction boundary between your package definition and the specific build environment you're using to compile it
04:25:41 <hpc> it's part of hpack
04:31:42 <tdammers> stack init does/did generate package.yaml though, at least some versions of the default template
04:55:50 <kuribas> can the type "[token] -> [(a, [token])]" be constructed as a monad transformer stack?
04:56:07 <kuribas> [token] is like state, but it is inside the list, not outside.
04:56:20 <lyxia> @unmtl StateT [token] [] a
04:56:20 <lambdabot> [token] -> [] (a, [token])
04:57:01 <kuribas> yeah, that looks like it!
04:57:19 <dminuoso> kuribas: Remember that [] is a monad modelling non-determinism. :)
04:57:37 <kuribas> dminuoso: I do :)
04:58:31 <kuribas> ListT is not a proper monad right?
04:58:43 <kuribas> But here it works because it's List, not ListT?
04:58:45 <Cale> btw, I'm curious, has anyone else ever put a monad like TardisT or the reverse-state monad to practical use?
04:58:57 <dminuoso> kuribas: That depends on which ListT you use.
04:59:00 <Cale> I ran into an actual practical use the other day
04:59:37 <dminuoso> kuribas: You can implement ListT correctly (such that it produces monads when applied to monads) though.
05:00:19 <Cale> ListT from mtl will give you a monad so long as the monad you give it is commutative, otherwise, it doesn't
05:01:08 <dminuoso> I know of LogicT from logict which is a valid ListT (but with church encoding)
05:02:03 <kuribas> what's symlink-bindir?
05:04:47 <lyxia> There's also a ListT in pipes, and you can get pretty much the same expressiveness with Codensity and for.
05:05:31 * ski . o O ( ListT In Pieces )
05:07:39 <Cale> The thing I realised the time machine monad is good for is in FRP-monads in the style of reflex-dom, though in this case it was for a terminal graphics library a coworker and I have been working on
05:08:57 <Cale> We wanted a monad transformer where you could make "tile" widgets that would lay themselves out consuming portions of the screen, and more to the point here, would exchange messages about who had keyboard focus
05:09:13 <hpc> oh nice
05:09:35 <Cale> So, when the user presses, say, Tab, we want to send an Event firing to the next widget, and if they press Shift-Tab, the previous
05:10:01 <Cale> So, a forwards-and-backwards-in-time state monad transformer is perfect for that.
05:11:56 <Cale> of course, it's weird to say "time" since it's more like "position" in this context
05:12:26 <hpc> forward and backwards in syntactic order
05:12:37 <Cale> yes :)
05:12:40 <hpc> it's like writing a bit let-in block, except do
05:12:43 <hpc> and each line is a definition :D
05:15:01 <hpc> i once wrote an image manipulation library that ran backwards, then forwards
05:15:09 <Cale> right
05:15:17 <hpc> it ran backwards to find the earliest intermediate state it hadn't computed, then ran forwards from there
05:15:25 <Cale> well, normal reflex with rec is like that
05:15:29 <hpc> not quite TardisT, but fairly similar
05:15:44 <Cale> but this is weirder than a big let block because the definitions are aware of which order they're in
05:15:56 <Cale> and it makes a difference :D
05:17:03 <hpc> i have some frontend work coming up soon on my side project i can probably use this idea for
05:17:07 <Cale> haha, let's add next and previous keywords to the syntax of let, which let you refer to the next and previous thing defined
05:17:22 <hpc> lol
05:17:24 <unyu> Out of curiosity, guys, when you are navigating the sea of abstractions, can you actually see the sequence of states in your computations?
05:17:52 <Cale> It depends on what you mean by that
05:17:54 <unyu> Or how else do you reason about computational complexity?
05:18:03 <kuribas> unyu: I don't think about sequences of states
05:18:15 <kuribas> unyu: I think about transformations of data
05:18:24 <Cale> In cases where that makes sense at all, the notion of what a state is changes according to the context, so that it's always manageable
05:19:12 <kuribas> unyu: computational complexity is the same as in other languages, with the caveat of lazyness.
05:29:51 <ski> hm, iirc Jerzy Karczmarczuk used reverse state monad in the paper "Lazy Time Reversal, and Automatic Differentiation" in 2001(?) at <https://web.archive.org/web/20091014113209/http://users.info.unicaen.fr/~karczma/arpap/>
05:32:10 <Cale> ah, nice!
05:36:54 <Cale> waaaait
05:37:08 <Cale> I'm not sure this counts as an application, he doesn't actually end up using the monad itself
05:37:49 <Cale> (but the things he defines are rather similar)
05:38:22 <ski> (could be. long time since i read the paper)
05:39:11 <Cale> Still pretty neat paper
06:05:39 <kuribas> Hehe, which other language lets you write a parser in two lines of code?
06:05:50 <phadej> perl6
06:06:07 <kuribas> phadej: by having a parser builtin?
06:06:17 <kuribas> that's cheating
06:06:50 * ski notes many Prolog systems have DCG
06:07:59 <kuribas> right, prolog does backtracking search, so parsing would be elegant there as well
06:08:13 <phadej> kuribas: I'm actually not sure, https://docs.perl6.org/routine/parse whether `grammar` is built-in or comes from a library
06:08:56 <kuribas> Of course you could argue that Monad + Applicative + Alternative + Transformer Stacks are also builtin into haskell..
06:09:43 <kuribas> But I'd say they are much more general than any prewritten parser library.
06:11:09 <Solonarv> Haskell even has a parser combinator library in base
06:11:12 <Solonarv> Text.ReadP
06:11:14 <phadej> kuribas: `StateT String [] a` is not so good parser though. It works, but it's not good
06:11:19 <Solonarv> (or something like that)
06:11:42 <Solonarv> ah - Text.ParserCombinators.ReadP
06:12:49 <merijn> Solonarv: That one is shit, though :)
06:13:03 <akersof> hi all, is haskell for the front end (browser side dev) a good alternative? or should i check on the side of elm or purescript instead?
06:13:08 <Solonarv> less shit than StateT String [] a though, I hope
06:13:26 <akersof> i want to invest time on it, just want to be sure that i am not on the wrong way
06:13:35 <merijn> Solonarv: I'm not so sure, one or both of the parser combinators in base have super weird/confusing Alternative instances
06:14:19 <tdammers> akersof: in principle, yes, but there are a few caveats. one of them is that nix is practically mandatory, because managing a working toolchain and library setup for ghcjs is a soul-sucking experience.
06:15:20 <tdammers> akersof: another caveat is that integrating with the existing JS ecosystem isn't straightforward; writing purescript bindings is significantly easier than ghcjs bindings, and due to the way Haskell expects a runtime to be present, ghcjs output is more intrusive than a compiled Elm or Purescript module
06:15:58 <akersof> ok, so it is probably "better" to use dedicated tools for this
06:16:07 <tdammers> it depends
06:16:21 <tdammers> if you ask the lumiguide folks, they're very very happy with their full-stack haskell setup
06:16:54 <tdammers> and from my own experience, it's not like the alternatives don't make you jump through considerable hoops either
06:17:06 <tdammers> I'd give all 3 a spin
06:17:09 <akersof> ok :)
06:17:17 <akersof> yeah i tried elm and purescript already 
06:17:21 <phadej> tdammers: hvr's ghcjs ppa is quite simple setup
06:17:25 <akersof> well elm really easy
06:17:40 <phadej> tdammers: given ghcjs-base is on hackage too
06:17:54 <phadej> tdammers: but yeah, it's not "press a button" like experience
06:17:55 <tdammers> phadej: ghcjs itself is doable, but IME insisting on the normal cabal workflow tends to end in tears. things could be better now though, it's been a while since I last tried
06:17:56 <akersof> purescript i found a bunch of outdated docs, but the language looks like haskellish, better than elm
06:18:18 <tdammers> akersof: yes, if you love haskell, you'll probably like purescript better than elm
06:18:28 <phadej> tdammers: normal cabal workflow works (at least I use it to make servant-client-ghcjs)
06:19:07 <tdammers> phadej: maybe I should give it another try some time. I keep hearing people say that nix is essentially mandatory though.
06:19:26 <akersof> tdammers: yes i love it, but still new in it. Just want to try a full stack haskell app for fun
06:19:54 <tdammers> by all means do give ghcjs a spin then
06:19:59 <akersof> so with ghcjs you code in haskell and it is "compiled" in javascript ?
06:20:16 <akersof> and i suppose you an works well with the dom and other kind of stuff, from haskell ?
06:22:20 <Solonarv> that's the idea!
06:22:53 <tdammers> yes
06:23:09 <tdammers> well, the DOM part is something that needs to be supplied by libraries, via FFI bindings
06:23:42 <tdammers> although the same goes for purescript, the mechanism is exactly the same
06:25:07 <akersof> FFI bindings to javascript dom related functions you mean ?
06:29:19 <Solonarv> precisely
06:30:01 <paolino> reflex-platform works out good if you are fluent in haskell (a bit slow to compile and run)  
06:31:42 <Cale> If you need any help getting set up with reflex-platform and obelisk, let me know and/or join #reflex-frp
06:34:15 <Cale> (obelisk is our newer tool for managing reflex-dom-based projects, giving you a basic skeleton with a frontend, backend, and common code shared between them, and an 'ob' commandline tool which does a bunch of useful stuff like running your app's frontend and backend in GHCi, reloading whenever there are changes, and letting you know about errors and warnings
06:34:18 <Cale> )
06:35:35 <kuribas> phadej: it works just fine for my problem (a simple backtracking pattern matcher)
06:35:58 <kuribas> phadej: also, it's StateT [Text] [] a
06:36:28 <akersof> Cale: i am checking the website and github, it looks amazing
06:38:58 <phadej> kuribas: yes, but it's ~as simple to use parsec or regex-applicative
06:41:34 <kuribas> phadej: I don't think they are the same
06:41:48 <kuribas> phadej: with respect to backtracking
06:42:52 <phadej> kuribas: regex-applicative "backtracks" automatically
06:43:46 <phadej> kuribas: importantly it works for `many (many p)`  like patterns
06:44:12 <kuribas> phadej: yeah, that would blow up
06:45:24 <kuribas> regex-applicative looks interesting
06:47:17 <kuribas> by the StateT approach just as well, if you don't do anything stupid.
07:03:07 * hackage recursion 2.2.3.0 - A recursion schemes library for GHC.  https://hackage.haskell.org/package/recursion-2.2.3.0 (vmchale)
07:24:37 * hackage nix-diff 1.0.7 - Explain why two Nix derivations differ  https://hackage.haskell.org/package/nix-diff-1.0.7 (GabrielGonzalez)
08:30:53 <comerijn> @quote beaky monoids
08:30:54 <lambdabot> beaky says: i love monoids / they are so easy
08:32:19 * comerijn sets the counter to "It's been 0 days since the last time a complicated problem boiled down to combining monoids"
08:33:30 <dminuoso> comerijn: combining monoids?
08:33:40 <dminuoso> Interesting, how do you combine monoids?
08:33:51 <comerijn> dminuoso: tuples, nesting, etc.
08:33:52 <dminuoso> As in constructing rings?
08:33:59 <dminuoso> Oh.
08:34:11 <dminuoso> Nevermind, I thoght you meant something else.
08:36:48 <comerijn> I recall there was a package that had a monoid for Max/Min by extending with infinity. Anyone remember what that was?
08:37:31 <dmwit> comerijn: monoid-extras
08:37:45 <dmwit> http://hackage.haskell.org/package/monoid-extras-0.5/docs/Data-Monoid-Inf.html
08:38:04 <comerijn> dmwit: Cheers
08:39:55 <wraithm> Just out of curiosity, has anybody ever worked on "Kind Classes"? As in, type classes at the type level.
08:41:31 <wraithm> (morbid curiosity)
08:43:02 <dminuoso> wraithm: TypeInType? :)
08:43:23 <dminuoso> % :set -XTypeInType
08:43:23 <yahb> dminuoso: 
08:44:58 <dminuoso> % :set FlexibleInstances
08:44:59 <yahb> dminuoso: Some flags have not been recognized: FlexibleInstances
08:45:02 <dminuoso> % :set -XFlexibleInstances
08:45:03 <yahb> dminuoso: 
08:45:12 <dminuoso> % class Foo
08:45:12 <yahb> dminuoso: 
08:45:16 <dminuoso> % instance Foo Type
08:45:16 <yahb> dminuoso: ; <interactive>:49:10: error:; * Expected kind `Type -> Constraint', but `Foo' has kind `Constraint'; * In the instance declaration for `Foo Type'
08:45:26 <dminuoso> % class Foo a
08:45:26 <yahb> dminuoso: 
08:45:28 <dminuoso> % instance Foo Type
08:45:28 <yahb> dminuoso: 
08:45:43 <dminuoso> Now I have no idea how to even utilize this.
08:45:45 <comerijn> dminuoso: Basically I had a complex thing where I had to traverse a list and transform one value and determine the first index where a condition was true, preferably without too complications. It was kinda messy and then I realised I could replace the entire thing with a function "Element -> (First Int, Endo [ListEntry])" and "foldMap" to build the newlist DList style and find the index I wanted :)
08:45:49 <Solonarv> the real question is whether you can do anything interesting with those
08:46:25 <dminuoso> Solonarv: Im thinking you could do interesting things with open type families.
08:48:23 <comerijn> I don't suppose anyone knows a nice way to take "[Either a b]" to "[Either [a] [b]]"? (i.e. I wanna concatenate adjacent lefts and rights together
08:50:00 <dminuoso> comerijn: What is the outer list supposed to be for?
08:50:08 <vaibhavsagar> comerijn: sounds like a job for `These`
08:50:14 <locallycompact> hmm, don't you mean [Either a b] -> ([a],[b])  ?
08:50:25 <comerijn> locallycompact: No, I need them in place
08:50:33 <locallycompact> oh I see
08:50:39 <comerijn> locallycompact: With that one I lose which lefts precede which rights
08:51:06 <comerijn> dminuoso: There are many left and right sequences in the original list
08:51:22 <comerijn> dminuoso: Note that I said grouping *adjacent* lefts/rights, not ALL lefts/rights
08:51:27 <c_wraith> do you really gain anything interesting with that compression?
08:51:34 <vaibhavsagar> doesn't seem like something that lends itself to a general-purpose implementation
08:51:51 <comerijn> c_wraith: Yes, because I need to consume the adjacent elements as lists
08:52:20 <comerijn> vaibhavsagar: I know that, but I'm not sure what the best solution to implement it myself would be
08:52:43 <vaibhavsagar> I can have a crack at it
08:52:43 <c_wraith> I'd just write it the boring way and shrug.
08:52:55 <Lears> Speaking of combinding monoids, the other day I managed to find an outer semidirect product in the wild. I was thinking I should be able to transform a list of bits to a natural with foldMap when I realised the monoid in question was Num a => Sum Int ⋊_phi Sum a with phi (Sum l) (Sum x) = Sum (2^l * a).
08:52:56 <comerijn> c_wraith: I'm not sure what the boring way to write it is
08:53:06 <dminuoso> comerijn: Gotcha.
08:53:20 <paolino> foldr ?
08:54:05 <c_wraith> comerijn, ever looked at Data.List.sort? the first pass in it divides the input into ascending and descending runs.
08:54:18 <c_wraith> which is roughly the same thing.
08:55:37 * hackage apecs 0.7.2 - Fast Entity-Component-System library for game programming  https://hackage.haskell.org/package/apecs-0.7.2 (jonascarpay)
08:57:27 <kuribas> :t groupBy ((==) `on` isRight) 
08:57:28 <lambdabot> [Either a b] -> [[Either a b]]
08:57:34 <kuribas> comerijn: almost...
08:58:18 <comerijn> The sort approach is probably the way to go
08:59:58 <kuribas> @src sort
08:59:58 <lambdabot> sort = sortBy compare
09:00:03 <kuribas> @src sortBy
09:00:03 <lambdabot> -- The actual definition used by GHC is an optimised mergesort.
09:00:03 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
09:01:30 <c_wraith> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.OldList.html#sort
09:01:45 <c_wraith> it's not exactly short code, but it does the job!
09:02:49 <c_wraith> it's also not especially complex, which is nice.
09:04:49 <vaibhavsagar> comerijn: something like https://gist.github.com/vaibhavsagar/a26d333f1f46b357cb7f180f3622486e?
09:05:03 <vaibhavsagar> it's fantastically ugly, but I think it works
09:05:07 * hackage eccrypto 0.2.0 - Elliptic Curve Cryptography for Haskell  https://hackage.haskell.org/package/eccrypto-0.2.0 (MarcelFourne)
09:05:55 <c_wraith> vaibhavsagar, that is awfully strict for an operation that doesn't need to be
09:06:40 <vaibhavsagar> c_wraith: I'm open to suggestions :)
09:06:45 <dminuoso> Also appending at the end might not scale too good.
09:06:59 <dminuoso> `a ++ [b]` tends to be a code smell.
09:07:06 <vaibhavsagar> cool, I'd love to see your implementation
09:07:31 <c_wraith> vaibhavsagar, my suggestion was to use logic like sort uses, as linked above. it could actually be a bit simpler, as it doesn't need to reverse on segment
09:07:41 <kuribas> dminuoso: if part of a loop...
09:07:43 <paolino> (commented on github)
09:07:54 <c_wraith> *one* segment type
09:07:54 <kuribas> otherwise it's OK
09:08:17 <dminuoso> kuribas: even then it might not be.
09:08:31 <kuribas> dminuoso: how else would you append an element to a list?
09:08:52 <dminuoso> kuribas: Change the problem so I dont have to, try and revert so I can prepend, not lise []...
09:08:54 <paolino> it's a foldr so just cons
09:09:05 <dminuoso> *use
09:09:10 <vaibhavsagar> paolino: much nicer, thanks!
09:09:34 <kuribas> dminuoso: if you can, yes...
09:09:40 <paolino> would be nice to collapse last 2 lines
09:09:59 <paolino> and first 2 of 'f'
09:10:23 <vaibhavsagar> paolino: `bimap pure pure` for last two lines?
09:19:04 <vaibhavsagar> probably some biapplicative thing for the first two lines as well
09:19:04 <vaibhavsagar> and some pattern guards
09:19:32 <paolino> mh, to high for me :-)
09:20:14 <vaibhavsagar> your definition is already much nicer than mine :)
09:20:19 <paolino> also bifunctors are a bit obscuring the code
09:20:41 <vaibhavsagar> hmm, I don't think so
09:21:20 <vaibhavsagar> but also I'm not sure this function is generally useful, and so it's okay if it's not super elegant
09:27:47 <dyl> Out of curiosity, what’s a case where bifunctors really clarify a piece of code?   
09:27:54 <dyl> I’ve often found they add more weight than they simplify. 
09:27:59 <dyl> I guess with arrow code? 
09:29:26 <amx> Either? :)
09:30:16 <Lears> Every time you want to map over the second last type variable rather than the last.
09:31:38 <glguy> dyl: A lot of the the class is just used to save defining a new name
09:32:04 <paolino> vaibhavsagar : Either is not biapplicative
09:32:12 <glguy> It's less common that it's being used in some interesting generic way
09:36:02 <vaibhavsagar> On interesting, I did not realise
10:09:37 * hackage apecs 0.7.3 - Fast Entity-Component-System library for game programming  https://hackage.haskell.org/package/apecs-0.7.3 (jonascarpay)
10:12:37 <dmwit> vaibhavsagar: map (traverse (first pure)) . groupBy ((==) `on` has _Success) :: [Validation a b] -> [Validation [a] [b]]
10:13:10 <vaibhavsagar> phwoar
10:17:14 * dmwit is sad once again that there is no `equating` comparable to `comparing`
10:17:44 <dmwit> But really I guess what I'm *actually* sad about is that there's no `groupOn`, and similar `On` variants of all the `By` functions.
10:18:29 <kuribas> :t comparing
10:18:30 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
10:18:50 <dmwit> :t \f -> (==) `on` f
10:18:51 <lambdabot> Eq a1 => (a2 -> a1) -> a2 -> a2 -> Bool
10:18:53 <kuribas> dmwit: what would equating do?
10:19:07 <kuribas> other than ==
10:19:09 <dminuoso> Isn't Equating just (==)?
10:19:28 <dminuoso> Except without the boolean blindness.
10:19:35 <reygoch> Is it possible to use Setup.hs to copy resulting executable to a project directory after the build process is done?
10:19:36 <dmwit> I don't know what Equating is. But equating is what I wrote above.
10:19:49 <dmwit> It is by analogy to ```comparing f = compare `on` f```.
10:20:01 <dminuoso> dmwit: Ahh.
10:20:05 <dmwit> To pass to *By functions that demand replacements for (==).
10:20:37 <dminuoso> https://hoogle.haskell.org/?hoogle=equating
10:20:41 <kuribas> :t let equating f = (==) `on` f in f
10:20:42 <lambdabot> FromExpr a => a
10:20:43 <dminuoso> Some libraries did define it :)
10:20:50 <kuribas> :t let equating f = (==) `on` f in equation
10:20:52 <lambdabot> error:
10:20:52 <lambdabot>     • Variable not in scope: equation
10:20:52 <lambdabot>     • Perhaps you meant ‘equating’ (line 1)
10:21:10 <kuribas> :t let equating f = (==) `on` f in equating
10:21:11 <lambdabot> Eq a1 => (a2 -> a1) -> a2 -> a2 -> Bool
10:21:12 <dmwit> kuribas: Did you miss my :t query answering and immediately preceding your question?
10:21:24 <Psybur> Whats a clean way to turn an ExceptT into an OptionT[Writer] where the error is just put in the Writer?
10:21:36 <Psybur> ExceptT[Writer] *
10:21:46 <kuribas> dmwit: yes
10:21:54 <dmwit> Psybur: Use Validation instead?
10:21:58 <dminuoso> Psybur: What does ExceptT[Writer] denote?
10:22:19 <dmwit> Psybur: Of course you lose the Monad instance and have to settle for Applicative.
10:22:32 <dmwit> If you demand Monad, you may be interested in ChronicleT from the these package.
10:23:06 <Psybur> So I have a list of calculations that can fast fail (ExceptT), but I want to try many of them for the first success, and I want to log the errors
10:23:58 <Psybur> These calculations also have logs i want to preserve
10:24:21 <Psybur> I can "run" them but I imagine theres a cuter way :D?
10:32:26 <EvanR> Psybur: i wonder if you could use parallel haskell
10:33:58 <Psybur> Im actually using scala/scalaz :{
10:34:11 <EvanR> whatinthe
10:35:03 <Psybur> Its best you didnt worry yourself about it.
10:35:57 <EvanR> i really want to cancel scala/scalaz to get 1/z
10:36:57 <Psybur> Scala language and the scalaz functional programming library.
10:37:12 <EvanR> right i heard of those
10:49:37 * hackage strongswan-sql 1.0.1.0 - Interface library for strongSwan SQL backend  https://hackage.haskell.org/package/strongswan-sql-1.0.1.0 (erick)
10:50:58 <dmwit> Psybur: The Alternative instance of ChronicleT tracks the messages of early failures.
10:51:07 * hackage deque 0.3 - Double-ended queues  https://hackage.haskell.org/package/deque-0.3 (NikitaVolkov)
10:51:50 <dmwit> Psybur: In other words, what you ask for is just asum if you're using ChronicleT.
10:53:41 <dmwit> It will be up to you, I suppose, to find or create a scalaz equivalent to ChronicleT. I can only answer your question for Haskell.
10:54:38 * hackage alg 0.2.10.0 - Algebraic structures  https://hackage.haskell.org/package/alg-0.2.10.0 (MatthewFarkasDyck)
10:57:21 <talqu> hi, how do you tell your project's shell.nix to include ghcid or any other tools only used in development?
11:01:50 <Psybur> dmwit, thanks, I might be able to use the cats library which has it
11:05:54 <Lears> talqu: ghcid is project independent so you may as well just install it to your user or system profile. But in general you can use haskell.lib.addBuildTools on the project derivation from which the shell derives, or override the shell's nativeBuildInputs to include the program.
11:08:31 <talqu> Lears, thank you, i know i could use in user profile, but just wanted to know how to make shell.nix tools in general, ghc-mod, etc. maybe you know of a gist where i can see an example of haskell.lib.addBuildTools or verride of shell's nativeBuildInput
11:12:44 <EvanR> is it possible for some operations on NonEmpty to fuse away when combined with List operations. like toList (x :| xs) = x : xs
11:13:38 <lyxia> I'm sure it's possible.
11:13:44 <EvanR> i.e. a NonEmpty data structure is really the same as a List, but to use it as a list do you have to do a whole copy
11:14:22 <lyxia> you mean a whole copy of one cell
11:14:56 <EvanR> yeah it would amount to doing a conversion of : cell to :| cell at every step
11:15:06 <EvanR> er other way around
11:15:39 <EvanR> i know this would happen even if every operation was on lists, but it doesnt because fusion
11:16:27 <glguy> EvanR: What you wrote is basically the definition of toList
11:16:42 <Solonarv> only the first cell needs to be converted
11:16:45 <Solonarv> the tail can be shared
11:17:06 <glguy> Actual definition: toList ~(a :| as) = a : as
11:17:36 <Solonarv> Yup. The overhead is trivial!
11:18:11 <Lears> talqu: Untested, but assuming you have a default.nix derivation for your project in the directory, your shell.nix might be as simple as: { pkgs ? import <nixpkgs> {} }: let project' = pkgs.haskell.lib.addBuildTools (import ./. {}) [ pkgs.haskellPackages.ghcid ]; in project'.env
11:18:51 <EvanR> oh duh, :| is only the beginning of the NonEmpty
11:19:22 <EvanR> it's been a while
11:22:41 <reallymemorable> I have a super basic question: why in the type definition of MonoidalMap is the first value `k`? This is what is returned: `MonoidalMap :: Map k a -> MonoidalMap k a`
11:24:12 <dmwit> Where do you see this?
11:24:42 <Solonarv> @hackage monoidal-containers
11:24:42 <lambdabot> http://hackage.haskell.org/package/monoidal-containers
11:24:42 <dmwit> Here, perhaps: https://hackage.haskell.org/package/monoidal-containers-0.4.0.0/docs/Data-Map-Monoidal.html
11:24:56 <dmwit> If so, then I guess my follow-up question would be: what were you expecting instead of k?
11:25:58 <Boarders> I am trying to do: pattern ExistingE :: (Int, Int) -> (Int, Int, EdgeLabel); pattern Existing e = (fst e, snd e, ExistingEdgeLabel) but I get
11:26:03 <Boarders> Parse error in pattern: fst
11:26:09 <Boarders> does anyone know what I am doing wrong?
11:26:33 <Solonarv> yes: the RHS of a pattern synonym must be a pattern
11:26:44 <dmwit> Yes, you can't use fst and snd in patterns (not even if that pattern arises as the RHS of a pattern synonym).
11:26:57 <Boarders> ah ok
11:26:58 <dmwit> pattern ExistingE (x,y) = (x,y,ExistingEdgeLabel) -- would be  fine
11:27:13 <reallymemorable> dmwit: what is the significance of the first value being k?
11:27:24 <Solonarv> (ViewPatterns are very useful for defining pattern synonyms!)
11:27:26 <Boarders> dmwit: that doesn't seem to wirk
11:27:28 <Boarders> work*
11:27:35 <Boarders> which is why I switched the convoluted fst, snd
11:27:41 <dmwit> reallymemorable: Well, I think you're misunderstanding something. There is no "first value" that is k. The first *type argument* is k.
11:27:42 <Boarders> I get   parse error on input ‘(’
11:27:51 <reallymemorable> ok
11:28:01 <reallymemorable> but why is the first argument k
11:28:12 <Boarders> Solonarv: ah ok, do you know a way to get something equivalent
11:28:13 <reallymemorable> i am 1 week into haskell, so it's all confusing
11:28:17 <dmwit> reallymemorable: k is short for "key". A `Map k v` keeps a collection of keys of type `k` and a value of type `v` associated with each.
11:28:49 <Solonarv> Boarders: well, I'm not sure what your pattern synonym is supposed to be
11:29:57 <Lears> Boarders: You probably have to make it pattern ExistingE x y = ...
11:31:20 <reallymemorable> dmwit: ah so I need to give it keys and values
11:31:46 <Solonarv> pattern ExistingE xy <- ((\(x, y, ExistingEdgeLabel) -> (x, y)) -> xy) where ExistingE xy = let ~(x, y) = xy in (x, y, ExistingEdgeLabel
11:31:54 <Solonarv> this should work, I think
11:32:50 <Solonarv> er, I missed a closing ) at the end
11:34:23 <Boarders_> Solonarv: great thank you!
11:34:58 <Boarders_>  I am really bad at the pattern language of haskell for some reason
11:35:47 <Solonarv> to be fair, pattern synonyms are a bit of a niche corner
11:36:32 <Solonarv> note: if you were willing to have 'pattern ExistingE :: Int -> Int -> (Int, Int, EdgeLabel)' you could have the uch simple 'pattern ExistingE x y = (x, y, ExistingEdgeLabel)'
11:43:07 * hackage haskell-lsp 0.8.1.0 - Haskell library for the Microsoft Language Server Protocol  https://hackage.haskell.org/package/haskell-lsp-0.8.1.0 (AlanZimmerman)
12:06:09 <neobrain> Hey! I'm trying to call a Haskell function from some Just-in-Time generated assembly code within the same process. I've already exported the function using the FFI (foreign export ccall helloWorld :: IO ()), but I'm not sure how I can actually get a raw pointer to that function, which I'd need for the assembly to actually call it
12:06:39 <cocreature> neobrain: hi! :)
12:07:17 <neobrain> oh hi cocreature :D (thanks for your reply on github!)
12:07:48 <cocreature> neobrain: search for "Dynamic Wrapper" in https://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1490008
12:08:04 <cocreature> That gives you a way to get a FunPtr from a Haskell function
12:08:24 <neobrain> Awesome, I'll give that a go
12:08:44 <cocreature> you can then use castFunPtrToPtr and pass the Ptr via the regular C FFI
12:10:29 <cocreature> I guess you don’t even need to castFunPtrToPtr, it looks like FunPtr is a valid FFI type
12:10:54 <neobrain> "Hello World from Haskell FFI" <- well, that was easy :) Thanks!
12:11:35 <cocreature> don’t worry, soon enough you’ll get to the point where everything segfaults and things won’t be that easy anymore :)
12:11:43 <neobrain> Hmm I'm using "ptrHelloWorld <- ptrToWordPtr <$> castFunPtrToPtr <$> mkCallback helloWorld" right now, since I'm wrapping up the entire thing in a JITSymbol, which expects a WordPtr32
12:12:05 <neobrain> idk I've been through those segfaults a couple of times already today :D
12:12:06 <monochrom> This is why we need a Haskell compiler for DOS, so as to eliminate segfaults!
12:12:34 <cocreature> monochrom: I’m too young to get that joke :) what happens on DOS if you screw this up?
12:13:50 <monochrom> You are allowed access to memory you neither own nor initialized.  When reading, you read unknown data.  When writing, you corrupt unknown but important data.
12:14:38 <monochrom> For example you can accidentally corrupt the interrupt vector table!
12:15:14 <cocreature> fun!
12:15:36 <monochrom> My friend had an extreme case that led to inadventedly calling up the format-the-hard-disk routine in the firmware.
12:16:17 <dminuoso> monochrom: Well "memory you don't own" is weird to talk about in a single user OS.
12:17:46 <cocreature> all your memory are belong to us
12:17:59 <monochrom> "you" is anthropomorphizm for "process".
12:19:38 <monochrom> Conversely, on a multi-user OS, I, monochrom, (a person not a process), can just break into the server room and access RAM chips I don't own! I can just yank them out and confound the hell out of all users and admins!
12:21:57 <amx> I think DOS and the 386 had protected mode, but the problem was executables did not like it? memory is hazy.
12:22:37 * hackage hs-duktape 1.0.0 - Haskell bindings for a very compact embedded ECMAScript (JavaScript) engine.  https://hackage.haskell.org/package/hs-duktape-1.0.0 (myfreeweb)
12:22:45 <geekosaur> protected mode for extended memory only, not for memory protection
12:23:12 <geekosaur> and the OS didn't support either memory protection or true multitasking, so all such were hacks
12:23:31 <monochrom> 386 has a lot of things DOS doesn't use.
12:24:16 <NickSeagull> Does anyone know how to translate all values of an effect from `freer` at the same time?
12:24:17 <monochrom> Very likely today's x86 and x86-64 still have four rings, and clearly all OSes use only two of them.
12:24:25 <cocreature> I’m never quite sure if I should be happy or sad that I never had to deal with this
12:25:06 <geekosaur> OS/2 and I think some aspects of MacOS use ring 1
12:25:10 <geekosaur> used
12:25:24 <cocreature> Then again, I’m employed as a Haskell programmer and yet I spent the last few weeks learning more about linkers and x86_64 relocations than I ever wanted so I feel like I get at least the modern version of that experience :)
12:25:30 <geekosaur> and recent versions of MacOS dropped some of its uses, iirc
12:25:59 <NickSeagull> not sure if I should ping lexi-lambda
12:26:26 <lexi-lambda> You called?
12:26:41 <lexi-lambda> (I don’t actually understand the question.)
12:26:44 <NickSeagull> Hi ^_^" sorry to bother you
12:26:51 <geekosaur> (which is why I think MacOS used/uses them; one of the announcements suggested that they'd removed at least some uses thereof, but not by name and might have meant something else)
12:28:17 <NickSeagull> lexi-lambda: I provided some more detail at https://github.com/lexi-lambda/freer-simple/issues/26 but basically it revolves around a function that runs a monad transformer multiple times instead of just once
12:30:17 <lexi-lambda> NickSeagull: From a quick peek at the issue, I still don’t completely understand the question, but is the gist of it that runInterpreter internally maintains some state?
12:30:41 <NickSeagull> Yep, it literally instantiates GHCi and maintains a session
12:31:50 <NickSeagull> So I'm not sure how to go from `Eff '[Interpreter] a` to `Eff '[IO] a` without making it instantiate a GHCi session per each instruction
12:32:10 <reallymemorable> How do I bring `DeriveAnyClass` into scope?
12:32:21 <reallymemorable> With `import` at the top of the .hs script?
12:32:36 <geekosaur> it's a pragma, not a keyword
12:32:46 <geekosaur> {-# LANGUAGE DeriveAnyClass #-}
12:33:04 <lexi-lambda> NickSeagull: So you want to sort of… collect all the actions together to form a computation of type `InterpretT IO a` and run it all at once with `runInterpreter`?
12:34:13 <NickSeagull> Exactly lexi-lambda 
12:34:58 <reallymemorable> geekosaur: even after putting `{-# LANGUAGE DeriveAnyClass #-}` at the top of my .hs file, it is still saying `Not in scope: type constructor or class 'DeriveAnyClass'`
12:35:19 <geekosaur> because it's not a keyword. what are you trying to do with it?
12:35:30 <dminuoso> monochrom: Regarding 4-rings: Processors dont have them anymore realistically. x86 has received very strong optimized instructions that assume a 2-ring usage to the point that 4-ring is extremely slow.
12:35:55 <geekosaur> the only place you'd mention it as such is a deriving strategy ("deriving any YourClassHere" iirc)
12:36:04 <lexi-lambda> NickSeagull: Interesting question. It sounds like it ought to be possible, but I can’t immediately tell you exactly what the right way to do it is. You certainly can’t use `runInterpreter` in `foo`, since that will run it once per use of the action.
12:36:19 <geekosaur> otherwise it's used when you tell it to derive a class that isn't one of the built-in ones
12:37:04 <dminuoso> (1/2 are still used by some device drivers though, so there is that)
12:37:10 <ski> @type GHC.Exts.groupWith
12:37:12 <lambdabot> Ord b => (a -> b) -> [a] -> [[a]]
12:37:13 <ski> @type GHC.Exts.sortWith
12:37:14 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
12:37:28 <ski> dmwit : fyi ^
12:37:38 <dminuoso> But that was x86, now we have AMD64.
12:38:18 <geekosaur> interesting that that hangs on
12:38:27 <geekosaur> OS/2 used ring 1 for video drivers
12:38:50 <geekosaur> I think MacOS may still do the same, hence above quibble about it
12:39:11 <lexi-lambda> NickSeagull: Thinking a little bit more, I’m not sure that what you ask for is possible, at least not right now. The trouble is that, fundamentally, transformers and effects aren’t the same thing; you can’t arbitrarily compose monad transformers.
12:39:22 <rfold> Is it possible to get "cabal repl" to load both the library and the test suite so that I can use ghcid with both?
12:39:24 <reallymemorable> geekosaur: sorry I'm new to haskell and not understanding what you mean.  I tried putting it below the type with the deriving (Generic, DeriveAnyClass) syntax but taht didn't work either.
12:39:31 <cocreature> rfold: sadly no
12:39:31 <reallymemorable> I thought you were suggesting I put it in brackets
12:39:35 <geekosaur> correct, because that's not what it does and not how it works
12:39:42 <rfold> cocreature: thanks, then I'll put my test suite in my library :)
12:39:52 <geekosaur> DeriveAnyClass tells it what to do if you derive a class it doesn't have a wired-in derivation for
12:39:54 <cocreature> rfold: for new-build, the ghc env file will make it fairly easy to use ghci directly
12:40:01 <geekosaur> it is not a directive used in a deriving specification
12:40:09 <reallymemorable> ok
12:40:18 <reallymemorable> so its something like a sum type for classes?
12:40:30 <geekosaur> there is no keyword meaning "derive every class known for this"
12:40:37 <lexi-lambda> NickSeagull: What you could do is have some function that goes from `LastMember Interpreter effs => Eff (MyInterpreter ': effs) ~> Eff effs`. Would that work for you?
12:40:46 <lexi-lambda> I’m not sure exactly what your needs are.
12:41:05 <geekosaur> reallymemorable, no. if you derive some class, it looks for how to derive those specific classes. some are wired in, like Show and (if you enable it) Functor
12:41:19 <NickSeagull> Yeah sure lexi-lambda that'd work, the interpreter is run at top level
12:41:49 <geekosaur> if you have GeneralizedNewtypeDeriving enabled, it knows how to wrap and unwrap "deriving" for any class the original type has.
12:42:11 <geekosaur> if DeriveAnyClass is enabled, it creates empty instances and requires the derived classes have default implementations for all methods
12:42:13 <lexi-lambda> NickSeagull: Okay, then make an interpreter that uses `interpretM`, or `interpret` + `sendM` directly.
12:42:23 <geekosaur> otherwise it throws an error that it doesn't know how to derive the class
12:42:43 <dmwit> ski: Oh, handy.
12:42:51 <dmwit> ski: That GHC namespace has a couple fun things in it, huh?
12:43:18 <ski> dmwit : <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#generalised-sql-like-list-comprehensions> happened to mention those
12:43:30 <NickSeagull> Oh cool didnt think about that lexi-lambda thanks
12:43:45 <NickSeagull> Actually the same thing happened to me when I tried to combine InterpreterT with ReaderT
12:44:04 <NickSeagull> So I had to write a super dirty hack to work around it
12:44:09 <NickSeagull> Thanks again ^_^
12:44:15 <lexi-lambda> NickSeagull: Ideally, it would be nice to embed arbitrary, self-contained GHCi sessions inside of a larger effectful computation. And maybe with some clever trickery it could be done by translating `Eff (MyInterpreter ': effs) a` into `InterpreterT (Eff effs) a`. But I’m not immediately sure how to do that, or if you would need something like MonadBaseControl.
12:44:58 <lexi-lambda> It sounds like it could be a fun puzzle to explore, but I probably won’t get to it terribly soon. :)
12:45:45 <reallymemorable> geekosaur: I'm trying to deal with this: https://paste.ofcode.org/38BKpB7m4TsRaQuVtETAduv
12:46:37 <NickSeagull> lexi-lambda: I just took notes of it, will check it out. I require MonadMask for that
12:46:42 <geekosaur> oh. the error message is misleading because ghc doesn't know what you're trying to do
12:47:54 <reallymemorable> how do I derive an instance of a non-standard class?
12:47:57 <geekosaur> there's no wired-in rule for Semigroup, nor is there a default implementation; you have to write one yourself
12:48:24 <geekosaur> (someone might have a generic implementation that would work with DeriveAnyClass hidden away in a package somewhere)
12:48:26 <reallymemorable> could you point me to an example of such a manually written class?
12:48:41 <geekosaur> the problem with deriving such classes is ghc has no idea what a class "means"
12:49:29 <geekosaur> in certain specific cases there are rules it can follow, hence there's a wired-in derivation for Functor and one for Show, etc. but for Semigroup, it doesn't know what a Semigroup is. you have to know that and write the instance appropriately
12:50:14 <geekosaur> which also means I can't tell you how to write it because I have no idea what a ProductMonoidalMap is (well, I can guess from the name, but there's still several possible interpretations)
12:50:28 <reallymemorable> ok thank you
12:50:35 <reallymemorable> just one week into this :P
12:50:39 <reallymemorable> trying to not get scared and run away
12:50:53 <geekosaur> this sounds like the wrong thing to be doing a week in...
12:51:14 <reallymemorable> I'm going back and forht between Haskell from first principles book and some legacy code
12:52:38 <geekosaur> anyway, Semigroup gives you one operator (<>) which can combine two values to produce a third. if you have a Monoid instance and just need to provide the now-required Semigroup instance, you can reuse it: instance Semigroup ProductMonoidalMap where (<>) = mappend
12:53:01 <geekosaur> (I think. I'd have expected there to be some description of this in the Data.Semigroup haddock, to help with migrating older code.)
12:54:12 <dminuoso> reallymemorable: If you are familiar with Java interfaces, C++ concepts or "protocols" as other languages call it, typeclasses serve a somewhat similar purpose. They just describe some interface, and some type can choose to implement that interface. We call such an implementation "an instance"
12:54:20 <geekosaur> and when doing this one has to be a little careful, since the Monoid instance might itself define mappend in terms of sappend or Semigroup's (<>) and the above would then be an infinite loop. But since mappend came first, I'd expect this setup
12:55:13 <geekosaur> dminuoso, they're trying to retrofit old code for ghc 8.6's requirement of Semigroup instances backing Monoid instances
12:57:47 <dyl> Anyone have any suggestions for writing a quick lexer concisely (I'm using Earley for parsing).
12:58:36 <dminuoso> dyl: any parser combinator of your choosing?
12:58:41 <dyl> I could just write another Grammar for the lexer perhaps?
12:59:00 <dyl> I'm used to just writing greedy regex scanners :p.
12:59:07 <dyl> I'm not sure what the golden path in Haskelland is.
12:59:43 <dyl> I should note: I already have a parser that works on a token stream. 
13:00:11 <dminuoso> dyl: it seems to be that all a lexer is, is a `Parser [Token]`
13:00:21 <dyl> Yeah, that was my intuition.
13:03:32 <ddellacosta> so this is nix-specific but I'm getting "default.nix:1:1 called without required argument 'gi-cairo-connector'" when I attempt to build https://github.com/taffybar/taffybar/blob/master/default.nix Any ideas what I need to fix this? I'm somewhat new to NixOS but have a basic grasp of derivations and how the system works
13:05:26 <boj> ddellacosta: you might get an answer in #nixos
13:05:56 <ddellacosta> boj: not so far :-/ I have a hard time knowing where to ask Haskell-specific NixOS questions
13:06:13 <ddellacosta> or er Nix-specific Haskell questions, as you will
13:06:16 <dmwit> dyl: alex for fast, regex-applicative for comfortable, I think.
13:18:18 <tombusby> Hey all, super quick, simple question: Is there a function in prelude or somewhere else that's a nicer looking alias for (:[])
13:19:03 <EvanR> (:[]) looks hilariously like a cookie monster
13:19:12 <EvanR> i recommend it
13:19:20 <tombusby> EvanR: XD
13:19:38 * hackage yesod-content-pdf 0.2.0.5 - PDF Content Type for Yesod  https://hackage.haskell.org/package/yesod-content-pdf-0.2.0.5 (alexkyllo)
13:26:09 <delYsid> Can I somehow get the address of a function such that I could pass it into hint (InterpreterT)?
13:27:22 <talqu> thank you Lears 
13:27:51 <NickSeagull> delYsid: could you make an example please? :)
13:28:34 <NickSeagull> tombusby: I use the `relude` prelude and they have a `one` function for that
13:28:58 <benzrf> talqu: pure
13:31:27 <delYsid> NickSeagull: With hint (InterpreterT) you can `interpret` an expression to Typeable results, which even allows to pass a function from tthe interpreter world to the runtime.  However, I am seeking a way to pass a function from the runtime to the interpreter.
13:32:24 <benzrf> :t pure @[]
13:32:25 <lambdabot> error:
13:32:25 <lambdabot>     Pattern syntax in expression context: pure@[]
13:32:25 <lambdabot>     Did you mean to enable TypeApplications?
13:32:28 <benzrf> :\
13:32:35 <tombusby> NickSeagull: I don't have the opportunity to change the prelude, existing codebase, but thanks for letting me know about this
13:32:36 <benzrf> @let {-# LANGUAGE TypeApplications #-}
13:32:37 <lambdabot>  Defined.
13:32:39 <benzrf> :t pure @[]
13:32:40 <lambdabot> error:
13:32:41 <lambdabot>     Pattern syntax in expression context: pure@[]
13:32:41 <lambdabot>     Did you mean to enable TypeApplications?
13:32:44 <benzrf> aw
13:32:55 <delYsid> Ultimately, I want to have the result of getExternalPrint (haskeline) which is String -> IO () to available in the interpreter.
13:33:56 <delYsid> However, that is a stateful function, so I cant just import it.
13:42:16 <delYsid> Or, is there some sort of IPC in Haskell I could use to send a string from one process to another?
13:43:56 <Solonarv> % :t pure @[] -- benzrf
13:43:56 <yahb> Solonarv: a -> [a]
13:47:15 <NickSeagull> delYsid: I dont know if that is possible tbh
13:50:10 <Solonarv> there is a simple workaround:
13:51:05 <Solonarv> instead of trying to pass a 'String -> IO ()' into hint and then asking the interpreted code to produce an 'r', ask the interpreted code to produce a '(String -> IO ()) -> r' and then marshal that into a function
13:54:34 <Solonarv> i.e.: do useExternalPrint <- "\\externalPrint -> do externalPrint \"hi\""; liftIO (useExternalPrint externalPrint)
13:59:38 <mpickering> ddellacosta: What commit of nixpkgs are you using?
14:00:12 <mpickering> That is quite a new package
14:00:17 <mpickering> so you will need quite a recent version of nixpkgs
14:01:19 <ddellacosta> mpickering: hrm I guess just whatever I have installed by default in NixOS 18.09...but that is helpful, thanks! I'll see where that clue leads me
14:01:31 <ddellacosta> I guess I may need a new channel huh
14:01:48 <mpickering> ddellacosta: If you update to nixos-unstable then it will probably work
14:02:14 <ddellacosta> mpickering: great, will give that a shot
14:21:38 <_JelloRaptor> So I'm trying to figure out how to do some nested transformations of a recursive data structure (like t
14:23:23 <Welkin> _Jello_Raptor: watch out for bill cosby
14:23:31 <Welkin> _JelloRaptor ^
14:23:35 <Welkin> there are too many of you!
14:23:54 <_JelloRaptor> Welkin, yeah, some issues with my bouncer
14:24:05 <_JelloRaptor> any of those work though. 
14:27:06 <_JelloRaptor> Like, I've got an AST functor for a small language, and I want to be able to write a transform (as a lens-ish thing) over the recursive (Fix t) definition which i can convert to a transform on the explicit version (Map k (t k))
14:29:07 * hackage aeson-casing 0.1.1.0 - Tools to change the formatting of field names in Aesoninstances.  https://hackage.haskell.org/package/aeson-casing-0.1.1.0 (andrewrademacher)
14:29:59 <_JelloRaptor> Basically I'm translating a high level constraint language down step by step into a version I can pass into a constraint solver, and want to be able to translate the solved version back out into the higher level language (Assuming I have a nice reversable transformation already.) 
14:30:41 <_JelloRaptor> I am just unclear on if there is already a good model for this, or whether i have to design one myself. 
14:32:12 <dmwit> Could you check the channel logs and make sure all the messages you intended to send actually arrived?
14:32:21 <dmwit> (There's a link in /topic.)
14:33:27 <_JelloRaptor> dmwit: everything I sent arrived, I just hit enter too early on the first message and decided to reword it.
14:34:46 <dmwit> Okay. I think I understand your request. But it's not clear to me that what you ask can actually be done.
14:35:25 <dmwit> It's certainly not hard to convert your Map k (t k) into a Fix t to pass into your other method.
14:36:12 <dmwit> But I'm imagining you are thinking you'd like to write, say, a `Fix t -> Fix t` and have that get automatically converted to a `Map k (t k) -> Map k (t k)`. But I don't see a way to recover the sharing of the output of your first function.
14:36:24 <_JelloRaptor> dmwit: yeah, but then in a lower level language I'd have to use observable sharing or something to get the unraveled version back out.
14:36:29 <dmwit> So converting to `Map k (t k) -> Fix t` seems easy, but the last step seems... not.
14:36:53 <dmwit> Now, if you know something special about your transformation it may be possible to do better.
14:36:58 <dmwit> But not for arbitrary functions.
14:37:29 <_JelloRaptor> dmwit: right, so I'm trying to figure out if I can have my plated transformation cake, while working directly with the unraveled version.
14:37:45 <dmwit> Which version is "unraveled"?
14:37:56 <_JelloRaptor> the Map k (t k)
14:38:48 <Solonarv> what is 'k'? if it's *not* just some unknown type then things get a lot easier
14:39:04 <dmwit> I'm assuming it's something easy and concrete. Say, Int.
14:39:48 <_JelloRaptor> Solonarv: Just some identifier type, int or Unique.
14:40:35 <Solonarv> also: does 't k' have an Ord instance? and do you need the keys to be preserved?
14:40:56 <_JelloRaptor> whatever it is will have the same guarantees as unique. Can generate unused values, has Eq and Hashable
14:40:58 <dmwit> Here's another thing that may make things easier: is this a DAG or are there cycles?
14:41:04 <_JelloRaptor> Solona
14:41:43 <Solonarv> I'm talking about your AST functor, does that have Eq/Ord/Hashable?
14:42:00 <_JelloRaptor> Dmwit: It can have cycles.
14:42:07 <_JelloRaptor> Solo
14:42:19 <_JelloRaptor> Solonarv: yeah, they do.
14:42:19 <dmwit> Too bad. I think you'll have to write manually.
14:43:06 <Solonarv> yeah, if cycles are allowed I can't think of a good way to do what you're trying to.
14:45:08 <_JelloRaptor> Is there an idea for if it isn't cyclic? I think I might be able to massage things into a DAG for the common case at least.
14:45:49 <dmwit> If you can express it as a fold;unfold, perhaps you can "just" process the nodes in toposorted order.
14:46:09 <Solonarv> yes: you can walk through the 'Fix t' while maintaining a 'Map (t k) k' of already-seen subexpressions and their ID
14:46:26 * _JelloRaptor nods
14:46:31 <merijn> Is there a "strict" identity I could use to make a foldMap application strict?
14:46:44 <dmwit> Identity is already strict.
14:46:47 <merijn> (So ideally a strict identity with a Monoid instance)
14:47:00 <dmwit> (It's a newtype.)
14:47:15 <merijn> dmwit: No it's not
14:47:16 <Solonarv> % newtype StrictSemi a = StrictSemi a
14:47:16 <yahb> Solonarv: 
14:47:36 <dmwit> > seq (Identity undefined) ()
14:47:38 <merijn> dmwit: "Identity (foo `mappend` bar)" won't for the mappend
14:47:38 <lambdabot>  *Exception: Prelude.undefined
14:48:10 <Solonarv> % instance Semigroup a => Semigroup (StrictSemi a) where StrictSemi x <> StrictSemi = x `seq` y `seq` StrictSemi (x <> y)
14:48:10 <yahb> Solonarv: ; <interactive>:63:72: error:; * The constructor `StrictSemi' should have 1 argument, but has been given none; * In the pattern: StrictSemi; In an equation for `<>': StrictSemi x <> StrictSemi = x `seq` y `seq` StrictSemi (x <> y); In the instance declaration for `Semigroup (StrictSemi a)'
14:48:19 <Solonarv> % instance Semigroup a => Semigroup (StrictSemi a) where StrictSemi x <> StrictSemi y = x `seq` y `seq` StrictSemi (x <> y)
14:48:19 <yahb> Solonarv: 
14:48:25 <Solonarv> ^ do you mean this?
14:48:26 <merijn> dmwit: The source of base certainly doesn't show it as strict
14:48:42 <dmwit> merijn: Forcing `Identity (mappend foo bar)` will force just as much as forcing `mappend foo bar`.
14:48:44 <merijn> Solonarv: I'd use bangpatterns, but yes something like that
14:48:48 <dmwit> merijn: That is, Identity is strict.
14:49:06 <Solonarv> % Product 0 <> undefined
14:49:06 <yahb> Solonarv: Product {getProduct = *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:65:14 in interactive:Ghci31
14:49:18 <Solonarv> (bah, should've used Any/All)
14:49:25 <Solonarv> % Any True <> undefined
14:49:25 <yahb> Solonarv: Any {getAny = True}
14:49:36 <merijn> dmwit: My problem is that "foldMap" is just the foldl thunk explosion allover again
14:49:37 <Solonarv> % Identity (Any True) <> undefined
14:49:37 <yahb> Solonarv: Identity (Any {getAny = True})
14:49:48 <Solonarv> % StrictSemi (Any True) <> undefined
14:49:48 <yahb> Solonarv: ; <interactive>:68:1: error:; * No instance for (Show (StrictSemi Control.Monad.RWS.Any)) arising from a use of `print'; * In a stmt of an interactive GHCi command: print it
14:50:17 <Solonarv> % StrictSemi (Any True) <> undefined
14:50:17 <yahb> Solonarv: StrictSemi (Any {getAny = *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:70:26 in interactive:Ghci34
14:50:56 <ski> (hm, so strict `(<>)' , rather than strict `Identity' (data constructor))
14:51:54 <merijn> ski: Well I was thinking "data StrictMonoid a = Strict !a; instance Monoid a => Monoid (Strict a)" along those lines
14:52:28 * dmwit == ski
14:52:48 <Solonarv> that doesn't quire have the same semantics as my newtype, does it?
14:53:02 <merijn> Solonarv: Pretty sure it does?
14:53:03 <dmwit> It's probably often the case that a single level of seq on each argument to (<>) is enough, although I bet I could cook up a monoid for which that's not enough. =P
14:53:11 <Solonarv> % data StrictBox a = StrictBox !a deriving Show
14:53:12 <yahb> Solonarv: 
14:53:28 <Solonarv> % case undefined of Identity _ -> "fine"
14:53:29 <yahb> Solonarv: "fine"
14:53:37 * hackage apecs-physics 0.3.2 - 2D physics for apecs  https://hackage.haskell.org/package/apecs-physics-0.3.2 (jonascarpay)
14:53:39 <Solonarv> % case undefined of StrictBox _ -> "fine"
14:53:40 <yahb> Solonarv: "*** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:73:1 in interactive:Ghci36
14:53:47 <Solonarv> see - not the same!
14:54:00 <merijn> Solonarv: Right, but not different in a way I care about ;)
14:54:04 <Solonarv> fair enough
14:54:21 <merijn> Solonarv: And I prefer strict datatypes to manually fucking about with seq
14:54:21 <Solonarv> No real reason not to use a newtype then!
14:54:26 <merijn> Because seq is confusing
14:54:41 <dmwit> ($!) is much less confusing.
14:54:56 <Solonarv> or BangPatterns
14:54:58 <dmwit> And good enough: `Strict x <> Strict y = Strict ((<>) $! x $! y)`
14:55:03 <merijn> dmwit: Combining $! with foldMap is tricky
14:55:34 <dmwit> I'm proposing using it instead of seq in your newtype's Monoid instance.
14:56:06 <theelous3_> hey, quick syntax question. If I have a list of tuples [(nt]
14:56:06 <ski> % newtype TT = CC !()
14:56:06 <yahb> ski: ; <interactive>:74:14: error:; * A newtype constructor cannot have a strictness annotation, but `CC' does; * In the definition of data constructor `CC'; In the newtype declaration for `TT'
14:56:08 <theelous3_> oops
14:56:09 <merijn> dmwit: But why is that preferable to my definition using !?
14:56:15 <dmwit> merijn: one less box
14:56:30 <dmwit> So, less memory usage, and less cache thrashing as you dereference an extra pointer.
14:56:40 <merijn> dmwit: If you newtype it you lose the box too, no?
14:56:50 <dmwit> newtype loses the box. Your strict data does not.
14:56:51 <theelous3_> hey, quick syntax question. If I have a list of tuples [(Int, Char)], how can I write a list comp like, [x * 2, y | (x, y) <- myList]
14:56:56 <Solonarv> exactly, that's the reason to use a newtype instead of a datatype with a strict field
14:57:08 <merijn> dmwit: You can make a strict newtype too, no?
14:57:11 <theelous3_> oh nvm got it
14:57:14 <dmwit> All newtypes are strict.
14:57:20 <ski> theelous3_ : `(x * 2,y)'
14:57:24 <theelous3_> yeah
14:57:26 <theelous3_> ty
14:57:27 <dmwit> Precision: all newtype constructors are strict.
14:57:29 <ski> (this is not OCaml)
14:57:54 <Solonarv> (however, they are not strict in quite the same way as a data-constructor with a !)
14:58:12 <dmwit> There are not different ways of being strict...
14:58:23 <Solonarv> % case undefined of Identity _ -> "fine"
14:58:23 <yahb> Solonarv: "fine"
14:58:26 <Solonarv> % case undefined of StrictBox _ -> "fine"
14:58:27 <yahb> Solonarv: "*** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:76:1 in interactive:Ghci37
14:58:37 <dmwit> But strictness says nothing about pattern matching, only function application.
14:58:38 <Solonarv> this is what I mean.
14:58:45 <Solonarv> fair enough
14:59:02 <ski> theelous3_ : it would also be possible to use `map (Data.Bifunctor.first (* 2)) myList'
14:59:51 <theelous3_> yep, I was just wondering about the syntax, because I initially tried [(x * 2, y) | x, y <- myList] who's error falsely lead me to believe that the first part was wrong too
15:00:10 <theelous3_> rather, I falsely interpreted it :P
15:00:18 <ski> % let f (Identity _) = () in f undefined
15:00:18 <yahb> ski: ()
15:00:23 <ski> % let f (StrictBox _) = () in f undefined
15:00:23 <yahb> ski: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:78:31 in interactive:Ghci38
15:00:47 <ski> latter `f' is strict, former isn't
15:01:46 <ski> so i suppose the former `f' here is `runIdentity' and the latter is `runStrictBox', had we defined such a one
15:02:48 <merijn> Anyway, the real question was: Do we already have a newtype/data/who cares to lift any Monoid to strict mappend in base already?
15:03:07 <ski> so it seems the issue is that the deconstructor/extractor/selector for `newtypes' are not strict, but for a strict-single-component-of-single-constructor `data', it is strict
15:03:55 <ski> hmm .. oops, not quite `runIdentity', since we throw away the contents, hmm
15:04:42 <ski> (perhaps we can express the different in terms of the `case' or `cata', applied to `const ()' in the above case ?)
15:05:45 * ski leaves this question for the channel to consider, heads for bed
15:16:55 <gentauro> anybody with custom instances of `Data` like in `deriving Data`?
15:17:34 <gentauro> is it possible to create an object if not all constructor fields are provided?
15:17:49 <gentauro> example: `data Foo = Foo Char Int`
15:18:37 <gentauro> `instance Data Foo where ... gunfold ... toConstr ...`?
15:19:09 <gentauro> I mean, both `gunfold` and `toConstr` are `type-safe`. They expect you to provide `two fields` each
15:19:18 <geekosaur> "yes" in the same way plain haskell would do it: use undefined or other bottom
15:19:18 <gentauro> but can this be somehow bypassed?
15:19:47 <geekosaur> for example, an incomplete record constructor will put bottoms that report uninitialized fields in the uninitialized fields
15:20:50 <gentauro> if I make the following change: `data Foo = Foo Char (Maybe Int)`
15:21:05 <gentauro> can I replace the last `undefined` with a `Nothing`?
15:22:01 <gentauro> if yes, how :)
15:22:35 <gentauro> I have been able to `mimic` this example -> http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Data.html#t:Data
15:22:54 <gentauro> but not when I don't provide all fields
15:22:57 <Welkin> what is everyone's obsession with foo?
15:23:12 <Welkin> why not Pikachu and Bulbasaur?
15:23:32 <gentauro> Welkin: ein?
15:24:34 <gentauro> oh, I'm really tired. I will try again tomorrow ...
15:26:37 <geekosaur> again, provide the field with undefined or (error "missing initializer for field 'whatever'")
15:26:47 <geekosaur> which is what you'd do if constructing it directly
15:27:08 <geekosaur> the missing fields, that is
15:27:31 <Welkin> the way you do this in haskell is to use records for construction and set default
15:27:37 <Welkin> defaultPikachu
15:27:50 <Welkin> you can even get fancy and use the Default typeclass so you can type 
15:28:18 <Welkin> def { hp = 100, favoriteFood = "poke pellets" }
15:29:22 <Welkin> thay way you can extend or change it later without having to update it everywhere
15:29:35 <Welkin> and won't have a million Nothing's everywhere
15:29:52 <Welkin> you'll have some annoying Justs though
15:36:10 <talqu> https://pastebin.com/vq9XsCRq, addbuildtools is function which take a derivation and a list of 'extra' packages as i understand from this snippet. The hoogle part is confusing, shouldn't generate hoogle docs be available only on the package defined below, and not on Snap, which comes from the derivation in default.nix?
15:37:26 <talqu> ups, sorry, i meant to paste this in #nixos
16:25:37 * hackage oeis2 1.0.2 - Interface for Online Encyclopedia of Integer Sequences (OEIS).  https://hackage.haskell.org/package/oeis2-1.0.2 (23prime)
17:06:07 * hackage ad 4.3.6 - Automatic Differentiation  https://hackage.haskell.org/package/ad-4.3.6 (ryanglscott)
17:06:46 <MarcelineVQ> Is there a paper about how MVar is implemented? There's a sort of overview about STM with some hints about how you might invent a TVar but I've not found similar for MVar.
17:07:10 <Welkin> a locally scoped IORef?
17:07:12 <MarcelineVQ> I perused the STG for MVar but find it a little hard to follow so far
17:07:30 <Welkin> check the parconc book
17:07:32 <Welkin> it may have something
17:08:38 <MarcelineVQ> I don't recall the book having info about the implementations about the implementation of the concurrency primitives themselves, just how they're used to make things. The primitives being fork, mvar, tvar
17:08:52 <MarcelineVQ> oops, not a well formed line :>
17:10:06 <MarcelineVQ> Good suggestion though, just mentioning that I don't think it's in there given the books focus
17:10:53 <Welkin> it should be in the runtime right?
17:12:41 <MarcelineVQ> Yes, things like newMVar lead to stg code that can be directly examined but I haven't been able to follow it quite yet, so a paper kind of giving the overall idea seemed like a good thing to ask about
17:17:36 <MarcelineVQ> stg_newMVarzh in this case if you're at all curious :> But I don't know what the dirtyness of an MVar means, I'm hazarding it's GC related
17:18:14 <Welkin> look like a mitzvah
17:19:25 <MarcelineVQ> I don't know what that means :o
17:19:58 <Welkin> the identifier reminds me of a (bar)mitzvah
17:20:11 <dyl> Does anyone else just always use GADT notation for aesthetic reasons?
17:20:26 <dyl> It's heavier than the usual ADT syntax but... consistency is key.
17:20:28 <MarcelineVQ> Welkin: oh like the pattern of letters reminds you of that?
17:20:33 <lightstep> Hello! Got a new ubuntu machine, I wonder what's the currently recommended way to install haskell? (preferably stack)
17:20:40 <MarcelineVQ> I could see that hehe
17:21:16 <Welkin> lightstep: haskell platform
17:21:20 <lightstep> Is there a package or do I download the shell script?
17:21:42 <sm> you can do either
17:21:49 <lightstep> so apt install haskell-platform?
17:22:01 <lyxia> dyl: I agree it's a very neat syntax
17:22:06 <MarcelineVQ> lightstep: if you know that you will prefer stack then I suggest strongly that you just get the executable from github, and stick it in ~/.local/bin and point your path there
17:22:14 <Welkin> stack sucks
17:22:14 <dyl> It also satisfies my desire to manually align things.
17:22:17 <Welkin> I don't recommend it
17:22:19 <dyl> I always give up on autoformatters/linters.
17:22:21 <MarcelineVQ> everything else will be messier by comparison
17:22:22 <Welkin> you can also use https://github.com/haskell/ghcup
17:22:25 <dyl> They mess my code up more than they help.
17:22:30 <sm> apt install haskell-stack; stack upgrade is maybe the easiest
17:22:38 <Welkin> if you are brand new to haskell, why would you prefer stack or even know it exists?
17:22:41 <Welkin> that is odd
17:22:42 <MarcelineVQ> If that route interests you I'll find the bin link
17:22:58 <lightstep> I didn't use haskell or ubuntu for 2-3 years, getting back now...
17:23:10 <Welkin> well stack is no good anymore
17:23:18 <MarcelineVQ> sm's idea is also a good one, you can upgrade (which will put stack in ~/.local/bin so you'll want your path set there) and then you could remove the system package after
17:23:19 <Welkin> we've moved on to new cabal
17:23:57 <Welkin> lightstep: https://www.haskell.org/cabal/users-guide/nix-local-build-overview.html
17:24:11 <lightstep> if stack is not well maintained then i'll go with the platform
17:25:10 <lightstep> i recall ubuntu having very outdated ghc versions in the official packages
17:25:12 <Solonarv> they're both well-maintained, but cabal has gotten over many of the shortcomings that used to push people to stack instead
17:25:13 <MarcelineVQ> I've not had issues with it being maintained. In fact when​I have issues an upgrade usually solves them, which means it's actively maintained
17:25:23 <fryguybob> MarcelineVQ: I can explain the dirty/clean part of MVar if you are interested.
17:25:30 <MarcelineVQ> fryguybob: yes please
17:25:37 <MarcelineVQ> And anything else you feel like :>
17:26:55 <fryguybob> GHC's GC is generational, long living heap objects are promoted to an older generation (heap) which is collected less often.
17:26:58 <lightstep> mmm haskell-platform brings ghc 8.0.2, that's no good
17:27:09 <sm> lightstep: using stack solves that problem
17:27:15 <fryguybob> This is fine for imutable objects, but a problem for mutable objects.
17:27:29 <Solonarv> using ghcup also solves that problem :>
17:27:30 <sm> haskell-platform includes stack. But also other stuff
17:28:02 <fryguybob> If an object is in the older generation and it is mutated to point to a value in a younger generation, it would be collected when the young generation is collected unless we do something to prevent this.
17:28:15 <MarcelineVQ> Ah so it is about GC, and so the "mutable list" referred to in stg_newMVarzh is the GC's
17:28:26 <Welkin> lightstep: https://www.haskell.org/platform/linux.html
17:28:32 <Welkin> haskell platform has the latest ghc 8.6.3
17:28:47 <fryguybob> Yes.  GHC's solution is to add objects to a mutable list when they are mutated.
17:28:56 <fryguybob> But, we only need to add them once.
17:29:26 <fryguybob> So mutable objects have two possible info tables, dirty and clean.  Dirty means it has already been put on the mutable list.  Clean has not yet.
17:29:47 <fryguybob> This (mostly) prevents duplicate entries on the mutable list.
17:29:48 <dyl> lightstep personally, I just install ghc (8.4.4 or 8.6.3, perhaps).
17:29:57 <dyl> And then I install cabal-install, and then I use cabal to update cabal.
17:30:25 <dyl> ¯\_(ツ)_/¯ 
17:30:44 <MarcelineVQ> fryguybob: That's quite clear thank you
17:30:53 <fryguybob> MarcelineVQ: No problem.
17:31:08 <MarcelineVQ> it entirely explains "// MVARs start dirty: generation 0 has no mutable list"
17:38:35 <dyl> Silly question:
17:39:07 <dyl> What is a concise form for an applicative parser which has one predicate for the first character, and another for the rest, where these ultimately form a single string?
17:39:34 <MarcelineVQ> liftA2 (:)
17:39:35 <dyl> (using Applicative notation, not do)
17:39:41 <dyl> MarcelineVQ oh, yeah, that'd do it :p.
17:39:51 <Welkin> dyl: look at prolog parsers :D
17:39:54 <Welkin> or ragel
17:39:56 <dyl> I'M WRITING ONE.
17:40:05 <dyl> >:|
17:40:06 <Welkin> no, I mean, prolog for writing your parser
17:40:15 <dyl> Oh, yeah, I'll get there.
17:40:27 <dyl> First I have to write a parser for my prolog, then I can use my prolog to write parsers :)
17:40:36 <Welkin> https://www.colm.net/open-source/ragel/
17:40:39 * dyl is implementing the Warren Abstract Machine.
17:40:43 <dyl> Also yeah, Ragel is awesome.
17:41:12 <Welkin> why are you writing a prolog?
17:41:40 <zachk> logic programming languages seem to be trendy lately with haskellers
17:41:43 <Welkin> what's wrong with swi-prolog or mercury?
17:41:50 <Welkin> zachk: they are cooloer o.o
17:42:01 <Welkin> haksell feels, I don't know, boring?
17:42:03 <zachk> wish prolog had better lambdas 
17:42:17 <dyl> I'm using SWI-prolog in my research.
17:42:26 <dyl> So I'm writing a prolog in my spare time to learn prolog better.
17:43:05 <Welkin> erlang lambas are ust like haskell ones
17:43:47 <Welkin> also I've noticed more and more that julia is really a lisp
17:44:07 <Welkin> `3 + 4 + 5 + 6` is transformed into `+(3,4,5,6)`
17:44:10 <zachk> dyl, curious, what research are you doing the uses prolog?
17:44:38 <dyl> The prolog bit is more a means to an end :p.
17:44:51 <zachk> iirc julia uses femtolisp underneath for its parser, or it used to at least 
17:44:55 <Welkin> yes
17:45:00 <Welkin> I was reading the source today
17:45:03 <zachk> dyl, which end? or is it hush hush 
17:45:04 <dyl> But, roughly speaking: automating synthesis of linear constraint based layouts.
17:45:05 <Welkin> it still does
17:45:18 <dyl> The prolog is useful for munging together a bunch of facts I extract from view hierarchies and other inputs.
17:45:24 <dyl> (we*)
17:45:24 <zachk> circuit board layouts? 
17:45:33 <Welkin> zachk: julia is also homoiconic, so it really is a lisp
17:45:33 <dyl> No, think AutoLayout/ConstraintLayout.
17:45:52 <zachk> don't know what a layout is in that sense, like a plan?
17:46:10 <dyl> It's a set of linear integer constraints, more or less.
17:46:14 <dyl> (see: cassowary)
17:46:26 <Welkin> you don't want to write an operating systems with it?
17:46:29 <dyl> The goal is to be able to take a bunch of layout mockups (think tagged view hierarchies) for different screen conformations, and generate a constraint set for them.
17:46:31 <Welkin> you can make the next multics!
17:47:16 <dyl> Random question.
17:47:29 <dyl> Does anyone else remember the `f . g . h $ x` pattern as "dot dot goose"?
17:47:42 <zachk> i use that pattern a lot, but no
17:47:55 <zachk> maybe dot dot noose?
17:48:17 <Welkin> oh oh!
17:48:23 * ski . o O ( `(f . g . h) x' )
17:48:43 <Welkin> and you can compose functions in julia, and create pipelines with reverse application
17:48:46 <Welkin> :D
17:48:57 <Welkin> haha
17:49:01 <Welkin> the $ is a goose?
17:51:38 <MarcelineVQ> dyl: the family of . compositions do have bird names for some reason http://hackage.haskell.org/package/data-aviary-0.4.0/docs/Data-Aviary-Birds.html
17:51:40 <Bleant> Hello, I'm a beginner! Can anyone tell me what the "Import <module> (<data> (..))" syntax does?
17:51:55 <dyl> MarcelineVQ the only one I often use is the kestrel :/.
17:51:58 <ski> zachk : there's lambdaProlog. good for HOAS (including matching under binders). but the lambdas there can't do arbitrary computation. however Mercury has function (and predicate) abstraction terms (but no matching on / unification of lambdas, otoh)
17:52:23 <Solonarv> Bleant: it imports the type <data> as well as all its constructors and fields
17:52:47 <ski> Bleant : import the type constructor `<data>' from `<module>', but also all its data constructors (and fields / field extractors)
17:52:53 <thebnq> some of those remind me of car cadr caar caddr etc
17:53:07 <Solonarv> e.g. if you have: module Foo where data Bar = Bar1 | Bar2 { aField :: Int }
17:53:12 <ski> (or, in case `<data>' is a type class, imports all its members)
17:53:13 <Bleant> Solonarv: Thanks!
17:53:23 <Bleant> ski: Thanks as well!
17:53:26 <zachk> ski, HOAS? I was looking at lambda prolog last week and teyjus seems broken, needs omake which I couldnt get my hands on :( 
17:53:45 <ski> zachk : Higher-Order Abstract Syntax
17:53:54 <Solonarv> then 'import Foo (Bar(..))' will bring into scope: the type Bar, as well as the constructors Bar1 and Bar2 and the record field aField
17:54:15 <zachk> ski, which lambda prolog implementation would you recommend in this day and age?
17:54:23 <Welkin> erlang
17:54:35 <Bleant> Do you think this could be considered a bad practice since it hides the origin of a lot of names you might see in code below the import?
17:54:39 <Solonarv> you can also import only specific constructors: 'import Foo(Bar(Bar1))' will only import Bar and its Bar1 constructor
17:54:42 <ski> zachk : in Haskell, `data Expr = App Expr Expr | Abs (Expr -> Expr)' is problematic, because you can't match on lambdas. but you can, in lambdaProlog (and Twelf)
17:55:05 <Solonarv> Eh, it depends. Usually for types it's fairly clear where they come from, IMO
17:55:23 <Solonarv> a common pattern is: import Data.Set (Set); import qualified Data.Set as Set
17:55:44 <ski> zachk : i haven't used it for some years. i used Terzo (interpreter in SML), but iiuc Teyjus is meant to be more efficient
17:55:56 <Solonarv> now the Set type is in scope unqualified, and all the related functions are in scope as Set.whatever
17:56:00 <Bleant> I see, thanks a lot!
17:56:37 <ski> (also you can match on (/analyze/inspect) *code* lambdas, in MetaML, but not, iiuc, in MetaOCaml)
17:58:03 <Solonarv> Bleant: additionally, if multiple things with the same name are in scope and you refer to that name, you get a compiler error - not sneaky behavior where one is picked over the other
17:58:47 <Solonarv> % import Data.Set
17:58:47 <yahb> Solonarv: 
17:58:50 <Solonarv> % :t map
17:58:50 <yahb> Solonarv: ; <interactive>:1:1: error:; Ambiguous occurrence `map'; It could refer to either `S.map', imported from `Data.Set' (and originally defined in `Data.Set.Internal'); or `Prelude.map', imported from `Prelude' (and originally defined in `GHC.Base'); or `T.map', imported from `Data.Text'
17:59:06 <Solonarv> % :m - Data.Set
17:59:06 <yahb> Solonarv: 
18:03:40 <dyl> Does anyone know how to get a greedy "many" with Text.Earley?
18:04:05 <dyl> λ> fullParses (parser tokenG) "foo"
18:04:06 <dyl> ([[Atom "fo",Atom "o"],[Atom "foo"],[Atom "f",Atom "o",Atom "o"],[Atom "f",Atom "oo"]],Report {position = 3, expected = ["","variable","atom"], unconsumed = ""})
18:04:08 <dyl> Not what I want :p.
18:06:30 <foobarbazquux> I'm taking a look through Paul Hudak's "Haskell School Of Music", and on pg 2 he describes a distinction between discrete notes and continuous signals (for sound output). Is the book based on functional reactive programming?
18:06:35 <foobarbazquux> It doesn't reference the term AFAICT, but the ideas seem the same. Plus, didn't he co-invent it with Conal Elliot?
18:07:15 <Bleant> Solonarv: yeah, if you could import more than one it would get pretty messy
18:07:48 <conal> foobarbazquux: I had developed Fran/FRP when I met Paul Hudak. He took quite a liking to it and led a lot of follow-on work at Yale.
18:08:27 <dmwit> dyl: Isn't the point of Early parsing that you get all parses?
18:08:28 <foobarbazquux> conal: Thanks for the clarification.
18:08:37 <dmwit> dyl: In that setting, what does "greedy" even mean?
18:08:48 <dyl> dmwit getting all parses is well and good, but I want to distinguish a particular one.
18:08:50 <conal> foobarbazquux: you bet!
18:08:54 <dyl> Perhaps my grammar is bad though.
18:09:03 <dmwit> foobarbazquux: There is a fair bit of FRP later in the book.
18:09:14 <dyl> dmwit https://gist.github.com/DylanLukes/db4a92b78f4185895f6936037a233bef
18:09:22 <dyl> idk why I lost the indents... one moment
18:09:58 <dmwit> If you want a specific one... write a grammar that isn't ambiguous?
18:10:03 <foobarbazquux> dmwit: Isn't it only packrat parsing which is linear on generic CFGs but chooses only one of the possible parses? I thought GLR also returned multiple parses like the Earley algorithm.
18:10:08 <dyl> dmwit yeah :/.
18:10:19 <dyl> I'm using "greedy" to refer to a particular disambiguation.
18:10:29 <dyl> But I don't know how to translate maximal munch to Earley.
18:10:55 <dmwit> I don't think Earley parsing has a convenient disambiguation mechanism. You have to write the grammar you mean, not one you didn't mean + some annotations.
18:11:25 <dmwit> Other formalisms do have such mechanisms, but Earley is very tied to the basic theory.
18:11:45 <dyl> Any thoughts on what I might want to do here?
18:12:37 <dmwit> Tokenize separately is the usual way.
18:12:46 <dyl> This *is* the separate tokenizer :p.
18:12:54 <dyl> I was just seeing if I could do it using Earley...
18:13:04 <dyl> But I might just handroll a lexer if it won't work :(.
18:13:12 <dmwit> Oh. Then demand that the character following an Atom token not be a valid atom character.
18:13:19 * ski . o O ( if you place two greedy parsers next to each other, who wins the tug-of-war ? )
18:13:49 <Welkin> the sloth 
18:14:05 <dyl> I'll have to write a new primitive methinks.
18:14:12 <Welkin> dyl: you make it sound like you are baking criossants
18:14:21 <dyl> I wish.
18:14:28 <Welkin> croicroissants
18:14:34 <Welkin> croissants
18:14:36 <Welkin> o.o
18:14:58 <Welkin> watch that french guy on youtube
18:15:03 <Welkin> he makes them from scratch
18:15:43 <dyl> I need a primitive to match a non-char without consuming it.
18:15:54 <dyl> Using manyTill from Control.Applicative.Combinators causes a hang :(
18:15:59 * ski twitches
18:16:14 <dyl> non-atom char*
18:16:14 <dmwit> dyl: Are you *sure* that `many (some (satisfy isSpace))` ys what you want??
18:16:36 <dyl> dmwit it should just be many :p, and also needs to ensure a non-ws character at the end also... or EOF.
18:16:38 <dmwit> Especially since you're throwing away the result of that parser it looks odd.
18:16:46 <dyl> I want to throw it away :p.
18:16:53 <Welkin> wasteful
18:16:55 <dmwit> Yes, I understand throwing it away.
18:17:07 <dmwit> I can also understand `many (some`.
18:17:13 <dmwit> I can't understand throw it away + `many (some`
18:17:20 <Welkin> there are starving parsers in this world
18:17:26 <dyl> dmwit I'm not sure I follow.
18:17:29 <Welkin> and you just throw perfectly good characters away
18:18:28 <dmwit> Anyway, I would guess that what you really intend here is for atoms and variables to be terminated by whitespace (or EOF, as you say).
18:18:44 <dmwit> In which case the ambiguity you showed above completely disappears.
18:18:56 <Welkin> but wait
18:19:00 <Welkin> atoms can have whitespace
18:19:02 <dmwit> Currently you allow them to be terminated by zero occurrences of whitespace, and this is the source of your ambiguity.
18:19:03 <Welkin> they can contains anything
18:19:09 <Welkin> 'This is an atom.'
18:19:12 <ski> dmwit : or brackets
18:19:22 <dmwit> Perhaps. Depends on the goals.
18:19:30 <Welkin> you wrap them in single quotes
18:19:43 <dmwit> Welkin: The current code does not appear to support that.
18:19:43 <dyl> Welkin I’m not handling quoted atoms yet. 
18:19:55 <dyl> It’s on the list, but first I want to get this minimal thing working.
18:20:55 <dyl> dmwit: I don’t actually want to require at least one ws afterwards though. 
18:21:06 <dyl> e.g. a+b 
18:21:14 <Welkin> also function names
18:21:19 <Welkin> an_atom(...)
18:21:24 <dyl> So I need some way to match a non-atom/var character at the end without consuming it.
18:21:30 <Welkin> and an_atom/2
18:21:44 <dyl> I’ve had this problem with Antlr too actually :/.
18:21:52 <Welkin> what's that?
18:22:07 <dyl> Neither here nor there.
18:22:28 <Welkin> but anywhere
18:22:30 <dyl> I think Earley is just not well suited to writing a lever, I’d be better served just hand rolling it, especially given how simple this one is.
18:22:33 <dmwit> dyl: Yes, change your grammar from `many (atom <|> var)` to `foo = liftA2 (:) (atom <|> var) (someProductionWhichGuaranteesThatTheFirstCharacterIsNotValidAsAnAtomOrVar)`.
18:22:37 <Welkin> in ab ox, or with a fox
18:22:39 <Welkin> :D
18:22:48 <dyl> It’s what that is that’s the trouble dmwit :p
18:22:48 <Welkin> with a mouse, or in a house
18:23:07 <dyl> I’ll have to muck around in Earley’s internals to work out how to write that primitive combinator.
18:23:15 <dmwit> Why is that hard? You can use `ws <|> parens <|> operator <|> whatever`
18:23:46 <dmwit> I mean `liftA2 (++) (ws <|> parens <|> ...) foo`, of course, where `foo` is from before.
18:23:55 <Welkin> you could always give up and make a prolog lisp
18:23:57 <dyl> It would consume the character. 
18:24:04 <dmwit> What is "it"?
18:24:16 <Welkin> the thing from stephen king's novel
18:24:30 <dyl> I think I’m thinking of this in a different manner. 
18:24:34 <Welkin> that's the origin of `it` in perl too
18:25:23 <dmwit> dyl: You should fix that problem! =P
18:25:25 <dyl> Then I’d end up with a grammar where nearly every rule includes all of the other rules as it’s last nonterminal.
18:25:30 <dyl> Which seems silly :p
18:25:31 <dmwit> Think of it like I do, then it will be easy.
18:25:58 <dyl> \me . o O (assimilate) 
18:26:00 <dmwit> Not every other rule. Only the other rules that wouldn't cause an ambiguity.
18:26:27 <dyl> That smells a bit funny. 
18:26:33 <dmwit> And yes, regular expressions are exactly those CFGs whose rules have at most one nonterminal and where that nonterminal appears last.
18:26:42 <dyl> :| 
18:26:46 <dyl> That is a great point. 
18:28:45 <dmwit> Hm. "Exactly" is probably too strong a claim. But that form of CFG always produces a regular language and is sufficient to cover all regular languages, anyway.
18:30:27 <dmwit> Yes, definitely too strong. e.g. you get a regular language out of S -> x | SSx which breaks both rules.
18:32:31 <dyl> I think I’m going to just write my lexer as a big nasty regex instead :p
18:32:55 * Solonarv waves towards regex-applicative
18:34:02 <Welkin> a tyranosaurus regex!
18:34:22 <Welkin> that's pretty close to regis
18:34:52 <jackdk> there are depressingly few search results for such a good pun
18:41:36 <Welkin> needs more comic strips
18:42:25 <dmwit> Solonarv: Hey, that's the same suggestion I made about six hours ago!
18:47:14 <ski> dmwit : perhaps each regular language *can* be presented in such a way ?
18:48:04 <dmwit> Yes, all such grammars are regular and all regular languages are covered by such grammars.
18:53:33 <siraben> I'm reading through the paper "Composing Monads Using Coproducts" and couldn't get the code to work: https://ptpb.pw/hDH7
18:53:52 <siraben> What language extensions must I enable?
18:54:14 <Welkin> -XKitchenSink
18:55:04 <jackdk> we used to call that `-fglasgow-exts`
18:55:28 <siraben> Do I pass that to ghci?
18:55:47 <siraben> Can I enable it within ghci?
18:55:49 <dmwit> siraben: At least here, the error is very clear about what's gone wrong.
18:55:56 <dmwit> It has nothing to do with extensions at all.
18:56:25 <siraben> It says I should add " add (Applicative f) to the context of the instance declaration"
18:56:47 <Solonarv> siraben: -XKitchenSink isn't real, and -fglasgow-exts is deprecated/discouraged
18:57:00 <dmwit> That's not what it says here.
18:57:13 <Welkin> Solonarv: you're not real!
18:57:18 <dmwit> I propose that this is not the code you are loading.
18:57:19 <siraben> So how do I undefine monad?
18:57:23 <Welkin> but lambdabot is a real boy!
18:57:27 <siraben> I want to use my own monad class
18:57:30 <dmwit> In particular I propose you have not included the `class Monad` bit shown here.
18:57:43 <Solonarv> 'import Prelude hiding (Monad(..))' will hide it
18:57:57 <Welkin> that won't hide instances
18:58:10 <Welkin> you have to use NoImplicitPrelude
18:58:12 <dmwit> If I am correct, then you can fix your problem just by adding `instance Triple f => Applicative f where pure = return; (<*>) = ap` and yes this is frustrating that things have changed in this way since whatever you're reading was written.
18:58:13 <Welkin> but then you can't do anything
18:58:27 <dmwit> You don't need to hide instances.
18:58:28 <Welkin> use BulbasaurMonad
18:58:29 <siraben> This seems to fix it: https://ptpb.pw/ZXe5
18:59:05 <Welkin> or evev Moonad
18:59:06 <Solonarv> If you also want do notation to be desugared using *your* >>= and >> you will additionally need the RebindableSyntax extension
18:59:36 <Welkin> of course you'll need a complementary Marsnad
19:01:09 <dmwit> Welkin: Really. You don't need to hide the instances. No need to use a different name.
19:01:21 <Welkin> :(
19:01:28 <Welkin> <:(
19:02:15 <Welkin> ∑:(
19:02:28 <ski> Welkin : a tomboy ?
19:05:06 <lightstep> The state of haskell tooling is awesome - my editor's haskell plugin automatically computes the type of each term I highlight :)))
19:15:24 <maerwald> what?!?!
19:15:41 <maerwald> You must be on emacs then
19:15:48 <lightstep> vs-code
19:16:03 <maerwald> hie?
19:16:26 <lightstep> i discovered this editor some months ago, it's a sublime clone by microsoft
19:16:50 <Solonarv> intero actually worked fairly well when I used it, I only stopped because it ties you to stack and I stopped using that
19:16:54 <Welkin> it's an atom derivitive
19:17:08 <Welkin> there is vscodium which strips out the tracking/spying
19:17:22 <Welkin> I still like emacs best
19:17:23 <Solonarv> it's significantly better than atom IME (doesn't tax my laptop nearly as much)
19:17:35 <Welkin> guis freak me out
19:17:55 <Solonarv> but I think maerwald was asking which editor plugin you're using
19:18:01 <Welkin> I can't do anything/feel helpless in a gui
19:18:02 <Solonarv> (there are several available)
19:18:05 <lightstep> oh, this one https://github.com/dramforever/vscode-ghc-simple
19:18:48 <lightstep> i installed the top 2 search results for haskell plugins
19:18:51 <maerwald> intero crashes my laptop
19:19:13 <maerwald> hie I just cannot get to work correctly with vim, it's a messy project currently
19:19:37 <maerwald> ghc-mod worked well, but cabal new-* support is still pending
19:19:45 <maerwald> dante is emacs only
19:20:17 <Solonarv> doesn't ghc-mod lag behind a ghc version or two
19:20:30 <Solonarv> lightstep: oh, I don't believe I've seen that plugin before!
19:22:54 <maerwald> that too
19:23:00 <foobarbazquux> I'm test-driving Haskell setups for Emacs right now.
19:23:07 * hackage airship 0.9.4 - A Webmachine-inspired HTTP library  https://hackage.haskell.org/package/airship-0.9.4 (lambda_foo)
19:23:17 <foobarbazquux> I just tried Intero. No-go. It froze emacs, and that's unacceptable because Emacs is my window manager.
19:23:19 <maerwald> tooling, ime, is one of the weakest parts of haskell
19:23:42 <maerwald> especially as the codebase grows, various tools just blow up
19:24:13 <maerwald> codex/hasktags will fail to parse some of your files, intero type preloading will trigger your OOM
19:24:28 <foobarbazquux> If they made use of Emacs 26.1's threads to load Stack in the background and loaded the rest incrementally via use-package, that would be fine. As it stands, I looked in Intero's source and saw one big (require 'intero) which dumps everything.
19:24:45 <foobarbazquux> (It was a speed reading, so correct me if I'm wrong)
19:26:00 <MarcelineVQ> do try out dante if you're using emacs
19:26:16 <MarcelineVQ> oh it was mentioned
19:27:37 <foobarbazquux> MarcelineVQ: That's going to be my next test run. I'm looking for a good setup guide. Is there a way to load code into the REPL besides the comment feature? While cool, I'd like to send blocks like how I do with Common Lisp or Python.
19:27:41 <foobarbazquux> (I couldn't find out how on the Github page)
19:28:48 <MarcelineVQ> no clue about that, I've little emacsexperience
19:42:10 <foobarbazquux> Does anyone use Intero? I always see recommendations for Dante instead.
19:42:40 <glguy> People tend to recommend intero as it isn't locked in with stack and is pretty easy to get set up
19:42:44 <glguy> err,
19:42:55 <glguy> People tend to recommend dante over intero as it isn't locked in with stack and is pretty easy to get set up
19:42:56 <foobarbazquux> I see what you meant to say
19:45:31 <foobarbazquux> My question was more about who does use Intero and why.
19:53:38 <maerwald> People tend to recommend intero as it isn't locked in with emacs ;D
19:55:43 <jackdk> I used it for a little while, but then I got sick of it rebuilding itself and needed to work on nixified haskell packages (reflex-platform stuff). Stack is too limited for my needs these days
20:15:49 <maerwald> rebuilding itself?
20:23:05 <zuserm> laser cut earrings made with Diagrams: https://raw.githubusercontent.com/bacchanalia/lasercuts/master/compassearringsphoto.jpg
20:31:17 <shapr> wow, real world stuff made with Haskell!
20:33:04 <zuserm> Real World Haskell is already a thing, so I think of it as Meat Space Haskell
20:33:25 <Solonarv> in my mind, that was the joke
20:36:46 <DigitalKiwi> shapr is all about that rust now 
20:50:24 <Axman6> zuserm: noice
21:54:29 <dminuoso> How do you folks respond when you hear claims like "Haskell was made to avoid success, it's only a research language"?
21:55:37 <geekosaur> "…in the early 1990s"
21:56:00 <geekosaur> PHP wasn't created to be a general programming language either
21:56:22 <dminuoso> Ive been pondering about an argument that goes along the lines of 
21:56:38 <dminuoso> "Wouldn't you want a language that was well founded in practice *and* theory?
21:57:03 <dminuoso> geekosaur: But yeah, I guess that's a valid point.
21:58:12 <cocreature> dminuoso: mostly I don’t because I’m not that interested in trying to convert people to Haskell. if they’re interested I’m happy to teach them, if they’re not there are enough people that are so I’d rather spend my time helping those
21:58:19 <geekosaur> and it's hard to argue that ghc is Haskell 1.0
21:58:43 <geekosaur> and yes, there's also that; if someone wants excuses to not learn something, that's because they're afraid of learning something new
22:00:55 <dminuoso> cocreature: Interesting.
22:01:22 <dibblego> I don't. They have just announced that they have no idea what they are talking about.
22:01:29 <dmwit> I think my personal response would be to ask what "research language" means.
22:01:31 <MarcelineVQ> my own pov tends towards: Share something you're excited about, don't be a sales rep.
22:02:36 <dmwit> There's probably some implicit assumptions in that claim that aren't warranted.
22:02:54 <dmwit> Things like, "it is a research language and therefore not suitable for X".
22:03:27 <dmwit> There's probably also some implicit assumptions that do turn out to be warranted, like "it's a research language and therefore doesn't have a lot of manpower on developing feature X".
22:03:28 <geekosaur> theres some ancient and long-irrelevant history in it. like it being a replacement for the commercial Miranda, to which that did apply
22:03:30 <dibblego> if I wanted to take the piss, something like, "C# took the practicel bits out of monads, so as to be practical, and not research amirite?"
22:04:20 <dmwit> Seems like it would be fun to explore those assumptions with somebody for a little while.
22:05:09 <MarcelineVQ> obstacle one in that convo, "what does production ready mean?"
22:05:19 <dmwit> (N.B. I'm not claiming Haskell is suitable for everything, just that "it's a research language" does not imply "unsuitable".)
22:05:58 <geekosaur> it's one of those "what I point to when I say it" things
22:06:28 <dmwit> It's funny that you see that as an obstacle. I see it as a jumping-off point.
22:06:38 * hackage geodetic-types 0.0.2 - Types for geodetic operations  https://hackage.haskell.org/package/geodetic-types-0.0.2 (qfpl)
22:06:46 <dibblego> it means this, "wasn't taught at my undergrad, and my buddies don't get it either"
22:07:01 <dminuoso> To me "a research language" is a feature, in that the language is studyable. It has clean semantics that theorists can reason about, but that's just me..
22:08:20 <geekosaur> dibblego, I'd love to see that one applied to C++ by someone whose UG was in python
22:10:07 <dibblego> in writing a python AST, I have learned that nobody actually knows python
22:10:23 <inkbottle> "Non type-variable argument in the constraint", l.18, https://paste.debian.net/1070811/ (ch16/csv2.hs), I have no clue about what that could mean
22:10:56 <dminuoso> inkbottle: Can you include the full error message in the gist?
22:11:24 <cocreature> dminuoso: the only time where I could see myself trying to convince someone of my preferred technology (holds for Haskell but also for other things) is if I want to convince my boss. Surprisingly, Neil Mitchell is quite open to the idea of using Haskell so I don’t have to do much convincing atm :)
22:11:53 <dmwit> inkbottle: Usually it means you have a constraint like `StreamLike String` or something and you need to turn on an extension (the error says which one).
22:11:59 <dminuoso> cocreature: Oh heh. :)
22:12:35 <inkbottle> https://paste.debian.net/1070812/
22:12:53 <dmwit> called it
22:13:57 <inkbottle> ^ included the full error message
22:14:15 <dminuoso> inkbottle: Enable the extension FlexibleContexts? :)
22:14:47 <inkbottle> OK, I try that, but I don't understand what that means
22:15:05 <dminuoso> inkbottle: GHC infers a constraint `Stream s m Char => ...`
22:15:31 <dminuoso> inkbottle: Now in standard haskell that `Char` there is not allowed, as all constraints must be of the form: `C t1 t2 t3 ...` where t_n are type variables.
22:15:40 <dmwit> The GHC manual is usually pretty good at explaining what an extension means and why it's useful to have around (although not always why the language didn't originally include that extension...).
22:16:27 <dminuoso> inkbottle: Char is not a type variable. For historic reasons this was not allowed, but its perfectly safe to lift this restriction. FlexibleContexts allows a constraint to have a non-type variable in any of the t_n positions.
22:16:57 <inkbottle> dminuoso: OK, I'll loo into that ;)
22:17:02 <inkbottle> look*
22:18:05 <koz_> dminuoso: Are the historical reasons efficiency-related?
22:18:23 <dminuoso> koz_: I do not know
22:18:34 <dminuoso> koz_: But I believe it was a technical limitation at the time.
22:18:41 <koz_> Ah.
22:18:52 <koz_> I'd be curious which SPJ paper resolved it.
22:18:59 <koz_> (because I suspect it was an SPJ paper)
22:19:19 <cocreature> without MultiParamTypeClasses it also tends to be far less useful
22:20:10 <Axman6> dminuoso: I assume you point out the proper bracketing of "avoid success at all costs" "avoid (success at all costs)" and not "(avoid success) at all costs"
22:21:01 <Axman6> is*
22:21:54 <dminuoso> koz_: While SPJ writes many papers, he is not the only author of type system related papers you know..
22:22:19 <koz_> dminuoso: I'm sure, but given that it's Haskell-related, I'd be surprised if he _didn't_ have a hand in that one.
22:22:41 <koz_> (and actually, he is close to the only author of type system related papers _I_ know :P)
22:26:13 <dminuoso> koz_: Weirich, Meijer, Mark P. Jones, Wadler.. there's plenty. :)
22:26:32 <koz_> I know... some of those names. Not Weirich, unless I'm forgetting something big.
22:26:51 <coldpress> is the famous pandoc-lens an attempt to make only one module per format, instead of two modules (Reader, Writer)?
22:27:15 <dminuoso> koz_: https://www.microsoft.com/en-us/research/wp-content/uploads/1997/01/multi.pdf
22:27:23 <dminuoso> koz_: Turns out SPJ had his hands in it after all. ;)
22:27:31 <koz_> dminuoso: DUN DUN DUUUUUUUUUUN
22:27:52 <dminuoso> Guess Ill read that paper on the train. :)
22:27:52 <cocreature> koz_: Stephanie Weirich was (among tons of other work) Richard’s PHD advisor so she’s involved in dependent Haskell
22:28:11 <koz_> Ah, _that's_ where I've heard the name.
22:28:19 <koz_> Thanks for reminding me.
22:29:11 <cocreature> koz_: if you look at https://www.cis.upenn.edu/~sweirich/publications.html I’m sure you’ve seen quite a few of those papers or at least the corresponding Haskell features :)
22:29:24 <koz_> cocreature: Cool, I may just do that.
22:30:34 <cocreature> “Boxes Go Bananas” pl papers sure have weird titles
22:42:46 <koz_> cocreature: Yeah... and weird everything else, if you're Conor McBride.
