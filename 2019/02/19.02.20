00:00:01 <koz_> Wow, that's a really neat link.
00:03:36 <ar1a> can anyone help me find some write ups? I'm looking to implement a 2d binpacking algorithm. The bin is a fixed size, and you can rotate each object 90 degrees. I'm awful bad at googlefu like this, and the one article i found was extremely imperative it was hard to port over since I'm so new to haskell
00:47:39 <lunabo> ar1a: what kind of algorithm is it? Dynamic programming?
00:48:16 <ar1a> lunabo: not sure honestly. theres some info here https://en.wikipedia.org/wiki/Bin_packing_problem
00:49:21 <ar1a> most of the info i can find is on 1d bin packing though
00:54:30 <maerwald> is there a safe way to convert 100.15 to 10015? Something like "something . fromRational . toRational"?
00:57:16 <maerwald> > fromEnum (fromRational ((toRational 100.15) * 100) :: Float) :: Int
00:57:18 <lambdabot>  10015
00:57:28 <lunabo> ar1a: I asked because sometimes you can do dynamic programming in Haskell using laziness and memoization (there are some things you can find if you Google around a bit about this).
00:57:29 <maerwald> but now I have an Int, not Integer :>
00:57:58 <ar1a> lunabo: it was more inplace stuff with mutable variables on each loop and whatnot
01:00:02 <dstromboli> Howdy all. I'm trying to write a show function that requires indenting the output based on the value of an int, and I'm not sure how to go about it.
01:00:10 <maerwald> > truncate ((toRational 100.15) * 100)
01:00:11 <lambdabot>  10015
01:00:24 <maerwald> > truncate ((toRational 4321.15) * 100)
01:00:27 <lambdabot>  432114
01:00:31 <maerwald> that's not funny...
01:00:56 <dstromboli> For instance, if i = 2 then "    " ++ show a... if i = 3 then "      " ++ show a... etc
01:14:01 <afidegnum> hello, is there a way to learn or improve math skills using haskell? is there any related books?
01:14:16 <lunabo> ar1a: right, which could be dynamic programming since that is often implemented using loops and arrays. You could also mimic the imperative implementation in Haskell using ST, at least to get an understanding of why it works, and then translate it to a more functional style
01:15:47 <lunabo> maerwald: binary float representation :)
01:16:33 <slaterr> you asked to truncate, then complained when it did
01:17:43 <slaterr> > truncate 4.9999999999
01:17:45 <lambdabot>  4
01:18:10 <Taneb> afidegnum: there's "The Haskell Road to Logic, Math, and Programming"
01:18:56 <afidegnum> ok, thanks, let me look at it
01:20:41 <afidegnum> Taneb: does it allow to learn Haskell as well or this book is for Intermediate/Advanced hackelists ? 
01:20:51 <afidegnum> **Haskellists :)
01:21:06 <Taneb> afidegnum: I believe so
01:21:20 <Taneb> It might be a bit dated, though
01:21:33 <Taneb> Things have changed in the past fifteen years or so :P
01:22:29 <Taneb> (although not all that much)
01:28:55 <jgt1> We prefer the term 'Haskellitionists'
01:30:11 <Ariakenom> maerwald: that may still be safe since that isn't exactly 0.15
01:30:15 <Ariakenom> % toRational (0.15 :: Double) == (0.15 :: Rational)
01:30:16 <yahb> Ariakenom: False
01:30:42 <maerwald> Scientific seems to be better
01:31:03 <Ariakenom> really, why?
01:31:28 <maerwald> because it works
01:31:34 <maerwald> And protectes from unbounded input
01:34:06 <Axman6> % 1.23456789082639623109612309856091374509867134095867134095867 :: Scientific
01:34:07 <yahb> Axman6: ; <interactive>:54:66: error: Not in scope: type constructor or class `Scientific'
01:34:13 <Axman6> :(
01:34:43 <Axman6> % 1.23456789082639623109612309856091374509867134095867134095867 :: Data.Scientific.Scientific
01:34:43 <yahb> Axman6: ; <interactive>:56:66: error:; Not in scope: type constructor or class `Data.Scientific.Scientific'; No module named `Data.Scientific' is imported.
01:35:03 <Axman6> % import Data.Scientific
01:35:04 <yahb> Axman6: ; <no location info>: error:; Could not find module `Data.Scientific'; It is not a module in the current program, or in any known package.
01:35:18 <Axman6> you're the worst
01:38:09 <Ariakenom> maerwald: Why does it work? Should be the same as Rational afaict.
01:39:07 * hackage http-client 0.6.1.1 - An HTTP client engine  https://hackage.haskell.org/package/http-client-0.6.1.1 (MichaelSnoyman)
01:39:20 <maerwald> slaterr: no, there is nothing to truncate
01:39:56 <Ariakenom> 0.15::Double is not the fractional number 0.15
01:40:18 <maerwald> look at it, I multiply with 100 :)
01:40:31 <kuribas> > 15 % 100
01:40:34 <lambdabot>  3 % 20
01:40:36 <maerwald> there is nothing to truncate, the conversions are just lossy. So truncate converts to Double or something
01:40:40 <Ariakenom> 0.15::Rational is the fractional number 0.15
01:40:55 <maerwald> no one said that
01:40:56 <Taneb> > 0.15 :: Rational
01:40:58 <lambdabot>  3 % 20
01:41:09 <maerwald> > > (toRational 4321.15) * 100 :: Double
01:41:10 <lambdabot>  <hint>:1:1: error: parse error on input ‘>’
01:41:18 <maerwald> > (toRational 4321.15) * 100 :: Double
01:41:20 <lambdabot>  error:
01:41:20 <lambdabot>      • Couldn't match type ‘Ratio Integer’ with ‘Double’
01:41:20 <lambdabot>        Expected type: Double
01:41:22 <kuribas> What 0.15 internally?  15 / 100 ?
01:41:24 <Taneb> > (4231.15 :: Rational) * 100
01:41:26 <lambdabot>  423115 % 1
01:41:29 <maerwald> yep
01:41:32 <maerwald> and now truncate that
01:41:47 <Ariakenom> % truncate ((4321.15 :: Rational) * 100)
01:41:48 <yahb> Ariakenom: 432115
01:41:57 <Taneb> maerwald: toRational is polymorphic, and default rules make its argument Double
01:42:17 <maerwald> Yeah
01:42:19 <Taneb> And Double can't represent 4231.15 exactly
01:42:31 <maerwald> It's all awful and type classes with numbers are awful
01:42:39 <Taneb> But if you don't use toRational and just start and stay in Rational, things work great
01:42:42 <maerwald> You can't reason about anything properly
01:42:47 <Ariakenom> defaulting to doulbe is the only issue here though
01:43:42 <Ariakenom> % default (Integer, Rational)
01:43:43 <yahb> Ariakenom: 
01:43:53 <Ariakenom> % truncate (4321.15 * 100)
01:43:53 <yahb> Ariakenom: 432115
01:46:07 * hackage auto-update 0.1.4.1 - Efficiently run periodic, on-demand actions  https://hackage.haskell.org/package/auto-update-0.1.4.1 (MichaelSnoyman)
01:49:30 <kritzefitz> I remember having read somewhere, that I when using parallel strategies from the parallel package, I should es the result of applying the strategy instead of just applying the strategy and using the original value, to avoid the created spark being garbage collected. Does that somehow apply to par too, even though it doesn't return the sparked value?
01:59:43 <Ariakenom> %kill
01:59:43 <yahb> Ariakenom: Done
02:00:07 * hackage hackport 0.6 - Hackage and Portage integration tool  https://hackage.haskell.org/package/hackport-0.6 (solpeth)
02:24:51 <dredozubov> How do I fix the broken haddocks in the package candidate? Any way to make the PUT /docs trick to work there?
02:26:59 <dredozubov> ok, apparently it works if you fix the url
02:27:03 <dredozubov> nvm
02:40:43 <fendor> what is the easiest way to open a ghci session in the test directory? E.g. where all test-dependencies have been loaded and I can exec functions from test modules. 
02:47:56 <maerwald> > truncate (toRational (4321.15 :: Double) * 100) -- why does this not work? Once the double is rational, there should be zero loss
02:47:57 <lambdabot>  432114
02:48:16 <maerwald> Err, I forgot type sig lol
02:48:21 <Taneb> maerwald: the loss is before it's converted to Rational
02:48:27 <Taneb> > 4321.15 :: Double
02:48:29 <lambdabot>  4321.15
02:48:47 <maerwald> > truncate ((toRational (4321.15 :: Double) :: Rational) * 100)
02:48:49 <lambdabot>  432114
02:48:59 <maerwald> Taneb: where
02:49:15 <Taneb> > properFraction (4321.15 :: Double)
02:49:16 <lambdabot>  (4321,0.1499999999996362)
02:49:31 <Taneb> maerwald: Doubles can't represent 0.15 exactly
02:49:53 <maerwald> ok so when is that function called? In the instance toRational of double?
02:50:04 <Taneb> Which function? It's part of the double type
02:50:19 <maerwald> So the show instance is lying?
02:50:23 <Taneb> Yes
02:52:27 <fendor> > truncate (toRational (0.2 :: Double) * 100)
02:52:29 <lambdabot>  20
02:52:49 <fendor> > truncate (toRational (0.1 :: Double) * 100)
02:52:51 <lambdabot>  10
02:52:57 <fendor> > truncate (toRational (0.15 :: Double) * 100)
02:52:59 <lambdabot>  14
02:56:29 <fendor> to my question, cabal new-repl <test-suite-name> does the trick
03:06:29 <bdfyotp> datetime format 2019-02-20 11:04:56.012 => how should I format it using time library? (e.g. %Y-%m-%d %H:%M)
03:58:07 * hackage simple-cmd 0.1.3 - Simple String-based process commands  https://hackage.haskell.org/package/simple-cmd-0.1.3 (JensPetersen)
03:59:07 * hackage template-haskell-compat-v0208 0.1.1.1 - A backwards compatibility layer for Template Haskell newer than 2.8  https://hackage.haskell.org/package/template-haskell-compat-v0208-0.1.1.1 (NikitaVolkov)
04:22:07 * hackage record 0.3.2.1 - First class records implemented with quasi-quotation  https://hackage.haskell.org/package/record-0.3.2.1 (NikitaVolkov)
04:29:37 * hackage schematic 0.5.0.0 - JSON-biased spec and validation tool  https://hackage.haskell.org/package/schematic-0.5.0.0 (dredozubov)
04:40:37 <Moony22> hi there, quick question: if i've got a data type defined as data Val = Const Int | Var String, is there a way to have another data type like this: data S = Assign Var Val? so the first argument in the Assign constructor has to be a Var?
04:43:43 <merijn> Moony22: The things after "Assign" have to be types, and "Var" is not a type in that example
04:44:56 <Moony22> merijn: hm ok thanks I see
04:47:35 <lunabo> Moony: you can either make a separate type for variables, or just use Assign String Val
04:47:44 <lunabo> Moony22: 
04:49:16 <lunabo> I.e. newtype Var = MkVar String and then data Val = ... | VVar Var and S = Assign Var Val
04:52:40 <Moony22> lunabo: Oh thank's very much, I think i'll do the second 
05:01:09 <kaol> I'm having trouble with Network.HTTP.Conduit. I've reduced my code to just do { mgr <- newManager tlsManagerSettings; rq <- parseRequest "https://www.googleapis.com/"; httpLbs rq mgr >>= print }. I'm getting a ConnectionTimeout on my server. It works on my development environment. curl https://www.googleapis.com/ works with not timeouts on both so what's different with using Network.HTTP.Conduit?
05:21:46 <kaol> At least I could reproduce the issue with curl by adding a proxy. I suspect that whatever this is about doesn't have much to do with http-client-tls.
05:24:52 <gentauro> I've updated my `cleanse-facebook` script so it no longer has the `pwd` issue with regard that it could be spotted by other `processes` and I added the functionallity to cleanse all messages. Now my FB every month will be `clean as a whistle` xD -> https://gitlab.com/spisemisu/cleanse-facebook
05:35:42 <__monty__> It removes anything related to fb from your disk or it removes stuff from fb?
05:36:25 <gentauro> __monty__: it `cleanses` your FB profile ;)
05:36:47 <gentauro> every month I `reset` my profile :)
05:37:35 <gentauro> (if you have a `jealous` partner who looks into your FB, she/he, will not find anything xD
05:38:54 <__monty__> Pretty sure that's more suspicious, not less. Though my fb is a ghosttown tbh.
05:39:23 <hc> wait.. some well known haskellers work for fb. it must be good. *ducks*
05:39:38 <gentauro> __monty__: my tools ensures that no data can leak -> https://gitlab.com/spisemisu/cleanse-facebook/blob/master/CFB.hs#L49-57
05:40:00 <gentauro> it's probably the most `safe` tool out there to do this task (in an automated way)
05:40:41 <gentauro> hc: well, when I gave the talk, "that" famous haskeller, sent me the FB+Lambda logo ;)
05:40:59 <hc> :-)
05:41:25 <__monty__> I'm not talking about data leaking. Absence of data is suspicious in and of itself.
05:41:57 <gentauro> __monty__: I decided (since FB obviously showed that they couldn't handle my data) to remove it every month
05:42:05 <gentauro> that way it would be if we spoke in real life
05:42:28 <gentauro> you would probably remember our conversation for a week or maybe a month, but after that, it would be long gone right?
05:43:01 <gentauro> I obviously don't think that I'm really `deleting` anything at FB (they are probably just moving it to another server or whatever they do)
05:43:12 <__monty__> But they don't actually remove things until the hadoop block is empty, right? And even then...
05:43:26 <gentauro> but at least it should be more difficult for `douchy` companies to use my data (Cambridge Analytica and so)
05:43:53 <__monty__> I guess this is way more valuable to active fb users.
05:44:03 <hc> you know how modern delete is implemented, right? UPDATE data SET deleted=true WHERE $WHERECLAUSE ;p
05:44:20 <hc> OH, don't forget ,deletedAt=$EPOCH :-)
05:44:32 <gentauro> __monty__: well, if I "requested" data deletion (EU GDPR) and it's not done, I have a pretty good case against them (I think it's article 80 something that allows you to sue them :P)
05:45:06 <Clint> good luck proving that they haven't
05:45:45 <gentauro> Clint: I live en Denmark, we have Margrethe Vestager (it will be them to prove they have) :P
05:46:08 <Clint> mm
05:48:07 <Taneb> gentauro: you should make a GDPR request, I'm curious what the result would be
05:49:01 <__monty__> Afaiui using a site feature to request deletion isn't the same thing as formally asking them to delete stuff. Is that covered by the GDPR?
05:51:23 <gentauro> Taneb: you can't contact FB (obviuosly, they have to many end-users)
05:51:34 <gentauro> but they have made a tool so you can download your profile :)
05:53:11 <slaterr> > parse (many (spaces *> digit)) "" ("123   " :: String)
05:53:13 <lambdabot>  error:
05:53:14 <lambdabot>      Variable not in scope: parse :: f0 [a1] -> [Char] -> String -> terror:
05:53:14 <lambdabot>      • Variable not in scope: spaces :: f0 a0
05:53:36 <slaterr> this gives me: Left (line 1, column 7): unexpected end of input expecting space or digit
05:53:42 <gentauro> __monty__: FB actually provides UI/UX to deleate everything. But it's a manual process.
05:54:02 <gentauro> It would probably take your around half a year (depending on how much stuff you post)
05:54:13 <gentauro> I have a FB friend who post around +20 things a day
05:54:27 <gentauro> he has been on the platform since 2008
05:54:57 <gentauro> 20 * 365 * 10 = 73000 stuff that he needs to delete manually
05:55:12 <gentauro> and then he obviously have messages with his friends and so
05:55:22 <__monty__> Their having many users is no excuse for being impossible to contact.
05:55:57 <gentauro> but the GDPR states that you need to allow end users to delete and that is what FB does, but it's single elements at the time
05:56:36 <gentauro> you can obviously opt to just delete your FB profile, but for some users, that's not a valid option (friends around the world, primary/high school, ...)
05:57:55 <gentauro> so that's why I made this tool. First, cos what I saw made in JavaScript, scared the Jesus out of me if I had to use it (what are they doing with my data when "deleting it") and second, to push Haskell to see if I could use it to crawl a site (`tagsoup` is my new friend)
05:58:24 <gentauro> I actually like how my FB friends want to use the script, I just say they need to install `stack`. I never hear from them again xD xD xD
05:58:30 <__monty__> It's a cool project. I would hate to lose access to all the conversations though. Do you back them up? Are they in a nicely accessible format?
05:58:40 <gentauro> (why is it so difficult for "normal people" to use stuff made with `Haskell`)
05:58:45 <slaterr> gentauro, check out scalpel too, it is a high level wrapper around tagsoup. I like it
06:00:00 <__monty__> gentauro: I think it's because of a lack of provided binaries. Not many users like building software. Especially if the compiler's a huge multi-GB beast.
06:00:10 <gentauro> __monty__: Nah, I don't store it locally, that would probably be a `backup service` and for that I would suggest you just to export your `profile` (they allow you to export a subset of it)
06:01:20 <__monty__> Does that include fb chat?
06:02:48 <slaterr> parse (many (spaces *> digit <* spaces)) "" ("123   " :: String) <- this works, but behavior is changed on the last digit (I don't want to slurp spaces after the last digit)
06:02:52 <Solonarv> you should just be able to compile it and throw a binary at them, if you're on the same OS
06:08:37 <gentauro> __monty__: yes, I think they have backup for the chat as well
06:09:10 <gentauro> Solonarv: my approach is that I wan't them to install `stack`
06:09:30 <gentauro> that way, they probably would be able to use other fancy stuff ;)
06:10:00 <statusfailed> Is there a function which looks up a (contiguous) range of values in a Data.Map ?
06:10:31 <statusfailed> I imagine that could be implemented more efficiently than O(n log n) given knowledge of the internals
06:11:16 <statusfailed> oh I guess takeWhileAntitone would work
06:11:29 <statusfailed> yeah nevermind :D
06:11:34 <gentauro> % :t takeWhileAntitone
06:11:34 <yahb> gentauro: ; <interactive>:1:1: error:; * Variable not in scope: takeWhileAntitone; * Perhaps you meant one of these: `S.takeWhileAntitone' (imported from Data.Set), `M.takeWhileAntitone' (imported from Data.Map), `S.dropWhileAntitone' (imported from Data.Set)
06:11:50 <gentauro> % :t M.takeWhileAntitone
06:11:50 <yahb> gentauro: (k -> Bool) -> M.Map k a -> M.Map k a
06:12:04 <statusfailed> it's O(log n) from the docs
06:12:27 <statusfailed> and the predicate has to satisfy j < k ==> p j >= p k
06:12:28 <gentauro> statusfailed: but you do the operation `at most` n times right?
06:12:41 <gentauro> so you are in `O(n lg n)`
06:13:01 <statusfailed> don't you just call takeWhileAntitone twice?
06:13:04 <statusfailed> once for upper and once for lower bound
06:13:07 <statusfailed> so it's log n?
06:14:28 <statusfailed> oh I mean dropWhileAntitone for the second call
06:15:44 <gentauro> takeWhileAntitone and dropWhileAntitone are probably implemented as `filters` right? That would be an operation on (possible) all elements
06:16:22 <statusfailed> gentauro: I don't think so, I think they're more efficient than that
06:16:25 <gentauro> `Map` are data structures with `O (lg n)` lookups, so it summarizes as `O (n lg n)`
06:16:34 <statusfailed> takeWHileAntitone is O(lg n)
06:16:38 <statusfailed> so says the docs
06:17:37 <statusfailed> internally it's stored sorted
06:17:38 <gentauro> `takeWhileAntitone p = fromDistinctAscList . takeWhile (p . fst) . toList`
06:17:39 <statusfailed> afaik
06:18:08 <statusfailed> gentauro: that's not the actual implementation, it's just to show equivalence
06:18:44 <gentauro> https://hackage.haskell.org/package/containers-0.6.0.1/docs/src/Data.Map.Internal.html#takeWhileAntitone
06:19:25 <gentauro> it calls it self recursively ... but I can't see if it terminates with `lg n` (height of a `Map`)
06:19:31 <statusfailed> I trust the docs :D
06:20:38 <gentauro> statusfailed: NEVER !!!
06:20:39 <gentauro> xD
06:20:52 <gentauro> normally I trust common sense
06:20:55 <statusfailed> lol
06:21:02 <gentauro> but in this case, I might be wrong :P
06:21:03 <statusfailed> Ah I think the "l" and "r" parameters are the left and right branches
06:21:12 <statusfailed> and internally it's a balanced tree
06:21:17 <statusfailed> so it's only going to go log n depth
06:21:28 <statusfailed> see the first recursion goes right, and the second goes left
06:22:31 <slaterr> (many (spaces *> digit)     <- this parser fails on "123   ". why? shouldn't it just stop on the first failure to parse?
06:24:33 <statusfailed> slaterr: my parsec is rusty but shouldn't you parse leading spaces?
06:24:39 <statusfailed> i.e. it would parse " 123" ?
06:25:20 <slaterr> yes, and that works. but I want "123   " to work as well, without adding <* spaces at the end (which would slurp spaces that aren't in between digits
06:25:48 <statusfailed> slaterr: does "spaces" expect 1 or more spaces?
06:26:04 <slaterr> 0 or more, including more than 1
06:26:09 <statusfailed> ah I see
06:26:29 <statusfailed> what about spaces *> many digit ?
06:26:46 <statusfailed> just as a wild guess :p
06:27:29 <slaterr> statusfailed, that will stop at 3 in "123  456"
06:28:10 <statusfailed> many digits `sepBy` spaces ? 
06:29:09 <statusfailed> slaterr: i'm a bit confused about what you want to parse - you want to accept the whole string "  123  456  789  " for example?
06:31:07 * hackage vrpn 0.3.0.0 - Bindings to VRPN.  https://hackage.haskell.org/package/vrpn-0.3.0.0 (BrianBush)
06:32:37 * hackage hleap 0.2.0.0 - Web Socket interface to Leap Motion controller  https://hackage.haskell.org/package/hleap-0.2.0.0 (BrianBush)
06:33:10 <kuribas> are recursion schemes to hard to understand for non-functional programmers?
06:33:37 * hackage kafka-device-joystick 1.0.0.0, kafka-device-glut 1.0.0.0 (BrianBush): https://qbin.io/burton-bodies-ootv
06:33:51 <statusfailed> kuribas: I think they're hard for functional programmers :p
06:34:07 * hackage kafka-device-leap 1.0.0.0, kafka-device-vrpn 1.0.0.0, kafka-device-spacenav 1.0.0.0 (BrianBush)
06:34:23 <kuribas> statusfailed: cata is pretty simple
06:36:38 <merijn> kuribas: What, they're not hard for functional programmers?
06:36:46 <statusfailed> kuribas: I always found libraries for them pretty tricky 
06:36:55 <merijn> I must've missed a memo, because I don't understand shit about bananas and barbed wire :p
06:37:07 <statusfailed> lol
06:37:32 <kuribas> merijn: catamorphism isn't that difficult, once you get it...
06:37:50 <merijn> I don't even remember what catamorphisms are, so who knows if I understand it
06:38:21 <statusfailed> kuribas: everything is easy once you understand it :D
06:38:32 <kuribas> merijn: foldr
06:38:37 <kuribas> merijn: is a catamorphism for list
06:38:46 <merijn> kuribas: I prefer just "foldr" :p
06:38:48 <kuribas> :t foldr
06:38:49 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
06:38:59 <merijn> kuribas: Or "fold"
06:39:11 <kuribas> merijn: that's just naming
06:40:17 <merijn> kuribas: Naming is important, though :)
06:52:10 <maerwald> CT is only there to make simple things sound smarter :>
06:52:20 <c_wraith> @unmtl ListT (State s) a
06:52:20 <lambdabot> s -> ([] a, s)
06:52:49 <c_wraith> that's an interesting display choice from that plugin
06:54:42 <petercommand> @mtl s -> ([] a, s)
06:54:42 <lambdabot> Maybe you meant: url unmtl pl msg
06:56:33 <__monty__> Hmm, Wizek, maybe this `@unmtl` could help with your question from yesterday : )
06:57:36 <Wizek> __monty__: maybe. thanks for pinging me about it!
07:05:07 * hackage fedora-dists 1.0.1 - Library for Fedora distribution versions  https://hackage.haskell.org/package/fedora-dists-1.0.1 (JensPetersen)
07:07:37 * hackage rattletrap 6.2.2 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-6.2.2 (fozworth)
07:27:16 <slaterr> how do I send a pointer to Word32 to a C function that will modify it?  
07:27:31 <slaterr> withArray [x]   ?
07:27:42 <merijn> slaterr: Modify it how?
07:28:06 <merijn> slaterr: Your C function is just something like "void foo(uint32_t val)"?
07:28:33 <slaterr> no, it is something like void foo(uint32_t *val)
07:29:12 <dmwit> Presumably the import will give the Haskell-side function a type like `Ptr Word32 -> IO ()`.
07:29:21 <dmwit> Then you just... send it. With function application.
07:29:46 <dmwit> Or maybe the actual question is "hwo do I acquire a pointer to Word32 in the first place"...?
07:29:48 <slaterr> how do I get a pointer with space allocated for one Word32 value?
07:29:54 <dmwit> malloc
07:30:05 <slaterr> I have to allocate it on the haskell side
07:30:18 <Solonarv> or 'alloca $ \ptr -> poke ptr myVal; theCFunction ptr'
07:30:23 <dmwit> Yes. malloc is a Haskell thing, too.
07:30:25 <Solonarv> (apologies if I got details wrong)
07:30:52 <merijn> But alloca is better, probably :p
07:31:12 <merijn> slaterr: Does the C code use the pointer after foo returns?
07:31:21 <dmwit> Maybe. Like all good questions, the answer depends on the question.
07:31:35 <slaterr> Solonar, is that the same as withArray [myVal] $ \ptr ->  theCFunction ptr ? 
07:31:48 <merijn> slaterr: Kinda, sorta
07:31:57 <slaterr> merijn, no, it uses that pointer to emulate returning more than one value
07:32:13 <c_wraith> "Does the C code use the pointer after foo returns?"  Heh.  I woke up thinking about strtok, for some reason.  Must have been remnants of a nightmare.
07:32:15 <merijn> slaterr: withArray builds an array of existing values. alloca gives you an uninitialised pointer
07:32:55 <merijn> slaterr: So "withArray [x]" allocates a pointer, writes the list into it, then gives you the pointer. Alloca just allocates the pointer and skips the rest
07:33:30 <Solonarv> so in the simplest case it's just 'alloca cFunction' - expanded: 'alloca $ \ptr -> cFunction ptr'
07:33:38 <slaterr> yeah
07:34:12 <dmwit> I find the juxtaposition of these two sentences troubling: "how do I get a pointer with space allocated for one Word32 value?" and "it uses that pointer to emulate returning more than one value"
07:34:43 <slaterr> dmwit, that's a common C pattern
07:35:06 <slaterr> foo() { int secondValue;  int firstValue = function(&secondValue);
07:35:07 <merijn> dmwit: He just means the C function will write the "extra" results into the pointers passed in
07:35:12 <c_wraith> the not allocating enough memory part is a common C pattern?
07:35:21 <c_wraith> Well, yes, I suppose buffer overruns are common in C
07:35:41 <slaterr> not sure where you get the "not allocating enough memory" part
07:35:54 <merijn> dmwit: The point was "my function returns an error code, but also needs to return a uint32_t"
07:35:58 <dmwit> merijn: Okay, correction: I find the juxtaposition of three sentences troubling. The previous two plus "it is something like void foo(uint32_t *val)"
07:36:12 <slaterr> ah, yes. one value is returned, other is written into the pointer
07:36:14 <merijn> dmwit: To be fair, I introduced that example :)
07:36:40 <slaterr> or rather, to the value pointed to by pointer
07:36:48 <merijn> slaterr: Anyway, yeah, for the "write return value here" case an unitialised pointer from alloca is the way to go
07:38:08 <c_wraith> just make sure you get the type right in the FFI declaration
07:38:23 <c_wraith> so easy to guess and be wrong
07:38:43 <c_wraith> leading to memory corruption that crashes the program much later
07:39:03 <kuribas> merijn: foldr is only a catamorphism for list
07:39:15 <kuribas> merijn: so cata is a generalisation of foldr
07:39:19 <kuribas> for any datatype
07:39:42 <slaterr> c_wraith, yeah I know. I liked h2sc for this reason, it could automatically handle things like extra padding in C structures. but unfortunately, it doesn't work with stack
07:46:02 <slaterr> anyone knows off hand how to write this in haskell? value &= ~flag
07:46:51 <Ariakenom> :t (complement,(.&.))
07:46:52 <lambdabot> (Bits a2, Bits a1) => (a1 -> a1, a2 -> a2 -> a2)
07:47:05 <c_wraith> there's also https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bits.html#v:clearBit
07:47:15 <slaterr> neat!
07:47:19 <shapr> aw, man I was too slow reading Data.Bits docs
08:05:46 <byorgey> when I looked at slaterr's question I didn't understand it because all I could think about was lens combinators. =)
08:19:26 <_d0t> Hello! Are there any GHC 8.6.3 builds for CentOS 6?
08:19:43 <_d0t> Petersen's copr repo doesn't have them.
08:20:08 <merijn> _d0t: I generally just install the bindists on all *nix OSes
08:20:39 <merijn> _d0t: https://www.haskell.org/ghc/download_ghc_8_6_3.html#binaries
08:21:23 <_d0t> merijn: afaik centos has incompatible GMP version
08:21:27 <_d0t> centos 6 i mean
08:22:16 <merijn> ah, hmm apparently I'm on CentOS 7.
08:22:21 <merijn> Isn't CentOS 6 super old?
08:22:36 <_d0t> Not super but old. Unfortunately I have to build our stuff for it.
08:22:43 <_d0t> Kinda stuck here.
08:23:01 <merijn> _d0t: Might have to build it yourself from an older GHC version
08:23:35 <_d0t> Might have to. Another question then. How do I supply my build of ghc to stack? Other than installing it and passing --system-ghc option.
08:23:58 <merijn> _d0t: Generally you don't, stack isn't really setup for that way of working
08:24:09 <merijn> afaik
08:24:17 <_d0t> merijn: So it's --system-ghc.
08:24:31 <merijn> I think that's the only real solution, yeah
08:24:42 <_d0t> :(
08:25:10 <_d0t> Thanks.
08:37:38 <Psybur> :t except
08:37:39 <lambdabot> error:
08:37:39 <lambdabot>     • Variable not in scope: except
08:37:39 <lambdabot>     • Perhaps you meant data constructor ‘ExceptT’ (imported from Control.Monad.Except)
08:38:01 <statusfailed> I'm using GHCJS 8.4, which doesn't support GHCI yet- is there a fast equivalent to being in the repl and running :r ?
08:38:12 <statusfailed> I guess "cabal build" isn't too bad actually
08:38:34 <slaterr> kind of unfortunate that clearBit accepts Int, and not Integral
08:39:00 <Solonarv> you should be able to pass -fno-code through 'cabal build' somehow and get even faster feedback
08:40:24 <ddellacosta> anyone have any opinions about "Thinking in Types" by Sandy Maguire? I'm relatively convinced I'll find it valuable from the samples he's provided, but curious if there are any reviews up and around online. I didn't see anything in the Haskell reddit so far at least
08:40:43 <ddellacosta> sorry, that would be "Thinking With Types" actually
08:40:57 <statusfailed> Solonarv: ah ok, thanks
09:17:25 <funrep_> hi! im trying to use persistant, but i can't figure out how to select which table selectList should use
09:23:42 <__monty__> ddellacosta: Maybe look at the idris community, they might have reviews. Also, Type driven development sounds like a related book.
09:26:37 * hackage fltkhs 0.7.0.2 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.7.0.2 (deech)
09:26:45 <MarcelineVQ> ddellacosta: koz_ enjoyed it, I haven't got too far in it for reasons unrelated to it
09:34:37 * hackage fltkhs-themes 0.1.0.4 - A set of themed widgets that provides drop in replacements to the ones in FLTKHS.  https://hackage.haskell.org/package/fltkhs-themes-0.1.0.4 (deech)
09:42:50 <slaterr> email or smtp-email?
09:51:13 <dyl> A variation on the usual "constraints in data types" question.
09:51:42 <dyl> Let's say you wanted to have a Heap i m type which is a newtype wrapper of an MArray (of unspecified implementation).
09:52:04 <dyl> Would you consider it proper to include constraints in the newtype at all (say, if using RankNTypes).
09:52:07 * hackage hjugement 2.0.1.20190208 - Majority Judgment.  https://hackage.haskell.org/package/hjugement-2.0.1.20190208 (julm)
09:54:28 <dyl> e.g. for some boxed type Cell.
09:54:30 <dyl> newtype Heap m i = Heap { unHeap :: forall a. (MArray a Cell m) => m (a i Cell) }
09:54:58 <dyl> Seems... reasonable enough to me?
09:55:06 <dyl> I just feel like this is a bad idea.
09:55:59 <Solonarv> I'd prefer having 'a' as a type parameter, I think
09:56:23 <Solonarv> i.e. 'Heap a m i = Heap { unHeap :: m (a i Cell) }'
09:56:56 <Solonarv> you can still have 'forall a. MArray a Cell m => Heap a m i' if you want
10:01:15 <dyl> Solonarv yeah, that was what I was thinking, but otoh it seemed like I really shouldn't need to expose it.
10:01:37 <dyl> The only time `a` is relevant is when creating an array, beyond that everything I care about is in MArray.
10:01:46 <dyl> So, this seems like a case where an existential is actually ok.
10:03:43 <Solonarv> % newtype Univ = Univ { getUniv :: forall a. [a] }
10:03:44 <yahb> Solonarv: 
10:03:56 <Solonarv> % test = Univ [5 :: Int]
10:03:56 <yahb> Solonarv: ; <interactive>:33:14: error:; * Couldn't match expected type `a' with actual type `Int'; `a' is a rigid type variable bound by; a type expected by the context:; forall a. [a]; at <interactive>:33:8-22; * In the expression: 5 :: Int; In the first argument of `Univ', namely `[5 :: Int]'; In the expression: Univ [5 :: Int]
10:04:05 <Solonarv> this is not an existential!
10:04:12 <dyl> Fair fair.
10:04:20 <Solonarv> % data Exist = forall a. Exist { getExist :: [a] } -- this is
10:04:21 <yahb> Solonarv: 
10:04:33 <Solonarv> % test = Exist [5 :: Int]
10:04:33 <yahb> Solonarv: 
10:04:40 <Solonarv> (it can't be a newtype)
10:04:48 <dyl> % newtype Univ = Univ { getUniv :: forall a. (Num a) => [a] }
10:04:48 <yahb> dyl: 
10:04:55 <dyl> % test = Univ [5 :: Int]
10:04:55 <yahb> dyl: ; <interactive>:37:14: error:; * Couldn't match expected type `a' with actual type `Int'; `a' is a rigid type variable bound by; a type expected by the context:; forall a. Num a => [a]; at <interactive>:37:8-22; * In the expression: 5 :: Int; In the first argument of `Univ', namely `[5 :: Int]'; In the expression: Univ [5 :: Int]
10:05:05 <dyl> Noted.
10:05:29 <dyl> % test = Univ 5 
10:05:29 <yahb> dyl: ; <interactive>:38:13: error:; * Could not deduce (Num [a]) arising from the literal `5'; from the context: Num a; bound by a type expected by the context:; forall a. Num a => [a]; at <interactive>:38:8-13; * In the first argument of `Univ', namely `5'; In the expression: Univ 5; In an equation for `test': test = Univ 5
10:05:45 <dyl> Oh, I'm just forgetting the [ ] haha.
10:08:37 * hackage hal 0.2.0 - A runtime environment for Haskell applications running on AWS Lambda.  https://hackage.haskell.org/package/hal-0.2.0 (nikeoss)
10:08:40 <gentauro> the reason I code with the `Safe` pragma turned on :-) -> http://dpaste.com/0VPF34T
10:09:16 <Solonarv> so yes, you could use an existential: data Heap m i where Heap :: forall arr m i. MArray arr Cell m => { getHeap :: m (arr i Cell) } -> Heap m i
10:09:34 <Solonarv> (I prefer GADT syntax when writing existentials)
10:11:40 <Solonarv> this can't be a newtype because the constructor needs to package in the dictionary for 'MArray arr Cell m' as well as the field you specified
10:12:10 <Solonarv> so it's secretly a two-field constructor
10:12:36 <gentauro> Solonarv: newtype only work with 1 field constructors right (cos they get erased at compile time)
10:12:44 <Solonarv> indeed
10:14:35 <Solonarv> dyl: make sense?
10:15:56 <Solonarv> (meanwhile, 'forall arr. MArray arr Cell m => m (arr i Cell)' is secretly a function 'forall arr. MArrayDict arr Cell m -> m (arr i Cell)')
10:28:42 <gentauro> a question on `pretty printing`. It seems that most libs in Haskell `pretty-show` and `shower` tend to go for a "difficult" way of `ppriting` (out commenting is more difficult) -> http://dpaste.com/1XX724K
10:29:04 <ddellacosta> __monty__, MarcelineVQ thanks!
10:29:05 <gentauro> wouldn't it give sense to add the `commas` under the `brackets`?
10:38:11 <glguy> gentauro: If the concern was ease of commenting lines then we'd want to allow trailing commas and put them all on the ends
10:38:46 <glguy> without that you have trouble commenting out lines at the beginning or end either way
10:39:15 <gentauro> glguy: I don't understand your point, could you please provide an example? (thx in advance)
10:39:35 <glguy> gentauro: You can comment out userName = "Artyom", just the same
10:41:07 <glguy> gentauro: If you were worried about consistency you'd need: http://dpaste.com/1XGJS6F
10:43:39 <gentauro> glguy: I find that way of using `brackets` really difficult to read. I prefer them on the same line
10:44:11 <gentauro> but I might agree on what you are saying with regard of `commas`
10:44:49 <gentauro> even though I don't understand how `userPassScrypt = <omitted>,` and `resourceHash = ACBD18DB4CC2F85CEDEF654FCCC4A4D8,` have trailing `commas` (does it even compile?)
10:46:15 <glguy> I'm just saying that being able to comment out lines wasn't really a feature that moving the commas to the front or back helps with
10:46:23 <glguy> Haskell syntax doesn't allow the extra trailing comma
10:48:59 <hpc> i often wish it did
10:55:46 <Solonarv> Perhaps it could be a syntax extension
11:02:00 <leshow> can someone do a sanity check on this? doing a hackerrank exercise that involves counting frequencys of elements, one of the operations is supposed to remove an element if it's count is 0, I can't get this to work: https://pastebin.com/53seyuhT
11:02:26 <leshow> freqQuery [[1,3],[2,3]] should result in an empty map
11:03:59 <gentauro> leshow: I think I made that hackerrank task. I will see if I can find it ;)
11:04:47 <glguy> leshow: Minor note: 1 : [x] is [1,x]
11:05:20 <leshow> as in, a list with 2 elements? that's what it's supposed to be
11:05:56 <Solonarv> yes, '1 : [x]' is just a weird way to write it (IMO)
11:06:02 <leshow> I put a trace on the 'clear' call it never runs
11:06:40 <gentauro> leshow: why are you using `Maps`? They will not allow you to have the same number twice ...
11:07:05 <leshow> I don't want the same number twice I want to count the frequency of each number
11:07:06 <Solonarv> Map is very sensible here
11:07:11 <Solonarv> ^
11:07:11 <gentauro> example: `[[1,3],[1,3],[2,3]]` will not work
11:07:39 <glguy> gentauro: Why would you think it wouldn't work?
11:07:42 <leshow> gentauro: it should construct a map of [(3,1)]
11:07:45 <leshow> in that case
11:08:06 <gentauro> leshow: oh, you add a counter
11:08:07 <gentauro> got it
11:08:15 <Solonarv> try switching the 'Data.Map' import to 'Data.Map.Strict', that should at least force the 'trace' to run
11:09:10 <glguy> Solonarv: That shouldn't matter since Lazy map is still strict in the spine
11:09:16 <glguy> and Map.update updates the spine
11:09:17 <Solonarv> hm true
11:09:27 <leshow> not on my end, i must be missing something stupid. I could write out clear function and the map in the repl and it would work
11:09:30 <leshow> but not when i run this
11:09:39 <glguy> leshow: foldr is probably the wrong fold
11:09:57 <Solonarv> another side note: 'Map.size (Map.filter (== z) m)) > 0' can be written as 'z `elem` m'
11:09:59 <glguy> so what's happening is you're deleting from an empty map first
11:10:10 <glguy> leshow: Because you're deleting from an empty map, clear doesn't need to be evaluated
11:10:31 <leshow> why wouldn't it have a value in it
11:10:36 <Solonarv> oooh yes it's the wrong fold!
11:11:41 <leshow> Why is it the wrong fold?
11:12:02 <glguy> > foldr f z [1,2,3] :: Expr
11:12:04 <lambdabot>  f 1 (f 2 (f 3 z))
11:12:29 <leshow> oh bollocks
11:12:32 <glguy> > foldr f z [[1,3],[2,3]] :: Expr -- better for your case
11:12:34 <lambdabot>  f [1,3] (f [2,3] z)
11:13:03 <leshow> right
11:13:06 <gentauro> glguy: how did you to that? (show as an expression)
11:13:18 <leshow> Thank you, I was driving myself crazy
11:14:06 <Solonarv> @hackage simple-reflect -- gentauro
11:14:06 <lambdabot> http://hackage.haskell.org/package/simple-reflect -- gentauro
11:16:31 <boj> gentauro: there is also http://pointfree.io
11:17:46 <leshow> heh, i still failed a couple of the cases, and timed out on one apparently
11:18:08 <leshow> if anyone is curious, https://www.hackerrank.com/challenges/frequency-queries/
11:18:44 <wroathe> So if I create a type synonym type Foo a b = a -> b I can ask ghci what kind Foo is, and get back * -> * -> *, but for some reason I can't do: :k (a -> b)
11:18:51 <wroathe> Is there a trick to make syntax like that work?
11:19:19 <cocreature> wroathe: :kind (->)
11:20:02 <wroathe> How would that work with a -> b -> c?
11:20:19 <Solonarv> % :k (->)
11:20:19 <yahb> Solonarv: (->) :: * -> * -> *
11:20:34 <cocreature> well there is no single type constructor in that case
11:23:32 <wroathe> Hrm, well the larger question I'm trying to answer is whether or not it's possible to do something like this in Haskell: https://gist.github.com/JustinChristensen/364682896fe783ed632a2437bdb79ba0
11:23:53 <wroathe> where the type of a function is dependent on the type of it's arguments
11:24:14 <wroathe> foo being the simpler case
11:25:06 <gentauro> boj: I think `simple-reflect` is nice to explain what happens "under the hood" ;)
11:25:07 <dyl> Finally looked into how reflection works.
11:25:24 <boj> gentauro: agreed!
11:25:30 <gentauro> boj: `pointfree` is more re-writting code in a `less is better`
11:25:49 <Solonarv> (sometimes it's *not* better, though :p)
11:25:59 <dyl> Hah, that simple-reflect was being discussed is pure coincidence :p. 
11:25:59 <cocreature> dyl: good ol’ unsafeCoerce :)
11:26:04 <dyl> cocreature indeed.
11:28:02 <Solonarv> wroathe: yes, it's possible - usually you need a type class for it
11:28:12 <dyl> "By the power of ConstraintKinds, TypeFamilies and unsafeCoerce, what could possibly stop us?"
11:28:13 <gentauro> `unsafeCoerce`? :|
11:28:33 <Solonarv> wroathe: see http://okmij.org/ftp/Haskell/polyvariadic.html
11:29:00 <gentauro> `unsafeCoerce` == "casting" ... :|
11:29:15 <Solonarv> yes - the 'reflection' package relies on the way GHC implements type classes
11:29:19 <wroathe> Solonarv: I was looking into the typeclass approach, but I was also thinking it might be possible to use a type family for this, right?
11:29:35 <dyl> gentauro casting to known internal GHC representation :p
11:29:41 <dyl> even _better_ than just casting.
11:29:52 <Solonarv> wroathe: a type family is enough to figure out the function's type, but can't get you the actual implementation
11:30:01 <wroathe> Solonarv: I only need a finite arity for the initial function argument
11:30:16 <wroathe> finite max arity
11:30:30 <gentauro> dyl: it' a disgrace for the Haskell language :P
11:30:43 <wroathe> Solonarv: I see
11:34:18 <wroathe> Solonarv: I'm guessing this is the kind of thing that would super easy to write in a true dependently typed language
11:34:50 <Solonarv> maybe, I'm not actually sure - I haven't used any proper DT language
11:36:47 <geekosaur> I doubt "super easy"
11:37:15 <dyl> Depending on the number of arguments to the functions provided would probably require some silly telescoping products.
11:37:21 <geekosaur> the dependently typed language will make you provide a proof that it aactually has that type, unlike a dynamically typed language that will lt you do whatever
11:37:24 <dyl> (to represent functions).
11:55:15 <dyl> Silly question:
11:55:51 * dmwit prepares a silly answer
11:55:54 <dyl> Is there a way to in some sense... parametrize (or configure) a record by an instance of a typeclass?
11:56:14 <dmwit> "an instance of a typeclass", also known as a type?
11:56:30 <dyl> Let me qualify, I think I'm just down a rabbit hole though.
11:56:34 <[exa]> dyl: like in existential types?
11:56:42 <dyl> e.g. Let's say I have data Machine m = forall a. (MArray a Cell m) => Machine {  _heap :: m (a Addr Cell) } 
11:57:06 <dyl> and I have some type family mapping IO/ST to IOArray/STArray in some manner.
11:57:29 <dyl> I want to have a "newMachine" which only has to know about the ambient monad, and hides the array details.
11:58:43 <dyl> I can't do: newMachineST = Machine { _heap = newArray (1, 256) Nil } because the array type is ambiguous.
11:58:55 <dyl> But I'm wondering if there's some way I can disambiguate this nicely.
11:59:12 <dyl> Without requiring Machine to carry a type parameter indicating the array type.
11:59:19 <dmwit> You can make a new class.
11:59:36 <dmwit> You can probably even do it just with a type family.
12:00:03 <dyl> I thought I might be able to, but it wasn't really jelling nicely when I tried.
12:00:26 <dmwit> type family DefaultArray m; type instance DefaultArray IO = IOUArray; type instance DefaultArray (ST s) = STUArray s; newMachine :: MArray (DefaultArray m) Cell m => m (Machine m)
12:00:48 <dmwit> Use STV to capture `m` for use inside the implementation of `newMachine`.
12:01:46 <dyl> dmwit ah, forgot STV.
12:02:06 <dyl> Perhaps more interestingly: what if I wanted to be able to configure the MArray instance directly via reflection? 
12:02:18 <argent0> hi, are there alternatives for http://hackage.haskell.org/01-index.tar.gz ? cabal new-update is timing out and then restarting the whole fetch again. Also the server seems not to be configured to support byte ranges.
12:02:20 <dyl> While still having some sane default behavior.
12:02:29 <dmwit> https://hackage.haskell.org/package/primitive-0.6.4.0/docs/Data-Primitive-Array.html also looks relevant for you
12:03:05 <dmwit> dyl: I mean, if you want the user to be able to specify, you can just make it a (type) parameter.
12:03:34 <dyl> I'm wondering about more black magic approaches :p.
12:03:35 <dmwit> dyl: `newMachine :: forall a m. MArray a Cell m => m (Machine m)`. Then users would write e.g. `newMachine @IOUArray` or whatever.
12:03:44 <dyl> Oh right, I forgot about @.
12:04:08 <dyl> Is there a way to default that nicely? 
12:04:24 <dmwit> Yes, use DefaultArray as above.
12:04:40 <dyl> In conjunction with being able to use @?
12:05:03 <dmwit> No, write two different operations.
12:05:09 <dmwit> (One can just be a call to the other.)
12:05:36 <dmwit> `newDefMachine :: forall m. MArray (DefaultArray m) Cell m => m (Machine m); newDefMachine = newMachine @(DefaultArray m)`
12:06:52 <dmwit> argent0: https://guide.aelve.com/haskell/hackage-mirrors-unelnlt9 perhaps
12:07:13 <dmwit> Dunno how up-to-date that list is.
12:08:28 <argent0> dmwit: Thanks I'll check it out
12:12:25 <dyl> dmwit I'm not sure that'll work (your newMachine).
12:12:46 <dmwit> oh?
12:12:48 <dyl> It won't unify the a from newMachine's forall and the a from Machine's forall.
12:13:03 <dmwit> It will if you tell it to.
12:13:09 <dyl> newMachine :: forall a m. MArray a Cell m => m (Machine m)
12:13:10 <dyl> data Machine m = forall a. (MArray a Cell m) => Machine {  ... } 
12:13:12 <dyl> how do I tell it ot?
12:13:17 <dyl> ~?
12:13:21 <dmwit> STV+TypeApplications, e.g.
12:13:37 <dyl> the issue is just in declaring newMachine at all, and I have STV.
12:13:59 <dmwit> Do you really mean declaring, or do you mean defining?
12:14:03 <dyl> Both.
12:14:10 <dyl> But the error is in the type.
12:14:21 <dmwit> You know the drill.
12:14:31 <dmwit> Paste minimal code end error, send us link.
12:14:33 <dyl> ...enable random extensions until it compile but crashes?
12:14:34 <dyl> :p
12:16:08 <dyl> https://gist.github.com/DylanLukes/02a86aa4e7e690c21d2a2e77eccbadc2
12:16:50 <dmwit> newArray @a
12:17:16 <dmwit> You'll almost certainly need more binding, though.
12:17:31 <dmwit> liftA2 (Machine 0 0) (newArray @a ...) (newArray @a ...) -- or something
12:17:32 <dyl> Yeah, just @a isn't getting rid of the ambiguity error.
12:17:56 <dyl> just @a on the newArrays*
12:18:07 * hackage proxied 0.3.1 - Make functions consume Proxy instead of undefined  https://hackage.haskell.org/package/proxied-0.3.1 (ryanglscott)
12:18:16 <dmwit> But the error tells you how to fix it.
12:18:24 <dmwit> You just turn on the appropriate extension and get on with your life.
12:18:36 <dyl> AllowAmbiguousTypes is the one I'm usually terrified of though :p.
12:19:06 <dmwit> Why?
12:19:14 <dmwit> It's completely benign since the advent of type applications.
12:19:21 <dyl> Because I don't know how it works.
12:19:26 <dyl> That's good to know at least.
12:22:07 <koz_> It's named in a very scary way.
12:24:35 <dminuoso> dyl: An ambiguous type is when you have some type `forall a. ctx => t` where a does not appear in t.
12:24:57 <dminuoso> It just means it can't infer the type variable based on usage.
12:26:18 <dyl> Aw, you can't derive Ix for e.g. data Addr = Heap Int | Reg Int.
12:28:09 <glguy> What would this do? range (Heap 5) (Reg 5)
12:29:09 <dyl> glguy explode! 
12:31:43 <dyl> I was just curious if GHC would (on the off chance) allow such a derivation.
12:31:48 <dyl> Apparently, GHC is reasonable :).
12:33:07 <dmwit> Your preferences are weird. No ambiguous types because I dunno, maybe callers would try to use them and the compiler would catch them in the act and refuse to make a program out of it. But yes derive Ix in a way that can cause bugs without the compiler noticing?
12:34:09 <dyl> I wouldn't *prefer* that it allow you to derive such an Ix. 
12:34:46 <dyl> But, as to not using ambiguous types, I mostly just try to avoid extensions I don't understand well. 
12:35:40 <dmwit> makes sense
12:38:55 <dyl> Might actually be reasonable/interesting (given a PartialOrd class) to define a variant of Ix that would accept such a type. 
12:39:03 <dyl> Not very, but maybe a little.
12:42:58 <dmwit> Interesting for what use?
12:43:33 <dyl> I’m not entirely sure. 
12:44:15 <merijn> dmwit: I do not agree that TypeApplications makes AllowAmbiguousTypes benign, as I don't even agree that TypeApplications is benign
12:45:05 <merijn> TypeApplications is only benign if all functions you use it on happen to have explicitly forall introduced type variables and the library maintainer actually agrees that that order is part of the public API
12:45:28 <merijn> That applies, for approximately 0.1% of Hackage
12:45:33 <merijn> Maybe less
12:46:06 <hpc> i doubt it applies to any package
12:46:22 <merijn> hpc: Sure, it's probably 0% of hackage, but I decided to hedge on the safe side
12:46:48 <merijn> And I seriously wish the very vocal proponents of TypeApplications would take a second to consider these implications
12:47:40 <dyl> Let's just bolt record syntax onto foralls! What could go wrong :D.
12:48:33 <monochrom> Wait, what would it look like?!
12:49:16 <dyl> forall { external ~ internal, ... }. 
12:49:38 * dyl gags.
12:49:40 <hpc> i figured you would put the record syntax onto the type application
12:49:48 <hpc> const @{a = Int, b = String}
12:49:54 <dyl> That too.
12:50:01 <monochrom> Oh! Using record syntax so it's more robust against "what is the exact order of the type variables again?".
12:50:07 <hpc> record syntax on the forall is kind of pointless
12:50:16 <hpc> you already have names for types
12:50:19 <hpc> they are... the type names :P
12:50:32 <merijn> hpc: Still problematic!
12:50:36 <dyl> hpc yeah, but as it stands type variables aren't considered public API, whereas these "external" aliases would be.
12:50:44 <hpc> ah true
12:50:51 <monochrom> But type variables are not robust against alpha equivalence!
12:50:59 <merijn> hpc: What if I didn't write a type signature and GHC infers the names, then you're relying on an undocumented internal GHC quirk
12:51:04 <hpc> merijn: yeah, you'd still need people to not alpha-rename and write type signatures for their... that
12:51:08 <dmwit> I am okay with "the order of foralls is part of the API". The name of type variables should not be part of the API, for the same reason the names I choose for the parameters to my function implementation should not be part of teh API.
12:51:16 <monochrom> Bring in de Bruijn numbering!
12:51:36 <merijn> dmwit: You might be okay with that, but as said before 99.99% of hackage doesn't guarantee that
12:51:37 <dmwit> Also I think your "proponents should consider these things" is a bit presumptuous.
12:51:39 <monochrom> Oh wait, now it's not robust against re-ordering again. Darn.
12:51:44 <hpc> dmwit: oddly enough, i have sometimes wished for haskell to have named function parameters
12:51:56 <monochrom> God help us
12:52:10 <dyl> monochrom forall { public ~ internal, ...} seems the most reasonable in that regard.
12:52:51 <dyl> hpc borrow the internal/external name from Smalltalk to buff up that "Influenced By" on Wikipedia ;p.
12:52:52 <monochrom> I don't entirely understand "public ~ internal".  Could you give an example?
12:53:08 <monochrom> Oh Smalltalk. I could take a look.
12:53:36 <dyl> forall { foo ~ a }... would mean that you could do @{foo = String}
12:54:04 <dyl> In my imagined world, @{<record syntax>} wouldn't be allowed on normal type parameter names.
12:54:10 <dyl> You'd have to explicitly expose them with the forall.
12:54:11 <merijn> dmwit: There are some people I see in here that very vocally advocate for TypleApplications everywhere to beginners, even in case where things can be trivially solved in straight Haskell98 and no one ever mentions any of the problems in versioning it can introduce. I'm not saying that's what you were doing here, I'm just wishing that people in general would stop acting like TypeApplications is a panacea
12:54:41 <dyl> monochrom smalltalk (and now Swift) allow something like foo(withBar bar: Bar)
12:54:51 <dyl> So you call it as foo(withBar: ...) but internally to the function it's called bar.
12:55:05 <dyl> _ is allowed to mean "just pass it normally".
12:55:31 <dyl> I kind of like the idea of having different external (API) and internal names.
12:55:46 <monochrom> Sorry there are too many bars. Is "Bar" a type?
12:55:50 <dyl> Yeah haha.
12:59:27 <monochrom> Well actually we can take a middle ground and insist that TypeApplication is good for explictly-forall'ed type parameters only.
13:00:27 <monochrom> Darn, that looks like the beginning of the worst of both worlds on second thought.
13:01:01 <monochrom> Yeah OK I'm now convinced that external names and internal names are the best of both worlds.
13:01:53 <monochrom> It is actually a non-obvious great idea.
13:03:22 <hpc> what about not having "~ a" in there, or making it optional?
13:03:29 <hpc> so you aren't defining twice as many type variables
13:03:38 <hpc> forall a. a -> a -- not @able
13:03:43 <monochrom> Yeah that's cool. I think Smalltalk and Swift allow that too.
13:03:43 <hpc> forall {a}. a -> a -- @able
13:04:19 <monochrom> {a} can be shorthand for {a ~ a}
13:04:19 <hpc> then in version 1.1, forall {a ~ b}. b -> b
13:04:28 <hpc> then in 2.0, forall {b}. b -> b
13:05:15 <tabaqui> hmm
13:05:17 <tabaqui> deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a] 
13:05:19 <tabaqui> why not
13:05:26 <tabaqui> deleteBy :: (a -> Bool) -> [a] -> [a] 
13:05:54 <monochrom> That's just one negation away from filter.
13:05:56 <tabaqui> for compatibility?
13:06:21 <hpc> it does seem kind of pointless
13:06:21 <dmwit> It's just a wart in my opinion.
13:06:29 <hpc> or is it pointful, who knows :P
13:06:31 <MarcelineVQ> monochrom: delete* only kills one item
13:06:38 <monochrom> Oh nevermind, yeah.
13:07:43 <monochrom> It's for consistency with groupBy, sortBy, etc. They all take a 2-ary relation.
13:07:59 <merijn> monochrom: Having the type parameters be explicitly forall'ed is not sufficient as middle ground, the maintainer needs to consider them part of the public API too
13:08:13 <monochrom> But I understand that maybe this consistency doesn't have value.
13:08:30 <monochrom> Yeah merijn I realized.
13:09:00 <phadej> the long version is useful when you write other *By functions, e.g. unionBy
13:09:47 <tabaqui> ok
13:10:09 <phadej> but it should been more general (b -> a -> Bool) -> b -> [a] -> [a]
13:10:22 <monochrom> phadej: The idea is the equivalence  standardDeleteby rel a = tabaquiDeleteBy (rel a)
13:12:29 <phadej> anyway, the consistency in naming is import. The could be `delete??? :: (a -> Bool) -> [a] -> [a]` but it shouldn't be deleteBy
13:12:42 <monochrom> OK
13:13:04 <monochrom> deleteIf :)
13:14:25 <dminuoso> merijn: I still believe that the benefits of TypeApplications greatly outweight the possible breakage you get when types change around. Now I agree that generally you can get around with Haskell 98/10, but we opt into extensions because they make code more concise.
13:15:12 <monochrom> But we're saying how to make TypeApplication even greater!
13:15:22 <merijn> dminuoso: The problem is, how are you going to version your dependencies? I mean, just of the top of my head I've made changes to my packages 5 times in ways that would break your code
13:16:22 <monochrom> Admittedly the whole thing can be said to function definitions at the term level too.  Parameter order has always been a tug war.
13:16:51 <merijn> dminuoso: Simple things like: I refactored code and switch to using ScopedTypeVariables (adding explicit forall), refactoring and dropping ScopedTypeVariables. Reordering foralls because I'm a pedant and screwed up the alphabetical order
13:17:09 <merijn> monochrom: Ah, but at least those are considered in the PVP and widely taken into account with versioning package releases
13:17:14 <dminuoso> merijn: Granted, perhaps TypeApplications is not the best extension to use against (potentially unstable) third party hackage dependencies.
13:17:19 <dminuoso> But inside my own code? I absolutely love them.
13:18:11 <monochrom> The difference is psychological and habitual. We have learned to live with term-level paramter order and its pain. We haven't overcome the cognitive dissonace when the same thing happens at the type level.
13:18:59 <dminuoso> monochrom: It's also about visibility.
13:19:29 <dminuoso> monochrom: A beginner might not be realizing that adding type variables/context can change the order of type variables, that is that type variables are in some way part of your public API (whether you define it to be or not)
13:19:44 <dminuoso> term-level parameter order is painfully obvious to any beginner
13:20:25 <monochrom> In my dream utopia I have always supported explicit foralls. Even for basic logic 101.
13:20:26 <dminuoso> I reckon plenty of experienced haskellers dont even know about TypeApplications
13:21:09 <monochrom> History is full of pedagogy disasters whenever people say "forall is hard, let's hide it".
13:21:27 <dminuoso> Why cant I have `exists`? :<
13:21:54 <monochrom> Hey one step at a time! :)
13:22:58 <monochrom> In the case of Haskell, the GHC people are a bit afraid of taking away your identifier names and reserving them for reserved words, so they shoehorned "forall" into existential types.
13:23:32 <monochrom> In my dream utopia, you would write ∀ and ∃ so no identifier name is harmed!
13:23:39 <dminuoso> Fine, just reserve Ǝ instead! The folks who actually use it are able to handle it.
13:23:46 <monochrom> Yeah!
13:24:04 <monochrom> But the world is full of die-hard ASCII-only fanatics.
13:24:23 <zachk> typing agda where unicode is common is kind of a pain 
13:24:37 <slack1256> I challenge you to write the forall symbol without looking for a manual :^)
13:24:53 <__monty__> The agda-mode's pretty enjoyable in my experience.
13:25:09 <monochrom> And the vocal die-hard ASCII-only fanatic majority are, of course, actually not the ones who actually need existential types at all.
13:25:36 <dminuoso> monochrom: You take care of doing first-level support for all the newcomers who come running "Look, I read about ∃, but I cant find them on my keyboard.. now I cant write the simplest code", and Ill take care of those complaining about `∀`
13:25:39 <monochrom> Programmers are control freaks. They will object to something you need but doesn't affect them.
13:26:04 <dminuoso> Time to figure out how to ipsec on nixos.
13:26:25 <__monty__> monochrom: Because when the shit hits the fan it affects everyone : )
13:26:43 <monochrom> I would s/when/hypothetically if/
13:27:01 <monochrom> Because in many cases there is no shit and nothing hits the fan.
13:27:37 <__monty__> On a more serious note though that sounds like "Let me have my extension *you* don't have to know about it at all," but then usage spreads and you end up having to understand all these extensions you never cared for.
13:27:53 <slack1256> It is a really simple extension though
13:28:00 <slack1256> It is not a change on semantics
13:28:30 <monochrom> Yes I agree there is a judgment to be made what are impactful extensions and what are benign extensions.
13:29:00 <MarcelineVQ> re unicode: learning to write new things isn't the end of the world mostly I find it hard to read, ∀ doesn't hurt my feelings but things like super and subscript letters used to differentiate things in code it's tougher
13:29:03 <slack1256> Although I like the written "forall a." as I learned about forall/exists on set theory and I feel icky when I don't define a belonging set
13:29:17 <__monty__> I'm just pointing out it's easy to say "It won't affect you." I'm actually in a weird place where I like unicode syntax but I'm not satisfied with the entry methods we have so far.
13:29:28 <dminuoso> __monty__: Particularly interesting are those extensions that are forced across library boundaries. That is, if you start using a library and it forces you to enable FlexibleContexts, FlexibleInstances, TemplateHaskell and whatever - then things become not fun anymore.
13:29:49 <slack1256> __monty__: What is your opinion on emacs TeX input mode? it translates forall to the unicode symbol
13:30:16 <slack1256> You have to do stuff like \forall which is not so bad
13:30:38 <monochrom> I speak from my bias of having heard GvR once zealotly refused what is now "x if booleanCondition else y" i.e., C's "? :" and Haskell's "if-then-else" expression, which is a very benign and easy-to-guess and easy-to-pick-up construct, on the religious ground "you should write imperatively, you just should" and "oh also only one way to do something".
13:31:27 <__monty__> slack1256: Like I said, I liked the agda-mode. I'm just not sold on this being the most ergonomic solution. Especially when it comes to finding out how to type a symbol you know exists. (I know you can query for a symbol that's already in a buffer but discovery is just not there yet imo.)
13:31:55 * slack1256 should buy an APL keyboard
13:32:04 <monochrom> So in short having heard GvR basically refused everything that makes sense, I am inclined to accept more things.
13:32:37 <monochrom> And I really mean makes-sense-globally not just "sounds cool in isolation".
13:34:39 <__monty__> monochrom: It just seems terrible to impose unicode symbols on people that likely don't have good input support and may not even have font support. It's very chicken and egg though, I admit.
13:35:37 <monochrom> Yes ASCII-only is a self-perpetualing cycle.
13:35:57 <MarcelineVQ> __monty__: I asked about this once and the response as I recall was "everyone writing x is already using editor x so it's not a problem since editor x supports this" Doesn't help me read it though ^^;
13:36:13 <monochrom> We all use emojis in our WhatsApp and Twitter and we can't use ∀ in our code?!
13:36:14 <MarcelineVQ> editor' 'y I guess, bad format string :>
13:36:29 <slack1256> We don't write our code on chrome or firefox though
13:36:35 <monochrom> And even emojis are yesteryear now. Today the rage is about stickers.
13:36:41 <slack1256> neither on iphones or android phones
13:36:56 <merijn> monochrom: It's always been about stickers, have you not ever interacted with 5 year olds? :p
13:37:42 <monochrom> It's OK merijn. I now interact with 50-year-olds (my highschool friends) who use stickers too!
13:38:04 <monochrom> Dude they have like Happy Chinese New Year stickers!
13:38:11 <slack1256> If we had a standard IDE (think dr.racket) maybe we could do it
13:38:22 <tabaqui> oh
13:38:50 <tabaqui> Pattern matching analyser doesn't work correctly with OverloadedLists
13:38:54 <tabaqui> do you know that?
13:38:55 <monochrom> Oh! Haha I see now, merijn.
13:38:56 <Psybur> Is there a better way to do this? Namely lines 6 and 7, the "_ <-" seems troubling. https://hastebin.com/ozoreferij.sql
13:39:22 <Psybur> The "pure x" is a waste
13:39:24 <monochrom> I loved stickers (physical paper-and-glue ones) too when I was a kid.
13:39:44 <merijn> Psybur: Sure, just remove it and disable the unused-do-binding warning
13:40:26 <monochrom> Psybur yeah the "_ <-" is for silencing a stupid warning. This is why -Wall die die die.
13:40:28 <tabaqui> https://pastebin.com/MrLK4H7X
13:40:48 <merijn> monochrom: I like -Wall, it's just -Wunused-do-bindings I hate
13:40:55 <tabaqui> Should I create a ticket?
13:41:19 <tabaqui> *sorry, I forget to derive instance IsList Foo
13:41:24 <tabaqui> but it still works
13:41:33 <merijn> tabaqui: Hah
13:41:36 <merijn> tabaqui: Nice find
13:41:54 <monochrom> That is a bit disturbing hehe
13:42:22 <tabaqui> monochrom: I prefer void instead of _ <-
13:42:41 <tabaqui> but it is the same as "Defined but not used" warning
13:43:08 <merijn> tabaqui: No, ignored do results are their own warning
13:43:09 <tabaqui> merijn: ghc 8.2.2
13:43:21 <tabaqui> merijn: I mean logically
13:43:33 <merijn> tabaqui: Yes, no, maybe
13:43:37 <merijn> Feels different to me :p
13:43:58 <merijn> tabaqui: I'd see if the same error happens in 8.6.3, if so, make a ticket
13:44:30 <tabaqui> ok
14:00:51 <fen> s -> (Maybe (r a),s) & s -> (r (Maybe a),s)
14:02:06 <fen> and then if r a = (i,a), then some way to partition unfolding these sate varients so that there is only one value per segment
14:02:53 <fen> "skip" containers and shaped segments
14:10:14 <fen> its got something to do with unfolding the `r a' using `f a' as the state, and then as we need the rest of the container there should be a kind of unfolding process that stops before the end
14:10:55 <fen> if we used eg s -> (a,Maybe s) then this would not give an `s' that could be reused
14:11:17 <fen> s -> Maybe (a,Maybe s) however, works. 
14:11:49 <zachk> that looks kind of like a state monad 
14:11:59 <zachk> if you squint 
14:12:20 <fen> if the outermost Maybe fails, then we can get the value before last and restart the unfold, possibly modifying the `s'
14:12:27 <zachk> @type runState 
14:12:28 <lambdabot> Control.Monad.State.State s a -> s -> (a, s)
14:14:07 <fen> zachk, are the maybes in the monad somehow?
14:14:28 <fen> was thinking of using; (a,s) -> Maybe (a,Maybe s) 
14:14:31 <zachk> don't know, but I was playing with this the other day
14:14:44 <zachk> @type liftA2 (>>=) 
14:14:45 <lambdabot> (Applicative f, Monad m) => f (m a) -> f (a -> m b) -> f (m b)
14:15:17 <fen> that way, giving a different `a' to start the unfolding could avoid having to modify the `s' 
14:15:37 * hackage language-puppet 1.4.3 - Tools to parse and evaluate the Puppet DSL.  https://hackage.haskell.org/package/language-puppet-1.4.3 (pi3r)
14:16:36 <fen> then if there was; `f a -> (a,(j,f a))' and `(j,f a) -> Maybe (j,Maybe (f a))' this couldbe used to unfold the segments, each with one `a', soof the form (i,a) for some `i'
14:16:55 <fen> calling the class withthose functions "substructure"
14:17:07 * hackage decimal-literals 0.1.0.1 - Preprocessing decimal literals more or less as they are (instead of via fractions)  https://hackage.haskell.org/package/decimal-literals-0.1.0.1 (leftaroundabout)
14:22:11 <fen> the `j' can bethought of as directions, instructions on how to get to the next value. like if you were pointing to the outer value of a tree, itwouldreturnthis value along with the directions that could be looped over to get to the next value, returning eachof the intermidiate directions returned by the state loop, whichcouldbe used to return a constructor to replace the value with the correct shaped branchfrom a the pointer that is re
14:22:44 <fen> hmm, think my spacebar is malfunctioning...
14:23:05 <zachk> I have seen that direction type used in some zipper implementations 
14:24:46 <fen> zachk: right, retaining the resulting [j] which is like the `i' of r a = (i,a), so that the zipper would be ([([j],a)],f a)
14:25:44 <fen> where we then need a set function ([j],a) -> f a -> f a
14:26:28 <fen> and the inverse process to unfolding the segment is to grow the `f a' using each `j' placing the `a' somewhere
14:26:53 <fen> to rewind the zipper
14:29:15 <fen> also, this unfolding process kind of uses the instructions/directions to get to the next value, and is costly, since it requires e.g. testing various directions to see which way you can go, like, going up a branch only if there are no other directions to go down along by checking the length of the list of branches.
14:30:48 <fen> so if we traverse_i, which stores the resulting i = [j] at each value, then this gives a mapAccum which can use these navigations on a carried copy of the container, to update it to always correspond to the current position during the traversal
14:31:26 <fen> this gives the comonad instance for pointers wherethe values are then replaced with the carried copy updated using the directions it encounters 
14:33:40 <fen> it seems there should be a way to relate `s -> (Maybe (r a),s)' or `s -> (r (Maybe a),s)' to `s -> Maybe (a,Maybe s)' and `(j,f a) -> Maybe (j,Maybe (f a))'
14:35:56 <jlamothe> Why is ghc so picky about leading whitespace on multi-line let statements in a do block?
14:36:11 <merijn> jlamothe: Because that's how the language is defined?
14:37:15 <merijn> jlamothe: The indent level of a multi-line let is set by the column number of the first non-whitespace character after the let.
14:37:36 <Solonarv> I usually write multi-line 'let's like this: https://gist.github.com/Solonarv/33a860f0d4f44f519c0575e2cf71b942
14:38:14 <merijn> Solonarv: See, if you just use 4 space indents that problem is irrelevant :p
14:38:22 <Solonarv> also true :P
14:39:45 <ch2db[m]> :)
14:40:08 <jlamothe> Hrm... it seems this problem isn't an indentation one...
14:40:21 <merijn> pastebin the code + error?
14:40:33 <jlamothe> Mismatched parens maybe...?
14:42:11 <tertl3> hi, Im starting this hackerRank tut and I cant this function to work when I compile it, it doesnt output the sum?
14:42:16 <tertl3> main = interact $ show . sum .map read . words
14:43:39 <zachk> @type interact
14:43:40 <lambdabot> (String -> String) -> IO ()
14:43:57 <zachk> you might need a unlines . stuff here . lines as well
14:44:04 <Solonarv> tertl3: it's waiting for the end of input, I think
14:44:35 <fen> > (show . (sum :: [Int] -> Int ) . map read . words) "1 2"
14:44:37 <lambdabot>  "3"
14:45:11 <Solonarv> 'interact' passes the *entire* input to the function — it doesn't work line-by-line!
14:46:10 <MarcelineVQ> is that true? interact (map toUpper) does interesting things as I type
14:46:49 <geekosaur> you're seeing line buffering and no more, since toUpper needs only a character to produce a character
14:47:06 <geekosaur> sum will consume an entire list, which will only be available at EOF on input
14:47:08 <tertl3> well what i post does compile, but when I run it, I dont get any output
14:47:30 <geekosaur> if you wrap the whole thing in lines and unlines, ]the sum operates per line
14:50:31 <MarcelineVQ> geekosaur: that makes sense thank you especially after looking at interact's definition
14:51:11 <tertl3> geekosaur, what do you mean wrap it in lines?
14:51:19 <tertl3> and unlines?
14:51:55 <geekosaur> main = interact $ lines . show . sum .map read . words . unlines
14:52:40 <geekosaur> now it reads values per line and computes their sum, instead of waiting until end of file or control-d (unix) / control-z (windows) to give you the sum of everything entered
14:54:11 <jlamothe> i think I solved it.  Just waiting on my tests to run now.
14:54:23 <tertl3> interesting, thank you
14:54:45 <jlamothe> Still not entirely sure whatvwas wrong with my original code...
14:56:11 <ch2db[m]> programming logic may be issue
14:59:46 <dedgrant_> Anyone know if GHC supports a TypeOperators-equivalent extension of PostfixOperators?
15:04:29 <jlamothe> TIL: Haskell doesn't like it when you put two let statements one after another in a do block.
15:06:09 <jlamothe> Tests passing!
15:06:16 <ClaudiusMaximus> > do{ let f False = 1; let f True = 2 {- shadows previous f, doesn't extend it with another pattern -} ; pure (f False) } -- was this your issue?
15:06:18 <lambdabot>  <hint>:1:119: error: parse error on input ‘}’
15:06:19 * jlamothe does a dance.
15:06:40 <jlamothe> ClaudiusMaximus: No.
15:07:03 <jlamothe> The compiler was outright refusing to compile.
15:07:41 <jlamothe> Not sure why.
15:08:09 <MarcelineVQ> what was the code/error?
15:08:21 <geekosaur> it's valid to have consecutive lets. you do need to watch indentation, since layout determines blocks by indentation. and may need braces if putting stuff on the same line
15:09:41 <jlamothe> I no longer have the exact error, but it was suggesting indentation or a paren mismatch as the possible culprit.
15:10:39 <jlamothe> I was given this syntax as a solution and it worked. https://gist.github.com/Solonarv/33a860f0d4f44f519c0575e2cf71b942
15:11:45 <jlamothe> Much to my surprise, because I couldn't find anything wrong with parens or indentation.
15:12:54 <jlamothe> Unfortunately, it's code owned by a client, so I'm not at liberty to share it verbatim.
15:26:41 <tertl3> geekosaur, still getting an error, one sec
15:27:10 <dyl> Can anyone provide any insight into why this usage of makeLenses fails? 
15:27:11 <dyl> https://gist.github.com/DylanLukes/3c30fb2d464c4330da0b4f924cae1896#file-machine-hs-L58
15:31:17 <Solonarv> at a guess, lens' TH isn't good at dealing with existentials
15:32:03 <Solonarv> you could probably get it to write lenses for _h, _s and _mode but I'm not sure it's even possible to write lenses for _heap and _regs
15:32:42 <dyl> Interestingly, this is fine:
15:32:43 <dyl> makeLensesFor [("_heap", "heap"), ("_regs", "regs")] ''Machine
15:32:51 <dyl> It's actually _h _s and _mode that it can't generate lenses for :p.
15:34:46 <dyl> The issue seems to be that it's generating lenses such as: 
15:34:57 <dyl> mode :: forall (m :: * -> *) (m1 :: * -> *). Lens (Machine m) (Machine m1) Mode Mode
15:35:05 <dyl> For _heap and _regs, it somehow figures out m ~ m1.
15:35:22 <Solonarv> oh, hm
15:35:39 <Solonarv> well either way it's the existential messing things up, so I was half right at least :p
15:35:49 <dyl> Half correct, half precisely incorrect.
15:35:50 <dyl> :p
15:36:25 <dyl> It... feels like this shouldn't be broken though?
15:37:53 <Solonarv> Can you write those lenses youself? (just to see if it's possible at all)
15:38:14 <dyl> I should like to think I can, let's see...
15:41:51 <dyl> Yeah I can write them Solonarv, though I do need to explicitly give them type signatures.
15:42:17 <Solonarv> that might be the issue, then
15:42:17 <dyl> e.g. h :: Lens (Machine m) (Machine m) Addr Addr; h = lens _h (\mch h' -> mch { _h = h' })
15:42:50 <dyl> The error is different though, relates to the functor in the definition of Lens.
15:43:59 <Solonarv> no; the only reason 'Functor' is mentioned in the error is because there is a 'Functor f' constraint in the context
15:44:30 <dyl> Ambiguous type variable ‘f0’ arising from a use of ‘lens’ prevents the constraint ‘(Functor f0)’ from being solved.
15:44:44 <dyl> That's the constraint I'm talking about, in the definition of Lens.
15:44:47 <dyl> type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
15:45:06 <Solonarv> the error is not related to functor at all; instead it's because ghc infers 'Lens (Machine m) (Machine m1) Mode Mode' for the code generated by Lens.TH
15:45:25 <dyl> I'm talking about the error when I write the lens manually and leave off the type signature.
15:45:26 <dyl> Not that one.
15:45:34 <Solonarv> oh sorry, I'm a bit distracted
15:45:42 <dyl> OK h :: Lens (Machine m) (Machine m) Addr Addr; h = lens _h (\mch h' -> mch { _h = h' })
15:45:48 <dyl> NOT OK: h = lens _h (\mch h' -> mch { _h = h' })
15:46:14 <Solonarv> Hm.
15:46:24 <dyl> Puzzling.
15:47:05 <ProofTechnique> #haskell-lens may have some insight.
15:47:21 <Solonarv> I'm not sure what *exactly* the issue is, tbh — but if a type signature fixes it that's enough for me to shrug
15:47:41 <ProofTechnique> The game there seems to be “drop an inscrutable type signature in channel and wait for someone to tell you the combinator”
15:48:33 <dyl> I'm amused that #haskell-lens is so close in size to -blah and -offtopic.
15:50:15 <dyl> Anyhow, I’m perplexed. 
15:50:47 <dyl> I think the issue was the existential, but I’m not sure why that affects its ability to unify m which is explicitly quantified.
15:50:58 <dyl> Well, is on the left side of the = 
15:51:13 <dyl> Why does it work for the weird fields :/.
15:57:07 * hackage pinch 0.3.4.1 - An alternative implementation of Thrift for Haskell.  https://hackage.haskell.org/package/pinch-0.3.4.1 (BenGamari)
15:58:41 <dyl> Solonarv further weirdness
15:58:50 <dyl> If I use Tagged a Mode/Addr, then it's fine :p.
15:59:42 <dyl> Writing _h :: forall a. Addr also works :|
15:59:54 <dyl> This does *not* seem right...
16:00:08 <Axman6> is that a type hole?
16:00:18 <dyl> No, just a prefixed record name.
16:00:23 <dyl> I'm producing a simpler example.
16:01:03 <wroathe> make 
16:01:15 <dyl> make: *** No targets specified and no makefile found.  Stop.
16:01:24 <dmwit> He made an exit.
16:01:55 <jle`> anyone know of a trick to generalize TestEquality in base to n-ary type constructors?
16:01:58 <jle`> https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Type-Equality.html#t:TestEquality
16:02:16 <jle`> i've tried looking at the n-ary-functors trick, http://gelisam.blogspot.com/2017/12/n-ary-functors.html, which is pretty neat. but i'm not sure if it's adaptable to this situaiton
16:02:41 <isTofu> Hello, I was wondering if some one could recommend a good starting book e.g (K&R For haskell). We're about to start learning haskell in University. I'd like to get a head start. I've used prolog, so I have some experiance with different paradigims. 
16:03:24 <isTofu> When i say (K&R) for haskell, i mean the goto book lol. 
16:04:04 <lyxia> jle`: what equality would it produce
16:04:21 <MarcelineVQ> isTofu: idk if there is an agreed upon goto, I enjoyed my time with haskell programming from first principles, I've seen others reccomend Programming in Haskell
16:04:46 <lyxia> jle`: equality on a component that's not the last, or equality on all components up to n, or something else?
16:05:17 <isTofu> Alright, thanks. What about IDE usage ? I'm planning on using emacs, however if there
16:05:22 <MarcelineVQ> isTofu: just to get familiar with things I even reccomend https://en.wikibooks.org/wiki/Haskell
16:05:28 <isTofu> 'there's a better option i'm all ears'
16:05:49 <jle`> lyxia: equality on all components, essentially
16:05:54 <isTofu> MarcelineVQ Thank you, 
16:06:16 <jle`> lyxia: what that witness might even look like is another question stil.  but i wonder if i can just do `f x y z :~~: f a b c`
16:06:22 <MarcelineVQ> emacs is a pretty standard choice with a few good haskell plugin options afaik, you can get pretty far with literally any text editor with language highlighting and ghci or ghcid to check your work
16:07:03 <MarcelineVQ> ghci comes with the ghc haskell compiler and will be how you first interact with haskell
16:07:23 <wroathe> Anyone know what the cabal new-build flag is to force a rebuild?
16:07:30 <isTofu> Okay great! I'm assuming ghci / ghcid equiv to gdb ?
16:07:54 <wroathe> isTofu: MarcelineVQ Programming in Haskell definitely had a K&R book feel to me
16:08:36 <Axman6> bgamari: Just had a look at pinch, your diagram at the top of the Pinch module should be added to so many more libraries, would love to see it in Aeson's docs
16:08:41 <MarcelineVQ> I've had very little time with gdb but that doesn't sound exactly right to me. ghci is a REPL (read eval print loop) if you want a term you can search
16:09:09 <lyxia> jle`: Have you considered   class DecEq a b where decEq :: a -> b -> Maybe (a :~: b)   and then generalize with   DecEq1 f = forall a b. DecEq (f a) (f b)   DecEq2 f = forall a1 a2 b1 b2. DecEq (f a1 a2) (f b1 b2)   etc.
16:09:24 <bgamari> Axman6, thanks, although it really isn't my diagram at all
16:09:28 <isTofu> Thank you for the information MarcelineVQ,
16:09:42 <bgamari> the package is almost exclusively Abhinav Gupta (great!) work
16:09:43 <jle`> lyxia: i tried that first but i ran into some issues. let me try to figure out what they were
16:09:49 <isTofu> I'm more terrified to learn this language, than I was skydyving, or rock climbing for the first time. :|
16:09:53 <bgamari> I just help maintain it
16:10:45 <MarcelineVQ> isTofu: Don't be too worried, you can ask in here about any problems you run into no matter how small they might seem. Just meet peple half-way any include a link to what you tried and what error you got :>
16:10:57 <jle`> lyxia: ah i had some issues with defining instances in terms of other instances
16:10:58 <MarcelineVQ> *half-way and
16:10:59 <dyl> Here's the reduced lens weirdness case: https://gist.github.com/DylanLukes/a195c670cf7a3dbd8bec105242af3fa0
16:11:05 <Axman6> bgamari: well if you get a change, tell him I appreciate it. might even consider doing a similar thing for aeson
16:11:08 <dyl> If anyone has any ideas... let me know. I am flummoxed. 
16:11:19 <isTofu> Alright, great :D
16:11:20 <lyxia> jle`: :(
16:11:23 <Axman6> isTofu: Haskell as a language is extremely simple, in the Data61 FP course, 90
16:11:35 <Axman6> 90% of the language is taught in the first 20 minutes
16:11:40 <isTofu> Really ?
16:11:48 <dyl> Why the heck is `forall a.` making a difference? STV?
16:12:27 <dyl> Huh, it's not STV it seems.
16:12:41 <Axman6> isTofu: Actually, I know you're after a book, but the Data61 course isn't a bad introduction (though it's better to go through it with someone like Tony who fills in all the gaps)
16:12:44 <jle`> lyxia: the problem comes up when i have to say instance (forall a b. DecEq (F a) (F b)) => DecEq (MyType x) (MyType y), I think.  but it also might have to do with some interplay with type families
16:12:59 <isTofu> Axman6, the smartest people i've met in my life love haskell. This is what scares me about it lol.
16:13:07 <Axman6> isTofu: #1 rule for learning haskell: All Functions Take Exactly One Argument
16:13:30 <isTofu> Is it simular to prolog ?
16:13:34 <jle`> i'll see if i can reproduce a simple example
16:13:41 <isTofu> i.e functions are just predicates / functors 
16:13:42 <Axman6> you'd be surprised how often when you'rew learning reiterating that rule will help you get through some silly syntactic problem
16:14:12 <jle`> isTofu: i would say that it's different from prolog.  prolog is about staing your problem in terms of constraints
16:14:15 <Axman6> I haven't done enough prolog to be able to say, but I understand they are quite different
16:14:30 <jle`> i don't think there's anything very much in common between haskell and prolog
16:14:35 <isTofu> that sucks lol
16:15:13 <Axman6> (It;s not very hard ti implement prolog like behaviour in Haskell IIRC)
16:15:31 <jle`> isTofu: btw, one suggestion i can give is to try to "forget" everything you've learned about other languages when going into haskell
16:15:52 <jle`> in particular, vocabulary like functor, class, instance, etc.
16:15:57 <Axman6> secconded
16:15:59 <isTofu> okay. 
16:16:03 <isTofu> Well the class thing. 
16:16:06 <jle`> they mean things pretty different in haskell than they might in prolog, java, etc.
16:16:08 <isTofu> Im a C guy. 
16:16:10 <isTofu> and ASM 
16:16:17 <isTofu> I dispise java for the most part. 
16:16:20 <isTofu> it's to complex. 
16:16:35 <Axman6> Java is actually quite a simple language
16:16:43 <bsima> ??
16:16:45 <isTofu> There's so much. 
16:16:52 <isTofu> I disliked C++ for that reason as well. 
16:16:59 <bsima> haskell is more *regular* than java/c++
16:17:05 <isTofu> It just seems like given 10 life times, you could never really learn java. 
16:17:23 <pacak> java itself or all of it's libraries/frameworks/whatever?
16:17:26 <isTofu> we did our data structures class in java, i wish we would have used C. 
16:17:31 <isTofu> All the frameworks etc. 
16:17:35 <isTofu> java alone is quite nice. 
16:17:37 <Axman6> that's not the language though
16:17:37 <hpc> there isn't much to java for you to learn - it's learning all the jank in every library that's too much
16:17:43 <isTofu> Axman6, true. 
16:17:48 <jle`> another thing that might be helpful is to suppress the feeling of "but then how am i going to do ____?" that you'll get very often when starting to learn haskell; it can get pretty dizzying, heh. given enough patience you'll start to see problems solved in a different way and things will start to make sense
16:18:19 <jle`> although if you're learning Haskell for a course, you might get something different out of it than you'd get if you're learning Haskell for "industry" progrmaming
16:18:25 <isTofu> jle` okay, so is this one of those things that take a ton of dedication then you just get it ?
16:18:40 <isTofu> Well we have to code a 3Sat solver in it. 
16:18:48 <Axman6> Haskell is similar, then language is very simple with very few co0nstructs, but that can be combined into arbitrarilly complex/abstract ideas - this is a good thing for any language because it does not limit you, but is can make learning _to use_ the language take longer
16:18:51 <isTofu> We've already done the same solver in C / Prolog. 
16:18:56 <isTofu> the last itteration is in Haskell. 
16:18:59 <jle`> isTofu: it's more like these problems you're thinking of might not actually be real problems at all if you switch to fully functional thinking
16:19:15 <jle`> for example, "if i can't mutate variables, how do i write a for loop?"
16:19:39 <isTofu> Interesting. 
16:19:46 <jle`> in the end the problem is "the thing you would use a for loop for is actually solved using another construct"
16:19:56 <jle`> so spending time worrying about writing a for loop ends up being counter-productive
16:19:58 <isTofu> So it will improve my mathematical ability all around i'm assuming. 
16:20:15 <jle`> maybe. i think that part of haskell might be overstating
16:20:19 <jle`> *overstated
16:20:27 <isTofu> Fair. 
16:20:27 <jle`> but it does look like you're using haskell to learn mathematical concepts
16:20:40 <Axman6> isTofu: no necessarilly, ideas from maths are used in Haskell but you don't need the maths to learn Haskell
16:21:01 <jle`> i guess is my point is that most univerisities use Haskell as a vehicle to teach PL concepts like functional programming, purity, denotative semantics, type inference
16:21:42 <jle`> so a semester's course in Haskell might not necessarily teach you how to, say, build a web app
16:22:59 <jle`> so you won't necessarily be taught how to handle 'real-world' problems that arise from actual applications
16:23:28 <jle`> but you'll at least be able to probably get to the point of your first or second semester beginning programming class in terms of proficiency
16:23:29 <isTofu> jle` my university is the reincarnation of the 3rd riche, our first language was C++ using emacs in linux, we have done nothing but learn algorithm after algorithm, the only UI i've ever done is what i'm doing right now which is building a monochrome game from scratch with C / m68k ASM using rasters. 
16:23:42 <isTofu> The real world is a construct in our minds right now. lol
16:24:04 <jle`> haha. sounds like quite a ride :)
16:24:07 <isTofu> Front end web app for me is printing triangles in C. 
16:24:52 <isTofu> lol yeah, it's good though! Small class sizes. We can maximum educational value for our $.
16:25:56 <isTofu> What was this Data61 thing you spoke of btw ?
16:26:03 <jle`> i guess also in most universities, languages are really only taught as vehicles for larger lessons. so maybe the thought i was trying to formulate was not to worry about the language itself, but rather the concepts they might be trying to teach you in the moment
16:26:27 <Solonarv> searching is proving fruitless, so I'll ask here: what's the incantation to make 'cabal v2-sdist' include nice hackage-ready haddocks?
16:27:21 <isTofu> jle` Aye, I really want to love this language. I'd like to see the 'beauty' of it that everyone raves about.
16:27:54 <jle`> hope you'll have a fun time with it :)
16:28:06 <jle`> @where learnhaskell
16:28:06 <lambdabot> https://wiki.haskell.org/Learning_Haskell
16:28:26 <jle`> oh hm, that wasn't eh link i was looking for
16:29:53 <isTofu> https://github.com/data61/fp-course
16:30:57 <jle`> ah yeah, that looks like the one
16:31:01 <isTofu> Yay!
16:31:13 <isTofu> Awesome, thanks for all the great info. 
16:35:37 <lightandlight> Is there a library with `data OS = Windows | Linux | Mac | etc...` and a function that tells me which of these the program is run on?
16:35:49 <lightandlight> I've seen System.Info, but is has `os :: String` which is next to useless
16:36:40 <dminuoso> lightandlight: Things are not as clear cut.
16:36:49 <dminuoso> What does "Linux" even mean?
16:36:53 <lightandlight> It can be more finely grained
16:37:02 <lightandlight> But it shouldn't be as big as String
16:37:19 <dminuoso> lightandlight: What is your endgoal
16:37:52 <lightandlight> I need my program to behave differently depending on which platform it runs on
16:38:39 <lightandlight> And I have no way of knowing a priori which values of `os :: String` I care about
16:40:12 <lightandlight> Ah, https://hackage.haskell.org/package/foundation-0.0.23/docs/Foundation-System-Info.html
16:40:43 <lightandlight> It's in an alternative prelude, though :<
16:41:37 * hackage vinyl-named-sugar 0.1.0.0 - Syntax sugar for vinyl records using overloaded labels.  https://hackage.haskell.org/package/vinyl-named-sugar-0.1.0.0 (Solonarv)
16:41:47 <Solonarv> \o/
16:42:09 <hpc> a couple of other options are CPP #if and OS flags
16:42:33 <hpc> or in cabal, i think you can swap out modules with if os() or something like that?
16:43:44 <lightandlight> Cabal seems to have a more robust version of what I'm looking for https://github.com/haskell/cabal/blob/master/Cabal/Distribution/System.hs
16:45:19 <hpc> that looks good
16:45:49 <hpc> although, Cabal's quite the dependency to pull in for that
16:46:14 <lightandlight> I'm filing an issue to see what people think of factoring it out
16:46:18 <hpc> probably still better than an alt prelude
16:46:25 <jle`> % os
16:46:25 <yahb> jle`: ; <interactive>:40:1: error:; * Variable not in scope: os; * Perhaps you meant one of these: `on' (imported from Data.Function), `or' (imported from Prelude), `cos' (imported from Prelude)
16:46:32 <jle`> % System.Info.os
16:46:32 <yahb> jle`: "linux"
16:47:05 <jle`> lightandlight: it looks like you can probably just copy+paste the matching code from Cabal, license issues aside
16:47:19 <lightandlight> sure, that works too
16:47:33 <jle`> it's basically just a string parser
16:47:52 <jle`> so nothing too fancy
16:48:35 <jle`> nothing fancy as in, CPP or IO magic
16:49:28 <lightandlight> Ya, I'll turn to code duplication as a last resort
16:51:18 <hpc> take a look at how directory does it, perhaps
17:08:25 <gentauro> I missed some overview from `SaveYourInternet` (Article 13 = meme ban) so I made this -> http://blog.stermon.com/articles/2019/02/21/haskell-eu-meps-overview-on-article-13-meme-ban.html
17:08:29 <gentauro> we are screwed :(
17:09:34 <gentauro> Sweden, Estonia, Austria, Czech Republic and Poland really have some nice politicians. The rest of EU, we have a bunch of techno-tards :(
17:10:25 <dyl> gentauro you do know there is no meme ban, nor was there ever, right?
17:10:43 <dyl> Memes have been covered under parody copyright exemption for... almost 20 years.
17:10:48 <dyl> (in the EU)
17:11:27 <gentauro> dyl: isn't that why they are chaning the law?
17:11:34 <dyl> ...no?
17:11:50 <gentauro> well if your platform needs to ensure that no copyright material can be uploaded
17:11:56 <gentauro> how are you going to have memes?
17:12:15 <dyl> Again, there is and has been a parody exemption. Memes are not copyright infringement, nor were they.
17:12:50 <gentauro> dyl: I don't think you are correct. If I use Coca Colas picture on my `paid` platform
17:12:50 <dyl> Actually, you might like to know that Article 13 specifically requires sites to have a redress mechanism for content inappropriately removed due to copyright claims.
17:12:58 <dyl> You know, like what's happening on YouTube right now :).
17:13:50 <gentauro> the problem with Youtube is that a lot of stuff is uploaded (and monetized) by other who haven't produced the media
17:14:04 <dyl> The meme ban thing was never substantiated in fact, it was just repeated often enough people believed it.
17:14:45 <gentauro> but Article 13 will hit Youtube like a truck, but it will also hit Imgur as hard as well
17:15:00 <gentauro> and that's one of our `meme platforms`
17:15:20 <gentauro> so it's all about the `memes` which is the important part
17:15:33 <gentauro> but I really envy Swedish politicians
17:16:09 <gentauro> 18 Against and 2 Neurtral, but none For. That's amazing
17:16:21 <gentauro> I'm a bit dissapointed with Finland though
17:16:25 <gentauro> it's a 50-50
17:20:51 <jle`> lyxia: i changed my mind, i only want the last parameter
17:22:16 <jle`> so it'd probably be a generalization of `forall a b c d. F a b -> F c d -> (b :~~~: d)`
17:22:20 <jle`> * :~~:
17:22:55 <jle`> hm, maybe the same system as before, but with (k -> Type) (j -> Type) as inputs might work...
17:30:20 <jle`> but i guess that's just a poly-kinded TestEquality then
18:38:13 <tertl3> hello again I forgot who was helping me
18:38:41 <tertl3> Im still working on this one liner but im having a hard time
18:39:59 <koz_> tertl3: I can try.
18:42:20 <tertl3> koz_, this one liner compiles but it doesnt print the answer out 
18:42:22 <tertl3> main = interact $ show . sum . map read . words
18:44:08 <monochrom> @type show . sum .map read . words
18:44:09 <lambdabot> String -> String
18:44:39 <monochrom> > (show . sum . map read . words) "1 2 3 4"
18:44:41 <lambdabot>  "10"
18:45:09 <Solonarv> I know this one: it's waiting for the end-of-input
18:45:12 <Solonarv> at least I'm pretty sure
18:45:18 <monochrom> Since it doesn't have a newline at the end, maybe you were just not spotting the print-out at a place you didn't expect.
18:45:40 <monochrom> Oh you're entering by hand not file redirection.
18:45:41 <Solonarv> tertl3: how is your program being run?
18:45:54 <Solonarv> (I have no idea, but that's the likely issue)
18:45:59 <tertl3> i want to run it from command line, not ghci
18:46:08 <tertl3> ./function
18:46:10 <tertl3> like that
18:46:16 <monochrom> And then?
18:46:58 <tertl3> i just dont get it, its supposed to print to StdOut
18:47:12 <monochrom> What and how did you enter input?
18:47:29 <tertl3> i enter it like ./function "2 2"
18:47:40 <tertl3> i tried with parens and comma
18:47:54 <monochrom> Is that what "interact" expects? Command line parameters?
18:48:18 <tertl3> @t interact
18:48:18 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
18:48:36 <Solonarv> :t interact
18:48:37 <lambdabot> (String -> String) -> IO ()
18:48:38 <monochrom> The type can't answer this question. "String" could come from anywhere.
18:49:02 <monochrom> Yes I'm making this a case of "did you actually check, or did you just presume"
18:49:54 <tertl3> thats what I dont understand, where is the string supposed to come from?
18:50:12 <Solonarv> standard input
18:50:14 <monochrom> What did the doc say?
18:51:19 <tertl3> the doc for what?
18:51:23 <monochrom> interact
18:52:46 <tertl3> it takes a string of all the input and returns all the output
18:53:48 <monochrom> No. Sorry to say but you made that up.
18:54:05 <monochrom> "The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device."
18:54:16 <monochrom> If you're not seeing that sentence you're not reading the doc.
18:56:28 <tertl3> but how does it get the input from standard input?
18:56:49 <Solonarv> that's an implementation detail of 'interact'
18:57:10 <Solonarv> presumably, it uses 'getContents'
18:59:04 <sebastianlin> if you want to take the args from the command line you might want to use `getArgs`
18:59:29 <Solonarv> (then you would not be using 'interact' anymore)
19:00:19 <sebastianlin> i have no idea what the problem she/he is solving though
19:01:08 <maerwald> tertl3: "the entire input"
19:01:22 <maerwald> this is how unix devices work, use a pipe
19:02:01 <Solonarv> you can write: program <<<"blah blah"
19:02:13 <shapr> Anyone know of a tutorial for cereal?
19:02:21 <Solonarv> to use blah blah as 'program's stdin
19:02:31 <maerwald> echo "1 2" | runhaskell Main.hs
19:02:37 <maerwald> where Main.hs is your one-liner
19:02:49 <Solonarv> yes, or echo "blah blah" | program ;)
19:03:56 <monochrom> <<< is from bash, isn't it?
19:04:21 <Solonarv> possibly; I use bash and it works for me
19:04:40 <geekosaur> bash and zsh
19:04:49 <tertl3> both of them worked
19:05:06 <maerwald> rtfm is not always a good answer ;)
19:05:47 <monochrom> Sure
19:05:56 <tertl3> this guy is kind of cheating with the one liner
19:06:09 <Solonarv> "this guy"?
19:06:22 <tertl3> yes the HaskellRank guy
19:06:32 <shapr> where?
19:06:43 <tertl3> https://www.youtube.com/watch?v=h_D4P-KRNKs
19:07:26 <monochrom> If you call that cheating, do you have a better alternative?
19:08:02 <monochrom> Yes every time anyone states a criticism I'm going to ask "do you have a better alternative?" to keep them honest.
19:08:58 <maerwald> We're not in a classroom :P
19:09:29 <monochrom> I know right? We need more "do you have a better alternative?" outside classroom in the real world.
19:10:06 <Solonarv> the HackerRank test runner seems to (correctly!) shove the entire input into stdin and then send EOF
19:10:16 <monochrom> We need more people in the real world to acknowledge that opinion is cheap, what we need is improvements and solutions.
19:10:53 <tertl3> Solonarv, do you think thats fishy? or
19:10:56 <sebastianlin> isn't that what this kind of websites (leetcode, codeforces, etc) do...?
19:11:10 <sebastianlin> and all the online judges website
19:11:21 <Solonarv> I said "correctly!", what do you think?
19:11:49 <tertl3> i think he hacked the test runner
19:11:56 <Solonarv> no
19:12:35 <tertl3> ok, maybe Im just mad that I didnt think of the pipe on my own
19:12:49 <tertl3> so sue me
19:13:09 <Solonarv> how do you think the test runner should work? keep in mind that programming problems like that usually have some pretty large test cases -- too big to pass them as command-line arguments!
19:14:02 <monochrom> Hell, most of those websites explicitly state "we'll use stdin" so you already know.
19:14:29 <monochrom> In my experience even every individual problem re-states that again and again.
19:14:54 <monochrom> Certainly I re-state it when I wrote practice problems for my students.
19:15:21 <monochrom> well, re-stated. Last time I made practice problems was a decade or two ago.
19:17:00 <shapr> so I found network-data which has Serialize instances for Ethernet and IP and IPv4, but I'm not clear on how to use those instances together
19:19:08 <shapr> is the sensible approach to make a new Serialize instance for a record that has a field for each piece?
19:19:39 <monochrom> I think so.
19:19:49 <shapr> ok, I'll try that
19:20:02 <monochrom> Serialize has methods "put" and "get" and from that point onwards it looks very similar to binary.
19:28:07 <blackbart> I'm new to Haskell and have this problem I thought Haskell would be great for. I want to make shelves for Karen. Karen decides the size of each shelf: [12, 12, 10, 6] or [8, 8, 8] (the number of shelves is specified implicitly). I need to know the position of each shelf -> [0, 12, 24, 34, 40], [0, 8, 16, 24]. (First shelf always starts at 0; top shelf has no height limit, so output should be 1 longer)
19:28:43 <blackbart> Here's what I came up with (mostly by trying to modify the example for reverse in LYAK)  https://pastebin.com/raw/DcaKvjeM
19:29:20 <shapr> this isn't homework?
19:29:33 <monochrom> I wonder why sp [5] is not simply [0]
19:30:14 <blackbart> No. I actually was trying to make a spice rack in openscad, got a little frustrated and wondered if it'd be easier in haskell, but, no, I suck in both :(
19:30:17 <monochrom> Either that, or why sp [] isn't [0].
19:31:29 <Solonarv> :t scanl
19:31:30 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
19:31:45 <monochrom> I think the error message "<interactive>" blah blah means that you just entered that code by hand into ghci.  That is a big mistake.
19:31:51 <Solonarv> ^ this is the function you want, btw
19:32:21 <monochrom> If you enter code like that by hand into ghci, later lines replace (not add to) previous lines. You only have the last line left.
19:32:37 <monochrom> The right thing to do is to put it in a file and use :load and/or :reload
19:32:52 <blackbart> Solonarv: cool. I did think about foldl too. Can it not be done in foldl, or is scanl just better?
19:33:29 <Solonarv> you can do it using foldr or foldl as well, but I didn't bother trying since scanl does exactly what is needed here
19:33:42 <blackbart> monochrom: Oh? that could explain lots of frustration
19:35:40 <Solonarv> you can enter multi-line definitions using :{ and :}, though
19:35:57 <monochrom> It doesn't scale.
19:36:31 <Solonarv> true
19:36:33 <monochrom> It breaks as soon as you have entered 5 lines and suddenly you realize you need to go back to line 3 and change one single letter.
19:36:49 <monochrom> This is why I always refuse to mention that misfeature.
19:37:57 <monochrom> Until one day ghci becomes a real full-blown editor like DrRacket, you should just use a real full-blown editor.
19:38:07 <monochrom> Gosh even sed is infinitely better.
19:38:23 <monochrom> Err, ed
19:41:27 <Phyx-> lightandlight: it shouldn't matter much, Cabal is a boot library so it ships with the compiler, and you don't need any specific version for this so you can just use the one that's installed.
19:41:55 <Phyx-> lightandlight: it shouldn't increase your binary size either due to -ffunction-sections.
19:42:14 <Phyx-> lightandlight: also the GHC api has a similar interface, https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc-8.6.2/Platform.html
19:43:04 <lightandlight> cool, thanks
19:44:04 <shapr> next silly question, is there an easy way to find packages that depend on a package on hackage?
19:44:27 <shapr> oh, oh looks like https://packdeps.haskellers.com/reverse
19:44:32 <monochrom> Yeah
19:44:54 <monochrom> (Did you just Google and got a hit?)
19:45:18 <shapr> yup
19:45:25 <shapr> "hackage reverse dependencies" doh
19:45:56 <shapr> I'm trying to figure out how to switch which parser I call next depending on the type of packet, not sure how to structure that
19:46:37 <monochrom> Is "type of package" determined by something like "the first byte you receive"?
19:46:44 <glguy> do tag <- getPacketTag; case tag of Tag1 -> parsePacket1; Tag2 -> parsePacket2
19:46:46 <glguy> like that?
19:46:56 <shapr> glguy: ooh yeah
19:47:00 <monochrom> Yeah, Get is a monad, you can do that.
19:47:49 <blackbart> monochrom: hey! it actually worked when I put it in a file
19:47:53 <shapr> still would like to find an existing package already doing something like this and see if there are other options
19:49:26 <blackbart> (I only had to flip the operands to ++ on line 3 to make the order make more sense)
19:50:50 <monochrom> Use DeriveGeneric on your algebraic data type, then you will get an automatically generated Serialize instance.
19:51:51 <blackbart> monochrom: Changing sp [] = [] to sp [] = [0] actually did not insert the 0 I wanted in the first position, though. (so sp [] = [0]; sp [x] = [x];)
19:51:53 <shapr> thing is, I'm trying to replace data in a packet capture file that's in an existing protocol (SIP) that's usually on top of UDP, but could be on top of TCP
19:52:53 <monochrom> blackbart: "scanl (+) 0" will work great except scanl (+) 0 [] = [0] so maybe just watch out for that and do your own pre-screening before handing over to scanl. (Either that, or change to a more rational specification!)
19:53:21 <monochrom> If it's an existing protocol you have to conform to, you will have to handwrite code.
19:53:49 <monochrom> It should be pretty short...
19:55:13 <monochrom> OK in theory you give the protocol grammar to a parser generator and get code written but meh we don't have that for Haskell for these binary protocols.
19:55:30 <blackbart> monochrom: I actually like that specification. I feel it gives me more flexibility. So, like I said, I was drafting a spice rack in openscad. I don't actually yet know how many shelves, or the heights, so I wanted it to be as flexible as possible and scale appropriately given only the most relevant criterea. I thought it would be fun example for learning Haskell
19:56:49 <monochrom> Yeah
19:57:02 <shapr> monochrom: I like that theory, but I've not heard of such a parser generator
19:57:02 <monochrom> Maybe I should put that on my midterm!
19:57:27 <Clint> shapr: have you looked at network-house
19:57:35 <monochrom> Hell in fact I don't even think the C people have this kind of binary protocol parser generators.
19:57:57 <monochrom> The C people enjoy re-coding the wheel, you know...
19:59:10 <shapr> Clint: I'll look at it now
20:01:20 <monochrom> That's pretty neat.
20:14:22 <maerwald> https://github.com/UpstandingHackers/hammer
20:14:25 <maerwald> no?
20:14:49 <monochrom> haha great
20:15:07 <maerwald> that was part of LANGSEC: http://langsec.org/
20:15:37 * hackage line-bot-sdk 0.1.0.0 - Haskell SDK for LINE Messaging API  https://hackage.haskell.org/package/line-bot-sdk-0.1.0.0 (moleike)
20:16:10 <maerwald> awesome project, just sad Sassaman is not there anymore
20:17:07 <maerwald> haskell is even mentioned in their research and they believed parser combinators to be a fundamental building block for security and input validation
20:17:27 <maerwald> (compare with ad-hoc parsers in nginx etc code)
20:34:31 <freusque> what is generally considered more pleasant to read between a huge pattern match or a huge case expression? 
20:37:26 <pavonia> I prefer case expressions because you don't have to repeat the function name all the time
20:37:29 <pacak> case expression is a bit less verbos
20:40:48 <shapr> maerwald: in my research I found https://github.com/rust-bakery/parser_benchmarks
20:41:16 <shapr> freusque: I prefer pattern matching
20:56:32 <freusque> I prefer to read pattern matching, but prefer to write case expressions (because of where bindings)
20:56:53 <freusque> the reverse, actually. :)
20:58:07 <maerwald> shapr: so am I reading correct that hammer is the slowest?
20:58:59 <maerwald> maybe they use strlen :>
21:25:31 <jle`> sometimes you can turn a multi-clause function into a LambdaCase, and it'll help you spot useless variable names
21:25:54 <jle`> and you get the benefit of sharing `where` bindings
23:20:23 <trcc> I am working within the IO monad. And now I make a function call, that returns something in the Writer monad. So now I have this issue: Expected IO a, actual type: Writer [logentry] a
23:20:39 <trcc> Can someone point me to the term to look up?
23:21:16 <dminuoso> trcc: can you show the code you have?
23:21:41 <trcc> dminuoso: https://gist.github.com/CThuleHansen/6a24e7cc5912666fd3e95fd404775e49
23:21:49 <trcc> I think I have filled in enough types for it to be clear
23:22:53 <dminuoso> trcc: are you aware of how do-notatoin desugars?
23:23:22 <trcc> I believe so. x <- something compares to something >>= \x -> ...
23:23:59 <dminuoso> You are asking for (>>=) :: (IO a) -> (a -> Writer A b) -> IO b
23:24:19 <Axman6> I think you want something like case runWriter (getLogic ...) [] of, you can't call Writer inside an IO do block
23:31:41 <dminuoso> trcc: What exactly are you trying to do with the writer there?
