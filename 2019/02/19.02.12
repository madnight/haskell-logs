00:06:22 <gentauro> opqdonut: is it possible to write a recursive `seq` to ensure all (nested) functions are evaluated with regard of whnf?
00:06:29 <gentauro> @seq
00:06:29 <lambdabot>  Sequence not found.
00:06:40 <gentauro> % :t seq
00:06:40 <yahb> gentauro: a -> b -> b
00:30:47 * hackage country-codes 0.1.4 - ISO 3166 country codes and i18n names.  https://hackage.haskell.org/package/country-codes-0.1.4 (FelipeLessa)
00:37:01 <dminuoso> cocreature: His point was rather "You couldn't implement fold' in terms of seq"
00:37:13 <dminuoso> cocreature: Which differs from "it would fuck up fold'"
00:37:46 <dminuoso> I mean it does beg the question, why does GHC implement those functions not in terms of pseq.
00:37:55 <dminuoso> Is that an oversight? 
00:39:04 <Orbstheorem> Is there a way to “teach” a data definition to lambdabot ?, I wanna tell him that `data Nat = Zero | Succ Nat`
00:39:20 <dminuoso> @ let data Nat = Zero | Succ Nat
00:39:24 <dminuoso> @let data Nat = Zero | Succ Nat
00:39:26 <lambdabot>  Defined.
00:39:35 <Orbstheorem> Cool ^^
00:39:38 <dminuoso> Orbstheorem: Alternatively you can use % which sends commands to yahb. yahb is basically just a GHCi bot.
00:39:42 <Orbstheorem> Manpage somewhere? ^^
00:40:01 <dminuoso> Orbstheorem: No idea, perhaps yahb is easier to use then (since it feeds everything just to GHCi)
00:40:10 <Ariakenom> % data Nat = Zero | Succ Nat -- easy
00:40:11 <yahb> Ariakenom: 
00:40:13 <Orbstheorem> I have ghci, I'm (ab-)using lambdabot for ?pl x)
00:43:46 * hackage cairo-core 1.16.6 - Cairo Haskell binding (partial)  https://hackage.haskell.org/package/cairo-core-1.16.6 (magicloud)
00:47:26 <gentauro> is there any way to write a `list comprehension` like this (F#/OCaml) -> `let foo : bigint -> bigint list = fun n -> [ 3I .. 2I .. n ]` so that `foo 10I = [3I; 5I; 7I; 9I]` becomes `val it : bool = true`
00:47:48 <gentauro> I seem to struggle with `take` as it requires an `Int` while I want to use an `Integer` (big int)
00:49:15 <dminuoso> gentauro: That last part does not make sense to me. What do you mean by: so that `foo 10I = [3I; 5I; 7I; 9I]` becomes `val it : bool = true`
00:50:26 <Ariakenom> % (\n -> [3, 5 .. n]) 10
00:50:26 <yahb> Ariakenom: ; <interactive>:68:9: error:; Not in scope: `fromInteger'; Perhaps you meant `formatInteger' (imported from Text.Printf); <interactive>:68:12: error:; Not in scope: `fromInteger'; Perhaps you meant `formatInteger' (imported from Text.Printf); <interactive>:68:21: error:; Not in scope: `fromInteger'; Perhaps you meant `formatInteger' (imported from Text.Printf)
00:50:36 <Ariakenom> eh
00:50:47 <dminuoso> % :q
00:50:48 <yahb> dminuoso: 
00:50:51 <dminuoso> % (\n -> [3, 5 .. n]) 10
00:50:52 <yahb> dminuoso: [3,5,7,9]
00:50:55 <Ariakenom> right
00:51:38 <Ariakenom> % (\n -> [3, 5 .. n]) 10 :: [Integer]
00:51:38 <yahb> Ariakenom: [3,5,7,9]
00:52:00 <eiGHttt> % takeWile (< 10) $ [3, 5..]
00:52:00 <yahb> eiGHttt: ; <interactive>:3:1: error:; * Variable not in scope: takeWile :: (Integer -> Bool) -> [Integer] -> t; * Perhaps you meant one of these: `BSLC.takeWhile' (imported from Data.ByteString.Lazy.Char8), `BSC.takeWhile' (imported from Data.ByteString.Char8), `takeWhile' (imported from Prelude)
00:54:07 <gentauro> dminuoso: Haskell `==` (equality operator) is simply `=` in F#/OCaml (more mathematically correct if u ask me)
00:55:04 <gentauro> Ariakenom: didn't know you could just [3, 5 .. ]. It's exactly what I was looking for :o
00:55:12 <Ariakenom> :D
00:55:22 <gentauro> always learning new stuff here xD
01:05:30 <delYsid> How do I install a custom file viac hpack/cabal?
01:06:45 <merijn> delYsid: Lookup data files in the cabal user guide
01:10:46 * hackage libyaml 0.1.1.0 - Low-level, streaming YAML interface.  https://hackage.haskell.org/package/libyaml-0.1.1.0 (MichaelSnoyman)
01:14:42 <delYsid> merijn: Thanks.  It looks like Data files go to a specific directory.  I would like to put stuff into XDG config dir...  Is there a way?
01:15:51 <merijn> delYsid: There are two separate issues here: 1) telling cabal about data files for distributing source/building and 2) controlling the way it finds files at runtime
01:17:05 <merijn> delYsid: data files in your cabal file deals with 1. 2 is resolved by, by default looking inside the ~/.cabal/ install dir. If you want them elsewhere there are environment variables you could use, but that's a hassle and mostl intended for people distributing binaries built in haskell via, e.g. apt-get or something
01:17:37 <merijn> delYsid: XDG config dir sounds like something that is a config file, not a data file which isn't what cabal's data files are intended for
01:18:08 <merijn> delYsid: You could ship a "default" config file as data file and then copy it to XDG config at runtime (where the user can then edit it)
01:19:18 <delYsid> I see, OK.
01:27:49 <Orbstheorem> Is there a reason why we can't do `a, b = fn aa, f2 bb`, but instead we have to do `(a, b) = (fn aa, f2 bb)`?
01:29:38 <tdammers> Orbstheorem: because the language spec says so?
01:29:44 <merijn> Orbstheorem: Because (a, b) is just a pattern match on tuples and the former is not, because that's not tuple syntax
01:29:52 <dminuoso> Orbstheorem: My guess is that it's a bit more consistent.
01:30:41 <tdammers> more specifically, languages that allow this kind of syntax (python, lua) have special cases built into their parsers to handle this, and it doesn't mean the same thing there as it would in Haskell anyway
01:31:03 <tdammers> a, b = f, g -- would mean "assign f to a and g to b", but Haskell doesn't have assignment
01:31:25 <tdammers> you could interpret it as binding variables instead of assignment, and then you'd probably write let a, b = f, g
01:31:52 <tdammers> but we don't have that special-cased; let bindings are one variable at a time
01:32:12 <tdammers> and the version with parentheses means something else, namely pattern-matching on a 2-tuple
01:32:31 <Orbstheorem> Hmm, then why `a:as = [1..10]` works?
01:32:38 <tdammers> pattern matching
01:32:46 * hackage haiji 0.2.1.1 - A typed template engine, subset of jinja2  https://hackage.haskell.org/package/haiji-0.2.1.1 (NoriyukiOhkawa)
01:32:47 <merijn> Orbstheorem: Because that's a valid pattern for lists
01:32:47 <dminuoso> Orbstheorem: Because it's *lists* that have syntax desugaring.
01:32:48 <tdammers> (:) is just a plain old list constructor
01:32:48 <Orbstheorem> So, parenthesis are part of the tuple syntax
01:32:52 <tdammers> yes
01:32:53 <merijn> Orbstheorem: Yes
01:32:57 <dminuoso> Orbstheorem: Formally [1,2,3] is written 1:(2:(3:[]))
01:33:29 <dminuoso> Orbstheorem: So a:as might be pattern matching against 1:2:3:[], where a was bound to `1` and `as` to `2:3:[]`
01:33:29 <Orbstheorem> Okay
01:33:33 <Orbstheorem> Thanks!
01:33:35 <tdammers> it becomes clearer if you use (hypothetical) normal-data-type-notation (i.e., non-operator, non-sugared) versions of the list and tuple types
01:33:53 <tdammers> e.g.: data Pair a b = Pair fst snd
01:33:58 <dminuoso> Orbstheorem: In Haskell pattern matching happens the same way you construct data.
01:34:04 <tdammers> then you can write: let Pair a b = Pair f g
01:34:44 <tdammers> and that means: match the expression "Pair f g" against the pattern "Pair a b", binding the variables "a" and "b" to whatever they match to in the matched expression
01:35:33 <Orbstheorem> I'm reading though “Programming in Haskell - Hutton” to formalize my so-far empiric haskell knowledge, thanks for the explaination !
01:36:00 <dminuoso> Orbstheorem: In the end pattern matching `(a, b) = (some expr, another expr)` would be using pattern matching to arrive at a similar goal to a language that might support some theoretical syntax construct `a, b = some expr, another expr`. But that's just "abusing" pattern matching for some visual pleasentry.
01:36:44 <tdammers> I wouldn't call it abuse
01:36:57 <tdammers> destructuring complex values is a legit use case for pattern matching
01:49:15 <gentauro> "My coworker: «Haskell developers are like cockroaches. You think there are none where you live. But then you find one and soon it turns out there are many more»." -- Jasper Van der Jeugt
01:49:29 <gentauro> xD xD xD
01:58:28 <gentauro> on a serious note. A few days ago, I asked for "something" that could clear a *nix terminal screen. I was suggested to use `clearScreen` from `terminfo` (a packaged which I recalled that I already used). What I noticed, is that `clearScreen` just "wraps" `clear`/`cls` in the sence that is just pushes data up. I then looked into `clearBOL` (clear the current line until position of the cursor, but I don't 
01:58:34 <gentauro> seem to get it to work). Has anybody has any (successfull) experience by using `clearBOL`? More info: https://hackage.haskell.org/package/terminfo-0.4.1.4/docs/System-Console-Terminfo-Edit.html#v:clearBOL
01:59:06 <gentauro> has = had
02:00:56 <gentauro> I mean it should be possible right? (`CTRL-u` in a *nix terminal clears the current line, so if `terminfo` just wraps ...)
02:01:47 * hackage doctest-driver-gen 0.3.0.1 - Generate driver file for doctest's cabal integration  https://hackage.haskell.org/package/doctest-driver-gen-0.3.0.1 (Hexirp)
02:17:09 <gentauro> oh, I see what I was doing wrong :-) `getLine` is triggered with `enter` and that moves the cursor to the next line ... (doh)
02:17:43 <merijn> gentauro: Are you trying to do line-editing?
02:22:06 <gentauro> merijn: yeah
02:22:21 <merijn> gentauro: Just use Haskelline? :)
02:23:04 <merijn> @hackage haskeline
02:23:05 <lambdabot> http://hackage.haskell.org/package/haskeline
02:23:47 <merijn> gentauro: I used it a while ago and it was fairly simple to hack together an interactive line prompt (with autocompletion!) without too much effort
02:23:54 <gentauro> merijn: xD
02:24:12 <merijn> A bit of work to make it's error handling typeclass work with MonadUnliftIO, but other than that A++ would use again
02:24:47 <dminuoso> merijn: What exact work did that entail?
02:25:04 <gentauro> merijn: now that's a nice feature :o -> http://hackage.haskell.org/package/haskeline-0.7.5.0/docs/System-Console-Haskeline.html#v:getPassword
02:25:09 <merijn> dminuoso: Writing my own instance and newtyping
02:26:12 <merijn> dminuoso: Figuring out how to implement the instance was a major PITA, but with Cale's help I figured it out
02:26:23 <merijn> dminuoso: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/Core.hs#L103-L107
02:26:51 <merijn> dminuoso: There's is a ticket about maybe adding MonadUnliftIO instance to Haskeline, but because it's a boot library (ghci uses it), new dependencies are tricky
02:27:25 <merijn> dminuoso: But all it needs is a MonadException instance, which can be trivially defined for a newtype of anything that is MonadUnliftIO
02:29:45 <merijn> Honestly, it's pretty amazing, I made an SQL query based auto completer in like a handful of lines
02:32:08 <Jetien> hey, i'm looking for a transformer stack that has 1)failures and 2)state. When you run it and there is a failure you get boht: 1) the failure message 2) the value of the state at the time of failure. how to do that?
02:39:05 <merijn> Jetien: I'd probably just newtype a stack of 1 and 2 and implement a custom instance to do that?
02:45:28 <dminuoso> merijn: Ill have to ponder about that MonadException class.
02:46:38 <dminuoso> merijn: Though it seems as if `IO` is considered to be the raw "exception layer"
02:46:46 <dminuoso> Then it kind of makes sense.
02:47:31 <dminuoso> considering: controlIO :: (MonadIO m, MonadException m) => (RunIO m -> IO (m a)) -> m a
02:47:40 <merijn> dminuoso: MonadException is really just MonadUnliftIO but different
02:47:58 <merijn> dminuoso: And/or MonadCatch/MonadBracket
03:05:35 <fr33domlover> When I `stack build` I get colors in the text, but with long errors I want to be able to scroll up to the first error so I do `stack build |& less` but then I lose the colors, is there a way to still see colorful output?
03:06:37 <fr33domlover> (I tried less -R, doesn't work, I guess stack detects it's not printing directly to terminal so it doesn't send color codes?)
03:09:08 <fr33domlover> Jetien, you have ExceptT and StateT, use them together?
03:12:41 <fr33domlover> Yay `stack build --color always` works, it can be piped to `less` and there are colors
03:29:20 <Jetien> fr33domlover: i'm not sure if i have access to the state value at failure if i just use them together. If I use ExcepT on the bottom of the stack then StateT won't be able to pass s in (s -> m (a, s)) because m will be be (Left e) value, i think
03:32:19 <fr33domlover> Jetien, you can make 's' part of the failure type, and wrap throwE with a function that extracts the state with 'get' and passes it to throwE along with the actual error. Idk if that's the prettiest way but give it a try and see :)
03:33:34 <Jetien> fr33domlover: thanks. i'll give it a try
03:33:58 <fr33domlover> Jetien, or put ExceptT on top? In my code 99% of the time ExceptT is at the top, idk if that's good/common, just somewhow happens that way :p
03:35:05 <Jetien> fr33domlover: i don't have gut feeling yet on what is "right" when it comes to transformer stacks
03:41:39 <fr33domlover> Jetien, you'll get intuitions with experience :) If your whole computation has state, I'd say put StateT at the bottom. But if StateT is just for a small part, and ExceptT is for a bigger part of the computation, put StateT at the top. Also, side note, if you get an exception thrown (actual exception, not the ExceptT one), then you'll lose the state that StateT holds. If that becomes a problem, you can
03:41:41 <fr33domlover> replace StateT with a ReaderT holding a reference (such as an IORef, MVar, TVar, etc.)
03:43:05 <Jetien> fr33domlover: thanks. luckily i don't have to worry about exceptions in my case
04:30:50 <coldpress_> anyone knows of good resources on working with GADTs in template haskell?
04:31:25 <merijn> coldpress_: "Don't." <- there you go ;)
04:31:50 <merijn> coldpress_: More realistically, there's not many great resources for TH in the first place, let alone how it interacts with things like GADTs
04:34:02 <hpc> TH is becoming increasingly niche when you can use Typeable and such instead, too
04:36:56 <kritzefitz> coldpress_, is there some specific problem you have with GADTs? As far as I can see from the haddock, GADTs are just another kind of constructor.
04:39:50 <dminuoso> kritzefitz: One with type equality proofs hidden inside..
04:44:17 * hackage dumb-cas 0.2.0.0 - A computer “algebra” system that knows nothing about algebra, at the core.  https://hackage.haskell.org/package/dumb-cas-0.2.0.0 (leftaroundabout)
04:44:36 <kritzefitz> Ah, I guess I don't really know enough about the subject, to comment.
04:45:39 <Rembane> coldpress_: Do you have an example of what fails and how?
04:49:06 <reygoch> Shouldn't cabal new commands be able to build any package regardless of what previous packages have been built independently?
04:49:53 <dminuoso> reygoch: Yes.
04:50:12 <reygoch> I've tried to run "cabal new-install Chart-1.9 --lib" but I'm getting conflicts with packages
04:50:31 <dminuoso> reygoch: Can you gist/pastie the full error messages as well as your .cabal file?
04:51:10 <reygoch> dminuoso: sure, although I don't have a project, I'm just trying to build the library from the hackage on its own
04:52:24 <reygoch> dminuoso: Here is the command I've ran and the errors I get, https://pastebin.com/AquL1Kqg
04:55:10 <reygoch> dminuoso: this behaviour reminds me of the old cabal install command, although I'm not sure if I'm doing something wrong
04:56:23 <AfC> reygoch: fwiw I just quickly tried building it against the `lts-13.7` snapshot from Stackage, and it built [though I have allow-newer set to true, obviously, so it got around the lens-4.17 being current but Chart requiring < 4.17 problem]
04:56:25 <coldpress_> kritzefitz: besides type equality, I believe GADTs have return types, and that too needs to be handled in TH
04:57:23 <reygoch> dminuoso: I'm trying to setup nice cabal only environment to see how it'll work.
04:57:26 <bwe> Hi, I need a function: f ["e", h"] ["a", "b", "e", "h", "z"] -- expected output: (["e", "h"], ["a", "b", "z"])
04:58:18 <coldpress_> Rembane: specific problem is, partial-isomorphisms fails to handle GADTs, because it is not yet defined for GADTs.
04:58:35 <bwe> isInfixOf from Data.List tells me when sublist is contained in the second list. Is there any library function I can use?
04:58:43 <hpc> > let f ["e", h"] ["a", "b", "e", "h", "z"] = (["e", "h"], ["a", "b", "z"]) in f ["e", h"] ["a", "b", "e", "h", "z"] -- bwe :P
04:58:46 <dminuoso> bwe: `elem` ?
04:58:46 <lambdabot>  <hint>:1:125: error:
04:58:46 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
04:58:52 <coldpress_> Rembane: However, it is defined for normal constructors. I'm looking to extend the existing implementation of partial-isomorphisms to handle GADTs
04:59:13 <hpc> aw, what was wrong with that!
04:59:28 <dminuoso> % let r = ["e", h"] in filter (`notElem` r) ["a", "b", "e", "h", "z"]
04:59:28 <yahb> dminuoso: ; <interactive>:4:68: error: lexical error in string/character literal at end of input
04:59:35 <dminuoso> % let r = ["e", "h"] in filter (`notElem` r) ["a", "b", "e", "h", "z"]
04:59:35 <yahb> dminuoso: ["a","b","z"]
05:00:00 <dminuoso> bwe: Is this what you need?
05:01:48 <bwe> dminuoso: No, I need it in a sliding window, meaning sublist searched for of any length.
05:02:35 <dminuoso> bwe: partition instead of filter then
05:02:47 <dminuoso> % let r = ["e", "h"] in partition (`notElem` r) ["a", "b", "e", "h", "z"]
05:02:47 <yahb> dminuoso: (["a","b","z"],["e","h"])
05:02:55 <dminuoso> % let r = ["e", "h"] in partition (`notElem` r) ["a", "e", "b", "e", "h", "z"]
05:02:55 <yahb> dminuoso: (["a","b","z"],["e","e","h"])
05:03:24 <hpc> bwe: perhaps you could describe the original problem in more detail?
05:09:14 <Henson> is it possible to include a typeclass constraint in a record-syntax data declaration, like data Foo = Foo { bar :: (Eq a) => [a], baz :: Int }
05:10:01 <hpc> not like that, and the ways it is possible you usually don't want to do
05:10:17 <Henson> hpc: hmm, ok
05:10:24 <hpc> the way you're most likely to want is GADTs
05:10:34 <hpc> but usually just putting a class constraint on the operations on Foo is enough
05:10:45 <hpc> even stuff like Set from base doesn't have an Ord constraint
05:11:37 <Henson> hpc: what do you mean when you say "class constraint on the operations on Foo"?
05:12:08 <hpc> so you don't have data Set a = Ord a => blahblah
05:12:22 <hpc> you have fromList :: Ord a => [a] -> Set a, that kind of thing
05:12:36 <dminuoso> Henson: Yes
05:12:48 <dminuoso> hpc: You just need to add RankNTypes and add an explicit forall a
05:12:53 <dminuoso> % :set -XRankNTypes
05:12:53 <yahb> dminuoso: 
05:12:58 <dminuoso> % data Foo = Foo { bar :: forall a. (Eq a) => [a], baz :: Int }
05:12:59 <yahb> dminuoso: 
05:15:52 <hpc> so if you do it that way with higher-ranked types, you can do Foo {bar = "abc"} and Foo {bar = [1,2,3]} and they'll both be :: Foo
05:16:06 <hpc> but then when you go to consume a value of type Foo, you won't be able to distinguish between them
05:16:16 <hpc> all you'll be able to observe is the list has three elements and none of them are equal
05:18:39 <dminuoso> hpc: You can do more than that.
05:19:04 <hpc> like what?
05:19:07 <dminuoso> hpc: Because a polymorphic value is stored inside, you can monomorphize it.
05:19:18 <dminuoso> bar (someFoo) @Int
05:19:20 <dminuoso> bar (someFoo) :: [Int]
05:19:42 <dminuoso> (Constructing such a value would be challenging)
05:19:47 <hpc> eeeeeeh?
05:19:57 <dminuoso> Am I off my meds here?
05:20:03 <hpc> oh, maybe you're right
05:20:06 <dminuoso> % :t bar
05:20:06 <yahb> dminuoso: Eq a => Foo -> [a]
05:20:09 <dminuoso> ^- there
05:20:29 <hpc> i might be mixing higher-ranked data types with higher-ranked functions
05:20:33 <dminuoso> hpc: I think you were thinking of ExistentialQuantification.
05:20:41 <hpc> yeah, probably
05:20:44 <hpc> that
05:20:54 <dminuoso> Where you would have: data Foo = forall a. Foo { bar :: Eq a => [a], :: baz :: Int }
05:20:59 <dminuoso> data Foo = forall a. Foo { bar :: Eq a => [a], baz :: Int }
05:21:46 <dminuoso> hpc: In all fairness, since Henson did not put any forall quantification it's not clear which one he wanted.
05:22:16 <hpc> that and i have never had a problem that was solved by code with "forall" in it
05:22:51 <dminuoso> hpc: ST is a prominent example
05:23:22 <dminuoso> Without the forall quantification it would be quite unsafe.
05:23:27 <tdammers> hpc: ScopedTypeVariables nonwithstanding, I hope?
05:24:05 <dminuoso> % :set -XExistentialQuantification
05:24:05 <yahb> dminuoso: 
05:24:17 <dminuoso> % data Foo = forall a. Eq a => Foo { bar :: [a], baz :: Int }
05:24:17 <yahb> dminuoso: 
05:25:19 <dminuoso> lenses is packed with higher ranked types too
05:32:43 <Rembane> coldpress_: That sounds interesting. Sadly it's way above my paygrade ... I was hoping that someone else would take the bait. :)
05:33:47 <coldpress> Rembane: well, glguy took my "bait" by introducing th-abstraction
05:34:12 <coldpress> but so far I'm just matching types, without actually understanding how GADTs are represented
05:50:15 <lyxia> coldpress: do you have examples of isomorphisms you'd like to be able to generate
05:55:08 <coldpress> lyxia: https://bpaste.net/show/1d8f005b10c2
05:55:27 <Henson> sorry for disappearing and not advancing the conversation that was going on in response to my question.
05:57:33 <Henson> the thing I'm trying to do is this.  I'm working on a Haskell library that wraps some OpenCV and machine-vision camera C libraries.  I've got one class like this "class CameraImage img where getCameraImageCvMat :: (ColourSpace cs, PixelDepth d) => img -> CvMat cs d"
05:59:55 <Henson> now I'm trying to write a datatype "data SpecificVendorImage = SpecificVendorImage {vendorImageCvMat :: (ColourSpace cs, PixelDepth d) => CvMat cs d} where in order to make SpecificVendorImage an instance of CameraImage all I need to write is "instance CameraImage SpecificVendorImage where getCameraImage = vendorImageCvMat"
06:00:45 <Henson> I could be going totally off in the wrong direction with this, so please feel free to suggest a better way of trying to do achieve my goal.
06:01:31 <Henson> By SpecificVendor I mean something like Sony or FLIR, where I could write specific vendor interfaces that wrap around different C libraries, and make them all instances of CameraImage so I can use different camera vendors with the same code.
06:02:55 <merijn> Henson: That type looks existential, which I would recommenda gainst
06:03:02 <merijn> @where existential-antipattern
06:03:02 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
06:03:22 <fendor> Is there a platform independent way to get the location of an executabke? E.g. a `which` command or `whereis`?
06:03:40 <merijn> fendor: Depends how you define platform independent
06:03:45 <merijn> fendor: What are you trying to do?
06:04:27 <fendor> merijn, I want the location of a ghc I found on the path. E.g. I wanna know whether there is a ghc with version 8.4.4 on the path and if yes, where is it 
06:05:30 <merijn> type will tell you that in bash (maybe shell too), but that doesn't mean it's platform independent, as I have no clue about windows
06:05:31 <fendor> this should be used to configure cabal new-configure -w $(whereis ghc). Maybe the way I am trying to take is overly complicated
06:06:13 <merijn> fendor: Presumably you already know where the GHC you want to use is installed, no?
06:07:06 <fendor> merijn, no, i dont think so, I know where it is installed on my machine, but not on others, right?
06:07:25 <merijn> fendor: Sure, but why do you need to know that?
06:07:37 <merijn> i.e. what are you trying to accomplish?
06:08:14 <fendor> I am trying to use shake to build a project with multiple ghc's. 
06:08:28 <fendor> *use shake which invokes cabal new-build
06:10:37 <fendor> this should work on more machines than just my own
06:14:22 <fendor> there is a shelly implementation
06:17:19 <fendor> I could easily implement it myself, for every path in the $PATH, I append the executable and check whether the path exists.
06:18:17 * hackage spectral-clustering 0.3.0.1 - Library for spectral clustering.  https://hackage.haskell.org/package/spectral-clustering-0.3.0.1 (GregorySchwartz)
06:29:19 <lyxia> coldpress: as long as no existential types are involved, it seems pretty straightforward
06:30:05 <coldpress> lyxia: ah actually...
06:32:24 * lyxia feels goosebumps.
06:32:36 <coldpress> https://bpaste.net/show/51fbc8b0584d
06:34:12 <lyxia> that still seems workable for Expr, doesn't it?
06:34:44 <coldpress> lyxia: the existential argument doesn't give problems with TH?
06:35:08 <lyxia> No because the declaration of Expr doesn't care how AnyExpr is defined.
06:38:26 <coldpress> great!
06:42:02 <coldpress> I'm sure it's simple, and I've read through TH tutorials, but I just don't know where to start on TH with GADTs
06:44:25 <lyxia> isn't there some TH already in partial-isomorphisms, you could try understanding that
06:52:08 <coldpress> Right, it's just extracting the reified parameters. Are there any gotchas with GADTs though?
06:56:47 * hackage haiji 0.2.1.2 - A typed template engine, subset of jinja2  https://hackage.haskell.org/package/haiji-0.2.1.2 (NoriyukiOhkawa)
06:56:57 <lyxia> not that I recall.
08:15:45 <gaze__> hey what's the favorite way these days to make a decorated AST?
08:15:58 <gaze__> I noticed there's that trees that grow paper. Seems complex but cool
08:16:08 <gaze__> futhark seems to use something similar
08:23:11 <dario_> test
08:23:30 <dario_> Hi, I have problem with installing xmonad with cabal. 
08:24:20 <dario_> some 
08:26:14 <Ariakenom> Athas: do you have some trigger for futhark? :p
08:52:39 <lyxia> gaze__: comp-data (i.e., Data Types à la Carte) still seems commonly used
08:54:00 <Athas> Ariakenom: what do you mean?
08:54:46 * hackage yesod-auth 1.6.6 - Authentication for Yesod.  https://hackage.haskell.org/package/yesod-auth-1.6.6 (MichaelSnoyman)
08:54:57 <Ariakenom> Athas: so you'd get a notification when gaze__ mentioned futhark
08:55:27 <Athas> Ariakenom: oh, yeah, my ERC highlights it.
08:57:01 <Ariakenom> great :)
09:27:12 <sgraf> I have a cabal project that I have generated a project.nix file with cabal2nix for. I also have a default.nix that calls that package. How can I open a nix-shell in a way that I have a really fast compile feedback loop? Essentially I want nix-build without all the Setup rebuilding and stuff that already succeeded
09:27:14 <Mrbuck> #Haskell-offtopic: Cannot join channel (+b) - you are banned  looks like monochrom  got some ego shit problems  go and treat yourself in mental hospital idiot
09:28:11 <Mrbuck> I hand at #haskell and offtopic thinking most friendly people and he banned me for no reason
09:29:12 <comstar> idk going into the topic channel and saying a bunch of off topic trash talk doesn't feel like it'd help your case
09:30:52 <Mrbuck> Welkin:  you should learn what is spam and what is  discussion...with out discusion you learn nothing, if you dont like some langauge just keep quit, if we cant discuss about other programming languages in offtoic then what is offtopic for ? 
09:31:56 <Solonarv> going into #haskell and insulting the moderator who banned you from #haskell-offtopic really doesn't seem like a great idea to me
09:32:47 <Mrbuck> Solonarv: I want to tell him he was a idiot maximum he will ban me here again but that doesnt make him no idiot  because he dinet accepted somebody arguments 
09:33:02 <Mrbuck> or respected my opinion when i was talking
09:33:42 <comstar> Mrbuck you're really derailing the channel but you're kinda trying to shift the discussion away from stuff you did, like your eariler quit message saying "fuck you rude guys fuckk haskell will never come here".  Like that's pretty uncalled for.  Also you're here calling people idiots and being a nuisance
09:34:13 <Mrbuck> Yeah I will never ever come again after he bane me here too
09:34:47 <comstar> why not just, go take a break, relax.
09:38:29 <monochrom> Mrbuck trolled with "c++ is as equally enjoyable as haskell who agree with me ?" that's why the ban.
09:40:52 <monochrom> Bannees are going to cry "freedom of speech" or "respect my opinion" all those high-horse things.  Don't fall for it.  They just want freedom to abuse.
09:42:02 <comstar> nah I think that's pretty obvious since he made no attempt to recognize his own bad-faith activity even here
09:42:31 <monochrom> OK!
09:46:10 <__monty__> monochrom: The reaction to the ban is pretty terrible but imo the ban was an overreaction too. A single trollish comment shouldn't get you banned in -offtopic.
09:46:30 <wroathe> It was a good troll though. Gotta hand it to him. The quickest way to get shunned by Haskellers seems to be stating that C++ is a superior language.
09:47:04 <glguy> No this channel has become off-topic. Chatting about moderation is just fine, but the best channel for it is #haskell-ops
09:47:07 <glguy> now this*
09:47:24 <comstar> __monty__: if he had good intentions he could've privmsg'd monochrom or attempted to resolve it reasonably instead of putting on a performance and derailing the main topic channel
09:49:45 <__monty__> comstar: Yes, I said their reaction was terrible. That doesn't excuse the frivolous ban. I'm in -offtopic and -blah if you want to talk about it further.
09:50:27 <monochrom> __monty__, it was the last straw.  I guess I should have added that last time.
09:56:10 <dminuoso> tdammers: It occured to me that wanting to write `f,g = x,y` is not so unnatural.
09:56:35 <dminuoso> tdammers: There's this rarely used syntax in Haskell: f , g :: SomeType
09:57:28 <Welkin> dminuoso: that is common in lua and python (multiple assignment)
09:57:40 <Solonarv> I wonder if a top-level [f, g] = [foo, bar] would get optimized properly. Hmm...
09:58:08 <Welkin> use an uboxxed tuple?
09:59:54 <monochrom> Yes [x,y]=[True,False] becomes "x=True; y=False" after -O
10:00:30 <monochrom> Actually still true without -O
10:01:15 <Solonarv> -O1 is default IIRC?
10:01:19 <Solonarv> and yea, I saw the same thng
10:01:19 <monochrom> No
10:02:08 <monochrom> cabal defaults to -O1. ghc doesn't.
10:02:19 <reygoch> Cabal is killing me today. I've tried installing ghcid simply by running "cabal new-install ghcid" in my users directory and I get some dependency mess. It's telling me that there is some collision with "Chart" dependencies which is something I've been building in a self contained project and has no access to my homedirectory, so I'm not sure where he's getting these constraints from. Here is the pastebin: https://pastebin.com/VeDira4u
10:02:27 <Solonarv> oh! that makes sense
10:02:30 <Welkin> however one of the main usecases for multiple assigment is to swap two values without creating a tmp
10:03:13 <Solonarv> '(x, y) <- pure (y, x)' in a do-block; the concept of swapping variables doesn't make much sense in any other context
10:03:48 <reygoch> It seems like cabal is stuck on my old project from earlier for some reason and I can't figure out how to fix it.
10:03:51 <Welkin> well in haskell you annot rebind anyway, so it makes less sense
10:04:12 <dminuoso> rebind :: (Alpha p1, Alpha p2) => p1 -> p2 -> Rebind p1 p2
10:04:14 <dminuoso> It seems I can!
10:04:34 <Solonarv> well, you can rebind - in a do block! (probably in arrow notation too, come to think of it)
10:04:53 <Welkin> that isn't rebinding, it's a different scope
10:05:09 <Solonarv> True. It looks a lot like rebinding, though!
10:06:10 <dminuoso> Well rebinding seems to not make much sense if you have a "temporal scope" in mind
10:06:21 <dminuoso> (Still trying to wrap my head around the tardis monad)
10:06:24 <sclv> reygoch: three possibilities. first check of there's a ghc-environment file  around
10:06:43 <sclv> perhaps if you ran a new-install on Chart at some point it might be in the global env file?
10:07:07 <sclv> second, check if there's a cabal.project or a .cabal file lying around in your current directory
10:07:27 <sclv> you can also run with verbose to see if it gives a hint why there's a user goal for Chart
10:07:29 <reygoch> sclv: I have ran new-install on chart, but shouldn't new commands be able to build stuff regardless of what I've installed before?
10:07:37 <sclv> no
10:07:40 <sclv> not exactly
10:07:51 <sclv> new-install on a _package_ puts it in your global, env file
10:07:56 <sclv> which you probably don't want
10:08:00 <sclv> but its easy enough to fix
10:08:08 <monochrom> I think s/package/library/
10:08:32 <sclv> https://downloads.haskell.org/~ghc/master/users-guide/packages.html#package-environments
10:08:37 <sclv> yeah, on a library i mean
10:09:12 <sclv> the point is to _install_ it rather than build a package depending on it, that means you're still making it globally available
10:09:17 <sclv> but now you can just delete the entry from that env file
10:09:22 <sclv> rather than muck with your packagedb
10:09:26 <reygoch> sclv: hm... I was expecting a different behaviour, this is very much like old cabal
10:09:39 <sclv> well with new-build you don't see it
10:09:44 <reygoch> sclv: but yea, I guess it's easyer to fix it
10:09:47 <sclv> the question is "what, if anything, should new-install on a library do"
10:10:07 <sclv> and the answer people came up with was, install it into the Store, but also alter the package-env to point to it
10:10:07 <monochrom> new-install is best reserved for exes.
10:10:09 <reygoch> sclv: I was using it to see if it'll build on my current msys2 setup
10:10:31 <Welkin> use `cabal new-build`
10:10:32 <sclv> i don't think its particularly useful, but i don't know what else one would want/hope new-install on a lib to do?
10:10:56 <reygoch> just build it, not add some constraint to any consequtive build
10:11:05 <sclv> but where can you access it from then? nowhere?
10:11:06 <reygoch> that's what I expected
10:11:21 <reygoch> don't care, just want to build it and download it from hackage
10:11:32 <sclv> tbh -- i think there's a bit of weird behavior in that consecutive new-installs should arguably not step on one another
10:11:35 <reygoch> and cache it
10:11:59 <sclv> the point is people are expected to want to new-install libs to make them available for global interactive use in ghci
10:12:13 <sclv> but i think new-installing an exe probably shouldn't make ref to the global env file?
10:12:45 <monochrom> Yeah I am surprised too.
10:12:45 <reygoch> I was using just cabal install for global environment
10:13:37 <sclv> lol i just went to create a ticket for this and apparently there's a current active discussion already: https://github.com/haskell/cabal/issues/5888
10:13:53 <reygoch> hehe :D, I also intended to complain later
10:19:56 <reygoch> sclv: wait, where exactly is this global environment defined? I thought it's in user config file or something.
10:20:30 <Welkin> ~/.cabal I think
10:22:23 <reygoch> ok, nvm. found it
10:22:35 <reygoch> on windows it's in %USER%/.ghc
10:23:48 <Welkin> if you are ever looking for something, it's probably in ~/.ghc or ~/.cabal
10:25:40 <reygoch> or ~/.ghc and ~/AppData/Roaming/cabal if you are on windows ;)
10:44:30 <wroathe> DefaultSignatures is cool
10:44:50 <wroathe>  /deep thoughts
10:45:11 <Solonarv> I agree
10:57:06 <wroathe> phadej: I noticed your name on some of the Aeson github discussion and a pull request or two. Are you pretty active with Aeson?
10:57:23 <wroathe> whoops, that was meant to be a whisper
10:57:28 <phadej> no worries
10:57:53 <phadej> https://github.com/bos/aeson/graphs/contributors
11:02:44 <janat08> class Monad m => MonadIO (m :: Type -> Type). :: is used to indicate what type something should be and in this case a function. monad is a function then. this function is in MonadIO?
11:04:25 <Solonarv> janat08: :: is also used to indicate a type variable's kind
11:04:36 <monochrom> No, this one is a kind signature, m is a type, m's kind is Type->Type.
11:05:05 <comstar> oh hey netsplit
11:11:47 <_lerk_> how the fuck do we end up with 1429 people on chan?
11:12:11 <_lerk_> oh, nm, wrong channel :D
11:12:20 <dmj`> _lerk_: it's the most heavily trafficked channel on freenode
11:12:29 <dmj`> _lerk_: you have the right channel, there's 1429 people here
11:12:52 <monochrom> Hrm trafficking!
11:13:05 <_lerk_> dmj`: yeah, but my surprise was wasn't at 1429 people in #haskell, it was 1429 as related to a different channel :D
11:14:25 <Athas> It's always kind of mind-boggling to me why/how the Haskell community is so large.
11:14:32 <Athas> Or maybe it's just centret on legacy platforms.
11:14:58 <_lerk_> good ideas persist, sometimes in the large
11:19:10 <monochrom> I'll paint a bleak picture for you.  Most Java programmers (for example) are not on IRC because they actually use it in a day job.
11:19:46 <monochrom> Or at least consider the correlation!
11:19:53 <_lerk_> most java programmers cut and paste bugs from one application to another
11:20:04 <Welkin> people use haskell for fun because they like it, not because they are forced to use it
11:20:07 <Rembane> I do that too! 
11:20:20 <Rembane> Or maybe I cut and paste applications from one bug to another.
11:20:25 <Rembane> Hm... more research needed.
11:20:26 <_lerk_> hahahaa
11:20:29 <monochrom> That doesn't matter.  The point is: 1. do they have time for IRC?  2. when they do, do they still want to talk about Java?
11:21:10 <Welkin> haskell programmers tend to be the kind of person who would use irc
11:21:27 <Welkin> other languages have a larger presence on slack/whatever
11:21:27 <monochrom> Likewise if someone comes to IRC and asks "I have some accounting questions, where are the accountants on IRC?" I'm going to answer "consider the fact that they actually have a life".
11:21:49 <_lerk_> we may have to disagree on your fundamental postulate
11:23:00 <Rembane> Do people do accounting for others for free?
11:23:47 <__monty__> Rembane: I do, just send me your money so I can account for it : >
11:24:31 <monochrom> I am merely using sheer economics.  And my explanation even covers dons and manatee and chrisdone and dolio and myself.  Ask yourself what happened to dons right after he was hired by Standard Chartered.
11:24:53 <monochrom> Hell in fact even me I am here now just because university is shut down by snow storm.
11:25:41 <Rembane> __monty__: Awesome! Send me postcards if you and my money ever travel somewhere beautiful! 
11:25:52 <monochrom> dons certainly no longer writes code for free.
11:26:09 <Rembane> monochrom: Don't you usually hang out here? 
11:26:34 <monochrom> My bouncer usually hangs out here.  I don't connect when I have classes or preparing or ...
11:27:10 <monochrom> I was like very active in my unemployed days several years ago, sure.
11:27:14 <monochrom> QED
11:27:18 <Welkin> monochrom: how did you meet your bouncer?
11:27:34 <Rembane> Good point. 
11:27:53 <monochrom> I Googled for "IRC bouncer" and also took a look at ubuntu's package listing.  Eventually I chose znc.
11:28:17 <Welkin> is your bouncer large and bald?
11:28:32 <monochrom> Type error.
11:28:38 <comstar> znc is pretty great, really beat the pants off psybnc since that's what was popular before it
11:28:57 <comstar> what are the other #haskell channels?
11:29:12 <Welkin> #lleksah maybe
11:29:17 <Welkin> mirror world haskell
11:29:44 <__monty__> Wait, there's an inverse correlation between talking here and having a haskell job?
11:29:47 <__monty__>  /part
11:30:07 <Welkin> except edwardk
11:30:15 <monochrom> There is a #haskell-beginners.  There are also #haskell.es (or is it #haskell-es?) etc i.e., based on human languages.
11:30:24 <Welkin> he writes haskell for money, and for open source (free) and talks here
11:30:26 <comstar> ah!
11:30:28 <Welkin> and live streams haskell
11:30:53 <Solonarv> comstar: I'm in #haskell, #haskell-beginners, #haskell-offtopic, #haskell-blah, #haskell-in-depth
11:31:00 <__monty__> He's being paid for the evangelism though : )
11:31:02 <Solonarv> in roughly descending order of activity
11:31:11 <Welkin> but yeah, for most people programming is just a way to make money, and have a typical job is exhausting
11:31:32 <comstar> yeah I burned out editing bourne shell scripts 
11:31:37 <comstar> for a devops job
11:31:45 <Welkin> when I wrote javascript all day for money I didn't want to do any programming, regardless of language, when I got home
11:31:45 <monochrom> Yeah a programming job is pretty exhausting.
11:31:47 <comstar> editing/writing
11:32:10 <monochrom> Hey comstar I heard that now they're upgrading you people to devsecops!
11:32:41 <Welkin> fullstackdevsecopsaccountantanalystsjanitors?
11:33:07 <comstar> I just was tired of fixing other people's problems and then constantly having the stress of working alone
11:33:28 <NemesisD> can anyone see why this nix expression would fail to disable profiling? when i load the shell i see deps compiling .p_o files: https://gist.github.com/MichaelXavier/bb404b3f2d4be10157ad481e36ae5c3b
11:33:28 <Welkin> did they also make you clean up when a coworker pooed on the floor?
11:33:32 <comstar> like at standup I'd regularly talk about stuff where other people there could help me, but should not because it wouldve been a waste of resources
11:33:48 <comstar> Welkin: no
11:34:33 <HenryCH> hi, beginner here. do I understand correctly that once a function returns a monad type, that type will flow through any other functions that need to work with that inner value, because the value can't be unpacked?
11:34:51 <monochrom> Depends on the monad. Yes for some.
11:35:34 <HenryCH> so if something returns one of those monads, and then another function takes that, and needs to work with that value and return a different monad, do you not then end up with a function returning an m1 m2 m3 a?
11:35:58 <monochrom> Yes but I haven't needed to do that.
11:36:02 <marvin2> monad interface does not give you a way out, but specific type that implements monad typeclass can do what it wants
11:36:45 <Ariakenom> :t fmap
11:36:46 <Solonarv> you would indeed end up with 'm1 (m2 (m3 a))', which is about as inconvenient as you think it is - that's more or less what monad transformers were invented for
11:36:47 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:36:54 <Ariakenom> nest
11:36:58 <Ariakenom> :t join
11:37:00 <lambdabot> Monad m => m (m a) -> m a
11:37:01 <Ariakenom> unnest
11:37:19 <Welkin> needs more birds
11:37:40 <hyperisco> But do you have a monad in your monad?
11:37:48 <HenryCH> join is only for the same m though right?
11:37:55 <marvin2> yes
11:38:14 <monochrom> There are all pretty hypothetical.  I would practice and study actual code.
11:38:33 <Welkin> once you use >>= and pure in real code you will get it
11:38:46 <Welkin> don't worry about the theory behind it, it's not important
11:38:56 <HenryCH> Solonarv, so is this a common thing in most people's code? i dont know what transformers are but are they regularly used?
11:39:00 <Ariakenom> oh I missed the different part, sorry
11:39:00 <Welkin> it's just an interface
11:39:24 <Solonarv> quite commonly, yes (although I don't have numbers to back that up)
11:41:43 <HenryCH> IO you can't unpack right? i've heard people saying you want to push IO to the edges, but once you have an IO and you need to work with that inner value, how do you push that to the edge if the rest of your workflow has to work with the IO type?
11:42:32 <marcx> in haskell, no. ghc has an escape hatch, but it isn't something a beginner needs to know about (or something that a beginner can safely use)
11:42:35 <monochrom> LIke this: http://www.vex.net/~trebla/haskell/IO.xhtml#organization
11:42:41 <Welkin> IO is the top-level wrapper around everything else
11:42:47 <Welkin> main :: IO ()
11:42:57 <tdammers> HenryCH: if you have an IO, and you want to do something with the value, then it has to also result in an IO
11:43:28 <tdammers> HenryCH: so in that sense, yes, what comes after that IO action also has to work with IO
11:43:32 <Welkin> your program is a huge nested expression with many sub expressions which contain other expressions
11:43:52 <tdammers> HenryCH: but that doesn't mean you can't call into non-IO things from "inside" IO
11:45:02 <tdammers> HenryCH: it makes more sense if you think of IO a as just another type, one that happens to represent a stateful program, and IO's >>= implementation is just a plain old operator that you can use to combine an IO value with a function that evaluates to another IO value - iow., >>= allows you to combine stateful programs into bigger, more complex ones
11:45:25 <HenryCH> monochrom: thanks for the link
11:49:36 <HenryCH> i get that example, but in a bigger application, where you have several branches and you may or may not need any input, but if you do it's somewhere in the middle of a workflow, i still dont know how i would handle that
11:50:49 <monochrom> I would write and discuss actual code.
11:51:15 <isovector1> how important are the laws _really_? is it enough that `fmap id = id` up to observation? or does this really and truly need to be equality?
11:52:15 <Solonarv> "up to observation" should be enough in practice, methinks
11:52:16 <HenryCH> isovector1: i read somewhere the compiler optimizes on the assumption the laws hold, but no idea what happens if they don't :D
11:52:18 <monochrom> What is "real and true" equality? >:)
11:52:29 <Solonarv> ^ also a good question!
11:52:51 <isovector1> :)
11:53:08 <monochrom> A question everyone ignores when pointlessly arguing over referential transparency.
11:53:10 <isovector1> presumably "you get the same data in memory"
11:53:50 <kadoban> Same data in memory isn't very good equality. Then you have no way to hide implementation details.
11:54:03 <Solonarv> by that logic, []'s functor instance isn't valid!
11:54:25 <marcx> why not?
11:54:40 <isovector1> Solonarv: no? `fmap id [5]` and `id [5]` give back equal pieces of data in memory
11:54:48 <monochrom> But I agree with up-to-observation.
11:54:52 <Solonarv> % import GHC.Exts (reallyUnsafePtrEquality#)
11:54:53 <yahb> Solonarv: 
11:55:05 <isovector1> if it has unsafe in the name it probably doesn't count :)
11:55:16 <isovector1> but point taken
11:55:29 <Solonarv> % let ex = [1, 2, 3] in I# (reallyUnsafePtrEquality# (id ex) (fmap id ex))
11:55:29 <yahb> Solonarv: 0
11:55:36 <monochrom> For how implementational equality is broken, consider fmap id (repeat ()) 
11:56:14 <monochrom> repeat() takes O(1) space.  fmap id (repeat ()) is not going to be that smart.
11:56:16 <Solonarv> I mean, Haskell doesn't normally expose the in-memory representation of data structures, so of course we'd need unsafe* stuff
11:56:57 <isovector1> so at the end of the day, what we're saying is "my free monoid instance with a magic mempty value is fine so long as you can never see that thing"
11:57:01 <monochrom> Also, https://www.vex.net/~trebla/humour/tautologies.html #9
11:57:42 <Solonarv> "cannot write a total function that distinguishes them" seems like a reasonable strong notion of equality for practical use
11:58:10 <Solonarv> (forbidding unsafe* and non-exported symbols)
11:58:50 <Solonarv> by this notion fmap @[] id and id @[_] are indeed equal!
11:59:10 <isovector1> Solonarv: perfect, that's what i was hoping
12:00:05 <Solonarv> (what I said is just a slightly more rigorous definition of "up to opservation")
12:00:51 <Ariakenom> Solonarv: why total?
12:01:04 <[Leary]> It also risks circularity by relying on the notion of distinguishable while defining distinguishability.
12:01:13 <Welkin> the cereal?
12:01:33 <Welkin> are there irc channels about cereal?
12:01:38 <Solonarv> Ariakenom: I was being conservative, perhaps the "total" qualifier isn't necessary
12:02:28 <monochrom> Hey! I just defined "has a winning strategy" circularly!
12:03:57 <monochrom> I wrote in my assignment question "you have a winning strategy iff there exists your next move such that for all opponent's next-next moves you have a winning strategy".
12:04:31 <Solonarv> we can say that the "discriminating function" must return a value of an enumeration (i.e. an ADT with only nullary constructors), and use the obvious equality on the return value; totality makes sure we can use that obvious equality, but maybe it isn't needed
12:04:46 <opqdonut> monochrom: more like recursively though right?
12:04:58 <opqdonut> pretty good definition though
12:05:10 <kadoban> I'm not sure how you differentiate winning and losing in that definition
12:05:11 <monochrom> The beauty is that the game in the assignment is a finite game so yeah it's already well-founded recursion without writing out an explict base case!
12:05:47 <opqdonut> kadoban: losing is not having any moves available
12:05:57 <monochrom> Actually let me show you the whole thing: http://www.cs.utoronto.ca/~trebla/CSCC24-2019-Winter/A2/cscc24-324-a2.pdf
12:06:18 <kadoban> opqdonut: As long as you define that, sure.
12:06:35 <monochrom> This game has this nature: Every move removes choices for future moves for both sides.
12:07:04 <Welkin> what about chance?
12:07:14 <monochrom> So after a while you're looking at either "there exists x in the empty set s.t. ..." or "forall x in the empty set ..." so you're done.
12:08:30 <monochrom> No, in this case it is unnecessary to define "win" or "lose" first.
12:08:48 <monochrom> I did it anything because clearly most people are intuitive not logical.
12:08:54 <monochrom> s/anything/anyway/
12:09:14 <monochrom> If you don't have a next move, you don't have a winning strategy.
12:09:36 <monochrom> Because now "there exist ..." is vacuously false for you.
12:10:30 <kadoban> Oh, ya that part is pretty clever
12:10:47 <Solonarv> vacuous truth/falsity is fun ;)
12:10:55 <Solonarv> I have totalled every car I ever bought!
12:11:35 <monochrom> The next beauty is that you now just code up that sentence in Haskell and you're done too!
12:11:47 <HenryCH> thanks for the help everyone
12:12:35 <monochrom> The meta-beauty is that now that you've seen the assignment I gave out, if my students come here to ask you, you recognize it and say "hey that's someone's homework!"
12:13:09 <kadoban> Or we point them to the log and the solution to the problem xD (although I'm sure if that was enough for them to solve, they'd pass anyway)
12:13:24 <monochrom> (But I think "just code up that sentence in Haskell" is a good advice. I will give it to my students upon asking anyway)
12:13:40 <kadoban> Yeah it does seem like pretty good advice
12:13:55 <Welkin> ask them to write it in prolog
12:14:08 <Solonarv> being able to "just code up that sentence in Haskell" is one of the things I enjoy about it tbh
12:22:47 * hackage plur 0.2.0.0 - Plurality monad: Zero, one, or at least two.  https://hackage.haskell.org/package/plur-0.2.0.0 (joelb)
12:23:17 <monochrom> Haha that's some ancient tribe's number system.  Zero, one, many.
12:24:59 <tdammers> such a culture doesn't exist, and probably never did. Almost all known languages can count to at least four; AFAIK there is only one known natural language that can't, and that language doesn't have numerals at all
12:25:40 <monochrom> Perhaps that's the one, and "zero", "one" there somehow aren't considered numerals.
12:26:04 <monochrom> Afterall, Greek did not consider "zero", "one" to be numerals either. Numbers started from two.
12:26:32 <monochrom> You can see its relics in our languages.  "I have a number of wives" you never thought I meant 0.
12:26:34 <tdammers> no, it's not. the language in question is pirahã, and they don't have a concept of "number" or "quantity" at all, because they abhor abstract thought
12:27:15 <comstar> y'all applying for that interos job?  
12:27:25 <Solonarv> wait, but abhorring abstract thought *is* an abstract thought!
12:27:44 <tdammers> Solonarv: if you are aware of it, then yes. but they probably aren't.
12:27:45 <_lerk_> we have reached an existential crisis!
12:27:48 <comstar> jobs* https://twitter.com/functionaljobs
12:27:57 <Solonarv> ∃crisis
12:28:07 <comstar> 2 interos jobs involving haskell
12:28:41 <Solonarv> or in Haskell: we have reached a ∀r. (∀crisis. crisis -> r) -> r
12:28:46 <benzrf> i thought the pirahã stuff was shown to be bs or something
12:29:21 <phadej> Solonarv: minus points but not using unicode arrow
12:29:28 <phadej> for*
12:29:43 <Solonarv> whoops! ∀r. (∀crisis. crisis → r) → r
12:30:12 <phadej> better!
12:30:17 <tdammers> benzrf: it may very well be. wouldn't surprise me if the pirahã had just been fucking with the scientists to make them go away
12:30:30 <benzrf> i think the guy who originally publsihed about them had an agenda or sth
12:30:41 <benzrf> i cant remember tho
12:30:51 <benzrf> ack i should be doing work
12:30:53 <benzrf> bbl
12:33:30 <comstar> language is fake
12:33:45 <comstar> haskell is the only true language everything else is sequenced and therefore impure
12:34:30 <Solonarv> but haskell is turing-complete and therefore useless!
12:34:58 <Welkin> not language, semiotics!
12:35:40 * Solonarv accelerando flashbacks
12:44:09 <_lerk_> i quickly go into memory of all the Eco books i've read
12:44:35 <_lerk_> baudolino was just weird
12:45:01 <_lerk_> the island of the day before was even more weird
12:45:42 * shapr swings foucault's pendulum back towards Haskell
12:47:39 <_lerk_> what a great novel
13:00:52 <kuribas> I found an interesting use for the Free Monad
13:01:12 <Solonarv> oh?
13:01:23 <kuribas> If I define "data Tree t = Tree t t", then (Free Tree) becomes a real tree
13:01:27 <kuribas> (recursive)
13:02:06 <kuribas> you can then use recursion schemes to operate over the tree.
13:03:35 <Solonarv> I'm pretty sure that's an example often given in documentation about Free
13:03:40 <Solonarv> but yes, it's neat!
13:03:47 <kuribas> Solonarv: ah right :)
13:03:53 <kuribas> I must have missed those
13:08:01 <kuribas> Solonarv: like this? https://gist.github.com/kuribas/244c3d9958e645ea7f12ac9ea8eed010
13:09:01 <Solonarv> kuribas: yes, though I question your naming
13:09:13 <kuribas> Solonarv: name what?
13:09:16 <Solonarv> 'Tree' should probably be called 'TreeF' or 'Pair'
13:09:24 <kuribas> Right :)
13:09:29 <lyxia> that's probably size rather than height too
13:09:41 <kuribas> ah right, I need max
13:09:56 <lyxia> or const 0 if you see the bug
13:10:09 <Solonarv> it's not a proper size calculation either; for size you'd need T.Pure _ -> 1
13:12:17 * hackage datasets 0.4.0 - Classical data sets for statistics and machine learning  https://hackage.haskell.org/package/datasets-0.4.0 (ocramz)
13:12:25 <kuribas> lyxia: const 0?
13:13:05 <lyxia> If your leaves (Pure) are 0, and the nodes only add up their children, the result is 0.
13:13:19 <kuribas> lyxia: yeah
13:13:26 <kuribas> should be 1 of course
13:14:31 <kuribas> Solonarv: so Free turns a pair into a tree.  That's pretty neat.
13:15:20 <kuribas> I am looking at recursion-schemes, but very little makes sense to me. 
13:15:26 <kuribas> Where can I read about it?
13:16:02 <ququ> Hello! I am writing a function which outputs [String]. In it there are certain different inner functions called, all of which output a String. However, I need to use a Boolean function to control whether each of the functions actually adds a String to the output, or not. What's the correct way to do it in Haskell?
13:16:49 <kuribas> ququ: outputs a string or returns a string?
13:17:02 <zachk> ququ, maybe filter
13:17:07 <zachk> @type filter
13:17:09 <lambdabot> (a -> Bool) -> [a] -> [a]
13:18:07 <Solonarv> I think there was a series of posts on comonad.com/reader, but I can't seem to find it
13:25:35 <dmj`> you can't do a single ViewPattern over two parameters right
13:25:55 <dmj`> foo :: [a] -> [b] -> [(a,b)]; foo (zip -> xs) = xs
13:26:47 <lyxia> > let foo a (zip a -> xs) = xs
13:26:47 <Solonarv> you can't, but you can do:
13:26:49 <lambdabot>  <no location info>: error:
13:26:49 <lambdabot>      not an expression: ‘let foo a (zip a -> xs) = xs’
13:26:54 <Solonarv> ah, lyxia was faster
13:27:18 <ququ> Filter was what I was looking for, thanks!
13:27:29 <Solonarv> a view pattern can refer to any variables bound to its *left*, IIRC
13:28:11 <dmj`> uh
13:28:14 <dmj`> you actually can
13:28:16 <dyl> > let foo (zip -> xs) = xs
13:28:18 <lambdabot>  <no location info>: error:
13:28:18 <lambdabot>      not an expression: ‘let foo (zip -> xs) = xs’
13:28:18 <dmj`> I'm blown away
13:28:35 <dmj`> https://gist.github.com/27790f8ea7717fa312360d9d1c8b36b2
13:28:36 <dyl> lambdabot doesn't have the extension enabled it seems.
13:28:40 <kuribas> if Free makes a monad out of a functor, what does Fix make out of a functor?
13:28:48 <dmj`> ViewPatterns is so underrated
13:28:49 <dyl> kuribas a hot mess!
13:28:57 <Solonarv> kuribas: a recursive data type
13:29:29 <dyl> Initial algebra, no?
13:29:40 <dmj`> Solonarv: does that work for you? Maybe it's a ghc 8.6 thing
13:29:54 <Solonarv> dmj`: lambdabot's > wants an expression
13:29:59 <dyl> I'm pretty sure view patterns haven't changed in quite a while.
13:30:07 <Solonarv> lambdabot is not a ghci prompt
13:30:10 <dyl> @let foo (zip -> xs) = xs
13:30:11 <lambdabot>  Defined.
13:30:17 <dyl> > foo [1, 2, 3] [4, 5, 6]
13:30:19 <lambdabot>  [(1,4),(2,5),(3,6)]
13:30:23 <dyl> There you go.
13:30:33 <dmj`>  I never knew
13:30:35 <dmj`> so cool
13:30:36 <vaibhavsagar> dmj`: that's wild
13:30:42 <dmj`> vaibhavsagar: life changing right
13:30:42 <Welkin> that's just syntax sugar
13:30:52 <comstar> whaat
13:31:01 <dyl> Haskell is just syntactic sugar for GHC Core.
13:31:04 <dyl> Change my mind.
13:31:27 <kuribas> will using recursion schemes scare away newbies?
13:31:28 <Solonarv> basically true
13:31:31 <dmj`> someone should tweet about this ViewPatterns thing
13:31:36 <_lerk_> hahahaa
13:31:38 <Solonarv> kuribas: quite possibly
13:31:52 <Welkin> using anything outside of haskell 2010 will scare away anyone
13:31:52 <vaibhavsagar> dmj`: the code golfing opportunities are endless
13:32:00 <vaibhavsagar> dmj`: I would like+retweet your tweet about this
13:32:11 <Solonarv> it depends on the recursion schemes in question - after all, foldr is a recursion scheme too!
13:32:12 <kuribas> Welkin: so basically using haskell will scare people away then 
13:32:12 <comstar> > :t (->)
13:32:13 <Welkin> don't tweet
13:32:14 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
13:32:16 <Welkin> I deleted twitter
13:32:20 <Welkin> toot (on mastodon)
13:32:21 <dmj`> vaibhavsagar: I'm more of like a retweeter than a tweeter
13:32:25 <comstar> @t (->)
13:32:25 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
13:32:34 <dyl> dmj` what about...
13:32:35 <Welkin> kuribas: yes
13:32:39 <comstar> @type (->)
13:32:41 <lambdabot> error: parse error on input ‘->’
13:32:43 <dyl> @let bar x = (x, x)
13:32:44 <lambdabot>  Defined.
13:32:45 <kuribas> Solonarv: I defined a sort of foldr in clojure on a tree structure
13:32:46 <dmj`> dyl: blow my mind boy
13:32:53 <dyl> @let foo (bar -> x y) = x + y
13:32:53 <lambdabot>  Parse failed: Parse error in pattern: x
13:32:56 <Solonarv> comstar: (->) is not an operator at the value level
13:32:58 <dyl> @let foo (bar => x y) = x + y
13:32:58 <lambdabot>  Parse failed: Parse error: =>
13:32:59 <kuribas> Solonarv: a catamorphism
13:33:01 <dyl> Aw.
13:33:08 <comstar> Solonarv: type level operators
13:33:09 <dyl> No implicit tupling.
13:33:25 <dyl> @let np k n | k <= n = Just (n-k) | otherwise = Nothing
13:33:26 <lambdabot>  Defined.
13:33:39 <dyl> @let   fib (np 2 => n) = fib (n + 1) + fib n
13:33:39 <lambdabot>  Parse failed: Parse error: =>
13:33:45 <dspyz> I'm just trying to get a simple ghcjs hello world project set up. But nothing I try seems to work. Any good _getting-started_ resources?
13:33:47 <Solonarv> kuribas: exactly; foldr is *the* catamorphism on []
13:33:47 <dyl> Yeah, no support for any of that stuff. Idk if it ever existed.
13:33:54 <MarcelineVQ> implicit is a four letter word, except when it's not
13:34:01 <benzrf> @let   fib (np 2 -> n) = fib (n + 1) + fib n
13:34:02 <lambdabot>  .L.hs:185:1: error:
13:34:03 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ Maybe a
13:34:03 <lambdabot>        Expected type: Maybe a -> a1
13:34:11 <comstar> is >> a catamorphism
13:34:13 <benzrf> @let   fib (np 2 -> Just n) = fib (n + 1) + fib n
13:34:15 <lambdabot>  Defined.
13:34:28 <MarcelineVQ> corvidzz: you'll need to say which >>
13:34:35 <comstar> you mean me?
13:34:36 <dmj`> dspyz: git clone https://github.com/dmjio/miso && cd miso && nix-build
13:34:40 <MarcelineVQ> ye :>
13:34:48 <benzrf> > map fib [1..20]
13:34:50 <lambdabot>  [*Exception: /tmp/mueval2929-0.hs:185:1-42: Non-exhaustive patterns in funct...
13:34:55 <benzrf> :(
13:34:59 <kuribas> Solonarv: I think it's easy enough if you look at it as replacing constructors by a function.
13:35:17 <benzrf> im pretty sure it's foldr's *instances* which are catamorphisms
13:35:34 <kuribas> benzrf: instance?
13:35:34 <Solonarv> kuribas: yes! that's exactly the right intuition 
13:35:42 <benzrf> "catamorphism" the noun refers to a unique morphism given by the initiality of the F-algebra, i believe
13:35:48 <dmj`> @let foo3(zip3 -> xs) = xs
13:35:50 <lambdabot>  Defined.
13:35:50 <benzrf> kuribas: i.e., foldr a b for some a and b
13:35:53 <dmj`> :t foo3
13:35:54 <lambdabot> [a] -> [b] -> [c] -> [(a, b, c)]
13:36:13 <kuribas> benzrf: ah, so each a and b give it's own catamorphism
13:36:14 <vaibhavsagar> dmj`: https://twitter.com/vbhvsgr/status/1095436149701660680
13:36:18 <benzrf> i tihkn so
13:36:21 <benzrf> *think
13:36:21 <comstar> but it's catamorphism from like greek kata-, right 'to go down'
13:36:25 <benzrf> yeah
13:36:43 <comstar> lol
13:37:03 <comstar> @let f x = [1..x]
13:37:04 <dmj`> @vaibhavsagar I retweeted ;)
13:37:04 <lambdabot>  Defined.
13:37:05 <lambdabot> Unknown command, try @list
13:37:12 <monochrom> Yes technically you need the whole "foldr a b" and you also have to remind "[]'s foldr, not some other Foldable instances".
13:37:14 <comstar> >f 3
13:37:18 <comstar> > f 3 
13:37:20 <lambdabot>  error:
13:37:20 <lambdabot>      Ambiguous occurrence ‘f’
13:37:20 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f’,
13:37:26 <comstar> ^ is that an anamorphism?
13:37:31 <dyl> comstar the usage of greek in those terms is somewhat iffy :p.
13:37:37 <comstar> lol
13:37:53 <monochrom> But there is also "depending on the audience, you can abbreviate".
13:37:56 <dyl> Translating "κατά" as "down" is a little weird.
13:38:04 <comstar> but like if I have [1..x] for some x > 2 is that an 'anamorphism' or should I read whatever "F-algebra" is 
13:38:39 <dyl> "into", "for the purpose of", "following from"... 
13:38:54 <monochrom> You should read what F-algebra is.  (It is pretty easy actually.)
13:38:54 <dmj`> vaibhavsagar: lol didn't know you could tag photos
13:38:59 <vaibhavsagar> dmj`: when are we hanging out :)?
13:39:00 <dspyz> @dmj` I was hoping for something small enough I can go through each file and understand what it does. 
13:39:00 <lambdabot> Unknown command, try @list
13:39:09 <comstar> I thought katabasis is a descent, while anabasis is an ascent
13:39:11 <Welkin> 上态射, 下态射
13:39:12 <Welkin> haha
13:39:18 <Welkin> use those instead :D
13:39:23 <dyl> comstar that is correct.
13:39:29 <dmj`> vaibhavsagar: soon :) I've been bad I know, apologies.
13:39:47 <dspyz> @dmj` when you first _start_ writing a ghcjs project, what do you start with?
13:39:48 <lambdabot> Unknown command, try @list
13:39:55 <vaibhavsagar> no worries :)
13:39:57 <dyl> It's just that these prepositions/roots don't entirely have a single meaning.
13:39:57 <Welkin> dspyz: inventing the universe
13:40:06 <Solonarv> (psst you don't need to put an @ before people's names on IRC)
13:40:12 <comstar> ancient greek xata 'downwards'
13:40:17 <dmj`> dspyz: if you just want ghcjs, 'nix-shell -p haskell.compiler.ghcjs86'
13:40:34 <dyl> comstar right but it carries other meanings than "down"/"downwards".
13:40:50 <dyl> It *implies* "down"/"downwards" but has a more general meaning.
13:40:58 <tswett[m]> Yo. We don't have an IRC channel (or a Matrix room) for type theory and dependent typing in general, do we?
13:41:04 <dmj`> dspyz: if you want to do something with ghcjs, nix-shell -p 'haskell.packages.ghcjs86.ghcWithPackages (p: with p; [ miso ])'
13:41:26 <Welkin> ##category-theory
13:41:26 <dspyz> I haven't gotten `nix-shell` to work:
13:41:26 <dmj`> dspyz: both commands will put you into a shell with ghcjs though
13:41:30 <dspyz> $ nix-shell error: getting status of '/home/david/default.nix': No such file or directory
13:41:31 <comstar> yeah 'into'
13:41:43 <dmj`> dspyz: how did you invoke it?
13:41:51 <dyl> And in modern greek it's not used to mean "down" at all really. 
13:41:56 <tswett[m]> (Also, I just discovered Matrix/Riot. It's snazzy! I wonder how this message will show up...)
13:41:57 <dspyz> nix-shell
13:42:01 <comstar> dyl: I appreciate your points, thank you, I'll avoid just reducing the meaning of xata/kata to fit my narrow idea of 'catamorphism'
13:42:05 <dspyz> And then I get
13:42:06 <dspyz> error: getting status of '/home/david/default.nix': No such file or directory
13:42:18 <dyl> It's more like "against" or "in the direction of" in modern greek.
13:42:18 <comstar> tswett[m]: the snazzy was inverted colors
13:42:23 <dyl> And ana is more like "between, among".
13:42:42 <dmj`> dspyz: try to invoke it with the commands I gave you. It might be trying to look for a default.nix in your current directory
13:42:43 <dyl> Ancient and modern greek both have a *lot* of prepositions :p.
13:42:47 <tswett[m]> comstar: Ooh, interesting.
13:42:58 <monochrom> I hate prepositions.
13:43:05 <comstar> dyl: anabasis means retreating in ancient greek too, right
13:43:29 <Welkin> what about botenana?
13:43:30 <dyl> No, anabasis means going from the coast inland.
13:43:34 <Solonarv> tswett[m]: I discovered it a while ago and switched away because the IRC integration felt clumsy and Riot kills my laptop
13:43:40 <dyl> katabasis means interior ⇒ exterior 
13:43:49 <dyl> But to the Greeks, "up" and "in" were closely related.
13:43:57 <dyl> Because going into a body of land meant going up :p.
13:44:11 <monochrom> True of Upper and Lower Canadas too
13:44:16 <dyl> They had a differently consistent/coherent system of conceptual metaphors.
13:44:22 <monochrom> And Upper and Lower Egypts
13:44:28 * dyl plugs Metaphors We Live By.
13:44:33 <vaibhavsagar> Solonarv: which IRC client are you using now?
13:44:35 <dyl> (it's a fun little book.)
13:44:51 <monochrom> Also I love the evoluation of "dashboard".
13:44:55 <dspyz> Any idea how large I should expect `/nix` to get? I tried to build `reflex` earlier and after taking 4 hours, 12 GB and crashing my laptop, I gave up
13:44:56 <comstar> ah
13:45:08 <Welkin> dspyz: 30 gb
13:45:16 <Solonarv> vaibhavsagar: thunderbird, I used quassel for a while but then had to reset my laptop and it broke
13:45:21 <Welkin> dspyz: don't build reflex, download the binaries
13:45:30 <dspyz> Welkin: Please tell me that's a joke
13:45:33 <Welkin> dpn`: no
13:45:36 <Welkin> dspyz: no
13:45:38 <dspyz> (the 30 gb)
13:45:39 <Solonarv> it's not a very good IRC client but it works at least
13:45:41 <comstar> I was wondering because Anabasis being mostly retreating from Persia and anaireo being like to undo oneself
13:45:42 <dmj`> dspyz: nix-shell -p 'haskell.packages.ghcjs86.ghcWithPackages (p: with p; [ miso ])' will fetch it all from the cache 
13:45:53 <dmj`> #cached-lyfe
13:46:00 <comstar> but that's fun ty for the little langauge lesson dyl
13:46:28 <dyl> Right, anabasis makes sense there because it was a "journey up from". 
13:46:30 <dyl> Persia being considered a lowland. 
13:46:40 <comstar> ohhhh
13:46:46 <comstar> that makes a lot of sense
13:46:54 <dyl> For contrast, Aeneas journey into Hades is called a katabasis. 
13:47:12 <dyl> well, into the underworld, not into Hades... ( ͡° ͜ʖ ͡°) 
13:47:22 <dyl> Though that would be consistent with the kind of stories they enjoyed...
13:47:25 <dmj`> dspyz: well, most of it, not all of it
13:47:27 <comstar> yeah
13:48:29 <vaibhavsagar> Solonarv: that "Chat" button has probably been there for years and I've never noticed it before
13:48:51 <Solonarv> yeah, I was surprised to find it too
13:49:10 <dmj`> dspyz: but you'll have to disable doctest
13:49:11 <Welkin> what's wrong with bitchx?
13:49:21 <dmj`> dspyz: I can give you working ghcjs scripts for nix if you'd like
13:49:39 <dmj`> nix scripts for ghcjs* lol
13:50:07 <monochrom> Oh, "chat" button attached to an individual? That's probably DCC chat.
13:50:13 <dspyz> "scripts"?
13:50:20 <dspyz> to do what exactly?
13:50:45 <Solonarv> monochrom: no, the "chat" button on Thunderbird
13:51:46 <monochrom> Hrm! I bet still DCC chat.
13:52:07 <dspyz> dmj`: I ran the nix command you said and for a while it was fetching from cache, but now it's building things
13:52:09 <Solonarv> It's not attached to an individual, though.
13:52:30 <dspyz> And I'm only 4.1 GB in
13:53:24 <Welkin> dspyz: I made the mistake of building reflex (accidentally) through nix once, and let it run overnight. by the next morning it was still going
13:55:12 <dspyz> In any case, all I want at the moment is something like a web page with a button you click and an alert pops up saying "Hello, World!"
13:55:14 <vaibhavsagar> Welkin: was it perhaps bulding GHCJS?
13:55:18 <Welkin> yes
13:55:20 <dspyz> Or anything along those lines
13:55:24 <Welkin> and it failed too
13:55:33 <vaibhavsagar> hahahaha
13:56:03 <vaibhavsagar> dspyz: ./try-reflex shouldn't be building very much at all
13:56:13 <dspyz> That's what I did
13:56:23 <dmj`> dspyz: that's ok if its building stuff, as long as its not building ghcjs that's good
13:56:25 <dspyz> `./try-reflex`
13:56:32 <Welkin> dspyz: do you have to use reflex? I recommend elm for bulding web apps. You can be set up and running in seconds
13:56:35 <vaibhavsagar> do you have the cache.reflex-frp.org cache set up?
13:56:38 <dspyz> and after four hours it crashed my computer
13:56:43 <dspyz> No, I don't need to use reflex
13:56:50 <dspyz> that was just one thing I tried
13:57:02 <dspyz> I do want to ultimately be writing in Haskell though
13:57:10 <Welkin> elm is close enough to haskell
13:57:20 <dmj`> dspyz: this website is all haskell https://haskell-miso.org/
13:57:23 <vaibhavsagar> it's definitely not Haskell
13:57:25 <Welkin> better on some ways
13:57:35 <Welkin> miso is the elm api in haskell
13:57:39 <dspyz> dmj`: That's a lot larger than Hello, World
13:57:45 <dspyz> Sure, let's try elm
13:57:48 <dmj`> dspyz: yea but it has hello world inside of it
13:58:05 <dspyz> But it's not helpful for getting started
13:58:52 <dspyz> At some point in the distant past, someone wrote the first line of code for miso. What did the environment look like when they did that?
13:59:01 <Welkin> bad
13:59:02 <dspyz> That's the environment I'm looking for
13:59:12 <dspyz> Okay, or whatever the equivalent would be today
13:59:17 <vaibhavsagar> dspyz: look at https://github.com/ghcjs/jsaddle
13:59:19 <Welkin> compiling haskell to javascript is a harsh road in general
13:59:40 <Welkin> you can do it, but you will have to be ready for lots of work
13:59:44 <dspyz> Just got
13:59:53 <dspyz> builder for '/nix/store/034f8nyg9kngz48v2b6fkmbg59jpq4mr-doctest-0.16.0.1.drv' failed with exit code 1
13:59:59 <dspyz> cannot build derivation '/nix/store/9qij56ik4ffl6zwmykq5p0gjzyb6mkl3-comonad-5.0.4.drv': 1 dependencies couldn't be built
14:00:06 <dspyz> building '/nix/store/y92vihxsmhdw4hrfjf8yn54ayadzm0ma-contravariant-1.5.drv'...
14:00:13 <dspyz> cannot build derivation '/nix/store/80d021wi0z72zkf662dwiyhvhnmvrq4i-http-types-0.12.2.drv': 1 dependencies couldn't be built
14:00:20 <dspyz> cannot build derivation '/nix/store/ipdy83b8idywj40m2jf38aplra6kzkfl-servant-0.15.drv': 1 dependencies couldn't be built
14:00:27 <dspyz> cannot build derivation '/nix/store/pm4xp8cbw693i6z0ihhm1fvh4zzjxfv0-ghcjs-8.6.0.1-with-packages.drv': 1 dependencies couldn't be built
14:00:28 <Welkin> okay stop
14:00:31 <dspyz> error: build of '/nix/store/pm4xp8cbw693i6z0ihhm1fvh4zzjxfv0-ghcjs-8.6.0.1-with-packages.drv' failed
14:00:33 <Welkin> you don't need to flood the channel
14:00:57 <dspyz> ok, sorry
14:01:12 <Welkin> here is elm if you want to try it https://elm-lang.org/
14:01:34 <Welkin> I gave up on haskell -> js and just use elm instead and love it
14:01:39 <q6AA4FD> dspyz: you only really want the first one of those messages anyways, the rest are just telling you what derivation was pulling in the failed one
14:01:49 <dmj`> dspyz: here's some instructions https://github.com/dmjio/miso#nix
14:11:06 <nvt> any idea how could I sort the lines if I read like this: contents <- hGetContents handle. 
14:11:30 <nvt> I guess the contents includes \n to separate lines
14:11:38 <Welkin> words
14:11:39 <monochrom> you will need "lines" to get a list of lines.
14:11:43 <Welkin> I mean lines
14:13:20 <Solonarv> :t lines
14:13:21 <lambdabot> String -> [String]
14:13:43 <Solonarv> > lines "hello world\nI am a potato"
14:13:45 <lambdabot>  ["hello world","I am a potato"]
14:15:43 <Welkin> > Data.List.Split.splitOn "\n" "look ma\nno hands!"
14:15:45 <lambdabot>  ["look ma","no hands!"]
14:15:50 <Welkin> either of those
14:15:56 <dmj`> dspyz: join the slack and people will help you setup ghcjs too https://haskell-miso-slack.herokuapp.com/
14:41:12 <pie__> how do I debug a hang? I found some helpful info at some point but it was a while ago so I forgot. google isnt being too helpful so far
14:46:26 <zachk> sometimes I pepper my code with print/putstrln statements 
14:46:40 <zachk> too narrow down what is and is not executing 
14:48:18 <pie__> zachk, i have too much code for that
14:48:31 <pie__> then again i guess i should have added tracing anyway...
14:48:39 <Welkin> Debug.trace
14:49:14 <pie__> i mean i would still prefer to actually just find the specific issue right now and add tracing later
14:49:43 <MarcelineVQ> a common approach is to break your functions up into smaller pieces until the problem reveals itself
14:50:28 <MarcelineVQ> also the common approach for profiling problem spots, though you get more info about where to look during profiling
14:55:20 <zachk> make a global/top-level debug variable that is a bool and do conditional tracing/printing 
15:00:09 <sm> pie__: a quick way is to keep adding trace/error calls and reloading in GHCI
15:00:36 <sm> assuming it's easy to reproduce
15:00:53 <pie__> its easy to reproduce.
15:00:55 <pie__> (luckily)
15:01:01 <pie__> (or unluckily :P)
15:01:12 <sm> that lucky, for sure :)
15:01:15 <sm> that's
15:01:40 <pie__> MarcelineVQ, hmm profiling is an idea I guess.
15:01:55 <pie__> man haskell debugging still sounds pretty crappz.
15:01:55 <sm> another way is to comment out code/recent changes until it stops
15:02:13 <sm> don't knock it till you try it!
15:02:19 <pie__> :P
15:03:41 <sm> there are quite a lot of debugging tools at your disposal. The only thing we don't have yet is a conventional GUI stepping debugger (there's a TUI one in GHCI)
15:03:45 <fragamus> OMFG I just watched Matthew Brecknell’s Hole-driven Haskell and it is awesome
15:04:47 <MarcelineVQ> idk if you can profile a program that doesn't stop, haven't looked into it
15:05:53 <sm> turning on -Wall may help detect hangs caused by name shadowing
15:05:56 <fragamus> Has the TypeHoles extension been added
15:06:23 <sm> or maybe that doesn't cause hangs. Not sure.
15:06:32 <MarcelineVQ> > _hole + 3
15:06:34 <lambdabot>  error:
15:06:34 <lambdabot>      • Found hole: _hole :: a
15:06:35 <lambdabot>        Where: ‘a’ is a rigid type variable bound by
15:06:43 <sm> but it's fairly easy to hang yourself with a typo
15:07:23 <MarcelineVQ> not the most descriptive hole example. is this what you are asking about though fragamus?
15:07:34 <fragamus> Is there Hole types of various kinds
15:07:55 <fragamus> Yes MarcelineVQ
15:08:43 <MarcelineVQ> There's type wildcards which are similar, enabled by PartialTypeSignatures
15:09:04 <fragamus> > 3 :: Hole
15:09:06 <lambdabot>  error:
15:09:06 <lambdabot>      Not in scope: type constructor or class ‘Hole’
15:09:31 <fragamus> 3 :: _Hole
15:10:08 <Solonarv> % 3 :: _Hole
15:10:09 <yahb> Solonarv: ; <interactive>:19:1: error:; * No instance for (Num _Hole1) arising from the literal `3'; Possible fix:; add (Num _Hole1) to the context of; an expression type signature:; forall _Hole1. _Hole1; * In the expression: 3 :: _Hole; In an equation for `it': it = 3 :: _Hole
15:10:17 <MarcelineVQ> % foo :: Int -> _; foo n = 3 + 2 -- they're not too smart though
15:10:17 <yahb> MarcelineVQ: ; <interactive>:20:15: warning: [-Wpartial-type-signatures]; * Found type wildcard `_' standing for `Integer'; * In the type signature: foo :: Int -> _
15:13:00 <MarcelineVQ> hehe, nvm I'm the not smart, didn't even use n
15:13:16 <MarcelineVQ> % foo :: Int -> _; foo n = 3 + n -- not bad
15:13:17 <yahb> MarcelineVQ: ; <interactive>:22:15: warning: [-Wpartial-type-signatures]; * Found type wildcard `_' standing for `Int'; * In the type signature: foo :: Int -> _
15:14:36 * hackage bitvec 0.2.0.0 - Unboxed bit vectors  https://hackage.haskell.org/package/bitvec-0.2.0.0 (Bodigrim)
15:16:24 <pie__> well for now i just ended up using the git diff, i forgot i did some coding last night
15:16:48 <pie__> mmy code is kind of convoluted, not sure what the problem is but i "fixed" it by adding an undefined
15:16:52 <pie__> ....wait a minute....
15:17:12 <lyxia> you need the PartialTypeSignatures extension to make GHC fill in the hole and keep compiling, but if you just want to do hole-driven programming the error message is there whether you enable the extension or not.
15:17:58 <pie__> i take it back, i have no idea what it was. maybe it was the rebuild that fixed it..
15:31:37 * hackage filepattern 0.1 - File path glob-like matching  https://hackage.haskell.org/package/filepattern-0.1 (NeilMitchell)
15:41:37 * hackage filepattern 0.1.1 - File path glob-like matching  https://hackage.haskell.org/package/filepattern-0.1.1 (NeilMitchell)
15:46:37 <ququ> Hey! not sure if my question was sent before I DCed, so I'll ask again: is there some compiler flag or so to turn off trace? I have a lot of trace in my functions, but the output is getting too messy
15:47:09 <Solonarv> ququ: no, not as far as I know
15:48:07 <Solonarv> you can define a top-level isDebug :: Bool and define trace' = if isDebug then trace else const id
15:49:14 <zachk> ququ, ^ 
15:50:05 <monochrom> Yikes.
15:52:37 * hackage dhall-to-cabal 1.3.2.0 - Compile Dhall expressions to Cabal files  https://hackage.haskell.org/package/dhall-to-cabal-1.3.2.0 (OliverCharles)
15:53:21 <lyxia> or use Debug.NoTrace
15:54:02 <sm> or Hledger.Utils.Debug
16:04:17 <nvt> how could I at the same time print something to standard output when foldling?
16:04:48 <nvt> I need some magic
16:04:52 <nvt> trick
16:05:21 <Solonarv> nvt: there should be a foldlM somwhere
16:06:17 <Solonarv> @hoogle (b -> a -> m b) -> b -> [a] -> m b
16:06:18 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
16:06:18 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
16:06:18 <lambdabot> GHC.OldList zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
16:06:28 <barrucadu> @type Control.Monad.foldM
16:06:29 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
16:06:47 <Solonarv> ah, that's where it is
16:08:37 * hackage dejafu 2.0.0.0 - A library for unit-testing concurrent programs.  https://hackage.haskell.org/package/dejafu-2.0.0.0 (barrucadu)
16:09:37 * hackage tasty-dejafu 2.0.0.0, hunit-dejafu 2.0.0.0 (barrucadu): https://qbin.io/trace-faster-2bde
16:10:18 <Lears> Or Data.Foldable
16:26:24 <janiczek> Dang I can't get over how great Control.Lens.Plated is for compilers (https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Plated.html#v:transform)
16:30:24 <NoidedSuper> Recursion Schemes do a similar thing
16:51:24 <johnw> janiczek: yes, it's pretty awesome for AST surgery
16:51:45 <johnw> not sure about the performance, though
18:11:53 <maerwald> how stable is purescript these days?
18:12:55 <maerwald> stable as in API and language spec (if any), or do they keep breaking the entire ecosystem with new versions?
18:18:33 <monochrom> I would think a purescript channel has more people who can answer.
18:20:12 <maerwald> Yeah and all will say "yes totally" ;)
18:20:35 <monochrom> I think you can believe them.
18:20:57 <monochrom> I would believe them.
18:50:46 <dmwit> maerwald: I dunno. If somebody asked me how stable Haskell APIs were I think I'd try to be fairly honest about it. e.g. there are breaking API changes to base every year or so but it's usually pretty easy to fix things up.
18:50:58 <dmwit> I don't see why other language fans would be any different in this regard.
18:58:38 <takanuva> is it still possible to use this channel to derive free theorems? I'd like to see the free theorem for (a -> b) -> b
18:59:00 <Solonarv> @free (a -> b) -> b
18:59:01 <lambdabot> Try `free <ident>` or `free <ident> :: <type>`
18:59:12 <Solonarv> @free k :: (a -> b) -> b
18:59:13 <lambdabot> g . h = p . f => g (k h) = k p
18:59:33 <Solonarv> takanuva: you can /query lambdabot too, or install it locally
19:01:07 <takanuva> thank you so much :)
19:01:38 <takanuva> @free x :: (a -> b -> c) -> c
19:01:39 <lambdabot> (forall y. h . k y = p (f y) . g) => h (x k) = x p
19:01:57 <takanuva> I'll take note of those, hope they'll help!
19:02:09 <c_wraith> @djinn (a -> b -> c) -> c
19:02:10 <lambdabot> -- f cannot be realized.
19:02:20 <Solonarv> @free fmap :: (a -> b) -> F a -> F b
19:02:20 <lambdabot> g . h = k . f => $map_F g . fmap h = fmap k . $map_F f
19:02:31 <c_wraith> guess free theorems don't depend on the function being possible :)
19:04:37 <Solonarv> if the function is impossible, they're vacuously true!
19:04:55 <takanuva> these types are useful for continuation-passing, which I'm studying
19:29:04 <dmj`> how does one specify a different c compiler in cabal
19:35:28 <dmj`> is the only way to do it in $(ghc --print-libdir)/settings ?
19:37:47 <geekosaur> there's multiple places the C compiler is used (cabal can compile actual C sources, but ghc also generates C FFI stubs that it compiles without cabal knowing about it)
19:37:57 <geekosaur> so you need to modify both
19:38:22 <geekosaur> and potentially hsc2hs, which builds C programs to determine things like the width of C types
19:39:27 <geekosaur> (and then there's inline-c package, whose quasiquoter might have its own separate C compiler setting)
19:40:12 <geekosaur> there should be a way to override ghc's by command line, look at the -progX options for various X
19:41:38 <haskelling> hi, I am just beginning to learn haskell and i ran into this problem
19:41:40 <haskelling> https://gist.github.com/leabstrait/4c6d18dce4f36533f3b835d6aaefef81
19:41:48 <geekosaur> ...be warned that that could potentially break things in the case of the C compiler on windows, since not all C compilers agree as to e.g. the width of (int) (but I think the main issue here is between VC and msys/mingw, which I think shouldn't be a problem)
19:42:16 <MarcelineVQ> geekosaur: -prog meaning https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html#replacing-phases ?
19:42:39 <geekosaur> yes
19:43:10 <haskelling> i compile the hello world haskell file and get an executable that runs fine 
19:43:18 <geekosaur> haskelling, it shouldn't cause an access violation, but for proper seup you want ":main" so it runs it as if it were a program instead of running main as a function invoked from another Haskell function
19:43:40 <dmj`> geekosaur:  is there a specific cabal file setting for the path to cc 
19:44:00 <geekosaur> in particular, :main lets you specify command line options, just using 'main' like that doesn't
19:44:10 <haskelling> sorry i don't know about cabal 
19:44:22 <haskelling> i haven't reached at that point in the book yet i guess
19:44:52 <Solonarv> haskelling: that message wasn't aimed at you, it's part of a different conversation
19:45:15 <haskelling> oh, okay 
19:47:00 <MarcelineVQ> looks like a ghc bug to me, dying when using the .o file "Main>" but working fine on bytecode "*Main>"
19:47:40 <jackdk> does it persist with other GHC versions? https://github.com/commercialhaskell/stack/issues/3765 seems like there might be some errors around 8.6.3 on windows?
19:48:03 <haskelling> will have to try using another version 
19:49:04 <geekosaur> yeh, this looks like a bug in the bco backend with .o files on windows. sigh
19:49:29 <geekosaur> dmj`, I don't see one. possibly cabal just hands it off to ghc and lets it figure out which cc to use (that'd be ideal)
19:49:56 <geekosaur> but the problem with hsc2hs still remains, if that matters (people have tripped over it not using ghc's before)
19:49:57 <jackdk> I don't use windows much any more, so maybe someone else might be able to help. I heard somewhere you can get 8.6.2 through something called chocolatey
19:51:16 <Solonarv> that's correct, yes
19:51:32 <Solonarv> there are other ways to get 8.6.2 but it's more of a hassle
19:51:42 <Solonarv> 'choco install ghc' Just Works (tm)
19:52:13 <haskelling> okay i'll think about getting to a linux system, i hope the bug's specific to windows and maybe get's fixed soon
19:52:22 <haskelling> :D
19:52:44 <Solonarv> you could also just switch to ghc 8.6.2; how did you install ghc in the first place?
19:53:12 <haskelling> just downloaded the latest version haskell platform from the haskell website
19:54:14 <Solonarv> ah, yeah
19:54:30 <Solonarv> if there's an 8.6.2 haskell platform download I couldn't find it
19:54:37 <Solonarv> I recommend using chocolatey
19:57:23 <geekosaur> earlier 8.6 had some moderately severe bugs and they didn't bother to make Platform releases
19:57:43 <geekosaur> best you'll do is https://www.haskell.org/platform/prior.html
19:58:39 <jackdk> also for initial learning I think you'd do fine without the latest and greatest. A reasonably recent release upgraded a lot of the error messages but I can't remember which
20:01:11 <haskelling> Thank you, I'll use the 8.4 platform version linked by geekosaur
20:01:47 <geekosaur> jackdk, started in 8.0, much improved in 8.2
20:02:11 <geekosaur> and you probably dont care about 8.6 vs. earlier 8.x unless you do a lot of type level hackery... which as a beginner is highly unlikely
20:02:42 <jackdk> thanks geekosaur
20:04:40 <Solonarv> 4:57:02 AM - geekosaur: earlier 8.6 had some moderately severe bugs and they didn't bother to make Platform releases
20:04:40 <Solonarv> that's funny, because 8.6.3 has bugs so severe it's almost unusable - hangs forever on TH, for example
20:09:42 <jackdk> I think in poor haskelling's case we may have gone past "almost"
20:12:44 <haskellian> Hello
20:12:49 <haskellian> This is my first time here
20:13:38 <Solonarv> haskellian: hello!
20:14:06 <haskellian> Hello! solonarv
20:26:21 <sclv> I mean, 8.6.3 is nonetheless still better than the prior 8.6 releases, but I guess that's not saying much.
20:26:37 <Solonarv> it isn't on windows!
20:26:39 <sclv> the whole series has really shown some significant weaknesses in our CI
20:26:57 <Solonarv> the prior 8.6 versions don't choke on TH, for example
20:27:11 <sclv> they were entirely unusable on some platforms
20:27:31 <Solonarv> oh yeah, I was talking about windows specifically
20:27:45 <Solonarv> so really all of 8.6 is kinda borked, I suppose
20:28:07 <sclv> iirc the prior releases in that series were also really screwy on windows in various ways
20:28:15 <sclv> yeah, its too bad
20:29:01 <mniip> hmm, when is reallyUnsafePtrEquality# actually unsafe?
20:30:16 <glguy> I don't know the full answer but I think it's important that you treat a result of 1 as the arguments being equal and 0 as you don't know if they are equal (as opposed to not equal)
20:30:47 <Solonarv> so basically: use it as a fast-path for == and nothing else
20:31:29 <Solonarv> (you can also use it for better sharing, look at the containers package's source for some examples)
22:53:52 <dminuoso> mniip: https://github.com/ghc/ghc/blob/master/compiler/prelude/primops.txt.pp#L3080-L3107
22:55:12 <mniip> so does it ever give a false positive
23:03:08 <dminuoso> mniip: Yes.
23:03:26 <mniip> oh? how so
23:03:49 <dminuoso> mniip: Managed to steal this example off stack overflow and it is an example of a false positive: https://gist.github.com/dminuoso/1c12e7ab5ba76e9b5766d029ff7395f4
23:04:44 <mniip> where's the false positive?
23:05:27 <dminuoso> mniip: Execute this and throw in "True" into stdin.
23:05:40 <mniip> ok?
23:06:15 <mniip> how is this a false positive?
23:06:16 <dminuoso> mniip: On my GHC this will print out "True\nFalse"
23:06:27 <mniip> that's a negative
23:06:30 <dminuoso> mniip: Oh. It's a false negative I guess. Yeah.
23:06:31 <mniip> not even really false
23:06:57 <mniip> the question is whether it can ever say True wrt things that are actually distinct objects
23:07:50 <dminuoso> mniip: I misread your question as "does it ever give a false negative", so thats my bad.
23:07:51 <dminuoso> mniip: No it cant.
23:07:52 <dminuoso> mniip: It can just produce false negatives.
23:09:25 <dminuoso> mniip: As far as I can tell it just does a ptr comparison. But if the ptrs involved are thunks then they could point to different thunks (Even though they might produce the same value pointer)
23:11:24 <MasseR> meh, even 8.4 has quite a few bugs. Type holes being broken is affecting me the most right now.
23:12:01 <maerwald> 8.6.3 is fine, not sure where the fud comes from
23:12:09 <maerwald> and I have not experienced it getting stuck on TH
23:13:36 <MasseR> I don't have any actual projects running on 8.6 but whatever single-file tests I've been doing I do on 8.6 and it's working great
23:37:07 * hackage multipool-postgresql-simple 0.1.0.0 -   https://hackage.haskell.org/package/multipool-postgresql-simple-0.1.0.0 (IanDuncan)
23:42:33 <cads2> hey is it safe to install haskell-stack and haskell-platform packages in ubuntu 18.04?
23:42:44 <cads2> like, on top of each other?
23:46:32 <jakob_> Yes, but they are different things, you need to know. Stack is a program for developing Haskell projects. The Haskell Platform is a suite of tools and libraries that contain the most important and best supported components. 
23:50:15 <jakob_> Stack is practically useless without at least ghc. What do you want to achieve? Are you going to write and deploy software? Stack is a useful tool for that. If you just want to play around with Haskell or write Haskell code for yourself (to be interpreted or compiled to binary) then stack may or may not help you, depending on what libraries you intend to use.
23:51:13 <cads2> AesonException "Error in $.packages.cassava.constraints.flags['bytestring--lt-0_10_4']: Invalid flag name: \"bytestring--lt-0_10_4\""
23:51:16 <cads2> entire log here: https://gist.github.com/maxsu/61af8629c1cc9bf686509172ef01d858
23:51:23 <cads2> I'm trying to build Futhark
23:51:53 <MarcelineVQ> iirc that error canbe resolved by updating your stack version
23:52:23 <cads2> I have done `stack upgrade
23:52:47 <MarcelineVQ> stack upgrade puts the new executable in ~/.local/bin did you point your path there?
23:52:48 <cads2> oh, but I never did stack update
23:52:51 <Athas> cads2: your stack is too old.
23:53:20 <tdammers> jakob_: stack installs ghc for you as needed; saying that it's useless without GHC is technically true, but a bit misleading
23:53:55 <jakob_> tdammers, thanks for the clarification, you are right!
23:54:37 * hackage multipool-postgresql-simple 0.1.0.1 -   https://hackage.haskell.org/package/multipool-postgresql-simple-0.1.0.1 (IanDuncan)
23:54:38 <Athas> I wonder if we'll ever see the last of that bytestring--lt issue!
23:54:45 <cads2> running stack 1.9.3
23:55:37 <cads2> it's still `Decoding build plan from: /home/m/.stack/build-plan/nightly-2018-11-20.yaml` and still `Decoding build plan from file failed: AesonException "Error in $.packages.cassava.constraints.flags['bytestring--lt-0_10_4']: Invalid flag name: \"bytestring--lt-0_10_4\""`
23:56:27 <Athas> cads2: strange, that should definitely be new enough.  Are you sure that the stack that's responding to --versionand the one you're 'stack install'ing with is the same one?
23:56:47 <Athas> You didn't build your own stack binary, right?
23:57:45 <MarcelineVQ> in ~/src/lang/futhark stack --version says 1.9.3?
23:59:03 <cads2> `which stack` yields /home/m/.local/bin/stack from inside the directory, which is the location that `stack upgrade` reports
23:59:21 <cads2> oh hey
23:59:54 <Athas> Hm.  Stale PATH?  Try 'hash -r'.
