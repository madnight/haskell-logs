00:14:57 <trcc> I think I might have overdone some stuff by using the writer monad... hmm.... Might have been easier just returning a list of log messages
00:15:07 * hackage line-bot-sdk 0.3.0.0 - Haskell SDK for LINE Messaging API  https://hackage.haskell.org/package/line-bot-sdk-0.3.0.0 (moleike)
00:17:18 <tdammers> if your monad stack has IO at the bottom, writer is not a great choice anyway
00:18:07 <trcc> it does
00:18:18 <trcc> I am mostly doing IO (Writer ...)
00:18:29 <tdammers> ReaderT of some mutable primitive to put log messages in, and a separate thread to read them back out and write them to stderr / stdout / some file is probably the nicest way
00:18:53 <tdammers> but if you only have one thread writing log messages, you can just use plain IO and have log = putStrLn
00:19:03 <trcc> I can give you a bit more context
00:19:44 <tdammers> btw. IO (Writer ...) means you don't have IO at the bottom, you have IO returning another stack that has Writer in it, but not IO
00:19:51 <trcc> ah ok
00:20:01 <trcc> terminology. Thank you
00:21:10 <trcc> an external applications calls, via ffi, my haskell program, and one of the arguments are a list of callbacks, that can be used to write log messages. My program does whatever it does based on the function called by the external function, and while doing this, it creates various log messages that are appended to a list using the writer monad. In the end, my haskell program goes through this list and uses the correct callba
00:21:10 <trcc> ck based on the loglevel of each logentry
00:22:08 <tdammers> why not call the callbacks right there and then?
00:22:35 <trcc> Not all functions lives in IO, and I have this idea, that it should remain this way
00:23:09 <trcc> but you might be right. This writer stuff is really a lot of mangling in and out of monads
00:23:59 <tdammers> you could use Writer internally, just to collect the log messages, and then return them as a list
00:24:09 <tdammers> or just create a list directly
00:25:04 <tdammers> then you can have a function like doTheThing :: Params -> [LogMessage], no IO involved at all; and then you use that function from inside IO, take the log messages, and invoke the relevant callbacks (in IO)
00:26:12 <trcc> that might be better
00:50:15 <ratinajar> hello  - which is the haskell offtopic channel 
00:50:16 <ratinajar> ?
00:54:49 <ziman> #haskell-blah
00:55:00 <maerwald> #haskell-offtopic
00:57:57 <Lycurgus> (both are about equally populated but they have different characters and -offtopic tends to be more active)
00:58:19 <Lycurgus> -blah requires tls (the reason there's two)
01:01:02 <maerwald> also different operators
01:03:22 <ratinajar> ziman: thank yo! 
01:08:27 <merijn> -blah was originally not affiliated with the #haskell op team, then the SSL restriction nonsensically was enabled, which led to the #haskell op team creating #haskell-offtopic and since then most of -blah has drifted to -offtopic
01:11:18 <ratinajar> i was about to say, and that asnswers my question/confusing regarding not being able to join -blah
01:11:35 <ratinajar> -offtopic seems to be more "ontopic" for its purpose =]
01:19:00 <tdammers> on-topic-ness of both channels tends to fluctuate wildly
02:01:31 <Celahir> Hello, I want to find and get a substring from a string, is there a way to do it ? 
02:01:52 <Celahir> i've tried something with take and drop but always result in an error
02:03:44 <tdammers> what error?
02:03:57 <tdammers> > take 3 . drop 5 $ "This is a long string"
02:03:59 <lambdabot>  "is "
02:04:31 <tdammers> (though note that if you're going to do serious string manipulation, you want Data.Text.Text, not String)
02:05:55 <Celahir> Well i've just forget putting the "$"...
02:08:02 <tdammers> heh
02:08:05 <tdammers> it happens
02:08:21 <tdammers> the error message you get in that case may be a bit confusing if you're not used to it
02:08:30 <tdammers> > take 3 . drop 5 "This is a long string"
02:08:32 <lambdabot>  error:
02:08:33 <lambdabot>      • Couldn't match expected type ‘a -> [a1]’
02:08:33 <lambdabot>                    with actual type ‘[Char]’
02:08:57 <tdammers> although the full error should mention the expression whose type doesn't match, which should give you a hint
02:10:29 <tdammers> it'll say something along the lines of "the second argument to (.), which is "drop 5 "..."" - that tells you that the expression is parsed as (take 3) . (drop 5 "..."), and of course the type of the RHS argument to (.) is supposed to be a function, but what you're passing is not
02:11:34 <Celahir> I'm totally new to haskell, trying some stuff on list manipulation
02:45:37 * hackage http-client 0.6.2 - An HTTP client engine  https://hackage.haskell.org/package/http-client-0.6.2 (MichaelSnoyman)
02:54:07 * hackage bunz 0.0.9 - CLI tool to beautify JSON string.  https://hackage.haskell.org/package/bunz-0.0.9 (sendyhalim)
03:16:30 <fendor> what are the possible values for `os` on windows? mingw32, win32 and something like that? I wanna know whether the script is executed on a windows without cpp
03:22:58 <phadej> what's the type of `os`
03:23:59 <phadej> I'd use http://hackage.haskell.org/package/Cabal-2.4.1.0/docs/Distribution-System.html
03:25:00 <phadej> (and/or look how it's implemented)
03:27:36 <fendor> :t os
03:27:38 <lambdabot> error:
03:27:38 <lambdabot>     • Variable not in scope: os
03:27:38 <lambdabot>     • Perhaps you meant one of these:
03:27:48 <fendor> phadej, type is String.
03:28:47 <phadej> fendor: I'd use Cabal's Distribution.System
03:28:57 <phadej> it classifies System.Info.os for you
03:29:24 <fendor> Then I have to depend on Cabal library, I would like to avoid that, ideally.
03:29:44 <phadej> Cabal library is everywhere GHC is
03:33:03 <fendor> oh well, right.
03:34:19 <__monty__> GHC is also everywhere GHC is but it's a pretty heavy dependency to pull in...
03:40:17 <MarcelineVQ> hmm, wonder why mingw64 isn't on the list http://hackage.haskell.org/package/Cabal-2.4.1.0/docs/src/Distribution.System.html#osAliases
03:40:33 <fendor> __monty__, i was thinking the same but is there a reason why you shouldnt do it?
03:45:46 <kritzefitz> fendor, Depending on large libraries that are always present during development might still increase you runtime dependencies, which results in either larger binaries, when linking statically, or more required dynamic libraries.
03:46:23 <kritzefitz> Specifically, most binaries don't require GHC at runtime, unless you explicitly depend on it.
03:48:49 <fendor> I think I see
03:50:49 <kritzefitz> Normally this isn't relevant for people developing in Haskell, as they need all the development tools for development, but when you distribute compiled binaries (like Debian does) this becomes relevant.
03:55:49 <__monty__> I'm not sure how Cabal the library compares to GHC btw. I just know you need to keep in mind how big your dependencies are, not just whether they come with GHC.
04:10:54 <Taneb> With the new NoStarInType stuff, would I need to import Type? If so, where from?
04:13:51 <Taneb> Ah, Data.Kin
04:13:52 <Taneb> d
04:18:49 <zincy> When should invariants for business logic be encoded at the value level vs the type level?
04:21:03 <mjrosenb> Is there a better way to get a list comprehension to ignore a pattern match failure in a let other than wrapping it in a list, and using another comprehension
04:21:07 <mjrosenb> e.g.
04:21:51 <mjrosenb> [(x,h) | (x,y) <- testList, let (h:t) = y] looks like it should do what I want, but fails
04:22:13 <mjrosenb> [(x,h) | (x,y) <- testList, (h:t) <- [y]] does what I want, but looks kinda silly 
04:22:49 <merijn> zincy: Doing so at the type level has several downsides: 1) compile times, 2) ease of refactoring/changing your architecture, 3) hard to get newcomers started on it
04:23:31 <merijn> zincy: In practice I find that trying to enforce too much at the type level incurs more pain than it gains you. But learning to find the sweet spot can be tricky
04:26:37 <akersof> hi all, i am on macosx and i try to find where is installed prelude.dart
04:26:52 <Taneb> Is there anything like eitherFromMaybe :: e -> Maybe a -> Either e a
04:27:06 <hpc> :t maybe
04:27:08 <lambdabot> b -> (a -> b) -> Maybe a -> b
04:27:10 <akersof> i have no clue where it is, or where i can found it
04:27:21 <Taneb> hpc: ah, I can use that, yeha
04:27:48 <hpc> there's probably a function with that type somewhere though
04:28:13 <Taneb> I guess what I really wanted was MonadError e m => e -> Maybe a -> m a
04:31:01 <zincy> merijn: Thanks. Is learning type level programming going to make me a better programmer though? 
04:31:13 <merijn> Yes, no, maybe :)
04:31:23 <hpc> it won't make you a worse programmer
04:31:34 <Taneb> (updating old code that used failable patterns in do notation)
04:31:48 <merijn> hpc: Debatable ;)
04:32:28 <zincy> merijn: please explain :)
04:32:52 <tdammers> sometimes, knowledge can have a paralyzing effect
04:33:07 <merijn> tdammers: Or you end up overcomplicating unnecessarily
04:33:13 <zincy> Like choosing what movie to watch on netflix
04:33:24 <merijn> zincy: I mean, I learned a ton just uselessly messing around with all sorts of extensions
04:33:51 <merijn> I'm not sure it made me a better programmer or that I would advocate using it "in production", otoh, I wholly endorse learning for the sake of learning :)
04:33:57 <zincy> Ok so what are the best things you can do to level up after you learn the basics
04:34:09 <tdammers> write more code, read more code
04:34:37 <merijn> And read some of the papers
04:34:45 <merijn> A number of them are fairly accessible
04:35:01 <merijn> "Fun with Type Functions" is a good paper that's reasonably accessible
04:35:20 <zincy> The codebase I am working on has use of typefamilies and other such extensions which I am curious about
04:35:30 <merijn> zincy: I also made some gists of some of my standalone experiments that you can play with
04:35:39 <zincy> Is learning about metaprogramming useful?
04:35:44 <merijn> zincy: https://gist.github.com/merijn/6130082 https://gist.github.com/merijn/39dc86e345e87276c523 https://gist.github.com/merijn/dc00bc7cebd6df012c5e
04:35:48 <zincy> I.e lisp macros/ template haskell
04:36:30 <merijn> zincy: The high cost of metaprogramming (in terms of compile time and understandability) means it's best avoided, but some otherwise impossible things become possible with it
04:36:50 <merijn> zincy: Incidentally, the GHC user's guide is an underrated document with lots of info about (and pointers to papers) extensions
04:37:15 <zincy> Maybe I am better of learning C and how memory management works :D
04:37:30 <merijn> zincy: And while I'm linking fairly short example code, I think this package is a nice example of neat tricks using template Haskell: https://github.com/merijn/validated-literals
04:37:31 <zincy> I feel like I am getting into more theoretical realms now with haskell
04:37:32 <hpc> learn both
04:37:43 <merijn> zincy: I agree with hpc, learn both :)
04:37:46 <tdammers> yes, do learn both
04:37:47 <hpc> you need to know how the machine works, but you definitely still need the theory as well
04:37:52 <zincy> :)
04:37:58 <tdammers> and then learn some more languages
04:38:01 <merijn> zincy: Also, contrary to popular opinion, GHC exposes a lot of those low level details to programmers
04:38:12 <hpc> once you're comfortable with c, check out rust as well
04:38:19 <zincy> Thats the plan hpc 
04:38:29 <merijn> zincy: You can write some pretty low level stuff using GHC if you know the basics in C: https://hackage.haskell.org/package/ghc-prim-0.5.3/docs/GHC-Prim.html
04:38:38 <hpc> you'll need to be comfortable with type-level programming to be able to follow the borrow checker too :D
04:38:52 <zincy> Really?
04:39:03 <zincy> So type-level programming would be useful for Rust
04:39:24 <hpc> you won't need to be DataKinding all the things, but being used to thinking at two levels simultaneously is important
04:40:21 <zincy> My todo-list for the next 6 months Typelevel programming in Haskell, C and basic comp architecture and then rust
04:40:47 <hpc> that's a good list
04:40:52 <merijn> Yeah
04:40:54 <zincy> Thanks
04:41:17 <merijn> Bit ambitious maybe, for 6 months :p
04:41:29 <zincy> yeah more like a year
04:41:36 <merijn> Depends on whether you have a full-time job/education next to it :p
04:41:51 <zincy> Its a year if it is all you do
04:41:58 <hpc> it took me a summer month in college to go from nothing to haskell irc bot
04:42:04 <hpc> so it's doable, but probably tight if you start right now
04:42:18 <zincy> That is fast
04:42:44 <zincy> Anything I should add to the list?
04:42:44 <hpc> from what i understand of other people and myself learning rust, you'll either get lucky or you won't
04:42:49 <akersof> little question, does ghc/ghci use a compiled version of all the base package (for example this one http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.List.html)
04:43:01 <hpc> in being able to quickly intuit what borrows and references and such are all about
04:43:04 <zincy> Probably shouldn't add anything if I want to see daylight :)
04:43:19 <hpc> come back in 6 months perhaps ;)
04:43:22 <akersof> or they are pure haskell file in my haskell environement?
04:43:26 <zincy> :)
04:43:42 <zincy> Thanks for the advice everyone
04:44:16 <tdammers> IME, you may actually make faster progress if you have a job next to it
04:44:42 <zincy> tdammers: Why is that?
04:44:55 <tdammers> because it gives you a practical perspective on things
04:45:09 <merijn> tdammers: Not if you're too tired to study/practice after work :p
04:45:15 <tdammers> depends on the work, yes
04:45:46 <tdammers> obviously flipping burgers for 10 hours and then studying type-level programming in Haskell in the evening isn't going to be super productive
04:45:48 <zincy> I have a remote programming job
04:45:54 <zincy> haha
04:47:25 <zincy> Will try and study the things and apply them where I can in my job
04:47:59 <tdammers> but a programming day job that is loosely connected to the concepts you're studying is going to help a lot
04:48:33 <tdammers> and there's only so many hours per day that you can focus deeply anyway, so studying for 16 hours per day isn't going to be 4 times as productive as studying 4 hours per day
04:48:41 <tdammers> possibly even less productive
04:49:08 <zincy> Yeah I am working with a colleague who uses type level programming in the codebase trying to understand what he has done will help :)
04:49:54 <zincy> tdammers: Having too much time is horrible for procrastination you need creative constraints.
04:50:32 <Celahir> Hey guys, how should I use findSubString to count the number of occurence of a substring in a string ? 
04:52:24 <zincy> finSubstring returns the index of the first occurrence of said substring no?
04:52:56 <Celahir> Yea that's the prob, i need to count the number of occurences I have in a string for a substring
04:56:09 <zincy> countSubs substring str = length $ split (onSublist substring) str
04:56:27 <zincy> Thats the split package
05:40:40 <meatich> hi everyone
05:40:51 <meatich> i am trying to figure out how to use gnuplot package
05:41:02 <meatich> i have installed it using stack install gnuplot
05:41:16 <meatich> but when I do import Graphics.Gnuplot.Simple
05:41:33 <meatich> and try to use any function like plotFunc, I get an error
05:42:04 <meatich> "parse error on input"
05:42:10 <meatich> could anyone help?
05:42:36 <merijn> meatich: It would help if you create a paste with the offending source code and error ;)
05:43:04 <Celahir> Hi guys, I'm trying to count the occurences of a substring into a string, I've tried with something like that https://paste.ofcode.org/38G9g4dZXHTnGrahXpT5Hqr but that doesn't work, any idea ?
05:43:20 <meatich> merijn: alright, will do
05:48:46 <Taneb> It's a little frustrating that so little seems to have a MonadFail instance
05:49:25 <merijn> Taneb: MonadFail has only been around for a short while
05:51:29 <meatich> alright, here is the paste for that gnuplot error
05:51:32 <meatich> https://pastebin.com/NDHiyUER
05:52:00 <meatich> if I just do "stack ghci" and then import the module and run the command, everything works
05:52:12 <meatich> I don't understand why compilation fails
05:52:53 <Solonarv> meatich: ghc doesn't know which type of number you're using
05:53:01 <Solonarv> ghci has more aggressive defaulting, so it's fine there
05:53:13 <merijn> meatich: Basically this part: "Ambiguous type variable ‘a0’ arising from a use of ‘plotFunc’" means the following
05:53:20 <Solonarv> as the error message says: "Probable fix: use a type annotation to specify what ‘a0’ should be."
05:53:42 <merijn> meatich: "You are passing a polymorphic value to a function that accepts a polymorphic argument and thus I can't figure out which specific instance/type you wanted to use"
05:53:51 <merijn> :t 5
05:53:52 <lambdabot> Num p => p
05:53:58 <meatich> that makes sense
05:54:08 <meatich> so how do i fix it?
05:54:19 <meatich> do i do :: Integer after each value?
05:54:20 <Taneb> How bad an idea is using irrefutable ~-patterns in do notations for things I know cannot fail?
05:54:23 <Solonarv> you add a type annotation
05:54:40 <Solonarv> it should be enough to annotate only one of the literals there
05:54:45 <merijn> meatich: So your "1000" passed to linearFunc can be "any Num instance" and linearFunc works for any type that is an instance of "Graphics.Gnuplot.Value.Atom.C" but there might be multiple legal candidates
05:55:24 <merijn> meatich: "(1000 :: Double)" for example, would be enough to let GHC figure out you want it to use Double
05:55:28 <Solonarv> (actually, the '1000' is fixed to Integer)
05:55:43 <merijn> Could be, I'm lazy and didn't look up the library :p
05:55:58 <Solonarv> I did :p
05:56:14 <Solonarv> writing (-20, 20 :: Double) should fix it
05:56:34 <Solonarv> (can't be Integer - that's not Floating, so you can't use 'sin' on it)
05:56:41 <meatich> Alright, one sec, trying it out
05:57:21 <merijn> meatich: For future reference, the correct solution to any problem involving "ambiguous type" in the error is always "throw more type signatures at it until it goes away" ;)
05:58:00 <tdammers> for lots of other type errors, it is also a good first step
05:58:08 <meatich> Solonarv: it works, thanks!
05:58:19 <meatich> merijn: alright, understood, thanks!
05:58:23 <tdammers> type annotations can serve a similar purpose as unit tests or asserts
05:58:50 <tdammers> "at this point, I think the type should be this", and then if the compiler doesn't agree, you know where to start digging
05:59:26 <meatich> :tdammers alright, i will have to get used to it i guess : )
06:04:37 * hackage fltkhs 0.7.0.4 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.7.0.4 (deech)
06:12:23 <meatich> guys, i hope you are still here, because i have another problem
06:12:26 <meatich> while compilation is fine, and while 'stack run' executes the code, no graph is shown as when using ghci
06:12:37 * hackage fltkhs-themes 0.1.0.6 - A set of themed widgets that provides drop in replacements to the ones in FLTKHS.  https://hackage.haskell.org/package/fltkhs-themes-0.1.0.6 (deech)
06:13:12 <meatich> i put putStrLn before and after the plotFunc command and those print, but no graph
06:17:37 <Shiro> hey
06:17:41 <Celahir> Hi guys, I'm trying to count the occurences of a substring into a string, I've tried with something like that https://paste.ofcode.org/38G9g4dZXHTnGrahXpT5Hqr but that doesn't work, any idea ?
06:18:07 * hackage split-morphism 0.1.0.0 - Split Epimorphisms and Monomorphisms  https://hackage.haskell.org/package/split-morphism-0.1.0.0 (gvolpe)
06:18:41 <Shiro> I'm a newbie in Haskell, and I've got troubles understanding how to return values in Haskell, basically, I'd like to make a function that takes no parameters and returns a value, "MyFunction : String", but somehow, that doesn't work :/
06:18:43 <opqdonut_> Celahir: your code works if you change the type to `String -> Char -> Int`
06:19:03 <opqdonut_> Celahir: you're filtering the elements of tab (which is a String), so the elements have type Char
06:19:32 <Celahir> Yea but I want to find a substring in a string, not just a character
06:19:40 <opqdonut_> then you need a different algorithm :)
06:19:50 <opqdonut_> > tails "abcd"
06:19:53 <lambdabot>  ["abcd","bcd","cd","d",""]
06:19:54 <opqdonut_> that might help
06:21:06 <Celahir> I want to count the number of time I match the substring in the string* sorry 
06:21:12 <Celahir> I'll check for tails then
06:22:12 <Solonarv> you might also be interested in 'isPrefixOf'
06:22:23 <Solonarv> > "ab" `isPrefixOf` "abcd"
06:22:26 <lambdabot>  True
06:23:51 <Celahir> Well, thank you !
06:49:37 <dmwit> Celahir: Just to check: is "abc" a substring of "abdc"?
06:51:11 <dmwit> Oh, I see a reasonable answer has already been given. Never mind.
07:00:59 <absence> function parameters are often called f. what about natural transformations?
07:02:07 <mniip> eta
07:02:24 <Solonarv> I've seen n, f, nat, eta
07:05:41 <absence> i had a hunch about h for some reason, but i'd rather use a common one :) thanks
07:06:29 <dcoutts> sclv: ping
07:10:31 <Celahir> dmwit: Yea that's it
07:41:37 * hackage libraft 0.4.0.0 - Raft consensus algorithm  https://hackage.haskell.org/package/libraft-0.4.0.0 (sdiehl)
08:00:13 <reallymemorable> I am super new to haskell (1 week in) and am trying to modify an existing codebase as a way of practicing (in addition to doing some training books).  GHCID is throwing an error I can't interpret.  I'm wondering if people here have thoughts: https://paste.ofcode.org/znrjanydnvrA7CYZBwR9sp
08:01:07 <Solonarv> that code snippet is too small to be sure what the error is, can you post more of the surrounding code?
08:01:50 <reallymemorable> it's throwing an error on the line that starts loanType
08:01:56 <Solonarv> yes, I know
08:01:57 <Cale> reallymemorable: Well, one thing which is almost certainly wrong is that you have that return () on the line following the definition of loanType, sort of floating there
08:02:14 <Cale> but the error that's mentioned is probably caused by something before this definition
08:02:17 <Solonarv> yeah, that seems incorrect - but it isn't causing the parse error
08:02:29 <reallymemorable> so i dont need the return()?
08:02:36 <merijn> Yes, no, maybe
08:02:42 <reallymemorable> lol
08:02:47 <merijn> Impossible to tell without surrounding code and types
08:02:53 <Cale> The return () doesn't really fit there
08:02:55 <merijn> But as-is, probably not
08:02:56 <Solonarv> no, you probably don't, but that isn't what's causing the error message
08:03:40 <Cale> (it'll cause the type of 'pure' on the preceding line to be inferred as something weird, and the definition might typecheck as a result, but won't mean what you want it to mean if that's the case)
08:04:53 <Cale> btw, pure and return are nearly synonyms, the only difference being just how polymorphic they are
08:04:56 <Solonarv> what you've written is: loanType = meta "loanType" "" $ (pure fico return ())
08:04:56 <Solonarv> this is valid syntax for a top-level definition, so I assume it isn't a top-level definition in your program
08:04:58 <sclv> dcoutts: pong
08:05:26 <Cale> yeah, syntactically, it's okay
08:06:19 <Cale> reallymemorable: If you could paste the entire file it's complaining about, it would be easier to tell what's going on
08:06:46 <reallymemorable> the entire .hs file is quite large
08:06:54 <reallymemorable> let me see what is relevant
08:06:58 <reallymemorable> hunting...
08:06:58 <Solonarv> don't
08:07:05 <Solonarv> just post the entire file
08:07:13 <Solonarv> we can jump to a line number
08:07:37 * hackage hal 0.3.0 - A runtime environment for Haskell applications running on AWS Lambda.  https://hackage.haskell.org/package/hal-0.3.0 (nikeoss)
08:08:27 <dcoutts> sclv: a dev at IOHK has bought the domain haskell.dev to prevent squatters and would like to donate it to haskell.org. Sound plausible? Should I put them in touch with you?
08:08:52 <sclv> put them in touch with ryan and the committee@ address
08:09:06 <sclv> i think we we've had one other donation of another related domain for anti-squatting purposes too
08:09:20 <dcoutts> great, ok, thanks!
08:14:49 <reallymemorable> I fixed it!
08:14:51 <reallymemorable> https://paste.ofcode.org/U8xQy3nV6TUg57Y62vXMte
08:15:23 <Solonarv> ah-ha, that makes a bit more sense
08:15:35 <Solonarv> (note: you don't need the parentheses around 'fico' there)
08:15:41 <reallymemorable> because it's only one?
08:16:06 <Cale> yeah, there's no need to parenthesise a single variable
08:16:22 <Solonarv> and function application doesn't involve parentheses either
08:16:37 <reallymemorable> what do you mean Solonarv
08:16:38 * hackage servant 0.16 - A family of combinators for defining webservices APIs  https://hackage.haskell.org/package/servant-0.16 (phadej)
08:16:41 <reallymemorable> the pure ()?
08:17:06 <tdammers> haskell's syntax for function application ("function call") is just juxtaposition
08:17:12 <Solonarv> no, '()' is a special value
08:17:26 <tdammers> where you'd write f(x) in, say, JS or Python, you write f x in Haskell
08:17:28 <Solonarv> but to apply a function to an argument you just put them next to each other
08:17:38 * hackage servant-server 0.16, servant-http-streams 0.16, servant-client-core 0.16, servant-client 0.16 (phadej): https://qbin.io/label-rep-nd27
08:17:40 * hackage codeworld-api 0.3.1 - Graphics library for CodeWorld  https://hackage.haskell.org/package/codeworld-api-0.3.1 (ChrisSmith)
08:17:41 <reallymemorable> and factor is a function
08:17:43 <reallymemorable> ok 
08:17:45 <reallymemorable> understood
08:17:56 <reallymemorable> fico would be a "value"?
08:18:00 <reallymemorable> is that the correct term?
08:18:02 <reallymemorable> or argument
08:18:09 <tdammers> parentheses serve three purposes: tuple syntax (a, b), grouping expressions (1 + 2) * 3, and the "unit" type (and its only value), both denoted as ()
08:19:10 <tdammers> so parenthesizing function arguments is sometimes OK, e.g. in f(x), but it doesn't mean the same thing as in those other languages; and the similarity breaks down when you have zero arguments or more than one
08:19:41 <tdammers> f () means "apply f to the unit value", not "call f with zero arguments"
08:19:43 <reallymemorable> is `factor (thing1 thing2)` correct?
08:19:46 <tdammers> no
08:19:57 <reallymemorable> ok
08:20:07 <tdammers> factor (thing1 thing2) means "apply thing1 to thing2, and then apply factor to the value of that"
08:20:26 <tdammers> you could rewrite it as let x = thing1 thing2 in factor x
08:21:42 <tdammers> it may be worth noting, at the risk of adding to the confusion, that all haskell functions are unary
08:21:51 <tdammers> i.e., every haskell function takes exactly one argument
08:22:20 <tdammers> when you write `f x y`, then that really means "apply f to x, and then apply the result of that to y"
08:22:42 <tdammers> but you will often see people use sloppy terminology, saying that f "takes two arguments", or that you are "applying f to x and y"
08:22:51 <tdammers> which is more like informal shorthand for the actual thing
08:23:37 <tdammers> if you like, you can add parentheses to f x y like so: (f x) y
08:23:55 <nvt> what's wrong with this? straight from my lessons and wont compile: facAux 0 r = r \ facAux n r = facAux (n − 1) (r ∗ n)
08:24:22 <tdammers> nvt: without further info, I'd blame the −
08:24:26 <tdammers> try - instead?
08:24:30 <nvt> oh, shit :D
08:24:40 <Solonarv> and the weird star too, I think
08:24:43 <Solonarv> should be * instead
08:24:44 <tdammers> (or maybe enable unicode syntax, no idea if that works)
08:24:47 <nvt> best way to feel stupid is to ask stupid questions
08:25:10 <Solonarv> copypasting from latex-typeset haskell: not even once ;)
08:25:21 <tdammers> oh boy
08:25:39 <nvt> yeah even * was wrong
08:28:04 <tdammers> they look the same in my terminal
08:28:15 <tdammers> oh wait no they don't
08:28:26 <tdammers> ∗ is aligned lower than *
08:29:09 <Taneb> nvt: you'll probably learn better by taking the time to type things out rather than copy-pasting, too :)
08:29:53 <tdammers> or, better yet, actually write them down and evaluate them with pen and paper
08:29:57 <tdammers> (not joking)
08:58:23 <akersof> hi all there is a way to apply constraints on type of a lambda?
08:58:45 <Solonarv> I'm not entirely sure what you mean
08:58:56 <akersof> Solonarv: indeed it is not clear
08:59:16 <akersof> takeHalf lst = take ((\x -> length x `div` 2) lst) lst 
08:59:50 <akersof> i wrote this little dirty code for fun,  even if it is useless, there is a way to say the x of my lambda has to be a list ?
09:00:08 <dminuoso> akersof: You can use a type annotation.
09:00:22 <dminuoso> akersof: if you enable ScopedTypeVariables, you can do it on the pattern
09:01:01 <akersof> i never enable kind of things, but i saw some source code with this inthe header i think
09:01:11 <dminuoso> takeHalf lst = take ((\(x :: [Integer]) -> length x `div` 2) lst) lst
09:01:25 <dminuoso> akersof: Its probably better to move the function into an annotated where binding.
09:01:31 <Logio> note that using length already requires the argument to be a list
09:01:38 <dminuoso> I couldn't instantly make sense of what the function does.
09:01:40 <akersof> Logio: indeed
09:01:41 <Solonarv> (note that this forces 'lst' to be [Integer], instead of the polymorphic [a])
09:01:45 <Solonarv> :t length
09:01:46 <Solonarv> no
09:01:47 <lambdabot> Foldable t => t a -> Int
09:01:53 <Solonarv> does not require a list
09:02:01 <dminuoso> Solonarv: It's not polymorphic in that spot anyway.
09:02:02 <akersof> Solonarv: good point
09:02:44 <akersof> dminuoso: ok yeah i know i am trying to play like a little wizard with lambda
09:03:10 <akersof> and ofc it is hard to read int he context of my code
09:03:29 <Solonarv> it probably doesn't help that the lambda there is unnecessary verbosity
09:04:56 <Solonarv> btw, I don't think it's a good idea to stay away from all language extensions on principle
09:07:54 <akersof> there is a drawback by enabling {-# LANGUAGE ScopedTypeVariables #-} in my source file?
09:08:02 <akersof> looks like a good feature
09:09:18 <Solonarv> I'm not aware of any
09:09:29 <geekosaur> not really. it's a pragma because it steals a keyword that would otherwise be a valid variable name ("forall")
09:09:34 <Solonarv> and it lets you write more type signatures, which is very much a good thing
09:09:44 <akersof> thx for the advice
09:11:17 <t4nk960> hey!
09:11:24 <Solonarv> t4nk960: hello1
09:11:41 <t4nk960> trying to figure out writeFile
09:11:47 <t4nk960> it requires FilePath
09:12:04 <t4nk960> I can't seem to be able to make a FilePath object though
09:12:15 <t4nk960> I import System.FillePath
09:12:21 <t4nk960> * System.FilePath
09:13:00 <t4nk960> then try to do: FilePath("/tmp/file") but constructor is not found
09:13:51 <t4nk960> Do you guys know what's wrong?
09:14:38 <dminuoso> t4nk960: type FilePath = String
09:15:21 <t4nk960> hmmmm alright
09:15:27 <t4nk960> lemme try something
09:16:37 <t4nk960> dminuoso: Yeah, it works!
09:17:15 <dminuoso> t4nk960: You might be interested in this search engine: https://hoogle.haskell.org/?hoogle=FilePath
09:17:20 <t4nk960> still kinda wonder why tab completion shows System.FilePath.FilePath and I can't use it
09:17:37 <dminuoso> t4nk960: That's because it's a type synonym.
09:18:36 <t4nk960> You mean type synonyms can't be used upon import?
09:19:01 <dminuoso> t4nk960: GHCi
09:19:09 <dminuoso> t4nk960: GHCi's tab completion is not very restricted.
09:19:20 <dminuoso> It gives you typeclasses, type constructors, data constructors..
09:19:32 <t4nk960> Oh, I see.
09:19:36 <dminuoso> And apparently type synonyms too.
09:19:47 <Solonarv> ah, it's not namespace-sensitive? shame
09:19:59 <dminuoso> Solonarv: Im not sure it could sensibly do this.
09:20:03 <glguy> "t4nk960: then try to do: FilePath("/tmp/file") but constructor is not found" >> type synonyms don't introduce a new value constructor, Strings and FilePaths are interchangable
09:20:12 <glguy> so you'd just write "/tmp/file"
09:20:29 <dminuoso> Solonarv: It would require a syntactically complete expression, or it has to do this heuristically.
09:20:57 <t4nk960> dminuoso: Ok, I see.
09:21:05 <t4nk960> Thank you guys!
09:21:31 <t4nk960> I should get used to using Hoogle
09:21:44 <dminuoso> t4nk960: Alternatively you can obtain a lot of information using :i in GHCi too.
09:22:11 <t4nk960> dminuoso: Ok
09:22:14 <dminuoso> But it requires the thing you are looking for to be in scope, whereas hoogle will search through its database of knowledge.
09:22:52 <Squarism> this might be a bad question, but is there "system f" as a library. A way of a constructing program value in haskell. So that lets me ask more about its structure and such.   
09:23:18 <Squarism> So that it lets me ask...
09:23:18 <t4nk960> dminuoso: that's fair enough I guess. Thanks again!
09:24:30 <meatich> exit
09:25:43 <Solonarv> Squarism: depends on what exactly you're trying to accomplish
09:31:50 <Solonarv> Squarism: template haskell or the GHC API might be helpful
09:32:07 <Squarism> Solonarv, well for one - i would like to be able to pattern match on lambda terms. Find certain types, transform to easier to digest representations and such
09:34:29 <Squarism> I guess im not 109
09:35:01 <Squarism> eh ... 100% certain on what i want
09:35:48 <Squarism> im thinking a DSL that atleast can have type functions
09:36:34 <Squarism> product type functions
09:39:45 <Solonarv> ah, if you don't need to represent all of Haskell you have more options
09:52:17 <Squarism> Solonarv, oh ok. Ive tried to use an implemenation of simply typed lambda calculus and that worked swell. So if i could just add product types to that it would be problem solved.
09:52:29 <Squarism> Do you have any suggestions?
09:53:53 <Solonarv> I don't, sorry
09:58:44 <ski> Squarism : fwiw, systems like lambdaProlog, Twelf, allows one to represent terms with bound variables (upto renaming), including matching on them
10:00:52 <ski> so you can define a type similar to `data Expr = App Expr Expr | Abs (Expr --> Expr)' (no (bound) variable data constructor needed) to represent pure lambda calculus, where values of type `Expr --> Expr' are like (parametric/uniform) functions, but you can also pattern-match on them
10:01:51 <Squarism> ski, thanks. Ok, ill check them out. They need to be libraries of haskell though
10:02:57 <ski> so `\x. \k0. \k1. k0 x' could be represented as (using the pseudo-Haskell syntax from above, not actual syntax in these systems) `Abs (\x --> Abs (\k0 --> Abs (\k1 --> App k0 x)))'
10:03:19 <ski> well, they are not libraries of Haskell
10:03:25 <Squarism> ah bugger
10:03:55 <ski> .. but perhaps it would be possible to make a library with similar features (matching on "lambda terms"), perhaps using TH and quasiquotation syntax
10:07:20 <ski> (also the staged programming systems MetaML (but not MetaOCaml, iiuc) allowed matching on (code) expressions of function type)
10:08:54 <Squarism> the idea would be to have an FFI back into haskell so that some expressions would abstracted away. TH is a good idea, but id hoped to leave it out as its a beast on its own. Let users build programs using some abstracted api and handle evaluation and some structure representations. Fail on too complicated / involved features. Say limit it to 2 type product types
10:41:37 * hackage yst 0.7.0.1 - Builds a static website from templates and data in YAML orCSV files.  https://hackage.haskell.org/package/yst-0.7.0.1 (JohnMacFarlane)
10:59:10 <ski> Squarism : hm, "2 type product types" ?
11:01:54 <Blob_> Hello, I'm trying to remove N characters at the end of a string, any idea how to do it please ? 
11:02:27 <argent0> :q
11:02:36 * argent0 *facepalms*
11:02:59 <ski> > liftA2 (zipWith const) id (drop 3) "abcdefgh"  -- Blob_ ?
11:03:01 <lambdabot>  "abcde"
11:03:41 <ski> > let xs = "abcdefgh" in zipWith const xs (drop 3 xs)  -- or without using the possibly confusing `Applicative ((->) rho)' instance
11:03:43 <lambdabot>  "abcde"
11:04:23 <ski> Blob_ : .. or were you looking for help on how to do it, by an explicit recursion ?
11:06:12 <Blob_> I'm new in haskell so I don't understand everything there, maybe it will be better with an explicit recursion ?
11:06:32 <marvin2> > (reverse . drop 3 . reverse) "12345"
11:06:34 <lambdabot>  "12"
11:06:57 <Blob_> ho
11:06:59 <ski> if you haven't run into the function `zipWith' (or `zip') before, then yes, possibly it would be better to "do it by hand"
11:07:13 <ski> do you understand marvin2's solution ?
11:07:22 <Blob_> Yea it's clear now
11:07:37 <ski> do you know how to define your own `take' and `drop' functions ?
11:07:39 <Blob_> reverse string then drop chars then re reverse it
11:07:58 <Squarism> ski, not sure what i would call it but 2 arg type functions maybe?
11:08:30 <ski> Squarism : hm, sounds like a strange restriction, to me (if i understand correctly)
11:08:52 <Blob_> Yup, thank you Ski
11:09:04 <Blob_> and marvin 
11:09:36 <ski> Blob_ : note that for long lists (ordinary strings are lists, in Haskell), `reverse'ing twice will possibly be inefficient. the `zipWith const' solution is supposed to be better in that regard
11:10:00 <Squarism> ski, true. But theres no reason to make it more involved in this case. Just fishing around
11:10:29 <Blob_> Well ok, I'll remember that then
11:10:46 <Blob_> what is the import for liftA2 btw ?
11:11:12 <ski> Squarism : i suppose i don't see why disallowing more than two type parameters would help make the system simpler in whatever relevant way you prefer
11:11:18 <ski> @index liftA2
11:11:19 <lambdabot> Control.Applicative
11:11:38 <Squarism> ski, i guess not. 
11:11:54 <ski> Blob_ : but if you're just starting with Haskell, it's probably better if you leave `liftA2' alone for a while, and focus on more basic things, first
11:12:15 <Blob_> Yea true, I'll just save it for later
11:12:34 <Blob_> Thank you anw guys
11:13:44 <ski> Blob_ : Haskell is a non-strict language, implementations of it are typicaly lazy. this includes Haskell lists (including strings). when working with a list, it only computes as many elements (starting from the front, typically) as required/demanded. this way, we can work with infinite (or very long) lists, in finite (or small) memory
11:15:25 <ski> Blob_ : e.g. if you use the action `getContents' (or `hGetContents') to capture the whole of user (textual) input (or some other opened file, perhaps a pipe or a network connection) as a single string, you can start processing the front of that string, without having to wait for the latter parts of it to be loaded into memory
11:16:19 <ski> Blob_ : however, if you use `reverse', then that would force the lazy Haskell implementation to wait for the whole of the string to be loaded into memory, at once. before being allowed to continue
11:17:57 <rvanderwarf> hi
11:17:59 <Blob_> Yea I understand that using reverse isn't very performant
11:18:40 <Blob_> and I guess that tools like liftA2 were created to gain in perf when reading big inputs
11:19:18 <ski> > take 25 (let sieve (p:ns) = p : sieve [n | n <- ns,n `mod` p /= 0] in sieve [2 ..])  -- computing the (infinite) list of prime numbers, only demanding the first twenty five of them
11:19:20 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
11:20:12 <ski> Blob_ : nah, `liftA2' was just used as a handy trick to avoid having to write the list in two places (in the version without `liftA2', i instead named the list `xs', and then wrote `xs' in two places)
11:21:45 <ski> Blob_ : in this case, `liftA2 f g h x' is the same as `f (g x) (h x)'. hence `liftA2 (zipWith const) id (drop n) xs' is the same as `zipWith const (id xs) (drop n xs)', which is the same as `zipWith const xs (drop n xs)', because `id x' is equal to `x', for any input `x' (here `xs')
11:23:51 <ski> > zipWith (+) [1,2,3] [40,500,600]  -- this shows what `zipWith' does, applying a function to each pair of corresponding elements, taking from two lists
11:23:53 <lambdabot>  [41,502,603]
11:24:33 <ski> > zipWith (+) [1,2,3] [40,500,600,7000,80000]  -- if one list is longer than the other one, the remaining elements at the end are just dropped
11:24:35 <lambdabot>  [41,502,603]
11:25:22 <ski> > zipWith const [1,2,3] [40,500,600,7000,80000]  -- `const x y' is defined to be the first argument, `x'. so this just gives the elements of the first list
11:25:24 <lambdabot>  [1,2,3]
11:26:23 <ski> > zipWith const [40,500,600,7000,80000] [1,2,3]  -- if we flip the order of the lists (but still use `const' which picks the first element, from the first list here), we will drop the elements of the first list, which doesn't get paired with corresponding elements of the second list
11:26:25 <lambdabot>  [40,500,600]
11:27:53 <ski> > zipWith const [0,1,2,3,4,5,6,7] [3,4,5,6,7]  -- similar example, with different lists. note the latter list is a suffix of the former, having losed the initial `n' (here three) elements
11:27:55 <lambdabot>  [0,1,2,3,4]
11:28:01 <ski> > drop 3 [0,1,2,3,4,5,6,7]
11:28:03 <lambdabot>  [3,4,5,6,7]
11:28:42 <ski> > zipWith const [0,1,2,3,4,5,6,7] (drop 3 [0,1,2,3,4,5,6,7])  -- hopefully the above examples better explain how this solution for "dropping three elements from the end" works
11:28:44 <lambdabot>  [0,1,2,3,4]
11:28:47 <ski> Blob_ ^
11:32:20 <zuserm> Blob_: there's always also the simple option of (\n xs -> take (length xs - n) xs) if you're not planning on fusing xs away anyway
11:42:21 <koz_> Someone did a whole blog post on 'zipWith const'.
11:42:46 <koz_> https://github.com/quchen/articles/blob/master/2018-11-22_zipWith_const.md <-- shoulda known lol...
11:43:07 * hackage crdt 10.4 - Conflict-free replicated data types  https://hackage.haskell.org/package/crdt-10.4 (cblp)
11:53:07 * hackage hlint 2.1.15 - Source code suggestions  https://hackage.haskell.org/package/hlint-2.1.15 (NeilMitchell)
12:00:16 <hololeap> i'm looking at the cabal docs here:
12:00:18 <hololeap> https://www.haskell.org/cabal/release/cabal-1.10.1.0/doc/users-guide/#example-package-using-detailed-1.0-interface
12:00:43 <hololeap> what test frameworks provide something that return Distribution.TestSuite.Test ?
12:00:53 <Guest10> @help
12:00:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:03:01 <cocreature> hololeap: the detailed stuff never caught on
12:03:14 <cocreature> also you’re looking at an ancient version of the docs
12:03:26 <Guest10> @help pl
12:03:26 <lambdabot> pointless <expr>. Play with pointfree code.
12:04:00 <bifunc2> data Foo = Foo { boom :: Scientific, boom2 :: Scientific }
12:04:00 <bifunc2> How would you make Foo an instance of Store (store package)
12:04:43 <hololeap> oops. thanks, cocreature 
12:05:22 <phadej> hololeap: that's ancient cabal version docs
12:05:41 <phadej> https://cabal.readthedocs.io/en/latest/
12:06:24 <phadej> hololeap: and to answer your question, I'm not aware of anything using type: detailed-0.9
12:08:01 <hololeap> thanks phadej 
12:22:17 <isomarcte> Are there any maintained libraries for working with Json schema? I see two on hackage/github, aeson-schema and hjsonschema. The first recommends the use of the second. The second says "DEPRECATED".
12:22:18 <hololeap> ok, so i'm playing around with a test-suite that uses HUnit. i have an assertion that fails, and it prints this in the report, but the overall test-suite passes. do i have to manually check for this and call System.Exit.exitFailure?
12:24:49 <phadej> hololeap: can you paste the code of your test-suite somewhere
12:26:46 <hololeap> phadej: http://dpaste.com/3AZY33P
12:30:07 <hololeap> here's the relevant part of my cabal file: http://dpaste.com/3SGSQ47  and here is the output of cabal: http://dpaste.com/2ZWW69M
12:40:03 <phadej> hololeap: yeah, it seems you heave to analyse the resulting counts yourself and exitFailure if there are failures e.g.
12:42:25 <hololeap> megh
12:42:27 <hololeap> *meh
12:43:51 <phadej> I'm not aware of anyone using HUnit as their choice of test-driver either
12:44:01 <phadej> hspec and tasty, test-framework
12:44:09 <phadej> but raw HUnit, never seen.
12:44:28 <hololeap> ok, i will check those out. this is the first time i've dove into testing in haskell.
13:13:20 <isd> Hey all. I'm trying to understand the details of how GHC infers the *kinds* of type variables (rather than type inference), and having trouble finding any information on this (search engines seem to be utterly incapable of understanding that type /= kind in this context). Can anyone point me to a description of how this works?
13:15:37 <[exa]> isd: AFAIK it works just as with the hindley-milner, but much more locally in most situations (at least without GHC extensions)
13:16:13 <[exa]> isd: and yeah, with defaulting to *
13:18:55 <[exa]> isd: about the original question -- didn't find any official description, sorry :]
13:20:31 <[exa]> isd: vaguely related, a recent ghc commit: 
13:20:33 <c_wraith> isd, most everything comes from "default to * if unknown", "(->) :: * -> * - > *", and the standard application rules
13:20:48 <[exa]> isd: https://github.com/ghc/ghc/commit/2257a86daa72db382eb927df12a718669d5491f8
13:21:07 <Welkin> you got stars in your eyes
13:21:13 * isd suddently realizes haskell has a spec: https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-970004.6
13:21:40 <isd> [exa]: thanks.
13:21:46 <c_wraith> the spec doesn't cover kinds.. They're not required to be a first class concept by it.
13:22:36 <[exa]> isd- I really liked the "kind inference monster" commit name
13:22:43 <isd> c_wraith: see the link. higher kinded types are part of haskell 2010.
13:23:10 <isd> I'm not sure how much of GHC extensions I'm directly interested.
13:23:18 <isd> But yes, that's a great name.
13:28:10 * ski would prefer calling them "higher order types"
13:28:19 <Welkin> god types?
13:28:31 <Welkin> like "the god (damn) particle"
13:28:32 <Welkin> :P
13:29:10 <EvanR> thats nonsequitur AF
13:29:11 <ski> (or would anyone consider using the term "higher typed values", e.g. for `interact',`map' ?)
13:29:40 <EvanR> higher order functions, functions that take functions as arguments
13:29:55 <EvanR> higher order types, "types" that take types as arguments
13:30:06 <Welkin> so what are higher order sheep?
13:30:09 <EvanR> more like we needed "type functions" from the beginning
13:30:20 <ski> how about `Parser (Expr -> Expr -> Expr)' ?
13:30:40 <EvanR> type functions that take type functions as arguments
13:30:56 <EvanR> higher order type functions
13:31:20 <Welkin> functions that take programmers as argumentd
13:31:43 <EvanR> i get 0% positive reaction when first using "type constructor" when explaining haskell
13:31:54 <Welkin> then don't explain haskell
13:32:02 <Welkin> show it
13:32:15 <Welkin> be a shower, not a grower
13:33:24 * ski . o O ( a good grower may sometimes wish for a shower )
13:33:47 <isd> You do hear them called higher order types in the literature sometimes.
13:34:00 <[exa]> hmm
13:34:16 <[exa]> does curry-howard isomorphism extend to kinds?
13:34:23 <Welkin> is this literature called Cosmo Magazine?
13:34:43 <isd> [exa]: basically? it's just a type-system for your type-system
13:34:52 <EvanR> types at the kind level are just propositions about propositions
13:34:53 <Welkin> @quote type system
13:34:54 <lambdabot> No quotes for this person. And you call yourself a Rocket Scientist!
13:34:58 <Welkin> @quote Welkin
13:34:58 <lambdabot> Welkin says: can it wash your cat and wax your lawn?
13:35:03 <isd> Haskell 2010's kinds are just the simply-typed lambda calculus
13:35:05 <Welkin> what?
13:35:21 <Welkin> @quote welkin
13:35:21 <lambdabot> No quotes match. My pet ferret can type better than you!
13:35:26 <EvanR> Welkin: u drunk m8?
13:36:23 <ski> imho, "polykinded","polykind" are also confusing terms. is there anything wrong with "polymorphic type" ?
13:36:34 <ski> @quote Welkin type.system
13:36:34 <lambdabot> Welkin says: You know you're a functional programmer when your type system has a type system
13:36:42 <[exa]> isd: well that's true but the question is whether there's some reasonable straightforward translation to logic, like 'proofs of proofs'
13:36:46 <isd> ski to me that evokes the type of a polymorphic function
13:36:55 <isd> (i.e. a type of values, rather than a kind of type)
13:37:03 <ski> isd : i call that a `forall'-type, or a universal type
13:37:22 <EvanR> proofs are values, and kinds dont have values
13:37:26 <isd> ski, right, but are polymorphic kinds not just that promoted to types?
13:37:30 <EvanR> its propositions all the way up
13:38:01 <Welkin> and turtles all the way down?
13:38:17 <ski> `Nothing' is a polymorphic value. its type is a `forall'-type. `Const', defined by `newtype Const c a = MkConst c', is a polymorphic type. its kind is a `forall'-kind
13:38:20 <[exa]> EvanR: oh sorry the other way down, theorems about theorems
13:38:36 <EvanR> yeah
13:38:39 <isd> [exa]: it's the same thing, except that your propositions are kinds and your proofs are types.
13:38:50 <jackdk> @pl \x y z -> x + y + z
13:38:50 <lambdabot> ((+) .) . (+)
13:38:54 <isd> as opposed to types being propositions and values being proofs.
13:39:04 <ski> isd : iow, the root source of the problem is insisting to use the term "polymorphic" when describing the *type* of a polymorphic value
13:39:20 <[exa]> isd: so, no 3-level structure in logic?
13:39:31 <isd> [exa]: I think DML has sorts.
13:39:43 <[exa]> hmm
13:39:50 <isd> and you have the infinite hierarchy approach, where it's CIC all the way up.
13:40:11 <ski> the type of a pair (value) is not a pair (unfortunately the syntax chosen in Haskell may reinforce this incorrect conclusion). the type can be called a pair type, (better ?) a product type
13:40:17 <[exa]> CIC?
13:40:39 <inkbottle> Inside a project, files are modules, and filenames are capitalized; Conversely, you can write an example, with a main but no module, and you will not capitalize its filename. Is that what is customary?
13:40:40 <isd> After you get value : type : kind : sort, folks just give up and talk about an infinite heirarchy of types.
13:41:03 <[exa]> oh so, ok
13:41:21 <EvanR> we need at least 1 more named level, for fun
13:41:24 <ski> similarly, the type of a function is not itself a function (at the type level) (i remember talking with someone, in here (i think), who insisted on this confusion). its type could be called a function type. or an arrow type, or an exponential type, or perhaps an implication type, if we call the type of a pair a conjunction type
13:41:36 <isd> https://en.wikipedia.org/wiki/Calculus_of_constructions though you could do infinite type hierarchies without dependent types
13:41:39 <isd> (but I haven't seen it)
13:43:15 <ski> so, perhaps one could then expect that the type of a polymorphic value would be called a polymorphic type (cf. type of pair/function could be called a pair/function type. a type pair/function is something else). however, the then suggested term "type polymorphic" for things like `Const' sounds a bit strange, no ?
13:44:27 <ski> (probably because "pair" and "function" are nouns, while "polymorphic" is an adjective)
13:44:34 <Welkin> in agda there is an infinite universe of Sets
13:44:48 <Welkin> Set < Set1 < Set2 Set3 < ...
13:44:51 <Welkin> I think
13:45:07 <isd> Welkin: right, and in this case Set = type
13:45:36 <ski> isd : DML ? Dependent ML ?
13:45:42 <isd> ski yeah
13:46:25 <isd> "dependent" in this case can be a bit confusing; it doesn't have pi and sigma types -- it's not as powerful as CoC/CIC, but it does have types that depend on values
13:46:38 <isd> ATS is a DML derivative that adds linear types
13:46:47 <isd> (if you've heard of that)
13:48:46 <lunabo> [exa]: you have things like first-order logic, second-order logic, third-order logic, etc. But I don't think those correspond to the three level structure of terms, types, kinds
13:49:13 <ski> iirc ELF (Edinburgh Logical Framework) has terms, type( familie)s, kinds
13:49:59 <ski> isd : can a type depend on a run-time input, in DML ?
13:51:05 <ski> (iow, can the world of values "cross over" into the world of types, without ugly tricks like singletons ?)
13:51:38 <Welkin> they can in idris and agda and other dependently typed languages
13:52:18 <ski> yes, without something like that, i wouldn't consider it to be a real dependently typed language
13:56:07 * hackage PyF 0.7.2.0 - Quasiquotations for a python like interpolated string formater  https://hackage.haskell.org/package/PyF-0.7.2.0 (guibou)
13:57:07 * hackage servant-dhall 0.1.0.2 - Servant Dhall content-type  https://hackage.haskell.org/package/servant-dhall-0.1.0.2 (phadej)
14:01:01 <inkbottle> I've asked the above question about uncapitalized filenames, because here: https://github.com/haskell/zlib/tree/master/examples, filenames are not capitalized
14:01:19 <inkbottle> however I cannot find general guidance about that
14:05:46 <lyxia> I haven't seen any consensus on this matter and probably nobody cares because it just works either way.
14:06:15 <inkbottle> OK, thanks
14:08:56 <isd> ski: it is definitely less hacky than anything like singletons, but the not *all* values can be reflected into the type level; there is a somewhat more restricted set of constraints that can be promoted. There is definitely debate as to whether DML style "counts" as dependent types or not though.
14:09:07 <isd> There's a good treatment of the design in ATTAPL.
14:11:21 <Solonarv> inkbottle: usually filenames must match module names; module names must be capitalized, so the filenames are as well
14:11:49 <Solonarv> the exception is if the module name is 'Main', in which case the filename can be whatever you want and capitalizing doesn't seem necessary to me
14:16:11 <ski> isd : ok, ty
14:26:00 <tswett[m]> Hey everyone. Can I ask about finding remote work here?
14:26:54 <trcc> So I am having trouble adding tuple to my library. Cabal file and log is here: https://gist.github.com/CThuleHansen/2697c7afc46b4f5df31a262601457092. Can someone point me in the right direciton?
14:28:40 <inkbottle> Solonarv: Thanks. I think, not capitalizing them (examples, mostly), do help differentiate them from modules, proper.
14:29:48 <Cale> tswett[m]: You certainly can ask about it
14:30:07 <trcc> ah removing default environemnt fixed it
14:30:32 <tswett[m]> Hey Cale.
14:30:36 <Cale> hey
14:30:42 <tswett[m]> So I think I've been coming here off and on for... like, gee, 15 years. :D
14:31:40 <tswett[m]> Anyway, I'm a bit of a washed-up software developer. I've been out of work for coming up on two months. But I've always been interested in functional programming and all that jazz, so I figured maybe I could find something here.
14:32:14 <tswett[m]> I doubt anyone here really remembers me, but I used to go by uorygl for a while.
14:32:41 <tswett[m]> I'm especially interested in type theory. But it's not easy to find a job involving type theory. :D
14:32:45 <Cale> I certainly recognise your nick
14:33:08 <Cale> Yeah, a Haskell job is probably the closest you're going to get there, outside of academia
14:33:43 <tswett[m]> You know, the joke I make is that I'm "doomed to go to grad school".
14:34:53 <tswett[m]> I wonder if there are any academic jobs I can get without a Ph.D.
14:36:12 <sclv> trcc: did that work before you added the `tuple` dependency?
14:36:16 <jackdk> I have seen some people get teaching positions sans PhD but they're often teaching more industrial courses. I don't know enough about the academic systems to say definitively but I suspect type theory is too academic for that sidestep
14:36:29 <sclv> ah never mind its fixed
14:36:32 <sclv> missed taht
14:36:34 <trcc> sclv: hehe yes
14:36:35 <trcc> thanks though
14:37:16 <tswett[m]> I feel like I "should" be able to get a nice high-paying job with the credentials I already have.
14:37:50 <tswett[m]> But I haven't fit into any of the positions I've had so far.
14:39:00 <Welkin> you don't get paid for your credentials
14:39:22 <Welkin> you get paid for creating value/making money (or making your boss look good)
14:39:49 <tswett[m]> Well, it's both, right? You need credentials to get the job, and you need to create value to keep it.
14:40:11 <Welkin> no
14:40:20 <Welkin> you just need to provide value
14:40:24 <Welkin> your credentials mean nothing
14:40:29 <jackdk> you need to prove that you can create value to get a job, and many employers consider credentials an acceptable proxy
14:40:44 <tswett[m]> Yeah, that.
14:41:22 <tswett[m]> So maybe I should think about how I can create value.
14:42:45 <MarcelineVQ> If you do think of a way consider also that you can create value for yourself instead of for someone else.
14:43:18 <tswett[m]> Well, I'm not totally sure what you mean. I can write software for myself, but that doesn't pay the bills.
14:43:45 <Welkin> quantify the value you produce
14:43:47 <MarcelineVQ> What I mean is if something you do is worth money it's better for you to have that money
14:44:37 <tswett[m]> Anyway, the "most obvious" answer to my question is, I can create value by writing software. But it turns out I'm really, really bad at writing software when I'm not "into" what I'm writing.
14:45:59 <tswett[m]> If you say "hey Tanner, we need you to alter this SQL query so that it gives a 10% discount to everyone who quit smoking within the last 5 years"... that sounds really boring, so I'm going to draw my feet and take weeks to finish that even though it's really, like, half an hour of actual work.
14:46:02 <tswett[m]> *drag my feet
14:46:11 <Welkin> no
14:46:19 <Welkin> you don't create value by writing software
14:46:43 <Welkin> if you are building a house, do you say "I'm creating value by hammering nails and pouring concrete"?
14:47:00 <Cale> y... yes?
14:47:05 <Welkin> no, you say "I'm creating value by building a house for someone to live in, or to sell for a profit"
14:47:08 <tswett[m]> I mean, kinda.
14:47:29 <tswett[m]> Yeah, I guess that makes sense.
14:47:49 <tswett[m]> So in my example it's... "I'm creating value by encouraging people to be healthier"?
14:47:52 <Welkin> no one cares how the sausage is made
14:48:01 <Welkin> they just want it to taste good and fill them up
14:48:48 <tswett[m]> Hmmmm.
14:48:53 <tswett[m]> How do I apply that, though?
14:49:12 <Welkin> focus on the outcome
14:49:32 <Welkin> even just use the "5 Whys"
14:49:33 <_deepfire> By saying "unknown package: hadrian:happy:exe.happy" -- does Cabal mean that it things that 'happy' is a sub-thing of 'hadrian'?
14:49:39 <_deepfire> *thinks
14:49:44 <Welkin> hadrian o.o
14:49:50 <Welkin> they really have taken this too far
14:50:23 <jollygood2> why is Data.Set's elem so slow? it is 5 times slower than list's `elem`, and 2700 times slower than Data.Set.member
14:50:40 <Welkin> read the source to find out
14:51:26 <tswett[m]> 5 Whys, is that when I say something like "the plane crashed because it hit the ocean, it hit the ocean because the pilots couldn't pull up, they couldn't pull up because the jackscrew failed, the jackscrew failed because it wasn't lubricated properly, it wasn't lubricated properly because the airline's procedures weren't sufficient, and the procedures weren't sufficient because the policy didn't require it"?
14:51:47 <jollygood2> I was hoping for an explanation why, rather than suggestion to dig through ghc sources. I googled, and found this:  ut also for monomorphic containers and with some extra tricks to make functions like elem fast for Set and HashSet (elem from Foldable works in O(n) time for Set).
14:51:53 <Solonarv> jollygood2: 'elem' doesn't get an Ord constraint on the set's elements, so it must do a linear traversal
14:51:58 <Solonarv> which is really slow!
14:52:02 <jollygood2> Solonarv, oh
14:52:29 <Cale> jollygood2: It's asymptotically faster than Data.List's elem
14:52:34 <jollygood2> Solonarv, that's pretty horrible.. everything compiles, looks ok, but you get linaer search
14:52:41 <MarcelineVQ> Foldable keeps catching me. I'm like.. "wtf is elem, does he mean elems, I don't see an elem here" :(
14:52:43 <Cale> er, wait, what?
14:52:53 <Cale> oh, you're using that
14:52:53 <Solonarv> :t elem
14:52:53 <jollygood2> Cale, it is 5 times slower
14:52:54 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
14:52:58 <Welkin> rename it `elmo`
14:53:03 <Cale> dang
14:53:06 <Solonarv> see, no Ord constraint (and no way for Set's instance to require one)
14:53:23 <Cale> yeah, don't use Foldable -- I assumed you were talking about a function in Data.Set
14:53:37 <Solonarv> the function in Data.Set is called 'member'  ;)
14:53:51 <Welkin> we need a `.goldmember`
14:54:02 <Cale> right
14:54:06 <Solonarv> dsal: ping
14:54:57 <jollygood2> is it sensible for Data.Set to even have a Foldable instance, with a gotcha like this if you use elem by mistake (which can happen by accident, if you say, initially use a list, and then switch to Set)
14:56:10 <Solonarv> elem is pretty much the only gotcha in there, the rest of the instance is useful
14:56:49 <Solonarv> I wonder if there's some mechanism to attach a warning to elem @Set
14:57:18 <jollygood2> elem = error "Use S.member instead"? :)
14:58:12 <Solonarv> No, only a warning
14:58:18 <jollygood2> of course, compile time warning woudl be even better, but I would have honestly prefer a runtime crash over using elem by accident
14:58:46 <ski> (i suppose exporting an alias `elem = member' from `Data.Set' would be annoying ?)
14:58:48 <Cale> Foldable is kind of awkward
14:58:58 <Solonarv> sometimes you can't switch to member because you're being polymorphic over Foldable
14:58:59 <Welkin> cue the awkward squad :D
14:59:03 <Cale> altogether
14:59:17 <Welkin> hey, what exactly is "the awkward squad" from that haskell paper anyway?
14:59:35 <jollygood2> ski, that wouldn't help if you do import qualified Data.Set as S
14:59:55 <Welkin> import as Set, not S
15:00:00 <Cale> "Functional programming may be beautiful, but to write real applications we must grapple with awkward real-world issues: input/output, robustness, concurrency, and interfacing to programs written in other languages."
15:00:08 <Welkin> anyone reading your code will thank you
15:00:09 <Cale> from the abstract of that paper
15:00:12 <Solonarv> and instance methods which are just 'error' are even worse than slow ones, IMO
15:00:33 <Welkin> Cale: I see
15:00:38 <Welkin> erlang solved all of those :D
15:00:41 <Cale> "Tackling the Awkward Squad: monadic input/output, concurrency, exceptions, and foreign-language calls in Haskell"
15:00:45 <jollygood2> Welkin, I prefer S for Set, T for Text, etch, and I've seen that in a lot of other people's code
15:00:50 <Solonarv> ..hmm. I wonder how often a 'elem = Data.Set.member' rewrite rule would fire?
15:00:59 <jollygood2> s/etch/etc
15:01:11 <Welkin> jollygood2: because you see others do it doesn't mean it's a good idea. I see all kinds of crazy variations
15:01:11 <Cale> Solonarv: you wouldn't want to rely on it anyway
15:01:24 <Solonarv> I like: import Data.Set (Set); import qualified Data.Set as Set
15:01:27 <Cale> Solonarv: but it might be a good thing to go along with the warning
15:01:44 <Cale> Solonarv: I wonder if it's possible to apply a deprecation warning to an instance method implementation
15:01:46 <Solonarv> (sometimes I'll add operators to the unqualified import as well)
15:01:47 <jollygood2> Welkin, and, likewise, just because you prefer Set, doesn't mean it is a good idea either
15:01:53 <Solonarv> Cale: that's exactly what I was wondering
15:02:11 <Welkin> I don't "prefer" Set, it is just what makes the most sense o.o
15:02:56 <jollygood2> I'm a bit annoyed that I have to bloat the source with S. prefix Set. prefix would make that even worse
15:03:04 <Welkin> what do you save by omitting 2 characters?
15:03:21 <Welkin> it becomes harder to understand by anyone reading it
15:03:29 <yushyin> exactly 2 characters
15:03:46 <Welkin> how does that benefit you in any way?
15:03:47 <jollygood2> Welkin, that is obviously not true, because I've seen other people using it. I've seen more people using S than Set
15:04:00 * ski . o O ( `import qualified Data.Set as Data.Set' )
15:04:09 <jollygood2> :-D
15:04:16 <Welkin> that is really the worst argument for something I have ever seen
15:04:38 <Cale> I import the module as S or Set randomly depending on how I feel about it at that very moment
15:04:49 <Cale> (honestly I don't think too hard about it)
15:04:49 * Welkin slaps Cale with a banana
15:04:51 <jollygood2> Welkin, I don't really think I have to present any argument. please go push your personal preference on someone else
15:05:07 <Welkin> be consistent at least!
15:05:17 * Solonarv . o O ( import qualified Data.Set as Data.Container.Set.Tree.BinaryBalanced.Ordered )
15:05:20 <Cale> If Data.Sequence is also getting imported, probably that makes me lean toward Set
15:05:37 <Cale> just for clarity
15:05:40 <Welkin> Solonarv: haha
15:05:57 <glguy> I prefer importing as Set and Map, etc, but I've seen lots of code using single-letter names, too
15:06:10 <Cale> Data.Miscellaneous.Control.Junk.Drawer
15:06:14 <Welkin> have fun when I import using chinese characters
15:06:33 <Solonarv> don't worry we'll just z-encode them
15:06:54 <glguy> I've got a vim-macro for transforming an "import Data.Map" into "import qualified Data.Map as Map\nimport Data.Map (Map)" (generalized to use the name of the right-most module part)
15:07:03 <Cale> import qualified Data.Set as 集合
15:07:17 <Solonarv> hey, there's a preprocessor for that glguy
15:07:45 <Solonarv> https://theam.github.io/require/
15:08:45 <Welkin> > let Σ = sum in Σ [1..10]
15:08:47 <lambdabot>  error: Not in scope: data constructor ‘Σ’
15:09:14 <Solonarv> > let ∑ = sum in ∑ [1..10]
15:09:15 <Welkin> that's one annoying thing about haskell
15:09:16 <lambdabot>  <hint>:1:5: error: parse error on input ‘∑’
15:09:28 <Welkin> arbitrary naming restrictions
15:09:55 <Welkin> > let σ = sum in σ [1..10]
15:09:57 <lambdabot>  55
15:10:09 <Welkin> not the same
15:10:33 <Solonarv> and the proper 'sum' character (which is ∑, not Σ) doesn't work either
15:10:36 <benzrf> > let 集合 = 3 in 集合
15:10:39 <lambdabot>  3
15:10:45 <benzrf> so that's lowercase is it
15:11:40 <Welkin> let 🦙 = fix in fix error
15:11:43 <Welkin> > let 🦙 = fix in fix error
15:11:46 <lambdabot>  <hint>:1:5: error: lexical error at character '\129433'
15:11:47 <Welkin> oops
15:11:56 <Welkin> > let 🦙 = fix in 🦙 error
15:11:58 <lambdabot>  <hint>:1:5: error: lexical error at character '\129433'
15:13:44 <Welkin> what is 2+🐟?
15:14:05 <Cale> benzrf: ahhh, forgot about that
15:14:33 <ski> > let (∑) = sum in (∑) [0 .. 9]
15:14:35 <lambdabot>  45
15:15:12 <Solonarv> yeah, it's treated as an operator
15:15:23 <koz_> ski: Awesome.
15:15:30 <Welkin> an all-emoji programming language
15:15:33 <Solonarv> > generalCategory '∑'
15:15:34 <Welkin> let's make one
15:15:35 <lambdabot>  MathSymbol
15:15:38 <Welkin> we can do it easily in lisp
15:15:41 <Solonarv> pretty sure there is already one
15:16:33 <Welkin> 🤡 +💩=☠️
15:16:52 <Welkin> prolog with emojis :D
15:18:07 * hackage servant-multipart 0.11.4 - multipart/form-data (e.g file upload) support for servant  https://hackage.haskell.org/package/servant-multipart-0.11.4 (phadej)
15:28:03 <ski> Welkin : Prolog with emoticons <https://github.com/Anniepoo/prolog-examples/blob/master/emoticons.pl>, also see <http://www.pathwayslms.com/swipltuts/())).pl>
15:32:32 <unyu> Welkin: “all-emoji” --> I thought that was Haskell already. :-p
15:49:41 <Welkin> emacs thinks that prolog files are perl
15:49:54 <koz_> Not just Emacs, lol.
15:50:03 <koz_> I ran into this problem a few times in the past.
15:50:21 <unyu> Change your auto-mode-alist?
15:50:35 <Welkin> doesn't perl6 use a new extension too?
15:51:55 <jackdk> stick a `-*- prolog -*- ` at the top of your file?
15:52:05 <jackdk> with prolog's comment char, whatever that is?
15:52:44 <Welkin> %%%
15:52:52 <Welkin> this isn't vim!
15:53:06 <Welkin> I see code cluttered with things like that for vim
16:00:19 * ski has an old snippet in `$HOME/.emacs', copied from someone else, headed by a comment `;;; perl in all honor but what the heck, prolog's kooler :)', that directs `.pl' to `prolog-mode'
16:00:58 <ski> (and Prolog is an older language than Perl)
16:02:49 <yushyin> as for 'this isn't vim!', vim by default does some heuristic to check if .pl is a perl or prolog file, works well most of the time.
16:53:28 <jollygood2> what's the name of the extension that allows inner function to use constraint of the outer function?   outerFunc :: (Show a) .. = ... where innerFunc :: a -> ...
16:53:48 <hpc> scoped type variables?
16:54:12 <mniip> scopedtyvars would make sure the inner 'a' is the same as the outer one
16:54:21 <mniip> and thus (Show a) is for "the right" a
16:55:54 <jackdk> you'd need  a `forall a . `in the type decl of outerFunc though
16:56:10 <jollygood2> I need to use forall syntax?
16:56:49 <lyxia> yes
16:56:52 <MarcelineVQ> you can check the manual for juicy details :>
16:58:06 <jollygood2> am I missing something? seems like an odd limitation to require forall syntax
17:00:20 <mniip> jollygood2, you need the forall syntax to know whether it's a new 'a' or an old one
17:23:29 * ski thinks turning on the extension should simply bring the tyvar in scope, *except* if it's explicitly introduced with a `forall'
17:26:43 <Solonarv> so you want 'a' to be in scope in the body of 'foo :: <some type involving a>', but not in the body of 'foo :: forall a. <some type involving a>' ?
17:27:01 <ski> (in `blah :: (forall a. ..a..) -> ...; blah = ...', clearly `a' can't be in scope in the defining equation(s). so it would be more consistent, imho, that with `blah :: forall a. ..a..; blah = ...', `a' would also not be in scope in the defining equation(s). otoh one could think of `blah :: ..a..; blah = ..a..' as implicitly being `forall a. { blah :: ..a..; blah = ..a.. }', with the same `a' scoping over both signature and definition)
17:27:07 <ski> yes
17:27:32 <ski> in case the extension is enabled, of course
17:28:54 <Solonarv> that seems slightly backwards / inconvenient
17:29:17 <Solonarv> what if I want to bring a bunch tyvars into scope, but want them to be available for TypeApplications as well?
17:29:32 <Solonarv> with your proposal those would be mutually exclusive!
17:31:59 <ski> hmm. that's a good point
17:33:53 <ski> `TypeApplications' has always made me a bit uneasy, since you can use them with operations with type signatures without explicit `forall' (which would explicitly fix the expected ordering)
17:34:34 <Solonarv> more generally, when I want to use tyvars in a function's body I would like to explicitly control how they are brought into scope, which means a 'forall' seems perfectly appropriate
17:35:12 <Solonarv> yeah, that's also something I'm uneasy about
17:36:07 <ski> in any case, i think the syntax for type applications ought to be available in definienda (what's to the left of `=' in defining equations)
17:37:11 <ski> so that one could express something like `blah @a @b (m :: Maybe a) ... :: ... = ...'
17:37:42 <Solonarv> IIRC there's already a ghc proposal for this
17:37:42 <ski> (but `TypeApplications' using the `@' symbol is another thing i'm not really happy with ..)
17:40:03 <Maxdamantus> Wouldn't the "@a" part there be the "forall"?
17:40:06 <rotaerk> is there a better abstraction for reading files than streaming?
17:40:37 <rotaerk> streaming just seems limiting, since reading files sometimes benefits from jumping around, rather than simply reading the bytes top to bottom
17:40:43 <rotaerk> at the very least, knowing the size is useful
17:41:02 <Maxdamantus> rather, not quite the forall, but the value used as the universally quantified variable.
17:42:00 <Solonarv> yes, these "type patterns" would correspong to forall-bound tyvars in that function's type
17:42:11 <rotaerk> (I'm asking about something more combinatorial and pure than all the System.IO stuff)
17:42:15 <Maxdamantus> `blah :: (a :: Type) -> ..; blah @a .. = ..`
17:42:27 <Solonarv> that's not legal haskell, actually
17:42:53 <Solonarv> when it is (with dependent haskell) you won't need the @ IIRC
17:43:15 <ski> (also, when i think about pattern ascriptions, i'm recurringly wondering why one can't ascribe the definiendum with a type in function bindings (pattern bindings like in `x :: Int = ...' is fine))
17:43:16 <Maxdamantus> Right, the type signature there would use "forall a." instead of "(a :: Type) ->", but they logically express the same thing.
17:43:55 <Solonarv> not quite
17:44:00 <Maxdamantus> (assuming `a` is a type in either case (as opposed to some other type-level thing))
17:44:21 <Solonarv> with (a :: Type) -> you would have to also explicitly provide the type when calling that function
17:45:10 <Maxdamantus> Sure.
17:45:37 <Solonarv> you can think of the '@' of type applications as a visibility override: quantified-over types are passed implicitly/invisibly, but @ allows you to pass them explicitly/visibly
17:45:40 <Maxdamantus> Anyway, my original point is that you wouldn't have an extra "forall"
17:46:15 <Maxdamantus> at least, not in the definition part. imo Haskell should probably have required it in the signature anyway.
17:46:34 <ski> i'm not sure what you mean with "extra" there
17:47:11 <Maxdamantus> id :: forall a. a -> a; id @a v = v
17:47:42 <Solonarv> (note that according to the current DH plan, '(a :: Type) -> ...' will not be legal; you will have to write 'forall (a :: Type) -> ...' or 'foreach (a :: Type) -> ...' - at least as far as I know)
17:47:42 <ski> there is only one `forall' in there
17:47:58 <Maxdamantus> That's as many "forall"s that can reasonably be expressed there. There's no sense in having an extra "forall" in the definition.
17:48:22 <Maxdamantus> Since the definition is taking a particular type (and storing it in the variable `a`)
17:48:22 * ski still doesn't understand Maxdamantus' point
17:48:34 <Solonarv> to clarify: the example you gave is the syntax you want?
17:48:50 <Solonarv> if yes, good news! that's exactly the plan
17:49:05 <Maxdamantus> Solonarv: it's the most explicit syntax, in that there are no implicit foralls.
17:49:41 <Maxdamantus> was just responding to ski saying there should be a forall somewhere.
17:50:19 <ski> hm, did i say there should be a `forall' ?
17:51:03 <Maxdamantus> Oh nvm, I misunderstood your point.
17:51:18 <Maxdamantus> You want the same foralls that I want.
17:51:51 <Maxdamantus> anyway, need to work.
17:52:13 <ski> i want an explicit `forall' in the signature (whether occuring on the "top-level" of the type, or nested inside (higher-rank, say)) to never bring a tyvar into scope in associated defining equations
17:52:38 <Solonarv> How do you want tyvars brought into scope, then?
17:53:16 <ski> with that in mind, `id :: forall a. a -> a; id @a v = v' would have to be equivalent to say `id :: forall a. a -> a; id @b v = v', the tyvar in the defining equation being unrelated to the (explicitly scoped) tyvar in the signature
17:54:11 <Solonarv> through '@tyvar' patterns? that seems reasonable to me (once those are implemented)
17:54:26 <Welkin> mike tyson var
17:54:59 <ski> (so, if that's to be allowed, that `id @a v = v' would have to implicitly be `forall a. { id @a v = v }', a second implicit quantifier. just like `v' there is (or can be considered to be) implicitly quantified over that defining equation)
17:55:34 <Solonarv> So at some point after we get @tyvar patterns, 'forall tyvar' could stop bringing tyvar into scope
17:55:38 <pagnol> Anyone know a library for record matching and data deduplication?
17:56:09 <ski> Solonarv : well, the current (of ancient days) ways of implicitly bringing tyvars into scope in the signature is reasonable, imho
17:56:18 <Solonarv> actually, 'id @a v = v' should just infer as 'forall a0. a0 -> a0'
17:56:24 <Solonarv> I don't recall that ever being the case
17:56:37 <ski> but perhaps you were more wondering about bringing tyvars into scope in defining equations
17:57:11 <Solonarv> I was wondering how they should be brought into scope at all
17:57:15 <Solonarv> the current state is:
17:57:25 <ski> in `id :: a -> a',`a' is implicitly brought into scope (in the signature)
17:57:34 <Solonarv> it is? that's news to me!
17:57:44 <ski> there is no explicit binder
17:58:00 <pagnol> I wish there was something like python’s dedupe for Haskell 
17:58:28 <ski> i'm not saying it's implicitly brought into scope in the defining equations (by the signature). i'm saying it's implicitly brought into scope in the *signature* itself !
17:58:54 <Solonarv> yes, I know that's what you meant
17:59:09 <ski> so what's the news ?
17:59:25 <Solonarv> that the 'id :: a -> a' signature brings 'a' into scope at all
18:00:14 <ski> `a' is a variable, it doesn't exist outside this type signature. ergo, it must be brought into scope (implicitly or explicitly), in order for it to be allowed to refer to it, in the signature
18:00:46 <ski> the scope of `a' is the type signature (or more specifically, the part of it after the `::')
18:01:12 <Solonarv> let me be clearer: I'm surprised that the 'id :: a -> a' signature causes 'a' to be in scope in id's body
18:01:31 <ski> that's a different statement, which i didn't claim
18:01:53 <ski> (in fact, i tried to make it clearer that i didn't mean to claim that)
18:01:57 <Solonarv> oh! then we have been talking past each other for the past half-hour
18:02:53 <Welkin> lots fo talk about clams in here
18:04:38 <ski> what i was saying before was that i'd prefer it (i think) if `ScopedTypeVariables' (a) didn't make `a' in `blah :: forall a. ..a..' come into scope in the defining equations of `blah'; and (b) *did* make `a' refer to the same thing in `blah :: ..a..' (no explicit `forall' binder for `a') as in the defining equations for `blah' (for arguments sake, say it's `blah = ..a..')
18:05:18 <ski> *however*, i'm *not* saying that in the (b) case the type signature brings `a' into scope !
18:05:47 * Solonarv thinks
18:05:48 <ski> you could just as well say that the defining equation(s), by mentioning `a', brings `a' into scope in the type signature
18:06:00 <Solonarv> okay, I think I see what you mean
18:06:18 <Solonarv> in any case, not a change that should happen before we get @tyvar patterns
18:06:46 <ski> in the (b) case, we'd conceptually have an implicit `forall', which we could in pseudo-Haskell indicate as `forall a. { blah :: ..a..; blah = ..a.. }'
18:09:11 <ski> (compare with how say `True && x = x' can be conceptually thought of as `forall (x :: Bool). True && x = x')
18:13:27 <ski> anyway, one problem with `const :: forall a. forall b. a -> b -> a; const @a @b x y = x' (under my proposal) is that the `a' and `b' in the defining equation is unrelated to the `a' and `b' in the signature
18:14:10 <ski> and so we don't know a priori whether `x' or `y' is the input having type `a'
18:15:26 <Solonarv> huh? this is easily resolved by looking at the order of @-patterns / forall-binders
18:17:32 <ski> hmm .. ok, but what if there's three `forall's in the signature, but only two `@'s in the defining equation ?
18:17:54 <Solonarv> they match against the two outermost forall-bound tyvars, of course
18:17:56 <ski> which of them is implicit in the definition ?
18:18:19 <ski> not the two innermost, then ?
18:18:28 <Solonarv> no
18:18:42 <Solonarv> (this mirrors how TypeApplications works, btw)
18:19:01 <ski> (this is something which i recall from Agda1 would have been a lot more convenient, in many situations. innermost, i.e.)
18:19:44 <Solonarv> if you want to skip over outermost foralls you can use @_ (i.e. a wildcard)
18:20:11 <Solonarv> this is again how type applications work, and the patterns should mirror that behavior
18:20:17 <ski> yes, but it's still ugly to litter ones code with extra such annotations :)
18:21:07 <Solonarv> Ordering type variables is a similar problem to ordering function arguments (for partial application)
18:21:25 <ski> (yes, i'm also suggesting this may be a problem with type applications, and implicit arguments in Agda. however, i'm not completely sure whether what i want could be made completely coherent ..)
18:21:58 <Solonarv> the same solution could work for both: keyword/named arguments
18:22:42 <ski> perhaps i'm overstating it a bit in the Haskell case. but for dependent code, it's not just the argument ordering with partial application problem
18:23:17 <Solonarv> well, the dependent case is still relevant for haskell if we're talking about its future
18:23:27 <ski> in the dependent case, you typically are not allowed to place an argument before another one, in case the type of the former needs to refer to the value of the latter
18:23:55 <Solonarv> you mean, arguments can't be arbitrarily reordered?
18:24:03 <Solonarv> that makes sense
18:24:21 <ski> so it's not only the concern of which argument is deemed to more likely "be hold fixed, while the other vary", but also this type dependency issue/concern
18:24:24 <ski> yes
18:24:28 <Welkin> keyword arguments are realy nice sometimes
18:24:36 <Welkin> it's the lisp way to create programmable functions
18:24:47 <Solonarv> and in fact this restriction already rears its head in forall-binders: Proxy :: forall k (a :: k) . Proxy a; you can't re-order these tyvars
18:24:57 <Welkin> but it's not necessary when you can compose lots of smaller functions together or pass in a record instead
18:24:58 * ski nods
18:25:15 <Welkin> it's a choice of style
18:25:22 <ski> Welkin : needs lightweight records
18:25:25 <Welkin> now, anonymous records (or named tuples) are really nice
18:25:38 <Solonarv> the annoying thing about records is now I need to define a separate type for my function's arguments
18:25:49 * ski also wants lightweight ("anonymous", if you prefer) variants
18:25:51 <Welkin> that's why: anonymous records/named tuples
18:25:57 <Solonarv> yup
18:26:00 <Solonarv> those would be really nice
18:26:05 <Welkin> elm has them :D
18:26:31 <Solonarv> Haskell has them too... as libraries, which makes them rather clunky.
18:26:50 <Welkin> a lot of things in haskell are clunky because they were bolted on (or libraries)
18:27:04 <Welkin> I really would like haskell to get a makeover; do some spring cleaning
18:27:15 <maerwald> why?
18:27:19 <ski> (i've also pondered a bit about "positional (light-weight) variants". they'd be to tuples, what (ordinary, named) variants are to (ordinary) records)
18:27:25 <Welkin> so it's a nicer/easier language to use
18:27:29 <maerwald> what do you mean with makeover
18:27:37 <maerwald> well, nicer/easier usually means removing features
18:27:46 <Solonarv> ski: we have those, but they're unboxed-only
18:27:50 <Welkin> integrate some of the extensions and clean up their syntax
18:27:59 <Welkin> and yes, reove features/simplify
18:28:02 <Welkin> remove*
18:28:05 <maerwald> That's what will it likely make more complicated and beginner hostile
18:28:13 <maerwald> And more expressive and useful for advanced programmers
18:28:16 * ski . o O ( `case ... of (x||) -> ..x..; (|y|) -> ..y..; (||z) -> ..z..' )
18:28:35 <Solonarv> if you add # on the inside of the parens that's legal haskell
18:28:40 <Solonarv> (with the UnboxedSums extension)
18:28:57 <ski> Solonarv : hm, i don't recall seeing that extension
18:29:25 <ski> since 8.2.1, ok
18:29:46 <Solonarv> % case (# || 5 #) :: (# Bool | Char | Int #) of (# || y #) -> print y; _ -> putStrLn "wha!?"
18:29:46 <yahb> Solonarv: ; <interactive>:42:50: error: Parse error in pattern: || y
18:29:53 <Solonarv> % case (# || 5 #) :: (# Bool | Char | Int #) of (# | | y #) -> print y; _ -> putStrLn "wha!?"
18:29:54 <yahb> Solonarv: ; <interactive>:43:9: error: A section must be enclosed in parentheses thus: (|| 5)
18:30:03 <Solonarv> huh? let me check the docs...
18:31:01 <Solonarv> % case (# | | 5 #) :: (# Bool | Char | Int #) of (# | | y #) -> print y; _ -> putStrLn "wha!?"
18:31:02 <yahb> Solonarv: 5
18:31:06 <Solonarv> hah!
18:31:16 <Solonarv> (need to separate the | 's)
18:33:44 <ski> Solonarv : i wonder whether this is implemented with a tag, or by selecting one of several alternative return paths
18:34:23 <Solonarv> it's a tagged union much like "normal" sum types
18:34:35 <ski> ok, too bad
18:34:43 <Solonarv> you can read about the representation in the ghc manual
18:34:44 <ski> still nice, though
18:35:15 * ski now recalls they didn't finish digesting the join point paper
18:40:18 <Welkin> I imagine ski chewing on the paper like a horse
18:40:27 <Welkin> or a llama
18:41:34 <Solonarv> now I'm imagining a goat chewing on academic papers
18:42:39 <monochrom> Doraemon had a "study bread".  You press a slice of study bread on a page, each the bread, then you automagically learn what's on that page.  Or maybe rote-memorize, I don't know.  (What's the difference in the context of most public education systems anyway?)
18:43:09 <monochrom> Yikes, s/each the bread/eat the bread/
18:43:51 <Solonarv> bread & each %%~ eat
18:44:08 <monochrom> On, lens saves the day!
18:44:40 <monochrom> lens is the best thing since sliced bread!
18:44:44 <Solonarv> now I'm thinking of that one post
18:45:03 <Solonarv> "A wild ed kmett appears! He s t a b s you with a Lens!"
18:45:50 <Welkin> it's super effective!
18:47:05 <ski> @quote s.t.a.b
18:47:06 <lambdabot> byorgey says: <edwardk> @type (^.) <lambdabot> s -> Getting a s t a b -> a <byorgey> I would not like to be getting a stab, thank you
18:47:40 <Solonarv> dangit, where is that post
18:50:25 <monochrom> Programming with dungeons and dragons and NPCs and lens.
18:51:34 <Welkin> I think you mean pokemon
18:52:08 <monochrom> I'm open to that!
18:56:28 * ski realizes "pokemon" sounds a little like a "monitor" you'd type in in BASIC (with `POKE's) from some magazine/book, in order to get a nicer interactor for doing assembly
18:57:34 <Welkin> like nodemon? and osmon?
18:59:25 <monochrom> MON = &F0F1 : RULES = &3E : POKE MON, COOL
19:04:05 <benzrf> no demon
19:04:19 <Welkin> daemon
19:04:31 <Welkin> which I pronounce like Matt Damon
19:04:44 <Welkin> but greybeards call it a demon
19:05:07 <maerwald> because you can't kill it
19:05:33 <Welkin> bsd has it's own little demon
19:05:48 <benzrf> https://www.youtube.com/watch?v=bFdzA2wI6c0
19:09:20 <nshepperd1> The unkillable matt daemon
19:10:24 <ski> i don't know those ("nodemon" appears to be something related to node.js ?). i had stuff like <https://www.c64-wiki.com/wiki/Machine_Code_Monitor>,<https://en.wikipedia.org/wiki/Machine_code_monitor> in mind (but also, i suppose, joke stuff like <https://csdb.dk/release/?id=12612>)
19:15:07 * hackage asif 4.1.0 - Library for creating and querying segmented feeds  https://hackage.haskell.org/package/asif-4.1.0 (arbornetworks)
19:20:53 <Welkin> you forgot anothermon
19:20:56 <Welkin> mongoose!!!!
19:21:36 <Welkin> ski: os_mon is an erlang thing
19:28:04 <ski> ok
19:34:26 <geekosaur> aieeeee... (my first computer had such. it sucked. especially since I ended up having to use it to hand enter a bugfix for its BASIC until I got the cassette drive working)
20:57:37 * hackage servant-waargonaut 0.6.0.0 - Servant Integration for Waargonaut JSON Package  https://hackage.haskell.org/package/servant-waargonaut-0.6.0.0 (schalmers)
21:13:35 <nfd> https://osa1.net/posts/2017-10-16-a-parallel-scheduler.html in here I see reference to utility functions on and comparing
21:13:48 <nfd> anybody know where exactly those live?
21:13:51 <ski> @index on
21:13:52 <lambdabot> Data.Function
21:13:52 <ski> @index comparing
21:13:52 <lambdabot> Data.Ord, Distribution.Simple.Utils
21:14:11 <nfd> ah, that's handy!
21:14:12 <nfd> thanks
21:14:22 <nfd> frustratingly ungooglable names :D
21:14:29 <osa1> nfd: there's also a link at the bottom of the page for the full source code :)
21:14:37 <osa1> nfd: https://gist.github.com/osa1/e7416f6a0f299f88f275bb8d56a31da3
21:16:05 <ski> i also sometimes define `equating :: Eq b => (a -> b) -> (a -> a -> Bool); equating f = (==) `on` f', for use with e.g. `groupBy'
21:16:07 <nfd> would've only done me so much good looking for those utility functions
21:16:42 <nfd> makes sense!
21:21:07 <osa1> nfd: well if you get the full source you can load it into ghci (maybe with `stack repl`) and then do `:info on`
21:21:33 <nfd> while i'm at it, are y'all aware of anyone trying to make a passably not-insane work-stealing scheduler in haskell?
21:21:48 <nfd> osa1: also good to know, thanks
21:22:40 <unyu> Is my scrollback deceiving me, or I saw a snippet that looks like OCaml's polymorphic variants?
21:23:08 * hackage shh 0.2.0.2 - Simple shell scripting from Haskell  https://hackage.haskell.org/package/shh-0.2.0.2 (lukec)
21:27:17 <nfd> unyu: probably just you? do you mean `on`?
21:27:37 <unyu> nfd: I mean the (# ... #) thingy.
21:28:00 <ski> unyu : <https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html#unboxed-sums> ?
21:28:13 <unyu> Wait, checking.
21:28:21 <nfd> all of those joins distracted me, hah
21:28:30 <ski> no row variables, though, afaics
21:29:04 <nfd> looks like so, actually. ski talking about positional variants
21:29:09 <nfd> UnboxedSums
21:29:42 <nfd> unyu: yeah, they were talking UnboxedSums
22:13:37 * hackage skylighting-core 0.7.7 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-core-0.7.7 (JohnMacFarlane)
22:14:37 * hackage skylighting 0.7.7 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-0.7.7 (JohnMacFarlane)
23:53:32 <PragCypher> Morning, is anyone familiar with the Turtle package's Pattern matching?  I'm having a hard time trying to figure out how to combine patterns.
23:54:24 <PragCypher> Something simple like 'prefix "<a " <> text "href="` matching '<a href='
23:59:46 <gentauro> how do you (type-safely) parse `json` where a a field (in this case `location`) varies for each element in the array (index 0 element has a lot of fields, index 1 has only `precipitation` and `symbol` besides `lat,lon,alt` and index 2 only has `lat,lon,alt`). Is it even possible :|
