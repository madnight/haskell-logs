00:45:17 * hackage gtk 0.15.2 - Binding to the Gtk+ graphical user interface library.  https://hackage.haskell.org/package/gtk-0.15.2 (HamishMackenzie)
01:03:29 <reygoch> So, I've added the source-repository-package pragma to my cabal file but it does nothing. Am I wrong in understanding that it would fetch the source from git and build a local version that I can use in my cabal project?
01:04:46 <reygoch> Stack has the ability to add a git repo instead of a package from hackage. Is there no such feature in cabal?
01:05:13 <hvr> reygoch: have you done it like in https://github.com/haskell-CI/hackage-matrix-builder/blob/master/src-ui.v3/cabal.project ?
01:05:45 <hvr> also, do you have a recent enough cabal version? i.e. cabal 2.4.1
01:05:49 <reygoch> yes, although I've added mine to my cabal file
01:06:06 <reygoch> and I have 2.4.1 cabal
01:06:29 <hvr> reygoch: ok, you need to add it to the cabal.project file; adding it to the .cabal file as an advertising purpose
01:06:52 <hvr> it's the cabal.project file that defines the "routing", i.e. where packages are procured from
01:07:35 <reygoch> hvr: Ok, thanks. I was expecting a warning from cabal on that matter. Do I have to add this package to my build-depends list?
01:07:57 <hvr> yes, you still need to specify which components depend on it
01:08:18 <reygoch> Ok, thanks. Also, thanks for the PPA :D
01:08:31 <hvr> reygoch: I assume you know the docs at https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html ?
01:08:41 <reygoch> Yes, I was reading them
01:08:57 <reygoch> hvr: but it wasn't clear that this should be added to the .project file
01:21:40 <hvr> reygoch: ...is it working now?
01:21:53 <reygoch> yes, just finished compiling successfully
01:22:02 <reygoch> thanks a bunch
01:23:50 <hvr> you're welcome :)
02:30:03 <EbohW6oo> Survey: how do you name a function that updates a boolean value, and how do you name the argument that represents the value to be set? E.g. enable + disable in one function = ???
02:33:07 <sicklorkin> Is there a reason why State.modify `(s -> s) -> m ()` doesn't return `s`? Is `get` free as in no runtime cost?
02:35:18 <sicklorkin> actually there's `state` does `modify` and returns `a` which 
02:36:20 <sicklorkin> s/which/in which case you don't need to call gets
03:13:27 <aveltras> hi, anyone could show me how i can specify that my package needs postgresql as a native dependency with a default.nix like this one https://gist.github.com/aveltras/a0df5d41b83e1a0c605551ed27d12db0 ?
03:55:19 <gotError> hi, i wanted to time how long it takes to insert 5000 comments inside a yesod handler and print the result. the comments are inserted but the time is wrong (it says "comments inserted in 0.753840908" when it should be ca. 5s) https://pastebin.com/FvCmys8T
03:57:03 <gotError> stuck on it for a while now, no idea how to debug it. my best guess is it has something to do with the "strictness" of the timed operation
04:01:36 <[exa]> gotError: depends on how lazy the whole thing is. Perhaps generating the description of what should be inserted (ie thunks) takes .75s, and the rest of the time is burn somewhere else (eg converting of the inserted stuff to strings somewhere else in the pipeline)
04:16:37 <cocreature> [exa]: laziness doesn’t matter here. inserting the description in the db will certainly force it
04:17:48 <cocreature> gotError: looks fine to me, what makes you think it should take 5s?
04:18:12 <gotError> cocreature, the actual time to load the page and the debug output from yesod
04:19:02 <gotError> from 09/Feb/2019:13:17:07 +0100 [Debug#SQL] INSERT INTO "comment"("message","user_id") VALUES(?,?); [PersistText "test5000",PersistNull]
04:19:09 <gotError> to 09/Feb/2019:13:17:12 +0100 [Debug#SQL] SELECT "id" FROM "comment" WHERE _ROWID_=last_insert_rowid(); []
04:19:56 <cocreature> where is the select coming from? that doesn’t seem to be in your benchmark
04:20:24 <gotError> it seems yesod does both an insert and then a select for the id for each insert of a comment
04:20:41 <gotError> like this
04:20:41 <gotError> 09/Feb/2019:13:17:07 +0100 [Debug#SQL] INSERT INTO "comment"("message","user_id") VALUES(?,?); [PersistText "test4997",PersistNull]
04:20:41 <gotError> 09/Feb/2019:13:17:07 +0100 [Debug#SQL] SELECT "id" FROM "comment" WHERE _ROWID_=last_insert_rowid(); []
04:21:11 <cocreature> oh I guess it uses the select to return the id
04:22:51 <cocreature> is that from the same program execution or did you do the benchmark with different options, e.g., no debug output?
04:23:32 <gotError> this is still from the same run/page load, i dont know how to disable the sql debug output
04:23:51 <cocreature> maybe the logging in yesod is asynchronous?
04:24:31 <cocreature> I’d be more tempted to distrust the times in some debug logging output than the ones measured by timeIt
04:26:22 <gotError> i will try to time a call to system "sleep 1" so we know for sure if the measurement is wrong
04:31:20 <gotError> cocreature, now it says "it took 2.64639e-4s" https://pastebin.com/UJiTGu3N
04:31:28 <gotError> when it should be 3s
04:32:24 <cocreature> gotError: runCommand doesn’t wait for the process to exit
04:32:32 <gotError> oh
04:32:43 <cocreature> use threadDelay
04:32:51 <cocreature> also you probably want to use liftIO instead of hGet
04:33:24 <gotError> ah yes
04:36:48 <gotError> cocreature, ok with threadDelay it still says it took 5.852496e-3s when it should be 3s
04:36:51 <gotError> https://pastebin.com/wxKspM1c
04:37:34 <gotError> there is no log output generated now
04:38:06 <gotError> other than the usual at the end of the request saying that it took 3s
04:42:32 <cocreature> gotError: oh I think I see what’s going on. timeIt measures the number of cpu seconds you use. that’s not going to be useful for things that aren’t cpu bound such as your first example which is IO bound or threadDelay which isn’t a busy loop either
04:44:22 <gotError> cocreature, that could be it, what else can i use?
04:46:05 <cocreature> gotError: https://gist.github.com/cocreature/a7d3f5aeeaf169bf075cb279405feea5 should do the job
04:46:36 <cocreature> also merijn might want to make this more clear in the docs of timeit :)
04:49:43 <gotError> cocreature, now it says 5.3s for 5k comments, thanks man, youre awesome!
04:51:15 <cocreature> I guess I was wrong in distrusting the debug log, timeit is seriously confusing :)
04:56:49 <elgoosy> hi, given two sound samples i want to compare to some degree if they are similar. Is there some library someone could suggest?
05:13:17 <gotError> elgoosy, i found "libfooid"
05:13:27 <gobby> Hey guys, is there a way to check this equality? 45e15 == (1 + 45e15)
05:13:34 <gobby> ghci says True when it obviously isnt
05:15:33 <lyxia> > 45e15
05:15:36 <lambdabot>  4.5e16
05:15:46 <lyxia> > 1 + 45e15
05:15:48 <lambdabot>  4.5e16
05:16:05 <lyxia> floating point does not have arbitrary precision
05:17:48 <lyxia> you have 53 bits of precision, which is about 15 digits, so for a number as big as 4.5e16 the precision doesn't reach the units digit.
05:18:07 <lyxia> (by "digits" I meant decimal digits)
05:18:50 <merijn> cocreature: I've been meaning to update it so it does both CPU time and wall clock time, because the CPU timing tripped me up to
05:18:54 <merijn> cocreature: I blame Lennart!
05:19:13 <Ariakenom> gobby: you have to use the type Integer
05:19:29 <Ariakenom> % 45e15
05:19:30 <yahb> Ariakenom: 4.5e16
05:19:34 <Ariakenom> % 45e15 :: Integer
05:19:34 <yahb> Ariakenom: ; <interactive>:19:1: error:; * No instance for (Fractional Integer) arising from the literal `45e15'; * In the expression: 45e15 :: Integer; In an equation for `it': it = 45e15 :: Integer
05:19:44 <merijn> cocreature: But it's somewhere low in the queue of things to do
05:19:51 <Solonarv> gobby: or more generally, a more precise type than the default Double
05:19:55 <lyxia> % 45 * 10^15
05:19:55 <yahb> lyxia: 45000000000000000
05:19:58 <gentauro> % let foo = 42 in foo
05:19:59 <yahb> gentauro: 42
05:19:59 <merijn> Ariakenom: You need NumDecimals or whatever that extension was
05:20:08 <merijn> % :set -XNumDecimals
05:20:08 <yahb> merijn: 
05:20:12 <gentauro> % let foo = 42; bar = 42 = foo + bar
05:20:12 <yahb> gentauro: ; <interactive>:23:24: error:; parse error on input `='; Perhaps you need a 'let' in a 'do' block?; e.g. 'let x = 5' instead of 'x = 5'
05:20:18 <merijn> % 45e15 :: Integer
05:20:18 <yahb> merijn: 45000000000000000
05:20:34 <merijn> Anyhoo, time to run
05:20:37 <gentauro> % let foo = 42, bar = 42 = foo + bar
05:20:37 <yahb> gentauro: ; <interactive>:25:13: error: parse error on input `,'
05:20:37 <Ariakenom> merijn: yeah good timing I just went to the user guide to find the name of it
05:21:12 <gentauro> % let foo = 42; bar = 42 in foo + bar
05:21:12 <yahb> gentauro: 84
05:21:18 <gobby> even with NumDecimals you can't make the comparison
05:21:20 <Ariakenom> oh yeah just using Rational is better heh
05:23:18 <cocreature> merijn: fair enough, I’ll see if I might be able to convince myself to make a PR :)
05:23:46 <gentauro> % let true  = \ x y -> x; false = \ x y -> y; not  = \ p   -> p false true; or   = \ p q -> q true  p; nor  = \ p q -> not (or  p q) in \ p   -> nor p p
05:23:46 <yahb> gentauro: ; <interactive>:27:150: error:; * Occurs check: cannot construct the infinite type: t ~ (p1 -> p0 -> p1) -> t -> (p2 -> p3 -> p3) -> (p5 -> p4 -> p5) -> t1; * In the second argument of `nor', namely `p'; In the expression: nor p p; In the expression: \ p -> nor p p; * Relevant bindings include; p :: t (bound at <interactive>:27:137); it :: t -> t1 (bound at <interac
05:25:08 <gentauro> is there a way to write a `typed or` in Haskell by using `nor logic`?
05:27:23 <Ariakenom> gobby: add a type signature
05:27:39 <gobby> Ariakenom: Thanks i=I already did
05:27:42 <Ariakenom> % 45e15 == (1 + 45e15 :: Rational)
05:27:42 <yahb> Ariakenom: False
05:28:09 <Solonarv> % (==) @Rational 45e15 (1+45e15)
05:28:09 <yahb> Solonarv: False
05:36:17 <gobby> Ariakenom: Can't I just use Integer?
05:36:51 <gobby>  (fromIntegral myLargeNumber :: Integer) === 45e15
05:37:42 <Solonarv> gobby: 45e15 isn't a valid Integer literal normally
05:37:55 <Solonarv> (but it is with the NumDecimals extension)
05:38:14 <gobby> ohhh
05:38:39 <gotError> gobby, it works with regular notation: 45000000000000000 == 1 + 45000000000000000
05:39:00 <gobby> gotError: gotcha
06:02:56 <ahri> I'm writing a script to be run with "stack script" and also possibly compiled, I want to know what directory the script/executable is in. I can use `System.Environment.getExecutablePath` in the compiled case, but in the script case I'll get the stack binary path - how can I get the full path to the script being executed?
06:46:23 <ion> ahri: What do getProgName and getArgs return?
06:48:04 <ahri> "shake.hs" and [], respectively, while getExecutablePath gives a full path to GHC
06:48:52 <ahri> getProgName is giving me what I want, but without a relative path to get to that filename It's not helpful for my case
06:49:00 <ion> aww
06:49:56 <ion> Yeah, it's calling basename: https://www.stackage.org/haddock/lts-13.6/base-4.12.0.0/src/System-Environment.html#getProgName
06:51:10 <Gurkenglas> If you're trying to copy the file contents elsewhere for fun, try making your script a quine :)
06:51:38 <ahri> I suppose I can re-implement getProgName
06:52:21 <ahri> Gurkenglas: heh, really all I need is the dir the script is in - it's often useful for build scripts to know where they are and to act on files relative to them
06:54:05 <ion> ahri: https://hackage.haskell.org/package/system-argv0
07:00:15 <ahri> ion: thanks, that saves me redoing the C FFI stuff!
07:01:38 <ahri> ugh... executing `./dotfiles/shake.hs` gives me `FilePath "shake.hs"` as output using `getArgv0` :(
07:03:17 <ion> :-(
07:03:45 <ion> Is this on Linux?
07:08:05 <ahri> yep, although I will need to test on Windows too
07:08:10 <ahri> https://hackage.haskell.org/package/executable-path-0.0.3.1/docs/System-Environment-Executable.html#v:getScriptPath seems to work
07:08:32 <ahri> I like the way the docs call it an "experimental hack" :)
07:10:51 <ahri> there's also https://hackage.haskell.org/package/FindBin - I guess I'll take a peek at the src and pick one, although the final decision will be whether it works cross platform I suppose!
07:20:59 <sm> nice
07:23:21 <WilliamHamilton[> zv: hey! I found your username googling "z3 smt sat irc channel" and this is a quote from you "i'll talk anyones ear off about the topic, no matter their level of interest". I have some questions, when you are around :D
07:24:32 <ahri> lol, so much for the right to be forgotten eh?
07:25:06 <WilliamHamilton[> hehe!
07:25:54 <WilliamHamilton[> my assumption here is that the interest hasn't vanished from last year
07:27:20 <WilliamHamilton[> zv: topic: I'm writing a generic (like in generic-programming) wrapper around the z3 api, and I'm not quite sure of what the practical limits of z3 are in the theory of datatypes, but I don't know where to ask
07:44:37 <dmwit> WilliamHamilton[: Have you looked at sbv? It's pretty idiomatic and covers a lot (although certainly not all) of what z3 can do.
07:45:29 <dmwit> ...sometimes frustratingly so. I remember filing a bug about something, and Levent telling me that the version of z3 I had -- which was, I'd like to point out, the most recent release they had made -- was "way too old". =D
07:45:40 <WilliamHamilton[> dmwit: yes, I looked at sbv, and what i want to do is unfortunately in the realm of what is difficult for sbv (see https://github.com/LeventErkok/sbv/issues/447 )
07:47:19 <WilliamHamilton[> dmwit: basically I'm more interested in what z3 could do for the theory of datatypes, and my use case is not too much different from what a basic prolog could do (except with conflict driven clause learning)
07:58:13 <dmwit> A lot of reading there.
07:58:32 <dmwit> Still haven't made it all the way through, but I think I've made it far enough to know I won't be much help. =)
08:00:06 <WilliamHamilton[> dmwit: props for reading! No problem, thanks!
08:11:09 <reactormonk> Is there a "all ok" from ghcid if it succeeds in building?
08:12:04 <aplainzetakind> reactormonk: All Good
08:12:20 <aplainzetakind> s/Good/good/
08:22:47 * hackage oset 0.4.0.1 - An insertion-order-preserving set  https://hackage.haskell.org/package/oset-0.4.0.1 (rcook)
08:45:20 <dmwit> Five versions in two days! wow
08:45:39 <dmwit> Nope, I can't read. It's five versions in five days. But still, wow.
08:50:21 <lyxia> that's an... interesting release strategy
09:00:40 <o1lo01ol1o> Can anyone here point me to an example of the the coq equivalent of the "type-indexed GADT" in haskell?  I've seen this before but now can't find any examples of the syntax.
09:06:54 <lyxia> Inductive foo : Type -> Type := Foo : foo nat.
09:28:40 <Mrbuck> which is more strongly types language than haskell or close to haskell other than idris
09:28:47 <o1lo01ol1o> lyxia:  huh.  that has quite a bit less ceremony than I thought.  
09:29:25 <Solonarv> Mrbuck: coq, agda
09:29:35 <Solonarv> are the ones I can think of right away
09:31:15 <Mrbuck> Solonarv:  c++ can even come close?
09:31:51 <Solonarv> ehhh
09:32:22 <Solonarv> c++ can imitate some things, because templates are eldritch gods squeezed into digital form
09:32:37 <veverak> :D :D :D
09:32:57 <Mrbuck> ok thanks Solonarv 
10:19:11 <lukelau> Is there a way to stream the test results with stack when doing stack test? rather than getting them all at the end
10:23:48 <kadoban> lukelau: Probably depends more on the library you're using to write tests than it does on stack
10:24:12 <dminuoso> phadej: to . from is not enough though. I mean the fields are represented differently in generics, and the data constructor is different too.
10:24:32 <dminuoso> phadej: Or was your point regarding `to . from` just as the idea of `to . convert . from` with some suitable convert function?
10:26:06 <lyxia> dminuoso: this sounds like an interesting problem
10:32:09 <gentauro> RMS is such a baws -> (Expectations vs Reallity -> https://imgur.com/a/EUup1Bh xD
10:40:47 * hackage DBFunctor 0.1.1.0 - DBFunctor - Functional Data Management =>  ETL/ELT Data Processing in Haskell  https://hackage.haskell.org/package/DBFunctor-0.1.1.0 (nkarag)
10:48:21 <lukelau> kadoban: running the test individually with stack test :my-test streams it, but its when stack has multiple test targets  i.e. stack test it just displays a stub for each target
10:56:39 <maerwald> isn't there --jobs or something for tests?
10:57:17 * hackage wai-cli 0.2.1 - Command line runner for Wai apps (using Warp) with TLS, CGI, socket activation & graceful shutdown  https://hackage.haskell.org/package/wai-cli-0.2.1 (myfreeweb)
11:18:21 <phadej> dminuoso, lyxia: very boring problem: https://gist.github.com/phadej/f18cbab7c882242c4782149b1f8cd3d8
11:20:28 <phadej> the fields are represented in the same way, there are some phantom type-level stuff which you need to either coerce or do GHC.Generics dance
11:37:14 <Gurkenglas> Are there any programming games when one uses a Haskell?
11:40:10 <kritzefitz> What is the default fixity of an infixed function (i.e. `f`) when no fixity has been declared?
11:40:34 <glguy> infixl 9
11:40:52 <kritzefitz> Thaanks
11:43:45 <glguy> kritzefitz: That's default for any operator whether it's an operator symbol or backticked identifier
11:44:18 <kritzefitz> Yes, I just found the relevant port of the Haskell2010 report.
11:50:28 <sm> Gurkenglas: how do you mean ?
11:50:58 <sm> like https://www.codingame.com/multiplayer/clashofcode ?
11:56:05 <Gurkenglas> sm, https://tvtropes.org/pmwiki/pmwiki.php/Main/ProgrammingGame
11:59:09 <sm> ah. I'm surprised that's considered a TV trope
11:59:58 <sm> some of the advent of code puzzles have this kind of flavour (eg this year's mine carts)
12:01:43 <sm> oh yes.. codingame has a bot programming category. I did some of https://www.codingame.com/multiplayer/bot-programming/coders-strike-back in haskell
12:05:06 <Welkin> won't load for me without enabling all kinds of google apis
12:30:17 * hackage floskell 0.9.0 - A flexible Haskell source code pretty printer  https://hackage.haskell.org/package/floskell-0.9.0 (ecramer)
12:50:17 * hackage generic-deriving 1.12.3 - Generic programming library for generalised deriving.  https://hackage.haskell.org/package/generic-deriving-1.12.3 (ryanglscott)
13:58:46 * hackage record-dot-preprocessor 0.1.5 - Preprocessor to allow record.field syntax  https://hackage.haskell.org/package/record-dot-preprocessor-0.1.5 (NeilMitchell)
14:06:54 <tsaka__> I'm getting stackoverflow, on a recusrive function, I think, while attempting to solve Project Euler #92: https://paste.ofcode.org/dVn7SFGc92CdMNECh6VhnA
14:07:02 <tsaka__> https://projecteuler.net/problem=92
14:07:37 <tsaka__> I'm not sure if the problem is the use of "foldr" (in solve) or the chainEnd function
14:07:54 <Welkin> post the exact error message
14:08:20 <Welkin> also yes, don't use foldr
14:08:21 <tsaka__> *** Exception: stack overflow
14:08:21 <Welkin> use folfl'
14:08:27 <Welkin> foldl'
14:08:31 <Welkin> strict foldl
14:08:38 <Welkin> otherwise you will accumulate too many thunks
14:12:00 <tsaka__> Welkin: still stack overflow with foldl'
14:18:20 <dmwit> tsaka__: Use foldl' *and* make your tuple strict (at least in its first argument).
14:18:34 <dmwit> tsaka__: Otherwise foldl' is just forcing the tuple constructor rather than the HashMap, as needed.
14:18:55 <dmwit> I suspect there are many other opportunities for improvement, too.
14:25:35 <suzu> where in wai/warp/servant do handlers that throw excs get caught with the "Something went wrong" response body?
14:26:11 <dmwit> tsaka__: e.g. you don't need to store anything over 567 in your HashMap, because all numbers bigger than 567 drop to 567 or less in one step, so memoizing that one step is wasted effort.
14:26:36 <dmwit> Sorry, all numbers between 567 and 9999999, I mean.
14:28:42 <tsaka__> dmwit: which tuple(s) where to make strict?
14:29:10 <dmwit> The tuple returned by the function you pass to foldl'.
14:30:30 <dmwit> After that fix it runs out of heap instead of stack. ;-)
14:31:24 <tsaka__> dmwit: yes, it crashes still with that fix, but w/o error message
14:31:57 <tsaka__> this is the code after the fixes: https://paste.ofcode.org/999FBB6KfytnQCxTyudTqj
14:32:11 <tsaka__> the 567 trick notwithstanding, that's kinda cheating
14:32:27 <Welkin> project euler is about math
14:32:30 <Welkin> not brute force
14:32:35 <Welkin> so dmwit is right
14:32:37 <dmwit> Cheating?
14:33:00 <dmwit> I can confirm that the code finishes (after several minutes) if you incorporate my third proposed change (the one you call cheating).
14:33:22 <dmwit> It's almost certainly possible to improve further, too.
14:36:37 <suzu> so i wish to begone with this ServantErr thing and catch my own exceptions and respond with http error codes and such
14:36:50 <suzu> where in the stack would i catch?
14:37:01 <suzu> i'd like to catch at a level where i can access the Request
14:37:39 <Welkin> ServantErr is just the Left of the Either
14:37:44 <suzu> right
14:37:48 <Welkin> no, the left
14:37:55 <dmwit> 2predictable
14:37:59 <suzu> hehe
14:38:01 <suzu> i walked into that
14:38:06 <suzu> correct, it is the left
14:38:30 <suzu> and a Handler is IO (Either ServantErr r)
14:39:00 <Welkin> you will know if something has gone wrong and you can use err404 or whatever to specify the error status code and message
14:39:16 <suzu> right, and this bubbles up to servant
14:39:22 <suzu> but i wish to log the request at this time
14:39:26 <suzu> and handlers don't get access to that
14:39:37 <Welkin> use a middleware logger
14:40:12 <monochrom> The intended correct solutions to all PE problems are clever formulas derived from math and takes at most linear time (even constant time in some cases).  Note that linear time means O(lg n) because number of bits in n.
14:40:32 <suzu> i can do that, but i wish for the middleware logger to have some more information about when this problem occurred
14:40:38 <Welkin> servant places restrictions on what you can do. If you want full freedom to do anything, use scotty (or wai), or make your endpoint a raw endpoint
14:40:41 <dmwit> tsaka__: Deforesting next makes it about twice as fast, too.
14:40:56 <suzu> so, i was thinking of just throwing a custom exception up the chain
14:41:12 <suzu> but servant will steal it away from me and respond with "Something went wrong"
14:41:26 <Welkin> what went wrong?
14:41:44 <suzu> if you throw an exception instead of providing an Either value, that is what servant does
14:41:49 <suzu> it 500s with that response bodhy
14:41:50 <Welkin> oh
14:41:54 <Welkin> catch your exceptions then
14:41:59 <suzu> right -- but where?
14:42:01 <Welkin> are you using postgresql-simple or something?
14:42:04 <suzu> no
14:42:07 <Welkin> that throws exceptions
14:42:14 <Welkin> figure out which libraries throw exceptions
14:42:23 <suzu> nono /i/ am going to throw an exception
14:42:28 <Welkin> why?
14:42:35 <Welkin> what's the point?
14:42:36 <monochrom> If you're looking for must-brute-force problems so you can't "cheat", look for PSPACE-complete problems, not PE problems.
14:42:41 <suzu> so that i have some custom information about what went wrong
14:42:49 <suzu> so i can log that, at the same time as giving the 400
14:42:57 <suzu> and i'd like the request too
14:43:00 <Welkin> you'll have the request in your log
14:43:04 <Welkin> and your response
14:43:16 <suzu> yes, but nothing else
14:43:20 <Welkin> you can search your logs later for 404/400 whateevr
14:43:50 <Welkin> 400 means that the input is bad
14:43:53 <Welkin> it's not a server error
14:43:55 <suzu> yes
14:44:01 <Welkin> so look at the request
14:44:03 <suzu> i am deliberately giving the user a 400
14:44:24 <suzu> as i do so, i wish to log the request, and also some other information that occurred at the time
14:44:41 <Welkin> I don't understand
14:44:48 <suzu> sorry
14:44:52 <Welkin> you can put whatever information you need in the ServantErr
14:45:26 <suzu> no i canont
14:45:29 <suzu> cannot *
14:45:31 <Welkin> https://hackage.haskell.org/package/servant-server-0.15/docs/Servant-Server-Internal-ServantErr.html#t:ServantErr
14:45:59 <suzu> i can't, say, log the userid that made this request, with just a servanterr
14:46:09 <Welkin> okay
14:46:18 <Welkin> then add WriterT to your App type
14:46:20 <Welkin> and write to that
14:46:29 <Welkin> with the timestamp
14:46:30 <Welkin> easy enough
14:46:47 <Welkin> or rather a logger type
14:46:54 <suzu> oh hmm
14:47:18 <suzu> yeah i could add a logger to my apphandler type
14:47:33 <dmwit> tsaka__: FWIW, compiling with -O2 lets even the "non-cheating" version finish with only about 2GB max residency in about 20s, which is more than enough performance to consider your solution a success for PE.
14:47:50 <suzu> is there any way to get the request in there at the same time, Welkin ?
14:48:14 <suzu> could i get the middleware to pass it down?
14:48:18 <suzu> or can i pass it up to the middleware..?
14:49:09 <Welkin> your transformer stack is gone by the time the middleware gets to it
14:49:27 <suzu> right. hence i was thinking of maybe tossing custom exceptions up there
14:49:43 <Welkin> you should ask in #servant
14:49:54 <suzu> oh, i did but it's not active atm
14:51:50 <dmwit> I think your question is on-topic here (though note that this is logically unrelated to whether it's been answered in another forum or not).
15:37:17 * hackage skylighting-core 0.7.6 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-core-0.7.6 (JohnMacFarlane)
15:38:16 * hackage skylighting 0.7.6 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-0.7.6 (JohnMacFarlane)
16:24:50 <zachk> I don't know if this is the correct place to ask, but, any recommendations on a first computer programming language for someone who is about 10 and good at math? 
16:25:47 <Solonarv> I seem to recall a vaguely Haskell-inspired language pretty much meant for this situation
16:26:07 <c_wraith> honestly, most people at age 10 are inspired by being able to make something game-like
16:27:50 <c_wraith> You can get something game-like in Haskell (and even on the web) at https://code.world/ 
16:28:30 <c_wraith> Though it's Haskell with a very idiosyncratic default library
16:30:16 <hpc> zachk: there's minecraft mods with lua scripting and turtle blocks
16:31:25 <Solonarv> c_wraith: as a former 10yo I wholeheartedly agree
16:31:39 <hpc> my first language was TI-basic on their graphing calculators - schools tend to make you buy those anyway, maybe get one early
16:32:02 <hpc> and they can program in solutions to what they learn in math
16:32:16 <zachk> my first language was ti-basic on a ti home computer, back in the 80's 
16:32:50 <zachk> it was very accessible with the manuals and was easy to do simple graphics with 
16:33:32 <iqubic> My first Language was Scratch, that block based language made by MIT.
16:33:53 <iqubic> And then I went straight from there to Java. That was a large step up in complexity.
16:34:22 <c_wraith> Scratch isn't a bad first choice either.  Especially since the most recent version drops the flash dependency
16:34:45 <zachk> isn't scratch graphical with blocks?
16:34:50 <iqubic> So codeworld takes main and renames it to program behind the scenes.
16:34:55 <iqubic> zachk: Yes.
16:35:12 <c_wraith> You can just think of that as a constructive type system.
16:35:42 <c_wraith> When I played with Scratch, it felt like a souped-up Logo, which I appreciated.  Logo was so much fun when I was 8-10
16:35:42 <iqubic> Wait... Why does codeworld require parentheses at all?
16:35:53 <c_wraith> It doesn't, it just pretends it does
16:36:13 <jcob> My first language was visual basic, then c++, but I wish it were scheme
16:36:15 <c_wraith> because the author wanted to pretend it's not really Haskell
16:36:15 <iqubic> c_wraith: What do you mean by `pretends'?
16:36:16 <jcob> coz sicp is great
16:36:30 <iqubic> How do you do you pretend to have parens?
16:36:44 <c_wraith> iqubic: all the examples show parens, and the entire standard library is uncurried
16:37:00 <iqubic> What does that mean?
16:37:11 <c_wraith> :t uncurry (+)
16:37:13 <lambdabot> Num c => (c, c) -> c
16:37:27 <jcob> iqubic: you know what curried is right
16:37:52 <iqubic> sure... But how does that work with one argument functions?
16:38:16 <c_wraith> It doesn't
16:38:20 <jcob> uncurrying one argument functions? hwat
16:38:29 <iqubic> Oh, wait... The parens on a one argument function are pointless.
16:38:41 <iqubic> > not(True)
16:38:43 <lambdabot>  False
16:38:48 <jcob> ~~haskells syntax would be better if it were lisp style~~
16:39:10 <iqubic> c_wraith: I assume it workes something like that?
16:39:11 <c_wraith> codeworld shows warnings if you leave out redundant parens on one-argument functions
16:39:17 <c_wraith> but that's just the IDE
16:39:23 <c_wraith> It still works
16:41:00 <iqubic> And it gives type signatures like this: colored :: (Picture, Color) -> Picture
16:41:12 <c_wraith> right.  That's because it's not curried.
16:41:46 <c_wraith> > let f = uncurry (+) in f(3, 7)
16:41:48 <lambdabot>  10
16:41:58 <iqubic> I know. it just looks super weird and off-putting to me.
16:42:32 <c_wraith> apparently he did it because enough kids had seen javascript that they lost entire class periods to explaining why there weren't parens.
16:42:36 <jcob> ok yall i have a question. I've asked it before but I didn't understand the answer. Lets say you have one typeless final language and you want to use an expression of it in another typeless final language
16:42:39 <jcob> how do you do it
16:42:50 <c_wraith> And he eventually just wrote a new standard library to avoid that.
16:43:03 <jcob> using javascript to teach programming? good heavens
16:43:20 <c_wraith> No, using Haskell to teach programming to people who had taught themselves some javascript.
16:43:30 <c_wraith> Self-taught javascript is the worst.
16:43:37 <c_wraith> You won't even know what parts of it are terrible.
16:44:03 <jcob> idk is it worse than self taught C
16:44:12 <c_wraith> ...  You have a point.
16:44:15 <iqubic> c_wraith: I don't think it should be hard to understand that some languages have parens and some don't.
16:45:23 <c_wraith> iqubic: I'm just relaying what I recall of his reasoning.  I actually thought it was the wrong choice, and argued a bit about it.  But in the end, it's his project, made for his class.  He made the choice he thought was right, and well...  He did a hell of a lot of work, so I'm giving him credit for that and just shrugging at the parts I disagree with.
16:46:33 <zachk> jcob what do you mean by typeless final language? 
16:46:37 <c_wraith> jcob: as for your question - I've never actually used finally tagless, though I've read about it a few times.  Tell me if what I'm saying makes no sense at all.
16:46:43 <jcob> tagless final
16:46:50 <jcob> mb
16:46:55 <jcob> finally tagless
16:46:59 <jcob> im being dumb
16:47:25 <c_wraith> jcob: basically, the idea is that all the functions belong to classes.  When you combine functions from different systems, you just end up with a dependency on both classes.
16:47:43 <jcob> hmmm. So you're saying its impossible?
16:47:57 <jcob> or you have to declare dependency on both classes somehow?
16:48:01 <c_wraith> No.  You just need to write a new interpreter type that covers both classes
16:48:04 <c_wraith> yeah, that
16:48:38 <jcob> HUH!. so you make two seperate languages, and then just have interpreters that unify them
16:49:00 <c_wraith> Yeah.  A lot of the papers about it are about techniques for making that process as low-boilerplate as possible
16:50:09 <zachk> would ocaml work as the ml for benjamin pierce's TAPL?
16:51:19 <c_wraith> It should, though some adaptation might be required.
16:51:30 <c_wraith> It's a lot closer than Haskell
16:53:02 <zachk> would it be hard to translate the ml to haskell as I go, or would that increase the burden quite a bit?
16:56:14 <c_wraith> The different evaluation model will cause the occasional really subtle issue.  Probably not too often, but it might be really distracting
17:05:04 <slack1256> What are my options to study the haskell-threads present on my program?
17:05:16 <c_wraith> threadscope is really the only one worth mentioning
17:05:38 <slack1256> I thought that was just for parallel programs
17:05:59 <c_wraith> It works for forkIO concurrency, too
17:06:12 <slack1256> Oh, brb compiling
17:06:16 <monochrom> There is a reason it is not called "parallelscope".
17:06:49 <dmwit> You of all people should know that names cannot be trusted because they are made up by humans.
17:06:56 <monochrom> heh
17:08:03 <monochrom> But really no one is going to implement threadscope or anything that first analyzes "oh you have so many locks and contentions that your program ends up being sequential so I will just shut down now".
17:08:47 * hackage hedgehog-classes 0.1.0.0 - Hedgehog will eat your typeclass bugs  https://hackage.haskell.org/package/hedgehog-classes-0.1.0.0 (chessai)
17:10:43 <monochrom> You can't trust names but you can trust human laziness and the halting problem!
17:11:36 <dmwit> "I trust in laziness" seems like it would be a nice bumper sticker.
17:11:51 <mjrosenb> Does anyone know of an up-to date hsx tutorial, or codebase that I can look at?
17:29:16 * hackage diagrams-haddock 0.4.0.3 - Preprocessor for embedding diagrams in Haddock documentation  https://hackage.haskell.org/package/diagrams-haddock-0.4.0.3 (BrentYorgey)
17:29:47 <coldpress> is there a TH tutorial for dealing with gadtC and recGadtC constructors?
17:29:59 <glguy> For dealing with them in which way?
17:30:37 <glguy> This package is good for forgetting about them if you're interpretting them http://hackage.haskell.org/package/th-abstraction
17:34:01 <iqubic> Template Haskell is just confusing all around.
17:34:13 <benzrf> :t confusing
17:34:15 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
17:35:25 <glguy> When I wrote that it was named "fuseTraversable"
17:35:34 <glguy> I'm not responsible for the name "confusing"!
17:35:47 <iqubic> What do those do?
17:36:19 <benzrf> https://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-Traversal.html#v:confusing
17:45:04 <iqubic> What does Yoneda do?
17:48:15 <Welkin> she sings
17:54:53 <iqubic> LOL.
17:55:11 <iqubic> I know there's a lemma tied to Yoneda, but IDK much beyon that.
17:56:20 <kadoban> I wonder if there's any llama/lemma jokes.
17:57:51 <Welkin> that's very chinese
18:02:43 <mjrosenb> I guess another question should be: does anyone know if the happstack guide for hsx is up to date?
18:02:55 <clmg> Is there any way to install the hackage package list without cabal? My internet connection is rather slow and curl always times out.
18:03:06 <clmg> Or is there a way to increase cabal's download timeout?
18:10:55 <Solonarv> clmg: you should just be able to download the tarball however you want and plonk it into cabal's folder structure
18:11:20 <Solonarv> I'm not sure what the URL is or where you need to put it, but I think that's mentioned in cabal's output when it tries to download
18:12:14 <clmg> Solonarv: I have the tarball for the base package. where do I "plonk" it?
18:12:53 <c_wraith> you can't install base with cabal/stack anyway
18:12:58 <Solonarv> clmg: I thought you wanted the index?
18:12:59 <c_wraith> base is wired to ghc
18:13:13 <c_wraith> It comes with ghc, and cannot be used with a different version of ghc
18:14:32 <clmg> Solonarv: That would be best. Where can I get a tarball of the package list?
18:14:59 <hpc> i wonder if you could mirror hackage locally and install from that
18:15:01 <clmg> /packages/index.tar.gz
18:15:03 <clmg> ?
18:15:25 <hpc> it might be a bit much bandwidth-wise though, if that's an issue on top of latency or packet loss
18:15:44 <Solonarv> clmg: run 'cabal new-update -v2 --dry-run' and you'll see what cabal wants to download
18:16:36 <clmg> Solonarv: aha! thank you. where should I put this file?
18:16:42 <Welkin> `cabal update` always takes forever
18:17:00 <Welkin> clmg said that is the problem, not downloading the actual packages
18:17:04 <clmg> I wish it would resume where it left off if it times out
18:17:36 <Solonarv> the index goes in blah/packages/hackage.haskell.org/01-index.tar.gz
18:17:59 <clmg> It gets ~ 75% of the way done and then curl gives up and starts over from the first byte
18:18:15 <Welkin> that's why you need bittorrent!
18:18:26 <Welkin> http is terrible for downloads
18:19:29 <Solonarv> if you have a way to plug bittorrent into cabal (new-)update, that'd be great
18:20:42 <Welkin> if we can make haskell package distribution distributed
18:20:44 <hpc> making bittorrent work with mutable files would be pretty impressive regardless of cabal
18:21:03 <Welkin> start with federation
18:21:14 <Welkin> each person can run their own cabal "pod"
18:21:20 <Welkin> and connect to other cabal pods
18:21:49 <Welkin> you can use a quorum to determine what the latest package is
18:22:00 <Welkin> and it will eventually get distributed to every pod
18:22:03 <Welkin> =D
18:22:33 <Solonarv> IPFS seems sort-of made for this
18:22:56 <Solonarv> hackage is append-only after all!
18:23:26 <Welkin> get ready for cabal to join the fediverse
18:23:31 <monochrom> There's ought to be a way to work blockchains into this. >:)
18:23:39 <c_wraith> that's what IPFS is. :P
18:23:41 <Welkin> you can watch videos on peertube while you download aeson
18:23:57 <monochrom> Oh!
18:24:08 <c_wraith> (not quite true.  Filecoin is the blockchain, but it's built on top of IPFS)
18:24:17 <Solonarv> ah, I was about to object
18:24:32 <Welkin> no blockchain!
18:24:37 <c_wraith> Yeah, figured I should actually tell the truth. :P
18:24:51 <Solonarv> IPFS is just a distributed content-addressed store
18:24:59 <Solonarv> IRIC
18:25:00 <hpc> what we really need is for google to make a new cabal protocol on top of udp :P
18:25:01 <Welkin> useless cpu cycles, for what?
18:25:15 <Welkin> no way
18:25:17 <Welkin> down with google
18:26:12 <monochrom> https://xkcd.com/2105/ :)
18:27:22 <Solonarv> heh
18:27:50 <coldpress> glguy: very cool! I want to take an existing TH implementation with NormalC, and extend it to GadtC
18:28:05 <slack1256> When compiling with -eventlog, does anybody get wrong results with +RTS -lf -RTS?
18:28:46 <slack1256> threadscope tells me I didn't pass that option when generating the eventlog, but I am sure I am doing it
18:33:02 <clmg> I tried to download the index manually but it times out around the same point. So the server is timing not, not cabal.
18:33:48 <Welkin> no package index for you!
18:34:19 <clmg> Is there a mirror that supports byte-ranges
18:34:32 <clmg> so I can download it in two parts
18:34:41 <Welkin> try using wget
18:34:53 <Welkin> wget -c url-here
18:35:02 <Welkin> that continues the download
18:35:05 <c_wraith> does the server not support it?  It's all just static files
18:35:35 <Welkin> the client has to support it
18:36:11 <c_wraith> well, yes, both do.
18:36:27 <c_wraith> but the question suggests that the server doesn't.
18:36:28 <clmg> Welkin: I can give wget a try. but why would wget continue the download?
18:36:32 <clmg> and curl wouldn't?
18:36:34 <c_wraith> That suggestion surprises me
18:37:27 <Welkin> curl is very low level
18:37:42 <Welkin> there may be an option for curl to continue too
18:37:50 <Welkin> but I know wget has lots of nice features
18:38:00 <clmg> Welkin: okay. trying wget -c
18:39:28 <Solonarv> clmg: actually, hackage itself supports byte ranges! I just did a `cabal new-update` and saw a Range header in the request
18:39:55 <clmg> Solonarv: excellent. hopefully wget will timeout, and then I can just re-run it and it will finish the download :)
18:40:07 <Solonarv> ;)
18:47:08 <clmg> when I re-run wget with the -c flag hackage returns "400 bad request"
18:47:09 <clmg> lame
18:47:17 <clmg> why on earth?
18:56:50 <Henson> hi everyone, if I'm interfacing with a C function and want to allocate a Ptr Foo to pass into the C function to put something into, which I'll then convert to ForeignPtr Foo, GHC is complaining that Foo isn't an instance of Storable.  What's the proper way to do this kind of thing?  If I have a C function that returns a Ptr Foo, Haskell deals with it just fine, but trying to allocate one...
18:57:10 <Henson> a-priori to pass in, I don't know the proper way to do that
18:57:17 * hackage constraints-extras 0.2.3.2 - Utility package for constraints  https://hackage.haskell.org/package/constraints-extras-0.2.3.2 (abrar)
18:57:55 <Solonarv> Henson: I'm pretty sure there's an 'alloc' variant where you pass in a size explicitly, you'd want to use that
18:58:29 <Henson> Solonarv: so just allocate the appropriate number of bytes for a pointer?
18:59:03 <Henson> Solonarv: if I'm trying to make a Ptr Foo, then do I need to make Foo an instance of Storable?
18:59:26 <Solonarv> Henson: no; allocate however many bytes are needed
18:59:27 <monochrom> Not necessarily.
19:00:31 <Henson> the C-level is going to be allocating the appropriate number of bytes for the actual object, and is going to be passing back a pointer to the Haskell layer which will hold on to it and eventually pass it back to C to reference it in the future.
19:01:04 <Solonarv> ...in that case, why are you trying to allocate memory on the haskell side?
19:01:52 <Solonarv> does the C function want a 'foo** ptr' and contain a line like '*ptr = malloc(whatever)' ?
19:03:30 <Henson> Solonarv: well, since I can only return 1 thing from a C function, but I have several things I want to pass back, I need to pass them back by manipulating pointers which are inputs to the function.
19:05:14 * Henson thinks
19:05:54 <Welkin> Jimmy is that you?
19:10:09 <Henson> Sonolarv: say I've got a C function that returns a pointer to some C data.  I tell Haskell it returns a type of (Ptr Foo), and it's fine with that.  But say I want to return multiple pointers, and I need to do that by writing to pointers that are passed in to the C function.  In Haskell I need to allocate memory for these and pass them in, then convert them to ForeignPtrs after the C call.
19:12:14 <Solonarv> ah! so the C function does want pointers to pointers?
19:12:51 <iqubic> How does FFI actually work?
19:13:04 <iqubic> Is there a tutorial for it somewhere?
19:13:37 <Henson> Solonarv: yes, now that I think about it, I should be using pointers to pointers in C.  That's not what I'm currently doing.
19:14:11 <Welkin> (void*) ********thing
19:14:12 <Welkin> :D
19:14:19 <Henson> haha!
19:14:30 <Solonarv> Henson: ah! that's where the confusion came from ;)
19:14:36 <slack1256> Is it possible to load a module (from STM) on lambdabot?
19:14:40 <Solonarv> Welkin: C function pointer syntax is eeeevil
19:14:54 <Solonarv> ?let import Control.Concurrent.STM
19:14:56 <lambdabot>  Defined.
19:15:04 <slack1256> witchcraft!
19:15:15 <Solonarv> :k STM
19:15:17 <lambdabot> * -> *
19:15:21 <iqubic> I always say it as "@let"
19:15:35 <slack1256> > var1 <- atomically $ newEmptyTMVar
19:15:37 <lambdabot>  <no location info>: error:
19:15:37 <lambdabot>      not an expression: ‘var1 <- atomically $ newEmptyTMVar’
19:15:44 <Solonarv> slack1256: lambdabot doesn't run IO
19:15:57 <Solonarv> :t newEmptyTMVar
19:15:58 <lambdabot> STM (TMVar a)
19:16:05 <slack1256> Mmm the type of that var1 binding is strange on ghci.
19:16:18 <Solonarv> strange how?
19:16:19 <Henson> Solonarv: but, at the Haskell layer I'll still have the same problem.  I'll still pass in to the C layer (Ptr Foo) and it still needs to be allocated.  But the amount of space I need to allocate is the space for a pointer.
19:16:30 <slack1256> It doesn't result on a `TMVar a`, it results on `TMVar GHC.Types.Any`
19:16:46 <Solonarv> slack1256: defaulting strikes again, I suppose? That is a bit weird.
19:16:58 <Henson> Solonarv: right?  Should I make Foo an instance of Storable with the size being that of a 64-bit pointer?
19:17:11 <Solonarv> Henson: no! unless 'Foo' is actually a pointer, that is
19:17:12 <slack1256> It is a weird defaulting. Any is a type family.
19:17:36 <Solonarv> Henson: your C function takes a 'foo**' argument, yes?
19:17:44 <iqubic> I really want to learn about FFI.
19:18:04 <Henson> Solonarv: yes, it should (it currently doesn't, I have to change that).
19:18:48 <Solonarv> Henson: well, change that; and change your 'foreign import' to '... -> Ptr (Ptr Foo) -> ...'
19:19:05 <Henson> Solonarv: ok, I'll give that a try
19:19:10 <iqubic> is there an Haskell to C FFI guide out there that I can look at?
19:19:41 <Solonarv> then you can allocate 'ptrptr :: Ptr (Ptr Foo)' on the Haskell side, pass it to the C function, and afterwards use 'poke ptrptr' to get out a 'Ptr Foo'
19:21:05 <Welkin> peterpiper
19:21:14 <Solonarv> iqubic: https://en.wikibooks.org/wiki/Haskell/FFI exists, though I haven't read it
19:25:24 <Henson> Solonarv: do you mean "peek ptrptr"?  Then do I convert the peeked (Ptr Foo) to (ForeignPtr Foo)?
19:28:31 <Solonarv> Henson: yes (to both questions)
19:31:01 <Henson> Solonarv: sweet, it compiles!  Now on to the task of seeing if it actually works the way I intend :-)
19:31:11 <Henson> Solonarv: thanks so much for your help!
19:33:56 <Solonarv> Henson: woohoo! glad I could help :D
19:37:17 * hackage hedgehog-classes 0.1.1.0 - Hedgehog will eat your typeclass bugs  https://hackage.haskell.org/package/hedgehog-classes-0.1.1.0 (chessai)
20:11:47 <Henson> what's the language extension (or is this a forall thing) I need to use if I want a multi parameter typeclass but I have functions in the class that don't contain all of the type variables?
20:13:05 <Solonarv> AllowAmbiguousTypes, because those methods' types are ambiguous :P
20:13:54 <Solonarv> You'll probably also need TypeApplications to use them without GHC yelling about amiguous types
20:15:21 <Henson> Solonarv: here's what I'm trying to do.  I'm trying to write an interface to a machine vision camera library.  One class I have is the CameraBus class, inside of which are some functions initialize and terminate the bus, and to get a camera from the bus.
20:16:01 <Solonarv> why does it need to be a class?
20:17:07 <Henson> Solonarv: but the problem comes when I want to get a camera.  I'm writing this to work with multiple different kinds of camera vendors, so that's why it's a class.  There's also a Camera class with things like opening and closing the cameras, adjusting the shutter etc.  Each vendor will have its own instance of CameraBus and Camera functions.
20:18:03 <Henson> Solonarv: but the problem with the CameraBus class is that the getCamera function can only return Cameras that are from the same vendor.  So for example a Sony instance of the CameraBus class can only return Sony camera.
20:18:38 <Solonarv> yes, that makes sense
20:19:02 <Henson> Solonarv: but in the CameraBus type class I need to figure out how to add that type constraint to the getCamera function.  I can't use a Camera type constraint, because that doesn't link the CameraBus and CameraTypes together.  For example I couldn't get a FLIR camera from a Sony CameraBus.
20:20:02 <Solonarv> this seems like a good use case for proxy arguments
20:20:27 <Henson> Solonarv: so I can use MultiParamsTypeClasses to say "class CameraBus b c" where "b" is the CameraBus type and "c" is the Camera type and only make instances of "CameraBus CameaBusSony CameraSony" to tie them together.
20:21:11 <Henson> Solonarv: but when I try doing that, GHC complains because the getBus function doesn't depend on the Camera type at all, and so it can't deduce the "c" in the "CameraBus b c" class.
20:21:31 <Henson> Solonarv: have I explained it well enough for you to see the problem, or should I keep going?
20:21:50 <Solonarv> well enough for me to suggest some approaches you should look up
20:22:03 <Henson> Solonarv: should I put something on hpaste for you to look at?
20:22:18 <Solonarv> maybe it'll help, sure!
20:22:48 <Henson> Solonarv: what's the URL of that haskell paste thing again?
20:22:59 <Solonarv> lpaste.org, but it's down
20:23:13 <Solonarv> just use gist.github.com, or whatever else you want
20:23:17 <Henson> hmm
20:25:12 <Henson> Solonarv: https://pastebin.com/5arQJQni
20:27:33 <Solonarv> Ah, this actually sounds like you want an associated type family; like so: https://pastebin.com/E59ZbuEt
20:28:48 <mjrosenb> Does anyone know of a project that uses hsx that I can look at to figure out what I'm doing wrong?
20:29:38 <Solonarv> mjrosenb: https://packdeps.haskellers.com/reverse/hsx will show you the ones that are on hackage, at least
20:30:37 <Solonarv> Henson: another option would be to keep your original two-parameter type class, and add a 'b -> c' functional dependency
20:30:53 <mjrosenb> neato. I guess I should look for the new one which replaced hsx?
20:30:56 <Solonarv> (read as: 'b' determines 'c')
20:31:22 <Solonarv> mjrosenb: I don't even know what hsx is, I just wanted to point you at that reverse-dependency tool
20:31:29 <mjrosenb> indeed.  thanks.
20:32:31 <mjrosenb> hsx is a preprocessor which enables you to write xml-like code and have it internally rendered into a dom-tree.  I don't really want to use it, but it looks like reform, which looks really nice only supports hsx.
20:34:08 <Solonarv> Ah.
20:35:10 <Henson> Solonarv: thanks for all your help.  I'll dig into this later and see if I can make some progress.  Unforunately, I have to go to bed now.
20:35:36 <Solonarv> Henson: hah! it's really late here too
20:35:46 <mjrosenb> aaand it looks like the only things that use hsx2hs are other libraries, no applications.
20:36:17 <mjrosenb> I suppose I could always use the code that the xml-like syntax gets translated to rather than using it directly.
20:38:00 <Solonarv> Applications are much less likely to be on hackage, so the tool I linked wouldn't find them.
20:38:43 <Solonarv> Perhaps you can squeeze useful examples out of searching github?
20:46:08 <mjrosenb> searching for hsx2hs only turns up the page of the project :-(
22:01:32 <ostscout> Hi. Coming from a scala background, thinking about futures where I can go from Future a -> future b via functor. How does this work with something like Async in haskell?  Do I also need to get back into plain old IO via wait before building up the rest of my computation?
22:02:19 <osa1> ostscout: the Async type is a Functor so you just do fmap
22:02:35 <osa1> fmap (... your a -> b function ...) async
22:03:54 <ostscout> Hrm. I must have messed up my imports. Let me try that.
22:05:15 <osa1> I don't think you messed up your imports if that doesn't work, as importing Control.Concurrent.Async brings in the Functor instance as well. paste your code somewhere with the error you're getting.
22:06:47 <ostscout> Figured it out. Was importing my own version of the Async type (from ch8 of parallel and concurrent programming in haskell), not the Control.Concurrent.Async chapter.  Ha. Egg on my face for that one.
22:07:03 <ostscout> er, package I mean.
22:18:36 <slack1256> > set (at 1 . _1) (Just 'a') $ Data.Map.fromList [(1, ('h', 'j') )]
22:18:38 <lambdabot>  error:
22:18:38 <lambdabot>      • Could not deduce (Field1
22:18:38 <lambdabot>                            (Maybe (Char, Char)) (Maybe (Char, Char)) a0 (Mayb...
22:18:50 <slack1256> Can somebody help me reading that error?
22:19:06 <slack1256> I want to change the 'h' to an 'a'
22:20:06 <ostscout> osa1 thanks, got it working.
22:20:27 <osa1> great
22:21:45 <slack1256> > set (at 1 . _Just . _1) 'a' $ Data.Map.fromList [(1, ('h', 'j') )]
22:21:47 <lambdabot>  fromList [(1,('a','j'))]
22:21:51 <slack1256> ...
22:22:01 <slack1256> Kind of make sense
22:22:06 <slack1256> thanks lambdabot lol
