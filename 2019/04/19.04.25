00:00:05 <jle`> or maybe i should say 'for each'
00:00:41 <Solonarv> for any particular choice of f and g there is only one instance, yes
00:01:02 <jle`> right, so it's accurate to say "for any f and g, Compose f g has a unique instance"
00:01:10 <Solonarv> sure
00:01:19 <nshepperd_> Solonarv: what are the two ways?
00:01:45 <Solonarv> nshepperd_: you can choose (Functor f, Functor g) or (Contravariant f, Contravariant g) for the constraint
00:02:03 <Solonarv> correspondingly the implementation of fmap becomes (fmap . fmap) or (contramap . contramap)
00:02:19 <jle`> i would consider Compose Maybe [] to be a "different" instance than Compose [] Maybe
00:02:28 <jle`> or Compose Pred Pred
00:03:01 <Solonarv> that is somewhat reasonable, but base:Data.Functor.Compose and GHC don't agree with you there
00:03:43 <fen> argh! the approach does not work! see this paste; https://pastebin.com/raw/pZf2mP8s
00:03:44 <jusss`> a function after doing partial, what the new function's type would be?  f x y z = z(y x)    f1 x1 = f x1 (\x->x) (\x->x)   what's the type of f1?
00:03:56 <jusss`> ghci show f1::t3->t3
00:04:28 <jle`> nice :)
00:05:22 <jle`> so maybe we can say "Functor instances are unique for all cases if you fix all the type variables"
00:06:00 <fen> jusss` whats wrong with the type GHCi is giving?
00:06:09 <jle`> or "Functor instances are all unique for any given instantiation of type variables"
00:06:33 <Solonarv> note: (\x->x) is already defined, it's called id. That said, let's work through this:
00:06:33 <Solonarv> f1 x1 = f x1 id id
00:06:33 <Solonarv>       = id (id x)
00:06:33 <Solonarv>       = id     x  -- definition of id: 'id foo = foo'
00:06:33 <Solonarv>       =        x  -- definition of id: 'id foo = foo'
00:06:33 <dminuoso> unsymbol: Also, as long as there is a single or canonical instance available, why not write it? :)
00:06:48 <Solonarv> jle`: yeah, that is certainly true
00:07:02 <Solonarv> but it doesn't explain why the instance Functor ((->) e) is unique
00:07:27 <jle`> doesn't it say that ((->) e) is a unique Functor for any e ?
00:07:48 <jle`> i mean, it doesn't explain why, but neither does the original statement
00:07:56 <Solonarv> hm
00:08:03 <jusss`> fine, type inference
00:08:08 <jle`> "why" functor instances are unique is a deeper question
00:08:09 <Solonarv> I feel like there should be an elegant way to extend that statement to forall-instances
00:08:11 <dminuoso> % data Foo :: (* -> *) where FooInt :: Int -> Foo Int
00:08:11 <yahb> dminuoso: 
00:08:13 <dminuoso> % data Bar a where BarInt :: Int -> Bar Int
00:08:13 <yahb> dminuoso: 
00:08:19 <dminuoso> Is there a difference between those GADTs?
00:08:33 <Solonarv> nope
00:08:35 <jle`> besides the name? no
00:08:42 <jle`> type variables in the head of GADTs are all ignored
00:08:50 <jle`> * GADT syntax
00:08:57 <Solonarv> well, Foo has what's called a CUSK (Complete User-Supplied Kind) but I think that's being done away with
00:09:05 <jle`> so data MyGADT a b c d e f where ...., the names of a/b/c/d/e/f are all ignored
00:09:16 <jle`> that's why it's kind of awkward to use this syntax with GADTs
00:09:21 <Solonarv> you could write: data Bar (a :: *) where ...; to give Bar a CUSK as well
00:09:21 <dminuoso> Ah, so it's just a visually pleasant way of denoting the kindness?
00:09:35 <jle`> yeah, it gives you the kind, but the names are all thrown away
00:09:48 <Solonarv> it's not even that pleasant if you want to specify the parameters' kinds
00:09:53 <jle`> the most natural way might be data Foo :: * -> * where FOoInt :: Int -> Foo Int
00:10:04 <jle`> since (* -> *) is the same as * -> *
00:10:15 <Solonarv> oh yeah, the parentheses aren't needed
00:10:19 <jle`> it hearkens to things like myFunction :: Int -> Bool
00:10:25 <fen> yeah, that way is nicer since `a' isnt mentioned 
00:10:29 <unsymbol> Solonarv dminuoso: thank-you both :) are there any examples out there in the wild that you've seen and thought, "wow, that's an elegant use of the canonical functor instance for (->)"?
00:10:38 <Solonarv> and I'm trying to get used to writing Type instead of *, but that's a separate quibble
00:10:56 <jle`> unsymbol: i don't think any usage of (->) directly is particularly elegant
00:11:00 <Solonarv> unsymbol: I don't often use fmap when I *know* the functor I have is (->), tbh
00:11:05 <jle`> er, `(->) r`
00:11:06 <dminuoso> unsymbol: There's a cool way to think about ((->) e) - if you take the "functors are containers" notion, then functions represent generalized containers indexed by their domain.
00:11:11 <fen> Solonarv: why? thats a worse syntax
00:11:18 <jle`> but, it's mostly used in functor-polymorphic abstractions
00:11:40 <jle`> it's hard to draw an example because i don't think there are too many functor-polymorphic abstractions you encounter early in Haskell
00:11:51 <Solonarv> especially because fmap @((->) e) is the same thing as (.) - function composition -, which communicates intent more clearly iMO
00:11:51 <jle`> maybe `void :: f a -> f ()`, but that's kind of useless for functions, heh
00:12:17 <fen> % :t fmap @((->) e)
00:12:18 <yahb> fen: ; <interactive>:1:13: error: Not in scope: type variable `e'
00:12:24 <Solonarv> however, a Functor instance is needed as a precondition for Applicative and Monad instances; and I do use those not too infrequently
00:12:27 <dminuoso> unsymbol: for example: `Integer -> Char` could be thought of as an infinite list of characters
00:12:31 <Solonarv> % :t fmap @((->) _) --fen
00:12:31 <yahb> Solonarv: (a -> b) -> (w -> a) -> w -> b
00:12:41 <dminuoso> unsymbol: So `fmap` over that changes the content of that list
00:13:35 <fen> is there a better way to write this so that we can both pattern match on, and write as a constraint, the members of a GADT? https://pastebin.com/raw/pZf2mP8s
00:13:43 <Solonarv> @let evenOver10 = liftA2 (&&) even (> 10)
00:13:44 <lambdabot>  Defined.
00:14:11 <Solonarv> > [evenOver10 8, evenOver10 19] -- an example
00:14:13 <lambdabot>  [False,False]
00:14:29 <dminuoso> unsymbol: The best example I can think of is `data Store s a = Store { pos :: s, peek :: s -> a }` when you model a simple automaton like Conways game of life using its Comonad instance. It's not exactly ((->) e), but its close enough.
00:14:29 <Solonarv> (using the Applicative instance for functions)
00:14:38 <jle`> there really aren't that many Functor-polymorphic abstractions you encounter every day
00:14:49 <jle`> but there are a lot of Applicative-polymorphic abstractions though, and that requires Functor (->) e
00:14:50 <dminuoso> unsymbol: So if you have some machine state, you can use the Functor instance to map over the entire board.
00:14:51 <jle`> so there's that.
00:16:26 <Solonarv> in a sense, the Functor ((->) e) instance is more of a fundamental building block at the bottom of many things you might end up using, rather than something you'll use directly
00:17:19 <jle`> there are bunches of Applicative-polymorphic abstractions in Haskell -- like, say you want to write a funky Monoid on [r -> String]
00:17:38 <jle`> that will combine all combinations of all attempts
00:17:55 <fen> I cant see how the type restricted output of a GADT could work like it is being used as a constraint in the paste
00:18:21 <unsymbol> dminuoso: thanks :) Solonarv: do any good examples of an abstraction that's the "next level up" spring to mind?
00:18:43 <Solonarv> the Applicate instance for functions is one such abstraction
00:18:50 <Solonarv> *Applicative
00:18:58 <unsymbol> thanks, i'll take a proper look
00:19:39 <Solonarv> I somewhat-regularly write f <*> g instead of \x -> f x (g x), or liftA2 op f g instead of \x -> op (f x) (g x)
00:19:59 <Solonarv> (these both come from Applicative)
00:20:01 <jle`> for example, there's the `Ap` newtype which gives a free `Monoid` instance for any instance of Applicative
00:20:06 <dminuoso> unsymbol: jle` described is nicely:
00:20:10 <dminuoso> 09:11:18            jle` | it's hard to draw an example because i don't think there are too many functor-polymorphic abstractions you encounter early in Haskell
00:20:18 <jle`> so if my type is Applicative, then i get a Monoid "for free"
00:20:33 <jle`> so here's a case where any Applicative instance you have can be used as a Monoid
00:20:45 <jle`> so since (->) r is an Applicative, then it can be used as a Monoid with the help of Ap
00:20:47 <dminuoso> unsymbol: Assuming you are still a beginner in Haskell, I dont think it would be easy to recognize and understand functor-polymorphism.
00:21:15 <jle`> functor-polymorphic here just means a function that is written to be used for *any* Functor instance
00:21:18 <fen> it seems like converting a GADT with constructors of uniform type into a closed type family class does not retain pattern matching, so cant be composed
00:21:21 <jle`> like `void :: Functor f => f a -> f ()`
00:21:29 <unsymbol> dminuoso: i wouldn't say i am a beginner but this question came up recently and i didn't have a good answer for it, so i'm trying to write a blog post.
00:21:31 <jle`> void :: IO a -> IO ()
00:21:36 <jle`> void :: Maybe a -> Maybe (), etc.
00:22:10 <jle`> there aren't too many functor-polymorphic abstractions, but there are a buttload of Applicative polymorphic abstractions
00:22:34 <unsymbol> jle`: aha, perfect
00:22:35 <jle`> case in point, the entire Data.Traversable module
00:23:26 <jle`> also Data.Functor.Product, Data.Functor.Compose are two big applicative-polymorphic abstractions i use a lot
00:23:38 <fen> i want compositional closed classes apparently
00:23:48 <jle`> also a big section of the lens libraries is just applicative-polymorphic abstractions
00:24:27 <jle`> so maybe we can appreciate Functor ((->) r) as just a necessity for the usefulness of Applicative ((->) r), heh
00:24:27 <dminuoso> Lens is probably the most popular functor polymorphic abstraction
00:24:36 <dminuoso> type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t 
00:24:41 <Solonarv> jle`: although Lens itself is actually Functor polymorphic, indeed
00:24:45 <jle`> also, there's an interesting use of Applicative that can't be said about Functor
00:25:08 <jle`> is that you can use Applicative-based newtypes like Product, Compose, etc. to automagically derive Applicative instances for your data types
00:25:27 <jle`> you can use them to automatigically derive Functor instances, as well...but that's much less useful because GHC already has -XDeriveFunctor built-in
00:25:57 <fen> maybe it would be enough just to consider the idea of pattern matching on instances instead, then the existing way could work
00:26:12 <jle`> but let's say i had `data MyType a = MyType [a] (Bool -> a)`
00:26:27 <jle`> sure, i can derive Functor automatically. but i can't derive Applicative automatically
00:26:27 <dminuoso> Solonarv: I just dont think that lens picks the ((->) e) instance for that.. ever.. 
00:26:32 <jle`> but, if i instead wrote:
00:26:51 <jle`> newtype MyType a = MyType (Product [] ((->) Bool) a)
00:27:03 <jle`> then using GeneralizedNewtypeDeriving, i can say `deriving (Applicative MyType)`
00:27:11 <jle`> and the Applicative instance will be given to me for free
00:27:18 <fen> somehow not being able to match on instances is almost the opposite of not being able to constrain on datatype inhabitants 
00:27:31 <Solonarv> however, the cost of that is that working with MyType directly becomes more unwieldy
00:28:16 <jle`> i think, not too much. you just have MyType (Pair xs f) instead of MyType xs f.  but yeah, there's a cost. some of it can be waved away using DerivingVia some day, maybe
00:28:26 <jle`> but yeah, that's one big benefit of Applicative `(->) r`
00:28:27 <fen> so that basically, if we could constrain on constructors this would solve not being able to match on instances
00:28:47 <jle`> is that you can use it to automatically derive Applicative instances using applicative-polymorphic combinators like Product and Compose
00:29:01 <dminuoso> unsymbol: https://www.schoolofhaskell.com/user/edwardk/cellular-automata/part-1
00:29:09 <jle`> this benefit exists for Functor too, but it's not as cool because GHC has functor-deriving built-in
00:29:30 <Solonarv> jle`: it gets *much* more unwieldy if you have more than two fields, and/or wanted to use record syntax
00:29:35 <dminuoso> unsymbol: This blog series of 3 parts explores functor polymorphism hidden in Pretext (and applicative polymorphism in Bazaar). This is very deeply related to lenses.
00:29:48 <jle`> Solonarv: ah yeah. well, that's why we have pattern synonyms ;)
00:29:56 <jle`>  /s
00:29:59 <jle`>  /but not really
00:30:17 <unsymbol> jle` dminuoso Solonarv: you've all been way too helpful. cheers :D
00:30:28 <jle`> happy haskelling :D
00:30:38 <dminuoso> Solonarv: By the way, regarding constraints-extras, I just realized that I have been comfortable with the notion of splitting the forall quantification and the proof obligation of constraints..
00:30:47 <dminuoso> Solonarv: Its done all over the place in constraints already.
00:30:52 <dminuoso> I feel quite dumb now.
00:31:40 <jle`> also neat that you can derive (Monad MyType) automatically too for the above case, i hadn't realized that. i wonder what the Monad instance does
00:32:06 <jle`> @let newtype MyType a = MyType (Product [] ((->) Bool) a) deriving (Functor, Applicative, Monad)
00:32:07 <lambdabot>  .L.hs:164:28: error:
00:32:07 <lambdabot>      • Expecting two fewer arguments to ‘Product []’
00:32:07 <lambdabot>        Expected kind ‘(* -> *) -> k0 -> *’, but ‘Product []’ has kind ‘*’
00:32:31 <jle`> @let newtype MyType a = MyType (F.Product [] ((->) Bool) a) deriving (Functor, Applicative, Monad)
00:32:32 <lambdabot>  .L.hs:166:37: error:
00:32:32 <lambdabot>      • Can't make a derived instance of ‘Applicative MyType’:
00:32:32 <lambdabot>          ‘Applicative’ is not a stock derivable class (Eq, Show, etc.)
00:32:42 <jle`> aw GeneralizedNewtypeDeriving is not on
00:32:45 <Solonarv> @slap lambdabot
00:32:45 * lambdabot slaps lambdabot with a slab of concrete
00:32:52 <dminuoso> Cant you enable extensions on lambdabot?
00:32:54 <fen> try yahb?
00:33:00 <Solonarv> % :set -XGeneralizedNewtypeDeriving
00:33:01 <yahb> Solonarv: 
00:33:06 <jle`> you cannot enable extensions on lambdabot unfortunately
00:33:09 <Solonarv> % import Data.Functor.Product
00:33:09 <yahb> Solonarv: 
00:33:20 <fen> jle` is that an issue with hotswapping?
00:33:22 <jle`> % newtype MyType a = MyType (Product [] ((->) Bool) a) deriving (Functor, Applicative, Monad)
00:33:22 <yahb> jle`: ; <interactive>:8:28: error:; Ambiguous occurrence `Product'; It could refer to either `Data.Functor.Product.Product', imported from `Data.Functor.Product'; or `Control.Monad.RWS.Product', imported from `Control.Monad.RWS' (and originally defined in `base-4.12.0.0:Data.Semigroup.Internal')
00:33:33 <jle`> % newtype MyType a = MyType (Data.Functor.Product.Product [] ((->) Bool) a) deriving (Functor, Applicative, Monad)
00:33:34 <yahb> jle`: 
00:33:37 <Solonarv> % :m - Control.Monad.RWS
00:33:37 <yahb> Solonarv: 
00:33:39 <dminuoso> jle`: Shame, well I have been using yahb for such a long time now because you can do pretty much anything in it... :(
00:33:49 <Solonarv> % import qualified Control.Monad.RWS as RWS
00:33:49 <yahb> Solonarv: 
00:34:14 <fen> % newtype MyType a = MyType (Product [] ((->) Bool) a) deriving (Functor, Applicative, Monad)
00:34:15 <yahb> fen: ; <interactive>:13:28: error:; Ambiguous occurrence `Product'; It could refer to either `Control.Monad.Writer.Product', imported from `Control.Monad.Writer' (and originally defined in `base-4.12.0.0:Data.Semigroup.Internal'); or `Data.Functor.Product.Product', imported from `Data.Functor.Product'
00:34:20 <Solonarv> fuck's sake!
00:34:34 <Solonarv> % :m - Control.Monad.Writer
00:34:35 <yahb> Solonarv: 
00:34:41 <dminuoso> Who do I talk to if I'd like some extra packages for yahb?
00:34:43 <Solonarv> one sec I'll fix it in PMs
00:34:48 <fen> % newtype MyType a = MyType (Product [] ((->) Bool) a) deriving (Functor, Applicative, Monad)
00:34:48 <yahb> fen: ; <interactive>:16:28: error:; Ambiguous occurrence `Product'; It could refer to either `Data.Monoid.Product', imported from `Data.Monoid' (and originally defined in `base-4.12.0.0:Data.Semigroup.Internal'); or `Data.Functor.Product.Product', imported from `Data.Functor.Product'
00:34:52 <fen> baaah
00:34:58 <fen> Solonarv: ok you do that
00:35:08 <jle`> % let testMyType mt = do x <- mt; y <- MyType [1,2,3] (bool 10 20); pure (x * y)
00:35:08 <yahb> jle`: ; <interactive>:19:38: error:; * Couldn't match expected type `(Bool -> Integer) -> m b' with actual type `MyType a0'; * The function `MyType' is applied to two arguments,; but its type `Data.Functor.Product.Product [] ((->) Bool) a0 -> MyType a0' has only one; In a stmt of a 'do' block: y <- MyType [1, 2, 3] (bool 10 20); In the expression:; do x <- mt; y <- M
00:35:26 <jle`> % let testMyType mt = do x <- mt; y <- MyType (Pair [1,2,3] (bool 10 20)); pure (x * y)
00:35:26 <yahb> jle`: 
00:35:29 <fen> dminuoso: what do you mean about splitting foralls?
00:35:45 <Solonarv> % newtype MyType a = MyType (FP.Product [] ((->) Bool) a) deriving (Functor, Applicative, Monad)
00:35:45 <yahb> Solonarv: 
00:35:48 <Solonarv> \o/
00:35:59 <jle`> oh um i already defined it earlier
00:36:12 <fen> what is it the "proof obligation of constraints" ? can we match on this?
00:36:13 <jle`> % let testMyType mt = do x <- mt; y <- MyType (FP.Pair [1,2,3] (bool 10 20)); pure (x * y)
00:36:13 <yahb> jle`: 
00:36:21 <Solonarv> dminuoso: yahb is maintained by mni-ip (remove the hyphen)
00:36:37 <jle`> okay, i wonder what testMyType (MyType (FP.Pair [11,12] (bool 0 1)) will be
00:36:40 <hololeap> unsymbol: you can use any Functor in Free and Cofree. (Free (a ->) b) lets you chain together (a ->)'s to create something where you can access a value, b, given a key, which would look like [a]
00:36:58 <jle`> hololeap: ah yeah, how could i forget Free, everyone's favorite Functor-polymorphic abstraction
00:37:01 <dminuoso> fen: Well something like... `forall a. IO () -> (Show a => a -> IO ()) -> IO ()` that we talked about yesterday
00:37:12 <fen> oh yeah
00:37:16 <fen> what about it?
00:37:38 <hololeap> unsymbol: Cofree (a ->) b would give you something similar, except there is always a `b` available, even given []
00:37:45 <jle`> % let MyType (FP.Pair reslist resfunc) = testMyType (MyType (FP.Pair [100,200] (bool 0 1)))
00:37:45 <yahb> jle`: 
00:37:48 <jle`> % reslist
00:37:48 <Solonarv> Free ((->) e) a is: keep feeding me e's, and eventually I might give you an a
00:37:48 <yahb> jle`: [100,200,300,200,400,600]
00:37:54 <fen> i dont get how that fits in with the stuff about constraining the return type of a GADT
00:38:00 <jle`> % resfunc <$> [False, True]
00:38:00 <yahb> jle`: [0,20]
00:38:17 <jle`> i have no idea what i learned from that
00:38:20 <Solonarv> Cofree ((->) e) a is: keep feeding me e's, and for each one I'll give you an a
00:38:24 <dminuoso> fen: So are you familiar with the `constraints` package?
00:38:31 <jle`> oh i see, 0 * 10, 1 * 20
00:38:44 <fen> I feel like as this seems like a closed data family that it might somehow be something that can be pattern matched on and serve like a constraint/instance. and then what you say about constraints-extra seems almost like it might help
00:38:46 <hololeap> Solonarv: yeah :)
00:39:01 <jle`> ah i see, the result is just as if the two monads worked in parallel without ever interacting with each other
00:39:20 <fen> dminuoso: can remember writing things to try and compose constraint continuations which seems like that package, though not too good with Dictionaries 
00:39:35 <Solonarv> combine them and you have pure pipes/conduits/streams/whatever; replace Free with FreeT and you have monadic <whatever>
00:39:36 <dminuoso> fen: At the core the package describes being able to do something like this: withDict :: Dict a -> (a => b) -> b
00:39:58 <dminuoso> fen: And the way this can possibly work, is that by pattern matching GHC can see the dictionary and discharge the obligation to provide some proof for a.
00:40:02 <jle`> the idea is being able to use (a =>) as a value you can pass around at runtime
00:40:36 <dminuoso> fen: since: withDict Dict b = b
00:40:45 <fen> right, it takes the `a' from the Dict and puts it into the type signature as a constraint and then can use the function that requires this
00:41:38 <fen> so would the idea then to be to have something like Dict but with many constructors?
00:41:55 <dminuoso> fen: A bit more in fact.
00:42:31 <dminuoso> fen: If you had a finitely indexed GADT, say: `data Foo where FooI :: Int -> Foo Int; FooU :: Foo ()`
00:43:01 <fen> data Foo a ?
00:43:04 <dminuoso> Yeah
00:43:09 <fen> ok
00:44:42 <dminuoso> So if you write: instance ArgDict Foo where type ConstraintsFor Foo c = (c Int, c ()); argDict = \case FooI {} -> Dict; FooU {} -> Dict
00:44:59 <dminuoso> You can then use argDict to manufacture this kind of composite dictionary
00:45:23 <fen> :~|
00:46:55 <fen> oh ok, so the restriction of the return type of the GADT constructors serves as a constraint on the input type
00:47:48 <fen> are we at the point now where we can consider how to do this example in that style? https://pastebin.com/raw/pZf2mP8s
00:49:31 <orzo> Using GI.Gtk, does anyone know how to get an Event object from an EventMotion object?
00:50:11 <orzo> Should I just use Data.Coerce.coerce?
00:50:39 <fen> dminuoso: would it involve adding an extra parameter to the Basecase datatype, and restricting it to match the inputs to each case?
00:51:03 <fen> data Basecase b s a where  Stream' :: Stream s a -> Basecase Stream s a 
00:51:05 <fen> etc
00:51:53 <fen> then if you have an ArgDict instance for Basecase, we can generate a dictionary with a constraint like (b ~ Stream)
00:51:57 <fen> right?
00:52:26 <fen> but with;
00:52:27 <fen> type family Base (b :: * -> * -> *) :: Constraint where  Base Stream = ()
00:52:28 <Solonarv> orzo: can you link the docs for Event and/or EventMotion? I'm unfamiliar with gi-gtk and its docs seem somewhat hard to search
00:52:42 <MarcelineVQ> Event in particular
00:52:58 <fen> we have a constraint that would work for *any* of the cases of Base
00:54:03 <fen> seems like you would need to be able to compose together all the possible Dicts returned by argDict
00:54:48 <fen> but not as a tuple, as it need only satisfy one of them
00:55:01 <orzo> Solonarv: http://hackage.haskell.org/package/gi-gdk-3.0.16/docs/GI-Gdk-Structs-EventMotion.html  
00:55:54 <orzo> Solonarv: in the "device" section of that page, they link to eventGetSourceDevice which is on the docs for event.
00:56:22 <Solonarv> oh, I was looking at gi-gtk because that's what you said in your original emssage
00:56:27 <orzo> they say that I should use it to get the slave device, but I can't do that unless I obtain an Event
00:59:18 <fen> hmm maybe its like the other way round, the way with ArgDict instances takes an input type specified by a Foo Constructor and returns the constraint that a type matches the return type of this constructor. we need something that checks that an input type matches any of the ConstraintsFor Foo
01:00:14 <Solonarv> hm, looks like coerce would be fine here
01:01:47 * hackage lattices 2 - Fine-grained library for constructing and manipulating lattices  https://hackage.haskell.org/package/lattices-2 (phadej)
01:02:28 <orzo> Solonarv: When I use coerce, eventGetSourceDevice returns Nothing.  I'm trying to distinguish pointer devices, but so far, all the apis show the same information regardles sof which pointer device I use.
01:02:57 <dminuoso> fen: Im just beginning to understand constraints-extras, I cant relate that to your code (which I still dont understand what its designed to do)
01:05:54 <fen> its just supposed to constrain something to equal one of a set number of specific datatypes
01:06:27 <fen> these are gathered into either a GADT or matched on in a try family
01:06:33 <fen> either way seems inadiquate
01:06:44 <fen> type family*
01:06:58 <orzo> Solonarv: Evidence that coerce is not okay: the #device property of EventMotion is giving me a Just result, but eventGetDevice on a coerced value gives me Nothing.
01:07:07 <orzo> Documentation leads me to expect them to return the same result.
01:09:11 <fen> it needs to take a parmater provided to a class and constrain it to be one of a few datatypes 
01:11:51 <fen> so if you had like your Foo above, so that Foo a has `a' as either Int or (), then there should be a constraint we can use that is OneOf Foo x, which is equivalent to ConstraintEither (x ~ Int) (x ~ ())
01:12:31 <dminuoso> fen: What would ConstraintEither even be?
01:12:50 <fen> well we can use pair for constraints, but there is nothing like either?
01:13:20 <dminuoso> I have no idea
01:13:31 <dminuoso> fen: What would that do? How would you use it?
01:13:59 <fen> well it was encoded in the paste using a closed type family returning () :: Constraint
01:14:28 <fen> here was the shorter version of the paste; https://pastebin.com/raw/DV9Lq8w9
01:15:37 <Solonarv> there is nothing like either for constraints in general, because it's nasty to solve for
01:15:53 <Solonarv> you can so something like: "x is one of Int or ()"
01:15:59 <Solonarv> s/so/say
01:15:59 <fen> it was used just as described, to constrain a type to be one of the members of a GADT. but by converting the GADT to a closed type family, it lost the ability to be matched on...
01:17:25 <dminuoso> % data F a where FS :: Show a => a -> F a; FR :: Read a => a -> F a
01:17:26 <yahb> dminuoso: 
01:17:53 <dminuoso> Solonarv: In some way, doesn't this encode an `either` on constraints?
01:18:11 <Solonarv> dminuoso: yes, but it only works for equality constraints
01:18:36 <fen> so if we are going to keep it as a GADT, but provide an extra parameter that can reflect the singletons like nature of the inputs to restrict this type, and convert it into a ArgDict, then we need to be able to have a "OneOf" to be satisfied if it matches any of the argDicts
01:18:42 <dminuoso> Solonarv: Show/Read are not equality constraints
01:18:51 <Solonarv> dminuoso: oh, I missed that
01:19:10 <Solonarv> in some way, yes
01:19:38 <kuribas> do you prefer compile time checking of database schema, or just runtime checking if the returned data of the database matches the type of the function?
01:19:40 <Solonarv> but you don't get the help of the solver, at all
01:20:05 <dminuoso> kuribas: It depends on whether you can assure that your program is the only part that can control the schema.
01:20:26 <dminuoso> Solonarv: Why not? On pattern maching the dictionary is brought into scope again
01:20:27 <kuribas> dminuoso: that would be pretty hard
01:20:31 <Solonarv> kuribas: can't get around runtime checks, unless you want to use TH to query the database about its schema at compile time (pease don't that sounds insane)
01:20:45 <dminuoso> Solonarv: I could reify it into a Dict, pass it around..
01:20:53 <kuribas> Solonarv: there are db libraries that do that
01:20:55 <Solonarv> dminuoso: what I meant is that the solver doesn't help you create the right F
01:21:00 <fen> would it be something like type ConstraintsFor Foo c.... except instead of giving a constraint it gives a list of constraints and then there is like an Any type family to check over these
01:21:05 <kuribas> Solonarv: I am not a fan of it though
01:21:18 <Solonarv> sure, once you have an F you can pattern-match on it and use the dictionary within
01:21:25 <dminuoso> Solonarv: I guess the open world assumption makes it impossible
01:21:32 <dminuoso> (Even conceptually)
01:21:36 <Solonarv> indeed
01:21:52 <dminuoso> Or it would, at least, lead to incoherent programs.
01:22:06 <kuribas> dminuoso: typically databases are created outside of the program
01:22:17 <dminuoso> kuribas: The schema maintenance might not be.
01:22:26 <Solonarv> if you have a 'Or (Show a) (Read a)' constraint, the solver could never conclusively decide "okay, 'Show a' isn't satisfied, I'll pick 'Read a'"
01:23:24 <fen> well you could just use type equality and then have an any
01:23:30 <fen> so its not a constraint, just a type
01:23:34 <fen> :t any
01:23:35 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
01:23:46 <fen> :t or
01:23:47 <lambdabot> Foldable t => t Bool -> Bool
01:23:49 <Solonarv> the only constraints for which the solver can conclusively say "impossible" are built from equality constraints and (), the open-world assumption makes it impossible for typeclass constraints
01:23:53 <fen> yeah, an or, not an any
01:24:24 <kuribas> dminuoso: it seems the opinions on having type checked schemas are quite mixed.
01:24:26 <fen> or, any but with type equality to the desired type as the input function
01:24:56 <dminuoso> kuribas: I have yet to see a good type-checked schema that feels right and doesn't impose crazy syntax on me.
01:25:02 <kuribas> dminuoso: the question is what is the ideal amount of type checking you want for a database library.
01:25:13 <Solonarv> my preferred approach would be to use the type/other information to generate a desired schema at compile time, and at runtime check this against the database in some way
01:25:21 <fen> so what do you end up just storing a stype level list of the types corresponding to the constructors?
01:25:46 <kuribas> dminuoso: I had an idea to use a normal datatype for tables, then generics and labels to check the fields.
01:25:57 <Solonarv> yeah, that seems sensible
01:26:25 <dminuoso> kuribas: If I had to write another database application, Id probably use drifter.
01:26:27 <Solonarv> you can generate the table name from the type name, column names from field names, and column types from field types
01:26:46 <fen> the problem with that is that the user has to copy the various types corresponding to the fields of the GADT into a list as an associated type to some class
01:26:57 <Solonarv> which seems not-terrible to do using generics (don't remember if we have a library like that) or TH (I think persistent does this?)
01:27:05 <dminuoso> kuribas: And then use plain postgresql-simple, the type guarantees dont buy me enough to warrant weird/custom syntax.
01:27:28 <dminuoso> I also dont like TH too much in my code, so there's that.
01:28:00 <kuribas> Solonarv: yes, that's the idea
01:28:01 <Solonarv> yeah, I'm somewhat wary of TH because the staging restrictions and compile times are annoying
01:28:06 <orzo> Solonarv: coerce does work, I was able to get EventTypeMotionNotify from the #type attribute of the coerced Event
01:28:20 <kuribas> dminuoso: generics could do the trick
01:28:22 <orzo> Still don't know how to distinguish my pointer devices though
01:28:22 <fen> the closed class type family managed to produce a constraint immediately, maybe there is a backwards way to recover the GADT
01:28:54 <dminuoso> kuribas: Well the question is: what do you want to type check exactly.
01:29:45 <dminuoso> Do you want your queries to be typechecked against the schema?
01:30:00 <dminuoso> Are there any non-TH solutions even?
01:30:19 <kuribas> dminuoso: yeah, isn't it just enough to check if the type of the results matches the type you expect?
01:30:43 <kuribas> dminuoso: squeal checks against the schema
01:30:45 <dminuoso> kuribas: SQL can do more than just `select * from table`, this is not trivial what you ask for.
01:31:34 <dminuoso> To me some preprocessor that parses your SQL and compares it with a schema statically seems a safer bet.
01:31:49 <Solonarv> you could use some sort of extensible record thingy as the return type of a query
01:32:15 <kuribas> or an applicative selector
01:33:07 <fen> hmm the problem seems to be that its not bejective; the correspondence between the GADT constructors singleton like restricted return type
01:33:20 <kuribas> with star and fields as primitives
01:33:30 <fen> bijective*
01:33:55 <fen> so you cant recover the constructor corresponding to a given type
01:34:26 <fen> otherwise you could map over a phantom type-list of types to check that each had a corresponding constructor
01:35:18 <fen> and also somehow you would need to check that it had every constructors type mentioned
01:36:01 <fen> basically, to constrain a phantom parameter list to mention all of the types corresponding to the constructors
01:36:39 <kuribas> fen: if you want to match types to a constructor, use a type class
01:36:55 <fen> how?
01:37:52 <kuribas> make the constructor a method of the class
01:38:12 <fen> GADTs encoding singletons are a restriction on the functionality of a GADT, if this were not the case, and there were a strictly bijective singletons like version of a GADT, then this wouldnt be a problem
01:38:22 <ocramz> morning all!
01:39:00 <fen> kuribas: but then you cant pattern match on it
01:39:51 <ocramz> would it be useful for a package to provide a newtype `Stream (Of ByteString) (ResourceT IO) a`, for example for large HTTP responses and the like? would it become something like conduit?
01:40:23 <ocramz> * a newtype _around_ Stream etc. I mean
01:40:25 <merijn> ocramz: That sounds like conduit combined with something like warp, yes
01:40:37 <ocramz> aha thanks merijn
01:41:33 <fen> ie in this paste; https://pastebin.com/raw/pZf2mP8s you couldnt write "type family State (x :: * -> * -> *) :: Constraint where  State Basecase = ()" if Basecase has been converted to a class
01:41:48 <fen> (as it is called Base in the rest of the paste)
01:41:52 <ocramz> I would like to extend `req` with `streaming` types and I was trying to wrap my head around what's missing to achieve that. I'm drawing inspiration (and some code) from `req-conduit` 
01:45:17 * hackage optparse-applicative-simple 1.1 - Simple command line interface arguments parser  https://hackage.haskell.org/package/optparse-applicative-simple-1.1 (NikitaVolkov)
01:50:23 <kuribas> dminuoso: the question is what do you gain from checking against the schema, if the schema can change any time anyway.
01:50:49 <dminuoso> kuribas: If I use drifter and operationally ensure that nothing but my program controls the schema, then it cant change.
01:50:52 <kuribas> dminuoso: even if you handle the schema changes in the app, the database could be outdated.
01:50:59 <dminuoso> Then I blindly trust my schema file to always contain the truth.
01:51:20 <kuribas> dminuoso: that's not possible in our setting
01:51:31 <kuribas> dminuoso: we have different applications reading from the db
01:58:47 * hackage kleene 0.1 - Kleene algebra  https://hackage.haskell.org/package/kleene-0.1 (phadej)
02:08:20 <kuribas> dminuoso: and drifter doesn't work with mysql anyway
02:08:27 <kuribas> why is there so little love for mysql in haskell?
02:08:36 <dminuoso> kuribas: You can write a mysql backend with very little effort.
02:08:43 <fen> so if singletons give this "bidirectionality" that cant be achieved using regular GADTs - can anyone help understand how to rewrite this using singletons? https://pastebin.com/raw/pZf2mP8s
02:08:45 <merijn> kuribas: Because mysql is a terrible RDBMS :)
02:08:51 <kuribas> merijn: in what way?
02:09:04 <tdammers> in not actually being a proper RDBMS
02:09:09 <dminuoso> kuribas: https://github.com/MichaelXavier/drifter-postgresql/blob/master/src/Drifter/PostgreSQL.hs -- Im willing to bet it would be no harder than this.
02:09:55 <kuribas> dminuoso: well... ok.  But our databases are shared between apps and even clients.  So it's not usuable for us.
02:09:59 <merijn> kuribas: In terms of both performance and bug/issue rate. Except for some very niche scenarios postgres is just better in both speed, flexibility, and safety
02:10:02 <dminuoso> kuribas: Yeah fair enough
02:10:55 <kuribas> merijn: still, sometimes you don't have a choice
02:11:06 <kuribas> I don't think migrating is an option for us
02:11:17 <fen> kuribas: i can find this; http://hackage.haskell.org/package/opaleye-0.6.7003.1/docs/Opaleye.html
02:11:22 <merijn> kuribas: Sure, not saying you should migrate, just answering the "why is mysql so unloved" question.
02:11:38 <kuribas> merijn: yeah
02:11:48 <dminuoso> fen: except opaleye is postgres
02:11:55 <merijn> kuribas: The answer is "haskellers are obviously attracted to the more correct postgres and so far no one has been stuck like you, so no one cared to implement a mysql backend (until now)"
02:12:29 <kuribas> merijn: I started making a selda backend, then I quit because it's rather ugly
02:12:35 <fen> isnt there a way to make a DSL that could target any of these industry bound SQL varients?
02:12:58 <merijn> fen: Is there a way? Sure. Will it be a lot of work? yes. Will it be worth it? Maybe...
02:13:03 <kuribas> merijn: now my idea is to make something a bit less low level that mysql-simple
02:13:27 <__monty__> fen: The common subset wouldn't be hard probably. But then you'll get people complaining they can't use implementation-specific features without breaking the abstraction.
02:13:29 <merijn> fen: Persistent, Selda, and opaleye try something like that. But generally you really want those implementation details when implementing for a specific database
02:13:36 <fen> right, you wouldnt want to have to keep up to date with *all* the varients
02:13:37 <dminuoso> fen: Well, in principle it's not that hard since SQL is just relational algebra - which is really easily representable in Haskell.
02:14:38 <kuribas> the problem with selda is that there isn't a 1-1 correspendance between db and hs types.
02:15:01 <kuribas> It only seems to work when you only use the DB in haskell.  Or if you only use sqlite.
02:15:12 <fen> its just that if different companies use different versions they cant migrate from, there is no scope to replace them all with a standard, but if you could gather up all the nesacary features into some kind of standard, you could at least target the traditional backends.
02:15:50 <hololeap> fen: https://hackage.haskell.org/package/beam-mysql
02:16:16 <merijn> fen: There is a standard for SQL, but everyone deviates from it :p
02:16:18 <fen> there should be no harm in asking them to *add* to their common dependencies, like, to support all the features of the standard they would need a backend composed of the thing they normally use, eg mysql, and the extra parts needed
02:17:14 <fen> it would basically just need a makefile or whatever build system to gather up all these sql varients. 
02:17:21 <dminuoso> merijn: Databases deviating from the SQL standard? That cant be. My Oracle is perfectly SQL conform!
02:17:54 <dminuoso> merijn: Can you imagine what `SELECT * FROM people WHERE first_name = '';` might do on Oracle?
02:18:10 <merijn> dminuoso: I've seen the Oracle database code...I would never trust my data to Oracle :p
02:18:12 <fen> merijn: an updated standard to also capture all the extra versions that extend the standard standard 
02:18:25 <dminuoso> merijn: Oh how did that happen?
02:19:01 <merijn> dminuoso: I didn't an internship at Oracle Labs (on something entirely unrelated), but one of my colleagues was working on static analysis of the database code.
02:19:09 <merijn> s/didn't/did
02:19:24 <fen> guess the other option is just to compile from the traditional varieties of SQL into some specific DSL
02:19:37 <dminuoso> Oracle funnily considers empty strings to be NULL, which makes for so many surprises in database abstraction libraries.
02:19:53 <fen> then the user could continue writing in their chosen dialect and not have to worry how the compilation translates it into another subsuming standard
02:19:56 <merijn> dminuoso: Prepares them for the real world ;)
02:20:04 <hololeap> kuribas: https://hackage.haskell.org/package/beam-mysql
02:20:37 <kuribas> beam is to boilerplatey
02:20:53 <merijn> kuribas: Word
02:21:06 <dminuoso> merijn: Ive seen much of the postgres code, its probably one of the best written C projects around (which doesn't say much on a total scale, but in the C world its pretty good)
02:21:15 <merijn> I looked at Beam documentation for like 5 seconds before I glazed over and went "welp...fuck this"
02:21:20 <fen> *and* that would enable people to apply for jobs in companies that use a version other than their preferred dialect and allow them to be used alongside each other 
02:21:29 <hololeap> there's a tutorial. it's not that bad in practice
02:21:43 <dminuoso> merijn: Im too afraid to ask for details on the oracle code. ;)
02:21:47 <hololeap> and it manages to do more than persistant without using template haskell
02:22:07 <fen> even if you cant directly translate one dialect into another that would allow people to read each others queries! 
02:22:34 <fen> maybe everyone would learn to read the new standard and could continue to generate it from their native dialect
02:22:47 * hackage yesod-auth-hashdb 1.7.1.1 - Authentication plugin for Yesod.  https://hackage.haskell.org/package/yesod-auth-hashdb-1.7.1.1 (paulrouse)
02:24:25 <fen> you couldnt help me translate something into using singletons could you? i cant really understand how it works enough to translate the example on my own
02:26:06 <fen> trying to read; http://hackage.haskell.org/package/singletons-2.5.1/docs/src/Data.Singletons.Internal.html#Sing
02:26:10 <fen> not really helping
02:26:24 <merijn> fen: singletons is dark voodoo :p
02:26:30 <merijn> fen: Have you read the related papers?
02:26:47 <fen> its not the concept thats the problem
02:27:12 <fen> just trying to actually translate the example 
02:29:32 <fen> i guess the key conceptual difficulty is how having a type level version of a datatype is actually the way to solve the current problem
02:30:06 <fen> basically, i think I understand the example about as much as Singletons... partially at best, and converting between the 2 is seemingly impossible
02:31:07 <merijn> fen: Let's rewind a bit, what is the goal of working with singletons/whatever example you were talking about?
02:31:21 <fen> so reading about singletons isnt going to help understand the example, which is what would be needed to translate it. possibly though, when it is translated, both the way singletons solve the problem, and exactly what the problem was to begin with, will be more clear
02:32:05 <merijn> fen: Which example are we talking about?
02:32:15 <fen> merijn: basically, singletons seem to do exactly what is needed
02:32:16 <fen> https://pastebin.com/raw/pZf2mP8s
02:32:36 <fen> its attempting to do what singletons seems to manage to do properly
02:32:44 <merijn> Which is trying to do what?
02:32:52 <fen> thats what isnt properly understood
02:33:03 <fen> which is making all this very difficult
02:33:14 <fen> something about "gathering up constructors"
02:33:54 <fen> there were numerous failed attempts to articulate this better, but basically all seeming to just give bad descriptions of singletons
02:34:18 <fen> so the better approach seems to be - assuming this needs singletons - etc 
02:34:43 <fen> "whats it trying to do" = use singletons
02:34:43 <merijn> I find it hard to formulate problems I understand well in singletons, let alone problems I don't understand well
02:35:13 <fen> basically if it were written using singletons you could understand it
02:35:19 <fen> but it isnt
02:37:03 <dminuoso> A coconut is just a nut, right?
02:37:32 * dminuoso chuckles
02:37:47 <merijn> dminuoso: I prefer hot a
02:38:07 <dminuoso> merijn: Heh
02:38:41 <merijn> dminuoso: Not to be confused with Apple's UI framework ;)
02:40:28 <fen> yeah its really not going to help to try and describe again what this is trying to do
02:40:44 <fen> what would be helpful is to see a vserion of it written using singletons!
02:41:17 <fen> hopefully the code can speak for itself...
02:45:01 <dminuoso> Oh my, there's also cocone in CT.
02:46:03 <Taneb> I reckon Sanders Mac Lane was behind a lot of these, but he must have had nspirators
03:04:37 <dminuoso> Taneb: Oh that's clever. Took me a while.
03:10:35 <dminuoso> Are all universal constructions representable as a terminal object in the category of cones for some diagram D?
03:12:21 <dminuoso> Or what is the link between limits and universal properties here?
03:15:34 <dminuoso> As far as I have processed it, every universal property is equivalent to a limit for some diagram D, and that limit is just the terminal object in the category of cones for that diagram.
03:55:51 <fen_> what does singletons do?
03:59:31 <fen_> how can i write as a constraint that something is a particular singleton?
04:02:41 <fen_> do you just use a kind constraint?
04:03:27 <fen_> because the value === type then gives type === kind, and then it serves as a sort of type equality or membership?
04:03:47 <fen_> not a kind constraint sorry, a kind annotation
04:06:56 <fen_> % :k SBool True
04:06:57 <yahb> fen_: ; <interactive>:1:1: error:; Not in scope: type constructor or class `SBool'; Perhaps you meant `Bool' (imported from Prelude)
04:09:04 <fen_> % data SBool (b :: Bool) where   SFalse :: SBool False ;  STrue :: SBool True
04:09:04 <yahb> fen_: 
04:09:16 <fen_> % :k SBool True
04:09:16 <yahb> fen_: SBool True :: *
04:09:21 <fen_> % :kind! SBool True
04:09:21 <yahb> fen_: SBool True :: *; = SBool 'True
04:09:47 <fen_> % :kind! (a :: SBool b)
04:09:47 <yahb> fen_: ; <interactive>:1:2: error: Not in scope: type variable `a'; <interactive>:1:13: error: Not in scope: type variable `b'
04:10:05 <fen_> % :kind! (forall a b. a :: SBool b)
04:10:05 <yahb> fen_: ; <interactive>:1:25: error: Not in scope: type variable `b'
04:10:18 <fen_> % :kind! (forall a. a :: forall b. SBool b)
04:10:18 <yahb> fen_: ; <interactive>:1:12: error:; * Expected kind `forall (b :: Bool). SBool b', but `a' has kind `k0'; * In the type `(forall a. a :: forall b. SBool b)'
04:10:24 <fen_> !!!! >:(
04:11:26 <fen_> % :kind! (forall a. a :: SBool a)
04:11:26 <yahb> fen_: ; <interactive>:1:23: error: Not in scope: type variable `a'
04:11:43 <fen_> :'-(
04:12:53 <fen_> this sucks
04:22:03 <fen_> so wait, is it that instead of having a *constraint* on some type, that it is the member of some collection, instead you just mention that type in a singleton datatype, and that serves as this kind of constraint?
04:22:34 <fen_> its not a constraint though is it because you could write the wrong thing at type level, corresponding to not having a constructor which could return this
04:23:27 <fen_> the point is you want to throw a type error if the wrong thing is supplied as a parameter to the singleton
04:24:02 <fen_> mayeb something like SingInstance or something does this?
05:39:47 * hackage attoparsec-data 1.0.4.1 - Parsers for the standard Haskell data types  https://hackage.haskell.org/package/attoparsec-data-1.0.4.1 (NikitaVolkov)
05:42:46 * hackage hasql-pool 0.5.0.2 - A pool of connections for Hasql  https://hackage.haskell.org/package/hasql-pool-0.5.0.2 (NikitaVolkov)
05:51:17 * hackage ron-rdt 0.6 - Replicated Data Types (RON-RDT)  https://hackage.haskell.org/package/ron-rdt-0.6 (cblp)
06:12:16 <fen_> ok this is as close as I can get; https://pastebin.com/raw/2JsJLmXT
06:12:30 <fen_> it does not use singletons and instead passes around a Proxy 
06:12:44 <fen_> this is because Basecase has kind * -> * -> *
06:12:53 <fen_> which means it cant be returned by a type family
06:13:04 <fen_> which is really annoying
06:13:15 <fendor_> what is the correct way to set up a project with cabal? E.g. is there an equivalent to stack init/stack new?
06:13:37 <dminuoso> fendor_: cabal init
06:13:57 <fen_> it ends up with;  type State   (x :: Proxy b) s a = s -> b s a
06:14:02 <dminuoso> fendor_: It just boils down to creating a cabal file and your Setup.hs, nothing more.
06:14:12 <dminuoso> Perhaps a LICENSE file, a README and a CHANGELOG file if you like..
06:14:33 <fendor_> dminuoso, , thanks! 
06:15:01 <Solonarv> dminuoso: actually it will also create stub Main.hs and/or MyLib.hs
06:15:18 <fen_> which is no good, it is not the correct thing at all... but the `b' cant be unpacked from the proxy any earlier or ghc complains about it not having kind *
06:15:53 <dminuoso> Solonarv: I actually smiled, imagining someone being unable to create their own file for Haskell code..
06:15:56 <fen_> not sure if singletons would be able to help with that, not really sure how they work at all tbh
06:16:05 <fendor_> holy, cabal init is completely interactive, rather cool!
06:16:09 <dminuoso> But I guess there is the issue of needing to know to add the modules to your cabal file..
06:16:39 <dminuoso> fendor_: Yeah its great. :)
06:16:57 <Solonarv> cabal 3.0 even has a mode where it doesn't ask you any questions at all (intended for beginners)
06:17:07 <dminuoso> Solonarv: Does it also generate my program code for me?
06:17:16 <fen_> there seemed to be something that looked promising, "Demote" but this extracting something from a Proxy seems almost equivalent 
06:17:16 <dminuoso> In a non-interactive way?
06:17:23 <fendor_> I still want some template, like the haskeleton from stack.
06:17:23 <Solonarv> dminuoso: if your program is hello world, then yes
06:17:25 <Solonarv> (IIRC)
06:18:26 <fen_> https://hackage.haskell.org/package/singletons-0.9.0/docs/src/Data-Singletons-Core.html#SingKind
06:18:37 <Solonarv> $ cabal init
06:18:37 <Solonarv> Should I generate a simple project with sensible defaults? [default: y]
06:18:51 <Solonarv> I don't remember what precisely it puts down
06:19:11 <Solonarv> fendor_: cabal doesn't support any sort of template, but there is a tool called 'summoner' that might interest you
06:19:30 <Solonarv> @hackage summoner
06:19:31 <lambdabot> http://hackage.haskell.org/package/summoner
06:20:17 <fendor_> thanks! 
06:20:25 <fendor_> cabal init was enough for this though :)
06:21:12 <dminuoso> fendor_: You can create a small tarball containing the skeleton you like and then untar it into every project.
06:21:31 <dminuoso> If thats your thing.
06:22:40 <fendor_> yeah, I can, but I think the advantage of templates is that new people can easily create a good project structure which helps them with early project development
06:22:55 <fen_> any ideas how to pass something of the correct kind to State and Costate in this; https://pastebin.com/raw/2JsJLmXT possibly using singletons
06:22:57 <fen_> ?
06:23:55 <dminuoso> fendor_: I have never understood why people think such a skeleton would help, so I cant relate.
06:24:44 <fendor_> dminuoso, that's fine, it is my opinion, not the truth :)
06:25:33 <fendor_> it would be hilarious though, if cabal init asked you whether you want to use hpack or .cabal files.
06:28:42 <fen_> it seems like it would end up with trying to make the GADT into a type family which returned the correct type from kind * labels 
06:28:59 <fen_> as these could be passed around without using a Proxy
06:29:24 <fen_> theres got to be a better way
06:39:36 <dmwit> fen_: Turn on TypeInType and write `type State (x :: Proxy (b :: * -> k -> *)) s a = s -> b s a`.
06:40:26 <dmwit> Oh, in fact, turning on TypeInType is enough without even changing the rest of the source at all.
06:42:10 <dmwit> But, uh... why bother having FlatBase and b and friends at all?
06:42:30 <dmwit> The only possible implementation of FlatBase is Proxy, and it isn't used anywhere anyway.
06:42:33 <fen_> wow! TypeInType to the rescue!
06:42:44 <dmwit> So why not just `type State s a = s -> Basecase s a`?
06:42:47 <fen_> dmwit: huh?
06:43:23 <fen_> no thatw just the same :-(
06:44:09 <dmwit> The same as what, exactly?
06:44:28 <fen_> type State (x :: Proxy b)
06:44:45 <fen_> the annotation to `b' is inferred anyway
06:45:09 <dmwit> fen_: https://gist.github.com/dmwit/a0f01d50518113f8e1c6a6088f3270 <- no TypeInType needed
06:45:24 <fen_> 404
06:45:32 <dmwit> (And you can do exactly the same things with this that you could with yours.)
06:45:58 <dmwit> https://gist.github.com/dmwit/a0f01d50518113f8e1c6a6088f3270f0 <- somehow didn't paste the last two characters of the URL, sorry
06:46:55 <fen_> but now there is no Basecase associated to f !
06:47:09 <dmwit> There never was.
06:47:14 <dminuoso> Okay so I have the ultimate heisenbug in my Haskell program. Compile with debugging enabled, no hang. Adding mild printf debugging, no hang. Almost no noise, process appears hung with no indication why.
06:47:28 <dmwit> Perhaps this is the actual bug: you thought there was, but there wasn't, so you've set something up wrong.
06:47:33 <fen_> ah
06:47:45 <dmwit> As usual I've no idea what you're trying to do, though, so I can't really help you fix it.
06:47:47 <fen_> so Proxy Basecase does not actually choose a particular basecase
06:48:09 <dmwit> nope
06:48:22 <fen_> how does that concept of "choosing" one of the constructors to be associated not make sense?
06:48:29 <fen_> because thats all im trying to do
06:48:50 <dmwit> I didn't say it doesn't make sense. Just that the code you've posted doesn't do that.
06:49:00 <fen_> this is true...
06:49:20 <fen_> thought maybe singletons could do that
06:49:44 <fen_> like you could have a class so that eg there was an associated 'True
06:50:00 <fen_> and then this could be used some other place too
06:50:22 <dmwit> % data Huh = A'
06:50:22 <yahb> dmwit: 
06:50:26 <dmwit> % :k 'A'
06:50:26 <yahb> dmwit: ; <interactive>:1:1: error: parse error on input '
06:50:41 <dmwit> % :set -XDataKinds
06:50:41 <yahb> dmwit: 
06:50:44 <dmwit> % data Huh = A'
06:50:44 <yahb> dmwit: 
06:50:46 <dmwit> % :k 'A'
06:50:46 <yahb> dmwit: ; <interactive>:1:1: error: parse error on input '
06:51:21 <Solonarv> % :k A' -- ;)
06:51:21 <yahb> Solonarv: A' -- ;) :: Huh
06:51:54 <dmwit> % :k ' A'
06:51:54 <yahb> dmwit: ' A' :: Huh
06:52:15 <Solonarv> oh yeah I keep forgetting the tick doesn't have to be stuck to the identifier
06:52:16 <dmwit> I didn't know you could put whitespace after the tick.
06:52:43 <fen_> this was as far as I got trying to use 'Bool instead of the version with State etc
06:52:43 <fen_> https://pastebin.com/p8yj782z
06:52:50 <dminuoso> o.o
06:52:52 <fen_> it might make a shorter template to work from
06:52:54 <dminuoso> Solonarv: Whats the usecase for that?
06:54:50 <dminuoso> Unrelatedly, is there a tool to visualize the external package depencies of a cabal package?
06:54:53 <fen_> oh so maybe I could use a Proxy over a singletons...
06:55:11 <dmwit> fen_: You know about defunctionalization? Seems relevant here.
06:56:15 <fen_> yeah
06:56:17 <fen_> how?
06:57:35 <Solonarv> dminuoso: for what? whitespace after the tick? *shrug*
06:57:41 <fen_> dmwit: maybe this does what it was supposed to almost; https://pastebin.com/raw/ZkHc212B
06:58:03 <Solonarv> ticking identifiers whose second character is a ', of course!
06:58:18 <fen_> sorry forgot to delete the comments
06:58:36 <dmwit> e.g. something like `data BCConstructor = LinearC | StreamC | StackC; type family Eval x where Eval LinearC = Linear'; Eval StreamC = Stream'; Eval StackC = Stack'`
06:59:17 <dmwit> So that it becomes `class Flat f where type BC f :: BCConstructor` or so.
06:59:42 <fen_> oh right to avoid the Proxys
06:59:53 <dmwit> type State c s a = s -> Eval c s a
07:00:07 <fen_> yeah, something like that, and then something to use that param for the data basecase
07:00:39 <fen_> oh right you replaced that with Eval
07:01:07 <fen_> wait what? how is it returning the Constructors?
07:01:09 <dmwit> Ah, perhaps you can even get away with using the plain old functionalized version. One moment.
07:04:19 <dmwit> ...nope, I've lost my grasp on the thread I had. I once again don't really understand what you're trying to accomplish.
07:04:46 <fen_> but the code pasted seems to do exactly what its suppsed to
07:05:16 <fen_> it just is annoying because of how it has to use a proxy because the kind * -> * -> * constructor cant be passed around 
07:05:37 <fen_> its just supposed to be assigning a constructor to a container
07:05:49 <fen_> well, a Constructor of Basecase
07:06:10 <fen_> which is similar to associating a 'True value for example
07:06:20 <fen_> but that has the correct kind for not using a proxy
07:06:38 <fen_> thats where the idea of BCConstructor was from
07:18:03 <fen_> like this; https://pastebin.com/raw/12sPsAQC
07:19:02 <dminuoso> Whats the correct way to adjust a package for say SMP to be compatible with all GHC versions? Bunch of `#if MIN_VERSION_base(...)` macros?
07:19:13 <fen_>  it does not need the LinearC argument to Basecase....
07:19:28 <fen_> but that gives a wierd kind of singleton for this style
07:19:46 <fen_> its not a good style, but its slightly better than having to pass round a proxy
07:20:31 <fen_> in this way of doing it it needs an "Eval" class for each GADT
07:20:55 <fen_> which almost makes sense as its sort of like making a type level version of a function alongside a value level version
07:21:41 <fen_> its annoying because its like some kind of tagged TypeRep or something
07:23:50 <Solonarv_> dminuoso: pretty much
07:25:29 <fen_> argh crap this is the only way to do it isnt it
07:25:45 <Solonarv_> you can make a header file with a bunch of macros like #define HAVE_DERIVING_VIA MIN_VERSION_base(4, 12, 0)
07:27:40 <fen_> the reason it seems not as good is because you should be able to just have '[Stream,Linear] etc, and now you have to have '[StreamC,LinearC]
07:27:57 <fen_> so its basically failed to do what it was supposed to and use the constructors
07:28:14 <fen_> or rather, use a GADT to "gather" a bunch of constructors
07:28:30 <fen_> so that they are "instances" of some sort
07:28:46 <fen_> like, a restriction over all possible kind * -> * -> * things
07:29:09 <fen_> that was the idea. so this *works* as the paste above, but it does not do what it was supposed to essentially
07:30:24 <fen_> while the version with the "closed class type family" managed it perfectly, except at the expense of not having any constructors to match on
07:30:35 <fen_> ok, this is just frustraiting
07:30:40 <fen_> byw
07:31:21 <dminuoso> Solonarv_: Mmm I guess that would be workable
07:42:47 * hackage bound-extras 0.0.1 - ScopeH and ScopeT extras for bound  https://hackage.haskell.org/package/bound-extras-0.0.1 (phadej)
07:53:47 <odumichthys> Hello! How is everyone? I've recently started learning Haskell and find it to be a fascinating language.
07:53:59 <dminuoso> Hiya, odumichthys.
07:53:59 * dmwit waves
07:54:11 <Solonarv_> o/
08:05:48 <pauline> hola
08:05:59 <pauline> i need a cvv 
08:07:16 <Solonarv> pauline: you need what?
08:09:18 <odumichthys> Heya dminuoso, Solonarv 
08:09:18 <[exa]> card verification value?
08:09:24 <odumichthys> Hello pauline 
08:10:29 <tdammers> curriculum vitae vitae?
08:12:18 <odumichthys> Does anyone use VSCode?
08:13:40 <Solonarv> I did/dp
08:13:48 <odumichthys> Or intero? Small issue of intero not recognizing my test suites and I've absolutely forgotten how to configure intero to do this.
08:14:07 <odumichthys> Or intero? Small issue of intero not recognizing my test suites and I've absolutely forgotten how to configure intero to do this.
08:14:09 <Solonarv> oh, I haven't used intero in a long time and never configured it myself at all
08:14:21 <odumichthys> Woops. Meant to type an error I was getting*
08:15:30 <odumichthys> Oh? How do you handle autocompletion? I ended up in this because I set up Haskero (Haskelly wasn't autocompleting) 
08:16:19 <Solonarv> well, intero requires stack and I stopped using stack a while back
08:17:04 <Solonarv> I use(d) vscode-ghc-simple which worked very well until I switched to cabal head
08:17:14 <Solonarv> now I just use ghcid and live without autocomplete
08:17:45 <Solonarv> haven't bothered to set up any plugins for vim yet other than basic syntax support
08:19:14 <odumichthys> Wait wait wait, why'd you stop using stack? Like, just as a preference or is there some outstanding issue I'm bound to encounter?
08:19:26 <[exa]> did you guys notice that turning autocomplete off somehow automagically increases quality of APIs? :]
08:20:33 <Solonarv> pretty much just preference
08:21:12 <[exa]> odumichthys: many people now prefer simpler solutions that do the same job just right
08:21:15 <Solonarv> mostly I got fed up with the hoops I have to jump through to get a package that isn't in whatever snapshot I'm using
08:21:45 <Solonarv> [exa]: that too
08:26:38 <dminuoso> odumichthys: Ever since cabal has gotten the new-* set of commands, stack doesn't have a clear cut advantage anymore.
08:27:25 <Solonarv> pretty much that, yeah
08:27:30 <halogenandtoast> I am looking to build an 18xx engine in Haskell, one aspect is to represent the board, which are a bunch of hex spaces, I care about adjacency here, is there a good way to model this?
08:28:15 <halogenandtoast> for reference 18xx is a style of boardgame, the main issue is a good way to represent a hex grid of sorts
08:28:15 <Solonarv> well, on windows stack still has some advantage especially if you don't want to upgrade to cabal head
08:28:22 <odumichthys> dminuoso, I don't know, autocomplete / linting is really big for me.
08:30:18 <Solonarv> halogenandtoast: I stumbled on this article a good while ago, perhaps it's helpful: https://www.redblobgames.com/grids/hexagons/
08:30:26 <Solonarv> (not haskell, but that shouldn't matter too much)
08:30:30 <dminuoso> odumichthys: You dont need stack to get linting, that is supplied by hlint generally.
08:31:31 <odumichthys> dminuoso, in vscode though? I guess my current issue is finding a good IDE; I also use python3.
08:31:32 <Solonarv> and likewise intero isn't the only way to get autocomplete; there is some support for that in recent GHCs directly, and there is also haskell-ide-engine
08:31:46 <Solonarv> for vscode I would recommend the vscode-ghc-simple plugin
08:32:05 <dminuoso> odumichthys: No idea, I use emacs so I have flycheck.
08:32:30 <Solonarv> works on all kinds of haskell projects (with auto detection!) and has autocomplete, error squiggles, and a bunch of other features I forget
08:33:53 <Solonarv> and there appear to be two extensions which integrate hlint into vscode
08:34:43 <halogenandtoast> Solonarv: thanks I will give it a look, sorry for the delay had a dog fight I had to break up
08:35:27 <dminuoso> Autocomplete probably works with something like ctags in most editors if you want..
08:35:27 <dminuoso> But I have never found autocomplete to be that important, honestly.
08:35:49 <Solonarv> oh yeah you can probably also spin hasktags into autocomplete somehow
08:35:57 <Solonarv> dminuoso: I agree, at least in Haskell
08:36:27 <odumichthys> I guess I'm just paranoid about a typo being the thing that stops my code from working?
08:36:47 <Solonarv> it's more important in languages with really verbose names (Java) or that don't check identifiers at compile time
08:36:57 <dminuoso> odumichthys: The compiler will catch that instantly.
08:37:09 <Solonarv> odumichthys: if you make a typo you will simply get a compiler error, not an incorrect program
08:37:16 <dminuoso> odumichthys: If you run ghcid in a different window, you spot it instantly too.
08:37:34 <Solonarv> well unless you have a bunch of really similar identifiers where you can easily mistype one instead of the other
08:37:46 <Solonarv> but autocomplete wouldn't stop you from making a mistake there either
08:38:41 <odumichthys> ...true...okay.
08:39:55 <dminuoso> odumichthys: Dont understand me wrong, I can sympathize why one might want it - but I wouldn't let those things dictate an editor for me.
08:40:01 <odumichthys> I will depend less on the "features" and more on my own skills.
08:40:16 <asheshambasta> So when using libraries that have external shared library dependencies; what is the best way to tackle issues like this during build? https://gist.github.com/asheshambasta/2b90c8c706e24791656d9ceb8d67a6eb
08:41:03 <asheshambasta> I'm running Manjaro and a recent upgrade upgraded the icu package; which is causing the issue. I've tried downgrading the icu package; which doesn't let me boot into a gui.
08:41:21 <[exa]> odumichthys: btw it's great to have a good _editor_. If you have 5 minutes, try e.g. going through vimtutor
08:42:08 <Solonarv> asheshambasta: perhaps you can somehow have libicuuc.so.63 at the same time as whatever the new version is? or symlink .63 to point at the new version, and hope the ABI is compatible?
08:42:34 <Solonarv> honestly, vscode is a pretty good editor
08:44:45 <odumichthys> [exa], vim is super strong. The vscode just ended up being one of familiarity (plus I had it already setup from the python environment).
08:45:14 <odumichthys> Though, I did have an issue where I couldn't get vim to compile with python3 that I never got around to resolving....should probably do that at some point.
08:45:40 <asheshambasta> Solonarv: yeah, seems like something I can try 
08:45:41 <odumichthys> But I just really like vscode at the moment.
08:45:51 <[exa]> vim compilation depends on python3?
08:46:37 <odumichthys> Not exactly, but I was attempting to test scripts from the editor with `:python` or `:python3` but would get a version error. 
08:47:11 <Solonarv> oh, that's what you meant
08:47:21 * Solonarv hasn't used python in quite a while either
08:47:23 <odumichthys> And if I did a `| grep python`, then there was a nice little `- python` present.
08:49:08 <asheshambasta> Solonarv: actually, the .so exists 
08:50:25 <Solonarv> huh, weird
08:50:44 <Solonarv> then I have no idea
08:51:58 * odumichthys is trying to get a job so uses python frequently.
08:55:08 <asheshambasta> Solonarv: https://gist.github.com/asheshambasta/2b90c8c706e24791656d9ceb8d67a6eb#file-cmd-txt -- just looks like the  file cannot be found; for whatever reason. 
08:55:23 <adamCS> Solonarv: which extensions do you use in vscode for Haskell?  I'm gonna give it a try but there's quite a few.  I don't use stack and I do love the ghcid feedback loop so that's what I am going for.
08:57:22 <Solonarv> adamCS: one of ghcid or vscode-ghc-simple, and the basic syntax support extension
08:58:03 <Solonarv> I meant to set up some more but I'm switching to vim anyway so I probably won't bother
08:59:14 <cheers> https://github.com/haskell/haskell-ide-engine is the most "official" editor extension, iirc
08:59:21 <Solonarv> asheshambasta: my only guess is that stack fucks with LD_LIBRARY_PATH somehow
08:59:41 <Solonarv> cheers: yes, but it's a bit heavyweight and I've had some trouble getting it to work
09:00:01 <cheers> ah
09:00:52 <adamCS> Solonarv, cheers: Thanks!  I tried the ide-engine thing with emacs but it uses a lot of CPU somehow?  Making it kind of an issue on a laptop.  I have a pretty good emacs setup but I like to try new things...Solonarv, why switching to vim?
09:01:50 <Solonarv> I'm on a pretty weak laptop and vim is much, much lighter than anything else
09:01:56 <cheers> i haven't noticed particularly heavy resource usage, but i have a decently modern computer
09:02:38 <Solonarv> so I decided to try vim again for the sake of system resources, and I'm enjoying it enough that I think I'll stick to it
09:02:43 <adamCS> cheers: It may have been my setup or emacs.  My computer is modern as well but it was still at 99% on one CPU a lot of the time.  
09:03:17 <cheers> hmm, strange
09:03:25 <cheers> i'm using it with vim, for what it's worth
09:26:19 <bandali> people using org domains need to be aware of this and raise their voice:
09:26:21 <bandali> https://tech.slashdot.org/story/19/04/23/2330210/icann-proposes-allowing-unlimited-fee-increases-for-org-domain-names
09:36:17 * hackage primitive-atomic 0.1.0.0 - Wrappers for primops around atomic operations  https://hackage.haskell.org/package/primitive-atomic-0.1.0.0 (andrewthad)
09:43:33 <asheshambasta> So, at this point I'm about to give up and get rid of the dependency that is causing the .so issue
09:44:42 <LRB> I'm just joining again to talk about something I came across in the book I'm learning from. Function Composition is *so cool*
09:44:48 <asheshambasta> I've tried the recommended methods of removing .stack-work; ~/.stack/... and those are definitely not the issues. And it seems like these "FFI" like dependencies are a sure way to hell 
09:46:06 <Solonarv> yeah, foreign dependencies are often quite annoying
09:46:57 <asheshambasta> I can only imagine the pain something like this may cause with CI and the significant "management" overhead caused as well
09:47:52 <berndl> Anyone familiar with csound-expression?
09:49:40 <odumichthys> Be back later. Thanks for the assistance thus far!
09:50:40 <asheshambasta> this seems to be culprit in my case: https://github.com/christian-marie/phone-numbers/blob/master/phone-numbers.cabal
09:55:16 * hackage ron-schema 0.6 - RON-Schema  https://hackage.haskell.org/package/ron-schema-0.6 (cblp)
09:59:47 * hackage ron-storage 0.7 - RON Storage  https://hackage.haskell.org/package/ron-storage-0.7 (cblp)
10:03:03 <wolfman154> 11:00 wolfman154: Hello there, I just did a fresh install of nixos 19.03, when I copied and pasted a file from my usb to my laptop , the processor goes full speed , I think it’s an infinite loop, also I noticed I’ve been having this problem with gnome3, why is this happening?
10:04:15 <srhb> wolfman154: Wrong channel?
10:47:47 * hackage fin 0.0.2 - Nat and Fin: peano naturals and finite numbers  https://hackage.haskell.org/package/fin-0.0.2 (phadej)
10:48:47 * hackage vec 0.1.1 - Vec: length-indexed (sized) list  https://hackage.haskell.org/package/vec-0.1.1 (phadej)
10:55:25 <fen> now i have this type error; https://pastebin.com/raw/RkZVjFaR
10:58:35 <fen> why cant it see the instance is given?
11:01:40 <fen> if its something to do with it not being able to check instances through a Proxy, how else can the class Eval be used?
11:06:55 <stylewarning> What's the recommended way to install GHC & Co. on a Mac? brew? Haskell Platform binaries?
11:07:13 <glguy> I recommend: haskell.org/ghcup
11:07:49 --- mode: glguy set -bo *!*@*/gruntmaster6000 glguy
11:08:10 <stylewarning> glguy: What's the difference between this vs. other methods?
11:08:40 <glguy> This makes it easy to pick which version of GHC you get and to have multiple installed, to uninstall them, etc
11:08:45 <fen> here is the same error, but not using Proxy; https://pastebin.com/raw/V8Hpbxvb
11:08:49 <fen> so it cant be that...
11:09:21 <glguy> homebrew is going to give you whatever version they have at the moment and that can change out from under you when they decide to update, not so good for development
11:09:47 * hackage boring 0.1.1 - Boring and Absurd types  https://hackage.haskell.org/package/boring-0.1.1 (phadej)
11:10:29 <glguy> it's just a shell script that knows how to download the binary distributions and install them in a directory, switch between then, etc. It's quite lightweight
11:11:08 <monochrom> Haha phadej what have you done?!
11:11:19 <phadej> monochrom: ?
11:11:33 <shapr> I love ghcup
11:11:34 <monochrom> The boring package!
11:11:36 <shapr> it's so great!
11:12:06 <phadej> monochrom: what about it?
11:12:59 <monochrom> To build so much abstraction over () and Void. I find it funny but I am not against it!
11:13:08 <fen> even with fundeps it seems not to be able to resolve what the fundeps say it should; https://pastebin.com/raw/sCMyPBDW
11:14:14 <Flonk> what was that lambdabot command that turns a function point-free again?
11:14:31 <monochrom>  @pl
11:14:36 <Flonk> Ah, right. Thanks
11:14:45 <monochrom> The l stands for "less".
11:14:52 <phadej> monochrom: it makes stuff less boring when you can (with vec e.g.) write 1 ::: True ::: String ::: boring
11:14:59 <phadej> monochrom: it makes stuff less boring when you can (with vec e.g.) write 1 ::: True ::: "String" ::: boring
11:15:26 <fen> is it something to do with classes not working at type level?
11:15:56 <monochrom> Actually did you consider naming your package "boring-and-absurd"? Because it also contains absurd.
11:16:34 <monochrom> Also how about "duh-and-doh" OK I'm going overboard now. :)
11:16:50 <phadej> monochrom: well, it's been there for 1.5 years already; so "too late" :)
11:17:54 <phadej> also the class names are from the methods they have; and both names have history :)
11:18:24 <phadej> anyway, yes, it's almost acme-* package; but I actually use it somewhere
11:18:44 <phadej> (e.g. to overload absurd over Void and Fin 'Z)
11:21:15 <monochrom> "The Absurd type is very exciting" haha
11:22:24 <monochrom> But yeah there are a number of types that end up being isomorphic to () or Void, so some general suite of functions that work for all of them is convenient.
11:22:54 <monochrom> (More precisely, a number of types that people actually define and/or use.)
11:23:22 <Solonarv> I love the documentation :>
11:23:33 <monochrom> Wait a second, I thought I swore I would never say "isomorophic" again...
11:24:11 <Solonarv> I name you forsworn! your power is void!
11:24:11 * ski . o O ( "isomoronic" )
11:24:42 * Solonarv . o O ( my power is boring! )
11:24:45 <fen> even this doesnt work! https://pastebin.com/16TdJ1j3
11:25:43 <phadej> Solonarv: it's copied (with permission) from https://stackoverflow.com/questions/33112439/what-does-mean-in-haskell/33115522#33115522
11:26:08 <monochrom> Wait a second! "More integeresting stuff" --- is "integeresting" a typo?  Deliberate?
11:26:09 <Berengal> When using scoped type variables, do I have to use forall to bring the variable into scope?
11:26:59 <lyxia> yes
11:28:04 <Solonarv> Berengal: or a type signature on a pattern match
11:28:33 <monochrom> Oh! So that's really why PatternTypeSig is merged with ScopedTypeVar.
11:28:40 <Solonarv> yep
11:30:10 <fen> oh this works; https://pastebin.com/raw/GPuMM85J
11:30:15 <ski> unfortunately no result pattern signatures, though
11:30:19 <fen> must have been something to do with the foralls.
11:30:23 <monochrom> Now I can write like SML again!  f (x :: a) = x :: a
11:31:53 <Solonarv> ski: I think there's a GHC proposal for that
11:31:56 <ski> i'm not satisfied if i can't write
11:32:01 <ski>   f (x :: a) :: a = x
11:32:24 <monochrom> One step at a time!
11:33:08 <ski> as long as they're not steps in the wrong direction
11:33:14 <reallymemorable> Is there a notion of casting types in Haskell?  I have a specialized quantiative type that can be used as a `Double` but is not a Double and I would like to cast it into that
11:33:21 <monochrom> I also tend to think that "f (x::a) :: a = ..." is a relic of Pascal syntax.
11:34:28 <monochrom> Yes. On condition that your "non-Double" value is internally a Double.
11:34:29 <ski> well, in Pascal, you assign the result value to the function itself
11:34:39 <ski> (in Ada also, i think ?)
11:34:45 <geekosaur> otherwise you can have conversion functions, but there is no casting as such
11:35:04 <monochrom> Yeah cast ≠ convert
11:35:26 <reallymemorable> Oh so apparently it's Int64
11:35:30 <reallymemorable> and I need it as a Double
11:35:39 <reallymemorable> so i guess I will write a conversion function
11:35:56 <monochrom> Do the bits inside really mean to be Double bits?
11:36:01 <ski> > cast (pi :: Double) :: Maybe Double
11:36:03 <lambdabot>  Just 3.141592653589793
11:36:03 <ski> > cast (pi :: Float) :: Maybe Double
11:36:05 <lambdabot>  Nothing
11:36:11 <Solonarv> monochrom: something something fastInvSqrt
11:36:35 <monochrom> Wait, fastInvSqrt = fastSquaring?
11:36:47 * ski was just about to say something to the same effect ..
11:36:48 <Solonarv> no
11:37:00 <monochrom> I don't know what's fastInvSqrt.
11:37:03 <Solonarv> but you can apply a similar technique for that
11:37:21 <Solonarv> monochrom: "fast inverse square root"
11:37:36 <monochrom> Well yeah I don't know what's that either.
11:37:54 <Solonarv> let me find a link
11:38:08 <monochrom> NAMES MEAN NOTHING
11:38:11 <Solonarv> https://en.wikipedia.org/wiki/Fast_inverse_square_root
11:38:46 <monochrom> Ho hum why didn't they say "reciprocal".
11:38:59 <Solonarv> an algorithm for estimating the inverse square root of an IEEE float, which involves casting the bits to an int, combining them with a magic number, and casting back to a float
11:39:04 <monochrom> But I guess I explained it. Names mean nothing anyway.
11:39:13 <fen> how can it work for Nothing and not for [] !? https://pastebin.com/g5BrTjxT
11:40:23 <Solonarv> it's less crazy than it sounds at first: the float -> int cast gives you an approximate logarithm
11:40:51 * ski . o O ( "'When *I* use a word,' Humpty Dumpty said, in rather a scornful tone, 'it means just what I choose it to mean — neither more nor less.' / 'The question is,' said Alice, 'whether you *can* make words mean so many different things.' / 'The question is,' said Humpty Dumpty, 'which is to be master — that's all.'" )
11:43:04 <fen> Alice's perceptron sensitivity threshold is set to curious 
11:44:41 <monochrom> Yeah I am not against casting.
11:46:23 <moriarty> Squarism, you're a Haskellian too?
11:46:32 <monochrom> What really happens is every time someone asks "how to cast x to y?" I have to confirm that they really mean take the bits and re-interpret the bits as the target type.  Because C and a couple other thoughtless languages have muddled the water and brainwashed people to use "cast" to mean conversions too
11:46:45 <shapr> Squarism: what else are you?!
11:46:55 <Solonarv> so the operation '(float) ( MAGIC - ((long) f) >> 1)' corresponds to exp( MAGIC - log(f)/2) = exp(MAGIC) / sqrt(f) -- up to some constants which depend on the floating point representation
11:47:48 <moriarty> am i the only one getting some privmsg spam from culito_kpop ?
11:47:57 <moriarty> something about making freenode great again?
11:47:57 --- mode: ChanServ set +o monochrom
11:48:02 --- mode: monochrom set +b culito_kpop!*@*
11:48:06 <Solonarv> moriarty: I don't know if you're the *only* one, but I'm not getting any
11:48:08 <shapr> BAN THEM!
11:48:11 <shapr> hurrah!
11:48:13 <moriarty> cheers monochrom
11:48:16 <Squarism> moriarty, i try
11:48:18 --- mode: monochrom set -b culito_kpop!*@*
11:48:18 <shapr> monochrom: thanks!
11:48:24 <moriarty> looks like culito _kpop got k-lined lol
11:48:24 <monochrom> No I was too late.
11:48:34 <shapr> I got spammed also
11:48:43 --- mode: monochrom set -o monochrom
11:48:47 <c_wraith> a lot of people started blocking privmsg from unregistered accounts in the last spam wars.
11:48:59 <moriarty> thanks for the tip, c_wraith, maybe i should set a +g
11:48:59 <shapr> I can see why now
11:49:01 * ski didn't
11:49:08 <moriarty> hey ski, long time no see :)
11:49:31 <ski> moriarty : was it the freenode-related recent spam/scam ?
11:49:32 <shapr> ski always makes me think of combinators in the snow!
11:49:37 <ski> hehe
11:49:40 * ski doesn't ski
11:49:54 <shapr> ski: I don't either, but I did meet you in Sweden
11:49:58 <moriarty> ski, indeed, i think it happened right around last year :) when they maligned a freenode network operator or two with some garbage from a botnet
11:50:10 <ski> hm, was it in the winter ?
11:50:15 <moriarty> yeah probably
11:50:25 * ski can't recall
11:50:31 <Solonarv> yep I recall some big kerfuffle around that time
11:50:36 <ski> moriarty : anyway, hello
11:51:03 <moriarty> ski, :) i remembered your great mentoring help with prolog, deeply appreciative
11:51:13 <shapr> ski mentors many things!
11:51:15 <shapr> so helpful!
11:51:36 <fen> what about deep stacked genetic autoencoders?
11:51:42 <ski> moriarty : yea, i was just about to say that i didn't recall exactly in which circumstances i had been talking to you, though the nickname looked a bit familiar
11:52:24 <moriarty> ski, apologies, i took a hiatus from freenode for some years, so it was about at least five years or more ago
11:52:34 <ski> (permanent `+g' is admitting defeat, imho)
11:52:56 <fen> i dont think ghc wants me to be able to run this through the type system
11:53:13 <fen> obstinate device
11:53:44 <ski> moriarty : *nod*. the years tend to blend together. i'm sure there are many i was often talking to on Freenode, ten years ago, but where only a few are active still (or again), and that i thus remember
11:53:52 <fen> no inverse type family GADT replacements today :-(
11:54:30 <ski> (though i do remember TheHunter,mmorrow,vixey,ddarius,augustss/lennart .. and probably more, if i think for a while)
11:54:49 <fen> no jam today!
11:55:05 <monochrom> Good riddance!
11:55:36 <odumichthys> Quick question, how would I get Haskell to display a graph of a function?
11:55:59 <Solonarv> odumichthys: pick a plotting library and throw your function at it
11:56:14 <Solonarv> we have one or two, I think 'diagrams' is fairly popular?
11:56:15 <odumichthys> ...there are plotting libraries?
11:56:28 * ski idly ponders the graph of `reverse'
11:57:19 <Solonarv> hm, perhaps I misremembered what diagrams is about
11:57:29 <Solonarv> but yes, there is definitely at least one plotting library
11:57:46 <monochrom> There are a number of plotting libraries.  Some just talk to gnuplot.
11:58:17 <sm> Chart is probably a mature one
11:58:17 <monochrom> (I don't know which are good.  Never tried.)
11:58:39 * ski wasn't aware that they did mentoring, fwiw
11:58:54 <Solonarv> monochrom: same
11:59:34 <sm> GoogleChart is probably an easy one
12:00:30 <Solonarv> odumichthys: here is what looks like a good entry point to Chart: https://hackage.haskell.org/package/Chart-1.9.1/docs/Graphics-Rendering-Chart-Easy.html
12:13:33 <cjay-> can someone recommend a tool for generating call-graphs? SourceGraph appears to be dead
12:20:17 * hackage telega 0.2.6 - Telegram Bot API binding  https://hackage.haskell.org/package/telega-0.2.6 (iokasimovmt)
12:50:47 * hackage morpheus-graphql 0.0.1 - Morpheus GraphQL  https://hackage.haskell.org/package/morpheus-graphql-0.0.1 (nalchevanidze)
13:06:51 <Boarders> is there a good way in Haskell (possibly using template haskell) to find what instances are in scope
13:07:11 <Boarders> I mean a function like listInstances :: a -> IO [String]
13:07:16 <Boarders> that will give me the list of instances of a
13:07:29 <Boarders> that is a terrible type sig for what I want but still
13:07:47 <Cale> yes, let me remember what it is :)
13:09:46 <Cale> ah, right, reifyInstances
13:10:07 <Cale> reifyInstances :: Name -> [Type] -> Q [InstanceDec]
13:11:44 <Cale> Boarders: You sort of have to know which instances you're looking for though.
13:12:10 <Boarders> Cale: thank you
13:12:12 <Boarders> why do you say that?
13:13:15 <Cale> Because you specify the name of the class, and then a list of the types for which you want to search for matching instances
13:13:23 <Boarders> ah ok
13:13:39 <Boarders> so I could take a list of classes I am interested in and the name of the type and see if it has an instance of that type
13:13:46 <Boarders> excluding nonsense like orphan instances and etc
13:15:58 <Solonarv> you can also just call reify on the type's name directly, the returned info includes a list of instances IIRC
13:16:20 <Boarders> oh cool, even better
13:16:23 <Boarders> that is just what I want
13:16:25 <Boarders> thank you
13:16:39 <Boarders> is there a recommended standard source for learning more about Template Haskell?
13:17:26 <c_wraith> well. a list of instances it knows about. that isn't the most reliable or exhaustive list.
13:17:49 <c_wraith> Boarders, the ghc manual + the template-haskell package docs are actually pretty good
13:18:19 <Boarders> what do you mean by that
13:18:38 <Boarders> if I have the module with the class and the module with the data def in scope then that should have all the instances apart from orphan ones
13:18:51 <Boarders> c_wraith: thanks, I 'll give them a look
13:19:28 <c_wraith> yeah, that "apart from orphan ones" matters. :(
13:21:21 <Boarders> it does but not for my purposes :)
13:28:35 <Boarders> $(stringE . show =<< reify ''Bool)
13:29:28 <Boarders> > $(stringE . show =<< reify ''Bool)
13:29:30 <lambdabot>  <hint>:1:1: error:
13:29:30 <lambdabot>      parse error on input ‘$’
13:29:30 <lambdabot>      Perhaps you intended to use TemplateHaskell
13:29:40 <Boarders> > :set -XTemplateHaskell
13:29:41 <Boarders> > $(stringE . show =<< reify ''Bool)
13:29:42 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
13:29:43 <lambdabot>  <hint>:1:1: error:
13:29:43 <lambdabot>      parse error on input ‘$’
13:29:43 <lambdabot>      Perhaps you intended to use TemplateHaskell
13:30:11 <Boarders> Solonarv when I try this in ghci I get back something funky, do you know how I get instances from it
13:30:36 <Solonarv> % :set -XTemplateHaskell
13:30:36 <yahb> Solonarv: 
13:30:53 <Solonarv> % import Language.Haskell.TH.runQ
13:30:53 <yahb> Solonarv: ; <interactive>:60:8: error: parse error on input `Language.Haskell.TH.runQ'
13:31:09 <Solonarv> % import qualified Language.Haskell.TH as TH
13:31:09 <yahb> Solonarv: 
13:31:22 <Solonarv> % TH.runQ (TH.reify ''Bool)
13:31:22 <yahb> Solonarv: Template Haskell error: Can't do `reify' in the IO monad; *** Exception: user error (Template Haskell failure)
13:31:41 <Solonarv> % $( stringE . show =<< TH.reify ''Bool )
13:31:41 <yahb> Solonarv: ; <interactive>:63:4: error:; * Variable not in scope: stringE :: String -> TH.Q TH.Exp; * Perhaps you meant one of these: `TH.stringE' (imported from Language.Haskell.TH), `TH.stringL' (imported from Language.Haskell.TH), data constructor `TH.StringL' (imported from Language.Haskell.TH)
13:31:48 <Solonarv> % $( TH.stringE . show =<< TH.reify ''Bool )
13:31:48 <yahb> Solonarv: "TyConI (DataD [] GHC.Types.Bool [] Nothing [NormalC GHC.Types.False [],NormalC GHC.Types.True []] [])"
13:32:03 <Solonarv> ah hm, seems I was wrong
13:32:48 <Solonarv> Boarders: btw, lambdabot only sort of looks like ghci - but yahb is actually an interface to ghci
13:33:37 <Boarders> thank you!
13:33:51 <Boarders> yeah, I'll give the other stuff a try
13:46:47 * hackage hylolib 1.5.4 - Tools for hybrid logics related programs  https://hackage.haskell.org/package/hylolib-1.5.4 (GuillaumeHoffmann)
13:55:58 <Shockk> just a point of interest, not 100% haskell related but I'm building it in haskell so idk if that counts; I'm making so much progress lately with the compiler for my programming language, I can now do pointers like this
13:56:00 <Shockk> https://gist.github.com/shockkolate/5f26534dbbfd6e842733594c287243a4
13:57:47 * hackage bytestring-substring 0.1 - break bytestrings up into substrings  https://hackage.haskell.org/package/bytestring-substring-0.1 (chessai)
14:00:09 <monochrom> Shockk: I don't know what any of the files means, but congrats!  (Is *.ll an LLVM file?)
14:00:21 <Shockk> oh, yes sorry, .ll is LLVM IR
14:03:17 * hackage HTab 1.7.2 - Tableau based theorem prover for hybrid logics  https://hackage.haskell.org/package/HTab-1.7.2 (GuillaumeHoffmann)
14:11:14 <Shockk> I'm designing it to treat types as just regular values, so things like `intn` is just a function that returns a value, where that value is really the builtin integer type
14:11:47 <Solonarv> neato!
14:12:06 <Shockk> also designing it to have explicit syntax without potentially ambiguous grammar anywhere, which is kind of why I'm doing the deference with a <* operator 
14:13:10 <Shockk> in case the syntax doesn't make sense, -> means function, <- is the call syntax, and : is the type annotation syntax, and then <* dereferences a pointer
14:14:23 * ski already figured that
14:14:56 <ski> (except i thought `<*' was assignment, before i looked at the LLVM)
14:15:29 <Shockk> ah no, I actually don't know how I'm going to do stores to pointers yet, that's one point I'm working on currently
14:16:03 <ski> do you want a notion of location expressions, which looks similar to value expressions, like in C ?
14:16:46 <mouse07410> Anybody use VSCode as IDE for Haskell? If so, is there a plug-in or such to actually build/run a Cabal or Stack project? Or I have to perform actions via terminal, and user VSCode only as a "glorified editor"?
14:17:17 <phadej> what else VSCode is than a "glorified editor" :)
14:17:35 <Shockk> ski: I'm not sure, that's a good question; I actually haven't decided if I want immutable terms yet, or if I want to allow the value of a term to be changed later
14:17:47 <Solonarv> with enough plugins it can be pretty close to an "IDE-lite"
14:24:02 <ski> Shockk : so `kb <* 27' is not a term ? or you only allow single-assignment/instantiation ?
14:27:07 <odumichthys> Question: Suppose I have in my Lib, someFunc = do print ("foo") and two lines below, placed outside of the indentation, world :: !!
14:27:31 <odumichthys> What makes that sufficiently incorrect to get a parse error?
14:27:38 <lyxia> What do you mean "outside of the indentation"
14:28:15 <odumichthys> Like, someFunc has two spaces before print but world has none.
14:28:18 <jle`> odumichthys: i think it should be a parse error no matter what, since :: !! doesn't fit anywhere
14:28:22 <jle`> in syntax
14:29:22 <odumichthys> jle`, apologies world :: Double -> Double
14:30:01 <jle`> is that a type signature for a new definition?
14:30:06 <odumichthys> But the parse error is highlighting just the w
14:30:08 <odumichthys> Yeah
14:30:19 <Solonarv> odumichthys: could you perhaps paste the relevant bit of code into gist.github.com or similar?
14:30:23 <jle`> at the top-level, there should be no indentation
14:30:39 <Solonarv> actually you can have top level indentation
14:30:43 <jle`> :O
14:30:57 <Solonarv> but you have to indent the *entire* contents of the ... in 'module Foo where { ... }'
14:31:04 <jle`> oh, heh
14:31:15 <jle`> that's...consistent
14:31:28 <Solonarv> :D
14:32:35 <Solonarv> somewhat annoyingly the VSCode syntax plugin does this by default
14:33:00 <Solonarv> I haven't figured out how to turn it off, but fortunately if I dedent the first line it doesn't insist
14:34:26 <odumichthys> Solonarv,  https://gist.github.com/iheartbenzene/e509bf0fbfe88a637a8cef5e548a5757
14:35:10 <jle`> odumichthys: at that point, yes, any indentation in doubleMe should be an error
14:35:22 <jle`> all of the declarations at the top level should be at the same level
14:35:52 <jle`> so once you establish the indentation  at someFunc :: IO (), then all other definitions have to be the same as someFUnc :: IO ()'s indentation
14:38:53 <odumichthys> Even though when I do that, it asks for a `let`?
14:39:21 <odumichthys> Then would that mean all declarations inside of my Lib.hs would need a `let`?
14:39:38 <Solonarv> no, that's not even valid
14:39:46 <jle`> who is asking for a let?
14:39:52 <Solonarv> can you add the error message to the gist?
14:40:15 <Solonarv> (gists can be edited, and can have multiple files - no need to make a new one!)
14:41:03 <ski> jle` : i tend to have top-level indentation :D
14:41:15 <Solonarv> ski: but why?
14:41:20 <ski> for consistency
14:41:35 <odumichthys> Solonarv, updated. 
14:41:35 <Solonarv> with what?
14:41:35 * Solonarv is a bit puzzled
14:41:37 <Shockk> ski: sorry, missed your msg; I mean, maybe I'm using the word "term" wrong, but kb <* 27 isn't an assignment, it's an expression
14:41:52 <ski> it's a `where', the contents ought to be indented more that the start of the item which the `where' is attached to
14:42:12 <Shockk> ski: the result is returned implicitly as it's the final expression in the block
14:42:38 <Solonarv> Shockk: do you have the language spec written down somewhere (even informally) ?
14:42:51 <ski> Shockk : sure. and i'm not quite sure what you mean by "term". but you don't want to allow assigning multiple times to the location which `kb <* 27' fetches from ?
14:43:31 <odumichthys> I gotta run. Be back later.
14:44:00 <ski> (similarly, in C, i don't leave the `}' ending a function definition at column zero, i indent it as much as the body)
14:44:21 <ski>   module Blah
14:44:23 <ski>     where
14:44:30 <ski>     foo :: ...
14:44:32 <ski>     foo = ...
14:45:11 <ski> (i place `where's (and the body after it) attaching to `class' and `instance' (and GADT `data'), the same way)
14:48:28 <Shockk> ski: well no I mean assigning to kb<*27 would be fine, but what I mean specifically is, I might not allow names of variables to be mutable, like x = 5 and then x = 6
14:49:11 <keegans> having some trouble with mapping over a complex recursive data structure : https://pastebin.com/2qKV88Lj
14:49:29 <ski> Solonarv : all clear ?
14:49:39 <keegans> when the `treeMap f xs` is replaced with E [], it works -- yet it should be returning that type as it is ... ? 
14:49:53 <Solonarv> ski: clear indeed, though certainly unusual
14:51:34 <ski> Shockk : ah, ok. but if you allow assigning to the location fetched by `kb <* 27', then wouldn't that mean that if you later evaluate that expression, you could get a different result, picking the latter option out of "if I want immutable terms yet, or if I want to allow the value of a term to be changed later" ?
14:51:53 <Cale> keegans: xs isn't an Equation
14:52:20 <Cale> keegans: It's a list of them, so presumably you wanted to map (treeMap f) over that list
14:52:41 <Cale> keegans: Of course, you could have done that from the outset, you don't need to pattern match on the list structure here
14:52:55 <ski> keegans : `f' is unused
14:53:09 <Cale> That's also an excellent point :)
14:53:11 <ski> keegans : do you know about parameterized `data' types ?
14:53:22 <keegans> this is an incomplete example, yeah 
14:53:29 <keegans> i wanted to fix this before i add the Number f x
14:53:51 <keegans> ah Cale how can I have it be in the pattern match ? 
14:54:06 <ski> you already do
14:54:12 <Cale> keegans: treeMap f (E xs) = E (map (treeMap f) xs)
14:54:24 <ski> or
14:54:29 <keegans> ah very nice
14:54:31 <keegans> thank you
14:54:35 <ski>   treeMap f (E xs) = E (treeMaps f xs)
14:54:39 <ski> if you define
14:54:53 <ski>   treeMaps f xs = map treeMap_f xs
14:54:55 <ski>     where
14:55:00 <ski>     treeMap_f xs = map f xs
14:55:15 <ski> that's just a bit more verbose and explicit version of what Cale suggested
14:56:01 <ski> (you could also use function abstraction expressions (function literals / "aggregates"), aka "lambda expressions" or "anonynous functions", if you've seen those)
14:56:30 <keegans> sounds good , yep
14:56:37 <ski>   treeMap f (E xs) = E (map (\x -> treeMap f x) xs)  -- a lambda expression
14:56:54 <keegans> well no need because of currying
14:56:58 <keegans> for the lamba expr there
14:57:05 <ski> yes, we can eta-reduce it away
14:57:26 * ski . o O ( "Eta-reduce all the day !" )
14:58:13 <keegans> now , is it possible for me to pass context when i reach an Element node ? i.e.: there is a Number adjacent to each list of Equations or Elements, i'd like to multiply the number contained in the Element by the Number adjacent to expression
14:58:34 <keegans> I read about state monads for this purpose but I not sure how i should begin to approach it
14:59:26 <ski> keegans : you could add an extra argument/parameter to your recursive tree-walking function
14:59:41 <Cale> Yeah, start by just passing it as a function parameter.
14:59:54 <keegans> will do, thanks
15:00:46 <ski> perhaps you need some form of state-passing-style .. depending on whether you allow all technically possible `Equation's or not, and depending on the details of where to find the relevant `Number's, for a given `Element'
15:00:59 <Cale> For certain cases, especially when you're producing some bit of state as part of the result of the operation on a subtree and using it to determine how things in other subtrees or at the root will change, the State monad will help tidy up that kind of code.
15:01:14 <keegans> if I have a `treeMap :: ((Equation, String, Int) -> (String, Int)) -> Equation -> Equation`
15:01:33 <keegans> I am not clear on how to get the equation to that function 
15:01:43 <ski> (state-passing-style merely means that you'd not only have an extra argument/input, but also an extra result/output. so your output would be a tuple (like a pair) of the original output, and the new one
15:02:27 <ski>  .. and then you'd "thread" this state (the pair of input and output, signifying some possible change in state from input state to output state) through your tree traversal, up and down branches in the treE)
15:02:52 <ski> keegans : i don't know what you mean by "the equation to that function"
15:03:41 <ski> hmm
15:03:45 <keegans> hmm i'll just describe what i'm looking to do, one second 
15:04:21 <ski> i suppose you could also pass the enclosing `Equation' (which includes the relevant `Number' node ?) to the callback, if you wanted to
15:04:57 <ski> .. but i, and Cale, was talking about adding an extra parameter to `treeMap' (itself) (or a function like it), not to the callback argument of `treeMap'
15:05:13 <ski> iow, something like
15:05:16 <Cale> It's not clear to me how this data type represents something that I would call an equation...
15:05:58 <ski>   treeMapWithContext :: (Context -> (String,Int) -> (String,Int)) -> Context -> Equation -> Equation
15:06:11 <ski> for some type `Context', perhaps `Int' or `[Int]'
15:06:22 <Cale> sampleInputOne looks something like a chemical formula
15:06:38 <ski> Cale : perhaps it's encoding data relating to some specific type of equation ..
15:07:19 <keegans> https://pastebin.com/RZuDgBfk
15:08:00 <keegans> and the way i have thought to do this is by passing the above list to the "leaf" to multiply by
15:08:01 <ski> keegans : so .. i suppose i ended up also adding an argument to the callback (since iiuc the callback was intended to do that "multiply the number contained in the Element by the Number adjacent to expression" you mentioned, no ?). but really the extra argument to `treeMap' itself was the main point
15:08:18 <keegans> that way it would stack with previous multipliers (as I'd multiply Number x by that) 
15:08:30 <jle`> maybe it's a chemical formula
15:08:50 <ski> perhaps instead of `E [...,Number n]', you could have `Scale (...) n' ?
15:09:03 <ski> (just guessing at what you perhaps are trying to express)
15:09:49 <keegans> yeah I think scale would be better
15:10:18 <Cale> data Formula = Element String | Scale Formula Int | Bond [Formula]
15:10:39 <ski> then you'd know exactly where the scaling number was expected to be, rather than having to hunt for it
15:11:21 <Cale> (an equation should have two formulas which are being equated...)
15:11:23 * ski never got an answer to
15:11:28 <ski> <ski> keegans : do you know about parameterized `data' types ?
15:12:02 <ski> perhaps it's just an aquatic solution, not a bond ?
15:12:19 <keegans> ah sorry
15:12:32 <keegans> parameterized as in generic , like using `a`, etc. in place of type ? 
15:12:35 <ski> yes
15:12:38 <Cale> Yeah, maybe we should have something that would be rendered as a "sum" rather than a "product"
15:12:41 <ski> like with `Maybe', e.g.
15:13:10 <keegans> sure, yeah
15:13:24 <Cale> Like, if I want to write CH_4 + O_2
15:13:25 <keegans> i am perhaps missing how parameterized types fit into this though
15:13:33 <ski>   data Formula a = Element a | Scale Int (Formula a) | Bond [Formula a]  -- or somesuch
15:14:05 <keegans> ah i see
15:14:07 <ski> then you'd been less likely to have forgotten to use `f' in `treeMap', is all
15:14:17 <ski> also, sometimes this kind of generalization can be helpful
15:14:26 <ski> perhaps not in your case, not sure
15:16:14 <mouse07410> phadej: so basically I should give up running Cabal builds from VSCode?
15:16:23 <keegans> thank you both for your help, i'm sure ill have more questions though , but just going to take another crack at it with these new ideas
15:16:35 * ski nods, take your time
15:18:21 <Cale> mouse07410: VSCode has an integrated terminal you can use to run cabal :P
15:19:13 <Cale> mouse07410: I would typically run something like ghcid in a separate window though, and only care about making the terminal go in the same window as my editor if I was sharing the window with someone via hangouts or something.
15:19:34 <Cale> ghcid -c cabal repl
15:20:01 <Cale> will give you a nice window that shows you the current set of errors to work on, and updates itself whenever you save a file
15:26:46 <Solonarv> Cale: oh, ghcid doesn't require the --command argument to be quoted?
15:31:07 <Cale> Solonarv: doesn't seem to
15:31:17 <Solonarv> neat!
15:40:07 <mouse07410> Cale: I have intero and HIE installed. Do I need to install ghcid also? Or basically, run cabal whichever way you want, edit via VSCode with plugins?
15:50:56 <Solonarv> the latter
15:56:31 <Cale> mouse07410: Yeah, basically the latter. ghcid is just a suggestion for how to get some IDE-like features for cabal without needing them to be tied to a particular editor.
16:01:46 <Solonarv> although there's one thing you can do with ghcid that I don't think any other IDE-ish tool supports out of the box: automatically (re)starting your program after recompilation
16:12:24 <Boarders> ghcid with typed holes is also a huge plus
16:12:43 <Boarders> Solonarv: what do you mean by restart after compilation?
16:13:46 <odumichthys> Okay, I'm back.
16:16:04 <Solonarv> Boarders: check out the -T option
16:16:24 <Solonarv> ghcid -T foo will run 'foo' after every reload
16:16:38 <Boarders> ah I see, cool
16:17:05 <Solonarv> so with ghcid -T Main.main that means your program is (re)started after each reload
16:17:54 <Solonarv> maybe you can even do 'ghcid -T ':main arg1 arg2 ...', I haven't tested that though
16:22:05 <phaul> hi all, after some time I started playing with haskell again, I did this bit of code https://gist.github.com/phaul/cdee889ac7f40c3828ce5371b22e6a8d, and Im not sure about the Show instance I made. I'm using the Monoid m => Applicative (m,) instance to traverse because that's what I managed to get compile and run but it feels weird. 
16:23:04 <keegans> why exactly is this not acting in the way I expect : https://pastebin.com/ca20DrNz ? i.e. all scales are multiplied by 2
16:23:10 <keegans> it seems to not be going deep enough
16:23:21 <c_wraith> phaul, if it makes you feel any better, that's also the Writer Applicative instance
16:24:27 <Solonarv> phaul: I'd generally recommend against hand-writing Show instances if one can be derived instead
16:24:30 <c_wraith> keegans, you forgot to recurse on line 8
16:24:47 <phaul> not sure, I don't fully grasp how Traversable is connected with Applicatives 
16:25:18 <c_wraith> :t traverse
16:25:20 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
16:25:32 <Solonarv> you can think of Traversable as a stronger Functor
16:25:44 <c_wraith> Applicative is just part of the definition of Traversable, like above.
16:25:51 <Solonarv> Functor's fmap lets you map a pure function over the data structure
16:25:58 <phaul> I mean I see the signatures, and I can get it working. But in practice how would you do this traversal?
16:26:02 <wolfman154> When is Haskell from first principles going to be fully complete ?
16:26:12 <Solonarv> Traversable's traverse lets you map an *effectful* function over the data structre
16:26:31 <keegans> oh my goodness i cant believe i forgot that . :D thank you
16:26:33 <phaul> because I needed to blumb in a () into the tupple, just to make types happy.
16:26:50 <phaul> line 55
16:27:07 <phaul> it feels weird, maybe because Im using the wrong applicative
16:27:11 <Solonarv> phaul: if you find yourself using the Applicative ((,) m) instance but only every putting () in the tuple's second slot, you should actually be using COnst
16:27:23 <Solonarv> er, Const
16:27:58 <Solonarv> or possibly just foldMap / one of its cousins
16:28:06 <phaul> I see Const. thanks I check it out
16:28:55 <Solonarv> also, slight nitpick: a better name for your traverse' function would be something like: traverseWithDepthColour
16:30:20 <phaul> ok, thanks Solonarv 
16:39:42 <ski> keegans : why `2' ?
16:46:34 <mouse07410> Cale: do you know if ghcid is complementary to HIE? Or if I use HIE, there's no need for ghcid?
16:49:49 <Cale> mouse07410: I don't know, I've never used HIE
16:50:23 <Cale> mouse07410: It's just a way to get the compiler output, updated automatically as you save things
16:53:59 <Boarders> sort of naive question but say I have some function that works with arbitrary sized matrices but for any fixed size matrix I want to use some constant based on the size
16:54:08 <Boarders> would it be possible to use template haskell to do that sort of thing?
16:54:35 <Boarders> or is that only the case if I statically know the sizes involved
16:54:48 <Boarders> I imagine it is but I just want to check
17:03:39 <halogenandtoast> Any suggestions for a simple drawing library in Haskell, I want to draw a hex grid, should I use SDL or something else?
17:06:46 <zachk> halogenandtoast, gloss is pretty easy 
17:07:56 <halogenandtoast> zachk: yeah that might be perfect!
17:09:09 <zachk> sdl was a lot of work last time I tried it, pointers and stuff, and was a pain to get working on windows if that matters to you halogenandtoast 
17:09:28 <Boarders> hologenandtoast: give the diagrams library a go
17:09:29 <Boarders> it is lovely
17:10:01 <halogenandtoast> windows, not so much, just want to program an 18xx game, so I need a hex grid (as well as a few other things).
17:10:48 <halogenandtoast> diagrams looks cool too Boarders, thanks!
17:15:16 <mouse07410> Cale: maybe it's worth your while to install hie and the VSCode plugin that uses it. It provides completion, linting, etc. Frankly, of like to learn your and others' experience with this setup, compared to other approaches
17:19:46 <Cale> I mostly use Sublime, which is pretty similar to VSCode in terms fo UI, but seems a bit faster. I don't use any Haskell-specific support plugins though.
17:20:04 <Cale> The closest thing to an IDE-ish feature that I use is tags.
17:20:17 * hackage generic-data 0.6.0.1 - Deriving instances with GHC.Generics and related utilities  https://hackage.haskell.org/package/generic-data-0.6.0.1 (lyxia)
17:21:26 <Cale> (and I do use the embedded terminal sometimes, but only when I want to easily share my terminal window with someone on a call, since it sucks compared to a real terminal emulator)
17:23:13 <Cale> I used to use vim (and still do when I want to quickly edit something from the terminal), but I used almost none of its features.
17:24:23 <Cale> There were very few text editor features I ever learned about and then thought "well, that was a good use of my time"
17:38:56 <keegans> looking to do some parsing, yet having some trouble with what approach i should take : https://pastebin.com/vnFDZmr6
17:38:59 <keegans> any help is appreciated 
17:47:28 <lyxia> ["(", xs, ")", scale, etc] is a pattern matching a list of exactly 5 elements
17:48:38 <lyxia> "(" and ")" are going to be separated by an unknown number of elements, so you can't match them in a single pattern
17:48:44 <keegans> lyxia: if i ("(" : xs : ")" , etc. that'll work , yeah ? 
17:48:53 <keegans> ah
17:49:11 <lyxia> you'll need to break the problem down into smaller pieces.
17:51:16 <keegans> q
17:52:53 <AfC> mouse07410: try the https://github.com/dramforever/vscode-ghc-simple plugin. It's the same wrapper around GHCi that ghcid is. Works quite well.
18:05:47 * hackage safe-decimal 0.1.0.0 - Safe and very efficient arithmetic operations on fixed decimal point numbers  https://hackage.haskell.org/package/safe-decimal-0.1.0.0 (lehins)
18:19:17 * hackage massiv 0.3.1.0 - Massiv (Массив) is an Array Library.  https://hackage.haskell.org/package/massiv-0.3.1.0 (lehins)
18:27:52 <mouse07410> AfC: thanks - I'll try that plugin too, to compare. I want to get all the "IDE" benefits -  error catching, function name completion, syntax highlighting, online documentation... If in addition I can get this thing to deal with projects - great, otherwise I'll have to run Cabal manually.
18:41:53 <luciandesozay33[> Hey
18:58:14 <halogenandtoast> Is ++ on lists lazy in that if I do take 3 ([1,2] ++ [3,4]) is the 4 "never added" to the list?
18:58:47 * hackage wai-app-file-cgi 3.1.7 - File/CGI/Rev Proxy App of WAI  https://hackage.haskell.org/package/wai-app-file-cgi-3.1.7 (KazuYamamoto)
18:59:44 <halogenandtoast> The answer to my question is yes
18:59:49 <jackdk> > take 3 ([1, 2] ++ [3, undefined])
18:59:51 <lambdabot>  [1,2,3]
19:00:04 <halogenandtoast> jackdk: that doesn't really prove it to my satisfaction
19:00:16 <halogenandtoast> > take 3 ([1..] ++ [3,4])
19:00:18 <lambdabot>  [1,2,3]
19:00:20 <halogenandtoast> that does though
19:01:17 * hackage mighttpd2 3.4.4 - High performance web server on WAI/warp  https://hackage.haskell.org/package/mighttpd2-3.4.4 (KazuYamamoto)
19:01:45 <jackdk> that will take the 3 from the first list
19:01:53 <jackdk> > take 3 ([1..] ++ undefined)
19:01:55 <lambdabot>  [1,2,3]
19:01:57 <jackdk> you may be okay with this.
19:02:56 <halogenandtoast> I am okay with this
19:03:09 <halogenandtoast> it really just makes the definition of cycle even more amazing to me
19:03:10 <halogenandtoast> cycle xs                = xs' where xs' = xs ++ xs'
19:03:39 <koz_> Laziness is Magic.
19:07:36 <halogenandtoast> Sometimes it really is
19:48:12 <aarvar> cycle has the wrong type though. It should return an infinite stream
19:54:45 <Cale> aarvar: Even if there were an infinite stream type hanging around in the Prelude, you might still want the infinite list that it gives.
19:55:37 <aarvar> are possibly-infinite lists really that useful?
19:56:47 * hackage warp-tls 3.2.5 - HTTP over TLS support for Warp via the TLS package  https://hackage.haskell.org/package/warp-tls-3.2.5 (KazuYamamoto)
19:56:58 <Cale> Certainly
19:57:11 <Cale> Are possibly-infinite loops really that useful?
19:57:40 <aarvar> idk. My guess would be no?
19:58:17 <Cale> There are a lot of programs out there which want to run indefinitely until some condition is met
19:59:07 <aarvar> fine, I'm wrong xd
19:59:13 <Cale> Lists in Haskell correspond in a very direct way to "stuff you want to iterate along", and it makes sense for them to possibly be infinite a lot of the time.
20:02:15 <monochrom> Almost every value has the wrong type.
20:08:38 <ski> Almost every type has the wrong values.
20:10:34 <aarvar> I guess one may as well use python
20:11:39 <ski> we already have `-fdefer-type-errors'
20:15:10 <monochrom> Even that doesn't allow "if False then () else id".
20:59:21 <maerwald> aarvar: why not
22:41:58 <tdammers> ah, the popular bath water argument
22:42:19 <tdammers> "we can never get 100%, therefor we should give up on the idea entirely"
22:43:10 <tdammers> anyway; it can be useful to think of Haskell's `[]` type as a control flow construct rather than a data type
22:43:24 <tdammers> representing iterations, rather than "lists"
22:43:42 * ski . o O ( "Data is code." )
22:44:28 <tdammers> that too, but with non-strict evaluation, x : xs starts out as a thunk, and a thunk can be thought of as a continuation
22:44:49 <ski> it can ?
22:45:22 <DigitalKiwi> i heard thunks are closures
22:45:32 <tdammers> it's a recipe for the rest of the evaluation of a given expression
22:45:57 <tdammers> DigitalKiwi: thunks also close over the environment in which they were defined, yes
22:46:16 <ski> a continuation expresses the rest of the computation of a program, once some particular subexpression has finished with a result
22:47:55 <tdammers> ski: yes, and that's roughly what a thunk is, except it's the rest of the evaluation ("computation") of a program, and the dependencies are kind of inverted - it "runs" when its value is demanded, and it in turn triggers evaluation of its own dependencies
22:48:15 <tdammers> although it boils down to the same really
22:48:39 <ski> so you're roughly saying, continuation ~ value, up to inversion of the program ?
22:48:41 <tdammers> it's very similar to how you would use callbacks in JS - instead of passing a value, you pass a procedure that is capable of *producing* the value
22:48:51 <Cale> Maybe a part of a continuation? If the evaluation of a thunk is the whole continuation of your program, you're probably a bit dead in the water usually.
22:49:24 * ski doesn't really see the need to appeal to continuations, though
22:49:24 <tdammers> I actually meant to say "the rest of the evaluation ("computation") of an expression"
22:49:36 <DigitalKiwi> tdammers: I'm referencing this almost 10 year old post why don't you understand the reference http://esr.ibiblio.org/?p=1796
22:49:47 <Cale> Essentially every thunk's evaluation will be continued by some case expression
22:50:02 <ski> (unless you want to express functions in terms of continuations. or thunks/suspensions)
22:50:12 <Cale> (or else it was a thunk for a function, and it will be followed up by application)
22:50:50 <Cale> Thunks are too low level anyway, better to think in terms of expressions or expression graphs.
22:51:08 * ski idly recalls esr coming on the channel, once
22:51:49 * ski tried to explain monads to them
22:52:48 <ski> yea, thunks (in this sense), and closures, are an implementation detail
22:53:31 <tdammers> ski: judging by that article, you failed D:
22:59:52 <gentauro> tdammers: did you work for Well-typed?
22:59:54 <DigitalKiwi> tbf it was linked on here a few days ago so isn't that obscure https://www.reddit.com/r/haskell/comments/bf0q06/how_does_haskell_make_you_a_better_programmer/
23:01:35 <DigitalKiwi> https://lukeplant.me.uk/blog/posts/why-learning-haskell-python-makes-you-a-worse-programmer/ was amusing
23:03:40 <tdammers> gentauro: still od
23:03:43 <tdammers> do
23:07:14 <ski> okay, i see esr talking in the `10.03.09' log entry (actually already over at `10.03.01'), and me responding
23:08:03 <ski> (me attempting to explain monads was done in private, though. iirc, they asked something in private, and i got into monad tutorial mode)
23:12:55 <DigitalKiwi> you say you know haskell? oh yeah well where's your monad tutorial then huh
23:13:21 <DigitalKiwi> s/huh/hmm?/
23:13:39 <tdammers> Eightfold path to monad satori. Nuff said.
23:14:04 <dminuoso> We should be getting Monad Enlightenment medals on haskell conferences.
23:15:59 <tdammers> level 1: monad tutorial written. level 2: "monad tutorials considered harmful" written. level 3: monad tutorial fallacy tutorial written. level 4: "monad tutorial fallacy tutorials considered harmful" written
23:16:13 <ski> DigitalKiwi : i've only even written them on IRC, interactively ;)
23:17:50 <dminuoso> tdammers: The first three are sadly exist sadly plentiful.
23:19:13 * ski has not yet been seduced/coerced into blaggery
23:28:13 <gentauro> tdammers: thx for maintaining GHC ;-)
23:28:22 <gentauro> (spoke yesterday with Simon Marlow) :-)
23:31:33 <dminuoso> In RTS stats, what exactly does max_live_bytes denote? What are "live data"?
23:31:48 <dminuoso> And what does the "max" here mean?
23:46:30 <dminuoso> My initial thought was that its the bytes copied by the GC, but we also have gcdetails_copied_bytes in the RTS stats
23:50:12 <tdammers> gentauro: I'm not currently working on GHC, but I've done some work on the project in the recent past
23:50:18 <tdammers> gentauro: so thanks, I guess :D
23:57:21 <sshine_> dminuoso, or maybe a black-belt ranking system.
