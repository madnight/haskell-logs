00:56:17 <jle`> johnw: i don't think it's something you can write for all arrows
00:56:27 <jle`> johnw: for example, how about (->)
00:58:14 <jle`> and note that (->) is an instance of all of the Arrow typeclasses in Control.Arrow
01:39:17 * hackage IntervalMap 0.6.1.1 - Containers for intervals, with efficient search.  https://hackage.haskell.org/package/IntervalMap-0.6.1.1 (ChristophBreitkopf)
01:50:46 <cdupont> Hi guys
01:50:58 <cdupont> I have a small question about Conduit
01:51:40 <cdupont> I have a stream like this: runConduit $ appSource intServer .| filterTraffic  .| appSink extClient
01:51:52 <cdupont> It's working fine to filter traffic
01:52:46 <cdupont> I have a stream like this: runConduit $ appSource extServer .| filterTraffic  .| appSink intClient
01:53:36 <cdupont> however sometime the function filterTraffic should stop some requests from the extServer and return it an error code directly
01:53:51 <cdupont> without involving the intClient
01:54:01 <cdupont> How do I do that?
01:54:08 <merijn> cdupont: Conduit can't do bidirectional things like that, AFAIK
01:54:24 <merijn> You might be able to hack something together on top of it, but I don't think you can do it directly
01:54:38 <cdupont> I suspect I have to pass extServer as a parameter to filterTraffic?
01:54:57 <cdupont> such as: runConduit $ appSource extServer .| filterTraffic extServer .| appSink intClient
01:56:00 <cdupont> But I don't know how to give a value directly to extServer inside filterTraffic (am beginner)
01:56:55 <merijn> cdupont: None of us know what the type of "extServer" is, let alone what "giving a value to it" means, so that's kinda hard to answer :)
01:58:11 <cdupont> sorry
01:58:50 <cdupont> it's AppData from Network.Conduit
01:59:24 <cdupont> filterTraffic ::  ConduitT B.ByteString B.ByteString IO ()
01:59:45 <cdupont> extServer and intServer are type 'AppData' from Network.Conduit
02:00:15 <cdupont> appSource :: AppData m -> Source m ByteString
02:00:23 <cdupont> appSink :: AppData m -> Sink ByteString m ()
02:00:42 <Itkovian> cdupont I have something similar. I have two sinks, not sure if that is the correct approach (and the code is likely consider fugly).
02:01:53 <cdupont> @Itkovian, how do you pass a data to a particular sink?
02:01:53 <lambdabot> Unknown command, try @list
02:01:59 <cdupont> Itkovian, how do you pass a data to a particular sink?
02:02:19 <Itkovian> Sec. Let me go find the code
02:02:35 <cdupont> thanks :) It seems I'm missing something obvious...
02:03:29 <merijn> The problem is that conduit streams are linear in a single direction and don't really have anything in the form of signalling back to an origin, because what would that even mean?
02:04:55 <Itkovian> cdupont https://gist.github.com/itkovian/3e990d0b29818984418f7767b157ca18
02:05:22 <Itkovian> but then the "failure" should be something that is connected back to your input application
02:06:09 <merijn> distributive-0.6 is failing to install for me with new-build to do a documentation building failure? Anyone know how to solve that?
02:06:28 <Itkovian> cdupont it is called like `messageSink (ZMQC.zmqSink successSocket []) (ZMQC.zmqSink failureSocket []) messageCount frequency)`
02:07:22 <cdupont> interresting, thanks
02:07:40 <Itkovian> in my app, both zmq sinks are talking to the same logstash (on different ports), but you could connect one of them to something else, obviously
02:08:02 <Itkovian> repo is here (yeah, the code needs a lot of love :) https://github.com/itkovian/hnormalise
02:08:18 <Itkovian> but it works and has been up and running from reboot to reboot :)
02:08:52 <cdupont> so something like `yeld XXXX .| appSink extServer` would work
02:09:12 <cdupont> thanks a lot, let me try thank
02:09:53 <Itkovian> if you yield to the correct thing, I suppose so.
02:10:16 <Itkovian> that said, it took a while for me to figure it out and I still do not completely grok it.
02:12:28 <cdupont> ya, Conduit is quite complex :)
02:15:04 <Itkovian> Well, on my todo list is to have multiple input/output options (0mq, kafka, ...) and I've no clue how to achieve this atm
02:18:43 <cdupont> It worked :)
02:19:13 <cdupont> I didn't know that you could yeld to a stream, inside another stream :)
02:20:12 <cdupont> Itkovian, can ZipSink help?
02:20:14 <cdupont> https://github.com/snoyberg/conduit#zipsink
02:21:12 <Itkovian> that would be if you would send _all_ data to each of them, no?
02:23:46 <cdupont> In this case, your strategy with the case seems goo
02:23:47 <cdupont> In this case, your strategy with the case seems good
02:25:22 <Itkovian> it works so ... :D
02:53:38 <gentauro> is it possible to define a `(~)` operator?
02:54:12 <gentauro> here is described as `Irrefutable pattern` -> https://imada.sdu.dk/~rolf/Edu/DM22/F06/haskell-operatorer.pdf
02:55:59 <gentauro> is it possible to define a `(~)` operator?
02:56:03 <gentauro> here is described as `Irrefutable pattern` -> https://imada.sdu.dk/~rolf/Edu/DM22/F06/haskell-operatorer.pdf
02:56:16 <gentauro> (I forgot to register my nick)
03:00:15 <dminuoso> gentauro: What do you mean? Do you want to reuse (~) for something else? Or do you want to implement the irrefutable pattern match operator yourself?
03:02:18 <gentauro> dminuoso: something like this `λ> (+) x y = x * y`
03:02:32 <gentauro> maybe limit it to a specific datatype
03:03:00 <gentauro> btw, I have never seen that operator in use, how would code be with ~ (irrefutable pattern)?
03:03:17 <dminuoso> gentauro: reservedop → .. | : | :: | = | \ | | | <- | -> | @ | ~ ̃| =>
03:04:04 <dminuoso> gentauro: The gentle introduction has an example of how irrefutable pattern matches can be useful.
03:04:18 <dminuoso> They are especially found in forms of mutual recursion.
03:12:36 <gentauro> dminuoso: found something usefull -> http://continuation.passing.style/2015/12/21/not-gentle-intro-to-haskell/
03:12:42 <__monty__> gentauro: This needs an irrefutable pattern to be lazy: bisect = foldr (λx ~(a, b) →  (x:b, a)) ([], [])
03:14:14 <gentauro> __monty__: magick !!!
03:14:20 <gentauro> black magick !!! :)
03:15:25 <gentauro> but thx for the example :)
03:17:15 <__monty__> I agree it's black magic.
03:17:40 <__monty__> Came across it in a great post by ertes.
03:20:17 * hackage http-proxy 0.1.1.0 - A library for writing HTTP and HTTPS proxies  https://hackage.haskell.org/package/http-proxy-0.1.1.0 (ErikDeCastroLopo)
03:20:24 <gentauro> __monty__: wasn't he the one that died last year?
03:20:38 <merijn> gentauro: Yes
03:31:41 <akr> I'm trying to compile a Setuh,hs script with `ghc --make Setup -o Setup` and I'm getting linking errors like this: 
03:31:44 <akr> /usr/bin/ld: /usr/local/lib/ghc-6.12.3/base-4.2.0.2/libHSbase-4.2.0.2.a(Read__1.o): relocation R_X86_64_32S against symbol `stg_CAF_BLACKHOLE_info' can not be used when making a PIE object; recompile with -fPIC
03:31:51 <akr> how can I pass -fPIC to ghc?
03:32:09 <merijn> akr: Let's rewind: Why are you manually compiling Setup.hs?
03:32:50 <akr> merijn: I'm trying to install cabal-install-0.8.2 from it's bootstrap.sh script and this is the error it gives
03:33:03 <merijn> akr: cabal-instal 0.8?!
03:33:21 <akr> yeah, unfortunately it is necessary to have it for a few more months
03:33:25 <merijn> Let's rewind further: Why cabal-install-0.8?
03:33:40 <gentauro> merijn: legacy?
03:33:42 <akr> well, I need ghc-6.12.3
03:33:45 <akr> gentauro: yeah
03:33:47 <merijn> akr: I dunno for sure, but I would guess that 0.8 would be well over 2 decades old by now
03:33:58 <gentauro> :o
03:33:59 <akr> that doesn't seem right
03:34:08 <akr> 10 years should be more like it
03:34:11 <merijn> Did you maybe mean 1.8?
03:34:23 <adelaney21> In this example I'm trying to compose `fmap`s across a binary Tree.  I feel like I'm missing a concept that would allow me to compose an arbitrary number of `fmap` calls.  Is there an obvious concept? https://paste.fedoraproject.org/paste/jDJMZflYYoqhEjhjf6otiw
03:34:28 <akr> hmm
03:34:35 <merijn> akr: I started learning Haskell over 10 years ago and we were definitely on a 1.x cabal-install by then :)
03:34:35 <akr> merijn: no, I don't think so
03:34:42 <akr> hmm
03:35:03 <akr> ok, where can I found out which cabal should be used with ghc 6.12.3?
03:35:07 <akr> find*
03:35:12 <merijn> akr: Anyway, cabal-install supports a range of older compilers. I'm not going to say 2.x support GHC6.12, but I'm 100% sure there's a more recent cabal supporting 6.12 :p
03:35:47 <Taneb> merijn: cabal-install 0.8 was 2010, I think, looking at Hackage
03:35:54 <akr> yeah, sounds right
03:35:54 <merijn> akr: GHC 6.12 shippd with Cabal 1.8.0.2 (according to the release notes)
03:36:05 <merijn> So presumably also cabal-install 1.8
03:36:10 <merijn> https://downloads.haskell.org/~ghc/6.12.1/docs/html/users_guide/release-6-12-1.html
03:36:55 <akr> weird
03:36:58 <akr> oh
03:37:04 <Taneb> merijn: Cabal and cabal-install version numbers didn't match until 1.16
03:37:06 <merijn> hmm, looks like cabal-install and Cabal weren't synced up that far ago
03:37:07 <akr> yeah
03:38:18 <akr> so I tried setting $CXXFLAGS=-fPIC but that makes no difference
03:38:56 <merijn> akr: Why would CXXFLAGS be remotely relevant?
03:38:56 <phadej> cabal-install-2.x supports GHC-7.0 onwards
03:39:15 <merijn> phadej: I guess 1.24 would still support 6.12?
03:39:33 <phadej> merijn: I don't remember where the switch happened
03:39:50 <phadej> I remember hacking something to work with 6.12 in past three years :)
03:40:08 <akr> merijn: I see, ghc doesn't invoke any c/c++ compilers?
03:40:14 <merijn> akr: Anyway, maybe try mixing GHC 7.0 with modern cabal? Supposedly the changes between 6.12 and 7.0 weren't that major...
03:40:15 <akr> I should probably read up on ghc some time
03:40:27 <merijn> akr: Not unless you're including C code :p
03:40:40 <akr> well, this is the network library
03:40:52 <akr> so, not sure
03:41:17 <merijn> akr: Ah, honestly that might just be that network versions that old don't support your current C compiler well
03:42:29 <akr> good point
03:42:48 <merijn> akr: Oh, actually, hvr just chimed in that cabal 2.x should *still* support GHC 6.12 IFF not using v2-build
03:43:24 <akr> I'll give it a try :)
03:43:47 <akr> though I also need cabal-dev
03:44:00 <akr> that thing is ancient as well, no idea if it works with newer cabals
03:44:51 <akr> well, the latest version needs Cabal <1.17
03:46:13 <akr> maybe I can just try replacing cabal-dev with cabal-install --sandbox
03:46:21 <merijn> akr: Wow...I forgot all about cabal-dev :>
03:46:55 <akr> lucky you :P
03:47:41 <merijn> akr: Honestly, if at all possible I'd try and see if GHC 7.0 is good enough for your codebase, because then you can just say "sod this" and switch to v2-build
03:47:47 <akr> I already ported our application to GHC 8.4 and Stack, but we're stuck also running the legacy version in parallel for a few more months :(
03:48:00 <merijn> ah, then probably don't bother :p
03:48:17 <akr> yeah I don't want to do another port
03:48:56 <merijn> akr: But builtin cabal sandboxes should obsolete cabal-dev, yes
03:49:33 <merijn> akr: You may have to hack into/modify the network package and the way it compiles it's C to get things working, if that's what's broken, though
03:49:45 <akr> hmm
03:50:03 <akr> another option is to compile our application on an ancient ubuntu inside docker
03:50:12 <akr> but I haven't figured out how to link it statically 
03:51:14 <akr> but maybe that's a better approach, dunno
04:12:21 <akr> oh, there is something wrong with the my entire ghc-6.12 installation. It can't link even a simple program with no imports.
04:13:00 <dminuoso> 6.12 :<
04:13:05 <merijn> akr: More likely, I think your system linker changed in an incompatible way
04:13:11 <dminuoso> This must be industry
04:13:20 <akr> indeed :)
04:13:54 <dminuoso> akr: I was really relieved when I learned that Facebook was still at GHC 8.0 last year.. :-P
04:14:17 <dminuoso> (I think it was 8.0)
04:14:46 <akr> merijn: yeah that is unfortunate 
04:17:53 <Athas> Ah, 6.12!  Now that was a good release.
04:17:54 <akr> it's weird though, ghci starts up fine
04:18:13 <akr> and apparently it does some linking at startup as well
04:18:21 <akr> not sure if it's the same kind of linking, though
04:18:38 <akr> Athas: :)
04:26:10 <adelaney21> Given functions f::a->b, g::b->c and h::c-d, how can I create some sequence to store them?
04:26:24 <dminuoso> adelaney21: (.)
04:26:32 <dminuoso> :t (.)
04:26:33 <lambdabot> (b -> c) -> (a -> b) -> a -> c
04:26:53 <merijn> adelaney21: Depends what you want to store them for?
04:27:13 <adelaney21> dminuoso: (.) will compose the functions, but I want to store them in some kind of growable structure
04:27:27 <dminuoso> adelaney21: Mmm you mean like FunList?
04:27:29 <adelaney21> merijn: I want to build a chain that can be applied in the future
04:27:57 <dminuoso> % data FunList a b= Done b | More a (FunList a (a -> b))
04:27:57 <yahb> dminuoso: 
04:30:49 <adelaney21> dminuoso: thank you
04:32:40 <dminuoso> adelaney21: Though wait, that wont encode what you asked for.
04:32:54 <adelaney21> dminuoso: No, but it's a good pointer :)
04:32:57 <dminuoso> But you could probably use a similar technique. :)
04:33:16 <adelaney21> I'm not sure I can.  I suspect I'm just thinking about it incorrectly.
04:34:22 <adelaney21> There's no way to "store" f::a->b and g::b-> other than (.).  Otherwise I'd end up with runtime type checking of the composition
04:36:47 * hackage scheduler 1.1.0 - Work stealing scheduler.  https://hackage.haskell.org/package/scheduler-1.1.0 (lehins)
04:37:03 <dminuoso> % data Funs a c where Done :: a -> c; Funs :: (b -> c) -> (Funs a b) -> Funs a c
04:37:04 <yahb> dminuoso: ; <interactive>:26:21: error:; * Data constructor `Done' returns type `c' instead of an instance of its parent type `Funs a c'; * In the definition of data constructor `Done'; In the data type declaration for `Funs'
04:37:18 <dminuoso> % data Funs a c where Done :: (a -> c) -> Funs a c; Funs :: (b -> c) -> (Funs a b) -> Funs a c
04:37:19 <yahb> dminuoso: 
04:37:22 <dminuoso> adelaney21: ^- ?
04:37:44 <merijn> hmm, there's no mapM_ for ByteString? What's the most efficient way to map over each byte? Simply unpack it to a list and mapM_ over that?
04:38:05 <adelaney21> thanks
04:38:11 <dminuoso> merijn: mono-traversable should have it, no?
04:38:39 <dminuoso> % :t omapM_
04:38:39 <yahb> dminuoso: ; <interactive>:1:1: error:; * Variable not in scope: omapM_; * Perhaps you meant one of these: `mapM_' (imported from Prelude), `imapM_' (imported from Control.Lens), `mapM' (imported from Prelude)
04:38:43 <merijn> dminuoso: Maybe, but why isn't it just in ByteString?
04:40:31 <dminuoso> merijn: Well you have L.map and you can trivially generate some otraverse_ out of it.
04:40:42 <dminuoso> For L ~ Data.ByteString.Lazy that is
04:40:54 <dminuoso> % import Data.ByteString as BS
04:40:55 <yahb> dminuoso: 
04:41:38 <merijn> dminuoso: No? Because map from ByteString requires me to produce a Word8 as output, which mapM_ and various folds don't
04:41:56 <dminuoso> merijn: Well yeah, that's what mono-traversable captures
04:42:34 <dminuoso> merijn: by otraverse_ I specifically refer to the monomorphic variant introduced by that package.
04:42:48 <merijn> dminuoso: That's not really an argument for them not being in bytestring, though...I guess I'll just BS.foldr instead
04:45:11 <dminuoso> % bstraverse_ f = BS.foldr ((*>) . f) (pure ())
04:45:11 <yahb> dminuoso: 
04:45:19 <dminuoso> % :t bstraverse_
04:45:19 <yahb> dminuoso: Applicative f => (Word8 -> f a) -> ByteString -> f ()
04:45:28 <dminuoso> merijn: Curious, whats your specific use case?
04:46:26 <dminuoso> In my eyes delegating the responsibility to mono-traverse that the beauty that you get to have MonoTraversable/MonoFoldable, so you can abstract over the concrete container you are having.
04:46:51 <merijn> Constructing a Vector from a ByteString, so I just wanna mapM_ over it to update a mutable vector
05:23:32 <arjen-jonathan> How do I disable the popup buffer of flycheck on holes in emacs?
05:23:54 <arjen-jonathan> Somehow it steals the focus...
05:25:37 <merijn> hmm, I wish Data.Vector.Generic conveniently re-exported type aliases for each vector type so I don't have to have 7 lines of Vector imports to deal with different vector types :\
05:34:17 <mjrosenb> I have these three lines using State and lenses, and I'm like 90% sure that it can be one line.
05:34:27 <Solonarv> yeah, the different Vector variants all being named Vector is kinda annoying and confusing
05:34:40 <mjrosenb> Just oldLow <- preuse $ low . ix curVertex ; let newLow = min d oldLow; low . ix curVertex .= newLow 
05:35:07 <mjrosenb> n.b. newLow is used after these lines, and should remain bound to its existing value.
05:36:01 <Solonarv> you can at least merge the first two lines: Just newLow <- preuse $ low . ix curVertex . to (min d)
05:37:51 <mjrosenb> I was trying newLow <- low . ix curVertex <%= min d
05:38:08 <mjrosenb> but those types don't work.
05:45:35 <Solonarv> <%= needs a Lens-or-stronger, I think that's why
05:46:06 <Solonarv> perhaps there's a variant which works on weaker optics
05:51:17 * hackage telega 0.1.2 - Telegram Bot API binding  https://hackage.haskell.org/package/telega-0.1.2 (iokasimovmt)
05:57:13 <petrus> quit
06:02:17 * hackage quickspec 2.1.1 - Equational laws for free!  https://hackage.haskell.org/package/quickspec-2.1.1 (NickSmallbone)
06:18:16 <TBG> @pl \a -> \b -> zero maximum . fmap a b
06:18:16 <lambdabot> ((zero maximum .) .) . fmap
06:19:16 <TBG> @pl \a -> \b -> zero maximum $ fmap a b
06:19:16 <lambdabot> (zero maximum .) . fmap
06:27:08 <tabaqui> GADTs definetly need case support
06:27:54 <tabaqui> we cannot touch data constructors with function, but not with case expression
06:28:15 <tabaqui> *we can touch
06:45:25 <TBG> @pl \(a,b) -> (a,b)
06:45:26 <lambdabot> id
06:45:30 <TBG> Gud bot
06:45:54 <TBG> @pl \(a,b) -> (2 * a, b)
06:45:54 <lambdabot> first (2 *)
06:46:05 <TBG> How does it know all these functions
06:47:25 <TBG> @pl \(a,b,c) -> (a, b, c * 2)
06:47:25 <lambdabot> (line 1, column 7):
06:47:25 <lambdabot> unexpected "c"
06:47:25 <lambdabot> ambiguous use of a non associative operator
06:47:37 <TBG> Gnomed
06:48:17 <TBG> @pl \(a,b) -> (a, 2 * b)
06:48:17 <lambdabot> second (2 *)
06:48:21 <TBG> @pl \(a,b) -> (2 * a, 2 * b)
06:48:22 <lambdabot> (2 *) *** (2 *)
06:51:15 <dstolfa> @pl \(a,b) -> a
06:51:16 <lambdabot> fst
06:52:52 <dstolfa> @pl \(x::xs) -> \(y::ys) -> x+y
06:52:52 <lambdabot> (line 1, column 5):
06:52:52 <lambdabot> unexpected ":"
06:52:52 <lambdabot> expecting "()", natural, identifier, "_" or "("
06:53:50 <dstolfa> oh yeah this is haskell
06:53:51 <dstolfa> oops
06:53:59 <dstolfa> @pl \(x:xs) -> \(y:ys) -> x+y
06:53:59 <lambdabot> (`ap` tail) . (. head) . (const .) . (+) . head
06:55:17 <dstolfa> i wonder if it knows currying. \x -> \y -> x
06:55:23 <dstolfa> @pl \x -> \y -> x
06:55:24 <lambdabot> const
06:56:08 <dstolfa> ah i see, i think i know how it works, fun
07:09:45 <dmwit> tabaqui: Am I missing some context? You can use GADTs in `case` in Haskell.
07:10:57 <tabaqui> data Foo a where { Foo :: Foo Int; Bar :: Foo Char }
07:11:03 <tabaqui> you can write such function
07:11:12 <tabaqui> foo :: Foo a -> Int; foo Foo = 1; foo Bar = 2
07:11:14 <tabaqui> it is ok
07:11:54 <tabaqui> but you cannot "case a of { Foo -> 1; Bar -> 2}" (imagine that a comes here from another GADTs type)
07:13:27 <dmwit> % :set -XGADTs
07:13:27 <yahb> dmwit: 
07:13:36 <dmwit> % data Foo a where Foo :: Foo Int; Bar :: Foo Char
07:13:36 <yahb> dmwit: 
07:13:54 <dmwit> % (case undefined of Foo -> 1; Bar -> 2) :: Int
07:13:54 <yahb> dmwit: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:37:2 in interactive:Ghci17
07:14:02 <dmwit> tabaqui: Works for me.
07:14:17 <tabaqui> err, I cannot compile similar code
07:14:26 <tabaqui> ok, I'll check it carefully
07:14:30 <dmwit> Show us a minimal case, perhaps?
07:14:51 <tabaqui> it takes a time :)
07:14:55 * dmwit nods agreeably
07:14:56 <tabaqui> thanks anyway
07:18:23 <dmwit> % data X a = X a
07:18:23 <yahb> dmwit: 
07:18:27 <dmwit> % data Y a = X a
07:18:27 <yahb> dmwit: 
07:18:29 <dmwit> % :t X
07:18:29 <yahb> dmwit: a -> Y a
07:18:33 <dmwit> ...huh
07:19:14 <geekosaur> it's ghci underneath, you shadowed the old X
07:19:46 * dmwit nods
07:20:13 <tabaqui> dmwit: yeah, it works. "Keep calm and annotatate each tiny shit."
07:20:14 <dmwit> It just never occurred to me until now that shadowing might apply to constructors, too.
07:20:21 <merijn> The most lightweight parser for String is probably Parsec, I guess?
07:20:30 <dmwit> Of course in retrospect there's no reason for constructors to be special. =P
07:20:32 <dmwit> tabaqui: hah!
07:20:43 <merijn> attoparsec only does Text/ByteString and megaparsec seems like it has far more dependencies
07:21:01 <dmwit> merijn: ReadP/ReadS are lighter on dependencies. =)
07:21:11 <merijn> dmwit: Yes, but they suck donkey balls
07:21:25 <merijn> And have weird ass non short-circuiting semantics for <|>
07:21:41 <dmwit> Sure, sure, *now* you change the requirements.
07:22:43 <dmwit> Anyway, I think you know just about as well as anyone here the breadth of the ecosystem, and have almost certainly already made a sensible decision.
07:22:48 <dmwit> I say trust yourself and start hacking.
07:23:44 <merijn> dmwit: But decision making is hard! :(
07:24:45 <tdammers> decision making is *crippling*
07:24:53 <tdammers> bane of experience, really
07:25:08 <dmwit> YAGNI (where it = the perfect decision)
07:25:32 <merijn> tdammers: Tell me about it...I'm all decision fatigued out >.>
07:44:42 <merijn> Man...dealing with bounded sizes numeric types in Haskell is annoying as shit...
07:45:54 <Cale> Is it any more annoying as shit as in any other setting?
07:46:19 <merijn> Cale: Kinda, because everything else is so nice
07:47:19 <merijn> Cale: And I'm pretty sure it should be possible to add some combinators to help deal with things
07:47:20 <Cale> When you're working on binary level stuff, it kind of would be nice to have some dependently typed shenanigans for stuff like concatenation.
07:47:34 <merijn> Cale: vector-sized is pretty nice :)
07:47:55 <Cale> Though I guess you could also do those things in a non-dependently-typed way for a finite bunch of possible combinations
07:48:29 <merijn> Cale: My current issue is: "I want to parse a Word8, but this stupid parser uses the same dumbass wrapping logic as fromIntegral"
07:49:16 <merijn> If I want to parse a Word8, 334 should be a parse error, not 78
07:49:42 <merijn> So now I need to first parse as Integer, then check with a guard, and then fromIntegral to return a value
07:50:23 <merijn> Cale: Similarly, stuff like this "v < fromIntegral (maxBound :: Word8)" is pretty god awful to write all the time too
07:51:11 <Cale> ahhh
08:14:12 <remexre> is there a way to get hoogle with a cabal v2-*-using package without installing it globally?
08:44:00 <asheshambasta> If one has a module with 2 typeclass instances of a typeclass that has an associated data-type; and in each instance we have the assocaited datatype derive (Eq, Show) instances; and if I'm using this assoc. type in another module in another datatype that derives its eq/show instance; can it ever happen that the inner Eq,Show instances are not available to the outer type? 
08:44:37 <Solonarv> I don't think that problem can happen
08:44:58 <Solonarv> every module implicitly exports all instances that are in scope in the module
08:47:23 <asheshambasta> https://gist.github.com/asheshambasta/45e77286984fc0cf507ef21e1a0f10a3
08:47:48 <asheshambasta> It seems to be happening in my case; from the first module, I'm exporting `DBUpdate(..)`
08:48:44 <Solonarv> (btw, gists can have multiple files - don't need to use comments to separate them!)
08:48:48 <Solonarv> reading now
08:49:20 <asheshambasta> Solonarv: I was feeling lazy. I've added the explicit export, so please refresh :-) 
08:50:32 <Solonarv> Hm.
08:51:43 <Solonarv> I don't really know what's going on there tbh
08:52:02 <Solonarv> try a standalone deriving instance?
08:52:21 <asheshambasta> doing that in the source module doesn't help either. 
08:53:37 <Solonarv> I meant Module2
08:53:42 <asheshambasta> updated gist.
08:54:23 <Solonarv> nice :D
08:55:17 <Solonarv> try removing the 'deriving (Eq, Show)' clause in Module2 and replacing it with 'deriving instance _ => Eq (DBUpdate Baz)' (and same for Ord)
08:55:26 <__monty__> merijn: Isn't ReadP much lighter than Parsec?
08:55:39 <merijn> __monty__: Have you ever written a parser using ReadP?
08:55:48 <__monty__> For toy problems, yes.
08:55:53 <Solonarv> you'll need StandaloneDeriving and possibly also PartialTypeSignatures
08:56:00 <asheshambasta> Solonarv: even if that works; is this intentional? 
08:56:03 <__monty__> I hadn't caught up to the conversation yet.
08:56:14 <Solonarv> asheshambasta: as I said earlier, I'm not sure
08:56:18 <asheshambasta> if I'm not missing something obvious here; this seems like a bit of a bug to me. 
08:56:20 <merijn> __monty__: The backtracking behaviour of ReadP sucks donkey balls. I implemented one for the cabal.project format once...it was awful
08:56:31 <asheshambasta> if not a bug, at least unintuitive behaviour. 
08:56:32 <Solonarv> I'm not too familiar with the specifics of (associated) data families
08:56:33 <MarcelineVQ> merijn: yactoparsec is pretty light, for some meaning of the word :>
08:56:35 <merijn> __monty__: I don't care enough about lightweight to torture myself like that :p
08:57:35 <MarcelineVQ> yoctoparsec
08:57:40 <MarcelineVQ> weird word
08:58:03 <merijn> MarcelineVQ: It's really not, though
08:58:11 <merijn> MarcelineVQ: free has a ton of dependencies
08:58:30 <merijn> MarcelineVQ: Attoparsec has far less
08:58:54 <Solonarv> yocto is a (seldom used) SI prefix ;)
08:59:23 <MarcelineVQ> for some meaning :o
08:59:31 <merijn> Anyhoo, it's weekend, this code can sod off until monday
09:02:17 * hackage propellor 5.7.0 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-5.7.0 (JoeyHess)
09:35:17 * hackage massiv 0.3.0.1 - Massiv (Массив) is an Array Library.  https://hackage.haskell.org/package/massiv-0.3.0.1 (lehins)
09:53:47 * hackage datadog-tracing 1.4.0 - Datadog tracing client and mock agent.  https://hackage.haskell.org/package/datadog-tracing-1.4.0 (fommil)
10:13:47 * hackage persistent-qq 2.9.1 - Provides a quasi-quoter for raw SQL for persistent  https://hackage.haskell.org/package/persistent-qq-2.9.1 (parsonsmatt)
10:43:45 <Thousdayss> Hello, first time using freenode as well as haskell
10:44:45 <Solonarv> Thousdayss: hello!
10:44:54 <yushyin> Hi Thousdayss
10:44:58 <Thousdayss> I was wondering if my reasoning and hopes are well in place. What I was hoping for through learning haskell is to deeping my knowledge for problem solving as in coding challenges as well as in mathematics
10:45:24 <Thousdayss> Hey :) Solo and Yush
10:45:58 <Thousdayss> Now will learning haskell Help me through that or am I wasting time?
10:46:24 <Thousdayss> Sorry this is very broad but Im genuinly intrigued by the langugae
10:48:01 <lyxia> I'd say Haskell is a pretty good support for these goals.
10:49:18 <Thousdayss> I was wondering if there is something you would defenitly use haskell for, not any other language. For example C for kernel development, haskel for X.
10:50:34 <Solonarv> Compilers, web backend, generally anything that isn't super performance constrained and doesn't need to do graphics/GUI
10:50:59 <Solonarv> (you can do these things in Haskell too but it tends to be a bit more painful)
10:51:51 <lyxia> Why not GUI? Is it because of the lack of tooling?
10:52:19 <Thousdayss> Oh that clears up alor, How would you approach writing a compiler?
10:52:23 <Thousdayss> alot*
10:52:27 <Solonarv> I've had trouble getting any of the GUI libraries to even work for me
10:52:36 <Solonarv> of course it doesn't help that I'm on windows
10:53:18 <tabaqui> I wrote my own wrapper around ansi-terminal to draw frames, inputs, option lists etc
10:53:31 <Solonarv> well I've never written a compiler so I'm not entirely sure
10:53:48 <tabaqui> I would say, that Haskell provides a lot of tools to write gui library, but current implementations are far from
10:53:59 <tabaqui> dunno, useful
10:54:06 <Thousdayss> So mainly haskell is used for backend dev? and of course research?
10:54:24 <tabaqui> well, we use it for cloud architecture
10:54:26 <koala_man> Thousdayss: there's a lot of things Haskell is quick and comfy for, but I don't think there's anything where it's significantly better suited than all other options
10:54:26 <Cale> Thousdayss: I would generally use Haskell for nearly anything that wasn't so memory constrained that it needed to run on a small microcontroller or something. Where I work, we build web applications entirely in Haskell
10:54:35 <tabaqui> it works well and very stable
10:54:39 <Cale> Including the frontend as well.
10:55:27 <Cale> There's ghcjs, a compiler which will compile Haskell to javascript so that you can run your programs that control the contents of the DOM in a browser, or you can compile those same programs to native ARM code and have them control the DOM in a webview.
10:55:36 <Cale> (on a phone)
10:55:58 <Thousdayss> Ok now that is wild
10:56:23 <Thousdayss> hmmm I was wondering about AI
10:56:46 <Thousdayss> is it more performant than python at that?
10:57:17 <Solonarv> shouldn't be much of a difference in terms of performance, tbh
10:57:32 <Cale> It really depends. Haskell code is going to compile to faster code than python code will typically run at, but the numerical libraries for python that are written in C can sometimes be really good from what I've heard.
10:57:42 <Solonarv> the ML libraries in python are just wrappers around C libraries which do the actual work
10:57:43 <koala_man> when people do AI in Python these days, what they mean is they use something like TensorFlow where Python is a configuration language more than anything else
10:58:10 <Rembane> Numpy and scipy are state of the art. 
10:58:12 <Solonarv> most of the ML libraries in Haskell are similar IIRC (but there are less of them)
10:58:51 <Thousdayss> hmmm, so why does everyone here use haskell? Seems to me that it is mediocre at it's use cases but fun to write.
10:58:54 <Cale> It would be really neat to see some machine learning stuff using the Accelerate library
10:59:11 <Cale> Thousdayss: It's outstanding in a very general way.
10:59:27 <Thousdayss> How so?
10:59:55 <Rembane> Thousdayss: Haskell is the best when it comes to writing parsers and compilers and I enjoy that a lot. 
11:00:15 <Cale> It's not a special purpose language at all -- it's just really really good at letting you abstract and reuse code. Its type system and purity (restriction of side effects) make it drastically easier to maintain and understand existing code
11:00:28 <Rembane> I can refactor without fear. 
11:00:35 <Rembane> The type system <3
11:00:38 <Cale> It has really excellent support for concurrency vs. almost anything.
11:00:39 <Thousdayss> Rembane: I was wondering if you can link me some of your work, I'm very intrested in compilers
11:01:17 <Rembane> Thousdayss: I don't think I have anything I can share, but you can take a look at the Purescript compiler for instance, it is written in Haskell.
11:01:37 <Cale> Haskell programmers tend to forget about this, but pattern matching is just a really good way of working with data structures, and many languages don't even have that.
11:02:15 <Cale> Thousdayss: We have first class functions which are actually functions in a mathematical sense.
11:02:23 <fen> research?
11:02:29 <Cale> This is very unusual for a programming language :)
11:02:49 <Thousdayss> Cale: wait what
11:03:00 <Thousdayss> Cale: How does that work
11:03:20 <Cale> I mean that given the same inputs, a Haskell function always produces the same result, and doesn't do anything else.
11:03:24 <fen> Solonarv: got a lambdabot message...
11:03:29 <koala_man> Thousdayss: just because it's possible to write a program in Scala or OCaml doesn't mean Haskell is mediocre. Similarly, C is not a good language just because it's hard to get away from it.
11:03:43 <Cale> So you can test functions in isolation, and if they give you the correct result you were looking for, you know they'll give the same result in production.
11:03:44 <Solonarv> fen: ah yes I sent that yesterday right after you left
11:03:51 <adamCS> I'll second and third Cale wrt being able to abstract.  Haskell almost invites that way of thinking (how polymorphic could this function be? etc.).  And thinking about how general something might be often leads to much simpler and more fun code.
11:03:52 <Solonarv> I forget what it was about though
11:03:53 <fen> Solonarv|phone said 1d 36m 30s ago: [19:21] (fen_) still is there a way to compile C code to haskell and refactor it into common higher order programming patterns? - yes, but this is not a constructive proof
11:04:00 <Thousdayss> Cale: oh I see, so the code is kind of modular?
11:04:08 <Solonarv> ah haha very helpful message from me ;)
11:04:10 <fen> just what was that about? 
11:04:42 <fen> Thousdayss: whats this "useful for research" idea?
11:04:46 <Cale> Thousdayss: Yeah, this also helps with reusability, because such a function also doesn't rely on some particular context to do its job, other than what you explicitly provide it.
11:04:56 <Solonarv> well you asked if there was a way to compile C to Haskell, and I gave an (unhelpful) answer
11:05:19 <Cale> Thousdayss: It also means that we can reason about our programs the same way you'd reason about algebraic expressions in highschool.
11:05:30 <Cale> Thousdayss: You can always replace a function with its definition.
11:05:37 <Thousdayss> Fen: well I was thinking if you wanted to compute something let's say related to the twin prime conjecture or if you wanted to drive code to prove something in mathematics
11:05:46 <fen> is that because haskell programs are so awesome that you can publish them in jounrals!? 
11:06:11 <fen> Thousdayss: dont obfuscate your point
11:06:12 <Thousdayss> fen: Lol
11:06:14 <Cale> Thousdayss: In Haskell, if I see an expression like f x + f x, I know that I can replace that by 2 * f x and it will necessarily result in the same thing.
11:06:33 <Cale> Thousdayss: In C, if I see f(x) + f(x), I can't be sure that 2*f(x) is the same thing
11:06:45 <Thousdayss> Oh btw, I should say this
11:06:45 <Cale> (or really, most programming languages)
11:06:53 <Thousdayss> all I wrote so far was hello world
11:06:55 * Solonarv mumbles about things that pretend to behave like numbers but aren't
11:07:22 <Thousdayss> Im just wondering if learning it is helpful
11:07:27 <Cale> Solonarv: Well, I'm trying to make a point about equational reasoning without getting into e.g. bad instances of Num :)
11:07:35 <Thousdayss> and it seems it is, but the usecases are unclear
11:07:53 <Cale> Thousdayss: I also use Haskell for most shell-script-y like tasks
11:08:01 <Ariakenom> the ghost of floating point haunts Cale's thoughts
11:08:15 <Thousdayss> Cale: oh so like little python scripts for automation?
11:08:29 <Cale> Thousdayss: Yeah, I would do essentially all of that kind of thing in Haskell
11:08:45 <Cale> Really, Haskell is my default language for almost anything, and I need a very good reason not to use it.
11:08:45 <fen> isnt the stuff about ML in python just because its easier?
11:09:08 <Thousdayss> Cale: would you mind sharing your github? 
11:09:11 <Solonarv> well to some extent it's an ecosystem thing
11:09:31 <Cale> I don't put much on my github except that I have a couple work-related things there.
11:09:32 <Solonarv> the actual number crunching is written in C but there are python libraries that let you glue them together fairly easily
11:09:43 <Cale> I could link you obsidiansystems' github :D
11:09:52 <Thousdayss> Please!
11:10:00 <Thousdayss> >.<
11:10:04 <Cale> https://github.com/obsidiansystems/
11:10:06 <Solonarv> those glue/wrapper libraries are in python because the *other* glue/wrapper libraries are in python
11:10:07 <fen> for instance, if you wanted to compare a custom algo against an industry standard for a research paper on you new algo, you have an out the box version of something to compare it to. whereas in haskell you might have to implement both your algo and the one you want to compare it to!
11:10:08 <Thousdayss> ty!
11:10:12 <Cale> https://github.com/reflex-frp/
11:10:45 <fen> we have bindings to tensorflow and some implementations of ML algos, but not in as widely used package as python
11:11:21 <fen> Solonarv: what traslation from C and refactoring into common higher order pattern tools exist in haskell?
11:11:34 <Solonarv> I'm not sure what *tools* exist
11:11:59 <Solonarv> but there's a mechanical translation of imperative code into chains of function calls
11:12:08 <Thousdayss> Cale: Ok so finaly, I need somewhere to start. Where do I start learning haskell? 
11:12:30 <Solonarv> and I'm pretty sure there are (semi-) automatic Haskell refactoring tools
11:12:37 <Thousdayss> Cale: Stress on math would be a plus
11:12:38 <Solonarv> so in principle you could glue those together
11:12:42 <Cale> Thousdayss: http://www.cis.upenn.edu/~cis194/spring13/lectures.html is a good free set of lectures and assignments
11:13:09 <Cale> Thousdayss: There's also Graham Hutton's book "Programming in Haskell" which I highly recommend
11:13:26 <Cale> http://www.cs.nott.ac.uk/~pszgmh/pih.html -- this one
11:14:02 <Thousdayss> Oh thanks a million Cale
11:14:19 <fen> adamCS: that point is like Tousdayss original question, it encourages you to approach the problem in a different way. it helps you think about algorithms. thats because of referential transparency and equational reasoning. pythin does not have this
11:14:27 <Lycurgus> yello Thousdayss catching up with scroll
11:14:51 <Thousdayss> :) Hey
11:15:06 <Thousdayss> This is so nice, man I love this community already!
11:16:00 <Lycurgus> haskell is good for correctness and very high level programming not so much for mathematics in general although you could say that pure mathematics was its model of computation
11:16:05 <Lycurgus> still catching up
11:17:13 <Thousdayss> Oh I see, my bad I thought haskell was tightly tied to mathematical concepts
11:17:18 <Lycurgus> it's essentially useless for "AI"
11:17:24 <Cale> Haskell is a good programming language to use if you think mathematically -- I say this as someone who learned it concurrently with doing a BMath in pure mathematics :)
11:17:41 <fen> Cale: just catching up with the chat, didnt know about the link with obsidian and you mention cross compiling to arm, is there any development on GHC for android to work with android studio or the AIDE
11:18:12 <Cale> But it's not really great for doing mathematics itself. Its type system is structured a lot like an intuitionistic logic, but it's (either fortunately or unfortunately depending on your perspective) an inconsistent intuitionist logic.
11:18:42 <fen> Lycurgus> it's essentially useless for "AI" !!??? whhhat!?
11:18:50 <Thousdayss> Cale: That is intresting, how would I avoid learning it the wrong way? haha
11:19:23 <Cale> fen: I've heard nothing in that direction, but feel free to try out Obelisk.
11:19:24 <Lycurgus> Thousdayss, a landing for my web presences is meansofproduction.biz/eg/index.php/Praxis , still catching up
11:20:00 <Cale> Thousdayss: Avoid learning Haskell the wrong way?
11:20:26 <Cale> Thousdayss: I dunno, hanging around here, and asking lots of questions as you go would be a good start. :)
11:20:35 <fen> Cale: without a working linux kernal on android its not going to be easy to do integrated compilation. so it would need a rooted phone and a cross compiled GHC? 
11:20:49 <Cale> fen: Doesn't need a rooted phone.
11:20:53 <Lycurgus> so iiuc your goal is to deepen your knowledge of mathematics and 
11:20:58 <fen> where is the linux?
11:21:17 <fen> can we put one on haskell?
11:21:23 <Lycurgus> develop problem solving and coding skills?
11:21:25 <Thousdayss> Cale: Alright then, umm do you generaly hang around here at this time of day with the same nickname?
11:21:42 <Lycurgus> (caught up)
11:21:47 <fen> like, if you can run GHCi on android, and a linux kernal on GHCi, then you could compile GHC in that
11:21:52 <Cale> Thousdayss: I'm around a lot of the time, but often distracted by work.
11:22:13 <Cale> fen: Oh, no, we don't run GHCi on the phone, that's ridiculous
11:22:18 <Thousdayss> Cale: will try my best not to Annoy you, no promises
11:22:32 <Lycurgus> if that's the case, haskell, which has a very steep learning curve might not be right for you though ofc most here will disagree with me on that
11:22:38 <Cale> Thousdayss: There are a lot of friendly people around here who will be happy to answer beginner questions a lot of the time
11:22:44 <fen> why? that would be really useful no? avoid all the cross compiling fiasco
11:23:05 <Cale> fen: Compiling takes long enough as it is :)
11:23:20 <Solonarv> it's a lot slower though... and you need to get a ghci that can run on the phone in the first place!
11:23:22 <fen> this is not compelling
11:23:42 <Lycurgus> also although, as I said, it's model of computation is mathematics itself, in fact it is heavily focused on a particular thing called category theory
11:23:45 <Thousdayss> Yeah Lycurgus, the fact is Im into haskell because of the learning curve, vim, i3 are some of the weird stuff I got into because of the learning curve
11:23:45 <Cale> fen: We tend to just build our applications targetting the DOM, most things get hammered out with the app running on your desktop, then you can start deploying to the phone and testing things there.
11:23:59 <fen> well either you need a linux on android (there used to be gnurootdebian, still have on old emulator with a working version of that)
11:24:08 <Lycurgus> which is a tiny thing compared to the entirety of applied mathematics
11:24:13 <Thousdayss> Yeah I heard about category theory alot today
11:24:16 <fen> so you *can* have ghci in that
11:24:18 <Cale> fen: Why do you need that?
11:24:27 <fen> to use haskell on a phone!
11:24:30 <Cale> fen: No.
11:24:36 <Lycurgus> and somewhat impractical although it can do some impressive things other langs can't 
11:24:37 <fen> what!?
11:24:41 <Cale> You can compile Haskell to native ARM code and run it via JNI
11:24:52 <fen> on a phone?
11:24:55 <Cale> yes
11:25:03 <Cale> That's what we do
11:25:05 <fen> hmmm
11:25:07 <Lycurgus> also it's not the only lang in its class, you may want to look at ocaml which is similar
11:25:20 <Lycurgus> as far as AI is concerned
11:25:30 <Lycurgus> i would recommend starting with prolog
11:25:32 <fen> without using a linux kernal like the gnurootdebian app?
11:25:53 <Lycurgus> and of course lisp
11:26:04 <fen> wait, you mean compile it *on* the phone or *run* it on the phone
11:26:04 <Cale> That would be riduculous, since you could never put such an app in the app store.
11:26:12 <Cale> ridiculous*
11:26:19 <Lycurgus> both of which while having non traditional models of computation are a lot easier to learn than haskell
11:26:26 <fen> your cotesting the existance of an app that existed
11:26:27 <Cale> I mean compile it on desktop, run it on the phone
11:26:43 <fen> thats not using haskell on a phone tho
11:26:45 <Cale> Who the hell wants to run the compiler on their phone? That would suck.
11:26:56 <Lycurgus> prolog and list are the traditional AI langs
11:27:00 <Lycurgus> *lisp
11:27:17 <fen> it would enable android as an OS on which you could develop, which has been desired by many for years
11:27:17 <Ariakenom> that's not the same AI
11:27:35 <megaTherion> Cale: "Who the hell wnts to have a computer in their home? That would be sick." XD
11:27:58 <Cale> megaTherion: I mean, if it was comparably fast as my desktop machine, sure, I might find a use for it.
11:28:14 <fen> it would make haskell on par then with java and C as a language that supports Android, as the android integrated development environment allows android apps to be develoed on android
11:28:34 <fen> Cale: you can dual boot android on your desktop
11:28:43 <Cale> I... guess
11:28:46 <fen> or run an emulator if you need the extra resources
11:28:49 <Cale> I don't know why anyone would do that
11:28:51 <Cale> but okay
11:29:04 <fen> the point is its this that distingushes haskell as a *not for android* language
11:29:19 <Lycurgus> if you want a challenging learning curve, you've found it, although the things you mention won't be preparation 
11:29:21 <Cale> I don't see the distinction, if the application will run just the same
11:30:29 <Thousdays> Out of charge, T_T
11:30:51 <Lycurgus> otoh, plenty of people have transitted that learning curve to become productive hs coders, and you can too if you persist
11:31:12 <Lycurgus> beware the kool aid though
11:31:35 <Thousdays> I see
11:31:35 <Lycurgus> it's just another damn lang at the end of the day
11:31:51 <Cale> Lycurgus: Have you *tried* programming in other languages though?
11:31:52 <Cale> :D
11:32:04 <Thousdays> alright then Im off to the resources TY guys TY Cale
11:32:17 <Cale> Haskell has plenty of flaws, but at the same time...
11:32:37 <shapr> it sure is awesome
11:32:49 <fen_> the point is that if you want to avoid cross compilation, you would need to be on an ARM device, and have a cross compiled compiler (1st, we want this), then to avoid having to root that device to run the compiler, we want to be able to run GHC on android 
11:32:52 <Lycurgus> Cale, are you serious? You do know I'm the same Lycurgus as in the chat channel you forked?
11:32:53 <shapr> My favorite part is that I only have to think about changing stuff that's *right here*
11:34:04 <Cale> Lycurgus: I'm not sure I could say what your preferences were when it came to programming languages from the offtopic chats though :)
11:34:25 <Lycurgus> ah
11:34:55 <Cale> But yeah, like, on the one hand, there are a lot of things which constantly annoy me about Haskell, but then you compare the sum total of that with any one thing which is wrong with a mainstream programming language and it's hilarious.
11:35:04 <Lycurgus> https://thoughtcrime.biz/eg/index.php/Troika
11:35:42 <Lycurgus> being stuck on one lang is punk ass in my book
11:36:10 <Cale> Well, I'm not really stuck on Haskell, there are other languages which I would enjoy, but there are no practical libraries for them.
11:36:16 <Lycurgus> it means you are just short by some period of the attrit point when you'll be washed out of the biz 
11:36:32 <fen_> then you would want some way to call the AIDE in a hidden way, like from the command line, to bundle up the jar file or whatever it is that this GHC produces, and have some standard way to communicate the phone based resources, like porting more and more things, starting from tilt and camera, networking stuff etc, to the more advanced things, like controlling the cameras focus etc
11:36:46 <Cale> I don't mind being "washed out of the biz" -- if Haskell didn't exist, I certainly would not have the patience to be a software developer
11:36:53 <Lycurgus> that's said, i do think hs has pride of place in this time
11:36:59 <Lycurgus> *that said
11:37:03 <shapr> yeah, I agree with Cale, software is fun, but it's not everything
11:37:06 <Cale> I'd just move on and do something else with my mathematics degree
11:37:29 <fen_> for most simple things people could want to develop for fun, just basic controls would be enough, and if people could deploy to the app store, with a haskell only environment, running on android. well, thats the aim anyway
11:37:36 <Lycurgus> right, that proves the point I was making to the newbie
11:37:49 <fen_> also, then, you could deploy that tool to the app store and actually get revenue from such a project!
11:38:24 <Cale> The first thing I write in most programming languages just to see if they're going to waste too much of my time to be useful is 'map'
11:38:37 <fen_> i would pay a small amount to buy an app that saved me the trouble of cross compiling haskell to android and having to wrangle the FFI to feed the controls from android java into the haskell jar
11:38:42 <shapr> Lycurgus: what's the summary of your point?
11:38:44 <Cale> Most mainstream typed languages fall over right then and there
11:38:51 <Cale> For not having parametric polymorphism
11:39:05 <Cale> or not having first class functions
11:39:07 <fen_> Cale: can obsidian systems do this?
11:39:18 <Lycurgus> shapr, that hs probably was a mismatch to his stated goals
11:39:26 <Cale> fen_: Do what?
11:39:28 <shapr> oh, what were his stated goals?
11:39:34 <Cale> fen_: Avoid cross compilation?
11:39:44 <Cale> fen_: Not without a lot of money :D
11:40:02 <shapr> there are things I would like to crowd fund for Haskell
11:40:06 <Lycurgus> to learn mathematics, coding, problem solving (presumably as a person naive to all three)
11:40:09 <fen_> write a GHC that runs on android that we could download from the play store, that allows programs to be compiled to apk and uploaded to the play store
11:40:14 <Cale> fen_: But we have open source tools you can use today to make cross compiling easy
11:40:18 <shapr> huh, I think Haskell would be good for that
11:40:35 <fen_> Cale: easy!?!?!
11:40:45 <Cale> fen_: Yeah, it's pretty straightforward
11:40:57 <Lycurgus> yes it could be, but for the average bear it prolly isnt
11:41:05 <fen_> all your competitors agree! 
11:41:25 <shapr> maerwald: ghcup has saved me hours of difficulty
11:41:52 <shapr> Lycurgus: I went back to get a degree because people were asking me where I got my PhD
11:42:03 <shapr> and I had to tell them I'd never had a CS or Math course in college
11:42:27 <shapr> I'm not convinced the average bear exists
11:42:45 <Lycurgus> well I first went to a trade school (run by control data) to learn programming then went back and got a degree, did major in math
11:43:07 <Peppep> I recently discovered ghcid, which so far has been great. Is there any reason that it's not more widely known/advertised?
11:43:08 <fen_> shapr: you would need to use a support vector machine for that
11:43:23 <shapr> fen_: I used one for my bachelor's final project!
11:43:38 <Lycurgus> Peppep, what did you use as a front end?
11:44:17 <geekosaur> it's still fairly recent
11:44:24 <shapr> Lycurgus: I'd like to take a bunch of math courses
11:44:55 <shapr> I haven't figured out how to integrate ghcid into emacs with cabal new-*
11:45:04 <Lycurgus> shapr, i thought you already did
11:45:18 <shapr> Lycurgus: no, I took ... two?
11:45:33 <Lycurgus> ah, I was hoping Peppep would say vscode
11:45:37 <shapr> but I never took a linear algebra course, or a bunch of other stuff I'd like to learn
11:45:47 <Peppep> Lycurgus: I use Spacemacs with two terminals, one with ghcid and one with ghci
11:45:53 <Lycurgus> i breezed thru linear alg
11:46:16 <shapr> linear algebra looks neat the tiny bits I've read about it.
11:46:46 <Lycurgus> i was correcting/grading papers during the actual classes that the teacher in a grad level math stats course has suckered me into doing
11:46:58 <Lycurgus> but I still got an A
11:47:31 <Lycurgus> it was De Paul though, which is basically a liberal arts uni, though with a decent math dept
11:48:19 <Lycurgus> also I was very motivated for linear alg because I wanted to do OR, simplex, etc
11:48:33 <fen_> Cale: so having a linux kernal on top of android ready, and ghci working within it, and guessing that GHC wouldnt work for some reason to do with cross compliation, is there a place to obtain cross compiled GHC binaries for ARM?
11:48:45 <fen_> and if not, how can I produce these?
11:50:14 <Peppep> Lycurgus: Briefly tried it in VS Code too and saw no issues. Also, the nvim plugin seems nice: https://github.com/ndmitchell/ghcid/tree/master/plugins/nvim
11:50:17 <fen_> and, if other users dont have this old version of gnurootdebien, they could use a rooted phone running linux, so, then with the cross compiled GHC running, it would need to output something that could work with AIDE right?
11:50:23 <Peppep> Haven't decided what I'll stick with :p
11:50:26 <fen_> so GHCjs
11:50:35 <Lycurgus> Peppep, great, thanks that's what I wanted to know
11:50:55 <fen_> then what is the interface that pipes through eg tilt and camera controls to the haskell program?
11:51:20 <fen_> wait, did he go offline?
11:51:33 <Lycurgus> Peppep, did use HIE?
11:51:40 <Lycurgus> *did you
11:52:08 <zincy> shapr: Was going back and doing the degree worth it?
11:52:17 <shapr> zincy: it was informative
11:52:22 <shapr> zincy: not sure it was worth the money
11:52:28 <fen_> "a lot of money" sheeesh
11:52:40 <zincy> What degree was it?
11:52:49 <shapr> degree cost me about $32,000 USD, by the time I paid off the student loans, a bit over $40k
11:53:01 <Solonarv> oof
11:53:06 <shapr> and I already had 15 years software dev experience beforehand, so I could pay off the loans *quickly*
11:53:19 <Solonarv> those figures make me really glad uni is free here
11:53:23 <zincy> I am in a kinda similar position as you were
11:53:35 <zincy> would you have done it again if the degree was 10k dollars
11:53:45 <shapr> zincy: I'd be in school now if that were the case
11:53:49 <Lycurgus> when I was in college the US had policies more like the EU does now 
11:53:49 <shapr> I love taking classes and learning stuff
11:53:50 <shapr> and I love teaching
11:54:47 <shapr> wow, now I wonder if Lycurgus is as old as I am
11:54:47 <Lycurgus> not quite that good but a world of different from now
11:54:47 <Lycurgus> i'm prolly older
11:54:48 <shapr> Lycurgus: 71?
11:54:48 <Lycurgus> ok you got me
11:54:48 <zincy> So would you recommend it for someone with 3-4 years of experience in dev and no formal training
11:54:50 <Lycurgus> (if ur 71)
11:54:52 <shapr> Lycurgus: er, 1971 :-P
11:55:15 <Peppep> Lycurgus: Npoe. I installed it, which took forever, and backwards compatability seemed cumbersome. I tried adding useCustomHieWrapper, but I wasn't able to get it to work. Probably a noob mistake somewhere, but the Haskell layer in spacemacs + ghcid works well for now
11:55:53 <shapr> zincy: I'm about 55% against the monetary requirements
11:56:10 <zincy> shapr: What do you mean?
11:56:29 <shapr> I mean, it might work out to be a net benefit to you, but the number is steadily declining
11:56:41 <Lycurgus> Peppep, yeah there's somekina compatibility wrapper thing, presume that's what ur talking about
11:56:41 <shapr> if you get scholarships and other free stuff, it'll probably work out as a net benefit
11:56:52 <shapr> Lycurgus: were you born before 1971?
11:57:03 <Lycurgus> i was 17 then
11:58:19 <shapr> Lycurgus: ok you win :-)
11:58:42 <Peppep> Lycurgus: Are you using VS Code + HIE?
11:58:47 <shapr> and clearly we should hang out sometime, do you show up at ICFP?
11:59:06 <Lycurgus> no, I don't do conferences or the like
11:59:22 <shapr> aw, too bad
11:59:44 <Lycurgus> Peppep, I'm using vscode but not gotten any of the deep backend stuff for hs working yet
11:59:46 <shapr> I like meeting cool people
11:59:56 <shapr> I've met a large number of people from this IRC channel
12:00:01 <zincy> shapr: What kind of things do you like teaching?
12:00:15 <zincy> I am up for coding/learning sessions remotely
12:00:17 <shapr> zincy: mostly programming, but I also teach unicycling, cartwheels, Swedish, and knitting
12:00:25 <zincy> nice
12:00:33 <shapr> and soldering and arduino and some other stuff
12:01:14 <shapr> basic mental math, basic nomograms
12:01:14 <Peppep> It probably would've worked perfectly for me if I started from scratch, but I'm doing Uni assignments where we get parts of the code as handouts, any they're typically built with GHC 7.x
12:01:14 <shapr> usually all these happen to unsuspecting victims
12:01:15 <zincy> my email is tomw08@gmail.com
12:01:29 <zincy> Not sure how well a remote cartwheel tutorial session would work though :)
12:01:45 <Peppep> Haskero and ghcid doesn't complain about the discrepancy, but HIE did
12:03:05 <shapr> zincy: I have a video :-P
12:03:48 <Lycurgus> (Peppep, sorry I repeated my query about HIE, I will try just what ghcid needs)
12:04:07 <zincy> I am very passionate about learning programming, 1 year of Haskell experience so far. So for that matter anyone feel free to email me if you are interested in little tutorials.
12:05:12 <shapr> zincy: if you search "neopixel scarf compass" on youtube you can find my video with cartwheels
12:06:37 <Solonarv> Lycurgus: have you tried vscode-ghc-simple? it seems to work very well and doesn't need any extra backend tools other than ghc itself
12:07:23 <Solonarv> it recently got an update so it works with all kinds of workspaces (cabal v1/v2, stack, bare, and so on)
12:07:38 <Lycurgus> Solonarv, no I remember seeing it though, will give it a try, thx
12:08:50 <Lycurgus> (assume you mean dramforever's thing)
12:11:27 <Solonarv> yep, that's the one
12:30:17 * hackage parser-combinators 1.0.2 - Lightweight package providing commonly useful parser combinators  https://hackage.haskell.org/package/parser-combinators-1.0.2 (mrkkrp)
12:31:17 * hackage persist 0.1.1.2 - Minimal serialization library with focus on performance  https://hackage.haskell.org/package/persist-0.1.1.2 (minad)
12:58:42 <unrooted[m]> umm
12:58:43 <unrooted[m]> I need help
12:59:36 <dmwit> You are going to need to be more specific.
12:59:58 * unrooted[m] uploaded an image: image.png (27KB) < https://matrix.org/_matrix/media/v1/download/matrix.org/RIMhfbfSIYJivjpbOegLRAVE >
12:59:59 <unrooted[m]> this
13:00:05 <unrooted[m]> why this
13:00:07 <unrooted[m]> doesn't work
13:00:09 <unrooted[m]> WRRYYYYYY
13:00:25 <unrooted[m]> I'm not into Haskell that much, sorry guys
13:00:40 <dmwit> You have declared `Address`es to have four fields, but pattern matched on five.
13:01:32 <dmwit> You should probably also use Word8 instead of Int.
13:01:41 <unrooted[m]> did I
13:01:42 <unrooted[m]> just forgot
13:01:43 <unrooted[m]> another `Int` on line 5.?
13:01:58 <dmwit> By the way, in the future, it's preferred that you use an online pastebin to include your code, together with a copy of the error it produces.
13:02:04 <unrooted[m]> WRRYYYYYY
13:02:06 <unrooted[m]> thanks man
13:02:10 <dmwit> Images make it difficult for us to reproduce your problem and test our proposed fixes locally.
13:03:22 <unrooted[m]> okie, np with that
13:06:19 <dmwit> (Also I find it puzzling that you found my comment useful, given how similar the error is: "The constructor Address should have 4 arguments, but has been given 5 in the pattern: Address ip0 ip1 ip2 ip3 port"
13:06:23 <dmwit> )
13:07:18 <fen> how do you have a class for "bounded" type lengthed things? they would have to somehow extend their "set" instances to throw an error if the types were wrong. is that a dynamic type error, ie at runtime, so does it need reflection?
13:07:44 <dmwit> What is a "bounded type lengthed thing"?
13:07:55 <fen> like, for bounded nats
13:08:27 <dmwit> Generally they will either carry or be given a piece of data describing their size.
13:08:40 <dmwit> e.g. in GHC the KnownNat constraint provides this data.
13:08:41 <fen> defined by throwing errors if the type that is the length exceeds the type that is the bound upon Set
13:09:50 <dmwit> "bound upon Set"?
13:09:52 <fen> class KnownNat (n :: Nat) Source#  This class gives the integer associated with a type-level natural. There are instances of the class for every concrete literal: 0, 1, 2, etc.  Since: 4.7.0.0  Minimal complete definition  natSing
13:10:00 <fen> thats just a singleton returning the length
13:10:07 <fen> like, unreflecting it from type level
13:10:11 <dmwit> Correct.
13:10:21 <fen> > range (1,10)
13:10:22 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
13:10:34 <fen> :t maxBound
13:10:35 <lambdabot> Bounded a => a
13:11:23 <fen> whats a type lengthed list? a list with a fantom parameter of type Nat ?
13:11:39 <fen> so a bounded version would be that with BoundedNat instead
13:11:58 <fen> oh wait thats a kind of circular argument if Nats are lists...
13:11:59 <fen> hang on
13:12:13 <dmwit> As always I find your questions very slippery. Each time I think I understand them you clarify in some way that completely wrenches them out of my hands.
13:12:41 <dmwit> What is BoundedNat? Which one of the many variants of length-indexed lists are you thinking of?
13:12:56 <fen> dmwit: yeah, set is the only thing that can increate the length, so we can be sure that if everything else uses set, then set is the only thing  that needs to throw an error when the length is attempted to exceed the bound
13:13:25 <fen> dmwit: type Nat = [()]
13:13:36 <dmwit> (...and what is "set"? Was "increate" just a typo, or is that a term I don't know?)
13:13:51 <fen> increase!! 
13:13:55 <fen> like cons
13:14:21 * ski isn't sure what this has to do with sets ..
13:14:22 <fen> like, if you ++ 2 bounded lengthed lists and the length exceeded the bound, then it would be set that throws the error
13:14:32 <fen> not set like set, set like set
13:14:38 <fen> get*
13:14:58 <dmwit> ...
13:15:02 <fen> the inverse of get!
13:15:04 <fen> like cons
13:15:30 <dmwit> What is a "bounded lengthed list"?
13:16:03 <fen> a list of length given in its type, where this cannot exceed the bound, also given in its type
13:16:17 <fen> it would throw a type error?
13:16:24 <fen> and that would happen at runtime?
13:16:33 <dmwit> Then presumably you would have `(++) :: BoundedList n a -> BoundedList n' a -> BoundedList (n+n') a` or similar.
13:16:38 <fen> yeah!
13:16:45 <fen> thats a class right?
13:16:46 <dmwit> No runtime error. It always succeeds.
13:16:53 <fen> no it will not!
13:17:04 <fen> it will throw an error if it exceeds the bound
13:17:09 <fen> thats the defining behaviour!
13:17:18 <dmwit> The bound of the return type is chosen so that (++) will not exceed it.
13:17:31 <fen> no the bound is the same
13:17:38 <dmwit> (Or at least that's how I chose it when I hypothesized a type for this hypothetical thing I don't even know an implementation of.)
13:17:44 <fen> like if you add 2 ints together, the maxInt value does not change!
13:18:01 <fen> so if we have BoundedNat = BoundedList ()
13:18:11 <ski> you want both the actual length, and an upper bound for it, in the type ?
13:18:28 <zachk> can ghc do dependent length vectors yet? 
13:18:32 <fen> well you would need both to do the bound check right?
13:18:39 <Solonarv> depends on what you mean by "dependent", zachk
13:18:52 <dmwit> zachk: ish. It's still frustrating as heck to prove that two type-level expressions turn out to be equal.
13:18:53 <Solonarv> if you just mean "vectors with length in the type", yes
13:18:56 <ski> (and the upper bound wouldn't change on such a concatenation operations, which then could possibly fail if the resulting length would otherwise exceed the bound)
13:19:15 <fen> yes!
13:19:19 <zachk> stuff like (++) :: Vect m a -> Vect n a -> Vect (m+n) a ? 
13:19:38 <fen> but that (n+m) should fail if its beyond the bound
13:19:44 <Solonarv> zachk: yeah, that's perfectly doable
13:19:55 <ski> Solonarv : .. i'd add "with length possibly depending on argument or run-time input (a value)"
13:20:05 <ski> (otherwise i'd not call it "dependent")
13:20:14 <Solonarv> that's why I asked what was meant
13:20:27 <fen> BoundedList b m a ++ BoundedList b n a = BoundedList b (if n+m > b then error"" else n+m) a
13:20:45 <Solonarv> even that is possible, but you have to hide the runtime-known length in an existential
13:21:04 <Solonarv> fen: yeah, perfectly doable
13:21:14 <ski> fen : ok, sounds like what i was supposing, then
13:21:17 <fen> but its a runtime type error right?
13:21:18 <Solonarv> although that's a slightly odd way of encoding that IMO
13:21:29 <Solonarv> it's not a "runtime type error"
13:21:35 <fen> yeah obviously not with the if then else and error in the type signature
13:21:52 <fen> Solonarv: but i dont know how long these lists might be at compile time!
13:22:04 <ski> Solonarv : yes, but existentials are clunky. and afaik you still can't express `foo : (n :) Nat -> Vec Int n' (can you ?)
13:22:11 <zachk> does ghc have dependent pairs as well? 
13:22:19 <Solonarv> it's a runtime error yes, but not a runtime *type* error
13:22:29 <fen> but its a comparison between types that fails?
13:22:45 <ski> zachk : no dependent functions, no dependent pairs
13:23:10 <ski> zachk : you can simulate some uses, via singletons
13:23:10 <fen> like the kind of error you would get if you tried to add lists of different bounds together
13:23:30 <Solonarv> you can perfectly well write '(++) :: (m+n <= b) => BoundedList b m a -> BoundedList b n a -> BoundedList b (m+n) a'
13:23:36 <Solonarv> no type errors anywhere
13:23:57 <Solonarv> although you might have some trouble proving (m+n <= b) if the lengths aren't known at compile time
13:24:01 <fen> http://hackage.haskell.org/package/fixed-list-0.1.6/docs/Data-FixedList.html#t:Append
13:24:08 * ski thinks fen (for some reason) wanted a run-time check `m+n <= b'
13:24:17 <fen> yeah!
13:24:20 <fen> why isnt it?
13:24:34 <fen> Solonarv: nice!
13:25:38 <fen> https://pastebin.com/raw/UB37TQer
13:25:45 <fen> thats the previous version of Nat
13:26:05 <fen> but, it should probably use a type level list instead..
13:26:19 <fen> then it can just use eg (++) as its (+) implementation
13:27:28 <Solonarv> actually I'd rather keep the S/Z encoding you have there
13:28:01 <Solonarv> compile times are already slow enough when doing type-level stuff, and it's not like [()] is particularly more enlightening
13:28:24 <fen> no but this is supposed to be for all Set instnaces
13:28:25 <ski> fen : you have one type-level `N', and one kind-level `N' there, but they're unrelated. with dependent types, you'd be able to relate them, or claim they're the same, so that you could say things like `replicate :: (n ::) N -> a -> Vec a n' (assuming `Vec :: * -> N -> *')
13:28:31 <fen> Set like Get like cons...
13:29:34 <fen> Replicate is here; https://pastebin.com/raw/UeDKErW7
13:30:59 <ski> (i suppose with `TypeInType' they would actually be the same `N', but you still can't express that `replicate', and so it's not dependent types. you can simulate it if you have a singleton type, `data NatIs :: N -> * where IsZ :: NatIs Z; IsS :: forall (n :: N). NatIs n -> NatIs (S n)', i.e. `replicate :: forall (n :: N). NatIs n -> a -> Vec a n' (`a' is either `forall'-bound as well, or is fixed to some particular type))
13:31:25 <fen> bound?
13:32:08 <ski> fen : yes, but that's a type-level version of the ordinary `replicate :: Int -> a -> [a]' (using `N' instead of `Int'), which is not what i was talking about
13:32:27 <fen> there was some other version with that using singletons, but nvm now, its more important how to have this bounded class
13:33:18 <fen> and certainly the preffered version would use [()]
13:33:26 <fen> so that we could have BoundedNat = BoundedList ()
13:34:39 <fen> but yeah, its a class because anything that is a Set instance, with set :: (a,f a) -> f a
13:34:46 <fen> can have a "bounded" version
13:34:59 <fen> and have this kind of type level check
13:35:24 <fen> proabbly it also first needs a type level length stored with it, but thats just a phantom type
13:36:01 <fen> type TypeLengthed (n :: N) f = f a 
13:36:04 <fen> right?
13:36:39 <fen> type TypeLengthed (n :: N) ((Get f,Set f) => f) = f a 
13:36:59 <fen> type TypeLengthed (n :: N) f = (Get f,Set f) => f a 
13:37:05 <fen> sorry...
13:38:02 <fen> its then "extending" the class Set so its function set throws an error for all its instances when they are promoted to being TypeLengthed
13:38:10 <fen> thats the problem, how to encode that!?
13:38:28 <fen> when the bound is exceeded it throws the errot
13:38:41 <fen> >:|
13:40:47 * ski 's not sure how a type class `Set', (presumably) parameterized on `f', with a method with signature `set :: forall a. (a,f a) -> f a' would be useful
13:41:04 <fen> its very useful!
13:41:21 <ski> what is the implementation of `set', for some particular choice of `f' ?
13:41:40 <Solonarv> ski: a more evocative name might be 'Cons'
13:41:43 <ski> can `f' be `[]' ? `Maybe' ? some notion of tree or vector ?
13:41:44 <fen> it unifies any of the users custom list types which are essentially equivalent, as is the purpose of a class
13:41:59 <fen> well, thats not quite enough, it needs to be Get + Set
13:42:15 <fen> oh yeah, actually thats a stream, its infinite
13:42:22 <ski> Solonarv : hm, ok. i suppose i was thinking of it maybe replacing a designated "focus" position with the given value
13:42:27 <fen> so lets have set :: Maybe (a,f a) -> f a
13:43:04 <ski> i'm still wondering which particular instances you have in mind
13:43:04 <fen> fine we can call it the Cons class to avoid confusion with the Set thing which is like a vector
13:43:12 <fen> all the possible instances!
13:43:28 <ski> which instances, specifically, do you have in mind ?
13:43:38 <ski> name some examples :)
13:43:52 <fen> MyList1 a = Nil1 | Cons1 a (MyList1),MyList2 a = Nil2 | Cons2 a (MyList2)
13:43:54 <fen> etc
13:44:13 <ski> so .. just ordinary lists ?
13:44:15 <fen> sorry thats missing a parameter a
13:44:24 * ski autocorrected it
13:44:24 <fen> yeah, anything isomorphic to list
13:44:34 <ski> why does this need a type class, then ?
13:44:41 <fen> thats the point of these Cons + Uncons classes
13:44:53 <fen> to make all implementations of lists use the same pattern
13:45:04 <ski> if you want a list, why not simply use a list directly, why invent these alpha-renamed versions of the list data type ?
13:45:09 <dibblego> @type cons
13:45:10 <lambdabot> Cons s s a a => a -> s -> s
13:45:57 <fen> its here
13:45:58 <fen> https://gist.github.com/fen-hs/9772c2ce27a355984add2e5b7d352fbb
13:46:03 <fen> on line 42 of FIFO.hs
13:46:07 <fen> (:::)
13:46:28 <fen> serves like pattern matchin on (:) for any Stream, including Stacks which are these List-Like things
13:46:54 <ski> fen : i see no mention of the `instance' keyword in that paste
13:46:56 <fen> Trees are Stack_i, they use (::::) and have extra shape parameter
13:48:06 <fen> ski: https://pastebin.com/raw/2XSdifDi
13:48:17 <fen> there is the instance for Linear Nonempty
13:48:40 * ski is always a bit confused by fen's bewildering array of type classes, all (a slight exaggeration) looking somewhat, but not completely, similar to one another
13:49:08 <fen> "i" is supposed to mean index, as in shape directing index
13:49:32 <fen> you get the navigations between two adjacent values stored alongside those values
13:49:42 <fen> implicitly as part of the way the tree is traversed
13:50:00 <fen> anyway, this is just showing that there are more "first in first out" things than just list
13:50:05 <fen> the point is that they have set
13:50:20 <fen> and so they can throw an error if that exceeds the specified bounds
13:50:29 <fen> on this new "bounded" thing
13:50:40 <fen> so you could have a bounded tree for example
13:50:45 <fen> because it has a Set_i instance
13:51:34 <fen> the difficulty is making existing types like list, into bounded things, and having some kind of way to make set throw this extra error
13:51:56 <ski> ok, so `[]' is meant to be an instance of `Get',`Set',`Set0',`Set1' but not of `Get0',`Get1', while `Nonempty' is an instance of all these, is that right ?
13:52:50 <fen> here are the list instances for Stack https://pastebin.com/XJkvNtzq
13:53:08 * ski thought queues were "first in first out" (FIFO), while stacks/lists were "last in first out" (LIFO)
13:53:19 <fen> shit
13:53:29 <fen> argh ffs
13:53:30 <ski> (or are you using single-linked lists to encode queues ?)
13:53:35 <fen> sorry
13:53:42 <fen> yeah LIFO!
13:54:11 <ski> no worry, i can understand mixing them up, if you're not thinking that much in particular about it
13:54:22 <fen> pfff
13:54:41 <fen> ski: no its the other way round, List has all the instances, it is a Stream, it is linear and its a Stack
13:54:47 <fen> while nonempty is not a Stack
13:54:51 <fen> it does not have empty
13:55:03 <ski> isn't that what i said, though ?
13:55:56 <fen> [] has get0 + get1 + get, and set0 + set1 + set.
13:56:00 <fen> nonempty has;
13:56:09 <fen> get0 + get1, and set0 + set1
13:56:19 <fen> it does not have get or set
13:56:24 <fen> these are just for stacks
13:56:38 <fen> 1 indicates "at least one value"
13:56:44 <fen> 0 indicates "no end!"
13:57:45 <fen> you might think that Stack would be more like the "0 thing", because it has a zero values constructor
13:57:55 <fen> but thats the wrong order wrt traverse and fold
13:58:12 <fen> which have no suffix for the Stack version
13:58:29 <fen> so we have eg Foldable0 for streams
13:58:38 <fen> which does not require a basecase
13:59:02 <fen> foldr0 :: f a -> (a -> b -> b) -> f b
13:59:20 <fen> foldr1 :: f a -> (a -> Maybe b -> b) -> f b
13:59:31 <fen> foldr :: f a -> (Maybe (a,b) -> b) -> f b
13:59:59 <fen> so (Maybe (a,b) -> b) is called C0State
14:00:03 <fen> coState*
14:00:14 <fen> (a -> b -> b) is CoState0 a b
14:00:22 <ostfale> hello, can someone explain to me quite simply, why IO-actions must be linked together?
14:00:23 <ostfale> in C you simply knock several print instructions one after the other, neatly separated from each other with semicolons, but in Haskell there is always a >> or >> = necessary.
14:00:25 <fen> (a -> Maybe b -> b) is CoState1 a b
14:00:38 <ski> so how does `get0' and `get1' work on `[]', if you feed them the empty list ?
14:01:07 <glguy> :t do print 'a'; print 'b';
14:01:08 <lambdabot> IO ()
14:01:37 <fen> *Data.ListInstances> get1 [] *** Exception: get0 []
14:01:44 <ski> ostfale : think of the `>>' or `>>=' as our version of `;' (and you can use actual `;' in `do'-syntax, instead, as glguy just showed)
14:01:46 <fen> *Data.ListInstances> get0 [] *** Exception: get0 []
14:01:54 <ski> @undo do print 'a'; print 'b';
14:01:54 <lambdabot> print 'a' >> print 'b'
14:02:03 <ski> those two expressions mean the same thing
14:02:04 <glguy> ostfale: You can link IO actions together in Haskell with semi-colons just the same. C just lacks the ability to name those sequences without defining a new procedure
14:02:08 <im0nde> Beginner question: Just starting out with haskell and stack. I'm trying to run a program that has "import           Network.HTTP.Simple
14:02:34 <fen> if you follow how we defined the listinstances here; https://pastebin.com/raw/XJkvNtzq
14:02:34 <im0nde> but I'm missing this module. What do I have to add as a dependency in the package.yaml file>
14:02:50 <im0nde> how do I find the corresponding deps in general?
14:03:02 <im0nde> I already added 'http-client'
14:03:11 <ski> fen : ouch, so `get1' and `get0' are partial on `[]'. i thought one of the points of having these different versions would be to avoid partiality
14:03:23 <fen> yeah, the defaults are used unless its get, which overrides this by matching on empty
14:03:32 <Solonarv> im0nde: usually searching for the module name on hackage or stackage should tell you that
14:03:45 <fen> it guards for empty and otherwise uses the superclass implementations. thats how the default is defined
14:03:53 <Solonarv> im0nde: example: https://www.stackage.org/lts-13.15/hoogle?q=Network.HTTP.Simple
14:04:00 <fen> ski: partial?
14:04:45 <ski> fen : aborting the computation, typically in case of some matching failure, or a guard (or `if') failing. possibly by calling `error' (or using `undefined')
14:05:06 <ostfale> glguy:  what do you mean exactly?: „C just lacks the ability to name those sequences without defining a new procedure“
14:05:07 <fen> just dont use a stream or linear get when working with stacks!
14:05:14 <geekosaur> ostfale, the short version is that in Haskell, everything is an expression
14:05:25 <ski> "linear get" ?
14:05:30 <fen> get1
14:05:33 <im0nde> Solonarv: I'm looking at the page. What is the name then, is it also called Network.HTTP.Simple ?
14:06:05 <fen> stream suffix = 0, linear suffix = 1, stack suffix is nothing
14:06:07 <Solonarv> im0nde: nope
14:06:17 <Solonarv> click the first result, that's the documentation for that module
14:06:18 <fen> linear is like nonempty
14:06:33 <Solonarv> at the top of the page you can see the name of the package it's in (here, 'http-conduit')
14:06:34 <ski> ok
14:06:52 * ski would perhaps call it "relevant" rather than "linear", though ..
14:07:10 <geekosaur> C thinks in terms of statements, Haskell in terms of expressions; so to combine two operations like that you use an operaor. (As shown, do notation gives you something resembling "statements", but it translates to the expression form)
14:07:32 <fen> well, there is another way to do it which avoids all these named synonyms just by referring to the type of the State used to unfold it
14:07:32 <ski> (to me, "linear" would suggest "exactly one", rather than "at least one" (relevant). there's also "affine" for "at most one")
14:07:33 <ostfale> so, in the end, only one connected expression may be after an = sign (for function definitions), or after "let ... in"?
14:07:55 <fen> ski: https://pastebin.com/raw/mDdjGUKL
14:08:00 <Solonarv> ostfale: yep
14:08:04 <im0nde> Solonarv: AH! i see. This might seem obvious, but if you don't yet fully understand what the information means it's actually not 
14:08:08 <fen> right, but its just names
14:08:09 <Solonarv> of course, there are many ways to combine expressions and make new ones
14:08:28 <im0nde> Solonarv:Thanks for the example, from that I think I'll be able to figure out the rest
14:08:42 <fen> and yeah, there should really be a way to gather all these up into one class parametrised by the distribution of Maybes over the State
14:08:43 <ski> ostfale : yes, just like in C, after `int main(int argc,char *argv[])' there's only a single block
14:09:01 <ostfale> ok, and how is that in pascal, or python, where those annoying semicolons are not needed like in C?
14:09:01 <fen> so whats happening now is trying to define states for nested things
14:09:12 <fen> like streams of stacks of linear containers of streams etc
14:09:13 <ski> (and after `if (...)' or `else' or `while (...)' or `do', there's only a single command/statement)
14:09:27 <ski> (hm, i forgot `switch (...)')
14:09:28 <fen> and the State corresponding to this is a complex beast
14:09:43 <Solonarv> ostfale: those languages just wanta newline, instead of a semicolon
14:09:48 <Solonarv> same idea though
14:10:02 <ski> (that single command is typically a block, though, containing a sequence of commands inside it)
14:10:03 <fen> Either (a,Either s N) N
14:10:12 <fen> but where these N "have the same bound"
14:10:25 <fen> hence the whole type bounding debacle 
14:10:52 <fen> the N there is saying at what depth the state failed to produce a value
14:11:08 <fen> and it can produce a value and fail to produce a state
14:11:13 <fen> (linear)
14:11:38 <fen> anyway, never mind that, it will be clear with an implementation, but this requires bounded lists!!
14:15:36 <geekosaur> yeh, those languages you can think of as saying "that line doens't need anything else so it must be a single statement". (python is a little more complex as it also uses indentation. and in fact, so does haskell, but you notice only in do syntax because it pretends to be statements instead of a single expression)
14:17:03 <Solonarv> "you notice only in do syntax" - also let, case, if
14:18:21 * ski . o O ( `\case' )
14:19:17 <fen> ski: if you were pattern matching using (:::) you would just guard using the Empty pattern to ensure you didnt hit an error on []
14:19:18 <im0nde> I'm getting a lot of errors like these: Couldn't match expected type ‘S8.ByteString’                                                                                                                                                                                            
14:19:19 <im0nde>                   with actual type ‘[Char]’ 
14:19:21 <geekosaur> less so, though
14:19:36 <im0nde> From an example of the http-client docs
14:19:47 <Solonarv> im0nde: are these errors on string literals?
14:19:52 <im0nde> Solonarv:yes
14:20:01 <geekosaur> you may have missed it telling you to enable OverloadedStrings
14:20:42 <im0nde> geekosaur: No, i put it in there https://gist.github.com/binaryplease/740bff5b9f58a52798090a565eafa141
14:20:52 <oliver70> i wanna print the arguments while doing a recursion, here is my code: https://pastebin.com/6KXGQXXg
14:21:00 <geekosaur> top of the file
14:21:10 <ski> fen : possibly i've said before, but i wouldn't call your `CoState' that. rather i think of something like `data CoState i a = MkCoState i (i -> a)' .. hmm, not sure what it would be, taking the `Maybe'-in-the-middle into account
14:21:11 <geekosaur> if it sees a keyword, it's too late for LANGUAGE pragmas
14:21:19 <Solonarv> im0nde: language pragmas must be at the top of the file, before the module header
14:21:36 <im0nde> I see.
14:21:52 <fen> ski: what?
14:21:56 <im0nde> Guess these are the pitfalls when you try to learn by "just doing"
14:22:03 <ski> oliver70 : if this is for debugging, see `trace'
14:22:06 <ski> @index trace
14:22:06 <lambdabot> Debug.Trace
14:22:13 <Solonarv> fortunately you have an entire IRC channel to help you out ;)
14:22:13 <ski> @type Debug.Trace.trace
14:22:14 <lambdabot> String -> a -> a
14:22:38 <geekosaur> traceShowId is often a convenient helper for that
14:22:43 <oliver70> not for debugging
14:22:44 <fen> how is (i,i->a) supposed to be like ((a,s) -> s)
14:23:05 <im0nde> Solonarv: I can't tell if thats ironic. I really appreciate the help, but don't want to bother you  guys with too many trivial questions
14:23:11 <oliver70> other possibilities than trace
14:23:11 <benzrf> fen: do you mean (s -> (a, s)) ?
14:23:13 <Solonarv> im0nde: not ironic at all
14:23:24 <ski> oliver70 : then you need something like `turnU :: String -> IO String' or `turnU :: String -> Writer [String] String'
14:23:32 <benzrf> :k Store
14:23:33 <lambdabot> error:
14:23:33 <lambdabot>     Not in scope: type constructor or class ‘Store’
14:23:33 <im0nde> Solonarv: Then, as said, I really appreciate it
14:23:40 <benzrf> @let import Control.Comonad.Store
14:23:42 <lambdabot>  <no location info>: error:
14:23:42 <lambdabot>      The package (distributive-0.5.3) is required to be trusted but it isn't!
14:23:42 <Solonarv> although if you do want some learning material:
14:23:42 <Solonarv> @where cis194
14:23:42 <Solonarv> @where pih
14:23:42 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
14:23:42 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
14:23:43 <fen> benzrf: thats state, we want costate
14:23:44 <benzrf> hmm
14:23:56 <benzrf> https://hackage.haskell.org/package/comonad-5.0.4/docs/Control-Comonad-Store.html
14:23:57 <im0nde> Endgoal is to write a simple matrix bot
14:23:58 <fen> never mind store
14:24:03 <fen> its totally different
14:24:07 <benzrf> how so
14:24:08 <fen> its more like a pointer
14:24:09 <ski> im0nde : see those ^ fine links Solonarv suggested
14:24:45 <fen> one problem is that it does duplicate and then navigate for extract
14:25:08 <fen> see this; https://pastebin.com/raw/2XSdifDi
14:25:20 <fen> we just want something dual to something else that captures the type of get and set
14:25:38 <ski> fen : "how is (i,i->a) supposed to be like ((a,s) -> s)" -- it's not. "Co" suggest a dual. i wouldn't say conjunction is "like" disjunction, or a universal quantifier "like" an existential quantifier, e.g.
14:26:18 <fen> oh what you mean (s,(s -> (a,s)))
14:26:33 <fen> no..
14:26:37 <fen> no i dont knwo what you mean
14:27:14 <ski> oliver70 : do you have an idea of how to use `IO' or `Writer' to achieve what you want ? .. a simpler (more verbose, but less advanced/abstracted) version of the `Writer' one would be `turnU :: String -> ([String],String)'. perhaps you should give that a go, first
14:27:27 * ski blinks
14:27:48 <fen> benzrf: we just want a type by which to parametrise the various containers, store is a class its totally different
14:28:30 <fen> linear <-> get of type (f a -> (a,Maybe (f a)))
14:28:59 <fen> so we are just having various ways to distribute Maybe over a "state" type
14:29:08 <fen> and flip the arrow backwards to get the costate
14:29:19 <fen> not like a state monad store comonad
14:29:43 <fen> just litterally the way these maybes are distributed is defining equivalence classes of containers
14:30:18 <ski> fen : `Store i a' could be thought of as a structure/collection of `a's, with pointers/indices of type `i' pointing to those `a's, and a particular index being selected as current (iow a particular element being selected as focused)
14:30:49 <fen> s -> Maybe (Maybe (a,s)) corresponds to (Stack f,Stack g) => s ~ f (g a)
14:31:21 <ski> % :m + Control.Comonad.Store
14:31:21 <yahb> ski: 
14:31:25 <ski> % :t runStore
14:31:25 <yahb> ski: Store s a -> (s -> a, s)
14:31:27 <fen> then we can nest up the Maybes to some depth, and have Maybe (Maybe ... (Maybe x)) ~ Either x N
14:31:30 <ski> benzrf ^
14:31:51 <fen> ski: exactly, its more like a pointer class
14:32:06 <ski> it's not a type class at all
14:33:01 <fen> its an encoding of a get function where you hide the fact that s ~ f a ?
14:33:42 <fanzy> Hey folks, new here, interested in learning FP the proper way (I'm a FE dev leaning towards FPish style in vanilla JS but feeling like I don't quite know the extent of what FP is)
14:33:46 <fen> while all the classes here are over `f' and recursion schemes are over `f a'
14:34:12 <fen> i cant fathom the advantage, other than capturing some extra level of abstraction
14:34:55 <ski> hello fanzy
14:35:22 <ski> fanzy : do you have some plan of action ?
14:36:00 <ski> some tutorials to look at, or perhaps videos, if you prefer. possibly thinking about getting some textbook ?
14:36:16 <ski> if you have questions, then please ask
14:36:34 <fanzy> @ski the haskell book seems like a good place to start with it's chapter on lambda calculus
14:36:34 <lambdabot> Maybe you meant: wiki src ask
14:36:54 <mjrosenb> so, continuing from earlier, is there an operator like <%=, but which can operate on a traversal (I happen to know that the traversal will always focus on exactly 1 element, but if it could be 0 or 1, I can also make it work)
14:37:28 <fen> you mean a skip container?
14:37:36 <fen> you could check the streams package
14:37:44 <ski> fanzy : i haven't looked at HPFFP, but it seems many people have liked it
14:38:16 <ski> fanzy : some other textbooks people seem to like are
14:38:19 <ski> @where PIH
14:38:19 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
14:38:42 <fanzy> ski: checking that out now
14:39:01 <fen> http://hackage.haskell.org/package/stream-fusion-0.1.2.5/docs/Data-Stream.html#t:Stream
14:39:21 <fen> mjrosenb: ^
14:39:33 <fen> wait, whats <%= ?
14:39:40 <fanzy> ski: oh perferct, turns our HPFFP is the haskell book
14:39:45 <ski> fanzy : "Haskell: The Craft of Functional Programming" by Simon Thompson (i learned from this one, and i think it's nice)
14:39:47 <fanzy> ski: buying now then
14:40:21 <ski> fanzy : yes, HPFFP is what's often called "the haskell book" (which is a bit of a vague term, i think, since there's several Haskell books, even several introductory books)
14:40:30 <ski> anyway, here's a few more books :
14:40:35 <ski> @where SOE
14:40:35 <lambdabot> "The Haskell School of Expression: Learning Functional Programming through Multimedia" by Paul Hudak in 2000 at <http://www.cs.yale.edu/homes/hudak/SOE/>,<http://haskell.org/soe/> [broken]
14:40:40 <ski> @where HR
14:40:40 <lambdabot> "The Haskell Road to Logic, Maths and Programming", by Kees Doets,Jan van Eijck, at <http://homepages.cwi.nl/~jve/HR/>
14:41:03 <ski> (i think there may be a book by Richard Bird (?) i'm forgetting about)
14:41:07 <ski> you could also try
14:41:16 <ski> @where wikibooks
14:41:16 <lambdabot> I know nothing about wikibooks.
14:41:20 <ski> @where wikibook
14:41:20 <lambdabot> http://en.wikibooks.org/wiki/Haskell
14:41:31 <ski> @where HTaC
14:41:31 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
14:41:40 <ski> @where WYAH
14:41:40 <lambdabot> "Write You a Haskell" (unfinished) by Stephen Diehl in 2015- at <http://dev.stephendiehl.com/fun/>
14:42:03 <ski> you may also have heard of
14:42:07 <ski> @where LYAH
14:42:07 <lambdabot> http://www.learnyouahaskell.com/
14:42:21 <fen> do any of these have bounded lists!?!?!?!?1?1
14:42:29 <fanzy> ski: oh what do you think of "Write you a haskell" I've seen it but sounds like one of those dummy books
14:42:37 <ski> but we don't tend to recommend that much, nowadays (at least not around here), except maybe as a first brief(?) initial impression
14:43:21 <ski> the criticism of LYAH is that it doesn't go deep enough, and there's no exercises. it has been likened to a four hour long film trailer, iirc
14:43:37 <ski> oh, for exercises, you can also try the course
14:43:41 <ski> @where CIS194
14:43:41 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
14:43:46 <fanzy> I like low level explanations, I like understanding things that's why i like the idea of learning lambda calculus as a primer
14:44:05 <ski> (yes, that year, spring 2013, is what tends to be recommended here)
14:44:28 <fanzy> alright i'll start there then
14:44:29 <ski> where's also
14:44:30 <fanzy> thanks
14:44:31 <ski> @where Data61
14:44:31 <lambdabot> Data61 Functional Programming Course <https://github.com/data61/fp-course>,<https://qfpl.io/links/2017-october-fp-course/> by Tony Morris,Mark Hibberd
14:44:38 <ski> but that's more advanced and fast-paced
14:44:51 <Cale> fanzy: I second the suggestion of Graham Hutton's book -- it's only going to take you so far, but what it covers is a good enough foundation that you should be able to be more self-directed at that point. Also the CIS 194 course by Brent Yorgey is quite good.
14:45:59 <ski> fanzy : hm, i don't think i've looked that much at WYAH yet. it seemed ok, is what little i remember
14:46:45 <fen> https://byorgey.wordpress.com/2010/07/19/typed-type-level-programming-in-haskell-part-iii-i-can-haz-typs-plz/
14:47:04 <ski> fanzy : low level explanations are good, but you also need to be able to detach yourself from them, and consider high level explanations. then, later, ideally you should be able to reason at multiple levels of abstraction, both low and high, at the same time
14:47:26 <fen> still cant figure out if the bounds added to that^ would give runtime type errors or not and if then they should use reflection
14:47:44 <fen> and if append should be a class...
14:48:21 <fanzy> ski: definitely, ultimately I expect to just care about the needs of the project. But when learning, especially something enterily new like a new paradigm, I like to start with the low level
14:48:38 <ski> fanzy : e.g. to understand lambda calculus, it's not enough just to consider how you'd implement it on a machine, say perhaps in terms of memory, instructions. you also need to be able to "reason in lambda calculus itself", rather than always thinking in operational terms, how it could be implemented in more lower level concepts
14:49:53 <fanzy> ski: :) i didn't mean that low level. I meant lambda calculus is what I would like to learn to understand FP better. Lambda calculus is the low level part, as well as category theory
14:50:07 <fen> neither of those things are helpful. haskell is much better
14:50:39 <ski> fanzy : ah, ok then :)
14:50:47 * hackage ivory 0.1.0.9 - Safe embedded C programming.  https://hackage.haskell.org/package/ivory-0.1.0.9 (EricMertens)
14:51:45 <fen> \a -> \ b -> ... === \ a b -> .... lamda calculus complete
14:51:47 * hackage ivory-eval 0.1.0.6 - Simple concrete evaluator for Ivory programs  https://hackage.haskell.org/package/ivory-eval-0.1.0.6 (EricMertens)
14:52:28 <fen> a -> (b -> c) = a -> b -> c /= (a -> b) -> c
14:52:28 <ski> fanzy : btw, you might have heard the slogan "everything is an object" in some OO circles. it's definitely not the case that we'd advocate thinking that "everything is a function" would be a good way to think about programming in FP, even though in "pure lambda calculus", everything actually is a function (and you can encode many other things, like numbers, lists, &c. in terms of such functions)
14:52:47 * hackage ivory-serialize 0.1.0.6 - Serialization library for Ivory.  https://hackage.haskell.org/package/ivory-serialize-0.1.0.6 (EricMertens)
14:53:31 <fanzy> ski: everything is data ?
14:53:50 <fen> [21:23] <Solonarv> you can perfectly well write '(++) :: (m+n <= b) => BoundedList b m a -> BoundedList b n a -> BoundedList b (m+n) a'
14:54:20 <glguy> fanzy: Nope, there are things other than data, too. Haskell isn't an "everything is" kind of language
14:54:22 <fen> so this has <= as a type level function returning a constraint, ie its a class, and so is (+)
14:54:33 <fen> or (+) is a type family...
14:55:32 <fanzy> ski: I never actually went into OO, I got the gist of classical inheritance vs concatenative inheritance vs prototypal inheritance, their implementation and pros and cons, chose concatenative inheritance by a mile when fancying OO but otherwise try to stick to function composition
14:55:39 <ski> fanzy : part of learning Haskell (or even SML, OCaml, Clean, F# .. or some of the statically typed versions of javascript^WECMAscript) (if not learning FP, which also includes dynamically typed languages like Erlang, Scheme (a Lisp dialect / member of the Lisp family)), is learning a (more) powerful static type system (with type *inference* !), which might make you appreciate static typing more than one would in say C or Java
14:55:45 <fen> so then the runtime type error would be a "no instance of ... "
14:56:20 <ski> (and, also, some of the static typing innovations that are being incorporated into languages like Java,C#,&c. are coming from the (static) FP camp)
14:57:26 <fanzy> yes it seems like alot of the new programming concepts nowadays come from FP hence why i want to learn it deeper
14:58:01 <fen> like if you reflected something to a type level bool , constructed a proxy from it and and tried to do ~
14:58:02 <ski> fanzy : well, in Lisps, you sometimes hear "code is data" (typically referring to meta- / staged programming, e.g. via macros, and also `eval'). it's true that functions are first-class values in FP, so in that sense "code is data" (this is not the same sense as in the staged programming case)
14:58:43 <fen> % 1 :: (True ~ False) => Int
14:58:43 <yahb> fen: ; <interactive>:46:1: error:; * Couldn't match type 'True with 'False arising from an expression type signature; * In the expression: 1 :: (True ~ False) => Int; In an equation for `it': it = 1 :: (True ~ False) => Int
14:58:55 <ski> fanzy : hm, i don't recall seeing the term "concatenative inheritance" before ? example of a language/system which uses it ? is it related to mixins ?
14:59:06 <fen> % 1 :: (True ~ True) => Int
14:59:06 <yahb> fen: 1
14:59:33 <fen> huh, well thats not a no instance error, seems to be a special one for ~
14:59:45 <fen> dont know what error <= would give...
14:59:46 * ski supposes fanzy doesn't mean concatenative languages like Forth,Factor,Joy,Postscript (?)
14:59:52 <fen>  '(++) :: (m+n <= b) => BoundedList b m a -> BoundedList b n a -> BoundedList b (m+n) a'
15:00:09 <ski> fen : a type error, presumably
15:00:17 <fen> yeah, but at runtime!?
15:00:21 <ski> no
15:00:34 <fen> why not!?
15:00:42 <fen> im unfolding lists
15:01:04 <fen> to some length calculated at runtime
15:01:11 <fen> its a runtime type error...
15:02:18 <fanzy> ski: concatenative inheritance is more a pattern than anything. It's by some (e.g. Douglas Crockford) concidered to be the correct way to do OOP.
15:02:27 <ski> fen : well, with that `(++)', iiuc Solonarv's intention properly, you'd get a type error (an instance resolution error, specifically), if the solver / you couldn't prove `m+n <= b' at compile-time
15:02:47 <fen> or at runtime...
15:03:06 <ski> fanzy : so you're pasting records together ? with left-most (right-most ?) override, in case of clashing fields/methods ?
15:03:31 <fen> a runtime "instance resolution error"
15:03:49 <fen> but there are a whole class of these things
15:03:54 <fen> things that can be bounded
15:03:55 * ski thought ECMAscript would typically be considered to encourage prototype-based OO
15:04:33 <fanzy> ski: (in JS vocab) it's basically just creating a function that returns an object and that object can be used as that parent as the base for a child object. But you only pick and choose which prop you inherit from the parent
15:04:46 <ski> fen : well, there'd be no "prove at run-time", though there might be some kind of corresponding "check at run-time"
15:05:01 <fanzy> ski: it's called concatenative because you don't actually inherit but rather copy the properties from the parent to the child
15:05:03 <ski> (prove is something that is typically not automatable)
15:05:03 <fen> hrmpf, just lists to start with then. so annoying the Set class cant be updated this way to have extra type checking capabilities
15:05:27 <fanzy> ski: it make for better composition without the classical inheritance problem of the gorilla banana 
15:05:34 <fen> what does ghc not just get called during the code running?
15:05:54 <fen> it has to be singletoned down from type level and checked with value level functions?
15:05:54 <Solonarv> indeed it does not
15:06:02 <fanzy> ski: yes overrice if clashing
15:06:06 <Solonarv> ghc may not even exist on the machine the code is running on!
15:06:18 <fen> lame
15:06:19 <ski> fanzy : hmm .. ok. that sounds a bit similar to some approaches to simulate (some aspects of) OO in e.g. Haskell (or perhaps OCaml. the "O" stands for "Objective")
15:06:33 <fen> staticly link it as a runtime function!
15:06:43 <c_wraith> the problem is libraries
15:06:47 <Solonarv> ghc is pretty damn big, let's not
15:06:47 <fen> and run linux on it
15:06:57 <c_wraith> you can certainly use ghc in your program
15:07:15 <fen> % :t runProcess
15:07:15 <yahb> fen: ; <interactive>:1:1: error: Variable not in scope: runProcess
15:07:19 <fen> like that?
15:07:25 <fanzy> ski: ECMAScript does have prototype based OO but it's cluncky and has the same issue as classical inheritance. 
15:07:30 <fen> System.Process....
15:07:38 <c_wraith> but if the computer doesn't have the same version of ghc installed somewhere, good luck compiling/interpreting anything. 
15:07:43 * ski idly recalls someone running GHC run-time on the bare metal, with no host OS
15:07:44 <Solonarv> you can also use the GHC API as a plain old Haskell library
15:07:51 <Solonarv> (this is how lambdabot works)
15:08:05 <fen> ah yeah thats a better idea
15:08:17 <ski> fanzy : ok. and what would you say those issues are, in this context ?
15:08:22 <fen> then you would load the linux version with :m ?
15:08:24 <c_wraith> it's really only suitable for developer use.
15:08:57 * ski ponders the term "classical inheritance"
15:09:22 <fen> or do we have something like apt-get that runs strait in ghci?
15:09:41 <fanzy> ski: at scale things become really hard to amend without breaking the hierachy you so carefully set up. You end up duplicating code more often than not for minor differences. I see that at work all the time it sort of drives me mad
15:10:17 * ski has heard OO people recommend to not have deep hierarchies
15:10:49 <fen> no recursive undecidable instances then?
15:11:32 <fen> thats how you would do (++) using Set right?
15:11:33 <fanzy> ski: well perfect then :) functions are one level deep objects (in JS)
15:11:52 <fen> basically like http://hackage.haskell.org/package/fixed-list-0.1.6/docs/Data-FixedList.html#t:Append
15:14:08 <ski> (i also recall hearing someone (on an OO newsgroup, i think) suggest that one should try to use asynchronous methods in a design, in the sense that one should send messages, but not expect a particular result to be sent back (i suppose that would mean that most methods would have no return value))
15:14:41 <fen> what a ridiculous paradigm
15:15:25 <Welkin> that's called the actor model
15:15:28 <fen> the advantages are probably not worth the overhead
15:15:37 <Welkin> it's the only way to do large scale conccurency
15:15:37 <fen> Welkin: thats slow right?
15:15:39 <Welkin> no
15:15:45 <Welkin> it's what erlang does
15:15:52 <Welkin> it's how the entire internet works
15:16:17 <fen> that does not mean it isnt slow
15:16:34 <Welkin> slow compared to what?
15:16:38 <fen> its one of the slowest forms of concurrency, but cant find the reference!!
15:16:50 <Welkin> it's the only concurrency that it correct
15:16:57 <Welkin> all others are flawed
15:16:58 <ski> fanzy : well, it's sometimes said that "functions are a poor man's objects". otoh "objects are a poor man's record-of-functions"
15:17:02 <fen> damn all these misilanious informations in my head
15:17:52 <ski> Welkin : i didn't quite understand what it had to do with OO ..
15:18:03 <ziman> how do you define "slow"?
15:18:09 <fen> Welkin, atm your unreferenced statement is less convincing to me than mine is, as i definatly remember there being a refference
15:18:10 <Welkin> well Alan Kay's formulation of OO is the actor model
15:18:21 <ski> yes. perhaps that's it
15:18:22 <Welkin> not java OO, which has nothing to do with the actor model
15:20:47 <ski> (at the time, i was attempting to fit those statements together with the idea of inheritance (either of interface, or of implementation). and how one would do algorithms if one's not allowed to return values back. or, how one would initially set up a network of objects that only asynchonously forward information to other objects, never waiting for a direct reply before continuing)
15:23:33 <fen> http://www.diva-portal.org/smash/get/diva2:1268459/FULLTEXT01.pdf
15:24:14 <ski> @tell fanzy (re "* ski has heard OO people recommend to not have deep hierarchies","<fanzy> ski: well perfect then :) functions are one level deep objects (in JS)") well, it's sometimes said that "functions are a poor man's objects". otoh "objects are a poor man's record-of-functions". (sorry, was looking for a reference, didn't find one)
15:24:14 <lambdabot> Consider it noted.
15:24:48 <fen> thats not the performance comparison Welkin
15:24:52 <fen> nvm
15:25:17 <fen> im never going to make these bounded lists work
15:25:22 <fen> this sucks
15:26:39 <ski> oh, that paper is related to lkuper's LVish work (`LVar's (Lattice Variables), &c.)
15:26:47 * ski likes the swedish title of it
15:27:27 <fen> how can we have years of work on type lengthed lists and no mention of bounded lists
15:27:46 <ski> @hackage lvish
15:27:46 <lambdabot> http://hackage.haskell.org/package/lvish
15:27:47 <fen> what a rediculous situation for a language to be in
15:28:45 <ski> what do you want to use these bounded lists for ?
15:28:55 <fen> "oh deterministic typing is new and everyone just uses python, you haskellers are too worked up about types"
15:29:00 <fen> ill show you worked up!"
15:29:01 <yushyin> ski: I thought it was 'Closures are a poor man's object' not functions
15:29:09 <Welkin> how can you misspeall "ridiculous"?
15:29:17 <fen> rarg!!!
15:29:29 <Welkin> I cannot believe how many times I have seen "ridiculous" spelled "rediculous" online
15:29:34 <Welkin> is this idiocracy?
15:29:47 <Welkin> misspell*
15:29:54 <fen> its the same one that didnt give us type level bounded lists!
15:30:14 <yushyin> ski: http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03277.html
15:30:23 <fen> ski: for type level bounded Nats!!
15:32:56 <fen> type family (x :: BoudedNat Nat) + (y :: BoudedNat Nat) :: BoudedNat Nat where
15:33:40 <ski> what's "deterministic typing" ?
15:33:43 <nisstyre> Welkin: I'm pretty sure it's intentional
15:33:48 <nisstyre> or maybe not idk
15:34:47 <ski> Welkin : i suppose it may be similar to misspelling "your" as "you're" (or vice versa). presumably there's some misfiring going on in the brain, having to do with them being pronounced similarly ?
15:34:54 <fen> ski: as opposed to what? probabilistic typing
15:35:14 <ski> fen : i don't know, you mentioned the term
15:35:35 <fen> just meaning runtime class implementation 
15:35:56 <fen> there was some suff about runtime get and set instances a while back
15:36:11 <fen> or a runtime traversal implementation or something
15:36:44 <fen> cant remember, probably a silly idea 
15:37:13 <zachk> by bounded do you mean min and max on a number?
15:37:18 <fen> yes!
15:37:54 <zachk> there is a fin for naturals in depedently typed languages, from 0 to a number or one less than a number
15:38:20 <fen> how do you do those in haskell?
15:38:44 <zachk> I wouldn't "bound" the list, I would put boundaries on the underlying number type if I needed to/could
15:39:05 <fen> yeah fair they are equivalant
15:39:07 <zachk> not sure how to do dependent type stuff in haskell, never used fin much in dependently type languages as well :-/ 
15:39:25 <fen> and if you dont like the argument about using (++) to implement (+) then i guess thats fine
15:39:35 <zachk> the fin in dt languages is usually used for indexes to vectors 
15:40:02 <ski> yushyin : i thought there was perhaps a page on <c2.com> or <community.schemewiki.org> on it, but i didn't find it. ty for that reference though (the koan was a plus :)
15:40:04 <fen> but you would end up with many things that can be plussed together, like whatever is isomorhpic to [Bool] for example
15:40:45 <fen> idk maybe another example could be the modulo set Zn
15:40:47 * hackage rtcm 0.2.39 - Haskell bindings for RTCM.  https://hackage.haskell.org/package/rtcm-0.2.39 (markfine)
15:41:07 <fen> so you have a number and if it is added to beyond the bound then it starts again from 0
15:41:24 <fen> its just like a type level Nat phantom type thinh
15:42:18 <fen> guess with Nat = [()] this would just keep consing on (:), and then starting over again when the bound was reached... maybe thats slow
15:42:52 <fen> type TypedList (n :: BoundedNat Nat) a = [a]
15:42:54 <fen> ?
15:42:56 <zachk> fen: here is the fin help section from idris https://www.idris-lang.org/docs/current/contrib_doc/docs/Data.Fin.html , dont know if you can do them in haskell 
15:44:26 <fen> data Fin : (n : Nat) -> Type FZ : Fin (S k) FS : Fin k -> Fin (S k)
15:46:07 <fen> data Fin (n :: Nat) where FZ :: Fin (S k); FS :: Fin k -> Fin (S k)
15:47:02 <fen> data Nat : Type  Z : Nat Zero S : Nat -> Nat
15:47:41 <fen> data Nat where Z :: Nat; S :: Nat -> Nat
15:47:56 <zachk> fen, have you worked with nat's before?
15:48:43 <fen> here was my first attempt; https://pastebin.com/raw/UB37TQer
15:48:57 <fen> but now want to use type Nat = [()]
15:50:43 <ski> yushyin : this reminds me of Doug Bagley's "Functional Programming Koans, in OCaml" in 2002 - 2003-02-03 at <http://web.archive.org/web/20041012103936/http://www.bagley.org/~doug/ocaml/Notes/okoans.shtml>
15:51:08 <fen> not used to Idris, is that Type the type of k?
15:51:23 <fen> data Fin (n :: Nat) (k::*) where FZ :: Fin (S k); FS :: Fin k -> Fin (S k)
15:51:27 <zachk> i think type is like * 
15:52:33 * ski . o O ( "Functional Koans: a dynamic programmer responds" by pozorvlak in 2006-05-15 at <https://pozorvlak.livejournal.com/15822.html> )
15:52:37 <fen> hmm, no because then S is taking it as an argument
15:52:56 <fen> so it must be Fin n :: *
15:53:08 <fen> (Fin n) :: *
15:53:33 <fen> sorry.... deriving idris syntax by process of elimination! 
15:53:48 <fen> whats that written in haskell?
15:54:19 <zachk> not sure, I only ever touched depdendent types in idris 
15:54:54 <fen> data Fin (n :: Nat) = FZ (Fin (S k)) | FS (Fin k -> Fin (S k)) ?
15:54:59 <Solonarv> * is slowly being phased out, we call that thing Type now (in GHC Haskell)
15:55:16 <Cale> fen: That was Haskell syntax too?
15:55:18 <Welkin> get your gub'ment hands off my *!
15:55:31 <Cale> Though I think you meant to write n where you wrote k a couple places
15:55:36 <fen> Cale: trying to converge on a valid haskell expression!
15:55:51 <fen> oh yeah...
15:56:05 <fen> the idris version is here; https://www.idris-lang.org/docs/current/contrib_doc/docs/Data.Fin.html#Data.Fin.Fin
15:56:18 <fen> cant figure out what they are doing wrt k/n
15:56:30 <Cale> oh, I see
15:56:34 <Solonarv> yeah you can pretty much copy/paste that to Haskell
15:56:41 <Cale> It's not parametrised by k, k is an index
15:57:00 <fen> Solonarv: apparently not!
15:57:01 <Solonarv> just change out : fr :: and change the head to 'data Fin :: Nat -> Type'
15:57:16 <Cale> :k Nat
15:57:18 <lambdabot> error:
15:57:18 <lambdabot>     Not in scope: type constructor or class ‘Nat’
15:57:18 <fen> you could write it out as an example!
15:57:25 <Cale> hmm, no Nat, let's add one
15:57:30 <fen> @let type Nat = [()]
15:57:31 <lambdabot>  Defined.
15:57:35 <Cale> @let data Nat = Z | S Nat
15:57:36 <lambdabot>  .L.hs:177:1: error:
15:57:36 <lambdabot>      Multiple declarations of ‘Nat’
15:57:36 <lambdabot>      Declared at: .L.hs:175:1
15:57:37 <Cale> oh
15:57:43 <Cale> that's not going to be as useful
15:57:46 <Cale> @undefine
15:57:46 <lambdabot> Undefined.
15:57:46 <fen> :k Nat
15:57:47 <lambdabot> error:
15:57:48 <lambdabot>     Not in scope: type constructor or class ‘Nat’
15:57:49 <Cale> @let data Nat = Z | S Nat
15:57:49 <fen> @let type Nat = [()]
15:57:50 <Solonarv> % data N = Z | S N
15:57:50 <yahb> Solonarv: 
15:57:50 <lambdabot>  Defined.
15:57:51 <lambdabot>  .L.hs:161:1: error:
15:57:51 <lambdabot>      Multiple declarations of ‘Nat’
15:57:51 <lambdabot>      Declared at: .L.hs:158:1
15:57:57 <fen> RRG
15:57:58 <Cale> pls
15:58:20 <fen> your version is ineffecient and slow and a bad implementation
15:58:21 <Cale> @undefine
15:58:21 <lambdabot> Undefined.
15:58:22 <Solonarv> % data Fin :: N -> Type where FZ :: Fin (S k); FS :: Fin k -> Fin (S k)
15:58:23 <yahb> Solonarv: 
15:58:35 <Cale> The list thing isn't any better, it's just syntactically awkward
15:58:43 <fen> its way better!
15:58:48 <Cale> n... no?
15:58:53 <Cale> Not in Haskell, anyway
15:59:08 <fen> yes! why redefine (+) for every value a of [a]
15:59:15 <dmwit> What do you think makes it better?
15:59:15 <fen> when you can ust use (++)
15:59:29 <fen> because I have get and set
15:59:34 <Cale> You can't use (++) at the type level anyway
15:59:42 <Cale> @let data Nat = Z | S Nat
15:59:43 <lambdabot>  Defined.
15:59:46 <fen> im not doing recursion schemes with the instance defined over 'f a'
16:00:19 <Cale> @let data Fin (n :: Nat) where FZ :: forall k. Fin (S k); FS :: forall k. Fin k -> Fin (S k)
16:00:20 <lambdabot>  Defined.
16:00:47 <Cale> FS (FS (FS FZ)) :: Fin (S (S (S (S Z))))
16:00:52 <Cale> :t FS (FS (FS FZ)) :: Fin (S (S (S (S Z))))
16:00:53 <lambdabot> Fin ('S ('S ('S ('S 'Z))))
16:01:37 <fen> that does not look like a list
16:01:37 <Cale> I wanted the data declaration to make sure that data kinds worked out okay. Perhaps the list would work as well, but it's not as easy to read, and not as good a match with idris' definition.
16:01:53 <fen> ahh
16:02:01 <Solonarv> lists would work as well but be more annoying syntactically
16:02:06 <fen> ok, so how do we get the bounded list version from this?
16:02:20 <dmwit> It looks very much like a list if you are wearing the right glasses.
16:02:46 <fen> Solonarv: your just used to working with f a ~ t of recursion schemes. while the libraries I have are defined over the container
16:03:06 <fen> not a list of anything
16:03:15 <fen> its [()]
16:03:24 <fen> so now we can recover the Bounded liste implementation
16:03:28 <Cale> @let data BoundedList a (n :: Nat) where LZ :: forall k. BoundedList a (S k); LS :: forall k. a -> BoundedList a k -> BoundedList a (S k)
16:03:29 <lambdabot>  .L.hs:166:38: error: Not in scope: type variable ‘a’
16:03:29 <lambdabot>      |
16:03:29 <lambdabot>  166 |         LZ :: forall k . BoundedList a (S k)
16:03:35 <Solonarv> @let type family (<=?) m n where (S m) <=? (S n) = m<=?n; Z<=?_ = True; _<=?_=False
16:03:36 <lambdabot>  Defined.
16:03:37 <Cale> oops
16:03:41 <jle`> fen: if you're using [()] then replace S with `():` and Z with []
16:03:44 <Cale> @let data BoundedList a (n :: Nat) where LZ :: forall a k. BoundedList a (S k); LS :: forall a k. a -> BoundedList a k -> BoundedList a (S k)
16:03:45 <lambdabot>  Defined.
16:04:26 <Cale> There you go
16:04:32 <fen> but it should have a set instance
16:04:42 <fen> and that set should throw an error if it exceeds the bounds
16:04:55 <Cale> uhhh... not sure what you mean
16:05:16 <Cale> You can choose a type like BoundedList Integer (S (S (S Z)))
16:05:20 <fen> well, the only things that would throw an error are returned from things defined in terms of cons
16:05:25 <Cale> and if you do, then you can only make lists of length at most 3
16:05:25 <fen> (cons sorry not set)
16:05:32 <Cale> LS is cons
16:05:50 <fen> where is the error/
16:05:51 <fen> ?
16:05:56 <Cale> > LS 1 (LS 2 (LS 3 (LS 4 LZ))) :: BoundedList Integer (S (S (S Z)))
16:05:58 <lambdabot>  error:
16:05:58 <lambdabot>      • Couldn't match type ‘'S ('S k0)’ with ‘'Z’
16:05:58 <lambdabot>        Expected type: BoundedList Integer ('S ('S ('S 'Z)))
16:06:06 <Cale> > LS 1 (LS 2 (LS 3 (LS 4 LZ))) :: BoundedList Integer (S (S (S (S Z))))
16:06:06 <fen> hmmm
16:06:08 <lambdabot>  error:
16:06:08 <lambdabot>      • Couldn't match type ‘'S k0’ with ‘'Z’
16:06:08 <lambdabot>        Expected type: BoundedList Integer ('S ('S ('S ('S 'Z))))
16:06:13 <Cale> ah, right
16:06:21 <Cale> > LS 1 (LS 2 (LS 3 (LS 4 LZ))) :: BoundedList Integer (S (S (S (S (S Z)))))
16:06:23 <lambdabot>  error:
16:06:23 <lambdabot>      • No instance for (Show
16:06:23 <lambdabot>                           (BoundedList Integer ('S ('S ('S ('S ('S 'Z)))))))
16:06:27 <Cale> okay, good :D
16:06:31 <fen> thats a better error!
16:06:34 <Cale> Apparently I'm off by one
16:06:45 <Cale> yeah
16:07:06 <Cale> The number provided is a strict upper bound for the number of elements
16:07:15 <Cale> Because I was copying Fin's convention
16:07:49 <Solonarv> you might be better served by this:
16:07:49 <Solonarv> @let data LList l a where LLZ :: LList Z a; LLS :: a -> LList k a -> LList (S k) a
16:07:50 <lambdabot>  Defined.
16:08:06 <Cale> Yeah, that's a list of specified length
16:08:12 <Cale> rather than a list of bounded length
16:08:29 <fen> nooo
16:08:30 <fen> bounded
16:08:37 <fen> wait...
16:08:39 <fen> both?
16:08:40 <Solonarv> @let data BLList b a where BLList :: (l <=? b) => LList l a -> BLList b a
16:08:41 <lambdabot>  .L.hs:179:20: error:
16:08:41 <lambdabot>      • Expected a constraint, but ‘l <=? b1’ has kind ‘Bool’
16:08:41 <lambdabot>      • In the definition of data constructor ‘BLList’
16:08:47 <Cale> I can fix the other one by fixing the type of LZ
16:08:55 <Solonarv> @let data BLList b a where BLList :: ((l <=? b) ~ True) => LList l a -> BLList b a
16:08:56 <lambdabot>  Defined.
16:09:09 <Cale> haha
16:09:13 <fen> yay!
16:09:14 <Cale> that's another way to do it
16:09:30 <Solonarv> might want to also toss a 'KnownN l' in that constrant
16:09:44 <fen> wait, is one of these slower?
16:10:09 <Cale> I wouldn't worry about the performance of any of these because they're all hilariously impractical to use
16:10:22 <Cale> and if you put them in production code, I'll fire you
16:10:24 <Cale> lol
16:10:25 <fen> or just restrict the kinds of m and n in the type family
16:10:26 <Solonarv> should be about the same anyway
16:10:41 <Solonarv> oh the type family is already kind-restricted (or should be anyway)
16:10:43 <fen> Cale: they are faster than Ints
16:10:51 <Cale> In what sense?
16:11:08 <Solonarv> I just didn't feel like writing out the kind signatures for t since I'm just typing code into IRC
16:11:11 <fen> replicate (3*3) ()
16:11:15 <fen> > replicate (3*3) ()
16:11:17 <lambdabot>  [(),(),(),(),(),(),(),(),()]
16:11:38 <fen> now, that uses Int, and is slow, it calculates n*m and then does (-1) over and over
16:11:42 <Solonarv> this is in no way "faster than Ints"
16:11:47 <fen> yes it is
16:11:51 <fen> let me finish
16:11:59 <Solonarv> I'm highly skeptical, show me benchmarks
16:12:01 <Welkin> you ain't kanye
16:12:12 <hpc> you know how slow that integer arithmetic is :P
16:12:12 <Cale> Okay, if you can take advantage of laziness somehow, then lazy Nat might sometimes finish in a case when an Integer program wouldn't.
16:12:26 <Cale> But holy shit the overhead of building lists
16:12:42 <fen> whereas if replicate was defined using Nat then it would be "unfolding" an n length [()] and an m length [()]
16:12:57 <Cale> Each list cell is three machine words, so like 24 bytes on a typical 64 bit machine.
16:13:06 <fen> and doing replicate (n :: [()]) (m :: [()])
16:13:23 <Cale> you have no expectation of cache locality also
16:13:32 <Cale> and you're following *code pointers*
16:13:40 <fen> so it reuses the first time it produces m :: [()] n times
16:13:50 <fen> like it has [()] ++ [()] ...
16:14:11 <fen> and it fuses down to the state that unfolds this concatinated [[()]]
16:14:37 <Cale> Yeah, I suggest that you try some actual benchmarking with criterion...
16:14:37 <fen> so instead of calculating a large number, we could use its product of primes representation 
16:14:48 <fen> Cale: you get the explanation though?
16:15:17 <Cale> It is in no way correct that this is going to be faster than Int arithmetic
16:15:22 <hpc> none of that comes within miles of being as fast as just subtracting from an integer
16:15:34 <hpc> you're competing with one clock cycle
16:16:11 <Cale> Note that we're talking about representing numbers in unary, so if you have the number n, it takes O(n) space
16:16:22 <fen> if the Int is large enough, like 10^6 * 10^6, then isnt it fastest to cach the 10^6 length list and fold over it 10^6 times, instead of actually producing this as an Int and unfolding one 10^12 length list and folding over it
16:16:36 <fen> no it fuses!
16:16:47 <fen> we just reuse the state many times
16:16:56 <fen> and that states use is cached
16:17:06 <fen> it does the same thing over and over
16:17:21 <hpc> > 10^6 * 10^6 :: Int
16:17:23 <lambdabot>  1000000000000
16:17:24 <Cale> I think you're way overestimating what the compiler is going to do with it.
16:17:39 <fen> no i have a zip fusion rule for state hylos
16:17:41 <Welkin> slow down there cowboy
16:19:04 <fen> https://pastebin.com/6qfN12Hi
16:19:56 <fen> thats why i want it over lists for the unfold fusion
16:20:09 <fen> but it probably would work anyway with the recursion schemes encoding of it
16:21:16 <Cale> Just... try it
16:21:23 <Cale> Do the calculation that hpc just tried
16:21:29 <Cale> and produce the string output
16:21:33 <fen> no thats not the idea!
16:21:44 <fen> its to use it as an argument to replicate
16:21:51 <fen> or take
16:22:31 <hpc> do that calculation then
16:22:37 <zachk> you have a fusion rule on lists and you want to use lists instead of numbers as arguments to replicate and the such? 
16:22:55 <fen> otherwise it wouldnt fuse
16:23:17 <Solonarv> if you want to "cache" 10^12 represented in unary it will take ~24 TB
16:23:22 <Cale> Note that you have ($>) as your analogue of "replicate"
16:23:43 <Cale> and zip as take
16:23:44 <Solonarv> (on a 64-bit machine)
16:23:54 <Cale> Or zipWith (flip const), I suppose
16:24:04 <zachk> just do it on 32 bit and it will only take ~12 TB ! 
16:24:09 <Cale> But yeah, caching any of the sublists is going to be a total disaster
16:24:17 <Cale> You have to explicitly avoid doing that
16:24:20 <hpc> Solonarv: somehow in this situation, pointer chasing is able to bypass basic information theory :P
16:24:59 <Cale> It's rather like this
16:25:10 <Cale> Which implementation of sublists is better:
16:25:15 <Cale> sublists [] = [[]]
16:25:33 <Cale> sublists (x:xs) = sublists xs ++ map (x:) (sublists xs)
16:25:34 <Cale> or
16:25:51 <Cale> sublists (x:xs) = let ys = sublists xs in ys ++ map (x:) ys
16:26:02 <Cale> ?
16:27:06 <Solonarv> Unrelatedly: has anyone seen the ApplyingVia proposal? I'm trying to see if I can implement it as a GHC plugin but having trouble with what the desugaring should be
16:28:02 <Solonarv> I don't think it can be fully implemented as a source plugin, I'd have to somehow package stuff up into a call to a dummy function and eliminate that with a plugin in a later stage
16:29:38 <fen> its not a long list of small primes
16:29:46 <fen> you would be unlucky to get a large prime!
16:30:15 <fen> but even if it was just like one cached list of like lenght 100 and it was folded over 10^6 times
16:30:29 <dmwit> The product-of-primes structure is completely lost when using [()].
16:30:36 <dmwit> If you want it, you'll need Tree () or similar.
16:30:45 <fen> your saying its slow, im saying there might exista a case where its faster
16:31:01 <dmwit> And *even after doing that*, Integer is going to be miles faster, and Int faster still if it gives the correct answer at all.
16:31:09 <fen> no its replicate! there are 2 numbers, and we can repeat that
16:31:20 <dmwit> I'm saying there does not exist a case where it's faster.
16:31:35 <fen> its easier to just consider folding one replicate of a shortish list a large number of times
16:31:41 <dmwit> No, it isn't.
16:32:29 <fen> it does not produce terrabytes of cached unitary representation, it simply avoids doing 100 (-1) , 99 (-1) etc millions of times
16:32:52 <hpc> it's gotta do /something/ millions of times
16:33:12 * dmwit . o O ( If unary-encoded numbers actually *were* faster, hardware designers would just use them instead. )
16:33:12 <fen> say its folding over this with const const
16:33:21 <fen> so its just doing const that many times
16:33:52 <fen> consting away the () it folds over with the first const, and then joining together the long list of consts
16:34:14 <zachk> over a whole list is always going to be O(n) 
16:34:22 <fen> hpc, right but it does not need to actually do millions of integer calculations
16:34:29 <hpc> this reminds me of a joke i saw here years ago, about haskell being the fastest language because graph reduction is a pure operation and therefore free to compute
16:34:43 <fen> there is no need to decriment one over that many ints!
16:34:50 <hpc> instead it chases pointers millions of times? much better
16:35:08 <fen> depends how big the ints are no?
16:35:08 <zachk> does ghc use graph reducation? 
16:35:11 <hpc> or calls const millions of times?
16:35:21 <fen> well it was always going to do that
16:35:34 <fen> the question is how it produces that representation
16:35:44 <zachk> you can count to 1 billion in integers 1 by 1 in asm on  32 bit linux vm on my laptop in 1.3seconds 
16:36:31 <fen> either you have like x n = case n of 0 -> const; (n'+1) -> const (x n')
16:36:33 <geekosaur> zachk, that's what STG is for, it's a graph reduction engine
16:37:14 <zachk> geekosaur, ahhhh
16:37:37 <fen> or you have repeatedly n (foldr1 (const ( . const) (replicate m ())))
16:37:46 <fen> where here repeatedly and replicate take Nats
16:38:23 <hpc> yeah, (foldr1 (const ( . const) (replicate m ()))) is so much faster than (-1)
16:38:32 <hpc> and you're still doing it n times
16:39:25 <fen> repeatedly also is implemented by folding (well zipping, as it fuses down to the state) 
16:39:54 <fen> but that one does not have any difference, it has nothing to chache, only being done once
16:40:06 <fen> it simply uses the Int decrement directly
16:40:22 <fen> (thats the Int that was originally used to unfold the Nat = [()])
16:41:29 <fen> but for the inner unfold, this Int decrimenting unfold is only performed once, and cached, and then folded (and chached again) 
16:41:35 <fen> wait, its easier to see as;
16:42:09 <fen> repeatedly n (repeatedly m const)
16:42:24 <fen> with repeatedly defined in the version above by comaprison
16:43:06 <fen> so we reuse the intermidiate representation instead of reproducing it and redoing an Int decrement calculation needlessly
16:43:20 <fen> come on, thats it conving right>?
16:43:25 <fen> convince!
16:43:53 <Cale> fen: I think what you're missing here is that even with a lazy list, cons cells require allocation in the heap
16:44:02 <hpc> write a benchmark that proves it
16:44:16 <fen> unitary fusion factorisation ftw!!!
16:44:19 <Cale> It's not going to "fuse away completely"
16:44:19 <hpc> haskell has no cost model, so the only way to measure performance is by running code
16:44:34 <Cale> That doesn't even make sense -- what is your input?
16:44:42 <fen> yeah well it turns out i lost my implementation of takeN
16:44:45 <Cale> Is it a number in Int representation?
16:44:47 <fen> *sigh*
16:44:53 <fen> so not for a while yet
16:45:08 <Cale> and we're going to produce a list of type [()] and then consume that with replicate or takeN or something?
16:45:14 <fen> yeah, you give it 2 Ints to unfold the 2 nats
16:45:20 <Cale> You need a producer to fuse with your consumer
16:45:27 <fen> so its like using 2 Ints to produce ()
16:45:34 <hpc> or just think about what it compiles down to
16:45:40 <fen> they are fusioned away, but one of them can be cached
16:45:45 <hpc> don't describe what it does in haskell terms, describe it in assembly terms
16:45:49 <fen> by referring to the unfolded Nat
16:45:56 <Cale> and then even if you are lucky and the whole thing fuses away... it's fusing away into Int operations.
16:46:14 <fen> no one is cached as an unfolded and refolded section!
16:46:21 <fen> part of it is reused
16:46:36 <Cale> I dunno, I think one of us is missing something, but I'll be happy to inspect some running benchmarks :)
16:46:57 <fen> the fusion rules need to be done properly first
16:46:58 <hpc> fen: describe the assembly that this produces
16:47:01 <hpc> since that's what gets executed
16:47:15 <fen> and the hierarchical unfolding of nested containers using higher order states before that
16:47:23 <fen> but the argument can be given 
16:47:32 <fen> and it sounds pretty reasonable
16:47:47 <fen> what if it was id instenad of const
16:47:48 <Cale> It doesn't make any sense to me how nominally producing millions of cons cells which would ordinarily be allocated on the heap in a very expensive fashion (even if garbage collected soon thereafter) and then rescuing oneself with fusion is going to turn out any better than just doing what you wanted with Int directly.
16:48:00 <fen> and it actually fusioned down the length n replicate id
16:48:05 <fen> repeatedly id
16:48:16 <fen> all the way down to just one id, which is very small
16:48:31 <fen> so none of your memory considerations 
16:49:00 <hpc> i think this is a misunderstanding on how fusion works?
16:49:25 <fen> either you repeatedly do id, which requires decrimenting a large number, or you split this up, find that the factored section fuses down to id, and repeatedly do this far fewer times
16:49:33 <fen> no benchmarks nesacarry, thats gona be faster
16:49:48 <Cale> Even if you get the fusion down to the point that you didn't allocate any lists (which is questionable if you're doing stuff like multiplication, but fine), you're still fusing it all away into Int operations
16:49:55 <dmwit> Did you know that in `x ++ x ++ x ++ x`, there are no shared links in the produced linked-list? All of `x`'s links must be duplicated three times for the first three `x`s.
16:49:58 <Cale> Or whatever your producer was using as input to make the list
16:50:05 <dmwit> I think this is the point you are missing.
16:50:12 <fen> but my implementation of multiplication over Nat was replicate!!!!!!!!!!!!!!!!1
16:50:25 <Cale> uhhh
16:50:26 <dmwit> Decrementing an Int by one is cheap compared to dereferencing one of `x`'s links.
16:50:31 <Cale> do you mean concat and replicate?
16:50:32 <fen> so there you go, it retains the originally combined nats and recover them for the fusion
16:51:09 <fen> you do not fuse all the way down to int opperations, you cach the resused part
16:51:14 <fen> cache*
16:51:18 <Cale> You cache the list?
16:51:29 <fen> no the folded version
16:51:38 <dmwit> fen: But the caching doesn't actually help. See my previous three comments.
16:51:41 <Cale> Uh, I don't know what you mean
16:51:45 <fen> your folding over one big list, thats repeatedly taking a Nat 
16:51:53 <Cale> But yeah, also, xs ++ ys has no cons cells in common with xs
16:51:58 <fen> but this Nat is a product, so is replicate n m
16:52:23 <Cale> and concat (replicate n m) will have at most a single copy of m in it.
16:52:39 <fen> so if your doing repeatedly 10^12 id
16:52:45 <slack1256> I got two `bracket`s acquiring a file handle and a socket. Either the socket or the file is failing throwing a IOException, but I don't know which one was it, so I don't know how to handle correctly.
16:52:45 <fen> which really should just be id anyway
16:53:01 <slack1256> is that problem common? How is usually solved?
16:53:04 <fen> being able to fuse down to the list factors...
16:53:08 <fen> you know what
16:53:17 <fen> its been explained sufficently
16:53:40 <fen> i dont know why your arguing against it still as it is basically satisfied
16:53:49 <Cale> slack1256: Well, bracket will end up finalising both if you don't catch the error
16:53:51 <Solonarv> slack1256: toss a `catch` (\e -> print (e :: IOExceptin) >> throwIO e) at the end
16:54:05 <Solonarv> at least for debuggih
16:54:07 <Cale> slack1256: Are you hoping to avoid finalising the outer one?
16:54:36 <hpc> slack1256: so to change notation a bit, you're basically writing try {handle; try {socket} catch {...}} catch {...}
16:54:41 <hpc> ?
16:54:52 <fen> you get repeatedly (n/m) id
16:54:59 <slack1256> Well on *this* case it fine finalise both of them, I just want to report correctly that it was the socket and not the file writing that failed 
16:55:00 <fen> you get repeatedly (n*m/m) id
16:55:10 <slack1256> *it is fine
16:55:14 <Cale> fen: I don't know how I can explain any better either. Just write a program and prove it :D
16:55:46 <fen> ok!
16:56:01 <fen> thanks for the help with the bounded list, thought that would end me
16:56:12 <Cale> Yeah, no problem
16:58:54 <slack1256> hpc: yeah, basically that `bracket (acquireSocket) (\socket -> bracket acquireFile (\file ->  maybeFileDownload) fileclose) socketclose
17:00:14 <slack1256> bracket rethrows exceptions, but both the socket and the file-handle can throw `IOException`-s. When I notice and exception has been thrown on that thread, I can't know if it was the socket or the file-handle
17:00:31 <slack1256> (later I notices my disk was full, so it was the file-handle :-) )
17:00:36 <hpc> use return values instead of exceptions, i think
17:01:06 <hpc> unless you have more exceptions that you are handling in some non-local piece of code
17:01:06 <slack1256> maybe some `map` for exceptions
17:01:17 <slack1256> on this case I don't
17:01:40 <ski> @where fp-koans
17:01:40 <lambdabot> "Functional Programming Koans, in OCaml" by Doug Bagley in 2002 - 2003-02-03 at <http://web.archive.org/web/20041012103936/http://www.bagley.org/~doug/ocaml/Notes/okoans.shtml>. Cf. "Functional
17:01:40 <lambdabot> Koans: a dynamic programmer responds" by pozorvlak in 2006-05-15 at <https://pozorvlak.livejournal.com/15822.html>
17:01:51 <fen> and yeah, it doen not just work for id
17:01:55 <ski> @where object-closure-koan
17:01:55 <lambdabot> "RE: What's so cool about Scheme?" (Teachings of venerable master Qc Na) by Anton van Straaten in 2003-06-04 at <http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03277.html> (cf. "RE:
17:01:55 <lambdabot> accumulator generator (Java)" by ibid in 2002-05-23 at <msg01488.html> (same site)) (Also see "Six of One, a Half Dozen of the Other" by Glenn Vanderburg in 2004-03-29 at <https://vanderburg.org/
17:01:55 <lambdabot> blog/2004/03/29/koan.html>)
17:01:58 <slack1256> @type mapException
17:02:00 <lambdabot> (Exception e2, Exception e1) => (e1 -> e2) -> a -> a
17:02:01 <ski> (for future reference)
17:02:15 <fen> reusing repeatedly n, m times, is always avoiding needless int decriments
17:03:24 <slack1256> it seems mapException will suffice
17:06:12 <ski> yushyin ^
17:14:57 <dmwit> "The static programmer was an idiot. The dynamic programmer was an idiot."
17:15:01 <dmwit> Just about sums it up, yup.
17:24:49 <ski> dmwit : which was that a comment on ?
17:26:47 * hackage alist 0.1.1.6 - lists with O(1) append  https://hackage.haskell.org/package/alist-0.1.1.6 (AlanHawkins)
17:27:53 <dmwit> ski: the petrol/diesel one
17:28:44 <dmwit> ski: Well, the followup, in which the static programmer discovered a gas station with no petrol, and so jury-rigged a chemical plant to convert the diesel to petrol on the fly.
17:34:11 <ski> ok
17:34:37 <ski> hm, that "tension between opposites" reminds me of <https://ncatlab.org/nlab/show/adjoint+modality>,<https://www.researchgate.net/publication/290468248_The_Influence_of_Heraclitus_on_Modern_Mathematics>,<https://ncatlab.org/nlab/show/Unity+and+Identity+of+Opposites+in+Calculus+and+Physics>,<https://ncatlab.org/nlab/show/Adjointness+in+Foundations>
18:25:17 * hackage feather 0.1.0.0 -   https://hackage.haskell.org/package/feather-0.1.0.0 (ssadler)
19:43:47 * hackage extensible-effects-concurrent 0.19.0 - Message passing concurrency as extensible-effect  https://hackage.haskell.org/package/extensible-effects-concurrent-0.19.0 (SvenHeyll)
20:00:50 <lacaps> Hello
20:03:43 <lacaps> #haskell-beginners
20:28:17 * hackage extensible-effects-concurrent 0.19.1 - Message passing concurrency as extensible-effect  https://hackage.haskell.org/package/extensible-effects-concurrent-0.19.1 (SvenHeyll)
21:46:47 * hackage pandoc 2.7.2 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-2.7.2 (JohnMacFarlane)
22:14:47 * hackage vado 0.0.11 - Runs commands on remote machines using ssh  https://hackage.haskell.org/package/vado-0.0.11 (HamishMackenzie)
23:45:47 * hackage gi-gtkosxapplication 2.0.16 - GtkosxApplication bindings  https://hackage.haskell.org/package/gi-gtkosxapplication-2.0.16 (inaki)
23:59:01 <TrueBoxGuy> @pl (\(y, row) -> fmap (\(x, alive) -> Cell alive x y) (zip [0..] row))
23:59:01 <lambdabot> uncurry ((. zip [0..]) . fmap . (`ap` snd) . (. fst) . flip (flip . flip Cell))
23:59:15 <TrueBoxGuy> Nope
