00:01:27 <jusss> I can think (a->b) (r->a) a is b,    but reverse it, I can not
00:02:23 <Cale> The rule for lambda is that if from assuming that x has type a, we can derive some expression e of type b, then \x -> e will have type a -> b
00:02:47 * hackage haiji 0.2.3.0 - A typed template engine, subset of jinja2  https://hackage.haskell.org/package/haiji-0.2.3.0 (NoriyukiOhkawa)
00:04:27 <jusss> yeah, I know that, the direction, expand b to f (g x) , not easy for me, but f (g x) to b is easy
00:05:15 <jusss> it's kind like 1 + 1 = 2, but 2 = 1 + 1 is not easy
00:10:01 <wolfman154> Do any of you guys know the link to change xmonad key bindings, I can’t find find the link geekasaur sent me earlier 
00:12:24 <wolfman154> Never mind I found it   :)
00:12:39 <Cale> jusss: Did you follow my explanation of how to write it?
00:14:43 <Cale> jusss: In general, this way of making types line up is not *always* going to result in the program you want, but it's fairly effective at restricting your options.
00:14:57 <Cale> In this case, there was only one program we could have written.
00:15:06 <jusss> Cale: you remove fmap on the right of = and move x from right of = to left, that's what I don't understand 
00:15:18 <jusss> yeah, I did follow you example, 
00:15:22 <Cale> You mean when I went from
00:15:28 <Cale> fmap f g x = f (g x)
00:15:30 <Cale> to
00:15:35 <jusss> <Cale> fmap f g x = f (...)
00:15:37 <Cale> fmap f g = \x -> f (g x)
00:17:24 <Cale> jusss: That step there
00:17:40 <Cale> was the result of looking at the types of things we had, and the type of thing we wanted
00:17:53 <Cale> (as were most of the steps, to be honest)
00:18:03 <jusss> it's kind like math stuff
00:18:20 <Cale> It's exactly like logic
00:19:12 <jusss> if fmap (a->b)  (r->a) =  (r->b)  and f = a->b ,   g= r->a
00:19:14 <Cale> In logic, if you want to prove A -> B (that is, "if A then B" or "A implies B"), you may start by assuming A, and trying to obtain B.
00:19:32 <jusss> so what b is ?
00:19:50 <Cale> In lambda calculus (or Haskell), if you want to construct a function of type A -> B, you may start by introducing a variable x of type A, and trying to obtain an expression e of type B
00:19:58 <Cale> and then \x -> e has type A -> B
00:20:35 <Cale> In logic, if you know A and you know A -> B, then you may conclude B
00:21:09 <Cale> In lambda calculus (or Haskell) if you have x :: A, and f :: A -> B, you may apply the function to obtain  f x :: B
00:21:33 <jusss> if fmap (a->b)  (r->a) =  (r->b)  and f = a->b ,   g= r->a, then how to express b with f and g
00:21:58 <Cale> Well, you're trying to construct a function of type r -> b
00:22:06 <Cale> so it might as well be a lambda
00:22:11 <Cale> \x -> ...
00:22:23 <Cale> now you have x :: r
00:22:31 <Cale> and you need to construct something of type b
00:22:56 <Cale> The only way to construct something of type b is to apply f
00:23:05 <Cale> \x -> f ...
00:23:10 <Cale> and now you need something of type a
00:23:25 <Cale> and the only way to construct something of type a is to apply g
00:23:32 <Cale> \x -> f (g ...)
00:23:41 <Cale> and now you need something of type r, which you have, it's x
00:23:45 <Cale> \x -> f (g x)
00:24:21 <Cale> Make sense?
00:25:16 <jusss> g -> f will get (r->a) -> (a->b)  so (r-> b)?  and (r->b) = g -> f and b is?
00:25:43 <Cale> That doesn't quite make sense to me
00:25:55 <Cale> What did you mean to indicate by g -> f there?
00:26:24 <jusss> 'cause g = (r->a)
00:26:28 <Cale> f and g were terms
00:26:39 <Cale> a, b, r, are types
00:26:47 <Cale> they live in different namespaces
00:26:54 <jusss> yeah, I mixed them,    and -> =
00:27:07 <Cale> g :: r -> a
00:27:13 <Cale> not g = r -> a
00:27:22 <jusss> whey they don't use the same symbols?
00:27:32 <Cale> Types and terms?
00:27:41 <jusss> yeah
00:27:43 <Cale> Because it doesn't take you very far
00:27:59 <Cale> We're already more punny with it than we ought to be
00:28:15 <Cale> Using (Int, Char) for the type of pairs of an Int and Char, for example
00:28:21 <Cale> rather than for a pair of types
00:28:34 <jusss> I mean -> and =
00:29:32 <Cale> Which -> is that?
00:29:45 <Cale> There's an arrow at the type level, which constructs the type of functions
00:30:00 <jusss> use ->  in type and use = in function
00:30:01 <Cale> and there's an arrow at the term level which is part of the syntax of a lambda expression
00:30:16 <Cale> and we can also use equations in order to define functions and other values
00:31:22 <jusss> ok, 
00:32:44 <jusss> it's really interesting we can get the right part of '=' from the left part of '=' through the type signature
00:35:54 <Cale> Well, when two expressions are equal, they must have the same type
00:36:45 <Cale> So if the left side of our equation is fmap f g, whatever its type is must be the type of the right hand side of our equation.
01:03:21 <yoneda> Cale++
01:10:57 <Akii> oh my, `decode "null" :: Maybe Float` gives "Just NaN"
01:11:02 <Akii> what black magic is this
01:11:12 <Akii> (Aeson)
01:11:18 <Cale> whaaaaa
01:11:24 <Akii> yes
01:11:25 <Taneb> Well, it's not a number
01:11:34 <Akii> would've expected a Nothing
01:12:04 <Cale> oh, right, you probably wanted Maybe (Maybe Float)
01:12:45 <merijn> Just support me and carter in our crusade to reform Float/Double and rid us of the bane of NaNs ;)
01:13:01 <Akii> like I had no idea that was even an option
01:13:03 <jle`> Akii: do you mean Just Nothing, or Nothing nothing?
01:13:13 <Akii> Nothing
01:13:15 <merijn> (mostly carter, I just do PR/propaganda :p)
01:13:31 <Akii> just like when you `decode "null" :: Maybe Int`
01:14:14 <jle`> looks like the behavior is here https://hackage.haskell.org/package/aeson-1.4.2.0/docs/src/Data.Aeson.Types.FromJSON.html#parseRealFloat
01:14:21 <jle`> it special-cases null as 0/0
01:14:45 <jle`> i wonder why
01:14:50 <merijn> jle`: I'm guessing that's just due to Haskell not having NaN literals
01:14:59 <merijn> jle`: 0/0 is the shortest way to write a NaN value
01:15:08 <jle`> oh, i mean, why null is interpreted as NaN
01:15:36 <merijn> jle`: Who knows :p
01:15:53 <merijn> NaN values should be scourged from Haskell
01:16:03 <jle`> hm, i guess NaN is not a part of the json spec
01:16:13 <jle`> so null would be the only way to indicate you 'want' NaN
01:16:25 <jle`> but, still
01:16:28 <jle`> :|
01:18:11 <bollu> We know that modulo bottom, having Foldable is like having toList. Similarly, ??? is like having fromList, with the law that fromList . toList = id, toList . fromList = id
01:18:26 <bollu> (what is the ??? is the question)
01:19:27 <merijn> bollu: I'm not sure such a thing exists (at least in a useful/general sense)
01:19:49 <bollu> merijn why not? It should for all "data structure" like things, no? 
01:20:18 <jle`> like what?
01:20:24 <bollu> jle` lists, trees, ...
01:20:28 <jle`> how about Map k
01:20:31 <jle`> hm, does it make sense for trees?
01:20:42 <bollu> yeah, you can reconstruct the data from the order of the traversal
01:20:45 <bollu> I believe
01:20:48 <jle`> try :)
01:20:57 <jle`> how could yuo make fromList for trees such that fromList . toList = id ?
01:21:23 <jle`> also, how would it work for Set, where toList . fromList = id
01:21:27 <bollu> jle` let me be more specific: complete binary trees  :) 
01:21:52 <merijn> bollu: That's a very limited number of data structures :)
01:21:54 <bollu> jle` ah indeed, Set would break the part of going from list and back. But I care more about (fromList . toList = id)
01:21:56 <jle`> hm, that went from "all data structures" to "some rare very specific data structures" pretty fast :P
01:21:57 <bollu> merijn right
01:22:07 <bollu> jle` Yeah, I saw the problem :) 
01:22:18 <bollu> thanks. Mh, this is annoying. 
01:22:25 <jle`> i still don't think it is even true for complete binary trees
01:22:37 <jle`> would fromList be a partial function if you don't have enough items?
01:24:09 <bollu> Hm, OK, let's ask this differently. What about a typeclass that allows (toList' :: f a -> [a], g) where g holds information about the "structure" of (f a)? And then, (fromList' :: [a] -> g -> f a), such that (fromList' . toList' = id)
01:24:26 <bollu> this seems doable?
01:24:39 <jle`> i suppose you just described Traversable
01:24:41 <bollu> jle`, merijn thanks for the food for thought
01:24:54 <bollu> oh, you mean stick the g into the Applicative you're traversing with?
01:25:04 <jle`> no, i mean the typeclass you are talking about is Traversable
01:25:09 <bollu> I don't see the isomorphism
01:25:20 <bollu> traversable is basically "traverse the structure with effects"
01:25:29 <bollu> this is more "analyse the structure"
01:25:36 <jle`> traversable lets you look at the ordered elements, but retains information of the structure so that you can re-construct it
01:25:58 <jle`> if something can implement traverse, it means that it can remember the structure to re-construct
01:26:02 <jle`> the original structure
01:26:19 <jle`> traverse isn't just "traverse the structure" --- that's Foldable
01:26:24 <jle`> traverse is "traverse the structure, and re-construct"
01:27:48 <jle`> for an example of this re-construction in action, see those algorithms that let you sort a general Traversable :)
01:28:08 <jle`> those algorithms usually involve getting the list of items, and then re-constructing the original Traversable structure, but with the elements swapped to be sorted
01:30:47 <jle`> this is also the idea behind `partsOf`, in lens
01:32:08 <jle`> > over (partsOf traverse) sort (M.fromList [('a', 3), ('b', 2), ('c', 1)])
01:32:10 <lambdabot>  fromList [('a',1),('b',2),('c',3)]
01:32:31 <jle`> you can think of this as (1) extracting the list and the structure, (2) sorting the list, (3) injecting the list back into the structure
01:38:55 <Ulrar> Hi, quick question is there any examples of how to use named capture groups with the regex package ? The doc mentions the cp quasiquoter for that but I have no idea how to use it
01:42:24 <merijn> Ulrar: In the category, not directly helpful responses: What are you using the regexes for and are you sure they're the best way to go?
01:42:30 <jle`> bollu: actually, the exact form toList' is `partsOf traverse (Context id)` :)
01:43:01 <jle`> er, by that i mean, your toList' exists pretty much exactly in that form, for Traversable
01:43:18 <Ulrar> merijn: Yes, I'm using them to parse log files, like fail2ban with the regex in conf files
01:46:23 <merijn> Ulrar: So you're reading the regex from a file to use on the logs?
01:46:36 <Ulrar> That's it, yes
01:46:41 <Ulrar> The regex is compiled at runtime
01:47:03 <Ulrar> Not ideal but it beats having to code a version of the software for each server manually
01:47:06 <jle`> @let bolloToList x = let Context g xs = partsOf traverse (Context id) xs in (g, xs)
01:47:07 <lambdabot>  Defined.
01:48:03 <merijn> Ulrar: then you can (well, have) to ignore the text on using the 'cp' quasiquoter, as that only works for compile time static regexes
01:48:13 <jle`> @let bolloFromList g xs = g xs
01:48:14 <lambdabot>  Defined.
01:49:04 <Ulrar> Yeah I'm using compileRegex instead of the eq quasi quoter, but I have no idea how to get the named captures group out of the result
01:49:04 <jle`> > uncurry bolloFromList . bolloToList $ [1..10]
01:49:08 <lambdabot>  *Exception: <<loop>>
01:49:14 <jle`> aw man
01:49:26 <Ulrar> s/eq/re/ of course
01:50:06 <jle`> @let bolloToList x = let Context g xs = partsOf traverse (Context id) x in (xs, g)
01:50:07 <lambdabot>  Defined.
01:50:14 <jle`> @let bolloFromList xs g = g xs
01:50:15 <lambdabot>  Defined.
01:50:20 <jle`> > uncurry bolloFromList . bolloToList $ [1..10]
01:50:22 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
01:50:23 <Ulrar> My code works fine without named capture groups as long as what I'm trying to extract is the first capture group, but it's pretty annoying to use that way
01:50:38 <jle`> > uncurry bolloFromList . bolloToList $ M.fromList [('a',1),('b',2),('c',3)]
01:50:41 <lambdabot>  fromList [('a',1),('b',2),('c',3)]
01:51:44 <merijn> Ulrar: You should just get a Matches value, no?
01:51:55 <Ulrar> Yes
01:52:12 <Ulrar> But I don't know which of those Matches is the one I want
01:52:53 <Ulrar> Well maybe even plural, I might need two matches for some log files I believe
01:53:21 <Ulrar> So anyway, I'm trying to get the name of the capture group with the value it matched
01:53:44 <merijn> Ulrar: A matches values represents multiple matches
01:53:56 <Ulrar> That's my problem, yes
01:53:57 <merijn> Ulrar: Because I see "allMatches :: Matches a -> [Match a]" in the docs
01:54:19 <Ulrar> I can't find a way to get the name of the capture group from a Match
01:54:22 <pezubi> How can I read and write files?
01:54:33 <Ulrar> even though the doc does say you can name capture groups
01:54:51 <jle`> pezubi: what kind of files?
01:55:23 <pezubi> Textfiles, with numbers (and maybe words?)
01:55:49 <jle`> simplest way would probably be `readFile :: FilePath -> IO String`
01:56:04 <Ulrar> reCaptureNames seems to give you the names, but it's missing the equivalent for the matches
01:56:10 <jle`> and `writeFile :: FilePath -> String -> IO ()` 
01:56:12 <pezubi> do I have to import any extra packages?
01:56:27 <jle`> they should be in Prelude (the default import) i believe
01:56:34 <pezubi> okay thanks
01:56:52 <jle`> np!
02:02:23 <merijn> pezubi: Although you almost certainly want the readFile and writeFile from the text package, because String's are kinda bad for this :)
02:07:46 <pezubi> merijn: so I should only use Strings and maybe chars?
02:08:54 <merijn> pezubi: If you are operating on entire files you'll want to use Text (or lazy Text) from the text package. String is a linked list of characters, which makes it *very* memory unfriendly. Text is dense blob of unicode text, which is far more memory friendly and (generally) faster
02:10:08 <merijn> pezubi: on 64 bit hardware String can easily use 24 bytes per character, whereas Text will be ~2 bytes per character (assuming western/english text)
02:10:30 <jle`> i think it's situational. if you're only reading small files then the string versions should probably be fine
02:11:09 <merijn> jle`: Probably, if you're reading short files and doing something like Project Euler/code-golfing
02:11:20 <merijn> But using Text isn't much more work and much more future proof
02:12:42 <tdammers> additional note: if you're dealing with "pseudo-textual" data (binary data encoded such that interesting parts align with ascii, like for example HTTP), then you may want to use Bytestring instead of Text (i.e., operate on byte arrays rather than strings)
02:13:07 <tdammers> I believe many of the project euler challenges are like that
02:13:13 <merijn> yeah
02:13:28 <tdammers> then again, most of the PE challenges are also such that this kind of optimization doesn't make a fundamental difference
02:13:35 <merijn> Although, also: Project Euler is a terrible tool for learning programming in general, and Haskell in particular :)
02:13:42 <tdammers> hmhm
02:13:48 <tdammers> it's not really about programming, is it
02:14:08 <tdammers> more about figuring out which algorithms to apply to a given problem
02:14:29 <jle`> readFile/writeFile is also useful for educational purposes, which (from the context) might be the situation happening here
02:15:11 <merijn> jle`: Sure, but text also has readFile/writeFile, which are just as easy to use (arguably easier, since the ones for strict Text don't do lazy IO)
02:16:34 <jle`> i have to leave now, but just letting everyone know so that my /part is not interpreted as a passive aggressive reaction to the conversation :)
02:19:17 * hackage telega 0.1.9 - Telegram Bot API binding  https://hackage.haskell.org/package/telega-0.1.9 (iokasimovmt)
02:23:47 * hackage hlint 2.1.16 - Source code suggestions  https://hackage.haskell.org/package/hlint-2.1.16 (NeilMitchell)
04:02:52 <Putonlalla> Can the following function be improved if the constraints are strengthened?
04:02:52 <Putonlalla> `longestSubsequences xss = [xs | xs <- xss, (not . any (\ ys -> xs /= ys && xs `isSubsequenceOf` ys)) xss]`
04:04:12 <Putonlalla> I feel like there should be a better way, but I don't see it.
04:12:43 <Ariakenom> Putonlalla: maybe something with tails?
04:12:49 <Ariakenom> [xs | xs:yss <- tails xss, not . any (isSubsequenceOf xs) $ yss]
04:13:37 <Ariakenom> (my confidence in the correctness of ^ is low)
04:14:40 <Guest66427> Hi! I'm looking for a traverse-like function, but which also passes the previous result. Something like `(b -> a -> f b) -> t a -> f (t b)`, but hoogle isn't being too helpful
04:15:18 <Cale> Guest18750: which actual type do you need it for?
04:15:48 <__monty__> Sounds like a fold.
04:15:49 <opqdonut> you can do that for "linear" traversables, which are Foldables I guess?
04:15:57 <Cale> sounds like some sort of weird fixed point
04:16:03 <Ven``> Cale: I have a tree, and I want a `Either Error [verbibols]`.
04:16:03 <Ven``>  
04:16:07 <opqdonut> no wait Traversables are Foldables
04:16:41 <opqdonut> right yeah Traversable is things that can be "traversed from left to right"
04:17:34 <Ven``> definitely a traversable, but I'm not sure how to do that with an Either
04:17:34 <Ven``>  
04:17:50 <Cale> :t mapAccumL
04:17:51 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
04:18:14 <Cale> not quite what you're looking for, but close perhaps?
04:18:20 <Ven``> Yeah -- I've seen that one, but I want `a -> b -> Either Error b`, not `a -> b -> (a, c)`
04:18:51 <Cale> I would just write it recursively
04:19:09 <Ven``> That's the current code I have, but it's just not as pretty :-)
04:26:52 <Putonlalla> Certainly not like that, Ariakenom.
04:31:57 <Putonlalla> > (Ergh !)
04:31:59 <lambdabot>  error:
04:31:59 <lambdabot>      Ambiguous occurrence ‘!’
04:32:00 <lambdabot>      It could refer to either ‘Data.Array.!’,
04:37:31 <Bish> cabal really doesnt fuck around when saying install in terms of cpu usage
04:37:50 <Ariakenom> Putonlalla: what does the function do?
04:38:42 <merijn> Bish: You mean the compilation? Cabal generally has negligible CPU usage for me, but GHC obviously grabs quite a lot
04:38:55 <Bish> yeah like every last bit
04:39:04 <Bish> i have a amd raven laptop, and my lap is burning now
04:39:23 <Bish> talking about no sideeffects
04:39:23 <merijn> Bish: By default cabal builds packages in parallel, one package per available core
04:39:32 <Bish> i figured
04:39:43 <merijn> Bish: So yes, it manages to heat up CPUs rather effectively :p
04:39:51 <Putonlalla> Given a set of sequences, it removes those sequences that are subsequences of longer sequences, Ariakenom.
04:40:32 * Bish is reminded of dominated terms in unviersity
04:41:12 <Bish> merijn: why on earth is "hoogle" such a big package with so many dependencies
04:41:14 <Putonlalla> The simple implementation constrained by `Eq` has quadratic time complexity and I was wondering if there was another one constrained by `Ord` that would have quasilinear time complexity. Similar improvements are available for other algorithms.
04:41:44 <merijn> Bish: Why would you expect it to be small? It's a rahter complex application
04:42:03 <Bish> oh wait.. you're saying hoogle is the implementation of the website
04:42:13 <Bish> not jsut a website query thing?
04:42:16 <merijn> Bish: Yes
04:42:17 <Bish> installing it the first time
04:42:21 <Ariakenom> Putonlalla: oh a complexity improvement.
04:42:21 <Bish> crazy
04:43:06 <merijn> Bish: The Hoogle package is literally the stuff that runs the website :p Although it also has a local application, but that doesn't query the website, that literally just builds and queries a database locally :)
04:43:27 <Bish> yeah i figured
04:43:31 <Ariakenom> prefixes in n * log n  seems doable. but subsequences hm
04:43:46 <Bish> hm, where did cabal put the binary, at home it was in .cabal/bin
04:44:37 <Bish> now it's gone :(
04:45:33 <merijn> Bish: v1-build or v2-build?
04:45:43 <Bish> cabal: The program 'happy' version >=1.19 is required but it could not be
04:45:54 <Bish> didn't see that
04:47:06 <Bish> what do i do about that?
04:47:12 <Clint> Bish: apt install happy
04:47:22 <merijn> Or cabal install happy
04:47:44 <Bish> hm, why doesnt it just pull the dependency?
04:47:48 <Bish> like the rest of the packages
04:47:59 <merijn> Bish: Because the author didn't correctly set build-depends, probably :p
04:48:10 <Bish> oh, okay
04:48:18 <Darwin226> I've been getting good mileage from a function that coerces between any two things that have the same generic representation but now I'm running into issues where the :*: constructors are associated differently for two types
04:48:25 <merijn> Bish: For several years it wasn't really possible to track executable dependencies in cabal
04:48:29 <Darwin226> is there some function/package that can normalize the representation?
04:48:39 <Bish> merijn: is it now?
04:48:43 <merijn> Bish: And alex/happy is often installed fairly early so it can be glossed over easily
04:48:48 <merijn> Bish: It should be, I think?
04:49:12 <Bish> so the problem here was, he wasn't using import happy, he executed happy?
04:49:53 <Bish> because it was steaded which version of happy was missing
04:50:03 <Bish> i mean doesnt that mean he did correctly set depends?
04:50:16 <merijn> Bish: Yes, happy is an executable that's used as a preprocessor
04:50:40 <merijn> Bish: Well, I mean that cabal didn't auto-install executable dependencies
04:51:15 <Bish> but then how did it know that it was a dependency?
04:51:35 <Bish> shoulnd't the error message be "happy: command not found" or something
04:52:31 <merijn> Bish: Cabal has hardcoded support for running several preprocessors (including happy) and knows how to check if they're installed
04:53:10 <Bish> okay i think i get it
04:53:45 <Bish> why does the "stdlib" of haskell have so many functions with flipped arguments or similiar things
04:53:49 <Bish> kinda confusing to a newby
04:54:05 <merijn> Bish: As of version 2.0 cabal has build-tools and build-tools-depends, so it knows which tools should be installed and how to install them, but not everyone has updated their packages to use those yet
04:54:13 <merijn> Bish: Flipped how?
04:54:21 <Bish> forM and mapM etc
04:54:57 <Bish> i understand cases like <$>, but for written out functions it gets more confusing
04:55:15 <bwe> I want to redirect from within servant app to another url (with possibly umlauts). How can I do it? Current approach works yet fails with German umlauts: https://bpaste.net/show/f8a7747df151
04:55:33 <merijn> Bish: It's because forM is nice and easy for use with a fixed collection and a lambda
04:56:16 <merijn> Bish: Stuff like: https://github.com/merijn/GPU-benchmarks/blob/d3065f61d8482e25084ae868e29047a826300ca7/benchmark-analysis/model-src/Main.hs#L32-L36
04:56:59 <Ariakenom> more so with several do-lines
04:57:21 <merijn> Ariakenom: Yeah, but this is the quickest bit of code I could find in a project :p
05:04:14 <Ariakenom> Putonlalla: perhaps "concat . tails" and then a prefix based algorithm can be used.
05:04:23 <Bish> i don't know i would prefer a (flip.x)
05:04:26 <Ariakenom> concat . map tails
05:05:01 <Bish> i don't know i would prefer a (flip x)
05:05:53 <Ariakenom> possibly n * |w| * log (n*|w|) with |w| being the length of the sequences
05:07:52 <sicklork1n> I have an Eq instance that compares text using the overlap coefficient. e.g. (==) (Foo a) (Foo b) = overlap a b == 1.  Now I want to make `Set Foo`, but it's not obvious to me how I should define Ord.
05:07:57 <Putonlalla> That's certainly an improvement, Ariakenom. I'm currently looking at turning the set of sequences into a prefix tree and working out the solution by pruning it.
05:09:14 <Ariakenom> it might be worse for long sequences compared to n
05:09:45 <Putonlalla> I'm fine with that.
05:09:53 <Bish> how would i ask hoogle for the cababilities of "chan" ?
05:10:01 <Bish> if i wanted to know the functions that interact with it
05:10:02 <__monty__> Putonlalla: Is a subsequence guaranteed to be a prefix?
05:10:03 <Ven``> Might be more pain than it's worth, but is there a `Bool -> a -> b -> Either a b`? somewhat the opposite of Bif{unctor,oldable}
05:11:24 <Putonlalla> Do you mean equal initial element or equal all initial elements, __monty__?
05:11:34 <c_wraith> Bish: the most reliable way is to use it to determine what package/module it's in, and then look up the docs for those.
05:12:10 <Bish> :( i was expecting to have it nicely inside CLI
05:12:54 <__monty__> Putonlalla: Just that I thought it was a great idea at first but then I thought but wait don't you have to check whether something'd be a prefix of all subtrees?
05:12:54 <Putonlalla> The answer to the former is possibly positive, but the answer to the latter is negative.
05:13:35 <__monty__> Bish: If you import the module in ghci you do have :browse and :info.
05:13:53 <c_wraith> and :doc on sufficiently new versions of ghc
05:14:45 <Bish> __monty__: but those doesnt show text
05:14:52 <c_wraith> they show types
05:15:13 <Bish> yes, but how would i found out about "writeChan" just knowing "Chan"
05:15:15 <__monty__> What more could you possibly want to know than the type : >
05:15:20 <Bish> without having to use google or hoogle
05:15:25 <__monty__> Through :browse.
05:15:34 <Bish> well okay
05:15:45 <__monty__> Though that doesn't work cross-module/project of course.
05:16:02 <c_wraith> yeah, the cross-module is the thing looking up package docs is really good for.
05:16:25 <c_wraith> It's *far* easier to look for related things in the package index.
05:16:38 <c_wraith> (why does no one ever know about haddock's package index?)
05:17:06 <merijn> c_wraith: Or about the quickjump stuff add over the last year, for that matter :p
05:18:09 <c_wraith> I mean, I saw a comment on SO a while back that asked why there was no single list of everything defined in lens.  I responded with a link to the package index, and the person who asked was shocked they existed.
05:19:02 <Putonlalla> Isn't there a command to open the index for the current project too?
05:21:34 <__monty__> merijn: You mean hackages's "s", right? What annoys me is it doesn't seem to work on packages' content pages.
05:21:49 <merijn> __monty__: It does for me
05:22:09 <merijn> __monty__: Is your browser maybe auto-selecting the search box at the top for input? That'd block it
05:22:35 <__monty__> Maybe I'm just running into pages that don't implement it?
05:22:49 <merijn> __monty__: That could be
05:23:06 <c_wraith> yeah, hackage docs aren't regenerated when new versions of haddock are released
05:23:55 <__monty__> Hmm, it *is* "s," right? Not getting anything for tasty-hunit, butcher, multistate, argon2.
05:24:21 <__monty__> It's probably that, all old theme docs.
05:24:29 <merijn> __monty__: Not working for me on tasty-hunit, but see c_wraith's comment
05:26:22 <Ariakenom> % filterPrefix = foldr (\x xs -> case xs of {(y:_) | isPrefixOf x y -> xs; _ -> x:xs}) [] . sort
05:26:22 <yahb> Ariakenom: 
05:26:24 <__monty__> The search box autoselection is also rather annoying. Tab puts me in the address bar and *then* I can use ESC to unfocus everything so I can finally press s.
05:26:39 <Ariakenom> % filterPrefix ["abc","b", "de","a", "abc"]
05:26:39 <yahb> Ariakenom: ["abc","b","de"]
05:30:54 <Putonlalla> That doesn't do what I expected, so perhaps I should share my test cases.
05:31:13 <__monty__> I'd expect it to remove b too.
05:31:19 <__monty__> From your descriptions.
05:31:35 <Ariakenom> yeah that just does prefixes, hence the name
05:32:36 <Putonlalla> Do you want to keep thinking about this or should I get back to you later once I have a better idea?
05:33:26 <Ariakenom> im just tinkering with it if I have some spare time
05:33:35 <Ariakenom> lemme know if you find a solution
05:33:52 <Putonlalla> Sure thing.
05:34:07 <Putonlalla> I'm in the same position.
05:42:47 <Ven``> Cale: I ended up with https://gist.github.com/vendethiel/e7d0e75d00e5965f47be030e84769b2b ; probably only needs `Applicative` instead of `Monad`, and probably could use some `Foldable` instead of `[]`, but it works™ :)
06:16:03 <phadej> >>= suggests it needs Monad :)
06:19:08 <phadej> :t \f -> evalStateT . traverse (\a -> StateT $ f a) 
06:19:09 <lambdabot> (Traversable t1, Monad m) => (t2 -> s -> m (b, s)) -> t1 t2 -> s -> m (t1 b)
06:19:31 <phadej> ah, that's a bit different
06:20:37 <phadej> :t foldM
06:20:38 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
06:20:49 <phadej> is the `traverseAccum`, Ven`` ^
06:31:47 * hackage telega 0.2.0 - Telegram Bot API binding  https://hackage.haskell.org/package/telega-0.2.0 (iokasimovmt)
06:48:55 <adamCS> A question (not yet well posed):  I want to represent a function from a foldable of values of type x to another value of type y. I'd like it to be container agnostic.  So ideally I would just use a Control.Foldl.Fold x y.  But I'd also like for a user to be able to provide any function  of the form (Foldable h => h x -> y).  So I tried one constructor of this "F x y" containing a "Fold x y" and another containing "(forall h.
06:48:56 <adamCS>  Foldable h=> h x -> y)" and the latter thing is...hard to use.  
06:51:06 <adamCS> Is there a way to do this?  Adding the container type to the data type doesn't really make sense.
06:55:46 <adamCS> (when I say "hard to use", I mean that type inference is finicky.  Sometimes it works and sometimes ghc has trouble unifying--if that's the right word here--the h inside that forall with the whatever at-that-point-ambiguous type represents the container.  And I get a "Could not deduce..." error)
06:56:17 * hackage ghcid 0.7.3 - GHCi based bare bones IDE  https://hackage.haskell.org/package/ghcid-0.7.3 (NeilMitchell)
06:58:23 <lyxia> adamCS: this looks reasonable so far, so perhaps you could ask about some concrete examples of ambiguity
06:59:56 <adamCS> lyxia: Thanks.   I can try to isolate a case.  But it happens sporadically and in the middle of messy code which makes it hard to isolate where the inference has gone wrong.  I was hoping someone might have seen related issues before.  I'll try to reproduce in something sane to look at...
07:11:12 <Bish> when ghci is interpreting what exactly does that mean? i mean haskell does not have bytecode has it?
07:11:29 <Bish> will it be native code on my cpu or rather a interpreter, really
07:17:06 <tdammers> it's kind of in between. ghci compiles and loads code from any files you import, and then kind of puts you into an "IO with lazy continuation" mode - you're essentially in an IO block that is being evaluated and executed while you add to it
07:17:41 <tdammers> I think Stephen Diehl has a section on that in his (incomplete) tutorial to implementing a Haskell compiler
07:17:49 <merijn> Bish: Note that languages and implementations are independent
07:18:11 <merijn> Bish: Specifically, GHC compiles to machine code, but ghci compiles to bytecode which gets interpreted
07:18:26 <Bish> why did ghc people went that weird route?
07:18:46 <tdammers> mainly because the REPL was a bit of an afterthought
07:18:47 <merijn> Bish: Because generating machine code on the fly is much harder than generating bytecode on the fly
07:18:49 <Bish> i mean keeping those 2 worlds consistent must be hard?
07:19:07 <merijn> Bish: I don't think it'd be that hard, tbh
07:19:21 <Bish> terry davis vibes, again
07:19:37 <z0> > (last [-1,0.999..1]) > 1
07:19:40 <lambdabot>  False
07:20:28 <z0> oops
07:20:33 <z0> > (last [-1,-0.999..1]) > 1
07:20:35 <lambdabot>  True
07:20:51 <z0> is this supposed to happen, and why does it?
07:20:54 <merijn> z0: The enum instance of Float/Double is despicable evil and should be avoided at all cost
07:21:11 <merijn> z0: So, "yes", depending on your definition of "supposed to"
07:21:43 <merijn> I would argue that the enum instance of Float/Double should be deleted (or turned into the useless, but sane implementation that enumerates all floats)
07:21:44 <Cale> Bish: GHC has a lot more than one backend, so it doesn't seem too out of place
07:22:02 <Cale> I think Enum should be split into two classes
07:22:15 <Cale> pred and succ don't really belong
07:22:23 <merijn> Cale: That too
07:22:51 <Cale> If they weren't there, we could just think of what remained as "how to interpret the .. syntax in lists"
07:23:25 <Cale> I think the Float and Double instances (and especially the Rational instance) could make a lot more sense than they do
07:23:35 <tdammers> or, alternatively, keep *only* succ and pred, and put the rest into a new typeclass
07:23:55 <Cale> succ and pred honestly aren't very useful
07:24:08 <tdammers> I use them all the time
07:24:12 <Cale> I would almost be in favour of deprecating and eventually removing them
07:24:15 <Cale> oh really?
07:24:17 <tdammers> yes
07:24:37 <tdammers> I find `succ` beautifully captures the intent "get me the next higher value from this discrete domain"
07:25:10 <tdammers> it's just a shame that they're partial for anything conceptually finite
07:25:37 <vivit> Is it possible to use ghci to find the typeclasses a type belongs to?
07:25:55 <merijn> vivit: It depends
07:26:07 <merijn> vivit: ":info" will print all typeclasses that are in scope/imported
07:26:31 <tdammers> you cannot possibly get an exhaustive list, due to the open typeclass universe
07:26:36 <merijn> vivit: "all typeclasses a type belongs to" doesn't have a sensible definition, because people can keep defining new ones :p
07:26:58 <vivit> Can you, for example, give two type classes to see if one is a subset of the other (at least for the types imported)
07:26:59 <tdammers> you'd have to be able to look at all the computers in the world simultaneously :D
07:27:14 <vivit> I mean those in scope
07:27:25 <tdammers> why do you need to know?
07:27:27 <merijn> vivit: That doesn't exist atm, no?
07:27:35 <vivit> Why do I need to know?
07:27:39 <Cale> vivit: You can look at the superclass constraints on the class definition itself
07:27:49 <vivit> Is there any way to access those from ghci?
07:27:54 <Cale> umm...
07:28:03 <Cale> *Maybe* :info would tell you
07:28:05 <Cale> Let me look
07:28:09 <tdammers> yes it does
07:28:12 <vivit> aight
07:28:12 <tdammers> :info Integral
07:28:21 <tdammers> lists Real and Enum
07:28:39 <tdammers> so yeah, finding superclasses is your best bet
07:28:49 <tdammers> anything else might as well be a sheer accident
07:29:15 <Cale> "class Eq a => Ord a" means that whenever someone writes an Ord instance, they must also write a corresponding Eq instance.
07:29:37 <Cale> (That Eq instance is allowed to use the Ord operations if it wants to though)
07:29:38 <tdammers> the typeclass universe is open both ways: people can add typeclass instances to a type, but also types to a typeclass
07:30:17 <tdammers> so "list all the types that have instances of this typeclass" is just as impossible as "list all the typeclasses that this type has instances for"
07:30:59 <maerwald> tdammers: the typechecker could download hackage though and look through it
07:31:00 <maerwald> :D
07:31:19 <maerwald> that's your sufficiently universal universe
07:31:29 <phadej> it really isn't
07:31:56 <tdammers> indeed, it totally is not
07:32:31 <tdammers> people write non-free code; people compile against git snapshots; plus you obviously need a crystal ball through which you can download all future versions of hackage as well
07:33:49 <tdammers> you could enumerate all valid Haskell modules, but unfortunately that will have you run into the halting problem
07:36:37 <__monty__> Will it? I thought the whole point was you might never? : >
07:42:15 <tdammers> "running into the halting problem" is a bit tongue-in-cheek - if you have the halting problem, you keep running forever, which means you can never be sure
07:42:55 <tdammers> but we already know that there is an infinite number of valid Haskell programs (handwaiving petty concerns like available disk space and RAM and such), so it's pretty obvious that this search will never terminate
07:43:24 <merijn> tdammers: Number of valid Haskell programs is pretty much infinite, since no upper bound on module size is defined
07:43:42 <merijn> I don't think we have an upper limit on identifier sizes either
07:44:47 <tdammers> at least we have a practical upper limit on tuple sizes
07:45:16 <tdammers> compared to the number of valid Haskell programs, the maximum tuple size is approximately zero
07:45:24 <tdammers> (give or take 62)
07:46:32 <merijn> tdammers: GHC has a practical upper limit on tuple sizes, not sure the Haskell report has that
07:47:08 <Bish> Cale: yeah maybe, but they all result in native code? don't they?
07:47:10 <merijn> tdammers: Nope, report says tuples are unbounded
07:47:25 <merijn> Bish: the LLVM backend produces LLVM assembly, not machine code
07:47:29 <Bish> but sure, pureness does help in having similiar behaviour on differnet backends i suppose
07:47:39 <merijn> Bish: the (no longer functioning/distributed) C backend produced C
07:47:42 <Bish> is llvm assembly whats used as bytecode?
07:47:49 <merijn> Bish: No
07:48:10 <Bish> oh? ghcs primary code generator is llvm?
07:48:29 <Bish> i remember having read about that, and that wasn't the case, i suppose it's still not
07:48:35 <Cale> Bish: Also, they're not part of GHC proper, but there's ghcjs which is GHC with a Javascript backend, as well as a webassembly backend for GHC underway (and which intends to get upstreamed eventually)
07:49:00 <Bish> god i'd love webghc
07:49:10 <merijn> Bish: GHC's primary code generator produces native code directly without LLVM
07:49:12 <Bish> too bad it doesnt matter until it gets dom access
07:49:15 <Cale> Bish: But different types of native code are sufficiently different that adding bytecode on top of that is not surprising
07:49:21 <merijn> "There is no upper bound on the size of a tuple, but some Haskell implementations may restrict the size of tuples, and limit the instances associated with larger tuples. However, every Haskell implementation must support tuples up to size 15, together with the instances for Eq, Ord, Bounded, Read, and Show."
07:49:29 <Cale> Bish: It has DOM access?
07:49:45 <Cale> Bish: at least, I don't see how these demos would be at all possible without it...
07:49:48 <Bish> Cale: only with hacks, wasm itself doesnt have dom access
07:49:53 <Cale> hmm
07:49:54 <Cale> interesting
07:50:00 <tdammers> merijn: yes, you are right; GHC does not correctly implement the Report
07:50:14 <Cale> Well, reflex-dom is building and mostly seems to work even
07:50:24 <tdammers> merijn: or actually, it is correct in this particular instance, but violates the Report in others
07:50:30 <merijn> tdammers: Well, report does say implementations may cap the tuple limit
07:50:33 <tdammers> yeah
07:50:41 <Bish> Cale: i saw a 3d demo using wasm, and i read it, i was actually wondering how the transport happens
07:50:51 <tdammers> good thing for GHC the report doesn't say anything about performance guarantees
07:50:53 <merijn> GHC's broken support for the Report is the bane of my existence...
07:51:03 <Bish> i couldn't find the line in code that writes it to the canvas, but afaik you always have to go over javascript
07:51:04 <merijn> Gib cyclical modules imports!
07:51:06 <Cale> Bish: But ghcjs is still winning at the moment even for stuff like code size.
07:51:25 <Bish> yeah and is less of a hack... because you have dom access there without hacks
07:51:29 <Bish> it's proper FFI
07:52:00 <Cale> It's coming along though -- I just got out of a weekly meeting where Will Fancher updated a few of us at Obsidian on his progress on it :)
07:52:10 <Ariakenom> Bish: why is it more proper?
07:52:36 <Bish> but webassembly will really revolutionize web as soon as it gets dom access, ironicially maybe with getting away from DOM then
07:52:58 <Bish> Ariakenom: well... do you consider creating javascript strings for doing something proper?
07:53:50 <Ariakenom> I see nothing inherently improper about it
07:53:51 <Bish> either way, people will have to R& D it
07:54:47 <tdammers> webassembly is going to be a great tool for making the web proprietary again
07:55:00 <Cale> tdammers: in what way?
07:55:13 <Cale> Is it not sufficiently open?
07:55:52 <tdammers> it's too proprietary already - I cannot effectively audit or web-of-trust-check any javascript I'm about to have my browser run, and it's going to get worse with WA
07:55:58 <Cale> It's not like javascript web applications today are any more readable than webassembly would be.
07:56:03 <monochrom> Perhaps because low-level code is less human-readable.
07:56:10 <tdammers> yeah, we're deep down the slippery slope already
07:56:37 <monochrom> I would put my money on automated static analysis.
07:58:35 <monochrom> People are also already blocking javascript without any analysis at all.  Automated static analysis that errs on the better-safe-than-sorry side is already an improvement over today's "blacklist vs whitelist" false dichotomy.
07:59:15 <monochrom> And with automated formal methods, I don't care whether it's webasm or quantum computing.
07:59:36 <monochrom> OK your next question will be "who audits the formal methods?" :)
08:06:31 <delYsid`> Is there a way to interpret .hp files if you're not capable of viewing PostScript?
08:10:34 <Cale> You can convert to pdf?
08:11:01 <Cale> I'm sure there is a way of reading the .hp file directly, but it's not terribly readable
08:12:15 <Cale> (well, it's readable, but there's probably more of it than you care to look at)
08:14:17 * hackage threads-supervisor 1.2.0.1 - Simple, IO-based library for Erlang-style thread supervision  https://hackage.haskell.org/package/threads-supervisor-1.2.0.1 (MikolajKonarski)
08:15:59 <delYsid`> yeah, viewing the plain .hp file is rather verbose and not quite informative.
08:16:12 <delYsid`> I was hoping for some simple text summary
08:18:03 <delYsid`> I guess if the numbers to the right of the somewhat scrambled-looking function names is increasingly getting bigger and bigger, I am haviing some sort of a space leak?
08:19:07 <delYsid`> Whenever it comes to finding out when lazyness bites me I seem to hit a wall.
08:19:41 <delYsid`> s/when/if/
08:20:32 <maerwald> laziness in haskell is like memory safety in C
08:20:41 <maerwald> you never know if you have it
08:23:06 <delYsid`> As far as I understand, you always have lazyness, unless you do something wizard-like to magically make it go away in exactly the right spot.  And it is important to insist on it being totally logical if someone ever might ask you why you choose that particular bang.
08:23:17 * hackage refined 0.4.1 - Refinement types with static and runtime checking  https://hackage.haskell.org/package/refined-0.4.1 (chessai)
08:24:15 <delYsid`> Its magic!
08:24:58 <delYsid`> I tried 6 places now, which initially felt to me they could really be a good choice, with absolutely no useful results.
08:26:27 <delYsid`> I am beginning to think about a haskell bang fuzzer running on a cluster to find space leaks by brute force.
08:32:08 <lavalike> delYsid`: I went through the same exact experience end of last year
08:32:09 <Putonlalla> I just put `{-# LANGUAGE Strict #-}` at the top and pretend it's OCaml, delYsid`.
08:32:26 <wz1000> is there a nice way to run a [StateT X (Either Y) a] into a StateT X (Either Y) [a], discarding all the computations that failed. I'm looking for something with semantics similar to catMaybes
08:33:04 <Ariakenom> Putonlalla: as long as you don't use anybody elses code
08:33:14 <Ariakenom> but who would, really
08:33:38 <Solonarv> just fork it and add Strict to the default-extensions in their cabal file
08:34:47 * hackage haskoin-store 0.14.0 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.14.0 (xenog)
08:36:23 <dmwit> wz1000: asum
08:36:39 <dmwit> err... maybe not
08:36:40 <dmwit> :t asum
08:36:42 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
08:36:46 <Ariakenom> delYsid`: I barely know anything about this but if you have a suspected data type you can try a strict version of it
08:36:53 <dmwit> Yeah, that'll give you just the first success, probably.
08:38:19 <lavalike> wz1000: what represents failure there?
08:38:36 <wz1000> lavalike: some computation that returns a Left ...
08:38:49 <lavalike> :t StateT
08:38:50 <lambdabot> (s -> m (a, s)) -> StateT s m a
08:39:05 <Solonarv> @unmtl StateT X (Either Y) a
08:39:05 <lambdabot> X -> Either Y (a, X)
08:39:13 <delYsid`> Ariakenom: I kind of suspect Data.Tree, but I haven't seen a Strict version of that one yet.
08:39:42 <wz1000> It would work even if the result is State X [a] instead of StateT X (Either Y) [a]
08:40:18 <Solonarv> oh, you don't actually care about accumulating errors? that makes things simple
08:40:31 <wz1000> No
08:40:40 <dmwit> wz1000: Should the updated state from the first success be used when computing the next element of the list?
08:40:46 <wz1000> yes
08:41:02 <dmwit> :t catchError
08:41:03 <lambdabot> MonadError e m => m a -> (e -> m a) -> m a
08:41:39 <dmwit> :t fmap catMaybes . traverse (\act -> catchError (Just <$> act) (\_ -> pure Nothing))
08:41:40 <lambdabot> MonadError e f => [f a] -> f [a]
08:42:10 <wz1000> neat, that might just work
08:42:23 <lavalike> pure. Nothing.
08:42:33 <dmwit> :t fmap partitionEithers . traverse (\act -> catchError (Right <$> act) (pure . Left))
08:42:34 <Solonarv> @let foo [] = pure []; foo (m:ms) = StateT $ \s -> case runStateT m s of Left _ -> runStateT (foo ms) s; Right (a, s') -> runStateT ((a:) <$> foo ms) s
08:42:35 <lambdabot> MonadError a f => [f b] -> f ([a], [b])
08:42:36 <lambdabot>  Defined.
08:42:40 <Solonarv> :t foo
08:42:42 <lambdabot> Monad m => [StateT s (Either a1) a2] -> StateT s m [a2]
08:43:03 <dmwit> I like mine better. =P
08:43:27 <Solonarv> I think I do too, but I wanted to finish mine
08:43:37 <dmwit> yeah!
08:44:13 <wz1000> Solonarv: you missed a "'" right at the end
08:44:23 <Solonarv> aw, heck
08:44:33 <Solonarv> another reason dmwit's solution is better! :P
08:44:41 <dmwit> Solonarv++ for PG swears
08:44:59 <MarcelineVQ> shazbot
09:16:08 <monochrom> My view is I wonder why people wait until a program has grown to 300 lines long and contains too many intractible moving parts before looking at its space cost (sometimes even time cost), rather than back when they had a 5-line "helper function to convert input to my data type" they already investigate whether it's too lazy or too eager.
09:17:25 <maerwald> because problems do not arise when it's trivial
09:18:13 <monochrom> Ironically that's easy to say.  I wrote non-trivial programs too.
09:19:01 <monochrom> I certainly have my share of too-lazy helper functions and I keep them as too-lazy won't-fix.  But I always make a point of being aware of it.
09:19:39 <monochrom> I.e., if one day in the future I find myself using too much space, I already know which helper functions are the cause.
09:20:32 <monochrom> I have written 300-line programs without ever needing profilers (or debuggers for that matter).
09:21:49 <monochrom> More ironically, if there is a space problem, the trouble-shooting process is always to cut out 99% of the original code until I have 2 lines "trivial" code that reproduces the problem.
09:26:42 <asheshambasta> Hi all; which one of these is preferrable: https://gist.github.com/asheshambasta/3751d4524f7ea17ebe34b1b254dc58ef
09:28:23 <hpyCdr> can I see Conduit / Pipes basically as C#s IEnumerable or similar?
09:28:37 <asheshambasta> (personally, I find the TypeFamily one more readable; but I'd like to know if there are any pitfalls here)
09:29:14 <asheshambasta> (it also gives me way to reference the collection type of an instance of DataField)
09:34:23 <monochrom> Case in point is Bish's recent hash collider.  Its space growth was cracked by not looking at profiling output, but rather by me cutting out all the jazz about hashing and filtering and concatenating; just have one line "main = mapM_ putStrLn (replicateM 8 ['a'..'z' ])" and it reproduces the space growth. That's the culprit.
09:35:23 <monochrom> I'm sorry I'm such a scientific reductionist. But my experience (both my programs and other people's programs here) is that the problem always arise when it's trivial.
09:55:47 * hackage registry 0.1.3.5 - data structure for assembling components  https://hackage.haskell.org/package/registry-0.1.3.5 (etorreborre)
09:57:04 <MarcelineVQ> Some people are a little too terse with their package descriptions :>
10:01:23 <boj> hah
10:19:53 <portnov> hi all.
10:19:55 <portnov> @src elem
10:19:56 <lambdabot> elem x = any (== x)
10:23:02 <markus1189> ~
10:23:09 <markus1189> oops, nevermind ;)
10:24:14 <Ariakenom> portnov: hi
10:24:38 <JoeCordingley> Hi
10:26:33 <JoeCordingley> I was trying something out the other day with maps and I was using a map that I was initialising with all possible keys, but I was having to use fromJust even though I know it couldn't fail. It occurred to me that the correct data structure was a function.
10:27:25 <JoeCordingley> But would a function be non performant after many inserts
10:27:28 <JoeCordingley> ?
10:28:05 <sicklork1n> JoeCordingley: findWithDefault (error "The unimpossible happened") key map?
10:28:33 <sicklork1n> just a thought if you're having to to use (fromJust $ lookup)
10:29:25 <lyxia> the cost of running the function is going to be linear in the number of inserts
10:29:40 <JoeCordingley> it's definitely a solution, I just wondered what the canonical way of dealing with it.
10:30:33 <sicklork1n> JoeCordingley: are your values already known?
10:30:34 <JoeCordingley> but as I insert with an if k == k' then it would get more and more non performant.
10:30:51 <Philonous_> I've recently discovered Fritz Hengeleins discrimination-based sorting (and by extension ekmetts final encoding of it in the "discrimination" library) and it seems to be that this is very useful. But now I wonder why it doesn't seem to be popular at all
10:31:07 <JoeCordingley> the keys are already known, but the values will be updated
10:31:24 <sicklork1n> JoeCordingley: do have have good defaults you can use?
10:32:15 <sicklork1n> For example are you storing some kinda config.key/values?
10:32:23 <JoeCordingley> yes I do, I just wondered if there was a better approach. This is just a pet project so it's partly a learning excercise.
10:32:56 <sicklork1n> JoeCordingley: tabulate is a good solution for this.
10:33:06 <sicklork1n> maybe..
10:34:07 <JoeCordingley> Data.Functor.Rep tabulate?
10:34:39 <sicklork1n> i'll cons up a pastebin just a sec
10:39:37 <sicklork1n> JoeCordingley: https://pastebin.com/aytPajFb The nice property here is that the compile now complains if you forgot to initialize some ConfigKey
10:39:44 <sicklork1n> *compiler
10:41:32 <sicklork1n> OR maybe Higher Kinded Data might be nicer if you dno't want to restrict yourself to values of the same type.
10:41:35 <monochrom> Hrm that's nice.
10:43:42 <JoeCordingley> thanks, I'll have a look at that.
10:49:15 <sicklork1n> Philonous_: I've often wondered the same. 
10:49:21 <zachk> you could just continue using the map if you need to update it and use the maybe function
10:49:35 <zachk> > maybe 0 id (Just 5) 
10:49:38 <lambdabot>  5
10:49:45 <zachk> > maybe 0 id (Nothing) 
10:49:48 <lambdabot>  0
10:50:02 <sicklork1n> fromMaybe 0 Nothing
10:51:50 <fendor_> :t join (Left (Right 3))
10:51:51 <lambdabot> Num b => Either (Either a1 b) a2
10:54:23 <Philonous_> sicklork1n, Perhaps it's because the module is quite impenetable if you haven't read the paper and seen ekmett's talk. Maybe I should write an introduction if I find the time 
11:00:18 <sicklork1n> Philonous_: +1
11:00:48 * shapr grumbles
11:00:55 --- mode: shapr set -o shapr
11:14:03 <MarcelineVQ> something I've been wondering about lately https://gist.github.com/MarcelineVQ/1fd05c18ab83b39fd1edbcc66c8cb856 Can we ensure that all cases of a datatype are covered when it's an output?
11:14:17 * hackage universe-base 1.1 - A class for finite and recursively enumerable types.  https://hackage.haskell.org/package/universe-base-1.1 (phadej)
11:15:15 <lyxia> MarcelineVQ: https://www.reddit.com/r/haskell/comments/adtuec/onto_syntax_for_exhaustive_construction_of_a_data/ sounds relevant
11:15:17 * hackage universe-instances-trans 1.1, universe-instances-base 1.1, universe 1.1, universe-dependent-sum 1.1, universe-reverse-instances 1.1, universe-instances-extended 1.1 (phadej)
11:17:36 <fendor_> what type of exception is error call?
11:17:38 <MarcelineVQ> lyxia, neat link thank you. it even mentions being good for a parser which was exactly where I thought such a thing would be useful, not forgetting to update your parsing when your datatype is changed
11:17:42 <fendor_> is that an error
11:17:58 <fendor_> :t show (typeOf (error "hello"))
11:17:59 <lambdabot> error:
11:17:59 <lambdabot>     • No instance for (Typeable a0) arising from a use of ‘typeOf’
11:17:59 <lambdabot>     • In the first argument of ‘show’, namely
11:18:08 <fendor_> show (typeOf (error "hello"))
11:18:11 <fendor_> > show (typeOf (error "hello"))
11:18:14 <lambdabot>  error:
11:18:14 <lambdabot>      • No instance for (Typeable a0) arising from a use of ‘typeOf’
11:18:14 <lambdabot>      • In the first argument of ‘show’, namely
11:18:42 <jle`> as an exception, it is of type IOErrorType
11:18:49 <jle`> more specifically userErrorType :: IOErrorType
11:18:52 <portnov> @pl (\(_,y) (_,x) ->  compare x y)
11:18:52 <lambdabot> (. snd) . flip compare . snd
11:18:56 <jle`> but remember, exceptions only live in IO
11:19:16 <jle`> `error "hello"` is *not* an exception
11:19:30 <jle`> it's a value of type `a` for any `a` you choose
11:19:38 <jle`> :t [error "hello"] :: [Int]
11:19:38 <MarcelineVQ> portnov: compare `on` snd
11:19:39 <lambdabot> [Int]
11:19:45 <lyxia> MarcelineVQ: for a different example, generic-random derives random generators, and require you to provide weights for all constructors.
11:20:12 <portnov> MarcelineVQ: yeah, i know, thanks :) Just wondered how lambdabot would write it :)
11:20:31 <fendor_> jle`, thank you! it is thrown somewhere in IO, so, that's fine :)
11:20:49 <jle`> yeah, just saying that to explain why the lambdabot code isn't working as expected :)
11:21:20 <jle`> fendor_: to check against it you'd use isUserErrorType :: IOErrorType -> Bool
11:21:37 <jle`> but admittedly you shouldn't really be checking against error in production code
11:21:44 <fendor_> wait, is ErrorCall the same as IOErrorType?
11:21:59 <fendor_> so, it is ok to catch ErrorCall, right?
11:22:11 <jle`> oh actually hm
11:22:54 <jle`> wait let me make sure i had this right
11:23:42 <fendor_> no hurry.
11:23:53 <jle`> actually yes, it is ErrorCall :) not sure where i mixed things up, hm
11:24:40 <jle`> i might have been mixing it up with something else.
11:25:13 <fendor_> maybe IOError? 
11:25:23 <fendor_> however, it is safe to catch that kind of errors, right?
11:25:48 <MarcelineVQ> lyxia: that's pretty cool, a type enforced data schema, I've done that in idris but not haskell
11:26:01 <jle`> fendor_: 'safe' in what sense?
11:26:14 <MarcelineVQ> Well not more than the average person does in haskell at least
11:26:17 <jle`> you can use it with the exceptions mechanisms and catch errors of type ErrorCall
11:26:36 <jle`> but 'error' is tricky because it's not explicitly thrown in IO
11:26:39 <fendor_> well, nothing special about it, such as SomeException?
11:26:50 <jle`> rather it's exception that pops up in the case of *evaluation*, not in the case of IO
11:26:51 <fendor_> it is what I expect and not a whole family of errors?
11:27:19 <jle`> fendor_: yeah, ErrorCall is a specific error that only comes from 'error', not anything else.
11:27:34 <fendor_> ok, so, I can catch it and nothing catches fire, right? 
11:27:39 <jle`> but the tricky thing about 'error' is that it's an evaluation-triggered exception, which makes it unpredictable or unreliable to use
11:28:08 <jle`> most other exceptions (file not found, etc.) are triggered by IO actions, but error and undefined are triggered via evaluation
11:28:20 <jle`> so you might get false negatives
11:28:47 <jle`> er, i mean
11:28:58 <jle`> the error might be thrown at a different time then when you try to 'catch' it
11:29:17 <jle`> your IO action to catch it might not pop the 'error' due to laziness, but later on your value might be evaluated by something else, and then the error is thrown at that later time
11:30:52 <jle`> for example, something like `catch (pure x) myHandler` might not trigger the error if x is `[1,2,undefined]`, but later on you might evaluate more of x and then cause the error.
11:31:01 <fendor_> well, that is bad luck then. Trying my best to catch it though. I guess, i'd have to evaluate right? 
11:31:15 <jle`> your best bet would be to evaluate to normal form, using something like deepseq
11:31:16 <fendor_> i think it will be triggered
11:31:28 <jle`> evaluate only evaluates to WHNF
11:31:37 <jle`> so it won't blow up on something like (1:undefined)
11:31:55 <jle`> the main takeaway is that error, undefined, etc. are not "meant" to be used as control flow
11:32:05 <jle`> so they aren't really meant to be used with catch/handle/etc.
11:32:23 <fendor_> i understand, but in this case, the file format for a database is nonsense, so, to give me results, it must actually encounter the problem on its own
11:32:39 <jle`> so while you can catch it, the fact that you are trying to catch it is a red flag that you might have some deeper structural issues
11:32:46 <fendor_> hm, maybe there is a function to actually check that a file is a valid database
11:32:49 <fendor_> in the hoogle api
11:33:07 <jle`> why would you need 'error' for that?
11:33:10 <MarcelineVQ> They're not even good at error reporting, if something outside of IO can fail there's datatypes for that like Maybe and Either
11:33:44 <jle`> yeah, you can use Maybe, Either, or even an actual IO-based exception so that you can deterministically throw them
11:33:48 <fendor_> well, if you use hoogle api `withDatabase` and the database is nonsensical, an ErrorCall is thrown apparently
11:34:08 <fendor_> i dont think i can fix that
11:36:05 <jle`> ah. that's unfortunate. looking at https://github.com/ndmitchell/hoogle/blob/master/src/General/Store.hs#L171 i do see a lot of situations where 'error' is used when an io exception would make more sense
11:36:42 <phadej> yes, one should use `fail` there
11:36:44 <phadej> not an error
11:36:54 <lavalike> :t fail
11:36:55 <lambdabot> Monad m => String -> m a
11:37:01 <jle`> here fail :: String -> IO A
11:37:04 <jle`> * IO a
11:37:10 <MarcelineVQ> odd, neil would know better, that part must be pretty old
11:37:57 <phadej> according to blame, 4 years old
11:38:04 <fendor_> well, I could try to fix that
11:38:19 <jle`> however, it looks like it's using 'error' to create an IO action, so this shoouullldd reliably throw if you use evaluate
11:38:35 <jle`> it's just semantically icky :/
11:39:10 <jle`> i'd use evaluate + deepseq to be as safe as possible, but also recognize that there probably isn't going to be any guarantees in the face of lazy IO
11:39:16 <jle`> *potential lazy IO
11:39:47 <fendor_> in my small tests, it worked to only use try.
11:40:12 <phadej> the main problem, is that it makes you think
11:40:15 <phadej> "what will happen"
11:40:22 <phadej> when using `fail` it,s quite clear what will happen
11:40:29 <phadej> (or throwIO)
11:40:46 <phadej> IMO, that's good enough argument: don't make me think
11:40:46 <fendor_> actually, what happens with fail? 
11:41:04 <phadej> fail = throwIO . userError for IO
11:41:31 <jle`> ah, that must be why i was thinking of userError before :3
11:42:23 <fendor_> maybe ill make a pr for hoogl
11:42:46 <jle`> exceptions in haskell are essentially control flow mechanisms.  so fail "hi" is basically an IO action that says "now, move control to the catcher"
11:42:56 <phadej> it's something, which IMO even hlint should suggest
11:43:11 <phadej> i.e. not use error in do-statements
11:43:13 <jle`> it is an IO action, not some hidden magic semantic value bomb
11:43:19 <jle`> *evaluation bomb
11:43:24 <phadej> jle`: yes, exactly
11:43:55 <jle`> phadej: hah. yes, he must not be dogfooding :p
11:44:24 <phadej> jle`: there aren't such rule; but there could be
11:44:40 <phadej> yet, I don't know what Neil thinks about it :)
11:45:08 <phadej> so I'd ask, first before going to implement it
11:45:30 <jle`> that's true, this could be an intentional choice for some reason.  4 years ago neil was already an established and experienced haskeller
11:45:36 * jle` shrugs
11:46:20 <jle`> fendor_: worth a PR though :)
11:46:38 <fendor_> no, first an issue :D 
11:46:50 <fendor_> not gonna waster my hours on a pr that may never be merged 
11:48:20 <MarcelineVQ> smart :>
11:48:37 <Solonarv> % forceIO = evaluate . force -- turn your error calls into proper exceptions ;)
11:48:37 <yahb> Solonarv: ; <interactive>:82:22: error: Variable not in scope: force :: a -> a1
11:48:43 <Solonarv> % import Control.Deepseq
11:48:43 <yahb> Solonarv: ; <no location info>: error:; Could not find module `Control.Deepseq'; Perhaps you meant Control.DeepSeq (from deepseq-1.4.4.0)
11:48:48 <Solonarv> % import Control.DeepSeq
11:48:48 <yahb> Solonarv: 
11:48:50 <Solonarv> % forceIO = evaluate . force -- turn your error calls into proper exceptions ;)
11:48:50 <yahb> Solonarv: 
11:49:10 <Solonarv> % forceIO [1, 2, undefined] `catch` print
11:49:10 <yahb> Solonarv: ; <interactive>:86:35: error:; * Couldn't match type `()' with `[a]'; Expected type: a0 -> IO [a]; Actual type: a0 -> IO (); * In the second argument of `catch', namely `print'; In the expression: forceIO [1, 2, undefined] `catch` print; In an equation for `it': it = forceIO [1, 2, undefined] `catch` print; * Relevant bindings include it :: IO [a] (bound at <interacti
11:49:27 <dmwit> % httpServer n = print n >> httpServer (n+1)
11:49:27 <yahb> dmwit: 
11:49:31 <Solonarv> % forceIO [1, 2, undefined] `catch` liftA2 (>>) print throwIO
11:49:31 <yahb> Solonarv: ; <interactive>:88:1: error:; * Could not deduce (Exception e0) arising from a use of `catch'; from the context: (NFData a, Num a) bound by the inferred type of it :: (NFData a, Num a) => IO [a] at <interactive>:88:1-59; The type variable `e0' is ambiguous; These potential instances exist:; instance Exception NestedAtomically -- Defined in `Control.Exception.Base'; i
11:49:37 <Solonarv> sigh
11:49:44 <fendor_> close enough
11:49:46 <dmwit> % forceIO (httpServer 0) >> return ()
11:49:46 <yahb> dmwit: ; <interactive>:89:1: error:; * No instance for (NFData (IO b0)) arising from a use of `forceIO'; * In the first argument of `(>>)', namely `forceIO (httpServer 0)'; In the expression: forceIO (httpServer 0) >> return (); In an equation for `it': it = forceIO (httpServer 0) >> return ()
11:49:57 <MarcelineVQ> boo-urns
11:49:58 <Solonarv> % forceIO [1, 2, undefined] `catch` liftA2 (>>) (print @SomeException) throwIO
11:49:58 <yahb> Solonarv: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:90:16 in interactive:Ghci36; *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:90:16 in interactive:Ghci36
11:50:28 <Solonarv> dmwit: use the >>= !
11:50:37 <dmwit> won't help
11:51:16 <dmwit> My point was that IO actions can be both useful and not deepseq-able. Which the "no instance" error made for me too, but less eloquently.
11:51:47 <dmwit> `httpServer 0` is infinitely big as a semantic object. But it's nevertheless usefully executable.
11:52:06 <fendor_> someone minds to proof read the issue? https://hackmd.io/4MZtn1xYQvaJjx7mnkN4GQ
11:53:36 <hpyCdr> can I see Conduit / Pipes basically as C#s IEnumerable or similar? Or are there some differences I don't see?
11:54:29 <monochrom> I think "forceIO" is a poor name for evaluate.force.
11:54:31 <Solonarv> hpyCdr: they're very vaguely similar
11:54:48 <Solonarv> monochrom: yeah, I was too lazy (hah!) to come up with a better one
11:54:50 <monochrom> I would go for "deepEvaluate"
11:57:29 <fendor_> if anyone wants to follow that issue: https://github.com/ndmitchell/hoogle/issues/292
12:13:47 * hackage network-simple-ws 0.1 - Simple interface to WebSockets.  https://hackage.haskell.org/package/network-simple-ws-0.1 (RenzoCarbonara)
12:22:52 <juri_> ok, anyone work with generics enough to give themselves a headache?
12:22:58 <juri_> https://gist.github.com/julialongtin/977daa259472917d5a976a2793f8b463
12:24:28 <juri_> vectorspace is somehow stripping off the wrapper of my newtype, and returning something that is the contents of the type, not wrapped in the type.
12:25:37 <juri_> I think that's about as minimal of a test case as i can come up with.
12:26:28 <Solonarv> I don't see any generics there?
12:26:44 <juri_> they're not there. VectorSpace uses them internally.
12:27:58 <Solonarv> where is VectorSpace from?
12:28:01 <juri_> I'm kindof new at type wrapping... but this feels very broken.
12:28:21 <MarcelineVQ> Solonarv: https://hackage.haskell.org/package/vector-space-0.16/docs/Data-VectorSpace.html
12:28:57 <juri_> Data.VectorSpace. https://hackage.haskell.org/package/vector-space-0.16
12:29:13 <juri_> pretty common library, i think. for matrixy stuff.
12:30:44 <Solonarv> okay, I think I see what's happening
12:31:13 <juri_> you're a scholar, and a gentleperson. what am i doing wrong? :)
12:31:17 <Solonarv> GeneralizedNewtypeDeriving re-uses instances of the wrapped type
12:31:34 <Solonarv> associated types are exactly the same, and methods are 'coerce'd
12:32:44 <juri_> ok, but i can't derive with stock, and i end up missing functions if i use anyclass...
12:34:02 <Solonarv> so the GND instance 'VectorSpace R' ends up looking like this:
12:34:02 <Solonarv> instance VectorSpace R where
12:34:02 <Solonarv>   type Scalar R = Ratio Integer -- copied from the VectorSpace (Ratio a) instance
12:34:02 <Solonarv>   (*^) = coerce ((*^) @(Ratio Integer)) -- re-use the method and simply cast its type
12:34:26 <Solonarv> you should be able to fix this by writing the VectorSpace instance yourself
12:35:10 <juri_> thanks. I'll give it a shot.
12:35:31 <Solonarv> (you can copy the instance I gave there, just change the type synonym to = R)
13:02:15 <juri_> that sortof worked.. got me in the right direction, at least. thanks!
13:21:37 <wolfman154> What is the correct syntax on how to put this in xmonad.hs?     https://superuser.com/questions/635166/when-i-quit-xmonad-how-can-i-make-it-shut-down-applications-nicely#661608
13:24:05 <wolfman154> If someone could paste bin the syntax or send me to the link that shows me how to do this, thanks 
13:24:32 <wolfman154> I can’t find the instructions on how to do this?
13:31:47 <wolfman154> 14:21 wolfman154: What is the correct syntax on how to put this in xmonad.hs?     https://superuser.com/questions/635166/when-i-quit-xmonad-how-can-i-make-it-shut-down-applications-nicely#661608
13:31:59 <wolfman154> 14:23 wolfman154: If someone could paste bin the syntax or send me to the link that shows me how to do this, thanks 
13:32:08 <wolfman154> 14:24 wolfman154: I can’t find the instructions on how to do this?
13:42:54 <ddellacosta> folks using ghcjs in production, do you usually keep whatever ghcjs code you have in an isolate repo from backend haskell code? It seems like you must do that if you don't want to use a GHC branch for all your code?
13:43:31 <ddellacosta> I'm currently trying to understand how I'd integrate ghcjs into a servant app
13:43:45 <ddellacosta> reflex in particular I guess
13:47:20 <ddellacosta> wolfman154: btw have you tried asking in #xmonad?
13:48:46 <dminuoso> ddellacosta: You could just keep some foo-api library that exposes the raw API and have both your ghcjs and the backend app depend on that foo-api package.
13:49:01 <boj> ddellacosta: we typically have a backend, common, and shared setup. common shares servant routes and models, we build the backend with ghc, and build a final artifact with ghcjs for the frontend
13:49:55 <boj> s/and shared/frontend
13:49:57 <dminuoso> ddellacosta: Or you could go one step further, and have some additional foo-client library that itself depends on foo-api and exposes higher level functionalities.
13:50:18 <dminuoso> (And have your foo-server package also depend on foo-api)
13:50:25 <ddellacosta> dminuoso: okay thanks, that makes sense as far as possible options and is helpful
13:50:40 <ddellacosta> boj: concretely speaking are these executables in a single repository?
13:51:02 <ddellacosta> er, or rather, libraries + executables in a single repo
13:51:03 <boj> the code is in a single repo, yes. then our build system spits out the final artifacts
13:51:18 <dminuoso> ddellacosta: Mono repo, git submodules, cabal using git (this is effectively equivalent to git submodules)
13:51:25 <dminuoso> ddellacosta: all three are viable options
13:52:01 <ddellacosta> dminuoso: cabal using git = specifying different libs/exes ?
13:52:31 <ddellacosta> sorry I'm just trying to understand very concretely what this involves
13:52:39 <dminuoso> ddellacosta: Starting from cabal 2.4 I think you can specify a git repository in our cabal.project
13:52:44 <ddellacosta> oh
13:52:51 <ddellacosta> I see
13:54:21 <dminuoso> ddellacosta: It's how we maintain our private dependencies currently. We run a private gitlab server, put our haskell packages up there and then depend on it via cabal.project files that we also put into repos.
13:54:43 <ddellacosta> that's neat
13:54:47 <dminuoso> We achieve modularity between packages without the hassle of running a hackage server.
13:54:59 <ddellacosta> that sounds really nice for development
13:56:44 <dminuoso> ddellacosta: The downside is that you have to pin using commit hashes, so changes require bumps. A mono-repo avoids this, but makes reusing harder. git submodules might actually be even more attractive, but we avoid it for other reasons.
13:57:25 <dminuoso> (Though even with git submodules you'd have to make commits every time your submodules change)
13:58:14 <ddellacosta> dminuoso: are you using nix as part of this?
13:58:21 <boj> we've been doing fine with a monorepo across a large number of projects. the drawback is that as your libraries evovle, you have to be careful about your api design since it can potentially affect a large number of projects
13:59:01 <ddellacosta> boj: I've found managing a monorepo so much easier than the alternative of tens of small projects
13:59:03 <dminuoso> ddellacosta: No, we use cabal new-* instead/
13:59:11 <ddellacosta> dminuoso: ah okay
13:59:19 <boj> ddellacosta: indeed, that is why we chose it
14:00:00 <ddellacosta> alright I have to eat. boj, dminuoso thanks a lot for your help and comments
14:00:03 <boj> ddellacosta: we use nix wrapped around cabal new-*, mostly since Reflex kind of forced us into it (and we were willing)
14:00:15 <ddellacosta> boj: oh man I want to ask you more about that so much...lol
14:00:16 <boj> yep, good luck
14:00:20 <dminuoso> (we also technically use nix the same way)
14:00:24 <boj> ping me any time
14:00:41 <ddellacosta> thank you, I will do that! and I may harass dminuoso as well next time if they don't mind!
14:01:31 <dminuoso> boj: How is nix forced on you, if you dont mind my asking?
14:02:16 <boj> dminuoso: keeping up with reflex in a sane way requires the use of their reflex-platform code
14:02:51 <boj> that is all nix infrastructure, and does too much for us to bother figuring out how to break it out
14:04:05 <dminuoso> boj: Interesting, if reflex uses nix then it presumably also uses v1-* infrastructure. How do you make that play nice with v2-*?
14:04:24 <dminuoso> Can you somehow depend on v1-* packages from a v2-* build?
14:04:31 <boj> dminuoso: that is all magic :)
14:04:39 <dminuoso> :)
14:04:42 <boj> we just run with what they have built in
14:08:26 <boj> oh, i haven't looked at it in awhile. we do actually drop into a nix-shell which pulls in their environment, then do incremental building with cabal new
14:11:22 <dminuoso> boj: Ah so you build reflex with v2-*?
14:11:31 <boj> yeah
14:14:45 <boj> at some point i got it building with GHC, which would be preferable for dev since the build times are so much faster, but ran into some issues with javascript ffi stuff and haven't had time to get back to it
14:15:42 <boj> working on a new project and we're giving obsidian system's "obelisk" project a try, which appears to do everything correctly and give us realtime code reloading
14:16:28 <sicklork1n> sounds nice
14:23:17 * hackage hslogger 1.3.0.0 - Versatile logging framework  https://hackage.haskell.org/package/hslogger-1.3.0.0 (HerbertValerioRiedel)
14:29:57 <wolfman154> How do I paste the code in the first link using the second link,I’m confused? 
14:30:01 <wolfman154> https://superuser.com/questions/635166/when-i-quit-xmonad-how-can-i-make-it-shut-down-applications-nicely#661608
14:31:24 <wolfman154> https://hackage.haskell.org/package/xmonad-contrib-0.13/docs/XMonad-Hooks-ServerMode.html
14:32:27 <wolfman154> Could someone paste bin the correct syntax, thanks!!!
14:34:55 <Tuplanolla> The problem is equivalent to finding the transitive reduction of the graph induced by the sequences, Ariakenom.
14:39:09 <Tuplanolla> The direct formulation keeps the longest subsequences, while the dual formulation keeps the shortest subsequences. The difference is obtainable flipping the arguments of `isSubsequenceOf` in the reference implementation `[xs | xs <- xss, (not . any (\ ys -> xs /= ys && xs `isSubsequenceOf` ys)) xss]`.
14:43:12 <wolfman154> 15:29 wolfman154: How do I paste the code in the first link using the second link,I’m confused? 
14:43:24 <wolfman154> 15:29 wolfman154: https://superuser.com/questions/635166/when-i-quit-xmonad-how-can-i-make-it-shut-down-applications-nicely#661608
14:43:36 <wolfman154> 15:31 wolfman154: https://hackage.haskell.org/package/xmonad-contrib-0.13/docs/XMonad-Hooks-ServerMode.html
14:43:37 <Tuplanolla> This confirms my suspicion that there is a more efficient algorithm, but I just don't know how to construct it yet.
14:43:47 <wolfman154> 15:32 wolfman154: Could someone paste bin the correct syntax, thanks!!!
14:43:47 <boj> wolfman154: spamming y9our question won't get it answered. if someone knows they will speak up
14:44:18 <__monty__> wolfman154: No need to spam. The code on SO goes into a shell script.
14:44:38 <wolfman154> sorry, I need more patience 
14:44:55 <__monty__> wolfman154: And then you change your quit keybinding to run the script before doing whatever else it does.
14:45:55 <wdanilo> Hi! I'm one of the founders of http://luna-lang.org , a data science platform based on a visual and textual programming language, fully written in Haskell. We've been selected by NASA and Singularity University as one of 20 companies worldwide to change the living of 1b people worldwide. 
14:45:59 <wdanilo> And we are hiring <3
14:46:21 <Tuplanolla> Neat.
14:46:34 <lyxia> wdanilo: congrats
14:46:47 <wolfman154> __monty__: I’m trying to figure out how to paste this code in xmonad.hs , but I am not sure about the syntax (I’m a beginner in Haskell and xmonad )?
14:46:48 <wdanilo> I know this community pretty well – I was often here and I love it so much that I would like to ask you, if any of you are interested in compiler engineering, cloud software architecture or data science in purely functional languages? :)
14:47:01 <wdanilo> lyxia: thank you! <3
14:47:21 <__monty__> wolfman154: The code does *not* go into xmonad.hs, it's not haskell code. It's shell.
14:47:28 <boj> wdanilo: that sounds very interesting!
14:48:23 <wdanilo> One more thing here, not to spam to much :) We've just raised a round of $2.5M and we've got amazing distributed team in Krakow, Warsaw, London and San Francisco. Hiring details are here: https://github.com/luna/hiring
14:48:27 <boj> i seem to recall seeing some posts about this last year
14:48:28 <wdanilo> boj: thank you :)
14:48:31 <wolfman154> __monty__:  well I guess I need to figure out how to do this in nixos, time to switch channels
14:48:32 <geekosaur> __monty__, it's supposed to go into the mod-shift-q keybinding
14:49:31 <geekosaur> spawn "for win in $(wmctrl -l | awk '{print $1}'); do; wmctrl -i -c $win; done" >> io exitSuccess
14:49:33 <wdanilo> An interesting note is, that we are compiling to Haskell Core and we plan to contribute to GHC itself, so this is another interesting point in working with us <3
14:49:47 <__monty__> geekosaur: I don't know xmonad. You can just embed scripts? I figured you'd use some command calling functionality.
14:50:09 <__monty__> Very interesting.
14:51:07 <geekosaur> er? see the line I sent with the 'spawn'
14:52:34 <__monty__> geekosaur: I'm not on your level typing speed wise...
14:52:51 <wolfman154> wdanilo: I’m looking for remote work either in freelancing or a position as a junior developer in Haskell, I’m self taught (no degree)and just started a boot camp (free code camp) , are you guys interested in hiring someone like me?
14:56:21 <wdanilo> wolfman154: Remote is completely ok for us, I don't care about degree too much as well, however, we do care about building a small, yet a very strong team. We don't want to grow too much and we put the bar really high (please see the attached github notes). Do not let this discourage you, if you send us a mail, we will always reply and chat :)
14:59:03 <wolfman154> wdanilo: also, maybe I could join one of your open source projects for a couple of weeks, that way you guys can see if I’d be a good fit or not?
15:01:04 <wdanilo> wolfman154: all of our technologies are open source! :) And yes, please write to me describing your fields of interests and we'll try to figure something out! :)
15:08:23 <wolfman154> wdanilo: sounds good, I just started using nixos, so I need to finish installing and configuring everything, I’ll contact you for sure towards the end of this week when I have all the stuff setup.
15:17:38 <dmwit> geekosaur: That won't actually wait for `wmctrl` to finish, will it?
15:17:42 <dmwit> wolfman154: you, too
15:18:32 <dmwit> It's also weird to call `wmctrl` to get a list of windows when that's something xmonad has intimate knowledge of, but I can understand it from a "very little developer time needed" standpoint.
15:19:05 <geekosaur> dmwit, no, but I don't think it'll matter much aside from some visual glitching. Actually waiting has issues, sicne you may have programs running that don't support even the ICCCM protocol so you'd need a timeout or etc
15:19:59 <dmwit> Well if the idea is to shut things down gracefully before exiting, and you don't wait, xmonad could exit and the server will kill the apps in the usual way before `wmctrl` has even started issuing its graceful shutdown notices.
15:20:41 <geekosaur> true. but the best you can do there is toss a threadDelay into it
15:21:00 <geekosaur> unless you want to try to implement a proper session shutdown, which is a lot more involved
15:21:16 <dmwit> I think it would probably be better to work out what `wmctrl -c` does and do that inside xmonad. Wrap it in a timer watchdog if you're worried about it taking a long time, or just have a keybinding that exits without waiting.
15:21:48 <dmwit> (These kind of considerations are why I avoided answering. It seems hard to do even a slightly sensible job of it.)
15:21:52 <geekosaur> killWindow
15:22:12 <wolfman154> Could you guys paste bin so I can see the syntax?
15:22:31 <geekosaur> which already kn ows how to use the ICCCM protocol for programs which advertise it, or just XKillClient if they don't
15:22:40 <dmwit> Oh, cool.
15:22:47 <dmwit> Should be pretty easy, then.
15:24:58 <Hayrom> https://soundcloud.com/hayrullah-coruhlu  
15:27:06 <Bish> lefts x = [a | Left a <- x]
15:27:20 <Bish> can somebody explain that line to me?
15:27:30 <Bish> i don't quite get how that works
15:27:39 <Bish> how do the rights get filtered
15:27:44 <Tuplanolla> @undo lefts x = [a | Left a <- x]
15:27:44 <lambdabot> lefts x = concatMap (\ b -> case b of { Left a -> [a]; _ -> []}) x;
15:27:47 * hackage cassava-streams 0.3.0.4 - io-streams interface for the cassava CSV library.  https://hackage.haskell.org/package/cassava-streams-0.3.0.4 (PeterJones)
15:28:05 <Bish> where is that case coming from? 
15:28:08 <Bish> pattern matching?
15:28:08 <MarcelineVQ> neat, didn't know you could @undo a comprehension
15:28:13 <geekosaur> yes
15:28:15 <jle`> Bish: any Right's in <- get skipped
15:28:28 <jle`> since it doesn't match the pattern
15:28:38 <geekosaur> you can also think of it as a pattern match in a "do expression, where failed matches invoke "fail" which for the list monad produces the empty list
15:28:40 <Bish> by what rule? pattern matching? something in the either type? 
15:28:46 <fosskers> Is anyone else unable to access https://prime.haskell.org?
15:28:49 <geekosaur> and for success you get a single element list with the value
15:28:56 <fosskers> Firefox is complaining about security issues
15:28:58 <jle`> Bish: well, you can think of it from a high level: what else would happen?
15:29:03 <fosskers> In particular, https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail
15:29:05 <Bish> geekosaur: i understand the list part
15:29:18 <Bish> jle`: well i am not asking on how magic this is
15:29:18 <jle`> Bish: if there is a Right in x...what do you think would happen when it's <-'d ?
15:29:22 <Bish> rather that syntax
15:29:39 <geekosaur> Bish, do you know what a list comprehension is?
15:29:43 <geekosaur> this is more or less the point of them
15:29:45 <Bish> yis
15:29:47 <jle`> Bish: that's just "how it is" for list comprehensions
15:29:52 <Bish> but somehow ie expected something like
15:29:54 <jle`> it's literally how it's implemented :)
15:30:09 <jle`> there are rules for the semantics of list comprehensions
15:30:10 <Bish> [a | a::Left <- x]
15:30:17 <Bish> i know that doesnt make sense, since Left is not a type
15:30:34 <Bish> but how is 
15:30:45 <geekosaur> it's a pattern. same as with: f (Left a) = ...; f _ = ...
15:30:52 <Bish> <constructor> a <- [Either a b] telling the list to filter rights
15:30:55 <Bish> not quit egetting that
15:31:31 <jle`> so when you have something like [ y | somepattern <- xs ], each item in xs is being "bound" as somepattern
15:31:32 <LKoen> Bish: maybe start with a simpler list comprehension and then work up to that one
15:31:36 <MarcelineVQ> best to reexamine what lyxia and geekosaur have said above a few times, since they're pretty much nailed it directly
15:31:37 <Bish> case b of { Left a -> [a]; _ -> []} where is this defined?
15:31:39 <jle`> > [ y | y <- [1..10] ]
15:31:42 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
15:31:44 <Bish> thats my question basicially
15:31:46 <geekosaur> maybe it's just the question fo where patterns are usable
15:31:47 <geekosaur> > let Left a = Left 7 in a
15:31:48 <MarcelineVQ> *geekosaur and Tuplanolla
15:31:50 <lambdabot>  7
15:32:21 <jle`> Bish: the case b statement translation is actually not the default interpretation of list comprehensions, it comes from an extension that translates list comprehensions to do notation
15:32:22 <fosskers> Anyone else unable to access https://prime.haskell.org ?
15:32:23 <geekosaur> > let Left a = Right "moo" in a -- throws exception
15:32:25 <lambdabot>  *Exception: <interactive>:3:5-24: Irrefutable pattern failed for pattern Left a
15:32:33 <Tuplanolla> Yes, fosskers.
15:32:38 <Bish> i understand the parts you describe already
15:32:40 <fosskers> Thanks Tuplanolla
15:32:47 <jle`> Bish: what is going on in [ y | y <- [1..10 ] ] is that each number is *matched* into the pattern on the lef thand side of the <-
15:32:47 <Bish> but i don't know where this is coming from case b of { Left a -> [a]; _ -> []}
15:32:51 <geekosaur> "Its certificate expired 6 days ago"
15:32:57 <geekosaur> according to Chrome
15:33:01 <Bish> you're explaining the wrongs things, that might be because i ask the wrong questions
15:33:03 <jle`> Bish: right, i'm saying that the case thing doesn't come from list comprehensions, it comes from do notation syntax
15:33:05 <Bish> but i know lists
15:33:15 <Bish> i also know how x <- works
15:33:22 <Bish> buts that not what confuses me
15:33:23 <geekosaur> Bish, we don't really understand what's confusing you, so everyones hunting around trying to figure it out
15:33:24 <Ariakenom> Tuplanolla: thanks for the update
15:33:36 <Bish> case b of { Left a -> [a]; _ -> []} this is confusing me
15:33:39 <jle`> Bish: the case ... thing is a distraction here, since it isn't what is actually going on with the list comprehension
15:33:49 <jle`> it's unrelated to list comprehensions; it comes from do notation
15:33:51 <Bish> and how a constructor can tell ghc what to do
15:34:16 <jle`> Bish: do you understand [ y + z | (y,z) <- xs ]
15:34:21 <Bish> yes
15:34:23 <jle`> here, a constructor is telling ghc "what to do" -- the (,) constructor
15:34:48 <jle`> this is saying: look at every item in xs, and *try* to match it with the pattern (y,z)
15:34:52 <jle`> if the match fails, then skip
15:34:58 <jle`> otherwise, bind the first field to y, the second field to z
15:34:59 <geekosaur> Bish, it's just a pattern. what's actually happening is what I said earlier: it's converted to do notation, in which a failed pattern match as part of a (pattern <- ...) becomes "fail", which produces an empty list
15:35:14 <dmwit> wolfman154: Something like this, I guess. It compiles, but I haven't tested it, so buyer beware. https://gist.github.com/dmwit/2a24ab10d8ef274669fec54399defe33
15:35:17 <geekosaur> that's just how do notation works with patterns that can fail
15:35:35 <jle`> Bish: the constructor isn't telling ghc what to do, the *pattern* is
15:35:47 <Bish> so do notations fails if the pattern does not apply? but how would you do tha
15:35:56 <geekosaur> @undo do Left a <- xs; pure a
15:35:56 <lambdabot> xs >>= \ b -> case b of { Left a -> pure a; _ -> fail ""}
15:35:57 <Bish> if in a list for example, you know the type, how can you "fail"
15:36:09 <jle`> Bish: for lists, fail = skip
15:36:16 <Bish> so that case REALLY comes from do notation
15:36:28 <jle`> right. the case only comes from do notation, which isn't the standard interpretation of list comprehensions
15:36:34 <jle`> but the case comes from the rules of desugaring do notation
15:36:48 <Bish> yeah but you wont have those cases when not having either or something similiar right?
15:37:05 <Bish> the (x,y) <- [...] example, how can that fail?
15:37:05 <jle`> the translation is pretty mechanical
15:37:20 <jle`> Bish: that one can't fail because the type has only one constructor
15:37:27 <jle`> but if there is more than one, it can fail
15:37:28 <Bish> ah, yes thats what i meant
15:37:48 <Bish> so this is  a play between constructors and do notation
15:38:01 <jle`> yeah, it's a part of the do notation desugaring rules
15:38:10 <Bish> great, thanks i goti t
15:38:13 <jle`> if you have a pattern match, it desugars to case .. of ...
15:38:24 <jle`> but also, list notations aren't necessarily implemented in terms of do notation
15:38:41 <jle`> so it's possible to just understand the semantics of list comprehensions without resorting to do notation
15:38:52 <geekosaur> that seems to vary by ghc version, possibly because of different ideas of how to implement MonadComprehensions
15:38:56 <dmwit> The Report *also* specifies pattern matches to appear as the result of list comprehension desugaring.
15:39:10 <jle`> Bish: here is the rules of the semantics of list comprehensions:
15:39:12 <jle`> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11
15:39:12 <Bish> that sugar really confused me
15:39:13 <dmwit> So this claim that what's really happening is monads is... not really right?
15:39:21 <Bish> but i guess it's fair calling this pattern matching
15:39:29 <Bish> but that this already filters is confusing..
15:39:43 <jle`> Bish: the table there explains what the rules are for list comprehensions, without resorting to case ... stuff
15:39:48 <jle`> Bish: well, what else do you think would happen?
15:40:01 <Bish> well the type dicates otherwise, but Maybe?
15:40:04 <dmwit> No, it uses `case` stuff. It just hides it in a let and names the pattern match construct `ok` instead of `case`.
15:40:31 <jle`> i think one confusing thing here is that you might be seeing a pattern like `y <-` differently than a pattern like `Left y <-`
15:40:33 <Bish> [Left 1,Left 1, Right 2] ⇒ [Just 1,Just 1,Nothing]
15:40:41 <jle`> syntactically, they are all the same
15:40:46 <Bish> thats what i would've expected from the function if i didn't see its signature
15:40:52 <jle`> anywhere you can use `y` as a pattern, you can use `Left y` as a pattern
15:41:00 <jle`> (providing the types match)
15:41:27 <jle`> Bish: right, the types guide the answer here :)
15:41:44 <Bish> yeah, but it's convention rather than logic, wouldn't you agree?
15:42:01 <jle`> how could it be convention?
15:42:02 <Bish> all other things i saw in haskell so far make more sense in a logic way
15:42:02 <dmwit> Yes, it is based on a rich history of writing this kind of things in set comprehensions in math.
15:42:20 <dmwit> It is a strong convention that did not originate with Haskell.
15:43:05 <Bish> are you talking about { x | x ∈  Y}?
15:43:07 <jle`> to me really it's a "what other way could it be?" sort of thing; Maybe isn't really an option, because it doesn't make sense (type-wise)
15:43:25 <dmwit> Bish: Yes, that is a set comprehension. But there are more complicated ones.
15:43:25 <jle`> the logical behavior to me would be to just throw away the failed matches
15:43:34 <Bish> jle`: well, it could not work, for example
15:43:43 <jle`> you mean, it could not compile?
15:43:48 <Bish> yes
15:43:57 <dmwit> Bish: Like { x | x \in Y, x odd } or { x | inl x \in Y }
15:44:25 <Bish> yes but those usually not filter
15:44:28 <jle`> Bish: that'd be weird, because all patterns are supposed to be syntactically interchangeable
15:44:32 <Bish> this implicit case feels like
15:44:33 <dmwit> Bish: The latter filters.
15:44:41 <jle`> so all of a sudden using `Left x` instead of `x` would cause a compile error, based on...syntax?
15:44:54 <dmwit> Bish: Things that are inr's instead of inl's wouldn't be included in the resulting set.
15:45:10 <dmwit> Bish: (The former filters, too, but more explicitly: those x's that are not odd are not included in the resulting set.)
15:45:15 <Bish> whats inl, though?
15:45:26 <dmwit> It is the canonical injection from X to X+Y.
15:45:53 <jle`> (basically, Left)
15:46:03 <dmwit> For the sake of avoiding name clashes, let's say it is the canonical injection from A to A+B.
15:46:18 <Bish> but this feels like {x | x ∈  Y, x ∈  ℝ } in one statemnet
15:46:42 <dmwit> Mathematicians do that all the time, too.
15:46:44 <Bish> it's a) out of Y and b) of type XYZ
15:46:49 <dmwit> { x | x \in Y \cap R }
15:47:00 <Bish> yeah but you dont have types there
15:47:16 <MarcelineVQ> the heck, the shorthand for that is cap? :X
15:47:34 <dmwit> I would claim that most mathematicians have a strong static type system in their heads when they read math, even if they don't explicitly represent it on the page.
15:47:47 <Bish> yeah sure, but still you get my point?
15:47:50 <Bish> even if you dont agree
15:47:52 <dmwit> Not really, no.
15:47:53 <jle`> Bish: but yeah, in case it wasn't clear, to answer your original question, this works on things other than Either; it works on all patterns :)
15:48:13 <Bish> yeah, the "multiple constructor thingie" brought be to understand
15:48:16 <jle`> > [ y | y:_ <- [[1,2,3],[],[2,3],[5]] ]
15:48:19 <lambdabot>  [1,2,5]
15:48:35 <jle`> Bish: in the actual desugaring, the "multiple constructors" doesn't actually come into play
15:48:55 <Bish> how so?
15:48:57 <dmwit> ...yes it does
15:49:02 <jle`> [ z | y <- xs ] is desugard as:
15:49:13 <wolfman154> Thanks guys I’m going to take a break for a while 
15:49:34 <Bish> wow, this is the dirtiest thing i saw in haskell so far
15:49:43 <geekosaur> I thought it was refutable vs. irrefutable patterns, not multiple constructors as such
15:49:44 <Bish> a:[] = [] dies when a is accessed?
15:49:51 <Bish> but on a list comprehension it works?
15:50:08 <geekosaur> Bish, depends on whether the pattern is in a strict or lazy context
15:50:28 <Bish> how does jle example make it strict?
15:50:28 <dmwit> I think both of the things he said are correct for both strict and lazy contexts.
15:50:30 <geekosaur> and you can force a strict context to be lazy with the ~ operator
15:50:30 <Bish> since mine is lazy?
15:51:03 <Bish> well jle` example doesnt die, shouldn't it?
15:51:12 <dmwit> "should" is hard.
15:51:18 <dmwit> The behavior you're seeing there matches the spec.
15:51:34 <Bish> well, it should because a:[] = [] does
15:51:40 <Bish> it's confusing atleast
15:51:45 * dmwit isn't confused
15:51:57 <dmwit> In fact, I frequently use this feature. It's quite useful.
15:51:58 <jle`> Bish: think of the desugaring as this: `let foo (y:_) = [y]; foo _ = [] in concatMap foo [[1,2,3],[],[2,3],[5]]`
15:52:37 <Bish> so it's very similiar to the either thing
15:52:43 <jle`> [ z | y <- xs ] is desugard as `let go y = [z]; go _ = [] in concatMap go xs`
15:53:00 <jle`> and this is desugared the same way, regardless of how many constructors the type of y has
15:53:02 <Bish> what do i need to have to see this desugaring?
15:53:16 <jle`> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11
15:53:18 <jle`> :)
15:53:38 <Bish> well like @undo does i mean
15:54:03 <geekosaur> the report defines it. if you want to see ghc doing it, there's -ddump-ds to see how things are desugared, but be warned that there will be a lot of output because a lot of surface Haskell is sugar over more fundamental constructs
15:54:35 <dmwit> For example, here is some code I've written that uses almost exactly jle`'s example: http://hackage.haskell.org/package/universe-base-1.1/docs/src/Data.Universe.Helpers.html#diagonals
15:54:39 <Bish> @undo [ a | a:_ <- [[1],[],[2,3]]]
15:54:39 <lambdabot> concatMap (\ b -> case b of { a : _ -> [a]; _ -> []}) [[1], [], [2, 3]]
15:54:47 * hackage themoviedb 1.1.5.1 - Haskell API bindings for http://themoviedb.org  https://hackage.haskell.org/package/themoviedb-1.1.5.1 (PeterJones)
15:54:53 <jle`> oh hey that's cute that that's pretty much what i wrote
15:55:02 <jle`> i'm pleasantly surprised?
15:55:05 <MarcelineVQ> Also the very first response on the original query :>
15:55:41 <Bish> dmwit: but thats not as pretty as what the bot does
15:56:01 <jle`> ah yeah, it's the same thing, isn't it
15:56:12 <Tuplanolla> Say more with fewer words.
15:56:14 <jle`> i guess the difference is that i was sneaky and hid it behind a multi-line function
15:56:14 <dmwit> Bish: What do you mean? What is not as pretty as what?
15:56:24 <Bish> -ddump-ds
15:56:31 <Bish> and what that bot does
15:56:41 <geekosaur> no, ghc debug output isn't generally pretty
15:56:58 <geekosaur> the -d option is debug output of various kinds, it's not intended to be pretty
15:57:09 <geekosaur> it's intended to show what the guts of ghc are doing
15:57:12 <dmwit> ...why does the prettiness of -ddump-ds matter to you?
15:57:13 <Bish> so how can i get that @undo in my shell?
15:57:29 <Clint> Bish: apt install lambdabot
15:57:31 <Bish> well, i don't find that case inside there
15:57:32 <Tuplanolla> Some parts of lambdabot are available as separate programs too.
15:57:32 <geekosaur> you can install lambdabot locally, or maybe someone has created a standalone version
15:57:53 <dmwit> (and why did you address your first comment about ddump-ds to me? and why did you think I would know you were talking about ddump-ds?)
15:58:41 <Bish> dmwit: i thought you suggested it, sorry if not
15:58:58 <Bish> it was geekosaur 
16:00:03 <Bish> well, i guess haskell will never fail to let me something read that i don't get AT ALL
16:00:05 <dmwit> Anyway, when I desugar `main = print [y | y:_ <- ...]`, I do see the case, though it uses different names.
16:00:40 <dmwit> `ds_d1xB = \ (ds_d1xC :: [[Integer]]) -> case ds_d1xC of { [] -> GHC.Types.[] @ Integer; : ds_d1xD ds_d1xE -> ...}` <- right here
16:01:04 <Bish> well but the clusterfuck makes it hard
16:01:44 <dmwit> But who cares? It's for internal consumption only. You don't ever need to see that code. You get to see the pretty list comprehension syntax instead.
16:01:58 <Bish> i never said i do care
16:02:14 <Bish> i just say -dump-whatever-lambdabot is doing was pretty useful too
16:02:16 <dmwit> It's like complaining that `"Hello, world!"` is a bad idea because the desugaring to `'H':'e':'l':'l':'o':' ':...` is hard to read.
16:02:36 <Bish> ... i never complained
16:02:47 * hackage http-media 0.8.0.0 - Processing HTTP Content-Type and Accept headers  https://hackage.haskell.org/package/http-media-0.8.0.0 (TimothyJones)
16:03:18 * dmwit squints
16:03:26 <dmwit> Okay.
16:03:36 <MarcelineVQ> -dsuppress-all tidies up the desugarer quite a lot
16:03:47 * hackage purescript 0.12.5 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.12.5 (hdgarrood)
16:03:57 <Bish> i said i want @undo, someone said "jus tuse -ddump-ds" and i said that's not as useful
16:04:10 <Bish> where do you see complaint about what -ddump-does inside ther
16:04:45 <MarcelineVQ> where do you see someone saying "jus tuse -ddump-ds"
16:05:24 <Bish> the report defines it. if you want to see ghc doing it, there's -ddump-ds to see how things are desugared, but be warned that there will be a lot of output because a lot of surface Haskell is sugar over more fundamental constructs
16:06:13 <geekosaur> MarcelineVQ, they're quoting something I sent
16:06:15 <MarcelineVQ> That reads as a helpful suggestion to me, certainly not an order to avoid @undo.
16:06:42 <Bish> i never said someone ordered me to avoid @undo
16:06:47 <Bish> hell you guys are complicated
16:06:53 <Tuplanolla> I also like to fight over misunderstandings.
16:07:21 <Bish> Tuplanolla: ikr
16:07:26 <Tuplanolla> @hackage lambdabot-haskell-plugins
16:07:26 <lambdabot> http://hackage.haskell.org/package/lambdabot-haskell-plugins
16:07:37 <Tuplanolla> Look there for the do-undo mechanism.
16:07:48 <Bish> Tuplanolla: thanks
16:07:56 <Bish> and thanks @rest you really helped me alot with that mystery
16:08:02 <geekosaur> and I did warn that it's noisy.
16:08:11 <Bish> i am going to head to bed now
16:08:20 <Bish> geekosaur: yes, and i asked for @undo
16:08:24 <Bish> geez
16:08:29 <MarcelineVQ> Huh, maybe "just do x" means something else where I'm from.
16:09:09 * geekosaur was focused on typing when you sent that, was responding to [15 22:52:40] <Bish> what do i need to have to see this desugaring?
16:10:09 <Bish> anyways, thanks alot guys
16:10:45 <Bish> summary is pattern matching in list comprehensions ⇒ drop everything that isn't matching
16:11:09 <geekosaur> and as I said somewhere near the start of this, that' part of the point of list comprehensions
16:11:33 <geekosaur> they're a compact way to filter and operate on elements of a list
16:11:35 <Bish> well some things you need to find out yurself to fully grasp them
16:11:44 <Bish> atleast that's true for me
16:14:49 <Bish> gn everyone
16:17:37 <jle`> Bish: have a good night :)
16:22:17 * hackage byline 0.3.2.1 - Library for creating command-line interfaces (colors, menus, etc.)  https://hackage.haskell.org/package/byline-0.3.2.1 (PeterJones)
16:45:34 <shapr> man oh man
16:45:38 <shapr> it's a lovely day for code
16:58:47 * hackage themoviedb 1.1.5.2 - Haskell API bindings for http://themoviedb.org  https://hackage.haskell.org/package/themoviedb-1.1.5.2 (PeterJones)
17:05:50 <random11993> Hi! I'm looking for some help to understand what is going on with my code: https://pastebin.com/GQYBDNXU
17:06:22 <random11993> I'm using user-defined data types, and when I try to use them in a list by comprehension (using patttern matching) I get an error
17:07:38 <lyxia> random11993: you need to spell out the constructor:   Estudiante' n ci a2 _ <- e
17:08:02 <kadoban> random11993: A better paste bin would be appreciated next time. gist.github.com isn't terrible.
17:11:46 <random11993> oh thanks I didn't notice that, so every time I use pattern matching with a user-defined type I need to specify the constructor right?
17:12:06 <Solonarv> it doesn't matter where the type comes from
17:12:09 <random11993> @kadoban pastebin is too bad?
17:12:09 <lambdabot> Unknown command, try @list
17:12:25 <random11993> kadoban pastebin is too bad?
17:12:40 <kadoban> random11993: Just look at it. That syntax highlighting ... how can you even read it?
17:13:00 <Solonarv> it's also bloated with ads
17:13:25 <random11993> Ok I understand, next time I'll use gist
18:27:22 <maerwald> github is proprietary, not sure that is much better :)
18:28:17 <Solonarv> it's certainly better than pastebin in terms of features and UI
18:29:15 <geekosaur> and relative lack of obnoxiousness
18:29:18 <whitebrick> Hi there! I'm trying to understand why `WatEq` type checks but `WatBroken` doesn't http://dpaste.com/0110ZSM
18:29:31 <whitebrick> (oops forgot to mention I have -XGADTs on)
18:31:05 <glguy> Make sure you include the error message when asking about error messages
18:36:24 <whitebrick> oops, good call glguy. See http://dpaste.com/2CN7DWR
18:40:33 <Solonarv> whitebrick: the WatBroken constructor hides an existential
18:40:59 <Solonarv> this is clearer if you rewrite that constructor as: WatBroken :: forall x. Wat x -> Wat x -> Wat Bool
18:42:01 <Solonarv> the derived Eq instance contains code that looks roughly like this:
18:42:01 <Solonarv> WatBroken a1 b1 == WatBroken a2 b2 = a1 == a2 && b1 == b2
18:42:26 <Solonarv> but a1/a2 and b1/b2 don't have the same type, and there's no way to check if they do
18:42:37 <Solonarv> so they can't be compared using ==
18:43:00 <whitebrick> aah, that makes a lot of sense
19:09:01 <dmwit> whitebrick: If you want to be able to check for equality anyway, you can store a `TypeRep a` in there and use `TestEquality` to check them for equality before proceeding with the field equality checks.
19:09:54 <whitebrick> dmwit: thanks for the pointer! Changing the types drew out some other problems that I'm trying to figure out now
19:10:18 <dmwit> (The standard trick for storing a `TypeRep a` conveniently would look like `Wat :: Typeable a => Wat a -> Wat a -> Wat Bool`.)
19:15:30 <jusss> what is (.) ?
19:15:55 <eiGHttt> :% t (.)
19:16:05 <Solonarv> :t (.)
19:16:07 <eiGHttt> % :t (.)
19:16:07 <yahb> eiGHttt: (b -> c) -> (a -> b) -> a -> c
19:16:07 <lambdabot> (b -> c) -> (a -> b) -> a -> c
19:16:16 <Solonarv> jusss: the function composition operator
19:16:31 <Solonarv> defined as follows: f . g = \x -> f (g x)
19:16:43 <Solonarv> or, alternatively: (f . g) x = f (g x)
19:16:56 <jusss> Solonarv: and this (.) is a instance of a functor?
19:17:11 <Solonarv> no
19:17:27 <Solonarv> it's not even the correct kind of thing to be an instance of Functo
19:18:20 <Solonarv> (.) is a function, but Functor instances have to be types!
19:19:02 <Solonarv> however, ((->) e) has a Functor instance, and the definition of 'fmap' in that instance is identical to (.)
19:20:01 <jusss> err...
19:21:17 <Solonarv> this can be a bit confusing to understand initially, so if there's somehting you don't understand, ask away!
19:21:45 <jusss> (->) e  is a Functor, I can understand, 
19:22:15 <jusss> fmap is (.) I don't
19:22:30 <Solonarv> okay, let's look at the tyes
19:24:12 <Solonarv> for the 'Functor ((->) e)' instance, we have to define:
19:24:12 <Solonarv> fmap :: (a -> b) -> ((->) e a) -> ((->) e b)
19:24:12 <Solonarv> we can also write this type as
19:24:12 <Solonarv> fmap :: (a -> b) -> (e -> a) -> (e -> b)
19:24:12 <Solonarv> which looks suspiciously like the type of (.) !
19:24:53 <Solonarv> in fact, it's the same type - just with the type variables renamed, which doesn't matter
19:25:14 <jusss> and?
19:26:41 <Solonarv> additionally, there is only one way to write a function of that type!
19:26:49 <Solonarv> (not counting 'undefined' and similar shenanigans)
19:28:55 <Solonarv> another approach: there is at most one lawful implementation of fmap for any Functor; so if we have two lawful fmap implementations for the same Functor we know they must be the same
19:29:22 <Solonarv> there is only one law we need to worry about, and it is very simple: fmap id = id
19:29:28 <Squarism> if you want to use turtle (that seems to use stack) is there some way to get a "global" install and not in every directory you execute your scripts in?
19:30:05 <Solonarv> Squarism: you can add a a #!/bin/env stack shebang to the top of the script file
19:30:58 <Solonarv> and a comment like the following: -- stack --resolver lts-13.16 --package turtle script
19:31:02 <Solonarv> at the start of the file
19:32:21 <MarcelineVQ> turtle doesn't have a particular dependency on stack, if it matters
19:33:33 <Squarism> Solonarv, ok ill try that
19:33:52 <MarcelineVQ> Or, huh, I thought it didn't but the tutorial seems to go that direction
19:34:40 <Solonarv> jusss: so, let's try to see if this law holds for (.)
19:34:40 <Solonarv> (.) id     ?= id
19:34:40 <Solonarv> (.) id f   ?= id f   -- eta expand (add an argument on both sides)
19:34:40 <Solonarv> (.) id f x ?= id f x -- again
19:34:40 <Solonarv> id (f x)   ?= id f x -- definition of (.)
19:34:41 <Solonarv>     f x    ?=    f x -- definition of id (twice)
19:34:42 <Solonarv>     f       =    f   -- eta reduce, we're done!
20:06:44 <whitebrick> dmwit: is that something the compiler can do while deriving? I can't seem to get it to wor
20:07:31 <dmwit> No, you have to write the instance yourself.
20:08:22 <whitebrick> Solonarv: I think I'm still missing something. I understand why WatBroken (no existential) fails, but how does adding the existential convince the compiler it's okay?
20:08:40 <whitebrick> how does that guarantee that a1 and b1 will be the same type?
20:08:45 <whitebrick> dmwit: okay that's what I figured, thanks!
20:08:59 <Solonarv> what you've written is already an existential
20:09:03 <dmwit> I challenge your claim that adding an existential makes it okay.
20:09:14 <Solonarv> I simply renamed the type variable and added an explicit forall to make it clearer
20:09:39 <whitebrick> err sorry, maybe I don't understand what an existential is then
20:11:02 <Solonarv> a simpler example:
20:11:02 <Solonarv> data Sneaky where
20:11:02 <Solonarv>   Sneak :: Maybe x -> Sneaky
20:11:34 <whitebrick> ok
20:11:46 <Solonarv> or, more explicit but otherwise identical:
20:11:46 <Solonarv> % data Sneaky where Sneak :: forall x. Maybe x -> Sneaky
20:11:46 <yahb> Solonarv: 
20:11:50 <whitebrick> here we would lose information about the type of `x`?
20:11:57 <Solonarv> yes
20:12:30 <Solonarv> and since we don't pack a Typeable constraint or anything of the sort into the constructor, we can't recover any information about the type
20:13:32 <Solonarv> this is called an 'existential' because it's equivalent to the following pseudo-Haskell definition: data Sneaky where Sneak :: (exists x. Maybe x) -> Sneaky
20:18:19 <whitebrick> okay, so we know there's some type in Sneaky - we just don't know what it is?
20:18:27 <whitebrick> by adding Typeable that information is kept around at runtime?
20:19:16 <Solonarv> aye
20:20:07 <whitebrick> so in my example, with WatEq we know what type the constructor must be (Wat a -> Wat a) since the return type has the type? Therefore it's captured?
20:20:17 <Solonarv> there are other ways to keep some info about the type; we just have to encode that info as a typeclass dictionary and/or something vaguely GADT-ish
20:20:27 <Solonarv> yup, the first constructor doesn't involve any existentials
20:20:28 <whitebrick> but when we return Wat Bool we lose information about that those constructor types?
20:20:34 <Solonarv> pretty much
20:20:38 <whitebrick> okay, I think that makes sense
20:21:54 <whitebrick> okay cool. Right, so I don't think having WatEq :: Wat a -> Wat a -> Wat a is going to work for me. I really do want WatEq to perform an equality comparison and return a Bool
20:22:03 <whitebrick> and I guess that's what dmwit was getting at above
20:22:29 <Solonarv> constructors never perform any work
20:22:56 <whitebrick> ah but the `eval` function that pattern matches on them does?
20:23:30 <whitebrick> (sorry hypothetical eval function, it wasn't in my paste above)
20:24:24 <Solonarv> yes, that function might actally do work
20:25:44 <whitebrick> okay, I think this is enough for me to chew on for a bit. Thank you all for your help!
20:56:09 <jusss> Solonarv: sorry to being late reply, I just check :t(.) and :t fmap, and I find that when the Functor is (->) a, then fmap is (.),   so fmap f g = f . g ???  when f and g are functions
20:58:36 <Solonarv> jusss: exactly!
21:01:09 <jusss> Solonarv: ok, but I really don't know what is eta reduce and expand, 
21:01:52 <Solonarv> eta expanding/reducing means adding/removing an argument in an equality or a definition
21:02:37 <Solonarv> for example, if we have 'foo x = negate x' we can rewrite that to 'foo = negate' (eta reduce); the opposite transformation is called eta expanding
21:04:17 <jusss> Solonarv: that pintless style use tis eta reduce?
21:04:45 <jusss> this
21:05:34 <Solonarv> well, eta reduction/expansion is only when you have something of the form 'f x = g x', where neither f nor g mention x
21:08:45 <jusss> Solonarv: now, I know that when a Functor is a List, fmap is same as map in other languages, and when a Functor is (->) e, fmap is (.), but what this (.) is used for?
21:09:49 <Solonarv> function composition
21:10:14 <Solonarv> it's true that you could just use fmap instead, but that's often less clear
21:10:37 <jusss> what's this good for ? function composition
21:12:06 <Solonarv> it lets you create functions by putting together smaller functions
21:12:09 <kadoban> jusss: Doing a string of operations on an input. Like perhaps you want to parse a string into a list of numbers, then remove duplicates and then sum them up.
21:13:15 <Solonarv> this could be written as:
21:13:15 <Solonarv> @let doStuff = sum . nub . map read . words
21:13:17 <lambdabot>  Defined.
21:13:21 <Solonarv> :t doStuff
21:13:23 <lambdabot> (Num c, Eq c, Read c) => String -> c
21:14:14 <jusss> but this is same as that a bunch of code which is not use (.)
21:14:45 <jusss> it just makes a good look
21:15:11 <kadoban> jusss: Much of programming is just things that are easier to work with than other things.
21:19:50 <jusss> [] is a instance of Functor List ？
21:20:19 <kadoban> [] is an instance of Functor, yes.
21:20:19 <monochrom> We just say "[] is an instance of Functor".
21:20:34 <monochrom> Or "instance Functor []".
21:22:20 <jusss> %t const
21:22:42 <jusss> % t: const
21:22:42 <yahb> jusss: ; <interactive>:93:1: error: Variable not in scope: t
21:22:51 <jusss> %t: const
21:23:55 <jusss> f = const id,   and f's type is (a->a) -> b -> (a->a)  right?
22:01:53 <eiGHttt> % :t (const id)
22:01:53 <yahb> eiGHttt: b -> a -> a
22:39:06 <jusss> (->) a is a typeclass?
22:40:57 <yushyin> why do you think so?
22:41:14 <jusss> yushyin: then what is a typeclass? 
22:42:00 <jusss> Maybe is  a typeclass also a Functor, right?
22:42:15 <jusss> and type constructor
22:43:44 <yushyin> I don't know any typeclass by the name Maybe but I sure know the typeclass Functor f
22:44:46 <jusss> ok, Maybe is not a typeclass
22:45:18 <yushyin> And Functor Maybe as a possible instance of the Functor f typeclass
22:50:15 <jusss> yushyin: f = const id, how get (const id)::b->a->a
22:53:23 <MarcelineVQ> You were on the right track earlier with your type for "const id" but const has been applied to id, so the first argument has been filled in, which is why it's b -> a -> a and not (a -> a) -> b -> a -> a
22:56:32 <jusss> MarcelineVQ: what 'filled in' means?
23:04:22 <wolfman154> geekosaur: is the syntax on the bottom correct? My goal is to make sure xmonad will shutdown gracefully when I press: mod+shift+q   https://hastebin.com/epafiwigud.rb
23:04:41 <MarcelineVQ> hehe I'm finding it surprisingly difficult to word that differently
23:05:44 <yitz> So ...   if I want to filter even numbers, I can do:  `f x = mod x == 0     filter f list`. Can I somehow inline f?
23:06:51 <MarcelineVQ> jusss: the type of const is, const :: a -> b -> a, what this means is that the function const takes two arguments, a value of some type 'a', a value of some type 'b', and results in a value of the same type 'a'. Does this make sense?
23:07:09 <jusss> MarcelineVQ: yeah
23:09:39 <MarcelineVQ> Let's call the type of id, id :: c -> c, since it doesn't matter what letter we use as long as it's consistent when we use it.
23:10:01 <yitz> Jeez. Trying to do ProjectEuler with Haskell. I'm pretty sure I could do this faster in at least 4 other languages...
23:10:28 <wolfman154> dmwit: so this paste bin link you posted a couple hours ago is to make sure xmonad shuts down applications correctly when I type:(mod+shift+q)
23:10:36 <wolfman154> dmwit: https://gist.github.com/dmwit/2a24ab10d8ef274669fec54399defe33
23:10:47 <wolfman154> dmwit: ?
23:11:19 <dmwit> Yes. Bind a key to `gracefulExit` and be on your way.
23:11:47 <yitz> How ... would I ... go from a list to a set()?
23:11:55 <dmwit> :t Data.Set.fromList
23:11:56 <lambdabot> Ord a => [a] -> S.Set a
23:12:06 <dmwit> ?hoogle [a] -> Set a
23:12:07 <lambdabot> Data.Set elems :: Set a -> [a]
23:12:07 <lambdabot> Data.Set toList :: Set a -> [a]
23:12:07 <lambdabot> Data.Set toAscList :: Set a -> [a]
23:12:10 <MarcelineVQ> when we say "const id" it means we're applying const to id, we're making the first argument of const be id. That means the 'a' of const must become (c -> c) since it's the type of id. Since both of const's 'a' are the same 'a', const's type must then be const :: (c -> c) -> b -> (c -> c)
23:12:18 <dmwit> Yikes, those results are awful.
23:12:20 <yitz> Oooh. OK. I guess there's helpers for all that :D
23:14:02 <wolfman154> dmwit: well how do I do this? Yes. Bind a key to `gracefulExit` and be on your way.
23:14:21 <wolfman154> dmwit: sorry I’m new to xmonad 
23:14:51 <yitz> Would it be unreasonable for me to try and do my own set?
23:15:00 <dmwit> Probably.
23:15:04 <dmwit> Why do you think you need to?
23:15:25 <dmwit> wolfman154: ...what did you try?
23:15:35 <MarcelineVQ> When we say "const id", we've given const its first argument, so it only needs one more argument. This means that (c -> c) -> b -> (c -> c) is no longer the correct type, that's the type of something that takes two arguments, but const has already been given one.
23:15:51 <yitz> I don't need to but I'm trying to solve ProjectEuler and using too many prepackaged stuff feels like cheating or like I'm not learning how to think in Haskell myself
23:15:54 * yitz shrugs
23:15:59 <MarcelineVQ> The type of const when we want to apply to id is const :: (c -> c) -> b -> (c -> c), but "const id" b -> (c -> c)
23:16:18 <dmwit> yitz: I mean, if you want to give it a shot for pedagogy, by all means go for it.
23:16:51 <wolfman154> dmwit: I just paste that code into my xmonad.hs and recompile? Or do I need to do something else as well?
23:16:53 <yitz> I'm still stumped trying to figure out how to derive the factors of a number. Set was just one aspect of that
23:16:54 <dmwit> It just feels like duplicating busywork to me but I already know Haskell pretty well.
23:17:31 <yitz> Probably not worth implementing myself. Learning to use packages is also valuable :)
23:17:31 <dmwit> wolfman154: Paste that code into your xmonad.hs and add a keybinding to `gracefulExit`. Take a look at your other keybindings and guess at how; you'll almost certainly be right.
23:18:44 <MarcelineVQ> Hopefully that's not too much more confusing, but if you understand that const :: a -> b -> a describes a function named const that takes two arguments, and you understand that "const id" is const that has already been given its first argument, the types should make sense if you take your time to piece it together
23:19:11 <jusss> MarcelineVQ: I see, 
23:19:11 <wolfman154> dmwit: I’ll paste bin the link so you can see if it is correct or not, one second 
23:19:18 <MarcelineVQ> dmwit: ever wrote a ghc plugin?
23:19:26 <dmwit> MarcelineVQ: Nope.
23:19:28 <jusss> MarcelineVQ: thanks
23:20:10 <MarcelineVQ> dmwit: nuts :> I'm trying to decide the best way to introduce new syntax, well a keyword really, or something that can act like one.
23:20:24 <dmwit> Oh, I don't think a plugin is very good for that.
23:20:25 <yitz> Boo yeah!! I think I just used a lambda maybe!
23:20:36 <dmwit> You don't get to see anything until after GHC has already done all its parsing and stuff.
23:20:57 <MarcelineVQ> Well the keyword is to active the plugin, I want to be able to tag a function declaration for scrutiny
23:21:17 <dmwit> Perhaps an annotation would be enough? I think plugins have access to the annotations.
23:21:18 <MarcelineVQ> Considering some kind of ANN pragma, but idk if that's at all more appropriate
23:22:12 <yitz> Oh. No. Not a lamba >.> Composed function?   `foo x y = mod x y == 0      filter (foo x) list`
23:22:36 <dmwit> Partial application.
23:23:13 <dmwit> You could make it a lambda if you wanted (`filter (\y -> foo x y) list`) but it would be silly to. =)
23:23:13 <yitz> Partial application. Thanks :) It's nifty. And sorta lambda/closure-ish
23:23:38 <dmwit> Yes, it's very closure-ish. And yes, sort lambda-y too. It has the lambda nature.
23:24:02 <yitz> Ah. OK. That's how lambdas work. I should go back and use a lambda earlier
23:25:21 <MarcelineVQ> dmwit: An ANN is probably best after all, it's not too cryptic a way to specify things upon closer scrutiny
23:27:45 <jusss> MarcelineVQ: const :: a-> b -> a,   can I say const a :: b -> a ?
23:28:47 <jusss> so if id :: a -> a, then const id :: b -> (a -> a) ?
23:29:26 <jusss> can I move the right part of :: to the left part ? 
23:29:55 <jusss> and remove ( ) at anywhere in type signature?
23:30:26 <fr33domlover> In async, if I launch a list of actions and I need to gather the return values, I could traverse waitCatch in IO, or traverse waitCatchSTM and apply atomically to the result. Does it make a difference? (I guess it saves 'atomically' calls?)
23:30:44 <yitz> Bah. My implementation sucks. It's hanging
23:32:14 <dmwit> jusss: No, those are not moves you can make.
23:32:24 <dmwit> jusss: The type language and computation language are completely separate.
23:33:03 <jusss> dmwit: and remove ( ) at anywhere?
23:33:11 <MarcelineVQ> Not in actual code no, types and values are separate. No, -> is right associative so you can only remove ( ) when they would associate right. -> being right associative means that a -> b -> c -> d is a -> (b -> (c -> d))
23:33:20 <dmwit> jusss: For the purposes of removing parentheses: (->) is right-associative.
23:34:10 <dmwit> fr33domlover: Yes, running multiple transactions and running one transaction are significantly different.
23:35:10 <MarcelineVQ> "<jusss> so if id :: a -> a, then const id :: b -> (a -> a) ?" Yes
23:35:23 <dmwit> fr33domlover: If you do whatever-it-is all in one transaction, then all the accesses to shared variables will guaranteed to see a consistent collection of values from them; however multiple transactions will be able to make progress in smaller chunks and so may be faster in some circumstances.
23:35:32 <jusss> I don't understand what is "types and values are separate"
23:36:13 <jusss> MarcelineVQ: but that's I do const a :: b -> a
23:36:36 <dmwit> What is the `a` in `const a`? It doesn't exist.
23:37:24 <MarcelineVQ> It means that Int and 3 live in different namespaces, Int is a type and 3 is a value. 3 doesn't belong to the right of :: and Int doesn't belong to the left.
23:38:04 <fr33domlover> dmwit, in this case each thread has a TMVar (I'm using async package) and I just need to wait for them all to finish
23:38:12 <dmwit> (It doesn't exist. It's not in scope. There's nothing with that name. These are all just different ways of saying the same thing, but maybe one of them will be more understandable to you.)
23:38:29 <dmwit> fr33domlover: Then I think there's no reason to put them all in the same transaction.
23:39:29 <MarcelineVQ> It's unclear what you mean when you say "const a :: b -> a" because we're not sure if you think the 'a' of "const a" is a name for some value or is a type variable.
23:40:04 <jusss`> sorry, my network just broken
23:40:05 <MarcelineVQ> id is a value, that happens to bea function, with the type (a -> a)
23:41:02 <MarcelineVQ> jusss`: https://gist.github.com/MarcelineVQ/850b54be9113015e45d068d21ceb1696
23:41:09 <fr33domlover> dmwit, in such cases though should I default to separate transactions or 1 big transaction?
23:41:39 <dmwit> fr33domlover: Generally, make your transactions as small as you can without sacrificing correctness.
23:41:52 <yushyin> the syntax is not even legal.
23:41:58 <fr33domlover> dmwit, thanks :)
23:42:25 <jusss``> again...
23:42:56 <MarcelineVQ> jusss`: https://gist.github.com/MarcelineVQ/850b54be9113015e45d068d21ceb1696
23:43:06 <yushyin> jusss``: ^
23:43:50 * dmwit is tempted to ?tell jusss``` the link
23:43:59 <MarcelineVQ> yushyin: What isn't legal?
23:44:40 <fr33domlover> dmwit, I suppose in this case I could just use MVar instead? I wonder if that would be even better :p
23:44:49 <yushyin> MarcelineVQ: the thing from jusss`` 'const a :: b -> a' ghc would complain, i guess?
23:45:08 <dmwit> fr33domlover: You could. I suspect it will make very little difference.
23:45:18 <yitz> Aww yis. https://gist.github.com/IsaacG/3b77458480106bc9841ccea8af39bbfe
23:45:23 <MarcelineVQ> oh that's legal, assuming some value identifier 'a' with type a
23:45:25 <jusss``> MarcelineVQ: what if we have knew that const :: a->b->a,  and can we use const a:: b->a ?
23:45:33 <dmwit> fr33domlover: I have heard rumors that in low-contention situations, TMVar is faster than MVar.
23:45:38 <jusss``> not const a:: b-> a at first
23:46:06 <yitz> I figured out a decent way to solve it
23:46:12 <dmwit> fr33domlover: The price being that MVar is single-wakeup (round-robin scheduling) and TMVar is global-wakeup, so in high-contention that can be a high price to pay.
23:48:38 <yushyin> MarcelineVQ: I guess I've never seen such type signature in the wild
23:48:58 <jusss``> and the left part of :: is type language and the right part is computation language?
23:49:03 <MarcelineVQ> jusss``: If you mean the 'a' to all be the same then no, 'a' is a type variable, which means it's standing in for some type. functions (like const) aren't applied to types, they're applied to values. 'a' there isn't a value.
23:49:15 <dmwit> jusss``: Other way. Left is computation, right is type.
23:49:25 <MarcelineVQ> yushyin: It's not a particularly useful one at a glance
23:49:44 <MarcelineVQ> yushyin: your options for 'a' are pretty limited
23:51:55 <dmwit> Void -> a is just as lousy a type as b -> a. Change my mind.
23:52:36 <MarcelineVQ> for now :O
23:53:45 <jusss``> const a :: b -> a,   the 'a' in the left is ?   and in the right is ?
23:54:03 <jusss``> const :: a -> b -> a,   a is a type,
23:57:11 <dmwit> In `const a :: b -> a`, the `a` on the left is just another variable name, exactly like `const`. Except that the Prelude defines a variable named `const` and doesn't define a variable named `a`.
23:58:14 <dmwit> The `a` on the right is a type variable -- a placeholder that says that users of the expression on the left may choose any type they like to put in that spot.
23:58:28 <MarcelineVQ> Consider that const id :: b -> (a -> a) and it is not const id :: b -> id, does this show you a problem in your thinking?
23:59:46 <dmwit> (Yes, Haskell distinguishes between variables and type variables. There is a resemblance in their names, but they are not the same thing despite that.)
