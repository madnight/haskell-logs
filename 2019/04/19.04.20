00:31:23 <Franciman> hi, I have a question about Pipes.Parse I would like to read Json objects from a ByteString producer and here is what I do: https://bpaste.net/show/74b7f859e670
00:33:12 <Franciman> I would expect this code to put stuff into the consumer
00:33:57 <Franciman> when a new json object arrives. Instead it successfully parses the only object in the producer
00:34:11 <Franciman> then continously fails parsing and puts into the consumer an error message
01:04:22 <maerwald> mh, autopep8 is awfully slow
01:04:26 <maerwald> oops, wc
01:05:17 * hackage hablo 1.0.0.0 - A minimalist static blog generator  https://hackage.haskell.org/package/hablo-1.0.0.0 (tissevert)
02:23:45 <fen> hi, still working on this idea... https://pastebin.com/raw/Sn66p5t5
02:26:41 <fen> the idea is to "unfold a state encoding" which can then be unfolded again
02:27:17 <fen> not sure if the UndecidableInstances is the best way to write it...
02:57:42 <fen> % let type S f s a = f s (s -> f a s) -> f a s 
02:57:42 <yahb> fen: ; <interactive>:54:5: error: parse error on input `type'
02:57:48 <fen> % type S f s a = f s (s -> f a s) -> f a s 
02:57:48 <yahb> fen: 
03:17:05 <tb15> Hello, I'm new to Haskell (ish) and trying to install a package. This all may be completely wrong, so please correct me! I'm using stack to try and keep all of my dependencies isolated. I want to install the package bnfc, that says I can: cabal install bnfc. I've tried stack install bnfc, with no luck. I've also tried stack install cabal-install, then cabal install bnfc but I get errors complaining about not being able to find
03:17:05 <tb15>  ghc, plus the stack install cabal-instal feels like it probably is completely wrong. Any help greatly appreciated :) 
03:18:47 * hackage winery 1.1 - A compact, well-typed seralisation format for Haskell values  https://hackage.haskell.org/package/winery-1.1 (FumiakiKinoshita)
03:19:06 <geekosaur> if you use stack to install aprogram, you have to use stack exec to run it
03:20:08 <tb15> so a: stack exec cabal install bnfc ?
03:20:13 <geekosaur> that will not work
03:20:29 <geekosaur> you'll get an error about the package db already being managed
03:20:41 <tb15> yep..
03:20:46 <geekosaur> this is one of the problems with using stack: you must do things *its* way
03:20:59 <tb15> I got that feeling.. 
03:21:26 <tb15> is there a way for me to install this tool, bnfc, with stack? or would i be better abandoning it ?
03:21:39 <geekosaur> you do not have a say in it. you need to use stack exec, and you proabbly need a dummy stack project with a stack.yaml telling it to map the bnfc package into the project
03:22:15 <tb15> ok so i can't just call stack install foo, and have stack update the .yaml?
03:22:37 <geekosaur> ...
03:23:08 <geekosaur> if you install using stack, stack saves it internally and it will be invisible unless specificaly requested by some stack project. it will not be installed globally
03:23:24 <geekosaur> you therefore need a stack project in order to use it, and you must use stack exec within that project
03:24:08 <geekosaur> stack does not install things globally, it always installs to internal locations that are not easily accessible. if the program is standalone enough, you might be able to find and symlink or copy it
03:24:26 <geekosaur> this is not something you can change
03:24:39 <geekosaur> if you wanted "use stack" and :install programs globally", stack says: no.
03:25:19 <tb15> Ok got you, so i have a stack project, i've run stack new myproject simple, then cd myproject, then stack setup. I now have a local (to my project) version of ghc, and a stack.yaml file to play with
03:25:53 <tb15> so next I edit the stack.yaml extra-deps field?
03:26:01 <geekosaur> now you add a dependency to the bnfc package to the stack.yaml, and then stack exec within that project will find bnfc
03:29:00 <tb15> extra-deps:
03:29:00 <tb15> - bnfc-2.8.2
03:29:00 <tb15> ?
03:30:01 <geekosaur> yes
03:30:21 <tb15>  YAML parse exception at line 38, column 1,
03:30:21 <tb15> while parsing a block mapping:
03:30:21 <tb15> did not find expected key
03:30:27 <tb15> i've broken something..
03:30:35 <blahh> After having installed haskell-ide-engine via "stack ./install.hs hie-8.4.4" on Kubuntu 19.04, how do I put it and ghc(i) in my PATH so I can use it with Visual Studio Code and Haskell Language Server?
03:31:46 <tb15> though i have no idea what
03:33:14 <blahh> ~/.local/bin is in my $PATH, but it doesn't contain hie nor ghc
03:34:05 <fen_> https://pastebin.com/85JuryCg
03:34:28 <geekosaur> tb15, pastebin your stack.yaml, it sounds like you have a typo or just bad formatting
03:34:38 <tb15> i had an indentation error with the yaml, copy pasted from the docs
03:34:54 <tb15> that yaml is parsing ok now, so now i stack setup again?
03:35:36 <fen_> class ExtraUnfoldable f g s h where  extraUnfoldr :: (s -> f s a) -> (s -> g s (h a))
03:35:56 <geekosaur> if you'd already done 'stack install bnfc' then 'stack exec -- bnfc ...your parameters here...' should work
03:36:25 <tb15> hey! it works! 
03:36:29 <tb15> just did stack install bnfc
03:36:43 <tb15> fantastic :) cheers! 
03:36:48 <geekosaur> I should note that I don't use stack, so there are some limits to what I can help with
03:38:16 <geekosaur> blahh, if you're using stack, it's not going to be on $PATH. hopefully there's a way to configure vscode to use stack to run them
03:39:06 <geekosaur> hie isn't going to work standalone, it'll need a stack configuration that tells it what packages are available, otherwise stack keeps them hidden
03:39:29 <tb15> @geekosaur
03:39:29 <lambdabot> Unknown command, try @list
03:39:35 <tb15> whoops 
03:39:37 <tb15> Didn't see bnfc-2.8.2 in your package indices.
03:39:37 <tb15> Updating and trying again. 
03:39:44 <tb15> am i not pointing it in the right place?
03:39:47 <blahh> I'm trying "stack install" in ~/haskell-ide-engine ...
03:40:09 <geekosaur> blahh, yes, and that installs in a location internal to stack, it does not install it globally
03:40:20 <geekosaur> stack doesn't *do* "globally"
03:40:37 <geekosaur> you do everything through stack, and it exposes only the things your stack.yaml tells it to
03:41:18 <Mo0O> loop detected
03:41:20 <geekosaur> tb15, I just checked hackage and there's no bnfc package
03:41:51 <geekosaur> oh, it's all uppercase
03:42:02 <tb15> gah
03:42:31 <tb15> is cabal install not. case sensitive?
03:42:40 <geekosaur> haskell packages are not case insensitive
03:43:37 <tb15> but bnfc is all upper case?
03:43:46 <geekosaur> BNFC-2.8.2
03:44:25 <tb15> so, er hackage is case sensitive?
03:45:38 <geekosaur> yes, it is. and at this point has to be because people have created packages whose names differ only in case. but be aware that haskell itself is case sensitive, including in module names (must be initial uppercase, otherwise it doesn't know if foo.bar is bar in module foo or composition of two functions foo and bar)
03:45:47 <geekosaur> so case sensitivity is not going away
03:46:08 <alanz> blahh, you are best off installing via the ./install.hs script, and for e.g. GHC 8.6.4 do "./install.hs hie-8.6.4". See the readme
03:46:18 <Tuplanolla> I wonder if there's an easy way to perform `isSubsequenceOf` and `flip isSubsequenceOf` on the same two lists at the same time.
03:47:08 <Tuplanolla> Besides the obvious `\ xs ys -> (isSubsequenceOf xs ys, isSubsequenceOf ys xs)`.
03:47:12 <tb15> ah ok right, cheers! :) it's all working now!
04:11:48 <Tuplanolla> My solution is quite a mess: http://tuplanolla.no-ip.org/tmp/Sequences.hs
04:33:05 <fen> https://pastebin.com/RJLpaL7K
04:33:31 <fen> cant wrangle the "Compose" properly, but this is the idea anyway... 
04:34:03 <fen> not quite sure about the fundeps either...
04:34:53 <fen> they could help it not be Undeciadable maybe?
04:49:23 <jophish> What is the part of a type to the right of the constraints called? Is it the 'head'?
04:49:35 <RedNifre> Okay, regarding to the type vs newtype discussion yesterday: Looks like Idris doesn't even have newtype.
04:56:02 <yyt16384> Is there a more memory-efficient version of IntMap?
04:57:13 <lavalike> yyt16384: I guess the values' types matter if you're trying to squeeze it
04:58:21 <yyt16384> lavalike: it's IntMap Int
04:58:36 <lavalike> that can probably be squeezed quite a bit :D
04:59:05 <yyt16384> I think most memory is spent on those pointers in the tree structure
04:59:34 <Cale> yyt16384: Possibly you could use an array of some sort, if it's densely packed and doesn't change size much
04:59:49 <Cale> IntMap is *pretty* efficient at what it does though...
05:00:47 <lavalike> yeah the usage is definitely key
05:01:24 <yyt16384> Well the structure is sparse
05:01:54 <yyt16384> about 10^6 keys in 10^12 range
05:02:24 <lavalike> I guess another route is finding an hashmap that has Int specialization in some other package
05:24:51 <yyt16384> Hmm, the ones in the hashtables package is better, but probably not worth converting my code to ST
05:26:46 <yyt16384> I guess I need to change my algorithms
05:36:32 <fen> is there a way to use type families to make a "Compose" which does not need the newtype wrapper?
05:37:27 <fen> basically just want to be able to write ((f :: * -> *) . (g :: * -> *)) in an instance
05:50:01 <AndreasK> There is unpacked-containers, but that only unpacks keys for Map not IntMap by the looks of it.
05:56:11 <fen> here is "dot" at type level, using defunctionalisation
05:56:13 <fen> https://pastebin.com/hUZ8TuSm
05:56:38 <fen> any idea if this can be used to simply write f . g :: * -> * ?
05:57:17 <fen> obviously with something other than (.)
05:57:41 <fen> maybe the f and g need to use TyCon ?
05:58:06 <fen> where is jle` when you need them!
06:05:27 <fen> ill take that as a no
06:39:17 * hackage staversion 0.2.3.1 - What version is the package X in stackage lts-Y.ZZ?  https://hackage.haskell.org/package/staversion-0.2.3.1 (debugito)
06:56:23 <david_lopez> hello, can anyone help me I have a noob question related to ghcid on mac. Is there some sort of setting to force ghcid to print all of the output? Right now it does not print all the errors and it stops after a certain amount of lines depending on the size of the window...
06:57:33 <david_lopez> i tried --no-height-limit but it didn't help
06:58:00 <monochrom> Look for something under "ghcid --help"?
07:08:47 * hackage telega 0.2.4 - Telegram Bot API binding  https://hackage.haskell.org/package/telega-0.2.4 (iokasimovmt)
07:44:07 <simbs38> hello there, im getting some problem with dependencies to run an haskell program, is there someone who can help me?
07:45:37 <Solonarv> simbs38: well, what's the problem?
07:45:59 <simbs38> im trying to get this https://github.com/rwbarton/rw running on my pc
07:46:35 <simbs38> i have downloaded the repository, and i have ran 
07:46:41 <simbs38> ghc Setup.hs
07:46:47 <simbs38> ./Setup configure
07:46:51 <infinite_recursi> I ran 'cabal install Frames'. I get this error 'import of Data.Vinyl is redundant'
07:47:08 <Solonarv> that's a very "ancient" way to install things
07:47:24 <simbs38> how should i do it then?
07:47:44 <simbs38> the problem is that there are a lot of missing dependencies
07:47:58 <Solonarv> pull down the repo and simply 'cabal new-install', as a first attempt
07:48:38 <Solonarv> that should grab all the needed Haskell dependencies, though it won't do anything for non-Haskell dependencies
07:49:02 <infinite_recursi> Let me know by @infinite_recursion if talking to me. Thanks.
07:49:07 <simbs38> cabal: unrecognised command: new-install (try --help)
07:49:22 <simbs38> it shows me this when i ran "cabal new-install"
07:49:24 <Solonarv> simbs38: oh, you have a quite old cabal version then
07:49:54 <Solonarv> which OS are you on?
07:50:04 <simbs38> ubuntu
07:50:15 <simbs38> its 1.24.0.2 cabal-install
07:50:23 <Solonarv> yeah, that's pretty old
07:50:34 <Solonarv> latest stable version is 2.4.1.0 IIRC
07:50:42 <Solonarv> how did you install GHC & cabal ?
07:51:14 <Tuplanolla> Probably via `apt`.
07:51:23 <simbs38> yup, apt
07:51:45 <Solonarv> alright
07:52:09 <Solonarv> I'd recommend grabbing up-to-date versions via
07:52:09 <Solonarv> @where ghcup
07:52:10 <lambdabot> https://github.com/haskell/ghcup
07:52:30 <glguy> We should have that point to: haskell.org/ghcup
07:53:47 <Solonarv> @where+ ghcup https://www.haskell.org/ghcup/
07:53:47 <lambdabot> Done.
07:53:59 <infinite_recursi> Failed to load interface for ‘GHC.TypeNats’ this is the error I face while compiling Frames.Categorical
07:54:19 <infinite_recursi> while installing the library frames
07:54:34 <infinite_recursi> Are my messages reaching you?
07:54:38 <Solonarv> infinite_recursi: they are
07:54:48 <Solonarv> I think you have some mismatched dependencies/package versions
07:55:07 <simbs38> okey, im going to install that and try to test it again, thanks mate :)
07:55:37 <infinite_recursi> I just did cabal install Frames and the dependencies installed automatically.
07:56:33 <infinite_recursi> This is my first 'cabal install xyz' command. I do not have any old versions
07:56:40 <infinite_recursi> of libraries
07:57:56 <Solonarv> hm, can you link the full error message?
07:58:07 <Solonarv> use gist.github.com or something like that
08:01:25 <infinite_recursi> https://gist.github.com/caissalover/13143b1014bfff3c7726e4c1e2d7c853
08:01:39 <infinite_recursi> Let me know if you got it
08:09:45 <Solonarv> ah yes, looks like your GHC is too old
08:10:07 <Solonarv> (and the version range for 'base' on Frames-0.6.1 is wrong)
08:10:17 * hackage rattletrap 6.3.0 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-6.3.0 (fozworth)
08:10:21 <Solonarv> GHC.TypeNats was added in base 4.10, but you have 4.9
08:10:31 <Solonarv> meanwhile Frames-0.6.1 claims to work with base >= 4.8
08:10:47 <Solonarv> solution: get the newest GHC
08:11:01 <Solonarv> if you're on Mac or Linux, I recommend ghcup
08:11:16 <monochrom> Solonarv: I keep forgetting to add "cabal update" when talking to beginners!
08:11:27 <Solonarv> monochrom: I didn't think of it either
08:11:37 <Solonarv> wouldn't have mattered here though
08:12:03 <monochrom> Also, these day they also want us to be politically correct and say one of "v1-update", "v2-update", or "new-update"!
08:12:27 <monochrom> (Honestly I don't know the difference.)
08:13:29 <Solonarv> old-update and (currently) update are aliases for v1-update, which is the old-style update
08:13:29 <Solonarv> new-update and is an alias for v2-update, which uses the cool new nix-style builds
08:13:43 <Solonarv> once 3.0 releases update will become an alias for v2-update instead
08:15:04 <monochrom> I don't understand that. Is there such a thing as "nix-style update"?
08:15:08 <infinite_recursi> is ghcup the command to update ghc?
08:16:34 <Solonarv> infinite_recursi: it's a script/program which can install and manage GHC (and cabal too)
08:17:14 <Solonarv> I haven't used it yet (I'm on windows, which ghcup doesn't support) but I have heard only good things aboutit
08:17:37 <Solonarv> monochrom: yes there is, but I don't recall what exactly the difference is
08:18:04 <Solonarv> if it did exactly the same thing as v1-update there wouldn't be a new version
08:18:45 <monochrom> I am less trusting :)
08:18:46 <Solonarv> "something something append-only" is the best I've got, you could try asking in #hackage (which is less dead than #cabal)
08:19:04 <Solonarv> for commands that don't have a pointless new version, see: init, check
08:19:11 <infinite_recursi> What I don't understand is I installed haskell-platform recently and yet I have ghc 8.0.2 which is released on 11th Jan 2018
08:19:19 <infinite_recursi> *2017
08:19:35 <Solonarv> how did you install it? distro package?
08:20:33 <infinite_recursi> apt
08:20:41 <Solonarv> ah, yeah
08:20:50 <Solonarv> distro packages tend to lag behind a bit
08:21:03 <monochrom> Ubuntu Debian etc are always ridiculously lagging behind.
08:21:26 <Clint> "ridiculously"
08:21:39 <cbarrett> i'm using inline-c-cpp and the flags being passed to the c++ compiler arent what I expect. I've set cxx-options in my .cabal file; I have a cabal.project (a directory up) which sets extra-lib-dirs and extra-include-dirs; my cabal-version is 2.2. Any further suggestions for debugging?
08:21:53 <monochrom> Yes, ridiculously. You have a problem?
08:22:16 <Tuplanolla> I have several. Do you want to solve them for me?
08:22:38 <Clint> monochrom: 6 months ago most of hackage wouldn't build with ghc 8.6
08:23:58 <monochrom> I agree. 8.4 is reasonable, not ridiculous.
08:24:06 <monochrom> But we are talking about bloody 8.0.
08:25:00 <infinite_recursi> I agree with monochrom, 2 years is a lot of time
08:25:38 <RedNifre> If I have a ParseResult a that in the case of success contains a (String, a) and I want to make that a Monad, what would be the type signature of >>=? Does that even fit if the type only contains a, but the function for >>= would expect a (String, a) ?
08:26:23 <RedNifre> Here's a pastebin of the mess: https://pastebin.com/DxpHAGfW
08:27:50 <Solonarv> RedNifre: no, the type signature is: (>>=) :: ParseResult a -> (a -> ParseResult b) -> ParseResult b
08:28:44 <monochrom> You have a typo?  s/MkParseResult/ParseResult/ ?
08:29:02 <monochrom> Because MkParseResult is a data constructor not a type.
08:29:05 <RedNifre> No, I have an Idris, sorry for that ;)
08:29:14 <RedNifre> yeah, right
08:29:36 <RedNifre> Solonarv yeah, so I guess I have to pull the tuple out to make that signature work.
08:30:23 <monochrom> Do you think you will benefit from my lecture notes?  http://www.cs.utoronto.ca/~trebla/CSCC24-2019-Winter/ParserLib.hs
08:30:44 <Solonarv> well, I think what you actually want to write a Monad instance for is:
08:30:44 <Solonarv> newtype Parser a = MkParser (String -> Either String (String, a))
08:30:51 <Solonarv> (note the extra 'String ->')
08:30:58 <monochrom> except I replace "Either String" with "Maybe" for simplicity.
08:32:11 <monochrom> And yeah the extra "(String," looks like dead weight until you also have a "String->" to receive it.
08:32:48 <RedNifre> Yeah, I'll need a monad instance for Parser as well.
08:33:24 <RedNifre> I actually need a "(String,a)->" to receive both the string AND the parsed element.
08:34:02 <RedNifre> ...which clashes with the normal signature for >>=, unless I change ParseResult to Either String a, but in that case it's nearly a normal Either.
08:34:29 <RedNifre> The only difference to the normal Either would be that the Left is fixed to String... would you say that this is still worth it?
08:34:48 <monochrom> If you must absolutely insist of a ParseResult type (I absolutely recommend against it), drop the "(String,".  data ParseResult foo = MkParseResult (Either String foo).  Then, Parser a = String -> ParseResult (String, a).
08:35:31 <monochrom> In other words leave your "(String," to the Parser type.
08:35:39 <Solonarv> you will note that ParseResult is now just a wrapper around Either String, which is not very useful
08:35:46 <monochrom> Or s/leave/postpone/relocate/whatever/
08:36:05 <RedNifre> I agree, it's so reduced that it might be worth it to just go with Either String (String, a) instead.
08:36:45 <RedNifre> Would you recommend still having a Parser type or should that also disintegrate to String -> Either String (String, a) ?
08:37:38 <monochrom> I recommend having "newtype/data Parser a = MkParser (String -> Either String (String,a))" and deleting ParseResult altogether.
08:39:05 <monochrom> This used to be known as the "coherence principle" taught in "software engineering" courses before those courses switched to OOP and had no time left for the really important principles.
08:39:09 <RedNifre> Alright, I'll try... but... uh... wouldn't it kinda sorta make sense to use one of these unpopular type aliases like type ParseResult a = Either String (String, a)? Why exactly are type aliases considered useless and dangerous?
08:39:17 <monochrom> Wait, s/coherence/cohesion/
08:39:35 <Solonarv> you can't give a monad instance to a type alias!
08:40:01 <Solonarv> oh wait, a type alias for ParseResult
08:40:02 <monochrom> The cohesion principle means you don't split up two things that should belong together, nor do you merge two things that don't belong together.
08:40:52 <Solonarv> yeah, you can use a 'type ParseResult a = Either String a' if you want
08:41:29 <Solonarv> note: not (String, a) - the String in that tuple is the "leftover input", but where's the input? it's not mentioned in that type synonym!
08:41:46 <Solonarv> this is (part of) what monochrom meant, I think
08:42:15 <RedNifre> well, so the problem of not being able to map an (Either String (String, a)) with a (a -> b) because there's already a map for Either that would want a ((String, a) -> b) goes away if I explicitely write functions that accept (String, a) instead of a.
08:42:21 <monochrom> Yeah, the cohesion principle.  Separating String-> from (String, makes no sense.  Each's purpose of existence is because of the other.
08:42:34 <RedNifre> okay
08:43:14 <monochrom> OTOH as far as type aliases go you can do whatever you want.  Type aliases are macros.  There is no principle required of macros.
08:43:19 <infinite_recursi> @monochrome Nice quote on real programmers
08:43:20 <lambdabot> Unknown command, try @list
08:43:42 <monochrom> All the cohesion modularity etc are for real abstractions.
08:43:58 <monochrom> (Shots fired.)
08:44:50 <monochrom> infinite_recursi: which one? Real programmers use quantum entanglement to write to SSD or something? :)
08:46:52 <simbs38> hi there, when i run "cabal new-install" it tells me that symlink-bindir is not defined, how can i define that?
08:47:10 <infinite_recursi> Real programmers get their job done in whatever way they see fit, despite what people say about real programmers. --monochrome
08:47:17 <infinite_recursi> :D
08:47:19 <monochrom> Oh that one.
08:47:39 <monochrom> simbs38: I think the error message also reminds you how?
08:48:18 <simbs38> it says set it in your cabal config file or use --symlink-bindir=<path>
08:48:39 <simbs38> how can i edit the cabal config file, and what is the <path> im looking for?
08:48:57 <RedNifre> Woohoo, it typechecks, let's ship it!
08:48:59 <RedNifre> :w
08:49:29 <monochrom> <path> is the directory you want to put the symlink inside of.
08:50:26 <monochrom> The medium-size story is that the exe is stored somewhere under $HOME/.cabal/store ; and then a symlink is made inside <path> to point to the real file for your convenience.
08:50:40 <Solonarv> so you could do: cabal v2-install blah --symlink-bindir=~/my/favorite/directory
08:51:47 <infinite_recursi> Thanks Solonrv, I updated ghc and that solved the problem!
08:51:50 <Solonarv> the config file is located at ~/cabal/config IIRC
08:51:53 <Solonarv> infinite_recursi: nice!
08:59:23 <monochrom> I think I will be recommending ghcup to my students too next time.
09:00:03 <Solonarv> out of curiosity, what were you recommending before?
09:00:07 <monochrom> The real problem is what do I tell students who use Windows.
09:00:37 <Solonarv> monochrom: chocolatey1
09:00:38 <monochrom> Direct from GHC website and cabal website.
09:00:47 <monochrom> Oh! I keep forgetting that!
09:00:54 <Solonarv> chocolatey is quite nice :D
09:01:08 <RedNifre> If a Parser is `String -> Either String (String, a)` and I want to "map" it, but not with functions like `(String, a) -> (String, b)` but `a->b` instead, what would be a good name for such a function? mapElement? submap?
09:01:34 <simbs38> ok thanks, i got there, but now when i run "cabal new install" it shows me this https://ibb.co/SQ5hvX9
09:01:42 <Solonarv> write a Functor instance for it and use 'fmap'
09:02:19 <monochrom> I would call it fmap too. Functor or not.
09:02:35 <Solonarv> simbs38: try 'cabal new-install rw'
09:02:43 <monochrom> If name clash then fmapParser. Even fmap_Parser.
09:03:02 <RedNifre> Oh, right, I confused the function with the Either. Unlike with the Either, there is not already a Functor instance for String -> Either...
09:03:05 <Solonarv> simbs38: also, oof, you'll need to grab an old-ish GHC or that to work
09:03:12 <monochrom> (The underscore is borrowed from LaTeX convention to mean "subscript".)
09:03:30 <Solonarv> RedNifre: well, actually there is - it's the Functor instance for 'String -> _'
09:03:39 <RedNifre> -_-
09:03:59 <Solonarv> that's why we told you to define a newtype like 'newtype Parser = MkParser (String -> Either String (String, a))'
09:04:01 <simbs38> Solonarv: https://ibb.co/98TWV6c
09:04:31 <Solonarv> simbs38: yeah, I noticed that - you'll need a GHC from 3-4 years ago
09:05:03 <Solonarv> GHC 7.8 is what you'll need I think
09:05:20 <Solonarv> (the version of 'base' is directly tied to the compiler version)
09:06:25 <RedNifre> Never mind, I got confused anyway. Yeah, newtype for String -> Either... and fmapParseResult for Either String (String, a)
09:06:40 <monochrom> If you're working with String -> Either String (String, a) directly, the whole fmap is a composition of 3 smaller fmap's, because you have 3 layers: the String-> layer, the Either layer, and lastly the (String, layer!
09:06:41 <Solonarv> should be relatively straightforward to get that with ghcup
09:07:46 <monochrom> At any rate, type synonyms in the Haskell setting are inconvenient to work with. The only exception I've seen so far is lens.
09:08:18 <monochrom> Whereas, for some reason that's a long story, typedefs in C are just fine.
09:08:51 <monochrom> But one of the reasons is that C has no type classes :)
09:09:30 <Solonarv> the only thing Haskell's type synonyms are good for is not having to type out large types all the time
09:09:39 <Solonarv> (this also applies to lens)
09:09:42 <simbs38> Solonarv: https://ibb.co/zPvQcxX
09:09:57 <monochrom> Sapir-Worf-Orwell theory: If your language doesn't have a word for "rebel", then you won't have the problem of your people wanting to rebel!
09:10:05 <Solonarv> simbs38: use ghcup to install ghc, not cabal
09:12:03 <monochrom> Solonarv: Actually I thought that initially, so I tried newtyping left right and centre, and saw it's deeper than that.  If you keep them as type synonyms, you can just use ordinary (.) on them.  Newtyping for lens is actually more bureaucracy than necessary.
09:12:59 <Solonarv> oh, I know. I was comparing type synonyms to nothing-at-all, not to newtypes
09:13:17 <monochrom> Ah OK.
09:14:32 <Solonarv> if you really wanted a newtype-y lens you'd define it as something like:
09:14:32 <Solonarv> newtype Optic p f s t a b = Optic { runOptic :: p a (f b) -> p s (f t) }
09:15:06 <Solonarv> then you get e.g. 'forall f. Functor f => Optic (->) f s t a b' instead of 'Lens s t a b'
09:15:18 <Solonarv> and you can define a composition operator too
09:16:03 <simbs38> Solonarv: https://ibb.co/0KqRvMR
09:16:36 <Solonarv> huh, I thought ghcup supported older versions. hm.
09:16:54 <monochrom> How old do you need? :)
09:17:08 <simbs38> 7.8 according to solonarv
09:17:33 <Solonarv> that's the version corresponding to base-4.7, if I can still count
09:17:43 <simbs38> how can i install it then?
09:17:51 <Solonarv> which is needed by <https://github.com/rwbarton/rw> which simbs38 is trying to install
09:19:13 <Solonarv> ah, you can try this: https://launchpad.net/~hvr/+archive/ubuntu/ghc
09:19:43 <monochrom> You know what, I would manually edit rw.cabal and relax all version constraints (more like delete them!) and see what happens.
09:20:16 <Solonarv> oh, that's also a possible approach
09:21:31 <maerwald> simbs38: 7.8 is not supported yet, provide a PR :P
09:22:57 <simbs38> i tryied that and it didnt work, it failed on latter steps
09:24:49 <Solonarv> hm, stack might actually be helpful here
09:26:25 <maerwald> see, this is why upper bounds (and == moreso) are just plain wrong. They are guesses and not informed dependencies :)
09:27:13 <simbs38> Solonarv: https://ibb.co/DrJ1F3G
09:27:30 <simbs38> i have installed ghc-7.8 but i can't use it
09:28:24 <maerwald> simbs38: I think hvrs ppa installs a default symlink, try removing ghcup from your PATH
09:28:40 <Solonarv> sorry, I'm out of my depth there - as mentioned earlier I haven't used linux in a looong time
09:29:02 <RedNifre> can a newtype still be used as a function call or is it no longer a function?
09:29:25 <maerwald> sudo update-alternatives --config opt-ghc
09:29:42 <RedNifre> A newtype is kinda a container for the function that I pass as the constructor parameter, right?
09:29:50 <Solonarv> RedNifre: yes, that's right
09:30:02 <Solonarv> you can "open" the container through plain old pattern matching
09:30:32 <RedNifre> ... so whenever I want to use the function I first have to pull it out of the newtype? There is no way to redirect function invocations to the contained function?
09:30:38 <Solonarv> also, it's common to define newtypes like so: newtype Parser a = Parser { runParser :: ... }
09:31:05 <Solonarv> so you can do: runParser myParser input
09:31:16 <maerwald> there is https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Coerce.html
09:31:30 <maerwald> not sure that's a good thing though
09:31:52 <Solonarv> it's not actually any better than simply using a record selector, here
09:32:13 <Phyx-> simbs38: you can't install a new version of wired in packages likes base and ghc using any tool. they are there for docs and to help the solver with dependency analysis
09:32:19 <RedNifre> Kotlin has this funky rule that newtype Functionish = Functionish { invoke :: ... } can be written either as `invoke Functionish 123` or `Functionish 123`, as in, if there's an invoke function defined for it, you can use it like a function.
09:32:54 <Solonarv> yeah, Haskell doesn't work like that
09:32:56 <Phyx-> simbs38: those two packages in particular are too closely tied to the compiler internals to be user installable.
09:33:02 <RedNifre> Guess I'll do invoke (MkParser f) = f
09:33:25 <Solonarv> yeah (although I'd suggest picking a better name than 'invoke')
09:33:50 <Solonarv> also, if you define your newtype using record syntax you don't even need to write that function definition
09:33:57 <simbs38> what should i do then? Phyx
09:34:42 <RedNifre> What's bad about invoke?
09:34:54 <Solonarv> well, it's not a very descriptive name, is all
09:35:25 <Phyx-> simbs38: you can *only* get a specific version of those packages by getting a corresponding version of the compiler. If you're trying to install a package with a hard bound on base you can try passing cabal --allow-newer to relax them.
09:35:48 <RedNifre> Yeah, that's the point. Maybe I should do a typeclass Invokable that defines invoke so functionish types could implement that? The idea is to communicate that this type is functionish.
09:35:58 <Solonarv> you could do that, but don't
09:36:07 <Phyx-> simbs38: but do note that even if the package does compile, it may not work as expected as base does not claim to be ABI stable
09:36:34 <Solonarv> type inference is just one problem with that idea
09:39:23 <simbs38> ok, i guess i will try to work around it , thanks mate :)
09:40:05 <Solonarv> simbs38: you could try stack, 7.8 is the earliest GHC version it supports
09:40:13 <RedNifre> Solonarv could you elaborate?
09:40:39 <RedNifre> Are you only arguing against the name "invoke" or against the whole idea of thinking of some types as functions?
09:41:20 <Solonarv> I'm arguing against generalizing the concept of "callable function" beyond types built from (->)
09:41:54 <Solonarv> *if* you were to generalize "callable thing", then 'invoke' would be a reasonable name
09:42:30 <RedNifre> Why not generalize "callable thing"?
09:42:38 <simbs38> i have stack installed, how can i use it? Solonarv
09:43:18 <Solonarv> simbs38: from within your 'rw' directory, run: stack init --resolver lts-2.22 && stack setup --install-ghc
09:43:25 <Solonarv> after that's done try: stack build
09:44:21 <Solonarv> RedNifre: for one, you don't really need to - functions are already values that we can pass around like any other value, so we don't need to add special magic that lets us treat some values as functions
09:45:20 <Solonarv> for another, it makes type inference worse - meaning the compiler will have a harder time figuring out the types of things, and so you will have to vomit type annotations all over the place
09:46:08 <Solonarv> on the third appendage, we use a lot of higher-order functions (e.g. map, >>=, and so on) in Haskell, and it's not even clear how that should work with "generalized callables"
09:48:15 <monochrom> Scheme teaches us that we don't need a "callable" abstraction. Instead, set things up so the user just has to use function application.
09:50:03 <monochrom> For example, call-with-current-continuation provides you a continuation.  How do you use a continuation?  Scheme packages it up so that you just use function application syntax and you're done, nothing new to learn.  Despite the fact that in all honesty a continuation is a snapshot of machine state and looks nothing like a function.
09:50:32 <monochrom> Hell, even Unix and C teach us that.
09:50:47 <Welkin> the idea of a "callable thing" sounds like java-style oop to me
09:50:49 <Rembane> Is that the callback abstraction in C? 
09:50:56 <Welkin> where nouns rule and functions are second-class
09:51:08 <Welkin> functional programming is all about functions that operate on data
09:51:24 <Akii> anyone using nix here? I have migration scripts I need to include in the derivate but cant figure out how to include anything but the compiled binary
09:51:35 <simbs38> Solonarv : https://ibb.co/p32G9RJ
09:51:58 <monochrom> A syscall is really raising a software interrupt.  However, the C binding sets up enough packaging and wrapperring so you just have to call a function, no new syntax or even semantics to learn.
09:52:44 <lavalike> monochrom: go deeper, what does it look like under the surface?
09:53:29 <monochrom> Why, it looks like using an electronic quantum tunneling microscope to probe molecules!
09:53:33 <Solonarv> simbs38: oof, looks like stack won't magically solve this
09:54:08 <maerwald> well, basically, what you are saying is... a function can just be a function or have an infinite amount of hidden context, because it's a closure/continuation/curried/partial/whatnot :trollface:
09:54:15 <maerwald> so much for equational reasoning...
09:54:43 <monochrom> Unfortunately for you, continuations still enjoy equational reasoning.
09:54:51 <maerwald> in a sense
09:54:57 <c_wraith> even with all that hidden context, they're still just functions.
09:55:01 <maerwald> until you want to look at the context
09:55:03 <maerwald> but you can't
09:55:33 <slack1256> you can make the context clearer on a pure functional language, beta reducing at each "bind"
09:55:43 <slack1256> I used to do that to understand how monads worked
09:55:59 <monochrom> And fortunately for me, all examples I have used so far enjoy anti-equational reasoning to begin with.
09:56:32 <c_wraith> What's the difference between not being able to inspect a use of "double" defined as "double x = 2 * x" at the top level and not being able to inspect "(2 *)"?
09:56:44 <c_wraith> you can't inspect either one at runtime.
09:56:55 <c_wraith> But for doing equational reasoning, they're equivalent.
09:58:42 <monochrom> Also, I did not say or imply "hidden context".  Instead, more like alternative representations.
09:59:28 <Mo0O> Hi there, how do you pretty print a data structure from an application? do you have any recommendations?
10:00:46 <c_wraith> Pick a library.
10:01:01 <c_wraith> There are several, each one probably tells you what its intended purpose is.
10:01:16 <Mo0O> looks like http://hackage.haskell.org/package/show-prettyprint-0.2.3/docs/Text-Show-Prettyprint.html fit my needs
10:02:14 <c_wraith> You might consider https://hackage.haskell.org/package/pretty-simple if you don't have custom Show instances
10:02:22 <slack1256> Mo0O: yeah, that work. Also depending ot the module they have pretty printing funcions (for example Data.Map)
10:02:55 <c_wraith> pretty-simple isn't the most powerful, but it is incredibly convenient when what it does works for you
10:07:06 <Mo0O> c_wraith: thanks, I do like pretty-simple :)
10:07:15 <Mo0O> slack1256: thank you too
10:11:19 <blankhart> cabal new-build does not recognize the option --compiler, but it works when it's in my cabal.project file.  any thoughts?
10:11:34 <blankhart> using cabal 2.4.1.0
10:12:43 <Solonarv> on the command line the option is -w
10:13:11 <Solonarv> I don't remember what the long form is; perhaps --with-compiler ?
10:13:50 <blankhart> you are correct that -w is short for --with-compiler
10:14:11 <blankhart> however, --compiler is a different option. https://cabal.readthedocs.io/en/latest/nix-local-build.html
10:14:30 <blankhart> "Specify which compiler toolchain to be used. This is independent of with-compiler, because the choice of toolchain affects Cabal’s build logic."
10:15:36 <Solonarv> huh, no idea then
10:16:47 * hackage brotli 0.0.0.0 - Brotli (RFC7932) compression and decompression  https://hackage.haskell.org/package/brotli-0.0.0.0 (HerbertValerioRiedel)
10:40:17 * hackage brotli-streams 0.0.0.0 - IO-Streams interface for Brotli (RFC7932) compression  https://hackage.haskell.org/package/brotli-streams-0.0.0.0 (HerbertValerioRiedel)
10:41:47 <RedNifre> Is there something like . but for cases where the second function is meant to take two parameters?
10:41:59 <Rembane> RedNifre: Yes, the owl operator.
10:42:07 <RedNifre> The what?
10:42:07 <Rembane> RedNifre: Or maybe the other one... I have a link somehwere here.
10:42:11 <Solonarv> (.).(.) -- looks like an owl!
10:42:36 <Rembane> RedNifre: It's all here! https://wiki.haskell.org/Pointfree
10:42:48 <Solonarv> @pl \x y -> f (g x y)
10:42:48 <lambdabot> (f .) . g
10:43:05 <Solonarv> this is just on the edge of readability, IMO
10:43:11 <RedNifre> well, that's too confusing compared to f $ g x y
10:43:52 <Solonarv> well you'd use this if you don't want to mention 'x' and 'y' explicitly
10:44:09 <Solonarv> but I agree, hence: on the edge
10:44:34 <frost> > pl \x y -> x + y * 2
10:44:36 <lambdabot>  <hint>:1:4: error: parse error on input ‘\’
10:44:51 <frost> @pl \x y -> x + y * 2
10:44:51 <lambdabot> (. (2 *)) . (+)
10:45:00 <Rembane> I dunno, when you get used to it it's very readable. 
10:45:28 <Solonarv> yes
10:45:37 <Solonarv> gets less readable with >2 arguments involved
10:47:09 <Welkin> :t (*2) . (.).(.) (+)
10:47:10 <lambdabot> (Num ((a2 -> b) -> a2 -> a1 -> a1), Num a1) => (b -> a1) -> (a2 -> b) -> a2 -> a1 -> a1
10:47:27 <Welkin> that is more readable
10:48:00 <MarcelineVQ> that constraint doesn't look happy
10:48:06 <Welkin> oops
10:48:23 <Welkin> let (:.) = (.).(.) in (*2) (:.) (+) $ 1 2
10:48:26 <Welkin> > let (:.) = (.).(.) in (*2) (:.) (+) $ 1 2
10:48:28 <lambdabot>  error:
10:48:28 <lambdabot>      Not in scope: data constructor ‘:.’
10:48:28 <lambdabot>      Perhaps you meant one of these:
10:48:41 <Welkin> > let (.:) = (.).(.) in (*2) (.:) (+) $ 1 2
10:48:43 <lambdabot>  error:
10:48:43 <lambdabot>      • Could not deduce (Num t0)
10:48:43 <lambdabot>        from the context: (Num
10:48:47 <Welkin> :(
10:48:54 <Welkin> > (*2) (.).(.) (+) 
10:48:56 <lambdabot>  error:
10:48:56 <lambdabot>      • No instance for (Typeable b0)
10:48:56 <lambdabot>          arising from a use of ‘show_M15423742376002277119436’
10:48:58 <Welkin> I meant this
10:49:01 <Welkin> :t (*2) (.).(.) (+) 
10:49:02 <lambdabot> (Num ((b -> a1 -> a1) -> (a2 -> b) -> a2 -> a1 -> a1), Num a1) => (b -> a1) -> (a2 -> b) -> a2 -> a1 -> a1
10:49:18 <Welkin> > (*2) (.).(.) (+) $ 1 2
10:49:20 <lambdabot>  error:
10:49:20 <lambdabot>      • Could not deduce (Num t0)
10:49:20 <lambdabot>        from the context: (Num
10:49:52 <Welkin> haha
10:49:57 <Welkin> I can't even get it right
10:50:03 <Welkin> something like that
10:50:48 <Welkin> it's far easier to just write `\x y -> 2 * y + x`
10:50:57 <frost> > ((*2) (.).(.) (+)) 1 2
10:50:59 <lambdabot>  error:
10:50:59 <lambdabot>      • Could not deduce (Num (a1 -> b0))
10:50:59 <lambdabot>          (maybe you haven't applied a function to enough arguments?)
10:51:00 <Welkin> oh, actually I got that wrong in terms of order of operatiosn too
10:52:19 <Welkin> > let (.:) = (.).(.)
10:52:21 <lambdabot>  <no location info>: error: not an expression: ‘let (.:) = (.).(.)’
10:52:26 <Welkin> @let (.:) = (.).(.)
10:52:27 <lambdabot>  Defined.
10:52:33 <Welkin> :t (.:)
10:52:34 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
10:52:37 <Welkin> there we go
10:52:50 <MarcelineVQ> you've been foisted by $
10:53:17 <MarcelineVQ> and the fixity of parens around (.:)
10:53:25 <Welkin> baboozled!
10:53:32 <Welkin> oh
10:53:33 <Welkin> yeah
10:53:34 <MarcelineVQ> in "something $ 1 2" 1 2 is the problem
10:53:38 <Welkin> it's already infix
10:54:05 <MarcelineVQ> > let (.:) = (.).(.) in ((*2) .: (+)) 1 2
10:54:07 <lambdabot>  6
10:54:24 <Welkin> > (filter even .: map) (+1) [1,2,3]
10:54:26 <lambdabot>  [2,4]
10:54:29 <Welkin> :D
10:54:47 * hackage brotli-conduit 0.0.0.0 - Conduit interface for Brotli (RFC7932) compression.  https://hackage.haskell.org/package/brotli-conduit-0.0.0.0 (HerbertValerioRiedel)
10:55:27 <Welkin> what's brotli?
10:55:36 <Welkin> sounds like a cabbage-related vegetable
10:56:03 <Welkin> that has a lot of vitmain C
10:57:56 <Welkin> after having written quite a lot of elm recently, I'm getting used to reverse function application pipelines
10:58:23 <Welkin> I've always used normal (right-to-left) function composition for pipelines in haskell
10:58:32 <Welkin> but I can see the apeal of using &
10:59:02 <Welkin> it would look better if it was |> though (which is used by a lot of library already for various things, usually data construction)
10:59:43 <Welkin> of course this doesn't work if you want point-free
11:01:22 <Welkin> are there any usable extensions for anonymous records?
11:02:13 <Welkin> and what's the story for field names? I forgot the name of the proposal
11:03:06 <Solonarv> there is... stuff
11:03:13 <Solonarv> but IMO it's not all that nice
11:05:06 <Rembane> I think lenses have the best field story so far. 
11:05:43 <Rembane> At least when it comes to ergonomics and how the code looks.
11:05:59 <Welkin> sure
11:06:16 <Welkin> I was talking more about th need to prefix all field names with something to avoud collisions
11:06:38 <Welkin> it's muscle memory at this point for me, but it would be nice to see it improve
11:06:44 <Solonarv> ah
11:07:04 <Solonarv> yeah, there is a DuplicateRecordFields extension which does something
11:08:25 <Rembane> It's alright, but not good. If you ever want to interact with the record fields you need to specify the types. 
11:08:41 <Solonarv> -XDisambiguateRecordFields : Allow the compiler to automatically choose between identically-named record selectors based on type (if the choice is unambiguous).
11:09:15 <Solonarv> DuplicateRecordFields is directly below
11:09:30 <Solonarv> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#record-field-disambiguation
11:10:47 * hackage pipes-brotli 0.0.0.0 - Brotli (RFC7932) compressors and decompressors for the Pipes package  https://hackage.haskell.org/package/pipes-brotli-0.0.0.0 (HerbertValerioRiedel)
11:48:58 <JKTKops> hey, I've been using Haskell for a few months and it's quickly become my favorite language (used to be a Java/Kotlin hobbyist mainly). What development environment do you guys use? I've been using vim + ALE but I'm feeling like I could do better
11:50:17 <Welkin> emacs with haskell mode
11:50:17 <fendor> JKTKops, i am a fan of vscode and haskell-ide-engine :) but vim works jsut as well.
11:50:42 <Welkin> not a development environment, just a text editor
11:50:46 <Welkin> haskell doesn't need an ide
11:50:58 <Welkin> the compiler is the ide
11:51:02 <Solonarv> I use vscode with vscode-ghc-simple
11:51:33 <Solonarv> which uses ghc(i) directly to provide features like type-at-cursorand the like
11:51:34 <Welkin> note on vscode: it contains tracking software that sneds your data to microsoft
11:52:03 <JKTKops> I'm a compiler guy and have been looking at some GHC files. Type information by hovering / go to declaration would be really nice.
11:52:03 <DigitalKiwi> doom dante nixos
11:52:18 <Solonarv> okay, I lied: I use vscodium
11:52:59 <fendor> Welkin, Haskell doesnt need it, but people do. Exploring a codebase is way easier with an ide
11:54:29 <fendor> JKTKops, haskell-ide-engine does not work yet on the ghc codebase, but there are active actions to make it work.
11:55:42 <Solonarv> ghci-based integrations should work though
11:56:27 <Solonarv> there was some work a while ago to make "load the GHC source into ghci" actually work
11:57:08 <JKTKops> Does anyone have experience with Neovim + Intero? I'm up for trying that and/or emacs. Don't really want to use vscode
11:58:20 <Solonarv> intero was originally made for emacs interaction, so that should definitely work
11:58:28 <Solonarv> never used it though
12:02:36 <ddellacosta> JKTKops: I used evil-mode in emacs + intero for a while and found it quite easy to get going, fwiw
12:03:53 <JKTKops> alright, thanks for the input guys :)
12:14:23 <wolfman154> I plan on using python in nixos, can nix replace pip?
12:15:39 <fendor> wolfman154, wrong channel? but yes
12:16:28 <wolfman154> fendor: that’s good to hear, I’m really enjoying nix
12:17:01 <fendor> same. It is a struggle though. However, nix is great to replace pip.
12:17:28 <wolfman154> fendor: struggle?
12:18:20 <fendor> nothing works as expected. Sometimes it takes me a couple hours to set up a project that works out of the box for others
12:22:58 <wolfman154> Is guile from guixsd similar to nix ?
12:23:44 <SabkaBaapThanos> hi
12:25:22 <dminuoso> Hi SabkaBaapThanos o/
12:25:31 <fendor> Hi!
12:50:39 <Nevoic18> Hey, I can't seem to find the definition of `succ` in Haskell, does anyone know where I can look for said code, or what an approximate working version of it would be?
12:51:25 <Rembane> :i succ
12:51:43 <Rembane> Nevoic18: https://hoogle.haskell.org/?hoogle=succ&scope=set%3Astackage
12:51:56 <Rembane> Nevoic18: Or here: https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:succ
12:52:18 <Nevoic18> I found those sites, but they seem to only display type information.
12:52:26 <Nevoic18> I would assume they're not defined entirely from just types.
12:52:30 <Rembane> Nevoic18: Do you search for the code?
12:53:11 <lyxia> Nevoic18: there are "source" links on the right of each function and instance
12:53:11 <Nevoic18> Yeah I'm searching for the code.
12:53:12 <Rembane> Nevoic18: succ is defined for the typeclass Enum, which is why there are only definitions there. 
12:53:37 <Rembane> Nevoic18: So it is implemented in different ways for different types. Are you searching for it for a particular type? 
12:53:43 <Nevoic18> When I click source it just brings me to the type definition + a comment.
12:53:54 <Rembane> Example: https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Enum.html#line-464
12:53:57 <Rembane> For Int! 
12:54:17 <Rembane> Nevoic18: Look for that code under Instances.
12:54:36 <Nevoic18> Ah okay, so there's no generic definition?
12:54:51 <Rembane> Indeed. 
13:17:35 <apeyroux[m]> Hello
13:19:38 <Rembane> Hi apx[m] ! 
13:57:56 <sm> hey all
13:59:33 <sm> stack build doesn't show module names while building dependencies - only when building project packages. I'd really like to see them, but AFAICT it's not supported. Do you know a way ?
14:01:58 <sm> s/project packages/project packages not depended on/
14:02:19 <sm> I guess I can do stack build LIBPKG; stack build MAINPKG
14:03:52 <monochrom> Would it be simply sufficiently many "-v3"s?
14:05:41 <sm> monochrom: no, in my experience that has no effect until termination and/or produces too much output. I want the standard one line "[ 8 of 49] Compiling Some.Module..." messages
14:06:17 * sm has tried --verbosity, --cabal-verbose, --ghc-options=-vN
14:07:51 <sm> also, an easy one: while "[ 8 of 49] Compiling ModuleA..." is the most recent thing printed, does that in fact mean it is currently compiling ModuleA ?
14:08:20 <sm> or might it be compiling the slow ModuleB that comes after ?
14:09:08 <sm> what I'd *really* like is also a report of time spent on each module
14:10:01 <sm> it would make build time optimisation, noticing regressions etc. much more common
14:12:23 <sm> I think my Types module takes a long time. Because of all the deriving I suppose.
14:15:50 <sm> while I'm wishing, also useful would be some quick module stats: counts of lines, types, functions, and known-slow things (derivations, TH/QQ..)
14:45:18 <phaazon> hey
14:45:38 <phaazon> what’s the math name of a structure that has add, sub, mul and div?
14:45:44 <phaazon> I guess it’s more than a group / ring
14:52:04 <Welkin> a plumbus
14:52:51 <phaazon> I’ll call that a plumbus then
14:53:02 <phaazon> even though it looks like a magical spell from Harry Potter
14:53:14 <phaazon> PLUMBUS! *Hagrid flyes the room accross*
14:53:16 <phaazon> flies*
14:53:28 <MarcelineVQ> a plumbus is a common handheld household appliance
14:53:36 <Welkin> everyone has oen in their home
14:53:39 <Welkin> one*
14:54:48 <AWizzArd> The „Write You a Haskell” project has been abandonned, yes? 10 out of 28 chapters done, last commit is two years ago.
14:56:48 <phaazon> https://i.redd.it/zy7p4penlpxz.png
14:56:54 <phaazon> MarcelineVQ: Welkin 
14:56:56 <phaazon> peeps.
14:57:11 <phaazon> that stuff looks like an actual alien fleshlight
14:57:15 <phaazon> what’s wrong with you
14:57:16 <phaazon> :D
14:57:44 <Welkin> oh god
14:57:54 <Welkin> you found the most horrendous illustration of that thing
14:58:08 <Welkin> here is the source material https://www.youtube.com/watch?v=eMJk4y9NGvE
14:59:06 <Welkin> I love the synths in the background
15:02:50 <monochrom> phaazon: Field.
15:03:43 <phaazon> monochrom: oooooh
15:03:46 <phaazon> like in a vector field?
15:04:23 <monochrom> No, just "field".
15:04:53 <monochrom> https://en.wikipedia.org/wiki/Field_(mathematics)
15:05:58 <monochrom> Unless you have something like the quartenions, whose multiplication is not commutative. That's a division ring.
15:29:59 <isBEKaml> hi, in this test function: https://github.com/JD95/haskell-problem-sets/blob/master/Arithmetic/Tests.hs#L27-L35, it does test for division by zero. Is that correct? How would I account for this to make tests pass?
15:30:28 <isBEKaml> function signatures are all: Int -> Int -> Int
15:30:31 <isBEKaml> ehh
15:34:38 <alx741> isBEKaml: QuickCheck has a way to exclude values, so you coud say that the property hols for all integers other than zero (check QuickChek docs)
15:35:12 <alx741> 'P.division' is a partial function though, what about Int -> Int -> Maybe Int ?
15:35:23 <isBEKaml> alx741: Yeah, I got around that with `Positive y`
15:36:20 <alx741> isBEKaml: that would work, bear in mind though you're also exluding negative numbers (that should be valid inputs)
15:37:13 <alx741> isBEKaml: https://www.stackage.org/haddock/lts-12.16/checkers-0.4.11/Test-QuickCheck-Instances-Num.html#v:nonZero
15:37:32 <alx741> 'nonZero' seems to fit better
15:40:20 <isBEKaml> alx741: thanks. NonZero y works 
16:04:01 <glimacs> hi! can somebody helping with a function that i am trying to implement?
16:07:46 <Nevoic> hey, I'm confused as to how a simple pattern like `(x: xs)` works (assuming the type is [a]). Conceptually, I follow what's going on (: is an infix function that pretends the first arg to the second arg, so marking that as a pattern will grab "x" (the first argument)), but how is this actually achieved? Is haskell reverse engineering functions, and
16:07:46 <Nevoic>  making it so outputs of functions cannot actually be inputs?
16:08:03 <Nevoic> prepends*
16:08:22 <Nevoic> can actually be inputs* lol
16:09:16 <lyxia> It's only in expressions that constructors behave like functions
16:09:27 <lyxia> in patterns, you can only match on constructors
16:10:19 <Nevoic> Is `:` a constructor?
16:10:26 <lyxia> yes
16:10:35 <Nevoic> I thought constructors were the things defined in algebraic data types.
16:10:39 <Nevoic> I.E A = B | C
16:10:42 <Nevoic> B and C would be constructors.
16:10:57 <lyxia> data [a] = a : [a] | []
16:11:14 <Nevoic> Oh, that's literally how lists are defined?
16:11:17 <AWizzArd> In principle, if you wouldn’t use a non-alphanumeric operator, but instead some other data constructor you could pattern match on   `List x xs`
16:11:47 <AWizzArd> You now only use `:` instead of `List` and say   `: x xs`.   But because it is an infix operator you write it infix too.
16:11:51 <lyxia> technically it's hard-wired in the compiler but if it could be defined in Haskell that's what it would look like
16:12:50 <Nevoic> Ah alright, I think I follow.
16:12:59 <Nevoic> I am confused on "in patterns, you can only match on constructors" though.
16:13:12 <Solonarv> Nevoic: apart from the special syntax (i.e. []), that is pretty much the definition
16:13:12 <lyxia> It's handled specially because of the particular syntax, but conceptually it's just like   data List a = Cons a (List a) | Nil
16:13:13 <Nevoic> For example, if you had a tuple and you matched on (x, 2), are you saying 2 is a constructor?
16:13:14 <AWizzArd> Nevoic: on what else would you like to match?
16:13:27 <Nevoic> Values.
16:13:29 <Solonarv> in the case of tuples, the constructor is (,)
16:13:37 <AWizzArd> Nevoic: probably here they mean that the tuple `(,)` is the constructor.
16:13:48 <Nevoic> What about if you're just matching a number?
16:13:50 <Solonarv> or (,,), or (,,,), and so on depending on how "wide" the tuple is
16:13:54 <Nevoic> Would 2 be a constructor?
16:13:57 <lyxia> Nevoic: Numbers are another special case I was ignoring when I said that.
16:13:58 <Solonarv> ah, no
16:14:08 <AWizzArd> Nevoic: instead of an operator imagine you were matching   `Tuple2 x 2`
16:14:18 <Solonarv> matching on literals uses ==
16:14:24 <Nevoic> How many special cases are there?
16:14:39 <AWizzArd> In a very trivial way one could see `2` as a data constructor. One that takes no arguments.
16:14:54 <AWizzArd> In a way so that `True` is also a constructor for the value `True` (itself).
16:14:56 <isBEKaml> This is a confusing type signature: problem10 :: (e -> a -> b) -> (e -> a) -> (e -> b) Is there an use for such a function?
16:15:24 <Solonarv> here is what the Haskell Report has to say on pattern matching: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17
16:15:40 <isBEKaml> although I managed to substitute a simple example: problem10 (add2) (add10) --> this still fails to type match
16:16:00 <dibblego> isBEKaml: why confusing? It has only one inhabitant. Also, yes it comes up all the time — write the source code for it and then ask, "how often does this happen?"
16:16:04 <isBEKaml> so: problem10 = \f g -> f $ g -- am I doing something wrong?
16:16:18 <dibblego> yes that is not of the correct type
16:16:30 <dibblego> note that right-most parens can be removed, as -> associates to the right
16:16:59 <Solonarv> consider an alternative way to write this type: (e -> a -> b) -> (e -> a) -> e -> b
16:17:11 <Solonarv> (ah, dibblego beat me to it)
16:18:37 <Nevoic> AWizzArd yeah I understand that conceptually, and just like I said at the start I understood `(x:xs)` conceptually too in the context of [a], I just wanted to understand what was actually happening instead of not knowing.
16:19:28 <Solonarv> Nevoic: did you look at the link I gave earlier?
16:20:02 <Nevoic> Yeah, I was understanding like 40% of it, I don't have a masters in math though.
16:20:39 <Solonarv> hah, you don't need a degree to understand pattern matching :P
16:21:08 <Nevoic> `lpat qconop pat` didn't really make much sense to me, I've only ever used subscripts in the context of math, and the last time I took a math course was 4 years ago so I don't really like have the meaning of that close to my heart.
16:21:57 <lyxia> You do need a bit of experience to read formal grammars, but probably nothing near degree-level of experience.
16:22:02 <Nevoic> Sure, I didn't say you needed a degree to understand pattern matching. More bluntly my point was I don't use math everyday, so math language/symbols aren't something I'm just going to read and understand.
16:22:46 <isBEKaml> Solonarv, dibblego: yeah, I see that. Let's say I have these 2 functions: let addxy = \x y -> x + y, add10 = (10+). Now, I write foobar = addxy $ add10 10
16:23:05 <isBEKaml> so foobar would be the same as the return type in problem10. What am I missing here?
16:23:37 <Solonarv> foobar certainly doesn't have the same type as problem10!
16:23:58 <dibblego> I'm not sure what you are asking — use-cases?
16:23:59 <Solonarv> :t let addxy = \x y -> x + y; add10 = (10+) in addxy $ add10 10
16:24:01 <lambdabot> Num a => a -> a
16:24:11 <isBEKaml> Solonarv: can you give me another example? I can try to fit the pieces?
16:24:56 <Solonarv> I can give you a "skeleton" to fill out, sure
16:24:56 <Solonarv> problem10 :: (e -> a -> b) -> (e -> a) -> e -> b
16:24:56 <Solonarv> problem10 eab ea e = _b
16:24:58 <isBEKaml> dibblego: I'm just working through a set of problems: https://github.com/JD95/haskell-problem-sets/blob/master/Functions/Problems.hs#L30
16:25:47 <dibblego> isBEKaml: ok, follow the types to the solution, and use type-holes at each step. When I run a class, we have certain procedures to follow
16:25:58 <dibblego> 1. if you are at a total loss of what to do, put _
16:26:13 <dibblego> 2. if you need a function, come up with a name (the hard bit) and type \name -> _
16:26:25 <dibblego> follow the type hole errors from there
16:26:56 <dibblego> so, as a first step, replace undefined with _
16:26:58 <dibblego> :reload
16:27:04 <dibblego> oh look you need a function...
16:27:43 <isBEKaml> dibblego: I'll work through it
16:31:18 <qubitrot> Is there a way, with an extension perhaps, to say something like `newtype A = B deriving all`? That is, I'd like A to be an instance of all the classes B is.
16:32:51 <Solonarv> not possible if you want *all* instances
16:33:32 <MarcelineVQ> sounds like a good way to add subtle bugs when someone has an instance in scope you didn't plan for
16:33:48 <Solonarv> you can write a bit of template haskell to inherit all instances that are in scope, but even that has problems because not all classes can be GNDed
16:33:50 <MarcelineVQ> and if it's really an instance of all the things, is it useful to have a different type?
16:34:22 <MarcelineVQ> Probably yes to the latter question, but it's something to ask still
16:37:47 <isBEKaml> dibblego: Okay, I figured it out. Now, I need usecases. :-)
16:38:08 <isBEKaml> problem10 = \f g x -> (f x) . g $ x
16:38:43 <isBEKaml> hoogle didn't match anything with the type signature 
16:38:59 <dibblego> @type (<*>)
16:39:00 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
16:39:09 <dibblego> that has the same type signature, in general
16:39:44 <Solonarv> % :t (<*>) @((->) _) -- behold!
16:39:44 <yahb> Solonarv: (w -> a -> b) -> (w -> a) -> w -> b
16:39:47 <isBEKaml> f here is a functor?
16:39:56 <dibblego> yes, it is (e ->) in your example
16:39:58 <bandali> Joe Armstrong has passed away; it's a sad day
16:40:28 <qubitrot> That's a good point. So my specific case is I want to write several newtype wrapping Linear.V4, and I want each newtype to be useable as a V4 in basially all contexts. I want them as seperate types becuase they belong to different vector spaces. 
16:40:52 <qubitrot> So is the best way to just write a long list of derivings for each newtype? Or is there a better approach?
16:41:23 <isBEKaml> dibblego, Solonarv: Thanks!
16:41:28 <Solonarv> you could use template haskell or CPP to write the list of should-be-derived things automatically
16:41:45 <dibblego> isBEKaml: consider this code: \x -> f x + g x + h x + i x + j x
16:41:58 <dibblego> that's a bit annoying, passing (x) through to all those functions
16:42:16 <isBEKaml> so, you abstract out into an applicative
16:42:20 <Solonarv> CPP: #define VECTOR_DERIVE deriving newtype (Eq, Ord, Show, ...other stuff...)
16:42:39 <dibblego> you can use your function, and const, to write it so that you don't explicitly thread x through everything
16:42:59 <Solonarv> then you write:
16:42:59 <Solonarv> newtype MyFancyV4 a = MyFancyV4 (Linear.V4 a)
16:42:59 <Solonarv>   VECTOR_DERIVE
16:42:59 <Solonarv>   deriving (other things maybe?)
16:43:47 * hackage versions 3.5.1 - Types and parsers for software version numbers.  https://hackage.haskell.org/package/versions-3.5.1 (fosskers)
16:44:42 <qubitrot> Thanks Solonarv! I'll try that.
16:45:12 <Solonarv> obviously you need to enable the CPP ("C PreProcessor") language extension
16:53:41 <Bish> any way to write "map (\ x -> read x ::Integer)" short?
16:54:12 <wolfman154_> how do I run xmonad locker command in services.screen-locker.lockCmd?(the example in home-manager manual is for i3) This is what I’m trying to do: 
16:54:34 <Bish> and/or map (:[])
16:59:03 <wolfman154_> Has anyone tried guixsd or guile? How does it compare to nixos and nix?
17:06:49 <AWizzArd> Bish: if it is given that your map call returns  [Integer] then try:  `map read`
17:08:51 <Bish> AWizzArd: okay, thanks
17:54:17 * hackage gray-extended 1.5.7 - Gray encoding schemes  https://hackage.haskell.org/package/gray-extended-1.5.7 (AmyDeBuitleir)
18:30:55 <fen> I want a way to return a type from a type level list of types, but cant understand how to do this.
18:31:21 <fen> a value of a type from a type level list of types*
18:31:51 <fen> it would need an Int index, but should this be a value level Int or a type level Int?
18:32:07 <fen> or Nat
18:33:04 <fen> eg s -> (Either Int Bool,s), but extended to draw from eg [Int,Bool,Int,Int] 
18:35:06 <fen> something like type StateN (a :: '[*]) ...
18:35:18 <fen> whats the syntax for that?
18:49:36 <Lite> Sorry don't mean to override fen's question. Just got a quick newbie question.
18:49:48 <fen> no worries
18:49:57 <Lite> This haskellbyexample site has a non-working example I'm trying to understand what's wrong: https://lotz84.github.io/haskellbyexample/ex/for
18:50:12 <Lite> I guess different ghc versions? Package doesn't exist?
18:50:59 <fen> that code compiles...
18:51:24 <fen> whats the problem?
18:52:02 <Cale> Lite: What error are you getting? Control.Monad.Cont is from the mtl package.
18:52:07 <Lite> Failed to load interface for    Control.Monad.Cont
18:52:24 <Lite> using just the base ghc package on Ubuntu
18:52:30 <Cale> ah
18:52:42 <fen> you need to type "cabal install mtl" at the command prompt
18:52:54 <Cale> I'd create a sandbox first, but yeah.
18:53:16 <fen> oh... whats that for?
18:54:24 <Cale> Eh, I guess it doesn't harm much if you install things at a user-level anyway, but a sandbox will let you play around with installing packages without affecting anything outside.
18:54:43 <Lite> How would I have been able to tell which package I needed based on the import name?
18:54:53 <Cale> Google
18:55:02 <Lite> fair enough
18:55:37 <Lite> Sandbox I guess installs the packages in a relative path versus a global user folder?
18:56:23 <fen> sure, but why is that advisable? 
18:56:54 <fen> here is the code so far for the question above btw.. https://pastebin.com/raw/WwRyMEhP
18:58:44 <fen> Cale: whats the alternative to "user-level" ? why wouldnt you want to do a global install? encase there are package conflicts or something?
19:01:26 <fen> the code in the paste could use type level Elem, but then it wouldnt have the corresponding position...
19:01:44 <fen> (instead of !!)
19:02:28 <Cale> Package conflicts exactly -- as you install packages, the likelihood increases that you end up needing to build packages against dependencies having different versions and having things be unusable together.
19:02:39 <fen> should it return something like a singleton Nat? like, a value level Nat that is also at the type level?
19:03:01 <fen> Cale: ok, that makes sense
19:03:27 <Cale> So just keeping things sandboxed is a way to avoid having a messy collection of packages in your home directory. Cabal-install can also install things globally, but it doesn't do that by default, nor is it recommended.
19:05:14 <fen> hmm, maybe this type level list style Sum type is something like the vinyl package, but I cant read that code...
19:06:40 <fen> its important it uses a list instead of just being a Sum datatype so that it can be added to, ie to do algebra over the different options of the Sum type...
19:07:14 <fen> such as eg taking the tail of the type level list to give a new sum type
19:07:41 <fen> that doesnt seem like something that is totally a new idea...
19:09:10 <MarcelineVQ> are you wanting a heterogeneous list or something more specific?
19:09:34 <fen> its like a HList that uses just one of the values from it
19:10:02 <fen> like how Either can be Left or Right, that means the value need to have a Nat used somehow to select which type it returns
19:13:26 <fen> oh wow, didnt realise the HList package was so complicated
19:13:44 <geekosaur> this should be a warning
19:13:59 <fen> how so?
19:14:38 <geekosaur> haskell is not agda
19:14:45 <fen> you mean its not a good idea? or that if I cant read that code then its not really within my ability to use easily?
19:15:04 <geekosaur> or other languages which have more flexible type levels and more flexible interactions between type and value level
19:15:35 <geekosaur> HList is complicated because this kind of thing is complicated in Haskell; there are better choices of language if you want to do it more generally
19:16:10 <fen> sure, but if its possible to do, so that it appears in these kinds of libraries, then maybe someone that can actually understand them / has experience using them can point to the part where it is, or help rederive this specific thing so it might appear more clear - like, without the surrounding machinery of the rest of the library
19:16:21 <fen> doesnt seem like it should actually be that complicate to write
19:16:22 <sclv> i mean naively an hlist is just nested tuples
19:16:31 <sclv> its only doing complicated things with them thats complicated
19:16:37 <sclv> simple things are trivial
19:16:47 <Solonarv> yeah, the basic definition isn't really all that ba
19:16:50 <Solonarv> d
19:16:51 <MarcelineVQ> just indexing a hlist isn't too bad, though I'm having trouble writing that myself just now as a learning exercise
19:17:35 <fen> the basic idea is "emulating a Sum datatype using a type level list" right?
19:18:05 <fen> maybe extensible isnt the right word... extendible? mutable?
19:18:08 <sclv> also the hlist package is done in a _very_ old style way
19:18:14 <MarcelineVQ> You might not want to go right to the type level, you might want a GADT that lets you play at both levels at once
19:18:29 <sclv> the same stuff with type families, gadts etc is much more straightforward
19:18:37 <fen> hmm, it needs to change length MarcelineVQ
19:18:57 <fen> nah type families are fine
19:19:23 <fen> its the singletons aspect thats more difficult
19:20:55 <fen> maybe its just (n :: Nat,a :: [*])
19:21:14 <fen> that should be easy to make a value of
19:24:04 <fen> like, this works; https://pastebin.com/raw/rjMGzRBs
19:24:50 <fen> but then the `Z' appears, and it doesnt seem much like a sum type then
19:25:25 <fen> like, you would have to chage the type to have `S Z' if it was supposed to be an Int
19:25:40 <fen> but if it was Either, it would have a way to select which of these it was at value level
19:36:16 <MarcelineVQ> so try tying the type to a value, https://gist.github.com/MarcelineVQ/35fbc14c749e175a93380f84fea61a2f
19:37:16 <fen> but that has a value of every type in the type level list of type
19:37:23 <fen> we just want one of them
19:37:33 <fen> your thing is more like a Product datatype
19:38:04 <MarcelineVQ> hmm
19:41:45 <fen> heres the Singleton Nat machinery that might be used, but still not sure how to write that it needs the value to be used in the type;
19:41:46 <fen> https://pastebin.com/raw/VuPgXiy8
19:41:56 <fen> thats what the `@' symbol is supposed to be saying
19:42:05 <fen> type SumType (a :: [*]) = (n @ SNat,a !! n)
19:44:05 <fen> not really sure what all that singInstance smart constructor stuff is supposed to be doing or how that might help write this...
19:53:14 <fen> how is it supposed to have a singleton value and use this in its type!?
19:54:24 <fen> guess there would be some way to pattern match on the fst of the tuple (the SNat) like you would match over the Sum datatype constructors
20:07:12 <fen> hmm, this is almost there, except it complains about the use of forall.
20:07:13 <fen> https://pastebin.com/raw/YFVHFCGX
20:07:25 <fen> seems to be stopping it calculating the type families or something
20:08:05 <fen> type SumType (xs :: [*]) = forall x (n::Nat). xs !! n ~ x => (Proxy n,x)
20:18:45 <fen> even this does not work;
20:18:45 <fen> https://pastebin.com/raw/chW7NZ38
20:18:56 <fen> (shorter code, easier to comment on)
20:19:14 <fen> type SumType (xs :: [*]) = forall x. True ~ (x `Elem` xs) => x
20:19:45 <fen> is that wrong to use forall like that?
20:20:53 <fen> should it be Exists? 
20:21:51 <fen> dont want to write the x on the lhs because that would mean it would need to be specified beforehand
20:21:59 <fen> this really seem impossible now
20:33:08 <fen> oh, this works! https://pastebin.com/raw/7UN65nca
20:35:24 <fen> hooray! now have HList style sum types!  
20:38:42 <Cale> btw, HList itself also has those
20:38:49 <Cale> http://hackage.haskell.org/package/HList-0.5.0.0/docs/Data-HList-Variant.html
20:41:41 <fen> well that all seems quite verbose
20:42:58 <Cale> Yeah, tbh I'm really not sure why anyone would do this to themselves
20:43:26 <fen> is that "tagged" stuff helpful for something?
20:44:46 <fen> there seems to be some hefty template haskell stuff to make an equivalent for the accessor functions  
20:45:43 <fen> really just need an Int label for now, can do without much of this functionality for the sake of brevity 
20:46:41 <fen> the idea is that its for a higher order "state" thing, which can be unfolded to a lower order state thing.
20:46:58 <fen> the Int corresponds to the depth of nested containers it would be unfolded into
20:48:18 <fen> like, when the state fails to return a new `s', it fails at some depth, and this is the depth of nesting that the container being unfolded at that level is finished unfolding
20:48:49 <fen> so yeah, basically, an Int is fine for this, no need to name the various depths, an Int is more natural
22:59:56 <JKTKops> Anyone know how to get Intero for neovim working? It says 'build failing' on the github page and doesn't seem to be starting up
23:01:17 <May> Hi!  I'm trying to write a function like: insideOut :: (Ord k1, Ord k2) => [(k1, [(k2, val)])] -> [(k2, [(k1, val)])]
23:01:47 <May> It's like flip, but for assoc lists.  Is there a nice way to write that?  (I don't mind converting to and from Data.Map.Map, if that makes it easier.)
23:01:56 <May> Perhaps something with lenses?
23:03:02 <c_wraith> I'd do it in two steps.  first convert to [(k1, k2, val)], then group the k2s together
23:11:18 <fen> https://pastebin.com/raw/7mBPmyFp
23:11:57 <fen> seems like these HSum types are difficult to work with...
23:12:52 <fen> any idea how to get something like that to compile?
23:28:54 <glguy> fen: https://gist.github.com/glguy/f6474f20cccf5fe68fb5806a34878861
23:38:51 <coldpress> JKTKops: I use GHCid instead
23:38:56 <fen> glguy: thanks!
23:47:05 <coldpress> JKTKops: actually Intero seems to work fine, it just has to register some packages, see if ghc/stack processes start up when you open a *.hs file
23:47:11 <koz_> I'm looking at 'Defunctionalizing Push Arrays' by Svensson and Svenningsson. I'm trying to understand their Code data type, but I don't get what the components Write mean. Could someone help me see? https://svenssonjoel.github.io/writing/defuncEmb.pdf
23:47:17 <koz_> (second page of the PDF)
23:47:45 <koz_> The Id is what to write to, but I don't get why _two_ Exps.
23:56:17 <glguy> koz_: one looks like an array index
23:56:33 <glguy> The other the value to write
23:57:11 <koz_> glguy: So it goes 'variable housing the array, expression computing index, expression determining what goes there'?
23:59:57 <x2l43ylol> hello! im very new here and looking for a bit of beginner help, can anyone assist me please?
