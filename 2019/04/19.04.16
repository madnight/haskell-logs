00:00:09 <dmwit> (Just like a dog and a doghouse have names that resemble each other but are very different.)
00:01:10 <wolfman154> dmwit: here’s my xmonad.hs, I’m not sure what’s the syntax to add a key binding to gracefulExit?    https://hastebin.com/dafigudafe.rb
00:01:20 <jusss``> MarcelineVQ: the left part is variabe, and the right part is type
00:01:51 <dmwit> wolfman154: Lines 18-35 are keybindings. Look at them, and make a guess about how to add another one.
00:02:53 <jusss``> so const id :: b->(a->a) is ok, and const id :: b -> id is not? because id is a varaible and the right part need type
00:03:14 <dmwit> wolfman154: Also your last line is not indented, but should be.
00:03:31 <MarcelineVQ> id is a 'value' not a variable, but you're starting to get it
00:03:55 <wolfman154> dmwit: I have no idea, and is the code indented correctly or do I need align it with defaultConfig?
00:03:57 <dmwit> I think it's okay to call `id` a variable.
00:03:58 <yushyin> MarcelineVQ: mmh ok, do you have an example at hand?
00:04:38 <jusss``> MarcelineVQ: dmwit  so a function's name is a variable or a value?
00:04:48 <dmwit> My original code was indented correctly. If in doubt, copy the exact indentation I used.
00:05:16 <jusss``> or called a function?
00:05:31 <MarcelineVQ> A function's name is an identifier. A function is a value.
00:05:41 <jusss``> I never know a function is equal to its name, or not
00:06:12 <yitz> Any suggestions on solving if a number is palendromic, eg 9009 and 909? I was thinking of converting to text and reversing but I can't find any helpful Text functions. Or I can `floor $ logBase 10 x` to convert 9009->[9,0,0,9] which I can `reverse`..
00:06:16 <yitz> ... and compare
00:06:24 <dmwit> If you want to be very, very careful, then no, a function and its name are not the same thing. But most people are sloppy about this because it's way too much work to be that careful all the time, and doesn't really buy you very much.
00:06:29 <MarcelineVQ> dmwit: Now I should probably recheck but afaik haskell has variables in one place, types, things that look (and seem to act) like variables elsewhere are bindings
00:06:40 <jle`> yitz: you can use list functions on strings
00:06:58 <jle`> > reverse (show 9009)
00:07:01 <lambdabot>  "9009"
00:07:31 <dmwit> > map (ap (==) reverse . show) [9009, 909, 1234, 4321234]
00:07:31 <yitz> Oooh. Nice :D `show` looks useful. Thanks, jle`!
00:07:33 <lambdabot>  [True,True,False,True]
00:07:40 <jusss``> id :: a -> a,  this id is a identifier or a value?
00:07:53 <dmwit> Yes, id is both things there.
00:07:58 <MarcelineVQ> dmwit: I'm totally willing to admit that's some pedantic nonsense though because I'm not sure where forall k . k -> ... fits into what counts as a binder or not
00:07:59 <jle`> syntactically, it is an identifier. the identifier represents a value
00:08:03 <jle`> jusss``: a lot of things can represent values
00:08:10 <jle`> (3 + 1), for example, is a value
00:08:24 <jle`> using a variable identifier like `id` is one way to specify a value
00:08:24 <yitz> dmwit: what's `ap` in that context?
00:08:50 <dmwit> yitz: Stupid Haskell tricks. It's... probably not worth the deep dive needed to explain it at this point.
00:09:01 <yitz> lol. ok
00:09:35 <dmwit> yitz: In this specific example, `ap f g x = f x (g x)`, so `ap (==) reverse = \x -> x == reverse x`.
00:09:49 <jusss``> jle`: then where is the variable?
00:10:25 <MarcelineVQ> "<yushyin> MarcelineVQ: mmh ok, do you have an example at hand?" of?
00:10:30 <jusss``> identifier, value, variable,  what they are?
00:10:58 <jle`> jusss``: have you looked at the Haskell Report?
00:11:05 <jle`> it defines all of these things pretty well
00:11:11 <jle`> it's very readable, too :)
00:11:16 <jle`> https://www.haskell.org/onlinereport/haskell2010/
00:11:38 <yushyin> MarcelineVQ: of a valid example of 'funcname ? :: a -> b; funcname = ...'
00:12:12 <dmwit> > (const 3 :: Int -> Int) 4 -- yushyin
00:12:14 <lambdabot>  3
00:12:20 <jle`> jusss``: the big picture of it is that "values" represent semantic meaning.  and in a Haskell source code, we use *expressions* to notate and describe values
00:13:00 <jle`> expressions can be thought of like trees -- they are constructed by using different expression pieces.  the haskell report describes all of the pieces that make up an expression
00:13:11 <yushyin> MarcelineVQ: dmwit: ah yes ...  I thought of something different.
00:13:20 <jle`> in the end an expression is what we type into haskell source file, it's the syntactic 'tokens'.
00:13:55 <jle`> an expression like `1 + 3` can be thought of as `Op "+" (NumericLit 1) (NumericLit 3)`, to use a pseudo-AST
00:14:11 <jle`> one of the possible "pieces" of an expression is a *variable identifier*
00:14:13 <yushyin> I was only thinking of type signatures alone
00:14:44 <jle`> so an expression like `id 5 + 2` can be thought of as `Op "+" (Apply (VarId "id") (NumLit 5)) (NumLit 2)`
00:15:10 <jle`> 'id' here, syntactically, is a *variable identifier*. it plays that role, just like how '5' plays the role of a numeric literal
00:15:43 <jle`> now, the "point" of an expression is to represent a value.  that's the actual semantic meaning that you are using expression syntax to describe
00:15:50 <MarcelineVQ> yushyin: I'm not sure what you're wanting to see, but in the case of const x :: b ->​ a, we must have some x = ... for this to be valid, we are informed by const that x must have type a, and that's all we can know about a since it must work for any a at all. There's very limited things that can fit into any a at all, two that come to mind are error "foo" and undefined.
00:16:15 <jle`> to show a contrast, the expression `id 5 + 2` and the expression `7` and the expression `const 7 2` are all *different expressions*
00:16:19 <jle`> but, they represent the "same" value
00:17:37 <jle`> the full rules of what are allowed in an expression, and what name each part has, is described in the Haskell Report in a pretty clear way
00:17:53 <jusss``> jle`: const id, what this id 
00:18:18 <jle`> on the expression level, that a "function application" expression
00:18:26 <jle`> Apply (VarId "const") (VarId "id")
00:19:05 <jle`> (if you're familiar with how ADT's and constructors work in Haskell)
00:19:21 <jusss``> f = const id,   and const id :: b -> (a ->a)     the id are same?
00:19:22 <yushyin> MarcelineVQ: no I was just dumb not realising that this is of course valid haskell syntax, I am just not entirely awake :D
00:20:20 <jusss``> in f = const id, id is a value I can undertand, that left-value right-value things in C or other language, 
00:20:57 <wolfman154> dmwit: ok, I think this paste bin link is correct, now where, how, and what key binding do I need to add to gracefulExit?               https://hastebin.com/uratufurez.rb
00:21:01 <jle`> "f = const id" is actually a different type of syntactic construct: it's *declaration* syntax
00:21:05 <jle`> again, this is all described in the report
00:21:19 <jle`> declaration syntax goes like: <name> <pattern> = <expression>
00:21:34 <jle`> (zero or more patterns allowed)
00:21:57 <jle`> so the right hand side of the = is expression syntax.  the left hand side is name and zero or more patterns
00:22:29 <jle`> so in this case, f is the name, there are zero patterns, and the expression on the right hand side is (in psuedo-ADT) Apply (VarId "const") (VarId "id")
00:22:56 <jle`> both 'const' and 'id' are "variable identifier" expressions
00:23:25 <jle`> and 'const id' is an 'application' expression, which takes two expressions (here, VarId "const" and VarId "id") and returns a new expression
00:23:58 <jle`> if you're familiar with ADTs, it's kind of like data Expr = VarId String | NumLit Integer | Apply Expr Expr | ... many other constructs, all defined in the report
00:24:41 <jle`> and we have something like data Declaration = Dec { decName :: String, decPatterns :: [Pattern], decExpr :: Expr }. in a simplified form :)
00:25:53 <jle`> so `f = const id` would be Dec { decName = "f", decPaterns = [], decExpr = Apply (VarId "const") (VarId "id") }, to make the link clear
00:26:07 <jle`> note that all of this is just *syntax*. it doesn't have anything to do with the meaning of any of these expressions or declarations
00:38:12 <wolfman154> dmwit: you there?
00:41:23 <fr33domlover> Hmm in Yesod (and similarly in resourcet) there's a forkHandler function doing some logic, but the UnliftIO instance of HandlerFor doesn't do that stuff. So If I want to use async with HandlerFor, the only option seems to be the UnliftIO instance? But then I don't get that memory leak prevention stuff etc.
00:43:41 <wolfman154> fr33domlover: is yesod pretty good for web development?
00:45:56 <wolfman154> ok, I think this paste bin link is correct, now where, how, and what key binding do I need to add to gracefulExit?               https://hastebin.com/uratufurez.rb
00:46:16 <wolfman154> Could someone help me with this, thanks!!!
00:47:59 <wolfman154> dmwit: you there, I could really use your help right now 
00:48:25 <yushyin> did you check https://wiki.haskell.org/Xmonad/General_xmonad.hs_config_tips#Key_and_Mouse_Bindings
00:50:03 <wolfman154> yushyin: yes, what’s the syntax for adding a key binding to gracefulExit?
00:51:07 <wolfman154> yushyin: I’m new to xmonad so I have no idea 
00:52:24 <yushyin> http://hackage.haskell.org/package/xmonad-contrib-0.15/docs/XMonad-Util-EZConfig.html here is the syntax
00:54:08 <wolfman154> yushyin: thanks, I can’t stay awake any longer, so later!!!
00:55:39 <yushyin> they will come again, ask the same question without any homework done.
00:59:25 <coldpress> how the hell does xmonad temporarily run other window managers?
00:59:47 <__monty__> It's not easy to be dropped into a programming language if you have no prior experience tbf. Especially if all you want is to get a window manager set up.
01:03:19 <maerwald> turing complete config languages are always a bad idea
01:05:47 <yushyin> they said they had some experience with haskell already. self-taught haskell programmer, who wants to work as a freelancer haskell developer. I presumed someone like that, should be able to read some documentation and ask more specific questions. :/
01:05:49 <sicklork1n> maerwald: is this because it's to expressive?
01:06:32 <maerwald> sicklork1n: yes, always choose the least expressive solution :)
01:06:56 <maerwald> most fundamental principle of all CS (both for theory and practice)
01:09:51 <__monty__> Totality doesn't buy you that much though. No noticeable difference between never finishes and takes a really long time.
01:09:59 <sicklork1n> maerwald: been meaning to try daml, which was the first thing that came to mind when you made that statement.. then remembering the days of xml and xslt...
01:10:26 <sicklork1n> we have made some progress...
01:10:50 <__monty__> yushyin: They also said they'd started a codecamp exercise site this week or something. Doesn't sound like an experienced haskeller/programmer tout court to me.
01:11:05 <__monty__> sicklork1n: Dhall! : )
01:11:21 <yushyin> oh well, missed that one
01:11:25 <sicklork1n> ohkay
01:18:14 <Ven``> phadej: foldM is perfect! Only had to swap my arguments. I guess hoogle isn't too fond of arguments order being swapped
01:18:27 <Ven``> Thanks.
01:18:32 <comerijn> __monty__: Totality makes reasoning about code much more tractable, though, even if it doesn't mean practical performance
01:45:36 <zincy> Can trees be represented as lists and is it wrong to do so?
01:46:12 <merijn> zincy: Yes, no, maybe, it depends :p
01:46:30 <zincy> In the context of an AST transformer that takes an Op and returns a list of target lang ops. So the overall AST transformer takes a list of source ops and returns [[targetOps]]
01:46:30 <merijn> zincy: Define "tree", "represented as" and "wrong" :)
01:47:13 <zincy> Ok maybe that is multiple questions in one :D
01:47:16 <merijn> zincy: Why [[TargetOps]], rather than [TargetOps]?
01:47:24 <merijn> i.e. don't you just want "concatMap"?
01:47:54 <merijn> zincy: Because this sounds like "compiling an AST to asm/machine code" which is just a linear sequence of instructions
01:48:19 <zincy> Ah yes
01:48:41 <zincy> I will want to flatten the list write since assembly doesnt have nesting.
01:51:46 <zincy> Thanks
01:52:21 <zincy> In webassembly you have this module expression for defining a module.
01:53:55 <zincy> Should I be adding in these kinds of expressions that are boilerplate to the empty AST at the beginning or after the AST for the non-boilerplate is generated
01:54:09 <zincy> Weirdly phrased ^
01:54:43 <zincy> Essentially what is the best way of adding in boilerplate-esque operations in your target language during the AST transformation?
02:01:30 <merijn> zincy: I don't think it really matters, tbh?
02:35:54 <zincy> merijn: Yeah I don't think so
02:40:01 <zincy> When people talk about "runtime" do they mean the program which executes the instructions?
02:42:43 <merijn> zincy: As in "the GHC runtime"?
02:42:51 <zincy> Yeah
02:43:06 <zincy> Well can we start with the term more generally
02:43:18 <merijn> zincy: No, the GHC runtime is, essentially, a library that implements a bunch of primitive stuff that every program needs
02:43:35 <zincy> As in the "Chrome runtime"
02:43:35 <zincy> Or any other one
02:44:01 <merijn> zincy: runtime systems are (generally) libraries that provide some primitive/essential operations to a language
02:44:23 <zincy> So it provides runtime dependencies for the compiled haskell (binary?)
02:44:44 <merijn> zincy: In GHC you should think of things like "spawn a forkIO thread, block on a file descriptor, allocate memory from the GC, allocate an MVar, try to read an MVar, etc."
02:46:04 <zincy> So the RTS is needed because forkIO doesn't map directly to low level instructions that are sufficient to fork a new thread
02:46:12 <merijn> zincy: You can do 2 things with that sort of logic: 1) have the compiler splice it into executables as boilerplate (like your question earlier), but this isn't very maintainable as now the logic is spread out throughout the compiler
02:46:15 <zincy> Since it is not actually an OS thread
02:46:48 <merijn> zincy: 2) you can create a "runtime" system that provides an API (and can be maintained independently) and teach the compiler to insert calls to said API in the compiled code
02:47:00 <zincy> ooh
02:47:33 <zincy> Great explanation
02:47:35 <merijn> zincy: runtime systems are generally "just" libraries, but libraries with special status (i.e. the compiler knows about their internals and generally lower level)
02:48:35 <zincy> So the RTS api is only called during compile time?
02:48:44 <zincy> It extends the compiler functionality
02:48:58 <zincy> I thought the RTS was essentially an interpreter before this chat
02:49:10 <merijn> zincy: No, it's like any other library "a bunch of code that gets linked into the final executable"
02:51:06 <zincy> The fact there is a chrome runtime for javascript confuses me
02:51:19 <zincy> since JS is interpreted by chrome
02:51:50 <zincy> Is the chrome runtime the compiled C code which is acts as an interpreter?
02:51:56 <merijn> zincy: But the JS spec has a bunch of builtin functions, like "get the current time/date"
02:52:21 <merijn> zincy: So how does the JS interpreter know what to do when you call a function to get the time?
02:52:41 <merijn> zincy: Obviously the function isn't written in JS, because it's part of the JS spec which just says "this function exists"
02:52:41 <zincy> The C interpreter makes a sys call?
02:53:07 <merijn> zincy: The JS interpreter doesn't know about "syscalls", though, it just knows about javascript
02:53:49 <jusss``> why ghci is so difficult to use?
02:54:12 <tdammers> is it?
02:54:19 <merijn> zincy: Most of these questions boil down to the fundamental point of "how does a compiler know what to do?" Consider something simple like: "x = 1 + 1" in Haskell. Somewhere, somehow GHC has to know how to add two numbers
02:54:26 <tdammers> maybe you're just using it for something it wasn't designed for?
02:54:34 <jusss``> use :{   and  :}  to multiple lines
02:54:55 <zincy> Ah right so runtimes are libraries containing extra operations you need to make your language spec work and are dynamically linked to the final executable
02:54:59 <merijn> zincy: Which, in turn leads to the notion of "primitives", i.e. operations that are just hard-coded into the compiler to teach it what they mean
02:55:10 <tdammers> jusss``: how else would you do it?
02:55:33 <zincy> merijn: So these primitives can either be spliced or abstracted out into a RTS
02:55:37 <merijn> zincy: So for things like + you can fairly easily just teach it some basic assembly instructions, but for things like "allocate a thread", you probably don't wanna do that directly in assembly :)
02:55:42 <merijn> zincy: Right
02:55:53 <jusss``> tdammers: just like others repl
02:56:00 <merijn> zincy: For example: GHC's threading implementation: https://github.com/ghc/ghc/blob/master/rts/Threads.c
02:56:17 <jusss``> no need for :{  :}
02:56:30 <tdammers> jusss``: like what? detect that an incomplete expression has been entered, and keep accepting more input?
02:56:40 <merijn> zincy: In the end "forkIO" compiles down to a primitive operation which results in GHC inserting a function call to that RTS code
02:57:05 <tdammers> jusss``: that's not possible due to the way Haskell syntax works. an expression can be syntactically complete but accept additional input as well
02:57:09 <tdammers> :t map
02:57:10 <lambdabot> (a -> b) -> [a] -> [b]
02:57:14 <tdammers> :t map succ
02:57:16 <lambdabot> Enum b => [b] -> [b]
02:57:16 <merijn> zincy: So we don't have to teach GHC to generate all that stuff directly in assembly (you could, it's just a lot of work an not very beneficial)
02:57:46 <tdammers> so basically we need a system that allows the user to tell GHCi to consider the entry read so far a complete expression to evaluate
02:58:24 <merijn> zincy: Bonus point, you can (conceptually) replace one implementation of the RTS with another. In fact, that's exactly what happens when you enable -threaded in GHC. There is a separate runtime system for the threaded case to, well, actually use multi-threading :)
02:58:43 <zincy> merijn: Ah interesting
02:59:17 <merijn> zincy: You should also give GHC.Prim a browse if you're interested in this stuff
02:59:20 <merijn> zincy: https://hackage.haskell.org/package/ghc-prim-0.5.3/docs/GHC-Prim.html
02:59:30 <zincy> merijn: So if you compile your Haskell to say Webassembly do you need to reimplement the RTS?
02:59:37 <merijn> zincy: That's the module and package listing all GHC's primitive operations
02:59:41 <merijn> zincy: Yes
02:59:52 <zincy> merijn: Or do you just need a C to Webassembly compiler for the RTS?
03:00:14 <zincy> Awesome I will browse it
03:00:21 <merijn> zincy: The problem is that the C code uses syscall which may not exist in webassembly, so at the very least you need to fix/implement those syscalls in webassembly
03:00:25 <merijn> (lunch time)
03:00:35 <zincy> Thanks for your help
03:02:31 <jusss``> how I can know the function fmap's definition? 
03:02:43 <jusss``> function definition, not type signature
03:03:48 <yushyin> you look at the source?
03:03:58 <jusss``> not yet
03:26:47 * hackage jaeger-flamegraph 1.2.0 - Generate flamegraphs from Jaeger .json dumps.  https://hackage.haskell.org/package/jaeger-flamegraph-1.2.0 (fommil)
03:37:54 <domenkozar> so what do haskell developers usually use for development version?
03:38:03 <domenkozar> X.X.X-dev?
03:38:13 <Peaker> newtype Knot = Knot (Knot -> Type) ; newtype Pure k where Pure :: k ('Knot Pure) -> Pure ('Knot k)    <-- this isn't allowed in newtype syntax. Must I pay with "data" instead of "newtype" just for type-level changes?
03:38:52 <Rembane> domenkozar: Developers as in GHC developers or as in people who compile things using GHC?
03:39:30 <Aruro> why haskell ecosystem is so unstable? i tried to install haskell platform and compile vado from source and i get dependecy errors
03:39:54 <Aruro> it feels exact same as it was in 2015 when i first learned haskell :(
03:40:02 <domenkozar> Rembane: as in someone writing a cli in haskell
03:40:39 <Rembane> domenkozar: Got it. If you can choose wildly, pick GHC 8.6.4.
03:40:42 <Peaker> Aruro, are you using stack?
03:41:04 <domenkozar> I mean, how to format cabal version to denote it's a development
03:42:56 <ZORR0W> How does old programmers who dont use social media connects with developers? Do they use IRC, email anything? If they do use IRC or email where do I know their email address?
03:43:56 <opqdonut> programmers connecting with developers?
03:44:12 <tdammers> what makes you think old programmers don't use social media?
03:44:30 <opqdonut> I'm not old but I'm not on social media, and I connect fine with people I know and on IRC channels like this one
03:44:31 <ZORR0W> I mean those who I know dont use. 
03:44:49 <opqdonut> meetups are nice too
03:44:52 <Athas> ZORR0W: "connect"?
03:45:00 <Athas> Like, how do they communicate?  Most everybody has email.
03:45:15 <ZORR0W> connect= talk/communicate
03:45:23 <Athas> Or they talk to people IRL.
03:45:37 <Athas> It's not so different from how old (or young) non-programmers communicate.
03:46:08 <Rembane> ZORR0W: Do you want to reach someone in particular? 
03:46:28 <Rembane> I usually use e-mail to get in touch with package maintainers, or I talk here, or I find meetups. 
03:46:43 <Rembane> domenkozar: I usually don't. Why do you want to do that?
03:47:30 <Athas> domenkozar: my personal convention is that development versions have a trailing .0, and release versions are .1 or greater.
03:47:45 <Athas> Another common approach is that released versions have even numbers, and development versions have odd numbers.
03:48:18 <ZORR0W> Brian Kernighan in particular for example. How can I reach to him? He is not on social media. 
03:48:25 <mniip> is there a less awkward way to say
03:48:30 <mniip> :t \f g -> f >>= fmap join . sequenceA . fmap g
03:48:32 <lambdabot> (Traversable m2, Monad m2, Monad m1) => m1 (m2 a1) -> (a1 -> m1 (m2 a2)) -> m1 (m2 a2)
03:48:52 <Rembane> ZORR0W: I would write a formal letter. 
03:49:39 <ZORR0W> ok
03:50:34 <Athas> ZORR0W: have you checked his home page?
03:50:44 <Athas> https://www.cs.princeton.edu/~bwk/ lists an email address, and the page was last updated two months ago, so I assume it's current.
03:51:23 <ZORR0W> Sending him stuff on university address is it ok?
03:51:31 <Rembane> Athas: I like it how you consistently are more reasonable than I am. :)
03:51:49 <Athas> ZORR0W: why else would he make it public?
03:52:15 <Athas> Rembane: well, formal letters are for Knuth!
03:52:36 <yushyin> :D
03:53:16 <krtio_> mniip: you can convert sequenceA . fmap to traverse
03:53:32 <Rembane> Athas: Darn it. My famous computer scientist contact lookup table isn't what it once was. 
03:53:33 <ZORR0W> Athas: Yeah. Maybe its public because he rarely check it.
03:53:53 <Athas> ZORR0W: do you really expect anyone here to have specific information on how often Brian Kernighan checks his email?
03:54:04 <mniip> :t \f g -> f >>= fmap join . traverse g
03:54:05 <lambdabot> (Traversable m2, Monad m2, Monad m1) => m1 (m2 a1) -> (a1 -> m1 (m2 a2)) -> m1 (m2 a2)
03:54:06 <Rembane> ZORR0W: Or because he likes getting thought out e-mail? 
03:54:09 <mniip> hmm
03:55:11 <Rembane> +well
03:55:17 * hackage Monadoro 0.1.1.0 - A minimalistic CLI Pomodoro timer, based on a library of the same purpose.  https://hackage.haskell.org/package/Monadoro-0.1.1.0 (patryk_kocielnik)
03:56:37 <ZORR0W> Alright guys. I got what I needed to know.
03:58:12 <opqdonut> ZORR0W: I'm curious, what do you want to email him about?
03:58:26 <opqdonut> (It's fine if you don't want to tell)
04:01:17 * hackage Monadoro 0.1.2.0 - A minimalistic CLI Pomodoro timer, based on a library of the same purpose.  https://hackage.haskell.org/package/Monadoro-0.1.2.0 (patryk_kocielnik)
04:13:15 <__monty__> domenkozar: There's no distinction imposed by the PVP, and that was on purpose, cabal already had a Stability field. https://pvp.haskell.org/faq/#semver
04:25:57 <akr> man, TH is so annoying
04:26:06 <akr> each time I change something I have to run clean on the whole project
04:26:24 <akr> otherwise it attempts to use the outdated definitions
04:29:24 <Peaker> akr, basically all build systems except tup/buildsome will be wrong for these non-trivial cases :-(
04:29:43 <Peaker> (it's evidently quite hard to get the dependency specs quite right, if it isn't done in an enforced way)
04:30:03 <akr> oh yeah I can understand that it's not an easy problem :)
04:45:17 * hackage fedora-img-dl 0.3 - Fedora image download tool  https://hackage.haskell.org/package/fedora-img-dl-0.3 (JensPetersen)
05:04:17 * hackage servant 0.16.0.1 - A family of combinators for defining webservices APIs  https://hackage.haskell.org/package/servant-0.16.0.1 (phadej)
05:26:52 <Bish> hello its me again with odd questions
05:27:00 <Bish> why does fmap act so weird with fmap?
05:27:09 <Bish> > fmap (+1) (Left 1)
05:27:11 <lambdabot>  Left 1
05:27:18 <Bish> > fmap (+1) (Right 1)
05:27:20 <lambdabot>  Right 2
05:27:54 <merijn> Bish: You mean "why does fmap act so weird with Either?"?
05:27:59 <Bish> okay
05:28:01 <Bish> yes, i do
05:28:01 <gonz_> Consider how you'd create a function that took one function that could apply to both L and R
05:28:04 <merijn> :t fmap
05:28:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:28:06 <gonz_> Can you?
05:28:16 <merijn> Bish: Can you tell me what 'f' is in the case of Either?
05:28:28 <gonz_> Or would you need two separate functions to be passed, taking different input types?
05:28:35 <Bish> merijn: well Either
05:28:58 <merijn> Bish: But 'f' only takes one argument, though?
05:29:23 <Bish> yes
05:29:32 <merijn> Bish: Either doesn't :)
05:29:38 <Bish> yes
05:29:55 <merijn> Bish: Conclusion: 'f' can't be 'Either', so then what is it :)
05:30:07 <Bish> the functor instance of either
05:30:17 <merijn> No
05:30:31 <Bish> hm, one of the constructors?
05:30:32 <fr33domlover> Bish, take a look at the Functor instance of Either, at least the declaration of it
05:30:38 <fr33domlover> You can see it in GHCi
05:30:44 <fr33domlover> :i Either
05:30:57 <Bish> fr33domlover: i did all that before coming here
05:31:35 <merijn> :t fmap even `asAppliedTo` Left True
05:31:36 <lambdabot> Integral a => Either Bool a -> Either Bool Bool
05:31:45 <merijn> :t fmap even `asAppliedTo` Right 5
05:31:46 <lambdabot> Integral a1 => Either a2 a1 -> Either a2 Bool
05:31:49 <gonz_> I really think this is one of those cases where this will become obvious if you try to create what you are looking for.
05:32:04 <gonz_> an `fmap` that somehow can apply to both `Left` and `Right` in this case, that is.
05:32:12 <gonz_> Try to implement it.
05:32:55 <Bish> gonz_: haskellers tend to say that, but it's not, i am sure if i substitute everything with the right side of the equation there will be the answer
05:32:55 <fr33domlover> Bish, note the difference between "instance Functor (Either a)" and, say, something like "instance Eq (Either a b)"
05:33:11 <Bish> because thats what lambda calculus is, but that does not help, at all
05:33:23 <gonz_> This is a very practical issue
05:33:35 <gonz_> When you try to create it you'll see exactly what the issue with it is.
05:34:46 <yushyin> same for (,)
05:35:04 <fr33domlover> Bish, Functor deals with some "container" type F that holds a value or values of type type a. The Functor instance of Either treats (Either a) as a "container" of a value of type b, so it operates on the Right side, and doesn't touch Left
05:35:35 <Bish> fr33domlover: yeah thats my observation, but why was it made ike that?
05:36:02 <bjs> Bish: say I have some either type `x :: Either Int Bool` and I do `fmap f x`,  what should the type of f be?
05:36:06 <Bish> just so that type of that either doesn't change?
05:36:09 <gonz_> Bish: What type does `f` in `fmap f either` have?
05:36:21 <gonz_> If it can apply to both
05:36:48 <Bish> gonz_: well, i see whats happening, i also see the benefit of doing it like this, doesn't explain this is the reason why they did it
05:36:55 <gonz_> It has to take some mythical `a | b -> c`
05:36:59 <fr33domlover> Bish, I'm not 100% sure but I think other people here know. However (1) how else would you define it? (2) Either is often used in cases Left is an error, so applying functions to the Right "success| value is what you want most of the time in such cases
05:37:18 <merijn> fr33domlover: I think you have your causal relation wrong :)
05:37:21 <Bish> fr33domlover: im sure its clever to do it that way, but knowing why it is is good too
05:37:21 <fr33domlover> Bish, you can always use Data.Bifunctor to apply to Left and/or Rght
05:37:39 <merijn> fr33domlover: Left is used as an error *because* the Functor instance privileges Right
05:38:06 <bjs> Bish: I mean, think about what the type of your function would have to be: if I did `fmap f someEither`  what type should f have?  You'd need a structure that knows there are multiple alternatives for the input to f
05:38:12 <fr33domlover> merijn, ah I see, sorry, like I said I don't know much about that detail :)
05:38:13 <gonz_> Bish: How would you take both `a` or `b` in `f`?
05:38:37 <gonz_> Nevermind "why was it done like that?"; *how* could you encode this?
05:38:49 <gonz_> Can you...?
05:39:00 <fr33domlover> Bish, take a look at Data.Bifunctor, it's like Functor except for 2 types and you can use it with Either
05:39:14 <fr33domlover> > first (1+) $ Left 3
05:39:16 <lambdabot>  error:
05:39:17 <lambdabot>      • Couldn't match type ‘(b, d)’ with ‘Either Integer b0’
05:39:17 <lambdabot>        Expected type: Either Integer b0 -> (b, d)
05:39:32 <fr33domlover> > first (+1) $ Left 3
05:39:34 <lambdabot>  error:
05:39:34 <lambdabot>      • Couldn't match type ‘(b, d)’ with ‘Either Integer b0’
05:39:34 <lambdabot>        Expected type: Either Integer b0 -> (b, d)
05:39:46 <Bish> i'd rather understand the functor instance first
05:40:16 <gonz_> This is why you should just try to implement what you want
05:40:39 <fr33domlover> > first (+ 1) $ Left 3
05:40:40 <gonz_> You'll see how you can't make `f` take `a | b`.
05:40:41 <lambdabot>  error:
05:40:41 <lambdabot>      • Couldn't match type ‘(b, d)’ with ‘Either Integer b0’
05:40:41 <lambdabot>        Expected type: Either Integer b0 -> (b, d)
05:40:47 <bjs> Bish: it's easiest if you just try, imagine you had a Functor instance (somehow) for `Either a b` and you now wanted to do `fmap f someEither` where `someEither :: Either a b`,  try write `f` and see what problems you run into.
05:40:48 <Bish> well im just peering around, i don't want anything right now but to understand
05:40:57 <fr33domlover> lambdabot, y u dont like me
05:41:31 <bjs> fr33domlover: maybe `first` isn't coming from Bifunctor but from arrow or something
05:42:03 <fr33domlover> bjs, yeah it seems to expect (,) so must be coming from some utility package? where it's only for pairs
05:42:43 <yushyin> Bish: I always thought it was a somewhat arbitrary choice to map over Right not Left, same for (,) to map over snd not fst?
05:44:44 <gonz_> Bish: Understanding can't really just come to you from not exploring and seeing the practical limitations of what you're asking for.
05:44:55 <Bish> well, is it ? yushyin 
05:44:59 <fr33domlover> Bish, note that "instance Functor F" would be applied to values of some type (F a) so it has to be the last type parameter of the type, e.g. imagine some type "data MultiEither a b c d" so the FUnctor instance would be on "MultiEither a b c" and apply the function to the value of type d
05:45:08 <Bish> gonz_: it feels like a choice to me, that has been made, yes
05:45:13 <fr33domlover> Bish, because d happens to be the last type parameter of MultiEither
05:45:38 <bjs> yushyin: it's not that arbitrary, you'd need something like `instance Functor (\x -> Either x y)` but maybe with enough extensions, I'm not an expert :)
05:46:12 <gonz_> Bish: Once again, exploration could answer these questions.
05:46:18 <Putonlalla> I think you cannot have lambdas on the type level without making type checking undecidable, bjs.
05:46:18 <yushyin> bjs: true
05:46:26 <Bish> gonz_: so could explainations
05:46:32 <gonz_> You've received several.
05:46:35 <Bish> gonz_: exploration is what i do all the time
05:46:38 <bjs> Putonlalla: probably
05:46:41 <fr33domlover> Bish, so "instance Functor (Either a)" is like that because it's basically the primary way that makes sense / is possible
05:46:56 <Bish> gonz_: "look at the types" is not a explanation , because thats what i am observing already
05:47:18 <Bish> fr33domlover: maybe you can tell me what is not possible?
05:47:29 <gonz_> Bish: I've told you repeatedly to implement it and also asked you to implement an `fmap` that can map over both sides of `Either`. These are very clear instructions.
05:47:45 <gonz_> You've ignored it completely in favor of explaining how you feel and what you believe.
05:47:49 <Bish> gonz_: yeah, now i got it
05:47:54 <Bish> so taking the right side was a choice?
05:47:55 <Bish> why?
05:47:56 <Putonlalla> You can make any `f a b` functorial on `a` with a carefully chosen `newtype`, Bish. Can you find it?
05:48:14 <Bish> it might have been the left aswell, doesn't it?
05:48:37 <bjs> Bish: because it's the last parameter to the Either constructor  (you can think of it as being the last argument to the Either type-level function)
05:48:51 <gonz_> Bish: That wouldn't be `Right`.
05:48:59 <gonz_> ...
05:49:29 <fr33domlover> Bish, the Functor instance for some type F applies to values of type (F a), so 'a' has to be the last type parameter, in Either a b the last parameter is b
05:49:46 <gonz_> The point here is that you have to choose one; they can't both be valid for input to `f` and as people pointed out, the natural layout of the specification is the last type parameter.
05:49:58 <fr33domlover> bjs, like Putonlalla to make the instance apply to a and not b, you need a newtype wrapper
05:50:04 <fr33domlover> *says
05:50:04 <gonz_> And the type is laid out like `Either l r`
05:50:33 <gonz_> `Left` is wrong, `Right` is right
05:50:37 <fr33domlover> Oops I meant Bish 
05:50:54 <bjs> :)
05:51:13 <Putonlalla> A similar trick works to make any `f a a` functorial on both occurrences of `a`.
05:52:12 <Bish> what exactly does class Functor (Either a) mean
05:52:24 <Bish> i mean the compiler knows Either has 2 type(variables)
05:52:29 <Bish> what does leaving 1 out mean in that case?
05:53:04 <Bish> oh wait.. i get it.. a is either
05:53:04 <fr33domlover> Bish, I suggest you read some Haskell totorial/book (there are some wonderful ones), in the chapter that introduces typeclasses and instances
05:53:22 <Bish> nono, i got confused i get it, a is Either if its left do that... so it's a choice as i said
05:53:26 <fr33domlover> You'll get a good clear introduction there
05:53:28 <Bish> it might've been Left aswell
05:53:37 <fr33domlover> Better than the random comments you can get on IRC
05:53:39 <Bish> atleast i don't see why not
05:54:24 <gonz_> `instance Functor (Either l) where ...` is what you mean. `Either l` takes one more parameter, which is the one `f` will be applying to.
05:54:45 <gonz_> With the type spec of `Either`, it can't be `Left`
05:54:57 <gonz_> With a type that flips them, sure
05:55:24 <Bish> fmap _ (Left x) = Left x
05:55:37 <Bish> what would happen if i changed this to fmap f (Left x) = Left (f x)
05:55:40 <fr33domlover> Bish, FUnctor is a typeclass of things of "type" (* -> *) which means, things that take one value type and the result of a value type. (Either a) satisfies that requirement, it takes some type parameter 'b' resulting with (Either a b) of which values can exist
05:55:45 <Bish> why can those not coexist?
05:56:03 <fr33domlover> Bish, if that's confusing give the online books/tutorials/wikibook a chance :)
05:56:15 <akr> TH + parallel compilation, not even once https://twitter.com/akr_types/status/1118133447858577409
05:56:22 <Bish> i know i can read books, thanks
05:56:24 <Bish> and i did
05:56:50 <gonz_> Bish: How does `f` apply both to the `l` and `r`types?
05:57:06 <Putonlalla> All of these questions of yours would be answered if you did the two exercises I suggested, Bish.
05:57:44 <Bish> #haskell is really od when getting explainations 3 people giving different excercises, i cannot even chose one without getting confused
05:57:53 <gonz_> I'll just say it one last time because we're not moving forward at all; if you try to implement `fmap f` over `Either a b` with `f` applying to both you'll see exactly how you can't.
05:58:01 <Bish> and they always need vocabulary i don't know
05:58:20 <Bish> i think im close to understanding it. it can't be both for some reason, but i don't see it
05:58:33 <Putonlalla> It's a choose-your-own-adventure kind of deal.
05:58:34 <bjs> Bish: let's take another approach, you gave some perfectly good Haskell: `fmap f (Left x) = Left (f x)` and `fmap f (Right x) = Right (f x)` 
05:58:43 <bjs> Bish: what happens if you just write that and see what Haskell says about the function
05:59:44 <Bish> well can i paste that into ghci?
05:59:51 <Bish> i didn't know that otherwise i would've done it :D
06:00:07 <fr33domlover> Bish, like I said, on IRC you're just getting lots of random comments from different people with different thoughts and approaches. If this Either thing is confusing, skip it for now, keep reading, and it will become clear very soon
06:00:37 <Bish> fr33domlover: "rtfm" is not helping anyone on earth, tehy know already
06:00:57 <Bish> feel free not to, but this isn't helping, random comments are great, but not if they're "you're doing it wrong"
06:01:06 <Bish> i chose a path, it might be stupid, but failure is the way to learn
06:01:24 <Bish> bjs: ghci ate those lines, what know? try it?
06:01:25 <bjs> Bish: yes you can just define the function in ghci.
06:02:01 <Bish> okay, ghci dies because patterns are not exhausted, why?
06:02:06 <Bish> i can't see it
06:02:13 <Logio> Bish: check :t fmap
06:02:16 <bjs> Bish: make sure you defined _one_ function with two cases
06:02:32 <exarkun> Bish: see :? about :{
06:02:44 <exarkun> if you're going to use ghci
06:02:52 <exarkun> or consider putting it in a .hs file instead
06:03:03 <bjs> Bish: I think you can separate them with semicolons or just write them in a .hs file
06:03:09 <Bish> oh. it always has to be a function to b
06:03:13 <exarkun> repl is really convenient for one line expressions, gets progressively less convenient the more lines you have
06:03:14 <Bish> hm
06:03:36 <Bish> but why :'(
06:03:57 <Bish> okay, im just blind to this problem
06:04:48 <Bish> oh, a function can only map to one type... and in the case that Left and Right are different types that doesnt make sense
06:04:48 <Logio> Bish: if you were to write a functor instance for Right, it would need to look something like "instance Functor (Either _ b) where"
06:04:57 <Bish> does that make sense? what i wrote?
06:05:08 <Logio> Bish: yes, that is part of the problem
06:05:12 <gonz_> Yes.
06:05:30 <Bish> if i created either only for integers, which would make less sense, would it be possible?
06:05:50 <bjs> Bish: if you had an `Either a a` then you could have a function (a -> a) that works for both Left/Right
06:06:00 <Bish> great, i got it, thanks :)
06:06:31 <bjs> Bish: so if you did something like `newtype SameEither a = SameEither (Either a a)` you could define a Functor for SameEither  if you wanted.
06:07:01 <Bish> now it the type feels more like a hashmap
06:07:08 <Bish> atleast if you have an array of them
06:08:52 <Bish> but what do i do if i want to map over a list of Left 1 and make it Left 2?
06:09:01 <Bish> how would i excract that info?
06:10:30 <gonz_> https://hoogle.haskell.org/?hoogle=(a%20%2D%3E%20c)%20%2D%3E%20Either%20a%20b%20%2D%3E%20Either%20c%20b
06:10:50 <Bish> fmap f (Left x) =
06:10:51 <bjs> Bish: what would you do if there was `Right 1` in that list?
06:10:54 <Bish> upsi
06:11:03 <Bish> well, use >>= or fmap
06:11:14 <bjs> Bish: because you can always just write your own functions to do exactly what you want (you don't need to use Functor/Monad if they don't fit)
06:11:39 <fr33domlover> :t Data.Bifunctor.first
06:11:41 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
06:11:41 <Bish> okay, then i blindly thought thats the way the cookie crumbles
06:11:45 <gonz_> Bish: Check the link I pasted; it's a great resource for searching for answers. Just learn how to represent your question as a type and you can see what's out there.
06:12:09 <Bish> yeah, great, thanks
06:12:14 <Putonlalla> More concretely, define `Functor` instances for these, Bish.
06:12:14 <Putonlalla> @let newtype Flip f a b = Flip {getFlip :: f b a}
06:12:15 <Putonlalla> @let newtype Join f a = Join {getJoin :: f a a}
06:12:16 <lambdabot>  Defined.
06:12:17 <gonz_> Also look at `Bifunctor`
06:12:17 <lambdabot>  Defined.
06:12:19 <fr33domlover> > map (Data.Bifunctor.first (+1)) [Left 1, Right 2, Left 3, Right 4]
06:12:21 <lambdabot>  error:
06:12:21 <lambdabot>      Not in scope: ‘Data.Bifunctor.first’
06:12:21 <lambdabot>      No module named ‘Data.Bifunctor’ is imported.
06:12:42 <fr33domlover> % map (Data.Bifunctor.first (+1)) [Left 1, Right 2, Left 3, Right 4]
06:12:43 <yahb> fr33domlover: [Left 2,Right 2,Left 4,Right 4]
06:12:51 <Sk01> bot hates fr33domlover confirmed
06:13:02 <fr33domlover> Sk01, yahb like me though lol
06:13:12 <Bish> i really have to stop peering inside the default datatypes, these questions drive me nuts
06:13:22 <Bish> yesterday that list comprehension stuff, today that
06:14:29 <bjs> Bish: the defaults are usually the "obvious, simple" thing, and sometimes there are choices and options to do it in a more complicated way
06:14:59 <fr33domlover> Here they come, the fancy people who use IRC via Matrix
06:15:13 <fr33domlover> ^_^
06:15:18 <Maxdamantus> You think that's air you're breathing in?
06:15:21 <Bish> bjs: yeah, thats what it feels like also, hard to believe that people take an easier foothold than me in this
06:16:22 <Bish> but maybe because they're not like me, who knows
06:17:10 <Bish> i mean i imagine new cs students learning haskell as a first langauge
06:17:24 <Logio> many of the choices are illusory though, due to the fact that the haskell typeclasses at least try to follow some laws
06:17:26 <gonz_> I had the exact question you had about mapping over `Either`; you're not likely to be any different to everyone else.
06:17:35 <c_wraith> There's some evidence it's easier to learn as a first language.  Not *easy*, but easier.
06:17:51 <c_wraith> Like, you have less established ideas about how things should work that Haskell ignores.
06:19:56 <t00l> that's interesting ^ the haskell mind, the beginner's mind to paraphrase
06:20:05 <c_wraith> On the other hand, those aren't really the hard parts of learning haskell.  Like, I was completely fine with immutability and no iteration when I started Haskell.  Learning laziness properly still took me over a year of using it daily.  Fortunately you don't need that every day.
06:20:50 <z0> c_wraith: what do you mean by "properly"?
06:21:43 <c_wraith> z0: finding a mental model where I could predict space use without experimenting.  It only took me a couple months to reach a point where I could debug space leaks that showed up.  It took me a lot longer to stop writing code that had them in the first place.
06:21:49 <Putonlalla> If by "properly" you mean "without introducing space leaks", then I'm still not there.
06:22:46 <c_wraith> I still deal with the occasional one where I missed something originally.  But it's down to the frequency I run into accidental memory problems in strict languages.  A couple times a year.
06:24:47 * hackage hedis 0.12.2 - Client library for the Redis datastore: supports full command set,pipelining.  https://hackage.haskell.org/package/hedis-0.12.2 (k_bx)
06:26:25 <bjs> c_wraith: I mean my head still hurts with something like `fix f = f (fix f)`
06:26:32 <c_wraith> for what it's worth, I quite like laziness.  I think it's super underrated.  But I agree it's scary to learn, and a lot of work.
06:27:08 <c_wraith> bjs: are you happier with the alternate representation?  fix f = let x = f x in x
06:27:17 * hackage telega 0.2.1 - Telegram Bot API binding  https://hackage.haskell.org/package/telega-0.2.1 (iokasimovmt)
06:27:44 <bjs> c_wraith: "happier" is very subjective :)
06:27:52 <bjs> I think it depends which day you ask me on
06:28:04 <c_wraith> bjs: fix doesn't really depend on laziness, though.  I mean, sometimes it does, sometimes it doesn't.
06:28:28 <c_wraith> > fix $ (0:) . scanl (+) 1  --  this one needs laziness
06:28:30 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
06:30:17 <c_wraith> > fix (\loop n -> if n == 0 then 1 else n * loop (n - 1)) 5 -- this one does not need laziness
06:30:19 <lambdabot>  120
06:31:17 * hackage datadog-tracing 1.4.1 - Datadog tracing client and mock agent.  https://hackage.haskell.org/package/datadog-tracing-1.4.1 (fommil)
06:37:17 * hackage datadog-tracing 1.4.2 - Datadog tracing client and mock agent.  https://hackage.haskell.org/package/datadog-tracing-1.4.2 (fommil)
06:45:47 * hackage network-simple-tls 0.3.2 - Simple interface to TLS secured network sockets.  https://hackage.haskell.org/package/network-simple-tls-0.3.2 (RenzoCarbonara)
07:06:38 <wolfman154> dmwit: are you there, I’m almost finished, I just need a little more help with my xmonad.hs
07:50:58 <AWizzArd> Have there been any news regarding linear types in Haskell? I think in 2017 and 2018 this was a hot topic. Is that project still alive?
07:51:17 * hackage network-simple-wss 0.1 - Simple interface to TLS secured WebSockets.  https://hackage.haskell.org/package/network-simple-wss-0.1 (RenzoCarbonara)
07:52:14 <merijn> AWizzArd: Yes, but this sorta feature is a multi-year project to integrate in GHC
07:53:05 <z0_> isnt there somewhere a fold function named something like "foldl0" or "foldl_" that automatically assumes the head as the accumulator? 
07:53:27 <z0_> my memory eludes me
07:53:42 <merijn> z0_: foldl1?
07:54:24 <z0_> thats it
07:54:31 <z0_> man i drew a blank
07:55:15 <z0_> thanks
07:55:51 <AWizzArd> I wonder what the differences between Haskell’s and Rusts linear types are. It seems that in Rust the use of a linearly typed var is optional, while in GHC it would have to be used exactly once.
07:56:17 * hackage pretty-ghci 0.2.0.0 - Functionality for beautifying GHCi  https://hackage.haskell.org/package/pretty-ghci-0.2.0.0 (harpocrates)
07:56:45 <Athas> AWizzArd: at most once, depending on laziness and exceptions.
07:56:54 <Athas> It seems to me that Haskell's linear types will have really funky semantics.
08:04:21 <AWizzArd> What I saw however was in the rust examples this borrowing principle.    They made a string s and created a function `length` and made it return the length plus the original input string.
08:04:34 <AWizzArd> let (len, newS) = length s in ...
08:04:56 <AWizzArd> Now with borrowing this would be possible in Rust, and that way one could use `s` again.
08:05:02 <Cale> I could be wrong, but I'm not at all happy with the newly proposed system for linear types in Haskell. It doesn't seem at all practically useful to me, and yet it will result in pressure for developers of open source libraries to make things more multiplicity-polymorphic, for instance.
08:05:06 <AWizzArd> But how would that be accomplished in the haskell types.
08:05:44 <Athas> I also think the linear types proposal is a huge pile of complexity for very little gain.
08:06:42 <Cale> Yeah, it's complicated and you really can't put it to use in a practical setting without e.g. giving up the ability to handle exceptions, which is a pretty big deal.
08:08:03 <Athas> My main worry is that this is another big piece of complexity that will make GHC yet more unstable and buggy, because the maintenance resources become stretched further.  But hey, I get it for free, so I feel a bit guilty about that worry.
08:08:30 <maerwald> Yes it will
08:08:45 <Ariakenom> Cale: "giving up the ability to handle exceptions"?
08:09:31 <maerwald> Athas: I worry more about the ecosystem. The more expressivity you give, the more fragmented the ecosystem may eventually become
08:09:41 <Ariakenom> if I understand correctly, while you can't make sure that a file is closed with it, you can make sure it isn't used after it's closed.
08:09:54 <merijn> Cale: thb, I think exceptions in Haskell need a big rework anyway. The only problem is the system I have in mind can't be backwards compatibly retro-fitted anyway
08:10:00 <Cale> Ariakenom: Exception handlers get in the way of things being used exactly once.
08:10:15 <Cale> (because e.g. they may not be used at all, if an exception occurs)
08:10:32 <Athas> Cale: don't you already have that issue in a lazy setting?
08:10:48 <Athas> You may call some linear function, but if you never use the result, the argument will never actually be used either.
08:10:49 <Cale> I don't mean 'used' in the sense of evaluated
08:11:00 <Ariakenom> so if you use withFile and a linear file you rule out both those errors, right?
08:11:39 <maerwald> I find it much more useful to have multiple semi-compatible languages, with different focus und expressivity than one with all of it retro-fitted
08:11:41 <Ariakenom> Athas: yes
08:12:27 <AWizzArd> maerwald: it would still be nice to have less GC calls and more runtime efficiency.
08:13:10 <Athas> Has that been demonstrated as an advantage of linear types?
08:13:36 <AWizzArd> Athas: well, in Rust it has. There no GC is required.
08:13:45 <Cale> Actually, perhaps I'm describing it incorrectly -- it makes it difficult to use anything which throws an exception
08:13:54 <Ariakenom> "linear functions have the property that if their result is consumed with multiplicity X, then their argument is also consumed with multiplicity X"
08:13:56 <Ariakenom> https://gitlab.haskell.org/ghc/ghc/wikis/linear-types
08:14:24 <Cale> Because if you were supposed to have used some variable by pattern matching on it, but first you need to do something which may throw an exception, now you're not necessarily consuming that variable exactly once.
08:14:35 <Athas> AWizzArd: yes, but Rust is entirely built around deterministic memory management in a way that even Linear Haskell is not.
08:15:02 <Ariakenom> AWizzArd: haskell and runst is different though. so is this type property
08:15:03 <orion> Cale: What if the finalizer consumes it?
08:15:25 <Athas> I have seen no evidence that retrofitting linear types has any advantages in automatic memory management, let alone linear types with properties as unpredictable as Linear Haskell.
08:15:42 <Cale> orion: That's a good question, but it doesn't seem to be accounted for in any fashion
08:15:58 <Cale> argh
08:16:01 <Cale> matrix pls
08:16:06 <Solonarv> heck
08:16:07 <Ariakenom> im gonna need a filter ...
08:16:17 <Athas> So many new friends!
08:16:33 <Solonarv> no, there was a mass disconnect from matrix earlier
08:17:04 <Ariakenom> Athas: correct. there is no change to the rts in linear hs
08:17:24 <Cale> orion: Like, what should the type of catch be?
08:17:50 <Ariakenom> you can write some nice freeze . foldr mutate data $ input though
08:17:53 <AWizzArd> I thought that more runtime efficiency was the main goal of LT in Haskell.
08:18:08 <AWizzArd> It’s a nice side effect that it _also_ offers additional correctness properties in some cases.
08:18:12 <Ariakenom> AWizzArd: where did you get taht from?
08:18:20 <Cale> We need a way to express the idea that if a caught exception occurs before the argument gets consumed, then the exception handler may consume it instead
08:18:28 <Cale> But there's no way to say that in Linear Haskell
08:18:37 <Athas> I think you can use Linear Haskell to enforce some API guarantees that let you do otherwise-unsafe things in your own code, just like how ST is really a type-safe wrapper around unsafePerformIO.
08:18:43 <Ariakenom> Cale: that sounds hard
08:18:47 <Athas> But GHC itself will likely not be able to exploit it automatically.
08:18:47 <AWizzArd> Ariakenom: https://www.tweag.io/posts/2017-03-13-linear-types.html
08:18:53 <Ariakenom> Athas: yup
08:19:06 <AWizzArd> „In this blog post, we'll briefly discuss (more in the paper) how we're trying to achieve more predictable performance at a smaller memory footprint in Haskell, and give you a preview of what you might expect in your favourite compiler in the not-so-distant future.”
08:19:17 * hackage dura 0.1 - durable/atomic file system writes (from rio package)  https://hackage.haskell.org/package/dura-0.1 (chessai)
08:19:40 <Ariakenom> AWizzArd: yeah that seems misleading 
08:19:47 <AWizzArd> Ariakenom: and later in that post they say: „But the story gets better still. Linear types aren't only useful for performance, they can also be key to correctness.”
08:19:50 <Ariakenom> although it may be the ultimate goal
08:20:14 <Ariakenom> you can always write unsafeX for the perf, I'd think
08:20:17 <AWizzArd> So, from this post I see that faster execution is the goal. But fortunately it also improves in some cases the correctness. This is how I read it.
08:20:47 <orion> Cale: Not sure. What is your backwards-incompatible suggestion for the exception system?
08:20:51 <AWizzArd> Ariakenom: but `unsafeX` does not imply that it runs outside of the GC, but instead with explicitly calls of malloc/free.
08:21:03 <Athas> I find the argument that linear types are useful for fusion to be dubious.  I have implemented loop fusion algorithms, and while linearisability certainly guarantees fusion without work duplication, there are many cases of fusion that are not (locally) linear, but can still be fused without work duplication (think diamond dependencies).
08:21:24 <Cale> orion: My suggestion would be just to not bother with linear types at all :P
08:21:56 <Athas> Also, if you really care about fusion, Joachim Breitner's work on testing application of rewrite rules seems a much smaller hammer than adding linear types.
08:22:17 <Cale> orion: It's already way more complicated than it's worth, and trying to deal with situations like that in order to be able to get practical usage out of it would just make it even more complicated.
08:22:25 <maerwald> Cale: but the hype ;P
08:23:31 <Cale> I honestly don't understand the hype at all
08:23:51 <Ariakenom> AWizzArd: I don't get the difference
08:24:49 <Athas> I think linear types is the only GHC proposal that has been complicated at all levels of the compiler!  Are they still discussing the lexical syntax of the linear arrows?
08:25:03 <Ariakenom> I suppose that blog post was a long term plan|goal, while the current proposal is a bit different
08:25:36 <Cale> Athas: We can only hope that the lexical syntax concerns tie it up indefinitely :D
08:25:37 <Ariakenom> "Faq: Does this proposal improve performance: No."
08:25:51 <orion> I would find linear types to be useful when implementing cryptographic algorithms/protocols.
08:26:20 <Athas> orion: for nonces?
08:26:48 <orion> For example, stream ciphers are subject to catastrophic key-reuse attacks. By forcing a key to only be used once, that problem is eliminated.
08:27:04 <Solonarv> Athas: dependent types are similarly wide-reaching
08:27:05 <Athas> Couldn't you do that monadically?
08:27:25 <Athas> Solonarv: yes, I also think dependent types in Haskell are a bad idea, although they are a more logical extension of what's already there.
08:27:25 <Cale> You can
08:27:42 <Athas> Linear types are like a whole different branch of type theory than the System F stuff that underlies Haskell.
08:27:43 <Solonarv> then again that's actually spread across many individual GHC proposals, some of which have already landed
08:28:03 <orion> Athas: Without IO?
08:28:28 <Ariakenom> Athas: well I've heard you can encode linear types in current haskell
08:28:33 <Athas> orion: I think so.  It's not like IO actually matters semantically.  You just hide away the use of key material in the monadic actions, such that it is never actually exposed as a value by itself.
08:29:32 <Athas> Really, it's not so different from monadic parsing, which prevents you from parsing the same character more than once (except when backtracking).
08:32:15 <orion> Athas: Not sure I follow. There is a cryptographic state s which contains the nonce, key, etc. That needs to be tracked somehow. Is your suggestion akin to using MonadState?
08:32:54 <Athas> orion: yes, but you'd hide the state from the user and present a safe API.
08:33:16 <Athas> Internally, it would use unsafe operations, but the outer API could be safe.  That's not so dissimilar from Linear Haskell.
08:34:54 <orion> I see.
08:36:13 <Athas> Does GHC still contain the bits for Data Parallel Haskell?
08:43:30 <Ariakenom> array :: Int -> [(Int,a)] -> Array a
08:43:35 <Ariakenom> array size pairs = newMArray size (\ ma -> freeze (foldl write ma pairs))
08:43:53 <Ariakenom> from https://www.microsoft.com/en-us/research/uploads/prod/2017/12/linear-haskell-popl18-with-appendices.pdf
08:44:46 <Athas> Couldn't you do that by making the inner function run in ST and return an STArray?
08:45:10 <Athas> That requires rank-2-types, but we already have that.
08:45:39 <Ariakenom> can you do that without unsafeFreeze?
08:46:51 <Athas> The vector library certainly provides an API that allows you to convert mutable vectors (running in ST) to immutable vectors (that you can take out of ST) without any user-visible unsafe operations.
08:47:14 <Athas> It might use unsafeFreeze behind the scenes, but does that matter?  Even with Linear Haskell, you are going to have something unsafe somewhere.
08:50:08 <Solonarv> indeed, if it wants to be efficient it has to use unsafeFreeze internally - because unsafeFreeze is "freeze without copying"
08:50:43 <Athas> The important thing is that you can hide away the unsafety and present a safe API that cannot possibly be misused.
08:50:54 <Solonarv> yes
08:51:01 <Athas> (It would be even better if everything was *fundamentally* safe, right down to the language semantics, but we are nowhere near that for Haskell!)
08:51:28 <Ariakenom> Athas: you need it somewhere. but I think you need less
08:52:06 <Ariakenom> vector has safe generate, but here you can write safe generate
08:52:20 <Solonarv> in order for things like unsafeFreeze to be made safe we'd need something very much like Rust's lifetimes/borrow checker; I'm not sure if "plain old" linear types are enough for that
08:52:31 <Solonarv> * as planned to be implemented in GHC
08:52:53 <Ariakenom> (generate is similar to that function I posted)
08:53:56 <Ariakenom> Solonarv: in that example there is freeze :: MArray a ⊸ Unrestricted (Array a)
08:54:25 <Ariakenom> oh you mean in the implementation of freeze, sry
08:54:50 <Solonarv> is that meant to be a linear arrow? I can't quite tell in my font
08:54:56 <Ariakenom> yeah
08:55:24 <Solonarv> hm, guess it works actually
08:55:50 <Ariakenom> full disclosure I'm actually not too positive about these linear types but I thought someone needed to play devil's advocate :)
08:58:52 <Athas> Looks like the linear type proposal is discussing non-lexical syntax now, so it must be close to done.  I think someone mentioned that GHC 8.10 was the target.
09:31:53 <hpyCdr> is it possible to create multiple conduit / pipes from a single file source? e.g. one conduit streams the header, one the data, another other data etc?
09:39:52 <yitz> Is there an sprintf equivilent in Python?
09:40:01 <yitz> string builder?
09:44:01 <Cale> yitz: I believe that's what the % operator does, but this isn't the right channel :)
09:45:12 <yitz> Uh .... s/Python/Haskell/. Sorry
09:45:20 <phadej> :t printf
09:45:21 <lambdabot> PrintfType r => String -> r
09:45:33 <phadej> > printf "%0.2f" 0.12345 :: String
09:45:35 <lambdabot>  "0.12"
09:45:44 <phadej> > printf "%0.2f" 0.12345 :: IO ()
09:45:46 <lambdabot>  <IO ()>
09:46:04 <yitz> Erm... what's the `:: String`  mean/do?
09:46:26 <yitz> > printf "%s %s" "Hi" $ printf "%s" "Bob"
09:46:30 <lambdabot>  error:
09:46:30 <lambdabot>      • Could not deduce (PrintfArg t0) arising from a use of ‘printf’
09:46:30 <lambdabot>        from the context: PrintfType t
09:47:16 <jgt> is there some idiomatic operator people use in place of (fmap . fmap)?
09:47:32 <jgt> I would have thought <$$> but Hoogle shows that to usually mean other things
09:47:59 <Cale> yitz: It informs the compiler about what type of result you want, since otherwise with printf, it's inherently ambiguous
09:48:30 <Cale> yitz: Usually I don't bother with printf, and instead just concatenate bits of Text
09:48:35 <phadej> jgt: reflex uses ffmap and <<$>>
09:48:54 <phadej> but, it's just one sample
09:49:04 <Cale> yitz: But if you want to see something really funny, I made this library: http://hackage.haskell.org/package/category-printf
09:49:16 <Cale> phadej: ffmap?
09:49:20 <Cale> ffor
09:49:31 <phadej> Cale: ffor is flip ffmap
09:49:40 <phadej> sorry
09:49:40 <yitz> Text's concat might do the trick... I'm just learning Haskell
09:49:42 <phadej> flip fmap
09:49:42 <Cale> oh, sorry
09:50:21 <phadej> yitz: there are formatting libraries
09:50:36 <Cale> phadej: But I don't think reflex defines ffmap or anything like that
09:51:02 <phadej> yitz: https://hackage.haskell.org/package/fmt which also lists other options in description
09:51:48 <jgt> ah, it's in a couple of alternative preludes like protolude, but not the one I'm using (ClassyPrelude)
09:51:57 <Cale> I should make sure that category-printf has all the features of the other formatting libraries :)
09:52:00 <yitz> Thanks, phadej 
09:52:06 <jgt> oh well. I guess I'll just define it.
09:52:43 <Cale> jgt: Are you sure you shouldn't just newtype something?
09:53:37 <Cale> jgt: If you're using fmap . fmap often enough to warrant special syntax for it, then maybe whatever pair of functors you're fmapping through ought to be fused together.
09:55:16 <z0> what are the conventions regarding the order of arguments in Haskell, if there are any? for example, should [Int] -> Int -> [Int] be preferred to Int -> [Int] -> [Int] ?
09:55:18 <jgt> Cale: I'm not sure. In this case, I'm using newtypes to wrap Maybe Text values, which are themselves wrapped in FormResult wrappers
09:55:31 <jgt> this is with yesod-form
09:55:42 <phadej> hmm, one of reflex-based projects I'm looking at uses just (fmap . fmap)
09:55:54 <phadej> which looks a bit silly :)
09:55:57 <jgt> Cale: so I'm doing something like this: (AMBestNumber <<$>> fst amBest)
09:55:58 <Cale> z0: Well, there are two things to be aware of which occasionally are at odds with one another
09:56:20 <Cale> z0: One is that you typically want the arguments sorted in order of increasing frequency of change
09:56:44 <Cale> That is, the most configuration-like or constant-like things are first, and the things which you expect to vary rapidly go later.
09:56:51 <jgt> with `amBest` being the result of `Yesod.Form.Function.mopt`
09:57:13 <Cale> This goes hand in hand with the fact that applying a function to one of its multiple arguments will get you another function.
09:57:14 <z0> Cale: yes, so we can apply sections without havinf to flip
09:57:17 <Cale> right
09:57:33 <z0> however
09:57:36 <Cale> The second thing to be aware of is that when possible, it's nice for a function to produce a result of type A -> A
09:57:46 <Cale> because such things can be composed together nicely
09:57:56 <z0> yesss
09:58:12 <jgt> Cale: this is that chunk of code: http://ix.io/1GnV
09:58:18 <z0> ok so you just subtitled my question perfectly
09:58:20 <Cale> Sometimes these two goals are in contradiction with each other, and you just have to make a judgment call, or offer both variants.
09:58:33 <z0> ok
09:58:45 <Cale> jgt: hmmm
09:59:23 <z0> i'm very partial to prioritizing the second rule
09:59:46 <Cale> jgt: I suppose that's fine. Seems a little awkward in context to make additional newtypes
10:00:34 <jgt> Cale: I'm basically in the habit of newtyping primites, especially when there's a bunch of them together in a record
10:00:39 <jgt> primitives*
10:00:42 <Cale> jgt: It might be useful to pattern match things like amBest as (amBest,_) in order to avoid the need to use fst
10:00:53 <jgt> I newtype my UUIDs too
10:01:03 <yitz> Heh. Just discovered the `do` keyword. Makes multiple printf calls in main a bit simpler...
10:01:41 <Cale> z0: Another thing to be considered is when one of the arguments is likely to be very long, it's nice to have a variant which places that argument last.
10:01:41 <jgt> Cale: Yeah, I could pattern match that way (because I use the second part of the tuple too), but I'm trying to keep line lengths to 80 chars
10:02:55 <z0> yitz: nice. but beware, do notation can be excessively obfuscative
10:03:08 <Cale> hm?
10:03:17 <Cale> do-notation for IO is perfectly normal.
10:03:31 <yitz> just a list of printf's right now :(
10:03:36 <yitz> * :)
10:04:27 <jgt> z0: when is do notation excessively obfuscative?
10:04:34 <Cale> Now, using do-expressions to denote functions, that might be weird
10:04:51 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
10:04:53 <lambdabot>  ("hello","olleh","HELLO")
10:05:14 <Cale> Wouldn't usually recommend it
10:05:43 <jgt> I've never seen code written that way in the wild :P 
10:05:44 <Cale> But any time that you're using a monad, do-notation is probably nicer than writing out chains of (>>=)'s
10:05:52 <yitz> I'm a complete and utter noob to Haskell. My plan is to work through Protect Euler in Python, Golang and Haskell in parallel. The first two languages should be simple
10:06:14 <jgt> everyone is a noob at some point
10:06:31 <jgt> best thing to do is not flirt with the language; just get stuck in
10:06:39 <yitz> I'm finding 'do' and lambdas and what a Main and module is as I go. it's very haphazard and exciting
10:07:19 <yitz> Euler is my attempt to get stuck in it a bit
10:08:48 <yitz> Python/Go is more for benchmarking my results and for the sake of completeness more than anything else
10:10:47 * hackage table-layout 0.8.0.4 - Layout text as grid or table.  https://hackage.haskell.org/package/table-layout-0.8.0.4 (muesli4)
10:11:47 * hackage integer-logarithms 1.0.3 - Integer logarithms.  https://hackage.haskell.org/package/integer-logarithms-1.0.3 (phadej)
10:19:26 <__monty__> yitz: Consider other coding exercise sites too. Euler's more about maths and knowing algorithms. I doubt it'll allow you to experience the things haskell is great at.
10:20:20 <yitz> that's a good point. thanks
10:22:33 <yitz> got any top recommendations?
10:22:50 <TBG> @curry (\a b -> (a, b))
10:22:50 <lambdabot> Unknown command, try @list
10:23:04 <TBG> @fp (\a b -> (a, b))
10:23:04 <lambdabot> Maybe you meant: wn v rc pl id faq do bf @ ? .
10:23:15 <TBG> @dp
10:23:15 <lambdabot> Error: expected a Haskell expression or declaration
10:23:22 <__monty__> yitz: I liked the hardest exercises for haskell on codewars.com, hear many people favor exercism.io.
10:23:38 <TBG> Those must be impossible
10:23:47 <TBG> I hope to be that good one day
10:23:49 <yitz> cute name. I'll check those out
10:24:01 <TBG> @help
10:24:01 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:24:04 <TBG> @list
10:24:04 <lambdabot> What module?  Try @listmodules for some ideas.
10:24:41 * yitz heads out to commute to work
10:24:44 <TBG> @pl  (\a b -> (a, b))
10:24:44 <lambdabot> (,)
10:24:49 <TBG> Oh reee
10:25:08 <TBG> Didn't know that was the desugaring 
10:26:51 <lavalike> TBG: there's an extension to enable (x,) and (,y) too
10:28:16 <TBG> Nice
10:28:25 <TBG> I was trying to do something like (,y) 
10:28:29 <TBG> I'm flipping (,) 
10:28:40 <lavalike> reasonable
10:28:47 <lavalike> :t flip (,)
10:28:48 <lambdabot> b -> a -> (a, b)
10:28:55 <TBG> Cool
10:29:11 <TBG> Does it have the extension enabled
10:29:14 <ProofTechnique> You can also enable TupleSections and write (,y) directly
10:29:21 <TBG> Yeah they said that
10:29:24 <TBG> :t (,y)
10:29:25 <lambdabot> t -> (t, Expr)
10:29:28 <lavalike> :t let x = "maybe?" in (x,) 10
10:29:29 <lambdabot> Num t => ([Char], t)
10:29:30 <TBG> Nice
10:29:35 <lavalike> > let x = "maybe?" in (x,) 10
10:29:37 <lambdabot>  ("maybe?",10)
10:29:40 <TBG> It has the extension enabled
10:30:09 <TBG> It's weird being on irc
10:30:13 <lavalike> haha why
10:30:28 <TBG> I haven't used it for a while
10:30:33 <lavalike> welcome back!
10:30:50 <TBG> Last time I used it was writing something that sent messages on an mc server to an irc
10:30:55 <TBG> And vice-versa 
10:31:04 <hpyCdr> If I have a conduit of a file that emits a Bytestring holding the whole file's data, where's the streaming happening? I expected the conduit outputting chars / lines
10:31:11 <lavalike> what's an mc server?
10:31:16 <ProofTechnique> Minecraft
10:31:35 <lavalike> I was thinking midnight commander but that couldn't be it.
10:32:33 <TBG> https://xkcd.com/1312/ this is so sad
10:32:47 <ProofTechnique> .oO(I suppose if you think of your machine as a midnight commander server, then every IRC client sends messages from an mc server to IRC)
10:34:41 <TBG> oof
10:46:10 <orion> Anyone know why this persistent template is failing the compile?: https://gist.github.com/centromere/3a394c1196eca69d7b4901b18e602447 The error is: "Unknown column in primary key constraint: "Id"".
10:46:39 <orion> I need to have a "Primary" definition in my schema, because I want to reference that table via a Foreign key constraint in another table.
10:49:10 <Coaster[m]> orion: it supposed to start with lower case
10:51:16 <orion> Coaster[m]: If I change it to "id" instead of "Id", I get this compilation error: Multiple declarations of ‘UserId’
10:51:47 * hackage parsix 0.2.1.0 - Parser combinators with slicing, error recovery, and syntax highlighting  https://hackage.haskell.org/package/parsix-0.2.1.0 (OlleFredriksson)
10:59:12 <orion> Coaster[m]: Also, the documentation confirms that "Id" is the correct way: https://github.com/yesodweb/persistent/blob/master/docs/Persistent-entity-syntax.md#change-tablecollection-key-definition-field-name-andor-type-persistent--21
11:00:43 <stefan_> Hi all, I tried to registerise GHC for the s390x architecture. In unregisterised mode GHC works as expected. Now, I added a register mapping in MachRegs.h and also added StgRun/StgReturn functions. Beside configure script changes that's it basically. Of course, after a stage2 build (GhcEnableTablesNextToCode=NO) I run into a segfault. Anyone has a pointer which is missing for a preliminary registerized 
11:00:50 <stefan_> version of GHC?
11:14:39 <Welkin> is there something about macos filenames that I need to know? I changed a directroy name from "XMPP" to "Xmpp", which to macos is the same thing (because the mac filesystem is case insensitive for some unknown reason)
11:15:10 <Welkin> and now I get compiler errors where the compiler thinks the old name is still in effect, but if I switch the name back, it complains in the other direction
11:15:50 <zachk> I thought os x was a certified unix, and I used to believe unix had case sensitive file names 
11:15:52 <Welkin> (this is the elm compiler, but I thought I'd ask here anyway)
11:16:15 <Welkin> however this only happens for one file
11:16:17 <Welkin> not all of them
11:16:42 <zachk> :(
11:16:55 <geekosaur> you may need to purge .hi files which have the old name, because while the filesystem treats the names as the same, ghc is internally case dependent
11:16:58 <Welkin> it's sad that the state of computing today is "No idea. Try turning it off and on again"
11:17:02 <geekosaur> including comparing filenames
11:17:13 <Welkin> I already cleared the elm cache
11:17:23 <Welkin> I'm running the binary, not compiling the compiler
11:17:27 <geekosaur> this comes up on both windows and macos, somewhat more on the latter because unixy stuff does assume case matters
11:18:11 <geekosaur> I don't know enough about elm but it sounds like something still has names cached somewhere
11:23:54 <Welkin> thanks 
11:24:42 <Welkin> I just figure out it was being caused by another module importing the old name, which is probably an obscure compiler bug of some sort
11:26:16 <vivit> Is it possible to use the  `data` keyword to define a type with a type variable while restricting the type class of that variable?
11:26:35 <Welkin> technically yes
11:26:41 <Welkin> but why would you?
11:26:52 <Welkin> it's better o place the typeclass constraints on functions
11:28:13 <vivit> Say I want to define a "Point" type as a coordinate pair, but I don't want to have to worry about what type of (real) number I use as those coordinates.
11:28:34 <Welkin> define a type family
11:29:21 <vivit> eugh extensions
11:29:31 <vivit> I have my hands full learning vanilla haskell as it is
11:29:47 <Solonarv> you don't even need any extensions for this
11:29:52 <Welkin> several ghc extensions are de facto part of haskell these days
11:30:12 <Solonarv> just 'data Point a = Point { x :: a, y :: a }'
11:30:13 <vivit> Hmm
11:30:21 <Welkin> for example, you can't even use ST without Rank2/N types
11:30:36 <Solonarv> then you can have functions like 'addPoints :: Num a => Point a -> Point a -> Point a'
11:30:53 <vivit> Solonarv: yes but I want to restrict a so that a is a member of typecalls num
11:30:54 <Welkin> but yes, Solonarv's suggestion is better
11:31:07 <vivit> s/call/clas
11:31:22 <Solonarv> put the appropriate constraints on the functions that manipulate Points
11:31:38 <Solonarv> Haskell data types are dumb bundles of data
11:31:49 <Solonarv> they don't do any actual work
11:32:01 <Solonarv> so it doesn't make much sense to put constraints on them
11:32:43 <zzz> ok so I have a number of functions composed together `j.i.h.g.f` and some of them may error `error "some string"`. Is there an orthodox way i can make `k = j.i.h.g.f` return either Left if there's an error along the chain or Right of there's not? 
11:33:05 <Solonarv> zzz: ideally, stop using 'error' for failute
11:33:14 <Solonarv> there's no way to catch errors in pure code
11:33:59 <Solonarv> you could change the functions to return 'Left "error message"' on failure, and compose them using >=> or <=<
11:34:00 <bdesham[m]> zzz: if you're able to use `throwError` instead of `error`, you can use the `Monad` instance of `Either`
11:34:39 <Solonarv> (thisis the same thing as bdesham[m]'s suggestion)
11:35:39 <zzz> so that's the current best practise
11:36:18 <Solonarv> can also use Maybe if you don't need to distinguish different errors
11:36:43 <zzz> ok thanks. there's so much information about error handling online that I kind of got lost
11:37:45 <Solonarv> 'error' is pretty much the worst way to do error handling, tbh
11:40:27 <jle`> 💤 error is not meant for errors, it's actually mostly meant for debuggings, or when things go so wrong that you abort the entire program
11:40:32 <jle`> * zzz ^
11:41:10 <jle`> zzz it looks like you are already familiar enough with Either so that you can have j/i/h/g/f use Either instead of bottom for failure cases
11:41:20 <jle`> so you can use some combiation of <=< and fmap
11:41:43 <jle`> oops i basically repeated what two other people said, sorry
11:42:51 <vivit> hmm
11:43:11 <vivit> Say I define  data Point a = { x :: a, y :: a }
11:43:21 <vivit> And then wanted to define a circle in terms of that definition of point
11:43:49 <vivit> Would it be  data Circle a = { center :: Point a, radius :: a }?
11:44:04 <jle`> that's a good way to do it :)
11:44:05 <ProofTechnique> You need a data constructor, but yes
11:44:23 <ProofTechnique> Unless we got anonymous records and no one told me :D
11:44:32 <vivit> Doesn't the data definition creata a data constructor?
11:45:04 <geekosaur> "Point" there is the type constructor
11:45:13 <vivit> ahhh okay
11:45:20 <ProofTechnique> Point on the left hand side is a type constructor. data Point a = Point { x :: a, y :: a}
11:45:30 <jle`> ah yeah, data Point a = MkPoint { x :: a, y :: a }, data Circle a = MkCircle { center :: Point a, radius :: a }
11:45:40 <ProofTechnique> On the right hand side, you have a data (or value) constructor also called Point
11:45:42 <jle`> also fwiw, x and y are not really the best names for record fields
11:45:51 <geekosaur> also it can be confusing to use the same name for both type and data constructor, even though it's convenient
11:46:20 <jle`> you're going to run into a lot of annoying things if you use x and y, heh
11:46:49 <Welkin> lol jle` 
11:46:56 <Welkin> are you sure you didn't fall asleep there?
11:46:57 <vivit> data Point a = Pt { xCoord :: a, yCoord :: a }
11:47:23 <vivit> data Circle a = Circ { center :: Point a, radius :: a }
11:47:26 <jle`> Welkin: my chat client inserts emojis based on text codes ;_;
11:47:30 <Welkin> haskell needs anonymous records
11:47:43 <Welkin> and, well, proper records
11:48:00 <vivit> How would that be?
11:48:37 <ProofTechnique> vivit: Looks good
11:49:04 <vivit> How's the naming; are "Pt" and "Circ" too arcane?
11:49:18 <vivit> I know I've picked up bad habits from reading old C codebases
11:51:42 <jle`> i've seen a lot of different conventions for constructor names
11:51:50 <bdesham[m]> vivit: MkPoint and MkCircle would be idiomatic (in my limited experience)
11:52:17 <jle`> Pt and Circ are fine, i've also seen Point and Circle (same name as type) so that it's easier to remember, and also MkPoint and MkCircle, and also P and C some palces
11:52:39 <jle`> there isn't much of a consistent convention across different projects. but it's good to keep the same convention within the same project however
11:54:05 <Phyx-> .
12:05:29 <zzz> well, I'm doing `f :: [a] -> Either SomeError [b]` where f is doing something like `f (x:xs) | somePredicate x = SomeB : f xs | otherwise = Left MyError
12:06:06 <zzz> how would I turn the successful result into a Right?
12:06:37 <kaol> return it.
12:07:30 <zzz> kaol: what do you mean?
12:10:39 <zzz> just noticed that my otherwise won't work
12:11:01 <zzz> it'll try to inject a Left into the list
12:11:37 <kaol> Have you looked into using mapM?
12:14:36 <zzz> oh man. I see that converting my functions from erroring to producing Eithers is going to take more work than i predicted
12:16:38 <bjs> zzz: it's just now whenever you would have applied `f x` before, you need to deal with the case that "f might error or succeed now",  some functions like fmap and (>>=) make this easier (the so called Functor and Monad interfaces)
12:16:38 <Solonarv> for that function, you can do something like:
12:16:38 <Solonarv> f (x:xs) | somePredicate x = fmap ((:) SomeB) (f xs)
12:16:38 <Solonarv>          | otherwise       = Left MyError
12:16:47 <Solonarv> (here I used fmap)
12:20:28 <wolfman154> Hello guys, here’s my xmonad.hs config file, what is the syntax to add a key binding to the gracefulExit function? https://hastebin.com/uratufurez.rb
12:21:42 <__monty__> wolfman154: What have you tried and what are the errors?
12:23:43 <yushyin> see? :D
12:24:15 <wolfman154> __monty__: I don’t know what to try, that’s why I’m asking the question here, dmwit told me that all I need to add to this code is a key binding to gracefulExit?
12:24:32 <MarcelineVQ> yushyin: nostradamus walks among us :>
12:26:08 <__monty__> wolfman154: You have a ton of keybindings already there. Try mimicking one of them.
12:26:19 <Xunie> Let's say I make a data construct, how do I prevent errors from this from creeping in?
12:26:19 <Xunie> https://gist.github.com/Xunie/489ace9c7eaaaa1cfdd12410f1705c54
12:26:33 <wolfman154> __monty__: the point of this code is to get xmonad to do shutdown itself and all applications gracefully.
12:26:55 <Xunie> Can I remove this arbitrary "Chan" constructor or override it somehow and not define it for x > 255?
12:28:13 <bsima> Xunie: you want to provide an upper limit to the Integer?
12:28:30 <bsima> one option is just to create a constructor function that checks the value
12:28:31 <Solonarv> Xunie: in this particular case, there is a better choice than 'Integer' for the field type
12:28:37 <geekosaur> one way is to use Word8 instead, but that will often truncate instead. the right way to do it is not to export the constructor, and instead export a smart constructor that checks it
12:28:44 <MarcelineVQ> Xunie: https://wiki.haskell.org/Smart_constructors Can ensure a safe starting value, but you still need to make sure your functions respect the limits
12:29:04 <__monty__> wolfman154: To be frank, I don't care what the point of the code is. You asked for syntax for key bindings while giving a configuration that already has that syntax. Just try to figure it out. That's not too much to ask. Once you've tried and failed you can ask again, except then you might be able to ask a better question.
12:29:19 <Xunie> bsima, I just want to prevent invalid use of a constructors, that's all.
12:29:44 <Solonarv> in this case the "smart constructor" approach seems right
12:29:45 <geekosaur> for it to depend on a value requires dependent types, which Haskell doesn't have
12:29:46 <Xunie> In THIS particular case it means I want to add a upper limit to the value.
12:30:12 <Solonarv> which means: you write a function like 'mkChan :: Integer -> Maybe Chan' which checks that the value is in bounds, and you don't export the Chan constructor
12:30:22 <wolfman154> geekosaur: here’s my xmonad.hs config file, what is the syntax to add a key binding to the gracefulExit function? https://hastebin.com/uratufurez.rb
12:30:52 <geekosaur> yes, I saw it earlier. and I'm inclined to agree with __monty__: at some point you should learn what's going on, since you have 9 examples of how to do it in there already
12:30:56 <Xunie> Solonarv, okay, but what if it's out of bounds? What does it return?
12:31:03 <Solonarv> Xunie: Nothing
12:31:05 <wolfman154> geekosaur: or do at least know of a link that has instructions on how to do this?
12:31:06 <Xunie> A pure function MUST return something.
12:31:12 <Xunie> Okay, a Maybe monad.
12:31:17 <Solonarv> that's why the return type is 'Maybe Chan' instead of 'Chan'
12:31:26 <Xunie> Oh yeah, sorry. I read past that.
12:31:36 <Solonarv> ...Maybe happens to be a monad, but thinking of it as "a Maybe monad" is not super helpful here
12:31:41 <__monty__> wolfman154: Please read up on what help vampires are. We're more than willing to help *if* you show us you're willing to put in some effort first.
12:32:57 <wolfman154> You guys are not very beginner friendly
12:33:07 <geekosaur> yes, you've asked varianrs of this question multuple times the past few days
12:33:16 <geekosaur> at some pint, it's expected that people start to learn
12:33:40 <geekosaur> "beginner" is fine. "eternal beginner" is not so much
12:34:38 <wolfman154> geekosaur: I’ve only been using xmonad for 5 days, I can only learn things so quickly 
12:34:48 <yushyin> https://wiki.haskell.org/Xmonad/General_xmonad.hs_config_tips#Key_and_Mouse_Bindings http://hackage.haskell.org/package/xmonad-contrib-0.15/docs/XMonad-Util-EZConfig.html
12:34:51 <Lycurgus> wolfman154, that may be but there are others that are worse, in fact in my experience it doesn't get more beginner friendly than here
12:35:54 <Lycurgus> also xmonad has it's own channel here
12:36:42 <Lycurgus> my guess is most xmonad users don't actually code haskell
12:36:55 <Lycurgus> other than the config file
12:37:12 <yushyin> wolfman154: I linked both to you hours ago, did read it?
12:37:54 <Xunie> So effectively. I just have to make the constructor abstract and write a specialized constructor function that uses function guards to return a special "error" for values for which it's not defined?
12:38:38 <Solonarv> Xunie: pretty much, yes
12:39:08 <wolfman154> yushyin: um, I don’t remember getting any links, could you repaste them please, thanks 
12:39:13 <Solonarv> most of the time Maybe is good enough for error-handling here
12:39:36 <Xunie> How does one do that? I still see 'Resistor' being passed into the module definition on that link.
12:39:36 <yushyin> wolfman154: https://wiki.haskell.org/Xmonad/General_xmonad.hs_config_tips#Key_and_Mouse_Bindings http://hackage.haskell.org/package/xmonad-contrib-0.15/docs/XMonad-Util-EZConfig.html
12:40:34 <Solonarv> Xunie: that exports the type only, not its constructors
12:40:52 <Xunie> Just for clarity, how WOULD you export the constructor?
12:41:08 <wolfman154> yushyin: thanks, what section has to do with what I’m trying to do?
12:42:00 <Solonarv> let's assume 'data Bool = False | True' as a simple example
12:42:00 <Solonarv> in an export/import declaration, 'Bool' alone refers only to the type; 'Bool(False)' refers to the type 'Bool' and its 'False' constructor; 'Bool(..)' refers to the type 'Bool' and all its constructors
12:43:20 <Xunie> Only two periods? Not three? That isn't a typo?
12:43:27 <lyxia> two
12:44:10 <Xunie> This is starting to make sense.
12:44:10 <Solonarv> you can of course also list multiple constructors: Bool(False, True)
12:44:19 <yushyin> wolfman154: the first link already links to the relevant section, the second link is short enough to read it all but for you the example from the additionalKeysP function should be of most use to you
12:45:03 <Xunie> With regards to returning an 'error' in a function that produces a particular type 'Chan' (as in my example). Can't I just return an error from /every/ pure function?
12:45:20 <yushyin> wolfman154: because you already make use of it in your config ...
12:45:22 <Solonarv> you can, but it's bad practice
12:45:31 <Solonarv> because you can't catch 'error' calls in pure coe
12:45:35 <Solonarv> * code
12:46:35 <Xunie> Makes sense, Solonarv.
12:47:10 <Xunie> So there's no way to hide this constructor from inside the module itself?
12:47:21 <Solonarv> no, there is not
12:48:01 <Xunie> Seems like there's a lot of implicit information in Haskell on the usage of objects inside a module then.
12:48:23 <Xunie> 'objects' for lack of a better word.
12:48:47 <Solonarv> often you end up putting each significant data type in its own module anyway
12:48:51 <vivit> Is there a way to make a rational into a fractional?
12:48:52 <geekosaur> there's a lot of implicit information in every language, because you'd go insane having to always fully specify eveyr little thing
12:48:58 <Solonarv> vivit: fromRational
12:49:23 <vivit> No, that's the other way around
12:49:26 <Solonarv> :t fromRational -- this is also used to desugar floating-point literals like 42.0
12:49:26 <Xunie> geekosaur, my old man has coded COBOL long ago.
12:49:27 <lambdabot> Fractional a => Rational -> a
12:49:32 <Xunie> So I know what you mean. xD
12:49:46 <geekosaur> so did I once
12:49:51 <Solonarv> vivit: I thought you wanted to "make a rational into a fractional"? that's exactly what fromRational does
12:49:56 <Xunie> I heard there's good money on that, but it ain't exactly future-proof. :P
12:50:01 <vivit> Oh derp
12:50:04 <Xunie> s/on/in/
12:50:07 <geekosaur> it's even more implicit in some ways, there's a lot of magic hidden in data definitions
12:50:22 <Xunie> So, Solonarv, to bug you a little more.
12:50:26 <vivit> I thought itw as the other way around
12:50:40 <Solonarv> Xunie: go ahead
12:50:45 <Xunie> What should I do then if it doesn't make sense for a function to be defined over a particular domain? 
12:50:50 <vivit> :w
12:50:59 <Xunie> Should I just not define it? Or make an edge case using 'func _ = error "blahblah"'?
12:52:06 <Solonarv> the two main techniques are making the domain smaller (define a new, more restricted type, and change the function to accept that instead) - or making the codomain larger, e.g. changing the return type to Maybe Foo and returning Nothing when the input is invalid
12:52:11 <wolfman154> here’s the syntax I have so far, is it correct?  (“M-S-q”, gracefulExit “windowIDs”)
12:52:40 <__monty__> wolfman154: Who knows? Maybe just try it.
12:53:21 <__monty__> The great thing about haskell is the type system'll tell you what if anything is wrong with it.
12:54:42 <geekosaur> Xunie, the latter. you need dependent types to get fancier… but then you need to provide proofs that your values are valid
12:55:04 <Xunie> geekosaur, okay now hang on cowboy. I'm just a beginner. This is only my first rodeo.
12:55:17 <wolfman154> __monty__: it does not compile., so how would I change the syntax for it to work correctly, I’m not trying to be a ‘help vampire’ , I’m just trying to finish setting up xmonad so I don’t have to worry about it anymore 
12:55:24 <geekosaur> but you're asking about something that turns out to be fairly advanced
12:55:26 <koz_> geekosaur: I like to think of it as 'me having to treat GHC like a first-year logic student'. :P
12:55:45 <__monty__> wolfman154: Share the error. That's how we'll be able to help you.
12:55:57 <geekosaur> "but it ought to be able to do X" when X turns out to be a lot more involved than you think
12:57:13 <wolfman154> geekosaur: so that means I am going to have to do more than just add a key binding to gracefulExit?
12:57:20 <Xunie> Solonarv, I feel like I'm being a help vampire on this one, but I feel like no resource helps me. Sorry for being a doofus about this.
12:57:29 <Solonarv> Xunie: nah, you're fine
12:57:44 <Xunie> But lets say I have a funcion that takes a defined type? How do I access a variable member of that?
12:57:45 <geekosaur> wolfman154, sorry, is everything I say necessarily directed at only you?
12:58:09 <Solonarv> let's use a simple example function here:
12:58:10 <Solonarv> squareRoot :: Double -> Double -- pretend that NaN doesn't exist
12:58:12 <geekosaur> yoyu are doingv somethings imple that you have done before, and apparently still do not know what you did yesterday
12:58:25 <Xunie> (What about Inf? :P)
12:58:38 <Solonarv> clearly this can't be a total function: negative inputs don't have a square root
12:58:50 <__monty__> Sure they do : >
12:59:09 <Solonarv> (infinity isn't relevant here, we can just say that sqrt(infinity)=infinity)
12:59:14 <__monty__> Oh, not in the context, sorry.
12:59:18 <Xunie> __monty__, lets constrain ourselves to the real domain for the purposes of this shall we? :p
12:59:28 <wolfman154> geekosaur: I thought you meant X that comes after gracefulExit, sorry.   https://hastebin.com/uratufurez.rb
13:00:47 <Solonarv> so here we have two options:
13:00:47 <Solonarv> 1) change the function to only accept positive inputs: sqrt :: PositiveDouble -> PositiveDouble
13:00:47 <Solonarv> 2) change the function to be able to error out when given a negative input: sqrt :: Double -> Maybe Double
13:01:22 <Xunie> Well yes. I know what you meant by "change the input type to have a smaller domain or change the output type to have a bigger domain" explanation.
13:01:46 <Solonarv> oh, oops
13:01:53 <Xunie> My question with regards to accessing members relates to something very simple.
13:02:01 <Habib> I wanna take back what I said on Saturday about Clever Cloud's product offering for Haskell just not working. The problem I was experiencing was my fault, as I have a monorepo with a separate Server and Client folder for two wholly different apps. Clever Cloud ran all the stack commands within the repo root, which was not the actual Haskell app.
13:02:14 <Xunie> Let's say I have a function 'get :: Chan -> Integer' which will return the channel intensity. 
13:02:38 <Xunie> How do I 'get chan = ???'
13:02:47 <Solonarv> aaah, I see
13:02:59 <Xunie> What magic incantation do I use to conjure up the computer spirits to let me return an internal variable? :p
13:03:12 <Cale> Xunie: get chan ?
13:03:15 <Habib> Even my complaint about their support being unresponsive was a bit short-sighted. It was the weekend at the time, which I had failed to take into account, though it would be great if they offered weekend support. My comment about no automated message telling me when I can expect a support response stands, though.
13:03:18 <Solonarv> you'll have to define that function in the same module as the Chan data type, so that its definition has access to the constructor
13:03:23 <Xunie> Cale, https://gist.github.com/Xunie/489ace9c7eaaaa1cfdd12410f1705c54
13:03:37 <Cale> Xunie: If you have a function of type Chan -> Integer, and you have a value of type Chan, then you can apply the function to the value
13:04:01 <Xunie> Cale, yeah, but I don't know how to define the function that takes a Chan and spits out the Integer inside of it!
13:04:10 <Cale> You've already defined it in that code
13:04:15 <Cale> It's called intensity
13:04:24 <Xunie> ohhhhhh wait hang on
13:04:26 <Cale> But if you hadn't, you could also write
13:04:38 <Cale> intensity (Chan n) = n
13:04:43 <Solonarv> Cale: this is a follow-up to an earlier question about hiding a constructor and exporting a smart constructor instead
13:04:53 <Xunie> Cale ahhhhhhhhhhhhhhhhhhhhhhhhhhh
13:05:14 <Xunie> Well, this is all starting to make a lot of damn sense.
13:06:03 <bdesham[m]> Xunie: sometimes the "thing" inside the record type is named with "get" for just this reason. for example, data Chan = Chan { unChan :: Integer }. this would be a confusing name in your particular case, but the idea is that "unChan" or "intensity" is a function that takes a Chan and returns an Integer
13:06:23 <bdesham[m]> oops, I meant to write "getChan". you'll see "unChan" sometimes too though
13:06:40 <MarcelineVQ> or even runChan
13:06:43 <Xunie> bdesham[m], yeah, it's implicitly defined when I create those members.
13:07:01 <Xunie> And once again: I probably can't hide them inside the module but by default they're not exported anyways so that shouldn't be an issue.
13:07:06 <bdesham[m]> exactly
13:07:24 <Xunie> Okay, this has given me a lot of tools to do what I want to do.
13:07:34 <bdesham[m]> I should mention that usually you'll only see unChan, runChan, getChan etc. in the case of a record type with a single field
13:07:44 <Cale> Xunie: You're also allowed to export the field extraction function even if you don't export the data constructor
13:08:25 <Xunie> Cale, so I can define types and not constructors and let people use a field extractor function to get access at fields without constructing anything.
13:08:44 <Xunie> Makes sense. I thought that was clear as no one told me I couldn't? :p
13:09:31 <Solonarv> Cale: doesn't that enable record update syntax to be used?
13:09:39 <Cale> Nope
13:09:48 <Solonarv> oh, good!
13:09:49 <Cale> Or at least, it shouldn't...
13:09:59 <Xunie> Thanks a ton guys. You've given me the tools I need. Gonna go try and hammer some nails, see if I can build something.
13:10:00 <Cale> If it does, that's pretty bad :D
13:10:13 <Xunie> Especially you, Solonarv :p
13:12:56 <Xunie> One last thing: Let's say I have a bunch of functions that mutate a data type a lot and some only change a single internal variable. How would I go about taking that datatype and only modifying the appropriate variable that I want to modify without having to manually boiler plate the 5 other member variables of that type I just want pass through unmodified?
13:13:21 <Solonarv> that's what record update syntax is for
13:13:25 <dmwit> For records, `x { y = z }` is a copy of `x` with field `y` changed to value `z`.
13:13:57 <wolfman154> __monty__: ok so here’s my attempt at add a key binding to gracefulExit on line 36 of the first link and the second link is the error: https://hastebin.com/utokejaxur.rb          https://hastebin.com/ateyirihuf.rb
13:14:03 <dmwit> If your type is not a record, you may write a function with the usual pattern-matching syntax that does what you want.
13:14:09 <Solonarv> Cale: looks like record update syntax does work if you only export the accessor
13:15:16 <wolfman154> dmwit: there you are I just posted the two links of my attemp at adding a key binding to gracefulExit?
13:15:22 <__monty__> wolfman154: Ok, so that's not the full error message. That'd be in the logs.
13:15:49 <__monty__> wolfman154: But, it's because you're passing an argument to `gracefulExit` which expects none.
13:16:03 <__monty__> wolfman154: So next step, remove the "X".
13:16:34 <Solonarv> Cale: https://gist.github.com/Solonarv/fb5aef36de8267f1d69fe5e9102046d6
13:16:36 <Xunie> dmwit, well, apparently I *do* have a record on my hands, hang on.
13:17:02 <__monty__> And next time share the full error message which you should be able to find with journalctl -u home-manager-wolf.service
13:17:15 <dmwit> Solonarv, Cale: snap, for example, takes advantage of this.
13:17:25 <Cale> Solonarv: interesting, and weird
13:17:32 <Solonarv> yeah, I can see how that'd be useful
13:17:47 * hackage vimeta 0.2.5.1 - Frontend for video metadata tagging tools  https://hackage.haskell.org/package/vimeta-0.2.5.1 (PeterJones)
13:17:49 <dmwit> The documentation is super unclear, because there appear to be just a bunch of `Request -> foo` functions, and nothing to set the value of `foo`. You have to look at the source to see that those functions are actually record accessors, yeesh.
13:18:00 <Solonarv> oof
13:19:08 <wolfman154> __monty__: thanks, at least a little bit of progress, ok I’ll remove “X” then recompile.
13:19:41 <zzz> dmwit: "If your type is not a record, you may write a function with the usual pattern-matching syntax that does what you want." how does pattern matching differ in relation to records ?
13:20:42 <__monty__> zzz: The record definition already gives you those field accessors.
13:20:45 <Solonarv> it can be a bit more verbose/harder to read/easier to mess up if you only care about a few fields
13:21:52 <__monty__> zzz: You can actually do all the pattern matching you'd do to any other type.
13:22:06 <Solonarv> consider the following example data type: data FileInfo = FileInfo { fileName :: String, fileLastModified :: UTCTime, fileOwner :: User }
13:22:57 <Solonarv> you can write e.g. someFile { fileLastModified = now }, to update one field
13:23:13 <dmwit> zzz: If you use record syntax, you get additional features. But features are only added; you can always use non-record syntax, including all the same patterns, even for record types.
13:23:52 <dmwit> (In point of fact, you can also always use record pattern syntax, even for non-records, though there aren't many field names you're allowed to include for non-records! =)
13:23:53 <Solonarv> you could write this without record syntax, too: (case someFile of FileInfo name _ owner -> FileInfo name now owner)
13:24:08 <dmwit> Hm.
13:24:26 <Solonarv> but this is more verbose, and is sensitive to the order of fields, and you need to change it anytime you change the fields of FileInfo
13:26:06 <vivit> So I have a function 'slope :: (Real a, Fractional b) => Line a -> b` and I want to use it to see if two lines are parallel
13:26:31 <vivit> The only problem is that I can't see a way to guarantee that the 'slope' function returns an Eq
13:28:01 <Solonarv> presumable you'd write something like:
13:28:01 <Solonarv> parallel line1 line2 = slope line1 == slope line2
13:28:03 <Solonarv> right?
13:28:48 <Solonarv> and in fact this almost works - but the return type of 'slope' is ambiguous here
13:29:04 <vivit> In that case, the compiler can't deduce that 'slope line1' and 'slope line2' are both of a type in Eq
13:29:17 <Cale> vivit: It will deduce that
13:29:40 <Solonarv> the problem is actually that the compiler can't figure out what the type of 'slope line1' and 'slope line2' is
13:29:44 <Cale> vivit: It will add a constraint to parallel which says that whatever type it is that you ultimately pick, it must additionally be an instance of Eq
13:30:00 <Solonarv> obviously if it doesn't know what the type is it can't figure out if there is an Eq instance for it!
13:30:07 <Solonarv> Cale: the type is ambiguous here
13:30:08 <__monty__> zzz: You'll also notice people often say "record syntax" and when they say "records" they really mean record syntax. This is because haskell doesn't really have proper records, it's mostly syntax sugar.
13:30:11 <Cale> Well, yes
13:30:11 <vivit> Hm
13:30:22 <Solonarv> vivit: there are two approaches to fixing this
13:30:26 <Cale> I was assuming intentionally so -- there's a polymorphic type
13:30:31 <vivit> The problem must have been that I had written an explicit type constraint
13:30:37 <vivit> Removing the type constraint made it work
13:31:03 <Solonarv> "type constraint"? do you mean a type signature?
13:31:16 <vivit> sorry, type signature
13:31:19 <Cale> Ah, I see
13:31:41 <wolfman154> __monty__: it compiled without errors, I am going to reboot nixos then test it to see if it works:  https://hastebin.com/ilaxuhozeg.rb
13:31:50 <Cale> Since the parallel function produces a Bool, it wouldn't have been clear at which type we should evaluate the slopes
13:31:51 <vivit> I had written 'parallel :: Eq a => Line a -> Line a -> Bool'
13:32:13 <__monty__> wolfman154: Fingers crossed.
13:32:15 <Cale> But it is a little bit mysterious that slope can change the type of the result
13:32:37 <Solonarv> yeah, I would expect 'slope :: _ => Line a -> a'
13:32:38 <Cale> Why is it not slope :: (Real a, Fractional a) => Line a -> a
13:32:51 <Solonarv> that would also fix the ambiguity issue
13:33:09 <Solonarv> and is in fact one of the approaches I was going to suggest
13:34:39 <vivit> It's so that if the coordinates of the points of the line arguments happen to have a type in e.g. Integral, it could still produce a result
13:35:35 <wolfman154> __monty__ , dmwit  , I tested it and it shuts down xmonad, how do I know that it’s actually shutting down xmonad and the applications gracefully(correctly)?
13:35:59 <vivit> The definition I gave it was   slope (Ln (Pt x1 y1) (Pt x2 y2)) = fromRational $ (fromRational.toRational) (y2-yq) / (fromRational.toRational) (x2-x1)
13:36:16 <vivit> hmm
13:36:20 <Cale> vivit: That's a reasonable answer, but it also means that the slope may have different types depending on what we ask for. In the case of a function like parallel, there would be no way to tell from outside which type we ought to use. So perhaps you could pick Rational for instance.
13:36:25 <vivit> I guess the outer "fromrational would be unnecessary even there
13:36:35 <Solonarv> indeed it is
13:36:42 <__monty__> wolfman154: Have something like firefox open that has different behavior upon opening after proper exit v. improper exit?
13:36:51 <Solonarv> and (fromRational . toRational) is realToFrac, IIRC
13:36:51 <wolfman154> __monty__ dmwit               https://hastebin.com/ilaxuhozeg.rb
13:36:54 <Cale> yes
13:36:59 <vivit> oh derp
13:37:33 <Solonarv> so this becomes: realToFrac (y2-y1) / realToFrac (x2-x1)
13:37:46 <wolfman154> __monty__: ok, thanks for the tip, I’ll test it out now!!!
13:37:53 <vivit> yes
13:39:47 * hackage playlists-http 0.2.1.1 - Library to glue together playlists and http-client  https://hackage.haskell.org/package/playlists-http-0.2.1.1 (PeterJones)
13:43:48 <vivit> Hmm, it looks like lots of problems in my code are clearing up as I'm removing type singatures...
13:44:02 <vivit> What's the purpose of explicit type signatures again?
13:44:15 <zzz> vivit: lol
13:44:20 <Heffalump> documentation, and to help you find type errors by writing down the type you think something should have
13:44:36 <MarcelineVQ> Meaning what you say, but if you don't know what you mean yet there's a clash
13:44:49 <c_wraith> they're not just documentation, they're *correct* documentation. :)
13:44:59 <Solonarv> I suspect you've simply written down incorrect type signatures in some places, as you did for 'parallel' above
13:45:36 <Solonarv> you can use _ to "stub out" parts of a type signature (or the entire signature), and GHC will tell you what type it inferred there
13:46:08 <TBG> @fp (\(a:b) -> (a, b))
13:46:08 <lambdabot> Maybe you meant: wn v rc pl id faq do bf @ ? .
13:46:18 <TBG> @fl (\(a:b) -> (a, b))
13:46:18 <lambdabot> Not enough privileges
13:46:23 <TBG> Excuse me what
13:46:24 <Solonarv> TBG: what are you trying to do?
13:46:34 <TBG> Convert a list of length 2 to tuple
13:46:48 <TBG> Wait
13:47:05 <zzz> TBG: (a:b:[]) or [a,b]
13:47:15 <Solonarv> (a:b) does not match a two-element list, it matches a list of length >= 1
13:47:21 <TBG> Oh lol lol
13:47:34 <Solonarv> but I meant to ask what lambdabot plugin you're trying to use there
13:48:01 <TBG> Tuple is traversable so I don't think I have to do this any way
13:48:13 <Solonarv> the "point-free" plugin is pl (short for "pointless")
13:48:23 <TBG> Yeah
13:48:31 <Solonarv> note that the Traversable instance for tuples only "works with" the last element
13:48:39 <TBG> Oh I didn't know
13:48:44 <TBG> So I'll have to use list
13:48:45 <Solonarv> % traverse print (1, 42)
13:48:46 <TBG> @pl (\(a:b:[]) -> (a, b))
13:48:46 <lambdabot> (line 1, column 8):
13:48:46 <lambdabot> unexpected "["
13:48:46 <lambdabot> expecting "()", natural, identifier, "_" or "("
13:48:46 <yahb> Solonarv: 42; (1,())
13:48:51 <TBG> Wait oof
13:49:14 <TBG> @pl \(a:b:x) -> (a, b)
13:49:14 <lambdabot> ap ((`ap` tail) . (. head) . (const .) . (,) . head) tail
13:49:16 <TBG> Ouch
13:49:28 <Solonarv> ah, it looks like the @pl plugin doesn't handle pattern matching against lists like that :/
13:49:34 <Solonarv> also, oof indeed
13:50:04 <wolfman154> __monty__: so I have some tabs open in firefox, when I do: (mod+shift+g) to trigger a graceful (correct) exit firefox still tells me: (sorry we’re having trouble getting your pages back) (restore session), I don’t think it’s working correctly?
13:50:06 <TBG> Are you responsible for this bot in any way?
13:50:11 <Solonarv> not at all
13:50:18 <TBG> Oh u know so much about it
13:50:36 <TBG> So is there some function or should I just write a lambda 
13:50:43 <__monty__> wolfman154: Have you tried making the timeout something silly, like 10s/30s?
13:50:54 <Solonarv> writing a lambda seems reasonable to me
13:51:04 <wolfman154> __monty__:                         https://hastebin.com/ilaxuhozeg.rb
13:51:44 <Solonarv> although keep in mind that (\(a:b:_) -> (a,b)) will produce an error if applied to a zero- or one-element list
13:51:48 <MarcelineVQ> (\(x:y:[]) -> (x,y)) is about as direct as it gets if you don't care about whether the list actually has two elements
13:52:09 <wolfman154> __monty__: are you talking about the threadDelay?
13:52:13 <TBG> Ye
13:52:15 <TBG> pairs <- many $ (\(a:b:[]) -> (a,b)) <$> sequence [jsonP <* (eatWhiteSpaceAround $ eatChar ':'), jsonP <* (eatWhiteSpaceAround $ eatChar ',' `orP` eatChar '}')]
13:52:16 <TBG> Lol
13:52:28 <Solonarv> MarcelineVQ: that one does very much care about the list having precisely two elements
13:52:35 <__monty__> wolfman154: Yes. Make it something large so we're sure we're not dealing with a race condition.
13:52:44 <TBG> ? wolfman
13:52:48 <Solonarv> TBG: oh, there's a much better way to write this
13:53:06 <MarcelineVQ> Solonarv: Sorry I mean if one doesn't care that it can explode
13:53:21 <wolfman154> __monty__: like: 10000000000
13:53:41 <Solonarv> pairs <- many $ liftA2 (,) (jsonP <* (eatWhiteSpaceAround $ eatChar ':')) (jsonP <* (eatWhiteSpaceAround $ eatChar ',' `orP` eatChar '}'))
13:53:44 <wolfman154> __monty__:   ?
13:53:50 <TBG> Oh nice
13:54:06 <__monty__> wolfman154: Well, not that silly. Just add a 0, maybe 2.
13:54:33 <TBG> Nice to have specific functions like that
13:55:01 <TBG> Not sure when I started getting serious about haskell
13:55:10 <TBG> I think it was only 3 weeks ago or smt
13:55:16 <wolfman154> __monty__: 50000000, like this?
13:55:22 <__monty__> Sure.
13:56:16 <TBG> Imagine having liftA230
13:56:37 <Solonarv> I think they are defined up to 7 or so
13:56:45 <TBG> Hehehe
13:56:55 <TBG> Would u use sequence after that then
13:57:00 <Solonarv> no
13:57:00 <TBG> Or spam a load of <*>
13:57:08 <Solonarv> the latter
13:57:27 <TBG> Yeah cus of currying i thonk
13:57:27 <Cale> You might use sequence, if all your stuff was of the same type.
13:57:29 <MarcelineVQ> % :set -XMonadComprehensions
13:57:29 <yahb> MarcelineVQ: 
13:57:41 <wolfman154> __monty__: well it goes slower but firefox is still throwing the same error?
13:57:49 <Solonarv> shoving things into a list, 'sequence'ing and then 'fmap'ing something that deconstructs the list seems enormously inelegant and error-prone to me
13:57:56 <TBG> Yeah
13:58:11 <MarcelineVQ> % (\xs -> [(x,y) | (x,ys) <- uncons xs, (y,_) <- uncons ys]) [1,2,3] -- for fun
13:58:11 <yahb> MarcelineVQ: Just (1,2)
13:58:21 <TBG> I think I'm getting ok at applicatives and the other stuff :)
13:58:22 <wolfman154> __monty__: https://hastebin.com/ilaxuhozeg.rb
13:58:36 <TBG> What's the learning curve like
13:58:40 <__monty__> wolfman154: Then I guess killWindow actually *kills* the windows/programs, rather than sending the right signal for graceful exit.
13:59:47 <wolfman154> __monty__: I have been doing this for to long,? I think I’m just going to give up and delete that code 
14:00:01 <wolfman154> __monty__:   :(
14:00:07 <TBG> How long have you ppl been doing haskell
14:00:16 <__monty__> wolfman154: You're close though.
14:00:44 <__monty__> wolfman154: *If* wmctrl does send the right signals you can probably just shell out to that.
14:00:49 <int-e> > (\xs -> [(x, y) | x : ys <- tails xs, y : _ <- tails ys]) [1,2,3] -- sometimes useful
14:00:52 <lambdabot>  [(1,2),(1,3),(2,3)]
14:00:56 <jle`> TBG: for me, around six years or so?
14:00:57 <Solonarv> TBG: I think I first got into it 4 or 5 years ago
14:01:03 <TBG> Wow
14:01:19 <TBG> So what's the learning curve like
14:01:25 <wolfman154> __monty__: I’m confused, what do you mean by that?
14:01:43 <TBG> Is it learning haskell stuff and then a big oof with the monad external stuff?
14:01:48 <__monty__> wolfman154: You were trying to use a program called wmctrl for this yesterday.
14:01:57 <jle`> hm, it took me a couple of months of fiddling around before i was able to do useful things for projects i had
14:02:06 <TBG> e.g?
14:02:08 <jle`> not sure what you mean by monad external stuff :)
14:02:18 <jle`> to be honest, doing useful haskell really requires very little
14:02:20 <TBG> Like databases and GUI libs
14:02:21 <jle`> it just won't be the cleanest
14:02:28 <jle`> what does that have to do with monads? :P
14:02:43 <TBG> Because all impure actions are "monad" stuff
14:02:50 <int-e> don't talk about -----s.
14:03:01 <vivit> *onads
14:03:01 <jle`> TBG: i don't think that's true
14:03:10 <TBG> :thonk:
14:03:19 <int-e> TBG: impure actions are IO.
14:03:32 <wolfman154> __monty__: oh, I forgot to install: wmctrl on nixos , I think that’s why it’s not working?
14:03:39 <int-e> IO happens to be a monad, but that is really completely irrelevant for using IO.
14:03:55 <__monty__> wolfman154: Nah, you're not trying to use wmctrl currently.
14:04:07 <int-e> (It allows using the 'do' notation.)
14:04:34 <jle`> it's also a semigroup, but nobody ever talks about that useful part of it either
14:04:41 <TBG> Ye it's only IO
14:04:43 <TBG> I thonk
14:04:49 <TBG> But you have to do "monad" stuff
14:04:55 <TBG> As in binding and stuff
14:05:02 <jle`> i like to think of that as IO stuff
14:05:05 <int-e> I mean I don't want to diminish the concept of monads; monad transformers are really useful. But there's no reason that the concept should get in the way of programming.
14:05:10 <__monty__> wolfman154: Hmm, the docs for killwindow do mention firefox is a special case though.
14:05:13 <TBG> It doesn't
14:05:17 <TBG> gtg
14:05:23 <__monty__> wolfman154: Is the keybinding you're using the same as the default?
14:07:11 <wolfman154> __monty__: no I changed it to (mod+shift+g)
14:07:47 <wolfman154> __monty__:  maybe I should try this instead: https://superuser.com/questions/635166/when-i-quit-xmonad-how-can-i-make-it-shut-down-applications-nicely
14:08:44 <geekosaur> __monty__: no, it mentions that applications like firefox that advetise support for WM_DELETE_WINDOW are handled appropriately. if it's not then most likely they're not waiting long enough
14:09:15 <geekosaur> there was a long discussion about this yesterday
14:09:40 <__monty__> geekosaur: That's why I had him test with an increased timeout first.
14:10:33 <geekosaur> and browsers often do take a while especially if configured to ask before exiting, or running external media that wants to be shut down first, etc.
14:10:44 <zzz> ok so i'm bashing my head against the wall here. I'm confusing myself. I want to find a simple (and sane) way to make my functions return Either instead of erroring. https://gist.github.com/jrvieira/da224c0af92dfbb02a3bb5e1f93393e5
14:11:09 <__monty__> geekosaur: True. wolfman154, try adding another 0 on the timeout.
14:11:18 <geekosaur> chrome in low memory takes several minutes to shut down
14:11:40 <geekosaur> and if that's threadDelay timeout, remember it's in microseconds not milliseconds or seconds
14:11:58 <geekosaur> (that catches practically everyone out)
14:12:26 <__monty__> Ouch. Yeah, then I don't really know a good way to deal with it.
14:12:58 <wolfman154> :(
14:13:32 <wolfman154> maybe I should try this instead: https://superuser.com/questions/635166/when-i-quit-xmonad-how-can-i-make-it-shut-down-applications-nicely
14:13:35 <wolfman154> ?
14:14:09 <wolfman154> That’s the only link I can find on the internet!!!
14:15:30 <__monty__> wolfman154: Actually, try creating a key binding that calls `killWindow firefox'swindowID`
14:15:44 <__monty__> Or try wmctrl.
14:17:56 <wolfman154> I’m going to try the link I just posted, can I copy that directly to xmonad.hs or do I also have to add more code for it to compile?
14:18:24 <__monty__> It's not haskell, so definitely can't just copy it over.
14:20:17 * hackage flat-tex 0.7.0 - flatten a latex multi-file latex document and remove all comments  https://hackage.haskell.org/package/flat-tex-0.7.0 (JohannesWaldmann)
14:20:36 <wolfman154> __monty__: will this work?    spawn "for win in $(wmctrl -l | awk '{print $1}'); do; wmctrl -i -c $win; done" >> io exitSuccess
14:21:08 <__monty__> Looks like it should.
14:24:32 <__monty__> wolfman154: Actually, it seems like the easiest way to get the behavior you want is to run a login manager. Are you using one currently?
14:26:12 <wolfman154> __monty__: no,I removed gnome3 and gdm, because they were not letting my custom keyboard layout load.
14:27:25 <wolfman154> __monty__: I’m just running xmonad.
14:28:06 <eva44> https://yip.su/2u5we5.png
14:28:20 <__monty__> wolfman154: Ok, we can keep trying to plug away at it.
14:28:27 <eva44> https://yip.su/2u5we5.png
14:30:27 <__monty__> SPAM WARNING
14:31:44 <geekosaur> yeh, and already gone
14:37:46 <xldenis> does anyone know of a library that will generate terms from a BNF-like description? I'd like to use that to help quickcheck my parser
14:38:00 <jle`> zzz : i added possible translation of one of your functions
14:38:44 <jle`> zzz : although i'm not sure exactly what you want from lexic.  what is the error case?
14:39:17 <jle`> zzz : also i'd strongly recommend using case statements instead of pattern guards, to ensure totality
14:40:14 <wolfman154> Does this look correct?   https://hastebin.com/alisebobux.rb  
14:40:41 <wolfman154> Using: https://superuser.com/questions/635166/when-i-quit-xmonad-how-can-i-make-it-shut-down-applications-nicely
14:40:47 <wolfman154> __monty__: ?
14:40:57 <wolfman154> geekosaur: ?
14:42:49 <__monty__> geekosaur: Well, the urls are still there. And mighty tempting to click ; )
14:43:37 <__monty__> wolfman154: Nope, I'll let you try to figure out why though.
14:45:09 <bdesham[m]> zzz: I added a comment too. TBH I was only looking at the simplified example, though, so that approach may or may not be useful for the "real" one
14:45:30 <wolfman154> __monty__: I have no idea?
14:46:15 <__monty__> wolfman154: It's not a subtle mistake. Try harder.
14:46:41 <wolfman154> __monty__: indentation?
14:46:55 <__monty__> I just said *not* subtle : )
14:47:18 <zzz> jle`: hey thanks, I'm seeing it now. well I guess lexic is safe but I would want it to propagate any Left it receives. how can we better ensure totality with case statements?
14:48:03 <wolfman154> __monty__: at least throw a hint?
14:48:09 <jle`> zzz : case l of Elem i s -> ...; Multi i -> ...; Over -> ...
14:48:26 <__monty__> wolfman154: Compare to your previous version.
14:48:32 <jle`> 💤 and, what do you mean by any Left it receives?
14:50:28 <wolfman154> __monty__: no semicolons after do and when?
14:51:13 <zzz> jle`: if i somehow chain it with other functions, i would like any error along the chain to propagate
14:51:37 <wolfman154> __monty__: Typo win not when 
14:51:38 <__monty__> That's not it. You can't have a multiline string like that but the bigger problem has nothing to do with the bit of shell script.
14:51:55 <jle`> 💤 you can use a combination of fmaps and <=< and (.)'s to make things all have the right 'shape' to compose
14:51:59 <__monty__> No, you do want win afaik.
14:52:10 <jle`> zzz : for example, if you have an (a -> b), you can turn it into an (Either e a -> Either e b) using 'fmap'
14:52:26 <jle`> so you could do, say, `fmap f . g`, if g is a -> Either e b and f is b -> c
14:53:30 <jle`> zzz : it's common to just leave your 'lexic' as is, and then to "lift" it to the shape that you need whenever you need it
14:53:35 <wolfman154> __monty__: please paste bin the correct syntax, I’m begging you  🤷🏽‍♂️🙏🏽
14:53:52 <MarcelineVQ> __monty__: is this the paste you want him to compare his current one to? https://hastebin.com/ilaxuhozeg.rb
14:53:52 <jle`> the reason is that while it's easy to go from (a -> b) to (Either e a -> Either e b) (using fmap), it's hard to go the other way
14:54:19 <zzz> jle`: nice, I see it
14:54:57 <__monty__> MarcelineVQ: Yes.
14:55:01 <wolfman154> MarcelineVQ:  that’s for something else 
14:55:02 <jle`> zzz : if you need help with a specific chain, feel free to paste or mention it, and we cna find the right combination of ., <=<, fmap, etc. to get it done :)  it's a pretty mechanical process, but admittedly it may be harder when you aren't used to it
14:55:44 <zzz> it's my first time doing something like this, so I'm going to study it and I'll let you know! tanks a lot
14:56:23 <jle`> np :) massaging functions into the right shape using the right higher-order function comes up a lot in haskell, so it's a good thing to try to practice as well
15:04:37 <zzz> on what you said about totality, is it really that riskier to use pattern guards vs case? I mean I can't think of an instance where case statements would prevent it
15:05:04 <zzz> can you expand on that?
15:05:38 <geekosaur> case can have a _ wildcard
15:06:58 <zzz> i'm intrigued geekosaur: how is that different from otherwise?
15:08:03 <geekosaur> otherwise is just an alias for True, used in guards because they're not directly patterns, they're boolean expressions
15:09:55 <zzz> oh! didn't know that. i'm still struggling to come up with an example
15:10:50 <zzz> and I guess we can do something like this ` _ <- x = …` , right?
15:11:03 <zzz> i mean:
15:11:04 <geekosaur> you can but it's kinda pointless as a pattern guard
15:11:14 <zzz> | _ <- x = whatever
15:11:26 <geekosaur> you're matching anything and then throwing the match away, so it's equivalent to using x without a pattern guard
15:11:38 <Jalina> ciao a tutti
15:11:41 <jle`> zzz : i'm assuming you're compiling with -Wall, so if you accidentally forget to handle a case, GHC will warn you
15:12:00 <jle`> although hm, i wonder if it does the same with pattern guards
15:12:07 <geekosaur> (this applies only to pattern guards, as opposed to expression guards where otherwise == True so that guard is always selected at that point
15:12:07 <zzz> jle`: that happens to be the case :)
15:12:08 <zzz> it does
15:12:18 <Jalina> nessuno parla italiano?
15:12:35 <geekosaur> it tries to. exhaustiveness checking is still a little buggy and a lot slow with complex patterns
15:12:52 <geekosaur> and expression guards which it also tries to check for completeness
15:13:45 <geekosaur> (tries, but obviously can't always because it doesn't necessarily know what the expression will evaluate to)
15:23:24 <zzz> ok, so i'm still confused. how and in what instance can a case expression prevent unhandled cases?
15:24:10 <jle`> hm, i think it isn't reliable that ghc will be able to warn you of incomplete pattern guard cases
15:25:15 <cht> Hello! I wrote some MonadState code and I was wondering if there's a more idiomatic way to do it.
15:25:27 <cht> Here's the very short code: https://gist.github.com/ClathomasPrime/25c28df822353a1bd8d0131825986f5f
15:25:38 <jle`> zzz in your case ghc might warn you if you leave off the Over case, but in more complicated cases it might miss something
15:25:40 <cht>  It takes a (stateful) computation which may fail (return a Maybe), and it only lets the computation "actually" alter the state if it succeeds (returns Just)
15:26:19 <cht> Also, can this be elegantly done using ExceptT or the like? 
15:26:25 <c_wraith> cht, usually it's spelled "succeeds", but I'm sure that's not what you were asking about. :)
15:27:01 <jle`> cht: it can be done using MaybeT's Alternative instance, but i don't think you'd gain much from using that here in this case
15:27:47 <jle`> er actually, maybe not
15:27:56 <c_wraith> cht, as a micro-cleanup, "foo >> return bar" is "bar <$ foo"
15:28:15 <MarcelineVQ> zzz: when you have the incomplete patterns ghc warning enabled https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wincomplete-patterns
15:28:35 <jle`> small cleanups you can do here too, you can do res <- m; when (isNothing res) (put us); return res
15:28:39 <MarcelineVQ> ah jle` mentioned -Wall earlier
15:28:46 <jle`> s/us/s
15:29:21 <jle`> on a higher level, you can design for (MonadState s m, Alternative m)
15:29:41 <jle`> then you can do performIfSucceeds m = m <|> pure Nothing
15:29:54 <jle`> then you can use a backtracking choice of monad m
15:30:22 <jle`> that is, a choice of monad m where <|> will 'restore the original state' on an error
15:30:45 <jle`> but here you are just offloading your backtracking behavior to the future Alternative instance you eventually pick
15:31:38 <jle`> so, if you want to guarantee backtracking (instead of leaving it up to the choice of m), then writing it the way you have it now is is good :)
15:32:07 <jle`> (an example of an instance of MonadState s m *and* Alternative m that is backtracking is `StateT s Maybe`)
15:32:41 <jle`> (but an example of an instance of MOnadState s m and ALternative that is *not* backtracking is `MaybeT (State s)`)
15:33:20 <cht> c_wraith, jle` thanks for the cleanups! Sounds like this function is not a standard notion at least
15:34:02 <cht> jle`, understanding those last two examples sounds like a perfect exercise for me :) 
15:35:08 <cht> I'll probably either use it as written (approximately) or try to use an ExceptT version of it
15:35:10 <jle`> er, my 'alternative' performIfSucceeds is wrong, performIfSucceeds m = (maybe empty (pure . Just) =<< m) <|> pure Nothing
15:35:33 <jle`> MaybeT or ExceptT won't help you here, because wrapping MaybeT gives you *short-circuiting* behvaior, but not backtracking behavior
15:38:37 <cht> Ah you're right... Basically there's no way to "within the monad" get a "m (Maybe a)" if all you have is "MonadError e m"
15:38:47 <cht> Is that correct? It'll just short circuit 
15:41:43 <jle`> you 'can' get it with catchError, but how useful it would be is a different story
15:42:17 <jle`> the "point" of MaybeT and ExceptT is to allow for short-circuiting Monad, Applicative, Alternative, etc. instances when you use >>=/do notation/<*>/<|>
15:42:31 <jle`> if this isn't what you are doing, then they don't really add anything
15:44:42 <cht> jle` thanks!
15:44:54 <jle`> np!
16:36:09 <Ucenna> does anyone have any good resources to learn how to write lambda calculus. I've taught myself to read it. and I can write expressions. But I'm struggling to write anything meaningful or to have an idea in my head and then write it out on paper. it's like learning math for the first time, except harder because I don't know how to define the operatio
16:36:09 <Ucenna> ns. 
16:42:16 <xpoqp> Do you understand what you read then?
16:42:35 <Ucenna> yeah.
16:42:56 <xpoqp> So the things that you've read, can you derive those things yourself?
16:42:57 <Ucenna> I just picked up church numerals and have been trying to abstract the definition to addition on my own. 
16:43:16 <Ucenna> not really, that's what I'm trying to learn. 
16:53:11 <shapr> Ucenna: Types and Programming Languages builds up a decent language from lambda calculus
16:54:13 <Ucenna> by Benjamin pierce? I'll check it out. thanks! 
16:57:09 <Ucenna> ooo! I think I just figured out multiplication. :D
16:58:34 <Ucenna> nvm... 
16:59:42 <shapr> yay! I just got accepted to recurse center! I'll be writing lots of Haskell soon!
17:01:10 <bdesham[m]> shapr congrats! that's great!
17:01:20 <shapr> yeah! I'm so excited!
17:06:30 <ricky_clarkson> Untyped lambda calculus is done very well by SICP imo
17:07:55 <shapr> I never did finish SICP, that's a good suggestion ricky_clarkson
17:09:22 <Lycurgus> looking for the connection of the recurse center to the price system, did eventually find it
17:09:47 <Lycurgus> as a funnel for employers
17:10:12 <shapr> Lycurgus: and a socially acceptable reason to take a few months off
17:11:21 <Lycurgus> so ur going into a batch, not as staff?
17:21:47 * hackage avro 0.4.4.2 - Avro serialization support for Haskell  https://hackage.haskell.org/package/avro-0.4.4.2 (haskellworks)
17:45:45 <vivit> How hot of a take would it be for me to say that the lambda character should be '^' instead of '\'
17:47:26 <Solonarv> hah
17:47:41 <Solonarv> scorching!
17:47:57 <vivit> that bad, huh?
17:48:09 <Solonarv> a problem immediately comes to mind: that clashes with the use of ^ for exponentiation
17:48:24 <vivit> use something different for exponentiation then!
17:48:40 <vivit> like exp
17:49:25 <Solonarv> that's already taken too! 
17:49:30 <Solonarv> > exp 1
17:49:32 <lambdabot>  2.718281828459045
17:51:51 <vivit> call that natExp or something 
17:53:13 <vivit> Alright then, call it 'pow'
17:53:24 <Solonarv> hm
17:53:29 <vivit> x to the power of y would be "pow x y"
17:53:56 <Solonarv> also, \ is going to look pretty much like a λ with the tail cut off no matter which font you use
17:54:14 <Solonarv> whereas ^ might end up being quite small and squeezed near the top of the line
17:54:22 <Solonarv> so it wouldn't look much like λ at all
17:54:33 <vivit> iirc '^' was the character originally used by Alonzo Church to represent variable binding in his original manuscript
17:54:43 <vivit> His typesetter made it into a lambda
17:55:27 <Solonarv> I mean, if you're going to have a the character transformed into a lambda symbol during rendering you can use whatever character anyway
17:56:23 <vivit> \ is just too closely associated with escape sequences for m
17:56:30 <vivit> s/m$/me/
17:58:20 <dmwit> vivit: Counter-hot-take: using a hat to mark binding sites was a bad idea in the first place.
17:58:53 <vivit> What would you have used instead?
18:00:03 <dmwit> All the truly lasting marks are outfix (?) -- they have a "start of name being bound" marker and an "end of name being bound" marker. (This is why hat is bad: it doesn't scale to long names.)
18:01:55 <dmwit> e.g. we write ∀ name . property, with ∀ and . being the markers; or f(x) = body with "start of line" and "=" marking f and ( and ) marking x.
18:03:21 <dmwit> Okay, ∫ thing dx doesn't fit the pattern -- there's a d for the start marker but no end marker -- but then I've always thought that was a pretty bad notation, too.
18:03:41 <vivit> what character is that? It's not rendering properly in my terminal
18:03:56 <dmwit> \int f(x) dx if you're TeX-savvy
18:04:16 <dmwit> They don't tell you this in high school but I think the right way to think of "dx" is that it's a binding site for x.
18:04:45 <vivit> That's a really good way to look at it
18:05:27 <vivit> I swear, that shit confused the hell out of me because of the way it was notationally ambiguous with multiplication
18:05:59 <Solonarv> to be fair, the thing after 'd' is (almost?) always a single variable
18:06:11 <dmwit> I think you have cause-and-effect backwards.
18:06:20 <vivit> I mean, it's not actually that ambiguous
18:06:29 <dmwit> If they'd picked a better notation, you might see that notation get used in programming languages, where people are more comfortable with longer names.
18:06:36 <Solonarv> also, there's some fancy way in which this *is* multiplication, so the ambiguity is thus resolved
18:06:41 <Solonarv> dmwit: good point
18:06:42 <vivit> But when you've only ever seen letters put next to each other to mean multiplcation of variables
18:09:27 <vivit> to change the subject: is 'Infinity' a value constructor?
18:10:12 <Solonarv> syntactically, it's a constructor, yes
18:10:31 <vivit> What type is it
18:10:51 <Solonarv> it isn't actually defined anywhere that I'm aware of
18:11:50 <vivit> > 1 / 0
18:11:53 <lambdabot>  Infinity
18:11:56 <Solonarv> ah, that
18:12:20 <Solonarv> no, that doesn't refer to any sort of constructor
18:13:36 <Solonarv> so that Show instance is a dirty liar!
18:14:01 <Solonarv> it pretends that there is an 'Infinity :: Double' constructor, but there really isn't
18:14:16 <vivit> there are too many different things that capitalized words can be in Haskell
18:14:46 <Solonarv> not at the value level - there they always mean 'data constructor'
18:14:58 <Solonarv> (or 'pattern synonym', which behave very much like a data constructor)
18:22:36 <dmwit> vivit: But that's not Haskell. =)
18:22:54 <dmwit> vivit: You can make a program that outputs any String you like; doesn't mean that String is valid Haskell code.
18:25:19 <vivit> I didn't say "in syntactically valid Haskell code", I said "in Haskell"
18:25:31 <dmwit> Let's see, where do all the capitalizations happen? There's module names, class names, type constructors, value constructors. Depending on what you call "Haskell", maybe language pragmas as well?
18:26:05 <dmwit> Of those only class names and type constructors can appear in the same syntactic positions, so it's usually pretty easy to tell these things apart.
18:26:35 <vivit> For someone who knows Haskell, yes, but for someone who's learning Haskell
18:27:02 <vivit> I understand how it works now, but when I was first starting out, the difference between a type class and a type constructor really confused me
18:27:12 * dmwit nods agreeably
18:27:55 <dmwit> (Oh yeah, kind constructors!)
18:28:09 <vivit> We Need To Go Deeper
19:01:16 <benzrf> vivit: i mean, historically df/dx /was/ a division
19:02:04 <benzrf> and when u work with differential forms, "f dx" really *is* an expression that makes sense in its own right, as the multiplication of the form "dx" by the function f
19:03:17 <lyxia> I wonder what mean constructors look like.
19:04:36 <Solonarv> they're full of gnarly existentials, constraint dictionaries, and proof terms
19:04:38 <benzrf> "mean constructor"?
19:04:59 <Solonarv> benzrf: as opposed to kind constructors ;)
19:05:32 <benzrf> =(
19:29:05 <whitebrick> Hi all! I'm trying to write the following function http://dpaste.com/3005TQD using Type.Reflection but I can't understand what I'm doing wrong?
19:29:55 <whitebrick> specifically where is `a1` coming from when I do typeRep :: TypeRep a?
19:30:29 <Solonarv> whitebrick: turn on ScopedTypeVariables
19:30:53 <Solonarv> otherwise the 'a' type variable in the function's body is completely unrelated to the 'a' type variable in its signature
19:31:52 <whitebrick> Solonarv: that worked! Aaah, thank you!
19:32:24 <whitebrick> so without Scoped Type Variables (STV) when I first say a in the function body does the GHC just make up some type?
19:32:54 <Solonarv> no, that becomes a fresh type variable
19:33:02 <Solonarv> (distinct from any other type variable)
19:34:05 <whitebrick> okay, and GHC knows nothing about this type variable? It has no constraints applied to it, etc?
19:34:13 <Solonarv> indeed
19:34:28 <Solonarv> this behavior is most unfortunate in my opinion
19:34:34 <whitebrick> hah tell me about it
19:35:29 <Solonarv> I think there's even been some discussion around enabling STV by default
19:35:34 <whitebrick> okay follow-up question. If you recall yesterday I was trying to derive Eq for my GADT. I can't because one of the constructors has a type variable and GHC can't know those two type variables are the same. Cool, so I can use type reflection as above, and that works
19:36:10 <whitebrick> now when I manually derive the Eq instance, is it possible to have GHC derive Eq for the rest of the constructors in the GADT that don't have type variables?
19:36:19 <whitebrick> and then I do the others manually?
19:36:43 <Solonarv> not as far as I know
19:36:52 <whitebrick> okay, no worries. Thank you again!
19:37:09 <clever> whitebrick: check how aeson handles toJSON and toEncoding
19:37:19 <clever> one of them has a default implementation, that refers to the other
19:37:28 <Solonarv> that isn't really helpful here
19:37:31 <clever> (which can cause nasty bugs if you only override one)
19:37:36 <clever> then check if Eq has similiar
19:37:47 <Solonarv> it does, /= has a default in terms of ==
19:37:53 <Solonarv> but that's not what the question is about
19:38:13 <clever> oh, other constructors, yeah, misread the question
19:38:33 <clever> never really looked into what GADT do yet
19:38:51 <drewbert> Are there any professional software developers here that would be willing to undergo a 10-15 minute interview? Thanks all. :)
19:40:15 <Solonarv> drewbert: I don't meet your requirements, but be aware that it's currently the middle of the night in europe (4:39 AM here); if you don't get a response here, you might have more luck trying at a different time of day
19:40:48 <Solonarv> or asking on a slightly more permanent forum, such as /r/haskell
19:41:44 <jackdk> I'd also suggest writing a bit more about what you're planning to ask and who you are writing for.
19:41:48 <drewbert> Thanks Solonarv. :)  If I don't get enough responses, I might try again later, but I definitely don't want to spam the channel
19:43:54 <drewbert> Good idea jackdk.  Basically, I'm a member of a team that just got second at a Seattle Startup Weekend.  I pitched the idea of a piece of software that integrates with the IDE and the project management software to streamline developer workflow.  I'm looking for professional software developers to share their experiences with project management sof
19:43:55 <drewbert> tware to me.
19:45:52 <jpg> Hi guys, Is there a way to define a GADT as a data family instance?
19:47:33 <Solonarv> I haven't tried it, but something like this should work, if it's possible at all: data instance Blah a b where {- constructors here -}
19:48:39 <Solonarv> otherwise you could define the GADT separately: data BlahFoo Foo b where ...
19:48:40 <Solonarv> and use a newtype instance: newtype instance Blah Foo b = BlahFoo (BlahFoo Foo b)
19:50:35 <jpg> Yes, it is possible, of course I tried before ask, but I had another syntax error and the message was cryptic
19:50:58 <jpg>  data instance Blah a b where {- constructors here -} works fine
19:51:28 <jpg> thank you anyway :)
19:53:21 <z0> ok so i'm kind of lost
19:53:43 <z0> im trying to use >=> to compose function that return Either
19:54:01 <z0> what module should I import?
19:54:34 <Solonarv> it's defined in Control.Monad
19:54:42 <Solonarv> so you can import that
19:55:10 <z0> but its defined in many places, right?
19:55:18 <z0> with differing implementations
19:57:34 <Solonarv> not at all
19:57:56 <Solonarv> it's a plain old function, it's only defined in one place
19:58:27 <Solonarv> that place is either Control.Monad, or some internal module that's re-exported from Control.Monad
20:01:09 <Solonarv> the definition looks something like:
20:01:09 <Solonarv> f >=> g = \x -> f x >>= g
20:11:17 * hackage rank2classes 1.3 - standard type constructor class hierarchy, only with methods of rank 2 types  https://hackage.haskell.org/package/rank2classes-1.3 (MarioBlazevic)
20:12:28 <z0> ha. got it
20:18:47 * hackage extensible-effects-concurrent 0.22.0 - Message passing concurrency as extensible-effect  https://hackage.haskell.org/package/extensible-effects-concurrent-0.22.0 (SvenHeyll)
20:19:34 <z0> i'm pretty sure I had this discussion when I started learning haskell, but is it an usual intuition to want something like `infixl .>; (.>) = flip (.)` ?
20:20:28 <z0> i mean most of the times we use >= and >=> right?
20:21:33 <geekosaur> I think that already exists with the name (>>>)
20:22:10 <geekosaur> but you have to import it (from Data.Function iirc, although also in Control.Arrow and Control.Category with different constraints)
20:24:43 <z0> that's fine, I'm just wondering why we tend to flow l2r on everything but pure function composition
20:25:47 <z0> is it only convention or is there some practical reason?
20:26:21 <geekosaur> pure functions are influenced by lambda calculus, monads influenced largely by emulation of imperative programming style
20:26:38 <z0> so convention then
20:26:46 <geekosaur> yes
20:30:17 * hackage extensible-effects-concurrent 0.22.1 - Message passing concurrency as extensible-effect  https://hackage.haskell.org/package/extensible-effects-concurrent-0.22.1 (SvenHeyll)
21:05:46 <Axman6> (.) is just function composition from maths, (f . g)(x) == f(g(x))
21:06:25 <Axman6> so it's "convention", but a much older convention than Haskell
21:25:18 <Maxdamantus> `fmap` is already the flipped version .. part of me also thinks `(>>=)` should be flipped, in which case the identity functor just has `fmap = id` and the identity monad has `return = id; bind = id`
21:27:51 <Maxdamantus> er, sorry, fmap is (.), so it's probably already the right way round, the inelegant part is just that (>>=) has to be defined as `flip id` in the identity monad.
21:28:33 <jackdk> Why is (=<<) not in class Monad>
21:29:22 <jackdk> I assume the reason for (>>=) is because it ties in with do-notation, but maybe everything was laid down here before defining instance functions in terms of each other was a thing?
21:37:04 <geekosaur> because there's no point in customizing it beyond flip (>>=)
21:37:07 <MarcelineVQ> things make their way into classes when they can have more efficient versions depending on the type
21:37:17 <geekosaur> ^
21:40:35 <MarcelineVQ> liftA2 is part of Applicative now because there are cases where it's more efficient to write a liftA2 for a specific type than to use a general liftA2 defined in terms of <$> and <*>
21:48:03 <jackdk> tyvm
21:52:25 <lavalike> MarcelineVQ: what is an example of such a case?
22:14:23 <yitz> How do I go from   [Char] -> Text ?
22:14:59 <lavalike> :t Data.Text.pack
22:15:01 <lambdabot> String -> Data.Text.Internal.Text
22:15:13 <yitz> [Char] == String ?
22:15:45 <lavalike> yes
22:15:59 <yitz> Ah. That explains that. And makes sense :) Thank you
22:16:05 <lavalike> np!
22:16:09 <lavalike> https://www.stackage.org/haddock/lts-13.17/text-1.2.3.1/Data-Text.html#g:6
22:16:17 <lavalike> (also click on "String" there)
22:17:50 <yitz> That site is prettier than hoogle
22:18:42 <lavalike> that is why I default to it haha
22:21:15 <yitz> Fugde. T.unwords doesn't work for this exercise. I need to split on whitespace /or/ lowerUpper transistions >.>
22:38:27 <yitz> So...   I'm trying to convert Strings to acronyms. ie "Foo bar" -> "FB", "GIMP Image Manipulation Program" -> "GIMP" and ... "HyperText"->"HT".
22:39:02 <yitz> My first try was    `map head unwords`  which mostly worked. Except "HyperText". 
22:40:20 <yitz> Now I'm thinking I need to compare each char to the following char and use that to `filter (next == ' ' || (cur == lower && next == upper) )`. Not sure how to compare each char to the next.
22:40:49 <yitz> I could ... rotate one char from the head to the tail and zip the original and transformed. Does that make any sense?
22:42:31 <yitz> Text.uncons "foo"  gives "f" and "oo".   T.cons "oo" "f"   gives me the rotates "oof".  I can't figure out how to go about getting   T.cons <swap??> T.uncons s
22:42:59 <yitz> Oh... nvm. There's a base.swap
22:44:16 <yushyin> yitz: zip with the tail of your list
22:45:04 <yitz> That works
22:45:22 <yitz> I think
22:49:59 <Axman6> > splitOn (\c -> isUpper c || isWhitespace c) "ThisThin has some Words GIMP Image Manipulation Program"
22:50:01 <lambdabot>  error:
22:50:01 <lambdabot>      • Couldn't match expected type ‘[Char]’
22:50:02 <lambdabot>                    with actual type ‘Char -> Bool’
22:50:07 <yitz> Heh. I think I'm making (messy) progress. I'm pretty damn sure there's a solution roughly 1000000 times prettier
22:52:14 <MarcelineVQ> yitz: what acronym is "biffHyperText"
22:53:08 <yitz> BHT
22:53:32 <tac-tics> What is GHC.Base.Any and how can I find the docs for it?
22:54:37 <Axman6> @hoogle Any
22:54:37 <lambdabot> Data.Monoid newtype Any
22:54:37 <lambdabot> Data.Monoid Any :: Bool -> Any
22:54:37 <lambdabot> Data.Semigroup newtype Any
22:54:45 <Axman6> hmm, none of those
22:54:51 <tac-tics> Yeah
22:54:59 <tac-tics> Apparently Coq emits references to this thing.
22:56:52 <Axman6> http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Exts.html#t:Any
22:57:32 <tac-tics> oh, thanks.
22:57:36 <tac-tics> How did you find that :X
22:57:39 <Axman6> it's a type which can be useful for places you you need to store things of different types which normally wouldn't allow that
22:57:51 <Axman6> went looking for Any in the base library index
22:57:59 <Axman6> http://hackage.haskell.org/package/base-4.12.0.0/docs/doc-index-A.html
22:58:32 <MarcelineVQ> there's also little trick that for some reason insnt' flashing in rainbow on every page: go to your pacage http://hackage.haskell.org/package/base and press S on your kb
22:58:43 <Axman6> which I got to by clicking the [Index] link on http://hackage.haskell.org/package/base under the description at the top. Anything that starts with GHC. should be in the base package IIRC
22:58:53 <MarcelineVQ> erm, take focus off the search bar on the top right first, stupid focus stealer
22:59:01 <Axman6> that only works on some packages
22:59:26 <tac-tics> MarcelineVQ, that is... why isn't that flashing in rainbow lights :[
22:59:30 <MarcelineVQ> inded.
23:00:54 <Axman6> An example of where Any is used is in the superrecord package, which has a type something like data Record [ty :: k] where Record :: SmallArray Any -> Record [ty], and the library takes care of keeoping the mapping between the types of the elements and their indices in the array
23:01:04 <Axman6> (the syntax is porobably wrong)
23:01:17 <tac-tics> So Any is essentially a Haskell void*?
23:01:19 <tac-tics> it seems
23:01:32 <Axman6> yeah
23:02:02 <Axman6> https://hackage.haskell.org/package/superrecord-0.5.0.1/docs/src/SuperRecord.html#Rec
23:02:03 <tac-tics> hm neat.
23:03:13 <yitz> Got a working solution ... but it's super messy
23:03:40 <TBG> Can someone help me with some applicative thingy? 
23:03:52 <TBG> I'll explain to you my thought process
23:04:02 <TBG> zip <*> tail
23:04:42 <TBG> So you get the function (b -> r) called on the result of tail
23:04:50 <Cale> That one is just a matter of knowing how <*> is defined for (->) e
23:05:08 <TBG> I think I know that tho
23:05:26 <Cale> (f <*> g) x = f x (g x)
23:05:49 <TBG> Yeah but I'm wondering why using stuff I know about applicatives
23:05:59 <Cale> fair enough :)
23:06:14 <yitz> Gah. foo-bar => FB but foo's => F  and not  FS.  Why would - and ' be treated differently and how?
23:06:30 <TBG> Would you agree about my thing "So you get the function (b -> r) called on the result of tail"
23:06:37 <Axman6> > (f <*> g) x :: Expr
23:06:39 <lambdabot>  error:
23:06:39 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘f’
23:06:39 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
23:07:30 <nshepperd> @quote zip`ap`tail
23:07:30 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
23:07:44 <TBG> lol
23:07:47 <kadoban> That one is just brilliant.
23:07:49 <Axman6> praise zip`ap`tail
23:08:38 <TBG> So would b->r be zip P . tail 
23:08:40 <Cale> TBG: well, what's (b -> r)?
23:08:52 <TBG> So zip is of a -> b -> r
23:09:01 <TBG> And applicatives unwrap that
23:09:07 <TBG> So you'd get b -> r
23:09:40 <Cale> uhh
23:10:35 <Cale> :t (<*>)
23:10:38 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
23:11:02 <Axman6> tac-tics: if Coq's emitting it it'll be becaus eit can't express something in Haskell safely
23:11:21 <Cale> Here, f = (->) [t], a = [t] and b = [(t,t)]
23:11:32 <TBG> Yeah
23:12:10 <Cale> So <*> ends up having type ([t] -> [t] -> [(t,t)]) -> ([t] -> [t]) -> [t] -> [t]
23:12:28 <TBG> I get why it has that type
23:12:30 <MarcelineVQ> yitz: foo's should be FS? complicated little acronyms :O
23:12:38 <TBG> But how
23:12:47 <TBG> Do you understand my unwrapping thingy
23:13:23 <yitz> MarcelineVQ: the unit test says  foo's => F     but   "foo-bar" -> FB
23:13:35 <Cale> I'm not sure that I do
23:13:37 <TBG> The function would come out to be zip P . tail (because it assumes A has already been provided)
23:13:41 <TBG> Ok
23:13:56 <MarcelineVQ> unit test? this homework? :>
23:14:00 <yitz> So I wrote my own `isSeparator` that spells out that space and - = True   but ' = False
23:14:03 <yitz> exercism.io
23:14:13 <Cale> Well, it's like (\xs -> zip xs (tail xs)) in the end
23:14:17 <TBG> So applicative unwraps the function to get a function and essentially fmaps it to the next val right
23:14:32 <yitz> Semi-homework for online ... exercises?
23:14:42 <Cale> I'm not sure I can make sense of "unwraps". Do you mean "applies"?
23:15:53 <tac-tics> Axman6, yeah. I realize that much. I figured Coq would just erase any type information it couldn't handle.
23:16:00 <tac-tics> and leave you with a coarse-grained type
23:16:17 <TBG> Maybe, what I mean is doing (a->b->r) <*> (c -> r1) is like doing (b -> r) . (c -> r1)
23:16:29 <TBG> But (b -> r) is usually constructed with a value
23:16:36 <TBG> e.g. (+5) is (+) 5 
23:16:39 <nshepperd> 'unwrapping' is a bad intuition
23:16:48 <TBG> k
23:16:51 <tac-tics> isn't (+5) technically flip (+) 5 :)
23:17:05 <TBG> Well they're the same sort of
23:17:12 <MarcelineVQ> yitz: have you solved the exercise and just want it to be nicer?
23:17:17 <tac-tics> up to merely propositional equality!
23:17:18 <nshepperd> there's nothing you can compose with g to get the result of 'f <*> g'
23:17:23 * tac-tics goes back to Coq 
23:17:41 <TBG> Wait maybe I wrote that wrong
23:17:50 <TBG> c -> ((b-> r) r1)
23:17:59 <TBG> Isn't that composition tho
23:18:10 <Axman6> > (<*>) `asAppliedTo` zip
23:18:13 <lambdabot>  error:
23:18:13 <lambdabot>      • No instance for (Typeable a0)
23:18:13 <lambdabot>          arising from a use of ‘show_M601996527420277902932367’
23:18:17 <Axman6> >:t (<*>) `asAppliedTo` zip
23:18:24 <Axman6> :t (<*>) `asAppliedTo` zip
23:18:26 <Cale> You can't apply (b -> r) to r1, that's a kind error
23:18:26 <lambdabot> ([a] -> [b] -> [(a, b)]) -> ([a] -> [b]) -> [a] -> [(a, b)]
23:18:30 <yitz> MarcelineVQ: I /just/ solved it now finally. It's a fugly solution that took forever.  I got a simple solution using `unword` but that doesn't pass the unit test that got finicky rules. So I got a messy solution where I define that '\''=False and..
23:18:34 <yitz> ... '-'=True etc
23:18:45 <TBG> Do you sorta understand my point
23:19:04 <TBG> How does it decide to have two xs
23:19:25 <Cale> It decides because that's what the instance of Applicative for (->) e looks like
23:19:32 <nshepperd> TBG: i mean, look at the <*> implementation for functions. f <*> g = (\e -> (f e) (g e))
23:19:33 <TBG> Yes but why does it look like that
23:19:39 <Cale> There's explicit code which says  (f <*> g) x = f x (g x)
23:19:46 <MarcelineVQ> Just wanted to make sure you had a solution before I posted the one I came up with, it's no good to ruin an exercise by pasting an answer before it's done :>
23:19:46 <TBG> Yeah but why
23:19:52 <Cale> and it's forced to be that by its type
23:20:04 <TBG> Yes but the e isn't
23:20:07 <Cale> which is (e -> (a -> b)) -> (e -> a) -> (e -> b)
23:20:17 <Cale> Let's write it
23:20:23 <TBG> You could have (\e -> (f CONS) (g e))
23:20:43 <Cale> hm?
23:20:46 <TBG> Or mempty or smth
23:20:47 <Cale> (f <*> g) x e = ...
23:20:53 <Cale> f :: e -> a -> b
23:20:56 <Cale> g :: e -> a
23:21:01 <TBG> Yes
23:21:02 <Cale> oh, oops
23:21:05 <TBG> It has to be e -> a
23:21:07 <Cale> (f <*> g) x = ...
23:21:13 <TBG> So you lose a param
23:21:15 <Cale> just noticed the typo
23:21:15 <yitz> MarcelineVQ: I'm done. Cleaning up indentation and comments
23:21:20 <nshepperd> TBG: you can't use constructors of e's type since you don't know what that type is
23:21:28 <Cale> x :: e
23:21:40 <Cale> and now our right hand side needs to have type b
23:21:48 <Cale> The only way to make something of type b is to apply f
23:21:50 <TBG> So is the only reason e is used as the other argument to make it useful and to have something of the same type?
23:22:04 <Cale> (f <*> g) x = f (... :: e) (... :: a)
23:22:09 <nshepperd> oh, yeah i'm probably confusing things by using e as a term
23:22:20 <Cale> So now we need something of type e and something of type a to be the parameters of f
23:22:38 <Cale> We only have x of type e, so it must go there
23:22:41 <TBG> What I'm saying is that something which takes two args goes to something which takes one arg
23:22:44 <Cale> (f <*> g) x = f x (... :: a)
23:22:47 <TBG> So say (+) . id
23:22:48 <TBG> Np
23:22:53 <Cale> and now the only way to make something of type a is to apply g
23:22:53 <TBG> (+) <*> id
23:22:55 <TBG> There
23:23:00 <Cale> (f <*> g) x = f x (g (... :: e))
23:23:02 <TBG> So you lose one arg
23:23:08 <Cale> and we need to apply it to something of type e
23:23:17 <Cale> of which we still only have one thing in scope
23:23:18 <TBG> So do they just chose e
23:23:21 <Cale> (f <*> g) x = f x (g x)
23:23:32 <Cale> That's the only possible non-recursive implementation
23:24:03 <MarcelineVQ> yitz: what acronym would "Foo'GoB" make? F?
23:24:18 <Cale> Because at every point in this process I just described, there was only one way to proceed
23:24:26 <TBG> Yeah
23:25:12 <MarcelineVQ> % filter isAlphaNum . map (toUpper . head) . groupBy (\x y -> isLower y) . takeWhile (/='\'') $ "biffHyper-TextThingD'zisuBo" -- this is for applying to single word, the sort you'd get from using 'words'
23:25:13 <yahb> MarcelineVQ: "BHTTD"
23:25:14 <yitz> MarcelineVQ: I have no idea :P   I think the "B" should appear in the solution, though
23:25:26 <MarcelineVQ> The most arcane part is probably what groupBy does
23:26:11 <TBG> So there's no guarantee that any of the params are monoids
23:26:19 <TBG> So you can't get a default or empty value for them
23:26:22 <TBG> So you have to go with e
23:26:24 <yitz> My solution:  http://ix.io/1GqN 
23:28:33 <yitz> The Haskell section of Exercism.io is far harder than the other languages >.>
23:29:08 <TBG> Is there a function that does takeWhile and returns some traversable of what was taken and then the rest?
23:29:53 <MarcelineVQ> groupBy considers all the items of a list two at a time, [1,2,3,4] would be considering 1 and 2, then 2 and 3, then 3 and 4. groupBy (\x y -> isLower y) says that as long as the second of the two being considered is lower case then we add it to the group
23:30:00 <Cale> TBG: Sorry, what's wrong with takeWhile?
23:30:04 <TBG> Or should I just use a takeWhile and then a dropWhile
23:30:14 <TBG> I was just wondering cus it would make stuff simpler
23:30:14 <kadoban> There's splitWhile, isn't there?
23:30:38 <TBG> Well it would be a splitFirst and it wouldn't remove the splitThing
23:30:47 <TBG> I don't think I need this function just wondering
23:31:30 <MarcelineVQ> % span (/=4) [1,2,3,4,5]
23:31:30 <yahb> MarcelineVQ: ([1,2,3],[4,5])
23:31:51 <kadoban> Oh span it's called, not splitWhile, the thing I was thinking of. Yeah
23:32:54 <Cale> Oh, sorry, yeah, span/break
23:33:53 <TBG> Nice
23:33:58 <TBG> Very cool
23:34:16 <TBG> Thanks
23:34:20 <yitz> MarcelineVQ: ah. That's nifty and useful and replaces a chunk of my code
23:34:27 <MarcelineVQ> yitz: There's nothing really warranting your use of Text in this exercise, the list (and thus String) versions of these Text operations are all in Data.List but it's not a bad solution at all if it works
23:34:29 <Cale> I was thrown off by "traversable" there.
23:34:49 <Cale> "Pair" might have been the word you were looking for :)
23:35:08 <TBG> Yeah
23:35:23 <TBG> It would be fine if it was a list, but a pair was way nicer
23:35:25 <yitz> MarcelineVQ: the instructions for the exercise links to https://haskell.fpcomplete.com/tutorial/string-types and tells me to import Text :(
23:35:36 <kadoban> I took it to mean they wanted like something that in another language would be an iterator
23:35:40 <kadoban> Or ... maybe not from that ^
23:35:57 <yitz> I trusted 'em
23:36:45 <MarcelineVQ> yitz: Text is amazing and you should use it whenever it makes sense to, I'm only saying it seems out of place here because you're working with String -> String and not using any operations that only Text can do
23:38:04 * yitz nods
23:40:54 <MarcelineVQ> huh, actually I was wrong about how groupBy works, what a funny little function
23:40:59 <TBG> Oh wait
23:41:04 <TBG> Yeah you're right
23:41:26 <TBG> Because tuple is traversable but only does it on the last element
23:43:32 <MarcelineVQ> TBG: it's unclear at this point what you'd like to have :>
23:44:27 <TBG> No I got it
23:44:44 <TBG> I was just agreeing with someone that traversable was confusing
