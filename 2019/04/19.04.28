02:01:45 <sudoka> Hey Haskellians! I'm having trouble installing some dependencies on a freshly installed Haskell platform on OS X ...
02:02:54 <sudoka> ... at some point, I get: /Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/lib/libiconv.tbd:4:18: error: unknown enumerated scalar | 4 | platform: zippered ...
02:03:41 <sudoka> ... none of this happens on Windows, when I try that on the same directory.
02:04:09 <lavalike> unknown number 4, fancy
02:04:31 <sudoka> I also tried installing haskell via brew, but I'm having the same trouble then.
02:05:07 <lavalike> maybe try reinstalling the xcode command line package, but I don't know
02:05:22 <sudoka> Anybody has a clue on how to resolve this?
02:15:04 <sudoka> lavalike: Yep, turns out a previous Xcode installation was incomplete. Good clue to go on, thanks! 
02:38:35 <zincy> When you define a grammar for an ML like language. How would you represent the functionality for type construction in the grammar? I guess you would just have a "type function" and a "type variable" to distinguish types and values.
02:46:46 <akfp> can anyone help me understand how doing a "span" or partition of a list looks like with lens?
02:47:26 <akfp> span (\case FooType -> True; _ -> False) list
02:47:40 <akfp> the equivalent using lens?
02:47:54 <akfp> list ???? _FooType
02:53:21 <fen> how does generics and recursion-schemes differ?
02:53:25 <lavalike> sujeet: excellent!
02:54:23 <fen> is it the same as the difference between contuniuations and the Default class?
02:55:03 <fen> sorry, *specific* the continuation; (a -> r) -> r, vs the class Default a where default :: a
02:55:46 <fen> as in, is the difference about there being *any* Constructor, as opposed to just using Fix
02:56:44 <fen> and then, is this the same as how lenses allow another step of this, to *any* constructor of *any* container
02:57:46 <fen> then, isnt it clear that the middle step is missing? we have recursion schemes which use Fix, instead of classes of Get and Set - and then the 2nd order abstraction where we have *anything* which can be used as a getter or setter
02:57:55 <fen> is there a better way to say that/
02:58:42 <fen> basically we go from the "canonical" container, where there is no constructor to pattern match on, as Fix is used (well this can be matched on sure, but its not a datatype constructor)
02:59:13 <fen> well- not a constructor for *different* datatypes isomorphic to the one expressed using Fix
03:00:46 <fen> so, from one *canonical* datatype (using Fix), to the group of all those it is isomorphic to it - using Get and Set (as class functions), and then to Lenses, which are continuation encoded (as opposed to classes, which specify only one implementation) versions of the get and set classes allowing *any* possible get and set to be used
03:01:33 <fen> how can we describe this difference between a fixed implementation using a class, and the continuation encoding allowing any possible implementation
03:02:52 <fen> and then, how is this similar to how *canonical* datatypes written using Fix do not have a cons like constructor, as this flexibility of the range of implementations has again been restricted down to a specific case
03:02:57 <fen> .
03:07:44 <fen> basically just wanting some kind of succinct terminology to express this idea 
03:08:32 <fen> there seems to be two stages of abstraction, what are they called, are they different?
03:10:00 <fen> class functions vs continuation encodings over them, and generics vs the things they are isomorphic to
03:13:33 <fen> and then, if generics are the specification of the canonical datatype *of an equivalence class under isomorphism to the generic/canonical datatype) the thing thats missing is a *cannonical* lens - a restriction from the contiuation lens encoding to a specific implementation as the instance of a class
03:39:51 <__monty__> zincy: Depends on what you mean by ML-like. Is DependentML ML-like enough? In dependent languages syntactical distinction between values and types is rare. In a language closer to current haskell that'd seem a fine approach to me. It's also where the capitalization for types comes from, makes it syntactically easy to distinguish.
03:40:55 <fen> monty: do they have kind signatures?
03:41:12 <fen> or does everything have to be written at the term level?
03:41:35 <fen> seems like it could be a thing to do with writing functions inline at type level
03:42:09 <__monty__> fen: Well agda, for example, doesn't distinguish between term/type/kind levels, they're all just the term level.
03:42:18 <fen> seems strange to have to write types at value level...
03:42:43 <fen> wow, agda sounds cool
03:43:03 <__monty__> Not really. It still looks like haskell for the most part, modulo dependent stuff and capitalization.
03:43:04 <fen> seems like it would be a pretty severe syntactic shift for haskell to do that
03:43:35 <__monty__> It's just that a type or a typing judgement *is* also a term.
03:43:46 <fen> so what, if you write a term level function at type level with a capital letter it becomes a type level function?
03:44:54 <fen> or can you just kind of mix together lowercase and capital letter perfix "Types" at type level
03:45:01 <__monty__> No, there's no restriction on capitalization.
03:45:18 <__monty__> But you can define a function and then use that function in a type.
03:45:26 <fen> thats awesome 
03:45:34 <fen> with lambdas?
03:46:03 <fen> like, can it do type inference on value level functions defined using lambdas at type level
03:46:19 <__monty__> With anything. There's *no* term v. type level anymore. So everything goes.
03:46:30 <__monty__> Nope, you give up inference with dependent types.
03:47:06 <fen> type A = foldr (\ a b -> ...) bc '['True,'False]
03:47:48 <fen> the type of the lambda and basecase there are inferable though right?
03:48:44 <__monty__> Maybe in principle, agda just doesn't though.
03:49:00 <fen> hmm, maybe haskells way can be better then
03:49:22 <fen> it might be extra work to add a typechecker to the agda compiler, but we already have one
03:49:57 <fen> not sure what a datatype like list or something would be like if you had to define it at term level though
03:50:10 <__monty__> The times inference works in the context of dependent types are usually too few and far between to justify the effort of writing an inference algorithm.
03:50:33 <fen> is there no use for the distinction between term and type? what about phantom types, do they even make sense at term level?
03:52:20 <fen> maybe they are kind of like contexts, specifying extra values which are in scope
03:52:25 <__monty__> Let's take the definition for Vec rather than List because that one involves built-in shenanigans: https://github.com/agda/agda-stdlib/blob/master/src/Data/Vec.agda#L34
03:52:34 <__monty__> It *almost* reads like haskell.
03:52:54 <__monty__> Not having a type level doesn't mean you can't use data declaration syntax.
03:55:31 <__monty__> There's also record syntax, let's take NonEmpty, for instance, https://github.com/agda/agda-stdlib/blob/master/src/Data/List/NonEmpty.agda#L34
03:56:57 <fen> open List⁺ public !?
03:57:01 <fen> argh!
03:58:21 <fen> what is this some kind of OOP!?
03:58:27 <fen> module?
03:58:51 <__monty__> Yeah, records define implicit modules.
03:58:51 <fen> and all these _?_ things 
03:59:38 <fen> is that so they could have symbols in names mixed with chars?
03:59:41 <__monty__> The underscores are part of the mixfix syntax. if_then_else_, for example, could be use as `if (conditions) then (value1) else (value2)`
04:00:18 <fen> like some kind of lambda argument distributing syntax?
04:00:32 <fen> thats pretty intense 
04:01:35 <fen> ah ok, it makes it easier to read knowing that!
04:02:03 <__monty__> A binary operator would be defined like this `_+_`, a ternary one like this `_-❬_❭->_` for example.
04:03:04 <fen> what, with the extra <> or with the - ->
04:04:04 <fen> oh, this is an ok example; _[_]
04:04:21 <fen> needing an argument for the head and the tail
04:04:33 <__monty__> Those brackets are just often used for clarity, like a bubble on a drawn arrow.
04:06:08 <fen> whats with snocView? do they manage to do snoc lists somehow?
04:20:59 <fen> anyway, this thing with lenses as an abstraction which captures both all container types, and all the ways of accessing them;
04:21:48 <fen> it seems whats missing is the middle case of the fixed choice of accessor (namely, at the head) parametrised over the various types of containers
04:22:16 <fen> as specified by the base functor that the canonical version is created from using Fix instead of a an actual datatype constructor
04:23:12 <fen> the there is this other aspect, of trying to "write all lenses" which is then, making an exhaustive parameter to supply to the accessor class 
04:23:35 <fen> and then, as this defines an unbranching order of traversal, giving an enumeration of the values
04:24:25 <fen> that all the lenses for a particular container for a given base functor, are then just a choice of Nat for the index being accessed
04:24:49 <fen> then, the choice of base functor and index of the value being focused, would give all lenses?
04:26:35 <fen> obviously the Nat part seems to exhaust all possible locations to be accessed, so then the task is making the parameter to exhaust all base functors
04:29:34 <__monty__> fen: The snocView reverses the list. No magic sadly.
04:40:51 <fen> monty: there should be a way with a zipper that is know to be unwould
04:40:57 <fen> unwound*
04:41:13 <fen>  /fully forwardsly navigated
04:41:52 <fen> maybe the realy magic would be having everything stored as a zipper by default!
04:42:08 <__monty__> But that would rely on having one. Not sure how you would "just notice" one lying around.
04:42:24 <fen> what?
04:42:52 <fen> oh right, that a zipper would need the basecase parameter
04:42:56 <fen> base functor*
04:43:09 <fen> right?
04:43:27 <__monty__> No, that the snocView would either need to be supplied an exhausted(?) zipper or find one.
04:44:08 <fen> yeah but if everything was always a zipper then it would just need to recurse forwards until the end
04:44:48 <fen> maybe this creates an extra time consuming check to see if something is fully forwardsly navigated
04:44:59 <fen> like, cons doesnt need to
04:45:42 <fen> so that would mean even if it *was* given the unwound version, it would still be slower than cons
04:46:07 <fen> actually, even cons on the fully rewound version would be slower than the cons on the version that doesnt use a zipper
04:46:18 <__monty__> Yes, but that doesn't save any work. Would definitely be cool if the garbage collector hinted something like "Pssst, if you ever need to reverse this list, here's an exhausted zipper."
04:46:32 <fen> that is, the posability that it might not be in the right position nessecitates an expensive check
04:46:41 <fen> though, maybe this could be fixed at type level?
04:47:12 <fen> monty: it does save work, the time spent navigating to the end need not be repeated between successive snocs 
04:47:46 <fen> meaning you could grow the snoc list as fast as the cons unfolding
04:47:53 <__monty__> Shouldn't the snocView not get garbage collected at all if it's still gonna be used?
04:48:08 <fen> and then you would have like an foldl - unfoldl fusion to obtain the original state
04:48:23 <fen> instead of having all the lists you grow by unfolding ending up backwards
04:48:23 <__monty__> Agda's pure so `snocView xs` is always the same value, no need to recalculate. (At least in theory.)
04:49:26 <Solonarv> so is Haskell (there are escape hatches, but they don't impact CSE - if you use them it had better be safe!)
04:50:25 <Solonarv> it can still be better to *not* share CSEs if they take up a lot of memory and/or would not even be fully materialized if you don't share them
04:51:23 <Solonarv> compare 'let xs = [1 .. 10^6] in product xs + product xs' vs. 'product [1 .. 10^6] + product [1 .. 10^6]'
04:52:12 <Solonarv> in the second form, the lists can be consumed by 'product' in a streaming fashion and never need to be fully materialized; in fact thanks to fusion they need not be materialized at all
04:52:53 <Solonarv> in the first form, whichever 'product' call gets evaluated first has to force the entire list, and since it's still needed by the other call none of it can be garbage collected
04:52:55 <fen> your using the let binding to strictly force the evaluation of the list?
04:53:11 <Solonarv> no, I'm using the let binding to indicate sharing
04:53:40 <fen> wait so the 2nd version somehow manages to cach the enumeration?
04:53:52 <Solonarv> no, the second version doesn't cache anything
04:54:07 <Solonarv> there is no sharing in the second version, and yet it has better/same performance characteristics
04:54:14 <fen> so it needs to repeat the calculations needed to generate the list?
04:54:24 <Solonarv> yes, but these calculations are very simple
04:54:35 <Solonarv> and the upside is that there is never a big old list sitting in memory
04:55:18 <fen> so how do you decide which version to use?
04:55:46 <Solonarv> it can be a bit tricky
04:55:50 <fen> if the calculations were more costly, and depending on the length of the stored list and size of the words of the contests type
04:56:26 <Solonarv> then it might make sense to share the list, yes
04:56:52 <Solonarv> basically sharing is a tradeoff: you use more memory and lose some optimization potential, but get to avoid duplicating work
04:57:23 <fen> so what calculation gives this intuition that the (+1) action compared to the memory burden of the extra value to a list of ints
04:57:38 <fen> is such that its better not to share in this case
04:58:39 <Solonarv> well, for one we can easily estimate the size of this list: it's about 24MB (on a 64bit machine)
04:58:41 <fen> guess its acutally a pretty important example because of its use in controling for loops
04:58:56 <Solonarv> so pretty much know how much memory sharing costs us
04:59:39 <Solonarv> additionally we know that incrementing ints is very fast, and so is counting from 1 to 10^6 - CPUs are good at that
05:01:05 <__monty__> fen: As to examples for functions in types, using a normal function in a type https://github.com/agda/agda-stdlib/blob/master/src/Data/Vec.agda#L95, using a function on types as a type `f : N-ary n A B` is a function that takes `n` `A`s and returns a `B` https://agda.github.io/agda-stdlib/Data.Vec.N-ary.html#853
05:01:35 <fen_> what if you take the square root, then you have a state over a 10^3 length list
05:01:51 <fen_> thats a much more costly calculation than (+1), to unfold that whole list
05:02:09 <fen_> hasnt it then become something worth caching?
05:02:43 <Solonarv> perhaps! that's what profiling is for
05:02:53 <fen_> ah, your using product, that actually needs to see the value of the Int
05:02:56 <__monty__> Yeah, really hard to give guidelines for this.
05:03:12 <fen_> its different if its just use eg as an argument to replicate
05:03:12 <__monty__> Depends on the amount of memory you have too.
05:03:32 <fen_> maybe thats the only case actually, its like mapping with const over the enumerated list
05:04:11 <fen_> hmm maybe scan also
05:04:30 <fen_> like mapAccumR const
05:04:30 <Solonarv> there are other cases too, consider something like:
05:04:30 <Solonarv> @let fibs = 0 : 1 : (zipWith (+) <*> tail) fibs
05:04:31 <lambdabot>  Defined.
05:04:41 <Solonarv> here you really want sharing to happen
05:05:31 <Solonarv> > fibs !! 24
05:05:33 <lambdabot>  46368
05:05:38 <Solonarv> > fibs !! 24
05:05:40 <lambdabot>  46368
05:05:48 <fen_> :t \x y -> zipWith x <*> y
05:05:49 <lambdabot> (a -> b -> c) -> ([a] -> [b]) -> [a] -> [c]
05:06:53 <Solonarv> oh that was just a fancy way to write zipWith (+) fibs (tail fibs)
05:06:57 <fen_> cant parse
05:07:05 <fen_> oh ok
05:07:27 <fen_> still complex how it recurses that though
05:07:34 <fen_> this is not a simple example!
05:08:53 <Solonarv> indeed
05:09:32 <Solonarv> but it's a relatively well known way to compute the fibonacci series, and sharing is absolutely crucial for it to not devolve into the O(2^n) of the naive recursive approach
05:09:55 <fen_> ah thats how the zipwith helps
05:10:04 <fen_> but where is the sharing there?
05:10:24 <fen_> oh the fibs and its tail
05:10:31 <fen_> reuses fibs twice
05:10:33 <fen_> ok 
05:10:57 <Solonarv> @let fibsBad () = 0 : 1 : zipWith (+) (fibs ()) (tail (fibs ())) -- sharing destroyed
05:10:58 <lambdabot>  .L.hs:160:35: error:
05:10:58 <lambdabot>      • Couldn't match expected type ‘() -> [a]’
05:10:58 <lambdabot>                    with actual type ‘[Integer]’
05:11:12 <Solonarv> @let fibsBad () = 0 : 1 : zipWith (+) (fibsBad ()) (tail (fibsBad ())) -- sharing destroyed
05:11:13 <lambdabot>  Defined.
05:11:20 <Solonarv> > fibsBad !! 24
05:11:22 <lambdabot>  error:
05:11:22 <lambdabot>      • Couldn't match expected type ‘[a]’
05:11:22 <lambdabot>                    with actual type ‘() -> [Integer]’
05:11:28 <Solonarv> > fibsBad () !! 24
05:11:30 <lambdabot>  46368
05:11:43 <Solonarv> hm let's try a bigger number
05:11:50 <Solonarv> > fibsBad () !! 100
05:11:56 <lambdabot>  mueval-core: Time limit exceeded
05:12:01 <Solonarv> > fibs !! 100
05:12:03 <lambdabot>  354224848179261915075
05:12:49 <fen_> so what, its the <*> that makes the sharing?
05:13:57 <Solonarv> no, just the fact that we refer to 'fibs' again in its body
05:14:13 <Solonarv> in 'fibsBad' the lambda / function call gets in the way
05:15:13 <fen_> oh right, you write fibsBad twice, but you only write fibs once in the function definition
05:15:26 <__monty__> Thats' not the crucial difference.
05:15:43 <Solonarv> yeah, that doesn't really matter
05:15:52 <Solonarv> the <*> nonsense in fibs is a red herring
05:16:21 <Solonarv> (if I only mentioned 'fibsBad ()' once in fibsBad that would actually improve things, I think)
05:16:37 <int-e> @hoogle Rational -> (Integer, Integer)
05:16:38 <lambdabot> Math.ExpPairs.Ivic checkAbscissa :: [(Rational, Rational)] -> Rational -> Bool
05:16:38 <lambdabot> Math.ExpPairs.Ivic findMinAbscissa :: Rational -> [(Rational, Rational)] -> Rational
05:16:38 <lambdabot> Language.Haskell.Exts.Lexer FloatTok :: (Rational, String) -> Token
05:16:56 <Solonarv> @hoogle Ratio a -> (a, a)
05:16:56 <lambdabot> Type.Hint aRatioOf :: Proxy ? -> Proxy (Ratio ?)
05:16:56 <lambdabot> Data.Ratio (%) :: (Integral a) => a -> a -> Ratio a
05:16:56 <lambdabot> MixedTypesNumPrelude (%) :: Integral a => a -> a -> Ratio a
05:17:12 <int-e> :t denominator &&& numerator
05:17:13 <lambdabot> Ratio c -> (c, c)
05:17:14 <__monty__> Solonarv: I expected it too yeah. *But* you could drop <*> from fibs without it degrading, right?
05:17:18 <int-e> I guess that's the way
05:17:20 <Solonarv> __monty__: yu[
05:17:37 <Solonarv> yup
05:54:55 <fen> oh no! the dreaded quantified constraints!
05:55:04 <epta> looks like 'stack runhaskell Main.hs' doesn't use stack.yaml placed in the same dir. Is there a way to use it?
05:55:15 <fen> there is an error where it cant match a against b because forall a. was used...
05:57:04 <fen> sorry its a long paste... https://pastebin.com/raw/G2bqntpt
05:58:06 <fen> the could not deduce functor error is strange since the quantified constraint on Container seems to give this exact instance
05:58:18 <fen> except, maybe the forall a. is messing it up somehow?
06:01:22 <fen> ok, never mind the second error, it was trivial to solve, but what about that first one?
06:04:39 <fen> hmm, maybe it is the use of a type family in the constraint...
06:17:33 <jakov> Hi everyone ! I am quite new to haskell, and i feel like i can use the applicative notation style for terse code:  I have got a list of functions, that, when applied to a single value should return a list of booleans. I have written it out like 
06:17:33 <jakov> [(boolfunc variable), (boolfunc variable), (boolfunc variable)]
06:17:33 <jakov> But would like to write it like 
06:17:33 <jakov> [boolfunc, boolfunc, boolfunc] <some applicative stuff> variable
06:17:36 <jakov> How would i do that ? Thanks in Advande.
06:18:29 <jakov> **advance :)
06:19:11 <fen> :t [not,True==]
06:19:12 <lambdabot> error:
06:19:12 <lambdabot>     A section must be enclosed in parentheses thus: (True ==)
06:19:17 <fen> :t [not,(True==)]
06:19:18 <lambdabot> [Bool -> Bool]
06:19:34 <fen> :t [not,(True==)] <$> False
06:19:36 <lambdabot> error:
06:19:36 <lambdabot>     • Couldn't match expected type ‘a0 -> b’
06:19:36 <lambdabot>                   with actual type ‘[Bool -> Bool]’
06:20:12 <fen> :t [not,(True==)] (_) False
06:20:13 <lambdabot> error:
06:20:13 <lambdabot>     • Couldn't match expected type ‘t0 -> Bool -> t’
06:20:13 <lambdabot>                   with actual type ‘[Bool -> Bool]’
06:20:24 <fen> :t [not,(True==)] `_` False
06:20:25 <lambdabot> error:
06:20:25 <lambdabot>     • Found hole: _ :: [Bool -> Bool] -> Bool -> t
06:20:25 <lambdabot>       Where: ‘t’ is a rigid type variable bound by
06:20:46 <fen> hmm that doesnt help much
06:21:25 <fen> :t [not,(True==)] (\ fs x -> fmap ($x) fs) False
06:21:26 <lambdabot> error:
06:21:26 <lambdabot>     • Couldn't match expected type ‘(f0 (a0 -> b0) -> a0 -> f0 b0)
06:21:26 <lambdabot>                                     -> Bool -> t’
06:21:35 <fen> rrg, thought that would be it
06:21:50 <jakov> something inbetween fmap and curry should do it xD
06:22:41 <[exa]> schoenmap
06:22:48 <matsurago> jakov: maybe [func, ...] <$> variable ?
06:23:01 <[exa]> s/(True==)/id/ ?
06:23:02 <matsurago> I am a bit a newbie myself ._.
06:23:03 <fen> :t let f = fs x -> fmap ($x) fs in [not,(True==)] `f`  False
06:23:04 <lambdabot> error: parse error on input ‘->’
06:23:09 <fen> :t let f = fs x = fmap ($x) fs in [not,(True==)] `f`  False
06:23:10 <lambdabot> error:
06:23:10 <lambdabot>     parse error on input ‘=’
06:23:11 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
06:23:23 <fen> omg so sorry
06:23:36 <jakov> matsurago [not, (==True)] <$> False
06:23:42 <jakov> [not, (==True)] <$> False
06:23:57 <fen> :t let f fs x = fmap ($x) fs in [not,(True==)] `f`  False
06:23:58 <lambdabot> [Bool]
06:24:02 <fen> right!
06:24:10 <fen> > let f fs x = fmap ($x) fs in [not,(True==)] `f`  False
06:24:12 <lambdabot>  [True,False]
06:24:25 <fen> :t \x -> ($ x)
06:24:26 <lambdabot> a -> (a -> b) -> b
06:24:33 <fen> thats the thing your after
06:24:56 <jakov> thanks fen !!
06:25:30 <matsurago> there should be a shorter way I believe it :3
06:26:25 <fen> @pl  f fs x = fmap ($x) fs
06:26:25 <lambdabot> f = flip (fmap . flip id)
06:26:26 <Rembane> I think you can replace (==True) with id 
06:26:32 <Rembane> :D
06:26:36 <[exa]> >  (==) <$> [1..3] <*> [2]
06:26:38 <lambdabot>  [False,True,False]
06:26:59 <matsurago> jakov: [not, (==True)] <$> [False]
06:27:03 <[exa]> jakov: combination of <$> and <*> helps  ^^
06:31:47 * hackage mtl-compat 0.2.2 - Backported Control.Monad.Except module from mtl  https://hackage.haskell.org/package/mtl-compat-0.2.2 (ryanglscott)
06:31:57 <fen> :t \fs ->  (fs <*>) . pure
06:31:58 <lambdabot> Applicative f => f (a -> b) -> a -> f b
06:33:24 <lyxia> The Applicative docs say "as a consequence of [the Applicative] laws, the Functor instance for f will satisfy: fmap f x = pure f <*> x", that seems to rely on parametricity, or am I missing some other way of deducing that fact? https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Applicative
06:34:48 <fen> but this is the flipped version
06:35:03 <fen> the pure on the other side means its like using a $ prefix
06:37:20 <fen> https://pastebin.com/raw/YPAwUuez
06:37:28 <fen> this is a shorter version of the error^
06:37:49 <fen> (about state base functor instances)
06:38:25 <fen> there seems to be some trouble to do with either quntified constraints or trying to switch the order of the arguments of state
06:38:38 <fen> cant quite fathom
06:43:06 <jakov> thank you for your support, it works :D !
06:49:26 <michalrus> Hey, can anyone tell what that is? :/ https://michalrus.com/hidden/paste/Screenshot-20190428-154754.png
06:49:37 <michalrus> It’s regular http-client…
06:50:01 <michalrus> I just want to call 127.0.0.1:8094… which does respond to /bin/curl…
06:55:07 <klntsky> Why does stack add `Path_*` to other-modules section of cabal package files? Are older versions of cabal able to compile the package with non-existing module in other-modules?
06:56:21 <Solonarv> that module is auto-generated by cabal
06:56:53 <Solonarv> it contains information like name & version of the package, and a few paths/directories- I forget which exactly
06:58:14 <fen> ok, this is probably as short as the error can be; https://pastebin.com/raw/5Xpfzmhm
06:58:58 <Solonarv> klntsky: see the cabal docs: https://cabal.readthedocs.io/en/latest/developing-packages.html#accessing-data-files-from-package-code
07:04:04 <fen> is it a problem to do with QuantifiedConstraints?
07:18:22 <fen> ok, this is the shortest version of the error! https://pastebin.com/raw/ZCs8wWzk
07:19:41 <fen> % class (forall a. Functor (BaseOf f a)) => Container f where   type BaseOf f = (r :: * -> * -> *) | r -> f
07:19:41 <yahb> fen: 
07:19:50 <fen> % class Container f => Test f where  test :: (a -> b) -> (BaseOf f) x a -> (BaseOf f) x b;  test = fmap
07:19:50 <yahb> fen: ; <interactive>:105:98: error:; * Could not deduce (Functor (BaseOf f x)) arising from a use of `fmap'; from the context: Test f bound by the class declaration for `Test' at <interactive>:105:22-25; * In the expression: fmap; In an equation for `test': test = fmap
07:44:47 * hackage grammatical-parsers 0.4 - parsers that combine into grammars  https://hackage.haskell.org/package/grammatical-parsers-0.4 (MarioBlazevic)
07:52:01 <fen> % undefine
07:52:01 <yahb> fen: ; <interactive>:106:1: error:; * Variable not in scope: undefine; * Perhaps you meant `undefined' (imported from Prelude)
07:52:11 <fen> % type family BaseOf f = (r :: * -> * -> *) | r -> f
07:52:11 <yahb> fen: 
07:52:39 <fen> % test :: (forall a. Functor (BaseOf f a)) => (a -> b) -> (BaseOf f) x a -> (BaseOf f) x b ; test = fmap
07:52:39 <yahb> fen: ; <interactive>:108:9: error:; * Could not deduce (Functor (BaseOf f a1)); from the context: forall a1. Functor (BaseOf f a1); bound by the type signature for:; test :: forall f a b x. (forall a1. Functor (BaseOf f a1)) => (a -> b) -> BaseOf f x a -> BaseOf f x b; at <interactive>:108:9-88; * In the ambiguity check for `test'; To defer the ambiguity c
07:53:32 <fen> % test :: (forall a. Functor (y f a)) => (a -> b) -> (y f) x a -> (y f) x b ; test = fmap
07:53:32 <yahb> fen: 
07:53:56 <fen> so it seems to be something to do with type familes and quantified constraints combined
07:54:30 <fen> whats up with that?
07:54:43 <Solonarv> actually it seems to be complaining about ambiguity
07:54:56 <Solonarv> % :set -XAllowAmbiguousTypes
07:54:56 <yahb> Solonarv: 
07:55:23 <Solonarv> % test :: forall f x a b. (forall z. Functor (BaseOf f z)) => (a -> b) -> (BaseOf f) x a -> (BaseOf f) x b ; test = fmap
07:55:23 <yahb> Solonarv: ; <interactive>:111:115: error:; * Could not deduce (Functor (BaseOf f x)) arising from a use of `fmap'; from the context: forall z. Functor (BaseOf f z); bound by the type signature for:; test :: forall f x a b. (forall z. Functor (BaseOf f z)) => (a -> b) -> BaseOf f x a -> BaseOf f x b; at <interactive>:111:1-104; * In the expression: fmap; In an e
07:55:32 <fen> right thats the error
07:55:42 <Solonarv> hm, nope ambiguity isn't the issue
07:57:15 <fen> its a bug?
07:57:25 <Solonarv> could be
07:57:29 <fen> noooo
07:57:47 * hackage minitypeset-opengl 0.2.0.0 - Layout and render text with TrueType fonts using OpenGL  https://hackage.haskell.org/package/minitypeset-opengl-0.2.0.0 (BalazsKomuves)
07:58:36 <fen> well its either that or for some good reason this shouldnt be expected to work
07:58:56 <fen> some intricacies to do with injective type families and quantified constraints
07:59:19 <fen> either way, my code wont compile >:-|
08:01:04 <fen> any idea why this *shouldnt* work?
08:01:56 <fen> anyway, why would the version with the type family complain about ambiguity and the version above using `y' in its place does not
08:02:40 <fen> ooooh, maybe it just needs some TypeApplications somewhere
08:03:11 <Solonarv> oh yeah that could be it
08:03:25 <Solonarv> % test :: forall f x a b. (forall z. Functor (BaseOf f z)) => (a -> b) -> (BaseOf f) x a -> (BaseOf f) x b ; test = fmap @(BaseOf f x)
08:03:25 <yahb> Solonarv: ; <interactive>:112:115: error:; * Could not deduce (Functor (BaseOf f x)) arising from a use of `fmap'; from the context: forall z. Functor (BaseOf f z); bound by the type signature for:; test :: forall f x a b. (forall z. Functor (BaseOf f z)) => (a -> b) -> BaseOf f x a -> BaseOf f x b; at <interactive>:112:1-104; * In the expression: fmap @(BaseOf f x)
08:03:28 <fen> but then its just fmap, and it should be totally bound by its type signature
08:03:46 <fen> like, there is no place to make it more specifiy with some @ symbols
08:04:03 <Solonarv> hm
08:04:09 <Solonarv> I'm inclined to call this a bug
08:04:24 <fen> now what am i supposed to do!
08:04:28 <fen> stupid compiler
08:04:59 <Solonarv> well in this particular case you don't actually need a quantified constraint
08:05:07 <fen> oh!
08:05:12 <fen> how so?
08:05:18 <Solonarv> % test :: forall f x a b. (Functor (BaseOf f x)) => (a -> b) -> (BaseOf f) x a -> (BaseOf f) x b ; test = fmap @(BaseOf f x)
08:05:18 <yahb> Solonarv: 
08:06:06 <lrb> Is there a homogeneous, fixed-size data structure that can be indexed? 
08:06:44 <tsahyt> vectors?
08:07:12 <Solonarv> specifically: vectors with the length fixed at the type level
08:07:36 <tsahyt> more specifically: https://hackage.haskell.org/package/vector-sized
08:07:37 <fen> Solonarv: oh, was I trying to swap the arguments or something that made it not work...
08:07:47 <royal_screwup21> is the "cata" combinator built into haskell?? I'm looking here https://chrispenner.ca/posts/asts-with-fix-and-free but it gives no implementation for it 
08:08:27 <tsahyt> royal_screwup21: recursion-schemes provides it
08:08:29 <lrb> Thanks for the link :)
08:08:31 <royal_screwup21> ah okay it uses recursion-shcemes
08:08:35 <royal_screwup21> yup thanks :)
08:09:42 <Solonarv> fen: no, I think it is actually a bug that this doesn't typecheck if we write it using quantified constraints
08:09:55 <Solonarv> we just don't need to write it using QC in the first place
08:10:41 <fen> that was for an associated type version of it actually
08:11:26 <fen> this version; https://pastebin.com/raw/ZCs8wWzk
08:12:18 <Solonarv> oh, I see
08:12:54 <Wieiner> hello
08:13:03 <Solonarv> yeah I think this needs QuantifiedConstraints and the fact that it doesn't work is a bug
08:13:14 <Solonarv> example is nice and minimal too, probably worth asking about it in #ghc
08:13:17 <Solonarv> Wieiner: hello!
08:15:35 <Wieiner> Solonarv: hello-hello. first time here
08:16:12 <Solonarv> welcome! feel free to ask any questions you may have
08:16:53 <fen> #ghc seems quiet but the bug is there for reference 
08:18:13 <Wieiner> just take a look on book by Miran Lipovacha Haskel for Great Good! and see this irc there
08:33:55 <royal_screwup21> is `left `Add` right` the same as `Add left right`? The datatype is ExprF a = Const Int        | Add a a        | Mul a a
08:34:18 <royal_screwup21> I'm looking at the functor instance defined here: https://www.schoolofhaskell.com/user/bartosz/understanding-algebras
08:34:48 <Ariakenom> royal_screwup21: yes `` is syntax for writing a function infix
08:34:49 <Solonarv> royal_screwup21: yup
08:35:08 <royal_screwup21> ah ok
08:36:47 * hackage hablo 1.0.1.0 - A minimalist static blog generator  https://hackage.haskell.org/package/hablo-1.0.1.0 (tissevert)
08:38:27 <Wieiner> i found cool book RealWorldHaskell. this book is more complicated
08:41:28 <Guillaum> Which library / pattern are you using to work on an in-memory (no need for persistance) database shaped like a relational database (one to one / one to many / many to many relationship, and the need for fast indexes). In a "mutable" object oriented world, I'll use pointers / reference to mutable objects. In Haskell, if I want to keep the persistante data structure, I'll use a lot of `Map Int Item` and 
08:41:35 <Guillaum> do all my references using Int (or newtype around Int). I.e, I'm just emulating pointers. Did I miss something here? Or do you know a DSL / pattern to easilly work on this kind of database?
08:41:49 <merijn> Guillaum: SQLite?
08:42:09 <merijn> Guillaum: I mean, if you want a database, just use one :p
08:44:00 <Guillaum> merijn: you have a point ;) Because I don't care about persistance, I was wondering if it exists another approach.
08:44:16 <merijn> Guillaum: SQLite supports in-memory only, though ;)
08:44:55 <Guillaum> merijn: you have another point ;) I'll have a look at SQL backend then. Thank you.
08:45:19 <merijn> Guillaum: I think for most people the solution to "I want mutable data" is "use mutable data", there's a bunch of different ways depending on the exact usecase
08:45:39 <merijn> Guillaum: sqlite-simple is a nice/simple wrapper around the SQLite API
08:46:40 <tsahyt> I've been working a little tool and thought I'd take polysemy for a spin. I've never really used any of the freer libraries before. Now I'm wondering about Input and Output. it seems like they should be functor-ish (contravariant and covariant respectively) but there are no functions provided in the library.
08:46:47 <tsahyt> am I getting this wrong or is this an oversight?
08:48:47 * hackage minitypeset-opengl 0.2.0.1 - Layout and render text with TrueType fonts using OpenGL  https://hackage.haskell.org/package/minitypeset-opengl-0.2.0.1 (BalazsKomuves)
08:52:13 <royal_screwup21> I don't understand catamorphisms :(
08:52:43 <royal_screwup21> reading this artcile here https://www.schoolofhaskell.com/user/bartosz/understanding-algebras I specfically don't understand the cata function
08:55:05 <royal_screwup21> `cata :: Functor f => (f a -> a) -> Fix f -> a`
08:55:21 <royal_screwup21> what is this (f a -> a)?
09:02:57 <c_wraith> royal_screwup21: it's a type.
09:03:52 <c_wraith> royal_screwup21: specifically, it's a function.  It unifies with concrete types like (Maybe Int -> Int) or ([String] -> String)
09:05:41 <royal_screwup21> is it possible to write oop equivalents for catamorphisms?
09:05:46 <royal_screwup21> it's making my head spin
09:06:01 <royal_screwup21> I sort of understand how the types check out
09:06:06 <c_wraith> it's possible to write an OOP equivalent for any one catamorphism
09:06:28 <monochrom> Yeah I think it's simply s/function/method/ ?
09:07:07 <Solonarv> but most OOP languages aren't powerful enough to write Fix, so obviously you can't write the general form of cata either
09:07:49 <c_wraith> it just occurred to me that the visitor pattern is often a catamorphism, in some view.
09:07:56 <monochrom> I'm just waiting for someone to come along and ask "could you translate the following Haskell type to C type syntax?" just so I can show how C types are less readable.
09:08:26 <c_wraith> I'd much rather use an explicit catamorphism over the visitor pattern. :)
09:08:33 <Solonarv> c_wraith: yes, that came to mind as something vaguely analogous
09:09:32 <Solonarv> monochrom: easy, just involve any/all of: non-enum sum types; function types; parameterized types
09:10:45 <royal_screwup21> but the visitor pattern is just so clear. `abstract class Expr { <T> accept(Visitor<T> v):T }`, then `class BinaryExpr extends Expr { <T> accept(Visitor<T> v):T { return v.visitBinaryExpr(this); }}`
09:10:55 <dolio> monochrom: Can you translate this type to C syntax? (forall r. (a -> r -> r) -> r -> r) -> [a]
09:11:27 <monochrom> I think I can do C++. :)
09:11:52 <c_wraith> royal_screwup21: I don't think there's anything in Haskell as complicated as C++ inheritance. 
09:12:27 <royal_screwup21> what I don't get about this function: `cata alg = alg . fmap (cata alg) . unFix`
09:12:41 <royal_screwup21> how is the base case evaluated at all?
09:12:59 <c_wraith> it's part of alg
09:13:05 <Berengal> Is there some better way to write something like 'case () of _ {...}' ?
09:13:23 <Solonarv> Berengal: well, by itself that doesn't do anything
09:13:29 <royal_screwup21> so unfix is takes a Fix f, return f (Fix f)
09:13:35 <Berengal> I just want guards
09:13:45 <Solonarv> a-ha! there is MultiWayIf
09:14:01 <Solonarv> if | cond1 = result1; | cond2 = result2
09:14:11 <Berengal> nice, thanks
09:14:16 <cocreature> royal_screwup21: it might be helpful if you go through this for a specific choice of f, e.g., f = ListF
09:14:39 <royal_screwup21> yup okay
09:14:41 <Solonarv> oh oops, it's -> not =
09:14:57 <Solonarv> Berengal: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#multi-way-if-expressions
09:15:22 <cocreature> (ListF a) actually
09:15:22 <royal_screwup21> ListF a k = Cons a k | Empty 
09:15:25 <Berengal> That's exactly what I want, thanks!
09:15:42 <royal_screwup21> cocreature yup
09:16:11 <royal_screwup21> let's go with this def of Fix: newtype Fix f = Fx (f (Fix f))
09:17:54 <c_wraith> hmm, I was a bit wrong.  The base case is the combination of alg and fmap.  Each of them contribute.
09:19:12 <monochrom> Well they still need to see Empty to trigger their base case contributions.
09:22:08 <c_wraith> yes.  phrased unclearly.  the base case is *handled* by the combination of fmap (which stops recursing at that point) and alg (which produces the output for that leaf)
09:23:06 <cocreature> fmap takes "Empty @(ListF a (Fix (ListF a))" to "Empty @(ListF a b)" and "alg" takes "Empty @(ListF a b)" to something of type "b"
09:29:13 <philippD> What's the status of could-haskell? I can't get it to compile on the current nixpkgs version and some packages are broken on GHC-8.6.4 and above. Their github repos also seem to be pretty inactive. Is there a more current alternative that I have missed or is cloud-haskell still the way to go for it's usecases?
09:49:54 <Berengal> Is there any good way to give names to arguments when all you do is pattern match on them?
09:50:05 <Berengal> For documentation purposes
09:50:29 <Solonarv> Haddock lets you attach documentation to a function's type signature
09:51:23 <Solonarv> Berengal: https://haskell-haddock.readthedocs.io/en/latest/markup.html#function-arguments
09:51:50 <glguy> Berengal: https://github.com/glguy/irc-core/blob/v2/src/Client/State.hs#L343-L347
09:52:37 <Berengal> Thanks
09:55:23 <fendor> what is the best way to explore a code base such as Cabal? ctrl+f seems inadequate to look up the types, since you have to remember most of them
10:00:55 <Solonarv> browse hyperlinked + highlighted source code courtesy of haddock, perhaps?
10:06:28 <lrb> When defining a record, is it possible to set default values?
10:07:34 <lrb> nevermind, I found my answer.
10:08:32 <Cale> lrb: The answer is no, but that you can define a record having your default values, and use record update syntax to make variations of it.
10:08:40 <Cale> (hopefully that's the answer you found)
10:09:25 <fendor> Solonarv, and if haddock can not be built?
10:11:17 <lrb> Cole: https://stackoverflow.com/a/31965959
10:11:25 <Solonarv> use hasktags to generate tags and jump around using those? not something I've ever done, but I know it's available
10:11:37 <cocreature> fendor: I usually use a combination of grep (or ripgrep to be specific), graphmod + ghci
10:16:32 <Phyx-> \o/
10:17:53 <fendor> what is graphmod?
10:18:07 <fendor> currently, I do roughly the same, ripgrep and vscode.
10:18:10 <fendor> sometimes ghci
10:18:25 <cocreature> https://github.com/yav/graphmod
10:23:47 <fendor> thats a good start. Hopefully it gets better with hie or something like that
10:42:33 <lrb> So I think I'm severely misunderstanding something. I'm now trying to import Data.Default, but ghc can't find it. I tried to install it with cabal, but it can't find it either. What am I missing?
10:45:11 <lrb> https://paste.ee/p/f7Xpd
10:46:12 <fendor> lrb, you tried `cabal install Data.Default`? 
10:46:33 <fendor> you have to install the package, this is just a module
10:46:39 <fendor> @hoogle Data.Default
10:46:40 <lambdabot> module Data.Default
10:46:40 <lambdabot> Data.Default class Default a
10:46:40 <lambdabot> Data.Default.Class class Default a
10:47:03 <fendor> the package is data-default, afaik
10:47:36 <lrb> Hm.. Where would I have found that information?
10:47:59 <fendor> Uhm, I dont know, but the concept is the same as with any other programming language
10:48:00 <cocreature> https://hoogle.haskell.org/?hoogle=Data.Default%20is%3Amodule
10:48:12 <fendor> oh, you meant the package name
10:48:14 <fendor> nvm
10:49:04 <lrb> Yeah. I see now that it has "data-default" in the description on that page. I guess I didn't have the context in which that bit of text was useful.
10:49:10 <lrb> Thanks cocreature 
11:16:09 <fen> there seems to be a workaround to the bug before
11:16:41 <fen> it involves an otherwise unnesacary `x' parameter to the unfolding and folding classes, but it allows the Functor constraint to be written;
11:16:41 <fen> https://pastebin.com/raw/0UjnR4xr
11:25:52 <Athas> Why doesn't stack pass -j to ghc by default?
11:32:17 * hackage aeson 1.4.3.0 - Fast JSON parsing and encoding  https://hackage.haskell.org/package/aeson-1.4.3.0 (AdamBergmark)
12:11:17 * hackage haskell-lsp-types 0.11.0.0 - Haskell library for the Microsoft Language Server Protocol, data types  https://hackage.haskell.org/package/haskell-lsp-types-0.11.0.0 (luke_)
12:12:17 * hackage haskell-lsp 0.11.0.0 - Haskell library for the Microsoft Language Server Protocol  https://hackage.haskell.org/package/haskell-lsp-0.11.0.0 (luke_)
12:34:17 * hackage lsp-test 0.5.1.4 - Functional test framework for LSP servers.  https://hackage.haskell.org/package/lsp-test-0.5.1.4 (luke_)
12:41:17 * hackage wuss 1.1.13 - Secure WebSocket (WSS) clients  https://hackage.haskell.org/package/wuss-1.1.13 (fozworth)
13:21:17 * hackage hslua-module-system 0.1.0 - Lua module wrapper around Haskell's System module.  https://hackage.haskell.org/package/hslua-module-system-0.1.0 (tarleb)
13:31:48 <laika__> hey all, is anyone using nix to build the leksah haskell IDE? im trying to figure out how i can run the "output" of the nix build (ie, sanely start leksah) without necessarily rebuilding things that are outdated. currently, sometimes when i run leksah's `leksah-nix.sh`, occasionally i have to wait a really long time for nix to build some dependencies (not sure if this is cache invalidation or dependency updates, but either way).
13:33:31 <manjaroi3> Hey guys, I don't know if anyone that helped me last semester is still here, but I asked for a lot of help on my Haskell homework and you guys were amazingly helpful
13:34:31 <manjaroi3> Not only was I able to ace the final, which was 90% Haskell-specific questions, but I was also able to help out my roommate on his own assignment this semester. Thanks again for the help last semester
13:35:00 <Cale> laika__: Weirdly, it seems that leksah-nix.sh is using cabal new-build explicitly
13:35:12 <Cale> manjaroi3: Nice!
13:37:16 <laika__> Cale: is that just "weirdly" because cabal new-build is meant to be equivalent to nix?
13:37:53 <Cale> Yeah, I'm just surprised it doesn't just have a nix derivation for it.
13:38:40 <Cale> It's using nix-shell, but then inside whatever shell it gets, it's rebuilding leksah
13:39:23 <Cale> If it was just calling upon a nix derivation for leksah, then there would be a good chance that it was already in the nix store, and wouldn't have to be rebuilt
13:39:50 <Cale> (or available from a binary cache even)
13:40:47 * hackage hslua-module-system 0.1.0.1 - Lua module wrapper around Haskell's System module.  https://hackage.haskell.org/package/hslua-module-system-0.1.0.1 (tarleb)
13:40:47 <laika__> someone from #nix suggested wrapping my command with a NIXPATH environment variable setting, so ill see if that works to keep it from rebuilding. i think ultimately ill file some issues on the leksah repo, around 1) pinning dependencies to prevent unnecessary rebuilds and 2) their usage of nix-shell and nix vs cabal new-build in that script. my thought is that this script is more intended for development on leksah itself
14:27:05 <infinisil> I was the one telling laika that
14:28:32 <infinisil> I just opened https://github.com/NixOS/nixpkgs/pull/60393 because the nixpkgs build has been broken for so long
14:28:47 <infinisil> It's unfortunate that they don't pin dependencies in these .sh scripts
14:34:10 <tb15> Hello, I'm trying to understand some code (https://termbin.com/up5b) that is generated using BNFC. (Beware im a novice) Specifically the run function. I'm trying to work out how to use the generated lexer / parser to return an AST. I don't understand how the input is passed to the parser, nor how 'show' seemingly produces an AST. Any help greatly appreciated :)
14:41:31 <hc> show is part of the "Show" typeclass. ts is of a type implemented by the lib you're using so calling show on tx will call some code defined by that library
14:43:23 <tb15> Ok, so the real work is being done in the line
14:43:28 <tb15> "run v p s = let ts = myLLexer s in case p ts of..." ?
14:44:26 <hc> let ts = myLLexer s     <-- that part defines ts to be the result of a call to myLLexer with parameter s
14:44:36 <hc> Which, in turn, is passed to the run function
14:44:53 <tb15> ok, that makes sense :) 
14:44:55 <hc> then p is calles with ts as parameter
14:45:27 <hc> the result is evaluated by the rest of that case statement. Either it's a "Bad s", s containing an error msg probably, or "Ok tree", where tree is probably the parse tree
14:46:03 <tb15> and the v throughout is verbosity...?
14:46:08 <hc> So I'd say mylexer returns a stream of tokens with no way to fail, the result (the tokens) is then passed to the parser function p which can fail
14:46:20 <hc> Looks like it, yeah
14:46:39 <hc> Handled by the putStrV function. If v > 1 it'll print the string passed to it
14:47:43 <hc> The let syntax can be a bit confusing..
14:47:52 <hc> > let a = 1 in a + a
14:47:53 <lambdabot>  2
14:48:13 <hc> It just defines some variables that are valid in the statement that follows after the "in"
14:48:43 <hc> Unless let is used inside a do block, in which case the defined variables are valid for the rest of the do block, no "in" required
14:49:32 <tb15> ohh ok 
14:49:42 <tb15> yea it is a bit confusing 
14:50:13 <tb15> Ok, so I'm gonna try some more stuff and see how it goes
14:50:23 <tb15> thanks for your help :)
14:50:39 <hc> you're welcome
14:50:59 <tb15> actually one more
14:51:03 <tb15> sorry! 
14:51:09 <JappleAck> it's not confusing if you try to read it, like "let A be(=) 1 in a + a(some expression)"
14:52:17 * hackage telega 0.2.8 - Telegram Bot API binding  https://hackage.haskell.org/package/telega-0.2.8 (iokasimovmt)
14:52:40 <hc> tb15: go ahead
14:53:41 <hc> JappleAck: it is a bit confusing imho if written like this: let ts = myLLexer s in case p ts of ... ;-)
14:54:07 <tb15> does 'type ParseFun a = [Token] -> Err a' define a parser type (class), that takes any input, a (where a is a type variable?) 
14:54:15 <tb15> basically how then is the parser called?
14:54:21 <hc> that let statement could be rewritten into "case p (myLLexer s) of"
14:55:14 <tb15> im still trying to wrap my head around the type system in haskell.. :/
14:55:21 <JappleAck> or even `case p $ myLLexer s of`
14:55:46 <hc> That "type" statement defines a type alias, meaning writing "ParseFun a" is equivalent to writing "[Token] -> Err a"
14:56:12 <JappleAck> tb15, consider `type' prefix as `let' but for types)
14:56:16 <hc> The -> indicates  it's a function, so It's a function that is given a list of tokens and returns something of type "Err a"
14:56:51 <JappleAck> while `let' is for values
14:57:11 <hc> So if you have x of type "type ParseFun a" and y is of type [Token], you can just write "x y" to call x
14:58:13 <hc> "case p ts of"... Calls p (which is of type ParseFun a) with ts, then the case block evaluates the return value
14:59:52 <tb15> ahh ok 
14:59:53 <tb15> very concise!
15:00:27 <tb15> the case block handling failure, 'Bad' and acceptance, 'Ok' ...
15:01:10 <hc> Yeah, those two options are defined by the type "Err a". Which is probably defined in the parser library you're using, it's nonstandard
15:01:35 <hc> It's what's called an algebraic datatype, https://wiki.haskell.org/Algebraic_data_type
15:02:09 <JappleAck> tb15: every time you apply an argument to a function one arrow (in type) is sliced.
15:02:09 <JappleAck> like you have `plus :: Int -> Int -> Int; plus a b = a + b' and you apply `plus 1' and type is `(Int ->) Int -> Int' now (Int ->) is sliced
15:02:44 <JappleAck> and you have only `Int -> Int`
15:03:06 <tb15> @hc ahh ok i see
15:03:06 <lambdabot> Maybe you meant: rc ghc
15:03:19 <tb15> oh dear I've upset a bot
15:03:38 <JappleAck> tb15: you don't have to use @ symbol to mention somebody
15:03:54 <fen> kind of stuck, not sure how to write this; https://pastebin.com/raw/HuGDksTf
15:03:55 <tb15> JappleAck (test) ?
15:04:08 <tb15> ah ok i see :)
15:04:21 <tb15> so, someone has the alias so ..?
15:04:42 <tb15> and 
15:05:03 <tb15> "like you have `plus :: Int -> Int -> Int; plus a b = a + b' and you apply `plus 1' and type is `(Int ->) Int -> Int' now (Int ->) is sliced" is that partial application then? (currying if my brain works ? )
15:05:43 <JappleAck> tb15: that's correct, everything is curried in haskell
15:06:02 <tb15> which is very powerful for reasons i've yet to understand..
15:06:14 <tb15> ?
15:06:27 <JappleAck> tb15: if you apply all arguments at once you may just consider that as applying them one by one, until all arrows will be sliced
15:06:57 <tb15> but i could theoretically pass around a partially sliced arrow?
15:07:40 <JappleAck> tb15: of course, here is an example: `map (*2) [1..10]'
15:08:37 <tb15> [2,4,6,8,10,12,14,16,18,20]
15:08:39 <JappleAck> tb15: you just partially applied `2' to multiplication operator, and passed a function of two arrows to `map' function as an argument
15:09:38 <JappleAck> tb15: you also may have a list of partially applied functions. there's actually no difference between values and functions
15:09:39 <tb15> uhh give me two seconds to try understand that
15:09:54 <tb15> functions = first class ?
15:10:45 <JappleAck> tb15: yes, and more, you may consider values as functions with no arguments (no arrows)
15:11:27 <JappleAck> > map (\partallyAppliedFn -> partallyAppliedFn 2) [(1*), (2*), (3*), (4*), (5*)]
15:11:29 <lambdabot>  [2,4,6,8,10]
15:11:43 <tb15> so the \ is a lambda ?
15:11:51 <JappleAck> tb15: yup
15:12:04 <tb15> uhh so how does that above amp work?
15:12:05 <tb15> *mao 
15:12:07 <tb15> map
15:12:07 <tb15> even 
15:12:59 <tb15> the \partiallyAppliedFn binds to each thing in the list?
15:13:27 <tb15> or, why is the second partiallyAppliedFn not a a lambda? 
15:13:51 <JappleAck> tb15: type of map is `(a -> b) -> [a] -> [b]` which you could read (it's the same) as: `(a -> b) -> ([a] -> [b])` which means you provide a function `a -> b` to `map` and you get list (multiple) version of that function, which now you could apply on lists
15:14:24 <tb15> ok....
15:14:25 <JappleAck> tb15: because (1*) or (2*) is a function of two arrows `Int -> Int`
15:14:46 <tb15> because its only partially applied? 
15:15:02 <JappleAck> `(\partallyAppliedFn -> partallyAppliedFn 2)' is a lambda where `partallyAppliedFn' is an argument with function like (1*) or (2*)
15:15:10 <JappleAck> tb15: yes
15:16:24 <tb15> so is that how things like parser combinators work? 
15:16:37 <tb15> partially building something up and passing the result around
15:16:39 <tb15> ?
15:16:43 <JappleAck> first argument of `map' is `a -> b' which means `a' or `b' is anything you may imagine, they both could be Int or another function
15:17:03 <tb15> a and b differ meaning they can be different types too, or no?
15:17:15 <JappleAck> tb15: it could be, depends on specific case
15:17:31 <tb15> ah ok 
15:17:59 <fen> seems like its some confusion resulting from too much programing at type level and confusing polymorphism at various levels
15:18:05 <JappleAck> tb15: yes, `a' and `b' could be the same type or could be completely different types
15:18:07 <fen> seems like a class should help
15:20:50 <tb15> I don't follow..?
15:20:55 <tb15> fen ^
15:23:52 <tb15> jumping back to that generated code, I can call myLLexer (an instance of myLexer) like this in ghci : 
15:23:58 <tb15> myLLexer "sig Name, Addr { }"
15:24:09 <tb15> which works and returns a string of tokens
15:24:45 <tb15> then the rest of the main file 
15:24:49 <tb15> main function * 
15:25:10 <tb15> does this : "  [] -> getContents >>= run 2 pSpecification"
15:25:56 <tb15> which is calling run with the input, and default (apparently) verbosity of 2?
15:26:13 <fen> seems like this is the way to do it; https://pastebin.com/raw/mje68jvf
15:26:47 * hackage bioinformatics-toolkit 0.7.0 - A collection of bioinformatics tools  https://hackage.haskell.org/package/bioinformatics-toolkit-0.7.0 (kaizhang)
15:27:28 <fen> seems strange to use an extra parameter to a class to represent what would otherwise be the output of a type family
15:28:25 <fen> does that mean everything type families can do could be done with classes before type families were even a thing?
15:31:54 <fen> and does that mean there is some kind of way to write type synonyms using classes?
15:32:02 <c_wraith> No.
15:32:24 <c_wraith> It means everything *other* than that is possible with fundeps.  and fundeps have a lot better inference properties sometimes.
15:33:02 <fen> not even with some type equalities to wrangle the resulting constraint?
15:33:50 <hololeap> can someone give me a tldr of what this library is about? https://hackage.haskell.org/package/repa
15:33:57 <hololeap> "Repa provides high performance, regular, multi-dimensional, shape polymorphic parallel arrays."
15:34:16 <hololeap> what does 'regular' 'shape-polymorphic' and 'parallel' mean in this context?
15:34:40 <c_wraith> regular means that it's an n-dimensional rectangle.  
15:35:17 <fen> that seems contradictory to shape polymorphic, unless that just means the width/hight etc
15:35:26 <c_wraith> polymorphic is about the contents.
15:35:38 <fen> the contents have "shape"?
15:35:42 <JappleAck> hololeap: multidimensional efficient arrays
15:35:42 <c_wraith> err, sorry
15:35:52 <c_wraith> in repa, a "shape" is the list of dimensions
15:36:18 <fen> parallel must mean about its use of zipping together adjacent columns for "stencils"  
15:36:23 <JappleAck> which are design for efficient parallelism of computations with that arrays
15:36:25 <c_wraith> parallel means parallel
15:36:36 <c_wraith> ie, it does its operations on multiple cpus
15:36:54 <hololeap> ok, wonderful. thanks everyone
15:38:22 <fen> % class PairSynonym a b (a,b)
15:38:22 <yahb> fen: ; <interactive>:114:23: error:; Unexpected type `(a, b)'; In the class declaration for `PairSynonym'; A class declaration should have form; class PairSynonym a b c where ...
15:38:35 <fen> omg
15:39:22 <fen> % class PairSynonym a b c | a b -> c ; instance PairSynonym a b (a,b) 
15:39:22 <yahb> fen: 
15:40:26 <fen> % test :: PairSynonym Int Int c => c -> Int; test (a,b) = a+b
15:40:26 <yahb> fen: ; <interactive>:116:49: error:; * Couldn't match expected type `c' with actual type `(Int, Int)'; `c' is a rigid type variable bound by; the type signature for:; test :: forall c. PairSynonym Int Int c => c -> Int; at <interactive>:116:1-41; * In the pattern: (a, b); In an equation for `test': test (a, b) = a + b; * Relevant bindings include test :: c -> In
15:40:31 <fen> hmmm
15:42:28 <fen> % type family PairSynonym a b = c | a b -> c where instance PairSynonym a b = (a,b)
15:42:29 <yahb> fen: ; <interactive>:117:37: error: parse error on input `b'
15:42:45 <fen> % type family PairSynonym a b = c | a b -> c where  PairSynonym a b = (a,b)
15:42:45 <yahb> fen: ; <interactive>:118:37: error: parse error on input `b'
15:42:48 <fen> !?
15:43:18 <iqubic> What's the issue right now?
15:43:39 <fen> the injective type?
15:44:02 <fen> % type family PairSynonym a b = c where  PairSynonym a b = (a,b)
15:44:02 <yahb> fen: 
15:44:22 <fen> % test :: PairSynonym Int Int -> Int; test (a,b) = a+b
15:44:22 <yahb> fen: 
15:44:39 <fen> so classes are not ok for that for some reason?
15:45:38 <fen> because classes are not closed?
15:47:18 <fen> well basically its because the Combine class of the paste isnt going to work properly for;
15:47:22 <fen> data Stream s a = Stream (a,s)
15:47:23 <fen>  data Stream_r r s a = Stream_r (r a,s)
15:48:17 * hackage lsp-test 0.5.2.0 - Functional test framework for LSP servers.  https://hackage.haskell.org/package/lsp-test-0.5.2.0 (luke_)
15:48:48 <fen> instance Combine (Stream s1 a1) (Stream_r r s2 a2) (Stream (s1,r s2) (a1,a2))
15:49:28 <fen> here, if we could write, type Stream_r r s a = Stream (r s) a
15:49:40 <fen> which we cant because it needs to be partially applied elsewhere in the code
15:50:47 * hackage poly 0.2.0.0 - Polynomials  https://hackage.haskell.org/package/poly-0.2.0.0 (Bodigrim)
15:51:04 <fen> then it would not seem so strange that the `r' appears in the "Stream" return parameter of Combine
15:51:36 <fen> thought maybe there could be some way to wrangle partially applied type synonyms using classes somehow 
15:52:25 <fen> (its for hyloZip unfold fusion!)
15:53:46 <fen> here is the code so far
15:53:46 <fen> https://pastebin.com/W78R21W7
15:54:35 <tb15> more general question, if i now have two ASTs and want to transform one into another where should I start? ...
15:54:48 <fen> traversing?
15:55:22 <fen> oh, no, like traverse implemented using fold, but taking the constructor of the new AST
15:56:30 <tb15> more simple, like here is a type X in my ast, i know that maps to type Y in my other AST
15:56:40 <tb15> now lets mutate AST containing X to Y
15:57:26 <tb15> basically just writing a compiler, but without any type checking or optimisation 
15:58:08 <fen> you would need to may from X to Y and then the constructor of the "convert" could accept it
15:58:12 <fen> map*
15:58:24 <fen> well not map, just apply a function from X to Y
15:58:46 <fen> thats the type taken by the constructor right?
15:59:27 <tb15> i think so
15:59:38 <tb15> i've just got no idea where to start..
16:00:38 <fen> how is the tree represented, is it some kind of Fix shape?
16:01:07 <tb15> https://termbin.com/fkgw
16:01:14 <tb15> is the initial one
16:01:23 <fen> jesus
16:01:29 <tb15> yeah.....
16:01:32 <tb15> fun fun fun
16:01:46 <tb15> I don't want to try all of it
16:02:04 <tb15> really just the `data Paragraph` type
16:02:20 <tb15> data SigDecl
16:02:21 <tb15> and 
16:02:28 <tb15> data FunDecl
16:02:37 <fen> BNF converter ?
16:02:47 <tb15> yeah, I think i made a mistake in trying to use that
16:02:54 <tb15> it's been a huge time sink and a real pain 
16:03:19 <tb15> should've used something like parsec 
16:03:31 <tb15> (i think, again I'm very new to this)
16:04:23 <fen> oh right, so you have this monstrous datatype and you want to parse it into something less sprawling  
16:04:38 <tb15> yeah
16:05:14 <tb15> i er
16:05:22 <fen> well, there are too many constructors here to write code to parse them all, so without more code generation your kind of stuck
16:05:23 <tb15> think i can do it just with pattern matching and normal functions 
16:05:35 <tb15> but im unsure
16:05:36 <tb15> ah 
16:05:45 <tb15> what does that mean?
16:05:57 <tb15> more code generation ?
16:06:33 <fen> well whatever produced this "generated code"
16:06:35 <tb15> that file is my (attempt) at translating this http://alloy.lcs.mit.edu/alloy/documentation/alloy4-grammar.txt to LBNF, then using the bnf converter 
16:06:43 <tb15> to generate what you've seen above
16:08:12 <fen> very distressing 
16:08:22 <tb15> yes...
16:09:40 <fen> so your thinking if you didnt go via the bnf converter, that you might have some way to get at the code as it passed through it
16:09:57 <fen> to attempt to modify it there, instead of now having to parse its output
16:10:03 <tb15> more i wouldnt have such a large sprawling data type 
16:10:33 <tb15> the bnf converter route needs an LALR(1) (I think) grammar which i've realised the alloy one is not
16:11:57 <fen> a "look ahead left right" parser?
16:12:45 <fen> im really not going to be able to help much sorry
16:12:49 <tb15> it's ok :) 
16:12:53 <tb15> everything helps to be honest
16:30:18 <tb15> fen is this too big still, or less daunting ? 
16:30:19 <tb15> https://termbin.com/4nag
16:58:06 <Xunie> So I've been using record update syntax for a bit now, but it still feels like the syntax is a little verbose
16:58:46 <Xunie> update state = state { text = init (text state) }
16:58:49 <Xunie> That's just a little too verbose
16:59:06 <Xunie> update state = state { text = init . text }
16:59:54 <Xunie> Can't I do that instead? No I can't. Because I can't assign text to be equal to a non applied function. So what do I do here? Is there a "better" or "cleaner" syntax out there? 
17:03:52 <JappleAck> Xunie: have you tried using lenses?
17:04:03 <JappleAck> Xunie: like from "lens" package for example
17:04:10 <Xunie> I've heard about them, lemme take a gander.
17:05:15 <JappleAck> Xunie: they probably will solve your issues. see https://hackage.haskell.org/package/lens
17:05:38 <Xunie> Well, I can solve it the old school way, and considering this is kinda time sensitive, I don't think I'll play with lenses just yet.
17:06:00 <Xunie> It's very good to know a solution like that is out there, but right now? It's a bit overkill.
17:06:17 <JappleAck> Xunie: also have a look at RecordWildCards extension too
17:07:20 <c_wraith> lenses are absolutely overkill for any single use.  The neat thing is that the idea generalizes over so many use cases, and ends up being a really practical tool to do lots of things.
17:07:53 <c_wraith> Like, they do way more than record updates.  They're about the much more broad category of "data manipulation"
17:08:30 <Xunie> It seems that functional programming just has a lot of this "Let's generalize it and apply it everwhere" stuff, so in the end you end up with a language that's just as complex as C++ but everything is sectioned off with thousands of weird little functions that does what you want to write in less characters.
17:08:54 <Xunie> Or maybe I'm just new to Haskell, which is more likely. :^)
17:09:19 <c_wraith> The big difference from C++ is that so much complexity is in libraries that is in the core language in C++.  :)
17:09:40 <Xunie> I dunno, it feels like there's a lot of features and hidden syntax to haskell I just "have to know" and I never see it explicitly defined. Should I grab a bottle of wine and read the Haskell spec or what?
17:10:30 <c_wraith> eh.  the core language is pretty small.  The extensions add a lot.  Maybe the syntactic extensions section of the GHC user's guide. :)
17:10:32 <Xunie> c_wraith, well yeah, that makes Haskell better in that regard, even if you're not looking at the main core which "makes FP 'better'"
17:10:46 <Xunie> Thanks dude, c_wraith.
17:10:55 <JappleAck> Xunie: you, as an architect of your app are deciding how many abstractions you'll use.
17:10:55 <JappleAck> but functional programming is about composing abstractions, composing primitives to more complex items, and those items to even more complex.
17:11:09 <c_wraith> I still claim that nothing in Haskell (even in the extensions) is as complicated as inheritance in C++ :)
17:11:25 <Xunie> JappleAck, I just feel like the abstractions are getting to me. I feel like I'm descending down that "iceberg" picture.
17:11:37 <JappleAck> at the end, your whole program is one big composition of functions
17:11:53 <c_wraith> it's cool to say "this is enough for now, I'm not going to deal with those other topics until I'm comfortable"
17:12:26 <Xunie> c_wraith, well, I'd love to plunge in right now, but I know I'll never finish what I gotta finish in the timeframe I need to.
17:12:37 <Xunie> That's why I was so eager to just plunge straight into Haskell when this fell in my lap.
17:12:58 <Xunie> I don't half-ass when I'm doing new things. I only go full-ass!
17:13:31 <Xunie> Thanks a lote JappleAck & c_wraith. I've got some more stuff to look at.
17:13:49 <Xunie> I feel like in the past week or two, I've learnt more haskell than I have all my life.
17:17:54 <Xunie> Man, haskell really tortures you psychologically if you write ugly code that still works.
17:18:40 <Xunie> I just stumbled into a situation where I realized "This is not the right solution" simply because the code looked ugly...
17:26:54 <dyl> Xunie: just wait until you go back to writing in other languages :p
17:27:38 <Xunie> dyl, let's just say I'm really liking this "using spells to conjuring up the spirits of the computer" stuff.
17:27:42 * Xunie puts on wizard hat
17:28:19 <dyl> If you’re having trouble adapting the exercises in that book to modern Lisp... 
17:28:20 <dyl> https://docs.racket-lang.org/sicp-manual/
17:28:37 <dyl> Prebuilt racket dialect for the book :) 
17:28:45 <Xunie> I think Lisp is elegant, but I know more haskell than Lisp.
17:28:48 * dyl I put on my wizard hat and robe.
17:28:56 <Xunie> I was making more of a reference to FP than to Lisp, but nice that you caught on. :p
17:29:10 <dyl> Lisp is elegant in that it does a lot with very few primitives. It’s RISCy.
17:29:35 <JappleAck> Racket runtime is very fat
17:29:41 <dyl> \me [Smalltalk intensifies]
17:29:48 <jackdk> dyl if you're referencing what I think you're referencing, isn't it "robe and wizard hat"?
17:29:56 <dyl> Yes, sorry haha. 
17:30:11 <JappleAck> like helloworld with 2-3 lines of code from example on home page may eat about 200mib
17:30:21 <Xunie> jackdk is the true netizen among us.
17:30:28 <dyl> Racket can be great fun though. 
17:30:39 <Xunie> I don't like fat programs.
17:30:51 <dyl> That said I would love to just have a lightweight minimal Smalltalk style language that compiles down and has full compatibility with all C.
17:31:00 <dyl> Wait, that’s Objective-C ;) 
17:31:19 <dyl> I will die on the hill that Objective-C does not deserve the criticisms. It’s good fun to implement, and pretty easy.
17:33:24 <dyl> Java made a mistake by discarding the explicit message passing metaphor imo. That said, while I am not a huge fan of Java, from the brief interactions I’ve had with him, James Gosling is very a funny and friendly dude. 
17:34:01 <dyl> To qualify: there’s a reason Haskell doesn’t have a great UI story beyond FRP. 
17:34:22 <dyl> And that’s because fully static languages (while great for business logic!) are suboptimal for UI code.
17:34:48 <JappleAck> you could just see how drracket ate more than a gig: https://youtu.be/TfehOLha-18?t=493
17:47:47 * hackage th-abstraction 0.3.1.0 - Nicer interface for reified information about data types  https://hackage.haskell.org/package/th-abstraction-0.3.1.0 (ryanglscott)
18:32:57 <jusss> how to make a type that can have Int or Bool, nothing else,  data T = Int | Bool  ???
18:33:09 <dyl> Either Int Bool? 
18:33:15 <dyl> @src Either 
18:33:15 <lambdabot> Source not found. Are you on drugs?
18:33:22 <dyl> @src Data.Either.Either
18:33:23 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
18:33:29 <jusss> aha
18:33:42 <jusss> dyl: data T = Either Int Bool?
18:33:48 <dyl> Yup. 
18:34:04 <dyl> Either A B is the dual of (A, B) [or Tuple A B if you prefer]
18:34:18 <dyl> Tuple is one of both (a product), Either is one or the other (a coproduct).
18:34:21 <jusss> dyl: and when I want to use this value, I should use Either 3 or I need Either 3 True?
18:34:38 <dyl> data Either A B = Left A | Right B.
18:34:53 <dyl> a b*
18:34:56 <jackdk> `data T = I Int | B Bool` or `type T = Either Int Bool`, depending on whether you want T to be a new type or an alias
18:35:05 <dyl> ^ 
18:35:20 <dyl> Tbh I would just use Either unless there’s a need to do otherwise as you get a lot of stuff for free.
18:35:32 <jusss> what is this Left and Right  ,  I and B here?
18:35:44 <jusss> just a Value Constructor? and meaningless?
18:35:46 <dyl> data Either a b = Left a | Right b
18:35:54 <dyl> They’re just the constructor for each case. 
18:36:27 <dyl> Pull up google on Data.Either.
18:36:27 <dyl> Hoogle*
18:36:50 <jusss> then I see, Int and Bool both are type constructor, so if they want to be a value , they need a value constructor, right?
18:38:55 <dlyang> use GADTs extension  data T a = where I :: a ->Int B:: a ->Bool
18:41:04 <JappleAck> data T a = where I :: a -> Int ; B :: a -> Bool
18:43:53 <JappleAck> but it still incorrect and supposed to be something like this: data T a where I :: a -> T Int ; B :: a -> T Bool
18:43:56 <jusss> data T a = I a | B a,   
18:44:50 <JappleAck> jusss: in your case you could have `I True' and `B 123'
18:47:33 <JappleAck> even this: data T a where I :: Int -> T Int ; B :: Bool -> T Bool
18:50:45 <glguy> Is there any CPP that can tell a module is being loaded in GHCi?
18:51:27 <glguy> higher-level desire, avoiding: foreign exports breaking ghci
18:51:41 <glguy> I don't care if the foreign exports don't work in GHCi, I want everything else to work
19:11:54 <monochrom> glguy: Turning on -fobject-code allows loading in ghci, but this also means you can only use what's exported, i.e., you lose the *
19:12:12 <glguy> Yeah, I know about that one but want to avoid it
19:14:16 <jusss> data T = Either a b
19:15:06 <jusss> data T = Either Int Bool 
19:15:31 <jusss> Either 3 is ok , but Either True is not, so it must be Either 3 True?
19:16:16 <pavonia> glguy: I used something like :set -DGHCI in the .ghci file for that in the past
19:17:06 <glguy> Ah, that could work well then. I was doing something with CPP and a cabal flag earlier. This is much more automatic
19:18:04 <glguy> Thanks!
19:19:56 <pavonia> No problem
19:23:22 <Squarism> i have a test that compares two "semi big" datastructures. Is there a way of comparing 2 records but omitt certain fields?
19:26:08 <jle`> Squarism: you can convert them to an extensible record type, like vinyl maybe
19:26:35 <Squarism> jle`, ok ill take a look at that
19:26:45 <geekosaur> jusss, that sounds confused. "Either 3" would be an unsaturated type, with a type level natural
19:27:17 <geekosaur> True is not a type unless you enable DataKinds
19:27:22 <jle`> Squarism: also GHC.Generics alone can be used to simulate an extensible record type, but it would require a bit of legwork
19:27:48 <jusss> geekosaur: I should use Either Int?
19:27:50 <jle`> vinyl has the nice ability to automatically generate subsets and intersections
19:28:10 <geekosaur> ...but I suspect you're getting tripped up by type level stuff you didn't intend. and your real problem is that the value level constructor for Either is not Either. there is Left and there is Right
19:29:18 <geekosaur> Either 3 is unlikely to be something you want, it's ghc assuming you're trying to do something advanced
19:29:19 <jusss> geekosaur: but now dat T =Either Int Bool,  
19:29:38 <geekosaur> with that you can make values Left 3 and Right True
19:29:52 <geekosaur> you do not use Either to make a value. it makes a type, not a value
19:30:05 <geekosaur> o, wait, I see your confusion
19:30:06 <jusss> geekosaur: but that Left 3 or Right True is Either, not T
19:30:12 <geekosaur> you ccreated a new value level constructor Either with that
19:30:33 <geekosaur> which requires both the Int and the Bool and has no relationship to the *type* Either
19:30:52 <geekosaur> % data T = Either Int Bool
19:30:52 <yahb> geekosaur: 
19:31:00 <geekosaur> % :t Either 3 False
19:31:00 <yahb> geekosaur: T
19:31:14 <jusss> % :t Either 3
19:31:14 <yahb> jusss: Bool -> T
19:31:14 <geekosaur> % :t Either 3
19:31:14 <yahb> geekosaur: Bool -> T
19:31:17 <geekosaur> incomplete
19:31:26 <geekosaur> because it's partially applied
19:31:48 <geekosaur> but you're confusing yourself by calling it Either
19:32:05 <geekosaur> which... I suspect you did not want. a "data" definition *requires* a constructor
19:32:18 <jusss> geekosaur: aha, so this 'Either' in 'data T = Either Int Bool' has no relationship with 'Either a b = Left a | Right b'?
19:32:24 <mniip> perhaps they wanted data T = C (Either Bool Int)
19:32:26 <geekosaur> here, you called it Either, which will be unrelated to the exxisting type Either
19:32:51 <geekosaur> % data T1 = MkT1 Int Bool -- same thing, different constructor name
19:32:52 <mniip> jusss, correct, they live in different namespaces
19:32:52 <yahb> geekosaur: 
19:33:33 <mniip> data A = B C
19:33:40 <mniip> A is a newly declared datatype
19:33:50 <mniip> B is a newly declared constructor (a value)
19:33:55 <mniip> C is a type
19:34:31 <mniip> some find this mix of namespaces confusing I guess
19:34:35 <jusss> mniip: data T = C (Either Bool Int),  what this C construct?
19:34:46 <mniip> C is just a name for the constructor
19:34:50 <mniip> you have to give it some name
19:34:51 <jusss> C (Either ? ?)
19:35:45 <mniip> not sure what you're asking
19:37:08 <jusss> mniip: what's the T type data like?
19:38:08 <geekosaur> a value of this type T looks like C (Left True) or C (Right 4)
19:39:17 <geekosaur> the parentheses are required here, `C Left True` would attempt to apply a value (C Left) (which is a type error) as a function to the value True
19:48:33 <jusss> geekosaur: if the type constrctor to do a value, I should put a value constructor on it? 
19:48:40 <jusss> do as
19:48:52 <geekosaur> ...what?
19:49:05 <jusss> data T = Maybe Int, this Maybe is nothing with type constructor Maybe
19:49:16 <jusss> this Maybe is value constructor here
19:49:23 <geekosaur> right, it's defining a data constructor, not a type constructor
19:49:30 <jusss> but I can use data T = C (Maybe Int)
19:49:44 <jusss> and this Maybe is still that Maybe type constructor
19:49:45 <jle`> you can use both, but they mean two different things
19:50:08 <jle`> `data T = Maybe Int`, you're declaring a new data type T, with a value constructor Maybe
19:50:12 <jle`> that contains an Int
19:50:13 <geekosaur> data ATypeConstructor {- possibly some type parameters -} = ADataConstructor {- possibly some types for "contained'/associated values here -}
19:50:33 <jle`> with `data T = C (Maybe Int)`, you're declaring a new data type T, with value constructor C, that contains a (Maybe Int)
19:53:03 <jusss> ok
19:54:15 <jle`> it's admittedly a little inconsistent because you flip back and forth between two levels of things
19:54:32 <jle`> that's one reason why a lot of people think GADT syntax is more consistent/easier to undersatnd in this regard
19:54:51 <jle`> it's an alternative syntax to declaring new data types and constructors
20:00:47 * hackage Villefort 0.1.2.18 - Villefort is a task manager and time tracker  https://hackage.haskell.org/package/Villefort-0.1.2.18 (AliceReuter)
20:03:47 * hackage stack2nix 0.2.3 - Convert stack.yaml files into Nix build instructions.  https://hackage.haskell.org/package/stack2nix-0.2.3 (domenkozar)
20:15:17 * hackage dhall 1.22.0 - A configuration language guaranteed to terminate  https://hackage.haskell.org/package/dhall-1.22.0 (GabrielGonzalez)
20:23:17 * hackage dhall-bash 1.0.20 - Compile Dhall to Bash  https://hackage.haskell.org/package/dhall-bash-1.0.20 (GabrielGonzalez)
20:24:17 * hackage dhall-text 1.0.17 - Template text using Dhall  https://hackage.haskell.org/package/dhall-text-1.0.17 (GabrielGonzalez)
20:28:17 * hackage dhall-json 1.2.8 - Compile Dhall to JSON or YAML  https://hackage.haskell.org/package/dhall-json-1.2.8 (GabrielGonzalez)
21:07:45 <jusss> {-#LANGUAGE GADTs #-}  will not enable GADTs in ghci?
21:08:11 <c_wraith> No, ghc doesn't support standalone pragmas.  You can use  :set -XGADTs
21:08:28 <c_wraith> err, ghci
21:19:19 <neverkas> hi
21:27:16 <pavonia> Welcome
21:35:52 <jlamothe> Can anyone point me to a resource that explains what's going on with the pipe in the type signature for Control.Monad.Except.MonadError?  I'm not familiar with this syntax.
21:38:20 <jle`> jlamothe: do you mean Control.Monad.Error.MonadError ?
21:38:46 <jlamothe> Yes.  That's the one.
21:38:51 <jlamothe> jle`: ^
21:38:58 <jle`> ah. it's Functional Dependencies syntax
21:39:18 <jle`> that's the googlable keyword, if that's what you are looking for :)
21:39:28 <jlamothe> jle`: Thanks.  :)
21:40:21 <jle`> jlamothe: ah, actually Control.Monad.Except.MonadError is correct too, sorry :)
21:40:31 <jle`> must have just missed it on the module list
21:40:58 <jlamothe> The former is deprecated, apparently.
21:41:34 <jle`> jlamothe: the basic idea is that `MonadError e m | m -> e` basically means that e must be inferrable from m
21:41:50 <jlamothe> jle`: Kind of like a type family?
21:42:16 <jle`> in the end you can use both tools to get the same functionality in this specific situation
21:42:34 <jle`> but it just means here that if you know m, then you must also know e
21:42:42 <jlamothe> Ah.  I've found some documentation on it.  I'll give that a look over.
21:42:43 <jle`> so `MonadError e Int` is not allowed as an instance
21:43:00 <jle`> er, maybe let's use `MonadError e Maybe`
21:43:11 <jle`> because if i told you m is Maybe, it doesn't tell you anything about e
21:43:17 <jle`> but, `MonadError e (Either e)` is an allowed instance
21:43:26 <jle`> because if i told you m is `Either Int`, then you know that e is Int
22:08:40 <dminuoso> If my GC continuously copies more data, this might be indicative of a memory leak right?
22:09:05 <Xunie> I doubt that.
22:09:11 <Xunie> It could just be your usage pattern, maybe?
22:09:16 <dminuoso> i.e. if copied_bytes from RTSStats is linearly increasing, with no change in behavior of the program
22:15:00 <c_wraith> it could indicate too many values are being held
22:16:14 <dminuoso> c_wraith: http://i.imgur.com/eLWtx9t.png
22:16:40 <dminuoso> This is taken over a period of a few days, instrumented via a simple prometheus exporter that just exposes RTSStats
22:17:25 <c50a326> https://gist.github.com/m1574b34r/500f686e25eabb9d1e48fc9c4bc2ad05 if I explicitly type sig line 20 with its type (the type that intero tells me it is), I get an error
22:17:31 <dminuoso> To me it looks as if each network request is leaking a small bit of memory
22:17:57 <c50a326> that is, if I add `xs :: [(a, [c])]`
22:18:43 <dminuoso> c50a326: You would have to: use ScopedTypeVariables, InstangeSigs, provide an explicit type annotation for (>>=) and use explicit forall quantification
22:19:13 <dminuoso> Otherwise the type variables `a` and `c` will be scoped differently
22:19:39 <dminuoso> Imagine `xs :: [(a, [c])]` being a top level binding, this would have been the same for the type signature without the above actions.
22:19:54 <c50a326> hmmmm well damn that's a bit overwhelming
22:20:15 <c50a326> I'm just trying to do this in haskell because I'm trying to do the same thing in PureScript but was having this problem there too I guess and didn't understand...
22:20:37 <c50a326> I guess I should just use more specific types in my Parser type, like String -> [(a, String)]
22:20:37 <dminuoso> c50a326: ScopedTypeVariables should be considered standard really
22:20:44 <dminuoso> And InstanceSigs is a harmless extension
22:20:53 <c50a326> hmm maybe I'll try all of that then
22:21:03 <c50a326> it feels like it would be instructive to go through this pain
22:21:09 <dminuoso> c50a326: You could avoid InstanceSigs if you write `(>>=) = someBind`, and then write someBind as a top level binding
22:21:19 <dminuoso> But ScopedTypeVariables and forall you need at least.
22:21:49 <c50a326> ah yeah I quite like writing instance functions separately and then just hooking them up in the instance definition anyways actually
22:22:51 <dminuoso> c50a326: The issue you experienced is essentially this: when you have `foo :: a -> ...; foo = ... where f :: a -> ...` then the inner a is not the outer a, but its a freshly universally quantified type variable
22:24:19 <c50a326> dminuoso: claro, thanks. Interestingly, with the haskell compiler, With the type sigs left out, the compiler is smart enough to figure it out and compile it. With the PureScript compiler with the same example, this is not the case I don't think.
22:25:33 <dminuoso> c50a326: Well the fact that we need a) an extension and b) do this with forall is a terrible unfortunate historic artifact.
22:26:31 <dminuoso> c50a326: The need to explicitly bring a type variable into scope with `forall` is just because the GHC developers wanted to avoid breakage when turning the extension.
22:26:46 <dminuoso> (the forall doesnt actually do something in this case...)
22:27:27 <dminuoso> c50a326: Perhaps PureScript has the ScopeTypeVariable behavior on by default
22:27:38 <dminuoso> Which would make sense I guess
22:28:05 <c50a326> https://gist.github.com/m1574b34r/977e6d41f808c4b507b1fbf5b9c1121f this is the code and the error (as a comment below) in PureScript, if interested
22:32:11 <cocreature> yep, afaik purescript always has ScopedTypeVariables
22:32:17 <c50a326> ... actually I screwed up the types in my Parser in the PureScript sample... figured that out when writing in the Haskell one, need to change it, so ignore all that D:
22:32:37 <cocreature> (which is a much better default for a new language imho)
23:15:47 * hackage universe-dependent-sum 1.1.0.1 - Universe instances for types from dependent-sum  https://hackage.haskell.org/package/universe-dependent-sum-1.1.0.1 (phadej)
23:18:50 <yushyin> cocreature: I would like to see ScopedTypeVariables as the default in the next haskell report, would be awesome.
