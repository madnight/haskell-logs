00:07:47 * hackage higgledy 0.1.1.0 - Partial types as a type constructor.  https://hackage.haskell.org/package/higgledy-0.1.1.0 (i_am_tom)
00:39:17 * hackage minilight 0.1.0 - A SDL2-based graphics library, batteries-included.  https://hackage.haskell.org/package/minilight-0.1.0 (myuon)
00:51:21 <zincy> Does a file consisting of webassembly bytecode count as a binary file?
00:52:07 <zincy> I am just wondering if hexadecimal counts as "binary" since in my mind binary is base 2 so would be only files which are 011011 etc
00:53:13 <jle`> 'binary' as in binary file usually is used to mean non-text
00:53:15 <Athas> Hexadecimal is a notation, not an encoding.
00:53:17 <jle`> all files are 'binary'
00:53:48 <jle`> hexadecimal is used as a way of displaying binary for human readability
00:54:32 <zincy> Oh how is hex not an encoding?
00:55:05 <jle`> since each chunk of 4 bits corresponds to a hex digit (it's a cute property) -- for example, a2e6 stands for [1010][0010][1110][0110]
00:55:13 <zincy> So the best way to think of it is binary files are just non-text files
00:55:39 <jle`> so if a binary file contains 1010 0010 1110 0110, you can 'print' it as [a][2][e][6], it's just a more compact way of printing the binary data
00:55:55 <zincy> Ah ok
00:56:12 <zincy> I thought encoding referred to a particular representation of something
00:56:43 <jle`> here we just use hex as a convenient way to read raw binary data
00:56:55 <jle`> we save 4x the space :)
00:57:04 <jle`> (screen space, not disk space)
00:57:06 <zincy> So because computers don't understand non-binary decimal would be a text file which would be an encoding ... 
00:57:41 <jle`> text files are binary files, but it's text encoded as binary
00:57:45 <zincy> But here we would have two different ways of representing the same thing so notation
00:58:43 <zincy> I guess say mpeg vs avi are encodings because they literally have to be interpreted differently at some level i;.e they aren't interchangeable
00:58:44 <jle`> it's just that if someone tells you 'this is a binary file', their intent is usually to say that it's a non-text binary file. just as like a common communication thing
00:58:55 <zincy> Ok thanks!
00:59:50 <jle`> right, the same video, when encoded using mpeg vs. avi, will have different binary encodings.
01:01:32 <literallyCrevice> ?pl (\x -> [x+3 .. x])
01:01:32 <lambdabot> enumFromTo =<< (3 +)
01:02:19 <literallyCrevice> ?pl (\x -> [x+3 .. x+1])
01:02:19 <lambdabot> liftM2 enumFromTo (3 +) (1 +)
01:02:23 <lavalike> Squarism: oooh, I wonder what 'b' becomes in that type
01:03:15 <lavalike> Squarism: also, did it end up producing the query you wanted, or did it produce an equivalent but different one which results in a correct count?
02:00:17 * hackage Allure 0.9.3.3 - Near-future Sci-Fi roguelike and tactical squad combat game  https://hackage.haskell.org/package/Allure-0.9.3.3 (MikolajKonarski)
02:01:30 <zincy> I am generating webassembly code from brainfuck source code. I have my AST. The next step would be to replace each node in the AST representing the operation with the webassembly equivalent op.
02:01:42 <zincy> Does it matter in which order the nodes are visited?
02:06:52 <ggole> I would guess yes, since brainfuck operations are effectful
02:07:56 <zincy> Thanks
02:09:23 <zincy> When you generate code for a low level target are you better of defining your operations as functions at the top and then calling them below in a procedural manner?
02:09:56 <zincy> Say you have the op Inc which increments the current cell
02:10:53 <zincy> In the generated Webassembly textual representation would you define a function called Inc? And then for each Inc in the AST from Brainfuck you generate a call in the generated webassembly code?
02:15:01 <ggole> I wouldn't do that without a good reason, no
02:15:51 <ggole> Usually a low level target would have primitive operations for loading/adding/storing, and you would use those
02:16:31 <zincy> I guess my suggestion would lead to bad performance
02:16:42 <ggole> Emitting a separate function can be useful if the amount of emitted code is large and you want to save space, but Inc doesn't sound like it would have that problem.
02:16:53 <zincy> As you would be building on those primitives for the sake of modularity which wouldnt be useful
02:17:20 <ggole> Right, whether the produced code is maintainable or not isn't a concern.
02:21:52 <zincy> Silly question but what type would you use for the function which outputs Webassembly when given an AST, Text?
02:23:20 <lavalike> wasm is s-expressions right? a tree might do a fine job, and then get pretty-printed through various means
02:23:30 <zincy> Correct
02:23:55 <ggole> Aren't there two representations, text and "bytecode"?
02:24:02 <zincy> Yes
02:24:16 <ggole> You might want to have some tree representation that can be reasonably converted to either.
02:25:06 <zincy> Ah ok so do I not want to go to an unstructured string so quickly
02:25:20 <zincy> I would want to map between ASTs
02:25:53 <zincy> Does that mean I would need to model webassemly S expressions with new ADTs?
02:26:17 <ggole> Yeah, unless you're happy only producing the textual form
02:26:22 <lavalike> when you have your tree you can look into stuff like this, which GHC also uses: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.8777
02:28:50 <zincy> A package called WASM actually exports the types already
02:28:54 <zincy> Could I use that instead
02:29:02 <zincy> http://hackage.haskell.org/package/wasm-1.0.0/docs/Language-Wasm-Builder.html
02:30:51 <zincy> Maybe it is better for learning purposes just to go AST -> tree of strings representing webassembly code
02:31:02 <zincy> My goal isn't to build a fantastic compiler
02:31:12 <zincy> only to learn the basics of building compilers
02:32:16 <ggole> It's quite reasonable to just hack away, you are likely to learn a bunch figuring these things out as you go.
02:32:49 <zincy> Yeah I have become quite bad at hacking away these days
02:32:54 <zincy> Overthink everything
02:33:32 <zincy> What was that study of pottery students where the successful group were told to prioritise quantity over quality.
02:34:34 <ggole> Toy compilers are great fun to write because if anything is boring or unhelpful you can probably simplify it away
02:35:29 <ggole> Including source language features, limited targets, lexers and parsers, even type checkers
02:35:56 <ggole> Rip it out and come back when you have more understanding.
02:38:44 <lavalike> zincy: that sounds right
02:46:12 <OnlyLove_> Hi! Only casual sex!! Free to join & free to use with casual sex herefuck me tonight handsome! ‚ù§ http://v.ht/mircchat ‚ù§
02:53:17 * hackage minilight 0.1.1 - A SDL2-based graphics library, batteries-included.  https://hackage.haskell.org/package/minilight-0.1.1 (myuon)
03:15:13 <literallyCrevice> How can I model/create a list of type `Ord a => [String -> a]`?
03:27:05 <__monty__> Using (:) and [].
03:29:33 <Rembane> literallyCrevice: [\x -> ..., \x -> ..., ...]
03:32:20 <Rembane> literallyCrevice: Does that solve your problem?
03:36:23 <Habib> What's the easiest way to deploy a Haskell web service? I have a launch scheduled tomorrow and I'm struggling to find a simple deployment solution. I thought Clever Cloud would be it, but their logs are giving me an error that suggests `stack` is being called outside of the project directory and their support is unresponsive. Docker Compose seems like a pain in the ass to get working and I need to leave enough time to work on some styling improvements and othe
03:36:23 <Habib> minor things before I launch.
03:37:29 <Habib> I'm willing to pay money for a solution to this problem.
03:37:43 <Habib> ¬£30
03:38:47 * hackage http-directory 0.1.1 - http directory listing library  https://hackage.haskell.org/package/http-directory-0.1.1 (JensPetersen)
03:44:14 <Rembane> Habib: What are your limitations when it comes to deployment?
03:47:14 <Habib> I'm not sure what you mean by limitations in this case. I have requirements, if that's what you're asking about. The deployment must be simple to kick off and the hosting shouldn't cost over $50/month (including a PostgreSQL DB and a Redis DB).
03:50:00 <Akii> anyone know how to add another header to servant auths cookie headers?
03:50:13 <Akii> I must be missing something completely obvious https://github.com/haskell-servant/servant-auth/blob/aa4453a079914edbfe692757daf3fb14caaa5148/servant-auth-server/src/Servant/Auth/Server/Internal/Cookie.hs#L145
03:50:18 <Akii> this is the function it returns
03:50:37 <Rembane> Habib: So you can host it at any of the big cloud providers? 
03:50:50 <Akii> in my understanding I should be able to `addHeader "blah" . acceptLogin ...`
03:51:16 <Akii> but because this is so deeply nested type foo nothing makes any sense anymore
03:51:43 <Akii> like thanks servant, thanks  foo :: forall a. a -> c0
03:52:05 <Habib> Rembane: I guess so, but I've heard that things like Heroku are a problem due to the build times. If it's a PaaS, it should offer first class support, not a community buildpack or something; otherwise, I may as well go with a VPS.
03:52:23 <Habib> In fact, if it can be done relatively easily, a VPS would be my preferred solution.
03:53:05 <kvda> Akii are you sure it's not part of CookieSettings type?
03:53:47 <kvda> I don't think addHeader "blah" . acceptLogin .. would work
03:56:42 <Rembane> Habib: I think VPS is the way to go. I haven't heard of any PaaS that works well with Haskell.
03:58:08 <Akii> http://hackage.haskell.org/package/servant-0.16/docs/Servant-API-ResponseHeaders.html#v:addHeader
03:58:11 <Akii> taking this
03:58:27 <Akii> if I apply acceptLogin with the return value I should get a headers thing
03:58:57 <Akii> like in example2 I should then be able to add a header or not
03:59:12 <Habib> Rembane: looks like it. I'm really disappointed, because Clever Cloud really looked like the one; they advertised first-class support for Haskell, but upon further investigation, it turned out to be a beta, then to just not work, and the support hasn't responded to me yet (not even an automated email to let me know how long I should expect to wait). Really annoyed with them.
03:59:48 <Akii> hmpf but I can just use getHeaders and just go around this servant crap
04:01:55 <Akii> welp that just wasted an hour
04:09:17 * hackage coalpit 0.1.1.1 - Command-line options and DSV parsing and printing  https://hackage.haskell.org/package/coalpit-0.1.1.1 (defanor)
04:10:00 <Rembane> Habib: That is indeed a disappointment. 
04:25:55 <literallyCrevice> Rembane: I'll be more clear. The compiler's fine with me having a list [compare `on` length, compare `on` id] but I cannot do map (\x -> compare `on` x) [length, id]. What can I do that's similar to the second solution?
04:29:23 <Rembane> literallyCrevice: First, take a look at `comparing`, it basically does what you think it does. Second, do you want to compare on two properties of the things you are comparing?
04:29:56 <Rembane> literallyCrevice: Or N number of properties for that matter.
04:31:57 <literallyCrevice> Rembane: I guess the real question is: take a look at import Data.Monoid  
04:31:58 <literallyCrevice>   
04:31:58 <literallyCrevice> lengthCompare :: String -> String -> Ordering  
04:31:58 <literallyCrevice> lengthCompare x y = (length x `compare` length y) `mappend`  
04:32:00 <literallyCrevice>                     (vowels x `compare` vowels y) `mappend`  
04:32:02 <literallyCrevice>                     (x `compare` y)  
04:32:13 <literallyCrevice> Oh fuck I thought I copied the url, sorry for the spam
04:32:33 <Rembane> No worries. It's a low traffic our. We can do with some code pasted by mistake. :)
04:32:58 <literallyCrevice> but anyways how would you adjust that function to deal with an arbitrarily-sized compare order?
04:33:12 <Rembane> By using mconcat I think. 
04:33:26 <Rembane> mconcat :: Monoid a => [a] -> a 
04:33:56 <literallyCrevice> so you'd have mconcat [length x `compare` length y, ...] but that's also very verbose
04:34:07 <literallyCrevice> I want to "take out" of the list as much as I can
04:34:37 <Clint> literallyCrevice: read back to what he said about comparing
04:35:29 <lavalike> :t comparing fst <> comparing snd
04:35:30 <lambdabot> (Ord b, Ord a) => (a, b) -> (a, b) -> Ordering
04:36:06 <literallyCrevice> Amazing, that's what I was looking for. Thanks everybody!
04:36:20 <lavalike> favorite monoid
04:36:35 <Rembane> Definitely
05:22:12 <bouzlibop> \help
05:24:04 <int-e> :t asks (\help -> Just help)
05:24:06 <lambdabot> MonadReader a m => m (Maybe a)
05:25:01 <absence> i've seen some recommendations against ExceptT over IO because of issues with async, and because IO can throw any other exceptions than the one in the type signature anyway. instead it's suggested to use MonadCatch's throwM, but it's not a drop-in replacemen since it has an Exception constraint. so for functions that return IO (Either e a) where e isn't an Exception, or functions returning IO (Maybe a) (a
05:25:07 <absence> ssuming MaybeT over IO is similarly bad), it doesn't really work out. am i missing something?
05:29:35 <cocreature> absence: one option is to make e an instance of Exception
05:32:08 <cocreature> but that recommendation should also be taken with a grain of salt. There is little doubt that ExceptT on top of IO can be useful in some cases. That recommendation is mostly arguing against throwing your whole application in one big ExceptT. Using it locally is a completely different story. And even for the whole application usecase there is a fair amount of dispute on whether ExceptT is preferable or not
05:37:47 * hackage r3x-haskell-sdk 0.1.0.0 -   https://hackage.haskell.org/package/r3x-haskell-sdk-0.1.0.0 (rubixfunctions)
05:41:41 <absence> cocreature: yeah, making orphan instances for an "e" in a third-party library doesn't sound good, and for MaybeT you don't even have an e
05:46:16 <cocreature> for MaybeT you can make a type isomorphic to () (but more descriptive) and make that an instance of Exception
05:53:58 <absence> cocreature: so when using something like Map.lookup, you'd throwM KeyNotFound if it returns Nothing, and then use "try" instead of runMaybeT?
05:54:39 <cocreature> I‚Äôd just use IO (Maybe a) instead of dealing with any transformer
05:56:04 <absence> cocreature: even if there are multiple lookups?
05:57:10 <cocreature> then that might be a case where using MaybeT locally make sense.
05:57:52 <cocreature> as I said, this advice should be taken with a grain of salt and it mostly applies to wrapping your whole application in such a stack. Using it locally is a completely different story
06:02:09 <absence> cocreature: i see. i'm not sure i understand the concurrency implications though, as e.g. the "ReaderT design pattern" article only rhetoricly asks "how would you handle concurrency with ExceptT?" rather than explain what the problemn is. would i have to be careful about concurrency when using MaybeT locally as you suggest?
06:04:33 <cocreature> "forkIO :: IO a -> IO ThreadId"
06:04:53 <cocreature> If you have something of type MaybeT IO a you can‚Äôt directly use it with forkIO so you need to think about how you want to handle it
06:08:52 <cocreature> just getting the types to work out is easy but you also need to think about what happens if you have multiple threads and one of them fails. you might want to kill other threads in that case or handle it in some other way and MaybeT isn‚Äôt going to do that automatically
06:37:10 <absence> cocreature: i think i found out what the problem with concurrency is: https://www.snoyman.com/reveal/monad-transformer-state#/3/4
06:37:51 <absence> in the case with two Left, one gets discarded. but on the other hand, MaybeT should be fine in that case...
07:23:47 <cocreature> absence: I don‚Äôt think that‚Äôs really the problem here. If both cases throw an exception you also need to combine that information in some way.
07:25:16 <cocreature> and with MaybeT you also loose information in some way. You loose the information whether one or both cases failed
07:26:13 <cocreature> (ofc losing information isn‚Äôt necessarily bad)
07:28:27 <sternmull> is there a library that provides named timezones? Data.Time can only get the current timezone.
07:34:13 <sternmull> there is tzdata, but i don't see a way to get a Data.Time.LocalTime.TimeZone from it
07:37:00 <phadej> @package tz
07:37:00 <lambdabot> http://hackage.haskell.org/package/tz
07:37:11 <phadej> uses tzdata "data"
07:37:14 <phadej> sternmull: ^
07:38:25 <sternmull> phadej: Thanks, looks good
07:39:02 <phadej> (also timezone stuff in `time` is not good, it's not really timezones; it's just offsets)
07:40:01 <sternmull> phadej: Yes, i noticed that. Looks like TZ from tz is what the rest of the world calls a timezone.
07:43:46 <phadej> good. clearly we'll need to add a link to `tz` into tzdata's description
07:44:04 <phadej> oh; there is
07:44:12 <phadej> See also the tz package http://hackage.haskell.org/package/tz or the timezone-olson and timezone-series packages that provide facilities to use the data shipped here. (The tz package automatically installs this package.)
07:46:03 <sternmull> it would be helpful if Data.Time.LocalTime would mention how to get LocalTime from UTC for timezones from timezone data. I came here because that isn't obvious.
07:48:27 <phadej> hmm, maybe; but picking `tzdata` is somewhat opinionated choice (i don't know if there are alternatives though)
07:49:27 <sternmull> it wouldn't hurt to list other alternatives if there are some. But when you start at Data.Time you are left to wonder how to construct timezones for regions.
09:16:55 <aplainzetakind> If Haskell is installed via ghcup, and I cabal install xmonad, what will I need to do so that `xmonad --recompile` can find its dependencies (I haven't done it and encountered a concrete problem yet, but I'm pretty sure it won't just work).
09:18:43 <glguy> Installing with ghcup isn't much different from installing without ghcup. The main difference is that it installs in ~/.ghcup/bin, so make sure that's in your PATH
10:07:56 <nisstyre> aplainzetakind: it shouldn't make a difference, it would only make a difference if you were trying to mix cabal libraries with libraries in a stack package or something
10:07:59 <nisstyre> since those are isolated
10:39:31 <HenryCH> how can we have just the single type e in: `Instance Applicative (Either e) where ...`, why do we not need (Either a b)?
10:40:32 <glguy> HenryCH: The Applicative class is for types with kind * -> * so that they can be applied to various types in the methods
10:40:47 <glguy> :t pure
10:40:48 <lambdabot> Applicative f => a -> f a
10:41:53 <HenryCH> still dont get it :\
10:43:23 <Taneb> HenryCH: for the Either Applicative instance, we substitute the head "Either e" for f, giving "pure :: Applicative (Either e) => a -> Either e a"
10:43:55 <Taneb> If you used "Either e x" instead, you'd get "pure :: Applicative (Either e x) => a -> Either e x a", and that doesn't work
10:44:55 <HenryCH> so the definition is partially applying e in the type constructor?
10:46:12 <Taneb> Exactly
10:46:51 <HenryCH> I see, thanks
10:46:53 <Taneb> (for completeness sake, if we just used "Either" instead of "Either e", we'd end up with "pure :: Applicative Either => a -> Either a", which also doesn't make sense)
10:47:51 <maerwald> partial application doesn't work well on type level :P
10:48:57 <EvanR> citation needed!
10:49:42 <maerwald> you can quote GHC errors ;o
10:58:17 * hackage rating-chgk-info 0.3.6.4 - Client for rating.chgk.info API and CSV tables (documentation in Russian)  https://hackage.haskell.org/package/rating-chgk-info-0.3.6.4 (MZiatdinov)
11:09:17 * hackage hjugement 2.0.2.20190414 - Majority Judgment.  https://hackage.haskell.org/package/hjugement-2.0.2.20190414 (julm)
11:21:58 <fresheyeball> starting to learn TH and its pretty intimidating 
11:22:00 <fresheyeball> https://pastebin.com/rE2CGU8S
11:22:12 <fresheyeball> if anyone wants to explain to me why this is not working, it would be a nice thing
11:23:46 <coldpress> fresheyeball: what's the error?
11:34:10 <geekosaur> it's in the paste
11:36:10 * geekosaur doesn't know TH well enough, but you generally can't just expand a name that way as an identifier, you need to create an internal reference to (in this case, a new) name
11:36:21 <geekosaur> and "$name" is not going to do a string expansion of a name
11:37:11 <cocreature> there are only expression, pattern, type and declaration splices. there is no such a thing as a name splice
11:37:44 <fresheyeball> cocreature: aww
11:38:01 <cocreature> see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#th-syntax
11:38:04 <fresheyeball> cocreature: so how can I write this without the quasi?
11:38:06 <fresheyeball> nice
11:38:39 <cocreature> also Q Exp seems to be the wrong return type, it looks like you want Q [Dec]
11:38:53 <fresheyeball> cocreature: oic
12:09:17 * hackage polysemy 0.1.1.0 - Higher-order, low-boilerplate, zero-cost free monads.  https://hackage.haskell.org/package/polysemy-0.1.1.0 (isovector)
12:22:06 <johnw> isovector: go go go!
12:23:56 <adamCS> johnw: I might've caused (some of) that release!  Had a funny MonadIO issue that was easy enough to fix and isovector added the appropriate interpretation right in!  Pretty easy to move from freer-simple to polysemy...
12:24:15 <johnw> cool
12:24:28 <johnw> I used freer-simple a lot at my last job; not using it right now, but for my next project I may
12:24:47 <johnw> when I use very few instances, mtl approach is cheap and easy
12:26:02 <adamCS> Yeah.  I like it.  Only wrinkle shifting to polysemy (so far) is that freer-simple has that LastMember thing and polysemy has a different way of handling that, via Lift.  And that was the source of my MonadIO issue.  But I learned a lot fixing it...
12:26:57 <johnw> adamCS: :)
12:28:45 <johnw> GHC is not fast to build on macOS
12:29:21 <cocreature> s/to build on macOS//
12:29:30 <johnw> :(
12:30:01 <Solonarv> hey, it runs decently fast
12:30:03 <johnw> I'm hacking 8.6.4 to work around a Darwin runtime linker issue; and it was easy to apply the patch using Nix, but.... stil waiting....
12:30:11 <Solonarv> but it certainly doesn't build fast...
12:30:18 <johnw> I mean building GHC _itself_
12:30:22 <johnw> not using GHC to build things
12:30:40 <cocreature> I mean both cases are bottlenecked on GHC building things
12:30:45 <cocreature> so it‚Äôs not all that different :)
12:31:20 <johnw> I think it's that it uses regular ld on macOS
12:31:25 <johnw> so link times kill the build
12:32:27 <cocreature> johnw: I recently realized that Hydra defaults to not picking things from substituters which resulted in me discovering that the bootstrap process in our nixpkgs snapshot at work consists of building ghc 8.2.1 using a 8.2.1 binary which is then used to build 8.6.3 which is then used to build 8.6.4
12:32:44 <johnw> oh wow
12:32:48 <Solonarv> yikes
12:32:52 <cocreature> that took quite some time :)
12:32:58 <johnw> that would take about 7 hours here
12:33:16 <cocreature> yeah took around that long
12:33:31 <cocreature> and then when it was finished, I realized I had messed it up and needed to build it again
12:33:34 <cocreature> fun times
12:33:47 <koz_> Such rebuild.
12:35:28 <cocreature> I also learned that we apparently depend on a fortran compiler
12:36:07 <shapr> fortran95 at least?
12:37:17 <cocreature> dunno, I think it built gfortran or rather it failed to build it since apparently that‚Äôs broken in nixpkgs (or at least in the snapshot we used at the time).
12:37:27 <cocreature> anyway, this is getting a bit offtopic, I‚Äôll stop here :)
13:02:17 * hackage stb-truetype 0.1.4 - A wrapper around Sean Barrett's TrueType rasterizer library.  https://hackage.haskell.org/package/stb-truetype-0.1.4 (BalazsKomuves)
13:04:47 * hackage minitypeset-opengl 0.1.0.0 - Layout and render text with TrueType fonts using OpenGL  https://hackage.haskell.org/package/minitypeset-opengl-0.1.0.0 (BalazsKomuves)
13:05:21 <wolfman154> What does   .|.  Syntax mean, what does the:  x in front of the k‚Äôs mean, and what does mask mean, I‚Äôm new to Haskell and xmonad, so please have patience 
13:05:25 <wolfman154> https://unix.stackexchange.com/questions/68691/remapping-keys-for-workspaces-in-xmonad#68709
13:06:46 <Phyx-> wolfman154: .|. is bitwise or
13:08:05 <Phyx-> the x itself has no meaning, the binding/variable is named "xK_k"
13:09:56 <wolfman154> Phyx-: thanks , and what does Mask mean?
13:12:39 <geekosaur> the xs are there because these are generated bindings to C macros XK_something --- but you can't start a binding with uppercase in Haskell, so the converter script downcases the first letter
13:14:46 <geekosaur> modMask there is typically a local binding, using old-style keybindings with a helper function. it's referring to the modMask element of your XConfig, which is the modifier key you have selected. the name is because X11 considers a key event "pattern" to consist of a bit mask of modifiers plus a KeySym (logical key)
13:15:01 <geekosaur> "bit mask" being why it's using logical OR
13:15:37 <wolfman154> geekosaur: makes more sense thanks 
13:16:25 <wolfman154> geekosaur:  lets see if I can get this to compile 
13:21:15 <wolfman154> geekosaur: do I need the lowercase x‚Äôs ?
13:21:53 <geekosaur> yes
13:23:25 <wolfman154> geekosaur: üëçüèº
13:26:14 <wolfman154> geekosaur: could you paste bin the link to change the keyboard bindings in xmonad again, sorry I can‚Äôt find the link?
13:32:29 <geekosaur> er, which one? you pasted one earlier from SO. there's several that go into more detail, depending on how you're doing it
13:34:06 <wolfman154> geekosaur: never mind I think I found it 
13:48:31 <HenryCH> looking at the base implementation of foldr for list, it's a bit cryptic for me, is it equivalent to the one in the wiki?
13:49:04 <shapr> @src foldr
13:49:04 <lambdabot> foldr f z []     = z
13:49:04 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:49:18 <shapr> HenryCH: is that the same one?
13:49:26 <HenryCH> thats the wiki one
13:50:02 <HenryCH> ah nevermind i was looking at the Foldable definition
13:50:48 <HenryCH> is it implemented as above because it's inefficient to traverse backwards?
13:51:18 <shapr> @src foldl
13:51:18 <lambdabot> foldl f z []     = z
13:51:18 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:51:36 <shapr> HenryCH: is that the traverse backwards?
13:51:41 <Solonarv> oh, did you see this: foldr k z xs = appEndo (foldMap (Endo . k) xs) z
13:51:53 <Solonarv> that's the implementation of foldr in terms of foldMa
13:53:47 <wolfman154> geekosaur: instead of the default where I press: mod + 1(switch to workspace 1) and mod + shift + !(to shift to workspace 1) I would like to do: mod + ?(to switch to workspace 1) and mod + shift + 1(to shift to workspace 1)
13:54:07 <wolfman154> What would be the syntax:  https://unix.stackexchange.com/questions/68691/remapping-keys-for-workspaces-in-xmonad#68709
13:54:09 <HenryCH> don't both of those implementations just go forward?  i mean they both pattern match with x:xs
13:55:21 <shapr> HenryCH: a - b isn't the same as b - a, right?
13:56:24 <wolfman154> geekosaur: https://hastebin.com/umojobewek.xml
13:56:29 <mathlover2> What is the best library for matrix manipulation?
13:57:12 <mathlover2> Is hmatrix good? Or are there better ones?
13:57:14 <wolfman154> geekosaur: I just want to change it to correspond with this custom keyboard mapping 
13:58:20 <wolfman154> geekosaur: do you know how I would change the syntax?
13:58:26 <geekosaur> xK_question and shiftMask .|. xK_question respectively
13:58:47 <geekosaur> (NOT xK_1; it needs to be the base keySym, the shiftMask covers the rest.)
13:59:03 <geekosaur> er, not .|. there, (shiftMask, xK_question)
13:59:24 <geekosaur> and the modMask ORed in
13:59:34 <geekosaur> sorry I am trying to do too many thinbgs at once right now
13:59:51 <wolfman154> geekosaur: could you paste bin please!!
14:03:01 <HenryCH> shapr: right, but isn't the difference between those two just how it builds the final expression with f x y or f y x? both just build one big expression forwards?
14:03:45 <HenryCH> if im not mistaken that implementation is not tail recursive, is it? why is it preferred?
14:03:59 <shapr> @src foldl'
14:03:59 <lambdabot> foldl' f a []     = a
14:03:59 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
14:04:04 <shapr> HenryCH:
14:04:06 <shapr> you right
14:04:07 <monochrom> mathlover2: I use hmatrix. I don't know about "best".
14:04:16 <shapr> foldl' forces the items as it goes
14:04:33 <shapr> for most things, foldl' is a better choice
14:04:36 <monochrom> Actually I know. If my answer is the only answer, then it is best. (It is also worst, but meh.)
14:04:51 <mathlover2> monochrom: I am writing a project in Haskell for school. Just needed advice. Thanks so much!
14:06:10 <HenryCH> shapr: is foldl' still lazy?
14:06:50 <geekosaur> all folds are as lazy as the function you are folding is
14:07:47 <monochrom> I wouldn't make that strong statement.  For one thing, lazy on what?
14:07:54 <geekosaur> well, no, not all, that's why foldl'. foldl will be lazy even if the function you are folding is strict, which causes usually unwanted thunk buildup --- so with a strict function you usually want foldl'
14:08:40 <wolfman154> geekosaur: could you paste bin those changes to this, it‚Äôs not compiling:  https://unix.stackexchange.com/questions/68691/remapping-keys-for-workspaces-in-xmonad#68709
14:08:41 <monochrom> For example, foldl is very eager on the list spine.
14:10:11 <wolfman154> geekosaur: I think I messed up with the syntax, I‚Äôm not sure though 
14:10:30 <geekosaur> https://gist.github.com/geekosaur/9fd2dbe0caba9fdfbcc85c7c70e81366
14:12:07 <wolfman154> geekosaur: thanks for being so helpful with this beginner
14:12:14 <wolfman154> :)
14:15:16 <shapr> HenryCH: when did you start learning Haskell?
14:16:46 <HenryCH> shapr: too late :D
14:17:08 <fen> would it be possible to talk through some of the things to do with this idea of using cannonical containers instead of their generic couterpart? the basic point would be to understand about how unfolding e.g. a list, instead of something isomorphic to it and how this works with respect to build fusion.
14:17:32 <shapr> HenryCH:
14:17:36 <shapr> you're still alive :-)
14:18:07 <shapr> HenryCH: just saying foldl and foldr both building a big pile of thunks is a good realization that took me awhile to notice
14:19:21 <fen> if we have an unfoldable and foldable class, then we can have unfold / fold fusion instead of build fold fusion for anything unfoldable instead of lists, but that by using lists as the "cannonical container" they can basically serve as generics would, and we can use list everywhere we could choose to use something isomorphic to list instead, as long as it is used like;
14:19:23 <fen> , fist unfolding, and then folding - because basically the foldable instance creates the isomorphism to list
14:19:39 <fen> (similarly for the unfoldable instnace?)
14:20:00 <shapr> fen: you need a blog
14:20:10 <shapr> or a twitter account?
14:20:14 <fen> @quote fen
14:20:14 <lambdabot> fen says: unnecessary complexity could be discouraged, but that might encourage an otherwise unnecessary justification.
14:20:29 <nh> lol
14:20:45 <shapr> fen: how would you explain that quote?
14:20:48 <HenryCH> thanks for the help, have a good evening
14:21:03 <shapr> HenryCH: come back soon!
14:21:18 <nh> shapr: are you endorsing unecessary explanations
14:21:42 <fen> nh: ++
14:21:52 <shapr> nh: Are you a bot?
14:22:17 <nh> i am not
14:22:37 <shapr> nah, just wanted that unpacked
14:22:51 <shapr> I have better stuff to do though
14:23:05 <fen> bots are recognisable by their use of emotion provoking responses 
14:23:23 <shapr> I'm having fun reading network-simple
14:23:31 <shapr> this is a fun library
14:24:37 <wolfman154> geekosaur: quick question, why does the your paste bin have: K‚Äôs placed there?
14:25:26 <geekosaur> ?
14:25:40 <shapr> nh: what are you writing in Haskell?
14:26:13 <wolfman154> geekosaur: 15:10 geekosaur: https://gist.github.com/geekosaur/9fd2dbe0caba9fdfbcc85c7c70e81366
14:26:13 <monochrom> I think the "K" in "xK_question"
14:26:47 <geekosaur> yes, I know what I pasted. those are X11 keysyms with the initial X downcased for Haskell compatibility
14:26:52 <wolfman154> monochrom: yeah that‚Äôs what I meant 
14:27:17 <geekosaur> the original names are in an X11 include file, which is converted to Haskell as part of the X11 haskell bindings
14:27:27 <geekosaur> so XK_question becomes xK_question
14:27:59 <nh> shapr, mostly silly irc bots
14:28:03 <nh> how about you
14:28:13 <geekosaur> usually /usr/include/X11/keysymdef.h has the base X11 keysym definitions
14:28:23 <shapr> nh: echo server at the moment, simple lisp evaluator earlier in the week. You got anything on github?
14:28:49 <nh> i don't
14:28:57 <shapr> aw
14:29:16 <nh> its been a while since i've played in haskell due to uni catching up with me
14:29:23 <shapr> I wrote this earlier in the week: https://github.com/shapr/lispeval/blob/master/Main.hs#L66
14:29:36 <shapr> doesn't do much, but I sure had fun figuring it out
14:29:42 <wolfman154> geekosaur: well so is k is needed for that other case, and I can remove it for my case?
14:29:48 <shapr> I'll add more to the eval when I have spare time
14:29:58 <geekosaur> no?
14:29:59 <wolfman154> https://unix.stackexchange.com/questions/68691/remapping-keys-for-workspaces-in-xmonad#68709
14:30:17 <geekosaur> that one has xK_ prefixes, mine has xK_prefixes
14:30:27 <geekosaur> "question" by itself is an undefined symbol and won't compile
14:30:38 <shapr> nh: which uni do you attend?
14:31:00 <nh> sheffield, hbu
14:31:17 <wolfman154> geekosaur: ok, just making sure, I thought x_question would work?
14:31:24 <geekosaur> no
14:31:27 <geekosaur> xK_ is the prefix
14:31:47 <geekosaur> I pointed you to the original C source of the names. the initial X has to be x in Haskell
14:31:58 <shapr> nh: never to Sheffield, only visited the UK a few times
14:32:30 <geekosaur> that is the master list of X11 base KeySym values. (there are some add-on lists for various workstation keyboards, Xorg extensions, etc.)
14:32:34 <nh> its nice, very friendly, extremely hilly
14:32:49 <wolfman154> geekosaur: so what does the K mean then?
14:33:19 <wolfman154> geekosaur: sorry I‚Äôm just a little confused 
14:33:29 <wolfman154> :(
14:33:34 <geekosaur> sigh. that is a single name. it has a prefix so it can be distinguished from other things that might want to use the word "question" or watever
14:33:48 <geekosaur> do you do any programming at all? maybe I can come up with an exxample in a language youa re familiar with
14:34:37 <geekosaur> the name xK_question is not the word question with some extra flags or whatever attached. the name of the keysym in Haskell is xK_question. the name of the keysym in C is XK_question
14:35:03 <wolfman154> geekosaur: thanks, I‚Äôm just really rusty, I haven‚Äôt coded in a long time 
14:38:04 <wolfman154> geekosaur: cool so I can use xK_‚Äôname‚Äô for changing the rest of my key bindings?
14:39:04 <wolfman154> geekosaur: in xmonad that is?
14:39:05 <monochrom> You should think of it as one single name "xK_question" rather than trying to deconstruct the name.
14:39:48 <wolfman154> monochrom: ok thanks for the tip 
14:39:53 <fen> nh: irc bots? like labdabot and yahb?
14:40:00 <fen> lambdabot*
14:40:46 <geekosaur> sometimes. the official names are in /usr/include/X11/keysymdef.h as I said before. or you can use xmodmap -pke to look at the current keymap, which should show keysyms. or you can use the names from that Xkb file you pasted earlier, with `xK_` prepended as with `question` being `xK_question` in Haskell code
14:41:10 <nh> fen, yes but nothing that complex
14:41:56 <fen> what, just for spam!?
14:42:40 <fen> in an adversarial classification language (turing) test - chatbots used to manipulate public psychology for rigging elections and skewing the generally accepted modes of thought (dilectic) utilise provokation as an effective means to distract genuinely human adversaries from the fact they are robotic 
14:44:16 <shapr> fen: you need a blog
14:45:16 <geekosaur> (the xkb file doesn't need the prefixes, as it's not a general purpose language and the xkb compiler knows that the name has to be a keysym)
14:47:58 <fen> shapr: a less common technique is to encourage discussion into some of the most interesting ideas ever comprehended!
14:48:23 <fen> btw: for full disclosure, im not a bot as far as i can tell
14:48:47 * hackage ghc-boot 8.6.4 - Shared functionality between GHC and its boot libraries  https://hackage.haskell.org/package/ghc-boot-8.6.4 (HerbertValerioRiedel)
14:49:47 * hackage ghc-boot-th 8.6.4 - Shared functionality between GHC and the @template-haskell@library  https://hackage.haskell.org/package/ghc-boot-th-8.6.4 (HerbertValerioRiedel)
14:51:47 <fen> did you know that the inability of animals to pass the turing test led the rationalist philosopher Ren√© Descartes to conclude that animals were indistinguishable from automaton? and that it was newtons greatest contribution to counteract his mechanical view of the world with the "mysterious" gravitational force...
14:51:54 <fen> thats what i would write about if I had a blog
14:52:20 <snunezcr> fen: Hi. I would dearly read your blog.
14:52:21 <fen> was anyone able to respond to the haskell query above before this digression was happened upon?
14:53:07 <shapr> fen: I bet it's not just for spam
14:53:12 <shapr> that was your haskell query, right?
14:53:37 <fen> would it be possible to talk through some of the things to do with this idea of using cannonical containers instead of their generic couterpart? the basic point would be to understand about how unfolding e.g. a list, instead of something isomorphic to it and how this works with respect to build fusion.
14:53:44 <fen> if we have an unfoldable and foldable class, then we can have unfold / fold fusion instead of build fold fusion for anything unfoldable instead of lists, but that by using lists as the "cannonical container" they can basically serve as generics would, and we can use list everywhere we could choose to use something isomorphic to list instead, as long as it is used like;
14:53:58 <fen> fist unfolding, and then folding - because basically the foldable instance creates the isomorphism to list, (similarly for the unfoldable instnace?)
14:54:15 <shapr> do you really think it's for spam?
14:54:54 <fen> can you stop that please?
14:54:59 <shapr> or was that just a non-sequiter?
14:55:04 <shapr> stop what?
14:56:17 * hackage ghci 8.6.4 - The library supporting GHC's interactive interpreter  https://hackage.haskell.org/package/ghci-8.6.4 (HerbertValerioRiedel)
14:56:53 <shapr> must have been a non-sequitur (that's the right way to spell that word!)
14:57:01 <fen> im asking you to stop. please
14:57:05 <shapr> stop what?
14:58:29 <shapr> I think a blog would help you refine your thoughts.
15:00:09 <shapr> network servers, hurrah!
15:02:39 <johnw_> fen: "if we have an unfoldable and foldable class..."  What you wrote makes little sense to me, and I'm also not sure why you think the whole channel needs to hear it.
15:03:03 <johnw> that's why shapr is suggesting a blog, so that you can speak to your own audience
15:03:59 <wolfman154> geekosaur: im guessing I need to add the paste bin to additionalKeys function?
15:04:12 <wolfman154> https://hackage.haskell.org/package/xmonad-contrib-0.13/docs/XMonad-Util-EZConfig.html
15:04:15 <fen> shapr suggests something which detracts from the topic at hand, echoing it is a questionable stance
15:04:58 --- mode: ChanServ set +o shapr
15:05:09 <geekosaur> wolfman154, if your;e using those functions then this is the wrong way to go about it. for one, you don't have modMask; the paste using that assumes you are using a function which is passed an XConfig and which extracts modMask from the config
15:05:10 <shapr> fen: the topic at hand is how to positively interact with a community
15:05:22 <johnw> it may be questionable to you, but as channel moderators, we're both asking you to desist
15:06:35 <geekosaur> if you're using additionalKeys then you need to use the actual modifier mask bit or find some other way to extract the config's default modifier mask, if you're using additionalKeysP then you use a string like "M-question" instead of a (KeyMask, KeySym) pair
15:06:44 <johnw> fen: you're welcome to be here and join in our discussions, but this channel is no one's soapbox, and there are measures we will take to turn down the volume
15:07:59 <Tuplanolla> You could join Welkin in using #haskell-offtopic as your blog, fen.
15:09:41 <fen> johnw: it would be appreciated if you could direct these measures at the recent comments of shapr and Tuplanolla, which serve to wrongly imply that the initial question was on topic, and encourage only off topic responses such as this 
15:09:56 --- kick: fen was kicked by shapr (Kicked by shapr)
15:10:05 --- mode: ChanServ set +o geekosaur
15:11:21 <Clint> seems like this is going to be a regular occurrence
15:11:29 <shapr> first time is a warning
15:11:47 <wolfman154> geekosaur: so for using this method I don‚Äôt need anything else, just copy and paste the import and two lines?
15:11:53 <wolfman154> geekosaur: https://unix.stackexchange.com/questions/68691/remapping-keys-for-workspaces-in-xmonad#68709
15:12:11 <geekosaur> tht paste doesnt' show you where it goes
15:12:15 <shapr> Clint: in hopes that further communication will be absorbed better
15:12:51 <Clint> shapr: i was referring to yesterday
15:13:01 <shapr> oh, what happened yesterday? I was packing
15:13:17 <shapr> not on irc, in any case
15:13:35 <Clint> shapr: dmwit had an encounter with fen
15:13:43 <geekosaur> wolfman154, that snippet expects to be used with the first example here: https://wiki.haskell.org/Xmonad/General_xmonad.hs_config_tips#Adding_your_own_keybindings
15:13:59 <geekosaur> inside the list in the myKeys function
15:14:23 <geekosaur> replacing the xlock example there
15:14:56 <geekosaur> shapr, actually I think most of the mods ahve had "encounters" with fen at this point
15:15:11 <geekosaur> I had them on ignore because I got tired of it, but others seemed to want to interact with them
15:15:48 <wolfman154> geekosaur: so I would use additionalKeys in this case?
15:16:01 <shapr> geekosaur: that's too bad, that implies it's time to remove fen permanently for not being able to understand how communities must function.
15:17:17 <shapr> perhaps fen will find a venue more suited for the type of dicsussions they prefer.
15:17:30 <geekosaur> wolfman154, if you don't already have a set of keybindings that you're extending, you probably want additionalKeysP instead of additionalKeys. the strings you'd use are "M-question" and "M-S-question", instead of the mask expressions
15:20:25 <wolfman154> geekosaur: ok, thanks for the tips 
15:32:47 * hackage ghc 8.6.4 - The GHC API  https://hackage.haskell.org/package/ghc-8.6.4 (HerbertValerioRiedel)
15:40:45 <wolfman154> geekosaur: sorry to bother one more time, could you paste bin a link the syntax of the link you sent for the additionalKeysP section it looks like those two options are for something else?
15:40:49 <wolfman154> 16:13 @geekosaur: wolfman154, that snippet expects to be used with the first example here: https://wiki.haskell.org/Xmonad/General_xmonad.hs_config_tips#Adding_your_own_keybindings
15:41:15 <geekosaur> that was with respect to the SO link you keep pasting
15:41:53 <geekosaur> which expects to be used with a function like myKeys as defined in that first example at https://wiki.haskell.org/Xmonad/General_xmonad.hs_config_tips#Adding_your_own_keybindings
15:42:11 <geekosaur> if you are starting from scratch, read the documentation for the additionalKeysP function
15:43:44 <wolfman154> geekosaur: I think it would be better if you could paste bin the syntax, I‚Äôm getting more and more confused!!
15:44:16 <geekosaur> that question becimes how much of the syntax" and ends with "just pastebin your config and I'll fix it"
15:45:14 <wolfman154> geekosaur:  I don‚Äôt know, I‚Äôm lost?
15:45:35 <geekosaur> that is exactly the poinht
15:45:41 <geekosaur> pastebin your config as you have it
15:45:55 <geekosaur> if you are lost, short snippets will not help
15:46:13 <geekosaur> especialluy with additionalKeysP which assumes you know what config combinators are and how you use them
15:46:28 <wolfman154> geekosaur: ok, give me a second, I have to type it on my phone 
15:57:05 <wolfman154> geekosaur: https://hastebin.com/zefajowowu.coffeescript
15:57:22 <wolfman154> geekosaur: will this work?
15:57:39 <geekosaur> ...why did you change the function names?
15:59:10 <wolfman154> geekosaur: I have no idea, could you paste bin the correct syntax please?
15:59:39 <geekosaur> https://hastebin.com/dosutuxeli.coffeescript
16:01:04 <wolfman154> geekosaur: I feel dumb, thanks  
16:01:47 <geekosaur> I explained what those were doing the other day, I don't see why you changed them
16:02:31 <Lears> There's also a precedence/type error; you need a $ between xmonad and defaultConfig or the first argument to `additionalKeysP` will be an IO () action rather than the config it modifies.
16:03:32 <wolfman154> geekosaur: I understand it a little better I thought I was supposed to change the syntax a little bit in this set of code but I was wrong 
16:05:54 <geekosaur> the only thing additionalKeysP does differently is how it specifies the keys
16:09:35 <wolfman154> geekosaur: ok 
17:02:15 <wolfman154> geekosaur: it xmonad.hs recompiled but when I do a rebuild switch in nixos line 5 throws an error?
17:08:13 <wolfman154> https://hastebin.com/pebinovine.coffeescript
17:09:05 <wolfman154> It recompiled but nixed is throwing an error when I rebuild?
17:09:33 <Lears> wolfman154: See my last line?
17:11:37 <wolfman154> Lears: the comma?
17:12:15 <wolfman154> Lears: what do you mean?
17:13:12 <wolfman154> Lears: ?
17:13:58 <jle`> wolfman154: what's the error?
17:16:08 <geekosaur> oh.
17:16:23 <wolfman154> It rebuilt when I removed ‚Äîupgrade, how strange 
17:17:01 <geekosaur> https://hastebin.com/topokisiji.coffeescript
17:18:54 <wolfman154> geekosaur: I just rebooted and those key bindings are not working when I try to switch to a new workspace?
17:20:03 <wolfman154> geekosaur: is this a problem with nixos or xmonad?
17:22:18 <wolfman154> ?
17:22:55 <wolfman154> I‚Äôm going to take a break, I‚Äôll be back in a while 
17:23:53 <geekosaur> looks like it doesn't handle standard names like that, it has to be an actual question mark instead
17:24:14 <geekosaur> the key name parser is a bit ad hoc and has some obscure warts
17:24:56 <geekosaur> https://hastebin.com/zelizutubi.coffeescript
17:26:13 <geekosaur> also I'd forgotten my keymap checker got merged; should probably have used that
17:36:56 <monochrom> When it comes to the question mark, there are more questions than answers. :)
17:42:44 <dibblego> @type foldr (>=>) pure -- is this in base somewhere?
17:42:45 <lambdabot> (Monad m, Foldable t) => t (c -> m c) -> c -> m c
17:48:46 <johnw> I think this would be "ala EndoM fold"
17:49:05 <johnw> EndoM is in the foldl package
17:49:37 <jle`> ah, that's where it is :)
17:49:39 <jle`> i keep on forgetting
17:49:55 <jle`> i do wish it was in base though.
17:49:59 <johnw> me too
17:50:13 <dibblego> yeah, trying to keep out deps, for a tutorial, cheers
17:50:41 <Cale> That's not really much shorter than foldr (>=>) pure
17:50:43 <jle`> fwiw foldr (>=>) pure is probably more accessible than anything given its own name
17:50:46 <Cale> and significantly harder to read
17:50:57 <johnw> Cale: granted
17:51:13 <johnw> there really isn't a foldr (.) id either, is there?
17:51:18 <Cale> right
17:56:07 <Axman6> Ia there an equivalent which returns m (t c)?
17:56:37 <jle`> with all of the intermediate results?
17:56:47 <Axman6> I guess there's a way to do it with StateT m but trying to see if there's a way that can be avoided
17:56:48 <Axman6> yeah
17:56:55 <jle`> :t scanr (>=>) pure
17:56:56 <lambdabot> Monad m => [c -> m c] -> [c -> m c]
17:57:05 <jle`> hm, no sharing
17:57:18 <Axman6> yeah it's like the traversab;e equivalent of the foldr one above
17:57:30 <jle`> maybe some mapAccumR
17:57:40 <jle`> (which is just traverse for State)
17:59:38 <growpotkin> Hey I have basically never tried to use Haddock myself (i always just check hackage). But I really want to produce some "printer friendly" documentation for a few files. The HTML haddock stuff has too many sidebards and stuff. Is there a way to dump other formats?
18:00:02 <Axman6> :t \x0 t -> runStateT (put x0 >> traverse (\f -> get >>= f >>= put >> get) t)
18:00:03 <lambdabot> (Monad m, Traversable t) => b -> t (b -> StateT b m b) -> b -> m (t b, b)
18:00:16 <Axman6> :t \x0 t -> runStateT (put x0 >> traverse (\f -> get >>= lift . f >>= put >> get) t)
18:00:17 <lambdabot> (Monad m, Traversable t) => b -> t (b -> m b) -> b -> m (t b, b)
18:00:18 <jle`> growpotkin: i believe haddock does have the ability to dump some other formats, like hoogle indices
18:01:01 <Axman6> :t \t -> runStateT (traverse (\f -> get >>= lift . f >>= put >> get) t)
18:01:03 <lambdabot> (Traversable t, Monad m) => t (b -> m b) -> b -> m (t b, b)
18:02:10 <Axman6> Feels like an interesting interview question
18:04:10 <growpotkin> jle`: Thanks. Jeeze Nix has spoiled me. I'm realizing I don't have a clue how to actually interact with Cabal now lol.
18:04:41 <growpotkin> Do I add haddock flags in a config file or just on invocation?
18:08:09 <Solonarv> I think 'cabal [new-]haddock' has a way to pass arguments through to haddock
18:08:20 <Solonarv> check its --help, should be listed there
18:12:15 <growpotkin> thank you
18:12:24 <growpotkin> yeah the new haddock was the trick
22:14:44 <jusss> List a -> (a->b) -> List b, so List is a Functor, but why function is Functor?
22:15:53 <jusss> (a->b) -> (b->c) -> (a->c)?
22:16:27 <jackdk> r -> a is the same as (->) r a, so it has the right kind (with f ~ (->) r)
22:16:50 <jackdk> then you have fmap :: (a -> b) -> ((->) r a) -> ((->) r b)
22:17:05 <jackdk> i.e. fmap :: (a -> b) -> (r -> a) -> (r -> b)
22:18:05 <jusss> I wonder is there a type called Function? so Function a -> (a->b) -> Function b
22:18:38 <jusss> fmap :: (a -> b) -> (r -> a) -> (r -> b)    a and r is the same type?
22:18:46 <jackdk> no
22:18:57 <jusss> but (a->b) and (r->b) is the same type?
22:19:00 <jackdk> no
22:19:07 <jackdk> a, b, r are all potentially different types
22:19:25 <jusss> but List a and List b are both List type
22:19:48 <jackdk> List a and List b are different types
22:20:10 <jackdk> because a is not necessarily the same as b
22:20:20 --- mode: geekosaur set -o geekosaur
22:21:09 <jle`> jackdk: you can make something like your Function
22:21:13 <jle`> type Function r = (->) r
22:21:24 <jackdk> true.
22:21:37 <jle`> ah sorry, that was meant to pinging to jusss 
22:21:51 <jackdk> no worries mate
22:21:52 <jle`> so you get something like (Function r) a -> (a -> b) -> (Function r) b
22:21:59 <jusss> List a and List b both are derived by List?
22:22:14 <jle`> 'List a' is a list of a's
22:23:07 <jusss> and (a->b)?
22:23:30 <jle`> an (a -> b) is a function from 'a' to 'b'
22:23:43 <jusss> (a->b) is (->) a b       and (r->b)  is  (->) r b?
22:23:48 <jle`> yes
22:23:54 <jle`> just like:
22:23:57 <jle`> > (+) 1 3
22:23:59 <lambdabot>  4
22:24:30 <jackdk> % :k (->) Int Char
22:24:30 <yahb> jackdk: (->) Int Char :: *
22:25:11 <jusss> how I to see (->) a b?     ((->) a) b  or (->) (a b)  ?
22:25:40 <jle`> both ways have advantages in different situations
22:25:48 <jle`> ah, but (->) (a b) is wrong
22:26:20 <jusss> (a b) just mean a and b is one thing, not tuple stuff
22:26:51 <jle`> (a b) is a "applied" to b
22:26:54 <jle`> like (List b)
22:27:22 <jle`> `((->) a) b` is not the same as a -> b
22:27:25 <jusss> that's kind like lisp
22:27:45 <jle`> yeah, if you're asking about haskel syntax, then it's not the same thing
22:28:16 <jle`> it's just liek how `((+) 1) 3` is not the same as (+) (1 3)
22:28:24 <jle`> in haskell
22:28:55 <jusss> let's go back to that Function r
22:29:51 <jusss> type Function r = (->) r       so Function r a is (->) r a  and is r -> a?
22:30:07 <jle`> yes
22:30:28 <jle`> or also ((->) r) a, if we add extra redunant parentheses
22:30:38 <jle`> in haskell, `f a b` is parsed as `(f a) b`
22:31:19 <jusss> so can we know  (r->a ) -> (a -> b) -> what?
22:31:46 <jle`> if you're drawing the analogy to List a -> (a -> b) -> List b
22:31:56 <jusss> yeah
22:32:00 <jle`> we have ((->) r) a -> (a -> b) -> ((->) r) b
22:32:21 <jle`> or (r -> a) -> (a -> b) -> (r -> b)
22:32:21 <jusss> and that's true?
22:32:41 <jle`> by true, do you mean it exists as a possible function?
22:33:13 <jusss> that's no need
22:33:42 <jusss> so I wonder what's the term function?    -> is function or (->) r is function?
22:33:57 <jusss> or (->) r a is function
22:34:02 <jle`> (r -> a) is the type of a function
22:34:14 <jle`> (->) is the function type constructor, used to create function types
22:34:25 <jle`> 'create' as in, specify
22:34:51 <jle`> and `(->) r` is the Functor
22:35:38 <jusss> what's r here?
22:35:53 <jusss> what's r in `(->) r` ?
22:36:19 <eiGHttt> % :k (->)
22:36:19 <yahb> eiGHttt: (->) :: * -> * -> *
22:36:26 <jle`> it's a type variable here
22:36:27 <geekosaur> the type of the parameter the function takes.
22:36:42 <jle`> in this discussion, it means that what we are saying is valid for any type
22:37:00 <jle`> so it's true for (->) Int, true for (->) Bool, etc.
22:37:29 <jle`> and a function of type (r -> a) is a function that takes an 'r' and returns an 'a'
22:37:41 <jle`> so a function of type (Int -> String) is a function that takes an Int and returns a String
22:38:38 <jusss> the thing is (->) must have two type variables?
22:39:22 <jusss> (->) is a type constructor, ok, I can understand,  r is a type variable, ok, that's fine, but why need another type variable a?
22:39:25 <geekosaur> when fully applied
22:39:42 <geekosaur> note that the Functor typeclass wants something that is *not* fully applied, since it supplies an additional type
22:40:03 <geekosaur> so a Functor instance would be for ((->) r), because it will add the a itself
22:40:15 <geekosaur> but the type constructor is (->) r a
22:42:39 <jusss> the type constructor should only be (->) ?
22:43:03 <geekosaur> I'm not sure what you're asking
22:43:18 <jle`> jusss: the type of a function is a -> b
22:43:21 <jusss> (->) r a is a type, a function type, and (->) is the Functor, and r and a both are type variables?
22:43:37 <jle`> (->) r is the Functor
22:43:45 <geekosaur> the type constructor is (->). being a symbol, it is normally infix, although the parentheses around it make it act as prefix. it takes two parameters, each a type (or type variable)
22:45:13 <jusss> so (->) is the type constructor, and (->) r is the Functor?
22:45:21 <jusss> and (->) r a is the type ?
22:45:45 <jusss> I even don't know what I'm talking about...
22:46:05 <jle`> they are all "types", but only r -> a is the type of functions
22:46:50 <jle`> for some r and a
22:47:27 <jusss> for example, data T a -> V a, I know that T is the type constructor and that a is type variable, V is the value constructor , and T a is the type of the value (V a)
22:48:36 <jle`> do you mean data T a = V a
22:49:07 <jusss> "<jusss> for example, data T a -> V a, I know that T is the type constructor  and that a is type variable, V is the value constructor , and T a is   the type of the value (V a)"  
22:49:20 <jusss> jle`: yeah
22:49:27 <jusss> my network just broken
22:52:16 <jusss> let's be clear something, function do have a type, right? like r->a is a type of function
22:52:46 <jusss> and (->) is a type constructor, just like T in data T a = V a?
22:53:20 <jle`> right, a function (like even :: Int -> Bool) has something of type ?? -> ??
22:53:32 <jle`> and (->) is the type constructor, the syntactical thing that allows us to specify function types
22:54:00 <jusss> and Ôºà->) r  is Functor, (->) r a -> (a -> b) -> (->) r b like List a ->(a->) -> List b,right?
22:54:55 <jusss> even::Int -> Bool , the type is Int -> Bool , right?
22:55:23 <jusss> and even is also a function 
22:55:29 <jle`> (->) r a -> (a -> b) -> (->) r b is analogous to List a -> (a -> b) -> List b, yes
22:55:48 <jusss> jle`: but?
22:56:06 <jle`> no but :)
22:56:08 <jusss> jle`: as you said, it's not need for the same, so?
22:56:09 <jle`> although it might be more accurate to say that `(->) r` is "a" Functor.
22:56:23 <jle`> jusss: oh, i was mentioning that in case you had a typo in what you said
22:56:31 <jle`> you wrote List a -> (a ->) -> List b, missing the 'b' in the middle
22:56:47 <jusss> do I?
22:56:48 <jle`> `(->) r` is just r "applied" to (->), like `f x` is x applied to f
22:57:05 <jle`> but, it happens to also have a Functor instance
22:57:14 <jle`> just like how Int happens to also have an Eq instance
23:00:18 <jusss> now, the term function , what it is?  (-> r a) is the function's type? and it is function?
23:00:44 <jle`> (->) r a, not (-> r a)
23:01:01 <jusss> oh, my typo
23:01:22 <jusss> yeah, what's the term function?
23:01:47 <jusss> r->a is a type, r-> is Functor, -> is type constructor
23:01:57 <jusss> and what is function now?
23:02:15 <jle`> here we're shifting from the discussion of general syntax to specific types
23:02:26 <glguy> Functions are values you can apply to arguments
23:02:52 <jle`> a function in haskell is something that, given a value, returns a new value.  it'll give the same output for the same value input
23:03:03 <jle`> you apply them using syntax like `f x`, or:
23:03:05 <jle`> > even 7
23:03:08 <lambdabot>  False
23:03:08 <glguy> Or similarly they can be types you can apply, depends on the level you're asking about
23:03:35 <jle`> these types of functions are values in haskell, like 1, True, "hello", 7.8, 'a', etc.
23:03:48 <jle`> and like all values, they have types.  the types are of the form ??? -> ???
23:04:08 <jle`> or 'a -> b', where a represents the type of the input they expect, and b represents the type of the values they return
23:04:36 <jusss> and we can not represent function with r->a ?
23:04:51 <glguy> (->) r , happens to be an instance of Functor, (->) is a type, a type constructor, an instance of some type classes, a function at the type level
23:04:51 <jle`> functions have type r -> a, for some r and some a
23:05:08 <jle`> all functions have a type of the form __ -> __
23:05:33 <jle`> so 'r -> a' can't be a function, but it is the *type* of a function from r to a
23:05:40 <jusss> and we can not describe that functions with their type?
23:05:58 <jle`> we can :)
23:06:11 <jle`> if r is Int, and a is Bool, then `even` is a function of type Int -> Bool
23:06:24 <jle`> remember, r and a here are just placeholders for actual types we want to use them with
23:06:37 <jusss> yeah, 
23:06:41 <jle`> so `even` is Int -> Bool, or r -> a, where r is Int and a is Bool
23:06:45 <MasseR> totally unrelated to anything, but jle` thank you for your blog, it's really entertaining
23:06:50 <jle`> er, even has type Int -> Bool
23:07:07 <jle`> MasseR: hah, thank you, i really appreciate it :) hopefully it is helpful as well, haha
23:08:37 <jusss> jle`: and Int->Bool is the type of function even, 
23:09:04 <jle`> yes. or well, to be specific, it's one possible type, since 'even' in haskell is polymorphic
23:09:19 <jle`> maybe a better example is `ord :: Char -> Int`
23:09:22 <jusss> I still have a little confused about Int ->  is the Functor
23:09:40 <jle`> "a" Functor :)
23:09:56 <jusss> whatever, my English is not good
23:10:03 <jle`> not trying to correct your english
23:10:14 <jle`> just saying that the two things have different implications :)
23:10:49 <MasseR> (one of the many functors vs the one and only functor)
23:11:11 <jusss> Int -> Bool, can I think a Functor need a type variable to constrct a type?
23:11:20 <jle`> jusss: when we say something is 'a' Functor, the implication is that it's just a regular old type that we have the opportunity to write a Functor instance for
23:11:47 <jle`> jusss: right, a Functor is a parameterized type
23:11:50 <jusss> and all the Functor are type constructors?
23:11:56 <jle`> so (Int ->) is parameterized on the 'result'
23:11:57 <glguy> no
23:12:20 <glguy> Type constructor is a category of names, it doesn't tell us about the kinds
23:12:29 <glguy> Int is a type constructor and not an instance of Functor
23:12:45 <glguy> (Either Int) is an instance of Functor and not a type constructor
23:13:53 <jusss> err..  (->) r is a Functor,   (->) r is a type constructor?
23:13:53 <glguy> There are constructors and variables
23:14:07 <jle`> (->) is the type constructor in this situation
23:14:12 <glguy> No, (->) r is neither not a constructor or a variable
23:14:27 <jle`> `(->) r` is r applied to the type constructor (->)
23:14:37 <jle`> like how `even 5` is 5 applied to the function `even`
23:14:43 <glguy> No, (->) r is neither a constructor nor a variable*
23:15:23 <jle`> or maybe to make a stronger analogy, how `V True` is True applied to the data constructor V, from your example earlier
23:15:43 <glguy> V True is "V applied to True"
23:16:08 <jle`> ah thanks. oh man i mixed this up the entire time
23:16:39 <MarcelineVQ> it is pretty late at night for you flesh and blood's
23:16:55 <glguy> Look at the bot showing off :-p
23:17:09 <MarcelineVQ> @botsnack
23:17:09 <lambdabot> :)
23:18:21 <jusss> fine, maybe I should just take r-> is a Functor and no more questions
23:18:51 <jusss> jle`: glguy really thanks
23:18:55 <glguy> jusss: The definition of functor is (simplified): class Functor (f :: * -> *) where fmap :: (a -> b) -> (f a -> f b)
23:19:26 <glguy> Because the 'f' parameter has kind * -> * we know we'll be able to apply it to a type with kind *
23:19:54 <glguy> when you were asking about functors being type constructors what you were really getting at was that instances of the Functor class will always have kind * -> *
23:20:51 <eiGHttt> why is (Either Int) not a type constructor? it has kinds * -> *.
23:21:01 <glguy> The reason that this class expect a type with kind * -> * is that the type of fmap needs to use f applied to some types
23:21:03 <Cale> Because it's a type application, not a constructor
23:21:09 <glguy> eiGHttt: type constructor is a kind of name
23:21:16 <glguy> the capitalized ones
23:21:17 <jusss> glguy: and "function is a Functor" is wrong? 
23:21:31 <Cale> Either is a type constructor, and Int is a type constructor, but Either Int is an application (of one type constructor to another)
23:22:25 <jle`> jusss: it's more of a synecdoche. it's "wrong", but most people will know what you mean
23:22:42 <jle`> `(->) r` is a Functor, and it's the functor people often talk about when referring to functions
23:23:08 <eiGHttt> thanks.
23:23:10 <glguy> ?wn synecdoche
23:23:11 <lambdabot> *** "synecdoche" wn "WordNet (r) 3.0 (2006)"
23:23:11 <lambdabot> synecdoche
23:23:11 <lambdabot>     n 1: substituting a more inclusive term for a less inclusive one
23:23:11 <lambdabot>          or vice versa
23:23:24 <jusss> jle`: they describe List for helping people to understand what functor is, so I think a function is a container?
23:23:38 <jusss> or wrapper  box whatever
23:23:54 <jle`> do you mean, a functor is a container?
23:24:11 <jle`> i think it's safe to say that *some* functors represent containers. but not all.
23:24:26 <jle`> List being a Functor makes it convenient to manipulate values inside it
23:24:36 <jusss> "A functor is a container of type a that, when subjected to a function that maps from a‚Üíb, yields a container of type b." from https://stackoverflow.com/questions/2030863/in-functional-programming-what-is-a-functor
23:24:54 <jusss> http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
23:25:01 <jle`> i don't think that is strictly always true, but it's an intuition people often start with
23:25:09 <jle`> not all functors are containers.
23:25:22 <jle`> er, not all functors correspond to containers, i mean
23:25:32 <jle`> but a lot of containers correspond to functors
23:25:43 <Cale> It's also a bit imprecise to say that any functor is a container. It might produce types of containers.
23:25:58 <Cale> [1,2,3] isn't a functor
23:26:08 <Cale> But the type constructor for lists is a functor
23:26:38 <jusss> List a, List is a Functor
23:26:42 <jle`> right, i think 'functors are containers' is pretty misleading, it lead to a lot of headache for me when i started
23:26:56 <jle`> but, i understand the sentiment
23:27:10 <Cale> But there is a sense in which all the functors we talk about in Haskell can be thought of as containers, it just gets really weird for some of them
23:27:11 <jle`> it does break down for things like (->) r
23:27:17 <Cale> It doesn't really
23:27:27 <jle`> it breaks down in the sense that it doesn't add anything to the conversation
23:27:38 <Cale> A function r -> a is like a container indexed by all the values of type r, containing values of type a
23:27:55 <kadoban> Don't you end up defining "container" as pretty much exactly Functor, leading to the intution helping basically not at all?
23:27:58 <jle`> "r -> a is a container, in the sense that exactly matches what an r -> a is"
23:28:02 <Cale> You can imagine functions in this way, as sort of "arrays"
23:28:13 <Cale> (or arrays as functions, for that matter)
23:28:36 <Cale> It can be useful to have that perspective
23:29:08 <wolfman154> xmonad ‚Äîrecompile is throwing an error, could you guys help me out:   https://hastebin.com/zelizutubi.coffeescript
23:29:11 <jusss> what that functor is used for?
23:29:33 <Cale> Well, that's basically asking "what does fmap do for that functor?"
23:29:49 <Cale> and if we write down its type, it will become clear what it must be
23:30:02 <Cale> fmap :: (a -> b) -> (e -> a) -> (e -> b)
23:30:28 <Cale> That has to be function composition
23:30:40 <jusss> Cale: the middle (e->a) , why it must return a?
23:30:55 <Cale> Well, let's look again at the general type of fmap
23:31:02 <Cale> fmap :: (Functor f) => (a -> b) -> f a -> f b
23:31:09 <Cale> In this case, f a = e -> a
23:31:19 <wolfman154> I have no idea what I‚Äôm doing wrong?
23:31:34 <Cale> wolfman154: You didn't paste the error
23:31:43 <jle`> jusss: all functor instances are useful in their own sense.  List is useful, for example, to...well, make a list of things :)
23:31:57 <jle`> jusss: but functor, as an abstraction, is useful for uniting a bunch of these under a common, clean interface
23:32:12 <jle`> and it also lets you do some nice program rewriting
23:32:23 <jle`> for example, fmap f (fmap g x) is always the same as fmap (f . g) x
23:32:55 <Cale> In the container analogy from before, we see function composition as taking some function (a -> b) (which you can think of however you like), and some function of type (e -> a), which we think of as a container containing many values of type a, one for each value of type e
23:33:24 <Cale> and applying the function (a -> b) to each of the values of type a, ending up with a container indexed by values of type e, containing values of type b
23:33:27 <jusss> jle`: and there's no fmap in other languages, unless g and x is lists, so map it is
23:33:39 <Cale> But of course, the code for it doesn't require so many words :)
23:33:47 <jle`> well, a lot of other languages have fmap's *specific* for each type
23:33:49 <Cale> (g . f) x = g (f x)
23:34:04 <jle`> but most other language ecosystems don't have a single unifying fmap for all functors
23:34:48 <Cale> wolfman154: ?
23:35:13 <jusss> I wonder what is (a->b) -> (b->c) -> (a->c) ? and does it exists?
23:35:29 <jusss> or just my illusion
23:35:32 <Cale> That exists, that's the same thing with the other argument order.
23:35:36 <wolfman154> https://hastebin.com/upatuyofip.sql
23:36:12 <Cale> wolfman154: ahhh
23:36:17 <jle`> jusss: it's function composition :)
23:36:27 <jle`> it's (>>>), as well
23:36:33 <Cale> wolfman154: Your error is not for the same code as you pasted
23:36:36 <jle`> > ((+1) >>> (*2)) 10
23:36:38 <lambdabot>  22
23:36:46 <eiGHttt> wolfman154: main = xmonad $ defaultConfig {...}
23:36:58 <Cale> Yeah, the code he pasted had the $
23:37:00 <jle`> jusss: in all honesty, the FUnctor instance of (->) is not very useful on its own.  you will never directly use fmap for (->) in everyday code
23:37:03 <jusss> jle`: ok
23:37:13 <Cale> The $ should fix things
23:37:17 <jle`> sorry, i mean, for (->) r
23:37:31 <jle`> we talk about it here in the sense "just because we can"
23:37:46 <jle`> "(->) r "can" be a Functor, so let's talk about it" :)
23:37:54 <Cale> It can certainly be useful for code golf
23:38:01 <Cale> haha
23:38:06 <jle`> but, `(->) r` having a Functor instance is useful when we use functor-polymorphic abstractions
23:38:06 <wolfman154> One second 
23:38:09 <MasseR> jle`: I occasionally use it with lenses and applicatives.
23:38:12 <jle`> that is, programs that are written to work for "all" functors
23:38:44 <jle`> Haskell has a lot of code that is written to work for 'all' Functor instances
23:39:02 <jle`> so because we give (->) r an instance, all of that code is now usable by us
23:40:42 <jusss> jle`: I wonder what it's like ? the instance of (->) r 
23:40:54 <jusss> for example? any concret stuff
23:41:06 <wolfman154> Cale: I pasted and saved the new code but for some reason xmonad is trying to recompile the code from before? Maybe I need to do a rebuild switch instead in nixos?
23:41:13 <jle`> jusss: we can just peek at the implementation :)
23:41:17 <Cale> wolfman154: no idea
23:41:25 <jle`> fmap :: (a -> b) -> (r -> a) -> (r -> b)
23:41:35 <wolfman154> Strange 
23:41:35 <jle`> fmap f g = \x -> f (g x)
23:41:36 <Cale> wolfman154: But that seems likely? Maybe it's getting the compiled code from the nix store
23:41:47 * hackage rio 0.1.9.2 - A standard library for Haskell  https://hackage.haskell.org/package/rio-0.1.9.2 (MichaelSnoyman)
23:42:16 <Cale> Well, except that also doesn't make sense
23:42:32 <Cale> because you have a compile error
23:42:46 <Cale> So maybe it stashed source code into the nix store and is trying to build that?
23:43:31 <jusss> jle`: wait a second, f is (a->b) and g is (r->a) right?
23:43:49 <jusss> how we can get that lambda from (r->b)?
23:44:05 <Cale> x :: r
23:44:05 <jle`> check the types :)
23:44:12 <Cale> g x :: a
23:44:21 <Cale> f (g x) :: b
23:44:32 <Cale> \x -> f (g x) :: r -> b
23:45:22 <wolfman154> Cale: my guess is that I‚Äôm not supposed to do xmonad ‚Äîrecompile, instead nixos-rebuild switch (to have nixos compile it for me) ? 
23:46:01 <Cale> No idea, I don't use nixos
23:46:07 <Cale> (nor xmonad, for that matter)
23:47:04 <wolfman154> Cale: it works
23:47:07 <wolfman154> :)
23:47:12 <Cale> cool
23:47:39 <Cale> jusss: Here's an example of the (->) e monad in use
23:47:48 <jusss> Cale: from \x -> f(g x) :: r->b to know x is r and f(g x) is b, that's ok, but how to get there b to f(g x)
23:47:54 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
23:47:56 <lambdabot>  ("hello","olleh","HELLO")
23:48:19 <Cale> I don't understand that last question
23:48:41 <Cale> "how to get there b to f (g x)"
23:48:52 <Cale> what?
23:49:02 <jusss> how to get the b from fmap :: (a -> b) -> (r -> a)
23:49:19 <Cale> That's not fmap's type
23:49:30 <Cale> fmap :: (a -> b) -> (r -> a) -> (r -> b)
23:49:34 <Cale> or
23:49:36 <Cale> fmap :: (a -> b) -> (r -> a) -> r -> b
23:49:39 <jusss> to b is fmap(g r)
23:49:46 <Cale> If you prefer to remove the redundant paren
23:50:00 <Cale> So if we define
23:50:07 <Cale> fmap f g x = ...
23:50:13 <Cale> then f :: (a -> b)
23:50:17 <Cale> and g :: (r -> a)
23:50:20 <Cale> and x :: r
23:50:32 <Cale> and the ... on the right must have type b
23:50:36 <jusss> and that's ok, the b
23:50:47 * hackage fedora-img-dl 0.2 - Fedora image download tool  https://hackage.haskell.org/package/fedora-img-dl-0.2 (JensPetersen)
23:50:49 <Cale> and there's only one way to get a value of type b using the things we have
23:50:52 <jusss> \ r ?
23:50:54 <Cale> which is to use f
23:51:00 <Cale> So
23:51:08 <Cale> fmap f g x = f (...)
23:51:16 <Cale> where now the ... has type a
23:51:30 <Cale> and there's only one way to get something of type a, which is to use g
23:51:35 <Cale> fmap f g x = f (g ...)
23:51:40 <Cale> and now the ... has type r
23:51:47 <Cale> and we have something of type r, namely x
23:51:51 <Cale> fmap f g x = f (g x)
23:51:53 <Cale> done
23:52:01 <Cale> and there were no real choices to be made
23:52:59 <Cale> We can move the parameter to the other side of the equation if we like:
23:53:05 <Cale> fmap f g = \x -> f (g x)
23:53:08 <Cale> it means the same thing
23:54:52 <jusss> err...
23:56:20 <jusss> fmap :: (a->b) -> (r->a) -> (r->b)       so  fmap (a->b) (r->a) = (r->b)
23:56:48 <Cale> Try not to mix the notation for types and terms
23:56:53 <Cale> But yeah
23:57:13 <jusss> f::a->b  g::r->a  we got fmap f g = (r->b)
23:57:27 <Cale> fmap (f :: a -> b) (g :: r -> a) :: r -> b
23:57:35 <Cale> yeah
23:59:01 <jusss> what I don't understand is how through (r->b) to get \x -> f (g x) or say how from b to (a->b) (r->a  r)
23:59:13 <jusss> aha,
