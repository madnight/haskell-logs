00:01:39 <ski> (and i'm not going to be overruled by a silly rule in a tool like `hlint' or `hindent')
00:02:25 <dminuoso> lrb: GHC errors are a double edged sword. In general they are very detailed and give a lot of context (related bindings, types, what lead the compiler to the error), but sometimes type inference and place errors at the wrong place.
00:02:41 <dminuoso> *type inference can place
00:02:46 <ski> <https://github.com/chrisdone/hindent>
00:02:50 <ski> @hackage hlint
00:02:50 <lambdabot> http://hackage.haskell.org/package/hlint
00:03:10 <jlamothe> dminuoso: I've had errors where it was out by 20+ lines.
00:03:24 <dminuoso> jlamothe: Ive had C++ errors spanning tens of thousands of lines.
00:03:32 <dminuoso> Quite literally.
00:03:33 <jlamothe> dminuoso: Fair.
00:03:35 * ski would like to see type error slicing being tried
00:03:48 <jlamothe> I guess it turns out that debugging (in any language) is hard.
00:03:59 <jlamothe> Who'da think it?
00:04:04 <lrb> There are people who have contests to see who can generate the longest error with the fewest lines of C++. 
00:04:20 <lrb> IIRC, they can generate gigabytes of errors in a few loc
00:04:51 <jlamothe> When you start working with C++'s templates, I can believe it.
00:05:03 <dminuoso> lrb: My overall impression so far is that GHC diagnostics are rather good. Sometimes you just need to know how the compiler does type inference and type unification, or that the type system has certain boundaries..
00:05:04 <ski> ("Skalpel: A Type Error Slicer for SML" at <http://www.macs.hw.ac.uk/ultra/skalpel/>. online demo (still working ?) at <http://www2.macs.hw.ac.uk/cgi-bin/cgiwrap/~jp95/skalpel/slicing.cgi>)
00:05:51 <DigitalKiwi> if hindent (or whatever) is the oracle of properly indented code you no longer have to worry about bikeshedding with other developers if your code is formatted, you don't have to think "is this how it's supposed to be? does this look better or this...what's it like in other fonts? what if..." the problem becomes "does the code do what i want" which is enough of a cognitive load, whether it's formatted the right way or not, and then if everyone 
00:05:51 <DigitalKiwi> uses it all code is more easily understood because the style is already common
00:06:18 <DigitalKiwi> (and sometimes the other developers bikeshedding are yourself)
00:06:48 <ski> (a type error slicer detects all, and only, the locations that actually contribute to the type inconsistency, given the information it has at hand : you must change at least one of these locations (and perhaps also some other(s) ?), to avoid the type error (if possible))
00:07:14 <ski> (as opposed to reporting the location where the type inconsistency was *detected* as the "error location")
00:08:28 <ski> DigitalKiwi : and where would the fun be in that, now ?
00:09:38 <dminuoso> ski: That would be wonderful. Ever since I started using lens liberally, Ive been using RankNTypes everywhere just for being able to type annotate parts to ease diagnostics. It's somewhat annoying having to turn on extensions and figuring out lens types just so I can make sense of programming mistakes.
00:09:40 <DigitalKiwi> that is the fun
00:10:09 <DigitalKiwi> not having to worry about anything other than the problem you're solving is fun
00:10:44 <DigitalKiwi> having to worry about formatting and tabs vs spaces and what looks good or not is not fun
00:11:38 <ski> DigitalKiwi : even having it become conservative in the face of some extensions could be worth it, i think
00:11:39 <DigitalKiwi> (well, when it comes to code)
00:12:11 <ski> er, sorry
00:12:14 <ski> dminuoso ^
00:14:40 <lrb> OK I'm about to crash. Thanks for all the help again tonight :)
00:14:49 <lrb> catcha later
00:18:47 * hackage yam-datasource 0.6.1 - Yam DataSource Middleware  https://hackage.haskell.org/package/yam-datasource-0.6.1 (leptonyu)
00:19:47 * hackage yam-redis 0.6.1, yam 0.6.1 (leptonyu): https://qbin.io/trauma-gays-t8vc
00:19:56 <zincy_> Is an interpreter just a compiler which executes the instructions directly rather than outputting source code?
00:23:20 <__monty__> They're very similar yes.
00:26:44 <zincy_> Why do dynamic languages often get interpreted by a VM
00:27:11 <DigitalKiwi> i don't think it's as easy as a yes or no
00:27:34 <tdammers> the first parts of the pipeline can be the same (lexing, parsing, building an AST)
00:27:45 <tdammers> and sometimes they are
00:28:43 <zincy_> So they have varying degrees of overlap in the wild but the common strand is direct execution for interpreters.
00:28:43 <DigitalKiwi> and even interpreted is not that well defined and universal
00:28:44 <tdammers> in Haskell, you can even abstract over "interpretation / code generation" such that both use the same code, but against different implementations of the "interpretation" API
00:29:34 <zincy_> Does an interpreter need to build an AST?
00:29:35 <tdammers> more specifically, if you're going to write an interpreter, the interesting question is how much of the compilation chain you use, and at what point you jump off the compilation train and just run whatever it is you have at that point
00:29:52 <tdammers> depends on the language, but typically, yes, in some form or other
00:30:16 <tdammers> you need *some* kind of representation of the code that is close enough to the abstract semantics of the language that you can interpret it as-is
00:30:27 <tdammers> a concrete syntax representation is not usually very suitable for that
00:31:16 <zincy_> Ah right.
00:31:34 <zincy_> Thanks
00:31:56 <dminuoso> zincy_: The details depend on the language entirely, really.
00:32:29 <dminuoso> zincy_: There's no intrinsic notion of "execution" vs "interpretation" either. Even your elf binaries are run by whats called the elf interpreter.
00:34:33 <dminuoso> Or at least they usually are.
00:41:35 <Solonarv> mpickering: re yesterday: unliftio has appropriately-lifted versions of many libraries, including async
00:45:29 <mpickering> Solonarv: So should I use MonadBaseControl or UnliftIO?
00:45:37 <Solonarv> I'd recommend UnliftIO
00:45:55 * ski . o O ( "Concerning compilation and interpretation, and an interpretation of the compilation of confusion surrounding their meaning and execution" in 2007-06-19,"Summarizing several issues with compilation and interpretation" in 2007-07-14, both at Riastradh's blag at <https://mumble.net/~campbell/blag.txt>,<http://vrici.lojban.org/~cowan/blag.xml> )
00:45:58 <Solonarv> it's less brain-bending and more obviously correct
00:46:32 <Solonarv> like, I'd feel really lost if I had to use MonadBaseControl's functions directly
00:46:43 <ski> zincy_ ^
00:46:56 <cocreature> If UnliftIO works, then you can be fairly sure it does what you expect it to do. That does come at a cost though, it has far fewer instances than MonadBaseControl
00:46:56 <mpickering> not 100% sure I want to buy into the fpcomplete package ecosystem though..
00:46:59 <cocreature> But imho that’s a good thing
00:47:14 <mpickering> is it widely support by other packages as well?
00:47:15 <Solonarv> with UnliftIO I can just do something like:
00:47:16 <Solonarv> do runInIO <- askUnliftIO
00:47:16 <Solonarv>    liftIO $ forkIO (runInIO whatever)
00:47:44 <Solonarv> UnliftIO is fairly "batteries included", it has a good number of instances
00:48:11 <zincy_> ski: thanks
00:48:46 <mpickering> ah I see they are all just bundled in the package
00:48:59 <Solonarv> yup
00:49:19 <Solonarv> unliftio-core has the core MonadUnliftIO typeclass, unliftio has that + lifted functions
00:50:12 <mpickering> lol the reddit comments when this library were released were all about whether unliftio was similar to Representable1 
00:50:14 <mpickering> classic stuff
00:50:50 <Solonarv> if you look through <http://packdeps.haskellers.com/reverse/unliftio> and <http://packdeps.haskellers.com/reverse/unliftio-core> you can see it's used by a whole bunch of packages
00:51:43 <phadej> Solonarv: it's used by resourcet
00:51:54 <Solonarv> yeah, I know
00:52:36 <phadej> (which switched from monadbasecontrol to unliftio)
00:52:55 <mpickering> phadej: What's your opinion on this?
00:53:43 <dminuoso> Solonarv: The only questionable part of unliftio is that it changes the semantics of some parts like from Control.Exception
00:53:51 <dminuoso> In my mind.
00:55:25 <dminuoso> Ah but I guess that's unliftio which is different from unliftio-core
00:55:48 <Solonarv> dminuoso: oh, do you mean the "will not catch async exceptions"? hm, that's a tad unfortunate indeed
00:56:04 <Solonarv> I hadn't even seen that yet
00:56:17 <dminuoso> Solonarv: Yeah. And Im not even talking about whether I agree or disagree with the change, it's annoying to have a change in semantics if you change from one to the other.
00:56:25 <Solonarv> yeah, definitely
00:57:14 <Solonarv> in principle I agree with the unliftio semantics (though I think there should be *some* way to catch async exceptions), but I don't like that they're different even though they're advertised as a drop-in replacement
00:59:39 <ski> zincy_ : please search for the correct date in that balg, if not obvious
00:59:42 <dminuoso> Perhaps having both versions in different modules would have been a better option.
01:00:10 <dminuoso> So that a library user could then for themselves decide whether to use the base compatible dropin or the "improved" versions.
01:00:25 <Solonarv> yeah, that'd be good too
01:00:35 <mpickering> Solonarv: monad-control is used by way more packages
01:01:12 <Solonarv> should actually be fairly straightforward to make that, since it's just mechanically throwing askUnliftIO / runInIO / liftIO at things to make the types line up
01:01:19 <Solonarv> mpickering: it's been around for much longer
01:01:39 <dminuoso> mpickering: My dislike with MBC is that its easy to write instances for it, but hard to reason about whether they are lawful. UnliftIO is almost trivial in comparison.
01:01:40 <Solonarv> I mostly meant to show that it's reasonably used and doesn't live on some fpco-only island (as far as I can tell)
01:02:44 <mpickering> but if I define `MBC` instances just for Reader like things then what's the difference?
01:02:48 <mpickering> Is the API nicer to use?
01:03:59 <Solonarv> in the end you're probably using the lifted functions anyway, so it wouldn't make a huge difference
01:04:16 <cocreature> “if I define MBC instances just for Reader” doesn’t really work since monad-control already includes a bunch of questionable instances
01:04:41 <Solonarv> but if you're *not* using pre-defined lifted functions, and defining them yourself instead, I find unliftio much easier to use
01:05:03 <mpickering> I'm just super nervous that unliftio is one of the opinionated fpcomplete packages which will force the application down a certain path in the future
01:05:14 <mpickering> alright I will try it
01:05:20 <phadej> mpickering: I don't think that unliftio-core will become that package
01:05:28 <Cale> dminuoso: It's not even really just whether they're lawful, but whether the instances which exist are the ones you want or not.
01:05:29 <Solonarv> 99% of the time it's just "use 'askUnliftIO' to get a 'm a -> IO a', use that + 'liftIO :: IO a -> m a' until types line up"
01:06:35 <phadej> withRunInIO gives you `m a -> IO a` too
01:06:52 <Solonarv> yeah, there's a few ways to get a 'm a -> IO a'
01:07:13 <Solonarv> I just get easily confused by nested continuations :P
01:07:23 <dminuoso> withRunInIO is easier to use :-)
01:07:30 <phadej> withRunInIO $ \runInIO -> ... -- 
01:07:41 <phadej> same as with `liftBaseWith`
01:08:11 <Solonarv> bah! I yield
01:08:28 <Cale> mpickering: My recommendation would be to use neither, if at all possible. What operation is it that you need?
01:09:29 <mpickering> The real problem is that I want to fork a computation which can be cancelled by an external trigger
01:09:51 <mpickering> so Solonarv suggested using async for this
01:10:10 <mpickering> but the application monad transformer stack is some ReaderT and the Ghc monad rather than just IO
01:10:19 <mpickering> so to make it more ergonomic I wanted to use lifted-async
01:10:47 <Solonarv> ah, hm. I don't know if Ghc has a MonadUnliftIO instance - I mean, it probably doesn't
01:11:04 <dminuoso> What is the Ghc monad?
01:11:41 <Solonarv> it's part of GHC and also exposed by the GHC API
01:11:41 <Cale> mpickering: Start by just writing the operation that you really need, using whatever functions run your monad.
01:12:07 <Solonarv> ah, nope - no MonadUnliftIO Ghc instance
01:12:14 <mpickering> Solonarv: This is why I need to write my own instance for it..
01:12:15 <Solonarv> then again there isn't a MonadBaseControl instance either
01:12:22 <mpickering> It's just a ReaderT
01:12:58 <Solonarv> true, but you're writing an instance (or the relevant operations, I suppose) directly
01:13:15 <Cale> mpickering: Sometimes, if you really need it to work in different monads, making your own type class can be the right idea. MonadBaseControl is a good way of making a bunch of decisions in a completely arbitrary way that might not coincide with what you want. It's probably fine for just ReaderT, but for everything else... it becomes questionable.
01:13:25 <dminuoso> Though Cale has a point. If you dont actually need to abstract over MonadUnliftIO in general, then writing some `unliftGhc :: Ghc a -> IO a` might be much simpler.. then you can use async freely.
01:13:50 <Cale> I'm not even thinking unliftGhc
01:14:07 <mpickering> There is more to the stack than just Ghc, there are also two other ReaderT monads
01:14:18 <mpickering> writing the functions directly sounds like a massive waste of time tbh
01:14:19 <Cale> I mean a specialised async operation which makes the decisions about how to deal with the monad transformers specially for that one operation.
01:14:35 <Solonarv> you could simply write:
01:14:35 <Solonarv> deriving via (ReaderT Session IO) instance MonadUnliftIO Ghc
01:14:36 <Solonarv> if you wanted
01:14:52 <mpickering> Nice idea
01:15:04 <Solonarv> or generally use 'coerce' to skip writing the actual code, since you just hav a stack of ReaderTs in a trenchcoat
01:15:07 <Solonarv> anyway, gotta go
01:15:13 <Cale> If it's just ReaderT's, then fine
01:15:23 <dminuoso> trenchcoat, this should be a type theory term.
01:15:26 <Cale> But you might want to ask "what if someday there's a StateT?"
01:24:53 <Solonarv> Cale: my answer here is "why are you using StateT IO, that's just silly - use an IORef/MVar or similar"
01:25:38 <Cale> Well, it might be some transformer which has meaning otherwise, implemented in terms of StateT
01:26:20 <phadej> then doing async stuff will make you think
01:26:24 <Solonarv> Could be, though I can't actually think of such a transformer
01:26:24 <phadej> in both  cases
01:27:03 <phadej> IORef and async (and cancellation): problems; async + StateT different side of the same problem
01:27:29 <Solonarv> STM is one possible solution too
01:27:48 <phadej> it's not a solution to cancellation
01:27:56 <Solonarv> indeed, it isn't
01:27:56 <phadej> if you have multiple writes
01:27:57 <Cale> Or, even in the case of ReaderT, it's not *always* clear that you want to reuse the same environment for your asynchronous computations.
01:28:42 <absence> is anyone using stack with travis-ci? when caching builds, and bumping the ghc version and what not over time, will the cache end up containing multiple ghc versions and dependencies built with each of them? is there an upper bound? can't find anything about it in the stack docs
01:28:44 <Solonarv> although you can give them a different env using 'local', so I'm not sure if that's a big problem
01:28:46 <Cale> I just like to actually have the convention you're using written out somewhere.
01:29:17 <Cale> Using MonadTransControl etc. seem like asking for trouble, and they don't really buy you all that much
01:29:23 <phadej> I actually don't remember how async + resourcet behaves
01:29:38 <phadej> I guess it works, but I don't remember what are the guarantees etc.
01:29:46 <Solonarv> phadej: it uses ref-counting IIRC
01:30:05 <Solonarv> you might need to use a special fork to make it work properly
01:30:15 <mpickering> aren't these arguments why you should use a library rather than roll your own solution
01:30:36 <Solonarv> if the library has clear semantics (as is the case for unliftio), sure
01:30:53 <Solonarv> the semantics of unliftio are: all instances are ReaderT-like, and environments are shared
01:32:24 <Cale> mpickering: Well, the thing is, such specialised generalisations don't really exist.
01:32:34 <phadej> semantics of MonadTransControl aren't that complicated either, it witnesses t m a ~ m (StT m a) "isomorphism"
01:32:37 <Cale> mpickering: But yeah, maybe ideally.
01:36:39 <Cale> mpickering: Well, I shouldn't say they don't exist at all -- some of them do
01:37:35 <Cale> For example, we have MonadError, which has a catchError method
02:44:25 <mpickering> UnliftIO isn;t going to work with a free monad is it
02:44:34 <mpickering> but I suspect that MonadBaseControl would
02:44:38 <mpickering> and would also be safe
02:44:47 <mpickering> the free monad is very simpe
02:54:43 <hololeap> what do free monads have to do with UnliftIO?
02:55:25 <mpickering> hololeap: What do you mean? It's a data type you might want to write an instance for
02:58:09 <Solonarv> MonadUnliftIO has a MonadIO superclass, and I'm unsure how you could write a MonadIO instance for a free monad
02:58:11 <dminuoso> mpickering: Do you mean free monad transformer?
02:58:16 <Solonarv> (unless it's FreeT, I suppose)
02:58:22 <mpickering> yes it's FreeT
02:58:39 <mpickering> however I am just reworking the application to remove it now as it's overly complicated
02:59:11 <Solonarv> :D
02:59:41 <dminuoso> mpickering: To answer your question: Yeah you cant, MonadUnliftIO only works for IO, Identity and ReaderT (and all things isomorphic to those)
03:00:03 <dminuoso> And even more to the point: those transformers must have IO at their bottom.
03:00:11 <dminuoso> (Obviously..)
03:01:30 <hololeap> there's `instance (Functor f, MonadIO m) => MonadIO (FreeT f m)`
03:02:19 <hololeap> some functions in unliftio only constrain the monad to MonadIO
03:03:55 <mpickering> not the ones I want to use
03:04:19 <mpickering> the free monad is only `data D a  = D X (Y -> a); type F = FreeT D IO`
03:37:17 * hackage strelka 2.0.4 - A simple, flexible and composable web-router  https://hackage.haskell.org/package/strelka-2.0.4 (NikitaVolkov)
04:02:09 <Minijinski> Hello guys got a question about assignment : I got something like that: https://paste.ofcode.org/drPhGQRPXx5jbHeJK6nYrw and I want to assign the "centroid" value to "res" at the position "pos" is there a way to do it ?
04:04:23 <dminuoso> % :t splitAt
04:04:23 <yahb> dminuoso: ; <interactive>:1:1: error:; Ambiguous occurrence `splitAt'; It could refer to either `Data.List.NonEmpty.splitAt', imported from `Data.List.NonEmpty'; or `Prelude.splitAt', imported from `Prelude' (and originally defined in `GHC.List')
04:04:26 <dminuoso> % :t Prelude.splitAt
04:04:26 <yahb> dminuoso: Int -> [a] -> ([a], [a])
04:04:30 <dminuoso> Minijinski: ^-
04:06:25 <dminuoso> Minijinski: Lists in Haskell are immutable, so this technique constructs a new list in the process. If you want a mutable version, you have to use a mutable vector or similar.
04:07:37 <Minijinski> So it's not possible to create another list as of copy of the previous one and add a new value in it ? 
04:07:58 <Minijinski> So it's not possible to create another list as a* copy of the previous one and add a new value in it ? 
04:08:06 <dminuoso> Minijinski: Well that construction is that.
04:08:20 <dminuoso> Sort of.
04:09:31 <ski> you could right a direct recursive loop, counting down the index
04:09:32 <dminuoso> % let (l, r) = Prelude.splitAt 3 "foobar" in l ++ "x" ++ r
04:09:32 <yahb> dminuoso: "fooxbar"
04:09:42 <ski> s/right a/write a/
04:09:59 <dminuoso> Minijinski: This is how I would do it.
04:10:14 <dminuoso> (Some additional pattern matching if you want to replace a value)
04:12:40 <dminuoso> Minijinski: Or perhaps just use a vector instead if you need to mutate much. :)
04:12:49 <dminuoso> Or if the lists are big.
04:14:20 <Minijinski> mmh i'll search how to do it with vectors, I'm still a beginner in haskell tho
04:14:39 <ski> or array
04:14:59 <ski> what do you want to do with the previous value at position `pos' ?
04:15:07 <ski> Minijinski ^
04:16:10 <Minijinski> Well, I got 2 lists at the beginning and I want to get a value from the 1st list to put it on the second one at the "pos" position 
04:16:17 <Minijinski> And the second list is empty
04:17:44 <dminuoso> Minijinski: lists in haskell are very different from what you may be used to.
04:19:08 <Minijinski> Yup I see that now 
04:20:09 <dycan> hi all.   Is it possible to get type name at type-level?  something like TypeEqual (TypeOf Int) "Int"
04:20:28 <Solonarv|phone> dycan: no
04:20:42 <Solonarv|phone> But if you want to
04:20:59 <dycan> Solonarvlphone: I see. Any alternative way?
04:21:00 <Solonarv|phone> ...check types for equality, you can just do that directly
04:21:35 <Solonarv|phone> % import Data.Type.Bool
04:21:35 <yahb> Solonarv|phone: 
04:21:42 <dycan> I want to get type name and create a database schema at type-level.
04:22:28 <dycan> so I don't need to assign db name for a type.
04:22:33 <Solonarv|phone> You might be able to get a name for *some* types using the Generic machinery
04:23:10 <Solonarv|phone> But consider: do you really want database columns named "Int"? What if there are multiple Ints?
04:23:19 <dycan> I see. I know there is Typeable. But it gets name at value-level/
04:23:56 <Solonarv|phone> No, it doesn't get you names - it can get you a string representation
04:24:17 <dycan> hmm... I didn't think of that.  I am just being lazy and not want to assign name myself. haha.
04:24:34 <Solonarv|phone> Well, stop being lazy :>
04:24:40 <dycan> that's what I want in type-level, a Symbol that is a string representation of a type.
04:24:44 <Solonarv|phone> Or just use an existing library!
04:25:07 <dycan> Okay, Thank you for clarifying this, Solonarvlphone!
04:25:27 <Solonarv|phone> There are already libraries that generate a DB schema and query functions based on a data type definition
04:25:37 <dycan> I haven't seen something like typeable in type-level.
04:26:02 <dycan> I see. Then I can look how they do it. Thanks!
04:26:07 <Solonarv|phone> Well, the only thing Typeable does is transfer type information at the value level
04:26:29 <Solonarv|phone> If you're working at the type level then the type info is already available!
04:26:51 <maerwald> so the opposite of DataKinds?
04:27:43 <Solonarv|phone> DataKinds doesn't make value-level info available at the type level, it just adds more types to work with
04:29:22 <dycan> hmm...project-m36-typed use a type family AppRecordName a...I can custom db name when instance AppRecordMeta a...But I want it auto-generate to type name itself.
04:29:24 <Solonarv|phone> dycan: if you're not dead set on generating column names from a field's *type*, you can require the data type to be defined using record syntax and use the field names for column names
04:29:52 <Solonarv|phone> You can do this using GHC's Generic machinery pretty easily
04:32:03 <Solonarv|phone> With a recent GHC and the right definitions, you could then write something like the following:
04:33:09 <dycan> Solonarvlohne: Thanks.  I guess I am looking a way to have a default Symbol generated from type name or Custom Symbol when instance.  AFAIK, Generic get info in value-level.
04:34:04 <Solonarv|phone> data Person = Person { personName :: String, personAddress :: Address } deriving DBSchema via GenericDBSchema '[StripFieldPrefix "person"] Person
04:34:37 <Solonarv|phone> No, Generic gives you info at the type level. Behold:
04:35:05 <Solonarv|phone> % [13:33] (Solonarv|phone) data Person = Person { personName :: String, personAddress :: Address } deriving Generic
04:35:05 <yahb> Solonarv|phone: ; <interactive>:168:19: error: parse error on input `phone'
04:35:28 <Solonarv|phone> % data Person = Person { personName :: String, personAddress :: Address } deriving Generic
04:35:28 <yahb> Solonarv|phone: ; <interactive>:169:63: error: Not in scope: type constructor or class `Address'; <interactive>:169:82: error: Not in scope: type constructor or class `Generic'
04:35:33 <Solonarv|phone> Augh
04:35:46 <Solonarv|phone> I really shouldn't do this on my phone
04:36:04 <Solonarv|phone> dycan: I'll be back in about half an hour
04:36:41 <dycan> Solonarvvphone Thanks. I have enough to ponder with. Let me think about this code.
04:42:51 <hololeap> i don't know if it's useful, but i think i figured out an instance for `MonadUnliftIO (CofreeT f m)`: http://dpaste.com/1MW9M80
04:51:43 <dycan> I see now. Generic can get metadata. That's a type-level Symbol of the datatype name. So maybe I can take use of that. Thanks!
05:07:17 * hackage strelka 2.0.5 - A simple, flexible and composable web-router  https://hackage.haskell.org/package/strelka-2.0.5 (NikitaVolkov)
05:07:26 <Solonarv> dycan: still there?
05:07:57 <Solonarv> % newtype Address = Address String deriving (Eq, Show)
05:07:58 <yahb> Solonarv: 
05:08:24 <royal_screwup21> in the context of parser combinators, I'm looking at this defintion: satisfy :: (Char -> Bool) -> Parser Char http://dev.stephendiehl.com/fun/002_parsers.html I understand what it's supposed to be doing , but I don't see how the bind factors into it -- could  someone give me a pointer or two? :)
05:08:42 <Solonarv> % data Person = Person { personName :: String, personAddress :: Address } deriving Generic
05:08:42 <yahb> Solonarv: ; <interactive>:171:82: error: Not in scope: type constructor or class `Generic'
05:08:57 <dycan> stll here.
05:08:58 <dminuoso> royal_screwup21: What should satisfy do, operationally?
05:09:09 <Solonarv> % data Person = Person { personName :: String, personAddress :: Address } deriving Generic
05:09:09 <yahb> Solonarv: ; <interactive>:173:82: error:; * Can't make a derived instance of `Generic Person': You need DeriveGeneric to derive an instance for this class; * In the data declaration for `Person'
05:09:10 <dminuoso> royal_screwup21: (This is a rhetorical question, obviously. I want you to think about it)
05:09:24 <Solonarv> % data Person = Person { personName :: String, personAddress :: Address } deriving Generic
05:09:24 <yahb> Solonarv: 
05:09:30 <Solonarv> ah, third time's the charm
05:09:39 <Solonarv> % :kind! Rep Person
05:09:39 <yahb> Solonarv: Rep Person :: * -> *; = D1 ('MetaData "Person" "Ghci81" "interactive" 'False) (C1 ('MetaCons "Person" 'PrefixI 'True) (S1 ('MetaSel ('Just "personName") 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy) (Rec0 String) :*: S1 ('MetaSel ('Just "personAddress") 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy) (Rec0 Address)))
05:10:19 <royal_screwup21> dminuoso take a function that checks if a given input is a char, and then create a parser out of that 
05:10:22 <Solonarv> dycan: as you can see, all the info is in this type: type name, constructor name, as well as the names & types of the constructor's fields
05:10:33 <dminuoso> royal_screwup21: Explain what the parser should do, operationally.
05:10:34 <Solonarv> (Rep is part of the Generic machinery)
05:11:30 <dycan> Solonarv: I see. Thank you very much! I'll look into this.
05:11:55 <royal_screwup21> check if a given a input, a,  is a char. If it is, return [(a, unconsumed_string)]. Otherwise return an empty list
05:12:11 <dminuoso> royal_screwup21: That's internal details.
05:13:13 <dminuoso> royal_screwup21: At this point you need to *stop* thinking about the internals.
05:13:16 <dminuoso> Dont construct parsers anymore.
05:13:28 <dminuoso> Use combinators to combine your existing toolset.
05:13:56 <dminuoso> royal_screwup21: Operationally it should: parse a single character and test whether the resulting character it satisfies the predicate. if it does, produce it as a result, if it does not then fail
05:14:59 <dminuoso> royal_screwup21: the =<< operator gives you the ability to "tap into the result of a previous action". You just need that "previous action" first.
05:15:27 <royal_screwup21> ah okay...it's like streams in java
05:16:49 <Solonarv> only very vaguely, in the sense that Stream is also a monad
05:22:23 <dminuoso> royal_screwup21: If you implement Alternative/MonadPlus you can then use `mzero/empty` to refer to a failed parse.
05:24:33 <royal_screwup21> hmm
05:24:41 <royal_screwup21> I'm looking at the definition satisfy p = item `bind` \c ->  if p c  then unit c  else (Parser (\cs -> []))
05:25:02 <royal_screwup21> is the "c" there referring to the output from item?
05:29:22 <dminuoso> A perhaps more concise definition might be: satisfy p = item >>= guard p
05:30:00 <royal_screwup21> % Just 3 >>= (\x -> Just (x+1))
05:30:00 <yahb> royal_screwup21: Just 4
05:30:09 <royal_screwup21> hmm I'm sort of seeing the structure to it...
05:30:31 <dminuoso> royal_screwup21: It's the same as: do { c <- item; if p c then unit c else mzero }
05:30:36 <dminuoso> Just in desugared form
05:31:56 <royal_screwup21> hmm
05:32:08 <royal_screwup21> the types are confusing me tbh...
05:32:28 <royal_screwup21> Item :: Parser Char
05:33:21 <royal_screwup21> is the type of "c" Char?
05:33:46 <opqdonut> :t "c"
05:33:47 <lambdabot> [Char]
05:33:52 <opqdonut> aka String
05:33:58 <opqdonut> :t 'c'
05:33:59 <lambdabot> Char
05:34:02 <opqdonut> that's just a Char
05:34:07 <royal_screwup21> no I  meant the c  in here:  do { c <- item; if p c then unit c else mzero }
05:36:32 <opqdonut> well in general in do-notation `a <- foo`, if foo has type `m X`, `a` has type `X`
05:36:40 <opqdonut> (here `m` is the monad in question)
05:36:49 <royal_screwup21> ah ok
05:37:08 <opqdonut> sorry I didn't read the context so I don't know what item is here :)
05:41:06 <haskellNewbie> Hi there
05:43:26 <haskellNewbie> I try to learn haskell with LYAH and I'm on the part "module" but I'm not sure to really understand the type of on
05:43:56 <haskellNewbie> on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
05:45:16 <haskellNewbie> We have apparently two function with this. But How can we define the domain of each function ?
05:45:33 <__monty__> on :: (function that takes b's) -> (function that turns a's into b's) -> (function that takes a's, turns them into b's and applies the first function to those)
05:45:45 <haskellNewbie> two functions, sorry, I'm french.
05:46:29 <haskellNewbie> Thanks _monty_, I try to understand your response ! :-)
05:49:56 <haskellNewbie> (function that takes b's) it takes one argument and return a function from b to c ?
05:50:23 <haskellNewbie> because its right associative
05:50:37 <haskellNewbie> because it's right associative
05:52:19 <royal_screwup21> can someone give me an example of how chainl is supposed to work?
05:56:45 <yushyin> haskellNewbie: yes, that's true for a function with a type (b -> b -> c). in the case of `on' you usally apply a function of that type (b -> b -> c) and you get a function of the type (a -> b) -> a -> a -> c
05:57:19 <__monty__> haskellNewbie: Yes, (b -> (b -> c)), is a function that returns a function that takes another b. With some handwaving we can sweep the currying under the rug and say the original function "takes 2 b's."
06:00:15 <yaxu> Hi all, I'm trying to get my head around monad transformers. I know ghci puts you in the IO monad, is it possible to wrap that in a statet monad, so I can interactively work with state in the repl?
06:00:16 * ski . o O ( `Church : State :: Curry : ???' )
06:00:50 <Solonarv> yaxu: I don't think there's an easy way to change the monad GHCi uses from IO to something else
06:01:06 <Solonarv> but you can use IORef to keep state, if you want
06:01:20 <Solonarv> % myState <- newIORef 0
06:01:20 <yahb> Solonarv: 
06:01:31 <Solonarv> % writeIORef myState 42
06:01:31 <yahb> Solonarv: 
06:01:37 <Solonarv> % readIORef myState
06:01:37 <yahb> Solonarv: 42
06:01:51 <haskellNewbie> Thank you Yushyin, that makes sense like this! We have to take all the arrow on the right order. :-)
06:01:58 <Cale> If you just want to play with StateT, the thing to do is to use runStateT explicitly
06:04:16 <yaxu_> @Cale: but then I suppose I can't run the statements in that in a lazy REPL manner
06:04:17 <lambdabot> Unknown command, try @list
06:04:48 <yaxu_> oops sorry lambdabot 
06:05:10 <royal_screwup21> I'm looking at example of chainl1 here : `parse (chainl1 number ((+) ⟨$ token "+")) "4 + 5 + 6" = [((4 + 5) + 6, "")]` 
06:05:27 <royal_screwup21> `chainl1 :: Parser a → Parser (a → a → a) → Parser a`
06:05:29 <yaxu_> Solonarv: I'd like to be able to read state without doing IO
06:07:04 <Solonarv> % stateEnv initialState = newMVar initialState
06:07:04 <yahb> Solonarv: 
06:07:12 <Cale> yaxu_: Yeah, you'll have to provide a complete StateT action to it.
06:07:25 <royal_screwup21> not totally sure I see how the signature of chainl1 is satisifed in the example..
06:07:55 <Solonarv> % runStateIO env st = do s <- takeMVar env; (a, s') <- runStateT st s; a <$ putMVar env s'
06:07:55 <yahb> Solonarv: 
06:08:07 <Cale> yaxu_: Of course, when you write your program, you'll end up doing the same thing anyway. It might actually be easier to define the action you're running in a file regardless.
06:08:26 <Solonarv> with those two definitions you can create a "state environment" and run individual StateT actions one by one
06:08:32 <Solonarv> (in ghci)
06:08:45 <Solonarv> % myEnv <- stateEnv 42
06:08:45 <yahb> Solonarv: 
06:08:52 <yaxu_> Solonarv: interesting, I'll meditate on this, thanks
06:09:06 <Cale> .oO(Why an MVar?)
06:09:08 <Solonarv> % runStateIO myEnv $ modify (+3)
06:09:08 <yahb> Solonarv: 
06:09:33 <Solonarv> % runStateIO myEnv $ get >>= liftIO . print
06:09:33 <yahb> Solonarv: ; <interactive>:185:20: error:; Ambiguous occurrence `get'; It could refer to either `Text.Read.get', imported from `Text.Read' (and originally defined in `Text.ParserCombinators.ReadPrec'); or `Control.Monad.RWS.get', imported from `Control.Monad.RWS' (and originally defined in `Control.Monad.State.Class')
06:09:44 <Solonarv> % runStateIO myEnv $ Control.Monad.State.get >>= liftIO . print
06:09:44 <yahb> Solonarv: 45
06:10:10 <Solonarv> Cale: because I like how it lets me say "take out the state, do something with it, then put it back"
06:10:14 <Solonarv> doesn't really matter in this case
06:12:29 <Solonarv> I suppose this approach is less likely to backfire if unwisely copied into something that isn't GHCi
06:12:47 * hackage ghc-boot-th 8.6.5 - Shared functionality between GHC and the `template-haskell`library  https://hackage.haskell.org/package/ghc-boot-th-8.6.5 (HerbertValerioRiedel)
06:13:00 <Solonarv> (could make it even safer by adding `onException` putMVar env s)
06:13:47 * hackage ghc-boot 8.6.5 - Shared functionality between GHC and its boot libraries  https://hackage.haskell.org/package/ghc-boot-8.6.5 (HerbertValerioRiedel)
06:14:47 * hackage ghci 8.6.5 - The library supporting GHC's interactive interpreter  https://hackage.haskell.org/package/ghci-8.6.5 (HerbertValerioRiedel)
06:15:08 <Cale> Solonarv: Would be safer to use withMVar
06:15:25 <Solonarv> ah yeah, that'd handle the onException bit too
06:15:39 <Solonarv> I forgot about it!
06:16:17 * hackage ghc 8.6.5 - The GHC API  https://hackage.haskell.org/package/ghc-8.6.5 (HerbertValerioRiedel)
06:17:28 <Cale> But you could also use atomicModifyIORef ;)
06:25:40 <Solonarv> no, I could not
06:25:46 <Solonarv> % :t atomicModifyIORef
06:25:46 <yahb> Solonarv: IORef a -> (a -> (a, b)) -> IO b
06:25:55 <Solonarv> -- ^ can't do IO
06:26:09 <Solonarv> % :t withMVar
06:26:09 <yahb> Solonarv: MVar a -> (a -> IO b) -> IO b
06:26:20 <Solonarv> hm, actually that doesn't work either
06:26:43 <Solonarv> can't update the MVar with the new state
06:28:04 <Solonarv> unless it uses tryPutMVar to put the value back, but that isn't the case
07:04:11 <nakkle> Hi! I have the following code: https://pastebin.com/My1VvfYP which gives an error `Couldn't match expected type ‘a’ with actual type ‘[Char]’`. I believe I understand why that error happens, but I still wonder whether it's possible for a function f to accept a polymorphic function g and apply g to multiple, differently typed items. Any tips what I need to do here?
07:04:37 <dminuoso> nakkle: Hi! Indeed this is possible.
07:04:49 <dminuoso> nakkle: You need to squeeze a forall in there and enable RankNTypes
07:05:00 <dminuoso> foo :: (forall a. a -> IO ()) -> IO ()
07:05:35 <dminuoso> And that's all what RankNTypes are about. :-)
07:06:41 <nakkle> Awesome, thanks! I believe I tried that before and ran into `No instance for (Show a) arising from a use of ‘print’`. Gotta look into that. Thanks for your help! 
07:07:09 <Cale> nakkle: You might rather want foo :: (forall a. Show a => a -> IO ()) -> IO ()
07:08:12 <nakkle> Aah, right. I believe I tried just (Show a => a -> IO ()) -> IO (), and backtracked from there. Thank you guys :)
07:09:01 <dminuoso> nakkle: Note that the forall quantification is implied if you dont specify it.
07:09:43 <Cale> Not in this case.
07:09:47 <dminuoso> nakkle: GHC will always move the quantification all the way to the left unless you either explicitly put it somewhere, or it's implied by Context.
07:09:53 <Cale> ah, well yes :)
07:10:34 <nakkle> So this is the implicit quantification? foo :: forall a. (Show a => a -> IO ()) -> IO ()
07:10:39 <Cale> yeah
07:10:42 <dminuoso> No!
07:10:58 <dminuoso> Gotta run, getting off the train
07:11:01 <Cale> which is the same as if you had the Show a => on the outside
07:11:09 <dminuoso> Cale: No its not, look closer
07:11:21 <Cale> hm?
07:16:45 <nakkle> dminuoso: So what would be the implicit quantification then? I only see two places where the `forall a.` can go, so if the default quantification is wrong, that mus be `foo :: forall a. (Show a => a -> IO ()) -> IO ()`, right?
07:17:21 <Cale> If you wrote it with the Show a in that place, then that would indeed be the implicit quantification.
07:17:33 <Cale> I'm not sure what dminuoso had a problem with
07:17:39 <solrize> @pl \s1 -> not . (f s1)
07:17:39 <lambdabot> (not .) . f
07:18:40 <Cale> I was wrong about it being equivalent to the case where the Show a is outside though
07:18:50 <Cale> Having the Show a in there is pretty hard to satisfy
07:19:19 <Cale> because you were allowed to pick an unconstrained a, and then in order to apply the function given, you suddenly need to know there's an instance of Show for a
07:20:28 <Cale> Maybe if there was a GADT hanging around with more information we could potentially discover about a, we could manage something like that
07:25:08 <fen> having a type parameter like a "base functor" defining classes like Foldable and Get for various shaped things means it could be used also to parametrise a zipper class. however, having this parameter extended to the nested case then means there are not just forward and backward directions to navigate, but also up and down and maybe even more orthogonal directions for higher order versions, maybe this is the correct candidate for a param
07:26:21 <dminuoso> Cale: foo :: forall a. (Show a => a -> IO ()) -> IO () !~ (forall a. Show a => a -> IO ()) -> IO ()
07:26:46 <Solonarv> oh, of course
07:28:28 <dminuoso> nakkle: https://gist.github.com/dminuoso/0e2b6b5cc1117b367cfa51c12ebf100f
07:29:01 <dminuoso> foo :: forall a. (Show a => a -> IO ()) -> IO () is actually something else, it's equivalent to:  foo :: forall q. (forall a. Show a => a -> IO ()) -> IO ()
07:29:08 <dminuoso> Where the outer quantification leads to an ambiguous type
07:29:26 <fen> so then, if the parameter - which when is the nested version, is just made up of the nestings of the varios linear versions, Zipper seems appropriate for these, and Pointer for the nested version... 
07:30:07 <solrize> https://medium.com/@reinman/monoids-to-groupoids-492c35105113  is this article total gibberish ?
07:30:10 <solrize> buzzword bingo
07:30:18 <solrize> enterprise functors
07:30:49 <fen> solrize: its some kind of members only page?
07:32:40 <fen> its asking me to sign in...
07:33:23 <Cale> dminuoso: Of course, the question was whether  (Show a => a -> IO ()) -> IO ()  was the same as  forall a. (Show a => a -> IO ()) -> IO ()
07:33:26 <tabaqui> fen: dunno, I can read it without issues
07:33:34 <Cale> dminuoso: and it is :)
07:33:35 <tabaqui> do you have ublock enabled?
07:33:44 <dminuoso> Cale: Wait. What? 
07:33:47 <tabaqui> Technically, monads are instances of special ‘containers’ called monoids (sets) that manage the above activities — but don’t ask the Haskell gurus because they will violently disagree and spew out all sorts of circular definitions. If that isn’t a major red flag for avoiding Haskell, I don’t know what is (which is unfortunate).
07:33:51 <tabaqui> Haha
07:34:02 <dminuoso> Cale: My mind model is broken then. I could have sworn this was two universal quantifications there.
07:34:32 <dminuoso> % foo :: forall q. (Show a => a -> IO ()) -> IO (); foo = undefined
07:34:32 <yahb> dminuoso: ; <interactive>:189:24: error: Not in scope: type variable `a'; <interactive>:189:29: error: Not in scope: type variable `a'
07:34:36 <dminuoso> Huh
07:34:54 <Cale> solrize: Yes, it's... word salad
07:34:59 <solrize> heh
07:35:02 <dminuoso> % foo :: forall a. (Show a => a -> IO ()) -> IO (); foo = undefined
07:35:03 <yahb> dminuoso: 
07:35:05 <dminuoso> % :t foo
07:35:05 <yahb> dminuoso: (Show a => a -> IO ()) -> IO ()
07:35:06 <solrize> thanks cale
07:35:35 <dminuoso> Cale: I apologize then. Im still baffled about this, it looks so wrong.
07:35:38 <Solonarv> % :set -fprint-explicit-foralls
07:35:38 <yahb> Solonarv: 
07:35:40 <Solonarv> % :t foo
07:35:41 <yahb> Solonarv: forall {a}. (Show a => a -> IO ()) -> IO ()
07:36:01 <dminuoso> % bar :: (forall a. Show a => a -> IO ()) -> IO (); bar = undefined
07:36:01 <yahb> dminuoso: ; <interactive>:194:57: error:; * Cannot instantiate unification variable `a0'; with a type involving foralls: (forall a. Show a => a -> IO ()) -> IO (); GHC doesn't yet support impredicative polymorphism; * In the expression: undefined; In an equation for `bar': bar = undefined
07:36:12 <dminuoso> Okay now Im completely lost.
07:36:28 <dminuoso> What is the difference here?
07:36:31 <Solonarv> something something monomorphism restriction?
07:36:52 <dminuoso> Solonarv: Explicit type annotation and no non-simple pattern matching, so MMR does not apply
07:36:57 <Solonarv> % bar :: (forall a. Show a => a -> IO ()) -> IO (); bar g = g 43 >> g "hello"
07:36:58 <yahb> Solonarv: 
07:37:05 <dminuoso> Woah.
07:37:08 <Solonarv> Huh
07:37:21 <Solonarv> guess the 'undefined' and point-free made it barf
07:37:33 <Solonarv> % bar :: (forall a. Show a => a -> IO ()) -> IO (); bar g = undefined
07:37:33 <yahb> Solonarv: 
07:37:36 <Solonarv> yup!
07:37:40 <dminuoso> Solonarv: Oh. I should have read the diagnostic more carefully..
07:37:57 <dminuoso> Okay now I have no idea what the difference between the two is.
07:38:18 <Solonarv> % bar :: forall a. (Show a => a -> IO ()) -> IO (); bar g = g 43 >> g "hello"
07:38:19 <yahb> Solonarv: ; <interactive>:197:69: error:; * Couldn't match expected type `a' with actual type `[Char]'; `a' is a rigid type variable bound by; the type signature for:; bar :: forall a. (Show a => a -> IO ()) -> IO (); at <interactive>:197:1-48; * In the first argument of `g', namely `"hello"'; In the second argument of `(>>)', namely `g "hello"'; In the expression:
07:39:16 <Solonarv> I'm not entirely sure about the difference between 'forall a. (Show a => a -> IO ()) -> IO ()' and 'forall a. Show a => (a -> IO ()) -> IO ()',tbh
07:39:22 <fen> % bar :: (Show a => a -> IO ()) -> IO (); bar g = g 43 >> g "hello"
07:39:22 <yahb> fen: ; <interactive>:198:59: error:; * Couldn't match expected type `a' with actual type `[Char]'; `a' is a rigid type variable bound by; the type signature for:; bar :: forall a. (Show a => a -> IO ()) -> IO (); at <interactive>:198:1-38; * In the first argument of `g', namely `"hello"'; In the second argument of `(>>)', namely `g "hello"'; In the expression:
07:39:31 <Solonarv> I mean they're clearly not the same, but beyond that I don't know
07:39:34 <tabaqui> no difference
07:39:39 <fen> how does it not know to put the forall in the brackets?
07:39:44 <tabaqui> if you push forall inside the braces...
07:39:56 <dminuoso> What does it even mean if the forall is outside the brackets, but the Show a context is not?
07:39:59 <tabaqui> *brackets
07:40:20 <dminuoso> Or differently, are these three all different from another? https://gist.github.com/dminuoso/d624adb8d1eb36d6d7b66bc4db74e79b
07:40:28 <Cale> Solonarv: forall a. (Show a => a -> IO ()) -> IO ()  means that while you're allowed to apply this function at any type a, it guarantees that it won't apply the function that you give it except when a has a Show instance.
07:40:30 <tabaqui> I'm not sure that you can place forall inside, while constraints outside
07:40:30 <Solonarv> fen: GHC will *never* infer a higher-rank type
07:40:40 <Solonarv> Cale: ah, that makes a ton of sense
07:40:59 <Solonarv> tabaqui: indeed you can't, since the constraints would mention a type variable that isn't in scope
07:40:59 <Cale> Solonarv: It's pretty hard to actually write something like that, unless you had a GADT hanging around that would give you more information about the type a
07:41:23 <Cale> Or a Typeable instance or something.
07:41:30 <Taneb> (aside from boring things like const someIOAction)
07:41:44 <fen> % bar :: Show a => (Show a => a -> IO ()) -> IO (); bar g = g 43 >> g "hello"
07:41:44 <yahb> fen: ; <interactive>:199:69: error:; * Couldn't match expected type `a' with actual type `[Char]'; `a' is a rigid type variable bound by; the type signature for:; bar :: forall a. Show a => (Show a => a -> IO ()) -> IO (); at <interactive>:199:1-48; * In the first argument of `g', namely `"hello"'; In the second argument of `(>>)', namely `g "hello"'; In the e
07:41:58 <fen> :-(
07:42:20 <Solonarv> fen: in other words, GHC will *never* put a forall inside parentheses
07:42:31 <Solonarv> if you want that you must write it explicitly
07:42:54 <dminuoso> Cale: So the obligation to prove an instance exists can be detached from the /\ quantification?
07:43:31 <dminuoso> % data F = F
07:43:31 <yahb> dminuoso: 
07:43:37 <fen> but that version wouldnt need the forall in the braces because its constrained already...
07:43:38 <dminuoso> % :t bar @F
07:43:38 <yahb> dminuoso: ; <interactive>:1:1: error:; * Cannot apply expression of type `(forall a. Show a => a -> IO ()) -> IO ()'; to a visible type argument `F'; * In the expression: bar @F
07:44:05 <Solonarv> Rank-2 type inference is doable - I think this is why we used to have a Rank2Types extension separate from RankNTypes - but higher-rank type inference is out
07:44:11 <Cale> yeah, have a look at has and whichever from here: http://hackage.haskell.org/package/constraints-extras-0.2.3.4/docs/Data-Constraint-Extras.html
07:44:20 <dminuoso> % bar :: forall (Show a => a -> IO ()) -> IO (); bar g = let q = g @F in g 43 >> g "hello"
07:44:20 <yahb> dminuoso: ; <interactive>:202:16: error: parse error on input `Show'
07:44:21 <Cale> has :: forall c f a r. Has c f => f a -> (c a => r) -> r 
07:44:27 <dminuoso> % bar :: forall a. (Show a => a -> IO ()) -> IO (); bar g = let q = g @F in g 43 >> g "hello"
07:44:28 <yahb> dminuoso: ; <interactive>:203:67: error:; * Cannot apply expression of type `a -> IO ()'; to a visible type argument `F'; * In the expression: g @F; In an equation for `q': q = g @F; In the expression: let q = g @F in g 43 >> g "hello"; <interactive>:203:85: error:; * Couldn't match expected type `a' with actual type `[Char]'; `a' is a rigid type variable bound by; the typ
07:45:32 <Cale> Has c f means basically that this function makes sense -- that given a value of type f a, we can get an instance c a
07:46:32 <Cale> For example, you might know that your GADT f has only finitely many possibilities for its index type, and they all have instances of ToJSON, and so you could write the constraint  Has ToJSON f
07:46:59 <Cale> and then this would give you access to the appropriate ToJSON instance
07:47:21 <dminuoso> I just stepped into a dark deep well of magic.
07:47:40 <Taneb> dminuoso: yeah, it's called "Haskell"
07:48:41 <Cale> I've gotta move all the 'V' stuff out of this package, it belongs in Vessel.
07:49:19 <Cale> https://github.com/obsidiansystems/vessel/blob/develop/src/Data/Vessel.hs#L141 :D
07:49:32 <maerwald> https://hackage.haskell.org/package/errors-2.3.0/docs/Control-Error-Util.html#v:-63--63- so confusing that there is no infix operator for Either e1 a -> (e1 -> e2) -> ExceptT e2 m a
07:49:57 <Cale> Have a look at that, and then think "I've got to write JSON instances for this"
07:50:38 <Cale> https://github.com/obsidiansystems/vessel/blob/develop/src/Data/Vessel.hs#L196 -- they're actually not that bad... once you have the dark magic of constraints-extras
07:51:26 <maerwald> now I see why you need more developers xD
07:51:30 <Cale> But really, constraints-extras' magic isn't that dark -- all it does is give you a handy way to case on all the constructors of a GADT and learn stuff
07:51:31 <dminuoso> Cale: Heh constraints was a fun nut to wrap my head around, Ill have some time with this. :-)
07:51:48 <Cale> maerwald: hm?
07:51:52 <fen> Cale: whats a view?
07:53:03 <maerwald> Cale: well, probably some people gone crazy after reading that, hehe
07:53:18 <Cale> fen: It's part of the architecture we use for web and mobile applications: the frontend will have a dynamically changing "viewselector" or "query" expressing what the user is looking at, and it provides changes to its viewselector to the backend, which then responds with a corresponding "view"
07:53:27 <Cale> (the data that the frontend wants to display)
07:53:28 <fen> maerwald: its certainly not an easy read!
07:53:28 <dminuoso> Cale: Do you have a tip on what to experiment to see the principle of splitting quantification/instance proof obligation in action?
07:53:43 <dminuoso> Cale: Something perhaps less... convoluted than your vessel..
07:54:05 <maerwald> I also like the whichever on line 198
07:54:07 <fen> Cale: it seemed to imply it was something like using a GADT to index over something somehow
07:54:22 <Cale> fen: It's using a GADT for its keys
07:54:35 <fen> ahh, now its all totally obvious
07:54:42 <Cale> fen: and the type index of that GADT says which sort of container is stored at each key
07:54:51 <Cale> all the containers are parameterised by a choice of functor
07:55:00 <Cale> and it just distributes that choice along
07:55:24 <Cale> maerwald: yeah :)
07:55:27 <fen> View is a pretty dense class, is all that machinery nesacary to express what you just said?
07:55:33 <Cale> There's an easier example I really should have pointed at first
07:55:40 <fen> :-D
07:55:56 <Cale> fen: It's what turns out to be necessary to implement the application architecture efficiently
07:56:13 <fen> i dont know what that is :(
07:56:37 <maerwald> "we lost the war against complexity, let's at least make this work correctly" -- haskell
07:56:43 <Cale> fen: We aggregate all the users' queries, so we end up with something like a map from ConnectionIds to queries, and then we're going to listen to changes coming in from the DB
07:56:59 <Cale> so, we want to know which users are interested in any given change
07:57:06 <fen> but the API is more general than this specific application though right?
07:57:12 <Cale> so we need something like a query of... maps from connection ids :)
07:57:28 <Cale> (letting us know which users are interested in each thing)
07:57:47 <Cale> and then once we've computed the change to those users' views, we need to transpose back
07:57:49 <fen> all these terms are application specific 
07:58:08 <Cale> Sure, I mean, this is just a data structure
07:58:16 <fen> like, this seems to be an example use case of a more general form of abstraction
07:58:18 <Cale> But it has a very specific application framework in mind
07:58:21 <solrize> fen re that medium article no i didn't get anything about signing in
07:58:54 <fen> hmm, its just a bit much for a presentation to understand the inner workings of the example application
07:58:57 <Cale> and I don't really have an interest in putting anyone through all this without that application framework :)
07:59:17 <Cale> yeah, let's just look at my instances for DSum and DMap using constraints-extras :)
07:59:22 <solrize> "smart monads"
07:59:27 <fen> well, we wouldnt be able to tell without first understanding that, so we just have to trust you on that
07:59:41 <Cale> https://github.com/obsidiansystems/dependent-sum-aeson-orphans/blob/master/src/Data/Dependent/Sum/Orphans.hs
08:00:20 <Cale> I really linked Vessel half-jokingly, because it's kind of overwhelming, but also, it shows off the power of constraints-extras quite nicely
08:00:45 <Cale> I don't expect anyone to understand it right at the moment, it's not in use yet.
08:00:46 <fen> yeah but if you dont normally work with JSON or web stuff this is still incomprehensible 
08:01:04 <fen> the idea about GADT parameter keys sounded really cool though
08:01:33 <fen> was constraints-extras supposed to do that?
08:01:48 <Cale> constraints-extras is like constraint-level Pi
08:02:00 <fen> Pi!?
08:02:15 <Cale> It gives you a way to say "given a *value* of type f a, I can deliver an *instance* of c a"
08:02:26 <Cale> Where c is a type class
08:02:42 <Cale> (or some constraint parametrised on a)
08:02:44 <fen> its like some form of resolving and composing constraint continuations or something
08:03:10 <Cale> As soon as you start working with maps keyed on GADTs you end up wanting stuff like this
08:03:17 <fen> just not sure how thats to do with the GADT keys idea
08:03:20 <Cale> e.g. you might want to write a Semigroup instance
08:03:50 <fen> maybe it would be a good place to start by describing what is meant by "maps keyed on GADTs"
08:04:15 <fen> like, a list is a map keyed on Int?
08:04:15 <Cale> and need to know that for every possible key of type f a, the type of the corresponding value in your DMap f g, namely g a, has a Semigroup instance
08:04:46 <Cale> Well, let's start with DSum then
08:05:05 <Cale> data DSum f g where
08:05:14 <Cale>   (:=>) :: f a -> g a -> DSum f g
08:05:48 <Cale> Imagine that f is a GADT such that by pattern matching on a value of type f a, we can rediscover which type a was.
08:06:07 <fen> like a singletons somehow?
08:06:17 <Cale> kinda, yeah
08:06:22 <fen> one datatype constructor per inhabitant of `a'
08:06:32 <Cale> Somehow we never ever get into using singletons
08:06:47 <Cale> It turns out to be more practical to have GADTs indexed by more ordinary types
08:06:49 <fen> but thats the same idea right?
08:06:52 <Cale> similar
08:07:01 <Cale> You want values of type g a to be nontrivial though
08:07:08 <thuringia> hello, Can someone explain the essential difference between a union in C and a sum type in Haskell?
08:07:21 <Cale> thuringia: A sum type in Haskell tells you which case you have
08:07:55 <benzrf> thuringia: a sum type is like a tagged union
08:08:38 <fen> when you say "rediscover what type `a' was" ... that might have been confusing, singletons would be, what value it was, as a value corresponds to a type for singletons.
08:09:14 <benzrf> haskell does not have non-tagged unions, which is a good thing, because the only time you want a union and you're not tagging it is if you're reinterpreting the representation of a value, but we would like to not have to think about representations
08:10:22 <fen> GADTs indexed by types is still confusin
08:10:58 <thuringia> mh what is a tagged union?
08:10:59 <Solonarv> fen: here is a simple GADT indexed by types:
08:10:59 <Solonarv> data Foo a where
08:10:59 <Solonarv>   FooInt :: Int -> Foo Int
08:10:59 <Solonarv>   FooChar :: Char -> Foo Char
08:11:15 <Cale> yeah, that's a good example
08:11:15 <benzrf> thuringia: oh haha i assumed youd be familiar with them if you knew about unions :V
08:11:28 <fen> that looks like a type family almost
08:11:41 <glguy> benzrf: You might also want a non-tagged union if you were planning on having an external tag. That tag could discriminate more than one union value
08:11:52 <benzrf> glguy: shhh, stop undermining my polemic :)
08:12:05 <fen> word!
08:12:09 <Cale> thuringia: In C, if you have a union of a bunch of types, there's nothing built-in to tell you which of the types you unioned together you have.
08:12:10 <benzrf> thuringia: a tagged union is a struct pairing some enum with some union, where the values of the enum correspond to the fields of the union
08:12:26 <benzrf> so that you can keep track of which field you're supposed to be using
08:12:51 <thuringia> the problem is that I can not do anything with the term. in German we just say variant to Union in C and I never used Unionen in C
08:13:30 <Cale> People don't use unions in C very much because they're awkward like that.
08:14:07 <Solonarv> example:
08:14:08 <Solonarv> enum foo_tag { TAG_INT, TAG_CHAR };
08:14:08 <Solonarv> struct foo { enum foo_tag tag, union { int anInt, char aChar } value }
08:14:38 <Cale> In Haskell, when you have a sum type, the language has built-in support for "pattern matching", which determines which part of the disjoint union you're in, and simultaneously allows you to bind variables to the parts.
08:15:43 <Cale> fen: The point of GADTs is that by pattern matching on the data constructors of a GADT, you can recover additional information about their type.
08:15:45 <fen> so you want to be able to pattern match over the parts of `f a' corresponding to different constructors, and somehow end up pattern matching over `g a'?
08:15:53 <Cale> fen: e.g. if we take Solonarv's definition above
08:16:16 <Cale> fen: inside of a case expression that pattern matches like  FooInt n -> ...
08:16:29 <thuringia> mh ok. 
08:16:31 <thuringia> does "tagged" mean that Haskell has a "data constructor" that names the exact part? or have I misunderstood something now?
08:16:42 <Cale> In the ellipsis, even if the thing we're matching on has type Foo a, we'll have learned that a = Int in this case
08:16:55 <Cale> thuringia: Correct
08:17:50 <fen> so the definintion of the GADT, namely the types of its constructors, can be used to restrict the type parameter provided to the GADT
08:18:22 <Cale> yeah
08:18:42 <fen> but what if there are 2 constructors giving the same restricted return type?
08:18:53 <Cale> The data constructors can have more restricted types, and then pattern matching re-discovers that information about the way in which they were restricted.
08:19:05 <Cale> That's fine, you just learn the same thing in each of those two cases
08:19:14 <Cale> I might have something like:
08:19:18 <Cale> data FormField a where
08:19:26 <Cale>   FirstName :: FormField String
08:19:33 <Cale>   LastName :: FormField String
08:19:38 <Cale>   Age :: FormField Integer
08:20:37 <fen> wait hang on, is what your saying that GADTs with constructors returning type restricted datatype values somehow implement something approximating closed data families?
08:20:50 <Cale> uhhh
08:20:58 <Solonarv> no, not really
08:21:09 <Solonarv> well sort of
08:21:13 <fen> !?
08:21:27 <Cale> I... guess? It's hard to think about what a closed data family would be.
08:21:29 <Solonarv> data families don't actually let you discover anything about their type parameter by pattern-matching
08:21:47 <Cale> Don't they?
08:21:53 <Solonarv> instead you can only pattern-match if you already know the type parameter
08:21:54 <fen> its only different to using GADTs to do what regular datatypes can do because of this restricted return type
08:21:57 <Cale> oh, right
08:21:59 <Cale> right
08:22:10 <Solonarv> with GADTs this is exactly backwards
08:22:31 <fen> but thats because they are open?
08:22:36 <Cale> There's no way to write the function which is polymorphic in the choice of data family parameter without writing a type class.
08:22:53 <Solonarv> yup
08:23:19 <Solonarv> this came up a few days ago, and someone pointed out that in a data family there is nowhere to store the equality evidence
08:23:21 <Cale> Consider my FormField type above
08:23:28 <Cale> We could have DSum FormField Identity
08:23:41 <Cale> which would then be a pair of some FormField a, and an Identity a
08:23:57 <Cale> which is basically "a filled in field"
08:24:18 <Solonarv> whereas for a GADT like Foo above we just generate something like:
08:24:18 <Solonarv> data Foo a = FooInt (a :~: Int) Int | FooString (a :~: String) String
08:24:27 <Cale> The value of the first part of the pair tells us about the type of the second part of the pair
08:24:40 <Cale> which is exactly what a dependent sum is about
08:26:54 <fen> :-/
08:27:26 <haskellNewbie> Hi there... 
08:28:00 <fen> all your questions answered! ask away!
08:28:12 <Solonarv> haskellNewbie: indeed, ask away!
08:29:04 <haskellNewbie> When I put -- let xs = [[5,4,5,4,4],[1,2,3],[3,5,4,3],[],[2],[2,2]] --
08:29:29 <haskellNewbie> and --  sortBy (compare `on` length) xs --
08:29:47 <Solonarv> % let xs = [[5,4,5,4,4],[1,2,3],[3,5,4,3],[],[2],[2,2]] -- let's follow along
08:29:47 <yahb> Solonarv: 
08:29:58 <Solonarv> % sortBy (compare `on` length) xs
08:29:58 <yahb> Solonarv: ; <interactive>:205:1: error:; Ambiguous occurrence `sortBy'; It could refer to either `Data.List.NonEmpty.sortBy', imported from `Data.List.NonEmpty'; or `Data.List.sortBy', imported from `Data.List' (and originally defined in `base-4.12.0.0:Data.OldList'); <interactive>:205:22: error:; Ambiguous occurrence `length'; It could refer to either `Data.List.NonEmpty
08:30:10 <Solonarv> blergh, one sec
08:30:15 <haskellNewbie> I have an error on ghci --  <interactive>:39:1: error:     Variable not in scope:       sortBy :: ([a0] -> [a0] -> Ordering) -> [[Integer]] -> t  --
08:30:19 <Cale> haha, way too many things imported unqualified :D
08:30:29 <Cale> haskellNewbie: that one's from Data.List
08:30:47 <fen> :t sortBy
08:30:48 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
08:30:51 <Cale> haskellNewbie: you can add "import Data.List" to your file or type it into ghci
08:30:52 <Solonarv> % sortBy (compare `on` length) xs
08:30:52 <yahb> Solonarv: [[],[2],[2,2],[1,2,3],[3,5,4,3],[5,4,5,4,4]]
08:31:03 <Solonarv> and, yep - need to import it
08:32:00 <haskellNewbie> Thanks, I try this thing on Ghci, now!
08:32:19 <fen> Cale: do you think this DSum idea could help with trying to make a nested state? the version with type families emulating closed classes seemed kinda crazy
08:33:23 <fen> that was here; https://pastebin.com/raw/GTvkhbfc
08:35:01 <Cale> I'm not really sure what you mean by "nested state", but if it has something to do with nesting StateTs, the real answer is really simple: never do that directly. Always newtype your monad transformers into something more meaningful, with operations that have better names than 'get' and 'put'
08:35:12 <haskellNewbie> It works, that way with import Data.List  :-)
08:35:29 <fen> this was supposed to serve as the parameter for parametric Foldable classes etc... where the "nested" version of a Zipper was a "Pointer"
08:35:29 <Cale> and then the problems regarding which operations you're referring to dissolve
08:35:49 <nshepperd_> Nobody can help with what you're trying to do because nobody understands it
08:36:14 <fen> but if I understood it I wouldnt need help!
08:36:52 <Cale> fen: Start with the actual problem you're trying to solve... there's probably something idiomatic already
08:37:16 <fen> ok
08:37:21 <fen> so if we start with this; https://pastebin.com/raw/mDdjGUKL
08:37:51 <fen> then you can see where "Folding" is restricted by this basefunctor-like parameter to give the normal Foldable class
08:41:46 <fen> then we want to generate similar classes with different parameters, and the first paste above has these as either the constructors of Basecase, or the Nested version of these
08:42:12 <fen> the idea being that these capture all possible such "Foldable-like" classes
08:42:34 <fen> so serve to replace the basefunctor assignment of recursion-schemes
08:43:22 <haskellNewbie> Is there a way to know if an import is missing? A tool or something, because ghci don't help very much on this ?
08:44:00 <haskellNewbie> I work with VScode
08:44:08 <zincy_> stack build?
08:44:24 <dminuoso> haskellNewbie: My technique is to quickly tab into a browser and search in hoogle.
08:44:56 <dminuoso> haskellNewbie: That way you get to see whether a given identifier is a) in Prelude and b) if its not, which module you have to import (or package you have to depend on)
08:45:03 <fen> that is, instead of a Recursive or Corecursive instance having its own basefunctor as an associated type, all possible instances instead are instances of some Foldable-like (resp. Unfoldable-like for Corecursive) class, with the parameter as either Stream,Linear or Stack, or some Nesting of these
08:45:46 <fen> then the idea of a DSum might be helpful in making this assignment 
08:45:49 <haskellNewbie> dminuoso: It it works for you, it will probably work for me. Thanks, I'll try that!
08:46:12 <haskellNewbie> dminuoso: If it works for you, it will probably work for me. Thanks, I'll try that!
08:47:57 <dminuoso> haskellNewbie: https://hoogle.haskell.org/ worth a bookmark :)
08:48:07 <tnks> I'm trying to understand async exceptions better.  If a thread has called forkIO and gets killed with a throwTo call, does the child thread carry on?  Or does it die because it's parent has been killed.  If it does carry on, then what's the way to make sure it dies with the parent?  
08:48:30 <tnks> And if it doesn't carry on, then would would be a way to write code such that it does?
08:48:38 <dminuoso> tnks: You can use the `async` package which lets you link threads together
08:48:42 <Solonarv> it carries on
08:49:07 <haskellNewbie> dminuoso: Worth a bookmak, for sure. ;)
08:49:18 <Solonarv> the way to make sure a child dies with the parent is to catch the exception in the parent and kill the child in the exception handler
08:49:36 <dminuoso> The async package handles the boilerplate of doing that for you. :)
08:49:42 <Solonarv> async has functions which can handle this for you
08:49:45 <Solonarv> ninja'd :>
08:49:56 <dminuoso> Heh
08:50:04 <dminuoso> % import Control.Concurrent.Async
08:50:04 <yahb> dminuoso: ; <no location info>: error:; Could not find module `Control.Concurrent.Async'; Perhaps you meant; Control.Concurrent.Chan (from base-4.12.0.0); Control.Concurrent.MVar (from base-4.12.0.0); Control.Concurrent.QSem (from base-4.12.0.0)
08:50:22 <dminuoso> https://hackage.haskell.org/package/async-2.2.1/docs/Control-Concurrent-Async.html#v:withAsync
08:50:52 <fen> finally the observation that these parameters to Folding or Unfolding also serve to parametrise Get and Set varients, then give Zippers for the Basecase parametrised containers, and giving rise to a notion of a "Pointer" for the containers corresponding to Nested parameters
08:51:56 <zincy_> An async exception kills the thread it is thrown in right?
08:52:38 <Solonarv> no, it kills the thread it is thrown *to*
08:52:54 <fen> probably a good first step would be understanding if DSum can indeed serve this purpose and if so, how might the State of the above paste be correspondingly rewritten 
08:53:54 <Solonarv> % reportExc = threadDelay 3000000 `catch` \e -> print (e :: SomeException) >> throwIO e
08:53:54 <yahb> Solonarv: 
08:54:09 <zincy_> Solonarv: So in a single threaded situation all exceptions are thrown to the main thread?
08:54:51 <Solonarv> % do reporter <- forkIO reportExc; threadDelay 1000000; throwTo reporter ThreadKilled
08:54:52 <yahb> Solonarv: thr
08:55:24 <Solonarv> zincy_: yes, if there is only one thread obviously all async exceptions are thrown to that thread - where else could they go?
08:56:00 <zincy_> :)
08:56:30 <zincy_> I never thought of an exception of having to have a target thread
08:56:47 * hackage fused-effects 0.3.1.0 - A fast, flexible, fused effect system.  https://hackage.haskell.org/package/fused-effects-0.3.1.0 (patrick_thomson)
08:56:48 <zincy_> I thought exceptions could only by raised by the thread they are in and thrown to themselves
08:56:59 <Solonarv> that's exactly how async exceptions work: an exception is created and tossed at an unsuspecting thread
08:57:03 <Solonarv> it could happen at any moment!
08:57:15 <c_wraith> (only at allocations)
08:57:22 <c_wraith> but any allocation!
08:57:42 <Solonarv> (more precisely, only when the thread yields - which happens at any allocation, but not *only* there)
08:57:43 <c_wraith> and in theory, GHC might improve that in the future. :)
08:57:51 <zincy_> so the same mechanism for synchronous exceptions?
08:58:05 <Solonarv> no, not really
08:58:08 <c_wraith> Not really.  async exceptions require a kind of mailbox
08:58:14 <c_wraith> synchronous exceptions don't
08:59:12 <Solonarv> in 'someAction `catch` handler', the only way for 'handler' to get a non-async exception is if someAction called throwIO
08:59:42 <c_wraith> Well, or if during its execution it evaluates something to a call to throw
08:59:54 <Solonarv> oh, true
09:00:08 <zincy_> So in sync exceptions you cant throw an exception at another thread?
09:00:13 <Solonarv> indeed
09:00:32 <Solonarv> "throwing an exception at another thread" is always an async exception
09:00:49 <zincy_> So that is what makes it asynchronous actually
09:01:44 <Solonarv> async exceptions are used by killThread, or by the RTS to notify a thread that it's blocked forever / ran out of memory / whatever
09:01:46 <Solonarv> (among other things)
09:02:11 <dminuoso> zincy_: https://simonmar.github.io/posts/2017-01-24-asynchronous-exceptions.html is a good quick read
09:02:21 <Solonarv> this is why it's a bad idea to catch SomeException without re-throwing it: you might end up swallowing an async exception that was meant to kill your thread! now there is an unkillable zombie thread!
09:02:52 <fen> thats what you use bracket for right?
09:03:03 <zincy_> Thanks!
09:03:45 <Solonarv> % let cantKillMe = forever (putStrLn "braaaaains" >> threadDelay 1000000) `catch` \(_ :: SomeException) -> cantKillMe
09:03:45 <yahb> Solonarv: ead kil
09:04:36 <Solonarv> % do zombie <- cantKillMe; threadDelay 3000000; killThread cantKillMe; threadDelay 2000000
09:04:36 <yahb> Solonarv: ; <interactive>:215:58: error:; * Couldn't match expected type `ThreadId' with actual type `IO a0'; * In the first argument of `killThread', namely `cantKillMe'; In a stmt of a 'do' block: killThread cantKillMe; In the expression:; do zombie <- cantKillMe; threadDelay 3000000; killThread cantKillMe; threadDelay 2000000
09:04:47 * hackage line-bot-sdk 0.5.0.1 - Haskell SDK for LINE Messaging API  https://hackage.haskell.org/package/line-bot-sdk-0.5.0.1 (moleike)
09:04:51 <Solonarv> % do zombie <- forkIO cantKillMe; threadDelay 3000000; killThread cantKillMe; threadDelay 2000000
09:04:51 <yahb> Solonarv: ; <interactive>:216:65: error:; * Couldn't match expected type `ThreadId' with actual type `IO a0'; * In the first argument of `killThread', namely `cantKillMe'; In a stmt of a 'do' block: killThread cantKillMe; In the expression:; do zombie <- forkIO cantKillMe; threadDelay 3000000; killThread cantKillMe; threadDelay 2000000
09:05:32 <fen> killThread zombie?
09:05:46 <Solonarv> oh, thanks
09:05:47 <Solonarv> % do zombie <- forkIO cantKillMe; threadDelay 3000000; killThread zombie; threadDelay 2000000
09:05:52 <yahb> Solonarv: braaaaains; braaaaains; braaaaains; braaaaains; braaaaains; [Timed out]
09:05:57 <fen> lol
09:06:17 <Solonarv> moral of the story: don't swallow SomeException :>
09:06:26 <Solonarv> % putStrLn "it's still going!"
09:06:29 <yahb> Solonarv: it's still going!
09:06:36 <Solonarv> or not, lol
09:07:17 <fen> where has Cale gone? i wanted to learn about DSum
09:08:57 <fen> Solonarv: yahb must have some way to stop the formation of zombie thread
09:09:34 <Solonarv> it might've killed the GHCi session because I made it wait too much with all the threadDelays
09:10:03 <Solonarv> mniip: care to explain?
09:10:09 <Mnijinski> Hello, how can I access at the 3rd element of a tupple ? 
09:11:09 <fen> cant remember what its called, something like how it doesnt let certain modules be imported... like, a way you could have a secure kernal with a self modifying program without allowing things to run on it that would break the kernal itsself
09:11:20 <Solonarv> Mnijinski: there's no built-in function for that
09:11:50 <zincy_> Can you use generics?
09:11:51 <Solonarv> you can use pattern matching: case myThreeElemTuple of (_, _, interestingValue) -> ...
09:12:00 <Mnijinski> So it's not possible to do something like that ? https://paste.ofcode.org/qEpnGhHWrFU5QccsNpTHEq
09:12:02 <Solonarv> generics might work, yes
09:12:17 <Mnijinski> where i'll put the last value of begin in sqrt
09:12:33 <Solonarv> no, but you can use pattern matching to take the tuple apart
09:12:49 <fen> begin@(x,y,z)
09:13:07 <Solonarv> calcMin min (beginX, beginY, beginZ) end
09:13:07 <Solonarv>   | sqrt beginZ < min = 0
09:13:55 <Mnijinski> so beginX beginY and beginZ are some kind of types ?
09:14:02 <fen> > (\begin@(x,y,z) -> (z,begin)) (1,2,3) 
09:14:04 <lambdabot>  (3,(1,2,3))
09:14:43 <fen> no, types begin with capital letters
09:15:21 <Solonarv> they're not types, they're just names I gave to the tuple's elements
09:15:34 <Mnijinski> so, how could I convert (Float, Float, Float) to (beginX, beginY, beginZ) ?
09:15:39 <Mnijinski> oh
09:15:42 <Mnijinski> nvm then
09:16:47 <fen> @let calcMin min (x,y,z) end | sqrt z < min = 0
09:16:49 <lambdabot>  Defined.
09:17:06 <fen> > calcMin 1 (1,2,3)
09:17:08 <lambdabot>  error:
09:17:08 <lambdabot>      • No instance for (Typeable p20)
09:17:08 <lambdabot>          arising from a use of ‘show_M497953005326458573921134’
09:17:16 <dminuoso> Mnijinski: You can also have them as record types.
09:17:20 <fen> :o
09:17:53 <Mnijinski> oh
09:18:02 <Mnijinski> I see now fen
09:18:24 <Solonarv> dang ambiguous types and weird defaulting
09:18:24 <Mnijinski> I'll search for record types tho
09:19:02 <Solonarv> yeah, IMO it's definitely a good idea to define your own types instead of slinging around predefined ones all the time
09:19:58 <ski> Mnijinski : "I got 2 lists at the beginning and I want to get a value from the 1st list to put it on the second one at the \"pos\" position","And the second list is empty" .. well, if it's empty, then there *is* no "element at the `pos'th position"
09:20:12 <ski> @hoogle thd3
09:20:12 <lambdabot> Data.Tuple.Utils thd3 :: (a, b, c) -> c
09:20:12 <lambdabot> Data.Tuple.HT thd3 :: (a, b, c) -> c
09:20:13 <ski> @hoogle trd3
09:20:14 <lambdabot> Text.Regex.TDFA.Common thd3 :: (a, b, c) -> c
09:20:16 <lambdabot> Data.Label.Base trd3 :: ArrowApply arr => Lens arr ((a, b, c) -> (a, b, o)) (c -> o)
09:20:18 <lambdabot> Yi.Utils trd3 :: (a, b, c) -> c
09:20:20 <lambdabot> Trace.Hpc.Coveralls.Util trd3 :: (a, b, c) -> c
09:21:56 <Solonarv> whoa whoa, arrow lenses? what the hell? what is this abomination
09:22:19 <c_wraith> it's from like... fc-labels, I think?
09:22:47 <c_wraith> it's an older package. not used much anymore.
09:23:16 <Solonarv> ah, that makes sense
09:29:26 * ski . o O ( <http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutation> )
09:33:24 <Solonarv> top answer by ed kmett :D
09:39:49 <monochrom> Oh w00t GHC 8.6.5.
09:46:15 <maerwald> yes
09:46:30 <maerwald> llvm bug still not fixed
09:46:37 <maerwald> so don't use unboxed floats lol
09:51:01 <Solonarv> wow, we've really had a lot of point releases for this GHC version
09:56:34 <maerwald> Which is good
09:56:45 <maerwald> features can wait, bugfixes not
09:57:24 <maerwald> The amount of bugs with the bindists is a bit annoying though (and unfortunately, they don't get reverse-fixed)
10:17:33 <heath> I think I recall seeing an article stating that using getters and setters in the context of Haskell is bad practice. Does anyone happen to recall this or have a counter-argument?
10:20:03 <zachk> heath, when I need getters and setters in haskell I usually use: cabal install lens 
10:21:02 <Solonarv> haha
10:21:57 <Solonarv> heath: Haskell strongly encourages immutability, so setters in the OO sense don't make much sense; "getters" are just plain old functions
10:23:10 <heath> I'm wondering about this due to the way I'm working with an Elm app. The Session acts sort of like a reader, and the Session module exposes getters. The setters are only internal to the module.
10:23:28 <dminuoso> heath: There's nothing fundamentally wrong with `setters`.
10:24:01 <dminuoso> heath: That is, if you consider a setter to be just a function that changes some object (in a mutable or non-mutable way)
10:24:15 <dminuoso> Functions that somehow transform data is the basis for our programming.
10:24:33 <Solonarv> indeed
10:24:56 <Solonarv> I should've added the amendment: if you're dealing with mutable state (or some approximation thereof), setters make perfect sense!
10:25:23 <heath> Good to hear. I couldn't recall the arguments against getters and setters, and so I thought I would ask a wise group of folks for opinions. Glad I did
10:37:47 * hackage archive-sig 0.2.0.0 - Backpack signature for archive libraries  https://hackage.haskell.org/package/archive-sig-0.2.0.0 (vmchale)
10:38:47 * hackage archive-tar 0.2.0.0 - Common interface using the tar package  https://hackage.haskell.org/package/archive-tar-0.2.0.0 (vmchale)
11:15:15 <Berengal> Which of these two functions is more readable in your opinion? https://pastebin.com/9Vq9NLku
11:17:09 <phadej> second, though not sure if those are in the same order
11:17:25 <Berengal> They're not, but order isn't important
11:17:39 <cocreature> second but I would call x' and y', dx and dy
11:17:57 <Solonarv> I like the second better, though I would change the formatting a bit
11:19:36 <Berengal> Thanks
11:20:07 <dmwit> I think I would `squareAt (Pos x y) = [Pos (x+dx) (y+dy) | dx <- [0,1], dy <- [0,1]]` and then `squaresWith = map squareAt . squareAt`.
11:21:11 <dmwit> I guess it's off by one.
11:21:39 <dmwit> `squaresWith (Pos x y) = map squareAt . squareAt $ Pos (x-1) (y-1)
11:21:43 <dmwit> `
11:28:22 <dmwit> hah! If you did actual arithmetic (say, with Rational), you could `centered (Pos x y) = [Pos (x+dx) (y+dy) | dx <- [-1/2, 1/2], dy <- [-1/2, 1/2]]; squaresWith = map centered . centered` and there'd be no off-by-one problem.
11:59:59 <zincy_> Is it fair to say that only data which form executable instructions can ever be called a program?
12:03:37 <exarkun> the small folded pieces of paper you get when you go to the theater or some concerts is also called a program
12:04:40 <[exa]> zincy_: recipes are executable instructions for human cooking machines
12:06:17 * hackage store 0.5.1.0 - Fast binary serialization  https://hackage.haskell.org/package/store-0.5.1.0 (MichaelSloan)
12:08:15 <zincy_> So programs can have the same definition as data in the general sense because you can write a compiler which will foreseeably understand how to take the arbitrary data in as an executable instruction
12:09:03 <zincy_> Does that sound right?
12:13:09 <Tuplanolla> It's certainly not wrong.
12:18:40 <[exa]> zincy_: programs are data are the same if you look at them at a sufficiently fundamental level.
12:19:38 <zincy_> Right, I was kinda confused
12:20:08 <zincy_> Because I thought until there existed a compiler that understands your data you cant call your data a progream
12:23:17 <[exa]> zincy_: that wouldn't hold for assembly programs, you don't compile them
12:24:04 <__monty__> In the abstract you can call an assembler a compiler, imo.
12:24:08 <zincy_> Does an assembler not compile assembly code to machine code?
12:24:33 <[exa]> I wouldn't call that compilation, it's basically a fancy regex + some linking-related tricks
12:24:35 <__monty__> zincy_: It assembles the code, hence the name : )
12:24:53 <zincy_> What is the difference between assembling and compiling? :)
12:25:15 <Solonarv> it's a very simplistic compiler, but it's still a compiler
12:25:19 <__monty__> Mostly the level of abstraction at which it happens I'd say?
12:26:29 <[exa]> I've got to put together a reasonable machine code editing machine
12:26:53 <[exa]> like, the only goodies you get from assembler is that you can put reasonable names to address labels
12:27:24 <[exa]> that can get stored as debug symbols right in the binary
12:27:33 <[exa]> meh, another project
12:27:41 <zincy_> Is it fair to say I feel lost in the fuzziness of CS terms.
12:27:56 <zincy_> Or is it just me :)
12:28:05 <zincy_> Compilers vs interpreters ... programs vs data
12:28:37 <[exa]> zincy_: naming is hard
12:29:15 <[exa]> AFAIK dragonbook has some reasonable definitions that should still be mostly valid
12:34:34 <mniip> Solonarv, explain?
12:35:15 <__monty__> zincy_: The field isn't exactly lacking in jargon, no.
12:38:34 <mouse07410> What book is "dragon book"?
12:39:17 <yushyin> mouse07410: https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools
12:39:19 <[exa]> Compilers: Principles, techniques&tools
12:39:24 <[exa]> kindof classic
12:39:27 <Solonarv> mniip: uhh, let me scroll up
12:39:28 <Solonarv> oh right
12:39:48 <mniip> I found it in the log
12:39:55 <Solonarv> I was wondering why the 'zombie' thread disappeared, instead of continuing to put garbage in yahb's output
12:40:07 <mniip> once it goes [timed out] the entire process dies
12:40:31 <mniip> the message isn't printed by GHCi or anything, it's printed by the sandbox
12:40:48 <mniip> the sandbox uses a combination of a RLIM_CPU and a wall clock timer
12:40:48 <Solonarv> ah yeah, I figured it would kill the process
12:40:59 <Solonarv> that explains it
12:46:27 <mouse07410> Re. Assembler - usually it just converts CPU mnemonics to it's machine code equivalent, which of much less than what a Compiler needs to do.
12:48:27 <mouse07410> yushyin: thanks! Was this book published in two volumes back in 1980-ties?
12:50:10 <yushyin> I only know the second edition which is one book
12:51:30 <EvanR> assembling is still not as trivial as mapping, assembly languages often have completely unnecessary superfluous features like labels and hint directives
12:52:23 <EvanR> so when youre writing a compiler and you get to this step, and you wish it was easy. its not
12:54:43 <EvanR> and now i am seeing a relationship between the target of a jump and the bindings in a binding tree
13:04:06 <mouse07410> EvanR: labels aren't bad at all. I'm not sure what you mean by hints. But I'm my youth (before the first edition :) I wrote a few assemblers for some weird processors. It wasn't a big deal ;-)
13:04:52 <mouse07410> ^ I'm -> in
13:08:59 <EvanR> well, labels arent instructions
13:09:15 <EvanR> so you cant just use "map"
13:18:51 <mouse07410> Yeah, but it wasn't a big deal to compute offsets for jumps and such.
13:20:36 <EvanR> yeah and in a compiler you had to compute labels in the first place to turn ifs and loops into assembler
13:20:49 <EvanR> useless!
13:21:00 <dmwit> mniip: How do you detect when a query has "finished"...?
13:21:44 <mniip> with a bit of a... hack
13:21:49 <mniip> I mean not really
13:22:34 <mniip> I've patched GHCi to do a special request when it's done processing a given request
13:22:48 <dmwit> Oh cool.
13:23:30 <dmwit> Hm, well. But then I guess the next question is how does ghci detect when a query has "finished", given that forkIO is allowed.
13:35:41 <ski> ll_new zincy
13:36:25 <zincy_> What do you mean?
13:36:25 <ski> er, sorry
13:36:58 <zincy_> no worries
13:37:50 <ski> (i was scrolled up a bit, and somehow managed to send something by mistake)
13:40:16 <ski> .. i suppose, in some sense, you might think a matrix, to which you adjoin a vector, to solve (say least-squares approximatively), as a "program" of sorts
13:40:25 <ski> (or consider "linear programming")
13:41:22 <ski> obviously not in a Turing-complete sense, but still as encoding some kind of somewhat nontrivial computation (especially if you take numerical analysis into account, i suppose)
13:43:02 <ski> and then, i suppose to "compile" such a matrix would be to produce a program (in C or Fortran or whatever) (or just some data to plug into a readymade such program template), that then can solve the corresponding problem, once you give it the vector (the run-time input, so to speak)
13:44:10 <zincy_> What is linear programming?
13:44:15 <ski> in some sense, perhaps, "interpreting" (like any pattern-matching, typically in a recursive fashion ?) a value of an algebraic data type (typically some kind of tree), can be considered as interpreting a program
13:45:26 <zincy_> Isn't pattern matching on an ADT just a parsing program?
13:46:14 <ski> well, you have a set of linear inequality constraints, on a bunch of real (or perhaps rational, or integer, or natural) number variables/unknowns/indeterminates. that defines say a region in the plane (if you've two variables), a polygon. or some kind of generalized polyhedron in more dimensions/more unknowns
13:46:50 <zincy_> Ah right
13:46:58 <ski> and then you have an "objective function", that given any "coordinate vector", specifying candidate values for all the unknowns, will compute a "value", that determines "how good it is"
13:47:27 <ski> and so you want to maximize (or sometimes minimize) the objective function, while staying in the confines of the linear inequality constraints
13:48:30 <ski> typically that means searching vertices of the polyhedron, possibly in some smart way, and possibly after doing other simplifications, which may be required to get things more tractable, in case you have say hundreds of indeterminates
13:48:53 <ski> zincy_ : re parsing, yea, i suppose that's another way to think about it
13:49:39 * ski . o O ( Futamura projections )
13:51:10 <__monty__> Futurama projections? Sounds like great fun.
13:52:05 <mniip> dmwit, well yea it's a shortcoming
13:52:18 <mniip> basically whenever ghci asks for another line of input
13:52:45 <mniip> you can indeed leave a thread running in background and have it mess up the output of the next invocation
13:52:50 <mniip> I don't think I can do anything about that
13:56:49 * dmwit nods
14:04:31 <thuringia> What is the general view on nested product types and type synonyms in Haskell?
14:04:31 <thuringia> Should one avoid these?
14:05:24 <zincy_> I think nested product types are totally standard.
14:05:32 <Solonarv> if by "product types" you mean tuples, yes, those are a codesmell IMO - define your own data types!
14:06:42 <zincy_> Do you mean something like data Person = Person Age Name?
14:08:02 <thuringia> yes.  data Name = Name String String      data Person = Person Name Age etc ...
14:08:31 <Solonarv> oh, if you define them yourself then that's totally fine
14:09:31 <thuringia> I mean, it's kind of annoying when internal data constructors have to be written down all the time.
14:09:31 <thuringia> p = person (name bla bla) bla
14:09:31 <thuringia> and then in several depths ...
14:10:40 <Solonarv> well, ideally if you've defined a type it makes sense to pass it around as a whole, and you wouldn't need to deconstruct it all the time
14:11:01 <Solonarv> if they're single-constructor types you can make things more convenient by using record syntax
14:11:35 <jle`> thuringia: i don't think there is anything necessarily wrong with nested data types if they are made in a semantically meaningful way
14:12:42 <jle`> i have never heard of anyone suggesting to avoid them
14:15:26 <thuringia> ok. it may be that there are style recommendations or something. that's why I asked.
14:15:52 <Solonarv> there are style recommendations, but none that I've ever heard of are against nested product types :P
14:16:55 <thuringia> XD
14:16:55 <thuringia> well, many people tend to nest heavily. For example, when I think of the module system in Rust, which seems really grotesque sometimes.
14:18:07 <Solonarv> yeah, heavy nesting can get unwieldy sometimes
14:18:20 <Solonarv> but so can giant singular types/modules/whatever
14:23:04 <untseac> hello. I was reading in lyah that a data constructor is a function but I don't think that's correct. It acts like a function but it's not.
14:23:11 <untseac> Am I right?
14:23:17 <glguy> untseac: True is a data constructor and not a function
14:23:21 <mouse07410> EvanR: a compiler is a whole different story, complexity-wise. And once you start considering optimization, it becomes royal fun. But a simple assembler, even with labels, was simple enough.
14:23:44 <untseac> glguy, makes sense to me. thanks
14:23:47 <glguy> untseac: "function" and "constructor" are in separate categories of names. Functions are values you can apply to thinks
14:23:57 <glguy> constructors are compitalized names you can use as values and in patterns
14:24:01 <glguy> capitalized*
14:24:13 <untseac> right, you can't use a function in patterns AFAIK
14:24:19 <jle`> thuringia: the general principle is that you should break data types according to how often you use them as individual parts
14:24:30 <glguy> untseac: You build patterns out of Constructors and variables
14:24:42 <glguy> it's not important if something is a "function" or not there
14:24:50 <jle`> thuringia: if you never need Name as a separate individual thing, then Person = Person { lastname :: String, firstname :: String, age :: Age } is fine
14:25:11 <glguy> untseac: You can bind a function with a pattern
14:25:21 <glguy> let (f,g) = (succ,pred)
14:25:26 <glguy> f and g are functions there
14:25:58 <untseac> hum yeah. still calling a data constructur a function is kind of silly imo
14:26:13 <glguy> Yeah, it's wrong to call all constructors functions
14:26:34 <untseac> thanks
14:26:51 <thuringia> ok thx records are a good alternative
14:26:54 <__monty__> Because nullary constructors are just values?
14:27:10 <__monty__> : >
14:27:17 <Solonarv> they're somewhat special values because you can match against them, but yes
14:27:42 <ski> untseac : `Just' is a function. and is also a data constructor
14:28:14 <__monty__> Hmm, are constructors uncurried functions?
14:28:44 <glguy> __monty__: non-nullary constructors can also be used as "just values", functions are just values
14:28:53 <ski> untseac : it's not a "function that computes anything", in some sense, it just "stores its input, for later retrieval", so to speak. but it's still a function, in the trivial sense that you can pass an input to it, and get an output (the wrapped input) back
14:29:06 <Solonarv> no, constructors are curried
14:29:45 <__monty__> glguy: What I meant was just as in only values. As opposed to both a value in their own right and a function that takes a value and produces a value.
14:30:38 <Solonarv> indeed, nullary constructors are non-function values
14:30:51 <untseac> hum, I say a non nullary constructor acts like a function, not exactly a function.
14:31:02 <ski> "curried" is not an objective property of a value (function or not), but is a statement about you intending to encode a "multiple-argument function" (something which Haskell does not have, all Haskell functions take exactly one argument, strictly speaking) in terms of Haskell functions. "currying" is one such encoding. the other common encoding might be called "tupling" (could also be done with a record, or list, or other compound data structure)
14:31:13 <ski> __monty__ ^
14:31:35 <ski> (hrm, cut off near ".. the other common encoding might be called \"tupling\" (could also be done with a record, or list, or other compound data structure)")
14:32:28 <__monty__> ski: Wasn't cut off for me. What would a curried record look like? Oh, I get it, instead of a tuple.
14:32:28 <ski> (are we confused enough, yet ?)
14:32:50 <__monty__> Haskell's functions are commonly described as curried functions though.
14:33:08 <ski> more like, a function being "recorded", rather than "tupled", by which i'd mean that the "multiple arguments" would be wrapped up together in a single record argument
14:33:14 <Solonarv> indeed, because we usually use the "currying" encoding to describe multiple-argument functions
14:33:51 <ski> __monty__ : yes, that's a misunderstanding. however, the design of the *syntax* of Haskell *definitely* encourages using curried style often
14:34:09 <ski> s/a misunderstanding/a common misunderstanding/
14:34:24 <__monty__> Ah, ok, I think I get the point. Interesting.
14:34:33 <Solonarv> and there is some privileged treatment for currying by the language: it's the most lightweight syntactically, and the functions specified in the report are curried
14:34:47 <ski> exactly
14:34:47 * hackage knit-haskell 0.1.0.0 - a minimal Rmarkdown sort-of-thing for haskell, by way of Pandoc  https://hackage.haskell.org/package/knit-haskell-0.1.0.0 (adamCS)
14:35:57 <__monty__> I do think I wasn't abusing the language in my question though. Asking whether a function is uncurried/not curried seems perfectly valid.
14:36:01 <Solonarv> imagine if instead of writing: foo a b c = a * b + c, we had to write: foo = a => b => c => a * b + c, to provide a curried function
14:36:08 <ski> (it's the same in OCaml, but not quite the same in SML. probably, in that latter case, because initial implementations were better with unpacking tuple (and record, tuples *are* records in SML) arguments, than not doing unnecessary/needless work, when calling curried functions)
14:36:16 <ski> or, in Scheme
14:36:36 <ski>   (define (foo a) (lambda (b) (lambda (c) (+ (* a b) c))))
14:36:59 <ski>   (define (((foo a) b) c) (+ (* a b) c))  ; Some Schemes support this syntax, though
14:38:51 <Solonarv> compare the tupled encoding: foo (a,b,c) = a * b + c -- in Haskell; foo = (a,b,c) => a * b + c // or something like it, in many imperative-with-lambda languages
14:39:31 <ski> (in SML, most typical functions in the standard library are tupled (exeptions like the commonly partially applied `map' exist). not so in OCaml)
14:39:32 <Solonarv> in Rust they compare: |a| |b| |c| a * b + c; |a, b, c| a * b + c
14:39:59 <ski> (btw, people also sometimes confuse currying with partial application (or even the latter with partial evaluation))
14:40:45 <ski> Solonarv : not that far from SML, actually .. the former examples
14:41:44 <__monty__> Can you even partially apply a curried function? You either give it a single argument, or you don't.
14:41:54 <ski> (you'd say `val foo = fn a => fn b => c => a * b + c', vs. `val foo = fn (a,b,c) => a * b + c', if you wanted to use the function abstraction/literal (aggregate ?) syntax)
14:42:20 <Solonarv> yeah - reasonably similar, but still one is clearly privileged
14:42:36 <ski> __monty__ : "partial application" (from where i'm taking it to make the most sense) also only applies to multiple-argument functions, which Haskell doesn't have
14:42:55 <Solonarv> __monty__: you can with appropriate magic
14:43:51 <ski> meaning : to presupply some (the early), but not all, of the multiple arguments, yielding a function that still "waits" of the "late" arguments (havning remembered / bundled up the early ones / taken them into account), before computing the final result
14:44:31 <__monty__> And partial evaluation would be evaluation the function body as far as possible given the arguments you've received?
14:44:42 <Solonarv> yes
14:44:44 <ski> so, part of the utility of curried style is that you get a very syntactically cheap way of partially applying to a *prefix* of the (curriedly encoded) multiple arguments
14:45:05 <ski> you can do "partial evaluation by hand", it can sometimes be useful
14:45:18 <Solonarv> well, doesn't actually have to be "as far as possible", it can just be "somewhat"
14:46:03 <ski> sometimes known as "run-time compilation" (not to be confused with the other kind of Run-Time Code Generation (RTCG), which tends to be able to generate new machine code, or at least virtual machine instructions, at run-time)
14:47:25 <ski> e.g., you might pass a function a description of a regular expression, and it might walk over that a bit, analyzing it, constructing a FSM that's exactly suited to that regex, before returning a function that, when given some text, will use that FSM to try to match it
14:47:52 <ski> (of course, in Haskell, said construction would probably happen only the first time you actually apply that resulting function)
14:48:21 <ski> i've seen this being called "serious currying", as opposed to "trivial currying" (which is what `curry' produces)
14:49:01 <Solonarv> you could make sure it happens earlier than that using strictness annotations, assuming the regex library is written with that in mind
14:49:10 * ski nods
14:49:30 <MarcelineVQ> is the next big extention after dependent and linear going to be partial evaluation :>
14:49:48 <ski> <__monty__> I do think I wasn't abusing the language in my question though. Asking whether a function is uncurried/not curried seems perfectly valid.
14:49:50 <Solonarv> match regex = let auto = compileRegex regex in auto `seq` \haystack -> matchAuto auto haystack
14:49:52 <ski> sure
14:50:10 <Solonarv> actually that can just be !auto, no need for manually using seq
14:50:19 <ski> __monty__ : i was just attempting to clarify the issue a bit, shed some light of some possibly interesting deeper matters
14:50:49 <Solonarv> actually GHC already does something like this for arguments that are sufficiently-known at compile time
14:51:22 <__monty__> ski, Solonarv: Thanks for the conversation. Have a good night.
14:51:25 <ski> __monty__ : in colloquial use, amongst people who know what is intended, i think it's fine. otoh, with newbies, i think it helps being stricter with terminology, when they're trying to get the basic concepts and distinctions right
14:51:35 <Solonarv> inlining, beta reduction, and case-of-known-constructor are the main relevant optimizer passes IIRC
14:51:46 <ski> __monty__ : good night to you as well, nice chatting with you, pleasant dreams
14:52:10 <ski> MarcelineVQ : would be kinda fun :>
14:53:46 <ski> having a not as .. clunky meta- / staged programming system (TH), would possibly help
14:54:24 <MarcelineVQ> -XModalHaskell
14:54:43 * ski . o O ( Nanevski )
14:55:51 <MarcelineVQ> oh, Separation Logic? does this guy work on iris?
14:56:33 <ski> i dunno separation logic
14:56:41 <ski> (would you suggest any paper ?)
14:56:59 <MarcelineVQ> idk, you said Nanevski and his page has links to seperation logic papers :>
14:57:09 <MarcelineVQ> https://software.imdea.org/~aleks/
14:57:39 <MarcelineVQ> pgiarrusso in ##dependent could likely cite you good papers however
14:58:19 <ski> i was thinking about "Contextual Modal Type Theory" by him,Frank Pfenning,Brigitte Pientka in 2008-06
14:58:33 <ski> MarcelineVQ : probably mietek as well, i imagine
14:58:59 <MarcelineVQ> probably but I think pgiarrusso brings it up more
14:59:18 <ski> hm, perhaps more now ?
14:59:33 * ski hasn't been much present there, alas
16:09:37 <halogenandtoast> Is there a more general way to write something like `f <$> (g <$> x <*> y)`
16:09:48 <halogenandtoast> s/general/idiomatic/
16:17:12 <tsizz> hi if i want to prompt user till a condition is satisifed (loop) with a helper recursive function... then this recursive function can't be pure?
16:17:51 <glguy> tsizz: The function will still be pure, it just might return an IO action
16:18:24 <halogenandtoast> glguy technically it can return a bottom if it recurses too many times no?
16:18:43 <jmorris> halogenandtoast: f <$> (liftA2 g x y)
16:20:11 <glguy> halogenandtoast: no, not if you have it in a tail position
16:20:33 <halogenandtoast> Ah true
16:20:44 <halogenandtoast> jmorris: do you find liftA2 to be more idiomatic?
16:20:58 <tsizz> so i should not be binding in my recurisve function?
16:21:05 <tsizz> or wait i think thats okay...?
16:21:27 <jmorris> halogenandtoast: I don't really know what idiomatic means, sorry.
16:21:30 <halogenandtoast> tsizz: as long as the recursion is in a tail-call optimized position, it's pure
16:22:27 <halogenandtoast> jmorris: It would mean that you'd expect to see the code in the form of f <$> (liftA2 g x y) more often than f <$> (g <$> x <*> y)
16:22:32 <halogenandtoast> in the wild
16:23:10 <phadej> halogenandtoast: i'd write fg <$> x <*> y where fg x' y' = f (g x' y') -- or something like that
16:24:16 <halogenandtoast> phadej: for a better reference the code I am looking at is `toJSON <$> (Log <$> getCurrentTime <*> pure [])`
16:24:32 <jmorris> halogenandtoast: liftA2 f x y is the same thing as f <$> x <*> y
16:25:37 <phadej> hololeap: I'd rewrite that as getCurrentTime <&> \t -> toJson (Log t [])
16:25:40 <phadej> halogenandtoast: ^
16:25:43 <phadej> sorry hololeap
16:25:58 <phadej> :t (<&>)
16:25:59 <lambdabot> Functor f => f a -> (a -> b) -> f b
16:26:05 <LambdaCoaster[m]> i write that sometimes as: `fmap f $ g <$> x <*> y`
16:26:41 <phadej> I don't like x <*> pure y stuff, I want to rewrite that using fmap/<$>/<&>
16:26:52 <tsizz> would anyone mind checking if my simple recursion function is defined right 
16:27:33 <halogenandtoast> phadej: curios, is there a particular reason you don't like that construction?
16:27:39 <halogenandtoast> *curious
16:27:52 <phadej> halogenandtoast: it requires Applicative, when Functor is enough
16:28:44 <phadej> it's ~ok when you do Constructor <$> ... <*> ... <*> pure something <*> ... <*> ...
16:29:05 <LambdaCoaster[m]> an alternative: `toJSON . flip Log [] <$> getCurrentTime`
16:29:15 <lyxia> And pure often entails constructing a structure that is unraveled by (<*>) so in a way it's a less direct formulation.
16:29:20 <LambdaCoaster[m]> an alternative: `toJSON . flip Log [] <$> getCurrentTime`
16:29:58 <tsizz> im sort of confused how recursion will be pure if i am taking a user input inside it
16:29:58 <halogenandtoast> LambdaCoaster[m]: anything that requires flip generally makes it off my list
16:30:40 <koz_> Is hindent dead or moribund? I can't install it with cabal new-install at all, because it doesn't like Cabal 2.4.*
16:30:47 <phadej> lyxia: true, and as often  <*> scrutinises lhs first, x <*> pure y isn't optimised (when pure x <*> y probably would)
16:31:23 <phadej> halogenandtoast: not always, e.g. flip evalStateT [] $ ... 
16:31:46 <halogenandtoast> phadej: I used "generally" to indicate there were exceptions ;)
16:31:46 <phadej> evalStateT initialState...
16:31:49 <LambdaCoaster[m]> or: `getCurrentTime <&> \t -> toJson $ Log t []`
16:32:12 <halogenandtoast> I also control the constructor order for Log
16:32:12 <phadej> LambdaCoaster[m]: I said exactly that ~6 minutes ago
16:32:17 <halogenandtoast> so I could just move time to the end
16:32:35 <phadej> halogenandtoast: yes, then Log [] <$> getCurrentTime would be very nice
16:32:36 <halogenandtoast> to avoid the flip
16:32:50 <unclechu> halogenandtoast: how about `toJSON . (`Log` []) <$> getCurrentTime`?
16:33:29 <unclechu> phadej: well, the point was that it wasn't /exactly/ the same
16:34:02 <phadej> unclechu: swapping () -> $ is IMHO "the same"
16:34:18 <tsizz> if im taking user input in a function. does the function have to be a do ?
16:34:20 <tsizz> in a do clause
16:34:30 <halogenandtoast> do is just a syntax sugar
16:34:34 <tsizz> oh
16:34:37 <halogenandtoast> you will likely need to use (>>=)
16:34:40 <halogenandtoast> which do does for you
16:34:47 <tsizz> can i just use do...?
16:35:04 <halogenandtoast> You can do anything through Haskell who strengthens you
16:35:30 <tsizz> im not sure if this is right tho
16:35:36 <tsizz> or like the haskell way of doing it
16:35:41 <tsizz> i feel my function isn't pure if i use do
16:36:04 <halogenandtoast> do just means you're using a monad
16:36:16 <tsizz> so i would need do to take user input?
16:36:28 <halogenandtoast> you don't need it
16:36:33 <halogenandtoast> but it allows you to write imperatively
16:36:48 <tsizz> so how would i do it without do
16:36:58 <unclechu> halogenandtoast: you can `do` with `Maybe` or `Either` it can't be not pure, right?
16:37:27 <halogenandtoast> tsizz: main = getLine >>= print
16:37:30 <halogenandtoast> is an example
16:38:11 <unclechu> tsizz: `foo >>= \foo' -> bar >>= \bar' -> baz foo' bar'`
16:38:42 <unclechu> like instead of: `do foo' <- foo; bar' <- bar; baz foo' bar'`
16:39:28 <halogenandtoast> tsizz: that same code written with do would be `main = do { line <- getLine; print line }`
16:40:09 <halogenandtoast> which just desugars to
16:40:20 <halogenandtoast> `main = getLine >>= (\line -> print line)`
16:41:04 <halogenandtoast> unclechu: I am not sure what you mean by your question.
16:42:23 <unclechu> halogenandtoast: sry, i was addressing it to another person but accidentaly mentioned you
16:42:35 <halogenandtoast> ah no worries.
16:43:51 <halogenandtoast> tsizz: when I was first learning haskell it took me a long time to understand what `do` was doing, I thought it was black magic for the longest time
16:44:09 <halogenandtoast> but generally it desugars each "line" and connects them with either (>>=) or (>>)
16:44:57 <halogenandtoast> if your line has <- in it, it will desugar to (>>=) and if it doesn't then it will desugar to (>>)
16:45:08 <halogenandtoast> I might be missing a case but that should get you 90% of the way there.
16:45:23 <tsizz> halogenandtoast: but you said do lets you do imperative. if its just syntatic sugar, then u dont need it to do imperative?
16:45:37 <halogenandtoast> tsizz: it lets you write in an imperative style
16:45:53 <tsizz> can i bind value to output of a function?
16:45:57 <tsizz> or is that not recommended
16:46:13 <halogenandtoast> tsizz: can you explain what you mean there?
16:46:33 <tsizz> like i have a function that will return a string
16:46:51 <tsizz> can i do call that function and bind it to a value and use that value
16:47:08 <dyl> let y = f(x)?
16:47:11 <dyl> Sure why not.
16:47:31 <halogenandtoast> dyl: I think he means `f <- g` where `g :: String`
16:47:45 <dyl> f ← return g ?
16:47:46 <tsizz> i guess either
16:47:47 <halogenandtoast> s/he/they/
16:47:49 <tsizz> not sure the difference D:
16:47:57 <tsizz> <- only for IO string?
16:47:58 <dyl> (But use “pure”, not “return”.$ 
16:48:12 <dyl> ← is part of special monad syntax called “do notation”.
16:48:17 <halogenandtoast> :t (>>=)
16:48:18 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:48:27 <halogenandtoast> if you monad is IO
16:48:32 <halogenandtoast> you need it to be in IO
16:48:39 <halogenandtoast> so it would need to be an IO String
16:49:01 <dyl> If you have a String and want it to be an IO String you can use ‘pure’
16:49:08 <dyl> :t pure “hello world”
16:49:10 <lambdabot> error: lexical error at character 'h'
16:49:19 <dyl> Oh sorry, my phone does smart quotes...
16:49:24 <dyl> :t pure
16:49:26 <lambdabot> Applicative f => a -> f a
16:49:29 <dyl> :t return 
16:49:30 <lambdabot> Monad m => a -> m a
16:49:44 <dyl> All monads are applicatives and we generally prefer “pure” because “return” is confusing.
16:49:56 <dyl> In nearly every monad, return = pure 
16:49:57 <halogenandtoast> I prefer pure because it is 2 characters shorter
16:50:14 <tsizz> so i need it to be an io string if i want to return?
16:50:20 <tsizz> as in output string
16:50:30 <halogenandtoast> tsizz: why don't you provide an example of code for what you want to do
16:50:34 <halogenandtoast> it's okay if it doesn't work
16:50:36 <dyl> Can you paste the context of your question? Like— yeah
16:50:40 <tsizz> uh
16:50:42 <halogenandtoast> and I can probably address your question better
16:50:54 <unclechu> tsizz: think about a monad as it is just another way of composing functions (and it is exactly what it is)
16:51:07 <unclechu> tsizz: you  don't `return` anything, this name is misleading
16:51:29 <dyl> (Hence why you should use “pure” instead.) 
16:51:44 <dyl> (Pure = “lift a pure value of type a into the monad m”)
16:51:58 <halogenandtoast> unclechu: indeed the name is misleading, definitely a tarpit if you've written in almost any other language
16:52:03 <tsizz> um
16:52:04 <dyl> For example, pure for lists turns a single thing into a list of length 1 containing that thing.
16:52:09 <unclechu> tsizz: what `return` does is just wraps a value with some wrapper. try to work with `Maybe` monad first. so `return` will just wrap some value with `Just`
16:52:11 <dyl> pure for Maybe is Just.
16:52:14 <tsizz> ill send the whole file. its sort of ocnfusing because im working on a few helper functions
16:52:19 <halogenandtoast> :t pure 1 : [Int]
16:52:20 <lambdabot> error:
16:52:20 <lambdabot>     • Data constructor not in scope: Int :: f a
16:52:20 <lambdabot>     • Perhaps you meant one of these:
16:52:25 <halogenandtoast> :t pure 1 :: [Int]
16:52:26 <lambdabot> [Int]
16:52:39 <halogenandtoast> > pure 1 :: [Int]
16:52:41 <lambdabot>  [1]
16:52:47 <halogenandtoast> > return 1 :: [Int]
16:52:49 <lambdabot>  [1]
16:52:57 <tsizz> https://pastebin.com/n2vZxamh
16:53:00 <dyl> > (pure :: a -> [a]) 42
16:53:02 <lambdabot>  [42]
16:53:10 <dyl> > (pure :: a -> Maybe a) 42
16:53:12 <lambdabot>  Just 42
16:53:25 <tsizz> i am doing hangman and i can guess 1 character and it'll print out the result
16:53:32 <tsizz> but now i want to loop it so i can keep guessing till i finish
16:54:06 <halogenandtoast> tsizz: btw there is getChar which might be better than getLine for what you are doing
16:54:35 <tsizz> oh okay
16:54:47 <halogenandtoast> you can see an example of me doing something similar here: https://github.com/halogenandtoast/all_the_sokobans/blob/master/haskell/src/Main.hs#L129-L134
16:55:19 <halogenandtoast> or my hangman implementation: https://github.com/halogenandtoast/hangman-haskell/blob/master/app/Main.hs
16:55:22 <dyl> I don’t think getChar will swallow the new-line though?
16:55:23 <unclechu> tsizz: and to loop you could use `forever` from `Control.Monad` module
16:55:47 <tsizz> unclechu: im not sure we are supposed to use that
16:55:52 <tsizz> so i rather do it with recursion
16:56:10 <dyl> forever is recursion :) 
16:56:14 <dyl> there are no loops, only recursion 
16:56:24 <dyl> But if you need to write it explicitly... 
16:56:36 <halogenandtoast> dyl: you are right that it won't, I think you can mess with stdin to not be buffered to do that
16:56:47 <dyl> That sounds bad...
16:56:48 <halogenandtoast> in that the user does not need to press return
16:56:54 <dyl> I wouldn’t do that lol.
16:57:03 <dyl> Once input buffering matters you’re in the Bad Place.
16:57:14 <halogenandtoast> dyl: why not? If you are making a game where you need to move around
16:57:17 <halogenandtoast> you want it unbuffered
16:57:27 <dyl> This is console hangman...
16:57:27 <unclechu> tsizz: here is the implementation of `forever`: `forever a   = let a' = a *> a' in a'`
16:57:28 <unclechu> it's recursion) forever recursion
16:57:58 <dyl> @src Control.Monad.forever
16:57:59 <lambdabot> Source not found. That's something I cannot allow to happen.
16:58:07 <halogenandtoast> dyl: sure, it's just a preference at this point, type a char, have it fill in immediately, rather than type a char and press enter
16:58:26 <dyl> Assuming your console behaves nicely... 
16:58:45 <halogenandtoast> *cough* runCurses
16:58:47 <dyl> Writing anything that depends on the TTY doing things correctly is a nightmare. 
16:58:55 <dyl> And now you have another dependency :p.
16:59:02 <halogenandtoast> Yeah but I live curses
16:59:04 <halogenandtoast> *love
16:59:09 <halogenandtoast> so I am okay with it
16:59:29 <halogenandtoast> my goal isn't portability, my goal is to enjoy what I am doing
16:59:32 <tsizz> ugh i feel like i have to write so many helper functions
16:59:38 <tsizz> i feel like this should be able to do in one function
16:59:45 <tsizz> not sure whts right 
16:59:48 <halogenandtoast> tsizz: did you see my hangman?
17:00:53 <tsizz> uhhh its sort of hard for me to understand 
17:00:59 <tsizz> i mean follow
17:01:23 <halogenandtoast> hmm I tried to write it in an easy to follow manner, I might have failed though :\
17:02:10 <halogenandtoast> All the IO (aka UI) related stuff is in Main, and the rest has been extracted to a lib
17:02:41 <dyl> tsizz: don’t be afraid to spend time reading other people’s code closely.
17:03:02 <dyl> It’s a dangerous misconception pushed in today’s industry focused unis that it’s a waste of time.
17:03:11 <tsizz> like idk what GameState is
17:03:12 <dyl> Learn from the works of the “masters”. 
17:03:20 <dyl> tsizz: ctrl-f ;)
17:03:28 <halogenandtoast> tsizz: https://github.com/halogenandtoast/hangman-haskell/blob/master/src/Hangman/Game.hs#L4-L7
17:03:41 <dyl> A word of advice: in my experience the strongest correlate of being a “good programmer” is...
17:03:44 <dyl> ...research skills.
17:03:57 <dyl> How quickly do you start searching? Do you know how to formulate search queries effectively? 
17:04:08 <dyl> These are far more important skills than knowing any one language or framework. 
17:04:09 <halogenandtoast> Keeps track of the word to guess, the guesses made by the user, and the maximum number of wrong guesses allowed
17:04:38 <dyl> Don’t be afraid to get your feet dirty and wade around through codebases to find what you need to know.
17:04:51 <dyl> “Show Usages” and “Go To Definition” are the best features of a good IDE.
17:04:53 <halogenandtoast> dyl: before I knew how to program, I would debug other people's code lol
17:05:12 <halogenandtoast> We were at a live programming competition and they were writing C and I would learn to point out mistakes
17:05:15 <dyl> The best programmer out of a pool is almost always the one who pulls up google first. 
17:05:48 <tsizz> im just confused how to have a string "Hask_ _ _" and then take in another guess. since u need the full word Haskell as well
17:06:18 <dyl> What if you had a list of booleans of the same length that represents whether that character has been revealed or not? 
17:06:41 <dyl> And then some function mask :: String -> [Bool] -> String to display it? 
17:07:27 <dyl> there’s a handy “all” function that checks if all booleans in a list are true, so that’s your win condition.
17:07:36 <dyl> > all [True, True, False]
17:07:38 <lambdabot>  error:
17:07:38 <lambdabot>      • Couldn't match expected type ‘a -> Bool’
17:07:39 <lambdabot>                    with actual type ‘[Bool]’
17:07:44 <clever> :t zip
17:07:44 <dyl> Oh, right
17:07:44 <lambdabot> [a] -> [b] -> [(a, b)]
17:07:46 <dyl> :t all 
17:07:47 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
17:07:59 <dyl> > all id [True, True, False]
17:08:00 <clever> dyl: use zip to turn a list of chars, and list of bools, into a list of (Char,Bool)
17:08:01 <lambdabot>  False
17:08:09 <halogenandtoast> tsizz: I do what you're mentioning here https://github.com/halogenandtoast/hangman-haskell/blob/master/app/Main.hs#L30-L35
17:08:09 <dyl> clever that’s not necessary 
17:08:13 <tsizz> i was thinking of having "Hask_ _ _" then like "_ _ _ _ e _ _ " and then combining it somehow
17:08:16 <clever> then you can use map to trasnform those tuples back into chars, possibly masked
17:08:42 <dyl> True, but let’s ignore HOFs for now because beginner.
17:08:51 <dyl> Writing out the recursion is a learning experience. 
17:08:53 <clever> HOF's?
17:08:55 <clever> ah
17:09:16 <clever> and for some things, recursion is simpler
17:09:21 <dyl> mask (c:cs) (b:bs) = (if b then c else ‘_’) : mask cs bs
17:09:25 <dyl> (Plus the base cases).
17:10:13 <dyl> You could use zip + map + un/curry though, yeah.
17:10:27 <dyl> But that’s more what a long time Haskeller would do once they know what that does under the hood.
17:10:47 <halogenandtoast> dyl: pretty sure I would do it the way I wrote it lol
17:11:10 <halogenandtoast> but I've only been doing Haskell for 6 years
17:11:30 <clever> > map (\(c,b) -> if b then c else '_') (zip "foo" [True,False,True])
17:11:32 <lambdabot>  "f_o"
17:11:33 <tsizz> halogenandtoast: oh so are you keeping track of the guesses and then applying them each time?
17:11:45 <clever> dyl: one weird artifact of this method, is that not all o's unmask at once!
17:11:48 <dyl> halogenandtoast: should have split the pure part off from the IO part :p
17:11:59 <dyl> clever ah, but that’s another layer isn’t it? 
17:12:08 <clever> dyl: *rewrites it*...
17:12:15 <dyl> You would need a function from [Char] -> [Bool] :)
17:12:25 <halogenandtoast> guesses is an array of chars, as is the word (String)
17:12:30 <dyl> Sorry, [Char] -> String -> [Bool]
17:12:42 <dyl> call it “maskLetters” or something.
17:12:45 <clever> > map (\c -> if c `elem` "fa" then c else '_') "foobarbaz"
17:12:47 <lambdabot>  "f___a__a_"
17:12:53 <clever> dyl: this looks pretty close to whats needed
17:12:59 <halogenandtoast> so we basically loop through all the chars in the word and if the char is in the guesses we show it
17:12:59 <dyl> (Note that a list of char and string are the same thing, I’m just writing them distinctly to make it clearer.)
17:13:34 <halogenandtoast> dyl: Which part is the pure part I didn't split off?
17:15:49 <tsizz> halogenandtoast: so where do you define guesses
17:15:52 <tsizz> i see the update part
17:16:54 <halogenandtoast> initialState defines it as an empty list
17:17:07 <halogenandtoast> initialState word = GameState word [] 6
17:18:07 <halogenandtoast> If you're not familiar with record syntax this might be slightly confusing
17:18:40 <tsizz> halogenandtoast: hm yeah im not sure
17:18:54 <halogenandtoast> data Person = Person { personName :: String } is the same as data Person = Person String BUT
17:19:07 <halogenandtoast> it gives you a method personName that pulls that String out
17:19:10 <tsizz> halogenandtoast: but essentially are you keeping a list of the guesses. and then populating the hangman state part with the list of guesses 
17:19:49 <tsizz> so like ['h'] map word and get h_ _ _ _ _ _
17:20:00 <halogenandtoast> Yes a GameState might look like      GameState "Haskell" ['h', 
17:20:02 <halogenandtoast> err
17:20:06 <tsizz> then ['h','a'] map word and get h a _ _ _ _ _
17:20:13 <halogenandtoast> GameState "Haskell" ['h', 'a', 'p'] 6
17:20:19 <halogenandtoast> in my game
17:20:49 <halogenandtoast> and then yes I map on the word and check to see if the character is the guesses
17:21:09 <halogenandtoast> if it is print it, otherwise print _
17:21:33 <tsizz> halogenandtoast: gotcha
17:21:43 <clever> > map (\c -> if c `elem` "fa" then c else '_') "foobarbaz"
17:21:44 <lambdabot>  "f___a__a_"
17:21:47 <halogenandtoast> ^^
17:22:09 <halogenandtoast> map (\c -> if c `elem` "hap" then c else '_') "haskell"
17:22:14 <halogenandtoast> > map (\c -> if c `elem` "hap" then c else '_') "haskell"
17:22:16 <lambdabot>  "ha_____"
17:23:37 <clever> oh, case sensitive
17:23:44 <clever> > map (\c -> if c `elem` "Fa" then c else '_') "foobarbaz"
17:23:45 <lambdabot>  "____a__a_"
17:23:47 <tsizz> yeah i get the map part
17:23:52 <tsizz> updateGuesses guesses letter = do   letter:guesses
17:23:57 <clever> you may want to toLower the guesses and answer
17:23:58 <halogenandtoast> clever: I downcase the word in my game
17:24:01 <tsizz> so how do i return letter:guesses o.O
17:24:09 <tsizz> clever: im assuming input is lower case
17:24:16 <clever> halogenandtoast: perfect!
17:24:37 <halogenandtoast> tsizz: you need to use a different word than return because it's a bit overloaded here.
17:24:41 <tsizz> i just write pure letter:guesses?
17:25:35 <clever> tsizz: probably pure (letter:guesses) or pure $ letter:guesses
17:25:51 <halogenandtoast> tsizz: the answer depends on a lot of things that aren't immediately apparent in the question
17:26:04 <halogenandtoast> are you in a monadic context?
17:26:17 <halogenandtoast> i.e. does your function have an IO result
17:26:34 <tsizz> as in am i gonna output the result..?
17:27:12 <ski> using `do' there suggests some monad
17:27:26 <tsizz> hi ski
17:27:26 <ski> if you say `do letter:guesses', then that monad must be the list monad
17:27:35 <tsizz> and yeah i don't think i need to use do here
17:27:41 <ski> put possibly you had some other monad in mind ?
17:27:59 <ski> or, if not, possibly you don't need any monad there, and then `do' should go
17:28:17 <halogenandtoast> tsizz: it really depends on if the function does any IO
17:28:39 <halogenandtoast> and how you want to use `(letter:guesses)`
17:29:00 <tsizz> halogenandtoast: that'll be my guesses array. but im trying that in prelude and its outputting a string instead of a list
17:29:04 <ski> (i understand what halogenandtoast's trying to say, but really, it doesn't "depend on whether it does I/O". it depends on whether you want to do something monadically or not)
17:29:13 <halogenandtoast> tsizz: Strings are lists of chars
17:29:34 <halogenandtoast> ski: Sorry I am assuming he's doing IO since it's a hangman game
17:29:34 <tsizz> ya okay
17:29:42 <tsizz> yeahi m only using IO 
17:29:44 <halogenandtoast> and they are likely getting letter from getLine
17:30:13 <halogenandtoast> tsizz: you are technically using List which is a monad as well
17:30:22 <halogenandtoast> but that's probably not important here
17:30:26 <ski> halogenandtoast : that's fine. i'm not really criticizing you, at least not much. merely pointing out that i don't think that way of stating it will be helpful, in the long run
17:31:11 <halogenandtoast> ski: yeah it's sometimes hard to distinguish between a universal truth versus what's being applied in the current context
17:31:16 <halogenandtoast> I've already seen their code so I had a rough idea.
17:31:40 <ski> (but hey, we all speak imprecisely, and also speak past each other much. it's not a problem, generally speaking, assuming we attempt to move on, when we realize it)
17:32:22 <ski> halogenandtoast : okay, yea, that helps
17:32:26 * ski didn't see it
17:32:50 <tsizz> uh if i want to call function like
17:32:56 <tsizz> updateGuesses guesses letter
17:32:59 <tsizz> calling it by
17:33:05 <tsizz> updateGuesses guesses head userInput
17:33:16 <tsizz> do i put parantheses like (head userInput)
17:33:22 <halogenandtoast> updateGuesses guesses $ head userInput
17:33:23 <ski> yes, if that's what you mean
17:33:29 <halogenandtoast> you can use parens as well
17:33:33 <tsizz> updateGuesses guesses (head userInput)
17:33:36 <halogenandtoast> updateGuesses guesses (head userInput)
17:33:37 <tsizz> ok
17:33:44 * ski would personally seldom use any `$' at all
17:34:06 <halogenandtoast> More $ more problems?
17:34:13 <ski> (a couple of brackets are nothing to be afraid of)
17:34:19 <tsizz> so yeah im confused still about my output of updateGuesses
17:34:25 <tsizz> should i just do
17:34:33 <tsizz> updateGuesses guesses letter = pure letter:guesses
17:34:40 <ski> tbf, i generally mostly think `$' looks ugly
17:34:44 <tsizz> then guesses = updateGuesses guesses (head userInput)
17:34:45 <halogenandtoast> tsizz: no
17:34:51 <halogenandtoast> pure doesn't "return" a value
17:35:11 <tsizz> oh
17:35:13 <ski> and then there's a lot of people overusing it because they seem to think "oh, that's so cool, no more brackets ever for me !"
17:35:16 <halogenandtoast> pure is a method defined by the monad class which takes a value and adds the monadic context to it
17:35:25 <tsizz> okay
17:35:34 <halogenandtoast> some examples
17:35:40 <halogenandtoast> > pure 1 : Mayba Int
17:35:42 <lambdabot>  error:
17:35:42 <lambdabot>      Data constructor not in scope: Mayba :: t0 -> [f a]error:
17:35:42 <lambdabot>      • Data constructor not in scope: Int
17:35:47 <halogenandtoast> > pure 1 : Maybe Int
17:35:49 <lambdabot>  error:
17:35:49 <lambdabot>      • Data constructor not in scope: Maybe :: t0 -> [f a]
17:35:49 <lambdabot>      • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)error:
17:35:54 <halogenandtoast> > pure 1 :: Maybe Int
17:35:56 <lambdabot>  Just 1
17:35:58 <halogenandtoast> I am jet lagged sorry
17:36:02 <ski> `pure' is a function that returns/computes an action, that, when executed, will have no nontrivial effect, and yield as a result the value passed to `pure' originally
17:36:22 <halogenandtoast> ski: Pretty sure you just started speaking Aramaic here.
17:36:30 <halogenandtoast> ;)
17:36:47 <ski> yea, i was starting to wonder how much of that would be greek to you ;)
17:36:52 <tsizz> hm
17:36:55 <halogenandtoast> me or tsizz ?
17:36:57 <tsizz> so how would i return in imperative way
17:37:01 <ski> both ?
17:37:06 <ski> tsizz : no
17:37:15 <halogenandtoast> I know what you mean by that sentence
17:37:36 <ski> tsizz : there is no "abort what you're currently doing, and yield this as the result value" (thankfully)
17:38:23 <tsizz> so how do i get the value from the function?
17:38:35 <ski> there is nothing resembling `break',`continue',`return' (in say C, or Java) on that level, in Haskell
17:38:42 <halogenandtoast> tsizz: whatever is the value it evaluates, it will return
17:38:49 <halogenandtoast> updateGuesses guesses letter = letter:guesses
17:38:51 <halogenandtoast> for example
17:38:52 <tsizz> halogenandtoast: okay 
17:38:57 <ski> tsizz : arrange for it to be placed where the return value is expected to be placed
17:38:59 <tsizz> thats what i was thinking
17:39:00 <halogenandtoast> or if you wanted to get crafty
17:39:03 <tsizz> had to do that in racket
17:39:09 <halogenandtoast> updateGuesses = flip (:)
17:39:16 <halogenandtoast> but I might get shunned for that
17:39:30 <tsizz> so i can put that whole function one line right
17:39:38 <ski> halogenandtoast : one step of mind-fuckery at a time, please ;)
17:39:52 <halogenandtoast> that's sort of up to you, but yes, you can put that function on one line
17:40:30 <ski> tsizz : hm, i don't think that sort of thing would be very common in Racket, either, actually ..
17:41:04 <ski> tsizz : talking about some custom syntax that's not in R^{5}RS ?
17:42:05 <ski> ("that sort of thing" being "abort what you're currently doing and yield this as main result" .. but perhaps i misread what you meant ?)
17:42:51 <halogenandtoast> tsizz: it's worth noting that there aren't really "lines" in haskell, a function can't really have 2 lines
17:43:02 <halogenandtoast> the `do` syntax makes it look like you have multiple lines
17:43:08 <halogenandtoast> but they all get connected by an operator
17:43:15 <ski> (for that matter, C isn't line-oriented, either)
17:43:18 <halogenandtoast> either (>>=) or (>>)
17:44:43 <halogenandtoast> ski: hmm, I am sort of intersted to know what you mean there, I would think of it being rather imperitive where the result of a line is not threaded to the next line.
17:45:15 <ski> halogenandtoast : you do know that you can break the line anywhere, not just after `;'s and `{'s, right ?
17:45:52 <tsizz> how's this look? https://pastebin.com/sWmNXPPi
17:45:53 <ski> you could think of C commands as automatically being inside a `do'
17:46:15 <ski> (there are still some differences, sure. but perhaps less than you'd initially think)
17:46:15 <halogenandtoast> ski: you would be wrong to think that though :p
17:46:35 <ski> halogenandtoast : please elaborate on that ?
17:46:51 <ski> of course, you do have to break line after CPP directives
17:47:04 <ski> (unless it's meant to go on)
17:48:00 <halogenandtoast> int foo() { printf("Hello\n"); return 1; printf("Hello\n") } 
17:48:44 <ski> yes ?
17:49:14 <ski> tsizz : put a `let' before `moreGuesses', and indent `nextState' under it to line up with `moreGuesses'
17:50:14 <ski> tsizz : and instead of `== False', you could use `not' .. though i suppose in your case, you could use `unless' instead of the whole `if'-`then'-`else'
17:50:17 <halogenandtoast> Those lines aren't glued together in any way, they are stepped through, but the context isn't retained, you can jump in and out of any context you want)
17:50:42 <ski> i don't know what you mean by context, in this .. eh, context ?
17:51:33 <halogenandtoast> ski: this is probably one of those situations where my language skills aren't good enough to explain, but in my heart I feel that drawing a parallel between the two is disingenious
17:51:48 <ski> hm, possibly you mean that that `return' can abort the progress of execution of commands in the body of `foo'
17:52:02 <halogenandtoast> That's definitely one of cases here.
17:52:02 <ski> which of course is true
17:52:12 <tsizz> hm Expected IO Char, Actual [Char] from the else nextState 
17:52:16 <clever> ski: ive also been confused about how return doesnt stop it from running things in that function
17:52:19 <ski> (i did say "there are still some differences, ...")
17:52:24 <tsizz> is that because of the do clause? it is expecting an IO 
17:52:34 <halogenandtoast> clever: In that function the compiler will remove the last line
17:52:38 <halogenandtoast> so there's that lol
17:52:52 <halogenandtoast> well... will likely remove that last line
17:52:53 <ski> tsizz : what should happen in the `else' case ?
17:53:01 <halogenandtoast> suppose you could turn off optimizations to have it leave it
17:53:10 <halogenandtoast> but it turns into a jmp anyways
17:53:15 <halogenandtoast> so it's unreachable
17:53:53 <tsizz> ski: output the final word 
17:54:02 <ski> halogenandtoast : *nod*. i don't think that contradicts what i was talking about (rather, i was trying to hint at this difference)
17:54:14 <tsizz> like hangman, once you guess the last character. outputs the whole guessed word
17:54:28 <halogenandtoast> ski: The main different I feel is that there is additional context/information passed between the lines, and the monad is free to decide what that context/information is (provided it follows the monadic laws)
17:54:39 <tsizz> little worried to it said expected IO Char instead of IO [Char] 
17:55:01 <ski> tsizz : the type of `getUserInput word nextState moreGuesses' will be `IO Something', since you have a `do' to the right of the `=' at the top, and that `do' is expressing `IO'-actions, e.g. because of `getLine' being an `IO'-action
17:55:34 <ski> tsizz : so, the type of the `else' branch must also be `IO Something'. but you decide what `Something' should be
17:55:45 <halogenandtoast> ski, and how everything inside that do has to be an action of that monad ;)
17:56:08 <tsizz> ski: but i should use do since im using getLine. so i should change the output to match IO something
17:56:35 <halogenandtoast> tsizz: I think output is the wrong term here
17:57:21 <tsizz> halogenandtoast: uh i mean like output of the function?
17:57:30 <ski> halogenandtoast : btw, i'm uneasy with you saying "the monad this" and "the monad that", as if a monad would be a run-time thing that would be executed at run-time. that would be a monadic action, not a monad. `getLine' is a monadic action, an `IO'-action. `IO' itself (together with its `Monad' instance, which basically consists of implementation of `return' and `(>>=)' for `IO') is the monad
17:57:52 <halogenandtoast> ski: that's fair, I have a hard time with the term "action"
17:58:07 <halogenandtoast> even if it is the right term
17:58:16 <halogenandtoast> I'm not saying I'm against it
17:58:19 <tsizz> actually its not the output of the function. just a varaible i want "returned"
17:58:21 <halogenandtoast> I just don't think about it like that
17:58:22 <ski> halogenandtoast : sorry if you're clear on this distinction, but it appears beginners get this wrong regularly, so i'm used to pointing it out, if i suspect that they may not fully realize the distinction
17:58:51 <ski> tsizz : change how ?
17:59:14 <tsizz> no idea
17:59:24 <ski> tsizz : didn't you just say you wanted some `String' or other presented as the result of executing the `IO'-action you're defining ?
17:59:33 <tsizz> but wait. first thing. essentially i need to use "do" if im doing IO stuff in the function
17:59:45 <tsizz> correct..?
18:00:03 <halogenandtoast> tsizz: I mentioned this before you don't need to use `do` but it makes things a lot easier (well subjectively easier)
18:00:05 <tsizz> or >>== which is syntatic sugar for do as halogenandtoast mentions
18:00:15 <ski> tsizz : `return' (or `pure', if you prefer. same thing) is how you convert from a `Foo', to an `M Foo', for `M' a monad. in your case `Foo' would then be `String', and `M' would be `IO'
18:00:47 <halogenandtoast> > pure "Foo" :: IO String
18:00:49 <lambdabot>  <IO [Char]>
18:01:13 <tsizz> :t putStrLn
18:01:14 <lambdabot> String -> IO ()
18:02:01 <ski> halogenandtoast : there are other terms that are also through around. like "computation", or (in some circumstances) "collection". when using more pictorial language, "recipe". also "instruction (sequence)". some people even say "context" and probably more things i find weird
18:02:31 <ski> halogenandtoast : mostly, i just don't want you to call e.g. `getLine' a "monad". `IO' is the monad
18:02:41 <halogenandtoast> Did I call getLine a monad?
18:02:55 <ski> nope
18:03:18 <ski> (but i wouldn't want you to. that not holding just for the `getLine' example)
18:03:21 <halogenandtoast> Okay, yeah we are in agreement, if I did something similar to that it might have been a disconnect between my brain and keyboard.
18:04:45 <halogenandtoast> I tend to refer to monads as context not actions
18:05:00 <halogenandtoast> so for example IO () is pure context with no touchable value
18:05:17 <halogenandtoast> but you could replace the term context here with action I guess
18:05:32 <ski> i think what i reacted to was "and the monad is free to decide what that context/information is (provided it follows the monadic laws)"
18:06:00 <halogenandtoast> ski: what I'm trying to imply there is the definition of (>>=) and (>>) decide
18:06:17 <ski> and, now that i reread it, it sounds more like you're talking about the definition of `return' and `(>>=)' for the monad deciding the behaviour, the "feel", of the monad
18:06:27 <halogenandtoast> yeah
18:06:28 <ski> so, i'm sorry for causing a ruckus about that
18:06:39 <halogenandtoast> no worries, this stuff is generally hard to talk about
18:06:45 <ski> true that
18:06:50 <halogenandtoast> because you either end up abstracting it to the point where you are wrong
18:07:02 <halogenandtoast> or you bust out category theory and 80% of people drop off
18:07:16 <clever> λ> let thing = (undefined :: State -> String -> State) in getLine >>= pure . (thing undefined)
18:07:30 <clever> this will read a single line of input, then pass it to a pure thing, that applies the line to some state
18:07:48 <tsizz> oh now i can't output the answer after the function bc its a IO string :(
18:07:55 <clever> which then opens up testing the `thing` without having to give it IO
18:08:04 <halogenandtoast> tsizz
18:08:07 <tsizz> hi
18:08:11 <ski> tsizz : why not ?
18:08:19 <tsizz> oh
18:08:23 <tsizz> well i was trying putStrLn
18:08:30 <halogenandtoast> :t putStrLn
18:08:31 <lambdabot> String -> IO ()
18:08:32 <ski> clever : you could use `fmap', i hope you know
18:08:40 <ski> tsizz : should be fine ?
18:08:41 <halogenandtoast> :t fmap
18:08:42 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:08:55 <halogenandtoast> ski I would have used (>>=)
18:09:00 <halogenandtoast> but that's me
18:09:06 <clever> ski: still learning the more complex parts
18:09:07 <tsizz> it says expected String, actual IO [Char]
18:09:07 <halogenandtoast> getLine >>= putStrLn
18:09:20 <tsizz> it seems weird what im doing
18:09:20 <ski>   return . f =<< m  =  fmap f m  -- clever, see this monadic law
18:09:39 <tsizz> function do getLine blah blah pure String.
18:09:43 <clever> λ> let thing = (undefined :: State -> String -> State) in fmap (thing undefined) getLine
18:09:44 <halogenandtoast> Oh you were talking to clever
18:09:47 <halogenandtoast> womp womp
18:09:49 <tsizz> then i have to convert the pure String back to a normal String. is that not strange?
18:10:02 <clever> ski: i think this does the same thing
18:10:10 <ski> tsizz : you're doing something strange, then
18:10:12 <halogenandtoast> tsizz: you... can't convert an IO String back to a normal string...
18:10:20 <ski> clever : yes, that's the point
18:10:32 <clever> nice
18:10:53 <halogenandtoast> tsizz: you need to use something like this
18:10:54 <tsizz> halogenandtoast: my bad i was just using the IO string to create a different string. then i made that different string an IO so i could "return" it
18:10:58 <halogenandtoast> :t (>>=)
18:10:59 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:11:03 <ski> @quote out.of.IO.String
18:11:03 <lambdabot> monochrom says: How do I extract the IO out of IO String?
18:11:07 <ski> @quote IO.String.to
18:11:07 <lambdabot> kmc says: it is not hard to troll #haskell for real; you just have to get confused and confrontational about how to convert IO String to String
18:11:22 <tsizz> haha
18:11:40 <halogenandtoast> so putStrLn has type (String -> IO ())
18:11:41 * ski likes the former one, more :)
18:11:50 <halogenandtoast> so if a is String and b is ()
18:11:55 <halogenandtoast> and m is IO
18:12:05 <halogenandtoast> IO String -> (String -> IO ()) -> IO ()
18:12:24 <halogenandtoast> so if you have a function that returns an IO String (let's call it foo)
18:12:28 <halogenandtoast> and you want to print it
18:12:32 <tsizz> mhm
18:12:32 <halogenandtoast> foo >>= putStrLn
18:12:42 <halogenandtoast> is one way to do this
18:12:42 <ski> (then `foo' is not a function, but an action)
18:12:51 <clever> you can also, `str <- foo \n putStrLn str`
18:12:57 <clever> if your in a do block
18:13:02 <ski> aye
18:13:23 <halogenandtoast> ski: I like to think of it as a function that returns an action.
18:13:28 <tsizz> oh
18:13:29 <tsizz> im dumb
18:13:32 <clever> after using do and <- everywhere, ive gotten a good grasp on the basics
18:13:33 <tsizz> i was just using = sign
18:13:42 <clever> and now i'm starting to use <$>, <*> and . more heavily
18:14:07 <halogenandtoast> clever: before you know it, you'll be using lenses ;)
18:14:07 <tsizz> haskell doesn't handle whitespace well does it
18:14:16 <halogenandtoast> tsizz: it handles it exceptionally well
18:14:21 <tsizz> oh
18:14:23 <halogenandtoast> but you might not
18:14:24 <tsizz> then im confused
18:14:32 <tsizz> it says my <- isn't in a do block >:(
18:14:35 <clever> halogenandtoast: already using basic lenses :P
18:14:36 <tsizz> BUT IT IS
18:14:46 <halogenandtoast> is it indented
18:14:53 <halogenandtoast> the same as the other lines in the do block?
18:15:02 <halogenandtoast> clever: nice!
18:15:07 <tsizz> oh
18:15:07 <halogenandtoast> What about Free monads?
18:15:10 <tsizz> forgot to remove the lete
18:15:11 <tsizz> let*
18:15:40 <clever> halogenandtoast: still need to learn how to make them, but i think ive used 2 of them before
18:16:04 <halogenandtoast> data Free f k = Pure k | Impure (f (Free f k))
18:16:07 <halogenandtoast> something like that
18:16:17 * hackage cabal-cache 0.2.0.2 - CI Assistant for Haskell projects  https://hackage.haskell.org/package/cabal-cache-0.2.0.2 (haskellworks)
18:16:30 <clever> halogenandtoast: the hard part is making it accept a `do` block
18:16:32 <tsizz> i got my-project-exe: Prelude.head: empty list
18:16:37 <tsizz> is that an error... or it returned empty list... 
18:16:51 <clever> tsizz: you ran head on an empty list, which is an error
18:16:57 <halogenandtoast> tsizz: it means you called (head []) somewhere
18:17:11 <halogenandtoast> head is not a pure function and can return a bottom value
18:17:26 <clever> halogenandtoast: still need to memorize what bottom means :P
18:17:33 <tsizz> halogenandtoast: hm i think its bc i defined two variables in one let?
18:17:49 <clever> tsizz: that wont do it
18:17:57 <halogenandtoast> clever: it can be a number of things but generally there are values at the "bottom" which represent everything
18:18:02 <halogenandtoast> undefined for example
18:18:05 <tsizz> oh okay
18:18:08 <tsizz> i found what was wrong
18:18:19 <halogenandtoast> someone might chime in to correct me where I am wrong
18:18:25 * halogenandtoast looks at ski
18:18:25 <clever> halogenandtoast: ah
18:18:40 <ski> halogenandtoast : all functions in Haskell take exactly one argument
18:19:08 <halogenandtoast> I wasn't debating that?
18:19:15 <halogenandtoast> I know me some lambda calculus
18:19:27 <clever> i learned that bit from the nix language
18:19:40 <ski> ("I like to think of it as a function that returns an action." ?)
18:19:58 <clever> in nix, it looks like `a: b: a * b`
18:20:03 <halogenandtoast> ski: touche
18:20:09 <clever> but in haskell, you can do `\a b -> a * b` and its less clear
18:20:26 <clever> also, `foo a b = a * b` is also less obvious
18:20:27 <halogenandtoast> clever: I prefer (*)
18:20:31 <ski> (sorry, i should have given what i replied to in conjunction with the reply)
18:20:44 <clever> but the `foo :: Int -> Int -> Int` sort of shows that its a function returning a function
18:21:07 <halogenandtoast> ski: no worries, I am used to being wrong :D
18:21:18 <ski> clever : is that genuinely less clear, or just appearing so, because you're more used to the Nix syntax, by now ?
18:21:46 <halogenandtoast> \a -> \b -> a * b
18:21:49 <c_wraith> clever: Haskell is full of things that are not the easiest to learn, but pay off in the long run one way or another.  Currying everything by default is just one example.
18:21:50 <halogenandtoast> is that any better?
18:22:05 <tsizz> let nextState = [if c == head moreGuesses then c else '_' | c <- word]
18:22:23 <tsizz> instead of head moreGuesses here. how can i test the whole list
18:22:39 <halogenandtoast> :t elem
18:22:40 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
18:22:41 <tsizz> im thinking to use the notation (x:xs) somehow shrug
18:23:00 <tsizz> but taht returns boolean 
18:23:09 <halogenandtoast> so does c == head moreGuesses
18:23:21 <clever> ski: more about how obvious it is, that `a: b: a*b` is clearly 2 functions, just like `\a -> \b -> a*b` is 2 functions
18:23:25 <tsizz> halogenandtoast: oh woops haha
18:23:31 <clever> but `\a b -> a *b` makes that less obvious
18:23:39 <c_wraith> clever: the unifying observation here should be that when programmers write code, they tend to write the easiest thing that works right now.  Haskell often makes the easiest thing the best option.
18:23:50 <ski> clever : ah, so you're speaking about that sugaring, in particular
18:23:56 <clever> ski: yeah
18:24:05 <clever> the sugar can hide a lot of things
18:24:09 <ski> indeed
18:24:14 <c_wraith> Can it, really?
18:24:24 <clever> from those that dont know all the sugar :P
18:24:44 <c_wraith> But that's an argument that newbie ignorance is as important as expert ergonomics.
18:24:46 <ski> @quote the.semicolon
18:24:46 <lambdabot> AlanPerlis says: Syntactic sugar causes cancer of the semicolon.
18:24:51 <tsizz> im playing my hangman right now
18:24:53 <tsizz> _iolen_l_
18:24:55 <tsizz> WTF IS THIS WORD
18:25:04 <tsizz> stupid fake word probably D:
18:25:21 <tsizz> oh
18:25:23 <tsizz> such a good word
18:25:29 <tsizz> guess im terrible at hangman
18:25:39 <tsizz> yay it worked =)
18:25:46 <clever> c_wraith: not like the sugar stops you from using things though
18:26:09 <c_wraith> clever: if you are forced to write it by hand, you'll tend not to.  that *does* prevent using it.
18:26:59 <c_wraith> clever: remember, programming is a social activity.  Things need to be measured in terms of the way they tend to influence use of the language by its actual users.
18:28:45 <halogenandtoast> I am a fan of useful sugars
18:29:13 <halogenandtoast> Arguably I'd say OverloadedStrings turns "" into a sugar which I am a big fan of
18:29:16 <clever> yeah, the do block has let me go this long without learning how to use >>=, lol
18:29:35 <clever> halogenandtoast: i use that all the time!
18:30:26 <halogenandtoast> It lets me be adequately lazy, but it doesn't hide much from me, because if I get it wrong, I get a type error
18:30:32 <tsizz> is this correcy way of defining the function and then pattern matching ?
18:30:35 <tsizz> correct*
18:30:36 <tsizz> https://pastebin.com/s34V5Vn5
18:31:09 <tsizz> im so scared to define the function signature 
18:31:16 <tsizz> probably better of not trying it hahaha
18:31:36 <halogenandtoast> sure that's fine
18:31:56 <halogenandtoast> tsizz: I'd suggest always writing the function signatures
18:32:06 <halogenandtoast> in fact I generally write those first
18:32:19 <halogenandtoast> and write most function bodies as undefined
18:32:33 * ski is a fan of some occasional syntactic salt
18:32:35 <halogenandtoast> and then fill in the games
18:32:51 <halogenandtoast> ski: what about syntactical vinegar?
18:33:03 <ski> i dunno, do you have an example ?
18:33:05 <halogenandtoast> *syntactic vinegar
18:33:22 <halogenandtoast> off hand no, but the idea is that the syntax is bad to deliberately keep you from using it.
18:33:42 * geekosaur votes for TH
18:33:57 <tsizz> if i define function signature and then input or it ouput something different it'll error out right?
18:33:57 <halogenandtoast> geekosaur: get out!
18:33:59 <ski> tsizz : that looks, ok
18:34:15 <halogenandtoast> tsizz: yeah you'll get a type error
18:34:18 <tsizz> so im pretty safe just trying to figure out how to define the signatures since i wrote it already
18:34:26 <tsizz> ski: just ok? :'(
18:34:27 <ski> tsizz : assuming you want to check there's no `_' in the `String'
18:34:38 <tsizz> ski: yup 
18:34:39 <nshepperd> you catch more bugs with syntactic honey than with syntactic vinegar
18:34:41 <ski> tsizz : well, insted of guards, you could use `&&'
18:34:56 <halogenandtoast> tsizz: there are other ways
18:35:14 <halogenandtoast> > any (== '_') "_abc"
18:35:15 <lambdabot>  True
18:35:20 * ski . o O ( "think logically/declaratively, not procedurally/operationally" )
18:38:06 <ski> halogenandtoast : sounds like the salt, to me
18:38:23 <ski> halogenandtoast : would the vinegar be stronger than the salt ?
18:38:38 <halogenandtoast> ski: I don't know but it sounds like we're making pickles tonight
18:39:30 <tsizz> so instead of List
18:39:31 <tsizz> i write String
18:39:34 <tsizz> right..
18:39:45 <ski> in Mercury, every time you call an impure predicate or function (mostly only intended for low-level FFI interface, to be wrapped in a declarative higher-level interface. I/O is typically done declaratively, using uniquenesS), you have to prepend the call with the keyword `impure'
18:39:50 <halogenandtoast> we're missing a lot of context to that question tsizz 
18:39:54 <ski> they call that "syntactic salt"
18:40:22 <ski> where did `List' come from ?
18:40:49 <halogenandtoast> ski: yeah it sounds like the same thing, but salt tends to make things more palatable, where vinegar arguably sours things
18:41:02 <halogenandtoast> I like both salt and vinegar and especially together on potato chips
18:41:09 <halogenandtoast> so :shrug:
18:41:09 <ski> well, too much salt becomes unpalatable
18:41:27 <ski> and it can sting, making you pay attention
18:41:32 <halogenandtoast> ski: true, and I suppose that's a good analogy
18:41:45 * ski supposes they thought of something like that
18:42:18 <tsizz> String -> String -> String -> IO String
18:42:23 <halogenandtoast> tsizz: String is an "alias" for [Char]
18:42:35 <tsizz> for function that takes in 3 strings and returns IO String bc its in a do block
18:42:56 <tsizz> ok yeah im only dealing with char and strings
18:42:58 <halogenandtoast> it doesn't "return an IO String because it's in a do block".
18:43:20 <halogenandtoast> it returns an IO String because you peform some IO action
18:43:30 <halogenandtoast> that you happened to put in a do block
18:45:02 <monochrom> ski: Were you looking for this ultimate question? http://www.vex.net/~trebla/photo/unorganized/IO-String.png
18:45:04 <tsizz> halogenandtoast: but just i use getLine?
18:45:09 <tsizz> just bc i use getLine
18:45:18 <tsizz> what if use getLine and don't do anything with it. 
18:45:26 <tsizz> it still exects IO string?
18:45:30 <ski> monochrom : hm, that the pushout one ?
18:45:34 <halogenandtoast> @foo xs ys = do { x <- xs; y <- ys; return $ x * y }
18:45:34 <lambdabot> Maybe you meant: yow todo faq do
18:45:34 <monochrom> Yeah!
18:45:42 <halogenandtoast> @define foo xs ys = do { x <- xs; y <- ys; return $ x * y }
18:45:43 <lambdabot>  Defined.
18:45:46 <halogenandtoast> :t foo
18:45:47 <lambdabot> (Monad m, Num b) => m b -> m b -> m b
18:46:02 <ski> i think i wasn't in particular thinking about that, no
18:46:17 <ski> (but it may be good to be reminded, regardless)
18:46:21 <monochrom> But it's much better than just IO String -> IO!
18:46:40 <ski> @undo foo xs ys = do { x <- xs; y <- ys; return $ x * y }
18:46:40 <lambdabot> foo xs ys = xs >>= \ x -> ys >>= \ y -> return $ x * y;
18:46:42 <tsizz> halogenandtoast: but what if i dont use the IO strings
18:47:05 <tsizz> like do { x<- xs; return 1 * 2
18:47:16 <halogenandtoast> ski I was talking about the do block to tsizz so not sure here what you mean
18:48:02 <halogenandtoast> @define foo xs = do { x <- xs; return 1 * 2 }
18:48:03 <lambdabot>  .L.hs:165:1: error:
18:48:03 <lambdabot>      Equations for ‘foo’ have different numbers of arguments
18:48:03 <lambdabot>        .L.hs:(165,1)-(168,21)
18:48:14 <halogenandtoast> @unfo foo
18:48:14 <lambdabot> foo
18:48:16 <halogenandtoast> @define foo xs = do { x <- xs; return 1 * 2 }
18:48:17 <lambdabot>  .L.hs:165:1: error:
18:48:17 <lambdabot>      Equations for ‘foo’ have different numbers of arguments
18:48:17 <lambdabot>        .L.hs:(165,1)-(168,21)
18:48:21 <monochrom> "main = do { getLine; return 0 }" will still wait for input. (And then goes on to discard it.)
18:48:23 <halogenandtoast> curse you lambda bot
18:48:49 <tsizz> halogenandtoast: hm i think i remember reading haskell seperartes impure for pure. so just if any io action is in it, then it will exepect io output and not any other kind of outpout
18:49:02 <geekosaur> there's only total undef, not individual
18:49:10 <ski> halogenandtoast : hm, nothing in particular related to that, i think
18:49:20 <halogenandtoast> @undef foo
18:49:20 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
18:49:29 <monochrom> Similarly, "do { [1,2,3]; return 0 }" will get you [0,0,0] not [0], showing that whatever "effect" is there is still there, even if "I don't use the answer"
18:50:02 * ski . o O ( an ostrich monad ? )
18:50:15 <tsizz> i define function signature for main as well?
18:50:22 <monochrom> No need.
18:50:44 <monochrom> Also, you should not have needed to ask. You should have been able to perform the experiment yourself.
18:51:11 <tsizz> well u donit need to define any signature? i asking if its good practice i mean
18:51:15 <monochrom> Because there is a big difference between "monochrom said so" and a real observation you see in your own eyes.
18:51:16 <clever> monochrom: weird!
18:51:18 <halogenandtoast> also monochrom that example is lots of fun
18:51:46 <monochrom> Even good practice doesn't give main a type signature.
18:51:56 <monochrom> Other helper functions, maybe.
18:51:57 <halogenandtoast> > [1,2,3] >> [0]
18:51:59 <lambdabot>  [0,0,0]
18:52:03 <halogenandtoast> is what it is doing
18:53:35 <monochrom> The list example is actually a logical conclusion if you start with a premise "the empty list is like Nothing, and both model failure".
18:54:44 <monochrom> In other words you expect do { []; return 0 } = [], do { Nothing; return 0 } = Nothing, because a failure in the middle causes holistic failure.
18:55:13 <monochrom> Now you generalize from "my list has 0 items" to "my list has n items".
18:55:20 <ski> monochrom : i suppose i'm no good practitioner :)
18:56:01 <halogenandtoast> I mean once you see it's doing >> it's pretty easy to see the "answer" is dropped m >> k = m >>= \_ -> k
18:56:33 <monochrom> That too.  Trust algebra.  Don't trust yourself.
19:00:06 <monochrom> . o O ( You must learn free algebras. Free algebras will set you free. )
19:00:41 <halogenandtoast> I mean, I could also not, I'm fine with these chains
19:00:54 <halogenandtoast> They're shiny
19:01:48 <monochrom> Hey I think that's OK afterall! Chain-completeness is why recursion is well-defined!
19:02:27 <halogenandtoast> monochrom: thanks for making me think about how to define the y-combinator again...
19:02:44 <monochrom> Actually this one is totally not about the Y combinator.
19:03:40 <halogenandtoast> :shrug: you can't control what you make me think about
19:03:55 <halogenandtoast> ;)
19:04:23 <monochrom> In denotational semantics, recursive code like "f x = ... f ..." is given the following semantics. (TLDR build a sequence, then ask about the limit of that sequence, then declare the limit is the semantics of f.)
19:04:49 <monochrom> Define f0 to be the everywhere-undefined function. f x = undefined, for all x.
19:04:56 <monochrom> err, f0 x = undefined, for all x.
19:05:23 <monochrom> Define f1 x = ... f0 ...  In other words, take your recursive code, replace LHS f by f1, RHS f by f0.
19:05:56 <monochrom> Similarly define f2 x = ... f1 ...   ad infinitum nauseum perpetuatum.
19:07:11 <halogenandtoast> I mean, that all sounds pretty sound, but I don't (and probably won't) understand the proof
19:08:02 <monochrom> It turns out f0 <= f1 <= f2 <= ...  If I'm allowed to use <= to mean information order.  TLDR: for functions, f<=g iff for all x, g x is at least as defined as f x.
19:08:23 <monochrom> When this happens, we say that [f0, f1, f2, ..] is a chain.
19:09:15 <monochrom> Then, the assertion "you're working in a chain-complete space" means that every chain has a limit. Now declare "f means the limit of [f0, f1, f2, ...]"
19:12:26 <z0>  do petter guards match against "unlocal "variables" no matter what?
19:12:48 <monochrom> I don't understand that.  Do you have an example?
19:13:17 * hackage pandoc-crossref 0.3.4.1 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.3.4.1 (lierdakil)
19:15:38 <z0> im tempted to do something like 'f | whatever <- x = wtv' where x is a global value but something in my gut tells me it's not good form
19:17:01 <monochrom> It could be OK depending on what you use it for and what's the surrounding and what other choices you have.
19:55:17 * hackage standalone-haddock 1.2.0.0 - Generate standalone haddock documentation for a set of packages  https://hackage.haskell.org/package/standalone-haddock-1.2.0.0 (KarlVoelker)
20:15:17 * hackage standalone-haddock 1.3.0.0 - Generate standalone haddock documentation for a set of packages  https://hackage.haskell.org/package/standalone-haddock-1.3.0.0 (KarlVoelker)
20:42:20 --- mode: ChanServ set +o glguy
20:42:21 --- mode: glguy set +b *!*@*/gruntmaster6000
20:52:40 <DigitalKiwi> what they do?
21:19:36 <dyl> Did someone say chains? (monochrom)
21:20:11 <dyl> What if every chain in some poset P has an upper bound in P?
21:20:26 <dyl> 🙃
21:22:13 <dyl> (In this case a poset of functions...) 
22:33:04 <jusss> where I'm wrong?  https://paste.ubuntu.com/p/5Sr2vMYbS2/
22:33:51 <cocreature> jusss: what do you mean by “wrong”? This is not an error as such, you just need to fill something in for the underscore at the end of the line
22:35:01 <jusss> cocreature: use 'whatever' instead of '_' ?
22:35:39 <cocreature> jusss: oh do you expect the underscore at the right refer to the underscore to the left?
22:35:45 <cocreature> If so yeah, just use some other name
22:36:03 <cocreature> if you use _ in a pattern match, the value will not be bound to an underscore. It won’t be bound at all
22:36:32 <jusss> ok
22:41:32 <jusss> cocreature: in a pattern match,' _' in the left of '=' will match everything, and '_' in the right of '=' is just a normal variable, right?
22:41:59 <jle`> i'd say that to the left of =, _ is just a normal variable
22:42:05 <jle`> or at least variable identifier
22:42:22 <jusss> and the right?
22:42:24 <jle`> actually nevermind, i'm wrong; it's one that you can re-use in the same pattern more than once
22:42:38 <tdammers> _ is special in pattern matches
22:43:30 <jle`> jusss: on the right i think syntatically it plays the same role as a normal variable, but it triggers a 'typed hole' error upon compilation
22:43:43 <jle`> yeah, _ is special in patterhs (to the left of =), don't listen to me :)
22:44:05 <jle`> _ acts like an identifier in pattern syntax, but it cannot be bound and any bindings are ignored
22:44:22 <jle`> so it's the same role syntactically in both cases, but different semantically
22:46:44 <jusss> jle`: so '_' in the left of '=‘ match all, on the right, just a normal variable, right?
22:46:56 <tdammers> on the right, it's a hole
22:47:08 <jusss> what is a 'hole'?
22:47:10 <jle`> so to clarify the mess of what i said, syntactically they fit anywere a normal variable or identifier would go
22:47:12 <dminuoso> @tell Cale Hey I just realized that what we talked about yesterday I know already: withDict :: Dict a -> (a => r) -> r 
22:47:12 <lambdabot> Consider it noted.
22:47:18 <jle`> but semantically they mean different things
22:47:52 <jle`> jusss: to the right of =, it essentially is a normal variable that is always unbound (since you can't bind _), *but* ghc gives it special treatment when doing error reporting
22:48:07 <tdammers> https://wiki.haskell.org/GHC/Typed_holes <- jusss 
22:48:35 <tdammers> before the Typed Holes feature in GHC, _ was just a regular variable (and it still is if you disable Typed Holes)
22:48:51 <tdammers> but because it's special in pattern matches, it cannot ever be bound to anything
22:49:01 <jle`> > True || blahblah
22:49:03 <dminuoso> jusss: Both x and _ `f x _ = ...` are so-called irrefutable pattern matches, the difference being that for the first pattern the result is bound to a variable named `x`, and for the _ pattern you cannot refer to it anymore.
22:49:03 <lambdabot>  error: Variable not in scope: blahblah :: Bool
22:49:06 <jle`> > True || _
22:49:08 <lambdabot>  error:
22:49:08 <lambdabot>      • Found hole: _ :: Bool
22:49:08 <lambdabot>      • In the second argument of ‘(||)’, namely ‘_’
22:49:15 <jusss> tdammers: so '_' shouldn't show on the right of ' =' ?
22:49:23 <jle`> the only difference effectively in expressions is that the error message is different
22:49:28 <tdammers> jusss: not if you want the code to compile without errors
22:49:40 <jle`> jusss: _ is useful for debugging, but shouldn't be there in 'completed' code
22:49:55 <dminuoso> jusss: Even more special are identifiers starting with an underscore. Say `_foo` is doubly special. :)
22:49:56 <jle`> jusss: note how in both cases, it's the same error essentially, but the error reported is different
22:50:05 <jle`> the error for _ is more useful for debugging and helping interactive programming
22:50:15 <dminuoso> jusss: That is, if _foo is not defined you get the error for a typed hole, but if it is defined then _foo becomes a regular variable.
22:50:33 <tdammers> and of course this all holds only at the term level. type-level, _ is also special, but in a slightly different (but related) way
22:50:47 <dminuoso> (Identifiers starting with underscore are particularly common when you deal with lenses for conventional reasons)
22:51:41 <hololeap> i don't understand how UnliftIO is basically (m a -> IO a), but withRunInIO :: ((forall a. m a -> IO a) -> IO b) -> m b
22:51:55 <dminuoso> hololeap: It has to do with the type system.
22:51:58 <hololeap> one is going from m to IO and the other is the opposite?
22:52:11 <dminuoso> hololeap: No, its still in negative position due to the extra lambda.
22:52:21 <dminuoso> withRunInIO $ \unliftio -> ....
22:52:29 <dminuoso> Perhaps the usage illustrates this :)
22:52:52 <jusss> can use type to describe that object operation in other language?
22:54:41 <jle`> hololeap: positive is something the function 'gives', and negative is what the function 'expects', and it flips when you have nested functions as input
22:54:52 <hololeap> dminuoso: i'm mostly curious in how to implement it, especially in terms of
22:54:54 <hololeap> instance MonadUnliftIO m => MoadUnliftIO (WrapperT m a)
22:54:58 <jle`> so unliftIO :: (- -> +), essentially
22:56:21 <hololeap> ok, but IO is in the positive, nested in the negative, twice, so how do you determine what IO is?
22:56:27 <dminuoso> hololeap: withRunInIO $ \io -> withHandle (\h -> do { r <- fetchFromDatabase h; io someReaderAction r } )
22:57:22 <dminuoso> Oh, missing some parens
22:57:29 <dminuoso> hololeap: withRunInIO $ \io -> withHandle (\h -> do { r <- fetchFromDatabase h; io (someReaderAction r) } )
22:58:02 <dminuoso> Where `someReaderAction :: Record -> ReaderT Env IO ()` perhaps, and `withHandle :: (Handle -> IO ()) -> IO ()
22:59:12 <hololeap> ok, maybe it would help if i was specific. i wrote this last night and was thinking that it might be cleaner in terms of withRunInIO, but i ended up getting lost
22:59:15 <hololeap> http://dpaste.com/1MW9M80
23:01:08 <hololeap> dminuoso: what is withHandle?
23:01:38 <hololeap> oh, nvm, you defined it
23:01:53 <dminuoso> withRunInIO inner = askUnliftIO >>= \u -> liftIO (inner (unliftIO u))
23:02:00 <dminuoso> Which Im sure you know :P
23:02:25 <dminuoso> hololeap: I think askUnliftIO is easier to implement actually
23:02:54 <hololeap> ok... i almost had that, but the liftIO seemed wrong somehow
23:03:17 * hackage warp 3.2.27 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.2.27 (KazuYamamoto)
23:03:38 <dminuoso> hackage: withRunInIO is tailored for how you would use it.
23:03:42 <dminuoso> Uh. hololeap!
23:03:55 <hololeap> lol
23:04:20 <dminuoso> hololeap: Generally you'd use this when you are inside a monad transformer stack already and have to use some library function that has IO in a negative positoin
23:04:40 <dminuoso> such as `withHandle` or maybe `withTransaction`, something along these lines
23:05:22 <dminuoso> It would be annoying to write liftIO every time you do: withRunInIO $ \io -> liftIO (withHandle (\h -> ... io (some action); ...))
23:05:45 <dminuoso> Its just a guess though
23:06:16 <hololeap> i was trying to write `instance (Alternative f, MonadUnliftIO m) => MonadUnliftIO (CofreeT f m)`
23:40:22 <fen> is this something that would be better expressed using DSum? https://pastebin.com/raw/DV9Lq8w9
23:41:18 <fen> its a base functor parametrized zipper
23:42:31 <fen> it seems to use both UndecidableSuperclasses and DatatypeContexts, which seems dubious
23:48:00 <fen> the style seems unorthodox and it would be good if it could be expressed in a simpler way
23:48:46 <fen> to save this peculiarity propagating through the whole code
23:49:17 <fen> is it the only way to express things like this?
23:50:59 <unsymbol> why is it useful that (->) has a functor instance? what's the motivation behind it?
23:52:39 <Solonarv> you can write functions that work for *any* functor and don't care which one you make them use; the instance for ((->) e) allows you to use these works-on-any-functor functions to work with functions
23:53:27 <Solonarv> additionally, Functor instances are unique for most cases*, so it's generally a good idea to provide the instance if possible
23:55:39 <Solonarv> *: for any particular type F that does not involve type variables, the functor instance (if it exists) is unique; if type variables are involved then there may be multiple possible instances, placing different constraints on these type variables, but these instances must give the same result whenever they would both be valid
23:57:19 <Solonarv> unsymbol: does that help?
23:57:57 <Solonarv> you can mostly ignore the asterisk - it's not relevant here, I simply included it for the sake of correctness
23:58:24 <Solonarv> the Functor ((->) e) instance doesn't place any constraints on e, so we know this must be the only valid instance
23:58:25 <fen> :t (*:)
23:58:26 <lambdabot> error:
23:58:26 <lambdabot>     • Variable not in scope: *:
23:58:26 <lambdabot>     • Perhaps you meant one of these:
23:58:38 <Solonarv> that wasn't an operator
23:58:49 <jle`> i don't think the asterisk is necessarily needed, there's always an implicit quantification when there is a type variable involved
23:59:02 <jle`> saying `Either e` is unique means that for all e, Either e is unique
23:59:27 <Solonarv> it is needed: there are two ways to write 'instance _ => Functor (Compose f g)', for example
23:59:53 <jle`> for all f and g, Compose f g has a unique functor instance, doesn't it?
