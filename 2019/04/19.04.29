00:55:58 <jeffhappily> hi
00:56:22 <lavalike> howdy
00:57:07 <Rembane> Mornin'
00:57:56 <jeffhappily> I'm new to haskell!
00:58:03 <jeffhappily> how long have you guys writing haskell?
00:58:38 <Rembane> jeffhappily: Ten years, why you ask? :)
00:59:09 <lavalike> a long time!
00:59:24 <jeffhappily> just curious
00:59:30 <jeffhappily> do you guys use haskell in work?
01:01:42 <cocreature> I do
01:04:32 <merijn> Every time I can get away with it :p
01:04:38 <merijn> And some times when I can't :p
01:07:42 <kernel-sanders> little job security won't hurt
01:10:13 <matsurago> me being a Haskell noob, had I chance to use it at work during hackathon days
01:17:27 <jgt> jeffhappily: I've been writing Haskell only a few years; on and off for the past four/five. Now I work with it full time, and run three businesses on it.
01:17:27 <dminuoso> c_wraith: turns out I didnt understand how GHCs GC works well enough.
01:17:54 <dminuoso> c_wraith: The GC just didn't do any major runs yet, which is why it seemed like objects were leaked.
01:18:03 <dminuoso> I verified with valgrind, no lost bytes.
01:49:18 <kuribas> I am missing IDE stuff like m-. in haskell
01:49:42 <kuribas> While I am not a very big clojure fan, the IDE experience is so much better.
01:50:02 <kuribas> there is so much missed opportunity for good tooling in haskell.
02:00:36 <maerwald> kuribas: whaaat?
02:00:45 <maerwald> clojure tooling has been extremely fragile to me (on vim)
02:00:53 <maerwald> to the point that I just turned it off
02:00:59 <kuribas> maerwald: I am on emacs
02:01:06 <maerwald> well, everything is better on emacs, lol
02:01:12 <kuribas> well, lisps for sure :)
02:01:19 <maerwald> haskell too
02:01:22 <maerwald> unfortunately
02:01:31 <kuribas> emacs + evil mode?
02:01:36 <matheus23> Hi all! Is there any interesting Alternative instances, except for Maybe, [], IO, and parsers like Parsec?
02:02:15 <maerwald> don't want to spend time on switching editor and my workflow usually involves opening and closing multiple vim windows. I don't like the concept of shared session
02:03:49 <merijn> matheus23: STM? :)
02:04:12 <matheus23> merijn: What does it do? Does it re-try similar to the IO Alternative?
02:04:28 <merijn> matheus23: if left fails, try right, if all fail retry everything
02:04:31 <kuribas> tooling for lisps can only go so far, since it doesn't have much compile time information.  Haskell has this information, but does nothing with it.
02:05:34 <matheus23> merijn: Huh. And that works for (a <|> b <|> c) too, I guess?
02:05:59 <matheus23> would STM retry by itself, without any <|>s?
02:06:01 <merijn> matheus23: yeah, that'll try first a, then b, then c, then retry everything
02:06:16 <maerwald> kuribas: yeah, it's amazing that something like autocompletion works better in a language like python :)
02:06:33 <Solonarv> matheus23: <|> doesn't introduce retrying
02:06:42 <matheus23> okay Thanks for info!
02:06:47 <Solonarv> you can think of <|> as catching a retry and trying something else
02:06:58 <Solonarv> if you want to retry, use... 'retry' :P
02:07:05 <Solonarv> (or Alternative's empty)
02:07:05 <merijn> matheus23: in STM fail and retry are kinda the same thing
02:07:13 <kuribas> maerwald: indeed
02:07:51 <matheus23> ok thanks! Interesting
02:07:58 <matheus23> Any other Alternative instances?
02:08:08 <merijn> matheus23: Semantically retry basically means "rerun the whole transaction until we don't hit a retry" in practice it's implemented smarter/more efficiently. But <|> let's you kinda switch between, well, alternative STM code paths ;)
02:08:39 <merijn> matheus23: A simple example would be "readTChan chan1 <|> readTChan chan2" to read from the first of two channels to have input available
02:09:33 <matheus23> Context: (I think) I'm generalizing Joachim Breitner's http://hackage.haskell.org/package/successors-0.1.0.1/docs/Control-Applicative-Successors.html They could be defined as data Succs f a = Succs a (f a) with f being Alternative. But now I'm thinking what those instances could look like
02:09:56 <matheus23> and how the resulting Applicative/Monad behaves with different Alternatives
02:11:12 <Solonarv> 'Event' from FRP (I'm thinking of reflex specifically) is another instance
02:11:35 <matheus23> Solonarv: Oh that one seems unlike the others! I'll take a look
02:11:52 <Solonarv> note, I couldn't actually find the instance
02:12:09 <Solonarv> so I'm not sure if reflex actually provides it
02:12:56 <Solonarv> hm. looks like it doesn't, I wonder why
02:13:08 <matheus23> Solonarv: Hm yeah. I struggle to find it as well
02:13:33 <Solonarv> it does provide leftmost :: Reflex t => [Event t a] -> Event t a
02:14:37 <Solonarv> which could be defined in terms of Alternative as: leftmost = foldr (<|>) never
02:14:37 <Solonarv> or vice-versa we could write instance Reflex t => Alternative (Event t) where empty = never; e1 <|> e2 = leftmost [e1, e2]
02:14:45 <dminuoso> matheus23: Control.Applicative.Backwards
02:14:59 <dminuoso> matheus23: This is one of my favourite newtype wrappers for Applicative because its fancy.
02:15:17 <Solonarv> Cale: why's that instance not in reflex, anyway? is it just because nested 'leftmost' would be horribly inefficient and you don't want to encourage it?
02:15:27 <matheus23> dminuoso: Ah nice. Basically Dual for Applicatives
02:15:50 <Solonarv> matheus23: you got it
02:15:50 <dminuoso> matheus23: Not quite
02:15:55 <Solonarv> no?
02:15:57 <matheus23> lol
02:16:08 <matheus23> well it only reverses effects, not values
02:16:19 <matheus23> I think I get it
02:16:20 <Solonarv> well yeah, it can't reverse values - the types forbid that
02:16:45 <Solonarv> consider: Backwards (Const m) ~ Const (Dual m) -- so they really are related!
02:17:19 <Solonarv> (by '~'  here I mean that they have the same representation, *and* their instances do the same thing)
02:17:33 <dminuoso> Oh well yeah. If you just look at the Alternative instance, then the definition works.
02:48:47 * hackage treap 0.0.0.0 - Efficient implementation of the implicit treap data structure  https://hackage.haskell.org/package/treap-0.0.0.0 (shersh)
02:59:19 <Taneb> Is there a way to specify that a test suite should be built but not run by default when cabal test is invoked?
03:06:46 <phadej> cabal v2-build --enable-tests
03:07:08 <Taneb> phadej: I still want to run some, just not all, tests
03:07:29 <phadej> ah, some test; that's tricky
03:07:56 <phadej> specifying explicitly which testa to run is supported
03:08:06 <phadej> but "all but thisone" isn't
03:08:36 <phadej> (you can cabal test tests-suite-name e.g)
03:09:04 <dminuoso> logDebugN "Waiting for workers to complete" >> atomically $ do { c <- readTVar workerCount; guard (c /= 0) }
03:09:30 <dminuoso> At least 6 Haskell professionals didn't see a mistake in this.
03:09:58 <dminuoso> How does one avoid such subtle mistakes?
03:13:19 <dminuoso> The mistake being using (/=) instead of (==) there.
03:22:37 <Putonlalla> One does not avoid such mistakes. One repeats them every time one uses `filter` or `guard`.
03:22:53 <[Leary]> I guess it's a boolean blindness thing like we have with filter too; it's hard to remember whether you want `guard b`/`filter p` or `guard (not b)`/`filter (not . p)`. I've seen people suggest that `filter` should be replaced with some ~equivalent functions called `keep` and `exclude` that make the intention more explicit. The same could be said for guard but I'm not sure what names are good in a broad Alternative context.
03:23:07 <Putonlalla> Too often, one is me.
03:23:10 <[Leary]> Maybe `ensure` and `prevent`?
03:24:04 <dminuoso> [Leary]: Well Alternative has `when` and `unless`
03:24:36 <dminuoso> But I guess `ensure :: Alternative f => f Bool -> f ()` would be preferable
03:25:13 <dminuoso> Or `ensure :: Alternative f => f a -> (a -> Bool) -> f ()`
03:27:09 <Solonarv|p> That requires Monad, actually
03:27:25 <dminuoso> Solonarv|p: I guess MonadPlus would be too strong?
03:27:58 <Solonarv|p> MonadPlus is pretty much exactly Monad + Alternative, I think
03:28:08 <dminuoso> Solonarv|p: It has an additional law
03:28:14 <dminuoso> Depending on who you talk to anyway..
03:30:34 <Solonarv|p> Yeah, I vaguely remember something like that
03:30:36 <Putonlalla> Is `MonadPlus` as well-grounded in theory as `Functor` and `Monoid`?
03:31:41 <Solonarv|p> A MonadPlus is a Monad that additionally gives rise to some Monoid
03:32:15 <Solonarv|p> Basically, it's monoids all the way down
03:34:51 <lyxia> the question of whether (>>=) distributes over mplus is pretty controversial
03:41:47 <BlackBloc> hi, is it blocked uploaded.net?
03:42:24 <kuribas> Putonlalla: so MonadPlus is redundant?
03:42:30 <kuribas> as you already have monoid
03:43:25 <PrimeSeeker[m]> np
03:43:46 <PrimeSeeker[m]> Wrong channel.
03:45:07 <Solonarv|p> No, there are often a bunch of different monoids arising from a Monad
03:45:37 <merijn> Solonarv|p: I mean, you already have minimum 4 or so for any monad, possibly more
03:46:07 <Solonarv|p> There's always at least one, with (<>) = lifatA2 (<>); mempty = pure mempty
03:46:34 <Solonarv|p> (which actually works for any Applicative, not only Monad)
03:47:04 <merijn> Solonarv|p: "liftA2 (flip (<>))"
03:47:37 <merijn> Also, "flip (liftA2 (<>))" and "flip (liftA2 (flip (<>)))"
03:47:38 <Solonarv|p> Yes, and permutations of that involving Dual and/or Backwards
03:48:07 <merijn> So, probably 16 minimum, if not more...
03:48:42 <Solonarv|p> merijn: no, your 'flip's correspond to Dual/Backwards
03:49:24 <Solonarv|p> So just 4 still
03:49:44 <merijn> Solonarv|p: You have First and Last too
03:50:11 <merijn> Which can apply to the internel element and the outer one, so... ;)
03:50:36 <Solonarv|p> That's not really the Monad/Applicative giving rise to anything, though
04:12:17 * hackage writer-cps-transformers 0.5.6.1 - WriteT and RWST monad transformers  https://hackage.haskell.org/package/writer-cps-transformers-0.5.6.1 (minad)
04:19:11 <dminuoso> kuribas: No since MonadPlus is generally assumed to carry extra laws.
04:22:08 <dminuoso> kuribas: Namely mzero acting as a left and right zero with respect to (>>=)
04:25:45 <dminuoso> Now the right zero is highly debatable, since that would invalidate a bunch of instances
04:26:28 <dminuoso> The best proposal Ive seen is to consider MonadPlus a right-seminearring.
04:36:17 * hackage di-handle 1.0.1 - IO support for file handles in di-core  https://hackage.haskell.org/package/di-handle-1.0.1 (RenzoCarbonara)
04:38:47 * hackage df1 0.3.1 - Type, render and parse the df1 hierarchical structured log format  https://hackage.haskell.org/package/df1-0.3.1 (RenzoCarbonara)
04:55:17 <Cale> Solonarv|phone2: You'd have to ask Ryan, but that sounds likely -- creating lots of pairwise merges accidentally would be bad, so we'd be relying on rewrites or some bit of extra runtime machinery. It might be that there's already some amount of merge fusing going on though, I haven't looked closely enough at Spider to know.
05:21:51 <dminuoso> Cale: So ArgDict to some degree seems like a Dict1, right?
05:22:19 <dminuoso> A reified higher order constraint, so to speak.
05:26:51 <Cale> dminuoso: Well, it's a class, rather than a datatype to start... it's specifying a way of consuming a GADT in order to determine which dictionary you need.
05:27:20 <Cale> dminuoso: I like to think of it as giving you a kind of constraint-level Pi types
05:27:38 <Cale> (Especially Has/Has')
05:27:44 <Cale> Has' c f g
05:28:07 <Cale> says that for any *value* of type f a, we can get a dictionary for c (g a)
05:28:10 <dminuoso> Sadly not familiar with Pi types
05:28:19 <Cale> Ah, let me explain that then :)
05:29:18 <Cale> So Pi is at the heart of what we'd call dependently typed programming -- it's a way of making functions where the type of the result depends on the *value* of the input to the function
05:30:02 <Lycurgus> as opposed  to what?
05:30:13 <Cale> So, we might have (using pseudo-Haskell-ish syntax) f :: Pi (x :: a). f x
05:30:22 <Cale> Where Pi here is a quantifier like forall
05:30:39 <Cale> But we're saying that x is a value of type a, which is the argument to f
05:30:39 <dminuoso> Cale: Except it quantifies over values?
05:30:52 <Cale> and yeah, we're quantifying over values
05:31:19 <Cale> and f here is some type which is parametrised on a value of type a, so it's again something we don't *quite* have in Haskell, but we come pretty close with datakinds
05:32:00 <Cale> ah, I should not have reused f twice
05:32:03 <Cale> that sucked :D
05:32:10 <Cale> f :: Pi (x :: a). F x
05:32:18 <Cale> Let's say F is the type
05:32:31 <dminuoso> Cale: Oh yeah, I managed to understand that even with the ambiguity. :)
05:32:33 <Cale> So that  f x :: F x
05:32:38 <dminuoso> (Wouldn't have made much sense differently_
05:32:42 <Cale> right
05:32:58 <Cale> though now our types and terms no longer live in separate namespaces
05:33:07 <Cale> so we really can't get away with that for long
05:33:12 <dminuoso> Cale: I guess the `a` would not be universally quantified either right?
05:33:19 <Cale> yeah, probably not
05:33:26 <maerwald> what is the equivalent of "mapped" for Getter? Basically same as 'to (fmap _record)' except with the lens for '_record'
05:33:27 <Cale> a there is probably something in particular
05:33:32 <dminuoso> Right
05:34:14 <Cale> dminuoso: So Has' gives you this kind of thing, but inside of a constraint -- it lets you express constraints that depend on a choice of value of another type
05:34:46 <Cale> Like, for instance, perhaps I have a DMap f g
05:35:13 <Cale> and I want to say that for any key k :: f a of my DMap, that I'll have an instance Semigroup (g a)
05:35:22 <Cale> so that I can combine values that occur at the same key
05:35:31 <Cale> Then I can write  Has' Semigroup f g
05:35:35 <dminuoso> Cale: So in some sense Pi takes a similar role as /\ except the domain it quantifies over is the value world.
05:35:35 <dminuoso> Or "parametrizes over
05:35:47 <Cale> yes, exactly
05:36:23 <Cale> Pi (x : A), B is the same type as A -> B whenever x isn't mentioned in B
05:37:16 <dminuoso> Just like `forall x. Int -> Double` is - if you squint a little - the same as `Int -> Double`
05:37:36 <dminuoso> Or wait..
05:37:37 <Cale> Pi (x : Bool), B x is isomorphic to the Cartesian product which in Haskell's style we'd write (B False, B True)
05:38:08 <Cale> ah, I've started using single colons :D
05:38:11 <Cale> haha
05:38:48 <Cale> So you can think of Pi (x :: A), B x  as a giant product over all values x of type A of the type B x
05:38:57 <dminuoso> Oh that's fine, the double colons are noisy anyway.
05:39:32 <dminuoso> Cale: You just introduced the comma there, what does it denote?
05:39:48 <Cale> oh, sorry, that's just another option for what I was using period for before
05:40:19 <Cale> There are a lot of similar notations that get used in different languages, and it's hard to keep the choices straight in pseudocode :D
05:41:11 <Cale> In TeX, you'll often see it as a capital Greek letter Pi with "x : A" written underneath, and then B x next to it
05:41:34 <Cale> (Or I should say, various mathematical contexts, which would use TeX to typeset)
05:42:02 <dminuoso> `f :: Pi (x :: Int). Float` is equivalent to `Int -> Float` because the resulting type is "constantly float (since x does not occur in it)" but its parametrized over x
05:42:07 <dminuoso> Okay this makes sense
05:42:10 <Cale> yeah
05:42:20 <Cale> I should also introduce Sigma
05:42:35 <Cale> Sigma (x :: A). B x
05:42:54 <dminuoso> Is that the existential version of it?
05:43:03 <Cale> is the type of pairs where if the first component is some x of type A, then the second component has type B x
05:43:07 <dminuoso> Oh 
05:43:33 <Cale> which you can think of as a giant summation of all the types B x ranging over values x of type A
05:43:55 <Cale> So x is our "tag" telling us which summand we're in, effectively
05:46:28 <Cale> So you can think of the graph of a function of type Pi (x :: A). B x as consisting of a bunch of pairs of type Sigma (x :: A). B x
05:46:35 <dminuoso> Cale: Is there an easy to see how Pi can be thought of as the cartesian product?
05:46:39 <dminuoso> Mmm
05:46:59 <Cale> Think of function application as being your projections
05:47:37 <dminuoso> Ah
05:47:38 <Cale> So when we apply a function of type Pi (x :: A). B x to some x of type A, we get some b_x :: B x
05:48:06 <Cale> (or more literally we might write it as b x, if b is our function)
05:48:30 <Cale> But I'm trying to hint at the thought that these are components of a giant tuple, having positions for each element of type A
05:48:58 <Cale> (or possibly not so giant tuple, if we pick A = Bool, then this reduces to pairs)
05:49:09 <dminuoso> Cale: Yeah, the hint with "function application as being your projections" explains it perfectly.
05:53:42 <Cale> So, back in actual Haskell world, we might not be able to directly talk about these things, but we do get as far as having DMap, which roughly approximates a finite map version of Pi in the sense that the keys of our DMap are going to be some indexed type, and the corresponding values will be required to have the same index
05:54:27 <Cale> So like, the key's value determines the index type, which then determines the value type, which is almost as good as having the key determine the value's type directly.
05:54:51 <Cale> and DMap is to Pi what DSum is to Sigma
05:56:16 <Cale> and if you try to work with these things in Haskell for any length of time, you start wanting to be able to say things like... for each possible key of my DMap, I want to have a Show instance for whatever type of value I'm going to have
05:57:10 <Cale> Which, if I was programming in a dependently typed language, I might express by way of a function of type  Pi (x :: k a). ShowDict (v a)
05:58:22 <Cale> Make sense? :)
05:59:00 <dminuoso> Cale: Im slowly digesting this. So Im not comfortable with Sigma yet, so I haven't proceeded to the end of it.
05:59:20 <c50a326> https://gist.github.com/m1574b34r/691c6394505f90750d7f5d3fbe43eac2 what's non-exhaustive about this? what pattern(s) am I missing? :S
05:59:28 <phadej> Cale: can't you say DMap MyTag (Compose Dict Show) or something like that?
05:59:32 <Cale> c50a326: []
06:00:09 <Cale> c50a326: also those patterns are quite redundant, because [[x]] will be covered by [x:xs], when xs = []
06:00:10 <c50a326> Cale: but the type is [[x]] -> [x] so how can [] be missing? the input _must_ be like [[]] at a minimum, no? :S
06:00:20 <phadej> :t concat
06:00:20 <Cale> no
06:00:21 <lambdabot> Foldable t => t [a] -> [a]
06:00:23 <dminuoso> Cale: Also regarding `k`, `a` and `a`. are they universall quantified? Or are they concrete type variables for some type?
06:00:25 <phadej> :t concat @List
06:00:26 <lambdabot> error:
06:00:27 <lambdabot>     Pattern syntax in expression context: concat@List
06:00:27 <lambdabot>     Did you mean to enable TypeApplications?
06:00:29 <Cale> [] is a perfectly good empty list of lists
06:00:29 <phadej> :(
06:00:35 <phadej> > concat []
06:00:37 <lambdabot>  []
06:00:49 <c50a326> oh right
06:00:50 <Cale> c50a326: Don't be confused by the similar syntax used for types and terms
06:01:14 <Cale> At the term level, [x] is a list of one element, at the type level [t] is the type of lists whose elements have type t
06:02:36 <Cale> It may also help you not to use x at the type level there, as it's a type, and doesn't have anything to to with your term level x's (apart from telling you something about what type they have)
06:03:20 <c50a326> okay, solved, thanks :)
06:03:34 <Cale> dminuoso: Well... k is more constant. The a's get existentially quantified
06:03:59 <Cale> dminuoso: data DSum f g where (:=>) :: f a -> g a -> DSum f g
06:04:39 <Cale> So if I have some DSum k v, that's like a pair of some k a and v a
06:05:00 <Cale> and DMap is like a collection of such pairs
06:05:38 <Cale> DMap k v has keys of type k a, and corresponding values of type v a
06:06:15 <Cale> With the presumption being that we'll choose k to be some GADT where by pattern matching on the data constructor, we re-learn which type a is
06:06:23 <Cale> e.g.
06:06:28 <Cale> data FormField a where
06:06:35 <Cale>   FirstName :: FormField String
06:06:40 <Cale>   LastName :: FormField String
06:06:47 <Cale>   Age :: FormField Integer
06:07:18 <Cale> I might then have  DMap FormField Identity  to represent a (possibly incomplete) form
06:07:50 <Cale> and  DSum FormField Identity  would be a single pairing like  FirstName :=> Identity "Cale"
06:08:23 <Cale> or  Age :=> Identity 36
06:09:11 <Cale> Now suppose I want to shove these over the wire. I want to be able to have ToJSON and FromJSON instances for DSum and DMap
06:09:24 <dminuoso> Cale: I guess the example is a bit contrived, since that seems like a rather elaborate way to do `data FormField = FirstName String | ...`
06:09:57 <dminuoso> Or is it assumed the DMap is fully satured?
06:09:57 <Solonarv> the thing about DMap is that you can vary the second argument
06:10:04 <dminuoso> *saturated
06:10:07 <Cale> It is a little bit, but maybe you're building software for mortgage applications and there are thousands of potential fields.
06:10:50 <dminuoso> Brb getting off the train, back in perhaps 10 minutes.
06:10:53 <Solonarv> DMap FormField Identity is a (possibly incomplete) form, but you might imagine DMap FormField EventSubscriber which holds things that want to know when your form fields change
06:10:56 <Cale> and maybe you'd rather not actually encode that as a sum type directly -- it's possible to do all kinds of useful things with these keys, like they can have other value parameters of course
06:11:02 <Cale> and they can be nested
06:11:13 <Cale> yes, indeed
06:11:41 <Solonarv> (I think I stole that example from you in the first place :P)
06:11:57 <Cale> Or from Ryan (possibly by way of me)
06:15:56 <Cale> Also, if you try to use Set FormField, with a type like dminuoso was suggesting there, you might have difficulty if you want to do the equivalent of an insert into the DMap or the union or intersection of DMaps
06:16:12 <Cale> i.e. you don't actually have a structure which is keyed on the fields then
06:17:05 <Solonarv> yeah
06:17:28 <Solonarv> DMap feels to me like a very nice and fancy hammer that I haven't quite found a nail for yet
06:17:37 <ocramz> hi all!
06:17:47 <Solonarv> ocramz: hello!
06:17:51 <Cale> Solonarv: We'll hopefully give you some soon :)
06:18:19 <Solonarv> I'm sure I'll find one soon, after all I'm learning reflex now :>
06:18:48 <Cale> Solonarv: We've been working on what will be Obelisk's story for (1) database access, and (2) communication of requests for data and changes to it between the frontend and backend of the app
06:19:10 <Solonarv> yeah, I recall you mentioning stuff about that
06:19:54 <ocramz> I have a design question: let's say we have a large set of HTTP request/response type pairs. The response type can be what's returned after parsing the response body. I'd like to have a single parametrized HTTP request function that, given the request type, computes the type of the response
06:20:24 <phadej> type families, functional dependencies
06:21:16 <Cale> ocramz: GADTs
06:21:40 <Cale> In fact, this is an extremely well-timed question from the context of our existing discussion :D
06:21:57 <Cale> So, you can define a GADT that represents all your possible requests
06:22:14 <Cale> and it'll be indexed on the type of the response
06:22:21 <Cale> data Request a where
06:22:55 <Cale>   GetSalary :: Id Employee -> Request Integer
06:23:01 <hyperisco> I have  instance Group a => AffineSpace (Vector a) (Point a)  but also  instance EuclideanSpace (Vector Double) (Point Double)  which is an error, because Double is not a Group, but it does have an additive group through Ring
06:23:02 <Cale> etc. etc.
06:23:29 <hyperisco> So the question is, how can I deal with this situation...
06:23:32 <ocramz> That's a good suggestion, I'll try that. Thank you Cale and phadej
06:23:39 <Cale> ocramz: and then your function  request :: Request a -> IO (Maybe a) or something perhaps
06:24:27 <hyperisco> If I strengthen Group to Ring it works, but then I lose (needed) utility of Vector and Point
06:25:14 <hyperisco> I can newtype Vector and Point, but this adds noise and requires rederiving all other instances, as such things do
06:25:46 <Cale> hyperisco: or you can have a newtype wrapper around Double which picks the group
06:26:01 <Cale> but that's similarly awkward
06:26:18 <hyperisco> mm yes suppose I could
06:26:40 <Cale> There's already Data.Monoid.Sum
06:27:05 <Cale> But yeah, I dunno
06:27:26 <hyperisco> well, that is an option I didn't consider, and I think it is the best one
06:27:35 <Cale> It might also be that you don't want such a generic instance of AffineSpace?
06:27:48 <hyperisco> no I really do, else I'd just strengthen it to Ring
06:28:24 <hyperisco> this is because I need an affine space of vectors and points of quantities with units
06:28:32 <Cale> I mean, you could even get away with writing particular instances for individual types of points and vectors
06:28:33 <hyperisco> well, *need* as in *want*
06:28:52 <hyperisco> this vector and point are specifically 2d
06:29:39 <hyperisco> I have no subclasses of EuclideanSpace, and it only has the member pdqf, so a newtype wrapper on Double to use that is not a big deal
06:33:02 <Logio> what's the purpose of the "Point a" type here?
06:33:59 <hyperisco> Logio, affine spaces have vectors and points
06:34:30 <hyperisco> also, I am using Double because I don't know of a way to characterise the reals generically…
06:34:56 <Logio> but why do you also have it for the euclidean space instance? 
06:35:17 <hyperisco> Logio, they also have vectors and points
06:35:23 <noipmusp> Hi, I successfully setup nix building for my project using https://maybevoid.com/posts/2019-01-27-getting-started-haskell-nix.html. Now, I would like to add ghcid to my project for debugging purposes, but I'm completely lost. Can anyone help me?
06:36:11 <Logio> hyperisco: I think I'm still confused, I usually consider vectors to be points and vice versa in this context
06:36:25 <hyperisco> Logio, they are distinct objects here
06:36:43 <Solonarv> noipmusp: if you start GHCi by running $GHCi, then ghcid -c "$GHCi" will work
06:36:57 <Solonarv> you simply need to make sure the ghcid binary is available
06:37:07 <Logio> hyperisco: I see that, I don't see why
06:37:12 <hyperisco> also, all Euclidean spaces are affine spaces, so, even on mechanistic level, I have to specify which affine instance is super to the Euclidean instance
06:37:22 <Solonarv> Logio: it often makes sense to conflate them, but not always
06:37:48 <Solonarv> mathematically, you can take any vector space and build an affine space from it by simply forgetting the origin
06:37:56 <Solonarv> (and the ability to add)
06:38:15 <hyperisco> you can add vectors in affine spaces
06:38:34 <Solonarv> yes, I was being sloppy here
06:38:40 <Solonarv> you can't add *points* though
06:38:44 <Solonarv> (well, not in general)
06:39:22 <hyperisco> sure… I am not sure when the machine representation of a point and vector would be different… presumably an example exists
06:39:41 <hyperisco> but even if not, practically speaking there is a conceptual difference, and it helps keep that straight to have different types
06:39:53 <Solonarv> a very simple, but useful example of an affine space is time as measured by some clock
06:40:46 <hyperisco> in a Euclidean space, a point is just a vector from origin, as is in my instance
06:41:04 <Solonarv> it doesn't make any sense to add '15:40 29th April, 2019' to '04:32, 9th March 1979"
06:41:05 <hyperisco> but I am actually only interested in the affine space, where points aren't necessarily that
06:41:51 <hyperisco> Solonarv, oh right, time does make an affine space doesn't it… how neat! :D
06:42:01 <Solonarv> indeed!
06:42:13 <hyperisco> useful to know because I am working with time a lot…
06:42:29 <Logio> Solonarv: I'm familiar with affine spaces, I'm wondering why the distinction is retained for Euclidean ones
06:43:38 <hyperisco> Logio, then the simple mechanistic reason is that in my class hierarchy a Euclidean space is both an affine space and an inner space, and they are multi param on vectors and points
06:44:29 <hyperisco> the affine space is, the inner space just cares about the vector
06:44:40 <Logio> but couldn't you simply have EuclideanSpace (Point a) still?
06:44:57 <hyperisco> granted I have a functional dep on the affine space so points determine vectors and vice versa
06:45:20 <hyperisco> so… I could drop either the vector or point param on Euclidean spaces
06:45:28 <Solonarv> fundep both ways? somehow that doesn't quite seem right
06:45:44 <Solonarv> I would think you'd only want it from points -> vectors
06:45:55 <hyperisco> mm… could be otherwise but practically speaking I don't see why
06:46:13 <Logio> hyperisco: remember that the only real parameter you have there is 'a', the Vector a on the left doesn't really have anything to do with the Vector a on the right
06:46:23 <hyperisco> Solonarv, can convince me otherwise with an example :)
06:46:45 <Solonarv> well, mathematically speaking the space of differences is unique for any affine space, but there may be multiple affine spaces based on the same vector space
06:47:00 <hyperisco> Logio, not sure what you mean… Vector is an example of a vector
06:47:04 <Solonarv> don't have an example though, so perhaps it turns out they're all isomorphic and my point is moot
06:47:16 <Solonarv> (hah, "point")
06:48:38 <hyperisco> Solonarv, to me it is just a question of type inference vs convenience. If there was a need for multiple vector types per point type, then it'd be inconvenient to newtype. On the other hand, the two-way dependency improves inference
06:48:51 <Solonarv> yeah, that's a fair point
06:49:06 <Solonarv> I can certainly see the practical upsides of the two-way FDs
06:49:47 <noipmusp> Solonarv: Sorry for delay. ghcid -c "$GHCi" not work for me, because $GHCi variable is probably not set ("echo $GHCi" prints nothing).
06:50:10 <Logio> hyperisco: I misread your instance declaration from before
06:50:31 <Solonarv> noipmusp: that wasn't meant literally
06:50:43 <Solonarv> you were supposed to substitute whatever-you-use-to-launch-ghci
06:51:21 <Solonarv> recall the beginning of my message: "if you start ghci by running $GHCi"
06:53:56 <Logio> hyperisco: I just remember thinking of the linear space hierarchies when I was making my Clifford algebra codes, and something felt funny in your instances
07:18:11 <hyperisco> I think I figured out my issue… I have two concepts going on… first concept is that given a ring/field I can make vector spaces, affine spaces, etc
07:18:24 <hyperisco> second concept is that the product of these spaces is also a space
07:19:24 <hyperisco> So, really, I can just construct the 1D spaces from ring/fields/groups/etc and then construct the product for 2D spaces
07:19:50 <hyperisco> because then the hierarchy wrt super classes naturally works out
07:23:09 <hyperisco> so I can make all the way up to the Euclidean space of Pixels (vector) and Pixel (point), where these are both represented by Double
07:23:14 <hyperisco> so, just a quantity with a unit
07:23:27 <hyperisco> then the product is also a Euclidean space
07:23:36 <hyperisco> so, tada, 2D vectors and points of pixels
07:24:29 <hyperisco> for that matter, Double itself is already an instance of all these spaces, isn't it
07:25:35 <hyperisco> so the Pixels type can be auto derived from Double
07:26:48 <c50a326> how would I, in my own head, figure out the type for `map map` or `fmap fmap` ?
07:27:10 <c50a326> I'm looking at these with `:t` in ghci and I've tried to pen and paper it and I don't understand what's happening :(
07:28:33 <hyperisco> c50a326, think of fmap not as  (a -> b) -> f a -> f b  but as  (a -> b) -> (f a -> f b)
07:32:55 <c50a326> hyperisco: ah, does that mean I can then think of it as: a -> b -> (f a -> fb) ?
07:33:06 <hyperisco> no
07:33:10 <Solonarv> no, that's not the same thing
07:34:25 <hyperisco> lets say  fmap :: (r -> s) -> (g r -> g s)  and  fmap :: (a -> b) -> (f a -> f b)  so the question is what  r  and  s  are in  fmap fmap
07:35:12 <hyperisco> well, by writing it as I have, clearly the ->'s match up, so  r  is  a -> b  and  s  is  f a -> f b
07:36:03 <hyperisco> fmap :: ((a -> b) -> (f a -> f b)) -> (g (a -> b) -> g (f a -> f b))
07:40:32 <c50a326> ohhh nice, and then can you do any further reduction?
07:43:32 <Darwin226> I have a type like data T a = T { field1 :: a, field2 :: a }, is it possible to use type changing lens with this type?
07:43:55 <Darwin226> The problem is that I can't just change one of the fields types since they need to be the same, but I want to change them both anyways
07:44:23 <Darwin226> any way to combine the lenses for those two fields into one lens which I can then use to modify both fields simultaneously?
07:44:23 <Taneb> Darwin226: you could define something of type Iso (T a) (a, a)
07:44:54 <Darwin226> Taneb: It's further complicated by the fact that I have additional monomorphic fields in the same record
07:45:08 <Taneb> Well, it could be a Lens
07:46:17 <Darwin226> Taneb: I guess it's easier to use the record selectors directly if I have to define helpers anyways
07:47:28 <Taneb> Darwin226: depends if you're going to be using this in a nested circumstance or not
07:47:53 <Solonarv> basically, your lens needs to include all the fields that change type together
07:48:14 <Solonarv> so a Lens (T a) (T b) (a, a) (b, b) would work, for example
07:48:22 <Darwin226> I mean I could probably derive traversable for my type and then use that
07:48:32 <Darwin226> but I hate that it only works for one type parameter
07:48:37 <Darwin226> Solonarv: Yep
07:48:47 <Solonarv> you can write a Traversal which targets all of the 'a' fields
07:49:06 <Solonarv> then you have: Traversal (T a) (T b) a b
07:49:16 <Darwin226> Solonarv: is there a 'combinatory' way of constructing these out of smaller lens?
07:49:17 * hackage QuickCheck-safe 0.1.0.6 - Safe reimplementation of QuickCheck's core  https://hackage.haskell.org/package/QuickCheck-safe-0.1.0.6 (BertramFelgenhauer)
07:49:29 <hyperisco> Cale, actually I think Sum itself is a vector, given the necessary constraint on its parameter
07:49:57 <hyperisco> So, like, Sum Double scaled by Double is a commutative module
07:50:14 <Cale> hyperisco: that's... also true
07:51:05 <Solonarv> (if we ignore Double's shortcomings, of course)
07:51:09 <hyperisco> yeah :)
07:51:57 <hyperisco> well then  newtype Pixels = Pixels (Sum Double)  is now inherently a vector
07:52:15 <hyperisco> and the product of Pixels is also so
07:52:17 * hackage hindent 5.3.0 - Extensible Haskell pretty printer  https://hackage.haskell.org/package/hindent-5.3.0 (ChrisDone)
07:52:31 <hyperisco> so I think I have detangled myself here
07:54:47 * hackage hjugement-protocol 0.0.0.20190428 - A cryptographic protocol for the Majority Judgment.  https://hackage.haskell.org/package/hjugement-protocol-0.0.0.20190428 (julm)
07:55:44 <tabaqui> proposal: "case leftOrRight { Left -> f; Right -> g }" is equal to "case leftOrRight { Left gen_sym1234 -> f gen_sym1234; Right gen_sym1235 -> g gen_sym 1235}"
07:56:04 <tabaqui> *case ... of
07:56:45 <tabaqui> like map from n-ary data constructor to applying n-ary function
07:57:03 <lyxia> I like it.
07:58:14 <Solonarv> I'm intrigued
07:58:24 <hyperisco> like, uh, some spin on eta reduction
07:59:19 <Solonarv> I think this form of case expression is used in PiCo (proposed dependently-typed replacement forGHC Core)
08:00:11 <tabaqui> it is not applyable to usual function call though
08:00:25 <tabaqui> because case expression allows only one pattern argument
08:01:02 <tabaqui> while functions can deal with many
08:08:50 <dmwit> I don't like it.
08:09:13 <dmwit> Because it's not modular: I wouldn't be able to smoothly use it on nested patterns.
08:10:17 <dmwit> In other words, I wouldn't be able to refactor `case ... of A x y -> case x of Left -> f; Right -> g` into anything that looks like `case ... of A Left y -> f; A Right y -> g` in a sane way.
08:13:39 <tabaqui1> Uhm, actually we can fill the holes like TypeApplications does
08:13:53 <tabaqui1> But I don't think it is good idea
08:41:47 * hackage deque 0.4.2.1 - Double-ended queues  https://hackage.haskell.org/package/deque-0.4.2.1 (NikitaVolkov)
08:53:47 * hackage lambdabot-core 5.2 - Lambdabot core functionality  https://hackage.haskell.org/package/lambdabot-core-5.2 (BertramFelgenhauer)
08:54:47 * hackage lambdabot 5.2, lambdabot-trusted 5.2, lambdabot-social-plugins 5.2, lambdabot-reference-plugins 5.2, lambdabot-novelty-plugins 5.2, lambdabot-misc-plugins 5.2, lambdabot-irc-plugins 5.2, lambdabot-haskell-plugins 5.2 (BertramFelgenhauer)
09:14:17 * hackage faktory 1.0.1.0 - Faktory Worker for Haskell  https://hackage.haskell.org/package/faktory-1.0.1.0 (PatrickBrisbin)
09:21:17 * hackage cuda 0.10.1.0 - FFI binding to the CUDA interface for programming NVIDIA GPUs  https://hackage.haskell.org/package/cuda-0.10.1.0 (TrevorMcDonell)
09:40:35 <fen> so i can make a state which returns states
09:40:53 <fen> but then this itself is not a state of the thing the inner state is of
09:41:02 <fen> ... ?
09:41:05 <fen> stuck
09:42:10 <fen> what if i just want to get one value from the inner state, and return the remaining state?
09:42:50 <fen> if its a state of states, then you dont just get a value from it, but a state, and when you get a value from this, your left with the rest of that state, and the state which produced it
09:43:33 <fen> thats 2 states. one partially used inner state, and the partially used outer state
09:44:29 <fen> if it were to be an actual state, this nested state would just produce a value and a nested state
09:45:12 <fen> instead we get the value along with a kind of dismantled set of states - this is no good
09:48:24 <fen> any ideas?
10:20:17 * hackage accelerate-llvm 1.2.0.1 - Accelerate backend component generating LLVM IR  https://hackage.haskell.org/package/accelerate-llvm-1.2.0.1 (TrevorMcDonell)
10:21:18 * hackage accelerate-llvm-ptx 1.2.0.1, accelerate-llvm-native 1.2.0.1 (TrevorMcDonell): https://qbin.io/nice-neon-2euh
11:10:25 <yitz> data V a = Maybe (V a)  <-- works fine. But I can't get this to work -> data V a = Maybe (V a) Maybe (V a)
11:11:42 <geekosaur> what do you expect that to do?
11:12:01 <cocreature> yitz: maybe you are looking for something like "data V a = MkV (Maybe (V a)) (Maybe (V a))"
11:12:01 <geekosaur> note that you have defined a new *data* constructor "Maybe", not used the existing *type* constructor
11:31:03 <reactormonk> yitz, it's a bit weird, a data declaration mixes value-level things with type-level things
11:31:49 <reactormonk> yitz, it's basically data (type) (type variable...) = (constructor name (value)) (type...)
11:31:57 <yitz> I think I was looking for " data V a = V (Maybe (V a)) (Maybe (V a))"
11:32:05 <reactormonk> Yeah
11:32:10 <yitz> Still figuring out this language 
11:32:56 <reactormonk> Got a resource at hand? Haskell is a bit harder to just jump into
11:33:22 <yitz> Google and exercism :)
11:33:29 <JappleAck> reactormonk: http://learnyouahaskell.com/
11:33:29 <yitz> I should probably read a tutorial though
11:34:09 <idlecore> I've been reading through Real World Haskell. It's been a great resource so far.
11:34:19 <yitz> That's been mentioned more than once...
11:34:19 <reactormonk> JappleAck, dunno, wouldn't recommend it. From what I've heard, it goes form easy to hard pretty fast
11:34:50 <JappleAck> reactormonk: just read it slow) and try every example by yourself
11:35:47 <idlecore> That's what I've been doing. It's a bit hard to understand until you start experimenting with the examples.
11:36:09 <idlecore> It doesn't do a good job of explaining syntax either. Just start using it, then I have to google.
11:45:21 <Cale> yitz: This is slightly different, but you might also want something like  data V a = Tip | V (V a) (V a)
11:45:27 <tabaqui> do we have a network library with dedicated Exception type?
11:46:02 <tabaqui> I need more information about possible errors, like network is unreachable, command not allowed, etc
11:46:06 <Cale> yitz: The difference being that this represents the empty tree directly, rather than always being a nonempty tree that might be missing either child
11:46:53 <tabaqui> s/dedicated/special (I dunno)
11:46:55 <Cale> (if you do that one, you might want to name the data constructor something like Branch rather than V, but it's up to you :)
11:48:48 * hackage proto3-wire 1.0.0 - A low-level implementation of the Protocol Buffers (version 3) wire format  https://hackage.haskell.org/package/proto3-wire-1.0.0 (GabrielGonzalez)
11:58:18 <Boarders> is there an option in ghci to disable printing output
11:58:27 <Boarders> like if I have on +t so I can just get the types
11:58:34 <tabaqui> void?
11:58:52 <tabaqui> oh, not exactly
11:59:43 <opqdonut> Boarders: mm just use :type?
12:00:02 <Boarders> I should have said I am using +s to get memory and time info too
12:00:22 <opqdonut> right
12:00:24 <Boarders> I guess I can do rnf
12:21:10 <mreh> is it possible to a get a raw bytestring version of a ReqBody in Servant?
12:21:30 <mreh> technically it's a JSON value, but I'd quite like both so I can verify a checksum header
12:26:16 <Emilijus> Hello! Could somebody look at this compiler error I'm getting? I would be very thankful! https://gist.github.com/EmilijusS/5efd8387fa19c3ed857ea604f7ac8db6
12:32:40 <boj> Emilijus: you have to tell it what type `message` is, and it must be an instance of Ord
12:33:17 * hackage fay 0.24.0.3 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  https://hackage.haskell.org/package/fay-0.24.0.3 (swamp_agr)
12:33:21 <blazered__> Emilijus  your function could return any type k, and nothing tells compiler which one to choose. It can't also deduce specific map type from your code
12:34:00 <blazered__> For all ghc knows, it could be Int or Char or something else. Need more type hints.
12:34:35 <Emilijus> Well that would depend on the specific instance of Aggregatable class, I guess it could be deducible from that
12:37:32 <blazered__> I could not. The only think known about your map is a value type, because "yield current" binds it to the "Pipe ...."
12:37:37 <blazered__> thing
12:39:04 <blazered__> and which type "getKey a" returns is unspecified. Two options here: add a type annotation to "empty", name key type there. Then replace k in getKey with that type.
12:40:39 <blazered__> Other option is when k depends on a: for each a there is some type k. Then you have to add it to the class declaration, and define in every instance.
12:43:34 <Emilijus> Okay, I just wanted this to be as general as possible, so that the user itself could choose whatever type of key it wants
12:44:07 <Emilijus> By making whatever it wants to pass an instance of Aggregatable
12:44:20 <blazered__> Option b then. Just tell the compiler that user should select their k and tell it via instance.
12:44:47 * hackage proto3-suite 0.3.0.0 - A low level library for writing out data in the Protocol Buffers wire format  https://hackage.haskell.org/package/proto3-suite-0.3.0.0 (GabrielGonzalez)
12:45:26 <Emilijus> How would that be written exactly if I may ask?
12:45:47 * hackage grpc-haskell 0.0.0.0 - Haskell implementation of gRPC layered on shared C library.  https://hackage.haskell.org/package/grpc-haskell-0.0.0.0 (GabrielGonzalez)
12:50:08 <blazered__> https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/type-families-and-pokemon#associated-type-synonyms
12:50:49 <blazered__> Scroll down to the last example, "date Move pokemon :: *" there is what you want.
12:51:01 <blazered__> The thing is called associated types
12:51:22 <RedNifre> I had the problem that I tried x == Bla on something that was not Eq and I solved it by pattern matching like "foo Bla =". But how does that actually work? Doesn't the pattern matching mechanism have to equate the things, too?
12:51:23 <halogenandtoast> s/date/data/
12:52:01 <RedNifre> (It was a simple data type like data Bleh = Bla | Blub)
12:52:03 <halogenandtoast> RedNifre: it's comparing type constructors, not the data contained
12:52:15 <blazered__> or associated type synonyms
12:52:30 <halogenandtoast> *data constructors
12:52:35 <halogenandtoast> no idea why I said type...
12:52:49 <RedNifre> I don't understand. How is x == Bla different from what the pattern matching mechanism does when it figures out if "foo Bla =" is the right match?
12:53:16 <opqdonut> RedNifre: consider a more complex type like "data MyType = Foo (Int -> Int) | Bar (Char -> Char)"
12:53:33 <opqdonut> RedNifre: you can still pattern match it, but you can't write an Eq instance since you don't have equality for functions
12:54:05 <blazered__> Emilijus: you would have to write "type KeyType a :: *" to get a synonym. Then "getKey :: a -> KeyType a"
12:54:09 <opqdonut> RedNifre: but for your simple Bleh, you should've just added "deriving Eq" and GHC would've written the obvious implementation of == for you
12:54:28 <halogenandtoast> My guess is they didn't control the definition
12:54:33 <RedNifre> Ah, so "==" is for the complete thing, while pattern matching only works on the parts that are "naturally" Eq?
12:55:04 <RedNifre> I.e. the "Foo" of "Foo (Int -> Int)" is naturally Eq, even though the whole thing isn't explicitely Eq?
12:55:06 <Emilijus> Thank you blazered__, I had a feeling, that this could be solvable with some language extension, but my knowledge about them is very minimal.
12:55:53 <halogenandtoast> you can destructure algebraic data types into the constructor and the values, you can then match on the constructor (and/or) the values if you want.
12:56:10 <halogenandtoast> You can do it with lists for example
12:56:21 <halogenandtoast> foo [] = something
12:57:00 <halogenandtoast> probably a bad example
12:57:03 <halogenandtoast> :shrug:
12:58:11 <RedNifre> But there is no "PatternMatchable", it's a fundamental feature of the language, right?
13:00:07 <halogenandtoast> I've never actually looked at the implementation of how destructuring works, but I think it's probably best to think of it as a "label" that can inherently be compared
13:00:33 <halogenandtoast> You don't have to say a data constructor can be pattern matched, it just is
13:01:05 <halogenandtoast> now I actually want to know how this is implemented...
13:01:45 <mreh> do `instance FromJSON a => MimeUnrender JSON a where` and `instance MimeUnrender JSON ByteString where` overlap?
13:03:44 <mreh> I just want my API to accept JSON and read it as a bytestring *cries*
13:04:09 <mreh> hystrionics will surely make someone help me
13:06:07 <fendor> does stack script set any environment variables to indicate that a script has been run by stack and not compiled with ghc?
13:09:36 <halogenandtoast> mreh more than likely your api would accept a bytestring and convert it to json no?
13:09:42 <halogenandtoast> it's over http right?
13:09:59 <halogenandtoast> as in, it's part of a request body?
13:10:54 <mreh> halogenandtoast, it accepts JSON but I need to access the raw bytestring to verify it
13:12:08 <mreh> it's a Stripe webhook and I need to check the body against a checksum and a secret, but once it's been parsed by Aeson, it's no good to serialize it again and use that
13:13:51 <halogenandtoast> mreh: not sure what you mean, there is encode :: ToJSON a => a -> ByteString
13:14:45 <mreh> halogenandtoast: I mean that `decode . encode` is not the same as `id`, so I can't get the original bytes of the request body
13:15:22 <fen> is there a version of list using sum instead of product type for cons? like either head or tail
13:15:24 <mreh> I'll create my own content type that's the same as JSON, but returns the raw body too
13:15:59 <halogenandtoast> mreh: I would, without knowing your setup, figure out how to get access to the http request
13:16:29 <mreh> halogenandtoast, it's Servant, so it's mostly done by magic
13:17:36 <fen> actually it might be easier to consider the stream variant to save the confusion on the empty stum constructor
13:17:40 <fen> sum*
13:18:04 <fen> ie Cofree Identity instead of Cofree Maybe. 
13:19:30 <fen> data Steam a = Stream ((,) a (Stream a)
13:19:34 <fen> data EitherStream a = EitherCons (Either a (EitherStream a))
13:20:03 <fen> its a thing?
13:22:14 <fen> might not seem totally obvious why this is useful at first, but it can contain information about the thing that produced the value for example
13:22:21 <fen> isomorphic to (Int,a) ?
13:23:20 <halogenandtoast> mreh: I think you're still inside a Wai Handler no?
13:23:50 <halogenandtoast> ah but I don't know where the Request is in this case...
13:24:20 <fen> there is a function for example where a nested state, which is like nested eithers, has these all commuted into a state giving this kind of eitherlist
13:24:27 <fen> sorry its really hard to describe
13:25:41 <fen> but basically it stores the information about which depth of nesting of states was the value produced by
13:28:25 <halogenandtoast> fen: looks a lot like a Free monad to me.
13:29:01 <fen> no its not
13:29:04 <halogenandtoast> ok
13:29:19 <fen> but its close
13:29:54 <fen> if Free is Fix + Maybe, and Cofree is Fix + (,) a, this is Fix + Either a
13:29:55 <technocrat> Where I am?
13:30:16 <fen> hi technocrat, this is #haskell!
13:31:36 <fen> um, wait, if list is Cofree Maybe = (Fix + (,) a) Maybe
13:32:05 <fen> this is ? Maybe = (Fix + Either a) Maybe
13:33:06 <fen> Cofree f a = Cofree ((,) a (f a))
13:33:22 <fen> ? f a = ? (Either a (f a))
13:36:22 <fen> thats not isomorphic to anything more common is it?
13:36:55 <fen> sorry that was wrong;
13:37:25 <fen> Cofree f a = Cofree ((,) a (f (Cofree f a)))
13:37:40 <fen> ? f a = ? (Either a (f (? f a)))
13:39:17 * hackage freq 0.1.1 - Are you ready to get freaky?  https://hackage.haskell.org/package/freq-0.1.1 (chessai)
13:40:09 <fen> halogenandtoast, you think it could be Free something?
13:42:16 <fen> maybe it is... like the way Cofree is Fix something
13:47:15 <fen> ah, no its not because its Fix something...
13:47:20 <fen> Cofree f a = Fix (\f -> (,) a (f a)) 
13:47:20 <fen> ? f a = Fix ((\f -> Either a (f a)) f)
13:47:54 <fen> ? f a = Fix (\f -> Either a (f a))
13:48:09 <fen> its a new thing?
13:49:17 <fen> if so it needs a name...
13:52:02 <fen> wait is that still wrong, looks more like free now...
13:52:30 <fen> its supposed to be like a | a | a | a | a | a | a | a | a .....
13:52:48 <fen> where that is with f = Identity
13:56:14 <fen> yeah the origninal question was a better way to ask this, instead of trying and failing to answer that question to describe it better...
13:56:28 <fen> if list is (,) head tail
13:56:34 <fen> whats Either head tail
14:03:07 <fen> ah, thats whats confusing, the `f' and the `a' merge together;
14:03:55 <fen> data Free f a = Free (f (Free f a)) | Pure a 
14:04:00 <fen> ? f a = ? (f a) | ?? (? f a)
14:04:14 <fen> ? a = ? a | ?? (? a)
14:05:41 <fen> ? = Free Maybe
14:05:43 <fen> ffs
14:05:45 <fen> sorry
14:08:32 <_kwstas> hello there! QQ: is there any way to `show` a record without the field names: e.g.`show (Val { _name = "val", _type = "String" }) -> "Val val String"`? 
14:10:01 <fen_> you want to use Deriving Show?
14:10:18 <_kwstas> yeao
14:10:23 <_kwstas> *yeap
14:10:32 <fen_> seems like it would need a custom show instance
14:11:12 <fen_> seems like a common way to implement one, but still, you couldnt expect Deriving to be able to cover that case 
14:12:29 <_kwstas> some background: I used to have few dozen of types with two three fields each, with a lot of doctest. Then I decided that I would need to use lenses in order to be able to handle them easier, so I converted all the types to records. As a result all my doctests are now broken :(
14:13:12 <_kwstas> hm...ok so i may just fox my doctests... it seems both easier and more appropriate
14:15:15 <fen_> so the question is if you can use lenses to write these show instances in a very easy way?
14:18:02 <_kwstas> I have already implemented a pretty printer for all these types... and because of their amount, believe me it was not a trivial thing to do... doctest are for sure less of a pain to fix!  
15:18:52 <dmwit> ?tell fen [a] : (,) a [a] :: (Nat, a) : Either a (Nat, a)
15:18:53 <lambdabot> Consider it noted.
15:20:04 <Solonarv> ?tell fen Cofree f a ~ Fix (Compose ((,) a) f); Free f a ~ Fix (Compose (Either a) f)
15:20:04 <lambdabot> Consider it noted.
15:20:19 <Solonarv> fen's going to come back to a storm :>
15:20:34 <dmwit> ?tell _kwstas You could use -ddump-deriv to get the code that GHC derived for Show before you made them records, then just reuse that code directly even after you turn them into records.
15:20:34 <lambdabot> Consider it noted.
15:20:37 <Solonarv> the funny thing is I've said this exact thing before and they still managed to get confused
15:21:35 <lyxia> ?tell _kwstas deriving Show via (Surgery Derecordify MyType)  using https://hackage.haskell.org/package/generic-data (see README)
15:21:35 <lambdabot> Consider it noted.
15:21:59 <Solonarv> oh, generic-data already does that, of course it does :>
15:22:14 <Solonarv> that library is awesome wizardry
15:22:15 <dmwit> Whoa.
15:24:00 <dmwit> This library is wild.
15:26:31 * glguy peeks
15:42:53 <oisdk> Does anyone know anything about backtracking monad transformers for ordered search?
15:43:06 <oisdk> This would be an example https://hackage.haskell.org/package/monad-dijkstra-0.1.1.2
15:43:30 <dmwit> ?where justask
15:43:30 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
15:43:55 <oisdk> dmwit I'm just looking for links!
15:44:19 <oisdk> Can't find anything more than that, was wondering if there was a paper or something floating around
15:44:21 <lyxia> oisdk: logict?
15:44:51 <dmwit> There's LogicT and that one weird paper that I never quite wrapped my head around that does a sort of inversion of control thing for its searches.
15:44:58 <lyxia> @where oleg
15:44:58 <lambdabot> http://okmij.org/ftp/
15:46:08 <oisdk> LogicT doesn't order the search in the way I want, I don't think. I'm looking for something that'll let me use an arbitrary ordered monoid (or something) to choose branches
15:46:17 * hackage multiprocess 0.0.0 - Multiprocess architecture library  https://hackage.haskell.org/package/multiprocess-0.0.0 (ChrisDone)
15:46:25 <dmwit> https://arxiv.org/pdf/1406.2058.pdf looks like what I was thinking of
15:47:08 <geekosaur> LogicT doesn't care about ordering at all, that's something of the point.
15:47:25 <oisdk> Yeah i can't figure out how to extend either of those, unfortunately
15:48:02 <dmwit> http://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Select.html
15:48:52 <oisdk> or more specifically, I'm looking for the right way to express something like dijkstra's algorithm algebraically in a similar way to LogicT or "algebras for combinatorial search"
15:49:04 <lyxia> I see, I don't have anything close to what you're looking for. :/
16:29:47 * hackage mmorph 1.1.3 - Monad morphisms  https://hackage.haskell.org/package/mmorph-1.1.3 (GabrielGonzalez)
17:05:30 <royal_screwup21> in this defnition: data Add k k = k :+ k -- what is the ":+" doing??
17:06:27 <royal_screwup21> sorry, data Add k = k :+ k
17:06:36 <royal_screwup21> is it sugar for Add k k?
17:07:01 <jackdk> it is a constructor, just like `:` is for lists
17:09:34 <Iceland_hask> royal_screwup21: Infix can obfuscate, it's actually
17:09:34 <Iceland_hask>   data Add k = MkAdd k k
17:09:34 <Iceland_hask> 'k' would only appear once on the left-hand side
17:09:52 <royal_screwup21> ah gotcha thanks
17:09:56 <Iceland_hask> MkAdd equals your (:+)
17:10:11 <Iceland_hask> You can write (:+) "prefix".. eh
17:10:21 <Iceland_hask>   data Add k = (:+) k k
17:10:31 <Iceland_hask> and similarly.. k `MkAdd` k
17:10:40 <Iceland_hask> It feels pretty logical
17:11:39 <Iceland_hask> Their types are
17:11:39 <Iceland_hask>   MkAdd :: k -> k -> Add k
17:11:39 <Iceland_hask>   (:+)  :: k -> k -> Add k
17:13:07 <Iceland_hask> Similarly the kind of Add is
17:13:07 <Iceland_hask>   >> :kind Add
17:13:07 <Iceland_hask>   Type -> Type
17:13:31 <Iceland_hask> I like to be explicit about this and write it as
17:13:31 <Iceland_hask>   data Add :: Type -> Type where
17:13:31 <Iceland_hask>     MkAdd :: k -> k -> Add k
17:15:51 <royal_screwup21> ah I see
17:16:27 <royal_screwup21> I have a datatype like so: data Free f a = Var a | Op (f (Free f a) 
17:16:42 <royal_screwup21> I'm trying to write a functor instance for it
17:17:06 <royal_screwup21> so fmap f (Var a) = Var (f a) 
17:17:21 <royal_screwup21> I'm not sure how to quite do it for the second constructr
17:17:35 <Iceland_hask> Pretend f ~ []
17:17:42 <royal_screwup21> hmm ok
17:19:15 <royal_screwup21> hmm do I need two two fmaps?
17:19:18 <royal_screwup21> this is confusing
17:20:01 <glguy> Yeah, you'll need two.
17:20:02 <Iceland_hask> one for each layer
17:20:06 <Iceland_hask> But you can get away with one
17:20:13 <royal_screwup21> wait, that that "f" there also has to be a functor 
17:20:13 <Iceland_hask> if you define
17:20:13 <Iceland_hask>   Op :: Compose [] Free a -> Free a
17:20:27 <Iceland_hask> (specialized to f ~ [])
17:20:54 <Iceland_hask> fmap @(Compose [] Free) becomes two fmaps
17:21:28 <royal_screwup21> hmm will have to look up what Compose is 
17:21:50 <Iceland_hask> Data.Functor.Compose, to give you the idea that it exists
17:22:42 <royal_screwup21> ah okay
17:22:43 <royal_screwup21> Compose :: f (g a) -> Compose f g a
17:22:44 <Iceland_hask> Basically every time you have 
17:22:44 <Iceland_hask>   f (g a)
17:22:44 <Iceland_hask> you can replace it with
17:22:44 <Iceland_hask>   Compose f g a
17:23:21 <Iceland_hask> royal_screwup21: Important note; there is no
17:23:21 <Iceland_hask>   instance (Monad m1, Monad m2) => Monad (Compose m1 m2)
17:23:31 <Iceland_hask> aka "Monads don't compose"
17:25:01 <royal_screwup21> so the idea behind fmap is to transform a data structure parameterized on a, to b 
17:25:22 <royal_screwup21> so I need to some how convert Op (f (Free f a)  to...Op (f (Free f b) 
17:25:39 <Iceland_hask> Do you know the type of Op?
17:26:24 <royal_screwup21> ah hmm, I know it's basically just a contructor
17:26:44 <royal_screwup21> f Free a -> Free a 
17:27:03 <royal_screwup21> f (Free a) -> Free a *
17:27:09 <Iceland_hask> yes
17:27:26 <Iceland_hask> try reading the same info from the -XGADTs style
17:27:26 <Iceland_hask>   data Free :: (Type -> Type) -> (Type -> Type) where
17:27:26 <Iceland_hask>     Var :: a            -> Free f a
17:27:26 <Iceland_hask>     Op  :: f (Free f a) -> Free f a
17:27:44 <royal_screwup21> hmm okay...
17:28:25 <royal_screwup21> hmm
17:28:36 <Iceland_hask> with f ~ []
17:28:37 <Iceland_hask>   data FreeList :: Type -> Type where
17:28:37 <Iceland_hask>     Var :: a            -> FreeList a
17:28:37 <Iceland_hask>     Op  :: [FreeList a] -> FreeList a
17:28:45 <royal_screwup21> what if I unwrap it from the f, then fmap that 
17:28:47 * hackage yesod-fay 0.10.0 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  https://hackage.haskell.org/package/yesod-fay-0.10.0 (swamp_agr)
17:29:59 <Iceland_hask> see if it works
17:30:20 <royal_screwup21> so fmap Op op 
17:30:24 <royal_screwup21> op:: f (Free f a)
17:30:41 <royal_screwup21> I need to do some magic to this and finally get Free f b 
17:31:00 <royal_screwup21> fmap f (Op op)**
17:31:18 <royal_screwup21> f:(a->b_
17:34:48 <royal_screwup21> not seeing this
17:40:36 <Iceland_hask> royal_screwup21: the definition is
17:40:36 <Iceland_hask>   fmap f (Op frees) = Op (fmap (fmap f) frees)
17:42:08 <Iceland_hask> But with {-# LANGUAGE DeriveFunctor #-} GHC will .. just write it
17:42:08 <Iceland_hask>   data Free f a = Var a | Free (f (Free f a)) deriving (Functor)
17:42:35 <Iceland_hask> *| Op (f (Free f a)) ..
17:45:43 <jlamothe> Is anyone here familiar with yesod?  I can't seem to talk on the #yesod channel directly for some reason.
17:46:17 <jlamothe> I'm trying to run a MonadHandler inside of a TextExample and extract the result for evaluation.
17:46:30 <jlamothe> I'm either being dense, or there isn't a way to do this.
17:46:42 <jlamothe> TestExample*
17:46:51 <jlamothe> YesodExample*
17:46:56 <jlamothe> It's been a long day...
18:23:55 <dmwit> jlamothe: Some channels require you to be authenticated to NickServ before you can join. Perhaps #yesod is one of them, and you are not authenticated.
18:24:17 <dmwit> (Don't know how to ask my current client whether you're auth'd and what #yesod's permissions are, so can't confirm this hypothesis myself, sorry.)
18:27:50 <geekosaur> it may also be set to quiet unauth users still
18:49:15 <glguy> Yes, jlamothe is in fact not identified and #yesod mutes unidentified users
18:49:33 <glguy> jlamothe: Registration is pretty quick. Check out /msg NickServ HELP REGISTER
18:50:52 <geekosaur> they
18:50:57 <geekosaur> re registered, just not authed
18:54:55 <z0> i thought this was an apripriate place to ask: what is going on with this big (and small) o notaion: https://en.wikipedia.org/wiki/Time_complexity#Second_definition ?
18:55:47 <lyxia> z0: Landau notation https://en.wikipedia.org/wiki/Landau_notation
18:55:48 <z0> never seen O(2^n) written as 2ªO(n) nor an O overbar
18:57:44 <lyxia> I haven't seen O with a bar either
18:57:56 <lyxia> but O(2^n) is very different from 2^O(n)
18:58:44 <lyxia> The 2 matters in the former, not the latter.
18:58:53 <z0> according to the article, its exponential time
18:59:40 <z0> im intrigued. its also consistently used throughout the whole article
18:59:57 <z0> for distinct complexities
19:00:57 <z0> only when n is part of the exponent
19:04:15 <geekosaur> Õ is listed in your article, it's ignoring logarithmic components because they're dominated by something else
19:59:32 <fen> https://pastebin.com/raw/iNrRETqj
20:00:04 <fen> turns out the idea with a | a | a ... was wrong
20:00:14 <fen> thats why it ended up collapsing down to Free
20:00:45 <fen> really there was supposed to be an `f' choice somewhere around those `a' values 
20:00:58 <fen> which does not seem to fit Free so easily
20:01:09 <fen> dmwit,Solonarv: ^
20:15:47 * hackage cabal-cache 1.0.0.1 - CI Assistant for Haskell projects  https://hackage.haskell.org/package/cabal-cache-1.0.0.1 (haskellworks)
20:41:33 <c50a326> I understand how `fmap fmap` is `f1 (a -> b) -> f1 (f2 a -> f2 b)` ... I was then trying to write out `fmap fmap fmap` in my notes... I got `f1 (f2 (a -> b)) -> f1 (f2 (f3 a -> f3 b)) ... but in ghci it says `f1 (a -> b) -> f1 (f2 a -> f2 b)`
20:49:50 <Lears> c50a326: Neither of those is right. mapping over a function is composition, so `fmap fmap fmap` is `(.) fmap fmap` aka `fmap . fmap`. That lifts a function over two levels of functor: (Functor f, Functor g) => (a -> b) -> (f (g a) -> f (g b))
21:09:33 <suzu> :t fmap
21:09:34 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:09:45 <suzu> :t fmap fmap
21:09:46 <lambdabot> (Functor f2, Functor f1) => f1 (a -> b) -> f1 (f2 a -> f2 b)
21:09:52 <suzu> :t fmap fmap fmap
21:09:53 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
21:10:52 <suzu> :t fmap . fmap
21:10:54 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
21:11:16 <suzu> it's kinda brain-melting but if you substitute carefully you can see how the result is made
21:44:47 * hackage Villefort 0.1.2.19 - Villefort is a task manager and time tracker  https://hackage.haskell.org/package/Villefort-0.1.2.19 (AliceReuter)
22:06:40 <c50a326> :t fmap .
22:06:42 <lambdabot> error:
22:06:42 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
22:06:46 <c50a326> :t . fmap
22:06:47 <lambdabot> error: parse error on input ‘.’
22:06:54 <c50a326> :t (.) fmap
22:06:56 <lambdabot> Functor f => (a1 -> a2 -> b) -> a1 -> f a2 -> f b
22:07:02 <c50a326> :t fmap (.)
22:07:03 <lambdabot> Functor f => f (b -> c) -> f ((a -> b) -> a -> c)
22:10:18 <c50a326> mapping over a function is composition? :S
22:12:19 <c50a326> yeah I suppose if you have an (a -> b) and a (b -> c) and you map the one over the other ... hmmm
22:15:22 <jackdk> If you work through the type of `fmap` with `f ~ ((->) r)`, composition falls out. (you can't write operator sections in types, but ((->) r) would be (r ->) if you could)
22:15:52 <Lears> % :t fmap @((->) _)
22:15:52 <yahb> Lears: (a -> b) -> (w -> a) -> w -> b
22:18:16 <c50a326> are there some exercises I can do to develop some intuition about this?
22:20:21 <jackdk> 1. Write out `fmap :: Functor f => (a -> b) -> f a -> f b` 2. Set `f ~ ((->) r)`: `fmap :: (a -> b) -> ((->) r a) -> ((->) r b)`. 3. rearrange to make it look more normal
22:22:46 <c50a326> (a -> b) -> (r -> a) -> (r -> b) 
22:26:39 <jackdk> there's only one sensible function you can write for that type, and that is the function that composes functions
22:27:35 <jackdk> roughly: this is because you know nothing about a, b, or r, so the only thing you know that's definitely an r is the one you were given, and the only way to get a b out the end is to feed it through the two functions you were give.
22:27:38 <jackdk> given*
22:35:31 <phadej> ca/wg 36
22:48:17 <c50a326> thanks for the clear explanation!
22:58:36 <Axman6> c50a326: you might find these useful for building the intuition - the lack of meaningful names means you have to just follow the types: http://blog.tmorris.net/posts/20-intermediate-haskell-exercises/
23:00:39 <jle`> oh wow i ran into a situation where Day convolution was the perfect tool
23:00:43 <jle`> ...how did this happen
23:02:41 <MasseR> blog post coming? :)
23:30:16 <jle`> it's pretty situational heh. but trying to process how the circumstances arose
23:30:29 <jle`> maybe it's from this weird functor-based style i'm using
23:36:17 * hackage multi-containers 0.1.0.0 - A few variants of multimaps.  https://hackage.haskell.org/package/multi-containers-0.1.0.0 (zliu41)
