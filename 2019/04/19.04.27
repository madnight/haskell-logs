00:05:17 * hackage pomaps 0.0.2.1 - Maps and sets of partial orders  https://hackage.haskell.org/package/pomaps-0.0.2.1 (sgraf812)
00:14:36 <c50a326> quick n easy way to export all of a module?
00:15:14 <c50a326> ah just don't put the ( ... ) bit, cool
00:20:46 <zincy> What is the difference between parametric and adhoc polymorphism?
00:26:03 <c_wraith> parametric -> the implementation can't depend on the type.  ad-hoc -> the implementation can depend on the type. That's done by putting a class constraint on the type.
00:28:44 <c_wraith> So like...  (==) :: Eq a => a -> a -> Bool  --  ad-hoc.   map :: (a -> b) -> [a] -> [b]  -- parametric.   fmap :: Functor f => (a -> b) -> f a -> f b -- ad-hoc in f, parametric in a and b
00:39:11 <lavalike> why is it called "ad-hoc"?
00:40:15 <c50a326> vscoders, do you guys just `stack build && stack exec ghci` followed by "import Whatever" followed by your experiments, when you want to experiment with your code in ghci?
00:41:00 <c50a326> ah there's a --file-watch `stack build` sorry my bad
00:41:24 <c50a326> (was playing with haskell before and now returning after playing with other stuff for a while so trying to remember everything :))
00:43:34 <c50a326> oh cool there's also stack ghci --with-ghc=ghcid
00:50:44 <c50a326> dammit, getting this https://github.com/commercialhaskell/stack/issues/3015#issuecomment-381271747
00:51:48 <jgt> if I have a list of tuples, how can I operate on one of the snd values by first selecting its fst value? The obvious answer is Map.fromList, but I can't do this in this case because my list of tuples has duplicate fst values, and I need to retain those duplicates
00:54:50 <jgt> I suppose I can manually remove the element I want to operate on, and then add it again
00:55:06 <jgt> IRC: The *best* rubber duck
00:59:27 <jgt> > filter (\(k, _) -> k /= "baz") [("foo", "bar"), ("baz", "qux"), ("spam", "eggs")] <> [("baz", "newqux")]
00:59:28 <lambdabot>  [("foo","bar"),("spam","eggs"),("baz","newqux")]
01:04:42 <jgt> is there a shorter way to write (\(k, _) -> k /= "foo")? I'm thinking something in terms of fst, with a section
01:04:51 <jgt> but I can't quite wrap my head around it
01:06:27 <lavalike> :t \f p -> map (\(x,y) -> if p x then (x,y) else (x,f y)) -- jgt something like this?
01:06:28 <lambdabot> (t -> t) -> (a -> Bool) -> [(a, t)] -> [(a, t)]
01:07:00 <jgt> I don't think that's what I'm after
01:07:38 <jgt> > filter ((/= "foo") . fst) [("foo", "bar"), ("baz", "qux"), ("spam", "eggs")]
01:07:39 <lambdabot>  [("baz","qux"),("spam","eggs")]
01:07:42 <jgt> there we go
01:09:21 <lavalike> > (\f p -> map (\(x,y) -> if p x then (x,f y) else (x,y))) (*100) (/= "foo") [("foo",5),("bar",3),("foo",3),("baz",5)]
01:09:23 <lambdabot>  [("foo",5),("bar",300),("foo",3),("baz",500)]
01:10:21 <jgt> oh I see
01:10:27 <jgt> hmm maybe that makes more sense
01:11:32 <c50a326> ah I was after `stack exec -- ghci --test="someExpr"`
01:11:41 <c50a326> ah I was after `stack exec -- ghcid --test="someExpr"`   even
01:12:32 <jgt> lavalike: sorry, I had such a braindead moment. Of course your approach works.
01:13:20 <lavalike> np! I was thinking concatenating is costly if you don't need it
01:15:14 <jgt> lavalike: is concatenating costly? I would have thought in this case it's negligible
01:15:23 <jgt> (I haven't measured)
01:15:55 <lavalike> for lists it is
01:16:13 <lavalike> @src (++)
01:16:13 <lambdabot> []     ++ ys = ys
01:16:13 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
01:16:14 <lambdabot> -- OR
01:16:16 <lambdabot> xs ++ ys = foldr (:) ys xs
01:17:03 <lavalike> it *has* to traverse both args (only as soon as you consume the result of course)
01:17:44 <fen> How can I restrict the type returned by a type family to be of some class?
01:17:57 <jgt> I'll bear that in mind next time I do an RTS run
01:18:09 <jgt> in this case it's one concatenation on a small list
01:18:51 <fen> type family A a :: * -> * -- this restricts the kind of the type returned to be (* -> *), but what if it was also supposed to be a Functor?
01:19:31 <fen> jgt: and one giant concatenation for mankind
01:19:40 <jgt> :D
02:17:27 <mjrosenb> oh... indexing does not do what I thought it does.
02:20:52 <mjrosenb> I have an Array (Int, Int) Foo, and I thought indexing on a traversal over it would use tuples of ints
02:20:57 <mjrosenb> but it uses ints.
03:58:09 <phadej> mjrosenb: are you using itraversed ?
04:14:55 <phadej> :t itraversed
04:14:56 <lambdabot> (Applicative f, Indexable i p, TraversableWithIndex i t) => p a (f b) -> t a -> f (t b)
04:26:38 <lavalike> why does i not appear in the type?
04:30:35 <Guest99141> Hello
04:32:16 <Guest99141> Is there someone here ?
04:32:32 <lavalike> slow saturday
04:32:47 <Guest99141> Yeah I get it men
04:32:51 <Guest99141> Wassup 
04:41:16 <Guest99141> Yo men
04:45:04 <Guest99141> No one's talking ?
04:55:18 <gonz_> If you have a question, just ask it and someone will likely help if they can.
04:55:50 <gonz_> If you're looking for casual conversation and not people idling, you may be a decade or so late to IRC.
04:56:10 <gonz_> s/a decade/a couple of decades
05:10:21 <Athas> I'm always up for casual conversation about parallel functional programming!  Standing invitation!
05:35:52 <Ariakenom> Athas: Obliged! Futhark on supercomputers?
05:40:05 <n-st> hi :)
05:40:35 <n-st> i'm rather unexperienced with haskell and trying to add a new config option to an existing program (paperboy)
05:40:58 <n-st> the existing config options are parsed via config-ini and read like this: `let action = if configData ^. importMove then Move else Copy`
05:41:13 <n-st> what's that ^. operator? i've never seen it before…
05:43:19 <[exa]> nst^: it's from lenses, probably covered in any lens tutorial
05:43:36 <[exa]> n-st: oh sorry, bad highlight ^^
05:44:40 <[exa]> n-st: see here https://hackage.haskell.org/package/lens-tutorial-1.0.3/docs/Control-Lens-Tutorial.html#g:3
05:51:35 <n-st> [exa]: thanks
05:52:20 <n-st> now to debug why the config parser expects a Char when i've explicitly typed that variable to [Char]…
06:16:52 <Athas> Ariakenom: low impact; too few supercomputers.
06:20:14 <Ariakenom> how about the broader instance of a bunch of networked CPUs
06:40:45 <JoeCordingley> Hi, I was wondering how people use hunit to test a single value of deeply nested data structures?
06:42:29 <JoeCordingley> I don't want to assert on the whole thing, just one value that may or may not be there, and if it isn't I'd like to know what match it failed on
06:46:14 <vtMoose> Joe I think you're looking for something like test1 in the example https://github.com/hspec/HUnit/blob/master/examples/Example.hs
06:53:21 <mreh> trying to get my head round Aeson and the Generic parsers / encoders: https://gist.github.com/mrehayden1/801f62fa621de17fe05ca41d76d80abe
06:53:47 <mreh> does that not map US -> "us" and "us" -> US
06:53:52 <mreh> the encode works, the decode doesn't seem to
06:56:51 <mreh> actually, the encode doesn't work either
07:00:48 <Solonarv> you want to use the same modifier for both ToJSON and FromJSON I'm pretty sure
07:01:32 <mreh> Solonarv: if you say so, however I think I'm completely misunderstanding the purpose of the generics
07:02:00 <mreh> I was trying to get round writing all the cases for every country
07:02:23 <Solonarv> the generic representation contains information like: this data type has one constructor named "US"
07:02:43 <Solonarv> constructorTagModifier describes how to turn the constructor's name into a JSON string
07:02:46 <mreh> right, in a tag I think
07:02:58 <mreh> that's for union types
07:03:19 <mreh> which this is, but I want to turn every value into a String
07:03:43 <Solonarv> the way you've written it, ToJSON will emit a "us" tag but FromJSON expects a "US" tag - obviously this doesn't work
07:04:07 <Solonarv> % data Color = Red | Green | Blue deriving (Generic, Show, Eq)
07:04:07 <yahb> Solonarv: ; <interactive>:82:43: error: Not in scope: type constructor or class `Generic'
07:04:18 <Solonarv> % import GHC.Generics
07:04:18 <yahb> Solonarv: 
07:04:19 <Solonarv> % data Color = Red | Green | Blue deriving (Generic, Show, Eq)
07:04:19 <yahb> Solonarv: ; <interactive>:84:43: error:; * Can't make a derived instance of `Generic Color': You need DeriveGeneric to derive an instance for this class; * In the data declaration for `Color'
07:04:23 <Solonarv> fuck's sake
07:04:33 <Solonarv> % data Color = Red | Green | Blue deriving (Generic, Show, Eq)
07:04:33 <yahb> Solonarv: 
07:04:54 <srid> Is there a way to currently prevent generation of `.ghc.environment.x86_64-linux-8.6.4` - or at least remove it automatically (assuming Nix)? I think it is interfering with flycheck-haskell.
07:04:56 <Solonarv> bah, yahb doesn't have aeson available
07:05:22 <Solonarv> srid: yes - edit ~/cabal/config and change 'write-ghv-environment-files' to 'never'
07:05:58 <Solonarv> you can also change this for a single project by setting the option in ./cabal.project.local
07:07:22 <srid> Solonarv: I added `write-ghv-environment-files: never` (top-level) to ./cabal.project.local and it had no effect (after a new-build)
07:07:41 <srid> using Cabal 2.4.1
07:07:50 <Solonarv> just to make sure: you did remove the existing env file, yes?
07:08:03 <Solonarv> er, also there's a typo
07:08:11 <Solonarv> it should of course be ghc not ghv
07:08:42 <srid> oops, works now
07:08:51 <Solonarv> \o/
07:10:19 <Solonarv> mreh: also, if you're defining toEncoding with custom options you should 100% also define toJSON with the same custom options
07:10:28 <Solonarv> otherwise they will give different output
07:11:03 <mreh> Solonarv, doesn't it stand to reason that the decode should use the inverse of the encode when converting to/from tags
07:11:18 <Solonarv> I can sort of see that making sense, but no
07:11:54 <Solonarv> the Generic machinery gives a type-level representation of the definition of a datatype
07:11:56 <Solonarv> example:
07:12:03 <Solonarv> % :kind! Rep Color
07:12:03 <yahb> Solonarv: Rep Color :: * -> *; = D1 ('MetaData "Color" "Ghci27" "interactive" 'False) (C1 ('MetaCons "Red" 'PrefixI 'False) U1 :+: (C1 ('MetaCons "Green" 'PrefixI 'False) U1 :+: C1 ('MetaCons "Blue" 'PrefixI 'False) U1))
07:12:09 <mreh> ah, okay I see
07:13:35 <Solonarv> the modifiers to pass to aeson's generic*** functions tell it which strings to use for constructor tags, field labels &c based on the strings recorded in this generic representation
07:13:54 <mreh> yeah
07:14:48 <Solonarv> so this means you need to use the same options two times (three times if you're also defining toEncoding)
07:16:29 <Solonarv> it's probably a good idea to do something like:
07:16:29 <Solonarv> data Country = ... deriving Generic
07:16:29 <Solonarv> countryJSONOptions = defaultOptions { constructorTagModifier = fmap toLower }
07:16:29 <Solonarv> instance ToJSON Country where
07:16:29 <Solonarv>   toJSON = genericToJSON countryJSONOptions
07:16:30 <Solonarv>   toEncoding = genericToJSON countryJSONOptions
07:16:32 <Solonarv> instance FromJSON Country where
07:16:34 <Solonarv>   parseJSON = genericParseJSON countryJSONOptions
07:20:27 <Solonarv> mreh: and if you needed to provide an inverse, there'd still be a problem - fmap toLower and fmap toUpper are not inverses!
07:20:51 <Solonarv> > ap (==) (map toLower . mapToUpper) "Hello World!"
07:20:53 <lambdabot>  error:
07:20:53 <lambdabot>      Variable not in scope: mapToUpper :: [Char] -> [Char]
07:21:00 <Solonarv> > ap (==) (map toLower . map toUpper) "Hello World!"
07:21:02 <lambdabot>  False
07:21:29 <Solonarv> so really it's a very good thing you aren't required to provide inverses :P
07:37:51 <tb15> Hello, I'm a complete novice at this (so forgive me if I'm doing anything incredibly stupid). I'm trying to use happy to make a glr parser - calling with --glr --decode and getting the following error:
07:38:25 <tb15> ➜ stack exec make
07:38:25 <tb15> happy -gca --glr --decode ParCut.y
07:38:25 <tb15> shift/reduce conflicts:  15
07:38:25 <tb15> GLR-Happy doesn't support multiple start points (yet)
07:38:25 <tb15> Defaulting to first start point.
07:38:25 <tb15> alex -g LexCut.x
07:38:26 <tb15> ghc --make TestCut.hs -o TestCut
07:38:26 <tb15> PrintCut.hs:1:33: warning:
07:38:26 <tb15>     -XOverlappingInstances is deprecated: instead use per-instance pragmas OVERLAPPING/OVERLAPPABLE/OVERLAPS
07:38:27 <tb15>   |
07:38:27 <tb15> 1 | {-# LANGUAGE FlexibleInstances, OverlappingInstances #-}
07:38:28 <tb15>   |                                 ^^^^^^^^^^^^^^^^^^^^
07:38:44 <tb15> Ah great that worked. 
07:39:21 <tb15> Is this failing as I have more than one start point??
07:40:21 <Solonarv> doesn't seem to be failing at all
07:40:42 <Solonarv> it would help if you could post your code too, but please don't copy-paste it directly into IRC
07:41:08 <Solonarv> use something like https://gist.github.com (which supports multiple files, very convenient)
07:41:23 <tb15> Ah sorry about that! I didn't realise each newline would create a new message :(
07:42:04 <Solonarv> oh it's not about number-of-messages, just the fact that there's a big wall of code/text
07:42:28 <tb15> Ah right ok
07:42:34 <tb15> https://termbin.com/41hl
07:42:36 <tb15> how is that?
07:42:50 <Solonarv> much better!
07:42:54 <tb15> :)
07:43:01 <Solonarv> oh, now I see an actual error message
07:43:40 <Solonarv> that's an easy one to fix, fortunately: module names must start with an uppercase letter
07:43:58 <Solonarv> and also, module name must match file name, unless the module name is Main
07:44:25 <tb15> Great! I'm generating the code using a tool called BNFC - so am a bit unaware of what's actually going on!
07:44:52 <Solonarv> yeah, I've never used it either
07:45:05 <Solonarv> also haven't used alex or happy yet
07:47:49 <tb15> it appears to be 
07:47:54 <tb15> generating from Happy 
07:48:17 <tb15> so whenever I call 'stack exec make'
07:48:26 <tb15> it gets defaulted to lower case again
07:48:38 <tb15> I'm not sure how to call GHC manually in stack?
07:50:21 <ski> BNFC is pretty nice
07:50:23 <tb15> it gets defaulted to lower case again 
07:50:25 <tb15> ok just remove exec
07:50:46 <Solonarv> I'm actually wondering why you're using make there
07:50:56 <tb15> ski do you use it much? I'm having a whole load of fun right now ...
07:51:06 <tb15> bnfc outputs a makefile 
07:51:09 <ski> not *very* much .. but a little
07:51:11 <ski> did you call `bnfc -m ... Blah.cf' at some point ?
07:51:15 <tb15> yeah
07:51:24 <ski> you may want to change the `Makefile' it generates
07:51:54 <tb15> that could work
07:52:04 <ski> and then *not* use `bnfc' with the `-m' flag again, since then that'll overwrite your modified `Makefile' (well, i think it renames the old into a backup file, but ..)
07:52:28 <ski> you can use `-m' to get a `Makefile' to start from, but then take ownership of that for yourself
07:52:31 <ski> is what i've done
07:52:48 <tb15> ah ok - I'm transitioning between trying to get happy to give me a working glr parser
07:52:51 <tb15> and not
07:52:55 <tb15> so ive been overwriting 
07:52:57 <ski> (or, perhaps you can refrain from using `make' at all ..)
07:53:15 * ski hasn't played much with `happy' options, though
07:53:34 <tb15> ah - i fear it's going to be a huge time sink for me 
07:53:49 <Solonarv> it certainly seems to me - an uninformed bystander - that you shouldn't need to use make at all
07:54:36 <tb15> yeah, I suppose i could write a bash script
07:54:58 <Solonarv> nono you shouldn't even need that
07:55:05 <Solonarv> stack/cabal already know how to invoke alex/happy
07:55:26 <tb15> oh right
07:55:36 <tb15> ( new error https://termbin.com/558i)
07:55:38 <ski> i think BNFC uses Make to call tools like Alex and Happy (or similar for the other languages than Haskell that it can generate)
07:55:57 <Solonarv> if you set up your my-amazing-package.cabal correctly you should only need to do 'cabal build' / 'stack build' and that should work
07:56:34 <Solonarv> er, what's on line 69 of GLR_Lib.hs ?
07:56:44 <tb15> I'm currently hoping to get there. I'm attempting to write a transpiler, my first step is trying to parse the grammar.
07:57:01 <tb15> I decided on BNFC as that was what I knew, but it might not have been the right choice :(
07:57:34 <tb15> GLR_Lib.hs is not a file in my cwd...
07:57:36 <Solonarv> I've never used bnfc, alex, or happy, so all I have is somewhat vague advice
07:58:02 <Solonarv> you can use 'find' to look for it, I suppose
07:58:19 <Solonarv> the error message mentions it so clearly it must exist somewhere
08:00:10 <tb15> ➜ find ~/ -name "GLR_Lib.hs" .....
08:00:20 <tb15> is probably a wise command to execute, right
08:00:34 * ski never understood why people used terms like "transpiler" rather than simply "compiler"
08:01:01 <tb15> I think I started using it to shorten source-to-source compiler
08:01:17 <ski> isn't all compilers that ?
08:01:47 <tb15> yep
08:01:53 <ski> or .. do you mean to imply that the user will then go on editing the output from your compiler, continuing development directly on that ?
08:01:56 <nisstyre> yes, there's no such thing as a transpiler
08:02:04 <nisstyre> it's a made up term to make javascript users feel nice
08:02:23 <tb15> though the wiki makes the distinction that generally a compiler would be from a high level language to a low level language 
08:02:28 <tb15> rather than a hll -> hll 
08:02:31 <ski> i don't agree with that
08:02:34 <nisstyre> try defining "high level language"
08:02:43 <tb15> please don't make me :)
08:02:49 <ski> i definitely would consider a translation from machine code to Prolog a compiler
08:02:55 <Solonarv> I think the distinction is based on whether the target language is some not-really-readable binary format intended for consumption by a (possibly virtual) machine, or a "normal" programming language
08:03:06 <Solonarv> of course this is not exactly precise either
08:03:35 <tb15> Solonarv, find found nothing :( 
08:03:40 <Solonarv> in practice I'd say they're synonymous with slightly different connotation
08:03:44 <ski> yea .. one man's non-readable binary is another man's source
08:04:28 <Solonarv> indeed, an easy modern example: minified JS compiled from some other language
08:04:47 <ski> (what with all the binary patching of executables (even running ones, which might not exist in corresponding source form), in the industry, and with the thing that crackers do)
08:04:55 <Solonarv> or (textual) assembly, perhaps
08:05:22 <tb15> in this instance I'm trying to go from Alloy (a modelling language) to prolog. They both have relations as 'first class citizens'
08:05:33 * ski nods
08:41:03 <monochrom> w00t Alloy
09:09:27 <isovector1> is there some trick i can use to determine if a type is polykinded?
09:09:47 <isovector1> ideally `type instance (IsPolyKinded (e :: forall k. k)) = 'True` 
09:10:23 <Solonarv> hmm...
09:11:11 <Solonarv> % type family IsPolyKind (ty :: k) :: Bool where IsPolyKind (t :: forall k. k') = 'True; IsPolyKind _ = 'False
09:11:11 <yahb> Solonarv: ; <interactive>:92:60: error:; * Expected kind forall (k :: k1). k', but `t' has kind `k0'; * In the first argument of `IsPolyKind', namely `(t :: forall k. k')'; In the type family declaration for `IsPolyKind'
09:12:00 <tb15> monochrom have you done much with it?
09:12:26 <Solonarv> isovector1: I'm sure you could write a typechecker plugin that solves a type family
09:12:37 <isovector1> Solonarv: hoping to not need to do that!
09:13:34 <Solonarv> maybe you could also try to instantiate it at different kinds but that won't work for detecting arbitrary polykinds, only for detecting polykinds of some number of chosen-ahead-of-time forms
09:13:38 <isovector1> Solonarv: you can do this at the value-level by attempting to get a coercion from a polytype to `Void`
09:14:01 <Solonarv> ah, if you want to detect specifically 'forall k. k' that might e possible
09:14:36 <isovector1> yup, that is the specific case i care about
09:15:19 <isovector1> in particular i have a type parameter which is usually `* -> *` but can be unused, and in that case i use polykinds to prevent people from needing to put that kind sig there
09:15:45 <Solonarv> well the only inhabitant of the kind 'forall k. k' is TypeError (someErrorMessage)
09:15:50 <isovector1> but now i want to make a type family that detects types with my shape, so now this thing could be `* -> *` or it could be `k`
09:16:05 <isovector1> but that thing gets stuck in the `k` case :(
09:16:23 <Solonarv> yeah, because k is unknown and could turn out to be * -> * as well
09:16:34 <isovector1> yup! but the two cases are overlapping
09:16:42 <isovector1> so incoherence would be ok
09:18:47 <isovector1> so i'd like to reduce on `* -> *` and `forall k. k`, but get stuck for anything else
09:19:07 <isovector1> (with the same reduction in both casess)
09:21:26 <fen> is there any way to constrain the return type of a type family?
09:25:15 <monochrom> tb15: No, I have only played a bit.
09:25:27 <tb15> ah ok 
09:30:28 <isovector1> fen: what do you mean?
09:30:42 * odumichthys waves enthusiastically.
09:40:37 <fen> isovector1: well we can specify the kind of the type returned by a type family, but can we add a constraint?
10:52:57 <tsahyt> what's the preferred way to create XML files? I've tried xmlgen but its output has some very odd newline placement, I'd prefer something human readable
10:53:14 <tsahyt> I don't need to be able to parse XML, just generate it
11:07:18 <tsahyt> well who'd have thought, a library named "xml" does the trick.
11:23:47 * hackage haskell-src-exts-simple 1.21.0.0 - A simplified view on the haskell-src-exts AST  https://hackage.haskell.org/package/haskell-src-exts-simple-1.21.0.0 (BertramFelgenhauer)
11:35:43 <fen> if (a :: *) means that `a' is a any type of kind *, how can we write something that is a subset of kind * ?
11:36:22 <fen> "a has kind which is a subset of *"
11:36:35 <fen> or does that not make sense?
11:37:07 <merijn> fen: That doesn't make sense, no
11:37:23 <merijn> fen: At least, not in "standard" Haskell
11:37:59 <fen> but if it was a type we would just write a constraint, like polymorphic type `a' can be restricted to be a subset of all types which are instances of a class
11:38:27 <fen> so how is it then that there is no notion of a constrained kind?
11:38:53 <fen> if we can constrain a type, and types can be used as kinds, this would seem like it should be possible
11:39:59 <Eduard_Munteanu> Haskell doesn't really have subtypes.
11:40:11 <fen> subtypes?
11:40:11 <nshepperd_> You can make typeclasses on kinds
11:40:29 <Solonarv> the only kind (hah!) of subtyping is that of constraints
11:40:41 <fen> nshepperd_ right, classes should work at any level
11:40:59 <Solonarv> you can use this to encode other subtyping relationships, e.g. lens
11:41:14 <fen> or continuations
11:41:20 <fen> in general
11:41:57 <fen> (definatly what we dont have is a "class of encodings" whatever that would be!)
11:42:39 <Eduard_Munteanu> Can DataKinds lift constraints too now?
11:42:42 <nshepperd_> Typeclasses do work on any level
11:42:52 <fen> oh what did you mean then?
11:43:05 <nshepperd_> But type functions can't have constraints
11:43:59 <fen> Eduard_Munteanu: meaning we cant turn eg (a :: (f :: * -> *))  into (a :: Functor f => f) 
11:44:20 <nshepperd_> So the methods of a "kindclass" still need to be values
11:44:44 <fen> oh thats confusing
11:44:45 <Eduard_Munteanu> fen, well, constraints wouldn't be inhabited types.
11:45:02 <fen> inhabited kinds?
11:45:03 <Eduard_Munteanu> * -> * isn't either
11:45:13 <Eduard_Munteanu> Er, yeah.
11:45:32 <fen> ohh is that the problem, something about defunctionalising 
11:46:02 <fen> is that because of the undecidability of type level lambdas?
11:46:34 <Solonarv> probably somewhat related
11:46:51 <Eduard_Munteanu> Well, one way to look at it is that type functions should be total. We also don't have data declarations with constraints on parameters, for instance.
11:47:09 <fen> well, like if we *could* do type level lambdas, that would also solve the defunctionalisation issue, so we could pass around things other than of kind *
11:47:41 * Solonarv waves vaguely towards -XDependentHaskell
11:47:59 <fen> maybe thats the reason it doesnt exist yet!?
11:48:15 <Eduard_Munteanu> (Actually, what I meant above was that types in * -> * aren't inhabited, not that * -> * has no "values" aka types in it.)
11:48:32 <Eduard_Munteanu> -XAgda :P
11:48:48 <fen> so maybe the question is (since its clear now why we cant have constraints at type level, because we would need eg * -> * to be ... inhabited? or something)
11:49:00 <fen> would dependent haskell have kind level constraints?
11:49:22 <nshepperd_> Immediately jumping to jargon like "defunctionalising" before even clarifying what anyone's talking about...
11:50:16 <fen> well you cant pass around a partially applied type family (or type for that matter, which are like what newtypes are to datatypes - type sysnonyms are to type familes)
11:51:17 <fen> nshepperd_ yeah, not really undestanding the correct termanolagy, so defunctionalisation, the process of wrapping partially applied type synonyms or type families into datatypes to give them kind * so you can pass them around
11:51:19 <Solonarv> there's a GHC branch which lets you work with unsaturated type families in some circumstances
11:51:27 <Eduard_Munteanu> That should be doable, but Haskell already has stuff which would make typechecking undecidable.
11:51:30 <Solonarv> I don't know a ton about it but it was mentioned in #ghc a bit ago
11:51:51 <Solonarv> being able to pass things around (or not) has nothing to do with their kind
11:52:01 <fen> doable and me being able to use it in my project are different things
11:52:10 <Solonarv> you can pass around 'Either' jsut fine for example
11:52:15 <fen> oh
11:52:21 <fen> because its a datatype?
11:52:22 <Solonarv> even though its kind is Type->Type->Type
11:52:37 <Solonarv> you can also pass around 'Just :: a -> Maybe a
11:53:10 <fen> so your calling things which have to be defunctionalised before you can pass them round "unsaturated type familes"
11:53:21 <Solonarv> no
11:53:28 <fen> *sigh*
11:54:01 <Solonarv> "unsaturated type families" are types which consist of a type family applied to some number of arguments which is less than the number of arguments in its declaration
11:54:12 <fen> should i just keep using shotgun terminology to attempt to express this or are you going to tell me what its called?
11:54:21 <Solonarv> what *what* is called?
11:54:44 <fen> something you cant pass around because its not got all its type parameters applied to it yet
11:54:59 <Solonarv> ah
11:55:08 <Solonarv> I'm not aware of a name for that, actually
11:55:47 <Solonarv> it's worth noting that there isn't a fundamental limitation here
11:55:51 <fen> "unsaturated types / type familes"
11:55:58 <Solonarv> yeah, that works
11:56:29 <fen> but then if types are just like type families, just as newtypes are like datatypes, then "unsaturated type families" should cover the case of types
11:56:44 <nshepperd_> "unsaturated type whatevers" isn't the name for that property
11:56:45 <Solonarv> you just need to somehow distinguish between unsaturated type families and partially applied type/data/class constructors if you don't want to lose type inference
11:56:57 <Solonarv> yeah, it's not "unsaturated type whatevers"
11:56:58 <nshepperd_> Unsaturated type families are unsaturated type families
11:57:05 <Solonarv> it's specifically "unsaturated type families/synonyms"
11:57:18 <nshepperd_> The fact that you can't pass them around is a contingent fact about ghc
11:57:21 <fen> nsepperd_ your not convinced that type familes are the only things?
11:57:57 <Eduard_Munteanu> Type families are actually type *synonym* families... you can't partially apply type synonyms either.
11:58:41 <fen> so what about this "its an artefact of ghc, not a property of the universe" thing
11:59:25 <fen> "there is no fundamental limitation" 
11:59:28 <fen> whats that mean?
11:59:41 <fen> well, its clear what it means.
12:00:00 <fen> im not sure whats not clear actually
12:00:05 <fen> and now we have a good name for it
12:00:20 <fen> "unsaturated type whatevers" isn't the name for that property
12:00:22 <fen> why not?
12:00:58 <Solonarv> because 'Either String' is also an "unsaturated type whatever" and yet you can pass it around and write instances for it just fine
12:01:22 <fen> no, thats an unsaturated datatype
12:01:26 <fen> ?
12:01:43 <Solonarv> I would think a "datatype" is also a "type whatever"
12:01:46 <Solonarv> the property you're looking for is "matchability"
12:01:48 <fen> haha
12:02:03 <fen> ok, if thats the only issue then "unsaturated type families/synonyms" seems ok
12:02:14 <fen> ok, so whats matchability?
12:02:24 <fen> thats what allows the typechecker to do its thing?
12:02:32 <fen> makes stuff decidable etc
12:02:36 <Solonarv> basically instead of having one function arrow -> we have two
12:02:53 <nshepperd_> fen: your comment was weird because it's like you said "so you're calling animals that live in this field sheep"
12:02:55 <Solonarv> I'll use '-> for the matchable function arrow
12:03:31 <nshepperd_> Sure, sheep might be living in the field right now, but they're not synonymous. And the definition of a sheep has nothing to do with the field
12:03:31 <fen> nshepperd_ thats only an issue if there isnt a name for them already. 
12:03:51 <Solonarv> matchability means that when we have f, g :: k1 '-> k2 and x, y :: k1, then we can take apart the equality constraint (f x ~ g y) into (f ~ g, x ~ y)
12:04:13 <fen> or unless "unsaturated" already has an established meaning in a haskell context
12:05:04 <fen> Solonarv: that sounds like some of the writing on injective type families
12:05:06 <Solonarv> for example the fact that Maybe is matchable lets you take apart (Maybe a ~ m String) into (m ~ Maybe, a ~ String) and infer the type
12:05:34 <Solonarv> yes, matchability is a stronger form of injectivity
12:05:53 <nshepperd_> Yes, the meaning of unsaturated is that not all the arguments have been applied
12:05:54 <Solonarv> injectivity lets you take apart (f x ~ f y) into (x ~ y)
12:06:19 <Solonarv> but note that we need to already know that we have the same function on both sides to use injectivity
12:06:46 <fen> nshepperd_ thats exactly what we wanted it to mean, perfect! so with the qualification "type families/synonyms" we have a good name
12:07:23 <fen> Solonarv: would that be solved with KindApplications?
12:07:26 <nshepperd_> fen: no, you wanted it to mean "types that you can't pass around"
12:08:08 <fen> oh, well the only reason they wouldnt mean the same thing is if there are other types we cant pass around other than "unsaturated type families/synonyms"
12:08:32 <nshepperd_> (matchability could be said to be when the juxtaposition / application operator itself is injective)
12:08:34 <fen> your not convinced the classification exhausts all possibilities 
12:09:00 <Solonarv> it does currently
12:09:08 <fen> ah ok
12:09:39 <Solonarv> once kcsongor's unsatured type families branch is done/merged there won't be an types you can't at least pass around
12:09:45 <fen> is there a proof that there is nothing else that it could be?
12:10:06 <Solonarv> well it's very easy to check since there aren't that many ways to create a type in haskell
12:10:11 <Solonarv> you just look at all of them
12:10:30 <fen> well it was assuming there could be something new
12:11:23 <fen> wait, so this new patch will make "unsaturated type families/synonyms" into something you *can* pass around, without making them matchable?
12:11:50 <Solonarv> yes
12:11:57 <fen> then the problem has to be matchability
12:12:09 <fen> since the original thing was about kind constraints
12:12:47 <fen> and the "but you cant even pass type families/synonyms around unless they have kind *" objection becomes secondary 
12:13:29 <fen> so matchability must be the common issue between type level lambdas and undecidability
12:13:56 <Solonarv> constrained kinds make sense in principle, I think - we just don't have them because they only make sense with something that's at least very close to dependent haskell
12:13:58 <fen> basically, I thought that solving matchability would be the solution to defunctionalsiation 
12:14:24 <Solonarv> it is actually, I think
12:14:49 <fen> Solonarv: well not having any idea what dependant haskell consists of, what specific considerations pertain to constrained kinds?
12:15:08 <Solonarv> once you can talk about matchability you can say "just give me anything :: Type -> Type, I don't need it to be matchable" 
12:15:28 <Solonarv> fen: just consider the dictionary-passing translation
12:15:38 <Solonarv> it's a pretty good way to think about how constraints work
12:15:51 <fen> but that would also need pattern matching?
12:15:52 <Solonarv> the only difference between => and -> is that GHC automatically inserts arguments for =>
12:16:44 <Solonarv> I think you might actually be interested in reading richard eisenberg's thesis
12:16:53 <Solonarv> it's where he outlines the plan for dependent haskell
12:17:06 <Solonarv> I don't have a link for you but it should be fairly easy to google
12:17:08 <fen> well what else havent we covered?
12:17:20 <emacstheviking> does anybody have experience with Data.Configurator package please? I am struggling to figure out how to get string values out of the loaded file, I get Nothing all the time! I don't understand how it works regarding Name/Text/Value/Configured relationships :(a
12:17:52 <Solonarv> can't think of anything we haven't covered at all here, but the thesis does a better job explaining it than I can
12:18:00 <fen> fair
12:18:15 <Solonarv> emacstheviking: I've never used that library, but stick around for a while - someone else might be able to help you
12:18:34 <Solonarv> also consider posting your code via e.g. https://gist.github.com
12:18:44 <emacstheviking> still reading the docs...it's a great library so far but I can't get strings back! LMAO
12:23:32 <emacstheviking> https://gist.github.com/emacstheviking/d018612d3e51c74dc52c698817611a30
12:25:13 <emacstheviking> I am failing to understand how the "Converter" process works. I can see I need to be talking "Text" not "String" ?!?!?!
12:46:47 * hackage ats-pkg 3.2.5.13 - A build tool for ATS  https://hackage.haskell.org/package/ats-pkg-3.2.5.13 (vmchale)
13:31:48 <d34df00d> Hi!
13:32:14 <Solonarv> d34df00d: hello!
13:33:26 <d34df00d> I'm playing around with some algorithms and data structures (and, in particular, benchmarking them). So there are a few different modules with different heap representations, and each of them has a function like this:
13:33:30 <d34df00d> https://bpaste.net/show/98fe6369aa86
13:34:23 <d34df00d> I refactored my code slightly so that now there's a Heap typeclass with methods like 'singleton', 'merge' and so on. Since this function only uses the methods exposed via the typeclass, I moved it to the module defining the typeclass.
13:34:55 <d34df00d> And as a result, I noticed the performance drop of about 10-15%.
13:35:11 <d34df00d> What could be the cause for that?
13:35:27 <Solonarv> hmm
13:35:42 <Solonarv> how are you compiling your code, and how are you measuring performance?
13:36:16 <d34df00d> I guess that ghc doesn't specialize as well as "manual" specialization does (by copying the implementation around and not relying to be polymorphic on the Heap type), but I don't know how to prove that and, more importantly, how to mitigate that.
13:36:28 <d34df00d> Solonarv: `stack build`/`stack bench`, whatever the defaults are there.
13:36:33 <d34df00d> Solonarv: benchmarking is done via criterion.
13:37:20 <Solonarv> hmm, I think stack passes -O1 by default
13:37:39 <d34df00d> So I have a benchmark group with entries like 'bench "LH.fromList"  $ nf (fromList @LH.Tree) lst', and so on for other types via -XTypeApplications
13:38:55 <Solonarv> could try compiling with -O2 and see if there's still a gap there
13:39:18 <Solonarv> I'm not confident making further suggestions without seeing your code
13:39:22 <d34df00d> BTW what's the best way to compile with -O2 with stack so that I still get reasonable --fast builds?
13:39:30 * ski idly wonders how many instances of `Heap' there is declared
13:39:38 <d34df00d> ski: three right now.
13:40:15 <Solonarv> I think --fast should override whatever optimization level you set in ghc-options
13:40:17 <d34df00d> I'm just going along with Okasaki, so that's leftist heaps, weight-balanced leftist heaps and binomial trees for now.
13:40:48 <d34df00d> Solonarv: thanks, I'll give it a try!
13:41:03 <ski> (and is the performance drop between the original, unrefactored code, and the one with this function in the same module as the type class ? or between the refactored code, and the one with this function in the same module as the type class ?)
13:42:03 <d34df00d> ski: the first one — the unrefactored with lots of dup logic between modules, and with the refactored, where 'fromList' relies on the class.
13:42:38 <ski> and with `fromList' is the module of the class, or not ?
13:42:47 * hackage port-utils 0.2.1.0 - Utilities for creating and waiting on ports  https://hackage.haskell.org/package/port-utils-0.2.1.0 (JonathanFischoff)
13:42:54 <d34df00d> Yep, fromList is in the module with the class.
13:43:00 <d34df00d> (After the refactoring)
13:43:50 <ski> using a type class, rather than directly call the relevant function (if possible), would be less efficient, in the general case at least
13:44:04 <ski> so perhaps that's the (main ?) cause
13:44:16 <Solonarv> GHC is usually pretty good at eliminating this overhead, though
13:44:30 <d34df00d> ski: but, since the compiler kinda knows statically what's the instance at the call site, isn't it eager to specialize?
13:44:32 <ski> yes, it tried to specialize when it can
13:44:36 <ski> (even cross-module ?)
13:44:52 <ski> i suppose you could try to determine whether moving `fromList' did anything at all, performance-wise
13:45:29 <ski> d34df00d : it can't always know statically, because of the possibility of polymorphic recursion, or of existentials
13:45:41 <d34df00d> Well, sure, I mean in this particular case.
13:45:49 <d34df00d> Solonarv: nah, -O2 didn't make a difference.
13:45:54 <Solonarv> in this case it should definitely be able to eliminate the indirection
13:46:05 <Solonarv> d34df00d: hm, could you perhaps provide the full code then?
13:46:43 <d34df00d> Uh, that's a big big project. Shall I try to minimize it somehow?
13:47:05 <d34df00d> I mean, big for asking someone on IRC to casually look at it :)
13:47:43 <Solonarv> I'm fine with you just tossing a link to a github repo or something
13:48:07 <d34df00d> Ok, I'll create a repo with the relevant parts.
13:58:46 <d34df00d> Hmm, interesting.
13:59:02 <Solonarv> hm?
13:59:07 <d34df00d> I've put SPECIALIZE pragma into the module with the benchmarks, like {-# SPECIALIZE fromList :: Ord a => [a] -> LH.Tree a #-}
13:59:43 <d34df00d> ghc complains that I cannot SPECIALISE this function (and that the corresponding rewrite rule is orphaned), yet the performance increase is noticeable.
14:00:04 <d34df00d> And it's giving me back roughly those 10% of time.
14:01:10 <d34df00d> Solonarv: anyway, here's the code: https://github.com/0xd34df00d/pfds-heaps
14:01:14 <d34df00d> Thanks for taking a look!
14:06:47 * hackage tmp-postgres 0.1.2.0 - Start and stop a temporary postgres for testing  https://hackage.haskell.org/package/tmp-postgres-0.1.2.0 (JonathanFischoff)
14:10:13 <Solonarv> d34df00d: I think a good solution here would be to:
14:10:14 <Solonarv>  - add a {-# INLINABLE fromList #-} pragma in Heap.Class
14:10:14 <Solonarv>  - add {-# SPECIALIZE #-} pragmas in each of {Binomial,LeftistHeap,WBLH}.hs
14:10:58 <d34df00d> Thanks!
14:11:16 <d34df00d> All this is still a bit of black magic to me even after reading, say, https://www.stackbuilders.com/tutorials/haskell/ghc-optimization-and-fusion/
14:12:49 <iqubic> Does someone have a simple cabal file that states that my project is a library, and not an executable?
14:13:39 <Solonarv> iqubic: just put a 'library' stanza in there, and don't put in any 'executable foo' stanzas
14:13:48 <iqubic> I see.
14:14:16 <Solonarv> you can also use `cabal init` to generate a starter .cabal file, if you haven't created one yet
14:14:53 <Solonarv> it asks you a bunch of questions and then writes out a .cabal file based on your answers; one of the questions is "is your project a library, executable, or both?"
14:15:19 <d34df00d> Solonarv: also, looks like merely declaring fromList (and dumbFromList for that matter) as INLINEABLE improves the performance, while putting SPECIALIZE either to the modules defining the types or to the benchmarking module doesn't noticeably affect anything.
14:15:45 <Solonarv> ah, seems we found the culprit
14:15:57 <d34df00d> So, bottom line, does ghc think that fromList is a too complex function, optimizing it immediately and leaving no chance to specialize later?
14:16:18 <d34df00d> Also explains why dumbFromList doesn't suffer — it's way more simple.
14:16:32 <Solonarv> what {-# INLINABLE #-} does is make sure that the function's implementation is visible when compiling other modules
14:17:23 <Solonarv> this in turn allows GHC to see "oh, you're using this function with the LH.Tree type" when compiling the benchmark, and decide to specialize it
14:18:18 <d34df00d> Yeah, that makes sense.
14:18:21 <clever> Solonarv: i also use -Weverything when developing code, and it constantly warns me about things it cant specialize, because it was built without unlineable
14:18:35 <Solonarv> clever: oh, that seems useful
14:18:46 <d34df00d> Those exercises are good, not just to learn algorithms, but also to learn writing and debugging performance.
14:18:49 <clever> Solonarv: anoyingly, -Wall doesnt turn on all warnings!
14:19:01 <Solonarv> yeah 
14:19:42 <Solonarv> d34df00d: I did a bit of that on advent of code last year
14:20:00 <Solonarv> gave up only a few days in because I had some issue with profiling
14:21:21 <d34df00d> Haven't heard about that one! Looks like there are no events planned right now though, right?
14:24:32 <Solonarv> well, as the name suggests advent of code happens every December during advent :>
14:25:03 <Solonarv> previous years' puzzles are still available though, so you could go solve them even now
14:28:41 <d34df00d> Hah, I didn't know "advent" a name for this period in English!
14:28:50 <d34df00d> Yeah, previous years would make a good practice.
14:29:13 <iqubic> Which number like class provides `mod` and `div`?
14:29:30 <iqubic> Also, does haskell have an infix `%` operator?
14:29:53 <Solonarv> iqubic: mod, div, quot, rem are part of the Integral class
14:30:16 <Solonarv> there is an infix % operator but it's used for constructing rational numbers, not for the modulo operation
14:30:37 <Solonarv> however you can use e.g. mod infix, like so:
14:30:37 <Solonarv> > 13 `mod` 4
14:30:39 <lambdabot>  1
14:31:39 <Solonarv> and there are sensible fixity definitions for these functions, so they interact like you would expect with the other arithmetic operators
14:32:09 <iqubic> Why do I need to define an instance of Enum, and an instnace of Real in order to be able to define an instnace of Integral?
14:33:26 <iqubic> What even does the `instance Enum Int` look like?
14:34:51 <d34df00d> Well, there's one, so you could check it out: `instance Enum Int -- Defined in ‘GHC.Enum’`
14:35:16 <Solonarv> has a bunch of low-level stuff going on with it IIRC
14:35:42 <d34df00d> http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Enum.html
14:35:53 <d34df00d> Sadly, no generated docs.
14:36:02 <d34df00d> So you'll have to Ctrl+F (or grep) for Int.
14:36:33 <Cale> iqubic: There are still some questionable superclass constraints in the Prelude numeric classes.
14:36:46 <iqubic> Why are these things needed in order to define division and modulo on my custom number type?
14:36:50 <bjs> Enum for Integer is probably simpler
14:36:58 <Cale> iqubic: for Real, you have to define toRational, for Enum, you have to define toEnum/fromEnum
14:37:20 <Cale> iqubic: Because of the superclass constraints on the Integral class
14:37:33 <iqubic> Why does that superclass constraint exist?
14:37:38 <bjs> iqubic: because if I give you something of type `Integral a => a`    what can you do with it? 
14:37:42 <Cale> No particularly good reason.
14:37:57 <bjs> the numeric hierarchy in Haskell is weird though
14:38:03 <Cale> But removing them now is a pain. Maybe it'll happen at some point.
14:38:05 <bjs> you have to "get used to it" ;)
14:38:16 <Cale> Less likely changes have happened to the Prelude in recent years.
14:38:36 <iqubic> Cale: Like what?
14:38:49 <Solonarv> most recently, the MonadFail proposal
14:38:51 <iqubic> This confuses me to no end.
14:38:52 <iqubic> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Enum.html#line-464
14:39:11 <Solonarv> you know the 'fail :: String -> m a' method in the Monad typeclass?
14:39:14 <Cale> iqubic: What's your numerical type?
14:39:18 <Solonarv> deprecated in 8.6, gone in 8.8
14:39:33 <iqubic> Cale: It's a new type wrapper around integers.
14:40:00 <Cale> iqubic: Would it make sense just to derive Integral and use GeneralisedNewtypeDeriving ?
14:40:02 <Solonarv> ah-ha! then you can just turn on GeneralizedNewtypeDeriving and tell GHC to re-use the instance(s) from Integer
14:40:24 <iqubic> I can, and should do that.
14:40:50 <Cale> Otherwise, you could just implement the instances by unwrapping/rewrapping the newtype anyway
14:40:55 <iqubic> What's the difference between Int and Integer?
14:41:01 <bjs> iqubic: Int is bounded
14:41:06 <Cale> Int is machine-word sized
14:41:13 <bjs> hence why Int's Enum is a bit more complex
14:41:16 <Solonarv> Int has a finite range (usually between 31 and 64 bits), Integer is unbounded
14:41:21 <iqubic> Cool.
14:41:58 <Solonarv> as of somewhat recently there is also Natural which is unbounded and non-negative
14:42:11 <iqubic> Why is that useful?
14:42:23 <iqubic> Also, how do you construct a Natural
14:42:23 <zachk> is fromIntegral slow? 
14:42:46 <Solonarv> well, sometimes you don't want to allow negative values, so sure
14:42:59 <Solonarv> zachk: it can be slow if things fail to specialize, IIRC
14:43:08 <Solonarv> (similarly for realToFrac)
14:43:10 <zachk> specialize? 
14:43:13 <iqubic> Question: Are there any performance differences between Int and Integer?
14:43:23 <Solonarv> iqubic: yes, Int is faster
14:43:26 <zachk> like if its too general/polymorphic 
14:43:28 <Solonarv> and takes lessmemory
14:43:29 <zachk> ?
14:43:31 <Solonarv> zachk: precisely
14:43:52 <Cale> Int is faster, but not so much faster that you should avoid using Integer
14:44:09 <Cale> I actually consider its inclusion in the Prelude mildly questionable.
14:44:14 <d34df00d> Does ghc vectorize?
14:44:17 <d34df00d> Say, with the llvm backend.
14:44:53 <Solonarv> I don't think it usually does but there is some support for it in the internals IIRC
14:44:53 <iqubic> So which one should I use?
14:45:35 <d34df00d> So I believe Ints are a bit easier to vectorize.
14:45:39 <d34df00d> For instance.
14:45:45 <d34df00d> But I probably care too much about numeric-heavy code.
14:45:46 <Cale> iqubic: With Integer, you don't have to worry about overflow. If your inputs are untrusted though, you do have to cope with the fact that Integer values can take arbitrary amounts of space.
14:45:50 <Solonarv> iqubic: if you run into performance issues, use Int (or Int32/Int64 if you need to be sure you get a specific size); if you expect to be working with numbers too large to fit into an Int, use Integer; if neither is the case it doesn't matter
14:46:14 <d34df00d> Also I prefer Int, all else being equal, as it's shorter to type.
14:46:14 <iqubic> I'm going to be working with small numbers, actually.
14:46:32 <Solonarv> if they're small numbers there's really no reason not to use Int
14:47:14 <iqubic> When I say small I mean between -(2^10) and +(2^10)
14:47:31 <iqubic> +-1024
14:47:59 <Solonarv> yes, by "small" I meant "definitely fits into the range of Int"
14:48:12 <iqubic> And by small I meant what I just said.
14:49:01 <Solonarv> which is always at least [-2^29 .. 2^29-1] and probably just the full 64 bits on a typical 64bit system
14:49:06 <Cale> d34df00d: Usually the amount of time spent typing your program is going to be way less than the amount of time spent thinking about it anyway
14:49:08 <Solonarv> % maxBound :: Int
14:49:08 <yahb> Solonarv: 9223372036854775807
14:49:20 <iqubic> So why is Enum a superclass of Integral?
14:49:25 <Solonarv> ^- full 64-bit in yahb, for example
14:49:55 <iqubic> Also, is there a chart anywhere that lists the Haskell heirarcy of numeric classes?
14:50:05 <Cale> iqubic: There isn't a good reason for it to be.
14:50:15 <d34df00d> Just use subhask.
14:50:28 <iqubic> What is subhask?
14:50:55 <d34df00d> Sort of alternative hierarchy for a bunch of stuff.
14:51:00 <d34df00d> With good algebraic reasons underneath.
14:51:00 <Cale> Oh, it's a weird alternative prelude.
14:51:02 <d34df00d> https://github.com/mikeizbicki/subhask
14:51:06 <d34df00d> Or weird, yes.
14:51:27 <Cale> Any alternative Prelude is of limited usefulness just because everything depends on the existing one.
14:58:15 <AWizzArd> Is „morphism” just another word for „function”?
15:01:18 <iqubic> So where's that chart with all the numeric type classes and their superclasses and subclasses shown?
15:03:18 <Cale> https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1270011 -- there's an old diagram here, it's no longer 100% accurate, since Functor is now a superclass of Monad, and Applicative is in between them
15:03:38 <Cale> You're better off just looking at the haddock documentation for base
15:04:50 <Cale> http://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html
15:05:21 <Cale> Oh yeah, also Eq and Show were removed as superclasses of Num
15:05:37 <Cale> which was a good change
15:08:59 <zachk> what good are numbers without equality or ordering? 
15:09:44 <Cale> Well, ordering, think about complex numbers
15:10:21 <zachk> yea that came to mind after I said it :) but what about equality at least?
15:10:28 <Cale> Eq often isn't computable for things like the computable reals or other numbers that are expressed by way of functions.
15:11:10 <zachk> so I guess the computable reals aren't that computable! 
15:11:27 <Cale> (Checking if two computable reals are equal is equivalent to solving the halting problem
15:11:28 <Cale> )
15:11:58 <zachk> so for some cases you can prove they are equal?
15:12:17 * hackage cpkg 0.1.3.0 - Build tool for C  https://hackage.haskell.org/package/cpkg-0.1.3.0 (vmchale)
15:12:26 <Cale> You can prove it externally
15:12:48 <Cale> (If you can see how they were defined)
15:13:14 <ddellacosta> I cannot for the life of me figure out which section of the cabal documentation includes the reference the cabal file's "test" section, would clue me in please? I tried using the search as well and am still stumped: https://cabal.readthedocs.io/en/latest/index.html
15:13:16 <zachk> kinda like proving function equality?
15:13:18 <Cale> yeah
15:13:21 <ddellacosta> the reference for*
15:13:31 <ddellacosta> argh would someone* clue me in please
15:14:27 <royal_screwup21> could someone explain to me the definition for Fix f?? `data Fix f = In (f (Fix f) )
15:14:33 <Cale> https://cabal.readthedocs.io/en/latest/developing-packages.html#test-suites
15:14:40 <royal_screwup21> like how does it even work 
15:14:51 <royal_screwup21> I can't quite think of the oop equivalent 
15:14:58 <ddellacosta> Cale: thank you
15:15:11 <Cale> royal_screwup21: Probably because you've never seen anything like that before
15:15:14 <d34df00d> You can always decide that two unequal computable reals are, well, unequal.
15:15:35 <Cale> royal_screwup21: Most OOP languages don't let you abstract over types of kind * -> *
15:15:35 <d34df00d> But deciding if two (in fact, equal) reals are equal allows solving the halting problem, yes.
15:15:47 * hackage cpkg 0.1.3.1 - Build tool for C  https://hackage.haskell.org/package/cpkg-0.1.3.1 (vmchale)
15:17:05 <royal_screwup21> Cale so Fix is parameterized on f...I don't really understand the stuff inside In
15:17:16 <Cale> royal_screwup21: Read this just like any other data type you've seen defined in Haskell: a value of type Fix f consists of the constructor 'In' applied to an argument of type f (Fix f)
15:17:38 <Cale> So we have   In :: f (Fix f) -> Fix f
15:17:50 <Cale> and correspondingly, we can define:
15:17:56 <Cale> out :: Fix f -> f (Fix f)
15:17:59 <Cale> out (In x) = x
15:18:04 <ski> (`Fix f' is basically `f (f (f (f (...))))')
15:18:31 <Cale> Yeah, often you want this to be a newtype rather than data, but the difference between the two is quite subtle.
15:19:17 <royal_screwup21> Cale hmm...I don't quite understand how f can be parametrized on (Fix f). Like how do we know if it even has a type parameter at all
15:19:24 <Cale> (Using a newtype will mean that the In constructors don't take up space at runtime, and changes the semantics of pattern matching a bit)
15:19:41 <Cale> royal_screwup21: It must, because we're applying it to a type
15:19:47 * hackage tmp-postgres 0.1.2.1 - Start and stop a temporary postgres for testing  https://hackage.haskell.org/package/tmp-postgres-0.1.2.1 (JonathanFischoff)
15:20:11 <Cale> royal_screwup21: We know that Fix f :: *  because we're writing a data declaration for it, defining its values
15:20:50 <Cale> and we know that f (Fix f) :: * because it's supposed to be the type of the argument to In (so it must be some type of values)
15:20:59 <Cale> So we must conclude that  f :: * -> *
15:21:18 <Lears> % :k Fix
15:21:18 <yahb> Lears: Fix :: (* -> *) -> *
15:21:49 <Cale> and yeah, then Fix, having f as its parameter, has the kind shown by yahb above
15:21:58 <royal_screwup21> oh dear...:( I'm not quite seeing it, will have to reread the explanation...as I see it, there's no way Fix can paramterized on Int then
15:22:17 <Cale> royal_screwup21: Fix can't be applied to Int, indeed.
15:22:29 <Cale> royal_screwup21: Let's consider something which *does* kind-check
15:22:34 <Cale> :k Maybe
15:22:35 <lambdabot> * -> *
15:22:40 <Cale> :k Fix Maybe
15:22:41 <lambdabot> error:
15:22:41 <lambdabot>     Not in scope: type constructor or class ‘Fix’
15:22:43 <Cale> oh
15:22:57 <Cale> @let newtype Fix f = In { out :: f (Fix f) }
15:22:57 <lambdabot>  .L.hs:173:30: error:
15:22:58 <lambdabot>      Ambiguous occurrence ‘out’
15:22:58 <lambdabot>      It could refer to either ‘Lambdabot.Plugin.Haskell.Eval.Trusted.out’,
15:23:04 <Cale> lol, fine
15:23:13 <Cale> @let newtype Fix f = In (f (Fix f))
15:23:14 <lambdabot>  Defined.
15:23:21 <Cale> :k Fix Maybe
15:23:22 <lambdabot> *
15:24:02 <Cale> @let deriving instance Show (f (Fix f)) => Show (Fix f)
15:24:03 <lambdabot>  Defined.
15:24:06 <royal_screwup21> Cale ok...so it can be paramterized only on datatypes that take parameter...
15:24:08 <Cale> > In (Just (In (Just (In Nothing))))
15:24:09 <lambdabot>  error:
15:24:10 <lambdabot>      Ambiguous occurrence ‘In’
15:24:10 <lambdabot>      It could refer to either ‘Lambdabot.Plugin.Haskell.Eval.Trusted.In’,
15:24:16 <Cale> what...
15:24:18 <royal_screwup21> one parameter*
15:24:19 <Cale> dang
15:24:28 <Cale> @undefine
15:24:28 <lambdabot> Undefined.
15:24:47 * hackage tmp-postgres 0.1.2.2 - Start and stop a temporary postgres for testing  https://hackage.haskell.org/package/tmp-postgres-0.1.2.2 (JonathanFischoff)
15:25:00 <Cale> royal_screwup21: "can be parametrised on" is the wrong terminology in one way or another
15:25:10 <Cale> It *is* parametrised on a choice of type of kind * -> *
15:25:31 <Cale> As such, it can only take arguments of kind * -> *
15:25:31 <ddellacosta> can anyone suggest where I can find good examples of how to set up an hspec test suite with cabal (not using stack)? The example in the docs is too simple unfortunately
15:26:24 <Cale> If you have f x = x^2 or something
15:26:28 <Cale> x is called a parameter
15:26:43 <Cale> and when you write f 5, then 5 is an argument to f
15:26:46 <Cale> (not a parameter)
15:27:06 <Cale> So in  newtype Fix f = In (f (Fix f)), the type parameter is f
15:27:08 <ski> royal_screwup21 : yes, `Fix' is a higher-order type. just like `onLines :: ([String] -> [String]) -> String -> String; onLines f = unlines . f . lines' is a higher-order function
15:27:25 <Cale> But if we tried to write  Fix Int, then Int would be (an attempt at) an argument, not a parameter.
15:27:51 <ski> (sometimes `x' would be called "the formal parameter", and `5' there "an actual parameter")
15:28:11 <royal_screwup21> ah I see...
15:29:16 <ski> since `Fix f' is basically `f (f (f (f (...))))', then `Fix Int' would be basically `Int (Int (Int (Int (...))))', which doesn't make any sense. `Int' is not a type that accepts a parameter. it is not an "incomplete type", aka a "generic type"
15:29:54 <ski> however, with `f' being `Maybe', then `Fix Maybe' comes basically `Maybe (Maybe (Maybe (Maybe (...))))', which does make more sense ..
15:30:19 <Cale> Fix Maybe is roughly equivalent to Nat
15:30:27 <Cale> where  data Nat = Zero | Succ Nat
15:31:00 <ski> the one thing that seems weird / fishy, is that `Maybe (Maybe (Maybe (Maybe (...))))' is some kind of "infinite type", or perhaps better thought of as a "cyclic type" (if we call this whole type `T', then clearly `T' is the same as `Maybe T')
15:32:24 <ski> (compare with in `ones = 1 : ones', we can think of this as defining an infinite list `ones', all of the elements of being `1'. but, in terms of representation in memory, we can think of it as a list being represented with only one "cons cell", containing the element `1', and a "tail list" component that refers back to ("points to") the same whole cons cell)
15:33:13 <ski> anyway, the values of `Maybe (Maybe (Maybe (Maybe (...))))' clearly are like `Nothing',`Just Nothing',`Just (Just Nothing)',`Just (Just (Just Nothing))',&c.
15:34:16 <royal_screwup21> hmm I think I'm seeing it, thanks for the explanation folks 
15:34:21 <ski> .. however, in Haskell, such infinite types are not acually allowed (for practical reason. it's not hard to allow them in the type system .. but it turns out that doing so would turn many genuine type-related mistakes, from being type errors, into being accepted by the type system, but with having really weird types inferred)
15:34:49 <ski> iow, we can't say `type T = Maybe T', we can't construct a recursive/cyclic type *synonym*
15:35:20 <ski> (that is sometimes called an "equi-recursive type")
15:35:31 <ski> however, we can do the next best thing, make a recursive `data' type (or `newtype')
15:35:53 <Solonarv> thus introducing an extra "wrapper" for each level of nestin
15:36:08 <ski> so, with `newtype Fix f = In (f (Fix f))', `Fix f' is no longer the same type as `f (Fix f)' .. but they're "isomorphic", contain the same information
15:36:12 <Solonarv> (and if we use 'newtype' then this wrapper doesn't exist at runtime)
15:37:40 <ski> and, as Solonarv noted, this means that rather than the values being like `Nothing',`Just Nothing',`Just (Just Nothing)',`Just (Just (Just Nothing))',&c., we'd now have to write them as `In Nothing',`In (Just (In Nothing))',`In (Just (In (Just (In Nothing))))',`In (Just (In (Just (In (Just (In Nothing))))))',&c.
15:38:31 <ski> (btw, this kind of recursive type would sometimes be called "iso-recursive", to contrast with the equi-recursive type)
15:39:12 <ski> and, as you can notice, either of these sequences corresponds closely to the sequence `Zero',`Succ Zero',`Succ (Succ Zero)',`Succ (Succ (Succ Zero))',&c.
15:39:52 <ski> in the `Nat' type that Cale mentioned. we'd say that this `Nat' type is isomorphic to (expresses the same kind of information) `Fix Maybe'
15:43:04 <ski> btw, you should note that we can define `infinity = Succ infinity', so that `infinity  =  Succ infinity  =  Succ (Succ infinity)  =  Succ (Succ (Succ infinity))  =  ...  =  Succ (Succ (Succ (Succ (...))))', is another value we can construct in Haskell, in the type `Nat' (even though it doesn't correspond to our usual idea of natural numbers)
15:43:33 <ski> (or even define it as `infinity = fix Succ', if we have defined `fix f = x where x = f x'. note that `fix f  =  f (fix f)  =  f (f (fix f))  =  f (f (f (fix f)))  =  ...  =  f (f (f (f (...))))' .. this `fix' is a value-level analogue of what `Fix' is doing on the type-level)
15:45:44 <ski> you can imagine for yourself how this `infinity' could be thought of in the simplistic `type T = Maybe T', giving `T  =  Maybe T  =  Maybe (Maybe T)  =  Maybe (Maybe (Maybe T)  =  ...  =  Maybe (Maybe (Maybe (Maybe (...))))' representation mentioned above
15:46:22 <ski> or in the actually allowed `newtype T = MkT (Maybe T)' (or `type T = Fix Maybe', say) representation
15:46:35 <ski> royal_screwup21 ^
15:47:38 <royal_screwup21> It'll me a while to grok this all haha, but thanks so much for the explanation :)  
15:50:01 <ski> please ask if you have any questions
15:52:24 <Cale> royal_screwup21: Where'd you encounter it, by the way? This *particular* example isn't very often important in real-world code (since the extra noise of having to write In repeatedly usually isn't worth the value gained by the abstraction), but it's a part of some interesting theoretical work.
15:52:26 <ski> > let ones = fix (1 :) in ones
15:52:28 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:54:10 <Cale> :t In
15:54:11 <lambdabot> f (Mu f) -> Mu f
15:54:17 <Cale> ahh, Mu :)
15:54:43 <Cale> (Mu is the same thing as Fix, it was in scope before while I was trying to define it to show you some stuff)
15:54:46 <Cale> :t cata
15:54:47 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
15:54:51 <Cale> ah, and we already have that
15:56:25 <Cale> This cata function is a very general way of expressing the idea that we often want a way to substitute the data constructors of a recursive data type with other values. If you're willing to make the recursion explicit, then it can be done generically.
15:56:46 <Cale> You might try figuring out how to write a function of that type for yourself :)
16:01:19 <ski> `cata' is related to the `foldr' function for lists
16:17:25 <zachk> is the sum function in the prelude inefficient over large lists? 
16:18:45 <Solonarv> it's probably fine in recent GHCs if you compile with optimizations
16:18:46 <Cale> It's defined in terms of foldl, so make sure you're compiling with optimisations and it should be fine
16:19:11 <Solonarv> if you want to be sure, define and use sum' = foldl' (+) 0 instead
16:19:16 <Cale> Where "recent GHCs" means "anything in the last decade" :)
16:19:54 <Solonarv> really? I thought the strictness analyzer improvement was a lot more recent than that
16:20:18 <Cale> The strictness analyser has been good enough for the case of sum for a long time.
16:20:53 <Solonarv> that's good to hear
16:21:30 <Solonarv> I thought there was a more recent improvement that let GHC sometimes figure out that a use of foldl is strict, and make it equivalent to foldl'
16:32:47 * hackage hmatrix-vector-sized 0.1.1.3 - Conversions between hmatrix and vector-sized types  https://hackage.haskell.org/package/hmatrix-vector-sized-0.1.1.3 (jle)
16:44:42 <zachk> so if I have a giant list I will get better performance with a lazy foldr summing the list instead of a strict foldl'? thinking becuase foldr doesnt need to construct the whole list in memory?
16:45:34 <zachk> if the list is generate via [0..n] .
16:48:18 <Solonarv> if you're summing up elements you want foldl'
16:48:32 <Solonarv> foldr is only as lazy as the function you give it
16:48:40 <Solonarv> and (+) is not lazy at all
16:49:13 <Solonarv> % foldr (+) 0 [1 .. 1000000]
16:49:14 <yahb> Solonarv: *** Exception: heap overflow
16:49:25 <Solonarv> % foldl' (+) 0 [ 1 .. 1000000 ]
16:49:26 <yahb> Solonarv: 500000500000
16:49:29 <Solonarv> zachk: ^
16:50:06 <zachk> so foldr would build more thunks?
16:50:16 <Solonarv> yes
16:50:43 <Solonarv> foldl' in contrast is strict and tail recursive
16:51:37 <Solonarv> my rule of thumb is: if you can produce part of the output after looking at part of the input, use foldr
16:52:03 <Solonarv> if you need to look at the entire input before producing any output at all, use foldl'
16:52:17 <Solonarv> basically never use foldl
16:53:00 <Solonarv> (if you're lucky, foldl ends up being the same as foldl'. if you're not, it will eat up all your memory by building ginormous thunks)
16:53:11 <c_wraith> foldr doesn't build especially many thunks there
16:53:32 <c_wraith> the problem is the evaluation depth, not a buildup of thunks
16:53:48 <Solonarv> ah, yeah
16:54:37 <c_wraith> foldl is still worse, though.  It builds up the huge mass of thunks - that then needs the same evaluation depth to get through
16:57:46 <ski> ("you can produce part of the output after looking at part of the input" = "you are incremental")
16:57:58 <ski> ("you need to look at the entire input before producing any output at all" = "you are bulky")
16:58:26 <ski> (and tail recursion inherently produces a bulky computation)
16:59:54 <Solonarv> ski: yup
17:00:10 <geekosaur> .oO { bulk smash }
17:00:40 * Solonarv . o O ( tail calls: the goto of functional programming )
17:43:03 <koz_> Solonarv: I thought that was callCC?
17:43:14 <koz_> (in the original, undelimited continuation form, a la Scheme)
17:44:08 <Solonarv> well callCC also tail-calls
17:44:22 <Solonarv> (or more accurately, the body tail-calls the continuation)
17:44:54 <Solonarv> but consider a group of mutually recursive functions which tail-call each other
17:45:09 <Solonarv> every function definition is a label, and the tail call is a goto
17:49:09 <Solonarv> in the callCC situation you basically pass a label (the continuation) to the body, and the body eventually jumps to that label by tail-calling the continuation
18:01:29 <ski> `callCC' would correspond to a "computed `goto'"
18:02:00 <ski> (although it also bundles up control state)
18:32:16 <fen> % pattern stateF act s = act $ fmap (pattern stateF act) (stateF s) 
18:32:16 <yahb> fen: ; <interactive>:99:16: error: parse error on input `act'
18:32:26 <fen> @let pattern stateF act s = act $ fmap (pattern stateF act) (stateF s) 
18:32:27 <lambdabot>  Defined.
18:32:34 <fen> :t pattern
18:32:34 <lambdabot> Functor f => (a -> f a) -> (f b -> b) -> a -> b
18:32:38 <fen> whats that?
18:34:38 <fen> oh its hylo from http://hackage.haskell.org/package/data-fix-0.2.0/docs/Data-Fix.html
18:34:58 <fen> seems to cover foldable and unfoldable for all the base functor types
18:35:01 <fen> neat pattern
18:35:31 <fen> that must be why they are called base "functors"
19:41:47 * hackage dbus 1.2.6 - A client library for the D-Bus IPC system.  https://hackage.haskell.org/package/dbus-1.2.6 (blaze)
19:57:47 * hackage polysemy-plugin 0.1.0.0 - Disambiguate obvious uses of effects.  https://hackage.haskell.org/package/polysemy-plugin-0.1.0.0 (isovector)
20:00:00 <iqubic> What's the difference between "/" and "div"?
20:00:06 <iqubic> :t (/)
20:00:07 <lambdabot> Fractional a => a -> a -> a
20:00:15 <iqubic> :t div
20:00:16 <lambdabot> Integral a => a -> a -> a
20:00:31 <iqubic> Other than the type signatures, is there a difference?
20:03:29 <Welkin> of course
20:03:34 <Welkin> one is integer division
20:03:38 <Welkin> the other is floating point
20:04:05 <Cale> Or not necessarily floating point, but division for the sort of numbers that can represent fractional results.
20:05:58 <iqubic> I see.
20:06:31 <iqubic> So next question: What's the difference between `div` and `quot`?
20:07:30 <iqubic> Also, what's the difference between `mod` and `rem`?
20:09:52 <Welkin> mod vs rem: one allows negative results
20:09:55 <Welkin> mod, I think
20:10:10 <Welkin> :t quot
20:10:11 <lambdabot> Integral a => a -> a -> a
20:10:19 <Welkin> not sure about quot; never used it
20:10:25 <Welkin> read the source to find out
20:11:16 <DigitalKiwi> https://ebzzry.io/en/haskell-division/
20:11:37 <iqubic> quot: integer division truncated toward zero
20:11:40 <iqubic> div: integer division truncated toward negative infinity
20:11:52 <iqubic> Mod: (x `div` y)*y + (x `mod` y) == x
20:12:04 <iqubic> rem: (x `quot` y)*y + (x `rem` y) == x
20:14:48 <iqubic> > divMod 13 -5
20:14:49 <lambdabot>  error:
20:14:49 <lambdabot>      • No instance for (Num (Integer -> (Integer, Integer)))
20:14:49 <lambdabot>          arising from a use of ‘e_1135’
20:15:01 <iqubic> > divMod 13 (-5)
20:15:03 <lambdabot>  (-3,-2)
20:15:16 <iqubic> > quotRem 13 (-5)
20:15:18 <lambdabot>  (-2,3)
20:15:37 <iqubic> > divMod (-13) 5
20:15:39 <lambdabot>  (-3,2)
20:15:54 <iqubic> > quotRem (-13) 5
20:15:54 <Welkin> are you hawaiian?
20:15:55 <lambdabot>  (-2,-3)
20:15:58 <Welkin> because you sure love spam
20:16:13 <iqubic> Why the hell does this work like that?
20:22:59 <Cale> iqubic: divMod is usually the thing you actually want, quotRem is usually the thing which is implemented in hardware
20:23:16 <iqubic> I'm not sure I understand.
20:23:35 <iqubic> Are you saying I should stick to divMod, and just not worry about quotRem?
20:23:41 <Cale> Typically, yeah
20:23:58 <iqubic> How do div and mod handle negative numbers?
20:24:11 <kadoban> iqubic: if you look at the docs it says exactly what equations they both follow
20:24:19 <kadoban> It's clearer that way
20:24:27 <iqubic> I don't really understand those equations.
20:25:44 <Cale> div/mod and quot/rem both satisfy the relations you'd want from a quotient and remainder. The differences are in what range the remainder will be selected from
20:26:07 <Cale> mod always gives you a remainder between 0 (inclusive) and the number you're dividing by (exclusive)
20:26:40 <iqubic> So that's like the mathematical version of modulo?
20:26:53 <iqubic> *modulus.
20:27:13 <Cale> I don't know what "the mathematical version" would be
20:27:19 <Cale> They're all mathematical :)
20:28:10 <Cale> There's actually another one which is often considered in mathematics, where you pick the remainder between 0 and the absolute value of the divisor. We don't have a name for that one.
20:29:20 <Cale> quotRem takes slightly fewer transistors to compute than various other options, and so that's what tends to be in CPUs
20:29:30 <Welkin> modus ponens?
20:30:10 <iqubic> cale: I thought picking the remainder from between 0 and abs val of divisor was what mod did.
20:30:12 <Cale> But the fact that it can give you a negative remainder even when the divisor is positive is obnoxious.
20:30:29 <Cale> mod gives you a remainder between 0 and the divisor, in either direction
20:30:38 <Cale> If your divisor is negative, then the remainder can be negative
20:30:50 <iqubic> So mod sometimes returns negative numbers?
20:31:01 <Cale> Yeah, but only when you give it negative divisors
20:31:05 <iqubic> Does rem always return positive numbers?
20:31:13 <Cale> no
20:31:32 <Cale> (as your example shows above)
20:31:42 <Cale> > rem (-13) 5
20:31:44 <lambdabot>  -3
20:31:55 <Cale> > mod (-13) 5
20:31:56 <lambdabot>  2
20:32:03 <DigitalKiwi> iqubic: read that link i sent it answers almost if not all of the questions you've asked
20:32:28 <nshepperd> iqubic: familiarise yourself with the behaviour of div and mod, and forget about quotRem imo
20:32:52 <iqubic> @check (\x -> x `mod` (-1) == 0)
20:32:54 <lambdabot>  +++ OK, passed 100 tests.
20:32:54 <nshepperd> you rarely need to worry about what happens when mod has a negative divisor anyway
20:32:56 <iqubic> Why does this happen?
20:33:17 <Cale> Yeah, quotRem is really only something you might reach for if you want to get a tiny bit of extra performance on occasion, and you know something about the signs of the numbers involved (e.g. if you know they're positive)
20:33:55 <Cale> iqubic: Well, you're dividing by (-1), that's always going to work out very nicely.
20:34:02 <iqubic> It is?
20:34:15 <Cale> div n (-1) will be -n
20:34:22 <Cale> and mod n (-1) will be 0
20:34:28 <monochrom> > div 10 (-1)
20:34:30 <lambdabot>  -10
20:34:31 <ski> iqubic : `div n (-1)' is going to be `-n'. so from `n = div n (-1) * (-1) + mod n (-1)', we can deduce `mod n (-1) = 0'
20:34:38 <monochrom> > quot 10 (-1)
20:34:39 <lambdabot>  -10
20:34:40 <iqubic> I see.
20:35:02 <monochrom> Ah I think they're different when I have -10 instead of 10.
20:36:30 <monochrom> Yeah quotRem does what x86 does, but divMod is probably fewer surprises for most applications.
20:36:44 <Welkin> x86 is dead
20:36:59 <nshepperd> long live x86_64
20:37:06 <Welkin> no!
20:37:21 <monochrom> And no one remembers Wirth's Pascal take, which is "the remainder is between -divider/2 and +divider/2"
20:37:45 <iqubic> > mod 10 (-2)
20:37:47 <lambdabot>  0
20:37:48 <ski> monochrom : i've seen that used in math, in some circumstances
20:37:59 <Welkin> is that a corollary to pascal's wager?
20:38:07 <monochrom> Yeah but we're in a programmer context.
20:38:13 <iqubic> > mod 10 (-3)
20:38:15 <lambdabot>  -2
20:38:18 <iqubic> Why is that -2?
20:38:25 <monochrom> Economics implies that programmers don't know math.
20:38:35 <Welkin> they don't
20:38:40 <Welkin> programmers are horrified of math
20:38:41 <Welkin> and logic
20:38:50 <Welkin> and social skills
20:38:52 <Cale> Because as I said, the remainder is between 0 and -3 (with -3 excluded)
20:39:09 <iqubic> But I thought the answer should be -1
20:39:15 <nshepperd> iqubic: instead of asking a bunch of trivial questions why not read the link DigitalKiwi posted and try to figure it out yourself first
20:39:15 <Cale> mod gets the sign of the remainder from the divisor
20:39:32 <Cale> > div 10 (-3)
20:39:33 <lambdabot>  -4
20:39:44 <iqubic> Oh, I see.
20:39:46 <Cale> > (-4) * (-3) + (-2)
20:39:48 <lambdabot>  10
20:39:49 <Welkin> quick! What's the resistance of an infinite grid of 1 ohm resistors?
20:40:23 <iqubic> mod returns the difference of the absolute values of the divisor and the dividend, following the sign of the divisor, if either the divisor or the dividend is negative.
20:40:25 <monochrom> Where are the two endpoints though?
20:40:30 <iqubic> Which isn't happening here.
20:40:39 <iqubic> > mod 10 (-3)
20:40:40 <lambdabot>  -2
20:40:48 <iqubic> > 10 - 3
20:40:49 <lambdabot>  7
20:41:05 <Cale> huh?
20:41:09 <iqubic> That link DigitalKiwi posted is a lie.
20:41:13 <Welkin> monochrom: inifinity
20:41:19 <ski> monochrom : also, looks like the same (or almost, depending on how you want to treat the endpoints) to `ROUND/' at Riastradh's "Proposal for Division Operators in Scheme" in 2009,2010,2011 at <https://mumble.net/~campbell/tmp/division.txt>
20:41:41 <Welkin> mumble.net?
20:41:47 <ski> monochrom : and mentioned in "Division and Modulus for Computer Scientists" by Daan Leijen in 2001-12-03 at <https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/divmodnote-letter.pdf>
20:42:08 <Welkin> is that like the voice conferencing software?
20:42:08 <monochrom> Yeah
20:42:17 <iqubic> DigitalKiwi's link claims that "mod 10 (-3)" should be equal to "10 - 3" and therefore should be 7.
20:42:20 <Welkin> oh that's mumble.com
20:43:34 <monochrom> Somehow "mumble" sounds like a terrible name for voice conferencing.
20:43:39 <DigitalKiwi> wat
20:43:39 <iqubic> So I'm not sure what this means exactly: "mod returns the difference of the absolute values of the divisor and the dividend, following the sign of the divisor, if either the divisor or the dividend is negative."
20:44:00 <monochrom> Like imagine I create an ISP and call it "CRC errors".
20:44:13 <Cale> monochrom: Given the average user's audio setup, and the general state of the software, it seems like a very appropriate and honest name.
20:44:31 <nshepperd> yeah i take it back, i'm not sure what the heck that sentence is supposed to mean either
20:44:36 <Welkin> well, mumble is supposedly a very high quality FOSS voip application
20:44:43 <monochrom> or "dropped packets".
20:44:50 <ski> monochrom : the two endpoints being `-divisor/2' and `+divisor/2' -- which to choose, if `divisor' is even ?
20:45:07 <Welkin> FOSS tends to have counter-intuitive names
20:45:08 <Welkin> like gimp
20:45:14 <monochrom> It's "excluding -divider/2" actually.
20:45:14 <Welkin> and pidgin
20:45:20 <iqubic> nshepperd: it's the last bullet point on this page; https://ebzzry.io/en/haskell-division/
20:45:32 <iqubic> pidgin is a weird name for a chat client.
20:46:04 <monochrom> OK anyone want to invest in my new ISP called packet-loss.com? >:)
20:46:26 <iqubic> No. I really don't.
20:46:41 <Welkin> ew, a hyphen?
20:46:41 <iqubic> Sounds like a slow and laggy system.
20:46:47 <Welkin> what is this? 1996?
20:46:50 * ski . o O ( Scheme,Guile,Chicken,Gauche,Larceny,Racket,Stalin .. scrotwm )
20:46:51 <nshepperd> it's called pidgin because it speaks multiple 'languages' i guess
20:47:12 <glguy> (poorly)
20:47:16 <Welkin> Scheme was originally called Schemer after Planner
20:47:18 <iqubic> scrot itself is just weird name for screenshot?
20:47:20 * ski nods
20:47:32 <iqubic> screenshot utility.
20:47:39 <Welkin> but the computer was limited to 6 letters or something for filenames
20:47:52 <Welkin> scrot sounds like scrotum
20:48:12 <ski> monochrom : for `ROUND/', it's using Banker's rounding
20:48:46 <nshepperd> iqubic: yeah that bullet point seems wrong...
20:48:48 <geekosaur> tops10? 6.3 (and limited SIXBIT character set too)
20:48:52 <ski> (but in the math situation i saw, it was always `-divisor/2' which was excluded)
20:49:25 <monochrom> Yeah
20:51:39 <nshepperd> iqubic: but you can understand all the behaviour of divMod from this: (a `div` b) is a/b rounded toward -infinity. (a `div` b) * b + (a `mod` b) = a
20:51:53 <iqubic> I once read an article that said "20 `mod` -1" was somehow equal to 19.
20:51:59 <iqubic> Not sure how though.
20:52:24 <ski> > 20 `mod` 0  -- this ought to be equal to `20'
20:52:25 <lambdabot>  *Exception: divide by zero
20:54:35 <nshepperd> > 10 `div` (-3) -- iqubic: -4, because 10/(-3) is -3.33…
20:54:37 <lambdabot>  -4
20:55:34 <nshepperd> > 10 `mod` (-3) -- iqubic: (-2), because (-4) * (-3) + (-2) is 10
20:55:36 <lambdabot>  -2
20:59:35 <DigitalKiwi> if it's wrong here's the source https://github.com/ebzzry/ebzzry.github.io/blob/22f17475d0218a8e68983ac663fb7d0ff2fcfe02/en/fkd/haskell-division.md submit a PR or issue i guess 
22:11:25 <lrb> I'm trying to write a function that requires an argument that's a tuple. So far I've got (@) :: <something> -> foo -> Int. How do I force <something> to be, for example, a tuple of size 2? I'm sure this book explains it but I don't think I'm understanding.
22:13:27 <pavonia> lrb: Tuple type syntax is (<something>, <something>)
22:15:30 <lrb> Oh, it just clicked. It was in a chapter I haven't read to yet. https://en.wikibooks.org/wiki/Haskell/Pattern_matching
22:17:17 * hackage discord-haskell 0.8.3 - Write bots for Discord in Haskell  https://hackage.haskell.org/package/discord-haskell-0.8.3 (Aquarial)
22:25:30 <ski> > let (@) = (+) in ()
22:25:32 <lambdabot>  <hint>:1:6: error: parse error on input ‘@’
22:29:49 <lrb> I've been trying to figure that error out myself, tbh.
22:30:09 <lrb> It doesn't look like @ is reserved or anything
22:30:17 <lrb> Maybe I've got syntax wrong
22:30:35 <ski> it is reserved
22:30:42 <ski> > let (@@) = (+) in ()
22:30:44 <lambdabot>  ()
22:31:01 <lrb> Not according to this: https://stackoverflow.com/questions/10548170/what-characters-are-permitted-for-haskell-operators
22:31:11 <ski> well, this is different
22:31:26 <ski> this is not like "`-' is not allowed in an ordinary identifier"
22:31:53 <ski> this is like "`if' is not allowed as an ordinary identifier (but `iff' is)"
22:32:00 <lrb> Oh, I missed one section of that response.
22:32:07 <ski> so renaming the infix operator to `@@' is fine
22:32:13 <ski> just `@', not fine
22:32:58 <ski> basically, `@' is a reserved keyword .. except perhaps one should say "reserved keysymbol" or something, in this case ?
22:36:16 <ski> (other examples are `~',`->',`<-',`=>',`\\',`|')
