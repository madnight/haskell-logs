00:17:45 <remexre> are there any reasonably simple pointed functors (functor + pure) that are not applicatives?
00:20:29 <suzu> Const
00:21:03 <suzu> Const over something that is not a monoid, isn't applicative
00:21:36 <remexre> huh, is it unlawful to define (Const a) <*> (Const _) = (Const a) ?
00:22:52 <delYsid> Does hackage have a type to represent non-negative time intervals somewhere?
00:23:39 <remexre> also wait, how is const a pointed functor?
00:23:56 <remexre> I can't write a function (a -> Const b a) for an arbitrary b
00:24:16 <suzu> oh, sorry i didnt see the pointed part
00:25:08 <suzu> you can write a -> Const a b, for any b
00:25:12 <suzu> though that isnt the same
00:25:56 <remexre> yeah
00:26:08 <suzu> hmm
00:26:13 <suzu> im not sure if there are any then
00:26:20 <suzu> though just because i cant think of one isnt a proof that they dont exist
00:26:23 <suzu> :P
00:27:11 <suzu> if its a pointed functor then i think yeah you probably can write an applicative for it
00:27:40 <suzu> at least, i feel like that should be true
00:27:41 <suzu> idk tho
00:28:46 <remexre> alright, thanks!
01:46:33 <arjen-jonathan> Whatsup with hackage?
01:48:18 <Taneb> arjen-jonathan: https://status.haskell.org/
01:55:28 <arjen-jonathan> Ah, didn't know about that one, thanks
02:15:42 <mr971[m]> https://hackage.haskell.org/ returns 502
02:16:38 <phadej> mr971[m]: https://www.reddit.com/r/haskell/comments/b99cef/hackage_downtime/
02:17:32 <phadej> or/and https://status.haskell.org/
02:30:45 <mimi_vx> hello phadej, please could you https://github.com/haskell-infra/www.haskell.org/pull/3 ?
03:19:23 <ibloom> why would you get a conflict line from cabal like: 
03:19:28 <ibloom> https://www.irccloud.com/pastebin/IPe5f8SK/
03:20:00 <ibloom> it seems like base<0 is impossible to fulfill.
03:21:13 <juhp> Basically that disables the package...
03:22:54 <ibloom> I see
03:23:38 <ibloom> I'm using ghc as an API and I was just trying to get cabal to use 8.6.*
03:24:43 <ibloom> Befuddled by what I need to do to make that happen: https://github.com/ianmbloom/venturi/blob/master/venturi.cabal
03:42:33 <merijn> ibloom: "get cabal to use 8.6" <- are you referring to the GHC for compilation, the GHC library to link against, or both?
03:43:24 <merijn> ibloom: Incidentally, you don't seem to have any version constraints on your dependencies, that's...probably not right if you want to use a specific GHC version :)
03:45:45 <jsomedon> hi, I am learning haskell and got confused with Data type definition
03:45:59 <jsomedon> for example, code like this: data Color = Red | Blue | Green
03:46:52 <jsomedon> I wonder if those Red, Blue, Green are variables that would get defined somewhere internally?
03:47:42 <merijn> jsomedon: Depends on what you mean by "are", "variables", "would get defined somewhere", and "internally" ;)
03:47:50 <jsomedon> uh....
03:48:12 <jsomedon> ok let me rephrase my question..
03:49:02 <merijn> jsomedon: A more helpful answer is probably: The language doesn't specify how constructors should be implemented, therefore any answer will be entirely implementation specific and, honestly, borderline irrelevant to working with Haskell :)
03:49:08 <lunabo> does anyone know why the Cloud Haskell packages (distributed-process and network-transport-tcp) are not available on most of the recent Stack LTS snapshots? is it because of incompatibility with recent GHC versions?
03:49:58 <merijn> jsomedon: So, the compiler could, for example, assign a number to each constructor and use those at runtime to "check" if constructors match
03:50:19 <TMA> jsomedon: it is a type definition, it defines a type
03:50:21 <ibloom> merijn, I'm using the GHC API to compile some haskell code to Core.
03:50:36 <jsomedon> wow
03:50:47 <jsomedon> thanks merijn
03:50:54 <jsomedon> and thanks TMA
03:51:00 <ibloom> I tried compiling it to STG instead and I'm getting a panic when I try to pretty print the output.
03:51:05 <jsomedon> that's alot to digest
03:51:18 <ibloom> So tried using a more recent version of GHC
03:51:42 <ibloom> Incidentally GHC>=8.4 works fine.
03:52:11 <ibloom> But I don't think that the GHC version was the actual problem as I still get the panic.
03:55:25 <merijn> jsomedon: The language specification basically says "you can define constructors like this" and "if you pattern match, this should happen", but there are many different ways you can implement that behaviour and the lack of definition of "how it's done" is to allow compiler implementors maximum freedom when implementing the compiler
03:56:07 <merijn> jsomedon: In fact, it's not even required that the compiler uses the same method for all code in a program, it's perfectly allowed to compile ADTs in different ways, as long as the behaviour stays the same
03:56:38 <merijn> jsomedon: GHC (mostly) relies on assigning unique tags (i.e., numbers) to constructors, but that's just an implementation detail
03:56:48 <jsomedon> merijn: uh, I see you keep mentioning constructor, and in that Color type definition, do you mean Red, Blue Green are constructor?
03:56:56 <merijn> jsomedon: Yes
03:57:02 <jsomedon> merijn: oh ok
03:57:33 <jsomedon> So this Color definiton code just tells me: Color has these three constructor, but how they work I don know
03:57:41 <merijn> jsomedon: Similarly "data Maybe a = Nothing | Just a" defines two constructors "Nothing" and "Just" with "Just" taking an additional argument value
03:57:45 <merijn> jsomedon: Right
03:58:26 <jsomedon> merijn: so for that Maybe code, 'a' is an argument to the constructor
03:58:33 <merijn> jsomedon: And the language specification says "you can pattern match on constructors to check which value you get"
03:58:36 <merijn> jsomedon: Yeah
03:59:31 <jsomedon> merijn: uhm, you say arg on constructor.. so constructors in haskell are kind of function? because functions take args
03:59:46 <merijn> jsomedon: So all that the language defines is that if I have "case Red of Blue -> 'a'; Red -> 'b'; Green -> 'c'" then I get 'b', but it doesn't tell me "how" (which is irrelevant for knowing what your program does, anyway)
04:00:00 <lunabo> jsomedon: I think it's maybe easier to focus on type definitions that do not include a type parameter btw (a is a type parameter in the Maybe example)
04:00:05 <lunabo> at first
04:00:07 <merijn> jsomedon: Some constructors have the type of a function, yes.
04:00:10 <merijn> :t Nothing
04:00:11 <lambdabot> Maybe a
04:00:17 <merijn> ^^ not a function
04:00:19 <merijn> :t Just
04:00:20 <lambdabot> a -> Maybe a
04:00:23 <merijn> ^^ a function
04:01:17 <jsomedon> lunabo: oh ok so for type it's param not arg
04:02:45 <lunabo> jsomedon: well that's what it's usually called I think, but it's just a name, if you would call it a type argument I don't think that would be too strange either
04:03:19 <lunabo> jsomedon: it's a bit similar to the T in vector<T> or ArrayList<T> if you're familiar with C++ or Java
04:03:30 <jsomedon> lunabo: oh
04:05:22 <jsomedon> So given code: data Color = Red | Blue | Green, how I make a Red value?
04:05:35 <lunabo> jsomedon: just write Red :)
04:05:36 <jsomedon> just: Red ?
04:05:41 <jsomedon> ...
04:05:47 <jsomedon> that's really weird..
04:06:01 <jsomedon> I even didn't define how Red works yet..
04:06:22 <lunabo> jsomedon: are you familiar with enums from C or C++?
04:06:28 <merijn> jsomedon: You told the compiler "this constructor exists", and so it does :)
04:06:28 <lunabo> jsomedon: it's a bit similar to that for this example
04:06:41 <jsomedon> oh
04:06:44 <merijn> @let data Color = Red 
04:06:45 <lambdabot>  Defined.
04:06:48 <merijn> @undefine
04:06:48 <lambdabot> Undefined.
04:06:56 <merijn> @let data Color = Red | Green | Blue deriving (Show)
04:06:57 <lambdabot>  Defined.
04:07:00 <merijn> :t Red
04:07:01 <lambdabot> Color
04:07:19 <merijn> > case Red of Blue -> 'a'; Red -> 'b'; Green -> 'c'
04:07:21 <lambdabot>  'b'
04:07:53 <jsomedon> deriving is like inheritance?
04:09:18 <merijn> jsomedon: No, almost entirely unlike inheritance ;) Haskell uses typeclasses for "overloaded functions" (like "turn this into a String"), the language defines several typeclass for which the compiler can automatically generate an implementation. One of those is "Show" which makes things printable
04:09:23 <merijn> > Red
04:09:25 <lambdabot>  Red
04:09:31 <merijn> @undefine
04:09:31 <lambdabot> Undefined.
04:09:38 <merijn> @let data Color = Red | Green | Blue
04:09:40 <lambdabot>  Defined.
04:09:54 <merijn> Without the Show instance you can write the code, but the compiler doesn't know how to print things
04:09:58 <merijn> > case Red of Blue -> 'a'; Red -> 'b'; Green -> 'c'
04:10:00 <lambdabot>  'b'
04:10:02 <merijn> ^^ Still works
04:10:08 <merijn> > Red -- this doesn't
04:10:10 <lambdabot>  error:
04:10:10 <lambdabot>      • No instance for (Show Color)
04:10:10 <lambdabot>          arising from a use of ‘show_M627483660440515735514581’
04:10:36 <merijn> jsomedon: "No instance for (Show Color)" <- aka "I don't know how to print this"
04:10:39 <jsomedon> oh
04:11:04 <merijn> jsomedon: so "deriving (Show)" just tells the compiler "generate code so you know how to print this"
04:11:17 <jsomedon> ha that bot is nice
04:12:24 <jsomedon> so if "data Color = whatever_name_comes_here deriving (Show)"
04:12:30 <lunabo> is there a hackage mirror btw? since hackage seems to be down
04:13:07 <jsomedon> then that whatever_name_comes_here gets printed out as is?
04:13:21 <Ariakenom> compare to telling your IDE to write a toString. instead you tell the compiler to define show
04:14:02 <jsomedon> so it's like toString() in other language
04:14:05 <merijn> jsomedon: Yes
04:14:08 <lunabo> jsomedon: the default implementation of show that is automatically generated displays things pretty much exactly like they appear in the code
04:14:14 <jsomedon> ok
04:14:18 <lunabo> jsomedon: so Red would get shown as "Red"
04:14:31 <jsomedon> and I guess you can customize this toSring() behavior as well?
04:14:33 <lunabo> but you can also implement show yourself if you want things to look different in principle
04:14:46 <merijn> jsomedon: You can define your own typeclasses and your own instances, yes
04:14:48 <jsomedon> lunabo: ah exactly what I was asking
04:15:01 <jsomedon> merijn: ah great
04:15:20 <merijn> @let instance Show Color where show c = case c of Red -> "Foo"; Green -> "Bar"; Blue -> "Baz"
04:15:21 <lambdabot>  Defined.
04:15:30 <merijn> > Red -- this is a pretty terrible idea, though...
04:15:33 <lambdabot>  Foo
04:15:54 <merijn> jsomedon: The general rule is that Show *should* print something that is valid Haskell
04:16:07 <jsomedon> merijn: k
04:17:19 <merijn> (For everyone's sanity)
04:17:34 <merijn> There are multiple libraries for prettyprinting classes if you want something fancy instead
04:19:06 <jsomedon> uhm so just to double check.. for this code "data Color = Red | Blue" I make a new type Color and possible value of Color type is Red and Blue? And Red and Blue are value and constructor at the same time?
04:19:31 <merijn> jsomedon: Correct
04:20:20 <jsomedon> that "constructor and value at the same time" part really confuses me..
04:21:09 <tdammers> they're "value constructors"... not sure how much that helps though
04:21:15 <lunabo> jsomedon: well, if you want you can think of it like a "zero-argument" constructor
04:21:20 <jsomedon> so for "data Maybe a = Nothing | Just a"
04:22:03 <jsomedon> so for "data Maybe a = Nothing | Just a", "Maybe a" is type, "Nothing a" and "Just a" are value and constructor and same time? 
04:22:03 <lunabo> jsomedon: you don't have to give it any arguments before it creates a value
04:22:23 <Ariakenom> hm, what's a value to you?
04:22:33 <lunabo> lunabo: so basically a "zero-argument" constructor is already a value :P
04:22:34 <jsomedon> uh..
04:22:42 <jsomedon> a value
04:22:51 <jsomedon> like numbers
04:22:53 <jsomedon> strings
04:22:57 <jsomedon> true
04:22:59 <jsomedon> false
04:23:01 <merijn> jsomedon: Functions are also values in Haskell, though :)
04:23:11 <jsomedon> ah yeah functions
04:23:18 <lunabo> jsomedon: compare it to data Bool = True | False
04:23:30 * tdammers tries hard to refrain from saying "types are also values"
04:23:41 <jsomedon> tdammers: uh...
04:23:48 * mniip . o O ( are instance dictionaries values )
04:23:55 <merijn> jsomedon: Anyway, "constructors" are a subset of values (so all constructors are values, but not all values are constructors)
04:24:24 <tdammers> jsomedon: they are, but for now, you can safely ignore this - thinking of types and values as separate universes makes the basic stuff easier to understand
04:24:39 <merijn> jsomedon: Nothing and Red are similar to True, 'c', and 1
04:25:05 <jsomedon> lunabo: my mind reads that code like: I just defined a Bool type, whose value are True and False..
04:25:12 <mniip> that is correct
04:25:25 <merijn> jsomedon: The only difference is that where character/string/numeric/boolean literals tend to be hardcoded in the language. In Haskell you can trivially make your own
04:25:38 <lunabo> jsomedon: yes, so there are two ways of constructing something of type Bool: you can either write True or you can write False
04:25:49 <lunabo> jsomedon: that is why they are called constructors
04:25:49 <merijn> jsomedon: Not only are you correct, Bool isn't even a magic builtin datatype, it's just defined in a library :)
04:26:14 <merijn> jsomedon: (Although there is some "magic" support for Bool in the form of guards/and if-then-else)
04:26:15 <tdammers> @src Bool
04:26:15 <lambdabot> data Bool = False | True deriving (Eq, Ord)
04:26:30 <mniip> % :i Bool
04:26:35 <yahb> mniip: data Bool = False | True -- Defined in `GHC.Types'; instance Eq Bool -- Defined in `GHC.Classes'; instance Ord Bool -- Defined in `GHC.Classes'; instance Show Bool -- Defined in `GHC.Show'; instance Read Bool -- Defined in `GHC.Read'; instance Enum Bool -- Defined in `GHC.Enum'; instance Bounded Bool -- Defined in `GHC.Enum'; instance Bits Bool -- Defined in `Data.Bits'; instance FiniteBits Bool -- Defin
04:28:29 <Ariakenom> oh Bits
04:28:33 <Ariakenom> % True `xor` True
04:28:33 <yahb> Ariakenom: False
04:28:44 <lunabo> jsomedon: but I think the difference between "value" and constructor only becomes more clear once you look at constructors that take arguments though
04:30:04 <lunabo> jsomedon: data Book = BookConstruct String | NoBook
04:30:23 <lunabo> Here BookConstruct and NoBook are the constructors
04:30:29 <jsomedon> oh
04:30:35 <lunabo> but if you want to make a value of type Book with BookConstruct, you have to first give it a string
04:31:00 <lunabo> BookConstruct "Book title" is a value of type Book, but it's not a constructor (BookConstruct is the constructor)
04:31:16 <jsomedon> then this is a Book value? --> BookConstruct "some string"
04:31:22 <jsomedon> ah
04:31:25 <lunabo> yes exactly
04:31:34 <Ariakenom> (BookConstruct is still a value though)
04:31:48 <jsomedon> Ariakenom: but not a value of Book type?
04:31:58 <merijn> @define data Book = BookConstruct String | NoBook
04:31:59 <Ariakenom> jsomedon: correct
04:31:59 <lambdabot>  Defined.
04:32:02 <jsomedon> ah
04:32:05 <jsomedon>  hmmm
04:32:08 <merijn> :t BookConstruct -- Let's see :)
04:32:09 <lambdabot> String -> Book
04:32:22 <merijn> :t BookConstruct "some string"
04:32:23 <lambdabot> Book
04:32:28 <jsomedon> ah
04:32:31 <jsomedon> ok
04:33:04 <jsomedon> that BookConstruct type looks similar to a function, a function that takes a String and return Book
04:33:51 <lunabo> that's essentially what it is
04:34:07 <Ariakenom> :t BookConstruct "title"
04:34:08 <lambdabot> Book
04:34:22 <lunabo> and NoBook is also like that, except it doesn't require any arguments so it's not a function
04:34:33 <jsomedon> But as you guys said, not all constructors are implemented same, maybe some are functions maybe some are not, so I can't assume that, because it's type looks like a function, it's actually a function?
04:34:44 <jsomedon> lunabo: oh ok
04:35:04 <jsomedon> :t NoBook
04:35:05 <lambdabot> Book
04:35:23 <jsomedon> :t BookConstruct String
04:35:24 <lambdabot> error:
04:35:24 <lambdabot>     • Data constructor not in scope: String :: String
04:35:24 <lambdabot>     • Perhaps you meant one of these:
04:36:02 <jsomedon> :t (BookConstruct String)
04:36:03 <lambdabot> error:
04:36:03 <lambdabot>     • Data constructor not in scope: String :: String
04:36:03 <lambdabot>     • Perhaps you meant one of these:
04:36:43 <jsomedon> :t BookConstruct
04:36:44 <lambdabot> String -> Book
04:36:56 <jsomedon> :t BookConstruct "a string"
04:36:57 <lambdabot> Book
04:37:12 <jsomedon> :t :t
04:37:12 <Ariakenom> jsomedon: what do you mean? it is "actually a function".
04:37:13 <lambdabot> error: parse error on input ‘:’
04:37:23 <tdammers> jsomedon: if you want to experiment with lambdabot, you can also send her private /msg commands, helps avoid spamming the channel
04:37:42 <jsomedon> tdammers: ah ok
04:38:21 <jsomedon> Ariakenom: so a constructor with param is actually a function?
04:40:09 <lunabo> jsomedon: yep pretty much, but it's even a bit more than that, since you can also do pattern matching to see which constructor was used to create the value
04:41:00 <merijn> jsomedon: Anything with a function type (so "a -> b") is a function. Some functions just happen to *also* be constructors
04:41:07 <jsomedon> oh
04:41:08 <jsomedon> ok
04:41:17 <dramforever> You can think of the value-making mechanism something a bit lower level, and the constructor being a function wrapping the lower level mechanism
04:42:13 <dramforever> So BookConstruct is a function that takes a String and does some magic (sorta) to make a Book value
04:42:34 <jsomedon> dramforever: ha ha that's exactly how I understand now
04:42:52 <dramforever> Pattern matching on BookConstruct is a nicely symmetric way of sorta doing that in reverse, getting a String back from a Book
04:44:17 <dminuoso> jsomedon: It might be helpful to use a type extension called GADTSyntax early on, as it helps visualize certain aspects of data constructors.
04:44:17 <dramforever> If you check case class/object from Scala, it might be more clear how constructing and pattern matching works because there's a bit less magic involved. Or it might confuse you even further, who knows.
04:44:48 <hpc> in GADTSyntax you get things like data Bool where {False :: Bool; True :: Bool}
04:45:03 <hpc> and data Book where {BookConstruct :: String -> Book; NoBook :: Book}
04:45:20 <hpc> (except with layout instead of braces, generally)
04:46:24 <dramforever> GADTSyntax really shows well how to *use* data constructors
04:46:33 <Ariakenom> dramforever: not that I've ever used scala, but that sounds like more magic. but maybe more familiar
04:46:35 <raichoo> Huh… is hackage down or is that just me?
04:46:52 <dminuoso> raichoo: https://status.haskell.org/
04:46:52 <dramforever> Because you *do* use them like functions. And when pattern matching
04:46:53 <MarcelineVQ> raichoo: probably down, was earlier, there's a status page at haskell.org I think
04:46:58 <lunabo> I do think the standard data syntax is a bit confusing when you first look at it, especially if you use the same name for the type as for the constructor
04:47:06 <dramforever> Down for half a day I think
04:47:15 <dminuoso> lunabo: Yup, which is why I generally recommend GADTSyntax when starting out with Haskell.
04:47:35 <dminuoso> lunabo: Once you get used to it, you can disable it and use more compact and terse code like the rest of us. :)
04:47:44 <hpc> standard ADT syntax has the same issue that say, python imports do
04:47:57 <hpc> in python import syntax, you're mixing module names and definitions seemingly at random
04:48:10 <hpc> in ADT syntax, you're mixing type and value-level terms
04:48:23 <raichoo> dminuoso: Ah thanks. Didn't know about status.haskell.org :) Thank you.
04:48:39 <hpc> data <type> = <value> <type> <type> | <value> <type> ...
04:53:53 <merijn> I have argued in the past and will keep doing so in the future that GADTSyntax is superior for teaching
04:54:27 <jsomedon> I just googled GADT
04:54:59 <jsomedon> is this sort of new way to write data type definition in haskell?
04:55:36 <hpc> yes
04:56:07 <hpc> GADTSyntax is a different way to write out regular ADTs, and GADTs themselves are able to express a bit more
04:56:19 <hpc> something you can do with GADTs that you couldn't do with ADTs for instance, is
04:56:50 <hpc> data Example a where {IntExample :: Int -> Example Int; StringExample :: String -> Example String}
04:57:23 <hpc> in practice, it's useful for linking type-level information with value-level information
04:57:26 <hpc> like so:
04:57:53 <hpc> data CheckedHandle open where {Open :: Handle -> CheckedHandle True; Closed :: CheckedHandle False}
04:58:07 <hpc> hPutStrLn' :: CheckedHandle True -> IO ()
04:58:52 <hpc> or perhaps, data CheckedHandle read write where ...
04:59:07 <hpc> GADTs are very powerful
04:59:43 <hpc> oh
04:59:48 <hpc> i accidentally used DataKinds there
05:00:22 <hpc> imagine i also had placeholder data types, "data True = TrueValue" and "data False = FalseValue"
05:02:46 <dminuoso> jsomedon: GADTSyntax is a harmless cosmetic change allowing you to write data types a bit more verbosely. Please do not compare them with GADTs. :)
05:03:05 <dminuoso> jsomedon: If you are just starting out, you may get quickly overwhelmed if you peek at GADTs too early.
05:03:16 <jsomedon> dminuoso: uh
05:03:40 <jsomedon> dminuoso: this is what I just googled: https://en.wikibooks.org/wiki/Haskell/GADT#Summary
05:03:53 <dminuoso> jsomedon: Yeah feel free to ignore it, it has nothing to do with what I suggested.
05:03:58 <dminuoso> jsomedon: Let me make a gist to show you.
05:04:01 <jsomedon> oh
05:04:03 <jsomedon> ok
05:05:03 <dminuoso> jsomedon: https://gist.github.com/dminuoso/ecdc99adc4753037418cbe6a8baa9dd7
05:05:13 <jsomedon> dminuoso: ok
05:05:55 <dminuoso> jsomedon: So here you get to visually distinguish between data world things `Book the data constructor`, its signature `String -> Int -> Book` and `Book the type constructor`
05:06:22 <dminuoso> jsomedon: Since you should know `::` as `has type`, this should look very familiar already.
05:07:33 <jsomedon> dminuoso: this way of writting does make type clear
05:08:14 <hpc> you've learned your first language extension :D
05:08:49 <jsomedon> dminuoso: about that Book the type con vs Book the data con, uhm.. is this idiomatic to write same name for type con and data con
05:08:57 <dminuoso> jsomedon: Yes.
05:09:03 <jsomedon> ok..
05:09:13 <dminuoso> jsomedon: Its very common to reuse the same identifier since they dont overlap.
05:09:26 <dminuoso> jsomedon: If you prefer you can change it however. :)
05:09:51 <jsomedon> yeah I think I will start with different names..
05:09:53 <hpc> sometimes you can be more specific with your data constructor name, but it gets increasingly difficult as you get more general
05:10:11 <jsomedon> hmm I can imagine that
05:10:12 <hpc> maybe you'd have data Book = HardCover | PaperBack
05:10:33 <MarcelineVQ> data Foo = MkFoo is fairly common if you want a similar name
05:10:45 <jsomedon> that's nice
05:11:02 <MarcelineVQ> It can get a little boring to type Mk all the time but it's quite readable
05:11:08 <merijn> jsomedon: It's especially nice for datatypes with only a single constructor, because then you only have to think of one name ;)
05:11:41 <dminuoso> jsomedon: In time you should get used to it, but its perfectly reasonable to use different names to let your mind get used to recognizing the different namespaces.
05:12:25 <dminuoso> jsomedon: To me `data Book = Book { unBook :: String }` imposes no mental overhead, I can instantly recognize all parts of it. But it took some practice. :)
05:13:04 <jsomedon> uhm, what does { some code } mean?
05:13:26 <hpc> it's because we can't write more than one line nicely on irc
05:13:39 <hpc> imagine the stuff in {} is indented, and newlines where ";" is
05:13:45 <dminuoso> hpc: Uh? Arent {} necessary for fields? :)
05:13:52 <hpc> oh, that too
05:14:02 <dminuoso> Shame, it would have made for quite a TIL moment.
05:14:06 <optmzr> Umm, is hackage down?
05:14:10 <dminuoso> optmzr: Yes.
05:14:19 <hpc> dminuoso: i am really stupid in the morning
05:14:25 <hpc> (and only slightly less stupid in the afternoon lol)
05:14:30 <optmzr> Woah quick, thanks dminuoso 
05:14:39 <dminuoso> jsomedon: Id say ignore it, your learning resource will cover it in time.
05:14:53 <jsomedon> dminuoso: ok, tbh I still dont really get that code
05:15:13 <jsomedon> trying real hard to understand that code
05:15:23 <dminuoso> jsomedon: It may be useful to start with the motivatoin: Consider a data record: data Book = Book String String Int String
05:15:36 <dminuoso> jsomedon: Now one field is going to be the title, one the author, the year it was published in, and the content.
05:15:36 <jsomedon> ...
05:15:41 <dminuoso> But which is which?
05:16:00 <jsomedon> I guess just in the order you described?
05:16:12 <jsomedon> so
05:16:14 <dminuoso> You can name those fields and automtically create accessor function: data Book = Book { title :: String, author :: String, pubishedIn :: Int, content :: String }
05:16:14 <jsomedon> like
05:16:35 <jsomedon> ah
05:16:41 <dminuoso> That then generates functions: title :: Book -> String; author :: Book -> String; etc...
05:16:53 <jsomedon> oh
05:17:36 <jsomedon> ok so what you wrote is not decorative thing like hpc said due to irc but it's actual haskell syntax
05:17:42 <dminuoso> Right.
05:17:46 <jsomedon> ok haha
05:17:51 <Ariakenom> and now for a lens tutorial ...
05:18:12 <dminuoso> lenses are just coalge... oh wait. I said to myself not to make jokes when beginners are present.
05:18:52 <Ariakenom> does that not include jokes about not making jokes?
05:19:39 <lunabo> jsomedon: also, you can achieve exactly the same thing as what dminuoso wrote by writing data Book = Book String String Int String and then writing the functions like title, author, publishedIn yourself
05:20:13 <lunabo> jsomedon: well actually not exactly the same thing, but pretty close to it
05:20:43 <lunabo> jsomedon: you get some other nice things if you use the record syntax as it is called
05:20:45 <jsomedon> lunabo: ok
05:21:07 <jsomedon> so that { name: type} thing is record
05:21:22 <lunabo> jsomedon: yes
05:22:25 <lunabo> jsomedon: but there is not that much difference between that and the other ways of defining the Book type that you have seen, it's just a bit more convenient sometimes
05:22:32 <lunabo> jsomedon: so a record is not really something special in that sense
05:23:22 <dminuoso> jsomedon: Well you can think of it as a field specification.
05:23:28 <jsomedon> it's just a way of automatically generate getter adn setter?
05:23:43 <dminuoso> jsomedon: More or less, yes.
05:23:58 <dminuoso> jsomedon: It adds a few more subtle things, but we can glance over that.
05:24:07 <jsomedon> alright
05:24:25 <jsomedon> reading wikibook on this Record Syntax
05:24:55 <lunabo> jsomedon: and the syntax for records maybe looks a bit similar to GADTSyntax, but those are completely different things btw
05:25:20 <dminuoso> jsomedon: *confusingly* the record field syntax reuses the `::` in a different sense.
05:25:41 <dminuoso> jsomedon: So this is where you need to juggle in your head a bit.
05:25:46 <dminuoso> Consider:
05:26:34 <michaelsaniyan> Does anyone know some good exercises for basic monad usage? Ive worked through all of the monad related material in Learn You a Haskell and it would be nice to have some problems to apply the material to.
05:26:49 <dminuoso> `data Book  = Book { title :: String }` - here title does *not* have type `String`. Instead what this says is "the field named `title` has type String, and it also generates a value level construct called `title :: Book -> String`
05:27:39 <jsomedon> dminuoso: ah yeah
05:28:10 <Ariakenom> michaelsaniyan: I see this course material recommended. it has monad homework https://www.seas.upenn.edu/~cis194/spring13/lectures.html
05:28:43 <jsomedon> dminuoso: it's like saying the return value of function title is String type
05:29:37 <michaelsaniyan> Ariakenom: Thanks!
05:29:38 <dminuoso> jsomedon: If that mindmodel helps you, sure.
05:29:50 <jsomedon> dminuoso: but in GADT if I see `title :: String` then title IS the String type?
05:30:47 <lunabo> jsomedon: in GADT, the thing before the :: will always start with a capital letter since data constructors start with capital letter
05:30:51 <ClaudiusMaximus> language extension RecordWildCards lets you do  printTitle Book{..} = putStrLn title  -- here title :: String, and all other fields are similarly brought into scope
05:31:06 <jsomedon> lunabo: ah
05:31:18 <lunabo> jsomedon: and the thing behind the :: should be the type you are defining, hence it will probably never be String :)
05:31:28 <dminuoso> jsomedon: So you can mix records and GADTSyntax, but that does not look pretty or natural.
05:31:32 <lunabo> jsomedon: but if you saw something like Title :: Book then it would mean Title is a value of type Book
05:31:40 <dminuoso> jsomedon: Id say that you are better off not using GADTSyntax for records that have field names.
05:31:50 <jsomedon> dminuoso: ok
05:31:50 <dminuoso> % :set -XGADTs
05:31:50 <yahb> dminuoso: 
05:32:22 <dminuoso> % data Book where Book { title :: String, content :: String } :: Book
05:32:22 <yahb> dminuoso: ; <interactive>:7:22: error: parse error on input `{'
05:32:30 <dminuoso> Mmm
05:33:01 <jsomedon> lunabo: So every constructor name should start with Captal letter, is that convention or it's part of grammar?
05:33:09 <dminuoso> Ohh
05:33:12 <lunabo> jsomedon: it's part of the grammar
05:33:15 <dminuoso> % data Book where Book :: { title :: String, content :: String } -> Book
05:33:15 <yahb> dminuoso: 
05:33:16 <jsomedon> oh
05:33:20 <jsomedon> ok
05:33:26 <dminuoso> jsomedon: ^- this is what it would look like.
05:34:07 <dminuoso> But you lose this visual niceness of why you might use GADTSyntax to begin with
05:34:21 <jsomedon> this surely is confusing
05:35:02 <jsomedon> so it's a Book type that has Book constructor, the Book con's type is ..
05:35:35 <jsomedon> String -> String -> Book ?
05:35:40 <dminuoso> jsomedon: Yes
05:36:28 <dminuoso> jsomedon: Let me emphasize though: There's a difference between GADTSyntax and GADTs
05:37:31 <jsomedon> I googled GADTSyntax and search result just talks about GADT
05:37:34 <dminuoso> jsomedon: GADTs is a change to the type system naturally extending data constructors in some ways. This is not relevant for you. GADTSyntax is an extension that just burrows the syntax from how GADTs are defined and allows you to write non-GADTs the same way as GADTs. :)
05:38:24 <jsomedon> so GADT is like haskell++
05:38:36 <jsomedon> and GADTSyntax is haskell but you can write code like haskell++
05:38:42 <dminuoso> jsomedon: Spot on. :)
05:39:03 <dminuoso> jsomedon: Its the visual style of GADTs without the expressive power of GADTs.
05:40:00 <jsomedon> you mean "spot on" by "correct"..? (English is not my first lang)
05:40:03 <dminuoso> jsomedon: Yes.
05:40:08 <jsomedon> haha ok
05:41:06 <jsomedon> so how do I write GADTSyntax in haskell code? I see you have this {-# LANGUAGE GADTSyntax#-}, so I just need to put this line and I am good to go?
05:41:30 <dminuoso> jsomedon: Yup. And if you are nice, you'd add a space after the `x` that I missed. :-p
05:41:57 <jsomedon> you mean {... GADTSyntax #-}
05:42:01 <dminuoso> jsomedon: Yeah. :-P
05:42:08 <jsomedon> ah ok
05:42:24 <dminuoso> jsomedon: {-# LANGUAGE ... #-} is how you enable language extensions
05:42:36 <dminuoso> jsomedon: The extension is scoped to the module you are writing in.
05:42:40 <jsomedon> I should probably fork your gist in case I forgot the syntax
05:42:51 <dminuoso> jsomedon: Or you can just refer to the GHC manual.
05:43:02 <dminuoso> jsomedon: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=gadt#extension-GADTSyntax
05:43:12 <jsomedon> ah that's nice!
05:43:34 <jsomedon> wodner why this didn show up when I google GADTSyntax
05:44:17 <dminuoso> jsomedon: GADTSyntax is seldomly used, GADTs otoh are commonly used.
05:44:17 <merijn> jsomedon: The GHC user guide is *very* good, yet somehow rarely shows up on google
05:44:31 <merijn> dminuoso: Well.. "common"
05:44:39 <dminuoso> merijn: Heh fair.
05:44:44 <dminuoso> merijn: In comparison at least.
05:45:40 <dminuoso> merijn: And wow, reading that manual I just realized that GADTSyntax might not be so useless!
05:50:32 <Ariakenom> dminuoso: yeah those constructor constraints look useful
05:51:14 <fen> if 2 datatypes, eg Nat === [()] and Something === [SomethingElse] 
05:51:26 <fen> then they have "add" like (++) of list
05:52:04 <fen> except, you would rather write data Nat = Z | S Nat, and similarly for Something = expand SomethingElse here
05:52:14 <merijn> Ariakenom: That's just existential quantification, though...
05:52:59 <fen> is there a way to reuse like (++) for the various list versions of these datatypes, some implementation of Add, but over the version not using List
05:53:00 <fen> ?
05:56:54 <heebo> is hackage down>?
05:57:46 <optmzr> heebo: yep
05:58:38 <heebo> is anyone trying to fix it?
05:59:05 <MarcelineVQ> yep
05:59:17 <heebo> oh cool :-)
05:59:20 <MarcelineVQ> :>
05:59:41 <fen> is it better to write Nat in terms of List or with the direct recursive implementation?
06:01:02 <Ariakenom> data Set a = Hash a => HashSet a | Ord a => OrdSet a | Eq a => EqSet a
06:01:34 <tabaqui> err, Hackage is down
06:01:56 <fen> seems like unless you can transfer the implementation written for list, then you could end up with a new recrsive datatype for any possible type a list could contain, where the definition of that contained datatype is combined with that of list to make it a recursive thing
06:02:12 <fen> and that this would have all the list functions needing to be redefined for it
06:02:56 <lunabo> fen: although when would you ever use most list functions on a [()] ?
06:03:29 <lunabo> fen: for instance drop is not very interesting imo
06:04:29 <fen> thats (-)
06:05:56 <fen> lunabo: you just mean the ones that have a forall for the contents type?
06:06:01 <dminuoso> What do you folks use for CI for your haskell programs? We're currently using gitlab-runner, using a docker executor building our programs with cabal new-*, extract build artifacts and then deloy the binaries directly.
06:06:10 <dminuoso> Curious what alternatives people here might have as ideas.
06:06:15 <lunabo> fen: yeah think so
06:06:24 <MarcelineVQ> fen: what you're searching for at the moment is called Generics. you write your functions once over some certain very generic types and classes, ghc is able to derive instances of these things for you
06:06:28 <MarcelineVQ> https://wiki.haskell.org/GHC.Generics#Representation_types
06:06:29 <lunabo> fen: and drop is a weird version of - since it doesn't take two [()]
06:06:55 <fen> yeah it does
06:07:03 <fen> it wouldnt work with negative ints anyway
06:07:30 <fen> MarcelineVQ: really?
06:07:38 <lunabo> well I meant that drop takes an Int and a list, and an Int is not actually a [()]
06:07:51 <fen> its not like its using a generic version of cons
06:08:29 <fen> lunabo: it does not use an Int and a List, but a Nat and a list, and Nats are [()]
06:08:50 <fen> drop :: [()] -> [a] -> [a]
06:09:14 <fen> so (-) :: Nat -> Nat -> Nat; (-) = drop
06:10:48 <fr33domlover> Is hackage down? I keep getting 502
06:10:50 <lunabo> fen: sure, but your aim is to use list functions like ++ from [()] to get addition, instead of giving recursive definition of Nat and implementing + on that?
06:11:15 <fen> MarcelineVQ: isnt that just for saying that 2 equivlent implementations of List can be made isomorphic via a generic version, by identifying the constructors with the generic sum constructor... what er have here instead is a restriction over the contents type, and a flattening of the list and contents type definitions
06:11:49 <fen> lunabo: yes
06:12:27 <_ceb> fr33domlover, I got 503
06:12:52 <_ceb> So it appears to be down
06:13:36 <fen> cabal still works tho
06:14:30 <chidy> Hi
06:14:36 <fen> lunabo: right, so (++) of list is (+) of Nat, or any other thing like [Bool] or whatever, and drop is (-)
06:15:16 <chidy> There was an old conversation which was on hpaste that I frequently referred to but can no longer access hpaste
06:15:24 <fen> data Nat2 = True Nat2 | False Nat2
06:15:29 <chidy> It has to do with category theory
06:15:45 <lunabo> chidy: well that narrows it down :)
06:16:35 <chidy> The previous link was here hpaste.org/71939
06:16:45 <fen> hows that going to help!?
06:16:50 <fr33domlover> dminuoso, I don't use CI so far but one thing that comes to mind is the sr.ht build service
06:16:57 <jsomedon> is :t a function? I tried :t :t and it throws error
06:17:11 <heebo> what webserver does hackage use?
06:17:17 <dramforever__> jsomedon, It's a special GHCi command
06:17:22 <chidy> Was wondering if anyone knew what happened to hpaste 
06:17:26 <lunabo> fen: either way, both the [()] and recursive representations of Nat are terribly in terms of memory usage and performance so I imagine you'd only want to do it if they are type-level only and are erased at runtime
06:17:28 <jsomedon> dramforever__: ah ok
06:17:30 <dramforever__> You can check :help in GHci
06:17:37 <heebo> wow is hpaste down too?
06:17:38 <fen> so we could write things like Nat for any thing that could be contained in a list... and would have to write (+) and (-) again...
06:18:07 <chidy> Nope, it asks for a login now which it never did last I used it anyway
06:18:17 <fen> lunabo: actually this was for a type level list of a 3 choice type
06:18:36 <fen> but isnt the memory usage ok compared to Int?
06:18:49 <fen> like, it factors the numbers defined using (*)
06:19:05 <fen> so it fuses down to the unfolding of the [()]
06:19:09 <lunabo> fen: well it's a unary representation so it's exponentially larger I think
06:19:19 <fen> eg n*m is just replicate n (replicate m ())
06:19:35 <fen> so you would cach the unfolding of m into [()]
06:20:05 <fen> and then the (++) and folding over it as opposed to repeatedly decrimenting a large number, would reuse the cached representation
06:20:49 <fen> so its faster than Int?
06:20:59 <fen> for use for something like a for loop i
06:21:16 <fen> as long as that i is never used explicitly
06:21:25 <fen> just to count the number of itterations
06:22:25 <fen> guess a benchmark would be in order, but anyway, not totally convinced its a worse representation
06:22:31 <lunabo> fen: hmm yeah maybe due to laziness it would be a bit different from a strict unary representation
06:22:40 <fen> but can see that its more memory intensive, but maybe with reduced computation
06:22:45 <fen> that could be a useful trade off
06:24:59 <fen> but anyway, type Nat = [()] has this extra () that the normal way. which combines this with the list datatype definition
06:25:09 <fen> it seems worse in this resepect
06:25:31 <fen> is there no way to solve this?
06:25:42 <fen> not sure how generics is the right way
06:26:05 <fen> like, another way would be preferred 
06:26:51 <fen> its not just like Generics for use when the user has given a custom name to a sum or product constructor is it?
06:27:21 <fen> its more with direct relation between a parametrised type and its flattened definition when combined with that of the parameter
06:29:26 <fen> so I just use the list version then!?
06:32:04 <fen> at least that would obviously fuse down the state which unfolded it. but thought there was a way to do that also for the N = Z | S N version
06:39:53 <adamCS> Anyone got any experience using the -dinline-check on ghc?  I can get reports about ordinary functions but I'm not sure how to get it to give a report about a class method...
07:10:09 <dminuoso> So I started using STM in production, proud how I cant have race conditions anymore. Now I have spurious "thread indefinitely blocked in an stm transaction" errors.
07:12:00 <Cale> It's interesting that it can detect that
07:12:17 <MarcelineVQ> it's got queues of subscribers and such, it's neat stuff
07:13:01 <dminuoso> Cale: Well, to be fair in a mutex heavy world you'd have "deadlock" errors too if you are lucky.
07:13:29 <Cale> I understand how the corresponding error works for MVar
07:13:53 <Ariakenom> if I recall correctly, when you GC a queue you throw exceptions to those waiting on the queue.
07:14:00 <dminuoso> As far as I understand it, when GHC claims all references to an MVar that is being retry'd on then that error can be thrown?
07:14:04 <dminuoso> *that is the GHC GH
07:14:05 <dminuoso> GC even!
07:14:18 <Ariakenom> and waiters don't keep it alive
07:14:32 <dminuoso> Ariakenom: Keep it alive in the sense of writing to it up to the retry point?
07:14:55 <dminuoso> I somehow wish GHC could tell me which MVar this was.
07:15:07 <Ariakenom> keep it alive in the sense of GC and weak references
07:15:17 <dminuoso> Im using STM in various places, and the race condition doesnt seem to trigger when I have my debug mode on - so I'm a bit lost on how to debug this.
07:15:35 <Cale> I guess if an STM transaction retries, and then everything that it read up to the point of the retry is garbage collected, then you can get this error.
07:16:02 <dminuoso> Cale: Wouldn't even a single claimed reference be enough?
07:19:04 <Cale> dminuoso: hmm, perhaps!
07:19:22 <Ariakenom> one sounds correct
07:19:26 <Cale> dminuoso: Well, wait
07:19:59 <dminuoso> My phrasing was a bit careless: a single xvar.
07:20:02 <c_wraith> are you using check, or something?
07:20:05 <dminuoso> (with all references claimed)
07:20:21 <dminuoso> Where xvar is meant to refer to either mvar or tvar.
07:20:35 <c_wraith> a tvar and an mvar are very different.
07:20:36 <Ariakenom> wait, it can't be 1 due to orElse, I think
07:20:46 <c_wraith> a tvar always contains a value
07:20:47 <Cale> The things won't actually be GCed, because our transaction is hanging on to them, but if no references to them exist elsewhere, then they can't change, so our thread will never wake up.
07:21:01 <Cale> Our thread wakes up if any one of those things that it read changes
07:21:12 <dminuoso> c_wraith: when talking about tvar then it could be a guard on it
07:21:48 <Ariakenom> readQueue a `orElse` readQueue b
07:22:13 <Ariakenom> both a and b need to be dead to block indefinitely
07:22:34 <dminuoso> I need to understand how `async` interacts with these mvar/stm exceptions, but sadly hackage is down and google doesn't appear to be caching it..
07:22:59 <Ariakenom> dminuoso: https://www.stackage.org/lts-13.15/hoogle?q=async
07:23:00 <c_wraith> Cale, yes. it has to detect something along the lines of "all threads that reference this these tvars are blocked waiting for an update to one of these tvars"
07:23:08 <dminuoso> Ariakenom: Ohh stackage! Thank you for the reminder.
07:23:20 <c_wraith> err. reference *one of these *
07:24:03 <dminuoso> Ariakenom: I guess <|> weakens it then. 
07:24:34 <dminuoso> Ariakenom: Outside of <|> it would be a single tvar though.
07:25:04 <Cale> c_wraith: Ah, that's an even fancier version than I was thinking of, but yes.
07:25:14 <dminuoso> At any rate, my best guess is that some thread is silently crashing.
07:25:37 <c_wraith> Cale, I think it needs to be that fancy to be correct
07:26:24 <Cale> c_wraith: It could simply fail to catch the case where another thread was hanging on to a TVar, but was blocked on a subset of the TVars we are.
07:26:49 <Cale> and only look for the case where there aren't any references left on other threads
07:26:50 <dminuoso> 16:20:14        c_wraith | a tvar and an mvar are very different.
07:27:15 <dminuoso> c_wraith: well we do have the mechanism to work with both though. that is, we do have "indefinitely blocked on stm" and "indefinitely blocked on mvar"
07:27:30 <dminuoso> but then again I have no idea whether they use the same code inside
07:28:38 <c_wraith> the error detection logic is similar.
07:28:46 <Cale> dminuoso: Note that it's not "blocked indefinitely on TVar", but "blocked indefinitely in an STM transaction" -- no TVar operation actually blocks
07:29:00 <c_wraith> but in stm, it's at the level of the entire transaction, not a single var
07:29:02 <Ariakenom> dminuoso: silent crashing!? I wish you luck in tracking down this abomination
07:29:15 <Cale> But yeah, the error detection logic in the STM case is probably similar but necessarily more complicated than the MVar case.
07:29:24 <dminuoso> Ariakenom: Lets say I have some rather liberal uses of async, always pretending that haskell code cant possibly have errors.
07:29:35 <dminuoso> Because my programs type check, you kno.
07:29:43 <dminuoso> :/
07:29:45 <c_wraith> in both cases the logic requires deep gc integration, so it's probably in the same place
07:30:33 <dminuoso> Cale: Mmm yeah. The reasons should be similar though, no?
07:30:41 <Cale> STM only makes concurrency about 10 times easier. It doesn't actually make it easy ;)
07:30:47 <Ariakenom> dminuoso: of course, you must've forgot to turn off DeferTypeErrors
07:31:18 <Cale> dminuoso: Similar, though potentially involving several TVars or other STM-related values.
07:32:50 <Cale> dminuoso: Since the only case where we'd actually want it to give up like that is if nothing can wake up the thread, and any write to a TVar that it read along the way to a retry will cause it to wake up.
07:33:03 <adamCS> Figured out my last thing (-dinline-check and class dictionaries) and am now stuck on a loop-breaker issue.  Something I would really like inlined is being called only from a function marked as a loop breaker.  So it's not even considered for inlining.  I know ghc has a good reason.  But it's happening in a place that very similar to a place where no loop breaker at all was required.  Any ideas for how to figure out why?  
07:35:06 <dminuoso> Cale: Do you have any suggestions on how to locate the source? Are there comparable tools like helgrind that can locate potential errors?
07:35:38 <Cale> Do you have any idea which thread it is that's dying?
07:36:09 <Cale> There's threadscope, maybe it could help.
07:36:55 <c_wraith> can't you install a global handler for exceptions that kill threads, to at least log when that happens?
07:37:37 <dminuoso> c_wraith: Something tells me I didnt consider async exceptions well enough.
07:38:50 <Cale> dminuoso: Where do you kill threads?
07:38:56 <Cale> (do you kill threads?)
08:16:18 <asheshambasta> Hackage is down; anyone knows of any ETA on when it can be back online? 
08:16:32 * hc recommends to use the stackage hackage in the meantime
08:16:56 <hc> https://www.stackage.org/nightly-2019-04-04
08:17:43 <asheshambasta> allright; thanks. 
08:20:04 <fen> adamCS: whats this about Inlining and loop breaking?
08:23:14 <delYsid> Is there a way to intersperse a list every two elements?  like i2 0 [1,2,3,4] = [0,1,2,0,3,4] ?
08:25:29 <Solonarv> I'd probably start with chunksOf
08:26:03 <Solonarv> @let i2 x = concatMap (x:) . chunksOf 2
08:26:04 <lambdabot>  Defined.
08:26:16 <Solonarv> > i2 0 [1,2,3,4]
08:26:18 <lambdabot>  [0,1,2,0,3,4]
08:26:22 <Solonarv> \o/
08:26:47 <Solonarv> delYsid: that work for you? :D
08:27:02 <delYsid> cool!
08:27:11 <Solonarv> ('chunksOf' can be found in extra:Data.List.Extra or split:Data.List.Split IIRC)
08:27:15 <fen> wouldnt that be like, unfolding the list via uncons, and zipping this state with another that was a counter, like turning a nat into a state of () 
08:27:29 <mpickering> adamCS: post the core
08:27:36 <mpickering> using the dump-core plugin if you can
08:27:55 <Solonarv> there's a dump-core plugin? what's it do?
08:28:09 <fen> adamCS: is that a kind of "shortcut" recursion scheme thing?
08:28:15 <fen> cant remember which one that is
08:28:58 <fen> like, for folding over just the first section and not bothering to fold over the tail
08:29:37 <fen> and what does it mean about inlining wrt to loop breaking
08:30:29 <fen> is that anything like trying to fuse to the state over the initial folded section?
08:30:35 <fen> does that make sense?
08:32:51 <fen> Solonarv: what if you want the next chunk to be the length of the sum of the previous chunk?
08:33:23 <Solonarv> I'd probably grumble and write my own chunking function
08:33:44 <Solonarv> fortunately here my (or really, delYsid's) need is satisfied by an existing function
08:34:42 <fen> but if you wrote that chunking function as an unfold it would be more easily addapted to these more complex cases?
08:36:08 <fen> as well as being able to fuse down to the original state which unfolded the list being chunked
08:37:11 <fen> actually that should work anyway if cunks of is written using fold and some emulation of the zipWith nat state
08:37:25 <Solonarv> yes, I would assume they already fuse anyway
08:38:26 <fen> then how to addapt the existing implementation so that the fold is replaced with a histomorphism?
08:41:34 <dexterfoo> Is hackage down?
08:42:20 <Solonarv> dexterfoo: yep
08:42:27 <Solonarv> status.haskell.org
08:42:37 <Solonarv> there are mirrors though
08:42:46 <fen_> https://www.stackage.org/haddock/nightly-2019-04-04/split-0.2.3.3/src/Data.List.Split.Internals.html#chunksOf
08:42:53 <fen_> it doesnt even use fold! 
08:43:48 <fen_> at least it uses build tho...
08:44:00 <Solonarv> it uses its own definition of build, actually
08:44:11 <dminuoso> It might be useful if an operator included a notice in the topic that haskell is down, and that the status can be monitored at https://status.haskell.org/ ...
08:44:22 <Solonarv> "This is in line with @split@'s design philosophy of having efficiency as a non-goal."
08:44:29 <dminuoso> That way we could just refer people to the topic at worst.
08:44:50 <MarcelineVQ> hoho, people don't read topics :>
08:45:02 <Solonarv> could add some info about mirrors too 
08:45:08 <Solonarv> yeah, but they do if we say "see topic"
08:45:54 <fen_> :(
08:46:01 <Clint> i'm reading the topic right now
08:46:24 <Solonarv> it hasn't been edited with info about thehackage downtime yet ;)
08:46:26 <MarcelineVQ> how would you feel if it aleady had the hackage info in it
08:47:20 <adamCS> fen: Just my same puzzle.  I have an unfold of a fold which is faster than an unfold of a paramorphism though the paramorphism is functionally identical to the fold in that it ignores the extra info.  I've been looking at the core and maybe something is happening with the inlining.  When ghc inlines recursive functions it has to do something to avoid inlining forever.  So it chooses one piece to be a "loop-breaker" and
08:47:20 <adamCS>  refuses to inline that.  I've way oversimplified/mis-explained that.
08:47:36 <Solonarv> see this reddit post for some info: https://redd.it/b99cef
08:47:45 <Solonarv> (on the hackage downtime, I mean)
08:48:01 <fen_> adamCS: can you break that down for those less familiar with the terminology?
08:48:29 <Solonarv> TL;DR: can't inline recursive fuctions because otherwise the inliner might loop forever
08:48:39 <adamCS> right
08:48:55 <Solonarv> if you have a set of mutually recursive fuctions then some set of them is chosen and marked as "never inline"
08:48:56 <fen_> so is there a confusion here with loop breaker and paramorphism?
08:49:02 <adamCS> but actually, ghc can inline them!  But has to pick a small bit not to inline
08:49:16 <fen_> as one is a fold which exits early, and so is like escaping a loop
08:49:24 <fen_> but has nothing to do with a loop breaker?
08:49:35 <adamCS> fen_: No.  paramorphism isn't the one that exits early.  That's apomorphism.
08:49:42 <Solonarv> the "loop breaker" here is talking aboutGHC's inliner looping forever
08:49:43 <fen_> ohhh
08:49:54 <fen_> ok, well that clears up that confusion
08:50:02 <fen_> but then what about loop breaking and paramorphisms?
08:50:37 <fen_> thats the one that retains the previously folded values?
08:51:28 <Taneb> Trying to do it the obvious but ugly way gives me "Too many heap sections: Increase MAXHINCR or MAX_HEAP_SECTS"
08:51:38 <Taneb> Didn't mean to send that, sorry
08:51:42 <fen_> so your issue is having implemented a catamorphism using a paramorphism and the inliner treating these differently?
08:52:28 <adamCS> Right.  I've got two--should be identical--unfolds of folds, all using recursion-schemes.  One is literally that, an unfold of a fold and criterion says it takes 35 ms to do a groupBy on my list.  Compare that to 13 ms for Map.toList . Map.fromListWith (<>).  Then I implement the same thing with the recursion schemes paramorphism.  And I ignore the extra info. So it should be the same.  But it takes 90 ms.  And I am puzzled.
08:52:57 <adamCS> It might be the inliner.  Might be something else.  I am having trouble pinning it down.
08:53:01 <fen_> ahh
08:53:25 <fen_> did you manage to gather the core?
08:53:34 <fen_> and or could paste the code?
08:54:39 <fen_> you think maybe its being strict about retaining the previous values? so that despite not accessing them they are assigned in memory?
08:55:58 <Cale> So uh... what's... going on... with hackage?
08:56:16 <Solonarv> it's down
08:56:20 <Solonarv> see this: https://redd.it/b99cef
08:56:23 <Cale> I kinda noticed
08:56:25 <Cale> ah
08:57:21 <Cale> So... full service disruption. Convenient.
08:57:24 <adamCS> fen_: The code is in the "map-reduce-folds" part of this repo: https://github.com/adamConnerSax/Frames-utils
08:57:37 <Welkin> hackage still down?
08:58:14 <Solonarv> seems so
08:58:22 <adamCS> fen_: the groupBy functions are all in "src/Control/MapReduce/Engines/GroupBy.hs" and the benchmarking code is in bench/GroupBy.hs
08:58:43 <Welkin> why is it hosted on rackspace anyway?
08:58:56 <Taneb> Welkin: until recently they were hosting it for free
08:59:08 <adamCS> fen_: and the cabal is setup to output core.  Though that output is hard to find!
08:59:19 <Welkin> move to a dedicated server
08:59:24 <Solonarv> which is a pretty good reason, especially for a FOSS project
08:59:27 <Welkin> no more dumb vps issues
08:59:41 <Solonarv> ah yes because dedicated servers never have any issues
08:59:50 <Solonarv> this is why everyone uses them all the time, of course
08:59:51 <Welkin> far less than a vps
09:00:05 <fen_> ipfs?
09:00:24 <Welkin> hackage should be mirrore in several places
09:00:27 <Welkin> mirrored*
09:00:44 <Solonarv> it is
09:00:44 <Welkin> how does nix do it?
09:00:53 <Welkin> it is?
09:01:01 <Cale> Yeah, presumably cabal install can still get stuff
09:01:04 <Solonarv> yes - see https://redd.it/b99cef
09:01:13 <Cale> It's just that the documentation and everything is inaccessible
09:01:15 <srk> nix can use cached stuff from hydra
09:01:19 <Solonarv> a default setup of cabal-install will flawlessly fall back to the mirrors
09:01:26 <srk> (or cache.nixos.org)
09:01:30 <srk> even sources
09:02:02 <Solonarv> actually, there's a comment in the thread I linked stating that nixpkgs doesn't include mirrors
09:02:16 <srk> any idea how much RAM does hackage need currently?
09:02:26 <Solonarv> so I guess you'll have to configure them manually if you're using nix and the stuff you need isn't in a cache
09:02:42 <srk> Solonarv: no need to when all the stuff is cached on CI
09:03:22 <srk> it's like a mirror for all ecosystems, except for nonfree things
09:03:22 <Solonarv> well, the comment mentions having issues in CI builds... so apparently that isn't true
09:03:45 <Solonarv> no further details though, and I have only superficial knowledge of nix anyway
09:05:00 <fen_> whats this? https://github.com/davidar/hs-ipfs-api/blob/master/src/Network/IPFS/API.hs
09:05:04 <srk> things that need to query hackage could fail, yes
09:05:32 <Solonarv> also, if you want to browse haddocks you might find them on stackage.org
09:05:43 <dminuoso> suzu: I can think of a way to have a Pointed Functor without having an Applicative instance, I think.
09:07:38 <Welkin> like this? <:D
09:08:58 <Solonarv> dminuoso: oh?
09:09:41 <Solonarv> easy example: Set
09:09:53 <Taneb> Solonarv: not a functor
09:09:54 <Solonarv> although I'm not sure if that *should* have an instance...
09:10:10 <Taneb> The example I can think of is "Coyoneda Set"
09:10:11 <Solonarv> oh I misread the original message
09:10:25 <Solonarv> oh, that might work
09:10:47 <Taneb> But Pointed could be anything...
09:10:49 <dminuoso> Im toying around with recursive types and existentials, and it seems there's plenty
09:11:11 <Solonarv> there are also instances for (,)/Const/Writer which use a Default constraint instead of Monoid, but I'm not sure if they should count...
09:11:35 <fen_> does Nix make it safe to run cloud server kernals from home for distributed hosting?
09:11:39 <dminuoso> Solonarv: The examples are bad because you could always encode it by imposing a trivial monoid like First.
09:11:58 <dminuoso> Oh wait. Thats not Monoid.
09:11:59 <dminuoso> Mmm.
09:12:14 <Solonarv> well, there are two Firsts
09:12:42 <Solonarv> one in Data.Monoid (which is a monoid, and wraps Maybe); and one in Data.Semigroup, which isn't a monoid
09:12:58 <Solonarv> (and just has (<>) = const)
09:13:31 <dminuoso> What Im thinking about is this
09:16:12 <fen_> does haskell have any tools to secure a server?
09:16:40 <fen_> or is that all down to the OS?
09:16:44 <Solonarv> depends, what do you mean by "secure a server"?
09:16:49 <dminuoso> Perhaps I was wrong after all. In particular the First semigroup seems to give a nice backdoor.
09:17:18 <fen_> Solonarv: not if it doesnt have any!
09:17:28 <dminuoso> Taneb: Why would Coyoneda Set not give an applicative?
09:18:21 <fen_> well, like if there was a haskell OS it would have a firewall right? so there should be a haskell package for that?
09:18:29 <fen_> or bindings or something... right?
09:18:30 <Taneb> dminuoso: it uses the underlying Applicative of f, which doesn't exist for Set
09:19:00 <dminuoso> Taneb: Im not convinced that Set is a good example. The reasons why Set doesn't have Functor/Applicative appear to rather strange.
09:19:15 <fen_> might could be issues to do with a FOSS firewall?
09:19:19 <dminuoso> Taneb: I mean the Ord condition could, in spirit, be lifted. No?
09:19:23 <Solonarv> no, FOSS firewalls are fine
09:19:32 <Solonarv> aFAIK there is no such thing as a Haskell OS
09:19:40 <fen_> or a haskell firewall?
09:20:03 <Taneb> dminuoso: no, Set relies and exposes the order
09:20:04 <fen_> wasnt there something that ran baremetal on Xen? 
09:20:23 <Solonarv> A firewall written in Haskell might exist but that doesn't mean you should use it
09:20:35 <Solonarv> Software isn't automatically better just because it's written in Haskell
09:20:41 <fen_> ah, it was this; https://github.com/GaloisInc/HaLVM
09:20:55 <fen_> Solonarv: no but it does mean I can read it
09:21:23 <dminuoso> Taneb: Ah so something like `fmap negate` would change its structure. :|
09:21:36 <fen_> which arguably is a priority for avoiding faux commits...
09:21:53 <Chousuke> fen_: If you ran a Haskell unikernel thing, you wouldn't need a firewall because your unikernel would simply not respond to any networks requests it isn't supposed to respond to
09:21:58 <fen_> for something as key to security as server security and kernels and stuff
09:22:01 <Chousuke> network*
09:22:31 <Chousuke> a firewall isn't a thing that makes things secure, it's just a tool to limit network traffic, which can help with security, but that isn't guaranteed.
09:22:39 <Solonarv> it's often considered fine if typeclass laws only hold "up to observation"
09:22:50 <Solonarv> of course what you count as "observation" is another matter...
09:23:01 <dminuoso> Taneb: I guess ultimately a Functor instance could exist, if we widened the notion of Functor to allow for different domains than Hask (e.g. Ord)
09:23:02 <fen_> wouldnt it need to be able to zap rogue spyware and stuff that downloaded itself via a bug in some part of the FOSS build tools?
09:23:13 <Solonarv> that's not what a firewall does
09:23:25 <fen_> yeah, but server security in general
09:23:38 <fen_> just thought of firewall as a pretty obvious component
09:23:53 <fen_> not idea what is the stadard for a sufficiently secure server
09:23:57 <Chousuke> fen_: again, if you ran a Haskell unikernel server, there probably wouldn't be anything for the malware to download itself *to* :)
09:24:54 <Solonarv> ah, the good old "use an obscure OS so generic malware can't run on your system" approach ;)
09:25:11 <fen_> but if it was for, say hosting hackage on the cloud where individuals ran nodes, then whatever kernal existed, it would still be on an home computing system which could be vulnerable
09:25:38 <fen_> would it mean totally stripping the hardware down to running just a really secure and minimal stack of build tools
09:26:01 <Chousuke> that's not really a useful way of thinking about security I think
09:26:17 <Chousuke> security is a function of your resources vs. your opponent's resources
09:26:54 <Chousuke> if your opponent has more resources than they need to break your security, you don't have a secure enough system :P
09:26:58 <Chousuke> if they don't, you're fine.
09:27:24 <siraben> I get this error message when trying to generate documentation with Haddock: http://ix.io/1Fjs
09:27:30 <Chousuke> in the vast majority of cases, you get adequate security with not all that many resources if you know what you're doing.
09:27:48 <fen_> the only point is that if we wanted to contribute to hosting hackage in a distributed way, could we be sure that this wouldnt increase the users vulnerability?
09:27:50 <siraben> But I can't find a way to do what the error messages says to do, which is run ":set -package parsec"
09:28:29 <Solonarv> siraben: how are you invoking haddock?
09:28:53 <codebam> how can I install this package? when I try to install it with cabal like they say in the docs I get this error: https://pb.j29eleven.org/gtYj
09:29:00 <siraben> Solonarv:   haddock src/* --html --package-name=r5rs-denot -o docs
09:29:05 <codebam> this package https://github.com/kbonne/pandoc-plantuml-filter
09:29:19 <Chousuke> cryptographically signed packages can be mirrored by anyone and as long as your downloading software has no vulnerabilities and you actually verify the signatures, you don't need to trust the host doing the mirroring.
09:29:27 <fen_> depending on if the user was a public institution or not they might have different requirements, so offering secure tools and reasureance would be essential to the success of a user based cloud hosting of any part of the haskell ecosystem
09:29:28 <Chousuke> but this is getting off-topic, so I'll stop now 
09:29:37 <Solonarv> siraben: try invoking it through stack/cabal (whichever one you're using)? they should handle making the dependencies visible
09:29:38 <glguy> codebam: Your version of GHC is newer than the package supports
09:29:52 <glguy> codebam: You can see this by the conflict on the base version (which is fixed to GHC version): rejecting: base-4.10.1.0/installed-4.1... (conflict: pandoc-plantuml-filter =>
09:29:58 <siraben> Also, is anyone else getting a bad gateway for https://hackage.haskell.org/package/containers/docs/Data-Sequence.html ?
09:29:58 <Solonarv> Chousuke: so basically, IPFS ;) (at least, ideally)
09:30:06 <Solonarv> siraben: yes, hackage is down
09:30:19 <siraben> Solonarv:  I'm using cabal
09:30:32 <fen_> as long as there is no bug in your openssl...
09:30:35 <Solonarv> https://redd.it/b99cef - siraben, info about hackage downtime
09:30:44 <Chousuke> fen_: consider bittorrent. It's basically user-based cloud hosting
09:31:03 <codebam> glguy: can I fix this? I just want the binary, I don't really care about compiling it
09:31:08 <siraben> That's unfortunate.  How are people getting around it?
09:31:08 <codebam> or recompiling it I mean
09:31:08 <siraben> Nix's mirrors are still up
09:31:18 <codebam> I just need it as a pandoc filter really
09:31:46 <glguy> codebam: You could change the base version constraint in the .cabal file and see if it works with your current version of base
09:33:02 <fen_> Chousuke: whatever standard it implemented it would still use our basic server infrastructure, conduit etc. some users might have issues with opening up their ports to unmoitered traffic so was just wondering what tools we have that can kind of make sure nothing untoward is taking place on the ports we might open up
09:33:16 <fen_> so basically, haskell firewall tools
09:33:55 <codebam> glguy: okay, I'll try that
09:33:57 <codebam> thank you
09:34:21 <Solonarv_> siraben: should just be 'cabal v1-haddock' (if using old-style build) or 'cabal v2-haddock' (if using new-style build)
09:34:22 <fen_> and its not so much off-topic if its a general question about the utility of haskell server infrastructure in the absence of peripheral security packages. for instance some of the eliptic curve stuff still uses FFI
09:34:44 <Chousuke> fen_: I guess there might be something, but they would be largely irrelevant to the security of Haskell programs themselves.
09:35:28 <Solonarv_> fen_: the thing about implementing crypto in Haskell is that it's very hard to reason precisely about things like memory use and execution time, which is needed to rule out side channel attacks
09:35:33 <fen_> not considering a hacked compiler at this point... just the users ability to contribute to hosting 
09:35:50 <Welkin> your hardware is compromised
09:35:58 <Welkin> the software doesn't matter at that point
09:36:00 <fen_> Solonarv_ ahh, good point
09:36:06 <Welkin> intel Management Engine
09:36:11 <Solonarv_> if it's just about hosting a static blob of files ipfs or similar should be good enough
09:36:18 <siraben> Solonarv_:  thanks, that works.
09:37:18 <fen_> Welkin: thats a totally defeatist attitude, and even if it was, it would still be worth developing the rest of the toolchain to be as secure as possible 
09:37:34 <Welkin> it's realistic, not defeatist
09:37:35 <Solonarv_> distributing hackage's build/CI system across users is much harder
09:37:39 <Welkin> go to the root of the problem and fix it
09:37:43 <Welkin> don't pretend it doesn't exist
09:37:45 <Solonarv_> partly because it can't really be parallelized
09:38:16 <fen_> Welkin: your picking the hardest thing for this community to address and using its complexity as justification for not addressing things we actually can
09:38:16 <Solonarv_> if a new version of e.g. lens is uploaded to hackage then it has to be built all on one machine, and that's a significant performance impact
09:38:19 <codebam> glguy: when I did that I now get this error? https://pb.j29eleven.org/5a-C
09:38:25 <dyl> I’m trying to remember where I heard about using unsafe coercion + knowledge of GHCs memory representation of something.
09:38:39 <dyl> There was a relatively common thing (in a library) where it was an implementation detail.
09:38:46 <dyl> Does this ring any bells?
09:38:51 <Solonarv_> dyl: those are Dark Arts! we use 'coerce' for that now! :P
09:38:53 <codebam> what does that mean
09:39:04 <dyl> Solonarv_: I know I know, I’m trying to remember where it was used though.
09:39:11 <Solonarv_> I don't know about "relatively common" but it's how 'reflection' is implemented
09:39:17 <dyl> That was it! 
09:39:17 <Cale> Welkin: Well, there's still a layer of abstraction in between
09:39:34 <codebam> I don't understand these errors
09:40:40 <dyl> Though I recall there being another case of it Solonarv_, I am also remembering the representation of type classes... 
09:41:07 <Solonarv_> the details are the following:
09:41:07 <Solonarv_> 'ClassConstraint => foo' has the same repr. as 'ClassConstraintDict -> foo'
09:41:07 <Solonarv_> for a single-method 'class Foo where bar :: T', the instance dictionary for Foo has the same repr. as T
09:41:08 <dyl> And typeclass dictionaries in general, particularly single function type classes. 
09:41:12 <fen_> at some point your going to have to assume whatever your building on is secure, and then the task is just to propagate certainty about this further down, using tools that can check parts further up are working as expected assuming things further down are
09:41:14 <dyl> Yes, that was it.
09:41:31 <fen_> pretty abstract but thats a way of thinking about it anyway
09:41:40 <Solonarv_> fen_: have you heard of the Ken Thompson hack?
09:42:13 <dminuoso> Solonarv_: Hah, reminds me of how GHC thought of nothing when they used unsafeCoerce for GND - until edge cases started popping up producing curious crashes.
09:42:37 <Solonarv_> TL;DR "what if something was snuck into your compiler that adds a backdoor into your program"
09:42:57 <dyl> fen_: And when not possible, crash fast and crash hard. Then let the trusted process above take care of reinitializing the child process.
09:43:02 * dyl [Erlang intensifies]
09:43:03 <fen_> http://wiki.c2.com/?TheKenThompsonHack
09:43:07 <fen_> scary!
09:43:11 <__monty__> codebam: It's complaining about the versions of template-haskell available. They're too old because your GHC is too old.
09:43:23 <codebam> oh, so I need to update ghc
09:43:27 <codebam> so this is a fedora problem
09:43:29 <Solonarv_> ...and also inserts itself into the compiler if you recompile it using itself, and also inserts a hack into your hex editor to hide itself when you check the binary, and...
09:43:36 <codebam> thank you __monty__ 
09:43:40 <codebam> going to update ghc
09:43:54 <dyl> Solonarv_: there is a flaw in the trusting trust argument when you go that deep.
09:43:55 <dminuoso> codebam: You might want to consider just hand unpacking GHC bindists.
09:43:59 <fen_> right, thats basically what we imagine when we have total lack of trust for the tools we have for checking for the existence of a hack
09:43:59 <__monty__> codebam: Yes, *or* an older pandoc-types that works with your GHC.
09:44:13 <codebam> dminuoso: what does that mean?
09:44:13 <Solonarv_> it's a race of Halting Problem (can you anticipate all the sneakiness? no!) vs. Halting Problem (can the attacker anticipate all your checks to fool them? also no!)
09:44:14 <dyl> Namely: physical storage is physical and can be observed independently of the whole of the computer.
09:44:30 <fen_> which is why they target things like checksum verification and SSL etc
09:44:32 <dyl> Unless you’re also able to somehow violate trust in the disk controller.
09:44:40 <dminuoso> codebam: https://www.haskell.org/ghc/download_ghc_8_6_4.html#binaries
09:44:41 <Solonarv_> theoretically... ;)
09:44:46 <dyl> Which is a substantially higher bar than trusting software at the user level. 
09:44:52 <Solonarv_> oh, of course
09:45:09 <dyl> And firmware can be signed and made to _not run_ when tampered in ways that software can’t affect.
09:45:14 <Solonarv_> just shows that you can't have perfect trust unless you start out with perfect trust
09:45:22 <Chousuke> honestly, most people don't really need to worry about their hardware being malicious
09:45:26 <Solonarv_> ah, but who signed the firmware...
09:45:27 <fen_> but yeah, all you can do is propagate the boundary of certainty further based on assumptions of security you cant verify
09:45:28 <dminuoso> Chousuke: Really?
09:45:29 <Solonarv_> Chousuke: yeah, I agree
09:45:38 <Welkin> that is the attitude that gets you in trouble Chousuke 
09:45:39 <Solonarv_> largely anyway
09:45:51 <Welkin> look at spectre/meltdown
09:45:54 <dminuoso> Chousuke: Considering how easy it is from JavaScript to run rowhammer, I'd say that attack vectors from a large ocean of websites exist.
09:45:54 <Welkin> disaster
09:46:00 <Chousuke> and even if they did, *most* actual security problems are so embarassingly basic that an attacker won't have to try to exploit the hardware issues
09:46:09 <Chousuke> they can just download your stuff off a public S3 bucket
09:46:14 <dyl> For the most part, that seems correct. But that’s because most people’s threat models are not “globetrotting Infosec expert”
09:46:18 <dyl> In the end it’s all bike locks.
09:46:19 <dminuoso> Chousuke: rowhammer is a prime example of how a seemingly "high level user task" can give attackers low level hardware access.
09:46:20 <fen_> using the existence of the possibility to mistrust some low level feature is not a good argument to then just not attempt to verify anythings integrity!
09:46:22 <dyl> Or running from bears.
09:46:33 <dyl> You don’t need to be faster than a bear, just faster than the next guy.
09:46:34 <codebam> I think I had cabal but not ghc
09:46:53 <dyl> At a statistical 
09:47:01 <Chousuke> as a user, all you can really do is just keep your software up to date and try to avoid things that expose you to attackers
09:47:07 <dyl> At a population statistic level, social attacks are far more viable than physical or software ones anyhow.
09:47:15 <dminuoso> codebam: Vendor packages dont do anything, really. And by manually installing GHC into ~/ghc/8.6.4 you can easily keep multiple versions on your computer. :)
09:47:22 <Chousuke> if you get targeted you lose already, unless you have some organizational support and resources to really secure systems.
09:47:30 <dyl> ^ 
09:47:31 <dminuoso> codebam: And you can always get updates the moment they are released.
09:47:34 <fen_> Welkin: most people are not a stock market or something where these timing attacks are really critical 
09:47:37 <codebam> dminuoso: okay, I might just install using the generic installer then
09:47:38 <codebam> :)
09:47:56 <dyl> Sidebar: this seems like -offtopic or -blah conv.
09:48:01 <dyl> Someone is going to ask that we move it ;).
09:48:29 <Welkin> move it to #haskell-I-got-a-doodoo-in-my-butt
09:48:33 <fen_> Chousuke: right, so moving the low hanging fruit is definitely advantagious
09:48:42 <Ariakenom> dyl: software attacks against weak targets is effective. botnets of webcams or routers
09:49:08 <dyl> True, but those aren’t usually particularly dangerous to the infested (because they aren’t the ultimate targets).
09:49:15 <dyl> They *could* be though.
09:49:20 <dminuoso> codebam: All you have to do is just modify your PATH accordingly. I used to have shell functions to modify the `xxx` part in my `/home/dminuoso/ghc/xxx:...` PATH. It's minimally invasive, and you can trivially get rid of it all if you want. :)
09:49:26 <codebam> what's the difference between cabal and stack?
09:49:34 <codebam> dminuoso: yep I'm familiar, thank you though :)
09:49:44 <codebam> I'll just symlink it to ~/.local/bin like I usually do
09:49:45 <dminuoso> codebam: so stack uses cabal, for one.
09:49:47 <Welkin> codebam: cabal is good, stack is bad. QED.
09:49:51 <dyl> stack is like clojure’s lein. cabal is like python’s pip.
09:49:51 <codebam> oh, okay
09:50:07 <fen_> Chousuke: when you say "try to avoid things that expose you to attackers" would that include running a haskell server through a windows firewall? and if so, cant we develop tools in haskell to improve on this
09:50:07 <siraben> Why was stack made if we had cabal?
09:50:08 <codebam> or um... well might need to add the bin to path
09:50:09 <codebam> for packages
09:50:12 <codebam> anyways
09:50:23 <dyl> Stack is a more all inclusive project environment manager, which ultimately builds on cabal... and currently is broken because it parses cabal output wrong.
09:50:37 <codebam> oh, I see
09:50:41 <dyl> You should probably know both these days.
09:50:46 <dyl> Though cabal is more “essential”.
09:50:48 <Solonarv|phone> codebam: If you don't feel like futzing around with PATH and stuff yourself, there's ghcup
09:50:51 <Welkin> no you shouldn't
09:50:56 <Welkin> stack is unnecessary
09:51:04 <dminuoso> codebam: Many of the reasons you find against cabal are somewhat old since cabal has received the `new-` or `v2-` set of commands, giving us deterministic nix-style builds.
09:51:07 <codebam> Solonarv|phone: yeah was planning on using that, it will modify my path for me?
09:51:18 <Solonarv|phone> Yep
09:51:23 <Chousuke> fen_: I'm not sure why you'd write a Haskell firewall when there are perfectly good, working alternatives already though.
09:51:25 <codebam> oh awesome
09:51:32 <Solonarv|phone> Lets you have multiple ghcs easily too
09:51:41 <Welkin> we will forever be plagued with stack questions in here. My god
09:51:55 <codebam> iptables will be faster than anything you could write in haskell, it's a kernel module
09:51:59 <dminuoso> codebam: If you want a good default try `cabal` out of the box using the `new-` style commands. But if you want to give stack a try, it's great too.
09:52:04 <codebam> so it runs at the kernel level
09:52:14 <Chousuke> fen_: and again, if your Haskell server doesn't listen to ports it doesn't need to listen to, you don't need a firewall to block things, usually.
09:52:21 <dminuoso> codebam: The differences are somewhat complex, the choice is not important since you can swap between them later anyway.
09:52:27 <fen_> Chousuke: is that an argument against haskell, or against new tools in general? why use haskell, because thats what we do here! 
09:52:30 <codebam> okay, cool!
09:52:32 <codebam> thanks guys :)
09:52:57 <Chousuke> fen_: you'd usually use Haskell because you can use it to write a new tool that solves your problem better than other tools.
09:53:30 <Solonarv|phone> fen_: it's an argument against rewriting security tools when existing tools are likely better than anything you'll produce in a timely manner
09:53:37 <dminuoso> Chousuke: Or you pick Haskell because you might be more productive with it.
09:53:50 <fen_> Chousuke: its not really fair to expect the average user to understand the details of security implementations, basically they just wont help hows hackage if they suspect it might open them up to vulnerabilities 
09:53:51 <dminuoso> Chousuke: Or perhaps you can use formal methods easier verifying certain properties about your program.
09:53:55 <maerwald> productivity is hard to measure, especially when security is involved :)
09:54:03 <Solonarv|phone> (I'm blithely assuming that you're not a security expert and that good tools exist already)
09:54:16 <dminuoso> Solonarv|phone: Shouldn't you be on the phone? :<
09:54:19 <dyl> maerwald: moreover... Productivity is never truly a function of the individual. 
09:54:21 <maerwald> formal methods are better applied to low level languages
09:54:33 <dyl> It’s a function of a group. 
09:54:43 <Chousuke> Rewriting security tools is not a problem by itself, it's just difficult :P
09:54:47 <Solonarv|phone> The |phone means I'm using my (smart) phone to be on IRC ;)
09:54:57 <dyl> The n=1 case isn’t particularly interesting in general ;). 
09:55:02 <dminuoso> Solonarv|phone: Sounds like a painful exercise unless you have a Gemini.
09:55:21 <fen_> Solonarv|phone: but this is the worst logic for security concerns, as it encourages a wierd vulnerability which is to bloat things that are depended on to make them illegible "in a timely manner" so people wont find the malicious contribution 
09:55:51 <maerwald> dyl: but usually that's how people are measured these days ;)
09:56:03 <Solonarv|phone> It's a relic from when I was regularly logged in on desktop+laptop+phone at the same time (without any sort of bouncer) - anyway, off topic
09:56:49 <fen_> motivating both the use of higher order languages (for their increased legibility) and the active creation of more succinct sufficient security standards
09:57:24 <Solonarv|phone> fen_: I'm saying that you as a non-expert shouldn't expect to outperform the product of many man-decades of expert work
09:57:37 <dyl> maerwald: yes, and we also still largely assess prospective employee fitness by how much time they’ve spent practicing the CS equivalent of SAT math problems and ability to regurgitate pseudocode on a whiteboard...
09:57:48 <dyl> Just because metrics exist doesn’t mean that they, well, mean much.
09:58:06 <codebam> how can I upgrade my cabal packages?
09:59:08 <fen_> Solonarv's earlier comment was that higher order languages are vulnerable by being higher up in a chain, so having extra vulnerability in the abstraction layer. but as said before, you have to assume whats underneath is secure, and develop tools to ensure this. hence, haskell based haskell security software to help secure haskell
09:59:16 <Solonarv|phone> codebam: that's not really a thing you need to do with cabal new-style
09:59:30 <codebam> oh, okay
10:00:15 <fen_> Solonarv: yeah but you could use that logic like with fortran blas! you are not bound to use outdated tools just because you cant read them to understand if they might be better!! thats totally counterproductive, the whole idea is to verify things!
10:00:40 <Solonarv|phone> fen_: that was specifically a caution against implementing low-level crypto/arithmetic primitives in a high-level language
10:00:53 <Solonarv|phone> Encryption schemes are generally fine
10:01:29 <fen_> and my point is that tools that allow that to be done securely would be helpful, and in keeping of this idea of "pushing the horizon of security from within"
10:01:41 <Solonarv|phone> Uh, what? I never said nor meant "use outdated tools" or "don't verify tools"
10:01:58 <fen_> your saying you cant verify the level below haskell is secure
10:02:09 <fen_> im saying you should try to, using haskell
10:02:19 <maerwald> fen_: it was tried and it is vulnerable
10:03:21 <Solonarv|phone> Sure, Haskell is a fine language for most tasks that don't require precise reasoning about performance
10:03:55 <maerwald> not just performance but memory behavior and branching as well
10:04:03 <Welkin> and logic
10:04:08 <fen_> sure, like, building a taller toolchain increases the surface are of attack, but similarly, placing all security features at lower levels also has associated vulnerabilities, and all we can do is try to progress these frontiers 
10:04:23 <maerwald> fen_: that's a bit unspecific
10:04:30 <fen_> the existence of one approach does not not invalidate the other.
10:04:34 <dminuoso> codebam: With cabal new-style, you just define version constraints (or.. not if you are adventerous) on a per-package basis. cabal will then figure out the proper versions for your package  (according to the package list it has available)
10:05:04 <fen_> maerwald: sorry, summarising because the associated vulnerability of legibility that higher order languages help solve was mentioned earlier
10:05:13 <codebam> oh I mean because I'm using cabal as a user tool, to install these packages
10:05:14 <fen_> no harm reiterating that though
10:05:22 <codebam> so how I would update them when they get updated on hackage
10:05:28 <dminuoso> codebam: You wouldn't install these packages manually.
10:05:30 <Solonarv|phone> There are two separate cautions here: 1) don't implement crypto primitives in a high-level language (such as Haskell); and 2) don't expect to many experts, in any programming language
10:05:33 <dminuoso> codebam: cabal new-build automatically fetches dependencies.
10:06:06 <maerwald> codebam: cabal new-update and then cabal new-install --overwrite-policy=always
10:06:09 <maerwald> if it's about binaries
10:06:33 <fen_> are things like proof assistants no help here? seems like they have the correct sort of architecture
10:06:48 <Solonarv|phone> Sure, proof assistants help
10:06:51 <fen_> "./prove this secure" 
10:07:09 <Solonarv|phone> If only it were that simple ;)
10:07:13 <fen_> right, well thats an argument for security at a higher level
10:07:15 <maerwald> fen_: check the everest project if you want to know the state of applying functional languages (not haskell) as part of a crypto chain
10:07:36 <Solonarv|phone> Proof assistants can work on lower level languages too, though
10:07:52 <dminuoso> codebam: You can still control versions, but you no longer try to maintain a global shared pool of packages. Instead you just declare the needed packages and versions on each package, cabal new-build will then build them in a global store (for each version/configuration as needed) and them provide them to your respective packages. It does all of this transparently for you.
10:08:05 <fen_> thats even better! the idea was to prove the security of the layers you were built on
10:08:19 <Solonarv|phone> E.g. "prove that this code never accesses memory out of bounds" => boom, no more buffer overflows (in theory)
10:09:13 <fen_> would that allow you to corral off the memory so that no web based open port could write anything it shouldnt?
10:10:29 <Solonarv|phone> Probably
10:11:02 <Solonarv|phone> Although this kind of bug in the OS networking layer seems like it'd be pretty hard to miss anyway
10:11:09 <dminuoso> Ive seen a paper demonstrating how you could provably construct side-channel free (up to some degree) primitives, and then provide side-channel free code using those primitives to extract essentially provably correct and side-channel (up to the guarantees of the primitives) ocaml code.
10:11:12 <dminuoso> Bah I cant find it.
10:11:24 <dminuoso> (it was using coq)
10:11:38 <fen_> that sounds awesome!
10:11:39 <Solonarv|phone> Yeah this is much easier in a strict language :p
10:11:48 <rfold> I was thinking of a kernel of CPU that would require memory access proofs so that it wouldn't need to check page access at runtime.
10:12:13 <Solonarv|phone> If you tried to do this in Haskell you'd probably have to at least vomit ! everywhere
10:21:30 <fen_> still is there a way to compile C code to haskell and refactor it into common higher order programming patterns?
10:26:19 <Solonarv|phone> @tell fen [19:21] (fen_) still is there a way to compile C code to haskell and refactor it into common higher order programming patterns? - yes, but this is not a constructive proof
10:26:19 <lambdabot> Consider it noted.
11:09:30 <dminuoso> Hackage is up again! Hooray :)
11:10:01 <Solonarv> hah, just as I (finally) get home!
11:10:36 <dminuoso> Since correlation implies causality, we need to bind you in chains to your home so we can browse hackage in peace.
11:11:10 <Solonarv> no, you misunderstand - the causality goes the other way
11:11:38 <Solonarv> Clearly hackage being up caused the coincidence that allowed me to be home just now
11:12:09 <dminuoso> We can't risk you being wrong, so I vote for chaining you to the door mat.
11:12:36 <statusbot> Status update: We've moved to  a new block-storage volume and restored hackage. -- http://status.haskell.org/pages/incident/537c07b0cf1fad5830000093/5ca584ccc0b3f91dfb7917e0
11:13:23 <dminuoso> 🎉
11:33:15 <arjen-jonathan> Is asking for Hashable on STRef itself insanity?
11:34:15 <phadej> hackage is back!
11:35:37 <phadej> arjen-jonathan: it is
11:35:45 <c_wraith> arjen-jonathan, well, not insanity. but a bit unusual.
11:36:03 <c_wraith> it'd essentially be unique keys by address
11:36:16 <phadej> c_wraith: but hten pure computation won't be deterministic
11:36:26 <phadej> if you let address leak into hash
11:37:06 <c_wraith> phadej, hmm. good point. that'd be fine for an IORef, but not for an STRef
11:40:36 <arjen-jonathan> Can I have it anyway in haskell (lets say that I am confident I can prove that the interface is pure), but I want a easy/fast implementation under the covers.
11:42:39 <phadej> I don't understand why you need to put STRef into a a HashMap/HashSet
11:43:11 <phadej> can't you just put the data into what ref points to?
11:43:47 <phadej> or you can have STRef Int and just pop new Int's as you need, and use those as the keys
11:43:56 <phadej> but that feels wrong idea
11:44:31 <arjen-jonathan> I could, for sure. That is the alternative I'm looking at. 
11:44:59 * Solonarv mumbles in STArray - are those growable?
11:46:02 <arjen-jonathan> It just feels wrong-ish because I kinda want the identity of the pointer anyway. So now I'm inventing identities that I have to trust (or verify manually) to respect reference identity.
11:46:23 <arjen-jonathan> And if I use Int for it those could be forged (at all/much more easily)
11:47:34 <Solonarv> what are you wanting to use the Hashable instance for?
11:48:13 <arjen-jonathan> Associate some other (transient) data with STRefs (which represent nodes in a mutable graph) 
11:48:45 <arjen-jonathan> Basically: I have a graph in ST, and I want to check for cycles. So I keep track of a visited set.
11:48:45 <phadej> why you won't put that data into where STRef points to
11:49:02 <arjen-jonathan> Because this data is shorter lived than the graph.
11:49:13 <Solonarv> oooh, I see now
11:49:17 <arjen-jonathan> So I might update the graph and have to redo cyclicity checking.
11:49:31 <arjen-jonathan> All of the old data would have to invalidated if I store in under the strefs.
11:50:08 <Solonarv> what does your graph datatype look like?
11:51:01 <arjen-jonathan> It is basically the Union-Find datastructure. So nodes that either have a pointer as a value pointing to another node, or a value if they are the representative for the modeled equivalence class.
11:51:53 <arjen-jonathan> The identity of the data in the representative is meaningless to the identity I'm after.
11:52:15 <Solonarv> so something like 'data Node s = NodePtr (STRef s Node) | NodeVal Value' ?
11:54:36 <arjen-jonathan> Uh, yes, I think that is a good approximation
11:55:41 <Solonarv> hm
11:56:14 <Solonarv> you can clearly do this safely using the Eq instance for STRef, but it'll have bad asymptotics
11:58:47 * hackage token-limiter 0.1.0.0 - Fast rate limiting using the token bucket algorithm (BSD)  https://hackage.haskell.org/package/token-limiter-0.1.0.0 (GregoryCollins)
11:58:51 <arjen-jonathan> That is kinda why I'm looking for Hashable I guess. Because it is a fast version of a safe thing.
11:59:16 <arjen-jonathan> Unsafe would be if I'd look at the underlying values of the hash (or address)
11:59:36 <arjen-jonathan> But I'm not. I promise I'll only use it to get fast Eq ;-)
11:59:51 <Solonarv> STRef is just a wrapper around MutVar# which is a compiler primitive
12:00:15 <arjen-jonathan> Yeah, I was trying to find documentation on pealing something Hashable out of it, but couldn't find any.
12:00:40 <arjen-jonathan> Wasn't helping that hackage was down... ;-)
12:00:46 <Solonarv> heh, yeah
12:00:51 <Solonarv> fortunately it's back up now
12:01:20 <arjen-jonathan> Yes, good news
12:02:29 <arjen-jonathan> If I really can't have hashable STRefs then I'll use an IntMap instead of ST to represent the graph.
12:02:39 <arjen-jonathan> I have no idea how that compares performancewise.
12:02:53 <arjen-jonathan> I like it less conceptually because nodes become forgable.
12:03:00 <Solonarv> you might be able to do a bit better if you replace your STRefs with indices into a (mutable) array
12:03:23 <Solonarv> could write a bunch of wrapper code to make that 100% safe
12:04:09 <arjen-jonathan> Hm, clarity is more important than performance for this project.
12:04:21 <Solonarv> or do the approach suggested above:
12:04:21 <Solonarv> data IxSTRef s a = IxSTRef { ix :: Int, ref :: STRef s a }
12:05:02 <arjen-jonathan> Yeah, I guess I'll do that. Can I make the Int type abstract outside of the implementation in Haskell?
12:05:16 <arjen-jonathan> Such that a client of the api can't forge an ix?
12:05:26 <Solonarv> compare using the 'ix' field, write enough operations on this to replicate the STRef API, put all this in a separate module and *don't export IxSTRef's constructors*
12:05:57 <arjen-jonathan> Right, the module system does the trick.
12:06:23 <Solonarv> wait I have an idea for how you can handle keeping track of the int safely
12:06:40 <Solonarv> I'll write a sample module though
12:06:48 <Solonarv> gimme a fewminutes
12:07:03 <arjen-jonathan> Alternatively I could program against the interface with an abstract identity and then I get unforgability from parametricity.
12:08:17 * hackage bitvec 0.2.0.1 - Unboxed bit vectors  https://hackage.haskell.org/package/bitvec-0.2.0.1 (Bodigrim)
12:08:30 <Solonarv> no, you have to "glue" the ID to the STRef so that nobody can swap IDs around
12:16:19 <arjen-jonathan> If that is possible that would be an alternative, but I'm pretty sure I can also get safety from parametricity 
12:27:51 <Solonarv> arjen-jonathan: https://gist.github.com/Solonarv/193ce27121accebe73acbb0376307fd6
12:28:33 <Solonarv> Not really recommending that though ;)
12:29:08 <Solonarv> an 'IntMap Int (Either Int Val)' seems like a better approach to me; if you need it to be mutable just stuff the whole thing in an STRef
12:29:33 <Solonarv> (obviously, add more rigorous types to taste)
12:30:26 <dmwit> arjen-jonathan: There's good union-find implementations on Hackage already, by the way.
12:30:50 <dmwit> e.g. http://hackage.haskell.org/package/union-find-0.2/docs/Data-UnionFind-ST.html
12:32:22 <dmwit> Also, you say, "But I'm not. I promise I'll only use it to get fast Eq", which I don't really believe. But if it's true, then you're in luck: STRef already has a fast Eq instance.
12:33:37 <Solonarv> hah ;)
12:35:50 <arjen-jonathan> dmwit: I'm using that yes.
12:36:12 <arjen-jonathan> dmwit: Particularly I'm building first order unification a la Baader Snyder on top of that.
12:36:34 <dmwit> There's... *also* a pretty good implementation of first-order unification on Hackage already.
12:36:35 <arjen-jonathan> Which requires cyclicity checking on top of union find.
12:36:38 <dmwit> ?hackage unification-fd
12:36:38 <lambdabot> http://hackage.haskell.org/package/unification-fd
12:37:00 <arjen-jonathan> dmwit: also aware of that one, and used it before. But doesn't serve the goal of this project.
12:37:47 <Ariakenom> Solonarv: haha, type to taste, I like it
12:37:57 <dmwit> It uses the trick everybody else was suggesting, by the way: http://hackage.haskell.org/package/unification-fd-0.10.0.1/docs/src/Control-Unification-STVar.html#STVar
12:38:14 <arjen-jonathan> I need an implementation I can present as educational; unification-fd is a bit more involved.
12:38:19 <dmwit> "In addition to the @STRef@ for the term itself, we also track the variable's ID (to support visited-sets)."
12:38:41 <Solonarv> yes, this is the "all the types" approach - trying to steal my IxCounter, will you? oh no you don't! typechecker, TO ME!
12:39:14 <arjen-jonathan> dmwit: Right, forgot about that. Thanks for reminding me
12:39:25 <arjen-jonathan> Solonarv: thanks for your gist!
12:39:58 <arjen-jonathan> Solonarv: so indeed you exploit parametricity to get safety here as well.
12:40:20 <Solonarv> oh yeah you'll want to make the fields strict and toss in UNPACK pragmas as well if you're worried about perf
12:40:46 <stepcut> Is there a cabal install command-line flag that will install only the libraries and skip building the executables? Or do I have to edit the .cabal file by hand and set the Buildable: False flag?
12:41:02 <arjen-jonathan> Thanks all for your help.
12:41:55 <Solonarv> stepcut: 'cabal install somepackage:lib' might do it; better question: why are you installing libraries?
12:42:47 <dmwit> stepcut: In the v1- days, I used the --only-dependencies flag from time to time.
12:43:18 <dmwit> That doesn't stop it from building the dependencies' executables, but will stop it from building the current package's executables at least.
12:44:00 <stepcut> Solonarv: I am actually just trying to run 'nix-shell' but the shell.nix depends on `cheapskate` being built by ghcjs and the libraries build fine, but the cheapskate.jsexe executable dies at the linking stage with a stack overflow. I have no need for cheapskate.jsexe.
12:44:31 <Solonarv> ah I see, nix/ghcjs
12:44:53 <stepcut> Solonarv: I'd like to find some setup of flags I can add to the .nix file rather than patching the upstream source
12:44:59 <Solonarv> I don't have any experience with that, so I don't have a better suggestion than 'cabal install cheapskate:lib'
12:45:03 <dmwit> (Doesn't really sound like a nix-specific problem to me, though.)
12:45:29 <Solonarv> (yeah, but I've mostly forgotten / never knew how cabal v1 works)
12:48:14 <Solonarv> --help suggests that the component syntax should work for v1-build/v1-install as well
13:14:59 <phadej> dmwit: ping! :)
13:18:04 <dmwit> pong
13:22:01 <Welkin> ching
13:22:50 <johnw> I love surgical bang patterns
13:23:31 <johnw> foo (Foo x) = go (someField x) where go !y = Bar (< y)
13:23:50 <johnw> otherwise, the closure passed to bar retains all of 'x', not just the one field
13:24:28 <johnw> although, the thunk returned by foo retains it too, so you have to force that as well
13:30:17 * hackage focus 1.0.1.3 - A general abstraction for manipulating elements of container data structures  https://hackage.haskell.org/package/focus-1.0.1.3 (NikitaVolkov)
13:31:17 <dminuoso> Mmm, is there a more elegant way to express ((>> g) . f) that Im not seeing?
13:31:54 <Welkin> yes `\a -> f a >> g`
13:32:00 <dminuoso> Id like something clean to put to the right of my `withException` handler that looks along the lines of: logException >> die
13:32:43 <dminuoso> blah `withException` (>> die) . logIt
13:32:49 <dminuoso> Is not pleasant to look at.
13:33:02 <Solonarv> logException <> const die
13:33:05 <Welkin> I gave you the answer
13:33:05 <Solonarv> ;)
13:33:12 <johnw> or f >=> const g
13:33:16 <Welkin> I don't see why you want to write convoluted code
13:33:46 <Solonarv> ah yeah >=> will actually work for every monad
13:34:00 <Solonarv> I endorse it
13:34:38 <dminuoso> johnw: It feels like there should be a combinator for it! But I take it, thanks. :)
13:35:05 <dminuoso> Probably wouldn't meet the Fairbairn threshold however.
13:35:14 <Solonarv> <> is techically shorter and works in IO at least
13:36:33 <dminuoso>  Semigroup b => Semigroup (a -> b)
13:36:36 <dminuoso>  Semigroup a => Semigroup (IO a)
13:36:44 <dminuoso> Solonarv: So you're relying on the Semigroup instance of () then?
13:36:56 <Solonarv> yes
13:38:12 <Solonarv> it seems like a reliable fellow, I trust it.
13:39:21 <dminuoso> Solonarv: The threshold of three relatively uncommon Semigroup instances does not seem worth the while here.
13:39:49 <Solonarv> I did say I preferred f >=> const g
13:39:51 <Solonarv> I agree!
13:40:30 <dminuoso> Solonarv: But it was interesting nevertheless. The Semigroup/Monoid instances on `(->) ...` are pretty nifty and underused. :)
13:41:27 <Solonarv> oh! runReaderT do ReaderT logException; liftIO die
13:41:28 <Solonarv> ;)
13:41:51 <Solonarv> yeah the (->) instances are neato
13:42:05 <dminuoso> Solonarv: I have been tempted to feed my LoggingT into this bit, actually.
13:45:17 * hackage morley-prelude 0.1.0.4 - A custom prelude used in Morley  https://hackage.haskell.org/package/morley-prelude-0.1.0.4 (gromak)
13:46:17 * hackage morley 0.2.0.1 - Developer tools for the Michelson Language  https://hackage.haskell.org/package/morley-0.2.0.1 (gromak)
14:01:28 <nemron> Can someone help me out to figure out the type of `zipWith id`? The type of `zipWith` is `(a1 -> (b1 -> c1)) -> [a1] -> [b1] -> [c1]`. The type of `id` is `a -> a`. So `zipWith` expects as first parameter a value of type `a1 -> (b1 -> c1)`. So `zipWith` applied to `id` yields `a = a1` and `a = (b1 -> c1)`. If I take the latter then `zipWith id :: [b1 -> c1] -> [b1] -> [c]`. 
14:01:33 <saml>  "What are these guys doing with monads? How are they managing to make such a simple concept so mysterious?"
14:01:51 <saml> @type zipWith id
14:01:52 <lambdabot> [b -> c] -> [b] -> [c]
14:02:17 <nemron> saml I want to execute the substitution by myselfe
14:02:26 <saml> @type zipWith
14:02:27 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
14:02:39 <nemron> @type id
14:02:40 <lambdabot> a -> a
14:02:51 <saml> So, it takes a binary operator, two lists, and does  a `op` b
14:02:59 <nemron> So how does a -> a match to a -> b -> c?
14:03:00 <saml> @type id
14:03:01 <lambdabot> a -> a
14:04:11 <saml> > zipWith id [(+1), (+2)] [1..]
14:04:13 <lambdabot>  [2,4]
14:04:14 <Solonarv> we want to solve: a -> a ~ a1 -> (b -> c)
14:04:14 <Solonarv> we can split this into (a ~ a1, a ~ b -> c)
14:04:14 <Solonarv> the rest should be straightforward ^^
14:04:30 <Solonarv> (~ means "should unify")
14:04:47 <Solonarv> nemron: does that help?
14:05:10 <saml> a `id` 1 => a 1
14:05:31 <nemron> Solonarv yes, a bit, but how to solve (a ~ a1, a ~ b -> c)? How can `a` be `a1` and `b -> c`.
14:05:49 <Solonarv> well, ~ is a kind of equality
14:06:12 <nemron> I guess this is my problem... I don't understand how to solve this
14:06:32 <Solonarv> and if we know x = y and y = z we can get x = z
14:06:47 <nemron> Is it (a ~ a1, a ~ b -> c) ~~~> a1 ~ b -> c
14:06:55 <Solonarv> yes
14:07:02 <saml> a = a1; a = b -> c;    so, a = b -> c   because single variable a1  loses
14:07:41 <c_wraith> so what's the type of id in that context?
14:07:43 <nemron> saml I don't think "because single variable a1 loses" is correct. 
14:07:51 <saml> in unification, you can erase  a ~ b;
14:08:13 <saml> "a variable equals another variable" clause can be removed
14:08:29 <saml> So, what's left is a = b -> c
14:08:48 <nemron> OK. Where can I read up this calculus?
14:09:15 <nemron> I like  (a ~ a1, a ~ b -> c) ~~~> a1 ~ b -> c better. BTW, Thx Solonarv 
14:09:24 <Solonarv> (well, you can't just toss it out - you have to remove one of the variables from the rest of the constraint-set, by replacing it with the other)
14:09:31 <Solonarv> which is basically what happened here
14:10:17 <dminuoso> nemron: You have been using this id in disguise probably a while already.
14:10:25 <dminuoso> nemron: ($) = id 
14:10:38 <dminuoso> (Plus an fixity declaration)
14:12:20 <dminuoso> saml: Regarding your quote, I think it's an interesting topic. Monads are definitely not simple, they are just rather abstract. I found in category theory every time I grok a concept, it suddenly feels extremely simple to me.
14:12:39 <saml> algebra is at http://dev.stephendiehl.com/fun/006_hindley_milner.html
14:12:52 <dminuoso> I mean how can you not understand what a limit or colimit is, they are like elemental algebra. The pain and mindtwisting you had to undergo to get to the plane of understanding is quickly forgotten.
14:13:30 <slack1256> ^ sh*t #haskell says
14:14:01 <nemron> saml Thx!
14:14:12 <shapr> dminuoso: right on
14:16:00 <dminuoso> And people split off into one of two classes after that. The folks who write down their own working mind model as a tutorial, which makes no sense to people because they cant relate to the mind model and lack the plane of understanding (this is where many monad tutorials come from), and the folks who then try to explore further subjects
14:16:00 <saml> all computation is over natural number. so simple
14:16:09 <dminuoso> Giving rise to jokes like "Monads are just monoids..."
14:17:59 <saml> I guess same isn't true for C programming. Maybe true for enterprise java.  Once you understand something, you want to forget about it.
14:18:29 <nemron> dminuoso re ($) = id ... nice... and you are right... didn't know. Thx!
14:19:54 <dminuoso> saml: Well there's of course also the broad group of people who wont care after they understand the concept because they just want to use it.
14:19:54 <saml> @type ($)
14:19:55 <lambdabot> (a -> b) -> a -> b
14:20:23 <dminuoso> % :t flip id
14:20:23 <yahb> dminuoso: b -> (b -> c) -> c
14:20:45 <dminuoso> This is an amusing mindtwister for newcomers every time. :)
14:21:02 <benzrf> @let foo :: (forall a. a -> a) -> Int; foo f = f 3
14:21:04 <lambdabot>  Defined.
14:21:13 <benzrf> :t foo $ id
14:21:14 <lambdabot> Int
14:21:15 <benzrf> :t foo `id` id
14:21:16 <lambdabot> error:
14:21:16 <lambdabot>     • Couldn't match type ‘forall a. a -> a’ with ‘a0 -> a0’
14:21:16 <lambdabot>       Expected type: (a0 -> a0) -> Int
14:21:24 <benzrf> where is your "($) = id" now????
14:21:51 <c_wraith> eh, let's pretend that hack doesn't exist.
14:21:55 <benzrf> ;)
14:22:24 <dminuoso> benzrf: I too pretend that (->) :: * -> * -> * ... :-)
14:22:33 <c_wraith> lens sometimes has a related thing:
14:22:37 <c_wraith> :t view
14:22:38 <lambdabot> MonadReader s m => Getting a s a -> m a
14:22:56 <c_wraith> :t flip view
14:22:57 <lambdabot> s -> Getting c s c -> c
14:23:00 <benzrf> dminuoso: ghci tells me it does =(
14:23:08 <dminuoso> benzrf: heh, its lying to you.
14:23:10 <c_wraith> magic extra parameter appears!
14:23:29 <dminuoso> % :i (->)
14:23:29 <yahb> dminuoso: data (->) (a :: TYPE q) (b :: TYPE r) -- Defined in `GHC.Prim'; infixr 0 ->; instance Applicative ((->) a) -- Defined in `GHC.Base'; instance Functor ((->) r) -- Defined in `GHC.Base'; instance Monad ((->) r) -- Defined in `GHC.Base'; instance Monoid b => Monoid (a -> b) -- Defined in `GHC.Base'; instance Semigroup b => Semigroup (a -> b) -- Defined in `GHC.Base'; instance [safe] (PrintfArg a, HPrintfTy
14:23:48 <benzrf> ow
14:24:10 <benzrf> my ghci just says "data (->) t1 t2"
14:24:16 <benzrf> what extns am i missing?
14:24:23 <dminuoso> benzrf: You may have a newer GHCi?
14:24:49 <dminuoso> benzrf: There's hacks inside to hide the levity polymorphism to avoid confusing beginners.
14:25:06 <dminuoso> There was or is a difference between :i and :k at least
14:25:08 <dminuoso> % :k (->)
14:25:08 <yahb> dminuoso: (->) :: * -> * -> *
14:25:22 <benzrf> im on 8.0.2 rn
14:31:50 <johnw> @pl \a b k -> k a b
14:31:50 <lambdabot> flip . flip id
14:32:40 <benzrf> @let rpn = flip . flip id
14:32:41 <lambdabot>  Defined.
14:32:52 <johnw> lol
14:44:06 <johnw> is there any way in Core output to remove all the `cast` stuff?
14:44:20 <johnw> I really just want to see where constructions are happening
14:44:49 <phadej> -dsuppress-coercisons isn't good enough?
14:44:54 <johnw> let me try that
14:44:58 <phadej> coercions
14:45:16 <phadej> (--show-options tells)
14:45:19 <johnw> ah, no I have that on
14:47:45 <phadej> looks like even suppress-all leaves them there
14:51:39 <phadej> johnw: I added https://github.com/nomeata/inspection-testing/pull/32/files to inspection-testing so I could inspect $ coreOf single symbols
14:51:59 <phadej> and in that setting, it's easy to add custom-ish postprocessors of core terms
14:52:33 <johnw> do you have an example of real world use? sounds great
14:52:39 <phadej> (though inspection-testing doesn't depend on syb, which would be handy to remove all casts)
14:54:07 <phadej> johnw: so far I used it only in one presentation showing out "it really does get fused"
14:54:53 <johnw> can I sees it?
14:55:02 <phadej> oh, it was live coding ;)
14:55:11 <johnw> I tried adding fusion to edwardk's 'free' library, and it worked out nicely
14:55:29 <johnw> I'd like an inspection test to ensure it stays that way
14:56:19 <phadej> well, inspection tests are easy to formulate when the invariant is "absence of something"
14:56:22 <johnw> phadej: any thoughts on how to make this faster: https://gist.github.com/a1929d42264863254f155876c836342d
14:56:58 <johnw> profiler says I'm allocating 60 GB through the GC, and 99% of my allocation is in `combine`, though that may just be where things are getting forced ultimately
14:58:00 <phadej> well, that's where I'd use inspect $ coreOf 'combine :)
14:59:39 <johnw> the core: https://gist.github.com/4507eea4bb963202fcd37bcf8dbe3e69
15:03:28 <phadej> johnw: it does allocate, those lets in combine_$scombine
15:03:38 <phadej> johnw: it might be that scc annotation makes it not optimise further
15:03:46 <phadej> scc<combine> always'_go lvl71 lvl72 dk
15:03:49 <johnw> i see
15:03:54 <johnw> i wondered if profiling was getting in the way
15:05:14 <phadej> if you feel adventurous, I invite you to try unreleased inspection-testing and do `specialiseCombine = combine @LogEntry @LogEntryAnalysis` and inspect core of that
15:05:21 <phadej> without profiling / scc annotations
15:06:16 <phadej> coreOf dumps the transitive closure of the term, which is present in that module
15:06:17 <johnw> ouch: 112,196,191,368 bytes copied during GC
15:06:28 <phadej> that's bad
15:06:30 <phadej> you leak something
15:06:37 <johnw> yes, and it's not much code either
15:06:57 <johnw> such a log scanner over a 16M log file
15:06:59 <johnw> just*
15:07:42 <phadej> but I'd try normal, non profiled version
15:07:49 <johnw> trying that now
15:09:13 <phadej> yo ucould do +RTS -hT which would generate heap profile even for non-profiled build
15:09:18 <johnw> ok
15:09:25 <phadej> if it's flat: good
15:09:32 <phadej> if it's not: you'll see what leaks :)
15:09:45 <johnw> without profiling, 76G
15:10:01 <johnw> 27M maximum residency
15:10:17 <phadej> 76 copied?
15:10:20 <johnw> yeah
15:10:47 <johnw> I expect some retaining from this code, but almost no copying
15:11:23 <johnw> it's not flat, it grows in ARR_WORDS
15:12:37 <johnw> time to just start ruling things out
15:12:44 <phadej> ARR_WORDS is bytestring
15:12:48 <johnw> yeah
15:12:57 <johnw> I wonder if it's pcre-heavy
15:15:50 <phadej> you could also try -A64M i.e. increase nursery
15:16:14 <phadej> if it's just because your per-entry stuff needs just a little more memory to not graduate out of nursery
15:16:51 <johnw> trying
15:17:16 <phadej> LogEntryAnalysis is also strict in every field and doesn't have ByteStrings (which could retain input?)
15:18:52 <phadej> (and silly questions, have you tried folds or foldl?)
15:19:04 <johnw> that did help a bit:
15:19:05 <johnw>  155,641,104,328 bytes allocated in the heap
15:19:06 <johnw>   15,542,061,080 bytes copied during GC
15:19:35 <johnw> logentryanalysis is a list, but I'm never actually creating anything but empty lists in this test
15:19:48 <johnw> and it refers to no bytestrinsg anyway
15:20:19 <johnw> hmm.. let me try something else
15:20:21 <phadej> a list like []
15:20:26 <phadej> that could retain stuff in a thunk
15:20:30 <phadej> if not forced fully
15:20:33 <johnw> true
15:21:07 <phadej> hopefully you find a culprit, I have to go now ->
15:21:24 <johnw> thanks for the help!
15:46:47 * hackage hw-ci-assist 0.1.0.0 - CI Assistant for Haskell projects  https://hackage.haskell.org/package/hw-ci-assist-0.1.0.0 (haskellworks)
15:47:57 <hpc> haskellworks is so CI that they upload hello world...
15:57:18 <johnw> the world needs a lot of greeting
15:57:31 <pat_> lol
16:02:46 <pat_> quit
16:02:49 <pat_> exit
16:06:47 <CelestialLake> s/exit/exeunt/
16:13:31 <linduxed> do people use this, or are records still considered an unsolved pain point of the language? http://nikita-volkov.github.io/record/
16:14:04 <hpc> check out the lens package
16:18:34 <slack1256> Most of the major problems with record, namely non-composability were moot since lens reached 1.0 on 2015
16:34:00 <vivit> I'm trying to define a type class "Reciprocal" with a function "inverse"
16:35:08 <vivit> I tried to put "inverse (inverse a) = a" in the where section for the class but, but ghci is giving me a parse error
16:35:15 <vivit> Am I barking up the wrong tree here?
16:36:53 <dminuoso> vivit: What is `inverse (inverse a) = a` supposed to mean?
16:37:19 <dminuoso> vivit: Keep in mind that pattern matching works against data constructors.
16:37:27 <dminuoso> vivit: functions are not data constructors.
16:38:16 <vivit> That for every a and b in any type of the typeclass Reciprocal, if inverse a == b, then inverse b == a
16:38:51 <dminuoso> vivit: The canonical way is to specify the law in the haddock part of the class.
16:39:02 <jle`> vivit: hm, what do you think a typeclass is, exactly?
16:39:40 <jle`> vivit: it's basically a way to associate functions with a given type
16:40:05 <vivit> Yes, that's what I understand a typeclass as
16:40:07 <jle`> so if a type is an instance of, say, Eq, it means that it defines an (==) and (/=)
16:40:15 <jle`> vivit: so, typeclasses associate functions
16:40:21 <jle`> inverse (inverse a) = a ... is that a function?
16:40:35 <vivit> It's supposed to be
16:40:40 <jle`> in a typeclass 'where' body, you provide the type signatures of the functions that must be defined 
16:40:49 <jle`> so instance Eq a where (==) :: a -> a -> Bool
16:41:01 <jle`> you provide the names and types of the functions that an instance must provide
16:41:05 <dminuoso> vivit: The tpeclass does not specify an implementation (it could specify a default implementation though, but thats a different story).
16:41:09 <jle`> (and also default implementations)
16:41:13 <vivit> I do provide the type signature: Reciprocal a where inverse :: a -> a
16:41:20 <jle`> exactly :)
16:41:22 <jle`> and that's it
16:41:29 <dminuoso> vivit: You cant tag laws along side (sadly).
16:41:31 <jle`> nothing more, except for default implementations maybe.
16:42:18 <jle`> vivit: class Reciprocal a where inverse :: a -> a is perfectly sufficient
16:42:31 <jle`> because it does everything a typeclass can do: it says the name of the function that must be associated with it
16:42:33 <dminuoso> vivit: what you are asking for is exceedingly complicated to attain by the way. Let's presume, for a moment, that `inverse (inverse a) = a` was legal and behaved the way you think it would inside some code.
16:42:36 <vivit> I saw a definition of Eq that defined  (==) a b = not (a /= b) and vice-versa
16:42:37 <jle`> there's...nothing else involved
16:42:41 <dminuoso> vivit: How can we know whether a function is equal to `inverse`?
16:42:48 <jle`> vivit: ah that's different, that's a default implementation
16:43:14 <jle`> it's a "fallback definition", if the user doesn't provide their own implementation
16:43:20 <jle`> but it has to be a valid function definition
16:43:40 <jle`> it's not defining a "property", but rather is just a fallback function definition
16:43:50 <jle`> `inverse (inverse a) = a` is not a valid function definition
16:43:58 <vivit> That's what I was trying to do with it; define a fallback definition
16:44:10 <dminuoso> vivit: Even if so, there is no equality on functions.
16:44:11 <jle`> `inverse (inverse a) = a` is not a valid function definition
16:44:19 <jle`> do you see why?
16:44:20 <vivit> I understand my mistake now: I was confusing functions with type constructors.
16:44:32 <vivit> s/type/data/
16:44:33 <jle`> @let inverse (inverse a) = a
16:44:33 <lambdabot>  Parse failed: Parse error in pattern: inverse
16:44:54 <jle`> the problem isn't that it's in a typeclass, but rather that it's invalid syntax for a function declaration
16:45:15 <jle`> you're free to provide a default implementation ... but it does have to be valid syntax :)
16:45:16 <dminuoso> vivit: And part of the reason is that there is no useful general notion of equality of functions. Do you care about extensoinal equality of functions? How do you test whether two functions over infinite domains are equal?
16:45:19 <vivit> I was thinking, "Well, (\(Just a) -> a) works as a function, so..."
16:45:50 <dminuoso> vivit: Do oyu care about intensional equality of functions? There exists no general solution to test whether two functions behave equally as an extension of the turing problem.
16:45:53 <jle`> that's definitely understandable :)
16:45:58 <c_wraith> Just is syntactically different from inverse in a very important way
16:46:15 <vivit> Yeah, because it's a value constructor
16:46:15 <c_wraith> values that start with capital letters are constructors
16:46:16 <dminuoso> vivit: So even if we admitted the syntax, we couldn't sensibly implement it anyway.
16:46:17 <vivit> Right?
16:46:22 <c_wraith> yeo
16:46:25 <c_wraith> err. yep
16:46:36 <jle`> vivit: it's not quite that it's a value constructor.  it's actually not a constructor at all
16:46:44 <vivit> What is it, then?
16:46:48 <dminuoso> vivit: its just a function.
16:46:58 <jle`> vivit: it's not a valid pattern :)
16:47:08 <c_wraith> um. I think vivit was talking about Just
16:47:17 <c_wraith> which is a constructor
16:47:19 <vivit> (I was)
16:47:24 <jle`> ah, i see
16:47:35 <jle`> i missed c_wraith's message :)
16:48:05 <jle`> in the big picture, the confusing thing is that you actualyl have two different syntactic "spaces" that look very very similiar 
16:48:26 <jle`> one is "expression" syntax, and the other is "pattern" syntax
16:48:56 <jle`> they're more or less unrelated, but the designers of Haskell tried to make the difference as confusing as possible ;)
16:49:28 <jle`> that's a little ingeneous of me to say.  but i mean that they try to blur the distinction to make things look cleaner and more unified, in a way
16:49:47 <jle`> but the "rules" of expression syntax are completely different than the "rules" of pattern syntax
16:50:05 <vivit> So regarding what I'm trying to do: I'm trying to set up a default implementation such that if I defined "instance Reciprocal Direction where inverse North = South", I would have already expressed that this also means that South = North
16:50:16 <jle`> what happened here is that you ended up switching the rules, which is a very common thing
16:50:21 <vivit> in the default implementation
16:50:39 <jle`> vivit: ah. yeah, that's not really a sensible "general" default implementation you can write
16:50:47 <jle`> since you can't really write one that works for all functions in general
16:51:03 <jle`> er, all types in general, that is. and functions, too
16:51:58 <jle`> for example, here's a counter-example: `inverse _ = North`
16:52:35 <jle`> any "general" method of writing inverse would be able to write an inverse for that function
16:52:50 <jle`> and no inverse for that function exists .... so any general method must necessarily fail
18:35:52 <vivit> What do I do if I want to give two data types A and B value constructors with fields of the other type
18:36:19 <vivit> i.e. A has a value constructor with a field of type B and B has a value constructor with a field of type A
18:36:49 <vivit> Whichever one I define first won't be able to have a datat constructor with a field of the second type, because the second type won't be defined yet
18:37:04 <vivit> Is it possible to forward-declare data types?
18:43:35 <vivit> Hmm, doesn't seem like you can forward declare data types
18:44:26 <nshepperd> just put them in the same file
18:44:59 <vivit> What do you mean?
18:45:26 <nshepperd> if they're in the same module, data types can be mutually recursive, no problem
18:45:51 <vivit> Hmm, I guess that works; I guess I was confusing how the ghci worked with how files are read
18:47:41 <nshepperd> yeah ghci is special. in a file all declarations happen "at the same time"
18:48:23 <nshepperd> if you want to declare mutually recursive data types in ghci, you can do it on one line, like "data A = MkA B; data B = MkB A"
18:48:56 <vivit> Okay, new question; this one actually relating to how things work in a file
18:50:14 <vivit> I can define functions to operate on multiple datatypes
18:51:45 <vivit> But I can't define named fields with the same name on data constructors in different datatypes
18:56:29 <nshepperd> that's because the named fields generate accessor functions with that name
18:56:44 <nshepperd> data Foo { value :: Int }; data Bar { value :: Int};
18:57:13 <nshepperd> now there's two functions called 'value', which is no good
18:57:48 <nshepperd> there are a bunch of language extensions for making this ok, but i don't know much about them
18:58:26 <delYsid> time-units + time-interval or o-clock?  What to use?  o-clock has parsing and formatting included, both are not in stackage lts.  Anything else I missed?
19:30:50 <vivit> What's the difference between lookup and !?
19:33:02 <jackdk> :t (!)
19:33:04 <lambdabot> Ix i => Array i e -> i -> e
19:33:11 <jackdk> :t Data.Map.!
19:33:12 <lambdabot> error: parse error on input ‘Data.Map.!’
19:33:19 <jackdk> :t (Data.Map.!)
19:33:20 <lambdabot> Ord k => M.Map k a -> k -> a
19:33:25 <jackdk> :t Data.Map.lookup
19:33:26 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
19:33:36 <jackdk> vivit: those two?
19:34:12 <vivit> No, (!?)
19:34:33 <vivit> lol, I see the ambiguity in my comment now
19:34:34 <jackdk> oh, I thought that ? was punctuation indicating a question
19:34:42 <vivit> yes
19:34:54 <vivit> :t Data.Map.!?
19:34:55 <lambdabot> error: parse error on input ‘Data.Map.!?’
19:35:09 <vivit> :t (Data.Map.!?)
19:35:10 <lambdabot> Ord k => M.Map k a -> k -> Maybe a
19:35:10 <jackdk> `(!?) m k = lookup k m`
19:35:16 <jackdk> https://hackage.haskell.org/package/containers-0.6.0.1/docs/src/Data.Map.Internal.html#%21%3F
19:35:39 <vivit> Oh so it's just an infix version?
19:35:44 <jackdk> yeah
19:36:06 <vivit> With the order of the arguments reversed to be more orthogonal to lists with (!!)
19:51:18 <vivit> Are data constructors different from other functions in that they NEED arguments?
19:51:50 <vivit> @foobar (++) = 1
19:51:50 <lambdabot> Unknown command, try @list
19:51:58 <vivit> @let foobar (++) = 1
19:51:59 <lambdabot>  Defined.
19:52:07 <vivit> @let foobar Just = 1
19:52:08 <lambdabot>  .L.hs:178:8: error:
19:52:08 <lambdabot>      • The constructor ‘Just’ should have 1 argument, but has been given none
19:52:08 <lambdabot>      • In the pattern: Just
20:01:38 <blankhart> no, they don't need arguments.  Nothing, for example, has arity 0.
20:32:47 * hackage http2 1.6.5 - HTTP/2 library including frames, priority queues and HPACK  https://hackage.haskell.org/package/http2-1.6.5 (KazuYamamoto)
20:34:04 <jle`> vivit: data constructors are like "literals" that represent functions in code
20:34:25 <jle`> kind of like 1, "hello"
20:34:43 <jle`> you type them into source code and Haskell interprets it as a function you can apply
20:35:46 <jle`> or as a non-function value
20:37:00 <Cale> Data constructors are different from other functions or non-function values in that you can pattern match against them
20:37:14 <Cale> That's really the major difference.
20:37:26 <jle`> yeah, when you use them in an expression, they become interpreted one way.  if you use them in a pattern, they're interpreted another way
20:38:54 <jle`> in a way, data constructors really only exist on the syntactical level
20:39:10 <jle`> on the semantic level they represent any other value
20:39:22 <jle`> (within expression syntax)
21:09:40 <Cale> jle`: I don't know if I agree with that -- depends a bit on the semantics, but data constructors definitely have a special role to play there most of the time as well.
21:10:44 <Cale> For example, think about how the definedness ordering works for something like the type [Bool]
21:11:02 <Cale> You have _|_ at the bottom, and then above it are [] and _|_ : _|_
21:11:37 <Cale> and then immediately above _|_ : _|_ are True : _|_, False : _|_,  _|_ : [],  and _|_ : (_|_ : _|_)
21:12:13 <Cale> Each level in the ordering determines one more data constructor
21:13:44 <Cale> Evaluation can be thought of as moving upward from _|_ always respecting the ordering, as you only ever discover more data constructors, never change your mind about previously determined ones.
21:16:48 <jle`> hm, that's fair
21:24:12 <mjrosenb> Is there anyting in lens that might want to be called <?%= ?
21:28:52 <glguy> Not that I can think of
21:38:22 <mjrosenb> newLow <- low . ix curVertex <%= min childLow 
21:39:11 <mjrosenb> that's what I have, but that isn't working because ix can select 0 or 1 things, and there's no Monoid Int
21:39:38 <mjrosenb> I'd like to be able to say 'this will definitely select something', but that appears to not be an option.
21:43:05 <sordina2> Does anyone have a link to a version of the Haskell Colored Petri Nets paper?
21:43:11 <glguy> If you're sure it will select something you can wrap it in 'singular'
21:43:19 <sordina2> The community server hosting it seems to be down: http://community.haskell.org/~claus/HCPN/
21:43:47 * hackage avro 0.4.4.0 - Avro serialization support for Haskell  https://hackage.haskell.org/package/avro-0.4.4.0 (haskellworks)
21:44:21 <geekosaur> that server has been archived
21:45:16 <siraben> How can I get cabal to download packages when hackage is down?
21:45:17 <siraben> Seems to be up now
21:47:19 <sordina2> geekosaur: is the archive anywhere public?
21:59:38 <glguy> https://web.archive.org/web/20150910103554/http://community.haskell.org/~claus/HCPN/
22:01:47 * hackage avro 0.4.4.1 - Avro serialization support for Haskell  https://hackage.haskell.org/package/avro-0.4.4.1 (haskellworks)
22:03:48 <sordina2> glguy: Thanks!
22:09:47 * hackage spiros 0.4.0 - Spiros Boosalis's Custom Prelude  https://hackage.haskell.org/package/spiros-0.4.0 (sboo)
22:44:26 <dminuoso> By the way... when talking about denotational semantics in Haskell.. are they formally defined anywhere at all? Or is it just something we consciously make up ourselves and pretend that we all have the same denotational semantics in mind?
23:19:30 <utonx[m]> hello, I'm trying to compile a very simple project that is splitted among two directories with stack; one for the main and one for the utility modules. Pretty much all there is to it is Main.hs being in exe dir and src containing CalUtils.hs. I added the library stanza to the .cabal file but it simply won't compile, complaining about being unable to find calutils. I have no experience with stack but it seems like either
23:19:30 <utonx[m]> it's ignoring the library stanza or the module itself. Am I doing something wrong or is there an issue with the stack I'm using? https://ghostbin.com/paste/36nk6
23:20:32 <utonx[m]> Would be really glad for any help
23:25:26 <dminuoso> utonx[m]: You have to name the library next to the `library` keyword.
23:25:49 <dminuoso> utonx[m]: `library calutils\n  hs-source-dirs: ...`
23:26:14 <dminuoso> utonx[m]: otherwise it will try to look for a package named `calutils` which it cant find.
23:27:40 <utonx[m]> goddamnit you're right, looks like I was following an obsolete tutorial
23:27:46 <utonx[m]> thank you
23:31:28 <hvr> siraben: cabal wouldn't even notice that hackage is down a it automatically falls back to mirrors =)
23:32:15 <hvr> siraben: ..unless you have a really old cabal
23:32:21 <dyl> Well, there go the matrix users.
23:32:42 <johnw> this may seem terribly 2006, but does anyone know how to write an arrow for any Arrow a that only processes the inputs after the first?
23:33:27 <johnw> I can do it easily with an Automaton, but don't know if there's a general way to express it
23:33:43 <dyl> What do you mean by “after the first”?
23:34:08 <johnw> I want to write next :: Arrow? a => a b (Maybe c) -> a b (Maybe c)
23:34:19 <johnw> that yields a Nothing for the first b, but a Just something for every subsquent b
23:35:05 <dyl> Arrow? ...?
23:35:47 <johnw> some Arrow class
23:35:51 <johnw> or maybe even just Arrow, I dunno
23:36:17 <dyl> You seem to be introducing a concept of enumeration/order that isn’t native to arrows.
23:36:35 <dyl> So, at the least, I doubt `Arrow a` is a sufficient constraint.
23:36:46 <johnw> I strongly doubt it is as well
23:37:02 <johnw> I could do it with ArrowLoop, if I know how to "start" the recursive value
23:37:31 <johnw> even just counting inputs would be a sufficient example
23:37:58 <johnw> loop $ proc (x, i) -> returnA -< (x, succ i)
23:38:02 <johnw> but how do you start i at 0....
