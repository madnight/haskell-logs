00:00:01 <dminuoso> Or just with a newtype.
00:00:05 <dminuoso> Or a data record.
00:00:13 <Cale> and then you implement concrete types which are instances of those classes
00:00:18 <Nevoic> data records specify fields, not functions.
00:00:19 <Nevoic> IIRC.
00:00:31 <Cale> Functions which use type class polymorphic things are automatically type class polymorphic
00:00:32 <dminuoso> Nevoic: You can have functions in a record too. :)
00:00:35 <Cale> :t (+)
00:00:36 <lambdabot> Num a => a -> a -> a
00:00:39 <Cale> :t (==)
00:00:40 <lambdabot> Eq a => a -> a -> Bool
00:00:57 <Cale> :t \x y -> x + y == x * y
00:00:58 <lambdabot> (Num a, Eq a) => a -> a -> Bool
00:01:20 <dminuoso> % data Server = Server { runServer :: IO (); logMessage :: String -> IO (); abortServer :: String -> IO () }
00:01:20 <yahb> dminuoso: ; <interactive>:408:42: error: parse error on input `;'
00:01:41 <Nevoic> Wait aren't data records in Haskell concrete?
00:01:50 <Cale> It's not yet decided what type of values this function will act on, but it's determined that they must be the same type, they must be comparable for equality, and they must implement numerical operations
00:02:09 <Cale> Nevoic: Data types may also have type parameters
00:02:28 <dminuoso> % data Server = Server { runServer :: IO (), logMessage :: String -> IO (), abortServer :: String -> IO () }
00:02:28 <yahb> dminuoso: 
00:02:31 <Cale> In fact, data types with type parameters are sometimes better than type classes, if you have many conventions for the same type.
00:02:44 <Nevoic> I'm not looking to generalize a type over other types, I'm looking to define a type with no type parameters that describes functionality.
00:02:49 <fr33domlover> There's also rank N types
00:02:57 <Cale> Nevoic: Think about something like:
00:03:20 <dminuoso> Nevoic: Then you could have your library expose that data type, and then a function `runServerMagic :: Server -> IO`, a consumer has to construct a Server object (perhaps satisfying some properties), and your library can consume it.
00:03:27 <Cale> data Combiner a = Combiner (a -> a -> a)
00:03:50 <Cale> (or you can use record syntax if you have lots of methods)
00:05:18 <Cale> data AnimationInterface a = AO { timeStep :: DeltaTime -> a -> a, userInput :: InputEvent -> a -> a, ... maybe some others ... }
00:05:42 <Nevoic> Alright, well thanks for all the help guys, I'm getting pretty tired at this point though so I'm going to have to call it. It's 3 AM where I am and I'm weak so I must succumb to my human needs.
00:05:45 <Cale> Then the same type may have multiple AnimationInterface records
00:05:53 <Cale> It's an option you have available to you anyway
00:05:54 <Cale> haha
00:06:05 <Cale> All right, I should have slept an hour ago also
00:06:09 <Cale> good talking to you :D
00:06:14 <Nevoic> You too!
00:48:46 <dminuoso> Is there a way to create singleton types without creating useless data constructors?
00:49:08 <johnw> could you use Proxy?
00:49:23 <johnw> + DataKinds, that is
00:49:45 <dminuoso> johnw: Mm, why would I need DataKinds?
00:50:04 <dminuoso> How would that work?
00:50:45 <johnw> I was thinkingof something like data Nat = O | S Nat  ;  Proxy ('S ('S 'O))
00:51:02 <johnw> you should be able to pass a Proxy of that type, and recover the number 2
00:51:50 <dminuoso> johnw: Ah so your point is to encode singletons as type level naturals instead?
00:52:02 <johnw> yeah, data at the type level associated with a singleton type has only one representation at the value level
00:52:24 <johnw> where by singleton type I just mean something with but one inhabitant
00:52:48 <johnw> Proxy ('S ('S 'O)) has one inhabitant, so if you receive it as a value, you know what it was intended to represent
00:53:12 <dminuoso> johnw: Ah that sentence about "but [with] one inhabit" helped. 
00:53:23 <dminuoso> Okay yeah that makes sense.
00:54:17 <johnw> singletons are just a bijection between an overlapping subset of the value world the type world
00:55:10 <johnw> I believe you can also think of every constructor to a GADT as being a kind of singleton, if they're all uniquely distingished by their type indices
00:57:25 <akr> I've caught an error, how do I retrieve the stack trace associated with it? One thing I could try is invoking `whoCreated` on the caught error, is there a better way? https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Stack.html
00:58:01 <dminuoso> akr: Did you see my note regarding infix type constructors yesterday? :)
00:58:16 <akr> yesterday? I don't think so
00:58:28 <dminuoso> % Left 1 :: Integer `Either` Char
00:58:28 <yahb> dminuoso: Left 1
00:58:36 <dminuoso> Ohh now that makes me wonder
00:58:54 <dminuoso> % data a `EitherT` b = LeftT a | RightT b
00:58:54 <yahb> dminuoso: 
00:58:57 <dminuoso> Wew! 
00:59:09 <johnw> :r
00:59:15 <akr> oh yeah I did see that one, dminuoso
00:59:36 <akr> tbh I'm not a huge fan of infix Either
00:59:55 <dminuoso> akr: Well yeah. It was just the first 2-arity type constructor that came to mind.
01:00:02 <dminuoso> akr: But perhaps this could be useful for some type families
01:00:37 <dminuoso> % type family Add (x :: Nat) (y :: Nat) :: Nat
01:00:37 <yahb> dminuoso: ; <interactive>:413:23: error: Not in scope: type constructor or class `Nat'; <interactive>:413:34: error: Not in scope: type constructor or class `Nat'; <interactive>:413:42: error: Not in scope: type constructor or class `Nat'
01:00:43 <akr> too bad you can't use operators here
01:00:54 <akr> % data a (+) b = L a | R b
01:00:54 <yahb> akr: ; <interactive>:414:6: error: Malformed head of type or class declaration: a (+) b
01:01:06 <dminuoso> akr: You should, if they start with a colon
01:01:13 <dminuoso> % data a :+ b = L a | R b
01:01:13 <yahb> dminuoso: 
01:01:16 <akr> ah I see
01:01:32 <dminuoso> akr: (servant makes great use of this)
01:02:19 <dminuoso> % data Nat = Z | S Nat
01:02:19 <yahb> dminuoso: 
01:02:24 <dminuoso> % type family Add (x :: Nat) (y :: Nat) :: Nat
01:02:24 <yahb> dminuoso: 
01:03:12 <dminuoso> % :kind! Z `Add` S Z
01:03:12 <yahb> dminuoso: Z `Add` S Z :: Nat; = 'S 'Z
01:03:17 <dminuoso> akr: Not too shabby, Id say.
01:03:53 <akr> well it's not Agda, but it's okay I suppose :)
01:05:26 <dminuoso> akr: And apparently type operator type families are allowed too, so this is great.
01:06:31 <dminuoso> % :kind!  S (S Z) :+ S Z
01:06:31 <yahb> dminuoso: S (S Z) :+ S Z :: Nat; = 'S ('S ('S 'Z))
02:05:56 <Shockk_> hello, I'm trying to use makeFields from lens in my project, but as soon as I try and make the fields for one of my data types, I start getting a bunch of duplicate symbol errors for llvm (a separate part of the project makes use of llvm-hs)
02:06:12 <Shockk_> has anyone experienced this before, or might anyone have insight into how to resolve it?
02:11:12 <Shockk_> like, this is all I need to have in my project for the errors to occur
02:11:13 <Shockk_> https://gist.github.com/shockkolate/90fd4778e364e8e9872db6476b123601
02:11:44 <Shockk_> it seems if I use makeFields at all, it causes the llvm symbols to be duplicated
02:12:37 * hackage transformers 0.5.5.2 - Concrete functor and monad transformers  https://hackage.haskell.org/package/transformers-0.5.5.2 (RossPaterson)
02:23:45 <dminuoso> Shockk_: Can you share the command you are using to build your program as well as the output? Use a gist or similar feature please.
02:25:29 <Shockk_> dminuoso: I found what appears to be the same issue: https://github.com/llvm-hs/llvm-hs/issues/95
02:25:56 <Shockk_> seems like it's because I'm linking llvm statically, and it doesn't manifest when I change the flag to build it as shared
02:44:07 * hackage dynamic 0.0.7 - A dynamic type for Haskell  https://hackage.haskell.org/package/dynamic-0.0.7 (ChrisDone)
04:05:37 <kuribas> is there a function (a -> a) -> Either e a -> Either e a -> Either e a, that combines valid values?
04:07:08 <dminuoso> kuribas: liftA2 ?
04:07:14 <kuribas> :t (Endo `on` (<>))
04:07:16 <lambdabot> error:
04:07:16 <lambdabot>     • Couldn't match type ‘Endo a’ with ‘(a -> a) -> c’
04:07:16 <lambdabot>       Expected type: (a -> a) -> (a -> a) -> c
04:07:35 <kuribas> dminuoso: no, that gives an error if one of them is an error
04:07:51 <dminuoso> kuribas: What behavior do you want if one of them is left?
04:08:08 <kuribas> dminuoso: return the other
04:08:39 <dminuoso> kuribas: And what would that function `(a -> a)` be applied to of both are Right?
04:08:44 <kuribas> dminuoso: yeah
04:08:45 <dminuoso> Or should that be `a -> a -> a` ?
04:08:51 <kuribas> dminuoso: ah right
04:09:00 <kuribas> a -> a -> a
04:11:06 <fendor> @let foo f e a = liftA2 f e a <|> e <|> a
04:11:08 <lambdabot>  Defined.
04:11:11 <fendor> :t foo
04:11:12 <lambdabot> Alternative f => (a -> a -> a) -> f a -> f a -> f a
04:11:37 <kuribas> ah, nice :)
04:11:55 <fendor> > foo (+) (Right 3) (Right 5)
04:11:57 <lambdabot>  error:
04:11:57 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M598475527242...
04:11:57 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
04:12:03 <fendor> > foo (+) (Right 3) (Right 5 :: Either String Int)
04:12:04 <lambdabot>  Right 8
04:12:11 <fendor> > foo (+) (Right 3) (Left "String" :: Either String Int)
04:12:13 <lambdabot>  Right 3
04:13:28 <fendor> > foo (+) (Left "me") (Left "String" :: Either String Int)
04:13:30 <lambdabot>  Left "String"
04:13:58 <fendor> @pl  liftA2 f e a <|> e <|> a
04:13:58 <lambdabot> liftA2 f e a <|> e <|> a
04:14:59 <siraben> How do I chose what file is loaded when I run "cabal repl"?
04:15:20 <dminuoso> siraben: Mmm, shouldn't it be all exposed modules?
04:15:22 <phadej> siraben: it's the first of exposed-modules (or Main)
04:15:31 <dminuoso> Oh just the first?
04:16:04 <fen> ok, so still searching for a way to make a higer order generalisation of; type SuperState s a = s -> Maybe (a,Maybe s) 
04:16:16 <phadej> dminuoso: it loads everything, but makes only the first current
04:16:20 <phadej> it = cabal
04:16:41 <siraben> I see
04:16:45 <siraben> It's just the first
04:16:59 <siraben> First of the other-modules field in the .cabal repl
04:17:00 <siraben> file*
04:17:54 <fen> normally stream fusion is nested on a "stream of streams" (here the terminology "stream" is similar to a "state encoding" that is (s,s->Maybe (Maybe a,s)) - which we can simplify by not considering "skips", giving (s,s->Maybe (a,s))
04:18:36 <fen> but thats no good here, we dont just have a state which outputs states... it needs the penultimate state of the last inner unfold...
04:20:08 <fen> so we dont just have (s1,(s1->((s2,s2->(a,s2)),s1))), thats; StateEncoding s1 (StateEncoding s2 a)
04:20:23 <fen> this is whats used to define mapConcat in; https://www.researchgate.net/publication/221241130_Stream_Fusion_From_Lists_to_Streams_to_Nothing_at_All
04:21:32 <fen> here, there is no obligation to exhaust the inner state (StateEncoding s2 a), it can simply be discarded, and a new version can be produced by the external state
04:24:49 <fen> this is unlike; (s,s -> Maybe (a,Maybe s)). here there is only one state s, and if it fails, ie given s returns Nothing, then it would need to be updated or replaced in order to continue to use the state function. this way we can halt, and use the most recent returned state as an argument to a state updating function.
04:25:42 <fen> by allowing the last state of the inner loop to be made available in creating the next state, this is different from the streams version above, which just has a state giving the new states
04:27:38 <fen> there should be some way to merge these datatypes together, to give something like Stream, but that takes some additional value to return the next inner state, which can be some arbitrarily produced value returned while unfolding the inner state, such as the last viable state as the SuperState example above
04:28:05 <fen> .
04:35:07 * hackage haskoin-store 0.13.1 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.13.1 (xenog)
04:50:10 <fen> the idea of working with (d,s) -> (a,(d,s)) is to factor the state into a variable "directions" and a constant "state"
04:51:12 <fen> then this idea of "updating the state" and "keeping the most recent state" is seen as \ d (_,s) -> (d,s), ie providing new directions
04:54:56 <fen> but really it does not need to be that all the dynamic carried information of a state be factored into the directions. eg a random number generator that stores how many numbers it has produced, taking and returning a new seed value, "d" is the seed, but s is not constant, as it still stores the number of values produced
04:56:37 <fen> really `d' just needs to be whatever needs to be provided to stop it jamming, or equivalently, to start the next block of nested outputs
04:58:55 <fen> this gives; (d,s) -> Maybe (a,Maybe (d,s))
04:59:15 <fen> which is still unlike StateEncoding s1 (StateEncoding s2 a)
04:59:52 <fen> but at least it allows the information needed to "update" the state to be specified
05:10:54 <fen> maybe thats just d -> s -> s though...
05:13:23 <fen> basically we just want to provide new "directions", and have the state run until it halts, giving ([a],s)
05:54:42 <fen> here is some code to illustrate this; https://pastebin.com/raw/2ieP43Nh
05:55:04 <Cahphah3> Can somebody explain to me why the definition of dropWhile with fold from the Hutton's "tutorial on universality and expressiveness of fold" works? It's on page 9, or here: https://pastebin.com/raw/dCB6YnYn
05:55:46 <Cahphah3> When p x is false, we return x : xs as our new ys; but xs is the whole list we traversed so far, so that doesn't drop anything, does it?
05:58:02 <fen> @let dropWhile' p = fold f v where f x (ys, xs) = (if p x then ys else x : xs, x : xs); v = ([ ], [ ])
05:58:04 <lambdabot>  Defined.
05:58:24 <fen> > dropWhile' (>5) [1..10]
05:58:26 <lambdabot>  error:
05:58:26 <lambdabot>      • Couldn't match expected type ‘[Integer] -> t’
05:58:26 <lambdabot>                    with actual type ‘([Integer], [Integer])’
05:58:53 <fen> > dropWhile (>5) [1..10]
05:58:55 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
05:59:10 <fen> > dropWhile (<5) [1..10]
05:59:12 <lambdabot>  [5,6,7,8,9,10]
05:59:17 <c_wraith> Cahphah3, what is fold? 
05:59:20 <int-e> :t dropWhile'
05:59:21 <lambdabot> Foldable ((->) a) => (a -> Bool) -> ([a], [a])
05:59:57 <c_wraith> (it's certainly not the same fold that fen used)
06:00:11 <fen> right
06:00:50 <Cahphah3> c_wraith: https://wiki.haskell.org/Fold (fen didn't call dropWhile' with the correct arguments as you can see from the type error)
06:01:42 <c_wraith> no, what *is* fold?
06:01:47 <c_wraith> is it foldr?
06:01:49 <int-e> :t fold
06:01:50 <lambdabot> (Monoid m, Foldable t) => t m -> m
06:01:53 <int-e> the monoid one
06:02:10 <fen> yeah, but its type doesnt match dropWhile... and its not clear how it works, so this is kind of an impossible question
06:02:13 <c_wraith> int-e, not in the code pasted
06:02:47 <MarcelineVQ> (yes it's foldr)
06:03:01 <MarcelineVQ> http://www.cs.nott.ac.uk/~pszgmh/fold.pdf
06:04:21 <c_wraith> Cahphah3, I think you're misparsing it
06:04:32 <fen> fold :: (α → β → β) → β → ([α] → β)
06:04:39 <fen> so its foldr
06:04:50 <fen> @let dropWhile' p = foldr f v where f x (ys, xs) = (if p x then ys else x : xs, x : xs); v = ([ ], [ ])
06:04:50 <c_wraith> Cahphah3, f return a pair, and only the first element of depends on p
06:04:51 <lambdabot>  .L.hs:171:21: error:
06:04:51 <lambdabot>      • Couldn't match type ‘([a], [a])’ with ‘t a -> ([a], [a])’
06:04:51 <lambdabot>        Expected type: a -> ([a], [a]) -> t a -> ([a], [a])
06:05:01 <fen> :(
06:05:25 <int-e> @undef
06:05:25 <lambdabot> Undefined.
06:05:31 <Cahphah3> c_wraith: that is true (I've stated that in the question)
06:05:35 <int-e> @let dropWhile' p = foldr f v where f x (ys, xs) = (if p x then ys else x : xs, x : xs); v = ([ ], [ ])
06:05:36 <lambdabot>  Defined.
06:05:49 <int-e> :t dropWhile'
06:05:49 <fen> > dropWhile' (<5) [1..10]
06:05:50 <lambdabot> Foldable t => (a -> Bool) -> t a -> ([a], [a])
06:05:51 <lambdabot>  ([5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
06:06:20 <c_wraith> Cahphah3, also... xs and ys are... uh... from the future. :)
06:06:51 <c_wraith> Cahphah3, they aren't the values seen so far, they're the result of folding the *rest* of the input
06:07:11 <int-e> laziness plays (seemingly) magical tricks with the evaluation order sometimes
06:07:16 <Cahphah3> c_wraith: ah! Then it makes sense, yeah
06:07:42 <c_wraith> int-e, that's actually not very lazy with the pattern match in the tuple.
06:07:51 <c_wraith> *on the tuple
06:08:03 <int-e> ... true. ouch.
06:08:36 <vfaronov> why doesn't GHC use my displayException? https://repl.it/repls/FewUnusedSlope
06:08:37 <int-e> > dropWhile' (<5) [1..]
06:08:44 <lambdabot>  mueval-core: Time limit exceeded
06:08:46 <int-e> > dropWhile (<5) [1..]
06:08:48 <lambdabot>  [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31...
06:08:58 <Cahphah3> Yep, it's not lazy.
06:09:01 <c_wraith> just throw in a ~ and it'll be good.
06:09:08 <fen> > fst $ dropWhile' (<5) [1..]
06:09:14 <int-e> c_wraith: I stopped analysing when I relazied that the code would lose all sharing
06:09:15 <lambdabot>  mueval-core: Time limit exceeded
06:09:19 <vivit> So I'm trying to build MazesOfMonad, and I'm getting some missing dependency warnings
06:09:30 <vivit> for example, "random -any"
06:09:31 <int-e> (compared to the naive `dropWhile' p xs = (dropWhile p xs, xs)`)
06:10:11 <vivit> But then when I $ cabal install random, it says I already have random-1.1 installed
06:10:21 <c_wraith> dropWhile isn't an efficient catamorphism, yeah
06:10:39 <int-e> (and of course the list elements would still be shared. but duplicating the spine is bad enough :) )
06:10:40 <vivit> What's the deal with that?
06:10:53 <c_wraith> it should be an efficient paramorphism, though!
06:11:20 <int-e> vivit: "trying to build" <-- what are you doing, exactly?
06:11:36 <vivit> I downloaded the source and I'm trying to build it
06:11:45 <vivit> Cloned it from github
06:11:55 <int-e> using cabal[-install]?
06:12:15 <vivit> No, by downloading it from github and running the Setup.lhs provided
06:12:31 <vivit> I don't know whether the error message I'm getting is standard or local
06:13:10 <vivit> grep -r doesn't find the phrase "missing dependencies", so I'm guessing it's the former
06:15:00 <int-e> vivit: I have not done that in ages... I usually do cabal configure; cabal build  stuff. It's possible that Setup.lhs defaults to a global install still and `random` is installed as a user packaged? try  Setup.lhs configure --user
06:15:00 <vivit> I've tried $ cabal install MazesOfMonad, but I get ambiguous occurrence errors
06:15:56 <vivit> ah, cabal configure;cabal build seems to be working
06:15:59 <vivit> Thanks!
06:18:37 <c_wraith> yeah, dropWhile is an efficient paramorphism. funny how I never noticed it's a good example of the practical difference between the theoretically equally-powerful cata and para
06:19:29 <dminuoso> % :t dropWhile
06:19:29 <yahb> dminuoso: ; <interactive>:1:1: error:; Ambiguous occurrence `dropWhile'; It could refer to either `V.dropWhile', imported from `Data.Vector'; or `Prelude.dropWhile', imported from `Prelude' (and originally defined in `GHC.List')
06:19:35 <dminuoso> % :t Prelude.dropWhile
06:19:35 <yahb> dminuoso: (a -> Bool) -> [a] -> [a]
06:20:02 <Solonarv> % :m - V
06:20:02 <yahb> Solonarv: ; <no location info>: error:; Could not find module `V'; It is not a module in the current program, or in any known package.
06:20:12 <Solonarv> % :m - Data.Vector
06:20:12 <yahb> Solonarv: 
06:20:21 <Solonarv> % import qualified Data.Vector as V
06:20:21 <yahb> Solonarv: 
06:20:42 <c_wraith> oh, hah. missed the "qualified" before. I hate when I do that.
06:21:16 <Solonarv> yeah; good thing you can "un-import" !
06:26:52 <Shockk_> hmm does anyone know how I can perform an `Except e` inside an `ExceptT e IO`?
06:27:18 <fen> ok, this is what was meant above; https://pastebin.com/raw/0iFFQzGz
06:28:37 * hackage http-client 0.6.3 - An HTTP client engine  https://hackage.haskell.org/package/http-client-0.6.3 (MichaelSnoyman)
06:29:37 * hackage http-conduit 2.3.7 - HTTP client package with conduit interface and HTTPS support.  https://hackage.haskell.org/package/http-conduit-2.3.7 (MichaelSnoyman)
06:29:39 * hackage ghci-dap 0.0.12.0 - ghci-dap is a GHCi having DAP interface.  https://hackage.haskell.org/package/ghci-dap-0.0.12.0 (phoityne_hs)
06:30:09 <fen> nudgeState requires a state encoding of the thing used to update the penultimate state
06:30:33 <fen> probably would be better if it could use an arbitrary thing returned from unfolding... but at least this gives the idea
06:30:37 * hackage haskell-debug-adapter 0.0.30.0 - Haskell Debug Adapter.  https://hackage.haskell.org/package/haskell-debug-adapter-0.0.30.0 (phoityne_hs)
06:31:18 <fen> it probably wouldnt appear like zipwith in that case
06:40:48 <Shockk_> hm in fact does anyone know if I can eliminate `r` in the following type alias?
06:41:07 <Shockk_> type Analysis r = forall m. Monad m => ExceptT ErrorContext m r
06:41:46 <Shockk_> I'd like to just eliminate r from both sides but then ghc requires one more argument to ExceptT ErrorContext m from me
06:42:04 <dminuoso> Shockk_: Is newtype an option for you?
06:42:41 <fen> you can make type synonyms of kind * -> * things just fine
06:42:42 <dmwit> Shockk_: Could you consider type Analysis = ExceptT ErrorContext instead?
06:43:45 <Shockk_> dminuoso: not sure how to use that in the context of this, I haven't really used newtype
06:43:55 <Shockk_> fen: is there an extension I have to enable?
06:44:14 <dmwit> Shockk_: For your previous question:
06:44:20 <Shockk_> dmwit: this is what I had previously but to achieve the same effect I'd have to add a Monad m constraint to every function I have
06:44:21 <dmwit> :t mapExceptT (return . runIdentity)
06:44:22 <lambdabot> Monad n => ExceptT e' Identity b -> ExceptT e' n b
06:45:08 <dmwit> (and note `Except e ~ ExceptT e Identity`)
06:45:41 <vivit> Is there any way to install old versions of a package with cabal?
06:45:45 <dmwit> Shockk: Given that context, are you double-plus sure that the type alias you are proposing actually means what you want it to mean?
06:45:55 <dmwit> I would be sort of surprised if it did.
06:46:07 <Shockk> dmwit: hm, no I'm very unsure actually
06:46:20 <dmwit> vivit: Certainly. There's `cabal install foo --constraint "foo=3.1.4"`, and the shorthand `cabal install foo-3.1.4`.
06:46:30 <dmwit> oops
06:46:33 <dmwit> two equals signs
06:46:40 <dmwit> --constraint "foo==3.1.4"
06:47:22 <fen> no you cant expect to use the constraint of a type synonym to propagate into the type signature it appears in 
06:47:42 <fen> it would throw an error, saying it needs you to write the constraint yourself
06:47:59 <Shockk> hm okay
06:49:59 <dmwit> Shockk: If you want to do it the mtl way, switch from `Monad m => ... -> ExceptT ErrorContext m a` to `MonadError ErrorContext m => ... -> m a`.
06:50:08 <vivit> I'm getting an error "conflict: requires pkg-config package gtk+-2.0-any, not found in the pkg-config database"
06:51:11 <vivit> Is that the general command pkg-config?
06:51:14 <dmwit> Shockk: Then if you *really* want to you can make a type alias to shorten the context. e.g. `type ECtx = MonadError ErrorContext` and then the type signatures take the form `ECtx m => ... -> m a`.
06:51:23 <dmwit> Shockk: I don't think you'll get it much more concise than that.
06:51:33 <dmwit> vivit: It is.
06:51:51 <Shockk> dmwit: ah okay, that makes sense, thanks
06:52:01 <dminuoso> It's mildly amusing that a Haskeller makes it to forall quantification before knowing what a newtype is.
06:53:48 <fen> its because they have instinctive desire for type level lambdas
06:57:59 <dminuoso> Shockk: On an unrelated topic.. you should probably get acquainted with newtypes. Rarely are type aliases the right tool or useful. :)
07:01:37 <davean> dminuoso: Oh I find type aliases great for documentation
07:06:07 * hackage shh 0.3.0.1 - Simple shell scripting from Haskell  https://hackage.haskell.org/package/shh-0.3.0.1 (lukec)
07:06:46 <fen> and you cant have typeclass synonyms with newtypes?
07:11:03 <dmwit> newtype TypeclassSynonym a = TypeclassSynonym (Dict (Monoid a, Ord a)) -- ;-)
07:11:20 <Solonarv> hah
07:11:51 <Solonarv> or: class (Monoid a, Ord a) => TypeclassSynonym a; instance (Monoid a, Ord a) => TypeclassSynonym a
07:12:15 <Solonarv> ^- this one is actually useful; it behaves much like a type synonym, but you can partially apply it
07:20:38 <fen> ok, so the good thing about having StateEncoding (d,s) a instead of just having d -> s -> s, is that it makes it clear that without providing directions, the state cannot progress, unlike the nudge version where this is not clear
07:21:37 <fen> Solonarv: can you use that to solve defunctionalisation?
07:22:31 <Solonarv> Hm, maybe? seems like it'd be more cumbersome than the standard approach, though
07:22:51 <fen> like, I cant make an instance where one of the parameters is a partially applied type family
07:22:59 <Solonarv> (which uses an 'Apply' or 'Eval' type family)
07:23:08 <Solonarv> oh! no, I don't think it helps with that
07:23:41 <fen> instead, the typechecker needs the defunctionalised version, which isnt good
07:25:33 <fen> have resorted to just using phantom parameters to datatypes to mimic closed type families of one case
07:27:21 <Solonarv> yeah the lack of type-level lambdas is sort of annoying
07:27:56 <Solonarv> can't really have them *and* have good type inference though, which is why Haskell doesn't have them
07:28:52 <Shockk> dminuoso: you're probably right, I have a knowledge gap there
07:30:00 <Shockk> though for my particular problem, I now rewrote the code to use MonadError
07:31:58 <Solonarv> even something as simple as 'fmap reverse ("hi", [1, 42])' becomes problematic if we allow type lambdas everywhere: do we mean the 'Functor ((,) e)' instance, or the 'Functor (Λa. (a, e))' instance?
07:36:10 <fen> would that need some kind of TypeApplications to specify which instance was to be used like "via" ?
07:36:55 <fen> (fmap @"via" Functor ((,) e)) reverse ("hi", [1, 42])
07:39:26 <fen> like, isnt the arbitrary choice of fmap actually acting on the snd almost less intuitive than throwing an error saying it doesnt know which side to fmap over?
07:39:56 <Taneb> Less intuitive, but also a lot less useful
07:40:15 <Taneb> Although I guess with TypeApplications...
07:40:19 <fen> well just use bifunctor, that actually does what its supposed to
07:40:29 <Solonarv> the problem is that you would have to specify which instance you mean every time you use any class method
07:41:05 <fen> or have synonyms such as to remove ambiguity. like it wouldnt complain about ambiguity in the bifunctor instance over pair as there is only one
07:41:22 <Solonarv> ...any class method where the class is over non-* kinds, anyway
07:41:30 <fen> well unless you considered swapping them backwards i suppose
07:41:40 <fen> hmm...
07:42:31 <fen> anyway, why would it start generating all possible lambda instances? shouldnt it just check over the instances the user specifies?
07:42:47 <Solonarv> for another example, consider the instances 'Monad ((->) e)' and 'Monad (Λa. s -> (s, a))'
07:43:14 <Solonarv> if you use >>= and the argument's type is 'e -> (a, e)', which instance should be used? both could match!
07:45:36 <fen> right so we have a newtype for state, and use this kind of cheat for reader
07:45:55 <fen> by rightmost parameter as an arbitrary default choice
07:46:19 <Solonarv> even worse: if you have (x :: Maybe Int) >> (y :: Maybe Int), you can't even unify the 'm' in '(>>) :: m a -> m b -> m b' with 'Maybe', or the 'a' and 'b' with Int - the typechecker becomes completely useless!
07:46:37 <Solonarv> it's not an arbitrary choice; we *can't* choose the left parameter
07:46:55 <Solonarv> this is a bit of a quirk, but it's entirely consistent within the language itself
07:46:58 <fen> because its already partially applied?
07:47:11 <fen> but thats just partially applying all but one parameter from right to left
07:47:23 <Solonarv> because of partial application, yes - partial application lets you drop parameters from the right only
07:47:51 <Solonarv> if you want to drop other parameters you have to reshuffle them using lambdas/flip/whatever
07:47:56 <fen> it would be better to write (Λe e'. e -> e')
07:48:13 <Solonarv> ah, but that has the wrong kind to be a Monad instance
07:49:05 <fen> ok so, ((Λe e'. e -> e') x) or (flip (Λe e'. e -> e') x)
07:49:26 <Solonarv> one might imagine an extension that lets you write these sorts of type lambdas but only if they're something you could write with partial application alone
07:49:38 <Solonarv> (keep in mind that we don't have type-level flip either)
07:50:04 <Solonarv> or rather, we do, but we can't partially apply it
07:50:24 <Solonarv> 'Flip f x y' is okay, 'Flip f' is not
07:50:28 <fen> but the problem then is there are 2 instances
07:50:41 <fen> ((Λe e'. e -> e') x) or ( (Λe' e. e -> e') x)
07:51:33 <fen> why would it think that both were written?
07:51:35 <Solonarv> well no, the second one has the wrong variance
07:51:53 <fen> ??
07:52:19 <Solonarv> the second one is Contravariant, not Functor
07:52:22 <fen> if the user tried to write both of those they would get some overlapping or undecidable error, so they would only be able to write one, and this is the one the typechecker would use
07:52:54 <Solonarv> well, now you're making the typechecker prove whether arbitrary lambdas can overlap
07:53:02 <Solonarv> this is clearly very hard!
07:53:18 <fen> hmm, well at least that makes the problem seem clearer 
07:53:53 <Solonarv> there are ways to have type lambdas without type inference being completely shot, but the one I'm aware of still doesn't allow instances of e.g. Monad for a type lambda
07:54:06 <fen> anyway, to use TypeApplications it would need to have some sort of AllowAmbiguousTypeLevelLambdas thing going go
07:54:08 <fen> on*
07:54:52 <Solonarv> instead it distinguishes functions into "matchable", where we can take apart 'f a ~ g b' into 'f ~ g, a ~ b'; and "unmatchable", where we can't do that
07:55:59 <fen> you would expect the kind of errors you get when using AloowAmbiguousTypes without having specified the TypeApplication
07:57:44 <delYsid> I am looking for a function f :: Eq a => a -> [a] -> [(a, Int)] which would count the occurances of every a in a list.  Is there something like that somewhere?
07:58:20 <Solonarv> delYsid: I don't think there's anything in base
07:58:20 <fen> some combination of group and length?
07:58:38 <Solonarv> doesn't quite work:
07:58:38 <Solonarv> > group [1, 1, 2, 1, 1]
07:58:40 <lambdabot>  [[1,1],[2],[1,1]]
07:59:08 <Taneb> :t map length . group . sort
07:59:09 <lambdabot> Ord a => [a] -> [Int]
07:59:16 <Taneb> :t map (id *** length) . group . sort
07:59:17 <lambdabot> error:
07:59:17 <lambdabot>     • Couldn't match type ‘(b, [a0])’ with ‘[a]’
07:59:17 <lambdabot>       Expected type: [a] -> (b, Int)
07:59:24 <Solonarv> if you're okay with upgrading to an Ord a constraint you can do
07:59:24 <Solonarv> map (head &&& length) . group . sort
07:59:24 <Taneb> :t map (id &&& length) . group . sort
07:59:25 <lambdabot> Ord a => [a] -> [([a], Int)]
07:59:37 <Taneb> (I was going to get there eventually ;P)
07:59:49 <Solonarv> (head is safe here, because group's result doesn't contain empty lists)
07:59:50 <fen> anyway if its just for selecting which arity / parameter position to use, the @via would just need a Nat parameter...
08:00:02 <MarcelineVQ> what is the first 'a' used for?
08:00:22 <delYsid> cool, that helps.
08:01:41 <Solonarv> you can also do:
08:01:41 <Solonarv> % :t M.fromListWith (+) . map (,1)
08:01:41 <yahb> Solonarv: ; <interactive>:1:22: error:; Ambiguous occurrence `map'; It could refer to either `M.map', imported from `Data.Map' (and originally defined in `Data.Map.Internal'); or `Prelude.map', imported from `Prelude' (and originally defined in `GHC.Base')
08:01:46 <Solonarv> % :t M.fromListWith (+) . fmap (,1)
08:01:46 <yahb> Solonarv: (Ord k, Num a) => [k] -> Map k a
08:02:03 <Solonarv> that will give you a Map instead of an association list, which might be more useful
08:02:16 <Solonarv> % histo = M.fromListWith (+) . fmap (,1)
08:02:16 <yahb> Solonarv: 
08:02:21 <fen> and it could default to leftmost if unspecified
08:02:26 <fen> rightmost*
08:02:35 <fen> as ususal, so it wouldnt break anything
08:02:44 <mpickering> I type `stack repl` and the error is `error: attribute 'ghc843' missing, at (string):1:43`
08:02:54 <mpickering> What is stack trying to achieve and why is it broken?
08:03:01 <dmwit> delYsid: If you're okay with Ord instead of Eq, then `fromListWith (+) [(x,1) | x <- xs]`.
08:03:30 <Solonarv> dmwit: I suggested that already (well, I wrote it differently)
08:03:32 <dmwit> delYsid: ...or import Data.Bag and just use `fromList`. ;-)
08:03:41 <Solonarv> and the group . sort solution also needs Ord
08:04:27 <Taneb> There will be an O(n^2)-ish algorithm that just needs Eq but there's nothing for it in base
08:04:53 <Solonarv> more generally, you need Ord to not be terribly slow (= O(n^2)) at grouping together non-adjacent equal values
08:05:03 <fen> hmm for higher arity things it would need a way to permute the order of arguments... like, combinations of flip and (.) probably, maybe there is a concise syntax for that... maybe something like (Λ a b c -> b c a) or something
08:05:07 <Solonarv> (or something fancier, e.g. radix sort; not really applicable here though)
08:05:43 <fen> so you could just write @via flip
08:06:28 <fen> is that right? is it just permutations thats the problem?
08:06:48 <Taneb> Compositions, too
08:07:26 <dminuoso> mpickering: Are you using nix integratoin?
08:07:42 <mpickering> I am using nixos
08:07:44 <mpickering> so perhaps?
08:08:06 <Peppep> What plugin(s) would you recommend for Haskell in VS Code? On Ubuntu if it matters
08:08:08 <Taneb> fen: consider \x -> Either Int (x, Bool)
08:08:39 <Taneb> There's... four? five? different fmaps that could apply there
08:09:07 <dminuoso> mpickering: Just asking because it sounds like an error from nix.
08:09:14 <fen> yeah but there is one cannonical ordering to the way the parameters distribute over those composed things right?
08:10:26 <mpickering> dminuoso: Right but I have no nix files in this repo which mention ghc843
08:10:58 <dminuoso> mpickering: Is ghc843 perhaps the compiler from your lts resolver?
08:11:11 <mpickering> I don't know
08:11:28 <mpickering> I should try updating the resolver?
08:11:44 <dminuoso> mpickering: Are you using `nix: { enable: true }` in your stack.yml?
08:11:47 <mpickering> this error shouldn't happen though, it seems like they failed to pin a nixpkgs version
08:11:50 <fen> \x -> Either Int (x, Bool) = (\x y-> (\y -> Either Int y) . (\ y -> x,y)) Bool
08:11:54 <mpickering> no but I think that's enabled by default on nixos
08:11:59 <dminuoso> Ah that might be.
08:12:12 <fen> and so on for the Int...
08:12:15 <dminuoso> mpickering: Im thinking that if you dont have the GHC version from the resolver available in your nixpkgs, it could probably produce funky errors.
08:13:01 <dminuoso> mpickering: So that sounds like your assumption about failing to pin a nixpkgs version could be right.
08:15:20 <fen> @pl \x -> (,) 1 (x, True)
08:15:20 <lambdabot> (,) 1 . flip (,) True
08:15:57 <mpickering> I updated the resolver and it works so just seems like another bug in stack
08:16:23 <fen> hmm, that doesnt put all the arguments to the right...
08:16:59 <fen> argh this is annoying! it would work though right? 
08:21:11 <fen> anyway, why does the existence of type level lambdas mean there would be instances even for Functor (flip (,) e)
08:21:49 <fen> it would only be if the user specified these that they would want to be able to choose them using @via
08:22:27 <fen> the point is that the type level lambda alone does not generate all these overlapping instances 
08:40:07 * hackage telega 0.1.1 - Telegram Bot API binding  https://hackage.haskell.org/package/telega-0.1.1 (iokasimovmt)
08:43:44 <tsizz> curious question to python users: how do you think list comprehension in haskell compares to python?
08:43:58 <tsizz> ive looked a little at haskells list comprehension
08:44:03 <tsizz> seems very powerful
08:45:48 <tabaqui> in python you can use it for set and dict collections, but in haskell - with any Monad (with correct extension)
08:46:46 <tsizz> tabaqui: not sure what monad is yet, but your saying haskell's is more flexible?
08:46:54 <tabaqui> much more
08:47:08 <dminuoso> tabaqui: Pythons list comprehension was inspired by Haskells list comprehension.
08:47:08 <tsizz> tabaqui: okay thanks
08:47:25 <tabaqui> tsizz: check out 13.3.13-13.3.15 here https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/lang.html
08:47:28 <tsizz> was haskells inspired by someone else
08:47:40 <tabaqui> dminuoso: didn't know that
08:48:03 <tabaqui> well, that explains a lot
08:48:11 <dminuoso> Or. tsizz should have received that actually. :)
08:48:28 <tsizz> ?
08:48:36 <dminuoso> tsizz: Pythons list comprehension was inspired by Haskells list comprehension.
08:48:56 <tsizz> dminuoso: mhm but what inspired Haskells?
08:49:02 <MarcelineVQ> probably Set notation
08:49:02 <tsizz> list comp
08:49:02 <dminuoso> tsizz: Set builder notation I guess.
08:49:15 <tsizz> ah okay
08:49:16 <tsizz> interesting
08:49:27 <dminuoso> tsizz: If you squint a bit, <- looks like ∈
08:49:42 <tabaqui> that is funny, because you cannot use LE to build a set in haskell
08:49:55 <tabaqui> without fromList, I mean
08:49:57 <fen> ok, here is another state encoding with "directions"... https://bpaste.net/show/72c4837460b3
08:51:41 <dminuoso> tsizz: The list comprehension monad interface is fully described by Monad/MonadPlus though, so we have a more powerful and general abstraction on list-comprehensions.
08:52:08 <dminuoso> (List comprehensions offer nicely built in pattern matching though, which can make for really elegant and compact code)
08:52:30 <fen> can you use overloaded lists with list comprehensions for things like trees?
08:52:32 <dminuoso> % [v | Left v <- [Left 'c', Right 1, Right 2, Left 'a']]
08:52:32 <yahb> dminuoso: "ca"
08:52:35 <tabaqui> *12.3.13 - 12.3.15
08:53:12 <dminuoso> fen: Well do-comprehensions?
08:53:32 <dminuoso> (I have yet to see one in the wild though)
08:53:49 <dminuoso> I mean monad comprehensions.
08:53:59 <tabaqui> dminuoso: how does it work without MonadFail?
08:54:06 <tabaqui> your example with Either
08:55:15 <dminuoso> tabaqui: Oh. Somehow I thought that was just a guard in disguise. I guess the difference is not noticeable unless you use monad comprehensions.
08:56:08 <tabaqui> looks like it is a guard
08:56:30 <tabaqui> % do { Left v <- [Left 'c', Right 1, Right 2, Left 'a']; pure v }
08:56:31 <yahb> tabaqui: "ca"
08:56:54 <tabaqui> I dunno, why it is desugareted with guard, but not with fail
08:58:06 <fen> how would that work with a tree?
08:58:17 <dminuoso> tabaqui: How did you determine that?
08:58:55 <tabaqui> dminuoso: it sane :) I'm googling for ghc desugarate flag right now
08:59:50 <tabaqui> oh, output is huge
08:59:50 <fen> cant quite see how the list monad instance is going to work there for a tree, its making the values pure and then concating them?
09:00:06 <tabaqui> fen: define Monad instance for trees
09:00:37 <fen> well if its supposed to be like fold with alternative
09:01:27 <fen> the alternative (<|>) is (++) for list, and for trees its some other thing, like with get and set used like pattern matching on (:)
09:02:14 <tabaqui> maybe join definition will explain more
09:02:16 <dminuoso> Haskell question: What could cause a Haskell *process* to become completely unresponsive?
09:02:22 <dminuoso> (Process in the OS sense)
09:02:25 <tabaqui> you have trees in each tree node
09:02:27 <fen> but yeah, pure isnt going to be much help there because it will make a shapeless tree, need some way to specify where they should be attatched
09:02:31 <tabaqui> and join have to flatten this
09:02:55 <fen> right, join is foldMap (<|>)
09:02:59 <tabaqui> dminuoso: waitForInput and lazy IO at all
09:03:07 * hackage shake 0.17.8 - Build system library, like Make, but more accurate dependencies.  https://hackage.haskell.org/package/shake-0.17.8 (NeilMitchell)
09:03:42 <dminuoso> Its as if the threads are "stuck".. and darn it I dont have a debugger on the system.
09:06:41 <fen> % :t Data.Foldable.foldr (<|>) mzero
09:06:41 <yahb> fen: (Foldable t, MonadPlus f) => t (f a) -> f a
09:07:14 <tabaqui> dminuoso: it is weird, if I read it correctly, then we have "[Left 1, Right 1] >>= (\a -> case a of { Left x -> pure x; _ -> fail void })"
09:07:17 <Taneb> fen: (why not use empty rather than mzero? You only need Alternative, not MonadPlus)
09:07:19 <MarcelineVQ> may as well use empty instead of mzero if you're using <|>
09:07:21 <MarcelineVQ> ehe
09:07:23 <fen> so its just the implementation of (<|>) using get and set like how (++) is defined using (:)
09:07:31 <tabaqui> or it is void#
09:07:48 <fen> Taneb: right
09:08:06 <tabaqui> oh, right, it is MonadFail [Int] instance here
09:08:11 <tabaqui> it is nothing about Either
09:08:20 <Taneb> :t asum
09:08:21 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
09:08:28 <fen> oh yeah, thats it
09:08:35 <tabaqui> right, comprehension requires MonadFail
09:08:54 <fen> oh, for the filter guard thing?
09:09:21 <tabaqui> for pattern matching in comprehensions
09:09:41 <fen> > [x|x<-[1..3], even x]
09:09:43 <lambdabot>  [2]
09:10:08 <tabaqui> guard requires Alternative instance
09:10:27 <Taneb> > [x | Just x <- [Nothing]]
09:10:30 <lambdabot>  []
09:10:35 <Taneb> ^that uses MonadFail
09:10:55 <tabaqui> % [x | x <- Right 1] :: Either Int Int
09:10:55 <yahb> tabaqui: ; <interactive>:476:1: error:; * Couldn't match expected type `Either Int Int' with actual type `[a1]'; * In the expression: [x | x <- Right 1] :: Either Int Int; In an equation for `it': it = [x | x <- Right 1] :: Either Int Int; <interactive>:476:11: error:; * Couldn't match expected type `[a1]' with actual type `Either a0 Integer'; * In the expression: Right 1; In a stmt of
09:10:56 <fen> oh, ok, so filter uses empty, and the fact a pattern match can fail uses MonadFail?
09:11:09 <Taneb> Yes
09:11:16 <tabaqui> in later ghc versions
09:11:18 <fen> nice
09:11:39 <fen> not sure what that is for tree or even list...
09:11:54 <tabaqui> you can try to code this :)
09:12:01 <fen> its just like sequencing a maybe?
09:12:42 <fen> like a traversal to propegate the error to the left of the nested containers?
09:13:47 <tsizz> wait... is haskell like python where True/False have to be capitalized
09:13:59 <fen> oh, its more simple that that its just fail _ = error "fail"
09:14:18 <fen> or fail _ = mzero for a confusing runtime error!
09:14:37 <tabaqui> > [x | x <- Right 1] :: Either Int Int
09:14:39 <lambdabot>  error:
09:14:39 <lambdabot>      • Couldn't match expected type ‘Either Int Int’
09:14:39 <lambdabot>                    with actual type ‘[a1]’
09:14:58 <fen> you tried that before
09:15:28 <tabaqui> tsizz: True and False are data constructors and all data constructors must be capitalized
09:15:42 <tabaqui> but you can define a function true :: Bool; true = True
09:16:13 <tabaqui> s/function/constant
09:16:33 <tabaqui> it is almost the same in haskell
09:23:34 <Cale> tsizz: It helps a lot that data constructors are capitalised and variables are not, because otherwise in pattern matching, you'd just have to know what things were data constructors to determine if a variable was bound or if you were matching a data constructor.
09:27:37 * hackage morley 0.2.0 - Developer tools for the Michelson Language  https://hackage.haskell.org/package/morley-0.2.0 (gromak)
09:34:03 <luftmensch[m]> https://arxiv.org/abs/1806.07366
09:34:03 <luftmensch[m]> > Link to Neural Ordinary Differential Equations (Chen, et al. 2019)
09:34:04 <luftmensch[m]> This is pretty interesting so I figured I’d try implementing it in Haskell. Still pretty new, any suggestions for 
09:34:05 <lambdabot>  error:
09:34:05 <lambdabot>      Data constructor not in scope:
09:34:06 <lambdabot>        Link
09:36:38 <luftmensch[m]> https://arxiv.org/abs/1806.07366
09:36:39 <luftmensch[m]> >Link to Neural Ordinary Differential Equations (Chen, et al. 2019)
09:36:40 <luftmensch[m]> This is pretty interesting so I figured I’d try implementing it in Haskell. Still pretty new, any suggestions for packages or patterns that might be helpful?
09:37:37 <luftmensch[m]> https://arxiv.org/abs/1806.07366
09:37:38 <luftmensch[m]> >Link to Neural Ordinary Differential Equations (Chen, et al. 2019)
09:37:40 <luftmensch[m]> This is pretty interesting so I figured I’d try implementing it in Haskell. Still pretty new, any suggestions for packages or patterns that might be helpful?
09:39:38 <slack1256> luftmensch[m]: your client is sending the same message thrice, check it out
09:41:10 <luftmensch[m]> will do, if there’s a way to delete it server-side go ahead
09:42:06 <slack1256> luftmensch[m]: yeah, irc doesn't work like that
09:42:15 <MarcelineVQ> I like ot point people at the grenade package for an interesting thing related to ANN but idk if it's helpful or not to your specific task
09:42:43 <MarcelineVQ> Mostly due to the vagueness of it :>
09:46:03 <MarcelineVQ> *vagueness of the question
09:49:53 <fen> luftmensch[m]: yeah this seems reasonable, what have you got so far?
09:52:29 <fen> MarcelineVQ: yeah, good shout for grenade. nice use of type level grid dimension specifications, and a good api
09:52:50 <fen> but probably not the eaisiest to convert to a custom implementation using differentials
09:53:00 <fen> maybe frp would be a place to start
09:53:49 <fen> but maybe thats not the right thing to jump to each time continuous interpolation / ode's are encountered 
09:54:48 <fen> but yeah with too vague a question it wouldnt be possible to advise
09:56:23 <fen> anyway that approach seems quite strange, woundt expect arbitrary neural connections to have a continuous version, cf crossings
09:57:34 <fen> there is no mention of a proof of universal approximation, are you convinced this is even a sound theoretical approach? 
10:01:35 <fen> maybe the work on automatic differentiation in haskell might be a good place to start
10:04:58 <fen> and yeah, anything that uses something like eigensystem realization is great, so an ode solver network is certainly a good idea, just not sure if this is fully developed
10:38:05 <luftmensch[m]> fen: 
10:38:05 <luftmensch[m]> >anyway that approach seems quite strange, woundt expect arbitrary neural connections to have a continuous version, cf crossings
10:38:06 <luftmensch[m]> yeah, it’s worth looking at the paper (or one of the many summaries out there) for the motivation, but the short of it is: RNN’s take the form of Euler’s method for solving differential equations (integrating across the direction of the layers), so this method generalizes the problem to use any ODE solver
10:38:46 <fen> riiight
10:39:46 <fen> wouldnt that be continuous time as opposed to continuous depth?
10:43:20 <fen> like, for a finite difference scheme we have the cfl condition which states that it is stable as long as the spacial resolution is not wider than the short time resolution multiplied by the velocity of information propegation
10:44:00 <fen> otherwise, information travels too fast, in the short time step, covering a wide distance between adjacent grid points
10:44:39 <fen> that is, when we use eulers method to step forwards in time, the change is approximated by local gradients which must be high enough resolution
10:45:11 <fen> now, if you have random connections between neurons, then this is going to give arbitrarily fast information propegation
10:45:39 <fen> along characteristics, and we would have no resolution bound to guarantee stability
10:46:01 <fen> basically proposing the approach be modified for deep convolutional neural nets
10:46:24 <fen> taking into consideration gradient across the layers as well as down through them
10:47:06 <fen> otherwise the cross between continous levels, and scrambled connections of "arbitrary steepness" seems like a recipe for instability  
10:47:35 <fen> unless training somehow wrangles that consideration, but certainly thats not a theoretical consideration..
10:48:38 <fen> continuous time we just connect each neuron at some time to its state at the next time, so there are no "crossings" 
10:53:16 <fen> but yeah, failing to understand why infinitely steep gradients are a concern when the solver has to bound the stability, and just refering to the motivation of the general approach seems like a total cop out
10:55:18 <luftmensch[m]> It was a cop-out, I was grocery shopping :P
10:57:15 <fen> well, thinking a bit more about it, having a covnet would force it to carve out paths for the information flow which for low dimensional eg 2d layers would place a burden on the depth, so being able to teleport information in an unfluid-like way might be an advantage. would like to see how the solver bounds stability though
10:58:40 <fen> luftmensch[m]: so what kinds of implementation are worth considering?
10:59:29 <fen> do you have any preferences?
11:01:13 <luftmensch[m]> Well the paper claims it performs better for time-series data than other methods, and I have a certain project in mind if I can get this working, but for now I just want to implement it and throw MNIST and see how it does
11:01:34 <fen> ok, we can see you would like to implement it
11:01:39 <fen> but what about haskell?
11:01:53 <luftmensch[m]> Just for fun
11:02:12 <fen> no, but what kind of libraries are you going to use?
11:02:40 <fen> do you expect to make a graph for each layer or a graph for the connections between layers (if thats how this continuous version is)...
11:03:01 <fen> whats that like, conduits along each edge?
11:04:47 <fen> or are you just thinking that mutable variables will be good enough for this concurrency? 
11:08:09 <fen> have you considered using an algebraic graph?
11:10:33 <fen> presumably it would update every neuron simultaneously, but access inputs in a structured way, maybe a vector or Map would be good, maybe there is some way to embed the structure of the edges into the weighting of the branching of a balanced partition tree
11:11:02 <fen> obviously these implementation considerations are going to have a significant impact on the performance...
11:11:31 <luftmensch[m]> There are no neurons, or I suppose you could think of it as having one single neuron
11:11:45 <luftmensch[m]> *single layer of neurons
11:15:26 <fen> you mean its continuous in depth and breadth?
11:15:28 <luftmensch[m]> The neural-ODE is an n-dimensional gradient, where n is the number of neuron equivalents
11:16:52 <fen> the performance is comapred using out the box python implementations! argh!
11:17:01 <luftmensch[m]> Yeah exactly. The only thing that’s discrete is the number of dimensions (and I’m sure the mathematicians will find some way to hammer those out too)
11:18:13 <fen> well how does that like an euler solver then!? that should have at least one distinguised direction for time flow
11:18:56 <fen> and if this is supposed to be "continuous depth" where information flows in a one way euler-time-like way, that would be another direction
11:19:30 <fen> anyway, saying the weight of a neuron constitutes a "dimenstion" is no different than a regular neural net
11:19:42 <luftmensch[m]> Yes you got it lol
11:19:43 <luftmensch[m]> that’s why I linked the paper
11:19:57 <fen> thats clearly not where the notion of continuousness is appearing...
11:20:22 <fen> i thought you linked it because you were serious about implementing things in haskell
11:21:16 <luftmensch[m]> It’s analogous but not the same
11:22:18 <fen> "there are no neurons" not convinced
11:22:51 <fen> even if you are just considering gradient descent as a path through some high dimensional space as a learning process then thats basically just neurons
11:23:31 <fen> and the concept of edges seems quite essential to determining how information flows over the network 
11:23:51 <luftmensch[m]> Yes it is all very analogous but it’s a different mathematical construct
11:23:56 <fen> the "architecture" of the network, with pruning schemes etc
11:25:25 <luftmensch[m]> The authors already did the work of explaining, so if you still don’t understand after reading it I’ll be happy to discuss because I still haven’t fully wrapped my head around it either
11:27:46 <nshepperd_> This sounds like the basic idea behind ffjord?
11:29:35 <nshepperd_> The two things you need are an ode solver, which there are probably existing packages for in haskell, and a differentiable parameterization of the hidden state derivative, which is a normal neural network, right?
11:30:52 <luftmensch[m]> nshepperd_: I’ll give that a read!
11:30:53 <luftmensch[m]> I haven’t seen much in the way of ODE solvers in hackage but any ol’ solver will do, I could just use RK
11:32:23 <luftmensch[m]> Yeah the derivative of the hidden state is more like a neuron, but with N-ODE you can solve those continuouslu
11:33:45 <fen> seems to be about sparcifying the jacobian!
11:34:03 <luftmensch[m]> Oh hey, Ricky Chen wrote both papers
11:35:26 <luftmensch[m]> *is an author of both papers
11:36:26 <fen> he is a coauthor having cowritten both
11:37:42 <nshepperd_> The derivative of the hidden state is a parameterized function dx/dt = f(x,t,params)
11:38:15 <aristid> hi. been a while since i've been in the loop on what is considered good style, hence this question:
11:38:35 <nshepperd_> You set x(t=0) to the input of the overall thing, and the output is x(t=1)
11:38:37 <aristid> is it considered good style to use DeriveGeneric to do deriving (Generic)
11:39:17 <aristid> somebody asked me why i don't expose Generic for the types in my package, and i'm not 100% sure whether to just add it
11:39:24 <fen> so then time is the depth direction?
11:40:04 <nshepperd_> To train it, you need to compute the gradient of the output wrt the parameters, which should be described in the paper as being some kind of ode involving a derivative of f
11:40:22 <nshepperd_> fen: yes
11:41:08 <fen> and there is no "continuous time" as such, as in, we only consider one pass over the netwoek from input to output neurons?
11:41:35 <nshepperd_> So f needs to be some arbitrary differentiable thing, so usually a nn. For mnist you'd use a convolutional nn
11:41:44 <fen> like, the training would be the gradient wrt multiple evaluations of the network with different weight
11:42:17 <nshepperd_> @hackage ad -- will work for calculating derivatives of simple f functions
11:42:17 <lambdabot> http://hackage.haskell.org/package/ad -- will work for calculating derivatives of simple f functions
11:43:21 <fen> but where can we get at the edges, and the number of neurons per layer? we might want an autoencoder style bottleneck to encourage the extraction of salient features
11:43:42 <sclv> just taking a derivative isn't enough for an ode solver. you really just want something like RK, which is easy to code up and also is lying around
11:43:49 <nshepperd_> For proper nns, I've heard of this grenade thing but don't know much about it. There are also haskell tensorflow bindings
11:44:06 <nshepperd_> sclv: yes, the ode solver is the other part you need
11:44:47 <fen> https://github.com/HuwCampbell/grenade
11:44:48 * nshepperd_ also has a haskell nn framework but it's really not for public consumption at this point
11:45:17 <nshepperd_> There seem to be a few if i Google "haskell ode solver"
11:52:29 <nshepperd_> aristid: deriving Generic is always a good idea imo, except for when the constructors of the type aren't meant to be public
11:52:44 <aristid> nshepperd_: ok
11:54:29 <nshepperd_> aristid: eg. Data.Set which hides the implementation so that it can enforce variants and/or switch to a different implementation without breaking compatibility
11:54:51 <nshepperd_> For everything else, having Generic seems good
11:55:19 <aristid> i forgot what the difference between Data.Data and GHC.Generics is :D
12:07:07 * hackage ghc-lib-parser 0.20190402 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-0.20190402 (shayne_fletcher)
12:08:37 * hackage keycloak-hs 0.0.0.5 -   https://hackage.haskell.org/package/keycloak-hs-0.0.0.5 (CorentinDupont)
12:09:37 * hackage orion-hs 0.1.1.0 -   https://hackage.haskell.org/package/orion-hs-0.1.1.0 (CorentinDupont)
12:10:37 * hackage keycloak-hs 0.1.0.0 -   https://hackage.haskell.org/package/keycloak-hs-0.1.0.0 (CorentinDupont)
12:12:07 * hackage keycloak-hs 0.1.1 -   https://hackage.haskell.org/package/keycloak-hs-0.1.1 (CorentinDupont)
12:13:07 * hackage orion-hs 0.1.2 -   https://hackage.haskell.org/package/orion-hs-0.1.2 (CorentinDupont)
12:18:03 <isovector1> is there a good way to pretty print template haskell decs? `pprint` dumps a bunch of unpretty things like module prefixes and unique ids
12:20:03 <Cale> hmm
12:20:51 <Cale> isovector1: What's the goal?
12:21:07 * hackage semirings 0.3.1.2 - two monoids as one, in holy haskimony  https://hackage.haskell.org/package/semirings-0.3.1.2 (chessai)
12:21:19 <Cale> isovector1: haskell-src-exts is a much nicer library to use if you're generating Haskell code which needs to look pretty
12:21:20 <isovector1> making slides in haskell that have haskell code on them
12:22:06 <isovector1> Cale: is there a TH -> haskell-src-exts? i want to get the decs out of TH qqs
12:22:07 * hackage webby 0.1.0.2 - A super-simple web server framework  https://hackage.haskell.org/package/webby-0.1.0.2 (AdityaManthramurthy)
12:22:36 <funrep_> hi! anyone know how to check which version of a library stack installed?
12:23:06 <funrep_> oh 'find . | grep parsec', didnt thought of running this
12:23:45 <isovector1> Cale: But i guess i'd be happy with a haskell-src-exts qq just as well
12:23:48 <Cale> What does  stack exec ghc-pkg list  get you?
12:24:07 <cocreature> funrep_: stack list-dependencies iirc
12:24:22 <Cale> isovector1: that exists http://hackage.haskell.org/package/haskell-src-exts-qq-0.7/docs/Language-Haskell-Exts-QQ.html
12:25:07 * hackage ghc-lib 0.20190402 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-0.20190402 (shayne_fletcher)
12:26:06 <isovector1> Cale: perfect. cheers!
12:27:39 <funrep_> cocreature: yes, thanks!
12:28:53 <isovector1> Cale: well a little less than perfect in that it's been broken since 8.2 :) but good enough to get me started
12:30:52 <Cale> isovector1: haha, well, it really shouldn't be hard to just make a quasiquoter yourself for that, given that there is a good enough Haskell parser in haskell-src-exts
12:31:04 <Cale> It's like 5 lines of code at most :)
12:40:38 <isovector1> Cale: works spectacularly. thanks!!
12:42:02 <heebo`> hello i was happy using deriving Generic FromJSON until I put a ByteString in my term constructor
12:42:16 <Welkin> lol
12:42:22 <Welkin> there is no instance for ByteString
12:42:28 <Welkin> all json is Text
12:42:37 <Welkin> mus be representable as Text
12:42:53 <Welkin> a ByteString is binary data and can contain unrepresentable characters
12:43:37 <heebo`> this is aeson, what do people do to get round this, do I need to define my own instances because I want to use ByteString to construct my values?
12:43:47 <tdammers> yes, pretty much
12:44:14 <heebo`> I admit im spoilt, because Haskell was making it so easy for me
12:44:19 <tdammers> there is no canonical way of encoding arbitrary binary data in JSON, so proving a ToJSON instance for ByteString would be wrong
12:44:22 <monochrom> I would go back a few step and ask myself "why do I have a ByteString there, and what is the nature of the bytes inside it".
12:44:24 <heebo`> but darnnit
12:44:43 <tdammers> this is Haskell making the desirable stuff easy and the undesirable stuff difficult
12:45:10 <heebo`> because Wreq expects values as ByteString
12:45:11 <tdammers> and yes, I second monochrom here. take a step back and ask yourself why you need a bytestring in the first place
12:45:20 <tdammers> what values
12:46:00 <monochrom> If you are working on FromJSON then what is exactly an example piece of JSON such that it should be parsed to ByteString and how?
12:46:20 <Welkin> the web is all plain text
12:46:29 <Welkin> so there are no bytestrings on the web
12:46:45 <Welkin> they are base64 encoded if necessary
12:46:53 <tdammers> Welkin: that is blatantly false
12:47:01 <Welkin> the *web*
12:47:08 <tdammers> still blatantly false
12:47:10 <Welkin> it is true
12:47:18 <Welkin> give a counter example then
12:47:31 <Welkin> instead of saying "false"
12:47:32 <tdammers> how do you think does your browser fetch a PNG image over HTTP?
12:47:33 <heebo`> Im using some of the values to set Headers in Wreq
12:48:06 <heebo`> the header function in Wreq expects ByteString
12:48:06 <monochrom> Does wreq's so-called "ByteString" mean that it wants utf-8 in the bytes?
12:48:07 <tdammers> and in fact, how does the browser parse HTTP headers in order to decide which character encoding to use, without knowing the character encoding?
12:48:26 <tdammers> HTTP headers are bytestrings. Not text.
12:48:36 <Welkin> http is plain text
12:48:37 <tdammers> They just happen to coincide with ASCII
12:48:47 <tdammers> "plain text" doesn't even exist, strictly speaking
12:49:00 <Welkin> the web is http
12:49:14 <Welkin> don't confuse it with "the internet" tcp/ip
12:49:24 <tdammers> I don't.
12:49:28 <ttoe> Hi. I was just wondering, how does Haskell fundamentally know that a function does not perform side effects? Can a non-IO() type signature be forced on e.g. putStrLn, and what would Haskell do?
12:49:33 <Welkin> json is made for the web/http and is plain text
12:49:38 <heebo`> http://hackage.haskell.org/package/wreq-0.5.3.2/docs/Network-Wreq.html#g:22
12:49:43 <Welkin> we are talking about json here
12:49:44 <heebo`> see header definition
12:49:47 <Welkin> don't get off topic
12:49:49 <heebo`> it takes ByteString
12:50:04 <tdammers> we are talking about Aeson (i.e., JSON) and Wreq (i.e., HTTP)
12:50:17 <monochrom> The overall lesson is you can no longer hide behind abstractions (more like vagarities) like "it's just string" "it's just text" "it's just ByteString", you have to start asking the difficult questions such as what are the actual bit patterns and what semantics do you give them?
12:50:23 <dmwit> ttoe: To a first approximation: no, a non-IO() type signature cannot be forced on e.g. putStrLn.
12:50:46 <heebo`> monochrom: i absolutely agree and understand
12:51:07 <heebo`> i guess it makes sense that a header could be a bytestring but not json
12:51:16 <heebo`> so the conversion is unavoidable
12:51:20 <tdammers> JSON is text-based, hence String or Text is the correct type to represent encoded JSON. But we're really interested in the "Value" side of Aeson (which means JSON's structural semantics), and at that level, we can only represent booleans, null, unicode strings, numbers (or some crude approximation thereof), lists, and dictionaries
12:51:41 <tdammers> this is why a generic JSON instance for ByteString isn't helpful
12:52:21 <dmwit> ttoe: (And more generally, anything that has side-effects has IO in its return type, and this invariant is how Haskell "knows" that a function does not perform side effects.)
12:53:08 <heebo`> thats the irritating thing about Haskell , you hit an obstruction and curse the library authors, and then you realise its for a good reason , and the library authors have thought more deeply about the domain than you did. how irritating!
12:53:47 <tdammers> Wreq uses ByteString for HTTP headers, and this is correct - HTTP is not a "text" protocol in the sense that it is based on text in any particular encoding; it is a binary protocol, but it was designed so that when mapped to ASCII, it becomes human-readable. But that's not the same thing; HTTP messages can (and often do) contain arbitrary binary payloads, and HTTP doesn't care what their encoding is (though
12:53:49 <tdammers> it does offer the means to declare it)
12:54:17 <tdammers> anyway, fortunately writing your own JSON instances isn't *that* hard
12:54:49 <monochrom> I might not write my own FromJSON instance. Instead, I do the conversion for HTTP.
12:55:06 <mojjoo> is there a way to build a stack script into an executable instead of running it?
12:55:07 <heebo`> monochrom: thats just what i was about to say
12:55:30 <heebo`> the reason for having bytestring in my value has been invalidated
12:56:04 <funrep_> anyone used Parsec with Data.Text? anything special i have to do besides importing it and using OverloadedStrings? the Parser type is still String so i get type errors from every parser
12:56:26 <funrep_> importing Text.Parsec.Text that is
12:56:26 <shapr> funrep_: I use attoparsec's Text specific parsers, they're real fast
12:56:27 <ttoe> dmwit: So it is just us, telling haskell from the most primal functions upward, that something performs side effects, via adding type annotations?
12:56:36 <tdammers> oh, I thought you wanted to serialize actual HTTP headers directly to JSON
12:56:47 <heebo`> thank you everyone , im glad there are such smart people available to answer Haskell questions
12:56:54 <tdammers> if that's not the case, then yes, use a more appropriate data type, and convert that to ByteString HTTP headers when needed
12:57:49 <heebo`> tdammers: ah know im just performing http authentication then getting a token back in json which i need to use on headers henceforth
12:57:54 <funrep_> shapr: im parsing quite complex grammar (indentation based programming language with binary operators), and Parsec has quite nice module Text.Parsec.Expr for this, but maybe it's easier to just convert to String then back to Text
12:59:00 <shapr> funrep_: if you just want it to go, yeah
12:59:09 <heebo`> *ah no 
12:59:13 <shapr> but if you want faster, better to go all out Data.Text
12:59:27 <monochrom> Text.Parsec.Expr is not hardcoded to String...
13:00:24 <heebo`> . o O (god i love the pipes and async libraries)
13:00:56 <funrep_> monochrom: i know, but changing Text.Parsec.String to Text.Parsec.Text gives type errors, but i guess the constrain must come from one of the default parsers only being compatible with String
13:01:02 <monochrom> LanguageDef is hardcoded to String, but you could go GenLanguageDef instead.
13:02:09 <funrep_> monochrom: thanks! that must be the issue
13:04:35 <kashima> kk
13:04:52 <fweht> i would like to understand more about what exactly is the type theoretic stuff at the core of functional programming languages and whats the 'syntactical sugar', any good references for this?
13:06:20 <funrep_> fweht: not read the whole thing but TAPL gives quite nice intro to lambda calculus followed by type theory
13:06:35 <axa> fweht I believe the core is System F
13:07:10 <fweht> thanks!
13:08:49 <fweht> axa: i read a bit about system f but it wasnt so clear to me how stuff in haskell exactly translates to types...  like pattern matching, etc.
13:08:59 <fweht> but i will look into TAPL!
13:09:30 <funrep_> fweht: http://dev.stephendiehl.com/fun/index.html <- not a complete resource, but more light intro to these topics from an implementation perspective
13:09:41 <fweht> funrep_: thanks!
13:15:46 <joel135> Is it possible to implement a function of type Y and X -> Y and X -> X -> Y and X -> X -> X -> Y and so on recursively (using typeclasses, I'm thinking) (where X and Y are fixed types, for starters)?
13:16:09 <monochrom> Yes with a lot of overlapping instances.
13:16:37 <joel135> Could you show me?
13:16:55 <monochrom> Not at the moment.
13:17:07 <joel135> Ok
13:18:12 <Solonarv> joel135: this page has a bunch of approaches: http://okmij.org/ftp/Haskell/polyvariadic.html
13:18:53 <joel135> Cool!
13:19:29 <Solonarv> although, keep in mind:
13:19:29 <Solonarv> @quote okmij
13:19:29 <lambdabot> BMeph says: okmij.net, conal.net, comonad.reader, and sigfpe.blogspot.com; the four horsemen of the Haskell Apocalypse.
13:19:37 <Solonarv> gah! wrong quote
13:19:48 <Solonarv> @quote get.a.link
13:19:48 <monochrom> That's a good one.
13:19:48 <lambdabot> shachaf says: Some people, when asking about a problem in #haskell, get a link to okmij.org. Now they have two problems.
13:19:58 <monochrom> Oh haha
13:42:18 <delYsid> oh, how cool is this: http://okmij.org/ftp/Haskell/polyvariadic.html#fast-forth
13:55:53 <Boarders> Does anyone know if it is possible to add role annotations to a polymorphic type sig
13:56:28 <Boarders> e.g. if I wanted all functors which are representational
13:56:36 <lyxia> nope
13:56:50 <lyxia> use Coercible instances instead
13:59:27 <Boarders> thank you! (I can't use that for what I am writing)
14:00:37 <Solonarv> given: type role Foo phantom representational nominal _
14:00:37 <Solonarv> (forall x y b c.                  Coercible (Foo x b c) (Foo y b c)) for phantom role
14:00:37 <Solonarv> (forall a x y c. Coercible x y => Coercible (Foo a x c) (Foo a y c)) for representational role
14:00:37 <Solonarv> (forall a b x y.         x ~ y => Coercible (Foo a b x) (Foo a b y)) for nominal role
14:01:27 <Solonarv> (you don't actually need that last constraint; it simplifies to (forall a b c. Coercible (Foo a b c) (Foo a b c)), which always holds)
14:01:37 <Solonarv> Boarders: ^
14:02:16 <Solonarv> so if you want "functors with a representational type parameter", you can express this as (Functor f, forall x y. Coercible x y => Coercible (f x) (f y))
14:02:40 <Boarders> ah nice, I'll give something like that a go
14:02:42 <Boarders> thanks!
14:03:30 <Solonarv> need GHC 8.6, for QuantifiedConstraints
14:05:00 <delYsid> Hmmm, -O2 gave me a 30% speedup.  I guess I can ignore the cabal check warning :-)
14:08:25 <jmcarthur> Yeah, I think cabal check is just wrong about -O2 not being much of an improvement
14:08:41 <sclv> the problem is it depends on the code
14:08:49 <sclv> and people were just littering it about willy nilly
14:10:53 <delYsid> In fact, it also halves my heap allocations.
14:18:25 <MarcelineVQ> I call that skipping breakfast
14:40:04 <delYsid> yay, TODO list is empty.  I guess now I should spend some time on writing haddock comments.
14:40:46 <delYsid> https://github.com/mlang/chessIO -- in case anyone feels like looking over what kept me occupied in the last two weeks.
14:41:30 <delYsid> feedback appreciated, since this is my first seriously useful package over 1000 LOC
14:42:36 <delYsid> no math inside though, just a bunch of bit twiddlings and (ab)using TChan.
15:03:44 <libertyprime>  /msg alis LIST * -topic github
15:03:53 <libertyprime> sorry ^^
15:50:41 <t7> delYsid: does it catch repeated positions
15:51:40 <t7> fifty move rule
15:51:55 <t7> and threefold repetition 
15:54:57 <johnw> delYsid: very cool!
15:55:16 <johnw> delYsid and I have a nearly 20 year long history now of playing with chess programming together :)
15:55:35 <johnw> glad to see it shifting to Haskell
15:59:46 <lyxia> 20 years!
16:00:07 <johnw> yeah, he and I are co-authors of the Emacs Chess library
16:01:22 <fen> here there is plenty of code for the reading of; https://pastebin.com/raw/kn3Dk4AJ
16:01:24 <ldlework> johnw: ever tried go?
16:01:55 <jle`> i hear the compile times can be bad
16:01:57 <johnw> no
16:02:56 <fen> getting closer to a "nested state encoding"... 
16:03:12 <fen> even a "FreeChurch" type !!
16:03:57 <fen> havent quite got the compositionality of it down yet but its close
16:07:15 <fen> you give an undirected thing directions, the loop it until the directions fail, and provide new directions via a state of such
16:07:42 <delYsid> t7: Not yet, that is a good point.  I haven't implemented any position hashing yet, but that is coming.
16:08:03 <delYsid> johnw: Thanks!  chessIO is largely inspired by me remembering about emacs-chess :-)
16:08:46 <delYsid> johnw: I was basically missing a simple console program to play against UCI engines.  While XBoard is surely nice, it is definitely not accessible...
16:09:38 <delYsid> The move generator is pretty fast, it does 62M nps on a 20 core system in the perft test.
16:11:11 <delYsid> And it passes the 126 test positions found in the perftsuite.epd file, so I am pretty confident it actually works as expected.
16:12:52 <MarcelineVQ> if you want to be certain then you can write it in coq next, ask johnw for assistance :>
16:13:02 <dmwit> ?tell ttoe (re: So it is just us, telling haskell from the most primal functions upward, that something performs side effects, via adding type annotations?) Yep, pretty much.
16:13:02 <lambdabot> Consider it noted.
16:18:46 <delYsid> MarcelineVQ: Yeah, but I am a bit worried about performance :-)
16:19:26 <delYsid> Last time I worked on a move generator, it was written in Emacs Lisp.  That was already pretty slow.
16:20:39 <delYsid> johnw: In case you didn't notice, emacs-chess is part of ELPA these days.  We need to watch out for the various repos getting out of sync.
17:11:34 <cole> Question about data type design: I want to model X' syntax in Haskell and I'm not sure what the best way is.
17:11:49 <cole> In brief, X' is a binary tree with three levels: XP, X', and X
17:12:23 <cole> By "levels" i mean types of branches
17:12:35 <cole> XP branches to an X' and another XP
17:12:41 <cole> X' branches to an X and another XP
17:12:45 <cole> and X branches to two XPs
17:12:57 <cole> What is the best way at making a datatype that encapsulates this behavior?
17:13:10 <johnw> data XPF r = XP X'  r | X' X r | X r r
17:13:22 <johnw> type XP a = Free XPF a
17:14:27 <johnw> I may have gotten that quite wrong
17:14:37 <johnw> but basically you want to describe your language directly as a recursive structure
17:14:42 <cole> Yeah
17:14:44 <johnw> I'm using Free here to lift the recursion out of the core type
17:15:14 <jackdk> or if you don't grok that, you could try: data XP = XP X' XP and data X' = X' X XP and data X = X XP XP ?
17:15:27 <cole> yeah i don't grok it yet
17:15:31 <cole> i don't quite understand Free
17:15:48 <johnw> Free lets you build trees with a base case
17:15:55 <johnw> it's just a convenience, you don't need it
17:15:58 <johnw> explicit recursion is fine too
17:15:59 <cole> Ah ok
17:16:09 <cole> So one of the things is
17:16:52 <cole> i want to be able to write a function that traverses the tree
17:17:00 <cole> and it seems kind of hard to deal with the different datatypes
17:17:22 <cole> i tried to make a disjunctive type that wraps the XP, X', and X types
17:17:29 <cole> but then that allows for invalid trees to be generated
17:17:33 <cole> am i approaching this problem wrong?
17:19:34 <jackdk> :t either
17:19:35 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
17:19:51 <jackdk> cole: have you seen this function before?
17:20:05 <cole> yeah
17:20:20 <jackdk> you might be able to write something similar for your X' type: take a function to handle each case, and an X'
17:22:06 <cole> OK, I'll try that out! Thanks
17:22:07 * hackage tensors 0.1.4 - Tensor in Haskell  https://hackage.haskell.org/package/tensors-0.1.4 (leptonyu)
17:22:12 <cole> I think that makes sense
17:31:37 * hackage ghc-dump-util 0.1.1.0 - Handy tools for working with @ghc-dump@ dumps.  https://hackage.haskell.org/package/ghc-dump-util-0.1.1.0 (BenGamari)
17:32:37 * hackage ghc-dump-core 0.1.1.0 - An AST and compiler plugin for dumping GHC's Core representation.  https://hackage.haskell.org/package/ghc-dump-core-0.1.1.0 (BenGamari)
17:51:37 * hackage hw-simd 0.1.1.4 - SIMD library  https://hackage.haskell.org/package/hw-simd-0.1.1.4 (haskellworks)
18:02:37 * hackage pandoc-pyplot 2.0.1.0 - A Pandoc filter for including figures generated from Matplotlib  https://hackage.haskell.org/package/pandoc-pyplot-2.0.1.0 (LaurentRDC)
18:08:04 <johnw> with cabal new-build, how can I compile a single module  to see its Core?
18:08:30 <johnw> delYsid: nice!
18:10:18 <Kasc> Hi, I know that you can use PatternSynonyms to export custom patterns out of a module.. but this is a lot of boilerplate when I just want patterns to all constructors for a certain type. I'm sure I remember seeing a way to export constructors directly as patterns, am I misremembering?
18:11:30 <slack1256> Are you sure you want pattern-synonyms for all constructors? why not use the constructors instead?
18:11:45 <Kasc> Because I don't want to allow construction
18:11:57 <Kasc> but inspecting held values is still valuable
18:12:11 <slack1256> export/import list are verbose on haskell, that is true
18:12:51 <slack1256> Kasc: I guess those patterns are view-only, not bidirectional then
18:14:52 <Kasc> slack1256: Yes. If I have a 20 constructors though the boilerplate is sort of insane. I'm wondering if there is a solution for this?
18:17:54 <slack1256> Maybe with TH but I don't really know. That is the deal with sum-types, enumerating all the cases both a pattern matching time and export time
18:57:46 <jusss> fmap = (a->b) -> f a -> f b,  what is this f?
18:58:09 <jusss> and it is fmap = (a->b) -> f(a) -> f(b) right?
19:01:22 <Axman6> looks like fmap to me, with some unneeded brackets
19:01:36 <slack1256> jusss: `f` can be different depending on the instance
19:01:44 <slack1256> % set -XTypeApplications
19:01:44 <yahb> slack1256: ; <interactive>:477:6: error: Data constructor not in scope: XTypeApplications :: ASetter s t a b -> b -> s -> t
19:02:19 <slack1256> % :t fmap @Maybe
19:02:19 <yahb> slack1256: (a -> b) -> Maybe a -> Maybe b
19:02:32 <slack1256> % :t fmap @(State Int)
19:02:32 <yahb> slack1256: (a -> b) -> State Int a -> State Int b
19:03:37 <slack1256> % :t fmap @Identity
19:03:37 <yahb> slack1256: (a -> b) -> Identity a -> Identity b
19:03:51 <slack1256> (btw I love yahb)
19:36:41 <glguy> The extra parentheses aren't needed; your first version was fine
19:36:55 <glguy> (was scrolled)
19:41:26 * geekosaur feels likee they were trying to reach for it representing a function directly, rather than a type with kind * -> *
20:05:16 <maerwald> how do you tell cabal new-haddock to generate docs for dependencies?
21:02:35 <ssm_> hello! at the end of my main function there is an else do part which has two lines first is "o <- getChar" and second is "operate o s" which s is determined before the if 
21:03:12 <ssm_> i get the error Couldn't match type '[]' with 'IO' expected type actual type string in a stmt of a do block operate o s
21:03:23 <Too_Lazy> pastebin
21:05:46 <Too_Lazy> but from a guess, it sounds like `operate` doesn't result in a type of IO, and since it's the last statement in the else block you're trying to return not IO in a function (main) that expects a result of type IO ()
21:11:02 <jle`> ssm_: what is the type of `operate`?
21:12:25 <ssm_> https://github.com/TuanSSM/qhaskell/blob/master/assignment_tuples.hs
21:12:47 <ssm_> sad but pastebin is blocked in my country
21:13:46 <jle`> ah yes, operate returns a list of char's
21:13:51 <jle`> ssm_: what were you expecting to happen?
21:14:34 <jle`> a 'do' block lets you sequence multiple IO actions one-after-the other, to create a new IO action
21:14:45 <jle`> so each line should be an IO action
21:15:03 <ssm_> how can i implement operate there?
21:15:29 <ssm_> since today i just used haskell in ghci and never wrote an executable now really confused
21:15:36 <jle`> ssm_: well, what do you want to 'do'?
21:15:43 <jle`> what IO do you want to perform?
21:15:56 <jle`> after you get a Char ... then what?
21:16:21 <ssm_> first i need to get an input string from the user and parse it then get chars to decide which operation to appy on that parsed string
21:16:36 <jle`> right. but then what IO do you want to do after that
21:16:44 <jle`> what do you want to do with the result of 'operate'
21:17:39 <ssm_> aah.. after 'operating' it i want to operate it again with the new 'state' until the operation is a measurement
21:17:48 <jle`> yeah, you can do something like
21:17:56 <jle`> let resultOfOperate = operate o s
21:17:57 <ssm_> after the measurement i want to ask to do you wish to continue or not
21:18:07 <jle`> but then after that you can do whatever IO action you want to do next
21:18:56 <ssm_> and how can i get back to beginning after a certain operation
21:19:07 <jle`> what do you mean "to the beginning"?
21:19:09 <ssm_> with char 'm' should i say it to do main again
21:19:13 <Too_Lazy> ssm_ it sounds like you want to put the "meat' of the main function into a nother function
21:19:36 <Too_Lazy> So you can do this if/else check routine and take the result of operate o s, then feed it back into the same function recursively
21:19:59 <Too_Lazy> so you can feed the new state back into the function to do the process over again
21:20:10 <Too_Lazy> if that makes sense
21:21:02 <ssm_> thanks i should study a bit more
21:44:31 <juhp> Why doesn't `cabal new-install` create a symlink for me in ~/.cabal/bin ?
21:45:33 <glguy> juhp: What version of cabal-install? And do you already have something in ~/.cabal/bin/ that would have been overwritten?
21:45:50 <juhp> glguy: earlier yes
21:46:11 <juhp> cabal-install version 2.2.0.0
21:46:49 <glguy> OK, if you're using the new-install stuff then upgrading to 2.4.1.0 is a great idea: $ ghcup install-cabal
21:47:07 <glguy> and when you new-install there's a flag: --overwrite-policy=always 
21:47:14 <glguy> to ensure that the new thing you install overwrites the old one
21:58:22 <luite> is there a default symlink-bindir. i think mine keeps asking for one explicitly, but perhaps i have some old configs that mess up things
22:12:24 <juhp> glguy: okay thanks!
22:13:33 <juhp> luite: my ~/.cabal/config has 'symlink-bindir: /home/petersen/.cabal/bin'
23:09:07 * hackage atlassian-connect-descriptor 0.4.8.0 - Code that helps you create a valid Atlassian Connect Descriptor.  https://hackage.haskell.org/package/atlassian-connect-descriptor-0.4.8.0 (RobertMassaioli)
23:37:16 <dminuoso> johnw: Regarding my question about singleton types, I think I realized I did not understand singletons right. I was merely looking for a way to express `data State = Open | Closed` without creating `Open` and `Closed` data constructors. Not that it's a big issue, I was just curious.
23:37:25 <dminuoso> johnw: Thanks for your insights.
23:41:53 <ruffy_> Should I prefer using concatMap or the List Monad for readability?
23:42:18 <glguy> Being more specific make things more readable
23:43:52 <ruffy_> Just a question what you prefer, because there is no performance difference, right?
23:44:01 <Cale> ruffy_: Are you nesting a bunch of concatMaps?
23:44:17 <Cale> You could also sometimes consider a list comprehension, which is the same
23:44:36 <Cale> Yeah, they should all compile to the same thing
23:45:00 <ruffy_> Cale: hmmmm I also do it sometimes, when I have just one concatMap
23:52:27 <dminuoso> ruffy_: You could also use a list-comprehension.
23:52:55 <dminuoso> If its for "clarity that a list is being used", then it should be either a list-comprehension or do-notation with a type signature perhaps.
23:53:11 <ruffy_> dminuoso:  thx I haven't thought about that
23:55:25 <dminuoso> Personally I dont use list-comprehensions, do-notation seems rather fine :)
23:58:32 <ruffy_> at the moment I also prefer do notation :)
