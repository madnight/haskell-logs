01:47:12 <arjen-jonathan> flycheck in emacs on haskell steals focus whenever I have my cursor on a goal. Anyone knows how to deal with that?
01:54:13 <madjestic> Hey guys.  I've got a question about Linear package.  Is there a built-in method to convert a value of `V4 0 0 0 1` to a standard structure, like [0,0,0,1] or (0,0,0,1)?  Or is the idea that such conversion is done by manually, by pattern-matching, etc.?
01:54:40 <madjestic> I see `fromV`, but I am not sure that's what I need, or is it?
01:58:17 * hackage dino 0.1 - A convenient tagless EDSL  https://hackage.haskell.org/package/dino-0.1 (EmilAxelsson)
02:21:53 <avn> Hello folks! Have a question, -- how RecordWildCards treat fields unused in following expression? Just like _ in pattern match?
02:22:30 <merijn> avn: Yes
03:50:24 <Bish> repM 0 x = pure []; repM n x = (repM (n-1) x)>>=(\f1->x >>= (\f2->pure (f2:f1))
03:50:32 <Bish> who tells me why the first pure is neccessary for this to work?
03:51:08 <Bish> oh, it isn't
03:51:17 <Bish> no it is.
03:53:02 <Bish> because []>>=(\x-> this never gets execuded?)
03:53:06 <Bish> and pure somehow keeps going?
03:55:02 <CelestialLake> Bish: It's just an edge condition.
03:56:07 <Bish> i don't follow why the result is [] always when not doing it
04:01:08 <Bish> oh sure, i get it.
04:01:10 <Bish> im stoopid
04:01:39 <Bish> but how the fuck does it know it's a list without that.. jesus thats impressive
04:06:42 <Axman6> understanding this is a lot easier if you also write the types
04:07:47 <Bish> Axman6: yeah thats what i did
04:07:54 <Bish> i wasn't realizing pure [] means [[]]
04:07:56 <Bish> in that context
04:08:24 <Bish> and then it makes sense, because [[]] >>= (\x->...) will be evaluated, not []>>=...
04:08:26 <CelestialLake> If you don't provide a type signature, GHC just infers whatever you mean by it from the operations you perform. If it is solvable and makes any sense for it, it will compile and work.
04:08:37 <CelestialLake> :t pure
04:08:38 <lambdabot> Applicative f => a -> f a
04:09:14 <Bish> did haskell notice though, that it indeed does nothing? but count to zero?
04:12:07 <CelestialLake> Don't know if GHC actually detects that, though it probably did.
04:15:26 <CelestialLake> Also, your function can be summarized otherwise as `repM x = (>>= pure . replicate x)`. 
04:16:41 <Bish> no, doesnt look like it :o
04:17:57 <merijn> Bish: What was the function?
04:18:49 <CelestialLake> It does. You want to replicate some value held by a monad (if I follow it), so what you need is (>>=) combined with underapplied `pure . replicate`
04:19:41 <CelestialLake> There's probably even simpler way to do so, though this one is a fairly obvious solution.
04:20:12 <merijn> CelestialLake: That looks like something very different from what people would normally want from that type
04:20:28 <merijn> CelestialLake: Your code is basically just "fmap (replicate x)"
04:21:03 <CelestialLake> Oh. Overlooked it, too.
04:22:35 <merijn> Incidentally, replicateM already exists :p
04:22:38 <merijn> :t replicateM
04:22:39 <lambdabot> Applicative m => Int -> m a -> m [a]
04:23:36 <CelestialLake> merijn: The original function is `repM 0 x = pure []; repM n x = (repM (n-1) x)>>=(\f1->x >>= (\f2->pure (f2:f1))` though.
04:24:17 <merijn> That's...a super confusing implementation >.>
04:24:58 <CelestialLake> (>>=) is basically why I've got this (>>= pure . replicate x) idea initially.
04:25:17 <CelestialLake> But I've got a question of my own, which is probably really stupid.
04:26:30 <CelestialLake> How do I intuitively describe a Profunctor as a generalization of Functor?
04:27:06 <merijn> I wouldn't say they are a generalisation of Functor at all
04:28:01 <merijn> Since Profunctors are a subset of Functors
04:29:09 <CelestialLake> Yup, though I've heard of Profunctors being useful to generalize other kinds of functors, including bifunctors, covariant/contravariant, etc.
04:31:07 <CelestialLake> Some suggest that they've got even more and are a nice way to generalize functions. Son I'm a bit confused now.
04:31:31 <Taneb> Well, they certainly generalize functions
05:23:30 <c_wraith> (A bit late, but..) They only generalize the part of functions where you can compose them together.  They don't allow  application, which is also an important thing functions do.  So *sometimes* you can use them as a generalization of functions, but it's not a guaranteed thing.
05:32:17 * hackage gitlab-haskell 0.1.0.0 - A Haskell library for the GitLab web API  https://hackage.haskell.org/package/gitlab-haskell-0.1.0.0 (RobStewart)
05:39:09 <ph88> does lambdabot have a last seen function ?>
05:39:25 <merijn> no
05:42:25 <veryfair> so if I have a list comprehension akin to `[(x,y) | x<-[1..3], y<-[1..3]]`. this generates `[(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]`. however i would like to obtain a more fair ordering, eg. `[(1,1),(1,2),(2,1).. etc]`. What is the most haskell-ian way to do this?
05:43:11 <veryfair> i also want to expand this to 3 lists^
05:44:38 <KaitoDaumoto> idk
05:47:06 <Bish> map (\(a:b:c:d)->(a,b,c)) $ replicateM 3 [1,2,3]
05:47:08 * Bish ducks
05:48:07 <c_wraith> veryfair: this isn't a thing lists are well-designed to do.  http://hackage.haskell.org/package/logict exists specifically for that use case, but it's a lot more advanced (have to understand how to install libraries) than just using lists
05:49:04 <c_wraith> veryfair: on the other hand, sometimes you can twist the problem around a bit to manage to use lists, like...
05:50:40 <c_wraith> > [(i, j) | n <- [2 .. 6], i <- [1..3], let j = n - i, j <= 3]
05:50:42 <lambdabot>  [(1,1),(2,0),(3,-1),(1,2),(2,1),(3,0),(1,3),(2,2),(3,1),(2,3),(3,2),(3,3)]
05:50:49 <c_wraith> hah, oops
05:51:01 <c_wraith> > [(i, j) | n <- [2 .. 6], i <- [1..(n - 1)], let j = n - i, j <= 3]
05:51:02 <lambdabot>  [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(2,3),(3,2),(4,1),(3,3),(4,2),(5,1)]
05:51:27 <c_wraith> Well, it still isn't quite right.  But the idea is there.  *sometimes* you can get what you want out of that.
05:51:46 <veryfair> interesting, thanks. ill look into logict as well.
05:52:20 <dmwit> > concat . transpose $ replicate 3 [1..3]
05:52:22 <lambdabot>  [1,1,1,2,2,2,3,3,3]
05:52:54 <dmwit> > concat . transpose $ [[(x,y) | x <- [1..3]] | y <- [1..3]]
05:52:56 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
05:53:50 <dmwit> veryfair: http://hackage.haskell.org/package/universe-base-1.0.2.1/docs/Data-Universe-Helpers.html#v:diagonal
05:54:31 <dmwit> > diagonal [[(x,y) | x <- [1..3]] | y <- [1..3]]
05:54:31 <dmwit> [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(2,3),(3,2),(3,3)]
05:54:33 <lambdabot>  error:
05:54:33 <lambdabot>      Variable not in scope: diagonal :: [[(Integer, Integer)]] -> t
05:54:44 <dmwit> (Sorry lambdabot. Forgot to escape my > for you.)
05:55:51 <dmwit> veryfair: Oh, wait. "I want to expand this to 3 lists" -- what do you want the three lists to be?
05:56:19 <veryfair> x<-[1..3], y<-[1..3], z<-[1..3] essentially
05:56:20 <dmwit> (Perhaps diagonals is what you want instead, though it will produce 5 lists, not 3. Not sure how it should be broken down.)
05:56:31 <veryfair> im installing universe, will check
05:56:37 <ph88> is there a checklist for publishing packages ?
05:57:13 <merijn> ph88: https://hackage.haskell.org/upload ?
05:57:42 <dmwit> veryfair: Like this?
05:57:44 <dmwit> diagonal . diagonal $ [[[(x,y,z) | x <- [1..3]] | y <- [1..3]] | z <- [1..3]]
05:57:44 <dmwit> [(1,1,1),(1,1,2),(2,1,1),(1,2,1),(2,1,2),(3,1,1),(1,1,3),(2,2,1),(3,1,2),(1,2,2),(2,1,3),(3,2,1),(1,3,1),(2,2,2),(3,1,3),(1,2,3),(2,3,1),(3,2,2),(1,3,2),(2,2,3),(3,3,1),(1,3,3),(2,3,2),(3,2,3),(2,3,3),(3,3,2),(3,3,3)]
05:58:22 <Bish> whats bad about my approach :o? i mean it counds binary
05:58:40 <ph88> thx merijn 
05:59:08 <dmwit> Bish: Your approach doesn't meet veryfair's "more fair ordering" requirement.
05:59:23 <merijn> ph88: Also the PVP documentation
05:59:23 <dmwit> Bish: In particular it won't work well if one of the lists you want to draw from is infinite (whereas diagonal will).
05:59:34 <merijn> ph88: https://pvp.haskell.org/
06:01:07 <veryfair> Bish: not sure if i understood you but it gives me the same thing as list comprehension (ie, z goes 1..3 then y goes 1..3 etc)
06:01:18 <veryfair> dmwit: diagonal works perfectly, thanks
06:01:50 <dmwit> Bish: e.g. compare `sequence [[1..3],[1..]]`, which starts `[[1,1],[1,2],[1,3],[1,4],[1,5]...`, with `[1..3] +*+ [1..]`, which starts `[(1,1),(1,2),(2,1),(1,3),(2,2),(3,1)...`.
06:02:12 <isovector1> is there some combination of tricks i can use to get an operator with infixl 10?
06:02:40 <isovector1> TH / core plugins / whatever magic you got are all acceptable
06:03:24 <merijn> isovector1: Not any method that has anything close to a sane cost-benefit ratio...
06:03:55 <isovector1> merijn: so long as it's not "patch ghc" my ears are open
06:05:43 <dmwit> I bet there's just a number 9 somewhere in the GHC source.
06:05:59 <dmwit> Probably doesn't cost all that much to find it and change it to 10 and kick off a build...
06:06:16 <isovector1> that's past the "patch ghc" limit unfortunately :(
06:06:34 <isovector1> that's the sort of patch that requires a 6 month proposal to get into the compiler
06:06:39 <dmwit> Yup. But I bet it's actually *less* work than cooking up a core plugin.
06:06:58 <dmwit> Oh. This is not just for your use?
06:07:07 <isovector1> nope. library use
06:07:12 <isovector1> oh!!! what about SOURCE plugins
06:08:16 <isovector1> ... yeah thb that's probably going off the rails
06:08:28 <isovector1> okay. my poor users will have to put some parens in
06:18:29 <gentauro> First picture of a black hole :o -> https://www.youtube.com/watch?v=jde8xWJRAC4
06:35:18 <shapr> Haskell has known about black holes since 2005 (page 5 of https://www.microsoft.com/en-us/research/wp-content/uploads/2005/09/2005-haskell.pdf )
06:44:57 <wolfman154> Could one of you guys help me with xmonad settings 
06:47:56 <merijn> make clean
06:48:02 <merijn> whoops :p
06:49:26 <wolfman154> In xmonad when I open an application with terminator such as firefox, half the screen opens firefox and the other half shows terminator, so how do I set xmonad to open an application in full screen?
06:51:49 <wolfman154> Does anyone here know how to do this?
06:51:58 <dmwit> You can switch to the Full layout.
06:52:02 <gonz_> If you use the default layout config you can just toggle the layout for the workspace by pressing Alt-Space
06:52:03 <dmwit> mod+space by default to switch layouts.
06:52:07 <dmwit> Also check out #xmonad.
06:54:17 * hackage dino 0.1.1 - A convenient tagless EDSL  https://hackage.haskell.org/package/dino-0.1.1 (EmilAxelsson)
06:57:01 <wolfman154> mod + space  works, thanks, is there a way to automatically set applications to open in full screen ? No one has responded in #xmonad so I’m asking here.
06:57:59 <wolfman154> I’m new to xmonad 
06:58:27 <dmwit> You haven't asked in #xmonad...
06:59:31 <wolfman154> dmwit: yes I have, I just posted the question 5 minutes ago 
06:59:59 <dmwit> I don't see it. Let's see if we can work out why.
07:00:50 <wolfman154> dmwit: I’ll repost it again 
07:01:29 <wolfman154> dmwit: ok I reposted it 
07:01:45 <dmwit> It didn't make it through. I'm looking into it, give me a moment.
07:04:39 <dmwit> Odd. You don't appear to be banned, the channel doesn't require you to be voiced to speak, and although the channel requires you to be in the channel to speak, you do appear to be in the channel.
07:05:52 <wolfman154> dmwit: I’m using irc in my phone, maybe that’s why?
07:06:39 <wolfman154> dmwit: irc app that is 
07:07:48 <dmwit> Shouldn't matter.
07:08:54 <wolfman154> dmwit: oh well 
07:09:56 <dmwit> Anyway. You can automatically set applications to open in full-screen. Check out the manage hooks in the documentation.
07:10:13 <dmwit> http://hackage.haskell.org/package/xmonad-0.15/docs/XMonad-ManageHook.html
07:10:28 <dmwit> There's a doFullFloat somewhere in xmonad-contrib.
07:10:37 <dmwit> https://hackage.haskell.org/package/xmonad-contrib-0.15/docs/XMonad-Hooks-ManageHelpers.html#v:doFullFloat
07:10:45 <dmwit> You'll need to cook up a Query that matches only the app you care about.
07:11:17 <dmwit> appName or title are a common choices for discriminators.
07:11:29 <wolfman154> dmwit: thanks 
07:11:38 <wolfman154> dmwit++
07:12:09 <wolfman154> dmwit: oh there’s no karma on this channel 
07:12:14 <dmwit> There is. =)
07:12:16 <dmwit> ?karma dmwit
07:12:16 <lambdabot> You have a karma of 78
07:13:02 <wolfman154> ?karma dmwit 
07:13:02 <lambdabot> dmwit has a karma of 78
07:13:14 <wolfman154> Oh 
07:13:33 <dmwit> Used to be 77 until two minutes ago. ;-)
07:14:56 * ski is not really in favor of a(n artificial) karma-accounting system ..
07:16:34 <maerwald> clearly someone didn't get what karma means :)
07:18:56 <MarcelineVQ> ski prefers naturally sourced karma :>
07:18:58 <ski> elaborate ? :)
07:19:09 * ski smiles
07:21:34 * Lycurgus .oO( the 'real' karman, in Dennet's sense)
07:21:48 * Lycurgus *karma
07:25:41 <ski> Lycurgus : Daniel Dennett ? any suggested reference re that ?
07:25:56 <Lycurgus> sure just a min
07:27:06 <Lycurgus> https://ase.tufts.edu/cogstud/dennett/papers/explainingmagic.pdf
07:28:03 <Lycurgus> the first acceptable, there's also a video i think where he talks about the use of 'real' with a fictional thing
07:30:29 <ski> name ?
07:31:57 <Lycurgus> of whom/what?
07:32:05 <ski> the video you had in mind
07:32:11 <Lycurgus> ah
07:34:05 <Lycurgus> https://www.ted.com/talks/dan_dennett_on_our_consciousness/transcript?language=en
07:34:15 <Lycurgus> around 4 min in and ff
07:35:12 <ski> ok, ty
07:35:40 <Lycurgus> np
07:42:29 <nefple[m]> Small question, is there a name fo  (>>) ? It seems like it should be "sequence" but it's not equivalent to the other sequence
07:43:05 <jassob> nefple[m]: It is (at least in some places) somewhat jokingly called blind
07:43:35 <Cale> "then"
07:43:44 <Lycurgus> nefple[m], it's normally called 'bind' but there are other terms, one really funny one i can't recall
07:43:45 <jassob> Since it is a `bind` that does not care for the return value of the first computation 
07:43:58 <Lycurgus> justifies or something like that
07:44:05 <jassob> So the >>= is bind and
07:44:11 <jassob>  >> is blind
07:44:19 <Shockk> I usually describe it as "bind and ignore"
07:44:40 <Shockk> I usually use *> though but that's how I describe both
07:44:58 <monochrom> I agree with "then"
07:45:13 * ski seconds (thirds ?) Cale and monochrom
07:45:49 <nefple[m]> Ha blind. "Then" seems most appropriate, but doesn't really indicate it's "throwing away" of m a
07:45:55 <nefple[m]> if that's even necessary
07:46:21 <Cale> It's not usually all that necessary to pronounce it
07:46:47 <Shockk> I usually read it as, there's no =, so nothing is being bound, just ignored
07:47:35 <ski> (and `(=<<)' is called "extend" (check the papers) .. sorry, `(<<=)' (and `(=>>)' ?) could perhaps better be referred to as "preserve" or something ?)
07:48:12 <Cale> I would just call those cobind/coextend
07:48:14 <ski> i suppose one could also call `(>>)' "before" ?
07:48:42 <Cale> Yeah, that seems reasonable
07:48:44 <MarcelineVQ> these are awful, just call it by name, rightpointybracketrightpointybracket
07:49:07 <Cale> "Two sideways vees"
07:49:19 <monochrom> >> is very analogous to C's ;.  How do you pronounce C's ; ?
07:49:50 <monochrom> In fact so much so that dons or shapr (I forgot who) said "monad is programmable semicolon".
07:50:25 <monochrom> MarcelineVQ: I posit that call-by-need is better than call-by-name!  <duck>
07:50:51 <MarcelineVQ> it was already called by need, that's how the convo got evaluated :>
07:51:33 <monochrom> My students, on the other hand, can only do call-by-value.  That is, they always have to expand the definition of >>= when working with the state monad or a parser monad...
07:51:43 <ski> @quote the.semicolon
07:51:43 <lambdabot> AlanPerlis says: Syntactic sugar causes cancer of the semicolon.
07:51:59 <ski> @quote semicolons
07:51:59 <lambdabot> you says: could be a monadic vampire.  I hear they bleed semicolons.
08:23:42 <shapr> monochrom: I stole the programmable semicolon from a blog post about monads in elisp
08:25:26 <shapr> monochrom: I'm also thrilled that you confuse me with dons :-)
08:28:25 <remexre> is there a way to get hoogle for the project I'm currently developing? (ideally without installing it globally)
08:29:47 * hackage futhark 0.10.2 - An optimising compiler for a functional, array-oriented language.  https://hackage.haskell.org/package/futhark-0.10.2 (TroelsHenriksen)
08:29:48 <shapr> I've seen something about doing that, I know it's possible to do project-local hoogle searches
08:31:21 <remexre> I've seen `hoogle generate --local`, but I think that's only globally installed things, right?
08:34:30 <shapr> remexre: I don't remember, sorry
08:48:03 <shapr> Does anyone use the Pragmata Pro font with Haskell? Any thoughts on whether it's worth it?
08:49:29 <remexre> I've got a friend who uses it pretty much everywhere; ligatures aren't to my taste, but it's certainly pretty
08:49:47 <remexre> I'm a cheapskate so when I do want pretty Haskell I use Fura :P
08:50:23 <shapr> I've been tempted to several years
08:50:34 <shapr> remexre: does your friend use PragPro in emacs?
08:50:41 <shapr> I'm curious if the Haskell ligatures work
08:50:49 <ziman> i think christiansen[m] uses it, assuming that's the christiansen i know :)
08:51:02 <remexre> shapr: Vim
08:51:19 <remexre> afaik most of his Haskelling is xmonad configuration tho
08:51:53 <shapr> heh, fair enough
08:52:14 <shapr> christiansen[m]: do you use Pragmata Pro in emacs? do ligatures work?
08:52:42 <ziman> afaik he wrote a fair bit of idris, too, and he could definitely have something to say about the ligatures
08:53:42 <ziman> http://www.davidchristiansen.dk/david-christiansen-phd.pdf
08:53:46 <ziman> this is pragmata pro, isn't it?
08:55:04 <ziman> fwiw, i use fira code in gvim and i'm happy with it :)
08:56:39 <shapr> ziman: I'm not sure if that's Pragmata Pro or not
08:56:48 <shapr> certainly looks like a fun read
09:08:17 * hackage servant-fiat-content 1.0.0 - Fiat content types  https://hackage.haskell.org/package/servant-fiat-content-1.0.0 (Jappie)
09:08:29 <tabaqui> Data.List.nub take n^2 time
09:08:59 <tabaqui> err, why not n * log n?
09:09:23 <tabaqui> sort >>> group >>> map head
09:09:42 <Taneb> tabaqui: no Ord constraint
09:10:24 <Solonarv> can't sort with only Eq
09:11:01 <Solonarv> there are a few 'ordNub :: Ord a => [a] -> [a]' implementations around which do run in n log n
09:11:12 <tabaqui> I dunno, what if we introduce some arbitrary ordering on elements
09:11:39 <Taneb> Can't in general be done compatibly with the Eq instance (citation needed)
09:11:41 <tabaqui> we can do this with haskell ADT, don't we?
09:11:55 <ddellacosta> I'm trying to model an undirected graph where, once a vertex is visited, it may allow for a new edge to be created between two vertices that were previously not directly connected. Another way to frame it is as the calculation of successive graph minors. I'm having troube figuring out any approach to this other than some kind of brute force calculation, but what I'm wondering is if there is a data structure
09:11:57 <ddellacosta> where the edge calculations resulting from removing vertices just kind of "falls out." Does this ring any bells for anyone?
09:12:05 <Solonarv> sure, you can always define some arbitrary ordering for an ADT (if all its fields are ordered)
09:12:27 <Solonarv> but not all types in Haskell are ADTs - there are also functions, for example
09:12:56 <Taneb> Solonarv: functions don't have an Eq instance either, so they're not relevant
09:13:03 <Solonarv> oh, true
09:13:08 <Solonarv> another example, then: IORef
09:13:09 <Taneb> One example of a type that has Eq but not Ord is IORef (iirc)
09:13:15 <Taneb> Heh, snap
09:14:40 <tabaqui> well, we can write special "freeCompare" method for arbitrary Eq instance
09:14:59 <tabaqui> IORef can be compare by its address in memory, for example
09:15:13 <Solonarv> that breaks things (I don't remember what exactly)
09:15:26 <Solonarv> also isn't actually possible, there's no way to get at the address corresponding to an IORef
09:15:35 <tabaqui> right, in pure haskell
09:16:09 <Solonarv> no, there isn't even an unsafe compiler primitive for it
09:16:29 <Solonarv> at least I couldn't find one when I went looking a few days ago
09:16:37 <tdammers> wouldn't that also annihilate all sorts of assumptions?
09:17:10 <Solonarv> it might not break much on IORefs alone
09:17:38 <Solonarv> it would break referential transparency if available on STRef (which are internally the same as IORef)
09:19:35 <Lycurgus> the EHT image is not Sagitarius A* contrary to dumb ass media reports
09:20:32 <Solonarv> the article I saw did not misreport it as Sag A*
09:20:37 <Solonarv> also, uh, wrong channel?
09:21:32 <Lycurgus> no
09:57:17 * hackage mixed-types-num 0.4.0 - Alternative Prelude with numeric and logic expressions typed bottom-up  https://hackage.haskell.org/package/mixed-types-num-0.4.0 (MichalKonecny)
10:27:17 * hackage heavy-log-shortcuts 1.0.0 - Simle api for heavy logger  https://hackage.haskell.org/package/heavy-log-shortcuts-1.0.0 (Jappie)
10:57:18 <fen> @tell Cale do we have an example of an app written in haskell compiled to android using obelisk which uses the tilt function of the android device?
10:57:18 <lambdabot> Consider it noted.
10:59:43 <tabaqui> @tell tabaqui test
10:59:43 <lambdabot> You can tell yourself!
10:59:56 <tabaqui> @tell tabaqui wat?
10:59:56 <lambdabot> You can tell yourself!
11:00:15 <tabaqui> it keeps the message while the user is offline?
11:01:20 <fen> you cant tell yourself? 
11:01:41 <tabaqui> I can but target doesn't listen!
11:02:12 <delYsid`> In attoparsec (or any other parser combinator) is there a way to fail harder?  In particular, I have a check that really means the data is invalid, which is done inside of a parser that is being passed to sepBy.  calling fail will just end sepBy, and not propagate the error.  I guess I could use ExceptT, but attoparsec is not a transformer...
11:02:22 <fen> it adheres to the idea that communication is for exchange of information otherwise unobtainable 
11:02:29 <shapr> @tell tabaqui hi
11:02:29 <lambdabot> Consider it noted.
11:02:30 <Solonarv> @help tell
11:02:30 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
11:02:38 <Solonarv> tabaqui: there you go :>
11:02:58 <tabaqui> oh, fine
11:03:56 <fen> you can query yourself but it just echoes back what you write
11:04:05 <fen> maybe thats the same as telling yourself
11:04:12 <fen> but equally as useless 
11:04:56 <fen> like, a really extreme version of an echo chamber... 
11:05:36 <tabaqui> maybe, maybe not :)
11:05:50 <tabaqui> some thinks that "forall a. a -> a" function is useless :)
11:06:14 <shapr> delYsid`: switch to megaparsec since it's a real monad transformer?
11:06:15 <fen> isnt that the unit used to create natural numbers from?
11:06:54 <shapr> megaparsec also allows you to use a custom error type, but I've never tried that
11:07:03 <tabaqui> not at all
11:08:08 <Solonarv> 'forall a. a -> a' has exactly two valid implementations: '\x -> x' (AKA id) and '\_ -> _|_' (AKA 'const undefined')
11:08:22 <Solonarv> if we're ignoring bottoms then there is only id
11:17:00 <delYsid`> shapr: speed is a primary concern.  I need to parse up to gigabytes of ascii data.
11:17:10 <Cale> fen: I don't have an example presently, but that is a good idea for a demo. There are bindings to DeviceMotionEvent and DeviceOrientationEvent in ghcjs-dom, which should be usable. There's a primitive thing in reflex-dom called wrapDomEvent which can be used to capture the occurrences of a DOM event like the devicemotion event on the window object, and create a corresponding reflex Event.
11:17:26 <shapr> delYsid`: I've read that megaparsec isn't much slower than attoparsec, but I have not compared them.
11:18:15 <Cale> fen: Or deviceorientation, depending on what it is that you want.
11:18:28 <delYsid`> hmm, maybe I should try.  But first I need a baseline to compare to.
11:18:54 <shapr> delYsid`: yeah, I mostly use attoparsec, but I'm trying to switch to megaparsec for improved error messages
11:19:49 <delYsid`> good errors would be nice to have.  Which reminds me: How do I get good errors when using ExceptT for hard failures?  That would bypass all the error message mechanism I guess?
11:19:51 <MarcelineVQ> shapr: afaik for both it just depends on the combinators you use. this is why attoparsec's docs emphasise the speedier combinators
11:21:14 <fen> Cale: well, whats needed are all different levels of hardware IO. so the wrapDomEvent is the more relevant for this? is that how we could do android or iphone bluetooth? or is there something for that already, possibly built on what you describe?
11:21:32 <delYsid`> I once used Spirit Qi (C++ parser combinator library) which had a version of *> that would commit to the current branch, throwing away backtracking abilities.  Something like that would really help here I guess.
11:21:37 <Cale> fen: I was talking about device orientation.
11:21:59 <fen> basically just chose tilt because it was an "easy" phone hardware interaction
11:22:24 <fen> but basically an example of any phone specific hardware interaction would be equivalent 
11:22:47 <shapr> delYsid`: megaparsec doesn't backtrack without try
11:22:48 <fen> or maybe they all have different wrappers.. not really sure how it works
11:22:54 <shapr> unlike attoparsec
11:23:07 <Cale> fen: Anything which you can't access from a webview is probably going to be rather inconvenient to get access to, as you may need to extend the Java wrapper that does the FFI to the Haskell program to add support for it.
11:23:09 <MarcelineVQ> delYsid`: yeah I kind of like that sort of option, like *!> for committing and *> for backtracking
11:23:34 <fen> Cale: oh thats similar to the earlier question of opengl shader drivers
11:23:57 <fen> that they can be accessed from a web app of haskell opengl compiled to js
11:23:59 <fen> ?
11:24:22 <Cale> fen: Well, the Haskell program isn't compiled to js in the case of a mobile build
11:24:24 <ph88> is ekmett still coming around here anymore ?
11:24:43 <fen> so is it that the existence of this means that graphic specific hardware interaction is a special case, just because opengl has custom driver implementations
11:24:47 <Cale> But it's still manipulating the contents of a webview
11:24:51 <fen> oh
11:25:26 <fen> can you explain that more? maybe with respect to how opengl manages to still work on android...
11:25:55 <Cale> I've never built an opengl app on android -- are you referring to like, webgl stuff?
11:26:02 <Cale> Or you want real opengl?
11:26:18 <fen> well, not sure which of those has these drivers...
11:26:31 <Cale> If it's the latter, then you'll have much more work to do -- we don't have any specific support for that yet.
11:26:51 <fen> was under the impression opengl had graphics card interaction in the form of shader driver implementations
11:26:53 <MarcelineVQ> Can't be that hard, there's plenty of mobile games.
11:27:01 <Cale> (It would be like, an entire alternate library to replace reflex-dom, perhaps with another reflex-based graphics library)
11:27:14 <fen> oh
11:27:27 <Solonarv> I wonder what the chances are that reflex-sdl2 Just Works on android
11:27:35 <Cale> haha, pretty low
11:27:48 <fen> so this isnt going to help understand how the ability to do graphics interactions could be extended to general hardware IO
11:28:45 <fen> either its a question of what specific hardware libraries exist already, or a case of how it is possible to provide those
11:29:40 <fen> "you may need to extend the Java wrapper that does the FFI to the Haskell program to add support for it."
11:29:41 <delYsid`> MarcelineVQ: Is there any parser combinator library in Haskell world that does that?
11:29:47 <fen> that seems pretty reasonable
11:29:59 <fen> just got confused about opengl shaders
11:30:42 <fen> so whats the extent of the existing FFI haskell-java interplay?
11:31:01 <fen> we can do graphics and device orientation, but what else?
11:31:03 <fen> sound? 
11:31:22 <Cale> We can do anything that you can do with a webview, which is actually quite a lot
11:31:39 <Cale> https://github.com/ghcjs/ghcjs-dom/tree/master/ghcjs-dom-jsffi/src/GHCJS/DOM/JSFFI/Generated
11:32:08 <Cale> (also have a look a the parent directory, there's a few things which are more hand-wrought, it seems)
11:32:22 <delYsid`> hmm, maybe I can use peekChar to at least detect that a failure was swallowed...
11:32:28 <fen> but can we get an idea of what is the extent of that? like, are bluetooth, airplane mode, camera, etc
11:33:20 <Cale> I doubt there's anything about bluetooth or airplane mode -- that stuff doesn't seem like the sort of thing you'd ever want to expose to web applications.
11:34:35 <fen> aha
11:34:52 <fen> or your contacts or something
11:35:12 <fen> ok, well thats a pretty reasonable kind of accidental security layer 
11:35:36 <fen> but if it stops us being able to write full phone apps then its more of a limitation 
11:36:01 <fen> does that restrict heavily what kind of apps you can build for clients at obsidian? 
11:36:27 <fen> or do most people just want stuff that can be done using this webview approach?
11:36:43 <Cale> One of the only things we do have apart from the stuff that a webview normally gets is a bit of support for sending firebase registration (for notifications), and some events regarding the state of the app (whether it's focused etc.) which we needed for determining whether someone was active in a chat app.
11:37:08 <fen> are there any ideas that could allow an increased range of hardware interactions? or would they always be restricted by the webview?
11:38:14 <Cale> They're not strictly restricted by that, we can always add additional facilities because ultimately we *are* running a wrapper application which starts up that webview and has access to everything that a normal android app would.
11:38:25 <fen> like, is it a case of how much extra work it is to add these specifically on a case by case basis, like, if there is incentive enough to add support for a particular hardware interaction
11:39:12 <Cale> Yeah, it's much less convenient to push through support for that stuff, but by no means impossible.
11:39:36 <fen> aha, so the webview itself does *not* limit the ability to do hardware IO, just means a different (and more difficult?) development process is required to add this functionality?
11:41:37 <Cale> Yeah
11:42:04 <fen> was reading more about the process of changing the focal distance of the camera, and it seems like it has something to do with the device manufacturers provided aip differing between makes and versions, so that there is a porting bottleneck on the android side between its OS versions
11:42:48 <fen> basically, the more subtle hardware interactions are less likely to be provided or well documented, and would then be even more difficult to access from haskell
11:45:07 <Cale> I mean, it's the difference between being able to just write Haskell code in your own program, and having to write C and Java code, in addition to wiring things up on the Haskell side.
11:45:34 <Cale> (and yeah, then you have to deal with more device differences)
11:47:47 * hackage parameterized-utils 2.0 - Classes and data structures for working with data-kind indexed types  https://hackage.haskell.org/package/parameterized-utils-2.0 (KevinQuick)
11:47:49 <fen> right, so then is it right to rely on obsidian to do all this work for the open source community from the revenue it gets from clients? have absolutely no quarms with expecting google to be able to patch through all the different apis for hardware functions of various device manufacturers, but feel slightly less ok about expecting a much smaller haskel company to take on a similar task to then port all these features on to haskell
11:47:52 <Cale> And of course, if you want to add something for Android, then you also probably want to add corresponding functionality for iOS...
11:48:39 <Cale> Well, we're only doing the bits of it that make sense for us to do, of course. You really can write quite a lot of application frontends without needing any of it.
11:48:44 <fen> well, ok, google + apple, but yeah they are still comparatively better equipped to take on such challenges   
11:49:11 <Cale> Perhaps, but who is going to convince them to care about Haskell?
11:50:00 <fen> Cale: sure, most clients are not as fussy as a deliberately obscure request for the ability to write an autofocus program in haskell 
11:50:34 <fen> Cale: part of the advantage of using haskell is as a way to escape from the "corporate owned" languages
11:50:45 <Cale> https://github.com/reflex-frp/reflex-dom/blob/develop/reflex-dom/java/org/reflexfrp/reflexdom/MainWidget.java -- here's the Java code which reflex-dom uses on android
11:51:22 <fen> some of which have a seemingly artificially high barrier to learning or whatever its called. a kind of expertise based limitation to the ability to write apps
11:51:38 <fen> not sure if thats just imaginary... 
11:52:02 <fen> but yeah, there might be real advantages of using haskell for mobile development
11:53:07 <shapr> do you like return? or are you a purist?
11:53:11 * shapr stops making FP jokes
11:53:16 <Cale> haha
11:54:10 <fen> and then this point was just supposed to suggest there may exist reasons big companies might deliberately not want to use haskell - or if they did, that there might be the possibility for the existence of language user preferences not to use a language which is "owned" 
11:55:09 <fen> arguments about the economy of scale, and language support funding as opposed to a kind of democratic control on the language itself 
11:55:25 <fen> but at that point its become completely ideological 
11:55:46 <Cale> https://github.com/ghcjs/jsaddle/tree/master/jsaddle-clib -- then there's this library which gets used on Android and also is part of the control chain between that Java and your Haskell code, so it also needs changing to reflect any new low-level features you're adding.
11:55:46 <fen> i just want to write a better app in a better language! 
11:56:01 <Cale> But it's doable!
11:56:10 <Cale> Just not something you hope to do very often.
11:56:42 <fen> the widget is illegible 
11:57:56 <Cale> https://github.com/ghcjs/jsaddle/blob/master/jsaddle-clib/src/Language/Javascript/JSaddle/CLib/Internal.hsc you can see here some low-level Haskell code where we're hooking up callbacks for various events that we needed in addition to the stuff that the DOM provided
11:58:13 <fen> does this mean there is a limitation to the ability to get employment writing android apps as a haskell user with no ability to read java? 
11:58:29 <fen> ie, haskell is not yet a fully fledged android development language
11:58:46 <Cale> You should almost never have to touch this code
11:59:12 <Cale> The assumption here is that you're writing mobile versions of web applications.
11:59:50 <Cale> (which will run much faster on a phone than the actual web version)
12:02:38 <Cale> But I suppose if you really want to cover all your bases, you might want to learn enough Java to be able to deal with this code if you really had to? Honestly, it's under a couple hundred lines of Java, which by Java standards is practically "hello, world!" ;D
12:03:17 * hackage acousticbrainz-client 0.1.0.0 - AcousticBrainz API client  https://hackage.haskell.org/package/acousticbrainz-client-0.1.0.0 (koral)
12:03:37 <fen> basically, as google is able to provide almost totally complete (again, it does not seem like they have managed to give control of the focal length sufficently, so we can even see google managing to fall short) android java and C, its easy to develop almost anything in those languages, but 
12:03:38 <fen> by depending on obsidian who are less capable than google and apple, the haskell community is still somewhat limited in its capability to develop for android  
12:04:40 <fen> yeah, but if you cant extend it then you cant work for obsidian? or more generally, as it requires at least some expertise to write that kind of code by someone in the company, its very difficult to set up a team to write android apps in haskell
12:04:45 <Cale> Sure, though you don't *have* to depend entirely on us
12:04:52 <Cale> We're not doing anything magical here
12:04:59 <Cale> and we're sharing pretty much everything we do
12:05:05 <fen> you are, your doing stuff in a language other than haskell
12:05:27 <fen> thats not the remit of a haskell app dev
12:05:36 <Cale> (at least, as far as it pertains to producing Haskell applications on Android and iOS, there's nothing we're holding back from the public)
12:05:56 <fen> that was not implied even slightly!
12:06:14 <fen> it should be no criticism that the company is not as large or as capable as google!
12:06:31 <Cale> Well, I'm just making the point that everyone has access to this stuff, and if they really need it to be more capable, it can happen
12:06:43 <fen> quite the opposite, the effort is highly commendable and much appriciated
12:06:44 <cocreature> I trust obsidian a lot more to not be evil than google :)
12:07:07 <fen> that was the point about ideology earlier 
12:07:17 <fen> not sure if its realistic though...
12:07:39 <Cale> Sure, you might need to learn enough Java or C or objective C to mess with the tiny wrappers if you really want to dig into the whole chain of interaction that's going on.
12:07:47 <Cale> But most developers will never need to do that
12:08:05 <fen> raising the question of how much of a priority for an open source language to be perceived as benevolent 
12:08:10 <Cale> Similarly, it's conceivable that when you're writing a Haskell program, you might need to fix something in GHC's RTS which is written in C.
12:08:42 <fen> actually, thats arguably one of the main selling points! take linux for example, breaking paywalls and proprietary-ness is a main aim
12:08:45 <Cale> Hopefully not, but it's always possible
12:09:14 <fen> so maybe google capturing ownership of haskell by making it an offically supported language (writing android-haskell) is not what we want
12:09:43 <Cale> It might be nice, but that would depend on how they made it happen.
12:10:25 <fen> Cale: so then your calling on Microsoft right? if its a GHC issue? but hardly think its a proprietary language just because of that 
12:10:35 <Cale> What?
12:10:55 <fen> ghc is spj ?
12:11:10 <Cale> Microsoft doesn't really do anything about GHC issues, apart from occasionally having put paychecks into the pockets of a couple of GHC developers
12:11:24 <delYsid`> Microsoft research has done a pretty good job of keeping out of Haskell politics AFAICS.
12:11:57 <Cale> (and it's debatable that MS Research is even really MS)
12:12:01 <fen> right, and we are even at the helm of facebooks anti-abuse software, so this logic probably is totally wrong!
12:12:15 <delYsid`> In fact, their not bragging about it always impressed me as good PR.
12:12:20 <Cale> It bears a similar relationship to Microsoft that Xerox PARC did to Xerox)
12:13:01 <fen> that is a very obscure reference!? whats that some kind of printed words based technology?
12:13:01 <Cale> Simon Marlow is actually the guy who probably knows most about GHC's RTS
12:13:54 <fen> yeah, but there is a difference between facebook using haskell, and google porting the language to android
12:14:18 <Cale> Xerox PARC was responsible for major developments on the GUI, object oriented programming, they made Ethernet, etc. etc.
12:14:47 <fen> most people have never even heard of Sun!
12:15:02 <Cale> Xerox was only interested in a tiny fraction of anything they did
12:15:48 <Cale> MSR is similar with respect to MS
12:16:16 <fen> are you suggesting we form a spliter-cell faction of google to subvert funding to the haskell cause!? seems a bit too guerrilla 
12:16:35 <Cale> hah, no
12:16:41 <fen> thank god for that
12:16:53 <fen> ok, thanks for the info on haskell android
12:17:00 <fen> bye!
12:17:06 <Cale> Just pointing out that GHC's ties to Microsoft proper are extremely weak
12:21:41 <nshepperd> there's a loose cooperative of volunteers inside google who work on (using internally) haskell
12:23:01 <nshepperd> dunno if we get any funding per se though
12:23:05 <nshepperd> porting haskell to android seems conceivable but rather ambitious
12:23:51 <geekosaur> it was done before iiirc. around android 3 days, though
12:23:59 <geekosaur> android has grown a bit since then
12:24:52 <geekosaur> (basically using a custom runtime which interfaced with a wrapper java app. the result wasn't great but at least simple stuff worked)
12:33:02 <nshepperd> i sort of imagined that the easiest way would be to get regular ghc to output STG, then run it with an STG interpreter written in java, implementing the RTS and all of the primops
12:33:59 <cocreature> is that how Eta works? I’ve never actually looked at how they implement it
12:38:35 <nshepperd> not sure. their faq mentions bytecode generation though
12:53:02 <Solonarv> AIUI Eta works just like GHC, but the final step is different - instead of generating native code (or LLVM) it generates JVM bytecode
12:53:18 <MarcelineVQ> "<delYsid`> MarcelineVQ: Is there any parser combinator library in Haskell world that does that?" I don't know, I first saw it in a total parser combinator lib in idris.
12:53:47 <cocreature> Solonarv: I thought it only goes to stg and not c--?
12:53:55 <MarcelineVQ> Because that's a place where stating whether something commits affects the provability of whether it's total
12:54:17 <Solonarv> possibly, I haven't looked into it
12:56:32 <MarcelineVQ> Also, I imagine, because idris isn't lazy so being clear about commiting might be more important. not sure
13:21:47 * hackage bv-sized 0.7.0 - a BitVector datatype that is parameterized by the vector width  https://hackage.haskell.org/package/bv-sized-0.7.0 (benselfridge)
13:29:47 * hackage polysemy 0.1.0.0 - Higher-order, low-boilerplate, zero-cost free monads.  https://hackage.haskell.org/package/polysemy-0.1.0.0 (isovector)
13:45:59 <jakov> hello ! I have got a tooling/package-compilation question: Is it possible to cross compile stack packages on a x86_64 build machine, while using the results on a armv7l Raspberry Pi ?
13:45:59 <jakov> It is painstakingly slow to compile just a few packages on the raspberry pi itself. 
13:45:59 <jakov> I would like to use ghc > 8.2, and i have nixos installed, so nix expressions are welcome :). Any reading references are welcome too ! 
13:45:59 <jakov>  
14:38:56 <tchakka> Pffff... compiling singletons takes a ridiculously long time.
14:39:29 <tchakka> Admittedly, my machine is getting somewhat old, but 40 minutes (and counting)? C'mon >_<
14:50:05 <delYsid`> MarcelineVQ: ah, idris.  thanks for the pointer.
14:58:03 <jle`> tchakka: yeah, it can be bad :| there's a lot of work the compiler does, and also a lot of typechecking logic
14:58:34 <jle`> and one thing that pushes it a bit more is that the code that takes a long time to compile are generated with template haskell
15:00:41 <p0a> Hello what is the flag that ghci uses so that every time I save a file it gets reloaded?
15:01:03 <c_wraith> is that something in ghci?
15:01:19 <p0a> I thikn so 
15:01:23 <boj> p0a: perhaps you are after a tool like ghcid?
15:01:34 <p0a> I thought it's just a flag of ghc
15:02:30 <geekosaur> ghc/ghci does not do that
15:02:46 <p0a> hm...
15:02:52 <p0a> maybe I should just use :load and then : to repeat the command 
15:02:53 <geekosaur> stack has a "watch" mode for compiles
15:03:34 <p0a> for example :load test.hs loadsa my Main but then `:' does not load it again 
15:03:38 <p0a> it says `Ok, modules loaded: none.'
15:08:45 <Solonarv> :reload (or :r for short) reloads everything you :load'ed
15:09:45 <p0a> Solonarv: oh, nice. I can type :r and then I can just use :
15:10:01 <Solonarv> yup
15:10:29 <Solonarv> you can automate this using ghcid - which isn't much more than a wrapper over ghci that does :reload when a file changes
15:10:34 <jle`> TIL about :
15:10:36 <Solonarv> @where ghcid
15:10:36 <lambdabot> I know nothing about ghcid.
15:12:49 <geekosaur> : just repeats the last command, which is often a ":l" or ":r"
15:14:04 <jle`> oh
15:31:20 <duairc> Is it possible in a .cabal file to declare a (runtime) dependency on a command-line binary?
15:31:47 * hackage mattermost-api 50200.1.4 - Client API for Mattermost chat system  https://hackage.haskell.org/package/mattermost-api-50200.1.4 (JonathanDaugherty)
15:32:10 <Solonarv> not as far as I know
15:32:10 <Boarders> what is the difference between cabal new-repl and cabal v2-repl?
15:32:18 <Solonarv> Boarders: nothing
15:32:21 <Boarders> oh ok
15:32:41 <Solonarv> v2-* and new-* are different aliases for the same thing(s)
15:32:47 * hackage matterhorn 50200.3.1, mattermost-api-qc 50200.1.4 (JonathanDaugherty): https://qbin.io/haiti-suck-nyv7
15:32:52 <Boarders> thank you!
15:33:25 <Solonarv> in cabal 3.0 those commands will be the default, so the prefix won't be needed at all
15:34:09 <geekosaur> and 'new-' will at some point start to point to new / proposed features
15:35:06 <p0a> How can I have a type for a nonzero 
15:35:10 <p0a> nonzero Integer? for example 
15:36:00 <p0a> or a unit vector. These are just examples 
15:36:07 <p0a> where I want only a specific range of values from a type
15:37:43 <geekosaur> not easily. there's some type level stuff that can help, but it's generally a pain to work with
15:38:29 <p0a> interesting 
15:38:36 <p0a> that's always been something I desired to have 
15:38:53 <p0a> well got to go
15:38:58 <Solonarv> the simplest solution is to define a newtype+smart constructor, like so:
15:38:58 <Solonarv> % newtype NonZeroInt = NonZeroInt Int
15:38:59 <yahb> Solonarv: 
15:39:11 <p0a> What does it do when I do NonZeroInt 0
15:39:16 <p0a> Or is it a semantic suggestion
15:39:18 <Solonarv> % mkNonZeroInt 0 = Nothing; mkNonZeroInt n = Just n
15:39:19 <yahb> Solonarv: 
15:39:31 <geekosaur> that's why you need a smart constructor: just wrapping the 0 isn't an error
15:39:39 <geekosaur> but a nonZeroInt function can test and reject it
15:39:42 <Solonarv> you don't export the NonZeroInt constructor, so it's impossible to write 'NonZeroInt 0'
15:40:02 <p0a> huh
15:40:09 <geekosaur> what you want is called a dependent type (its type depends on its value), and Haskell doesn't currently support that
15:40:29 <p0a> anyway, got to go. thank you 
15:40:37 <p0a> I'll see abotu it. not very important right now for my project
15:42:02 <Solonarv> @tell p0a you can also do this sort of thing with Liquid Haskell - an external type-checker that allows you to attach predicates like "not zero" or "less than 42" to types
15:42:02 <lambdabot> Consider it noted.
16:09:07 <Boarders> is there a standard name for the function: f :: Monoid m => Maybe m -> m; f = maybe mempty id
16:09:17 * hackage LambdaHack 0.9.3.0 - A game engine library for tactical squad ASCII roguelike dungeon crawlers  https://hackage.haskell.org/package/LambdaHack-0.9.3.0 (MikolajKonarski)
16:12:24 <Clint> Boarders: dunno about standard, but https://hackage.haskell.org/package/universum-1.5.0/docs/src/Universum.Monoid.html#maybeToMonoid
16:13:13 <Solonarv> Boarders: fold
16:13:15 <Boarders> CLint: thanks!
16:13:26 <Boarders> Solonarv: cheeky :)
16:13:30 <Solonarv> > fold Nothing :: String
16:13:31 <lambdabot>  ""
16:13:39 <Solonarv> > fold (Just "hello")
16:13:41 <lambdabot>  "hello"
16:13:58 <Solonarv> also: maybe x id = fromMaybe x
16:14:12 <Boarders> yeah, I forgot about fromMaybe
16:14:19 <Solonarv> fold is (unsurprisingly) in Data.Foldable
16:14:37 <Solonarv> :t fold
16:14:38 <lambdabot> (Monoid m, Foldable t) => t m -> m
16:14:43 <Boarders> yeah, I use it all the time actually
16:14:54 <Boarders> just didn't occur to me with a more specialised type )_o
16:21:47 * hackage Allure 0.9.3.0 - Near-future Sci-Fi roguelike and tactical squad combat game  https://hackage.haskell.org/package/Allure-0.9.3.0 (MikolajKonarski)
16:40:17 * hackage b9 0.5.68.3 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-0.5.68.3 (SvenHeyll)
16:48:17 * hackage mixed-types-num 0.4.0.1 - Alternative Prelude with numeric and logic expressions typed bottom-up  https://hackage.haskell.org/package/mixed-types-num-0.4.0.1 (MichalKonecny)
17:19:57 <MarcelineVQ> hey you; good job
17:24:42 <hpc> MarcelineVQ: "hey you"? that's me! :D
17:26:11 <MarcelineVQ> you bet
17:26:21 <MarcelineVQ> good job
17:26:46 <hpc> :t (<3)
17:26:47 <lambdabot> (Num a, Ord a) => a -> Bool
17:30:04 <jle`> aw man. foldable instance for tuples got me again
17:31:57 <jle`> can we not
17:32:00 <jle`> have them :'(
17:32:26 <jle`> maybe we can add a deprecated notice on every method
17:32:48 <MarcelineVQ> what happened :>
17:32:49 <jle`> length _ = 1 { -# DEPRECATED length why #-}
17:33:09 <jle`> oh i was trying to get the lenght of a list but it was actually a list inside a tuple that i forgot
17:34:03 <Solonarv> instance TypeWarning ('Text "why") => Foldable ((,) a)
17:34:14 <jle`> :)
17:34:29 <Solonarv> if only
17:36:42 <hpc> i hope these warning and error types take off
17:37:00 <hpc> i can see them being very useful for making future changes
17:39:29 <Solonarv> containers is already using them
18:04:09 <dibblego> there is no such thing as foldable for tuples
18:08:32 <Solonarv> sure there is, it's just not super useful
18:09:07 <Solonarv> and there's an alternative foldable-like thing for tuples which requires all the fields to have the same type and does what you expect
18:09:26 <Solonarv> (you can find it in lens, it's called Each I think)
18:09:38 <dibblego> I just checked, it's still a kind error
18:12:36 <nshepperd> dibblego: instance Foldable ((,) a)
18:12:56 <dibblego> oh, so not tuple then
18:13:04 <dibblego> there is no such thing as foldable for tuples
18:13:12 <nshepperd> (,) is certainly a tuple
18:13:25 <dibblego> looks like a constructor to me
18:13:39 <dibblego> so does, forall a. ((,) a)
18:13:52 <nshepperd> if you want to interpret 'foldable for tuples' wrong, it seems like you're the one with the kind error
18:14:10 <dibblego> the distinction is important
18:14:25 <nshepperd> yes it is, so stop getting wrong on purpose
18:14:39 <dibblego> there is a strong correlation between those who object to the instance, and those who state it incorrectly [and conceptualise it incorrectly?]
18:14:58 <dibblego> I am not getting it wrong on purpose, I am getting it correct deliberately, because I think it is important
18:16:48 <nshepperd> translating from informal to formal language in the most autistic way possible isn't getting it correct
18:17:05 <jle`> indeed i was referring to the foldable instance typically associated with tuples, which is the instance ((,) a).  i don't object to the instance conceptually, but i do think it opens a lot of bugs that are unrelated to how it is conceptualize
18:17:06 <dibblego> oh ok, you win then, totally convinced
18:17:39 <dibblego> jle`: happy to discuss this matter elsewhere, I understand your point
18:18:21 <nshepperd> you wanna say that there's no show instance for Sets as well?
18:19:10 <dibblego> yes, due to my autism
18:19:32 <geekosaur> nshepperd, can you at least find a different way to express yourself?
18:23:58 <tomsen> hey i remember a page on some haskell wiki listing many short code snippets showing off syntax. they also showed different implementations things like quicksort and simple problems. a chance anyone knows the buzzword to find it again?
18:31:06 <geekosaur> tomsen, tbh that describes quite a lot of the wiki :)
18:31:22 <tomsen> haha dang
18:40:28 <dibblego> tomsen: maybe this https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems
18:42:30 <tomsen> it's not the one, but it's just aswell, exactly what i'm looking for. thanks dibblego, thanks geekosaur
18:43:03 <geekosaur> you can also look at Category:Code but there's a lot of stuff in there
18:43:22 <geekosaur> including e.g. old programs from the old debian programming languaage shootout
18:45:14 <Clint> the what
18:46:40 <geekosaur> https://salsa.debian.org/benchmarksgame-team/benchmarksgame
18:46:46 <jusss> about Monad, what is the function "join" ?   it's related with "bind" or "unit" ?
18:46:54 <geekosaur> apparently it changed names, but we haven't done much with it since that
18:47:11 <Solonarv> jusss: it's related to 'bind', yes
18:47:15 <geekosaur> jusss, bind is join . fmap
18:47:32 <geekosaur> roughly
18:47:57 <jackdk> join, (>>=) and (>=>) are equivalent in power - you can write each using any other
18:48:11 <jusss> it means bind = \x join(fmap(x)) ?
18:48:17 <Solonarv> k >>= x = join (fmap k x)
18:48:17 <Solonarv> join x = x >>= id
18:49:14 <Solonarv> the actual point-free way to write this is '(>>=) = (join .) . fmap' which is a bit confusing
18:49:48 <jusss> no more infix expressions please
18:50:40 <tomsen> geekosaur i think i mixed things up, a part of what i was looking for was the fibonacci sequence page, found it with your advice. but category:code offers much more. i somehow never learned how to browse wikis.
18:50:42 <jusss> join x = bind(x,id)?
18:51:13 <geekosaur> well, that one is specific to mediawiki, other types of wikis have their own ways (or sometimes none)
18:51:51 <geekosaur> which is the problem with wikis in general, each one is kind of its own weird beast with its own features derived from how it's implemented and others depending on who, if anyone, bothered to try to organize their content
18:52:01 <Solonarv> jusss: there isn't actually a function named 'bind' in base; I prefer talking about functions that are actually defined
18:53:21 <tomsen> how is your way of getting from mainpage to category:code ? there is wiki community -> all pages, but seems wrong
18:54:05 <tomsen> ah i take it back, there is wiki under "join the community" on the right
18:56:10 <geekosaur> here, I happen to know that's how mediawiki category lookups work, but if you follow that link you get a list of pages in category Haskell and a list of subcategories, including Code
18:58:16 <jusss> Solonarv: >>= isn't pronouced "bind"?
18:58:31 <Solonarv> it is, but that isn't its actual name
18:58:40 <Solonarv> and it certainly doesn't take a tuple as an argument
18:58:55 <Solonarv> so talking about 'bind(x,id)' is at best misleading
18:59:36 <jusss> Solonarv: it's not a tuple, I just use the way to express in other languages
19:00:05 <jusss> I don't think bind(x,id) is a tuple in other languages, it is?
19:00:22 <Solonarv> no, and it isn't a tuple in haskell either
19:00:36 <Solonarv> it's a function 'bind' applied to a tuple '(x,id)'
19:00:54 <jusss> ok
19:01:06 <geekosaur> jusss, if your earlier 'don't use infix' really meant 'don't use Haskell syntax', that's kinda going to be a problem when talking about Haskell
19:01:11 <geekosaur> we do not write things that way
19:01:37 <geekosaur> and some things can't reasonably be written that way, although I understand that is what yu'ere trying to avoid… but it can't always be avoided
19:01:57 <jusss> fine
19:01:58 <geekosaur> it's one of Haskell's strengths it gets used a lot, "avoid it" isn't going to help
19:02:22 <jusss> can I avoid point-free style?
19:02:31 <jusss> or pointless?
19:02:39 <Solonarv> sure, although it can be a lot more verbose and harder to read
19:09:31 <monochrom> We are all going to agree to not abuse pointfree. And to not abuse pointful.  (Yes pointful can be abused too.)
19:09:47 <monochrom> But if you want "religiously pointful" then we don't do religious.
19:09:59 <monochrom> (Yes you are asking for religious.)
19:10:41 <monochrom> (Either that, or ideology.)
19:13:16 <monochrom> Just today my exam questions had one that says "foo can be expressed as a foldr too. Do it: foo = foldr op z where z = _____ ; op x r = _____" (fill in the blanks)
19:13:44 <monochrom> This one is not an abuse of pointfree.  This one is actually better as pointfree.
19:14:03 <dibblego> we do that in data61/fp-course on iterations
19:14:09 <Solonarv> monochrom: but what was foo!? I have to know!
19:14:14 <monochrom> Because if I provided "foo xs = foldr op z xs where ..." students will wrongly try to make use of xs in their op or z.
19:14:20 <dibblego> headOr :: a -> List a -> a
19:14:45 <monochrom> In fact I did provide "xs" last time in the midterm test, and all of them went wrong.
19:15:50 <monochrom> Plus my "op x r = ___" template is not pointfree.  See, I am not religious.  I use pointful and pointfree wisely as a guiding hand.
19:15:55 <Solonarv> oh I'm tired, I didn't even register 'foo = foldr op z' as pointfree
19:16:01 <monochrom> :)
19:16:05 <jusss> how the monad can be used to avoid lots of if-else-then stuff?
19:16:13 <Solonarv> for some reason I only noticed the pointful 'op x r = __'
19:16:16 <monochrom> monad doesn't.
19:16:32 <jusss> and what does?
19:16:32 <dmwit> jusss: https://stackoverflow.com/q/33005903/791604
19:16:40 <monochrom> if-then-else.
19:16:58 <Solonarv> guards or MultiWayIf, potentially
19:17:10 <Solonarv> if you have lots of 'else if'
19:17:26 <monochrom> Why are you on the run? Why are you avoiding this and that? What are you afraid of?
19:18:02 <monochrom> If you said you have 5 levels of if-then-else, sure, that could be improved. But you didn't say it.
19:18:07 <jusss> common pattern?
19:18:14 <monochrom> If it's just one level, what is there to avoid?
19:18:53 <monochrom> What common pattern?
19:18:57 <dmwit> For some conditions, you may find pattern matching more natural.
19:18:59 <dibblego> if(x == null) return null; else { y = f(x); if(y == null) return null; else return g(y); }
19:19:31 <dmwit> And for dibblego's example, see my link above.
19:20:04 <dibblego> here are more examples, https://qfpl.io/posts/fp-cheat-sheet/
19:22:26 <jusss> monochrom: dmwit  https://paste.ubuntu.com/p/qKjy2YKDbv/
19:23:39 <dibblego> that pattern loosely correlates to the behaviour of a specific monad
19:24:04 <dibblego> the practical purpose of monads in general, is that you work with the general case
19:24:22 <Solonarv> (the specific monad here is Maybe)
19:25:10 <jusss> that's what I saw from an article  about how to compose a pattern with monad
19:25:11 <dibblego> consider these two examples, where to someone not familiar with generalisation, will be sure they are very different code snippets, but they both unify at a common pattern (called sequence) 1. https://qfpl.io/posts/fp-cheat-sheet/#sequence-on-maybe-with-list 2. https://qfpl.io/posts/fp-cheat-sheet/#sequence-on-reader-with-list
19:25:49 * dmwit . o O ( If you won't read what I wrote on SO, why should I believe you will read what I write here? )
19:31:01 <jusss> I did, and I can not understand that examples immedly, too many symbols
19:35:31 <dmwit> jusss: I am happy to answer pointed questions. =)
19:38:51 <jusss> dmwit: sorry, I'm not mean to igore your useful link, I did a check, but I'm not smart as you expected, I'm just a newbie to haskell, and I'd like to learn something that I can use it on the most languages not just haskell, because I may never use haskell in my work, I do like to learn it :)
19:39:01 <jusss> ignore
19:54:17 * hackage summoner-tui 0.1.0 - Tool for scaffolding fully configured batteries-included production-level Haskell projects using TUI.  https://hackage.haskell.org/package/summoner-tui-0.1.0 (vrom911)
20:04:09 <johnw> domenkozar: ping
20:04:52 <domenkozar> pong
20:05:04 <johnw> I have a question about streaming in servant
20:05:13 <johnw> it's a very shifting landscape, which has been hard to keep up with
20:05:35 <johnw> where did StreamGenerator go? is servant-streaming still relevant? is there an example of how one should use the newest version on the server and client side?
20:06:51 <domenkozar> make sure to use servant 0.16
20:06:59 <domenkozar> client side body streaming had a runtime error
20:07:13 <johnw> ok
20:07:45 <domenkozar> servant-streaming is deprecated
20:08:07 <domenkozar> use https://docs.servant.dev/en/stable/cookbook/basic-streaming/Streaming.html?highlight=streaming
20:08:32 <domenkozar> there is servant-conduit, etc
20:10:11 <johnw> ah, that's the document I needed, thank you
20:10:40 <johnw> how do I set headers with streaming?
20:10:55 <johnw> just (Headers StreamingHeaders (SourceIO ByteString))?
20:11:02 <johnw> I used to use (Headers StreamingHeaders (StreamGenerator ByteString))
20:22:00 <domenkozar> yeah the former should work iirc
20:23:57 <johnw> ok, giving it a go
20:24:02 <johnw> seems like a lot of other types have changed oto
20:24:11 <johnw> I hope the runtime behavior isn't too different...
20:24:15 <johnw> (we're going from 0.14 to 0.16)
20:41:37 <domenkozar> johnw: I haven't observed any differences at runtime
20:41:50 <domenkozar> you do need to use CPS for client side now
20:42:57 <monochrom> CPS is always a good candidate for moar monadization >:)
20:48:01 <jle`> >:)
21:50:46 <Blackbeard[m]> hello
21:50:57 <p0a> Hi
21:50:59 <blackbart> Hi fren
21:52:10 <Blackbeard[m]> blackbart: ٩(◕‿◕｡)۶
21:52:56 <blackbart> arr matey
21:52:57 <kaizoku> YAARRR
21:53:16 <Blackbeard[m]> I want to learn haskell
21:53:30 <p0a> want meet do
21:54:51 <blackbart> (my nick is actually after Charles Boles the outlaw, not the pirate, though)
21:56:57 <Blackbeard[m]> blackbart: I see
21:57:01 <Blackbeard[m]> p0a: ٩(◕‿◕｡)۶
21:57:20 <johnw> domenkozar: CPS?
21:57:41 <p0a> doesn't render 
22:10:17 * hackage fast-logger 2.4.15 - A fast logging system  https://hackage.haskell.org/package/fast-logger-2.4.15 (KazuYamamoto)
23:38:38 <densetense> I've got a function (a -> b -> (c, d)), which I need to pass to a function that's expecting (a -> b -> c) and (a -> b -> d). Any idea how I'd make that split?
23:40:10 <jackdk> use fst/snd on the result?
23:41:31 <jackdk> if f :: a -> b -> (c, d), then \a b -> fst (f a b) is what you want, no?
23:42:31 <densetense> Yeah, that's what I want
23:42:36 <densetense> Thanks, lazy brain in the morning
23:51:17 <jackdk> or, if you're into that sort of thing: (fst .) . f
