00:00:25 <remexre> if I'm porting ML code that uses modules to Haskell, are type families the nearest construct here?
00:02:05 <jle`> i don't really think of $ as a way to get rid of parentheses.  if you think of $ as a 'substitute' for parentheses, then you will probably run into issues with your intuition
00:02:17 <jle`> i think it should be taught as a parentheses-eliminator, but rather for what it actually is
00:02:24 <sicklork1n> jle`: natural as in consistent
00:02:40 <jle`> sicklork1n: okay, so consistent with what?
00:02:44 <sicklork1n> jle`: ey that's probably why
00:03:20 <sicklork1n> jle`: consistent in the use of `$` to eliminate the need for parens
00:04:23 <jle`> oh. yeah, it's not a parentheses eliminator, it's just a normal operator
00:04:46 <jle`> it's a function application operator, f $ x = f x
00:04:54 <jle`> and it just happens to have lowest precedence
00:05:41 <MarcelineVQ> remexre: backpack might be closer
00:08:26 <jle`> haskellhelp: your manual evaluation should amtch the behavior of what ghc/ghci gives you, so try seeing where you might be making a mistake
00:08:37 <jle`> if you take a picture of your work maybe then we can spot where you're going wrong
00:08:50 <remexre> MarcelineVQ: okay, thanks, reading through one of the blogposts now
00:09:19 <jle`> haskellhelp: i think i might have an idea, but without seeing what you did, it's hard to know if that's what actually happened
00:09:30 <jle`> haskellhelp: maybe try a simpler example, like toBin (-7)
00:11:08 <haskellhelp> alrighty ill try -7
00:13:37 <sicklork1n> jle`: fwiw `<&>` and `&` have an infixl of 1; `$` is 0 and `<$>` is 4.. 
00:18:03 <haskellhelp> https://imgur.com/a/4fACA4c
00:18:26 <jle`> haskellhelp: ah, remember how guards work
00:18:33 <jle`> it goes down the path of the first match
00:18:56 <jle`> so toBin (-7) will match the n `mod` 2 == 1 case, not the last case
00:19:33 <jle`> toBin (-7) = toBin (-7 `div` 2) ++ [1]     -- matches on first case
00:19:45 <jle`>    = toBin (-3) ++ [1]
00:20:05 <jle`> now, what is toBin (-3) ?  when you find it, you can substitute it in there.
00:20:19 <jle`> toBin (-3) will also match on the first case, since -3 `mod` 2 == 1
00:20:30 <jle`> er, actually -3 `mod` 2 == -1
00:20:45 <jle`> oh sorry, it's == 1 :) my bad
00:20:47 <haskellhelp> ya im following you
00:20:49 <jle`> > (-3) `mod` 2
00:20:52 <lambdabot>  1
00:21:18 <jle`> ah, i even messed up in my evaluation, sorry :)
00:21:26 <jle`> > (-7) `div` 2
00:21:29 <lambdabot>  -4
00:21:41 <jle`> so toBin (-7) = toBin ((-7) `div` 2) ++ [1]
00:21:53 <jle`>      = toBin (-4) ++ [1]
00:22:21 <jle`> and toBin (-4) will match on the second case, so we get:
00:22:48 <jle`>   = (toBin ((-4) `div` 2) ++ [0]) ++ [1]
00:23:20 <jle`>  = toBin (-2) ++ [0,1]
00:23:26 <jle`> do you see where we already deviate from the work that you showed?
00:24:18 <haskellhelp> ahhhhh yes i see
00:24:36 <haskellhelp> f**k me hahah
00:24:49 <jle`> so at this point your issue isn't haskell anymore :) it's logic
00:25:50 <haskellhelp> right i understand now
00:29:46 <haskellhelp> how to i ammend this so that it works?
00:33:37 <jle`> walk through the logic of conversion to binary
00:33:43 <jle`> and then put that in code :)
00:34:04 <jle`> it's not a matter of amending a different logic to match your own logic
00:34:19 <jle`> that's like asking what you can fix about a bee to turn it into a truck ;)
00:34:48 <jle`> if you want to build a truck, don't ask how you can amend a bee into a truck. ask about how to build a truck.
00:35:05 <haskellhelp> when i input say the number 8 or something it works fine and gives the correct binary output. why does it not work for negatives? im looking at it and its just not working in my brain haha
00:35:21 <jle`> well, how would you do the logic in your head?
00:35:26 <jle`> if i asked you to convert -7, what would you do?
00:39:47 <haskellhelp> i would think about it and say, how many times does 1 go into it, how many times does 2, 4,8 etc until i get -0111
00:40:46 <jle`> how to bake a cake: think about it, until you have a cake :P
00:41:04 <jle`> does the method you describe...actually work?
00:42:38 <haskellhelp> im pretty sure it does, it gives me the correct binary
00:43:04 <jle`> show me how
00:43:22 <jle`> how many times does 1 go into -7?  -7 times
00:43:29 <jle`> how many times does 2 go into -7? ...-3 times, maybe?
00:43:47 <jle`> how many times does 4 go into -7?  -1 times?  8...zero?
00:43:52 <jle`> so the answer is [-7,-3,-1,8] ?
00:43:52 <haskellhelp> sorry im explaining my thinking poorly
00:44:04 <jle`> * [-7,-3,-1,8]
00:44:13 <jle`> * [-7, -3, -1, 0], sorry, heh
00:44:59 <haskellhelp> i really dont think i know how to explain m thinking
00:47:20 <jle`> haskellhelp: that's the problem :) if you don't know how to explain it to me, a human ... how much harder would it be to explain it to a computer?
00:47:43 <haskellhelp> maybe im taking the wrong course :P
00:47:49 <jle`> so, first work on trying to explain your thought process to *yourself*, even.  and then maybe figure out how you would teach a human to do the same thing
00:48:01 <jle`> and then, once you know how to explain it to a human, you'll know how to explain it to a computer
00:48:01 <MarcelineVQ> What course are you taking?
00:48:22 <haskellhelp> Programming as Problem Solving
00:48:40 <MarcelineVQ> Do they tell you what language to use for the course?
00:48:50 <haskellhelp> Yes, they have specified haskell
00:49:40 <nshepperd> the initial idea of turn -7 into 7 and handling positive 7 normally seems like a fine one to me
00:49:47 <MarcelineVQ> huh, geeze, that's really surprising :O
00:50:26 <MarcelineVQ> er, mostly because of the wording of the task
00:52:13 <MarcelineVQ> e.g. "You may assume all inputs in this question will be numbers." Is not something you should ever have to say for a haskell task that accepts 14 and 3.1 as inputs
00:53:46 <nshepperd> i feel like this assignment was copied and pasted from a Ruby tutorial or something
00:55:29 <haskellhelp> what are your gus backgrounds in haskell? do use it in daily work? just for reference
00:55:37 <MarcelineVQ> hobbyist here
00:55:52 <haskellhelp> never actually asked my teacher about his background in it
00:56:06 <MarcelineVQ> jle` uses it to control the weather and frighten animals
00:57:28 <nshepperd> haskellhelp: is https://pastebin.com/38QKGcy9 your latest code still?
00:57:30 <jle`> haskellhelp: but yeah, if you are confident in your positive number solution, you can just write a function that will find the binary rep of the absolute value, and then add '-' or not appropriately
00:57:58 <haskellhelp> nshepperd: yes it it
00:58:19 <nshepperd> haskellhelp: which branch does it choose when you call toBin (-7)?
00:58:49 <haskellhelp> the first i think
00:59:35 <nshepperd> haskellhelp: the n < 0 branch? good, so the result is '-' : toBin n
00:59:48 <nshepperd> haskellhelp: now what is n?
01:00:07 <haskellhelp> -7
01:00:22 <nshepperd> so the result is '-' : toBin (-7)
01:01:15 <nshepperd> haskellhelp: now which branch does the recursive call to toBin (-7) choose?
01:01:17 <jle`> one way to make things directly reusable is if you renamed your original toBin to be toBinFromPositive, and then you write toBin in terms of toBinFromPositive. but this would only work if you are confident that your toBin already works for positive numbers correctly
01:02:36 <haskellhelp> it gies down the second branch
01:03:03 <nshepperd> haskellhelp: nope!
01:03:23 <haskellhelp> no?
01:03:26 <nshepperd> functions don't remember what they did last time
01:03:55 <nshepperd> they always choose the first branch which matches
01:04:08 <nshepperd> more generally: they always do the same thing on the same input
01:06:00 <nshepperd> haskellhelp: so, in the recursive call, n is -7, right?
01:06:09 <haskellhelp> yes
01:06:19 <nshepperd> haskellhelp: and -7 is still < 0
01:06:30 <haskellhelp> yes
01:06:37 <nshepperd> so it chooses the first branch again
01:06:48 <haskellhelp> right i see what its doing
01:07:12 <nshepperd> you see the problem?
01:07:12 <haskellhelp> how do i stop this?
01:07:20 <haskellhelp> ya i see the problem
01:11:45 <nshepperd> your function works for positive numbers, so instead of calling 'toBin n' you could make n positive and call toBin with that instead
01:12:45 <nshepperd> ie. '-' : toBin (abs n)
01:14:10 <nshepperd> you should try evaluating this by hand with n = -7 to convince yourself that this does the right thing and doesn't get stuck in a loop
01:18:13 <nshepperd> to put that an another way: you don't want the recursive call to take the 'n < 0' branch again. so you need to call it with a number that isn't negative
01:18:37 <nshepperd> haskellhelp: i've gotta go to bed now but good luck!
01:19:17 * hackage streaming-brotli 0.0.0.0 - Streaming interface for Brotli (RFC7932) compression  https://hackage.haskell.org/package/streaming-brotli-0.0.0.0 (HerbertValerioRiedel)
01:19:53 <nighty> A quick question
01:20:17 * hackage streaming-lzma 0.0.0.0 - Streaming interface for LZMA/XZ compression  https://hackage.haskell.org/package/streaming-lzma-0.0.0.0 (HerbertValerioRiedel)
01:20:45 <nighty> I would like to know if you consider (beyond what is written on the haskell webpage) that haskell is sufficiently stable on ARMv7 and more importantly ARMv8 ? 
01:20:54 <nighty> On Linux 
01:21:46 <nighty> I mean Haskell/stack
01:22:36 <nighty> In other word would you use it a producion environement ?
01:26:38 <bahamas> anyone know the most up-to-date way of building an Electron app with Haskell?
01:58:39 <fen> can we have something like Either as a class?
01:59:01 <fen> it seems like its a pretty fundamental idea which could have many instances
01:59:52 <fen> probably there is a wider question also about this general idea that common datatypes could have classes for their instances instead of generics...
02:00:27 <fen> e.g. the same question obviously applies to (,) and (,,) e.t.c. and the Sum type versions
02:01:13 <fen> for example of a need for such a class, consider the Either datatype adorned with a phantom type
02:01:24 <geekosaur> the main problem with that is performance sucks. there at least used to be a container class package using common typeclass interfaces, which nobody used because it was so slow compared to containers
02:03:23 <fen> suppose we want to describe what is a "State", modelled on the simple examples; s -> Maybe (a,s), s -> (a,Maybe s)
02:04:14 <fen> Maybe (a,s) ~~~ Either (a,s) (), (a,Maybe s) ~~~ Either (a,s) a
02:05:37 <fen> then as we have the possibility for example of; s -> ((i,a),Maybe s) where ((i,a),s) ~~~ Either ((i,a),s) (i,a)
02:06:12 <fen> basically the description is "Either (a bifunctor in `a' and `s') or something else"
02:06:30 <fen> but then we would want this Either to be like Binfunctor, as a Class
02:07:00 <fen> you shouldnt have to actually *use* Either, it should just have that kind of functionality
02:07:18 <fen> just like you dont have to use (,) but can use Bifunctor to abstract over this
02:08:49 <fen> it just feels like there is some kind of feeling not to do something like this since whenever a generalisation of Either is considered, the Generics style constructors spring to mind and seem to demotivate Either as a typeclass, and similar 
02:09:53 <fen> wait, sorry, that (,) ~~~ Binfunctor is wrong, its more like Bifunctor + Biextract
02:12:41 <fen> to justify this attempt to "characterise what is a State" which motivates this Either class, its because nested States are States and the only way to have as yet unspecified States in a type level list of such describing the nested State, methods of a State class (synonym) must be used so that they work over all states
02:13:03 <fen> thats kind of complicated, but anyway, why dont we have an Either class?
02:14:51 <fen> and maybe if there is any comment also on if the use of such to also give a State class seems reasonable.
02:15:25 <nshepperd> Either is a datatype
02:15:42 <fen> *facepalm* 
02:15:43 <nshepperd> the idea of making a datatype into a class doesn't make much sense
02:16:15 <fen> yeah thats the real question - or one of them anyway
02:16:18 <fen> why so?
02:16:50 <fen> you can have many implementations of such... eg just adding a phantom type parameter 
02:17:32 <fen> thats this whole point about Generic representations vs typeclass versions of datatypes
02:18:50 <fen> like what if instead of Generics you just had template haskell generating typeclass versions of datatypes
02:19:15 <fen> the idea being that datatypes accessor functions (records) make good class functions
02:22:01 <akr> is there any resource on understanding how to use various transformers from mtl with instance classes?
02:22:08 <akr> or can anyone explain to me what the problem is here https://gist.github.com/osense/5c184e90b4af35ca153a6577d15c511a
02:22:39 <fen> and the thing with State having a kind of class representation is a slightly different thing, since drastically different datatypes can have the same kind of functionality - as opposed to something that was actually isomorphic to another datatype like the idea with Either
02:23:38 <fen> ark: is your indentation off?
02:23:49 <fen> like, is that supposed to be a class function?
02:24:30 <fen> ah, nvm, misread it
02:25:05 <akr> yeah, it's not supposed to be an instance function
02:25:32 <lyxia> akr: WriterT String IO Int -> IO (Int, String)
02:26:43 <nshepperd> typeclasses can't replace Generics, it's literally impossible
02:27:18 <fen> thats really difficult to understand
02:27:31 <lyxia> To use the "run" functions you need to make your monad concrete.
02:28:17 <nshepperd> Generic representations are decidable, typeclass instances are not
02:28:18 <lyxia> fen: now you know how people feel like reading your rants
02:28:46 <akr> lyxia: then why does this work? https://gist.github.com/osense/1a56531e75a06573986a10ba327e5442
02:28:52 <fen> are you saying its more clear the meaning with less explaining?
02:29:26 <fen> sometimes its not easy to understand how to describe something you dont understand... 
02:29:34 <lyxia> fen: you make no effort to explain anything
02:29:43 <fen> :-(
02:30:32 <learnerof> Hey Guys! How you doin? Anybody here who can help a Haskell #Newbie with his Code?
02:31:20 <akr> nshepperd: yeah it does need undecidable instances
02:31:42 <bahamas> learnerof: it's better to just ask your question
02:31:47 <learnerof> :D good one
02:31:54 <lyxia> fen: I still think you'd be better served by structuring your thoughts in a blogpost or a mailing list
02:32:04 <fen> isnt the idea of generics that one constructor would serve as that of any isomorphic datatype, and so in this way kind of deriving a "canonical" datatype? the idea is then that such a "canonical" datatype, which is isomorphic to many others, could then also be used to make a class with its constructors as typeclass functions, which the isomorphic versions could then instantiate 
02:32:32 <fen> lyxia: thats about as good as explain as can be, probably
02:32:33 <akr> generics are not really about isomorphism 
02:32:43 <fen> oh
02:33:08 <akr> it's about offering a common interface over some collection of datatypes
02:33:33 <akr> for example, both String and Int are instances of Show, but they're really not isomorphic
02:34:12 <fen> ah right, thats how the point about State vs Either - described as a typeclass - works, its not that it needs be isomorphic, just that it at least satisfies the properties described by the class functions
02:34:17 <lyxia> akr: here f is generic. in your previous post, f was not generic, it's withWriter that was generic
02:35:01 <learnerof> I get alltimes a - parse error on input `|' - my whitespace are correct, no tabs are used.
02:35:08 <fen> just as Either adorned with a phantom type isnt actually isomorphic to Either, though it does implement the same "interface"
02:35:16 <akr> lyxia: hmm I see
02:35:20 <akr> lyxia: thanks!
02:35:35 <lyxia> akr: So before, withWriter got an "f :: m Int", but it's the caller of "withWriter" who decides how to instantiate f
02:35:47 <akr> right
02:35:51 <lyxia> akr: and here it's the implementation of withWriter itself which decides.
02:35:57 <akr> so the best way around this is to use your first suggestion?
02:36:04 <akr> or is there some other workaround?
02:36:40 <Shockk> learnerof: are you able to post your code somewhere like https://gist.github.com/ ?
02:37:22 <learnerof> Its a Class-Task. I will PN you if it's okay
02:37:31 <akr> lyxia: I thought that this type signature of withWriter might fix it: `withWriter :: (MyMonad m => m Int) -> IO (Int, String)`
02:37:38 <akr> but that doesn't seem to do what I want
02:37:59 <akr> as in, m is still instantiated by whoever calls withWriter
02:38:12 <lyxia> akr: I think usually the code looks more like that last paste, you build a big polymorphic computation (MonadWriter Foo m, MonadBlah Bar m) => m Baz, and then at the end you "run" it to get IO (Foo, Bar, Baz)
02:38:24 <fen> but it would have to instantiate it *as* WriterT?
02:39:01 <lyxia> akr: you can try (forall m. MyMonad m => m Int) but that now excludes using any other class
02:40:15 <fen> are you after some kind of record accessor that would work with any MonadWriter? 
02:40:19 <lyxia> akr: runWriterT needs m to be exactly of the form WriterT _w _n so putting that down is what gives you the most general type.
02:40:46 <akr> ooh
02:40:48 <akr> yeah that works
02:40:51 <akr> awesome!
02:41:42 <akr> thanks a lot, lyxia :) learned something new and solved a problem in our codebase
02:42:28 <fen> that would sure save a lot of different names for equivalent record accessors...
02:44:13 <fen> lyxia: sorry, can see where the confusion was now, probably the version for the irc is just the question: do we have a class like Either? I need that for something im doing now
02:47:02 <fen> and I'm not comfortable using Generics... 
02:49:47 <fen> and if there *isnt* a class like Either, is there a reason for that? would it be a bad idea to make one for the current project?
02:50:42 <fen> the only reason to mention Generics really is to speculate about what this bad reason could possibly be, since I dont really understand why classes mimicking records are not more common
02:50:53 <lyxia> Bifunctor? I still have no idea what the problem is
02:51:36 <fen> its difficult to see why...
02:52:47 <fen> oh right, well anyway, (,) is also a Bifunctor, so thats not it.. it would just have left and right as class functions, exactly the same as the datatype declaration 
02:52:55 <fen> :t Left
02:52:56 <lambdabot> a -> Either a b
02:53:59 <fen> class Either_class f where left :: a -> f a b;right b -> f a b;
02:54:18 <fen> class Either_class f where left :: f a b -> a; right :: f a b -> b;
02:54:31 <fen> one of those, or maybe a combination of both...
02:55:11 <lyxia> You may be looking for a finally tagless encoding, there's a paper or two about that.
02:55:43 <lyxia> We don't have it because we're all happy using Either directly instead of encoding it.
02:58:52 <fen> hmm, but then you could apply the same logic the the [] datatype and you end up with something like the lens encoding
03:00:47 * hackage socks 0.6.0 - Socks proxy (ver 5)  https://hackage.haskell.org/package/socks-0.6.0 (VincentHanquez)
03:02:05 <fen> here is the "phantom type adorned version of Either" that this was meant for anyway; https://pastebin.com/raw/ynnAXxp5
03:17:14 <fen> since there are many possible "state" things, there should be a class to describe what propertys they have, and as they all have a kind of Either structure, because they either continue producing values or terminate, then the State class would be a synonym including the Either class, as that reflects this aspect of thier structure, having 2 cases..
03:27:47 * hackage connection 0.3.0 - Simple and easy network connections API  https://hackage.haskell.org/package/connection-0.3.0 (VincentHanquez)
04:59:31 <hpyCdr> how do I convert a Double to Bytestring / Double to [Word8] ? Since for binary IO it seems like I have to convert to Word8 ?
05:01:37 <Ariakenom> hpyCdr: https://hackage.haskell.org/package/binary-0.8.6.0/docs/Data-Binary-Put.html
05:02:46 <Ariakenom> % :t Data.Binary.Put.runPut . Data.Binary.Put.putDoublebe
05:02:46 <yahb> Ariakenom: Double -> BSL.ByteString
05:07:52 <hpyCdr> thanks
05:20:23 <www-isbuu-com> http://www.isbuu.com
05:21:55 <hpyCdr> ^ banhammer ?
06:18:20 <bolverkr> hello
06:28:29 <Ariakenom> bolverkr: hi
06:46:54 <fendor> where can I find the binaries of test-executables built by stack or cabal?
06:48:29 <fendor> nvm, found them
06:49:47 * hackage pandoc-pyplot 2.1.1.0 - A Pandoc filter to include figures generated from Python code blocks  https://hackage.haskell.org/package/pandoc-pyplot-2.1.1.0 (LaurentRDC)
06:50:08 <hoppfull> I'm trying to understand free monads. Is the point that one might for example create a small effectful function but use a free monad instead of IO to produce a pure testable datastructure?
06:50:53 <Solonarv> that's one possible use, indeed
06:51:30 <Solonarv> they're also useful if you want to have multiple "interpreters"
06:51:44 <hoppfull> So the monad becomes a parameter; if I use IO, it's the real deal, if I use my own made up thing, it's just a datastructure
06:52:08 <Solonarv> well, you don't actually need free monads for this - another often-used approach is typeclasses
06:52:15 <hoppfull> I've seen that but I don't undestand what we mean with "interpreters."
06:52:41 <Solonarv> an "interpreter" is some way of executing or otherwise "consuming" your computation
06:52:48 <hoppfull> ok cool
06:53:16 <hoppfull> Because they seem like they could be used to do automatic differentiation.
06:53:16 <Solonarv> for a datatype like: data Expr = Lit Int | Add Expr Expr, two interpreters might be "calculate the result" and "print out the expression"
06:53:32 <Solonarv> hmm... yes, AD seems sort of related
06:53:56 <hoppfull> Ok, interesting
06:54:32 <hoppfull> Ok, it's starting to make a little bit more sense now.
06:55:17 * hackage haskell-lsp-types 0.10.0.0 - Haskell library for the Microsoft Language Server Protocol, data types  https://hackage.haskell.org/package/haskell-lsp-types-0.10.0.0 (luke_)
06:56:17 * hackage haskell-lsp 0.10.0.0 - Haskell library for the Microsoft Language Server Protocol  https://hackage.haskell.org/package/haskell-lsp-0.10.0.0 (luke_)
06:56:22 <Cale> hoppfull: Note that there isn't much reason IO isn't just a sensible data structure also -- just that GHC benefits somewhat from doing something rather hacky instead.
06:57:26 <Cale> (It just uses effectful functions internally so that it doesn't need to reimplement all the optimisations it does specially for IO actions.)
06:58:04 <Athas> Cale: how else would it do it?
06:58:29 <Athas> You could use IO to hide the old-school continuation/stream approach, but doesn't that fall apart in the presence of concurrency?
06:58:52 <Cale> You could effectively just have it be a free monad
06:58:57 <Solonarv> it could just be a free(r) monad that gets interpreted by the runtime
06:59:05 <Solonarv> I think Hugs might do it that way? not sure
07:26:17 * hackage lsp-test 0.5.1.2 - Functional test framework for LSP servers.  https://hackage.haskell.org/package/lsp-test-0.5.1.2 (luke_)
07:57:36 <caissalover> I want to install tensorflow. I have installed protobuf, libtensorflow and snappy. How do I proceed further?
07:58:25 <caissalover> Wait, before that, are there any other libraries better than tensorflow for gpu based ML in haskell
08:02:41 <caissalover> By better, I mean in terms of speed, or even comparable.
08:57:47 * hackage lsp-test 0.5.1.3 - Functional test framework for LSP servers.  https://hackage.haskell.org/package/lsp-test-0.5.1.3 (luke_)
09:17:17 * hackage amqp 0.18.2 - Client library for AMQP servers (currently only RabbitMQ)  https://hackage.haskell.org/package/amqp-0.18.2 (HolgerReinhardt)
09:34:22 <realloc> hi, https://www.stackage.org/haddock/lts-13.18/base-4.12.0.0/Control-Exception.html#interruptible discourages the use of uninterruptableMask, however, I wonder if I have no other choice but to use it in my case:
09:36:23 <realloc> I have a function which connects to a server and other threads might send it an AsyncCancelled exception. However, before it shuts down, it should always dump the remaining contents of a buffer into the connection. However, I want to mask the code, which acquires the connection
09:37:36 <realloc> mask seems not to work, since establishing the connection seems to be interruptable. Using uninterruptableMask works.
09:38:10 <realloc> Do you think this a valid use case of uninterruptableMask? 
09:57:20 <jlamothe> Has anyone ever encoubtered an issue where using the standard durectional keys on NAO (hjkl...) cause the cursor to move multiple steps when selecting an object? I'm running Ubuntu 18.04, if it makes a difference.
09:57:59 <jlamothe> Sorry, wrong channel...
10:35:09 <gentauro> jlamothe: nice try. You wrongly post this in hope of some haskellers answering it :P
10:35:23 <gentauro> (just kidding)
10:42:17 * hackage cpkg 0.1.2.1 - Build tool for C  https://hackage.haskell.org/package/cpkg-0.1.2.1 (vmchale)
10:43:00 <isd> Hey all. I'm having a weird issue with cabal publish: https://pastebin.com/u1A6J7RB
10:43:36 <isd> Some bogus character in a source file according to the message -- but there's no Main.hs anywhere in the source tree or dist-newstyle/ etc.
10:43:59 <isd> Any guesses?
10:45:08 <isd> I'm actually getting this with any of my packages, not just one.
10:47:21 <sclv> isd: i dont' even know what cabal publish is?
10:47:26 <sclv> it must be in very recent cabal only?
10:47:39 <sclv> not in the docs, not in 2.4.1.0
10:47:49 <Solonarv> sclv: I have cabal-head and it's not there either
10:48:25 <sclv> oh i see its just sdist and they called it the wrong thing...
10:48:47 <sclv> wait, no its not
10:48:50 <sclv> its "publish"
10:48:53 <isd> sclv: no, publish is for uploading the package, sdist makes the souce tarball.
10:48:57 <sclv> isd: are you sure you don't mean "upload"
10:49:08 <isd> I might. But I get the same error.
10:49:32 <Solonarv> isd: try running with -vvv and post the error log then
10:49:50 <Solonarv> (there will probably be a lot of output)
10:50:05 <isd> Ah, v2-upload doesn't exist yet; just upload works
10:50:25 <Solonarv> indeed, I was wondering where you'd got that command from
10:50:39 <sclv> isd: i think you must have the version where v2-prefixed commands that don't exist execute with errors
10:50:55 <isd> 2.4.0.0
10:51:30 <isd> It's been a couple months since I've published a package; just mis-remembered I guess.
10:53:27 * Solonarv just uses the web interface to upload
10:53:47 * hackage vector-endian 0.1.0.0 - Storable vectors with cpu-independent representation.  https://hackage.haskell.org/package/vector-endian-0.1.0.0 (isd)
10:54:23 <isd> Huzzah.
11:04:52 <Forty-Bot> does Distribution.Simple have something like ccache?
11:05:20 <Forty-Bot> I am compiling the same package a bunch with slightly different configuration trying to fix a build bug
11:05:47 * hackage hledger-flow 0.11.2.0 - An hledger workflow focusing on automated statement import and classification.  https://hackage.haskell.org/package/hledger-flow-0.11.2.0 (apauley)
11:09:32 <tabaqui1> Is it true, that there exists at most once functor between two arbitrary categories? 
11:12:04 <jle`> i don't think so. consider the fact that many categories have several endofunctors
11:13:25 <tabaqui1> I've read somewhere that list has another monad instance, if you build it for free
11:13:39 <tabaqui1> But didn't check it by myself
11:14:01 <jle`> i don't know what that is meant to mean
11:14:09 <tabaqui1> Oh, wair a sec
11:14:10 <jle`> are you asking if a data type can have more than one unique monad instance?
11:14:17 <tabaqui1> jle, it is your blog :)
11:14:40 <tabaqui1> https://blog.jle.im/entry/const-applicative-and-monoids.html
11:14:58 <tabaqui1> Here you write that sentence 
11:15:00 <jle`> ah haha. it all comes around :)
11:15:13 <jle`> time for me to eat my words maybe
11:15:35 <jle`> hm, what sentence are you referring to?
11:15:59 <jle`> i don't think that article mentions monads at all
11:16:19 <tabaqui1> Ref2
11:16:22 <tabaqui1> Note that this is a meaningful starting point because fmap’s definition is fixed. For any type, there is at most one possible fmap that is legal and lawful — and in Haskell, we only have to check that fmap id leaves all inputs unchanged.2
11:16:49 <Solonarv> yes, this is a completely different claim than "there exists at most one functor between two arbitrary categories"
11:17:23 <c_wraith> That's not even "there exists at most one endofunctor in the category of Haskell types"
11:17:42 <c_wraith> It's "there's at most one instance of Functor"
11:17:55 <c_wraith> And even that needs a proviso or two.
11:18:02 <jle`> yeah, it's a specific claim about the Functor typeclass in Haskell, not about any sort of general property of category theory functors
11:18:05 <tabaqui1> Ok, the first cat is Hask
11:18:33 <Solonarv> the second cat is also Hask (which is not really a category, but we can squint a bit and pretend it is)
11:18:49 <jle`> if you prove something for a specific case, it doesn't mean it is true for the general case ;)
11:18:59 <jle`> for example: let's prove that the sum of any two numbers is always 7.
11:19:05 <jle`> proof: take 3 and 4.  their sum is 7
11:19:07 <c_wraith> There are at least two different valid ways to write a Functor instance for newtype Compose f g a = Compose (f (g a))
11:19:09 <jle`> therefore, the sum of any two numbers is 7
11:19:18 <tabaqui1> I know, but Hask doesn't look somewhat unique for me
11:19:25 <monochrom> This sounds more like "given a mapping from objects to objects (note that no one says this part is unique), there exists at most one mapping from morphisms to morphisms you can add to get a functor".
11:19:37 <c_wraith> Hask isn't the important part.  "instance of the Functor class" is the important part.
11:19:47 * hackage yesod-paginator 1.1.0.2 - A pagination approach for yesod  https://hackage.haskell.org/package/yesod-paginator-1.1.0.2 (PatrickBrisbin)
11:20:10 <monochrom> And even then probably you need to add an extra assumption about naturality or something.
11:20:32 <tabaqui> well, back to Compose
11:20:39 * Solonarv waves hands and mumbles something something parametricity
11:20:47 <monochrom> But my favourite is 2+2=2*2=2^2
11:20:57 <jle`> yeah, i don't think this property generalizes nicely in any way to a property about functors or categories in general
11:21:17 <tabaqui> ok, back to origin sentence from the blog
11:21:27 <tabaqui> c_wraith: does your example with Compose is still valid?
11:21:31 <c_wraith> Compose complicates things because you have to add constraints to f and g to be able to write a Functor instances.
11:21:39 <tabaqui> *is your...
11:21:52 <c_wraith> And it turns out that there are different constraints you can add to them to make that work.
11:22:11 <tabaqui> so we get different types?
11:22:18 <Solonarv> the two instances are:
11:22:18 <Solonarv> instance (Functor f, Functor g) => Functor (Compose f g) where
11:22:18 <Solonarv>   fmap f (Compose fg) = Compose ((fmap . fmap) f fg)
11:22:18 <Solonarv> instance (Contravariant f, Contravariant g) => Functor (Compose f g) where
11:22:19 <Solonarv>   fmap f (Compose fg) = Compose ((contramap . contramap) f fg)
11:23:00 <monochrom> Fortunately "Functor f" and "Contravariant f" are disjoint. :)
11:23:00 <jle`> yeah. but to link that to the original point, there is only one instance for a composition of two specific functors
11:23:08 <tabaqui> doesn't Functor f instance define just usual functor from Hask to f?
11:23:12 <c_wraith> monochrom: no, but they are identical when they overlap
11:23:32 <tabaqui> I know that Monads in Haskell differ from monads from math
11:23:34 <Solonarv> tabaqui: no, 'f' isn't even a category
11:23:42 <tabaqui> oh
11:23:45 <tabaqui> so it is endofunctor?
11:23:50 <jle`> tabaqui: Functor in haskell is an endofunctor, yes
11:23:58 <jle`> it's supposed to represent Hask ~> Hask
11:24:11 <c_wraith> monochrom: (they overlap only when the type variable is phantom)
11:24:12 <monochrom> Oh!  I guess I forgot Identity. :)
11:24:15 <jle`> for example, the Functor Maybe maps the type `Int` to `Maybe Int`
11:24:17 <tabaqui> so there exists at most once endofunctor with given image?
11:24:30 <jle`> monochrom: identity is not contravariant
11:24:32 <c_wraith> monochrom: nah, Identity isn't Contravariant
11:24:35 <Solonarv> when you write 'instance Functor F where fmap = ...', F is the mapping for objects and fmap s the mapping for morphisms
11:24:37 <monochrom> OK nevermind.
11:24:38 <isd> f is the object part of the mapping, fmap is the morphism part.
11:24:42 <c_wraith> monochrom: Const is both
11:24:54 <Solonarv> monochrom: Const k, Proxy, similar silliness
11:25:08 <tabaqui> ok, is it ture that there exists at most once endofunctor with given image?
11:25:11 <tabaqui> *true
11:25:14 <jle`> tabaqui: hm, i'm not sure you can say that there is at most one endofunctor with a given image
11:25:28 <jle`> tabaqui: but what the statement is saying is that if you fix the object mapping part, then you fix the morphism mapping part
11:25:32 <monochrom> Ironically phatom types are my favourite counterexamples in monads.
11:25:54 <jle`> at least, if you fix the object mapping part to a very specific form
11:26:05 <tabaqui> jle`: image is a set of outputs
11:26:05 <jle`> if your 'object mapping function' is, given type 'a', return 'F a'
11:26:13 <monochrom> For example whenever people analogize "monad is a container" I whip out Proxy.
11:26:16 <Solonarv> monochrom: phantom type parameters are surprisingly useful!
11:26:28 <tabaqui> so we have some (* -> *) type constructor that defines outputs
11:26:31 <jle`> tabaqui: right, i don't think it's even true for "all" endofunctors in Hask
11:26:41 <jle`> just the ones that are defined by a type constructor in that way
11:26:51 <glguy> tabaqui: It doesn't have to be a type constructor, any type with kind * -> * will do
11:26:53 <jle`> but there are other endofunctors that don't have to do with any type constructors
11:27:09 <jle`> ah yeah, any * -> * generated by a some application of a type constructor
11:27:15 <monochrom> To be fair, phantom types annoyed Moggi so much, he added a condition "no no no, return must be injective!" to rule them out.
11:27:20 <tabaqui> right, not type constructor, just * -> * kind
11:27:25 <c_wraith> Look at the pipes library.  The basic Pipe type is explicitly a functor in 5 different categories
11:27:29 <Solonarv> pah - boooring
11:27:36 <jle`> it has to be an injective and generative * -> * kind
11:28:01 <Solonarv> "generative" = "hits everything" ?
11:28:17 <monochrom> Actually I am not sure what Moggi really wanted to rule out, but he definitely added a condition that requires injectivity (plus other things).
11:28:19 <tabaqui> ok, I understand now
11:28:24 <tabaqui> thank you all guys
11:28:43 <jle`> f a = g b implies f = g and a = b
11:28:58 <Solonarv> oh, I see
11:28:59 <jle`> if f and g are...generative? not sure about the exact word atm
11:29:15 <tabaqui> special thanks to jle` for his really weird and intriguing point of view on Free Alternative
11:29:18 <Solonarv> I think "generative" only gives you half of that soehow
11:29:40 <jle`> i was just making that clarification to rule out psuedo * -> *'s that come from type synonyms
11:29:54 <jle`> tabaqui: heh, glad you appreciate :P
11:29:58 <Solonarv> 'f a ~ g b => (f ~ g, a ~ b)' is called "matchability" in richard eisenberg's thesis
11:30:09 * tabaqui is out
11:30:11 <Solonarv> and I think that concept is actually in a soon-to-be-merged GHC branch
11:31:00 <Solonarv> (and indeed, distinguishing type synonyms/families from (partially applied) type constructors is what it does in practice)
11:31:46 <monochrom> I propose "unifiable", "unification-friendly", "unificative". >:)
11:32:07 <monochrom> Because that's exactly what unification assumes.
11:32:25 <jle`> right, it's always been weird to me that * -> (* -> *) is a 'lie' in some situations
11:32:37 <Solonarv> monochrom: too late! :P
11:33:05 <Solonarv> yeah, soon we'll actually have two different sorts (kinds? variants?) of -> to distinguish this
11:33:07 <jle`> type FlipTup a b = (b, a)
11:33:14 <jle`> FlipTup :: * -> * -> *
11:33:23 <jle`> FlipTup :: * -> (* -> *)
11:33:29 <jle`> FlipTup Int Bool :: *
11:33:33 <jle`> FlipTup Int :: undefined ???
11:33:41 <monochrom> I kind of don't mind "matchable" because unification is just glorified matching.
11:34:07 <monochrom> In some circles "matching" is defined to be unification, even.
11:34:08 <S6420> b
11:34:23 <Solonarv> indeed, and it also applies just as well to the distinction between data constructors and plain old functions
11:34:33 <jle`> 🅱
11:34:35 <Solonarv> very elegant!
11:35:12 <c_wraith> hmm.  kind of unifying what's happening at the type level vs at the value level?  I can see how that's relevant.  (pun intended)
11:35:51 <Solonarv> hah!
11:36:08 <monochrom> heh
11:36:21 <Solonarv> hih
11:36:29 <c_wraith> huh?
11:36:39 <monochrom> hoh
11:36:55 <Solonarv> almost :D
11:37:27 <monochrom> hyuoieah  I win.
11:39:25 <agander> hrumpf
12:02:19 <horatiohb> Any opinions about the current state of web servers/frameworks? Is happstack(-server) moribund? Is snap?
12:14:18 <shapr> horatiohb: I'm a fan of scotty
12:14:27 <shapr> but that's a small/thin framework
12:15:50 <horatiohb> shapr: thank you, I saw scotty, and it looks nice. But I'm particularly interested to know whether happstack and snap are somehow on their way out. (Sorry I didn't make that clear enough in my question.)
12:16:19 <shapr> oh, I don't know
12:16:35 <shapr> didn't mightybyte create snap?
12:16:41 <horatiohb> yes
12:16:58 <shapr> I talked to mightybyte at this past ICFP and they said they haven't been especially active with snap
12:17:39 <horatiohb> that's useful to know, thanks.
12:18:19 <shapr> I hear lots of people using servant and yesod
12:18:25 <shapr> and all of obsidian's cool libraries
12:18:30 <shapr> I hear Cale worked on that
12:19:49 <Cale> I've worked on many of Obsidian's libraries
12:20:17 <Cale> (servant and yesod aren't ours though, just to be clear)
12:21:12 <shapr> horatiohb: are you looking to build something specific?
12:22:48 <horatiohb> shapr: yes, a fully fledged webapp, and I really like happstack so far...but I'm hesitating to commit to it, because I'm wondering if it's age means that it's on its way out.
12:23:04 <horatiohb> it's age -> its age
12:23:06 <Cale> Have a look at Obelisk
12:24:54 <shapr> horatiohb: google search haskell happstack and limit your results to the past year?
12:25:05 <shapr> that's how I'd check up on the popular activity of a framework
12:25:21 <shapr> or I'd join the forum and get a feel for activity that way?
12:25:27 <shapr> (I don't know if happstack has a forum)
12:25:30 <horatiohb> will try, thanks...
12:25:52 <__monty__> horatiohb: Sometimes age/inactivity just means stability. So if it serves your needs, why not enjoy not having to chase an API : )
12:26:39 <horatiohb> __monty__: point well taken, thx..
12:26:46 <horatiohb> that's what I've been thinking
12:31:58 <shapr> horatiohb: are you building something nifty?
12:33:13 <horatiohb> of course...everything I do counts as nifty...
12:33:18 <horatiohb> ;-)
12:57:47 * hackage extra 1.6.15 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.6.15 (NeilMitchell)
13:18:40 <TBG> @pl (\n->n*(n-1))
13:18:41 <lambdabot> ap (*) (subtract 1)
13:18:43 <TBG> Nah
14:44:04 <clamothe> Say you have three side-effect IO functions. The first returns a list of values. Using that list, I want to call the second function passing the entire list, and the third function for each item in the list.
14:45:53 <clamothe> This doesn't fit in one sequential binding really. The result of the first feeds into the second and third, but the second and third are in parallel
14:47:05 <boj> :t bimap
14:47:06 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
14:48:00 <clamothe> @boj Is that in response to my message ?
14:48:00 <lambdabot> Maybe you meant: yow do bug bid bf
14:48:33 <devalot> I'm starting a new project and trying to decide if I should use the mtl or fused-effects.  Reverse depends for fused-effects doesn't show anything else using it yet.  I'm curious if anyone has any feedback on it.
14:48:34 <boj> clamothe: yes, although i was curious if it was relevant myself
14:49:18 <clamothe> Interesting, this might apply
14:49:44 <xldenis> devalot: depends, are you just trying to learn new tools / techniques or are you trying to get the project done above all?
14:52:57 <MarcelineVQ> devalot: consider polysemy over fused-effects if you go that route https://github.com/isovector/polysemy#readme
14:53:38 <devalot> xldenis: Getting the project done is pretty important.  But I'd like to use an effect system that lets me break IO into smaller effects and it seems like that's easier to do with something like fused-effects.
14:54:24 <devalot> MarcelineVQ: polysemy looks interesting.  But it looks like the only thing it has over fused-effects is less boilerplate thanks to TH.
14:56:02 <xldenis> wouldn't we all ;) , imo if you want to get a project done asap using the simplest / most established tools is best. however effect systems are fun to play with too
14:58:18 <devalot> xldenis: Do you think something other than mtl slows the project down because a learning curve or because of having to create some of the effects by hand, or what?
14:59:01 <xldenis> a bit of both plus you'll probs get angrier messages from the compiler 
15:00:09 <EvanR> clamothe: while IO >>= doesn't exactly fit, IO does support doing two things in parallel
15:01:51 <devalot> xldenis: There's definitely a tension between getting the project done, and getting it done right.  I'd like to be able to guarantee that certain parts of the app can't do certain things (i.e. write to the database).  That would make me happy.
15:02:53 <EvanR> devalot: if all db operations required a connection... and that part of the app was never given one... should do it
15:03:12 <EvanR> someone would have to go out of their way to connect to the database
15:03:43 <xldenis> devalot: mtl can do that fairly easily by creating a MonadDB class etc...
15:03:47 <devalot> EvanR: Of course.  I was just using that as an example of restricting IO.
15:04:27 <EvanR>  yeah i see, the idea of "can do any IO at all except for this one thing"
15:04:44 <EvanR> has a nice ring to it in management meetings :)
15:04:51 <devalot> xldenis: That's what I've done before, and I'm leaning to do again.  Just wanted some feedback on whether this sort of thing is better done in a more modern way.
15:05:01 <xldenis> ofc do what you want but personally if actually want the project to be finished / usable I'd go w mtl 
15:05:43 <devalot> These are all good things to hear, and I appreciate everyone's opinions.
15:05:50 <xldenis> devalot: yea i figured :)  if you do go w fused-effects and the project is oss i'd be interested in seeing how it goes
15:07:51 <devalot> It will be/is OSS: https://code.devalot.com/incubator/sthenauth
15:09:16 <devalot> It's a security product which is why I like being able to think about the capabilities of various code paths.
15:10:01 <EvanR> ah the exact opposite, the code can't do anything EXCEPT what i allow
15:10:17 <devalot> EvanR: Correct.
15:11:20 <EvanR> thats an area where dependent type experimental languages have an edge i think, for one reason or another
15:11:32 <EvanR> because they are so restricted by default
15:11:45 <devalot> I can definitely agree with that.
15:12:19 <cheers> come to #idris :)
15:12:25 <devalot> :)
15:12:44 <EvanR> the slow path floating point exploits cant hope to work... because you dont even have addition :)
15:12:54 <MarcelineVQ> It's a difference kind of restriction, dependent languages naturally enable statically enfored finite state transitions. things like session types and indexed monads, which happen to work well with effects
15:13:02 <devalot> I worry about long-term language stability with things like Idris.
15:13:18 <cheers> well, there's a dependent types proposal for haskell iirc
15:13:42 <MarcelineVQ> however on the subject of security aps: https://arxiv.org/pdf/1902.06590.pdf
15:13:54 <xldenis> just write and prove your software in coq and then extract it to haskell :upside_down_face: 
15:14:15 <devalot> xldenis: So much for "just get it done"!
15:14:23 <EvanR> ah the weasel "just"
15:14:34 <MarcelineVQ> synthesis (rather than just extraction) from coq is pretty interesting, johnw could show you a thing or two
15:14:52 <MarcelineVQ> https://www.cs.purdue.edu/homes/bendy/Fiat/FiatByteString.pdf
15:14:54 <devalot> MarcelineVQ: Thanks for the link
15:15:56 <xldenis> marcelinevq: doesn't that still use coq's extraction to produce the haskell code?
15:17:02 <MarcelineVQ> with some help http://plv.csail.mit.edu/fiat/
15:20:50 <MarcelineVQ> EvanR: combining the two, effects and type-checked state transition, gets you things like ST http://docs.idris-lang.org/en/latest/st/index.html
15:31:02 <devalot> MarcelineVQ: Why do you prefer polysemy?
15:53:16 <MarcelineVQ> devalot: I don't prefer it because I haven't used it :> but I suggested it for the reasons the readme lists
15:53:27 <devalot> MarcelineVQ: I have to step away but I'm interested in what you have to say.  I'm sorry if I seemed dismissive when you recommended polysemy.
15:54:01 <MarcelineVQ> nah I didn't get that impression I was just away too
16:14:47 * hackage front 0.0.0.2 - A reactive frontend web framework  https://hackage.haskell.org/package/front-0.0.0.2 (swamp_agr)
19:11:17 * hackage minilight 0.2.0 - A SDL2-based graphics library, batteries-included.  https://hackage.haskell.org/package/minilight-0.2.0 (myuon)
20:31:42 <johnw> xldenis: it's not only extraction, but an effort to minimize the "surface area" that is extracted, by refining down to a set of effects over a Free monad. We're also working on refined to an algebraic term that would get interpreted on the Haskell size, so that Coq can guarantee that what it "hands over the wall" is fully correct. We'll never know the full operational semantics of the Haskell runtime, so we can't say very much about how
20:31:44 <johnw> such a Haskell interpreter will behave anyway.
20:52:19 <Lycurgus> the speech center is so strong it broke "side" into "size" even though no vocalization took place
21:11:11 <Xunie> That's weird. Haskell Platform for Windows didn't come with Cabal in the bin folder. Did I use the wrong installer?
21:14:40 <Guest43> https://pastebin.com/m37q0Xa8
21:19:54 <sclv> Xunie: which bin folder? it might not have shown up in the one you expected
21:20:13 <sclv> it should def be put on your path
21:20:23 <sclv> but it won't go in to /Haskell/bin
21:20:35 <sclv> that folder is just for the binaries that cabal-install itself installs
21:20:37 <Xunie> sclv, yeah. it's under ./lib/extralibs/bin/
21:20:39 <Xunie> My bad
21:20:52 <Xunie> I was just looking in under ./bin
21:21:15 <Xunie> Is there some "set my paths" shell script that's provided?
21:22:29 <sclv> its just sort of just baked into the installer
21:22:50 <sclv> if you used the right installer?
21:23:15 <Xunie> Yeah. Those paths are set inside of cmd but they're not in MSYS2
21:24:01 <sclv> weird -- i thought msys would pick up system paths
21:24:04 <sclv> guess not
21:24:18 <Xunie> Perhaps it does but I just didn't reboot yet?
21:24:27 <sclv> if you just open a new terminal
21:24:34 <sclv> or run a new bash within an existing one, it may well work
21:24:43 <Xunie> nope
21:24:53 <sclv> well, learn something new every day
21:25:32 <Xunie> Just tried restarting explorer.exe using taskman but that didn't help either. *shrugs*
21:25:41 <Xunie> Well, I know where it is and how to call it
21:25:47 <Xunie> (from CMD) so I'll just do that
21:47:26 <rprije> acid-state users: Aside from when the [Query]s are needed for [Update]s, is there any good reason to construct rich [Query]s for specific DB lookups over just having simple [Query]s returning more or less the whole database then performing your more specific lookups in pure haskell?
22:08:47 * hackage graphql-w-persistent 0.3.1.2 - Haskell GraphQL query parser-interpreter-data processor.  https://hackage.haskell.org/package/graphql-w-persistent-0.3.1.2 (jasonsychau)
23:11:47 * hackage zip-archive 0.4.1 - Library for creating and modifying zip archives.  https://hackage.haskell.org/package/zip-archive-0.4.1 (JohnMacFarlane)
23:13:26 <dminuoso> What is the point of adding that second type argument to: data FunList a b t = Done t | More a (FunList a b (b -> t))
23:14:17 <dminuoso> As opposed to say: data FunList a b = Done b | More a (FunList a (a -> b))
23:15:10 <geekosaur> seems like a might be a phantom used to distinguish lists which use the same b but need to be distinct at type level?
23:16:34 <dminuoso> % :t traverse
23:16:35 <yahb> dminuoso: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
23:16:49 <dminuoso> geekosaur: Mmm, I think it has something to do with the traverse function being allowed to change the inner type.
23:17:17 * hackage salak-yaml 0.2.9.2 - Configuration Loader for yaml  https://hackage.haskell.org/package/salak-yaml-0.2.9.2 (leptonyu)
23:17:48 <geekosaur> admittedly I don't have context here, I see something that looks stream-ish
23:18:17 * hackage salak-toml 0.2.9.2 - Configuration Loader for toml  https://hackage.haskell.org/package/salak-toml-0.2.9.2 (leptonyu)
23:18:18 <geekosaur> but "allowed to change the type" makes me think there would need to be an inner forall, since there's no way to represent a changed type in a More
23:18:32 <dminuoso> runFun :: Applicative f => (a -> f b) -> FunList a b t -> f t
23:18:34 <dminuoso> In this sense
23:19:17 * hackage salak 0.2.9.2 - Configuration Loader  https://hackage.haskell.org/package/salak-0.2.9.2 (leptonyu)
23:19:26 <geekosaur> that looks like the answer, then. you're passing an Applicative, which can change the type
23:20:41 <geekosaur> unless you meant why separate t as opposed to why separate a, in which case yes, that's because Traversible can produce a third type
23:21:06 <geekosaur> and it has to know both the Applicative and the Traversable involved
23:22:09 <geekosaur> right, I misread that type signature, you were asking why the t
23:22:15 <geekosaur> so yes, it's the Traversable
23:23:24 <dminuoso> geekosaur: well the second argument `b` actually
23:24:57 <geekosaur> that one is because of the Applicative, which is the first parameter. it's not exposing Traversable here but I'd suspect t is what the type of traverse calls (t b)
23:25:37 <geekosaur> compare fmap
23:26:03 <geekosaur> (maybe one can ask why Applicative instead of Functor?)
23:26:39 <geekosaur> but (Applicative f => a -> f b) looks like the parameter to fmap, with a stronger constraint
23:34:58 <lrb> I'm *very* new to haskell and, frankly, I'm not a very good programmer to begin with. I'm struggling with something that is probably really stupid, tbh. I 100% do not understand why "floor(1 + floor(1+1))" is not working. I've distilled the larger calculation down to that, and I'm getting some stuff about ambiguity when I compile it. Will one of you help me with this?
23:35:20 <Rembane> lrb: Sure. What error do you get? 
23:35:43 <Rembane> lrb: Can you put the error in a gist and paste the link here?
23:36:19 <lrb> https://paste.ee/p/YX1o3
23:36:49 <lrb> Sorry, I figured it would be something really dumb so I didn't grab it to begin with.
23:38:00 <geekosaur> there's not enough there to tell
23:38:20 <lrb> What do you mean? That's literally all there is. 
23:38:21 <geekosaur> if "i" has been inferred as an Integral type by other usage, you'd get a type error
23:39:07 <geekosaur> if this is in ghci, "i" probably got inferred as Integer. try ":t i"
23:40:13 <geekosaur> and in fact when I do that in ghci with "i = 1", it infers (Integral a => a), which isn't compatible with floor
23:40:23 <geekosaur> Haskell does nto do automatic "casting" like some other languages
23:40:54 <geekosaur> numeric literals are polymorphic, but once something has been determined to be e.g. Integer, it will not be "promoted" to Double for you
23:41:23 <lrb> Ah, I think that's my problem. So I need to specify my types?
23:41:32 <lrb> If I want to use floor, that is
23:41:42 <geekosaur> or convert, yes
23:41:57 <geekosaur> floor (1 + floor (1 + fromIntegral i))
23:42:38 <geekosaur> or specify originally: i = 1 :: Double -- or whatever
23:43:22 <geekosaur> ogh, wait
23:43:24 <geekosaur> :t floor
23:43:25 <lambdabot> (Integral b, RealFrac a) => a -> b
23:43:45 <geekosaur> right, the result of floor is an Integral type, so you can't feed it directly
23:44:15 <geekosaur> floor (1 + fromIntegral (floor (1 + i)))
23:44:18 <lrb> So I'd need to convert the result using fromIntegral
23:44:30 <geekosaur> I'd been wondering why it'd be inferring Integral instead of Num for the binding
23:45:09 <geekosaur> right, i's being inferred as Num a => a, it's the inner floor that forces an Integral constraint
23:45:13 <geekosaur> derp
23:46:31 <lrb> This language is awesome but it really makes me think differently than other languages. I guess this facility is there to help ensure that there isn't any changes to values without explicit intent. Does that sound right?
23:46:47 <lrb> aren't*
23:47:35 <geekosaur> this aspect is just strong typing, so you don't have things changing types (consider e.g. Python or Ruby tossing an unexpected nil at you, which will cause a runtime error as a number)
23:47:53 <geekosaur> we prefer to catch such errors when building the program, not in the middle of it running
23:48:13 <nisstyre> lrb: it's no different than how float is not the same as int in Python
23:48:21 <nisstyre> whereas in Javascript there is no difference (weak typing)
23:51:42 <lrb> You're all awesome :) Thanks for your help. I might be coming back if I run into something else. I'm trying to work through a No Starch Press haskell book while I'm working on this.
