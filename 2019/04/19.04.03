00:08:07 * hackage registry 0.1.3.2 - data structure for assembling components  https://hackage.haskell.org/package/registry-0.1.3.2 (etorreborre)
00:12:16 <ruffy_> Can anybody explain me this type signature from Control.Arrow : (***) :: a b c -> a b' c' -> a (b, b') (c, c')?
00:12:36 <c_wraith> :t (***)
00:12:37 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
00:12:42 <c_wraith> You left part of it out
00:12:53 <c_wraith> Probably because you were reading from the class definition
00:13:18 <ruffy_> ohhh 
00:14:32 <ruffy_> Now it makes more sense, thx
00:14:59 <c_wraith> Basically, it lets you combine two arrows to get a product of the two, in some sense
00:29:29 <dminuoso> ruffy_: It might help to think of the `a` being in fix position: Array a => b `a` c -> b' `a` c' -> (b, b') `a` (c, c')
00:30:40 <ruffy_> Thx dminuoso
00:31:56 <Cale> It used to be that we could write (Arrow (~>)) => (b ~> c) -> (b' ~> c') -> ((b,b') ~> (c,c'))
00:32:07 <Cale> But infix type variables are no more
00:34:34 <juhp> Fwiw I tried `cabal new-install` in a clean system and it created symlink correctly
00:35:03 <dminuoso> Cale: Oh really? When were they abolished and why?
00:39:24 <Rembane> ruffy_: The diagrams on this page helped me understand arrows: https://en.wikibooks.org/wiki/Haskell/Understanding_arrows#An_Arrow_can_multitask
00:40:09 <ruffy_> Cale thx
00:40:20 <ruffy_> Rembane: I will have a look at it, thank you :)
00:40:53 <Rembane> ruffy_: No worries. Good luck! :)
00:42:58 <Cale> dminuoso: Not sure exactly. Basically, to make more room for type operators.
00:47:16 <dminuoso> Cale: I guess it makes sense, since the type operator and the quantification could appear in different libraries - so if you allowed this, then packages might become incompatible.
00:48:02 <dminuoso> Or perhaps its just a parser issue?
00:49:55 <Cale> Well, it's a parser issue having to deal with which things are variables and which are type constructors
00:54:50 <Cale> It might've been GHC 6.8 which changed that
01:28:17 <im0nde> Hi, I'm trying to replicate this curl request with haskells http-client (or any other http package), but I can't figure out how to set the POST parameters.
01:28:20 <im0nde> curl -XPOST -d '{"type":"m.login.password", "user":"example", "password":"wordpass"}' "https://localhost:8448/_matrix/client/r0/login"
01:29:07 <im0nde> I read the documentation but can't get it working (haskell newbie), what is the simplest HTTP-client I can use with haskell to make POST and GET requests?
01:30:37 * hackage chessIO 0.2.0.0 - Basic chess move generation and UCI client library  https://hackage.haskell.org/package/chessIO-0.2.0.0 (mlang)
01:30:43 <Ariakenom> im0nde: what about this https://haskell.fpcomplete.com/library/http-client ?
01:35:04 <Ariakenom> and these docs https://www.stackage.org/haddock/lts-13.15/http-conduit-2.3.6.1/Network-HTTP-Simple.html#g:1
01:38:36 <im0nde> Ariakenom: Thanks I'll try to figure it out and report back later
01:42:47 <bahamas> specifying the range of base verions in the cabal file is an indirect way of saying which ghc versions the project supports, right?
01:42:56 <bahamas> *base versions
01:44:32 <fendor_> bahamas, very indirect. In principle, any library version could support any ghc version. Except when the library is ghc version dependent. 
01:47:39 <bahamas> fendor_: yes. that's why I'm asking. I have a clash between the versions of base specified in my cabal file and the versions in one of my dependencies
01:48:02 <bahamas> I assume the solution is to just increasing my ranges to include those supported by my dependency
01:48:28 <fendor_> or bump the version range of your dependency
01:48:53 <bahamas> fendor_: how?
01:49:10 <bahamas> it's not a dependency I have control over. in this particular case, it's the rio library
01:50:09 <fendor_> bahamas, you could fork it, or at least open an issue? 
01:50:25 <fendor_> but yeah, quickfix, if applicable, is to widen your version range
01:50:50 <fendor_> or to use stack
01:50:56 <fendor_> that should work, too
01:51:52 <bahamas> fendor_: yes, using stack works. that's what package sets are for? to remove the need to care about base versions?
01:52:14 <fendor_> bahamas, yeah, as I have understood it
01:53:42 <bahamas> I see
01:54:53 <fendor_> pro: is easier to use, con: you have older libraries. potentially way older
01:56:38 <bahamas> fendor_: yeah, I stumbled into plenty of issues while trying to use stack. that's why I've come to prefer cabal with the new-* commands
01:56:50 <fendor_> bahamas, same.
01:57:22 <fendor_> you lose almost every advantage of stack the moment you do not use the latest ghc.
01:57:32 <bahamas> btw, do you or anyone understand these cabal messages: https://bpaste.net/show/c08e5d237044
01:58:21 <bahamas> it's not the whole thing, but I'm confused on why "base" shows up in there. it's not a part of my cabal file. I'm using base-noprelude, like it says on the last line, because I'm using rio
02:00:31 <fendor_> sorry :/ there are some commands to draw the dependecy graph, that helps
02:00:44 <bahamas> ok, the problem was that I was actually using ghc 8.6.2 instead of 8.4.3
02:01:45 <bahamas> I think the error message could be better. it could say there's a mismatch between the versions of base in your cabal file and the ghc version that you're running
02:02:20 <fendor_> i agree, I cant read the error message of cabal
02:03:16 <juhp> juhp: okay, cabal-install-2.4.1.0 looks good to me (symlink-binary installs)
02:04:28 <bahamas> juhp: that's what I'm using as well
03:21:24 <tinyBob> @djinn a->(a->b)->(a->b->c)
03:21:24 <lambdabot> -- f cannot be realized.
03:22:00 <tinyBob> @djinn (a->b->c)->a->(b->c)
03:22:00 <lambdabot> f a = a
03:22:47 <tinyBob> quit
03:52:37 * hackage hw-json-simd 0.1.0.2 - SIMD-based JSON semi-indexer  https://hackage.haskell.org/package/hw-json-simd-0.1.0.2 (haskellworks)
04:03:34 <mpickering> I am using dhall and have a sum type with 5 nullary constructors, after deriving `Interpret` how can I make a value dhall accepts? 
04:03:41 <mpickering> I can't find the bit of the documentation which talks about this
04:07:46 <phadej> mpickering: I think you get something like
04:07:46 <phadej> % echo 'let Foo= < Foo1 : {} | Foo2 : {} > in Foo.Foo1 {=}' | dhall
04:07:46 <phadej> < Foo1 = {=} | Foo2 : {} >
04:07:46 <yahb> phadej: ; <interactive>:482:7: error: parse error on input `let'
04:08:24 <__monty__> phadej: I think mpickering wants to turn a haskell value into a dhall value.
04:08:25 <mpickering> So I should refer to it as "Foo.Bar {=}"
04:08:33 <mpickering> No I want to write it in a .dhall file
04:08:39 <__monty__> Oh.
04:09:06 <phadej> mpickering: I'd try that, cannot say for sure; IIRC that's how sums are encoded
04:09:09 <mpickering> Unbound variable: CradleConfig
04:09:14 <mpickering> Which is the type constructor
04:09:22 <phadej> mpickering: that one you have to define yourself
04:09:53 <mpickering> So every user has to define this type themselves? or I have to wrap every config file before interpreting it?
04:09:53 <phadej> you could write < Foo1 = {=} | Foo2 : {} | Foo3 : {} > directly  too
04:10:07 <mpickering> I derived all this stuff with the `Interpret` default implementation
04:10:13 <mpickering> so I expected it to happen for me
04:10:32 <phadej> mpickering: yes, interpret only interprets; but you'll need to provide dhall library (to be import'ed)
04:10:33 <__monty__> Interpret's about reading dhall afaik.
04:12:59 <mpickering> hmm seems a bit useless then
04:13:25 <__monty__> Why? It's how you get dhall values into haskell.
04:14:13 <phadej> mpickering: I think you can dump the interpret values so you can make the library part in somewhat automated way
04:14:18 <phadej> but I don't know for sure how
04:15:32 <mpickering> __monty__: I don't understand what you're saying. If I define `data T = A | B` and `instance Interpret T` then I shouldn't have to define the dhall representation of `T`, that should be derived as well
04:15:54 <mpickering> So a user can just write `A` or `T.A` in their script and it's interpreted in the correct context
04:15:57 <mpickering> surely!
04:16:11 <phadej> mpickering: I think you can populate interpretter with globals too in _your_ interpreter
04:16:23 <phadej> but in general, `dhall` executable doesn't know about your `data T`
04:16:33 <mpickering> right but I am using the `interpret` function
04:16:50 <__monty__> mpickering: The exact syntax that is interpreted as value of your type T doesn't have to correspond to the haskell syntax though.
04:18:59 <phadej> mpickering: somehow you'll need to tell it about your `T`, it cannot just know that instance exists
04:19:25 <phadej> (and which other definition need to be there)
04:19:52 <phadej> there's startingContext
04:20:07 * hackage hw-dsv 0.3.5 - Unbelievably fast streaming DSV file parser  https://hackage.haskell.org/package/hw-dsv-0.3.5 (haskellworks)
04:20:13 <phadej> so you could insert definition you get from `autoWith`
04:20:43 <phadej> (I don't know, maybe there are helpers for that even; I haven't followed closely)
04:21:14 <kritzefitz> % showFFloat (Just 50) (0.1 :: Double) ""
04:21:14 <yahb> kritzefitz: "0.10000000000000000000000000000000000000000000000000"
04:21:22 <kritzefitz> Why is this not slightly more than 0.1?
04:22:13 <kritzefitz> AFAIK 0.1 isn't can't be precisely represented by a float, so why does Haskell seem to be able to do so?
04:22:21 <kritzefitz> s/Haskell/ghc/
04:22:42 <dminuoso> kritzefitz: Why do you presume that 0.1 cant be precisely represented by a float?
04:22:46 <Axman6> % showFFloat (Just 80) (0.1 :: Double) ""
04:22:46 <yahb> Axman6: "0.10000000000000000000000000000000000000000000000000000000000000000000000000000000"
04:23:09 <Axman6> I'm pretty sure it is one of the repeating binary representations
04:23:24 <dminuoso> kritzefitz: IEEE 754 allows for the radix to be either 10 *or* 2. So strictly speaking it *could* be representable, depending on the implementatoin.
04:23:25 <Axman6> it's like 0b0.0011001100110011 or something
04:23:51 <kritzefitz> dminuoso, ah I was assuming a radix implementation of 2.
04:23:59 <Axman6> I'm not sure that's actually true of any actualy implementation of IEEE-754
04:24:08 <ClaudiusMaximus> > toRational (0.1 :: Double) - 0.1
04:24:10 <lambdabot>  1 % 180143985094819840
04:24:24 <Axman6> % showFFloat (Just 200) (0.1 :: Double) ""
04:24:24 <yahb> Axman6: "0.10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
04:24:27 <dminuoso> Axman6: My point is merely that based on the specs alone you cant deduce whether 0.1 is exactly representable or not. :)
04:24:31 <hpc> > 1 / 180143985094819840
04:24:34 <lambdabot>  5.551115123125783e-18
04:24:53 <kritzefitz> dminuoso, mostly I saw that python was not able to represent 0.1 and assumed that ghc would behave the same way.
04:24:56 <hpc> i wonder if showFFloat has some sort of trickery involved
04:25:06 <Ariakenom> Axman6: I would guess that string is rounded
04:25:07 * hackage hw-json 1.0.0.2 - Memory efficient JSON parser  https://hackage.haskell.org/package/hw-json-1.0.0.2 (haskellworks)
04:27:30 <dminuoso> % showFFloat Nothing (0.1 :: Double) ""
04:27:31 <yahb> dminuoso: "0.1"
04:27:40 <__monty__> -- Based on "Printing Floating-Point Numbers Quickly and Accurately"
04:27:40 <__monty__> -- by R.G. Burger and R.K. Dybvig in PLDI 96.
04:27:49 <__monty__> This algo is used in showFFloat.
04:28:06 <__monty__> Maybe you can find the answer there? 
04:33:49 <Ariakenom> __monty__: where did you find that?
04:34:47 <__monty__> In the code.
04:38:41 <tdammers> it may be worth noting that just `show`-ing a value is insufficient to judge whether it is an exact representation of a decimal
04:39:43 <tdammers> iow., if the equivalent of show 0.1 prints "0.1", then that can mean that the language in question can represent 0.1 exactly, but it can also mean that the implicit rounding involved in the formatting is playing in our favor here
04:40:11 <kritzefitz> “Finally, we prove that our algorithm gen-erates the shortest, correctly rounded output string fromwhich the original floating-point number can be recoveredwhen input.”.
04:40:18 <kritzefitz> That's probably the important bit here.
04:40:41 <kritzefitz> That's from the paper __monty__ pointed out above.
04:41:10 <Ariakenom> nice find
04:41:17 <__monty__> % showHFloat (0.1 :: Double) ""
04:41:17 <yahb> __monty__: "0x1.999999999999ap-4"
04:42:30 <__monty__> % showFloat (0x1.999999999999ap-4 :: Double)
04:42:30 <yahb> __monty__: ; <interactive>:494:12: error:; * Couldn't match expected type `Double' with actual type `a1 -> c0'; * Probable cause: `(-)' is applied to too few arguments; In the first argument of `showFloat', namely `(0x1 . 999999999999 ap - 4 :: Double)'; In the expression: showFloat (0x1 . 999999999999 ap - 4 :: Double); In an equation for `it': it = showFloat (0x1 . 999999999999 ap - 4 :
04:43:13 <__monty__> Hmm, guess it needs HexFloatLiterals.
04:44:07 <__monty__> I figured the hexadecimal representation would be true to the real one. But then you still need to convert that back to decimal without the rounding interfering again.
04:44:45 <__monty__> % 0x1.999999999999ap-4
04:44:45 <yahb> __monty__: ; <interactive>:495:1: error:; * Could not deduce (Num (b1 -> c)); (maybe you haven't applied a function to enough arguments?); from the context: (Num (a -> c), Num (b -> c), Num ((m (a1 -> b2) -> m a1 -> m b2) -> a -> b), Monad m); bound by the inferred type for `it':; forall a c b (m :: * -> *) a1 b2. (Num (a -> c), Num (b -> c), Num ((m (a1 -> b2) -> m a1 
04:45:07 <__monty__> % :set -XHexFloatLiterals
04:45:07 <yahb> __monty__: 
04:45:09 <__monty__> % 0x1.999999999999ap-4
04:45:10 <yahb> __monty__: 0.1
04:45:12 <__monty__> -.-
04:48:21 <__monty__> % toRational (0.1 :: Double)
04:48:21 <yahb> __monty__: 3602879701896397 % 36028797018963968
04:48:35 <__monty__> This is clearly not exactly 1 % 10 : >
04:50:31 <Ariakenom> % fromRational (toRational (0.1 :: Double) - 0.1) :: Double
04:50:32 <yahb> Ariakenom: 5.551115123125783e-18
04:51:49 <Ariakenom> with some, not at all confusing, defaulting
04:51:51 <Ariakenom> % fromRational (toRational (0.1) - 0.1)
04:51:52 <yahb> Ariakenom: 5.551115123125783e-18
04:53:19 <Ariakenom> of course this has rounding in the last conversion. is there a nice Rational show function for that instead?
04:54:53 <kritzefitz> % fromRat (1 % 10)
04:54:53 <yahb> kritzefitz: 0.1
04:55:08 <kritzefitz> Ah, wrong.
04:55:23 <kritzefitz> I thought that function returned a string.
04:55:42 <Ariakenom> :t fromRat
04:55:43 <lambdabot> RealFloat a => Rational -> a
04:56:10 <Ariakenom> :t fromRational
04:56:11 <lambdabot> Fractional a => Rational -> a
04:56:26 <Ariakenom> something something naming
04:57:49 <trcc> Hi. What is the entity before runtime? I.e. the code is linked with the runtime, but what do you call the other thing that is not runtime?
04:57:52 <trcc> is there a word for this?
04:58:34 <dminuoso> trcc: program?
04:58:34 <hpc> you mean your program?
04:59:14 <trcc> your program is the thing passed to the runtime
04:59:15 <trcc> _
04:59:16 <trcc> ?
04:59:25 <trcc> If so, then yes
04:59:31 <ClaudiusMaximus> > let showRat' x = let (n, y) = properFraction x in shows n $ showRat' (10 * y) ; showRat x = let (n, y) = properFraction x in shows n . ('.':) $ showRat' (10 * y) in showRat (toRational 0.1)
04:59:33 <lambdabot>  "0.1000000000000000055511151231257827021181583404541015625000000000000000000...
04:59:59 <ClaudiusMaximus> (probably doesn't work for negative values)
05:00:26 <kritzefitz> > let showRat' x = let (n, y) = properFraction x in shows n $ showRat' (10 * y) ; showRat x = let (n, y) = properFraction x in shows n . ('.':) $ showRat' (10 * y) in showRat (toRational (-0.1))
05:00:29 <lambdabot>  "0.-10000000000000000-5-5-5-1-1-1-5-1-2-3-1-2-5-7-8-2-70-2-1-1-8-1-5-8-3-40-...
05:02:03 <hpc> heh
05:02:11 <trcc> thanks dminuoso and hpc
05:05:26 <hpc> hmm
05:05:41 <hpc> > let showRat' x = let (n, y) = properFraction x in shows n $ showRat' (10 * y) ; showRat x = let (n, y) = properFraction x in shows n . ('.':) $ showRat' (10 * y) in drop 50 (showRat (toRational 0.1))
05:05:43 <lambdabot>  "101562500000000000000000000000000000000000000000000000000000000000000000000...
05:06:17 <hpc> oh right, this is still using Double so limited precision
05:14:38 <Sanchayan> When using postgres-simple, what would be the type of field in record, corresponding to a SQL date type?
05:22:09 <heebo> hello is it possible to pattern match against Data.Text values?
05:22:21 <dminuoso> heebo: Yes.
05:23:07 <dminuoso> heebo: If you enable OverloadedStrings, you can then use string literals
05:23:39 <dminuoso> % isFoo :: Text -> Bool; isFoo "foo" = True; isFoo _ = False
05:23:39 <yahb> dminuoso: ; <interactive>:507:10: error: Not in scope: type constructor or class `Text'
05:23:43 <dminuoso> % import Data.Text
05:23:44 <yahb> dminuoso: 
05:23:46 <dminuoso> % isFoo :: Text -> Bool; isFoo "foo" = True; isFoo _ = False
05:23:46 <yahb> dminuoso: ; <interactive>:509:30: error:; * Couldn't match expected type `Text' with actual type `[Char]'; * In the pattern: "foo"; In an equation for `isFoo': isFoo "foo" = True
05:23:51 <dminuoso> % :set -XOverloadedStrings
05:23:51 <yahb> dminuoso: 
05:23:54 <dminuoso> % isFoo :: Text -> Bool; isFoo "foo" = True; isFoo _ = False
05:23:54 <yahb> dminuoso: 
05:23:59 <dminuoso> % isFoo "foo"
05:23:59 <yahb> dminuoso: True
05:25:54 <heebo> aha
05:25:55 <heebo> thanks
05:31:07 * hackage reanimate-svg 0.9.0.0 - SVG file loader and serializer  https://hackage.haskell.org/package/reanimate-svg-0.9.0.0 (DavidHimmelstrup)
05:43:07 * hackage Chart-diagrams 1.9.2 - Diagrams backend for Charts.  https://hackage.haskell.org/package/Chart-diagrams-1.9.2 (bravit)
05:53:57 <akr> did by any chance anyone encounter crashes caused by the `nettle` C library? This assert is failing in my program: https://git.lysator.liu.se/nettle/nettle/blob/master/ecc-mod-inv.c#L156
05:54:23 <akr> right now I'm struggling with trying to retrieve a stacktrace from this "apport" ubuntu tool, so that's all I know
06:09:26 <c_wraith> akr: that looks like a buffer overrun test
06:11:22 <akr> weird… so, this application was compiled in a docker container and then deployed on a server with different ubuntu version (so, different packages)
06:11:36 <akr> right now I'm thinking this might be the most likely cause
06:11:40 <akr> c_wraith: ^
06:11:51 <dminuoso> akr: The build artifact was extracted out of the container?
06:12:01 <akr> if you mean the binary, yes
06:13:50 <akr> I mean that just sounds like a recipe for disaster 
06:14:15 <dminuoso> akr: Not really. Docker containers are not special.
06:14:35 <akr> sure, but the libraries that were linked against might be slightly different
06:15:06 <dminuoso> akr: If shared libraries are used and there's a mismatch, that would be bad indeed.
06:17:32 <akr> well, they are used, according to ldd
06:17:40 <akr> and one of the is indeed libnettle
06:18:26 <akr> still, it is the "correct" version, I mean it's linked against libnettle.so.6
06:18:47 <akr> not sure if that can refer to different (minor?) version across different installations
06:18:54 <akr> versions*
06:28:37 * hackage orion-hs 0.1.3 -   https://hackage.haskell.org/package/orion-hs-0.1.3 (CorentinDupont)
06:32:37 <remexre> if I have a data Foo = Foo Int (IORef Foo), is there a nice way to convert a bunch of these to data Bar = Bar Int Bar values instead?
06:34:09 <c_wraith> remexre: the standard recursive walk really isn't very bad at all
06:35:11 <c_wraith> remexre: fooToBar (Foo x ref) = do foo <- readIORef ref ; bar <- fooToBar foo ; pure (Bar x bar)
06:36:25 <remexre> if the IORefs are circular, does this infinitely loop though?
06:36:48 <c_wraith> Yes.
06:37:42 <c_wraith> If nothing is going to change the IORefs ever again, you can throw in an unsafeInterleaveIO to deal with that by making it lazy
06:38:13 <remexre> ok, thanks!
06:38:18 <c_wraith> Otherwise you might need to make a more complex traversal that establishes sharing based on IORef identity
06:38:34 <c_wraith> it's still not bad, but it is a few more lines :)
06:42:19 <MacSlow> Greetings everybody!
06:42:22 <remexre> huh, so what's the issue here? https://p.acm.umn.edu/WnjbwlcU0AA=
06:42:44 <remexre> (I've never actually used unsafeInterleaveIO, so I'm not sure I'm using it right)
06:43:53 <remexre> oh, never mind, if I compose the whole fooToBar with unsafeInterleaveIO instead of just readIORef, it works
06:43:58 <c_wraith> yes
06:44:08 <c_wraith> it suspends whatever IO action you pass it
06:44:16 <c_wraith> you want to suspend the recursive call :)
06:44:26 <remexre> right :P
06:45:25 <c_wraith> Do be aware, you're entering the realm of lazy IO.  It has consequences, like evaluation results possibly depending on evaluation order.
06:45:52 <c_wraith> It's perfectly fine to use, but you should make sure that those consequences won't mess things up for you
06:47:01 <remexre> yeah, lazy IO has given me weirdness before...
06:48:39 <c_wraith> Just make a note that if things start to get weird, it's something you need to look into further.  Like, as a comment in the code.  :)
06:48:49 <remexre> :+1:
07:02:13 <heebo> hi I have this type ``` newtype NullableUTCTime = NullableUTCTime (Maybe UTCTime) deriving (Show ) ```
07:03:41 <heebo> I want to write a fromJSON instance for it, such that if the JSON contains "Null" the result is a NullableUTCTime None and a NullableUTCTime $ Just UTCTime otherwise
07:04:44 <heebo> however when i use overloadedstrings and to pattern match (String "Null") it fails the match
07:05:33 <fen> this is quite interesting; https://pastebin.com/raw/Uz4zGAqU
07:06:02 <dminuoso> heebo: "Null" and null are different in JSON.
07:07:10 <heebo> I think its "Null" but thats a great point, i only observe that after ive printed it, i.e. rendered to a string
07:07:16 <heebo> how would i match null?
07:08:16 <dminuoso> heebo: https://hackage.haskell.org/package/aeson-1.4.2.0/docs/Data-Aeson.html#t:Value
07:09:11 <dminuoso> heebo: Do you see the Null data constructor for Value?
07:09:38 <heebo> yes! thank you
07:19:05 <fen> hmm, this version is better; https://pastebin.com/raw/Rskq9LQA
07:19:08 <fen> any ideas?
07:20:45 <fen> class HyloDual f g => Hylo f g where  hylo :: s -> f s a -> g a b -> b
07:23:05 <fen> this looks similar; but the dual of Alg and CoAlg seems less strong.. http://hackage.haskell.org/package/category-extras-0.44.1/docs/Control-Morphism-Hylo.html
07:23:46 <fen> and there is;
07:23:46 <fen> hylo :: Functor f => (f b -> b) -> (a -> f a) -> a -> b
07:23:58 <fen> from Data.Fix; http://hackage.haskell.org/package/data-fix-0.2.0/docs/Data-Fix.html
07:31:44 <fen> even recursion schemes has this notion of algebra and coalgebra over the base type of the container
07:33:12 <fen> is the notion of Dual in the paste more general than (a -> f a) <-> (f a -> a)
07:33:29 <fen> ?
07:35:09 <fen> like, is the Alg - CoAlg duality just an instance of HyloDual?
07:35:16 <fen> or are they equivalent?
07:40:17 <fen> cant quite see how (a -> f a) could capture (s -> (a,s)), (s -> Maybe (a,s)), (s -> (a,Maybe s))
07:41:23 <fen> hmm, ok so f is a functor that could be eg \s -> (a,s) or \s -> Maybe (a,s) etc
07:42:16 <fen> huh, maybe these are literally equivalent. ie all HyloDual f g instances could be represented as Alg / CoAlg...
07:42:22 <fen> struggling to prove that though
07:42:41 <fen> or even to disprove it...
07:43:12 <fen> heres the paste again; https://pastebin.com/raw/Rskq9LQA
07:44:58 <fen> guess you could do something weird like adding a phantom type to State and Costate.. 
07:46:08 <fen> cant tell if that means its better to work with HyloDual because its more general, or with Alg/CoAlg because it prevents such cases!
07:50:48 <adamCS>  A simpler (I hope!) question about recursion-schemes and the like:  Mostly as a learning exercise, I've been implementing various versions of a groupBy function (f :: Ord k => [(k,v)] -> [(k,[v])]).  I've been sort of following along with the lovely paper "A Duality Of Sorts" about sorting with recursion-schemes.  So I've built a few versions, verified that they produce the correct result and then benchmarked them.  And
07:50:48 <adamCS>  I'm...confused.
07:52:10 <adamCS> First off: The fastest thing I've found so far is "Data.Map.toList . Data.Map.fromListWith (<>) . fmap (second (pure @[]))"
07:53:13 <adamCS> (Actually, HashMap is faster but lets ignore that for now!  I'm confused enough without it!)
07:54:35 <adamCS> The code for my various versions is here: https://github.com/adamConnerSax/Frames-utils/blob/master/map-reduce-folds/src/Control/MapReduce/Engines/GroupBy.hs
07:55:03 <adamCS> And the benchmark code is here: https://github.com/adamConnerSax/Frames-utils/blob/master/map-reduce-folds/bench/GroupBy.hs
07:55:58 <fen> nice work! whats the question?
07:57:07 * hackage ring-buffers 0.1 - mutable ring buffers with atomic updates in GHC Haskell  https://hackage.haskell.org/package/ring-buffers-0.1 (chessai)
07:57:42 <adamCS> The first thing that's cool is that the unfold of a fold version is faster than the fold of an unfold.  Because the unfold first version gets to combining things earlier and combining is good, results in fewer comparisons as the algo goes on.  But the equivalent version using an unfold of a paramorphism is slower, though in my code I completely ignore the extra info in the paramorphism.
07:58:02 <adamCS> That feels like a sign that I am missing something fundamental about how all this works.
07:59:49 <fen> a paramorphism can avoid folding over a remainding tail right?
08:00:09 <fen> wouldnt seem that useful in a sort that didnt have an already sorted tail...
08:00:20 <adamCS> No. Paras can see the structure as well as the result so far
08:00:23 <fen> actually, no idea how this works so lets let someone else help with this...
08:00:50 <fen> oh ok, that makes more sense, still getting familiar with these other recursion schemes
08:01:03 <fen> one thing is that there seems to be a lot of use of Fix?
08:01:13 <adamCS> apos can avoid redoing work.  I think.  But to use an apo here, I have to fold first.  And then I lose the early combining advantage.  Which is the first thing I am trying to untangle.
08:01:14 <fen> thats because of this notion of a "base functor" right?
08:01:25 <fen> fold ::(Functor f) ⇒ (f a → a) → (Fix f → a)
08:01:33 <fen> unfold ::(Functor f) ⇒ (a → f a) → (a → Fix f)
08:01:41 <fen> from; https://www.cs.ox.ac.uk/ralf.hinze/publications/Sorting.pdf
08:01:50 <fen> (the paper you mention)
08:01:59 <adamCS> Yes.  Like [a] ~ Fix (ListF a)
08:02:11 <fen> but why not unfold using a state?
08:02:29 <fen> and use the actual list rather than this isomprphic fix thing?
08:03:14 <fen> its not ~ is it? its just isomorphic
08:03:58 <adamCS> Here's where I get hazy.  But my rough understanding here is that if you can specify all the steps in terms of the base functors, it's then possible to optimize away all the intermediate structure.  Which doesn't matter when it's all lists.  But if there's some better version with a tree in the middle--and the speed of the Map version hints that way--then there might be a recursion schemes version that has that advantage and
08:03:58 <adamCS>  doen't build the tree at all.
08:04:15 <adamCS> Which, to be fair, might also be true of the Data.Map version.
08:04:22 <realloc> hi, do I understand correctly, that Haskell uses user-level threads with its own scheduler? If that is true, wouldnt a blocking IO call (or any syscall) also block all other threads?
08:05:03 <adamCS> fen: it is isomorphic but not the same since there is an extra constructor in there with Fix.
08:05:25 <fen> ahh, ok, so this kind of fuses away specifically one structure, and forces that the intermidiate structure is this fix type thing, which never actually gets made, whereas the version with state would allow any "Linear" thing to be unfolded and fused away as a unevaluated intermidiate type
08:06:32 <fen> adamCS: isnt it slow to convert the map to a Fix-List just so it can be fused over?
08:06:37 <fen> Map*
08:06:38 <realloc> Ok, I just found this "It is a common misconception that you need to use forkOS instead of forkIO to avoid blocking all the Haskell threads when making a foreign call; this isn't the case."
08:07:09 <realloc> I wonder how a syscall is handled then, to achieve this
08:08:17 <adamCS> fen: Not if you do it right!  You fold (or unfold) the list to a Tree, then fold or unfold it back to a List, now sorted.  The Tree gets fused away and you end up with a good mergesort or heapsort.  But that's the sorting case.  And my confusion starts well before there are any trees involved.
08:08:31 <fen> adamCS: wait, your somehow getting at the intermidiate Tree of the map and fusioning it?
08:09:22 <fen> ohh, thats just some other special Fix-Tree thing your fusing away that has a faster sort implementation. ok, thought it was the Tree the Map was built of internally.
08:09:25 <adamCS> fen: No.  The version using Map does whatever it does.  My guess is that it gets fused away but I haven't checked.  it's just my reference implementation for correctness and speed.
08:09:36 <fen> you dont actually fuse through the Map then...
08:09:56 <fen> like, if it was unfolded from a state
08:09:57 <adamCS> right
08:10:15 <fen> these is no base-functor for Map? its not a Fix-Like thing?
08:10:29 <fen> even though its a tree internally?
08:11:14 <adamCS> You just make a tree structure and use it.  See: https://github.com/adamConnerSax/Frames-utils/blob/master/map-reduce-folds/src/Control/MapReduce/Engines/GroupBy.hs#L274
08:11:21 <monochrom> realloc: See my http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml , the section "Concurrent FFI Calls"
08:11:54 <adamCS> I think since there are many possible Tree structures, the library doesn't pick one.  List is sort of fundamental.
08:12:13 <monochrom> The correct purpose of forkOS is in the next section, "Thread-Local FFI Calls".
08:12:43 <adamCS> fen: That TH "makeBaseFunctor" makes the appropriate TreeF such that Tree a = Fix (TreeF a)
08:12:56 <fen> snazzy
08:13:02 <adamCS> True that
08:13:20 <fen> is that like writing get and set instances?
08:14:45 <fen> guess the Recursive and Corecursive instances are basically equivalent
08:14:52 <fen> as they give to and from list?
08:14:55 <adamCS> fen: sort of.  It makes the data structure and then instances of Recursive and CoRecursive, which allow you to roll and unroll one level of Fixed-ness
08:14:57 <adamCS> http://hackage.haskell.org/package/recursion-schemes-5.1.2/docs/Data-Functor-Foldable-TH.html
08:14:58 <adamCS> right
08:19:37 <realloc> monochrom, that helped, thank you
08:27:50 <__monty__> Hmm, mpickering, I got curious and looked into it. Deriving Interpret *is* working some magic. I think the problem's just the unexpected syntax for literals of a certain type.
08:29:00 <fen> adamCS: still confused about the time it doesnt spend converting to the Fix structure...
08:30:01 <fen> it still has to fold the underlying Map right? like, toList, even it doesnt actually build the Fix TreeF thing, it still ends up building a list?
08:30:32 <fen> like, its not fusing down to the state which unfolded a linear structure? 
08:31:16 <fen> by working with Map that has a slow "get" to turn it into an unfolding state. and then you use it to unfold a list, via an intermidiate Tree which is fusioned away
08:31:17 <adamCS> fen: Let's ignore Maps altogether for now.  I'm plenty confused by list -> list versions.
08:32:43 <fen> well yeah, it was basically just a "state" used to unfold something anyway
08:33:44 <fen> just not sure if it unfolds this virtual Tree or a list
08:34:16 <fen> like, does it fuse down to the state, or the list unfolded by the state?
08:36:02 <johnw> dminuoso: ah, I see
08:38:06 <adamCS> fen: For the first few versions, there is no Tree.  Just List-like things.  Nil and Cons a (ListF a [a]).  Which is not exactly a list, but certainly not a tree.
08:38:40 <fen> but not a state?
08:39:10 <fen> like, there is no Tree, fine, but is there is no List either?
08:41:52 <fen> like, it could be that the list was produced by build, then the coalg from folding the list into a tree would fuse
08:44:17 <adamCS> Sure.  The list may fuse.  But I'm stuck on simpler things, I think.  I'm just trying to make sure I understand why an unfold of a fold is faster here and then why the paramorphism version is any different, given that I thing I am ignoring the extra info.  Maybe I have to dive into core but I find that...difficult.
08:48:06 <fen> hmm
08:48:38 <fen> it does not matter if the list fises?
08:49:41 <fen> basially the point is that lists are foldable, so you can always make a coalgebra if you can fold the list into eg a tree, such as if the tree has a set function to use to fold the list with
08:51:16 <fen> guess its a matter of style, do you bother making 2 virtual equivalent intermidiate types? if the fold list to tree requires a set tree instance, why not just unfold to the tree, but thats almost like saying, whats the build fold fusion for lists worth... 
08:51:41 <fen> thats why a version of build that uses Set directly is actually quite cool
08:51:42 <adamCS> Ultimately, it matters if it fuses.  But right now I am trying to understand a difference between two algos where, I think, the fusion aspect is the same, so it's not a fusion issue.  
08:51:54 <fen> oh ok
08:51:59 <fen> sry
08:53:31 <adamCS> np! Just trying to be clear about where my confusion is.  
08:54:06 <fen> was just trying to understand why use all this TH and baste_t coalgebras just to be able to use list fusion to have a fold coalg when a version of build which used a set instance would save this complexity
08:55:10 <fen> like, why not combine list fusion and the Fix-Like isomorphism into one "Linear" class?
08:56:04 <fen> get and set seem way more straitforward than a TH derived base functor and virtual Fix_like structure AND a virtual list like structure
08:56:13 <adamCS> Right now it's educational.  Trying to understand the recursion-schemes library and that way of thinking.  Eventually trying to understand how all this can build a good groupBy function.  But for now just trying to get my head solidly around the basic recursion schemes.
08:57:08 <fen> sure, both fusion rules can work together and its equivalent, but somehow it seems less intuitive than just showing how Tree is like a list, instead of having TH wrangle this by kind of having a Generic Fix like representation
08:58:00 <fen> probably the REAL problem is that Unfoldable does not make much sense as foldable
08:58:37 * hackage haiji 0.2.2.2 - A typed template engine, subset of jinja2  https://hackage.haskell.org/package/haiji-0.2.2.2 (NoriyukiOhkawa)
08:58:43 <fen> like, taking hylo, and partially applying the state, to leave fold, is not the same as the opposite of taking hylo and not doing the fold part to leave an abstract foldable container
08:59:05 <fen> that was the point of trying to combine the foldable and unfoldable classes into the hylo class here
08:59:14 <fen> https://pastebin.com/raw/Rskq9LQA
08:59:38 <fen> unfoldable as a class over state-like things does not work
09:00:04 <fen> we need a way to express all the different types of state like things, which seem more than can be covered by alg & coalg
09:00:19 <fen> and the question was if these extra cases could be useful
09:00:26 <fen> well that was my question anyway
09:02:44 <fen> hylo :: Functor f => (f b -> b) -> (a -> f a) -> a -> b
09:02:49 <fen> compared with;
09:02:50 <fen>  hylo :: s -> f s a -> g a b -> b
09:04:02 <fen> and yeah, how is that (a -> f a) supposed to be like (s -> (a,s))
09:04:32 <fen> is it trying to unfold values from a value of the same type?
09:05:49 <fen> (s,f s a) -> [a], s can be like a RNG or something, producing Num a => a. 
09:06:35 <fen> trying to generalise to f s a = s -> (a,s) or f s a = s -> (a,Maybe s) 
09:06:53 <fen> that does not seem to be what Alg and CoAlg express...
09:07:26 <fen> ana :: Functor f => (a -> f a) -> a -> Fix f
09:07:57 <fen> or is f supposed to be containing the values? like swapping the roles of s and a?
09:19:29 <mpickering> __monty__: what do you mean exactly? 
09:20:36 <__monty__> mpickering: That give data T 
09:21:33 <__monty__> mpickering: That given data T = A | B | C deriving Generic...; input auto "< A = {=} | B : {} | C : {} >" :: IO T is valid.
09:22:38 <mpickering> Right I would expect that? 
09:23:11 <__monty__> I thought you were expecting input auto "A" :: IO T to be valid.
09:23:17 <mpickering> As that doesn't require anything from the context
09:23:18 <__monty__> or "T.A"
09:23:22 <mpickering> I am
09:23:37 * hackage datadog-tracing 1.3.3 - Datadog tracing client and mock agent.  https://hackage.haskell.org/package/datadog-tracing-1.3.3 (fommil)
09:36:47 <shapr> ooh, I could probably use that datadog-tracing package
09:41:14 <__monty__> mpickering: That'd be like defining new built-in types. Which would make your dhall not evaluate as dhall anymore. So you have to define those builtins yourself, basically creating a new language. It's not that weird a decision.
09:45:42 <mpickering> Exactly what I want
09:45:59 <mpickering> Or at least some sane method to achieve it
09:48:41 <__monty__> mpickering: This should help you achieve that: https://github.com/dhall-lang/dhall-lang/wiki/How-to-add-a-new-built-in-function
09:49:07 * hackage haiji 0.2.2.3 - A typed template engine, subset of jinja2  https://hackage.haskell.org/package/haiji-0.2.2.3 (NoriyukiOhkawa)
09:53:17 <shapr> oh, I just need edit ~/.cabal/config and uncomment and fill in symlink-bindir: ~/.cabal/bin
10:37:22 <finnkauski> hi folks. 
10:37:43 * dmwit waves
10:39:00 <finnkauski> Not to cause too much of a discussion, but someone next to me is sort of scoping out what language to tackle next as a side thing to learn. So he has a background in Java and a bit of Python. I suggested haskell (i'm learning it myself atm.). What would you say are the reasons to learn Haskell over the other major langs? (And i know this is like comparing apples and oranges)
10:39:57 <dmwit> Of the languages you could choose, I think Haskell hits a nice spot: it's got a lot of concepts that you probably haven't encountered in other major languages, which means that learning it teaches you the most new things.
10:40:09 <delYsid> What happens if a duped TChan is garbage collected.  I guess messages which arrived in the meantime get GC'd as well?
10:40:14 <dmwit> Rust with its borrow checking seems like it would also be high in my list.
10:40:26 <finnkauski> Yeah, those are the two in my aim as well. 
10:40:43 <finnkauski> Definitely rust after I get comfortable with haskell (so like another 10 years or so :D )
10:42:56 <dmwit> As it happens, I also think Haskell is a very nice language, independently of whether it does things differently from other languages or not. =)
10:43:13 <AndreasK> finnkauski: If he's a friend of yours he should join you learning Haskell. Having someone to discuss things with is very valuable.
10:43:21 <finnkauski> Yeah 
10:43:27 <finnkauski> I've been lobbying him to softly 
10:43:50 <dmwit> Lazy, pure, functional, ADTs, type inference, and higher-kinded polymorphism are all features that I wish for when I'm forced into other languages.
10:45:19 <dmwit> (...and I'm happy to expand at length on what any of those means and why it's useful.)
10:45:51 <finnkauski> ADT's just seems a bit of a myster to me, i'm 600 pages into the Haskell Book 
10:45:56 <finnkauski> and just got through them 
10:46:10 <finnkauski> But i was assured when they click, you get why they are useful 
10:46:13 <nshepperd> delYsid: if the messages are no longer readable they'll be GC'd
10:46:24 <__monty__> What? Algebraic Data Types are pretty simple.
10:46:35 <__monty__> Why wouldn't they come up in the first 600 pages? o.O
10:46:41 <finnkauski> they did 
10:46:42 <dmwit> finnkauski: ADTs are the obvious generalization of switch-case statements.
10:46:44 <MarcelineVQ> er, you meet them on page 88 hehe
10:47:04 <dmwit> finnkauski: (I think for newcomers that's the right way to understand them.)
10:47:40 <MarcelineVQ> data Bool = False | True is a simple ADT
10:47:41 <dmwit> finnkauski: Like switch-case, they 1. enumerate all the possible cases you could be in and 2. give you a way to take different actions in each case.
10:47:57 <finnkauski> I mean, i got through the chapter, i understand product and sum types etc. but It's not 'clicked' on how i'm going to be leveraging them 
10:47:57 <dmwit> The big difference is that they let you store extra information specific to each case.
10:48:23 <finnkauski> As far as I had discussions here. its just a good way to understand how large your '...'
10:48:26 <finnkauski> whats the word 
10:48:34 <AndreasK> domain?
10:48:38 <dmwit> So when you are in the "this object is a car" case, you can store VIN info; when you're in the "this object is a house" case you can store the address.
10:48:55 <dmwit> And never the twain shall meet: the type-checker helps you make sure you didn't try to store an address for a car or a VIN for a house.
10:49:06 <finnkauski> t
10:49:09 <finnkauski> Cardinality!
10:49:11 <finnkauski> Thats it. 
10:49:38 <finnkauski> So as far as I understand it helps you think about cardinality of your data 
10:49:49 <dmwit> That's one way to approach it. But I think not a very good way, because a huge collection of useful ADTs all have the same cardinality, even though they are not usable interchangeably.
10:50:20 <finnkauski> Sure, but understanding the cardinality of your datatype, helps you cover all your possibile outcomes 
10:50:31 <AndreasK> On a certain level I just think of them as C structs. It's not a perfect equivalent but then what is.
10:50:33 <finnkauski> Again i'm fairly new to this and i've not picked up haskell for about 2 weeks. 
10:51:09 <finnkauski> I mean, the type system in haskell is ace. Its the algebraic part of it i was struggling to make use of atm.
10:51:10 <zincy> finnkauski: Don't stress, just practice using ADTs in real code and you will build the intuition.
10:51:13 <finnkauski> But again, it'll click 
10:51:18 <finnkauski> Yeah zincy. 
10:51:34 <zincy> You are probably worrying about what you don't know.
10:51:36 <finnkauski> Thats the plan. Again I asked for a good haskell project and people struggled to give me a basic haskell project to work about. 
10:51:58 <finnkauski> Something not tractable but not trivial :D 
10:52:03 <finnkauski> That would also be ace
10:53:03 <AndreasK> finnkauski: Tbh I rarely (never maybe?) explicitly think about the algebraic part.
10:53:23 <finnkauski> Yes. Thats what I concluded from my first discussion here about them. 
10:53:41 <finnkauski> Sum, product etc. isn't something you probably thing about unless you wanna assess the cardinality of the type you're working with 
10:54:33 <__monty__> I never think about the cardinality of my types.
10:54:43 <dmwit> You seem pretty hung up on this cardinality thing. I think it's a complete red herring.
10:54:52 <finnkauski> Im not hung up per say 
10:54:53 <AndreasK> It's useful if your doing proofs or generic programming. But when just trying to put down code that does something it's kinda irrelevant. 
10:54:57 <finnkauski> Its just what the punchline to the chapter was 
10:55:00 <zincy> finnkauski: Write a two player poker game in Haskell. Where player actions are read from the command line.
10:55:11 <finnkauski> I'm not that invested in the whole 'algebraic' part as of yet. 
10:55:20 <zincy> There is a library that does exactly that so you can write your own and then after see how they did it
10:55:22 <finnkauski> I think a while later when i reread the book it will make more sense 
10:55:37 <__monty__> The important thing about the "algebraic" part is that you can combine more basic types with sums and products.
10:55:46 <dmwit> It's not super common to use the algebraic laws that give algebraic data types their names. But when you do, it's generally not for cardinality.
10:56:01 <dmwit> e.g. the concept of differentiation and its connection with zippers is a brilliant connection with algebra, and has nothing to do with cardinality.
10:56:22 <AndreasK> finnkauski: Are you on windows or linux?
10:56:42 <dmwit> Refactoring your types can often be conceived of as an algebraic manipulation, and again is not really about cardinality.
10:56:52 <finnkauski> atm im on my work mac, but when I get my new laptop i'm just gonna dump arch on it 
10:56:56 <finnkauski> so linux in short 
10:57:09 <dmwit> But most uses of algebraic types in your day-to-day programming with Haskell won't be concerned with the algebra that gives them their name.
10:57:43 <finnkauski> yes. thats how i get it. 
10:57:47 <dmwit> Nevertheless pattern matching and discriminated unions are so smooth in Haskell that it makes me want to implement Haskell-like features as a preprocessor when I switch to other languages that don't have them. =P
10:59:02 <finnkauski> poker game sounds good 
10:59:02 <AndreasK> finnkauski: The best projects are these in whose success you are invested. So hard to give you one that you will find fullfilling :) But simple games are always an option.
10:59:14 <finnkauski> yeah. 
10:59:27 <finnkauski> Any good libraries for ui dev in haskell ? 
10:59:31 <AndreasK> No
10:59:38 <finnkauski> I c. 
10:59:44 <AndreasK> There are ok bindings though.
11:00:18 <zincy> Yeah you are better picking a project that aligns with your interests
11:00:50 <AndreasK> finnkauski: So if you are used to a popular gui library just go with the bindings for that. For console I heard good things about brick
11:02:06 <finnkauski> Well I work with data. I'm a data scientist. So I suppose it would be good to get on some data analysis. Unfortunately the Haskell ecosystem for scientific computing is not as well tied together as the python one. 
11:02:14 <finnkauski> In terms of interoparability 
11:02:36 <finnkauski> So perhaps implementations of some algorithms from scratch would be a good place to start. 
11:05:05 <fen> https://pastebin.com/raw/4B6KPzkY
11:05:44 <finnkauski> ok good chat
11:05:46 <finnkauski> thanks folks 
11:05:48 <finnkauski> cya 
11:06:33 <fen> instead of (as in recursion schemes) needing to use the type associated to a container as the state to unfold it, or the costate to fold it, we can generate different foldable/unfoldable classes as synonyms for different state or costate types which are dual
11:07:31 <fen> so instead of Tree and Nonempty having different state types, they can both use the same one...
11:09:42 <fen> in the language of recursion schemes, these types have the same base type, which we use to give a unique type synonym for foldable or unfoldable things which can use this common state or costate
11:10:15 <fen> ie we have a family of foldable or unfodable classes parametrised by the common base types of different containers
11:12:50 <fen> so that instead of having, what ammounts to - in this way of thinking, a unique Foldable/Unfoldable class associated to *each* container (this is basically what recursion schemes does, hence TH) we instead can collect containers which have the *same* shaped argument to unfold and fold
11:13:32 <fen> allowing us to say eg, these are all nonempty (Linear); ... and these are all streams; ... and these are all stacks; ... 
11:13:59 <fen> by identifying the isomorphism between the base functors
11:14:14 <fen> to a common set of State / CoStates
11:15:25 <fen> as a way of naming these classes by isomorphims with the particular type of State or CoState that is used as a parameter to define the Foldable class variant synonym
11:16:57 <fen> having enumerated these - and having only found 12 different cases, it seems better to memorise these and use them as a language feature, than to needlessly generate using TH a state / costate base functor alg / coAlg for each container
11:18:07 <fen> hmm, one caveat, thats for one or fewer parameter base functors.. ie, not multiparameter containers
11:18:27 <zachk> you don't need th to do recursion schemes from what I have seen 
11:20:17 <fen> well sure you can write the base functor out by hand if you like
11:20:37 <fen> the point is you dont need to, you can unfold using the common state
11:20:45 <fen> like, for folding;
11:20:47 <fen> :t foldr
11:20:48 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
11:21:15 <fen> the ((a -> b -> b),b) is like (a -> b -> Maybe b)
11:21:19 <fen> no
11:21:28 <fen> (a -> Maybe b ->  b)
11:21:55 <fen> which is common to all "Foldable" containers (as opposed to eg Foldable1)
11:22:36 <fen> whereas for recursion schemes you have Base t b -> b
11:22:49 <fen> eg (ListF a b -> b)
11:23:15 <fen> where ListF a b = Nil | Cons a b
11:23:36 <fen> is isomorphic to (a -> Maybe b ->  b)
11:23:38 <fen> wait...
11:23:46 <fen> how does that go...
11:24:14 <Solonarv> actually, (a -> b -> b, b) is smaller than (a -> Maybe b -> b)
11:24:29 <Solonarv> the latter can use the value of 'a' to produce a 'b' in theNothing case
11:24:40 <Solonarv> it's (Maybe (a, b) -> b)
11:24:45 <fen> yikes!!
11:25:09 <Solonarv> and indeed ListF a b = Nil | Cons a b ~ Maybe (a, b)
11:25:10 <fen> oh right, well at least then its obviously isomorphic to ListF
11:26:00 <fen> so the idea is that you could use (Maybe (a,b) -> b) instead of (Base [a] b -> b)
11:26:31 <fen> so that you could then eg, refer to this as a "stack"
11:26:51 <fen> along with anything else with a base functor isomorphic to this
11:27:12 <fen> (previously these have been called "list-like" things)
11:28:02 <fen> now we have a cononical naming convention given by the state / costate defining the isomorphism class of the base functors
11:29:12 <fen> and associated Foldable and Unfoldable (and hylo - fusion) classes parametrised by these cannonical state / costates
11:29:27 <fen> as demonstrated here; https://pastebin.com/raw/4B6KPzkY
11:30:39 <delYsid> Does Haskell have a way to run an IO action when a data type is GC'd?
11:30:53 <Solonarv> there are finalizers, yes
11:31:09 <c_wraith> "when" is uncertain. "sometime after" isn't too bad
11:31:34 <Solonarv> IIRC they're attached to a ForeignPtr and run after the ForeignPtr is GCed
11:31:44 <c_wraith> I've never seen finalizers used outside of ForeignPtr, though.
11:31:57 <c_wraith> not sure if they apply to arbitrary types.
11:32:25 <Cale> ForeignPtr's reason to be is finalizers
11:33:08 <c_wraith> touchForeignPtr is a weird thing.
11:33:34 <c_wraith> laziness + finalizers is an interesting combo
11:33:50 <delYsid> I am perhaps overdoing it, but I have a Handle to an external process which can be quit gracefully, so I was wondering if I could send a final quit command before shutting it down.
11:34:01 <fen> so do I just not use these results and start using recursion schemes...
11:35:13 <HenryCH> what's the easiest way to group items in a list (i don't even need to apply a key function, just 'id')
11:35:18 <fen> hmm, guess thats like asking whats the use in the foldable class at all...
11:35:41 <slack1256> delYsid: If it's a external process, just wait for the exit return value
11:35:45 <Solonarv> HenryCH: 'group'
11:35:56 <Solonarv> will only group *adjacent* elements though
11:36:00 <HenryCH> Solonarv: I tried this, but doesn't give what I expect
11:36:08 <Solonarv> > group "aaaabbbbcccaaabb"
11:36:10 <lambdabot>  ["aaaa","bbbb","ccc","aaa","bb"]
11:36:10 <HenryCH> right, exactly, anything that will just do the whole list?
11:36:13 <slack1256> % :t groupBy
11:36:13 <yahb> slack1256: ; <interactive>:1:1: error:; Ambiguous occurrence `groupBy'; It could refer to either `Data.Text.groupBy', imported from `Data.Text'; or `Data.List.groupBy', imported from `Data.List' (and originally defined in `base-4.12.0.0:Data.OldList')
11:36:21 <slack1256> % :t Data.List.groupBy
11:36:21 <yahb> slack1256: (a -> a -> Bool) -> [a] -> [[a]]
11:36:23 <Solonarv> you can 'sort' the list first
11:36:28 <fen> but whats the correct way, when discovering there are a family of foldable like classes, make one for each container (ala recursion schemes) or use the cononical state / costate and associated Foldable / Unfoldable class varient
11:36:29 <MarcelineVQ> not you too yahb :O
11:36:31 <Solonarv> groupBy doesn't help here
11:36:33 <Cale> You could sort. Possibly the answer to the easiest way is just to use Map.fromListWith
11:36:43 <MarcelineVQ> % :q
11:36:43 <yahb> MarcelineVQ: 
11:36:46 <Cale> Depending on what exactly you mean by "group"
11:36:47 <fen> serious question
11:36:47 <Solonarv> > (group . sort) "aaaabbbbcccaaabb"
11:36:49 <lambdabot>  ["aaaaaaa","bbbbbb","ccc"]
11:37:49 <HenryCH> thanks
11:38:46 <fen> mu fix group shuffle
11:41:14 <Solonarv> delYsid: ah, weak pointers also exist
11:42:07 <Solonarv> although the docs warn about using a weak pointer to an ordinary Haskell ADT
11:43:20 <delYsid> Solonarv: I just found System.Mem.Weak.addFinalizer, but it looks scary.
11:44:18 <delYsid> nah, this is overdesigning, but was interesting to know.
11:45:30 <Solonarv> I'd choose the "bracket" / "with*" pattern
11:45:33 <fen> probably there is a correct number of foldable classes, somewhere inbetween 1 and 1 for each container type...
11:45:55 <Solonarv> i.e. 'withExternalProcess :: SomeConfigData -> (ExternalProcessHandle -> IO ()) -> IO ()'
11:46:48 <Solonarv> and 'withExternalProcess cfg = bracket (startExternalProcess cfg) exitExternalProcess'
11:47:17 <fen> where that number is the number of equivalence classes of the base functors of the containers
11:47:28 <Solonarv> or you could lean on resourcet
11:47:35 <fen> which is fewer than the number of containers, and greater than 1
11:47:42 <fen> so in the correct region
11:49:39 <fen> well, I still think there are just streams linear and stacks with possibility to skip, and generalise to getting a container of values as the head
11:50:25 <Ariakenom> I'll ping delYsid in case they missed it
11:50:29 <fen> so basically just 3 x the number of types of containers that could be
11:51:43 <fen> with the current Foldable class corresponding to "stack" + Identity
11:52:37 * hackage push-notifications 0.2 - Push notifications for Android and iOS  https://hackage.haskell.org/package/push-notifications-0.2 (abrar)
11:53:19 <fen> one thing though about this "duality" between the state and costate, is that a good use of UndecidableSuperclasses? https://pastebin.com/raw/4B6KPzkY
11:53:37 <fen> and there is something strange going on with the constraint appearing in the forall of the fusion rule....
12:13:54 <fen> extension on the theme; https://pastebin.com/raw/mDdjGUKL
12:14:11 <fen> class (Unfolding (Base f) f,Folding (Co (Base f)) f,Hylo (Base f) (Co (Base f))) => FIFO (f :: * -> *) where type Base f :: * -> * -> *
12:14:58 <fen> instance FIFO [] where  type Base [] = State
12:15:12 <fen> here State defines the equivalence class
12:24:07 * hackage push-notifications 0.2.1 - Push notifications for Android and iOS  https://hackage.haskell.org/package/push-notifications-0.2.1 (abrar)
12:59:27 <TheOrientalBegin> Hello everyone
12:59:38 <cronokirby[m]> heya
13:00:37 <TheOrientalBegin> How can I create type with list plea ? For example if i want a thing like this :  type myType = ([Int, Int, Int, Int, Int], [Int, Int])
13:02:47 <cronokirby[m]> I don 't think you can get type-level lists with that syntax
13:03:11 <cronokirby[m]> although you could have a type-level list that accomplishes that
13:07:56 <slack1256> TheOrientalBegin: Try to explain what you want to do
13:08:37 <TheOrientalBegin> I want to simplify my function prototype which have 2 times ([Int, Int, Int, Int, Int], [Int, Int])
13:16:07 <slack1256> Are you sure it is not ` functionPrototype :: ( (Int, Int, Int, Int, Int), (Int, Int) )` ?
13:17:47 <slack1256> On haskell, List of specific sizes are not reflected at type-level on the base libraries. So `[Int]` is the type of list of Ints, but `[Int, Int]` doesn't exist on base.
13:19:04 <slack1256> Tuples on the other hand, specify how many arguments they have. So you could set all the type variables to the same type and get fixed size list without the functions present on Data.List
13:27:47 <delYsid> Wow, ViewPatterns is really cool! "| ("go", map BS.pack . words -> args) <- splitAt 2 input -> do"
13:45:32 <slack1256> delYsid: you can do the same with guard patterns
13:46:08 <slack1256> although not the consisely
13:48:01 <dmwit> `'g':'o':rest -> let args = map BS.pack (words rest) in do`
13:48:15 <delYsid> slack1256: I know, but matching *and* binding in the same line is pretty cool.
13:48:17 <dmwit> what primitive technology the ancients were forced to use
13:49:00 <slack1256> fun input | ("go", args) <- over _2 (map BS.pack . words) $ splitAt 2 input = ...
13:52:17 <dmwit> I wonder how hard it would be to make an extension that let you write `"go" ++ xs` as a pattern (...and wasn't completely specific to (++)).
13:52:55 <delYsid> <> please :-)
13:53:17 <delYsid> I am going to get stoned for this quote, but: Haskell is the Perl I ealways wanted to have!
13:53:19 <geekosaur> NPlusKPattersns, list style. sounds like a trainwreck looking for an excuse to happen in some unsuspecting persons code
13:54:02 <geekosaur> not to say, how you define operators afterward (guess that's still doable in prefix form, until you decide you want this syntax to work for that too)
13:56:48 * dmwit ponders `"go" ++ ys@(x:xs)` (seems okay) and `map (x:) ["1","2"]` (should `x` be bound to the character preceding `"1"` or the character preceding `"2"`?)
13:57:28 <dmwit> > let f [x:"1", x:"2"] = x in f ["21", "32"]
13:57:30 <lambdabot>  error:
13:57:30 <lambdabot>      • Conflicting definitions for ‘x’
13:57:30 <lambdabot>        Bound at: <interactive>:1:8
13:58:04 <dmwit> I guess that's as sensible a behavior as any for what `map (x:) ["1","2"]` should mean: just error out.
13:59:19 <dmwit> It's probably too niche. Even `xs ++ "go"` seems like it wouldn't really make sense.
14:00:47 <dmwit> (Again it seems possible to just report an error -- saying, e.g., that you can't tell which of the two cases for ++ to use when the value is held abstract like that -- but then maybe so many things would be an error that it did essentially end up being specific to "go" ++ xs.)
14:01:43 <dmwit> geekosaur: Surface syntax is certainly a question, but it seems to me not a super hard one.
14:02:43 <dmwit> I definitely wouldn't want it to be "NPlusKPatterns for lists" -- I'd definitely want it to work on any type, using some sort of symbolic execution kind of idea to turn your function application into a pattern.
14:06:13 <dmwit> [x] ++ if x then [True,True] else [False] -- hmm....
14:07:34 <dmwit> Ah, sorry. I meant [x@True] ++ if x then [True,True] else [False]
14:27:37 * hackage eventstore 1.2.3 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-1.2.3 (YorickLaupa)
15:02:35 <delYsid> Hmm, is there a version of try that works on MonadIO?
15:02:56 <slack1256> liftIO $ try <stuff> ?
15:03:04 <delYsid> like try :: MonadIO m => m a -> m (Either e a)
15:03:10 <slack1256> There is also MonadCatch 
15:03:52 <delYsid> liftIO (try foo) returns an IO, which means I can't get back to my monad in the case statement...
15:04:11 <delYsid> or am I missing something?
15:04:43 <glguy> No, there's not a try that works in MonadIO
15:04:51 <delYsid> gah
15:04:58 <delYsid> there goes a plan.
15:05:36 <delYsid> so better abandon the whole exception thing and go back to Either
15:05:45 <delYsid> which is probably better anyway
15:05:49 <glguy> or write a version of try that works with your particular monad instance
15:06:00 <glguy> Either isn't generally a good replacement for exceptions
15:07:01 <delYsid> glguy: How you I write my own version of try?
15:07:14 <delYsid> s/you/would/
15:07:15 <glguy> depends on what type you're using
15:07:37 <delYsid> InputT MyState IO
15:07:58 <glguy> What defines InputT?
15:07:59 <delYsid> er, InputT (StateT MyState IO)
15:08:04 <delYsid> haskline
15:08:46 <glguy> Oh, that one might be a challenge. I seem to remember haskeline doesn't expose enough of InputT for you to write your own operations
15:09:35 <delYsid> so, back to m (Either e a) then?
15:09:45 <glguy> have you seen this module? http://hackage.haskell.org/package/haskeline-0.7.5.0/docs/System-Console-Haskeline-MonadException.html
15:10:06 <delYsid> thats going away in 0.8.0
15:10:16 <delYsid> (luckily!)
15:10:52 <glguy> Why is that lucky?
15:10:57 <delYsid> Its being replaced with real MonadException.
15:11:14 <glguy> So can you use that, then?
15:11:16 <delYsid> glguy: Because it prevented stacking InputT with InterpreterT from hint.
15:12:09 <delYsid> glguy: hmm, maybe, but then I will have a dependency on master till 0.8.0 gets out.
15:13:56 <delYsid> But come to think of it, the exception is the problem, I'll move the code that throws out to the caller, thats likely more clean anyway.
16:08:45 <lambdaman> Does anyone know the magic incantation to instantiate a stack template from the yesodweb/yesod-scaffold github repo?  The stack tool seems to have the ability to refer to external templates in github with the "new" command.  I can't seem to get this to work however.
16:15:57 <MarcelineVQ> lambdaman: you've already generated the .hsfiles files?
16:19:39 <MarcelineVQ> stack can refer to remote template files (it claims) but I don't think this repo actually has any, it's a repo for generating them afaict
16:20:03 <lambdaman> MarcelineVQ I guess I missed that step.  
16:20:45 <lambdaman> OK, I guess I have to install the package first, then refer to the scaffolding templates locally somehow.  
16:21:14 <lambdaman> I just saw the docs on accessing templates from repos and assumed that this was one such consumable repo.
16:21:59 <lambdaman> I'll grab the repo and see if it builds the templates I want somehow.
16:22:00 <MarcelineVQ> doesn't seem to be, but this one is https://github.com/commercialhaskell/stack-templates and some of its contents are generated by the repo you mentioned
16:23:33 <lambdaman> Right.  I wanted the postgres-fay template, which isn't in that stack-templates repo
16:27:56 <AndreasK> Is there already a function that filters one last based on a predicate and another list? Something like filterWith :: (b -> Bool) -> [a] -> [b] -> [a]
16:28:16 <MarcelineVQ> that's interesting, I wonder why fay is the only one missing.
16:28:58 <MarcelineVQ> "https://github.com/yesodweb/yesod-scaffold/commit/1cfed56aae6c76c9650578731295ed50bd358ecc#diff-63e7d2cbf23880a9c902c91fa34f6043" how informative <_< hehe
16:29:41 <lambdaman> Ha.  Nice blame.  
16:30:08 <lambdaman> Maybe Fay is no longer flavour of the month. 
16:30:08 <MarcelineVQ> well anyway, enable fay there and then build I suppose. you can find out what commands are available in that file
16:30:28 <lambdaman> Indeed.  Thanks.
16:30:29 <MarcelineVQ> I've never seen this stuff before so it's all guesses
16:30:31 <AndreasK> Reminds me of NewClass newClass = new NewClass();
16:30:58 <MarcelineVQ> mongo being missing has an explanation in its commit at least
16:33:18 <MarcelineVQ> AndreasK: how do you imagine that function working?
16:36:15 <MarcelineVQ> iow what does it do, the description and signature are unclear :>
16:36:18 <AndreasK> MarcelineVQ: Like that.  https://www.irccloud.com/pastebin/XY65c3No/
16:37:59 <MarcelineVQ> ah it zips
16:39:11 <AndreasK> I guess catMaybes . zipWith (\a b -> if f b then Just a else Nothing) would be one way.
16:39:33 <MarcelineVQ> sure or concat and [a] else []
16:46:03 <AndreasK> They both don't fuse away it seems :/
16:49:04 <hpc> that looks like filter
16:49:41 <hpc> zip the lists, then filter (f . snd), then map (finagle into your desired structure)
16:49:43 <MarcelineVQ> yus, it's \f xs ys -> filter (f . snd) $ zip xs ys
16:49:52 <MarcelineVQ> ehe
16:50:25 <hpc> oh wow, i am so good at scrollback
16:51:00 <hpc> i just saw that definition and fusing, and zoomed in on how to make it fuse
17:00:45 <MarcelineVQ> wanted to make it pretty with ParallelListComp but it turns out that [x | x <- xs | y <- ys, f y] does not do what I thought it would :> though it does do what it should.
17:01:54 <AndreasK> MarcelineVQ: Looking at the core you wan't be able to beat  "map fst . filter (f . snd) $ zip xs ys" 
17:02:56 <AndreasK> Which was my first thought to use, but for some reason I assumed it would come out worse.
19:02:30 <zuserm> Hackage is down :(
19:02:47 * slack1256 heart rate goes to 90
19:05:27 <Welkin> only 90?
19:05:39 <Welkin> what is your resting heartrate? 35?
19:05:48 <slack1256> 60
19:05:54 <Welkin> buuuuuull
19:06:22 <slack1256> no really, I also have really low blood pressure
19:06:39 <Welkin> are you a giant?
19:06:54 <slack1256> No, I am actually very short
19:07:03 <slack1256> but I swim a lot, so it really good
19:07:24 <Welkin> low is not good
19:07:27 <Welkin> just as bad as high
19:07:48 <Welkin> makes you lethargic and weak
19:08:37 <slack1256> I mean I get dizzy when leaving a chair too quickly, but once I start walking everything is fine
19:08:55 <slack1256> It is just when I am sit too much time on the pc that gets really low
19:44:54 <Shockk> hackage giving me a 503 first byte timeout error :(
19:45:50 <Welkin> you broked the internet
19:46:08 <Shockk> oh now it's a 504 
19:46:13 <Shockk> I did broke it
19:53:32 <Shockk> well er, since hackage is down, does anyone know what the function from Control.Monad.State is that gives me both the return value and the final state?
19:53:40 <Shockk> I think it returns both in a tuple?
19:53:47 <adamCS> runState
19:53:55 <adamCS> or runStateT
19:53:55 <Shockk> ahh great thanks
19:54:05 <Shockk> that's exactly what I need, thanks
19:54:10 <adamCS> np
19:54:52 <Shockk> :t runStateT
19:54:53 <lambdabot> StateT s m a -> s -> m (a, s)
19:54:58 <Shockk> just checking the order
19:55:20 <adamCS> yep.  It's the wrong order.  If you remember that, you'll never need to check again...
19:55:26 <Shockk> lol
19:57:28 <Welkin> you don't nee hackage to look up docs
19:57:29 <Welkin> o.o
19:57:35 <Welkin> you have them on your computer already
19:57:43 <Welkin> and you can egenrate them for any packages you installed
19:58:06 <Welkin> if you installed with haskell platform you definitely have all the docs for everything in base
19:58:12 <Welkin> look in your ghc directory
19:58:20 * slack1256 is selling hackage docs at 5$ the megabyte
19:58:28 <Shockk> hmm where would that be if I I installed with stack?
19:58:28 <slack1256> the source has run out boys!
19:58:36 <Shockk> slack1256: I'll take 50!
19:58:37 <Welkin> no idea
19:58:40 <Welkin> I don't use stack
19:59:55 <slack1256> I think stack has a show documentation command
20:00:14 <Welkin> does it have a remove-stack command?
20:00:55 <slack1256> heh, maybe if you build a haskell program that rm -rf stack
20:01:13 <Shockk> is stack bad? (probably asking a controversial question)
20:01:20 <Welkin> yes
20:02:09 <Shockk> how so?
20:02:18 <Welkin> in your cabal config you can set up hackage doc generation locally
20:02:22 <Welkin> I did that at one point
20:03:08 <adamCS> Sigh.  Obligatory balanced statement: "stack is not bad.  stack and cabal (the tool) do things differently.  stack can be easier.  It used to be much easier.  But cabal has improved.  So now it's a matter of taste. And people have *very* strong feelings about their taste." 
20:03:31 <Welkin> Shockk: without getting into the politics surrounding it, it's obsolete and convoluted an goes against the stanard way of doing things and the official build tool cabal
20:04:03 <Welkin> it really has less to do with the tool and more to do with the politics around it
20:04:10 <Welkin> but the tool is bad too, yeah
20:04:27 <adamCS> But, that being said, I basically agree with Welkin, though I'm less clear on why it's obsolete.  But cabal just seems easier and better now.  
20:04:33 <adamCS> Now try asking about Nix!
20:05:07 <slack1256> you have to use cabal to use nix though
20:05:07 <geekosaur> that's more or less why it's obsolete. cabal 1.x was quite painful at times, stack came about to address that, then cabal 2.x fixed 1.x's flaws
20:05:22 <geekosaur> and is generally more flexible in how it does so
20:06:01 <adamCS> I guess I am sympathetic to the idea that curated snapshots might be useful.  though I suppose we could keep the snapshots and drop the stack tool.
20:06:28 <geekosaur> whereas stack is more or less an internal corporate dev tool released publicly, and tends to enforce the preferred dev workflows of its creators
20:07:34 <slack1256> Are the nixpkgs ghc sets based on stackage or are their own thing?
20:08:26 <Cale> They're based on hackage, aren't they?
20:08:34 <Welkin> I don't see why they would be based on stackage
20:08:39 <Cale> https://raw.githubusercontent.com/NixOS/nixpkgs/master/pkgs/development/haskell-modules/hackage-packages.nix
20:09:48 <slack1256> So they don't check consistency, even so it works fine
20:09:55 <Welkin> ?
20:09:59 <Welkin> why would they not be tested?
20:10:06 <Welkin> I don't get your reasoning
20:10:09 <Shockk> on a less controversial topic, now I finally have some resemblance of proper semantic analysis
20:10:11 <Shockk> https://gist.github.com/shockkolate/18f2ef732a309ece1a45148aa4208cf2
20:10:37 <Shockk> that's the analysis result from `bool = <>  false = <>:bool  true = <>:bool`
20:10:43 <Welkin> cabal solves the package constraints on demand
20:11:00 <adamCS> A Core question:  I have a bit of core that seems to be calling a function that is not inlined.  So it's just there by name.  This happens when I label it {-# INLINABLE #-} or {-# INLINE #-}.  Very similar functions are being inlined.  Is there an obvious place to look (in the source or the core),  at the call site or in the function for why that might be?  
20:11:38 <slack1256> Welkin: I thought that was just hackage witht he latest version available for each package, so maybe packages that haven't been updated in a while would not build with it.
20:11:42 <Welkin> ghc ignores inline pragmas right?
20:11:47 <Welkin> it just does whatever it wants
20:12:08 <adamCS> I thought it was a very strong suggestion but not an obligation.  
20:12:12 <geekosaur> ^
20:12:19 <adamCS> And usually discouraged over inlinable
20:12:52 <geekosaur> it'll ignore something that it can't sanely inline, but if it just thinks it's not wirth inlining INLINE will tell it to do so anyway
20:12:53 <adamCS> but the question remains.  Similar size functions are being inlined from the same module.  So how might I figure out why this one isn't?
20:13:07 <geekosaur> that said, these days it's pretty good about recognizing when inlining is worthwhile
20:13:20 <adamCS> I'm not doubting GHC.
20:13:22 <Welkin> which brings the question to mind: has anyone written assembly embedded in haskell source?
20:13:48 <geekosaur> not so far as I'm aware, although it's probably possible via eg. inline-c and __asm__
20:13:56 <adamCS> I'm just trying to puzzle out a performance difference and that night be related.  And it's preventing me from seeing the core for that function which also might be helpful...
20:13:59 <Cale> Look at harpy
20:14:08 <geekosaur> you might need to know rather more about how STG works on the platform than is healthy
20:14:21 <Welkin> Cale: only x86 :(
20:15:38 <geekosaur> adamCS, if it's not showing you core, something trickier might be going on
20:16:01 <adamCS> geekosaur: what do you mean?  
20:16:47 <Cale> Welkin: I'm sure it can only be so hard to adapt it to ARM
20:16:54 <geekosaur> every so often you get e.g. interaction with RULES that rewrite the call away (possibly incorrectly, because it's someone else's unrelated fusion rules getting confused or something)
20:19:34 <adamCS> geekosaur: I don't think it's that.  In the core I see the function called.  It's wrapped into another name with a couple of parameters fixed.  Then that wrapper is called.  But for many other similar functions in the module, the actual code appears in the core for my executable, not the just the name.
20:25:19 <Shockk> quick question before I go and rewrite lots of my code; can I use the `use` lens for Reader as well as State, or is there a separate lens that I should use for Reader? 
20:25:32 <c_wraith> view works for reader
20:25:34 <c_wraith> :t view
20:25:35 <lambdabot> MonadReader s m => Getting a s a -> m a
20:25:46 <Shockk> :t use
20:25:47 <lambdabot> MonadState s m => Getting a s a -> m a
20:25:49 <Shockk> ahh great
20:25:54 <Shockk> thanks
20:28:19 <slack1256> I think lens verbs (use, view, views, preview, over, set) should be highlighted over their operator counterparts
20:29:29 <Shockk> :t preview
20:29:30 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
20:30:00 <Shockk> I'm confused at what that would do
20:30:07 <c_wraith> If that Getting (First a) thing reads awkwardly, just think of it as works for things that may not have a target
20:30:26 <Shockk> oh so it potentially views something?
20:30:26 <c_wraith> It's the same as (^?)
20:30:47 <glguy> (Except you can't use ^? with Reader)
20:30:49 <c_wraith> except with a more general type
20:31:22 <c_wraith> > preview (ix 3) []
20:31:24 <lambdabot>  Nothing
20:31:28 <c_wraith> > preview (ix 3) [1..5]
20:31:30 <lambdabot>  Just 4
20:31:39 <Shockk> ah that's cool
20:42:13 * hackage shh 0.3.1.0 - Simple shell scripting from Haskell  https://hackage.haskell.org/package/shh-0.3.1.0 (lukec)
20:54:25 <Axman6> "Given a thing which can get the first a, give it to me"
20:56:32 <slack1256> "if you don't find even the first one, return Nothing"
21:15:31 <statusbot> Status update: Hackage server appears to be under heavy load, investigating. -- http://status.haskell.org/pages/incident/537c07b0cf1fad5830000093/5ca584ccc0b3f91dfb7917e0
21:16:13 <Welkin> ddos?
21:16:43 <Welkin> or a runaway process in a neghboring VM
21:16:50 <Welkin> it should run on dedicated hardware
21:21:02 <jle`> ah, was just about to check
21:21:21 <jle`> guess it's time to call it a night
22:24:23 <delYsid> Is hackage down?
22:25:16 <statusbot> Status update: Issue appears to be related to block storage access. Continuing to investigate. -- http://status.haskell.org/pages/incident/537c07b0cf1fad5830000093/5ca584ccc0b3f91dfb7917e0
23:00:59 <akegalj> I am not sure is it known yet - but hackage seems to be down (nginx - 502 - bad gateway)
23:01:03 <suzu> it's known
23:01:10 <suzu> statusbot
23:01:13 <suzu> hackage down
23:01:20 <suzu> Is hackage down
23:01:23 <suzu> Is hackage down?
23:01:29 <suzu> hm
23:01:51 <suzu> well,
23:01:52 <suzu> https://status.haskell.org/
23:06:53 <geekosaur> yeh, discussion in #haskell-infrastructure, problem with virtual block storage at the hosting provider. hopefully shouldn't be any lost data, but it can't be accessed right now
23:07:32 <geekosaur> I don't thnk it was actually respinding to the earlier question based on timing; statusbot reports when status.haskell.org gets a post
23:14:12 <juhp> Can someone recommend a mirror?
23:16:27 <juhp> hackage mirror
23:26:15 <geekosaur> stackage uses a hackage mirror in EBS, but I don't recall details
23:48:21 <abaumann> https://hackage.haskell.org/ reporting 502 gateway error.. anything serious?
23:52:20 <yushyin> abaumann: https://status.haskell.org/
23:53:52 <abaumann> thanks.
23:54:08 <abaumann> should have thought about that URL myself, sorry. :-)
