00:04:24 <kadoban> I think traversable in general is pretty understandable. Some of the instances on tuples can be initially unintuitive
00:05:10 <kadoban> > length (1, 2) -- for example
00:05:13 <lambdabot>  1
00:22:23 <yitz> Heh. Solved another Exercism problem using Haskell. Maybe I'll actually figure out this language
00:35:07 <kadoban> I did quite a few exercism problems quite a while back in haskell, IIRC it was quite educational.
00:45:50 <thoradam> What is going on when something compiles fine with 8.6.4 but with 8.4.3 it fails with `Module ‘Bla’ does not export ‘field’` where `field` is a record field?
00:59:27 <DigitalKiwi> i believe in you yitz
01:09:14 <c50a326> is there a stack command to show my locally installed ghc's?
01:09:30 <c50a326> I mean, the build plan thingies... the lts's... you know what I mean
01:10:14 <c50a326> ah, snapshots I guess
01:10:17 <c50a326> stack ls snapshots
01:12:16 <pavonia> thoradam: Is that a custom type or one defined in one of the standard libraries?
01:25:47 * hackage acme-this 0.1.0.0 - import This  https://hackage.haskell.org/package/acme-this-0.1.0.0 (TobiasDammers)
01:26:58 <merijn> tdammers: Pfft, no docs uploaded and no github link...how can I look what it's doing like this? >.>
01:27:12 <tdammers> merijn: pun intended?
01:27:24 <merijn> Always, even if I didn't
01:28:13 <Ariakenom> Python's built-in @import this@ feature, ported to Haskell.
01:28:17 <Ariakenom> very good
01:34:33 <DigitalKiwi> why's it need template haskell
01:35:01 <Ariakenom> Usage: just import 'This' and observe the magic.
01:37:18 <tdammers> DigitalKiwi: because that's the easiest way to run IO actions at compile time
01:39:08 <DigitalKiwi> oh
01:40:21 <tdammers> Haskell doesn't really allow for effectful imports, this is the closest I could come up with
01:40:45 <tdammers> (and in fact, it's still pretty terrible, though not as bad as proper effectful imports)
01:41:50 <Ariakenom> this <- IO (Module _)
01:42:09 <Ariakenom> eh
01:42:16 <Ariakenom> this :: IO (Module _)
01:42:34 <Ariakenom> lgtm
01:47:35 <utonx[m]> hey guys, do I need to close handle after opening it with either openFile or openBinaryFile or is it closed automatically after it gets out of scope?
01:48:07 <Ariakenom> utonx[m]: I'd recommend withFile or similar
01:48:27 <tdammers> it gets closed automatically if and when the garbage collector picks it up, but that's not guaranteed to happen. second the withFile recommendation
01:50:02 <utonx[m]> but what if I need to do 2 operations on it? Like reading its contents and checking the initial file length? Invoking length on binary file contents doesn't seem like a good idea, I'd much rather use hFileSize unless I'm missing something
01:52:48 <merijn> tdammers: What? I'm pretty sure openFile doesn't close on GC
01:52:56 <tdammers> merijn: it doesn't?
01:53:09 <Ariakenom> utonx[m]: sounds reasonable. but do you think this is in conflict with using withFile?
01:53:14 <tdammers> merijn: I've always operated under the assumption that it did. Let me check.
01:53:55 <merijn> tdammers: It looks like it kinda maybe, sorta, tries too
01:54:22 <merijn> utonx[m]: withFile just gives you a file handle you can do whatever with, though
01:54:30 <tdammers> merijn: https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:Handle
01:54:44 <tdammers> "GHC note: a Handle will be automatically closed when the garbage collector detects that it has become unreferenced by the program. However, relying on this behaviour is not generally recommended: the garbage collector is unpredictable."
01:54:56 <tdammers> so basically what I said
01:55:04 <utonx[m]> Ariakenom: I mean, I could just abstract it into a function and then use it that way but I feel like it might obscure the code a bit. On the other hand, this seems like a correct way to do it
01:55:14 <tdammers> it gets closed if and when the garbage collector picks it up, but you can't rely on that ever happening
01:55:52 <utonx[m]> Alright, thanks for help guys, gonna do it with withFile
01:56:00 <Ariakenom> utonx[m]: I don't understand sry
01:56:06 <Ariakenom> sounds good
01:56:50 <merijn> utonx[m]: I mean, you just do "withFile ReadMode myFilePath $ \hnd -> do { hFileSize hnd; ...whatever else you wanna do... }"
01:57:32 <utonx[m]> oh right, I completely forgot about lambdas
01:57:40 <Ariakenom> :D
01:58:17 <merijn> utonx[m]: The general use-case of withX brackets is to invoke them with a lambda (which nicely gives you an indented block when using do too)
01:59:06 <tdammers> .oO(introducing an indented block is sometimes the only reason I use do notation)
01:59:54 <thoradam> pavonia: Custom type
01:59:56 <utonx[m]> yeah that looks cleaner now
01:59:59 <utonx[m]> thanks again
02:03:21 <pavonia> thoradam: No idea then. Perhaps paste a small sample module
02:31:17 * hackage servant-quickcheck 0.0.7.4 - QuickCheck entire APIs  https://hackage.haskell.org/package/servant-quickcheck-0.0.7.4 (phadej)
03:51:18 <royal_screwup21> anyone know stuff about functionals? :(  I'm trying to understand the functional defined here (see "it easy to verify...") https://imgur.com/a/9SUEOt7 
03:51:26 <royal_screwup21> if s x = 0, it makes sense that the output state is s, same as input state 
03:51:31 <royal_screwup21> but when s x!=0, why is it defined the way it is??
03:57:01 <lyxia> after one iteration you run the loop again
03:57:45 <lyxia> so the denotation g of this while loop is    g s = g ([[skip]] s)    if  x /= 0   where [[skip]] is the denotation of skip
03:57:59 <lyxia> well it must satisfy this equation
03:58:23 <lyxia> that's reexpressed as a fixed point equation
03:58:29 <lyxia> g s = F g s
03:58:59 <lyxia> F g s = g ([[skip]] s)    if x /= 0
04:05:27 <contrun[m]> How can I override the implementation of Show for Tree Char where `data Tree a = Empty | Branch a (Tree a) (Tree a) deriving (Show, Eq)`. I don't want to discard deriving show for Tree a.
04:06:31 <merijn> contrun[m]: You can't and you really shouldn't even if you could
04:06:47 <merijn> contrun[m]: What do you want to override it for?
04:07:55 <lavalike> isn't there an extension that enables that
04:08:35 <merijn> lavalike: That enables what?
04:08:41 <lavalike> overlapping instances?
04:09:00 <Solonarv> you can't "override" a derived instance
04:09:08 <lavalike> ah
04:09:14 <Solonarv> what you can do is simply not derive it and hand-write the instance
04:09:17 <merijn> lavalike: That only works if you manuall write them
04:09:24 <lavalike> didn't know
04:09:41 <merijn> What you *should* do, since this is almost certainly about pretty printing is use a prettyprinter, instead of Show
04:10:00 <Solonarv> but Show instances should (when possible) produce valid Haskell that evaluates to the same value
04:10:05 <merijn> Repeat after me, the golden mantra of "Show is not for pretty printing output"
04:10:10 <Solonarv> which the derived Show instance already does!
04:13:42 <lavalike> Show is some times for pretty printing output B)
04:14:34 * Solonarv screams incoherently
04:14:51 <Solonarv> I guess you can layer something like pretty-show on top of it
04:15:16 <Solonarv> i.e. parse the output of 'show' into some kind of generic tree thingy and pretty-print that
04:18:57 <contrun[m]> merijn: I am writing a pretty printer of  a binary tree myself.
04:19:43 <Taneb> contrun[m]: you don't have to make it the Show instance, though
04:19:53 <Taneb> You can just have a function that isn't Show
04:20:30 <contrun[m]> Taneb: Yeah. I will write a new function. Thanks.
04:21:47 * hackage Monadoro 0.1.1.1 - A minimalistic CLI Pomodoro timer, based on a library of the same purpose.  https://hackage.haskell.org/package/Monadoro-0.1.1.1 (patryk_kocielnik)
04:23:47 <royal_screwup21> lyxia ah thanks for explanation :)
04:25:12 <royal_screwup21> lyxia if the body of while loop had x = x -1 (instead of skip), would this be correct: (F g) s = g s[x -> x = -1] 
04:25:25 <royal_screwup21> my feeling is it would be correct since the state changes 
04:25:50 <royal_screwup21> the fixed point is g, the while loop, and we run it against a different state where x is decremented
04:26:11 <royal_screwup21> x -> x-1*
04:27:21 <lyxia> royal_screwup21:that is right
04:33:24 <royal_screwup21> I'm trying to do 4.2 and figure out the fixed points. https://imgur.com/a/yOiZi6v  So, functional F is defined like so: (F g) s = s if s x == 0 or gs[x -> x-1] if x!=0...okay now to determine the fixed points...the first one is, g1 s = undefined. That's definitely NOT a fixed point, because when x = 0, it gives undefined when it should be s[x=0]. A
04:33:24 <royal_screwup21> m I  on the right track? :)  
04:39:24 <Uniaika> /21
04:39:28 <Uniaika> (woops)
04:50:16 <royal_screwup21> anyone read the book "semantic with applications" :)  I'm trying to solve  a question about fixed poitns from that book, posted my question here https://cs.stackexchange.com/questions/107098/trying-to-determine-fixed-points I'd love a pointer or two in the right direction :)
04:50:59 <fendor_> hackage down again?
04:51:16 <fendor_> no, just a bad request
05:25:30 <raek> royal_screwup21: a long time ago, but maybe I can point you to this: https://en.wikibooks.org/wiki/Haskell/Denotational_semantics#Partial_Functions_and_the_Semantic_Approximation_Order
05:30:06 <raek> I had a hard time grasping exactly how the mathematics worked in detail, but wasn't the idea that you had a sequence of partial functions, each one defined for one more argument that the previous ones
05:30:33 <raek> so maybe the excercise is to find which of the proposed partial functions that can be part of that sequence
05:32:51 <raek> hmm, but it looks like you already figured out that...
05:33:28 <royal_screwup21> raek yeah haha I'm just really annoyed there are no solutions in the book to verify my understanding 
05:35:23 <Sh4rPEYE> Hello
05:37:31 <Sh4rPEYE> (is there anybody here? Not sure if the messages get thru my irc client)
05:37:46 <aldum> we see you
05:38:51 <Sh4rPEYE> Oh, great!
05:38:52 <raek> royal_screwup21: hmm. or maybe it was like this: the partial function that the stamement "means" is the least fixed point of F (let's call that partial function g_lfp).
05:39:47 <raek> it is the most interesting fixed point to F beacause it is only defined for the arguments which the program actually terminates for (n >= 0). at least intuitively.
05:41:21 <raek> other functions (g_1 to g_5) may also be fixed points, but then they are supposed to "respect" g_lfp for all inputs which g_lfp is defined for, but may be defined for additional inputs
05:42:35 <raek> so to me it looks like g_lfp == g_2
05:45:35 <royal_screwup21> raek hmm I don't think g1 is a fixed point
05:45:54 <raek> I think so too
05:46:19 <jacker[m]> Have you implemented any protocol like usb, Bluetooth or developed any item compatible to such protocols?
05:46:41 <raek> g3, g3 and g4 would be fixed points because the all assign x to 0 when x >= 0.
05:46:55 <royal_screwup21> raek yup! Thats' my thinking too
05:47:33 <royal_screwup21> raek g5 I don't think so, since it doesn't necessarily capture  x = 0 
05:49:05 <royal_screwup21> raek ok I think I'm sort of seeing why fixed points are sorta useful in analyzing loops...it helps to enumerate the commonality in all loops. Like when the loop breaks,  all valid fixpoints have s x = 0
05:51:09 <royal_screwup21> not sure I understand g_lfp == g2 though hmm
05:51:42 <royal_screwup21> why*
05:53:15 <raek> my idea was that intuitively the code would loop forever when x < 0, break when x == 0, and get one step closed when x > 0
05:55:00 <raek> the equation for g2 captures what the loop code achieves after running all iterations: if x < 0 at the start, it never terminates, if x > 0 then the new state is the incoming state but with x assigned to 0
05:55:53 <raek> g3 could not be the "real" meaning, because it says that the loop would be just a no-op that terminates and leaves all variables unchanged
05:55:59 <royal_screwup21> raek right  but why would that make g2 the least fixed point?
05:57:44 <royal_screwup21> raek ah I see...
05:57:54 <royal_screwup21> not totally sure if undefined means it would never terminate 
05:58:39 <raek> this is where I don't grasp the mathematics, but the semantic equations are defined in such a way that the resuling state transition function is defined in terms of the least fixed point of F
05:58:47 <raek> ...I think
05:59:50 <lyxia> royal_screwup21: can you come over to #haskell-blah
06:00:38 <royal_screwup21> yup!
06:02:14 <Sh4rPEYE> I have some questions regarding optimizing Haskell performance. I asked a similar question on Reddit, but I think there's more that I don't understand and I don't want to spam it too much. I hope you won't mind if I ask here.
06:02:59 <Sh4rPEYE> I have a String (let's say enumerated from 0) and a sorted list of (start :: Int, length :: Int) pairs. I want to splice *length* dashes into the string, starting after the *start*-th letter, for every pair in the list, and return the resulting string. I'm currently walking through the string, mostly doing just x : (go rest), and only if I'm on the right index, replicate length '-' ++ x : (go rest).
06:04:25 <gonz_> This seems awfully reductive, but the base performance characteristics of `String` aren't great.
06:04:31 <Sh4rPEYE> I call the function a lot in my code (with different arguments). It gets progressively slower, 500+ call is almost ten-fold slower than the first one. I'm really unsure of the cause, but had narrowed it down to the "replicate".
06:05:02 <Sh4rPEYE> And becasue it gets slower and slower, I suspect some laziness funny business might be at play.
06:06:47 <Sh4rPEYE> (whole function here https://gist.github.com/Eugleo/d88608a4f93366afac5bbac6c1faca59)
06:06:51 <gonz_> Just to be sure; are you actually using `String` or did you mean to say `String` here as a placeholder for that type of thing? `Text` is what one usually would use for text manipulation.
06:08:17 <Sh4rPEYE> It's literally a String type. I figured I'm only traversing the whole string and building a new string in the meantime, both of which aren't particularly optimized in Text (AFAIK).
06:10:33 <merijn> Sh4rPEYE: There's map and concatMap in Data.Text
06:13:07 <Sh4rPEYE> I know about them. But map will be O(n) anyway and if you look at the gist, I'm actually building the result string one by one with (:) (and only sometimes using replicate and ++). Somewhere I read (:) is O(n) for Text as well, so I figured that Text might not be that good for my usecase.
06:13:26 <merijn> Sh4rPEYE: Anyway, obvious first question: Did you compile with -O2? Second obvious question: Did you profile it yet?
06:15:17 <Sh4rPEYE> I did neither; just starting out with real Haskell development (and development in general). Is that a flag I could pass to Stack build somehow?
06:15:48 <merijn> Sh4rPEYE: tbh I have no idea how to do things with Stack, but the GHC user guide has a pretty in-depth on how to profile code
06:15:52 <Sh4rPEYE> (sorry google throws only cpp flags at me)
06:16:11 <Sh4rPEYE> Ok, will look it up, thanks.
06:16:14 <merijn> Sh4rPEYE: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
06:16:35 <merijn> Sh4rPEYE: I'm *sure* stack has a way to rebuild stuff with profiling enabled, I just don't know what it is :)
06:17:04 <Bish> does IO not have a show because of not wanting to evaluate by accident?
06:17:57 <merijn> Bish: How would you "show" an IO action?
06:18:00 <Bish> why does putStrLn "hi" not throw an error that the value of that expression is IO ()
06:18:04 <merijn> Bish: What does that even mean?
06:18:09 <Bish> merijn: no clue, maybe if it's just "IO"
06:18:34 <merijn> Bish: You mean why does it not produce an error in ghci?
06:18:45 <Bish> just confused [putStrLn "hi"] does not evaluate and or show
06:19:01 <Bish> while (putStrLn "hi") does
06:19:09 <Taneb> IO is special-cased in GHCi
06:19:23 <Bish> Taneb: i figured it's something like that
06:19:24 <merijn> Bish: That's because ghci is a huge dirty hack that tries to auto-detect that case
06:19:33 <Bish> well okay cool :D
06:19:53 <Bish> but if i do main = putStrLn "hi", it does get evaluated aswell?
06:20:04 <[exa]> compared to other dirty hacks, ghci is extra tidy :]
06:21:02 <Bish> okay, im guessing because main ges always evaluated.. and if i have a do block there... it will evaluate that one
06:21:22 <tabaqui> I need to draw a diagram of my code for the rest of the team
06:21:47 <tabaqui> but application contains a lot of threads based on actor model
06:21:58 <tabaqui> and a huge logic based on arrowized frp
06:22:27 <tabaqui> what model language do you advice for this case?
06:22:28 <Taneb> tabaqui: sounds like you need to draw a diagram of your code so that anyone else could possibly understand it
06:23:05 <tabaqui> Taneb: sure
06:23:22 <tabaqui> But I never used one before
06:23:27 <tabaqui> uhm, UML, BPMN?
06:23:31 <[exa]> tabaqui: model language like "simple language I'll use to write pseudocode" or "modeling language I'll use to typeset the picture" ?
06:23:42 <tabaqui> second one
06:24:11 <[exa]> honestly I'd go with paper first, then latex+tikz if you want to make it shiny
06:25:09 <tabaqui> err, I mean some formal model language explaining the logic to non-functional programmers
06:28:13 <[exa]> I know but everytime I tried to work with the uml-style tools for anything more complex than db schemas, it failed for not being able to describe actual processes
06:28:44 <yushyin> true that
06:29:15 <[exa]> bpmn might be better, but it's only because it's closer to simple flowcharts
06:29:17 * hackage simple-units 1.0.0.0 - Simple arithmetic with SI units using type-checked dimensional analysis.  https://hackage.haskell.org/package/simple-units-1.0.0.0 (groscoe)
06:29:36 <[exa]> tabaqui: how many "tiny boxes" do you expect to have in the whole picture?
06:30:22 <tabaqui> A couple dozen
06:30:49 <tabaqui> maybe more
06:31:05 <[exa]> if these are related to code I'd perhaps just try to generate it into .dot and see what happens
06:32:03 <tabaqui> it is an interesting thought
06:42:57 <Sh4rPEYE> merijn: Found it, stack build --profile. I also tried to simply build with -ghc-options="-O2" (is that a letter O, as in Olof, right?), but nothing really changed. Is there any way to find out if my executable has been optimized by the -O option?
06:43:31 <merijn> Sh4rPEYE: Whether -O2 has effect depends a lot on the code, so hard to say.
06:43:47 <dmwit> Sh4rPEYE: For building Text values Char-by-Char, you might like to look at Data.Text.Lazy.Builder.
06:45:09 <Sh4rPEYE> dmwit: Another possibility would be concatMapping over the Text, when the function would sometimes return [char] and sometimes [T.replicate length '-' ++ [char]].
06:46:24 * dmwit nods agreeably
06:51:47 * hackage pipes-network-ws 0.1 - WebSockets support for pipes.  https://hackage.haskell.org/package/pipes-network-ws-0.1 (RenzoCarbonara)
06:57:22 <Sh4rPEYE> What is the Text's advantage over Strings? I know that Strings are just lists, so they have bad random access performance. So I guess Text is better from this pov. 
06:57:59 <[exa]> Sh4rPEYE: 1 character in String may have around 32 bytes
06:58:43 <merijn> 24, I think, but yeah...pretty awful
06:58:50 <merijn> Text also has much better cache behaviour
06:59:26 <[exa]> with some added uncertainity about the pointers in the character lists, it makes Strings very slow when processing any non-trivial amount of data
07:00:19 <[exa]> OTOH Strings are perfect if you have a sentence of undecidable length with undecidable character content.
07:01:24 * ski . o O ( indefinite/unknown )
07:01:41 <Sh4rPEYE> sorry for ignorance; how big it should be if there was no space wasted? 8B (I guess the "8" in UTF-8 must mean something)
07:01:50 <Sh4rPEYE> *?
07:03:29 <Sh4rPEYE> Ehm, is there a way to install hp2ps without using the Haskell Platform? I'm using stack (as per the recommendation of my teacher + various places on the net which talk badly of HP)
07:04:43 <[exa]> Sh4rPEYE: most used characters occupy 3 bytes or less if packed in utf8.
07:05:09 <Sh4rPEYE> Oh wow. 8x memory increase sounds horrendous.
07:05:57 <[exa]> ski: I didn't want to use 'undefined' :]
07:06:59 <[exa]> Sh4rPEYE: it doesn't really matter if the strings are tiny (if you're just working with a few filenames you won't feel any difference), but Text is a necessity for anything bigger.
07:08:03 <[exa]> and sometimes even Strings are good, e.g. when you can lazily generate the whole data before just printing them out
07:08:13 <merijn> [exa]: I would argue most characters in the western world average less than 2 bytes :p
07:09:48 <Sh4rPEYE> [exa]: Well, this is an evolutionary algo with thousands of generations, 100 organisms per generation and in each organism there is around 10 of these sequences. ( 0 _ 0 )
07:10:23 <[exa]> merijn: safety margin! :D  (also china)
07:10:48 <[exa]> Sh4rPEYE: what are you storing in the Text? isn't that some kind of DNA?
07:10:58 <merijn> Sh4rPEYE: tbh, for a genome in evolutionary algorithms don't you just want a fixed length vector or something?
07:11:06 <Sh4rPEYE> Pretty much.
07:11:08 <[exa]> like, if you don't have actual UTF8, you _want_ the arrays or vectors
07:11:18 <merijn> Sh4rPEYE: So why not use an actual vector, then?
07:11:36 <merijn> Sh4rPEYE: That's far less memory hungry than String and gets you O(1) random access too
07:12:54 <Sh4rPEYE> merijn: I'm aligning the sequences. I start with "AABBCC", say, end in each generation it becomes "AA-BB--CC" or "A----ABBC--C" or something. That's why I'm storing the gaps separately.
07:13:25 <Sh4rPEYE> (it's easy to change a list of (Int, Int))
07:14:09 <Sh4rPEYE> And at the end of each gen I need to splice the gaps in, in order to compare the sequences index-by-index.
07:15:48 <Sh4rPEYE> merijn: Do you recommend to store the original sequences as Vector Char and then only make the String/Text when splicing?
07:16:19 <merijn> Sh4rPEYE: Could work. I think you could do splicing via vectors reasonably well too, though
07:16:50 <Sh4rPEYE> I actually tried to work with Vectors, but it didn't get much faster (quite the contrary). Maybe I just put it in the wrong place/used it in the wrong way. For vectors, and kind of mutation (cons...) is slow, right?
07:17:10 <Sh4rPEYE> They aren't good "intermediaries", if I'm not mistaken.
07:19:00 <Solonarv> if you're using Text, you can use the stuff from Data.Text.Builder to efficiently build up a Text
07:19:35 <ski> [exa] : i didn't suggest that :)
07:19:37 <Solonarv> also: Text is internally packed UTF-16, which IIUC means 2 or 4 bytes per character
07:20:12 <merijn> Solonarv: True
07:34:12 <Sh4rPEYE> merijn: (If you've written something to me after my last message, could you please resend it? My IRC client crashed)
07:34:48 <merijn> Sh4rPEYE: Mutable vectors exists if you want mutation :)
07:35:03 <merijn> Sh4rPEYE: And there are also various builders for efficiently constructing vectors from (chunks of) other vectors
07:36:20 <Sh4rPEYE> merijn: This is part of a scoring function, so the IO Monad would propagate throughout the whole program. I'll take a look at the builders, though, thanks.
07:36:31 <merijn> Sh4rPEYE: You can have mutable vectors without IO :)
07:36:39 <Solonarv> you can mutate vectors in ST
07:36:47 <merijn> Sh4rPEYE: All you have to do is look into the wonderful world of ST :)
07:36:59 <Solonarv> you can even safely create a vector using mutation and freeze it into an immutable vector afterwards
07:37:03 <Sh4rPEYE> Oh. ST then?
07:37:11 <merijn> @hackage vector
07:37:11 <lambdabot> http://hackage.haskell.org/package/vector
07:37:30 <Solonarv> ST doesn't necessarily leak everywhere, because we have runST :: (forall s. ST s a) -> a
07:37:59 <Solonarv> or also create :: (forall s. ST s (MVector s a)) -> Vector a
07:38:16 <merijn> Sh4rPEYE: If you're not familiar with ST the "Lazy Functional State Threads" paper is a good explanation: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.45.3718&rep=rep1&type=pdf
07:40:04 <merijn> <3 ST
07:40:04 <tabaqui> ST(STT) still has limitations
07:40:23 <merijn> tabaqui: Sure, but for his problem it's almost certainly fine
07:41:16 <tabaqui> either you do all the jobs in single ST monad or you constatly freeze/thaw array between ST calls that means copying big memory block or you use unsafe operations
07:41:35 <merijn> tabaqui: In his case he doesn't really want to thaw, though
07:41:56 <merijn> tabaqui: For mutating genomes just creating a immutable vector by indexing an existing one is fine
07:42:36 <tabaqui> I am fine with ML so cannot answer :)
07:43:07 <tabaqui> but I agree that ST is great when it is applyable
07:43:17 * hackage simple-units 1.0.1.0 - Simple arithmetic with SI units using type-checked dimensional analysis.  https://hackage.haskell.org/package/simple-units-1.0.1.0 (groscoe)
07:43:21 <tabaqui> *applicable
07:44:24 <z0> a >== b is there a way to pattern "unmatch", so we can do something like this pattern guard: `| One <- a, *not* One  <- b = "a is one and b is not one"`
07:44:44 <z0> ups sorry nvm the "a >== b" at the start
07:44:45 <merijn> tabaqui: What I'd want to do with evolutionary algorithms (and I'm blindly guessing it'll work for Sh4rPEYE) is you write a function "mutate :: Genome -> Genome" where the return value is a longer/shorter fresh vector that you wanna initialise by copying parts of the original. Initialising with mutating logic makes the logic easier, but you skip the copy from thawing
07:45:01 <tabaqui> z0: underscore?
07:45:22 <Cale> z0: Just add another match before it which matches that case
07:45:29 <merijn> z0: Handle the both are one case first, then add a second catch all, which will only have 'b' != One
07:45:42 <z0> tabaqui: underscore would match even is b is One
07:45:42 <merijn> z0: Alternatively, you could use /= but that restricts you to Eq a
07:45:46 <z0> Cale: too many cases :p
07:46:27 <Cale> z0: If you *really* want, it would be possible to use ViewPatterns and perhaps PatternSynonyms to make something like that
07:46:36 <tabaqui> z0: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#multi-way-if-expressions
07:46:43 <tabaqui> Multi-way if-expressions
07:47:06 <Cale> Of course, you can also use a guard with /=
07:47:26 <Cale> | One <- a, b /= One 
07:47:51 <Cale> assuming that there is an Eq instance
07:48:16 <Sh4rPEYE> Oh man, I missed all the messages since "all you have to is look into...". 
07:48:48 <z0> Sh4rPEYE: I think this channel is logged
07:49:01 <Sh4rPEYE> merijn: Anyway, isn't it considered a bad practise to have 75% of a program in ST monad? 
07:49:14 <merijn> Sh4rPEYE: The point of ST is that you don't have to do that
07:49:20 <z0> Cale: can I do something like b /= Just _ ?
07:49:34 <tabaqui> z0: isNothing b
07:49:43 <merijn> Sh4rPEYE: My comment from after you disconnected: What I'd want to do with evolutionary algorithms (and I'm blindly guessing it'll work for Sh4rPEYE) is you write a function "mutate :: Genome -> Genome" where the return value is a longer/shorter fresh vector that you wanna initialise by copying parts of the original. Initialising with mutating logic makes the logic easier, but you skip the copy from 
07:49:49 <merijn> thawing
07:50:19 <Cale> z0: You could just do  Nothing <- b  ?
07:50:39 <merijn> Sh4rPEYE: vector specifically supports for "initialise immutable vector using mutating logic, then freeze it"
07:51:19 <z0> bad example. I'm not using Maybe, I'm using custom types
07:51:34 <tabaqui> custom predicate?
07:51:36 <Sh4rPEYE> I'll have to look into that. That would mean I can create it in mutate and then freeze it to escape from ST
07:51:51 <z0> tabaqui: i think that's the way ill do it
07:51:53 <z0> thanks
07:52:06 <merijn> Sh4rPEYE: Yes. Did you see my link to the ST paper?
07:52:39 <Sh4rPEYE> No but I'm sure I'll be able to look it up :) 
07:52:41 <Solonarv> direct link to relevant Vector docs: https://hackage.haskell.org/package/vector-0.12.0.2/docs/Data-Vector.html#v:create
07:52:49 <merijn> Sh4rPEYE: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.45.3718&rep=rep1&type=pdf
07:52:50 <AWizzArd> If you have used the NATS message queue – which lib did you work with?
07:53:56 <Sh4rPEYE> merijn and Solonarv: Thanks a lot.
07:55:47 * hackage hedgehog-generic 0.1 - GHC Generics automatically derived hedgehog generators  https://hackage.haskell.org/package/hedgehog-generic-0.1 (chessai)
07:57:00 <lyxia> oh, shiny new package
08:00:17 * hackage simple-units 1.0.1.1 - Simple arithmetic with SI units using type-checked dimensional analysis.  https://hackage.haskell.org/package/simple-units-1.0.1.1 (groscoe)
08:03:15 <Sh4rPEYE> Last question before I dive into rewriting the whole thing: given my use case ("AAB"→ "A-AB-" often, but also comparing different sequences with gaps included), is my data model appropriate? That is, a constant String (or Vector Char now) and a list of gaps which is mutated, and an occasional splicing operation when I need to compare the sequences.
08:05:08 <Sh4rPEYE> (that means mutate = mutateGaps and score = compareSeqs . splice)
08:10:32 <Ulrar> Mh, I have a binary compiled on my local machine, I've tried copying it to one of my servers for a quick test and it says "illegal instruction" when I start it. x86_64 in both cases, it's a bit strange. Is there an option to cabal build to make it generate a generic-er binary ?
08:18:14 <Sh4rPEYE> merijn: I forgot to thank you for the profiling tip. I didn't know something like that existed and it really is handy!
08:19:17 * hackage ngx-export 1.7.1 - Helper module for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-1.7.1 (lyokha)
08:19:54 <merijn> Sh4rPEYE: np :)
08:23:17 * hackage tidal 1.0.11 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-1.0.11 (AlexMcLean)
08:27:29 <Sh4rPEYE_> merijn: Any idea about the data model?
08:28:06 <Sh4rPEYE_> (btw, thanks to the profiling I found out the bottleneck is another, related function, but not this one. it seems to have the same problem, though)
08:32:08 <quicksil1er> I'd try Seq Char as my first step
08:32:22 <quicksil1er> it has a simple API and surprisingly good performance characteristics
08:32:48 <Cale> Good asymptotics, not as good constant factors
08:32:53 <quicksil1er> if you are replacing sequences with sequences of different lengths you're doing a load of splicing
08:33:01 <quicksil1er> which feels outside the sweet spot for vectors
08:33:08 <quicksil1er> but if you really care you just have to try it and see
08:33:15 <Cale> Is Text not working out?
08:33:38 <Cale> I suppose concatenation for Text isn't especially cheap
08:36:01 <zincy_> So a runtime system is essentially a library used by a compiler to add operations in the target language to the final executable
08:36:11 <zincy_> Then why is haskell regarded as having a heavy runtime
08:37:17 <merijn> Sh4rPEYE_: Don't really see an obvious alternative for the data model, but then I haven't really thought about it
08:37:26 <merijn> zincy_: Depends what you compare it too :)
08:37:52 <merijn> zincy_: The GHC runtime is something like 1-5MB or something? The C runtime of gcc is like a few kilobytes or something
08:38:03 <Cale> I don't know about "heavy", but it's 50k lines of C and C-- code
08:39:27 <zincy_> Is it because higher level languages need more "help" to get to a lower level?
08:39:42 <zincy_> Why is the C runtime much smaller?
08:39:52 <merijn> zincy_: Because it does basically nothing :p
08:40:08 <Cale> There's a generational garbage collector in there, n:m thread scheduler, and a bunch of other stuff...
08:40:17 <zincy_> What is the Haskell runtime doing? i guess garbage collection is a big one.
08:40:25 <Cale> https://gitlab.haskell.org/ghc/ghc/wikis/commentary/rts
08:41:00 <zincy_> I guess automatic memory management leads to much more extra code in the executable
08:41:11 <zincy_> And C doesn't support lightweight threads
08:42:24 <zincy_> Thanks for the article that clears it up!
08:43:18 <zincy_> So what are GHC primitives?
08:43:26 <zincy_> Are they types which can be marshalled to C?
08:43:41 <tdammers> "primitive" means that they're hard-wired into the compiler
08:43:42 <zincy_> I.e the types the runtime cares about
08:44:04 <tdammers> as opposed to defined in a library (even base)
08:44:17 <zincy_> So the Haskell compiler boils any ADT you define to GHC primitives
08:44:37 <tdammers> sort of, yes
08:44:46 <tdammers> though not all primitives are defined in the RTS
08:44:53 <tdammers> some are just hardcoded into the compiler itself
08:44:55 <Cale> Algebraic datatypes all basically have the same structure, so they don't need much special runtime support.
08:45:40 <zincy_> Ok so only some get marshalled into the RTS
08:46:13 <zincy_> is it a bit like if you make a compiler for x86 Assembly
08:46:17 * hackage ghc-boot-th 8.4.4 - Shared functionality between GHC and the @template-haskell@library  https://hackage.haskell.org/package/ghc-boot-th-8.4.4 (HerbertValerioRiedel)
08:46:20 <tdammers> "marshalled"? the RTS is essentially a library that gets linked into your binary
08:46:24 <zincy_> Jump and Add would be primitives
08:47:07 <zincy_> So the RTS is in the same language as the linked executable
08:47:13 <zincy_> I thought the RTS was in C
08:47:17 * hackage ghc 8.4.4, ghci 8.4.4, ghc-boot 8.4.4 (HerbertValerioRiedel)
08:47:27 <tdammers> uhm
08:47:29 <zincy_> Does Haskell source code end up as C
08:47:36 <zincy_> and then assembly
08:47:42 <Solonarv> the RTS is written (mostly) in C and C-- because that is massively easier to write than assembly
08:47:56 <Solonarv> that C/C-- is compiled to native code
08:48:17 <Solonarv> and no, GHC doesn't use C as an intermediate output - it knows how to generate native code directly
08:48:44 <zincy_> So GHC goes to assembly
08:48:56 <zincy_> and the RTS is C -> assembly
08:49:13 <zincy_> Ah right so the linking happens when both are assembly
08:49:18 <Ariakenom> (C,C--,assembly) -> assembly
08:49:19 <tdammers> machine code, actually
08:49:50 <zincy_> Machine code is just binary whereas assembly is human readable right
08:50:12 <Solonarv> the readability is... debatable, but yes
08:51:07 <zincy_> Why wasn't the RTS just written in Haskell? Because you want performance?
08:51:29 <Ariakenom> haskell needs gc, the RTS implements the gc
08:51:42 <Ariakenom> circular
08:51:48 <zincy_> hehe
08:51:51 <Solonarv> it's a chicken-and-egg problem, essentially
08:52:28 <tdammers> you need to bootstrap haskell somehow
08:52:28 <Solonarv> the solution is to have the chicken egg laid by something that isn't a chicken, to badly stretch a metaphor
08:53:05 <tdammers> a lot of work has gone into making the bootstrapping requirements (i.e. the "we cannot write this in haskell" parts) small, but it can never be zero
08:53:59 <zincy_> Just like the first Haskell compiler
08:54:15 <Ariakenom> well there's always bootstrapping tricks, right? work with some subset that doesn't need the parts you haven't written yet
08:55:05 <Solonarv> sure, that's what libraries that rest on top of the primitives do
08:55:12 <Solonarv> e.g. array, bytestring, vector, text
08:57:43 <zincy_> How is Text implemented
08:57:54 <zincy_> It isn't a linked list essentially is it?
08:58:41 <Ariakenom> zincy_, https://hackage.haskell.org/package/text-1.2.3.1/docs/src/Data.Text.Internal.html#Text
09:00:17 <Solonarv> lazy text is a lazy linked list of strict text
09:00:34 <zincy_> "Packed, unboxed, heap-resident arrays"
09:00:48 <zincy_> What do packed and unboxed mean?
09:01:13 <Solonarv> "packed" means the data is next to each other in memory, as close together as possible
09:01:38 <zincy_> So that implies we aren't dealing with a C style array here?
09:01:39 <Solonarv> "unboxed" means that there is no extra box (pointer) involved
09:03:01 <Solonarv> behind the scenes a Text roughly corresponds to this C struct: struct Text { int offset, int length, int bufLength, char* buf }
09:03:51 <Solonarv> oh, actually the bufLength field is only there when assertions are enabled
09:06:47 * hackage hlint 2.1.17 - Source code suggestions  https://hackage.haskell.org/package/hlint-2.1.17 (NeilMitchell)
09:09:02 <zincy_> Solonarv: So would length be the length of one element and bufLength is the length of the allocated memory?
09:09:04 <hpyCdr> I'd like to get the "optional" instance for free, how can I achieve that? https://pastebin.com/tZkqekUM
09:09:43 <Solonarv> zincy_: the 'length' field says how long this piece of Text is, the 'bufLength' field says how large the backing buffer is
09:09:58 <zincy_> What is a backing buffer?
09:10:13 <Solonarv> it's the buffer where the actual character data sits
09:10:35 <zincy_> So is a buffer just allocated memory?
09:10:38 <Solonarv> yes
09:10:44 <geekosaur> rather than constantly reallocating a Text to exactly match its contents, it remembers how big its allocation is vs. what's in use
09:10:46 <thoradam> pavonia: Here's a minimal example, https://gist.github.com/thoradam/f345895e88c50a21f64ed0a47bec3bf3, seems like it's triggered by DuplicateRecordFields
09:10:52 <Solonarv> this approach lets you have efficient slicing
09:11:05 <c_wraith> importantly, many different Text values can share the same buffer. 
09:11:05 <zincy_> Ok so it saves calls to malloc
09:11:12 <Solonarv> say you read a file into memory and you want to work with various substrings of it
09:11:14 <zincy_> you just grow the buffer when you need to
09:11:23 <c_wraith> can't grow it.
09:11:25 <Solonarv> no, there's no mutation involved there
09:11:31 <Solonarv> Text is immutable
09:11:42 <c_wraith> just use windows into it.
09:12:03 <Solonarv> but you can shove the entire big string into one big chunk of memory
09:12:05 <zincy_> So allocated a new buffer each time Text is placed in memory?
09:12:29 <Solonarv> and then instead of copying out individual pieces you just say "the text from X to Y in my big buffer"
09:13:03 <zincy_> Ok so you have one big buffer and you can have many of these Text structs in it
09:13:18 <Solonarv> when a new Text is created you get a fresh buffer
09:13:33 <Solonarv> but when you take a slice of an existing Text, the existing buffer is re-used
09:13:38 <hpyCdr> how can I instance a class for another class? I get 'constraint Foo is no smaller than the instance head' errors https://pastebin.com/tZkqekUM
09:14:23 <Solonarv> UndecidableInstances is the only way to make that compile, but I question what it's trying to accomplish in the first place
09:14:23 <pavonia> thoradam: I'm not sure what the exact semantics of that extension are supposed to be
09:14:48 <bdesham[m]> String is a linked list of Char, but Text is an array. so String comes up a lot more while teaching Haskell (because it's just another kind of list) but Text is strongly preferred for any real application
09:15:12 <thoradam> Yeah me neither 🤷‍♂️
09:15:14 <zincy_> Solanarv: Write so each Text gets its fresh buffer and we refer to the offsets (ptr) to use substrings without having to create new buffers for said substrings
09:15:27 <Solonarv> yes
09:15:35 <zincy_> :)
09:15:43 <Solonarv> bdesham[m]: or ByteString for chunks of binary data
09:16:57 <hpyCdr> Solonarv, so there will be some types that only sometimes can provide an "X" and some algorithms that can deal with it being optional. While other types can always provide it and other algorithms will always require it
09:17:09 <Solonarv> yeah, I see now
09:17:39 <hpyCdr> while those types that can always provide it, should automatically implement the optional class
09:17:49 <Solonarv> here I would actually just use DefaultSignatures and a default implementation, instead of a blanket instance like you have there
09:17:53 <pavonia> thoradam: Does the problem resolve if you export the types or even the fields explicitly?
09:18:47 <Solonarv> class OptX a where
09:18:48 <Solonarv>   getoptx :: a -> Maybe Double
09:18:48 <Solonarv>   default getoptx :: X a => a -> Maybe Double
09:18:48 <Solonarv>   getoptx = pure . getx
09:19:17 <hpyCdr> that looks good, let me try
09:19:42 <Solonarv> (need DefaultSignatures extension)
09:19:46 <thoradam> pavonia: Nope
09:21:08 <hpyCdr> Solonarv, at least it compiles :) . Thank you
09:21:31 <pavonia> Weird. Perhaps someone else knows more about hat
09:21:48 <bdesham[m]> Solonarv: oh, definitely, right. I was only thinking about text-like applications :)
09:21:50 <Solonarv> hpyCdr: with this setup you can write
09:21:50 <Solonarv> instance OptX Foo -- no instance body needed
09:21:50 <Solonarv> instance X Foo where getx = ...
09:22:27 <hpyCdr> it won't work without the explicit instance?
09:22:34 <hpyCdr> or is there another way?
09:22:48 <hpyCdr> it's perfectly fine this way, tho
09:22:58 <Solonarv> need the explicit instance declaration
09:23:16 <thoradam> pavonia: Yeah gonna try asking in other channels, thanks for taking a look ^_^
09:23:30 <Solonarv> you can abbreviate it slightly using DeriveAnyClass but that doesn't really seem very helpful here
09:23:42 <pavonia> thoradam: There's #ghc, IIRC
09:23:59 <thoradam> pavonia: Cool thanks
10:06:08 * shapr hops quietly
10:06:12 <WinchellsM> What happens if you pattern match against Maybe like this:
10:06:25 <WinchellsM> Just value <- (Maybe Value)
10:06:42 <shapr> WinchellsM: tried it?
10:06:50 <WinchellsM> Just value <- (return (Just value)) :: Maybe Value
10:06:50 <shapr> I bet you can try it in a recent ghci
10:07:18 <geekosaur> or even not so recent
10:07:49 <Ariakenom> WinchellsM: https://en.wikibooks.org/wiki/Haskell/do_notation#The_fail_method
10:08:12 <Ariakenom> ^ has "Just x1 <- action1" as example
10:09:26 <Solonarv> @undo do Just x <- foo; use x
10:09:26 <lambdabot> foo >>= \ a -> case a of { Just x -> use x; _ -> fail ""}
10:10:11 <Solonarv> for IO, the 'fail' method throws an exception (which you can catch)
10:11:53 <z0> I just created `(>==) :: (a -> Either l r) -> (r -> b) -> a -> Either l b` for composing error handling and non error handling functions together. Is there a more standard way of doing this?
10:12:34 <Solonarv> z0: yes, just use 'fmap' and '.' directly
10:12:47 <Solonarv> or if you have a more complex chain you can use do notation
10:16:35 <z0> how so? what I have is `e0 >=> e1 >=> e2 >== f0 >== f1 >=> e3` where e's return an Either and f's don't 
10:17:19 <Solonarv> in that case you can also combine >=> and return/pure
10:17:42 <Solonarv> f >== g is the same as f >=> pure . g
10:17:52 <z0> hum
10:18:07 <Solonarv> I prefer the latter because it doesn't introduce a new operator that I've never seen before and have to look up first ;)
10:19:40 <Solonarv> or if you compose the other way around you end up with:
10:19:40 <Solonarv> e3 <=< fmap f1 . fmap f0 . e2 <=< e1 <=< e0 -- which you can shorten to:
10:19:40 <Solonarv> e3 <=< fmap (f1 . f0) . e2 <=< e1 <=< e0
10:22:06 <z0> oh i got you!
10:30:17 * hackage map-reduce-folds 0.1.0.0 - foldl wrappers for map-reduce  https://hackage.haskell.org/package/map-reduce-folds-0.1.0.0 (adamCS)
10:30:51 <hpyCdr> is Data.Text a good choice over String if I dynamically create many strings of e.g. 100 chars created from 5 sub strings? They're basically created once and dumped to file
10:31:18 <hpyCdr> since I'd have to pack once anyway I don't see a benefit
10:36:11 <phadej> is you have N (N small) "input" strings, and create new strins by appending those in various ways, then maybe you should work abstractly over your language, i.e. [1,2,3,4,5] etc. and only make concrete Text or String when you need it (i.e. just before writing it to file)
10:46:32 <z0> `pure.f >=> pure.g` just clicked. Thanks, Solonarv
10:46:42 <Solonarv> \o/
10:47:56 <z0> i dont know why, but pure tends to illude me
10:50:50 <__monty__> Hmm, I have a ReadP parser. I want it to fail if *both* (xs == [] && mFrac == Nothing). I thought avoiding a boolean guard'd be nicer but I can't seem to fill in the _nofail holes: `foldr (\_ -> _nofail) (maybe pfail (\_ -> _nofail) mFrac) xs`
10:54:55 <lyxia> _nofail = pure () ?
10:54:59 <jerv> Any way to concatenate Data.Text and a number without first going through String?
10:56:51 <lyxia> jerv: maybe this https://hackage.haskell.org/package/text-1.2.3.1/docs/Data-Text-Lazy-Builder-Int.html
10:57:05 <pavonia> Ah, too slow :p
10:57:40 <lyxia> If you want efficient conversions to Text, you should look into converting to Builder
11:00:10 <phadej> build build's lazy Text though
11:00:29 <phadej> but if it's used to output stuff, then it doesn't matter
11:02:19 <lyxia> is there a strict version of builders
11:02:26 <lyxia> or does it make no sense
11:03:46 <__monty__> lyxia: Hmm, yeah that's what I thought. Can't get the type to line up though: Couldn't match type ‘()’ with ‘ReadP ()’
11:12:14 <__monty__> lyxia: Oh, forgot fold's function gets two arguments -.-
11:16:14 <lavalike> > foldr f z [x,y]
11:16:16 <lambdabot>  f x (f y z)
11:16:57 <jacker[m]> Today I came to know that floating point numbers representation or conversion in binary digits is quite complex
11:20:06 <__monty__> Also surprisingly simple if you look at it from another POV : )
11:21:23 <jacker[m]> What's pov?, how monty
11:21:28 <Ariakenom_> % 0.1 + 0.2 -- jacker[m] 
11:21:28 <yahb> Ariakenom_: 0.30000000000000004
11:22:13 <geekosaur> "point of view"
11:22:25 <jacker[m]> Ariakenom_: didn't get you
11:22:46 <Ariakenom_> I was just pointing weird float stuff
11:22:49 <Ariakenom_> well "weird"
11:22:55 <Ariakenom_> I just learned
11:22:59 <Ariakenom_> % let nan = 0/0 in max 0 nan
11:22:59 <yahb> Ariakenom_: 0.0
11:23:02 <Ariakenom_> the other day
11:23:10 <Ariakenom_> now that's weird
11:23:20 <__monty__> Yep. It's surprising to me how complex a system can be represented with such simple rules at the binary level.
11:24:00 <Ariakenom_> also
11:24:03 <Ariakenom_> % let nan = 0/0 in 1**nan
11:24:03 <yahb> Ariakenom_: 1.0
11:24:14 <[exa]> now that's cool
11:24:46 <__monty__> Hmm, what's max nan -inf?
11:25:52 <Ariakenom_> It was from this fun video. think I got it from around here https://www.youtube.com/watch?v=5TFDG-y-EHs
11:26:26 <Ariakenom_> % let nan = 0/0; ninf = -1/0 in max nan ninf
11:26:26 <yahb> Ariakenom_: NaN
11:27:15 <Ariakenom_> ... I do not like floats
11:27:51 <Ariakenom_> (as in from around this channel, -offtopic or something)
11:29:14 <__monty__> % let nan = 0/0; inf = 1/0 in (max nan -1, max nan inf)
11:29:14 <yahb> __monty__: ; <interactive>:118:1: error:; * No instance for (Show (Double -> Double)) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
11:29:36 <__monty__> % let nan = 0/0; inf = 1/0 in (max nan (-1), max nan inf)
11:29:36 <yahb> __monty__: (NaN,NaN)
11:29:54 <__monty__> % let nan = 0/0 in max nan 1
11:29:54 <yahb> __monty__: NaN
11:29:57 <__monty__> WAT
11:30:15 <__monty__> So it's only a number *if* the number is 0?
11:30:29 <Ariakenom_> % let nan = 0/0 in max nan 1
11:30:29 <yahb> Ariakenom_: NaN
11:30:38 <Ariakenom_> % let nan = 0/0 in max nan 0
11:30:38 <yahb> Ariakenom_: NaN
11:30:51 <Ariakenom_> % let nan = 0/0 in max 1 nan
11:30:51 <yahb> Ariakenom_: 1.0
11:31:07 <Ariakenom_> % let nan = 0/0; ninf = -1/0 in max ninf nan
11:31:07 <yahb> Ariakenom_: -Infinity
11:31:18 <Ariakenom_> >:]
11:33:17 <Ariakenom_> __monty__: you think max is associative!? such a silly idea
11:33:40 <Ariakenom_> actually
11:34:06 <Ariakenom_> that's a haskell failure, not floats
11:34:34 <Ariakenom_> "Ord Double"
11:35:18 <Ariakenom_> I think the standard is max Nan x = max x NaN = x
11:43:48 <EvanR> Ariakenom_: seems js is "wrong" too, max 5 NaN = NaN
11:44:42 <mud> Usually you want any operation using nan to be nan itself, afaik.
11:45:12 <EvanR> usually i want NaN to cause an error
11:45:28 <mud> That would often be ideal
11:46:27 <mud> Not really a way for that to happen the way it's handled in hs tho, is there? Seems like you'd need working with Double to be quite a bit more annoying.
11:47:48 <EvanR> well you can mess with the global floating point env
11:49:03 <Ariakenom_> python depended on order in the same way as haskell
11:49:37 <mud> What would it even do though, wouldn't you then just get exceptions from pure code? It'd be like using error everywhere, right?
11:49:46 <Ariakenom_> and js gave nan for both orders, yeah
11:50:11 <EvanR> nevermind i was thinking of signalling NaNs, which doesn't do what i meant
11:50:31 * Ariakenom_ once newtyped float where Ord on nans errored out
11:50:32 <EvanR> crashing when given NaN as input is too late
11:51:36 <EvanR> yeah you get exceptions from pure code when using integer arithmetic wrong, so it's not unheard of
11:52:14 <dminuoso> Its a shame that Haskell RTS has no support for IEEE 754 exceptions. Is there any work in progress there?
11:52:30 <Ariakenom_> I believe the standard does specify a total order for floats, nans being smallest
11:52:38 <dminuoso> Ariakenom_: Not quite.
11:52:59 <EvanR> NaN is "uncomparable"
11:53:15 <Ariakenom_> yeah but
11:53:33 <Ariakenom_> I think there is some separate "total order" version of the rodering
11:54:17 <ClaudiusMaximus> the #numerical-haskell channel exists, where there has been discussion about improving the FPU environment story, part of which is removing x87 and using SSE so the state is smaller
11:54:25 <Ariakenom_> https://en.wikipedia.org/wiki/IEEE_754#Total-ordering_predicate
11:54:55 <Ariakenom_> oh nice, is SSE faster too?
11:54:59 <geekosaur> which has problems like debian's stance
11:55:26 <dminuoso> Ariakenom_: Generally SSE is faster than x87 yes.
11:55:36 <Ariakenom_> thanks, thought so
11:55:44 <ClaudiusMaximus> geekosaur: oh, for supporting ancient machines?
11:55:55 <geekosaur> yes
11:56:46 <dminuoso> Ariakenom_: Refer to 5.10 in http://www.dsc.ufcg.edu.br/~cnum/modulos/Modulo2/IEEE754_2008.pdf 
11:57:44 <EvanR> arent questions about floating point really dependent on the platform anyway, ancient x86 and modern are like two platforms right
11:58:05 <EvanR> and motorola 68k is another
11:59:49 <Ariakenom_> dminuoso: oh yeah, thanks. that rings a bell
12:02:51 <Ariakenom_> dminuoso: the float spec to haskell translation is open to some interpretation, right? implementing Ord in terms of totalOrder seems fine to me.
12:03:33 <dminuoso> Ariakenom_: Not quite, the total order predicate is seperate from comparisons (see 5.6.1)
12:05:57 <Ariakenom_> dminuoso: the comparisons need to be provided, yes. but do they have to be (==), (<)?
12:08:01 <dminuoso> Ariakenom_: Ah I see what you mean. Though you'd need to provide the non-total order another way then.
12:08:36 <Wizek> Is it possible to get a/the monomorphic, specialised type with ghc(i) of a polymorphic value?
12:08:57 <dminuoso> Ariakenom_: I guess part of the problem is that implementations unfaithfully implement the comparison predicates since generally you do not have an unordered result.
12:09:13 <Wizek> E.g. if I have a .hs file containing `main = putStrLn $ id $ "x"`, can I somehow inspect id to be `String -> String`?
12:09:38 <dminuoso> Wizek: Check TypeApplications
12:10:17 * hackage language-puppet 1.4.4 - Tools to parse and evaluate the Puppet DSL.  https://hackage.haskell.org/package/language-puppet-1.4.4 (pi3r)
12:10:34 <Gander> data Term =     Variable Var   | Lambda   Var  Term   | Apply    Term Term
12:10:50 <dminuoso> Wizek: A polymorphic value in GHC is implemented as a kind of "function" parameterized over a type. So in order to use a polymorphic type you have to apply that function to a type first, GHC does this behind the scenes automatically using type inference. You can however manually apply the type using TypeApplications.
12:11:24 <Ariakenom_> dminuoso: the spec does include the boolean, predicate, results for each operation, in addition to the relations, in 5.11
12:11:38 <Ariakenom_> so it seems fairly faithful, no?
12:11:54 <Wizek> dminuoso: It's not that I want to restrict id to be String -> String, I want ghci to be able to tell me that
12:12:01 <ClaudiusMaximus> Wizek: you can use holes: putStrLn $ _id $ "hi"
12:12:03 <dminuoso> Wizek: How do you mean?
12:12:25 <Ariakenom_> *the bool result in combination with the relation
12:12:54 <dminuoso> % putStrLn $ (id :: _) $ "hi"
12:12:55 <yahb> dminuoso: ; <interactive>:128:19: error:; * Found type wildcard `_' standing for `a -> a'; Where: `a' is a rigid type variable bound by; the inferred type of <expression> :: a -> a; at <interactive>:128:19; To use the inferred type, enable PartialTypeSignatures; * In an expression type signature: _; In the expression: (id :: _); In the second argument of 
12:13:02 <dminuoso> Mmmm.
12:13:16 <dminuoso> Is that actually correct?
12:13:27 <ClaudiusMaximus> % putStrLn $ _id $ "hi"
12:13:28 <yahb> ClaudiusMaximus: ; <interactive>:1:1: error:; GHC internal error: `Ghci32.$trModule' is not in scope during type checking, but it passed the renamer; tcl_env of environment: []
12:13:37 <dminuoso> % putStrLn $ _id $ "hi"
12:13:37 <yahb> dminuoso: ; <interactive>:1:1: error:; GHC internal error: `Ghci32.$trModule' is not in scope during type checking, but it passed the renamer; tcl_env of environment: []
12:13:44 <dminuoso> % :q
12:13:44 <yahb> dminuoso: 
12:13:46 <dminuoso> % putStrLn $ _id $ "hi"
12:13:52 <yahb> dminuoso: ; <interactive>:1:1: error:; GHC internal error: `Ghci1.it' is not in scope during type checking, but it passed the renamer; tcl_env of environment: []
12:13:56 <Roxbury> data Term =     Variable Var   | Lambda   Var  Term   | Apply    Term Term.  used :: Term -> [Var] how can I make used  collect all variables of type Variable into a list and not just the first one?
12:14:22 <dminuoso> Roxbury: What have you tried so far?
12:15:00 <Roxbury> Nothing that's got remotely close to working, I'm quite new to this
12:15:13 <Ariakenom_> dminuoso: oh heh I actually had that spec link bookmarked in my browser
12:15:35 <dminuoso> Roxbury: So consider your data structure representing a kind of tree.
12:16:36 <Roxbury> Yeah, I get that I can view it as a tree, but not sure how I can make use of this :/
12:17:20 <dminuoso> Roxbury: Recursion is the key.
12:17:29 <EvanR> start with the type of your collection operation
12:17:40 <EvanR> ah, Term -> [Var]. now do case analysis
12:19:43 <Roxbury> So I want something like (Variable p) = [p] etc.? Idk how to approach the recursion so it works on the whole function
12:20:07 <EvanR> thats one case
12:20:42 <dminuoso> Interesting.
12:20:57 <dminuoso> % instance Cocartesian (DownStar f)
12:20:57 <yahb> dminuoso: ; <interactive>:8:10: error:; * No instance for (Functor f) arising from the superclasses of an instance declaration; Possible fix: add (Functor f) to the context of the instance declaration; * In the instance declaration for `Cocartesian (DownStar f)'
12:21:33 <dminuoso> So even if I dont actually use the instance Functor on f, I still have to specify it if a superclass instance has Functor f on its instance?
12:22:17 <geekosaur> yes, as it's part of the typeclass's "contract"
12:23:32 <Roxbury> I don't know how to make a recursive case to read through a whole expression like Lambda "a" (Lambda "x" (Apply (Apply (Lambda "y" (Variable "a")) (Variable "x")) (Variable "b"))) without just giving one output
12:24:07 <shapr> reduce one step?
12:24:11 <geekosaur> combine results?
12:24:23 <dminuoso> Roxbury: How would you handle the `Apply` case?
12:26:10 <Roxbury> I don't know how to deal with the apply, I just need to be able to extract the variables or lambdas. I can't figure a recursion which will work outward from the effective top of the tree
12:26:26 <dminuoso> Roxbury: Well just do it anyway. :-)
12:26:56 <Roxbury> Alrighty
12:27:28 <dminuoso> Roxbury: In addition, keep the type signature of `used` in mind.
12:28:23 <Roxbury> So I create a case for each of apply, variable and lambda, and find some means of calling this over the whole expression?
12:29:21 <dminuoso> Roxbury: If you find a case for each of those, then the latter is done already.
12:38:44 <Roxbury> used :: Term -> [Var] used (Variable p) = [p] used (Lambda x m) = [x] ++ used m used (Apply n m) = used m ++ used n so something like this where I define m and n with a where?
12:42:08 <dminuoso> Roxbury: Yes.
12:42:28 <Roxbury> Okay, thanks very much :)
12:43:00 <dminuoso> Roxbury: You could think of `used (Variable p)` as a kind of "base" case, and the other cases as an induction step, if you are familiar with induction from high school.
12:43:31 <Roxbury> Yeah, I am familiar. This makes sense now, much appreciated
12:44:39 <hololeap> where can i look a the progress of dependent types in haskell?
12:47:21 <dminuoso> Roxbury: In addition, `[x] ++ ...` should rather be written as `x : ...` 
12:50:02 <dminuoso> hololeap: I think there's a wiki page on our gitlab
12:50:31 <MarcelineVQ> there's a wiki page but there's also another place I saw that I thought was more up to date, having trouble finding it just now
12:54:47 * hackage persistent 2.10.0 - Type-safe, multi-backend data serialization.  https://hackage.haskell.org/package/persistent-2.10.0 (parsonsmatt)
12:55:48 * hackage persistent-postgresql 2.10.0, persistent-template 2.7.0 (parsonsmatt): https://qbin.io/clarke-talked-4l8b
12:56:47 * hackage persistent-mysql 2.10.0 - Backend for the persistent library using MySQL database server.  https://hackage.haskell.org/package/persistent-mysql-2.10.0 (parsonsmatt)
12:57:10 <hololeap> can someone link me to the wiki page?
12:57:27 <geekosaur> https://gitlab.haskell.org/ghc/ghc/wikis/dependent-haskell
12:57:56 <hololeap> tha nks
12:58:06 <geekosaur> it's fairly out of date (e.g. long note about problems with *, which have been fixed by NoStarIsType)
13:00:46 <Solonarv> hololeap: I hear there is a branch with unsaturated type families and matchability in arrows which has been/will soon be merged
13:01:04 <geekosaur> interestingly, if I search the wiki I get the source markdown, not the rendered one
13:01:26 <Solonarv> also, the 'forall k ->' quantifier (visible, dependent) has been merged, although it's only valid in kinds right now
13:01:47 * hackage hledger-flow 0.11.1.0 - An hledger workflow focusing on automated statement import and classification.  https://hackage.haskell.org/package/hledger-flow-0.11.1.0 (apauley)
13:02:23 <__monty__> geekosaur: I think that's a known issue.
13:03:17 * hackage hledger-flow 0.11.1.1 - An hledger workflow focusing on automated statement import and classification.  https://hackage.haskell.org/package/hledger-flow-0.11.1.1 (apauley)
13:05:06 <infinisil> Hey, I want to make a class `class Property a` with a method `propertyName :: String`, which should return the name of that property
13:05:27 <infinisil> But obviously I can't do that, because propertyName even have `a` in its type
13:05:36 <dminuoso> infinisil: It actually does.
13:06:02 <dminuoso> infinisil: If you enable AllowAmbiguousTypes, then the type is actually: propertyName :: forall a. Property a => String
13:06:10 <infinisil> Ohhh
13:06:12 <dminuoso> You can then use this by also enabling TypeApplications.
13:06:14 <infinisil> I think that's what I need
13:06:21 <infinisil> Thanks
13:06:21 <dminuoso> Alternatively you'd use the proxy pattern
13:06:50 <Solonarv> which means you change the type of your method to something like 'propertyName :: Proxy a -> String'
13:06:52 <infinisil> Yeah I've actually used Proxy and AllowAmbiguousTypes/TypeApplications before, but I didn't know I could use it for this too
13:07:40 <infinisil> Perfect
13:13:13 <dmwit> Solonarv: s/P/p/ pls!
13:13:29 <Solonarv> dmwit: oops
13:13:35 <dmwit> =)
13:14:07 <dmwit> That way I can make people mad by giving it `[] :: [Foo]` and save 9 characters.
13:17:29 <Solonarv> even better, pass in [x] when you have some x :: Foo in scope!
13:18:33 <__monty__> Wow, that pisses me off so much o.O
13:19:24 <Solonarv> my eye is twitching o_O
13:19:33 <MarcelineVQ> literally shaking right now
13:20:49 <jle`> for those interested in this, ryan scott has a nice post outlining different ways of doing this with pros and cons of each
13:20:50 <jle`> https://ryanglscott.github.io/2019/02/06/proxy-arguments-in-class-methods/
13:21:18 <glguy> even better is putting Tagged in your class methods so you don't add any unnecessary functions to the mix
13:22:40 <Solonarv> oh, that's a nice one!
13:23:47 * hackage ghcid 0.7.4 - GHCi based bare bones IDE  https://hackage.haskell.org/package/ghcid-0.7.4 (NeilMitchell)
13:24:02 <jle`> glguy: ah, that method wasn't covered in ryan's post. i wonder if he'd be interested to hear about it 
13:28:00 <infinisil> I have another question: I'm trying to use OverloadedLabels instead now, so I can write a function that can be used like `getProperty #foo`, with the foo property having some additional property-specific methods defined
13:28:34 <infinisil> For this I'm doing `instance IsLabel "foo" (Property Bool) where  fromLabel = Property ...` which seems to work
13:29:09 <infinisil> But now I'm trying to access the string "foo" from inside fromLabel, without duplicating it
13:29:30 <infinisil> Is that possible? I might be going at this the wrong way
13:29:36 <jle`> since it's a static type, you can just literally type in "foo"
13:29:46 <jle`> literally literally, with a literal
13:31:05 <infinisil> jle`: Well, I just need the string "foo", as in, if `data Property a = Property { name :: String, parse :: String -> a }`, I want to have `fromLabel = Property "foo" read`
13:31:36 <jle`> right, you can just type in `Property "foo" read`, right?
13:31:48 <infinisil> jle`: Yeah, but then I have the string "foo" duplicated
13:31:54 <jle`> or are you trying to write an instance generic over all labels
13:32:03 <infinisil> Oh
13:32:52 <jle`> i don't think there's any way of getting around duplicating "foo" specifically, but if you you are writing something generic, instance IsLabel l (Property Bool) then there might be a way
13:33:09 <infinisil> Ah no I'm not doing that
13:33:28 <infinisil> I have a bunch of properties with names and types (and parsers/pretty-printers)
13:33:47 <infinisil> And I'd like to define an `instance IsLabel "name" (Property type)` for each of them
13:34:04 <infinisil> I'll think about this some more though, I have an idea
13:34:08 <jle`> hm
13:34:24 <jle`> there might be a way
13:34:41 <Solonarv> you could do something like: class HaveProperty (s :: Symbol) t | s -> t where ...; instance HaveProperty s t => IsLabel s (Property t) where ...
13:35:02 <infinisil> Solonarv: Oh that does certainly look good
13:35:13 <Solonarv> perhaps add a KnownSymbol s constraint to HaveProperty, and pick some better names :p
13:35:34 <infinisil> Solonarv: Can I get a String from KnownSymbol s => ?
13:35:39 * infinisil checks the class
13:35:44 <Solonarv> yes! that's exactly what KnownSymbol is for
13:36:20 <Solonarv> symbolVal :: KnownSymbol s => Proxy s -> String, and one or two variants for different ways of specifying s
13:36:38 <infinisil> Oh neat
13:37:06 * infinisil tries
13:37:47 * hackage hledger-flow 0.11.1.2 - An hledger workflow focusing on automated statement import and classification.  https://hackage.haskell.org/package/hledger-flow-0.11.1.2 (apauley)
13:42:31 <MarcelineVQ> jle`: these QuantifiedConstraints posts of ryan's are pretty great
13:42:46 <MarcelineVQ> Or at least the first one so far :>
13:46:14 <w1n5t0n> hey all, do I need to add something to my stack.yaml file to be able to use Control.Concurrent.MVar.Strict?
13:47:37 <MarcelineVQ> Not with a recent lts, but you would have to add strict-concurrency to your .cabal file or package.yaml if you have one
13:51:18 <MarcelineVQ> to "build-depends:" section if .cabal or "dependencies:" section if package.yaml
13:52:31 <MarcelineVQ> like you would with any package you want to import from. you can determine what package Control.Concurrent.MVar.Strict belongs to by typing it into https://hoogle.haskell.org/
13:53:36 <w1n5t0n> MarcelineVQ: ohh thanks that's so useful, I never knew how I was supposed to figure out the package of a module!
13:54:55 <w1n5t0n> what's the difference between specifying package dependencies in .cabal, stack.yaml, or package.yaml?
13:55:18 <MarcelineVQ> https://docs.haskellstack.org/en/stable/stack_yaml_vs_cabal_package_file/
13:56:12 <MarcelineVQ> in short stack.yaml tells stack where to get the things you want, your .cabal file says what you want to use, and package.yaml is something that can generate .cabal files.
13:57:21 <MarcelineVQ> There's much more to each of them than that but that's the basic differences as I see them
14:05:57 <w1n5t0n> so if I have a package.yaml and a .cabal and I delete the .cabal, will it be generated again?
14:06:35 <glguy> Yes, and if you delete the package.yaml you won't have to worry about that
14:06:37 <MarcelineVQ> when using stack yes
14:08:12 <__monty__> w1n5t0n: You should always have a .cabal if you open source or otherwise distribute your project, for people who don't use stack.
14:08:39 <w1n5t0n> good point, thanks!
14:12:59 <infinisil> I wish git had a feature to register files as generated along with how to generate them. Then you wouldn't have to commit them, but every time somebody checks out a version, it would automatically generate those files with the given command
14:13:20 <infinisil> Or something like that
14:14:02 <kadoban> The issue is just that you're using git for something it's not. It's not a deployment solution on its own.
14:14:16 <__monty__> infinisil: That wouldn't work if you don't have stack installed. Which is the main audience checking it in is important for : p
14:14:16 <infinisil> That has nothing to do with deployment though
14:14:38 <infinisil> __monty__: *cough* slap some nix on it!
14:16:09 <MarcelineVQ> Well, you can run a makefile when your project is built if you like, but there's still an onus for the user to have hpack available in this particular case.
14:18:07 <MarcelineVQ> Could galaxy-brain this problem though, just reimplement hpack in your Setup.hs
14:26:37 <infinisil> MarcelineVQ: That actually sounds pretty reasonable
14:27:44 <DigitalKiwi> not using stack sounds much more reasonable ;p
14:29:46 <Solonarv> you don't even have to stop using stack, just rm package.yaml ;)
14:35:43 <infinisil> rm -rf . to get rid of all your problems!
14:35:47 <infinisil> (but solutions as well)
14:36:36 <DigitalKiwi> usually the solutions are the problems :D
14:38:20 <Solonarv> what if some obnoxious bureaucrat wrote down the problem somewhere else? now you can never get rid of it!
14:39:18 <yitz> Having a hard time finding this. I want to do `data Foo = Foo int deriving (Eq)`. How do I go about implementing the binary-op Eq?
14:40:04 <Solonarv> you don't - if you write 'deriving (Eq)' you are asking the compiler to figure it out for you
14:40:58 <yitz> ...oh
14:42:05 <Solonarv> same for Ord, Show, and everything else you might put in a 'deriving' clause - that's what the 'deriving' clause is for!
14:42:54 <yitz> That's magical and useful :)
14:43:44 <Solonarv> it's quite useful, indeed!
15:46:26 <Boarders> if I use derive NFData from the generic instance
15:46:31 <Boarders> what sort of deriving strategy is that
15:46:37 <Boarders> if I have Deriving Strategies turn on
15:47:04 <Boarders> is it anyclass?
15:47:05 <yitz> Can I make a function that takes String|Text and then .. use a type-case?
15:47:31 <Boarders> yitz: you can use a typeclass with only intances for String and Text
15:47:40 <Boarders> not sure if that fits for your use case
15:47:51 <jle`> yitz: you cannot case on type directly
15:48:04 <yitz> Thanks
15:48:08 <jle`> yitz: this is actually a really important part about haskell's type system
15:48:14 <jle`> it gives us parametric polymorphism
15:48:34 <jle`> so we can say like, `myFunc :: a -> a` can only be the identity function, and nothing else
15:48:47 * hackage rattle 0.1 - Forward build system, with caching and speculation  https://hackage.haskell.org/package/rattle-0.1 (NeilMitchell)
15:48:51 <jle`> if we could directly case on type, we could do `myFunc x = if a == Bool then False else x`
15:49:52 <yitz> Hrm. Ok
15:51:19 <jle`> yitz: depending on what you want, you can do Either String Text -> ...
15:51:19 <lyxia> Boarders: anyclass yes
15:51:26 <Boarders> thought so
15:51:28 <Boarders> thanks!
15:51:42 <jle`> yitz: or turn your function into a typeclass method, and only have instances for String or Text
15:52:04 <jle`> (but this is commonly considered a bad idea, since you should never really make new typeclasses except for very rare circumstances)
15:52:18 <yitz> Either may work. 
15:52:21 <jle`> yitz: but from what i'm guessing, you just want something to act uniformly on string or text
15:52:28 <jle`> you don't want to actually branch the logic, you want to treat them the same way
15:52:53 <jle`> in that case, you can just have the function take Text or String (arbitrarily), and then ask the user to convert before giving it to you
15:53:03 <Boarders> if there is nothing in the ecosystem that can deal with stringy data then why not make your own typeclass?
15:53:14 <Boarders> I think that is strange advice in the haskell world
15:53:19 <jle`> also, note that you can interpret string literals as Text with -XOverloadedStrings
15:53:31 <yitz> Ah. Nifty
15:53:34 <yitz> Good to know
15:53:49 <jle`> so if your function takes Text, you can call `myFunction "hello"`, and "hello" will be interpreted as Text
15:53:52 <jle`> if -XOverloadedStrings is on
16:09:23 <yitz> What's the '.' vs '$'?
16:10:16 <Boarders> yitz: (.) means composition whereas ($) means function application (with lower precendence than other operators)
16:10:25 <Boarders> do you have a concrete example you are confused about
16:10:49 <Cale> :t (.)
16:10:51 <lambdabot> (b -> c) -> (a -> b) -> a -> c
16:10:53 <Cale> :t ($)
16:10:54 <lambdabot> (a -> b) -> a -> b
16:11:17 <yitz> Just seeing '.' show up a bunch.   $ pad $ clean $ pack input
16:11:30 <Cale> (.) takes two functions and composes them together like
16:11:34 <Boarders> ` (+5) . (* 6) ` means the function that multiples by 6 then adds 5
16:11:38 <Cale> (f . g) x = f (g x)
16:12:10 <Cale> while ($) is just ordinary function application, albeit with low precedence and weirdly associating to the right instead of left
16:12:14 <Boarders> `\x -> (+ 5) $ (6 * x)` means the same thing written using $
16:12:17 <Cale> f $ x = f x
16:13:27 <yitz> $ f $ g x    vs $ (f . g) x   are the same?
16:13:46 <Cale> yeah
16:14:03 <Cale> (the initial $ is a bit weird there, but presumably there would be something before it)
16:14:23 <yitz> OK. So ... similar :) But I need to wrap it all up in a ()
16:14:56 <yitz> Is there a reason to use    f $ g $ h x   vs (f.g.h) x  ?
16:16:36 <Welkin> if you like dollars
16:16:53 <Welkin> always put a space between the dots
16:16:58 <Welkin> (f . g . h) x
16:16:59 <yitz> ok
16:17:02 <Welkin> I prefer that to dollars
16:17:15 <Welkin> or
16:17:20 <Welkin> f . g . h $ x
16:17:34 <yitz> That looks clean
16:18:16 <Welkin> no, clean is another language
16:18:55 <Welkin> https://clean.cs.ru.nl/Clean
16:18:59 <yitz> :P
16:19:47 <yitz> Any tips on going from a string to an Int? atoi style?
16:21:16 <Welkin> > read "3" :: Int
16:21:18 <lambdabot>  3
16:21:23 <benzrf> bad! no!
16:21:30 <benzrf> that doesnt let u handle errors!
16:21:47 <yitz> Erm...
16:22:15 <infinisil> > readMaybe "3" :: Int
16:22:17 <lambdabot>  error:
16:22:17 <lambdabot>      Variable not in scope: readMaybe :: [Char] -> Int
16:22:24 <infinisil> % readMaybe "3" :: Int
16:22:24 <yahb> infinisil: ; <interactive>:9:1: error: Variable not in scope: readMaybe :: [Char] -> Int
16:22:35 <infinisil> % import Text.Read
16:22:35 <yahb> infinisil: 
16:22:38 <infinisil> % readMaybe "3" :: Int
16:22:38 <yahb> infinisil: ; <interactive>:11:1: error:; * Couldn't match expected type `Int' with actual type `Maybe a0'; * In the expression: readMaybe "3" :: Int; In an equation for `it': it = readMaybe "3" :: Int
16:22:45 <infinisil> % readMaybe "3" :: Maybe Int
16:22:45 <yahb> infinisil: Just 3
16:22:48 * yitz backs away
16:22:49 <infinisil> There!
16:23:03 <yitz> I like me that Read
16:23:07 <infinisil> > Text.Read.readMaybe "3" :: Maybe Int
16:23:09 <lambdabot>  error:
16:23:09 <lambdabot>      Not in scope: ‘Text.Read.readMaybe’
16:23:09 <lambdabot>      No module named ‘Text.Read’ is imported.
16:23:15 <yitz> Maybe's are a pain to handle
16:25:37 <infinisil> I have a question, along with some code: https://gist.github.com/Infinisil/e6653248ad5ced2f9b4aaf0814e42a37
16:25:56 <infinisil> It's again regarding my property thing from earlier ( Solonarv jle` )
16:26:11 <infinisil> I'm using an implementation like this right now, I couldn't get the other thing to work
16:26:40 <infinisil> I have to have both read-only properties, only needing a parser function
16:26:54 <infinisil> And read-write properties, which in addition need a printer function
16:27:32 <infinisil> This solution uses separate GADT data constructors (PropertyRO :: String -> (String -> a) -> Property False a) and (PropertyRW :: String -> (String -> a) -> (a -> String) -> Property True a)
16:28:00 <infinisil> `Property False` being a read-only property, `Property True` is a writable one
16:28:20 <infinisil> But this doesn't feel very good, there's some bloat in there
16:28:39 <infinisil> Is there any way to make this nicer? I feel like I'm missing some abstraction somewhere, but I just can't put my finger on it
16:31:33 <jmcarthur> yitz: Error handling is a pain, but it's worth doing right even if it's verbose.
16:34:32 <jmcarthur> I guess unless you're just making some little side project that nobody is going to care about ever
16:36:51 <yitz> I'm just trying to learn the language and work through exercism.io
16:44:15 <yitz> `vals t = let parts = chunksOf 2 t in Prelude.map partValue parts`  ==>   Defined but not used: ‘parts’
16:44:18 <yitz> How is that not used?
16:44:38 <infinisil> Um, read that again
16:44:45 <infinisil> Oh
16:45:00 <infinisil> My IRC split up your line in two, I didn't see the last `parts`
16:45:15 <yitz> It works and gives me what I want
16:45:37 <infinisil> You don't have it defined elsewhere?
16:45:54 <yitz> ....
16:46:00 <infinisil> And the website might be buggy, dunno
16:46:03 <yitz> Uh... maybe? 
16:46:15 * yitz quickly deletes the other `parts`
16:46:20 <infinisil> Lol
16:46:28 <yitz> Nope! No where else now.
16:46:55 <yitz> It's not like I check line numbers
16:50:52 <Solonarv> infinisil: sorry, I was AFK
16:51:28 <Solonarv> one approach is to simply define a new datatype: data PropertyKind = PropReadonly| PropReadWrite, and use that instead of Bool in your GADT
16:52:33 <Solonarv> doesn't change anything really, apart from making it much easier to see what the type parameter means
16:52:42 <infinisil> Yeah..
16:52:56 <Solonarv> which is actually quite a significant change!
16:53:31 <infinisil> Ehh, I guess
16:54:15 <infinisil> Oh actually, I could make that a type with 3 constructors in my usecase
16:54:35 <Solonarv> a-ha! another case of boolean blindness cured!
16:54:41 <infinisil> xD
16:55:07 <Solonarv> another approach is to split your typeclass in two: a 'class PropertyRead blah' that has just the property name + parser, and a 'class PropertyRead blah => PropertyReadWrite blah' that additionally has the writer/printer
16:55:49 <infinisil> Yeah I tried that, but then defining instances is a pain
16:55:58 <infinisil> Because every property needs its own data type
16:56:22 <Solonarv> associated types to the rescue?
16:57:36 <infinisil> Haven't tried that (or only very shortly), but I don't have hopes in that approach
16:58:05 <Solonarv> oh, maybe I got things backwards
16:58:06 <infinisil> Ignoring the code duplication, what I have now is almost perfect
16:58:49 <Solonarv> can you post your current code? let's see if we can deduplicate it!
16:59:07 <infinisil> I did
16:59:29 <infinisil> (unless you already saw that and assumed I had to have more, which I don't :))
17:00:04 <Solonarv> if you mean the GADT definition, yeah, I saw that
17:00:37 <infinisil> The duplication is there, namely how both constructors are almost the same
17:00:55 <infinisil> Which leads to propName and propParse's cases being almost the same too
17:01:20 <Solonarv> aaah, I see
17:01:47 <Solonarv> you could fix this with a pattern synonym for the shared fields
17:02:09 <yitz> Solved exercism.io Luhn!
17:02:14 <infinisil> A "pattern synonym"??
17:02:21 * infinisil has to look that up
17:02:32 <Solonarv> they're neat!
17:02:57 <infinisil> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-PatternSynonyms
17:04:27 <infinisil> Neat
17:04:41 <Solonarv> pattern PropReadable :: String -> (a -> String) -> Property c a
17:04:41 <Solonarv> pattern PropReadable name parse <- ((\case PropertyRO n p -> (n,p); PropertyRW n p _ -> (n,p)) -> (name, parse))
17:04:57 <Solonarv> other extensions used here: ViewPatterns, LambdaCase
17:05:27 <Solonarv> unfortunately pattern synonyms that "merge together" multiple constructors are a bit unwieldy like that
17:05:51 <Solonarv> ...unwieldy to define, that is
17:06:19 <Solonarv> note also that you can only use this particular pattern synonym to deconstruct, not to create a new value - but that's probably fine
17:07:45 <infinisil> Enabling all the extensions
17:09:30 <Solonarv> another option is to change your GADT to something like the following:
17:09:30 <Solonarv> type family WriterFor k a where
17:09:30 <Solonarv>   WriterFor PropRead a = ()
17:09:30 <Solonarv>   WriterFor PropRead a = a -> String
17:09:30 <Solonarv> data Property k a where
17:09:31 <Solonarv>   Prop :: { propName :: String, propParse :: String -> a, propPrint :: WriterFor k a } -> Property k a
17:10:00 <infinisil> Oh yeah, I thought of something like that too, but that's kinda ugly
17:10:19 <Solonarv> er, the second clause in that type family should be: WriterFor PropReadWrite a = a -> String
17:10:47 <Solonarv> record syntax here also makes it easy to ignore fields you don't care about
17:10:57 * infinisil still trying the pattern thing
17:13:42 <infinisil> Solonarv: Okay well actually this pattern thing only reduces duplication minimally
17:14:01 <infinisil> And it's a pain to write
17:14:12 <infinisil> Sooo, I guess I'll still stick to the original for now
17:14:30 <mjacob> is there a way to make something like "function_returning_itself () = function_returning_itself" work?
17:14:58 <mjacob> by default it fails with "cannot construct the infinite type: t ~ () -> t"
17:15:23 <infinisil> mjacob: Well, how about `f = f`?
17:15:49 <Solonarv> mjacob: that infinite type will always show up, since it's exactly how you say "function returning itself" at the type level
17:16:34 <mjacob> infinisil: i added the "()" just to make it a function, it could be something else that's actually used
17:16:54 <Solonarv> yeah, then you'll definitely have that problem
17:17:08 <mjacob> Solonarv: yes, i know.  basically my question was "is there a GHC extension that makes infinite types legal?"
17:17:17 <Solonarv> perhaps there's some other way to do whatever it is you're actually trying to do?
17:17:23 <infinisil> ^^
17:17:49 <Solonarv> hm, you can trick GHC into accepting sort-of-infinite types with judicious use of newtype wrappers
17:18:20 <Solonarv> for example: newtype Eat a = Eat { feed :: a -> Eat a }
17:18:34 <Solonarv> % newtype Eat a = Eat { feed :: a -> Eat a } -- let's try it
17:18:34 <yahb> Solonarv: 
17:18:53 <mjacob> Solonarv: it didn't come up in a "real-world" use case.  i was just interested whether it's possible (from a language-theoretic perspective).
17:19:08 <Solonarv> % returnsSelf = Eat $ \() -> returnsSelf
17:19:08 <yahb> Solonarv: 
17:19:15 <Solonarv> % :t returnsSelf
17:19:16 <yahb> Solonarv: Eat ()
17:19:41 <Solonarv> strip away all the newtype wrappers and this is returnsSelf :: () -> () -> () -> ...
17:20:02 <Solonarv> which does indeed satisfy the 't ~ () -> t' equation!
17:20:20 <mjacob> yes, seems like it.  thank you!
17:20:37 <Solonarv> this example is rather useless, but the general technique (introduce wrappers) is in fact how we encode recursive types
17:21:45 <Solonarv> which includes things like {mealy,moore} machines, pipes, (co)free (co)monads, ...
17:24:22 <Solonarv> we can also use this to get a shallow embedding of the untyped lambda calculus:
17:24:22 <Solonarv> % data LC = LC { ($$) :: LC -> LC }
17:24:22 <Solonarv> % :set -XBlockArguments
17:24:22 <yahb> Solonarv: 
17:24:22 <yahb> Solonarv: 
17:25:06 <Solonarv> % lcTrue = LC \t -> LC \f -> t; lcFalse = LC \t -> LC \f -> f
17:25:06 <yahb> Solonarv: 
17:27:17 <Solonarv> % lcOr = LC \p -> LC \q -> p $$ lcTrue $$ q
17:27:17 <yahb> Solonarv: 
17:27:37 <Solonarv> % lcAnd = LC \p -> LC \q -> p $$ q $$ lcFalse
17:27:37 <yahb> Solonarv: 
17:28:11 <Solonarv> of course this is a bit inconvenient - we can only ever aply LC values to each other, not to regular Haskell values
17:28:29 <Solonarv> although, we probably can with judicious use of unsafeCoerce and friends
17:30:08 <Solonarv> there might even be a cleverer encoding where we can use safe coercions instead, but I'm too tired to remember that
17:31:13 <mjacob> the untyped lambda calculus is unsound as a deductive system.  how do the types need to be restricted so that unsound versions of the lambda calculus can't be embedded?
17:31:37 <mjacob> not sure whether that question makes sense really, but maybe you have an easy answer.
17:33:18 <Solonarv> eh, Haskell is unsound already (we have fix)
17:33:49 <Solonarv> and in fact a simple type system forbids writing the usual Y combinator!
17:35:46 <Solonarv> % y = \f -> (\x -> f (x x)) (\x -> f (x x)) -- forbidden
17:35:46 <yahb> Solonarv: ; <interactive>:21:23: error:; * Occurs check: cannot construct the infinite type: t0 ~ t0 -> t; Expected type: t0 -> t; Actual type: (t0 -> t) -> t; * In the first argument of `x', namely `x'; In the first argument of `f', namely `(x x)'; In the expression: f (x x); * Relevant bindings include; x :: (t0 -> t) -> t (bound at <interactive>:21:13); f :: t 
17:36:29 <Solonarv> so I *think* you just need to outlaw non-totality
17:38:59 <mjacob> Solonarv: maybe we can write the Y combinator with the trick you used for returnsSelf
17:39:49 <Solonarv> yeah, there's some way of doing tha
17:40:03 <Solonarv> I don't recall what exactly
17:40:41 <mjacob> if this was a channel where people insisted that i tell them what i'm "actually" trying to do, i could have said "i want to write the Y combinator" ;)
17:41:12 <Solonarv> % y f = let x = f x in x -- there you go!
17:41:12 <yahb> Solonarv: 
17:42:12 <Solonarv> this is actually the definition of 'fix' in the standard library, up to some irrelevant quibbling about let vs. where
17:47:35 <mjacob> Solonarv: thank you so far, this have been helpful!
17:47:44 <mjacob> s/have/has/
18:25:23 <Welkin> mr goldenfold
19:54:46 --- mode: ChanServ set +o glguy[m]
20:06:24 --- mode: ChanServ set -o glguy[m]
20:09:50 <glguy> test message please ignore
20:11:33 <DigitalKiwi> /ignore glguy
20:17:31 <benzrf> Solonarv: that's not Y, tho
20:17:53 <benzrf> that's indeed a fixed point combinator, but i feel like "Y" specifically refers to the particular combinator
21:02:10 <hans[m]6> if you are developing on mac is stack better or homebrew?
21:11:30 <glguy> hans[m]6: I prefer using ghcup to manage my GHC version
21:11:49 <glguy> versions*
21:14:17 <glguy> hans[m]6: homebrew's not so good for development as it picks a version for you and can change when you're not ready to change
21:15:29 <hans[m]6> that does not sound good
21:16:02 <glguy> https://www.haskell.org/ghcup/
21:16:11 <hans[m]6> im just starting off so im still trying to get the pieces together
21:17:57 <hans[m]6> does stack or ghcup also act like pythons virtualenv?
21:18:35 <glguy> cabal's v2-build handles sandboxing packages and reusing them when it's appropriate
21:35:49 <Gander> So I have the function  beta :: Term -> [Term]  || beta (Apply(Lambda x n) (Variable m)) = [substitute x (Variable m) n] ||  beta (Apply(Lambda x n) (Lambda y m)) = [substitute x (Lambda y m) n] ||  beta (Apply(Lambda x n) (Apply y m)) = [substitute  x (Apply y m) n] || and it gives me one beta reduction of an expression, what is a good way to output all possible reductions as a list?
21:38:34 <glguy> Gander: Why are you enumerating so many cases? Can't you write a single, more general case?
21:39:03 <Gander> data Term =     Variable Var   | Lambda   Var  Term   | Apply    Term Term
21:39:11 <Gander> this is my data type and need cases for each
21:39:17 * hackage Frames-map-reduce 0.1.0.0 - Frames wrapper for map-reduce-folds and some extra folds helpers.  https://hackage.haskell.org/package/Frames-map-reduce-0.1.0.0 (adamCS)
21:39:39 <Gander> or at least I thought I needed to
21:40:00 <glguy> beta (Apply (Lambda x n) arg) = [substitute x arg n]
21:40:03 <glguy> What about something like:
21:41:17 <Axman6> hans[m]6: stack also provides virtualenv style builds, with shared libraries between projects using the same (or compatible) stackage snapshots
21:41:34 <yitz> How do I convert an Int -> Float ?  I want to sqrt an Int
21:42:00 <Axman6> :t fromIntegral
21:42:01 <lambdabot> (Num b, Integral a) => a -> b
21:42:01 <glguy> :t fromIntegral :: Int -> Float
21:42:03 <lambdabot> Int -> Float
21:42:08 <yitz> Thanks!
21:42:31 <yitz> What exactly is an "Integral"?
21:42:33 <glguy> :t realToFrac :: Int -> Float
21:42:35 <lambdabot> Int -> Float
21:42:50 <glguy> Integral types are those like Int, Word, Integer
21:42:55 <glguy> whole numbers
21:43:06 <yitz> Ah. Thanks again
21:45:20 <Gander> glguy: that's a lot nicer,  I didn't realise that was a thing
21:46:09 <zxtx> hey anybody around that I can ask DataKind and GHC.TypeLits questions to?
21:46:28 <glguy> zxtx: On IRC you just ask your question and then wait for someone to see it
21:46:40 <geekosaur> best just to ask and wait around. if you can't wait on irc, there's stackoverflow or the haskell-cafe mailing list
21:47:04 <zxtx> alright, I'm trying to write a small interpreter with user-defined data types
21:47:16 <zxtx> and I want to track the user-defined types in the AST type
21:47:44 <zxtx> but I have this issue in that SomeSymbol are really these global names
21:48:10 <zxtx> what's the same way to enforce things
21:48:14 <glguy> If you have some code it's good to put it on gist.github.com so people can see it
21:51:49 <zxtx> ok so this if from the Hakaru project (https://github.com/hakaru-dev/hakaru/blob/master/haskell/Language/Hakaru/Types/DataKind.hs)
21:52:04 <zxtx> https://github.com/hakaru-dev/hakaru/blob/master/haskell/Language/Hakaru/Syntax/TypeCheck.hs
21:53:33 <Gander> beta :: Term -> [Term] ||  beta (Apply (Lambda x n) arg) = [substitute x arg n] so how do I get a list of all possible beta reductions from this? 
21:53:39 <zxtx> The challenge I'm having I want to be able to refer to user-defined data-types in macros like in https://github.com/hakaru-dev/hakaru/blob/master/haskell/Language/Hakaru/Syntax/Prelude.hs#L843
21:53:50 <Gander> data Term =     Variable Var   | Lambda   Var  Term   | Apply    Term Term
21:54:15 <glguy> Gander: there will be zero or one possible reductions?
21:54:18 <zxtx> but I'm unclear how to allow that in the code without breaking something
21:55:29 <Gander> Depending on the order of reduction there will be multiple after each step for example and I need to output the possible options
21:55:53 <Gander> A beta-step can be applied anywhere in a term. This is defined by: if N1 →β N2 then λx.N1 →β λx.N2 N1 M →β N2 M M N1 →β M N2 . We will implement a beta-step with the function beta. Since a term may have many redexes, or none at all (if it is in normal form), beta will return the list of all possible reductions.
22:29:57 <Lears> mjacob: https://gist.github.com/LSLeary/4c7f3ab7622d991cfa22c36efbaf0674
