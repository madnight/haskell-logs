00:04:30 <johnw> domenkozar: any idea what this is about: No instance for (servant-client-core-0.16:Servant.Client.Core.RunClient.RunStreamingClient ClientM)
00:04:44 <johnw> ah, maybe I'm just missing an import
00:08:27 <domenkozar> import Servant.Client.Streaming
00:08:28 <domenkozar> iirc
00:11:32 <c50a326> how can I have user-generated types? I'm looking at working with this kind of a data structure: https://gist.github.com/c50a326/4353279c53958ee6a0e5c859476cef8c (json) - see how the "variants" key can sit in any item to give child properties?
00:12:19 <c50a326> I'm working on an e-commerce shop implementation... actually in elm but thought to ask here... the idea would be that the user could specify what fields to expect and what types they would be
00:12:55 <c50a326> so I guess I need to write something that takes some data and produces some code which then produces the shop, kinda thing...
00:13:51 <c50a326> and maybe there's a better word or phrase to describe this pattern...
00:14:00 <johnw> domenkozar: I did that, but now I get something stranger
00:14:27 <johnw> https://gist.github.com/3411b6a70b056e1a55a0cef8b40546e6
00:14:41 <johnw> are there multiple ClientM types?
00:20:09 <johnw> if I import only Servant.Client.Streaming, and not Servant.Client, then I get: No instance for (FromSourceIO chunk2 (Headers StreamingHeaders (SourceIO ByteString)))
00:23:08 <johnw> ah, it just doesn't exist yet
00:42:53 <delYsid`> A PGN game is a Forest.  Interesting.
01:14:23 <merijn> Who maintains/runs the "reverse package dependencies" site?
01:14:47 <merijn> I'm curious what things would look like if they listed transitive dependency counts too
01:15:21 <Taneb> merijn: snoyberg and phadej, going by the GitHub
01:16:39 <phadej> I only contribute to the `packdeps` cli tool
01:20:29 <phadej> (which is good enough, but not perfect)
01:46:05 <xpika> what is the most advanced haskell nosql solution?
01:48:34 <xpika> ideally one that doesn't require marshalling to a custom ADT before calculations are done
01:55:51 <merijn> xpika: Why nosql?
01:57:33 <xpika> i'd like the freedom to calculate anything like select * from a where isPrime(a.b) or something
01:59:17 * hackage gitlab-haskell 0.1.0.1 - A Haskell library for the GitLab web API  https://hackage.haskell.org/package/gitlab-haskell-0.1.0.1 (RobStewart)
01:59:45 <[exa]> xpika: but that's sql?
02:00:37 <xpika> [exa]: yeah. so that would be pretty advanced if it looked like sql but wasn't
02:01:15 <[exa]> xpika: what's the most complicated function that you need there? IIRC some equivalent of isPrime is even in PostgreSQL standard library
02:01:39 <xpika> the idea would be that I could use my own functions
02:04:53 <[exa]> xpika: yeah there's PL/whatever for writing functions executed directly by the server. I wanted to point that the functionality you're requesting is not even remotely, nosql-specific and you'll probably have better to use normal SQL, unless you need some actual anti-relational functionality (denormalization or inverted indexing)
02:06:18 <merijn> [exa]: Honestly, even then SQL is still probably better
02:06:31 <merijn> Hell, even SQLite lets you trivially call your own functions
02:06:43 <merijn> You could even run Haskell functions inside your query :p
02:07:23 <tdammers> "nosql" on its own doesn't really say much about the requirements
02:07:51 <tdammers> it really just means "it doesn't have to be relational, and I can live with giving up some ACID guarantees in a somewhat controlled way"
02:07:54 <merijn> tdammers: Sure it does! "I hate stability and don't care about ACID" ;)
02:07:55 <[exa]> well the decision point for me is usually when I need to remove ACID for efficiency reasons
02:09:14 <tdammers> people tend to grossly underestimate the performance you can get out of a properly managed PostgreSQL cluster
02:09:28 <tdammers> a.k.a. "You Are Not Google"
02:09:30 <[exa]> yeah, nosql! <<<---   [can I lose random data?]   --->>> nope, acid.
02:10:02 <tdammers> I mean, why accept data loss or "eventual consistency" when you don't have to?
02:10:23 <[exa]> tdammers: very true :]
02:10:27 <tdammers> although for some specific situations and nosql databases, there may be valid arguments
02:11:15 <tdammers> for example, if your most important data is intrinsically tree shaped, and manipulating subtrees is an intrinsic part of your critical functionality, then a relational database might not be the best choice
02:11:30 <tdammers> not because of the ACID guarantees, but because the relational model isn't great at representing trees
02:18:46 <xpika> acid-state is pretty cool
02:19:37 <MasseR> acid-state, or a-state as I like to call it is a terrible database
02:19:54 <Taneb> xpika: someone wrote https://gist.github.com/parsonsmatt/6b747d3020c4a4ac43b6580b65392a23 a few months ago
02:20:05 <MasseR> The amount of data loss and grey hair it has caused our team is horrible
02:24:36 <merijn> MasseR: I don't think it's sensible as a database at all, but I liked the idea of "persistent heap data with ACID guarantees", but sadly Taneb's link made me realise a few weeks/months ago that it's not even remotely ACID, so I'm kinda over it
02:25:04 <MasseR> merijn: agreed. I like the idea. It's just not production quality
02:25:07 <merijn> SQLite on the other hand is the world's most underrated file format/database and everyone should use it more
02:26:29 <merijn> Database decision flowchart: "I need a database" -> SQLite, "but I really have a lot of data and need a REAL database!" -> SQLite, "but I need lots of concurrent writers, super high performance, and 100s of gigabytes of storage" -> "ok, so postgres, then"
02:41:13 <tdammers> merijn: for me, the tripping point is usually that I want proper column type constraints and stuff like that
02:50:32 <delYsid`> Is there a version of Data.ByteString.Builder which would make linewrapping to 80 columns possible?
02:51:38 <phadej> bytestring is binary
02:51:47 * hackage heavy-log-shortcuts 1.0.1 - Simle api for heavy logger  https://hackage.haskell.org/package/heavy-log-shortcuts-1.0.1 (Jappie)
02:51:49 <phadej> but there's `pretty` for prettyprinting stuff
02:51:54 <koz_> Unless you actually wanna insert LF bytes.
02:51:55 <phadej> (and other pretty printing libraries)
02:52:10 <merijn> @hackage prettyprinter
02:52:10 <lambdabot> http://hackage.haskell.org/package/prettyprinter
02:54:15 <phadej> hmm, that could tell https paths
03:08:15 <xpika> is there an option to calculate a value at compile time. 
03:08:15 <xpika> {-# precompute x #-}
03:08:15 <xpika> x = sqrt(2)
03:08:17 * hackage telega 0.1.6 - Telegram Bot API binding  https://hackage.haskell.org/package/telega-0.1.6 (iokasimovmt)
03:35:23 <delYsid`> xpika: https://www.youtube.com/watch?v=AzJVFkm42zM
03:36:52 <xpika> delYsid`: thanks
03:37:32 <pezubi> hey guys
03:37:41 <pezubi> which pastebin do you prefer?
03:37:59 <pezubi> I was told not to use pastebin.com but why?
03:39:09 <khan_> @pl 
03:39:09 <lambdabot> (line 1, column 1):
03:39:09 <lambdabot> unexpected end of input
03:39:09 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
03:39:39 <khan_> @pl  fn x = x + 1
03:39:39 <lambdabot> fn = (1 +)
03:39:52 <khan_> @pl sieveSundaram n = (2:) . map (\x -> 2*x + 1) . (Data.List.\\) [1..n]      . map (\(x, y) -> (x + y + 2*x*y))      . filter (\(i, j) -> i + j + 2*i*j <= n) . filter (\(i, j) -> i <= j)     . (\x -> cartProd [1..x] [1..x]) $ n
03:39:53 <lambdabot> (line 1, column 18):
03:39:53 <lambdabot> unexpected " "
03:39:53 <lambdabot> expecting operator
03:54:17 * hackage spiros 0.4.2 - Spiros Boosalis's Custom Prelude  https://hackage.haskell.org/package/spiros-0.4.2 (sboo)
04:48:47 <furnost> Hi all! I'm trying to build a small (not really useful) webapp as a small project to learn haskell. At some point, I want to connect to a SQLite DB, and so, I'm using SQLite.Simple. I have 'newtype Table = Table Text' and an instance for ToField 'toField = SQLText', but there is a type error: "Couldn't match type Table with Text". I don't understand how to "cast" the Table to a Text in an instance 
04:48:53 <furnost> declaration...
05:12:29 <Maxdamantus> AH GOD MAKE IT STOP
05:13:30 <Clint> Maxdamantus: okay
05:50:14 <kuribas> is there an indexed traversal?
05:50:18 <kuribas> :t traverse
05:50:19 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
05:52:01 <c_wraith> yes, but I can never remember the name
05:52:08 <c_wraith> :t itraversed
05:52:09 <lambdabot> (Applicative f, Indexable i p, TraversableWithIndex i t) => p a (f b) -> t a -> f (t b)
05:52:17 <c_wraith> or maybe I can :)
05:53:31 <kuribas> that's lens right?
05:53:34 <CelestialLake> IndexedTraversal is also a type in lens package. Somewhat confusing query.
05:54:34 <kuribas> can it be done elegantly using only base?
05:55:38 <phadej> it cannot
05:56:12 <c_wraith> Well, it can if you reimplement what lens does
05:56:29 <CelestialLake> Though why would you need to
05:56:37 <c_wraith> ...  actually, nevermind, I don't think any reimplementation of Indexable can be elegant. :P
05:56:45 <c_wraith> Indexable is kind of a silly class
05:56:46 <kuribas> I don't need indexable
05:56:50 <kuribas> just an index :)
05:57:01 <phadej> [reimplementation can be] or compatible with `lens`
05:57:04 <Cale> Also, in nearly any particular case, reimplementing it is nearly trivial. You probably don't really need the piles of abstractions.
05:57:07 <kuribas> (Int -> a -> f b) -> t a -> f (t b)
05:57:28 <Cale> Do you know what your 't' is?
05:57:48 <kuribas> []
05:57:55 <Cale> zip [0..]
05:58:38 <Cale> e.g. I'd be most likely to write something like   forM (zip [0..] xs) $ \(n,x) -> do ...
05:58:49 <kuribas> right
05:59:13 <kuribas> :t zipWith (flip ($)) [0..]
05:59:14 <lambdabot> (Enum a, Num a) => [a -> c] -> [c]
05:59:27 <kuribas> :t \f -> zipWith (f $) [0..]
05:59:28 <lambdabot> (Enum a, Num a) => (a -> b -> c) -> [b] -> [c]
05:59:47 <c_wraith> (f $) is just f
06:00:23 <kuribas> and then sequenceA?
06:01:18 <kuribas> :t \f l -> sequenceA $ zipWith f [0..] l
06:01:19 <lambdabot> (Enum a1, Num a1, Applicative f) => (a1 -> b -> f a2) -> [b] -> f [a2]
06:02:17 <kuribas> :t \f l -> sequenceA_ $ zipWith f [0..] l
06:02:18 <lambdabot> (Enum a1, Num a1, Applicative f) => (a1 -> b -> f a2) -> [b] -> f ()
06:02:24 <kuribas> that looks right...
06:04:17 <kuribas> that does create an intermediate list
06:04:27 <kuribas> maybe fusion will remove that though
06:05:27 <phadej> zipWith is fusion aware
06:05:31 <phadej> not sure about sequenceA
06:05:50 <zincy> What am I looking for here ? data Loop = Loop [Op | Loop] 
06:07:38 <zincy> I want to express that a loop contains one or more Ops and can contain another Loop
06:08:59 <kuribas> zincy: so just a list of ops?
06:09:09 <kuribas> or more like a tree?
06:09:14 <kuribas> a tree of ops...
06:09:37 <kuribas> a rose tree of ops
06:10:53 <zincy> Hmm it would seem like a tree of loops where each node is a list of ops
06:11:20 <zincy> Im essentially modelling nested loops that contain ops
06:11:55 <c_wraith> still sounds like a rose tree
06:12:45 <zincy> I guess the rose tree would be the resulting AST
06:14:15 <c_wraith> Oh, no, it's a bit different
06:14:53 <c_wraith> I think you want data Loop op = Single op | Multiple [Loop op]
06:18:36 <zincy> So a loop of one op would be - Single Op
06:20:35 <c_wraith> You could write it more like you had it initially, too.  data Loop op = Loop [Either op (Loop op)]
06:21:05 <zincy> Should the op on the left not be in a list
06:21:05 <c_wraith> those can hold roughly equivalent shapes of things.  Maybe the latter is more direct about it
06:21:17 <c_wraith> I don't see what that would help
06:21:29 <zincy> How else would you represent one loop of many ops?
06:21:38 <zincy> data Op = MoveRight | MoveLeft | Inc | Dec | ReadStdOut | WriteStdOut 
06:21:49 <c_wraith> Loop [Right Op1, Right Op2, Right Op2] etc
06:22:08 <zincy> Ah
06:22:10 <zincy> :)
06:22:17 <c_wraith> Err.  those should be Left instead of Right, with my definition
06:22:26 <c_wraith> I never was good at left/right
06:22:39 <zincy> I read it wrongly so didn;t notice
06:22:58 <zincy> Is it okay to use Either outside of Err handling?
06:23:04 <Taneb> Absolutely
06:23:43 <zincy> Ok cool
06:23:56 <zincy> I really like the latter ADT
06:24:57 <zincy> So for nested loops would you just pass Loop into the type variable `a`?
06:25:39 <zincy> Loop [ Right Loop Inc] 
06:39:38 <zincy> How should you go from a `Parser Char` to a data constructor if you are constructing an AST
06:39:42 <zincy> inc :: Parser Char
06:39:42 <zincy> inc = satisfy (== '+')
06:39:45 <zincy> .
06:40:14 <zincy> I am just not sure what the next step would be. Is there a way of getting an inc :: Parser Inc
06:41:28 <Solonarv> sure, you just need to come up with some function 'Char -> Inc'
06:41:57 <Solonarv> it can be as easy as: inc = Plus <$ satisfy (== '+')
06:42:08 <Solonarv> (here the function is 'const Plus')
06:43:36 <zincy> Ah ok is that using the functorial interface of the Parser type
06:44:28 <zincy> Is that equivalent to 
06:44:30 <zincy> inc :: Parser Inc
06:44:30 <zincy> inc = do
06:44:30 <zincy>     _ <- satisfy (== '+')
06:44:32 <zincy>     return Inc
06:44:42 <Solonarv> indeed it is
06:44:54 <Solonarv> and <$ is part of Functor
06:45:00 <Solonarv> @src <$
06:45:01 <lambdabot> (<$) = (<$>) . const
06:45:05 <Solonarv> bah
06:45:20 <Solonarv> x <$ fa = fmap (const x) fa
06:45:46 <zincy> So how do you decide whether to use the Functor, Applicative or Monadic typeclasses of Parser? I guess Monadic for sequencing
06:45:50 <Guest4749> Has GHC dropped support for IntWord32 (emulated primitive 32-bit types for 16-bit machines)?
06:46:19 <Solonarv> zincy: I usually just use the weakest one that will do the trick
06:46:25 <Solonarv> so in this case, Functor
06:47:47 <zincy> With x <$ fa = fmap (const x) fa 
06:47:59 <zincy> In what case would you not end up with fx
06:48:07 <zincy> if f is the functor
06:48:25 <Solonarv> well, what's fx?
06:48:31 <Cale> zincy: Since Parser has all of those, you needn't worry about which ones to use -- you may use them all.
06:49:15 <Solonarv> some examples might help:
06:49:15 <Solonarv> > 3 <$ Nothing
06:49:15 <Solonarv> > 3 <$ Just "hello"
06:49:15 <Solonarv> > "hi" <$ [1 .. 3]
06:49:18 <lambdabot>  Nothing
06:49:18 <lambdabot>  ["hi","hi","hi"]
06:49:18 <lambdabot>  Just 3
06:49:32 <Solonarv> o_O out of order?
06:49:56 <merijn> Solonarv: Yay, concurrency!
06:50:27 <zincy> Is that the exercise? match them up
06:51:53 <Solonarv> haha
06:53:09 <zincy> fmap is apply this function to some *->* type right. So <$ means the function is const now just give me the value for const?
06:55:38 <Solonarv> you can think of fmap as "modify every value using this function", and <$ as "replace every value with this value"
06:57:19 <zincy> Thanks
06:59:18 <zincy> So I have two types, one represents loops and the other ops
06:59:42 <zincy> Should I create an expression type to group these two types.
07:00:02 <zincy> So I can then create a type for program  which is then  a list of expressions?
07:00:46 <Solonarv> sounds like a sensible approach, though I don't know what kind of language you're trying to model
07:00:50 <zincy> https://pastebin.com/Duz5tF8T
07:00:57 <zincy> Brainf*ck
07:02:23 <tdammers> brainfuck doesn't really have loops, does it
07:02:28 <Solonarv> it does
07:02:29 <Solonarv> [ ]
07:03:00 <Solonarv> [ means "conditional jump to matching ]", ] means "conditional jump to matching ["
07:03:05 <tdammers> well, yes, but they kind of occur as a consequence of the interpretation rules, I wouldn't try to model them in an AST
07:03:24 <Taneb> tdammers: eh, it makes about as much sense either way
07:03:36 <tdammers> hmm, yeah, maybe
07:03:44 <zincy> In example grammars there is a loop construct
07:04:08 <tdammers> if you're going to *compile* brainfuck, then representing them as actual loops might be more useful
07:04:08 <Solonarv> if you parse [] specially you don't have to scan for matching [] when running the program
07:04:15 <tdammers> right
07:04:28 <tdammers> but for an interpreter, I'd stick with the conditional jumping
07:04:48 <zincy> I am compiling brainfuck to webassembly
07:05:28 <zincy> but I never considered that you would take a different approach for loops in the case of writing an interpretor
07:06:11 <tdammers> well, the main reason why I'd do it that way for an interpreter is because it would allow reading the program code in a streaming fashion
07:06:40 <tdammers> then again, you could also do that with a proper parser, really
07:08:46 <zincy> data Expr a = OpExpr a | LoopExpr a 
07:09:00 <zincy> Is this ok if a can only be Loop or Op
07:09:13 <zincy> I guess if you really wanted safety you would use typefamilies
07:09:17 * hackage extensible-effects-concurrent 0.21.0 - Message passing concurrency as extensible-effect  https://hackage.haskell.org/package/extensible-effects-concurrent-0.21.0 (SvenHeyll)
07:10:31 <zincy> No that doesnt work
07:11:01 <zincy> With a you are gonna end up with a hetereogenous list of expression types as your program
07:11:01 <Solonarv> I'd do something like: data Op = Incr | Decr | ... | Loop Program; type Program = [Op]
07:11:16 <zincy> Ooh good idea.
07:12:18 <Solonarv> or: data SimpleOp = Incr | Decr | ...; data Op = Simple SimpleOp | Loop Program; type Program = [Op]
07:12:30 <Solonarv> if you want more separation between loops and the other operations
07:13:43 <tdammers> data Expr a = OpExpr a | LoopExpr [Expr a]
07:14:27 <Solonarv> yeah, that works too
07:14:28 <tdammers> and then use Expr Op as the actual type
07:14:46 <tdammers> but frankly, I'd just go with data Expr = Incr | Decr | ... | Loop [Expr]
07:15:13 <Solonarv> yeah, that seems simplest
07:15:28 <zincy> Yeah nice.
07:15:35 <tdammers> assuming that the goal is to write a Brainfuck compiler, not a compiler for a whole family of Brainfuck-like languages
07:15:47 <zincy> The former.
07:15:57 <dmwit> Y'all are making it way too simple.
07:16:11 <zincy> Is it not simple?
07:16:41 <dmwit> You should parse straight-line code into an IntMap whose keys are pointer offsets and whose values are additions.
07:17:13 <zincy> Are you joking?
07:17:27 <dmwit> Actually, additions with an optional input, together with a list telling which input corresponds to which.
07:17:56 <dmwit> Sort of only half-joking. If you want an optimizing compiler... it turns out noticing a few simple patterns like [-] and the one for multiplying two cells makes your programs go way, way faster.
07:18:27 <dmwit> And a little bit of symbolic execution goes a long way to noticing those patterns.
07:19:11 <zincy> So using multiplication in the compiler reduces the operation count?
07:20:18 <zincy> Why would the simpler ADT hurt optimisation efforts?
07:20:21 <dmwit> Oh, heck yes. One hardware multiply instruction is about a bazillion times faster than m subtractions, m*n additions, and m*n branches.
07:20:28 <dmwit> (for multiplying m by n)
07:20:46 <zincy> So going from linear time to constant time
07:21:11 <dmwit> No, it goes from exponential time to polylog time.
07:22:22 <dmwit> (Treating "size of input" as "number of bits in a single memory cell". If you admit that single memory cells have 8 bits each, then both things are O(1), which is a dumb way to compare them.)
07:22:26 <zincy> So for [-] you just set said address to 0
07:22:31 <dmwit> Right.
07:22:49 <dmwit> There's another common pattern for copying a cell. There's a bunch of them.
07:23:21 <dmwit> But like I said above you can unify the handling of all of the common patterns with only a little bit of symbolic execution.
07:23:36 <dmwit> Just look for loops where the position of the pointer doesn't move and do a bit of arithmetic at that moment.
07:24:21 <zincy> What is symbolic execution?
07:25:24 <dmwit> [-] becomes *p_1 = *p_0 - *p_0; [>+<-] becomes *(p+1)_1 = *(p+1)_0 + *p_0; *p_1 = *p_0 - *p_0; etc.
07:26:50 <dmwit> Googling will get you started on symbolic execution. But broadly, it means running the program on some abstract representation and computing how the outputs relate to the inputs as a mathematical formula.
07:27:40 <dmwit> (Choosing how complicated of a mathematical formula you allow yourself is a very difficult art. Quite some balance is needed between tractability and coverage.)
07:31:52 <zincy> So it is about mappings between representations that maintain semantics?
07:32:26 <dmwit> Sure.
07:32:44 <tdammers> suppose you have an expression like a + a + a
07:33:15 <tdammers> you can reason about that at the symbolic level
07:33:35 <tdammers> and arrive at the conclusion that it's actually 3 * a
07:34:24 <tdammers> or, other example, given a + b - b, you can symbolically reason that you can eliminate the + b - b part
07:36:06 <zincy> That must be tough for an impure language
07:38:34 <phadej> not really
07:39:18 <phadej> if one knows which concrete + and - those are, then one can symbolically reason
07:39:26 <phadej> but in general, 'a + b - b /= a'
07:39:53 <phadej> as in, without "laws" (which GHC doesn't use, neither verify)
07:41:14 <zincy> So symbolic execution is tied up to reducing the number of operations a compiler has to do to generate output
07:41:55 <Solonarv> no
07:42:31 <Solonarv> symbolic execution is a way to figure out stuff about the program, which a compiler can use to produce better (faster/smaller/...) output
07:47:28 <tdammers> with symbolic execution, the compiler generally does *more* work, not less
07:47:56 <tdammers> and that's by design - the goal is to do more at compile time in order to do less at runtime
07:50:48 <Solonarv> of course it is occasionally possible for symbolic execution to allow the compiler to d less work; for example, if it figures out that some code can never be reached then it doesn't need to compile that code
07:51:23 <zincy> Is that dead code elimination?
07:51:29 <zincy> Heard the term
07:51:52 <Solonarv> yes indeed
07:52:18 <Solonarv> in order to eliminate dead code you need to somehow figure out that it's dead, after all
07:52:39 <isovector1> do we have any estimates on the size of the haskell community?
07:54:25 <Solonarv> I'm not aware of any concrete numbers, but there are surely some statistics that might be relevant
07:54:57 <maerwald> I think it was... over 9000
07:54:59 <maerwald> definitely
07:55:01 <Solonarv> stackoverflow, various communities such as /r/haskell or this channel...
07:55:08 <Solonarv> personally I think it's at least 12
07:55:19 <c_wraith> I don't even know how to define "the Haskell community"
07:55:46 <maerwald> c_wraith: sum of the combat power of each hero
07:56:03 <c_wraith> Haskell has a very high ratio of advanced users who only use it for hobbies, compared to most languages.
07:56:21 <isovector1> yeah i guess that's a good question
07:56:47 <isovector1> i guess i'd define it somewhere close to "consider themselves haskell programmers and use it somewhat frequently"
08:00:08 <c_wraith> I don't even know if I fit that definition. :)
08:01:04 <c_wraith> I haven't used Haskell to write real software in years. I have used it for toy problems and examples for others plenty, in that time.
08:02:18 <c_wraith> fwiw, that's not a thing I do with other languages. that's why I think this question is even more nebulous for Haskell than most languages
08:04:10 <isovector1> the _real_ question i'm trying to figure out is how big is the market for my book ;)
08:04:17 <c_wraith> I'd self-identify as part of the community. I still contribute patches to libraries like lens. but I do it to have more fun toys, not make better programs.
08:04:59 <c_wraith> ooh, that's even harder.
08:05:01 <Cale> What's your book about?
08:05:19 <c_wraith> he posted a link on reddit yesterday (-ish)
08:06:33 <c_wraith> the market for Haskell books is even harder to judge (without data), because lots of people are looking for the perfect book that makes it all make sense.
08:06:49 <c_wraith> and they probably wouldn't identify as part of the community.
08:07:24 <c_wraith> I'd say the only people who can really give you good feedback on market size are the ones who actually have published books and have sales numbers
08:07:39 <Cale> I didn't find a book, but I did find a link to this polysemy library which looks interesting :)
08:07:59 <c_wraith> oh, I must have mixed up posts
08:08:07 <c_wraith> sorry
08:08:30 <isovector1> i mean the book i already wrote :) https://thinkingwithtypes.com/
08:09:42 <isovector1> (but polysemy is super cool too!)
08:20:48 <dmwit> zincy: This is the kind of thing I'm thinking of: https://gist.github.com/dmwit/300d6a159e3d8de2938b44d7f9f34908
08:21:47 <zincy> isovector1: Great job on the book, I bought it.
08:24:26 <zincy> dmwit: So are you using symbolic execution there?
08:24:57 <dmwit> Yes. TapeUpdate is the symbolic representation of the execution of a straightline BF program.
08:25:56 <dmwit> Perhaps "compile" should be "symbolicallyExecute" everywhere in that file. =)
08:26:11 <dmwit> (Since I didn't then go on to show how to compile the symbolically executed thing to hardware instructions.)
08:26:17 * hackage http-directory 0.1.0 - http directory listing library  https://hackage.haskell.org/package/http-directory-0.1.0 (JensPetersen)
08:26:31 <dmwit> (...and you could imagine using this in an interpreter, too, so really "compile" is a terrible name!)
08:29:27 <isovector1> zincy: thanks! hope you like it :)
08:29:40 <zincy> isovector1: I already love it!
08:31:45 <zincy> dmwit: Ah so you are basically mapping out the operations before you carry them out there.
08:32:15 <zincy> So the resulting program doesn't have the performance of a turing machine
09:14:50 <remexre> so I'm using quickcheck, and I have a type like
09:15:09 <remexre> data Foo f = Bar Int | Baz (f (Foo f))
09:15:37 <remexre> and I wanna write an instance Arbitrary (f (Foo f)) => Arbitrary f
09:16:41 <phadej> remexre: check Arbitrary1 class
09:16:58 <phadej> instance Arbitrary1 f => Arbitrary (Foo f) where ...
09:17:20 <remexre> er, change Bar Int to be Bar (Foo f) Int (Foo f)
09:18:07 <remexre> my problem is that if f = Identity, then you end up getting infinitely huge trees
09:18:23 <remexre> since there's no way to pass down the size from sized
09:19:25 <phadej> you can use scale :: (Int -> Int) -> Gen a -> Gen a
09:19:40 <phadej> though, isn't Foo Identity infinite tree?
09:19:56 <remexre> uh..... yes. My real datatype does have leaf nodes
09:19:57 <phadej>  data Foo f = Bar (Foo f) Int (Foo f) | Baz (f (Foo f)) 
09:20:50 <remexre> would I want to do scale (1-) then? or scale (/2)?
09:21:00 <phadej> anyway. First, think how you'd generate Arbitrary List for data List = Nil | List Int
09:21:31 <phadej> the good way is to do: `arbitrary = sized gen where gen 0 = pure Nil; gen n = ... (gen (n - 1))
09:21:46 <phadej> similarly you can do for your type
09:21:58 <remexre> helper 0 = pure Nil; helper n = oneof [pure Nil, Cons <$> arbitrary <*> helper (n-1)]; arbitrary = sized helper; right?
09:22:15 <remexre> yeah, I have that
09:22:21 <phadej> yes. scale would work too, but it's worse as it would also scale other generators
09:22:22 <remexre> I think scale is what I needed
09:22:34 <phadej> i.e. generators of Int
09:22:48 <remexre> It shouldn't affect choose though, right?
09:22:57 <phadej> it will affect whole subtree
09:23:12 <phadej> so, it will
09:23:15 <remexre> but I mean, choose would still select from the range you pass it
09:23:22 <remexre> not scaling it by magic
09:23:30 <phadej> well, say you have some [] there
09:23:39 <phadej> list length is dependent on size
09:23:56 <phadej> (and in fact, the range of `Int` is dependent on size too)
09:24:22 <phadej> I'd recommend to first write fooGen :: ... => Gen (Foo f)
09:24:27 <remexre> okay, but if I'm using choose everywhere anyway, I'm fine?
09:24:30 <phadej> to make sure you don't accidentally recurse using the instance
09:24:48 <phadej> well, you aren't; because it's a convention you don't make obvious
09:24:59 <phadej> you'll need to write a comment, so you fellow co-worker would understand
09:25:04 <phadej> do it right the first time ;)
09:26:34 <phadej> I recommend writing standalone instance (usign Arbitrary1 constraint), as with Arbitrary (f (Foo f)) you cannot as easily control size
09:26:44 <phadej> (or in fact, you cannot)
09:27:13 <phadej> cannot... independently for your structure only
09:27:29 <phadej> Say, f = Either Int
09:27:31 <remexre> uhh... I don't get it, can you explain that again?
09:28:12 <phadej> start with genFoo :: Arbitrary f => Gen (Foo f); genFoo = sized helper where helper 0 = ...
09:28:43 <remexre> okay
09:47:43 <wolfman154> 10:46 wolfman154: In my custom keyboard layout I switched the symbols row with the numbers row, now when I press: mod + shift + number, to switch to a different workspace it does not work, how do I fix this ?
09:51:49 <chreekat> wolfman154: Since you're asking here, I guess you're asking about xmonad?
09:53:26 <wolfman154> chreekat: yes I can’t ask questions on xmonad because my nick is not setup (I’m on an irc app on my phone), that’s why I’m asking here.
09:54:34 <wolfman154> 10:47 wolfman154: 10:46 wolfman154: In my custom keyboard layout I switched the symbols row with the numbers row, now when I press: mod + shift + number, to switch to a different workspace it does not work, how do I fix this ?
09:56:45 <wolfman154> What do I need to do to fix this?
09:59:03 <wolfman154> 10:57 wolfman154: In my custom keyboard layout I switched the symbols row with the numbers row, now in xmonad when I press: mod + shift + number, to switch to a different workspace it does not work, how do I fix this ?
10:00:49 <flebron> Hi folks. I have a type that uses [Nat] as part of it, so for example T [1, 5, 5] -> T [8, 8]. I'd like to store these in a list, where their types vary, using existential quantification. I'd then like to map a function that *does* know what these types are (say, I have a g :: forall (p :: [Nat]). p, and I'd like to feed my functions with g.) How can I use ExistentialQuantification for this?
10:08:04 <wolfman154> 10:57 wolfman154: In my custom keyboard layout I switched the symbols row with the numbers row, now in xmonad when I press: mod + shift + number, to switch to a different workspace it does not work, how do I fix this ?
10:16:02 <jlamothe> So, I've got some function foo of type [a] -> [b] -> [c]. I'm pattern matching foo [] ys, foo xs [], and foo (x:xs) (y:ys) in that order, but ghc is complaining about incomplete pattern matching. Any ideas why?
10:21:59 <vivit> So in LYaHFGG in the chapter on custom types and typeclasses, it gives a syntax example for type definitions with numerals in it. Is this valid syntax?
10:22:17 <chreekat> wolfman154: what happens when you do mod + number ?
10:25:40 <chreekat> jlamothe: I can't reproduce. Looks like it should work
10:26:18 <wolfman154> chreekat: it does not work anymore because because I made a custom keyboard layout where I switched the symbols row with the numbers row , so I think maybe I need to change the keybindings?
10:27:26 <chreekat> wolfman154: remapping keys in X is not a pleasant experience (I just recently spent a week figuring out parts of it myself). I guess it depends how, and when, you do it.
10:28:34 <jlamothe> Found the problem.  I mispelled the function name on one of my matches.
10:28:57 <jlamothe> Hooray for bad test coverage.
10:29:05 <chreekat> jlamothe: hooray
10:30:57 <chreekat> wolfman154: seems like it should just work. After I use setxkbmap to change keys, xmonad works as one would expect (mod + shift + f does the same thing no matter where 'f' is)
10:32:14 <wolfman154> chreekat: my custom keyboard layout works fine, it’s just now some of the xmonad key bindings are not working , I’m not sure how to fix this because I’m new to xmonad?
10:34:39 <chreekat> wolfman154: and if you switch to a standard layout, do they work?
10:35:33 <johnw> domenkozar: is there documentation on how to rewrite a StreamGenerator from earlier servant into a SourceT for new servant?
10:36:36 <fresheyeball> hey out there
10:36:47 <fresheyeball> anyone know how to make jsaddle-warp serve the app on all urls?
10:36:57 <fresheyeball> https://github.com/tomsmalley/jsaddle/commit/28213e6af2ac5f448e361c7496ac770406c17206
10:37:02 <fresheyeball> according to this it does already
10:37:09 <fresheyeball> but when I visit /alasdlkajsd
10:37:12 <fresheyeball> I get Forbidden
10:37:39 <wolfman154> chreekat: yes all the key bindings work in default us layout, but in my custom layout, some aren’t working (for example in the top row of my keyboard the the symbols row and numbers rows are switched 
10:38:47 <chreekat> wolfman154: ohhh I get it. I mean, I don't *get* it, but I bet it's because rather than xmonad seeing "mod + shift + 1", it's seeing "mod + shift + !"
10:38:58 <fresheyeball> elvishjerricco: I think you know this one for some reason
10:39:22 <wolfman154> chreekat: exactly!!!
10:40:11 <chreekat> wolfman154: i wouldn't know off and how to fix :D Except maybe customize all your bindings to make xmonad expect symbols rather than numbers. Sounds like misery, though, since then you've got a tight dependency on the key config
10:41:27 <wolfman154> chreekat: do you know a link with instructions on how to do this (I’m new to xmonad)?
10:44:23 <chreekat> wolfman154: I recommend just copying wildly from the 'default config' , http://hackage.haskell.org/package/xmonad-0.15/docs/src/XMonad.Config.html
10:44:53 <johnw> domenkozar: maybe this is where servant-conduit can come in...
10:45:01 <chreekat> wolfman154: gotta go, gl
10:45:58 <wolfman154> chreekat: thanks and later 
10:59:14 <remexre> so my tests are https://p.acm.umn.edu/WoNh1yha0AA= and it's still infinitely looping
11:00:00 <remexre> the instance (Arbitrary1 c, Default a) => Arbitrary (Expr c a) and instance Arbitrary1 Holed.ExprCustom both don't loop (themselves)
11:06:17 * hackage coya 0.1 - Coya monoids  https://hackage.haskell.org/package/coya-0.1 (chessai)
11:15:31 <remexre> (phadej this is the same thing as before, but the real code)
11:16:12 <phadej> remexre: what loops there?
11:17:03 <remexre> the Holed.exprFromValue . pp == id one, so I assume the Arbitrary Expr one
11:18:43 <phadej> try with helper (n - 1) changed to helper 0
11:19:01 <phadej> to be sure that it's actually loopiung, and just insanely large
11:19:31 <phadej> I often use `div` 2 or intLog2 (from http://hackage.haskell.org/package/integer-logarithms-1.0.2.2/docs/Math-NumberTheory-Logarithms.html)
11:19:48 <phadej> *and not simply insanely large
11:20:49 <remexre> oh, huh, looks like that may have been it
11:21:26 <remexre> huh, with (helper (n `div` 2)) it still takes "forever" tho
11:23:35 <remexre> (n `div` 100) is fine though... I guess I'll just need to tune it?
11:23:49 <phadej> intLog2 is good one :)
11:24:21 <phadej> % import Math.NumberTheory.Logarithms
11:24:21 <yahb> phadej: ; <no location info>: error:; Could not find module `Math.NumberTheory.Logarithms'; It is not a module in the current program, or in any known package.
11:24:37 <phadej> % import Data.Scientific
11:24:37 <yahb> phadej: ; <no location info>: error:; Could not find module `Data.Scientific'; It is not a module in the current program, or in any known package.
11:24:39 <phadej> :(
11:24:42 <phadej> ok, I cannot demo
11:25:28 <phadej> Prelude Math.NumberTheory.Logarithms> take 10 $ iterate (\x -> intLog2 (x + 1)) 100
11:25:28 <remexre> alright, I'll assume it does what it says on the tin
11:25:31 <phadej> [100,6,2,1,1,1,1,1,1,1]
11:25:50 <remexre> so I should change helper 0 to helper 1 then, right?
11:26:51 <phadej> intLog2 intLog2 1 = 0
11:26:55 <phadej> intLog2 1 = 0
11:27:18 <remexre> er wait you did x+1
11:27:45 <phadej>  take 10 $ iterate (\x -> intLog2 (max 1 x)) 100
11:27:45 <phadej> [100,6,2,1,0,0,0,0,0,0]
11:27:50 <phadej> better
11:28:35 <phadej> 1 + 1 = 2; intLog2 2 = 1
11:28:36 <ski> `unfoldr' ?
11:28:37 <phadej> that's why
11:30:04 <phadej> I'm not sure, if intLog2 . max 1 is so common, that I should just add it to the integer-logarithms
11:30:34 <ski> why do you need/want to handle `0' ?
11:32:02 <remexre> so I have a base case
11:32:45 <remexre> and if the base case is 1 and intLog2 0 is undefined, then i still need a 0 case
11:33:57 * ski didn't follow what exactly remexre wants to do
11:34:17 * hackage ring-buffers 0.1.0.1 - mutable ring buffers with atomic updates in GHC Haskell  https://hackage.haskell.org/package/ring-buffers-0.1.0.1 (chessai)
11:34:20 <remexre> generating expressions for an Arbitrary instance (in quickcheck)
11:34:45 <remexre> (intLog2 . max 1) seems to be looping
11:34:52 <remexre> or insanely large
11:35:07 <ski> instance for which type ?
11:35:26 <remexre> https://p.acm.umn.edu/WoNh1yha0AA= the instance (Arbitrary1 c, Default a) => Arbitrary (Expr c a)
11:36:19 <ski> i don't see any `helper' in that one
11:36:40 <remexre> er it's in arbitraryHelper'
11:36:44 <remexre> which it uses
11:39:22 <ski> hm, and you want to use `div' or `intLog2', how ?
11:39:42 <remexre> instead of (n-1), some other expression
11:39:48 <remexre> looks like n `div` 10 works
11:40:19 <ski> would that be for efficiency, or for changing the distribution ?
11:40:31 * ski supposes the latter
11:40:47 <phadej> "former"
11:41:01 <phadej> to make recursion end faster
11:41:57 <ski> hmm .. vaguely similar to how you can compute exponentiation more efficienctly, by using `divMod' ?
11:43:01 <phadej> it's not about that
11:43:09 <ski> mhm
11:43:17 <phadej> `div` 10 makes trees at most 3 deep with default 10 size
11:43:55 <phadej> default 100 size
11:44:08 <phadej> intLog2 . max 1 makes them 4 deep
11:44:23 <phadej> that might matter already
11:45:12 <ski> sometimes i wonder if it would be nice if for `Gen'-actions (or similar) you could report "how large size" you actually used, so that you could accordingly adjust sizes of sibling structures
11:45:46 <ski> phadej : that sounds to me as it being about changing the distribution
11:46:36 <phadej> well, it's not so much distribution tweaking at this stage, as to make it generate even something reasonable :)
11:46:58 <ski> ok, so a very crude aspect of distribution design, then ?
11:47:04 <ski> re remexre
11:48:03 <remexre> sorry, machine died from oom from that test :P
11:48:10 <remexre> to try to avoid literally that
11:49:32 <phadej> :)
11:51:27 <ski> (hm, also the notion of "size" in `Gen', at least to my knowledge, seems a bit vague .. which is probably not that good, with there being instances under constraints, like `Arbitrary a => Arbitrary (Foo a)')
12:07:32 <wolfman154> Does anyone know a way to change key bindings in xmonad?
12:15:10 <MasseR> wolfman154: xmonad site and wiki should have plenty of guides and examples. If that doesn't help, try out #xmonad
12:15:43 <wolfman154> MasseR: thanks I’ll keep looking.
12:18:05 <isn> Hey
12:19:01 <isn> I’m trying to calculate all multiples of 3 of 5 using Haskell recursively. However it’s not worked as it should. Can someone help me out with this?:
12:19:01 <isn> som a = if a `mod` 3 == 0 || a `mod` 5 == 0 then a else 0
12:19:01 <isn> som2 a 0 = a
12:19:03 <isn> som2 a b = (a + (som a)) (b - 1)
12:19:29 <isn> I expect 23 for: som2 0 10
12:23:19 <[exa]> isn: by 'all multiples of 3 of 5' you mean 'all multiples of 3 and 5' ?
12:24:20 <isn> Well, I'm supposed to call som2 0 10. 0 as the starting "sum" and 10 for the index. The 10 means, it will go through 10, 9, 8, 7, etc. and if its a multiple of 3 or 5, it adds it up to the total sum
12:24:33 <dmj`> takeWhile (\x -> x `mod` 3 == 0 && x `mod` 5 == 0) [ 1.. ]
12:25:30 <[exa]> dmj`: that's empty but certainly shows the way :]
12:25:47 <dmj`> right, he can "take" it from there ;)
12:26:04 <Solonarv> no, no - it's *empty*
12:26:07 <isn> nice, thanks! :)
12:26:11 <Solonarv> > takeWhile (\x -> x `mod` 3 == 0 && x `mod` 5 == 0) [ 1.. ]
12:26:13 <lambdabot>  []
12:26:20 <isn> but I'm trying to solve it just recursively
12:26:23 <infinisil> Needs more Control.Arrows!
12:26:27 <isn> wiht the simple functions
12:26:34 <[exa]> needs generalized type-level sets!
12:27:33 <[exa]> isn: btw I still kindof fail to parse the problem-- why would the thing output 23 for 'som2 0 10' ?
12:27:33 <dmj`> takeWhile (\x -> x `mod` 3 == 0 || x `mod` 5 == 0) [ 1.. ]
12:27:35 <dmj`> :)
12:28:11 <Solonarv> presumably: 3 + 5 + 6 + 9
12:28:16 <[exa]> dmj`: that list is infinitesimally less empty :]
12:28:17 <Solonarv> no, not takeWhile - you want filter
12:28:25 <dmj`> [exa]: that's good :)
12:28:29 <isn> Well, because when we count from 10 to 0, the only numbers that are multiples of 3 and 5 are: 3, 5, 6 and 9. If we add them up we get 23
12:28:36 <[exa]> dmj`: yeah I like the difference
12:28:38 <[exa]> :]
12:28:50 <[exa]> isn: oooh sooo. sorry. :]
12:28:55 <isn> :)
12:29:23 <isn> np, it's not a really realistic problem, but it's the first problem on project euler :p
12:29:51 <[exa]> isn: so let's do an induction! what's the easiest case of the problem you can solve?
12:30:50 <isn> uhm, this line that returns the number if its multiple of 3/5, otherwise 0: som a = if a `mod` 3 == 0 || a `mod` 5 == 0 then a else 0
12:31:12 <isn> I want to recursively call that function
12:31:49 <[exa]> yeah that creates a sum of the multiples, only just over interval of size 1
12:32:34 <kadoban> Is there a harder version of that problem (higher limit) on PE, or is that the only one?
12:32:36 <fresheyeball> My dudes. Naturality is blowing my mind. That is all
12:33:02 <isn> Not sure, probably. It's literally the first problem on the site
12:33:35 <[exa]> isn: which you tried to solve using the accumulator-based recursion, which is a good choice, except for you're using the accumulator in one place where you should not
12:34:10 <[exa]> (and not recursing in the recursive case, ofc.)
12:35:15 <isn> What do you mean in one place?
12:36:12 <[exa]> let's view it as an imperative cycle. a=0; b=n; while(b>0) {a = a+ (what here?); b=b-1; }. You can easily rewrite that to recursion right after that
12:37:19 <[exa]> questions: 1] how does recursion decide whether to continue or not? 2] what 'som' are you computing in the empty place
12:37:58 <lukelau> Better way of writing `mapM (mapM (mapM f)) x` ?
12:38:00 <isn> (what here) should be b
12:38:29 <isn> I mean som(b)
12:39:22 <isn> 1] if the base case is not met, so if we count back (b) from 10 to 0, 0 is the base case in my "not working solution"
12:39:57 <isn> 2] just the value that we want to add to the current sum, so add 0 if not multiple of 3/5, or add the number
12:41:45 <ski> lukelau : maybe `(mapM . mapM . mapM) f x' ?
12:42:03 <Solonarv> ski++
12:42:18 * ski twitches
12:43:21 <lukelau> ski: i might as well at this point
12:43:22 <lukelau> +1
12:43:40 <dmwit> lukelau: If you can, it may be worthwhile to rearrange your code so that it is merely `mapM f x`.
12:44:09 <ski> (perhaps by judicious use of `newtype's)
12:45:10 <dmwit> (Worth it why? Not because of this code snippet, but because you will be thinking about the data in a different way, in bigger chunks -- a neuroscience-endorsed form of abstraction.)
12:53:47 * hackage text-trie 0.2.5.0 - An efficient finite map from Text to values, based on bytestring-trie.  https://hackage.haskell.org/package/text-trie-0.2.5.0 (lambdamichael)
12:54:13 <nshepperd> 'newtype Foo t a = Foo <paste your type here> deriving (Functor, Foldable, Traversable)' is a powerful incantation
13:03:01 <_kwstas> hi there! qq: I have an AST with 20+ data constructors and a list of element of this AST. Is there any way to group the elements based on their data constructor? (apart from the use of `groupBy` where I would manually have to define the grouping function )
13:07:03 <Solonarv> _kwstas: what do the AST's constructors look like? do they have fields?
13:09:11 <_kwstas> Solonarv: Yes there are ~30 constructors with 2-3 fields etch
13:09:15 <_kwstas> *each
13:09:48 <Solonarv> hm
13:09:49 <Solonarv> oh!
13:10:14 <Solonarv> there is a dataToTag# :: a -> Int# function somewhere
13:10:21 <Solonarv> there might be a lifted version as well
13:10:33 <Solonarv> % :t dataToTag
13:10:33 <yahb> Solonarv: ; <interactive>:1:1: error:; * Variable not in scope: dataToTag; * Perhaps you meant `dataToTag#' (imported from GHC.Exts)
13:11:31 <[exa]> isn: /me got afk, sorry. The problem of your solution is that there's no recursion (at least in the code you posted I don't see any)
13:11:48 * ski . o O ( "Tagalog" )
13:11:49 <Solonarv> % dataToTag x = I# (dataToTag# x)
13:11:49 <yahb> Solonarv: 
13:11:55 <Solonarv> % :t dataToTag
13:11:56 <yahb> Solonarv: a -> Int
13:12:05 <Solonarv> _kwstas: use that for grouping
13:12:14 <Solonarv> % dataToTag (Left ())
13:12:14 <yahb> Solonarv: 0
13:12:21 <Solonarv> % dataToTag (Right 3)
13:12:21 <yahb> Solonarv: 1
13:13:08 <isn> [exa]: I've fixed it already
13:13:15 <Solonarv> % dataToTag !x = I# (dataToTag# x) -- better
13:13:15 <yahb> Solonarv: 
13:13:20 <isn> This is what I have now:
13:13:22 <isn> module MainModule where
13:13:22 <isn>     som a = if a `mod` 3 == 0 || a `mod` 5 == 0 then a else 0
13:13:22 <isn>     som2 (a, 0) = (a, 0)
13:13:24 <isn>     som2 (a, b) = som2 (a + som b, b - 1)
13:15:11 <Solonarv> _kwstas: does that help?
13:15:36 <trcc> Which group of functions does a function like sequence belong to? Is it monads or functors or?
13:15:38 <isn> [exa]: thank you for helping :)
13:15:57 <_kwstas> Solonarv: so, if I understand correct, this function return the position of the data constructor?
13:16:09 <Solonarv> _kwstas: yup
13:16:32 <Solonarv> should probably avoid calling it on non-ADTs though
13:16:48 <Solonarv> trcc: observe:
13:16:48 <Solonarv> % :info sequence
13:16:48 <yahb> Solonarv: class (Functor t, Foldable t) => Traversable (t :: * -> *) where; ...; sequence :: Monad m => t (m a) -> m (t a); -- Defined in `Data.Traversable'
13:17:00 <trcc> ahh
13:17:12 <trcc> so it is a traversable
13:17:16 <_kwstas> Solonarv: cool! I'll give it a try! thx a lot!!
13:17:23 <Solonarv> no, it is a method that belongs to the Traversable class
13:19:00 <zincy> Looking back at this I forgot how to encode a loop with many ops inside
13:19:03 <zincy> data Op = MoveRight | MoveLeft | Inc | Dec | ReadStdIn | WriteStdOut | Loop Op deriving Show 
13:19:23 <Solonarv> you use a list
13:19:27 <Solonarv> ... | Loop [Op]
13:19:31 <trcc> Solonarv: okay. Thank you
13:19:36 <Solonarv> (or some other list-like data type, of course)
13:19:47 * hackage haskell-lsp-types 0.8.2.0 - Haskell library for the Microsoft Language Server Protocol, data types  https://hackage.haskell.org/package/haskell-lsp-types-0.8.2.0 (AlanZimmerman)
13:20:15 <zincy> Wow I shouldn't program in bed 
13:20:17 <zincy> thanks :)
13:20:47 * hackage haskell-lsp 0.8.2.0 - Haskell library for the Microsoft Language Server Protocol  https://hackage.haskell.org/package/haskell-lsp-0.8.2.0 (AlanZimmerman)
13:20:50 * hackage haskell-src-exts-util 0.2.5 - Helper functions for working with haskell-src-exts trees  https://hackage.haskell.org/package/haskell-src-exts-util-0.2.5 (PepeIborra)
13:34:19 <_kwstas> Solonarv: Update: I wasn't able to use dataToTag, but your suggestion pointed me to a SO related question where the Typeable/Data classes and the toConstr method are suggested to be used for constructor equality check. Thx again!
13:34:35 <Solonarv> oh yeah I keep forgetting Data still exists
13:35:44 <_kwstas> what do you mean by *still*? Is it going to be removed/replaced by something else?
13:35:57 <Solonarv> no, not as far as I know
13:36:20 <Solonarv> but there is also the Generic machinery, which covers some of the use cases for Data
13:36:46 <_kwstas> oh, I see
13:39:22 <jakov> Hi ! I was wondering, if it's possible to compile stack packages for a raspberry Pi on a more powerful computer? 
13:39:22 <jakov> Is there any known method to generate llvm code, and compile it to armvl7, and then just copy the .stack-work/ directory ?
13:40:38 <jakov> The reason for not compiling on the raspberry pi is just time and memory. For some http-conduit, hxt and aeson it took me about 4 hours of waiting.
13:41:20 <MarcelineVQ> this is known as cross compiling, angerman (in this channel) might be able to point you in the right direction. some related posts here https://medium.com/@zw3rk
13:43:40 <Solonarv> TL;DR: possible, but a bit fiddly
13:44:00 <Solonarv> I don't know how well stack in particular supports cross-compilation; most of what I've heard about uses nix
13:49:48 <jakov> okay, i have nixos installed, and i have just passed the barrier, of writing my own nix expressions :). MarcelineVQ, thanks for pointing to the link ! I have read his articles, and thought about the possiblility of intergrating the cabal packages  into a working stack installation. I don't know stack well enough to tell if it's possible ...
13:50:32 <jakov> Or does cross compiling mean, in the case of the raspberry, that i am forced to use cabal ?
13:52:08 <jakov> PS: I know what cross compiling means. I mean:  Under the circumstances of the ghc tooling environment, does it mean that using cross compiled packages is easier with cabal ? 
13:54:33 <MarcelineVQ> dunno I've never done it
14:04:41 <jakov> Is it possible to do cross compilation by generating llvm code, and then compiling the llvm code to a certain platform ?
14:17:29 <geekosaur> possible, yes, and that's generally how ARM builds were done in the past. but manually, and I don't think any of the tooling directly supports is
14:17:31 <geekosaur> *it
14:25:28 <rhitakorrr> Hey folks - I'm having some trouble getting language extensions to work. If I put my language extensions under other-extensions: in my cabal file, they don't take. They do work if I put them under extensions: or default-extensions:.
14:25:54 <rhitakorrr> I am including the {-# LANGUAGE ... #-} bit in my code as well.
14:26:15 <glguy> rhitakorrr: It sounds like you figured it out
14:26:19 <glguy> https://www.haskell.org/cabal/users-guide/developing-packages.html?highlight=other%20extensions#pkg-field-other-extensions
14:26:46 <glguy> other-extensions just means you want to check at configure time that those extensions are supported
14:26:55 <glguy> you still have to manually enable them in each module
14:27:11 <rhitakorrr> glguy: Yep - still doesn't seem to work if I manually enable them, though.
14:27:37 <glguy> Then you've got some other non-.cabal file related bug
14:27:54 <glguy> like a typo in the language pragma or you're putting it in the wrong module or you're using the wrong extension
14:28:03 <MarcelineVQ> what isn't working and how do you know?
14:28:05 <glguy> Can you show the file and the error message?
14:29:19 <rhitakorrr> Yep - give me a sec to toss it into a gist
14:29:58 <geekosaur> also note that LANGUAGE pragmas must be the first thing in the file
14:30:08 <Solonarv> jakov: obsidian systems has some stuff for compiling to ARM (they target android), perhaps looking at that might help
14:30:13 <geekosaur> once parsing has started, it's too late to specify which parser elements to use
14:30:43 <rhitakorrr> geekosaur: Oh... that might be it
14:30:45 <rhitakorrr> Sec
14:31:42 <rhitakorrr> geekosaur:  Yup, that did it. I had them after my module header.
14:31:53 <rhitakorrr> Thanks! :)
14:33:11 <orion> Hey all. I'm using persistent-sqlite, and I have the following schema: https://gist.github.com/centromere/82ebe41da02ec10978f4fbdb4c0bf8ac The migration it generates is: CREATE TABLE "user" (..., "short_name" VARCHAR NOT NULL, ..., PRIMARY KEY ("id")). Why isn't a UNIQUE constraint generated?
15:11:30 <cjay-> is there a good reason why there is no uncurry3 to uncurry7 in base, while zip3 to zip7 are there?
15:12:36 <kadoban> Probably not really
15:13:07 <kadoban> Depends on your definition of "good". My guess would be nobody seemed to need them
15:13:36 <Cale> Good point, we should remove zip3 through zip7
15:14:13 <MarcelineVQ> when zipWith3-7 exists too, sure why not :>
15:14:21 <cjay-> is there a better alternative to a combo of zipX and uncurryX?
15:14:39 <cjay-> maybe a newtype wrapper for list that does applicative zipping?
15:15:00 <Cale> Usually just not using tuples, and instead making data types that explain what you're doing better
15:15:26 <Cale> also, uncurry is usually better served by a lambda
15:15:39 <jle`> i think a major reason why zipN but not uncurryN is because ... you shouldn't really ever use a tuple bigger than 2
15:15:50 <jle`> but it's very common to have functions with more than two arguments
15:15:56 <jle`> (and also to have more than two lists)
15:16:15 <jle`> hm, the second reason is more compelling than the first, since the first applies to both
15:16:36 <jle`> but yeah, you shouldn't relaly ever have a tuple of size bigger than 2.  but it's very common to have more than two lists
15:16:42 <jle`> so that's probably a big reason why
15:19:13 <cjay-> I see the point of never using tuples bigger than 2 as a data structure, but isn't zipping a special case?
15:19:44 <Cale> You can always zipWith more than once
15:21:29 <Cale> and yeah, it's possible to use ZipList for the once-in-10-years case that you ever actually need that
15:23:05 <Cale> It really almost never comes up that you have lists coming from various different sources whose elements are meant to carefully align in that way. Usually you at *least* have a bunch of Maps or something keyed.
15:23:53 <Cale> and then you can unionWith or intersectionWith, or use the new merge stuff.
15:25:40 <cjay-> I'm interacting with low level bindings to a C library, so it's not idiomatic Haskell code
16:34:47 * hackage ffunctor 1.1.99 - FFunctor typeclass  https://hackage.haskell.org/package/ffunctor-1.1.99 (fommil)
16:52:09 <zachk> are lts releases for stackage static in nature after they are released?
16:52:37 <hpc> i think so
16:52:39 <MarcelineVQ> They're intended to be, it's probably not impossible for bugfixes to occur
16:52:51 <hpc> they're versioned
16:53:07 <hpc> so you can track lts 8, and update from 8.5 to 8.6, or something like that
16:54:21 <zachk> how would I find the latest lts that provides intero?
16:54:39 <Solonarv> go to stackage.org, search for intero
16:55:19 <Solonarv> on the main page for intero it tells you the latest LTS with that package in it
16:55:39 <Solonarv> https://stackage.org/package/intero
16:55:49 <Solonarv> 9.21, yikes
16:56:20 <zachk> intero on hackage seems to support 8.6.4 but to the best of my knowledge intero uses stackage
16:56:45 <Solonarv> 'stack install <package>' can use versions of <package> that are not in the snapshot you're using
16:57:00 <Solonarv> as long as all its dependencies are in the snapshot there's no problem
16:57:45 <Solonarv> so 'stack build --copy-compiler-tool intero-0.1.39 --resolver lts-13.16' should work, methinks
16:57:59 <MarcelineVQ> I wonder why it's not on recent stackage, it's an fpcomplete product
16:58:13 <Solonarv> yeah, strange
16:58:27 <zachk> intero in emacs was working fine, and the latest update seems to have broken it for me
17:17:04 <orion> If the OverloadedRecordFields proposal is adopted, will it obviate the need for records/vinyl/makeClassy?
17:18:04 <Solonarv> hmm, it might replace some use cases
17:18:09 <Solonarv> but not all of them
17:18:25 <Solonarv> for example vinyl gives you *anonymous* records - you don't have to define a new datatype
17:20:19 <orion> Have you ever used vinyl in production?
17:23:42 <Solonarv> I've never written anything I'd call production, but I have used vinyl a bit
17:24:08 <Solonarv> I quite like it tbh
17:24:55 <Cale> We don't use vinyl in production at Obsidian, but we do use a fair amount of DMap, and ordinary records. No DuplicateRecordFields either though.
17:29:03 <Solonarv> I'm not really a big fan of where GHC's record-related proposals seem to be going tbh
17:29:38 <OmegaDoug> I'm wondering if the Streamly library is a replacement or complement to Channels or TChannels
17:30:18 <Cale> I have a really dumb-sounding idea for an extension to records, but it might open up some new possibilities for abstractions in our projects
17:30:36 <Solonarv> I want to hear it
17:30:50 <hpc> dumb-sounding ideas are the best ideas
17:30:56 <Cale> Basically, to have the ability to define a record field as "ignored", to the extent that the compiler won't even reference check its contents.
17:30:56 <hpc> except when they aren't
17:31:30 <Cale> The idea is that we typically have our codebase split into three parts: frontend, common, and backend
17:32:26 <Cale> It would be nice if we could build data types which package things together related to the frontend and backend for the same feature.
17:32:55 <Cale> Where on the frontend, we'd mark the field(s?) related to the backend component of the widget as ignored
17:33:10 <Cale> They'd be necessarily inaccessible
17:33:20 <hpc> hmm
17:33:22 <Cale> On the backend, we'd have access to everything
17:33:35 <hpc> i have seen things like that before
17:33:36 <Cale> and we'd also be able to define higher order means of combining widgets together
17:33:44 <hpc> in minecraft modding, the client and server run the same code
17:34:04 <hpc> but you add annotations like ClientOnly or ServerOnly for specific pieces
17:34:07 <Solonarv> something like using typelevel computation to turn the fields into Void, but having compiler support to actually remove them completely, Cale ?
17:34:56 <Cale> Yeah, and where you don't have to have stubs for everything that you use on the backend which isn't compilable for the frontend
17:35:12 <hpc> i feel like there's a more general formulation of this
17:35:19 <Cale> Like, I don't want to have to work out how to get the postgresql library compiling to Javascript
17:35:22 <hpc> where you have two types defined and some sort of relationship between them
17:35:44 <hpc> with the relationship being kind of like maybe a type family but in both directions?
17:36:10 <Solonarv> type families can be injective!
17:36:27 <Cale> It's important that we don't go as far as the typechecker
17:36:52 <hpc> yeah, it wouldn't be exactly equal to type families
17:37:08 <hpc> it reminds me of irrelevance as well
17:37:51 <hpc> like if you could parameterize irrelevance in some way
17:41:20 <Solonarv> hm, interesting
17:52:44 <dmwit> Cale: Perhaps the Trees that Grow approach could work here.
17:53:28 <dmwit> Instead of the different compiler phases, your type parameter would take on the values Frontend or Backend.
17:54:35 <Cale> dmwit: Maybe, but that doesn't solve the problem that I want the backend bits to have all sorts of references to code that I can't compile on the frontend
17:55:55 <Cale> (The goal being that we write our application all in one place with a minimal amount of conditional compilation.)
17:59:35 <dmwit> uh
17:59:44 <Squarism> Just curious. But what would be the problem of introducing function overloading for fixing record fields?
17:59:51 <dmwit> I think the proposal you're making is a bit more far-reaching than a modification to the record system.
18:00:10 <dmwit> What is function overloading? What problem does it solve?
18:00:30 <dmwit> (Records have multiple problems.)
18:00:40 <Cale> dmwit: In what way?
18:00:42 <Squarism> oh ok. Just curious
18:01:16 <Cale> dmwit: It should be fairly easy to implement: if a record field is marked as ignored, it gets immediately discarded after parsing.
18:01:22 <dmwit> Cale: I mean, it sounds like you maybe want to be able to skip dependending on certain packages, skip importing modules, skip type-checking and compilation of certain code...
18:01:45 <Cale> dmwit: Well, we still have CPP hanging around
18:02:22 <dmwit> If you're willing to CPP, then I don't understand "that doesn't solve the problem that I want the backend bits to have all sorts of references to code that I can't compile on the frontend".
18:02:23 <Cale> (But yeah, there are a bunch of other things that would help as well...)
18:03:02 <dmwit> (Because it's not a problem in the first place if you're willing to CPP.)
18:03:44 <Cale> Well, I'm willing to CPP for imports, and for the definition of a single "widget" datatype (field either gets ignored or not)
18:03:58 <Cale> but I don't want CPP polluting all the actual widget code
18:04:51 <dmwit> Presumably for the backend phase most of the fields will just be (). No CPP needed at use sites.
18:04:54 <Cale> and I want to be able to define algebraic operations on these things which are meaningful on both the frontend and backend for composing these widgets, but only half of the code makes it into the compiled frontend
18:05:01 <dmwit> But you will need to CPP out any code you don't want compiled. Don't see how to avoid that.
18:05:10 <Cale> For the backend, everything is accessible
18:05:25 <dmwit> Yes, Trees that Grow lets you do those things.
18:05:41 <dmwit> You typeclass the operations, and make an instance for Frontend and an instance for Backend.
18:05:48 <dmwit> CPP out the Frontend instance as appropriate.
18:05:52 <Cale> Well, this feature I'm talking about would effectively be like CPP-ing out every occurrence of a particular field
18:06:38 <Cale> and so, the fact that the backend fields contain references into database libraries (which are conditionally included) isn't a problem
18:07:18 <dmwit> Suppose the only field of Identity was intended to be CPP'd out in the current variant. Would you want `x = Identity y where y = 3` to become `x = Identity where y = 3` or `x = Identity`?
18:07:38 <dmwit> If the latter, then we're back to what I was saying before: you want automatic detection and elimination of dead code, a v. big feature.
18:08:24 <Cale> For what I'm proposing, it would become x = Identity where y = 3, and then you'd have a problem if 3 wasn't in scope.
18:08:51 <Cale> (I'm only proposing a very simple thing)
18:08:55 <dmwit> Okay. I don't like this proposal. It means that apparently benign refactorings suddenly stop working code from working.
18:09:28 <dmwit> Being able to name just about any subterm (provided you give some type hints on occasion) is... pretty central to how I think about programming.
18:10:40 <wolfman154> I was wondering if you guys could help me with a Haskell and xmonad problem, I’m new to both of these?
18:10:52 <dmwit> wolfman154: Please register with NickServ. Then ask in #xmonad.
18:11:38 <Cale> wolfman154: I think it's okay to ask here as well... often #xmonad is a bit dead
18:12:47 <wolfman154> dmwit: I’m on my phone, and I’m going to reinstall nixos tomorrow so I don’t have the time right to setup nick.
18:13:27 <Cale> wolfman154: Let's start with the Haskell question
18:15:48 <Clint> 2/win go #linguistics
18:15:52 * Clint sighs.
18:19:21 <wolfman154> I switched to a new keyboard layout in nixos, after I finally got it working I noticed my workspaces do not work because I switched the symbols row with the numbers row, I think I found the solution online but I don’t understand it that well, here’s the two links to my key map and the solution I found online:  https://hastebin.com/adefayujob.xml     https://unix.stackexchange.com/questions/68691/r
18:19:21 <wolfman154> emapping-keys-for-workspaces-in-xmonad#68709   
18:19:49 <wolfman154> https://unix.stackexchange.com/questions/68691/remapping-keys-for-workspaces-in-xmonad#68709
18:20:27 <wolfman154> https://hastebin.com/adefayujob.xml
18:21:11 <wolfman154> Paste problems with phone, here’s these two links should work 
18:22:59 <wolfman154> Cale: do you understand what I’m trying to do?
18:24:09 <Cale> I don't really understand what difficulty you're having, but if you can phrase it as a Haskell question, I can probably answer it
18:24:22 <Cale> I don't use XMonad, but I can read its documentation :P
18:25:47 * hackage metar 0.0.3 - Australian METAR  https://hackage.haskell.org/package/metar-0.0.3 (TonyMorris)
18:26:00 <Cale> Like, what about the given solution isn't working?
18:27:17 <Lears> wolfman154: Someone recently had a similar issue with czech keyboard layout on /r/xmonad, you can see my answers to that there (the second approach is better): https://www.reddit.com/r/xmonad/comments/badzx0/switching_workspaces_not_working/
18:27:27 <wolfman154> Cale: I’m just trying to remap the workspace key bindings to my custom keyboard layout I just paste bined, in order to get the workspace key bindings working again 
18:29:29 <Cale> wolfman154: Isn't it just a matter of figuring out which keys you want them on, and writing some bindings?
18:29:47 <wolfman154> Lears: this solution looks easier but I’m not sure how to do it: 19:19 wolfman154: https://unix.stackexchange.com/questions/68691/remapping-keys-for-workspaces-in-xmonad#68709
18:30:14 <Cale> wolfman154: Do you already have some keybindings in your xmonad config?
18:30:18 <wolfman154> Lears: using my custom keyboard layout: 19:20 wolfman154: https://hastebin.com/adefayujob.xml
18:30:35 <Cale> What's your xmonad.hs currently look like?
18:31:39 <wolfman154> Cale: ok I’ll paste bin it now, like I said I’m still a beginner with Haskell 
18:31:53 <wolfman154> Cale: one second 
18:33:23 <Lears> The super basic solution on SE is just manually writing all 18 keybindings that the list comprehension in my link generates.
18:33:56 <Lears> And it's the same as adding any other kind of keybinding, so the basic solution is just knowing how to do that.
18:35:22 <wolfman154> Well let me just paste bin my xmonad.hs, so you guys could help me with the syntax, I have a 3 year Java background but I am new to Haskell, so please have some patience 
18:36:26 <Lears> https://wiki.haskell.org/Xmonad/General_xmonad.hs_config_tips#Adding_your_own_keybindings
18:40:16 <wolfman154> Cale: Lears:    https://hastebin.com/mosilitexu.coffeescript
18:41:10 <wolfman154> Cale: Lears: if you could really quick help me with the syntax ?
18:41:38 <wolfman154> 19:20 wolfman154: https://hastebin.com/adefayujob.xml
18:41:56 <wolfman154> 19:19 wolfman154: https://unix.stackexchange.com/questions/68691/remapping-keys-for-workspaces-in-xmonad#68709
18:42:04 <Cale> (I'm not sure what we're meant to do with that nix keymap...)
18:42:21 <wolfman154> Cale: Lears: using these two links 
18:42:22 <Cale> But sure, I can help with adding any keybindings at all
18:42:44 <Lears> There's nothing pre-existing in your config to work around, so the link I just posted should already tell you how to go about adding those keybinds.
18:43:12 <Cale> Yeah, just have a look at the "Adding_your_own_keybindings" link
18:43:46 <wolfman154> Cale: thanks I’m a little lost, I know for sure the workspaces are not working because of my keyboard layout change 
18:46:06 <wolfman154> Cale: Lears: this last link I just posted looks much easier, I’m just not sure on the syntax?
18:46:10 <Cale> So you'll want to start out by adding the import of Data.Map like they have it there, and then you can actually steal their definition of keys
18:46:50 <Cale> and in fact, probably the definition of mykeys as well, except you'll want to change that list after the $ 
18:47:25 <Cale> You can also put mykeys at the top level rather than sticking it into a where clause if you prefer
18:47:37 <Lears> The relevance of your change of keyboard layout is just that the current keybindings are to, e.g. (mod4Mask, xK_1), which you can no longer produce. xK_1 is wrong, since you've replaced that key with xK_question, and xK_2 with xK_percent, etc.
18:47:46 <Cale> It's not like the namespace in your xmonad.hs is all that cluttered ;)
18:48:54 <wolfman154> Well could you paste bin the syntax with the correct key swaps, I’ll paste bin the links again 
18:49:06 <wolfman154> 19:41 wolfman154: 19:19 wolfman154: https://unix.stackexchange.com/questions/68691/remapping-keys-for-workspaces-in-xmonad#68709
18:49:17 <Cale> We already have that link, don't we?
18:49:18 <wolfman154> 19:41 wolfman154: 19:20 wolfman154: https://hastebin.com/adefayujob.xml
18:49:30 <Cale> stop repeating it :)
18:50:00 <wolfman154> Cale: sorry just making sure we’re looking at the same links 
18:50:52 <Cale> wolfman154: So, Haskell uses square brackets around lists
18:52:05 <Cale> and the keymap is an associative data structure called a Map, which you can make from a list of pairs using M.fromList (if you have  "import qualified Data.Map as M")
18:52:15 <wolfman154> Cale: I just need help with the syntax , I’m still struggling with Haskell, could you paste bin some syntax so I see what you mean 
18:52:16 <slack1256> Ignorant question, How are `Async ()`s that comunicate via `TChan Message` different from the actor model?
18:52:57 <slack1256> specially when they are spawned via `withAsync ()` so they enjoy supervision semantics?
18:53:26 <Cale> slack1256: Not very different, but Async only does SMP parallelism and concurrency on a single machine.
18:53:27 <wolfman154> Cale: Haskell is completely different from Java   :(
18:54:10 <Cale> wolfman154: So, the first part of each of the pairs in our list is itself a pair, of the modifiers and the key that we want to bind
18:54:30 <Cale> wolfman154: and then the second part of the pair is which action we want to bind that key to
18:54:43 <Cale> (and we can write fairly arbitrary code there)
18:55:36 <Cale> So the only question should be which keys would you like to bind, and what do you want to bind them to?
18:57:49 <Cale> If the answer to that is something like "all the default keys, but I want to write some function to translate them according to my funky keymapping"... we can also do that, but it's more involved.
18:58:42 <wolfman154> Cale: Well basically just my workspaces, that is the top row where the numbers and symbols are, I want the key bindings remapped in the exact same locations as before, but I have to do it using my custom keyboard layout I paste bined earlier 
19:00:13 <Cale> So, e.g. you want to put  ((modm, xK_percent), windows $ W.greedyView "2")  in the list?
19:00:21 <geekosaur> btw you can't speak in #xmonad because we currently require nickserv authentication, due to a spam attack several months ago. I don't know who has ops in there to change it
19:01:14 <Cale> I'd recommend starting out by just doing each one by hand, one at a time, and figuring out how to clean up that code after
19:01:29 <Cale> Start by trying to just get one additional keybinding working
19:02:48 <Cale> wolfman154: You saw Lears' link to the xmonad wiki, right?
19:04:40 <wolfman154> Cale: I think the other keybindings work correctly, but I’ve only checked a few of them, anyways  for example:  looking at my custom keyboard layout: I’d like to be able to press mod + question for workspace 1 and mod + shift + 1 to shift the window to workspace 1 , just like before?
19:05:23 <Cale> wolfman154: Yeah, so if you can get one new keybinding working, it should be easy from there, right?
19:05:41 <wolfman154> Cale: exactly!!!
19:05:55 <Cale> Did you follow the example on the wiki?
19:07:00 <wolfman154> Cale: hopefully, and yeah I looked at it and I’m still not sure on the syntax, I’m just so used to Java 
19:07:27 <Cale> You should almost be able to copy-paste the syntax...
19:08:39 <Cale> You might want to try that XMonad.Util.EZConfig module in xmonad-contrib
19:08:48 <wolfman154> Cale: could you repaste it, I’m not sure if I’m looking at the right link
19:09:05 <Cale> https://wiki.haskell.org/Xmonad/General_xmonad.hs_config_tips#Adding_your_own_keybindings
19:10:06 <Cale> You could just add on an `additionalKeysP` with a list of the bindings like they show in the second example, if that module is available
19:11:10 <Cale> But perhaps the first example is more straightforward, because it doesn't require you to have xmonad-contrib installed
19:11:26 <wolfman154> Cale: I’m going to have to look at the util.ezconfig for a while because I’m still confused 
19:11:44 <Cale> http://hackage.haskell.org/package/xmonad-contrib-0.15/docs/XMonad-Util-EZConfig.html
19:11:57 <Cale> There's the documentation for that... the wiki link is... odd
19:12:01 <Cale> I should fix it
19:12:22 <wolfman154> I think I already have xmonad-config installed 
19:12:33 <geekosaur> wiki link may be for when we were self-hosting docs because hackage wasn't doing documentation. xmonad's wiki stuff badly needs an overhaul
19:12:45 <geekosaur> half the links are obsolete or dead
19:13:20 <Cale> geekosaur: It goes to http://code.haskell.org/XMonadContrib/XMonad/Actions/CycleWindows.hs
19:13:34 <geekosaur> hah. original repo
19:13:45 <Cale> and not the right module
19:14:02 <geekosaur> that sounds like a copy-pasto
19:14:28 <Cale> there, fixed
19:15:22 <wolfman154> So in xmonad the key names are the same as in xkb x server?
19:15:24 <Cale> wolfman154: If you can add  import XMonad.Util.EZConfig  to the top of your xmonad.hs and have it not complain, then it's installed
19:15:50 <Cale> wolfman154: Pretty much, it's using a binding to the X library
19:16:56 <Cale> If you're using the additionalKeysP thing though, it seems to parse the keys out of a string though, and I'm not 100% certain what language of keys is being parsed :)
19:17:22 <Cale> http://hackage.haskell.org/package/xmonad-contrib-0.15/docs/XMonad-Util-EZConfig.html#v:mkKeymap -- ah, there's a list here
19:18:01 <Cale> For the symbol characters, you should mostly just be able to type them literally, like % for percent and such
19:18:11 <Cale> (It seems)
19:19:25 <wolfman154> Thanks guys, I’m brain dead right now so I’ll try this out tomorrow, thanks again!!!
19:19:27 <Cale> haha, I want to see a keyboard which has all of the supported multimedia keys
19:19:31 <wolfman154> :)
19:20:36 <cosimone1> i thought about getting this beauty for emacs alone https://i.imgur.com/1nRp5UO.jpg
19:21:32 <Cale> I would definitely get into a group buy for that keyboard if there were one
19:21:39 <ski> some variant of a space cadet ?
19:21:48 <Cale> I thought that was just one dude's crazy project
19:22:03 <Clint> where are the apl keys
19:25:47 <wolfman154> Well if you guys could paste bin a link explaining what this code in this link means then I’ll try and figure it out tomorrow:
19:25:51 <wolfman154> https://unix.stackexchange.com/questions/68691/remapping-keys-for-workspaces-in-xmonad#68709
19:27:32 <geekosaur> it's just a pair of entries in the keybinding list, each of which is a tuple of (KeyMask,KeySym) and a command
19:30:35 <geekosaur> "windows" is the function that manipulates windows and their locations; it takes as parameter a function that modifies a window entry, here either (W.shift "2") (moves the focused to the workspace named "2") or (W.greedyView "2") (displays the workspace named "2" on the current monitor, swapping workspaces with another monitor if it's currently displayed there)
19:34:38 <wolfman154> geekosaur: wow, thanks the really good explanation, I’ll give it a try tomorrow
19:40:05 <wolfman154> geekosaur: I get shiftMask is there for shift, but what is the zero 0?
19:41:33 <geekosaur> just to make the two look the same, as 0 logical-or someValue is the same as someValue
19:41:59 <geekosaur> (occasionally people get pedantic and use noModMask instead)
19:42:21 <geekosaur> which is silly since it's just getting or-ed with modMask
19:44:00 <Cale> Yeah, just leave the "0 .|." out :P
19:46:17 * hackage crc32c 0.0.0 - Haskell bindings for crc32c  https://hackage.haskell.org/package/crc32c-0.0.0 (leptonyu)
19:46:41 <wolfman154> Ok thanks, it’s making more sense 
19:47:39 <wolfman154> I’m going to buy Haskell from first principles, is it easier to learn in this book than the others?
19:48:35 <wolfman154> Cale: geekosaur:   ?
19:48:37 <Cale> I don't know -- I've heard that book is really long and slow
19:49:14 <Cale> My personal dead tree book recommendation would probably be Graham Hutton's "Programming in Haskell"
19:49:36 <Cale> and there's a free course online http://www.cis.upenn.edu/~cis194/spring13/lectures.html
19:49:43 <Cale> which is fairly good
19:49:49 <wolfman154> Just wondering, I was learning Haskell from the wiki book, and I got lost half ways through 
19:50:09 <Cale> also, hang around here and ask questions as you go :)
19:51:30 <wolfman154> Cale: and is the demand for Haskell increasing because I’m going to start looking for freelance work?
19:52:46 <wolfman154> Cale: not until I get better with Haskell though 
19:54:58 <mud> Freelance haskell work sounds difficult
19:55:48 <wolfman154> mud: yeah but functional programming is the future,isn’t it?
19:56:57 <mud> I am not sure what that would mean. But freelance work is mostly about what you can get work in approximately in the present i'd think
19:58:55 <wolfman154> mud: what I mean is shouldn’t the demand for functional programming increase in the coming years?
19:59:56 <mud> I don't know. Many languages seem to be using some functional patterns. I don't think anyone expects haskell to be in the say, top 5 most popular languages anytime soon
20:00:21 <mud> Or in any specific domain being too close to the top either
20:01:54 <Cale> On the other hand, it does seem that there are more and more job postings for Haskell work these days
20:03:02 <mud> I'd say it's probably possible to do freelancing in haskell, but fairly difficult compared to most languages I can think of
20:03:03 <Cale> There aren't a huge number of postings, but that's somewhat okay if you're looking for work, because there are correspondingly few Haskell programmers.
20:03:13 <Cale> I don't know about freelancing though
20:03:19 <wolfman154> mud: yeah I get what you mean, I got tired of Java, learning Haskell has been refreshing (even though I struggle a lot)
20:03:21 <Cale> You're more likely to find actual positions
20:04:33 <mud> wolfman154: Makes sense. And yeah i certainly agree. I even think haskell is worth learning. Just want to make sure expectations for direct profitability aren't too high
20:05:20 <Solonarv> I'd guess that you have more freedom to choose which language you work in if you do freelance
20:07:31 <mud> Sometimes ya, people are flexible on what language you use. Most of the time they'll have one picked tho
20:07:53 <wolfman154> Cale: ok I understand, my plan is to work from home, either through freelancing or as an employee, I live in a very cold blooded toxic society, so I want to avoid these negative people. Sorry about the rant, I’m trying to be more positive 
20:09:08 <Cale> I work from home for Obsidian Systems, we mostly build web and mobile applications in Haskell
20:09:36 <wolfman154> I should rant on Reddit instead     :)
20:09:43 <nshepperd> coding for reptilians eh
20:11:53 <geekosaur> sadly, there's a lot of cold blooded toxicity in pretty much any programming context these days :(
20:12:24 <Cale> Is there really?
20:12:25 <wolfman154> Cale: sounds interesting, I’m not quite ready yet to start applying places, I’ve only been using nixos, and xmonad for two weeks, I have 3 years of Java experience, but very little Haskell experience 
20:12:59 <Cale> wolfman154: We use nix fairly extensively as well -- personally I have a love-hate relationship with it
20:14:53 <maerwald> turing complete configuration language...
20:14:54 <Cale> It's the best thing available for the thing that it does, it's just that it's an infuriating and baffling experience every time I actually need to get in and edit the .nix files for anything.
20:15:00 <wolfman154> geekosaur: I was talking about the society I live in not programmers, most of them are brainwashed blue pilled religious people who hate science and logical reasoning 
20:15:55 <Cale> But once the .nix files are correct, they do tend to work really well for making sure that everyone is running the same code and can get into appropriate development environments, even with really complicated toolchains.
20:16:54 <wolfman154> Cale: I guess nixos 19.03 stable just came, out but I’m thinking of trying the unstable version 
20:17:43 <Cale> (also, I don't use nixos, just nix itself, but most of the others in the company are using nixos on their desktops)
20:19:50 <Cale> The central problem with nix is that while its configuration language is purely functional, all the advantages of having a purely functional language only work if you can actually find the definitions of the things you're trying to work with, and a combination of the features of the language with the conventions in use by nixpkgs makes it infuriatingly difficult to do that a lot of the time.
20:21:09 <Cale> There are these "sets", basically associative mappings, and people construct these gigantic sets of things with 500 elements in them, and mix them together and extend them with recursive fixed points, and it becomes almost impossible to actually find where things came from without reading quite a lot of code.
20:21:27 <wolfman154> Cale: the benefits sound great though, I’ve dealt with decency hell in Java and I heard cabal has this problem too
20:22:32 <Cale> Nix solves *some* aspects of dependency hell to be sure
20:22:47 <Cale> It solves the problem of getting everyone on the team running the same damn code
20:22:48 <Solonarv> cabal really doesn't have that problem anymore if you stick to v2 builds
20:22:51 <Cale> which is really big
20:23:04 <Cale> cabal doesn't *really* try to solve that, I don't think
20:23:24 <Cale> It's much better at solving dependencies if you stick to the new builds
20:23:38 <Solonarv> cabal has freeze files so you should be able to do that
20:24:01 <Cale> Yeah, if your project is entirely Haskell, you probably can do something like that
20:24:01 <Solonarv> but it only handles haskell dependencies, not e.g. C libraries you're calling from Haskell
20:24:10 <sclv> Right
20:24:10 <Cale> right
20:24:28 <sclv> In a big polyglot project nix can coordinate the whole system
20:24:40 <sclv> Including not just builds but running services etc
20:24:52 <sclv> So a complex interlinking deploy as well
20:25:24 <Cale> So, where I work, where we're building Android and iOS apps as well as desktop and web applications (all the same Haskell code, but very different toolchains!), it sorts that stuff out very nicely.
20:25:25 <wolfman154> Could one paste the link to today’s logs, I’m on my phone so I can’t, I’ll take a look at the links tomorrow 
20:26:02 <ski> the link's in the topic ?
20:26:46 <Cale> ... of course, I've just blown almost an entire week trying to upgrade one of the compilers we're using, but that's mostly our own damn fault (and only slightly nix's fault for letting us accomplish some of the crazy patching we did in the first place)
20:27:03 <wolfman154> It does not show it on my phone :(
20:27:17 <ski> try <http://tunes.org/~nef/logs/haskell/?C=M;O=D>
20:27:53 * ski idly wonders what happened to <ircbrowse.com>
20:28:23 <Cale> It was run by Chris Done...
20:28:24 <wolfman154> ski: thanks 
20:28:53 <ski> Last seen  : Oct 31 11:29:06 2018 (23w 1d 15h ago)
20:29:13 <ski> (rings a bell, yes. did something happen ?)
20:29:31 <Cale> Maybe he took it down around the same time he tried to revoke the rights of haskell.org to use his website design
20:29:50 <wolfman154> You can build android apps with Haskell?
20:29:55 <Cale> wolfman154: Yep!
20:30:19 * ski can't recall hearing about this, before
20:30:21 <Cale> wolfman154: We had to go to a fair amount of trouble to get everything to work, but we're doing our best to make it easy now.
20:30:39 <Cale> https://github.com/obsidiansystems/obelisk/
20:30:49 <wolfman154> Cale: wow
20:31:22 <maerwald> looks complicated :P
20:31:25 <Cale> Obelisk is our tool for developing applications with Haskell that will simultaneously run on Android, iOS, the web, and desktop.
20:31:44 <maerwald> on desktop? via electron?
20:31:50 <Cale> No, via our own stuff :)
20:32:06 <maerwald> native gtk?
20:32:18 <Cale> Your application runs in native code, but controls the contents of the DOM in a webview.
20:32:38 <Cale> btw, it sounds like we might be developing a proper reflex-gtk for a client now
20:32:41 <Cale> possibly
20:33:12 <Cale> Can't really confirm anything for sure, but I heard some mumbling to that effect.
20:33:31 <mud> That'd be quite cool
20:34:16 <Solonarv> there's also already reflex-sdl2 which lets you use SDL2 (and opengl if you want)
20:34:23 <wolfman154> Good night guys, I can’t stay awake any longer
20:34:36 <Solonarv> and I think I recall seeing one or two other reflex hosts besides those
20:36:00 <Cale> My coworker Ali and I are working on a reflex-vty, which should come out pretty soon, if we can just find a weekend or two more to work on it.
20:36:21 <Cale> It uses the Graphics.Vty library that underlies Brick
20:36:38 <mud> Vty? Like ncursesish style ui?
20:36:41 <Cale> yeah
20:36:46 <mud> Ah cool
20:39:35 <mud> I really need to do more reflex stuff soon. It was super fun last i did, and there's even more now
20:39:54 <Cale> While we were building the most basic parts of its reflex host, we were really careful to add a lot of commentary. It's possible we'll also split out that work into a new library for helping people more easily make new reflex hosts.
20:40:23 <Cale> Because really, a lot of it is likely to be the same setup a lot of the time, if you're building a full-featured reflex host.
20:40:56 <Cale> Reflex lets you do things very incrementally, but sometimes you just want everything that reflex-dom supports, and it's a bunch of work to set it all up.
20:41:39 <Solonarv> I've finally gone from "scared" to "excited" wrt reflex, now I have a semi-working reflex-sdl2 test app
20:41:40 <Cale> So I'm hoping we can make that a bit easier for people.
20:41:45 <Cale> nice!
20:49:59 <jle`> nice :) i remember reflex-vty and related projects being something i've been excited for for a long time :)
20:52:42 <Cale> Yeah, sorry it's not out yet, we really want to finish up the last few things before we release what we've got, but it's just been quite busy the last short while.
20:53:03 <jle`> no need to be sorry :o
22:22:29 <Lite> What is *the thing* I want to read up on to understand state management in Haskell?
22:22:55 <Lite> I'm absolutely new to this programming language so something even as simple as writing a boolean toggle is beyond me.
22:36:17 * hackage servant-checked-exceptions-core 2.1.0.0 - Checked exceptions for Servant APIs.  https://hackage.haskell.org/package/servant-checked-exceptions-core-2.1.0.0 (cdepillabout)
22:37:17 * hackage servant-checked-exceptions 2.1.0.0 - Checked exceptions for Servant APIs.  https://hackage.haskell.org/package/servant-checked-exceptions-2.1.0.0 (cdepillabout)
22:37:25 <Cale> Lite: So the first thing you want to realise is that the only way that variables vary is when they're bound to new things, so if your algorithm calls for some quantities that change over time, you can make them into function parameters, and by way of recursion, have them take on new values. 
22:38:58 <Cale> Lite: Beyond that, you can also work with functions which take some initial state as a parameter, and along with their result, produce a new state along with their result. If threading the current state along through many functions of that sort becomes annoying, that's where the State monad (or its transformer friend StateT) comes in.
22:40:14 <Cale> Lite: and then also, if you're in IO, there are many honest to goodness mutable reference types to choose from -- IORef is the most basic, we also have mutable arrays of various sorts, and then there are things like MVar and TVar which help when you're dealing with multiple threads.
22:41:27 <Cale> Lite: So... what you'll use will depend on what it is you're trying to express.
22:41:57 <Cale> You could start off with something like:
22:42:01 <Cale> myLoop b = do
22:42:15 <Cale>   putStrLn $ if b then "On" else "Off"
22:42:20 <Cale>   getLine
22:42:25 <Cale>   myLoop (not b)
22:42:52 <Cale> main = myLoop False
22:43:09 <Cale> Lite: Make sense?
22:44:36 <Lite> I understand the portion about writing a higher order function that takes an initial state.
22:44:55 <Lite> I'll have to look at your example code more to understand. I'm very new to the syntax.
22:45:09 <Cale> Lite: It's possible to take pretty much any imperative algorithm which computes something while mutating a bunch of variables and implement it in terms of functions by taking each point of control in the program (somewhere that the program counter could be), and turning that into a function
22:45:25 <Cale> all the mutable variables in scope at each point become the function parameters
22:45:51 <Cale> and the functions apply each other to new values based on where the control flow goes and how the values of the mutable variables get updated
22:46:32 <Cale> This will of course result in a bit of a mess at first, but since you now have a bunch of *equations*, you can simplify the program using highschool-algebra-like substitution
22:47:22 <Cale> It's not something that I do every day, but on occasion I've done it to sort out how an obfuscated imperative program worked :)
22:50:43 <Lite> In case it helps, I'm coming from Javascript
22:51:00 <Lite> So if I were to write a toggle in that language it may look like:
22:51:02 <Lite> let bool = true
22:51:04 <Lite> let toggleValue = () => bool = !bool
22:51:23 <Lite> But of course bool is mutated.
22:51:47 <jle`> it's possible to directly write the equivalent program in haskell, but in a lot of cases it might not be the cleanest way to achieve your goal
22:51:51 <Cale> Right, so we can actually do a direct equivalent of that, but it might not be the first thing we'd jump to
22:51:55 <Cale> yeah
22:52:02 <Cale> bool <- newIORef True
22:52:40 <Cale> let toggleValue = modifyIORef bool not
22:52:52 <Cale> Or perhaps:
22:53:08 <Cale> toggleValue = do v <- readIORef bool; writeIORef bool (not v)
22:53:49 <jle`> but yeah, i know that years of imperative programming have conditioned me to reach for 'toggles' or other mutable state, without thinking too much about it. it definitely warped my intuition a bit
22:53:51 <Lite> Ok. I think a good starting point is for me to backtrack and read how newIORef and modifyIORef work. I was skimming the documentation and jumped straight to monads.
22:54:11 <Cale> Well, those are only available in IO specifically, not just in any monad
22:54:18 <Cale> http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-IORef.html
22:55:12 <jle`> Lite: a lot of things that you might reach immediately for a mutating state...there might be a way that flows a lot better in the language
22:55:47 * hackage http-client 0.6.4 - An HTTP client engine  https://hackage.haskell.org/package/http-client-0.6.4 (MichaelSnoyman)
22:55:53 <jle`> for example, given a list of numbers, i might want to create a new list that has all of the items in the original list, but doubled
22:56:20 <jle`> in an imperative language i'd just initialize something to an empty list, and then iterate through the first list and mutate the state variable
22:56:33 <Lite> Right. Given a problem and two languages I wouldn't use guard clauses and function overloading in javascript but would definitely reach for that in elixir. :)
22:56:58 <jle`> this is something that's...not *super* bad in Haskell to implement imperatively using mutable variables
22:57:05 <jle`> but we could also just do `map (*2) myList`
22:57:35 <Cale> In general, a lot of what would be loops in other languages become lists in Haskell
22:57:38 <jle`> my point isn't that mutable variables bad, higher order function good
22:57:54 <jle`> but just to be aware of your initial reactions and how they might have been shaped by your environment in the past
22:58:37 <jle`> and often 'how do i use a list as mutable state' is a (legitimate) initial reaction in a lot of languages, there is a much cleaner and readable path that's available in haskell
22:58:40 <Cale> Just as a loop either finishes immediately (because its termination condition is satisfied, say), or consists of an iteration followed by another loop, a list is either the empty list [] or consists of a single element followed by another list x:xs
22:59:05 <Cale> and so lists become a way of saying "I'm going to iterate over these things"
22:59:18 <Lite> Indeed. Hopefully the shock isn't too great as I try to write functionally as possible in javascript professionally. Typically chaining data through reducers instead of making temporary states and variables.
22:59:23 <Cale> (and in fact, that's the main thing they're actually good for)
23:01:23 <jle`> when you're learning haskell, if you have time to just learn and you're not in a super big rush, it's good practice to try to write everything without mutating references and IO
23:01:36 <jle`> in practice, real haskell code doesn't always look like this
23:01:49 <Cale> (For some value of "everything")
23:01:55 <jle`> buut it's a good sort of mental prep thing
23:02:17 * hackage rio 0.1.9.0 - A standard library for Haskell  https://hackage.haskell.org/package/rio-0.1.9.0 (MichaelSnoyman)
23:04:15 <Lite> One more question and I'll go back to reading...
23:04:29 <Ariakenom> jle`: I like the direct translation as a first implementation. That you can change later. But knowing that you can always get a solution by writing it in js and doing a direct translation is, I think, good.
23:04:32 <Lite> In elixir I can get away with no variables thanks to pattern matching
23:04:40 <Lite> for instance:
23:04:41 <Cale> It's funny, Haskell has some of the most sophisticated systems for constructing and controlling effects, but the big deal when learning it is not using any of them :D
23:04:44 <Lite>   def sum_list([head | tail], accumulator) do
23:04:46 <Lite>     sum_list(tail, head + accumulator)
23:04:48 <Lite>   end
23:04:50 <Lite>   def sum_list([], accumulator) do
23:04:52 <Lite>     accumulator
23:04:54 <Lite>   end
23:05:01 <Lite> Then I could say sum_list([1, 2, 3], 0) #=> 6
23:05:20 <Lite> Is there an equivalent tail/head pattern matching in Haskell?
23:05:25 <Cale> sumList (x:xs) acc = sumList xs (x+acc)
23:05:32 <Cale> sumList [] acc = acc
23:05:58 <Cale> Though we'd never put the parameters in that order :)
23:06:36 <Cale> It's nicer to put the accumulator first, so that it can be specialised to 0, and you obtain a function of a list
23:07:41 <Lite> I bet javascripts' reduce implementation drives Haskell users crazy then.
23:07:44 <Cale> Not actually a very big deal, it's just that when you apply a function to less than all its arguments in Haskell, you obtain a function of the rest of them
23:08:15 <Cale> So it's natural to put the more-constant-like things first, and have the more-varying parameters later
23:08:15 <Lite> ah yeah, currying
23:08:28 <jle`> yeah, haskellers love partial application :)
23:08:57 <Cale> It goes really well with our penchant for using higher-order functions (i.e. functions which take other functions as arguments)
23:10:04 <Lite> In a language where partial application isn't implied, I would argue having the accumulator as the last param is advantageous because you could make it optional.
23:10:36 <Lite> For instance leaving it off in javascript iirc the first element of an array becomes the accumulator if there is none.
23:11:03 <Cale> Yeah, we don't really have optional arguments, though if you ever feel like you want those, the answer is typically to make a record datatype, and provide a default record that can then be updated
23:11:26 <Cale> Which would look like  foo defConfig { someParam = ... }
23:11:27 <jle`> in a language with optional arguments, yeah.
23:12:48 <Cale> (Here, we're applying the function foo to the default configuration defConfig which we'd have defined elsewhere, but where the someParam field of that record has been replaced with the value we provided in the "..." bit)
23:12:56 <Lite> So in the haskell example above I couldn't define sumList again with only one parameter?
23:13:07 <Cale> Right, so probably you'd write
23:13:17 <Cale> sumList = sumList' 0
23:13:19 <Cale>   where
23:13:33 <Cale>     sumList' n [] = n
23:13:47 <Cale>     sumList' n (x:xs) = sumList' (n+x) xs
23:14:05 <maybefbi> How to implement scalarSubtract using Crypto.ECC.Edwards2551? I am trying to do this: https://pastebin.com/UJA7re8H
23:14:42 <Cale> maybefbi: I have no idea, but do you have a (-1)?
23:15:19 <maybefbi> Let me see
23:15:27 <maybefbi> (-1) :: Integer
23:15:37 <maybefbi> scalarDecodeLong :: ByteArrayAccess bs => bs -> CryptoFailable Scalar
23:16:01 <Cale> It doesn't look like it...
23:16:04 <Cale> huh
23:16:14 <maybefbi> I have:
23:16:18 <maybefbi> instance ByteArrayAccess ByteString
23:16:38 <Lite> Thank you for the insight to my petty questions. I'll continue on with my reading now.
23:17:09 <maybefbi> so If I find something :: Integer -> ByteString, then I can ByteString -> CryptoFailable Scalar
23:17:43 <maybefbi> because of the above instance
23:21:15 <Cale> Lite: Beginner questions are totally okay here :)
23:22:29 <maybefbi> \quit
23:25:18 <lovesegfault> Anyone around?
23:26:11 * ski blinks
23:26:28 <lovesegfault> Oh, hey!
23:26:51 <lovesegfault> I'm a Rust SWE wanting to experiment with Haskell; is there a good LSP for Haskell that I can use with Vim?
23:26:59 <lovesegfault> Just looking for recommendations
23:27:18 * ski wouldn't know about that
23:27:34 <ski> (perhaps someone else knows the answer)
23:38:05 <maerwald> lovesegfault: https://github.com/autozimu/LanguageClient-neovim
23:38:12 <hoppfull> Hello! I'm curious if contravariant functors make sense for anything else than functions in Haskell. Can you treat a type constructor as a functor and/or contravariant functor?
23:38:23 <maerwald> lovesegfault: which can be used with https://github.com/haskell/haskell-ide-engine
23:38:38 <lovesegfault> maerwald: Perfect! I already use the first one!
23:39:21 <jle`> hoppfull: there is only one family of instances of both Contravariant and Functor
23:39:44 <jle`> hoppfull: and by 'other than functions', do you mean the (a -> b) -> F b -> F a, the (a -> b) ?
23:39:54 <hoppfull> No, I mean the F
23:39:57 <jle`> oh
23:40:04 <jle`> ah yeah, there are plenty :)
23:40:11 <hoppfull> Cool
23:40:36 <hoppfull> Is there a way to list what implements a certain type class?
23:40:46 <jle`> yeah, you can :i in ghci
23:40:54 <hoppfull> list all Show
23:40:56 <hoppfull> or something
23:41:02 <hoppfull> alright, cool!
23:41:11 <jle`> btw, the only things that can be both Contravariant and Functor is if the final type parameter is phantom, and doesn't occur in the data type 
23:41:32 <hoppfull> Ok, interesting
23:41:35 <jle`> so, like `Proxy`, and `Const w`
23:41:45 <hoppfull> I'm only interested in contravariant functors right now.
23:41:54 <hoppfull> I'm getting to profunctors and the like later.
23:42:21 <hoppfull> Can you map over type constructors?
23:42:42 <hoppfull> sorry, fmap
23:42:43 <jle`> hm, what do you mean?
23:43:13 <jle`> btw, there are a lot of types in the profunctor library that can be made into profunctors
23:43:19 <jle`> er, that can be made into contravariant functors, i mean
23:43:46 <jle`> so that gives you a lot of interesting contravariants, too
23:43:54 <hoppfull> alright, cool
23:44:04 <jle`> ah, this post explains a lot of non-function contravariant functors https://ocharles.org.uk/guest-posts/2013-12-21-24-days-of-hackage-contravariant.html
23:44:54 <jle`> the general idea is that functors sort of represent "producers", and fmap lets you post-process the produced items
23:45:12 <jle`> and contravariant functors represent "consumers", and contramap lets you pre-process the consumed items
23:47:02 <hoppfull> yeah, that's what I got so far but I could only come up with functions and type constructors as candiates for possible "consumers"
23:48:09 <hoppfull> hmm, I wonder if a (a, b) could be though of as a consumer where a is what would be consumed. pairs are isomorphic to functions I believe
23:48:24 <ski> hoppfull : a type of continuations will be contravariant
23:49:06 <jle`> pairs are definitely not isomorphic to functions :)
23:49:33 <hoppfull> jle, no you're right, a set of pairs is however
23:49:52 <hoppfull> ... I think *uncertain*
23:50:45 <ski> there is both a covariant, and a contravariant, powerset functor (giving the set/type of all subsets of a given set/type)
23:51:30 <jle`> hoppfull: "write-only" acess to an IO ref is a consumer
23:51:52 <jle`> write :: WriteOnly a -> a -> IO ()
23:51:54 <ski> if you want to represent a function by its graph, as a subset of pairs of elements from the domain and the codomain, then that really ought to be contravariant in the domain part, and covariant in the codomain part
23:52:20 <ski> (or to a `Chan')
23:53:37 <hoppfull> Always a joy to engage with the haskell community! :) Unfortunately I have to get back to work now. :( Anyway, thanks for the responses, guys!
23:54:24 <jle`> happy haskelling :)
