00:00:09 <koz_> x2l43ylol: Ask away! No need to ask to ask.
00:01:26 <x2l43ylol> for a preject i have to make a function that outputs the number of days within a year based on the inputted year. i think i nearly have it right but i get a non-exhaustive patterns error message for certain years inputted daysInYear :: Int -> Int daysInYear y   | mod y 400 == 0 = 365   | mod y 100 == 0 = 366    | mod y 4 == 0 = 365
00:01:44 <x2l43ylol> sorry i dont know how to copy and paste the code in the right format
00:01:53 <koz_> x2l43ylol: gist.github.com is your friend.
00:02:08 <koz_> The reason you're getting this is because GHC can't prove your patterns are exhaustive.
00:02:15 <koz_> So you need a 'last resort' pattern at the end.
00:02:57 <x2l43ylol> ahh i see, so i need an "otherwise = invalid input" at the end?
00:03:23 <koz_> x2l43ylol: Well, yeah, an invalid input is conceivable in this case, since you're using Int to represent years.
00:03:45 <koz_> Although I guess you could represent BCE years as negative.
00:03:58 <koz_> It's more to do with GHC not being able to determine whether an arbitrary set of conditions cover all possible inputs.
00:04:17 <koz_> In this case, GHC can't say that no matter what Int you get given, one of your guards will catch it.
00:04:44 <x2l43ylol> right right. if i wanted to make it so that it could handle negative numbers and float numbers how might i go about that?
00:04:57 <koz_> Well, I would argue floats don't make sense in this context.
00:05:10 <koz_> How many days are there in year 12.6?
00:05:14 <koz_> What even is year 12.6?
00:06:05 <x2l43ylol> ya i totally get there is no point to inputting a float in the first place, however for the task it says that my code must be able to handle float numbers aswell as negative numbers
00:06:25 <koz_> x2l43ylol: Uhh. I'd like to see what the task's exact wording is in that case.
00:06:28 <fen> well it would, thats the point of the otherwise case right?
00:06:34 <koz_> Since I'm not sure I understand how that would work.
00:06:44 <koz_> fen: Please inform me in what reality an Int -> Int function can handle Float?
00:06:45 <fen> well, for the negative case at least
00:07:09 <fen> leap years?
00:07:12 <fen> idk
00:07:18 <koz_> fen: What is the year 12.6?
00:07:26 <fen> lol
00:07:27 <x2l43ylol> Write a function daysInYear such that it output number of days based on the input year given. Your program should be able to handle negative input and float number. E.g. daysInYear 2019 365 daysInYear 1900 365 daysInYear (-2000) 366 daysInYear 1.1 Invalid input daysInYear 1992 366 You may assume all input in this question will be numbers.
00:07:28 <koz_> That's why I'm trying to see what the question actually says.
00:07:42 <koz_> Ah, I see.
00:07:44 <x2l43ylol> that is the task description with examples
00:08:27 <koz_> This is a Haskell exercise?
00:08:33 <koz_> Homework or something?
00:08:38 <fen> yeah, maybe if it was "read"ing the numbers and it got something other than an Int it would have to throw an error
00:08:43 <x2l43ylol> ya this is a homework task
00:09:12 <fen> :t floor
00:09:13 <lambdabot> (Integral b, RealFrac a) => a -> b
00:09:41 <koz_> The thing is, what type could you even give it such that it'll accept both Ints and Floats, _and_ can distinguish between them?
00:09:56 <fen> well you would just take Num right?
00:09:59 <koz_> :t mod
00:10:00 <lambdabot> Integral a => a -> a -> a
00:10:07 <koz_> Integral is better, since you don't need anything else.
00:10:19 <koz_> Although how would you check you got handled a float?
00:10:27 <fen> but then it would be a type error instead of a runtime error if it was given a flaot
00:10:40 <koz_> Yeah, point.
00:10:48 <koz_> But that doesn't change my question materially.
00:11:27 <fen> basically it seems like it wants a toInt function that throws an error if it wasnt given something like the result of fromInt
00:11:41 <fen> :t fromIntegral
00:11:42 <lambdabot> (Num b, Integral a) => a -> b
00:12:42 <koz_> x2l43ylol: You're absolutely sure the exercise tells you nothing else?
00:13:25 <fen> :t (\a -> if a - (floor a) /= 0 then error "not given an whole number" else floor a)
00:13:26 <lambdabot> (Integral p, Integral a, RealFrac a) => a -> p
00:13:46 <x2l43ylol> https://imgur.com/a/ihcmXsJ
00:13:55 <fen> > map (\a -> if a - (floor a) /= 0 then error "not given an whole number" else floor a) [1.0,1.1]
00:13:57 <lambdabot>  error:
00:13:57 <lambdabot>      • Could not deduce (Num a0) arising from a use of ‘-’
00:13:57 <lambdabot>        from the context: Integral b
00:14:01 <fen> ok nvm
00:14:06 <x2l43ylol> this is a screenshot of the task
00:15:37 <fen> yeah, that cant have Int as the input type
00:16:22 <koz_> You could have it always take Double and just check if it's not whole.
00:16:29 <koz_> Since technically
00:16:31 <koz_> :t 2000
00:16:32 <lambdabot> Num p => p
00:16:34 <koz_> :D
00:17:16 <fen> :t \a -> (fromIntegral (floor a)) == a
00:17:17 <lambdabot> RealFrac a => a -> Bool
00:17:33 <fen> > (\a -> (fromIntegral (floor a)) == a) 1.1
00:17:35 <lambdabot>  False
00:17:38 <fen> > (\a -> (fromIntegral (floor a)) == a) 1.0
00:17:40 <lambdabot>  True
00:18:46 <fen> any idea how to make a list of lists using Compose?
00:20:10 <x2l43ylol> okay thank you very much for your hep everyone, much appreciated
00:20:23 <x2l43ylol> may i ask how long you all ahve been usuing haskell etc?
00:20:32 <fen> all day!
00:20:43 <fen> maybe more...
00:21:15 <x2l43ylol> lol, how long did it take you to become comfortable with usuing it?
00:21:30 <fen> well its very natural at first and then it gets worse and worse
00:21:59 <x2l43ylol> did you have previous programming experience prior to learning it?
00:22:11 <fen> its probably easiest as a first language
00:22:45 <x2l43ylol> righy right
00:22:50 <fen> there are some things that can become ingrained which are hard to do without
00:23:08 <fen> but thats the case with any particular first language
00:23:14 <x2l43ylol> what would you say are the best resources online for learning it?
00:23:44 <fen> well it helps to have a project to work towards
00:24:07 <fen> then the challenges that arise can be basically just googled until a point
00:24:18 <x2l43ylol> ahh okay i get you
00:24:22 <[Leary]> @where cis194
00:24:23 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
00:24:37 <[Leary]> That one's a good start, x2l43ylol.
00:24:51 <x2l43ylol> the cis194?
00:24:59 <[Leary]> Yes.
00:25:19 <x2l43ylol> okay, thank you very much ill have a look through it :)
00:27:07 <fen> is there a way to use '[* -> *] to represent nested containers of arbitrary depth?
00:27:50 <fen> that might be similar to trying to use Compose [] [] for a depth 2 case
00:29:15 <fen> cant understand how to have them containing multiple values if they are tangled up in the Compose type
00:31:21 <fen> well; data Compose [] [] a = Compose [[a]], is easy, but when its the type level list version, unless its cast to the actual normal representation it seems like it cant store values, the constructors are not available...
00:33:08 <fen> the whole point of having it like ComoseN '[[],[]] a instead of [[a]] is because then it can have arbitrary depth, but how can that be written?
00:39:27 <[Leary]> % data Nested :: [Type -> Type] -> Type -> Type where Base :: a -> Nested '[] a; Nest :: g (Nested l a) -> Nested (g ': l) a
00:39:27 <yahb> [Leary]: 
00:39:27 <fen> hmm, this seems to work with TypeFamiles; https://pastebin.com/D7Cajaf8
00:39:32 <[Leary]> % :t Nest [Nest [Nest (Just (Base ()))]]
00:39:32 <yahb> [Leary]: Nested '[[], [], Maybe] ()
00:39:48 <fen> oh nice
00:40:19 <fen> is that different to the type families version?
00:40:32 <fen> appart from being able to be partially applied
00:40:37 <fen> not sure which to use
00:40:49 <[Leary]> A type family hidden under a newtype might be better, since it doesn't need to interfere with the representation.
00:41:10 <fen> what does that mean?
00:41:46 <fen> why have it under a newtype?
00:41:57 <fen> just to defunctionalise it?
00:42:53 <fen> cant quite get the hang of what should be a type family and what should be a datatype
00:42:55 <[Leary]> To make in into a "real" data type from GHC's perspective, so you can make instances and avoid difficulties in inference.
00:43:06 <fen> oh right yeah
00:43:08 <fen> instances
00:43:10 <fen> ok
00:44:05 <fen> you would need to be able to partially apply it so that when it wasnt given a contants type yet it would have kind * -> * and have instances
00:44:09 <fen> thanks
00:45:47 * hackage simple-ltl 1.0.0 - A simple LTL checker  https://hackage.haskell.org/package/simple-ltl-1.0.0 (JohnWiegley)
01:14:53 <Mo0O> Hi there, is there a flipped version of (.) and/or ($)?
01:16:04 <Ariakenom> Mo0O: yeah https://hoogle.haskell.org/?hoogle=a+-%3E+%28a+-%3E+b%29+-%3E+b&scope=set%3Astackage
01:17:14 <Ariakenom> I think >>> from arrow is the most used flipped (.)
01:18:07 <Mo0O> Ariakenom: great, thanks a lot
02:13:08 <Uniaika> Mo0O: you can also check (&) from Data.Function (if I understood your question correctly)
02:19:27 <Mo0O> Uniaika: I've checked it using hoogle function signature search feature, and that's perfectly fix my needs, by the way thanks that's confirm it's the good choice/option
02:20:28 <Mo0O> I come from elm and was missing the (|>) operator which "enable" pipeline like style
02:20:45 <Mo0O> (&) does exactly that
02:27:45 <aldum> Mo0O: how's #elm these days? whenever I dropped by, it was either dead air or spam
02:36:17 <Mo0O> aldum: elm 0.19 comes with lots of improvement, we still create new projects and maintain olds ones here at work
02:36:29 <Mo0O> there's an elm con at paris this sumer
02:36:39 <Mo0O> I/we'll be there
02:44:18 <Uniaika> Mo0O: you can absolutely have a little utility that does `(|>) = (&)` in your program
02:49:46 <Uniaika> Mo0O: although it's a tricky pattern. I'm coming from Elixir, and the order of the parameters is often fun(data,lambda), so you can easily pipe some data through a series of higher-order functions. In haskell, you will compose those functions through (.) and ($) (and (<*>), (*>) and (>>=))
02:50:00 <Uniaika> which is why I quickly gave up on the (&) / (|>) operator
03:40:45 <halogenandtoast> Anyone know if there is a way to get ghcid to play nice with build tools like alex and happy?
03:41:03 <halogenandtoast> As in I'd like it to try to compile those files and provide feedback.
04:32:30 <Wizek> Anyone knows if/how it would be possible -- either with ghc or ghci -- to inspect the concrete type of a polymorphic subexpression? E.g. inspect what `id` is in `main = putStrLn $ id $ "x"`. It's of course `String -> String`, but I want a tool to be able to tell me this for much more complicated situations as well.
04:33:46 <lyxia> Wizek: replace id with (id :: _) ?
04:34:12 <Wizek> would it be that simple? Lemme try.
04:55:34 <Wizek> lyxia: unfortunately it doesn't seem to work: `Found type wildcard `_' standing for `a -> a'`
04:55:58 <Wizek> https://www.irccloud.com/pastebin/n1izZGEV/
04:56:11 <Wizek> ^ full output, lyxia 
04:57:03 <Wizek> IIRC for a long time this has been something that I found to be lacking with typed holes
04:57:27 <Wizek> They sometimes are very silent about important information
04:58:33 <Wizek> lyxia: is there any other way?
04:59:45 <lyxia> another is to replace all of id with a hole   putStrLn $ _ $ "a"
05:12:21 <tail42> hi there everyone. looking to get some assistance, could someone please explain to me what is happening inside of this function https://pastebin.com/mJ5VUCtc
05:13:32 <Wizek> lyxia: Now that output is indeed more helpful, thanks! Somehow some type parameters still remain, which I don't fully understand how, but I am investigating.
05:18:19 <lyxia> Wizek: here's another one:  putStrLn $ (\x -> x :: _) id $ "a"   i.e., apply an anonymous identity function to the expression you want to know the type of, and put a type hole in there.
05:18:54 <lyxia> compared to the previous trick, this seems to take into account both the inferred and expected types
05:22:38 <lyxia> tail42: tail accumulates binary digits of y in wz
05:24:47 * hackage wikicfp-scraper 0.1.0.11 - Scrape WikiCFP web site  https://hackage.haskell.org/package/wikicfp-scraper-0.1.0.11 (debugito)
05:30:46 <duncan^> It does strike me as slightly confusing to call it the same thing as the thing in prelude.
05:31:25 <duncan^> I would call it 'lait' for fun. :)
05:48:33 <CubicE> Hi, I'm having a weird issue GHC 8.6.4; Whenever I have a function that takes a do block as a parameter I get complaints about it not being syntactically valid, even if I wrap it in parentheses or separate it with the $ operator
05:49:20 <CubicE> BlockArguments seems to 'fix' that, but I think it should work without block arguments as well. Is that a known 'bug'? Or is this supposed to happen now?
05:52:51 <CubicE> I also get parsing errors now if I use a case expressions inside a let inside a do block? That also didn't use to happen
05:57:58 <__monty__> CubicE: Maybe it's a layout issue?
06:04:00 <CubicE> __monty__: hm... maybe? I just did a test and it seems I can at least the latter to work if I indent the cases further than the 'case' keyword, but I could swear it used to work like 'do' where it was enough to indent a bit on the next line
06:05:50 <CubicE> ah
06:05:50 <__monty__> That's normally the case yes. But I think dedenting from the "do-body" level actually stops the do block. If that's what you're doing. In any case the indentation should be more than the "do-body."
06:06:28 <CubicE> so, the let bit apparently only works if the case indent is greater than the indent for the let patterns, which I guess makes sense
06:07:06 <__monty__> Yeah, similar idea.
06:07:17 * hackage telega 0.2.5 - Telegram Bot API binding  https://hackage.haskell.org/package/telega-0.2.5 (iokasimovmt)
06:14:20 <CubicE> yeah, so that was just me being silly, apparently the first thing was also not actually caused by the do block, the indent in the let just had confused the parser so much that it couldn't figure out what I was doing anymore
08:08:47 * hackage th-reify-many 0.1.9 - Recurseively reify template haskell datatype info  https://hackage.haskell.org/package/th-reify-many-0.1.9 (MichaelSloan)
08:09:55 <Wizek> lyxia: with the help of your pointers I was able to pinpoint a concrete type that I was looking for. Thank you.
08:15:06 <Wizek> I also have a different question to whomever might know the answer: Is it possible to have a WriterT monad that is able to share its partially collected `tell`s in case of an exception? If I `try` outside of `runWriterT` the `w` seems to be discarded. If I try to `try` inside, I seem to need `MonadUnliftIO`. `MonadUnliftIO` sounds like it could help me, but that package says that it is only able to unlift monadic contexts and
08:15:06 <Wizek> not monadic state which I guess Writer is. Has anyone done anything similar with Writer?
08:18:38 <jacker[m]> Wireshark can send commands to device?
08:18:38 <jacker[m]> Or is it just used as viewer?
08:23:17 <glguy> jacker[m]: This is #haskell
08:23:32 <glguy> Try: /join #wireshark
08:24:09 <jacker[m]> Okglguy
09:01:06 <utonx[m]> Hello, can anyone help me understand why `tupled = rev <$> (cap >>= (,))` where `tupled :: [Char] -> ([Char], [Char])` and both `rev` and `cap` are `[Char] -> [Char]` won't compile, but with `tupled x = rev <$> (cap >>= (,)) x` it works?
09:02:25 <Solonarv> certainly
09:03:04 <Solonarv> tupled = rev <$> (cap >>= (,))
09:03:04 <Solonarv> tupled x = (rev <$> (cap >>= (,))) x -- added the argument, note the parentheses!
09:05:06 <sm> g'day all. In case anyone knows, or would like to know more about profiterole/profiling, I'm asking here: https://github.com/ndmitchell/profiterole/issues/4
09:08:20 <utonx[m]> Solonarv: oh, that explains it, does it get evaluated in the same way as `(,) <$> cap <*> rev` ?
09:09:28 <utonx[m]> I mean it certainly produces the same result so I guess that's a yes but is the process the same?
09:10:18 <Solonarv> if it produces the same result that's close enough as far as I'm concerned
09:10:39 <utonx[m]> alright, thank you
09:13:17 * hackage LambdaHack 0.9.4.0 - A game engine library for tactical squad ASCII roguelike dungeon crawlers  https://hackage.haskell.org/package/LambdaHack-0.9.4.0 (MikolajKonarski)
09:14:17 * hackage Allure 0.9.4.1, Allure 0.9.4.0, LambdaHack 0.9.4.1 (MikolajKonarski): https://qbin.io/panels-leave-4d2m
09:18:15 <AWizzArd> Do we have a Rust expert here? Does Rust support Rank-N-Types?
09:18:41 <AWizzArd> I didn’t get a reply in the ##Rust channel yet (asked over 3 hours ago).
09:20:00 <EmilKarlson> rust is more active in mozilla network
09:20:36 <EmilKarlson> or in matrix, which may or may not be bridged
09:36:01 <royal_screwup21> Hi folks, what pacakge is <*> in?
09:36:26 <royal_screwup21> ah actually nvm
09:38:04 <AWizzArd> royal_screwup21: in case you don’t know it yet:  https://hoogle.haskell.org/?hoogle=(<*>)
09:38:35 <royal_screwup21> I'm trying to grok Parser combinators and I'm amazed how you can  parameterize a datatype on a function...
09:41:37 <royal_screwup21> gonna try and see if it'ls possible to do thing in kotlin
09:43:35 <royal_screwup21> huh so you can...
10:03:01 <RedNifre> royal_screwup21: Have you seen Bodil's parser combinator tutorial? It's well written and I'm currently using it to write some parser combinators in Idris.
10:13:03 <royal_screwup21> how do I run a .lhs file on prelude?
10:14:09 <mreh> is it possible to create an empty class?
10:16:36 <mreh> I'm trying to create some simple instances of Beam's typeclasses for converting haskell values to SQL syntax and from SQL queries using Read and Show, but of course there are loads of overlapping instances
10:18:17 * hackage http2-client 0.9.0.0 - A native HTTP2 client library.  https://hackage.haskell.org/package/http2-client-0.9.0.0 (LucasDiCioccio)
10:20:24 <pavonia> mreh: Could you paste an example? Empty classes should be fine
10:20:43 <pavonia> royal_screwup21: What do you mean by "run on prelude"?
10:21:02 <mreh> pavonia: class (Read a, Show a, Typeable a) => SimpleSqlValue a
10:21:34 <mreh> however it seems that anything that's an instance of Read, Show and Typeable is also a SimpleSqlValue
10:22:12 <pavonia> That matches on *any* type and requires them to have  Read, Show etc. instances
10:22:43 <pavonia> Err no, for instances that is
10:22:49 <mreh> yeah
10:23:24 <mreh> I could always generate this code using TH or CPP
10:23:44 <pavonia> What do the instances look like? I don'Tt hink the class is a problematic by itself
10:24:12 <mreh> it just marshalls values into strings and back again
10:24:19 <mreh> they*
10:24:53 <pavonia> You said the class is empty
10:25:57 <mreh> @bot paste
10:25:57 <lambdabot> :)
10:26:04 <mreh> @where paste
10:26:04 <lambdabot> https://gist.github.com
10:26:25 <mreh> https://gist.github.com/mrehayden1/2b8064d2df0eb577866b6557c1cb2dec
10:26:57 <mreh> there are overlapping instances though
10:27:51 <mreh> this was my original attempt
10:27:52 <mreh> https://gist.github.com/mrehayden1/375b86a890a0390a35c67ccd772ad96b
10:28:56 <pavonia> Yeah, it doesn't work like that, you have to give instances for each type separately, AFAIK
10:30:15 <pavonia> At least unless your set of types is limited
10:33:25 <mreh> pavonia: maybe I can generate them somehow?
10:35:20 <pavonia> You can with TH, I guess
10:41:07 <royal_screwup21> I'm trying to grok how the <$ combinator works -- I'm lookign at the definition on ghic but I'd love an example of two :)  Not really sure how to use ti 
10:41:51 <monochrom> @type (<$)
10:41:52 <lambdabot> Functor f => a -> f b -> f a
10:42:22 <phadej> > '-' <$ "line of equal length"
10:42:24 <lambdabot>  "--------------------"
10:42:41 <monochrom> Yeah, like that.
10:43:22 <monochrom> It is not meant to be useful daily. Just once in a blue moon.
10:43:31 <royal_screwup21> ah I see
10:44:01 <pavonia> It's like fmap with a constant function
10:44:44 <phadej> monochrom: it pops up in applicative prser combinators though
10:45:06 <pavonia> Yeah, quite useful in parsers
10:45:24 <monochrom> Like char '*' *> pure Mul = Mul <$ char '*' ?
10:45:35 <monochrom> @type ($>)
10:45:36 <lambdabot> error:
10:45:36 <lambdabot>     • Variable not in scope: $>
10:45:36 <lambdabot>     • Perhaps you meant one of these:
10:45:51 <monochrom> I don't like the order of <$ :)
10:46:04 <phadej> :t (&>)
10:46:05 <lambdabot> error:
10:46:05 <lambdabot>     • Variable not in scope: &>
10:46:05 <lambdabot>     • Perhaps you meant one of these:
10:46:12 <royal_screwup21> the parser def I'm looking at is: (⟨$) :: b → Parser a → Parser b
10:46:12 <phadej> that could existed
10:46:17 <royal_screwup21> x ⟨$ py = const x ⟨$⟩ py
10:46:38 <royal_screwup21> so that <$> is basically an famp
10:46:40 <royal_screwup21> fmap*
10:47:13 <mreh> I used <$ recently when parsing integers
10:47:42 <Shockk> <$ is like fmap but ignores the rhs rather than applying it to what's on the left, unless my memory is wrong
10:47:43 <monochrom> Like 42 <$ many (satisfy isDigit) ? :)
10:48:08 <royal_screwup21> hmm const takes two args...but in that defintion we've only supplied it one argument?
10:48:32 <monochrom> (\y -> const x y) <$> py
10:49:50 <royal_screwup21> ahh I see
10:50:09 <royal_screwup21> so we do the mapping with (\y -> const x y)
10:50:36 <royal_screwup21> sort of seeing it now...
10:53:10 <mreh> can I put oxford brackets around a couple of instance declarations?
10:53:22 <mreh> making a Q [Dec]
10:53:38 <mreh> and splice them in somewhere
10:56:35 <mreh> or do they only work with expressions?
10:57:30 <mreh> I think this will be much easier with CPP
11:03:24 <phadej> mreh: [d| instance .... |]
11:06:23 <mreh> phadej: is that dump?
11:09:13 <phadej> declaration
11:09:32 <phadej> read about quasiquoters in ghc manual
11:09:56 <phadej> default is expressuon, but there is for declarationa, types and patterns
11:19:30 <mreh> phadej, okay, are there examples, I'm falling over the syntax, maybe the wiki is more detailed
11:29:47 * hackage poly 0.1.0.0 - Polynomials  https://hackage.haskell.org/package/poly-0.1.0.0 (Bodigrim)
11:33:26 <orzo> When GHC needs to look up an instance, does it use a logarithmic lookup sructure?  I ask because the gi-gtk package using OverloadedLabels is really really slow when there is a type failure.  It is okay when your types are correct, but something about producing the error message is way too slow.
11:34:08 <orzo> this is with ghc 8.4.4
11:35:00 <orzo> The slowness is probably why they made a cabal flag to disable the OverloadedLabels support.
11:35:31 <orzo> They say you pay a compile-time penalty for it, but what they don't say is that the penalty is ridiculously high.
11:44:37 <orzo> "Language pragmas can be preceded or followed by comments and whitespace, but they must precede any other Haskell code in the module." -- So what's the convention for haddock comments for the module?  Before or after the langauge pragmas?
11:50:05 <geekosaur> for consistency I put them after
11:53:21 <Cale> orzo: Haddock annotations count as comments
11:53:28 <Cale> So it doesn't really matter
11:56:29 <orzo> I'm asking about convention.  I know it "doesn't matter".  But if there's a common practice, I want to conform.
11:56:47 <orzo> I'll conform to geekosaur since he's brave enough to offer an opinion
12:04:29 <lyxia> Putting the pragmas first makes them easier to process automatically, although I haven't actually made use of that.
12:07:06 <__monty__> lyxia: Except you're doing it wrong if you're relying on that : /
12:10:45 <loller> hello, can anyone tell me what is wrong with the following function declaration
12:11:03 <loller> sum :: [a] -> [a]
12:11:03 <loller> sum = scanl (+) 0 [a]
12:11:15 <Cale> The [a] at the end
12:11:25 <loller> how should I write it ?
12:11:33 <loller> I want the list [a] as input to the function
12:11:35 <Cale> just delete those characters
12:11:41 <rfold> sum = scanl (+) 0
12:11:46 <rfold> or: sum xs = scanl (+) 0 xs
12:11:55 <loller> ah
12:12:04 <loller> but why can I leave out the [a] ?
12:12:10 <rfold> the type signature does not bring arguments into scope; you have to write them explicitly before the = sign
12:12:11 <Cale> The [a] in the type refers to the type of lists of elements of type a
12:12:24 <Cale> e.g. [Integer] would mean lists of Integer values
12:12:43 <loller> okay
12:12:48 <Cale> Oh, you'll also need a constraint in the type saying (Num a) => ...
12:13:01 <Cale> because this definition won't work if your values aren't numbers
12:13:03 <__monty__> The type's wrong too, no? scan creates a [[a]].
12:13:17 <Cale> No, it makes a list
12:13:21 <Cale> > scanl (+) 0 [1,2,3,4]
12:13:23 <lambdabot>  [0,1,3,6,10]
12:13:29 <rfold> foldl returns the final accumulator. scanl creates a list of accumulators.
12:13:33 <__monty__> Yeah, my brain messed up.
12:13:51 <Cale> loller: At the term level, [a] would be a singleton list whose only element was a
12:13:58 <Cale> loller: but a isn't in scope here
12:14:27 <Cale> loller: So it doesn't make sense to write that at all
12:14:48 <Cale> loller: You can either say that your function, called sum, is the same as the function scanl (+) 0
12:15:04 <loller> ah
12:15:05 <Cale> or you can say that for any list, say xs, that sum xs is equal to scanl (+) 0 xs
12:15:12 <loller> and then it will implicitly accept the same input?
12:15:23 <Cale> yeah, well, they will be the same function
12:15:33 <loller> yeah, I think I see what you mean
12:15:53 <loller> it works now in any case, thanks
12:17:00 <loller> I have another function that I can't figure out what's wrong with, but it might need to be rewritten altogether
12:17:13 <loller> the GHC error messages don't really help me at all, but they're infamous for that I guess
12:17:31 <loller> diff :: [(a,b)] -> [c]
12:17:31 <loller> diff [] = []
12:17:31 <loller> diff ((a,b):xs) = (a-b):(diff xs)
12:18:06 <loller> what I wanted here is a function that takes a list of tuplets and returns a list of the differences of their elements, like [(200,400),(500,300)] becomes [-200,200] for example
12:18:06 <__monty__> They certainly aren't, they're actually really helpful once you get used to them.
12:18:19 <geekosaur> (a) you should use a pastebin (b) and include the error message(s) in the paste
12:18:25 <loller> well I have no idea what they're trying to tell me
12:18:36 <loller> okay, one sec
12:18:44 <Cale> loller: You probably meant to write diff :: (Num a) => [(a,a)] -> [a]
12:19:06 <geekosaur> and yeh, first guess is missing Num instance so it doesn't know how to (-)
12:19:07 <Cale> loller: or just comment out the type signature and ask ghci what the type of diff is
12:20:00 <Cale> loller: Whenever you perform numerical operations like (+), (-), (*), (/) etc. they tend to require both arguments and the result to have the same type
12:20:03 <Cale> :t (-)
12:20:04 <lambdabot> Num a => a -> a -> a
12:20:21 <loller> ah, I see
12:20:39 <loller> lambdabot: can I write it like that even though I want it to accept a list of tuplets?
12:20:40 <Cale> so, diff won't really work with a, b, c being distinct types, and you'll probably get a complaint at least about that, but also about the fact that a Num instance will be required
12:20:56 <Cale> diff :: (Num a) => [(a,a)] -> [a]
12:21:34 <loller> here is a pastebin that includes the error messages btw: https://pastebin.com/vBbFYnC1
12:21:50 <ProofTechnique> > map (uncurry (-)) [(100, 200), (17, 10)]
12:21:52 <lambdabot>  [-100,7]
12:22:16 <Cale> Right, so that first error is telling you that diff is supposed to produce a list of values of type c, but instead the implementation is producing a list of values of type a
12:22:30 <royal_screwup21> looking at a function defined like so: robot = Mov ⟨$ char 'f' ⟨∗ optional (char ' ') ⟨∗⟩ number ⟨∗ string ", " ⟨∗⟩ robot -- are parser combinators usually left associative? I don't quite understand where execution would start
12:22:59 <Cale> The second error is telling you that the second argument to (-) has type b, while it also should have type a if the values are supposed to be subtracted
12:23:14 <Cale> (you can't subtract things of different types)
12:23:48 <loller> I think I somehow got the idea that the variables in the type declaration (?) had to be a, b, c if I was going to refer to a, b, etc. when defining the function
12:24:06 <Cale> In fact, those variables are in completely separate namespaces
12:24:21 <Cale> Terms and types don't share names generally
12:24:23 <loller> but I guess I should think of the line "diff ((a,b):xs) = (a-b):(diff xs)" as describing a pattern?
12:24:46 <ProofTechnique> Pattern *matching*, even
12:24:47 <loller> that is it, if it finds a tuple "(a,b)" at the beginning of a list, then a is the first and b is the second element right?
12:24:48 <Cale> yeah, the ((a,b):xs) on the left hand side of the equation is a pattern, which will be matched against the argument
12:24:52 <Cale> yes
12:25:07 <Cale> and this pattern will only match a nonempty list
12:25:17 <loller> both functions work now, thanks a lot
12:25:33 <loller> and I think I see what I did wrong
12:26:34 <loller> I realized now I shouldn't have named my function "sum", though
12:27:28 <Cale> Yeah, that's already taken
12:27:32 <Cale> > sum [1,2,3,4,5]
12:27:34 <lambdabot>  15
12:40:18 <bifunc2> Has anyone here used Hakyll?
12:40:21 <bifunc2> (static web sites)
12:40:53 <Rembane> bifunc2: Yes, a long time ago. Are you stuck?
12:41:47 <bifunc2> Rembane just a general question.. they say it's useful for blogs... but i don't see how because blog posts have dates. i'm supposed to hardcode dates into my blog posts (and corresponding URL)?
12:42:11 <bifunc2> so, manually write out something like "January 1, 2019" ?
12:42:20 <Rembane> bifunc2: No, it will do that for you. 
12:42:57 <FOSS_Fundraiser> Due to recent legal battles, Freenode has run into hard times and needs help from the FOSS community in meeting its annual hosting costs.  We need to raise $10,000 USD by the 1st of May in order to ensure another year of smooth operation.  Will you become a Freenode medallion member today by donating 1 mBTC or more?  Any donation of 1 mBTC or higher automatically enters you into a raffle for a 5 star safari dinner with Mark Shuttleworth at 
12:42:59 <FOSS_Fundraiser> Kruger National Park in South Africa, including 4 days and 5 nights in Johannesburg. bitcoin:39ZkLrzCsoiRa3GPcTUHyWFFuwfuvPJW48?amount=0.01000000&label=Keep%20Freenode%20Online&message=Help%20us%20pay%20for%20our%20hosting%20and%20to%20keep%20serving%20the%20open%20source%20community%21
12:43:15 <Rembane> Why does this feel like a scam? 
12:44:25 <bifunc2> Rembane what does it do for me? so it's not fully static? (a date on the backend turning into a formatted date sounds dynamic)
12:45:15 <Rembane> bifunc2: It generates a static html file. Or rather, many html files. 
12:45:21 <hc> Rembane: probably because it is?
12:45:34 <Rembane> hc: then my smell is still working as it should.
12:45:55 <hc> I mean, no freenode cloak, bitcoin, ... :-)
12:45:58 <nshepperd> ah yes, a 5 star safari dinner with Mark Shuttleworth
12:46:07 <hc> K-Line
12:46:40 <Rembane> Booom! 
12:46:51 <EmilKarlson> is bitcoin URI now a thing
12:47:07 <EmilKarlson> well, probably decades already
12:47:26 <EmilKarlson> if btc is that old
12:47:26 <nshepperd> it's been a thing for a while
12:59:17 * hackage http2-client-exe 0.2.0.0 - A command-line http2 client.  https://hackage.haskell.org/package/http2-client-exe-0.2.0.0 (LucasDiCioccio)
13:09:47 * hackage tidal 1.0.12 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-1.0.12 (AlexMcLean)
13:11:17 * hackage http2-client-grpc 0.7.0.0 - Implement gRPC-over-HTTP2 clients.  https://hackage.haskell.org/package/http2-client-grpc-0.7.0.0 (LucasDiCioccio)
13:28:29 <orzo> When I see a warning "Pattern match checker exceeded (2000000) iterations" what is the ramifications of exceeding this max?  Just failure to determine redundancy or something?
13:28:53 <orzo> It can't be serious or it'd be an error rather than a warning, right?
13:29:25 <Cale> Well, it would mean that it was having a lot of difficulty deciding whether your pattern match was total or not
13:29:53 <orzo> i don't think i even have that incomplete-patterns warning turned on though
13:30:10 <orzo> why would it need to check total if you don't ask for incomplete-patterns warning?
13:30:48 <Cale> Isn't that default?
13:31:06 <orzo> no
13:31:12 <orzo> it's not even included in -Wall
13:31:23 <stevenxl> Hi everyone. I am using the decode function from the cassava library (https://www.stackage.org/haddock/lts-13.17/cassava-0.5.1.0/Data-Csv.html#v:decode). My file has names that include what in spanish are called "asentos". For example: Hernández, and teh decode function is throwing an error due to that.
13:31:54 <Cale> orzo: Yes it is.
13:32:02 <Cale> It's even included in plain -W
13:32:12 <Cale> (but indeed, it's not default)
13:33:08 <Cale> orzo: But I'd be worried about the design choices that led to anything which caused such an error, because it probably means you have a type with a ridiculous number of cases or something.
13:33:12 <orzo> hmm, well, something wasn't in Wall an di was surprised by its lack, I thought it was this, but I guess not.
13:33:13 <stevenxl> What do I need to do so that decodign works
13:33:37 <nshepperd> -fwarn-incomplete-uni-patterns isn't in -Wall
13:33:39 <orzo> Cale, it's not actually my code
13:33:59 <nshepperd> but -fwarn-incomplete-patterns is
13:34:38 <Rembane> stevenxl: Does it work without the asentos? 
13:34:52 <Cale> "accents"
13:35:03 <stevenxl> Rembane: Yea. I think I ran into the problem these folks did: https://www.stackbuilders.com/tutorials/haskell/csv-encoding-decoding/
13:35:26 <stevenxl> So I can't derive the FromRecord instance because that assumes utf-8. I gotta write the instance by hand.
13:35:38 <stevenxl> And use a decodeLatin1 func.
13:35:42 <stevenxl> I guess that's not too bad.
13:35:50 <stevenxl> Rembane: is that where you were headed?
13:38:11 <Rembane> stevenxl: That's where I'm headed. 
13:38:18 <stevenxl> Thank you!
13:38:25 <Rembane> stevenxl: No worries! 
13:38:43 <Rembane> stevenxl: The instances shouldn't have to be too complicated even when you have to write them manually. 
13:39:28 <stevenxl> Rembane: Yup. Not bad at all. In fact, I think I can use a newtype in the record I am trying to unwrap and use the latin function only for the FromField instance of that. 
13:39:38 <stevenxl> but i think i have enough to make forward progress
13:39:40 <stevenxl> gracias
13:40:35 <Rembane> stevenxl: Good stuff. Good luck! Come back if you get stuck. 
13:40:43 <stevenxl> will do
13:42:08 <johnw> If Mealy is Mealy a b = a -> (b, Mealy a b), what is Something a b = a -> Either b (Something a b)?
13:42:53 <koz_> johnw: Not Moore is it?
13:42:54 <stevenxl> Wow; I really should have read first. This is exactly the solution "I came up with" in teh docs (https://www.stackage.org/haddock/lts-13.17/cassava-0.5.1.0/Data-Csv.html#g:6)
13:43:15 <Solonarv> johnw: hm
13:43:24 <lyxia> Parser :P
13:43:28 <johnw> Moore a b = Moore b (a -> Moore a b)
13:43:35 <Solonarv> the obvious intuition is "consumes a bunch of 'a's and eventually produces a 'b'"
13:43:40 <royal_screwup21> what are .lhs files used for?
13:43:44 <johnw> Solonarv: exactly
13:44:21 <koz_> royal_screwup21: Literate Haskell.
13:44:32 <koz_> So you can like, write a LaTeX document and have actual Haskell in it.
13:44:42 <Solonarv> royal_screwup21: they allow you to embed Haskell code in a (markdown, TeX, whatever) document, and have it be directly executable
13:44:42 <koz_> Then have the compiler make a program from the Haskell parts.
13:44:48 <lyxia> royal_screwup21: https://en.wikipedia.org/wiki/Literate_programming in Haskell
13:45:16 <koz_> What's the Haskell off-topic channel?
13:45:21 <koz_> I keep forgetting.
13:45:35 <Solonarv> koz_: there are two
13:45:43 <Solonarv> #haskell-blah and #haskell-offtopic
13:45:49 <koz_> What's the difference?
13:45:59 <Solonarv> uhh, one of them requires you to be identified
13:45:59 <Solonarv> I think
13:46:09 <koz_> (also, is this a meta-offtopic discussion? :P)
13:46:17 <Solonarv> I just hang in both so I don't really care :p
13:47:44 <Rembane> One of them needs you to have SSL enabled I think. 
13:57:23 <wildtrees[m]> blah requires ssl
14:18:07 <duncan^> SSL is good
14:23:08 <lyxia> is it
14:23:51 <Rembane> Some think it is, some think it isn't. I'm out of popcorn so I won't encourage a discussion right now. 
14:24:11 <Solonarv> perhaps that discussion should take place in -offtopic
14:24:14 <Solonarv> or -blah
14:24:16 <Solonarv> who knows!?
14:24:30 <Rembane> Pick the one that uses SSL and it will be extra fun. :D
14:27:29 <Uniaika> hahaha
14:27:32 <Uniaika> nice one, Rembane 
14:27:54 <Rembane> Uniaika: ^^
14:47:47 * hackage simple-ltl 2.0.0 - A simple LTL checker  https://hackage.haskell.org/package/simple-ltl-2.0.0 (JohnWiegley)
15:19:17 * hackage tidal 1.0.13 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-1.0.13 (AlexMcLean)
16:22:38 <boundary123> hey can anyone help me with understanding wahts happening within this function https://pastebin.com/j7FT620t   ? am very lost with it haha
16:31:17 <Entroacceptor> boundary123: sure. Can you tell me what of it you do understand?
16:34:58 <boundary123> Entroacceptor, i understand that it is a function to convert a decimal number to binary. i understand how to do it on paper mathematically but i am having trouble understanding how to convert that to a function of my own and i am just trying to understand what this example function is doing with "n"
16:38:06 <Entroacceptor> Ok, the first line is easy. if you just call toBin 0, the answer is, of course, [0]. 
16:38:58 <Entroacceptor> the second line uses things called "guards". 
16:39:29 <Entroacceptor> Everything before the single '=' is a guard, which says "if this condition holds true, the function body is what follows"
16:40:44 <Entroacceptor> so there's two different function bodys, one if n is odd, one for if n is even. 
16:42:43 <Entroacceptor> so, if n is odd, we append a 1. Append it to what? That's where recursion comes into play.
16:43:16 <Entroacceptor> let's say we call toBin 5. The expected answer would be [1,0,1], right?
16:43:29 <boundary123> ya that would be the expectd answer
16:44:52 <Entroacceptor> So let's start putting it in. toBin 5. So it's not 0, so we ignore the first line. Then we got the next line, which is a definition for toBin n with two guards.
16:45:21 <Entroacceptor> Check the first guard: n `mod` 2 == 1. 5 modulo 2 is one. So that condition checks true.
16:45:50 <Entroacceptor> so we now have toBin ( n `div` 2) ++ [1]. ++ is the array appendix operator. 
16:46:32 <Entroacceptor> So first we have to see what n `div` 2 is, that's just integer division ignoring the rest, so 5 div 2 = 2. 
16:46:49 <Entroacceptor> 2 mod 2 is? 
16:46:59 <boundary123> 0 :D
16:47:12 <boundary123> im following you
16:47:19 <Entroacceptor> zero, so we now have toBin (2 `div` 2) ++ [0] ++ [1]. 
16:47:42 <Entroacceptor> You see where that [0] comes from now?
16:48:15 <boundary123> ahhh i see. so anyhting within the | guards must be executed sequentially?
16:48:19 <boundary123> yes i definitely do see
16:49:33 <Entroacceptor> There's two concepts here: guards, and recursion.
16:49:55 <Entroacceptor> and I lied, the answer is [0, 1, 0, 1] :D
16:50:12 <Entroacceptor> you have to stop the recursion somewhere. 
16:50:56 <Entroacceptor> and that's where the first line of the function definition comes into play: after 1 div 2 you get a call to (toBin 0)
16:51:36 <Entroacceptor> and that's when you get [0]++[1]++[0]++[1], which is the same as [0,1,0,1].
16:52:28 <boundary123> oh my god, i fully understand what is going on now, you have given such a better explanation that i have been looking at online
16:54:11 <Entroacceptor> although the whole book is a bit dated, recursion is explained at http://learnyouahaskell.com/recursion
16:56:09 <boundary123> ahh okay, i will check that out thank you very much!
16:56:30 <boundary123> one last question, how would you go about dealing with negative integers?
16:58:56 <Entroacceptor> well, how would you encode a negative integer?
16:59:34 <Entroacceptor> > -5 `mod` 2
16:59:36 <lambdabot>  -1
16:59:56 <Entroacceptor> so that wouldn't match any of the guards
17:03:12 <boundary123> would you need to have it read the negative integer as a non-negative and then have a condition that if it is negative, to add an extra 1 at the start of the binary output?
17:06:21 <Entroacceptor> something like that sounds sensible, yes
17:06:57 <boundary123> okay thank you for that, i will have a crack
17:07:16 <boundary123> also with this irc, how do i stop it from showing when people have joined at left??
17:07:39 <glguy> boundary123: There's an option to hide that in the hamburger menu
17:08:24 <boundary123> awesome, got it thank you
17:39:46 <remexre> is there a convenient Applicative m => (a, b) -> (a -> m c) -> m (c, b)?
17:41:21 <lyxia> remexre: Bitraversable https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bitraversable.html
17:41:56 <remexre> oh cool, thanks!
17:42:21 <remexre> for some reason that doesn't show up plugging that type sig into Hoogle (the CLI, at least)...
17:52:11 <fen> so there is something pretty intense going on at type level with this idea of trying to compose states into nestings to unfold nested containers - basically, there is a list of state types and the head of this is the kind of state which is normally producing values
17:52:33 <fen> and then, the rest of the list of states only appear when this lowest level fails to return a value
17:53:04 <fen> this gives a crazy kind of type level thing, something like Either, but where you can *maybe* specify if its left or right at type level
17:55:55 <fen> that is, the state which unfolds the lowest layer - which is kind of like an either, all states seem to be (not having streams here) in that they can either fail or not, and give different types in these cases - is *only ever success* and similarly, if it fails, the state will then return a state of a level being unfolded further up the nesting, which again, is restricted at type level to the case where it succeeds 
17:56:39 <fen> data EitherT :: Maybe Bool -> * -> * -> 
17:56:46 <fen> *
17:57:42 <fen> so if thats given Nothing at type level as its first argument, then it is like a normal Either, but if it has Just True for example this means it is restricted to only return Left.
17:57:54 <fen> seems pretty mental
18:58:06 <infinisil> I have this function in my code which is supposed to catch *all* exceptions (except user interrupts), and just restart whenever there is one 
18:58:14 <infinisil> https://gist.github.com/Infinisil/bd4f1682b503ec77f656ddd37f880765
18:58:44 <infinisil> But just now I encountered that it doesn't seem to catch everything after all
18:59:25 <infinisil> Can any exception escape from that code? I'd think not
19:03:52 <glguy> infinisil: You shouldn't make a recursive call into your function from the exception handler of a catch
19:05:50 <jusss> the kind type, what it's used for?
19:08:04 <geekosaur> a kind is the type of a type
19:08:06 <infinisil> glguy: Oh, good point
19:08:13 <geekosaur> :k Int
19:08:14 <lambdabot> *
19:08:17 <geekosaur> :k Maybe
19:08:18 <lambdabot> * -> *
19:08:25 <geekosaur> :k Functor
19:08:25 <lambdabot> (* -> *) -> Constraint
19:16:34 <jusss> geekosaur: when I need to use it?
19:17:24 <geekosaur> most of the time it's just an internal detail. you'll care if you start doing a lot with higher order types
19:18:10 <geekosaur> internally it's how Haskell knows the difference between something like Int which is complete as is and has values, and something like Maybe which needs to be applied to another type
19:19:31 <geekosaur> standard Haskell doesn't even provide a way to talk about kinds
19:20:50 <jusss> it's related with higher order logic?
19:22:14 <infinisil> glguy: Alright this should be better: https://gist.github.com/Infinisil/bd4f1682b503ec77f656ddd37f880765
19:22:36 <geekosaur> it's related to the fact that type level behaves somewhat like value level. you can have a "type constructor" like Maybe that can be applied to a type to produce another type; type families give you type-level functions; typeclasses need to track kinds so that class Monoid knows it is applied to a complete type, whereas class Functor knows it applies to a type constructor that requires another type as a parameter
19:23:04 <infinisil> I also realized that what I had previously would just exit normally when no exception is thrown and the action just finishes
20:37:17 * hackage exception-hierarchy 0.1.0.2 - Exception type hierarchy with TemplateHaskell  https://hackage.haskell.org/package/exception-hierarchy-0.1.0.2 (YoshikuniJujo)
20:44:19 <boundary123> how can i make my function handle negative integers when converting to binary?
20:45:06 <mud> Depends. What do you want to happen? The usual is to encode them in twos-complement, but also possible would be a simple sign bit or a few other things.
20:45:51 <boundary123> currently i have https://pastebin.com/j7FT620t  but am just unsure what to do from here on
20:46:22 <boundary123> my task requires my function to be able to handle negative integers and produce an error message when a float is input but im at a complete loss
20:47:17 <mud> An error message? That sounds rather odd to me. Usually that would just not compile if you don't want it to work.
20:47:21 <Cale> boundary123: How does the task say to handle negative numbers?
20:48:21 <boundary123> https://imgur.com/a/9rnjrx8 this is the task i have been given
20:49:37 <mud> Is this specific to haskell?
20:49:45 <boundary123> ya specific to haskell
20:51:00 <mud> That error message part is so unidiomatic to haskell that I'm not even sure what they're expecting you to do there.
20:52:20 <mud> boundary123: Okay, the negative number part is clear though at least. They just want you to put a - at the start.
20:52:48 <boundary123> i think the error message is just a competency part of the task
20:52:53 <mud> boundary123: For that, I'd suggest you have a wrapper function that handles that part, and then another numToBinary' that *only* has to know how to handle positive numbers.
20:53:09 <boundary123> ahhh i see what youre saying
20:53:23 <mud> Well, I mean I have no godly idea why you'd want that function to work like that, usually if a function shouldn't handle a type, you just make it not fit the type signature. Which is the obvious type sig you'd write for this anyway.
20:54:09 <mud> I think the only way I even know how to make it do the weird error message is to add my own goofball typeclass. Maybe I'm not thinking of something though *shrug*
20:54:31 <boundary123> haha right right
20:54:33 <Cale> mud: You're quite right, this would have to be a class method.
20:54:53 <boundary123> could you explain the wrapper function? im not sure ive encountered those yet
20:55:03 <MarcelineVQ> class method? the output type is String
20:55:09 <Cale> It looks like you're supposed to handle negative numbers just by outputting a "-" sign beforehand though, so that should be easy
20:55:28 <boundary123> Cale, would you also use a wrapper function for the negative?
20:55:28 <Cale> MarcelineVQ: I mean, in order to do something different for Float
20:56:07 <Cale> boundary123: No, just have something like  numToBinary n | n < 0 = '-' : numToBinary (-n)
20:56:25 <mud> Oh, yes that's a better way than a separate wrapper function ^ do that
20:59:12 <MarcelineVQ> boundary123: you should look for actual haskell exercises if you want to learn haskell :> Not that this is a bad route, but they'd be more clearly specified.
20:59:43 <mud> Well, it did say this is supposed to be haskell-specific.
20:59:48 <mud> s/it/they/
21:00:57 <boundary123> when i write in | n < 0 = '-' : numToBinary (-n) i am getting a type error. should i be using something other than [Int]?
21:02:01 <mud> What's the type of numToBinary?  :: [Int] -> String  ? I'd think more :: Int -> String makes sense (ignoring the fun float part)
21:02:35 <mud> (Using Integral could also be nice, instead of being specific to Int)
21:04:41 <boundary123> okay, thank you very much
21:04:51 <boundary123> is haskell a hobby for you guys? or do you use it in daily work etc?
21:05:09 <Cale> I use Haskell at work.
21:05:35 <Cale> I work for a company called Obsidian Systems, we primarily build web and mobile applications, entirely in Haskell.
21:09:59 <boundary123> oh very cool. can ios applications be built in haskell? or is it xcode only
21:11:47 * hackage simplest-sqlite 0.1.0.1 - Simplest SQLite3 binding  https://hackage.haskell.org/package/simplest-sqlite-0.1.0.1 (YoshikuniJujo)
21:52:04 <bauernbrot> A while back, I stumbled upon a webpage (I believe backed by a program written in Haskell) which took an input data structure and an output data structure and attempted to find a function that would conduct a transformation between the two for you. Does this ring a bell for anyone? Trying to find it again...
22:22:17 * hackage simple-ltl 2.1.0 - A simple LTL checker  https://hackage.haskell.org/package/simple-ltl-2.1.0 (JohnWiegley)
22:22:50 <johnw_> Cale: I was able to pull out enough tricks to get speed down from 6.1s to 1.8s
22:44:16 <cbarrett> Cale: I've heard of Obsidian, sounds very cool :)
22:47:17 * hackage yesod-persistent 1.6.0.2 - Some helpers for using Persistent from Yesod.  https://hackage.haskell.org/package/yesod-persistent-1.6.0.2 (MichaelSnoyman)
22:47:50 <haskellhelp> if i want to be able to input negative numbers and recieve a negative binary, can i simply append a '-' to the output?
22:55:33 <jle`> haskellhelp: hm, what do you mean by 'input negative numbers'
22:55:37 <jle`> do you mean as a literal in source code?
22:55:47 * hackage winery 1.1.1 - A compact, well-typed seralisation format for Haskell values  https://hackage.haskell.org/package/winery-1.1.1 (FumiakiKinoshita)
22:56:11 <jle`> and what output are you referring to?
22:56:13 <haskellhelp> im just trying to get this function to work for binary numbers https://pastebin.com/FmUbbtw6
22:56:38 <jle`> ah
22:56:40 <jle`> what is the error?
22:56:41 <haskellhelp> if the input n is less then zero id like the function to add a '-' infront
22:56:52 <jle`> does it not work right now?
22:56:59 <haskellhelp> Couldn't match type `Char' with `Int'
22:57:07 <haskellhelp> yes its not working at the moment
22:57:29 <jle`> haskellhelp: right, do you see why that error is happening?
22:58:15 <haskellhelp> i think i sort of do but i doubt myself haha
22:58:23 <jle`> what do you think the reason is?
22:58:27 <haskellhelp> and i dont know how to fix it
22:58:44 <haskellhelp> becuase i am usuing characters instead of int
22:58:55 <jle`> right, you want to return an [Int]
22:59:01 <jle`> but you are consing a '-', which is a Char
22:59:12 <jle`> one thing you can do maybe is return a [Char] instead
22:59:25 <jle`> aka, a string
22:59:36 <jle`> so toBin 0 = ['0'], not [0]
22:59:39 <jle`> that way things are consistent
23:00:53 <haskellhelp> so do you mean by saying toBin :: Int -> [Char]
23:01:16 <jle`> yes, since that is closer to what you "really" want, isn't it?
23:01:27 <jle`> well, really, it all does depend on what you actually want to do in the end
23:01:45 <jle`> but if you want to return a list of 0's, 1's and '-''s, then one option you can do is have a list of Char's
23:01:50 <jle`> there are other potential options as well
23:03:10 <haskellhelp> im working on a task, and it says that my function must be able to handle negative integers aswell. For example, if i input toBin -63 then it should return "-111111"
23:03:50 <jle`> ah, "-11111" is a string, so that makes sense in this case
23:05:02 <haskellhelp> must admit, im very lost with this
23:05:47 * hackage warp-tls-uid 0.2.0.6 - set group and user id before running server  https://hackage.haskell.org/package/warp-tls-uid-0.2.0.6 (YoshikuniJujo)
23:14:51 <haskellhelp> how could i make a function gie a "this will not work" when a floating point is inpiutted?
23:18:37 <jle`> haskellhelp: you do that using the type signature
23:18:45 <jle`> Int -> [Char] is sufficient
23:18:56 <jle`> then it cannot be given a Float or Double
23:19:55 <haskellhelp> https://imgur.com/a/9rnjrx8 this is the task that im trying to do
23:20:20 <haskellhelp> i have to be able to input a float and have it output a error message
23:20:25 <haskellhelp> very strange task i know
23:21:31 <jle`> hm this does not look like haskell
23:22:03 <jle`> for one, numToBinary -63 is not how you call numToBinary with input -63
23:22:09 <jle`> you'd have to write numToBinary (-63)
23:22:17 <jle`> maybe this assignment is written for another programming language?
23:22:32 <haskellhelp> thats what other people ihave talked to have said. but this class is specifically haskell
23:23:02 <jle`> also, giving different logic based on the input of your type is also very un-haskell, heh
23:23:07 <jle`> this is pretty confusing.
23:23:30 <jle`> it's one of the things you should never do, actually, heh
23:23:56 <jle`> can you ask your instructor what type numToBinary should have?
23:24:04 <jle`> any good haskell assignment should start out by providing the type signature ...
23:24:15 <haskellhelp> yes i will definitely make sure to do that, very confusing
23:24:28 <jle`> is there more to the assignment?
23:24:32 <haskellhelp> jle` would you be able to provide some input on a different section of the task
23:24:39 <haskellhelp> yeai will show you
23:24:47 <jle`> one possibility would be to make the function Double -> String, maybe
23:24:55 <jle`> and then check if the Double is 'close' to a whole number
23:25:24 <jle`> but this also screams against every instinct i have as a haskell developer, heh.
23:25:40 <haskellhelp> https://imgur.com/a/tRxWnFt this is another task within the assignment
23:25:55 <jle`> oh, i meant more to the task
23:25:59 <jle`> it seems like you cut off the image partway
23:26:17 <haskellhelp> oh no, that is all there is to binary conversion task
23:26:22 <jle`> but yeah, your solution you posted seems close? just changing things to output a list of chars instead of a list of Int's
23:26:31 <jle`> and a minor logic error or two
23:27:48 <haskellhelp> https://pastebin.com/38QKGcy9 now i have this howvever when inputting a negative integer it returns No instance for (Num (Int -> [Char])) arising from a use of `-'
23:30:17 <jle`> are you calling it numToBinary (-63)
23:31:02 <haskellhelp> oh i changed it in mine to 'toBin'
23:31:14 <haskellhelp> and am inputting toBin -63
23:31:37 <glguy> toBin minus 63?
23:31:55 <kadoban> You need the parens, as in jle`'s example
23:31:56 <haskellhelp> yes
23:32:02 * nshepperd is tempted to strongly insult the haskell qualifications of whoever wrote this assignment
23:32:22 <jle`> i have already thrown in my insults, so feel free to tack them on :)
23:32:34 <haskellhelp> toBin '-63'
23:32:40 <kadoban> Yes I question who is giving this assignment...at the very least i'd say it's an odd assignment
23:32:44 <jle`> haskellhelp: toBin (-63)
23:33:12 <haskellhelp> oooo toBin (-63) very much breaks it haha
23:33:14 <jle`> note the parentheses
23:33:24 <jle`> haskellhelp: what do you mean by breaks?
23:33:28 <haskellhelp> continuous  _ _ _ _ _ _
23:33:38 <jle`> ah. yeah, that's the logic error i mentioned :)
23:33:48 <haskellhelp> poop
23:33:53 <jle`> one nice thing is that pure functions can be easy to debug, all you have to do is expand it
23:33:56 <jle`> expand the definitions
23:34:03 <jle`> you can evaluate these functions 'by hand'.
23:34:06 <jle`> do you know how?
23:34:16 <haskellhelp> is it safe to say that my teacher is no good and i should look for online sources for my learning of haskell?
23:34:26 <haskellhelp> no im afraid i dont know how
23:34:39 <jle`> so, how functions work in haskell: you replace the function call with the definition
23:34:50 <jle`> for example, if i have a function `myFunction x = x * 2`, how would i evaluate `myFunction 6` ?
23:34:58 <jle`> the process is: myFunction x = x * 2
23:35:13 <jle`> so if you want to evaluate `myFunction 6`, you look at `x * 2` and replace every x with 6
23:35:23 <jle`> so myFunction 6 becomes `6 * 2`, which is 12
23:35:37 <haskellhelp> oh okay i see what you mean by 'by hand'
23:35:44 <jle`> do you see what i did there? i looked at the body of the function (x * 2), and i replaced every x with 6
23:35:59 <jle`> because if i call `myFunction 6`, it matches `myFunction x`, where x is 6
23:36:17 <jle`> so here, try evaluating `toBin (-63)` by hand, and seeing what the problem might be
23:36:30 <haskellhelp> okay ill give it a try
23:37:39 <jle`> well, first think about what you expect the answer to be.  then see why what you get doesn't match the answer you expect
23:38:16 <sicklork1n> `fn <$> fetchSomeThings $ Range 0 500`; how do people deal w/the `$` here? `()`, `do^M`? 
23:38:39 <jle`> what's wrong with it?
23:38:55 <jle`> (fn <$> fetchSomethings) (Range 0 500), right?
23:39:13 <jle`> or, what are you trying to write?
23:39:31 <jle`> are you trying to write fn <$> fetchSomeThings (Range 0 500) ?
23:40:52 <jle`> sicklork1n: i'm not sure what you mean by 'dealWith'.  $ is only really there as an extra tool to make some things more convenient or clear.  if it doesn't help, there's no reason to try to force it to happen...
23:43:31 <sicklork1n> jle`: I mean that <$> and $ on the same line produces a complier error and sometimes the errors can be pretty cryptic.. I've never had a good solution to this problem and wondered if anyone else runs into this again and again.
23:43:51 <jle`> why not just fn <$> fetchSomeThings (Range 0 500) ?
23:44:10 <jle`> or fmap fn . fetchSomeThings $ Range 0 500, if you for some reason feel some odd compulsion to add dollar signs to your code
23:44:15 <jle`> or maybe you are paid per dollar sign :)
23:45:34 <sicklork1n> jle`: If I were paid per keystroke I'd use `()` liberally - it's just that i'm lazy and typically try to avoid () when I can.. Perhaps the above example is a bad one.
23:46:16 <jle`> i can't think of anything that is more readable than blahblah (fetchSomeThings (Range 0 500))
23:46:26 <sicklork1n> I guess I can look at using <&> and &, perhaps this doesn't suffer from the same thing.
23:46:27 <jle`> in this case maybe fmap fn (fetchSomeThings (Range 0 500)) might be more readable
23:46:30 <haskellhelp> jle` when i evaluate toBin (-63) i get 111111, im not sure what im doing wrong
23:46:46 <jle`> haskellhelp: you did that by hand?
23:46:57 <haskellhelp> yes i wrote it out
23:46:58 <jle`> sicklork1n: what is the real solution you are trying to find here?
23:47:11 <jle`> sicklork1n: how to use the least keystrokes?
23:47:15 <jle`> sicklork1n: or how to be the most readable?
23:47:21 <sicklork1n> jle`: both :)
23:47:28 <jle`> fn <$> fetchSomeThings (Range 0 5000) is probably as readable as it gets
23:47:36 <jle`> modulo some switching of <$> and fmap
23:48:05 <jle`> sicklork1n: those are two contradictory goals ;)
23:48:26 <jle`> haskellhelp: and you want -111111 right?
23:48:42 <haskellhelp> yea
23:49:13 <jle`> hm, it's a little weird that your by-hand evaluation gives different results than your ghc evaluation
23:49:31 <jle`> you're evaluating the smae code in both cases, right?
23:49:59 <haskellhelp> oh, well i mean i did really get -111111. following the function writing it out by hand. 
23:50:14 <haskellhelp> i just didnt add the 'minus' on
23:50:17 <jle`> hm, care to show your work?
23:50:38 <jle`> if you call toBin (-63), which branch does it go down?
23:50:44 <jle`> the first, second, or third one?
23:51:10 <haskellhelp> it goes down the seconds as -63 modulus 2 has a remainder of 1
23:52:43 <jle`> > (-63) `mod` 2
23:52:45 <lambdabot>  1
23:53:06 <jle`> hm, fair.
23:53:10 <jle`> but don't you want it to go down the last branch?
23:54:51 <haskellhelp> im not sure what you mean by that
23:56:06 <sicklork1n> jle`: going back to my example again, is the issue that `<$>` has higher precedence than `$`? Do you have an example where this is useful?
23:56:12 <haskellhelp> can i ask, am i right in thinking that n < 0 = '-' : toBin n   means when n is less than 0 a 'minus' sign will be added to toBin n?
23:56:26 <jle`> sicklork1n: yeah, <$> binds tighter than $
23:56:34 <jle`> haskellhelp: yes, that is what it means
23:56:53 <jle`> sicklork1n: so fn <$> fetch $ Range 0 500 is parsed as (fn <$> fetch) (Range 0 500)
23:57:09 <sicklork1n> jle`: does that seem natural to you?
23:57:14 <haskellhelp> what do you see within my function that causes the logic error?
23:58:21 <jle`> sicklork1n: what do you mean by natural?
23:58:38 <jle`> to me when i see a $, i imagine it as the spine of a butterfly that spreads its wings as far as it can go
23:58:50 <jle`> so the $ eats the entire left and right hand sides
23:59:01 <jle`> like (fn <$> fetch)$(Range 0 500)
23:59:23 <sicklork1n> jle`: that <$> binds before $
23:59:41 <jle`> what do you mean by 'natural'
23:59:58 <jle`> what possible natural analogy could this have? :p
