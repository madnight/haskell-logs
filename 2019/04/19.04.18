00:02:58 <jusss> fmap :: (a->b) -> (e->a) -> (e->b)
00:03:29 <jusss> fmap :: (a->b) -> f a -> f b
00:03:45 <jusss> (.) :: (a->b) -> (e ->a) -> (e->b)
00:03:53 <jusss> how to know fmap . fmap :: ?
00:11:17 <dibblego> @type fmap . fmap
00:11:18 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
00:48:47 * hackage haiji 0.3.0.0 - A typed template engine, subset of jinja2  https://hackage.haskell.org/package/haiji-0.3.0.0 (NoriyukiOhkawa)
01:01:43 <luciandesozay[m]> Hey
02:04:22 <TBG> @fl (\(a,b) -> 16^a * b)
02:04:22 <lambdabot> Not enough privileges
02:04:31 <TBG> @pl (\(a,b) -> 16^a * b)
02:04:32 <lambdabot> uncurry ((*) . (16 ^))
02:04:35 <TBG> Oh yeah
02:23:32 <avn> Hello folks. Stack question -- why `stack build` and `stack test` rebuild whole project after each other? How I can figure out what options differ, and cause rebuild?
02:50:24 <zincy> avn: Are you sure that stack test is causing the main executable to rebuild if it has already been compiled?
02:55:23 <Uniaika> yeah, pretty sure you're just rebuilding the library part of your project that has changed since `stack test` was started
02:56:31 <Gander> data Term =     Variable Var   | Lambda   Var  Term   | Apply    Term Term      beta :: Term -> [Term]   beta (Apply (Lambda x n) arg) = [substitute x arg n] . How do I  return the list of all possible reductions? Apparently "ou will need four pattern-matching cases: one to see if the term is a redex, and if not, the three usual cases for Term to look further down in the term. In the first case, don’t forget to look for further redex
03:00:39 <zincy> I don't know about lambda calculus
03:00:55 <zincy> but the permutations function from Data.List springs to mind
03:01:22 <zincy> Could you just get a list of the matching cases and then get all permutations in a new list?
03:03:09 <Gander> Thank I will try
03:04:17 * hackage stm-containers 1.1.0.3 - Containers for STM  https://hackage.haskell.org/package/stm-containers-1.1.0.3 (NikitaVolkov)
03:05:42 <avn> zincy: it start rebuild all 120 modules of project (hopefully not all depenencies)
03:06:14 <zincy> Sounds like it is building all the dependencies from scratch
03:20:47 * hackage ngx-export-tools 0.4.5.0 - Extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-0.4.5.0 (lyokha)
03:22:41 <jeff___> hello
03:25:10 <zincy> hi
03:30:11 <jeff___> PRIVMSG #haskell I was trying to come up with my own version of scanr using foldr, here's what I've got, scanr' f acc ls = foldr ((:) . f) [acc] ls
03:30:53 <jeff___> It seems to be working, but when I tried to add type signature in, scanr' :: (a -> b -> b) -> b -> [a] -> [b] , it throws error
03:32:13 <lyxia> that doesn't look like a scan
03:32:39 <lyxia> > let scanr' f acc ls = foldr ((:) . f) [acc] ls in scanr' (+) 0 [1,2,3]
03:32:41 <lambdabot>  error:
03:32:41 <lambdabot>      • No instance for (Num (Integer -> Integer))
03:32:41 <lambdabot>          arising from a use of ‘e_10123’
03:32:48 <lyxia> > scanr (+) 00 [1,2,3]
03:32:51 <lambdabot>  [6,5,3,0]
03:32:58 <lyxia> > let scanr' f acc ls = foldr ((:) . f) [acc] ls in scanr' (+1) 0 [1,2,3]
03:33:00 <lambdabot>  [2,3,4,0]
03:33:04 <lyxia> > scanr (+1) 0 [1,2,3]
03:33:06 <lambdabot>  error:
03:33:06 <lambdabot>      • No instance for (Num (Integer -> Integer))
03:33:06 <lambdabot>          arising from a use of ‘e_110123’
03:33:14 <lyxia> not the same.
03:39:45 <Sh4rPEYE> merijn: As per your (and Solonarv's) recommendation I replaced the Strings with Vector Char. Also, thanks to the profiling, I found out that a different function took around 50% of the processing power, so I rewrote a part of my scoring function in such a way that this function wasn't needed at all. In total I got to around 50k generations under 4 minutes. Before the optimizations, the runtime was around one generation per
03:39:45 <Sh4rPEYE>  second. Thanks!
03:45:17 * hackage ffunctor 1.1.100 - FFunctor typeclass  https://hackage.haskell.org/package/ffunctor-1.1.100 (fommil)
04:14:48 <Gander> data Term =     Variable Var   | Lambda   Var  Term   | Apply    Term Term    beta :: Term -> [Term] beta (Apply (Lambda x n) arg) = [substitute x arg n]     Apparently ". Since a term may have many redexes, or none at all (if it is in normal form), beta will return the list of all possible reductions." How do I make the output a list of the possible redexes?
04:17:37 <lortabac> hello, I am doing dependent pattern-matching on a singleton Bool: case sing @condition of { STrue -> doMonoidalThing; SFalse -> doOtherThing } A Monoid constraint is needed only for the True case, but I am obliged to require the constraint for the whole function. Is there a way to express that the False case does not require the constraint?
04:27:14 <lyxia> Gander: you can append lists:  [substitute x arg n] ++ more_stuff
04:28:33 <lyxia> lortabac: If condition (Monoid Bar) ()  where If :: Bool -> a -> a -> a   ?
04:30:41 <lortabac> lyxia: do you mean I should use an If type-family in the constraints?
04:30:46 <lyxia> yeah
04:30:57 <lortabac> I see
04:31:46 <lortabac> I think I will make an auxiliary type class with a Bool parameter, and an instance for each of the two cases
04:32:01 <lortabac> the overall code size would be shorter
04:32:23 <lortabac> I am afraid carrying the If constraint everywhere can be too verbose
04:32:58 <lyxia> Sure, that's a fine way.
04:33:15 <lortabac> anyway thanks for the tip :)
04:56:17 * hackage telega 0.2.2 - Telegram Bot API binding  https://hackage.haskell.org/package/telega-0.2.2 (iokasimovmt)
05:20:34 <Gander> beta :: Term -> [Term]  \\ beta (Apply (Lambda x n) arg) = [substitute x arg n]  \\ beta (Lambda x p) = (Lambda x beta(p))  \\ beta (Apply p m) = (Apply beta(p) m) \\ beta (Apply m p) = (Apply m beta(p)) obviously beta(p) returns a [term] instead of term. How can I avoid this to make a recursive function giving beta reduction redexes?
05:26:20 <Solonarv> why does it return a [Term] in the first place? that doesn't seem right to me.
05:31:27 <Gander> "Since a term may have many redexes, or none at all (if it is in normal form), beta will return the list of all possible reductions."
05:34:04 <royal_screwup21> I'm trying to determine the fixed points of the factorial function. I've posted my question here https://cs.stackexchange.com/questions/107154/fixed-points-of-factorial-function I'd love a pointer or two if I'm on the right track :)
05:34:51 <zincy> 1?
05:35:08 <zincy> The fix point of a function is where the argument equals the result
05:35:16 <zincy> Right?
05:35:27 <royal_screwup21> yup...this is in a slightly different context 
05:35:58 <zincy> Oh never mind me then :)
05:43:21 <zincy> Linker is giving me an error that won't be fixed with rm -rf .stack-work or stack clean --full
05:43:25 <zincy> any other ideas?
05:47:17 <zincy> Oh fixed it
05:47:29 <zincy> MacOS headers needed to be installed whatever they are ...
06:45:47 * hackage NaperianNetCDF 0.1.0.0 - Instances of NcStore for hypercuboids  https://hackage.haskell.org/package/NaperianNetCDF-0.1.0.0 (DominicSteinitz)
06:48:17 * hackage NaperianNetCDF 0.1.0.1 - Instances of NcStore for hypercuboids  https://hackage.haskell.org/package/NaperianNetCDF-0.1.0.1 (DominicSteinitz)
08:13:36 <jusss> how to express map . map in other languages? like python or scheme
08:13:56 <ski> Gander : use list comprehensions (or `map',`concat',`concatMap')
08:16:25 <Solonarv> or ugly, ugly lambdas, e.g. python: map(lambda xs: map(f, xs), xss)
08:16:46 <ski> jusss : i was about to say `(compose map map)', but that doesn't do what you wanted, try `(lambda (f lis) (map (lambda (lis) (map f lis)) lis))' instead ?
08:17:30 <ski> jusss : if you `(define ((curried-map) f) lis) (map f lis))', then you can say `(compose curried-map curried-map)' (adjust in the obvious way if you want to work on more than one list)
08:19:08 <ski> (the definition of `curried-map' may also need to be adjusted, if your Scheme doesn't support "curried" `define's)
08:19:37 <glimacs> hi there! can anybody give me a hint on a function i want to implement?
08:19:51 <tdammers> hmmm, I wonder what a practical use case for map . map would be
08:19:57 <tdammers> :t map . map
08:19:58 <lambdabot> (a -> b) -> [[a]] -> [[b]]
08:20:04 <jusss> Solonarv: ski, I know that map . map :: (x2->y2) -> [[x2]] -> [[y2]] 
08:20:07 <tdammers> oh ofc
08:20:09 <tdammers> duh
08:20:37 <jusss> can I through the type signature to get the function's definition?
08:20:47 <ski> tdammers : typically you'd apply it at least to some given function operating on elements. but the composition form can sometimes feel more elegant and easy to read .. at least ime
08:20:57 <Solonarv> jusss: sometimes
08:21:03 <ski> jusss : "through" ?
08:21:20 <Solonarv> roughly speaking, the more general the type signature is the more you can deduce about the implementation
08:21:39 <Solonarv> for the type of (map . map) there are many possible implementations
08:21:43 <jusss> ski: const::a->b->a, id::a->a, so const id::b->a->a  
08:21:45 <tdammers> ski: yeah, I actually use compositions of fmap a lot, and it's perfectly natural - "fmap . fmap" is "drill down 2 levels", informally. my brain somehow just didn't see the case where you specialize it to nested lists
08:22:14 <jusss> f:: const id,   f x y = y
08:22:58 <Solonarv> roughly speaking, the type of map.map is enough to figure out that elements in the result must come from the function argument being applied to elements in the input list
08:23:13 <ski> @djinn b -> a -> a
08:23:13 <lambdabot> f _ a = a
08:23:17 <ski> jusss : like that ^ ?
08:23:34 <Solonarv> but the type doesn't say anything about how the elements are arranged - they could be duplicated, or reshuffled in some arbitrary way, or stuff like that
08:29:00 <jusss> ski: yeah
08:30:00 <jusss> Solonarv: ski, how you think about map .map to express in other languages? I mean the transformation, is there a rule or something?
08:30:24 <ski> what do you mean with "the transformation" or "rule" ?
08:30:55 <jusss> map . map == (map (lambda (lis) (map f lis)) lis)
08:31:16 <jusss> the procedure do that transform
08:31:44 <jusss> sorry for my Bad English
08:33:00 <Solonarv> basically just inline the definition of (.) and eta-expand everything until there are no partial applications left
08:35:46 <ski> jusss : `map' in Scheme is more like a `tupledMap' satisfying `tupledMap (f,xs) = map f xs' in Haskell
08:36:02 <ski> (well, `map' in Scheme also has the functionality of `zipWith',&c. ..)
08:36:33 <ski> (so there's some slight impedance mismatch you need to account for)
08:40:49 <jusss> Solonarv: that eta-expand apply on type signature or function's definition?
08:41:10 <Solonarv> definition
08:43:23 <Solonarv> so we go like this:
08:43:23 <Solonarv>             map . map
08:43:23 <Solonarv> = \f     -> map (map f)               -- 1. definition of (.)
08:43:23 <Solonarv> = \f     -> map (\xs -> map f xs)     -- 2. eta expand the inner 'map' call
08:43:23 <Solonarv> = \f xss -> map (\xs -> map f xs) xss -- 3. eta expand outer 'map' call
08:47:44 <Gander> data Term =     Variable Var   | Lambda   Var  Term   | Apply    Term Term \\ beta :: Term -> [Term]  \\ beta (Apply (Lambda x n) arg) = [(substitute x arg n)] . My code only gives the first of the possible initial beta steps. How can I change this so it includes the other(s)? I know I need to do some sort of traversal as opposed to recursively working outwards    
08:49:14 <ski> Gander : you also need to attempt reducing `arg' in the `Apply (Lambda x n) arg' case (and presumably also `n', if you want reduction-under-lambda)
08:51:11 <ski> Gander : you could have something like `beta (Apply p0 m0) = (case p0 of Lambda x n -> [substitute x arg n]; _ -> []) ++ [..p1.. | p1 <- beta p0]'
08:52:39 <ski> Gander : so you need to consider not only reducing the `Apply'-`Lambda' redex, but also, alternatively, to reduce some subexpression instead. use `++' to concatenate different alternative redices. and use list comprehensions to convert the list of reductions of the subexpression into a list of reductions of the current expression
08:52:53 <ski> Gander : have you seen `case' before ?
08:52:57 <Gander> no
08:54:05 <ski> if you say
08:54:43 <ski>   beta (Lambda x p) = Lambda x (beta p)  -- this is btw incorrect code, it has a type error. but let's ignore that for now
08:55:02 <ski>   beta (Apply p m) = Apply (beta p) m
08:55:13 <ski>   beta (Apply m p) = Apply m (beta p)
08:55:26 <ski> then this is the same as saying
08:55:34 <ski>   beta t = case t of
08:55:46 <ski>              Lambda x p -> Lambda x (beta p)
08:56:16 <ski>              Apply p m  -> Apply (beta p) m
08:56:24 <ski>              Apply m p  -> Apply m (beta p)
08:57:03 <ski> so, instead of "matching on the left of the `='", you can pattern-match, iow do a case distinction, based on the "shape" of a value, "inside" an expression (to the right of the `=')
08:57:32 <ski> btw, the latter two patterns here are (completely) overlapping, which is pretty useless
08:57:39 <ski> the last pattern will never be used
08:57:58 <ski> (this applies both to your original code, and the reformulation of it in terms of `case' that i just showed)
08:58:28 <ski> instead of those last two branches, it would probably be better to say something like
08:58:52 <ski>   beta (Apply p m)  = [Apply (beta p) m]
08:59:06 <ski>                    ++ [Apply p (beta m)]
08:59:14 <ski> (and similarly for the `case' form)
08:59:47 <ski> btw, i'm not suggesting that you should actually do the above `case' reformulation. i'm just showing it to help you get what `case' does
09:00:14 <Gander> Thanks, I appreciate it
09:00:24 <ski> typically, code is considered a little bit more readable, if you can "do your matching to the left of the `='" (without going to extra effort to achieve that)
09:00:36 <ski> but if you can't, then `case' is a good fallback to know about
09:00:53 <ski> in my case, i was suggesting
09:01:10 <ski>   beta (Apply p0 m0) = case p0 of
09:01:25 <ski>                          Lambda x n -> [substitute x arg n]
09:01:53 <ski>                          _          -> [                  ]
09:02:08 <ski>                     ++ [..p1.. | p1 <- beta p0]
09:02:33 <ski> (and no, you don't have to align like this (you do have to align the start of the `case' branches, though). i just like lining things up :)
09:03:17 <ski> the point here is that the latter part, which calls `beta' on the operator term `p0' in the application, should apply regardless of whether `p0' is a `Lambda' or not
09:04:00 <ski> and so i use a `case' in the former part, independent of that latter part, to check if `p0' is a `Lambda', and in that case, generate a beta-reduction as an alternative reduction (otherwise the empty list, so no extra reductions)
09:04:05 <ski> Gander : making any sense ?
09:05:07 <Gander> Yeah, I get what you're saying, thank you very much. What does ..p1.. do btw? I'm quite new to this
09:05:48 <ski> (instead of a `case', you could define a helper function, which you call in place of that `case' expression. that helper would then match on its input, checking whether it's a `Lambda', and so either generate a singleton list (with `substitute'), or else an empty list. that might perhaps be more readable for you. you can try it, and see which you prefer)
09:06:34 <ski> Gander : `..p1..' does nothing, it's illegal syntax. i just wrote that there to suggest that the above snippet isn't finished, you're supposed to fill something in there .. and then perhaps adapt the code a bit more as well :)
09:07:24 <Gander> I'll try your suggestion, sounds good. Oh lol thanks :')
09:09:55 <ski> np :)
09:19:20 <hpyCdr> is there an easy way to get an initial state of MegaParsec's State / PosState? Seems like I have to default 10 fields there http://hackage.haskell.org/package/megaparsec-7.0.4/docs/Text-Megaparsec.html#t:State
09:19:28 <hpyCdr> I want to use runParser'
09:20:15 <jusss> Solonarv: eta-expand is wonderful!
09:20:52 <ski> jusss : yea, it might be a good idea to practice it until it becomes second nature :)
09:23:53 <hpyCdr> let initial = State blob 0 (PosState blob 0 (SourcePos "" (mkPos 0) (mkPos 0)) (mkPos 0) "")
09:24:04 <hpyCdr> kinda silly :/
09:24:27 * ski idly wonders whether there's a `Default' instance there
09:25:39 <Solonarv> cheeky way: create a parser that just immediately succeeds and returns the starting state, and feed that to runParser
09:26:03 <hpyCdr> or leave it like that :D
09:26:16 <hpyCdr> I was trying to write a parser that can be applied one by one
09:26:17 * ski idly wonders why hpyCdr wants the initial state
09:26:25 <hpyCdr> to emit Foo many times instead of [Foo]
09:26:47 <hpyCdr> maybe there's an easier way, but only runParser' seems to support that
09:27:07 <hpyCdr> I'm also using Conduit and want to only emit the results one by one
09:27:30 <qxjit[m]> Does anyone here know how specifying `+RTS -H<size>`  affects the size of the allocation area over the life of the program?
09:28:22 <jusss> ski: through map's type signature we can know it takes two parameter, and through eta-expand, we can consturct (map . map) = \f -> map (map f) to a form that map with two parameter, and then we can get the expression in other language who support lambda, wonderful!
09:29:20 <RedNifre> Hi. Assuming mediocre Haskell knowledge, if I used good libraries, how hard would it be to implement something like a BASIC compiler? (Compiling things like "10 X=1+2" to calculator code like "2 1 + STO 0")
09:30:32 <RedNifre> I think I can figure out the compile part, but what about lexers/tokenizers and parsers?
09:33:08 <ski> jusss : yep :)
09:33:14 <lyxia> RedNifre: megaparsec is pretty good
09:33:55 <ski> RedNifre : you could use BNFc, to lex and parse, getting an AST back
09:33:58 <ski> @where BNFc
09:33:58 <lambdabot> BNF Converter, http://bnfc.digitalgrammars.com/
09:35:56 <ski> (BNFc can output code in Haskell, Java (using Visitor Pattern for the AST matching skeleton it produces), and some more languages i forget)
09:39:53 <RedNifre> Nah, I need to output calculator code. Somebody else already created a tool that converts code like "3; STO I; RCL(i);" to calculator memory dumps which you can then upload.
09:40:10 <RedNifre> Thanks, I'll check out Megaparsec and BNFc.
09:41:27 <ski> RedNifre : yes, but BNFC outputs code that lexes and parses, for you, in the language of your choice (of a small selection supported). then you build on that by traversing the AST and do whatever you like with it
09:41:36 --- mode: ChanServ set +o glguy
09:41:38 --- mode: glguy set +j-o 5:10 glguy
09:41:40 <kort_> I'm really stuck, how do I convert Data.Text.Internal.Text -> Data.Text.Internal.Lazy.Text ?
09:42:13 <Solonarv> kort_: there should be a function for that in Data.Text or perhaps Data.Text.Lazy
09:43:18 <ski> RedNifre : for BNFc, you basically just type in a variant of (labelled) BNF, and it'll automatically from that generate your lexer and parser (in the case of Haskell, using Alex and Happy (lexer and parser generators for Haskell))
09:43:19 <kort_> I found fromStrict but it fails because the output type it's ‘Data.ByteString.Lazy.Internal.ByteString
09:43:21 <RedNifre> ski well, what I need is something that takes BASIC lines like "10 A=2+3:B=8" and represents that as something I can easily work with.
09:43:35 <ski> RedNifre : *nod*, so some form of AST, i'd assume
09:43:36 <kort_> I'm using scotty and trying to return some text in a handler
09:44:03 <RedNifre> ski hm, so it creates Haskell code that reads the BASIC code into an easy to work with AST that I can then use to compile to calculator code, huh?
09:44:29 <Solonarv> kort_: are you sure you looked at the right module?
09:45:02 <Solonarv> https://hackage.haskell.org/package/text-1.2.3.1/docs/Data-Text-Lazy.html#v:fromStrict
09:45:35 <ski> RedNifre : Happy is a bottom-up parser generator (LALR(k) or something, i don't recall detals), like Yacc. however, MegaParsec (and Parsec,AttoParsec,&c.) are parser combinator libraries which yield top-down recursive descent parsers (so think more like LL(k), though perhaps the monadicity of the parsing gives more power ?)
09:45:47 <ski> RedNifre : yep, exactly
09:46:08 <kort_> Solonarv: that's embarassing, I was importing from the wrong module
09:46:14 <kort_> thanks for the hint
09:46:17 <ski> RedNifre : the BNF you declare will correspond directly to Haskell `data' types (if you choose to use the Haskell backend)
09:46:18 <Solonarv> monadic parsing + general recursion give you approximately Very Much power
09:46:31 <Solonarv> kort_: I'd recommend importing ByteString, Text and similar modules qualified
09:46:46 <ski> Solonarv : yes, the problem is that it's hard to analyze, to control unnecessary non-determinism
09:47:00 <Solonarv> that way you avoid the name clashes and confusion
09:47:20 <Solonarv> ski: indeed, and it's a bit too easy to accidentally write a non-terminating parser
09:47:46 <ski> yea, left-recursion and all that
09:51:07 <ski> RedNifre : anyway, if you haven't tried parser combinators, i suggest doing that at some point. but knowing about BNFc (or just underlying tools like Alex,Happy for Haskell; JLex/JFlex,CUP for Java; FLex,Bison for C and C++; GPLEX,GPPG for C#; ocamllex,ocamlyacc for OCaml; Pygments (lexer) for Python) can also be handy
09:51:47 * hackage persist 0.1.1.3 - Minimal serialization library with focus on performance  https://hackage.haskell.org/package/persist-0.1.1.3 (minad)
10:44:53 <reactormonk> I've been trying to compile haskell statically, but I get /usr/bin/ld.gold: error: cannot find -ltinfo
10:45:05 <reactormonk> I'm running with -optl-static and ld-options: -static
10:46:55 <reactormonk> and -fPIC
10:49:58 <koala_man> reactormonk: does that mean it's unable to find libtinfo.a?
10:50:07 <zachk> maybe tinfo is term info? do you have all the required packages/libraries installed, reactormonk 
10:50:17 * hackage snaplet-postgresql-simple 1.2.0.0 - postgresql-simple snaplet for the Snap Framework  https://hackage.haskell.org/package/snaplet-postgresql-simple-1.2.0.0 (DougBeardsley)
10:51:08 <koala_man> here's what I have on my debian system "libncurses-dev:amd64: /usr/lib/x86_64-linux-gnu/libtinfo.a"
10:51:17 * hackage proto-lens-arbitrary 0.1.2.7 - Arbitrary instances for proto-lens.  https://hackage.haskell.org/package/proto-lens-arbitrary-0.1.2.7 (JudahJacobson)
10:53:40 <reactormonk> koala_man, zachk,https://gist.github.com/reactormonk/2804a2fd3a046b595b748836c2be25c9
10:53:49 <reactormonk> that's all there is, so I guess there's no .a with the library
10:54:43 <koala_man> reactormonk: do you have the dev package for ncurses installed?
10:54:55 <royal_screwup21> I'm trying to create a trivial stupid functor instance like so: https://repl.it/repls/CoolNervousLock could someone explain the error to me? :)  I want to map over Animal type, and make it so that that it always results in Animal "foo"
10:55:17 * hackage turtle 1.5.14 - Shell programming, Haskell-style  https://hackage.haskell.org/package/turtle-1.5.14 (GabrielGonzalez)
10:55:29 <reactormonk> koala_man, archlinux, there's no dev package
10:56:13 <Solonarv> royal_screwup21: that's a kind error
10:56:37 <zachk> reactormonk, I have heard ghc isn't very well behaved on arch linux 
10:56:47 * hackage stack 1.9.3.1 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-1.9.3.1 (KirillZaborsky)
10:56:50 <Solonarv> to be given a Functor instance, a type must have kind 'Type -> Type', but the kind of Animal is 'Type'
10:57:07 <royal_screwup21> oh I see okay
10:57:22 <royal_screwup21> so it only works on...paramterized datatypes?
10:57:34 <geekosaur> yes
10:59:07 <koala_man> google hints to a ncurses-full-git AUR package, but it appears to be gone
10:59:11 <reactormonk> zachk, yeah, going full stack
10:59:41 <reactormonk> koala_man, honestly, if it works on an ubuntu that's plenty for me. It only has to work on an azure pipeline in the end
11:04:31 <koala_man> reactormonk: you can easily test it on an ubuntu shell if you have docker installed
11:07:26 <zachk> koala_man, as for your original error, you seem to have tinfo.so.5 but no tinfo.a 
11:24:03 <Gander> beta :: Term -> [Term] beta (Apply p0 m0) = case p0 of                      Lambda x n -> [substitute x m0 n]                      _          -> [                  ]                             ++ [p1| p1 <- beta p0]   How can I modify p1 so it only outputs a lambda beta reduction?
11:24:27 <Gander> data Term =     Variable Var   | Lambda   Var  Term   | Apply    Term Term
11:25:47 <Gander> ski: I took a look and can't resolve it
11:27:24 <Cale> Gander: Aren't you destroying your Apply in the second case there?
11:27:37 <royal_screwup21> could someone explain to how this defintion makes any sense? `data Fix f = In (f (Fix f) )? I get that we have a datatype, Fix, parameterized on f -- but I don't understand the stuff inside In
11:27:39 <Cale> Gander: (and wouldn't you want to preserve it?)
11:28:24 <royal_screwup21> ah ok, so it's two argumets....
11:28:33 <ski> Gander : how much experience with list comprehensions do you have ?
11:28:35 <Cale> royal_screwup21: The idea is that Fix f is roughly the same thing as f (Fix f)
11:28:50 <Cale> royal_screwup21: two?
11:28:51 <Gander> I'm basically new to this, sorry :/
11:29:00 <ski> consider this example
11:29:08 <ski> > [n^2 | n <- [0 .. 9]]
11:29:10 <lambdabot>  [0,1,4,9,16,25,36,49,64,81]
11:29:23 <royal_screwup21> is it basically analogous to this: enum LinkedList<T> {Node:T, next:LinkedList<T> }?
11:29:39 <Solonarv> royal_screwup21: not really
11:29:43 <ski> this is : the list of all `n^2's (squares of `n'), where `n' is drawn from the list `[0 .. 9]', which is shorthand for `[0,1,2,3,4,5,6,7,8,9]'
11:29:47 <Cale> Apart from the recursion, no
11:29:54 <royal_screwup21> oh :(
11:29:55 <Cale> But we could make a list type with this
11:29:59 <ski> Gander : can you read that list comprehension, see wht each part is saying ?
11:30:04 <Gander> yes
11:30:14 <ski> now, consider this
11:30:37 <Solonarv> for an analogy: struct Fix<T> { recurse: T<Fix<T>> }
11:30:56 <ski> > [(m,n) | m <- [0 .. 4],n <- [0,1]]
11:30:58 <lambdabot>  [(0,0),(0,1),(1,0),(1,1),(2,0),(2,1),(3,0),(3,1),(4,0),(4,1)]
11:31:28 <royal_screwup21> Solonarv ah thanks for the pointer 
11:31:38 <ski> Gander : in this case, we have two "genertors" (the `<-' things) in this list comprehension. so we draw `m' from one list, and `n' from another list, and we do that in every possible way, every possible combination
11:32:00 <ski> Gander : in fact, for each possible value of `m', we'll run through all the possible value (only two here) of `n'
11:32:05 <Solonarv> you could write something like what I did using C++ templates, although you might make the template expansion thingy loop forever
11:32:16 <Gander> Ah, I get you
11:32:25 <ski> > [m + n | m <- [0 .. 4],n <- [10,100]]  -- this is a variant of the same thing
11:32:27 <lambdabot>  [10,100,11,101,12,102,13,103,14,104]
11:32:38 <royal_screwup21> Solonarv gonna try it with rust, yeah. I'll need to use boxed types to wrap the recursive Fix
11:32:57 <Solonarv> royal_screwup21: rust doesn't have higher kinded types, you can't (directly) encode Fix in it
11:33:11 <ski> Gander : so, if you're familiar with nested loops in other languages, you could think of this as a nested loop, which output some element to a resulting list, for each combination of values selected in the outer and the inner loop
11:33:31 <royal_screwup21> oh right yeah! 
11:33:39 <ski> Gander : you can also have the sequence of values that the inner loop loops through depend on the current value ("iteration index", in this case) of the outer loop :
11:33:39 <Gander> so I need (Lambda p1 p2) where they're both elements of the beta p0 or something like that? 
11:33:40 <Solonarv> royal_screwup21: in rust, all generic parameters must either be lifetimes or plain old fully-monomorphic types
11:33:57 <ski> > [(m,n) | m <- [0 .. 4],n <- [0 .. n]]
11:33:59 <lambdabot>  *Exception: not an integer: n
11:34:05 <ski> er, sorry, that should be
11:34:07 <ski> > [(m,n) | m <- [0 .. 4],n <- [0 .. m]]
11:34:09 <lambdabot>  [(0,0),(1,0),(1,1),(2,0),(2,1),(2,2),(3,0),(3,1),(3,2),(3,3),(4,0),(4,1),(4,...
11:34:22 <royal_screwup21> yeah makes sense..."type parameter not allowed on this type", with a red underline on Fix<T>
11:34:41 <Gander> I see
11:34:43 <ski> Gander : i'm still just surveying the general possibilities with list comprehensions
11:35:08 <ski> here's another example, now not just with a generator, but also a "guard", and a `let'
11:35:11 <royal_screwup21> Solonarv this is going to be hard for me to grok then :(  Pretty sure Java wouldn't have an equivalent either
11:35:27 <Solonarv> indeed, java generics aren't higher-kinded either
11:35:41 <ski> > [t | n <- [0 ..],let t = n * (n + 1) `div` 2,even t]
11:35:43 <lambdabot>  [0,6,10,28,36,66,78,120,136,190,210,276,300,378,406,496,528,630,666,780,820,...
11:35:59 <ski> if we skip the guard here, we get
11:36:01 <ski> > [t | n <- [0 ..],let t = n * (n + 1) `div` 2]
11:36:04 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
11:36:06 <Solonarv> you could do it in Scala I think (though I don't know if that has newtypes), or perhaps one of the MLs
11:36:34 <ski> which is the list of "triangular numbers" : `0',`0 + 1',`0 + 1 + 2',`0 + 1 + 2 + 3',`0 + 1 + 2 + 3 + 4',&c.
11:37:49 <ski> Gander : so, if the guard (which is any `Bool'ean expression) fails (evaluates to `False'), then further processing of that (combination of) element(s) drawn from generator(s) is skipped (so no element output), continue to next combination
11:38:13 <Gander> Ah, I get you
11:38:59 <ski> > [(l,m,n) | n <- [0 .. 19],m <- [0 .. n],l <- [0 .. m],l^2 + m^2 == n^2]  -- this one computes "Pythagorean triples" (less than twenty)
11:39:01 <lambdabot>  [(0,0,0),(0,1,1),(0,2,2),(0,3,3),(0,4,4),(3,4,5),(0,5,5),(0,6,6),(0,7,7),(0,...
11:39:10 <ski> well, let's skip `0'
11:39:19 <ski> > [(l,m,n) | n <- [1 .. 19],m <- [1 .. n],l <- [1 .. m],l^2 + m^2 == n^2]  -- this one computes "Pythagorean triples" (less than twenty)
11:39:21 <lambdabot>  [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17)]
11:40:08 <ski> ok, i think thats enough about list comprehensions in general
11:40:30 <Gander> Yeah, I understand them now :)
11:40:37 <royal_screwup21> Solonarv I'm trying to think of an example of Fix parameterized on Maybe Int...In (Maybe 3)?
11:40:44 <ski> <Gander> so I need (Lambda p1 p2) where they're both elements of the beta p0 or something like that?
11:40:55 <ski> well, that sounds a bit vague to me
11:41:01 <Solonarv> royal_screwup21: no, the type parameter would be 'Maybe' itself
11:41:06 <ski> Gander : can you make the suggestion a bit more precise ?
11:41:20 <Solonarv> and the one field of 'Fix Maybe' has type 'Maybe (Fix Maybe)'
11:41:52 <Gander> I'm not sure how ://
11:42:01 <ski> royal_screwup21 : `Fix' is a higher-order type function. it takes not an ordinary ("concrete") type like `Maybe Int' as an argument, but a type function, like just `Maybe' (or `Either Integer', &c.)
11:42:06 <Solonarv> royal_screwup21: so, taking away newtype wrappers, x :: Fix Maybe must be something like: Just (Just ... (Just Nothing) ... )
11:42:56 <ski> Gander : if you say `[p1| p1 <- beta p0]', then you're selecting every possible alternative way to do a beta-reduction in `p0', calling each respective next expression `p1' ..
11:43:08 <royal_screwup21> I'll have to write this down to make sense of it...
11:43:17 <ski> Gander : .. but then you just collect the same `p1's as the elements of the list generated by the list comprehension
11:43:43 <ski> Gander : note that `[x | x <- xs]' is the same as just `xs'. you need to do something more, for it to be interesting
11:44:35 <ski> Gander : you started with an `Apply p0 m0' as the original expression .. presumably you want to give back a (list of) variant(s) of that ?
11:44:43 <Gander> yea
11:45:24 <ski> so, you've beta reduced `p0', and you've gotten `p1' back as the result of doing that
11:45:30 <ski> what do you want to do, then ?
11:46:06 <dminuoso> Mmm, is there any libray containing Monoidal (for free monoidal profunctors)?
11:46:25 <ski> (this is also practicing recursive thinking, btw. perhaps you're not so sure of that, yet)
11:46:36 <Gander> reduce p1
11:46:39 <Gander> I assume
11:47:08 <dminuoso> That is: class Profunctor p => Monoidal p where par :: p a b -> p c d -> p (a, c) (b, d); empty :: p () ()
11:47:26 <ski> Gander : what is the overall goal of `beta' ? what should `beta t' return ?
11:47:36 <ski> (for any expression/term `t')
11:48:01 <Gander> it should be a list of all possible one step beta reductions
11:48:19 <ski> yes
11:48:32 <ski> so `p0' have been one-step beta-reduced, to `p1'
11:48:47 * hackage direm 0.1.0.0 - Deletes a directory and retains its contents in the parent directory  https://hackage.haskell.org/package/direm-0.1.0.0 (mgttlinger)
11:48:54 <royal_screwup21> Solonarv what is it about haskell's type system that allows it to have data types like this  that you can't model in rust/c++?
11:48:59 <ski> so you don't want to reduce `p1' again, since then you'd have multiple-step reduction, not one-step
11:49:05 <Gander> oh right
11:49:15 <ski> royal_screwup21 : higher-order types
11:49:21 <Solonarv> royal_screwup21: Haskell allows us to abstract over types of *any* kind
11:49:48 <ski> royal_screwup21 : allowing kinds to be like `(* -> *) -> *' -- allowing type parameters to be type functions, not necessarily concrete types
11:49:54 <c_wraith> you can sort of do that in C++, but it's an indirect hacky thing.
11:49:55 <Solonarv> in particular this means we can abstract over "type functions", i.e. types with a kind like '* -> ... -> *'
11:50:10 <ski> (royal_screwup21 : btw, iirc, you can do this in C++, have a template take another template as argument)
11:50:42 <Solonarv> (but template expansion is "too eager", so I think Fix would sent the compiler into a loop - or perhaps it would bail out)
11:51:18 <ski> Gander : anyway, your original expression was not `p0', but `Apply p0 m0'. so `p1' is not the^Wa one-step reduction of that. what is an example of a one-step reduction of `Apply p0 m0', given that `p1' is a one-step reduction of `p0' ?
11:51:51 <Gander> m1?
11:52:01 <ski> there is no `m1'
11:52:06 <ski> at least not yet
11:52:20 <Gander> beta(m0)?
11:52:23 <ski> hmm
11:52:53 <ski> Gander : here's a different problem, which perhaps would be simpler to think about
11:53:25 <ski> let's say we have some kind of very simple game, with positions being `Integer's (perhaps restricted to some range, but let's ignore that now)
11:53:35 <ski> let's in fact say
11:53:54 <ski> hmm .. or, actually, let's not :)
11:54:05 <ski> so
11:54:27 <ski> each time our player gets to move, they can move left or right, forward or back
11:54:50 <ski> so, we want a function that, given the current position, gives the possible next positions our player could be at
11:54:54 <ski> this could be
11:55:16 <ski>   moveForwardOrBack :: Integer -> [Integer]
11:55:29 <ski>   moveForwardOrBack n = ..n..
11:55:44 <ski> how should we fill in this incomplete definition ?
11:56:06 <ski> what to fill in the "hole" `..n..' (by which i mean, any expression, which is allowed to make use of `n') with ?
11:56:27 <ski> (this should be very simple. not a trick question)
11:56:40 <Gander> n+1 n-1?
11:56:42 <ski> Gander : any suggestion ?
11:56:50 <ski> yeah, if we put those in a list, so
11:57:00 <ski>   moveForwardOrBack n = [n + 1,n - 1]
11:57:48 <ski> so, perhaps this function could be used by an AI, to think about where we could go, and try some things out "in its mind", before actually committing to what to do
11:58:11 <ski> so, this function would give the possible places we could move to
11:58:22 <Gander> I've got to go in like 2 mins :/ So I need to add the beta of m0?
11:58:26 <ski> we could adapt it to only keep positions within some range, if we wanted to
11:58:34 <ski> hmm
11:58:35 <Gander> I appreciate your explanation
11:58:38 <Gander> sorry to hurry
11:58:41 <ski> okay
11:59:27 <ski> i was going to suggest to now write a function `move2D :: (Integer,Integer) -> [(Integer,Integer)]', which used the previous function to move in one of four directions
11:59:38 <ski> i think doing that would give you a hint of what to do with `beta'
12:00:13 <Gander> oh, I get you
12:00:23 <ski> i don't think i can do much more in a minute
12:00:32 <ski> good luck
12:00:45 <ski> you can perhaps come back later, if you have the opportunity
12:00:46 <Gander> Cheers mate for you all your help, really appreciated
12:01:15 <ski> (btw, `move2D' should use list comprehensions)
12:01:29 <Gander> right
12:01:53 <ski>   move2D (x,y) = ..x..y..
12:01:56 <ski> something like that
12:02:51 <ski> `move2D' would be simpler thatn your `beta' case, in that `move2D' wouldn't be recursive
12:02:58 <ski> but otherwise i had the same idea in mind
12:04:01 <Gander> Okay, that's given me a good amount to work with, have a nice day man
12:04:17 * hackage nvim-hs 2.1.0.0 - Haskell plugin backend for neovim  https://hackage.haskell.org/package/nvim-hs-2.1.0.0 (saep)
12:08:05 * ski nods
12:19:17 * hackage stm-containers 1.1.0.4 - Containers for STM  https://hackage.haskell.org/package/stm-containers-1.1.0.4 (NikitaVolkov)
12:26:50 <icyt_> herro
12:27:24 <icyt_> alrighty boys and girls, I have a quest(ion) for you
12:27:42 <Solonarv> ask away!
12:28:11 <icyt_> I'm manipulating a list, and I'm using a comprehension statement to find every possible combo.
12:28:37 <icyt_> But, I also want to have it keep every element in the list as a single element, within the same comprehension
12:30:05 <icyt_> Ex: list = ['a', 'b'] to end up as ['a', 'b', 'ab', 'aa', 'bb', 'ba']
12:32:01 <Cale> icyt_: Well, not literally that, surely
12:32:10 <Cale> You probably meant for there to be strings
12:32:14 <icyt_> Ye
12:32:42 <icyt_> So, thoughts?
12:32:45 <Cale> Do you want a more general thing where you're building strings of arbitrary length?
12:32:46 <ski> > filterM (const [False .. True]) "ab"  -- not quite
12:32:48 <lambdabot>  ["","b","a","ab"]
12:33:03 <icyt_> Yeah
12:33:06 <Cale> You could pick a string length first
12:33:13 <ski> > replicateM 2 "ab"  -- not quite, either
12:33:14 <Cale> and then build strings of that length
12:33:15 <lambdabot>  ["aa","ab","ba","bb"]
12:33:36 <Cale> > [w | n <- [1..2], w <- replicateM n "ab"]
12:33:38 <lambdabot>  ["a","b","aa","ab","ba","bb"]
12:33:50 <Cale> > [w | n <- [1..3], w <- replicateM n "ab"]
12:33:52 <lambdabot>  ["a","b","aa","ab","ba","bb","aaa","aab","aba","abb","baa","bab","bba","bbb"]
12:33:53 <__monty__> [a ++ b | a <- xs, b <- "":xs]
12:34:08 <icyt_> I mean, it's supposed to work for random lists of nouns and adjectives, so I can't choose string length
12:34:21 <Cale> hm?
12:34:39 <ski> __monty__ : `xs' would have to have type `[String]', then
12:35:13 <__monty__> Yes, if it's String, just map pure xs.
12:35:14 <Cale> icyt_: Did you perhaps mean to optionally add adjectives from a list to your list of nouns?
12:35:18 * ski nods
12:36:01 <__monty__> ski: Though a list of nouns sounds like a [String].
12:36:20 <Cale> icyt_: like  adjectify adjs nouns = nouns ++ [a ++ " " ++ n | a <- adjs, n <- nouns]
12:36:22 <ski> possibly
12:36:43 * ski . o O ( adverbs )
12:37:08 <ski> (are some adverbs polymorphic ?)
12:37:31 <icyt_> Alright, y'all have given me a lot to think about and try. I'mma go work on it, Thanks everyone!
12:38:46 <Cale> Adverbs tend to be able to boldly go almost anywhere in a sentence.
12:54:38 <icyt_> For those of you who helped me out earlier, I got it. I was being silly, all we had to do was add the list to the combinations, so there would be an exmaple of each individual element before the combinations. Grazie!
12:58:24 <ski> icyt_ : mhm, how would that look like ?
13:02:55 <__monty__> ski: xs ++ [ comprehension that generates combinations ]
13:08:37 <ski> maybe
13:25:29 <Xunie> Let's say I have some 'data Color = Red | Green | Blue', is it possible for me to use all three colors in a range?
13:26:13 <ski> by "range" you mean ?
13:26:14 <Xunie> I want to define a range called 'deck' that defines of all cards in a Set (the game) card deck.
13:26:42 <Xunie> deck = [ Card col num | col <- all_colors | num <- all nums ]
13:27:21 <ski> by "range" you mean a list of assorted values, possibly constructed as an enumeration, ior via a list comprehension ?
13:27:31 <Xunie> A list comprehension apparently. My bad.
13:27:37 <ski> you probably want that second `|' to be a `,'
13:28:13 <Xunie> Okay, yeah, I wasn't familiar with the syntax. But my point still stands. How do I define a variable 'col' inside of that list comprehension so that all colors are enumerated once?
13:28:19 <Solonarv> derive Enum for your color type and you can write [Red ..]
13:28:24 <ski> otherwise you're not going to get all combinations, but rather the two generators will proceed in "lockstep / parallel", pairing corresponding elements at corresponding indices in the two lists, stopping when either of them runs out
13:28:52 <ski>   all_colors = [Red .. Blue]
13:28:53 <ski> yes
13:28:55 <ski> or perhaps
13:29:02 <Xunie> Solonarv, that seems kinda ugly. Also: Hello again!
13:29:03 <ski>   all_colors = [minBound .. maxBound]
13:29:12 <ski> if you also derive `Bounded'
13:29:29 <ski> (oh, and i meant to say s/all_colors/allColors/)
13:29:39 <ski> ugly, how so ?
13:29:40 <Xunie> It seems bad form to define a set of colors by an order!
13:29:55 <Solonarv> well, lists aren't sets in the first place
13:30:01 <ski> well, you can write `[Red,Green,Blue]' manually, if you like
13:30:12 <Xunie> Is there a way to define a 'Bag' instead? An unordered set of elements akin to a std::set in C++?
13:30:14 <ski> or you could make it into a set, in place of a list, if you prefer
13:30:46 <Solonarv> yeah, we have sets in libraries
13:30:52 <ski> @let data Color = Red | Green | Blue deriving (Eq,Ord,Show,Read,Bounded,Enum,Ix)
13:30:54 <lambdabot>  Defined.
13:30:59 <Solonarv> @let import qualified Data.Set as Set
13:31:02 <lambdabot>  Defined.
13:31:11 <ski> > S.fromList [minBound .. maxBound] :: S.Set Color
13:31:13 <lambdabot>  fromList [Red,Green,Blue]
13:31:25 <ski> (it's already imported as `S' in lambdabot, but ty)
13:31:39 <Xunie> For now, I want to define myself to Prelude or List operations.
13:31:48 <ski> then lists ?
13:31:54 <ski> and lists imply an ordering of elements
13:32:04 <ski> (or build your own sets or bags, i suppose ..)
13:32:18 <Xunie> Good practice but not what I've set my mind to solving tonight.
13:32:30 <Xunie> My next adventure in Haskell. :p
13:32:52 <ski> are you satisfied now, or are there something left that you're wondering about ?
13:33:18 <Xunie> Very satisfied. You fellas certainly are helpful once you know the appropriate lingo.
13:33:39 <Xunie> Thanks, ski. And thanks again, Solonarv! :3
13:33:39 <ski> yea, it will of course take some effort to communicate
13:33:51 <ski> but, if there's any term we're using that you're unsure about, just ask !
13:34:29 <Xunie> Over the years, I've learned to be very pedantic about terminology, which makes communicating in technical concepts a breeze.
13:34:47 <ski> ime, being pedantic about terminology often helps beginners
13:34:54 <Xunie> It VERY much helps beginners!
13:35:10 <Xunie> Correct the from the git-go, ESPECIALLY if they're in groups. It will make future teaching a lot better and helps to correct mental mistakes.
13:35:15 <ski> people who're more familiar with the conceptual landscape can afford to be a bit more sloppy with terms .. among themselves !
13:35:33 * ski nods
13:35:36 <Xunie> It's like "I'm trying to iterate over a std::set but I can't index it, how do I do that?!"
13:36:01 <Xunie> If they didn't know how to say "std::set", they'd definitely have trouble understanding that sets aren't ordered!
13:36:35 <Xunie> ski, what I find interesting is that once you know the correct terminology? Your thinking space seems to scale exponentially with the terms you know!
13:36:54 <Solonarv> huh, is there not a way to walk through an std::set in some arbitrary order? that seems like it would exist
13:36:58 <ski> heh .. *if* the concepts are defined/delineated appropriately
13:37:05 <ski> some would say "orthogonally"
13:37:24 <Xunie> Solonarv, it sure works, but you'd probably have to use some iterator I don't know about, lemme look for ya.
13:38:10 * ski . o O ( "the more you know .. the more you know" )
13:38:21 <Solonarv> cplusplus.com says there is
13:38:30 <Xunie> https://en.cppreference.com/w/cpp/container/set
13:38:35 * ski idly wonders whatever happened to C--
13:38:45 <Xunie> There *is* an iterator defined, but it's a LegacyBidirectionalIterator, and I'm not sure what that is.
13:39:02 <Solonarv> ski: it's still around in the sense that GHC uses it and parts of the GHC RTS are writtenin it
13:39:58 <ski> but i suppose it didn't really caught on much, right ?
13:40:12 <Solonarv> I don't know if it was ever used much outside of GHC, or even at all
13:40:30 <bdesham[m]> I'm not sure it was ever designed to be written by end users
13:40:42 <bdesham[m]> (well, "developer end users")
13:40:52 <Xunie> Are there any subsets of Haskell with very light dependencies?
13:41:04 <Xunie> Like, a minimal implementation of Haskell?
13:41:30 <ski> bdesham[m] : iiuc, the target audience was compiler writers and the like ?
13:41:43 <Solonarv> there are a few other Haskell compilers (besides GHC and GHC-based ones), but AFAIK they aren't used much
13:42:19 <Solonarv> and/or haven't been worked on in quite some time
13:42:35 <bdesham[m]> ski: yeah. wikipedia suggests it was intended to be generated by compilers, not written by humans
13:42:36 <ski> it's a bit of a shame
13:47:47 * hackage tensor-safe 0.1.0.0 - Create valid deep neural network architectures  https://hackage.haskell.org/package/tensor-safe-0.1.0.0 (leopiney)
13:54:09 <Ariakenom_> I looked into C-- as part of my master's. the not ghc specific, don't know how much of the genric there ever was, looked abandoned.
13:56:44 <Solonarv> Ariakenom_: interesting, do you have any links where one could learn more?
14:04:12 <hseg> Hi. Reading quchen's article on tagging types with phantoms instead of introducing synonyms, I was struck by a thought. What if we could tell GHC "Ignore type differences between this newtype N and its ground type T in this term`? This would relieve some of the pressure to use type synonyms.
14:04:37 <Ariakenom_> Solonarv: hm ... lemme look
14:05:08 <hseg> A) Is something like this even implementable in GHC? B) Is it as useful as it looks on first sight?
14:05:19 <Solonarv> hseg: such a mechanism already exists!
14:05:31 <hseg> Solonarv: Oh?
14:05:38 <Solonarv> that's what Data.Coerce.coerce does
14:06:12 <Solonarv> coerce :: Coercible a b => a -> b; the constraint roughly means "same type after throwing away newtype wrappers"
14:06:26 <geekosaur> and is generated internally
14:06:44 <Ariakenom_> Solonarv: https://gitlab.haskell.org/ghc/ghc/wikis/commentary/rts/cmm
14:06:47 <hseg> Sure. But what if you have some complicated term with multiple places you want to coerce at, and you want GHC to just figure out where to place them?
14:06:59 <Ariakenom_> but what were you asking for?
14:07:13 <Solonarv> oh, I see. Hm.
14:07:47 <Solonarv> Pretty sure "insert this function when needed to make things type-check" is within the realm of possibility for a typechecker plugin
14:07:49 <geekosaur> that is probably doable in some sense, but it's got a certain air of "forget that types exist here"
14:07:50 <c_wraith> didn't goldfire just make a ghc plugin that does this?
14:08:18 <Solonarv> yup
14:08:23 <hseg> geekosaur: True, but I want "forget _this_ type difference within _this_ term"
14:08:31 <c_wraith> ... don't use that. :)
14:08:36 <ski> hseg : sounds like the "Restricted type synonyms" extension in Hugs, see <https://www.haskell.org/hugs/pages/users_guide/restricted-synonyms.html> and <https://www.haskell.org/hugs/pages/hugsman/exts.html#sect7.3.5> for more details
14:08:51 <Solonarv> yeah, should be doable as a GHC plugin
14:09:31 <ski> Solonarv,geekosaur ^
14:09:34 <ski> c_wraith ?
14:09:50 <Solonarv> ski: oh, interesting
14:10:02 <hseg> c_wraith: Can't find it
14:10:56 <hseg> ski: That looks nearly exactly like what I want.
14:11:49 <hseg> Now if only it could be more like `let type Stack a = [a] in stacky_term`, we'd be done.
14:13:04 <Solonarv> certainly should be possible to do something sort of like this with a compiler plugin
14:13:13 <ski> (hm, it just struck me that there's a similarity (and a difference) between restricted type synonyms, and the `abstype' abstract type declaration in SML)
14:13:55 <Solonarv> surface syntax might end up looking something like: typePunning @Int @(Sum Int) $ <some expression>
14:14:01 <hseg> Solonarv: K. Maybe as my first compiler plugin? Bit busy atm, but could be a nice motivational exercise for whenever I find the time.
14:14:07 <ski> btw, i don't think i really got why one can't export a type synonym abstractly from a module
14:14:14 <ski> (one can do that in the MLs)
14:14:40 <Solonarv> and in <some expression> the plugin could automatically insert calls to 'coerce @Int @(Sum Int)'
14:15:37 <ski> hm, <http://homepages.inf.ed.ac.uk/stg/NOTES/node79.html> describes `abstype'
14:16:18 <ski> it basically generates an ordinary `datatype', coupled with some declarations over which it is concrete. outside of the that, the new type is abstract
14:16:32 <c_wraith> ski, https://github.com/ghc-proposals/ghc-proposals/pull/217
14:16:33 <hseg> Right. One potential issue I can see is if the term pathologically depends on the type chosen -- e.g. you could have n independent coercion sites, but only one choice of coercions typechecks.
14:17:43 <ski> so, it's equivalent to defining a local module (`structure' in SML lingo), with the `datatype', and the operations to export, and ascribing to that module a `signature' that only exposes the `datatype' abstractly, hiding its implementation (you can't even tell whether it's a `type' synonym or a `datatype', from outside), and exporting the operations .. then opening that local module in-place
14:18:42 <Solonarv> actually, you could do this with backpack too, I think
14:18:42 <hseg> Hm. Right. It seems what I want is the power to open those modules locally as I see fit.
14:19:08 <Solonarv> but it would probably be rather verbose and clunky, and require you to split your code among more files than is natural?
14:19:13 <ski> so, the difference is that a restricted type synonym (a) is implemented as a synonym, not as an algebraic data type; and (b) that only the signatures (needed to specify exactly what should be abstract) are encapsulated by the declaration, while the actual operation definitions are separate
14:20:54 <ski> c_wraith : so, that's distinct from `-fdefer-type-errors' ?
14:22:11 <ski> hseg : in OCaml, you can write `M.<expr>', where `<expr>' is any expression, where the module `M' is locally opened over
14:22:39 <hseg> Nice
14:22:40 <ski> Solonarv : hm, no local modules with Backpack ?
14:24:21 <ski> (i think `abstype' is sortof a relic in SML, that's not considered needed, if you have the module system. but i think i've seen some experimental extension (i think it was MetaML) which didn't implement the full module system, but which (iirc) did implement `abstype' (can't recall whether it did `local
14:24:31 <ski> '-`in'-`end')
14:24:41 * ski misses `local'-`in'-`end' in Haskell
14:25:00 <hseg> What's local-in-end ?
14:25:40 <ski> basically, a `let'-`in', but where what's after `in' is a declaration (or really a sequence of them), not an expression. the whole thing is therefore also a declaration
14:25:46 <ski> so you can say
14:25:50 <ski>   local
14:26:02 <ski>     datatype 'a t = C of ..'a..
14:26:23 <ski>     fun f (C (x,y)) = ..f..g..x..y..
14:26:35 <ski>     and g [     ] = ...
14:26:55 <Xunie> How do I define a 'data Count = 1 | 2 | 3' data type? GHC doesn't like me writing that...
14:26:58 <ski>       | g (t::ts) = ..f..g..t..ts..
14:27:01 <ski>   in
14:27:14 <ski>     ..some other declarations that uses `t',`f',`g'..
14:27:16 <ski>   end
14:27:24 <hseg> Xunie: well, 1,2, and 3 are already taken up as names.
14:27:55 <ski> the problem with `where' (not to speak of ordinary `let'-`in'), from this POV is that it only scopes over a single defining equation (expression)
14:28:02 <ski> and it's tedious to have to say
14:28:17 <ski>   (f,g) = (realF,realG)
14:28:18 <ski>     where
14:28:23 <ski>     realF = ...
14:28:26 <ski>     realG = ...
14:28:35 <ski>     ..other, local, declarations..
14:29:34 <hseg> Yeah, makes sense. How often do you run into that, though? And aren't such cases opportunities for factoring out that family of declarations into its own module?
14:29:37 <ski> (also, i'd like to be able to define local `data' types in Haskell, as well, inside `where' and `let' .. of course there'd need to be some restrictions, since it's not visible outside)
14:30:06 <ski> hseg : well, if modules could take parameters, that might be a workable workaround ..
14:30:31 <__monty__> hseg: Digits aren't valid as the first character in an identifier btw. It has to be a lowercase letter or underscore.
14:30:51 <ski> admittedly, you don't run into this kind of situation *that* often .. but when you do (and you know about this feature in SML), you do miss the ability to just do it like that ..
14:31:00 <hseg> ski: Oh yes. Once questioned why where and let couldn't have local data types with local class instances, which can then only be used in the scope where where and let are valid.
14:31:03 <hseg> __monty__: Point
14:31:32 <hseg> ski: Yeah. It's less a matter of practicality and more a matter of homogeneity+naturality.
14:31:46 <ski> hseg : i think mostly it's because noone has sat down and tried to figure out how it'd work, and then gone and implemented it
14:32:21 <ski> however, i have run into situations where it's annoying to carry a bunch of type variables on my "local/temporary data types"
14:32:27 <ski> where i'd like to be able to say
14:32:31 <hseg> Hm. Which is potentially explained by the fact that workarounds are so readily available and that the issue doesn't come up so often.
14:32:35 <ski>   foo :: forall a. ..a..
14:32:38 <ski>   foo = ...
14:32:39 <ski>     where
14:32:46 <ski>     data T b = ..a..b..
14:33:12 <ski> where `a' *isn't* a direct parameter of `T', but is rather picked "out of the air", just like with ordinary nested scoping
14:33:35 <ski> (and of course that `forall a.' shouldn't be required there .. but that's another pet peeve of mine)
14:35:18 <hseg> Yeah, it's the same motivation as wanting to allow local term definitions instead of explicitly closing over the values you need.
14:36:00 <hseg> It's bloody convenient, and when you reach for it and it isn't there you can't help but curse the devs. Even though they have valid reasons.
14:37:13 <ski> can you elaborate on what you mean by "local term definitions" there ?
14:38:05 <hseg> Those local bindings that _are_ available in H98: f ... where g = ...
14:38:08 <hseg> where g is a term
14:38:37 <hseg> (i.e. not a type, class or type family as we've been talking about)
14:38:49 <ski> Xunie : anyway, you could do `data Count = One | Two | Three', and then `instance Num Count where ...; fromInteger 1 = One; fromInteger 2 = Two; fromInteger 3 = Three'
14:39:16 <spion> is anyone aware on papers on access control "algebra" ? :)
14:39:17 <TBG> @fl (\[a:b:[]) -> (a,b))
14:39:18 <lambdabot> Not enough privileges
14:39:18 <Xunie> ski, thanks, but I've moved on. I'll fix the code later. :p
14:39:22 <TBG> @pl (\[a:b:[]) -> (a,b))
14:39:22 <lambdabot> (line 1, column 3):
14:39:22 <lambdabot> unexpected "["
14:39:22 <lambdabot> expecting pattern
14:39:26 <TBG> @pl (\[a:b:c) -> (a,b))
14:39:26 <lambdabot> (line 1, column 3):
14:39:26 <lambdabot> unexpected "["
14:39:26 <lambdabot> expecting pattern
14:39:30 <TBG> Oh reee
14:39:35 <TBG> @pl (\[a:b:[]]) -> (a,b))
14:39:35 <lambdabot> (line 1, column 3):
14:39:35 <lambdabot> unexpected "["
14:39:35 <lambdabot> expecting pattern
14:39:41 <ski> Xunie : anyway .. so refinement types in Haskell. and no subtyping
14:39:42 <TBG> @pl (\[a:b:_]) -> (a,b))
14:39:42 <lambdabot> (line 1, column 3):
14:39:42 <lambdabot> unexpected "["
14:39:42 <lambdabot> expecting pattern
14:39:50 <TBG> Sorry I speckle
14:39:58 <TBG> @pl (\(a:b:_)) -> (a,b))
14:39:58 <lambdabot> (line 1, column 10):
14:39:58 <lambdabot> unexpected ")"
14:39:58 <lambdabot> expecting operator, pattern or "->"
14:39:59 <geekosaur> TBG, not everything can be done in pointfree form
14:40:10 <TBG> Nah I know but I'm typing it wrong
14:40:12 <geekosaur> well, it can but with a lot of extra work
14:40:26 <TBG> I'm just looking if there's a func
14:40:28 <hseg> And associated loss in clarity.
14:40:38 <ski> TBG : perhaps you could try that out in private, until you have something more or less working, that you want to share with us ?
14:40:43 <Xunie> ski, giving me more stuff to google. I've got plenty on my plate today :3
14:40:49 <ski> TBG : or did you mean to show all these failed attempts to us ?
14:40:51 <spion> i.e. datatype to define a policy result (Allow, Deny, ProvisionalAllow, ProvisionalDeny) and operator(s) to combine results
14:40:58 <TBG> @pl (\(a:b:_) -> (a,b))
14:40:58 <lambdabot> ap ((`ap` tail) . (. head) . (const .) . (,) . head) tail
14:41:08 <TBG> Yeah that one's ugly
14:41:31 <ski> TBG : also note that the pointless parser is incomplete, it doesn't understand all the syntax, e.g. some pattern syntax
14:41:46 <TBG> Yeah I know
14:41:56 <TBG> But you can usually replace some of the pattern syntax
14:42:15 <TBG> And I think it's because some stuff actually can't be converted into pointfree
14:42:29 <TBG> Like you can't pattern match that in point free
14:42:34 <hseg> Question: has anyone written a bit of TH that will write out wiring diagrams into straightline syntax?
14:42:41 <TBG> Because it would be a function which was non-exhaustive 
14:43:04 <hseg> Because some things seem to be expressed more easily in 2d rather than 1d
14:43:58 <spion> this looks interesting https://www.cs.cmu.edu/~wing/publications/PincusWing05.pdf
14:44:36 <TBG> The Void type confuses me so much
14:44:44 <hseg> spion: Interesting, thanks
14:45:02 <TBG> Is it some value to represent some branch that should never happen?
14:45:08 <TBG> Because the implementation requires so?
14:45:26 <spion> hseg, oops - sorry thats not related to your question :|
14:45:50 <TBG> "ex falso quodlibet"
14:45:53 <hseg> spion: Yeah, but it was still interesting
14:46:04 <Solonarv> TBG: yes, pretty much
14:46:38 <Solonarv> it's the "can't happen" type
14:47:13 <Solonarv> for example, if I give you an 'Either Void blah', then you know this has to actually be Right, and can't be Left
14:47:25 <Solonarv> (well, ignoring 'undefined')
14:53:10 <hseg> Solonarv: ski: Thanks
15:00:26 <ski> TBG : if you have a type `Tree a', where `a' is the type of elements at the leaves of the tree (but there may be some other info at internal nodes). then `Tree Void' is a tree with no leaves (there could still be "leaves", really internal nodes with no children)
15:01:37 <ski> TBG : you can compare this with how the type `()' itself might seen not terribly useful .. until you start wanting `IO ()' say. or even `Tree ()' (in this case, imagine that the internal nodes of a `Tree a' are annotated with `a's, and you just want a plain vanilla version, no extra annotations)
15:02:17 <Ariakenom> Solonarv: there is no C-- website, I suppose that is a sign of deadness https://en.wikipedia.org/wiki/C-- (note C-- and cmm distinction)
15:02:57 <TBG> Thx Solonarv
15:03:01 <TBG> gonna go :(
15:03:04 <ski> have fun
15:03:08 <TBG> I should probably get a real irc client soon
15:04:03 <Welkin> cmm was invented solely for ghc
15:05:06 <geekosaur> the original website is archived, yes
15:05:22 <geekosaur> iirc someone else apparently picked it up though
15:20:12 <EvanR> with so many unrelated languages called cmm or c-- i demand to be able to call my latest language C++ or Java with impunity
15:24:56 <jle`> if i ever write a scripting edsl for java i'll call it javascript
15:53:17 * hackage archive-sig 0.1.0.0 - Backpack signature for archive libraries  https://hackage.haskell.org/package/archive-sig-0.1.0.0 (vmchale)
15:54:17 * hackage archive-tar 0.1.0.0 - Common interface using the tar package  https://hackage.haskell.org/package/archive-tar-0.1.0.0 (vmchale)
16:01:26 <AWizzArd> Can I create a big in-process/in-memory cache with Haskell? I worry about pumping, say, 75 gb of data into a process to cache data and still have acceptable GC times.
16:02:22 <Rembane> There's a package for creating a big chunk of data that doesn't get garbage collected, would that help solve your problem?
16:03:11 <AWizzArd> Rembane: I know what you mean, but my data is live data and changes.
16:03:49 <AWizzArd> If I remember correctly compact regions are for read-only data.
16:04:20 <Rembane> Got it. 
16:07:32 <AWizzArd> I thought about creating a huge array and serialize my values and fill them in there myself and do manual memory management. I reckon that a 75gb array steals no time from the gc, because it is not checking its contents.
16:08:14 <Rembane> If it doesn't take too long time, build a prototype, profile it and see how the GC behaves.
16:09:02 <AWizzArd> I’m still hoping that someone has a tip ready for this or will say: „nope, use Redis”
16:13:26 <icyt__> People like me
16:26:29 <sssilver> is it true that Haskell programmers are on average more intelligent, better looking, and healthier than programmers of other languages?
16:26:34 <sssilver> asking for a friend
16:27:06 <rotaerk> duh
16:27:08 <Rembane> Yes, they are also very good at tinkering with averages.
16:27:57 <EvanR> they have to be, because the straightforward sum xs / length xs is broken in haskell
16:37:38 <ski> sssilver : i've seen people say in here that they prefer programming in Haskell, because they're too dumb to use other languages
16:45:37 <bsima> haskell definitely reduces cognitive load locally, but learning monads isn't easy
16:47:36 <MarcelineVQ> learning 'a' Monad is easy though, so a person can start with that and snowball from there :D
16:48:33 <EvanR> oh yeah. Specifically the Maybe monad, which many languages are stealing
16:48:46 <EvanR> but for some reason only that one
16:51:36 <Logio> they then see the list monad and start to hear the piping madness from the dark depths
16:53:28 <Logio> recursions with thousands upon thousands of gibbous branches
17:09:47 * hackage persistent-sqlite 2.10.0 - Backend for the persistent library using sqlite3.  https://hackage.haskell.org/package/persistent-sqlite-2.10.0 (parsonsmatt)
17:47:17 * hackage hnix 0.6.1 - Haskell implementation of the Nix language  https://hackage.haskell.org/package/hnix-0.6.1 (JohnWiegley)
17:49:29 <ski> bsima : "locally" ?
17:50:44 <ski> Logio : well, it's backtracking, like in Prolog (i also think generators in Icon is a bit like that ?)
17:53:48 <bsima> ski: meaning I only have to think about one function at a time (usually)
17:56:04 <ski> oh, so reduces cognitive load to mostly be local, then ?
17:56:12 * ski nods
17:57:24 <Cale> bsima: Yeah, I would recommend not learning "monads", but rather learn various individual things that happen to be monads. By the time you've seen a couple, the more general idea will be obvious.
18:02:52 <bsima> yeah thats the approach i took
18:03:26 <bsima> Cale: sorta wrote about it here https://www.bsima.me/clog/how-i-learned-monads.html
18:31:07 <wolfman154> How long did it take you guys to learn Haskell?
18:31:56 <wolfman154> Or functional programming in general?
18:32:59 <Cale> wolfman154: A couple of months before I felt like I could do useful stuff with it and about a year to be comfortable. That was back around 2001-2002 or so though
18:33:22 <sicklork1n> wolfman154: after writing about 10k lines of code
18:34:21 <monochrom> Probably 1k or below in my case.
18:36:09 * DigitalKiwi 10 years and still a newb
18:36:16 <wolfman154> Cale: wow that’s a long time ago, My first language i was introduced to in 2014 was Java, been learning Haskell on and off for the last 6 months 
18:36:45 <sicklork1n> wolfman154: i think this is a good book for beginners https://www.ccs.neu.edu/home/matthias/BTLS/ (functional programming)
18:36:45 <monochrom> I think most of us do on-and-off so it's very difficult to count.
18:37:18 <monochrom> But "how much code did you write during learning" is much easier to recall.
18:38:10 <monochrom> And with that, also how much reading of tutorials and other people's code.
18:38:17 <Cale> Around 2003 or so, I spent a summer working for a professor at McMaster University on a special purpose programming language for signal processing applications. The implementation was in Haskell. I wrote a brute force pipeline scheduler that was kind of an approximate simulator of the PPC/Altivec architecture that would try to reorder the instructions in a loop such that as many as possible could be scheduled onto different processing 
18:38:17 <Cale> units at the same time.
18:38:26 <Cale> That project really solidified things for me :)
18:38:48 <Cale> (I also wrote a register allocator, and other bits and pieces)
18:40:14 <wolfman154> sicklork1n: thanks, I have that book so I’ll learn it down the road, I’m planning on trying Haskell from first principles first though , hopefully it will help me not struggle so much 
18:40:32 <DigitalKiwi> sicklork1n taking the avoid success at all costs seriously by sending people to scheme, i like it! :P
18:41:02 <sicklork1n> lol
18:42:36 <Cale> Nah, programming in scheme will teach you why we like Haskell ;)
18:43:03 <wolfman154> Has anyone got Haskell from first principles, is it useful, so far the other books I’ve downloaded from the internet are hard to understand 
18:43:27 <Cale> I've heard it goes *really* slowly
18:44:20 <wolfman154> Cale: that sounds good 
18:44:48 <Cale> Have you tried Graham Hutton's Programming in Haskell?
18:44:53 <sicklork1n> http://www.cs.nott.ac.uk/~pszgmh/pih.html Graham's 'Programming in Haskell' was good
18:44:57 <DigitalKiwi> hutton++
18:47:08 <DigitalKiwi> also i thought this https://www.coursera.org/learn/programming-languages was really good (this is part A, there are 2 more parts)
18:48:44 <wolfman154> Cale: cool, I guess I’ll try out Haskell from first principles, I don’t like paying for books, but I guess I’ll fork over the $65 bucks 
18:49:15 <wolfman154> DigitalKiwi: thanks for the link I’ll take a look 
18:49:21 <sicklork1n> wolfman154: Good luck!
18:50:09 <wolfman154> sicklork1n: thanks, I hear learning monads gives people nightmares 
18:50:22 <DigitalKiwi> is really just one course split up. it's heavy on FP and explores the differences between typed fp, dynamic fp, dynamic oops with Standard ML, Racket, and Ruby. I did a bit of the SML exercises in haskell for kicks
18:50:39 <Cale> wolfman154: eh, they have a worse reputation than they deserve
18:50:56 <sicklork1n> one fun thought experiment I like to ask newbs to functional programming is to write a function that implements `+`, then watch their head explode.
18:51:13 <Cale> wolfman154: It's hard to study monads directly -- you just learn a bunch of libraries that happen to define things which happen to be a monad, and then you get it.
18:52:05 <Cale> wolfman154: and then thinking about the abstraction a bit and why it works can be cool at that point, but it's really the examples that you need to have first.
18:52:38 <jusss> w6 :: (Num a)=> a -> (a->a) ->a          w6 x (+1) = (+1) x    which part is wrong?
18:52:58 <wolfman154>  I tried the Haskell wiki book, but then got lost 1/3 through the book 
18:53:53 <wolfman154> Cale: will understanding lambda calculus make learning Haskell easier ?
18:54:56 <DigitalKiwi> i think which books work best for people depends largely on the person and the order they read them...it's entirely subjective
18:56:01 <sssilver> wolfman154: you can't start learning Haskell unless you can do beta reduction with close eyes on a parchment
18:56:40 <sssilver> jgc: hi!
18:56:52 <Solonarv> jusss: the (+1) part is wrong, you can't pattern match on functions
18:56:57 <wolfman154> DigitalKiwi:  I think my problem is my first language I learned was Java (for 3 years), I think my brain is stuck in imperative, declarative is so different 
18:57:08 <Solonarv> (and (+1) isn't a valid variable name either)
18:57:09 <DigitalKiwi> sssilver: is that it? i thought you needed a phd
18:57:43 <sssilver> DigitalKiwi: come to think of it, I don't think any of the Haskell programmers I know have PhDs. They can all do beta reduction though. With closed eyes.
18:57:48 <MarcelineVQ> parchment is textured, so that shouldn't be too hard
18:57:51 <jusss> Solonarv: how I can express like f(x,y) = y(x) ?
18:58:11 <Cale> wolfman154: I don't think it's in any way necessary. It might be a point of interest at some point though.
18:58:27 <jusss> f = function(x,y) {return y(x)}
18:58:40 <Solonarv> jusss: you've almost got it, just pick a normal variable name instead of something silly like (+1)
18:58:40 <Cale> jusss: f x y = y x
18:58:44 <sssilver> wolfman154: in all seriousness though, just start reading Real World Haskell, and see where lambda calculus kicks in
18:59:22 <sssilver> wolfman154: there's a correlation between people who are into lambda calculus and people who are into programming in Haskell, but I'm not convinced there's causation
18:59:53 <Solonarv> I would expect there to be some causation, seeing as Haskell is based on a lambda calculus
19:00:06 <wolfman154> sssilver: well isn’t functional programming based on lambda calculus?
19:00:10 <sssilver> I posit that you can be a very effective Haskell programmer without knowing a thing about Lamba calculus (except those you implicitly pick up in routine Haskell programming)
19:00:25 <sssilver> wolfman154: yeah but to some extent normal programming is also based on lambda calculus
19:00:37 <sssilver> wolfman154: ever made an anonymous function in <your favorite language>?
19:00:50 <sssilver> or really any function
19:00:52 <Solonarv> oh, of course
19:01:10 <wolfman154> sssilver: I thought imperative is based on Turing machine?
19:01:18 <Solonarv> it's just that Haskell lets more of the underlying lambda calculus shine through than many other languages
19:01:49 <sssilver> wolfman154: sorry I'm not sure what we're discussing here at this point. If your question is "do I need to learn lambda calculus to learn Haskell", imo the answer is decisive "NO"
19:01:51 <Solonarv> wolfman154: not usually; that is, the semantics of imperative languages are not usually given in terms of a turing machine
19:01:57 <sssilver> you can learn Haskell as a normal programming language
19:02:15 <sssilver> like C++, Rust, Java, GW-BASIC, COBOL, PHP, Lua, anything really
19:02:21 <Solonarv> contrast Haskell, whose semantics are in fact described by a translation into an (extended) lambda calculus
19:02:32 <wolfman154> sssilver: I was curious 
19:02:36 <monochrom> "beta reduction" is just an obscure nerdy name for something every highschool math student is supposed to do all the time.
19:02:43 <jusss> Solonarv: I can not use function's name in pattern match for function's definition, use a variable to instead of that function's name, right?
19:02:53 <sssilver> it'll help if you have experience with strongly statically typed languages but even that you'll just pick up as you go
19:02:58 <Solonarv> jusss: well, you can use whatever variable name you want
19:03:13 <sssilver> monochrom: nooooo don't tell people this!
19:03:17 <sssilver> monochrom: branding is everything!
19:03:29 <Solonarv> if the name is already bound to something "outside" the local binding will simply shadow the outer one
19:03:30 <jusss> Solonarv: and (+1) can not be a variable?
19:03:42 <Solonarv> correct, (+1) is not a variable
19:03:47 <sssilver> Beta® Reduction™
19:03:48 <Solonarv> that's the only thing you did wrong!
19:03:53 <monochrom> Of course those highschool students who can actually do it have better career options than programming.  Therefore programmers are supposed to completely fail on mere plugging in.
19:04:48 <wolfman154> I’m lucky I discovered irc chat rooms recently, learning on my own without help was painful 
19:05:23 <jusss> Solonarv: what if I want express f x = x+1, what the type would be?
19:05:31 <jusss> w::a->a?
19:05:39 <Solonarv> almost
19:06:00 <Solonarv> let's ask the compiler!
19:06:00 <Solonarv> :t let w x = x + 1 in w
19:06:01 <lambdabot> Num a => a -> a
19:06:13 <monochrom> The "+" and the "1" incur a Num constraint.
19:06:51 <ion> :t let w x = x + (1 :: Integer) in w
19:06:52 <lambdabot> Integer -> Integer
19:07:41 <jusss> Solonarv: so, if it's concret type's instance in the function, and the type must be concret in type signature?
19:07:54 <jusss> in the function's definition
19:09:02 <jusss> w::(Num a)=> a->a      w x= (+1) x
19:09:03 <wolfman154> Sorry this is off topic but i want to add a script to xinitrc, I found xnit package in nixos, so how do I set this up?(when I install xinit does a xinitrc file get created automatically?
19:09:47 <monochrom> sssilver: Jokes aside, "beta reduction" "monoid in the category of endofunctors" etc are closer to pomposity than branding.  My branding is instead "Haskell is a premium language".
19:09:50 <MarcelineVQ> that's a pretty great question for the #nixos channel, iirc they're quite helpfup
19:10:30 <wolfman154> I want to put a script to keep my laptop screen from turning off while i watch videos and stuff like that 
19:11:01 <Solonarv> I remember "monoid in the category of endofunctors" frustrating me when I didn't understand it
19:11:03 <wolfman154> MarcelineVQ: no one responded to my question in nixos 
19:11:20 <Solonarv> now I do understand it, and it frustrates me (just a little) because it's ambiguous!
19:11:56 <MarcelineVQ> Solonarv: how do you feel about lax monoidal functors?
19:12:10 <Solonarv> (it describes Monad, but it also describes Applicative)
19:12:27 <Solonarv> MarcelineVQ: I'm alright with those
19:13:20 <monochrom> In put things in perspective, ##math regulars don't say "complete archimedian ordered field" when simply "the real numbers" is enough.  Not even for jokes.
19:13:21 <wolfman154> Have you guys learned category theory?
19:13:45 <Solonarv> a little bit, mostly because I was curious and like learning abstract mathy things
19:13:46 <MarcelineVQ> wolfman154: Not me, just the jokes
19:14:36 <Cale> wolfman154: I have
19:14:39 <monochrom> I have learned category theory but I learned it for software engineering purposes first not Haskell.  (Look for "Doug Smith" for example.)
19:15:22 <Solonarv> It's fair to say that Haskell got me into category theory, but I'm not very deep into it
19:15:41 <monochrom> (For example, an object is a specification (of a module, say). A morphism is refinement/entailment/subsumption/etc.)
19:15:42 <Solonarv> on a good day I can vaguely remember what an end/coend is (today is not a good day)
19:15:51 <Cale> If you're really interested in a wide range of areas of mathematics and logic, category theory is a great thing to learn.
19:15:55 <DigitalKiwi> wolfman154: sometimes they take a while and you have to ask again later depending on the time/who's on. this is a general thing on irc
19:16:15 <monochrom> (And so pushouts, pullbacks, and limits are more important than natural transformations and adjunctions.)
19:16:22 <Cale> But it's by no means a prerequisite to Haskell.
19:16:29 <monochrom> (And so also no monad.)
19:17:01 <wolfman154> DigitalKiwi: ok 
19:17:21 <monochrom> Enjoy this pushout/pullback diagram! (I forgot which.)  http://vex.net/~trebla/photo/unorganized/IO-String.png
19:17:46 <DigitalKiwi> MarcelineVQ: how do you feel about frilly toothpicks? I'm for 'em!
19:18:52 <MarcelineVQ> DigitalKiwi: I'm for them in the sense that they're degenerate trees.
19:19:29 <monochrom> Also I will tell you about pumpkin catmorhpism every Halloween. :)
19:19:34 <MarcelineVQ> relatedly category theory is good to know roughly for the reason that lists are degenerate trees are degenerate graphs are degenerate categories, and I wish I could find the thing I read that showed this
19:19:51 <MarcelineVQ> And probably used more rigorous wording.
19:20:46 <monochrom> The list-tree-graph segment is in pretty much most graph textbooks. Some category theory textbooks have the graph-category segment.
19:21:11 <MarcelineVQ> it was either a blog or an arxiv paper in this case, pretty sure the former
19:21:15 <ski> wolfman154 : "I think my problem is my first language I learned was Java (for 3 years), I think my brain is stuck in imperative, declarative is so different" -- well, i started with BASIC, then assembler (6502) ..
19:21:21 <ski> @quote mentally.mutilated
19:21:21 <lambdabot> Dijkstra says: It is practically impossible to teach good programming to students that have had a prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of
19:21:21 <lambdabot> regeneration.
19:21:23 <monochrom> These are pretty standard/folklore theorems so a lot of textbooks will have proofs or at least "Proof: Trivial".
19:21:33 <ski> (also, s/irc rooms/irc channels/ :)
19:21:58 <monochrom> I also started with BASIC.
19:22:13 <MarcelineVQ> me too :>
19:22:18 <monochrom> The important thing is not what you started from, but what attitude you hold.
19:22:41 <sicklork1n> 10 LET U = 0
19:23:06 <sicklork1n> 99 END
19:23:30 <monochrom> My attitude was "GOSUB is nice but how do I pass parameters or recursion?" and so when I met Pascal afterwards it was rejoice not resentment.
19:23:41 <Solonarv> hey, I too started with (a descendant of) BASIC - it had functions already
19:24:19 <monochrom> In contrast, my classmates' attitude was "what is going on with parameter passing and recursion I'm lost".
19:24:39 <sicklork1n> monochrom: i too went from BASIC to Pascal - i guess u were born in the late 70s/ early 80s
19:24:40 <ski> monochrom : judging from the right angle alone, that would seem to be a pushout ?
19:24:58 <monochrom> So in more general wording, the important thing is whether you have a critical attitude or a gullible attitude.
19:27:37 * ski . o O ( "The Boom Hierarchy" by Adrian Colyer in 2014-11-06 at <https://blog.acolyer.org/2014/11/06/the-boom-hierarchy/> ; "The Boom Hierarchy" by Alexander Bunkenburg in 1993 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.49.3252> )
19:27:53 <nshepperd> i started with http://www.yabasic.de/ which amazingly is still getting updates and now supports colored graphics?
19:28:26 <ski> MarcelineVQ : i don't think that mentions categories, so that's probably not what you were thinking of ..
19:28:59 <Solonarv> more precisely I started with BlitzBasic
19:29:53 * ski thinks they have a gullible attitude .. :/
19:30:24 <monochrom> Hey supporting coloured graphics is already ahead of Haskell!
19:30:45 <monochrom> At this point Haskell barely supports ASCII graphics!
19:30:55 <MarcelineVQ> ski: What has gulled you?
19:31:00 * ski . o O ( are you saying Haskell is not supportive of people of colour ? )
19:31:24 <ski> MarcelineVQ : not sure. i tend to prefer magpies (and jackdews), truth told
19:31:51 <MarcelineVQ> All birds are vermin, some of them are just dressed nicely.
19:31:55 <DigitalKiwi> someone tell ocharles haskell doesn't have graphics
19:32:06 <DigitalKiwi> or maybe he found out and that's why he stopped streaming :(
19:32:16 * ski idly recalls O'Haskell
19:32:18 <Solonarv> eh, SDL2 works pretty well for simple 2D graphics
19:32:30 <Solonarv> and we do have OpenGL bindings, they're just a pain to work with
19:32:37 <Solonarv> (which I hear is not unusual for OpenGL)
19:32:42 <DigitalKiwi> https://github.com/ocharles/zero-to-quake-3
19:34:38 <monochrom> Maybe ocharles stopped streaming because the project was finished.
19:35:07 <monochrom> I certainly stopped writing my PhD thesis!
19:36:37 <DigitalKiwi> hopefully your phd thesis was more finished than zero-to-quake-3 it was just starting to get good! :(
19:36:46 <monochrom> Oh hehe
19:37:24 <monochrom> Actually the trick of finishing a PhD is precisely to finish just when it starts to get good.
19:37:43 <ski> speaking of birds, the ones on the front cover of this Haskell book "Haskell Primer: The first functional language to learn" (in japanese) by Jun Mukai in 2006-03 at <https://www.amazon.co.jp/gp/product/4839919623> look lean and mean :)
19:38:32 * ski idly wonders whether it's any good
19:52:45 <iqubic> I HATE OOP.
19:52:47 * hackage yam-datasource 0.6.0 - Yam DataSource Middleware  https://hackage.haskell.org/package/yam-datasource-0.6.0 (leptonyu)
19:53:15 <iqubic> I'm doing some unity game development and am starting to hate C# with a firery passion.
19:53:38 <monochrom> It is healthier to quit.
19:53:47 * hackage yam-redis 0.6.0, yam 0.6.0 (leptonyu): https://qbin.io/jews-genres-4d8c
19:54:23 <monochrom> Either that, or demand a higher pay.
19:55:46 <iqubic> Hobby projects don't give me any pay.
20:03:59 <DigitalKiwi> hobby projects don't demand you use unity :D
20:06:18 <Solonarv> yeah, use Haskell! I'm sure you won't despair at the graphics, you're better than me!
20:06:33 <iqubic> No, but how else will I do game development?
20:06:54 <iqubic> I can't write Unity Scripts in Haskell.
20:07:06 <monochrom> Ah you are still after high pay, just that it's in the future. Interest theory covers that.
20:07:23 <iqubic> monochrom: What are you talking about?
20:07:25 <Solonarv> no, but who says you have to write unity scripts? (and what do those do? I've never  actually used unity)
20:07:38 <monochrom> The same way medical students bite through 10 years of miserable med school and residency.
20:08:18 <monochrom> I am talking about economics and why you give yourself pain for seemingly no profit.
20:09:07 <iqubic> Solonarv: Unity Scripts are the bread and butter of Unity. If you want to add any sort of logic you game, then you need C# code.
20:09:45 * ski thought Unity was something in Ubuntu
20:10:02 <iqubic> Or you can use Javascript, but support for that in Unity is basically deprecated at this point
20:10:06 <Solonarv> ski: that too
20:10:18 <iqubic> ski: That too is deprecated at this point.
20:10:21 <Solonarv> ah, but why would you need to write unity scripts if you're not using unity?
20:11:58 <iqubic> But I am using Unity.
20:12:18 <iqubic> I'm stating that the Ubuntu Unity DE is dead.
20:12:34 <iqubic> I'm using the Unity Game engine, not the Unity DE.
20:12:37 <ski> okay, i'm sad^Wrelieved to hear ?
20:12:42 <Solonarv> yeah, I know
20:12:56 <Solonarv> my question is: why do you have to use the unity game engine?
20:13:09 <iqubic> Solonarv: Because I want to do game development.
20:13:25 <Solonarv> unity is far from the only way to make games!
20:13:58 <iqubic> how would you chose to make games?
20:14:17 <monochrom> I begin to wonder if at the bottom you'll hit "I need something to hate".
20:14:28 <iqubic> I might.
20:14:38 <Solonarv> I just write them like any old program, using plain old libraries
20:14:46 <iqubic> But right now, I want a better way to make games than what I'm doing now.
20:14:48 <Solonarv> no need for some big all-in-one IDE thingamabob
20:15:07 <monochrom> Then again IIRC all game engines force some OO on you.
20:15:28 <Solonarv> eh, depends on your definition of OO
20:15:58 <monochrom> Yeah, but in 99% of the cases it's going to be a choice between C++ and C#.
20:16:10 <Solonarv> bah, if it's a hobby project you can use whatever
20:16:41 <monochrom> But this one is a career-hunting project euphemized as "hobby", Solonarv.
20:16:50 <Solonarv> ah, fair
20:17:35 <iqubic> I'm still in Highschool, I haven't started looking for jobs yet.
20:17:42 <monochrom> The same way I thought all my tutorials were my hobby project until one day when I applied for a teaching job I suddenly realized this is my portfoilio and free sample.
20:17:58 <DigitalKiwi> you can also make games with things like love and godot in other languages
20:18:02 <Solonarv> but are you making games because you expect them to one day help you land a job, or because you want to make games?
20:18:07 <DigitalKiwi> or make your own
20:18:24 <Solonarv> if the latter, don't concern yourself with what the industry demands, just use whatever you want
20:18:24 <monochrom> At that moment I finally grew up.  It is no longer "free speech, free beer".  It is "free market, free samples".
20:19:24 <Solonarv> and anyway, actually finished games will look a lot more impressive than games you gave up on because you couldn't stomach unity/unreal/whatever
20:19:38 <Solonarv> finishing projects is a skill too!
20:19:56 <Solonarv> (one which I don't seem to possess, but that's hardly relevant)
20:21:22 <Solonarv> iqubic: to answer the qestion from a few minutes ago, currently I'm trying to wrap my head around FRP (specifically, reflex) and want to use that + its SDL backend to make games
20:22:20 <Solonarv> (in Haskell, in case that wasn't clear)
20:24:42 <Solonarv> aww
20:31:17 * hackage fits-parse 0.0.1 - Parse FITS files  https://hackage.haskell.org/package/fits-parse-0.0.1 (krakrjak)
21:21:29 <c50a326> monochrom: read "I'm a sell-out, a prostitute"
21:25:00 <DigitalKiwi> c50a326: https://www.youtube.com/watch?v=8qtIdhpw6hc or listen to the audio book
21:28:17 * hackage pandoc-citeproc 0.16.2 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.16.2 (JohnMacFarlane)
21:29:43 <lity> Hey guys
21:29:52 <lity> What does @ do in haskell?
21:31:36 <nes> @lity IDK about ur context but it could be a type application
21:31:37 <lambdabot> Maybe you meant: list let elite
21:32:13 <nes> https://gitlab.haskell.org/ghc/ghc/wikis/type-application
21:34:56 <hololeap> what is going on here? https://github.com/mstksg/inCode/blob/master/code-samples/singletons/Door.hs#L61-L65
21:35:12 <hololeap> what does (SingDSI s => r) mean?
21:36:19 <DigitalKiwi> https://www.haskell.org/tutorial/patterns.html @ in as-patterns ?
21:36:26 <orzo> I'm struggling with a computer graphics problem and maybe my assumptions are wrong.  I have some code that rotates an object in world coordinates before applying a model-view camera transform.  I want to adjust it to move the camera instead of the object.  My assumption is that the resulting matrix will be the same.  My camera matrix is built using a lookat function (lookat pos target up) taking
21:36:32 <orzo> the camera position, coordinate we're looking at, and upward orientation for the camera
21:38:00 <orzo> In my case, target is the origin.  I figured I could apply the inverse rotation to the /pos/ and /up/ vectors given to the lookat function instead of multiplying the matrix on the right of the result.
21:38:29 <orzo> but i can't seem to get the resulting matrix to be equal.
21:38:57 <ski> lity : as a pattern, `<var>@<pat>' binds the variable `<var>' to the value being matched, and also matches it with the pattern `<pat>' (which may bind further variables)
21:39:33 <ski> lity : so it's used to name the whole thing, but also match on, and (commonly) name parts of the whole thing
21:40:08 <ski> lity : there's also a different use of `@' in a language extension, `TypeApplications'
21:48:31 <DigitalKiwi> it can also trigger the haskell bot as you may have noticed
21:55:25 <Cale> orzo: It's too unclear what lookat does -- there's a degree of freedom in terms of what roll it'll get you
21:56:07 <Cale> orzo: That's probably the problem, but I couldn't tell you exactly without knowing how it works
21:57:25 <orzo> i don't see the freedom.  Asside from it's position and the point you're looking at, you supply an "up" direction, which resolves it fully so far as I can tell
21:57:47 <Cale> Oh, I see
21:58:32 <orzo> i'll put a paste together if you want to help me
21:58:59 <Cale> So what are the two expressions you're expecting to be equal?
22:05:24 <orzo> Cale: https://gist.github.com/joecrayne/caf04e4757c2b0bac54b201806e6ee02
22:11:48 <orzo> Cale, basically I'm trying to forumlate rotateLookAt in order to do just the right things to the arguments of lookat to make it come out the same as lookAtRotate
22:13:49 <Cale> orzo: d points from the target to the pos, is that intentional?
22:14:18 <orzo> yeah, but the target is 0 so d is just pos
22:16:11 <orzo> i've been screwing around with that rotateLookAt function, i pasted another version in comment on the gist
22:19:35 <orzo> You agree that I ought to be able to modify the arguments to lookat en lieu of multiplying a rotation, right?
22:36:29 <hololeap> what does this syntax mean? (SingDSI s => r)
22:36:43 <hololeap> in a type signature
22:38:17 <ski> that's a context with a type class constraint ?
22:38:26 <ski> what's the whole signature ?
22:38:27 <orzo> It means that the type s requires an instance of the class SingDSI
22:39:12 <hololeap> https://github.com/mstksg/inCode/blob/master/code-samples/singletons/Door.hs#L61-L65
22:39:18 <ski> s/requires/is required to be/, i'd say
22:39:19 <MarcelineVQ> typically the Door example is a demonstration of type-safe/type-enforced state transitions. Sing(letons) are a somewhat hacky way to have limited dependent-types in haskell
22:39:27 <hololeap> withSingDSI :: SingDS s -> (SingDSI s => r) -> r
22:39:47 <MarcelineVQ> By typically I mean you can find it present in multiple languages
22:39:50 <ski> ok, so
22:39:53 <ski> yes
22:40:09 <ski> that's the CPS encoding of
22:40:42 <ski>   unSingDSI :: SingDS s -> (SingDSI s *> ())
22:41:05 <ski> unpacking a value of type `SingDS s' into evidence for the constraint `SingDSI s'
22:41:36 <ski> because it's CPS, you pass a continuation, of type `SingDSI s => r', and you get back something of the same "final answer/result type" `r'
22:41:55 <ski> so, within that continuation, you're free to make use of having evidence for that constraint
22:42:11 <ski> hololeap : making any sense ?
22:42:40 <hololeap> what is the type `SingDSI s => r'? it doesn't make sense to me why the type variable would change
22:43:35 <ski> a value of type `cxt => ...' is a value such that, *if* you provide evidence for the context `cxt', then you can use the value as if it had type `...'
22:44:39 <ski> a value of type `cxt *> ...' is a value that *provides* to you both evidence for the context `cxt', and you can use the value as if it had type `...'
22:45:02 <ski> so, it's a bit like `t -> ...' vs. `(t,...)', for some type `t'
22:45:19 <ski> in the former case, you have to provide a value of type `t', before getting back a value of type `...'
22:45:34 <ski> in the latter case, you get provided with a value of type `t', as well as a value of type `...'
22:45:55 <ski> but in the constraint case, it's not values of type `t', but (implicit) evidence for the constraint `cxt'
22:46:29 <hololeap> is *> from Control.Applicative?
22:46:31 <orzo> Is the withSingDSI signature equivalent to this?   withSingDSI :: SingDS s -> (forall t. SingDSI t => r) -> r
22:47:12 <hololeap> and what determines which type `r` is? 
22:47:22 <ski> no `*>' is pseudo-Haskell i use to talk about issue like this, more comfortably
22:47:31 <ski> orzo : nope
22:48:57 * ski is unfortunately talking a bit with someone else atm ..
22:49:07 <ski> .. but if you can wait a bit, i can follow-up with more info, if you'd like
22:50:09 <ski> hololeap : the caller of `withSingDSI' does
22:50:17 <ski> they can pick any type `r' they like
22:50:33 <hololeap> so is r like `undefined` then?
22:51:03 <hololeap> as long as s is a SingDSI, r can be any type? it must be undefined then?
22:51:47 <ski> nope
22:51:51 <ski> @type id
22:51:53 <lambdabot> a -> a
22:51:56 <orzo> r is determined by the return type context
22:52:04 <ski> `a' here is not "like `undefined'"
22:52:44 <ski> the caller determines which `r' to pick, and passes a continuation that will eventually deliver a value of the type `r' (that they picked). and then `withSingDIS' will eventually return back that same value of type `r'
22:53:44 <hololeap> ok, then what is the difference between `withSingDSI :: SingDS s -> (SingDSI s => r) -> r` and `withSingDSI :: SingDSI s => SingDS s -> r -> r`
22:55:04 <ski> .. those are completely different
22:55:38 <ski> the latter expects the *caller* to provide it with evidence for the constraint `SingDSI s'
22:56:07 <ski> the former will *itself* (the *callee*) provide the caller (inside the callback) with evidence for `SingDSI s'
23:01:10 <hololeap> the evidence is just the compiler knowing that s has a SingDSI instance, right? so this context is dependent on what s is. doesn't the caller determine what type is is, depending on which (SingDS s) is given?
23:01:28 <hololeap> s/is is/s is
23:04:27 <hololeap> sorry, but this is going right over my head. maybe if i had an example of what you meant by the the *caller* vs the *callee* providing evidence of `SingDSI s`
23:08:16 <hololeap> does r have to be isomorphic to ()?
23:15:50 <ski> "doesn't the caller determine what type is is, depending on which (SingDS s) is given?"
23:15:53 <ski> hmm
23:15:55 <ski> yes and no
23:16:10 <ski> not "depending on which (SingDS s) is given"
23:16:14 <ski> the caller decides
23:16:35 <ski> but the caller might now know itself the concrete type that `s' actually is, because perhaps the caller's caller will decide that
23:16:38 <ski> and so on
23:17:04 <ski> so, the caller might now have evidence for `SingDSI s' around
23:17:52 <ski> however, the point of the type `SingDS s' is exactly that a value of this type encodes evidence for `SingDSI s'. iow `SingDS s' is isomorphic to what i'd write as `SingDSI s *> ()'
