00:42:17 <bahamas> is anyone familiar with dhall-to-nix? how could you use dhall exactly? could dhall replace nix files in the project?
00:43:29 <Rembane> bahamas: Write your configuration in dhall, run the tool, get nix-files, use them as usual. 
00:45:21 <bahamas> Rembane: so I guess I could create a wrapper that runs the dhall-to-nix converter and then the nix-specific command
00:46:22 <Rembane> bahamas: Yes. 
00:58:21 <__monty__> OR, use pkgs.dhallToNix in a slim nix file to not even have to go through that annoying process at all.
00:59:43 <__monty__> Closest thing to an example I could find: https://github.com/dhall-lang/dhall-nix/issues/2
01:16:47 * hackage data-compat 0.1.0.0 - Define Backwards Compatibility Schemes for Arbitrary Data  https://hackage.haskell.org/package/data-compat-0.1.0.0 (TravisWhitaker)
01:38:35 <dminuoso> Given this dispatcher loop for a network service https://gist.github.com/dminuoso/5cb87e40c5c3f4c7a23ce4472f7b46b2 - how could I safely call sdNotify every few minutes in such a way to guarantee the dispatcher loop is not stuck?
01:55:17 * hackage optparse-simple 0.1.1.2 - Simple interface to optparse-applicative  https://hackage.haskell.org/package/optparse-simple-0.1.1.2 (MichaelSnoyman)
02:03:47 * hackage rdf 0.1.0.3 - Representation and Incremental Processing of RDF Data  https://hackage.haskell.org/package/rdf-0.1.0.3 (TravisWhitaker)
02:04:40 <jmorris> why can i not use AddRq from Level02.Types here on line 72? https://github.com/joshua-morris/applied-fp-course/blob/master/src/Level02/Core.hs
02:08:47 * hackage salak-yaml 0.2.9.3 - Configuration Loader for yaml  https://hackage.haskell.org/package/salak-yaml-0.2.9.3 (leptonyu)
02:09:47 * hackage salak-toml 0.2.9.3 - Configuration Loader for toml  https://hackage.haskell.org/package/salak-toml-0.2.9.3 (leptonyu)
02:10:56 * hackage salak 0.2.9.3 - Configuration Loader  https://hackage.haskell.org/package/salak-0.2.9.3 (leptonyu)
02:15:54 <dminuoso> Oh I guess I could use select and set up a timer...
02:16:08 <dminuoso> Instead of doing a blocking call to recvFrom :)
02:21:17 * hackage hasbolt 0.1.3.3 - Haskell driver for Neo4j 3+ (BOLT protocol)  https://hackage.haskell.org/package/hasbolt-0.1.3.3 (zmactep)
02:33:40 <Darwin226> Anyone remember that library that provided a Map structure with a typesafe lookup? IIRC it used the ST trick to have keys tagged with the map they came from to guarantee safe lookups
02:34:42 <phadej> @package justified-containers
02:34:43 <lambdabot> http://hackage.haskell.org/package/justified-containers
02:35:09 <Darwin226> awesome thanks
02:38:00 <alfio> ciao
02:38:12 <alfio> !list
02:38:13 <monochrom> alfio: http://okmij.org/ftp
02:42:56 <lavalike> haha
02:43:49 <dminuoso> Mmmm, so it appears that network wont let me do nonblocking IO. :<
02:44:07 <dminuoso> Why is there not even epoll available
02:44:25 <dminuoso> Or select
02:45:25 <cocreature> dminuoso: huh, are you sure that you actually need to do that manually? Usually you pretend to do blocking IO and GHC’s IO manager will use non-blocking IO internally
02:46:33 <dminuoso> cocreature: Yes. I want my network dispatcher loop to send sd_notify events. For that to make sense, I need to use recvFrom in a non-blocking fashion.
02:51:24 <dminuoso> Otherwise if no network request came in for a long time, then I'd be blocked on recvFrom without the ability to send watchdog notifications.
02:53:47 <cocreature> dminuoso: can’t you just have a separate thread for sending watchdog notifications?
02:55:03 <dminuoso> cocreature: What if my dispatcher loop is stuck somehow?
02:55:55 <dminuoso> I mean there's an alternative technique: I could add a watchdog service that sends specialized request, and I add a handler that sends sd_notify whenever that request is received.
02:56:33 <dminuoso> But this is for systemd watchdog restarting, so I dont like my process relying on other processes
02:58:48 <phadej> why you don't use separate thread for each network connection and separate thread for sending notifications
02:59:07 <phadej> I'm with cocreature with that; I'm not convinced you want to do whatever you are doing manually
03:02:24 <phadej> and dispatcher "loop" could simply block on `accept` and fork new threads to deal with new connections
03:02:45 <Bish> why is haskell so facist about tab/space usage?
03:03:24 <dminuoso> Bish: Because whitespace is relevant. If you cant visually determine the structure of code, it makes maintaining/reading that much harder.
03:03:52 <dminuoso> Bish: Most tab vs space discussions are rather meaningless anyway.
03:03:54 <Bish> well is it relevant somewhere else than reading?
03:04:07 <Bish> dminuoso: yes they are, but they aren't if your compiler puts out messages if you don't act like it
03:06:19 <dminuoso> Bish: The list of people who have been bitten by files with mixed tabs and spaces is so unbelievably long..
03:06:28 <__monty__> The compiler needs to read the code too.
03:06:29 <dminuoso> Bish: But if you prefer you can turn off the warning
03:06:38 <dminuoso> Bish: -fno-warn-tabs if you insist.
03:07:13 <Bish> __monty__: ... and it cares if it reads 2 bytes or 1 for the same thing?
03:07:25 <dminuoso> Bish: It cares about the amount of whitespace.
03:07:33 <Bish> dminuoso: how so?
03:07:41 <__monty__> Bish: Same thing? I think you are misunderstanding '\t'.
03:07:47 * hackage serverless-haskell 0.8.7 - Deploying Haskell code onto AWS Lambda using Serverless  https://hackage.haskell.org/package/serverless-haskell-0.8.7 (AlexeyKotlyarov)
03:08:13 <dminuoso> Bish: Consider nested do-notation.
03:08:26 <__monty__> Bish: The width of a tab is variable. There is no one tab == x spaces relation.
03:08:30 <dminuoso> Bish: consider nested where blocks
03:08:57 <Bish> okay, so it actually matters then? but if everyone agreed tab == 2 spaces there wouldn't be an issue, would there?
03:09:27 <dminuoso> Bish: Sure.
03:09:39 <Bish> dont get me wrong, i use spaces aswell (actually i always liked tabs, but people where like nyeeeh), but every now and then i just want to test a thing with unconfigured vim
03:09:41 <DigitalKiwi> nah, tabs are 3 spaces, fight me
03:09:42 <tdammers> everyone does not agree though
03:09:56 <Bish> since my editor does 2 spaces on tab.. and then ghc annoys me
03:10:11 <dminuoso> Bish: The biggest problem arises from code where ambiguity changes *meaning* and not lead to incorrect code
03:10:13 <tdammers> clearly tabs should be 37 spaces each, to discourage deep nesting
03:10:14 <dminuoso> Let me prepare an example:
03:10:32 <Bish> no i get it, but imho you shouldn't force people
03:10:45 <Bish> also.. code should be format free, have there been discussions about that when creating haskell?
03:10:45 <dminuoso> Bish: We do not force people.
03:10:50 <dminuoso> Bish: We just *warn* them if you mix it.,
03:10:56 <dminuoso> Bish: You can turn off the warning if you like.
03:11:02 <yushyin> It is just a good default 
03:11:04 <Bish> dminuoso: well, it also warns if you don't mix :D
03:11:14 <phadej> Bish: you can write do { a <- action1; b <- action2; } if you like
03:11:18 <dminuoso> Bish: Oh well. Yes.
03:11:30 <dminuoso> Bish: Its a warning either way.
03:11:39 <dminuoso> Bish: You can turn it off if you insist.
03:12:00 <Bish> why wasn't haskell designed to be format free like alltheotherslanguages.jpg
03:12:04 <dminuoso> Bish: Some of the problems you will experience is that tabs are not enough for proper alignment, you'd start adding spaces anyway.
03:12:06 <tdammers> as much as I think tabs are a good idea in general, I never use them in languages where indentation matters (Python, Haskell)
03:12:29 <DigitalKiwi> use all the other languages then
03:12:29 <tdammers> and I also don't use them when working with people who don't fully understand the difference between alignment and indentation
03:12:33 <Bish> dminuoso: i never cared, because my editors never cared, except vim without configuration
03:12:38 <__monty__> Bish: You don't have to use haskell's layout rules. You can just manually specify all the blocks like do {...; ...}
03:12:41 <Bish> i just set my editors to tab = 2 spaces and everyones happy
03:12:50 <dminuoso> Bish: The haskell layout rules exist to write less noisy code.
03:12:52 <yushyin> There are many languages with this off-side rule
03:12:55 <tdammers> Bish: how can those editors do it correctly then?
03:13:09 <dminuoso> Bish: Humans happen to be quite good at visually recognizing structure, but much worse at reading actual symbols and decoding the,/.
03:13:16 <dminuoso> decoding *them
03:13:22 <tdammers> Bish: you *have* to tell the editor whether to insert tabs or spaces when you press <Tab>, one way or another
03:13:26 <Bish> eww us keyboard layout
03:13:40 <dminuoso> Bish: The thing is, with spaces you get guaranteed good behavior and reproducability.
03:13:48 <dminuoso> With tabs you rely on people configuring their editors.
03:14:00 <tdammers> dminuoso: not really, not if you use them correctly
03:14:06 <tdammers> dminuoso: indent with tabs, align with spaces
03:14:09 <Bish> yeah i know the discussion, i had it several times, just think it's weird if you force people to
03:14:12 <dminuoso> tdammers: Thats my point! *IF* you use them correctly.
03:14:15 <Bish> yeah you can deactivate that.. you don't get forced
03:14:31 <dminuoso> tdammers: You rely on even more than just configured editors. You rely on configuration *and* people conforming to some convention
03:14:51 <tdammers> dminuoso: yes, but that's not so much a matter of configuring editors; even if you configure the editor correctly, you can still insert tabs where spaces would belong
03:15:03 <Athas> Bish: you can (almost) write free-format Haskell if you want.  Just insert your own semicolons and braces!
03:15:14 <dminuoso> Some people (eyeballs SPJ) even like doing both.
03:15:26 <dminuoso> Formatted code with plenty of braces and semicolons. :P
03:15:30 <phadej> btw, discussing the core syntax element of 30 years old language is a bit silly :)
03:15:31 <Athas> It's just that the community has overwhelmingly (but not unanimously) decided to write Haskell in an indentation-sensitive way.
03:15:53 <phadej> this discussion is ~as bashing lisps for using too many parentheses;
03:15:58 <Athas> I think some of the GHC committers still like semicolons.  At least you can find a lot of them in the GHC source code.
03:16:03 <phadej> if you don't like, don't use ;)
03:16:07 <dminuoso> Athas: Who other than SPJ does?
03:16:08 <tdammers> hehe, yeah, GHC itself deviates from the "accepted community standard" quite a lot
03:16:15 <Athas> dminuoso: it may only be him.
03:16:19 <dminuoso> :-)
03:16:29 <tdammers> I think quite a few people do, but not visibly so
03:16:47 <dminuoso> tdammers: GHC is probably the simplest Haskell codebase out there from a haskell-wizardy point of view.
03:17:12 <tdammers> dminuoso: yes, it's so simple sometimes that it's *more* difficult to understand what's going on
03:17:19 <tdammers> dminuoso: all sorts of abstractions manually typed out
03:17:53 <__monty__> Best part is the semicolons are often leading rather than trailing : )
03:18:12 <dminuoso> __monty__: It actually makes it very symmetric and pleasant to read.
03:18:22 <tdammers> __monty__: leading separators is a very common thing, though you don't see it a lot with do blocks
03:18:40 <dminuoso> Ive tried leading semicolons on do blocks myself for a while and I enjoy it quite a bit.
03:18:48 <tdammers> .oO( makeLenses ''DynFlags )
03:18:50 <__monty__> tdammers: In haskell maybe. Other languages not so much afaik?
03:18:57 <tdammers> __monty__: ah yes, of course.
03:19:07 <Athas> dminuoso: GHC does have a few nasty things like global state and an odd string/symbol abstraction.
03:19:23 <Athas> But GHC is more unsafe/low-level nasty than type trickery nasty.
03:19:32 <__monty__> Calling anything haskell "common" without qualification, maybe we're down the rabbit hole too far : >
03:19:47 <dminuoso> Athas: And most of the complexity is hidden in the problem domain of compiler/type theory/GHC design, rather than the written code.
03:20:45 <tdammers> __monty__: why? there is enough haskell code out there to talk about "common" patterns between it
03:21:21 <dminuoso> __monty__: #haskell is still the third (?) most visisted channel on freenode, and yet Haskell can rarely be found on even "known programming languages", let alone "most popular programming languages".
03:21:22 <__monty__> If you qualify it with "in haskell," yes.
03:21:49 <dminuoso> It's a curious thing indeed to be using the word "common"
03:23:18 <Athas> There are some things that look really wizardry in GHC.  For example, the documentation for inlinePerformIO says "Very unsafe. In particular, you should do no memory allocation inside an inlinePerformIO block".  Yet, in GHC, inlinePerformIO is used to allocate FastStrings.
03:23:40 <Athas> My wizard beard is not long enough, and my pointy hat not pointy enough, to do something like that.
03:24:01 <__monty__> Athas: I see you're on the fence about double-spacing your sentences? : >
03:24:13 <dminuoso> Athas: Is inlinePerformIO the GHC equivalent of accursedUnutterablePerformIO?
03:24:18 <Athas> __monty__: no, I copied that verbatim from the docs.
03:24:30 <__monty__> Ah.
03:24:44 <dminuoso> Ah it looks like it.
03:24:49 <Athas> dminuoso: actually, no, I may be mistaken.  inlinePerformIO is normally from Data.Text, but maybe GHC has its own with subtly different properties.
03:25:01 <dminuoso> mmm
03:25:43 <Athas> No, I think it's the same, just not documented in its GHC incarnation.
03:26:07 <dminuoso> Athas: pretty sure its actually not unsafePerformIO from GHC. From the looks of it its actually accursedUnutterablePerformIO
03:26:11 <Athas> GHC also has this charming design of not using hierarchical modules, so it's always exciting when you have to find things.
03:26:51 <Athas> GHC's FastFunctions.inlinePerformIO looks identical to Data.Text.Internal.Unsafe.inlinePerformIO.
03:26:56 <Bish> Athas: well, write it ugly as fuck doesn't sound as a viable option there
03:27:21 <Bish> dminuoso: who likes pressing space a thousand times
03:27:24 <dminuoso> Athas: GHC is also very "carefully" designed around cylic dependencies because boot modules.. well.. I sometimes have the feeling they dont work right.
03:27:46 <Athas> Boot modules are a mess.  Haskell should not support circular dependencies at all IMO.
03:27:50 <dminuoso> Bish: My editor does the right thing when I press the <Tab> key or <Enter>
03:28:10 <Bish> well, you said people either configure their editors or respect a convention
03:28:21 <Bish> if i am in a unconfigured vim tab does tabs :/
03:28:31 <dminuoso> Bish: What do you want me to tell you?
03:28:34 <MasseR> And then there are some people who indent with 3 spaces :<
03:28:45 <Bish> MasseR: maniacs
03:29:09 <MasseR> But luckily we now have a *mix* of 2-space and 3-space 
03:29:16 <dminuoso> Bish: Dont press the <tab> key then, or configure your editor for convenience with tab expansion or better yet a language plugin so it heuristically determines the needed indention when you press enter.
03:29:27 <dminuoso> But that's not really about convention, that's just convenience.
03:29:31 <Bish> yeah i want a way without doing anything but writing :o
03:29:44 <Bish> editors suck :/
03:29:55 <dminuoso> Bish: I think some peoples expectations do.
03:30:47 <tdammers> it helps to think of tabs and spaces as perfectly normal characters
03:31:40 <Taneb> Is there something like Identity but with a MonadFail instance that calls "error"?
03:31:46 <dminuoso> Bish: Besides, if you want to be lazy and pick say spacemacs and use the haskell layer - you get sane and fine defaults.
03:31:47 * Bish gotta learn to configure/use vim/emacs for 10 years to be happy
03:32:05 <Athas> The tab character is definitely not normal!  It is the only context-sensitive character in all of ASCII (except some control characters).
03:32:22 <dminuoso> (And spacemacs does all of it automatically behind the scenes, so it works out of the box)
03:32:41 <Bish> i am already confused all these emacs distributions that exist
03:33:10 <Bish> using M+ for navigation is insane
03:33:17 <dminuoso> Athas: Once you go into that area, then all of ASCII is not normal. People pretend its a text format, when its really a terminal control protocol.
03:33:50 <dminuoso> Athas: I mean what do you realistically expect a *text* editor to do when you see a \a character? Should your editor continuosly produce bell sounds?
03:34:33 <Athas> dminuoso: no, I would expect it to mark it up somehow as a crazy character.  And I'd expect the same for \t!
03:34:54 <Athas> It's crazy that the size of \t depends on how many characters precede it.
03:35:23 <Athas> When tabs are involved, a compiler cannot even provide column offsets for errors, unless you enjoy configuring the tab size of your compiler.
03:35:24 <dminuoso> +-
03:37:26 <tdammers>  :set list
03:37:35 <tdammers> now tabs show up as "crazy" characters
03:37:43 <tdammers> you can even configure the flavor of crazy
03:37:56 <merijn> Yeah, I have obnoxious red arrows for it :p
03:38:17 * hackage ngx-export-tools-extra 0.1.0.0 - More extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-extra-0.1.0.0 (lyokha)
03:38:20 <tdammers> vim can also highlight tabs following non-tab characters
03:40:02 <Putonlalla> I can recommend `listchars=tab:├─,trail:·,nbsp:␣` for all your spatial needs.
03:48:14 <Bish> oh lol, the haskell-ide package for atom is massive
03:59:50 <Rembane> I suppose it contains at least one version of GHC. 
04:12:43 <Bish> Rembane: no it communicates wqith ghc-mod as it seems
04:12:49 <Bish> but doesnt work for me out of the box so what gives
04:16:25 <Rembane> Bish: Okay. 
04:18:53 <Athas> Has anyone ever written an explanation of why editor tooling for Haskell is so flakey?
04:18:59 <Athas> (Or is it like this for most languages?)
04:19:27 <dminuoso> Athas: One big reason is the lack of industrial funding/backing I suppose.
04:19:36 <merijn> Athas: This kinda tooling is annoying to implement and no one wants to do it. Most languages get by on a handful of people sacrifing themselves to get things working
04:20:03 <merijn> Athas: And, in fact, ghc-mod and hdevtools were working rather well, right up until the point that new-build required them to be changed and no one working on them had time
04:21:05 <Rembane> merijn: Aren't the old cabal commands still around, or has something else happened? 
04:21:22 <cocreature> Is there a flag that has the effect of "-no-threaded"?
04:21:33 <merijn> Rembane: Sure, but that doesn't help unless you can succesfully build with those
04:21:36 <dminuoso> Rembane: They are, you refer to them as v1-* as opposed to v2-* for the new ones.
04:21:53 <Rembane> merijn: That's true. I didn't think of that. 
04:21:55 <merijn> Rembane: Also, hdevtools and ghc-mod were using the Cabal library's unstable internal APIs which changed
04:22:01 <Rembane> merijn: Ouch! 
04:22:48 <merijn> I was working on a ghcid based replacement for hdevtools, but (like all the others) progress is slow, since I can only work on it outside of work and 90% of the time I have more fun/less painful things to do :p
04:26:46 <Athas> So, is the Haskell-specific part that we had poor build tools (which changed for the better), and that the IDE tools had to use internal APIs (which obviously change)?
04:27:02 <Solonarv> sounds about right
04:27:28 <Solonarv> apparently intero works alright, but that has lock-in to stack which limits its usefulness
04:27:29 <Athas> Something like Rust could just get it right from the start.
04:27:36 <Athas> I wonder how good the OCaml IDE experience is.
04:27:57 <merijn> Athas: Basically, yes
04:28:02 <Athas> I've had some success with Intero, but it is also flakey sometimes, and it has really frustrating failure modes where the entire Emacs starts fucking up.
04:28:15 <Athas> I value stability far higher than features, so now I just use ghcid and sometimes flycheck.
04:28:37 <carlosdagos> Athas: have you ever used ghcid? I find it quite easy to use
04:28:37 <Athas> ghcid is very very good, exclusively because of its stability.
04:28:49 <carlosdagos> Aha there it is :) 
04:38:15 <Uniaika> I personally replaced it with `stack test --file-watch`
04:38:37 <dminuoso> Is there a way to run ghcid in a new-* project?
04:38:51 <merijn> dminuoso: Yes, just call "cabal new-repl" instead of ghci
04:38:57 <Solonarv> sure, ghcid doesn't care what command you use to open the repl
04:39:21 <carlosdagos> Uniaika: That wouldn't work for non-stack projects though 
04:39:22 <dminuoso> merijn: Do you then specify ghcid as a build-depends dependency? Or would you install ghcid globally through nix/cabal old-*?
04:39:28 <Solonarv> ghcid -c 'cabal new-repl', or ghcid -c 'stack repl', or...
04:39:47 <merijn> dminuoso: You can install ghcid via new-install too...
04:39:54 <merijn> dminuoso: Why would it care how you installed ghcid?
04:39:59 <Solonarv> ghcid isn't bound to any particular ghc/whatever version so it's fine to install as a "global" binary
04:40:36 <Solonarv> you're not going to run into issues like "installed ghcid expects ghc 8.4 API but this project uses ghc 8.6", because ghcid doesn't use the ghc API
04:41:58 <Solonarv> if you run ghcid without specifying -c then it will try to guess based on files in the CWD
04:45:02 <dminuoso> Ah fair enough. So Ill just install ghcid via nix then
04:56:32 <tabaqui> back to yesterday discussion about Functor in Haskell
04:56:43 <tabaqui> if we add Typeable constraint in definition of fmap
04:57:12 <tabaqui> then we can add trivial functor instance "fmap f = id or _|_"
04:59:21 <mouse07410> Merjin: Athas: The main problem IMHO is the conscious decision to accept, maybe even encourage instability of API. Is practically guarantees that even if something works today, it won't tomorrow. In this aspect Haskell ecosystem is the worst, compared to all the languages I ever worked with (and that's quite an achievement for Haskell ;)
04:59:49 <Athas> mouse07410: I agree, and I have the same impression.  Haskell APIs are incredibly volatile.
05:01:09 <Rembane> OTOH, you compile, the typechecker screams and then it's usually easy to fix. 
05:02:36 <Solonarv> and at least our build tool(s) categorically refuse to have multiple versions of the same package in the dependency graph
05:04:31 <mouse07410> That, and the decision that it's OK to download the entire different toolchain merely because one package requires something other than you have installed. With this approach, soon enough you hit the situation when packages in one build don't agree, so no matter how many tool gains you install, the build don't succeed.
05:07:43 <mouse07410> Solonarv: yes - but with no API stability you hit what I described sooner or later. I hit it sooner because I'm trying to get complex tooling to work (IDE plugins). One can manage staying with the same version of the dependencies and tooochain for so long until something had to change and breaks all the rest.
05:08:08 <Uniaika> carlosdagos: yes indeed
05:08:12 <dminuoso> mouse07410: Is that realistically a problem? If you set tight bounds then you should never experience instability issues unless people disrespect PVP.
05:10:24 <dminuoso> mouse07410: So I dont know about the "if it works today, it might not tomorrow"
05:10:42 <mouse07410> Athas: IMHO the problem is not instability itself, but the almost-encouragement to ignore what software engineers learned in several decades: respect for maintaining compatibility. That's why ghc-mod doen't build any more, intero may or may not build depending on your luck and local config, etc.
05:10:44 <dminuoso> That rather sounds like an artifact of not providing dependency bounds.
05:11:48 <Athas> mouse07410: I agree.
05:12:30 <Athas> dminuoso: dependency bounds are a band-aid.  It fixes you into a fairly rigid snapshot of the world.  In contrast, respect for backwards-compatibility lets you both progress and avoid churn.
05:12:50 <Athas> Haskell does progress, but the cost is having to retrofit old code.
05:12:52 <mouse07410> dminuoso: yes it is a problem that manifests itself when something gets out of whack. Tight bounds guarantee that instead of failing sometimes during run time, it will fail during build always.
05:14:19 <Athas> Which language ecosystems are the best at ensuring progress while maintaining a good amount of backwards compatibility?
05:14:26 <Athas> Java?
05:14:47 <Athas> I do recall that Common Lisp was decent at it, but it's been some years.
05:15:32 <mouse07410> dminuoso: as an obvious example - try building ghc-mod. It's "tight bounds" don't seem to help, even when you use stack that tried to pull exactly the specified dependencies. Or if you know a magic incantation to build it now - please share it with me
05:16:19 <matsurago_> Athas: C++
05:16:47 <Athas> matsurago_: I thought about C++ as well, but does it really have a thriving ecosystem of third party packages?
05:17:37 <mouse07410> Athas: in my experience (of more than 3 decades), Java is reasonably good. I've never had a problem with "major" components like toolchains or IDE, and very rarely with individual packages, which in turn usually were fixable.
05:17:38 <Athas> People seem to mostly use either just the standard library (plus OS APIs like POSIX or Win32) or mega-frameworks like Qt.  Nothing like the dozens of small libraries people use in Haskell.
05:18:26 <matsurago_> Athas: the language evolves pretty quickly, and the new features are amazing, and they are super cautious about compatibility. As for libraries, it depends on area of application
05:19:01 <mouse07410> C is fine in that aspect too. There's a reason for many other languages to provide FFI which basically allows calling functions from a C library.
05:19:28 <matsurago_> Athas: for AI/Image processing/Math there is lots of staff. I think no one uses just stdlib for these applications
05:20:59 <Athas> I guess you are right.  The old number crunching libraries are super stable, too.
05:21:05 <mouse07410> C++ is fine in the sense that most likely whatever library you need you could recompile yourself (but Haskell and Rust do it anyway, so no loss here ;).
05:22:07 <matsurago_> Rust is nice, but it is not stable yet
05:22:31 <mouse07410> But with C or Java, you're likely to be able to use old er) libraries - with C++ is less so.
05:23:33 <fendor> mouse07410, java, eh... the moment you do not use spring parent in maven, things get dirty very quickly, imo
05:24:49 <matsurago_> mouse07410: I know they keep lots of all not recommended constructs just for compatibility reasons, so it should be fine to call old libraries. The only thing I remember they wanted to remove badly was auto_ptr
05:25:22 <matsurago_> As for Java, 11 has many compatibility issues with 8 and below.
05:25:43 <fendor> i mean major libraries, not the language itself
05:26:10 <mouse07410> matsurago_: true - but Rust community seems to have a far greater respect for API stability than this one. I'm trying to add both Haskell and Rust to my "arsenal". So far, with Rust most things just work, particularly the "big" ones. Here, is a miracle when IDE successfully build a toy project.
05:26:11 <matsurago_> fendor: and of course with libraries for 8 and below
05:26:58 <Athas> Java 8 and Java 11 are separated by four years.  I think (GHC) Haskell changed more than Java did in that period.
05:27:14 <__monty__> mouse07410: That's not fair. ghcmod and friends weren't using strictly public APIs.
05:27:32 <mouse07410> matsurago_: yes and no. I have fairly complex things done in Java-8, and they all run fine after minor changes in the invocation scripts.
05:27:45 <matsurago_> mouse07410: my arsenal was (Java, C++, Haskell), I am trying Rust now, love it so far. 
05:27:59 <fendor> rust is less fragmented than haskell
05:28:36 <Rembane> And hasn't existed for nearly as long.
05:28:57 <__monty__> Maybe Haskell's reputation of being hard/inaccessible doesn't attract the kind of people who like making accessible GUI development tools?
05:29:33 <matsurago_> mouse07410: I have experience upgrading a Java 8 project that uses lots of sun.misc.* staff like SharedSecrets. It takes ages to upgrade with all hacky compile and runtime args, which may not even be supported in future...
05:30:00 <mouse07410> Java-11 was a breaking change - somewhat like OpenSSL-1.1.x vs 1.0.x. Yet, the transition was fairly straightforward, and if you must hey something old run without the new environment, it was trivial. With Haskell ecosystem it seems just impossible.
05:30:43 <__monty__> Do you have an example?
05:33:05 <mouse07410> __monty__: maybe you're right re. GUI. And Haskell is not difficult to grasp of you come from imperative language (ALGOL, FORTRAN, PL/1, C, C++, Java, various assemblers - you got the idea ;).
05:33:19 <mouse07410> Example of what?
05:33:39 <__monty__> Of old stuff that you can't get to run anymore.
05:48:18 <mouse07410> Ah, sure - with explanations. ghc-mod - which prevents one IDE plugin from being usable. interior - which was blocking another plugin, until I convinced the author to avoid forcing rebuild of interior and use what's already installed for the right GHC. Network package, which makes it impossible to user older stuff. ghc-paths package, which managed to evade successful builds... And I'm just a beginner with Haskell, so I'm
05:48:18 <mouse07410> sure I'm only scratching at surface here...
05:48:35 <mouse07410> ^intero
05:51:08 <mouse07410> To add to my bucket of gripes - tools like stack do not seem to pass all the global config parameters to packages they build, or the packages seem to ignore them. Add a result, workarounds for local problems that work with every other ecosystem, fail here: you can't link to a specific library if it's path is not pushed down...
05:51:22 <mouse07410> ^As
05:51:33 <__monty__> ghc-mod still works, you just have to use an older ghc, same with the others. These are all exceptional in that they're tightly bound to ghc's implementation though. During normal everyday haskelling you'd encounter that much less.
06:12:10 <mouse07410> __monty__: again, yes and no. E.g., stack fails to build ghc-mod, despite being designed to download whatever toolchain and packages are needed for a specific build. So does the new Cabal. I agree that during "normal everyday" you encounter such issues much less.
06:12:38 <mouse07410> But getting to that convenient everyday k seems a problem.
06:15:50 <__monty__> It doesn't build with an old ghc and v2-* cabal?
06:19:12 <mouse07410> You got it - it didn't
06:50:32 <royal_screwup21> I have a function like so: `parse ((+) ⟨$⟩ number ⟨∗ char ' ' ⟨∗⟩ number ) "7 5" = [(12, "")] `I sort of know what each combinator does individually, but I can't for the life of me figure how they all interact together. Is it supposed to blindingly obvious?
06:52:03 <tabaqui> do you use another unicode braces?
06:52:18 <tabaqui> "<$>" "⟨$⟩"
06:52:32 <royal_screwup21> tabaqui ah yeah, I just copy-pasted from a pdf 
06:52:54 <dminuoso> royal_screwup21: Which pdf is that?
06:53:18 <tabaqui> well, except of this unicode, I see no issues in the code
06:53:28 <tabaqui> not really obvious but well readable for me
06:53:50 <dminuoso> royal_screwup21: Is it possible you missed a single brace there?
06:54:23 <dminuoso> royal_screwup21: Do you understand how Applicative generalizes Functor for arbitrary functions (not just 1-arity functions)?
06:54:51 <tabaqui> get somehow (f Int), skip lifted space, get another (f Int), sum it together with lifted (+), and parse with this combinator given string
06:55:01 <royal_screwup21> the snippet is exactly as it is in the pdf...I'll have to read up more
06:55:10 <dminuoso> royal_screwup21: Pretty sure you missed a single > there :-)
06:55:16 <dminuoso> royal_screwup21: So consider:
06:55:18 <tabaqui> dminuoso: where?
06:55:30 <dminuoso> tabaqui: parse ((+) ⟨$⟩ number ⟨∗ char ' ' ⟨∗⟩ number )
06:55:40 <dminuoso> tabaqui: parse ((+) ⟨$⟩ number ⟨∗⟩ char ' ' ⟨∗⟩ number )
06:55:45 <tabaqui> nope
06:55:49 <dminuoso> Huh?
06:55:52 <Solonarv> dminuoso: no, that's not right
06:55:59 <Solonarv> :t (<*)
06:56:00 <lambdabot> Applicative f => f a -> f b -> f a
06:56:04 <dminuoso> Oh!
06:56:06 <tabaqui> then we will "(+) 7 ' ' 5"
06:56:31 <dminuoso> Its amazing how incapable I am of reading code with unicode braces..
06:56:47 <tabaqui> do you use ligatures, by the way?
06:56:48 <royal_screwup21> tabaqui the way you descibred it -- "get somehow..." that's kind of the intituion I was looking for, thanks 
06:56:54 <dminuoso> tabaqui: Yes.
06:57:03 <dminuoso> Probably a part of it.
06:57:05 <tabaqui> royal_screwup21: my pleasure :)
06:57:12 <tabaqui> dminuoso: Fira Code, I guess?
06:57:33 <dminuoso> tabaqui: Yup.
06:57:54 <royal_screwup21> is that how it's supposed to be understood? Or are you supposed to look at the signatures of each combinator and take it from there? 
06:57:56 <dminuoso> Though Im very close to buying pragmata pro
06:58:19 <royal_screwup21> like, I have this definition: (⟨∗) :: Parser a → Parser b → Parser a
06:58:34 <dminuoso> royal_screwup21: It's a kind of "flipped" around >>
06:58:50 <dminuoso> % :t (>>)
06:58:50 <yahb> dminuoso: Monad m => m a -> m b -> m b
06:58:52 <dminuoso> % :t (<*)
06:58:53 <yahb> dminuoso: Applicative f => f a -> f b -> f a
06:59:02 <dminuoso> Ignore the different constraints here. Pretend they both read Applicative.
06:59:11 <tabaqui> remember about effects
06:59:21 <tabaqui> <* doesn't skip effects of the second argument
06:59:43 <tabaqui> in the example, we still parse ' ' and skip it after
06:59:48 <dminuoso> royal_screwup21: Just like >> sequences efffects and discards the result of the first, <* sequences effects and discards the result of the second
07:00:18 <dminuoso> royal_screwup21: So if you accept that *> is >>, then you could think of the * as denoting "combining effects" and the arrows denoting which result to pick. :)
07:00:31 <royal_screwup21> ah I see...
07:00:42 <dminuoso> *> picks the result from the action to the right, <* picks the result from the action to the left, <*> picks both and applies the left to the right
07:01:48 <tabaqui> what's about signatures, usually I don't think about actual Functor. The library just returns me integer with number combinator. All the magic is in the "parse" function.
07:02:17 <dminuoso> equivalently
07:02:22 <dminuoso> % :t <$
07:02:23 <yahb> dminuoso: ; <interactive>:1:1: error: parse error on input `<$'
07:02:26 <dminuoso> % :t (<$)
07:02:26 <yahb> dminuoso: Functor f => a -> f b -> f a
07:02:29 <dminuoso> % :t ($>)
07:02:30 <yahb> dminuoso: Functor f => f a -> b -> f b
07:02:39 <dminuoso> royal_screwup21: ^- these two guys are also nice to be aware of. :)
07:03:28 <dminuoso> (Which lets you simply override/set the the result without changing the effect)
07:03:48 <royal_screwup21> hmm I see
07:04:17 <royal_screwup21> (3 <$ word) "hello world"
07:04:20 <dminuoso> So if you ever find yourself writing something like `x >> pure ()`, you could also just write `x $> ()`
07:04:22 <tabaqui> btw, check out the ApplicativeDo extension
07:05:06 <royal_screwup21> am I right in thinking the above sinppet would return [(3, " world")]  (assmuing word parses a stream of characters and stops at a sapce)
07:05:17 <tabaqui> yeah
07:07:01 <royal_screwup21> interesting...hmm
07:07:33 <Denommus> dminuoso: that's cool
07:08:35 <royal_screwup21> number <* word "hello12" -- would this return [(12, ""]) ? My thinking is, it first parses word to get ("hello", 12"), then applies the num onto the consuming stuff 
07:08:46 <royal_screwup21> unconsumed stuff**
07:09:08 <royal_screwup21> also [("hello", "12")
07:09:08 <dminuoso> royal_screwup21: Well the code is a bit incomplete. 
07:09:31 <royal_screwup21> oh right 
07:09:41 <dminuoso> royal_screwup21: And also no.
07:09:49 <dminuoso> royal_screwup21: The order of effects is still left-to-right
07:09:59 <tabaqui> it will parse number at first
07:10:05 <dminuoso> <*>, <* and *> all sequence left-to-right
07:10:15 <royal_screwup21> ah okay
07:10:22 <dminuoso> the braces just identify which results to keep
07:10:38 <dminuoso> <* keeps the result of the left action, *> keeps the result of the right action, <*> combines them bothg
07:10:40 <royal_screwup21> `number <* word "hello12"` -- this basically returns a Parser. I need to run the parse function against it to get the list of tuples
07:10:55 <dminuoso> royal_screwup21: its missing parens and some additional `runParser` code probably
07:11:09 <royal_screwup21> ah okay cool
07:11:12 <dminuoso> unless `word :: String -> Parser Something`
07:13:32 <tabaqui> anyway, try to write it with do-notation and ApplicativeDo enabled
07:13:54 <tabaqui> like { do; n <- number; w <- word "hello"; pure n }
07:14:09 <tabaqui> it can help a lot
07:14:53 <royal_screwup21> it's interesting how the first parameter of <*> has to be a parser that parses a function...so it would return [(some_function, unconsumed_string)]...so it's parser paramterzied on a function, which in turn has to be paramterized from (a->b)....
07:15:08 <dminuoso> royal_screwup21: The choice of a *function* is relatively arbitrary actually.
07:15:20 <dminuoso> royal_screwup21: You could also pretend that instead of <*> we had a function <.> that looked like this:
07:15:39 <dminuoso> % :t (<.>)
07:15:40 <yahb> dminuoso: Applicative f => f a -> f b -> f (a, b)
07:16:02 <dminuoso> It's mostly a convenience, since a function with apply semantics happens to be what you mostly use.
07:16:10 <royal_screwup21> ah I see...
07:17:27 <tabaqui> waaat?
07:17:40 <tabaqui> from which package is this function <.>?
07:18:15 <Denommus> is `a <.> b = (,) <$> a <*> b`?
07:18:19 <tabaqui> I missed it for a long time
07:18:21 <dminuoso> Denommus: Yup.
07:18:25 <dminuoso> Or just `liftA2 (,)`
07:18:54 <dminuoso> Denommus: And to make this really pleasent, you'd also have `unit :: f ()` instead of `pure`
07:19:11 <dminuoso> Where `unit` as as a kind of identity with respect to (<.>)
07:19:16 <tabaqui> dminuoso: where can I import unit and <.>?
07:19:38 <dminuoso> tabaqui: This representation is usually called Monoidal. A few packages on hackage expose this, like `invertible`
07:19:50 <tabaqui> ok, thanks
07:19:55 <dminuoso> tabaqui: You can trivially cook it up yourself too.
07:20:00 <dminuoso> Not worth a dependency.
07:20:56 <Denommus> it reminds me of (&&&)
07:20:59 <Denommus> :t (&&&)
07:21:00 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
07:21:44 <tabaqui> err, Control.Arrow and Data.Bifunctor aren't well compatible
07:22:05 <dminuoso> Denommus: The notion of "monoid" is extremely pervasive in programming. :)
07:22:28 <Denommus> tabaqui: not saying they're compatible, just that they have a similar look
07:23:03 <dminuoso> Denommus: There's monoidal profunctors, which have `par :: p a b -> p c d -> p (a, c) (b, d); unit :: p () ()` which also looks surprisingly similar
07:25:50 <dminuoso> Denommus: But yeah. What you actually see is part of the reason why Arrow is considered superseded by Applicative (and other things)
07:26:13 <dminuoso> So its an actual relationship
07:26:17 <ski> (the most annoying thing about `Arrow' is `arr')
07:27:18 <dminuoso> (***) gives you monoidal profunctors, (&&&) gives you applicative, first/second gives you strong profunctors.. arr gives you.. I dont even know
07:29:33 <tabaqui> fmap, possible?
07:31:48 <Denommus> dminuoso: should I be able to implement something like opaleye with applicative, then? Or am I misunderstanding?
07:44:02 <dminuoso> Denommus: Probably not. I should have said "largely superseded".
08:12:26 <dminuoso> What is the reason for some packages like https://hackage.haskell.org/package/libsystemd-daemon-0.1.0.1 not having haddock documentation?
08:13:15 <phadej> "something like opaleye" with applicative: maybe.
08:13:31 <phadej> but not "only with applicative"
08:17:54 <fen> new to GADTs apparently they cant be mutually recursive? https://pastebin.com/raw/RkvDYZyK
08:18:10 <fen> and does this seem like an ok representation of state (other than the cyclic GADT...)
08:19:07 <fen> oh, its not quite a state, just the return type, like the "base functor" of recursion schemes, `f s'
08:19:15 <fen> of, s -> f s
08:19:53 <fen> this is supposed to cover all possible cases of such
08:21:28 <tabaqui> can you minify the example?
08:22:04 <ski> they can certainly be mutually recursive. btw, you don't need `GADTs' there, `GADTSyntax' would suffice (or ordinary algebraic `data' type syntax)
08:22:18 <int-e> fen: Mutual recursion on the data level is fine... but apparently not for kinds. I don't know the reason for that (it'll either be "it's hard" or "this would make the type system inconsistent)
08:23:08 <ski> you are defining a type `State', but then in the definition of `Nested', you're trying to use a *kind* `State' (via `DataKinds'), and apparently that's not allowed in a mutually recursive group ..
08:23:28 <tabaqui> data Foo = Foo Bar; data Bar (x :: Foo);
08:23:40 <tabaqui> cannot be compiled with the same error
08:23:52 <dminuoso> int-e: What's the difference since we have TypeInType?
08:24:26 <fen> ski: so basically you cant have a GADT that takes a type level list of itself as an input?
08:24:26 <int-e> dminuoso: Ask goldfire, maybe :P
08:24:35 <dminuoso> Heh :)
08:24:43 <ski> also, the  Nested'  `data' constructor of `State' looks suspicious (as does the `Nested' `data' constructor of `Nested'), because of `xs' being a singleton
08:24:44 <tabaqui> fen: it is not about GADTs
08:25:51 <ski> fen : i'd bet you'd get the same error, if you replaced `GADTs' by `GADTSyntax', or even scrapped that (using `ExistentialQuantification' for  Nested'  ..)
08:26:12 <fen> right, just any datatype then
08:26:45 <Solonarv> dminuoso, tabaqui:
08:26:45 <Solonarv> instance Arrow p => Functor (p e) where
08:26:45 <Solonarv>   fmap f pea = arr f . pea -- note: this is the (.) from Control.Category
08:26:45 <Solonarv> instance Arrow p => Applicative (p e) where
08:26:45 <Solonarv>   pure x = arr (const x)
08:26:46 <Solonarv>   liftA2 op pea peb = fmap (uncurry op) . pea &&& peb
08:27:04 <fen> actually, this gives a different error, maybe it wasnt the correct way to write that type level list of state...
08:27:05 <fen> https://pastebin.com/raw/tpLZr30N
08:27:33 <Solonarv> obviously these instances are a Bad Idea as such, but they actually exist in base with a WrappedArrow wrapper
08:28:35 <ski> fen : that's just an ordinary kind error
08:28:45 <ski> (which you introduced in this new paste)
08:28:45 <tabaqui> fen: it's pretty simple: "x s a" implies that "x :: * -> * -> *", while xs has just "*"
08:28:47 <fen> tabaqui: yeah, maybe it wasnt the correct thing to try and use State as the *kind* of the things in the type level list... just want to somehow say that the list is of States
08:29:25 <tabaqui> * not xs itself, but "Head xs :: *"
08:29:34 <fen> otherwise it gives Expecting two more arguments to `(,)'
08:30:08 <fen> or Expected kind `[(s1, a1)]', but `xs' has kind `[*]'
08:30:42 <ski> fen : anyway .. it looks like you'ren't doing anything GADTy .. so is there any reason for enabling that (you can use `GADTSyntax' if you for some reason just want the alternative `data' constructor declaration style) ?
08:31:29 <fen> like, this works, but then its just a list of any kind * -> * -> * thing, not nesacarily of States https://pastebin.com/raw/Ysazehxi
08:31:59 <fen> ski: it just makes the use of a constraint nicer to read because it has a ::
08:32:03 <tabaqui>  % data Foo = Foo Bar; data Bar (x :: Foo)
08:32:07 <tabaqui> % data Foo = Foo Bar; data Bar (x :: Foo)
08:32:07 <yahb> tabaqui: ; <interactive>:105:36: error:; * Type constructor `Foo' cannot be used here (it is defined and used in the same recursive group); * In the kind `Foo'
08:32:41 <ski> fen : ok, so `GADTSyntax', then (possibly coupled with `ExistentialQuantification') ?
08:34:03 <fen> yeah it works with those, whats the difference?
08:34:35 <fen> data Foo = Foo Bar; data Bar (x@Foo)
08:34:36 <int-e> https://gitlab.haskell.org/ghc/ghc/blob/master/compiler/typecheck/TcTyClsDecls.hs#L1179-1193 <-- hmm "We don't want to" doesn't really help me here...
08:34:56 <ski> i don't even know what you mean by "type level list of state"
08:36:49 <fen> well its not that the kind should be restricted, that was a mistake, just that the contents of the list should be not [* -> * -> *], but eg [Stream,Linear]
08:37:00 <dminuoso> Solonarv: The more I understand about arrows the less I understand.
08:37:16 <Solonarv> yeah, arrows are weird :/
08:37:40 <Solonarv> but actually all I did here is prove the claim that "Arrow is at least as powerful as Applicative"
08:38:24 <ski> you don't seem to do anything interesting with the `xs' parameter of `Nested s a xs', anyway ..
08:38:51 <fen> data Nested (s :: *) (a :: *) (xs :: [* -> * -> *]) where
08:38:52 <fen>   Nested :: (Head xs ~ x) => x s a -> Nested s a xs
08:39:13 <fen> the x s a, should just be e.g. one of Stream s a... etc
08:40:01 <fen> basically, if your using a nested state as a state for unfolding, it unfolds the lowest layer into its respective container
08:40:34 <fen> so it needs to have the correct "fail" case, as specified by the corresponding Stream / Linear etc datatype
08:41:37 <fen> it would then return a Nested State with the tail of xs, and a ~ [a] for example (corresponding to Stack)
08:42:18 <fen> but the problem is just trying to make xs only contain states
08:42:46 <fen> maybe a constraint would do, but even that is not obvious how it would be written
08:43:47 <fen> it seems to be some complication to do with trying to "enumerate all the instances of a class" as a datatype, as then you cant use it as a constraint 
08:43:49 <int-e> https://gitlab.haskell.org/ghc/ghc/issues/11962 seems relevant.
08:44:13 <int-e> dminuoso: you'll be happy that it starts with "Now that we have -XTypeInType"...
08:44:28 <ski>   Nested :: x s a -> Nested s a (x ': xs)  -- hmm ?
08:44:30 <int-e> dminuoso: while I'm happy that goldfire is the reporter :)
08:45:03 <ski> (`a ~ [a]' sounds like it would give a cyclic/infinite type ..)
08:45:56 <royal_screwup21> could someone give me an example of uncurry/curry? I'm looking here http://zvon.org/other/haskell/Outputprelude/uncurry_f.html but it's not clear what's happening
08:46:17 <fen> sorry, thats the a of the new state, returned upon unfolding, maybe a' ~ [a] would be clearer
08:47:01 <fen> ski: that looks more like a kind of Cons, its just supposed to be the head value, the list (which does not change size) is just a phantom parameter
08:47:31 <fen> you just want to be able to read off the Head to see which State it actually is
08:48:13 <royal_screwup21> ok, so curry just wraps the args into a pair, whereas uncurry unapairs them
08:48:17 <fen> as when you are unfolding the nested state, only the innermost state is being used to hold the returned values; s -> SomeState s a
08:48:51 <dminuoso> royal_screwup21: Right. In other words `a -> b -> c` and `(a, b) -> c` are isomorphic. curry/uncurry are witnesses of that isomorphism.
08:49:54 <fen> :t [curry (uncurry (:)),(:)]
08:49:55 <lambdabot> [a -> [a] -> [a]]
08:50:15 <dminuoso> royal_screwup21: Sometimes, for API reasons, you might get a tuple thrown at you and you want to feed both as seperate arguments to a function. uncurry could be used as a kind of adapter if you dont want to manually do this
08:50:55 <dminuoso> say you have some `p :: IO (Int, String)` and you want to feed that into `f :: Int -> String -> IO ()`
08:51:15 <dminuoso> You could use do notation and pattern matching, or just write `uncurry f =<< p`
08:51:43 <dminuoso> Uh. Or curry rather.
08:52:01 <dminuoso> No, it's curry. Oh well
08:52:09 <fen> :t curry
08:52:10 <lambdabot> ((a, b) -> c) -> a -> b -> c
08:54:22 <fen> ski: maybe the different (Sum) fields of the GADT would be better as instances of a Class, which could then be used to constrain the values of xs
08:58:33 <fen> like this; https://pastebin.com/raw/fvsSfGTX
08:59:51 <fen> it compiles but its the weirdest style ever... maybe the other datatypes could be turned into instances like this...
09:02:00 * ski has no idea what fen is attempting to achieve, so can't help with that ..
09:04:39 <fen> well, here it is as a closed type family instead! https://pastebin.com/raw/SSzwMq1Y
09:05:25 <fen> ski: to be able to constrain a type to be one of the records of a sum datatype
09:06:15 <fen> that version^ uses a closed type family instead of a class, as then all the instances can be specified together with the class declaration, just like a GADT 
09:07:47 * hackage hasql 1.3.0.5 - An efficient PostgreSQL driver and a flexible mapping API  https://hackage.haskell.org/package/hasql-1.3.0.5 (NikitaVolkov)
09:11:17 * hackage ghc-lib-parser 0.20190423 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-0.20190423 (shayne_fletcher)
09:16:31 <fen> its wierd because you cant write the constraint in the header of the GADT where appears this phantom list of types you want to constrain to be just members of another GADT, and instead the constraint has to go in the type of the constructor 
09:16:41 <fen> there is DatatypeContexts
09:16:47 <fen> but it gives these errors;
09:16:48 <fen> https://pastebin.com/raw/E5cTDANs
09:17:07 <fen> seems like you cant constraint the parameters to a GADT
09:17:39 <fen> and if you write it as a regular datatype, then you cant constrain the Constructors properly...
09:20:17 * hackage ghc-lib 0.20190423 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-0.20190423 (shayne_fletcher)
09:26:42 <leshow> does any covariant type have a functor instance?
09:27:47 * hackage language-ats 1.7.1.2 - Parser and pretty-printer for ATS.  https://hackage.haskell.org/package/language-ats-1.7.1.2 (vmchale)
09:28:02 <Taneb> leshow: what do you mean by "covariant type"
09:28:50 <fen> ok this sort of works, just not sure if that forall x. is ok... https://pastebin.com/raw/GTvkhbfc
09:28:59 <fen> data (All StateSym0 xs) => Nested (xs :: [* -> * -> *]) (s :: *) (a :: *) = Nested {unNested :: forall x. (State x,Head xs ~ x) => x s a}
09:29:16 <leshow> Taneb: take for example, newtype T a = T ((a -> Int) -> Int)
09:29:33 <Solonarv> sure, that has a Functor instance (GHC can even derive that instance for you)
09:29:34 <leshow> it's covariant, a is in positive position, and it has a functor instance
09:29:52 <leshow> is any type that's covariant going to have a functor instance
09:30:01 <Taneb> leshow: http://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Cont.html#t:ContT
09:30:08 <Solonarv> depends on the definition of "covariant"
09:30:10 <Taneb> ContT from transformers is an example
09:30:27 <Solonarv> "can have a Functor instance" is a reasonable-ish definition, and then it's trivially true
09:30:28 <nshepperd> fen: DatatypeContexts is useless. if you want to constrain the parameters of a type in any useful way, it needs to be a GADT
09:30:30 <Taneb> Oh, you mean do all of them have Functor instances
09:30:43 <fen> nshepperd: it throws an error though
09:30:54 <fen> No context is allowed on a GADT-style data declaration     (You can put a context on each constructor, though.)
09:31:43 <fen> why would it insist that the constraint is rewritten on each constructor?
09:33:25 <fen> also, no-one has seemed to comment at all on this very peculiar converting of a GADT into a type family emulating a kind of closed class !?
09:35:34 <fen> of all the strange nature of this, the fact its not like a newtype but more like a Sum type synonym (having no "wrappers" on the various fields) seems most odd
09:36:18 <fen> is this even a thing? it seems like some kind of hack
09:37:11 <shapr> I'm trying to come up with a good process to follow at recurse center
09:37:26 <shapr> I figure I'll do the fp-course, but I'm not sure what other material I could follow
09:38:25 <Boarders> Is there any way to get the name of a type in haskell
09:38:31 <Boarders> possibly with something like Typeable or etc
09:39:52 <Boarders> shapr: what are you looking to acheive?
09:39:57 <ski> shapr : recurse center ? is that like when one curse wasn't enough, or didn't take properly ?
09:40:20 <shapr> Boarders: become qualified for a "real" haskell job
09:40:36 <shapr> I figure I'm intermediate Haskeller, but I haven't written a real thing yet
09:40:38 * ski idly ponders rebless
09:41:02 * ski . o O ( "redress" )
09:41:09 <Boarders> is there anything you would like to build in haskell?
09:41:34 <shapr> lots of things, but I'm not sure what will fit into 12 weeks
09:41:44 <shapr> I wanted to build a research paper organization and annotation tool a long time ago
09:41:47 <shapr> I could start with that
09:42:26 <ski> shapr : FLM ?
09:42:29 <Boarders> that sounds cool
09:42:29 <fen> ooh, you could do some machine learning for sentiment analysis 
09:42:37 <shapr> ski: you've heard of it?
09:42:49 <Xunie> Sentiment analysis is very interesting, I tell ya.
09:42:51 <ski> shapr : i think you've mentioned "Fermat's Last Margin" before, in here ?
09:42:58 <Xunie> Hey there, ski. Nice to see you again. :3
09:43:03 <shapr> ski: yes, I have. But it's been quite some time.
09:43:04 * ski waves
09:43:15 <ski> (must've been some years since, yes)
09:43:45 <fen> shapr: annotations like "this sentence states the utility of the current approach to industry" - "comment on the increasing power of computers in recent years" etc
09:44:36 <fen> if you could parse those into a kind of lossless summary you might be able to automate a literature review tool
09:44:47 <shapr> I have a really large amount of research papers
09:44:59 <shapr> I'd like to be able to write notes in the margins, and save those notes to a git repo
09:45:02 <shapr> then share with others
09:45:14 <shapr> yeah, this does sound like a fun thing to build
09:45:28 <shapr> I don't think I would have enough time to try to build a spoken programming language
09:45:41 * ski . o O ( "The one with the most research papers when they die, wins." )
09:46:09 <fen> yeah, dont we all! thats the basic state of human global collaborative research, its fast outpacing the ability of individuals or even some groups to read all the new material, especially when it restates so much similar and essentially superfluous stuff
09:46:21 <int-e> ski: is that the new "publish and perish" approach to research?
09:47:03 <fen> that really shouldnt be the goal, simply curating the existing papers is totally valid.
09:47:05 <shapr> @remember ski . o O ( "The one with the most research papers when they die, wins." )
09:47:05 <lambdabot> Nice!
09:47:18 <ski> int-e : well, i was thinking more of having individually downloaded papers, rather than publishing, but i guess it might apply to that as well
09:47:35 <[exa]> int-e: better, publish AND perish
09:47:43 <[exa]> oh I can't read
09:48:49 <fen> like, a lot of research is done in like, second order citations etc.. even research has been done into machine learning to determine the most influential papers by tracking common phrasiology etc - to determine the quality of a contribution
09:50:16 <fen> but the idea of lossless compression is really serious. you dont want to be in the position of saying "ok. if you have the following books, then you dont need to read anything written before 1970" unless you can be absolutely certain there is nothing missing / no utility in the original work
09:51:26 <fen> and thats really difficult to determine if you have to understand how people might learn when reading it.. but then, most ancient stuff is written in basically a different language, as in, you would need to have read the same papers these authors did to have their way of thinking essentially
09:51:33 <fen> and nobody is going to do that!
09:51:38 <ski> shapr : shameless travesty of "The one who knows the most number of decimals of ⌜π⌝ when they die, wins.", from a nice math song .. "Decimaler På Pi" by Matte Matik at <https://www.youtube.com/watch?v=LZXKfjsIPpc>
09:52:40 * ski . o O ( "Oh, If I Had Been a Scalar Product" by Matthew Matics at <https://www.youtube.com/watch?v=hxh-KCdm2u4> )
09:54:06 <fen> the ad-hoc approach to scientific research is pretty shakey from an engineering standpoint - a lot of developing economies could really benefit from exporting human resource in contributing to this global effort of curating scientific knowledge 
09:55:04 <fen> but the funding model is totally not set up for that, maybe we could have like a "fruit for literature review" exchange program 
09:55:21 <fen> sorry, totally rambling, off to write a blog brb
09:57:54 <WinchellsM> How can one create an RGBA color type of (1,1,1,1) into type AlphaColour Double? I've been reading Data.Colour documentation and it's incredibly opaque how to do something so simple :anger:
10:00:49 <[exa]> WinchellsM: (color) `withOpacity` (alpha) ?
10:01:38 <WinchellsM> How do I create the initial color?
10:02:09 <WinchellsM> I need something like `(1,1,1) `withOpacity` 1
10:02:15 <[exa]> using RGB, which you need to create using Chan
10:02:52 <[exa]> meh, using affineCombo of the predefined red/green/blue is probably an overkill, isn't it.
10:03:07 <phadej> rgb :: Fractional a => a -> a -> a -> Colour a
10:03:25 <phadej> [exa]: affineCombo is weighted *average*
10:03:50 <WinchellsM> (rgb 1 1 1) `withOpacity` 1
10:06:31 <[exa]> wow, 'rgb' is very well hidden.
10:07:21 <phadej> well, not really if you know about colorspaces
10:08:17 * hackage strelka 2.0.3 - A simple, flexible and composable web-router  https://hackage.haskell.org/package/strelka-2.0.3 (NikitaVolkov)
10:08:25 * ski . o O ( `affineColumbo' )
10:08:44 <phadej> as in, `colour` package is probably more then only converting `#ffffffff` to (Word8, Word8, Word8, Word8)
10:10:10 <phadej> so, it might be that you want sRGB actually
10:10:15 <phadej> Interfacing with Other Libraries' Colour Spaces
10:10:20 <phadej> Executive summary: Always use Data.Colour.SRGB when interfacing with other libraries. Use toSRGB24 / sRGB24 when interfacing with libraries wanting Word8 per channel. Use toSRGB / sRGB when interfacing with libraries wanting Double or Float per channel.
11:03:03 <Zemyla> You know, I just realized that runSTArray could be made so that it returns an inspectable array constructor.
11:06:58 <ski> "inspectable array constructor" ?
11:07:33 <Zemyla> Instead of using regular runSTArray st = runST (st >>= unsafeFreezeArray), you do something like runSTArray (ST st) = case runRW# (\s# -> case st s# of { (# s'#, STArray l u (I# n#) marr# #) -> case unsafeFreezeArray# marr# s'# of { (# _, arr# #) -> (# l, u, n#, arr# #) } }) of { (# l, u, n#, arr# #) -> Array l u (I# n#) arr# }
11:08:17 <Zemyla> Basically, instead of runRW# returning a boxed object, it returns an unboxed tuple which is turned into a boxed object outside the runRW#.
11:09:18 <ski> @hoogle runRW#
11:09:18 <lambdabot> GHC.Exts runRW# :: () => (State# RealWorld -> a) -> a
11:09:18 <lambdabot> GHC.Magic runRW# :: forall (r :: RuntimeRep) (o :: TYPE r) . (State# RealWorld -> o) -> o
11:10:30 <ski> what would be the advantage ?
11:11:06 <Zemyla> It means that, like, if you say arr = runSTArray whatever, and then use arr ! i several times, it can inline the ! code.
11:11:31 <ski> mhm, nice
11:12:04 <Zemyla> Also, slightly reducing allocations.
11:13:42 <Zemyla> I still want runSTArrayTrav :: Traversable t => (forall s. ST s (t (STArray s i e)) -> t (Array i e), because I want a calculation to be able to return a Maybe (Array i e) or a (extrastuff, Array i e).
11:13:59 * ski nods
11:14:16 <ski> (i think i recall wanting something in that direction, as well)
11:15:33 <fen> do we have closed data families?
11:17:34 <Berengal> What's the best way to turn a bunch of Chars into Text?
11:17:56 <Mo0O> do you have any advice on code formatter? I'm not realy satified about hfmt
11:18:00 <boj> :t Data.Text.pack
11:18:01 <Solonarv> are they single chars, or are they in a list?
11:18:01 <lambdabot> String -> Data.Text.Internal.Text
11:18:11 <Solonarv> if they're in a list, you want 'pack'
11:18:13 <Berengal> They're not in a list, more like a tree
11:18:47 <Mo0O> bafain: there's this function available: http://hackage.haskell.org/package/text-1.2.3.1/docs/Data-Text.html#v:pack
11:18:50 <machinedgod> fen: Sorry for parachuting in like this, but I think we do - not too lnog ago, I wrote one to solve a small-ish problem I had. Syntactically, they look a lot like gadts.
11:18:53 <Solonarv> you could 'foldMap Data.Text.singleton', but that's not very efficient
11:19:14 <cocreature> `text-builder` might be worth a look
11:19:18 <Solonarv> (appending Text's together needs to copy them fully)
11:19:26 <Solonarv> yeah, a builder would be the right approach
11:19:36 <Berengal> There's only a builder for lazy text, right?
11:19:44 <Berengal> I'm not too familiar with the library
11:20:00 <Solonarv> you can convert lazy text to strict
11:20:19 <Zemyla> runSTMultiTrav :: (forall f s. Applicative f => (forall i e. STArray s i e -> f (Array i e)) -> (forall i e. STUArray s i e -> f (UArray i e)) -> u -> f v) -> (forall s. ST s u) -> v; runSTMultiTrav tr st = runST (st >>= tr unsafeFreezeArray unsafeFreezeSTArray)
11:20:32 <machinedgod> Btw, conan exiles updates are forcing me to keep almost 100GB free on PS$ :-(
11:20:40 <machinedgod> Dmn sorry wrong channel :-(
11:21:02 <Zemyla> Actually, wait, better.
11:21:07 <fen> machinedgod: how? 
11:21:26 <Zemyla> runSTMultiTrav :: (forall f s. Applicative f => (forall i e. STArray s i e -> f (Array i e)) -> (forall i e. STUArray s i e -> f (UArray i e)) -> u s -> f v) -> (forall s. ST s (u s)) -> v; runSTMultiTrav tr st = runST (st >>= tr unsafeFreezeArray unsafeFreezeSTArray)
11:21:30 <machinedgod> fen: Check here https://wiki.haskell.org/GHC/Type_families
11:21:31 <fen> % data family A where
11:21:31 <yahb> fen: ; <interactive>:106:15: error: parse error on input `where'
11:21:41 <machinedgod> Under "Detailed definition..."
11:22:00 <fen> that section states; "However, type families - in contrast to GADTs - are open;"
11:22:18 <fen> presuming it means data families...
11:22:22 <machinedgod> fen: K, let me just pastebin my code
11:22:27 <fen> thanks!
11:23:40 <machinedgod> fen: https://lpaste.com/FEVeGLvB15
11:24:07 <fen> its not a type family?
11:24:51 <machinedgod> I must've misunderstood something then? I assumed that 'type family' is a type family, what you were looking for?
11:25:01 <machinedgod> If I did, sorry, as I said I parachuted right in without reading much context.
11:25:21 <fen> no, was after "closed data familes"
11:25:38 <fen> so they have constructors, not like type synonyms
11:25:51 <fen> basically thought they could help soleve defuntionalisation like problems
11:25:56 <machinedgod> Ah, my bad! Sorry on that, I just realized I misread
11:26:04 <fen> as data families can have instances over them when they are partially applied
11:26:39 <nshepperd> aren't closed data families just GADTs
11:26:58 <fen> are data families just open GADTs?
11:27:03 <machinedgod> Huh, interesting, I'd assume closed data families are in there, by default...
11:27:58 <nshepperd> fen: basically
11:28:06 <machinedgod> Anyway, sorry to have wasted your time, I really thought I'm helping out, for a change :-D
11:28:44 <fen> hey, no worries
11:29:11 <nshepperd> but the fact that data families are open takes away most of the good properties of GADTs from them
11:29:44 <nshepperd> like, you have to know what the type parameter is before you can pattern match on a data family value
11:30:23 <fen> hmm
11:31:38 <Solonarv> oh really, that's annoying
11:31:56 <Solonarv> I would've figured you could pattern-match and discover an equality just like with GADTs
11:31:58 <fen> anyway, they probably couldnt be used as "closed class declarations" like closed type families can, so there is probably no way to combine both of these things
11:32:43 <fen> to have both a constructor and a constraint (which requires the type synonym / no constructor type family thing)
11:33:27 <c_wraith> Solonarv: you have to treat them basically like a type family - that just always happens to point to type specifically created for it to point to.
11:33:35 <fen> Solonarv: no that would basically give a type error trying to infer the same thing was 2 different types
11:33:53 <Solonarv> I guess if you really need to discover an equality you could pair them with some kind of singleton
11:34:07 <Solonarv> (TypeRep would do the trick in modern GHC)
11:34:07 <fen> thats quite a complex idea to parse
11:34:19 <Boarders> asked earlier but didn't get a response, is there any way to get the name of a type out of the type?
11:34:36 <c_wraith> If you want a closed type-indexed type, you should be using a GADT.
11:34:37 <fen> you stated the answer alongside that question
11:34:43 <Solonarv> Boarders: a few, what form do you have the type in?
11:34:50 <Solonarv> c_wraith: who said I want it to be closed?
11:34:51 <Zemyla> So the library submissions page seems to be obsolete some https://wiki.haskell.org/Library_submissions
11:35:24 <c_wraith> Solonarv: well, fen was talking about created a closed class...
11:35:24 <Zemyla> Do I submit issues about Array here? https://gitlab.haskell.org/ghc/packages/array
11:35:26 <Boarders> Solonarv: I want it so I can pass something like myFunc ["Any"] @Any but I would like to just get the Any automatically
11:35:53 <fen> c_wraith: it was because closed type familes were being used to be like a GADT except without the constructors
11:36:15 <Solonarv> you can use 'typeOf' to get (a representation of) the type of a value, and you can 'show' that
11:36:20 <Solonarv> > typeOf "hello"
11:36:22 <lambdabot>  [Char]
11:36:22 <c_wraith> fen: sure, but when you want to add the constructors in, go to a GADT, not a data family. :)
11:36:29 <fen> and that by having them return constraints they were like a class, so being able to "match" of the constructors...
11:36:59 <fen> c_wraith: yeah, and that doing so means it isnt like a class anymore
11:37:07 <Boarders> Solonarv: thanks I'll give it a think
11:38:22 <fen> the original problem was just to try and constrain some type to be a specific datatype, and this was to try and get a GADT to be like *all the instances* of a class
11:39:33 <fen> because of the difficulty in encoding some things as classes, like Either
11:39:39 <MarcelineVQ> I think that's called a universe
11:42:31 <fen> compare; https://pastebin.com/raw/Ysazehxi to https://pastebin.com/raw/GTvkhbfc
11:43:14 <nshepperd_> Solonarv: yeah the problem is because data families are open there's no common 'space' for the constructor tags. You need something like typeable to use compiler magic to make a global space
11:43:25 <fen> State turns from a GADT to a closed type family...
11:43:57 <Solonarv> yeah, makes sense
11:44:14 <fen> with is then used to "constrain all the values of a type level list to be states"
11:44:30 <fen> MarcelineVQ: is that a valid way of doing a "universe" ?
11:47:02 <MarcelineVQ> tbh I'm still trying to figure out what all a universe entails, but the notion of a gadt that contains all the types you want to work with sure sounds like it fits
11:47:14 <fen> right yeah
11:47:19 <fen> a GADT basically does it
11:47:30 <fen> but then there is just the problem of stating it as a constraint
11:48:33 <nshepperd_> I could imagine a ghc extension which would define a 'typeable data family' variation which would automatically generate Typeable instances for each data family instance, and insert the typerep comparisons
11:49:03 <fen> the only problem with using a closed type family to return () :: Constraint to emulate a "closed class" is that it needs to be defunctionalised to create instances over, but not really sure if thats a problem, but did wonder if that would mean closed data families might help...
11:49:14 <fen> probably totally confused anyway, nvm
11:49:41 <nshepperd_> Dunno what such a feature would be good for though
11:50:18 <fen> maybe its something like "partial type constructors" https://cs.brynmawr.edu/~rae/papers/2019/partialdata/partialdata.pdf
11:52:03 <fen> basically its just to constraint things - not sure if there is a batter example than in the paste, but that was a type level list where instead of writing [* -> * -> *], which could be anything, you have to kind of get at the values of kind * -> * -> * and constrain them, and the solution was to fold over xs :: [* -> * -> *] to return a constraint 
11:52:43 <fen> saying "each of the values of kind * -> * -> * is actually a State..." where State is just *something* with that kind
11:53:02 <fen> hence "partial" and not total
11:53:28 <fen> basically just giving kind annotations isnt restrictive enough because it allows everything of that kind, instead of just something of that kind
11:54:19 <quakenet> Hi all good server your all invited * IRC quakenet ORG  *
11:55:30 --- mode: ChanServ set +o monochrom
11:55:35 --- mode: monochrom set +b *!*@88.248.51.239
11:55:35 --- kick: quakenet was kicked by monochrom (quakenet)
11:55:53 --- mode: monochrom set -b *!*@88.248.51.239
11:55:58 --- mode: monochrom set -o monochrom
12:02:54 <fen> also it seems to be complicated by the idea that the Constructors themselfs are being refered to as the values of the typelevel list, and its only by construction that these have the same kind...
12:05:09 <fen> im sorry its a really bizzare piece of code but otherwise its seemingly impossible to express State as it does
12:05:59 <fen> cant really understand the paradigm its getting at
12:10:57 <AWizzArd> I would like to try out VSCode. When I am looking at the extensions under the tag "haskell" I am seeing tons of them.
12:11:30 <AWizzArd> I will likely need the „Haskell Language Server” from alanz, but what else? Something for syntax highlighting?
12:12:39 <Solonarv> AWizzArd: you have a few backends to choose from, actually; I don't think LSP is necessarily ideal
12:13:47 <Solonarv> I like vscode-ghc-simple or haskell-ghcid because they're simple and don't require installing seventy different versions of some backend engine
12:14:24 <Solonarv> for syntax highlighting I use language-haskell
12:15:14 <AWizzArd> Solonarv: okay I see.
12:17:20 <monochrom> The IDE landscape of Haskell is still in poor shape.  (I'll explain in what sense later.)  Because of this, less ambitious plugins are more robust.
12:17:45 <AWizzArd> I am mostly used to Intero and Emacs. Just out of curiosity I would like to try some other IDE.
12:18:04 <AWizzArd> I just introduced Haskell in my department and am looking for something that my devs may like.
12:18:28 <AWizzArd> Haskell _and_ Emacs in one go might be too much of the good stuff.
12:18:47 <monochrom> The way the landscape is in poor shape is this.  Any non-dumb implementation uses GHC-API, which suffers the same problem as ghci: Whenever you have a compiler error, all information is lost.
12:19:23 <AWizzArd> monochrom: all information as in: state in the repl?
12:19:33 <monochrom> Yes. Names and types.
12:19:50 <AWizzArd> monochrom: in Lisp for example I can create some vars/state, add new functions, get errors, walk through the debugger, etc.
12:20:14 <AWizzArd> monochrom: In Intero I can also build up state. But one single new compile in Intero means that all info is lost. I need to do it in the code, in a test file instead.
12:20:29 <monochrom> Thumbs up to most (even all) Lisp implementations! But GHC doesn't do that.
12:20:42 <AWizzArd> Right.
12:21:10 <AWizzArd> So I now tend to introduce one „play around” file, do the stuff there that I would like to do in the repl and compile&load this into ghci.
12:21:11 <monochrom> This can actually be worked around, wihout changing GHC any bit.  Two-phase commit.
12:22:02 <AWizzArd> monochrom: I can understand the motivation though. If I have a defclass in CL, create an instance and then change the class definition (adding/removing slots) then in my repl I still have the outdated object.
12:22:28 <AWizzArd> In Haskell it would be completly lost. If I keep it in my playground file though I need to update the definition there before I can continue interacting in the repl.
12:23:29 <monochrom> So this is why I don't use tight integrations such as Intero or ghc-mod.  I use loose integrations like emacs's haskell-mode.  I mean this: When I save, do not auto-reload.
12:23:51 <AWizzArd> Okay, so your repl still sees the old stuff.
12:24:08 <AWizzArd> But: it would at the same time not see the new stuff, the changes that you edited, right?
12:24:20 <monochrom> This means now I can do my own two-phase commit meaningfully.  I run ghcid in the background.  I save, ghcid tells me "good" or "bad".  Only when "good" do I tell haskell-mode to reload.
12:24:55 <monochrom> Well yeah I have to be more fine-grained and/or more temporary "foo = undefined".
12:25:31 <AWizzArd> More control, less automation/comfort.
12:25:39 <tdammers> GHC-API suffers another problem: the "API" is really just "GHC's internal data structures, but exposed", and it is subject to changing between GHC versions, even minor, and without prior warning
12:26:10 <monochrom> Yeah intero and ghc-mod implies installing 70 copies of GHC. :)
12:26:16 <tdammers> there are plans (and a lot of wishful thinking) to change that, but so far, they're mostly just that, plans.
12:26:36 <monochrom> Time for my economics-of-research quip again.
12:27:10 <AWizzArd> monochrom: what do you mean by that? Does this have to do with Stack or Intero? Per project one GHC right? But isn’t this cached in compiled form once, in Stack’s main local repo?
12:27:15 <tdammers> I was about to say - part of the reason this isn't happening faster is because core GHC development is funded through sources that don't have a particularly strong interest in this particular area
12:27:17 <monochrom> People have huge incentives to add dependent typing that nobody needs, and no incentive to add non-lossy reload that everybody is waiting for.
12:27:36 <Solonarv> nothing to do with stack, really
12:27:44 <monochrom> Because, like, can't publish a paper just for "I got GHC to reload losslessly".
12:28:13 <Solonarv> stack helps avoiding some number of unnecessary reinstalls, but it doesn't fix the underlying problem
12:28:23 <tdammers> this wouldn't have to come from academia; it's just that nobody is putting enough of their money where their mouths are in the "industry" either
12:29:01 <monochrom> Solonarv: Are you telepathic?  I certainly had stack in mind, but I didn't say it out loud. :)
12:29:13 <tdammers> in fact, I'm pretty sure if someone were to step forward and fund it, it would be absolutely no problem finding someone to do it
12:29:17 * hackage attoparsec-data 1.0.4 - Parsers for the standard Haskell data types  https://hackage.haskell.org/package/attoparsec-data-1.0.4 (NikitaVolkov)
12:29:41 <nshepperd_> Troll solution: enable -fdefer-type-errors in IDE integration tools
12:29:45 <AWizzArd> monochrom: but how to reload safely? In the Common Lisp (and Clojure and Scheme) style? That would mean that my outdated type still hangs around, which is missing a required field after a reload.
12:30:15 <monochrom> nshepperd_: But I also make tons of syntax errors.
12:30:31 <Solonarv> nshepperd_: that's not even a bad idea, though
12:30:59 <nshepperd_> monochrom: yeah i got nothing for that
12:31:15 <AWizzArd> monochrom: we could have a  `data User = U {name: Text, age: Int}`  and create a value of it in the repl. Then update our code to   `data User = U {name: Text, age: Int, email: Maybe Text}`. What will happen now?
12:31:40 <Solonarv> AWizzArd: try doing all this in the REPL directly
12:31:42 <AWizzArd> monochrom: despite the fact that an existing User would still be valid, because the `email` field is optional. But this is an orthogonal issue.
12:31:58 <monochrom> AWizzArd: I think Lisp and SML people are used to that.  I think the harder question is: I have 100 lines (let's say all new/changed) and only 1 line has a typo.  When I reload, should I still get the other 99 lines?  How to do this?
12:32:25 <tdammers> I don't think just copying the Lisp way of doing this would even work, considering how GHC works
12:32:37 <Solonarv> basically, what happens is that the new definition gets a sneakily different name, so your value is still referring to the old type definition which is also still hanging around
12:32:52 <Solonarv> (although you can't access it because you can't write its name anymore)
12:33:06 <Solonarv> same deal if you redefine a function, a typeclass, whatever
12:33:28 <AWizzArd> monochrom: after 15 years of Lisp I _am_ used to this behaviour in Lisp. What Haskell would need is to keep two different data types around, both having exactly the same name `User`, while being two different things.
12:33:41 <monochrom> Lisp is far away, but SML does this too.  SML is much closer to Haskell.
12:33:45 <AWizzArd> I think it is mostly inacceptable for Haskellers to accept.
12:34:09 <AWizzArd> What would SML do in this case? What if we change the type of a field or remove it?
12:34:14 <nshepperd_> Convert the types replacing new fields with undefined
12:34:37 <AWizzArd> nshepperd_: how to convert?
12:34:57 <monochrom> Like what all of you have said.  Old value and old types hang around; old types get different name so the name goes to the new type.
12:35:22 <AWizzArd> Idris supports the `cast` method, which is a generalization of Haskell’s `read`. Such a tool might help for converting perhaps.
12:35:24 <monochrom> SMLers are used to this, too.
12:35:33 <nshepperd_> AWizzArd: Serialise / deserialise probably
12:35:38 <Solonarv> AWizzArd: Haskell *already does that* (keeping two different types around), if you define them directly in GHCi
12:36:09 <Solonarv> there isn't a way to name any definition other than the latest, but in principle this could be changed
12:36:24 <AWizzArd> Solonarv: can you give a minimal code example that I can try out in ghci that demonstrates this?
12:36:38 <Solonarv> I'll demonstrate it right here!
12:36:45 <AWizzArd> Yes, please :-)
12:36:56 <Solonarv> % data User = User { name :: String, age :: Int } deriving Show
12:36:56 <yahb> Solonarv: 
12:37:12 <Solonarv> % myUser = User "John Doe" 42
12:37:12 <yahb> Solonarv: 
12:37:37 <Solonarv> % data User = User { name :: String, age :: Int, email :: Maybe String } deriving Show
12:37:37 <yahb> Solonarv: 
12:37:40 <Solonarv> myUser
12:37:45 <Solonarv> % myUser
12:37:45 <yahb> Solonarv: User {name = "John Doe", age = 42}
12:37:47 <nshepperd_> Making ghc resistant to syntax errors seems harder
12:37:48 <Solonarv> % :t myUser
12:37:48 <yahb> Solonarv: Ghci46.User
12:38:06 <nshepperd_> I think ekmett talked about this once
12:38:08 <Solonarv> % :k Ghci46.User -- sadness
12:38:09 <yahb> Solonarv: Ghci46.User -- sadness :: *
12:38:15 <Solonarv> :O
12:38:25 <monochrom> :D
12:38:33 <Solonarv> % jane = Ghci46.User "Jane Doe" 24
12:38:33 <yahb> Solonarv: 
12:38:36 <Solonarv> !!
12:38:45 <Solonarv> well, color me surprised
12:38:46 <monochrom> Wow GHC is ahead of SML!
12:38:59 <Solonarv> you can refer to shadowed definitions already!
12:39:07 <monochrom> What did ekmett say?
12:39:51 <nshepperd_> There's that one parsing rule in the haskell report that specifies something to happen on parse failure
12:40:03 <nshepperd_> Brace insertion i think?
12:40:19 <nshepperd_> Which makes recovering from errors annoying
12:41:00 <monochrom> Yeah insert } to fix parse errors.
12:41:16 <nshepperd_> Ideally the compiler would indeed have -fdefer-syntax-errors though
12:41:49 <monochrom> https://mail.haskell.org/pipermail/haskell-cafe/2019-March/130862.html  >:)
12:43:43 <monochrom> OK I have more errors in my sleeve.  How about import errors?  "import Foo.Foo.Foo" but Foo.Foo.Foo doesn't exist.
12:44:36 <ski> % let foo = Ghci73.foo
12:44:36 <yahb> ski: ; <interactive>:150:11: error:; Not in scope: `Ghci73.foo'; Perhaps you meant one of these: `Ghci63.foo' (imported from Ghci63), `Ghci71.foo' (line 145), `Ghci51.foo' (imported from Ghci51); No module named `Ghci73' is imported.
12:45:01 <geekosaur> there at least used to be -fdefer-all-errors
12:45:06 <geekosaur> I think it proved problematic though
12:45:36 <monochrom> It is really hairy either way.
12:45:57 <AWizzArd> si
12:47:22 <monochrom> But IMO the least we could do is "don't lose the previous load". Although this doesn't add the good stuff from the new-but-failed load, at least it is a workable convention we can get used to.
12:47:50 <monochrom> Like dude two-phase commit is a solved problem.
13:30:06 <Boarders> is there a reason NonEmtpy doesn't have a Field1 instance from lens?
13:30:11 <Boarders> NonEmpty
13:31:28 <Solonarv> I think those are only for tuples
13:31:49 <Boarders> what are you meant to do with NonEmpty
13:31:53 <Boarders> barring write your own lens
13:32:15 <Solonarv> it's a Traversable, Applicative, and a ton of other stuff
13:32:34 <Boarders> oh yeah I just want to write a lens and use the head of the list with it
13:32:40 <Boarders> and was hoping for something out of the box
13:32:48 <c_wraith> Yeah, it can't be an instance of Cons, either
13:32:52 <Boarders> especially as lens has _head which is unsafe
13:33:20 <Solonarv> % :t _head
13:33:21 <yahb> Solonarv: (Cons s s a a, Applicative f) => (a -> f a) -> s -> f s
13:33:26 <Solonarv> that's not unsafe
13:33:36 <c_wraith> but it doesn't work with NonEmpty
13:33:40 <c_wraith> the types don't line up
13:33:43 <Solonarv> indeed
13:34:14 <Boarders> oh it is not a lens
13:34:16 <Boarders> my bad
13:34:20 <Boarders> Lens*
13:34:26 <Solonarv> wait, no - the types totally line up?
13:34:42 <Boarders> "A lens reading and writing to the head of a non-empty list.  Attempting to read or write to the head of an empty list will result in an error. "
13:35:05 <Solonarv> hm, outdated perhaps?
13:35:16 <c_wraith> Solonarv: Well...  If you line the types up, you are forced to make "uncons (x :| [])" return Nothing
13:35:28 <Boarders> this is from
13:35:33 <Solonarv> ah, hm
13:35:34 <Boarders> Data.List.Lens
13:35:34 <c_wraith> Solonarv: So I guess the types do line up, but they're not any good.
13:35:42 <Boarders> but an old version
13:35:46 <Solonarv> Boarders: ah, that makes sense
13:36:08 <Solonarv> lens-4.17:Control.Lens.Cons properly describes _head as a Traversal
13:38:17 <Boarders> ok makes sense
13:38:34 <Boarders> I think NonEmpty could have an instance for Field1 though
13:38:44 <Boarders> but I'm not sure if that would be considered in bad taste
13:39:08 <c_wraith> It could be.  And...  I wouldn't argue against it.
13:39:16 <c_wraith> I wouldn't really argue for it, either.
13:46:51 <Boarders> oh actually I now understand what Solonarv was complaining about because it would only make sense for Lens' (NonEmtpy a) a
13:46:55 <Boarders> *
13:47:14 <c_wraith> Oh, that is an obstacle
13:48:54 <Solonarv> yeah I don't think there is a super clean way within 'lens' to express non-emptiness of NonEmpty
13:50:13 <Solonarv> I suppose we could define
13:50:14 <Solonarv> nonEmptyElems :: forall f. Apply f => LensLike f (NonEmpty a) (NonEmpty b) a b
13:50:29 <Solonarv> (Apply is "Applicative without pure", defined in semigroupoids)
13:50:52 <c_wraith> All you really need is a Iso between NonEmpty a and (a, [a])
13:51:00 <Solonarv> yeah, that works too
13:51:55 <c_wraith> I think it'd be reasonable to create Data.List.NonEmpty.Lens and throw that in.
13:52:10 <c_wraith> I think it just hasn't been done since NonEmpty was added to base.
13:52:17 <Solonarv> yeah
13:52:21 <c_wraith> (If I was less lazy, I'd go ahead and do it)
13:52:53 <Solonarv> I wonder if there's anything useful we can do with an 'Apply' optic that we can't with a Traversal
13:53:51 <Solonarv> well, we can make a safe ^?!
13:54:35 <Solonarv> safeHead l = getFirst . getConst . l (Const . First)
13:54:46 <Solonarv> (First from Data.Semigroup)
13:55:50 <Solonarv> theoretically there is an instance Semigroup w => Apply (Const w) which makes this work
14:04:17 <phadej> :t firstOf1
14:04:18 <lambdabot> error:
14:04:19 <lambdabot>     • Variable not in scope: firstOf1
14:04:19 <lambdabot>     • Perhaps you meant one of these:
14:04:21 <phadej> :first1Of
14:04:24 <phadej> :t first1Of
14:04:25 <lambdabot> Getting (Data.Semigroup.First a) s a -> s -> a
14:04:49 <phadej> > firstOf1 folded1 ('x' :| "yz")
14:04:51 <lambdabot>  error:
14:04:51 <lambdabot>      • Variable not in scope: firstOf1 :: t0 -> t1 -> t
14:04:51 <lambdabot>      • Perhaps you meant one of these:
14:04:55 <phadej> > first1Of folded1 ('x' :| "yz")
14:04:57 <lambdabot>  error:
14:04:57 <lambdabot>      • Variable not in scope:
14:04:57 <lambdabot>          folded1 :: Getting (Data.Semigroup.First a) s0 a
14:05:06 <phadej> > first1Of traverse1 ('x' :| "yz")
14:05:08 <lambdabot>  error:
14:05:08 <lambdabot>      • Data constructor not in scope: (:|) :: Char -> [Char] -> t0 a
14:05:08 <lambdabot>      • Perhaps you meant one of these:
14:05:11 <phadej> :(
14:05:15 <phadej> screw you, lambdabot
14:05:18 <phadej> % first1Of traverse1 ('x' :| "yz")
14:05:19 <yahb> phadej: 'x'
14:05:28 <phadej> % first1Of traverse "xyz"
14:05:29 <yahb> phadej: ; <interactive>:153:10: error:; * No instance for (Monoid (Data.Semigroup.First Char)) arising from a use of `traverse'; There are instances for similar types: instance Monoid (First a) -- Defined in `Data.Monoid'; * In the first argument of `first1Of', namely `traverse'; In the expression: first1Of traverse "xyz"; In an equation for `it': it = first1Of traverse "xyz"
14:05:48 <phadej> safeHead is there already
14:06:28 <phadej> also
14:06:46 <phadej> % ('x' :| "yz") ^. _Wrapped
14:06:46 <yahb> phadej: ('x',"yz")
14:07:05 <phadej> is Iso' (NonEmpty a) (a, [a])
14:07:19 <phadej> c_wraith, Solonarv ^
14:09:42 <Solonarv> oh, nice
14:43:40 <AWizzArd> Is there some way of doing „C style serialization” in Haskell? That is: I have my value (in C „instance of a struct”) and want to access its raw byte representation, in the most efficient way.
14:47:41 <jle`> AWizzArd: there are some issues with that.  the raw byte representation might not be consistent, i think
14:47:53 <jle`> but for those that 'are', we have the Storable typeclass
14:49:01 <jle`> there's also the "compact regions" feature, that lets you write out a data type as raw binary and load it later
14:49:33 <jle`> but it does that by using the RTS represenation, so like preserving the raw pointers and stuff
14:59:17 <lucorecio> !list
14:59:17 <monochrom> lucorecio: http://lpaste.net/browse
14:59:37 <ski> ciao a tutti ?
15:03:43 <LRB> I have another question. I'm reading through "Learn you a Haskell for a great good" and it's wonderful. I came across the term "singleton list" but it's never defined. In fact, the only time the word "singleton" is used in the book is in context of singleton lists. I did some DDG-ing but I'm struggling to really find information on it. What exactly is a singleton list and how does it differ from a regular list? Is it related to the singleton
15:04:24 <LRB> For that matter, is it only related to lists or are there other singleton types in haskell?
15:05:26 <LRB> I hope my client doesn't disconnect. I don't have an IRC bouncer and I have particularly poor internet here.
15:05:33 <Solonarv> don't read too much into it, it's just a term used for "a list that happens to have just one element"
15:09:11 <ski> similarly, occasionally, a list with two elements could be called a "dupleton"
15:10:19 * Solonarv has never heard that used
15:10:37 <ski> "singleton" is more common, for sure
15:20:04 <jle`> LRB: singleton there refers to a list with a single item
15:22:01 <jle`> so it isn't really a different "type", it's just an adjective to describe some lists
15:22:36 <jle`> maybe not 'singleton list', which implies a distinct type, but 'a singleton value of the list type'
15:25:11 <mpickering> Can anyone think how to interrupt a running function based on an external trigger? 
15:25:28 <mpickering> I'm thinking of something like forkIO and throwTo
15:25:38 <Solonarv> yeah, that's what I was going to suggest
15:25:48 <Solonarv> you could use async to make this a bit nicer
15:26:34 <Solonarv> worker <- async . evaluate . force $ someBigComputation;
15:26:34 <Solonarv> -- when external trigger fires:
15:26:34 <Solonarv> cancel worker
15:27:11 <mpickering> What are the types like there? What is the point of force and evaluate? 
15:27:13 <AWizzArd> Anyone here who experimented with Haskell apps that have a huge amount of live data in RAM? Like tens of gigabytes? Is this still running fine or do you already tried this and saw the GC times are really bad?
15:27:27 <mpickering> What happens if you don't use the threaded runtime? 
15:28:14 <Solonarv> force :: NFData a => a -> a; force x = rnf x `seq` x -- when 'force x' is in WHNF, all its parts are also in WHNF
15:28:50 <Solonarv> evaluate :: a -> IO a forces its argument and returns it
15:29:29 <Solonarv> found in deepseq:Control.Deepseq and base:Control.Concurrency, respectively
15:29:33 <mpickering> OK right but I don't need that if I already have an IO action
15:29:45 <Solonarv> oh, of course
15:30:04 <Solonarv> for some reason I was assuming you wanted to interrupt a big pure computation
15:30:25 <Solonarv> (in that case 'evaluate . force' is the right song-and-dance to make sure the worker thread actually does th work)
15:30:46 <Solonarv> if it's already IO you could even use: race bigComputation waitForExternalTrigger
15:31:09 <mpickering> OK thanks these are good leads
15:31:39 <mpickering> I think I need to work out how MonadBaseControl works first and then come back to this
15:32:09 <Solonarv> eeeep! 
15:32:14 <Solonarv> MonadBaseControl is scary
15:32:21 <Solonarv> MonadUnliftIO is much friendlier IMO
15:38:29 <jle`> monadbasecontrol is deprecatedish, but also most application writers wouldn't have to work directly with it
15:38:34 <jle`> or monadunliftio either
15:41:22 <mpickering> lifted-async is defined in terms of MonadBaseControl 
15:41:59 <mouse07410> Help with ghcup please. MacOS. "ghcup install 8.6.3" fails on step 230 of 236 on attempt to load shared library libgmp.10.dylib  from brew-specific location (instead of where it is on my system). Error "image not found" - of course
15:43:38 <mpickering> jle`: what other option are you suggesting? 
15:44:06 <jle`> mpickering: yeah, you should just be able to use lifted-X with MonadBaseControl or MonadUnliftIO
15:44:16 <jle`> instead of having to directly understand MonadBaseControl :)
15:44:42 <mpickering> I need to define the instance still
15:45:12 <glguy> mouse07410: https://gitlab.haskell.org/ghc/ghc/issues/15404 something like this?
15:45:23 <mouse07410> Must add that 8.6.3 and 8.6.4 got installed just fine. But HIE apparently requires 8.6.2 no matter what.
15:45:53 <glguy> mouse07410: In your original question you specified 8.6.3, did you mean 8.6.2?
15:46:59 <mouse07410> glguy: yes that seems to be the issue. Yes, the problem is with 8.6.2.
15:47:03 <mpickering> Hie works with 8.6.3 and 8.6.4
15:47:12 <glguy> mouse07410: That issue was resolved in the 8.6.3 release notes
15:47:25 <jle`> mpickering: having to define an instance means you might be running into some odd use cases
15:47:27 <mpickering> You need to have built hie with 8.6.4
15:47:43 <mpickering> jle`: why is that? 
15:47:58 <mpickering> The stack is two normal ReaderT
15:48:16 <mpickering> And the GHC monad which is another Reader like thing
15:48:22 <mpickering> And IO at the bottom
15:48:57 <mpickering> So probably I just have to define it for the GHC monad and it will work
15:49:09 <jle`> from the application level, the idea is that the monads you use would already have instances
15:49:37 <jle`> ah, i see
15:50:11 <jle`> yeah, defining instances is the tricky part that the library tries its best to hide from the application level
15:51:02 <mouse07410> mpickering: I'd love to - but hie fails to build even with 8.6.4 (and 8.6.3). README.md guidance seems insufficient. Again, this is on MacOS.
15:51:39 <mouse07410> glguy: wouldn't it make sense to backport the fix...?
15:55:55 <glguy> mouse07410: backport it to what?
15:56:22 <glguy> 8.6.3 is the fixed version of the 8.6 compiler
15:56:41 <glguy> (for that bug)
16:00:08 --- mode: ChanServ set +o glguy
16:00:08 --- mode: glguy set -zo glguy
16:03:18 <mouse07410> Glguy To 8.6.2
16:03:50 <glguy> When fixes are backported to GHC it bumps the 3rd number
16:04:49 <mouse07410> Because, as I said, hie build process Skywars to download 8.6.2 regardless. Not that I really want 8.6.2 - just trying to get that blasted hie build in that blasted Haskell ecosystem... :-(
16:05:17 <mouse07410> ^Skyward ->? attempts
16:26:27 <hololeap> i'm going through the introduction to singletons, and i'm wondering how to write lockAnyDoor_ without referring to lockAnyDoor: http://dpaste.com/2MFVMYN
16:27:13 <hololeap> it doesn't seem to like `lockAnyDoor_ d = case singDS of ...`
16:29:53 <Cale> hololeap: You might be able to use ScopedTypeVariables to insist that you're pattern matching on a singDS :: SingDS s of the appropriate type to match the Door s
17:01:23 <zzz> what would be the most efficient data structure for storing 2d grids as iterations of some cellular automata? (meaning a lot of accesses based on position)
17:02:44 <zzz> i'm looking at Data.IntMap.Strict
17:03:18 <dmwit> zzz: http://www.drdobbs.com/jvm/an-algorithm-for-compressing-space-and-t/184406478
17:03:25 <Cale> If the cells which are "on" are quite sparse, you *might* get away with IntMap as an option, but I would probably looking at some sort of array type first.
17:03:54 <dmwit> (This approach is not most efficient in programmer time. But that didn't appear to me to be the question. =)
17:04:22 <shachaf> Hashlife is TG.
17:04:44 <dmwit> hashlife is life
17:20:55 <jle`> 💤 i usually use IntMap, it's pretty good for sparseness. 
17:21:01 <jle`> or just Map (Int, Int)
17:21:55 <dmwit> jle`: Which client do you use so I know to never switch to it
17:22:08 <jle`> hololeap: -XScopedTypeVariables is a way, but you can also get away with some helper functions
17:22:17 * DigitalKiwi was just thinking how annoying everyone using emoji on irc is
17:22:19 <jle`> dmwit: heh, it's not my client, it's an extension i have enabled
17:22:35 <jle`> i thought it would help me be more expressive
17:23:01 <DigitalKiwi> [01F\n4A4]
17:23:04 <DigitalKiwi> that's what we see
17:23:17 <jle`> that sounds like a client issue ;)
17:23:22 <mud> What you see depends on your client and your font
17:24:03 <mud> It's not quite jle`'s fault that you font doesn't have emoji glyphs, hehe.
17:24:58 <DigitalKiwi> why would i want emojis in a terminal?
17:25:23 <jle`> hololeap: you can have a helper function like `mkSing :: SingDSI s => p s -> SingDS s; mkSing _ = singDS`, then you could write `lockAnyDoor_ d = case mkSing d of SOpened ..., etc.
17:25:24 <LRB> ski: thanks for answering my question a few hours ago. It makes so much more sense now lol.
17:25:31 <dmwit> DigitalKiwi: So you can see jle`'s messages, duh.
17:25:32 <jle`> DigitalKiwi: presumably the same reason you'd want emojis on any platform
17:25:55 <mud> Because they're a compact and fun way to express certain ideas.
17:25:57 <DigitalKiwi> why would i want emojis? 
17:26:12 <dmwit> ski++ for helping LRB and to make ski squirm
17:26:33 <jle`> there are some benefits in expressivity
17:26:38 * ski strains to keep a calm face
17:28:55 <zzz> zero benefits in seeing my mention like that though
17:29:10 <nshepperd> i find ascii emoticons more expressive usually
17:29:29 * ski grumbles about they not thanking Solonarv or jle`
17:29:32 <nshepperd> emoji are too dependent on the ideosyncrasies of the platform/font
17:29:44 <ski> .. kids these days
17:30:01 <Axman6> IS there a way to make this work? With HasResolution from Data.Fixed, and KnownNat, Nat etc. from GHC.TypeLits, I'm Trying to write instance KnownNat n => HasResolution n where resolution = natVal, but get the error "Expected a type, but ‘a’ has kind ‘Nat’"
17:30:02 * ski . o O ( and they're called "smileys" )
17:30:10 <zzz> dmwit: thanks im taking a look
17:30:17 <nshepperd> hah
17:30:18 <DigitalKiwi> ski: *chortle*
17:30:50 <mud> Probably most of them don't have anything to do with faces anymore, so "smileys" sounds odd.
17:31:19 <DigitalKiwi> nshepperd: also they're not as universal as people think, "WHAT DID THEY MEAN BY THAT :) IS THAT A GOOD OR A BAD :)"
17:31:28 <jle`> Axman6: check if HasResolution is PolyKinded
17:32:08 <jle`> Axman6: if not, you can wrap it in some singleton-like thing
17:32:09 <Axman6> class HasResolution a where resolution :: p a -> Integer; doesn't look like it
17:32:13 <jle`> or just literally a singleton, heh
17:32:25 <jle`> Axman6: that declaration looks like it should be poly-kinded if -XPolyKinds is enabled in the module
17:32:36 <dmwit> Axman6: KnownNat n => HasResolution (Proxy n)
17:32:40 <dmwit> Axman6: Or similar.
17:32:48 <mud> DigitalKiwi: That's just all of communication
17:32:58 <nshepperd> DigitalKiwi: or the unicode emoji which is a water pistol on Apple devices and an actual pistol everywhere else...
17:33:10 <Axman6> trying to be able to write Fixed 3 instead of needing Fixed E3
17:33:16 <DigitalKiwi> similiarly 'lol' and related is just as ambiguous and easily misunderstood
17:33:25 <Axman6> Lots of love
17:36:48 <dmwit> Axman6: With `unwrap :: p (Proxy a) -> Proxy a; unwrap _ = Proxy` you can write `instance KnownNat n => HasResolution (Proxy n) where resolution = natVal . unwrap`.
17:37:21 <dmwit> Don't forget to turn on PolyKinds so that it doesn't mistakenly assume `a :: *` in the type signature for `unwrap`.
17:37:22 <DigitalKiwi> mud: yes. and emoji don't help solve that; they make it worse
17:39:06 * ski idly recalls hearing some pronounce "lol" out loud
17:39:26 <nshepperd> unicode emoji make it worse, because there's no guarantee that what the other person sees is the same as what you wrote
17:40:21 <nshepperd> ascii emoticons and smileys like :) may not be perfectly clear, but at least they don't get corrupted in transit by choice of font
17:40:45 <shachaf> ASCII art gets corrupted by proportional fonts all the time.
17:42:05 <dmwit> And even in the world of monospace fonts the height of = and : vary a lot, so that =) can look much different and wronger in some fonts.
17:42:23 <nshepperd> if they're multiple lines. but that's still better because they end up looking like nonsense instead of a totally different message
17:42:29 <dmwit> (...than in the font I use, which is obviously the best choice.)
17:43:45 <DigitalKiwi> clearly the best font is that stupid curly one that all girls that post pictures of text messages use
17:52:12 <jackdk> nah mate, the best font is this one: http://int10h.org/oldschool-pc-fonts/fontlist/#ibm_vga9
17:55:21 <DigitalKiwi> how did you know what font i use
17:56:45 <jackdk> because it is the best font, duh
17:57:32 <Zemyla> The best font is Font of Mythos, because it draws you two cards every turn.
17:58:50 <DigitalKiwi> no lies detected.gif
18:28:00 <cht> Does #haskell-stack no longer exist? Where is the best place to ask dependency nightmare questions? 
18:29:34 <Cale> Here will do
18:32:09 <Cale> cht: What problem are you having?
18:32:38 <cht> Okay thanks! I'm trying to use stack to install/use typed-spreadsheets. When it compiles the dependency pango (0.13.5.0) it errors out because of deprecations 
18:34:01 <Cale> hmm
18:34:07 <Cale> It's marked as broken in nix as well
18:36:21 <cht> Hmmm I might be misreading the error. I think the deprecations are non-fatal warnings. Looks like the package pangocairo may be missing? 
18:39:23 <tsizz> Hi. is there a way to import System.Random without stack
18:39:27 <tsizz> import it in normal ghci?
18:40:21 <Cale> It's in the random package, so you need to have that package installed in one way or another.
18:40:23 <nisstyre> tsizz: that doesn't work?
18:40:34 <nisstyre> do you have it installed with cabal or your OS package manager?
18:41:34 <tsizz> okay nvm i just downloaded stack and did stack ghci --resolver nightly --package random
18:43:37 <tsizz> okay nvm that doesn't work =)
18:44:27 <Cale> You could do  nix-shell -p 'haskellPackages.ghcWithPackages (pkgs: with pkgs; [ random ])'
18:44:37 <Cale> (and list any other packages you want there)
18:44:51 <tsizz> oh wait i put a ! and its working
18:45:17 <Cale> (you could also just cabal install it)
18:46:09 <DigitalKiwi> Cale++
18:47:05 <nisstyre> I only install xmonad and taffybar with cabal, and nothing else basically
18:47:23 <nisstyre> for everything else, stack works fine
18:47:30 <tsizz> ok thanks
18:47:47 <nisstyre> you can `stack build` and copy the binary to ~/.local/bin or whatever
18:56:59 <tsizz> if i want to read a text file line by line. do i use lines?
18:57:08 <tsizz> its just one word each line
19:00:23 <tsizz> im trying to decipher my error message
19:03:57 <nisstyre> tsizz: f <- readFile "/etc/hosts"; print $ lines f
19:04:22 <nisstyre> I'm guessing the "<-" part of that is confusing you?
19:04:33 <tsizz> nisstyre: so i did read my file and able to putStrLn f
19:05:01 <tsizz> i do want to make the read file into a list 
19:05:10 <nisstyre> :t lines
19:05:11 <lambdabot> String -> [String]
19:05:30 <nisstyre> :t readFile
19:05:31 <lambdabot> FilePath -> IO String
19:05:42 <nisstyre> put those two things together and you get a list of lines from a file
19:07:02 <tsizz> nisstyre: hm okay
19:07:13 <tsizz> if i want to print my list would i just do print instead of putStrLn?
19:07:24 <nisstyre> tsizz: depends how you want it printed
19:07:31 <nisstyre> do you want it to actually be printed line by line?
19:07:37 <nisstyre> or just print a representation of it?
19:07:58 <tsizz> either or, just wanted to check it was correct, but i think it is
19:08:34 <nisstyre> tsizz: well `print` is meant to print out a representation of a value that can be `read` back in
19:09:13 <nisstyre> > print [1,2,3]
19:09:15 <lambdabot>  <IO ()>
19:09:18 <nisstyre> ugh
19:09:26 <nisstyre> > read "[1,2,3]" :: [Integer]
19:09:28 <lambdabot>  [1,2,3]
19:09:33 <nisstyre> you get the point hopefully
19:09:52 <nisstyre> if you did putStr it just outputs the exact string
19:10:50 <tsizz> nisstyre: what do you mean read by in
19:10:56 <tsizz> can i safely use print just to output numbers>?
19:11:03 <tsizz> read back in*
19:11:53 <nisstyre> tsizz: I just mean that "read" and "print" are in some ways the opposite of each other
19:12:15 <nisstyre> if you do `print x` then you should be able to take that output and do `read x` and get back the same value
19:12:24 <nisstyre> assuming the compiler knows the type of it
19:13:03 <nisstyre> there's no actual guarantee that's the case because you could make an instance of Show for a type that doesn't respect that, but it's the case at least for [Integer]
19:13:46 <tsizz> nisstyre: okay cool.
19:14:01 <tsizz> im coming from imperative languages. can i treat print here the same way as print in like python or something
19:14:15 <tsizz> regarding output 
19:14:16 <nisstyre> tsizz: no, it doesn't do the same thing
19:14:20 <nisstyre> it's more similar to repr() in python
19:14:31 <nisstyre> putStrLn is like Python's print function
19:15:01 <tsizz> nisstyre: so if i want to print numbers then i have to make it a string?
19:15:05 <tsizz> output numbers*
19:15:17 <nisstyre> if you want to use putStrLn, then yes you do
19:15:29 <Hotbees> tsizz: print x = putStrLn (show x)
19:15:33 <nisstyre> :t putStrLn
19:15:34 <lambdabot> String -> IO ()
19:15:41 <Hotbees> show would be more accurate to call the opposite of read
19:15:44 <tsizz> :t print
19:15:45 <lambdabot> Show a => a -> IO ()
19:15:49 <nisstyre> > mapM_ putStrLn $ map show [1,2,3]
19:15:50 <lambdabot>  <IO ()>
19:16:01 <nisstyre> that's one way you could do it
19:16:15 <nisstyre> Hotbees: yeah true
19:16:31 <Hotbees> opposite of print I suppose would be readLn
19:16:36 <tsizz> so my understanding is if i want to use a variable then i have to use "let" 
19:16:47 <nisstyre> tsizz: nope
19:16:54 <nisstyre> let is just one way of binding variables
19:17:02 <nisstyre> you can just as well use functions to bind variables
19:17:19 <nisstyre> but that's maybe getting a bit too deep
19:18:19 <jusss> if f = \x -> \y -> x+y,   so what f(f(1)) = ?
19:18:39 <nisstyre> but basically you can think of these two things as roughly equivalent: let x = 12 in x * x, (\x -> x * x) 12
19:18:57 <nisstyre> those do the same thing but you didn't need let in the second one
19:19:12 <nisstyre> there is actually a subtle difference though wrt to types
19:19:29 <geekosaur> jusss, a type error, because the inner f(1) has type (Num a => a -> a), but the outer one expects (Num a => a)
19:19:37 <ski> jusss : a type error, probably
19:20:08 <geekosaur> 'f = \x -> \y -> x+y' is the same as 'f x y = x+y', it's looking for two parameters. give it one and you get back a partially applied function, looking for another parameter to complete it
19:20:20 <tsizz> nisstyre: i am setting variables in a do block
19:20:24 <tsizz> and compiler tells me maybe use let
19:20:29 <nisstyre> tsizz: I wouldn't think of them as "setting"
19:20:31 <tsizz> and i do that and it works, but i don't use in
19:20:39 <nisstyre> you're not actually mutating anything, you're just binding the names to values
19:20:50 <geekosaur> because do blocks allow a shorthand
19:20:53 <nisstyre> tsizz: yeah the syntax for do blocks with let is slightly different from the regular let syntax
19:20:54 <tsizz> nisstyre: so assigning is more accurate
19:21:00 <nisstyre> you don't need let blah = ... in ...
19:21:11 <jusss> geekosaur: ski ok
19:21:18 <ski> tsizz : "binding", not "setting"
19:21:18 <nisstyre> tsizz: ehhh, maybe but I would still call it "binding"
19:21:31 <tsizz> mhm but i mean just in my way of comparing it to imperative languages
19:21:47 <geekosaur> jusss, you also might want to lose the habit of saying things like f(1). precsely because of partial application. we don't say f(1)(2), we say (f 1 2)
19:21:58 <jusss> in js or python, I found it plus a function on a int
19:22:09 <geekosaur> becuase (f 1) is meaningful and gives us another function that can be applied, so we can also write that as ((f 1) 2)
19:22:34 <geekosaur> :t let f x y = x + y in f 1
19:22:35 <lambdabot> Num a => a -> a
19:22:38 <tsizz> nisstyre: would you mind looking at my few lines of code and see if its okay?
19:22:42 <ski> tsizz : "assign" suggests the possibility of reassignment, which is absent here. so "bind" is preferred. (`int n;' binds `n' to a mutable location, `n = 2;' assigns to that mutable location, the mutable location itself that `n' is bound to is not changed)
19:22:43 <nisstyre> tsizz: sure
19:23:12 <tsizz> nisstyre: https://pastebin.com/P3sVVsQi
19:23:22 * ski . o O ( "sure, i would mind" vs. "sure, i wouldn't mind" )
19:23:24 <geekosaur> :t map toUpper -- another partial application
19:23:25 <lambdabot> [Char] -> [Char]
19:23:35 <jusss> geekosaur: ok, f(f(1)) is same as f (f 1) ? or f $ f 1 ?  I'm just not sure, so I use f(f(1))
19:23:48 <ski> tsizz : you could replace the second `let' with three spaces
19:24:13 <geekosaur> it is f (f 1). but tis is still a type error, because f wants to see a number there and has been given a function
19:24:15 <tsizz> ski: as in binding 2 variables with one let statement?
19:24:29 <ski> tsizz : yes
19:24:41 <ski> tsizz : `putStrLn randomIndex' should probably be `print randomIndex' ?
19:25:31 <tsizz> ski: i commented that out
19:25:50 <ski> `print' call `show' on the input, which converts it to a String (a Haskell-representation of the value, specifically. not, in general, intended for pretty printing. but works here, since we know it's an `Int')
19:25:57 <nisstyre> tsizz: I would be carefuly with using !! because you don't always know whether your list has a value at that index
19:26:00 <nisstyre> *careful
19:26:02 <ski> tsizz : i know, that's why i commented on it
19:26:03 <nisstyre> in this case it looks safe
19:27:10 <ski> also, using `!!' (random access) is inefficient, on a list (being singly-linked list). if you want random access, you could try an array, or some other data structure. but for learning the ropes, it works
19:27:16 <nisstyre> and yeah you don't need the two `let` blocks, you can do it with one
19:27:23 <nisstyre> just make sure to indent properly
19:27:51 <ski> multiple bindings inside a `let', must be aligned with each other (the start of them, i.e.)
19:27:56 <tsizz> so is print just putShowLn (show input)
19:28:03 <ski> just like multiple commands in a `do' must be aligned with each other
19:28:03 <tsizz> yeah i got that double bind working
19:28:06 <nisstyre> putStrLn you mean?
19:28:06 <ski> tsizz : yes
19:28:09 <nisstyre> yep
19:28:12 <ski> @src print
19:28:12 <lambdabot> print x = putStrLn (show x)
19:28:20 <ski> it's literally that
19:28:45 <tsizz> so print and putStrLn are both outputting like a print in python?
19:28:52 <tsizz> it seems like you said otherwise
19:29:21 <jusss> let's assume there's a function f,      f g [] = X       f g (x:xs) = f (g x) xs        what g and X would be to make this f exist?
19:29:29 <ski> `show' is just converting from `Int' to `String', here. it's `putStrLn' (or `putStr') (and then also `print', since it calls the former), which has the effect of doing Input/Output (the latter, here)
19:29:30 <nisstyre> tsizz: they have the same return type, IO (), but they aren't the same function
19:30:09 <ski> jusss : attempting to do varargs ?
19:30:11 <tsizz> nisstyre: mhm, but they both are how you output right
19:30:19 <nisstyre> tsizz: depending on your use case, yeah
19:30:24 <nisstyre> there are other ways of doing output too
19:30:32 <nisstyre> but you probably only need those to start with
19:30:53 <jusss> ski: I don't know, 
19:31:12 <tsizz> nisstyre: okay awesome thanks for the clarification
19:32:23 <tsizz> im making a hangman game. so now i want to output _ the word length number of times
19:32:28 <ski> jusss : with dependent types, you could have something like that working .. but i'd like to know where this question arose, what you were thinking about
19:32:33 <tsizz> i woul ddo this with recursion correct..?
19:32:53 <tsizz> example my word is "word" so i would want to output _ _ _ _ 
19:32:58 <ski> > replicate (length "foobar") '_'
19:32:59 <lambdabot>  "______"
19:33:16 <ski> > intersperse ' ' (replicate (length "foobar") '_')
19:33:18 <lambdabot>  "_ _ _ _ _ _"
19:33:32 <ski> > map (const '_') "foobar"
19:33:34 <lambdabot>  "______"
19:33:46 <ski> > ['_' | _ <- "foobar"]
19:33:48 <lambdabot>  "______"
19:33:58 <jusss> ski: it just comes to my mind, for i in alist: g=g(i)  I just wonder if this is exist
19:34:08 <ski> (that last one is using a "list comprehension", in case you haven't seen that yet)
19:34:34 <jusss> a function take a parameter, then it return a new function with that parameter
19:34:49 <jusss> and do it again, over and over
19:34:52 <tsizz> ski: i have seen list comprehension. thanks ill try it out
19:35:28 <ski> jusss : at least not in that form. if you want to, you can define a new `data' type which describes a "consumer", which will consume a number of "input" tokens, before producing an output. you could probably do something like your `f' with that
19:35:29 <drewbert> What pain points do you encounter when trying to deliver code for a project?
19:35:41 <ski> jusss : details would depend more exactly on what you want to do
19:36:27 <ski> jusss : if it never does anything more than consume a parameter value, then it isn't of much use ..
19:36:55 <jusss> ski: that's why there's a final X in the f g [] = X,
19:37:01 <jusss> and I wonder what X should be
19:37:07 * ski nods
19:37:12 <jusss> end this endless stuff
19:37:54 <drewbert> or less formally: when you're at work following your normal development workflow, what's your biggest annoyance?
19:38:04 <nisstyre> drewbert: mostly other people
19:38:11 <Cale> drewbert: Customers not deciding what it is they want
19:38:13 <nisstyre> i.e. interruptions
19:38:26 <ski> you could have `data Consumer i o = MkCons {done :: o,consume :: i -> Consumer i o}', and then your `X' would involve using the `done' field, while the recursive call, passing `x' to `g', would use the `consume' field
19:40:13 <ski> jusss : and then the signature of your `f' would be `f :: Consumer i o -> [i] -> o'
19:40:22 <drewbert> nisstyre: I feel for you.  Can you tell me about the last time you were interrupted?
19:40:38 <ski> jusss : have you seen `data' type declarations yet ? with record syntax ?
19:41:02 <jusss> ski: not familar
19:41:19 <jusss> I saw a few, but I have never used  it
19:45:12 <ski> jusss : do you know any OO language ?
19:45:23 <jusss> ski: yeah, js and python
19:46:52 <ski> you may think of a value of type `Consumer i o' as an object, which accepts two kinds of messages (has two methods), one being `done', which generates a result output of type `o', and the other being `consume', which, when given an argument input of type `i', will produce a new state/version of the object, which you can then go on calling `done' ior `consume' on
19:47:37 <ski> (no mutation, so instead of `consume' changing some internal mutable state, it just returns a "clone" of the state of the object, adapted to the new information in the newly accepted input of type `i')
19:48:43 <ski> to create a consumer "object", you just have to tell how it should "respond" to the two messages `done' and `consume' .. iow, you don't have classes here, you just describe the behaviour of the object directly
19:48:49 <nisstyre> drewbert: scheduled meetings every day, killing me
19:48:52 <nisstyre> and slack
19:48:54 <nisstyre> god
19:48:57 <nisstyre> someone put me out of my misery
19:49:16 <nisstyre> it's not that bad though as I work from home
19:49:20 <ski> (if you want to, you can describe common behaviour that you want to reuse in a function, which constructs new objects for you. an "object factory", i suppose ..)
19:49:22 <nisstyre> so I can always just put it on silent
19:49:32 <ski> jusss : does that help ?
19:50:07 <ski> e.g. if you wanted to define an accumulating object, which accumulated a sum, starting at zero, you could say
19:50:24 <ski>   accumulator :: Consumer Int Int
19:50:30 <ski>   accumulator = MkCons
19:50:33 <tsizz> nisstyre: https://www.reddit.com/r/ProgrammerHumor/comments/bg6z1l/programmers_day_vs_night/
19:50:40 <drewbert> nisstyre: Have you taken any other steps to try to reduce your interruptions?
19:50:45 <ski> actually
19:51:03 <ski>   accumulator = self 0
19:51:06 <ski>     where
19:51:15 <nisstyre> drewbert: mainly just trying to focus on only doing one thing at a time
19:51:18 <ski>     self sumSoFar = MkCons
19:51:24 <ski>       { done = sumSoFar
19:51:40 <ski>       , consume = \n -> self (sumSoFar + n)
19:51:42 <ski>       }
19:52:15 <nisstyre> on a more relevant topic
19:52:19 <nisstyre> anyone used this before? https://hackage.haskell.org/package/capnp
19:52:33 <nisstyre> I've been bing reading papers and blog posts about capabilities, and this came up many times
19:52:43 <nisstyre> Cap'n Proto that is
19:52:49 <ski> so `sumSoFar' is the (private) local state (still immutable, but you can swap it out for another state, if you call the "constructor" `self' with a different initializer value, like inside `consume' there) of your object
19:52:51 <nisstyre> *binge
19:53:21 <jusss> ski: sorry to being late replay, I need a little time to understand this
19:54:06 <ski> jusss : i'm mostly trying to get across a broad idea of what one could do with something like this data type. getting the details can wait for later
20:03:42 <tsizz> how would i go about repeating taking user input?
20:03:46 <tsizz> while loop 
20:07:14 <ski> tsizz : recursion is the general answer
20:07:29 <tsizz> ski: okay i thought so thanks
20:07:48 <ski> one can build stuff like
20:07:49 <ski> @type until
20:07:50 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
20:07:54 <ski> @src until
20:07:54 <lambdabot> until p f x | p x       = x
20:07:54 <lambdabot>             | otherwise = until p f (f x)
20:08:07 <ski> in your case you'd want a monadic version
20:08:29 <ski> @hoogle untilM
20:08:29 <lambdabot> Control.Monad.HT untilM :: (Monad m) => (a -> Bool) -> m a -> m a
20:08:29 <lambdabot> Control.Monad.Loops untilM :: Monad m => m a -> m Bool -> m [a]
20:08:29 <lambdabot> Control.Monad.IfElse untilM :: Monad m => m Bool -> m () -> m ()
20:08:31 <ski> @hoogle whileM
20:08:31 <lambdabot> Control.Monad.Loops whileM :: Monad m => m Bool -> m a -> m [a]
20:08:31 <lambdabot> Control.Monad.Extra whileM :: Monad m => m Bool -> m ()
20:08:31 <lambdabot> Extra whileM :: Monad m => m Bool -> m ()
20:08:41 <ski> not quite sure which packages those are in
20:09:05 <tsizz> ski: monads are still really confusing to me so idk if i should try that
20:09:18 <ski> @hoogle untilM_
20:09:18 <lambdabot> Control.Monad.Loops untilM_ :: Monad m => m a -> m Bool -> m ()
20:09:19 <ski> @hoogle whileM_
20:09:19 <lambdabot> Control.Monad.Loops whileM_ :: Monad m => m Bool -> m a -> m ()
20:10:16 <ski> tsizz : after you grasp a few particular ones, like `Maybe',`Writer',`Reader',`State',`[]', it'll probably go easier, not much of a big deal
20:10:38 <ski> (i should also mention `Either', i suppose)
20:10:58 <tsizz> ski: mhm but i can just do while loop as recursion too right
20:12:31 <ski> monad's just a commonly recurring pattern of code, idiom/style of coding it. using them amounts to, first and foremost, avoiding some errorprone boilerplate code that you'd otherwise have to write. it so happens that "state","logging","environment","failure","exceptions","nondeterminism" all fit the same abstract pattern
20:12:37 <ski> tsizz : sure
20:13:27 <tsizz> ski: should i use id to convert a string to a char
20:13:37 <ski> @src String
20:13:37 <lambdabot> type String = [Char]
20:13:50 <ski> a `String' is the same thing as a list of `Char's
20:13:56 <ski> (for better or worse ..)
20:13:56 <tsizz> mhm
20:14:01 <tsizz> yeah im trying to do comparsion
20:14:11 <tsizz> it says expect char but actual string
20:14:15 <ski> so you'd have to decide which (if any) `Char' to select in the list
20:14:37 <ski> oh, so you're confusing an element for a list, or vice versa, somewhere
20:14:38 <tsizz> my string is really just ["a"]
20:14:56 <ski> that's not a `String', that's a *list* of `String's !
20:15:03 <tsizz> ah yeah
20:15:05 <tsizz> i mean "a"
20:15:07 <ski> @type ["a"]
20:15:08 <lambdabot> [[Char]]
20:15:09 <tsizz> instead of 'a'
20:15:16 <ski> > ['a']
20:15:18 <lambdabot>  "a"
20:15:22 <ski> would be a `String', though
20:15:37 <ski> > head "a"
20:15:39 <lambdabot>  'a'
20:15:41 <ski> > head "abc"
20:15:43 <lambdabot>  'a'
20:15:44 <ski> > head ""
20:15:46 <lambdabot>  *Exception: Prelude.head: empty list
20:15:47 <ski> oops !
20:15:57 <tsizz> "a" is same as ['a']?
20:16:07 <ski> yes, former is syntactic sugar for latter
20:16:32 <tsizz> could i just do "a"!!0 
20:16:35 <tsizz> to get a char o.O
20:16:54 <ski> > case "abc" of c:rest -> "ok, got a non-empty string, first char was : " ++ show c; "sorry, empty string has no first char !"
20:16:56 <lambdabot>  <hint>:1:125: error:
20:16:56 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
20:17:05 <ski> > case "abc" of c:rest -> "ok, got a non-empty string, first char was : " ++ show c; _ -> "sorry, empty string has no first char !"
20:17:07 <lambdabot>  "ok, got a non-empty string, first char was : 'a'"
20:17:09 <ski> > case "" of c:rest -> "ok, got a non-empty string, first char was : " ++ show c; _ -> "sorry, empty string has no first char !"
20:17:11 <lambdabot>  "sorry, empty string has no first char !"
20:17:21 <eiGHttt> > "a" !! 0
20:17:23 <lambdabot>  'a'
20:17:38 <ski> `head' is probably considered "better" than `!!', when appropriate
20:18:07 <ski> but really, pattern-matching is usually preferable to `null',`head',`tail'
20:18:21 <ski> (the `case' above was an example of pattern-matching)
20:18:40 <ski> > "" !! 0
20:18:41 <lambdabot>  *Exception: Prelude.!!: index too large
20:18:48 <ski> still doesn't work
20:19:07 <jle`> you can also use listToMaybe and case on the Just for the first item if you fancy that
20:19:11 <jle`> > listToMaybe "a"
20:19:12 <ski> with a `case' you can do something else in case you got an empty `String'
20:19:13 <lambdabot>  Just 'a'
20:19:14 <jle`> > listToMaybe "abc"
20:19:16 <lambdabot>  Just 'a'
20:19:17 <jle`> > listToMaybe ""
20:19:18 <lambdabot>  Nothing
20:19:32 * ski idly wonders how familiar tsizz is yet with `Maybe'
20:20:15 <tsizz> ski: not at all :(
20:20:23 <tsizz> but for my assignment i assume input is valid
20:20:32 <tsizz> so i wouldn't run into the problem of ""!!0
20:20:52 <ski> that's ok, as long as you're aware of that (preferably documented)
20:21:13 <ski> (aware of making that assumption / precondition on input)
20:21:44 <ski> i'd still use `head' rather than `!! 0', though, unless maybe if i also used `!!' with other indices
20:23:43 <nisstyre> you can pattern match as well if that works for you
20:23:48 <nisstyre> IDK if you've been introduced to that
20:24:38 <nisstyre> > let (x:_) = "a" in (a :: Char)
20:24:39 <lambdabot>  error:
20:24:39 <lambdabot>      • Couldn't match expected type ‘Char’ with actual type ‘Expr’
20:24:40 <lambdabot>      • In the expression: (a :: Char)
20:24:47 <nisstyre> > let (x:_) = "a" in (x :: Char)
20:24:49 <lambdabot>  'a'
20:24:50 <nisstyre> woops
20:24:50 <tsizz> nisstyre: i have but its an arbitrary character
20:25:05 <tsizz> that i would need to use as well
20:25:08 <tsizz> in the output
20:25:14 <tsizz> so i don't think that would work?
20:25:29 <tsizz> ski: oh so head is just first element right
20:25:45 <tsizz> that sounds better
20:26:41 <tsizz> is zvon.org a good resource?
20:30:23 * ski isn't sure why people seem to insist on wrapping brackets around patterns, where none are required
20:30:44 <ski> > let x:_ = "a" in x
20:30:46 <lambdabot>  'a'
20:31:04 <tsizz> ski: thanks yeah i used head. its more lisp style!
20:31:11 <ski> tsizz : `head' is the initial element of a non-empty list, yes
20:31:16 <tsizz> head ""
20:31:16 <ski> like `car' in the Lisps
20:31:22 <ski> and `tail' is then like `cdr'
20:31:33 * ski . o O ( "My other car is a cdr." )
20:31:35 <tsizz> head empty list would error too
20:31:46 <tsizz> >
20:31:50 <ski> and `null' can be used to check whether a list is empty ..
20:32:38 <monochrom> I am sure cargo-culting is the norm.
20:32:42 <ski> .. but really, if you find yourself using `null' and `head' ior `tail', then that may be a code smell, and you may be better off with plain pattern-matching (or some other utility like `listToMaybe', perhaps coupled with `maybe' or `fromMaybe')
20:33:37 <ski> i've certainly seen <zvon.org> referenced here before, over the years
20:33:47 <monochrom> Also, I have students who insist on "null" and "head". When I deduct marks, the students go "mine is just as performant and readable".
20:33:49 <ski> though, i tend to forget it exists, when not reminded of it
20:34:02 <tsizz> zvon.org always pops up first hah
20:34:09 <tsizz> or in the first 3 when i google
20:34:34 <monochrom> Actually it's probably worst. Some of those students use "xs == []" instead of null.
20:34:49 <ski> tsizz : "head empty list would error too" -- yes, as i already showed above :)
20:34:57 <ski> monochrom : argh ! :)
20:35:30 <ski> at least it's not `(xs /= []) == False'
20:35:56 <ski> (maybe too imaginative ? .. though i wouldn't be surprised)
20:36:10 <monochrom> Oh in another part of the code they have "<long boolean expression> == False". Just not simply list emptiness.
20:36:20 * ski nods
20:36:56 <ski> sometimes i want to write `if <condition> else <alternate> then <consequent>'
20:37:25 <tsizz> should i put module Main where at the top?
20:37:34 <tsizz> it works fine, but i think im going to rename my file 
20:37:37 <ski> i guess this is where someone would suggest me to use the fine `case'
20:37:41 <monochrom> Here is the thing. I never taught them null, head, tail, fromJust, isJust.  I taught pattern matching only.  So it shows that they just disobey me or even completely ignore.
20:37:43 <tsizz> it works fine without it module Main where**
20:38:05 <ski> tsizz : `Main' module is a special exception, in GHC, the file doesn't need to be called `Main.hs'
20:38:33 <monochrom> Their attitude is not "let me learn this new way", it's "I'm entitled marks".
20:39:54 <ski> well, at least they're curious enough to find those things .. or just cargo-culting, as you said
20:40:08 <tsizz> monochrom: i wish i could apply myself to learning more, but i get really busy with school and part time internship so i just rush to finish assignments and its detrimental to my learning
20:40:11 <jackdk> I don't mind students finding other stuff, but there are really good reasons to use `null` over `== []` and patterns over `head`/`tail`
20:41:22 <ski> tsizz : yes, you can leave it out as well, if you don't need to import it elsewhere
20:41:28 <jackdk> and the student claim "mine is just as performant and reliable" is not true when you consider code modification - yeah you remembered to guard your `fromJust` with an `isJust` today, but that's not necessarily stay lined up right after refactoring
20:41:38 <tsizz> ski: wait im confused what module Main where does
20:42:34 <monochrom> Their background is python. They will just shoehorn python habits everywhere.
20:43:00 <ski> tsizz : names the module defined by the source file `Main'. if you leave it out, it'll just implicitly make a `Main' module
20:43:40 <jackdk> yeah it is sometimes necessary to take away those tools so you are forced to practice the new way
20:43:56 <ski> tsizz : all the other things in the module (excepting comment, and pragmas i suppose) defines things that are put inside that named module (perhaps to be exported, perhaps not)
20:45:48 <tsizz> ski: sorry im confused by term module. i am just thinking of it as the whole code
20:45:51 <tsizz> in the file
20:47:42 <jackdk> here is the definition of module: https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-980005
20:49:28 <ski> tsizz : a module is roughly a compilation unit of code, that is compiled on its own, independently (more or less) of other modules. a module bundles up a bunch of value (like function) and type definitions (and perhaps also type class definitions ior instances). some of which may be private to that module (not visible by other modules importing it), others being public/exported
20:50:08 <tsizz> mhm okay yeah that is my basic understanding
20:51:24 <tsizz> ski: so its basically way of exporting the file as a name?
20:51:30 * ski . o O ( "Because they are allowed to be mutually recursive, modules allow a program to be partitioned freely without regard to dependencies." )
20:51:32 <tsizz> kind of
20:52:10 <ski> tsizz : it's a way of controlling which definitions in a source file are to be made public, to importers of the module defined by that source file
20:52:44 <ski> and of cutting a larger program up into smaller chunks of code, each typically residing in separate source file
20:53:14 <tsizz> ski: mhm. so if im just using this one file then i dont need to worry about that
20:53:20 <tsizz> running this one file*
20:54:08 <ski> (and then there's external infrastructure for bundling a number of related modules together, into a package, which you may choose to selectively download and install (make available), on your computer, for use from other Haskell programs (modules))
20:54:16 <ski> correct
20:54:39 <ski> modules are for programming-in-the-large
20:56:02 <ski> re lrb
20:56:38 <lrb> re?
20:57:00 <ski> as in "rehi", or "we meet again"
20:57:15 <tsizz> ski: okay awesome. runhaskell myprogram.hs
20:57:23 <tsizz> that just runs my main function?
20:57:23 <lrb> Oh, hi :)
20:57:31 <ski> tsizz : action, not function. but yes
20:57:48 <ski> (I/O action)
20:58:21 <tsizz> and it will correctly be able to use functions defined outside of the main action in the main action?
20:58:37 <tsizz> just want to make sure my program will run right on my graders computer
20:59:36 <ski> tsizz : i think you could even put `#!/path/to/runhaskell' or `#!/bin/env runhaskell' as the first line of your file, and make it executable, on a *nix system, so you could run it directly without having to use `runhaskell' explicitly
20:59:43 <ski> ah, right
21:00:05 <ski> <tsizz> and it will correctly be able to use functions defined outside of the main action in the main action?
21:00:27 <ski> yes, as long as they're defined in the same module, and all at the "top-level" (not a local scope)
21:01:18 * ski isn't sure how shabangs would work on Windows, though. BATch scripts, maybe ?
21:01:31 <tsizz> ski: gotcha okay thanks so much for the help =)! i am going to head to bed
21:02:41 <ski> tsizz : ok. have fun ! good night and pleasant dreams
21:02:48 <lrb> So I'm doing something *very* naively, and I can tell that's the case. I just don't know how else to accomplish it. I've typed up a very simple example of what I plan to be doing: https://paste.ee/p/bNiOs
21:03:25 <tsizz> thanks i am going to finish it tomorrow, but all i have to do is loop it now so that shouldn't be too hard! good night !
21:03:37 <ski> lrb : you could use a record, or at least a tuple, inplace of a list
21:04:02 <lrb> Ultimately, though, mybasket will be a collection of stats that has something like 30 different entries
21:04:06 <ski>   mybasket = (4,2,6)
21:04:10 <lrb> I'll see what the record looks like
21:04:13 <lrb> That's a tuple, right?
21:04:28 <ski>   apples (noBananas,noApples,noOranges) = noBananas
21:04:34 <ski> yes, a triple, specifically
21:05:15 <ski> lists are homogenous, arbitrary length
21:05:24 <ski> tuples are heterogenous, fixed length
21:06:09 <ski> er, of course the above should be
21:06:15 <ski>   apples (noBananas,noApples,noOranges) = noApples
21:06:21 <ski> otherwise it makes no sense !
21:06:27 <lrb> Yup, that was my understanding of it. I was considering making it a tuple just to ensure the length and the types of the items contained within. 
21:06:46 <lrb> And I'm not really understanding the syntax you're demonstrating.
21:07:07 * ski . o O ( bad ski, no more apples for you ! )
21:07:33 <ski> it's called pattern-matching
21:07:52 <mouse07410> mpickering: I've posted the logs of HIE build failures on GitHub under "MacOS build broken". If there's a specific branch that should be used (I used master), or survive l specific instructions - it would be great to learn.
21:08:12 <ski> if a `basket' is a triple, then every possible `basket' must evaluate to something of the general shape `(..,..,..)'
21:08:18 <ski> so, by writing
21:08:26 <mouse07410> ^survive -> specific
21:08:32 <ski>   foo (x,y,z) = ..use `x',`y',`z' here..
21:08:48 <ski> we're taking about the input triple, giving the names `x',`y',`z' to the three components
21:10:08 <ski> in my case, i used the names `noBananas',`noApples',`noOranges' ("no" as in latin "number of" ("numero")) for the three parts of your `basket' triple (or any similar triple that will be passed as input to one of `bananas',`apples',`oranges')
21:10:15 <ski> lrb : making any sense ?
21:10:25 <lrb> OH that makes so much more sense. So I'm specializing the function to a specific thing and making it FAR more readable
21:11:31 <ski> yea, pattern-matching generally tends to make things more readable, than a twisty maze of `if'-`then'-`else's with alternative predicates and field accessors :)
21:12:06 <ski> (in this case, there's no choice, though. a triple is a triple, it can't have any alternate form/shape. the only issue is getting at the components)
21:12:38 <ski> (otoh, a list could have one element, or two elements, or three, or ...)
21:12:52 <ski>   countElements [] = "Zero"
21:12:57 <ski>   countElements [x] = "One"
21:13:03 <ski>   countElements [x,y] = "Two"
21:13:09 <ski>   countElements [x,y,z] = "Three"
21:13:29 <lrb> Now in terms of code redundancy, I'll be naming 24 different components with a way to access each in a readable way. Do you have any suggestions on *generalizing* that to reduce the amount I need to actually write? 
21:13:38 <ski>   countElements _ = "Many"  -- Sorry, I can't count higher than three
21:13:43 <jlamothe> ski: Why bind the variables to names if they're not being used?
21:13:57 <ski> that's an example of pattern-matching also doing choice selection (on list length)
21:14:34 <ski> jlamothe : why introduce a new concept to the newbie when they've got their mouth full with the current one ?
21:14:49 <ski> (well, looks like i already did ! (last case of `countElements'))
21:15:33 <ski> lrb : are those structured in any way ?
21:15:45 <lrb> they are, yes. 
21:15:52 <ski> you could have tuples inside tuples
21:16:17 <ski> possibly with type synonyms to remind you of what each kind of type is intended to stand for
21:16:33 <lrb> I'm mostly talking about some way to avoid writing 24 *slightly* different functions. 
21:16:49 <lrb> Is there some kind of hash map?
21:16:54 <ski> or you could just go all the way to records (really record notation), and use named field accessors, rather than access components by position (which is what tuples give you)
21:16:58 <lrb> er.. Table
21:17:32 <lrb> Oh, maybe what you're talking about is what I'm interested in.
21:17:33 <ski> .. you could use a `Map', i suppose. if you're prepared to import a library module
21:17:53 <lrb> Lemme look at the record and see if that'll accomplish what I want.
21:18:23 <ski> (`Map's are homogenous, though. records doesn't have to be)
21:19:11 <lrb> "Currently in Haskell two records in the same module can't share a field name." <- Does this mean I can't have an "noApples" record in two separate records?
21:19:35 <lrb> Er.. "noApples" field, I mean
21:19:44 <ski> you can have it in two separate record values, but not in two separate record *types* (in the same module)
21:20:08 <lrb> OH, so I can't have a record with an int "noApples" and a float "noApples".
21:20:53 <ski> (also, record syntax is a bit unsatisfactory and confusing, in some regards .. /me wistfully looks towards SML)
21:21:36 <lrb> So as an aside, so far this has been the most welcoming programming community I've been a part of. You're all awesome.
21:21:37 <ski> well, unless you generalize the record type on that component type, and "instantiate" the generalized record type differently, in two different cases
21:21:47 <ski> (but tthat might be clunky, depending on what you're doing)
21:21:56 <ski> yw
21:22:30 * ski thinks it's probably same to assume lrb hasn't seen parameterized `data' types, yet
21:22:45 <ski> (called "generics", in some programming languages)
21:23:21 <lrb> I'm on Chapter 2 of "Learn You A Haskell For A Great Good!" so probably not.
21:24:18 <ski> just so you know, LYAH has been likened to a "four hour long movie trailer", by someone in here
21:24:29 <ski> nowadays, it's not considered that good an introduction
21:24:36 <ski> but, it has pretty pictures :)
21:24:59 <ski> main faults : not explaining deeply enough, and not having exercises
21:25:05 <ski> @where CIS194
21:25:05 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
21:25:10 <ski> has exercises you could try
21:25:34 <ski> if you want textbook suggestions, you could try e.g.
21:25:37 <ski> @where PIH
21:25:37 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
21:25:37 <lrb> I got it in a humble bundle a while back. The author's humor is appreciated though lol.  
21:25:46 * ski nods
21:25:53 <ski> having fun is important, when learning !
21:26:18 * ski learned using "Haskell: The Craft of Functional Programming", by Simon Thompson
21:26:36 <lrb> indeedy. I've got a project in mind and that's always helped me learn. It's not really as structured of learning as I probably need, but I prefer to learn at my own pace.
21:27:01 <ski> some people have liked
21:27:03 <ski> @where SOE
21:27:03 <lambdabot> "The Haskell School of Expression: Learning Functional Programming through Multimedia" by Paul Hudak in 2000 at <http://www.cs.yale.edu/homes/hudak/SOE/>,<http://haskell.org/soe/> [broken]
21:27:06 <ski> and
21:27:08 <DigitalKiwi> the thing I still like about LYAH is it shows a lot of common functions that are harder to find otherwise and less talked about in some other books
21:27:09 <ski> @where HR
21:27:09 <lambdabot> "The Haskell Road to Logic, Maths and Programming", by Kees Doets,Jan van Eijck, at <http://homepages.cwi.nl/~jve/HR/>
21:27:10 <lrb> I am struggling a bit with Haskell's hoogle, which would probably make things a lot easier for me.
21:27:17 <ski> and nowadays, many seem to be trying
21:27:22 <ski> @where HPFFP
21:27:22 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
21:27:36 <ski> there's also
21:27:39 <ski> @where wikibook
21:27:39 <lambdabot> http://en.wikibooks.org/wiki/Haskell
21:27:43 <ski> @where HTAC
21:27:43 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
21:28:17 <ski> and the dreaded "gentle" tutorial
21:28:19 <ski> @where tutorial
21:28:20 <lambdabot> http://www.haskell.org/tutorial/
21:28:39 <DigitalKiwi> ski "doesn't want to introduce _" also ski "here are a dozen different books"
21:29:01 <ski> (not really so gentle, unless you already know some other functional programming language, preferably statically typed, like SML,OCaml,F#,Clean,Alice ML)
21:29:26 <ski> DigitalKiwi : heheeh ;)
21:30:24 <ski> (perhaps Schemers or Erlangers would also fare well with the gentle one. at least if they have tackled SICP ?)
21:30:29 <DigitalKiwi> ftr i don't think _ is that confusing and plenty of other languages have the idea of it so the likelihood of it being familiar is high
21:31:14 <lrb> Problem is that I don't know how much I actually know so it's hard to give you an idea :| 
21:31:31 <ski> DigitalKiwi : yea, i mostly didn't want to nest it inside another pattern (rather than simply using it as a catch-all at the end as with `countElements'), and then spend a couple of messages explaining what it meant. simply giving every component a name seemed simpler
21:31:32 <DigitalKiwi> but that's just my opinion 
21:31:39 <lrb> I guess I'll just say that I've never been able to focus long enough to actually get a project completed.
21:32:10 <lrb> I've studied Python and C++, though.
21:32:12 <ski> lrb : yes, the general problem with learning. Dunning-Kruger and all that
21:32:28 <lrb> And a *teeeeeeny* bit of x86_64 asm
21:32:34 <ski> (parameterized types in Haskell are *sort* (kinda) like templates in C++)
21:32:41 <ski> lrb : my condoleances
21:32:48 <DigitalKiwi> i feel like the linter/compiler might even give a message if you do it anyway
21:33:30 <lrb> Haha, I was gonna try tackling reversing the macOS trackpad driver, but gave up on that after realizing how much of a pipedream it was.
21:33:47 <ski> DigitalKiwi : ooc, which other languages did you have in mind ?
21:34:02 <lrb> I've bookmarked all those links, by the way.
21:34:15 <DigitalKiwi> what's ooc
21:34:59 <lrb> out of character?
21:35:03 * ski tends to err of giving people enough rope to hang themselves with, and then some, while explaining why you would normally not want to use such dangerous things, and why, and what to do instead
21:35:07 <lrb> that's what google says, anyway
21:35:14 <ski> DigitalKiwi : "out of curiosity"
21:35:37 <ski> s/err of/err on the end of/
21:37:06 <DigitalKiwi> oh, python, scala, lua, without thinking too hard, all have it either by convention or built in
21:37:27 <DigitalKiwi> i'm sure there are more but i don't want to think too hard about it ;p
21:37:55 <ski> ok, so `_' is a locator value, in those ?
21:38:12 <ski> (locator expression ?)
21:40:55 <DigitalKiwi> "we don't ever need the name of this so we name it _"
21:41:33 <ski> and that's not just a regular name, then ?
21:42:00 <DigitalKiwi> sometimes it's only by convention, sometimes it's built in, it varies by language
21:42:44 <ski> well, i think you should be able to say at least the equivalent of `(_,y,_) = ...', for it to count
21:44:39 <ski> (iow repeat it in a compound pattern / locator, and have each occurence to count as a distinct thing, not requiring them to be equal (which is what `{U,Y,U} = ...' in Erlang would do). hm, i suppose shadowing would also fullfil that .. but i think probably (?) most languages wouldn't do shadowing here)
21:45:02 <monochrom> ski: Consider "you should really not smoke but... here are 10 great ways to smoke and/or vape! ..."
21:45:46 <ski> "you should really not smoke but... in case you do (or would like to), here's what you could try : ..." ;)
21:46:03 <monochrom> If people don't know that something exists, they won't even think of trying.
21:46:10 <ski> exactly
21:46:26 <ski> how can they know that something is bad, if noone tell them about it ?!
21:46:36 <monochrom> But if you tell them it exists, and even state 10 ways of doing it, then the more you say "it's actually banned", the more they will actually do it.
21:46:47 <DigitalKiwi> anyway the point isn't how well the languages support it but that the concept of _ being something that the name doesn't matter (even if it's actually a variable but you're not supposed to access it) is common. and even if it wasn't it's pretty easy to reason about "oh, this has a name, but we don't need the name, so we give it this name that we don't care about"
21:46:50 <ski> and then .. perhaps, learn a thing or two ;)
21:47:45 <monochrom> Use Sapir-Worf-Orwell? The same way Python 1 did not have if-then-else-as-expression therefore no one could do it? Recall that GvR thought it bad.
21:49:04 <ski> DigitalKiwi : granted. i just tend to count the "distinct occurances count as matching different values / acting as distinct sinks for values" part as parcel of the whole idea (but yes, even the convention is a step forward)
21:49:47 <monochrom> Although, this is a great chance to get back at me with "hey you didn't teach your students null-head-tail and they still do it..."
21:50:07 <ski> yea .. there's always other teachers
21:50:31 <ski> @quote son.or.daughter
21:50:31 <lambdabot> Dave_Benjamin says: please talk to your son or daughter about parametric polymorphism
21:50:40 <monochrom> heh
21:51:01 <monochrom> Although, if I taught them null-head-tail, more students would use it.
21:51:55 <ski> sometimes, if i'm mentioning `eval', i say something along the lines of "You should not use `eval', unless you know why you shouldn't use it."
21:52:48 <ski> (i probably got that off someone else, i can't remember)
21:54:50 * ski probably isn't that good at getting back at anyone, though .. :/
21:57:39 <monochrom> I always argue with myself. It adds sparks to my conversations.
21:58:23 <ski> i can imagine
21:58:25 <ski> (maybe ?)
21:59:13 <ski> (i suppose i sometimes like being contrary)
21:59:22 <MarcelineVQ> no you don't
21:59:59 <ski> yes, i do !
22:00:43 <ski> (or do i ? /me wanders off having a minuscule identity crisis)
22:06:40 <MarcelineVQ> null xs vs xs == [] is actually petty neat as far as teachable examples go: Do they look the same? Do they give the same output? Did you check the type? What is the actual difference as an english sentence? Why might one be considered better overall?
22:11:11 <jle`> my haskell project i was building as tooling to distract me from the main project is now done
22:11:22 <jle`> such emptiness in my heart now
22:12:17 * hackage odpic-raw 0.5.0 - Oracle Database Bindings  https://hackage.haskell.org/package/odpic-raw-0.5.0 (leptonyu)
22:13:41 <lrb> ski: would you think that https://en.wikibooks.org/wiki/Haskell is a fine way to start? it's free, so that's a huge bonus for me. you linked it, but I'm just wondering how it compares to the other resources you shared.
22:18:36 * ski hasn't really tried it
22:19:23 <ski> i'd suppose it's good in places, and may have holes in other places ?
22:21:25 <lrb> That's profoundly applicable to basically everything, lol. I'll just read as much as I can :)
22:26:15 <benzrf> quit
22:27:06 <lrb> no u
22:27:33 <DigitalKiwi> i don't think there's one best resource you'll likely end up reading multiple books/blogs/wikis/papers/etc and different things will click at different times
22:28:06 <lrb> Yeah, that's what I figured would be happening
22:28:44 <S6420> g
22:29:55 <jackdk> g!
22:30:11 <lrb> g!!
22:30:21 <ski> g-
22:31:15 <S6420> -clone sim-card for germany and exchange on bitcoins/monero (vodafone, d2, d1, e+, o2, telekom, mobilcom) jabber: bgmn@616.pub 
22:31:37 <DigitalKiwi> wat
22:31:39 <lrb> baaaaan
22:31:47 <ski> no thanks, i'm fine
22:32:03 <ski> and how're you ?
22:32:18 <ski> S6420 : did you have any Haskell-related question or comment ?
22:33:02 <DigitalKiwi> i have sim cards i don't use how much they worth? 
22:33:28 <lrb> Verizon sells them for like $5 so they're probably worth $0.23
22:33:29 <ski> probably more, the older they are
22:33:49 <DigitalKiwi> i used to have one with unlimited verizon plan ;_;
22:51:36 <lrb> ski.. you mentioned 'apples (noBananas,noApples,noOranges) = noBananas' as a way for referencing the tuple. Is there any way to define a function 'framework' of sorts as being like that and then define a bunch of functions which use that framework? I don't know how else to describe it.
22:52:20 <ski> not sure what you mean / are after
22:52:33 <lrb> Hm... Lemme see if I can make some pseudocode
22:52:38 <ski> that already defines a function `apples', which you can then call like `apples basket'
22:53:24 <ski> you could also define functions for "updating" components of the tuple (really returning new versions of it, with some components changed)
22:53:50 <ski>   anotherApple (noBananas,noApples,noOranges) = (noBananas,noApples + 1,noOranges)
22:54:15 <ski> then you could say `apples (anotherApple (anotherBanana (anotherApple basket)))'
22:54:30 <ski> or `iterate anotherApple basket !! n'
22:56:07 <ski> or `apples (foldr ($) basket [anotherApple,anotherBanana,anotherApple])' (that does the same as the example just before the last one)
22:56:41 <dminuoso> % trimap f g h (x,y,z) = (f x, g y, h z)
22:56:41 <yahb> dminuoso: 
22:56:44 <ski> > iterate f x
22:56:46 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
22:56:53 <ski> > iterate (2 *) 1
22:56:55 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
22:56:56 <dminuoso> % trimap (+) toUpper Prelude.tail (1, 'c', "foobar")
22:56:57 <yahb> dminuoso: ; <interactive>:159:1: error:; * No instance for (Show (Integer -> Integer)) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
22:57:01 <ski> > iterate (2 *) 1 !! 8
22:57:03 <lambdabot>  256
22:57:08 <dminuoso> % trimap (+1) toUpper Prelude.tail (1, 'c', "foobar")
22:57:09 <yahb> dminuoso: (2,'C',"oobar")
22:57:48 <dminuoso> % ((+1), toUpper, Prelude.tail) <*> (1, 'c', "foobar")
22:57:48 <yahb> dminuoso: ; <interactive>:161:39: error:; * Couldn't match expected type `Char -> Char' with actual type `Char'; * In the expression: 'c'; In the second argument of `(<*>)', namely `(1, 'c', "foobar")'; In the expression: ((+ 1), toUpper, Prelude.tail) <*> (1, 'c', "foobar")
22:58:14 <dminuoso> Oh
22:59:45 <lrb> So this is kinda what I'm looking for: https://paste.ee/p/PEeSw 
22:59:46 <ski>   modifyApples f (noBananas,noApples,noOranges) = (noBananas,f noApples,noOranges)  -- is a more general function
22:59:59 <ski>   anotherApple = modifyApples (+ 1)
23:00:19 <lrb> I hope it makes sense
23:00:33 <dminuoso> lrb: I cant understand what you are trying to convey there.
23:00:55 <dminuoso> lrb: Could you perhaps use words to describe the intention?
23:01:37 <ski>   framework foo (var0,var1,var2) = foo (var0,var1,var2)
23:01:52 <ski>   initialsum (var0,var1,var2) = var0 + var1
23:02:12 <ski> or, you could say
23:02:32 <ski>   framework foo (var0,var1,var2) = (initialsum,tailsum,headlastsum)
23:02:34 <ski>     where
23:02:42 <ski>     initialsum = var0 + var1
23:02:54 <lrb> I wonder if it's just not possible. I'd like to declare a set of functions that all take the same parameter. ski suggested that I use the syntax of "apples (noBananas,noApples,noOranges) = noBananas" to name elements of a tuple, which is perfect, but my tuple will have 24 named elements and typing those 24 elements for every function will just make the code cluttered
23:02:54 <ski> and then
23:03:04 <ski>   getInitialSum (initialsum,tailsum,headlastsum) = initialsum
23:03:36 <dminuoso> lrb: You could use a record and refer to the individual parts using field accessors.
23:03:54 <ski> if you define twentyfour accessor functions, (and maybe also twentyfour modifier functions), then you could selectively use those, instead of matching
23:04:15 <dminuoso> lrb: for example: data LargeRec = LargeRec { firstName :: String, lastName :: String, age :: Int, gender :: Gender, birthPlace :: City, ... }
23:04:28 <ski> (your `apples' is an example of an accessor function. my `modifyApples' is an example of a modifier function)
23:04:45 <dminuoso> lrb: Haskell then generates accessor functions as well as a shortcut syntax to update individual fields.
23:05:08 <ski> with record syntax, using dminuoso's example, you can say
23:05:19 <lrb> That's the other thing I was looking into, dminuoso. I had the idea I proposed while I was thinking about the solution. 
23:05:33 <ski>   infantinize largeRec = largeRec {age = 0}
23:05:52 <dminuoso> lrb: Also type signatures get more readable since you can just write LargeRec instead. Furthermore you can now use modules to hide implementation details, prevent people or yourself from accidentally supplying a type matching but wrong tuple, and so forth.
23:06:21 <ski> which will return the same record, with all the fields being the same, except that the `age' field now has value `0' in the resulting value (the input value is unchanged, of course, as usual)
23:07:06 <ski> ("infantilize" ?)
23:07:25 <lrb> So that would be a function which takes a largeRec as the argument and returns it with an altered element?
23:08:20 * ski isn't sure whether lrb is aware of type signatures, yet
23:08:24 <dminuoso> lrb: Right.
23:09:06 <ski> if you wanted you could let the new value depend on the old one
23:09:16 <lrb> I know that they exist, but I might as well just not know about them with how much I know
23:09:31 <ski>   aYearPasses largeRec = largeRec {age = age largeRec + 1}
23:09:38 <dminuoso> PVP question: If I make a large bump on a pkg-config version dependency with no externally visible changes or behavior, would that be a minor or major bump?
23:09:50 <ski> (and this is where record syntax .. eh, syntax, starts to get a little bit confusing a weird)
23:10:44 <lrb> so that returns a record where the age record is incremented from the original
23:10:57 <dminuoso> lrb: Spot on.
23:11:00 <lrb> Neato
23:11:09 <ski> lrb : you mentioned Python, so i suppose you're used to not having manifest types. so i suppose for now you could ignore type signatures. eventually, you'll want them as your friend, though
23:11:27 <lrb> I can't tell if I like this language because it's awesome or because it's different, lol. I'm enjoying it a lot though
23:12:19 <ski> imho, that would be better (less confusing) if it was say `#age largeRec + 1' (a la ML), or even `largeRec .age + 1' (a la OCaml, and also other languages)
23:13:14 * geekosaur thinsk too many things use . as it is
23:13:28 <ski> (as it is now, sometimes `age' means the field itself (of type `Int'), and sometimes the field accessor function (of type `LargeRec -> Int') -- and this can get annoying e.g. when you also want to have a local variable named `age' .. turns out that that will shadow the field accessor function :/ ..)
23:14:06 <ski> geekosaur : possibly. but there's something to be said for the post-field order
23:14:29 * ski would be fine with `largeRec #age + 1'
23:14:46 <dminuoso> geekosaur: Haskell included? :-)
23:15:06 <ski> dminuoso : i took them to be talking specifically about Haskell :)
23:15:06 <geekosaur> > [False..True] -- case in point. And specifically Haskell
23:15:08 <lambdabot>  error:
23:15:08 <lambdabot>      Not in scope: ‘False..’
23:15:08 <lambdabot>      No module named ‘False’ is imported.error:
23:15:41 <ski> lrb : perhaps a bit of both ;)
23:15:51 <lrb> lol, that's what I was thinking
23:16:14 <lrb> Hm.. does this mean I need to find a font with Haskell ligatures?
23:16:42 <dminuoso> lrb: Fira Code is a great choice. ;-)
23:17:08 <geekosaur> (and we're at the same place with ! and @ now. overloaded syntax kinda sucks...)
23:17:19 <lrb> I really like narrow fonts for realestate. I found Quinze and immediately fell in love.
23:17:38 <dminuoso> lrb: If you like narrow fonts, perhaps PragmataPro would be to your taste.
23:17:55 * ski wouldn't personally bother with editor-support for giving the appearance of ligatures (and other unicode symbols) .. unless it preserved the character width of the source
23:18:11 <lrb> ski, that's why I like vim :)
23:18:45 <ski> (layout is a bit finicky with character count .. also if you try to align things (like patterns), things will be off, one place or the other)
23:18:47 <lrb> dminuoso: if you have *any* interest in narrow fonts, I highly recommend looking at quinze. TBH, I've churned through almost every narrow font out there and this one really stood out
23:18:55 <monochrom> Ligature is best for shell scripts so "fi" is merged. :)
23:19:03 <ski> lrb : it does preserve it ?
23:19:49 <dminuoso> ski: vim does whatever your terminal emulator doe.s
23:19:53 <lrb> I use vim in the terminal, so yeah. Sometimes it moves a specific character closer to another if the font says to do so, but it leaves the space.
23:19:54 <ski> geekosaur : .. yes :/
23:20:02 <lrb> ^ That's a better way of putting it
23:20:36 <ski> dminuoso : hm, good point, i suppose. but will Vim know whether the terminal does (say) double-width or not ?
23:20:44 <monochrom> So "fiend" will look like "fi end"?
23:20:51 * ski tends to use `emacs -nw'
23:21:33 <dminuoso> ski: So if you use a terminal emulator that supports monospace ligatures, then vim has them for free transitively.
23:21:33 <dminuoso> It's probably different if you use gvim or others.
23:22:02 <ski> okay, hmm
23:22:17 <dminuoso> ski: Mmm, Im not well versed in terminfo. Perhaps that might include the info?
23:22:26 <ski> possibly
23:23:05 <lrb> You can set the encoding in most terminal settings, so I presume that sets an environment variable for the session
23:25:32 <geekosaur> only at start; once the shell has been started, its' too late for the terminal to affect its environment
23:27:42 <ski> hm, i see capabilities to enter and exit double-width mode, and quering about the character step size in that mode
23:28:10 <ski> (but not anything about it automatically entering it, or for querying the status)
23:29:09 <geekosaur> and it's not related, since it's about extending standard characters; it's from the original VT100, and well predates Unicode
23:29:20 <ski> ah, okay
23:29:32 <geekosaur> basically "presentation mode"
23:29:43 <geekosaur> so it's readable from a distance
23:31:44 <ski> (the XTerm docs also mentioned CJK in some relation to "double-width")
23:31:50 <MarcelineVQ> For me ligatures were cute to look at but provided no improvement to code readability and quality, occasionally making things less readable.
23:33:13 <lrb> That's useful to know. I'll probably focus on the more important things
23:35:42 <DigitalKiwi> i don't like typing unicode but i like sometimes when the editor displays the unicode symbols (but it's still ascii in the file, and i can disable if i don't know what it means, and ligatures are confusing and support varies...) and hindent everything so i don't have to decide on alignment
23:37:35 * ski tends to want to align patterns in different defining equations / branches, and sometimes also appropriate corresponding parts in types
23:43:19 <lrb> Is there any reference on reading ghc errors? They seem very generic compared to what I'm familiar with
23:44:44 <DigitalKiwi> but if you just embrace letting hindent be the final say on everything you only spend 30 minutes making it perfect once (and then hindent changes everything and you realize it's futile to put so much effort into formatting it manually)
23:47:05 <lrb> G V gg =
23:49:34 <MarcelineVQ> Not really. They're fairly direct, but verbose, it'll take seeing them a few times combined with being able to read the types in play. if you want to ask about a specific error you're getting though, by putting it and your code in a paste link, people could explain it to you
23:51:40 <lrb> I was mostly asking for learning purposes. I'm reading through a book and it mentions the errors being ugly. I'll probably get used to them eventually.
23:53:38 <ski> DigitalKiwi : (unfortunately ?) i have patience :)
23:56:52 <DigitalKiwi> idk what you mean
23:58:58 <lrb> ski is patient enough to reformat all of the tables formatted automaticlaly by hindent (is hindent a program?)
