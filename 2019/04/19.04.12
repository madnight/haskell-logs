00:47:32 <mpickering> Anyone know how to make `cabal install` install a package and all its build products into somewhere other than `~/.cabal`
00:51:56 <mpickering> perhaps it's time to bust out the sandbox like it's 2013
00:52:03 <blackbart> mpickering: I never messed with that, but it looks like it's specified in ~/.cabal/config under install-dirs user
00:52:12 <Axman6> yeah does cabal new-build give you that?
00:52:30 <mpickering> I'm trying to reproduce a low-level problem with ghc
00:52:42 <mpickering> so I am passing the -package-db flags explicitly and so on
00:52:48 <mpickering> but need to isolate the `.a` and `.o` files
00:55:35 <mpickering> I think a sandbox will work perfectly here as I can create two different once for each of the two cases
01:03:48 <mpickering> going to miss these old cabal features when they get removed :(
01:04:59 <merijn> On the one hand, I empathise with you. On the other hand, dear god I can't wait until dropping old stuff allows the code to be refactored into something remotely sane...
01:06:36 <mpickering> I suppose for this case I could have used `./Setup` directly
01:11:06 <merijn> So...I was looking at the docs of discrimination and...what?
01:12:22 <merijn> I think "newtype Group a = Group { getGroup :: forall m b. PrimMonad m => (b -> m (b -> m ())) -> m (a -> b -> m ()) }" could've done witha little more documentation than, say, "Productive Stable Unordered Discriminator"
01:14:13 <phadej> you aren't supposed to write `Group` by hand anyway
01:14:15 <nshepperd> haha
01:14:23 <nshepperd> the documentation is all in his tech talk
01:19:43 <nshepperd> although i don't remember the PrimMonad stuff being in there so maybe it's not
01:36:10 <absence> in ExceptT one can transform exceptions using withExceptT, but the transformation function type is (e -> e'). what if i want an effectful transformation, i.e. (e -> m e')?
01:36:56 <merijn> absence: I'm not entirely sure whether that'd even make sense?
01:37:44 <phadej> it does
01:38:09 <phadej> :t mapExceptT
01:38:10 <lambdabot> (m (Either e a) -> n (Either e' b)) -> ExceptT e m a -> ExceptT e' n b
01:38:23 <phadej> :t mapExceptT (>>= either f pure)
01:38:24 <lambdabot> (FromExpr (n (Either e' b)), Show a, Monad n) => ExceptT a n (Either e' b) -> ExceptT e' n b
01:38:31 <phadej> :t \f -> mapExceptT (>>= either f pure)
01:38:32 <lambdabot> Monad n => (a -> n (Either e' b)) -> ExceptT a n (Either e' b) -> ExceptT e' n b
01:38:58 <phadej> :t \f -> mapExceptT (>>= either f (pure . Right))
01:38:59 <lambdabot> Monad n => (a -> n (Either e' b)) -> ExceptT a n b -> ExceptT e' n b
01:39:04 <phadej> close enough
01:39:17 <phadej> :t \f -> mapExceptT (>>= either (fmap Left . f) (pure . Right))
01:39:18 <lambdabot> Monad n => (a -> n e') -> ExceptT a n b -> ExceptT e' n b
01:40:37 <absence> that's surprisingly complicated :)
01:41:52 <jle`> :t \f -> mapExceptT (bitraverse f pure)
01:41:53 <lambdabot> error:
01:41:53 <lambdabot>     • Variable not in scope:
01:41:53 <lambdabot>         bitraverse
01:42:01 <jle`> @let import Data.Bitraversable
01:42:03 <lambdabot>  Defined.
01:42:05 <jle`> :t \f -> mapExceptT (bitraverse f pure)
01:42:06 <lambdabot> Applicative n => (a1 -> n e') -> ExceptT e (Either a1) a2 -> ExceptT e' n (Either e a2)
01:42:21 <jle`> ah
01:43:34 <jle`> :t \f -> mapExceptT (bitraverse f pure =<<)
01:43:35 <lambdabot> Monad n => (a -> n e') -> ExceptT a n b -> ExceptT e' n b
01:44:06 <absence> ooh
01:44:25 <jle`> too bad there's no traverseFirst / traverseSecond
01:45:22 <phadej> traverseSecond = traverse
01:45:40 <phadej> except for (,,) :P
01:47:33 <absence> thanks!
01:59:33 <delYsid`> I have three modules in a hierarchy: Types, Import and Export.  Both Import and Export import Types.  However, I would like to define a Pretty instance in Export for a type in Types.  Is there a better way to organize this, or are orphan instances OK in that case?
02:00:59 <delYsid`> Merging all three modules into one gives a bunch of name clashes which I'd like to avoid.  So it is either orphan instances or qualification.  Wahts the lesser evil?
02:02:18 <merijn> delYsid`: Why not define the Pretty instance in Types?
02:06:39 <delYsid`> merijn: Because it needs functions from Export, which depends on Types.
02:06:46 <delYsid`> s/depends on/imports/
02:07:24 <delYsid`> That sounds like a circular import.
02:07:48 <merijn> Yeah...sounds like merging the circular bits will be the easiest option
02:14:08 <phadej> or/and splitting the hierarchy to be more precise
02:14:48 <phadej> T1 -> E1 -> T2 -> E2
02:15:11 <phadej> and then Types are import T1; import T2 and Export is import E1 and E2
02:31:20 <delYsid`> phadej: I didnt parse that.
02:33:07 <lavalike> I think he means Types becomes Types1 and Types2, same for Export, so that you can define the Pretty instance in Types2 because the stuff you need from Export is in Export1 now.
02:33:41 <delYsid`> merijn: The "easiest" option looks like to define an orphan instance for a type from Types in Export.  However, orphans are frowned upon I guess.
02:35:00 <delYsid`> both import and export depend onthe same type from Types, so splitting doesnt seem to work.
02:36:25 <phadej> Export imports Import ?
02:36:30 <phadej> you didn't say that, did you
02:38:05 <phadej> I'm trying to say that reorganising modules in their "natural" order first might help with cycles. And then you can create "bundle" modules to act as public interface
02:38:32 <phadej> often natural order is the same as public interface, sometimes it isn't
02:39:29 <phadej> and I have noticed that having "big" `Types` module contributes to cycle problem
02:39:47 <phadej> having a module per Type (with associated functionality) feels to work better
02:40:10 <phadej> or a Class
02:40:13 <delYsid`> OK, so back to merging all three modules into one.
02:40:33 <phadej> One way, is to draw the dependency graph
02:40:50 <phadej> there are no tool for that, so it's manual, but enlightning process
02:40:54 <phadej> "what depends on what"
02:42:13 <phadej> (I consider single Types module an anti-pattern; at some point it will become too big; and then splitting will be a pain)
02:42:36 <phadej> same with "Helpers" or "Utils"
02:42:37 <merijn> phadej: The problem is that I very often find myself having no choice when having mutually referencing datatypes
02:42:52 <phadej> merijn: I'm sure that's not the case in delYsid` example
02:42:58 <merijn> phadej: I don't *want* a Types module, GHC lack of recursive imports forces me too
02:43:17 <AfC> Is there an obvious way to choose between Data.Array and Data.Vector?
02:43:18 <phadej> merijn: you can make types parametric, and tie the know outside
02:43:22 <merijn> Yes, no, maybe
02:43:27 <merijn> phadej: Sometimes, far from always
02:43:27 <phadej> AfC: Vector
02:43:42 <merijn> AfC: Vector, unless you require 2 or more dimensional data
02:44:24 <AfC> My data isn't large. I mostly just want a list with finite length (as opposed to [] lists)
02:44:46 <merijn> AfC: That's not really relevant, tbh :p
02:45:01 <merijn> vector is <3
02:45:09 <AfC> Yeah alright
02:45:28 <koz_> Where can I find Haskell source?
02:45:32 <koz_> s/Haskell/GHC/
02:45:38 <koz_> Argh, long week, lol.
02:45:43 <phadej> koz_: gitlab.haskell.org
02:45:43 <slack1256> there is a mirror on github
02:45:44 <merijn> koz_: gitlab and the github mirror? :p
02:45:59 <phadej> AfC: yet, if the list is small, then [] is probably good enough too
02:46:03 <koz_> merijn, phadej: Yeah, thanks. It's been a _very_ long week.
02:46:07 * koz_ goes and checks that.
02:47:00 <AfC> I just realized that a newtype over [] would be a sufficient differentiator (duh, what else is new)
02:48:08 <AfC> I have infinite lists in play, and wanted to differentiate when I had selected a finite subset.
02:57:04 <slack1256> AfC: You can work with that newtype painlessly via Data.Coerce
03:01:47 <AfC> slack1256: that's a good suggestion, thanks
03:03:55 <koz_> OK, I'm getting something weird. I'm trying to build GHC from a tarball, but it's complaining that it's missing the GMP tarball for some reason.
03:06:20 <slack1256> koz_: it's not asking for the library, it's asking for the tarball? weird
03:06:24 <slack1256> Are you on windows?
03:06:30 <koz_> slack1256: Linux.
03:10:14 <koz_> slack1256: Want the exact error?
03:10:42 <slack1256> ok
03:11:38 <koz_> slack1256: http://ix.io/1FYh
03:12:32 <slack1256> how to solve it's right there though
03:12:46 <slack1256> any reason why are you building from phase0?
03:13:22 <koz_> I just got a tarball, extracted it, did autoreconf, configure.
03:13:30 <koz_> Was I not meant to?
03:13:46 <koz_> (also, git submodule update won't work, since it's a tarball not a git repo)
03:13:59 <koz_> s/repo/tracked thing I dunno I'm tired/
03:14:10 <slack1256> well you could get the repo at the correct revision
03:14:19 <slack1256> or do a git --clone --depth=1000
03:14:24 <koz_> slack1256: OK, I can try that.
03:14:32 <slack1256> so it just gets "just enough" of the main repo
03:14:55 <slack1256> phase0 IIRC is what you use to bootstrap a compiler on a new platform (say ARM9
03:15:19 <slack1256> if you already have a working GHC, you can start at phase2 which is the final
03:16:08 <koz_> I have a working GHC.
03:16:12 <koz_> How do I get a phase2?
03:16:21 <slack1256> I think it's a configure flag
03:23:10 <koz_> No such option I can see.
03:24:34 <slack1256> maybe someone else can help
03:24:49 <slack1256> check the ghc.mk file
03:25:05 <koz_> slack1256: I'll lurk and see, I guess.
03:31:05 <domenkozar> johnw: yeah, did you solve it?
03:31:12 <domenkozar> maybe I should have given you our code..
03:32:34 <domenkozar> or just https://github.com/haskell-servant/servant/blob/master/servant-conduit/example/Main.hs
03:46:33 <kqr> Maybe a -> Maybe b -> Maybe (a, b)  -- feels a little like currying
03:46:35 <kqr> (Maybe a, Maybe b) -> Maybe (a, b)  -- feels a little like a monadic join
03:46:37 <kqr> I assume these are established concepts, but what are their names?
03:47:19 <kqr> maybe more generally,  Alternative f => f a -> f b -> f (a, b)... can I hoogle in here?
03:47:55 <Taneb> :t liftA2 (,)
03:47:56 <lambdabot> Applicative f => f a -> f b -> f (a, b)
03:48:17 <kqr> hm, yeah, that's a good point
03:48:19 <lavalike> :t uncurry $ liftA2 (,)
03:48:20 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
03:48:34 <kqr> very good points!
03:49:43 <Taneb> It might feel like monadic join because they're both a monoidal operation in the category of endofunctors, albeit with different tensor products
03:50:41 <kqr> I understood a surprising large degree of those words!
03:50:55 <Taneb> Then you're doing pretty well ;)
03:52:10 <lyxia> I wonder whether there is something that makes category so good at explaining similarities between otherwise disparate concepts, or I'm just biased.
03:52:34 <Taneb> lyxia: that is what category theory is designed to do
03:52:51 <lyxia> oh, good point :)
03:53:44 <kqr> either way, the reason I ask, so I don't run into XY issues, is this: at my current workplace I was encouraged to try out F#, which seems nice given my Haskell background. however, many of the more abstract abstractions I'm used to are not available by default, so instead of asking coworkers to implement their own homebrew versions, I thought I might as well compose a little util library on solid foundations
03:53:46 <kqr> once and for all.
03:53:48 <kqr> I'm currently looking to find a common ground on which to implement both
03:53:50 <kqr> (a -> b -> ()) -> Maybe a -> Maybe b -> ()
03:53:52 <kqr> and
03:53:54 <kqr> (a -> b -> Bool) -> Maybe a -> Maybe b -> bool
03:53:56 <kqr> and I feel like one of the key components of that is
03:53:58 <kqr> Maybe a -> Maybe b -> Maybe (a, b)
03:54:00 <kqr> but I might be very wrong!
03:54:13 <lyxia> Would you know any piece of writing that discusses how CT was "designed" with that goal in mind?
03:54:25 <Taneb> I don't, I'm afraid :(
03:54:58 <ski> missing `Maybe Bool -> Bool' ?
03:56:10 <ski> kqr : are those side-effectful ?
03:56:41 <ski> perhaps instead of `Bool', you'd like `Maybe ()' ?
03:57:27 <ski> kqr : does F# already define `option' ?
03:57:42 <kqr> ski, not missing – if one of the two are Nothing the result is false
03:57:54 <ski> i suspected so
03:57:56 <Taneb> :t fromMaybe mempty 
03:57:57 <lambdabot> Monoid a => Maybe a -> a
03:58:08 <ski> so then you could use `Maybe ()', as i said ?
03:58:30 <kqr> ski, F# has an option type, yes. there's also a FSharpPlus library which brings in a bunch of useful abstractions that I would like, but I have met some resistance trying to introduce that, so I thought I should do a soft warmup with just safe and simple things
03:58:44 <kqr> ski, not sure how Maybe () would do it...
03:59:10 <ski> @let infixl 4 <*>>; (<*>>) :: Monad m => m (a -> m b) -> m a -> m b; mamb <*>> ma = join (mamb <*> ma)
03:59:11 <lambdabot>  Defined.
03:59:42 <kqr> lyxia, isn't that just what generalisation/abstraction is about? then CT happens to be one of the more general/abstract languages we can talk about things in
03:59:53 <ski> @let bindM2 :: Monad m => (a -> b -> m c) -> (m a -> m b -> m c); bindM2 f ma mb = f <$> ma <*>> mb
03:59:54 <lambdabot>  Defined.
04:00:30 <ski> @type bindM2 :: (a -> b -> Maybe ()) -> Maybe a -> Maybe b -> Maybe ()  -- looks like what you were wanting, kqr ?
04:00:31 <lambdabot> (a -> b -> Maybe ()) -> Maybe a -> Maybe b -> Maybe ()
04:00:44 <kqr> lyxia, when I write software, one of my main criteria for a good design is whether it's capable of pulling together seemingly disparate things under one implementation. things get abstract, but that's IMO also how things get maintainable and safe
04:01:05 <ski> kqr : `Nothing' corresponds to `False', and `Just ()' to `True'
04:01:50 <kqr> ski, ohh, right. yeah, that would work
04:02:27 <Taneb> I should learn how to explain the Day convolution...
04:02:28 <ski> @let bindM3 :: Monad m => (a -> b -> c -> m d) -> (m a -> m b -> m c -> m d); bindM3 f ma mb mc = f <$> ma <*> mb <*>> mc  -- just for comparision
04:02:29 <lambdabot>  Defined.
04:02:43 <kqr> right, yeah. thank you so much!
04:02:52 <ski> (and `bindM1' is of course just `(=<<)', while `bindM0' would be `id')
04:03:23 <ski> kqr : but you could also use Taneb's missing piece, if you prefer
04:03:24 <lyxia> kqr: my question is what makes CT in particular so good at that/so abstract. (It's a vague question, so vague answers are expected, but I wouldn't be so surprised if someone comes up with a categorical argument :))
04:03:43 <lyxia> Like, why are we not doing monoid theory instead
04:04:10 <Taneb> "Adjoint functors arise everywhere"
04:04:49 * ski . o O ( "The Unreasonable Effectiveness of Category Theory in the Formal Sciences" )
04:04:49 <kqr> lyxia, that question feels a little like asking "what makes Earth in particular such a good place for humans to live?"
04:06:25 <lyxia> ski: that title sounds exciting!
04:06:36 <kqr> lyxia, i.e. the answer is probably something close to "survivor bias"
04:06:53 <ski> lyxia : perhaps someone ought to write it, then !
04:07:56 <lyxia> Haha I didn't notice that's not the title of the PDF a search with this title turns up.
04:09:20 <Ariakenom> the pdf that turns up is interesting too
04:14:17 * hackage Agda 2.6.0 - A dependently typed functional programming language and proof assistant  https://hackage.haskell.org/package/Agda-2.6.0 (AndresSicardRamirez)
04:17:05 <lyxia> kqr: Sure that's quite a reasonable answer, but we can still look at bits of humans and notice that some of the observed structures, thanks to evolution, happen to coincide with solutions of local optimization problems. That does give a deeper understanding of why things are the way there are, even if a complete understanding may not ever be reached.
04:18:33 <kqr> lyxia, I'm not dismissing your question, I'm just not (yet) seeing a perspective from which it can produce a useful answer. that's probably a limit of myself, and not the question!
04:19:34 <lyxia> :)
04:19:57 <kqr> lyxia, maybe part of it is that I feel like in order to be able to give a satisfying answer to "what makes CT so abstract", you have to use language that abstracts over the various components at CT, and at that point, CT is no longer the most abstract language we can talk about things in!
04:20:22 <kqr> but then again, there may be a subtle distinction between "most abstract" and "straddles the line between abstract and intuitive" – and you might be more interested in the latter
04:24:57 <lyxia> I don't know what I'm looking for either :)
04:26:14 <lyxia> But thanks for the discussion, it's comforting to know I'm not the only one who's lost there.
04:49:13 <fen> Ok, so there is a problem because the base functor for a nonempty list of lists matches that of list of nonempty lists
04:50:25 <fen> this is the simplest form of the problem that any nesting of either list or nonempty list has indistinguishable base functors from any other nesting with the same proportion of list and nonempty list
04:52:17 <fen> this means there is a problem in trying to form equivalence classes of nested containers, where we cannot determine the original nesting from the base functor used
04:54:00 <fen> (a,s) -> Maybe (a,Maybe s) is the "state" (with corresponding dual, the argument to its fold) which unfoldes *either* a `list of nonempty lists' or a `nonempty list of lists'
04:56:08 <fen> the more nested version is (a,s) -> MaybeN n (a,MaybeN m s), where n+m is the depth of nesting, regardless of the order the containers are nested within each other
04:56:38 <fen> data MaybeN n a = NothingN (BoundedNat n) | JustN a
04:59:00 <fen> a list of bools of length (n+m) equal to the total depth of nesting of the containers has (n+m)^ informations, while the state above has only (n+m) corresponding to the different *proportions* of list to nonempty list appearing in the nesting
05:00:24 <fen> StateN m n a s = (a,s) -> MaybeN n (a,MaybeN m s), is like a slider along the numbers [0..m+n] (maybe off by 1 somewhere)
05:01:31 <fen> to solve this, in the simplest case it would correspond to something like (a,s) -> Maybe (a,Maybe s), which can be used to unfold *either* a `list of nonempty lists' or a `nonempty list of lists' 
05:01:48 <fen> but that was distinguishable in each case
05:01:59 <fen> where this would extend to the StateN version also
05:02:09 <fen> .
05:10:15 <fen> (n+m)^2 informations
05:11:28 <fen>  / choices
05:20:05 <atennapel> Hi, I'm looking for some concise practical examples of STRef
05:20:25 <atennapel> Where dynamic allocation is actually used, so not factorial or fibonacci
05:20:45 <atennapel> Could anyone here point in a direction? :)
05:22:01 <merijn> atennapel: You mean STRef specifically, or just practical usage of ST in general?
05:22:36 <atennapel> STRef preferred, but in general would also be good
05:22:55 <merijn> atennapel: I think the most useful/obvious example of ST would be in the vector package
05:23:08 <merijn> atennapel: Which lets you construct pure/immutable vectors via mutable ST operations
05:23:59 <phadej> I guess, edit-distance is one good example: https://github.com/phadej/edit-distance/blob/master/Text/EditDistance/STUArray.hs
05:24:38 <phadej> last time I tried, non-ST implementation would have worse constant factors than ST-based
05:25:47 * hackage haskoin-node 0.9.7 - Haskoin Node P2P library for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-node-0.9.7 (xenog)
05:26:55 <atennapel> Thanks for the suggestions
05:27:08 <ski> atennapel : logic variables
05:27:16 <atennapel> I'm writing a thesis related to ST, having trouble thinking of a concise example that shows the need for ST
05:27:23 <delYsid`> Ouch, 60GB or memory use for parsing a 1GB file...
05:27:36 <merijn> delYsid`: Textual data?
05:27:37 <atennapel> Logic variables?
05:27:46 <ski> as in Prolog
05:28:10 <delYsid`> merijn: ASCII, YES.
05:28:17 <delYsid`> PARSING INTOA dATA.tREE
05:28:18 <merijn> delYsid`: Are you using String?
05:28:24 <delYsid`> woops, sorry for shouting
05:28:37 <delYsid`> merijn: nope, already using ByteString
05:28:40 <ski> @google typed logical variables in Haskell Koen Claessen
05:28:43 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.718.2329&rep=rep1&type=pdf
05:28:55 <merijn> do you have an example parser? I suspect a problem :p
05:31:13 <ski> atennapel : that paper shows how one can implement them in terms of `STRef'
05:31:21 <fen> can anyone think of a way to represent the base functor for nested list and nonempty list?
05:31:31 <delYsid`> merijn: https://github.com/mlang/chessIO/blob/master/src/Game/Chess/PGN.hs
05:32:18 <fen> it would have to have the order of the nesting
05:32:49 <ski> do you mean an `F' such that `Mu F a = [[a]]' ?
05:32:55 <fen> not sure the thing above with l=n+m is correct, probably actually l=n=m
05:33:21 <fen> ski: yes, Mu or Fix like in recusion schemes
05:33:45 <fen> but, for deeper nestings and where some of the layers are nonempty
05:34:40 <fen> oh is that right?
05:34:44 <fen> hmm maybe not
05:34:52 <merijn> delYsid`: So you have "[(ByteString, String)]" return by part of your game parser. How many entries does that have?
05:34:53 <fen> that relies on a theorem of equivalence
05:35:03 <fen> between the state of the unfold and the base functor
05:35:11 <fen> not sure if that holds for nested things
05:35:15 <ski> which `F' would you suggest in that situation ?
05:35:22 <fen> certainly seems to be the case for the 1 depth things
05:35:26 <ski> (also note that `Mu' is not injective)
05:35:41 <atennapel> ski: thanks, looking at it now
05:35:49 <fen> ski: i cant approach it like that until its sure thats an approach that leads to the state for an unfold
05:36:33 <fen> maybe to prove that it would need us to consider the depth 2 case from both angles, see if they are the same and see if that can give a proof by induction to higher cases
05:36:51 <ski> atennapel : if you want to, you could check out the earlier Silvija Seres, and Mike Spivey paper, that that Claessen & Ljunglöf one is based on. that previous paper doesn't use `STRef's, though, just plain substitution, iirc
05:38:41 <fen> ski: your question has a simple answer however. [[a]] is unfolding from state `s -> 
05:38:48 <delYsid`> merijn: Just about seven per game, not really much.  But I could try to change String to Text I guess
05:39:04 <fen> wait, sorry the state given in the original question was wrong. list of nonempt and nonempty of list has state of; s -> Maybe (a,Maybe s)
05:39:25 <ski> atennapel : .. i once did a prototype implementation of a logic programming engine (novel feature being goal implication, which one could left-nest. this required being able to backtrack backtracking itself (and backtrack backtracking backtracking, &c.)), that was partially based on that paper
05:39:25 <fen> [[a]] has state of s -> Maybe (Maybe (s,a))
05:39:26 <merijn> delYsid`: Anyway, first step: Do a profiling build and profile your memory usage :)
05:40:04 <ski> (it used a potentially infinitely deeply nested continuation monad transformer stack)
05:40:04 <fen> "nonempty of nonempty of a" has state of `s -> (a,Maybe (Maybe s))
05:40:23 <ski> fen : what does that have to do with `Mu' ?
05:40:29 <atennapel> cool, I implemented kanren a couple of times
05:40:41 <atennapel> can't wait for Edward kmett Guanxi talk as well
05:40:52 <delYsid`> Right.  Gotta relearn how profiling works.  Last time I was turned off was when I realized it produces PostScript output.  Not quite what a blind guy wants :-)
05:40:55 <fen> ski: if thats not obvious, its also something i cant determine 
05:41:36 <fen> but, its clearly not the base functor F that you asked for
05:41:49 * ski isn't even sure what fen means by "folding" and "unfolding" here
05:41:52 <fen> so apparently the state in only the same as the base functor in the depth 1 case...
05:42:03 <fen> if thats a coincidence it would be good to understand why
05:42:14 <fen> :t unfoldr
05:42:15 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
05:42:50 <ski> that's really about `nu s. 1 + a * s', though, with `nu' rather than `mu'
05:43:02 <fen>  :t foldr === (Maybe (a, b) -> b) -> [a] -> b
05:43:04 <ski> (perhaps you're not concerned about that, dunno)
05:43:25 <fen> that might be the best way to approach it actually
05:43:36 <ski>      [a]
05:43:42 <fen> nu is about the state encoding isnt it?
05:43:45 <kuribas> atennapel: mutating a vector?
05:43:47 <ski>   =  mu r. 1 + a * r
05:43:59 <ski>   =  forall r. (1 + a * r -> r) -> r
05:44:15 <ski>   =  forall r. (1 -> r) * (a * r -> r) -> r
05:44:22 <ski>   =  forall r. r * (a -> r -> r) -> r
05:44:27 <ski>   =  forall r. r -> (a -> r -> r) -> r
05:44:30 <kuribas> atennapel: you can do that functionally, but it has a different complexity
05:44:48 <kuribas> atennapel: O(1) vector update is not possible functionally.
05:44:53 <ski>      Stream a
05:45:03 <ski> actually
05:45:12 <ski>      PotentiallyFiniteStream a
05:45:19 <ski>   =  nu s. 1 + a * s
05:45:24 <fen> nonempty?
05:45:27 <atennapel> I was hoping for an example that shows of the dynamic allocation of references instead of for example the State monad, where you get only one state "cell"
05:45:28 <ski>   =  exists s. s * (s -> 1 + a * s)
05:45:45 <ski> no, both of these can be empty
05:45:55 <fen> oh ok
05:45:57 <atennapel> I've seen factorial and fibonacci examples, but they have a static amount of references
05:45:59 <ski>      NonEmptyList a
05:46:06 <kuribas> atennapel: you dynamically create a new vector
05:46:10 <ski>   =  mu r. a * (1 + r)
05:46:23 <ski>   =  forall r. (a * (1 + r) -> r) -> r
05:46:36 <ski>   =  forall r. (a -> (1 + r) -> r) -> r
05:46:36 <merijn> atennapel: Maybe lookup a quicksort implementation using STRef?
05:46:50 <ski>   =  forall r. (a -> (1 -> r) * (r -> r)) -> r
05:46:58 <ski>   =  forall r. (a -> r * (r -> r)) -> r
05:47:18 <ski>   =  forall r. (a -> r) * (a -> r -> r) -> r
05:47:21 <ski>   =  forall r. (a -> r) -> (a -> r -> r) -> r
05:47:26 <fendor> @pl const $ flags
05:47:26 <lambdabot> const flags
05:47:35 <fendor> @pl (const $ flags)
05:47:35 <lambdabot> const flags
05:47:41 <fendor> :t (const $ flags)
05:47:43 <lambdabot> error: Variable not in scope: flags
05:47:44 <ski>      PotentiallyFiniteNonEmptyStream a
05:47:50 <fen> !!
05:47:54 <ski>   =  nu s. a * (1 + s)
05:48:08 <ski>   =  exists s. s * (s -> a * (1 + s))
05:48:17 <ski>   =  exists s. s * (s -> a) * (s -> 1 + s)
05:48:48 <ski> fen : dunno whether these calculations help or not ..
05:48:55 <fen> exactly!
05:49:11 <fen> well, they are there now
05:49:26 <fen> but can we understand if they are relevant!? 
05:49:39 <atennapel> merijn: mmm yeah quicksort could work, I'm also thinking of a shuffling algorithm with swapping elements of an array
05:49:56 <ski> i would perhaps help to understand the problem situation you're considering
05:50:04 <ski> s/i would/it would/
05:50:20 <merijn> atennapel: Really any form of array/vector manipulation is a simple usecase for ST :)
05:50:40 <ski> atennapel : it's very common with logic variables to dynamically create new ones (and commonly also of differing types)
05:51:02 <fen> well it seems to have been a misplaced desire to assign a base functor to nested containers, thinking this would be the same as the state used to unfold them
05:51:11 <ski> atennapel : i suppose you could also consider graph rewriting of some sort
05:51:53 <fen> but hang on, that literally is exactly what the recursive and corecursive classes do
05:52:05 <fen> im confused about how i got confused ther
05:52:23 <fen> yes, its literally just F for [[a]]
05:52:30 <ski> merijn : i suppose not counting the ones where immutable arrays suffice (like for top-down dynamic programming)
05:52:34 <fen> [[a]] has state of s -> Maybe (Maybe (s,a))
05:53:00 * ski doesn't understand what fen means by "has state of"
05:53:10 <fen> :t unfoldr
05:53:11 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
05:53:24 <fen> that is; "list has state of (b -> Maybe (a, b))"
05:53:24 <ski> i would say `b' is the state type there, if anything
05:53:53 <ski> `b -> Maybe (a,b)' would be the type of the state-updating callback/transition
05:54:04 <fen> well, the "state" is the `b' sure, so it has "state function type of"
05:54:08 <atennapel> ski: yeah logic variables (or simply unification) could work, but the example might become too involved
05:54:10 <fen> to be specific
05:54:43 <fen> state transition function fine...
05:55:11 <kuribas> merijn: do you need ST for logic variables though?
05:55:13 <fen> the "state encoding" is then a pair of the state with its transition function 
05:55:19 <kuribas> wouldn't a lookup map be easier?
05:55:22 <ski> (also i become confused when you say "dual", but don't actually talk about something which looks like a dual to me)
05:55:42 <ski> kuribas : less efficient
05:55:56 <fen> the costate transition? that of an incrament of fold?
05:56:09 <kuribas> ski: so then all logic computations live inside the ST?
05:56:12 <ski> (also there's the matter of persistent vs. ephemeral)
05:56:19 <fen> as the state transition is an incrament of unfold
05:56:53 <fen> (b -> Maybe (a, b)) <-> (Maybe (a, b) -> b)
05:57:14 <ski> kuribas : or inside a monad which supports mutable references. could also be `IO', e.g. (or `STM' ?) -- but most computations wouldn't necessarily need to know whether the base monad is `IO' or `ST s'
05:57:25 <fen> it is that duality at the heart of the "recursive" and "corecursive" classes of recursion schemes
05:57:41 <fen> ie, the relation between the base functors of instances of both
05:57:44 <kuribas> ski: so you would abstract  using a typeclass?
05:58:37 <ski> fen : i'm not sure i'd talk about "costate", re catamorphisms
05:58:51 <ski> kuribas : that's what i did, in my prototype, yes
06:00:03 <fen> why not?
06:00:14 <fen> the store comonad is similar
06:00:37 <fen> not as a reason for or against
06:01:28 <ski> how is `Store s a = (s,s -> a)' similar to `Maybe (a,r) -> r' for list cata ?
06:01:30 <fen> its not true that the base of recursive and corecursive are dual in this way?
06:02:01 <fen> because s = f a
06:02:02 <ski> i don't know (i don't know what you mean by "dual in this way")
06:02:13 <fen> no
06:02:15 <fen> um
06:02:50 <fen> Store s x = (s,s -> x),Maybe (a,r) -> r
06:03:22 <fen> s = f x, r = f a
06:03:37 <fen> sorry x = a, there is confusion
06:03:41 <fen> brb
06:23:17 * hackage extensible-effects-concurrent 0.21.1 - Message passing concurrency as extensible-effect  https://hackage.haskell.org/package/extensible-effects-concurrent-0.21.1 (SvenHeyll)
06:26:47 * hackage haskoin-core 0.9.0 - Bitcoin & Bitcoin Cash library for Haskell  https://hackage.haskell.org/package/haskoin-core-0.9.0 (xenog)
06:47:28 <gentauro> so there are no Haskellers on stackoverflow.com? https://insights.stackoverflow.com/survey/2019#most-loved-dreaded-and-wanted
06:47:54 <gentauro> I find it kind of "meh" that `Haskell` doesn't appers on this year survey ...
06:47:59 <gentauro> ;-)
06:55:54 <absence> i've seen some recommendations against ExceptT over IO because of issues with async, and because IO can throw any other exceptions than the one in the type signature anyway. instead it's suggested to use MonadCatch's throwM, but it's not a drop-in replacemen since it has an Exception constraint. so for functions that return IO (Either e a) where e isn't an exception, or functions returning IO (Maybe a) (a
06:56:00 <absence> ssuming MaybeT has the same async problems), it doesn't really work out. am i missing something?
06:57:47 * hackage haskoin-node 0.9.8 - Haskoin Node P2P library for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-node-0.9.8 (xenog)
06:58:27 <absence> for reference, this is one place i've seen this advice: https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell
06:59:17 <Rembane> absence: You can probably create functions that go from the types you have to the types you need.
07:00:45 <absence> Rembane: yes, but that's a pretty vague statement that can probably answer most haskell questions :)
07:01:32 <Rembane> absence: ^^
07:01:37 <Rembane> absence: That is indeed true.
07:02:11 <kirne> type Subject = String
07:02:11 <kirne> type Verb = String
07:02:11 <kirne> type Object = String
07:02:11 <kirne> data Sentence =
07:02:11 <kirne> 	Sentence Subject Verb Object
07:02:12 <kirne> 	deriving (Eq, Show)
07:02:16 <mmo> I am stuck for a few hours now and would be happy if someone give me an advice: I got an unboxed vector of elements v (:: Vector Element) and want to map a function computeResults (:: Element -> Vector Result) over it and then in a sense concat everything to get one big vector of all results (:: Vector Result). This process will happen millions of times in my program. Therefore it should be very effecient. Converting the element vector 
07:02:16 <mmo> to a list, then map computeResults and then concat to a new unboxed vector is not an option as the conversion to a list uses to much space and time. Is there a quick and efficient way for doing this? :)
07:02:16 <kirne> s1 = Sentence "dogs" "drool"
07:03:02 <Taneb> mmo: like Data.Vector.concatMap? ;)
07:08:16 <kuribas> mmo: the conversion to a list will likely fuse away
07:08:26 <kuribas> mmo: but like Taneb says concatMap is a better option
07:09:24 <kuribas> mmo: if computeResults can be inlined, that resulting vector can also be fused away
07:11:17 <kuribas> mmo: that should be very efficient
07:14:59 <mmo> Ok. Thank's I'll try that
07:44:19 <sagax> hi all!
07:47:44 <fendor> hi!
07:48:03 <sagax> we have haskell in 2018 https://insights.stackoverflow.com/survey/2018/  but where is haskell in 2019? https://insights.stackoverflow.com/survey/2019/
08:01:48 <zincy> sagax: I know right!
08:02:53 <kuribas> it's not even in the most dreaded languages!
08:02:58 <kuribas> how aweful!
08:03:43 <saml> is haskell dead 2019?
08:04:04 <kuribas> i don't think so
08:05:08 <Taneb> Haskell is achieving its primary objective: avoid success at all costs!
08:05:14 <aldum> why did they weigh this by gender again?
08:05:48 <Taneb> Because they thought it might be insightful, one presumes
08:06:32 <aldum> only if you're sexist, and think somehow it's very different, when a woman does it...
08:06:49 <aldum> loving their self-contradictory reasoning
08:09:47 * hackage telega 0.1.7 - Telegram Bot API binding  https://hackage.haskell.org/package/telega-0.1.7 (iokasimovmt)
08:13:41 <dmwit> What's self-contradictory? They explicitly say they believe the population of women is indeed different, and have data to back up that claim.
08:14:11 <dmwit> I don't see that it's necessary to be sexist to think it might be useful or insightful, either.
08:16:03 <zincy> What is that quote ... “If people do not believe that mathematics is simple, it is only because they do not realize how complicated life is.”
08:16:17 <zincy> Replace math with Haskell
08:27:12 <fen> so, still not sure how to worth with a version of recursion schemes over nested containers that attempts to find a type which serves as a parametrisation of the equivalence classes of these composite containers
08:29:49 <fen> having trouble finding a datatype which can serve as the base functor for nested containers which has as much information as the list of choices of which container to use, having restricted considerations to nonempty and list for now
08:32:05 <fen> so far have identified the state type used for lists, and nonempty lists, s -> Maybe (a,s) and s -> (a,Maybe s) respectively
08:33:23 <fen> but upon nesting these, s -> MaybeN n (a,MaybeN m s), seems to have only enough information to say the proportion of each type of container, but not the order they appear in the nesting
08:34:13 <fen> what datatype can we use as a base functor for nested list and nonempty lists to some depth?
08:40:49 <fen> perhaps the example identified before should be a good first step, trying to find the base functors for depth 2 nested linst and nonempty list recursion schemes
08:41:20 <fen> these 4 cases should serve as an inductive step
08:41:46 <fen> the nonempty of nonempty is; s -> (a,Maybe (Maybe s))
08:42:02 <fen> list of list is; s -> Maybe (Maybe (a,s))
08:42:23 <fen> and both list of nonempty, and nonempty of list is; s -> Maybe (a,Maybe s)
08:42:45 <fen> which is where we first encounter the problem of the order of nesting not being reflected in the base functor
08:43:14 <fen> and should help us understand what "more informational" representation of the base functor might look like
08:44:01 <fen> so that instead of the implementation details being all that captures the difference between the way this s -> Maybe (a,Maybe s) is used 
08:44:09 <Taneb> Where do these types come from?
08:44:29 <fen> you mean, what are the implementations of the instances of recursive and corecursive?
08:46:53 <fen> the "dea is that you "unfold" as far as you can the inner most list, then start again on the next of these, so unfolding the second layer
08:47:00 <fen> idea*
08:47:57 <fen> basically obtaining a base functor for the one depth less nested version, upon unfolding the overall state
08:48:21 <fen> and then inductively repeating this process until reaching that basecase 
08:50:15 <fen> cata :: (Base t a -> a) -> t -> a
08:51:12 <fen> so that `Base t a' should be recursive
08:51:22 <fen> maybe a = Base t' a'
08:51:48 <fen> where t' is related to t by being one level more nested
08:51:57 <fen> sorry thats really confused
09:28:47 * hackage amqp-worker 0.3.2 -   https://hackage.haskell.org/package/amqp-worker-0.3.2 (seanhess)
09:45:17 * hackage haskoin-node 0.9.9 - Haskoin Node P2P library for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-node-0.9.9 (xenog)
09:45:49 <ababcd> Hey, I have this function: `parseLine ln = map (read::String->Int) $ words ln`. How can I write it without `ln` in the definition?
09:46:38 <systemfault> Compose (.)
09:46:54 <ababcd> Oh, of course. Thanks!
09:47:33 <lavalike> ?pl \ln -> map read $ words ln
09:47:33 <lambdabot> map read . words
09:47:59 <lavalike> @botsnack
09:47:59 <lambdabot> :)
09:49:19 <boblehest> ?pl \f xs -> sum (map f xs)
09:49:19 <lambdabot> (sum .) . map
09:49:56 <boblehest> neat
09:53:31 <fen> is there a way to write inductive instances for recursion schemes on nested containers?
10:04:44 <ababcd> ?pl \fn -> fromIntegral (length $ filter fn xs) / fromIntegral (length xs)
10:04:44 <lambdabot> (/ fromIntegral (length xs)) . fromIntegral . length . flip filter xs
10:04:56 <ababcd> that's awesome
10:07:12 <merijn> I think you misspelled awful :p
10:13:33 <Solonarv> gets a bit unreadable
10:14:41 <Solonarv> :t let (//) = (/) `on` (fromIntegral . length) in \f -> filter f xs // xs -- ;)
10:14:43 <lambdabot> error:
10:14:43 <lambdabot>     • Variable not in scope: xs :: [a]
10:14:43 <lambdabot>     • Perhaps you meant one of these:
10:14:49 <Solonarv> :t let (//) = (/) `on` (fromIntegral . length) in \f xs -> filter f xs // xs -- ;)
10:14:50 <lambdabot> Fractional c => (a -> Bool) -> [a] -> c
10:16:05 <Solonarv> or:
10:16:05 <Solonarv> :t let (//) = (/) `on` fromIntegral; count f = length . filter f in \f xs -> count f xs // length xs
10:16:06 <lambdabot> Fractional c => (a -> Bool) -> [a] -> c
10:22:17 * hackage symantic-http 0.1.1.20190410 - Symantic combinators for deriving clients or a server from an HTTP API  https://hackage.haskell.org/package/symantic-http-0.1.1.20190410 (julm)
10:23:17 * hackage symantic-http-test 0.0.1.20190410, symantic-http-client 0.0.1.20190410, symantic-http-server 0.1.1.20190410 (julm)
10:25:46 <dmwit> Solonarv: cute
10:29:22 <johnw> domenkozar: I did, using conduitToSourceIO, which is actually much easier to use
10:31:36 <phadej> i wrote that one, glad it's useful (I have no context :)
10:36:17 <johnw> phadej: thank you!!
10:36:26 <johnw> I'm using it to create servant streaming endpoints
10:38:36 <phadej> do you have some newtype over Conduit to implement ToSourceIO; or how your API look like?
10:43:53 <phadej> (I'm interested in how streaming is used, as it's not perfect, but I don't want to kill any existing use cases either)
11:16:24 <johnw> umm.. no
11:16:39 * shapr blinks
11:17:14 <johnw> phadej: using servant-conduit
11:29:38 <phadej> johnw: so you use raw Conduit (or StreamIO) in the type API = ... :> Stream ... ?
11:30:27 <phadej> I'd really need to make that clear, that it's as bad idea (i.e. not bad if you really know what you are doing) as Get '[OctetStream] ByteString
11:30:32 <johnw> I have: StreamGet DoubleNewlineFraming EventStream (Headers StreamingHeaders (SourceIO ConsoleOutput))
11:30:42 <johnw> where I've defined DoubleNewlineFraming, EventStream, StreamingHeaders and ConsoleOutput
11:31:06 <phadej> of, so you actually use framing!
11:31:17 <johnw> then I just do: return $ addHeaders $ conduitToSourceIO $ forever $ yield foo
11:31:36 <johnw> yeah, framing helps make the output readable when watching it with curl
11:32:01 <phadej> why not Conduit directly in the API, if you do it this way?
11:32:26 <johnw> because I had no idea how?
11:32:36 <johnw> this stuff isn't documented in a way that I could discover it, yet
11:32:46 <johnw> I basically got to this point by doing whatever I could to make the compiler happy
11:33:05 <johnw> and it still doesn't work, btw, i'm streaming client dies with ConnectionClosed and I haven't figure out yet why
11:34:14 <phadej> johnw: https://github.com/haskell-servant/servant/blob/master/servant-conduit/example/Main.hs#L38 it's indeed not well documented
11:34:31 <phadej> but I don't want to document it too well either, as we might change stuff in the next version, once again
11:34:51 <phadej> streaming resists to be solved once for good
11:35:51 <johnw> as a user, it's been a pain
11:36:13 <johnw> I love servant, but it's almost becoming more work than it's worth with all these deep changes
11:37:53 <phadej> it's unfortunate when you are happy with current state of servant; but there are people who aren't. Dilemma
11:43:18 <johnw> I wouldn't say I was happy with the previous incarnation; the conduit rendition is a vast improvement
11:43:55 <johnw> it's just working code that I'd like to stop changing at some point :)
11:44:47 * hackage wai-routes 0.10.4 - Typesafe URLs for Wai applications.  https://hackage.haskell.org/package/wai-routes-0.10.4 (AnupamJain)
12:03:29 <fen_> hi, is anyone using recursion schemes?
12:03:59 <golergka> Hi. I wanted to ask for help with cis194 course.
12:04:25 <golergka> There's a homework assignment there that I can easily do with Google, but can't do with just the material from the lecture (and I assume I should be able to).
12:04:53 <fen_> what extra info did you need?
12:04:58 <golergka> It asks me to double every other integer in the list, but from the end.
12:05:17 <fen_> what does that mean, "from the end"?
12:05:23 <golergka> The lecture only explains the most basic list pattern matching. I don't understand how to use it to iterate on the list from the end (not from the beginning).
12:05:27 <fen_> you mean foldr?
12:06:06 <golergka> fen_: foldr looks like it fits, but as I said, I thought I should be able to do it just with the material from the lecture https://www.seas.upenn.edu/~cis194/spring13/lectures/01-intro.html
12:06:19 <fen_> you would be very difficult to derive foldr just from that requirement
12:06:49 <fen_> you could be able to derive foldr from no material at all, but its just very difficult thats all
12:07:11 <golergka> I think that foldr is explained later in the course; this homework is assigned right after explaining things like sumEveryTwo (x:(y:zs)) = (x + y) : sumEveryTwo zs
12:07:36 <golergka> which makes me think that there should be some clever trick that I can use just with this primitive pattern matching
12:08:12 <fen_> those notes are not sufficeint material for that question you can be reasured of that
12:08:35 <fen_> there is no preperatory notions of understanding the difference between foldl and foldr
12:09:00 <golergka> it's not about difference between foldl and foldr, it's just about using the index from the end of the list
12:09:07 <golergka> here's the homework link: https://www.seas.upenn.edu/~cis194/spring13/hw/01-intro.pdf
12:09:15 <opqdonut> hmm I think using reverse is the simple way to do that
12:09:22 <golergka> it says "Remember that doubleEveryOther should double every other number beginning from the right, that is, the second-to-last, fourth-to-last, . . . numbers are doubled."
12:09:29 <golergka> so I just reverse the list, process, then reverse back?
12:09:46 <golergka> I was sure I'm really missing some way to pattern-match the end of the list...
12:09:53 <opqdonut> yeah there's no way to do that
12:09:53 <fen_> not sure why they would push you to skip ahead like that, maybe the idea is to make you struggle needlessly to instill some form of frustration to build up to a sense of satisfaction upon understanding. not sure if thats a teaching style or a form of psycological abuse to be honest!
12:10:01 <Solonarv> there's no way to (directly) pattern match on the end of a list
12:10:11 <Solonarv> reverse - process - reverse back should work
12:10:28 <golergka> oh, OK. I just thought that they wouldn't mean something as wasteful
12:11:01 <fen_> oh the reverse opperate reverse thing is more like what we would call a "snoc" list
12:11:04 <golergka> but maybe it's not really wasteful in Haskell and I just don't understand how execution model works here. Thanks for the help!
12:11:13 <Solonarv> no, it is pretty inefficient
12:11:17 <Solonarv> but it works
12:11:40 <Solonarv> I know there's a better way but I can't remember it right now, and I can't be bothered to derive it from scratch either
12:12:07 <golergka> Solonarv: I am absolutely sure there is, I even googled up a couple, but I wanted to complete these assignments the "right" way, going from the basics
12:12:17 <fen_> well the more interesting question is if a snoc zipper navigated to the end actually needs to do any more compulational work
12:12:39 <fen_> like, why snoc as cons following rewind actually needs to incur the cost of reversing the list
12:12:58 <fen_> but thats certainly not something you would ask of a student on first contact!
12:13:46 <Solonarv> you can do something like this: compute "double every even entry" and "double every odd entry" while traversing the list; then when you get to the end you decide which one to return
12:14:38 <fen_> yeah but thats not exactly a snoc list is it? would need to traverse the whole thing just to get to the end
12:15:07 <fen_> never mind breaking the fixed length traversal law
12:15:08 <golergka> Solonarv: but I would "get" to the end via recursion... so I don't really understand how do I make this decision and how do I pass these parameters around in recursion-based code
12:15:14 <Solonarv> there's no way around that, fen_
12:15:36 <Solonarv> you can't decide whether a list is even-length or odd-length without computing its length, which requires traversing the entire spine
12:16:29 <fen_> golergka, the question is ambiguous, it doesnt actually do one computation before the other
12:17:01 <fen_> foldl and foldr can both be written like mapAccumL and mapAccumR, just traversing with a different thing
12:17:18 <fen_> maybe it would be better to think of doing all the computations at the same time
12:17:34 <fen_> hmm, well, maybe not as you couldnt do them seperatly
12:17:48 <fen_> just that the actual order of evaluation is commutative
12:17:56 <golergka> OK, I have to admit that I read a couple of posts about foldl and foldr, but haven't actually grokked them yet so I think that I should first go do more tutorials first before I'm qualified for this conversation
12:17:57 <fen_> no... the other one, associative
12:18:12 <fen_> wait nvm
12:18:26 <nshepperd> fen_: they're not even up to foldr
12:18:41 <fen_> i was talking to solonarv
12:18:42 <nshepperd> golergka: you'd maintain two arguments to your recursive function, which would be updated on each recursive call
12:19:13 <fen_> sorry shouldnt be confusing the beginner... 
12:19:47 <fen_> :t mapAccumL
12:19:48 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
12:19:51 <fen_> :t mapAccumR
12:19:52 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
12:19:58 <fen_> hmm
12:20:10 <jgt> I managed to make my Haskell program hang by writing a stupid PersistField instace. My implementation was `fromPersistValue = fromPersistValue`. Should the compiler have caught me here? Or am I just being stupid?
12:20:12 <fen_> they are not different at type level like foldl and foldr
12:20:14 <golergka> nshepperd: OK, this makes sense, thanks (I vaguely remember this kind of thing from SICP)
12:20:17 <jgt> instance*
12:20:18 <saml> haskell has no heap allocation right? everything is function arguments
12:20:28 <lavalike> > flip (foldr (\x k -> \n -> (if n then x else 2*x) : k (not n)) (const [])) True $ [1..10]
12:20:30 <lambdabot>  [1,4,3,8,5,12,7,16,9,20]
12:20:35 <lavalike> > flip (foldr (\x k -> \n -> (if n then x else 2*x) : k (not n)) (const [])) False $ [1..10]
12:20:37 <lambdabot>  [2,2,6,4,10,6,14,8,18,10]
12:20:37 <__monty__> saml: Where do you think those arguments go?
12:20:52 <Solonarv> saml: no, haskell has heap allocation
12:20:57 <saml> __monty__, I mean user controlled malloc type of stuff
12:21:04 <Solonarv> you can even call malloc and friends if you want
12:21:13 <fen_> but why is that relavent?
12:21:14 <saml> haskell compiler can avoid malloc completely, no?
12:21:15 <__monty__> But you wouldn't normally, no.
12:21:34 <nshepperd> golergka: the easiest way is for these two arguments to be lists which you add to the end, then you return one of them when your recursion hits either [] or [x]
12:21:36 <Solonarv> GHC doesn't call malloc for allocation normally, no
12:21:45 <nshepperd> depending on which one you hit
12:22:04 <fen_> saml: it uses it under the hood, but it tries to hide as much of this functionality from the user as possible, for reasons of legibility and runtime safety
12:22:07 <__monty__> saml: Not calling malloc doesn't mean memory doesn't get allocated.
12:22:10 <golergka> I ended up with just doubleEveryOther = (reverse . doubleEveryOtherRev . reverse)
12:22:19 <lavalike> golergka: I used foldr!
12:22:20 <golergka> which I think is exactly what this course author had in mind
12:22:51 <nshepperd> go evenDoubled oddDoubled (x:y:xs) = go (evenDoubled ++ [double x, y]) (offDoubled ++ [x, double y]) xs
12:23:08 <Solonarv> I think the RTS might call malloc on startup to get a big block of memory
12:23:11 <jgt> I'm guessing `fromPersistValue = fromPersistValue` is infinite recursion and can't be caught by the compiler because of the Halting Problem. Am I right about that?
12:23:13 <fen_> nshepperd: you mean to add them as the basecase? isnt that what the "carry" of mapaccum is for, or do you mean that the extra info isnt actually needed during the traversal?
12:23:13 <nshepperd> the efficient method makes those into difference lists so you're not repeatedly appending to the end of a thing
12:23:24 <Solonarv> but normally stuff gets allocated by a very simple pointer-bump method
12:23:45 <saml> i guess a better question is,  if there's a good functional programming language with manual memory management
12:23:47 <nshepperd> fen_: i have no idea what you're talking about
12:23:59 * Solonarv high-fives nshepperd
12:24:06 <fen_> hrmpf
12:24:18 <__monty__> saml: Rust, kind of.
12:24:19 <Solonarv> saml: rust is functional-adjacent, and might fit the bill
12:24:25 <fen_> well ill just wait to ask my recursion schemes question again
12:24:39 <MarcelineVQ> In long ago testing the fastest method was simply to length the list and decide what to do based on that.
12:25:13 <Solonarv> seems reasonable
12:25:19 <fen_> saml: the idea if haskell is to give good memory managment
12:25:40 <fen_> the user is generally worse at it
12:25:44 <Solonarv> you do end up traversing the list twice, but you could fuse the traversals together if you really wanted to
12:25:59 <fen_> and should be saved from their own terrible fallibility 
12:26:33 <boblehest> I'm reading "PureScript by Example", and I feel like this book is just taunting me.
12:26:36 <boblehest> (Medium) Write a function filterM which generalizes the filter function on lists.
12:26:48 <fen_> keep the user away from the memory, and only good things can happen
12:26:49 <boblehest> Would anyone consider that a "medium" task for a complete beginner?
12:27:45 <Solonarv> % doubleEveryOtherEnd xs = go (even (length xs)) xs where go _ [] = []; go True (y:ys) = (y*2):go False ys; go False (y:ys) = y:go True ys
12:27:45 <yahb> Solonarv: 
12:27:52 <Solonarv> % doubleEveryOtherEnd [1..10]
12:27:53 <yahb> Solonarv: [2,2,6,4,10,6,14,8,18,10]
12:28:32 <Solonarv> boblehest: seems reasonable if monads have already been introduced and you've already made them implement filter
12:28:33 <MarcelineVQ> geeze, filterM was pretty hard
12:28:42 <Solonarv> otherwise, not so much
12:29:15 <boblehest> Solonarv: Monads have been introduced, but I probably still don't understand the general notion of a monad
12:29:19 <MarcelineVQ> I was brick-walled on that one in the data61 course, and they make effort to give you all the pieces beforehand
12:29:54 <boblehest> My reaction to this:  filterM p        = foldr (\ x -> liftA2 (\ flg -> if flg then (x:) else id) (p x)) (pure [])
12:29:58 <boblehest> was just "that's pretty damn cute"
12:30:08 <fen_> just read the source! its a waste of time otherwise
12:30:37 <fen_> if its supposed to be an excersize, its just one in futility
12:30:44 <MarcelineVQ> fen_: yeah, why understand things for yourself, that wouldn't be useful to anyone
12:30:48 <fen_> no
12:30:58 <ababcd> ?pl \n -> [1 .. n]
12:30:58 <lambdabot> enumFromTo 1
12:31:05 <boblehest> fen_: Just reading the source is a good way to avoid learning anything :p
12:31:09 <fen_> why derive it yourself, when people have put their lives into deriving it in cooperation with each other
12:31:24 <MarcelineVQ> To understand a little about how to derive things people haven't done for you.
12:31:36 <boblehest> I'm trying to force myself to understand these things. But I'm definitely wasn't ready for this task just yet
12:31:47 <fen_> but they have done it for you!
12:31:48 <boblehest> s/But I'm/But I/
12:31:58 <fen_> so its a waste of time 
12:32:13 <fen_> we should concentrate on understanding existing information
12:32:18 <fen_> everything we need is out there
12:32:22 <fen_> we just need to understand
12:32:37 <MarcelineVQ> uhm
12:32:44 <MarcelineVQ> Doesn't that decribe the problem?
12:32:50 <fen_> learning is not deriving new ideas, its specifically learning existing ones
12:33:06 <MarcelineVQ> It is if you don't have the source to copy.
12:33:28 <Solonarv> it's fairly simple in do notation:
12:33:28 <Solonarv> filterM _ [] = return []
12:33:28 <Solonarv> filterM p (x:xs) = do
12:33:28 <Solonarv>   cond <- p x
12:33:28 <Solonarv>   rest <- filterM p xs
12:33:29 <fen_> why try and be creative about it. like, im not going to learn newtons law, i want to figure out what that arises from on my own
12:33:30 <Solonarv>   if cond
12:33:32 <Solonarv>     then return rest
12:33:35 <Solonarv>     else return (x : rest)
12:34:02 <boblehest> Solonarv: Thanks, that's actually quite helpful :)
12:34:15 <lavalike> what was that operation to go from m (n a) to n (m a)
12:34:30 <Solonarv> this is a bit verbose of course, but it's basically a straightforward conversion of the normal 'filter' definition
12:34:41 <Solonarv> lavalike: there isn't such an operation in general
12:34:41 <fen_> MarcelineVQ: but thats not the problem we face, we have unlimmeted amount of source code, we just cant read it. we need to focus on parsing not lexing
12:34:49 <lavalike> Solonarv: no of course
12:35:03 <Solonarv> often 'sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)' will do
12:35:04 <boblehest> lavalike: sequence?
12:35:07 <lavalike> thanks!
12:35:19 <Solonarv> (or sequenceA which generalizes 'Monad' to 'Applicative', actually)
12:35:29 <fen_> the idea of a "good language" is that when you read it, it forms useful understanding in the human mind
12:35:43 <fen_> so read the source, and it will shape your understanding
12:35:49 <fen_> not the other way round
12:36:55 <boblehest> fen_: I'm not really sure what problem you're talking about, but I disagree that you should just learn from reading source code, for multiple reasons
12:37:20 <fen_> but the alternative is to try and fail, before skipping to the answers
12:37:48 <fen_> its either, get frustraited by lack of sufficient information, or permit access to sufficient information
12:38:01 <fen_> the only argument is that without struggling you wouldnt value the soultion
12:38:01 <nshepperd> fen_: empirically, just looking up the answers to exercises doesn't work as well as actually doing them
12:38:23 <boblehest> fen_: If you didn't try and fail, you don't even know what you're trying to learn
12:38:35 <fen_> thats an argument for time wasting on needless toil because it creates a more studious approach
12:38:41 <fen_> your crafting nerdiness
12:38:46 <fen_> its a horrible idea
12:38:54 <fen_> its like maximising revenue or something
12:39:06 <fen_> without caring how exactly that arrises
12:39:31 <fen_> and the deeper consequence as side effects of why things happen
12:39:44 <fen_> just give them the information, stop teasing them
12:40:03 <fen_> if they care, thats enough, you dont need to coerce them into that state
12:40:40 <fen_> your job is not to make someone want to learn
12:40:53 <fen_> its to provide the information they need, based on existing desire
12:41:34 <fen_> delivering that information in a way that is frustraiting, because it gives better results long term, might cause unknown side effects
12:41:54 <fen_> basically, who are you to say what "better results long term" are
12:42:40 <fen_> "if we make them dig their way out, they and up stronger diggers" never mind the secondary impact of this form of pressure
12:42:53 <zachk> @src filterM
12:42:53 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
12:42:57 <fen_> or if its at all important that they be strong diggers
12:42:58 <zachk> :(
12:55:05 <fen> is there a way to write inductive instances for recursion schemes on nested containers?
12:55:19 <johnw> fen: hmmmm?
12:55:35 <johnw> can you define what you mean by these terms
12:56:01 <fen> recursion schemes as in the library. instances of recursive and corecursive classes
12:56:10 <johnw> that's the one part I knew
12:56:17 * hackage fused-effects-exceptions 0.1.0.0 - Handle exceptions thrown in IO with fused-effects.  https://hackage.haskell.org/package/fused-effects-exceptions-0.1.0.0 (patrick_thomson)
12:56:17 <johnw> I don't know what you mean by "inductive instances"
12:56:17 <fen> inductive instances as in, for a more nested container in terms of a less nested one
12:56:34 <fen> with a basecase of a container such as list
12:56:40 <johnw> do you mean, mutually recursive data types?
12:56:54 <fen> maybe not
12:56:59 <johnw> small example?
12:57:03 <fen> of?
12:57:15 <johnw> the above-mentioned request
12:57:30 <johnw> I am a big fan and user of recursion schemes
12:57:30 <fen> what, a mutually recursive datatype?
12:57:38 <johnw> so perhaps, once I know what you're thinking about, I could have a suggestion
12:57:50 <johnw> I can't picture in my mind yet what you're thinking of
12:57:51 <fen> nested containers?
12:58:10 <fen> i cant picture what part your not able to picture
12:58:13 <johnw> "inductive instances of nested containers"
12:58:30 <fen> inductive as in, with a basecase and inductive step
12:58:39 <fen> the basecase is the instance for a container
12:58:51 <johnw> yes, define "the instance for a container"
12:59:01 <fen> and the induction is of a one layer more nested container in terms of some depth of nested container
12:59:15 <fen> the instance of the classes recursive and corecursive
12:59:29 <johnw> there is a type class named Recursive?
13:00:02 <fen> http://hackage.haskell.org/package/recursion-schemes-5.1.2/docs/Data-Functor-Foldable.html#t:Recursive
13:00:14 <johnw> ah, you mean recursion-schemes
13:00:18 <johnw> I thought you just meant recursion schemes
13:00:24 <fen> !>!>!
13:00:26 <johnw> never mind, I don't use this library
13:00:46 <fen> >:^{
13:01:46 <fen> Solonarv!!
13:04:03 <fen> johnw: its ok, the question was only phrased using this language to enable an explanation in a common parlance, it would need to understand how best to phrase the question for you to understand it otherwise
13:04:12 <fen> and currently thats not available
13:04:39 <johnw> do you have a version in uncommon parlance? :)
13:06:01 <fen_> hmmm
13:06:06 <fen_> yes ok
13:06:24 <fen_> i think the inductive step is clear from just considering depth 1 vs depth 2 nestings
13:07:08 <fen_> and paraphrasing the recursion-schemes library down to the part we need, is just to be able to get the type of the thing we unfold to get the desired container
13:07:28 <fen_> for the basecase, we need to unfold a container
13:07:45 <fen_> for the inductive step, we need to unfold a state, which can be unfolded to give a container
13:07:52 <johnw> are you thinking in terms of a higher-order recursion scheme, where you recurse not just on some terminating recursor 'r :: *', but also some companion recursor 'f :: * -> *'?
13:08:05 <fen_> :o
13:08:11 <johnw> I use this type for that:
13:08:12 <johnw> newtype Fix1 (t :: (k -> *) -> k -> *) (a :: k) = Fix1 { unFix1 :: t (Fix1 t) a }
13:08:28 <fen_> no
13:08:29 <johnw> to allow me to plumb a reference to another structure through my fixed-point
13:08:48 <fen_> this would fail to extend infinitly
13:09:01 <fen_> and trying to wrangle it to do so looks like the wrong way
13:09:08 <fen_> we just need a forall a.
13:09:18 <fen_> so it can be [a], [[a]] etc
13:09:43 <fen_> not something like compose, which we would need higher arity analogues of
13:09:46 <johnw> what you're doing sounds interesting
13:10:09 <fen_> we have an example of a state you can unfold from a higer order state
13:10:18 <fen_> but unfortunatly it is ambiguous
13:10:39 <fen_> its type can be used to represent lists of nonempty lists, or nonempty list of lists
13:11:21 <fen_> this lack of bijectivity means the "state transition function" does not specify the sequence of nested containers unambiguously
13:12:20 <fen_> ie, we can unfold the state transition function s -> Maybe (a,Maybe s) into either s -> (a,Maybe s) or s -> Maybe (a,s)
13:12:52 <fen_> argh, thats not right
13:13:15 <fen_> we can unfold the state transition function s -> Maybe (a,Maybe s) into either s -> ([a],Maybe s) or s -> Maybe (Nonempty a,s)
13:13:53 <fen_> where s -> (x,Maybe s) unfolds into a Nonempty, and s -> Maybe (x,s) unfolds into a list
13:15:46 <fen_> the question in thus to find something that unfolds into somthing that unfolds into so...... something that unfolds into a specific container.
13:16:30 <fen_> note that we can kind of say that we can turn eg s -> Maybe (a,Maybe s) into either s -> (a',Maybe s)
13:16:33 <fen_> notice the a'
13:17:07 <fen_> so only at the last level do we unfold into a container, as at every other stage we unfold into a state
13:17:24 <fen_> that the state is actually of a container is basically hidden
13:18:49 <fen_> except it should be used explicitly to capture the "outer layer of the compoite state transition function" and cast it into the corresponding container type that the state resulting from the unfold has as its value - ie a' becomes [x] 
13:18:49 <zachk> fen_,  your state transition function looks kind of like a mealy machine and also some types used in doing frp 
13:19:08 <fen_> ok its some kind of higer order mealy machine
13:19:18 <fen_> which sounds cool
13:20:15 <zachk> i don't think its a full mealy machine type cause the Maybe s is usually a recursive type of Machine m a b = a -> m (a , Machine m a b) 
13:20:21 <fen_> johnw: that is free of recursion schemes language more or less, though is in the same spirit. is it celar?
13:20:25 <fen_> clear!*
13:21:12 <fen_> zachk, why not jsut; Machine m a b = a -> m a (Machine m a b)
13:21:32 <fen_> then you can commute the maybe into the pair
13:21:33 <zachk> m is usually a monad 
13:22:07 <zachk> (monad m ) => m a m takes only one arugment
13:22:32 <fen_> probably not as important as being able to be either s -> (a,s), s -> Maybe (a,s), s -> (Maybe a,s),s -> (a,Maybe s)
13:23:20 <fen_> and yeah, it should take a type level nat?
13:23:35 <fen_> could maybe avoided as the depth could be returned from the nesting directly
13:23:54 <fen_> but it would at least help ensure that the recursion was monotonically decreasing
13:24:04 <fen_> to produce lower order mealy machines
13:24:58 <zachk> a mealy machine takes an input, and produces an output and a new mealy machine, so you can model state with them 
13:25:43 <fen_> anyway, for the recursion-schemes folks it can be thought of as an equivalence class of common base functors - where the base functor is a type generated via a parameter of the depth of nesting
13:26:44 <fen_> zachk: yeah, but we also need to be able to handle when it fails to return an output, or when it fails to return the new machine, in one of 2 ways, as in, empty, or a last value, corresponding to nonempty
13:27:51 <fen_> what does the `b' param in your version do?
13:27:53 <zachk> the m on can handle failure 
13:27:59 <zachk> the b is the output type
13:28:01 <fen_> but only one kind
13:28:07 <zachk> a is input
13:28:11 <fen_> we need s -> (a,Maybe s)
13:28:13 <zachk> and the m is the monad you operate in 
13:28:30 <fen_> so s -> (a,Nothing) is the "last" value of a nonempty container
13:28:47 <fen_> if thats how it fails, it is safe to not have an empty list
13:29:11 <fen_> so we dont need that extra b param?
13:29:39 <zachk> you could just make the b () 
13:29:49 <fen_> what would not doing that enable?
13:29:50 <zachk> but you be eating an input and producing a new machine
13:30:01 <zachk> so what would be the point
13:30:08 <zachk> unless you had a way to unwrap a machine 
13:30:20 <zachk> but by the definition of it its a function 
13:30:30 <fen_> oh, so it is something other than m which makes the machine different from a
13:30:32 <fen_> ok
13:30:33 <zachk> you can model coroutines and some streaming libraries and frp stuff with them 
13:31:19 <fen_> so what if we have; Machine m a = a -> m a (Machine m a)
13:31:38 <fen_> then the `b' is hidden in the a
13:31:47 <fen_> argh
13:31:53 <fen_> there are too many options
13:32:28 <fen_> its more simple to just have fixed; s -> (a,Maybe s) and s -> Maybe (a,s)
13:32:35 <fen_> and just do nonempty and list
13:33:11 <fen_> maybe `m' could be a place to make it recursive, but at the moment that happens at `a'
13:33:24 <fen_> we have;
13:33:53 <fen_> (s -> Maybe (a,Maybe s)) -> (s -> ([a],Maybe s))
13:33:56 <fen_> and;
13:34:15 <fen_> (s -> Maybe (a,Maybe s)) -> (s -> Maybe (Nonempty a, s))
13:34:51 <zachk> i was playing with something like Computation m a b r = runComputation :: a -> m (Either (b,Computation m a b r), r) the other month and made it work 
13:35:11 <fen_> either we unfolded a state-which-unfolds-into-a-list of `nonempty a'
13:35:32 <fen_> or, we unfolded a state-which-unfolds-into-a-nonempty-list of `list of a'
13:35:49 <zachk> my computation can run in any monad, takes an input and either produces an output and a new computaion or just a final terminal result 
13:36:13 <zachk> so you can have a computation you can step and produces values or terminates with a final result 
13:36:24 <fen_> this implementation born ambiguity means the state transition function does not uniquely specify which nested container it unfolds into
13:37:02 <zachk> do you need "intermediate" values? and a final value? 
13:37:29 <fen_> no
13:37:44 <fen_> its not like the stream representaion
13:37:50 <fen_> actually, wait, it might be
13:37:57 <fen_> if the final thing was the state
13:39:06 <fen_> sometimes stream is written; data Stream a b = StreamCons a (Stream a b) | End b
13:39:12 <fen_> is that what you mean?
13:39:36 <fen_> that then we would have b = s of State s a = s -> (a,s)
13:40:25 <fen_> yes, looks like thats your `r'
13:40:32 <zachk> mine is a function and can operate in a monad the Stream thing looks somewhat similar, maybe for an output type, final result 
13:41:09 <fen_> yeah, not sure about this whole "running it in a monad" tradition
13:41:22 <zachk> if haskell had better support for dependent types I would just say use a sized a vector as your nonempty with a guarantee that the size is greater than zero 
13:41:30 <fen_> seems totally unnecessary here
13:41:41 <zachk> your maybe is the monad for your examplle
13:41:44 <zachk> example
13:41:53 <fen_> zachk: well not thats not right
13:42:00 <fen_> its not actually nonempty or list
13:42:05 <fen_> its the state encoding of these
13:42:15 <fen_> you could unfold it into a tree if you wanted
13:42:29 <shapr> myme: hi!
13:42:31 <fen_> it abstracts away the notion of the class of lenses
13:42:32 <zachk> i was saying using sized dependent vectors to represent your nonempty 
13:42:33 <fen_> !?
13:42:37 <fen_> or somrthing like that
13:42:44 <fen_> the "Set" class
13:43:03 <zachk> so you have nonempty Set's as well? 
13:43:22 <fen_> zachk: im saying thats a misleading idea, as we are working with nonempty-like things
13:43:36 <fen_> anything which can be unfolded using the same state that unfolds a nonempty
13:43:50 <fen_> its an equivalence class of recursion schemes
13:44:03 <fen_> if the base functor is isomorphic to this state transition function
13:44:18 <zachk> yea but if your nonempty has a size and that size could be zero you can represent it as something simpler with a condition that the size be greater than zero if haskell had better support for depedent types 
13:44:28 <fen_> zachk: nonempty has a different type for its Set function
13:44:45 <fen_> the idea is that there is are many of these possible types for set functions
13:44:47 <zachk> yea I dont fully understand how to implement lens or even use recursion schemes :( 
13:44:59 <zachk> so you have a nonempty type class?
13:45:01 <fen_> these are the common base functors which form the equivalence classes
13:45:19 <fen_> no we dont have a nonempty typeclass as such
13:45:24 <fen_> we just have Get and Set
13:45:31 <fen_> with various different types
13:45:42 <zachk> so like lens 
13:45:46 <fen_> such as one type for nonempty things
13:46:04 <fen_> i cant see how thats anything like lens at all
13:46:10 <fen_> other than the notions of get and set
13:46:26 <fen_> you could just write Lens f = (Get f,Set f)
13:46:42 <fen_> but then there would be a different type of lens for each of the different Set and Get classes
13:48:20 <fen_> basically we are providing this "state transition functions type" as a parameter to the Get class
13:48:27 <fen_> (and the dual of it for Set)
13:48:43 <fen_> erm, swap Get and Set in the above 2 lines
13:48:54 <fen_> eh?
13:48:57 <fen_> ok nvm
13:49:14 <fen_> hmm, confused because you need a Set to unfold a Get!
13:49:51 <fen_> so ehn unfolding, we require an implementation Get, but provide an implementation of Set
13:50:03 <fen_> ok, this is getting long and distracting
13:50:33 <fen_> it would be much better to focus on the question. i dont find exaplining the theory all that useful
13:50:48 <fen_> its great if it causes someone to understand and then give an answer
13:51:07 <fen_> but in a silent room, there is no idea of the audiences attention or level
13:51:13 <fen_> ...
13:52:05 <fen_> we are trying to unfold a state transition function
13:52:45 <fen_> to avoid the resulting ambiguity and provide a bijection between the types of these "higher order state transition functions" 
13:53:00 <fen_> and the containers they unfold into
13:53:22 <fen_> the current example of a depth 2 version fails as there is an ambiguity;
13:53:51 <fen_> (s -> Maybe (a,Maybe s)) -> (s -> ([a],Maybe s))
13:53:52 <fen_> (s -> Maybe (a,Maybe s)) -> (s -> Maybe (Nonempty a, s))
13:54:17 <fen_> the higher order state transition function; (s -> Maybe (a,Maybe s))
13:54:29 <fen_> unfolds into one of 2 different state transition functions
13:54:36 <fen_> depending on the implementation
13:54:53 <fen_> and the resulting order of nesting containers cant be determined
13:56:17 <fen_> thus we need a better representation for this higher order state transition function
13:56:41 <fen_> (the problem gets worse at even higher orders, as there are more choices of how to order the nested containers)
13:58:22 <fen_> if we can solve this lowest inductive step, then we can get something that unfolds a "one level of depth lower" higher order state transition function
13:58:45 <fen_> which is bijective with the nested container itslef
13:59:03 <fen_> oh thats not right
13:59:09 <fen_> because there are many nonempty things
13:59:12 <fen_> for example
13:59:56 <fen_> but at least it would identify th class of containers at each level, if not the specific container, which would be specified during the unfolding 
14:01:00 <fen_> this is the closest relavent code; https://pastebin.com/VPRmAw9A
14:01:23 <fen_> though it does not mention higher order nestings as its still not solved the issue being described
14:01:43 <myme> shapr: Oh, hi. Didn't see the mention ;)
14:05:45 <fen_> the hope was that if any recursion schemes officianado could give the [[a]] Corecursive instance in terms of the [a] version, then it would give a good place to start
14:07:08 <myme> Perhaps more fit for #nixos, where I've also asked, but I could try here as well. I'm new to NixOS and am having troubles with IO in some of my projects. I noticed that utf8 files were causing issues, and localeEncoding is reporting "ASCII". LANG=en_DK.UTF-8, as with my non-NixOS systems as well.
14:07:37 <myme> As run through `stack repl`.
14:14:43 <isn> Hello, i'm back :)
14:14:47 <isn> With a new episode of questions!
14:14:52 <shapr> ask them!
14:15:54 <isn> I’ve created a function to calculate the next number in the fibonacci sequence with:
14:15:54 <isn> fibTuple :: (Int, Int, Int) -> (Int, Int, Int)
14:15:54 <isn> fibTuple (x, y, 0) = (x, y, 0)
14:15:56 <isn> fibTuple (x, y, index) = fibTuple (y, x + y, index - 1)
14:16:56 <fen_> :t iterate 
14:16:57 <lambdabot> (a -> a) -> a -> [a]
14:16:59 <isn> And calling it with fibTuple(0,1,5)
14:17:10 <isn> I'm getting 8 in y
14:17:27 <slack1256> isn: you should force via seq the second argument
14:17:45 <slack1256> otherwise you will get an accumlating thunk on it
14:18:14 <isn> Uhm
14:18:17 <isn> :)
14:18:23 <fen_> :t seq
14:18:23 <lambdabot> a -> b -> b
14:18:25 <isn> How would I force a sec
14:18:46 <fen_> > seq undefined "hello seq"
14:18:48 <lambdabot>  "*Exception: Prelude.undefined
14:19:00 <slack1256> fibTuple (x, y, index) = let val = x + y in val `seq` fibTuple (y, val, index - 1)
14:19:03 <fen_> > seq "eval" "hello seq"
14:19:05 <lambdabot>  "hello seq"
14:19:15 <absence> i've seen some recommendations against ExceptT over IO because of issues with async, and because IO can throw any other exceptions than the one in the type signature anyway. instead it's suggested to use MonadCatch's throwM, but it's not a drop-in replacemen since it has an Exception constraint. so for functions that return IO (Either e a) where e isn't an exception, or functions returning IO (Maybe a) (a
14:19:21 <absence> ssuming MaybeT has the same async problems), it doesn't really work out. am i missing something?
14:19:45 <shapr> @where cis194
14:19:45 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
14:19:57 <isn> slack1256: I don't really understand what you mean by forcing a sequence in the second arg
14:20:15 <fen_> otherwise it is lazy and wont evaluate
14:20:18 <slack1256> @where lazy
14:20:18 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
14:20:25 <slack1256> isn ^
14:20:58 <fen_> its ok, except will take more memory to deffer computation till the end
14:22:04 <slack1256> absence: using MonadCatch won't help you with async exceptions, that's an ortogonal problem
14:22:29 <slack1256> The only thing MonadCatch does it let you catch exception on monad stacks (maybe with an IO at the base)
14:22:30 <isn> Hm, I thought haskell was lazy by default
14:23:11 <slack1256> isn: it is. That is why you have to force (`seq`uentializate) you values to not build big thunks on those recursive computations
14:24:07 <absence> slack1256: it was suggested to use throwM instead of ExceptT, not for catching async exceptions
14:24:55 <slack1256> absence: In the same way that if you are already on the IO monad, you should use throw instead of putting an ExceptT on top of IO, by what you said before
14:25:27 <isn> slack1256: alright, thank you. could you give me an example of how its used?
14:26:24 <slack1256> absence: IO action implicitly say "all the operations can fail with an exception", by decorating with an ExceptT you are only adding another avenue to check for exceptions. It is better to use the exception framework already present on IO
14:26:35 <slack1256> isn: I already did
14:26:46 <slack1256> fibTuple (x, y, index) = let val = x + y in val `seq` fibTuple (y, val, index - 1)
14:27:07 <absence> slack1256: is there never a reason for a function to return IO (Either e a)?
14:27:47 <Solonarv> sure there is
14:28:05 <Solonarv> as a rule of thumb: if 'e' is an error that should always be caught/handled
14:28:18 <Solonarv> s/always/almost always/
14:28:58 <fen_> :t catch
14:29:00 <lambdabot> error:
14:29:00 <lambdabot>     Ambiguous occurrence ‘catch’
14:29:00 <lambdabot>     It could refer to either ‘Control.Exception.catch’,
14:29:11 <fen_> :t guard 
14:29:12 <lambdabot> Alternative f => Bool -> f ()
14:29:24 <absence> what if e is not an Exception (so it can't be thrown), is ExceptT on top of IO still a bad idea?
14:30:06 <absence> or for that matter, what about MaybeT? it's isomorphic to ExceptT with () for e
14:33:05 <slack1256> @help try
14:33:05 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:33:11 <slack1256> % :t try
14:33:11 <yahb> slack1256: Exception e => IO a -> IO (Either e a)
14:33:17 <slack1256> ^ absence
14:33:36 <slack1256> that's should the only one you need.
14:34:10 <slack1256> absence: not a bad a idea, it's innecesary by the contract that IO fullfils (every IO action can potentially fail)
14:34:22 <Solonarv> if it can't be thrown (doesn't have an Exception instance) then especially returning IO (Either E a) is fine to me
14:34:40 <Solonarv> you can always convert from IO-exception to IO (Either ..) using try
14:34:54 <slack1256> Except or MaybeT on top of IO only give them different avenue on how to report such failure. At the top level you should do not only the `try` but also the runMaybeT
14:34:57 <Solonarv> or convert the other way with '>>= either throwIO id'
14:35:08 <slack1256> so it's better to decide to use just one.
14:35:16 <isn> slack1256: when I run fibTuple (x, y, index) = let val = x + y in val `seq` fibTuple (y, val, index - 1) - it gets stuck
14:35:30 <isn> Its really weird because I got my old function from the book seven languages in seven weeks
14:35:50 <isn> Not sure why the author would put that in there
14:35:54 <slack1256> isn: well yeah, it only modified a single case on the three cases your function had
14:36:55 <isn> I still get (10946,17711,0) for fibTuple(0,1,21)
14:37:03 <isn> With:
14:37:05 <isn> fibTuple :: (Int, Int, Int) -> (Int, Int, Int)
14:37:05 <isn>     fibTuple (x, y, 0) = (x, y, 0)
14:37:05 <isn>     fibTuple (x, y, index) = let val = x + y in val `seq` fibTuple (y, val, index - 1)
14:37:21 <slack1256> yep, the values don't change
14:37:27 <slack1256> operationally is potentially more efficient
14:37:32 <fen_> that was the point to begin with!
14:37:41 <slack1256> because we aren't using laziness we didn't need
14:37:58 <absence> slack1256: so let's say we have a function that returns IO (Maybe a), or for that matter MaybeT IO a. how would you turn it into just IO a, if that's what you mean by using just one avenue?
14:38:03 <isn> lol, thanks for that tho. Now I have another research material :)
14:38:08 <slack1256> absence: yep
14:38:17 <isn> I actually wanted to ask that when I put 21, I'm expecting 34
14:38:39 <isn> but I get (10946,17711,0)
14:38:40 <Solonarv> now why would that be?
14:38:56 <Solonarv> fibTuple (0, 1, n) gives you the nth number in the fibonacci sequence
14:39:07 <slack1256> % take 10 $ fix $ \rec -> 1 :  1 : zipWith (+) rec (tail rec)
14:39:07 <yahb> slack1256: [1,1,2,3,5,8,13,21,34,55]
14:39:09 <Solonarv> not the fibonacci number that comes after n
14:39:21 <fen_> Solonarv: there you are, recursion schemes for [[a]] !?
14:39:22 <isn> Okay, I am actually very stupid
14:39:28 <isn> thank you very much
14:39:47 <isn> tunnel vision mode again :/
14:39:50 <fen_> recursion-schemes...
14:40:01 <fen_> apparently that is nesacary
14:40:06 <Solonarv> % take 10 $ fix $ (0:) . (1:) . zipWith (+) <*> tail
14:40:06 <yahb> Solonarv: ; <interactive>:29:17: error:; * Couldn't match type `[Integer]' with `[a] -> [a]'; Expected type: [a] -> [a] -> [a]; Actual type: [a] -> [Integer]; * Possible cause: `(.)' is applied to too many arguments; In the first argument of `(<*>)', namely `(0 :) . (1 :) . zipWith (+)'; In the second argument of `($)', namely `(0 :) . (1 :) . zipWith (+) <*> tail'; In the se
14:40:12 <Solonarv> % take 10 $ fix $ (0:) . (1:) . (zipWith (+) <*> tail)
14:40:12 <yahb> Solonarv: [0,1,1,2,3,5,8,13,21,34]
14:40:21 <Solonarv> points are for other people!
14:40:41 <absence> slack1256: i think you skipped the "how" part of my question :)
14:41:10 <slack1256> Solonarv: wizardry!
14:41:36 <slack1256> % :t runExceptT
14:41:36 <yahb> slack1256: ExceptT e m a -> m (Either e a)
14:41:42 <slack1256> % :t runExceptT @IO
14:41:42 <yahb> slack1256: ; <interactive>:1:13: error:; * Expecting one more argument to `IO'; Expected a type, but `IO' has kind `* -> *'; * In the type `IO'; In the expression: runExceptT @IO
14:41:56 <slack1256> % :set -XTypeApplications
14:41:56 <yahb> slack1256: 
14:41:58 <slack1256> % :t runExceptT @IO
14:41:58 <yahb> slack1256: ; <interactive>:1:13: error:; * Expecting one more argument to `IO'; Expected a type, but `IO' has kind `* -> *'; * In the type `IO'; In the expression: runExceptT @IO
14:42:00 <Solonarv> absence: pick some thing sensible to do in the Nothing case, then feed that into '>>= maybe somethingSensible pure'
14:42:14 <Solonarv> % :t runExceptT @(IO _)
14:42:14 <yahb> Solonarv: ExceptT (IO w) m a -> m (Either (IO w) a)
14:42:25 <Solonarv> hahaha
14:42:28 <slack1256> use also runMaybeT and runExceptT
14:42:30 <Solonarv> % :t runExceptT @_ @(IO _)
14:42:30 <yahb> Solonarv: ; <interactive>:1:17: error:; * Expected kind `* -> *', but `IO _' has kind `*'; * In the type `(IO _)'; In the expression: runExceptT @_ @(IO _)
14:42:31 <slack1256> ¬¬
14:42:35 <Solonarv> % :t runExceptT @_ IO
14:42:35 <yahb> Solonarv: ; <interactive>:1:15: error:; * Data constructor not in scope: IO :: ExceptT w m a; * Perhaps you meant `I#' (imported from GHC.Exts)
14:42:40 <Solonarv> % :t runExceptT @_ @IO -- finally!
14:42:40 <yahb> Solonarv: ExceptT w IO a -> IO (Either w a)
14:46:32 <absence> slack1256: i think we must be talking past eachother. the premise is "don't use MaybeT over IO because IO actions have exceptions anyway, and it's bad to have more than one avenue for errors". so if i have a bunch of "IO (Maybe a)" returning functions i want to call, how do i get it to work like MaybeT without using MaybeT?
14:46:47 * hackage hvega 0.2.0.0 - Create Vega-Lite visualizations in Haskell.  https://hackage.haskell.org/package/hvega-0.2.0.0 (DouglasBurke)
14:48:17 * hackage ihaskell-hvega 0.2.0.0 - IHaskell display instance for hvega types.  https://hackage.haskell.org/package/ihaskell-hvega-0.2.0.0 (DouglasBurke)
14:54:20 <fen> ???? -> ([a],????) ......... -> ([[a]],!?!?!?)
15:02:59 <hpyCdr> how can I define a typeclass with an additional type? e.g. class EventHandler e a where handle :: e -> a -> a
15:03:13 <hpyCdr> where instances have a concrete "e" not "any e" 
15:03:18 <hpyCdr> is that possible?
15:03:44 <hpyCdr> So my instance is not an EventHandler e, but EventHandler Foo
15:04:04 <hpyCdr> I'm certain this should work somehow, but can't figure it out
15:04:31 <benzrf> hpyCdr: MultiParamTypeclasses, but it might be a good idea to explain *why* you want this - there may or may not be a solution that doesnt require a language extension
15:04:41 <wolfman154> 16:02 wolfman154: How does nix work with cabal and stack, can nix be used instead of cabal and stack? I’m confused?
15:05:10 <hpyCdr> benzrf, I might be able to write some logic that doesn't care about the event type
15:05:24 <hpyCdr> while I'll need something concrete when really handling the event
15:06:24 <wolfman154> Cale: can you explain this because I’m going to install Haskell in a while?
15:08:23 <ski> hpyCdr : MPTCs (possibly with FDs), yes, or ATs
15:09:15 <ski> hpyCdr : MPTCs would be your `EventHandler e a' class head, so `EventHandler' is a relation between two types, not a predicate on a single type
15:09:47 <wolfman154> so I can use nix for all my Haskell programming without having to use cabal or stack?
15:11:17 <absence> Solonarv: doesn't >>= maybe something pure defeat the whole purpose of the Maybe monad?
15:12:31 <hpyCdr> ski, MPTCs looks right, thanks
15:12:40 <fen> wolfman154: why would you want to do that?
15:13:29 <ski> hpyCdr : note that it's common to want FDs on the `class' declaration, for MPTCs
15:13:37 <wolfman154> fen: I want to use nix for everything 
15:13:43 <fen> why?
15:14:28 <hpyCdr> ski, flexible d.... ?
15:14:47 <ski> no, functional dependencies
15:15:06 <ski> as in normalization of database tables/relations, in relational data base theory
15:16:05 <ski> e.g. if you were to write `class EventHandler e a | a -> e', then that would mean tht for each `a', there can be at most one type `e', which together forms an instance
15:16:53 <ski> logically, that's `forall a. unique e. EventHandler e a', which is equivalent to `forall a e0 e1. (EventHandler e0 a,EventHandler e1 a) => e0 = e1'
15:17:22 <ski> so you can't in that case have two instances for the same `a' but different `e0' and `e1'
15:18:04 <hpyCdr> not too important in my case, but I'll do
15:18:25 <ski> what this buys you practically (as opposed to attempting to capture integrity constraints in your problem domain), is that you'll get less ambiguous types (which is something that is easy to get with MPTCs)
15:19:05 <sclv> wolfman154: nix works in conjunction with cabal for development
15:19:23 <sclv> Nix manages the deps, but cabal is used to control the builds
15:19:38 <ski> so if you use `hendle' twice in the same definition, on the same `a' type, instead of inferring constraints `(EventHandler e0 a,EventHandler e1 a)', it'll then realize that there can be at most one `e', so that it'll then unify `e0' with `e1' (calling it `e'), and just infer the constraint `EventHandler e a'
15:19:53 <wolfman154> sclv: thanks 
15:20:35 <ski> hpyCdr : just remember that if you run into annoying issues with ambiguous types, when using MPTC methods, adding an appropriate FD on the `class' declaration could help with that
15:20:44 <sclv> wolfman154: https://github.com/Gabriel439/haskell-nix
15:24:29 <hpyCdr> ski, I added it and will do. Thanks
15:25:32 <wolfman154> sclv: thanks 
15:25:33 <fen> does anyone know how to write an instance for Corecursive for [[a]] ?
15:26:05 <fen> possibly using the [a] instance as the return type
15:26:27 <fen> like, the result of an unfold of a state is another state
15:27:12 <fen> ana :: (a -> Base t a)  -> a -> t
15:28:17 <fen> does this mean t = a -> Base t' a ?
15:29:11 <ski> @tell hpyCdr otoh, you shouldn't add an FD, imho, unless it makes sense wrt what kind of situation / problem domain the MPTC is attempting to model
15:29:11 <lambdabot> Consider it noted.
15:29:24 <fen> sorry; t = a -> Base t' [a]
15:29:44 <fen> thats what was meant by an inductive corecusion instance
15:32:49 <fen> we need the State transition function to specify the class of containers
15:32:55 <fen> like, for these nested containers
15:33:09 <fen> we have a parametrisation over all nested containers
15:33:50 <fen> ie there should be a bijection between the state transition function and the alternating nestings of nonempty and list
15:34:21 <fen> not that this is the *only* way it could be cast, as it can also be used to generate an other similar nesting
15:35:01 <fen> like swapping one of the lists for something the same as list, like basically a newtype over it, or other thing isomorphic to it
15:35:39 <fen> but that just as all these equivelant containers have a common base type that their individual base type is isomorphic to
15:36:03 <fen> that is, there is a cannonical base functor
15:36:24 <fen> the containers themselfs are isomorphic to some canonical container, that is the container with the base functor which is the cannonical base functor of the equivilance class
15:37:25 <koz_> I'm trying to compile GHC 8.4.4 (stage2) using GHC 8.6. However, I get this error: http://paste.debian.net/1077416/
15:37:32 <koz_> How can I fix this?
15:38:21 <fen> they are not forwards compatible, you need an older version of the compiler 
15:38:37 <fen> right?
15:38:39 <koz_> fen: So wait, GHC version X can't be built with GHC version >X?
15:38:44 <koz_> That seems... suboptimal.
15:41:21 <fen> well it allows it to change at least!
15:43:50 <koz_> So basically I need a binary GHC 8.4 to build GHC 8.4?
15:44:19 <fen> why cant you use 8.3 or something?
15:44:23 <Solonarv> hm, that seems strange - I was under the impression that GHC X should be buildable with at least the next GHC >X as well
15:44:37 <Solonarv> fen: odd-numbered ghc versions are unreleased/in-development versions
15:44:45 <Solonarv> koz_: try asking in #ghx, perhaps
15:44:53 <koz_> Solonarv: OK, shall do, thanks.
15:45:04 <fen> yeah, dont ask me i dont really know anything about these things
15:45:11 <Solonarv> er, #ghc of course - don't mind the typo
15:45:18 <koz_> Solonarv: Just realized, lol.
15:45:25 <fen> just trying to do the recursive recursion schemes 
15:45:43 <fen> Solonarv: you do that right?
15:47:44 <Solonarv> I do what?
15:48:48 <fen> revcursion-schemes
15:50:40 <Solonarv> not really
15:50:51 <Solonarv> I haven't even used the library much
15:52:06 <fen> oh, i thought you were telling me to translate all my work into recursion-schemes quite recently
15:52:21 <fen> and then having done that you would be able to understand the question
15:52:24 <geekosaur> it's the other way around, ghc X is buildable with versions X-4 through X
15:52:49 <geekosaur> building older versions tends to hit this because it'd take forever to make changes to anything used by ghc otherwise
15:52:57 <Solonarv> ah, makes sense
15:53:00 <Solonarv> koz_: ping
15:53:17 <koz_> Solonarv: I saw. So what, basically, I can't build GHC 8.4 with 8.6?
15:53:23 <Solonarv> seems so
15:53:30 <koz_> If so, that is a large modicum of annoying.
15:53:38 <Solonarv> 'course, you could patch 8.4 to make it build
15:53:49 <koz_> Solonarv: If I knew what to patch, lol.
15:54:04 <Solonarv> shouldn't even be all that difficult, just fix whatever warning you get until there aren't any left
15:54:10 <koz_> Solonarv: I guess I could do that.
15:54:16 <fen> bet that makes a lot of peoples custom ghc's uncompilable or unusable
15:54:26 <fen> whatever they are called, compiler add ons or something
15:54:32 <koz_> It turns out my issues don't even stem from older GHC - they stem from Idris being unhappy with my version of Cabal.
15:54:33 <fen> like the type level lambda project
15:54:35 <koz_> fen: Plugins.
15:54:42 <fen> always wondered how to build that
15:55:04 <fen> probably impossible if we cant even compile the old ghc's
15:55:16 <fen> but wait, there are ghc binaries available for the old versions?
15:55:24 <fen> just use those koz_
15:55:37 <koz_> fen: I'm on a musl-based system.
15:56:15 <Solonarv> koz_: in the case of the error you posted, it's a simple matter of adding/changing an import and s/Map.insertWith'/Map.Strict.insertWith/g (or whatever you import Data.Map.Strict as)
15:56:31 <koz_> s/me/the GHC devs/, but yeah.
15:56:44 <Solonarv> (as the error tells you, conveniently enough)
15:57:15 <koz_> It's fine, turns out I don't even need that, so it's OK.
15:57:24 <koz_> Just need to figure out what Idris has against Cabal > 2.3
15:58:08 <fen> your trying to compile ghc in idris!? or the other way round?
15:58:20 <koz_> fen: My ultimate goal is to have Idris.
15:58:27 <koz_> I tried 'cabal new-install ... idris'.
15:58:28 <koz_> It barfed.
15:58:39 <koz_> I previously successfully installed it (on another machine) using GHC 8.4.
15:58:45 <koz_> I set about getting myself 8.4.
15:58:48 <koz_> Got here.
15:59:01 <koz_> Upon closer inspection figured out the issue seems to stem from Idris not liking Cabal > 2.3.
15:59:06 <koz_> Cue present moment.
15:59:07 <Solonarv> interesting, idris' dependencies suggest it should compile with 8.6
15:59:21 <geekosaur> bindists usually are the better bet. but you should be able to build an older Cabal lib with 8.6
15:59:21 <koz_> Solonarv: Yeah, so it says. I've asked in #idris, but it's a fairly quiet channel.
15:59:43 <koz_> geekosaur: So basically, try and build Cabal version < 2.4 and try again?
15:59:56 <fen> oh right its got a bunch of "cabal: The following packages are likely to be broken by the reinstalls:"
16:00:04 <fen> thats never a good sign
16:00:14 <geekosaur> yeh. although you may need to do something to ensure it sees the right version
16:01:01 <koz_> geekosaur: Worth a shot at least.
16:01:06 <fen> it sees 1.3.1
16:02:20 <fen> why would it need a depreciated cabal?
16:02:26 <fen> that should never be the case right?
16:02:49 <koz_> fen: I am not aware of any deprecation notice being given for Cabal < 2.4.
16:02:53 <koz_> At least not for a few versions.
16:03:24 <fen> huh?
16:03:34 <fen> oh right sorry 
16:03:36 <fen> nvm
16:04:22 <fen> so its just the newest version is unstable?
16:04:36 <fen> does this constitute a bug?
16:04:44 <koz_> fen: I'm not sure if you're referring to Idris or Cabal, but in either case, I don't think that's true either.
16:04:45 <Solonarv> no bug there
16:04:59 <Solonarv> looking at idris.cabal, it uses a custom Setup.hs
16:05:00 <geekosaur> there is a deprecation for "new-*" commands in cabal-install (which is quasi-independent of the Cabal library) in favor of v2-*, in expectation that new-* will be used for cabal 3 enhancements in the future
16:05:00 <fen> "Idris not liking Cabal > 2.3."
16:05:13 <fen> this should not be possible? 
16:05:21 <geekosaur> cabal-install 3.x
16:05:22 <Solonarv> presumably there's some API change in Cabal 2.4 that makes their Setup.hs not work anymore
16:05:27 <Solonarv> which is perfectly in line with the PVP
16:06:29 <fen> so we need a version manager for our build tools now too!?
16:06:57 <koz_> Solonarv: So I guess I should probably report this?
16:07:33 <fen> ana :: (a -> Base t a)  -> a -> t
16:07:37 <fen> whats that for [[a]]
16:07:38 <fen> ?
16:08:08 <Solonarv> koz_: to the idris folks? yeah, seems reasonable
16:08:22 <koz_> Solonarv: OK, shall do.
16:08:52 <Solonarv> they probably wouldn't mind if you had a fix ready as well ;)
16:09:50 <fen> so like, for t = [a], Base t a === [a] ?
16:09:54 <koz_> Solonarv: Yeah... I think I'll just report. :P
16:10:39 <fen> type instance Base [a] = ListF a
16:11:03 <fen> data ListF a b = Nil | Cons a b
16:11:50 <fen> ok, so Base [a] a = ListF a a = Nil | Cons a (ListF a a)
16:12:04 <fen> hmm, is that an extra recusive call more than it should be...
16:12:23 <fen> ListF a a = Nil | Cons a a
16:12:28 <fen> that does not seem right
16:12:32 <c_wraith> well it's a random shift between type equivalence and type definition
16:12:41 <c_wraith> that's absolutely right
16:12:41 <Solonarv> no, it is right
16:12:48 <fen> okok
16:12:54 <c_wraith> err, no.
16:13:01 <fen> and then now we want it to be a State
16:13:01 <c_wraith> needs two different type variables
16:13:10 <fen> instead of a [a]
16:13:27 <fen> no, we need to do the [[a]] normally first
16:14:03 <fen> c_wraith: no its just the actual state transition type;
16:14:32 <c_wraith> OK, you're conflating type equivalence and definition.
16:14:48 <c_wraith> that's *extremely* confusing.
16:15:10 <fen> (a -> Base t a) = (a -> Base [a] a) = (a -> ListF a a) === a -> (Maybe (a,a))
16:15:13 <fen> argh thats wrong!
16:15:28 <fen> yes, this is confusing your right
16:15:48 <fen> oh, t /= [a]
16:16:02 <fen> `a' is the fix thing
16:16:11 <fen> so maybe it would work with t = [x]
16:16:25 <fen> are they using `a' to mean the state
16:16:32 <fen> yes ok
16:17:02 <fen> ana :: (s -> Base t s)  -> s -> t
16:17:21 <fen> t = [a]
16:19:20 <fen> (s -> Base t s) = (s -> Base [a] s) = (s -> ListF a s) === s -> (Maybe (a,s))
16:20:11 <fen> having used; data ListF a s = Nil | Cons a s === Maybe (a,s)
16:21:03 <fen> ana :: (s -> (Maybe (a,s)))  -> s -> [a]
16:21:05 <fen> as desired
16:21:17 <fen> now we want t = [[a]]
16:21:20 <koz_> OK, if I tell cabal new-install to use an older Cabal, I now get complaints that my containers is too new...
16:21:48 <koz_> Is there a way I can tell it to ignore any system-level packages?
16:22:03 <koz_> Like, I want it to use the .cabal stuff and _nothing else_.
16:22:22 <fen> and we want to get there by using t = (s -> Base [a] s)
16:23:07 <fen> ana :: (s' -> Base (s -> Base [a] s) s')  -> s' -> (s -> Base [a] s)
16:23:10 <fen> right!
16:23:31 <fen> so whats (Base (s -> Base [a] s) s')
16:23:32 <fen> ?
16:24:41 <fen> sorry it took so long to get to this point.... is that the bascailly thing that manages to capture all the questions?
16:24:53 <fen> i think this is basically what I want
16:26:47 * hackage liquidhaskell-cabal-demo 0.2.0.1 - Demo of Liquid Haskell integration for Cabal and stack  https://hackage.haskell.org/package/liquidhaskell-cabal-demo-0.2.0.1 (MichaelSmith)
16:27:02 <fen> and then you would have a recursion over this
16:27:24 <fen> meaining the newtype over (s -> Base [a] s) would be parametrised by depth
16:27:44 <fen> but basically this information is already there by how nested the `a' is
16:28:28 <fen> maybe something like \f -> (s -> Base (f a) s)
16:28:49 <fen> and then its identified by the argument `f' which "parametrises this equivalence class"
16:30:10 <fen> but then (Base (s -> Base [a] s) s') is the next level up... hmm thats not good because the first argument to base is a transition function
16:30:43 <fen> so maybe the lowest level needs to be (s -> Base (s -> Base a s) s)
16:30:50 <fen> instead of (s -> Base [a] s)
16:31:06 <fen> oh god this is horrible
16:40:20 <fen> help!
16:47:28 <adamCS> fen: Have you looked at yaya (http://hackage.haskell.org/package/yaya)?  That's another recursion schemes package but it may be somewhat more oriented toward the way you are thinking.
16:48:30 <fen> how is it?
16:49:25 <fen> ana :: Coalgebra f a -> a -> t
16:49:27 <adamCS> Not sure.  But there are a lot of Maybe and Either and NonEmpty as Base functors and I wonder if that presentation wouldn't align more with whatever you are trying to work out.  Worth a look, maybe.
16:49:33 <fen> type Coalgebra f a = a -> f a
16:50:03 <fen> ana :: (s -> Base t s)  -> s -> t
16:50:35 <fen> ana :: Coalgebra f s -> s -> t
16:51:19 <fen> a -> f a === Base t s
16:51:38 <fen> class Recursive t f | t -> f where
16:52:25 <fen> so instead of having a base class they just take the base type as another parameter 
16:53:01 <fen> oh there is an error above; f a === Base t s
16:53:10 <fen> yeah, these look totally equivalent
16:53:16 <fen> the modules
16:53:24 <adamCS> which?  Yaya and Recursion schemes?  
16:53:30 <fen> yes
16:53:35 <adamCS> Yes.  They are.
16:53:57 <adamCS> Just thought the yaya version might be closer to how you were thinking.  Not sure.
16:54:05 <fen> isnt there a difference between assocaited types and extra parameters?
16:54:14 <fen> maybe not
16:54:15 <adamCS> In a class?
16:54:35 <adamCS> You mean associated type family vs. functional dependencies?
16:54:40 <fen> yes
16:54:50 <adamCS> They often accomplish very similar things.
16:55:01 <adamCS> But, I think, they are not quite the same.
16:55:16 <fen> how could it be more similar and totally equivalent at the same time?
16:55:59 <adamCS> The history, as I understand it goes:  Multiparam type classes, yay! Oh, inference issues.  Fundeps, yay!  Oh, maybe not.  Associated type families, yay!  Oh wait, maybe fundeps were good?
16:56:01 <fen> oh it has some lenses too
16:56:13 <fen> no this is not helpful. thanks anyway though
16:56:38 <adamCS> k
16:56:51 <fen> well injective type families were needed before associated types could be as good as fundeps
16:58:10 <fen> well, ok no bother trying to phrase the above again in this neater syntax
16:59:12 <fen> ana :: (s -> f s) -> s -> t
16:59:57 <fen> set, t = [a], f s = Maybe (s,a)
17:00:14 <fen> set, t = [a], f s = Maybe (a,s)
17:00:45 <fen> wait, how is the `a' supposed to get from in the `t' to into the `f s' ?
17:01:29 <adamCS> data MyType a s = Maybe (a,s) ? 
17:01:37 <adamCS> sorry
17:01:58 <adamCS> newtype M a s = M (Maybe (a,s))
17:02:27 <fen> well you can just give it as a synonym...
17:02:47 * hackage higgledy 0.1.0.0 - Partial types as a type constructor.  https://hackage.haskell.org/package/higgledy-0.1.0.0 (i_am_tom)
17:03:05 <fen> instance Corecursive [a] (a -> (a,s))
17:03:17 <fen> oh, it needs the `s' as another argument?
17:03:31 <fen> instance Corecursive [a] (M a)
17:04:27 <fen> ana :: Coalgebra (M a) s -> s -> [a]
17:04:59 <fen> Coalgebra (M a) s = s -> M (Maybe (a,s))
17:05:14 <fen> ok that seems to work ok
17:05:22 <fen> so then we should try [[a]]
17:05:54 <fen> and then get something like, instead of trying to unfold [[a]] we first unfold the state transition function over the return value type [a]
17:06:09 <fen> which we can then unfold again to give [[a]]
17:06:38 <adamCS> sorry. Gotta go for a bit.  But I'm not following where the nesting is happening.  Or why.  What's the function you are trying to write?
17:06:55 <fen> ill keep typing you can check when you get back
17:07:10 <fen> not sure why is the correct question?
17:07:17 <fen> ana :: (s -> f s) -> s -> t
17:07:33 <fen> set, t = [[a]]
17:08:10 <fen> no, first, t = Coalgebra (M a) s
17:08:22 <fen> or is it (Coalgebra (M a) s,s) ?
17:08:24 <fen> hmmm
17:08:57 <fen> yes, we want a state to continue to unfold with
17:10:01 <fen> ana :: (s -> f s) -> s -> (s' -> f' s',s')
17:10:15 <fen> thats very clearly of the correct form for a recursion
17:10:31 <fen> with s'',f'' etc
17:10:59 <fen> but there is still no way of determining f from t
17:11:08 <fen> so the yaya package wont really do
17:11:19 <ski> you want an existential there, not a universal
17:11:32 <fen> a what!?
17:11:44 <ski> it ought not to be
17:11:54 <fen> is that a question?
17:12:10 <ski>   ana :: forall s s' f f'. (Functor f,Functor f') => (s -> f s) -> s -> (s' -> f' s',s')
17:12:38 <fen> hmm
17:12:54 <fen> well thats certainly wrong
17:13:06 <fen> its the function of a class, so those parameters are bound
17:13:21 <ski> that's just what you typed, adding in explicit universals for the unbound variables (and throwing in `Functor' constraints, for good measure)
17:13:22 <fen> it takes t f |t -> f
17:13:37 <fen> where t = (s' -> f' s',s')
17:13:39 <ski> there is no `t' in the type signature
17:13:41 <fen> we have;
17:14:00 <ski> even if
17:14:02 <ski>   t = (s' -> f' s',s')
17:14:17 <ski> you'd still have to decide how to bind the variables on the right hand side
17:15:31 <fen> instance Corecursive f (\s' -> (s' -> f' s',s'))
17:16:14 <fen> f' seems to contain f somehow
17:16:23 <fen> contain `a' somehow
17:16:32 <fen> this is all very confusing
17:17:29 <fen> class Corecursive t f | t -> f where ana :: (a -> f a) -> a -> t
17:17:48 <fen> in the depth 2 case;
17:18:11 <ski> i dunno why you're thinking in terms of  s'  and  f'  at all
17:18:45 <ski> that instance for `Corecursive' wouldn't be kind-correct, wouldn't kind-check
17:19:00 <fen> instance Corecursive (s' -> Maybe ([a],s')) f
17:19:24 <fen> where we should determine f
17:19:40 * ski doesn't understand that at all
17:19:50 <fen> i suspect it to be something like (s' -> Maybe (Maybe (a,s))
17:19:59 <fen> i suspect it to be something like (s' -> Maybe (Maybe (a,s'))
17:20:14 <ski> i think you're still missing your quantifiers
17:20:31 <fen> instance Corecursive (s -> Maybe ([a],s)) (s' -> Maybe (Maybe (a,s'))
17:20:48 <fen> where obviously we then have;
17:20:54 <fen> instance Corecursive (s -> Maybe ([a],s)) [[a]]
17:21:04 <fen> oh shit
17:21:12 <ski> doesn't look kind correct, either
17:21:20 <fen> noo
17:21:37 <fen> if you tried it would proabaly be correct
17:22:03 <ski> what is the argument order of `Corecursive' ?
17:22:30 <fen> class Corecursive t f | t -> f where ana :: (s -> f s) -> s -> t
17:22:36 <fen> thats the actual class
17:23:01 <ski> ok, so `Corecursive :: * -> (* -> *) -> Constraint', then
17:23:10 <fen> yes
17:23:34 <ski> `[[a]]' doesn't have kind `* -> *'. it has kind `*' (assuming `a' has kind `*')
17:23:45 <fen> f is not [[a]]
17:23:56 <ski> <fen> instance Corecursive (s -> Maybe ([a],s)) [[a]]
17:23:57 <fen> there are 2 instances, the second has t = [[a]]
17:24:06 <fen> yeah that was the wrong way round sorry
17:24:32 <ski> `s -> Maybe ([a],s)' still has kind `*' (assuming `a' and `s' has kind `*'), not kind `* -> *'
17:24:47 <fen> right, its f s for some f
17:24:55 <ski> what is ?
17:25:05 <fen> f s  = s -> Maybe ([a],s)
17:25:30 <fen> instance Corecursive [[a]] (\s -> s -> Maybe ([a],s)) 
17:25:31 <ski> oh, so you meant `\s -> (s -> Maybe ([a],s))', then ?
17:25:33 <fen> ok 
17:25:37 <fen> thanks
17:25:54 <fen> it was the lambda f that was confusing me because it was all backwards
17:26:04 <fen> and wasnt sure that f took s and not `a;
17:26:08 <fen> so
17:26:19 <fen> we can join those 2 instances together
17:26:29 <ski> in the signature of `ana' before, you called it `a'
17:26:34 <fen> hopefully with somthing like an overlapping undecidable instance 
17:29:01 <fen> instance Corecursive ((\s -> (s -> Maybe ([a],s))),s') (\s' -> (s' -> Maybe (Maybe (a,s')))
17:29:27 <fen> holy shit!
17:30:10 <fen> then the bit we cant do which is needed is to determine the relation between this f and t
17:30:21 <fen> so that we can write this for any depth
17:32:18 <fen> and use it as an inductive thing, to give the instances converting between states that are not adjacent wrt this nesting, like [a] is next to [[a]]. so we could get the [[[a]]] to [a] instance by combining the enc [[[a]]] to enc [[a]] instance with the enc [[a]] to enc [a] instance
17:32:38 <fen> writing `enc t' to mean the state encoding of, as used in those examples
17:33:00 <fen> ski: still with me?
17:33:12 <ski> nope
17:33:19 <fen> myahh
17:33:22 <ski> that instance doesn't make any sense to me
17:33:58 <fen> in what way?
17:34:16 <ski> what is the kind of `((\s -> ..s..),s')' ?
17:34:16 <fen> we are unfolding a state encoding
17:34:21 <fen> *
17:34:28 <fen> its a function value pair
17:34:28 <ski> no ?
17:34:54 <fen> :k ((,) Int,Int)
17:34:55 <lambdabot> error:
17:34:55 <lambdabot>     • Expecting one more argument to ‘(,) Int’
17:34:55 <lambdabot>       Expected a type, but ‘(,) Int’ has kind ‘* -> *’
17:35:01 <fen> hmm
17:35:18 <fen> :k '((,) Int,Int)
17:35:18 <lambdabot> (* -> *, *)
17:35:23 <fen> damn
17:35:40 <ski> even if you mean a type pair, and not a pair type, it'd be of the kind you just got there, not of kind `*'
17:35:46 <fen> nono this is all wrong
17:36:15 <ski> yes, that's what i said :)
17:37:31 <fen> the thing thats confusing is trying to unfold a state transition function type
17:37:46 <ski> unfold, how ?
17:38:08 <fen> well, suppose we start with (s -> Maybe (Maybe (s,a)))
17:38:27 <fen> then we unfold this as if it were (s -> Maybe (s,a))
17:38:35 <ski> are you going to define anamorphisms at the type level ?
17:38:38 <fen> ie, we stop when it fails
17:38:50 <fen> ski: do we need to?
17:38:55 <ski> i dunno
17:39:03 <fen> its not just a forall somewhere?
17:39:21 <fen> never mind the types until it becomes apparent something like that is nesacary
17:39:28 <fen> i dont think we need anything like Fix
17:40:26 <ski> "unfold a state transition function type" sounds to me like you're maybe wanting to pass a type (like `s -> Maybe (Maybe (s,a))' ?) as argument to a type `Ana' of kind `(k0 -> kf k1) -> k0 -> k1', or something like that
17:41:05 <fen> anyway, we end up with a function of type; (s -> Maybe (Maybe (s,a))) -> s -> [[a]]
17:41:11 <ski> (but quite possibly that's not what you had in mind. just saying that if you say "unfold a ... type", then it *sounds* like you have something like that in mind)
17:41:43 <fen> by combining the complex thing we are searching for with; (s' -> Maybe (s,[a])) -> s -> [[a]]
17:41:51 <ski> i don't see how that function would work
17:41:58 <fen> not sure about these s'
17:42:09 <fen> which one are you unsure of?
17:42:10 <ski> how would you write
17:42:17 <ski>   unfoldLists :: (s -> Maybe (Maybe (s,a))) -> s -> [[a]]
17:42:18 <ski> ?
17:42:26 <fen> by combining 2 stages
17:42:30 <hasker1> ?pl \xs -> (last xs) : xs
17:42:30 <lambdabot> (:) =<< last
17:42:43 <ski>   unfoldLists step init = case step init of
17:42:49 <ski>     Nothing -> []
17:43:10 <ski>     Just Nothing -> ???
17:43:22 <fen> first unfolding a state encoding (state transition and state value, returning [a] as the return value) and then unfolding this
17:43:26 <fen> ^^
17:43:46 <ski>     Just (Just (next,a)) -> (a:as):ass
17:43:51 <ski>       where
17:44:04 <ski>       as:ass = unfoldLists step next
17:44:11 <ski> something like that ?
17:45:01 <dmrd_> NickServ IDENTIFY dmrd polikarnperu
17:45:04 <ski> how does it determine when one of the lists is finished, so as to possibly begin a new one ?
17:45:17 * hackage wolf 0.3.47 - Amazon Simple Workflow Service Wrapper.  https://hackage.haskell.org/package/wolf-0.3.47 (markfine)
17:45:33 <ski> (also, can it possibly generate more than one infinite list in the output list of lists ?)
17:46:00 <systemfault> dmrd_: Time to change your pass (in case you haven't seen it)
17:46:08 <ski> dmrd_ : better change that
17:46:16 <dmrd_> I'm dumb, I'm looking for the command right now
17:46:36 <fen_> ski: https://pastebin.com/raw/Lbq7mZ6W
17:47:23 <fen_> sorry the types are messed up there... ill try again
17:47:59 <ski> /msg NickServ set password <new password>
17:48:00 <Solonarv> dmrd_: just /query NickServ and do everything in there
17:48:07 <ski> dmrd_ : ^ after you have identified
17:48:19 <dmrd_> fixed
17:48:39 <dmrd_> thanks folks, lol.  Literally a nightmarish 5 minutes
17:48:43 <fen_> ski: https://pastebin.com/raw/7r83W9s3
17:49:38 <ski> (brb)
17:56:46 <johnw> phadej: yay, using ConduitT everywhere solved my last problem
17:56:58 <johnw> I'm now updated to servant-0.16 and things are working again
18:00:50 <fen> johnw: is that the final boss?
18:01:00 <johnw> no
18:01:10 <johnw> now I'm dealing with what might be a GHC bug, over in #ghc
18:01:19 <johnw> trying to track it down
18:01:58 <fen> this type makes no sense; http://hackage.haskell.org/package/conduit-1.3.1.1/docs/src/Data.Conduit.Internal.Pipe.html#Pipe
18:03:28 <Solonarv> ah, I remember thinking the same thing
18:05:12 <ski> fen : i don't see `(s -> Maybe (Maybe (s,a))) -> s -> [[a]]' in that paste
18:07:31 <fen> no, its using nonempty 
18:07:43 <fen> its actually a more confusing situation there
18:08:05 <fen> because of the arbitrary choice of which way round the nestings go
18:08:16 <fen> but it happens to be some old code that exists
18:08:18 <Solonarv> huh, Conduit is actually a free monad
18:08:30 <Solonarv> I wonder why its instances aren't written to take that into account
18:09:54 <Solonarv> s/Conduit/Pipe l i o u m/
18:10:03 <MarcelineVQ> haskell: reminder to check out https://hackage.haskell.org/package/polysemy if you haven't yet
18:10:15 <adamCS> MarcelineVQ: right?
18:10:28 <Solonarv> yeah, I saw it already - looks cool!
18:10:29 <adamCS> I have a freer-simple thing I'm itching to convert
18:11:14 <johnw> Solonarv: https://github.com/jwiegley/notes/blob/master/haskell/PipesCompile.hs#L33
18:11:35 <johnw> Solonarv: that explores Pipes as a Free type
18:11:52 <Solonarv> and still the 'm' parameter gets a Monad constraint everywhere
18:11:57 <Solonarv> that's mostly what has me puzzled
18:12:02 <johnw> and then also https://github.com/jwiegley/notes/blob/master/haskell/PipesFreeT.hs#L6
18:12:27 <fen> ski, anyway it would be a combination of superLoop :: SuperState s a -> State1 s [a]
18:12:29 <fen> and;
18:13:09 <fen> oh wait, the 2 pastes are mixed up
18:13:13 <fen> hyloState1 :: State1 s a -> (CoState1 b a) -> s ->  b
18:13:13 <Solonarv> johnw: interesting!
18:13:36 <fen> but then you need to have "build" to turn that into a list
18:13:47 <fen> like, b = [a]
18:14:03 <fen> but thats a forall a.
18:14:12 <fen> and its the [a] returned by the superstate
18:14:50 <johnw> Solonarv: yeah, unidirectional Pipes is just FreeT m over a Teletype algebra
18:15:16 <Solonarv> even the one in Conduit is at least a Free monad, possibly even a FreeT
18:15:17 <ski> `Polysemy.Cont' ?
18:15:28 <Solonarv> er, I mean, it's a FreeT
18:23:22 <fen> ski: https://pastebin.com/Gra7aS8E
18:25:03 <fen> teletype algebra!?
18:26:58 <johnw> polysemy looks cool
18:27:08 <johnw> every month needs a new algebraic effects library
18:28:06 <Solonarv> this one does fancy effects (e.g. bracket) too!
18:28:58 <johnw> i like the option of monad lifted effects
18:29:14 <johnw> the only real problem with algebraic effects libraries is that people generally don't know them, so it limits contributors sometimes
18:29:51 <fen> it uses the phrase "business logic" in the first sentence of the overview. now i need to be convinced to keep reading! 
18:31:23 <fen> Solonarv: whats bracket?
18:31:55 <Solonarv> bracket :: IO a -> (a -> IO ()) -> (a -> IO b) -> IO b
18:32:14 <fen> IO zip liftA2?
18:32:37 <Solonarv> bracket acquire free use = do x <- acquire; use x `finally` free x
18:32:52 <Solonarv> (the actual implementation is a bit more complicated)
18:33:34 <Solonarv> useful to allocate a resource (e.g. open a file) while making sure it will be released properly
18:33:34 <fen> its not some kind of async / mutable thing is it?
18:33:51 <fen> or is it for like, managing server connections or something?
18:34:00 <Solonarv> that's one thing you can use it for
18:34:13 <fen> thats like, worse than not having that though
18:34:18 <Solonarv> how so?
18:34:35 <fen> thats the exact type of thing that should be abstracted away from the user in the haskell traditional style
18:34:54 <fen> if you dont hold reference to it, its gc'd
18:35:15 <Solonarv> yea sure but GC might happen like 5 hours later
18:35:39 <Solonarv> there's no guarantee that garbage collection happens promptly, or that finalizers are run promptly
18:36:06 <fen> well if you have bracket to do so, why cant this just be combined with the way you describe which sounds bad
18:36:21 <fen> like, why is it bad when it seems like there are tools which could make it better
18:36:32 <fen> so that we should never actually use that kind of tool
18:36:39 <Solonarv> I'm not even sure what it is you don't like about bracket
18:36:54 <fen> that which could be incorperated into an existing form of abstraction
18:37:08 <Solonarv> functions are an existing form of abstraction
18:37:19 <fen> because its for resource managment, and that should be abstracted away from the user
18:37:30 <fen> im the user, not the person that writes that layer of abstraction
18:37:34 <fen> says me
18:37:50 <fen> no time for mutable things 
18:37:50 <Solonarv> most libraries expose some sort of with*** function
18:38:03 <fen> IO is already going too far
18:38:14 <Solonarv> e.g. withFile :: FilePath -> Mode -> (Handle -> IO a) -> IO a
18:38:20 <Solonarv> you as a user don't want to use IO?
18:38:21 <fen> the very most i would accept is an input and an output vector of streams
18:38:22 <nshepperd> bracket is for IO things
18:38:50 <fen> a changing lengthed vector of IO streams is going too far
18:38:55 <nshepperd> you seem to be conceiving of bracket as being a solution to some entirely different problem
18:39:01 <nshepperd> i'm not even sure what
18:39:13 <fen> ho to free a resource after its no longer needed
18:39:31 <fen> i have a screen and a keyboard
18:39:39 <fen> i dont need to free these resources
18:39:41 <Solonarv> bracket is for e.g. "I would like to open a file, do something with it, and not make the silly mistake of forgetting to close it"
18:40:06 <fen> oh yeah, forgot about that
18:40:08 <Solonarv> for the special case of working with a file there is withFile, which I mentioned above
18:40:13 <fen> hmm
18:40:24 <fen> too much thinking like frp style mobile apps
18:40:34 <Solonarv> which is basically just: withFile path mode = bracket (openFile path mode) closeHandle
18:40:34 <nshepperd> it also makes sure that the file is closed even if your program throws an exception while operating on the file
18:40:40 <Solonarv> (might have gotten some names wrong)
18:40:49 <fen> forgot about long term memory 
18:40:56 <Solonarv> nshepperd: yep, that counts under "silly mistake"
18:40:59 <mniip> fen, are you abastro
18:41:07 <Solonarv> well, it's less silly than forgetting to close altogether
18:41:20 <fen> thought the malloc backend could handle all IO except the human computer interface
18:41:47 <fen> stupid web sockets and file system
18:41:49 <Solonarv> it most certainly can't
18:41:58 <Solonarv> (also, what's a "malloc backend"?)
18:42:09 <fen> idk, whatever lets me never have to think about IO
18:42:15 <fen> wrt malloc
18:42:39 <Solonarv> you can call malloc from Haskell if you want to; if you do, you have to think about IO
18:42:50 <fen> no
18:42:53 <fen> i dont have to
18:42:56 <fen> thats the whole point
18:43:11 <Solonarv> well I guess you can try to call 'malloc :: Int -> IO (Ptr a)' without thinking about IO
18:43:13 <fen> providing the capability to thus seems like a step backwards
18:43:16 <Solonarv> but I wouldn't recommend it
18:43:29 <fen> a pure immutable interface is a happy place
18:44:06 <fen> so the only IO i would ever need is a changing lengthed list of streams
18:44:25 <fen> with tags to tell what they are for
18:45:16 <fen> so there would be like an "add bluetooth-node" or "add-camera" which would add the extra stream to the list
18:45:36 <fen> and then i guess it would just not ever have to be freed because that should be automatic
18:45:52 <fen> but that seems like a malloc
18:46:13 <Solonarv> in what world is that "like a malloc"
18:46:14 <fen> some kind of allocating a new device slot or something, 
18:46:16 <ski> teletype algebra ?
18:46:37 <fen> like adding a memmory address, but adding a hardware IO stream address
18:46:39 <Solonarv> ski: data Teletype a where Get :: Teletype String; Put :: String -> Teletype ()
18:46:49 <fen> of which there are far fewer
18:46:52 <Solonarv> aka the standard free(r) monad / extensible-effect example
18:47:28 <fen> that is a wierd looking type ski
18:47:32 <ski> afaics `superLoop' will accumulate the result similarly to `foldl' .. that doesn't seem like an appropriate `ana' for `Compose [] []' (or `Compose NonEmpty []'), to me 
18:47:34 <fen> did you see the paste above?
18:47:37 <fen> oh 
18:47:42 <fen> :D
18:47:56 <fen> its a hylo 
18:48:02 <fen> thats how unfold works
18:48:05 <ski> (or rather, doesn't seem like an appropriate building block, for an anamorphism)
18:48:14 <fen> ahaaa
18:48:18 <fen> this is the difference
18:48:30 <fen> im only using things which are unfoldable because they have set
18:48:33 <ski> afaiu, it builds the element lists backwards
18:48:40 <fen> yeah thats fine
18:48:46 <fen> that shows its good
18:49:01 <ski> (btw, that `Teletype' thing doesn't look that weird, to me)
18:49:23 <fen> ok, well its the point; unfolding, like ana - as a way to "abstract over set" .... im just demanding it as an argument
18:49:25 <ski> i don't understand
18:49:48 <fen> you could encode it as a continuation style thing but this isnt the approach taken here
18:50:26 <fen> as in, if you can produce values then you can return a container of those values
18:50:37 <ski>   ana2 :: (s -> Maybe (a,Maybe s)) -> s -> Nonempty [a]
18:50:38 <fen> thats "abstracting away the *set* "
18:50:50 <fen> im not abstracting it away
18:51:19 <fen> ski: whats wrong with that!? its the exact type we were going for
18:51:35 <fen> well, modulo [] /= Nonempty
18:52:06 <fen> this is the first example of a "depth 2 higher order state transition function type"
18:52:13 <fen> (s -> Maybe (a,Maybe s)) 
18:52:19 <fen> called "superstate" in the paste
18:52:36 <fen> and the problem is trying to extend this type to higher orders
18:52:57 <fen> the idea was (s -> MaybeN n (a,MaybeN n s))
18:53:14 <fen> but that is ambiguous over the choice of where the list and the nonempty lists are
18:53:30 <fen> they can be in any order and this type would still have an implementation
18:54:00 <fen> so we need something with more information, as much as [Bool] of length = the depth of the nesting
18:54:10 <fen> that is, to choose between list and nonempty at each layer
18:54:40 <fen> this thing has l, we need 2^l
18:54:59 <fen> so i cant figure out the higer order version of superstate
18:55:37 <fen> the idea that if we can get from a n-order superstate to a (n-1)-order superstate then we can continue inductively to the basecase
18:56:00 <fen> so give an instance for Corecursive from any order and any lower order superatete
18:56:10 <fen> between*
18:56:39 <fen> that seems fairly simple, though writing that type would require this higher order version of superstate 
18:56:58 <fen> thats why we were just sticking to depth 2 where we have an actual example
18:57:16 <fen> the l and l^2 (almost) matching up for depth l = 2
18:57:26 <fen> we have 3 types, and 4 choices
18:57:35 <fen> hmm ok that math isnt right
18:57:47 <fen> there is probably an m `choose` n somewhere
18:58:16 <fen> (s -> Maybe (Maybe (a,s))) to unfold [[a]]
18:58:53 <fen> (s -> (a,Maybe (Maybe s))) to unfold `Nonempty (Nonempty a)'
18:59:32 <fen> and the superstate in the paste for either [Nonempty a] or (Nonempty [a])
18:59:50 <fen> thats; (s -> Maybe (a, (Maybe s)))
19:00:07 <fen> here we can see they are all in the form of; (s -> MaybeN n (a,MaybeN n s))
19:00:29 <fen> and we can see how it does not unambiguously map to the order of nesting
19:00:30 <fen> .
19:03:43 <fen> these ideas can be comprehended?
19:07:40 <fen> l+1 vs 2^l ?
19:09:04 <fen> cant just use [Bool] because then where do the s and a go!?
19:09:28 <fen> (just doing nonempty and []...)
19:09:48 <fen> if there were streams as well (strictly infinite) it would be 2^l
19:10:11 <fen> 3^l
19:11:12 <fresheyeball> I seem to be confused by a very simple lens thing
19:11:21 <fen> pretty much, for simplicity, we could just use lists. then we would just has (s -> MaybeN n (a,s))
19:11:23 <fresheyeball> f :: Lens' a b
19:11:31 <fresheyeball> g :: Prism' b c
19:11:34 <fresheyeball> I expected
19:11:39 <fresheyeball> f . g :: Prism' a c
19:11:45 <fresheyeball> but it vomits
19:12:13 <fen> is that for sum types instead of product types?
19:12:21 <fen> why would you expect it would compose like that?
19:12:38 <fresheyeball> what is it though? I tought a lens composed with a prism was a prism
19:12:55 <fen> idk, i only think about product types, sorry
19:13:10 <fen> except maybe of course!
19:13:18 <fen> and occasionally either
19:13:33 <fen> normally people have prisms when they have DLSs or something
19:13:50 <fen> like, large mutailly recursive types. that sounds mad
19:13:56 <fen> cant even do 1d recursion
19:14:04 <fen> :-/
19:15:04 <Solonarv> fresheyeball: it's a Traversal
19:16:44 <Solonarv> roughly: a Lens' s a is an isomorphism between s and (C, a); a Prism' s a is an isomorphism between s and Either C a
19:17:26 <Solonarv> so if you compose them you get an iso between s and (C1, Either C2 a) or Either C1 (C2, a)
19:17:32 <Solonarv> (depending on which way 'round you compose)
19:20:10 <fresheyeball> Solonarv:++
19:20:14 <fresheyeball> Solonarv++
19:20:51 <Solonarv> fresheyeball: another perspective: a Lens' s a is a pair of functions (get :: s -> a, set :: s -> a -> s); a Prism' s a is a pair of functions (match :: s -> Maybe a, construct :: a -> s)
19:21:37 <Solonarv> if you compose these the result can have 'match' and 'set', but it can't have 'get' (so it isn't a Lens') and it can't have 'construct' (so it isn't a Prism')
19:21:47 * hackage composition-prelude 2.0.5.0 - Higher-order function combinators  https://hackage.haskell.org/package/composition-prelude-2.0.5.0 (vmchale)
19:25:06 <Solonarv> fresheyeball: does that help?
19:27:30 <fen> whats its complexity this thing Solonarv: 
19:27:41 <fen> can you get the l^2 hing ?
19:28:35 <fresheyeball> Solonarv: yes
19:32:37 <remexre> is it reasonable to define (for Arbitrary) shrink = traverse shrink?
19:32:50 <remexre> or am I missing some case if I do?
19:33:19 <remexre> (the datatype is an AST doing something similar to higher-kinded data internally)
19:38:17 <fen> :t let shrink = traverse shrink in shrink
19:38:18 <lambdabot> error:
19:38:18 <lambdabot>     • Occurs check: cannot construct the infinite type: a1 ~ [a1]
19:38:18 <lambdabot>       Expected type: a1 -> f1 b1
19:41:52 <dmwit> Solonarv:--
19:42:08 <dmwit> that doppleganger has to earn their own karma!
19:44:20 <remexre> er wait
19:44:27 <fen> stabilizers vs creativity... inventing wheels is an important life skill
19:45:07 <remexre> fen, I think that doesn't work because the let is recursive, no?
19:45:11 <remexre> :t traverse shrink
19:45:12 <lambdabot> (Arbitrary b, Traversable t) => t b -> [t b]
19:46:23 <fen> :t shrink
19:46:24 <lambdabot> Arbitrary a => a -> [a]
19:46:27 <fen> oh
19:46:32 <fen> didnt know that was a thing
19:46:52 <fen> but you said; shrink = traverse shrink
19:47:38 <fen> huh
19:47:42 <fen> what a wierd type
19:47:48 <remexre> shrink is a typeclass method
19:47:54 <fen> > shrink [1,2,3]
19:47:56 <lambdabot>  [[],[2,3],[1,3],[1,2],[0,2,3],[1,0,3],[1,1,3],[1,2,0],[1,2,2]]
19:48:10 <fen> > shrink [1,2]
19:48:12 <lambdabot>  [[],[2],[1],[0,2],[1,0],[1,1]]
19:48:16 <remexre> it's part of QuickCheck
19:48:16 <fen> > traverse shrink [1,2]
19:48:18 <lambdabot>  [[0,0],[0,1]]
19:48:42 <remexre> ah
19:48:45 <fen> > traverse (traverse shrink) [1,2]
19:48:47 <lambdabot>  error:
19:48:47 <lambdabot>      • No instance for (Num [()]) arising from a use of ‘e_112’
19:48:47 <lambdabot>      • In the expression: e_112
19:48:53 <fen> > traverse (traverse shrink) [1,2,3]
19:48:56 <lambdabot>  error:
19:48:56 <lambdabot>      • No instance for (Num [()]) arising from a use of ‘e_1123’
19:48:56 <lambdabot>      • In the expression: e_1123
19:48:59 <fen> oh nvm
19:49:04 <dmwit> > traverse (traverse shrink) [[1,2],[3,4]]
19:49:06 <lambdabot>  [[[0,0],[0,0]],[[0,0],[0,2]],[[0,0],[0,3]],[[0,0],[2,0]],[[0,0],[2,2]],[[0,0...
19:49:40 <fen> whoah
19:49:42 <fen> cool
19:50:38 <fen_> hmmmm
19:51:16 <fen_> well, i made this paste for ski, to accompany a long explanation of a problem, and now he is gone away and the problem is not solved https://pastebin.com/raw/Gra7aS8E
19:51:28 <dmwit> Practically speaking, what is the difference between an executable and a benchmark?
19:51:40 <dmwit> Or a test and a benchmark?
19:51:48 <dmwit> (In cabal files, I mean.)
19:52:09 <fen_> one shows functionality, one shows performance
19:52:18 <fen_> even in a cabal setting i presume
19:53:53 <fen_> its been a week since I hit this problem, and am most worried about its seemingly complex and difficult nature
19:53:55 <dmwit> But what does cabal actually do differently for the two?
19:54:30 <dmwit> Could we just replace all three with executable stanzas with a completely free-form "tag" field?
19:54:32 <fen_> a unit test / quickcheck vs criterion? or some inbuilt ghc perfomance thing?
19:54:46 <fen_> stanzas!? 
19:54:50 <Cale> dmwit: Perhaps that tests can fail
19:54:54 <fen_> free form tag field!?
19:54:57 <Cale> (But I'm not sure)
19:55:02 <duairc> If I spawn a sub process in Haskell, it's well-documented how to talk to its STDIN (0), STDOUT (1) and STDERR (2) file descriptors. But if the process also opens 3 and 4, how can I talk to them from Haskell?
19:55:06 <fen_> sounds like jazz jargon
19:55:23 <duairc> https://hackage.haskell.org/package/process
19:55:26 <dmwit> duairc: You can use one of the lower-level process-spawning APIs.
19:55:33 <duairc> There just doesn't seem to be a place in the API for it
19:55:38 <duairc> dmwit: Which ones are they?
19:55:58 <dmwit> https://hackage.haskell.org/package/unix provides all the usual suspects for duping FDs and the like
19:56:07 <dmwit> fork and exec, too
19:56:35 <fen_> hardly bluetooth
19:57:18 <dmwit> Windows has its own thing, too, I think, but I can't remember what it's called. Maybe Win32 or something?
19:57:54 <duairc> I don't care about Windows, though it would be nice if my code worked there too, but I'm not going to lose any sleep over it
19:58:03 <fen_> i get very anxious when i hit problems that i cant solve easily or that seem like they will take on the order of weeks to solve because it drasticly affects my ability to meet a deadline
19:58:15 <fen_> this problem is somewhat vexing
19:58:53 <duairc> dmwit: Thanks
19:59:24 <dmwit> Cale: Okay, hm.
19:59:39 <dmwit> Cale: But, like, cabal v2-run exits with the same exit code the thing it runs does, right?
20:00:10 <dmwit> Or, oh, you're saying there could be (maybe even is??) a test mechanism which reported its success or otherwise not via exit codes.
20:00:13 <dmwit> I see.
20:05:51 <Cale> dmwit: Yeah, I don't really know.
20:06:36 <Cale> dmwit: What I do know is that I often need to add "dontCheck" to nix derivations for things because their test suites are broken, and it kills the build
20:06:49 <dmwit> ^_^
20:07:09 <dmwit> r o c k s t a r s
20:10:54 <duairc> dmwit: Maybe part of the problem is that I don't fully understand all this stuff, but I'm looking in unix and I don't really see how to do what I want. I'm reading the source code of process and it uses the unix API a bit, but also calls to C via FFI for all the crucial bits... maybe I'll just read the C then
20:11:37 <dmwit> duairc: Standard protocol would be something like this:
20:11:47 <dmwit> 1. createPipe to get a read and write end.
20:12:08 <dmwit> 2. dupTo the appropriate end to the Fd your spawned thing will be using
20:12:19 <dmwit> sorry
20:12:32 <dmwit> 2. fork
20:12:46 <dmwit> 3a. on one side of the fork, dupTo the appropriate end to the Fd your spawned thing will be using
20:12:50 <dmwit> 4a. exec
20:13:02 <dmwit> 3b. on the other side of the fork, use the other end of the pipe
20:14:28 <dmwit> ...I think. It's been a while since I've done this stuff.
20:15:10 <duairc> Okay, dupTo is part of what I was missing, let me read about that and see if I can piece it all together
20:20:11 <duairc> dmwit: Okay, I get it now, thanks!
20:21:07 <dmwit> 👍
20:21:41 * dmwit . o O ( isDigit 👍 = True )
20:22:14 <duairc> :D
20:22:24 <duairc> Unfortuantely not :(
20:22:35 <Solonarv> > isDigit '👍' -- you liar!
20:22:37 <lambdabot>  False
20:24:45 <dmwit> % іsDigit '👍'
20:24:45 <yahb> dmwit: True
20:25:29 <dmwit> % map іsDigit "abc123👍" -- just to prove I'm not cheating
20:25:29 <yahb> dmwit: [False,False,False,True,True,True,True]
20:26:11 <duairc> :D
20:26:17 * hackage dbus 1.2.5 - A client library for the D-Bus IPC system.  https://hackage.haskell.org/package/dbus-1.2.5 (blaze)
20:26:39 <dmwit> It may be hard to convince you that I haven't changed anything since the last yahb message, but I declare that I haven't.
20:26:43 <dmwit> % :i isDigit
20:26:43 <yahb> dmwit: isDigit :: Char -> Bool -- Defined in `GHC.Unicode'
20:27:05 <duairc> > "іsDigit" == "isDigit"
20:27:07 <lambdabot>  False
20:27:17 <dmwit> caught! ^_^
20:42:17 * hackage strongswan-sql 1.3.0.0 - Interface library for strongSwan SQL backend  https://hackage.haskell.org/package/strongswan-sql-1.3.0.0 (erick)
21:34:53 <fr33domlover> MVar vs TVar revisited: I produce a list of boolean variables, all set to False. Then each variable has a thread running, possibly updating the variable to True. Finally, I check which variables changed to True. It can be done using MVar (), or with TVar Bool, I'm wondering which one to prefer
21:35:03 <fr33domlover> Based on previous discussion here,
21:35:35 <fr33domlover> Semantically this isn't blocking behavior, it's just for thread communication
21:37:43 <fr33domlover> So I suppose based on that, TVar would make more sense
21:38:40 <clever> fr33domlover: tvar can help if you want to atomicly check several tvars at once
21:39:23 <clever> tvar also must always have a val (bool in your case)
21:39:46 <clever> but mvar can lack a value, and ive hung my program before by uncauht exceptions causing me to not return a value into an mvar
21:39:51 <fr33domlover> clever, in this case nope, it's pretty trivial, I do need to wait for all threads to finish running but that can be done with Mvars/async
21:40:05 <clever> that sounds more like a job for ASync
21:40:16 <clever> just pure ASync can do that
21:40:22 <fr33domlover> clever, yeah I'm aware of these differences :) Just sharing thoughts haha
21:41:00 <clever> though one crazy idea i did recently, was to use STM to create a stream of ASync's
21:41:03 <clever> so it could process data in parallel
21:41:20 <clever> but i read the asyncs out in order, to it re-assembles the original stream
21:41:42 <clever> then i disocvered, the db read primitive i was wrapping, grabs a global mutex, lol
21:42:00 <clever> so it cant actually become parallel
21:42:54 <fr33domlover> clever, oh no what evil db is that? ^_^
21:43:08 <clever> it was more the monad transformer mess around everything
21:43:23 <clever> the code i was working in was IO based, and had a mutex for entering a custom transfomer stack
21:43:30 <clever> so there wasnt concurrent access to the db
21:44:28 <clever> but the whole thing is also in the middle of a rewrite, and soembody else optimized the same code i was trying to optimize, and got the times way down
21:48:22 <fr33domlover> clever, async could do what I need if I wrap the actual action with an exception handler than returns Nothing
21:49:09 <fr33domlover> clever, the reason I prefer setting-a-TVar is that even if I miss some exception that gets thrown, things will still work right
21:49:44 <clever> i think async would also report the thread as finished if it dies to an exception
21:49:52 <clever> (or re-throw that to the parent?)
21:49:58 <fr33domlover> Yeah it rethrows
21:50:47 <fr33domlover> I could use mapConcurrently and make sure to catch excpetions
21:51:14 <clever> and return Either SomeException _
22:02:47 <maerwald> how do you find the path to the currently selected ghc via cabal
23:27:53 <HenryCH> is there something similar to >=> but that works on a (a -> m b) and a (b -> c)? 
23:28:12 <HenryCH> can't find anything in hoogle
23:30:13 <Ariakenom> :t \m f -> fmap f . m
23:30:14 <lambdabot> Functor f => (a1 -> f a2) -> (a2 -> b) -> a1 -> f b
23:32:11 <Ariakenom> HenryCH ^
23:33:00 <HenryCH> Ariakenom: thanks, that's exactly what i wanted, let me just make sense of it now
23:33:09 <suppi> Alternatively, f >=> pure . g
23:33:59 <Ariakenom> suppi: indeed
23:34:22 <suppi> I'm not aware of an operator for that though :o
23:35:35 <HenryCH> I don't get this, if f is a functor , how can you do f . m?
23:35:57 <Ariakenom> HenryCH: (fmap f) . m
23:36:41 <HenryCH> right, still don't get it, is f just the a in fmap's a  -> b?
23:37:17 <Ariakenom> fmap f :: m b -> m c
23:37:18 <HenryCH> or f is a constructor?
23:37:37 <suppi> f in the expression is a function of type b -> c
23:37:43 <Ariakenom> (.) :: (m b -> m c) -> (a -> m b)
23:38:15 <suppi> fmap f has the type f (b -> c)
23:38:15 <Ariakenom> (.) :: (m b -> m c) -> (a -> m b) -> (a -> m c)
23:38:42 <Ariakenom> suppi: not quite
23:39:02 <suppi> Right sorru
23:39:14 <suppi> fmap f :: f b -> f c
23:39:34 <HenryCH> but f is a functor, not a -> b?
23:40:04 <suppi> there are two namespaces, one in the type level and one in the value level
23:40:14 <suppi> And they are distinct
23:40:24 <suppi> Type level is everything after ::
23:40:34 <jle`> :t \m g -> fmap g . m
23:40:35 <lambdabot> Functor f => (a1 -> f a2) -> (a2 -> b) -> a1 -> f b
23:40:49 <jle`> note, same type
23:41:07 <HenryCH> ah, thanks
23:41:13 <HenryCH> that clears it up :D
23:41:28 <suppi> And value level is the other stuff
23:42:21 <suppi> Another example of that: data T a = V a a
23:42:45 <suppi> T is in the type level namespace and V is in the value level namespace
23:44:11 <suppi> If that makes sense
23:45:02 <HenryCH> yep that's clear thanks, I got confused with the f thinking it was referring to the same thing in the declaration and the signature
23:47:01 <suppi> Yeah i find this mix-up to be fairly common
23:49:34 <jle`> yeah, it's often good practice to try not to mix them up. that's why you'll see people using a, b, c for types, and x, y, z for values
23:49:46 <jle`> but 'f' comes up often in both type and values so :/
23:54:17 <remexre> so I've got a type data Foo = Bar Baz Int | Quux Int; is it legal to make a Prism' Foo Baz that has the Int as a default value when creating a Foo from a Baz?
23:59:56 <cocreature> remexre: no, you violate the “if `preview l s = Just a` then `review l a = s`” law
