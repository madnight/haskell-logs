00:25:37 * hackage dynamic 0.0.5 - A dynamic type for Haskell  https://hackage.haskell.org/package/dynamic-0.0.5 (ChrisDone)
00:43:46 <merijn> Chris Done's April Fool's joke is my favourite so far :p
00:44:33 <phadej> is it?
00:44:34 <phadej> Uploaded
00:44:34 <phadej> by ChrisDone at Sun Mar 31 15:35:33 UTC 2019
00:44:37 <phadej> ;)
00:44:57 <merijn> UTC doesn't count :p
00:45:19 <merijn> Everyone knows internet April Fool's runs on an Anywhere-on-Earth basis
00:46:08 <phadej> merijn: well, based on github chris is based in England, so UTC does count
00:46:32 <phadej> also reddit thread is made well on 31th of March
00:47:33 <phadej> (the actual bad thing, is that a very good package name is now squatted for a joke)
00:48:23 <phadej> and: https://matrix.hackage.haskell.org/#/package/dynamic
00:50:25 <merijn> phadej: On the one hand, I agree with you. On the other hand I empathise with the difficulty of selecting an appropriate package name. Honestly, of my code on hackage probably 50% of the work went into writing them and the other 50% on trying to pick a name and I still fucked up the name on a couple of them >.>
00:57:02 <phadej> merijn: yes, names of packages are difficult, but one should to think about it, as there's single namespace
00:57:18 <phadej> (one can argue whether latter is good or not)
00:58:27 <merijn> It's unfortunate there's no real way to migrate/change names on Hackage without breaking everything
00:59:07 * hackage dynamic 0.0.6 - A dynamic type for Haskell  https://hackage.haskell.org/package/dynamic-0.0.6 (ChrisDone)
00:59:22 <CelestialLake> merijn: Well, there's one.
01:00:42 <merijn> CelestialLake: No, you can create a new package with a new name and deprecate the original, but that just contributes to the clutter and name pollution on Hackage
01:11:29 <bahamas> hello. how easy is it to pass to GHC an AST instead of source code. can you programmatically access the GHC functionality that takes the AST generated during parsing?
01:12:29 <merijn> bahamas: You are literally describing Template Haskell ;)
01:12:39 <merijn> bahamas: So I'd go with "fairly easy" :p
01:12:45 <CelestialLake> The only problem of Hackage in this regard is that it cannot exclude by keyword when searching. For instance, it'd be easier to deprecate something by adding 'deprecated' tag. Then, anyone willing to hide stale packages, may just do '-deprecated' in search bar. A lot better.
01:14:01 <merijn> bahamas: You can use quasiquotation to get an AST representation of Haskell and then write Template Haskell code to modify/manipulate said AST before GHC compiles it
01:14:43 <bahamas> merijn: I'm glad to hear that. I'm asking more because I'm thinking of keeping the AST of my code in memory and just passing that to GHC when I want to build
01:15:41 <merijn> bahamas: That's probably trickier
01:15:55 <bahamas> merijn: why's that?
01:16:01 <merijn> bahamas: Then again, generating Haskell from an AST probably isn't too hard
01:16:24 <merijn> bahamas: I'm not sure ghc exposes the necessary API for that
01:16:30 <Peppep> The recommendation on haskell.org is to use apt-get to install haskell-platform on Ubuntu. But doesn't this give me a 4.5 years old version? https://packages.ubuntu.com/search?keywords=haskell-platform
01:16:47 <merijn> bahamas: Then again, ghc is an embeddable library, so maybe there's an easier way
01:17:10 <merijn> Peppep: You probably want ghcup nowadays
01:17:29 <merijn> bahamas: Have a look at https://hackage.haskell.org/package/ghc ?
01:18:04 <bahamas> merijn: I found this, if that's what you mean: https://github.com/digital-asset/ghc-lib. but I don't understand the reference to runtime system. also, it says you can't run code produced by ghc-lib
01:18:11 <bahamas> merijn: ok, I will. thanks!
01:18:15 <merijn> bahamas: ghc-lib is something else
01:19:11 <merijn> bahamas: ghc-lib is is a compatibility wrapper around the GHC API for some specific usecases (which doesn't let you run code)
01:19:16 <CelestialLake> Peppep: You may just install `nix` and then install the desired `ghc` using it. Or you may use stack/cabal to install the required ghc version. Stack happily provides one.
01:20:18 <merijn> bahamas: The ghc package is literally ghc (the ghc executable is just an executable wrapper around the ghc library) it lets you do anything GHC can. However, it's API is not stable across releases, so writing code that supports multiple GHC versions can be annoying (which is what ghc-lib tried to help)
01:20:38 <bahamas> merijn: what I have in mind is doing syntax and type-checking as close to the editing time as possible. with this I would like to pass the generated AST to GHC
01:20:42 <bahamas> merijn: I see
01:22:45 <Peppep> CelestialLake: Any advantages of doing it that way instead of ghcup, which seems quite straight-forward?
01:23:10 <bahamas> Peppep: I also find ghcup very convenient
01:23:14 <Peppep> Btw, I already tried ghcup once, but it wasn't running smoothly. But that was on my old Ubuntu install, with Anaconda messing up my path
01:23:34 <Peppep> Now I just reinstalled, so I expect it'll run smoothly this time
01:24:53 <CelestialLake> Peppep: why would you want one global version of GHC? For what sake? GHC has a new major almost yearly now, so I'd consider it a wrong move. If you use some static configurator, it's just easier to still have a working code, dependencies that build successfully, et cetera.
01:25:51 <bahamas> CelestialLake: if you use cabal, you need to install ghc somehow
01:26:27 <CelestialLake> Sure, that's trickier. So you just get stack and install whatever ghc version you need.
01:27:09 <CelestialLake> Or you might as well get `nix` for that if you despise stack for some reason
01:27:22 <bahamas> well, then you need to specify the path to that GHC which 12 levels deep (exaggeration)
01:27:37 <CelestialLake> Why do you?
01:28:38 <merijn> Peppep: Personally I just install GHC binary distributions by hand: https://www.haskell.org/ghc/download_ghc_8_6_4.html
01:28:41 <bahamas> CelestialLake: where does stack install ghc? when I needed it, I found it in a pretty-deep folder path
01:29:12 <CelestialLake> bahamas: Did you ever think of issuing `stack --help`? :)
01:29:14 <bahamas> that maybe be my lack of knowledge regarding slack.
01:29:28 <Peppep> Atm I'm not too worried about the long-term. I'm using Haskell for a Uni course where learning Haskell itself isn't the goal, but a tool to build an interpreter. So in a way we're trying to use as little Haskell as possible
01:29:32 <bahamas> CelestialLake: I just ran it before I asked it. 
01:29:33 <CelestialLake> `stack ghc` is pretty much all you'll need
01:29:37 <merijn> I like the bindist approach because it "Just Works" (TM) on any *nix like platform
01:30:17 <CelestialLake> or `stack ghci` if you wish
01:30:31 <CelestialLake> (globally)
01:30:33 <Peppep> So I might carry on with Haskell later on, but currently I just need an enviroment that'll run until June
01:31:21 <CelestialLake> Project-local setup is just `stack new <whatever>`, then it'll use the one specified in (again) project-local configuration.
01:31:21 <bahamas> CelestialLake: ah, you're talking about using ghc with stack. I thought you meant installing ghc with stack but using it with cabal. that was the use case I was referring to
01:31:53 <CelestialLake> bahamas: If you've stack, you've cabal out of the box.
01:32:25 <bahamas> CelestialLake: yes and I said that you need to install ghc yourself when you're using cabal.
01:33:43 <CelestialLake> Yes. If you're not willing to jump through hoops in that way, you just get yourself a stack or nix to get the desired ghc(i) version.
01:35:59 <bahamas> Peppep: I would say that you can first try stack. if it does what you want, use it. if not, try cabal with the `new` commands and use `ghcup` to install ghc. if that doesn't work, try nix
01:36:20 <bahamas> I don't see why the first two options shouldn't work though
01:36:59 <CelestialLake> Nix is a bit overkill in the above case but it does the job. So it's an option here just in case.
01:44:23 <Peppep> Already tried "ghcup install", didn't work
01:44:26 <Peppep> /home/x/.ghcup/ghc/8.6.3/lib/ghc-8.6.3/bin/ghc-pkg: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory
01:44:29 <Peppep> make[1]: *** [ghc.mk:991: install_packages] Error 127
01:44:31 <Peppep> make: *** [Makefile:51: install] Error 2
01:44:33 <Peppep> Failed to install, consider updating this script via: ghcup upgrade
01:46:08 <CelestialLake> Peppep: get libtinfo.
01:48:00 <CelestialLake> Then it'll work (most probably)
01:48:10 <figureli1p> what makes a language functional? Why people say javascript is not functional but haskell is
01:48:56 <figureli1p> if possible please explain it like you would be explaining a novice developer
01:49:58 <Peppep> CelestialLake: Thanks, that worked! 
01:52:20 <[exa]> figurelisp: functional programming is achievable even in assembly, the question is whether you want to it like that
01:52:37 * hackage tensors 0.1.3 - Tensor in Haskell  https://hackage.haskell.org/package/tensors-0.1.3 (leptonyu)
01:55:08 <figurelisp> [exa]: how do i know what i want
01:55:18 <Peppep> So now it installed ghc, but when trying to run ghci I get "can't load .so/.DLL for: libgmp.so (libgmp.so: cannot open shared object file: No such file or directory)". Would it make sense to do "apt-get build-dep ghc", or should I do them one by one?
01:55:37 * hackage menshen 0.0.3 - Data Validation  https://hackage.haskell.org/package/menshen-0.0.3 (leptonyu)
01:58:27 <CelestialLake> Peppep: It's probably way safer to resolve them one by one in case of aptitude. Apt tries to do a lot of stuff for nothing while giving you no to little control... So yep, do one-by-one.
01:58:43 <merijn> Peppep: How did you install it and which distro is this?
01:59:00 <Peppep> merijn: ghcup on Ubuntu 19.04 beta
02:02:29 <phadej> Peppep: you need just `libgmp-dev`
02:04:01 <phadej> there's https://github.com/haskell/ghcup/issues/49 (which I disagree with as in https://github.com/haskell/ghcup/issues/46)
02:04:39 <phadej> I really don't agree that one should look into GHC manuals / bindist release notes to find out which ubuntupackages one have to install in addition
02:06:37 <Peppep> phadej CelestialLake, working now, thanks
02:10:02 <CelestialLake> phadej: These errors produce a highly verbose output, from which the requirements are pretty deducible. So the manuals on this topic are redundant imo.
02:11:26 <phadej> CelestialLake: don't tell me that, but a maintainer of ghcup
02:12:37 <phadej> I don't think they need documentation, but that ghcup should tell what else user need to do to get complete installation
02:13:05 <phadej> (as AFAIK it wants to stay non-interactive, so it cannot prompt either)
02:34:24 <[exa]> figurelisp: that's complicated :] but generally you want the software running with the least possible amount of ugly hacks, magic, bugs and code.
02:36:14 <dminuoso> ski: So I have been pondering about profunctor for a while now. I think the construction you were looking for is a bifunctor. So part of the motivation behind the `Set` codomain is that it generalizes the hom functor or relations (depending on which perspective you want to take).
02:50:01 <remexre> is there a way to import the constructors of a type without importing the type itselF?
02:50:41 <M2tias> w
02:50:47 <M2tias> oops, nvm that
02:58:04 <__monty__> remexre: You could definitely wrap them in functions then export those without export
02:58:12 <__monty__> ing the type, like smart constructors.
02:58:50 <remexre> eh, I guess
02:59:00 <merijn> remexre: Why do you not want to import the type?
02:59:32 <remexre> the type has a bunch of type variables, so I have a local alias with them "filled in"
03:08:07 <EmilKarlson> merijn: actually now I remember, why I stopped configuring swap, it's very hard to configure oomkiller with it
03:08:20 <EmilKarlson> or at least, I don't know how
03:09:17 <EmilKarlson> obviously you could just have just enough swap to fit the idle parts, but anything more will jam your system
03:41:44 <merijn> remexre: You can just import the type qualified?
03:45:07 * hackage telega 0.1.0 - Telegram Bot API binding  https://hackage.haskell.org/package/telega-0.1.0 (iokasimovmt)
04:03:55 <fen> can someone check this? https://pastebin.com/raw/DM4GLaNa
04:04:09 <fen> "extraBuild / extraFoldr"  fusion...
04:37:37 * hackage registry 0.1.3.0 - data structure for assembling components  https://hackage.haskell.org/package/registry-0.1.3.0 (etorreborre)
04:53:09 <fen> its supposed to enable s -> ([a],Maybe s) to represent a state returning an arbitrary hidden intermediate foldable container, where [] is used so that fusion can be used to recover the church encoding before the [a] is returned by providing (:) [] as the arguments to a fold. 
04:54:04 <fen> so like how build fold fusion replaces these (:) and [] used to return [a] from a partially applied fold, here we can do the same over the list appearing in s -> ([a],Maybe s)
04:54:38 <fen> in this way, we can start to "nest" states of states, and fuse into the inner states as they are unfolded to replace the accumulating functions
04:56:24 <fen> at a nesting depth of 2, here (the recursive case has not beed done yet... this is basically just using regular build/fold fusion as the basecase to the recursion) then we essentially have a way of "double unfolding" [[a]], and the fusion given here allows the (:) and [] of the inner list to be replaced by arbitrary arguments to foldr
04:57:12 <ph88^> how can i link an .a file into a haskell executable? i use stack
05:00:16 <hpc> there are some sqlite packages that you can use as an example
05:00:58 <ph88^> oh i found it
05:01:04 <ph88^> extra-lib-dirs
05:03:08 <fen> actually, might need the state encoding, not church...
05:05:03 <fen> as might need to get at the recursively nested states... otherwise if church is used the state is hidden and there is nothing to recurse into
05:05:41 <fen> any comment on https://pastebin.com/raw/DM4GLaNa might help here
05:06:07 * hackage hw-rankselect 0.13.0.0 - Rank-select  https://hackage.haskell.org/package/hw-rankselect-0.13.0.0 (haskellworks)
05:25:37 * hackage salak-yaml 0.2.7 - Configuration Loader for yaml  https://hackage.haskell.org/package/salak-yaml-0.2.7 (leptonyu)
05:26:38 * hackage salak 0.2.7, salak-toml 0.2.7 (leptonyu): https://qbin.io/share-when-i6ol
05:26:51 <ph88> first i get this warning:     pcre2-0.1.0.0: library-dirs: ./pcre2-10.32/build is a relative path which makes no sense (as there is nothing for it to be relative to). You can make paths relative to the package database itself by using ${pkgroot}.
05:27:03 <ph88> then i put in package.yaml    extra-lib-dirs: ${pkgroot}/pcre2-10.32/build
05:27:12 <ph88> then i get     Warning: 'extra-lib-dirs: ${pkgroot}/pcre2-10.32/build' directory does not exist.
05:27:22 <ph88> anyone know how i'm supposed to use that pkgroot ?
05:29:07 * hackage japanese-calendar 0.1.1.0 - Data type of Japanese Calendar (Wareki).  https://hackage.haskell.org/package/japanese-calendar-0.1.1.0 (nakaji_dayo)
05:33:21 <libertyprime> hey guys. can i run hoogle searches for code on my own machine?
05:34:26 <libertyprime> dont worry, i think ive found my answer. https://github.com/ndmitchell/hoogle/blob/master/docs/Install.md
05:34:53 <libertyprime> i have an actual language question now though.
05:35:59 <libertyprime> although it's kinda irrelevant now actually, that i can point hoogle at a directory to index
05:36:34 <libertyprime> i was going to ask if it's easy to make a type that is idential to a string, and can be used interchangeably, but is named something else
05:37:07 <libertyprime> for the purposes of being able to search for specific functions i make that take that type of string as a parameter
05:40:12 <ProofTechnique> libertyprime: Either `type MyString = String` if you only want an unchecked alias, or `newtype MyString = MyString String` if you want a checked one (with some associated wrapping and unwrapping)
05:41:31 <libertyprime> oh awesome! thanks so much
05:41:44 <Ariakenom> libertyprime: don't overdo type aliases, indirection can get confusing. newtypes may be  nicer
05:41:52 <libertyprime> noted
05:44:54 <Ariakenom> What are some well regarded type synonyms?
05:46:12 <Ariakenom> lenses, transformers. Is it mostly things that have a complicated full type?
05:48:07 * hackage salak-yaml 0.2.8 - Configuration Loader for yaml  https://hackage.haskell.org/package/salak-yaml-0.2.8 (leptonyu)
05:48:13 <ProofTechnique> `type Parser = Parsec Void Text` or similar is pretty common
05:48:48 <ProofTechnique> Subbing whatever error-handling you want for `Void`
05:49:07 * hackage salak 0.2.8, salak-toml 0.2.8 (leptonyu): https://qbin.io/lang-square-k4pu
05:51:48 <lavalike> is hackage down?
05:52:30 <dminuoso> Ariakenom: I like `type IOL = LoggingT IO` a lot
05:53:02 <dminuoso> Generally for transformer stacks Im not convinced type aliases are great.
05:56:04 <Ariakenom> dminuoso: what about  type State s = StateT s Identity
05:56:29 <fen> generally you need a newtype instead of a type synonym whenever the type would be partially applied, such as in an instance 
05:56:58 <fen> maybe if we had type level lambdas this wouldnt be the case, but then the solver would need to be improved
05:58:02 <fen> Ariakenom: that case is slightly different, since some of the parameters are concretely provided
05:58:38 <ruffy_> I have a problem with the SBV library. I construct an SMT formula which is unsatisfiable and I want to extract an unsat core, but the returned unsat core is always an empty list, which is in my opinion not correct. Does anyone knows if SBV simplifies the formula before it calls z3? In my opinion that is the only reason, why I get an empty unsat core.
06:00:26 <fen> ruffy_ can you provide an example that would help anyone less familiar with the SBV library understand why you think this is so?
06:03:12 <ruffy_> fen https://pastebin.com/navjv6Hq
06:03:37 * hackage chessIO 0.1.0.0 - Basic chess move generation and UCI client library  https://hackage.haskell.org/package/chessIO-0.1.0.0 (mlang)
06:04:03 <ruffy_> fen that is my current implementation
06:04:46 <fen> hmm, but maybe more as an explanation of what you were saying about z3...
06:06:15 <ruffy_> fen: The problem is that I don't understand why I get an empty list as unsat core. The only thing I could imagine is that the formula is simplified to just "False" before it is sent to z3 and therefore z3 returns and empty unsat core
06:06:33 <ruffy_> * an empty
06:07:00 <fen> ok and an unsat core is something to do with this library?
06:08:06 <fen> % :m Data.SBV
06:08:07 <yahb> fen: ; <no location info>: error:; Could not find module `Data.SBV'; Perhaps you meant Data.Set (from containers-0.5.11.0)
06:08:59 <fen> http://hackage.haskell.org/package/sbv-8.1/docs/Data-SBV-Control.html#v:getUnsatCore
06:09:01 <tabaqui> LeiraSarvo
06:09:23 <ruffy_> There is a function getUnsatCore for this library. And for SMT encodings it is possible, if the formula is unsatisfiable, that you can extract an unsat core
06:09:46 <ruffy_> fen yes exactly this function
06:09:54 <ProofTechnique> fen: https://en.wikipedia.org/wiki/Unsatisfiable_core
06:11:43 <fen> oh right, you reduce the unsatistifiable program to a smaller "unsatisfiable core" 
06:12:55 <ruffy_> yeah and I am wondering why the unsat core for my first encoding is just an empty list.
06:13:09 <fen> so if you "get an empty list as unsat core" then this is a failure to find such a reduction?
06:13:59 <fen> is that what you get when the program is satisfiable? or if it is a minimal unsatisfiable core already?
06:14:22 <ruffy_> nope it is not a failure
06:14:34 <fen> what does it mean that its an empty list then?
06:14:44 <ruffy_> when it is satisfiable I extract an assignment
06:14:56 <tabaqui> oops
06:15:02 * tabaqui is changing password
06:15:07 <ruffy_> only when it is unsatisfiable i extract an unsat core
06:16:08 <ruffy_> I think that the empty list, in my opinion, can only be returned if the formula just consists of the constant "False"
06:16:15 <fen> ok so its using the Unsat pattern, so its unsatisfiable, but then its giving an empty list, so what does that actually correspond to?
06:16:22 <ruffy_> and no other variables
06:16:25 <fen> oh ok
06:16:41 <fen> so thats why you think its performed some sort of reduction on it
06:18:16 <ruffy_> Yes maybe if the formula is first simplified, it could be reduced to just "False" and then I get this behavious
06:18:22 <ruffy_> *behaviour
06:18:49 <ruffy_> But I would like to get an unsat core for the original formula
06:19:15 <fen> and you think that its the call to z3 thats doing this as its the only thing inbetween "run" and "print" parts of your program 
06:19:45 <ruffy_> Actually I don't know what causes this behaviour
06:19:58 <ProofTechnique> Is there a way to inspect what gets sent to z3 before it gets sent out?
06:20:11 <ruffy_> The explanation with simplifying is just a guess
06:20:33 <ruffy_> ProofTechnique hmmmmm I have to investigate that
06:22:11 <ProofTechnique> If I go to https://rise4fun.com/z3 and do just `(assert false)(check-sat)(exit)`, I just get `unsat`, which seems in line with your suspicion
06:22:42 <fen> seems like it also does "query" on the result before its returned from run, maybe this does something unexpected?
06:25:35 <ruffy_> hmmmm I don't find a way to extract the formula which is send to z3
06:26:25 <ruffy_> ProofTechnique you have to enable this
06:26:37 <ruffy_> (set-option :produce-unsat-cores true)
06:26:39 <ruffy_> (assert false)
06:26:41 <ruffy_> (check-sat)
06:26:43 <ruffy_> (get-unsat-core)
06:26:45 <ruffy_> (exit)
06:27:02 <ProofTechnique> After doing that, I still get `unsat ()`, which seems like your issue
06:27:28 <ruffy_> fen could also be the case
06:28:00 <ruffy_> ProofTechnique Yeah but you get an empty unsat core
06:28:03 <ruffy_> unsat
06:28:05 <ruffy_> ()
06:28:41 <ruffy_> That's why I think that there is some implicit simplification applied
06:29:54 <ProofTechnique> ruffy_: Anything in http://hackage.haskell.org/package/sbv-8.1/docs/Data-SBV-Internals.html look promising?
06:30:59 <fen> query :: Query a -> Symbolic a, and you have a === Result, maybe the "result" of this query is a simplification?
06:31:10 <ruffy_> ProofTechnique I will have a look
06:32:29 <ruffy_> fen So you mean that the result returned by query is simplified?
06:34:33 <fen> probably would have to find what its actually doing to tell
06:34:33 <fen> http://hackage.haskell.org/package/sbv-8.1/docs/src/Data.SBV.Control.html#query
06:35:06 <fen> seems like the comments about "constrain" might be helpful
06:36:14 <ruffy_> fen: also before I return the core in query it is the empty list
06:36:40 <fen> as its "constrain enc", where `enc <- existsKColoring g k' and existsKColoring :: Graph -> Int -> Symbolic SBool
06:36:47 <ruffy_> fen: but in the comments they don't say something about simplification or do I missed somthing?
06:36:54 <fen> can we assume this is doing a reduction to return False?
06:37:48 <ruffy_> fen: you mean the bind from existsKColoring to enc? that this applies a simplification?
06:38:12 <fen> um, isnt existsKColoring doing the simplification to SBool?
06:38:47 <ruffy_> Yes thats true.......hmmm I understand what you mean
06:39:53 <ruffy_> that could be the problem 
06:40:13 <jenkee[m]> Newbie here,can anybody tell me why more and more people are picking up Haskell while Lisp is so dead
06:42:43 <luftmensch[m]> As an Emacs user I can say for certain Lisp is far from dead
06:42:47 <fen> cant say much about Lisp, but certainly Haskell will continue to grow as recruiters and industry team leaders start to realise, utilise and communicate the advantages of higher order languages
06:42:59 <c_wraith> lisp isn't dead. clojure still gets a lot of attention
06:43:07 <ruffy_> fen: Do you have an idea how I could solve this?
06:43:12 <merijn> luftmensch[m]: I think it's because strongly typed languages like Haskell are more conducive to collaboration
06:43:21 <c_wraith> but people pick up Haskell because it has cool ideas that are worth learning.
06:43:40 <merijn> luftmensch[m]: What I usually see with Lisp is that everyone forks of into their own little universe of custom DSLs, which makes it hard to read anything written by someone else
06:43:46 <fen> whats up ruffy_ ? isnt it working as expected? if you understand what its doing cant you produce the desired behaviour? 
06:44:10 <merijn> luftmensch[m]: In contrast, strong/static typing and purity make it much easier to hack on someone else's code even if you don't fully understand it
06:44:26 <ProofTechnique> merijn: *crying in lens*
06:44:31 <pie__> merijn, isnt haskell kind of similar <merijn> luftmensch[m]: What I usually see with Lisp is that everyone forks of into their own little universe of custom DSLs, which makes it hard to read anything written by someone else
06:44:35 <pie__> ProofTechnique, lol there we go
06:44:42 <pie__> i can imagine it being less bad than lisp tho
06:44:54 <merijn> pie__: But Haskell's little DSL have types and purity to simplify understanding them ;)
06:44:54 <fen> c_wraith: nice, "because it has advantages"
06:45:20 <ruffy_> fen: I just return now the different variables and construct my formula in the line of constrain after query.
06:45:23 <ProofTechnique> The lack of homoiconicity certainly doesn't *hurt* Haskell in that regard
06:45:57 <ruffy_> Shouldn't that solve the problem if existsKColoring reduces to SBool?
06:46:29 <fen> could you write that up into a working example?
06:46:44 <pie__> ProofTechnique, meh, I wish code generation was easier. (but I'm a noob)
06:46:53 <fen> it would be great to see what result you were trying to construct
06:47:11 <pie__> it code generation was easier Id have just code generated my way out of some problems as opposed to falling into a type theory rabbit hole hoping someone else solves my problem
06:47:20 <luftmensch[m]> jenkee: I think at this point it’s mostly carried by momentum, but Haskell is a popular language for implementing new high-level programming concepts so it’s fun and exciting to learn. Maybe that answers
06:48:08 <pie__> well nto really a type theory rabbit hole, more of a ghc generics rabbit hole
06:48:11 <pie__> or something
06:48:17 * pie__ scratches head...gets back to work
06:48:33 <fen> pie__ : why do you think code generation would be helpful?
06:49:07 <fen> or to "avoid having to understand complex types" ? or whatever it was you were suggesting .... 
06:49:15 <fen> doesnt seem to be a good idea...
06:49:33 <ruffy_> fen: https://pastebin.com/R4Lxd9Pk
06:49:38 <pie__> in my specific case i have a mutually recursive AST with 30 different types and 100 fidifferent constructors
06:49:56 <pie__> which is a shitload of boilerplate (solution pending)
06:50:40 <pie__> I actually found a paper which might solve it but I havent had time to look yet
06:50:47 <pie__> anyway haskell is pretty great tho
06:50:49 <pie__> :p
06:51:36 <fen> whats that some kind of intense domain specific language?
06:52:09 <ProofTechnique> pie__: https://www.parsonsmatt.org/2015/11/15/template_haskell.html I read that recently and it made TH seem much more pleasant
06:52:22 <pie__> thanks ill give it a look
06:53:05 <fen> what kind of functionality is the boilerplate supposed to be giving? cant you just derive whatever it is?
06:53:17 <ProofTechnique> pie__: Also https://markkarpov.com/tutorial/th.html
06:55:54 <pie__> fen, can I do deriving on a library I import?
06:56:22 <fen> you might be able to use DerivingVia...
06:57:42 <fen> anyone who can comment on this? https://pastebin.com/raw/DM4GLaNa
06:58:36 <fen> still struggling with the idea of nested states which unfold to produce states etc
06:59:37 * hackage safe-money 0.8.1 - Type-safe and lossless encoding and manipulation of money, fiatcurrencies, crypto currencies and precious metals.  https://hackage.haskell.org/package/safe-money-0.8.1 (RenzoCarbonara)
06:59:49 <fen> trying to construct a way to use fusion to represent this as nested states of lists, which can be "fusioned over" to replace the (:) []
07:07:26 <fen> there is this aswell... https://pastebin.com/VxL9QZXx
07:07:45 <fen> with imports from https://gist.github.com/fen-hs/
07:08:06 <fen> zip fusion seems nice
07:08:51 <merijn> Build systems a la carte is beautiful magic
07:08:57 <fen> just unsure how to combine the fold / unfold fusion with these nested states
07:10:08 <python476> just came back from metal scrapyard 
07:10:34 <python476> to give them some old kitchen appliances
07:10:42 <python476> so much shit lying around at their building
07:15:43 <vivit> Is there any way to get newlines to print in ghci?
07:16:12 <vivit> I want to test my tabulation module
07:16:31 <merijn> vivit: In what way are they not printing?
07:16:48 <python476> (btw: sorry for previous message, wrong chan)
07:21:22 <fen> > putStrLn "hello \n world"
07:21:25 <lambdabot>  <IO ()>
07:22:01 <fen> % putStrLn $ show "hello \n world"
07:22:01 <yahb> fen: "hello \n world"
07:22:07 <fen> % putStrLn "hello \n world"
07:22:07 <yahb> fen: hello ; world
07:22:17 <fen> vivit: ^ ?
07:23:03 <fendor> :t MaybeT
07:23:04 <lambdabot> error:
07:23:04 <lambdabot>     • Data constructor not in scope: MaybeT
07:23:04 <lambdabot>     • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
07:23:07 * hackage transformers-compat 0.6.3 - A small compatibility shim for the transformers library  https://hackage.haskell.org/package/transformers-compat-0.6.3 (ryanglscott)
07:24:25 <vivit> fen: The latter seems to work
07:24:47 <vivit> Which is funny, because I thought I had tried that
07:25:23 <MarcelineVQ> you might have tried print, which is putStrLn . show
07:25:24 <python476> vivit: is this for a job or personal project ?
07:26:11 <merijn> vivit: If you return a String (or any other non-IO type) in ghci it will run "show" on it, before printing
07:26:21 <merijn> vivit: Which will render newlines as \n
07:26:42 <merijn> vivit: If you actually write it to stdout via putStr/putStrLn then it will actually print it
07:29:29 <zincy> If you had an IntMap how would you do a find which returns the closest key to a given Int?
07:29:47 <fendor> how can I run a MaybeT?
07:31:05 <Rembane> fendor: runMaybeT should give you a m (Maybe ...)
07:31:44 <MarcelineVQ> zincy: some combo of lookupLT lookupGT perhaps
07:32:17 <fendor> Rembane, thanks!
07:32:38 <Rembane> fendor: No worries. There are more fun things your can do with MaybeT here: https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Maybe.html#t:MaybeT
07:37:28 <zincy> Thanks.
07:37:29 <MarcelineVQ> zincy: maybe splitLookup and minView/maxView on the results to compare with your target key and decide which one you want
07:38:00 <zincy> What is a suitable data structure for a collection of timestamped data?
07:38:25 <zincy> I was thinking IntMap where the keys are Unix Seconds
07:39:13 <merijn> zincy: What sorta accesses do you need to do?
07:39:58 <zincy> merijn: Just to be able to insert and lookup the nearest timestamp
07:47:42 <vivit> python476: personal project
07:47:47 <vivit> merijn: thanks
07:52:34 <vivit> Is there any way to use one definition* to cover part of but not all of the domain of a function and then use another definition to cover the rest, or do you have to use guards or conditional for that?
07:53:00 <merijn> vivit: You mean write a function in 2 or more equations?
07:54:03 <vivit> Yes, but more specifically, I mean covering more than one but not all elements of the domain with one equation, and then covering the rest of the domain with another eqaution
07:54:18 <Cale> vivit: So long as you put the equations next to each other in the code, yes
07:56:03 <vivit> I know how to say something like  foo 1 = 1 ; foo 2 = 3 ; foo 3 = 6 ; foo 4 = 10 ; foo a = a + (foo $ pred a)
07:56:07 <monochrom> Each equation will contain a guard anyway. Unless the difference is in patterns not in guards.
07:57:01 <monochrom> But telepathic talks are telepathic talks. Mock code goes much further to show what you actually have in mind.
07:57:12 <vivit> But could I, for example, in one equation, define  foo a  where a < 0 as 0
07:57:29 <monochrom> That's guards. foo a | a < 0 = 0
07:57:36 <vivit> Yes, I know guards do that
07:57:50 <vivit> What I'm asking is if there is a way to do that in multiple equations, without guards
07:58:18 <monochrom> Are you OK with a compromise?
07:58:26 <monochrom> Multiple equations and with guards.
07:58:55 <monochrom> The second equation can be "foo a | a > 5 = a^2".
07:59:48 <vivit> Do guards have to have an otherwise case?
07:59:54 <monochrom> No.
08:00:03 <vivit> Good, that gives me the information I need
08:00:39 <merijn> vivit: If all guards with a pattern equation fail it will fall through to the next equation
08:01:18 <vivit> Wonderful. That's what I was looking for.
08:34:07 * hackage ghc-events 0.8.0.2 - Library and tool for parsing .eventlog files from GHC  https://hackage.haskell.org/package/ghc-events-0.8.0.2 (MitsutoshiAoe)
09:03:55 <nrg-rounds> anyone alive?
09:04:43 <Ariakenom> probably. somewhere
09:05:06 <nrg-rounds> thats reassuring
09:05:16 <fendor> cant find the type: `Maybe a -> MaybeT m a`
09:05:26 <fendor> @hoogle Maybe a -> MaybeT m a
09:05:27 <lambdabot> Intro MaybeT :: m (Maybe a) -> MaybeT a
09:05:27 <lambdabot> HsDev.Stack MaybeT :: m (Maybe a) -> MaybeT a
09:05:27 <lambdabot> Intro runMaybeT :: MaybeT a -> m (Maybe a)
09:06:02 <statusfailed> What does "unitary" mean in the context of category theory?
09:08:54 <fendor> @pl MaybeT $ return $ (do Just 3)
09:08:54 <lambdabot> MaybeT (return (do Just 3))
09:11:01 <fendor> how can I lift a m
09:11:18 <fendor> `Maybe a` to `MaybeT m a` without including an additional dependency?
09:11:34 <fendor> MaybeT . return seems to do the job, but it is kind of ugly
09:13:35 <flebron_> Hi folks. Is there a polymorphic version of Data.Function.on? That is, I have (f x) `op` (f y), but f is polymorphic, and x and y do not have the same type (`op` is <*>, f is Compose, x and y are different Applicatives).
09:13:37 * hackage haskoin-node 0.9.6 - Haskoin Node P2P library for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-node-0.9.6 (xenog)
09:39:02 <lyxia> not in anywhere I know
09:58:03 <remexre> how do I compose a prism with a lens
09:59:58 <dminuoso> remexre: With (.) like usual
10:00:10 <dminuoso> remexre: Keep in mind that the result will be a traversal (an affine one if you have profunctor optics)
10:00:30 <remexre> why wouldn't it be a prism?
10:00:42 <remexre> I'm new to anything other than plain lenses
10:01:01 <dminuoso> remexre: It cant be either.
10:01:11 <dminuoso> remexre: It cant be a prism because you cant *build* it, and it cant be a lens because it could still fail
10:02:18 <ProofTechnique> I'm talking about the algebra of types in a talk at work, and I've hit an unusual case in `id`. Its type `a -> a` implies that the cardinality of the type should be `|a|^|a|`, but without any constraints there's really only one function of `a -> a` due to parametricity. Is there a way to square this nicely without getting into normalized lambda terms and foralls? Or is it better to just kind of hand-wave and say that
10:02:18 <ProofTechnique> `id` defines a
10:02:18 <ProofTechnique> family of functions?
10:02:35 <anna_> Is there a way to disable GHCi's welcome message in ~/.ghci ?
10:03:07 * hackage morley 0.1.0.4 - Developer tools for the Michelson Language  https://hackage.haskell.org/package/morley-0.1.0.4 (gromak)
10:04:24 <dminuoso> % (Left 6, 'c') ^.. _1 . _Left
10:04:24 <yahb> dminuoso: [6]
10:04:29 <dminuoso> remexre: ^-
10:04:51 <remexre> huh, ok
10:05:02 <remexre> % Left (6, 'c') ^.. _Left . _1
10:05:02 <yahb> remexre: [6]
10:06:27 <remexre> % firstOf (_Left._1) (Left (6, 'c'))
10:06:27 <yahb> remexre: Just 6
10:06:30 <remexre> cool
10:19:37 * hackage morley 0.1.0.5 - Developer tools for the Michelson Language  https://hackage.haskell.org/package/morley-0.1.0.5 (gromak)
10:20:45 <lyxia> ProofTechnique: the real type of (a -> a) is (forall a. a -> a), so in naive set theory that cardinality would be the product of |a|^|a| over all a in some universe (which is indeed way too big)
10:21:35 <ProofTechnique> Right
10:22:32 <lyxia> You could also say the analogy has its limits. Not all types map well to a set/cardinal.
10:23:06 <ProofTechnique> Yeah, that may be the best thing to say.
11:26:43 <nshepperd> i would say that the cardinality |forall a. a -> a| is 1, but the forall is not something that can be calculated with simple algebra
11:27:37 * hackage record-wrangler 0.1.0.0 - Alter your records with ease  https://hackage.haskell.org/package/record-wrangler-0.1.0.0 (parsonsmatt)
11:28:08 <fen> whats this?
11:28:09 <fen> foldr2 f1 b1 f2 b2 = foldr (\ x xs -> (foldr f2 b2) x `f1` xs) b1
11:28:40 <fen> and is there a way to make increasingly nested versions using some existing combinator?
11:29:03 <nshepperd> it's something like |forall a. a -> a| = |intersection over all (a :: *) of {f | f :: a -> a}|
11:30:03 <nshepperd> where the intersection is calculated based on some kind of... syntactic equality
11:30:07 * hackage parsix 0.1.0.4 - Parser combinators with slicing, error recovery, and syntax highlighting  https://hackage.haskell.org/package/parsix-0.1.0.4 (OlleFredriksson)
11:30:24 <fen> you mean id . id = id rewrite?
11:31:03 <fen> hmm, there could be other things via arrows, like copy and then fst or snd
11:31:15 <fen> copy or split or whatever its called
11:31:52 <fen> maybe you could just have a rewirite that looked at the type, and if it was forall a. a -> a it could jut rewrite it to id
11:33:57 <nshepperd> i mean that because you can write 'id :: Int -> Int; id x = x' and 'id :: Char -> Char; id x = x' with the same syntactic implementation, that means that 'id x = x' is an element of the 'intersection' (Int -> Int) ∩ (Char -> Char)
11:34:58 <fen> but then you would have the cardinality as a measure of the number of types covered by the polymorphic `a' 
11:35:16 <fen> thats defiantly not worth measuring since you could just make more...
11:35:30 <nshepperd> no
11:37:44 <fen> anyway, for this nested foldable thing, e.g. (Foldable f,Foldable g, .... ) => f (g ( ... a) ... )) 
11:38:03 <luftmensch[m]> Little side project I’m considering, I want to try implementing Neural Ordinary Differential Equations (Chen et al. 2019) in Haskell. I’m still learning the ropes, can anyone recommend specific material I should brush up on? Pretty sure I need to be familiar with the ad package at least
11:38:04 <nshepperd> it means then that the set of functions of type 'forall a. a -> a' is then the infinite intersection '(Int -> Int) ∩ (Char -> Char) ∩ ...' including all types
11:38:06 <fen> whats the combinator that composes the foldables...
11:38:28 <fen> s/foldables/folds
11:38:39 <nshepperd> which has only one (total) member, id, so the cardinality is 1
11:39:31 <Solonarv> fen: seems cleaner to think in terms of foldMap, rather than foldr
11:39:38 <Solonarv> :t foldMap . foldMap
11:39:39 <lambdabot> (Foldable t2, Foldable t1, Monoid m) => (a -> m) -> t1 (t2 a) -> m
11:40:35 <fen> but you would have foldMap = foldMapDefault = \f -> foldr (\ x xs -> f x : xs) []                                
11:40:48 <fen> assuming the foldable is list
11:41:36 <fen> thats how this form appeared; foldr2 f1 b1 f2 b2 = foldr (\ x xs -> (foldr f2 b2) x `f1` xs) b1
11:41:38 <Solonarv> that's not a valid default for foldMap, it doesn't even have the right type
11:41:49 <Solonarv> yeah I'm not sure if there's something more elegant
11:41:59 <Solonarv> that's why I suggested thinking in terms of foldMap instead
11:42:18 <fen> its ok to restrict the type to list, since it will be an intermidiate type fusioned away anyway...
11:42:19 <Solonarv> (which is exactly as powerful as foldr, so you're not losing any expressive power by doing that)
11:42:58 <fen> basically just working with [] to mean Foldable f => f for this fusion stuff, since the (:) and [] get replaced upon folding anyway
11:43:36 <fen> Solonarv: you suggesting implementing foldr in terms of foldMap instead? 
11:43:45 <fen> not sure whats the idea behind that
11:43:49 <Solonarv> well it's not actually clear to me what you're trying to do
11:44:24 <fen> why do you think reversing the fold / foldmap would help?
11:45:50 <fen> explaining the actual fusion rule being aimed at right now would be not the right thing, just to understand these nested foldr's is enough
11:45:58 <Solonarv> well, which of the following seems cleaner to you:
11:45:59 <Solonarv> (foldMap . foldMap) f
11:45:59 <Solonarv> foldr (\xs r -> foldr f z xs `g` r) y
11:46:15 <fen> maybe nested foldMaps are more simple then that would be understadable, just not sure about trying to get foldr from foldMap
11:46:54 <Solonarv> foldr f z = foldMap (Endo . f) `appEndo` z
11:46:57 <fen> Solonarv: those do different things! foldMap preserves the containers, foldMap nyams them up
11:47:02 <fen> foldr*
11:47:26 <Solonarv> foldr and foldMap are equally powerful, you can implement each one in terms of the other
11:47:33 <fen> ok fair enough, with that they are equivalent...
11:48:12 <fen> doh!
11:48:16 <fen> thought you meant fmap
11:48:21 <fen> thats what was confusing
11:48:50 <fen> :t foldr (\ x xs -> f x : xs) []                                
11:48:51 <lambdabot> (FromExpr a, Show t2, Foldable t1) => t1 t2 -> [a]
11:48:55 <Solonarv> hm, actually that nested foldr can be shortened:
11:48:55 <Solonarv> foldr (\xs r -> g (foldr f z xs) r) y
11:48:55 <Solonarv> foldr (\xs -> g (foldr f z xs)) y
11:48:55 <Solonarv> foldr (g . foldr f z) y
11:49:16 <fen> % :t \f -> foldr (\ x xs -> f x : xs) []                                
11:49:16 <yahb> fen: Foldable t1 => (t2 -> a) -> t1 t2 -> [a]
11:49:32 <fen> its a restricted *fmap* sorry, not foldMap
11:49:52 <fen> thats why it was surprising to think foldr could be defined in terms of *fmap* 
11:49:56 <Solonarv> oh, I see
11:50:40 <Solonarv> your function is just \f -> fmap f . toList
11:50:44 <fen> basically we are fmapping foldr into seccond level of 2 nested foldables
11:51:05 <fen> just assume the foldables are always lists...
11:51:26 <Solonarv> well in that case you've reimplemented list's fmap
11:51:33 <fen> :t foldr (g . foldr f z) y
11:51:34 <lambdabot> (Show a, Foldable t2, Foldable t1) => t1 (t2 a) -> Expr
11:51:55 <fen> % :t \ f g y z -> foldr (g . foldr f z) y
11:51:56 <yahb> fen: (Foldable t1, Foldable t2) => (a -> b1 -> b1) -> (b1 -> b2 -> b2) -> b2 -> b1 -> t1 (t2 a) -> b2
11:52:21 <fen> noo
11:52:46 <fen> % :t foldr ((:) . foldr (:) []) []
11:52:46 <yahb> fen: (Foldable t1, Foldable t2) => t1 (t2 a) -> [[a]]
11:52:49 <fen> ahhh
11:53:07 <fen> then the fusion wants to be able to change those (:)
11:53:40 <fen> but first it would make sense to be able to combine these folds... guess with foldMap the combinator is (.) ? could be helpful
11:53:41 <Solonarv> @let foldr2 = \ f g y z -> foldr (g . foldr f z) y
11:53:42 <lambdabot>  Defined.
11:53:55 <Solonarv> :t foldr2 (:) (:) [] []
11:53:55 <lambdabot> (Foldable t1, Foldable t2) => t1 (t2 a) -> [[a]]
11:54:13 <fen> right
11:54:38 <fen> but we dont really want to define foldr7
11:54:58 <Solonarv> another approach is:
11:54:58 <Solonarv> @let foldrMap f k z = foldr (k . f) z
11:54:59 <lambdabot>  Defined.
11:55:01 <Solonarv> :t foldrMap
11:55:02 <lambdabot> Foldable t => (a -> b1) -> (b1 -> b2 -> b2) -> b2 -> t a -> b2
11:55:17 <Solonarv> :t foldrMap (foldr (:) []) (:) []
11:55:19 <lambdabot> (Foldable t2, Foldable t1) => t1 (t2 a) -> [[a]]
11:55:57 <fen> :t foldrMap (foldrMap (foldr (:) []) (:) []) (:) []
11:55:58 <lambdabot> (Foldable t3, Foldable t2, Foldable t1) => t1 (t2 (t3 a)) -> [[[a]]]
11:55:58 <Solonarv> well if you want to have a unified combinator for n-ary nesting things get a bit complicated/annoying
11:56:25 <fen> just trying to make the fusion rule have a recursive step and a basecase
11:56:29 <Solonarv> even for nice functions like foldMap, concat etc
11:56:38 <fen> so it could work with any depth of nesting
11:56:50 <Solonarv> what are you trying to fuse, anyway?
11:57:32 <fen> fmap (foldr g bc) $ loop (superloop sf s) === consume (hyloList s sf g bc) (:) []
11:58:10 <fen> where loop is like build, except it works with state encoding instead of church encoding, basically unfold followed by fold
11:59:17 <fen> and hyloList is a version that also returns the leftover state of a "superstate", for superLoop (another build like thing but for these halting state things)
11:59:52 <fen> consume and hyloList are similar, in that they basically do unfold followed by fold
12:00:24 <fen> loop and superLoop are then just restricting the folding functions to (:) and [] like build does
12:00:35 <fen> type SuperState s a = s -> Maybe (a,Maybe s)
12:00:41 <fen> type State1 s a = s -> (a,Maybe s)
12:00:50 <fen> superLoop :: SuperState s a -> State1 s [a]
12:01:26 <fen> Solonarv: comprehend? 
12:01:47 <Solonarv> not really, sorry
12:02:08 <fen> hmm
12:02:23 <fen> well its for build fold fusion, but a state-encoding version
12:02:52 <fen> the fusion rules are like foldl / consume and unfoldr / consume
12:03:27 <fen> there must be some kind of higher type of SuperState, that is a state of superstates and so on
12:03:42 <Solonarv> I think you should get fusion here by having
12:03:42 <Solonarv> 1) a rule for fmap f (loop g) which moves f into loop's argument
12:03:42 <Solonarv> 2) a rule involving foldr and superloop, not sure what that is
12:04:23 <fen> you think fmap would be better than fold here?
12:05:05 <fen> i know we are fmap . fmap ... ing into the nested layers, but that would use fmapDefault using foldr and the foldr fusion?
12:05:09 <adamCS> fen, Solonarv: Is this something recursion-schemes could be used for?  I'm just learning a bit of that now so I don't really know.  But it seems like the sort of thing recursion-schemes was designed to simplify, maybe?
12:05:09 <Zvpun> How can I convert `Num a` to Double or Fractional a?
12:05:37 <fen> :t realToFrac :: Num a -> Double 
12:05:38 <lambdabot> error:
12:05:38 <lambdabot>     • Expected a type, but ‘Num a’ has kind ‘Constraint’
12:05:38 <lambdabot>     • In an expression type signature: Num a -> Double
12:05:45 <fen> :t realToFrac :: Num a => a -> Double 
12:05:46 <lambdabot> error:
12:05:47 <lambdabot>     • Could not deduce (Real a1) arising from a use of ‘realToFrac’
12:05:47 <lambdabot>       from the context: Num a
12:05:49 <ProofTechnique> :t realToFrac
12:05:51 <sphalerite> Hi folks! I've been fiddling with ghci and would like to save the current session's history to a file, how can I do this?
12:05:54 <fen> sorry
12:05:54 <lambdabot> (Fractional b, Real a) => a -> b
12:06:04 <Solonarv> adamCS: yes, recursion-schemes is related
12:06:34 <ProofTechnique> :t fromRational
12:06:35 <lambdabot> Fractional a => Rational -> a
12:06:51 <Solonarv> (I think, anyway; fen's been talking about this for sevaral months, but I still don't quite understand what they're doing)
12:07:35 <fen> well, not being an expert on recursion schemes it wouldnt be right to pass comment
12:08:50 <fen> Solonarv: sure there could be a fmap fusion specifically, but there should also be a multiple fold version aswell
12:09:21 <fen> lets revisit this again soon to avoid jamming the channel 
12:09:34 <Solonarv> I'm not sure what it would mean to fuse folds, anyway
12:10:32 <fen> thats basically the question! well, its folds fusing into nested "loops" which are like builds which expose the internal state
12:10:55 <fen> thought it would just be a start to understand how to nest folds.
12:11:03 <fen> still dont even know how to nest states...
12:11:07 <fen> thats another question
12:12:22 <adamCS> I think the idea is that if you are folding to a different data structure and then unfolding that (like Map.toList . MapFromListWith f), recursion schemes lets you do that with a guarantee that the intermediate Map is never built. 
12:12:50 <adamCS> But I don't really know how the nesting plays into that in fen's case
12:13:19 <fen> thats perfect adamCS, thats exactly what this is doing, but via an explicit fold . unfold fusion rule
12:13:49 <fen> and yeah, it could be that nesting is as difficult to do using either method
12:14:39 <adamCS> Right.  recursion-schemes generalizes that to non-list base functors, so you no longer depend on explicit fusion rules or list fusion
12:15:21 <adamCS> Is 'nesting" here somehow different from "recursion" in the sense of recursive data types?
12:17:58 <adamCS> Like, if your t1 and t2 are lists, maybe this is all a rose-tree fold?  
12:19:31 <adamCS> Or not, because the types aren't the same.  Hmm. I'll think about it...
12:20:04 <fen> % let consume = (\s sf f bc -> maybe bc (\(a,s')->a `f` consume s' sf f bc) (sf s))
12:20:04 <yahb> fen: 
12:20:13 <fen> % let loop = (\s sf -> consume s sf (:) []) :: s -> (s -> Maybe (a,s)) -> [a]
12:20:13 <yahb> fen: 
12:20:19 <fen> % :t loop
12:20:19 <yahb> fen: s -> (s -> Maybe (a, s)) -> [a]
12:21:54 <fen> adamCS: well the idea is just that they are nested foldables, ie Foldable (f,g,h ...) => f (g (h ... a)))
12:22:09 <fen> and that *if* they are lists, that were "built" using loop
12:22:53 <fen> then you can have a fusion rule for if you fold over some depth, replacing the (:) and [] at that depth with the folding functions
12:23:48 <fen> we can actually define loop using arbitrary cons and empty defined in a class, then this subset of foldables that also is "consable" can be fused over
12:24:07 <fen> so its more like; Set (f,g,h ...) => f (g (h ... a)))
12:24:36 <adamCS> Do you need to have nested foldables or do you just have a nested data-structure that needs folding with different combining functions at different levels?
12:25:04 <fen> how is that not folding?
12:25:13 <fen> no, fold is perfect for this
12:25:46 <fen> also, if there is anything that can be said about recursion-schemes, and why we might seek this "Set class" based explicit fusion approach
12:26:04 <fen> its that, by explicitly providing all possible implementations of some abstraction...
12:26:08 <fen> well, basically, its better
12:26:31 <adamCS> Sorry.  I get that it's folding.  I was wondering how you get *nested* foldables 
12:26:37 * hackage hadolint 1.16.3 - Dockerfile Linter JavaScript API  https://hackage.haskell.org/package/hadolint-1.16.3 (lorenzo)
12:26:55 <fen> just like list of lists, or higher nested version of that
12:27:33 <fen> % :t Identity ((1::Int,["hello","world"])) 
12:27:33 <yahb> fen: Identity (Int, [[Char]])
12:28:10 <fen> this has something to do with scrap your biplate
12:30:33 <fen> i guess maybe there is some logic about e.g. Foldable as a subclass of Traversable. you wouldnt question the existance of Foldable just because there is a wider encompasing abstraction, namely Traversable
12:31:07 <fen> so if we can identify a subclass of recursion schemes, and implement all the fusion and stuff, then it gives another API, which might be more nformative
12:31:55 <fen> the real question is how to make nested states!
12:33:16 <fen> s -> Maybe (a, Maybe s) can be converted to s -> ([a],Maybe s) by "superLoop" (above), and then this resulting State using loop can become [[a]]
12:33:41 <fen> s -> Maybe (a, Maybe s) then appears like a "2 nested state"
12:33:59 <fen> but what is a "3 nested state" ? or an "n nested state"
12:34:39 <fen> https://pastebin.com/raw/DM4GLaNa
12:35:07 * hackage language-c99 0.1.1 - An implementation of the C99 AST that strictly follows thestandard.  https://hackage.haskell.org/package/language-c99-0.1.1 (frankdedden)
12:36:04 <fen> https://pastebin.com/raw/RBrTzJcK
12:37:37 <adamCS> fen: I will think on it some more.  Gotta go for now.  Good luck!
12:40:07 * hackage language-c99-simple 0.1.1 - C-like AST to simplify writing C99 programs.  https://hackage.haskell.org/package/language-c99-simple-0.1.1 (frankdedden)
12:41:07 * hackage language-c99-util 0.1.1 - Utilities for language-c99.  https://hackage.haskell.org/package/language-c99-util-0.1.1 (frankdedden)
12:54:37 * hackage pointfree-fancy 1.1.1.12 - Tool for refactoring expressions into pointfree form  https://hackage.haskell.org/package/pointfree-fancy-1.1.1.12 (vmchale)
12:57:37 * hackage elsa 0.2.1.2 - A tiny language for understanding the lambda-calculus  https://hackage.haskell.org/package/elsa-0.2.1.2 (ranjitjhala)
13:00:51 <akr> any idea what happened to hayoo? it's been down a fairly long time
13:00:59 <akr> like, a week or something
13:11:09 <fr33domlover> Hmm is there a rule of thumb for using MVars to lock access to resources? I fetch many documents from the network, and for each one I need to do an update in the DB. Option (1) is to download a resource, withMVar updateDB, fetch the next resource, withMVar updateDB... etc. (2) fetch all resources, then use withMVar once to update them all at once
13:11:36 <fr33domlover> I guess the weakness of (2) is that it may starve threads right?
13:11:49 <fr33domlover> Like, lock access for a long-ish time
13:12:18 <fr33domlover> But (2) also means the lock happens just once instead of tons of MVar takes and puts happening all over
13:12:31 <fmsbeekmans> Can I derive a MonadState for something that newtype that wraps a 2-tuple?
13:13:43 <dmwit> I don't know if you can. But I can.
13:13:50 <glguy> Next, should you
13:14:13 <Welkin> fr33domlover: don't use locks
13:14:17 <Welkin> they are a terrible idea
13:14:29 <Welkin> don't share state
13:15:07 * hackage record-wrangler 0.1.1.0 - Alter your records with ease  https://hackage.haskell.org/package/record-wrangler-0.1.1.0 (parsonsmatt)
13:16:21 <fr33domlover> Welkin, it's for making some DB access atomic :p my alternative is to figure out long ugly SQL queries. So far what I do is, persistent and esqueleto queries, and I lock with MVar when doing stuff that isn't atomic
13:17:17 <fr33domlover> (Not the whole DB, just sections of it ^_^)
13:17:51 <Rembane> fr33domlover: I think having a channel/queue is a nice solution. Do you want to be nice to the network or can you start one thread per document?
13:20:09 <dmwit> fr33domlover: One thing you could consider is having a central thread whose job it is to handle that section of the DB. Your fetches can send that thread a message when they get an update.
13:20:10 <Rembane> fr33domlover: Or you could use the async package and get a list of documents which you can insert into the database. 
13:20:31 <dmwit> What's nice about this approach is that you can separate out the concern of deciding when to write from the concern of producing data to write.
13:20:41 <fr33domlover> Rembane, yeah I've considered that, but I'm not sure it does much good (it serializes the DB access and it would use a Chan, which iirc just uses MVar behind the scenes?)
13:20:48 <dmwit> Because that separate thread can implement policies like "batch up messages for ten seconds, then do a write" e.g.
13:21:06 <dmwit> For your first draft the policy can just be "write on every message", and you can improve it later if you discover that's not good enough.
13:21:20 <fr33domlover> (Well, locks serialize access too, it's just more flexible how to use them around pieces of code)
13:23:34 <Cale> fr33domlover: The important thing is that the Chan means the individual threads don't have to wait (assuming they don't need a response back from the db)
13:23:44 <Welkin> use CRDTs and write-only a database
13:23:50 <Welkin> then you eliminate the problem
13:23:56 <Welkin> you don't update the data
13:23:58 <fr33domlover> dmwit, the writes would always be instant. I wonder though, about the difference between using O(n) Chans and threads versus using a HashMap with O(n) MVars to lock access
13:24:07 <Welkin> append-only*
13:24:09 <Cale> fr33domlover: The cost of hitting an external DB is going to be way higher than many accesses to an MVar or Chan
13:24:10 <fr33domlover> Cale, I already use locks only for writing
13:24:50 <fmsbeekmans> https://gist.github.com/fmsbeekmans/b762b69ba0dbb91b415dfe29a3f3e15a
13:25:06 <fmsbeekmans> What exactly does the possible fix ghc suggests mean here?
13:25:36 <Cale> fmsbeekmans: There isn't already an instance of MonadState for pairs (nor should there be)
13:26:04 <fr33domlover> Welkin, sometimes I must update shared resources (when I don't, it's just a safe SQL insert or update)
13:26:07 * hackage webby 0.1.0.0 - A super-simple web server framework  https://hackage.haskell.org/package/webby-0.1.0.0 (AdityaManthramurthy)
13:26:18 <fmsbeekmans> Cale: Ah, I thought that I could derive one because State is a newtype around a pair.
13:26:23 <Cale> No it isn't
13:26:37 <Cale> It's a newtype around a function, which produces a pair
13:27:13 <fmsbeekmans> I see, I'm mixing State and Writer.
13:27:42 <fmsbeekmans> Cale: If it were the same shape, does deriving via newtype work like that?
13:28:12 <Cale> not necessarily. The important thing is that there's an instance for whatever type you're newtyping directly
13:28:31 <Cale> It won't go looking for other newtypes of that type which might have an instance
13:28:43 <fmsbeekmans> Cale: Ok, thanks
13:29:03 <Cale> You'd want to make your newtype a newtype of State or StateT of something (or anything with a MonadState instance)
13:31:07 * hackage http2-grpc-types 0.4.0.0 - Types for gRPC over HTTP2 common for client and servers.  https://hackage.haskell.org/package/http2-grpc-types-0.4.0.0 (LucasDiCioccio)
13:32:19 <Solonarv> you actually can use some other newtype with the same shape, but you have to specify which one - that's what the fancy new DerivingVia extension is
13:32:30 <Solonarv> (well, actually it's even a bit more general than that)
13:34:04 <Solonarv> e.g. you could write:
13:34:04 <Solonarv> % newtype MyMonad e a = MyMonad { runMyMonad :: e -> IO a } deriving (Functor, Applicative, Monad, MonadIO, MonadReader e) via (ReaderT e IO a)
13:34:05 <yahb> Solonarv: ; <interactive>:396:69: error:; * Cannot derive instance via `ReaderT e IO a'; Class `Functor' expects an argument of kind `* -> *',; but `ReaderT e IO a' has kind `*'; * In the newtype declaration for `MyMonad'; <interactive>:396:78: error:; * Cannot derive instance via `ReaderT e IO a'; Class `Applicative' expects an argument of kind `* -> *',; but `ReaderT e 
13:34:13 <Solonarv> % newtype MyMonad e a = MyMonad { runMyMonad :: e -> IO a } deriving (Functor, Applicative, Monad, MonadIO, MonadReader e) via (ReaderT e IO)
13:34:13 <yahb> Solonarv: 
13:42:07 * hackage registry 0.1.3.1 - data structure for assembling components  https://hackage.haskell.org/package/registry-0.1.3.1 (etorreborre)
13:47:29 <MacSlow> Greetings everybody!
13:48:07 * hackage webby 0.1.0.1 - A super-simple web server framework  https://hackage.haskell.org/package/webby-0.1.0.1 (AdityaManthramurthy)
13:58:46 <fr33domlover> Another point btw is that using MVars is simpler: If I wanted to use Chan queues (which I still may), the easy way is to have a HashMap Text (Chan Cmd) where each Chan is associated with a thread. And I suppose a more flexible solution but maybe more complicated, is to have something like the resource-pool package, where threads stop if unused, so it's scalable and shrinkable, and still allows to choose a
13:58:49 <fr33domlover> specific thread and not an arbitrary one (which is how resource-pool works, so, I can't use it as-is)
13:59:19 <Welkin> use the actor model
13:59:29 <Welkin> it's the way the internet works
13:59:37 <Welkin> cloud haskell
13:59:41 <Welkin> threads suck
13:59:45 <Welkin> shared state is evil
14:02:52 <slack1256> thread programming is not bad with stm though
14:03:31 <slack1256> but yeah with an actor model, you can have supervision trees which increment reliability a lot
14:04:13 <Welkin> and it's fully asynchronous (well you need to make sure you don't make any synchronous requests)
14:04:34 <Welkin> you can have a partial system failure and still have it work fine
14:04:36 <Welkin> and even recover
14:04:54 <Welkin> in a threaded model, one problem in a tiny portion of your program will bring the whole thing crashing down
14:05:32 <tabaqui> what do you mean by actors here?
14:05:50 <Welkin> https://en.wikipedia.org/wiki/Actor_model
14:05:51 <tabaqui> haskell has no other primitives except of fork and mvar
14:05:56 <slack1256> Also, what is your idea of thread programming?
14:05:58 <Welkin> look at cloud haskell
14:06:06 <Welkin> better yet, look at erlang
14:06:19 <tabaqui> I know how it works in Erlang/Elixir
14:06:37 <tabaqui> but they was created for this
14:06:41 <Welkin> a haskell "thread" is treated like an erlang process
14:06:55 <Welkin> which it can be if you do it right
14:07:05 <tabaqui> haskell has no priority system and access to hypervisor
14:07:09 <Welkin> it doesn't have the exact same characteristics, but it's close enough
14:07:19 <Welkin> tabaqui: see cloud haskell
14:07:29 <tabaqui> Welkin: ok, I will
14:08:35 <tabaqui> I just thought that "actors" in haskell is usual library built in top of forkIO/STM
14:09:07 * hackage http2-client-grpc 0.6.0.0 - Implement gRPC-over-HTTP2 clients.  https://hackage.haskell.org/package/http2-client-grpc-0.6.0.0 (LucasDiCioccio)
14:10:10 <tabaqui> *on top
14:22:59 <slack1256> There is no library called "actor", there are a bunch of them with that description but not one is really popular (by DL metric)
14:26:07 * hackage fair 0.1.0.0 - Lists with fair choice  https://hackage.haskell.org/package/fair-0.1.0.0 (MatthewFarkasDyck)
14:27:11 <tobiasBora> Hello,
14:27:40 <tobiasBora> I'm trying to package a software to Nix, and therefore I need to compile it with latest ghc version
14:27:51 <tobiasBora> However, it appears that new errors are created:
14:28:05 <tobiasBora> The code contains:
14:28:07 <tobiasBora> {-# LANGUAGE DeriveGeneric      #-}
14:28:11 <tobiasBora> import           Network.Socket                (HostName, PortNumber)
14:28:16 <tobiasBora> deriving instance Generic PortNumber
14:28:26 <tobiasBora> But during the compilation there is an error:
14:28:55 <tobiasBora> Can't make a derived instance of ‘Generic PortNumber’ The data constructors of ‘PortNumber’ are not all in scope so you cannot derive an instance for it
14:29:07 <tobiasBora> any idea what's wrong?
14:30:34 <slack1256> I am pretty sure `type PortNumber = Int`
14:32:04 <tobiasBora> slack1256: well if I do so I've tons of error after about Ambiguous occurrence ‘PortNumber’
14:32:23 <johnw> flycheck-
14:32:58 <johnw> flycheck-haskell seems to have stopped working for me again a few days ago, but I can't track down where the point of failure is. Does anyone have experience tracking down "cannot satisfy -package" errors when using flycheck-haskell with cabal.project files?
14:33:34 <Welkin> I can never get anything to work with emacs, so I just give up and use barebones emacs
14:34:14 <slack1256> tobiasBora: my bad, it is `newtype PortNumber = PortNum Word16`
14:34:33 <slack1256> Welkin: welcome to the club ;-)
14:35:49 <tobiasBora> slack1256: still the same error of ambiguous occurrence of PortNumber. But why do we need to redefine it as we already import it from Network.Socket?
14:36:05 <slack1256> Nooo, don't redefine it
14:36:20 <slack1256> PortNumber is a newtype of Word16
14:36:35 <tobiasBora> slack1256: so I don't even import it?
14:36:59 <slack1256> if Word16 is already Generic (I don't know if), you can use GeneralizeNewtypeDeriving to get the correct instance
14:37:05 <slack1256> import it from Network.Socket
14:37:41 <tobiasBora> oh, so your code was not meant to be written in the file
14:37:54 <slack1256> No
14:38:15 <slack1256> it was meant to illustrate the solution by means of knowing what were we acting on
14:38:21 <akr> how do I get ghci to load code with profiling enabled?
14:39:07 <tobiasBora> makes more sense. So I should just replace "deriving instance Generic PortNumber" with "deriving instance "
14:39:34 <tobiasBora> hum actually I'm not sure to see what I should use to replace it
14:39:51 <slack1256> Are you by change using the DeriveVia extension?
14:40:40 <tobiasBora> slack1256: this programs just uses the basic {-# LANGUAGE DeriveGeneric      #-}
14:40:52 <slack1256> tobiasBora: you could change on top of your file the "DeriveGeneric" with "GeneralizedNewtypeDeriving" and see if it works
14:42:35 <tobiasBora> slack1256: Can't make a derived instance of ‘Generic PortNumber’ (even with cunning GeneralizedNewtypeDeriving):
14:42:41 <tobiasBora> You need DeriveGeneric to derive an instance for this class
14:43:27 <Nevoic> Is there any package that exists to invert call flow of methods? Like
14:43:28 <Nevoic> map $ (\
14:44:01 <slack1256> tobiasBora: I think the original error has some grain of truth
14:44:02 <Nevoic> map $ (\x -> x + x) numbers
14:44:02 <Nevoic> to
14:44:02 <Nevoic> numbers |> map \x -> x + x
14:44:40 <geekosaur> that PortNumber thing sounds like the real fix is: import Network.Socker (HostName, PortNumber(..))
14:44:54 <geekosaur> er Network.Socket
14:45:18 <dmwit> % :set -XBlockArguments
14:45:18 <yahb> dmwit: 
14:45:27 <slack1256> The network library doesn't want people creating `PortNumber`-s without getAddrInfo. I would await for somebody else that maybe has an idea
14:45:27 <dmwit> % [1..5] & map \x -> x+x
14:45:27 <yahb> dmwit: [2,4,6,8,10]
14:45:32 <dmwit> Nevoic: ^
14:45:51 <Nevoic> What does that do? % and & ?
14:46:02 <dmwit> slack1256: PortNumber is an instance of Num.
14:46:11 <dmwit> Nevoic: % is just the marker to tell yahb to pay attention.
14:46:15 <dmwit> Nevoic: (&) is flip ($)
14:46:43 <Nevoic> Oh cool. Thanks!
14:46:53 <geekosaur> PortNumber is kinda bad magic anyway, you may want to be very careful with it
14:47:32 <geekosaur> don't know what current network package does, but it used to store the port in network byte order (byteswapped from Intel ints) and the Num instance does the byteswapping
14:47:42 <tobiasBora> dmwit: so being an instance of num is not enough to be "generic"?
14:47:57 <Welkin> why do you need a generic instance?
14:48:00 <Welkin> what are you trying to do?
14:48:03 <geekosaur> which means anything using generics has the potential to do unexpected things, because generics won't know about the byteswapping
14:48:10 <geekosaur> it would assume it's just a native int
14:48:38 <tobiasBora> geekosaur: but at some point I guess it was working as the library works with older ghc
14:49:05 <dmwit> tobiasBora: Oh, I didn't understand that the top-level request was for a Generic instance. I was just replying to "don't create without getAddrInfo" which doesn't seem right to me.
14:49:08 <tobiasBora> geekosaur: after, I'm not sure, but it is possible that Generic is just meant to have "Hashable" after?
14:49:08 <geekosaur> guessingt hat's actually older network paackage, because there were major changes in the most recent release
14:49:44 <tobiasBora> dmwit: To start again, I'm trying to make the following program compile on newer GHC: https://github.com/erebe/wstunnel/blob/master/src/Types.hs
14:50:20 <tobiasBora> geekosaur: so this strick about ordering is recent?
14:50:38 <geekosaur> Hashable is probably using generic deriving in a safe way. but recent network may hide the guts because that byteswapping thing is an evil trap that trips people up all the time
14:50:58 <dmwit> I'm mildly surprised this ever worked, to be honest.
14:51:19 <dmwit> I would expect DeriveGeneric to need more than just the type name to be in scope.
14:52:24 <tobiasBora> dmwit: well I tried to compile with the stack package given online and it actually worked
14:53:04 <tobiasBora> geekosaur: so it may be possible that generic is just used for Hash? If yes, how could I make the "new" version hashable?
14:54:03 <dmwit> You can piggy-back on Integer's Hashable instance.
14:54:25 <dmwit> hashWithSalt s portNumber = hashWithSalt s (toInteger portNumber)
14:54:31 <geekosaur> if you can get there. I wonder if you can just depend on network < 3
14:54:46 <dmwit> It's got an Integral instance.
14:55:56 <dmwit> (Precision: I checked 2.5.0.0 and 3.0.1.1 and they both provide Integral instances. That seems like good evidence to me that you can rely on that instance being there in a wide version range.)
14:57:38 <tobiasBora> geekosaur: the thing is that nixos packs only latest versions of dependencies, so it's not really a solution if I want to pack it
14:58:10 <geekosaur> ok, so you'll need dmwit's solution
14:58:41 <tobiasBora> dmwit: /me is trying to implement dmwit solution
14:58:45 <tobiasBora> ahah
15:01:16 <tobiasBora> Hum, seems better, now I've another error
15:01:19 <tobiasBora> Ambiguous occurrence ‘hGetBuffering’
15:01:34 <tobiasBora> from ClassyPrelude.hGetBuffering or System.IO.hGetBuffering
15:01:42 <tobiasBora> Haskell is not really backward compatible ^^
15:02:16 <tobiasBora> if the above solution is enough however, thanks!
15:02:50 <Welkin> drop classyprelude 
15:02:51 <Welkin> o.o
15:03:32 <geekosaur> prelude replacements are usually begging for trouble like that
15:04:04 <geekosaur> ba ckward compatibility is usually not one of their design goals
15:04:14 <tobiasBora> Can't it create other problems afterwards? I guess the creator of the lib chose this for some reasons no?
15:04:16 <hpc> people defining the same thing twice isn't what backward compatibility is about
15:05:14 <hpc> the language telling you about overlapping imports is the best case scenario
15:05:44 <hpc> you don't want it to just pick one, because you'll never know if it's the right one
15:06:27 <tobiasBora> and what's the point of classyprelude? To import basic stuff?
15:08:55 <Welkin> the point is nothing
15:09:05 <Welkin> to fetishize typeclasses
15:09:19 <merijn> The point is: Some people dislike the standard prelude and use their own incompatible one instead
15:09:30 <Solonarv> well, there are a bunch of warts in the standard Prelude
15:09:42 <Solonarv> One possible response to this is: "I know, I'll use a different prelude!"
15:09:49 <Welkin> sure, you can just hide those and import them directly
15:09:58 <Welkin> it's not a big deal
15:10:18 <c_wraith> my take is that libraries should be usable without special preludes, but they're fine for executables.
15:10:36 <Solonarv> agreed
15:11:43 <Welkin> agrarian
15:11:46 <merijn> c_wraith: Which, since like 80% of my code is libraries means they're basically useless :p
15:13:02 <Welkin> get with the times and use gulper and browserpackify with your package.yaml
15:16:03 <c_wraith> merijn, write a new prelude specifically for implementing libraries that are compatible with the base prelude.
15:18:02 <Welkin> but remove all of the folds and make fmap/map and filter unusable byt requiring an obscure interface for them
15:20:37 * hackage copilot 3.0 - A stream DSL for writing embedded C programs.  https://hackage.haskell.org/package/copilot-3.0 (frankdedden)
15:20:50 <fr33domlover> tobiasBora, network 2.8 changed PortNumber, see the changelog
15:21:12 <fr33domlover> (sorry if you already already saw that, maybe I missed stuff)
15:21:22 <fen> there must be times when updating the actual prelude is worth doing?
15:21:37 * hackage copilot-theorem 3.0, copilot-language 3.0, copilot-libraries 3.0, copilot-core 3.0, copilot-c99 3.0 (frankdedden)
15:21:41 <fen> its a process of consensus right?
15:21:45 <tobiasBora> fr33domlover: ok thanks
15:21:58 <fen> is there a darcs or something for that?
15:22:09 <merijn> fen: The Prelude has been updated in the past (with AMP and FMP proposals, for example)
15:22:19 <tobiasBora> also, I tried to remove classyprelude, but I still have one error about Int. Should I import prelude instead, or is there a better way to solve it? Not in scope: type constructor or class ‘Int’
15:22:25 <merijn> fen: But generally there's not really that much reason to change it
15:22:50 <c_wraith> merijn, wasn't it FTP?
15:22:56 <merijn> fen: Keep in mind that anything in Prelude is ALWAYS in scope and thus taking up valuable names. If you want new stuff you can just import it.
15:22:58 <fen> right, and these tend to break old code right? like having to go back most recently to factor semigroup out of monoid
15:23:02 <merijn> c_wraith: Probably, I'm tired
15:24:06 <Welkin> tobiasBora: disable "NoImplicitPrelude"
15:24:16 <Welkin> probably in the cabal file, or at the top of the file
15:24:22 <fen> argh, noImplicitPrelude is terrible!
15:24:36 <fen> you cant use putStrLn or anything
15:24:43 <Solonarv> well, if you want to use a custom prelude it makes sense
15:25:00 <Solonarv> don't want the custom prelude's stuff to clash with the base Prelude
15:25:30 <fen> but without basic things like that you cant even produce an output to test if your programs working as expected!
15:25:38 <tobiasBora> Welkin: hum... 
15:25:43 <fen> you just have to compile and hope
15:25:45 <Welkin> no Ints for you
15:25:57 <Welkin> you'll have to write your own Ints using church encoding
15:25:59 <Welkin> also no lists
15:26:05 <Welkin> write your own lists, fool!
15:26:10 <fen> lol
15:26:24 <Solonarv> I'd wager most custom preludes export some variant of putStrLn
15:26:38 <fendor> yeah, also lists
15:26:57 <tobiasBora> But I'm a bit worried: the library initially needed classyprelude. But people from here asked me to remove it, while the library says "Prelude is soo old school, use us!". I'm a bit lost, Prelude is good or devil?
15:27:05 <fendor> i wonder if there is some custom prelude that prefers vector over lists as default data structure 
15:27:06 <Welkin> look at this line from a sourcefile I am reading `S8.length bs > 4096 = leftover bs >> return bs`
15:27:09 <Welkin> it's funny
15:27:21 <Solonarv> 'foo >> return x' grrr
15:27:29 <fendor> tobiasBora, in haskell, the normal answer is, it depends.
15:27:36 <Welkin> "if the length of your bullshit is greater than 4096, get the leftover bullshit and return the bullshit"
15:27:40 <fendor> and there always at least 2 sides to an argument
15:27:57 <fendor> *there are
15:28:40 <Welkin> yes, the wrong side and the right side
15:29:10 <fen> % :t \f x -> f >> return x
15:29:10 <yahb> fen: Monad m => m a -> b -> m b
15:29:36 <Solonarv> I prefer 'x <$ foo'
15:29:42 <fendor> i suppose that is an oversimplification
15:30:02 <fen> :t (<$,$>)
15:30:03 <lambdabot> error: parse error on input ‘,’
15:30:11 <fen> :t ((<$),($>))
15:30:12 <lambdabot> error:
15:30:12 <lambdabot>     • Variable not in scope: $>
15:30:12 <lambdabot>     • Perhaps you meant one of these:
15:30:16 <fen> % :t ((<$),($>))
15:30:16 <yahb> fen: (Functor f1, Functor f2) => (a1 -> f1 b1 -> f1 a1, f2 a2 -> b2 -> f2 b2)
15:30:41 <fen> <lambdabot>     • Perhaps you meant to use yahb
15:30:53 <Solonarv> haha
15:31:46 <tobiasBora> fendor: Welkin : Maybe you have more details^^ If I arrive and remove the classyprelude library of this poor guy I need to have good arguments :P
15:33:25 <fen> i want something like unfold but that halts and returns the remaining state
15:33:40 <fendor> tobiasBora, I was late to the party, a little bit of context? 
15:33:41 <Welkin> tobiasBora: give him this 凸
15:34:21 <Welkin> you don't need a reason to delete something
15:34:28 <Welkin> instead, you need a reason to keep it
15:34:38 <Welkin> every library and every line must eran its place
15:34:41 <Welkin> earn*
15:35:11 <fendor> depends, if it is the code of someone else, it is hard to make that person to delete code, especially if that person spent a lot of time writing it
15:35:30 <Welkin> who cares if they spent a lot of time
15:35:35 <Welkin> everyone spends a lot fo time writing code
15:35:37 <fen> and if this unfold-like function takes something other than a regular state, what is this thing?
15:35:40 <Welkin> but the best thing to do is to delete code
15:35:46 <tobiasBora> fendor: I'm correcting a library to make it compile with latest GHC/libraries. However, these libraries have a "ClassyPrelude" loaded, and people here tells me "remove it". But this library is not mine, and on the webpage of classyprelude, they say "Prelude is soo old school", so I'm trying first to see if Prelude is old school and bad, or good.
15:36:08 <fendor> while mostly true, it matters to some people
15:36:09 <Welkin> classyprelude is just dumb
15:36:41 <fen> your inability to understand someone elses well devised design priorities does not invalidate them!
15:36:46 <Welkin> also good luck figuring out those errors messages with 15 type class constraints
15:36:46 <Solonarv> don't listen to Welkin, all they do is shitpost and call things bad
15:37:04 <Welkin> not true Solonarv 
15:37:10 <Solonarv> tobiasBora: what's the library?
15:37:13 <Welkin> I just call out crap when I see it
15:37:17 <fendor> tobiasBora, you can try whether it is easy to remove the dependency.
15:37:35 <fendor> maybe then decide whether it is worth the hustle to remove it or adapt it to work with latest ghc
15:37:37 <Solonarv> I actually lost track of what the original error was
15:37:49 <tobiasBora> Solonarv: https://github.com/erebe/wstunnel
15:38:09 <Welkin> it looks like OOP with IsString IsBlue IsRed IsMyMom
15:38:35 <tobiasBora> I have " Ambiguous occurrence ‘hSetBuffering’/timeout/hGetBuffering "
15:39:03 <Nevoic> I can't figure out how to make this one line:
15:39:03 <Nevoic> test :: String -> IO ()
15:39:03 <Nevoic> test name = do
15:39:03 <Nevoic>   r <- get (test2 name)
15:39:03 <Nevoic>   print $ r ^? responseBody
15:39:04 <Nevoic> I tried:
15:39:04 <Nevoic> print $ get (test2 name) >>= ^? responseBody
15:39:09 <hpc> i have to agree with Welkin here, alternate preludes don't add anything of value
15:39:19 <Solonarv> blegh, it's one of those "I use stack, therefore I don't need version bounds" libraries too
15:39:20 <tobiasBora> fendor: ok I'll try, and let the guy know that people say it's bad to use classy
15:39:28 <Welkin> also, if it is a library, definitely do not use alternate preludes
15:39:35 <hpc> improving the prelude belongs in the language design process due to where it sits in the dependency graph
15:39:39 <Welkin> it just adds extra crap that users of the library have to deal with
15:39:48 <fendor> i disagree, custom preludes can help to overcome some shortcomigns of the normal prelude
15:39:56 <Welkin> like when idiots add lens as a dependecy in a library that absolutely has no need for it
15:39:57 <hpc> and all the issues that come with alternate preludes are a result of trying to use the same namespace and skipping steps of that design process
15:40:22 <Solonarv> ripping out uses of an alternate prelude is probably quite a big chunk of work though, especially if you're just doing it to package up someone else's library
15:40:25 <glguy> Welkin: Your opinion will have more value if you can share it without being insulting
15:40:26 <fen> hpc: what about when there is some power gained by overriding some standard thing, but that is too convoluted or jarring to make standard? 
15:40:28 <fendor> it is an application, right? So it is alright to use custom preludes, imo
15:40:40 <tobiasBora> Welkin: sorry, it was not library but program actually
15:40:45 <hpc> fen: then you consider it separately
15:40:57 <hpc> lens is a separate thing and is great
15:40:59 <fen> but if it needs to override e.g. Traversable
15:41:05 <Solonarv> oh, it is a program
15:41:14 <Solonarv> then I'm much less annoyed
15:41:17 <hpc> if the author tried to replace Prelude's fst/snd, it would have sucked big time
15:42:02 <hpc> text and bytestring shadow a lot of base, but do it for a single purpose and don't creep into trying to solve numbers on top of it
15:42:22 <Welkin> you don't do artithmetic with your bytestrings?
15:42:36 <fendor> tobiasBora, btw, I think you can just use the ClassyPrelude version of the functions ‘hSetBuffering’/timeout/hGetBuffering'
15:42:59 <Solonarv> yep that's what I was going to suggest too
15:43:06 <hpc> fold/traverse started their lives outside of base before being folded in
15:43:08 <hpc> among other things
15:43:10 <fen> hpc: but you will have thrown away Ints anyway... 
15:43:10 <tobiasBora> fendor: oh, I was hidding the classy one instead. What's the difference?
15:43:35 <fendor> tobiasBora, ClassyPrelude normally lifts IO functions to use MonadIO, which composes better if you use MonadIO
15:44:00 <fendor> otherwise, i'd say it doesnt really matter, it is often a reexport of the original function with different constraint.
15:44:19 <jackdk> alternate preludes are possibly ok for leaves of the depgraph, but unacceptable for libraries because of the impact on dependency footprint
15:44:25 <jackdk> imho
15:44:26 <tobiasBora> fendor: ok thanks. So I just "import           System.IO                 hiding (hGetBuffering, hSetBuffering)"?
15:44:28 <fen> hpc: what about get/set as classes? these seem to cover a good amount of traversables...
15:44:32 <fendor> jackdk, agreed
15:44:40 <fendor> tobiasBora, I would try that, yes
15:44:58 <fen> something like Traversable_i makes a valid addition right?
15:45:22 <tobiasBora> ok thanks!
15:45:23 <hpc> you wouldn't make some kind of alternate Traversable class
15:45:33 <fen> then the original Traversable is then just a synonym, like a Monad Trasformer with the orifinal thing just being Identity to the suffixT thing
15:45:36 <hpc> you'd make your new thing, maybe class Traversable f => NewThing f
15:46:01 <Solonarv> fen: it really should be a separate library to start with, so that people can judge its worth properly
15:46:08 <hpc> if you reeeeeeeaaaaaally need to, do what text/bytestring do and shadow some minimal set of definitions for it
15:46:14 <hpc> and see how well it works
15:46:32 <Solonarv> semigroup, applicative, and a bunch of other things-now-in-base started out that way
15:46:47 <hpc> the point is to keep it as small as possible, for reasons not even related to being a prelude replacement
15:46:56 <fendor> tobiasBora, good luck with porting it! have fun with the type-puzzle :)
15:46:58 <hpc> if your change gets folded into base, you want it to be a small change
15:47:02 <fen> Solonarv: sure, but like, supposing it is worth something, then what would the migration look like. probably thats actually part of the assessment 
15:47:04 <hpc> or it'll never get accepted
15:47:11 <fen> if its too jarring, it wont seem worth it
15:47:28 <hpc> and if it's separate, you want to minimize the amount of work you have to do to maintain it
15:47:41 <hpc> this is the whole point of modularity
15:47:48 <Solonarv> you can figure that out later, after you've ascertained that it's a worthwhile abstraction at al
15:48:05 <Solonarv> you seem to be very convinced that it is, but other people aren't!
15:48:08 <fen> Solonarv: the Semigroup proposal is good, as any factoring of classes into one function at a time is better in terms of modularity and composition
15:48:27 <fen> even would support just making Monoid a synonym of Semigroup and Default
15:48:35 <Welkin> you haven't see nthe dark side of "modularity" have you?
15:48:39 <Solonarv> and frankly you've not been doing a great job of explaining what your abstraction even is, let alone why it's worthwhile
15:48:41 <fen> but maybe there are arguments against that
15:48:41 <Welkin> take a look at npm
15:48:43 <hpc> you've just listed 3 completely unrelated changes
15:48:45 <Welkin> or at purescript
15:48:48 * Welkin shudders
15:49:27 <Welkin> the point of programming is to solve problems, to built things
15:49:37 <Welkin> the purpose is not to program
15:49:55 <fen> Solonarv: in terms of get and set as prelude classes? or of Traverse as a synonym of some parametrised version with this extra parameter restricted
15:49:58 <fen> ?
15:50:16 <Solonarv> I meant both of those things
15:50:39 <Solonarv> in fact I meant "whatever this thing you've been talking about for the past few months is"
15:50:52 <tobiasBora> fendor: thanks ;)
15:51:04 <tobiasBora> Also, it seems to work now! Great :D
15:51:09 <tobiasBora> thanks a lot everybody ;)
15:51:16 <fen> Solonarv: constantly working on different things almost by definition
15:51:20 <hpc> Welkin: npm has entirely different sins that are not about being "too modular"
15:51:30 <fendor> tobiasBora, kudos to you for porting it to a new ghc version! congrats!
15:51:57 <tobiasBora> Ok, still one thing to figure out: it compiles with nix, but not with stack... As I can't even download the lts-13.5 plan: AesonException "Error in $.packages.cassava.constraints.flags['bytestring--lt-0_10_4']: Invalid flag name: \"bytestring--lt-0_10_4\""
15:52:06 <fen> still like the justification in terms of enumerating instances of a higher level of abstraction to provide a more concrete api
15:52:34 <fen> ie, just implement get and set if thats how your traversable works, and get all the instances derived for you
15:52:57 <Welkin> hpc: it's still a huge problem
15:53:17 <fendor> tobiasBora, since it is stack, did you try stack clean? :D 
15:53:50 <tobiasBora> fendor: same error
15:53:51 <tsizz> Hi. I was wondering if anyone knows good beginner resource to learn haskell! any popular resource that is uusally recommended?
15:53:53 <fendor> tobiasBora, also, did you add extra-deps to stack.yaml?
15:54:06 <Solonarv> tobiasBora: if it's an error while downloading the snapshot, perhaps you might want to check that you have the latest stack version?
15:54:07 <tobiasBora> fendor: extra-deps: [ ]
15:54:07 <hpc> @where cis194
15:54:07 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
15:54:12 <Solonarv> should be 1.9.3 IIRC
15:54:13 <hpc> tsizz: ^ is good
15:54:27 <tsizz> hpc: thanks
15:54:31 <tsizz> is this a class on only haskell?
15:54:42 <fen> Solonarv: trying to get the fusion to work is a matter of perfection, to make it feasable to use the theoretical advances in the real world it cant suffer a performance hit. and this leads to some new and interesting things in terms of state encodings and zip fusion etc. it might be the best way of doing it, but its defiantly more recent than months that this has been approached. maybe even just a week 
15:54:59 <hpc> "CIS 194: Introduction to Haskell" - yep
15:55:18 <fen> so sorry but no, not agreeing this has gone on for ages, always the same, and is incompehensable and useless, as you seem to surgest
15:55:25 <tobiasBora> let's try to upgrade stack first
15:55:30 <Solonarv> no, I'm not suggesting that
15:55:42 <tobiasBora> same error
15:55:53 <fendor> tobiasBora, stack version is 1.9.3?
15:56:14 <Solonarv> I'm saying I can't see how useful it is or even exactly what it is, because it doesn't seem to exist anywhere other than your computer and a few 500-line pastes you link here occasionally
15:56:16 <tobiasBora> now really ^^ Version 1.4.0,
15:56:24 <tobiasBora> Don't even know how I installed it
15:56:30 <tobiasBora> let's upgrade by some way
15:56:36 <fen> also, this is a place to ask questions, not to explain justifications for why a particular approach should be considered... maybe
15:56:44 <tsizz> hpc: 194 class interesting
15:56:50 <Solonarv> Even a not-very-performant implementation would be helpful in figuring out the theory behind your approach
15:56:56 <tsizz> i'd think it would be later class but i guess it doesn't matter much
15:57:06 <fendor> tobiasBora, yeah, please reinstall or something, latest and greatest!
15:57:09 <hpc> well, the class has actually changed since then
15:57:13 <hpc> you'd just follow the material
15:57:32 <fen> if there is any "not explaining things properly" its just because of this constant questioning based on where questions exist, like, things that are not yet fully understood. but when they are understood there is code to be seen
15:58:00 <kadoban> tsizz: I recommend http://haskellbook.com/
15:58:13 <fen> and if its not completely documented thats just because the project isnt finished and thats a comestic thing to do with deployment, its not ready...
15:58:39 <tsizz> kadoban: not free tho D:
15:58:45 <tsizz> sorryi . should've mentioned that
15:58:59 <kadoban> There's ways to get free books on the internet *shrug*
15:59:03 <tsizz> can i write haskell in vim or is it not recommended
15:59:12 <tsizz> kadoban: wow right when u said that someone joined the channel calle pirate
15:59:16 <tsizz> lol
15:59:22 <Solonarv> vim is a perfectly suitable editor
15:59:53 <tsizz> Solonarv: ok do i just save as .hs file and then run?
15:59:55 <fen> Solonarv: im not sure what kind of thing you would like at this point
16:00:22 <hpc> tsizz: i write all my haskell in vim ;)
16:00:54 <Rembane> Me too. 
16:01:12 <Rembane> ghcid is a very good companion to vim.
16:01:32 <tsizz> do i just save as .hs
16:01:34 <tsizz> and run?
16:01:36 <Solonarv> fen: a github (or whatever you prefer) repo with code broken up into some sensible module hierarchy, some examples, some comments
16:02:03 <Rembane> tsizz: Yes. runghc MyModule.hs
16:02:04 <hpc> tsizz: so, lots of options there
16:02:06 <fen> this https://gist.github.com/fen-hs ?
16:02:17 <hpc> you can runghc foo.hs, and it'll execute main as defined in that file
16:02:24 <Solonarv> no, that's the collection of *all* your gists
16:02:30 <hpc> or you can compile it and run the generated executable
16:02:35 <fen> its just the current project
16:02:41 <hpc> or load it in ghci and interact with its definitions
16:02:42 <Welkin> you mean runGHC
16:02:47 <Welkin> RunGHC
16:03:15 <Solonarv> no, it's called runghc and non-windows systems tend to be case sensitive there
16:04:37 * hackage taskell 1.4.0.0 - A command-line kanban board/task manager  https://hackage.haskell.org/package/taskell-1.4.0.0 (smallhadroncollider)
16:04:45 <tsizz> hm it says u can run haskell interpreted or compiled
16:04:46 <fen> Solonarv: basically the approach is illustrated by https://gist.github.com/fen-hs/9772c2ce27a355984add2e5b7d352fbb#file-fifo-hs-L147
16:05:00 <fen> but it does not use all the fusion that it should... 
16:05:02 <tsizz> is any prefered
16:05:25 <hpc> tsizz: compiled is preferred
16:05:28 <Solonarv> if you're writing a program that actually does things it will usually be compiled
16:05:45 <hpc> we use cabal to make packages so things are easy to install and put the right files in the right locations
16:05:53 <c_wraith> compiled code runs faster, but compiling itself can be slow
16:06:09 <hpc> and some people use stack or nix to control their build environment
16:06:30 <hpc> none of that is necessary when you're learning the language though
16:06:53 <tsizz> hpc: yeah mines not gonna get that complicated.
16:06:58 <tsizz> and oh okay i have to download the compiler right
16:07:01 <fen> its welcome to be invited to demonstrate the idea, but frustrating if its maintained that such a demonstration does not exist.
16:07:19 <tsizz> whats "runhaskell"? is it compile then run in one command?
16:07:29 <hpc> runhaskell is an alias for runghc
16:07:33 <hpc> both of which run your code interpreted
16:07:46 <Solonarv> fen: ideally, I'd like a *single* repo that I can 'git clone' and play around in
16:08:01 <Solonarv> that's much less convenient with a bunch of gists
16:08:05 <j-walk> Hey, so I really don't understand why this happens
16:08:07 <fen> yeah, when its finished it will be deployed
16:08:13 <j-walk> return 1 2 -> 1
16:08:19 <tsizz> hpc: okay so i shoulld go ghc test.hs then ./test.hs
16:08:21 <kadoban> stack has a way to compile and run in one go, which can be nice when it's a simple thing but still needs to be optimized, or needs libraries.
16:08:25 <tsizz> rather than runhaskell or runghc?
16:08:48 <hpc> whatever is easier for you
16:08:48 <Solonarv> why isn't it in a git repo already? and if it is, why not just push that to github?
16:08:52 <tsizz> oh also ghc download is saying i need cabal.
16:08:58 <tsizz> so i guess i have to get it anyways
16:09:00 <fen> because its not finished!
16:09:14 <fen> there is no good at all distributing unstable code
16:09:21 <tsizz> oh wait nvm i dont have too
16:09:21 <Solonarv> git repos are not immutable!
16:09:42 <Solonarv> and you're already "distributing unstable code" by putting up those gists at all
16:09:49 <hpc> cabal isn't required, but you'll want it to use other libraries
16:09:53 <fen> yeah, but if when its issued its *done* then its much more convincing
16:09:57 <kadoban> gists can have multiple files in them. And gists also work as git repos, by the way.
16:10:10 <kadoban> You can clone, fetch, push, etc.
16:10:15 <fen> rather than "this and that caveat, oh its not done yet, oh it would be good if it did this as well" etc
16:10:23 <glguy> fen: git repositories are for when the code isn't done in particular
16:10:27 <hpc> feel free to skip it until you need it
16:10:45 <Solonarv> if it's done you can just toss a tarball/zip/whatever at people
16:10:56 <fen> right, then it goes on hackage
16:11:11 <tsizz> hpc: sorry im confused about downloading the ghc. it says cabal or distrubtion/binary packages and then source distribution. not sure which one i should download
16:11:18 <Solonarv> yes, when it's *done* (or at least in a usable state) it goes on hackage, which is append-only
16:11:24 <tsizz> i thought macs came with compilers o.O
16:11:57 <fen> but until then, the absence of a version you can clone renders it incomprehensible and beyond reasonable capability to asses or consider
16:11:58 <hpc> "source distribution" means you'd have to compile it yourself
16:12:13 <glguy> tsizz: You're trying to install GHC on a Mac?
16:12:15 <Solonarv> fen: yes, actually
16:12:21 <fen> fair
16:12:23 <hpc> you probably want the "binary package" for your OS, which is already compiled
16:12:36 <fen> so its not enough to read it, you want to be able to use it
16:12:43 <hpc> or whatever mac's package manager is, ghc might be available there
16:12:45 <fen> even if its just a default implementaion of traverse
16:12:46 <Solonarv> yes
16:12:55 <fen> because you dont know what that does
16:13:06 <hpc> like on linux, i can run "apt install ghc cabal-install"
16:13:12 <glguy> tsizz: Rather than figuring out how to install it, ghcup is a nice way to get everything installed and to switch versions if you want to do that in the future: https://www.haskell.org/ghcup/
16:13:55 <Solonarv> I want to load it into ghci, play around with it, see how it works, maybe generate haddocks and jump around in those, and so on
16:14:38 <fen> well if your going to do the haddocks then maybe it might be worth getting a version you can clone!
16:14:56 <fen> consider it added to the todo list
16:16:03 <Solonarv> yeah, if I actually understand what it's about then I might contribute too :D
16:16:19 <fen> i dont understand this process
16:16:32 <fen> is that where all the code gets deleted and replaced by dancing cats?
16:17:06 <tsizz> glguy: i sort of want to do it the legit way first haha
16:17:18 <tsizz> hpc: do i have to the installation make install part o.o
16:17:20 <Solonarv> nah, april fools is over already - no dancing cats!
16:17:45 <hpc> ghcup is perfectly fine
16:17:47 <glguy> tsizz: Manual isn't "legit" but certainly if it's fun go for it
16:18:24 <fen> i just dont want to see all kinds of lenses all about the place before it even fuses... seems reasonable
16:18:36 <Solonarv> although I wouldn't recommend building ghc from source: a) it takes a long time, and b) you need ghc to build ghc, so that doesn't actually allow you to skip grabbing a binary
16:18:37 <hpc> get programming first, imo
16:18:53 <fen> like, contributing and mangling could be different approaches 
16:18:56 <tsizz> its installing rn so we'll see
16:19:02 <tsizz> hpc: i think it installed cabal in the binary package
16:19:41 <tsizz> hpc: got my hello world! thanks 
16:19:44 <Solonarv> well, I can't change code in your repo without your approval (neither can anyone else), so you're safe from that :P
16:19:50 <hpc> nice
16:20:04 <tsizz> is the W in world capitalized hmm
16:20:26 <c_wraith> wow, https://github.com/goldfirere/ghc-proposals/blob/dynamic/proposals/0000-dynamic-types.rst is amazing. especially step 3 in section 2
16:20:39 <hpc> tsizz: that's the question that keeps me up at night :P
16:21:48 <fen> Solonarv: nah but if you clone it and then i try to read some plethora of ways it could have been done differently its not exactly the same as adhering to the approach thus far intended
16:22:59 <fen> really trying to keep from reading things that defeat the purpose, which is probably all a more experienced haskeller could contribute
16:23:02 <tsizz> hpc: hahaha for real!
16:23:20 <dmwit> tsizz: The only correct hello-world string is "Hello, world!". Hope that helps!
16:23:52 <glguy> What's the correct Hello-World string?
16:23:53 <tsizz> dmwit: https://en.wikipedia.org/wiki/%22Hello,_World!%22_program
16:23:55 <tsizz> but but but 
16:23:59 <tsizz> that W is capitalized :O
16:24:00 <fen> its a bit paradoxical, but this way might actually yield some good advances, and it would be worth not having that possibility trashed by getting overwhelmed with the complexity of someone elses approach
16:24:49 <fen> all this and more about why holding off from deploying until its actually done
16:25:55 <Solonarv> I'm not planning to overwhelm you
16:26:07 <glguy> If your goal is for no one else to understand your ideas you'd want to stop telling us about them
16:26:07 * hackage transformers 0.5.5.1 - Concrete functor and monad transformers  https://hackage.haskell.org/package/transformers-0.5.5.1 (RossPaterson)
16:26:10 <Solonarv> and if you get wall-of-texts thrown at you you can just reject them
16:26:15 <glguy> that will ensure you don't get feedback that changes your course
16:26:40 <dmwit> tsizz: Wikipedia is stupid and wrong. Hope that helps!
16:27:08 <glguy> dmwit: Time to go and edit wikipedia
16:27:37 * hackage approveapi 0.1.3.0 - ApproveAPI Haskell Client  https://hackage.haskell.org/package/approveapi-0.1.3.0 (kcking)
16:31:35 <tsizz> is there no list in haskell o.o
16:32:02 <Solonarv> sure there is:
16:32:07 <Solonarv> > [1, 2, 3]
16:32:09 <lambdabot>  [1,2,3]
16:33:12 <Solonarv> if you're following CIS194 as was recommended above they should be brought up quite early
16:33:51 <tsizz> hm okay i was just looking at my teachers slides as of now bc they're basic but will look there for more info
16:34:07 <tsizz> interesting that printing y = y + 1 gives you <<loop>> 
16:36:41 <hpc> tsizz: the mechanics behind it are very interesting indeed
16:37:57 <hpc> it's a good topic to revisit if you ever want to learn how the language is implemented
16:44:22 <Tuplanolla> We have secretly solved the halting problem, but keep it quiet in order to not upset anyone.
16:46:49 <hpc> sssssssh, we only talk about that in #haskell-illuminati
16:47:01 <Rembane> Tuplanolla: Did you see the new paper? Solving the halting problem considered harmful.
16:48:28 <Tuplanolla> Not if that's a real thing, Rembane.
16:49:05 <Rembane> Tuplanolla: It isn't. ^^
16:49:45 <Tuplanolla> I could see it being a rant against total domain-specific languages.
16:50:14 <Rembane> And the reply to that paper: Telling that the paper "Solving the halting problem considered harmful" isn't real considered harmful.
16:50:32 <Rembane> Tuplanolla: That would be fun. 
16:50:46 <hpc> one time i thought really hard about if solving the halting problem was good or bad
16:50:49 <hpc> in the end...
16:50:50 <hpc> i couldn't...
16:50:51 <hpc> decide
16:51:04 <hpc> https://www.youtube.com/watch?v=6YMPAH67f4o
16:51:32 <Rembane> hpc: You need a pair of sunglasses.
16:56:20 <Nevoic> Does anyone know why the first one here works but not the second? https://snippets.cacher.io/snippet/eca0fcf84db3fdc3eec7
16:57:36 <Solonarv> Nevoic: I think you forgot a comma in the second one?
16:57:45 <Solonarv> oh no you didn't, nvm
16:59:00 <Nevoic> https://cdn.discordapp.com/attachments/496210024498987009/562425523687653396/unknown.png 
16:59:01 <isovector1> any tips for debugging the mfix blues?
16:59:02 <Nevoic> There's more information
16:59:33 <Solonarv> oh right, I see the problem now
17:00:15 <isovector1> i've written a `MonadFix` instance that sorta works sometimes, but I can't wrap my mind around why it is bottom sometimes but not others
17:00:32 <Solonarv> 'foo ^? many . different . optics' parenthesizes as 'foo ^? (many . differnt . optics)'
17:01:08 <Solonarv> so you can't just "go deeper" by adding '. more . stuff' like you did there
17:01:19 <Nevoic> So why does the first one work the way I expect it to?
17:01:29 <Nevoic> I wrote exactly the same code for the ^? part
17:01:55 <Nevoic> Also the documentation shows that idiom, so I think that's the way to do it.
17:03:25 <Solonarv> if we inline the definition of 'r' and do some rearranging, we get the following:
17:03:25 <Solonarv> get (...) >>= \x -> return $ (x ^? responseBody . key "results" . nth 0) . key "name" . _String
17:03:56 <c_wraith> isovector1, all MonadFix instances will diverge sometimes. just the nature of the beast
17:04:27 <Solonarv> keep in mind that the . here isn't magical in any way; it's still just plain old function composition
17:04:42 <Nevoic> Solonarv: It looks like you're just talking about rewriting the second one the way I wrote the first one (while adding unnecessary parenthesis). What's the difference that I'm not seeing?
17:05:04 <Solonarv> those parentheses are not unnecessary, and they're the reason your second approach doesn't wor
17:05:31 <Nevoic> I'm talking about my first approach. You wrote identical code to my first approach, accept you added parenthesis that I don't have in my first approach.
17:05:34 <Nevoic> And my first one works.
17:05:40 <Nevoic> except you added*
17:05:43 <isovector1> c_wraith: fair enough. but do people have the ability to reason beforehand whether or not it will diverge?
17:05:51 <Solonarv> we have '(x ^? stuff) . moreStuff'
17:05:51 <Solonarv> vs.     'x ^? stuff . moreStuff'
17:05:55 <Solonarv> these are not the same!
17:06:07 <Nevoic> I know, but x ^? stuff . moreStuff works.
17:06:07 * hackage hw-hedgehog 0.1.0.3 - Extra hedgehog functionality  https://hackage.haskell.org/package/hw-hedgehog-0.1.0.3 (haskellworks)
17:06:09 <Nevoic> I tested it.
17:06:13 <Nevoic> It does what I want it to do.
17:06:23 <Solonarv> yes, I know. That's why your first approach works.
17:07:01 <Solonarv> but your second approach is equivalent to '(x ^? stuff) . moreStuff', which is incorrect
17:07:31 <Solonarv> note that 'x ^? stuff . moreStuff' is equivalent to 'x ^? (stuff . moreStuff)'
17:07:47 <Nevoic> Correct me if I'm wrong, but are you just telling me to disregard the second approach and just use the super repetitive first one?
17:08:03 <Nevoic> You proposed a solution that looked literally identical to me (except for a set of parenthesis).
17:08:06 <Solonarv> no, I'm trying to tell you why your second approach doesn't work
17:08:44 <Solonarv> I didn't propose a solution; 'get (...) >>= \x -> return $ (x ^? responseBody . key "results" . nth 0) . key "name" . _String' is exactly as broken as your second approach, because it's equivalent to your second approach
17:09:01 <Nevoic> Ah okay, that's what I misunderstood.
17:09:05 <Solonarv> those parentheses are not meaningless, they are why your second approach is broken
17:09:20 <Nevoic> Well I thought you were saying that was a working approach.
17:09:36 <Nevoic> So I misunderstood you. Is there any way to unparametize that?
17:09:51 <Nevoic> Or is there just no way to DRY up that code?
17:09:59 <Solonarv> yes, I'll put together my version
17:10:02 <Solonarv> gime a minute
17:10:56 <Nevoic> All I'm looking for is a way to capture the repetitive part in a variable, I'm kind of dumbfounded as to why `where` is not the way to do that.
17:10:56 <c_wraith> isovector1, hmm. I've never really thought it through. I use MonadFix so rarely, and when I do it's usually in a sanctioned manner.
17:11:31 <c_wraith> isovector1, ie, I do what the docs tell me, and don't worry about the theory. :)
17:11:47 <Nevoic> My guess is because assigning it to a variable (or having parenthesis there) causes the `>>= (bind)` action to execute and changes the value, but I thought I accounted for that by unwrapping it with `r>>=`
17:12:21 <Solonarv> Nevoic: https://gist.github.com/Solonarv/7b5cb1481e7d1effcc28f7061cdb864b
17:12:29 <isovector1> c_wraith: hah yeah. i'm in the same boat. but i am trying make a C++ EDSL that can define constants for how big arrays are. except that i need to output that before i know how big the arrays are. thus timetraveling thus monadfix
17:12:52 <isovector1> c_wraith: it doesn't feel like i'm breaking any causality here... but the runtime disagrees
17:13:06 <c_wraith> Nevoic, note that whenever you have (...) >>= return (...), you can use an fmap instead
17:13:45 <Nevoic> Sure that makes sense I guess, flat mapping the IO to the next one.
17:13:45 <Solonarv> (I used <&> in my example, which is a flipped infix version of fmap)
17:13:58 <Nevoic> Your version still gives a complaint Solonarv.
17:14:16 <Solonarv> Nevoic: yeah, I noticed that. reload th page, I think I fixed it
17:15:08 <Nevoic> Yeah it did. What does _Just do there?
17:15:24 <Nevoic> I don't want this to crash if the value doesn't exist, and it won't in the original functioning one.
17:15:36 <Solonarv> this won't either
17:15:56 <Solonarv> the type of r here is 'IO (Maybe _)' (I'm not sure what _ is)
17:16:39 <Solonarv> _Just works similar to _String, or _Integer
17:16:39 <Nevoic> How does <&> differ from & ?
17:17:19 <Solonarv> (<&>) :: Functor f => f a -> (a -> b) -> f b
17:17:19 <Solonarv> (&)   ::                a -> (a -> b) ->   b
17:18:07 <Nevoic> I've spent probably 35 hours reading about what a Applicative, Functor, and Monad are and I still have literally 0 idea what any of them are.
17:18:10 <Solonarv> & is "backwards function application", <&> is "backwards fmap"
17:18:24 <Nevoic> an Applicative*
17:18:44 <c_wraith> that's OK.
17:18:58 <c_wraith> they're not something you really get by reading.
17:19:09 <c_wraith> they make a lot more sense after a bunch of doing.
17:19:25 <dibblego> the data61 fp-course introduces it over the first day without mentioning it, then we do the Parser.hs exercise, where it becomes very clear
17:19:26 <c_wraith> it's OK to file them under "later"
17:19:34 <dibblego> I would recommend doing exercises
17:19:56 <dibblego> ex1 :: Num a => Maybe a -> Maybe a -> Maybe a -- add the two numbers in those Maybe values
17:20:34 <Nevoic> I've watched videos of Maybe/List and watched people try to tie them into what a Monad is, but a billion examples won't just teach me the abstraction.
17:20:48 <Nevoic> I might just lack the mental capacity to grasp it, which will make a good chunk of functional programming never understandable to me.
17:21:02 <dibblego> ex2 :: (String -> Int) -> (String -> Int) -> String -> Int -- given a String, calculate two Int values and then add them
17:21:22 <c_wraith> Nevoic, seriously worry less. it will come when you start *using* it.
17:21:29 <dibblego> I think teaching this stuff is very nuanced, and the student needs to be well-guided.
17:22:15 <Nevoic> c_wraith: I'm just not used to learning that way. I've been doing OOP type development for like 9 years, and I've been able to whenever I lack understanding of a concept, read about it for X number of hours and grasp it.
17:22:46 <c_wraith> I finally figured out what was going on when I was learning parsec, and discovered that I just... was able to do things. that worked. and suddenly I understood that the reason my knowledge transferred was the common interface
17:22:50 <Nevoic> It may take multiple hours, but I always come around to understand the concept in a way that makes sense in English, and that I can explain to people and have them follow to some degree.
17:22:51 <dibblego> if you have ever played chess, remember the day you learned how a knight moves on the board. You physically picked it up and counted out the squares. But now, you can do it with your eyes, several moves. It's the same process of practice and spotting patterns, then internalising them.
17:23:35 <Nevoic> Yes, but every step of the way I was never confused by how someone moved, it would just take me quite a bit longer to understand and put together what happened.
17:23:42 <c_wraith> Nevoic, be fair to yourself. nothing you've run into in oop languages has required so many new concepts at once, operating at a different level of abstraction than you're used to.
17:23:54 <dibblego> I can give you those same two exercises in java, if you prefer. They are the same point. You'll see the problem if we continue those exercises but you won't be able to solve it, because of java limitations.
17:23:57 <Nevoic> If someone uses the word "Functor", "Monad" or "Applicative", I just literally have no clue what's going on.
17:24:19 <dibblego> what if they use the word java.util.Comparator ?
17:24:58 <Nevoic> Most of my development experience is in Kotlin/Python/Ruby, but I'd understand the Java Comparator assuming it's like Comparable in Kotlin.
17:25:11 <dibblego> "an interface that exists so we don't have to repeat code. For example, we can sort a list of Comparator values, and we only have to write sort once."
17:25:35 <zachk> what if someone gave you, Nevoic,  a list of a lists, and they wanted a listed from it? 
17:25:52 <Nevoic> Are you talking about flatmapping?
17:25:55 <Nevoic> zachk
17:25:58 <dibblego> it's similar to Comparable in kotlin (and java). But it's more like Comparator in kotlin.
17:26:12 <zachk> Nevoic, yea pretty much 
17:26:23 <zachk> flatmap is like bind from Monads in haskell 
17:26:33 <Nevoic> dibblego It seems like you're talking about generalizing a problem, I understand Applicative, Monads and Functors are generalizations of specific problems.
17:26:33 <dibblego> I will write you a short haskell exercise if you like, to see the point
17:26:42 <dibblego> sdby
17:27:18 <zachk> > join [[1,2,3],[4,5,6]] 
17:27:20 <lambdabot>  [1,2,3,4,5,6]
17:27:23 <Nevoic> zachk I understand what bind does. I don't see how that's supposed to clarify what Applicative, Monads, or Functors are. Unless that's not what you're talking about.
17:27:25 <zachk> @type join 
17:27:26 <lambdabot> Monad m => m (m a) -> m a
17:27:50 <zachk> they are typeclasses in haskell, like interfaces from java 
17:28:31 <dmwit> I find "I understand what bind does but do not understand what Monad is" a puzzling juxtaposition. What more do you want to understand? Presumably it is not `return` that's tripping you up.
17:28:40 <Nevoic> Yeah, like I said earlier, I understand that they're generalizations of some sort. If I'm not mistaken, they're not *just* typeclasses from Haskell though.
17:28:53 <Nevoic> You can create a Monad in a language that doesn't have a `Monad` as long as it abides by the monadic laws.
17:29:04 <zachk> they are from category theory 
17:29:14 <Nevoic> Yeah, so they're not just typeclasses in haskell, like you seemed to imply.
17:29:18 <dibblego> the same way Comparator is a generalisation of some sort (just a different sort)
17:29:27 <zachk> in haskell they are just typeclasses 
17:29:32 <dibblego> here is a short exercise. https://gist.github.com/tonymorris/f6ea0ce12cfc8bab9803a844cafbbc27
17:29:41 <dmwit> Suppose we admit that they are not just typeclasses. Would you then feel satisfied that you understood them?
17:30:22 <Nevoic> I meant to say, they're more general than just existing in Haskell. Monads are not a haskell only thing.
17:30:26 <zachk> if you understand bind/flatmap , join, fmap/map and pure/return, I would say you have monads down pretty good then 
17:30:46 <Nevoic> I mean that's cool, except for the fact that I have no idea what a Monad is.
17:30:58 <dibblego> how would you fix that code repetition?
17:31:04 <Nevoic> Like if I said "You understand what bread, ketchup, and apples are. Therefor you understand what a buncharoa is"
17:31:11 <dmwit> A monad is a data structure that supports bind and return.
17:31:32 <dmwit> If a buncharoa was a combination of bread, ketchup, and apples, then it would be perfectly sensible to say that.
17:32:05 <Nevoic> Nope, a buncharoa is a generalization that supports many more things. It's just those are 3 examples of a buncharoa.
17:32:15 <dmwit> But bind is not an example of a monad.
17:32:19 <Nevoic> That's how Monads are generally explained to me. "If you understand Maybe, List, Bind, Flatmap, etc." then you understand Monads.
17:32:20 <dmwit> So the analogy fails.
17:32:35 <dmwit> Bind and flatmap are not types.
17:32:40 <dmwit> They are operations.
17:32:43 <Nevoic> dibblego I'm not sure, I'm not very well versed in haskell.
17:32:45 <dmwit> So not in the same class of objects as Maybe and List.
17:33:02 <Nevoic> Probably just use generics though.
17:33:31 <dibblego> would we do something like, "factor out the map functions?"
17:33:54 <fr33domlover> Q: I have a TVar containing a HashMap Text MVar. Inside atomically, I lookup a Text in the HashMap and then in IO I readMVar. Problem: What if between the STM transaction and readMVar, someone already wrote to the MVar, and other threads got the value and I missed it, and now I'm blocked on this MVar forever? Idea: Instead of MVar, use TMVar, and then in the STM transaction, I lookup in the HashMap, get a
17:33:56 <fr33domlover> TMVar and readTMVar it. But while I'm blocked on this TMVar, can other threads freely modify the HashMap, read from it, read from the same TMVar and write to it?
17:34:23 <dmwit> Yes they can.
17:34:40 <Solonarv> fr33domlover: I feel an urge to suggest stm-containers
17:35:21 <fr33domlover> Solonarv, well the stm hashmap there is just a hashmap of TVar iirc, or a hashmap in a TVar, so it doesn't change the situation :)
17:35:36 <Solonarv> IIRC it has a bunch of TVars at multiple levels, actually
17:35:53 <Nevoic> "bind" and "return" don't always mean the same thing that they do in Haskell.
17:36:24 <dibblego> Comparator for String does not mean the same thing as Comparator for Int
17:36:26 <dmwit> That is true. For the statement "a monad is a data structure that supports bind and return [subject to some laws]", you must read this sentence with the Haskell meanings of "bind" and "return" in your head.
17:36:45 <dibblego> oh yeah that too
17:37:05 <dmwit> But I think you are capable of doing that. =)
17:37:30 <fr33domlover> dmwit, hmm but am I protected from the case that after I grab the TMvar, someone writes to it before I have a chance to readTMvar (and then I'm possibly blocked forever?)
17:37:48 <dmwit> You are not protected from being blocked forever.
17:37:59 <dmwit> It is your responsibility to ensure that the TMVar gets filled eventually.
17:38:41 <dmwit> (Checking whether the TMVar gets filled eventually is surely undecidable, so no sound and complete static check can possibly exist.)
17:39:07 <Nevoic> Alright, I have what a Monad is in my head for now.
17:39:13 <dmwit> Yay!
17:39:19 <Nevoic> Are applicatives and functors more general?
17:39:23 <fr33domlover> dmwit, I do make sure it gets filled, I just mean is this possible: (1) I find the TMvar in the HashMap (2) someone else writes to the TMVar, and someone reads from it (3) I readTMvar, not knowing the write already happened and no other writes ever will OR does STM atomicity prevent that?
17:39:24 <Solonarv> it's undecidable in general, but it's certainly possible to decide often enough that trying is useful
17:39:30 <Solonarv> Nevoic: yes
17:39:33 <dmwit> Nevoic: All monads are applicatives, and all applicatives are functors.
17:39:56 <dibblego> all Comparators are Equality
17:39:56 <dmwit> Nevoic: There are functors which cannot be construde as applicative; and applicatives which cannot be construed as monads.
17:40:23 <Nevoic> Yeah, I got the second part of that from the first part.
17:40:33 <dmwit> fr33domlover: STM atomicity does not prevent it.
17:40:42 <dibblego> there are Equality things which are not Comparable (e.g. complex numbers)
17:40:53 <luftmensch[m]> I get the definition of Monads and all that but it’s still helpful for me to think: a monad is a function, but instead of returning a value it acts like a box
17:41:21 <dmwit> Yikes, but that's untrue and... really misleading. A monad is not a function.
17:42:02 <dmwit> There are many monads which are function-like (we even have the Representable class for them), but many that are really not.
17:42:27 <Solonarv> rather, "function" is an example of a monad, alongside e.g. list, maybe, ...
17:42:33 <Squarism> Say i have a multi module stack project. If i have a non-stackage dependency i need to specify the version of it in stack.yaml files in all the separate submodules of my project. Is there some mechanism to fix this annoyance? Like some base/parent stack.yaml?
17:42:33 <luftmensch[m]> Everything in haskell is a function
17:42:39 <Solonarv> luftmensch[m]: no!
17:42:40 <dmwit> This, too, is untrue.
17:42:42 <Nevoic> Do monads need to specifically support a function of type :: m a -> (a -> m b) -> m b? Meaning :: m a -> (a ->b) -> m b wouldn't be a monad?
17:43:11 <Solonarv> correct
17:43:22 <fr33domlover> dmwit, hmmm I see, thanks. I actually found something interesting: It seems that unlike with MVar, if you use readTMVar then the TVar says full forever (until someone does takeMVar, but in my case nobody does). So, even if someone writes and someone else reads the MVar seems to still stay full, waiting safely until I readMVar and get the value too?
17:43:29 <dmwit> Nevoic: Correct. The second type you gave is what is required of Functors.
17:43:50 <dmwit> fr33domlover: Normal MVar also offers readMVar.
17:43:51 <Nevoic> So all monads need to have :: m a -> (a -> b) -> mb then? Because all monads are functors.
17:43:52 <fr33domlover> *the TMvar seems to still stay full
17:43:55 <dmwit> fr33domlover: Which leaves the MVar full.
17:44:07 <dmwit> fr33domlover: But yes, readTMVar does not empty the MVar.
17:44:17 <dmwit> *does not empty the TMVar.
17:44:20 <Solonarv> fr33domlover: readTMVar var = do x <- takeTMVar; putTMVar var x; return x
17:44:21 <dibblego> Nevoic: yes all monads (call an example of one: m) must support (m a -> (a -> m b) -> m b) as well as a few other things
17:44:25 <Solonarv> (and similar for MVar)
17:44:31 <dmwit> fr33domlover: If you *want* to empty the TMVar, you can use takeTMVar for that. (Similarly for MVar.)
17:44:39 <Solonarv> luftmensch[m]: http://conal.net/blog/posts/everything-is-a-function-in-haskell
17:44:46 <dmwit> Nevoic: Correct.
17:44:56 <fr33domlover> dmwit, hmm I thought readMVar is only instant wakeup, like, it wakes whoever is waiting on it but then empties the MVar?
17:45:00 <dmwit> Nevoic: And indeed, if you have bind and return, then you can build a function of that type out of them.
17:45:00 <dibblego> similarly all Comparator values (call an example: c) must support (c -> c -> Ordering) as well as a few others things (e.g. swapping the two c values swaps the Ordering)
17:45:02 <Nevoic> well the question was about m a -> (a -> b) -> m b not m a (a -> m b) -> m b
17:45:06 <adamCS> Nevoic: Sometimes it's easier to think about Monads needing to have join :: m (m a) -> m a. bind is just join . fmap.  And join can be more intuitive.  For lists, join is concat.  For Maybe it's the obvious (Maybe (Maybe a)) -> Maybe a. And so on.  
17:45:09 <fr33domlover> (While readTMvar leaves the Mvar full when it's done)
17:45:16 <dmwit> fr33domlover: takeMVar empties the MVar. readMVar does not.
17:45:30 <dibblego> Nevoic: ok, so since a monad (m) also supports (a -> m a), it also by implication, supports (m a -> (a -> b) -> m b)
17:46:10 <Solonarv> Nevoic: if you can write 'm a -> (a -> b) -> m b', then m is a functor.
17:46:10 <Solonarv> if you can *also* write 'm a -> (a -> m b) -> m b', then m is also a monad
17:46:38 <dmwit> (monads need both m a -> (a -> m b) -> m b and also a -> m a)
17:46:47 <Nevoic> Yeah, alright that makes sense.
17:46:52 * fr33domlover tries in GHCi
17:46:54 <dmwit> :t (>>=)
17:46:54 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:46:55 <dmwit> :t return
17:46:56 <lambdabot> Monad m => a -> m a
17:47:08 <dmwit> :t \f m -> m >>= return . f
17:47:09 <lambdabot> Monad m => (a -> b) -> m a -> m b
17:47:30 <dmwit> Nevoic: ^ This shows how to implement your `(a -> b) -> m a -> m b` out of the pieces that Monad requires.
17:47:56 <Nevoic> Cool! So the only piece I don't have in my head right now is Applicatives.
17:48:08 <Nevoic> I'll surely lose all this information in like 30 minutes after I stop thinking about it, but that's just how it is.
17:48:13 <dmwit> :t (<*>)
17:48:14 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
17:48:22 <dmwit> Applicative requires this operation together with return.
17:48:27 <dmwit> There is nothing more to understand about them.
17:48:38 <dmwit> (Okay, *that* is a lie. =D)
17:48:52 <dmwit> Besides the laws, there is nothing more to the *definition* of them.
17:49:06 <Nevoic> Applicatives require a -> m a?
17:49:11 <dmwit> yes
17:49:25 <Solonarv> yes (it's called 'pure' in the actual definition)
17:49:49 <Solonarv> and this must be identical to the corresponding 'return :: a -> m a' from monad
17:50:13 <Nevoic> I don't really understand the definition tbh.
17:50:17 <Nevoic> "Applicative f => f (a -> b) -> f a -> f b"
17:50:37 <Nevoic> Is that saying an Applicative f is a type where you can call that function?
17:50:44 <dmwit> Yes.
17:51:18 <Nevoic> What's the function's name?
17:51:23 <dmwit> (<*>)
17:51:43 <Nevoic> Oh okay.
17:51:44 <dmwit> Or, you may pronounce it "ap" if you are feeling retro.
17:51:46 <dmrd_> hey folks, for those of you that use `hpack`, is it ever a good idea to have nexted `package.yaml` files?
17:51:49 <Nevoic> Is it an infix function normally?
17:51:53 <dmwit> Yes.
17:53:03 <dmwit> :t \f m -> pure f <*> m
17:53:04 <lambdabot> Applicative f => (a -> b) -> f a -> f b
17:53:21 <dmwit> ^ this shows how to implement your `(a -> b) -> m a -> m b` out of the pieces that Applicative requires. =)
17:53:37 <Nevoic> The functor requirement?
17:53:44 <Solonarv> yup
17:54:14 <fr33domlover> dmwit, oh I see now! So when you putMVar and other threads readMVar, it still stays full after that ^_^ Hmm I suppose I can just use the regular MVar then, or TMVar, getting the same behavior I suppose
17:54:15 <dmwit> :t \mf mx -> mf >>= \f -> mx >>= \x -> return (f x)
17:54:16 <lambdabot> Monad m => m (t -> b) -> m t -> m b
17:54:16 <Nevoic> Hmm, well thanks for the tips guys, I'm going to brb for some food.
17:54:30 <dmwit> ^ This shows how to implement Applicative's requirement out of the pieces that Monad requires.
17:55:06 <luftmensch[m]> Solonarv: I happily fall into the “blame Church” school because it is useful for making sense of the syntax. Even if it’s not implemented as pure lambda calc (which it could be, hypothetically), the monad notation, m a, is exactly the same as the notation function application, f a, for good reasons
17:55:07 <dmwit> fr33domlover: If you only `putMVar` once, and forever after `readMVar`, then perhaps boring old `TVar` is enough for you...?
17:55:49 <dmwit> luftmensch[m]: But those two notations are from completely different languages!
17:56:03 <Solonarv> luftmensch[m]: "hello" isn't a function in Haskell, and neither is 5 or (3, reverse, "hello")
17:56:09 <dmwit> The `m a` that you see in monad-y type signatures is a type-level application, while the `f a` of computation is term-level.
17:56:25 <Welkin> `hello` can be a function!
17:56:28 <dmwit> Or... like... I guess I just have no idea what your point is.
17:56:38 <Welkin> in lambda calculus, everything is functions
17:56:46 <dmwit> Haskell is not lambda calculus.
17:56:47 <Welkin> True is const
17:56:51 <Welkin> False is flip const
17:56:52 <Welkin> :D
17:57:02 <Welkin> build your church encoded integers
17:57:17 <dmwit> And even in lambda calculus what you say is not necessarily true. Having base types is perfectly fine in lambda calculus if you set it up appropriately.
17:57:58 <fr33domlover> dmwit, hmm I'd love to use plain TVar! But how do I do that: When I find that MVar in the HashMap, it means there's a thread running, and when I readMVar, I'm waiting for the thread to finish working and putMVar so that I can get that value
17:58:01 <Solonarv> ...in fact, that's what GHC Core is: a typed lambda calculus extended with some base types
17:58:23 <dmwit> fr33domlover: Oh, so that's what you're doing!
17:58:59 <dmwit> Then TMVar seems perfectly reasonable to me.
17:59:57 <fr33domlover> dmwit, any arguments for MVar vs TMVar? I already have a piece of code like this where I use MVar, but, I'm still not sure which one is better :P
18:00:24 <fr33domlover> (The HashMap lives in a TVar either way, the question is do the HashMap values live in MVars or TMVars)
18:00:46 <Solonarv> it makes more sense to stay fully in STM, IMO
18:00:49 <dmwit> I recommend TMVar. Since you don't expect a lot of contention, it will likely be faster.
18:02:09 <dmwit> Also you get for free the guarantee that nobody modifies the hashmap after you read it but before you read the MVar, though I'm guessing that's not an issue for you.
18:02:51 <fr33domlover> dmwit, thanks. Last question hopefully: In the case the TMvar doesn't exist in the HashMap, I insert a new one (and I also need to launch the helper thread, so I need IO). But due to atomicity, does it mean I need to update the HashMap main TVar in 1 transaction and then readTMVar in another transaction? Otherwise the HashMap can't be concurrently modified until I finish readTMvar?
18:03:20 <fr33domlover> And if that's true, then I have to get out of STM anyway (I guess either way I must because I need to forkIO before I readTMvar)
18:04:08 <Solonarv> well, you could have a helper thread with which you communicate using some sort of channel, and which does forking for you
18:04:45 <dmwit> Oh, very good idea!
18:05:22 <dmwit> Hm, you still need to end the transaction for it to see the message, though.
18:05:36 <dmwit> So I think no choice but to have two transactions in case there's a forkIO needed.
18:05:44 <fr33domlover> Solonarv, hmmm good idea ^_^ but if I writeTvar (i.e. update the HashMap) and then readTMvar in the same transaction, while I wait for my value, can other threads update that HashMap, and do they see my update when they read it?
18:05:48 <Solonarv> hm
18:05:57 <fr33domlover> Because if no, I need them in sepsrate transactions
18:05:58 <Solonarv> dmwit: good point, I hadn't thought of that
18:06:20 <dmwit> Are you *sure* you don't just want to use async for all this?
18:06:42 <dmwit> ...actually, hm, it's not clear that solves any of these annoying issues.
18:06:44 <dmwit> Never mind. =P
18:07:36 <fr33domlover> dmwit, oh I'd love to! But that HashMap protects concurrent access to some shared database stuff, that's why there's a single helper thread per Text. Without that requirement, I'd happily use async ^_^
18:08:56 <fr33domlover> Solonarv, dmwit, just to be sure: In STM transactions, they are done atomically at once, right? So other threads see their changes only when they finish?
18:09:25 <fr33domlover> (Much like committing a transaction in SQL?)
18:11:04 <Nevoic> Do functors have to be parameterized over a generic?
18:11:44 <Nevoic> I would imagine so, a type that's parameterized by a concrete type couldn't describe fmap.
18:21:31 <johnw> is it possible to have an associated kind family? how would I declare that? type Foo m :: ?
18:22:17 <Solonarv> johnw: kinds and types are the same now, so it's exactly like an associated type family
18:22:24 <johnw> ok
18:24:57 <johnw> I'm trying to do this:
18:24:58 <johnw>   data MState s a b :: *
18:24:59 <johnw>   type MTransition s a b :: MState s a b -> MState s a b -> Constraint
18:25:13 <johnw> but it says it can't because it's in the same recursive group
18:29:11 <johnw> in general I'm finding it hard to declare an associated data family whose kind is that of an associated type (kind) family
18:30:08 <johnw> ah, I found something
18:42:30 <johnw> I guess what I really want here is the ability to have both type class methods, and type class type functions
18:42:38 <johnw> where the methods are defined using the type functions
18:42:52 <johnw> (the type of the methods, that is)
18:42:53 <dmwit> fr33domlover: right
18:42:58 <dmwit> Nevoic: right
18:43:03 <Solonarv> I took a stab at the "helper thread to fork from within an STM transaction" thing: https://gist.github.com/Solonarv/1389de7031ad858035096dadb02956e4
18:43:20 <Solonarv> fr33domlover, dmwit ^
18:43:51 <Solonarv> you do indeed have to wait for the current transaction to complete, though
18:44:24 <Solonarv> * before doing anything with the newly forked thread
18:46:30 <dmwit> Yep. Cakes and eating, etc.
18:47:19 <Solonarv> I guess you could use unsafeIOToSTM if you don't mind potentially forking more often than you actually wanted to
18:48:16 <Solonarv> (and dropping the "extra" threads on the floor; you won't ever be able to cancel them)
18:48:36 <Solonarv> so, uh, probably not a good idea!
18:50:02 <Solonarv> (the takeTMVar should probably be a readTMVar, though)
18:55:13 <fr33domlover> Solonarv, I guess it can be also extended to trigger any IO via an STM queue
18:55:22 <Solonarv> yeah
18:55:24 <fr33domlover> I'll remember this idea ^_^
18:58:05 <luftmensch[m]> Back from my walk and I’m not convinced.
18:58:05 <luftmensch[m]> Despite the pedantic naysayers, it can be very helpful to think of everything in Haskell as a function. Besides some syntactic sugar here and there, a lot of times you start to make sense of unfamiliar patterns.
18:59:07 * hackage transformers-compat 0.6.4 - A small compatibility shim for the transformers library  https://hackage.haskell.org/package/transformers-compat-0.6.4 (ryanglscott)
18:59:57 <luftmensch[m]> Back from my walk and I’m not convinced. Despite the pedantic naysayers, it can be very helpful to think of everything in Haskell as a function. Besides some syntactic sugar here and there, a lot of times just following the rules of function application helps you start to make sense of unfamiliar patterns.
19:04:39 <Welkin> everything is an *expression*
19:04:42 <Welkin> but not everything is a function
19:06:18 <c_wraith> not even everything is an expression.  :)
19:06:36 <c_wraith> there's a whole family of declarations!
19:06:46 <Welkin> what you may be talking about is the fact that functions are values, like any other value, and they are all automatically curried
19:07:12 <Welkin> c_wraith: executable code, not compile-time-only constructs like pragmas and type declarations
19:11:07 <Squarism> What is a good object serialization format. Ive tried json but it seems Aeson changes now and then. Stability of format would be the important faktor.
19:11:23 <Squarism> "show" is a bit too verbose
19:13:11 <Welkin> gltf
19:13:21 <Welkin> obj is really basic
19:13:23 <Welkin> some people use fbx
19:15:33 <Solonarv> cbor, maybe? there's a library for it
19:16:10 <johnw> finally got something working: https://github.com/jwiegley/notes/blob/master/haskell/Mealy.hs
19:16:19 <Solonarv> whoa, there are a lot of serialization libraries on hackage
19:17:23 <Welkin> imagine is haskell was homoiconic
19:17:27 <Welkin> if*
19:18:00 <Solonarv> @hackage serialise seems promising
19:18:00 <lambdabot> http://hackage.haskell.org/package/serialise seems promising
19:18:40 <Welkin> the thing about json is that is compresses very well
19:18:42 <Welkin> it*
19:25:24 <Cale> Welkin: It kind of is, if you treat the definition of homoiconic very broadly, via template haskell.
19:28:33 <Nevoic> Does anyone know why I can't map a Vector of Aeson Values to Integers?
19:28:48 <Nevoic> I can transform a single Aeson Value into an integer like so: x . _Integer
19:29:12 <Nevoic> But this: map (. _Integer) vecOfValues
19:29:12 <Nevoic> doesn't work
19:29:33 <Cale> Are you sure about that first bit?
19:29:55 <Cale> _Integer looks like a prism, and if it was, you wouldn't be able to apply it like that
19:30:10 <Nevoic> Idk what a prism is tbh.
19:30:23 <Nevoic> But you're right, it is a prism.
19:30:28 <Nevoic> I just don't know what that means.
19:31:09 <Nevoic> key returns a Traversal ' Value
19:31:09 <Cale> Prisms are a sort of generalisation of lenses such that the thing can fail to match.
19:31:26 <Nevoic> I call key "stringName" . _Integer
19:31:32 <Nevoic> And that works as I expect.
19:32:00 <Nevoic> Now I have a Vector of Value (not Traversal' Value, whatever the christ that means lol) and I can't seem to map it.
19:32:09 <Nevoic> In pretty much every language I've worked in to date, you can take an iterable, and map it.
19:32:18 <Solonarv> Nevoic: by chaining together a bunch of things with (.), you describe a "path" through your data structure
19:32:24 <Nevoic> Unless I'm severely misunderstanding what a vector or a value is, I'm entirely lost.
19:32:47 <Solonarv> you can use this path using functions/operators like ^. ^? ^.. .~ and so on
19:32:49 <Cale> Nevoic: In the end, you're applying those things probably with the ^? operation?
19:33:05 <Nevoic> Na.
19:33:49 <Nevoic> So is it wrong of me to think of a Vector of Values as an iterable that I can perform standard higher order functions on?
19:33:55 <Cale> Well, how are you actually making use of the traversal/lens you're building?
19:34:13 <Nevoic> Does that actually matter for what I'm trying to do? I'm not looking for a simpler solution, I'm looking to do this exact 1 thing.
19:34:45 <Solonarv> it matters because you seem to be under the impression that . "applies" a traversal/lens/whatever
19:34:46 <Nevoic> I prefer to write code the way I see it and then learn the hardships of that, instead of someone just telling me the best way to write Haskell.
19:34:49 <Cale> You can certainly do that, the confusing/advanced part of what you're doing is that you're manipulating these constructions that let you both view and replace deeper parts of data structures
19:35:01 <Solonarv> it doesn't; it *combines* two traversals/lenses/whatever to make a new one
19:35:03 <Nevoic> I'm not looking to replace any part of the data structure.
19:35:04 <Cale> The (.) operator is function composition
19:35:40 <Cale> and you're composing together functions which basically let you act in fairly general ways on pieces of individual structures
19:35:42 <Nevoic> I'm simply trying to read nested JSON.
19:35:51 <Solonarv> a Vector is not an optic, so combining it with an optic doesn't make much sense
19:36:04 <Solonarv> the optic for "every element in a vector" is 'each'
19:36:05 <Cale> If I were you, I'd probably start out by simply pattern matching on Values
19:36:16 <Squarism> Welkin, thanks!
19:36:39 <Solonarv> % :t each @Vector . _Integer
19:36:39 <yahb> Solonarv: ; <interactive>:1:7: error: Not in scope: type constructor or class `Vector'
19:36:42 <Nevoic> I don't know what an optic is either.
19:36:42 <Cale> But we can surely do it this way. What have you got working thus far?
19:37:07 <Solonarv> "optic" is the catch-all term for lenses, traversals, prisms, and so on
19:37:14 <Nevoic> Well I can successfully go x levels deep (either through a JSON object or array) and get whatever single values I want.
19:37:23 <Cale> We're using fancy machinery that will make the expressions for digging around through Aeson Values short and pretty, but is also very general, and tbh, a bit hard to comprehend at first.
19:37:33 <Nevoic> But now (like 3 levels deep or so) I want a specific entire iterable.
19:37:34 <Cale> Nevoic: So how do you do that?
19:37:46 <Nevoic> wreq.
19:37:54 <Nevoic> And Aeson.
19:38:16 <Cale> (In particular, I'm trying to figure out what you're doing with the (key "stringName" . _Integer)
19:38:18 <Cale> )
19:38:42 <Nevoic> Well that part is working the way I expect it to, but retrieving a value and turning it into an Integer.
19:38:56 <Cale> What's the rest of the line of code that piece of text sits on?
19:39:17 <Cale> i.e. how are you actually applying it to your Value?
19:39:22 <Cale> view?
19:39:36 <Nevoic> r <&> preview (_Just . key "id . _Integer)
19:39:46 <Nevoic> "id"*
19:40:37 <Cale> That's pretty fancy, but okay
19:40:49 <Cale> What's the type of r?
19:40:55 <Nevoic> Yeah, I had a version that was similar but wasn't functional, someone on here helped me with it.
19:41:00 <Solonarv> (that was me)
19:41:05 <Cale> jeez
19:41:07 <Cale> lol
19:41:08 <Solonarv> r :: IO (Maybe something)
19:41:10 <Cale> okay
19:41:20 <Nevoic> Mine was like r >>= \x -> (x . key "id" . _integer)
19:41:29 <Cale> Why the heck use the weird backwards <&> thing?
19:41:32 <Cale> anyway
19:41:35 <Nevoic> I couldn't tell you.
19:41:45 <Cale> Let's just use a do-block, get the result of our IO action first
19:41:57 <Solonarv> I chose it to keep with the order-of-operations that's usually used in lens
19:41:58 <Cale> and *then* consider pulling it apart with preview
19:42:10 <Nevoic> I'm trying to return an IO here, not unwrap it.
19:42:17 <Cale> That's okay
19:42:26 <deech> Does GHC have something like an 'INFO' pragma? I want to pass along a message to the user that they might not want to use some function but don't want it flagged as a warning in case they have warnings-as-errors turned on.
19:42:28 <Cale> If you use a do-block to execute an IO action, the do-block as a whole is an IO action
19:43:03 <Nevoic> Alright, that makes sense, but the do syntax is pretty imperative looking as well.
19:43:14 <Nevoic> I'm not a huge fan of it.
19:43:22 <Solonarv> deech: I don't think so; your best bet is to put a big bold "CAREFUL: whatever" in the documentation
19:43:30 <Cale> It's totally okay. I promise :D
19:44:05 <monochrom> haha did you see that "Python 5" post on reddit /r/haskell ?
19:44:08 <Nevoic> Can't we just unwrap whatever value you're talking about unwrapping with >>= or even just fmaping it?
19:44:10 <Cale> It's designed to look a bit imperative, but it's less imperative than it looks.
19:44:26 <Cale> Sure, do-notation is just a shorthand for chains of (>>=)'s
19:44:48 <Cale> It's just that chains of (>>=) get a bit tedious to write after a while and they're harder to read
19:45:05 <Cale> But anyway
19:45:09 <Nevoic> That's fair. Is there something about refactoring the rest of this code that'll make it easier to map this iterable?
19:45:18 <dmwit> deech: There is the ANN pragma.
19:45:31 <Cale> Well, I want it to be more clear exactly what we're doing
19:45:50 <dmwit> deech: I don't think those pragmas are displayed to users, though; it's intended more for machine consumption.
19:46:35 <Cale> do mv <- r -- here, we'll run the r :: IO (Maybe something), obtaining some mv :: Maybe something
19:47:06 <Cale> You might have a better name for mv in the context of your program...
19:47:08 <deech> dmwit: Oh wow, I don't even see docs for that https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pragmas.
19:47:13 <Nevoic> The type of my method is: searchForActor :: String -> (IO (Maybe Text), IO (Maybe Integer), IO (Maybe [Integer]))
19:47:13 <Nevoic> so it's doing quite a bit more than just grabbing a single value, btw.
19:47:28 <Cale> whoa
19:47:29 <Nevoic> Then in main I'm destructuring those arguments.
19:47:38 <Cale> are you really meaning to return three separate actions?
19:47:43 <Nevoic> Yeah.
19:47:52 <Nevoic> I don't necessarily execute them all.
19:47:56 <Cale> okay, okay
19:48:38 <Cale> So, now we can use preview to apply our Traversal to mv
19:48:54 <Cale> That's what your code was doing already
19:50:28 <Cale> preview (_Just . key "id" . _Integer) mv   will have type Maybe Integer
19:51:56 <Cale> (though tbh, I would totally use a case expression instead, and I've been programming in Haskell for well over a decade)
19:52:54 <Cale> We can Vector.map (preview (_Just . key "id" . _Integer)) over a Vector of (Maybe Value)
19:53:10 <Cale> and obtain a Vector of Maybe Integers
19:53:48 <Nevoic> That's the part I was not able to do. Wouldn't you need to do Vec.map (preview (_Just . key "id" ._Integer)) values ?
19:53:52 <dmwit> deech: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/extending_ghc.html#source-annotations
19:54:09 <Cale> yeah, that's exactly what you'd do
19:54:25 <Cale> Is that not what you have?
19:54:32 <Cale> What does your Vector contain?
19:54:44 <Nevoic> Values.
19:54:46 <dmwit> monochrom: That typing sound effect that doesn't quite line up with the actual typing is really distracting.
19:55:29 <monochrom> I think it's part of the joke.
19:55:31 <Cale> Well, you can remove the _Just bit
19:55:49 <Cale> and that'll turn a Vector Value into a Vector (Maybe Integer)
19:56:06 <monochrom> like, misinterpreting "static typing" to "background typewriter noise"
19:56:26 <Nevoic> And that's not exactly what I was trying to do either. I'm actually pulling the vector of values out, not just mapping an already known quantity.
19:56:40 <Nevoic> That's why earlier I said that line (with the key "id" . _Integer) already did what I wanted.
19:57:09 <Nevoic>   map (. _Integer) (r <&> preview (_Just . key "known_for" . _Array))
19:57:09 <Nevoic> That's the line that doesn't do what I'd expect.
19:57:31 <Cale> Okay, let's start over and just do things how I'd expect, since this is nearly incomprehensible
19:58:37 <Nevoic> I mean just to be clear, r <&> preview (_Just . key "known_for" . _Array)) is fine, it does what I expect.
19:58:48 <Nevoic> I'll probably refactor it, but I'd like to do that at my own pace so I actually know what's happening.
19:58:53 <Cale> okay
19:59:21 <Cale> So, I think your problem is firstly that this whole thing is still an IO action
19:59:27 <Cale> (r <&> preview (_Just . key "known_for" . _Array))
19:59:32 <Cale> is an IO action, not a vector
19:59:41 <Cale> so you can't just use a Vector.map over it
20:00:00 <Nevoic> Ohh
20:00:42 <Nevoic>   r <&> preview (_Just . key "known_for" . _Array & map (. _Integer))
20:00:42 <Nevoic> Just tried that too.
20:00:42 <Cale> That's point 1. Secondly, even if you take its result, which will be a Maybe (Vector Value), I think
20:00:50 <dmwit> monochrom: ...ouch
20:01:02 <Cale> and let's say you get through the Maybe as well
20:01:21 <Cale> then you still don't have a Vector full of functions that you can compose _Integer with
20:01:29 <Cale> So, yeah
20:01:37 <Nevoic> I want it to be an IO (Maybe [Integer])
20:01:50 <Nevoic> It's currently an IO (Vector Value)
20:02:11 <Nevoic> i.e I want to take the vector of values, and convert them to possible integers.
20:02:14 <Nevoic> Via _Integer
20:02:44 <Nevoic> I successfully converted a IO (Value) into an IO (Maybe Integer) so I figured it was in the realm of possibility.
20:02:57 <Nevoic> an IO *
20:03:25 <glguy> Nevoic: focus on writing a function with type "Vector Value -> Maybe [Integer]" and you can always fmap that function to make it work on IO later
20:04:03 <Nevoic> So there isn't a function that already does that?
20:06:08 <Nevoic> I've done JSON parsing in a number of other languages. Kotlin, Scala, Python, Ruby, Java, Swift, Rust. A number of them have an untyped concept similar to `value`, and an Option concept similar to `Maybe`, and generally it's not at all hard to take a deeply nested value, say an array of JSONObjects, and then map those JSONObjects to the respective 
20:06:08 <Nevoic> value that I want.
20:06:57 <Nevoic> And making that an optional is pretty easy too, like in a null safe language (Kotlin) turning it into null if it doesn't exist or not null if it does, which is pretty much like Just and Nothing in Haskell.
20:07:01 <Cale> Yeah, it's not all that hard here either, you're just... choosing to use a really fancy library to do it.
20:07:24 <Cale> I'd probably just use Aeson's Parser directly.
20:07:28 <Nevoic> I chose wreq and aeson specifically because they were both the least fancy/most front end user friendly I could find.
20:07:32 <Nevoic> I spent like 10 minutes looking too.
20:07:34 <Cale> aeson is good enough
20:07:42 <Cale> It's the lens-aeson stuff that's fancy
20:08:07 <glguy> What's the actual shape of the JSON data you're working with? Did I miss that? (lots of backlog)
20:08:15 <Cale> That's like, off-the-deep-end profunctor optics shenanigans, just to pick apart some data
20:08:39 <Nevoic> I can probably do this in like 2 minutes in a Python repl tbh.
20:08:43 <Nevoic> Just to show you guys what I want.
20:08:48 <Cale> You *can* do it that way, if you try hard enough, it's just going to be insane
20:08:52 <Cale> Just show us the JSON
20:08:59 <Cale> and what result you want
20:09:15 <Cale> and I'll do it with only Aeson
20:12:06 <Cale> and explain my code
20:12:29 <Cale> I guarantee it won't be too hard. :P
20:12:50 <Nevoic> https://snippets.cacher.io/snippet/89099f6f06bd727fb9e6
20:15:15 <glguy> and which Integers are you trying to extract?
20:15:18 <Cale> okay, and so we want which values out of here?
20:15:58 <Welkin> show me the money!
20:16:51 <Nevoic> Here's the Python (just made it):
20:16:53 <Nevoic> movies = jObj["results"][0]["known_for"]
20:16:53 <Nevoic> ids = [movie["id"] for movie in movies]
20:17:08 <Nevoic> I just need the ids.
20:17:40 <Welkin> use `at`
20:17:50 <Nevoic> It doesn't handle the null case, and I don't like that, it shouldn't crash when the value doesn't exist.
20:17:59 <Nevoic> But I just made it to show you guys what I was looking for.
20:18:22 <glguy> toListOf (key "results" . _Array . ix 0 . key "known_for" . values . key "id") val
20:18:22 <glguy> [Number 70160.0,Number 101299.0,Number 131631.0]
20:18:23 <Welkin> well if it's nullable then it has to be Maybe
20:18:28 <Welkin> no way around it
20:19:03 <glguy> That's the "fancy lens-aeson way"
20:19:03 <Nevoic> What does "ix" do?
20:19:16 <glguy> indexes the array at position 0 like you did in your first line
20:19:32 <Nevoic> Ah. Never seen "index" referred to as ix.
20:19:34 <glguy> Oh, there's a shortcut: toListOf (key "results" . nth 0 . key "known_for" . values . key "id") val
20:19:38 <Nevoic> usually it's like `get` or [0].
20:19:47 <Nevoic> Yeah I used nth in mine.
20:20:22 <glguy> toListOf (key "results" . nth 0 . key "known_for" . values . key "id" . _Integer) val ==> [70160,101299,131631]
20:20:26 <glguy> If we want to focus on integers
20:20:38 <Nevoic> So what is `toListOf`?
20:20:47 <Nevoic> Is that how to convert a Vector to a List?
20:21:22 <Nevoic> I tried values before too, I just always did like & values because I thought you had to call values (iterable) to make it work.
20:21:26 <glguy> It takes a path through the data (first argument) and gives you a list of all the values that path "visits"
20:23:17 <Nevoic> What will happen if one of them doesn't exist?
20:23:28 <Nevoic> Like one of the keys?
20:23:44 <glguy> Then that path won't visit any values and won't contribute to the list
20:29:02 <glguy> If you wanted to have things blow up more:
20:29:02 <glguy> do known_fors <- preview (key "results" . nth 0 . key "known_for" . _Array) val; traverse (preview (key "id" . _Integer)) known_fors
20:29:03 <glguy> Just [70160,101299,131631]
20:29:25 <Nevoic> I'm still trying to work through the original solution tbh XD lol
20:29:26 <glguy> You could do something like that. It would fail if 1) there's no list of known_fors at that path
20:29:39 <glguy> 2) if any of the known_for elements weren't integers
20:29:45 <Nevoic> Because my code is a bit more complicate than what I asked for, but it's a lot of help.
20:30:03 <glguy> and failure here means you get a Nothing, not runtime disaster / null dereference
20:31:25 <Nevoic> Yeah, I mean Python is a special little thing because it loves its runtime failures.
20:32:26 <Nevoic> I usually code in Kotlin which has null safety. Interoping with Java can still be dangerous, but if you're writing pure idiomatic Kotlin code you have to explicitly type `!!` to blow up null references, and it'll always blow up right there and not when it's called at some random point in the future.
20:33:04 <Nevoic> I'd honestly be fine with them not having that operator, I never use it, but some people coming from Java wanted the ability to just turn their null types into non-null types.
20:34:42 <Cale> Nevoic: Sorry, had to step out for a second there, but I'm back. Here's the kind of code I was thinking of: https://gist.github.com/cgibbard/6bcfa4e4fffb994bb4a1d4519bd75514
20:35:06 <Cale> Just use Aeson's Parser monad, and navigate the structure bit by bit
20:35:20 <Nevoic> Idk what .: does
20:35:39 <Cale> It extracts a field of an object
20:35:55 <Cale> http://hackage.haskell.org/package/aeson-1.4.2.0/docs/Data-Aeson.html#v:.:
20:35:58 <glguy> Cale: indexM so it looks nice in do-notation?
20:36:16 <Cale> Well, also because it'll fail in the Parser monad
20:36:32 <Cale> So if there's no 0th element of that Array, we should get a JSON parse failure
20:36:55 <glguy> Cale: I don't think it does that (rechecking)
20:36:57 <Cale> I haven't tried it yet though
20:37:48 <Nevoic> Those are both cool solutions, but I'm still kind of just stuck on the same thing. Maybe what I'm trying to do is impossible, it very well might be.
20:38:04 <Cale> lol, it does fail, but the error is pretty weird
20:38:27 <Cale> I have no idea why the error message is as weird as it is
20:38:29 <glguy> Cale: indexM is a strictness trick, it's not about indexing failure
20:38:38 <Cale> ah, odd
20:39:04 <glguy> Prelude Data.Vector> indexM empty 0 :: Maybe Int
20:39:04 <glguy> *** Exception: ./Data/Vector/Generic.hs:330 (indexM): index out of bounds (0,0) CallStack (from HasCallStack):  error, called at ./Data/Vector/Internal/Check.hs:87:5 in vctr-0.12.0.2-e6bb4662:Data.Vector.Internal.Check
20:39:31 <glguy> The intended usage is described here: https://hackage.haskell.org/package/vector-0.12.0.2/docs/Data-Vector-Generic.html#v:indexM
20:39:45 <Cale> oh, !?
20:39:57 <Cale> Let's just go with !?
20:41:34 <Nevoic> Pretty much, I just need a function that achieves this:
20:41:34 <Nevoic> method :: IO Maybe Value -> IO (Maybe[Integer])
20:42:10 <glguy> Nevoic: fmap :: ( Maybe Value -> Maybe [Integer] ) -> ( IO (Maybe Value) -> IO (Maybe [Integer]) )
20:43:16 <Nevoic> I tried that the same way I tried map, and it didn't work.
20:43:37 <glguy> well it works, so you have to be more specific about what you tried and what error you got
20:46:05 <Cale> Nevoic: Updated my gist so that it used the right operation on Vector and gives a bit better of an error message from the result of decodeEither when there are no results
20:46:12 <Cale> (though it's still not the nicest message...)
20:47:42 <Cale> It's a bit of a shame that it's gotten kind of obnoxious to use parsers directly in aeson.
20:49:13 <Cale> But once you have that type, you can just fromJSON your value to it
20:49:19 <jackdk> Yeah, I think that more often than not, typeclasses are the wrong place to hang serialisation code
20:49:31 <Nevoic> method :: IO (Maybe Value) -> IO (Maybe[Integer])
20:49:31 <Nevoic> method r = fmap (. _Integer) r <&> preview (_Just . key "known_for" . _Array)
20:49:42 <Nevoic> To answer glguy as to what I've tried
20:49:46 <Cale> It's not that bad to have a canonical way to serialise/deserialise things, it just shouldn't be the only way
20:50:15 <Cale> Nevoic: Did my explanation about why that doesn't work make sense?
20:50:55 <Cale> Nevoic: Basically, if you want to continue down that road, you want to find appropriate things to compose onto the chain of traversals inside your preview there.
20:50:56 <MarcelineVQ> jackdk, Cale: the creators of https://hackage.haskell.org/package/waargonaut agree
20:50:57 <Nevoic> I don't see where you explained that, I haven't shared that code yet.
20:51:42 <Cale> Nevoic: A while back I explained why that (. _Integer) doesn't make sense there
20:51:54 <Nevoic> Ah, I was using map before.
20:52:16 <Cale> yeah, but even with fmap, that only makes sense if the contents were a function
20:52:32 <Cale> (. _Integer) is the function which takes any function f, and composes it with _Integer
20:53:06 <Cale> So it might make sense if you had a whole collection of these prism/traversal things
20:53:24 <Cale> and you wanted to add ". _Integer" on to the end of each one
20:53:43 <Cale> but you've already done the preview there, so you're back to talking about ordinary values
20:53:50 <Cale> you might just do another preview
20:54:09 <Cale> but you're probably better off just extending the one you're doing in that case
20:54:35 <Nevoic> I don't know, I just feel kind of lost tbh in terms of my ability to do anything in this language.
20:54:55 <Nevoic> It's my first ML language so I guess it's to be expected, I just haven't felt this way in like 7 years while coding.
20:55:41 <jackdk> I've been there mate. That's what being in the middle of a paradigm shift feels like.
20:55:48 <Cale> Yeah, that's to be expected, but also, prisms and lenses make me feel similarly lost a lot of the time, and I've been programming in Haskell for 15 years.
20:55:59 <Cale> So, don't feel too bad here.
20:56:15 <Cale> wait, not 15 years, it's more like 18
20:56:25 <Cale> I started around 2001-2002 or so
20:56:26 <jackdk> yeah and diving into lens in particular. I've only just started going a bit below the surface of that lib.
20:56:29 <Nevoic> The weird thing is I thought I was ready for the jump, I don't write low level imperative code, whenever anyone in another language is like using mutable variables to create counters I'm like refactoring it to do it recursively or with maps/reduces/folds/flatmaps etc.
20:56:56 <Cale> Nevoic: It's also worth noting that you can just write functions that pattern match on Value
20:56:59 <Nevoic> I have a Kotlin project consisting of like 4000 lines of code with literally 1 mutable variable.
20:57:08 <Cale> It's an ordinary data type with a bunch of constructors
20:57:20 <Cale> and you can just pattern match a bunch and deal with the cases
20:57:47 <maerwald> mutable variables are not the problem, shared "global" mutable variables are
20:57:47 <Nevoic> That's probably what I'd like to do, that's one of the things that Kotlin really lacked that I looked forward to using in Haskell.
20:57:54 <Cale> aeson provides some stuff to try to be convenient, the lens-aeson thing you're using also tries to make it syntactically shorter
20:58:00 <Cale> but honestly...
20:58:06 <Nevoic> Yeah, I have none of those either maerwald. The only mutable variable I have is local.
20:58:10 <Cale> case expressions are often just simpler
20:58:21 <Nevoic> It's a single variable that's used to track a timer indefinitely.
20:58:25 <maerwald> mutabiltiy is not your enemy 
20:58:27 <Cale> Here, I'll do it with just case and basic operations
20:59:07 <Nevoic> Also I should mention that I'm also pulling stuff from an API, I'm not messing with local JSON.
20:59:16 <Nevoic> And I'm also interacting with a Discord bot.
20:59:21 <Nevoic> All in like 50 lines of code.
20:59:44 <Nevoic> maerwald So if global mutable shared state isn't my enemy, what is?
21:00:03 <maerwald> Nevoic: no, I said mutability is not your enemy, but global mutable shared state is
21:00:28 <maerwald> you can tackle this problem by fixing the "shared" part too instead of the "mutable" part
21:00:56 <Nevoic> I mean I'm doing no mutation right now.
21:01:00 <Nevoic> I'm not trying to modify anything inline.
21:01:07 <Nevoic> I'm not trying to modify anything at all.
21:02:10 <Nevoic> Completely separate note, has anyone here read Clean Code or looked into Clean Architecture?
21:02:31 <Nevoic> I'm at a loss as to how to implement that idiomatically in Haskell. Would boundaries be defined as typeclasses?
21:03:03 <Cale> I haven't -- what's the gist of it?
21:03:32 <Nevoic> It's an architecture that's meant to separate your presentation/data from your domain (similar to the point of IO in Haskell, but on an architectural level instead of a language level).
21:04:08 <Nevoic> So you have your domain, which is where all your business logic is, and then boundaries that are defined and owned by your domain, defined as abstractions, and your domain works entirely in abstractions, no concrete references to any real presentation or data representation.
21:04:13 <Cale> So, like the separation between the model on the one hand and the view/controller on the other in MVC?
21:04:46 <Nevoic> Not exactly, MVC doesn't really dictate how to separate domain logic from presentation.
21:04:58 <Nevoic> Or from data.
21:05:13 <Nevoic> Like MVC in rails, for example, has your "domain model" coupled directly to your DB (via Active Record).
21:05:24 <Nevoic> Same thing in ASP.NET Core MVC.
21:05:29 <Nevoic> They all kind of do heavy coupling everywhere.
21:05:30 <Cale> Well, maybe... you can ask a ten people what MVC is and get a dozen answers I suppose.
21:05:48 <Nevoic> Yeah, I've just found a pretty consistent pattern in terms of framework level implementations of MVC.
21:06:04 <Cale> I'm just thinking about the way that the model can be thought of as a declarative specification of how data flows between the view and controller.
21:06:10 <jackdk> Nevoic: https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html ? 
21:06:20 <Nevoic> Yeah jackdk
21:06:33 <Nevoic> It's kind of like that then I suppose Cale.
21:06:46 <Nevoic> But the big thing is that you really can't have your entire domain in your model.
21:06:47 <Cale> In some sort of ideal world, it would essentially be a pure function of its inputs over all of time
21:07:44 <Nevoic> In the clean architecture world, you can actually have all your true domain logic completely decoupled from all implementation.
21:07:45 <Cale> In my day job, I work for a company which is using Haskell to write mostly web and mobile applications
21:07:58 <Cale> We use something called reflex-dom to build our frontends
21:08:24 <Cale> Underlying reflex-dom is a library (reflex) for what's called functional reactive programming (FRP)
21:08:37 <Nevoic> How does your logic tie into that?
21:09:18 <Cale> The basic idea of FRP is that in order to write programs which react to user input over time, we're basically going to introduce some new datatypes which will model the different kinds of ways that something can vary over time
21:09:24 <jackdk> I've done a little thinking but haven't built/tested anything. You might be able to specify each "port" as an MTL-style typeclass, and then use a trick like https://chrispenner.ca/posts/mock-effects-with-data-kinds to allow you to select different implementations for each port
21:09:35 <Cale> Some things have a value at any moment you care to look at them
21:10:18 <Cale> Things like the current time of day, the current position of the mouse pointer, the current contents of a text field or an entire form, the current hitpoints of a monster, the current scene to be displayed on the screen in a game...
21:10:24 <jackdk> the core will probably look quite different, as your modeling of application data and business rules won't be object-oriented, naturally.
21:11:08 <Cale> These we call "behaviours", and there's a type in Reflex:  Behavior t a  for things which have a value of type a at any moment (the t refers to a choice of implementation for the abstractions)
21:11:33 <Cale> Then there are things which only occur at particular moments in time, and have values at only those moments
21:12:34 <Cale> Things like the sequence of mouse clicks or keystrokes, the sequence of requests made over the network to a backend server or the sequence of replies coming back, the sequence of attacks made by the player, the sequence of audio clips to be played, etc. etc.
21:13:16 <Cale> Then we provide lots of combination functions which take Behaviors and Events and combine them together to make more Behaviors and Events
21:13:20 <Cale> in various ways
21:13:41 <Cale> and the idea is that you can express your program in terms of those going from inputs all the way through to outputs
21:14:00 <Nevoic> That's interesting, I'll have to look into FRP a bit more.
21:14:05 <Cale> and that's like a pure declarative specification of what ought to happen over time
21:14:10 <jackdk> Cale: you are making new connections in my brain. I hadn't thought to try the strict dependency rule from the bob article with FRP. This could be quite interesting...
21:14:38 <Cale> and then the *library* takes care of the hard task of making sure that everything stays up to date and we don't recompute anything more than what is necessary for the demanded output
21:15:24 <Cale> If two Events are triggered by the same keystroke, say, then they actually occur simultaneously in this model, and it's not possible to tell which order the library is handling them in.
21:16:00 <Cale> That's the main problem with the Observer pattern: it secretly matters which order your event handlers are installed in
21:16:17 <Cale> Well, that's *a* main problem with it
21:16:33 <Cale> another problem is that all your event handlers produce no result
21:16:39 <Cale> and so are inherently incomposable
21:17:35 <Cale> But even if you don't go so far as full-blown FRP, it's often the case in Haskell that we will use data structures to form an abstract model of what ought to be taking place
21:17:55 <Cale> and then use calculations on those data structures to govern what actually does take place when we connect everything up to IO
21:18:27 <Cale> For example, inside the XMonad window manager is a perfectly abstract data structure model of the tiled window layouts
21:18:53 <Cale> and then a bunch of stuff which actually goes about putting the windows where that model says they ought to go
21:19:30 <Cale> Modelling things in terms of pure functions makes them easier to test
21:19:36 <Nevoic> Yeah I mean that doesn't sound too different from what I've achieved tbh.
21:19:52 <maerwald> Cale: is it?
21:20:02 <Cale> maerwald: Is what?
21:20:05 <maerwald> I think it's more about how atomic and reproducible a function is, not so much about purity
21:20:22 <maerwald> E.g. I test IO exceptions in some libraries, reproducible
21:20:31 <Cale> It is about purity, because it lets you use equational reasoning in testing.
21:20:43 <Cale> (also in refactoring)
21:21:02 <Nevoic> Yeah, also purity leads to the other two things you talked about, if I'm mistaken maerwald.
21:21:16 <Nevoic> At least reproducibility.
21:21:27 <Nevoic> That's like one of the big selling points of pure functions.
21:21:38 * hackage sv 1.3.1, sv-core 0.4.1 (qfpl): https://qbin.io/speech-median-a7un
21:21:39 <Nevoic> No state means you call it and the same thing happens every time.
21:21:46 <Cale> I don't have to worry that checking my property that f x = g x causes some side effect that makes the following test fail, and I don't have to worry about f causing unexpected changes to x before g gets it, causing the test to pass when it should have failed.
21:22:08 <Nevoic> So is it the case that you can only ever unpack IO objects in main?
21:22:10 <maerwald> Nevoic: if I have a function that modifies an array in-place instead of return a new one... is not much of a difference. You can write property tests for both easily
21:22:25 <Cale> and yeah, I can apply functions in isolation in a repl, and if they work in the repl, they produce the same results when deployed
21:22:32 <Cale> That's really nice
21:22:44 <Cale> Can't have it all the time, but it's nice to get it as much as you reasonably can.
21:23:37 <Cale> I don't have to worry about mocking things, and whether I've mocked correctly
21:23:51 <Nevoic> maerwald There are examples of easy things to test in non-pure environments for sure.
21:24:15 <Nevoic> I just think the claim is that reproducibility is what's important, and keeping everything pure guarentees that. 
21:24:33 <Cale> The real reason why Haskell's purity and type system are so much of a value proposition is that they work together to make code far more refactorable though.
21:24:54 <Cale> You don't get stuck with bad early design choices, too afraid to touch anything.
21:25:27 <Cale> You can just make some change to the heart of something and start ripping shit apart, doing whatever the compiler tells you needs to happen
21:25:44 <Cale> and eventually you typically come out the other end with a working program
21:25:44 <Nevoic> Yeah that's exactly what I like about Kotlin.
21:25:52 <Nevoic> I literally just did a refactor of a multithousand line project of mine two weeks ago.
21:26:08 <Nevoic> I refactored the entire domain, didn't touch any dependencies at all, and then just listened to the compilation warnings to drive the changes.
21:26:15 <Nevoic> And changed the implementations based on that domain.
21:27:17 <Nevoic> I spend like 20 hours refactoring it without running it once, changed so much shit, ran it, had one runtime exception that I fixed in a few minutes and then it was good.
21:27:22 <Nevoic> That's the kind of shit that just isn't doable in Python.
21:27:29 <Nevoic> You can't refactor code blind without running it for 20 hours.
21:27:59 <Cale> A coworker and I took a fully featured chat application we were working on for a client, and made it multi-tenant (i.e. keeping multiple copies of the database schema in the DB and running multiple isolated copies of the same service at different subdomains, with the same backends), in three days.
21:28:17 <Cale> Actually, it was closer to two days, but spilled over a little
21:29:14 <Nevoic> That's solid. The coolest anecdote I have from Kotlin is building the chat bot I'm talking about, I had probably 2,000 lines of code at the time, it functioned only on Discord, and then I got telegram up and working with all the exact same commands in like an hour.
21:30:12 <Nevoic> I had to look up the framework, read the documentation, then I implemented the few interfaces that needed to be implemented, and started a separate Telegram instance at the start and injected all the same backend dependencies (APIs/DBs etc.) and could've used different ones if I so pleased.
21:31:39 <Nevoic> It was cool. I had a friend building a Discord bot in Python at the same time, and all his domain code was coupled with the bot itself, so the idea of making a Telegram bot would've been like super daunting for that codebase.
21:32:54 <maerwald> Cale: sometimes haskell code is harder to refactor though
21:32:55 <Cale> Our backend was around 16k lines of Haskell, code shared between the backend and frontend around 5k lines, and frontend around 26k lines.
21:33:13 <maerwald> Because you often commit to very strong (and/or opinionated) APIs
21:33:26 <maerwald> Reverting such a decision than is like a rewrite
21:33:30 <Cale> no!!!
21:33:40 <Cale> It's less like a rewrite than in any other kind of setting
21:34:01 <Cale> Because although it may be tedious when you go and make the change, the compiler is going to help you through it
21:34:06 <Nevoic> I mean so long as when you're writing the majority of your codebase you're not using any external APIs you're fine.
21:34:11 <Cale> You can just leave a ghcid running
21:34:20 <Cale> and go to town
21:34:46 <maerwald> The type errors you get when you change your core monad stack... :)
21:34:47 <Cale> Now, it's certainly possible to make decisions with your types that make programming unwieldy
21:34:47 <maerwald> gl
21:35:20 <maerwald> IMO refactoring is easy as long as you don't change core decisions
21:35:21 <Cale> Ah, but you should have newtyped that, and your code should not be strewn with explicit lifts, ever
21:35:44 <Cale> But granted, that'll be annoying to clean up the first time, if it is
21:36:03 <Nevoic> I mean if you compare any compiled language to say Python, it's night and day.
21:36:04 <Cale> The solution is to have type classes that express what things you need in your monad
21:36:17 <Cale> and for almost everything not to care about the implementation of your monad
21:36:28 <Nevoic> At one of the jobs I worked, we had an Object (GithubRepo) that developed into our domain project model, and we never renamed it while I was there.
21:36:45 <Cale> hahaha
21:36:53 <Nevoic> Within my first month of being there I made a task to refactor that, and I talked to people about it, and it was pretty much just consistently decided that it would be too daunting to rename.
21:37:17 <Cale> our CI server is called gitlab-xmpp, even though it has nothing to do with xmpp any more and it works on github projects as well
21:37:22 <Nevoic> In Kotlin (Intellij) you literally just click shift F6 and it renames all usages of it, and even suggests variable renames (that you can skip if you want) based on the class rename.
21:37:27 <Nevoic> It's godly.
21:37:34 <Cale> (but that's just because we haven't bothered renaming it)
21:38:01 <Cale> It started out as something that just dumped commit messages into our xmpp chat
21:38:13 <Nevoic> So renaming a class with 2000 instantiations throughout the codebase is instant, where in Python it'd probably be a multi-day bug-ridden adventure.
21:38:59 <Cale> Yeah, we don't have as many editor-based tools in Haskell, or... well, in some cases we do, but people don't seem to use them nearly as much.
21:39:19 <Nevoic> I refused to use Haskell until I found something that at least somewhat resemebled the toolstack I'm used to.
21:39:50 <Nevoic> It's not where nearly as good, but I get compile-time autocomplete (not textbased), inline errors and type hints.
21:39:56 <Nevoic> I don't know how so many people settle for text-based autocomplete.
21:40:06 <Nevoic> Makes me want to tear my hair out lol
21:40:53 <johnw> i've never used autocomplete with Haskell
21:41:02 <Nevoic> Oof.
21:41:05 <johnw> it's never been worth the effort to make it work
21:41:18 <Cale> I use only tags-based autocomplete with hasktags
21:41:19 <Nevoic> Does that mean you're living in documentation hell?
21:41:24 <johnw> in Emacs I use M-/, which consults all open Haskell buffers, and that has been enough
21:41:29 <Nevoic> Like what do you do for undocumented libraries?
21:41:36 <Cale> But I don't really *need* it so much
21:41:36 <Nevoic> Read the source? D=
21:41:41 <johnw> I have a local Hoogle that indexes every package my project uses
21:41:46 <Cale> I just know the libraries fairly well
21:41:58 <Cale> and yeah, documentation
21:42:02 <johnw> I consult it often until I get familiar with the subset I'm using
21:42:43 <Cale> I'll usually just jump to tag to get the types of things, and have lots of source trees unpacked to make that easier
21:42:55 <Cale> Or use the repl
21:43:10 <Nevoic> Yeah that's rough. There are a number of libraries that wouldn't be usable for me in various languages without really good autocomplete.
21:43:22 <Cale> Well, it's a double-edged sword
21:43:38 <Cale> If everyone uses autocomplete, you end up with stuff that's a pain to use without autocomplete
21:43:48 <Nevoic> I don't know what that means.
21:44:00 <Nevoic> You're saying autocomplete reduces code quality?
21:44:14 <Cale> It changes code quality
21:44:17 <johnw> a culture of autocomplete users favors the existence of the tool
21:44:19 <Cale> Let's just say
21:44:36 <Cale> Like, it's not going to create lots of bugs, I don't think
21:44:44 <Nevoic> "if everyone uses a compiler, you end up with a language that's a pain to use without a compiler"
21:45:04 <Cale> If everyone uses a debugger, you *definitely* end up with code that's a pain to debug without a debugger!
21:45:07 * hackage haiji 0.2.2.0 - A typed template engine, subset of jinja2  https://hackage.haskell.org/package/haiji-0.2.2.0 (NoriyukiOhkawa)
21:45:23 <Cale> Debuggers are the strongest example of this I know of
21:45:29 <Nevoic> You can apply the argument to anything that's useful, then.
21:45:58 <Cale> They let you make changes to code that you don't understand in order to fix bugs, and gradually push the code out of reach of understanding without a debugger.
21:46:14 <Cale> I don't think that's really true of compilers.
21:46:20 <Nevoic> I was easily able to write code I didn't understand in Haskell without a debugger.
21:46:21 <Nevoic> I did today lol
21:46:28 <Cale> haha
21:46:37 <Nevoic> I don't think that's really true of autocomplete or debuggers either.
21:46:54 <Nevoic> But the argument is exactly the same for all of them. They're all useful tools that help people code more reliably and quicker.
21:47:10 <Cale> I know it's true from experience working on some of the worst code in one of the worst languages I've ever come across
21:47:16 <Nevoic> Have a reliable tool means you can step outside your comfort zone more effectively.
21:47:26 <Nevoic> "I can write this shitty code because I know it won't blow up at runtime because of my compiler"
21:47:43 <Nevoic> That's obviously not how nobody thinks, but I don't write shitty code because I use a debugger, either, so you're kind of drawing the same strawman.
21:47:46 <Cale> There was this calendar app which a friend of mine was brought on to rescue from the pits of despair
21:47:48 <Nevoic> not how anybody thinks*
21:47:55 <Cale> and he hired me on to work on it soon after
21:47:59 <Nevoic> What language?
21:48:03 <Cale> Groovy
21:48:06 <Cale> lol
21:48:24 <Nevoic> Yeah I mean that's a dynamically typed language.
21:48:31 <Nevoic> I despise dynamic languages lol
21:48:46 <luite> hmm, I'd like better debugging facilities for Haskell still, in particular for debugging bigger running programs where it's not clear which package (or combination) is causing an exception or leak
21:48:53 <Cale> It's *kind of* dynamic?
21:49:02 <Cale> It has a type system, it's on the JVM
21:49:10 <Cale> but it does a bunch of bullshit
21:49:24 <Nevoic> I mean JRuby and Jython are on the JVM and they're both dynamically typed (because they're Ruby and Python)
21:49:35 <Nevoic> Being on the JVM /= static
21:49:38 <Cale> It's like some people who had never implemented a programming language before, and had also never really used ruby said "hey ruby is cool, let's make it on the JVM"
21:49:51 <Cale> and then proceeded to implement a complete trainwreck
21:50:09 <Nevoic> Ah okay, so version two they allowed it to be optionally compiled statically.
21:50:14 <Cale> Every method invocation is done by linear lookup doing string and type comparisons in a list of methods
21:50:18 <Nevoic> So I guess you can choose to make it static, I didn't know that.
21:50:22 <luite> it's a good time to repeat history with WebAssembly now ;p
21:50:57 <Cale> but that's not even what made that job so hard
21:51:10 <Nevoic> But I'm still not at all convinced that autocomplete has any negative effect on code quality.
21:51:14 <Cale> Groovy used by people who knew how to program would have been relatively okay
21:51:30 <Cale> But we inherited this codebase from a bunch of novice programmers who had no idea what they were doing
21:51:43 <johnw> I actually liked Groovy
21:51:44 <Nevoic> That'll generally lead to bad code more so than the dreaded debuger.
21:51:45 <Nevoic> debugger.
21:51:48 <Cale> This was a calendar application
21:51:59 <Cale> Groovy has a time data type
21:52:05 <Cale> (It's just Java's stuff)
21:52:30 <Nevoic> The thing is, I'm of the opinion that humans are notoriously bad coders, we're just super imperfect. Some other coders (mostly Python developers tbh lol) have this perception that we are Gods and also mostly infallible if we try hard enough.
21:52:32 <Cale> But they chose instead to use integers with digits like HHMM
21:52:39 <Nevoic> So we need as many tools as possible to make us slightly better.
21:52:50 <Cale> e.g. 1630 means 4:30 pm, *Eastern Standard Time*
21:52:54 <Cale> lol
21:53:28 <Cale> and the code was just rats' nests everywhere of things where something wasn't working and someone got in there with a debugger, found where it didn't seem to be right, and put in a thing to fix it
21:53:29 <Nevoic> Inline errors to help us see if we screwed up syntax is good, autocomplete based on compile-time information instead of text is good because it actually shows you usable code instead of just guessing.
21:53:29 <Nevoic> compilers in general are good because they catch errors that we wouldn't because of our incomplete capacity to understand code bases.
21:53:48 <Cale> I don't think there was a person alive who could have understood the conditions on which that system sent out email
21:53:49 <Cale> lol
21:54:08 <Cale> like, I don't think anyone's capable of fitting that much detail into their heads
21:54:16 <Nevoic> Yeah, 7 is the number.
21:54:23 <Nevoic> Of like specific things on average a person can fit in their head.
21:54:49 <luite> Cale: so it's like an instance of Num? :)
21:55:14 <Nevoic> And we generally use abstractions or hierarchies to encapsulate problems that are larger than what we can store in our head.
21:55:24 <Cale> luite: it was literally the int value, one thousand six hundred thirty
21:55:43 <Cale> luite: They were doing modular arithmetic to extract the hours and minutes
21:56:06 <Cale> and there was an explicit list of the allowed time values for appointments to start and stop and shit
21:56:12 <Cale> it was just... hilarious
21:56:15 <luite> oh uh, neat
21:57:13 <Cale> Nobody was actually smart enough to understand that code. The only reason it could be maintained as long as it had been was debuggers
21:57:39 <Cale> If debuggers weren't an option, people would have been forced to keep it understandable, or they just couldn't have made the changes they had.
21:59:07 <Cale> I'm not saying it's *always* like that, but it requires constant discipline, when you're using fancy debuggers, to keep things from deteriorating in that fashion.
21:59:31 <Cale> That was just a spectacular example of it
22:00:39 <Cale> Anyway, after treading water for a few months, we ended up rewriting the entire thing from scratch in Haskell in a few weeks.
22:01:05 <Cale> and it worked really well and was far easier to maintain and extend
22:04:50 <Cale> (and like 10000 times faster)
22:05:55 <Nevoic> How do you pattern match a Value?
22:06:02 <Nevoic> _String _Integer etc.?
22:06:05 <Cale> case myValue of
22:06:23 <Cale> http://hackage.haskell.org/package/aeson-1.4.2.0/docs/Data-Aeson.html#t:Value
22:07:29 <Cale> So you would proceed with  Object o -> ... o is now a HashMap Text Value ...
22:07:39 <Cale> etc. etc.
22:08:10 <Cale> Note that there are some type synonyms in use there in the documentation -- not sure how wise those were for aeson to use.
22:08:22 <Cale> But Object means the same thing as HashMap Text Value
22:08:32 <Cale> Array here means Vector Value
22:09:03 <Cale> Scientific is a weird number type that I'm not sure why they went with it...
22:09:17 <Cale> (It's arbitrary precision)
22:10:38 <Nevoic> Is Data.Aeson.Types Value what we're talking about here?
22:10:40 <Nevoic> When we say Value?
22:10:46 <Cale> Honestly, the more I look at aeson, the more I want to replace it -- we use it all the time at work, but we basically never use it by hand
22:11:06 <Cale> http://hackage.haskell.org/package/aeson-1.4.2.0/docs/Data-Aeson.html#t:Value -- this thing
22:11:08 <Cale> yeah
22:11:18 <Cale> uppercase V Value is that thing :)
22:11:24 <dmwit> I think it's designed to 1. match very closely the way the JSON spec talks about numbers and 2. have a security story about not using way too much space just because the number given has a big exponent.
22:11:24 <Nevoic> I decided to say screw everything and rewrite it all without IO because I can't do it.
22:11:30 <Cale> http://hackage.haskell.org/package/aeson-1.4.2.0/docs/src/Data.Aeson.Types.Internal.html#Value
22:11:47 <Nevoic> https://cdn.discordapp.com/attachments/496210024498987009/562504260705583105/unknown.png
22:12:08 <Nevoic> That's what was working before, and now it's not. I kind of expected this part to just work so I'm even more discouraged lol
22:12:53 <Nevoic> https://cdn.discordapp.com/attachments/496210024498987009/562504541975609364/unknown.png I have *no* idea what that means.
22:13:08 <dmwit> Like a naive implementation would see 1e9000000000000000000 and try to make a 2^63-bit-long Integer, which is obviously not what you want to happen.
22:13:34 <Nevoic> f0 c0, probably like automatically named generics?
22:13:45 <Cale> dmwit: Yeah, for sure... though if you try to convert that thing to an Integer or otherwise do much with it, you're going to hit that problem pretty quickly.
22:13:49 <Nevoic> I'm still so bad at following abstract code, when literally everything is genericized I kind of lose what's actually going on.
22:14:01 <Cale> Nevoic: Everyone does
22:14:15 <Cale> (to different extents, depending on familiarity)
22:14:37 <Cale> Sometimes if it's abstract *enough* it gets simple again
22:14:45 <dmwit> Cale: Yep. The user should check the exponent before doing anything. And I think it's sort of reasonable for the library itself to say "we don't have a policy here, it's on you to decide how big is too big".
22:14:45 <Nevoic> And the thing is, I write to generic functions all the time in Kotlin too.
22:15:02 <Cale> It's the moderately abstract code which is really working with something in particular but it's hard to understand what, where things get a bit annoying
22:15:27 <Nevoic> Yeah.
22:15:48 <dmwit> Nevoic: Are you sure you want `r . whatever`, and not, say, `r ^. whatever`?
22:16:02 <dmwit> no no
22:16:11 <Nevoic> I think so.
22:16:12 <Cale> Yeah, val here isn't a function
22:16:13 <dmwit> s/`r/`val/g
22:16:16 <MarcelineVQ> error reads: "expected to be given something that wasn't a function, got a function, help"
22:16:21 <Cale> It's a Value
22:16:27 <Cale> so you can't compose it with (.)
22:16:36 <MarcelineVQ> *er other way around :>
22:16:38 <Cale> Nevoic: It's important that you understand what (.) is here
22:16:41 <dmwit> Nevoic: I think you are wrong. =)
22:16:45 <Cale> :t (.)
22:16:46 <lambdabot> (b -> c) -> (a -> b) -> a -> c
22:16:50 <Nevoic> I surely am wrong.
22:16:55 <Nevoic> Oh cool more generic stuff.
22:16:55 <Cale> (f . g) = \x -> f (g x)
22:17:03 <Cale> It's function composition
22:17:06 <Cale> like from math
22:17:10 <Nevoic> Yeah I know.
22:17:16 <Nevoic> I can't just read it though and grasp it.
22:17:26 <Nevoic> I don't have a masters in math. I only ever got up to Calc.
22:17:44 <Nevoic> I know function composition is taught way before Calc, I'm just saying I'm not super familiar with math.
22:17:49 <Cale> The thing which really makes all this hard is that the kinds of functions you're working with are a bit unusual
22:17:51 <Nevoic> I haven't taken a math course in 4 years.
22:18:02 <dmwit> That's fine.
22:18:08 <dmwit> We've just reminded you of the relevant bit anyway.
22:18:43 <Nevoic> Okay, well then screw all this code. What's the "usual" way to parse a JSON structure in Haskell?
22:18:51 <Nevoic> I'm done doing things unusually.
22:19:18 <Cale> Well, what you'd often do using aeson is to define a data type corresponding to the JSON you want to parse
22:19:25 <Cale> Or a bunch of them
22:19:44 <Nevoic> That would take like 50 lines of code.
22:19:48 <Nevoic> There's a lot of nested structure here.
22:19:49 <Cale> and then you write instances of FromJSON (or have them written for you, if you're super lucky)
22:20:01 <Nevoic> It would literally over double the length of my script.
22:20:02 <Cale> Well, yeah, if you wanted to do a really complete job, yes.
22:20:30 <Cale> But that's sort of the kind of library that Aeson is. You can choose to parse partially, as in the example I gave you
22:20:35 <Cale> and that was only a few lines
22:20:47 <Cale> It's possible to make the datatype only have exactly the information you want to extract
22:21:03 <Cale> But it's sort of against the grain of what aeson is about
22:21:21 <Nevoic> I'm just frustrated at this point because doing what I want to do literally would take me 5 minutes to do in other languages, and I've been stuck on it for 4 hours.
22:21:38 <Nevoic> I'm actually convinced I might have a mental disorder.
22:21:41 <dmwit> spoiler: it wouldn't take me 4 hours
22:21:50 <Nevoic> Well you're a person of at least average intelligence.
22:21:52 <Nevoic> I think I'm retarded.
22:21:56 <dmwit> New languages are harder than languages you know intimately. News at 11.
22:22:21 <Nevoic> I've learned new languages in the past actually, believe it or not.
22:22:24 <Nevoic> Like 10.
22:22:32 * dmwit nods agreeably
22:23:04 <Cale> Well, sure. I knew like 15-20 languages when I started learning Haskell. It still took about 2 months before I felt like I could do anything useful and then about a year to feel comfortable.
22:23:13 <dmwit> Nevertheless, I suspect there are more new concepts in Haskell vs. the 10 languages you know than there were in any of those 10 vs. the other 9.
22:23:49 <dmwit> Haskell is more different from most mainstream languages than most mainstream languages are from each other.
22:23:52 <jackdk> What dmwit said. The number of concepts you were able to reuse when moving between those "like 10" languages would have been higher
22:23:56 <dmwit> So learning is harder, and takes longer.
22:24:03 <jackdk> and pays off more!
22:24:09 <Cale> If you approach it like learning your first programming language, then it's probably not really any harder to learn Haskell than most others.
22:24:21 <Cale> It's just that it's very different
22:24:32 <dmwit> And, I'll admit: it's possible that for munging JSON, Haskell isn't even as good! I don't know, because I haven't had to do much of it in other languages recently. But I think that's a much smaller factor than the unfamiliarity one.
22:24:39 <Cale> Once you know 5 or 10 imperative languages, it's super easy to just pick up one more in a week or so
22:24:57 <Cale> Let's give waargonaut a try, I've heard good things about it
22:25:08 <Cale> It might be better for scraping
22:25:17 <Cale> Aeson is decidedly bad for scraping.
22:26:37 <Nevoic> I mean this is the first time in my experience with programming where the more I learn about a language the less interested in it I become, not even because of my shortcomings as an individual, but because it's not even that readable.
22:26:57 <Nevoic> That's something I was looking forward to, moving away from imperative code that describes how into declarative code that describes what.
22:27:03 <Nevoic> That's like something I advocate f or 24/7
22:27:13 <Nevoic> And having a whole language designed around that sounds amazing.
22:27:44 <Nevoic> But r <&> x >>= a & f x $ q (x 3)  isn't that readable to me.
22:27:48 <Cale> Yeah, it still takes work to make code readable, and readability is one of the major reasons I don't care much for lens in any case where it's not absolutely needed. This is arguably a good use-case for lens, and even now, I'm torn.
22:27:55 <Nevoic> And for some reason that seems to be all the code I'm writing and seeing.
22:28:02 <Cale> Yeah, some of that is just terrible choices
22:28:13 <Cale> <&> is particularly odd, I don't even know why that exists
22:28:20 <Cale> It's backwards <$>
22:28:37 <Nevoic> $ is something I've come to like. It took me a couple hours, but I actually prefer it over nested parenthesis now.
22:28:44 <Cale> yeah
22:28:47 <dmwit> Hypothesis: all Turing-complete languages permit the creation of working, unreadable code.
22:28:50 <Nevoic> But then like 14 more random symbols came at me in quick succession and I was like what the fuck.
22:29:02 <johnw> I love $ as a way of separating semantic domains
22:29:22 <dmwit> All programs in hq9x are super readable. But there's also not that many interesting programs you can write in that language.
22:29:23 <johnw> I always say 'return $ Foo 10', even though I'd write 'foo (Foo 10)'
22:29:28 <Ke> dmwit: like creating brainf interpreter and running your algorithm through that
22:29:35 <Nevoic> Does anyone have an example of like a super readable Haskell project I can look at?
22:29:41 <Nevoic> Like a library or something that they know is coded well?
22:29:45 <Nevoic> Just so I know what good stuff looks like?
22:30:03 <Nevoic> I've been reading and writing shit code for like 10 hours it's probably messing with my perception of what Haskell is capable of.
22:30:37 <dmwit> Of course, you can look at any of my packages, they are all 100% beautiful unimpeachable code. ;-)
22:31:19 <maerwald> haha
22:31:30 <maerwald> everyone: look at <my package>
22:31:34 <Nevoic> Yes, there will be flaws in everyone's code, but surely someone has to have written something nice in Haskell at some point in time? lol
22:31:56 <Nevoic> I like Haskell's quicksort more than most other language's, for example.
22:32:05 <Nevoic> I'd like something like that but like maybe on the level of a whole file (a hundred lines) or a few files.
22:32:15 <maerwald> Look at some of chris dones projects. He writes fairly clean and simple APIs for an advanced haskeller, which is very uncommon ime.
22:32:30 <Cale> You know, people complain that it's not in-place, but I didn't properly understand quicksort until I read it in Haskell.
22:33:12 <Cale> (You can implement in-place quicksort in Haskell as well, but it's probably going to be nearly as ugly as any imperative version)
22:33:14 <Nevoic> I wrote a quicksort in Kotlin that looks almost as good, and is also not in-place. I think functional quick sorts just generally make a lot more sense.
22:33:24 <Nevoic> They, like I alluded to earlier, describe what's happening instead of how it's happening.
22:33:33 <dmwit> Nevoic: https://github.com/greenrd/beeminder-api/blob/master/Network/Beeminder/Internal.hs <- lots of aeson-based code here
22:33:42 <Nevoic> I've been convinced of functional in the small for a long time.
22:33:46 <dmwit> An example of a binding to a JSON-based API.
22:34:21 <Nevoic> I've been using maps/reduces/filters etc. for a long time, as long as recursive functions and immutable variables, and objects without external state.
22:34:46 <Cale> Yeah, the thing is, Aeson is aimed more at constructing complete bindings to APIs efficiently than it is aimed at scraping bits and pieces out.
22:35:04 <johnw> lens-aeson makes a halfway decent scraper
22:35:05 <Nevoic> Is the comma on the next line thing comma place in Haskell?
22:35:10 <Nevoic> I don't really like the look of that tbh.
22:35:15 <johnw> Nevoic: yeah, it's common place
22:35:19 <johnw> you get used to it
22:35:31 <Cale> johnw: Yeah, for a really experienced Haskell programmer, that's pretty true, but for a beginner, it's entirely incomprehensible
22:35:38 <johnw> agreed
22:35:39 <Nevoic> also I thought the days where we did horizontal alignment was gone XD
22:35:50 <Nevoic> Like everything here is aligned. It'd be so hard to maintain that.
22:35:59 <maerwald> Nevoic: quicksort must be in-place :)
22:36:12 <dmwit> Nevoic: Weren't you the one extolling the benefits of good tooling earlier?
22:36:18 <dmwit> Nevoic: There's tooling for maintaining alignment. =)
22:36:19 <maerwald> Nevoic: check https://augustss.blogspot.com/2007/08/quicksort-in-haskell-quicksort-is.html
22:36:27 <Nevoic> dmwit: didn't know that. That makes things better.
22:36:44 <Cale> But also, people are just obnoxious about alignment.
22:36:57 <Nevoic> maerwald according to Wikipedia "quicksort can operate in-place"
22:36:57 <dmwit> Nevoic: That said, I've moved much farther away from alignment than I was at the time I helped with that code.
22:37:15 <Nevoic> Even if a non-in-place quicksort isn't technically a quicksort, people know what it means. That's just semantics.
22:37:19 <Nevoic> But I think it is.
22:37:20 <Cale> Where I work, we have a strict rule to generally not align things past the left margin
22:37:55 <Cale> Unless it really serves a coherent purpose -- like if you have a table and want to ensure visually that it's not missing entries, then fine.
22:38:17 <Cale> But if it just makes git diffs larger, then no.
22:38:59 <Nevoic> diff   = Diff   <$> v .: "goals" <*> (map idID <$> v .: "deleted_goals")
22:39:01 <Nevoic> What does that do?
22:39:30 <dmwit> `v .: "goals"` parses the sub-value under the "goals" key.
22:39:34 <dmwit> Similarly for deleted_goals.
22:39:36 <Cale> It builds a Diff value, parsing the first argument by extracting the "goals" field from the object v
22:39:57 <dmwit> (map idID <$> ...) unwraps the newtype used to get the right parse for deleted_goals.
22:40:01 <Cale> and the second argument by mapping the function idID over the list obtained by extracting "deleted_goals" from the same object v
22:40:16 <dmwit> Diff <$> ... <*> ... -- builds a Diff data structure from the results of the two parses done by ... and ...
22:40:28 <Cale> ^^ yeah, that's how to look at it
22:40:35 <Cale> This is a common pattern
22:40:50 <Cale> It's equivalent to writing:
22:40:55 <Cale> do x <- ...
22:40:58 <Cale>    y <- ...
22:41:03 <Cale>    return (Diff x y)
22:41:23 <dmwit> (Equivalent, but preferred these days, for reasons that aren't super important right now.)
22:41:49 <Cale> I would claim they're pretty much not super important ever ;)
22:41:58 <dmwit> Very likely.
22:41:58 <Nevoic> Ah alright. Is a lot of functional coding about learning those patterns and mapping them mentally to more imperative sequences?
22:42:05 <dmwit> People do seem to get really into that argument, though.
22:42:23 <Cale> Nevoic: Note that my do-block, while it may look imperative, is more functional stuff in disguise
22:42:24 <dmwit> I... do not think about that snippet in an imperative way, no.
22:42:42 <Cale> The way that do-syntax works is that:
22:42:47 <Cale> do { x } = x -- base case
22:43:05 <Cale> do { v <- x; <stmts> } = x >>= \v -> do { <stmts> }
22:43:23 <Nevoic> Ah alright, that makes sense, except for all the random syntax stuff right there.
22:43:24 <Nevoic> Imperative may have been the wrong word.
22:43:26 <Nevoic> Readable.
22:43:35 <Cale> do { let { <decls> }; <stmts> } = let { <decls> } in do { <stmts> }
22:43:41 <Cale> haha
22:43:55 <Cale> So, readability is a bit of a funny notion
22:44:15 <Cale> If you're used to reading the <$> and <*> stuff, for parsing, it tends to be pretty nice
22:44:51 <Cale> Because you're just building the result of your parse, applying the data constructors of the resulting syntax tree directly to the parsers which will parse the components
22:45:02 <dmwit> Do I lose Haskell cred if I admit that I often forget how the fixities of *> and <* work?
22:45:09 <Cale> haha
22:45:10 <Nevoic> Yes.
22:45:13 <Nevoic> lol
22:45:21 <dmwit> Okay. I won't admit it, then. ;-)
22:45:24 <Nevoic> I don't even know what fixities means.
22:45:31 <Cale> I wouldn't know what they are
22:45:36 <Nevoic> Is that like order of operations?
22:45:40 <dmwit> It is, yes.
22:45:43 <Cale> but I assume it's rigged so that the pointy end points at the result
22:46:01 <dmwit> Cale: That tells how the arguments are arranged, but says nothing about the fixity.
22:46:03 <Cale> and hope that it all works out :D
22:46:16 <Cale> Nevoic: Yeah
22:46:17 <dmwit> Cale: Which is important when writing parsers that mix <*> and *> e.g.
22:46:33 <Cale> But to be honest, I don't often use *> and <*
22:46:43 <Cale> I do use <$ though
22:47:12 <Nevoic> I think you're generally right that "readability is a funny notion" Cale, but the thing that you're missing is that different groups of people can parse different sets of symbols in a very similar way.
22:47:31 <Nevoic> For example, I can show non-programmers short Python scripts and they'll understand what's going on.
22:47:39 <Nevoic> It's readable to native English speakers.
22:47:45 <Cale> Nevoic: Well, that's not entirely true
22:47:54 <Nevoic> Haskell is implicitly readable to people with a masters in math.
22:48:06 <Nevoic> I mean they can *read* what's going on.
22:48:12 <Nevoic> They won't understand why things happen the way they do.
22:48:14 <Cale> That's very not true
22:48:23 <Nevoic> Ah okay.
22:48:24 <Nevoic> My bad.
22:48:30 <Nevoic> lol
22:49:09 <dmwit> Russian probably isn't a useful language. Most people can't understand anything I show them written in that lousy language.
22:49:15 <Cale> and, well, a friend of mine who I was teaching a bit of Haskell to also pointed out that in some ways it's also *more* like natural language than imperative programming a lot of the time
22:49:35 <Nevoic> I do use a lot of dollar signs while talking.
22:49:47 <Cale> Because in English, when we want to tell someone to wash all the dishes, we don't tell them to number them all with a dry-erase marker and increment a counter
22:50:11 <Nevoic> I mean I'm talking about C vs Haskell.
22:50:12 <Cale> We just say "wash all the dishes" which is a whole lot more like a higher order function than anything imperative.
22:50:28 <Cale> I mean, than a sequence of commands
22:50:28 <Nevoic> for dish in dishes: wash(dish)
22:50:41 <Cale> map wash dishes
22:50:42 <Nevoic> Not for (int i = 0; i < i.size; i++)
22:50:53 <Nevoic> Yeah, most people read that and say "map?"
22:50:56 <Nevoic> Because they don't know what a map is.
22:50:57 <Cale> Or mapM wash dishes, if we want literal Haskell
22:51:04 <dmwit> Yeah, I think most modern languages are moving away from C-style for loops and generally towards container iteration.
22:51:07 <Nevoic> Ah yes the famous mapM.
22:51:09 <Cale> Well, no, but you have to expect some unusual new words
22:51:10 <dmwit> Haskell doesn't have the lock on that idea it used to have.
22:51:12 <Nevoic> Everyone who speaks English knows what a mapM is.
22:51:27 <Nevoic> I mean I've been programming for 8 or 9 years and I don't even know what mapM is lol
22:51:37 <Nevoic> You can read the Python one in English though.
22:51:39 <Cale> It's not that it's literally English words, it's that you can get grammatical constructions which are more like those which natural languages use
22:51:49 <Nevoic> for every dish in the dishes, wash the dish
22:51:54 <Nevoic> for dish in dishes: wash(dish)
22:52:09 <Nevoic> It sounds like Kevin from the office talking.
22:52:14 <Cale> Python only gets this one vaguely right by way of cheating and baking in a language primitive
22:52:14 <Nevoic> He's taking out unimportant words.
22:53:00 <Nevoic> I mean that makes no difference to me, at all.
22:53:01 <Cale> But Python programmers don't generally do higher order stuff.
22:53:12 <Nevoic> Yes, and for programmers that sucks. I hate their lambda implementation.
22:53:19 <Nevoic> It's garbage.
22:53:22 <Nevoic> I hate Python generally speaking too.
22:53:25 <Nevoic> But it's readable.
22:53:38 <Nevoic> I'm just challenging your idea that readability is this vague notion that can't really be captured because it's different for everybody.
22:53:40 <Cale> You say that, but I've seen python scripts that people write
22:53:45 <Nevoic> There are readable bits of code, and there are not readable bits of code.
22:53:46 <Cale> and it's... not always pretty
22:53:54 <Nevoic> A lot of Python code can look like shit, like other languages.
22:54:01 <Nevoic> But my point was that short Python scripts read like English.
22:54:10 <dmwit> "Readable Python is readable."
22:54:11 <dmwit> Okay.
22:54:26 <Nevoic> Yes. I'd even go as far to say Readable Python is more readable than readable Haskell.
22:54:28 <Nevoic> That's kind of my point.
22:54:47 <Nevoic> I'd still prefer to work in Haskell because I already appreciate language constructs that it has more than Python.
22:54:49 <Cale> You could pull more tricks to make Haskell readable to non-Haskell programmers
22:55:16 <Cale> At least, they'd think they understood the code ;)
22:55:59 <Cale> But yeah, Haskell isn't optimised for readability for people who know other imperative languages, or for people who don't know how to program at all.
22:56:11 <Nevoic> Yeah, it's optimized for people who know Haskell.
22:56:12 <Nevoic> Or math.
22:56:16 <dmwit> Nevoic: I have two papers to recommend. The first is Simon Peyton-Jones' "Composing contracts: an adventure in financial engineering".
22:56:17 <Nevoic> Of which I know neither.
22:56:28 <dmwit> The second I'll have to search a bit. It's about doing flight planning or something.
22:56:39 <Cale> Haskell moreso than math. I was working on a degree in pure mathematics when I picked up Haskell.
22:56:41 <dmwit> I challenge you to read these two papers and say that Haskell can't be readable.
22:56:43 <yushyin> we could have used forM_ in the previous example!
22:56:57 <Cale> I liked Haskell immediately because of its mathematical approach to things
22:57:04 <Cale> but the syntax was not familiar
22:57:11 <dmwit> And I will also say this: most Haskell is written to be readable by Haskell experts, not non-Haskellers, and yes it shows.
22:57:27 <Nevoic> All languages will be readable by experts of said language.
22:57:31 <dmwit> That is part of why I recommend these two papers: they were written in part to be readable by folks not steeped in Haskell lore.
22:58:19 <Cale> One of my main job functions now is just making sure that all the more junior Haskell developers stick to more basic idioms and don't write incomprehensible nonsense with lenses.
22:58:41 <Cale> It's funny
22:59:24 <Cale> Like, these are "advanced" things, but eventually, you just get weary of people writing shit with traversals that typechecks and doesn't do at all the right thing.
23:00:24 <Cale> and you're like "come on, just use a damn list comprehension and basic functions from Data.Map and write the code in a way that is obviously correct"
23:01:29 <johnw> Cale: lol
23:01:30 <Nevoic> Yes, I probably came off like an ass, sorry. It's just I thought we had JSON traversals figured out tbh. I didn't know a paradigm shift meant that there'd not be a library that I'd be capable of using to parse JSON data.
23:01:34 <Cale> I have a very high tolerance for case expressions and explicit pattern matching as well, particularly in real world applications.
23:01:53 <johnw> Cale: how about higher-order functions, like functions in data structures?
23:02:06 <Cale> johnw: It depends on what they're buying you.
23:02:11 <johnw> fair
23:02:12 <dmwit> Nevoic: The other paper is "Haskell vs. Ada vs. C++ vs. Awk vs. ...: An Experiment in Software Prototyping Productivity" by Paul Hudak and Mark P. Jones.
23:02:14 <Cale> Like, that can be entirely fine.
23:02:17 <dmwit> https://www.cse.iitk.ac.in/users/karkare/courses/2010/cs653/Papers/hudak_haskell_sw_prototype.pdf
23:02:35 <johnw> Cale: I wonder if the hnix codebase would violate all of your rules, although we don't use lenses at all
23:02:41 <Nevoic> That paper is from 1994 dmwit.
23:02:43 <Nevoic> That's before I was born lol
23:02:51 <johnw> but we abuse the living hell out of AllowAmbiguousTypes and TypeApplications
23:02:56 <dmwit> It describes the story of a paper rejected because "it only had pseudcode, with no clear indication of how it could be turned into an executable program".
23:03:03 <dmwit> The pseudocode was (yes, executable) Haskell code.
23:03:05 <Cale> johnw: I don't know, like, I'm also thinking of code which is very different from a language implementation.
23:03:23 <Cale> johnw: A language implementation is way closer to a piece of mathematics than the code I'm thinking of
23:03:32 <dmwit> Nevoic: Yep. People have been debating readability a long time. If you think you have new thoughts in the area... think again. =)
23:03:32 <johnw> ah, "standard production code" should be utterly basic, unless the abstract really buys you something
23:03:43 <Cale> Yeah, exactly.
23:03:46 <johnw> plain functions and data go a really long way, the more purity the better
23:04:08 <johnw> if you have an urge for fanciness, put it into your testing code
23:04:15 <im0nde> Hi, I would like to write a simple matrix (matrix.org) bot. It has a http REST-api, what package would you recommend do make simple http requests? 
23:04:42 <johnw> http-client
23:04:48 <Nevoic> I'm not saying these words because I think my thoughts are extraordinary and need to be shared with the world, I'm saying these words because I recognize my limited capacity to understand things, and am sharing ideas with other humans who have a limited capacity to understand things in the hopes that we exchange knowledge about things dmwit
23:05:04 <Nevoic> So no, I don't think I have new thoughts in the area.
23:06:25 <Cale> Nevoic: If you do happen to find a library for scraping JSON that you really like, or you end up writing one, let me know, so that I know what to recommend in that direction.
23:07:13 <Nevoic> Alright. It is entirely possible that Haskell doesn't have any good libraries for it, and that wouldn't really be a language level short coming.
23:07:27 <Cale> Nevoic: I'm already pretty convinced for a bunch of reasons that Aeson could use a rework. It's trying too hard to be too many things at once. There are really at least 3 different libraries that you'd want for parsing and producing JSON.
23:07:40 <Cale> One for scraping bits and pieces out and parsing incompletely
23:07:41 <Nevoic> I recognize Haskell isn't as popular as say Java or Python so it might not be fair of me to expect the same level of work put into libraries.
23:07:57 <Cale> One for more completely implementing a *specified* interface
23:08:21 <Cale> and one for when you don't actually care what your JSON looks like, you just want to serialise and deserialise Haskell data structures
23:08:44 <Cale> Aeson is trying to do the second two of those three, and they get in the way of each other a bit
23:08:54 <Cale> I only care about the third one
23:09:02 <Cale> because all my frontends are also written in Haskell ;)
23:09:16 <Cale> (Not entirely true, but pretty true)
23:09:46 <Cale> For example, the ToJSON and FromJSON instances for Maybe in aeson encode Nothing as null
23:10:10 <Cale> This is a disaster. I really think this should be considered a very high priority bug.
23:10:33 <Cale> The problem is that if you have something of type Maybe (Maybe a), and you ship it across the wire
23:10:43 <Cale> Just Nothing and Nothing encode to the same thing
23:11:06 <Cale> similarly if you have Maybe applied to any other type which can encode something as null
23:11:16 <Nevoic> That actually sounds pretty terrible lol
23:12:02 <Cale> But it comes about because aeson is halfway trying to make it easy to define Haskell datatypes which correspond to your JSON format and automatically derive instances that parse all the JSON correctly without writing anything by hand
23:12:06 <Cale> (apart from the types)
23:12:21 <Nevoic> Yeah, but that's not groundbreaking either xd
23:12:22 <Cale> So they just used Maybe in order to mean "nullable thing in the JSON I'm trying to parse"
23:12:28 <Nevoic> Especially if they're not doing it correctly.
23:12:48 <Cale> It's perhaps the correct thing if you don't really care about round-tripping as much.
23:13:09 <Cale> But I wish they had some other data type for it, not the standard Maybe
23:13:24 <Cale> But for me, round tripping is literally the only thing that matters
23:13:51 <Nevoic> I'm fairly sure Kotlin has that capacity as well (automatically derive "instances" that parse all the JSON correctly without writing anything by hand).
23:14:11 <Cale> I could use binary serialisation, and the only reason I don't is that browsers won't show you binary websocket frames in any kind of approximately readable way (or at all) when you're trying to debug stuff
23:14:37 <Nevoic> Like if you have a class:
23:14:37 <Nevoic> class Person(val name: String, val age: Int)
23:14:54 <Nevoic> all you need is to do: Klaxon().parse<Person>(json)
23:15:07 <Cale> Yeah, rather like that
23:15:11 <Nevoic> Not a lot of boiler plate tbh (that's the entire class definition above too, constructor getter/setters etc.)
23:15:27 <Nevoic> That class definition would be like 20 lines in Java.
23:16:08 <Cale> There are two ways to make it happen in Aeson -- there's deriving Generic on your data types, and then just write blank ToJSON and FromJSON instances and the default class methods will give you a standard encoding
23:16:27 <Cale> and then there's some template haskell code which can write instances, and is more configurable
23:16:48 <Cale> (basically compile-time macros)
23:16:58 <Nevoic> They're more like Rust and not C right?
23:17:03 <Nevoic> not text based?
23:17:08 <Cale> They're syntax tree based
23:17:12 <Nevoic> nice
23:17:40 <Cale> http://hackage.haskell.org/package/aeson-1.4.2.0/docs/Data-Aeson-TH.html
23:18:24 <Cale> It gives you the ability to apply some functions to the names of data constructors and field names
23:18:49 <Cale> It's funny that the docs don't actually show any generated output
23:19:02 <Nevoic> That reminds me, I also like Haskell's `|` for defining types.
23:19:05 <Nevoic> or data, whatever.
23:19:10 <Cale> yeah
23:19:16 <Cale> "types" is the right word
23:19:22 <Nevoic> Cool
23:19:32 <Cale> It's just funny that we use the type keyword for defining type aliases
23:19:43 <Nevoic> Yeah that all confused me. They really threw me in a circle with that.
23:19:57 <Nevoic> And choosing `instance` for what is practically simple subclassing
23:20:10 <Cale> ehhhh
23:20:10 <Nevoic> like I know it doesn't do everything OOP subclassing does.
23:20:16 <Cale> Well, type classes are pretty damn different
23:20:24 <Cale> They're more like Java interfaces
23:20:33 <Cale> only they don't count as types
23:20:39 <Cale> they only constrain type variables
23:20:46 <Nevoic> typeclasses don't count as types?
23:20:50 <Cale> correct
23:20:54 <Nevoic> wut
23:20:57 <Cale> :t sort
23:20:58 <lambdabot> Ord a => [a] -> [a]
23:21:00 <Nevoic> How would you even define an abstraction then?
23:21:07 <Nevoic> Like an "object" lol
23:21:07 <Cale> You're not allowed to write [Ord] -> [Ord]
23:21:12 <Nevoic> I don't know how else to phrase it.
23:21:19 <Cale> :t (+)
23:21:20 <lambdabot> Num a => a -> a -> a
23:21:32 <Cale> That's not Num -> Num -> Num (nor is that legal)
23:21:35 <Nevoic> I know methods are abstractions, but like say I want to define a Bot that has 3 functions on it.
23:21:46 <Nevoic> Abstractly though.
23:21:53 <Nevoic> So I say "to be a Bot you have to have these 3 functions"
23:21:55 <jackdk> they have different kinds.
23:21:57 <Cale> The other weird thing is that instances travel separately from the data they pertain to
23:22:00 <jackdk> :kind! Ord
23:22:03 <Cale> :t read
23:22:04 <lambdabot> Read a => String -> a
23:22:08 <Cale> ^^ you can't do this in OO
23:22:19 <Nevoic> Can't do what?
23:22:29 <Nevoic> read?
23:22:29 <Cale> The type of the *result* of read is polymorphic, and which function it uses to parse depends on its type
23:22:42 <jackdk> % :kind! Ord
23:22:42 <yahb> jackdk: Ord :: * -> Constraint; = Ord
23:22:48 <Cale> > read "5" :: Integer
23:22:49 <lambdabot>  5
23:22:56 <Cale> > read "[5,4,5]" :: Integer
23:22:56 <Nevoic> How is that different from: fun <A> read(s: String): A ?
23:22:57 <lambdabot>  *Exception: Prelude.read: no parse
23:23:01 <Cale> > read "[5,4,5]" :: [Integer]
23:23:03 <lambdabot>  [5,4,5]
23:23:24 <Nevoic> or wait, read is the name of the type, right?
23:23:28 <Nevoic> not a function?
23:23:31 <Cale> read is the name of the function
23:23:34 <Cale> but it's not a single function
23:23:49 <Cale> It's implemented separately for each type
23:23:50 <Nevoic> why'd you do :t then?
23:23:54 <Nevoic> I thought :t was type
23:23:59 <Nevoic> oh wait functions have types
23:24:00 <Nevoic> nvm
23:24:02 <Cale> That asks for the type of something
23:24:21 <Nevoic> So how's that different from the code I posted ?
23:24:28 <Nevoic> fun <A> read (s: String): A
23:24:30 <Cale> Well, it doesn't work for any type A
23:24:44 <Cale> It only works for types A that are instances of this type class called Read
23:25:00 <Cale> :t sort
23:25:01 <lambdabot> Ord a => [a] -> [a]
23:25:14 <Nevoic> You're going to have to forgive me, but "instances" still trips me up.
23:25:21 <Nevoic> Because instances means something very distinct in other languages.
23:25:24 <Nevoic> And pretty consistently too.
23:25:37 <Cale> sort works for any type a for which there is an instance of Ord, which means that we've implemented the ordering operations like (<=)
23:25:52 <Cale> and it takes a list of values of type a and produces another such list of values of the same type
23:25:57 <Nevoic> Even in other functional languages, I think "instance" means what it means in imperative languages.
23:26:07 <Nevoic> like F# I think they use "instance" the same way C# does.
23:26:09 <Cale> Depends on the language
23:26:22 <Nevoic> Haskell is the only language I've come across that completely changed the meaning of instance.
23:26:26 <Nevoic> And I still don't understand what it is lol
23:26:29 <Cale> F# is a CLR language, so of course they're going to use the same terminology as all the other CLR languages
23:26:49 <Nevoic> It's also an ML language though.
23:26:54 <Cale> Yeah
23:27:23 <Cale> There are a few languages with some variant of type classes now
23:27:27 <Cale> Haskell was the first
23:27:32 <Nevoic> OCaml also has "instances" that mean what they mean in imperative languages (although OCaml is more like Scala than Haskell)
23:27:42 <Cale> Actually, all of Java's generics came from Haskell, lol
23:27:54 <Cale> Phil Wadler, who was involved in creating Haskell worked on Java later
23:28:00 <Nevoic> Alright, well what is an instance?
23:28:05 <Nevoic> It's not a subclass.
23:28:11 <Nevoic> or even a subtype.
23:28:13 <Nevoic> It sounds like.
23:28:30 <Cale> Okay, so what's a type class, first of all
23:28:49 <Nevoic> idk
23:29:04 <Cale> A type class is like a predicate on types, you can think of it as something a type may or may not satisfy
23:29:41 <Nevoic> I feel like you described a refinement type more-so.
23:29:44 <Cale> and when a type belongs to a type class, or satisfies that predicate, it means that we've implemented certain functionality in terms of it
23:29:54 <Nevoic> I think they literally have types depend on predicates.
23:29:54 <Cale> So for example
23:29:58 <Cale> There's a type class Eq
23:30:03 <Cale> class Eq a where
23:30:08 <Cale>   (==) :: a -> a -> Bool
23:30:13 <Cale>   (/=) :: a -> a -> Bool
23:30:54 <Cale> and then it has a subclass called Ord:
23:30:59 <Cale> class Eq a => Ord a where
23:31:08 <Cale>   (<=) :: a -> a -> Bool
23:31:14 <Cale>   compare :: a -> a -> Ordering
23:31:21 <Cale>   ... other ordering operations ...
23:31:40 <Cale> When we define a new data type, we can say how the operations like (==) work on it
23:31:47 <Cale> by writing an instance
23:32:14 <Cale> which will make our type satisfy the Eq class, i.e.  Eq MyType  is something that the compiler will be happy about
23:32:39 <Cale> data MyType = A | B | C
23:32:43 <Cale> instance Eq MyType where
23:32:51 <Cale>   A == A = True
23:32:58 <Nevoic> everything you've described so far could be described via interfaces and a concrete class, unless I'm missing something.
23:33:03 <Cale>   A == B = True -- whoops, lol
23:33:07 <Cale> etc. etc.
23:33:25 <Nevoic> Except for the `data` specifically, since that's using `|`.
23:33:25 <Cale> Everything so far is kind of like interfaces, yes
23:33:36 <Nevoic> I mean I'd go as far to say exactly the same as interfaces.
23:33:49 <Cale> There are a bunch of differences... type classes may have multiple type arguments
23:33:51 <Nevoic> What have you already specified that's different from interfaces?
23:33:56 <Cale> and so relate different types with each other
23:34:19 <Nevoic> You mean a type class can be parameterized over multiple types?
23:34:24 <Cale> Okay, so one difference already
23:34:36 <Cale> Is that interfaces say that objects will have certain fields, pretty much
23:34:44 <Cale> That is not what we're saying here
23:34:46 <Nevoic> Java/Kotlin interfaces can have multiple generic types.
23:34:57 <Cale> We're not shoving implementations of equality into the A data constructor
23:34:59 <Nevoic> interfaces don't specify fields, they specify functions.
23:35:25 <Cale> Well, sure, but the stuff they specify is ultimately part of the objects described by the classes that meet the interface
23:35:51 <Cale> So we're talking about pieces of our values of some type
23:36:12 <Cale> type classes aren't really like that -- we transmit the type class methods *separately* from the data they act on
23:36:33 <Cale> This may seem like a minor point
23:36:39 <Nevoic> It seems like a made up point, actually.
23:36:40 <Nevoic> ll
23:36:44 <Nevoic> lol*
23:36:44 <Cale> haha
23:36:50 <Cale> But look how awkward equality is in something like Java
23:36:55 <Cale> It's asymmetrical
23:37:16 <Cale> One of the objects knows how to compare itself with another
23:37:37 <Cale> and which implementation of equality you get actually kind of depends on which object is doing the comparing
23:37:49 <Cale> Maybe not too important with equality
23:37:58 <Cale> But with other operations, it can be pretty important.
23:38:08 <Nevoic> I have actually no idea what you're talking about.
23:38:11 <Nevoic> lol
23:38:15 <Cale> I'm talking about a.equals(b)
23:38:24 <Nevoic> Yeah, but you could also do b.equals(a)
23:38:29 <Cale> Indeed you could!
23:38:35 <Cale> And it may not even be the same thing
23:38:41 <Cale> Because b is a different object from a
23:38:49 <Cale> and may contain a different implementation of equals
23:39:12 <fr33domlover> Hey Nevoic! I'd like to recommend that you learn Haskell without comparing to other languages, just take it as-is, and you can compare later once you have a good grasp of the concepts
23:39:33 <Cale> I'm enjoying this comparison though :D
23:39:37 <Nevoic> Same lol
23:39:41 <Cale> I think it's good to contrast these things
23:39:49 <Nevoic> I've never understood the mindset that it's bad to compare.
23:39:52 <Cale> Another difference: type classes may have multiple parameters
23:39:56 <Nevoic> I feel like only languages that have something to hide don't like comparing things.
23:40:09 <Cale> class VectorSpace s v where
23:40:16 <Cale>   (.+.) :: v -> v -> v
23:40:24 <Cale>   (*.) :: s -> v -> v
23:40:33 <fr33domlover> Well it often gets in the way of people's learning. Not always, but often, so compare if it doesn't bring you confusion :)
23:40:46 <Cale>   negateV :: v -> v
23:40:50 <Cale> zeroV :: v
23:40:53 <Cale> oops
23:41:00 <Cale> you get the idea, perhaps
23:41:24 <Cale> So, the idea is that we can define a relationship saying that v is a vector space with scalar type s
23:41:42 <Cale> We can also put a functional dependency on that:
23:41:52 <Cale> class VectorSpace s v | v -> s where ...
23:42:00 <Nevoic> I was thinking about the equals thing, and I think a crucial difference is that `Eq` would limit the usability of comparisons to just that type. You could do the exact same thing in a class though.
23:42:12 <Cale> Oh, indeed it does
23:42:16 <Cale> :t (==)
23:42:17 <lambdabot> Eq a => a -> a -> Bool
23:42:20 <Nevoic> You could say `fun eq(other: ThisType)` and it will only compile with that type.
23:42:34 <Cale> If you use (==) to compare two values in Haskell, they must have the same type to begin with.
23:42:35 <Nevoic> You could even write equals generically on Object to do exactly that (and only compare A to A)
23:42:58 <Cale> Let's actually, before going to fundeps and all that, let's look at read
23:43:07 <Cale> class Read a where
23:43:24 <Cale>   readsPrec :: Int -> String -> [(a, String)]
23:43:28 <Nevoic> That's an implementation detail of Eq though, not a language construct.
23:43:52 <Nevoic> In practice, the same kind of t hing won't work in most good static languages
23:43:53 <Nevoic> https://cdn.discordapp.com/attachments/496210024498987009/562527454175166465/unknown.png
23:43:59 <Nevoic> That's Kotlin.
23:44:11 <Nevoic> It's complaining about a type mismatch.
23:44:18 <Cale> Indeed, that is an implementation detail of Eq
23:44:33 <Cale> we could add a second type parameter to Eq, and let it compare things of different types
23:44:42 <Nevoic> So what's the advantage that type classes, as a level of abstraction, have over interfaces?
23:44:51 <Cale> but in practice that's less convenient because you'll have to say what more of those types are -- type inference will be less helpful
23:44:51 <Nevoic> Instead of comparing Eq to Comparable?
23:44:53 <Nevoic> I'd agree Eq is better.
23:45:29 <Cale> Nevoic: But really, that doesn't quite get at what I want to explain... let's look at Ord, and let me point out a property that type classes have
23:45:38 <Cale> So, Ord provides ordering operations
23:45:38 <Nevoic> alright
23:46:07 <Cale> Type classes have the property that if an instance exists in scope for a given type, it must essentially be unique.
23:46:32 <Nevoic> "it"?
23:46:35 <Cale> You're not allowed to define two conflicting instances of Ord for, I dunno, Integer or something
23:46:36 <Nevoic> The instance declaration?
23:46:55 <Cale> If I try to write  instance Ord Integer where compare = ....
23:47:05 <Cale> The compiler will complain that there's already an instance
23:47:18 <Cale> This may seem like a limitation, and it is, in some ways
23:47:38 <Nevoic> I don't see it as a limitation.
23:47:41 <Nevoic> I don't even see it as a difference.
23:47:46 <Cale> But it allows data structure implementations to know that wherever they get an Ord instance, it's going to coherently make the same decisions
23:48:04 <dminuoso> Nevoic: Consider Monoid.
23:48:06 <Cale> So we have a library in Haskell called Data.Set
23:48:19 <Nevoic> I have no idea what a monoid is.
23:48:20 <dminuoso> Nevoic: Or Semigroup even. There's often multiple valid instances one could pick for a type.
23:48:24 <Cale> :t Data.Set.insert
23:48:25 <lambdabot> Ord a => a -> S.Set a -> S.Set a
23:48:27 <Nevoic> I never took a class on category theory.
23:48:36 <dminuoso> Nevoic: It's just basic high school algebra in disguise.
23:48:45 <Nevoic> The disguise is good enough to confuse me.
23:48:46 <Cale> ^^ it relies on the ordering on values of type a to determine where to insert the values in a balanced tree structure
23:49:05 <Cale> If there could be more than one such ordering, you'd end up with fucked up Sets and be very very unhappy.
23:49:11 <dminuoso> Nevoic: A semigroup is, in Haskell terms, just a single function `(<>) :: Semigroup a => a -> a -> a`, so a way to combine two values together (in an associative ways).
23:49:16 <Nevoic> Cale that makes sense.
23:49:31 <dminuoso> Nevoic: Two semigroups you have learned in highschool is addition over the set of natural/integer numbers. Multiplication too is a valid case
23:49:32 <Cale> Nevoic: So, it's quite important that the instances are in some way "globally determined"
23:49:57 <Cale> The reason type classes exist is to make conventional choices about how we're going to implement certain operations
23:49:58 <Nevoic> Cale But I think that limitation exists in other languages too, if you look at the typeclass /instance dichotomy as a replacement for interface/class then that same limitation exists.
23:50:08 <dminuoso> Nevoic: So if you were to write `instance Semigroup Integer`, would you pick multiplication? Would you pick addition? Turns out both make plenty of sense, being limited to just one type can be annoying in some sense.
23:50:20 <Nevoic> You can only implement an instance for a type one time, and you can only implement an interface for a class one time.
23:50:22 <Cale> Well, no, in an OO language, I can always make a subclass and reimplement the operations on an object-by-object (value by value) basis
23:50:36 <Cale> Unless it's a final class
23:50:59 <Nevoic> That's a fair point, all classes in Kotlin are final by default so I kind of got used to that.
23:51:04 <Nevoic> Forgot the default in Java was the opposite.
23:51:07 <Cale> Or in prototypical OO, it's even more clear that I can just put whatever method implementations in that I want.
23:51:48 <dminuoso> Nevoic: (And to close the circle, a Monoid is just an "upgraded" Semigroup in which you have an identity element. So for integer addition that would be `0`, and for integer multiplication `1`)
23:51:57 <fr33domlover> Nevoic, I'm not sure typeclasses and interfaces fill the same roles, they're different features, something done with interfaces in OO won't necessarily be done with typeclasses in a functional language and vice versa
23:52:11 <Nevoic> Cale I'd also clarify it's not reimplementing the operations on an object-by-object basis, you're reimplementing them on a class by class basis.
23:52:37 <Cale> yes, but the objects may all be of different subclasses
23:52:42 <Nevoic> Yee
23:52:49 <Cale> Classes are really a red herring to OO in my opinion :D
23:53:10 <Cale> They're a hack to make the language implementations easy back in the 1960s
23:53:12 <Nevoic> I rarely, rarely use open classes though
23:53:15 <Nevoic> (opposite of final)
23:53:19 <Cale> that has been carried forward into the present day
23:53:38 <Nevoic> I'm mean they've been refined to a ridiculous level though.
23:53:44 <Cale> Yes
23:53:46 <dminuoso> Cale: When people talk about OO there's two kinds: those who talk about OO in the sense of Smalltalk (where you have strong encapsulation, internal state and external communication with messages of some kind), and those who talk about OO in the sense of Java classes.
23:53:50 <Nevoic> The level of practical development you can do in Kotlin is kind of insane compared to like C.
23:53:57 <dminuoso> I dont think either is wrong, you just have to identity which group someone is from.
23:54:01 <Nevoic> You can define what would take 200 lines of C code inside of like 10 Kotlin lines.
23:54:07 <Cale> Yeah, I tend to think in terms of Smalltalk when I think about OO
23:54:19 <Cale> Even if I speak Java words sometimes
23:54:30 <Nevoic> I tend to be talking about Java.
23:54:45 <Cale> Or secretly now, I'm thinking about encodings of OO into Haskell
23:54:56 <Cale> Where you just use records of functions :D
23:55:24 <Cale> But that doesn't quite cover the whole comparison with interfaces and whatnot
23:55:51 <fr33domlover> Extensible exceptions are an example of building a hierarchy of types in Haskell
23:55:59 <Nevoic> I think one, large, practical point I want to hit before I go off to bed:
23:56:22 <Cale> Let me also touch on Read once more
23:56:30 <Nevoic> What should I be replacing interfaces with? Specifically interfaces that I use constantly throughout a large section of my codebase, and then have multiple implementations for in the presentation or data layer.
23:56:34 <Cale> Let's pretend it's simpler than it is
23:56:41 <Cale> class Read a where
23:56:45 <Cale>   read :: String -> a
23:57:01 <Cale> (it's not actually defined that way, since read throws exceptions when failing and you almost never want that)
23:57:13 <dminuoso> Nevoic: Module boundaries serve nicely as interfaces.
23:57:35 <Cale> You *might* use a type class.
23:57:38 <dminuoso> Nevoic: Where you might require a consumer of your server to pass a saturated record of functions/values.
23:57:49 <Cale> Modules get you encapsulation.
23:57:59 <Cale> Just by not exporting data constructors
23:58:11 <fr33domlover> Nevoic, in my uneducated opinion, if you reimplement an OO program in Haskell/FP the components may entirely change, idk how useful it is to think in terms of replacing stuff one by one
23:58:37 <Nevoic> Alright, well then I'll just speak to a practical effect I want, instead of asking for a language level replacement.
23:58:46 <Cale> But it's useful to think that way a little bit when you're starting out, because you're relearning how to architect programs.
23:59:03 <Cale> Maybe you'll be lead to do some suboptimal things
23:59:10 <Cale> but eh, at least you'll have something
23:59:11 <Nevoic> I was able to write all my code to non-concrete types in a way that made a ton of sense. I actually wrote my entire domain without using a single class, all functions and interfaces.
23:59:40 <Nevoic> And I required well-defined very  readable interfaces (Bot, Channel, etc.) for my chat bot.
23:59:43 <Cale> Right, so definitely, you can write libraries like that in Haskell
23:59:54 <Cale> Where you specify the primitives of your interface with type classes
