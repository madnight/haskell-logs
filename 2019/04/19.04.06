00:28:47 * hackage eventstore 1.2.4 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-1.2.4 (YorickLaupa)
01:05:47 * hackage yiyd 1.0.0 -   https://hackage.haskell.org/package/yiyd-1.0.0 (vonfry)
01:09:17 * hackage dynamic 0.1.0 - A dynamic type for Haskell  https://hackage.haskell.org/package/dynamic-0.1.0 (ChrisDone)
01:10:11 <im0nde> So I added "ConfigFile" to my stack's package.yaml but now I'm getting "ConfigFile needed, but the stack configuration has no specified version  (latest matching version is 1.1.4)"
01:10:42 <im0nde> What is it trying to tell me? I tried to specify a specific version, but I can't get it to compile
01:11:29 <im0nde> Why do I need a version? I added other packages to dependencies: before and it worked just fine
02:11:47 * hackage ghcjs-dom-jsffi 0.9.4.0 - DOM library using JSFFI and GHCJS  https://hackage.haskell.org/package/ghcjs-dom-jsffi-0.9.4.0 (HamishMackenzie)
02:12:48 * hackage ghcjs-dom 0.9.4.0, ghcjs-dom-jsaddle 0.9.4.0 (HamishMackenzie): https://qbin.io/urls-monkey-2wpa
02:28:19 <akr> I have a script that I would normally execute with stack, but the startup time is horrendous
02:28:26 <akr> how do I build an executable out of this scripts?
02:28:51 <akr> alternatively, is there something like a stack server which would run as a daemon and execute scripts?
02:33:23 <im0nde> Nevermind, found my error. I was putting them into package.yaml, not in stack.yaml
02:56:58 <im0nde> Got another question though: Why can I not print strings read from a config like this: https://gist.github.com/binaryplease/99a52e7d8573615609d4ea9b5dc8e506
02:57:15 <im0nde> The putStrLn lines throw an error
02:58:56 <asheshambasta> So, given my lens-foo isn't on point yet, I'm doing some things like `%%~ const (m newVal)` (not actual code); is there a way to get rid of the const and just treat it as an assignment? What I'm trying to ask is: what operator (other than %%~) does that? 
03:17:44 <ski> im0nde : `putStrLn' is a function that wants a `String' as input, but `matrixUser' and `matrixPass' are not `String's. they're `IO String's
03:21:08 <ski> oh, actually, they are not even `IO String's, i see after looking slightly closer at the code
03:21:26 <ski> they are `IO Value's
03:22:21 <ski> so you should probably use `print' instead of `putStrLn' - and then you get back to the mismatch between `Value' and `IO Value'
03:22:54 <ski> `print' can accept a `Value' (assuming `Value' has a `Show' instance. but there's no sensible `Show' instance for `IO Value')
03:23:49 <ski> a result of type `IO Value' is like a recipe that, if you perform it with appropriate ingredients, you'll (hopefully) get a `Value' in the end
03:24:13 <ski> but you shouldn't confuse the recipe with the end result of using the recipe
03:24:38 <ski> @quote is.not.the.cake
03:24:38 <lambdabot> ski says: <ski> `getLine :: IO String' is a recipe for how to interact with the world to acquire a `String'  <ski> the recipe is not the cake
03:25:05 <ski> (in your case you have `Value' in place of `String', but the issue is the same)
03:27:11 <ski> what you need to do is to paste the "recipe"s, `matrixPass' and `matrixUser', both of type `IO Value', together with the "processing continuation-function" `print', in this case of type `Value -> IO ()'
03:28:06 <ski> you can do this as `print =<< matrixPass' and `print =<< matrixUser', since `(=<<) :: (a -> IO b) -> IO a -> IO b' (in this case `a' will be `Value', and `b' will be `()')
03:28:44 <ski> (or equivalently, you can do `matrixPass >>= print' and `matrixUser >>= print', since `(>>=) :: IO a -> (a -> IO b) -> IO b')
03:30:52 <ski> `(=<<)'/`(>>=)' "pastes" the two components together into a larger "recipe" that, when executed/performed, will first perform the recipe of type `IO a', yielding an intermediate result of type `a', which is then passed to the callback function argument, of type `a -> IO b' (in your case that's `print'), getting back another action/"recipe", of type `IO b', which is then performed/executed to yield a result of type `b', which is taken to be the overall end r
03:31:16 <ski> (hrm, possibly that got cut off near the end : ".., which is taken to be the overall end result of the compound action/recipe")
03:31:38 <ski> you could think of `(>>=)' as being defined like
03:31:55 <ski>   act >>= continue = do intermediateResult <- act
03:32:16 <ski>                         overallResult <- continue intermediateResult
03:32:22 <ski>                         return overallResult
03:32:28 <ski> which is the same thing as
03:32:31 <ski>   act >>= continue = do intermediateResult <- act
03:32:36 <ski>                         continue intermediateResult
03:32:49 <ski> iow, instead of
03:32:56 <ski>   matrixAccessToken = do
03:33:13 <ski>     print =<< matrixPass
03:33:15 <ski>     print =<< matrixUser
03:33:21 <ski> you could also have said
03:33:41 <ski>   matrixAccessToken = do
03:33:51 <ski>     passValue <- matrixPass
03:33:57 <ski>     print passValue
03:34:05 <ski>     userValue <- matrixUser
03:34:11 <ski>     print userValue
03:35:38 <ski> this makes it clear in what order the four effects will happen in, the `load' and `require's (inside `matrixUser' and `matrixPass') being interleaved with the `print's (in a particular way)
03:37:38 <ski> if you instead had used `foo matrixPass', and then `foo matrixUser' (in that order), then you'd not be passing the *results* of executing `matrixPass' and `matrixUser' to `foo', but rather you'd be passing those "recipes" / actions *themselves* to `foo', which could then decide to perform those as many times as it liked, perhaps interleaved with other actions. it could even register them to not be executed now, but at some later time
03:38:01 <ski> (because that's a kind of thing you can do in `IO')
04:17:51 <deathcap> While we're on the topic, another newb question from reading LYAH. In the Input and Output chapter, they refer to "IO a" as an I/O action with a result type a, rather than strictly a type constructor. Other than the distinction needing to be made because of impurity, is there any particular reason for this? Or do I just need to keep on reading?
04:29:08 <tdammers> IO isn't impure, it's really just another type constructor
04:29:38 <tdammers> IO a is not an IO action, it is a *type*, and values of that type are IO actions
04:30:14 <tdammers> the IO type constructor isn't magical; its values are, but not as much as you'd think
04:30:17 <deathcap> Ahhh, okay!
04:30:27 <deathcap> ty. I'll keep on reading.
04:30:37 <tdammers> the magic, in fact, isn't embedded in the values themselves, it's that the RTS (runtime system) treats them specially
04:31:03 <tdammers> LYAH is a bit sloppy with things like these, which may occasionally lead to confusion
04:31:51 <deathcap> Are there any free books after this primer than would be good choices to get a bit further info from? I've heard good things about Real World Haskell.
04:35:58 <Solonarv> there's a wikibook too, and I've seen Hutton's book recommended too
04:35:58 <Solonarv> @where wikibook
04:35:58 <Solonarv> @where pih
04:35:58 <lambdabot> http://en.wikibooks.org/wiki/Haskell
04:35:58 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
04:36:27 <deathcap> lovely, thank you!
04:42:47 * hackage HDBC-odbc 2.5.1.1 - ODBC driver for HDBC  https://hackage.haskell.org/package/HDBC-odbc-2.5.1.1 (anton_dessiatov)
04:45:51 <ski> @where CIS194
04:45:51 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
04:46:02 <ski> deathcap : that ^ also has exercises you could try
04:47:09 <im0nde> ski: Thanks for the detailed explanation! One thing though, when I try to write it like "passValue <- matrixPass" and "print passValue" I get an error saying the last statement in a do block should be an expression. What is the compiler trying to say here?  In the end printig it was just a try to see if the values are read correctly. What I really want to do is read the values to a string to be able to use
04:47:11 <im0nde> them later, i.e. write a functino that returns the pass and one that returns the username
04:49:11 <ski> im0nde : perhaps you're mseeing up indentation, somehow ?
04:49:24 <ski> im0nde : if you could paste the relevant code so we could have a look ?
04:49:32 <ski> s/mseeing/messing/
04:50:13 <im0nde> ski: Oh right, i had a tab instead of spaces there!
04:51:17 <ski> yeah, you *can* use tabs for indentation, but you have to be quite careful and disciplined with it, if you decide to do that
04:51:29 <im0nde> ski: on my last question for now: how do I "return" (is that even a thing in haskell?) a string from the function instead of printing it?
04:51:57 <im0nde> ski: Didn't do it on purpouse, seems my vim assumes it should indent with tabs when adding a line
04:52:40 <ski> basically, you have to *only* use tabs for indentation, and also make sure to always break line after a layout-introducing keyword (like `do',`where',`let',`of') followed by more than one "item" (roughly speaking, a "line")
04:53:06 <ski> im0nde : use `return str' instead of `putStrLn str', at the end of the `do'-block
04:53:28 <ski> note that `return x' doesn't cause the `do'-block execution to be aborted, and the value `x' presented as the result
04:54:00 <im0nde> I see.
04:54:30 <ski> `return x' just packages the result value `x' up in an action, that, *if* you place it at the end, as the last command, of a `do'-expression, will cause the execution of said block to yield the value `x' at the end (in case execution ever reaches that far, that it. one could abort with exceptions and the like)
04:55:56 <Solonarv> ...note that 'x <- foo; return x' at the end of a do block is the same thing as just 'foo'
04:56:27 <Solonarv> and also, 'return x; other stuff' is the same thing as just 'other stuff'
04:56:29 <ski> in particular, this means that if you have a `return x' "in the middle" (perhaps inside an `if'-`then'-`else', or call to `when' or `unless'), that will not abort the `do'-block execution, so will effectively be a no-op (apart from yielding `x' as an *intermediate* result at that point, which then is possibly ignored by the rest of the `do'-block
04:56:32 <Solonarv> (again, in a do block)
04:56:34 <ski>  possibly, but not necessarily. sometimes you want to do this kind of thing, giving the intermediate result a name)
04:57:03 <Solonarv> 'return x' in the middle of a do-block is *always* a no-op
04:57:07 <Solonarv> so sayeth the monad laws
04:57:41 <ski> i believe this is the most important gotcha about how `return' (which is just an ordinary function) in a `do'-block in Haskell differs from the `return' construct in imperative languages, which actually also *aborts* the execution of the current function/procedure body
04:57:41 <Solonarv> ('y <- return x' is not necessarily a no-op, but that's not what I said!)
04:58:00 * ski smiles
04:59:25 <ski> some argue that it would have been better if `return' had been called something else (say `pure', or perhaps `unit', or `trivial'/`trivially', or `noop') in Haskell, because of this mismatch between what `return' does in Haskell (in terms of `do'-notation), and what it does in most other languages which has a concept named `return'
05:00:00 <ski> but then, there also seem to be sufficient overlap in the uses of it, for people to be helped by them having the same name
05:00:13 <Solonarv> ...and indeed we have 'pure', and it's the same thing as 'return' (well, it's slightly more general)
05:00:48 <ski> (or even just it being called `return', as in "please yield this as the result (of this action)", nevermind what `return' means in other languages, which someone has perhaps not even seen)
05:01:50 <ski> im0nde : .. does this general reflection make any sense to you ?
05:02:25 <im0nde> ski: Still reading it, I think it makes sense to me just have to think about it a while ):
05:02:28 <im0nde> :)
05:02:38 <ski> *nod*, take your time :)
05:03:01 <ski> (and do come back with further questions, if you get them)
05:08:14 <im0nde> So, if I understood corretly just passing "matrixUser" to a function f  would pass the "matrixUser" function to f, not it's result, correct?
05:08:42 <im0nde> in particular it would not execute matrixUser at all at that point
05:08:58 <Solonarv> correct
05:09:12 <ski> it would pass a "recipe"
05:09:25 <im0nde> is a "recipe" a function?
05:09:29 <ski> no
05:10:33 <ski> so if the function `f' expects to get a `Value', but gets an `IO Value' (an action, an `IO'-action to be particular, what i informally called a "recipe"), that's like handing your kid a bread recipe, when they're hungry and ask for the bread to make a sandwich
05:10:34 <im0nde> Hm, ok. I don't understand the difference yet then. Will reread
05:10:40 <ski> (to put it drastically :)
05:11:02 <im0nde> I see.
05:11:19 <ski> a value of type `IO Value' is an action (an `IO'-action)'. it doesn't (necessarily) "contain" any thing of type `Value'
05:11:19 <hpc> to put it a bit more directly, a function is a thing that takes an input value and produces an output value
05:11:26 <hpc> the same input value produces the same output value every time
05:11:34 <hpc> a "recipe" is something that gets executed
05:11:42 <hpc> it doesn't have any input, it just happens
05:11:58 <hpc> it can produce a result, which may be different between different executions
05:12:11 <ski> it *describes* how to interact (Input/Output, the `IO') with the OS to (hopefully) *acquire* a `Value' in the end
05:12:13 <deathcap> another question: since I'm in an environment where doing pretty much anything involving root access or an internet connection is extremely impractical (at least on this system) and most of the haskell installers seem to require both: is there a decent way to even install this language?
05:12:20 <im0nde> Could i say then a recipe is a function without parameters?
05:12:21 <hpc> in the type (IO Value), IO means it's a recipe and Value is the type of its result
05:12:41 <hpc> not a function, they're different things
05:12:44 <ski> you have to actually carry out the instructions, follow the recipe, perform/execute the action, to arrive at the "monadic" result of it, in the end
05:12:53 <deathcap> like i'm looking at all of the package installers, they're out of the loop. and well, cabal needs to be able to get outside the (heavily firewalled) system, right?
05:13:18 <deathcap> err, out of the question because i don't have root.
05:13:29 <im0nde> Ok, let me put in another example: why can I not do this then:
05:13:32 <ski> im0nde : a function takes a parameter/input/argument (that you pass to it, when calling it). all functions in Haskell take exactly one argument
05:13:36 <im0nde> matrixAccessToken = do
05:13:39 <im0nde>     let userValue <- matrixUser
05:13:41 <im0nde>     let passValue <- matrixPass
05:13:43 <im0nde>     let matrixLoginRequestData =  BLU.fromString ("{\"type\":\"m.login.password\", \"user\":\"" ++ userValue ++ "\", \"password\":\"" ++ passValue ++ "\"}")
05:14:03 <Solonarv> deathcap: cabal can work offline, though of course you'll need to somehow fetch libraries you want to use
05:14:31 <im0nde> It tells me, parse error on <-
05:14:35 <hpc> ah, so that's all syntactic issues
05:14:49 <ski> im0nde : `putStrLn' is not an action, it's a function that will give you back an action, a recipe, as result. still the execution of that action has not happened. only *if* (and when) you later execute that action, will the interaction description "inside" it happen
05:14:58 <hpc> when you're binding the result of an action, the syntax is "result <- action"
05:15:03 <Solonarv> more generally, you can very well use ghc+cabal without root access - they're perfectly happy living in e.g. your home directory
05:15:27 <hpc> when you're doing an ordinary definition, it's "let <defn> = <expr>"
05:15:40 <deathcap> ahh, okay, that's reassuring.
05:15:53 <hpc> finally, a do-block needs to end in an expression
05:15:57 <hpc> so you might have
05:16:01 <Solonarv> another option might be to do development on a less isolated machine and simply copy over the final executable (along with any needed files, perhaps)
05:16:18 <hpc> matrixAccessToken = do {your stuff; pure (userValue, passValue, matrixLoginRequestData)}
05:16:24 <ski> im0nde : and the way (in general) you execute an action is by making it part of a larger action, that is eventually executed (such as `main'). by placing the action `putStrLn matrixPass' (which is the output of the function `putStrLn') as a command "line" in a `do'-block, you're making the action part of the larger `do'-block action in this fashion, so that it will be executed whenever the larger `do'-block action is executed
05:17:05 <Solonarv> cabal does of course need internet access to download third-party packages you want to use, but that's just http(s) - if that is allowed things should Just WOrk
05:17:23 <ski> im0nde : `let' is for giving a name to (the value computed by some) expression. it will not execute an action, in case that action is the value of the expression
05:18:24 <ski> im0nde : `<-' in a `do'-block (with no `let' before) is how you say "please execute this action (when/if you get to this point), and name the result like this". if you don't want/need to name the result of executing the action, then you don't need the `<-' part
05:19:25 <ski> `=' goes with `let' here. and `<-' with the plain `do' at the top
05:19:31 <ski> btw, you could say
05:19:35 <ski>   matrixAccessToken = do
05:19:55 <ski>     let userValue = matrixUser
05:20:03 <ski>         passValue = matrixPass
05:20:16 <ski>         matrixLoginRequestData =  BLU.fromString ("{\"type\":\"m.login.password\", \"user\":\"" ++ userValue ++ "\", \"password\":\"" ++ passValue ++ "\"}")
05:20:26 <Solonarv> deathcap: if downloading won't be possible, I do know it's possible to fetch the packages some other way, or even point cabal at a package repository you control (instead of hackage.haskell.org); however, having never needed to do it, I don't know how
05:20:37 <ski>     return (userValue, passValue, matrixLoginRequestData)  -- remember, `pure' does the same thing as `return' here
05:20:49 <Solonarv> * ...fetch the packages some other way and make cabal use those sources
05:20:54 <ski> the point being that you can define multiple things withing a single `let'
05:21:48 <ski> .. oh, but in your case, you actually wanted to *run* the actions `matrixUser' and `matrixPass', giving the execution *results* the names `userValue', `passValue'. so you should not actually use `let' for those first two "lines" here, you should use `<-'
05:21:56 <ski>   matrixAccessToken = do
05:22:01 <deathcap> hmmm, i may go the "work on a different machine" route. right now i'm ssh'd into our designated internet facing machine from an operational workstation (to use IRC at least), so maybe i could get everything installed in a particular directory there and then just copy over executables.
05:22:02 <ski>     userValue <- matrixUser
05:22:08 <ski>     passValue <- matrixPass
05:22:15 <ski>     let matrixLoginRequestData = ...
05:22:23 <ski>     return (userValue,passValue,matrixLoginRequestData)
05:23:22 <deathcap> it's not terribly critical that i build any actual production software, i'm mostly interested in using this system for learning...my actual use case will be on my home system where none of these restrictions matter.
05:24:17 <ski> (in the former case, using `let' for the `matrixUser' and `matrixPass' parts as well, `userValue' and `passValue' would be *synonyms* for those two actions. iow, `userValue' and `passValue' would themselves be actions, not the results of executing those actions .. and that's not what you wanted to do here, it wouldn't work with your definition of `matrixLoginRequestData', which treats `userValue' and `passValue' as `String's (not actions that when executed 
05:24:40 <ski> (hrm, possibly cut off near : ".., which treats `userValue' and `passValue' as `String's (not actions that when executed would yield `String's))")
05:24:53 <ski> im0nde : is that clearer ?
05:24:53 <Solonarv> you could also consider using nix, which supposedly helps make the "copy over build products" more consistent & reproducible
05:25:14 <deathcap> Solonarv: i'm on RHEL
05:25:34 <deathcap> unless nix is not short for linux
05:25:55 <Solonarv> nix is a package manager 
05:25:58 <deathcap> oh. haha.
05:26:30 <im0nde> ski: Do I need the return at all if I just want to print out the accesstoken?
05:26:35 <Solonarv> there is also nixOS which is (predictable) a linux distro based around nix, but you can use nix without having to use nixos
05:26:36 <deathcap> i just want something to run through the 99 haskell problems or project euler or something! stupid firewall, why can't they give all non-admins root privileges.
05:26:48 <ski> im0nde : you don't, i suppose
05:27:29 <ski> im0nde : the `return' was just something hpc added, in order to satisfy the syntactic requirement "finally, a do-block needs to end in an expression"
05:27:33 <deathcap> my workspace taking security extremely seriously is just a pain sometimes.
05:27:49 <im0nde> ski: Ok, i get it.
05:27:54 <Solonarv> it'd probably be a good idea to do that by ssh'ing onto a less secured machine, yeah
05:27:57 <ski> im0nde : if you're not going to *use* `matrixLoginRequestData' later, then why do you name it ?
05:28:08 <im0nde> My goal is to just print the accessotken
05:28:30 <im0nde> ski: dunno actually, I thought I needed to do so
05:28:31 <ski> im0nde : *often* that ending expression is of the form `return x', for some value `x'
05:29:01 <ski> im0nde : but it could be any action other than `return x', as well. e.g. a call to `putStrLn' or `print', or something else
05:29:20 <Solonarv> if you have unrestricted http(s) access it should be fine, but I might expect your employer to frown upon that if they insist so heavily on security
05:29:30 <im0nde> Let me paste the whole program maybe it's cleaer what I'm trying to do: https://gist.github.com/binaryplease/f8dbc3a7ec4edb1885b6e089dee68acf
05:29:46 <im0nde> ^ these are my baby steps at trying to write a bot
05:30:04 <im0nde> I will need the token for later requests
05:30:10 <ski> (and by a "call to" one of those, i really mean : a call to that function, followed by actually *executing* (or invoking, if you will) the action which is the output of that function call. but for short, we can say that we "call an effectful function", or something similar)
05:30:17 * hackage fltkhs 0.8.0.0 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.8.0.0 (deech)
05:31:07 <ski> im0nde : the indentation in `matrixAccessToken' is off
05:31:18 <ibloom> Is there any barrier to using a local build of the ghc API
05:31:22 <ski> im0nde : all commands in a `do'-expression should be indented to the same level
05:31:59 <ibloom> Do I need to also use that build as my compiler.
05:32:17 * hackage fltkhs-themes 0.2.0.0 - A set of themed widgets that provides drop in replacements to the ones in FLTKHS.  https://hackage.haskell.org/package/fltkhs-themes-0.2.0.0 (deech)
05:32:22 <ski> im0nde : and i see you're actually going to use `matrixLoginRequestData' later, in the `let request = ...' command (that command doesn't perform any action, it just gives names to values resulting from evaluating expressions)
05:32:57 <deathcap> i mean nobody ever complains about my IRC usage. our web facing box is designated for fetching data, it's just a one-sided thing. like from the system i'm sitting at we can either push to or pull from the web-facing server but if you're on the web-facing server our operational systems may as well not exist.
05:33:23 <deathcap> which, well, works as intended. 
05:33:42 <ski> im0nde : and if you deindent, appropriatedly, the first four lines of the body of `matrixAccessToken', then the fourth line, namely `return (userValue, passValue, matrixLoginRequestData)' becomes exactly such a noop that Solonarv was talking about before. it's a redundant command, you can remove it
05:34:41 <ski> im0nde : `return x' is an action that, when performed/executed, won't actually *do* any (nontrivial) effects (in this case I/O interaction), the only thing happening is that it yields `x' as a result of executing this (sub)action
05:35:08 <ski> im0nde : if you say `y <- return x', then that's more or less the same (ignoring some minor type issues) as `let y = x'
05:35:51 <im0nde> I see. 
05:35:54 <ski> im0nde : but if you then don't have `y <- return x' "in the middle of a `do'-expression", but just `return x', then that's completely useless, since you're not even passing the value of `x' somewhere (like giving it the name `y')
05:36:52 <ski> btw, it would be possible to replace the lines
05:36:59 <ski>   request' <- parseRequest "POST https://matrix.org/_matrix/client/r0/login"
05:37:04 <ski>   let request
05:37:13 <ski>           = setRequestMethod "POST"
05:37:19 <ski>           $ setRequestPath "/_matrix/client/r0/login"
05:37:27 <ski>           $ setRequestBodyLBS matrixLoginRequestData
05:37:34 <ski>           $ request'
05:37:36 <ski> with
05:38:28 <ski>   request <- setRequestMethod "POST"
05:38:37 <ski>           .  setRequestMethod "POST"
05:38:45 <ski>           .  setRequestPath "/_matrix/client/r0/login"
05:38:51 <ski>           .  setRequestBodyLBS matrixLoginRequestData
05:39:00 <ski>          <$> parseRequest "POST https://matrix.org/_matrix/client/r0/login"
05:39:17 <ski> thereby avoiding having to name the intermediate result there
05:40:20 <im0nde> Why would I need the "setRequestMethod "POST"" line twice there?
05:40:54 <Solonarv> pretty sure that's a typo ;)
05:41:44 <ski> oh, sorry, yes
05:42:29 <ski> (generally, if you have `f $ g $ h $ x' (which is parsed as `f $ (g $ (h $ x))'), you can replace that with `f . g . h $ x' (which is parsed as `(f . g . h) $ x'), or (which i often find neater), `(f . g . h) x' .. what i did above is a "monadic" (well, really "functorial") variant of this, using `<$>' in place of `$' in the suggested replacement)
05:43:08 <ski> (the original used monadic binding with `<-' for the "last part" corresponding to `x', the `parseRequest ...' thing, rather than just writing that inline after the last `$' in `let request = ...')
05:43:45 * ski isn't sure how intelligible that last explanation attempt is ..
05:44:36 <ski> (oh, and the call to `S8.putStrLn' is also misaligned, but i think you probably noticed this already)
05:44:57 <ski> (and there's a missing close bracket on that same line)
05:50:31 <ostfale> How can you make a triple parameter into a curried function in Haskell? f (a, b, c) = a + b + c
05:51:03 <ggole> \a b c -> f (a, b, c)?
05:51:24 <ggole> There might be a combinator to do that floating around somewhere
05:51:26 <im0nde> I saw it. Thanks again for the help! My last issue seems to be that userValue and passValue still have the wrong type in the let matrixLoginRequestData line
05:52:32 <ski> @hoogle curry3
05:52:33 <lambdabot> Data.Tuple.HT curry3 :: ((a, b, c) -> d) -> a -> b -> c -> d
05:52:33 <lambdabot> Data.Tuple.Tools curry3 :: ((a, b, c) -> d) -> a -> b -> c -> d
05:52:33 <lambdabot> Data.Tuple.HT uncurry3 :: (a -> b -> c -> d) -> ((a, b, c) -> d)
05:52:47 <ski> is apparently in some package(s ?) (dunno which)
05:53:02 <ski> im0nde : your current code being ?
05:53:24 <im0nde> https://gist.github.com/binaryplease/51f9f1a73046d9e461a484a0863bd0fe
05:53:43 <ostfale> ok, So you need a separate function for each arity?
05:54:09 <im0nde> ski: ^
05:54:57 <ski> ostfale : yes. "arity" isn't really a well-defined concept in Haskell. every function takes exactly one argument
05:55:28 <ski> ostfale : you can do some tricks with type classes to get something that looks like "variable arity functions" -- but it tends to be a bit tedious to use
05:55:41 <im0nde> oh seems wraping it with a (show passValue) works
05:55:46 <ostfale> mh ok. thx :)
05:56:26 <im0nde> but it results in a json parser error
05:56:33 <ski> > let x = 2; y = 3 in printf "%s is %d\n%s is %d" "x" x "y" y :: String  -- is one example of such a "vararg" function
05:56:34 <lambdabot>  "x is 2\ny is 3"
05:57:00 <ski> im0nde : yes, so `userValue' and `passValue' both have type `Data.Configurator.Types.Value', not `String' which is what's expected in those use sites
05:57:16 <ski> im0nde : and you don't need wrapping brackets around those calls to `show', there
05:58:14 <ski> im0nde : possibly there is some other (Aeson ? Yaml ?) function for representing your values as `String's (?) that you should be using ?
05:59:04 <ski> i would try to take a look at the string that `matrixLoginRequestData' is created from, and try to figure out which format it ought to have been using
05:59:22 <im0nde> ski: I just print out matrixLoginRequestData it puts "String" (these actual letters) before the actual string
05:59:33 <ski> (perhaps there's cookbook examples or tutorials which tell you how to do this ?)
05:59:53 * ski has used neither of `aeson' nor `yaml'
06:01:11 <ski> im0nde : hmm .. imho, that's a not-nice-playing `Show' instance for `Value', then (but that's not directly related to the issue you're having. i think you should probably simply not use `show' here at all, rather some other custom format)
06:02:28 <ski> (imho, `Show' is *meant* to output a Haskell-syntax representation of a value (iow, as a Haskell expression that when evaluated would yield back the original value). but here you're not outputting something in Haskell-syntax, you're outputting some Aeson or Yaml format of some kind (i believe). so you need some other kind of formatter)
06:04:26 <Solonarv> % import Data.Aeson
06:04:26 <yahb> Solonarv: ; <no location info>: error:; Could not find module `Data.Aeson'; Perhaps you meant Data.Version (from base-4.12.0.0)
06:04:28 <ski> (unfortunately, there are even some `Show' instances in basic libraries that violate this expectation .. imho, it would be better, if we could move closer to the (imho) ideal)
06:04:33 <Solonarv> ...huh
06:04:46 <Solonarv> actually, I'm pretty sure aeson's show instance *does* output valid Haskell
06:04:48 <im0nde> I see. Will look into it later, but I feel like Im getting closer
06:04:59 <Solonarv> yep, it does
06:05:11 <Rembane> Does it output Value:s? 
06:05:17 <Solonarv> ski: Value (the main aeson type) simply happens to have a constructor named String
06:05:56 <ski> Solonarv : .. oh. ok, i suppose that could be ok, then
06:06:16 <Solonarv> data Value = Object (HashMap Text Value) | ... | String Text | ... deriving (Eq, Ord, Show, ...)
06:06:41 <Solonarv> it is in fact a derived instance - no complaining!
06:06:57 <ski> then i apologize for doubting the `Show' instance :)
06:07:00 <Solonarv> ;)
06:07:47 <ski> (i normally don't name my data constructors the same as type constructors, so it didn't enter my mind that `String' could be a data constructor here)
06:08:06 <Franciman> Hi
06:08:11 <ski> hello Franciman
06:08:20 <Franciman> if I have data MyType = MyType deriving(Typeable)
06:08:26 <im0nde> gtg, once agin thanks for the help
06:08:27 <Solonarv> ski: yeah, I'm not a huge fan of the names of Value's constructors
06:08:38 <Franciman> and have a : MyType, is there a way to get a string representing the name of the type of a ?
06:08:45 <Franciman> a :: MyType *
06:09:11 <Solonarv> @let data MyType = MyType -- deriving Typeable isn't needed
06:09:12 <lambdabot>  Defined.
06:09:15 <ski> > show (typeOf False)
06:09:17 <lambdabot>  "Bool"
06:09:22 <Solonarv> > show (typeOf MyType)
06:09:24 <lambdabot>  "MyType"
06:10:03 <Solonarv> typeOf gets you the TypeRep describing the type of a (Typeable) thing, and TypeRep has a Show instacce
06:10:13 <Franciman> cool! Thanks
06:10:34 <Solonarv> @let showTyped x = show x ++  " :: " ++  show (typeOf x)
06:10:35 <lambdabot>  Defined.
06:10:42 <Solonarv> > showTyped True
06:10:44 <lambdabot>  "True :: Bool"
06:11:33 <olligobber> > show (typeOf typeOf)
06:11:35 <lambdabot>  error:
06:11:35 <lambdabot>      • No instance for (Typeable a0) arising from a use of ‘typeOf’
06:11:36 <lambdabot>      • In the first argument of ‘show’, namely ‘(typeOf typeOf)’
06:13:20 <Solonarv> > show (typeOf (typeOf @Bool))
06:13:22 <lambdabot>  error:
06:13:22 <lambdabot>      Pattern syntax in expression context: typeOf@Bool
06:13:22 <lambdabot>      Did you mean to enable TypeApplications?
06:13:31 <Solonarv> dangit lambdabot, get with the times!
06:13:35 <Lears> > msg lambdabot > show (typeOf (id :: Int -> Int))
06:13:37 <lambdabot>  error:
06:13:38 <lambdabot>      Variable not in scope: msg :: t0 -> Stringerror: Variable not in scope: ...
06:13:44 <Solonarv> % import Data.Typeable
06:13:44 <yahb> Solonarv: 
06:13:46 <Lears> Oh wow, got those the wrong way around.
06:13:51 <Solonarv> % typeOf (typeOf @Bool)
06:13:51 <yahb> Solonarv: Bool -> SomeTypeRep
06:14:36 <olligobber> lol, "SomeTypeRep" sounds like someone was like "how will we represent types?" "just use some type rep"
06:16:37 <ski> @let data ShowableDynamic = forall a. (Show a,Typeable a) => ToShowDyn a
06:16:38 <lambdabot>  Defined.
06:16:47 <ski> @let instance Show ShowableDynamic where showsPrec p (ToShowDyn a) = showParen (p > 10) (showString "ToShowDyn " . showParen True (showsPrec (9+1) a . showString " :: " . showsPrec 9 (typeOf a)))
06:16:48 <lambdabot>  Defined.
06:16:53 <ski> > ToShowDyn False
06:16:55 <lambdabot>  ToShowDyn (False :: Bool)
06:16:59 <ski> > toDyn False
06:17:01 <lambdabot>  <<Bool>>
06:17:24 <Solonarv> Typeable got changed a bit recently; the new API lives in Data.Type.Reflection
06:17:34 <Solonarv> Data.Typeable is now a backwards-compatible layer over that
06:17:55 <Solonarv> % :m - Data.Typeable + Data.Type.Reflection
06:17:55 <yahb> Solonarv: syntax: :module [+/-] [*]M1 ... [*]Mn
06:17:59 <Solonarv> % :m - Data.Typeable
06:17:59 <yahb> Solonarv: 
06:18:07 <Solonarv> % :m + Data.Type.Reflection
06:18:07 <yahb> Solonarv: ; <no location info>: error:; Could not find module `Data.Type.Reflection'; Perhaps you meant; Data.Reflection (from reflection-2.1.3); Type.Reflection (from base-4.12.0.0)
06:18:13 <ski> `SomeTypeRep' presumably being `exists a. TypeRep a'
06:18:19 <Solonarv> ski: precisely
06:18:32 <olligobber> ooh, I didn't realise haskell had existential types
06:18:33 <Solonarv> gah, I must've misremembered the module name
06:18:38 <ski> (that's the typical naming convention with `Some...')
06:18:59 <Solonarv> % import Type.Reflection
06:18:59 <yahb> Solonarv: 
06:19:01 <ski> olligobber : it has two common ways of *encoding* existential types like `exists a. TypeRep a'
06:19:02 <Solonarv> % :t typeOf
06:19:02 <yahb> Solonarv: ; <interactive>:1:1: error:; Ambiguous occurrence `typeOf'; It could refer to either `Type.Reflection.typeOf', imported from `Type.Reflection' (and originally defined in `base-4.12.0.0:Data.Typeable.Internal'); or `Data.Data.typeOf', imported from `Data.Data' (and originally defined in `Data.Typeable')
06:19:12 <Solonarv> blergh
06:19:21 <Solonarv> % :t Type.Reflection.typeOf
06:19:22 <yahb> Solonarv: Typeable a => a -> Type.Reflection.TypeRep a
06:19:24 <olligobber> I see
06:20:24 <Solonarv> olligobber: no "true" existential types; you need to hide the existential in a data/newtype constructor or use a continuation to turn it into a universal
06:20:38 <ski> (more precisely, there are extensions which enable these two encodings. one of which would be `ExistentialQuantification', and the other being `Rank2Types' (and i would say perhaps `PolymorphicComponents', except i think that doesn't do a thing on its own, now))
06:21:20 <ski> (s/a continuation/CPS/, i'd say ;)
06:21:21 <Solonarv> ski: "The obsolete language options PolymorphicComponents and Rank2Types are synonyms for RankNTypes."
06:21:27 <Solonarv> (from the GHC docs)
06:21:28 <ski> right :)
06:22:32 <ski> if you want to encode `exists a. TypeRep a', you can either define a new type `SomeTypeRep' which encodes that, like
06:22:52 <ski>   data SomeTypeRep = forall a. WrapTypeRep (TypeRep a)
06:23:02 <ski> which is the same thing as the `GADTSyntax' style declaration
06:23:06 <ski>   data SomeTypeRep
06:23:07 <ski>     where
06:23:19 <ski>     WrapTypeRep :: forall a. TypeRep a -> SomeTypeRep
06:23:27 <ski> (and the `forall a.' there is optional)
06:24:11 <ski> note how `forall a. (TypeRep a -> SomeTypeRep)' logically is equivalent to `(exists a. TypeRep a) -> SomeTypeRep', hence `SomeTypeRep' (having `WrapTypeRep' as single data constructor) encodes `exists a. TypeRep a'
06:24:21 <ski> you may compare with how
06:24:30 <ski>   length :: forall a. ([a] -> Int)
06:24:40 <ski> logically means the same as (the pseudo-Haskell)
06:24:48 <ski>   length :: (exists a. [a]) -> Int
06:25:19 <olligobber> I am too tired to parse this fully, but I recall seeing something like this in a textbook
06:25:29 <ski> the first signature says that for any/every/each type `a', if you call `length' with an argument of type `[a]' (so a list of `a's), you will get back an `Int' as result
06:26:01 <ski> the latter says that, you will get back an `Int', when calling `length', as long as there *exists* a type `a', such that the argument has type `[a]'
06:27:08 <ski> so, `SomeTypeRep' is one encoding of `exists a. TypeRep a'. if you want to express `foo :: (exists a. TypeRep a) -> ...', you could then instead say `foo :: SomeTypeRep -> ...', and have `foo' unwrap the `WrapTypeRep' data constructor
06:27:22 <ItalianGentleman> Hi everyone 
06:27:53 <ski> though, in this particular case, since `foo :: (exists a. TypeRep a) -> ...' means the same as `foo :: forall a. (TypeRep a -> ...)', you could just write `foo' like that, as a function that's polymorphic in `a'
06:28:30 <ski> but you can't do this trick if you want `exists a. TypeRep a' as a *result* type, as in `bar :: ... -> exists a. TypeRep a', then you'd really need to say `bar :: ... -> SomeTypeRep'
06:28:51 <ski> .. so, this was the "existential data type" encoding of the existential quantification
06:29:24 <ski> the other encoding, the CPS (Continuation-Passing Style) encoding of `exists a. TypeRep a', is `forall o. (forall a. TypeRep a -> o)'
06:29:40 <ski> so, in the `bar' case, instead of
06:29:47 <ski>   bar :: ... -> exists a. TypeRep a
06:30:03 <ski> (which you can't type (yet ?), it's pseudo-Haskell notation)
06:30:08 <ski> you could say
06:30:18 <ski>   barWith :: ... -> forall o. (forall a. TypeRep a -> o)
06:30:21 <ski> which is the same as
06:30:22 <ItalianGentleman> I have an issue in haskell. I have a [[Bool]] and I'm trying to do a function that returns [(Int,Int)] with all the coordinates of the "True" ones
06:30:30 <ski> er, sorry, that should be
06:30:33 <ski>   barWith :: ... -> forall o. (forall a. TypeRep a -> o) -> o
06:30:49 <ski> (i forgot the `-> o' part in `forall o. (forall a. TypeRep a -> o) -> o' before, as well. sorry)
06:30:57 <ski> anyway, that's the same as
06:31:09 <ski>   barWith :: forall o. ... -> (forall a. TypeRep a -> o) -> o
06:31:10 <ski> or
06:31:14 <ski>   barWith :: ... -> (forall a. TypeRep a -> o) -> o
06:31:16 <ski> for short
06:31:44 <ski> this is a rank-2 operation, since it's taking a *polymorphic* argument (the last argument, which is a callback, in this case a "continuation")
06:32:11 <ski> the first kind of encoding of existentials is good in some situations, the second in other situations
06:32:33 <ski> ItalianGentleman : hmm, ok
06:32:42 <ski> ItalianGentleman : what have you done, so far ?
06:33:02 <ski> or, what are you having trouble with ?
06:34:11 * ski can imagine doing this with a list comprehension
06:34:22 <ski> you can probably also use recursion, directly
06:35:14 <ski> .. probably you could also use `findIndices'
06:35:40 <ItalianGentleman> ski : I think I have problems with how to do it with a functional language
06:35:47 <ski> ok
06:35:55 <ski> would that be Haskell, or some other language, then ?
06:36:19 <ItalianGentleman> Haskell is my fisrt functional language
06:36:32 <ski> ok. i'm taking that as "yes, in Haskell"
06:36:59 <ItalianGentleman> So I'm think in the functionnal way
06:37:03 <ski> ItalianGentleman : have you seen list comprehensions, yet ?
06:37:16 <ski> have you seen `map' and `filter' ? `zip' ?
06:37:39 <ski> (`concat' ?)
06:37:46 <ItalianGentleman> I see what it is but never applied
06:38:08 <ski> you need to, somehow, get the "current indices" "in there"
06:38:54 <ski> they're implicit, in the positions in the lists. but you need to make them explicit, because you're going to be removing elements (the `False' ones), and also because you're going to be flattening the list of lists into a single list (i presume)
06:38:59 <ItalianGentleman> ski : with that : x <- [0 .. 3dlen - 1]] | y <- [0 .. 3dlen - 1] ?
06:39:13 <ski> yes, that would be (part of) list comprehension syntax
06:39:29 <ski> (btw, `3dlen' is not a valid identifier name in Haskell)
06:39:54 <ItalianGentleman> yes
06:40:08 <ItalianGentleman> I know I can have this 3darray !! y !! x | x <- [0 .. 3dlen - 1]] | y <- [0 .. 3dlen - 1]
06:40:40 <ski> nitpick, you shouldn't say "array" there, because it's a list (a single-linked list), not an array (there are also arrays, but they are different)
06:41:36 <ski> so .. you *could* make a usable (though a bit inefficient) solution, along those lines
06:42:15 <ItalianGentleman> Now i have to push (x, y) in a new array if grid !! y !! x 
06:42:45 <ItalianGentleman> But I'm blocking here
06:42:48 <ski> (for lists, it's generally better to not index them with indices, but rather to loop along the "chain" of the list only once, handling all the elements you want to handle. using `!!' repeatedly will instead *re*traverse the list from the start, each time, which is inefficient. for an array, using `!' to index would be efficient)
06:44:00 <ItalianGentleman> How do I use it ?
06:44:17 <ski> ItalianGentleman : in a list comprehension, you can not just have "generators", like `x <- [0 .. 3dlen - 1]' (which would enumerate `x' from the given list of indices), after the `|', but also "guards", which are simply boolean expressions, that tell whether the current selection of values from the generators are to be considered further, or skipped
06:44:39 <ski> (and you separate multiple generators and guards, in a list comprehension, after the `|', with `,'s)
06:44:51 <ski> in your case, you could perhaps write something like
06:45:32 <ski>   [[my3dlist !! y !! x | x <- [0 .. my3dlen - 1],..x..y..] | y <- [0 .. my3dlen - 1]]
06:46:30 <ItalianGentleman> All right, thank a lot, i'm going to inquire about "..x..y.."
06:46:33 <ski> where `..x..y..' is to be replaced by some `Bool'ean condition (presumably) involving `x' and `y', that will tell whether you want to "push" an index pair for this current selection of `x' and `y', or, otherwise, to skip this current selection, moving on the the remaining ones
06:47:35 <ski> (there is also at least two other things you have to fix in this list comprehension, in order to get it to do what you described)
06:48:10 <ski> (but one step at a time :)
06:51:05 <ItalianGentleman> I'm not understanding what I need to do after the ','
06:51:50 <ski> you need to write a condition that tells the list comprehension whether you want to continue processing with the current selection of `x' and `y'
06:52:11 <ski> or, otherwise, to skip that selection, and continue on with considering the next possible selection (if any)
06:52:48 <ski> so, initially, `x' and `y' would both be `0', so you presumably need to decide whether you want to "output" the pair `(0,0)' into the resulting list, or not
06:53:18 <ski> next, `x' would advance to `1', `y' still being `0', and so you'd consider whether to "output" `(1,0)'
06:53:40 <ski> and so on, for each possible `x' up to `my3dlen - 1', iow considering the pair `(my3dlen - 1,0)'
06:54:17 <ski> next, `y' advances to `1', and `x' restarts counting up from `0', so you'd then consider `(0,1)',`(1,1)',`(2,1)',...,`(my3dlen - 1,1)'
06:54:43 <ski> next, `y' advances again, so then you're considering from `(0,2)' up to `(my3dlen - 1,2)'
06:54:47 <ItalianGentleman> Yes, that I understand the `<-`
06:55:06 <ski> and so on, until `y' has (also) reached `my3dlen - 1', the final pair you're considering is `(my3dlen - 1,my3dlen - 1)'
06:55:57 <ski> so, for each such pair `(x,y)' (or did you want them in the opposite order, like `(y,x)' ? i just assumed the first order), you need to determine whether that pair should be output in the desired result list, or not
06:56:35 <ski> and to determine that, you need to write some `Bool'ean expression, in terms of `x' and `y', in place of the "template hole" `..x..y..' i wrote above (to indicate where you have to "fill in some blanks")
07:00:37 <ski> .. do you have any further question, or some update on what you've tried, that you want to show ?
07:01:33 <ItalianGentleman> No thanks
07:01:37 <ItalianGentleman> Thanks a lot
07:01:55 <ski> np
07:05:38 <ssm21> there is a function which takes a char and tuple (char is for deciding which operation to do on that tuple) and function outputs a string, but i want to modify the input tuple to be the result tuple
07:06:20 <ssm21> so i can use that function to change the tuple and also change the new tuple continuosly
07:09:52 <ski> and what should happen with the `String' ?
07:10:36 <ssm21> i still want to get the string
07:11:46 <ssm21> duuh.. now i found it this was a bad question should write another function and use them separetly
07:46:17 * hackage hledger-makeitso 0.10.0.0 - An hledger workflow focusing on automated statement import and classification.  https://hackage.haskell.org/package/hledger-makeitso-0.10.0.0 (apauley)
07:52:38 <maskat> ciao
07:53:09 <maskat> !list
07:53:09 <monochrom> maskat: http://hackage.haskell.org/packages/
07:58:41 <monochrom> haha
08:00:34 <ssm21> i get parse error on input 'putstrLn' at line 14 in this code https://pastebin.com/DfkZXPWZ
08:00:37 <ssm21> where is the problem?
08:01:25 <c_wraith> the branches of an if inside a do block are not part of the do block
08:03:12 <monochrom> 14? 10?
08:04:07 <ssm21> 10. sorry i didnt put the imports to pastebin
08:04:33 <monochrom> Then yeah you need a "do" like line 14.
08:04:59 <ssm21> thanks a lot
08:41:47 * hackage opench-meteo 0.2.0.3 - A Haskell implementation of the Swiss Meteo Net data API  https://hackage.haskell.org/package/opench-meteo-0.2.0.3 (RolandSenn)
08:48:32 <ssm21> how can i get result of a function in that function again? in main block
08:48:34 <ssm21> https://pastebin.com/jhEwRUuX
08:49:34 <ssm21> i want to ask for operation char again and do the 'operate' on the result of the previous 'operate'
08:53:11 <ski> ssm21 : make a recursive function that takes `s' as an input. in that function, ask for the operation `Char', call `operate', and then call that function recursively with the new state
08:54:16 <ski> ssm21 : also `(isNormalized s) == False' is `not (isNormalized s)', and there is a `notElem' operation you could use
08:55:32 <ski> should `"HXYZ"' be `"HXYZM"' ?
08:56:16 <ski> (you also probably need to handle newline `Char'acters read in by `getChar')
09:26:49 <TBG> @help
09:26:49 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:26:53 <TBG> @list
09:26:54 <lambdabot> What module?  Try @listmodules for some ideas.
09:26:59 <TBG> @listmodules
09:26:59 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
09:26:59 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
09:27:55 <TBG> @undo nextGen = do   cells <- checkCells   filteredCellValues <- fmap (V.filter $ (== 1) . cellAlive) $ traverse (uncurry nextCellState) cells   put filteredCellValues
09:27:55 <lambdabot> <unknown>.hs:1:9:Parse error: =
09:28:09 <TBG> @undo do   cells <- checkCells   filteredCellValues <- fmap (V.filter $ (== 1) . cellAlive) $ traverse (uncurry nextCellState) cells   put filteredCellValues
09:28:09 <lambdabot> <unknown>.hs:1:47:Parse error: Last statement in a do-block must be an expression
09:28:14 <TBG> @undo do   cells <- checkCells   filteredCellValues <- fmap (V.filter $ (== 1) . cellAlive) $ traverse (uncurry nextCellState) cells   put filteredCellValues
09:28:15 <lambdabot> <unknown>.hs:1:47:Parse error: Last statement in a do-block must be an expression
09:28:19 <TBG> Aaaaah
09:28:26 <TBG> Semicolons lol
09:28:50 <TBG> @undo do {cells <- checkCells; filteredCellValues <- fmap (V.filter $ (== 1) . cellAlive) $ traverse (uncurry nextCellState) cells; put filteredCellValues}
09:28:50 <lambdabot> checkCells >>= \ cells -> fmap (V.filter $ (== 1) . cellAlive) $ traverse (uncurry nextCellState) cells >>= \ filteredCellValues -> put filteredCellValues
09:46:17 * hackage mime-mail 0.5.0 - Compose MIME email messages.  https://hackage.haskell.org/package/mime-mail-0.5.0 (MarekSuchanek)
09:56:39 <HenryCH> what's the difference between mapM and traverse? Is traverse just more a more general form because it works with a Traversable?
09:57:02 <HenryCH> i mean with an applicative
09:57:41 <Rembane> traverse is less powerful. OTOH you don't need the power of monads to do that kind of traversal.
09:58:03 <Rembane> I'm really hoping for an example when you do... :D
09:58:28 <Rembane> mapM was created first, since Monads is an older idea than Applicative functors. 
09:58:32 <Rembane> At least in Haskell.
09:58:42 <HenryCH> i thought applicative sits on top of monad?
09:59:05 <Rembane> On top of as in ?
09:59:57 <HenryCH> Monad f => Applicative f, I just looked it up it's Functor f
10:00:53 <cocreature> the fact that we have both mapM and traverse is mostly a historical accident
10:02:05 <HenryCH> Rembane:  what do you mean when you say you don't need the power of monads to do that kind of traversal?
10:03:42 <Rembane> HenryCH: I infer it from the type. You only need the power of Applicative to do it.
10:03:46 * Rembane handwaves furiously
10:03:49 <Rembane> :t traverse 
10:03:50 <ssm21> i have a recursive IO() function on ghci when i call the function i can use it multiple times but when i do on main it only works once and prints othe if else conditions without asking for input
10:03:51 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
10:04:03 <monochrom> Applicative f => Monad f.
10:04:25 <Rembane> ssm21: Do you want to be able to use it more than once in main? Can you put the code in a gist and show us?
10:04:33 <ssm21> https://pastebin.com/JM19rbFD
10:04:56 <aditsu> hi, does haskell have a hashmap? import Data.HashMap doesn't seem to work
10:05:08 <ssm21> i want to use result of the operator again and again in operator
10:05:10 <HenryCH> monochrom: ah, thanks
10:05:17 <Rembane> aditsu: Have you installed the package?
10:05:25 <monochrom> is a third-party library that you have to install by hand.
10:05:39 <HenryCH> Rembane: i see what you mean, thanks
10:05:49 <Rembane> ssm21: I think you need more indentation after your "do:s"
10:05:51 <aditsu> oh, it doesn't have that in the standard library?
10:05:53 <Rembane> HenryCH: No worries. 
10:06:14 <monochrom> doesn't come with GHC.
10:06:42 <Rembane> HenryCH: If you want more fun you can look at the laws for Monad and Applicative and think about what effects they have on computation. :)
10:06:58 <HenryCH> do you have a good source for that?
10:07:01 <aditsu> guess I can try Map instead
10:07:41 <cocreature> aditsu: it’s in the unordered-containers package
10:07:42 <Rembane> HenryCH: This is quite good: https://wiki.haskell.org/Typeclassopedia#Laws_2
10:08:05 <cocreature> aditsu: note that the HashMap type in Haskell is different from the mutable hashtables that you find in a lot of imperative languages
10:08:40 <HenryCH> cheers
10:10:17 <ssm21> i think my problem is on main function
10:10:46 <ssm21> operator function starts working again but doesnt ask getChar again and directly falls to the `notElem`
10:11:23 <ssm21> when i use ghci and call operator there is no problem
10:13:34 <ssm21> https://pastebin.com/dfVyyZRd
10:22:33 <ski> ssm21 : hmm
10:23:40 <ski> ssm21 : do you want to also repeat some operation (like perhaps `amplitude <- getLine') which is part of `main' ?
10:24:47 <ski> ssm21 : in any case, the code in that last paste can be improved somewhat, by "winding/rolling it up" a bit more
10:25:08 <ssm21> actually when i use measurement (M) i need to start main function again
10:25:21 <ihsancz> Hey guys
10:25:32 <ssm21> i mean getting new amplitudes there will be a prompt do you want to continue or not
10:26:16 <ihsancz> i'm currently reading a book called Seven Languages in Seven Weeks and I'm trying to learn Haskell. I made a .hs file and added
10:26:28 <ihsancz> module Main where\n\ndouble x = x + x
10:26:39 <ihsancz> when I run it, I get the error: The IO action ‘main’ is not defined in module ‘Main’
10:26:42 <ihsancz> Can someone help me out with this?
10:27:00 <ski> ssm21 : "when i use measurement (M) i need to start main function again" -- ok, you can do that
10:27:44 <ski> ihsancz : write the line
10:27:56 <ski>   main = print (double 7)
10:28:00 <ski> into the file, e.g.
10:28:41 <monochrom> Either that, or use a different module name, don't call it Main.
10:28:52 <ssm21> i guess that part needs just one if and else and on one condition call main again on the other one nothing but what about the 'operator' not repeating itself in executable
10:28:56 <ski> ihsancz : if you try to compile the program into an executable, you need a starting point where computation begins. that's `main'. in this case it'd tell to compute `double' of seven, and then to `print' the result of that as output from the program
10:29:36 <ski> ihsancz : however, you could also use an interactor, to try out evaluating expressions, that may use definitions of things in the file, and in this case you'd not need to define `main'
10:29:44 <ihsancz> oh, thanks, it works when I put the main = print (double 7) in
10:30:07 <ihsancz> why wouldnt main = double x = x * x work?
10:30:17 <ski> ihsancz : with GHC, you'd use the `ghci' command rather than the `ghc' command, to get into the interactor (sometimes known as REPL, or Read-Eval-Print Loop)
10:30:35 <ihsancz> yeah, I'm loading it in the ghci with :lad
10:30:36 <ihsancz> :load*
10:30:42 <ski> you need to put an expression after a `='. `double x = x * x' is not an expression, it's a definition
10:30:55 <ski> (a definition, defining the function `double')
10:31:41 <ihsancz> ah I see, thank you very much
10:31:59 <ihsancz> I thought that the function would just be defined so I can use it furhter in the interactor
10:32:13 <ihsancz> module Main where
10:32:13 <ihsancz>     double x = x + 2
10:32:13 <ihsancz>     main = print (double 7)
10:32:17 <ihsancz> I've done it like this now ^
10:32:29 <ski> ihsancz : once you have started the interactor, with `ghci' and then (once inside) an interactor command like `:load MyFile.hs' (or just `:l MyFile.hs' for short), alternatively starting the interactor with the command `ghci MyFile.hs', then you can enter expressions like `double 7', and it's reply with the computed result
10:33:46 <ihsancz> shouldn't I directly get "9" when I load up the script with ghci though?
10:33:51 <ihsancz> for this:
10:33:53 <ihsancz> module Main where
10:33:53 <ihsancz>     double x = x + 2
10:33:53 <ihsancz>     main = print (double 7)
10:34:38 <ski> no, the interactor doesn't automatically execute `main'
10:34:39 <ihsancz> It just says module loaded, but 9 doesn't get printed. when I put double 3 in the interactor myself it does print 5
10:34:59 <ski> (if you type `main', or the interactor command `:main', it will execute the `main' action)
10:35:17 <ihsancz> ah I get it now, thank you very much :p
10:35:33 <ihsancz> so haskell scripts/moduls always require a main right?
10:36:20 <ski> oh right, actually as monochrom said, if you name the module `Main' (iow you have `module Main' inside the file, regardless of whether the file is called `Main.hs' or not), then it requires `main' to be defined, apparently even if you're just starting the interactor (i didn't realize this)
10:37:10 <ihsancz> ah that makes sense. I've changed the module name and now it works like I wanted it to. Thank you very much guys
10:37:19 <ski> (but then, if you start the interactor with `ghci', it doesn't automatically run `main' .. so it perhaps sounds a bit strange to still require `main' being defined in this case. i suppose it's for consistency with the batch (non-interactor) case of compiling the program to an executable)
10:37:28 <ihsancz> does any of you know why the Main modules require a main and other module names not?
10:38:02 <ski> ihsancz : you can have several modules, of which one is named `Main', which import the other ones. only the one named `Main' need to define an action called `main'
10:39:10 <ski> ihsancz : so you could compile all those modules together into a single executable program, which starts execution at `main' in module `Main' (which doesn't necessarily have to reside in a file named `Main.hs'. this is an exception to a GHC rule that the module name has to correspond to the name of the source file it's residing in)
10:39:47 <ihsancz> ah alright, so it's kind of the starting point for haskell projects which exists of multiple modules
10:39:48 <ski> ihsancz : the module `Main' is intended as the "main module" of the program, where execution of the program starts
10:39:52 <ski> yes
10:40:01 <ihsancz> alright, that makes sense
10:40:03 <ihsancz> thank you :)
10:40:28 <ihsancz> Coming from a Java background, I thought it was something like the main method in a java app
10:40:35 <ski> one could also compile modules without a `Main' module, yielding a library (a package, say), which is perhaps later imported into someone else's program, which may or may not include a `Main' module
10:40:40 <ski> yes, exactly
10:41:02 <ski> but a Java program doesn't need to start in a class named `Main'
10:41:25 <ihsancz> yeah, true, but it does get executed first if you run it through the class that has it defined
10:41:34 * ski nods
10:41:42 <ski> so, it's similar, but not exactly the same
10:41:44 <ihsancz> but nice, I get the point now. thank you for clearing it all up
10:42:55 <ski> ihsancz : i recommend that you test our your program in the interactor, as you write chunks of it. you can reload the currently loaded modules (after having changed the source file(s) and saved them, in your favourite text editor), using the interactor command `:reload' (or `:r' for short)
10:43:49 <ihsancz> oh thanks. that saves time. I was repeating :q :load x.hs
10:44:28 <ski> (one can also set up the interactor command `:edit' (`:e' for short), to fire up an editor to edit a module file. then when one finishes editing, the interactor will automatically reload the file)
10:44:56 <cocreature> fwiw you can also specify a different module and a different function than Main and main as the starting point. That just happens to be the default
10:45:24 <ski> yea, one can fiddle with it, with command-line flags to `ghc'/`ghci'
10:45:43 <ihsancz> @cocreature how would one do that?
10:45:43 <lambdabot> Unknown command, try @list
10:46:17 <ski> ssm21 : so, what's your current code now ?
10:46:28 <cocreature> ihsancz: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/phases.html?highlight=main-is#ghc-flag--main-is%20%E2%9F%A8thing%E2%9F%A9
10:46:59 <ihsancz> cocreature: thank you!
10:47:02 <cocreature> it isn’t particularly common to do that but it can be useful sometimes
10:48:27 <ihsancz> yeah, don't really need it right now but I can see that that could be needed at one point 
10:49:19 <ski> ihsancz : you can say `ghc -main-is Foo.bar MyFile.hs' (or with `ghci' in place of `ghc')
10:50:35 <ski> (where the module which would normally be found under the name `Main' is now to be found under `Foo', and in stead of the main action being called `main', it'll look for an action called `bar')
10:50:40 <ihsancz> nice, ty for writing that out
10:53:57 <ski> ihsancz : you'll probably also have fun with the Prolog chapter in that book
10:54:31 <ihsancz> ski: yeah, I directly started out with Haskell right now to learn more about functional programming etc
10:54:59 <ihsancz> I've been told that in Haskell, you basically can't even do anything beside fucntional programming
10:55:12 <ski> heh ..
10:55:19 <ihsancz> right? ;p
10:55:42 <ski> you can do imperative programming, with updating of mutable boxes ("variables"), if you like
10:55:50 <cocreature> you can but functional programming is at least the path of least resistance in Haskell
10:56:17 <ihsancz> yeah, I'll have to try to avoid variables etc
10:56:31 <ihsancz> this: double x = x + 2 - that's a function right?
10:56:34 <ihsancz> a function called double
10:56:39 <ihsancz> x = mutable box (variable
10:56:59 <ski> but that part of the language is nicely compartmentalized away. you'll know, just by looking at the interface (/ prototype / type signature) of a library operation, whether it *possibly* could do some effect like reading a file, or changing (or even reading) the contents of some mutable container
10:57:05 <cocreature> x is not mutable
10:57:24 <ski> that's a function *definition*
10:57:32 <ski> `double' is the function itself
10:57:44 <ski> `x' would be called a variable in Haskell
10:58:01 <ski> in Haskell, variables are *not* mutable (just like they're not mutable in math)
10:58:20 <ski> and functions in Haskell are a lot more like functions in math, than functions in most other programming languages
10:58:23 <ihsancz> oh hm, yeah I thought it was mutable because we set x to x + 2
10:58:50 <ski> if you run a function in C, or a method in Java, twice, with the same input arguments, you could still perhaps get different results/outputs
10:59:13 <ski> not so in Haskell : if you call a function with same (or equal) inputs, then the output will be the same/equal
10:59:44 <ihsancz> ah okay, so x
10:59:48 <maerwald> except for IO :)
11:00:00 <ski> also, the result of the function won't depend on some dynamic state. it can't read from some mutable global, so that the behaviour of the function depends on what's currently in that mutable global
11:00:01 <ihsancz> x is immutable because it's value isn't stored anywhere
11:00:44 <ski> .. you can *achieve* the same effect of this, if you really want/need to .. but then you have to involve not just functions, but also "actions"
11:01:02 <maerwald> also, gcc has a pure function attribute, but it's mainly a gccism for optimisation I think
11:01:23 <ski> an action can be allowed to change (and access) mutable stuff, and can be allowed to communicate with the surrounding world (via the operating system)
11:01:34 <ski> a plain function can't do these things
11:01:53 <ihsancz> gccism?
11:01:56 <ski> maerwald : nah, no exception ;)
11:02:04 <maerwald> ski: it is
11:02:15 <maerwald> calling a function is not just evaluating it :)
11:02:16 <ski> (invoking/executing/running an action, is not the same thing as calling a function)
11:02:30 <maerwald> as a programmer, you care about both, not just evaluation
11:02:38 <ski> yes, i agree about that
11:02:41 <maerwald> it's just that it's more strictly separated
11:02:46 * ski nods
11:03:33 <ski> evaluation is about simplifying expressions, calling functions, replacing the call to the function with the body of the function, while replacing the formal parameters of that function definition with the actual parameters from the call
11:04:12 <ski> ihsancz : so `=' in Haskell is not assignment, `x = 2' does not mean "please make sure that from now on (until further notice), `x' refers to `2' (regardless of what it referred to before)"
11:04:40 <ski> ihsancz : `x = 2' means that `x' is defined to be equal to, the same as, `2', now and forever. no later changing of the value of `x'
11:04:54 <ihsancz> ah I see. and what about let?
11:04:56 <ihsancz> let x = 2
11:05:25 <ski> `let' is just syntax to be able to make a local definition inside some expression (e.g. the body of a function definition)
11:05:54 <ski> ihsancz : in `double x = x + 2', this is defining `double x' to be equal to `x + 2', in this case for every possible value of `x' that we pass as input to the function `double'
11:06:23 <ski> so it's defining the function `double', by defining what the output, the result of evaluating a call `double x', should be, for every possible input `x'
11:06:55 <ihsancz> oh alright, thought that with let you'll create mutable vars. How would one create variables then? do you have an example?
11:07:09 <ski> so, if you call `double 3', then that would effectively create a new variable, which is "bound to" the actual parameter, the argument, `3', and then `x + 3' is evaluated
11:07:09 <ihsancz> ^ so I can avoid it :p
11:07:49 <ski> if you then call `double 5', then that will in effect create a new, *different*, variable `x', which is instead bound to `5', and then `x + 3' is evaluated for *that* variable `x'
11:08:17 <ski> so, even if you call `double' mulitiple times, there is no (re)assignment of different values to (a single variable) `x'
11:08:40 <ski> instead, there's different variables, one for each call to `double', which get bound to (potentially) different values
11:09:12 <nshepperd> ihsancz: to create mutable variables you need to import a library such as Data.IORef. you're not likely to do it by accident
11:09:23 <ski> another term for "bound to" could be "initialized as". but since we don't allow (re)assignment of variables, we tend to not use the term "initialize" here
11:09:56 <ski> here's an example of creating a mutable box, which is then changed :
11:10:32 <ski>   import Data.IORef
11:10:34 <ski>   
11:10:35 <ihsancz> nshepperd: sounds like I won't do that on accident yeah :p
11:10:37 <ski>   main = do
11:10:47 <ski>     ref <- newIORef 10
11:11:02 <ski>     x <- readIORef ref
11:11:17 <ski>     writeIORef ref (x + 3)
11:11:23 <ski>     y <- readIORef ref
11:11:30 <ski>     writeIORef ref (2 * y)
11:11:33 <ski>     z <- readIORef ref
11:11:37 <ski>     print z
11:12:12 <ski> `ref' here is just an ordinary variable (which can't be changed, can't be assigned to). however `ref' is *referring* to some mutable box, which we *can* change the contents of
11:12:38 <ski> `readIORef' will access the current contents of such a box, given a reference to it, and `writeIORef' will change the contents
11:12:53 <ski> `newIORef' will allocate a new mutable box, with a specified initial value
11:13:23 <ski> these are all library routines, exported by the module `Data.IORef' that i imported
11:14:07 <ihsancz> ah I see, thanks for the explanation. I'm gonna play around with that soon :)
11:14:11 <ihsancz> but, I don't get this:
11:14:21 <ski> you can think of a reference here like an address of, or a pointer to, the mutable cell/box. except we can't do any pointer arithmetic on it. we can just access and change its contents
11:14:28 <ihsancz> module Test where
11:14:28 <ihsancz>     double x = 2
11:14:53 <ihsancz> don't I set 2 to x
11:15:06 <ihsancz> dam'n my mind is gliding away
11:15:22 <ski> and .. we can't do this (creating, accessing, and changing the contents of a mutable box) from general functions. we need to be inside an "action", which is typically indicated with the `do' syntax i used (which is however syntactic sugar over more basic (library) operations)
11:15:24 <im0nde1> Sorry quick offtopic: is this room bridged to the Haskell IRC channel on freenode?
11:15:41 <nshepperd> ihsancz: that should be parsed as '{double x} = 2', not 'double {x = 2}'
11:15:58 <nshepperd> ihsancz: the thing that is being defined to be 2 is 'double x'
11:16:05 <sm> im0nde: this room seems to BE the Haskell IRC channel on freenode :)
11:16:06 <hpc> im0nde1: https://www.youtube.com/watch?v=pzYGWF6qrts
11:16:15 <sm> and it is bridged to matrix, yes
11:16:36 <ski> ihsancz : no, `double x = 2' parses as `(double x) = 2', so you're defining `double x' (the result of calling the function `double' on some input, call it `x') to be `2' (so, ignoring the input `x')
11:16:54 <ihsancz> ah yeah okay that makes sense
11:17:01 <ihsancz> thanks nshepperd, ski
11:17:15 <ski> (oh, im0nde1 is connecting via Matrix)
11:17:22 <ihsancz> brb
11:18:12 * sm thinks im0nde seems to be connected via IRC
11:18:28 <ski> apparently, yes
11:18:56 <Solonarv> the Matrix bridge works by connecting to IRC on behalf of the user
11:18:57 <coot> Is there a way to install ghc with ghcup so that the base library is compiled with haddock documentation? (for :doc support for ghci)
11:19:08 <coot> Is there a way to install ghc with ghcup so that the base library is compiled with haddock documentation? (for :doc support in ghci)
11:19:24 <Solonarv> * Matrix/IRC bridge
11:19:52 <monochrom> I think it already does?
11:20:17 * hackage hledger-flow 0.11.0.0 - An hledger workflow focusing on automated statement import and classification.  https://hackage.haskell.org/package/hledger-flow-0.11.0.0 (apauley)
11:20:26 <monochrom> Because ghcup simply downloads from the official GHC website which already did.
11:20:59 <coot> at least for ghc-8.6.4 it does not 
11:22:18 <ski> ihsancz : btw, there's a reason that `do'-notation example used `<-', and not `='. `<-' is used in `do'-syntax to name the result of executing/running/performing some action (which may have some effect other than computing said result value from given inputs). for "ordinary" naming of the result of an evaluation, you use `=' (and `let' or `where', if you're inside the body of some outer definition)
11:23:11 <monochrom> I'm afraid mainstream programming languages have brainwashed people to believe that "=" means change rather than mathematical equality.
11:23:35 <coot> but it does with ghc-8.6.3, maybe the latest version is treated differently
11:23:39 <Solonarv> monochrom: sometimes it also means equality testing! very confusing
11:24:31 <Solonarv> coot: perhaps there was some mistake in the process of creating the bindist, GHC's ops setup is/was going through some changes
11:25:41 <coot> Solonarv hmm, maybe there's a ticket for that
11:26:10 <cocreature> coot: which OS?
11:26:23 <coot> GNU/Linux
11:26:50 <cocreature> hm not sure about that. I know that the windows bindist was broken in various ways but I haven’t heard about problems with the linux bindist
11:27:35 <ihsancz> ski, that makes sense, ty :)
11:27:58 <maerwald> coot: ~/.ghcup/ghc/8.6.4/share/doc/ghc-8.6.4/html/libraries/base-4.12.0.0 looks good to me
11:30:19 <coot> maerwald: it indeed seems ok, but still `:doc print` (or any other function from base) shows the `... Try re-compiling with '-haddock'` message.
11:30:54 <maerwald> hm, that command is supposed to change in 8.8 anyway
11:31:11 <maerwald> and is marked experimental
11:43:11 <Habib> Can someone explain to me why amazonka's ObjectKey type has a FromText instance that can fail with Maybe, yet at the same time, has an _ObjectKey :: Iso' ObjectKey Text that converts cleanly between the two? What's the canonical way to construct an ObjectKey when I have a Text?
11:45:13 <Habib> This isn't critical, as I can just construct it manually the same way the lens `Iso` does, as it's just a newtype over `Text` (and I don't know how to use lens `Iso`s).
11:45:46 <maerwald> coot: I tried :doc with a self-compiled ghc-8.6.4, it works, so yeah, must be bindist messup
11:48:40 <maerwald> coot: if you feel lucky, remove ghc-8.6.4 then run 'ghcup compile 8.6.4 ghc-8.6.3'
11:49:10 <coot> maerwald: let me try :)
11:49:22 <maerwald> maybe also pass --jobs 4
11:49:24 <maerwald> or something
12:22:18 <fen> how much space does a function take up?
12:23:09 <fen> like, what takes more space, a list of functions, or a list of parameters and something to map over this to get a list of functions? 
12:23:33 <Cale> It depends
12:23:33 <fen> what takes up more space, the parameter, or the function?
12:23:46 <Solonarv> IIRC a function is 2 words + however much space is needed for the values the function closes over
12:23:58 <Solonarv> might only be 1 word, not sure
12:24:11 <fen> "closes over" ?
12:24:27 <fen> "is applied to?"
12:24:31 <Cale> The variables which occur in the body of the function but aren't bound by lambdas
12:24:37 <fen> ohhh
12:24:47 <Solonarv> \x -> \y -> x -- the inner lambda closes over x
12:24:57 <fen> all the where and let bound internal variables which are assigned, ok
12:25:48 <fen> is there a class for functions which can be composed and simplified?
12:26:04 <fen> like (+1) . (+2) = (+3)
12:26:20 <fen> the composed version would take less space right?
12:26:52 <fen> instead of having eg foldr (.) id $ map (+) [1,2]
12:27:26 <fen> the point is we should be able to tell if the representation is going to be able to be compressed
12:27:44 <fen> because depending on this we might choose between approaches 
12:27:55 <Cale> No, there's no such class, and it's not even really well-defined, since the compiler has a lot of freedom to do or not do any particular such thing
12:28:09 <Cale> It may or may not inline the definition of any given function
12:28:30 <fen> so we have no way to direct it to choosing the more effecient representation?
12:28:46 * ski . o O ( `RULES' )
12:28:52 <Cale> Well, there are RULES pragmas
12:28:59 <Cale> and there are compiler plugins
12:29:08 <fen> what like (fmap f . fmap g = (fmap (f.g)))
12:29:12 <ski> yes
12:29:16 <fen> the rhs is a smaller representation?
12:29:35 <Cale> I don't think GHC will actually do that one most of the time.
12:29:54 <Solonarv> that transformation shouldn't change the size of the corresponding closure
12:29:56 <Cale> Because it has no way of knowing that your instance of Functor is law-abiding.
12:29:59 <fen> like (foldr (.) id $ fmap (fmap id) )
12:30:03 <Solonarv> however it will produce code that runs faster
12:30:10 <Solonarv> (at least, usually)
12:30:21 <ski> at least it could be more efficient (no intermediate structure constructed), given a naïve evaluation of either side
12:31:18 <ski> (consider s/fmap/map/)
12:31:21 <fen> > :t foldr (.) id $ fmap (fmap id)
12:31:23 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
12:31:29 <fen> :t foldr (.) id $ fmap (fmap id)
12:31:30 <lambdabot> (Functor f, Foldable ((->) (f b -> f b))) => f b -> f b
12:31:34 <Cale> However, after inlining the definition of composition and then fmap, assuming that the fmap specialises to a particular type, and if that fmap implementation itself isn't recursive, you can probably expect a bunch of stuff to collapse.
12:32:12 <Solonarv> or also if that fmap implementation refers to e.g. map, which has a RULES for collapsing
12:32:20 <fen> right, so if it collapses then it has a smaller representation
12:32:26 <fen> but if it doesnt it might not
12:32:52 <Cale> Actually it probably uses more space, because you have a specialised implementation
12:32:55 <fen> so we should be able to check to see if we want to use a representation that would only be more effecient if such RULES could be applied
12:33:13 <Cale> But the closures over it will be roughly the same size
12:33:15 <MarcelineVQ> on the current subject, are there partial evaluation libs on hackage?
12:33:50 <Cale> (I mean, you have a specialised implementation in addition to the polymorphic one potentially hanging around somewhere else)
12:34:06 <Solonarv> fen: see the GHC commentary for the layout & size of heap objects - https://gitlab.haskell.org/ghc/ghc/wikis/commentary/rts/storage/heap-objects
12:34:25 <fen> ok
12:37:57 <Solonarv> ah, looks like it's one word + however much space is needed for what the function closes over
12:38:55 <Solonarv> ...well, partial applications are more complicated
12:40:24 <fen> is that smaller than an Int?
12:40:49 <fen> what if the function uses const and is mapped over [()]
12:40:57 <fen> then its just the same function over and over
12:41:31 <fen> so it shouldnt need to store anything except a reference to the same function at each position, which is roughly the same size as the () was?
12:42:01 <fen> (this is if there are no (.) fusion rules for when it is folded over with (.) for "repeatedly")
12:42:51 <fen> the idea is that a unitary Int built using multiplication might be faster than using the Int directly as long as it does not need to access the actual value of the Int
12:43:19 <fen> which is "repeatedly" applying the same function - it cant depend on the value it encounters, so its always just consting away a ()
12:44:01 <fen> maybe there is a carried value, that would complicate things... but repeatedly is very simple, and maybe we can have a class of things that will fuse with (.)
12:45:21 <Solonarv> Int is two words (one for the box, one for the actual value)
12:45:24 <fen> like if it was repeatedly (n :: [()]) (+1) we could give a fusion for ((+n) . (+m) = (+) (n+m))
12:46:40 <fen> then if (n = i*j) then repeatedly n = repeatedly (replicate i (replicate j ()))
12:47:17 <fen> so repeatedly (i*j) (+1) = repeatedly i (+j)
12:47:29 <fen> would be obtained via the RULES
12:47:43 <fen> (not given as one rule, but that the compiler would arrive at this)
12:47:58 <fen> and that has a smaller representation
12:48:47 <fen> so if you "repeatedly" do the same thing over and over, and that thing can be fused when composed with itself, then the unitary itterator is more effecient
12:56:23 <fen> basically this could lead to; repeatedly (i*j*k ... *n*m) (+1) = repeatedly (i*j*k ... *n) (*m) = repeatedly (i) (j*k ... *n*m) = i*j*k ... *n*m
12:57:03 <fen> just using the fusion rule ((+i) . (+j) = (+ (i+j)))
12:58:01 <fen> and it only has to count to each of i,j,k .. n,m once each. so the complexity is sum [i,j,k .. ,n,m] instead of product  [i,j,k .. ,n,m]
12:58:07 <fen> thats a seemingly huge saving
12:59:02 <fen> the sum of the product of primes is like, below O log n?
13:20:57 <ibloom> Why is there no instance of Bounded for Float?
13:23:09 <hpc> Float is too powerful to be limited by min and max bounds
13:23:10 <hpc> https://www.youtube.com/watch?v=5TFDG-y-EHs
13:23:11 <hpc> :P
13:26:09 <ibloom> Oh you Haskellers you.
13:27:07 <ibloom> Now I have to spend 30 seconds writing an instance for my newtype.
13:27:26 <hpc> i have a feeling it has to do with Float not being Enum either
13:27:45 <hpc> or wait, it is Enum
13:27:59 <hpc> maybe it's because of NaN
13:28:01 <MarcelineVQ> it is, it's kind of weird, but is detailed in the standard
13:32:45 <geekosaur> becaue Float's bounds are weird, shaped by how it's represented per the spec
13:33:01 <geekosaur> not only NaN, but you get in effect different "bounds" for the mantissa depending on what the exponent is
13:33:11 <ibloom> I see.
13:33:20 <geekosaur> so for example you can have a Float where adding 1 doesn't change its value
13:33:40 <hpc> that only affects Enum though, i thought
13:33:52 <geekosaur> that specific one, yes
13:34:17 <geekosaur> I guess I need to not provide examples unless I can somehow come up with one that doesnt evoke something else at the saem tiem
13:34:51 <hpc> Float breaks enough rules that i am sure there's some reason
13:34:54 <geekosaur> do recall Enum and Bounded are somewhat incestuously related, as defined by Haskell
13:35:18 <hpc> laws-wise, yeah
13:39:32 <Berengal> Hello, I have a Tower -> Move -> Maybe Tower, how do I write Tower -> [Move] -> [Tower] ?
13:40:24 <Berengal> Other than just using recursion I mean
13:41:20 <lyxia> :t mapMaybe
13:41:20 <hpc> you can use these two functions to apply the function you have to each element of the move list, and then filter it
13:41:21 <lambdabot> (a -> Maybe b) -> [a] -> [b]
13:41:25 <hpc> :t map
13:41:26 <lambdabot> (a -> b) -> [a] -> [b]
13:41:27 <hpc> :t catMaybes
13:41:28 <lambdabot> [Maybe a] -> [a]
13:41:45 <hpc> ah, or mapMaybe is more direct
13:41:55 <hpc> :t filter -- getting a bit more general, as well
13:41:56 <lambdabot> (a -> Bool) -> [a] -> [a]
13:42:24 <Berengal> I'm feeding the result of one move into the next function
13:42:34 <Berengal> so it's a fold of some kind
13:43:17 <lyxia> ahhhh
13:43:55 <Berengal> Sorry that wasn't clear
13:44:37 <lyxia> And you want the list to stop if you get nothing?
13:44:51 <Berengal> yes
13:45:00 <lyxia> I can't think of a nice one liner. It sounds like a kind of scan though.
13:45:14 <lyxia> or unfoldr
13:46:16 <hpc> definitely a scan here, if you're given a list of moves to start
13:46:17 <lyxia> or something with a sufficiently rich recursion-schemes library, but it's not sufficiently rich.
13:46:17 <hpc> :t scanr
13:46:19 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
13:46:24 <hpc> :t unfoldl
13:46:26 <lambdabot> error:
13:46:26 <lambdabot>     • Variable not in scope: unfoldl
13:46:26 <lambdabot>     • Perhaps you meant one of these:
13:46:41 <hpc> yes lambdabot, i meant one of those :P
13:46:45 <Berengal> unfoldr works I think, but it won't be pretty
13:47:16 <lyxia> plain recursion is best
13:47:20 <lyxia> IMO
13:47:28 <Berengal> that's the conclusion I'm slowly coming to
13:48:23 <Berengal> thanks for the help
14:17:01 <fen> <Solonarv> this is in no way "faster than Ints"
14:17:30 <fen> <Cale> I wouldn't worry about the performance of any of these because they're all hilariously impractical to use
14:17:41 <Solonarv> oh, got a benchmark?
14:18:09 <fen> its in a teapot orbiting a distant planet
14:19:28 <fen> burden of proof avoided by appealing to reasonable something argument
14:20:14 <fen> qed
14:21:20 <kencure> any one here use Kali Nethunter?
14:25:53 <ski> what's that ?
14:28:29 <fen> why would fusion rules need benchmarks?
14:28:39 <fen> we are using equational reasoning 
14:29:02 <fen> you could claim to "only be convinced by benchmarks", maybe
14:29:12 <hpc> fusion rules are done for optimization, but are implemented as just rewriting some piece of source to another piece of source
14:29:16 <fen> but not when this equivalently convincing thing exists
14:29:17 <hpc> they don't even have to be functionally the same
14:29:30 <hpc> so you have to show they are functionally the same
14:29:40 <hpc> and then you have to somehow determine that one form is consistently faster
14:29:47 <fen> no, we assume they are
14:29:49 <hpc> haskell has no cost model, so the only way to do that is direct measurement
14:30:06 <fen> *if* the fusion rules are valid, then the rewrite can be faster
14:30:11 <hpc> no
14:30:34 <hpc> fusion rules are simple rewrites of specified code patterns
14:30:49 <hpc> it can be faster, or it can be slower
14:31:03 <fen> so totally disjoined from benchmarks as a way to verify the validity of a performance comparison
14:31:46 <fen> ok, so we have to make some additional assertions about the nature of the rewrite
14:32:49 <hpc> no, you have to measure
14:32:56 <hpc> imagine you're the one writing the rules in the first place
14:33:07 <hpc> is (map f . map g) faster or slower than map (f . g)?
14:33:20 <hpc> remember that haskell has no cost model
14:33:31 <Solonarv> fen: you're claiming "doing things <this way> is faster"
14:33:32 <hpc> you don't know how slow calling map is, how slow (.) is, or f or g
14:33:45 <hpc> and you don't know if the order you evaluate the result changes things, etc
14:33:55 <hpc> so how do you assert anything here?
14:34:06 <Solonarv> common wisdom disagrees with your claim, so you're going to have to provide some dang evidence beyond "it makes sense to me"
14:34:18 <fen> but like for the ((+i) . (+j) = (+(i+j))) rewrite; foldr (.) id $ map (+) $ replicate n 1 = (+n), this is obviously less memory intensive than storing the list of (+1), and if we can reuse this result, its obviously less computationally intensive than reproducing it needlessly 
14:34:37 <hpc> nothing is obvious in that statement
14:35:03 <fen> Solonarv: a very simple version is just; caching something is less costly than recalculating it. you wouldnt need a benchmark for that
14:35:18 <hpc> caching something is often more expensive than recalculating it
14:35:22 <fen> not only a benchmark is compelling here
14:35:41 <Solonarv> fen: that isn't even true if the thing is big and you don't need it much, or if you don't need it often
14:35:44 <fen> hpc: ok, *can* be less expensive
14:36:16 <fen> and the idea here is that storing an Int is cheaper than decrimenting it all the way to 0
14:36:30 <hpc> fen: "can" is meaningless here
14:36:41 <fen> "is in this case"
14:36:47 <fen> even if not always
14:37:00 <hpc> prove it
14:37:02 <fen> sum $ repeat n 1
14:37:02 <Solonarv> you're claiming a particular way of doing something is less memory intensive, but you're not even willing to run it with +RTS -s ?
14:37:07 <hpc> again, haskell has no cost model
14:37:14 <fen> its cheaper just to use n!
14:37:20 <hpc> so you have no way of saying without measurement that ANYTHING in haskell is cheaper than anything else
14:37:26 <hpc> at all
14:37:27 <hpc> ever
14:37:29 <hpc> it's impossible
14:37:57 <Solonarv> hpc: while Haskell doesn't have a cost model, it's certainly possible to reason about costs in Haskell-as-implemented-by-GHC
14:38:00 <fen> cost {sum $ repeat n 1} > cost {n}
14:38:40 <Solonarv> (which is distinct from Haskell-as-defined-by-the-report)
14:39:58 <hpc> fen: that's not always true either, assuming you're generalizing over all numeric types
14:40:06 <fen> n :: Int
14:40:08 <hpc> it's certainly true if both sides :: Int
14:40:24 <fen> the above is a counterexample to any argument saying that only a benchmark could be convincing
14:40:27 <hpc> but you're using different types on both sides when you extend that to your idea from yesterday
14:40:47 <hpc> cost {sum $ repeat n 1} :: Int < cost {n :: Nat}
14:40:57 <fen> no, thats the same, the [()] was produced from an Int and that Int is recovered on fusion
14:41:12 <fen> or at least, its recalculated by folding over the [()]...
14:41:32 <fen> no it is recovered exactly by fusion! it doesnt even need to be counted to!
14:42:25 <fen> repeatedly (replicate (i :: [()]) (replicate j (replicate ...))) (+1)
14:43:04 <fen> = (i*j ...) by fusion
14:43:35 <fen> then we calculate the number by multiplication instead of +1
14:43:42 <fen> thats way cheaper
14:43:47 <hpc> multiplication on Nat
14:43:50 <fen> no
14:44:05 <fen> the nats are all unfolding state of decrementing ints
14:44:19 <fen> and those states are recovered by fusion
14:44:31 <fen> oh, ok maybe the actual ints are not...
14:44:46 <fen> but then you just need to get an Int from that state one time
14:45:23 <fen> instead of having a state with the total number, and unfolding and then folding with const (+1)
14:45:39 <Solonarv> look, creating a basic benchmark to prove your claims isn't hard
14:45:41 <fen> you just do that recounting on each of the factors of the large number
14:45:57 <fen> Solonarv: yes it is! the library isnt finished!
14:46:04 <fen> if it isnt so hard you do it
14:46:13 <Solonarv> who said anything about benchmarking the entire library?
14:46:16 <fen> otherwise stop insisting its a nesacary form of proof
14:46:25 <hpc> you have the code to test right there it looks like
14:46:31 <Solonarv> I'm only talking about the claim that [()] is supposedly faster than Int
14:46:41 <fen> well the parts of the library which would be required are obviously the parts missing"!!
14:46:42 <hpc> just write repeatedly, then run it
14:46:50 <Solonarv> benchmarks are not a *necessary* proof
14:47:08 <fen> then why keep pushing that it requires benchmarking
14:47:08 <Solonarv> but you repeatedly stating how bloody obvious this is to you is certainly not sufficient to convince me
14:47:21 <fen> just accept the logical argument and quit asking me to do unnesacary work
14:47:37 <MarcelineVQ> Solonarv: yeah, gosh
14:47:38 <Solonarv> benchmarks would be sufficient, and are pretty easy to do
14:47:49 <fen> so is a logical argument
14:48:00 <Solonarv> if it holds water, yes
14:48:09 <fen> your refusal to comprehend it does not cause me to have to do the kind of proof you prefer
14:48:11 <Solonarv> as far as I can see yours doesn't
14:48:19 <hpc> https://www.youtube.com/watch?v=dFIDh74nZSk
14:48:31 <fen> you could always do that, "i dont accept your proof"
14:48:37 <fen> thats not how it works
14:48:48 <fen> your not a compiler
14:48:50 <Solonarv> conversely, your refusal to do anything other than state how brilliant your idea is does not cause me to be convinced that your claim is true
14:48:53 <fen> you can even correct typos
14:48:59 <MarcelineVQ> hpc: big willy style bullies shodan (gone wrong)
14:49:28 <hpc> fen: that... is how it works
14:49:30 <fen> like you could help make it a better argument instead of using its poor phrasing against it
14:49:42 <hpc> papers are rejected regularly for being confusing to peer reviewers
14:49:43 <fen> hpc: no we had a concrete counterexample to that above
14:49:55 <fen> thats as far as i need to go in this argument 
14:50:32 <fen> "haskell has no cost model therefore benchmarks are always necessary" is false
14:50:37 <fen> we have equational reasoning also
14:50:52 <fen> and that happens to be what this argument is based on
14:50:53 <hpc> performance does not obey equational reasoning
14:51:01 <hpc> if it did, fusion rules would be literally pointless
14:51:21 <fen> so its actually quite reasonable to refuse to accept that benchmarking is nesacary here as it seems actually quite fundamental that it isnt
14:51:56 <fen> its one thing to think that my code might not be as fast as i think it could be, its another to refute the utility of equational reasoning in proofs about performance
14:52:29 <hpc> then i guess it's another thing :P
14:52:34 <fen> i actually dont much care if you dont think there is any way unitary nats can outperform Ints, even though i am convinced that I have given a complete justification of how they can be
14:53:05 <fen> but the idea that only a benchmark is sufficient proof is definitely worth refuting heavily 
14:54:06 <hpc> suppose you have two functions that sort an input list
14:54:16 <hpc> they're both implemented correctly, so they are equationally equal
14:54:23 <fen> to appeal to logical falacy to convince me to do something you would like to see done isnt on at all
14:54:29 <hpc> forall xs. sort1 xs = sort2 xs
14:54:40 <hpc> are they always identical in performance?
14:58:30 <isn> hi
14:58:34 <r0x> hi
14:59:16 <Solonarv> hello!
15:00:47 <r0x> hello Solonarv 
15:23:47 * hackage telega 0.1.3 - Telegram Bot API binding  https://hackage.haskell.org/package/telega-0.1.3 (iokasimovmt)
15:48:28 <delYsid`> What newtype do I need to use to get a shortcircuiting instance for Monoid m => Maybe m when using fold?
15:48:43 <delYsid`> > fold [Just "1", Nothing, Just "2"]
15:48:45 <lambdabot>  Just "12"
15:49:12 <delYsid`> i.e., it should return Nothing
15:50:32 * Solonarv head scratch
15:50:47 <Solonarv> > getAp . foldMap Ap [Just "1", Nothing, Just "2"]
15:50:48 <lambdabot>  error: Variable not in scope: getAp :: b0 -> cerror:
15:50:49 <lambdabot>      • Data constructor not in scope: Ap :: Maybe [Char] -> a -> b0
15:50:49 <lambdabot>      • Perhaps you meant one of these:
15:51:18 <Solonarv> % getAp . foldMap Ap [Just "1", Nothing, Just "2"]
15:51:19 <yahb> Solonarv: ; <interactive>:60:9: error:; * Couldn't match expected type `a -> Ap f a1' with actual type `Ap Maybe [Char]'; * Possible cause: `foldMap' is applied to too many arguments; In the second argument of `(.)', namely `foldMap Ap [Just "1", Nothing, Just "2"]'; In the expression: getAp . foldMap Ap [Just "1", Nothing, Just "2"]; In an equation for `it': it = getAp . foldMap Ap [Jus
15:51:38 <Solonarv> % getAp . foldMap Ap $ [Just "1", Nothing, Just "2"] -- whoops
15:51:38 <yahb> Solonarv: Nothing
15:52:08 <delYsid`> what does Ap stand for here?
15:52:13 <Solonarv> delYsid`: ^
15:52:30 <Solonarv> newtype Ap f a = Ap { getAp :: f a }
15:53:14 <Solonarv> instance (Applicative f, Semigroup a) => Semigroup (Ap f a) where (<>) = liftA2 (<>)
15:53:14 <Solonarv> instance (Applicative f, Monoid a) => Monoid (Ap f a) where mempty = pure mempty
15:53:45 <delYsid`> oh, now I get it. It means applicative.
15:53:48 <Solonarv> in base since 4.12 I think
15:53:49 <Solonarv> yup!
15:53:53 <delYsid`> which is indeed what I want.
15:54:28 <Solonarv> I've wanted that a few times before it was in base and was annoyed at having to define it myself :P
15:54:52 <delYsid`> Where is that defined, not in Data.Semigroup.
15:55:38 <delYsid`> I actually just wrote a bug because I was assuming it would be the default instance of Maybe haha.
15:55:55 <Solonarv> Must be Data.Monoid, then
15:56:26 <delYsid`> oh, maybe tried on wrong machine with old ghc
15:56:51 <Solonarv> Yeah I was about to say that ^^
15:58:58 <delYsid`> there you go, thats better.  Now the testsuite doesn't always succed just because only the first test passed :-]
16:16:23 <dmwit> :t fmap fold . sequence
16:16:24 <lambdabot> (Monad f, Traversable t, Monoid b) => t (f b) -> f b
16:17:28 <r0x> :t 1
16:17:29 <lambdabot> Num p => p
16:17:37 <r0x> :t (+1)
16:17:38 <lambdabot> Num a => a -> a
16:33:52 <slack1256> Ideally I would like the different subsystems of a program to interact in well defined ways to maintain shared state, ideally with some formalism of a state machine
16:34:44 <slack1256> Immutability helps reach that goal, but sometimes I feel temped to just write a custom (lens) modification of a core data structure because is just so easy.
16:35:02 <slack1256> Is there any way to define interaction between components that isn't as rigid as a state machine?
16:39:12 <Solonarv> Hm, perhaps you should look into FRP?
16:46:44 <slack1256> I don't know anything about FPR, I thought it was just some paradigm useful for UI programming
16:46:52 <slack1256> kind of a replacement for MVC
16:49:29 * ski . o O ( Fudgets )
16:52:43 <Solonarv> Sure, it's used for GUI programming because that's an area where you have lots of state and different parts of the program interacting with each other
16:57:17 <slack1256> I need a good tutorial/toy example that shows its power, I don't care what library it uses
17:00:41 <slack1256> ski: How long have you been using haskell? :-)
17:02:11 <fen> "unitary ints are slow" - "no, they can be faster than ints" - "wrong" - "why?" - "they are memory intensive" - "not if they fusion away" - "this is not a good enough answer, you should benchmark it" - "no need, it is a good enough answer" 
17:33:55 <ostfale> f m n x = (m * x) + n 
17:33:57 <ostfale> How can you freely use functions partially in Haskell? For example, I just want to implement the parameter "n"? If I say "a = f 3", m is implemented, which I do not want.
17:35:22 <monochrom> I would use a lambda. \m x -> f m 3 x
17:36:31 <slack1256> Also sometimes you can `flip`, `\m x -> f m 3 x` is equal to `flip f 3`
17:36:56 <Solonarv> also sometimes helpful: operator sections, e.g. (`elem` someList) instead of \x -> elem x someList
17:37:16 <slack1256> ^ that one is specially useful
17:37:20 <Solonarv> I usually prefer (`func` foo) to (flip func foo)
17:38:27 <Solonarv> or you can do this (but please don't):
17:38:27 <Solonarv> @pl \m x -> f m 3 x
17:38:27 <lambdabot> flip f 3
17:38:28 <ostfale> mh lambda sounds ok. So Haskell offers no way, for example, with underscore _ to skip a paremeter?
17:38:31 <Solonarv> bah!
17:38:57 <Solonarv> no, not for partial application
17:46:10 <ski> ostfale : thankfully, no
17:46:50 <ski> (it has been suggested before, more than once, in this channel)
17:47:11 <Solonarv> wouldn't be surprised if there's been a(n attempted) ghc proposal too
17:48:08 <ostfale> ok, thanks for the answers :)
17:48:30 <ski> ostfale : also, fwiw, i wouldn't say "use functions partially", since that sounds like you're talking about partiality. while you were actually talking about partial appliction. (similarly you don't "implement" a parameter, you partially apply the function to a value for it. or you specify it in advance, or something similar)
17:49:06 <ski> ostfale : if you're interested, i could go more into why i'd think it'd be a bad idea ..
17:49:33 * slack1256 thinks the netwire tutorial is awesome
17:51:42 <ostfale> ski: yes, why do you think so?, 
17:55:34 <ski> well, first, every Haskell function takes/has exactly one argument/input/parameter
17:56:09 <ski> from a strict perspective, the arity of every Haskell function is `1', or, if you prefer, it's a meaningless concept
17:56:12 <ski> however
17:57:31 <ski> we still have an idea of "multiple argument/parameter functions". the most obvious way to see this is to consider an expression with multiple free variables, like `a*x^2 + b*x + c', which we can consider to "be a function in `a',`b',`c',`x'"
17:58:57 <ski> so, we could choose to pick out (only) `x' from that "array" of free variables (or ("replicated") "slots"), considering the function that maps any input, call it `x', to `a*x^2 + b*x + c'. so this function does not depend ("any longer") on `x', but it still depends on `a',`b',`c'
17:59:35 <ski> or, if we prefer, we could "consider" the expression as a function of `a',`b',`c', so this function only depends on `x', not on those other three variables
17:59:45 <ski> (or some other selection of the free variables)
18:00:18 <ski> now, how do we actually represent such a function of multiple inputs, in a language which only allows functions-of-one-input ?
18:00:44 <ostfale> Partial application :D
18:00:55 <ski> not yet :)
18:01:59 <ski> there's two basic encoding stategies. one is called currying, in which we select an ordering amongst the selected variables, and construct a function that, given a value for the first variable, will return a function that is a multiple-argument function of the remaining variables. and that is in turn also (usually) represented via currying, until we run out of arguments
18:02:25 <ski> so in the above example, we could have `\a -> \b -> \c -> a*x^2 + b*x + c'
18:02:52 <ski> well, actually we shouldn't call the encoding "currying", but rather "curried style", or something like that
18:03:27 <ostfale> yes, you mean: f :: a -> (a -> a -> a) (Regarding my example)
18:03:51 <ski> anyway, the other encoding might be called "tupling". the idea is that we pack the (conceptually) multiple arguments together, into a single structure (a single value). like a tuple, but could also be a record, a list, or some other compound structure with multiple parts/places in which to place the "multiple arguments"
18:04:34 <ski> so, this in particular is made easier in Haskell, due to the presence of pattern-matching, so that you can say `\(a,b,c) -> a*x^2 + b*x + c'
18:05:06 <ostfale> mh yes, like in C or other imperative languages
18:05:22 <ski> now, "currying" would be the process of translating from the tupled style of representing multi-argument functions, to the curried style. and "uncurrying" is the opposite translation
18:05:52 * Solonarv waves a λ at ski: begone, heretic!
18:06:13 <Solonarv> (joking about the \(a,b,c) -> ... thing)
18:06:45 <ski> yes, except in C you can't do the equivalent of `\t -> fst3 t * x^2 + snd3 t * x + thd3 t', or `f t = fst3 t * x^2 + snd3 t * x + thd3 t', where you elect to not pattern-match on the "coneptual multiple arguments"
18:07:13 <ski> instead, you may choose to forward the tuple to another function (actually, you can do something a bit like that, with varargs, in C)
18:07:47 <ski> in C, you can't name the "argument list" itself (apart from varargs)
18:08:32 <ski> in Haskell, you can (if you use tupled style), except the "argument list" isn't actually there, in the language, it's only in your mind, in the conceptual model that you're encoding in Haskell, according to some encoding choice
18:09:17 <ostfale> Yes. I know. In C there are no literal tuples, etc; like so much else ...
18:09:58 <ski> now, what is "partial application". i would define partial application as the process in which you take a multiple-argument function, and presupply *some* (but not all, except perhaps as a trivial limiting case) arguments, so that you get back a (multiple-argument) function that still waits for the remaining arguments
18:11:17 * hackage pandoc-pyplot 2.1.0.0 - A Pandoc filter for including figures generated from Matplotlib  https://hackage.haskell.org/package/pandoc-pyplot-2.1.0.0 (LaurentRDC)
18:11:23 <ski> so, to partially apply `\(a,b,c) -> ..a..b..c..', call that function `f', we could write `\(a,c) -> f (a,b0,c)', in this case partially applying the `b' parameter to some "early" actual parameter `b0', letting the other formal parameters be "late inputs"
18:12:08 <ski> similarly, in the curried style, that's be `\a -> \c -> g a b0 c', if `g' is the corresponding curried style version of the multiple-argument function
18:13:13 <ostfale> I wonder if one could not unite this "tuple style" with currying: in that both are the same, so that even with tuples one value after the other is partially applied; If you only want to supply certain parameters, these are addressed by a name or other mechanisms.
18:13:16 <ski> now, if we have used the curried style, then it's particularly easy to partially apply to a prefix of the list of parameters. namely, instead of `\c -> g a0 b0 c', we can just say `g a0 b0'
18:15:05 <ski> (btw tupled style and curried style are useful in different situations. Haskell itself doesn't "have curried functions". otoh, it *does* have syntax that is designed to *encourage* using curried style. you can write `f x y = ..x..y..', you don't have to write `f x = \y -> ..x..y..' (as in Scheme (e.g.), modulo concrete syntax))
18:15:52 <ski> (but one could view the presence of pattern-matching on tuples (say) to be a partially similar encouragement of using tupled style, when appropriate)
18:17:21 <yichen> can someone help me with haskell?
18:17:23 <yichen> state monad?
18:17:29 <ski> if we're used a record variant of tupled style (or, alternatively named parameters, which is related. e.g. OCaml has named parameters (fitting in with what looks like curried style)), then one could imagine a shorthand syntax to partially apply such a function to particular named arguments, leaving the rest for later
18:18:40 <Solonarv> ski: now you made me sad that named parameters are so clunky to implement in Haskell
18:18:47 <ski> but for curried style, where we identify argument roles by position, unless we want to go for the full explicit partial application representation, with an explicit new lambda, we really can then only partially apply on a prefix on the "argument list" (modulo such things as sections, and `flip')
18:18:58 <ski> Solonarv : yea .. :/
18:19:16 <ski> we ought to have light-weight record types, that one doesn't need to declare, just like tuples !
18:19:23 <Solonarv> yes!
18:19:37 <ski> (at least we have light-weight, positional, variant types, now ..)
18:19:57 <Solonarv> there are several implementations of that as a library but they're syntactically more awkward than a language-supported version would be
18:20:11 <Solonarv> oh, apparently Hugs has some sort of actual record system
18:20:49 <Solonarv> ski: what variant types? are you referring to unboxed sums?
18:21:14 <ski> (btw, on light-weight record types, i think i'd really like it if the field names used there would not be "global", but rather so that you could rename them on export/import from modules. iow if a module uses field names you don't like, you should be able to rename those field names, when importing the module)
18:21:31 <ski> Solonarv : yes
18:21:41 <ski> yes, Hugs had TRex
18:21:55 <Solonarv> I'm not even the biggest fan of record accessors being plain old functions, actually
18:21:57 <ski> with "lacks" predicates on row variables
18:22:01 <Solonarv> *top-level functions
18:22:09 <ski> yea, that's another misdesign in Haskell
18:22:24 <ski> there is an unfortunate conflation between field names, and accessor functions for them
18:22:43 <ski> if you use record punning in a pattern, then suddenly your field accessor functions are shadowed
18:23:21 <Solonarv> also leads to prefixing field names with (a mangled form of) the type's name, which is cumbersome
18:23:35 <ski> i think the ML (say SML) way here is the right one. where if `x' is the field name, then the access function is `#x', so you write `#x p' (in OCaml, it'd be `p .x', which is also ok, i suppose)
18:23:43 <Solonarv> and sadly I don't think the current record-related efforts in GHC are going in the right direction
18:23:52 <ski> yea .. that's a separate issue
18:24:02 <ski> (hm, ok)
18:24:14 <ski> (prefixing being a separate issue)
18:24:18 <Solonarv> yeah
18:24:39 <ski> yichen : well, what is your question ?
18:24:57 <ski> ostfale : anyway, i've come a bit off-track in my explanation :)
18:25:23 * ski looks at scrollback, to recall the original question
18:25:41 <ski> hm, ok, so we were at partial application
18:25:44 <ostfale> no problem. I thank you! :)
18:26:05 <Solonarv> somehow we went from partially applying the second argument of a function, to grousing about GHC's (lack of a) record system ;)
18:26:06 <ski> one somewhat interesting thing that one could note here is the currying function (for pairs)
18:26:20 <ski>   curry :: ((a,b) -> c) -> (a -> b -> c)
18:26:42 <ski> so if `f' is in tupled style (with a *pair*), then `curry f' is the corresponding function in curried style
18:26:46 <ski> *however*
18:26:56 <ski> it also happens that we can read the signature of `curry' as
18:27:06 <ski>   curry :: ((a,b) -> c) -> a -> (b -> c)
18:27:31 <ski> where if we have `f' in tupled style, and an early parameter `a0', then `curry f a0' is the partial application of `f' to `a0'
18:27:48 <ski> so, in this form, `curry' is not a "currying operation", but a "partial application operation"
18:28:07 <ski> (and i suspect this may be one reason why people seem to confuse currying and partial application
18:28:10 <ski> )
18:29:47 <ski> (also, the latter shouldn't be confused with partial evaluation (which one could thing of as (very roughly) being about optimizing a program by "short-circuiting" early inputs, simplifying function bodies based on that. and obviously neither should be confused with partiality, meaning that a function may fail to produce a result for some inputs, typically because of pattern-matching failure, or calling `error' or `undefined', or the like)
18:30:18 <ski> anyway, this form of `curry' could have been called `partiallyApply', as
18:30:25 <ski>   partiallyApply :: ((a,b) -> c) -> a -> (b -> c)
18:30:34 <MarcelineVQ> ski: you can call it program specialization if partial it too overloaded
18:31:09 <ski> however, note that this `partiallyApply' is itself a multi-argument function (taking `f' and `a0' in the example above, and then returning a new function), written in *curried* style
18:31:18 <ski> one could also have a tupled style version of it
18:31:28 <ski>   tupledPartiallyApply :: ((a,b) -> c,a) -> (b -> c)
18:31:47 <ski> (and actually, this could be said to be both tupled, and curried, since it returns a function as result)
18:33:15 <yichen> ski: my question
18:33:19 <yichen> is 
18:33:32 <ski> in a language where the predominant cultural way of expressing multiple-argument functions are via tupling (this is, or at least was, mostly true for SML (but not OCaml)), or where the language itself actually has a notion of multiple-argument (like in Scheme, or Javascript^WECMAScript, Erlang, &c.), that *would* probably be the way to normally express such a partial application operation (perhaps a vararg operation ?)
18:34:09 <ski> MarcelineVQ : yea .. actually, i'm not quite sure whether those two terms have nonzero difference in either direction, or not
18:34:50 <MarcelineVQ> ski: like many things I would bet it depends who you ask
18:34:56 <ski> ostfale : now, back to your original question. consider `f x y z = ..x..y..z..', and say you want to write `f _ y0 _'
18:35:10 <ski> ostfale : what should `f _ y0 _' really mean ?
18:35:17 <MarcelineVQ> *bet/guess
18:35:43 <ostfale> or like in ocaml with labels XD (https://caml.inria.fr/pub/docs/u3-ocaml/ocaml051.html)
18:36:34 <ski> ostfale : presumably, you had `\x z -> f x y0 z' in mind. but recall that Haskell functions really only take a single argument, so that `f _ y0 _' syntactically would be the same as `((f _) y0) _'. now, suddenly, it would also seem that an alternate interpretation would be `\z -> ((\x -> f x) y0) z', which means something different
18:36:48 <ski> ostfale : do you see the problem, now ?
18:38:01 <ski> i recall that at least one time this idea came up, it was suggested that the "reach" of the "don't fill in this parameter, let it be a late one" should be indicated by where you write explicit brackets (or other delimiter)
18:39:00 <ski> but i certainly wouldn't want to give up being able to insert and remove the brackets inbetween `f x y z' and `((f x) y) z', without having to consider whether any one of the expressions `x',`y',`z' are this special `_' marker or not
18:39:43 <ski> one might argue that one ought to insert the extra lambdas "as far out as possible", but that's also not a good answer
18:41:14 <ski> should `zipWith (f _ y0 _) _ zs0' mean `\xs -> zipWith (\x z -> f x y0 z) xs zs0', or `\x z ys -> zipWith (f x y0 z) ys zs0' (or perhaps some other variant ?) ?
18:41:50 <ski> i don't see why `_' being a "complete, single argument" should be treated differently from it being nested inside an argument
18:42:36 <ostfale> yes, that is problematic.
18:42:42 <slack1256> This infodump clicks all my FP geek buttons, well done.
18:42:43 <ski> so .. we need an explicit delimiter, to tell exactly the reach of these `_'s, "how far out" the "wait for late arguments" thing should be inserted
18:43:24 <ski> however, that explicit delimiter turns out to be more or less just the `\' -- congratulations, you've reinvented lambda abstraction ! :)
18:45:13 <ostfale> XD 
18:45:29 <ski> (it might not be quite that, since you could refrain from giving the individual `_'s names, instead relying on abstracting them in the same order they appear (in a depth-first order traversal, say) .. but if you want to be able to bind to a not-necesarily-closest delimiter (which i definitely would want then, due to modularity/composability reasons), then you at least need to (potentially) tag them with a description of which outer delimiter to bind to)
18:45:46 <ski> (er, cut off near ".., then you at least need to (potentially) tag them with a description of which outer delimiter to bind to)")
18:45:46 <MarcelineVQ> ohh here it comes
18:46:02 <ostfale> as I said. I think. the easiest would be labels like in ocaml. do not complicate everything that way :D
18:47:45 <ski> ostfale : yeah, OCaml labels was the named argument thing i had in mind, earlier
18:47:51 <ski> (i didn't recall what they called it)
18:48:15 <ski> ostfale : anyway .. i think that more or less sums it up
18:48:30 <ski> i hope that was useful, or at least somewhat entertaining
18:48:45 <ski> yichen : yes ?
18:49:07 <yichen> this is my first time using irc here
18:49:12 <ski> yichen : sorry for not responding to you that much, i was in the middle of an explanation brain-dump
18:49:19 <yichen> its ok
18:49:27 <ski> (i'm done now, though .. i think :)
18:50:07 <yichen> ok
18:50:09 <yichen> im having trouble with
18:50:13 <yichen> understanding this state monad
18:50:14 <yichen> http://www.cs.toronto.edu/~trebla/CSCC24-2019-Winter/lab09/
18:50:15 <ostfale> that's the same way guys are just renamed types to make them sound like "size" instead of "int". In rust, I saw a library where someone renamed 50 types so that they sound more "pictorial". I do not think that is meaningful. I think labels are better. In haskell I can not really make friends with the fact that each time the data constructor has to be written down. I am probably to C-contaminated.
18:50:33 <yichen> http://www.cs.toronto.edu/~trebla/CSCC24-2019-Winter/lab09/
18:50:55 <ski> yichen : which of the files ?
18:51:01 <yichen> o
18:51:02 <yichen> its in
18:51:09 <yichen> def
18:51:16 <yichen> Lab09Def.hs
18:51:30 <ski> ok
18:51:37 <yichen> im havin trouble understanding
18:51:40 <yichen> the >>=
18:51:46 <yichen> and the do notation
18:51:58 <yichen> im unable to succcessfuly trace the monad
18:52:08 <ski> do you know the type of `(>>=)' ?
18:52:22 <yichen> wat u mean?
18:52:34 <yichen> u mean a tuple?
18:53:18 <ski> no. `>>=' is an infix operator. if you wrap an infix operator (like e.g `+'), in brackets, you get an ordinary function, that you can pass two arguments, afterwards
18:53:34 <ski> just like you can say `f 2 3', you can say `(+) 2 3', which means the same as `2 + 3'
18:54:13 <yichen> ok i know that
18:54:30 <yichen> but i dont get why thats important
18:54:41 <ski> in your case, if you write `act >>= continue', then that's the same as `(>>=) act continue', where `act' would be some monadic action, e.g. of type `State Int Bool', and `continue' would be a function that returns a monadic action, e.g. of type `Bool -> State Int String'
18:55:34 <yichen> ok
18:56:13 <yichen> but that doesnt really help explain this
18:56:20 <yichen> albertProg1 :: State Int (Int, Int) albertProg1 =     postInc >>= (         \i -> postInc >>= (                 \j -> return (i, j)             )         )
18:56:27 <ski> and then if you pass both of those to `(>>=)', it "pastes them together" into a single monadic action, that, when executed, will execute the first action `act', getting a result of type `Bool' (in this case), which is passed to the second one (the function `continue'), getting back an action of type `State Int String', which is then executed in turn, and the result value of type `String' of that action is then the overall result of executing `act >>= contin
18:56:39 <ski> ok
18:56:43 <yichen> albertProg1 :: State Int (Int, Int) albertProg1 =     postInc >>= (\i -> postInc >>= (\j -> return (i, j)))
18:57:09 <ski> well, `postInc' has type `State Int Int', with an `Int' at the end
18:57:18 <ski> so the "monadic result type" of that action is `Int'
18:57:55 <ski> that means that the result of executing the first `postInc' action will be passed into the function on the right of the first `>>=', iow `i' will get the value of that result
18:58:13 <ski> do you understand that, at least on a high-level conceptual level ?
18:59:26 <ski> (i'm assuming you have seen the lambda-notation before, for functions, where e.g. `\x -> x^2' is "the function that, given an input, call it `x', computes `x^2' as result", or "the squaring function" for short)
19:00:44 * ski looks at yichen
19:00:58 <yichen> yesyes
19:01:13 <yichen> how do i filter ur messsages on here
19:01:20 <yichen> i've never used irc before
19:01:50 <ski> filter, how ?
19:01:57 <yichen> just see u
19:01:57 <yichen> ski
19:02:15 <ski> well, nobody else than me and you are talking in the channel, for the moment
19:02:32 <ski> (there's some joins and parts, but you can ignore those, no ?)
19:03:04 <yichen> is there a command?
19:03:15 <ski> i *could* talk to you in private messages .. but then (a) other people couldn't chime in with help and more viewpoints; (b) other people couldn't lurk and learn
19:03:26 <ski> .. so i tend to prefer not doing that
19:04:08 <ski> well, i think it is probably possible in several IRC clients (at least standalone ones), to ignore / filter out messages that one doesn't want to see
19:04:43 <yichen> ok
19:04:44 <yichen> anyway
19:04:53 <yichen> im having toruble understanding this
19:04:54 * ski has never tried it, though, haven't yet found a need (in .. perhaps around eighteen(?) years on IRC)
19:06:24 <ski> you're currently using the web browser client .. if you want to use IRC more, you might want to consider checking out a standalone client. they tend to be nicer, for more than just casual, occasional, use
19:06:52 <ski> yichen : trouble understanding how to use and read `>>=', or how it's implemented (in this case), or both ?
19:07:01 <yichen> gawd dam idk
19:07:09 <yichen> anymore
19:07:09 <ski> that's ok
19:07:16 <yichen> i just wanna pass my course
19:07:19 <ski> we're here to try to help
19:07:19 <yichen> and never see this again!
19:07:38 <ski> (but obviously we expect you to show some effort, as well :)
19:07:46 <yichen> StateOf t >>= k = StateOf (\i0 -> case t i0 of (i1, a) -> deState (k a) i1)
19:07:49 <yichen> i wanna trace
19:07:51 <yichen> through the program
19:07:52 <ski> ok
19:07:53 <yichen> but idk how
19:08:06 <yichen> i feel like theres too many little things idk
19:08:21 <slack1256> Maybe you should start with a simpler Monad
19:08:27 <slack1256> like Maybe
19:08:39 <yichen> i understand that
19:08:41 <slack1256> and see how their (>>=) is implemented
19:08:46 <yichen> but i dont understandanything more complex
19:09:11 <ski>   StateOf t >>= k = StateOf (\i0 -> case t i0 of (i1, a) -> deState (k a) i1)
19:09:20 <ski> that's the implementation of `(>>=)', in this case
19:09:32 <ski> so consider your
19:09:35 <yichen> is the \i0 t in this case?
19:09:47 <ski>   postInc >>= (\i -> postInc >>= (\j -> return (i, j)))
19:09:52 <ski> `t' ?
19:10:00 <ski> no
19:10:02 <yichen> (\t -> case t i0 of (i1, a) -> deState (k a) i1)
19:10:21 <ski> `i0' is the initial version of the state (as far as this call to `(>>=)' is concerned)
19:11:01 <ski> `i1' is the intermediate version, and `deState (k a) i1' will compute a final version, which in this case hasn't been named (it could have been named `i2')
19:11:30 <ski> so, to be able to simplify
19:11:33 <ski>   postInc >>= (\i -> postInc >>= (\j -> return (i, j)))
19:12:02 <ski> we must first bring the first `postInc' into the `StateOf t' form that the (first) call to `(>>=)' expects
19:12:10 <ski> so, we also have a definition
19:12:18 <ski>   postInc = StateOf (\i -> (i+1, i))
19:12:24 <ski> therefore, we can argue :
19:12:30 <ski>       postInc >>= (\i -> postInc >>= (\j -> return (i, j)))
19:12:38 <ski>   =   StateOf (\i -> (i+1, i)) >>= (\i -> postInc >>= (\j -> return (i, j)))
19:13:09 <ski>   =   StateOf (\i0 -> case (\i -> (i+1, i)) i0 of (i1, a) -> deState ((\i -> postInc >>= (\j -> return (i, j))) a) i1)
19:13:26 <ski> in the first step, i replaced `postInc' with `StateOf (\i -> (i+1, i))'
19:14:11 <ski> in the next step, which is a call to the first `(>>=)', i matched the whole thing to the left of the `=' in the definition of `(>>=)', namely
19:14:17 <ski>   StateOf t >>= k
19:14:24 <ski> with the actual call, here being the whole
19:14:29 <ski>   StateOf (\i -> (i+1, i)) >>= (\i -> postInc >>= (\j -> return (i, j)))
19:14:45 <ski> thing, and the result of that matching is the solution/substitution/bindings :
19:14:52 <ski>   t = \i -> (i+1, i)
19:15:01 <ski>   k = \i -> postInc >>= (\j -> return (i, j))
19:15:32 <ski> next, we replace this call `... >>= ...' with the body (iow what's to the right of `=', in the definition of `(>>=)', iow
19:15:38 <ski>   StateOf (\i0 -> case t i0 of (i1, a) -> deState (k a) i1)
19:16:22 <ski> ), except replacing `t' and `k' (the formal parameters) with the argument expressions (the actual parameters) `\i -> (i+1, i)' and `\i -> postInc >>= (\j -> return (i, j))', that they were bound to
19:16:30 <ski> doing so results in going from
19:16:34 <ski>   =   StateOf (\i -> (i+1, i)) >>= (\i -> postInc >>= (\j -> return (i, j)))
19:16:35 <ski> to
19:16:42 <ski>   =   StateOf (\i0 -> case (\i -> (i+1, i)) i0 of (i1, a) -> deState ((\i -> postInc >>= (\j -> return (i, j))) a) i1)
19:17:23 <ski> yichen : you should make sure you understand this "replace a function call (in this case infix operator call) with the body of the function, with formals replaced by actuals"
19:17:33 <yichen> right
19:17:34 <yichen> 1s
19:17:38 <yichen> ur actually making sense
19:17:42 <yichen> let me digest it
19:18:07 <ski> next, we're going to simplify this. if `\x -> x^2' is the squaring function, then `(\x -> x^2) 3' is calling the squaring function with input `3', which is of course `3^2', iow `9'
19:19:24 <ski> this step is called "beta-reduction" : simplifying a call to a lambda expression with some argument expression, by replacing that call with the body of the lambda expression, but with (all occurances of) the formal parameter of the lambda expression (in the body) replaced by the actual parameter, the argument
19:19:43 <ski> so, in this case, `(\i -> (i+1, i)) i0' is simplified to `(i0+1,i0)'
19:20:10 <ski> and also, `(\i -> postInc >>= (\j -> return (i, j))) a) i1' is simplified to `postInc >>= (\j -> return (i0, j))) a'
19:20:23 <ski> therefore, we can continue as
19:20:29 <ski>   =   StateOf (\i0 -> case (\i -> (i+1, i)) i0 of (i1, a) -> deState ((\i -> postInc >>= (\j -> return (i, j))) a) i1)
19:20:41 <yichen> ski is there a diff way to communicate?
19:20:43 <yichen> on slack or something
19:20:44 <yichen> ?
19:20:47 <yichen> i cnat take this irc
19:20:50 <ski>   =   StateOf (\i0 -> case (i0+1,i0) of (i1, a) -> deState (postInc >>= (\j -> return (i0,j))) a)
19:21:00 <ski> yichen : i dunno, i don't use Slack
19:21:27 <yichen> u got fb?
19:21:42 <ski> (one reason being that it's proprietary)
19:21:49 <ski> nah, i don't use that either :)
19:21:57 <yichen> discord?
19:22:13 <ski> i've tried it a little, but didn't really like it. i'm sorry
19:22:35 <ski> there's some kind of Matrix interface to IRC, that people coming on here sometimes use
19:22:36 <yichen> god dam i cant read it correctly here
19:22:41 <ski> perhaps you'd like that better ?
19:22:52 <yichen> wats matrix interface
19:23:09 <MarcelineVQ> the webchat is pretty awful
19:23:22 <ski> <https://en.wikipedia.org/wiki/Matrix_(communication_protocol)>
19:23:41 <ski> yes, that's one reason i suggested perhaps looking into a standalone IRC client, rather than using the webchat
19:23:54 <yichen> which one r u using
19:24:15 <ski> one of the strengths of IRC is that different people have different needs and tastes, and IRC allows them to use different clients, suiting those needs and tastes
19:24:28 <ski> with Slack, you're not allowed to use anything else than the official client, iirc
19:24:32 <yichen> ok... but u didnt answer my question
19:24:38 <yichen> which irc client do u use
19:24:38 <ski> i'm using Irssi, a text-only client
19:25:07 <yichen> jesus
19:25:09 <yichen> i just need a way
19:25:14 <yichen> to filter only your username
19:25:28 <ski> but if you're starting, you probably would want to use a GUI one, like mIRC (Windows), HexChat (Windows,*nix), Colloquy (Mac). Adium (i think this one is for smartphones, perhaps not all ?)
19:26:02 * ski isn't quite sure why filtering would be that necessary here, since mostly other people are quiet atm
19:26:14 <ski> (unless you're really bothered by the joins and quits, that is ..)
19:26:22 <MarcelineVQ> there's not even many join/parts happening right now, is the text too small for you yichen?
19:26:35 <yichen> which one is the best on linux
19:26:38 <yichen> that has a nice gui
19:26:46 <ski> are you on a mobile phone, or other device with a small screen ?
19:26:58 <ski> well, you can try HexChat, which i suggested
19:27:08 <ski> there's also others
19:27:13 <ski> (Smuxi, iirc ?)
19:27:21 * ski can't keep up with all of them
19:27:36 <MarcelineVQ> one can actually hide joints/parts on the webchat, click the triple bar icon on the top level and select options, "Hide JOINS/PARTS/QUITS:"
19:27:50 <MarcelineVQ> *on the top left
19:29:22 <MarcelineVQ> and can increase the text size in the usual way for browsers, ctrl+scroll or ctrl++
19:29:55 <ski> yichen : anyway, i was already planning to sum up the "reduction/evaluation trace" i was starting, at the end, without the intervening text
19:30:04 <yichen_> ok
19:30:04 <yichen_> cool
19:30:06 <MarcelineVQ> if it broke lines that were too long and had a dark theme option instead of silenty truncating them it'd be a real client
19:30:10 <yichen_> seems like this is a better client
19:30:19 <ski> yichen : should i continue ?
19:30:23 <yichen_> one sec
19:30:30 <yichen_> let me try to confiure something
19:30:40 <ski> (should i repeat what i said previously, to you, in private ?)
19:30:52 <yichen_> how do u tell me in private?
19:31:25 <ski> /msg yichen by writing an IRC command like this, starting with `/'
19:31:44 <ski> /query yichen
19:32:05 <ski> would also work to open a separate "private tab/window" for talking in private with you
19:32:51 <ski> (but as i said, i prefer helping in public. i'm just offering to repeat what i said, before you joined the channel with the other client. and i'd do *that* in private, to avoid spamming the channel with the messages)
19:34:43 <yichen_> filter ski
19:34:45 <yichen_> dam
19:34:47 <yichen_> how do u do this
19:34:57 <yichen_> FADD ski
19:35:03 <ski> it was years since i last used HexChat ..
19:35:28 <yichen_> ok
19:35:30 <yichen_> so how do i pm u?
19:35:46 <ski> (.. and i didn't use ignore or filtering then. haven't since, either. i just would be surprised if HexChat doesn't have some way to filter or ignore)
19:36:03 <ski> just type in the other (private) tab, like you already did
19:38:02 <ski> ok, so let's split the last step i made into two parts : (a) replacing the call to `(>>=)' with the body; (b) replacing the formal parameters with the actual parameters
19:38:27 <ski> let me repeat the reduction trace from the beginning, so you get the full context
19:38:27 <yichen> wait hang on
19:38:30 <yichen> wats the different
19:38:33 <yichen> diferene
19:38:36 <yichen> of private chat
19:38:40 <yichen> ur just chating in public then
19:38:41 <ski>       postInc >>= (\i -> postInc >>= (\j -> return (i, j)))
19:39:01 <ski>   =   StateOf (\i -> (i+1, i)) >>= (\i -> postInc >>= (\j -> return (i, j)))
19:39:09 <ski>   =   StateOf (\i0 -> case t i0 of (i1, a) -> deState (k a) i1)
19:39:14 <ski>         where
19:39:21 <ski>         t = \i -> (i+1, i)
19:39:29 <ski>         k = \i -> postInc >>= (\j -> return (i, j))
19:39:37 <ski>   =   StateOf (\i0 -> case (\i -> (i+1, i)) i0 of (i1, a) -> deState ((\i -> postInc >>= (\j -> return (i, j))) a) i1)
19:40:02 <ski> yes, i'm chatting in public (as i already said)
19:40:37 <[rg]> hi, is there a fp chat somewhere on irc?
19:41:47 <yichen_> yes ski
19:41:49 <yichen_> go on
19:41:49 <ski> in the second step above, i just replaced the `... >>= ...' call with the body of the definition of `(>>=)'
19:42:34 <ski> [rg] : i'm not aware of a specific general such channel. try one of the particular programming languages channels (like this one), or maybe ##typetheory ?
19:42:56 <yichen_> go on ski
19:43:26 <ski> but that body refers to the formal parameters `t' and `k', which are bound to the actual parameters `\i -> (i+1, i)' and `\i -> postInc >>= (\j -> return (i, j))', as indicated by the `where' clause just below
19:43:58 <ski> then, after replacing those formals with the corresponding actuals, we arrive at the last (so far) position in that reduction trace
19:44:13 <[rg]> ski: ok, i will be studying clean from this point on so was not sure if discussion for non haskell stuff was ok
19:44:59 <ski> now, as i said, we there have two subexpressions, which are calls to lambda-expressions, and those can be simplified (that's called "beta-reduction", to use the technical term), as :
19:45:11 <ski>      (\i -> (i+1, i)) i0
19:45:19 <ski>   =  (i0+1,i0)
19:45:21 <ski> respectively
19:45:28 <ski>      (\i -> postInc >>= (\j -> return (i, j))) a) i1
19:45:35 <ski>   =  postInc >>= (\j -> return (i0,j))) a
19:46:01 <ski> so, plugging those two "substeps" into the last point in the overall reduction trace, we can continue that as
19:46:09 <ski>   =   StateOf (\i0 -> case (\i -> (i+1, i)) i0 of (i1, a) -> deState ((\i -> postInc >>= (\j -> return (i, j))) a) i1)
19:46:27 <ski>   =   StateOf (\i0 -> case (i0+1,i0) of (i1, a) -> deState (postInc >>= (\j -> return (i0,j))) a)
19:46:39 <ski> yichen_ : does that make sense, now ?
19:46:45 <yichen_> well yes
19:46:48 <yichen_> but u didnt simply no?:
19:46:50 <yichen_> u still got 
19:46:57 <ski> i'm still not done, no
19:46:59 <yichen_> 1 more postInc left
19:47:00 <yichen_>  postInc
19:47:02 <ski> should i continue ?
19:47:07 <yichen_> yes plz XD
19:47:34 <ski> ok. so next, we can simplify the `case' part
19:48:09 <ski> we are scrutinizing the expression `(i0+1,i0)', matching it with the pattern `(i1, a)', and obviously that yields the bindings
19:48:18 <ski>   i1 = i0+1
19:48:23 <ski>   a  = i0
19:48:36 <ski> so, we can continue from where we left off by
19:49:41 <ski>   =   StateOf (\i0 -> case (i0+1,i0) of (i1, a) -> deState (postInc >>= (\j -> return (i1,j))) a)
19:49:53 <ski>   =   StateOf (\i0 -> deState (postInc >>= (\j -> return (i0+1,j))) i0)
19:50:36 <ski> (sorry, i just realized that in the previous two beta-reduction steps, i mistakenly used `i0' rather than `i1' at the end. i fixed that here, though)
19:51:00 <ski> now, to be able to continue, we need to remove the `deState' call
19:51:15 <ski> but `deState' is defined as
19:51:16 <ski>   deState (StateOf stf) = stf
19:51:38 <ski> so it wants to match its actual parameter with the formal parameter (the pattern) `StateOf stf'
19:51:59 <ski> so in order to be able to do that matching, we must first simplify the inner (the originally second) call to `(>>=)'
19:52:53 <ski> and in order to be able to do *that*, we must then simplify the remaining `postInc', because `(>>=)' wants to match *its* argument with `StateOf t'
19:53:28 <ski> so, the plan is : first replace `postInc' by what it's defined to be, then simplify/call the remaining `(>>=)', *then* the `deState' (and then we'll see)
19:53:36 <ski> ok, so i continue from above
19:53:43 <ski>   =   StateOf (\i0 -> deState (postInc >>= (\j -> return (i0+1,j))) i0)
19:53:56 <ski>   =   StateOf (\i0 -> deState (StateOf (\i -> (i+1, i)) >>= (\j -> return (i0+1,j))) i0)
19:54:44 <ski>   =   StateOf (\i0 -> deState (StateOf (\i0 -> case t i0 of (i1, a) -> deState (k a) i1)) i0)
19:54:49 <ski>        where
19:55:04 <ski>        t = \i -> (i+1,i)
19:55:15 <ski>        k = \j -> return (i0+1,j)
19:55:35 <ski>   =   StateOf (\i0 -> deState (StateOf (\i0 -> case (t = \i -> (i+1,i)) i0 of (i1, a) -> deState ((\j -> return (i0+1,j)) a) i1)) i0)
19:55:53 <ski>        {
19:56:25 <ski>           (\i -> (i+1,i)) i0
19:56:33 <ski>        =  (i0+1,i0)
19:56:46 <ski>           (\j -> return (i0+1,j)) a
19:56:56 <ski>        =  (i0+1,a)
19:56:59 <ski>        }
19:57:25 <ski>   =   StateOf (\i0 -> deState (StateOf (\i0 -> case (i0+1,i0) of (i1, a) -> deState (i0+1,a) i1)) i0)
19:58:15 <ski> er, sorry, that last step is incorrect. i forgot about the `return' part
19:58:16 <ski> it should be
19:58:42 <ski>   =   StateOf (\i0 -> deState (StateOf (\i0 -> case (i0+1,i0) of (i1, a) -> deState (return (i0+1,a)) i1)) i0)
19:59:00 <ski>   =   StateOf (\i0 -> deState (StateOf (\i0 -> deState (return (i0+1,i0)) (i0+1))) i0)
19:59:07 <ski> at this point, we need the definition of `return'
19:59:20 <ski>   return a = pure a
19:59:27 <ski>   pure a = StateOf (\i -> (i, a))
19:59:30 <ski> so, continuing
19:59:33 <ski>   =   StateOf (\i0 -> deState (StateOf (\i0 -> deState (return (i0+1,i0)) (i0+1))) i0)
19:59:38 <ski>   =   StateOf (\i0 -> deState (StateOf (\i0 -> deState (pure (i0+1,i0)) (i0+1))) i0)
20:00:06 <ski>   =   StateOf (\i0 -> deState (StateOf (\i0 -> deState (StateOf (\i -> (i,(i0+1,i0)))) (i0+1))) i0)
20:00:39 <ski> oh, and i forgot that we can also perform the outer `deState' call, some steps earlier already. i'll do that now, to reduce some of the noise
20:00:42 <ski>   =   StateOf (\i0 -> deState (StateOf (\i0 -> deState (StateOf (\i -> (i,(i0+1,i0)))) (i0+1))) i0)
20:01:02 <ski>   =   StateOf (\i0 -> (\i0 -> deState (StateOf (\i -> (i,(i0+1,i0)))) (i0+1)) i0)
20:01:14 <ski>   =   StateOf (\i0 -> deState (StateOf (\i -> (i,(i0+1,i0)))) (i0+1))
20:01:20 <ski> and the other `deState'
20:01:22 <ski>   =   StateOf (\i0 -> deState (StateOf (\i -> (i,(i0+1,i0)))) (i0+1))
20:01:31 <ski>   =   StateOf (\i0 -> (\i -> (i,(i0+1,i0))) (i0+1))
20:01:51 <ski>   =   StateOf (\i0 -> ((i0+1),(i0+1,i0)))
20:02:20 <ski> and now i think we've come as far as we can, here
20:02:26 * ski ponders the end result
20:08:55 <ski> hmm, i think i made a mistake somewhere
20:09:47 <ski> (it's easier to do this, if you have it all in one place, as you can imagine. but then i also wanted to talk about what i was doing, which sortof was at cross-purposes with that)
20:10:51 <ski> if we go back to when we had called the first `(>>=)', then i think the step just after we had arrived at
20:10:55 <ski>   =   StateOf (\i0 -> case (\i -> (i+1, i)) i0 of (i1, a) -> deState ((\i -> postInc >>= (\j -> return (i, j))) a) i1)
20:11:00 <ski> was mistaken
20:11:44 <ski> i accidently replaced `i' here with `i1', while i ought to have replaced it with `a'
20:11:57 <ski> so, the next position should have been
20:12:28 <ski>   =   StateOf (\i0 -> case (i0+1,i0) of (i1, a) -> deState (postInc >>= (\j -> return (a,j)) i1)
20:12:52 <ski> (with `return (a,j)' instead of `return (i,j)', and with `i1' at the end, not `a')
20:13:32 <ski> then, in further steps, `a' (now in a different place) would be replaced with `i0' (as before), and `i1' with `i0+1'
20:17:58 <ski> hm, and i think i also see that, in order to do this correctly, it might be preferrable to rename local variables in the body of a function, when we make the function call, in order to avoid being confused by different variables apparently being named the same
20:18:35 <ski> anyway, the end result, if we carry out the corrections (sorry for messing it up a bit) is that we finally arrive at
20:19:04 <ski>   =   StateOf (\i0 -> (((i0+1)+1),(i0,i0+1)))
20:19:40 <ski> so you can see that the state is increased by two, and that the "return value" is `(i0,i0+1)', so the two previous states
20:20:05 <ski> yichen_ : i hope this wasn't completely confounding ..
20:20:36 <ski> i recommend doing the substitutions yourself, by hand, on paper or in a text editor
20:21:08 <ski> (you could use indentation to lay out the expressions on multiple lines, to avoid being as confused with the bracket nestings, if you like)
20:21:38 <ski> hopefully at least the basic ideas of how to do this kind of reduction trace should be clear by now
20:22:17 <ski> (i'm also a bit tired atm, which i suppose could explain me messing it up a bit ..)
21:09:14 <remexre> is there some way to make DefaultSignatures show up a bit better in the haddock-generated docs?
21:11:05 <remexre> nvm, sounds like this is haddock #567
21:22:37 <siraben> Anyone doing Google Code Jam this year?
23:03:41 <remexre> is there a way to do a typelevel lambda? e.g. (\a -> (Either Foo (c a))) :: * -> *
23:04:01 <Cale> no
23:04:16 <Cale> However, you could write that as  Compose (Either Foo) c
23:04:27 <Cale> But you have to deal with the explicit Compose newtype
23:04:43 <remexre> hm, okay
23:05:08 <remexre> I think I'll do that, but what's the reason for this?
23:05:30 <remexre> I'd guess that it makes typechecking undecidable, but typeclasses already do that, right?
23:08:59 <Cale> Well, it's a reasonable thing to investigate how one would retain the same level of type inference, but I'm not sure anyone's figured that out.
23:09:56 <jle`> remexre: it makes typeclass resolution a little funky
23:10:06 <Cale> Yeah, it certainly does.
23:10:26 <Cale> Are you going to allow lambdas in instance heads?
23:10:56 <remexre> hm, right
23:11:08 <jle`> for example, fmap with (,Int) Bool
23:11:20 <jle`> with (,Int) as a potential * -> * Functor instance
23:11:41 <jle`> if you saw fmap with (Bool, Int), are you going to look for the (Bool,) instance, or the (,Int) instance?
23:11:50 <Cale> Yeah, you'd certainly not want to allow instances like that
23:12:07 <Cale> But it's tricky to say what ought to be allowed then, if anything
