00:16:44 * hackage GLFW-b 3.3.0.0 - Bindings to GLFW OpenGL library  https://hackage.haskell.org/package/GLFW-b-3.3.0.0 (Mokosha)
01:06:53 <jgt> anyone know what might be causing this? http://ix.io/1ZgZ
01:08:00 <jgt> I'm looking at the source for the Faker library, and I don't see where this undefined comes from
01:08:01 <jgt> https://github.com/gazay/faker/blob/master/src/Faker/Lorem.hs
01:14:10 <jgt> ok, I'm just going to switch to psibi's fake data library instead. Seems higher quality and actively maintained.
01:23:12 <koz_> Seriously, why does Haskell have so many awesome papers?
01:23:22 <koz_> Is it like, SPJ leading the charge on readability?
01:32:51 <Rembane> koz_: Are they way too well written?
01:33:01 <koz_> Rembane: No such thing. :P
01:34:19 <koz_> In the shortcut fusion paper, they define a base functor 'data Tree_ a b = Empty_ | Leaf_ a | Fork_ b b'. What's the kind of b?
01:34:31 <koz_> Is it just Type, or am I batty?
01:43:36 <koz_> So it is. OK, I need more sleep lol.
04:12:44 * hackage wai-middleware-static 0.8.3 - WAI middleware that serves requests to static files.  https://hackage.haskell.org/package/wai-middleware-static-0.8.3 (ryanglscott)
05:38:07 <dignissimus> How should I shuffle a list?
05:44:31 <jneira> dignissimus: maybe a link is not enough but https://wiki.haskell.org/Random_shuffle
05:44:44 * hackage tldr 0.6.0 - Haskell tldr client  https://hackage.haskell.org/package/tldr-0.6.0 (psibi)
05:46:18 <dignissimus> jneira: Should I implement my own or just use the package?
05:46:42 <dignissimus> Well one of the packages
05:49:28 <jneira> well, it depends :-D  
05:51:06 <jneira> how many code saves you, how big is it the lib, how many transitive dependencies brings? 
05:51:55 <jneira> maybe you already have part of its transitive deps...
06:04:58 <dmwit> dignissimus: I have a different answer from jneira: you should use the one of the packages.
06:05:56 <dmwit> All those other considerations pale in comparison to "they already found and fixed through the five easiest-to-write bugs".
06:49:44 * hackage strict-tuple 0.1.3 - Strict tuples  https://hackage.haskell.org/package/strict-tuple-0.1.3 (mitchellwrosen)
06:58:44 * hackage lightstep-haskell 0.1.1 - LightStep OpenTracing client library  https://hackage.haskell.org/package/lightstep-haskell-0.1.1 (DmitryIvanov)
07:25:40 <dignissimus> Could somebody help me understand these compiler error messages? https://paste.rs/tBO https://paste.rs/B1I.hs
07:25:51 <dignissimus> I don't understand why players can't be [Player]
07:27:14 * hackage dhall 1.27.0 - A configuration language guaranteed to terminate  https://hackage.haskell.org/package/dhall-1.27.0 (GabrielGonzalez)
07:28:15 * hackage dhall-lsp-server 1.0.2, dhall-nix 1.1.9, dhall-bash 1.0.24, dhall-json 1.5.0 (GabrielGonzalez)
07:29:09 <pavonia> dignissimus: Why do you think it would be a list? You let it to an action of the type of getInputLine
07:29:40 <sternmull> dignissimus: you are missing "return"
07:29:47 <pavonia> or that monad at least
07:33:16 <dignissimus> Adding a return fixes it but I don't understand
07:33:21 <dignissimus> :t (do [1, 2, 3])
07:33:22 <lambdabot> Num a => [a]
07:40:26 <mniip> did you know!
07:40:36 <mniip> that all promoted data constructors have representational type roles
07:42:12 <dignissimus> I don't think I understand what that means either
07:43:02 <mniip> `Coercible (F a) (F b)` entails `Coercible a b`
07:45:20 <lavalike> what's a promoted data constructor
07:46:21 <mniip> with DataKinds type constructors can be promoted to kind constructors and their respective data constructors are promoted to type constructors
07:46:57 <nshepperd2> % :k Coercible
07:46:58 <yahb> nshepperd2: Coercible :: k0 -> k0 -> Constraint
07:47:33 <geekosaur> dignissimus, lists are monads so `do [1,2,3]` happens to work. this does not necessarily generalize
07:47:47 <nshepperd2> Huh
07:48:01 <nshepperd2> What does that mean, when the kind is not *?
07:48:14 <geekosaur> `return` doesn't mean what you probably think it does, either. these days there's a growing preference for `pure` as an alternative name
07:49:00 <geekosaur> although I'm un-fond of it because what's impure about list elements?
07:49:21 <geekosaur> % :t pure @[_]
07:49:21 <yahb> geekosaur: ; <interactive>:1:7: error:; * Expected kind `* -> *', but `[_]' has kind `*'; * In the type `[_]'; In the expression: pure @[_]
07:49:26 <geekosaur> bah
07:49:29 <geekosaur> % :t pure @[]
07:49:29 <yahb> geekosaur: a -> [a]
07:50:17 <geekosaur> which is to say, in the context of list as a monad, it turns a value into a single-element list containing that value
07:50:48 <geekosaur> that said, `return` is an even worse name for it, so
07:57:01 <jgt> have people come up with suggestions for better names?
07:58:14 <geekosaur> this has been tossed around for years and `pure` seems to have won; I'm part of a small minority
07:58:28 <jgt> pure for both typeclasses?
07:58:33 <nshepperd1> unit would be a sensible name, but may already be taken
07:58:37 <mniip> geekosaur, actually `do x` is always syntactic sugar for `x` with no constraints added
07:58:47 <geekosaur> true
07:59:00 <jgt> nshepperd1: isn't that what we call the empty tuple?
07:59:27 <mniip> just call it mempty and mappend :P
07:59:56 <jgt> f `burritoify` g
07:59:58 <nshepperd1> I call the empty tuple ()
08:00:18 <mniip> sir that's a function call operator
08:00:39 <nshepperd1> einpacken
08:00:48 <jgt> nshepperd1: I'll have none of that lisp nonsense around here thanks
08:00:53 <geekosaur> homempty, and confuse everyone :p
08:01:07 <jgt> f `whatsTheProblem` g
08:01:56 <mniip> I actually have a file somewhere that says
08:02:02 <geekosaur> f `fuzzy` g
08:02:17 <mniip> -- A monad is just a monoid in the category of endofunctors                     
08:02:18 <mniip> return = runNT (mempty @Compose) . Identity                                     
08:02:18 <mniip> join = runNT mappend . Compose
08:02:59 <jgt> f `itsJustSmartPipes` g
08:03:21 <[exa]> are there monad examples where return is somehow significantly different from pure?
08:03:35 <dmwit> No.
08:03:47 <mniip> no because every monad generates an applicative
08:03:47 <dmwit> It is a law that they be the same.
08:03:51 <nshepperd1> do x <- foo; eingewickelt (x + y)
08:04:05 <mniip> and we arrange that the applicative instance is the same as the one generated by the monad instance, if there is one
08:04:17 <mniip> this is why `instance Applicative []` is iteration and not zipping
08:04:22 <dmwit> (However, there are types with two different Applicative instances whose pure's are different.)
08:04:47 <mniip> [] has an infinite amount of applicative instances
08:04:58 <[exa]> like, ofcourse there's the law for return==pure, but we've had 'fail' and pals
08:05:26 <mniip> [exa], you could define instance Monad ZipList via coercing Monad []
08:05:42 <mniip> you would have return x = [x], and pure x = repeat x
08:06:24 <[exa]> hm interesting
08:14:04 <nshepperd1> "[] has an infinite amount of applicative instances" it does? How so?
08:15:30 <[exa]> nshepperd1: (wild guess: ) ordering of the output list?
08:17:09 <mniip> I was actually contemplating enumerating all of them, but here's a quick proof that there's at least infinitely many of them
08:17:13 <nshepperd1> That would conflict with fmap id = id
08:19:04 <mniip> newtype L (n :: Nat) a = L [a]; instance KnownNat n => Applicative (L n) where pure = replicate (n + 1); L xs <*> L ys = L $ zipWith id (take n xs) (take n ys) ++ (drop n xs <*> drop n ys)
08:19:37 <mniip> quick explanation would be that L 0 = [], in terms of applicative instances
08:20:21 <mniip> and L (n + 1) = Maybe (a, L n a)
08:20:29 <mniip> you can see how this composition creates a lawful applicative
08:21:44 <nshepperd1> Interesting
08:22:02 <nshepperd1> It's a combination of the two normal instances
08:22:15 <mniip> more like, ZipList is the limiting case L Infinity
08:24:54 <nshepperd1> Neat
08:30:40 <Lears> I don't think it works. If (<*>) truncates you won't keep `pure id <*> v = v` for longer `v`s. And so long as your instance is zippy, what can it do but truncate when one input is shorter?
08:32:22 <mniip> but pure id is "long enough"
08:32:28 <dmwit> Lears: But pur... what mniip said
08:33:35 <dmwit> Lears: pure id <*> v = v looks satisfied to me.
08:35:37 <mniip> @let data P f g a = P (f a) (g a) deriving Functor; instance (Applicative f, Applicative g) => Applicative (P f g) where pure x = P (pure x) (pure x); P f g <*> P x y = P (f <*> x) (g <*> y)
08:35:39 <lambdabot>  Defined.
08:35:41 <mniip> is this instance believable
08:36:48 <dignissimus> I get a syntax error when assigning the result of a case expression to a variable inside a do block, what's the problem here? https://paste.rs/oBQ https://paste.rs/tDF.hs
08:37:41 <dignissimus> When I remove the the `let withAI = ...`, it's all fine
08:37:44 <mniip> furthermore
08:37:47 <mniip> @let newtype H f a = H (Maybe (P Identity f a)) deriving Functor; instance Applicative f => Applicative (H f) where pure = H . getCompose . pure; H fs <*> H xs = H $ getCompose $ Compose fs <*> Compose xs
08:37:50 <lambdabot>  Defined.
08:38:05 <Lears> I see now that a single `id` is being held over to non-zippily cover the rest of the second input ... So I guess the instances comes down to something like the product of a vector and a list.
08:38:09 <geekosaur> the case alternatives are aligned with the let bindings, so it looks like another let binding
08:38:28 <dmwit> dignissimus: The branches of the case must be indented more than the variables of the let.
08:39:23 <dmwit> dignissimus: That will get you to your next error. ^_^
08:39:34 <geekosaur> heh
08:39:37 <mniip> @let toH [] = H Nothing; toH (x:xs) = H (Just (P (Identity x) xs)); fromH (H Nothing) = []; fromH (H (Just (P (Identity x) xs))) = x:xs
08:39:39 <lambdabot>  Defined.
08:39:40 <geekosaur> yes, theres a  few issues there
08:39:44 <mniip> :t (toH, fromH)
08:39:45 <lambdabot> ([a1] -> H [] a1, H [] a2 -> [a2])
08:39:51 <dignissimus> So many red lines! D:
08:40:01 <mniip> so [] is naturally isomorphic with H []
08:40:07 <dignissimus> I'll try to fix them on my own first though
08:40:14 <mniip> and see above, instance Applicative f => Applicative (H f)
08:40:21 <mniip> this concludes the proof
08:41:24 <mniip> > fromH $ fromH $ (toH $ toH [10, 20, 30, 40]) <*> (toH $ toH [1, 2, 3, 4])
08:41:26 <lambdabot>  error:
08:41:26 <lambdabot>      • Couldn't match expected type ‘H [] a’ with actual type ‘[a1]’
08:41:26 <lambdabot>      • In the second argument of ‘($)’, namely
08:41:36 <mniip> > fromH $ fromH $ liftA2 (+) (toH $ toH [10, 20, 30, 40]) (toH $ toH [1, 2, 3, 4])
08:41:38 <lambdabot>  error:
08:41:38 <lambdabot>      • Couldn't match expected type ‘H [] a’
08:41:39 <lambdabot>                    with actual type ‘[Integer]’
08:42:01 <mniip> > fromH $ fmap fromH $ liftA2 (+) (fmap toH $ toH [10, 20, 30, 40]) (fmap toH $ toH [1, 2, 3, 4])
08:42:03 <lambdabot>  error:
08:42:03 <lambdabot>      • No instance for (Num (H [] ()))
08:42:03 <lambdabot>          arising from a use of ‘e_12102030401234’
08:42:07 <mniip> dammit
08:42:07 <mniip> one sec
08:43:42 <mniip> this doesn't stack inductively as I expected it to
08:45:40 <mniip> @let liftH :: (forall a. f a -> g a) -> H f a -> H g a; liftH h (H Nothing) = H Nothing; liftH h (H (Just (P x xs))) = H (Just (P x (h xs)))
08:45:42 <lambdabot>  Defined.
08:45:51 <mniip> :t liftH (liftH toH) . liftH toH . toH
08:45:52 <lambdabot> [a] -> H (H (H [])) a
08:46:11 <mniip> > fromH $ liftH fromH $ liftA2 (+) (liftH toH $ toH [10, 20, 30, 40]) (liftH toH $ toH [1, 2, 3, 4])
08:46:13 <lambdabot>  [11,22,33,34,43,44]
08:46:27 <mniip> as you can see it zips the first two and cartesian products the rest
08:54:00 <Lears> tldr there's an Applicative-structure-preserving embedding of `P (Vec n) []` into `[]`
08:54:06 <Lears> or something like that
09:04:06 <dignissimus> I think the compler is saying that it can't induce what getInputLine should return? If so, I'm still confused, I tried adding  `:: InputT (MonadException IO) (Maybe String)` after it but that was just a guess https://paste.rs/Nza.hs https://paste.rs/MPq.tpl
09:04:38 <merijn> MonadException is a typeclass, you can't put it there
09:05:32 <merijn> dignissimus: That block in the "players" binding looks wrong
09:05:44 <merijn> dignissimus: That never gets executed
09:06:28 <dignissimus> What does this mean? I thought it was a suggestion for an instance that would work: instance MonadException IO -- Defined in ‘System.Console.Haskeline.MonadException’
09:07:07 <merijn> dignissimus: Your problem is the lack of MonadException, your problem is that you're defining players and never using it
09:07:26 <merijn> dignissimus: Actually, none of that code does anything
09:07:42 <merijn> Well, that's not true the getInputChar line does something
09:07:44 <monochrom> merijn, you missed a "not" in the first half sentence :)
09:08:05 <dignissimus> merijn: Not yet, I'm adding things bit by bit
09:08:34 <merijn> dignissimus: No, my point is that all those 20+ lines on the right of "let players" *literallly* do nothing in that code
09:08:50 <monochrom> "player" is defined but not used, therefore compiler cannot infer free-standing "player"s type.
09:09:24 <monochrom> (There is a longer story but that's for another day.)
09:10:20 <merijn> dignissimus: Perhaps you meant "players <- {- code here -}"?
09:10:35 <monochrom> Here is a simpler example of what merijn is saying.  "main = do { let {x = getLine} ; putStrLn "hello" }"  try it.
09:10:36 <merijn> The same applies to basically all the let bindings you have there
09:11:00 <merijn> monochrom: That works because getLine is monomorphic, though :)
09:11:10 <monochrom> I mean the noop aspect.
09:11:52 <merijn> dignissimus: Actually, I think we can get to the bottom of the entire problem by having you answer 1 question :)
09:12:20 <merijn> dignissimus: Why do you use "<-" to define entered, but "let" for everything else?
09:13:27 <dignissimus> Because I thought getInputChar returned some sort of wrapper like getLine does
09:13:46 <merijn> what does "wrapper" mean?
09:14:06 <dignissimus> Something like `IO String`
09:14:13 <merijn> dignissimus: Relatedly: What is the type of, say, "generator"?
09:14:24 <dignissimus> StdGen I think
09:14:34 <merijn> :t newStdGen
09:14:36 <lambdabot> IO StdGen
09:14:38 <dignissimus> hmmmm
09:14:41 <merijn> I highly doubt it :)
09:14:53 <monochrom> Do not think. Fact check.
09:14:57 <monochrom> Never think.
09:14:58 <merijn> dignissimus: Try adding type signatures for all your "let" bindings
09:15:18 <monochrom> This world is all wrong and people are polarized because people think.
09:15:53 <merijn> Type signatures are like violence
09:16:01 <merijn> If it's not working, you're not using enough of them
09:16:06 <monochrom> haha
09:16:44 <dignissimus> With the first let binding I wrote `withAI :: Bool` and I get `Variable not in scope: withAI :: Bool`
09:16:48 <monochrom> No actually I hold the opposite opinion sometimes.  Remove type signatures so you learn from the computer rather than being cocky.
09:17:49 <dsal> Add or remove type signatures to fix things. Move a type signature from one thing to another.
09:19:39 <dignissimus> Hmm, changing let ... = ... to `... <- ...` magically fixed everytinh
09:19:55 <monochrom> This is why I no longer teach do-notation.
09:20:05 <dignissimus> What's the alternative?
09:20:07 <merijn> dignissimus: This situations is why I usually recommend beginners to avoid do-notation for, say, the first month
09:20:12 <monochrom> Use >>= directly.
09:20:15 <merijn> dignissimus: >> and >>= directly
09:20:31 <monochrom> I'm so ghetto I don't even teach >>
09:21:06 <merijn> dignissimus: The problem with "do notation" (for beginners) that it looks too much like magic, so they start thinking it *is* magic, as opposed to some fairly trivial and mechanical translation rules
09:21:32 <merijn> dignissimus: Understanding the underlying logic is crucial to not get confused by cases like this.
09:22:01 <dignissimus> I think I bookmarked a page about how do is just syntax sugar for >>=, I'll try and dig it up
09:22:06 <monochrom> Most of the time I teach ">>= \_ ->" directly.  In a few cute cases like "skipspaces *> myparser <* eof" I teach *> and <* because I have covered Applicative before that point.
09:22:25 <merijn> dignissimus: https://en.wikibooks.org/wiki/Haskell/do_notation
09:22:52 <merijn> dignissimus: I mean, do notation itself is *great* for readability, but not so much for learning :)
09:23:05 <merijn> See also:
09:23:28 <merijn> @undo do { x <- getLine; print (readMaybe x); }
09:23:29 <lambdabot> getLine >>= \ x -> print (readMaybe x)
09:24:37 <unfixpoint> Do people write code like this ^?
09:24:57 <unfixpoint> Am I the only one that prefers `print . readMaybe =<< getLine`?
09:25:02 <monochrom> Do I count as people?
09:25:12 <monochrom> You are not alone either.
09:25:40 <monochrom> But I have a meta-level question along that line.
09:26:01 <merijn> unfixpoint: Sometimes, for short code, yes. Do I do it consistenly? No. Do I think it's great for beginners to write code like that at first? Definitely.
09:26:02 <unfixpoint> I'll let you decide that, though if you're not a people it might be difficult to arrive at a sensible conclusion (in that case the answer is simple: no).
09:26:08 <monochrom> Do people expect one size fits all? Am I the only one that prefers diversity and freedom?
09:26:32 <merijn> I think there's an important distinction between learning and using.
09:26:36 <[exa]> unfixpoint: your form kindof supports the right-to-left dataflow that is common when using (.). In longer programs (esp. on multiple lines) it stops looking natural
09:26:44 <merijn> Do notation is *brilliant* for using, not so much for learning
09:27:24 <geekosaur> I'll often use >>= or =<< for one-liners, although I also occasionally use 1-line do-s when they're fitting a pattern for some reason (e.g. formulaic debug dumpers in an xmonad module, that came up recently)
09:27:53 <geekosaur> but it really is useful for understanding what do is and is not, that you do it by hand at first
09:28:04 <geekosaur> otherwise you'll be endlessly confused by things like let vs <-
09:28:12 <unfixpoint> [exa]: Yeah, that's so true I don't have consistent Haskell style for many reasons (one being that one) 
09:28:29 <merijn> Consistency is overrated
09:28:39 <[exa]> unfixpoint: compare with ⌜getLine >>= print.readMaybe⌝ and ⌜getLine >>= readMaybe .> print⌝
09:28:46 <[exa]> +1 merijn
09:28:48 <monochrom> Herd compliance die die die
09:28:50 <merijn> There's certainly a consistency in my formatting, but it's not something simple and rule based, it's aesthetics
09:29:03 <merijn> It's why I heavily dislike hlint and all these autoformatters
09:29:13 <[exa]> whatever best suits the story behind the algorithm (even documentation!) is the best version
09:30:04 <monochrom> Yes, with Haskell you finally get to do aesthetics rather than robot army conformance coding style.
09:30:54 <unfixpoint> [exa]: If I had to choose, I'd opt for the latter one where the information flow is in one direction.
09:31:22 <unfixpoint> Also using `print.readMaybe` will get you into trouble one day when `print` becomes a constructor ;)
09:32:40 <geekosaur> I don't think we're losing case any time soon, sadly
09:33:03 <[exa]> print being a constructor of what?
09:34:01 <unfixpoint> I mean if you have `Ctor.f` sorry, nothing to do with either `print` or `readMaybe`
09:34:39 * [exa] got scared
09:40:20 <higherorder> Hi! What's the lens operator to map a function over a getter? e.g. go from `Getter s a` to `Getter s b` with `a -> b`
09:42:29 <rotaerk> higherorder, https://hoogle.haskell.org/?hoogle=%28a+->+b%29+->+Getter+s+a+->+Getter+s+b&scope=set%3Astackage
09:42:35 <rotaerk> does that first thing work
09:44:44 <mniip> Lears, it's not a Vec
09:44:46 <higherorder> rotaerk: hmm hang on, I need to find the equivalent for the Optics library
09:44:49 <mniip> the Vec itself can be missing members
09:45:07 <mniip> and if it is then the [] part is necessarily empty
09:52:48 <Lears> mniip: Ah, yeah, the structure doesn't factor quite that nicely. I had thought that `H` construction was overcomplicating something, but it makes more sense now.
09:56:16 <mniip> monochrom, TIOWTDI and TIMTOWDI have been conflicting philosophies for quite some time now
09:56:47 <mniip> [exa], replace .> with >>>
10:07:30 <fraktor> So I'm looking at developing a REST server, and it looks like Yesod is pretty common, but I've also heard some negative things about TemplateHaskell.  Is it always bad to use, or is it just kinda frowned upon?
10:08:27 <monochrom> It is neither always good nor always bad.
10:08:54 <fraktor> That's what I figured.
10:08:57 <MarcelineVQ> monochrom: but LEM
10:09:36 <MarcelineVQ> oops wrong channel for nonsequiturs
10:09:43 <monochrom> What you need to think is whether your project and your personality works well with a large framework and a number of DSLs.
10:10:34 <fraktor> If it turns out that it did not, what should I use instead of Yesod?
10:10:51 <fraktor> That's the only web framework I've seen for Haskell so far.
10:11:22 <monochrom> You sound like you accept only frameworks.
10:11:39 <fraktor> Eh, not necessarily.  That's just what I've used in other languages.
10:12:08 <mniip> yesod has the unfortunate thing that it is modeled after rails
10:12:26 <mniip> in particular the development philosophy of being easy to make something
10:12:40 <mniip> simple things should be easy, sacrificing composability and orthogonality
10:12:41 <monochrom> There are a whole bunch of libraries.  I only recall servant right now.
10:12:58 <mniip> also it doesn't have normal docs and instead only has "tutorial" "cookbooks"
10:13:05 <mniip> /rant
10:13:07 <monochrom> (I have never done web stuff. I only remember names from this channel)
10:13:36 <mniip> (I use yesod at work)
10:14:08 <fraktor> mniip: Do you have something you prefer?
10:14:23 <fraktor> monochrom: Looking at servant, it looks like something I would prefer, since I'm a big composability guy.
10:14:24 <mniip> not really, all of webdev is terrible
10:14:31 <fraktor> Agreed on that.
10:14:33 <mniip> yesod uses servant under the hood doesn't it
10:14:41 <jgt> mniip: …no?
10:14:47 <jgt> they both use WAI
10:14:51 <mniip> ah fair
10:15:17 <jgt> there's nothing wrong with Yesod, and Rails gets a lot right in terms of developer workflow
10:15:20 <mniip> I haven't looked to deep but we have a fair amount of servant + yesod interop
10:15:32 <Clint> "nothing"
10:15:41 <mniip> servant for api endpoints, yesod for user-facing routes
10:15:46 <jgt> let's not be debbie downers here
10:15:57 <mniip> jgt, I expressed my frustration
10:16:02 <mniip> it's designed with simplicity in mind
10:16:10 <mniip> that is not necessarily bad but it has its effects
10:16:14 <jgt> mniip: my last comment was directed towards Clint's sarcasm
10:16:37 <monochrom> Hmm, simplicity conflicts with composition...
10:16:40 <fraktor> mniip: I'm writing something that will exclusively API endpoints, so it sounds like servant might be a little better.
10:16:49 <mniip> maybe
10:16:56 <fraktor> Not just from what you said, but also from looking at the documentation for it
10:17:07 <monochrom> Perhaps "simplicity" itself is also ambiguous and admit opposing meanings.
10:17:15 <Clint> perhaps
10:17:20 <mniip> monochrom, yeah good point
10:17:29 <jgt> I haven't used Servant, but it does seem very cool. I like that apparently you can generate both your API and documentation from the types
10:17:37 <mniip> newcomer-friendliness vs conceptual simplicity
10:22:01 <monochrom> My personal measure of simplicity is "if you wrote down complete documentation how long would it be?"
10:23:48 <jgt> I'm sympathetic to both perspectives and definitions, but I know there are plenty of people using Haskell today who probably wouldn't be if it weren't for more hand-holdy style libraries
10:41:29 <rotaerk> simplicity is complicated
10:46:19 <rotaerk> a language's keywords and syntactical constructs make up a sort of "vocabulary", and if you look at just these things, it's a somewhat small vocabulary.  if you start adding in functions and user defined operators, this extends the vocabulary further.  newcomer-friendly code is code that is expressed with minimal vocabulary, because they have little to learn before they have reached the peak ability to read the code.
10:47:26 <rotaerk> but with a small vocabulary, the code may not be able to express complex concepts as easily.  so I think this means that there's a natural opposition between expressiveness and newcomer-friendliness
10:47:47 <merijn> OTOH there's the FreeBSD design philosophy of "You're only a beginner for a shortwhile, but an expert forever, so better optimise tools/configuration for the latter"
10:48:08 <merijn> That's not to say things *shouldn't* be beginner friendly
10:48:52 <rotaerk> right, I don't think newcomer-friendliness is inherently bad or anything, just hard to maintain while prioritizing expressiveness-for-the-expert-reader
10:49:22 <jgt> rotaerk: that's probably true in the general sense, but how true do you think it is in the specific context of Yesod?
10:49:27 <merijn> Things shoud be as beginner friendly as possible, without compromising consitency and ease of use of experts
10:49:40 <rotaerk> I don't know Yesod; I'm *only* speaking in the general sense
10:49:42 <merijn> jgt: I think Yesod is a mess for experts
10:49:52 <merijn> jgt: I would certainly not use it :p
10:50:20 <jgt> merijn: I know you've said this before, and IIRC your main criticism is the heavy(?) use of TH. Is that your main/only criticism?
10:50:56 <rotaerk> and yeah, you shouldn't explode your vocabulary beyond what's useful; there's a point at which increasing the size of it doesn't really buy you anything
10:51:15 <rotaerk> for a given use-case
10:51:20 <merijn> jgt: My main criticism is the lack of transparency (due to large amounts of classes and TH) and the tight coupling between libraries in the ecosystem
10:52:52 <rotaerk> most procedural code is distinct from haskell not only in the sense of being ubiquitously impure-by-default, but also in that it tends not to extend the vocabulary much further than the language's keywords/grammar
10:52:54 <monochrom> When that happens, I suspect that boundaries are drawn based on the authoring organization's own political boundaries, not on what suits users :)
10:53:36 <rotaerk> C# has, say, LINQ which I use instead of raw for/foreach loops most of the time.  but many programmers don't bother with it, and just write all their code directly in terms of if-else, for, etc
10:54:27 <jgt> I'm struggling to follow this analogy
10:55:05 <rotaerk> which analogy
10:55:07 <jgt> I'm also struggling to grasp what "political boundaries" monochrom is hinting at
10:55:13 <jgt> perhaps I just don't know enough
10:55:35 <jgt> but I'm a pretty happy user of Haskell and Yesod, and everyone else's mileage may vary
10:55:39 <monochrom> Boundaries drawn among a group of people.
10:56:00 <monochrom> Like you're in department X I'm in department Y
10:56:17 <jgt> I promise I'm not trying to be obtuse, but I genuinely don't get the point you're making
10:56:41 <merijn> jgt: I'm not saying Yesod is bad or anything. It's just very opaque and the types are complex so as a beginner you're just blindly copy pasting from tutorials and if it doesn't work...well, god help you and good luck on stackoverflow
10:57:15 <merijn> jgt: And due to the TH rendering it tricky to "just look at the code" things aren't a lot better for experienced Haskell programmers
10:57:40 <monochrom> OK suppose there are two libraries but they're very tightly coupled to the point you either use neither or you use them both as one.  How do you explain why the authors haven't merged them?
10:57:41 <merijn> Because you'd first have to mess with -ddump-splices, dive through computer generated noise, etc. to figure out what's *actually* going on
10:57:43 <jgt> merijn: I don't disagree that the types are complex, although saying that I think it's pretty easy to use the Handler type without understanding what it does under the hood
10:58:02 <merijn> jgt: Sure, it's easy to use, right up until the point where it suddenly isn't ;)
10:58:15 <jgt> ok, I think that's fair criticism
10:58:30 <merijn> And when it isn't, it's *really* hard :)
10:59:08 <jgt> could the same not be said of Servant? Again, I haven't used it so I don't actually know, but I've _heard_ that the compiler errors are much more opaque than Yesod's
10:59:17 <merijn> I don't know servant, so I can't say
10:59:31 <merijn> Although it seems overly heavy on type level junk from what I saw
10:59:36 <jgt> though Yesod's errors are pretty intimidating if you create a parse error in some Shakespeare tempalte
10:59:39 <jgt> template*
10:59:48 <jgt> though perhaps that's Shakespeare, and not Yesod specifically
11:00:11 <jgt> merijn: which web framework would you suggest?
11:00:23 <merijn> Mu
11:00:39 <merijn> I don't suggest web frameworks, because I don't do web :)
11:01:38 <jgt> …kind of a moot point then?
11:02:02 <monochrom> Wait, aren't you doing web at work?
11:02:21 <mniip> might have been me?
11:02:24 <merijn> jgt: Me not knowing anything else doesn't preclude me from not liking the things I do know :)
11:02:28 <monochrom> Ah OK!
11:02:30 <merijn> monochrom: Pfft
11:02:54 <merijn> monochrom: I'm doing C++, Fortran and FPGAs, the only web I do is browsing :p
11:03:39 <merijn> monochrom: Honestly not sure if that's better than web, though >.>
11:06:16 <nshepperd> in the docs for System.Mem.StableName it says this: "The reverse is not necessarily true: if two stable names are not equal, then the objects they name may still be equal. Note in particular that makeStableName may return a different StableName after an object is evaluated."
11:07:21 <merijn> Is there a question attached to that? ;)
11:07:24 <nshepperd> am I to take this that 'evaluate x >>= makeStableName' won't return false negatives, as far as pointer equality is concerned?
11:07:25 <alp> jgt, servant is less beginner friendly than libraries like scotty/spock, which are the most approachable ones. then yesod/snap/servant and possibly others are fancier, each in their own way, which tends to materialize as difficulties when learning how to use the thing. with servant, the heavy type stuffs make it a bit unusual in that regard. there are good reasons for this (documented in a blog post and the paper), this is a point in the 
11:07:25 <alp> design space we really were interested in. but it comes at a price.
11:08:11 <monochrom> What is false negative for this?  I don't think stable names help you do pointer equality.
11:08:55 <merijn> nshepperd: Well, what's the reason for false positives being an issue?
11:08:56 <jgt> alp: I'm somewhat aware of that :)
11:09:01 <monochrom> IIRC stable names are just for you to pass to C (and on the C side, don't dereference, it's only a cookie) and then C pass back to Haskell and you receive legit data.
11:09:10 <merijn> monochrom: That's StablePtr
11:09:19 <monochrom> Oh, oops, nevermind.
11:09:51 <monochrom> Oh snap, snap was the name I couldn't recall!
11:10:01 <merijn> nshepperd: I think that false negative caveat only applies if you generate two stable names from the same value
11:10:17 <merijn> nshepperd: So you need to be doing fairly weird things to run into issues
11:11:42 <nshepperd> merijn: I want to do graph algorithms on a graph of observably shared values
11:11:44 * hackage nonempty-vector 0.0.1.0 - Non-empty vectors  https://hackage.haskell.org/package/nonempty-vector-0.0.1.0 (topos)
11:12:42 <merijn> nshepperd: My question was more: Can you implement whatever you want while only generating the stablename once?
11:12:52 <merijn> If not, why not?
11:13:18 <dignissimus> Is there a `groupBy` that disregards order, by this I mean: f (==1) [1, 2, 2, 1, 1, 3] would return [[1, 1, 1], [2, 2, 3]]
11:13:36 <merijn> dignissimus: "group . sort" :)
11:14:06 <nshepperd> uh... maybe?
11:14:22 <merijn> nshepperd: Because if you can, then your problem is already solved :)
11:14:32 <nshepperd> I guess I can try using unsafePerformIO to stick the object's StableName inside itself O_O
11:15:11 <EvanR> StableName of something can change if it's not already evaluated
11:15:31 <EvanR> if unsafePerformIO runs near the time thing is evaluated, not sure which name you would get
11:15:55 <merijn> nshepperd: The problem is basically that running makeStableName on a value before and after evaluation may return different stable names, but a single StableName always refers to a single object, so if you only ever use makeStableName once per object there's no false negatives
11:15:56 <nshepperd> EvanR: yeah, my question is whether it *can't* if I always evaluate the thing first
11:16:26 <EvanR> you mean, if you generate the stable name twice on the same thing?
11:16:45 <EvanR> i guess that's the point of stable names
11:17:04 <EvanR> detect if this object was already seen, for whatever purposes
11:17:15 <nshepperd> EvanR: in other words, whether "the object is not already evaluated" is the *only* time the StableName can change
11:17:45 <merijn> nshepperd: If you want to be really pedantic it still depends
11:17:56 <merijn> nshepperd: Objects may be evaluated multiple times
11:18:13 <merijn> nshepperd: and they may be duplicated
11:18:16 <dmwit> dignissimus: partition
11:19:05 <dmwit> dignissimus: But your behavioral spec doesn't match what `groupBy` does very well, which is probably what prompted merijn's related answer.
11:20:02 <gaze__> anyone have a suggestion for how to display diagrams from ghci?
11:20:03 <dmwit> dignissimus: If it turns out you really do want something more like groupBy than like the spec you gave, then you might enjoy looking through https://stackoverflow.com/q/12398458/791604
11:20:18 <dmwit> gaze__: I've used and enjoyed the diagrams library.
11:20:32 <gaze__> haha sorry, I specifically mean the diagrams library
11:20:42 <gaze__> I'm just curious what a good workflow is for interactively working with it.
11:20:54 <dmwit> Open up the diagram in a client that automatically refreshes.
11:21:12 <gaze__> mmm okay.
11:21:15 <dmwit> Then use one of the diagrams library's utilities for re-running themselves when you change their source.
11:21:44 * hackage arithmoi 0.10.0.0 - Efficient basic number-theoretic functions.  https://hackage.haskell.org/package/arithmoi-0.10.0.0 (Bodigrim)
11:22:42 <dmwit> http://hackage.haskell.org/package/diagrams-svg-1.4.2/docs/Diagrams-Backend-SVG-CmdLine.html shows how to do this last bit
11:22:48 <EvanR> nshepperd: the docs make it sound like stable names could be arbitrary by having hashtable keys be the only example use case. Would be nicer if they coincided more, but they might not. But to me that seems kind of useless
11:23:11 <EvanR> and I haven't personally seen stable names change on fully evaluated thingies
11:26:19 <nshepperd> hm
11:26:24 <nshepperd> merijn: under what kind of conditions?
11:26:56 <EvanR> also ... no Ord instance for StableNames heh. I get this in a vague theoretical sense, but come on that makes Map and Set not work
11:27:00 <dignissimus> Ok so, I have a TicTacToe board implemented as a `Map Location GamePiece`, where Location is `(Int, Int)`, I want to check whether or not the game has finished, is a Map suitable for this? With the map, my current idea is to filter the map 8 times, (once for each column, once for each diagonal and once for each row) then check whether it's the case that in any grouping all the pieces are the same
11:27:25 <merijn> nshepperd: If GHC thinks a thunk is cheap enough to compute that evaluating it multiple times is cheaper than waiting for another thread to finish (in a multi-threaded setting)
11:27:53 <merijn> dignissimus: For something like tictactoe I'd probably just use a 3x3 Array
11:28:04 <dmwit> dignissimus: That sounds reasonable enough to me.
11:28:15 <EvanR> if Array's API didn't stink
11:29:25 <EvanR> you could write a pattern function of some sort to look at rows and columns
11:29:42 <merijn> There's no real convenient fold/foldMap that lets me treat the last element differently, is there?
11:30:04 <dignissimus> EvanR: Pattern function?
11:31:38 <EvanR> pattern guard?
11:31:50 <EvanR> ignore me
11:34:17 <EvanR> i imagine the conditions on tic tac toe being framed as talking about one of 8 views of the board
11:34:39 <EvanR> Diag1 x y z, Diag2 x y z, Row1 x y z, etc...
11:34:44 * hackage spacecookie 0.2.1.0 - Gopher Library and Server Daemon  https://hackage.haskell.org/package/spacecookie-0.2.1.0 (sternenseemann)
11:35:01 <EvanR> x==y==z would be the winning condition
11:35:39 <EvanR> view patterns
11:36:54 <EvanR> since we only check 1 thing this way in tic tac toe probably not worth the abstraction
11:39:28 <EvanR> if we had non linear patterns, pattern guards would make it cute
11:57:11 <nshepperd> well, switching to making the stablename once and stuffing it inside the object itself seems to have resolved my test failures
11:59:21 <nshepperd> though at that point what i'm doing is not really any different from impurely incrementing a global MVar Int
12:00:27 <nshepperd> (and using it as a source of unique identifiers)
12:02:26 <Lears> merijn: You can write a Semigroup on something ~ V2 a that delays combination of the last thing it sees, but it's not a Monoid so you'd need to be using `foldMap1`.
12:03:34 <nshepperd> I guess stablenames are really only good for caching things
12:05:06 <dsal> Teaching gf Haskell is hard.  She's really smart, but doesn't let me talk to her while she's doing something.
12:05:43 <dignissimus> This hurt my brain and I don't want to do it again: https://paste.rs/03e.hs
12:05:47 <merijn> dsal: Sometimes you just gotta shit up and suffer through watching someone do things really inefficiently so you don't overload them :p
12:07:09 <evelyn> you were them, once
12:07:10 <dsal> merijn: yeah.  It's hard.  She's doing probably better than I was at this stage. I just want to drop hints now and then, but she's got a million tabs open and is determined to learn by struggling.
12:07:22 <dsal> evelyn: I'm still them
12:07:46 <merijn> dsal: I know your pain all too well :p
12:08:09 <merijn> dsal: Thankfully I got to her before she starts her Java based schooling next year :p
12:08:18 <dsal> Haha
12:09:45 <merijn> dsal: The curriculum has "data structures (trees, etc.) and recursion" in the advanced section and she's just going "but that's easy..."
12:14:44 * hackage lenz 0.4.1.0 - Van Laarhoven lenses  https://hackage.haskell.org/package/lenz-0.4.1.0 (MatthewFarkasDyck)
12:42:58 <monochrom> @quote monochrom textbook
12:42:58 <lambdabot> No quotes match. My pet ferret can type better than you!
12:43:03 <monochrom> aww
12:43:30 <monochrom> @quote monochrom chapter
12:43:30 <lambdabot> monochrom says: If you read a haskell book or an FP book, by chapter 5 it's already doing data structures. It's chapter 10 in imperative books.
12:45:35 <MarcelineVQ> or lecture 2 in a course
12:50:12 <dignissimus> Is this recursion ok? https://paste.rs/seH.hs
12:52:17 <[exa]> dignissimus: ⌜return⌝ is not what it used to be in imperative languages
12:52:39 <dmwit> Also, I doubt `let game = doMove move game` does what you want it to do.
12:52:48 <dmwit> (Remember: recursion everywher. So this is a recursive definition.)
12:53:24 <EvanR> and i have an issue with your error check.  But none of this answers your question :)
12:53:41 <dmwit> I think both [exa] and I were directly answering the question.
12:53:45 * hackage rattletrap 9.0.5 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-9.0.5 (fozworth)
12:53:53 <EvanR> the recursion
12:53:54 <dmwit> There are two recursive occurrences here, and neither is okay. =P
12:54:05 <EvanR> eh?
12:54:13 <f-a> what game are you working on dignissimus 
12:54:40 <dmwit> The playGame recursion isn't okay because the `when` check doesn't prevent it from recursing as intended; the `game` recursion isn't okay because it almost certainly wasn't even intended to be recursion in the first place.
12:54:44 * hackage grammatical-parsers 0.4.1.2 - parsers that combine into grammars  https://hackage.haskell.org/package/grammatical-parsers-0.4.1.2 (MarioBlazevic)
12:54:57 <EvanR> "game recursion?"
12:54:57 <[exa]> dmwit: "not okay" :
12:55:08 <EvanR> oh
12:55:11 <EvanR> funny
12:55:16 <dmwit> yeah =)
12:56:01 <EvanR> this was probably an unintentionally sense-making question
12:56:02 <[exa]> dignissimus: aaanyway, I'd start correcting the thing with using 'unless' before the 'do'
12:57:39 <dignissimus> f-a: TicTacToe so I can improve my haskell knowledge and try out the minimax algorithm
12:58:55 <sternmull> How to i express the type signature of a function that returns itself (or has itself as an argument, basically a recursive signature)?
12:59:10 <dignissimus> [exa]: And that's becsuse return doesn't halt the control flow?
12:59:23 <EvanR> newtype L = L (L -> L)
12:59:25 <[exa]> dignissimus: exactly
13:00:39 <sternmull> EvanR: I don't get it.
13:00:52 <EvanR> well it does what you wanted :)
13:01:20 <hpc> sternmull: you need a data type to avoid having an infinite type
13:01:21 <dignissimus> With the `game` recursion doMove takes a move and returns the game after the move has been performed
13:01:24 <[exa]> sternmull: "has itself as an argument" kindof asks for an infinite type, which you need to wrap a bit in order to actually work
13:01:29 <EvanR> L is a function type that takes itself and returns itself
13:01:40 <[exa]> sternmull: see the naive type of fixpoint
13:03:13 <sternmull> and where in "newtype L = L (L -> L)" do i put the rest of the signature? I mean the non-recursive part of it.
13:04:00 <EvanR> namely... ?
13:05:12 <EvanR> i mean you can change L -> L to have more arguments or return values as you please, until you need even more recursion
13:05:14 <sternmull> lets say i want "Int -> Bool -> _magicSelfReference_". Where do i put the first two arguments?
13:05:30 <EvanR> newtype L = L (Int -> Bool -> L)
13:05:57 <sternmull> oops... yeah, that makes sense :)
13:06:08 <sternmull> thank you
13:06:23 <EvanR> and now we can all wonder how that can do anything
13:07:01 <sternmull> you mean it makes no sense?
13:07:06 <EvanR> it makes sense
13:07:57 <EvanR> i guess i don't know the right words for what is odd about it 
13:09:26 <[exa]> EvanR: it can still fail, that's a great result
13:09:41 <EvanR> you mean like error?
13:10:00 <EvanR> freezing up isn't my idea of a great result :)
13:10:02 <sternmull> i want to have a function that does at most one modification inside a recursive data structure. So my idea is that it returns the (possibly) updated node and a function that is either the real modifying function or (after the first modification happened) a noop-function of the same type.
13:11:26 <[exa]> okay that's completely different in fact!
13:11:28 <dignissimus> Have I done this wrong? I want to get input from the user but I think I might have to declare that in the function type? https://paste.rs/yE0.hs
13:11:30 <geekosaur> maybe you want a con tinuation type of thing: Done node | Continue node continuation ?
13:11:45 <sternmull> geekosaur: Yes, i think so
13:12:36 <dignissimus> Also ignore that I've used let = getLine in the commented section
13:13:03 <geekosaur> dignissimus, it'd need to be IO Move, or whatever monad haskeline uses to keep its state these days
13:13:16 <geekosaur> and it'd thereby need to use <- instead of let for the input
13:14:46 <dignissimus> Would it make sense to change PlayerLogic to be `PlayerLogic :: Game -> IO Move`? Because not all players will make use of IO
13:15:41 <dmwit> Yes. Players that do not make use of IO can use `return` to wrap their pure result accordingly.
13:15:54 <geekosaur> if you wanted to be really clever you'd use a free monad and run it with IO or something else as appropriate, but that's probably a bit much for a beginner
13:16:23 <dmwit> Free monads solve a different problem, I think.
13:16:57 <merijn> dmwit: The problem of "my pattern matches don't have enough boiler plate"? ;)
13:18:19 <geekosaur> they can be used for this one, and that was one of the original drivers (Prompt was one of the first implementations of the idea)
13:18:42 <EvanR> big brain, use IO to get player move. bigger brain, use a free monad to abstract the getting of the move. astrobrain, pass the move in as an argument
13:18:59 <geekosaur> and operational followed shortly thereafter
13:22:41 <redsombrero> go to nicklist
13:26:34 <dignissimus> My programme just outputs `TicTacToe <<loop>>`, why is this? https://paste.rs/Waz.hs https://paste.rs/hyM
13:27:10 <EvanR> "spot the bad recursion" game
13:27:12 <dmwit> Because `let game = doMove move game` does not do what you think it does.
13:27:30 <geekosaur> which you were told earlier
13:28:00 <dmwit> Well. I'm not sure that's why. But that part is definitely wrong.
13:28:08 <dmwit> There might be another mistake, too.
13:28:13 <geekosaur> you cannot "assign to" "game". what you told it to do instead is to make a new binding "game" hiding the old, which refers not to the old one but to itself
13:29:22 <dmwit> Ah, no, there's another reason.
13:29:31 <dmwit> But it's the same reason, but a different reason. =P
13:29:45 <dmwit> `let (humanWillGoFirst, generator) = random generator` does not do what you think it does.
13:29:57 <geekosaur> same thing again indeed
13:29:58 <dmwit> For exactly the same reason: if it can be recursion, it is. So it's recursion. Not replacement.
13:30:19 <[exa]> hm. is there some prominent example of a type that is both Functor and Foldable but not Traversable?
13:30:21 <geekosaur> there is no "assignment" in Haskell. don't try to do it, it wwill cause a loop instead
13:31:19 <geekosaur> [exa], I don't think so since practically speaking Foldable means "there's some way to flatten it into a list" and lists are Traversable?
13:31:56 <dmwit> [exa]: https://stackoverflow.com/a/12896512/791604
13:32:06 <geekosaur> hm, there's the sructure preserving aspect, which Traversable does have to deal with. having both doesn't mean using together
13:32:09 <dignissimus> I've written `doMove move game >>= \game -> playGame roles game` is this closer?
13:32:17 * geekosaur needs to wake up more
13:32:28 <EvanR> yeah that does not follow
13:32:38 <dmwit> dignissimus: The standard fix is `let game' = doMove move game`. Note the extra prime at the end of the name `game'`.
13:33:10 <dmwit> (You could also use a number or some letters or anything you want, so long as the name on the left and the name on the right are different.)
13:33:10 <geekosaur> dignissimus, just use a different name instead of trying to get clever. and it's not clear to me that doMove can be used that way
13:33:19 <dmwit> (Like `let game2 = doMove move game` or whatever.)
13:33:36 <geekosaur> since you were using it in let, which implies either it's not in IO or you are again not doing what you think
13:34:40 <dignissimus> Even if `let game = ...` hid the old game, what's wrong with that? I'm not using it anymore
13:35:01 <geekosaur> you were using it, as the parameter to doMove
13:35:15 <geekosaur> except what it really did was use the new one, which you didn't expect and which causes a loop
13:35:37 <dignissimus> ohhhh
13:35:52 <geekosaur> the other one with `generator` has the same problem
13:35:56 <EvanR> let ones = 1:ones
13:36:00 <EvanR> recursive
13:36:24 <geekosaur> > ones
13:36:27 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:36:31 <geekosaur> bah
13:36:38 <[exa]> dmwit: that is cool, thanks!
13:36:40 <geekosaur> > ones'
13:36:40 <EvanR> looks right
13:36:43 <lambdabot>  error:
13:36:43 <lambdabot>      • Variable not in scope: ones'
13:36:43 <lambdabot>      • Perhaps you meant ‘ones’ (line 273)
13:36:55 <geekosaur> > > let ones' = 1:ones' in take 3 ones'
13:36:58 <lambdabot>  <hint>:1:1: error: parse error on input ‘>’
13:36:59 <geekosaur> crap
13:37:04 <geekosaur> >let ones' = 1:ones' in take 3 ones'
13:37:11 * geekosaur is not doing so well today...
13:37:14 <geekosaur> > let ones' = 1:ones' in take 3 ones'
13:37:17 <lambdabot>  [1,1,1]
13:37:35 <geekosaur> there was no earlier definition there for it to use
13:37:47 <geekosaur> would have worked better without me making fumbly mistakes though
13:39:44 * hackage hmp3-ng 2.7.1 - A 2019 fork of an ncurses mp3 player written in Haskell  https://hackage.haskell.org/package/hmp3-ng-2.7.1 (galen)
13:41:44 * hackage cpkg 0.2.3.6 - Build tool for C  https://hackage.haskell.org/package/cpkg-0.2.3.6 (vmchale)
13:43:14 * hackage ats-pkg 3.2.6.4 - A build tool for ATS  https://hackage.haskell.org/package/ats-pkg-3.2.6.4 (vmchale)
13:52:32 <ashe[m]> Hey everyone
13:53:54 * dmwit waves
13:54:45 * doublex particulates
13:55:11 <ashe[m]> I was wondering if anyone knew of any other programming servers? the matrix.org server is too slow for me to search for rooms right now
13:56:49 <monochrom> I would use IRC directly. I am using IRC directly.
13:57:14 * hackage massiv 0.4.3.0 - Massiv (Массив) is an Array Library.  https://hackage.haskell.org/package/massiv-0.4.3.0 (lehins)
13:57:53 <ashe[m]> ah okay thanks :) 
14:01:14 * hackage nonempty-vector 0.0.1.1 - Non-empty vectors  https://hackage.haskell.org/package/nonempty-vector-0.0.1.1 (topos)
14:02:38 <EvanR> historical jargon question here
14:02:45 <EvanR> what is a "constructor class"
14:03:27 * hackage rattletrap 9.0.6 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-9.0.6 (fozworth)
14:03:34 <MarcelineVQ> idk man, google says https://mail.haskell.org/pipermail/haskell/2001-October/008179.html
14:04:57 <EvanR> ok so it's like... * -> *
14:05:10 <EvanR> or the combination of type classes and types of kind * -> *
14:08:46 <dignissimus> Any books/resources you guys would recommend for getting to grips with some concepts that might be new to an imperative programmer?
14:16:14 * hackage rational-list 1.0.0.0 - finite or repeating lists  https://hackage.haskell.org/package/rational-list-1.0.0.0 (RossPaterson)
14:25:08 <dmj`> dignissimus: any concepts in particular ?
14:33:15 * hackage purescript 0.13.4 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.13.4 (hdgarrood)
15:00:44 * hackage ghcide 0.0.4 - The core of an IDE  https://hackage.haskell.org/package/ghcide-0.0.4 (cocreature)
15:07:54 <fraktor> I'm building a project with stack, and for some reason it's not able to find my modules.  What problems might be causing this?
15:08:01 <fraktor> It can find the main module, but not any others.
15:08:47 <mmaruseacph2> are you building an executable?do you have a main function? is the file with the main function listed in main-is in cabal?
15:09:56 <fraktor> I am building an executable, I am able to build it and run it when not importing my modules.  Yes, it is listed in main-is in cabal.
15:10:02 <Axman6> what does your cabal file look like?
15:10:22 <Axman6> have you told it where your modules are?
15:10:50 <fraktor> I have given it that in hs-source-dirs.
15:11:18 <Axman6> without seeing the cabal file and stack.yaml we're blind, it could be any number of things
15:11:54 <fraktor> Cool cool, I'll put them in a pastebin.
15:12:13 <Axman6> if you also add the output of `tree` that would be great
15:13:43 <fraktor> ttps://0paste.com/40386
15:13:53 <fraktor> Oops, bad link: https://0paste.com/40386
15:14:20 <EvanR> that's a nice 0paste
15:14:51 <EvanR> i'll post a 0paste later
15:15:02 <fraktor> ?
15:15:40 <EvanR> exercising new language
15:17:42 <EvanR> question, is the only difference between haskell-with-GADTs and a dependently typed language whether you can freely use value level in the type level (and vice versa)
15:18:01 <EvanR> as opposed to having two levels separate
15:18:53 <merijn> EvanR: GADTs have essentially zero to with dependent types...
15:18:59 <merijn> EvanR: Are you thinking of DataKinds?
15:19:12 <EvanR> haskell + GADTs + DataKinds
15:19:44 <MarcelineVQ> fraktor: What's the actual error output you're getting?
15:19:48 <EvanR> GADT constructors can have the output type dependend on things, unlike nonGADTs
15:19:57 <merijn> EvanR: If you're willing to handwave all sorts of subtleties like "generally can't infer all dependently typed expressions" and lots of stuff like that
15:20:24 <EvanR> type inference works just fine with GADTs and DataKinds? across the board?
15:20:47 <fraktor> MarcelineVQ: I'm getting a "cannot find module 'Smeebot.Database'" error.
15:20:55 <EvanR> maybe i need to add RankN to the question
15:21:02 <merijn> EvanR: I'm just pointing out what I remember from some lectures on dependently typed languages
15:21:03 <EvanR> to break type inference
15:21:16 <merijn> EvanR: You can infer *some* things in a dependent setting, but far from *all*
15:21:26 <fraktor> Oh wait, I just figured it out. I didn't quite get how namespacing worked.
15:21:32 <EvanR> basically, did haskell get basically dependent types through all these features, just no value-type integration
15:21:37 <EvanR> merijn: i know
15:22:14 <MarcelineVQ> fraktor: oh? your folder structure suggests the module should be called Database not Smeebot.Database
15:22:31 <MarcelineVQ> Smeebot.Database would be /src/Smeebot/Database.hs
15:22:34 <fraktor> Yep. I moved Database into Smeebot/ and now it works.
15:23:43 <MarcelineVQ> you typically also would want to add Smeebot.Database to other-modules: in your cabal file's executable section
15:23:44 <EvanR> ok type level computation is being carried out with type classes right now, that's totally different
15:24:11 <MarcelineVQ> as in "other-modules: Smeebot.Database"
15:24:31 <fraktor> Good to know.
15:25:15 <MarcelineVQ> stack should warn you about that when you build though if you have a halfway recent version
15:51:14 * hackage nonempty-vector 0.1.0.0 - Non-empty vectors  https://hackage.haskell.org/package/nonempty-vector-0.1.0.0 (topos)
15:52:32 <topos> LTS compat is a pain in the ass
15:54:44 * hackage coinbase-pro 0.7.0.0 - Client for Coinbase Pro  https://hackage.haskell.org/package/coinbase-pro-0.7.0.0 (mdunnio)
16:05:14 * hackage coinbase-pro 0.7.1.0 - Client for Coinbase Pro  https://hackage.haskell.org/package/coinbase-pro-0.7.1.0 (mdunnio)
16:10:32 <topos> phadej what can be done about the `Generic` instance for `NonEmptyVector`? I notice edwardk's nonempty list also derives it (along with read as well), but I admit I've never written a `Generic` instance by hand before!
16:11:18 <topos> ... or a `Read` instance, now that I think about it
17:06:14 * hackage predicate-transformers 0.6.0.0 - A library for writing predicates and transformations over predicates in Haskell  https://hackage.haskell.org/package/predicate-transformers-0.6.0.0 (edmundnoble)
17:20:44 * hackage sws 0.4.5.0 - A simple web server for serving directories.  https://hackage.haskell.org/package/sws-0.4.5.0 (DerekElkins)
17:46:44 * hackage sws 0.4.6.0 - A simple web server for serving directories.  https://hackage.haskell.org/package/sws-0.4.6.0 (DerekElkins)
17:53:26 <dgtlcmo> does anyone know any companies letting employees use haskell for programming language in commercial products?
17:54:36 <edmundnoble> https://www.reddit.com/r/haskell/comments/6p2x0p/list_of_companies_that_use_haskell/
17:58:36 <dgtlcmo> lots of startup like companies
17:58:50 <dgtlcmo> edmundnoble: on that list
18:03:48 <edmundnoble> Yes, I'd guess because they want to attract top talent
18:04:16 <edmundnoble> Naturally there are a few more mature companies there
18:04:41 <Domains> new site for coding http://godlikelunatics.freeforums.net/
18:05:16 <edmundnoble> Facebook, JP Morgan, Capital IQ, Github, Kaspersky, Prezi, Target, Tesla, those stood out
18:13:38 <dmj`> When I use doctest, it spawns a subprocess that forgets about the C libs I have linked in the parent process.
18:13:47 <dmj`> Is there anyway I can preserve this ?
18:18:29 <jusss> install haskell's packages is so hard on linux
18:18:57 <mmaruseacph2> jusss: what do you mean? stack install/ have proper cabal/stack config
18:20:09 <jusss> mmaruseacph2: stack using AWS and that's not allowed to visit on my country, cabal always build error 'cause of package's version issue,
18:20:46 <jusss> mmaruseacph2: ghc use static libs, and my archlinux use dynamic libs
18:24:14 * hackage language-ats 1.7.6.2 - Parser and pretty-printer for ATS.  https://hackage.haskell.org/package/language-ats-1.7.6.2 (vmchale)
18:28:43 <jusss> except cabal and stack, is there any other tool?
18:37:44 * hackage language-ats 1.7.6.3 - Parser and pretty-printer for ATS.  https://hackage.haskell.org/package/language-ats-1.7.6.3 (vmchale)
19:23:24 <gaze__> hey folks. I'm struggling to build a project that uses language-c-cpp on stack lts-14.11. Stack build succeeds, stack build --profile fails with 'error: invalid argument '-std=c++11' not allowed with 'C'', `clang++' failed in phase `C Compiler'. (Exit code: 1). On macOS Mojave 10.14.4
19:23:57 <gaze__> ah sorry, typo. Inline-c-cpp
19:24:58 <gaze__> bitonic
19:38:39 <EvanR> walder 1998 post to generic java mailing list on the expression problem...  speaks of "higher order type parameters" heh (not higher kinded types) and doesn't mention haskell at all
19:38:45 <EvanR> wadler
19:39:53 <EvanR> it's crazy how much you get from just parametric polymorphism
19:43:11 <gaze__> I even blew out ~/.stack/ and it's repeatable
19:43:27 <gaze__> I'm just not sure what changes between build and build --profile
19:53:04 <gaze__> I guess I might ask... are there any favored techniques for calling C++ stuff from haskell? Seems like language-c-cpp might not even be all that up to date
20:09:58 <jusss> cabal: installdir is not defined. Set it in your cabal config file or use --installdir=<path>
20:10:07 <jusss> where should I set?
20:13:53 <jusss> cabal install slack-api --installdir="/home/john/.cabal/packages"
20:14:14 <jusss> why I still can't import Web.Slack?  this module can't be found
20:14:45 <sclv> jusss: if you just want to depend on it, create a local project
20:14:49 <sclv> that includes it in the dependencies
20:14:59 <sclv> and then its all managed for you
20:15:14 * hackage postgresql-pure 0.1.0.0 - pure Haskell PostgreSQL driver  https://hackage.haskell.org/package/postgresql-pure-0.1.0.0 (kakkun61)
20:15:30 <jusss> sclv: can it be as a system libs?
20:15:44 <sclv> what do you mean "as system libs"?
20:15:48 <jusss> sclv: I mean for many projects
20:15:51 <jusss> no just one
20:16:02 <sclv> if multiple projects depend on it
20:16:07 <sclv> it will be auto-shared between them
20:16:11 <sclv> if its the same version
20:16:16 <sclv> that's all managed for you
20:16:24 <sclv> the reason its asking for an install-dir btw is not for the library
20:16:30 <sclv> its because the lib packages example executables
20:16:39 <sclv> so it expects them to go into some sort of /usr/local/bin or something
20:16:54 <jusss> sclv: what should I use? executables or libs? I saw there're 3 options
20:16:59 <sclv> arguably that's a problem with the package -- it shouldn't package completely sample code as part of the main package
20:17:04 <sclv> for just the lib pass --lib
20:17:20 <Hojourner> Hi all, quick question. Why does  https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #h
20:17:24 <Hojourner> 23:15 [ ccokee          ] [ freusque        ] [ keith[m]        ] [ nisstyre        ] [ sicklorkin      ] [ ybit            ]
20:17:25 <sclv> the exes are sample code. they should never have packaged them
20:17:29 <jusss> sclv: how to create a project and contain it? use cabal init？
20:17:33 <sclv> yes
20:17:37 <sclv> then edit the deps
20:17:47 <sclv> jusss: i assume you have cabal v3?
20:18:24 <jusss> sclv: yeah, I use cabal-install upgrade to v3 from v2, then I deleted v2
20:18:30 <sclv> if so then just cabal build to build the project, cabal repl to bring up a ghci with the packages, etc
20:19:21 <jusss> sclv: now I run cabal init, it pops https://paste.ubuntu.com/p/BDPn45tyf3/
20:19:57 <jusss> sclv: sorry, the create project logic, I have a little confused, every project, I should use cabal init to init and create?
20:20:27 <jusss> it's not like python, in python, I can use pip install what it needs, then I can use them in any projects
20:21:21 <jusss> and the git, I only need to init once, then I can create multiple repos
20:22:07 <sclv> jusss: you get automatic reuse between different projects!
20:22:30 <sclv> you just need to have the projects individually
20:22:36 <jusss> sclv: what should I do now?
20:22:44 <sclv> what step are you at?
20:22:44 * hackage hw-kafka-client 3.0.0 - Kafka bindings for Haskell  https://hackage.haskell.org/package/hw-kafka-client-3.0.0 (alexeyraga)
20:22:56 <sclv> have you inited your project?
20:23:36 <jusss> sclv: I just had run `cabal init' in my home directory, and use cabal installed slack-api
20:23:58 <sclv> ok you want to create a new directory for your project, and run cabal init in there
20:23:58 <jusss> and point --installdir = .cabal/packages
20:24:04 <jusss> ok
20:24:09 <sclv> then once you do that
20:24:13 <sclv> you edit the .cabal file
20:26:32 <jusss> sclv: ok, now what should I set in the MyRobot.cabal, I created a project called MyRobot
20:28:00 <sclv> one sec
20:28:44 <sclv> there should be a build-depends stanza in there
20:29:09 <sclv> add the libs you want to depend on to that stanza
20:29:15 <jusss> ok
20:29:24 <sclv> and add the code you want to work on to the /src directory or the like
20:29:31 <sclv> that should be created for you?
20:29:36 <sclv> if there's none then it goes in the top level dir
20:29:55 <sclv> hs-src-dirs tells you which dir
20:30:28 <sclv> then "cabal build" builds the code. if its an executable, "cabal run" runs it. and "cabal repl" brings up ghci with the libs available
20:30:30 <jusss> sclv: that build-depends: how to split multiple packages? newline or ;
20:30:43 <sclv> comma
20:30:58 <sclv> look at some example cabal files to get a sense
20:30:58 <sclv> https://hackage.haskell.org/package/hw-kafka-client-3.0.0/hw-kafka-client.cabal
20:31:03 <sclv> or whatever
20:34:17 <jusss> sclv: ok then, after I use hs-src-dirs point to /home/john/MyRobot/src, and I `mkdir src' touch src/Main.hs, now cabal repl can import Web.Slack
20:34:31 <sclv> great!
20:34:43 <sclv> there are other ways to do this, but i think this is the best one to teach you
20:34:49 <sclv> since it gets you going with a real project
20:35:26 <jusss> sclv: I feel I'm doing pack  something to a package like that apt or pacman doing
20:35:41 <jusss> sclv: the steps is like that 
20:44:13 <jusss> sclv: another question, should I install that specific package in my project or just in the home directory?
20:45:09 <sclv> with these steps you don't need to install it at all
20:45:09 <jusss> sclv: for example, I create a project MyRobot, and I install slack-api in that MyRobot directory or just install it in the home?
20:45:15 <sclv> cabal will manage it for you automatically
20:45:21 <sclv> that's the advantage
20:45:30 <sclv> and it'll auto-share between different packages automatically too
20:45:46 <sclv> in this workflow you never need to say "install" -- just say what you depend on, and all the deps are managed automatically for you
20:45:57 <jusss> sclv: ok, 
20:47:42 <jusss> sclv: I just need put the package name like "salck-api" into the `build-depends:' in MyRobot.cabal, and cabal will install it, right?
20:47:53 <sclv> ya
20:49:01 <jusss> sclv: except `build-depends:' and `hs-source-dirs:', is there other tags I need to care?
20:49:06 <jusss> to change
20:51:32 <jusss> sclv: another question, after I installed cabla-install, do I need to run cabal init and cabal update at the first time in my home directory?
20:53:19 <sclv> jusss: you don't need to change anything else for now. most other stuff is for developing packages to distribute to others. but you will eventually want to learn how to do that, how to create test-suites, etc
20:53:31 <sclv> also you don't need to run cabal init in the homedir
20:53:36 <sclv> you run it in a project dir to init a project
20:53:41 <sclv> and you can run update anywhere whenever
20:53:50 <sclv> and it just fetches the latest package list from hackage and caches it
20:53:57 <jusss> sclv: that's awesome
20:55:04 <jusss> sclv: that's a question, ghc use static libs, but other system use dynamic libs like archlinux, can I use cabal pack my project to binary and run it on archlinux?
20:55:31 <sclv> not really. you can build a fully statically linked binary, but that's a bit tricky
20:55:45 <sclv> otherwise you should build a binary on whatever the target platform is
20:55:56 <jusss> sclv: that won't be conflicted with that libs in the archlinxu?
20:56:09 <sclv> the fully static one?
20:56:18 <pikajude> it will if it's named the same thing as a system library
20:56:35 <sclv> the fully static one links in at link time
20:56:39 <sclv> that's what static is!
20:56:45 <sclv> dynamic is when it uses the system lib :-)
20:56:54 <pikajude> static is something you don't want near your motherboard
20:56:58 <jusss> sclv: can we pack all the stuff just into one binary file? or with the libs come?
20:57:07 <sclv> that's literally what a static build is
20:57:33 <sclv> it links everything statically at link time into a single file
20:57:48 <sclv> but its only "mostly" static without work, because it dylinks standard things like glibc
20:58:09 <pikajude> how much bigger is an actual fully statically linked binary
20:58:20 <sclv> depends
20:58:30 <sclv> you can also `strip` to cut them down a bit
20:58:37 <jusss> sclv: pikajude but that's how things work on windows, right?
20:58:53 <sclv> windows has both methods too
20:58:54 <pikajude> i don't know anything about windows
20:59:09 <sclv> typically there's a lot of dlls tho -- that's just convention
20:59:58 <jusss> sclv: if I want to pack with full static libs into one binary, did I need to change in the .cabal file?
21:00:16 <jusss> that `cabal build' will output ?
21:01:10 <sclv> i don't know how to do fully static builds. its hard
21:01:12 <sclv> you can google it
21:01:19 <jusss> ok
21:01:20 <sclv> you get "mostly static" by default
21:03:04 <fraktor> I'm working on two different machines that use Debian.  I should be able to build an artifact on one and move it to the other, right? Since they both have similar versions of glibc and so on.
21:03:21 <sclv> yes
21:10:20 <jusss> sclv: another question, do I need to install ghc with cabal?
21:10:28 <pikajude> you can't really do that
21:10:37 <jusss> pikajude: but stack can?
21:10:44 <pikajude> well that's what stack is designed for
21:10:51 <pikajude> i mean, stack uses cabal internally anyway
21:10:51 <pikajude> so
21:11:18 <jusss> pikajude: ok
21:11:49 <jusss> pikajude: which tool you prefer? cabal or stack
21:12:10 <sclv> you install ghc and cabal seperately
21:12:22 <sclv> you can manage installing both with the ghcup tool if you want
21:13:00 <jusss> sclv: but there're some issues on archlinux
21:13:14 <maerwald> jusss: like what
21:13:15 <jusss> sclv: the package ghc and cabal-install 
21:13:18 <sclv> yes. the issue is the archlinux maintainers are awful
21:13:21 <sclv> yes don't use their stuff
21:13:25 <sclv> the maintainers are obstinate and terrible
21:13:36 <sclv> and refuse to listen to the entire haskell dev ecosystem screaming at them
21:13:39 <sclv> just use ghcup
21:13:39 <jusss> maerwald: use cabal to install pacakge there're lots of versions issue of package
21:13:43 <maerwald> ah, I thought there is an issue with ghcup on arch
21:14:18 <jusss> they just maintain dynamic libs
21:14:34 <jusss> and ghc mostly use static libs, which is the problem
21:15:23 <jusss> sclv: ghcup works well on archlinux?
21:15:50 <jusss> now I have to chroot into a debian sid on archlinux for using cabal
21:18:00 <fraktor> I've been using a couple of libraries that make extensive use of <$> and <*>.  Looking at their types in GHCi shows that they're similar but not the same.  What do they do?
21:20:23 <pikajude> imagine you have two values `x` `y` and function `f`
21:20:27 <pikajude> `f x y` calls f with x and y
21:20:51 <pikajude> `f <$> x <*> y` calls f with the "contents" of the Applicatives x and y
21:21:03 <pikajude> > (+) <$> Just 3 <*> Just 4
21:21:05 <lambdabot>  Just 7
21:21:07 <pikajude> > (+) 3 4
21:21:10 <lambdabot>  7
21:21:15 <pikajude> > (+) <$> Just 3 <*> Nothing
21:21:17 <lambdabot>  Nothing
21:23:13 <fraktor> Magic
21:23:36 <pikajude> f <$> x <*> y is equivalent to liftA2 f x y
21:23:38 <pikajude> :t liftA2
21:23:40 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
21:23:49 <fraktor> Oh! Does that mean that <*> and `ap` are the same?
21:23:59 <pikajude> i think they are now, now that Applicative => Monad
21:24:09 <pikajude> they used to mean the same thing but not be equivalent
21:24:09 <fraktor> So <*> is for applicative, and `ap` is for Monad?
21:24:19 <pikajude> yeah, but now ap is just <*> since applicative is a superclass
21:24:30 <pikajude> if they actually do differ in any case that's incorrect behavior
21:24:39 <fraktor> Damn, I'm starting to capitalize Monad like it's a religion
21:24:59 <pikajude> well it's useful to capitalize Monad if you mean the typeclass, because monads in category theory are sort of separate-ish to my understanding
21:26:10 <sclv> jusss: afaik ghcup should work. If it doesn’t then  the maintainers would be interested to know
21:26:54 <sclv> it may need a little messing about to make sure you have tinfo compat etc
21:29:12 <pikajude> stack also downloads and installs GHC
21:29:18 <pikajude> if you use it to build projects
21:41:07 <fraktor> Hmm.  I'm trying to find out how to read a config file (any form will do, JSON or YAML are the likely ones here), and I've heard that ReaderT is good for that, but all the articles I'm finding are poorly written or are doing something different.
21:41:27 <pikajude> ReaderT isn't for reading files
21:41:33 <pikajude> well, not specifically nayway
21:41:38 <pikajude> the name similarity is coincidental
21:42:29 <fraktor> Right. But I've heard that's a good way of passing around configuration without specifically passing it as an argument to every function.
21:42:34 <pikajude> oh
21:42:43 <pikajude> yeah
21:42:46 <jle`> fraktor: some good config file integration in haskell are libraries like yaml (yaml files), dhall (dhall config), aeson (json) and configurator (some specific format)
21:42:54 <pikajude> reader is good for that
21:43:14 <pikajude> a lot of projects i work on end up having some kind of type MonadThingy m = (MonadReader ThingyConfig m, ...)
21:44:48 <pikajude> did you know? Reader is actually equivalent to (->)
21:45:54 <fraktor> I did not, because I've never used Reader.  I have absolutely no idea how to go about doing this; can someone point me in the right direction?
21:46:19 <pikajude> > runReader (do { x <- ask; return (x + 1) }) 10
21:46:22 <lambdabot>  11
21:46:43 <pikajude> > runReaderT (do { x <- ask; liftIO (print (x + 1)) }) 10
21:46:45 <lambdabot>  error:
21:46:45 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M984271762804...
21:46:45 <lambdabot>        prevents the constraint ‘(Show (m0 ()))’ from being solved.
21:46:54 <pikajude> oh fiddlesticks
21:46:56 <pikajude> it's meant to print out 11
21:47:11 <pikajude> have you used any monad transformers fraktor
21:47:33 <jle`> for what it's worth people really never use Reader
21:47:40 <fraktor> Not really no.  All I know is that it's a pretty good way of combining monads, and that lift gets you one monad higher.  Also that liftIO gets you to the IO monad, wherever it lies in the chain.
21:47:43 <pikajude> i use ReaderT all the time
21:47:49 <pikajude> it's great
21:48:17 <pikajude> or well, MonadReader
21:49:05 <fraktor> How can I go about learning these?
21:49:13 <fraktor> Or rather, where should I look for some resources?
21:49:33 <jle`> 'monad transformers step by step' is how i learned how to get into monad transformers
22:02:40 <maerwald> pikajude: except you can have only one ;)
22:02:49 <maerwald> so rather awkward
22:02:53 <yushyin> Me too!
22:03:50 <rotaerk> don't really like ReaderT for providing a common environment
22:04:09 <pikajude> sld ,jak
22:04:12 <pikajude> one what
22:04:14 <pikajude> sorry
22:04:21 <fraktor> rotaerk: What do you prefer?
22:04:37 <maerwald> pikajude: one reader
22:04:42 <pikajude> oh, i see
22:04:56 <maerwald> I don't see how it's useful at all, but ymmv
22:05:05 <pikajude> well, that applies to other transformers if i understand correctly
22:05:06 <jle`> my favorite way to pass configuration is as a parameter to a function
22:05:18 <maerwald> pikajude: which is why transformers are rather inelegant
22:05:24 <jle`> i also like ImplicitParams too heh
22:05:25 <pikajude> indeed
22:05:41 <rotaerk> just seems bad to add extra baggage in every monadic bind just to carry an environment around, when reading from the environment sholudn't need to be sequenced
22:05:43 <jle`> ReaderT can be useful for hijacking 'monad-polymorphic' functions
22:05:56 <rotaerk> like, there's nothing inherently monadic about reading from an environment
22:06:04 <rotaerk> it's just shoehorned into the monad abstraction
22:06:12 <pikajude> ok
22:06:14 <pikajude> what do you use instead
22:06:28 <maerwald> rotaerk: yeah, basically abusing monad instance, so you don't have to add a parameter to your functions 
22:06:29 <fraktor> what is ImplicitParams?
22:06:54 <pikajude> params you dont have to pass explicitly
22:06:58 <maerwald> which is a mildly interesting use case
22:07:08 <jle`> it's an extension that allows you to turn function arguments into 'constraints'
22:07:11 <maerwald> unless you have 5 different params...
22:07:19 <maerwald> but then transformers cannot express that anyway lol
22:07:23 <pikajude> :t show ?x
22:07:24 <lambdabot> (Show a, ?x::a) => String
22:07:25 <rotaerk> I normally just pass things in via parameters explicitly.  however, I do thin reflection might make a better choice than ReaderT if you really want to pass an environment around
22:07:33 <pikajude> oh i see
22:07:40 <rotaerk> that said, reflection is a PITA because you have to carry a type parameter all over the placce
22:07:46 <pikajude> hmm that seems like it could be frustrating
22:07:55 <pikajude> if you need to add to the environment, need to add an extra parameter to every callsite
22:08:23 <rotaerk> like, if you have something that wouldn't normally have a type parameter, you have to wrap it in something that has one (as a phantom type) just so that it unifies with other things
22:08:53 <rotaerk> so I don't really have a satisfying common-environment approach; I just pass stuff in explicitly
22:09:09 <pikajude> i guess with ghc-mod/hie it wouldn't be THAT bad to add an extra param everywhere
22:10:37 <rotaerk> (it's possible I didn't understand how to use reflection *correctly*, and what I said is based on misunderstanding)
22:12:51 <pikajude> i know servant at least has a pretty legitimate use of ReaderT because the handler types are generated based on a bunch of instance resolutions
22:13:08 <pikajude> so if you need to pass some argument into a handler you can't just add a new param without giving up all the nice servant type inference stuff
22:13:20 <pikajude> so instead you transform the wrapper monad m to ReaderT Thing m
22:13:56 <fraktor> That's true, I should have mentioned that I'm using servant in this project.
22:14:06 <rotaerk> yeah I'd use ReaderT to conform to the interface, I suppose, if there wasn't a better option
22:14:08 <pikajude> all things considered i think servant is pretty good
22:14:17 <pikajude> except for the issue of trying to advertise what errors an endpoint can return
22:14:29 <pikajude> it can work for simple usecases though
22:14:53 <fraktor> Which this is.  What would you suggest for more advanced use cases?
22:15:03 <pikajude> doing it all manually with wai, lol
22:15:17 <pikajude> i've never tried to build an advanced rest api in haskell
22:15:45 <fraktor> I mean yeah, you get the most power when you code in assembly directly too.
22:15:49 <pikajude> actually, now that i think of it, i think newer versions of servant might have a different way to work around the passing arguments issue
22:16:01 <pikajude> i definitely don't, i'm too dumb to understand how SSL works
22:16:12 <pikajude> which wai can handle on its own
22:16:31 <jle`> yeah, this is what i meant earlier about using ReaderT to hijack things that are polymorphic for all monads
22:16:45 <pikajude> yeah, if you have a thing that wants a monad, you can use reader for it
22:21:33 <fraktor> I'm way too tired for this. 'Night all
22:25:14 * hackage fficxx 0.5.1 - automatic C++ binding generation  https://hackage.haskell.org/package/fficxx-0.5.1 (IanWooKim)
22:25:17 <rotaerk> an idea occurred to me of another way to do a shared environment
22:25:33 <rotaerk> only works if you have a fixed set of functions that access this environment
22:26:17 <rotaerk> basically immitates OOP
22:28:15 <rotaerk> say you have something you might normally implement as `foo :: X -> ReaderT Env m Y` and `bar :: A -> B -> ReaderT Env m C`
22:29:27 <rotaerk> you can instead do:  data MyFuncs = MyFuncs { foo :: X -> m Y, bar :: A -> B -> m C }
22:30:23 <rotaerk> and then: myFuncsFromEnv :: Env -> MyFuncs; myFuncsFromEnv env = MyFuncs { foo x = ...; bar a b = ... }
22:31:07 <rotaerk> and then when you're wanting to actually use this, use record wildcards to do:  let MyFuncs{..} = myFuncsFromEnv someEnv
22:31:26 <rotaerk> now foo and bar are in scope, with the desired signatures, and have access to someEnv
22:32:03 <rotaerk> (it's kind of like OOP, in the sense that an objecct is a set of functions with a shared closure over some internal state, or if immutable, an internal shared *environment*
22:36:13 <rotaerk> the record wildcards is essential there, otherwise foo's signature becomes `MyFuncs -> X -> m Y` which buys you nothing
22:38:04 <maerwald> just use an effects system :P
22:38:29 <rotaerk> not very familiar with those
22:38:46 <rotaerk> what's a good library for that
22:39:22 <maerwald> last one I looked at is polysemi, but it isn't particularly simple
22:39:36 <maerwald> @hackage polysemy
22:39:36 <lambdabot> http://hackage.haskell.org/package/polysemy
22:40:28 <rotaerk> hmm thanks
22:40:55 <maerwald> but with these things I somewhat feel either go full DSL on your entire code or stick to the well-known methods like mtl
22:41:11 <rotaerk> I remember someone poopoo-ing that library (without me understanding what it was)
22:41:19 <rotaerk> I think their complaint was around practicality
22:43:34 <maerwald> the main interesting thing is how it makes you structure your code
22:43:45 <rotaerk> I should learn that though; making DSLs has generally interested me, but I never really dug into it
22:44:20 <maerwald> I think that's the main reason to use haskell... doing something DSL-ish
22:44:42 <maerwald> Otherwise you're not really facilitating the advantages of the language
22:44:49 <maerwald> And would probably be better off with... C# or something
22:45:07 <rotaerk> lately all my haskell programming has been working with Vulkan, so I'm effectively programming at a C level, but with nicer abstraction capabilities
22:45:43 <rotaerk> though I've been on the lookout for how it might be made better with a DSL
23:00:52 <jle`> rotaerk: what you propose isn't really much different than foo :: Env -> X -> m Y, bar :: Env -> A -> B -> m C
23:01:53 <jle`> i guess the record wildcard makes it cute
23:02:25 <dminuoso> If you have some Generic driven wireprotocol encoding, would you represent some POSIX encoded value rather as UTCTime or as NominalTimeDiff?
23:05:49 <dminuoso> Actually I should probably keep it as NominalTimeDiff, otherwise you might have the wrong expectations (hidden rounding, hidden bounds)
23:10:08 <svipal> hey I swear there used to be a json lib that allowed you to stroll through a jsonvalue like so : s = jsvalue["attr"]["attr2"] 
23:10:16 <svipal> obviously with a different syntax
23:10:23 <svipal> does anyone know if I'm crazy
23:10:36 <svipal> or if it really is something like this
23:11:00 <svipal> or if something like this really exists*
23:11:18 <koz_> @pl \i -> fmap ((`index` i) . f) x
23:11:18 <lambdabot> flip fmap x . (. f) . flip index
23:11:27 <koz_> Lol, such flip.
23:15:10 <jle`> svipal: lens-aeson is pretty close i think
23:15:20 <jle`> s = jsvalue ^? key "attr" . key "attr2"
23:15:36 <jle`> or was it aeson-lens
23:16:11 <c_wraith> it's lens-aeson
23:18:09 <dminuoso> What does aeson-lens actually give you what generating optics for your deserialized values doesnt?
23:18:54 <dminuoso> Ohh! It's for working with unstructured JSON data?
23:18:58 <jle`> yeah
23:18:59 <koz_> dminuoso: A sense of pride and accomplishment. :P
23:19:10 <jle`> it's useful for just dealing with raw json
23:19:26 <jle`> you can even directly lens into a bytestring which is kind of neat
23:20:30 <jle`> "{'a': [1,2,3], 'b': 4}" ^? key "a" . nth 2
23:20:34 <jle`>  => 3
23:20:36 <jle`> or something like that
23:22:02 <dibblego> see also waargonaut
23:27:27 <dminuoso> jle`: In some sense I feel its not good style because it promotes these "loose" and brittle APIs where proper no protocol between two parties is established.
23:27:46 <dminuoso> Though I suppose if you have some nasty undocumented or unstable API, it could be a useful tool.
23:28:30 <jle`> yeah it's useful in all cases where you would deal with just json directly
23:28:34 <jle`> instead of a known type/schema
23:29:31 <c_wraith> I mean...  JSON promotes brittle APIs all by itself.
23:29:56 <dminuoso> c_wraith: Indeed. And in my mind the primary reason is by encoding data into JSON you throw away everything you know about your data, and then have to carefully recover it by parsing and validating it again
23:30:21 <dminuoso> Im operating a self written RADIUS Server here, and its really refreshing to have an explicit wire protocol...
23:42:23 <svipal> thanks jle` !
23:46:33 <jle`> np!
23:55:44 * hackage prettyprinter 1.4.0 - A modern, easy to use, well-documented, extensible pretty-printer.  https://hackage.haskell.org/package/prettyprinter-1.4.0 (quchen)
