00:04:11 * hackage concurrent-hashtable 0.1.7 - Thread-safe hash tables for multi-cores!  https://hackage.haskell.org/package/concurrent-hashtable-0.1.7 (PeterRobinson)
01:52:21 <lavalike> :t ((&&&) . ($ fst)) <*> ($ snd) $ fmap
01:52:23 <lambdabot> Functor f => f (b, b) -> (f b, f b)
02:57:52 <sicklorkin> :t (***)
02:57:54 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
03:12:20 <brisad> I get -Wtype-defaults warning for `i` in this function: `printTerms :: [Int] -> IO (); printTerms = mapM_ putStrLn . zipWith (\i y -> "Term " ++ show i ++ ": " ++ show y) [0..]` How can I avoid it?
03:13:12 <lavalike> brisad: [0::Int..]
03:18:23 <brisad> I added the TypeOperators feature, but I still get "Not in scope: type constructor or class ‘Int..’" when I try that
03:18:40 <lavalike> I don't think you need extensions for that
03:19:00 <lavalike> oh you need a space, my bad
03:19:06 <lavalike> > take 10 [0::Int ..]
03:19:09 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
03:19:34 <brisad> Oh, perfect! Thanks lavalike
03:19:42 <lavalike> I wonder if it's parsing it as module "Int" dot "." operator dot "." or something like that hehe
04:20:42 * hackage ekg-influxdb 0.2.0.0 - An EKG backend to send statistics to influxdb  https://hackage.haskell.org/package/ekg-influxdb-0.2.0.0 (ondrej)
04:45:46 <maralorn> I‘d really love a thorough comparision of different effect libraries with more than just one toy example.
04:46:23 <maralorn> isovector talked about some weird semantic problems they ran into with polysemy.
04:54:31 <maerwald> Don't think there is one. Even if someone started to use one of them extensively in production, all you'd get is a comparison with mtl probably
04:56:49 <gobby> I'm modifying some `servant` code to be "AWS Lambda" compatible. My question is I'm not sure what concurrency primitive to use. I know the lambda function (after being instantiated) can hang around to process subsequent requests. This leads me to think using an IORef to feed requests to my servant application would be a bad idea.
04:56:57 <gobby> And that I should use an MVar instead.
05:23:59 <emizan> how can I define a data structure made of 2 numbers, with a restriction: the second number is greater than the first?
05:25:20 <lavalike> emizan: good question, I don't think there's a direct way to do that
05:27:26 <Rembane> emizan: If you use a smart constructor you can uphold the invariant in that function. 
05:28:41 <WangJi> Guys how can i get the quadratic residue x² = q mod m with my function func :: Integer -> Integer -> Bool
05:30:43 <hpc> without knowing what func is, i would say something like this:
05:30:58 <hpc> if func 0 0 then quadraticResidue x q m else quadraticResidue x q m
05:30:59 <hpc> :P
05:31:50 <hpc> what is func here?
05:31:52 <hpc> @where paste
05:31:52 <lambdabot> https://gist.github.com
05:32:00 <hpc> ^ if it's longer than a line or two
05:32:40 <lavalike> I see at least 2 problems: one is how do you find quadratic residues in finite fields, the other is you might know how to do it but don't know how to encode it in haskell?
05:34:08 <WangJi> i have two variables A and B, A is the q and B is the m in the function q mod m. I know that x is {0..n-1} so how can i test x² == q mod b for every vcalue in the list {0.. n-1]
05:34:24 <dibblego> @type munzip -- koz_ 
05:34:26 <lambdabot> error:
05:34:26 <lambdabot>     • Variable not in scope: munzip
05:34:26 <lambdabot>     • Perhaps you meant one of these:
05:34:35 <Zemyla> @let import Control.Monad.Zip
05:34:37 <lambdabot>  Defined.
05:34:37 <dibblego> http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-Zip.html
05:34:41 <Zemyla> :t munzip
05:34:42 <lambdabot> MonadZip m => m (a, b) -> (m a, m b)
05:34:45 <dibblego> thanks
05:34:50 <lavalike> dang
05:35:32 <Zemyla> I wish it also had munzipWith, MonadZip m => (a -> (b, c)) -> m a -> (m b, m c).
05:49:10 <dmwit> > 3^2 `mod` 2 == 7 `mod` 2 -- WangJi
05:49:12 <lambdabot>  True
05:51:30 <dmwit> There is also the Mod type from arithmoi. I can't demonstrate in lambdabot, but it would look something like `3^2 == (7 :: Mod 2)`.
06:33:41 * hackage bencoding 0.4.5.2 - A library for encoding and decoding of BEncode data.  https://hackage.haskell.org/package/bencoding-0.4.5.2 (SergeyVinokurov)
07:15:56 <_deepfire> Why isn
07:16:22 <_deepfire> Why isn't SomeTypeRep self-evident in the sense that it essentially represents a Typeable instance?
07:16:38 <_deepfire> currently, SomeTypeRep :: forall k (a :: k). !(TypeRep a) -> SomeTypeRep
07:17:02 <merijn> _deepfire: What do you mean "self-evident"?
07:17:03 <_deepfire> but why not, SomeTypeRep :: forall k (a :: k). Typeable a => !(TypeRep a) -> SomeTypeRep
07:18:30 <merijn> That seems like something that'd be covered by the paper on the current Typeable design? (Although I can't remember the name of that)
07:19:17 <_deepfire> merijn: interesting, thanks!
07:20:35 <_deepfire> I was trying to figure out how to use 'Data.Reflection.reifyTypeable' to essentially restore that dictionary from a given SomeTypeRep
07:21:23 <_deepfire> ..but then it struck me how unnecessary that could've been..
07:32:12 <_deepfire> merijn: is it "A reflection on types", 2016?
07:38:19 <FacultiesofMind>  
07:40:03 <dmwit> _deepfire: Why bother with `Typeable a =>` when all that allows you to do is get a `TypeRep a` anyway?
07:40:37 <fendor> what is a weak finalizer thread? Currently looking at some output produced by ghc-events-analyzer and reports like 100 threads with the name "weak finalizer thread"
07:41:07 <dmwit> (I guess because maybe some API thing you want to use has a Typeable constraint?)
07:41:13 <_deepfire> dmwit: to recover a context that is required by other code, yes
07:41:32 <dmwit> You could write your own replacement for SomeTypeRep.
07:41:57 <dmwit> data DeepFireTypeRep where DeepFireTypeRep :: Typeable a => DeepFireTypeRep
07:42:23 <_deepfire> dmwit: one problem is that wouldn't have the instances that SomeTypeRep has
07:42:47 <_deepfire> dmwit: like, for example, Codec.Serialise.Serialise
07:43:10 <dmwit> Does the Serialise instance also offer deserialization?
07:43:23 <_deepfire> it does, yes
07:43:36 <dmwit> Okay. You cannot deserialize to a Typeable dictionary in a sane way.
07:43:58 <dmwit> So if SomeTypeRep were the way you wanted, it wouldn't have been possible to write that instance in the first place.
07:44:13 <_deepfire> But why not, it's tantalisingly close to being self-evident.
07:44:35 <_deepfire> It only formally isn't..
07:44:38 <dmwit> To get back a Typeable dictionary, you need to do instance search. Which means, in practice, having a complete description of the universe of types you wish to be able to deserialize.
07:44:52 <dmwit> Instance search is a compile-time thing. It doesn't exist at runtime.
07:45:05 <dmwit> So to have it at runtime, you must write it yourself.
07:45:28 <_deepfire> instance search shouldn't be needed in case of SomeTypeRep, that's the whole point!
07:45:30 <dmwit> (Or include ghc with your app. This is also possible; see the ghc package. There are wrappers that are more convenient as well, like mueval and friends.)
07:45:43 <dmwit> _deepfire: Right, in the case of SomeTypeRep it's not needed, because there's no dictionary.
07:45:54 <dmwit> Which is *my* whole point.
07:46:15 <_deepfire> you insist on being formally correct, of course : -)
07:47:31 <_deepfire> But I hope one can agree that SomeTypeRep is, essentially, the instance.
07:47:43 * dmwit nods
07:47:51 <dmwit> Unfortunately, "essentially the instance" is not "the instance".
07:48:00 <_deepfire> Precisely.
07:48:08 <dmwit> And it would be incredibly unsafe to offer an API that let it be.
07:48:29 <_deepfire> now, that is interesting!
07:48:39 <_deepfire> why do you think it would be unsafe?
07:48:42 <dmwit> For exactly the same reasons SomeTypeRep and TypeRep a do not have Read instances.
07:49:12 <dmwit> ...because it would let unscrupulous programmers like _deepfire invent a Typeable dictionary out of thin air. ^_^
07:50:23 <dmwit> In fact... I'm really suspicious of Codec.Serialise now.
07:50:59 <dmwit> Oh ho!
07:51:06 <dmwit> instance Typeable a => Serialise (TypeRep a)
07:51:18 <dmwit> So you have the Typeable dictionary around already anyway.
07:51:29 <_deepfire> For TypeRep -- yes.
07:51:42 * hackage constrained 0.1 - Generalization of standard Functor, Foldable, and Traversable classes  https://hackage.haskell.org/package/constrained-0.1 (SergeyVinokurov)
07:51:48 <dmwit> I'd honestly just write `instance Typeable a => Serialise (TypeRep a) where encode = pure (); decode = pure (SomeTypeRep typeRep)`.
07:51:55 <dmwit> And you can do this for DeepFireTypeRep, too.
07:52:42 * hackage constrained-platform-instances 0.1 - Instances of standard platform types for 'constrained' package.  https://hackage.haskell.org/package/constrained-platform-instances-0.1 (SergeyVinokurov)
07:53:52 <_deepfire> https://github.com/well-typed/cborg/blob/master/serialise/src/Codec/Serialise/Class.hs#L1224
07:56:51 <dmwit> I see. It uses the Type.Reflection.Unsafe module.
07:57:13 <dmwit> And despite the fact that it passes this unsafe-ness on to the user, the documentation doesn't mention this fact. =(
07:57:40 <dmwit> I think it would be okay to offer `TypeRep a -> (Typeable a => c) -> c` from Type.Reflection.Unsafe.
07:58:22 <dmwit> I suspect a patch to offer this would be accepted. But I think it would essentially have to be built into the compiler.
07:58:53 <dmwit> But you should also complain to the cborg folks that their documentation isn't carefully highlighting the risks of this instance.
08:02:34 * dmwit tries to form a crisp description of what's unsafe
08:04:04 <_deepfire> merijn: "A reflection on types" doesn't seem mention SomeTypeRep at all.
08:05:18 <dmwit> I mean, the start of the unsafety is that you can serialise, change some data definitions, then deserialise and get a "wrong" wrapped TypeRep. But then, it's not super clear to me how to coerce the compiler into using that wrong information to do something bad. Which makes me wonder how you could use the right information to do anything good?
08:05:23 <dmwit> What is the use case for this instance?
08:12:11 * hackage servant-websockets 2.0.0 - Small library providing WebSocket endpoints for servant.  https://hackage.haskell.org/package/servant-websockets-2.0.0 (moesenle)
08:36:10 <nshepperd> this seems roughly equivalent to serialising a string containing the name of the type
08:39:26 <nshepperd> so basically you'd serialise (SomeTypeRep (typeRep @Int), 5), then when deserialising you'd compare the typerep against a list of types, including Int, and that would tell you to attempt to deserialise the second thing as an Int
08:41:53 <nshepperd> I guess another possible use case is you could write a Serialise instance for your data type that first serialises the typeRep, so that when decoding you can first validate the typeRep and if it's wrong throw an error like "wrong file, you dummy, this is a RocketShipSchematic not a CakeRecipe"
08:42:32 <afreakk> hi, im pretty newb, is there a nicer way of doing what im doing here? https://kopy.io/BgpoK#NVdArNAVvQOVJo
08:43:13 <nshepperd> instead of getting some inscrutable parsing error where it says "expected uint8, got ..."
08:43:23 <merijn> afreakk: Well, you could lift the functions directly so that they're "StateT GameState IO ..."
08:43:52 <merijn> afreakk: Or use "MonadIO m => GameState -> m GameState", which is probably more generic
08:44:14 <Ariakenom> fendor: I suppose its a thread made to run the finalizer
08:44:42 * hackage flexible-defaults 0.0.3 - Generate default function implementations for complex type classes.  https://hackage.haskell.org/package/flexible-defaults-0.0.3 (PeterSimons)
08:45:14 <afreakk> ah merijn, could you show how that would look? 
08:45:48 <fendor> Ariakenom, yeah, I just dont know where all these weak pointers are coming from, but I suppose it is alright
08:47:03 <nshepperd> (it's a bit more advanced than serialising the name of the type in that it includes the package and module name, but that also makes it less compatible. so maybe just encoding the name would be better)
08:58:12 * hackage proto-lens 0.6.0.0 - A lens-based implementation of protocol buffers in Haskell.  https://hackage.haskell.org/package/proto-lens-0.6.0.0 (JudahJacobson)
08:58:53 <irc27313> :t id
08:58:55 <lambdabot> a -> a
08:59:12 * hackage proto-lens-optparse 0.1.1.6, proto-lens-arbitrary 0.1.2.8, proto-lens-setup 0.4.0.3, proto-lens-protoc 0.6.0.0, proto-lens-runtime 0.6.0.0 (JudahJacobson)
09:13:41 * hackage stm-io-hooks 1.1.1 -   https://hackage.haskell.org/package/stm-io-hooks-1.1.1 (PeterRobinson)
09:16:12 * hackage stm-io-hooks 1.1.2 - Launch your IO-actions from within the STM monad  https://hackage.haskell.org/package/stm-io-hooks-1.1.2 (PeterRobinson)
09:19:21 <dmwit> nshepperd: If you have a list of types lying around, then _deepfire's question about how to make an instance doesn't make sense, because you can just use that list.
09:20:01 <dmwit> nshepperd: Same objection about the second use.
09:25:32 <nshepperd> i mean, the only thing you can do with a Typeable constraint or a TypeRep is compare it to another one
09:26:15 <nshepperd> so any usage of Typeable boils down to a list of types at some level
09:27:43 <nshepperd> anyway, the function _deepfire is looking for exists and is withTypeable https://hackage.haskell.org/package/base-4.12.0.0/docs/Type-Reflection.html#v:withTypeable
09:29:59 <nshepperd> case mysometyperep of { SomeTypeRep typerep -> withTypeable typerep (... do stuff ...) }
09:48:12 * hackage vector-rotcev 0.1.0.0 - Vectors with O(1) reverse  https://hackage.haskell.org/package/vector-rotcev-0.1.0.0 (Bodigrim)
09:50:39 <jzyamateur> What does one call the `<-` operator typically used in a do block ?
09:52:44 <merijn> jzyamateur: It's not an operator, it's syntactic sugar for >>= (which is usually called "bind")
09:52:47 <c_wraith> are you looking for a name, or a way to read it when discussing code out loud with other people who know haskell?
09:52:49 <sm[m]> good question. "Bind current monadic state to" ? Or just "bind" ?
09:53:22 <merijn> sm[m]: Only for very loose definitions for current and state :p
09:53:25 <jzyamateur> both, how do you read it out loud?
09:53:46 <c_wraith> unless there's ambiguity from using State, I'd probably say "gets"
09:53:52 <c_wraith> or maybe "from"
09:55:13 <jzyamateur> also how do you think about your code when you gets/bind from an list e.g. `k <- [1..4]` like a for-each it seems. but then later combined in some way?
09:55:31 <c_wraith> it's the same operation as concatMap
09:55:48 <jzyamateur> I think the container analogy for structure is not very intuitive in case of lists...
09:56:16 <c_wraith> I mean, the less you use analogies the better.  :)
09:57:17 <jzyamateur> it is hard to visualize what the code would be doing, 
09:57:41 <jzyamateur> if we ignore the container analogy.
09:58:59 <merijn> honestly, the answer to "how would you read it aloud" is just that I wouldn't
09:59:37 <merijn> jzyamateur: With the container analogy it's also hard to visualise what, say, "IO Int" would be doing :)
09:59:59 <rotaerk> yeah the way I read code out loud is "this" *points finger at code*
10:00:19 <jzyamateur> When IO comes, I visualize There is some side-effect needed to bring in that Int
10:00:50 <jzyamateur> merijn I got your point
10:01:03 <jzyamateur> We have to spend time with each monad/structure respectively
10:01:11 <jzyamateur> to understand their own weird semantics
10:01:24 <jzyamateur> the only thing that stays same across are the types and laws
10:02:12 <[exa]> IO additionally carries the slightly specific RealWorld trick
10:09:24 <c_wraith> That's just a GHC implementation detail.  IO's semantic model doesn't need it.
10:11:45 <c_wraith> http://comonad.com/reader/2011/free-monads-for-less-3/  see "Who Needs the RealWorld?"
10:43:01 <monochrom> GHC's RealWorld is a coding trick not a universal truth.
10:43:47 <maerwald> We should just never speak of it
10:44:42 * hackage ats-pkg 3.3.0.0 - A build tool for ATS  https://hackage.haskell.org/package/ats-pkg-3.3.0.0 (vmchale)
10:45:16 <dminuoso> monochrom: Furthermore its a misleading truth. Its only value is its implications of inside the type system. 
10:45:37 <dminuoso> Trying to think of IO as "having to do with RealWorld" will give you headaches if you think about forkIO.
10:47:47 <monochrom> It is a phantom type for the following: They want to re-use the code generator they're already using for lazy functional code, but the problem is the code generator would feel free to re-order things, but you don't want to re-order your getLines and putStrLns, so add a phantom type to express phantom data dependency to force the code generator to respect order.
10:48:29 <monochrom> RealWorld doesn't even have a representation by the time you hit cmm.
10:49:25 <dminuoso> monochrom: The thing though, we have that dependency in bind to begin with.
10:49:34 <dminuoso> % :t (>>=)
10:49:34 <yahb> dminuoso: Monad m => m a -> (a -> m b) -> m b
10:49:49 <monochrom> That dependency disappears if you set m = Identity.
10:50:08 <c_wraith> that dependency also disappears when you use (>>)
10:50:11 <monochrom> Preserve that dependency by setting m = State Something
10:50:42 <dminuoso> monochrom: The dependency is still there with m = Identity.
10:51:44 <dminuoso> The RealWorld trick is used because GHC secretly ties effects into the evalutation of values, so its merely an artifact of this particular implementation of effects.
10:52:03 <monochrom> Consider the expression "(const 0) x".  That would be "x >>= const 0" when m = Identity.  The code generator will recongize the independence from x.
10:53:27 <monochrom> And for arbitrary "f x" aka "x >>= f", the code generator may, in the name of code optimization, partly evaluate x first or partly evaluate f first or any mixture.
10:54:02 <monochrom> Well yes "tie effects into evaluation" is my "re-use the code generator designed for lazy functional code".
10:54:21 <monochrom> If you untie effects from evaluation you write a 2nd code generator.
10:56:13 <rotaerk> hmm... should I put my assimp bindings in the Graphics or Codec namespace...
11:00:42 * hackage sets 0.0.6.2 - Ducktyped set interface for Haskell containers.  https://hackage.haskell.org/package/sets-0.0.6.2 (athanclark)
11:00:49 <dminuoso> monochrom: Well sure, but the dependency is still there in the form of 
11:00:50 <dminuoso> % :t (%)
11:00:50 <yahb> dminuoso: Integral a => a -> a -> Ratio a
11:00:52 <dminuoso> % :t ($)
11:00:52 <yahb> dminuoso: (a -> b) -> a -> b
11:01:04 <dminuoso> monochrom: You cant get to `b` without actually applying that thing.
11:01:24 <dminuoso> The lack of Identity means the optimizer can have fun.
11:01:33 <dminuoso> Err, *the case of Identity
11:02:02 <wildtrees[m]> Could I use a trick similar to Codensity to make a list like type that always associates an underlying append to the right?
11:03:02 <c_wraith> wildtrees[m]: you could.  the type is [a] -> [a]
11:03:45 <c_wraith> wildtrees[m]: https://hackage.haskell.org/package/dlist  has it packaged up, but it's rarely less work than just doing it by hand.
11:04:15 <dminuoso> rotaerk: Going by some of the 3d format packages, Id say Graphics.Format is the most common tree.
11:04:31 <dminuoso> Based on looking through hackage for a short moment.
11:06:12 <monochrom> We're in violent agreement.  But your description doesn't address c_wraith's >>
11:08:40 <wildtrees[m]> Thank you c_wraith . I have heard of difference lists before
11:09:36 <dminuoso> monochrom: I think (>>) is a really interesting case. The sequentiality comes from the requirement of coherent Monad/Applicative instance.
11:10:02 <c_wraith> that's not a thing the compiler knows about or enforces
11:10:21 <c_wraith> (and there are libraries that intentionally break it)
11:14:57 <rotaerk> seems to be a mix; for instance "wavefront" is in Codec.Wavefront
11:16:21 <dminuoso> rotaerk: Collada and STL (I think it was) are in Graphics.Format
11:16:35 <rotaerk> ah
11:29:05 <entel> hi. i installed lambda bot but where do i find instructions to get it into my irc channel?
11:32:08 <geekosaur> there's a file online.rc in the distribution with the commands that take it online. you'll need to edit it to use a distinct name and change the channels it connects to. (admittedly I have not looked to see if it still has the information used by the one in here, or maybe has placeholders now)
11:32:40 <entel> thanks
11:33:15 <[exa]> wow lambdabot COMMAND file apparently contains command called "yhjulwwiefzojcbxybbruweejw"
11:33:28 <geekosaur> looks like it's still the default. you will need to edit it, and in particular the list of admins
11:33:40 <[exa]> (looking at http://code.haskell.org/lambdabot/COMMANDS )
11:33:50 <geekosaur> there's a story behind that. in the old days, the @run command used a temporary binding for the result
11:34:19 <geekosaur> which was originally v, then that long thing, then they started generating fresh names because people were finding and abusing the binding because bindings are recursive in Haskell
11:34:51 <geekosaur> so @v and @yhjulwwiefzojcbxybbruweejw show some examples of things people tricked lambdabot intoo doing (none of them all *that* interesting, but)
11:35:51 <[exa]> ok now that's a good story, thanks :
11:35:53 <[exa]> :]
11:38:47 <geekosaur> hm, nobody adopted my alternative COMMANDS, granting it's missing many of the useful ones in this lb (didn't use e.g. the haskell plugins)
11:38:55 <geekosaur> but I think I had the only docs for the admin commands
11:40:26 <geekosaur> I don't run a bot any more but someone should really adopt https://users.ece.cmu.edu/~allbery/lambdabot/COMMANDS.more
11:40:33 <geekosaur> (also not at CMU any more)
11:41:08 <entel> ok i edited my online.rc
11:44:02 <entel> i guess im supposed to call irc-connect somehow
11:44:09 <entel> not sure what to do but i gotta leave thanks guys
11:45:05 <geekosaur> if you have the lb console up, 'rc online.rc'
11:45:57 <geekosaur> and look at the admin commands in that link I posted; it says what those various commands do, to the extent I was able to unravel them with only the code to look at and no docs
11:46:08 <geekosaur> which is why I wrote it, for myself
11:56:04 <_deepfire> nshepperd: thank you a lot!
11:57:17 <_deepfire> curiously, 'withTypeable' is Type.Reflection, not Type.Reflection.Unsafe
11:58:15 <_deepfire> So, apparently, it's not considered dangerous to "invent a Typeable dictionary out of thin air".
12:05:46 <geekosaur> iirc that's because they always exist for internal use, so it can always get at a valid one?
12:07:54 <geekosaur> rather, can always generate the name of a valid one
12:09:47 <nshepperd> it's because you can't generate an invalid 'TypeRep a' in the first place (without using unsafe stuff)
12:14:36 <nshepperd> (an example of an invalid TypeRep would be 'unsafeCoerce (typeRep :: TypeRep Int) :: TypeRep String' -- this claims to be a TypeRep of String, but matches as equal to typeRep of Int, which lets you get Int ~ String)
12:15:53 <nshepperd> however, the TypeRep you get out of a SomeTypeRep is always valid, because the existential type variable means it doesn't claim to be a TypeRep of anything in particular
12:28:36 <koz_> I have need of something of type (i -> m a) -> (i -> m b) -> (a -> b -> m c) -> i -> m c. I guess m needs to be a Monad, but what am I looking for?
12:29:48 <Rembane> :t (>=>)
12:29:49 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
12:30:05 <Rembane> But one more...
12:30:11 <Rembane> :t liftM2
12:30:13 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:30:26 <heatsink> It looks like monadic on
12:30:27 <heatsink> :t on
12:30:28 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
12:30:28 <koz_> So wait, I gotta lift fish?
12:30:57 <koz_> :t liftM (>=>)
12:30:59 <lambdabot> (Monad m1, Monad m2) => m1 (a -> m2 b) -> m1 ((b -> m2 c) -> a -> m2 c)
12:31:33 <koz_> I guess I could do-notation this...
12:31:47 <nshepperd> lift fish to grow strong...
12:31:57 <Rembane> Need big fish for that
12:32:13 <nshepperd> @hoogle f a -> f b -> (a -> b -> c) -> f c
12:32:14 <lambdabot> No results found
12:32:39 <Rembane> koz_: You can do it in smaller steps
12:32:51 <koz_> Rembane: Nah, I'm gonna be lazy and use do-notation. :P
12:33:36 <Rembane> koz_: ^^
12:33:40 <heatsink> :t \f g h i -> join $ liftM2 h (f i) (g i)
12:33:42 <nshepperd> anyway it's flipped liftA2
12:33:42 <lambdabot> Monad m => (t -> m a1) -> (t -> m a2) -> (a1 -> a2 -> m a) -> t -> m a
12:33:55 <koz_> :t flip liftA2
12:33:56 <lambdabot> Applicative f => f a -> (a -> b -> c) -> f b -> f c
12:34:17 <koz_> nshepperd: Thanks!
12:40:44 <koz_> While I'm here - is there an elegant way to write (a -> b -> c) -> ((d, a), (e, b)) -> ((d, e), c)?
12:40:59 <koz_> s/write/implement something of signature/
12:45:34 <bor0> :t \g ((d, a), (e, b)) -> ((d, e), g a b)
12:45:36 <lambdabot> (t1 -> t2 -> b1) -> ((a, t1), (b2, t2)) -> ((a, b2), b1)
12:45:40 <bor0> how about ^ koz_ 
12:46:08 <koz_> bor0: That's pretty much what I came up with.
12:46:23 <bor0> looks good to me
12:46:57 <nshepperd> you probably shouldn't use \f -> biliftA2 (,) f
12:47:44 <pja> :t biliftA2
12:47:45 <lambdabot> error:
12:47:45 <lambdabot>     • Variable not in scope: biliftA2
12:47:45 <lambdabot>     • Perhaps you meant ‘liftA2’ (imported from Control.Applicative)
12:48:31 <nshepperd> % import Data.Biapplicative
12:48:31 <yahb> nshepperd: 
12:48:54 <heatsink> @let transposeTuple ((a, b), (c, d)) = ((a, c), (b, d))
12:48:55 <lambdabot>  Defined.
12:48:57 <nshepperd> :t (\f -> biliftA2 (,) f) :: (a -> b -> c) -> (d, a) -> (e, b) -> ((d, e), c)
12:48:59 <lambdabot> error:
12:48:59 <lambdabot>     • Variable not in scope:
12:48:59 <lambdabot>         biliftA2
12:49:05 <nshepperd> % :t (\f -> biliftA2 (,) f) :: (a -> b -> c) -> (d, a) -> (e, b) -> ((d, e), c)
12:49:05 <yahb> nshepperd: (a -> b -> c) -> (d, a) -> (e, b) -> ((d, e), c)
12:50:29 <koz_> Wait, biliftA2 is a thing? Woah.
12:50:42 <jumper149> Hi, what symbols can used for infix data constructors?
12:51:15 <koz_> Anything starting with : I think.
12:51:18 <pja> When would you use a bifunctor ?
12:51:19 <koz_> (well, aside from :: for obvious reasons)
12:51:29 <jumper149> I tried :_ and it doesn't compile
12:51:30 <heatsink> > let f g t = fmap (uncurry g) (transposeTuple t) in f (++) ((1, 2), ("a", "b"))
12:51:33 <lambdabot>  error:
12:51:33 <lambdabot>      • Could not deduce (Num [Char]) arising from the literal ‘2’
12:51:33 <lambdabot>        from the context: Num a1
12:51:48 <koz_> pja: I am using them a lot right now.
12:52:06 <koz_> (although to be fair, I'm using bitraversables, which are technically bifunctors)
12:52:36 <pja> Sure.
12:52:40 <heatsink> > let f g t = fmap (uncurry g) (transposeTuple t) in f (++) ((1, "a"), (2, "b"))
12:52:44 <lambdabot>  ((1,2),"ab")
12:52:45 <heatsink> ^ koz_
12:53:03 <koz_> heatsink: Yeah, that works too, thanks!
12:53:12 <koz_> nshepperd, as ever, is ready with the obscure base functions. :P
12:53:51 <nshepperd> I have never actually used bifunctor :p
12:55:09 <koz_> :t uncurry
12:55:10 <lambdabot> (a -> b -> c) -> (a, b) -> c
12:59:27 <rotaerk> hmm if I have pattern synonyms defined for flags, like `pattern MY_FLAG = Flags 0x1`, is there a way to define a pattern that is the union of multiple flags without just hard-coding the number resulting from their union
12:59:59 <rotaerk> `pattern COMBINATION = MY_FLAG1 .|. MY_FLAG2 .|. MY_FLAG3` obviously doesn't work
13:02:32 <heatsink> I want to run a linter or code formatter on a cabal project.  Should I somehow use cabal to do it?
13:03:00 <f-a> heatsink: I personally just keep the relevant hlint invocation in a .sh file
13:09:21 <geekosaur> rotaerk, I suspect you'd need to use TH to generate the pattern synonym
13:09:42 <geekosaur> and beware staging restrictions, which might scuttle that idea
13:14:19 <rotaerk> hmm k
13:14:40 <rotaerk> I decided there's not much point in these being pattern synonyms...
13:15:04 <rotaerk> since you're not likely to pattern match a bitmask on a particular flag
13:15:46 <nshepperd> you can use ViewPatterns in pattern synonyms
13:17:02 <nshepperd> i assume there's some way to do it with that
13:17:35 <rotaerk> maybe I could do something like "(blah .|. blah .|. blah ==) -> True"
13:20:50 <nshepperd> bitmasks are conceptually just sets of flags though
13:23:19 <nshepperd> so i guess if I was going to pattern match on them maybe i'd do something like 'pattern MY_FLAG1 otherFlags = (\x -> (hasMyFlag1 x, deleteFlag1 x)) -> (True, otherFlags)'
13:23:55 <rotaerk> hmm that could be cool
13:24:01 <nshepperd> so pattern matching on MY_FLAG1 checks that it is included and returns the rest of the flags
13:25:12 <nshepperd> 'MY_FLAG1 (MY_FLAG2 (MY_FLAG3 _)))' to pattern match on all three being present
13:25:38 <nshepperd> or something
13:26:14 <rotaerk> interesting idea
13:27:42 * hackage proto-lens-protobuf-types 0.6.0.0 - Basic protocol buffer message types.  https://hackage.haskell.org/package/proto-lens-protobuf-types-0.6.0.0 (JudahJacobson)
13:33:46 <nshepperd> i guess it's a bit of machinery for something that is ultimately not really any more usable than 'func flags | hasFlags [MY_FLAG1, MY_FLAG2, MY_FLAG3] flags = ...'
13:41:19 * geekosaur is somewhat amused that Haskell has "the C enum problem" after a fashion
13:41:28 <geekosaur> then again most languages have some form of it
13:43:46 <slack1256> What is "the C enum problem"?
13:45:40 <geekosaur> that it's painful to defien bitmasks that way; one ends up using an int and #define instead
13:46:01 <geekosaur> or other slutions that ignore the language feature one would expect to be useful
13:46:35 <slack1256> Oh I didn't read the previous comments, got it.
13:47:18 <geekosaur> sadly you also can't reliably use bitfields, since (a) combining them is even more painful (b) and how they work is not defined, so if you need to match up with an external source you're out of luck without lots of nonportable hacks
13:50:37 <heatsink> What do you mean, combining bitfields is painful?
13:51:52 <nshepperd> hmm... data Flags = Flags { flag1, flag2, flag3 :: Bool };   myfunc Flags{..} | flag1 && flag2 = doSomething
13:52:37 <geekosaur> well, it's less convenient when they're struct eleemnts instead of values. (still talking C)
13:53:13 <heatsink> Does GHC pack unpacked bool fields into bits?
13:53:43 <geekosaur> not by default that I'm aware of
13:54:36 <koz_> heatsink: Very likely no.
13:54:58 <heatsink> Well, bitfields aren't first-class values.  They only exist as struct members, and they automatically convert to/from integers when you make faces at them
13:55:02 <koz_> How does GHC generate code for sum types?
13:55:22 <koz_> Is there some kind of implicit branching involved?
13:55:53 <heatsink> The first word of a type points to a type descriptor.  For a sum type, the type descriptor says which element of the sum it is.
13:56:04 <merijn> koz_: Usually as numeric tags (for different constructors)
13:56:05 <koz_> heatsink: Ah, tagged union?
13:56:09 <heatsink> right
13:56:37 <merijn> There's no requirement it does that, though (although I'm not entirely sure if GHC uses different strategies too)
13:56:40 <heatsink> Some data is also encoded in the low bits of the pointer, which makes it faster in the common cases
13:57:05 <koz_> So that means a pattern match on a sum type goes 'if the tag is x, do this, else if the tag is y, do that, ...'?
13:57:18 <heatsink> right
13:57:21 <merijn> I have some vague memory that it did, but I'm not sure
13:57:33 <koz_> OK, thanks.
14:11:10 <monochrom> koz_: https://github.com/takenobu-hs/haskell-ghc-illustrated
14:11:15 <nshepperd> as i recall, under the Bool constructor is just a plain old Word#
14:11:24 <nshepperd> so a whole 64 bits
14:11:35 <koz_> monochrom: Thanks!
14:11:43 <monochrom> It is way more interesting than that.
14:12:51 <monochrom> And/Or a way longer story.
14:14:28 <nshepperd> oh wait what am i talking about, it's an adt
14:15:00 <nshepperd> getting it mixed up with Word8 (which is, tragically, a 64 bit Word#)
14:15:16 <monochrom> The short story is that what everyone has speculated in this channel so far is more like "what *I* would do if I were writing this" but GHC did not take that obvious route.
14:15:43 <nshepperd> I guess nothing stops ghc from unpacking enumerations into constructors except that it's not implemented
14:17:13 <merijn> nshepperd: Nothing stops GHC from not having a runtime representation at all for ADTs :p
14:18:01 <monochrom> Instead the GHC people wanted to unify more, to the point thunks and data constructors are unified, so both are pointers to code first of all.
14:18:34 <monochrom> (The difference is then what code they point to.)
14:20:59 <monochrom> It's then a long story after making that design decision.  The STG paper justifies and describes the rest up to before pointer tagging (exploiting address alignment, using lower 2 or 3 bits to cache "I'm pointing to thunk", "I'm pointing to 1st ctor", "I'm pointing to 2nd ctor" etc)
14:43:21 <maralorn> What’s the boundary that counts for orphan-instances? modules or packages?
14:43:30 <merijn> maralorn: modules
14:45:47 <fendor> given a FilePath "src", how can I strip that prefix from a FilePath "src/Lib.hs" s.t. "Lib.hs" is the result?
14:46:21 <merijn> fendor: You probably want a mix of stuff from
14:46:25 <merijn> @hackage filepath
14:46:25 <lambdabot> http://hackage.haskell.org/package/filepath
14:46:45 <fendor> merijn, yeah, but I fail horribly
14:46:54 <maralorn> fendor: takeFileName
14:47:40 <fendor> maralorn, not enough, the more complex example would be "src/Lib/Lib.hs" -> "Lib/Lib.hs"
14:49:41 <maralorn> Oh, sorry, didn‘t read exact enough.
14:51:04 <fendor> I didnt specify it enough, my mistake
14:54:39 <maralorn> fendor: Well I guess "joinPath . tail . splitPath". Or is the existence of the prefix optional?
14:55:10 <fendor> maralorn, yeah, that too, but I think this is a good start
14:55:19 <fendor> the filepath library is missing some basic utilities, imo
14:55:43 <fendor> @type equalFilePath
14:55:44 <lambdabot> error: Variable not in scope: equalFilePath
14:57:01 <maralorn> fendor: I suggest stripSrcPrefix ("src/":xs) = xs \n stripSrcPrefix xs = xs.
15:00:28 <fendor> hm, yeah that looks good, thank you!
15:02:59 <maralorn> fendor: Actually to be a bit less platform depend I suggest: joinPath . stripSrcPrefix . splitDirectories
15:03:21 <maralorn> then you can do stripSrcPrefix ("src":xs) = xs
15:06:56 <fendor> that looks so not efficient :D 
15:11:51 <fendor> how about: "src" </> "" `isPrefixOf` fp?
15:26:43 <fendor> ( normalise $ "src" </> ".") `stripPrefix` fp is giving  the desired results, but it feels horrible
16:16:11 * hackage ghc-prof-flamegraph 0.2.0.0 - Generates flamegraphs from GHC .prof files.  https://hackage.haskell.org/package/ghc-prof-flamegraph-0.2.0.0 (FrancescoMazzoli)
16:57:07 <koz_> Is there an elegant way to write the tuple-munging function of signature ((a, c), (b, d)) -> ((a, b), (c, d))?
16:58:04 <rotaerk> `\((a,c),(b,d)) -> ((a,b),(c,d))` :-o
16:58:28 <koz_> rotaerk: :P
16:59:01 <koz_> I asked @pl, but did not like the answer...
16:59:21 <heatsink> {-# LANGUAGE CPP #-} \n #define SIG ((a, c), (b, d)) -> ((a, b), (c, d)) \n f :: SIG \n f = \ SIG
16:59:31 <koz_> heatsink: Even more lol.
16:59:48 <koz_> 'What's even more elegant than explicit munging? Explicit _preprocessor_ munging!'
17:00:59 <monochrom> I don't thik this is elegant in pointfree form.
17:01:39 <koz_> monochrom: Understatement of the millenium.
17:02:03 <koz_> @pl \((a,c),(b,d)) -> ((a,b),(c,d))
17:02:03 <lambdabot> uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (,)) . flip . (((.) . (,)) .) . (,)))
17:02:09 <EvanR> sorry, "I just think in pointfree. Can't help it"
17:02:39 <lavalike> :t (fst *** fst) &&& (snd *** snd)
17:02:40 <lambdabot> ((c, b1), (c', b2)) -> ((c, c'), (b1, b2))
17:03:17 <EvanR> oh man, elegance relative to a choice of base combinators
17:04:50 <koz_> lambdabot: Nice!
17:05:01 <koz_> I meant lavalike.
17:05:01 <lavalike> @botsnack
17:05:01 <MarcelineVQ> yeah, gj lambdabot 
17:05:01 <lambdabot> :)
17:05:05 <koz_> LOl
17:37:19 <mniip> is there some sort of .hi-to-ctags based tags generator out there?
17:39:40 <mniip> ghci seems to be able to, but that requires interactively loading all modules
17:39:42 * hackage minimal-configuration 0.1.4 - Minimal ini like configuration library with a few extras  https://hackage.haskell.org/package/minimal-configuration-0.1.4 (MariusGhita)
18:02:45 <hseg> Hi. Was trying to play around with some Unicode strings, thought [Char] would *work*, despite being inefficient. Instead, am getting many instances of \65533. What gives?
18:02:52 <hseg> Code in question: http://codepad.org/0fG4SM27
18:03:20 <ChaiTRex> hseg: Is the output surrounded by double quotes?
18:03:33 <hseg> no
18:04:16 <hseg> (problem I'm trying to solve: given a string with =<26 distinct characters, replace the characters by a-z in a one-to-one way)
18:05:43 <hseg> (all I care about is which indeces are equal, not their values -- since the input is the output of a substitution cipher, precomposing any other substitution cipher won't wreck statistics)
18:06:43 <ChaiTRex> hseg: Is the file stored in UTF-8 format or something else?
18:06:46 <hseg> (tried converting to Text, but it lacks the convenience of [] instances)
18:06:56 <ChaiTRex> hseg: Source file, I mean.
18:07:37 <hseg> ChaiTRex: see code sample. downloading it, seems to be utf-8
18:07:45 <int-e> works for me
18:08:00 <hseg> so no reconversion on the server
18:08:05 <hseg> int-e: odd
18:08:37 <hseg> have no ghc locally, was using codepad as a hacky replacement
18:08:58 <int-e> (ghc 8.6.5, linux...)
18:10:00 <hseg> ah... looking at the compiler used, codepad uses hugs from 2006-09
18:10:05 <jusss> can I compile haskell code to a x86 binary and run it on 32-bit OS?
18:10:06 <hseg> oops
18:10:25 <ChaiTRex> hseg: Does running the download work for you rather than running the file you started with?
18:10:44 <int-e> The oldest ghc I have is 7.6.3 and that's fine as well.
18:10:55 <hseg> ChaiTRex: see above, no compiler locally, don't want to set it up right now
18:11:07 <hseg> int-e: see above. is hugs
18:11:15 <int-e> hseg: yeah, I saw.
18:12:13 <hseg> so it's 7 years older. happy to pin the blame on that
19:16:31 <suzu> jusss: yeah, just statically link it to avoid many headaches
19:17:47 <jusss> suzu: can I compile it on amd64? and compile on amd64 to x86-32 and run it on x86-32
19:18:46 <EvanR> cross compiling is supposedly a thing, since we have haskell running on phones
19:19:11 <EvanR> and rpi
19:28:56 <suzu> you can
19:28:59 <suzu> i don't know how
19:29:12 <suzu> i would guess you need to compile ghc in a cross-compilation toolchain
19:29:32 <suzu> and if i had to guess it'd be pretty treacherous
19:29:45 <suzu> so if there's a different way of accomplishing what you want, i'd probably opt for that
19:34:12 * hackage antiope-sns 7.4.5 - Please see the README on Github at <https://github.com/arbor/antiope#readme>  https://hackage.haskell.org/package/antiope-sns-7.4.5 (arbornetworks)
19:35:12 * hackage antiope-athena 7.4.5, antiope-contract 7.4.5, antiope-shell 7.4.5, antiope-core 7.4.5, antiope-messages 7.4.5, antiope-s3 7.4.5, antiope-es 7.4.5, antiope-dynamodb 7.4.5, antiope-sqs 7.4.5, antiope-optparse-applicative 7.4.5 (arbornetworks)
19:36:40 <sicklorkin> lavalike: join (***)
19:36:46 <sicklorkin> :t join (***)
19:36:48 <lambdabot> Arrow a => a b' c' -> a (b', b') (c', c')
19:41:10 * sicklorkin was somehow reminded of https://gist.github.com/shangaslammi/3438688 
19:51:40 <koz_> Is there a version of ~ that produces a Constraint?
19:52:07 <EvanR> :k () ~ ()
19:52:09 <lambdabot> Constraint
19:52:19 <koz_> Oh, lol, OK.
20:01:12 * hackage hw-uri 0.2.0.0 - Supports IO on URIs  https://hackage.haskell.org/package/hw-uri-0.2.0.0 (haskellworks)
20:02:43 <nshepperd> darn, I can't make my Num instance take implicit parameters
20:03:07 <sicklorkin> :t  \xs -> sortBy (\v1 v2 -> foldMap (\fn -> fn v1 v2) xs)
20:03:09 <lambdabot> Foldable t1 => t1 (t2 -> t2 -> Ordering) -> [t2] -> [t2]
20:03:47 <sicklorkin> does that look wrong to anyone?
20:04:48 <sicklorkin> def less readable (to me) than using mconcat 
20:09:09 <heatsink> you can eta-reduce the outer lambda
20:09:37 <sicklorkin> heatsink: I think ti's borked thou
20:10:00 <heatsink> Oh, you're not sorting xs
20:10:25 <sicklorkin> i want to sort by 'this', then 'that'.
20:10:46 <heatsink> What do you mean?
20:11:16 <sicklorkin> brokedSortOns [_qty, _price] [qtyPrices,...]
20:11:55 <sicklorkin> whre _qty, _price are some fields of qtyPrice
20:12:43 <heatsink> You want to order by _qty, and among those with equal _qty order by _price?
20:12:53 <sicklorkin> oui!
20:13:41 <heatsink> I see
20:20:34 <freeside> language question. I'm making my way through the book Computational Semantics with Functional Programming by van Eijck & Unger, and I'm wondering about modeling a hypothetical piece of business logic that specifies "the value of computation C1 shall be given by (some numerical algorithm); the value of computation C2 shall be given by the same algorithm as for C1, except that any part of the computation involving an odd 
20:21:24 <MarcelineVQ> cuts off at " involving an odd"
20:21:44 <freeside> involving an odd number shall be set to zero". I have some idea how I would approach this in Lisp, thanks to homoiconicity; I'm wondering if this is something I could do in Template Haskell, which I haven't learned yet.
20:22:03 <freeside> By "this" I mean "write the business logic for C1 without anticipating the need to write C2, and then subsequently express the 'programming-by-patch' intent of C2 without refactoring C1 to explicitly handle the odd/even consideration."
20:22:50 <heatsink> That description sounds fishy
20:23:15 <freeside> My first thought was that some code would be able to crack open the AST of C1, and transform it in some way to inspect for odd/evenness at each op.
20:23:24 <heatsink> For example, "x + 1 + 1 :: Int" and "x + 2 :: Int" compute the same thing, but the first one always involves odd numbers and the second one sometimes does not
20:24:06 <heatsink> Because although they compute the same results, they go through different intermediate steps
20:25:03 <heatsink> I don't see why a specification's meaning should depend on how the algorithm works at this level of detail
20:25:06 <freeside> That's true. i know it's not the best example. I guess what I want to do is to do some kind of code transformation that reflects the requirement specification directly, rather than refactor and rewrite and then document the requirement only in a comma
20:25:16 <freeside> er, only in a comment
20:26:28 <freeside> the reason I want to do things this way is because I'm working on a project that involves formalizing the semantics of business logic and legal rules, which are often phrased in a "do algorithm X, but modulo Y, to get algorithm Z" kind of way
20:28:22 <heatsink> I feel it depends on how to formalize the way that parts of the specification can "modify" procedures in other parts of the specification
20:30:33 <heatsink> The Haskellish way to go about it would be to define data structures for the formal language that you're modeling, and write some transformations on those data structures
20:30:50 <heatsink> I wouldn't recommend using TH to edit haskell code directly
20:31:41 <freeside> suppose a specification shows up that says: "any tax benefit which depends on the sex of the applicant shall, after the Gender Blindness Act of 2020 comes into effect, be deemed to return the maximum of the benefits computed across all possible genders."
20:32:39 <freeside> suppose we already have an existing codebase that does calcBenefit :: (Income, Gender, Age) -> Money
20:33:05 <freeside> I wouldn't want to refactor the codebase; I'd want to layer something on top of it, organically, if possible
20:34:26 <freeside> one approach would be to   calcBenefit2020 income _ age = max [ calcBenefit income g age | g <- genders ]
20:35:14 <heatsink> If you use that new function instead of calcBenefit, would that not be refactoring the code?
20:37:07 <freeside> i guess ... but if the new requirement digs deeper into the underlying algorithm, like with detecting odd numbers, then it becomes harder to just wrap the function; you would have to unscrew it and inspect the AST. I suppose I should go learn Template Haskell. That might be enough
20:40:30 <heatsink> I think it will be easier to refactor your program than to write a function that refactors your program for you.
20:43:42 * hackage reflex-basic-host 0.2 - A basic `reflex` host for backend work  https://hackage.haskell.org/package/reflex-basic-host-0.2 (qfpl)
20:44:42 * hackage reg-alloc 0.1.0.0 - Register allocation API  https://hackage.haskell.org/package/reg-alloc-0.1.0.0 (MatthewFarkasDyck)
20:46:42 <heatsink> That register allocation API looks extremely incomplete
20:53:38 <nshepperd> https://kcsongor.github.io/global-implicit-parameters/ this is neat
20:55:06 <nshepperd> but alas, bare words in haskell do not solve my problem, so i guess i'll have to use a non-implicitparams solution
21:04:44 <electricityZZZZ> In many Gnostic systems, God is known as the Monad, the One. https://en.wikipedia.org/wiki/Monad_(Gnosticism)
21:05:13 <electricityZZZZ> Neo in the Matrix is the One (Neo being an anagram of One)
21:05:18 <electricityZZZZ> Neo is a Monad
21:05:56 <electricityZZZZ> (the Matrix was acknowledged by the Wachowskis to have significant Gnostic influences in its authorship)
21:12:26 <wejetheman> hi guys, i have this function for converting ints to binary http://codepad.org/DZgoNqZz and im wondering if there is a way to recursively define it in a way that is similar but so that it comes out facing the right direction to begin with so I don't have to go and do that ridiculous reverse.
21:15:25 <electricityZZZZ> you will have a better chance of getting your question answered if you start refering to Monads as Neos
21:17:19 <ChaiTRex> > let toBinary 0 = [0]; toBinary x = f [] x where f bs 0 = bs; f bs x = let (x', b) = quotRem b 2 in f (b:bs) x' in toBinary 6
21:17:22 <lambdabot>  *Exception: <<loop>>
21:17:34 <ChaiTRex> Something along those lines with the bugs removed :)
21:17:42 <ChaiTRex> Let me try in GHCi
21:19:51 <ChaiTRex> > let toBinary 0 = [0]; toBinary x = f [] x where f bs 0 = bs; f bs x = let (x', b) = quotRem x 2 in f (b:bs) x' in toBinary 6
21:19:53 <lambdabot>  [1,1,0]
21:20:02 <ChaiTRex> wejetheman: ^
21:20:16 <ChaiTRex> @let toBinary 0 = [0]; toBinary x = f [] x where f bs 0 = bs; f bs x = let (x', b) = quotRem x 2 in f (b:bs) x'
21:20:19 <lambdabot>  Defined.
21:20:30 <ChaiTRex> > map toBinary [0..7]
21:20:33 <lambdabot>  [[0],[1],[1,0],[1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
21:21:32 <wejetheman> thanks chai let me pop it in emacs and spread it out and see if i can make some sense of it
21:22:30 <sicklorkin> Gnosticism and the Surpreme Reality
21:24:36 <ChaiTRex> wejetheman: Here it is laid out nicely: http://codepad.org/HsKwma2l
21:35:08 <plakband> I have a recursive/fixpoint data structure that I would like to both 1) extend with a Lift/Pure value like in the free monad 2) annotate every recursion with a value like in the cofree comonad. Does this make sense, and is there a name for this?
21:48:11 * hackage hw-uri 0.2.0.1 - Supports IO on URIs  https://hackage.haskell.org/package/hw-uri-0.2.0.1 (haskellworks)
22:34:26 <remexre> is there a way to lift a lens into a functor in some way?
22:35:11 <remexre> specifically, I have: foo :: Lens' T (Map String U), bar :: Lens' U V, str :: String
22:35:38 <remexre> and I want use (foo.at str.bar) to do what I mean :P
22:43:58 <remexre> ah, preuse and ix
22:45:18 <jackdk> remexre: I was going to say `foo . at str . traverse . bar :: Traversal' T V`
22:47:05 <remexre> I guess side question for a different function
22:47:37 <remexre> wait, nvm
22:48:41 <jackdk> or just use ix str instead of at str . traverse I guess, since you aren't creating things anyway
22:51:12 * hackage hw-prim 0.6.2.37 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.6.2.37 (haskellworks)
23:16:41 * hackage hw-prim 0.6.2.38 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.6.2.38 (haskellworks)
23:25:24 <MarcelineVQ> newhoggy: :>
23:39:00 <newhoggy> MarcelineVQ: hi
