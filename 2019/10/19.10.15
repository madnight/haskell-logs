00:13:56 <trcc> I am trying to integrate Network.Wai.Logger with Network.Wai.Middleware so I can use it in my Scotty Backend. But I cannot figure out the step forward. Any ideas? https://gist.github.com/CThuleHansen/a48d53eb5233e239dff7a18778fe9ea6#file-logger-hs
00:30:20 <dminuoso> trcc: Did you look at the README from wai-logger?
00:30:30 <trcc> dminuoso: for about 3 hours ^^
00:30:40 <trcc> But it was late last night. Now I got from apacheloggeractions to apachelogger
00:30:52 <trcc> So just progressed a tiny bit, and now I need to turn it into a Middleware
00:31:03 <trcc> i.e. Application -> Application
00:33:23 <dminuoso> trcc: And Application is?
00:33:47 <trcc> sec, updating gist
00:33:55 <dminuoso> Ah interesting, Im not entirely sure you can do this.
00:34:08 <trcc> https://gist.github.com/CThuleHansen/d630f319ebbd8ca7b11e48836706dd7e
00:34:20 <trcc> Can you try and explain?
00:35:40 <trcc> I was thinking of using this isntead: http://hackage.haskell.org/package/wai-extra-3.0.28/docs/Network-Wai-Middleware-RequestLogger.html#v:mkRequestLogger but it does not have as much configuration, i.e. amount of log files before starting to overwrite
00:35:41 <dminuoso> Sorry I read wrong. 
00:35:58 <dminuoso> trcc: So the idea is as following.
00:36:24 <dminuoso> trcc: You construct an Application, which means its some `Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived`
00:36:42 <trcc> okay, so just applicatino to begin with
00:36:51 <dminuoso> So you have some `mkMiddleware req res = ...` where `req :: Request` and `res :: Response -> IO ResponseReceived`
00:37:20 <dminuoso> trcc: And you have some existing application - and you basically just need to plumb your original application into this new application with the logger sitting in between.
00:38:44 <trcc> okay dminuoso. I will try for a bit and see how far I get
00:38:45 <trcc> thank you
00:38:50 <dminuoso> trcc: So more appropriately, you'd have an additional argument representing the parametrized app
00:39:45 <dminuoso> so some `mkMiddleware app req res = ...`
00:43:47 <trcc> So Application -> Application does that equal Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived -> Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived or (Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived) -> (Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived)
00:44:35 <dminuoso> trcc: What do you think? :)
00:45:17 <dminuoso> trcc: Perhaps it helps to imagine that you could always write redundant parens around an identifier. So `(Int)` is the same as `Int`
00:47:22 <trcc> hmm I think the second
00:47:29 <trcc> but still looking into it
00:48:04 <jusss```> dmwit:  "<dmwit> jusss`: For example, (* -> *) -> *, and * -> (* -> *), and * -> * ->" but that (* -> *) -> * , we may think it as * -> * ?
00:52:56 <dminuoso> jusss```: No.
00:53:26 <dminuoso> jusss```: Just like, on the type level, `(Int -> Int) -> Int` is a different type from `Int -> Int`
00:53:48 <dminuoso> `* -> *` says "give me a type of kind *, and Ill return a type of kind *"
00:54:07 <dminuoso> `(* -> *) -> *` says "give me a type of kind (* -> *), and Ill return a type of kind *"
00:54:34 <dminuoso> % :k MaybeT
00:54:34 <yahb> dminuoso: ; <interactive>:1:1: error:; Not in scope: type constructor or class `MaybeT'; Perhaps you meant `Maybe' (imported from Prelude)
00:54:45 <dminuoso> % impot Control.Monad.Trans.Maybe
00:54:45 <yahb> dminuoso: ; <interactive>:81:7: error:; Not in scope: data constructor `Control.Monad.Trans.Maybe'; No module named `Control.Monad.Trans' is imported.
00:54:47 <dminuoso> % import Control.Monad.Trans.Maybe
00:54:47 <yahb> dminuoso: 
00:54:49 <dminuoso> % :k MaybeT
00:54:49 <yahb> dminuoso: MaybeT :: (* -> *) -> * -> *
00:55:48 <dminuoso> % :k ConstTF
00:55:48 <yahb> dminuoso: ConstTF :: * -> (* -> *) -> *
00:55:57 <dminuoso> % :k (ConstTF Int)
00:55:58 <yahb> dminuoso: (ConstTF Int) :: (* -> *) -> *
00:56:05 <dminuoso> % :k (ConstTF Int Maybe)
00:56:05 <yahb> dminuoso: (ConstTF Int Maybe) :: *
00:56:56 <jusss````> % :k (ConstTF Int)
00:56:56 <yahb> jusss````: (ConstTF Int) :: (* -> *) -> *
00:57:38 <dminuoso> jusss````: As you can see the next argument to apply has to be of kind (* -> *)
00:57:48 <dminuoso> % :k (ConstTF Int Bool)
00:57:48 <yahb> dminuoso: ; <interactive>:1:14: error:; * Expected kind `* -> *', but `Bool' has kind `*'; * In the second argument of `ConstTF', namely `Bool'; In the type `(ConstTF Int Bool)'
00:58:01 <dminuoso> See how it says "I expected something of kind * -> *, but you gave me something of kind *" ?
00:59:54 <jusss````> dminuoso: wait a sec, functions would have type like f :: a->a, but f doesn't have kind, why？
01:00:43 <jusss````> dminuoso: if f is a value, f has type like Int -> Int, and Int has kind *, so f should has kind * -> *
01:01:39 <jusss````> if f has kind * -> *, so functions will have higher-kinded types? but functions is on value level, not on type level
01:01:57 <jusss````> Maybe is a function, which work on type level
01:02:32 <jusss````> dminuoso: I'm confused, so functions are higher-kinded types?
01:03:51 <MarcelineVQ> f has kind *, the kind of -> is what matters for f.
01:03:52 <MarcelineVQ> % :k (->)
01:03:53 <yahb> MarcelineVQ: (->) :: * -> * -> *
01:03:55 <MarcelineVQ> % :k (->) Int
01:03:55 <yahb> MarcelineVQ: (->) Int :: * -> *
01:03:57 <jusss````> or there're two kind of functions, type function and value function
01:03:57 <MarcelineVQ> % :k (->) Int Int
01:03:57 <yahb> MarcelineVQ: (->) Int Int :: *
01:05:23 <jusss````> MarcelineVQ: why -> has kind * -> * -> *? not * -> *?
01:06:25 <jusss````> % :k (->) Int Int Int
01:06:25 <yahb> jusss````: ; <interactive>:1:1: error:; * Expected kind `* -> k0', but `(->) Int Int' has kind `*'; * In the type `(->) Int Int Int'
01:07:26 <jusss````> so Int -> Int has kind * ? but what the last * means?
01:08:07 <dminuoso> jusss````: Kinds are the types of types.
01:08:23 <dminuoso> jusss````: If you think of the type-language as a sort of programming language of its own, then that programming language itself too has types.
01:08:58 <dminuoso> `5 :: Int` `Int :: *`
01:09:27 <jusss````> dminuoso: but the function, kind level has function, right?
01:09:34 <dminuoso> jusss````: Right.
01:09:45 <dminuoso> jusss````: oh wait, no
01:09:50 <dminuoso> jusss````: The *type* level has functions.
01:09:58 <dminuoso> jusss````: But its represented by (->) in the kind level.
01:10:05 <dminuoso> Maybe :: * -> *
01:10:54 <jusss````> dminuoso: then I don't understand why -> has kind *->*->*
01:11:14 <dminuoso> jusss````: The symbol (->) exists in two worlds.
01:11:23 <MarcelineVQ> The kind of types which have values is *, Int has *, a valid Int is 3, Char has *, a valid Char is 'a', Int -> Int has *, a valid Int -> Int is (\x -> x + 2). * -> * -> * says, give me two types of kind * and you'll get back a type of kind *
01:11:39 <dminuoso> jusss````: So if we look at a regular *type* `f :: Int -> Int`
01:11:50 <dminuoso> jusss````: Then you might ask "well what's the kind of `Int -> Int`"
01:12:15 <dminuoso> jusss````: And that'd be `*`, but you might think "hey, if `Int :: *` and `Int -> Int :: *`, then what is that (->) in the type level?
01:13:02 <trcc> Sorry dminuoso, can you give me a few more pointers? My mkMiddleware function takes type Middleware, which expands to Application -> Application, which expands to (Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived) -> (Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived). It steps in between, so basically it should return the Application it receives as argument. Is this correct?
01:14:28 <jusss````> MarcelineVQ: why Int -> Int has * ?
01:15:17 <jusss````> dminuoso: yeah, if Int :: * and Int -> Int :: *, what's the diffrents? 
01:15:31 <jusss````> Int and Int -> Int are same in kind level?
01:16:45 <boxscape> (hmm this conversation makes me look forward to Data.Kind.Type becoming the default)
01:17:00 <boxscape> jusss```` Int and Int -> Int are both types
01:17:13 <boxscape> whereas Maybe is a type constructor
01:17:13 <jusss````> boxscape: they're same on the kind level?
01:17:15 <boxscape> :k Maybe
01:17:17 <lambdabot> * -> *
01:17:29 <boxscape> jusss```` they're not on a kind level, they're both on the type level
01:17:37 <trcc> ahh no. It takes: mw (app::Wai.Application) (req::Request) (res::(Response -> IO ResponseReceived))
01:18:02 <jusss````> boxscape: another question, do they have the same kind?
01:18:15 <boxscape> jusss```` yes, both Int and Int -> Int have kind *
01:18:49 <jusss````> ok,  3 and 5 are not same on value level, but 3 and 5 are same on type level
01:19:09 <boxscape> uh, I'm not sure what you mean by that
01:19:13 <jusss````> so Int and Int -> Int are not same on type level, but they're same on kind level?
01:19:30 <boxscape> jusss```` it's more like 3 /= 5, but 3 :: Int and also 5 :: Int
01:19:30 <dminuoso> jusss````: Right.
01:19:54 <jusss````> dminuoso: then I wonder why -> would have kind * -> * -> *?
01:20:07 <dminuoso> jusss````: If you think of (->) as a type operator it makes sense
01:20:09 <jusss````> why its kind is that ?
01:20:15 <dminuoso> jusss````: (->) takes two arguments, just like (+) takes two arguments
01:20:18 <dminuoso> jusss````: and it returns something
01:20:21 <dminuoso> Comprae
01:20:22 <boxscape> :k Either
01:20:23 <lambdabot> * -> * -> *
01:20:24 <dminuoso> % :t (+)
01:20:24 <yahb> dminuoso: Num a => a -> a -> a
01:20:29 <dminuoso> % :t (++)
01:20:29 <yahb> dminuoso: [a] -> [a] -> [a]
01:21:51 <dminuoso> jusss````: (->) is the type-level operator that generates function types. 
01:22:16 <dminuoso> jusss````: Let's just set `type Fun = (->)` and then say "Fun Int Double" is the type of all functions taking Int and returning Double
01:22:28 <dminuoso> jusss````: Does this make sense?
01:23:01 <dminuoso> % type Fun = (->)
01:23:01 <yahb> dminuoso: 
01:23:31 <dminuoso> % myOdd :: Fun Int Bool; myOdd f = odd f
01:23:31 <yahb> dminuoso: 
01:23:32 <jusss````> dminuoso: -> in the kind level, does it still mean function? or what else?
01:23:42 <dminuoso> jusss````: No Im talking about -> in the type level.
01:23:49 <jusss````> 'cause value and type levels both have function ->
01:24:07 <dminuoso> jusss````: and sort of yes, (->) in the kinds generates kinds for function types!
01:26:31 <jusss````> dminuoso: if type Int :: *, and Int -> Int :: *,  (->) Int Int :: *, (->) * -> * :: *, (->) :: * -> * -> *
01:27:19 <boxscape> % :k  (->) * -> *
01:27:19 <yahb> boxscape: ; <interactive>:1:1: error:; * Expecting one more argument to `(->) *'; Expected a type, but `(->) *' has kind `* -> *'; * In the type `(->) * -> *'
01:27:34 <jusss````> % :k (->)
01:27:34 <yahb> jusss````: (->) :: * -> * -> *
01:28:04 <jusss````> % :k (->) * *
01:28:04 <yahb> jusss````: (->) * * :: *
01:28:23 <jusss````> oh, it's (->) * * :: *,
01:29:32 <trcc> dminuoso: I am close now. I just cannot figure out how to get the status and length. https://gist.github.com/CThuleHansen/e283c81034b69d834c4b1e0800554f41#file-logger-hs-L94
01:40:07 <MarcelineVQ> Nevoic9: get it figured?
01:43:52 <trcc> A general hackage question that I have come across a couple of times now: How do I see the content of a type? i.e. how do I see the parts of ResponseReceived in here (bottom): http://hackage.haskell.org/package/wai-3.2.2.1/docs/Network-Wai-Internal.html
01:45:33 <trcc> http://hackage.haskell.org/package/wai-3.2.2.1/docs/Network-Wai-Internal.html#t:ResponseReceived direct link
01:45:47 <MarcelineVQ> It says all that it publicly exposes about it already. but if you want to see it directly, click Source on the right of it, which for some unknown reason people think writing in grey on a grey background is a good idea
01:46:22 <trcc> data ResponseReceived = ResponseReceived
01:46:22 <trcc>     deriving Typeable
01:46:25 <trcc> MarcelineVQ: thank you. It just says the above
01:46:29 <trcc> which does not really help me
01:46:52 <trcc> I do not understand where it is hiding
01:47:09 <MarcelineVQ> It's not hiding anywhere, that's the whole thing. data ResponseReceived = ResponseReceived
01:47:44 <trcc> So it does not have any data except a constructor?!
01:47:47 <MarcelineVQ> In the same way that data Blob = Blarble is the entire definition of a type called Blob with one value Blarble
01:47:53 <MarcelineVQ> Correct
01:48:40 <trcc> hmm damn. How the hell do I extract a status from (Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived) then?!?! arrrr soo close yet so far
01:50:09 <[exa]> trcc: what's the closest type you can get?
01:50:34 <trcc> Well I have Request and ResponseReceived, but I need Response I get
01:50:58 <trcc> guess*
01:51:22 <jackdk> I don't believe you do. You construct the response maybe by making decisions based on the request
01:51:25 <[exa]> it returns IO, you can sneak it out of the (Response->IO ResponseReceived) using some ugly kind of ioRef or so, right?
01:52:19 <trcc> yes, but the  ResponseReceived does not contain any useful data for this purpose. Here is a gist: https://gist.github.com/CThuleHansen/3e79b254c819ddbd83593dcbec27c22d#file-logger-hs-L94 with my standstill
01:52:31 <trcc> jackdk: certainly, but it seems like this is not the job of the middleware
01:52:52 <[exa]> the data you want is hidden in either Request or Response?
01:53:20 <jackdk> https://hackage.haskell.org/package/wai-3.2.2.1/docs/Network-Wai.html#v:modifyResponse is almost what you want but without the ability to do IO
01:53:51 <trcc> [exa]: reponse I believe
01:54:18 <[exa]> trcc: can you stuff in your own function (or wrapper) in place of the (Response -> IO ResponseReceived) ?
01:56:18 <trcc> hmm [exa] maybe I can. Interesting!
01:57:44 <[exa]> trcc: you seem to do the ⌜app req fRes⌝ thing; so you could probably expand ⌜req⌝ a bit as ⌜\a -> writeIORef ... a >> req a⌝ right ?
01:57:59 <trcc> [exa]: I think I got the idea - jsut need to work on it!
01:58:29 <[exa]> (hopefully a WAI expert will appear now and show us a cleaner way to do that....)
01:59:19 <[exa]> jackdk: OTOH one unsafePerformIO never hurts right? :D
02:04:21 <trcc> [exa]: think I got it
02:04:40 <trcc> [exa]: https://gist.github.com/CThuleHansen/7cbd57db6875f160d5a671d2a9e2f446#file-logger-hs-L88-L95
02:04:54 <trcc> Thank you all! dminuoso, jackdk, MarcelineVQ[exa]
02:04:58 <trcc> although I haven't tested it yet
02:06:38 <[exa]> trcc: oh yes that's much cleaner
02:07:04 <[exa]> (sorry I somehow confused req with response function :D )
02:09:07 <trcc> we'll see whether it works hehe
02:09:29 <higherorder> How can I lift the value `Nothing` (from the Mayne monad) to the `StateT a Maybe b` monab?
02:10:11 <[exa]> higherorder: pure ?
02:10:48 <[exa]> oh it's StateT, sorry
02:11:25 <[exa]> :t lift 
02:11:26 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
02:11:58 <[exa]> :t lift :: (Maybe a -> StateT b Maybe a)
02:11:59 <lambdabot> Maybe a -> StateT b Maybe a
02:12:16 <higherorder> [exa]: ah, thanks! and so in that monad this would abort the computation?
02:14:27 <[exa]> IIRC yes; running it should return Nothing instead of ⌜Just (State s->(s,a))⌝
02:15:44 <[exa]> (one parentheses missing in the type but I guess it's readable)
02:19:14 * hackage slave-thread 1.1 - A fundamental solution to ghost threads and silent exceptions  https://hackage.haskell.org/package/slave-thread-1.1 (NikitaVolkov)
02:21:44 <higherorder> [exa]: I'll try that out; thank you :)
02:24:26 <trcc> Wooho I am happy now. This logging stuff was just on the edge of my knowledge, awesome to have completed it!
02:33:16 <trcc> Okay almost working. However, file is locked after first log message
02:34:20 <trcc> Anyways, issue for another day.
02:36:55 <maerwald> MarcelineVQ: https://hackage.haskell.org/package/polysemy-1.2.1.0/docs/Polysemy-Internal-CustomErrors-Redefined.html#t:IfStuck xxxD
02:39:26 <maerwald> one of those libraries where you can confidently say: "avoid looking at the internals"
02:39:31 <maerwald> but I like the API
02:39:51 <maerwald> higher-order effects are sick
02:42:37 <boxscape> "So instead, we just propagate out 100 of these type variables and assume that 100 type variables ought to be enough for anyone."
02:42:41 <maerwald> yeah
02:42:47 <maerwald> isn't that what bill gates said too?
02:42:48 <maerwald> :>
02:42:56 <boxscape> something like that
02:44:54 <boxscape> I hope we won't be seeing Moore's law apply to the number of type variables people use
02:45:42 <maerwald> create the type family via TH and allow to set the number in your .cabal file :P
02:47:14 * hackage yeamer 0.1.0.0 - Yesod-based server for interactive presentation slides  https://hackage.haskell.org/package/yeamer-0.1.0.0 (leftaroundabout)
02:48:16 <Guest_59> Hi! I'm trying to install Haskell on Mac, following the instructions from here: https://www.haskell.org/platform/mac.html . I'm getting an error message regarding the C compiler and I couldn't find any way to solve this:
02:48:33 <Guest_59> ```checking XCode version... 11.1configure: XCode version component 1: 11configure: XCode version component 2: 1checking whether the C compiler works... noconfigure: error: in `/var/folders/zz/ck0j19_d4336p_45trlj1bcr0000gp/T/tmp.iuTjmdvH/ghc-8.6.5':configure: error: C compiler cannot create executablesSee `config.log' for more details```
02:49:55 <Guest_59> Sorry for the bad formatting... I reinstalled Xcode like most SO answers recommend, and also followed their instructions, but no luck... any help would be much appreciated!
02:52:14 * hackage dynamic-plot 0.4.1.0 - Interactive diagram windows  https://hackage.haskell.org/package/dynamic-plot-0.4.1.0 (leftaroundabout)
03:12:27 <mniip> Guest_59, see config.log for more details
03:12:34 <mniip> you could paste your config.log to a pastebin
03:13:13 <Guest_59> mniip thanks! I was looking for the file but couldn't find it... it's not in the directory I'm working from
03:15:06 <maerwald> the Tactics stuff is pretty... strong... in polysemy
03:16:59 <mniip> Guest_59, it should've created a temporary directory and put a ghc-$version in there
03:17:52 <mniip> you can rerun with VERBOSE=1 to get it to output what it's doing
03:24:14 * hackage colour-space 0.1.5.1 - Instances of the manifold-classes for colour types  https://hackage.haskell.org/package/colour-space-0.1.5.1 (leftaroundabout)
03:27:44 * hackage yeamer 0.1.0.1 - Yesod-based server for interactive presentation slides  https://hackage.haskell.org/package/yeamer-0.1.0.1 (leftaroundabout)
03:33:59 <Guest_59> mniip I'm using the shell script suggested at the site I've linked to... where should I put the verbose flag? Sorry for the naive questions, I'm still trying to make sense of it...
03:34:37 <Guest_59> Installing GHC-8.6.5 for Darwin on architecture x86_64checking build system type... x86_64-apple-darwin18.7.0checking host system type... x86_64-apple-darwin18.7.0checking target system type... x86_64-apple-darwin18.7.0Build platform inferred as: x86_64-apple-darwinHost platform inferred as: x86_64-apple-darwinTarget platform inferred as:
03:34:38 <Guest_59> x86_64-apple-darwinGHC build  : x86_64-apple-darwinGHC host   : x86_64-apple-darwinGHC target : x86_64-apple-darwinLLVM target: x86_64-apple-darwinchecking for path to top of build tree... /var/folders/zz/ck0j19_d4336p_45trlj1bcr0000gp/T/tmp.Q7oqbFBV/ghc-8.6.5checking for perl... /usr/local/bin/perlchecking for a BSD-compatible install...
03:34:38 <Guest_59> /usr/bin/install -cchecking for gfind... nochecking for find... /usr/bin/findchecking whether ln -s works... yeschecking for gsed... /usr/local/bin/gsedchecking XCode version... 11.1configure: XCode version component 1: 11configure: XCode version component 2: 1checking whether the C compiler works... noconfigure: error: in
03:34:39 <Guest_59> `/var/folders/zz/ck0j19_d4336p_45trlj1bcr0000gp/T/tmp.Q7oqbFBV/ghc-8.6.5':configure: error: C compiler cannot create executablesSee `config.log' for more details
03:35:50 <mniip> export VERBOSE=1
03:35:52 <mniip> then run the script
03:36:04 <mniip> also please do use a pastebin for long walls of text
03:36:07 <mniip> or you might die
03:39:49 <Guest_59> OK :-)  
03:40:07 <Guest_59> export VERBOSE=1 and then running curl ... | sh does nothing, same as without the export
03:41:30 <maerwald> Guest_59: export PATH="$HOME/.ghcup/bin" ; ghcup --verbose install
03:41:34 <maerwald> oops
03:41:35 <maerwald> sec
03:41:45 <maerwald> export PATH="$HOME/.ghcup/bin:$PATH" ; ghcup --verbose install
03:41:46 <maerwald> that
03:43:13 <Guest_59> Thanks. Working now, will pastebin the output when it'll fail...
03:44:12 <maerwald> supposedly, os x should open a dialog box for installing the command line tools... that's what os x users told me
03:44:39 <Guest_59> pretty sure I already have this installed
03:44:42 <maerwald> after it did that, you just run 'ghcup install'
04:06:20 <Guest_90> I've just installed the ghci, but it says I need to adjust my PATH variable. The automatic solution with typing YES doesnt seem to work
04:06:28 <Guest_90> how do i adjust it?
04:06:44 * hackage aeson-yaml 1.0.2.0 - Output any Aeson value as YAML (pure Haskell library)  https://hackage.haskell.org/package/aeson-yaml-1.0.2.0 (patrick)
04:12:40 <fendor> Guest_90, what is your OS?
04:13:10 <Guest_90> mac
04:13:49 <Guest_90> macos high sierra version 10.13.6
04:13:56 <Schrostfutz> Hi, I'm trying to solve a (very) simple problem. For that, I want to parse some input. So far I have 'map words (lines "1 2 3\n2 1 3")'. I want to use the '.' to change associativity ('map words . lines "1 2 3\n2 1 3"') which gives me an error I have trouble understanding (Couldn't match expected type a -> [String] with actual type [String]. Can you explain what I'm doing wrong?
04:14:11 <ChaiTRex> Guest_90: Is the thing to add to your path inside your home directory or somewhere else?
04:14:45 <Guest_90> its in /User/...
04:15:01 <Guest_90> Users*
04:15:23 <ChaiTRex> Guest_90: That's probably your home directory (/Users/yourUsername)
04:15:33 <Guest_90> yes
04:16:07 <Guest_90> It says: "You may want to source '/Users/umguez/.ghcup/env' in your shellconfiguration to do so (e.g. ~/.bashrc)."
04:16:20 <MarcelineVQ> Schrostfutz: . composes functions but lines "1 2 3\n2 1 3" is no longer a function because it's been fully applied. (map words . lines) "1 2 3\n2 1 3"
04:16:30 <Guest_59> maerwald @mni
04:16:41 <Schrostfutz> MarcelineVQ: Ah, thanks a lot
04:16:45 <Guest_59> maerwald mniip this is what I get: https://pastebin.com/raw/TwRSBzBQ
04:17:00 <ChaiTRex> Guest_90: In that case, go ahead and add a line to ~/.bashrc that says: source /Users/umguez/.ghcup/env
04:17:59 <ChaiTRex> Guest_90: You'll need to save ~/.bashrc, close out that terminal session, and open a new one to have the new settings.
04:19:11 <MarcelineVQ> or even relog
04:19:23 <Guest_90> how do i add a line to ~/.bashrc and how do i save it, when I solely type ~/.bashrc, it says no such file or directory
04:19:54 <Guest_90> im a novice, i bet you can tell
04:21:17 <ChaiTRex> Guest_90: You can use the command: nano ~/.bashrc
04:21:56 <ChaiTRex> Guest_90: It will use the nano text editor to edit the file. Use the arrow keys to get around in the file. Ctrl key combos should be listed at the bottom for saving and exiting.
04:22:52 <ChaiTRex> Guest_90: Note that saving the file is called writing it out.
04:24:40 <Guest_90> i wrote source /Users/umguez/.ghcup/env into the editor and write out, now for the "File Name to Write: /Users/umguez/.bashrc/.." i can choose a name?
04:25:29 <Guest_59> @mae
04:25:29 <lambdabot> Maybe you meant: msg more faq
04:26:14 <Guest_59> maerwald mniip sorry browser restarted so I lost it if you replied after I linked pastebin
04:26:41 <ariakenom> Guest_59: you want the same name. just press enter
04:27:09 <Guest_59> what do you mean?
04:27:46 <Guest_90> kk
04:27:49 <Guest_90> thanks a lot
04:30:13 <MarcelineVQ> to add, .bashrc isn't a folder, it's the file
04:30:55 <MarcelineVQ> unless mac is different there I guess
04:33:50 <Guest_90> ghci file.hs still doesn't work
04:34:06 <Guest_90> ghci: command not found
04:34:36 <Guest_90> i guess i only added ghc
04:35:00 <Guest_90> ghc doesnt work either
04:36:08 <ChaiTRex> Guest_90: Does the following show your source line you added: cat ~/.bashrc
04:37:05 <Guest_90> yes
04:37:07 <ski> Guest_90 : did you either run `source ~/.bashrc' in your shell, or start a new shell ?
04:38:32 <Guest_90> I wrote "source /Users/umguez/.ghcup/env" into the nano ~/.bashrc inside the same shell that I installed the haskell platform in
04:38:48 <Guest_90> then I started a new shell to compile my first haskell file
04:39:25 <ChaiTRex> Guest_90: In that new shell, what does the following say: echo $PATH
04:39:40 * ski . o O ( `printenv PATH' )
04:41:29 <Guest_90> i cant wirte
04:41:55 <Guest_90> i cant copy paste it for some reason
04:42:07 <ChaiTRex> Hmm. Are you talking to us through the terminal app?
04:42:49 <Guest_90> I can paste it into the text line on the browser, but pressing doesnt send it
04:42:56 <Guest_90> pressing enter*
04:43:30 <Guest_90> it says /Library/Frameworks/Python.framwork/Version...
04:43:40 <ChaiTRex> Guest_90: Ahh, a browser. In the terminal app, press Apple+Q to quit it completely, then try starting it and running ghci
04:44:55 <Guest_90> still doesnt work
04:46:24 <ChaiTRex> Guest_90: What does the following say: file /Users/umguez/.ghcup/env
04:47:45 <Guest_90> "/Users/umguez/.ghcup/env: ASCII text"
04:48:15 <Guest_90> "/Library/Frameworks/Python.framework/Versions/3.7/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/Library/Frameworks/Mono.framework/Versions/Current/Commands"
04:48:20 <Guest_90> thats what echo path said
04:48:57 <ChaiTRex> Guest_90: And what does the following say: grep -n source ~/.bashrc
04:49:25 <Guest_90> 2:source /Users/umguez/.ghcup/env
04:50:16 <ChaiTRex> Guest_90: One more: wc -l ~/.bashrc
04:50:35 <Guest_90>        3 /Users/umguez/.bashrc
04:50:36 <ChaiTRex> Guest_90: That's the letter L lowercase, not a one.
04:52:04 <ChaiTRex> Guest_90: Ahh, OK. Maybe it's interrupting in the middle of something. Try moving it to the bottom line instead of the second line. Editing with: nano ~/.bashrc
04:54:28 <Guest_90> ghc and ghci still don't work. Also is the space in "source /Users/..." intentional?
04:54:51 <ChaiTRex> Guest_90: Yes, there should be one space between source and the /Users part.
04:55:44 <ChaiTRex> Guest_90: OK, now what do the following produce: grep -n source ~/.bashrc && wc -l ~/.bashrc
04:57:10 <Guest_90> 100:source /Users/umguez/.ghcup/env
04:57:22 <Guest_90>      101 /Users/umguez/.bashrc
04:58:26 <ChaiTRex> Guest_90: Is the following an empty line: tail -n 1 ~/.bashrc
04:58:45 <Guest_90> yea
04:59:10 <Guest_59> Hi, I'm trying again since I lost what I wrote before that... I'm trying to install Haskell on Mac using these instructions: https://www.haskell.org/platform/mac.html
04:59:26 <Guest_59> I get the following error message:
04:59:52 <Guest_59> https://pastebin.com/raw/TwRSBzBQ
05:00:15 <Guest_59> Can someone help me find config.log so I can figure out what's going wrong?
05:01:05 <Guest_59> The final error I'm getting is `configure: error: C compiler cannot create executables` which seems to repeat in different SO questions, but I wasn't able to fix it by following their solutions...
05:03:07 <Guest_90>  i just tried this: https://stackoverflow.com/questions/32920452/how-to-run-haskell-on-osx-el-capitan
05:03:16 <Guest_90> but it says No GHC or Platform versions installed in /Library
05:03:48 <hpc> i bet config.log is in /var/folders/zz/ck0j19_d4336p_45trlj1bcr0000gp/T/tmp.WgX6Wp3f/ghc-8.6.5 or one of its many parent directories
05:05:21 <Guest_90> should I try to reinstall the haskell platform?
05:05:46 <Guest_59> hpc I've tried but the folder is empty...
05:06:22 <hpc> even if you go up a few levels?
05:06:51 <merijn> C compiler cannot create executables and /Library, this sounds like macOS with no XCode tools installed
05:07:06 <hpc> it says xcode 11.1 is installed
05:07:23 <Guest_59> yes... is that a problem?
05:07:24 <merijn> hpc: Sure, but are the *commandline tools* installed
05:07:28 <hpc> is the C toolchain separate?
05:07:30 <hpc> oh, ugh
05:07:35 <ChaiTRex> Guest_90: Can you pastebin the output of: cat /Users/umguez/.ghcup/env
05:07:50 <ChaiTRex> Guest_90: It might be broken somehow
05:07:52 <merijn> hpc: The C toolchain isn't, but the commandline C toolchain is a separate addon not installed by default, yes
05:08:25 <merijn> hpc: Since people who aren't grumpy unix curmudgeons like us just use the XCode build setup for compiling C :p
05:08:49 <Guest_59> merijn how can I test this?
05:09:36 <merijn> Guest_59: Try running "xcode-select --install"
05:10:15 <Guest_90> https://pastebin.com/eWQk4yE4
05:10:30 <Guest_90> does it work?
05:10:37 <Guest_90> ive never pastebined
05:10:44 <Guest_59> merijn `xcode-select: error: command line tools are already installed, use "Software Update" to install updates`
05:10:58 <merijn> ok, so then they should be working
05:11:12 <merijn> Mojave or Catalina?
05:11:16 <Guest_59> Mojave
05:11:31 <merijn> hmm, then I'm confused why it's not working
05:11:50 <Guest_59> me too :-D
05:12:04 <ChaiTRex> Guest_90: And the following gives one as a result: wc -l /Users/umguez/.ghcup/env
05:12:28 <Guest_90> yes
05:14:38 <ChaiTRex> Guest_90: Try the following: printenv PATH; source /Users/umguez/.ghcup/env; printenv PATH
05:14:44 * hackage trackit 0.6.3 - A command-line tool for live monitoring  https://hackage.haskell.org/package/trackit-0.6.3 (EmilAxelsson)
05:14:47 <ChaiTRex> Guest_90: Are the two results different?
05:15:13 <merijn> Naming scheme question: If I have a function that sets a variable (if not set and error if it is) and one that just clobbers any existing value, how to distinguish these two versions?
05:15:48 <Guest_90> yes it worked
05:15:55 <Guest_90> ghci compiled
05:15:58 <Guest_90> thanks man
05:16:05 <ChaiTRex> Guest_90: Hold on, it won't stay.
05:16:13 <Taneb> merijn: instantiate vs write?
05:16:18 <ChaiTRex> Guest_90: Are you running bash? Try: echo $0
05:16:51 <MarcelineVQ> merijn: can anything else set the first variable but this function?
05:16:58 <MarcelineVQ> if not setOnce seems good
05:17:35 <merijn> MarcelineVQ: I had setGlobalVar so far, but that's only one name so I need to change/modify it in some preferably systematic way to name the 2nd variant
05:17:46 <MarcelineVQ> otherwise setTo or just set seem fine for the second
05:17:53 * ski . o O ( `putX' vs. `setX' ? )
05:18:36 <Guest_90> echo $0 gives -bash, just started a new shell, yea it didnt compile there
05:19:04 <Guest_90> only work on the first shell
05:19:13 <Guest_90> or bash
05:19:43 <Guest_59> hi merijn, got disconnected again so if you wrote anything I'd appreciate it if you can re-send it
05:19:49 <MarcelineVQ> hmmm... initializeGlobalVar (once) and setGlobalVar (clobber)... I feel like we have different naming proclivities :>
05:20:08 * ski was also thinking about "instantiate"
05:20:41 <merijn> hmm, that's probably better
05:21:12 <ChaiTRex> Guest_90: This one's a bit harder. Remove the source line from .bashrc and save it. Then, add the source line to .profile and save it.
05:21:28 * ski is reminded of I-Vars
05:21:43 * MarcelineVQ dataflow programs ski
05:21:49 <ChaiTRex> Guest_90: Then, save all your work and everything because you have to log out to make sure it works properly. Log out, log in, start a terminal, start ghci.
05:22:14 * hackage gtk2hs-buildtools 0.13.5.3 - Tools to build the Gtk2Hs suite of User Interface libraries.  https://hackage.haskell.org/package/gtk2hs-buildtools-0.13.5.3 (HamishMackenzie)
05:22:45 * ski passes MarcelineVQ the declarative concurrency of a concurrent logic programming system
05:23:14 * hackage cairo 0.13.6.1, glib 0.13.7.1 (HamishMackenzie): https://qbin.io/pages-files-xypo
05:23:20 <ski> @hackage ivar-simple
05:23:20 <lambdabot> http://hackage.haskell.org/package/ivar-simple
05:23:24 <ski> @hackage data-ivar
05:23:24 <lambdabot> http://hackage.haskell.org/package/data-ivar
05:23:26 * MarcelineVQ akwardly plugs it into an indexed monad while wearing science goggles
05:23:32 <merijn> ski: Not really I var and more "abusing a database table to store "variables"" :p
05:24:14 * hackage pango 0.13.6.1 - Binding to the Pango text rendering engine.  https://hackage.haskell.org/package/pango-0.13.6.1 (HamishMackenzie)
05:24:35 <ski> merijn : what's an extensional relation, but a persistent mutable variable ?
05:24:55 <ChaiTRex> Guest_90: Again, add it as the bottom line of ~/.profile if there's anything already there.
05:25:13 <ski> @hackage lvish
05:25:13 <lambdabot> http://hackage.haskell.org/package/lvish
05:25:15 * hackage gtk3 0.15.3, gio 0.13.6.1 (HamishMackenzie): https://qbin.io/again-nba-mmal
05:25:40 <Guest_90> ChaiTRex It still doesnt work on new tabs and shells/bash, should I still restart?
05:26:14 * hackage gtk 0.15.3 - Binding to the Gtk+ graphical user interface library.  https://hackage.haskell.org/package/gtk-0.15.3 (HamishMackenzie)
05:26:27 <MarcelineVQ> Ye you should restart after editing profile, I always restart after editing .bashrc as well because it never seems to update my terminals otherwise :X
05:26:38 <Guest_90> kk
05:27:01 * ski uses `source'
05:27:31 <MarcelineVQ> source just doesn't seem to work for me for whatever reason, it's never been a mystery needing solving however
05:27:49 <ski> mhm
05:28:28 <MarcelineVQ> If you solve all the mysteries they fire you beause the work's done.
05:30:47 <Guest_90> ChaiTRex it doesnt work
05:30:58 <Guest_90> command not found
05:31:07 <ChaiTRex> Guest_90: Does this have new stuff on it: printenv PATH
05:31:39 <Guest_90> no
05:31:57 <Guest_90> or maybe yes
05:32:09 <Schrostfutz> In my code I import Data.Map, which makes map ambiguous. Is there a way to avoid this and by default still get Prelude.map?
05:32:13 <ChaiTRex> Guest_90: Does it have anything with .cabal in it?
05:32:13 <Guest_90> it doesn't cabal anywhere
05:32:24 <ChaiTRex> Guest_90: Oh, anything else new?
05:32:39 <mniip> Schrostfutz, import qualified Data.Map
05:33:06 <mniip> most containers modules are supposed to be imported qualified
05:33:10 * ski . o O ( "The Mysteries of Counting" by John Baez in 2005-07-14 at <http://math.ucr.edu/home/baez/counting/> )
05:33:10 <merijn> Schrostfutz: All of containers (including Data.Map) is intended to be imported qualified
05:33:13 <mniip> as are things like text and bytestring
05:33:21 <Guest_90> I think .../usr/sbin:/sbin: is new
05:33:42 <Guest_90> but I'm not sure
05:33:50 <Schrostfutz> mniip, merijn: Ah, I see. 
05:34:12 <merijn> Schrostfutz: Normally "import qualified Data.Map as M"
05:34:14 <MarcelineVQ> ski: what prompted that link?
05:34:21 <merijn> Schrostfutz: So you can write "M.map" etc.
05:34:23 <Schrostfutz> This apparently then also applies to operators, s.t. I need to write e.g. Data.Map.!. Is that necessary?
05:34:33 <mniip> M.!
05:34:49 <Guest_90> I mean technically I could copy past those lines that made it work everytime I want to work with haskell can't I?
05:35:06 <mniip> yes because every other module has a ! operator
05:35:17 <merijn> Schrostfutz: You can use "as" to alias the qualification. You can also import twice "import Data.Map (Map, (!)); import qualified Data.Map as M" so you can use the Map type and ! directly and qualify the rest
05:35:33 <mniip> (in our codebase we rarely use qualified imports, rather we import Data.List as L, and use L.map if needs be)
05:35:50 <merijn> mniip: Which ! are you talking about?
05:36:05 <Guest_90> ChaiTRex: What were those lines that made it work earlier?
05:36:51 <mniip> merijn, Data.Map.!, Data.Set.!, Data.HashMap.!
05:36:53 <mniip> to name a few
05:37:08 <merijn> That's hardly "all" :p
05:37:10 <mniip> wait, set has no !
05:37:13 <ChaiTRex> Guest_90: OK, we can do the ugly nonupdating method: remove the source line from ~/.profile, replace it with: export PATH="$HOME/.cabal/bin:$HOME/.ghcup/bin:$PATH"
05:37:34 <ChaiTRex> Guest_90: Make sure to copy and paste.
05:38:41 <ChaiTRex> Guest_90: That should be the line that fixes it.
05:39:02 <ChaiTRex> Guest_90: Either in ~/.profile (and then a reboot) or in the shell itself.
05:40:40 <Guest_90> I'll reboot then
05:44:55 <Guest_90> ChaiTRex typing it into ~/.profile didnt seem to work, but typing into shell works. I'll just have to copy paste everytime
05:46:10 <ChaiTRex> Guest_90: 
05:46:23 <ChaiTRex> Guest_90: Oh, that's too bad.
05:47:02 <ChaiTRex> Guest_90: I'm not sure what macOS has changed to make it not work. Sorry.
05:47:26 <Guest_90> ChaiTRex Still thanks, helped me a lot :)
05:47:27 <MarcelineVQ> sure you don't need .bash_profile ?
05:47:58 <Guest_90> I'll try it MarcelineVQ
05:49:40 <Guest_90> Oh yes, bash_profile worked
05:49:43 <Guest_90> thx
05:50:03 <svipal> does any of you use representable functors, and if yes, in what contexts ?
05:51:02 <MarcelineVQ> conal does for sure, he's not here just this moment though
05:51:42 <svipal> It feels like a really cool thing I'd been ignoring
05:54:30 <MarcelineVQ> svipal: https://hackage.haskell.org/package/MemoTrie uses them, memoization is their main feature (iiuc)
05:54:40 <MarcelineVQ> there's blog posts here http://conal.net/blog/tag/trie
05:55:15 <MarcelineVQ> edwardk has some replies in those posts (or at least one) so he could tell you more, e.g. http://conal.net/blog/posts/memoizing-polymorphic-functions-via-unmemoization#comment-775
06:07:14 * hackage graphql-api 0.4.0 - GraphQL API  https://hackage.haskell.org/package/graphql-api-0.4.0 (teh)
06:11:55 <svipal> Will read up, thanks
06:29:46 <jumper149> Hi I want to parse a time from a bytestring and want to use `parseTimeM` from Data.Time.Format but it needs a String instead of a ByteString
06:30:12 <jumper149> How do I convert it?
06:30:25 <merijn> jumper149: Do you know the encoding of the ByteString? (Or are you willing to assume UTF-8?)
06:32:04 <jumper149> It's from pcap packet so I guess its UTF8?
06:32:17 <jumper149> What if I just use `show` on the bytestring?
06:32:47 <merijn> jumper149: That's not what you want. Data.Text.Encoding has decoding functions from ByteString to Text. Once you have Text you can simply do T.unpack
06:33:00 <merijn> jumper149: show will add quotes/escape characters
06:35:00 <jumper149> I just found it its ascii but since i now know it should be fine :) ty
06:35:42 <merijn> jumper149: You can treat ascii as UTF-8, so :)
06:36:06 <jumper149> it even says so on hackage x)
06:50:03 <merijn> There's no way to access the type of exception in onError, right?
06:50:19 <merijn> i.e. I need to catch SomeException and rethrow if I want that?
07:15:03 <boxscape> With lenses, is it more common to write lens1.lens2 or lens1 . lens2?
07:15:21 <merijn> I prefer the second
07:16:07 <dminuoso> boxscape: Its down to personal preference.
07:16:24 <boxscape> but what's more common? :P
07:17:00 <boxscape> I find it kind of difficult to actually find projects that use lenses at whose source code I could look
07:17:08 <boxscape> not sure I would go about looking for them
07:21:28 <tdammers> lens1 . lens2 is what I would use
07:21:51 <tdammers> simply to avoid the quasi-ambiguity with . as a module name separator
07:24:09 <boxscape> I suspect . might get more ambiguity in the future; there's a proposal right now to make it work for OOP style record field selection
07:25:01 <dminuoso> boxscape: You can use hackage's reverse dependency search.
07:26:55 <boxscape> Ah, nice
07:27:04 <tdammers> "OOP style"? lol
07:27:35 <boxscape> Well, I'm calling it that
07:27:36 <merijn> boxscape: Keep in min that lots of proposals don't get accepted
07:28:03 <boxscape> yeah, that's why I said "might" and "suspect" :)
07:32:56 <dminuoso> With TH, is there ways to generate whitespace, such as to influence the output of -ddump-splices?
07:33:40 <boxscape> (hm, I haven't found a single project that uses the lens1.lens2 style so far)
07:38:42 <EvanR> oop style. Power-of-the-dot
07:43:18 <merijn> boxscape: Objective argument against "lens1.lens2" is that you can't always write all legal compositions like that, but you can write them all with the spaces
07:43:35 <merijn> So with the space style you can always use the same consistent style
07:43:46 <boxscape> merijn can you give an example for a composition you can't write with it?
07:43:59 <merijn> > Just . even $ 5
07:44:01 <lambdabot>  Just False
07:44:03 <merijn> > Just.even $ 5
07:44:04 <lambdabot>  error:
07:44:05 <lambdabot>      Not in scope: ‘Just.even’
07:44:05 <lambdabot>      No module named ‘Just’ is imported.
07:44:06 <boxscape> ah, right
07:48:10 <tdammers> I've adopted a style that puts whitespace around *all* operators, except in operator sections
07:49:07 <boxscape> I find that math terms like 2*x + x*y can be more readable if you don't put whitespace around tighter binding operators
07:49:48 <tdammers> maybe so, but I don't think of this as a compelling enough argument to make an exception to the rule
07:49:59 <boxscape> that's fair
07:50:11 <tdammers> also, what if you have more than two different fixities in your expression? which level do you write in "tight" style?
07:50:39 <boxscape> depends on the exact situation
07:51:01 <ariakenom> 2  +  2 * x^2
07:51:04 <ariakenom> :p
07:52:19 <barrucadu> I'm sure I've seen an (esoteric?) language which uses spaces like that instead of parentheses for order of operations
07:52:32 <merijn> Forth?
07:52:42 <merijn> oh, wait, no
07:52:44 * hackage type-errors-pretty 0.0.1.0 - Combinators for writing pretty type errors easily  https://hackage.haskell.org/package/type-errors-pretty-0.0.1.0 (shersh)
07:52:53 <merijn> I was thinking RPN
07:53:17 <Taneb> barrucadu: someone suggested it at ICFP2017 for Haskell
07:53:25 <dsal> RPL was my first true love.
07:54:00 <merijn> Taneb: That person subsequently disappeared and was never seen again? >.>
07:55:17 <barrucadu> Disappeared to become a GHC contributor, perhaps
07:56:05 <AWizzArd> I like to use TVars with maps inside and other simple data structures. What I also like is that I can store hundreds and thousands of versions of my map. At any point in time I can revert back to a previous version, and this works in microseconds.
07:56:34 <boxscape> merijn btw, a data constructor couldn't be used as a lens though, right? (or maybe there's some obscure way?) So at least module name ambiguity doesn't cause a problem if you never use whitespace for lens composition and always for composition of other things?
07:56:35 <AWizzArd> Now: what can I do if my data set is 7 Terabytes? Is there a way to map a tvar and Maps and Vectors and such to a disk?
07:57:02 <merijn> boxscape: Lens uses the same (.) as function composition, so I use the same thing for everything
07:57:11 <boxscape> yeah, that makes sense
07:57:13 <merijn> AWizzArd: Yes, it's called "a database" ;)
07:57:45 <AWizzArd> merijn: which database besides Datomic will store all versions for me and allows me instantly to go back to any version, without loosing the others?
07:58:13 <merijn> Eh, any of them if that's how you operate on them? >.>
07:58:48 <AWizzArd> merijn: I have a postgres DB right now. How can I run a select on the db as it was 7 months ago?
07:59:12 <merijn> AWizzArd: Tag every row with an insertion timestamp?
08:00:04 <AWizzArd> merijn: I insert (a, 10) then (b, 20) then (c, 30) then do an update of "a" which leads to the insertion of (a, 40) and then (d, 50).
08:00:34 <AWizzArd> If I now demand the timestamp between (a, 40) and (d, 50), how will I ensure that this works nicely?
08:00:52 <merijn> AWizzArd: Anyway, if the question is "Can I somehow directly use STM/TVar's with data on disk" then the answer is "hell no"
08:00:53 <AWizzArd> There can be thousands of versions of a, b, c and d.
08:01:03 <AWizzArd> merijn: okay, that was my question.
08:01:12 <merijn> Unless "implement your own STM backed database from scratch" is an acceptable way of doing it
08:01:22 <merijn> (it probably shouldn't be >.>)
08:01:26 <AWizzArd> I guess what Datomic did was to do exactly that, implemented an stm and tvars on top of a DB.
08:01:55 <merijn> AWizzArd: How often/many changes does this data get?
08:02:09 <merijn> And what sort of queries do you do?
08:03:33 <AWizzArd> merijn: I think I will have a lot of key/value pairs, something similar to Redis. But I want to be able to go back to any version. Think of Datomic.
08:04:13 * geekosaur implemented a very limiteed version of this for testing once, and that was bad enough. "any version" means arbitrarily large change logs
08:04:27 <geekosaur> you can model this as transactions but that has its own penalties
08:05:18 <lortabac> AWizzArd: do you want to go back to a previous snapshot of the whole database or just of a specific value?
08:06:00 <AWizzArd> lortabac: any complete snapshot. As if I would be using a TVar. With a TVar I can dereference the hashmap in it and store it in a vector. And after each transaction I deref the TVar again and also store that.
08:06:29 <AWizzArd> I would end up with a vector that has tens of thousands of hashmaps, which all share most of the memory.
08:07:11 <AWizzArd> But I don't know how good this would work with the GC times and stop-the-world if I had a 200 GB Hashmap and keep 400k copies of it.
08:07:16 <AWizzArd> "copies"
08:08:05 <geekosaur> this also sounds confused about TVars, this sounds like something an MVar could do just as well as it's not related to retry semantics, only mutex semantics
08:08:07 <merijn> AWizzArd: Do you know about CompactRegions?
08:08:26 <AWizzArd> geekosaur: yes, an MVar could do the same, but doing transactions works nicely with TVars.
08:08:48 <AWizzArd> merijn: I know about it. They sound good to circumvent the GC for read-only data. But this DB might/will change.
08:08:56 <lortabac> if you didn't have performance constraints, I would tell you to use an event-sourcing database
08:09:03 <merijn> AWizzArd: The past bits won't, no?
08:09:15 <merijn> Like, that's the entire point
08:09:54 <AWizzArd> merijn: the past wouldn't change, that's correct. But the core chunk of the DB, that 200 GB part, this would have to sit in the live memory.
08:10:23 <AWizzArd> lortabac: which one for example? And what you mean by performance constraints? It's clear that hundreds of GB or TB won't perform as nicely as a 40 MB TVar in RAM.
08:11:35 <lortabac> AWizzArd: recomputing the state requires applying a "fold" computation on past events, which can be expensive (it depends on the nature of the data and the queries you want to perform)
08:11:49 <lortabac> AWizzArd: for example EventStore
08:13:26 <geekosaur> that's not the model I understood them to be using, though. they store a snapshot of the whole db, relying on sharing over changes. basically trading space for time
08:13:56 <geekosaur> so every snapshot is fast but there's potentially a lot of memory in play if enough stuff changes over time
08:14:15 <lortabac> geekosaur: yes, I was proposing an alternative model
08:15:54 <dsal> Any lens experts here?  I want to up my expertise.  Something between simple property stuff and the super magic thing I did with biplate that I'll never understand.
08:17:01 <Goriya> heyy!!
08:17:22 <ariakenom> dsal: for inspiration you can maybe look at these examples https://github.com/ChrisPenner/lens-regex-pcre
08:18:03 <AWizzArd> geekosaur: in an ideal world I would have terabytes of RAM and could simply use a (TVar (Map String Value)) and after each transaction store the dereferenced Map along with timestamp data and a version number.
08:18:15 <dsal> I've got a list of a record that has a list of a sum type where one value is a record.  This is a parsed java stack dump (I built a parser for a friend and realized it's a pretty good thing for working with lenses.  e.g.:  ts ^. ix 0 . stack . ix 0 . _AStackFrame . method
08:18:43 <AWizzArd> I could then go back and select for keys in the past, I could start new branches as in git. Essentially like git, but all in ram and nice and quick.
08:22:24 <AWizzArd> merijn: some other question: if I have a Map that I copied to a compact region, and save it to a file, is there an easy route to "query" that Map without actually loading it into RAM?
08:22:53 <merijn> I don't think so?
08:22:56 <AWizzArd> That is, operate on the map via disk access.
08:23:09 <AWizzArd> Yeah, I guess there is no trivial solution.
08:23:44 <ariakenom> dsal: nice
08:23:44 * hackage lazy-search 0.1.2.1 - Finds values satisfying a lazy predicate  https://hackage.haskell.org/package/lazy-search-0.1.2.1 (JonasDuregard)
08:24:15 <dsal> I might be thinking lens is too magical, but is it reasonable to do something like for every Thread where [some condition], I want all the AStackFrame values?   [[StackFrame]] ?
08:25:15 <ariakenom> is storing a compact region to a file easy?
08:26:02 <ariakenom> dsal: That sounds be doable, although you will be getting into "dangerous" lenses
08:26:06 <merijn> ariakenom: Yes
08:26:06 <dsal> Or maybe even the methods...  biplate actually seems slightly easy to use, but too magical.  StackLine is    DumbTextStuff | AStackFrame     This is all pretty straightforward in regular code.  I just want to see how much lens magic I can do.
08:26:36 <dsal> ariakenom: Sure.  I want to learn something slightly more than I know now.  Like maybe, filter all the stacks to remove DumbTextStuff things.
08:26:56 <dmwit> :t filtered
08:26:57 <lambdabot> (Choice p, Applicative f) => (a -> Bool) -> Optic' p f a a
08:27:33 <dmwit> ariakenom: The README has a pretty nice overview. tl;dr: yes, it's easy https://github.com/ezyang/compact
08:28:25 <dmwit> Oh, I guess Hackage has README's too, these days, so I could have linked there instead.
08:29:00 <geekosaur> has had them for a while now. at least ever since hackage2
08:29:06 <Goriya> Hi to everyone who helped me a call to see the attachment file and import and I have to go back and the other side of things to say the least expensive way of getting the error please immediately contact me know what to say the least expensive
08:29:38 <Goriya> The posts and the knowledge to be the same thing happened in a couple weeks to go back in the day of my life with the following link unsubscribe from these guys have any further information or to your account
08:29:49 <geekosaur> is this a markov bot?
08:29:59 <Goriya> No
08:30:20 <ariakenom> and it's possible to not break if you read it from a different program invocation. nice
08:30:29 <Goriya> I have a great day ahead of the story never marry me know what the problem is
08:30:29 <ariakenom> although many ifs on that part
08:30:42 --- mode: ChanServ set +o geekosaur
08:34:21 <dsal> I don't quite understand filtered...    ts ^.. filtered . _    where ts is a [Thread] wants a [Thread].  I assume that's because it made a list of one Thread each to mconcat, but how does one write a test for a field value here?
08:34:30 <dsal> e.g.    _threadState == Runnable   ?
08:42:16 <ariakenom> dsal, something sort of like this: ts ^.. filtered (t -> (t ^. _threadState) == Runnable) . _
08:43:35 <AWizzArd> With that new concurrent GC - will the main effect be that the latency will be reduced? That there will be shorter and/or fewer stop-the-world phases?
08:43:36 * geekosaur assumes a missing \ in there
08:44:23 <dsal> Yeah, I get the idea.  I'll give that a go.
08:45:19 <dsal> I'm afk at the moment, but trying to find more usage docs.
08:45:58 <ariakenom> pointless: (Runnable==) . view _threadState
08:46:29 <ariakenom> AWizzArd: sure
08:47:04 <nshepperd2> dsal: I would guess that filtered actually filters the targeted item itself
08:47:16 <AWizzArd> ariakenom: for example back then, when Pusher worked on their app, they saw pause times of 50 msecs. From the graphs they have shown it looked as if per second about four of such 50 msecs stops occurred.
08:47:38 <AWizzArd> ariakenom: in other words: 20% of their runtime was spent stopping the world.
08:48:01 <nshepperd2> dsal: so if you want to filter the elements of a list ts, you'd do ts ^.. traverse . filtered (\t -> _threadStats t == Runnable) . _ 
08:48:10 <AWizzArd> If we would add more data, then two things might happen: there could be more than four such phases or each can take longer or both.
08:48:55 <AWizzArd> Does the new GC just distribute this differently? Still 20% of my runtime is spent pausing the world, but it won't occur four times but fourtY times instead, and each pause is now 5 msecs instead of 50.
08:49:04 <geekosaur> that was my expectation aas well, not sure what dsal was thinking
08:49:29 <nshepperd2> > [1..10] ^.. traverse . filtered even
08:49:31 <lambdabot>  [2,4,6,8,10]
08:49:36 --- mode: geekosaur set -o geekosaur
08:50:29 <ariakenom> AWizzArd: the throughput is less. so more than 20%. not sure how much more ofc
08:51:20 <AWizzArd> ariakenom: okay, I see. And it would probably suffer in a comparable way as soon not 200 MB are used but instead 2 GB or 20 GB.
08:52:13 <AWizzArd> If I really want to make use of a lot of RAM I would have to do manual memory management and just have one single huge array, and serialize/deserialize to/from it.
08:52:41 <merijn> AWizzArd: Well, the reason I brought up compact regions is that they're "free" when it comes to GC
08:53:07 <AWizzArd> ariakenom: would you agree that if I had one single 1 TB array that it would cost essentially zero GC time, if that was my own live value? The GC would see if there still is a reference to that array (which there is), and be done.
08:53:46 <merijn> The "problem" is that GHCs standard "copy & compact" GC doesn't deal well with huge live sets. But compact regions are allocated outside of the normal heap so don't have to be traversed, so their impact on the entire GC is simply a single pointer
08:54:10 <merijn> AWizzArd: Right, your description is exactly what compact regions do for you
08:54:15 <AWizzArd> merijn: yes, they sound pretty good. I am thinking about creating a distributed DB, where most of the DB is stored in a compact region and the rest is managed by changelogs, and for transactions there is one central transaction manager.
08:55:42 <AWizzArd> merijn: the vast majority of the values of such a key/value store wouldn't change often. Some keys however might change very often.
08:55:53 <ariakenom> is GC usually a problem though? when I've checked my programs it's been single digit percents
08:56:00 <merijn> ariakenom: "It Depends"
08:56:04 <AWizzArd> It's really tricky, there is no clever solution on the market. Datomic is the only one trying to work in this field.
08:56:33 <merijn> ariakenom: GC is always a trade off, the trade offs made in GHCs GC means that programs with huge livesets are painful
08:56:49 <AWizzArd> ariakenom: for me the question is how it will affect the program if I have many many gigabytes, and the GC would have to traverse it, only to discover that nothing needs to be collected.
08:57:25 <AWizzArd> I would love to communicate that there are no other references to any of the values. This map is really the only single owner of the data, and GC please don't check it.
08:57:45 <merijn> ariakenom: Basically, GHC uses copy & collect, so when you run out of heap, you allocate a new heap and copy every "live" value from the old heap to the new one. The advantage is that the amount of "garbage" doesn't impact GC time. Lazy languages like Haskell allocate A LOT and most of those allocation die quickly
08:57:49 <mniip> what is inside the map?
08:57:55 <AWizzArd> Linear or dependent types. Then this could possibly be done.
08:58:32 <dsal> nshepperd2: thanks. Maybe a good example to keep be busy would start with [(1, [Just 1, Nothing, Just 3]), (2, [Nothing, Just 4])]. -- can I filter out Nothings?  Bonus: even fsts?
08:58:35 <AWizzArd> mniip: I assume right now that it is a (TVar (Map String Value))
08:58:38 <merijn> ariakenom: The advantage of copy & collect is that all "free" space is always at the end of the heap, so you just need to keep a pointer where that is and allocation is simply increasing that pointer
08:58:51 <mniip> yuck
08:58:59 <ariakenom> if your data is very "generational" GHC would probably like you
08:59:08 <mniip> you could roll manual memory management if you wanted to
08:59:12 <merijn> ariakenom: So allocation becomes *super* cheap (which also works well if you allocate a lot of stuff that dies fast
08:59:22 <ariakenom> as in most of your data dies young
08:59:23 <AWizzArd> mniip: this is what I am considering. Just one giant array.
08:59:36 <mniip> I meant more along the lines of malloc/free
08:59:45 <merijn> ariakenom: GHC actually uses a bit more complex where it has several generations of heaps, yes
08:59:49 <AWizzArd> mniip: ah okay, that would also be available in Haskell?
08:59:53 <mniip> yes
09:00:09 <mniip> haskell has very strong C interop
09:00:17 <mniip> you could allocate any kind of structure a C function would expect
09:00:20 <AWizzArd> mniip: can you tell me the name of the corresponding package? I could consider it, because it is extremly constraint data and I have great control over it.
09:00:23 <mniip> base
09:00:26 <AWizzArd> I just don't want to suffer from GC times.
09:00:27 <mniip> Foreign.Marshall.*
09:00:38 <merijn> ariakenom: Now, this works well for *most* programs, but as you can imagine if you have a live set of several GB this means copying several GB *each* GC, which of course ruins performance
09:01:09 <mniip> you could have a map where writing to a map dismantles the haskell value and allocates a bunch of buffers
09:01:16 <ariakenom> merijn: are the old generations copied too?
09:01:19 <mniip> and reading from the map walks those buffers and constructs a haskell value
09:01:25 <ariakenom> in my mind they werent
09:01:31 <merijn> ariakenom: There's "minor" and "major" GCs
09:01:43 <mniip> (you won't get either reading or writing for free)
09:01:45 <AWizzArd> mniip: is there any kind of "duplication" going on with this?
09:01:52 <merijn> ariakenom: major GCs operate on *everything* minor only on the youngest 1 or 2 generations, iirc
09:02:01 <mniip> temporarily yes
09:02:12 <ariakenom> merijn: I thought they were non-copying
09:02:17 <mniip> at some point you will have two copies of the particular element of the map you're working with
09:02:18 <merijn> ariakenom: minor GCs can also happen independently
09:02:39 <merijn> ariakenom: For more detailed answers consult ghc-devs@ and #ghc ;)
09:02:53 <mniip> another thing to look into could be compact regions
09:03:05 <AWizzArd> mniip: so as long I am storing very trivial pieces of data then this explicit malloc/free approach might work.
09:03:13 <mniip> yes
09:03:23 <AWizzArd> mniip: the compact regions are read only. I need to update the values behind the keys.
09:03:29 <mniip> create new regions
09:03:53 <ariakenom> merijn: there were some good wiki pages or similar iirc
09:03:56 <AWizzArd> mniip: if I have a 100 MB Map and want to move it to a compact region, then for a short amount of time two times 100 MB will exist in RAM, right?
09:04:10 <mniip> nono
09:04:13 <mniip> I meant
09:04:20 <mniip> Map String (Compact Value)
09:04:28 <mniip> as opposed to (Compact (Map String Value))
09:04:41 <ariakenom> GHC seems to have a mark-weep strategy too https://gitlab.haskell.org/ghc/ghc/wikis/garbage-collector-notes
09:04:43 <AWizzArd> mniip: I think that wouldn't work, because I want to keep _all_ versions.
09:04:53 <AWizzArd> mniip: So the Compact has to be on the outside.
09:04:57 <mniip> ?
09:05:12 <nshepperd2> dsal: you want to get out something like  [(1, [1, 3]), (2, [4])]?
09:05:23 <mniip> what do you mean keep and what do you mean versions
09:05:32 <nshepperd2> dsal: basically catMaybes on the second items?
09:05:56 <AWizzArd> mniip: Ideally I would want to have a ton of key/value pairs in a TVar. As soon I finished a transaction I dereference the TVar and store the Map in a vector, along with a version number and timestamp.
09:06:22 <AWizzArd> mniip: I could then make 400k transactions and store all 400k versions of that map.
09:06:38 <AWizzArd> mniip: within a few microseconds I could run lookups on any version that I want.
09:06:40 <mniip> for some reason I thought Value meant an aeson value i.e. a tree of its own
09:07:09 <AWizzArd> mniip: well yeah, it could indeed be aeson-like. Possibly even exactly that one, so trees might be possible as well.
09:07:45 <mniip> so keys/values are never freed?
09:07:59 <AWizzArd> mniip: but the nice thing is that I could update my TVar (i.e. knowledge base) with aggregated data. But then I want to test new rules and simply go back in time and test the rules against old versions of the DB.
09:08:15 <AWizzArd> mniip: it is possible that a key/value pair gets totally deleted inside a transaction.
09:08:26 <AWizzArd> mniip: but: only in the newest version
09:08:39 <AWizzArd> mniip: like Datomic: each delete/update results in an insert.
09:08:56 <mniip> right but the value is still referenced from an older revision
09:09:02 <mniip> so it has to be kept in memory
09:09:08 <dsal> nshepperd2: Yeah.  Except it's my own prism in this case.
09:09:10 <AWizzArd> mniip: well, a delete just remove it from a certain version on. But all values that were ever assumed will exist forever.
09:09:19 <mniip> ok
09:09:38 <AWizzArd> mniip: what could happen though is that at some point I decide to give up the oldest 30k of my 400k versions.
09:09:38 <dsal> Well, maybe just   [(1, [Just 1, Just 3]), (2, [Just 4])]
09:09:40 <mniip> sounds like you need a write-only store of keys and values
09:09:46 <AWizzArd> Then that information would truly be lost
09:09:48 <mniip> then everything else can index into that store
09:09:49 <merijn> mniip: Well, yes
09:10:00 <merijn> That was his question :p
09:10:13 <AWizzArd> mniip: yes, it is essentially write only. But so that all versions are available.
09:10:22 <mniip> nono you don't understand
09:10:36 <AWizzArd> mniip: we could do this easily with a (TVar (Map String Int)) with 10 key/value pairs.
09:10:52 <mniip> it's a vector mapping from an artificial int to a value
09:11:07 <mniip> then your "Map" would contain those artificial ints
09:11:13 <AWizzArd> mniip: artificial int as in "timestamp"?
09:11:24 <mniip> no, sequential id or whatever
09:11:53 <AWizzArd> mniip: but how could I then query this store?
09:12:01 <mniip> by index
09:12:28 <mniip> what I'm saying is, instead of Map Key Value, you get Map Int Int
09:12:39 <mniip> and separately a store that is effectively Int -> Key and Int -> Value
09:12:52 <nshepperd2> dsal: i'd do that as a map of something else instead of trying to do it all in one magical lens
09:13:02 <AWizzArd> mniip: let's say I will insert (a, 10) at second 0, then one sec later I add (b, 20) and a sec later (c, 30) and a sec later I now update a to 40 and then add at second four I add (d, 50). Now I wait 10 seconds and say: give me the DB contents of second 7.
09:13:19 <AWizzArd> The DB contents would be: {a: 40, b: 20, c: 30, d: 50}
09:13:29 <AWizzArd> But at second 7 there was no operation.
09:13:43 <nshepperd2> dsal: like, over (traverse . _2) (\maybes -> maybes ^.. traverse . filtered isJust)
09:13:51 <AWizzArd> If I wanted the DB of second 2.5 I wcould get: {a: 10, b: 20, c: 30}
09:14:02 <mniip> that sounds irrelevant to the question
09:14:15 <mniip> Map Timestamp (Map Key Value) or whatever
09:14:52 <mniip> actually
09:14:59 <mniip> just add all values to a compact
09:15:09 <mniip> and refer to the compactified values from the map
09:15:19 <mniip> as long as the compact is alive the values will be alive
09:15:27 <mniip> I'm not sure how that affects GC walking though...
09:16:49 <AWizzArd> Let's say I have several versions: 1 {a: 10},   2 {a: 10, b: 20},   3 {a: 10, b: 20, c: 30}    4 {a: 40, b:20, c:30}    and  5  {a: 40, b: 20, c: 30, d: 50}.
09:17:29 <AWizzArd> so for each I could have this monotonically increasing counter 1-5. And I can associate it with a certain timestamp.
09:17:34 <dsal> nshepperd2: Thanks.  My first attempt that seemed to at least do something.  heh   over (traverse . filtered (\x -> x ^. threadState == Runnable) . stack) (\st -> st ^.. traverse .filtered isStack) ts
09:18:14 <mniip> AWizzArd, ok?
09:18:15 <AWizzArd> mniip: you would want to store the values 10, 20, 30, 40 and 50 all in a (very tiny) compact region.
09:18:29 <mniip> as well as {a, b, c, d} probably
09:19:17 <dsal> nshepperd2: I guess one more question if you don't mind.   I wrote the isStack function, but is there a way I can do that with the generated prism?  _AStackFrame ?
09:19:26 <svipal> Are infinite streams distributable ?
09:19:28 <AWizzArd> mniip: what Map would reside in memory?
09:20:19 <dsal> > over (traverse . _2) (\maybes -> maybes ^.. traverse . filtered isJust) [(1, [Just 1, Nothing, Just 3]), (2, [Nothing, Just 4])]
09:20:20 <mniip> all of them?
09:20:21 <lambdabot>  [(1,[Just 1,Just 3]),(2,[Just 4])]
09:20:34 <AWizzArd> mniip: I mean outside of a compact region.
09:20:45 <mniip> the map from timestamps to maps from keys to values
09:22:05 <AWizzArd> mniip: So each time when I want to "update" a value I will have to copy the whole versioned map from a compact region into RAM. Then I can update that Map and copy it back. If the Map is some GBs in size then this operation would take a good while.
09:22:22 <mniip> no
09:22:30 <mniip> ythe map is not in the compact region
09:22:49 <mniip> the map is in the regular haskell heap and so the update can be succinct
09:23:15 <nshepperd2> dsal: yeah
09:23:48 <nshepperd2> > [Just 1, Nothing, Just 3] ^.. traverse . _Just
09:23:50 <lambdabot>  [1,3]
09:24:06 <AWizzArd> mniip: my assumption was this: at pusher they have shown that 200 MB of live data means that 20% of a second was spent stopping the world. They had 4 stops of 50 msecs per second.
09:24:37 <AWizzArd> mniip: now when the latest version of the map has to reside in RAM, and we try to store 100x as much data, then it would still not help going around the GC issue.
09:24:42 <ariakenom> AWizzArd: the data is not that simple. it matters how you use that data
09:24:49 <mniip> depends on how big the individual allocations are
09:24:52 <nshepperd2> > [Just 1, Nothing, Just 3] ^.. traverse . _Just . re _Just -- dsal: use re to put the constructor back after using the prism
09:24:54 <lambdabot>  [Just 1,Just 3]
09:24:57 <mniip> the larger the chunks the easier it is to walk them
09:25:05 <mniip> everything inside a compact region is like a single chunk
09:25:16 <dsal> nshepperd2: Right, but that gets rid of the Maybe, so I can't write that back to the same structure.  I did find that, but not quite right.    But thanks, you got me pretty far along.  :)
09:25:55 <c_wraith> note that pusher's data comes from before compact regions were added. 
09:26:19 <dsal> This seems to be the one giant magic lens:  over (traverse . filtered (\x -> x ^. threadState == Runnable) . stack) (\st -> AStackFrame <$> st ^.. traverse . _AStackFrame) ts
09:26:33 <c_wraith> also, compact regions aren't traversed at all. if any of it is live, the whole thing is. 
09:26:34 <AWizzArd> c_wraith: yes, for me the numbers were interesting. I can't just copy the 20 GB map into a compact region because I need to update the map.
09:28:33 <EvanR> are compact regions moved during gc or are they pinned
09:28:45 <svipal> lol 
09:28:51 <EvanR> or "somthing something mmap"
09:29:45 <merijn> EvanR: Pinned
09:29:57 <EvanR> 20GB index structure, back in my day that would immediately imply B-trees on a rotating disk
09:30:11 <merijn> EvanR: Creating the compact region effectively forces a "copy&compact" on just the value you're compacting
09:30:12 <mniip> these days you can fit 1TB in RAM
09:30:28 <EvanR> i know you can fit stuff in ram, but a copying GC doesn't make much sense
09:30:29 <merijn> EvanR: Afterwards the compact pointer is treated as a GC root
09:30:35 <mniip> AWizzArd, how about this you create a new compact region for the entire map, every n seconds?
09:30:44 * hackage yeamer 0.1.0.2 - Yesod-based server for interactive presentation slides  https://hackage.haskell.org/package/yeamer-0.1.0.2 (leftaroundabout)
09:30:47 <c_wraith> note that there's some work in progress to add a mark+sweep collector to ghc, which lets you reduce gc latency in exchange for throughput. 
09:30:47 <merijn> EvanR: If you don't consider anything else then it doesn't, no
09:31:03 <svipal> I don' t understand collect from distributives
09:31:04 <phadej> you can add data to existing compvt region
09:31:06 <merijn> EvanR: The reason GHC has copy&compact is to make allocation cheap
09:31:12 <mniip> if the map is huge with relatively few changes per update, make n huge
09:31:22 <c_wraith> merijn: a root? that seems off. it's more like a leaf. 
09:31:31 <EvanR> copy&collect is also easy to implement
09:31:36 <EvanR> yeah a root?
09:31:39 <kuribas> I wish there was a way to disable warnings on a line by line level
09:31:52 <merijn> c_wraith: I'm just copying terminology from the blags!
09:32:01 <kuribas> So I could explicitly disable a shadowing warning above a line.
09:32:06 <mniip> if the current state of the map is huge and you can't copy it from one region to another in realtime, you can "prefire" and create a region ahead of time and populate it concurrently
09:32:09 <EvanR> the deal with compact regions is ... they can't point out of the region right
09:32:10 <mniip> with a switchover when needed
09:32:12 <phadej> so of updates are rare and rewrite only few things, adding things migjt work oit
09:32:44 <nshepperd2> :t has _Just
09:32:45 <lambdabot> Maybe b -> Bool
09:34:49 <EvanR> if you have so much memory that 20G map is chump change... it's like... why do you even need to gc :)
09:34:52 <c_wraith> EvanR: correct. all pointer inside must be internal. also, fully evaluated as a consequence thereof. 
09:34:58 <dsal> Oh wait, this isn't filtering out the runnables, it's only editing the runnables.
09:35:20 <merijn> EvanR: Because else the sysadmins start yelling at you :p
09:35:33 <EvanR> in any case seems like you could gc less often
09:36:10 <merijn> I once tried to plot a few million points of data using Chart. Got a miffed email if I could stop my programs from allocating >100GB. That's how I learned Chart doesn't really scale well with big inputs :p
09:36:43 <EvanR> if nobody gets OOM killed it's fine right
09:36:58 <merijn> EvanR: It slows down the NFS serving
09:37:10 <EvanR> NFS... gawd
09:37:10 <merijn> (due to evicting stuff from caches)
09:37:15 <mniip> SSD swap is amazing
09:37:33 <merijn> EvanR: What would you use instead of NFS?
09:37:37 <mniip> I can run GHC *and* chromium at the same time
09:37:58 * EvanR is not a distributed wonk
09:38:35 <merijn> EvanR: I'm not really doing distributed stuff either, but it's nice that your home directory works on every machine in the cluster
09:38:51 <EvanR> active directory :)
09:39:30 <merijn> AD doesn't take care of file shares, that'd be SMB, but SMB on *nix is still kinda...meh
09:40:14 * hackage yeamer 0.1.0.3 - Yesod-based server for interactive presentation slides  https://hackage.haskell.org/package/yeamer-0.1.0.3 (leftaroundabout)
09:40:21 <fendor_> do pattern gaurds and case guards compose?
09:40:33 <merijn> fendor_: What do you mean by that?
09:40:59 <fendor_> for example: case ... of x | Proj1 <- x, Proj2 <- x -> 1
09:41:17 <EvanR> <- and -> in the same sentence
09:41:24 <EvanR> i can hear the torches and pitchforks now
09:41:42 <fendor_> not my mistake if the syntax is supported :P
09:41:53 <fendor_> or that it kind of would make sense in my opinion
09:42:50 <merijn> fendor_: Works fine
09:43:03 <fendor_> hm, maybe haskell-ide-engine just chokes
09:43:44 <merijn> fendor_: I'm about 90% sure I've used that
09:44:10 <AWizzArd> mniip: I think the only solution that will scale nicely is to do manual memory management in an array, and inside it re-implement a STM and a functional data structure.
09:44:21 <fendor_> to be fair, it looks kind of disgusting without the perfect layouting. I think I will resort to predicates nevertheless
09:45:05 <fendor_> yeah, it works fine, thanks! error was something different
09:45:17 <AWizzArd> With all those nice STMs in Haskell or Clojure, etc - I really don't know how useful they are, if they only work for data sets of just a few MB or few hundred MB.
09:45:40 <fendor_> but holy burrito, syntax in haskell can look horrifying
09:45:44 <wintermuteai> Hi - I have a start up architecture plan in .NET...I would like to move it to Haskell before I start coding. Is someone willing to chat about libraries/databases/framework choices that would be sensible with me please? PM help is greatly appreciated
09:46:20 <EvanR> #haskell-boardroom
09:46:35 <EvanR> just kidding, probably doesn't exist
09:47:11 <wintermuteai> lol, my main problem is it'll be on AWS. It would help to chat to someone who haskells more then me to avoid pitfalls :)
09:48:46 <fendor_> i would love a #haskell-boardroom. 
09:51:44 * hackage persist 0.1.1.4 - Minimal serialization library with focus on performance  https://hackage.haskell.org/package/persist-0.1.1.4 (minad)
09:52:44 * hackage paripari 0.6.0.1 - Parser combinators with fast-path and slower fallback for error reporting  https://hackage.haskell.org/package/paripari-0.6.0.1 (minad)
09:59:49 <svipal> I can't wrap my head around DIstributive Functors really. I understand what distribute does but I really don' t understand how to write an instance for it
10:08:08 <Ariakenom> I found out hc only does copying gc by default. my memory banks were corrupted
10:08:15 <svipal> Like how do I even get "inside" the argument of the function ?
10:08:22 <Ariakenom> s/hc/ghc/
10:25:31 <svipal> got it
10:51:58 <hololeap> i've got another question about this code. if BoxId is a type synonym, how is it also providing a constructor for primaryKey? http://dpaste.com/22T8K3N
10:53:03 <hololeap> oh, wait i think i get it now
10:53:43 <jle`> mniip: i have seen it i think
10:54:49 <jle`> mniip: or, well, checking it out now, it looks like i was thinking of something else. but i have seen it now, at least :)
11:16:48 <dsal> I'm a little sad.  All the things I wanted to do were just worse with lens.  I'll find the way it saves me life before too long, I guess.
11:17:48 <svipal> Hahahahaa
11:18:48 <merijn> hololeap: That's a data family (rather than a type family) :)
11:19:41 <merijn> dsal: FWIW, after 10+ years of Haskell I still haven't really used lens for anything non-trivial (and even then it's mostly other people's lensy APIs) :p
11:21:17 <EvanR> you must be avoiding serious use of nested records 
11:25:49 <merijn> EvanR: Generally yes
11:26:09 <EvanR> i tried representing a game world as a sum of product of sum of product of ...
11:26:18 <EvanR> couldn't get anywhere without lens
11:26:40 <EvanR> which was the worst part 
11:27:33 <dsal> heh.  This project is a tuple with a list of records that has a list of a sum with a record.  It seemed ideal.
11:28:36 <dsal> Filtering out the stuff at that prism seemed cool until I wanted to do stuff with the data and needed the case to exist anyway just for completeness.
11:30:10 <EvanR> these are the hells we create for ourselves :)
11:32:29 <svipal> Is it possible to do a declaration such as data Test a = Test a  :> a :> Test a
11:33:08 <svipal> putting two ":>" in a declaration always gives me an error
11:33:23 <svipal> (I know the "normal" way to do such a decl, but I'm curious)
11:33:53 <merijn> svipal: No, constructors need to be a single token
11:36:52 <svipal> mm
11:50:57 <dignissimus> When should I use `when` statements as opposed to if statements?
11:52:07 <merijn> dignissimus: 1) they're not statements, but expressions, and 2) they're really not comparable
11:52:13 <merijn> :t when
11:52:15 <lambdabot> Applicative f => Bool -> f () -> f ()
11:52:29 <merijn> dignissimus: Note that you can only use "when" with Applicatives
11:52:46 <wildtrees> dignissimus, I usually use when's inside of do blocks for monadic code 
11:53:10 <merijn> dignissimus: if/then/else on the other hand works any place an expression works
11:53:54 <merijn> dignissimus: Note that if/then/else is more like the "ternary" expression you find in other languages, both in the fact that it is an expression AND the fact that the else branch is *not* optional
11:54:28 <merijn> > (if True then 2 else 3) + 5
11:54:31 <lambdabot>  7
12:09:37 <dmwit> hololeap: Did you see my comments yesterday on that code?
12:13:06 <koz_> I have a binary build of GHC, and I want to notify its ./configure where it can find LLVM stuff. How do I do this again?
12:14:12 <merijn> koz_: ./configure usually supports --help
12:14:31 <koz_> merijn: I recall being told by someone it needs an environment variable, which --help doesn't explain.
12:14:37 <merijn> ah
12:14:43 <merijn> koz_: Try #ghc?
12:14:53 <koz_> (that's literally the first thing I tried, and the --help from ./configure for _any kind of_ GHC is missing like, half its options at least)
12:14:57 <koz_> merijn: I will thanks.
12:16:35 <mniip> I think I found something very big
12:16:43 <merijn> koz_: Patches welcome? ;)
12:17:11 <mniip> I invite everyone to take a look at these two type families and tell me what is the difference between them https://gist.github.com/mniip/1930d7a36f20d00a4d2d68f0e5495058
12:18:28 <merijn> One blows up? Compiles 10x more efficiently?
12:18:34 <merijn> <- just guessing
12:18:54 <mniip> the second one compiles 3x faster and with 3x less memory
12:19:13 <merijn> ok, so basically what I was thinking, yeah
12:19:42 <merijn> mniip: So you basically invented type-level loop unrolling? ;)
12:20:29 <mniip> imagine if jump was very expensive
12:20:36 <mniip> loop unrolling would be effective
12:21:52 <merijn> mniip: Nothing says fun like reverse engineering your compiler!
12:22:22 <mniip> if I understand correctly, every type family reduction adds a coercion on top of a coercion tree
12:22:31 <mniip> and then the compiler has to drag that around
12:28:14 * hackage predicate-transformers 0.5.0.0 - A library for writing predicates and transformations over predicates in Haskell  https://hackage.haskell.org/package/predicate-transformers-0.5.0.0 (edmundnoble)
12:29:00 <dmwit> mniip: I left a comment; I wonder, out of curiosity, how it compares for your test case.
12:30:57 <dmwit> Ah, it can be done better.
12:33:21 <mniip> dmwit, KnownBool :: Bool -> Constraint
12:33:26 <mniip> I think yours is a kind error
12:34:56 <dmwit> Well, my KnownBool is k -> Constraint.
12:35:03 <dmwit> So if it works for my KnownBool, it must work for yours.
12:35:44 * hackage context-free-art 0.1.0.0 - Generate art from context-free grammars  https://hackage.haskell.org/package/context-free-art-0.1.0.0 (414owen)
12:35:46 <dmwit> I posted a deforested version, by the way.
12:36:43 <mniip> dmwit, vice versa
12:37:08 <mniip> um
12:37:11 <mniip> what does your new TF even do
12:37:19 <mniip> it just loops infinitely
12:38:04 <Lears> Needs a singleton case.
12:38:14 <dmwit> Oh, yeah, needs another base case.
12:38:15 <mniip> yeah
12:38:29 <dmwit> I just went with "it compiles, it must work". I should have known better.
12:39:19 <dmwit> Seems to work ok with an extra KnownBools '[b] = KnownBool b line in the obvious spot.
12:40:09 <dmwit> Oh, yeah, the first version was broken, too. Wow, lern2test
12:44:22 <mniip> dmwit, insignificant improvement
12:44:33 <mniip> as in, there's no statistical significance
12:44:52 <mniip> as far as I can tell you're doing more tf reductions, not fewer
12:45:56 <Guest_25> jarrive pas a installer Haskell sur mon mac ???
12:47:31 <Guest_25> I can't  install Haskell on Mac 
12:48:38 <dmwit> mniip: Ah, I see. I had a wrong cost model in my head... and probably still do. Neat, thanks!
12:49:17 <dmwit> Guest_25: What are you using to try to install it? What error do you see?
12:49:43 <dmwit> Guest_25: You can use a pastebin online for the error. Then send us a link. Please do not paste it in-channel.
13:05:42 <dignissimus> How could I improve this? https://hastebin.com/yucuqotecu.hl
13:05:57 <dmwit> Guest_25: You might also want to try #haskell-fr
13:07:05 <jle`> mniip: unsettling
13:07:17 <dmwit> dignissimus: Instead of `case length result of ...`, consider `case result of [] -> ...; [x] -> ...; _ -> ...`
13:07:36 <dmwit> `[x] -> show x`, specifically
13:09:18 <dmwit> dignissimus: I think normally your gut reaction should be to use foldl' instead of foldl, though here specifically I'm not sure it matters much.
13:09:31 <dmwit> dignissimus: Other than that, this code looks pretty nice to me. Simple and readable.
13:10:01 <mniip> now if only I could throw this tyfam out altogether
13:10:03 <dmwit> dignissimus: Of course it can be made more robust in a number of ways.
13:10:04 <mniip> but it doesn't add up
13:10:59 <merijn> dignissimus: I'd replace the length on line 12 with pattern matching directly
13:11:48 <dmwit> dignissimus: e.g. in a production app, you'd want to use `Maybe` or `Except` to track errors in `executeCalculation` such as the stack being emptier than needed or a parse failure.
13:12:00 <merijn> dignissimus: https://paste.debian.net/1107152/
13:12:04 <merijn> like that
13:12:23 <merijn> dmwit: Also, haskeline so you could edit typos ;)
13:12:37 <dmwit> right! =)
13:13:03 <merijn> dmwit: I replaced my input query logic with haskeline at some point and it's the best change I ever made
13:15:29 <dmwit> rlwrap for when you have 0 programmer resources and don't mind it being a little janky ;-)
13:20:20 <EvanR> so
13:20:31 <EvanR> can you use haskeline without a terminal gui ? :)
13:21:03 <merijn> EvanR: It has a "terminal interaction" and "file interaction" mode
13:21:23 <merijn> EvanR: Default is to auto-detect stdin and decide based on that which to use
13:21:56 <merijn> EvanR: Wait, what did you mean by "without a terminal gui"?
13:23:04 <dignissimus> On my end I was able to re-do the case expression so it matches directly against the result but I'm stuck at how to make the executeCalculation function safer
13:23:20 <merijn> dignissimus: Text.Read.readMaybe is a start
13:23:27 <merijn> :t Text.Read.readMaybe
13:23:28 <lambdabot> Read a => String -> Maybe a
13:23:40 <merijn> > Text.Read.readMaybe "foo" :: Maybe Int
13:23:42 <lambdabot>  error:
13:23:42 <lambdabot>      Not in scope: ‘Text.Read.readMaybe’
13:23:42 <lambdabot>      No module named ‘Text.Read’ is imported.
13:23:54 <merijn> @let import Text.Read (readMaybe)
13:23:56 <lambdabot>  Defined.
13:23:58 <merijn> > Text.Read.readMaybe "foo" :: Maybe Int
13:24:00 <lambdabot>  Nothing
13:24:04 <merijn> > Text.Read.readMaybe "53" :: Maybe Int
13:24:07 <lambdabot>  Just 53
13:24:41 <EvanR> merijn: like, my app uses SDL, opengl, or something else and i still want haskelline
13:24:50 <EvanR> because it's that awesome
13:24:57 <merijn> EvanR: Ah, then no, I think?
13:25:52 <dignissimus> If I wanted to pass a reason for why execution failed, could I match for `Nothing` and have the stack be an `Either` with Left being an `[Int]` and Right being an error message?
13:26:20 <koz_> merijn: OPT and LLC apparently.
13:26:33 <koz_> (and that's been docced, but only as of GHC 8.10)
13:26:50 <wildtrees> dignissimus, usually Left is the error message and Right is a nonerror value 
13:27:04 <merijn> dignissimus: That, or you can replace getLine with an action that loops until it gets either 1) ":q" or 2) a number (with appropriate error)
13:28:10 <EvanR> :(
13:29:37 <sternmull> I am reading this: https://wiki.haskell.org/Typeclassopedia#Instances Aren't the descriptions of tuples and functions flipped? ((,) e) is (,e) and not (e,)... right?
13:30:05 <merijn> sternmull: ((,) e) is (e,)
13:30:13 <jle`> sternmull: (/) 3 is (3 /)
13:30:19 <jle`> > (/) 3 2
13:30:21 <lambdabot>  1.5
13:30:39 <sternmull> oh, i am stupid. Of course!
13:31:02 <jle`> map negate == (negate `map`)
13:31:06 <jle`> sternmull: definitely not stupid :)
13:31:48 <sternmull> i used that syntax many times before and just didn't read carefully
14:12:39 <devalot> What's a good way to encode something like "Binary a OR ToJSON a =>"?  My instinct is to create a class then provide default instances for Binary and ToJSON but that produces errors about undecidable instances.  Any suggestions?
14:14:36 <geekosaur> this sounds like IfCxt
14:15:10 <geekosaur> (in general, no, there's no good way to do this; it requires a runtime witness and runtime checking, but instance resolution is at compile time)
14:34:17 <devalot> I guess I'll just write more newtype wrappers then :(
14:44:06 <dmwit> devalot: I'd make a new class (say, HasWireFormat or Serializable or something), two newtype wrappers for Binary and ToJSON, then use the new DerivingVia stuff to give one-line instances for all the types you care about.
14:44:49 <dmwit> If you can't use DerivingVia for back-compat reasons, then you can use DefaultSignatures to make one or the other of Binary and ToJSON the default, and provide method implementations for the non-default one so that again instances are just one line.
14:45:32 <devalot> dmwit: Thanks
14:49:00 <kiwi_34> I have an RWS monad that I've defined with Control.Monad.RWS.lazy and a call to iterateM that is supposed to be run lazily, but is not. I had it previously defined with a Control.Monad.State.Lazy State before needing to pass a config and write a log, and it worked then. Could anyone help me figure out why?
14:49:01 <kiwi_34> https://gist.github.com/charleskinbote/2ec0d369cf389f2cd163c692b4e95de5
14:50:59 <dmwit> Well, your first step should be to minimize as much as possible.
14:53:05 <dmj`> > flip execState True (id %= not)
14:53:07 <lambdabot>  False
15:00:00 <lambdabot> FALSE
15:01:48 <dmj`> FALSE!
15:02:14 <dmwit> YOU CAN'T HANDLE THE TRUE!
15:03:14 <dmj`> https://www.youtube.com/watch?v=MMzd40i8TfA
15:13:09 <kiwi_34> dmwit it may be a cop-out but I decided to define a strict version of iterateM that stops after `n` evaluations. My guess is that the underlying RWS monad instance does something strict that the State monad doesn't, I don't really feel like delving into that
15:17:21 <dmwit> kiwi_34: Actually, come to think of it, it's probable the writer bit that's being unfortunate. Did you try ReaderT r (AccumT w (StateT s m)) as an alternative to RWST r w s m?
15:17:47 <kiwi_34> I have not tried that
15:19:34 <kiwi_34> dmwit what about the writer is is that's giving you pause
15:19:43 <kiwi_34> what is it about that writer*
15:22:52 <dmwit> https://blog.infinitenegativeutility.com/2016/7/writer-monads-and-space-leaks
15:25:21 <jle`> don't use laziness for iterateM for stateful monads
15:25:27 <jle`> that's just asking for trouble
15:25:43 <Guest_55> hey guys
15:25:47 <Guest_55> what is this:
15:25:48 <Guest_55> In order to run ghc and cabal, you need to adjust your PATH variable.You may want to source '/Users/gabe/.ghcup/env' in your shellconfiguration to do so (e.g. ~/.bashrc).Detected ~/.bash_profile on your system...If you want ghcup to automatically fix your ~/.bash_profile to include the required PATH variableanswer with YES and press ENTER (at your
15:25:48 <Guest_55> own risk).
15:26:01 <jle`> the difficulty in reasoning with laziness in *effects* is well-known, and is one of the reasons we have streaming effects libraries
15:26:07 <Guest_55> I get this after trying to install ghcup
15:26:11 <kiwi_34> jle` do you have any alternatives in mind?
15:26:24 <jle`> kiwi_34: iterateM with a given number n is good
15:26:46 <kiwi_34> even if that iterateM is itself lazy?
15:26:53 <kiwi_34> with that new argument, i mean
15:27:09 <dmwit> iterateM with stateful monads is fine if you don't look at the resulting state.
15:27:14 * hackage hw-hedgehog 0.1.0.5 - Extra hedgehog functionality  https://hackage.haskell.org/package/hw-hedgehog-0.1.0.5 (haskellworks)
15:27:18 <jle`> the thing is that whenever you use >> or >>=, you should assume that you are strict in effects
15:27:42 <jle`> so if you do iterateM with 100x, that means that the effect would be sequence 100x
15:27:50 <jle`> even if you only ever get the first value in the resulting list
15:28:20 <jle`> dmwit: 'don't touch at the resulting state' sort of gets in the way of how one would naturally use stateful monads
15:28:26 <Guest_55> guys?
15:28:32 <jle`> Guest_55: what part do you not understand, exactly?
15:28:36 <Guest_55> Like
15:28:48 <dmwit> jle`: Depends. It can still be useful to produce an infinite list in a stateful way.
15:28:57 <ChaiTRex> Guest_55: Is this macOS?
15:29:00 <jle`> it can be useful, yeah, but so can lazy IO
15:29:03 <Guest_55> What does it do? Will it screw with my path? And yes, MacOS
15:29:10 <jle`> it just...breaks all the normal semantics you would normally associate with state
15:29:33 <dunce> hello again
15:29:42 <dunce> I have a short question 
15:29:53 <dmwit> jle`: It definitely doesn't break semantics in the way lazy IO does.
15:30:10 <jle`> hm, maybe i should say it breaks expectations
15:30:11 <MarcelineVQ> it says it will screw with your path, you can let it do that for you or your can screw with your path yourself :>
15:30:14 * hackage hw-parser 0.1.0.2 - Simple parser support  https://hackage.haskell.org/package/hw-parser-0.1.0.2 (haskellworks)
15:30:17 <jle`> it can be useful, but you're basically playing with fire
15:30:26 <ChaiTRex> Guest_55: Try editing ~/.bash_profile with a line at the bottom that says: source /Users/gabe/.ghcip/env
15:30:31 <jle`> you have to be careful with everything you do, so it doesn't blow up in your face
15:30:41 * dmwit nods agreeably
15:30:43 <dunce> say i have data Shape int = Circle radius  
15:30:49 <ChaiTRex> Guest_55: That'll update the PATH with a few paths to GHC and Cabal stuff.
15:31:20 <jle`> if you really want a principled way to deal with iterating effectfully in a stateful monad, you can use a streaming effects library like pipes or conduit
15:31:26 <dunce> and some function fiz (circle r)  = , whats the syntax called to call another function using that input to the function?
15:31:26 <jle`> in this specific case that would be a little overkill
15:31:38 <jle`> fiz (Circle r), probably
15:31:48 <dunce> like fiz (circle r) = buzz(circle r)
15:31:50 <jle`> what do you mean by another function, exactly?
15:31:56 <jle`> yeah, nothing wrong with that
15:32:16 <jle`> but remember that your constructor is Circle, not circle
15:32:17 <dmwit> fiz (Circle r) = buzz (Circle r) is fine.
15:32:26 <dmwit> fiz shape = buzz shape is fine, too.
15:32:38 <dunce> ah
15:32:56 <dunce> i am in fact a dunce, my method signatures where conflicting, int and integer
15:32:58 <dunce> thanks
15:33:44 <Guest_55> The problem I get is on the next step of downloading Haskell
15:34:34 <Guest_55> When I run "curl -sSL https://get.haskellstack.org/ | sh", I get "Stack has been installed to: /usr/local/bin/stack", but also  "WARNING: '/Users/g/.local/bin' is not on your PATH.    For best results, please add it to the beginning of PATH in your profile."
15:34:44 * hackage hw-packed-vector 0.2.0.1 - Packed Vector  https://hackage.haskell.org/package/hw-packed-vector-0.2.0.1 (haskellworks)
15:35:20 <MarcelineVQ> You'll want to do that too, if you plan to use stack.
15:35:46 <jle`> kiwi_34: fwiw if you want to directly translate your lazy iterateM to conduit, you'd do something like:
15:36:11 <MarcelineVQ> Guest_55: any particualr reason why you're getting both ghcup and stack?
15:36:42 <jle`> nthCtx <- runConduit $ C.iterate step ctx .| (C.drop n .| C.head)
15:36:43 <Guest_55> https://www.haskell.org/platform/mac.html
15:36:43 <MarcelineVQ> Not that it's a problem I'm just curious, since stack can fetch ghc already
15:37:00 <Guest_55> Says to "The recommended way to install the components of the mac platform is using ghcup to install ghc and cabal-install, and following the instructions at haskellstack.org to install stack."
15:37:00 <jle`> nthCtx <- runConduit $ C.iterate step ctx .| (C.drop n >> C.head)
15:37:13 <jle`> (typo)
15:37:26 <kiwi_34> thanks jle`, conduit is new to me so I'll give it a look
15:37:36 <jle`> again it's definitely overkill if you just want to iterate something n times
15:37:54 <jle`> it's more useful if you have a bunch of similar effectful iterating things that you want to chain
15:37:56 <Guest_55> MarcelineVQ: Should I just install one?
15:38:01 <kiwi_34> ok, makes sense
15:38:27 <jle`> basically if you wanted to 'port' something like map f . foldr g x . filter p . iterate h $ x
15:38:39 <jle`> it might be a little messier to make monadic in a way that preserves laziness in effects
15:38:40 <MarcelineVQ> I see, I guess if the platforms include both that makes sense for conformity but that's weird to have a user do without explanation. Guest_55 it depends what you're going to use, I'm guessing this is for a course or something, should probably get everything just in case.
15:38:52 <jle`> conduit makes it easier to compose streaming combinators like that in an effectful situation
15:39:03 <jle`> but in this case you just have one thing you want to do, so just an iterateM-with-length should be good :)
15:40:14 * hackage hw-streams 0.0.0.12 - Primitive functions and data types  https://hackage.haskell.org/package/hw-streams-0.0.0.12 (haskellworks)
15:41:30 <Guest_55> MarcelineVQ: Yeah.. SMT Solver. Alright. So I should both add the line "source /Users/gabe/.ghcip/env" to bash_profile and do what in order to silence the second Warning, aka "WARNING: '/Users/g/.local/bin' is not on your PATH.    For best results, please add it to the beginning of PATH in your profile."
15:43:26 <MarcelineVQ> It says what to do, you can google that last sentence or I can get an example I guess if you're lazy :> I don't really use source so ChaiTRex is the guy to listen to for specifics on that one.
15:44:49 <MarcelineVQ> it could look like  export PATH=/Users/g/.local/bin:$PATH  or possibly  export PATH=$HOME/.local/bin:$PATH
15:45:40 <MarcelineVQ> Which says: define a new PATH, placing a specific path at the start and adding the old ones afterwards
15:46:47 <Guest_55> MarcelineVQ: I already did google it, nothing to do with laziness, just would really rather not screw my path up. I'll figure  it out, thank-you for your help
15:48:27 <MarcelineVQ> shapr: is this your doing? getting everyone to learn SMT solvers?
16:08:21 <dunce> could someone offer me a hint for this problem?
16:09:54 <dunce> I need to traverse a tree to the tip, recording the path in a list i.e. [L,R,L,R,R] along with the value stored in the tip, so (a, [L,L]), (b, [l,r]), and so on
16:10:46 <dunce> I have a snippit that gets the path to each tip, I'm just not sure how to pair that with the right data in the tip
16:27:43 <jle`> dunce: paste your snippet :)
16:29:27 <dunce> yea 
16:29:29 <dunce> it uh
16:29:35 <dunce> doesnt work like i thouht lol
16:29:53 <dunce> </3 
16:30:12 <jle`> ah, well, paste it anyway :) it's good to see what you have tried
16:30:25 <jle`> so that we can give suitable advice
16:31:16 <shapr> MarcelineVQ: wasn't me, but I'll gladly take credit!
16:35:36 <wroathe> Patricia tries are just black magic
16:35:45 <wroathe> I've decided
16:37:13 <Rembane> wroathe: What lead you to make that decision?
16:37:49 <wroathe> Staring at the code in IntSet for the past few hours trying to reason through what a C implementation might look like in my head
16:38:04 <wroathe> Might be time for a pen and paper
16:39:24 <Rembane> I think it is. If you can grab a rubber duck or colleague and a whiteboard it might help you even more. 
16:39:45 <dunce> pathb :: BTree a -> [[Bool]]pathb (Leaf _) = [[]]pathb (Fork (Leaf _) r) = map (True:) (pathb r)pathb (Fork l (Leaf _)) = map (False:) (pathb l)pathb (Fork l r) = [False] ++ pathb l ++  [True] ++ pathb r
16:39:48 <dunce> uh
16:39:55 <dunce> are there code blocks in irc
16:39:55 <pikajude> ah yes, indeed
16:39:58 <pikajude> no
16:40:07 <pikajude> that's a slack or discord or gitter thing, just use a pastebin
16:40:10 <dunce> can I make this more readable
16:40:13 <dunce> oh
16:40:18 <pikajude> i know lpaste used to be a thing, but i think it's gone now
16:40:25 <pikajude> ah yeah, the topic says to use gist now
16:41:07 <dunce> https://gist.github.com/FreezeSnail/1afe619be41937cd56a8457bb424bcc8
16:41:14 <dunce> like that?
16:41:38 <dunce> that gives me a type error
16:43:04 <dunce> im working on fixing that rn 
16:43:08 <dunce> think I almost have it
16:52:50 <jle`> dunce: i believe in you :)
16:54:22 <dunce> pathb (Fork l r) =  map (((False:) pathb l) ++ ((True:) pathb r))
16:54:30 <dunce> its just this that im having trouble with rn
16:54:37 <dunce> paths (Bin l x r) = map (x:) (paths l ++ paths r)
16:55:09 <dunce> that works for getting each node's data, but i cant figure out how to get the left or right branch instead 
16:55:10 <jle`> you might have forgotten a map on the second half of the first line
16:56:05 <dunce> I already tried that 
16:56:05 <dunce> pathb (Fork l r) =  (map (False:) pathb l) ++ (map (True:) pathb r)
16:56:10 <dunce> same problem
16:56:22 <jle`> maybe you mean map (False:) (pathb l) ?
16:56:25 <dunce> Couldn't match expected type ‘[[Bool]]’                  with actual type ‘BTree a1 -> [[Bool]]’
16:56:54 <dunce> ok
16:56:56 <dunce> can
16:57:04 <dunce> you explain to my pea brain why that bracketing works
16:57:26 <jle`> `pathb l` is a list, right?
16:57:33 <jle`> and `(False:)` is a function, right?
16:57:41 <jle`> so if you want to map a function over a list, it's like this: `map myFunction myList`
16:57:52 <jle`> or in this case, `map (False:) (pathb l)`
16:58:45 <dunce> ok I guess that makes sense
16:59:06 <jle`> what you were trying to do before was (map (False:) pathb) l
16:59:11 <jle`> which is, try to map (False:) over pathb
16:59:17 <jle`> but you can't do that, because pathb is not a list
16:59:33 <dunce> ok theres implicit bracketing
16:59:36 <dunce> ill remember that
16:59:57 <jle`> dunce: yeah, you don't have to consider it bracketing, just that's how it's interpreted as
17:00:20 <jle`> if haskell sees `f x y z`, it's interpreted as ((f x) y) z
17:00:27 <jle`> apply x to f, then y to the result, then z to the result
17:03:00 <dunce> ok
17:03:01 <dunce> my
17:03:47 <dunce> base cases where unnecessary, the pathing works now.  So now I just need to pair it up with the right data in each tip
17:15:40 <dunce> jle` thanks so much, I think this is working now
17:15:46 <jle`> congrats :D
17:27:30 <dunce> now I just have one problem left lol
17:27:37 <dunce> think this might be a tomorrow problem
17:31:14 * hackage hw-xml 0.4.0.2 - XML parser based on succinct data structures.  https://hackage.haskell.org/package/hw-xml-0.4.0.2 (haskellworks)
17:38:54 <lightandlight> So I've been playing around with extensible effects in polysemy, and I kinda think I should be able to write this: `mergeWriters : Sem (Writer a ': Writer b ': r) -> Sem (Writer (Either a b) ': r)`. Thoughts?
17:40:58 <lightandlight> eh, maybe just ignore me
17:41:36 <Axman6> if you had (a,b) then sure
17:41:40 <Axman6> I think
17:44:08 <lightandlight> I got the types wrong anyway
17:46:16 <lightandlight> What I was thinking was combining a `Writer [a]`and `Writer [b` into a `Writer [Either a b` in a way that preserves ordering, but you can't do that. `[Either a b]` is richer; you can do `[Either a b] -> ([a], [b])`, but you lose some information and can't reverse it
17:47:03 <lightandlight> So I guess I'll have classy prisms hooked up to my writer
17:48:06 <MarcelineVQ> What information do you lose?
17:48:59 <lightandlight> MarcelineVQ: you lose the interleaving of the `a`s and `b`s
17:49:14 <MarcelineVQ> I see
17:51:14 * hackage dual 0.1.0.1 - Dual category  https://hackage.haskell.org/package/dual-0.1.0.1 (MatthewFarkasDyck)
18:04:44 * hackage alg 0.2.12.0 - Algebraic structures  https://hackage.haskell.org/package/alg-0.2.12.0 (MatthewFarkasDyck)
18:09:14 * hackage dual 0.1.0.2 - Dual category  https://hackage.haskell.org/package/dual-0.1.0.2 (MatthewFarkasDyck)
18:12:29 <dmj`> Is it cool if I put absolute paths from the Windows operating system in a cabal file, I forgot if this was kosher to do
18:12:44 * hackage category 0.2.4.2 - Categorical types and classes  https://hackage.haskell.org/package/category-0.2.4.2 (MatthewFarkasDyck)
18:12:52 <dmj`> like C:\Program Files\foobah
18:15:54 <dmwit> I think absolute paths are basically not kosher, no matter what OS they come from.
18:17:09 <jusss> there's a famous website called RN, but I forget what its full name, it's a big black stone like in the movie space odyssey 2001, anyone know that name?
18:17:25 <jusss> there's lots of implements with lots of languages
18:18:33 <dmwit> rosetta stone?
18:19:01 <dmj`> dmwit: I have a lib like hmatrix, and I saw hmatrix does this in a few places:  extra-lib-dirs:     /opt/local/lib/openblas/lib
18:19:03 <jusss> dmwit: yeah
18:19:07 <dmj`> but it has a default paths flag
18:19:08 <jusss> http://rosettacode.org
18:19:20 <dmj`> to enable or disable this behavior
18:19:40 <dmwit> dmj`: Yeah, that's probably not really right either.
18:20:12 <dmwit> dmj`: If you want to do it right, you likely have to write a custom Setup.hs.
18:20:22 * dmj` *gasps*
18:20:32 <dmj`>     if os(linux)
18:20:32 <dmj`>         if flag(openblas)
18:20:32 <dmj`>             if !flag(disable-default-paths)
18:20:32 <dmj`>                 extra-lib-dirs:     /usr/lib/openblas/lib
18:20:39 <dmwit> It might be possible with build-type: configure? But I don't know what that means on Windows.
18:20:41 <dmj`> is the hmatrix way of doing things apparently
18:20:55 <isovector1> lightandlight: you can definitely do that with Outputs
18:22:04 <isovector1> censor and pass might throw a wrench into the works
18:49:19 <dmj`> dmwit: I'll probably just do it the way hmatrix does it... most users will install the package with the quick installer and it will go into this default location, but will do the disable thing in case nix people (those evil nix people) want to get all custom
18:57:30 <siraben> Is there a way to do unsafe pointer arithmetic in Haskell?
18:58:44 <siraben> http://ix.io/1YNz
18:58:53 <siraben> See the line that says "a' <- mapIndices (d, f - m) (+ m) anArray 0"
18:59:07 <siraben> I want to do the C equivalent of "a_prime = anArray + m;"
18:59:08 <dmj`> siraben: plusPtr
18:59:37 <jusss> https://rosettacode.org/wiki/Sockets#Haskell
18:59:46 <jusss> where i can find Network package?
18:59:51 <siraben> dmj`:  how would that line look with plusPtr?
19:00:48 <dmj`> let newPtr = somePtr `plusPtr` m
19:00:49 <jusss> `main = withSocketsDo $ sendTo "localhost" (PortNumber $ toEnum 256) "hello socket world"' just one line, it seems so wonderful
19:00:59 <dmj`> you'd need to extract the pointer from the underlying vector
19:01:21 <monochrom> If you don't have a pointer to start with, you can't do pointer arithmetic.  No, an array is not a pointer.  Unless the array library you chose happens to expose in its API a "give me the pointer behind" operation.
19:02:05 <siraben> Ah. Hm.
19:02:28 <siraben> Are arrays in Haskell contiguous?
19:02:33 <monochrom> Yes.
19:02:50 <monochrom> Doesn't mean they have to expose their pointers behind, though.
19:03:34 <monochrom> Likewise Double is not an 8-byte array.
19:04:05 <monochrom> Welcome to strongly typed high-level languages!
19:04:37 <siraben> Haha, moving from monad transformers to imperative programming in Haskell, doesn't feel like the same langauge
19:04:38 <siraben> language*
19:07:41 <siraben> monochrom:  Am I using mapIndices correctly?
19:07:45 <siraben> To sort of emulate this pointer arithmetic.
19:10:04 <dmwit> siraben: Why not just pass a low and high index into the array instead of just its size?
19:10:54 <siraben> dmwit:  Ah, because I'm translating a C function into Haskell just as an exercise; http://ix.io/1YNF
19:11:24 <dmwit> I don't think that actually answers my question.
19:11:50 <dmwit> Also, I don't think return does what you think it does in Haskell.
19:12:31 <siraben> dmwit:  To answer your question: sure, I could pass a low and high index
19:12:50 <siraben> Yeah it has the type return :: a -> m a
19:12:52 <monochrom> This is an inefficient XY-problem use of mapIndices.
19:13:45 <monochrom> I would recurse over simple indexes too.
19:14:16 <monochrom> But even then it is going to be fairly slow and there is no cure.
19:14:32 <monochrom> I mean no cure unless you change to another array library.
19:15:10 <siraben> I see.
19:15:15 <dmwit> I suppose you could also just operate on Ptr's instead of STArray's.
19:15:34 <dmwit> monochrom: Why slow?
19:15:47 <dmwit> Just boxing, or do you have some other concern?
19:16:06 <monochrom> Firstly STArray supports arbitrary element types and laziness so it is an array of pointers to elements, not an array of elements.
19:17:09 <monochrom> Secondly raw pointer arithmetic is unsupported so you are forced to loop/recurse over simple indices therefore you keep doing (start + index*elementsize) all the time.
19:17:32 <dmwit> whaaa
19:17:43 <EvanR> save index*elementsize to a PtrDiff
19:17:44 <dmwit> You definitely do not.
19:17:59 <dmwit> Oh.
19:18:01 <dmwit> Okay, maybe you do.
19:18:08 <EvanR> er
19:18:15 <dmwit> Neat! Gross.
19:18:41 <monochrom> (Compare to C and Fortran compilers which will do loop invariant code motion etc therefore "i++" becomes "currptr += elementsize" in asm code.)
19:19:04 <monochrom> (and "a[i]" becomes "currptr")
19:19:05 <dmwit> monochrom++ for thinking of this detail
19:19:10 <EvanR> is a Ptr boxed... guessing yes
19:19:16 <koz_> Is there a reason why this isn't rewritten using vector instead?
19:19:18 <monochrom> I took a bloody code optimization course >:)
19:19:28 <koz_> monochrom: Vampires love your code then.
19:19:35 <EvanR> you can still do curPtr += elemSize
19:19:37 <EvanR> manually
19:19:57 <monochrom> Yeah but you can't do curptr += elemsize if you're using STArray.
19:20:22 <EvanR> does STArray not have a "recursor" or something implemented in C
19:20:36 <monochrom> Or maybe STArray has a freeze-to-pointer function I forgot.
19:20:40 <dmwit> koz_: Vector is just passing low and high indexes around for you. =P
19:20:50 <monochrom> No.
19:21:00 <dmj`> unsafeWith :: Storable a => Vector a -> (Ptr a -> IO b) -> IO b
19:21:09 <koz_> You don't even need the low and high - just slice it, then smash the slice flat.
19:21:10 <dmj`> storable vectors are great
19:21:24 <dmwit> koz_: How do you think the slice is implemented? Go take a look, and you will see I am right.
19:21:48 <koz_> dmwit: I believe you.
19:22:06 <monochrom> slice has the same [in]efficiency as mapIndices.
19:22:18 <dmwit> No, it's better than mapIndices.
19:22:21 <monochrom> because very similar implementations.
19:22:26 <dmwit> mapIndices is O(n), slice is O(1).
19:22:39 <monochrom> Oh, true, mapIndices is probably too general.
19:23:13 <monochrom> Aww siraben accidentally wrote a quadratic time summer!
19:23:38 <dmwit> I think n log n?
19:23:55 <siraben> monochrom:  Oof, that's worst than I thought!
19:24:12 <monochrom> Ooops just n log n yeah.
19:24:18 <siraben> Better define sumList = foldr (+) 0, or even better, sumList = sum
19:24:30 <monochrom> Aww I accidentally overcounted time complexity!
19:24:41 <siraben> Why n log n?
19:25:06 <monochrom> mapIndices spends time proportional to array length.
19:25:28 <monochrom> But/And your recursion is halving like mergesort.
19:25:49 <dmwit> How annoying. Arrays offer lots of operations for bulk creation, but none for bulk consumption.
19:25:50 <siraben> Ah, right.
19:26:22 * EvanR looks at the Array Foldable instance
19:26:28 <monochrom> Because Array was invented way before the vector fusion paper. >:)
19:26:35 <dmwit> EvanR: UArray don't got it
19:26:50 <EvanR> what is U, unboxed?
19:26:56 <monochrom> Yeah, unboxed.
19:27:08 * EvanR looks at Vector Foldable
19:27:36 <monochrom> Keep in mind there are like 3 kinds of "Vector"s.
19:28:49 <koz_> Four technically, if you consider Prim and Unboxed as different.
19:28:54 <dmwit> EvanR: Same complaint, unboxed vectors don't got it
19:29:06 <monochrom> Oh oops, yeah.
19:29:19 <dmwit> There is foldr and friends for unboxed vectors, though.
19:29:21 <dmwit> I wonder how they work.
19:29:23 <koz_> (they're not really - Unboxed is just a wrapper around Prim with more generality)
19:29:26 <monochrom> Also API existence doesn't imply efficiency.
19:29:47 <koz_> monochrom: Are there any online notes/lecture slides/recordings of your bloody code optimization course?
19:29:59 <koz_> I too would like to know how to write vampire-positive code. :P
19:30:09 <monochrom> It was a long time ago so no.  But let me find a recently one I know of.
19:30:15 <koz_> monochrom: Thanks!
19:30:34 <dmwit> Haha! foldr works by iterating an index.
19:30:51 <dmwit> So even vector doesn't really offer bulk consumption operations in the sense I meant!
19:31:02 <EvanR> monochrom: i was just wondering how efficient the instance was.. and this is a rabbit hole
19:31:04 <koz_> dmwit: Patches welcome then? :P
19:31:20 <dmwit> koz_: I doubt it's possible. Vectors are wrappers around arrays, and arrays don't got it.
19:31:40 <koz_> dmwit: Yeah, makes sense. I guess there's no level lower to go, unless you wanna sink all the way to Ptr?
19:31:57 <EvanR> why the hell not
19:32:11 <monochrom> http://www.cs.toronto.edu/~pekhimenko/courses/cscd70-w19/content.html
19:32:26 <dmwit> koz_: GHC could offer such a thing with a high-level (non-Ptr) API, I think.
19:32:45 <koz_> monochrom: _Of course_ it's taught by someone from the former Soviet Union...
19:32:50 <EvanR> lol the dragon book
19:33:00 <koz_> dmwit: Yeah, it _could_, but I'm asking more for now.
19:33:08 <koz_> Assuming you had a _burning_ need for such a thing.
19:33:13 <monochrom> koz_: Don't worry my teacher (probably also his teacher) was Arabic.
19:33:30 <EvanR> my compiler optimizations teacher was indian i think
19:33:37 <koz_> Oh, I don't think that's a bad thing - I'm merely amused by this fact.
19:33:55 <koz_> (being from the former Soviet Union myself)
19:34:05 <dmwit> % GHC.Arr.hopelessIndexError
19:34:06 <maerwald> monochrom: arabic or persian?
19:34:06 <yahb> dmwit: *** Exception: Error in array index
19:35:04 <dmwit> GHC.Arr does offer bulk operations, but still not for unboxed arrays. I wonder why.
19:35:13 <EvanR> has anyone combined dependent types and (actual) arrays
19:35:29 <EvanR> well someon must have but i want the evidence
19:35:38 <koz_> monochrom: These slides are actual gold.
19:35:46 <koz_> EvanR: I'm (slowly) working on it.
19:35:53 <koz_> There's rather a lot of literature I need to catch up on first.
19:39:14 * hackage hmp3-ng 2.4.2 - A 2019 fork of an ncurses mp3 player written in Haskell  https://hackage.haskell.org/package/hmp3-ng-2.4.2 (galen)
19:40:13 <monochrom> maerwald: The name is Tarek Abdelrahman.  He is not on linkedin, but after going through 30 other Tarek Abdelrahmans on linkedin I am pretty sure Arabic or from Egypt (which has further chance of being Arabic).
20:14:47 <polyhydrant> I have code to parse a number using Parsec, https://pastebin.com/ueyPsWh7, but whenever the first case fails (string "#d"), it returns an error and I'm not sure why.
20:15:20 <polyhydrant> I thought choice only returns an error if any input was consumed?
20:16:09 <pavonia> polyhydrant: For what input?
20:16:27 <pavonia> Note that all of the options have the same prefix "#"
20:16:38 <polyhydrant> "#x10" returns "unexpected "f", expecting "#d""
20:17:10 <polyhydrant> x, not f
20:17:11 <polyhydrant> oops
20:17:18 <pavonia> Yep, "#" has already been consumed
20:17:47 <polyhydrant> Ah the input is consumed per character?
20:18:09 <jle`> polyhydrant: looks like a backtracking problem
20:18:16 <pavonia> Yes
20:18:36 <polyhydrant> Thank you
20:18:38 <jle`> polyhydrant: it depends on the definition of <|> for your type
20:18:55 <jle`> polyhydrant: it's kind of tricky -- different parser combinators define <|> with different semantics
20:19:17 <jle`> so you have to check the docs to see if <|> is backtracking or not, whenever you use a new library
20:19:30 <polyhydrant> I believe Parsec doesn't backtrack
20:19:43 <polyhydrant> And instead fails if any input was consumed on a failing case
20:19:58 <jle`> polyhydrant: i think <|> can recover from a failure
20:20:04 <jle`> but just without backtracking by default
20:20:16 <jle`> so you can recover backtracking behavior using 'try'
20:20:27 <polyhydrant> I see, thanks
20:20:46 <jle`> polyhydrant: optionMaybe $ try (string "#d") <|> try (string "#x") <|> string "#o"
20:21:31 <jle`> alternatively you can refactor things out to not require backtracking, char '#' *> oneOf "dxo"
20:21:39 <jle`> (er not sure if oneOf is a thing for parsec)
20:22:09 <polyhydrant> Oh, yeah that's much simpler
20:22:41 <jle`> it also might be cleaner to move the parser to the combinators themselves
20:22:53 <jle`> er, to the parser itself. kind of confusing
20:23:11 <jle`> parseDecimal <$ char 'd'
20:23:25 <jle`> parseHex <$ char 'x', etc.
20:23:40 <jle`> but that wasn't a part of your original question, sorry :)
20:30:44 * hackage emd 0.1.9.0 - Empirical Mode Decomposition and Hilbert-Huang Transform  https://hackage.haskell.org/package/emd-0.1.9.0 (jle)
21:04:27 <EvanR> monochrom: do you have any resource for optimizations that are more like what ghc does
21:05:43 <EvanR> rewriting do, while, and goto's is interesting, but only to a certain  point :)
21:49:03 <heatsink> Is there a library with mutable hash tables that can be frozen and then read immutably?
22:01:33 <jsomedon> can this type be a functor? `newtype MakeString a = MakeString { mkString :: a -> String }` I see that this can be a contravariant though.
22:04:20 <Axman6> cn you write a function with the type (a -> b) -> MakeString a -> MakeString b?
22:04:42 <Axman6> heatsink: why do you believe you need mutable hashtables?
22:04:46 <Mrbuck> any one work with webassembly in Haskell ?
22:04:49 <jsomedon> Axman6: that's what I am not sure about
22:04:59 <Axman6> jsomedon: give it a go!
22:05:00 <Mrbuck> or languages like RUST better fit to wasm
22:05:20 <Axman6> Mrbuck: I believe there's work on a wasm backend for GHC
22:05:51 <Axman6> jsomedon: also, you might find that @djinn can help you figure this out
22:06:04 <Mrbuck> Axman6:  Okay 
22:06:09 <Axman6> (I'll show you how after you've had a go yourself)
22:06:29 <jsomedon> Axman6: so I guess, it can be a functor right?
22:07:16 <Axman6> cAn you write a function with the type (a -> b) -> MakeString a -> MakeString b?
22:07:44 <Axman6> if you can (and if f id == id) then yes, but you need to prove you can write that function
22:07:53 <heatsink> Axman6: Mutable hash tables are useful to update arbitrary items efficiently.  An example is computing word frequencies in a document, you'd like to do `forM_ (words document) $ \word -> update succ word hashtable`
22:08:29 <Axman6> heatsink: why does it need to be mutable though? are you finding performance problems using unordered-containers?
22:09:25 <shachaf> jsomedon: No, it's not a Functor.
22:11:35 <heatsink> it hasn't been a performance problem.  I'm asking because it seems useful to know about
22:13:46 <EvanR> jsomedon: i think your time is better spent proving that Functor would be impossible there
22:14:07 <EvanR> then you don't have to keep wondering :)
22:16:47 <Axman6> @djinn (a -> b) -> (a -> c) -> (b -> c) -- c because djinn doesn't know about Strings 
22:16:47 <lambdabot> Cannot parse command
22:16:57 <Axman6> @djinn (a -> b) -> (a -> c) -> (b -> c)
22:16:57 <lambdabot> -- f cannot be realized.
22:17:10 <Axman6> :shocked-pikachu:
22:19:20 <jsomedon> so my thought is `fmap` may look like: `fmap f ma = MakeString (mkString ma) . (g::b->a)` 
22:20:27 <jsomedon> tried to get such `g` from like `f` but didn't work
22:21:13 <jsomedon> then I just saw you guys all saying it's not a functor..
22:21:23 <EvanR> to show `something' is impossible implement `something -> Void'
22:21:42 <EvanR> i.e. use something to generate a Void value of which there are none. And no cheating
22:22:17 <EvanR> or in this case implement unsafeCoerce with it
22:22:24 <EvanR> (a -> b)
22:23:03 <jsomedon> EvanR: uhm what is unsafeCoerce?
22:23:11 <EvanR> an impossible function
22:23:31 <jsomedon> :t unsafeCoerce
22:23:32 <lambdabot> error: Variable not in scope: unsafeCoerce
22:23:42 <EvanR> % :t unsafeCoerce
22:23:43 <yahb> EvanR: a -> b
22:24:11 <jsomedon> what.. so it's a normal function, by lookign at its type
22:24:37 <EvanR> a normal function with a certain kind of polymorphism that makes it impossible to implement
22:24:45 <EvanR> forall a b . a -> b
22:26:21 <EvanR> so the whole exercise is (forall a b . (a -> b) -> MakeString a -> MakeString b) -> (a -> b)
22:26:27 <EvanR> write this function...
22:27:18 <EvanR> forall a b . (forall c d . (c -> d) -> MakeString c -> MakeString d) -> (a -> b)
22:34:40 <EvanR> ok i don't see a way to implement unsafeCoerce with this
22:35:22 <jsomedon> EvanR: so far I have this: uC x = mkString (fmap f (MakeString x)) :: y -> String -- I need y here not y -> String
22:36:05 <jsomedon> EvanR: uhm, the y in type means the type of value y..
22:36:16 <EvanR> you're not going to succeed in implementing fmap
22:36:30 <EvanR> better to figure out instead why not
22:37:05 <jsomedon> intuitively it seems not working though, just if someone like you ask me to _prove_ this
22:37:17 <jsomedon> then I am having a hard time haha
22:37:33 <EvanR> yeah ignore unsafeCoerce now i might be way off there
22:37:47 <jsomedon> yeah
22:39:27 <EvanR> the goal is MakeString b which accepts bs. You can easily build functions of type b -> String. But you won't be able to even satisfy f id = id
22:39:44 <EvanR> fmap f id = id
22:39:49 <EvanR> fmap id = id
22:40:01 <EvanR> i'm out
22:42:17 <mniip> what's going on here
22:42:31 <mniip> % class C a b | a -> b; instance C Int Char
22:42:31 <yahb> mniip: 
22:42:39 <mniip> % foo :: C Int r => r; foo = 'a'
22:42:39 <yahb> mniip: ; <interactive>:110:28: error:; * Couldn't match expected type `r' with actual type `Char'; `r' is a rigid type variable bound by; the type signature for:; foo :: forall r. C Int r => r; at <interactive>:110:1-19; * In the expression: 'a'; In an equation for `foo': foo = 'a'; * Relevant bindings include foo :: r (bound at <interactive>:110:22)
22:42:44 <mniip> didn't fundeps use to be stronger?
22:46:45 <jsomedon> EvanR: how does your b -> String look like?
22:47:01 <EvanR> \_ -> "something"
22:51:02 <jsomedon> EvanR: to have b -> String, and given only a -> b and a -> String, I don't really see how can I construct such thing.. I only can imagine somehow a -> b get reversed into b -> a then compose it with a -> String then I get b -> String
22:51:33 <jsomedon> EvanR: and I don't see such reverse process works for every cases
22:51:58 <mniip> I mean heck
22:52:09 <mniip> % :t undefined :: C Int r => r
22:52:09 <yahb> mniip: Char
22:52:12 <mniip> ???
22:52:18 <jsomedon> EvanR: so I am really curious when you say you have a b -> String
22:53:28 <EvanR> :t \_ -> "something"
22:53:29 <lambdabot> p -> [Char]
22:53:45 <EvanR> you can make constant functions
22:54:55 <jsomedon> EvanR: ah, so `\_ -> "a string"` this is literally your b -> String??
22:55:02 <EvanR> unless you have a way to use the b, which you don't because of the mismatched types
22:55:30 <EvanR> the must-be-constant-function is incompatible with fmap id = id
22:55:39 <jsomedon> hu
22:55:43 <jsomedon> I see
22:56:51 <EvanR> like, fmap id (MakeString reverse) should give MakeString reverse
22:56:58 <EvanR> but it would give some other thing
23:01:46 <dminuoso> Hi. Im a bit confused about the capturing rules of newName and mkName in TH. Can someone give me a pointer?
23:02:37 <dminuoso> Given `return (LamE [VarP nm1] (LamE [VarP nm2] (VarE nm1)))`, what does it mean for `VarE nm1` to (not) be captured by `VarP nm2`?
23:07:43 <mniip> dminuoso, if nm1==nm2 then it will be captured
23:07:52 <mniip> to avoid this use a really unique name
23:08:04 <mniip> or if you're using a global defined in some module, use a fully qualified name
23:08:23 <mniip> (really unique meaning `newName`)
23:08:34 <dminuoso> mniip: Is capturing a synonym for binding here?
23:08:40 <tdammers> "captured" means it will reuse variables of the same name from the parent scope, rather than generating a fresh new unique name
23:10:09 <dminuoso> tdammers: But here comes the thing, the way the documentation is phrased, it implies that the pattern in a lambda captures something in the body, so apparently "capturing" happens the other way (where something from the parent scope can capture a name from a subordinate scope)
23:10:18 <dminuoso> Am I making any sense here?
23:10:32 <tdammers> I think the best way to think about it is this:
23:11:30 <tdammers> mkName takes a String and constructs a Name from it, such that the same String will always produce the same name
23:11:32 <tdammers> newName, by contrast, always gnerates a fresh Name.
23:11:59 <tdammers> so the same invocation of newName will produce two *different* names
23:12:07 <tdammers> s/the same/& two/
23:12:25 <dminuoso> tdammers: So what the documentation is saying, that if you use newName to generate a name for a *binder* - and use mkName, then mkName could refer to the bound variable?
23:13:06 <tdammers> I've never used it that way, but in principle, yes, I think it could
23:13:30 <tdammers> ah, no, not really
23:13:42 <tdammers> https://hackage.haskell.org/package/template-haskell-2.15.0.0/docs/Language-Haskell-TH.html#v:newName explains it, I think
23:14:45 <dminuoso> The act of "capturing" sort of illudes me
23:15:56 <dminuoso> I mean I understand the difference between them and how they interact, but the process of "capturing" seems to be referring to something that GHC does - and capturing does not seem to be about binding.
23:16:46 <tdammers> it happens one step up
23:18:43 <dminuoso> I guess capturing is about figuring out whether two identifiers having the same label are actually the same identifier?
23:20:15 <dminuoso> Or more concretely, if A captures B, then A designates that B refers to the thing that A refers to?
23:29:48 <tdammers> pretty much, yes
23:57:14 * hackage partial-records 0.2.0.0 - Template haskell utilities for constructing records with default values  https://hackage.haskell.org/package/partial-records-0.2.0.0 (mniip)
