00:01:03 <EvanR> > foldr (||) False [False,False,False]
00:01:05 <lambdabot>  False
00:01:37 <int-e> @src any
00:01:37 <lambdabot> any p = or . map p
00:01:43 <int-e> @src or
00:01:43 <lambdabot> or = foldr (||) False
00:02:21 <int-e> (for a moment I was worried that @src could be wrong about this :) )
00:03:16 <int-e> > foldr (||) True (repeat False) -- at least it's not a constant function
00:03:22 <lambdabot>  mueval-core: Time limit exceeded
00:07:21 <yeboi> ah that worked, thanks
00:08:25 <yeboi> you could use foldr to flatten a list of lists too right? like [[1], [2], [3]] into [1,2,3]
00:11:24 <yeboi> ah nvm think i got it
00:13:58 <koz_> foldr is equivalent in power to general recursion.
00:15:37 <HaskellNoob> "general" recursion, does that cover all forms of recursion? 
00:15:41 <dmwit> How can the type `new :: PrimMonad m => Int -> m (MVector (PrimState m) a)` possibly be right? Where is it getting `a`s to fill the vector in with? (The documentation for `unsafeNew` says that the memory is not initialized, which to me heavily implies that the memory *is* initialized for the safe one.)
00:20:16 <EvanR> koz_: proof or it didn't happen
00:21:46 <koz_> EvanR: http://www.cs.nott.ac.uk/~pszgmh/fold.pdf
00:24:09 <koz_> dmwit: I _think_ it just zeroes it.
00:24:16 <koz_> Although I'm unsure.
00:24:27 <koz_> Easiest way would be to create one, freeze it, then show.
00:24:32 <koz_> s/way/way to check/
00:25:45 <EvanR> i doubt that foldr (or primitive recursion on N) can do anything general recursion can do
00:26:00 <dmwit> koz_: What does "zeroes it" mean for, say, `Int -> Int`?
00:26:18 <koz_> dmwit: A bunch of null pointers I guess? 
00:26:19 <EvanR> this paper doesn't argue that
00:26:23 <koz_> I admit it's not well-defined.
00:27:12 * dmwit squints
00:27:25 <cocreature> dmwit: boxed vectors?
00:27:41 <cocreature> dmwit: for boxed vectors it just fills it with "error …" iirc
00:28:43 <cocreature> for storable and unboxed it zeroes iirc
00:29:10 <koz_> cocreature: TIL.
00:29:28 <koz_> EvanR: Weird, because when I last asked someone about that, this is what they linked me to. Guess I should read more carefully.
00:29:36 <cocreature> for boxed, the unsafe and the safe version are equivalent
00:30:00 <koz_> EvanR: 'Getting a Fix from the Right Fold' here: https://wiki.haskell.org/wikiupload/1/14/TMR-Issue6.pdf seems to be relevant too.
00:30:11 <koz_> cocreature: Ah, so it _always_ zeroes in that case?
00:31:35 <cocreature> koz_: it doesn’t zero, it sets it to "error …"
00:32:00 <koz_> cocreature: Ah, whoops, I misread.
00:32:36 <dmwit> cocreature: I see.
00:32:45 <EvanR> koz_: yeah fix is recursion but not general recusion (on functions)
00:33:02 <koz_> EvanR: Could you explain that a bit more?
00:33:03 <dmwit> cocreature: (Yeah, the unboxed one I understand, because it has an `Unbox a` constraint, which gives it a place to pick a specific `a`.)
00:33:30 <EvanR> hmmmmm nope it is general recursion after all. 
00:33:40 * EvanR reads the other paper
00:33:52 <cocreature> boxed vectors are a wrapper around MutableArray# which can’t be created uninitialized (newArray# requires you to pass a default value) so even the unsafe version has to set it to some dummy value and "error …" is the most obvious one
00:37:22 * dmwit nods
00:37:29 <dmwit> Thanks!
00:47:36 <koz_> EvanR: That was an interesting read.
00:57:07 <koz_> Literally _everything_ in that is an interesting read.
01:43:00 * hackage seonbi 0.1.0 - SmartyPants for Korean language  https://hackage.haskell.org/package/seonbi-0.1.0 (hongminhee)
01:53:13 <HaskellNoob> why is there no 'Monoid Identity' instance?
01:54:14 <koz_> :k Identity
01:54:15 <lambdabot> * -> *
01:54:26 <koz_> HaskellNoob: Identity has the wrong kind to be a Monoid.
01:55:52 <sim590> I have those types https://paste.debian.net/1104869/ which try to describe a labyrinth. The labyrinth has dimensions. I encode this with LConf data type. I have some function that is of the type `:: Cell -> Integer` which needs to know about LConf, but the signature doesn't give this. How can I modify my types in a sensible manner to get this information?
01:56:26 <c_wraith> There really should be a  Monoid a => Monoid (Identity a)  instance, though
01:56:57 <koz_> c_wraith: But there is! https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Functor.Identity.html#line-72
01:57:35 <c_wraith> then no bug report needed. :)
01:58:21 <koz_> sim590: What is this function meant to do?
01:58:55 <sim590> Should I make a type like LCell that would be a tuple (Cell, LConf) and build on this? I'm trying to evolve to something like I saw in State monad. I know that the State monad gives access to the state while the important data is a seperate data structure.
02:00:42 <sim590> koz_: It's supposed to give the index of a Cell in the grid. Every cell is labelled with a natural number in the range [0,w*h-1] where w and h are respectively the width and height of the grid. 
02:01:01 <koz_> sim590: Without knowing the dimensions of the maze, this function can't be written.
02:01:10 <sim590> koz_: exactly.
02:01:21 <koz_> You have to either pass in the LConf, or the whole Labyrinthe type, to provide it.
02:01:51 <koz_> If you don't want to expose LConf to the user, you can just take a Labyrinthe argument.
02:02:19 <sim590> So I need to know that information in a subtle manner without explicitely passing the info. Is there a way to hide this information? Can monads to this for instance if I say that I'm in the "Labyrinth" monad.
02:03:01 <koz_> You can use Reader Labyrinth (if you're never going to change it) or State Labyrinth (if you plan on changing it).
02:03:50 <koz_> (well, 'Reader Labyrinth a' and 'State Labyrinth a' to be exact)
02:04:10 <sim590> Alright. I saw Reader today in fact and I understood that it was a usual monad, but I didn't understand that it did that. I will read about it.
02:05:02 <koz_> sim590: Reader r a is a wrapper around r -> a.
02:05:13 <koz_> State s a is a wrapper around s -> (a, s).
02:05:40 <koz_> (well, not exactly, but that's the idea at least)
02:07:10 <sim590> I have looked at State in the wikibooks website. I understood it, but I can't use it very well right now. I still need much more practice.
02:13:08 <HaskellNoob> I'm having a hard time using mtl, calling a polymorphic function using the RWS monad. Can someone take a look? https://pastebin.com/raw/fGjtMKuA
03:08:30 <sim590> koz_: Why do I get the error `Non type-variable argument in the constraint: MonadReader LConf m` for my function singature `index :: (MonadReader LConf m) => Cell -> m Integer` ?
03:08:49 <koz_> sim590: Because you need FlexibleContexts enabled.
03:08:58 <koz_> (the error message will even say that)
03:09:17 <sim590> Yeah, but I thought that it was something else. So MonadReader needs an extension?
03:09:40 <koz_> MonadReader in general doesn't.
03:10:18 <koz_> In your case it does, because you're writing a constraint against MonadReader LConf m, which means only the second type variable is... well, variable. :P
03:10:29 <koz_> The first one is 'fixed' to LConf, which Haskell2010 doesn't allow.
03:10:37 <koz_> FlexibleContexts lifts that restriction.
03:11:43 <sim590> Would I have this problem with plain Reader?
03:12:43 <koz_> No, because then your type would be 'index :: Cell -> Reader LConf Integer', which doesn't have any constraints.
03:13:02 <koz_> And it's not really a 'problem' - FlexibleContexts is a harmless, and very useful, extension.
03:13:30 * hackage xml-lens 0.2 - Lenses, traversals, and prisms for xml-conduit  https://hackage.haskell.org/package/xml-lens-0.2 (FumiakiKinoshita)
03:15:41 <sim590> Alright. It's just a question of remembering why I used that.
03:16:02 <sim590> May be starting with Reader instead of MonadReader would make this easier.
03:30:35 <macroprep> how does an Euclidean vector differ from a normal (typical) vector
03:31:34 <__monty__> I don't *think* it does? It's just more specifically a vector in a Euclidean vector space.
03:39:35 <sim590> I have a function in Reader LConf Bool monad and the other in the ReaderT LConf Maybe Bool monad (https://paste.debian.net/1104878/). How do I use the return value of the first one in the second one. In my pasted code one can see that lines calling isInBound does pose a problem to the compiler... :/
03:41:55 <koz_> sim590: I don't think you want ReaderT LConf Maybe Bool there.
03:42:01 <koz_> You want Reader LConf (Maybe Bool).
03:42:27 <sim590> Oh. Yeah. Maybe. :D
03:45:17 <sim590> koz_: I'm not sure how `guard` is going to behave in this case. It should behave like Reader tells it to behave and not Maybe, so I cannot use `guard` to return `Nothing`.
03:46:13 <sim590> Actually, I'm not sure how to write it so that I don't put big cases with Just and Nothing if unnecessary.
03:47:26 <koz_> :t guard
03:47:27 <lambdabot> Alternative f => Bool -> f ()
03:48:06 <koz_> Why do you need the 'Maybe Bool' there? Wouldn't it just give back a Bool?
03:48:23 <koz_> How is 'Nothing' different as a result from 'Just False' here?
03:48:34 <sim590> If passed cells are not in bound I want to return Nothing.
03:49:13 <sim590> well. I thought that returning a bool didn't inform on the malformation of one of the cells.
03:49:21 <koz_> Yeah, that makes sense.
03:53:52 <koz_> Just replace the last two lines with 'if b && b' then Just [your big calculation] else Nothing'.
03:54:24 <koz_> Sorry, return . Just ([your big calculation]) and return Nothing.
03:54:33 * koz_ is tired.
03:55:06 <sim590> I did this: https://paste.debian.net/1104881/, but I was wondering if I could use `guard` again, but I guess I can't since I'm not in the Maybe monad.
03:55:42 <koz_> guard isn't limited to Maybe.
03:55:44 <koz_> :t guard
03:55:45 <lambdabot> Alternative f => Bool -> f ()
03:55:59 <sim590> But I think that Reader is not an Alternative instance.
03:56:05 <koz_> Indeed.
03:56:20 <sim590> That's what I should have said.
03:56:28 <koz_> Your approach there is what I would suggest.
03:56:44 <koz_> It's probably doable in a more concise way, but I don't think it makes it more readable. :P
03:57:12 <sim590> Yeah. It's sufficiently good now I think.
03:59:00 * hackage hledger-irr 0.1.1.16 - computes the internal rate of return of an investment  https://hackage.haskell.org/package/hledger-irr-0.1.1.16 (JoachimBreitner)
04:07:08 <jsomedon> that paper you guys mentioned
04:07:19 <jsomedon> interesting read
04:07:45 <jsomedon> that part it shows how map can be defined by reduce
04:08:37 <jsomedon> that part reminds me of transducer thing in Clojure
04:10:54 <jsomedon> I always thought pipelining several map over some huge data is kind of waste of memory because each portion of pipeline would produce whole size of intermediate temp data, while all you really need is the data in the final step of pipeline
04:11:24 <jsomedon> and when I see that transducer thing in Clojure I thought ha this could be the solution
04:11:31 <jsomedon> now I see this paper
04:12:01 <jsomedon> it looks like explains how I can write my own such thing in Haskell
04:13:04 <merijn> Whoops...I made the mistake of opening a Hacker News post on Haskell...Quick, someone tell me something positive about monoids to clear my brain! >.>
04:13:28 <koz_> merijn: Monoids are key to the foldr-foldMap equivalence!
04:13:48 <merijn> jsomedon: FYI, if you're just interested in using something like that, there's several libraries for composing streaming operations like that :)
04:13:49 <__monty__> jsomedon: map f . map g . map h *is* already rewritten to map (f . g . h) iirc. So there's no intermediate steps. And the transformation doesn't even really on any foldr/build trickery.
04:13:54 <koz_> jsomedon: You don't even need to do that - Haskell's laziness takes care of that.
04:14:03 <merijn> koz_: Well, yes and now >.>
04:14:07 <merijn> s/now/no
04:14:16 <koz_> Yeah, I'm oversimplifying.
04:14:24 <merijn> I did find this excellent quote: "Asking "What is a monad?" to learn how to use monads is as wrong as asking "What is a musical instrument?" to learn how to play musical instruments. It's a good start, but it won't teach you very much.”"
04:14:58 <jsomedon> koz_: you mean code like this: map f1 (map f2 (map f3 someHugeList)), there won't be waste of memroy in Haskell?
04:15:01 <merijn> jsomedon: Oh, are you referring to the iteratees paper? (I missed the backlog)
04:15:23 <jsomedon> merijn: uh A tutorial on the universality andexpressiveness of fold
04:15:50 <merijn> jsomedon: Ah, that's an interesting one, yes, but not quite related to transducers I think
04:16:00 * hackage mini-egison 0.1.2 - Template Haskell Implementation of Egison Pattern Matching  https://hackage.haskell.org/package/mini-egison-0.1.2 (SatoshiEgi)
04:16:10 <merijn> Transducers would be more like iteratees, etc.
04:16:24 <koz_> jsomedon: Even more than that, if I have 'take 4 . map f1 . map f2 . map f3 $ someHugeList', only four elements would even get generated.
04:16:40 <jsomedon> hmmm that's really interesting
04:16:48 <jsomedon> wonder how that's done internally
04:17:02 <merijn> I think you guys are answering the wrong question, tbh :p
04:17:34 <koz_> merijn: Feel free to elaborate - you're better at answering questions than me even when I'm not half asleep. :P
04:17:48 <merijn> jsomedon: So "A Tutorial on the Universality and Expressiveness of Fold" is mostly about showing that fold is equivalent to most recursive functions
04:17:56 <jsomedon> ah yes
04:18:02 <merijn> jsomedon: It doesn't really show how to do stuff like that *efficiently*
04:19:07 <merijn> jsomedon: There's the (cryptically named) "Bananas, Lenses, Envelopes, and Barbed Wires" paper that talks about other higher level recursive abstractions (also commonly called recursion schemes)
04:19:32 <merijn> jsomedon: Although honestly, in daily life I find the names of recursion schemes way to complicated to bother dealing with
04:20:08 <merijn> jsomedon: Transducers, afaik, are more about having a streaming pipeline of operations that only keep as much as needed in memory, regardless of the input dataset size
04:20:47 <merijn> jsomedon: Oleg wrote a paper on "iteratees" which explain how to do something like that in Haskell (tbh, I don't remember if iteratees came before transducers, I think they did)
04:21:02 <merijn> jsomedon: However, Oleg's iteratee API was a bit...hard to use :)
04:21:43 <merijn> jsomedon: Since then we've had a bunch of different libraries try (and a bunch succeed) to do "iteratees, but easy to use"
04:22:01 <merijn> jsomedon: The biggest ones right now being: conduit, pipes, and machines
04:22:34 <merijn> There's also the (somewhat related) foldl packages for describing/composing arbitrary folds in a pipeline
04:23:47 <merijn> jsomedon: These also deal with "how to handle IO and resource cleanup" inside these pipelines. tbh, the streaming libraries in Haskell are like nothing I've seen in other languages :)
04:24:03 <jsomedon> ah I just thought, the way that "universality.." paper shows me how map can be defined as, `map f = fold \x ys -> f x:ys` kind of inspires me that, if I have like bunch of map f1(map f2(map f3 ...)) then I can write them as` fold \x ys -> f1.f2.f3 x:ys []` and I thought, maybe, transducers essentially is jsut using this kind of mechanism to uh you know generate such \x ys->some_code on the fly to
04:24:05 <jsomedon> avoid memory waste?
04:24:46 <merijn> jsomedon: You could, but that's a super annoying way to program, though :) makes it hard to reuse code
04:25:39 <merijn> jsomedon: Plus: 1) laziness means you only evaluate as much of the map as needed (this is what koz_ was saying), i.e. even *if* you evaluate all three maps, you will only have to evaluate them for the first 4 elements if you do "take 4"
04:26:02 <jsomedon> I guess yeah, because when I see koz_ mentions chaining liek take 4, I thought the way I imagined would not be that good to handle such case
04:26:16 <merijn> jsomedon: Now, there's also fusion rules in GHC that try and fuse away these sorts of compositions completely, so that it tries to automatically eliminate the maps by turning them into a single map :)
04:26:19 <jsomedon> I only thought about chainign map
04:27:16 <jsomedon> so, if the code is like `take 4 (map f someHugeList)`
04:27:36 <merijn> jsomedon: Then it doesn't map the entire list, no
04:27:46 <jsomedon> ha
04:27:53 <jsomedon> that's done by the langauge
04:27:54 <merijn> jsomedon: In fact, if the list is the result of the computation it probably won't even compute the entire list
04:27:55 <felixlau[m]1> Are you guys okay? Do you need help
04:28:17 <jsomedon> right if it's the only code I have
04:28:29 <jsomedon> so it's done by the language
04:28:55 <jsomedon> the compiler knows how many it will actually need to evaluate, that's what you mean
04:29:34 <jsomedon> ok let me re read your comment..
04:29:38 <merijn> jsomedon: The compiler doesn't know how many, it just generates code that only evaluates as many as necessary
04:29:42 <macroprep> anyway, is an Euclidean vector just a vector that uses real numbers instead of complex numbers?
04:32:15 <jsomedon> higher level recursion, what are these
04:33:02 <merijn> jsomedon: i.e. combinators that describe recursion instead of writing it yourself
04:33:31 <merijn> jsomedon: If you want to recursive over a list you can write a function that does that OR you can use fold which takes care of the recursion for you
04:33:38 <jsomedon> some recursion constructor?
04:34:17 <jsomedon> yes, hence the universality property of fold?
04:34:38 <jsomedon> so you mean fold is one of such combinator
04:35:19 <merijn> jsomedon: Well, that paper says "not only can fold do all recursions on lists, but actually ALL simple recursion"
04:36:24 <jsomedon> you mean, that paper says, fold can also be used to other kind of recursion, not just on list
04:36:32 <merijn> yes
04:36:33 <jsomedon> like maybe on tree
04:36:43 <macroprep> jsomedon: note if you have not done so already, you will need to also implement tail recursion in your recusion combinator thing as to not get a stack overflow during recursion should a list/array/whatever have too many indexes/nests
04:37:09 <jsomedon> uh
04:37:19 <merijn> jsomedon: you can ignore that
04:37:34 <merijn> macroprep: tail recursion isn't really all that relevant in most recursive calls in haskell
04:37:47 <merijn> Since tail call optimisation doesn't exist
04:38:03 <macroprep> oh
04:38:18 <macroprep> is it impossible to get a stack overflow from recursion
04:38:24 <merijn> (or everything is already tail call optimised, depending how you look at it...)
04:38:35 <macroprep> in haskel
04:38:43 <merijn> macroprep: (GHC) Haskell doesn't use a function call stack
04:38:51 <macroprep> o.o
04:38:56 <jsomedon> ha
04:39:01 <jsomedon> so it's done in haskell?
04:39:07 <jsomedon> how it's done in haskell
04:39:45 <jsomedon> if it uses stack then what macroprep said holds in haskell too right? merijn 
04:39:46 <merijn> jsomedon: Everything is in CPS (Continuation Passing Style) (which isn't really an explanation :p)
04:40:03 <merijn> jsomedon: Consider this: Why do we need/use a function call stack in other languages?
04:40:23 <jsomedon> I don know.. maybe easy to think about?
04:40:31 <jsomedon> at least makes some sense to me
04:40:38 <merijn> jsomedon: To remember where to continue when the function returns
04:40:41 <jsomedon> I need to know where to return
04:40:44 <jsomedon> yes
04:40:46 <merijn> jsomedon: Right
04:41:16 <jsomedon> and that relation between this context and previous context, I dont know looks just liek stack to me
04:41:27 <merijn> jsomedon: Now, next question: "f x y = x + y; foo = f 1 2" <- notice how the right hand side is always an expression?
04:41:29 <jsomedon> seems pretty straightforward to use stack
04:41:46 <jsomedon> ye
04:41:47 <merijn> jsomedon: Well, what does "after" mean in a pure language?
04:42:39 <merijn> jsomedon: In CPS you don't ever return when a function finishes, instead you pass in an extra argument "what to do when you're done"
04:44:19 <merijn> so if you have "f x y = x + y" and you write "f (f 1 2) (f 3 4)" you turn that into: (f 1 2 (\r -> f r (f 3 4))" (where the r argument of the lambda is "the result of computing "f 1 2"
04:45:46 <merijn> But of course we can do the same for the f 3 4 and get like "(f 1 2 (\r -> f 3 4 (\s -> f r s)))" (now the final 'f' is still missing a continuation, but that continuation would just be "the thing that called our "f (f 1 2) (f 3 4)" in the first place
04:46:22 <jsomedon> hmm
04:46:33 <merijn> jsomedon: So now your functions never return, they just call more functions, which means instead of compiling them to assembly CALL instructions (that use a stack) you can just use JMP to jump to the next bit of code to run
04:47:08 <macroprep> merijn: well then, what would happen if you wanted to write a more complex program in CPS
04:47:22 <jsomedon> what you saying makes sense, Im now just htinking why other language doesn't do same thing..
04:47:24 <merijn> jsomedon: If you're interested in this sorta thing there's an excellent (but long) paper that explains "So how do you compile a simple, lazy functional language to something that runs on a regular CPU?"
04:47:36 <merijn> jsomedon: They do, actually :p
04:48:09 <jsomedon> that is the name? So how do you .....
04:48:11 <merijn> jsomedon: Many C/imperative compilers use an internal representation called SSA (Static Single Assignment) which is basically "CPS, but with named variables"
04:48:22 <merijn> @where stg
04:48:22 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
04:49:14 <merijn> jsomedon: That one, if you can read the universality paper you know more than enough Haskell for that one. A little bit of basic C/ASM knowledge helps, but is mostly optional
04:49:32 <jsomedon> ok
04:49:39 <merijn> macroprep: Writing CPS code by hand is...hard it melts your brain once you wanna do complicated things, which is why you generally don't
04:49:47 <jsomedon> the title looks scary though hah
04:50:05 <merijn> jsomedon: That paper is *much* simpler than the universality one, so don't worry :)
04:50:27 <jsomedon> oukidoki
04:50:49 <merijn> However, optimising CPS (or SSA) code is fairly simple/easy, so compilers would like code to be in CPS/SSA style (this is why C compilers use SSA internally)
04:51:37 <macroprep> merijn: for example, if you where to convert a typical call stack based language to CPS, would it look like, for example, in psuedo, lets take a simple builder
04:51:40 <merijn> The main difference is: Turning (pure) Haskell code into CPS is *much* simpler than turning C into SSA :p Once you start playing with compilers and how to implement optimisations you quickly learn this the hardway :)
04:52:55 <merijn> Most of our compiler course lectures on optimisation boil down to: "Here's a neat straightforward optimisation" *class goes 'cool!'* "and here's all the ways you will break C code due to accidentally reordering side-effects, so you can't use it unless you do A LOT of static analysis to prove that can't happen!" *class goes 'oh :('*
04:54:09 <macroprep> merijn: builder(something, addToBuilder(something, addToBuilder(something, addToBuilder(something, foreach( do( sort( endDo( endForeach, addToBuilder(something, printResultingBuilder())))))))))
04:55:08 <macroprep> would it look something like that in CPS
04:55:08 <macroprep> merijn: 
04:55:10 <merijn> macroprep: I mean, that's already practically in CPS style :p
04:55:29 <merijn> macroprep: In fact, I would argue such an incremental builder is basically trying to reinvent CPS
04:58:38 <macroprep> if, in a normal stack based program, it might look something like this
04:58:39 <macroprep> a = builder(something) a.addToBuilder(something) a.addToBuilder(something) a.addToBuilder(something) foreach(a, do { sort() }) a.addToBuilder(something) a.printResultingBuilder()
04:59:23 <macroprep> which is, nowhere near complex lol
04:59:32 <merijn> macroprep: Imagine "addToBuilder" had an extra argument that had the result of the previous computation (it already kinda does, the 'a' you're calling it on)
05:00:20 <merijn> macroprep: The continuation for builder is "all the following "addToBuilder" functions", the continuation for the first addToBuilder is all the remaining ones, etc.
05:00:21 <macroprep> merijn: yea, but in CPS, it has no call stack thus something as simple as, a(); b(); CANNOT be done
05:00:46 <macroprep> since after returning from a() it cannot determine where to continue executing from next
05:00:46 <merijn> macroprep: Define "a(); b();"
05:01:08 <macroprep> thus cannot execute b unless you do a(b())
05:01:33 <macroprep> or something similar to that anyway
05:01:37 <merijn> macroprep: You're confusing syntactic notation with "what does this mean"
05:01:52 <merijn> macroprep: Do you know the bracket pattern in Haskell?
05:02:47 <macroprep> oh god imagine what the main of an ACTUAL cps program would loog like T_T
05:02:52 <macroprep> look*
05:03:23 <merijn> macroprep: I don't have to, SO literally has an example of using Cont(T) (the continuation monad, i.e. CPS) on how to make deeply nested continuations readable
05:03:33 <macroprep> would probs like like a gigantic nested indented tree of some kind lmao
05:03:39 <merijn> macroprep: https://stackoverflow.com/a/26437739
05:03:40 <macroprep> look like*
05:04:14 <merijn> macroprep: See also Tekmo's "managed" library which uses CPS for resource allocation: https://hackage.haskell.org/package/managed-1.0.0/docs/Control-Monad-Managed.html
05:05:04 <merijn> See also: http://www.haskellforall.com/2014/08/managed-100-monad-for-managed-resources.html
05:06:48 <merijn> Turns out that CPS style without side effects just looks like...imperative code :p
05:07:15 <macroprep> merijn: probably something like this lol https://del.dog/ufoxovulat
05:08:15 <merijn> macroprep: In current imperative languages, sure, because those have terrible support for most abstractions
05:08:47 <jsomedon> merijn: I was rereading your comments, so the transducer thing, the streaming pipline of operation thing can be done with: conduit, pipes, machines? and these are haskell library?
05:10:12 <merijn> jsomedon: Yeah
05:10:24 <merijn> I think conduit has the most library support at the moment
05:14:26 <merijn> jsomedon: Stuff like: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/ingest-src/Main.hs#L145-L149
05:15:00 <jsomedon> uh
05:15:02 <jsomedon> '|
05:15:07 <jsomedon> no I mean
05:15:09 <jsomedon> .|
05:15:12 <merijn> jsomedon: The streams data from a file, decodes it as UTF-8, performs a replace on the Text, then runs a parser before storing everything in a list
05:15:32 <merijn> jsomedon: .| is an operator from the conduit library that connects two conduits (like | does in your shell)
05:15:37 <jsomedon> oh ok
05:15:46 <jsomedon> so it means "pipe this to that"
05:16:19 <merijn> jsomedon: It only ever reads as much text (well, there's some buffering so probably minimum of like 1-4 kilobyte) as it needs to parse something (in my case single lines)
05:16:29 <merijn> jsomedon: Which means it works fine even on huge files
05:17:19 <jsomedon> hmm I really wanna know some fundamental concept about how such thing is implementd
05:17:31 <merijn> jsomedon: I use similar pipelines to process database query results
05:17:48 <merijn> jsomedon: Well, CPS is pretty important again ;)
05:17:54 <jsomedon> ok
05:18:07 <jsomedon> so that scary looking titled paper then
05:18:38 <jsomedon> I first saw this transducer thing when it
05:18:41 <merijn> jsomedon: Oleg's papers/text on iteratees discuss the invention of this stuff. And both Michael Snoyman and Gabriel Gonzalez have written quite a bit about the design/implementation of conduit and pipes
05:19:23 <jsomedon> so it's called iteratess in uh academic context?
05:19:44 <merijn> That was the name Oleg invented for his stuff
05:20:02 <merijn> There's also an iteratees library, but almost no one uses it anymore because the others are simpler
05:20:44 <__monty__> It's usually referred to as streaming afaik?
05:21:16 <maerwald> streamly > conduit
05:22:56 <merijn> maerwald: Why?
05:23:13 <maerwald> merijn: performance and very simple API
05:23:14 <merijn> First thing I see upon opening it is MonadBaseControl in a constraint >.>
05:23:18 <__monty__> Oh, maerwald do you want me to PR those tar changes to ghcup?
05:23:48 <merijn> maerwald: I only use it for streaming IO operations, so performance has never really been an issue for me
05:24:09 <maerwald> for us it has, streaming large data from backend
05:24:36 <maerwald> used Vector streaming before in fact, but streamly is nicer
05:24:55 <maerwald> and they really care a lot about performance
05:25:39 <maerwald> and conduit is just over-engineered :o ...you have to learn it again every half a year, because you forgot everything
05:25:59 <maerwald> __monty__: dunno
05:26:18 <merijn> maerwald: Most library I'm using right now use conduit anyway, so else I'd have to convert from conduit to streamly and port all the code, so that seems like very little gain
05:26:23 <maerwald> but conduit has the best ecosystem coverage (e.g. amazonka also uses it)
05:26:29 <maerwald> exactly
05:26:40 <merijn> maerwald: I dunno, I've never really had to "learn" conduit, you just compose stuff and it works :p
05:27:54 <maerwald> yeah, different approaches don't compose well in haskell
05:28:00 <maerwald> effects, streaming, ...
05:28:03 <maerwald> parsers
05:28:28 <merijn> maerwald: Plugging parsers into conduit hasn't really been an issue for me?
05:28:55 <maerwald> I mean, you can't really compose different parsers 
05:29:02 <merijn> ah, yeah
05:29:15 <maerwald> or randomly switch between mtl and e-e
05:31:00 * hackage tldr 0.4.0.2 - Haskell tldr client  https://hackage.haskell.org/package/tldr-0.4.0.2 (psibi)
05:32:00 * hackage tldr 0.5.0 - Haskell tldr client  https://hackage.haskell.org/package/tldr-0.5.0 (psibi)
06:01:36 <jsomedon> so this catamorphism, its (+)(the_+_inside_circle_operator) doens't have to be [a] -> b, it could be [a] -> [a]
06:01:43 <jsomedon> ?
06:02:10 <jsomedon> the context is this banana whatever paper
06:04:33 <__monty__> ⊕ <- feel free to copy/paste this since (+) is a valid way of addressing haskell's + operator.
06:05:04 <jsomedon> ha how did you even type that :-D
06:05:32 <__monty__> Kitty terminal has a unicode input mode.
06:05:45 <jsomedon> huh I use kitty
06:06:15 <jsomedon> well but I dont know how can I do that
06:06:39 <__monty__> C-S-u, then F2 then type circled plus
06:07:32 <jsomedon> 😎
06:07:52 <jsomedon> very nice feature, too bad i didn't know this
06:09:20 <jsomedon> 💻
06:19:59 <tombusby> hey all, I recently binned all of my RSS feeds (too much noise to signal). I'm looking for good recommendations for keeping up to date on what's going on in the world of haskell and the broader FP community, does anyone have any suggestions?
06:21:12 <merijn> tombusby: Haskell Weekly News is pretty good, I tend to glance over the /r/haskell frontpage once/twice a day (really glance, I open maybe 1 in 10 items on the frontpage), FP twitter is pretty ok but figuring out who to follow is tricky
06:21:52 <tombusby> Have any good recommendations for some key figures who make good central(ish) nodes on twitter who curate good content
06:22:04 <tombusby> (cheers btw)
06:22:31 <merijn> Gabriel Gonzalez and edwardk are good central hubs, I guess? See who they follow/retweet
06:22:51 <tombusby> fantastic, cheers.
06:23:33 <tombusby> if anyone has any other suggestions, feel free to shout them out too, more the merrier
06:26:51 <jsomedon> so a filter really can be defined as catamorphism or anamorphism right?
06:33:50 <jsomedon> also, in the notation of anamorphism, the h=[(g,p)], does the g gets its name g from like genereate-a-value-and-list-of-values-to-recurse-on?
06:34:19 <jsomedon> the p makes sense though, probably predicate-to-see-if-we-are-on-the-base-case?
06:43:00 * hackage typesafe-precure 0.7.6.1 - Type-safe transformations and purifications of PreCures (Japanese Battle Heroine)  https://hackage.haskell.org/package/typesafe-precure-0.7.6.1 (igrep)
06:49:47 <higherorder> Hello :) Does anyone know why `type Show1' f = forall a. Show a => Show (f a)` doesn't kind-check?
06:49:59 <higherorder> it gives `• Expected a type, but ‘Show (f a)’ has kind ‘Constraint’`
07:07:11 <boxscape> higherorder I believe you should be able to make a type family instead of a type here
07:07:19 <boxscape> (with one equation)
07:08:59 <boxscape> hm actually with a type family I get "illegal polymorphic type"
07:09:26 <boxscape> i.e. with this: (note the kind signature which makes it stop complaining about Constraint): type family Show1' f :: Constraint where Show1' f = forall a . Show a => Show (f a)
07:14:04 <higherorder> boxscape: yeah I get that too :(
07:16:13 <boxscape> actually, more confusingly, if I pull the forall out in front, i.e. with type family Show1' f :: Constraint where forall a . Show1' f = Show a => Show (f a)
07:16:19 <boxscape> I get error: Not in scope: type variable ‘f’
07:16:25 <boxscape> which doesn't make any sense to me
07:16:32 <merijn> hmm, so something I just realised: Should you keep ResourceT as high in your stack as possible to provide the smallest possible scoping for resources?
07:17:08 <boxscape> oh wait
07:17:18 <boxscape> I guess you have to specify f in the forall as well in that case?
07:17:42 <boxscape> ah, but then you get illegal qualified type again, of course, so not very helful
07:21:23 <macroprep> this would be roughly correct (ignoring all vector space rules for the sake of a working vector space), right? https://del.dog/VectorSpace
07:23:00 * hackage mini-egison 0.1.3 - Template Haskell Implementation of Egison Pattern Matching  https://hackage.haskell.org/package/mini-egison-0.1.3 (SatoshiEgi)
07:27:36 <macroprep> note: they are NOT limited to a fixed dimension https://del.dog/DynamicVectorSpace
07:38:30 * hackage xmonad-extras 0.15.2 - Third party extensions for xmonad with wacky dependencies  https://hackage.haskell.org/package/xmonad-extras-0.15.2 (psibi)
07:39:22 <merijn> A pox upon IOError's show instances
07:52:00 * hackage HsYAML 0.2.1.0 - Pure Haskell YAML 1.2 processor  https://hackage.haskell.org/package/HsYAML-0.2.1.0 (HerbertValerioRiedel)
07:55:24 <merijn> ffs
07:55:36 <merijn> How do I find out which IOException I actually have? >.>
07:58:43 <cocreature> merijn: what’s the show output you get?
07:58:59 <merijn> cocreature: "fd:140: hPutBuf: resource vanished (Broken pipe)"
07:59:37 <cocreature> merijn: ResourceVanished
08:00:11 <merijn> cocreature: Where's that defined?
08:00:21 <merijn> That doesn't seem to be in System.IO.Error
08:00:22 <cocreature> merijn: it’s one of the constructors of IOErrorType
08:00:46 <merijn> cocreature: Yeah, but which of the functions do I use to detect that? >.>
08:00:50 <cocreature> merijn: https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.IO.Exception.html#line-377
08:01:19 <cocreature> import all the internal crap so you get access to the actual constructor and don’t bother with the tester functions :P
08:02:29 <cocreature> GHC.IO.Exception is the one you need iirc
08:02:41 <merijn> cocreature: Unrelatedly, two questions: 1) How hard would it be to have ghcide inject a flag into the GHC configuration? (I still need to test, but I think stripping off the path/line number from the errors might be possible with GHC configuration)
08:03:15 <cocreature> that should be very easy
08:03:36 <merijn> cocreature: 2) feature ideas I don't currently have time to investigate further -> just make an issue on github in case someone else is motivated?
08:03:44 <cocreature> sure
08:04:35 <merijn> (Basically I think it would be brilliant if it could (opt-in) not report typed hole errors/warnings unless there's no other errors :p
08:08:08 <cocreature> not too keen on messing with how and which GHC warning emits (outside of flags that it already provdies) in general but I could definitely see that being useful so I might be willing to make an exception :)
08:10:23 <merijn> cocreature: That could be done simply by toggling existing flags, though. Just run with all holes hidden, if nothing turns up, run with hole warnings enabled? (Although I guess that means running twice which might be wasteful, on the third hand, so far it's running faster than vim can exit insert mode for me :p
08:14:14 <cocreature> definitely opposed to running twice :)
08:25:30 * hackage fakedata 0.3.1 - Library for producing fake data  https://hackage.haskell.org/package/fakedata-0.3.1 (psibi)
08:26:55 <nshepperd> hmm. Control.Exception ought to be made out of prisms
08:27:34 <merijn> What? No, why?
08:27:47 <nshepperd> much fewer lines of code than writing fromException, toException manually
08:28:19 <merijn> nshepperd: Removing to/fromException loses the ability to use hierarchical exceptions
08:29:32 <nshepperd> no I mean implementing exactly the same thing, but having the Exception typeclass have 'exception :: Exception e => Prism' SomeException e' instead of a pair of from/to functions
08:30:09 <merijn> nshepperd: I don't know lens/prism that well, but I'm pretty sure that can't actually describe the same thing
08:30:13 <nshepperd> with fromException, toException as functions outside the typeclass 
08:30:24 <merijn> nshepperd: Because then you'd only be able to project from/to SomeException
08:31:26 <nshepperd> the Exception typeclass has 'toException   :: e -> SomeException; fromException :: SomeException -> Maybe e' which is exactly a Prism' SomeException e
08:31:28 <merijn> nshepperd: The current exception system supports sybclassing
08:32:18 <merijn> nshepperd: You don't use Exception just for converting to/from SomeException, you use it for subclassing too (granted, almost no one uses this, but people should!)
08:32:45 <heatsink> sybclassing = scrap your boilerplate classing?
08:32:47 <nshepperd> but the way it's written now, you have to write like 8 lines of code to subclass your own exception type, instead of writing 'instance Exception MyException where { exception = exception . _ParentExceptionType }'
08:32:54 <merijn> heatsink: No, that's a typo
08:32:58 <heatsink> ok
08:33:09 <merijn> heatsink: it's just subclassing
08:33:12 <nshepperd> merijn: yeah, I'm saying you can implement that better with prisms
08:33:53 <merijn> nshepperd: Then base would have to depend on lens and I would have to finally learn lens, fortunately for that status quo base depending on lens seems unlikely :p
08:34:25 <Rembane> Lenseption! 
08:35:26 <nshepperd> the way you subclass an exception type with Exception is by composing a prism that takes SomeException to your ParentExceptionType and a prism that takes ParentExceptionType to your exception type
08:35:59 <nshepperd> yeah i wouldn't want base to depend on lens
08:36:44 <nshepperd> but since we need very little lens features maybe a self contained implementation would do
08:40:40 <nshepperd> https://zlkj.in:9000/uploads/5c9b026bd588dc4c/exception.hs <- example
08:45:57 <nshepperd> i'm not much of an expert on prisms though, so i'm not sure what kind of self contained implementation is possible
08:46:44 <nshepperd> wrapping up toException/fromException in a pair type with a Category instance might do fine already
08:56:10 <sternmull> could someone give me a hint how to read "myReverse xs = foldr (\x fId empty -> fId (x : empty)) id xs []"? It seems to indeed reverse a list. I know it is intentionally written to be hard to read. But how do you approach such cryptic code?
08:58:19 <dminuoso> sternmull: https://wiki.haskell.org/File:Right-fold-transformation.png
08:58:30 <higherorder> sternmull: I would write a few steps down by hand
08:58:53 <dminuoso> sternmull: Also this trick is a common idiom. :)
08:59:09 <dminuoso> (So its not intentionally written to be hard to read, you are just not familiar with this trick)
09:00:14 <sternmull> dminuoso: I have already sketched that picture on the sheet of paper in front of me. But so far didn't help much for understanding that function.
09:00:16 <dminuoso> sternmull: https://ertes.eu/tutorial/foldr.html this is a superb guide. :)
09:00:31 <dminuoso> sternmull: After that, the foldr will be familiar to you.
09:00:58 <sternmull> dminuoso: Ok, thanks.
09:01:23 <higherorder> sternmull: also I think your variable named `empty` is misleading; it's not always the empty list
09:02:08 <dminuoso> sternmull: Also, if I may make one little modification to your code to make things more obvious: myReverse xs = foldr (\x fId -> \empty -> fId (x : empty)) id xs []
09:03:04 <dminuoso> But really, ertes guide is by far one of the best sources to learn foldr.
09:03:23 <jzyamateur> hello, how does one know the kind of a type variable?
09:03:36 <higherorder> jzyamateur: in what context?
09:03:47 <jzyamateur> Let's say `id:: a -> a`, what is the kind of a?
09:03:49 <sternmull> dminuoso: Yeah, i figured that there is some partial application involved. But haven't yet figured out how all that fits together.
09:03:53 <dminuoso> jzyamateur: Its always *
09:03:57 <higherorder> jzyamateur: Type/*
09:04:02 <dminuoso> jzyamateur: * is the only type that is inhabitatable.
09:04:20 <dminuoso> jzyamateur: Since `id` accepts a value, it means that values type must be inhabitatbale.
09:04:52 <jzyamateur> What is the meaning of `inhabitable`?
09:05:07 <dminuoso> jzyamateur: A type is said to be inhabited if there exist values of that type.
09:05:19 <higherorder> A question of my own (mostly for fun): is there a way to make `a -> Maybe _` an instance of Applicative? I know there is a sensible way to define it, but I don't know how to write it down 
09:05:24 <dminuoso> jzyamateur: A type is said to be inhabitable if, according to its kind, it is allowed to have inhabitants.
09:05:46 <higherorder> specifically, I tride `instance Alternative ((->) a . Maybe`` but that doesnt' compile
09:05:55 <merijn> higherorder: With the argument of 'a' being the Applicative variable, you mean?
09:05:59 * higherorder (since composition doesn't 
09:06:03 <dminuoso> higherorder: Make a newtype.
09:06:03 <higherorder> oops
09:06:24 <higherorder> merijn: No; `a -> Maybe b` with `b` being the applicative variable
09:06:29 <merijn> higherorder: You're right that it doesn't work due to lack of composition. The answer is, as dminuoso says, a newtype
09:06:42 <merijn> higherorder: Eh, that's what I meant, yeah
09:06:43 <higherorder> to give you some context (maybe there is a better option), I am trying to write a little utility to pattern match on data using prisms
09:06:48 <merijn> higherorder: Note that we already have:
09:06:57 <merijn> :t Data.Functor.Compose.Compose
09:06:58 <lambdabot> forall k1 k (f :: k -> *) (g :: k1 -> k) (a :: k1). f (g a) -> Data.Functor.Compose.Compose f g a
09:07:09 <dminuoso> jzyamateur: Basically this is also how you can deduce that `m` in Monad must be of kind * -> *, you can just look at return:
09:07:11 <dminuoso> % :t return
09:07:12 <yahb> dminuoso: Monad m => a -> m a
09:07:17 <higherorder> I thought I could chain cases like so: `on _SomePrism f <|> on _OtherPrism g`
09:07:26 <merijn> :t Compose (undefined :: a -> Maybe b)
09:07:27 <lambdabot> error:
09:07:27 <lambdabot>     • Data constructor not in scope: Compose :: (a0 -> Maybe b0) -> t
09:07:27 <lambdabot>     • Perhaps you meant variable ‘icompose’ (imported from Control.Lens)
09:07:32 <merijn> hmm, rats
09:07:38 <merijn> :t Data.Functor.Compose.Compose (undefined :: a -> Maybe b)
09:07:39 <lambdabot> Data.Functor.Compose.Compose ((->) a1) Maybe a2
09:07:40 <dminuoso> jzyamateur: Since a value of type `a` exists, its kind must be *. And since values of `m a` exists, it follows that `m a :: *`, and thus `m :: * -> *`
09:08:04 <merijn> higherorder: That also already has instance for Applicative and stuff
09:08:27 <jzyamateur> dminuoso very cool, mind = blown
09:08:53 <higherorder> merijn: ah, ty!
09:09:12 <higherorder> merijn: by the way, does doing pattern matching with prisms sound like a sensible idea to you? 
09:09:20 <higherorder> I want to do it in conjunction with `fastsum`
09:09:31 <merijn> higherorder: Honestly, no clue, because I've so far never used prisms :p
09:11:51 <dminuoso> higherorder: What exactly are you trying to do with the prisms?
09:13:04 <higherorder> dminuoso: So, I am using `fastsum` (https://hackage.haskell.org/package/fastsum-0.1.1.0/docs/Data-Sum.html) to represent the type of an AST. I want to define prisms for every AST node type, and then use them to pattern match on the AST
09:13:24 <dminuoso> higherorder: In what sense do you intend to pattern match on the AST?
09:13:37 <dminuoso> higherorder: In the sense of one grand case-of using prisms?
09:13:58 <higherorder> dminuoso: yes
09:14:14 <dminuoso> higherorder: What do you hope to gain by using prisms?
09:14:29 <higherorder> not sure; it just seemed like an easy way to define this
09:14:33 <higherorder> I'm not sure how else I could do it
09:14:38 <dminuoso> A big case-of?
09:14:38 <higherorder> pattern synonyms perhaps
09:14:57 <higherorder> well no, with `fastsum` I would have to manually spell out the injections if I used a big case-of
09:16:21 <merijn> hmm, is there a convenient way to check if a certain executable exists in $PATH? I could simply try and run it, but that seems...inefficient?
09:17:01 <heatsink> merijn: findExecutable in System.Directory
09:17:08 <merijn> heatsink: Ah, cheers!
09:23:30 * hackage gitlab-haskell 0.1.2 - A Haskell library for the GitLab web API  https://hackage.haskell.org/package/gitlab-haskell-0.1.2 (RobStewart)
09:46:01 * hackage haskell-formatter 2.0.2 - Haskell source code formatter  https://hackage.haskell.org/package/haskell-formatter-2.0.2 (evolutics)
09:47:48 <boxscape> What does it mean for unlifted types to not contain bottom considering I can still do something like `undefined :: (ByteArray# :: TYPE 'UnliftedRep)`?
09:48:40 <merijn> boxscape: I don't think you can do that?
09:48:49 <merijn> Like, have you tried?
09:49:08 <boxscape> % I# (isByteArrayPinned# (undefined :: (ByteArray# :: TYPE 'UnliftedRep)))
09:49:08 <yahb> boxscape: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:9:25 in interactive:Ghci5
09:49:12 <boxscape> I have
09:49:56 <heatsink> I believe it's like unlifted types are implicitly strict
09:50:00 <monochrom> I don't know for sure, but I suspect a factor is it is a boxed type.
09:50:02 <merijn> "undefined :: ByteArray#" gives an error for me
09:50:16 <boxscape> merijn because ghci can't print unlifted types
09:50:18 <merijn> Couldn't match a lifted type with an unlifted type
09:50:33 <boxscape> heatsink I suppose that would make sense
09:51:22 <boxscape> monochrom the docs on RuntimeRep say "For boxed values (that is, values that are represented by a pointer), a further distinction is made, between lifted types (that contain ⊥), and unlifted ones (that don't)."
09:53:14 <boxscape> merijn if you look at the definition of undefined it's actually explicitly levity polymorphic: `undefined :: forall (r :: RuntimeRep). forall (a :: TYPE r). HasCallStack => a `
09:55:11 <cocreature> % let x = undefined :: (ByteArray# :: Type 'UnliftedRep) in ()
09:55:11 <yahb> cocreature: ; <interactive>:10:22: error:; * Expected kind `TYPE 'UnliftedRep', but `(ByteArray# :: Type 'UnliftedRep)' has kind `*'; * In an expression type signature: (ByteArray# :: Type 'UnliftedRep); In the expression: undefined :: (ByteArray# :: Type 'UnliftedRep); In an equation for `x': x = undefined :: (ByteArray# :: Type 'UnliftedRep); <interactive>:10:23: error:; * Expected kin
09:55:22 <cocreature> % let x = undefined :: (ByteArray# :: TYPE 'UnliftedRep) in ()
09:55:22 <yahb> cocreature: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:11:9 in interactive:Ghci5
09:55:42 <cocreature> so heatsink’s comment is accurate (afaik)
09:56:58 <boxscape> okay, thanks heatsink cocreature
10:07:00 * hackage basen 0.2.0.0 -   https://hackage.haskell.org/package/basen-0.2.0.0 (fabianhjr)
10:16:27 <inkbottle> Anybody is using haskell-ide-engine?
10:16:55 <fendor_> inkbottle, yes
10:19:45 <inkbottle> fendor_: in order to install it, through stack, I understand you have to git-clone it first? (stack install hie is not enough)
10:20:19 <fendor_> inkbottle, yes, clone the repo and then use the shake installer. Or use nix, if you are familiar with that
10:21:43 <inkbottle> fendor_: new computer, with NixOS; but no, not yet familiar with nix /-)
10:21:52 <fendor_> so, you do have nixos? 
10:21:55 <fendor_> then use nix, way faster
10:22:36 <fendor_> you need: https://github.com/Infinisil/all-hies
10:23:16 <inkbottle> OK, I'm on that page...
10:24:33 <inkbottle> I come back to you when I've done some reading
10:25:17 <fendor_> sure!
10:56:14 <jzyamateur> Is there a way to convert nested `Just` to a single `Just`? e.g. `Just (Just (Just 0))` to be `Just 0`?
10:56:23 <heatsink> join
10:56:50 <merijn> Yeah, repeated joins. Or better yet, don't nest them in the first place? :) 
10:57:16 <koz_> Bind is your friend. :P
10:57:29 <jzyamateur> yeah merjin, wrote a helper fn and now only doing Just on the return value of helper fn.
10:57:29 <boxscape> In https://www.youtube.com/watch?v=lSJwXZ7vWBw , at the linked timestamp, Richard says that (+) can be defined levity polymorphic, but that doesn't seem to be the case in base. What's the reason for that?
10:57:37 <boxscape> wait I didn't link a timestamp
10:57:51 <boxscape> it's at 12:28
10:58:04 <merijn> boxscape: Levity polymorphic functions have terrifying signatures that scare beginners
10:58:11 <boxscape> I see
10:58:17 <boxscape> I thought ghci got rid of those though
10:58:20 <merijn> boxscape: I mean, that's just a guess of course
10:58:25 <boxscape> though I suppose that's still an argument for haddock and such
10:58:42 <boxscape> (ghci + error messages, I mean, I think)
10:58:50 <merijn> boxscape: It's fairly rare to need/use levity polymorphism and unboxed values, so "using a different name" is really not that much of a hassle
10:58:58 <boxscape> that makes sense
11:05:54 <boxscape> he says later "the biggest win here are class methods" but also "we haven't done this yet" (where "this" is using levity polymorphism for standard classes) because "we want to let it mature a little bit", so maybe we're still in the maturing phase
11:23:58 <dsal> Rebuilding with --profiling.  Hopefully within the next hour I can know where this random exception is coming from.  :)
11:26:10 <fresheyeball> hey out there
11:26:20 <fresheyeball> so I have a modeling problem and could use some advice
11:27:10 <fresheyeball> https://gitlab.com/fresheyeball/Shpadoinkle/blob/71c5613e7221c70aa4d0c34bfe462430cd0025f1/widgets/Shpadoinkle/Widgets/Types/Choice.hs
11:27:20 <fresheyeball> I wrote this type and I really like it
11:27:49 <fresheyeball> my goal is to make a nice friendly api into data types on the UI that share traits
11:30:24 <fresheyeball> the problem is I am feeling OOP about this
11:30:41 <fresheyeball> I can't see an easy way to avoid that aspect of this problem
11:31:02 <fresheyeball> I have a dropdown type that has a Choice attached
11:31:12 <fresheyeball> boy it would be nice to have a simple api like
11:31:18 <fresheyeball> select x myDropdown
11:31:49 <fresheyeball> this feel EXACTLY like inheritance
11:34:47 <merijn> fresheyeball: But why have all this incredibly complicated typeclass/type family machinery? Couldn't you just use Maybe/NonEmpty/Set directly?
11:35:04 <fresheyeball> merijn: they don't model this at all
11:35:18 <c_wraith> have you considered a record of functions?
11:35:37 <c_wraith> 99% of the time you think you need OOP, it does the job.
11:35:50 <fresheyeball> I don't see how that helps
11:35:53 <fresheyeball> point is
11:35:54 <c_wraith> (I'd argue that it actually captures the most important details in OOP)
11:37:43 * ski . o O ( interface inheritance or implementation inheritance ? )
11:38:22 <c_wraith> I'd argue the most important detail is "open changes to behavior for values of the same type"
11:40:25 <fresheyeball> c_wraith: that is not my goal here
11:40:28 <fresheyeball> so here is the thing
11:40:42 <fresheyeball> in UI dev there are a shitload of cases where the user needs to pick something
11:40:47 <fresheyeball> with different semantics
11:41:00 <fresheyeball> sometimes they need to pick one thing
11:41:08 <fresheyeball> sometimes they may pick one thing
11:41:12 <evelyn> Isn't that abstract and unrelated to the technical implimentation?
11:41:13 <fresheyeball> sometimes they may pick more than one thing
11:41:20 <fresheyeball> yes
11:41:40 <fresheyeball> however the ergnomics of code about this kind of problem is horrible
11:41:53 <fresheyeball> I should be able to share logic between a dropdown menu and a radio button set
11:42:06 <fresheyeball> they are both a case where the user must pick one thing from a set
11:42:09 <fresheyeball> the logic is the same
11:42:23 <fresheyeball> but the data structure is rarely the same
11:42:59 <fresheyeball> The structure I have here is universal
11:43:19 <evelyn> I think the type family approach may make the structure universal, but that might not be the best approach.
11:43:28 <fresheyeball> dropdown menus, radio groups, navigation bars, all of these cases where the user selects something from a set 
11:43:32 <fresheyeball> evelyn: I agree
11:43:39 <fresheyeball> but I can't find a better approach, and I tried 4
11:43:42 <c_wraith> it sounds to me like you want a common set of operations on various backends. 
11:43:52 <fresheyeball> yes
11:44:04 <fresheyeball> however those backends are not so different
11:44:12 <c_wraith> "common set of operations" = "record of functions" 
11:44:16 <fresheyeball> for example, we can't do this with abackend of NonEmpty set
11:44:37 <evelyn> It might be helpful to look at existing UI libraries' approaches. How have other people approached a similar problem?
11:45:41 <fresheyeball> I have don't extensive research on this top
11:45:43 <fresheyeball> topic*
11:46:05 <fresheyeball> infact I have spent about 6 years on this one problem in one form or another
11:46:21 <fresheyeball> no one seems to realize quite how hard this is to get right
11:46:49 <fresheyeball> but I think the similarity is clear. We are picking something from a set
11:46:59 <fresheyeball> there are not that many backends that work for that
11:47:09 <fresheyeball> infact they all have the same underlying structure
11:47:16 <fresheyeball> which I have unified with Choice
11:47:37 <fresheyeball> so I am quite happy with Choice, it allows for polymorphism where it helps and not where it doesn't
11:47:43 <fresheyeball> error messages are easy to understand
11:47:47 <merijn> tbh, I agree with c_wraith that the "record of functions" approach is probably the right way to go here
11:48:04 <fresheyeball> why?
11:48:26 <fresheyeball> isn't a record of functions and a typeclass isomorphic?
11:48:29 <merijn> Much simpler to implement, understand and work with, avoids most of the type level mess
11:48:55 <geekosaur> you can "subclass" the record of functions more easily, for one
11:49:57 <geekosaur> for example, wrap it in a Reader and use "local" to get an override. or just use record update syntax
11:49:58 <fresheyeball> so I will have a subclass depth maximum of 1
11:50:07 <fresheyeball> I can easily solve this with classy lenses
11:50:16 <fresheyeball> but then I need to demand consumers of my library use lens
11:50:19 <fresheyeball> and I don't want that
11:50:38 <fresheyeball> I see what you are getting at
11:50:55 <fresheyeball> you are thinking record of functions because we can modify it, no?
11:51:03 <geekosaur> heh. at some point you need to make up your mind there :)  lens or no?
11:51:19 <evelyn> if you don't want the giant lens library, there is always microlens.
11:51:23 <fresheyeball> I guess I don't see how classy lenses are not oop
11:51:38 <fresheyeball> they look exactly like oop polymorphism
11:52:04 <fresheyeball> basically, if I have a HUGE suite of functions for a type
11:52:19 <fresheyeball> and multiple records that have a field with that type
11:52:33 <fresheyeball> is there a "right" way to lift all those functions to work on that record directly?
11:52:44 <fresheyeball> or is it better to use record update syntax in all those cases
11:52:46 <fresheyeball> ?
11:52:54 <fresheyeball> sorry its hard to articulate this problem
11:53:14 <geekosaur> that's more or less lens, but note that lens offers a third option: profunctors
11:53:55 <geekosaur> (as compared to record of functions or typeclasses)
11:54:49 <fresheyeball> can you describe the significance?
11:54:58 <fresheyeball> ugh my spelling
11:56:24 <fresheyeball> like if I want to lift all the functions that operate of `Foo` to a record containing one `Foo`, does that mean I need to put all of them into a typeclass?
11:57:00 <fresheyeball> I don't see how putting the entire module into a record really helps here
11:58:09 <geekosaur> that's one approach out of multiple. lens lets you drill down instead, which is a fancy alternative to wrapper functions, or can use profunctors which are a different fancy alternative. the wrapper here would drill down inside the record to focus on the Foo, allowing your functions to be used
11:58:29 <fresheyeball> right, so then I have something like
11:58:46 <geekosaur> it can use typeclasses beneath the hood (makeClassy) but it's a generic typeclass (and indeed related to generics)
11:58:53 <fresheyeball> myDropdown & choice .~ select x
11:58:55 <fresheyeball> vs
11:59:00 <fresheyeball> select x myDropdown
11:59:10 <fresheyeball> err sorry
11:59:24 <fresheyeball> myDropdown & choice %~ select x
11:59:28 <fresheyeball> vs
11:59:32 <fresheyeball> select x myDropdown
11:59:34 <geekosaur> it's more or less a `hasField "Foo"` instance in that case, which can be used to pull the Foo out of the record
11:59:39 <geekosaur> or push something into it
12:16:00 * hackage concurrent-output 1.10.11 - Ungarble output from several threads or commands  https://hackage.haskell.org/package/concurrent-output-1.10.11 (JoeyHess)
12:16:02 <monochrom> Don't avoid OO when it naturally arises.  Just don't seek OO when it doesn't naturally arise.
12:16:47 <fresheyeball> monochrom: my instinct is to fight OO tooth and nail
12:19:00 * hackage websockets-simple 0.2.0 - Composable websockets clients  https://hackage.haskell.org/package/websockets-simple-0.2.0 (athanclark)
12:19:23 <Lycurgus> toof und nagel
12:26:24 <whadevah> Good day. Can somebody explain, how the Yoneda lemma works exactly. I see that, because of an identity morphism in a hom-functor, possible natural transormations to any other functor are fully determined by an element our identity morphism is mapped into. So for each natural transormation from our hom-functor there is exactly one element in a
12:26:25 <whadevah> chosen functor. It works because of naturality condition, fine. But the lemma also states that it works the other way around. For each element in a functor there is a natural transormation. But how so? Say we have an element in our functor to which there is just no morphisms from our hom-functor. The lemma states it isn't possible, but I don't
12:26:25 <whadevah> understand why.
12:30:58 <geekosaur> there's a category theory channel
12:31:33 <geekosaur> but it looks to me like naturality itself applies in both directions, so there has to be such a unique mapping in both directions
12:34:34 * geekosaur is not a CT expert, though
12:34:57 <geekosaur> but that appears to be wikipedia's proof, for what that's worth
12:35:15 <whadevah> geekosaur here, I tried to draw it with my non-existent skiils https://i.imgur.com/9vtZPex.png
12:36:36 <whadevah> The lemma states that it's not possible to have such orphan elements in `F a`. But I don't understand how it's proved.
12:37:16 <geekosaur> because naturality says that in *both* directions each element maps to exactly one element
12:38:29 <geekosaur> in short, if there are orphans on either side, it's not a natural transformation
12:38:45 <whadevah> For naturality to exist there should be a morphism. And as I see it, the only thing naturality states is that a diagram has to commute
12:40:52 <whadevah> I don't see how epimorphisms are connected to naturality in any way. Aren't these different things? 
12:41:50 <dsal> I've got a bug that only seems to manifest on arm64.  I know what it sounds like to blame the compiler...  Gonna try 8.8, though.
12:42:39 <merijn> dsal: People who don't blame compilers have never used anything other than, say, gcc/javac/something mainstream on Intel :p
12:42:49 <merijn> Compilers are buggy as hell all the time :p
12:43:25 <hpc> i am constantly blaming those sorts of compilers, but mainly when they lie to me about things like where my mistakes are
12:43:27 <koz_> Compilers are software. Software has bugs. Therefore, compilers have bugs. :P
12:43:49 <dsal> I had a pretty awful gcc on intel bug at one point.  It was a spec problem, but super annoying.  If you used some pragma that says a parameter can't be NULL, it would fail to compile if you passed in a literal NULL, but it would also elide any generation of null checks in your code.
12:44:47 <geekosaur> happy-go-lucky optimization?
12:45:01 <evelyn> See also all the android phone manufacturers with broken kernels for new gcc versions (looking at you, Barnes & Noble!). :P
12:52:57 <dsal> I worked with a guy who was convinced he found a way to corrupt linux filesystems from a userspace program.  He was a well-known, rockstar programmer who got famous for a program he wrote in a functional language, but mostly just ranted about needing to do everything in C.  He was using an API I wrote that would call him with some data.  He'd keep the pointer I passed in and return and then later write that data to disk.
12:53:59 <dsal> I don't think this code's gonna work under 8.8, though.  So that idea's out.  :(
12:55:10 <dsal> `fail' is not a (visible) method of class `Monad'   -- that's in a dependency far enough away  from my code that I'm not even sure what it does.
12:55:51 <merijn> dsal: That's easy enough to fix, though
12:55:54 <dsal> Actually, a few dependencies are suffering under that.  This seems like it might be a disruptive transition.
12:56:07 <dsal> Can I fix it with a compiler flag?
12:56:27 <EvanR> fail was finally removed?
12:56:30 <EvanR> nice
12:56:32 <dsal> s/re//
12:56:42 <merijn> EvanR: 8.8 enables MonadFailDesugaring by default, iirc
12:57:06 <merijn> EvanR: Some horrible people have already implemend MonadFail via error in some libraries, though >.<
12:57:11 <sm[m]> it wasn't that easy to fix for me; https://github.com/commercialhaskell/stackage/issues/4802#issuecomment-529264001 might be helpful
12:57:13 <errelion> Hey there, I've got a question
12:57:24 <EvanR> yeesh
12:57:52 <errelion> I created a new Type, that is a list of another type. Now i cant figure out how to add more elements to existing lists of that type
12:57:55 <errelion> https://pastebin.com/d2EhJJAC
12:58:34 <errelion> For example in this code i want to add exampleTwo to theTester, but i cant figure out how
12:59:49 <koz_> errelion: theTester = Tester [exampleOne, exampleTwo]
13:00:09 <dsal> sm[m]: This suggests fixing the libraries that are failing, though, right?  No magic wands.
13:01:35 <merijn> dsal: Sadly, yes
13:02:48 <dsal> Yeah, this will be a long climb for an application where I just want to see if the new compiler fixes the bug. 
13:03:08 <errelion> koz_: isnt there any other way? I'm trying to write a function that goes through a list of my type and change values of it, so i need a way to do this in a recursive function
13:03:12 <errelion> and that doesnt seem to work :/
13:03:21 <jgt> merijn: show us on the monad doll where the bad fail touched you
13:03:31 <jgt> :D
13:03:53 <EvanR> "monad doll"
13:03:54 <koz_> errelion: Could you write up an example of what you want done? It's a bit hard for me to understand what you mean there.
13:04:16 <errelion> koz_: on it
13:04:16 <koz_> EvanR: instance Monad Doll where ...
13:04:56 <dsal> This might be the bug I was having the whole time, though...  The more logging and stuff I add, the more it seems that just like... threads either disappear or exit silently.     It seems to happen a lot on ARM64, but I can't make it happen on other platforms.
13:06:00 <EvanR> i was about to go on a rant about monitoring your threads but i think i already did on dsal 
13:06:44 <dsal> EvanR: yeah, I made an erlang-esque supervisor for the one that's seeming to get dropped, and that at least seems helpful.  I'll keep adding junk there until I have a much better idea of what's happening.
13:07:06 <merijn> dsal: Does your main thread exit?
13:08:01 <dsal> merijn: I don't think so.  It's in a callback somewhere that's handled by another thread.  That yields a response packet from my client and that not happening is the first bit of detection I've got.
13:08:36 <merijn> dsal: If/when main exits, all the others just die
13:09:06 <dsal> Yeah, that'd be fine for this type of thing.  I'm having an issue where one gets spawned and doesn't seem to die.
13:09:31 <dsal> Does this seem like a reasonable supervisor? https://www.irccloud.com/pastebin/yTics0Q8/supervisor.hs
13:13:54 <errelion> koz_: this would be what i want to do
13:13:56 <errelion> https://pastebin.com/WqKN7Max
13:14:37 <errelion> I've got an existing Object of Tester, i want to go through it and change the value of the objects in the list
13:14:55 <errelion> by creating a new list thats basicly the same but with the values i want to change changed
13:15:51 <errelion> but no matter how i write it, i always get type errors when compiling
13:17:31 <koz_> errelion: What do those type errors look like?
13:17:41 <errelion> Couldn't match expected type ‘Tester’ with actual type ‘[a]’
13:18:16 <dsal> errelion: There's not really enough program here.  What is changeValue?
13:19:20 <errelion> changeValue is a function that should change the value of the objects in the lists by patternmatching and recursion
13:19:42 <koz_> errelion: Your pattern match just grabs the first item, calls it 'value', and tries to blindly replace it.
13:20:00 <koz_> Type errors that I can't place aside, this sounds nothing like what you want.
13:20:27 <errelion> yeah thats right, the actual program i'm working on is a little bit different but i dont want to complicate so i wrote this example
13:20:39 <errelion> to show just the problem i got
13:20:42 <koz_> errelion: Yeah... that doesn't really help us help you.
13:21:17 <koz_> Let me try to understand here: Is your goal something like 'given a Tester, an old value and a replacement, go through the Tester and replace all occurences of the old value with the new one'?
13:21:34 <errelion> exactly!
13:21:54 <koz_> errelion: Yeah, your code does not do that.
13:22:06 <koz_> Let me find you a useful function which might.
13:22:14 <errelion> i know xD sorry i'm quite new to haskell and am trying to wrap my mind around it
13:22:32 <dsal> You might consider making Tester a Functor.
13:23:13 <dsal>  But in general, I like to put type annotations on at least toplevel things, and anywhere else I might want to remember what I'm doing.
13:23:26 <koz_> Or just use map on the underlying list.
13:23:28 <dsal> changeValue :: Tester -> Property -> Tester     -- Is that what you expect?
13:23:28 <koz_> :t map
13:23:29 <lambdabot> (a -> b) -> [a] -> [b]
13:23:43 <errelion> dsal: yes thats what i expected
13:23:50 <koz_> You basically wanna check if the value matches using ==, if it does, replace it, otherwise, leave as-is.
13:24:15 <errelion> koz_: yeah later on that would be my goal, but in this snippet i just wanted to replace it blindly
13:24:47 <errelion> oh man, i didnt think about map.. that would be usefull i guess
13:24:47 <koz_> errelion: Usually, it's better to do what you want directly. I don't usually shine my shoes as a means of alleviating hunger. :P
13:25:19 <errelion> xd
13:26:15 <dsal> errelion: Tester is basically just a list, so Functor would just unwrap it and fmap the list.  So changeValue could be something like    changeValue =  fmap (const newValue)
13:26:44 <koz_> dsal: That just blindly replaces everything. If errelion wants _targeted_ replacement, it's better to just start with that from day 1.
13:27:05 <dsal> Yeah.  That wouldn't be any harder.
13:28:29 <dsal> I'm running with -xc and I keep seeing this:     *** Exception (reporting due to +RTS -xc): (THUNK_STATIC), stack trace: 
13:28:38 <dsal> There's no exception I can see.  Is this just cancelation?
13:37:57 <EvanR> dsal: reason for a thread to die is known when you join it / await it
13:39:33 <dsal> EvanR: Understood.  I also expect these to be short lived, so I want to detect when they're not responding fast enough as well.
13:39:55 <monochrom> Haskell's killThread is by throwing an exception.  cancel would use killThread.
13:41:54 <EvanR> dsal: if they are still alive but not responding (to e.g. async exceptions) it may be they are stuck in certain FFI calls. Which is where the fun of unsafe vs safe and -threaded vs not -threaded comes in
13:42:33 <EvanR> or they could have exceptions masked
13:42:44 <EvanR> in particularly nasty way
13:43:48 <geekosaur> but that looks like an exception made its way uncaught up to the "root" of the thread, and vanished.
13:44:24 <EvanR> o_O
13:44:35 <dsal> OK, that's expected.  This is a withAsync that was satisfied, so I'd expect it to be canceled.
13:44:43 <geekosaur> right
13:46:21 <geekosaur> the behavior I described is what happens without something like async managing threads, including (I think) a thread killing itself when its function returns. it's a fairly raw interface, which is why async exists
13:50:22 <freeman42x> does anyone know how to enable jsaddle so that HIE works? I tried the following and it is not working: https://gist.github.com/razvan-flavius-panda/864f81fd55d59e6331b5c7f7567f175b
14:08:41 <inkbottle> fendor: I've initiated https://github.com/infinisil/all-hies#declarative-installation-nixos-home-manager-or-similar w/o cachix, because there were something I didn't understand with cachix: maybe not my smatest move. I tell you if it ever finishes
14:09:34 <fendor> inkbottle, for a single installation, it takes roughly an hour, iirc
14:10:06 <inkbottle> nice
14:10:19 <inkbottle> I do undersatnd now about cachix
14:10:56 <fendor> yeah, cachix turns it into a less than 5 min installation
14:12:05 <inkbottle> (I thought I had to use, like myself, the command nix-build; and I didn't know how; Now I understand that it is not I who'd use it directly; more like a callback)
14:12:56 <inkbottle> I wonder if C-c would be a good idea? Maybe not
14:13:17 <fendor> should not matter
14:13:22 <fendor> the paths still exist
14:13:31 <fendor> all-hies is designed to be idempotent, afaik
14:13:42 <fendor> so, C-c does not matter
14:13:46 <fendor> or should not
14:14:25 <inkbottle> I let it continue a little bit; maybe I have a very powerful cpu
14:15:48 <koz_> @pl \w -> (w *) <$> explog
14:15:48 <lambdabot> (<$> explog) . (*)
14:15:59 <koz_> ... yeah I think I'll leave that one. :P
14:16:22 <fendor> @type \w -> (w *) <$> explog
14:16:23 <lambdabot> error: Variable not in scope: explog :: f b
14:17:16 <koz_> What's the funny symbolic version of 'flip fmap' again?
14:17:50 <jgt> surely it's something like >$<
14:17:55 <fendor> @type <$>
14:17:56 <lambdabot> error: parse error on input ‘<$>’
14:18:01 <fendor> @type (<$>)
14:18:01 <koz_> fendor: You want :t.
14:18:02 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:18:09 <koz_> Or that.
14:18:18 <fendor> that is not flipped
14:18:23 <EvanR> i've seen $$ be flip fmap
14:18:33 <EvanR> useful in partially applying fix
14:18:57 <jgt> it's written ££ where I live
14:19:28 <koz_> <&> apparently.
14:20:15 <jgt> oh that'd make sense, being analagous to Data.Function.&
14:21:30 * hackage evdev 0.1.0.0 - Bindings to libevdev  https://hackage.haskell.org/package/evdev-0.1.0.0 (GeorgeThomas)
14:33:56 <EvanR> i was thinking of this unrelated thing...
14:34:18 <EvanR> let infixr 9 $$; ($$) = flip ($)
14:34:41 <EvanR> fix $ 'x' $$ 'y' $$ (\x y r -> ...)
14:36:15 <EvanR> an adhoc fixloop with two state variables that you initialize
14:37:11 <EvanR> that you don't have to initialize at end of multiline lambda
14:45:00 * hackage evdev 0.1.0.1 - Bindings to libevdev  https://hackage.haskell.org/package/evdev-0.1.0.1 (GeorgeThomas)
14:49:00 * hackage free-algebras 0.0.8.0 - Free algebras in Haskell.  https://hackage.haskell.org/package/free-algebras-0.0.8.0 (coot)
14:50:33 <cheater> is there a good package that will serialize an ADT into a binary representation that i can share with other haskell executables?
14:53:56 <EvanR> binary ?
14:54:09 <EvanR> also compact regions
15:07:25 <koz_> Seconding binary, assuming you're only interested in transferring data, and not, say, executable code or w/e.
15:21:55 <koz_> :t floor
15:21:56 <lambdabot> (RealFrac a, Integral b) => a -> b
15:26:48 <heatsink> > let 1 = 2 in "if it compiles, it's probably correct"
15:26:50 <lambdabot>  "if it compiles, it's probably correct"
15:27:25 <hpc> i prefer its corrolary, if it probably compiles, it's correct
15:28:25 <heatsink> I agree.  Re-starting the tests a few times is way easier than debugging.
15:28:43 <heatsink> Two passes out of three is pretty good
15:32:54 <inkbottle> fendor: Compilation is done; only remains to have it working with emacs. What editor do you use?
15:35:26 <fendor> inkbottle, vscode
15:35:30 * hackage verismith 0.4.0.0 - Random verilog generation and simulator testing.  https://hackage.haskell.org/package/verismith-0.4.0.0 (ymherklotz)
15:36:38 <inkbottle> fendor: are you using the open source version (vscodium)?
15:37:52 <koz_> OK, I'm _really_ close to getting this, but it's still throwing me. I have a Stream (Of a) m (), and a 'starting' a. I need to construct a new Stream (Of a) m (), which starts by smashing together the starting a and the first stream element, giving the first result, then takes that, smashes it with the second stream element to make the second result, until my 'smasher' gives Nothing, which signals
15:37:54 <koz_> the new stream's end.
15:38:06 <koz_> I've been trying to write this for ages and I can't find what function in Streaming.Prelude I need for that.
15:39:11 <koz_> All the stream transforms in Streaming appear to be unable to 'thread' values through like that.
15:44:01 <fendor> inkbottle, no, I dont think so
15:58:42 <dmwit> I make a proprietary tool with no e in it, whatchu calling the open source knock-off
16:03:52 <EvanR> fr softwar
16:11:20 <jgt> :D
16:12:30 * hackage setdown 0.1.0.4 - Treating files as sets to perform rapid set manipulation.  https://hackage.haskell.org/package/setdown-0.1.0.4 (RobertMassaioli)
16:30:55 <koz_> mapMaybeM is the closest I've found, but it's not _quite_ right.
16:32:08 <koz_> I could import the Internal module and write a version of mapMaybeM that suits my needs, but I suspect that this is a bad idea and I should be using something else.
16:41:04 <infinisil> koz_: Perhaps https://hackage.haskell.org/package/streaming-0.2.3.0/docs/Streaming.html#v:unfold ?
16:42:22 <koz_> infinisil: Yeah, that's got a seed value, but doesn't consume a Stream in the process. I think I'll try and write this with explicit recursion and Stream teardown, and see if someone might be able to suggest a less awful way. :P
16:43:25 <infinisil> koz_: Oh and the streaming package doesn't let you access Stream's constructors?
16:43:36 <koz_> infinisil: Only if I import Internal.
16:44:24 <infinisil> I see
16:47:38 <infinisil> koz_: Actually how about https://hackage.haskell.org/package/streaming-0.2.3.0/docs/Streaming.html#v:inspect
16:48:00 <infinisil> Looks like you could use that to deconstruct a stream one-by-one
16:48:16 <koz_> Inspect seems good - better than Streaming.Prelude.uncons.
16:49:40 <infinisil> koz_: Oh and https://hackage.haskell.org/package/streaming-0.2.3.0/docs/Streaming.html#v:destroy also seems useful
16:50:33 <koz_> infinisil: How? I'm not sure I understand that type.
16:52:11 <infinisil> You can choose the `b` to be anything, the (f b -> b) tells it how to make a b from an (Of x), the (m b -> b) from an effect, the (r -> b) from a result
16:52:29 <infinisil> It's an unfold
16:52:37 <infinisil> I mean a fold
16:54:36 <infinisil> Not sure if it's useful for this
16:59:18 <koz_> Hmm, how do I produce a stream that ends immediately...
17:00:04 <heatsink> Stream is a monoid,
17:00:17 <heatsink> so mempty seems like a good candidate
17:01:58 <koz_> That's a very good point.
17:02:32 <boxscape> uh, is there a way to make... classes of type families instead of of functions? associated types don't seem like the write thing because that's how you make *one* type family
17:02:40 <boxscape> s/write/right
17:23:30 * hackage describe 0.2.0.0 - Combinators for describing binary data structures  https://hackage.haskell.org/package/describe-0.2.0.0 (riuga)
17:25:25 <boxscape> I guess I should just look at how singletons does it, huh
17:26:10 <dmwit> I'm not sure I understand the question yet.
17:26:18 <boxscape> (it looks like the answer is "it doesn't")
17:27:04 <boxscape> dmwit basically I'm trying to pretend haskell is agda. More concretely, I just did "data Nat = Z | S Nat", and I was wondering whether there's a nicer way to name type families than to do "PlusNat" etc. for this one and then possibly "PlusSomethingElse" if I have a different number kind in the future
17:27:48 <keklel> whats abouts the haskell?
17:28:11 <dmwit> boxscape: type family Plus k (a :: k) (b :: k) :: k -- ?
17:28:28 <dmwit> type instance Plus Nat Z Z = Z, etc.
17:28:30 <keklel> yesn't
17:28:45 <boxscape> oh yeah, that's good dmwit
17:29:10 <boxscape> as long as it doesn't give me any headaches for not using closed type families, but I'm not sure if that gives you any perks besides guaranteeing that no one else can make equations
17:29:24 <boxscape> (or I guess I could also just use a closed type family for this actually)
17:29:55 <dmwit> It gives a very subtle perk to take advantage of the carefully-not-specified evaluation order of type families.
17:30:01 <boxscape> okay :)
17:42:23 <boxscape> that type family even has a kind with the "forall k -> " syntax, neat
17:44:05 <boxscape> though maybe it would be worth doing simply "type family Plus k (a :: k) (b :: k) :: k", effectively turning that arrow into a dot
17:44:12 <boxscape> uh
17:44:16 <boxscape> I mistyped
17:44:21 <boxscape> type family Plus (a :: k) (b :: k) :: k
17:44:24 <boxscape> (first k is gone)
17:45:16 <boxscape> dmwit thought on if that would be a terrible idea for reasons I can't think of?
17:51:13 <koz_> OK, I think I wrote this now. I welcome all suggestions for how generateNexts can be less awful: https://gist.github.com/kozross/60927bdcb8d0b3090f617f2c8ae9c26c
17:57:14 <MarcelineVQ> % :t maybe mempty
17:57:14 <yahb> MarcelineVQ: Monoid b => (a -> b) -> Maybe a -> b
17:57:21 <MarcelineVQ> % :t foldMap
17:57:21 <yahb> MarcelineVQ: (Foldable t, Monoid m) => (a -> m) -> t a -> m
18:01:30 * hackage describe 0.2.0.1 - Combinators for describing binary data structures  https://hackage.haskell.org/package/describe-0.2.0.1 (riuga)
18:01:39 <koz_> Oh yeah, that's kinda cool.
18:01:40 <MarcelineVQ> % :t either (const mempty)
18:01:40 <yahb> MarcelineVQ: Monoid c => (b1 -> c) -> Either b2 b1 -> c
18:01:58 <MarcelineVQ> % :t foldMap @(Either _)
18:01:58 <yahb> MarcelineVQ: Monoid m => (a -> m) -> Either w a -> m
18:02:21 <koz_> MarcelineVQ: So you're saying I need a lot more foldMap?
18:03:02 <MarcelineVQ> Or at least that catamorphism or w/e these patterns are, with a mempty base, is gonna tend to end up as foldMap
18:03:34 <koz_> It's a hylo if anything, but yeah, I see your point.
18:03:52 <koz_> It certainly makes it less fiddly presentation-wise.
18:04:06 <MarcelineVQ> 'these' meaning maybe and either and foldr, etc
18:04:36 <koz_> My main gripe about generateNexts is the use of explicit recursion. I get the feeling Streaming or Streaming.Prelude has some kind of HOF I can use for this, but I'm not seeing one.
18:05:19 <koz_> :t foldMap
18:05:21 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
18:05:59 <koz_> Is there a foldMapM?
18:11:00 <jle`> what would you want it to do?
18:11:51 <jle`> (what type are you looking for)
18:13:50 <koz_> jle`: Having thought about it some more, I realize I don't actually need it. :P
18:13:55 <koz_> (there's various takes on it)
18:14:03 <koz_> :t bool mempty
18:14:04 <lambdabot> Monoid a => a -> Bool -> a
18:14:20 <jle`> one thinkg you can do is foldMap with Ap, which basically liftA2 (<>) all the results together
18:14:37 <jle`> (Applicative f, Monoid m) => (a -> f m) -> t a -> f m
18:14:59 <jle`> :t \f -> getAp . foldMap (Ap . f)
18:15:00 <lambdabot> forall k (t :: * -> *) (f :: k -> *) (a1 :: k) a2. (Foldable t, Monoid (Ap f a1)) => (a2 -> f a1) -> t a2 -> f a1
18:15:09 <jle`> whoops
18:17:21 <jle`> % :t \f -> getAp @Type . foldMap (Ap . f)
18:17:21 <yahb> jle`: (Foldable t, Applicative f, Monoid a1) => (a2 -> f a1) -> t a2 -> f a1
18:17:27 <jle`> Ap is now polykinded for some reason
18:21:10 <koz_> Ap is what again?
18:31:30 * hackage describe 0.2.0.2 - Combinators for describing binary data structures  https://hackage.haskell.org/package/describe-0.2.0.2 (riuga)
18:43:36 <jle`> koz_: Ap is a newtype wrapper that gives (Applicative f, Monoid a) => f a a Monoid instance
18:43:42 <jle`> where mempty = pure mempty
18:43:45 <jle`> and (<>) = liftA2 (<>)
18:44:17 <koz_> Ah.
18:44:45 <jle`> so basically the existing Monoid instances for `r -> a` and `IO a`
18:45:09 <koz_> But for any Applicative.
18:45:18 <jle`> yeah
18:45:25 <jle`> so you get a different instance for types like [a] and Maybe a
18:45:52 <jle`> but basically, like Sum/Product/etc., it's a way to hijack foldMap to have it do what you want
18:46:01 <jle`> or hijack Writer etc.
19:00:54 <dmwit> boxscape: I dunno. Seems fine.
19:02:48 <boxscape> dmwit fwiw, it doesn't actually work the way you wrote it since for some reason ghc doesn't recognize that k is Nat if the first argument is Nat, but it does work if you leave out the first k 
19:02:52 <boxscape> I'm not actually sure *why* it doesn't work
19:08:00 * hackage describe 0.2.0.3 - Combinators for describing binary data structures  https://hackage.haskell.org/package/describe-0.2.0.3 (riuga)
19:09:36 <boxscape> it's really strange, actually, I think
19:09:38 <boxscape> % type family Huh (a :: k) (b :: k) :: k where Huh Int t = t 
19:09:38 <yahb> boxscape: 
19:09:40 <boxscape> that works
19:09:50 <boxscape> % type family Huh' p (a :: k) (b :: k) :: k where Huh' p Int t = t
19:09:50 <yahb> boxscape: ; <interactive>:38:56: error:; * Expected kind `k', but `Int' has kind `*'; * In the second argument of Huh', namely `Int'; In the type family declaration for Huh'
19:09:52 <boxscape> this doesn't
19:09:56 <boxscape> why?
19:10:45 <dmwit> % :k Huh'
19:10:45 <yahb> dmwit: ; <interactive>:1:1: error:; Not in scope: type constructor or class Huh'; Perhaps you meant one of these: `Ghci5.Huh' (imported from Ghci5), `Huh' (line 37)
19:10:54 <boxscape> % type family Huh' p (a :: k) (b :: k) :: k where
19:10:55 <yahb> boxscape: 
19:10:57 <boxscape> % :k Huh'
19:10:57 <yahb> boxscape: Huh' :: k1 -> k2 -> k2 -> k2
19:11:10 <boxscape> dmwit ^
19:11:26 <dmwit> puzzling
19:11:31 <boxscape> indeed
19:11:57 <dmwit> % type family Huh'' p (a :: k) :: k where Huh'' p Int = Int
19:11:57 <yahb> dmwit: ; <interactive>:42:49: error:; * Expected kind `k', but `Int' has kind `*'; * In the second argument of Huh'', namely `Int'; In the type family declaration for Huh''
19:12:37 <heatsink> % type family Huh''' p (a :: k) :: k where Huh''' @Type p Int = Int
19:12:37 <yahb> heatsink: ; <interactive>:44:49: error: parse error on input `@'
19:12:50 <heatsink> That feature isn't turned on
19:12:56 <boxscape> is it even a feature yet?
19:13:00 <heatsink> % type family Huh''' (k :: Type) p (a :: k) :: k where Huh''' Type p Int = Int
19:13:00 <yahb> heatsink: 
19:13:03 <boxscape> type application in patterns in types?
19:13:30 <boxscape> I think visible kind application became a feature in 8.8, not sure if it works in patterns, but yahb uses an earlier version of ghc
19:13:43 <heatsink> I see
19:13:54 <dmwit> heatsink: But how does that explain the discrepancy between having p and not having p?
19:14:11 <dmwit> What you did there seems more like a workaround than an explanation of what went wrong.
19:14:41 <heatsink> I didn't notice that p made a difference
19:15:18 <dmwit> Yeah. Huh (a :: k) :: k is fine, Huh p (a :: k) :: k isn't.
19:15:40 <dmwit> (With a where block that matches a with Int and returns it.)
19:15:52 <heatsink> That's weird
19:18:33 <boxscape> also "Huh (a :: k) :: k where" works, but "Huh (a :: k) where" doesn't
19:18:43 <boxscape> wait actually that one makes sense
19:19:08 <boxscape> no it doesn't
19:19:13 <boxscape> type family Test (a :: k)  where Test Int = Test Int
19:19:17 <boxscape> still fails with the same error
19:19:40 <boxscape> or even type family Test (a :: k)  where Test Int = Test Double
19:19:48 <boxscape> fails on the Int, not on the Double
19:21:36 <boxscape> s/Test Double/Double
19:22:46 <boxscape> oh is this one of those weird CUSK things?
19:22:53 <boxscape> I mean weird CUSK issues?
19:23:50 <boxscape> it is!
19:23:56 <boxscape> None of them (I think) work with -XNoCusks enabled
19:24:00 <boxscape> uh
19:24:08 <boxscape> -XNoCUSKs
19:24:17 <boxscape> dmwit heatsink
19:24:49 <boxscape> wait
19:24:50 <jsomedon> what does `rec` do?
19:24:54 <boxscape> that's not true, the first one still works
19:25:11 <boxscape> uh never mind
19:25:18 <jsomedon> for example `rec . tail`
19:25:18 <boxscape> it doesn't work, it *is* a CUSK issue
19:25:50 <iqubic> :t rec
19:25:51 <lambdabot> error:
19:25:51 <lambdabot>     • Variable not in scope: rec
19:25:51 <lambdabot>     • Perhaps you meant one of these:
19:26:24 <jsomedon> already tried that on bot and local repl
19:27:30 <boxscape> jsomedon: https://wiki.haskell.org/MonadFix
19:27:35 <boxscape> It's from RecursiveDo
19:30:00 * hackage describe 0.2.0.4 - Combinators for describing binary data structures  https://hackage.haskell.org/package/describe-0.2.0.4 (riuga)
19:30:40 <jsomedon> hmm I thought it's a simple function but the doc you gave me looks pretty difficult for me to read
19:31:02 <boxscape> it's never something I've personally needed
19:31:10 <jsomedon> so do I need to know monad to understand this? I am still learning Haskell..
19:31:11 <boxscape> s/never/not
19:31:19 <boxscape> I think that would be a good idea
19:31:23 <boxscape> how did you come across rec?
19:31:57 <jsomedon> so context is I saw this puzzle: implement dropWhile using fold, I think someone posted this in this channel yesterday
19:32:19 <jsomedon> and one of solution uses rec
19:32:21 <jsomedon> so
19:32:26 <boxscape> hm, okay
19:32:51 <dmwit> I'd bet they also defined rec right then and there.
19:32:57 <MarcelineVQ> boxscape: rec . tail suggests it's a function not a keyword
19:33:02 <boxscape> true
19:33:13 <jsomedon> ok here is the link: https://wiki.haskell.org/wikiupload/1/14/TMR-Issue6.pdf
19:33:28 <EvanR> is The Monad Reader still around?
19:33:35 <jsomedon> in the chapter: Getting a Fix from the Right Fold
19:33:52 <jsomedon> EvanR: I think you or someone else posted this link
19:33:58 <EvanR> it was koz_ 
19:34:02 <boxscape> jsomedon looks like they gave one of the arguments the name "rec"
19:34:03 <jsomedon> ah yes
19:34:09 <EvanR> and yeah i don't think it has to do with monads
19:34:22 <koz_> EvanR: Last publication was about 2015 or so I think, and it was a mini-issue.
19:34:25 <jsomedon> boxscape: ohhh right
19:34:34 <EvanR> ok so it's in cryo stasis
19:34:39 <koz_> That issue of TMR is actually pure gold.
19:34:52 <koz_> Like, all three of those articles are super interesting.
19:35:02 <jsomedon> koz_: you mean the one I am reading?
19:35:05 <EvanR> yeah i started reading the whole thing
19:35:20 <koz_> jsomedon: Assuming you're reading that link, yes.
19:35:34 <EvanR> i like the "we're going to publish PDFs now, not blog posts"
19:36:00 <koz_> EvanR: The one making an assembler in RWS, then going 'ain't nobody got time for that' and then burning out R and S using MonadFix blew my actual mind.
19:36:27 <boxscape> dmwit btw to make the original definition work you have to use "type family Plus (k :: Type) (a :: k) (b :: k) :: k where", i.e. you have to give a kind to every parameter to make it a CUSK 
19:37:57 <boxscape> (or use the new StandaloneKindSignatures which I think are only in HEAD so far)
19:38:58 <EvanR> koz_: haven't gotten there yet
19:39:47 <EvanR> i need to get back into the regularly scheduled "mind blown" of haskell. It's been a while
19:40:37 <koz_> EvanR: That one blew my mind because I knew about MonadFix, but never understood what it's for.
19:40:49 <heatsink> I think I'm developing a tolerance for haskell.  I need something stronger.
19:41:39 <koz_> heatsink: #idris and #agda exist. :P
19:41:39 <EvanR> wanna name names there?
19:41:45 <EvanR> hmm...
19:44:41 <MarcelineVQ> koz_: it's for implementing/using Reflex and nothing else right?
19:45:05 <koz_> MarcelineVQ: And implementing assemblers in Haskell apparently. :P
19:47:10 <EvanR> something something observable sharing
19:51:42 <fraktor> I've got a problem where I want to get a random sampling of several different permutations of a set.  (I'd like to get, say, 10,000 permutations of a set with 26 elements).  I don't just want to shuffle it 10,000 times, since that might end up with repeats.  Does anyone have a suggestion on how I might do this?
19:52:17 <EvanR> the chance of a repeat is incredibly low
19:52:33 <EvanR> but even if it happened, that would technically be random
19:53:50 <EvanR> > product [1..26]
19:53:52 <lambdabot>  403291461126605635584000000
19:53:58 <fraktor> That's true.  Let me clarify a bit: I want to find the "best" permutation given some scoring function, but I don't have the computing power to check all of them.
19:53:59 <EvanR> hmm
19:54:17 <rajivr___> I am new to Haskell. I was trying to understand why `getInt` type checked and in the process ended up informally solving for type variables `a`, `b`, and `f` in my head. https://gist.github.com/rajivr/a2b26d5708118c9b01ed5d4e2f2b76f9#file-test-hs-L12  . I was wondering if Haskellers use some form of methodology / notation for doing type checking on paper?
19:54:37 <ammar2> probability is (1-(1/26!))^(10000)
19:56:53 <ammar2> fraktor: hmm, what kind of scoring function is it?
19:56:57 <EvanR> ah birthday paradox
19:57:44 <koz_> rajivr___: In this case, it's not terribly difficult. fmap just 'lifts' a pure function into IO: specializing for it, we get 'fmap :: (a -> b) -> IO a -> IO b'.
19:58:23 <koz_> The type for b is forced by the type of getInt (namely Int).
19:58:37 <koz_> And a is forced by getLine (to String).
19:59:02 <heatsink> rajivr___: Working out types by hand boils down to matching up two types that have to be equal.  When one type has a variable, the other type tells you what the variable is.
19:59:12 <rajivr___> koz_:  That's correct. When working with QuickCheck exercises, I had seen more scarier types which took a lot more time to comprehend.
19:59:29 <koz_> rajivr___: It takes time to get used to that, but this is purely a matter of practice.
20:00:27 <rajivr___> I see. So, there is no shortcut other than just staring at it till it reveals itself? :-)
20:00:43 <dmwit> I mean, you can read and learn about unification, which gets you most of the way there.
20:00:51 <heatsink> rajivr___: For example, we know that (++) :: [a] -> [a] -> [a].  So consider how you'd figure out the type of x in `x ++ [True]`
20:01:13 <EvanR> luckily you don't have to check types in your head
20:01:20 <EvanR> there's a type checker
20:01:45 <koz_> rajivr___: Usually, there's a more goal-directed approach. You normally have a desired type in mind, and a starting point. Then you just try and find the steps in-between, with the compiler helping you along.
20:02:54 <rajivr___> dmwit: What would be a good resource to learn about unification? 
20:02:56 <heatsink> rajivr___: (++) expects something of type [a], and the type of [True] is [Bool].  So we have [a] = [Bool].
20:03:50 <rajivr___> heatsink:  Yes, I can those right now. Right now it takes sometime with higher kinded types involving many type classes.
20:04:57 <rajivr___> So, I wanted to make sure there was no trick advanced haskellers use, that I was missing on! :-) If its a matter of practice, I'll get there eventually. :-)
20:05:05 <heatsink> For anything complex, you can get help from type inference.  You're probably seen people use lambdabot's :t feature here
20:05:20 <heatsink> You can do the same thing in ghci to ask what the type of something is
20:06:08 <rajivr___> heatsink:  Yes, I use type inference all the time! :-) Othewise, there would have been no way I would have been able to comprehend what was going on.
20:06:10 <dmwit> rajivr___: I think I got the gist of it from TAPL.
20:06:23 <heatsink> Also, when I'm trying to figure out the types in a piece of code I already have, writing more type annotations help
20:06:29 <dmwit> rajivr___: You might also like https://stackoverflow.com/q/12532552/791604 , though reviewing it now it doesn't seem to explicitly talk about unification there.
20:07:03 <heatsink> > ([3] :: [Int]) ++ 4
20:07:05 <lambdabot>  error:
20:07:05 <lambdabot>      • No instance for (Num [Int]) arising from the literal ‘4’
20:07:05 <lambdabot>      • In the second argument of ‘(++)’, namely ‘4’
20:07:09 <heatsink> > ([3] :: [Int]) ++ [4]
20:07:11 <lambdabot>  [3,4]
20:07:30 <heatsink> Of course that's a simple example.  In complex code, it can be helpful to write extra annotations
20:08:18 <heatsink> This might be helpful, though it's more about the unification algorithm than about how to do it by hand https://pointlessfunctor.blogspot.com/2017/05/efficient-unification.html
20:08:19 <rajivr___> TAPL = Types and Programming Languages (*cough* scary red book?) 
20:08:25 <fraktor> ammar2: This is mostly just an experiment for me to try to find the "optimal" keyboard layout given a particular corpus of text.  So it will take the letters, and give a higher score to layouts that involve repeating different keys with the same finger, and a higher score for a key that isn't on home row (so that more common keys will tend to drift towards home row.)
20:09:21 <dmwit> rajivr___: You might also like to look at https://stackoverflow.com/q/32368507/791604 , in which I explain how to ask GHC to do a unification problem, as a way to sort of "check your work" after you set yourself some exercises.
20:09:29 <dmwit> rajivr___: Yes, that is the TAPL I mean.
20:12:04 <rajivr___> dmwit:  heatsink : Thanks for the pointers. I really appreciate the help. :-)
20:13:59 <heatsink> You're welcome.  Please let me know what you think of the blog post, I'm not sure how it looks from others' point of view.
20:20:00 * hackage hdocs 0.5.4.0 - Haskell docs tool  https://hackage.haskell.org/package/hdocs-0.5.4.0 (AlexandrRuchkin)
20:21:20 <macroprep> ok, in Axler, a complex number is defined as "  A complex number is an ordered pair (a; b), where a; b (rounded E) R, but we will write this as a + bi ." right? ( https://i.imgur.com/HyjiZT2.png ), such that a and b are real numbers, must exist in R, and the dimensions MUST be a power of two, eg (1) is NOT suitible for C, (1, 2) IS suitible for C, (1, 2, 3) is NOT suitible for C, (1, 2, 3, 4) IS suitible for C, and so on, 
20:21:21 <macroprep> correct?
20:23:18 <monochrom> Wrong channel?
20:24:13 <EvanR> :t a :+ b -- we write it like this
20:24:15 <lambdabot> Complex Expr
20:25:00 <boxscape> > exp ((0 :+ 1) * pi)
20:25:01 <lambdabot>  (-1.0) :+ 1.2246467991473532e-16
20:25:09 <boxscape> neat
20:25:33 <EvanR> so close
20:26:41 <EvanR> > decodeFloat 1.2246467991473532e-16
20:26:43 <lambdabot>  (4967757600021511,-105)
20:27:05 <EvanR> ok could be closer
20:27:16 <boxscape> just an ulp away
20:27:18 <boxscape> or something like that
20:27:39 <boxscape> > encodeFloat (4967757600021511,0)
20:27:41 <lambdabot>  error:
20:27:41 <lambdabot>      • Couldn't match expected type ‘Integer’
20:27:41 <lambdabot>                    with actual type ‘(Integer, Integer)’
20:28:07 <boxscape> > encodeFloat 4967757600021511 0
20:28:10 <lambdabot>  4.967757600021511e15
20:29:36 <boxscape> macroprep 1 is also a power of 2, it's 2^0
20:32:33 <sarahzrf> ulp?
20:33:00 <heatsink> unit of least precision
20:33:01 <koz_> sarahzrf: Unit of Least Precision.
20:33:24 <sarahzrf> > exp (0 :+ pi)
20:33:26 <lambdabot>  (-1.0) :+ 1.2246467991473532e-16
20:33:30 <EvanR> that number seems relatively far from zero given precision of Double
20:33:43 <heatsink> It's the smallest value you can add to a floating-point number to get a different floating-point number.
20:33:59 <sarahzrf> doesnt that vary based on the size of the float
20:34:07 <EvanR> that varies on the magnitude
20:34:08 <heatsink> yes
20:35:55 <heatsink> The term ULP is common when analyzing the accuracy of FP algorithms
20:36:16 <heatsink> 1/2 ULP is the lower bound on the algorithm's accuracy, since you can't make a number that's closer to the true answer
20:36:22 <dmwit> EvanR: It is probably fixable if you care enough. See also https://stackoverflow.com/q/48100794/791604
20:39:04 <EvanR> > sin pi
20:39:05 <lambdabot>  1.2246467991473532e-16
20:39:29 <EvanR> going to guess the limit here is the precision of pi
20:40:10 <sim590> https://paste.debian.net/1104969/ How can I call randomCell sucessively from twoRandomDistinctCells? On one side I'm in monad ReaderT LConf (State StdGen) and on the other side I'm in ReaderT LConf Identity. Can I make the value go from one to another? I'm still begining with monads and transformers and I'm not sure what operation to use.
20:40:26 <sim590> Clearly, it's not lift, because I don't want to pull it up, but sideways if that makes sense.
20:40:31 <EvanR> > let p = realToFrac (pi::Double) :: CReal
20:40:32 <lambdabot>  <no location info>: error:
20:40:33 <lambdabot>      not an expression: ‘let p = realToFrac (pi::Double) :: CReal’
20:40:50 <EvanR> @let p = realToFrac (pi::Double) :: CReal
20:40:51 <lambdabot>  Defined.
20:40:52 <boxscape48> > exp ((0 :+ 1) * pi) :: Float
20:40:54 <lambdabot>  error:
20:40:54 <lambdabot>      • Couldn't match expected type ‘Float’
20:40:54 <lambdabot>                    with actual type ‘Complex Double’
20:41:00 <EvanR> > sin p
20:41:02 <lambdabot>  error:
20:41:02 <lambdabot>      Ambiguous occurrence ‘p’
20:41:02 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.p’,
20:41:04 <boxscape48> > exp ((0 :+ 1) * pi) :: Complex Float
20:41:06 <lambdabot>  (-1.0) :+ (-8.742278e-8)
20:41:26 <EvanR> @let pie = realToFrac (pi::Double) :: CReal
20:41:28 <lambdabot>  Defined.
20:41:31 <EvanR> > sin pie
20:41:32 <lambdabot>  0.0000000000000001224646799147353177226066
20:41:58 <EvanR> bingoo
20:43:07 <sim590> Should I be using MonadReader instead of ReaderT?
20:43:07 <EvanR> sin pi is exactly right, give what pi is
20:43:17 <EvanR> given
20:43:21 <koz_> sim590: You can't do that - you need the ability to perform random generation to call randomCell, but the stack in twoRandomTooLongNameCells doesn't include it.
20:46:02 <sim590> koz_: but I can't include that in twoRandomDinstinctCells? Can I?
20:46:09 <sim590> I mean, I could
20:46:12 <sim590> But
20:46:22 <koz_> sim590: Not only _could_ you, but _must_ you.
20:46:38 <sim590> How can I stop this? It needs to stop at some point when I go up the call stack.
20:46:38 <koz_> You can't magic up (or magic away) effects on a whim like that.
20:47:14 <koz_> sim590: Usually, you'd build up a complete computation in FooT (BarT s (BazT t u v ... ))...) a, then have a 'runMyStack' function which handles all effects.
20:47:21 <EvanR> if you want magic you have to use IO
20:47:51 <sim590> OK, so it stops when I use runReader.
20:48:15 <koz_> sim590: Your stack already is 2 deep - you need to handle _both_ the reader and state parts.
20:48:28 <koz_> (assuming you wanted to use randomCell in any part of your built-up computation)
20:49:28 <sim590> But randomCell needs to know about LConf, so I thought I should use ReaderT.
20:49:44 <koz_> sim590: Look at the type signature for randomCell.
20:50:15 <koz_> You have 2 effects - one from ReaderT LConf, another from State StdGen.
20:50:21 <koz_> You gotta handle them _both_ to get your result.
20:50:44 <sim590> Yeah. So I put this `twoRandomDistinctCells :: ReaderT LConf (State StdGen) (Cell, Cell)` and it's good.
20:51:04 <sim590> Yeah?
20:51:31 <sim590> In terms of maintainability and such.
20:51:41 <koz_> Maintainability isn't the issue here.
20:52:05 <koz_> The issue is that you can't magically call operations that require an effect to be in your stack in the context of a stack without that effect.
20:52:14 <koz_> It's like saying 'I wanna use readLine, but don't wanna be in IO'.
20:53:20 <sim590> I agree, so I put `State StdGen` inside the ReaderT for twoRandomDistinctCells and up in the stack I will end this with runReader giving the conf.
20:55:25 <fraktor> If I write code that uses the Random Monad, is there a way to get that into some other Monad (ideally IO)?
20:55:52 <koz_> fraktor: Are you writing library or application code?
20:55:58 <koz_> How much flexibility do you need the stack to have?
20:56:01 <fraktor> Application code
20:56:01 <sim590> koz_: Am I saying the same thing as you or am I misunderstanding and keeping contradicting you? I'm not sure.
20:56:27 <koz_> fraktor: If you're writing application code, you can just build a stack out of RandT and IO, wrap it up nice, and use that.
20:56:37 <koz_> Write some helpers for common operations to avoid lift-spam and go.
20:56:51 <koz_> sim590: I think we're in agreement.
20:57:02 <fraktor> Oh damn, I need to learn how to use Transformers I guess.
20:57:12 <sim590> koz_: alright. Thanks!
20:57:26 <EvanR> either that or use random support in IO 
20:57:27 <maerwald> fraktor: or use something else :)
20:57:44 <koz_> Yeah, I would say that if you're in IO already, you might as well do your RNG in that too.
20:57:56 <koz_> Generally speaking, once you've hit IO, you can already do anything anyway. :P
20:58:39 <EvanR> spedometer reads "IO mph"
20:58:50 <EvanR> redlining
20:59:11 <maerwald> Say, you have a function with a transformer stack of reader, writer, state, something else and... IO inside. What can you say about this function? Only "it might do anything". So what's the point in terms of reasoning about effects?
20:59:48 <EvanR> basically StateT covers all those
20:59:54 <EvanR> if you have IO
21:00:19 <EvanR> and actually makes Writering efficient
21:00:32 <koz_> EvanR: Writering, lol.
21:04:07 <EvanR> i'm not exactly sure, but i think Writer is this big disappointing thing in terms of efficiency
21:04:55 <EvanR> if you're trying to do a log of some sort
21:04:59 <koz_> Well, lazy Writer is super-duper-lazy.
21:05:09 <koz_> Strict Writer is only slighly less so.
21:05:10 <EvanR> that's what i meant by Writering was logging
21:05:22 <koz_> I think they have an even-more-strict Writer now.
21:05:23 <EvanR> like an execution trace
21:05:40 <koz_> Which demonstrates that, as in real life, Writering is hard. :P
21:08:29 <EvanR> efficient purely function log...
21:08:34 <EvanR> -al
21:14:44 <koz_> EvanR: The even-stricter-WriterT I meant was https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Writer-CPS.html
21:23:25 <Nevoic> Does anyone here have a good resources on lens? Specifically on the meaning of most of the operators? The best I've found is https://github.com/ekmett/lens/wiki/Operators but it's really not comprehensive and I don't understand the categories.
21:23:36 <Nevoic> https://pastebin.com/9BfZwPxm code like this still confuses me.
21:24:29 <Nevoic> Pretty much I want to understand `<=>` `<+>` `.~` and `<|>`. i'm sure I'll come across more I don't know.
21:24:54 <Nevoic> I think I understand `^.` to some extent.
21:27:27 <sarahzrf> :t (<=>)
21:27:29 <lambdabot> error:
21:27:29 <lambdabot>     • Variable not in scope: <=>
21:27:29 <lambdabot>     • Perhaps you meant one of these:
21:27:33 <sarahzrf> hmm
21:27:37 <sarahzrf> i can tell u that <|> is not from lens
21:27:41 <sarahzrf> :t (<|>)
21:27:42 <lambdabot> Alternative f => f a -> f a -> f a
21:27:53 <sarahzrf> :t (<+>)
21:27:54 <lambdabot> error:
21:27:54 <lambdabot>     Ambiguous occurrence ‘<+>’
21:27:54 <lambdabot>     It could refer to either ‘Control.Arrow.<+>’,
21:28:03 <sarahzrf> 🤨
21:28:07 <Nevoic> :t (Control.Lens.<+>)
21:28:08 <lambdabot> error:
21:28:08 <lambdabot>     Not in scope: ‘Control.Lens.<+>’
21:28:08 <lambdabot>     Perhaps you meant one of these:
21:29:35 <Nevoic> I'm using these in the context of Brick, if that helps.
21:29:44 <Nevoic> But what does the `<|>` lens do?
21:30:12 <Nevoic> The signature doesn't help me at all. I don't even know what Alternative is.
21:30:14 <Nevoic> :i Alternative
21:30:19 <Nevoic> :t Alternative
21:30:21 <lambdabot> error:
21:30:21 <lambdabot>     Data constructor not in scope: Alternative
21:31:24 <Nevoic> Oh okay, `<|>` is a method on the Alternative typeclass.
21:35:29 <Nevoic> :t .~
21:35:30 <lambdabot> error: parse error on input ‘.~’
21:35:33 <Nevoic> :t (.~)
21:35:34 <lambdabot> ASetter s t a b -> b -> s -> t
21:35:49 <Nevoic> so that looks like it was probably the only lens out of the list I wrote loll
21:36:43 <sarahzrf> :t ix 3 .~ 'x'
21:36:44 <lambdabot> (Ixed t, Num (Index t), IxValue t ~ Char) => t -> t
21:36:55 <sarahzrf> :t (ix 3 .~ 'x') "hello"
21:36:56 <lambdabot> [Char]
21:37:02 <sarahzrf> > (ix 3 .~ 'x') "hello"
21:37:04 <lambdabot>  "helxo"
21:37:08 <sarahzrf> > "hello" & ix 3 .~ 'x'
21:37:10 <lambdabot>  "helxo"
21:37:36 <sarahzrf> stab stab stab
21:46:27 <Nevoic> :t ix
21:46:29 <lambdabot> (Ixed m, Applicative f) => Index m -> (IxValue m -> f (IxValue m)) -> m -> f m
21:46:50 <Nevoic> ix 3 "potato" "potatotaot"
21:47:04 <Nevoic> > ix 3 "potato" potaotaot"
21:47:06 <lambdabot>  <hint>:1:25: error:
21:47:06 <lambdabot>      lexical error in string/character literal at end of input
21:47:36 <Nevoic> > f = ix 3 .~ 'x'
21:47:39 <lambdabot>  <hint>:1:3: error:
21:47:39 <lambdabot>      parse error on input ‘=’
21:47:39 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
21:47:45 <Nevoic> > let f = ix 3 .~ 'x'
21:47:47 <lambdabot>  <no location info>: error: not an expression: ‘let f = ix 3 .~ 'x'’
21:52:55 <macroprep> Nevoic: thought you said :I wrote a loli*
21:53:06 <macroprep> Nevoic: thought you said "I wrote a loli" *
21:57:53 <MarcelineVQ> her name's Mamooru-chan and she harbors a dark secret, late every night she mysteriously transforms into a middle-aged police officer and hunts down evildooers, many whacky adventures result in this wonderful coming of age tale soon to become an animated feature film
21:59:30 * hackage discord-haskell 1.1.3 - Write bots for Discord in Haskell  https://hackage.haskell.org/package/discord-haskell-1.1.3 (Aquarial)
22:06:10 <sim590> I know that I can extract a value from `Reader` using `runReader`, but what if I have `ReaderT (State StdGen)` ? I want to pass both `LConf` and `State StdGen`, but I'm not sure how to pass both at the same time.
22:06:39 <sim590> I have tried nonsense like this `(runState <$> makeLabyrinth <*> (mkStdGen 0)) (LConf 3 3)`
22:07:02 <EvanR> the types will reveal the path
22:07:05 <sim590> (I know that mkStdGen 0 is not safe).
22:12:49 <sim590> `makeLabyrinth` is of type `ReaderT LConf (State StdGen) Labyrinth`
22:13:09 <EvanR> so the last think you will do is runReaderT
22:13:19 <sim590> Does that exist?
22:13:25 <EvanR> :t runReaderT
22:13:26 <lambdabot> ReaderT r m a -> r -> m a
22:13:49 <EvanR> ok, make that the first thing you will do
22:14:26 <EvanR> since that gives you a State StdGen Labyrinth, you then need to runState
22:14:26 <sim590> Oh
22:15:00 <sim590> YES. That's it. I must be dislexic. I didn't see runStateT in hoogle.
23:12:00 * hackage mini-egison 0.1.4 - Template Haskell Implementation of Egison Pattern Matching  https://hackage.haskell.org/package/mini-egison-0.1.4 (SatoshiEgi)
23:20:19 <koz_> sim590: Basically, you have to unravel your stack from the 'outermost' effect.
23:20:53 <koz_> In the case of ReaderT Whatever (State WhateverElse) a, that means runReaderT first, then {run,eval,exec}State.
23:24:34 <sim590> koz_: Yes! The thing is that I was trying to use runReader. Also, I wasn't sure if I had to do runState before or after runReader (which should have been runReaderT). After running runReaderT, I saw that I had to do runState then. This all makes sense now that I can see the signature of runReaderT which I didn't see before.
23:25:02 <koz_> sim590: It's fine. For every non-transformer 'resolver', there's also a transformer version.
23:25:14 <koz_> So like, runReader - runReaderT, runState - runStateT, etc.
23:26:38 <sim590> I just realized that. I'm begining to understand how to use those things ;).
23:36:12 <__dingbat__> Hello, I am trying to read a config file (YAML) as below and facing errors, any help on this would be appreciated
23:36:32 <__dingbat__> data Config = Config
23:36:33 <__dingbat__>     { tcpPort                      :: PortNumber
23:36:34 <__dingbat__>     , udpPort                      :: PortNumber
23:36:36 <__dingbat__>     , secretKey                    :: SecretKey
23:36:37 <__dingbat__>     , trustedPeers                 :: [Peer]
23:36:39 <__dingbat__>     , myNodeId                     :: ByteString
23:36:40 <__dingbat__>     , myIp                         :: String
23:36:42 <__dingbat__>     , logFile                      :: T.Text
23:36:43 <__dingbat__>     , sbound                       :: Int
23:36:45 <__dingbat__>     , pingThreshold                :: Int
23:36:46 <__dingbat__>     , kademliaConcurrencyFactor    :: Int
23:36:48 <__dingbat__>     } deriving (Show, Generic)
23:36:56 <__dingbat__>  
23:37:00 <__dingbat__> instance FromJSON Peer where
23:37:02 <__dingbat__>     parseJSON (Object o) = do
23:37:03 <__dingbat__>         v <- Prelude.head <$> o .: "trustedPeers"
23:37:05 <__dingbat__>         Peer <$> v .: "nodeID" <*> v .: "endPoint"
23:37:06 <__dingbat__>     parseJSON _ = error "Can't parse "
23:37:08 <__dingbat__>  
23:37:41 <MarcelineVQ> best to link to a paste when you've got more than a couple lines :>
23:37:56 <__dingbat__> ok will share, thanks
23:38:24 <MarcelineVQ> And you'd want to include your error in the paste
23:38:37 <__dingbat__> yes, surely
23:38:51 <koz_> Also, you're parsing JSON? Or YAML?
23:42:37 <__dingbat__> here is the link - https://www.codepile.net/pile/5yjd2Rvm
23:45:00 <__dingbat__> trying to parse a YAML file
23:45:26 <__dingbat__> have now included the yaml file contents into the snippet as well
23:47:07 <amorris> How do I import Data.Char in https://gist.github.com/aimorris/c7ab415a75d9e9f48eb7f8326bbd1e70?
23:47:45 <dsal> amorris: add "Import Data.Char" on that blank line?
23:48:11 <amorris> oh
23:48:22 <MarcelineVQ> __dingbat__: You're trying to parse like Peer is Peer NodeId Endpoint, but it's Peer (NodeId, Endpoint). So you probably want something like, Peer <$> ((,) <$> v .: "nodeID" <*> v .: "endPoint")
23:50:25 <MarcelineVQ> But koz_'s question is important, you're writing a json parser but yaml isn't json, afaik
23:50:40 <koz_> This is why I asked.
23:51:13 <__dingbat__> ok, I can switch back to JSON, but I am not able to get past compiling this...
23:51:28 <__dingbat__> will try your solution now
23:52:35 <__dingbat__> i have made the link EDITABLE now , incase you want to make trivial changes
23:52:40 <__dingbat__> appreciate your help
23:54:16 <__dingbat__> it compiled!! Yah
23:54:51 <__dingbat__> thanks, now i will have to switch it to JSON you mean? YAML will need significant code change?
23:55:48 <koz_> If you want to parse YAML, a FromJSON instance won't help terribly much.
23:55:57 <koz_> (as the name suggests)
23:56:17 <__dingbat__> I realized that, but didnt know if i could easily swap a different instance
23:56:20 <__dingbat__> for YAML
23:56:54 <MarcelineVQ> yaml is not a simple as json afaik so it will be more work but I've not written a parser for either. This looks like you're using aeson, which is only for working with JSON
23:57:26 <__dingbat__> ok, will change the config file to JSON
23:58:18 <MarcelineVQ> You could do that or you could use someone else's yaml parser it depends what your goals are
23:59:30 <__dingbat__> i just wanted a simple config file, JSON will do I guess. Thanks again
