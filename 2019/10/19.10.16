00:55:10 <dminuoso> tdammers: Cheers.
01:09:14 <maerwald> "constraint from project config TODO" -- err, cabal?
01:10:46 <maerwald> what does that even mean
01:34:14 * hackage partial-records 0.2.1.0 - Template haskell utilities for constructing records with default values  https://hackage.haskell.org/package/partial-records-0.2.1.0 (mniip)
01:39:25 <maerwald> is there an equivalent in optics for 'non'? https://hackage.haskell.org/package/lens-4.18.1/docs/Control-Lens-Iso.html#v:non
01:43:41 <Taneb> maerwald: I think Optics.Iso exports 'non :: Eq a => a -> Iso' (Maybe a) a'
01:44:49 <maerwald> https://hackage.haskell.org/package/optics-core-0.1/docs/Optics-Iso.html don't see it
01:45:38 <Taneb> Ah, I'm looking at the GitHub source
01:45:42 <Taneb> Maybe it's not been released
01:50:56 <boxscape> huh interesting that in the STG paper from 1992 they use data Tuple3 a b c = MkTuple3 a b c rather than punning
02:00:06 <MarcelineVQ> what does punning mean for that?
02:01:27 <boxscape> MarcelineVQ type and data constructor having the same name
02:03:23 <boxscape> first time I came across this Mk convention was in Idris
02:03:51 <MarcelineVQ> That's because there's not a seperate level/namespace between types and values
02:04:41 <boxscape> Right, which is why I'm surprised that they did it in the STG paper - that language presumably *does* have separate namespaces
02:07:23 <MarcelineVQ> idk if their STG language does, it's a bit of a bad habbit anyway, convenient though :>
02:10:33 <boxscape> it'll be interesting to see how that develops as haskell moves towards dependent types
02:25:13 <maerwald> boxscape: does it?
02:26:33 <boxscape> maerwald It seems likely at this point. Many people are in favor of it and there are several active proposals slowly going in that direction
02:27:10 <boxscape> (and Richard Eisenberg is on the steering comittee)
02:27:18 <maerwald> I thought it's pretty controversial
02:27:39 <boxscape> I suppose the question is how backwards compatible you can make it
02:27:48 <maerwald> or if you even want it in the language
02:29:40 <boxscape> true, though that seems like a hard argument to win if there's many people who do want it and if it were fully backward compatible (though I don't expect that)
02:31:34 <maerwald> well, winning arguments is rarely about the arguments :P
02:33:51 <Rembane> If you do the implementation slow enough, backwards compability won't be an issue
02:35:06 <lortabac> as far as I know the very-long term plan is to make type families disappear, so it's certainly not backward compatible
02:36:31 <Rembane> Is there any documentation about that plan, or is it just in the heads of people?
02:36:47 <MarcelineVQ> what subsumes open type families?
02:37:00 <lortabac> MarcelineVQ: class methods
02:37:20 <boxscape> Rembane Richard Eisenbergs thesis contains a plan on how to make Haskell dependent, but IIRC it doesn't talk about what features to remove in the long-term
02:37:31 <Rembane> boxscape: Got it. Thanks. 
02:37:32 <boxscape> s/dependent/dependently-typed
02:37:54 <MarcelineVQ> isn't that a stepbackwards, now you need a class and a class constraint?
02:38:06 <lortabac> boxscape: no, but he talked about his ideas during the latest Zurihac
02:38:08 <maerwald> I hope it won't happen, it will be a hit to the knee for haskell adoption and make it even more niche.
02:38:17 <boxscape> lortabac ah, good to know
02:38:41 <lortabac> also, Tweag is paying him to work on GHC
02:39:51 <lortabac> maerwald: DependentHaskell is not ineluctable, all the proposals still need to be discussed on Github
02:41:39 <boxscape> I think making sure that dependent haskell doesn't overly affect people who don't want to deal with it (or newcomers) is a concern that many people have, so hopefully it'll be addressed if we are going in that direction
02:41:43 <maerwald> I mean, show me a language with dependent types that has wide adoption and isn't just experimental.
02:42:31 <maerwald> it blows up the language and ecosystem complexity
02:42:48 <maerwald> It's good for specific domains, not for a general purpose language
02:43:21 <jgt> I like the idea of dependent types, and I have to agree. It's pretty easy to ruin a language by just adding everything to it
02:44:00 <boxscape> I think the best thing you can do if you're concerned is participate in the proposal discussions
02:44:08 <maerwald> Instead, look at the F* approach. They created a new language with basically dependent types that compiles to F#, without trashing F#
02:44:21 <maerwald> You can do the same with haskell
02:44:53 <lortabac> the thing is, for people who already do advanced type computations dependent types will simplify the language considerably
02:45:07 <boxscape> (which does happen in commonly used libraries)
02:45:13 <maerwald> lortabac: you mean simplify their code
02:45:18 <lortabac> maerwald: yes
02:45:41 <mniip> can we get a faster typechecker for non-dependent types first :(
02:45:44 * hackage gtk2hs-buildtools 0.13.5.4 - Tools to build the Gtk2Hs suite of User Interface libraries.  https://hackage.haskell.org/package/gtk2hs-buildtools-0.13.5.4 (HamishMackenzie)
02:47:14 <lortabac> I confess I am a bit jealous when I see my C# colleagues build their projects in 10 seconds
02:47:25 <lortabac> and ours takes 10 minutes :)
02:47:51 <maerwald> oh right, tooling will probably become even worse :P
02:48:14 <jgt> I'd love to see a way to understand where GHC is spending its time during compilation
02:49:17 <boxscape> I guess you could profile it?
02:49:23 <jgt> boxscape: but how?
02:49:39 <MarcelineVQ> ghc is a ghc program :>
02:49:45 <boxscape> ^
02:50:09 <MarcelineVQ> if it doesn't expose enough guts you might have to build it with profiling tho, idk
02:50:11 <Rembane> I've read some blog posts on profiling GHC and making it faster 
02:50:30 <jgt> oh… so… build GHC with profiling enabled, then run that GHC with profiling to compile my project
02:51:08 <Rembane> Does GHC do incremental compilation?
02:51:36 <jgt> feels a bit like turning GHC into a Matryoshka
03:09:22 <mniip> lortabac, our CI used to hit 1.5 hours
03:09:53 <mniip> jgt, conventional wisdom says type computations are very very slow
03:10:20 <mniip> a type family computation you perceive as linear might actually be quartic
03:20:15 <kuribas> how to get all combinations of elements from sublists?
03:21:29 <kuribas> for example [[1, 2], [3]] => [[1, 3], [1], [2, 3], [2], [3]]
03:22:52 <evelyn> subsequences or permutations from data.list may be what you're looking for
03:23:26 <evelyn> (they are obviously different operations)
03:24:10 <evelyn> in that case, you'd fold all the elements into a single list then use subsequences or similar.
03:24:19 <evelyn> ...is this homework?
03:24:35 <kuribas> nope
03:25:06 <kuribas> I can do a simple recursive function in the list monad, but I wonder if there is something easier
03:25:20 <kuribas> ah, first permutations, then sequence
03:25:34 <Axman6> it's quite an odd operation, it's the combination of a few different operations
03:25:56 <evelyn> yeah, I fear the question is slightly unclear
03:25:58 <kuribas> powerset more likely
03:26:19 <Axman6> > filterM (const [False,True]) [1..5]
03:26:21 <kuribas> so sequence =<< powerset l
03:26:21 <lambdabot>  [[],[5],[4],[4,5],[3],[3,5],[3,4],[3,4,5],[2],[2,5],[2,4],[2,4,5],[2,3],[2,3...
03:36:39 <kuribas> > foldr (\e l -> (l <> ((e:) <$> l))) [[]] [1..5]
03:36:42 <lambdabot>  [[],[5],[4],[4,5],[3],[3,5],[3,4],[3,4,5],[2],[2,5],[2,4],[2,4,5],[2,3],[2,3...
03:37:23 <kuribas> > sequence =<< foldr (\e l -> (l <> ((e:) <$> l))) [[]] [[1..2], [3]]
03:37:26 <lambdabot>  [[],[3],[1],[2],[1,3],[2,3]]
03:37:41 <kuribas> bingo
03:39:09 <MarcelineVQ> why no [1,2]
03:39:28 <kuribas> MarcelineVQ: 1 and 2 are in the same sublist
03:40:03 <MarcelineVQ> but why does that exlcude them? [3] is also its own sublist
03:40:55 <kuribas> MarcelineVQ: it's looking at elements of the sublist, not sublists of sublists.
04:08:43 <Schrostfutz> Hi, I wrote a small program (http://sprunge.us/Oz7SoQ?haskell) for a problem on hackerrank. That is to print the fractions of numbers in a input that are greater, smaller, or equal to zero. Could you tell me what you think of it and where it might be improved?
04:11:55 <dminuoso> Schrostfutz: Id probably avoid the intermediate list and encode it via a foldr into a Map
04:12:29 <mniip> instead of adding signatures to fromRational I'd rather add signatures to greaterZero, ...
04:13:02 <mniip> `group . sort $ xs` or `group $ sort xs`, not *that*
04:13:27 <mniip> do you come from lisp? lots of redundant parens :P
04:13:29 <dminuoso> Also amusingly you could just write `group (sort xs)`
04:13:30 <kuribas> MarcelineVQ: basically I pick zero or one from each list
04:13:37 <lortabac> mniip: we achieved a 10-minute CI by caching all our dependencies, otherwise it would take hours
04:13:51 <mniip> lortabac, we cached all our dependencies as well
04:13:59 <kuribas> MarcelineVQ: the pick zero comes from the powerset, the pick one from sequence.
04:14:03 <dminuoso> lortabac: What kind of caching mechanism do you use?
04:14:45 <Schrostfutz> dminuoso, mniip: Thanks a lot, that helps
04:15:04 <AWizzArd> How are are the Maps such as Data.Map.Strict in "containers" are implemented? Are they using fingertrees under the hood? Red-Black trees?
04:15:35 <mniip> you can look at the source
04:15:37 <KingoftheHobos> iirc, weight-balanced trees
04:15:38 <dminuoso> Or the documentation.
04:15:43 <dminuoso> AWizzArd: It says right at the top in the haddock.
04:15:50 <mniip> the documentatoin points to a paper iirc
04:16:00 <dminuoso> Several infact.
04:16:12 <AWizzArd> dminuoso: I was looking here https://haskell-containers.readthedocs.io/en/latest/
04:16:19 <dminuoso> AWizzArd: https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html
04:16:44 <lortabac> dminuoso: erm... I don't remember exactly, it's someone else who did it, I think we have an archive of build artifacts somewhere
04:16:59 <lortabac> that we scp and extract before building
04:17:10 <mniip> AWizzArd, customarily all documentation in haskell is on hackage
04:17:27 <dminuoso> lortabac: Interesting. What's wrong with the builtin store-based caching with `cabal v2-build`?
04:17:52 <dminuoso> Or are you talking about shipping those stores around?
04:17:58 <mniip> dminuoso, you ever use a public cloud CI?
04:18:05 <lortabac> the CI does not always run on the same machine
04:18:17 <mniip> you have to jump through hoops to keep previous build output available
04:18:55 <dminuoso> mniip: Ahh okay. Not really, we switched to local CI on gitlab runners.
04:18:57 <Reisen> I have a C library that takes 3 callbacks, I'm registering Haskell functions to do it, but I'm not sure how to share the state between them. Is there a nicer abstraction than IORefs?
04:19:20 <mniip> Reisen, does your library allow you to sneak a void* in?
04:19:36 <Reisen> mniip, yeah
04:19:49 <Schrostfutz> mniip: No, no particular Lisp background, I just have trouble parsing Haskell error messages and am confused by using (), . and $.
04:20:02 <mniip> Reisen, StablePtr
04:20:04 <dminuoso> lortabac: I see. So I was rather thinking of many runners with a ceph to share the store.
04:20:14 <dminuoso> But that's not really applicable with remote cloud CI.
04:21:23 <Reisen> mniip, so how does this work, I have the foreign code pass me the state back?
04:21:48 <mniip> you create a StablePtr wrapping whatever haskell value you want
04:21:50 <Reisen> And StablePtr guarantees the underlying haskell state isn't GC'd away
04:21:56 <mniip> on FFI bound it turns into a bare pointer
04:22:35 <mniip> then when control returns back into haskell, you get the pointer back, and FFI turns it into a StablePtr, which you can read
04:22:49 <Reisen> I see, I'm not sure that's the problem I want to solve though. I'm wondering how to do the mutation in haskell land, with that I'd still need an IORef or something to make the state changes in one callback visible to another
04:23:11 <mniip> ah sure, yes, you will need those
04:23:46 <Reisen> I was wondering if there was a nicer abstraction, it would've been nice if I could somehow make all the callbacks `State ()`
04:23:54 <mniip> sure
04:24:04 <mniip> just roll your own abstractions
04:24:43 <Reisen> Fair point, I guess I can wrap the IORefs/callbacks and do the mutation outside of the `State ()` part
04:24:49 <Adi13> Hi
04:24:57 <Reisen> Thanks for the StablePtr mniip, think you saved me some pain I'd have run into otherwise with that one
04:25:06 <Adi13> Im not sure if this is the right place to ask for some help with a Haskell lab Im dearly struggling with..
04:25:18 <mniip> :t \v s -> Control.Concurrent.MVar.modifyMVar v (runStateT s)
04:25:19 <lambdabot> GHC.MVar.MVar b -> StateT b IO b -> IO b
04:25:23 <mniip> voila done
04:25:37 <Reisen> Beautiful
04:25:44 <mniip> this has unfortunate exception interaction though so be careful
04:26:06 <Reisen> Ah, can you expand? Curious
04:26:22 <mniip> if you `modify` and then throw your modification will not be recorded
04:26:45 <mniip> you want to roll your own MonadState
04:26:46 <Reisen> Oh, that's actually beneficial here I want transactional like mutations
04:26:53 <mniip> ah ok
04:26:54 <Reisen> All or nothing is perfect
04:27:47 <mniip> in most places I would've preferred early writebacks
04:28:11 <Adi13> I have a data type I would like to import from another file which looks like this data Node a = Node a [a]  deriving (Show, Eq)
04:28:14 <Reisen> Yeah, in this case though the library is quite literally calling a function named "commit" :)
04:28:23 <Reisen> So It's ideal
04:28:36 <Adi13> with functions empty,addVertex,addEdge,vertices,neighbors which do what you would guess they do
04:29:03 <Adi13> in the file I would like to import the data type but not the constructor
04:29:22 <Adi13> does the following mean I have imported the constructor? import Graph(Graph, empty,addVertex,addEdge,vertices,neighbors)
04:29:26 <mniip> no
04:29:30 <mniip> you only imported the type
04:29:57 <Adi13> Alright. How would the import look if I wanted the constructor as well?
04:30:51 <mniip> Graph(Graph)
04:31:05 <mniip> import Graph ( Graph(Graph), ... )
04:31:13 <Adi13> aha I see
04:31:30 <Adi13> I guess I should be careful with the nomenclature to not confuse myself horribly
04:31:50 <boxscape> (or import Graph ( Graph(..) ), which imports all constructors of that type
04:31:51 <boxscape> )
04:32:44 * hackage hsinspect 0.0.4 - Inspect Haskell source files.  https://hackage.haskell.org/package/hsinspect-0.0.4 (tseenshe)
04:35:30 <mjrosenb> for lenses, does ix require the element being indexed to be a monoid?
04:36:48 <Adi13> Does anyone have experience using the following: https://en.wikipedia.org/wiki/DOT_%28graph_description_language%29?
04:37:41 <Rembane> Adi13: Yes! 
04:38:11 <mjrosenb> Adi13: yes.
04:38:51 <mjrosenb> presumably the person who wrote that article has experience with it.
04:41:24 <KingoftheHobos> You know he was asking if any one of us has experience with it.
04:41:48 <KingoftheHobos> Snide replies doesn't help anyone.
04:43:01 <evelyn> neither do offtopic questions >;)
04:43:46 <Adi13> I have moved to #haskell-offtopic. Apologies, didnt realize that it was an OT discussion
04:44:07 <evelyn> I was only joking!
04:44:11 <MarcelineVQ> it's not off topic if it invovles haskell but the response was due to asking a pre-question instead of your actual question :>
04:45:36 <mjrosenb> I also answered because I am in face familiar with dot, then followed up with a joke, since there hadn't been any response.
04:45:42 <MarcelineVQ> "don't ask to ask, just ask" is something of a mantra here, in this context it means ask about your haskell problem with DOT rather than asking if people are aware of DOT. or something
04:46:56 <Adi13> Well I shall do that then. So this is what the instructions are: Given a graph whose vertices are strings dot(:: Graph String -> String) shall compute a string representation of the graph in the DOT language
04:46:57 <Adi13> I have so many questions just about that sentence. I have a Graph datatype with some functions (init, addVertex, addNeighbour, returnVertices, returnNeighbour) but what does Graph String mean? What does "whose vertices are strings" mean?
04:47:33 <Adi13> I mean String is already a type, how would we apply a Graph datatype on top of it?
04:48:21 <mniip> presumably Graph is a generic datatype, parameterized by the type of its vertices
04:48:44 <mjrosenb> I would assume that it means that the vertexes in your graph can be any type in general, but for this problem, you're assuming that they are only Strings.
04:49:00 <mniip> yeah
04:49:03 <Adi13> aha
04:49:11 <Adi13> Yeah my datatype looks like data Node a = Node a [a]  deriving (Show, Eq)
04:49:15 <Adi13> so I guess the a here is a string
04:49:37 <mniip> it *can* be a string
04:49:51 <mniip> anyway what does your graph datatype look like?
04:50:01 <Adi13> Like that: data Node a = Node a [a]  deriving (Show, Eq)
04:50:06 <mniip> ah huh
04:50:18 <Adi13> so each Node contains its label and list of neighbours
04:50:29 <Adi13> and the Graph is a list of such Nodes
04:50:30 <mniip> but you can only encode a connected graph this way
04:50:35 <mniip> ah
04:50:52 <Adi13> the representation is only for simple graphs
04:50:56 <Adi13> if that is important
04:52:14 <Adi13> Im not even really sure what to expect as an input to the dot function
04:52:33 <Adi13> is it just strings like Graph "v1 v2 v3" = ....?
04:52:39 <Rembane> Adi13: Create a graph manually using DOT in your text editor and it will be easier to get your and around. 
04:52:44 <Rembane> s/and/head/
04:53:00 <mniip> do takes a Graph String
04:53:05 <mniip> what's confusing about that
04:53:36 <Adi13> but how do I know if v1 and v2 have an edge between for example
04:53:47 <mniip> ?
04:54:08 <mniip> do you have a Graph datatype?
04:54:12 <Adi13> Yeah
04:54:13 <mjrosenb> in DOT? or in your representation?
04:54:42 <mniip> Adi13, what does it look like?
04:54:45 <MarcelineVQ> it's not Graph "a string" it's a Graph of String
04:55:01 <Adi13> mjrosenb, I can figure out how it looks in both represenntation. Im not sure how it looks in the input to dot
04:55:21 <MarcelineVQ> Graph a is a list of Node a right? So Graph String is a list of Node String, i.e a list of Node String [String] values
04:55:27 <Adi13> mniip yes I do. data Node a = Node a [a]  deriving (Show, Eq)
04:55:34 <mniip> that's not what I asked
04:55:39 <mniip> that's not a datatype called Graph
04:55:43 <mniip> nor does it encode a graph
04:56:13 <Adi13> Im terribly confused it seems..
04:56:19 <Adi13> Not sure what you were asking otherwise. 
04:57:01 <mniip> is this some sort of exercise sheet?
04:57:14 <Adi13> Its a lab assigment
04:58:06 <mniip> can you show us the entire thing?
04:58:36 <MarcelineVQ> via an image or gist or pastebin link
04:58:50 <Adi13> Can I paste an image here?
04:58:58 <Adi13> or link imgur or something?
04:59:02 <MarcelineVQ> a link to one, irc is text-only
04:59:21 <Adi13> https://imgur.com/a/bLIC5CV
04:59:22 <MarcelineVQ> Well, generally
05:00:31 <Rembane> Adi13: This might be the right time to contact a TA and ask them all the questions concurrently. 
05:01:01 <Adi13> perhaps..
05:01:21 <Rembane> They have much more context than we do. 
05:01:28 <Rembane> Unless someone here is one of your TA's of course.
05:01:40 <mniip> Adi13, I'm mostly wondering about what exercise 1 is
05:02:16 <MarcelineVQ> yes, supposedly there should be a Graph module you could share (possibly named Graph.hs)
05:02:22 <mniip> so far it sounds like exercise 1 asked you to define a datatype that looks like `data Graph a = ...`
05:02:28 <sm[m]> morning all
05:02:32 <mniip> and in that context the exercise makes perfect sense
05:02:36 <sm[m]> https://www.reddit.com/r/haskell/comments/dh2a8b/no_garden_of_eden_adventures_in_teaching_haskell/ is very good, I vote this for the "haskell supporter's must-watch list"
05:02:38 <mniip> and what you're sayign makes no sense
05:02:48 <mniip> so I'm guessing you don't have a datatype like that
05:02:54 <Adi13> It was to create a datatype and the following functions: create an empty graph, add vertices to the graph, add edges from vertice 1 to 2,return all vertices, return all neighbours
05:03:00 <Adi13> no I have a Graph.hs!
05:03:02 <Adi13> with everything done
05:03:11 <mniip> Graph.hs sure but does it have `data Graph a = ...`
05:03:49 <Adi13> https://pastebin.com/bWjBmgDG
05:03:54 <Adi13> Yes it does 
05:04:15 <mniip> right
05:04:23 <MarcelineVQ> sm[m]: neat I'll have to check that when my connection improves, interested in people's opinions on error reporting especially
05:04:49 <mniip> do you know what `Graph String -> String` means then?
05:05:31 <Adi13> I think so... the polymorphic type a in the constructor will bind to String 
05:05:56 <mniip> exactly
05:06:08 <Adi13> so the input will be something like dot (Graph "v1 v2 v3") = ..
05:06:11 <mniip> no
05:06:43 <Adi13> oh..
05:06:45 <mniip> I think you're being confused by type/data constructor punning
05:07:51 <mniip> the type `Graph a` has one constructor `Graph` whose only field is of type `[Node a]`
05:08:27 <mniip> when you pattern match on Graph (the data constructor) you will get a list of `[Node String]`, not a string
05:08:50 <Adi13> so the labels/keys of the nodes will be of type String
05:09:33 <Adi13> like [Node "v1" [adjacency list v1], Node "v2" [adjacency listv2] .... ]
05:11:12 <mniip> yes
05:12:57 <Adi13> Alright
05:13:29 <Adi13> and I am supposed to convert my datatype Graph to DOT language
05:15:52 <mniip> yes
05:16:02 <Adi13> Thank you for perseverence! At least now I have something to work on :)
05:16:41 <Adi13> Haskell is the first thing that has made me feel this bone-headed and thick. 
05:17:04 <mniip> get used to it
05:17:09 <mniip> it's a good feeling
05:17:12 <mniip> that means you're learning
05:21:48 <jumper149> What are popular modules for parsing a bytestring where information is stored by index. I haven't used a parser yet, just need some info where to read up on it.
05:23:37 <dminuoso> jumper149: Depends a bit on the exact details of the encoding
05:24:40 <jumper149> the bytestring is encoded in ASCII, if that is what you mean? 
05:26:14 <jumper149> my current solution is a hardcoded read function that uses the start and length of a field and puts the information into a record.
05:26:40 <jumper149> I would like to simplify this. At least by only giving the order of the fields and lengths
05:27:04 <dminuoso> jumper149: Are you just accessing single bytes?
05:27:11 <jumper149> dminuoso: yes
05:27:29 <dminuoso> jumper149: Well you just said "length of a field", so its more than just single bytes.
05:27:45 <jumper149> well multiple single bytes^^ 
05:27:52 <dminuoso> jumper149: I would probably parse it into some `Vector Field`, and then just index into that vector?
05:27:56 <dminuoso> But without knowing more its hard to say.
05:28:18 <jumper149> Is there anything I can look into on Hackage?
05:28:23 <dminuoso> Or maybe its a Map, or perhaps something else.. really hard to say without knowing the details of your protocol.
05:30:13 <c_wraith> there was a post on r/haskell in the last couple weeks about someone extending (I think) attoparsec to allow skipping around by particular byte counts
05:35:56 <c_wraith> ...  Or maybe I'm crazy.  I can't seem to find it now
06:11:25 <Schrostfutz> Whats the nicest way to get the real 'head' of a list, i.e., all but its last element?
06:12:36 <boxscape> > init [1..5]
06:12:38 <lambdabot>  [1,2,3,4]
06:12:50 <boxscape> in what sense is that the "real" head though?
06:14:23 <dminuoso> boxscape: init is a terrible example.
06:14:26 <dminuoso> % :t init
06:14:26 <yahb> dminuoso: [a] -> [a]
06:14:46 <boxscape> terrible example of what?
06:15:00 <dminuoso> boxscape: init, just like head, is unsafe to use.
06:15:17 <boxscape> hm, okay, fair enough
06:15:34 <Schrostfutz> Thanks. In how I understand the semantics of head and tail in natural language: we have tail and last to return all but the first and the last element respectively, so head and first should return all but the last and the first element.
06:16:01 <Schrostfutz> Unsafe in that it fails on empty lists?
06:16:06 <dminuoso> Schrostfutz: Right.
06:17:02 <boxscape> Schrostfutz the "head" of a list is only its first element
06:17:12 <dminuoso> Schrostfutz: We call it head because conceptually a list is some element prepended to a list (a singly linked list, essentially)
06:17:21 <dminuoso> Schrostfutz: So its the "head" of that singly linked list.
06:18:42 <Schrostfutz> boxscape, dminuoso: Yes, I understand that, and I agree that it makes sense. However from a 'usability' perspective it is counterintuitive that functions denoted by antonyms do not have the inverse behavior.
06:19:14 * hackage birch-beer 0.2.2.0 - Plot a colorful tree.  https://hackage.haskell.org/package/birch-beer-0.2.2.0 (GregorySchwartz)
06:19:19 <MarcelineVQ> idk, tail could as easily be called toes
06:20:09 <oats> anybody know of a library that's good for just simple http servers?
06:20:11 <dminuoso> Schrostfutz: The head of the snake, and its tail.
06:20:20 <dminuoso> Schrostfutz: I find that to be quite intuitive. :-)
06:20:21 <MarcelineVQ> there's another disconnect in that head, the cli command, acts like take
06:20:26 <oats> not like full-blown web frameworks or html DSLs
06:20:48 <boxscape> Schrostfutz it wouldn't really be inverse behavior since the construction of a list isn't symmetrical, which means that for example taking all but the first element takes constant time, but the time it takes to take all but the last element is linear in how many elements th list has
06:20:55 <Schrostfutz> dminuoso: True, but that doesn't make sense for other animals: the head and the tail of the horse
06:21:31 <MarcelineVQ> right, horse is nose to tail
06:21:54 <dminuoso> Schrostfutz: Haskell lists are closer to snakes than horses though.
06:22:29 <boxscape> Schrostfutz you can also think of a list as a pair (head, tail), in which case head and tail *do* have inverse behavior the way they are currently implemented
06:23:11 <Schrostfutz> boxscape, dminuoso: True, that's what I meant when I said I understand why it is the way it is. The abstraction the user is presented with, at afirst glance at least, is however just a symmetric list
06:23:35 <boxscape> that's true
06:23:41 <dminuoso> Schrostfutz: Im not convinced of that.
06:23:52 <dminuoso> Schrostfutz: What is a symmetric list, and what gave you the impression?
06:23:57 <boxscape> dminuoso the [a,b,c] syntax is symmetrical
06:24:04 * nshepperd2 . o O (haskell lists are snakes, unix files are horses)
06:25:30 <Schrostfutz> boxscape, dminuoso: That's what I mean. The commonly used syntax conveys symmetry. If you write it as 1:[2,3] one sees that it isn't
06:25:59 <mjrosenb> blerg, I am refactoring some code, and can't figure out how the old code worked.  it looks like I'm using [foo::Tower] ^. ix 0, but Tower isn't a monoid
06:26:57 <dminuoso> mjrosenb: "it looks like Im using" ?
06:27:51 <Schrostfutz> boxscape, dminuoso, MarcelineVQ: But I'm not trying to be a smartass here, just trying to explain my intuition.
06:28:12 <dminuoso> Schrostfutz: Oh I understand, no need to defend yourself.
06:28:31 <mjrosenb> as in there is an expression in my code (levelState ^? towerState . to TV.forSale . ix n)
06:28:51 <mjrosenb> and levelState ^. towerState . to TV.forSale :: [Tower]
06:29:06 <dminuoso> mjrosenb: ^? is just preview
06:29:20 <mjrosenb> and the compiler is complaining that Tower isn't an instance of Monoid (which it is not)
06:29:58 <dminuoso> mjrosenb: As it should. A Traversable/Fold targets *multiple* values, so trying to view through it needs to know how to condense them into one valu.
06:30:27 <dminuoso> (Whereas preview could be thought of as view through Fold/Traversable, picking the First monoid to make that decision)
06:31:21 <mjrosenb> right.  the thing is, this used to work, and I'm not too sure how.
06:32:12 <dminuoso> mjrosenb: What changed?
06:33:40 <nshepperd2> mjrosenb: did you possibly mistype ^.. as ^. in refactoring?
06:34:18 <mjrosenb> this is the line that used to work:
06:34:20 <mjrosenb> tower = trace ("clikced on ..." ++ show n) (model ^?! levelState . _Just . towerState . to TV.forSale . ix n)
06:35:13 <mjrosenb> and because of reasons, that is a very overcomplicated expression, since the definition of forSale is:
06:35:16 <mjrosenb> forSale _ =  [T.gunTower, T.aaTower]
06:36:26 <nshepperd2> ^?! is unsafe preview
06:36:47 <nshepperd2> unlike ^., it doesn't need a Monoid constraint, and throws an exception if there aren't any values to get
06:38:20 <mjrosenb> oh, well.
06:38:23 <mjrosenb> that makes sense.
06:39:18 <mjrosenb> althought the difference between ^? and ^?! seems rather extreme.
06:41:12 <Taneb> They do the same thing, just one of them returns a Maybe and the other errors on failure
06:49:11 <mjrosenb> but Maybe x doesn't require x to be a monoid.
06:49:44 * hackage too-many-cells 0.2.2.0 - Cluster single cells and analyze cell clade relationships.  https://hackage.haskell.org/package/too-many-cells-0.2.2.0 (GregorySchwartz)
07:03:48 <boxscape> unboxed types aren't part of the haskell report, right?
07:04:05 <Adi13> Adi13 15:59:20
07:04:07 <Adi13> scope?
07:05:37 <MarcelineVQ> Hard to say what your error in thought is without knowing what g is, but you can't use functions on the left of =
07:06:05 <Adi13> g is supposed to be a Graph
07:06:10 <MarcelineVQ> the left of = is for matching against data constructors like True or () or (Just x)
07:06:14 <Adi13> a datatype I created/imported from my own module
07:07:16 <boxscape> Adi13 can you paste the whole line you're entering in ghci and say what you expect it to do?
07:07:19 <MarcelineVQ> when you write "dot (g listOfNodes) = .." what does (g listOfNodes) do in your own words?
07:08:03 <Adi13> That is acutally the whole line. I would think that g would bind to Graph and listOfNodes to String
07:09:29 <boxscape> Ah, you cannot bind variables to constructors like this.
07:09:40 <boxscape> you must use the explicit constructor
07:09:47 <boxscape> dot (Graph listOfNodes)
07:11:11 <boxscape> if this worked, and you had a type like "data Graph = GraphA String | GraphB Int", it wouldn't know what the type of listOfNodes is supposed to be
07:11:27 <Adi13> the thing is Im not allowd to use the constructor
07:11:35 <Adi13> only allowed to import the datatype from my module
07:11:46 <Adi13> Like this: import Graph(Graph, empty,addVertex,addEdge,vertices,neighbors)
07:11:56 <boxscape> that import list is given?
07:11:58 * ski doesn't see Adi13 mentioned that line with `dot' and `listOfNodes' anywhere in backlog
07:12:03 <Adi13> yeah basically...
07:12:08 <MarcelineVQ> ski: he pasted to offtopic by accident
07:12:13 <ski> oh
07:12:20 <Adi13> yeah I can paste it again here sorry
07:12:27 <Adi13> appendVertices:: [a] -> String -> String
07:13:16 <Adi13> Basically I have a Graph which looks like this: data Node a = Node a [a]  deriving (Show, Eq)
07:13:18 <MarcelineVQ> what's the typeof vertices?
07:13:19 <ski> (just pasting a timestamp isn't very useful, either, since there's lots of people here in many different timezones)
07:13:37 * ski was just about to ask re `vertices', as well
07:13:50 <Adi13> [a]
07:14:02 * ski doubts that
07:14:09 <MarcelineVQ> No that's the type of Node again, Graph is data Graph a = Graph [Node a] deriving (Show, Eq)
07:14:15 * ski blames the record system
07:14:16 <MarcelineVQ> https://pastebin.com/bWjBmgDG
07:14:40 <Adi13> Thank you MarcelineVQ
07:14:41 <ski> that lists
07:14:41 <MarcelineVQ> I see something interesting in thie paste btw, assuming it's verbatim "module Graph(Graph,empty,addVertex,addEdge,vertices,neighbors) where -- modify as needed"
07:14:43 <ski>   vertices :: Eq a => Graph a -> [a]
07:15:10 <Adi13> the modify  as need was there in between module and where
07:15:19 <Adi13> I just never changed the comments 
07:15:21 <ski> (so the type of `vertices' is then `Eq a => Graph a -> [a]', not `[a]')
07:15:35 <MarcelineVQ> Isn't that saying you can modify the export list?
07:15:38 <Adi13> That is true.. Im sorry
07:16:06 <Adi13> No got explicit instructions that we are only allowed to export the data type + functions and not the constructor
07:16:20 <ski> it's okay, Adi13. just making it clear what MarcelineVQ was asking about, what you were supposed to look for, for another time
07:17:06 <boxscape> Adi13 you can write a function with type `Graph a -> [Node a]` in that module, using the constructor, and then export that function 
07:17:51 <boxscape> then, instead of pattern matching on `Graph`, you can use this function to extract the content
07:18:22 <Adi13> I dont think Im allowed to do that. Explicit instructions were  to only export the 5 functions in the pastebin and the data type
07:19:23 <dminuoso> boxscape: What do you mean by "are not part of the report"?
07:19:28 <Adi13> so only tools I have at my disposal are the 5 functions (empty, addVertex, addEdge, neighbours, vertices)
07:20:06 <boxscape> dminuoso I guess I mean that `cat Haskell2010.txt | grep -e 'unboxed'` is empty
07:20:58 <boxscape> Adi13 vertices and neighbors together give you the same functionality as the function I described
07:21:30 <Adi13> Yeah but I dont understand how to write the left hand side of the dot function without using the constructor
07:21:47 <Adi13> I thought that dot g listOfNodes would bind like I described earlier but that isnt valid
07:22:20 <MarcelineVQ> dot only takes one argument
07:22:25 <dminuoso> boxscape: Well okay put it this way, the Haskell report does not know of "unboxed types".
07:22:29 <boxscape> Adi13 write `dot g = ..` and then on the right hand side use vertices and neighbors with g to extract the contents
07:22:32 <boxscape> dminuoso okay
07:22:36 <Adi13> aha
07:22:41 <Adi13> oh wow I am dumb
07:22:44 <MarcelineVQ> https://imgur.com/a/bLIC5CV dot takes a single arugment of type Graph String
07:23:54 <Adi13> alright so thats how I extract the data
07:25:18 <Adi13> but I still cannot get intersperse to work for me
07:25:46 <Adi13> basically Id like to first get all the vertices from the graph and append it to an empty string with ';' inbetween. Then take every vertice and find its neighbours. iterate over that and for every neighbour append vertice - neighbour to the string
07:26:03 <Adi13> but this is proving much harder to do then I thought..
07:26:17 <boxscape> (btw the singular of vertices is vertex :P _
07:26:20 <boxscape> )
07:27:39 <dminuoso> boxscape: I suppose you are talking of unboxed types in the sense of the (deprecated) kind #?
07:27:39 <dminuoso> boxscape: Or in the sense of `class ... => Unbox a`?
07:27:44 <Adi13> I have used vertices, vertex and node all jumbled up in my code way too much haha
07:27:55 <boxscape> dminuoso first one
07:30:59 <Adi13> So I was missing an import Data.List but Im not correctly matching types for the return of vertices g
07:31:52 <Adi13> I would expect that lstVertices = vertices g would return [a] and appendVertices:: [a] -> String would match correctly 
07:32:36 <boxscape> what's the definition of appendVertices?
07:33:20 <Adi13> appendVertices:: [a] -> String
07:34:13 <boxscape> that's the type, I mean the actual code that defined its behaviour
07:34:33 <Adi13> its a oneline function...
07:34:41 <Adi13> unless Im misunderstandign your question
07:34:54 <boxscape> Adi13 can you paste that one line in here?
07:35:17 <Adi13> appendVertices v = intersperse ';' v
07:35:32 <boxscape> :t intersperse ';' v
07:35:33 <lambdabot> error:
07:35:34 <lambdabot>     • Couldn't match expected type ‘[Char]’ with actual type ‘Expr’
07:35:34 <lambdabot>     • In the second argument of ‘intersperse’, namely ‘v’
07:35:41 <boxscape> :t \v -> intersperse ';' v
07:35:42 <lambdabot> [Char] -> [Char]
07:35:52 <boxscape> The type of that is not [a] -> String
07:35:56 <boxscape> it's String -> String
07:37:03 <Adi13> so I need to have [String] -> String?
07:37:21 <Adi13> because my own vertices functions returns [a] which will become [String] here?
07:37:25 <c_wraith> What's the purpose of the function?
07:37:28 <boxscape> yes, but I think you'll probably want intercalate rather than intersperse
07:37:46 <boxscape> > intersperse ';' "abcd"
07:37:47 <lambdabot>  "a;b;c;d"
07:38:02 <boxscape> > intercalate ";" ["foo", "bar"]
07:38:04 <lambdabot>  "foo;bar"
07:38:14 <boxscape> (note that it uses ";" instead of ';')
07:38:22 <Adi13> aha
07:38:53 <Adi13> @c_wraith I need to first get all the vertices from the graph and append it to an empty string. Then take every vertice and find its neighbours. iterate over that and for every neighbour append vertice - neighbour to the string
07:38:53 <lambdabot> Unknown command, try @list
07:39:06 <c_wraith> that's a weird thing to do
07:39:24 <Adi13> https://en.wikipedia.org/wiki/DOT_(graph_description_language)
07:40:18 <c_wraith> like, why is "append" in the name?
07:40:31 <Adi13> because I need to append them to a string..
07:40:37 <Adi13> i just cant get any part of it to work at all
07:40:42 <c_wraith> but you're not passing in a string to append it to
07:40:57 <Adi13> appendVertices:: [String] -> String -> String
07:41:10 <Adi13> This was not working so I thought Id start easy
07:43:20 <Adi13> Finally got the vertices to work. apprently needed ";" instead of single quotes
07:48:53 <Adi13> do let .. in .. statements have a scope for only that let .. in ... block?
07:49:28 <Adi13> For example I would like to first append somethings to a string and then later append further things to the string and return it. Will the variable be scoped only for the first part?
07:50:02 <geekosaur> the scope of bindings followingt he let is the other bindings plus the expression following in
07:50:35 <Adi13> so it is only scoped for one block and not the other?
07:52:05 <geekosaur> I'm not sure what you're asking since we appear to have different undertandings of what's going on (let … in is an expression, not a "block")
07:53:04 <Adi13> appendVertices:: [String] -> String -> String
07:53:07 <Adi13> appendVertices listVertices dotString
07:53:11 <Adi13> Basically I would like to do that
07:53:20 <Adi13> but I guess Im not allowed to do it like this?
07:54:30 <boxscape> that looks like valid haskell but it's hard to understand how it relates to your question since it doesn't contain any let bindings
07:54:59 <Adi13> do you not see the logic for the dot function?
07:55:06 <Adi13> I have 3 let statements there
07:55:14 <Adi13> I guess I cannot paste a big block of code like that
07:55:28 <boxscape> you can paste it on pastebin and post a link
07:55:31 <Adi13> OK
07:55:49 <Adi13> https://pastebin.com/v6SCF6ps
07:55:59 <dminuoso> Adi13: There's two different kinds of let. There's the let in do expressions, and there's standard let in regular expressions.
07:56:24 <Adi13> oh I see
07:56:36 <Adi13> this is the one in regular exp. then I suppose
07:56:37 <dminuoso> Adi13: (The former desugars into usage of the latter)
07:57:18 <boxscape> Adi13 return is not what you think it is
07:57:37 <boxscape> Adi13 in fact you should probably not use return at all at the moment
07:57:51 <geekosaur> right, also you're using do syntax outside of do
07:58:02 <geekosaur> and do doesn't do what you think, either
07:58:18 <boxscape> geekosaur
07:58:20 <boxscape>  oops
07:58:28 <boxscape> geekosaur do doesn't seem to be in there?
07:58:37 <geekosaur> exactly
07:58:42 <boxscape> hm, fair
07:58:47 <Adi13> So how do I do this?
07:58:50 <Adi13> haha
07:58:50 <geekosaur> but you have: let listVertices = vertices g
07:58:54 <geekosaur> with no "in"
07:58:58 <geekosaur> which is only valid inside "do"
07:59:10 <Adi13> can I not have several let statements before an in?
07:59:17 <geekosaur> you do not have statements
07:59:26 <Adi13> expressions?
07:59:31 <geekosaur> unless you are using "do", and that only works when you're working in a monad
07:59:38 <boxscape> Adi13 it looks like you should put all of these bindings in a single let expression, i.e. something like let a = 1; b = 2; c = 3 in a + b + c  (you can replace the semicolons with newlines)
07:59:40 <geekosaur> you have one expression
07:59:42 <Adi13> alright..
08:00:18 <rotaerk> why is a vertex a String, anyway?
08:00:35 <boxscape> rotaerk they're labels, apparenlty
08:00:42 <rotaerk> ah
08:00:43 <Adi13> because vertices :: Eq a => Graph a -> [a]
08:00:59 <Adi13> and dot:: Graph String -> String
08:02:05 <Adi13> I dont really know how to write this in "valid" haskell
08:02:28 <Adi13> Im not sure what Im doing at all tbh
08:03:41 <dminuoso> Adi13: Then yes, let introduces bindings only inside the expression of the `in` clause.
08:03:50 <boxscape> Adi13 first of all, remember that the right hand side of a function definition always consists of a single expression, i.e. something like 1 + 2, or [1,2,3], or any other value. There are no statements in haskell.
08:04:32 <Adi13> basically I would like to first append all the vertices with a ";" inbetween and then find all the neighbours for each vertice and append vertice -- neighbour for each vertice to the same string as earlier
08:05:17 <boxscape> Adi13 a "let expression" (notably not a statement) makes writing some expressions easier - for example instead of "(x + y) * (x + y)" you can write "let z = x + y in z * z". But the result, the whole let ... in .. thing, is still just one expression
08:05:47 <Adi13> From what you guys are saying I cannot do this inside one function
08:05:55 <Adi13> So now Im really lost as to how to accomplish this
08:06:27 <geekosaur> I tried to figure out what you were trying to write int hat paste, and it's pretty confused as to how things work
08:06:42 <Schrostfutz> Hi, my code (http://sprunge.us/TJkZDh?haskell) fails to deduce Ord a arising by the use of minimum for the context of Num a. Why is that? Aren't all Nums also Ords?
08:07:12 <dminuoso> Adi13: Haskell is really different from many traditional languages in that you don't have a principle imperative setting in which you can sequence "what to do in which order" and "what to return"
08:07:21 <geekosaur> my best attempt at figuring out what you intended is https://gist.github.com/geekosaur/7418481cfcb096474d5b98bb2ff46d76
08:07:24 <boxscape> Adi13 to add to that, let expressions can contain more than one binding, for example `let x = 4, y = 5 + 6 in x * y` (where the semicolons can be newlines)
08:07:34 <ski> s/,/;/
08:07:43 <geekosaur> you seem to be trying to pass the result as a parameter and expeccting it to be changed by the function, which is wrong
08:08:02 <geekosaur> nothing can be "changed" in that way,bindings are immutable
08:08:06 <boxscape> Adi13 uh oops, the comma in what I last wrote should be a semicolon
08:08:37 <boxscape> (thanks ski)
08:09:13 <dminuoso> Adi13: One important thing to understand, is that in Haskell a function is not a list of statements that are executed, its rather an equation where an appearance of the left hand side can be replaced with its right hand side.
08:09:25 <Adi13> alright
08:09:38 <Adi13> geekosaur I actually think that is what I was trying ot do
08:09:44 <dminuoso> (With variables replaced by bound variables, appropriately)
08:10:25 <Adi13> geekosaur but it wont compile due to some typ issue in the map function
08:10:38 <geekosaur> I didn't go so far as to check that
08:11:13 <Adi13> dminuoso, boxscape yeah its a completely different way of thinking
08:11:23 <dminuoso> *bound values
08:11:23 <Adi13> and Im really struggling to get my head around it
08:11:35 <geekosaur> hm. have to guess what you intended, but suspect the last line is: in map appendNeighbours (listVertices dotString)
08:12:16 <geekosaur> but I'm not sure. this is still fairly confused
08:12:20 <Adi13> Still complains that it expected String -> [String] but got [String] in the map
08:12:34 <boxscape> Schrostfutz Ord does not appear to be a superclass of Num
08:12:39 <geekosaur> oh wait
08:12:52 <geekosaur> you did that again, trying to modify dotString by passing it as a parameter
08:13:29 <Schrostfutz> boxscape: But isn't the constraint to Num stronger? i.e., all as for this function will be numbers and all numbers are Ords?
08:13:31 <geekosaur> just remove dotString from the last line, because that doesn't work
08:13:47 <geekosaur> Schrostfutz, complex numbers are numbers but you can't define Ord for them
08:14:00 <Adi13> so basically I need to create a string whihc first lists all the vertices in a graph. and then for each vertex finds the neighbors and appends "vertex -- neighbour" for each neighbour
08:14:00 <geekosaur> likewise quaternions and such
08:14:20 <Adi13> geekosaur but then appendNeighbours has no string to append to
08:14:23 <Schrostfutz> geekosaur: Oh, you're right. I was mistaken. How do I define two constraints for a type?
08:14:45 <geekosaur> something like: (Show a, Ord a) => ...
08:15:09 <Schrostfutz> geekosaur: Thanks
08:15:16 <Adi13> how do you append it to the same string?
08:15:25 <geekosaur> Adi13, you do not "append" as such. you return a result which is a new strting, you do not modify some "variable" in Haskell
08:15:32 <Adi13> OK true
08:15:45 <dminuoso> Is there a way to simulate local-but-instance-wide bindings? Or do I have to do non-exported top module bindings for that?
08:15:49 <geekosaur> https://gist.github.com/geekosaur/7418481cfcb096474d5b98bb2ff46d76
08:15:51 <Adi13> how do I return a new string with the new values added then?
08:16:18 <Schrostfutz> Nice. I really like Haskell's type system. The code runs correctly on my input without me ever mentioning a specific type.
08:16:24 <geekosaur> which should produce a new string with the appendages, similarly to the previous functions which take a string and produce a new one with the values appended
08:16:30 <dminuoso> Adi13: Remember what I said about what a function is?
08:16:49 <dminuoso> Adi13: `f x = x + 5` can be thought of to mean "whenever you see `f 1` you can replace it with `1 + 5`"
08:16:56 <Adi13> dminuoso yeah. 
08:17:30 <dminuoso> Adi13: It works just like that. So instead of doing addition you could do list concatenation.
08:18:29 <Adi13> geekosaur still cant get it to work: :/
08:18:41 <Adi13> so do I need ot create two functions
08:18:41 <geekosaur> probably not, as I said I'm having to guess
08:18:46 <geekosaur> no?
08:19:09 <geekosaur> I expect you're trying to do something like the earlier functions in that paste I started from, but I can't tell what
08:19:49 <geekosaur> actually no, dot doesn't look like it's suppposed to append to an existing string
08:20:09 <Adi13> just supposed to return a string, true...
08:20:11 <geekosaur> hm, appendNeighbors has nothingt o start from. because this should not be a map; it looks like it wants to be a fold
08:20:19 <geekosaur> do you know about folds yet?
08:20:52 <Adi13> yeah but folds is like reduce. here I want to concatenate "vertex -- neighbour" for every vertex and its given neighbours
08:21:11 <geekosaur> here you start from [], you fold appendNeighbors across the list of vertices, you get a list
08:21:25 <geekosaur> "reduce" is kinda badly named, because you aren't always "reducing"
08:21:28 <merijn> Algorithm discussion time! I need to (uniform randomly) select K elements out of stream of N (where N is known ahead of time). I know about reservoir sampling, but since K is big I would prefer to not have to build a reservoir of K elements in memory. I have some ideas for how do do it, but I'm not confident that I'm not accidentally introducing bias in the randomness
08:21:42 <geekosaur> which is why we call it fold instead of reduce
08:21:49 <Adi13> I see..
08:22:02 <Adi13> Could you show me how to do it because Im completley lost at this point
08:22:19 <geekosaur> "reduce" really only works for things like addition, where you're compacting something away. here you're changing form and appending, not compacting
08:23:34 <merijn> Basically, I was thinking to keep a running tally of K', the number of elements not yet picked, and then for each element select it with probability K'/N, so for the first it's K/N, if it's picked then the second has probabiliy (K-1)/N (or K/N if the first wasn't picked), etc.
08:23:59 <merijn> But I'm not sure if that's fair
08:24:00 <geekosaur> anyway, https://gist.github.com/geekosaur/7418481cfcb096474d5b98bb2ff46d76 is another attempt. still guessing at intent though
08:24:54 <geekosaur> merijn, this sounds like a permutation
08:25:03 <merijn> geekosaur: Yes
08:25:10 <Adi13> what part of my intent is unclear?
08:26:50 <merijn> geekosaur: But that doesn't really help me, because I can't find anything when googling permutations either :p
08:27:05 <geekosaur> you're asking the wrong question. I am missing most of the scaffolding for this code, in particular what a Graph is
08:27:14 <Adi13> One sec..
08:27:22 <Adi13> https://pastebin.com/bWjBmgDG
08:27:29 <Adi13> that is the module that Im importing that Iw rote
08:27:57 <Adi13> Each Node contains a label and its neighbours
08:28:04 <Adi13> and the graph is a list of such nodes
08:30:38 <geekosaur> and now I'm lost at what you intend with how you're using appendNeighbors, which may be the same confusion as earlier where you somehow want things to do updates in place
08:31:04 <geekosaur> basically I have no idea how you intended that to be used, so I can't apply it properly
08:31:58 <geekosaur> the code I wrote won't work, and I suspect from looking at this that appendNeighbors already does the work of the fold and you were trying to duplicate it out of confusion
08:40:14 * hackage hspec-expectations-pretty-diff 0.7.2.5 - Catchy combinators for HUnit  https://hackage.haskell.org/package/hspec-expectations-pretty-diff-0.7.2.5 (myfreeweb)
08:43:17 <dminuoso> geekosaur: Mmm, there's no decent way to have TH play nice with haddock, is there? :(
08:43:28 <dminuoso> geekosaur: I suppose your idea of "pseudo-TH" or perl/co scripts generating Haskell is starting to become lot more attractive now.
08:49:17 <dunce> Hello again.  I was hoping I could get pointed in the right direction for what I need to learn to do this problem
08:49:49 <dunce> I have a bit string i need to iterate through and match sequences to a, b, c
08:50:22 <dunce> ie 11 10 0 = c b a
08:50:29 <dunce> not really sure where to even start
08:50:50 <dunce> I can draw a state machine for this but translating it into haskell escapes me
08:52:20 <dminuoso> dunce: What exactly do you mean by "iterate through and match sequences to a, b, c"?
08:52:50 <dunce> i have a list ob bits
08:52:51 <lortabac> a = 0, b = 1, c = 10, d = 11...?
08:53:13 <dunce> 0 = a, 10 = b, 11 = c
08:53:16 <dunce> theres only 3
08:53:34 <lortabac> so you need to translate between numbers and chars?
08:53:44 <nil> what should 01 become?
08:53:57 <dunce> that would be a and a hanging bit
08:54:17 <dunce> I can assume that list is well formatted 
08:54:46 <dminuoso> Im not exactly sure what you are trying to do. Your description of what your code is supposed to do is unclear to me.
08:54:51 <evelyn> Can you give an example?
08:55:19 <nil> so, your thing takes a string like "11100" and produces the string "cba"?
08:55:31 <nil> or how are the bits stored exactly?
08:55:33 <dminuoso> dunce: `11 10 0 = c b a` is a rather vague description. You have a bitstring, what do you want to produce from thta?
08:55:52 <dunce> Nil is correct
08:56:17 <dminuoso> dunce: So there's only 3 possible bit patterns?
08:56:22 <dunce> my input would be [1,1,1,0,0]
08:56:26 <dunce> yes only 3
08:56:44 <dminuoso> dunce: What have you tried so far?
08:56:55 <dunce> I don't know where to start lol
08:57:09 <dminuoso> nil, lortabac: Not bad, how did you get that from that description?
08:57:19 <nil> mentalism
08:57:20 <lortabac> quick question, is there a function somewhere that merges two maps monoidally? Monoid a => Map k a -> Map k a -> Map k a
08:57:31 <nil> dunce: you want to start thinking recursively
08:57:31 <jle`> lortabac: M.unionWith (<>)
08:57:38 <lortabac> jle`: thanks
08:57:56 <dunce> well I know recursively yes. 
08:57:58 <dminuoso> dunce: Start by thinking of a function that just solves this problem receiving a pair of bits.
08:58:09 <dminuoso> That is, how do you map a single pair of bits to a character.
08:58:10 <dunce> ok ill do that
08:59:59 <jle`> dunce: well, if you already have your state machine drawn out, you could even do this explicitly using a state machine
09:00:03 <jle`> character-by-character
09:00:21 <nil> dunce: you can do this with basic recursion like   f [] = [] ; f (0:xs) = 'a':f xs ; f (1:0:xs) = 'b':f xs ; f (1:1:xs) = 'c':f xs
09:00:49 <jle`> you can give every node in your state machine a constructor in an ADT and use mapAccumR or something, or foldl' with output and current state
09:00:49 <nil> this is a very common pattern and is how you'd implement things like map, fold, ...
09:00:53 <dunce> oh I didnt think about (1:1:xs)
09:00:58 <dunce> that makes it super easy lol
09:01:08 <nil> yes, you can have nested patterns
09:01:22 <dunce> I've only done it once like x:xs
09:01:27 <dunce> ok ill work on this for a bit
09:01:29 <dunce> thank you
09:01:31 <jle`> data StateNode = Fresh | GotOne
09:02:13 <nil> note that the patterns above aren't complete, so the function would raise an error on things like [1] or [42]
09:03:47 <jle`> you could also do this using parser combinators on a stream of ints
09:03:51 <jle`> the possiblities are endless :D
09:04:58 <jle`> in parser combinator style this would just be parseTheStuff = many $ ('a' <$ token 0) <|> ('b' <$ string [1,0]) <|> ('c' <$ string [1,1])
09:05:50 <nil> cute
09:05:52 <jle`> alternatively you can use a binary tree as your state nodes in your state machine
09:06:05 <jle`> your binary tree then acts like a Trie Bool
09:07:06 <jle`> myFunc (Branch a b) (0:xs) = myFunc a xs
09:07:13 <jle`> myFunc (Branch a b) (1:xs) = myFunc b xs
09:08:01 <jle`> then give it myFunc (Branch (Leaf 'a') (Branch (Leaf 'b') (Leaf 'c'))
09:08:27 <jle`> i think this might be what the exercise was looking for since i remember you asking about binary trees yesterday maybe
09:12:55 <dunce> *Project2> mapBit [True,False,True,True,True,False,False,True,False]"yzyxy"
09:12:59 <dunce> thanks guys 
09:13:06 <dunce> (y) 
09:16:06 <royal_screwup21> can I ask a question about algorithms?
09:21:39 <svipal> youd have expected the Traced comonad to be easier to understand than the Store
09:21:49 <svipal> B u t n o 
09:22:00 <svipal> t r a c e s
09:27:50 <freeman42x> getting the following error when trying to use live reload with Miso: https://gist.github.com/razvan-flavius-panda/09ef057b7c15166132aab71fb5f7634e any ideas how to fix this?
09:30:06 <dminuoso> freeman42x: What is entr?
09:30:28 <freeman42x> dminuoso, a program that re-runs a command when files change
09:30:58 <dminuoso> freeman42x: Where is it from? It might have wrong expectations wrt to nixos.
09:31:18 <freeman42x> dminuoso, if I understand your question, I installed it from nixpkgs
09:32:10 <freeman42x> dminuoso, if you search for `entr` here you will see that the command was meant to be run in `nix-shell` https://github.com/dmjio/miso
09:32:37 <dminuoso> freeman42x: Im not sure how it works. You could try `entr "$(which cabal) v1-build"`
09:34:21 <freeman42x> dminuoso, gives: `entr: exec $(which cabal) v1-build: No such file or directory`
09:34:31 <wroathe> So am I correct in saying that the PATRICIA trie implementation of IntSet is very different than how PATRICIA tries are typically described? Wikipedia and StackOverflow both seem to think that it's it's bit-wise comparison and then storing the position where the keys differ at each node. IntSet seems to store the the last 58 bits of a 64 bit integer as the "prefix" for a node for comparison
09:34:43 <dminuoso> freeman42x: Oh wait. I think you're not supposed to provide an entire string.
09:35:29 <wroathe> Side note: what an annoying name for a data structure
09:36:07 <dminuoso> freeman42x: Try `entr cabal -- v1-build` perhaps? Or maybe `entry cabal v1-build`
09:36:15 <dminuoso> freeman42x: The readme on miso appears to be incorrect.
09:36:39 <dminuoso> In your case its apparently trying to lookup an executable named "cabal v1-build", but v1-build is supposed to be an argument.
09:41:52 <freeman42x> dminuoso, you are correct, both commands above work
09:42:01 <freeman42x> @karma+ dminuoso
09:42:01 <lambdabot> dminuoso's karma raised to 10.
09:42:35 <dminuoso> freeman42x: By the way, you should probably look into ghcid instead of entr.
09:44:38 <freeman42x> dminuoso, I used ghcid before. I do not think it gives live reload, it just gives live feedback on compile errors?!
09:45:40 <dminuoso> freeman42x: It does give live reload.
09:48:18 <dsal> Does anyone know if there's a convenient function to truncate a UTCTime to specific resolution?  I guess my resolution will always be less than an hour, so it's pretty straightforward, but it seems like something that would be around somewhere.
09:53:01 <EvanR> dsal: i mean you can convert to posix time, scale, floor, convert back to utctime
09:53:59 <EvanR> scale, floor, unscale
09:54:50 <dsal> UTCTime is a day and a difftime.  I'm just truncating the difftime bits.
09:55:06 <fr33domlover> If I'm a Haskeller and a nomad, does that make me a Monad? ^_^
09:56:10 <freeman42x> dminuoso, ok, well, I would rather use something already documented (wrongly in Miso) than try something different haha
09:56:19 <jumper149> Hi, I'm trying to use the Reader monad, but it might not be what I want^^
09:56:24 <EvanR> dsal: technically i have a feeling that would cause a problem...
09:56:47 <EvanR> but maybe not after all
09:56:54 <jumper149> I have a string from which I parse fields just by giving the length and order of the fields.
09:56:58 <EvanR> note the utctime time componen can exceed 86400
09:57:42 <EvanR> so chopping back sort of put you "in yesterday" but... technically you were still in yesterday anyway
09:58:05 <jumper149> What I thought was that the Reader monad would let me mutate the environment so that I can keep using `take n` on the environment but it seems to be immutable
09:58:18 <jumper149> Am I right in thinking that the State monad is just what I want?
09:59:18 <jzyamateur> Was trying to make sense of defining instances for Arbitrary typeclass: https://gist.github.com/chetnashah/0bfaed07bd1ad5caa6ef8409b568a205
09:59:24 <dsal> EvanR: Yeah, I saw that.  It's a minor part of a big refactoring I'm doing.  I don't think we *actually* hit 86401 here.
09:59:40 <jzyamateur> the arbitrary here looks like it is recursive??
09:59:54 <wildtrees> jumper149, if you want mutate state the State monad isn't that bad of a place to go :) 
10:00:01 <dsal> jzyamateur: arbitrary often looks like that.
10:00:06 <EvanR> or 86400.5 more likely
10:00:17 <EvanR> this actually has happened in history
10:00:21 <dsal> I've got some that are like    arbitrary = T <$> arbitrary <*> arbitrary <*> arbitrary <*> arbitrary  ...
10:00:40 <EvanR> though i don't think it was visible on people's stock unixes
10:00:43 <dsal> jzyamateur: The key is that those aren't the same arbitrary
10:00:57 <jzyamateur> dsal: how?
10:01:00 <EvanR> where the effect is even worse
10:01:00 <dsal> EvanR: Yeah, we do time a little differently.  Not to say I wouldn't want to do this more right.
10:01:25 <dsal> jzyamateur: the same way "show" means something different for different types.  The arbitrary is generating a particular type, so it calls the appropriate abitrary.
10:01:55 <dsal> So I'd write yours as     instance Arbitrary a => Arbitrary (Identity a) where arbitrary = Identity <$> arbitrary
10:02:30 <dsal> What that means is that to make an Arbitrary Identity of type a, where a also has an arbitrary instance, call the arbitrary of type a to get an arbitrary a and then wrap it in an Identity.
10:02:31 <EvanR> jumper149: you can't mutate the Reader environment
10:02:36 <jzyamateur> Ah.. I have yet to deal with `<$>` operator, but I get what you are saying.
10:02:40 <EvanR> with State you can
10:02:48 <dsal> jzyamateur: Oh, it's not an important detail here.
10:03:35 <dsal> In your do block  "a <- arbitrary" is getting an arbitrary value of type *a*, not of Identity a.  Then you're wrapping it.
10:03:35 <jzyamateur> Yeah kind of like we are trying to use Arbitrary that is already defined for a.
10:03:43 <dsal> That's exactly what you're doing.
10:03:51 <jzyamateur> Got it... Thanks
10:03:54 <dsal> And this code doesn't have any idea what that is -- it just knows it exists.
10:04:52 <dminuoso> freeman42x: With this particular tool I find that a bit silly. :)
10:06:27 <dsal> EvanR: the good news is that the mixture of DiffTime and NominalDiffTime makes my quick hack not work.  Now I have to do a slightly slower hack.
10:06:56 <EvanR> wait where is DiffTime coming in
10:07:58 <dsal> UTCTime is a Day and a DiffTime.  I was going to just truncate the DiffTime part, but I'm using NominalDiffTime in various places.
10:08:17 * EvanR uhgs
10:08:21 <dminuoso> freeman42x: ghcid is superior to `entr cabal v1-build` in every way, and there's no tie in of miso into entr, so the decision to advertise seems fairly arbitrary and probably just an opinion of the author.
10:08:42 <EvanR> i didn't realize UTCTime used DiffTime. But it's only using it as a Pico really.
10:08:44 <dminuoso> freeman42x: Besides, ghcid is extremely fast. :-)
10:09:15 <dsal> Even with stuff this primitive, time is kind of a pain to work with.
10:09:49 <dminuoso> freeman42x: Also, there's really easy integration into emacs compilation mode if you are an emacs user... :-)
10:09:54 <EvanR> from what i understood we really only need NominalDiffTime in a normal application
10:10:28 <EvanR> i'm going to call bullshit on the use of DiffTime in UTCTime, should be raw Pico
10:10:35 <freeman42x> dminuoso, Atom / VSCode user here. So ehm... how do I use ghcid to not only run cabal build but also relaunch the application after it built it?
10:11:19 <jumper149> EvanR: ty :) Ill rewrite it with State, shouldnt be too hard :p
10:12:10 <dminuoso> freeman42x: There's integration for vsc as well. For how to re-run the application, you can take inspiration from this: https://binarin.ru/post/auto-reload-threepenny-gui/
10:12:11 <EvanR> when you subtract two UTCTimes you get a NominalDiffTime anyway, making the "more exact" DiffTime pointless
10:13:14 <dminuoso> freeman42x: It should be rather trivial anyhow. :)
10:15:39 <EvanR> dsal: heh... the implementation uses realToFrac to disregard DiffTimes type and just use it as a number, in conversions
10:16:19 <dsal> Ugh.  This is mildly annoying.  There's secondsToDiffTime, but how do I just like, make a NominalDiffTime?
10:16:34 <EvanR> fromIntegral or fromRational
10:16:39 <dsal> Yeah, it seems.
10:17:17 <EvanR> conversions e.g. posixTime = number of days * 86400 + min 86400 (realToFrac dt)
10:17:48 <EvanR> i.e. leap time disregarded, diff time added as offset
10:18:59 <dsal> Oh, it's seconds.  I didn't expect that.
10:19:04 <EvanR> yeah
10:24:52 <pikajude> you can just use a num literal for NominalDiffTime
10:25:11 <pikajude> i was trying to figure out how to make a UTCTime representing the unix epoch awhile ago and figured out you can just use
10:25:14 <pikajude> > posixSecondsToUTCTime 0
10:25:16 <lambdabot>  error:
10:25:16 <lambdabot>      Variable not in scope: posixSecondsToUTCTime :: Integer -> t
10:25:19 <pikajude> oh, that's not in scope :(
10:25:33 <pikajude> but you get the idea
10:26:43 <EvanR> works when you have a literal
10:27:33 <EvanR> otherwise you can stuff like hours :: Int -> NominalDiffTime; hours i = fromIntegral (i * 3600)
10:28:05 <pikajude> hmm yeah
10:28:21 <pikajude> that's true
10:28:22 <EvanR> h <- askDatabase; setTimeBomb (hours h)
10:29:53 <pikajude> unsafePerformIO launchTheMissiles
10:32:28 <EvanR> evaluate (unsafePerformIO launchMissiles)
10:32:42 <dsal> launching missiles does seem unsafe.
10:32:50 <int-e> This is Haskell rocket science.
10:33:07 <pikajude> launching them is generally pretty safe, it's when they land that's the risky part
10:33:30 <int-e> pikajude: heh there's a book called "Ignition!" that could teach you otherwise
10:33:39 <sicklorkin> Anyone familar with Moving Average filters? I'm trying to understand what a weighted shifted unit impulse function is.. Is that something like w(t) = (1/2)^(t/λ) * Foo
10:33:41 <int-e> (on development of rocket fuels. fun read.)
10:33:44 <pikajude> nah i knew that joke was on poor foundations when i typed it
10:33:56 <pikajude> but i had to give it a try
10:34:00 <dsal> Derivative of "falling doesn't kill you"
10:34:33 <pikajude> could one die from freefalling long enough? wouldn't it be hard to breathe?
10:34:43 <pikajude> ok actually let's stop there before this gets to haskell-blah material
10:35:20 <sicklorkin> well i guess I dont' know how to solve Foo.. 
10:35:23 <EvanR> there's an entire reddit for that one i think
10:35:26 <dsal> Man, UTCTime isn't an Enum.
10:35:38 <pikajude> no, i don't think there's a sensible way to implement that
10:35:43 <dsal> This slightly increases my work.
10:35:50 <pikajude> i'm pretty sure UTCTime tracks picoseconds or something crazy like that
10:35:57 <EvanR> dsal: i mean, would you want it to act like Double?
10:35:59 <pikajude> what are you trying to do?
10:36:00 <dsal> Time is so easy.  Everyone understands how it works.
10:36:05 <pikajude> that's how they get you
10:36:24 <dsal> I'm just creating a sequence of times by duration.  My original code didn't use UTCTime, so I'm just updating it.
10:36:40 <dsal> I had time as an Int, with no basis or anything.  Just counting some units of time up.
10:36:46 <EvanR> zipWith
10:37:09 <EvanR> scanl, something
10:37:09 <dsal> zipWith...   I wouldn't've thought of that.  Thanks.
10:37:24 <dsal> Yeah, scanl actually is probably what I want.
10:38:02 <dsal> Oh wait, no, this is zip.  So maybe zipWith.  I need to add a type annotation to this thing to figure out what I'm even trying to do.
10:38:17 <pikajude> it's a true mystery
10:38:28 <EvanR> zoiks
10:39:12 <svipal> does anyone use comonad stacks in their work ?
10:44:19 <EvanR> .oO( what is a comonad stack )
10:44:55 <dsal> comonod gobot library
10:45:04 <svipal> stack of comonad transformers
10:45:09 <svipal> https://www.youtube.com/watch?v=jTVVtJGu3D0
10:45:55 <svipal> I'm doing my best to follow along, but even when I can I don't get the "I see where that could be useful" insight
10:46:38 <merijn> svipal: Comonad's are much more niche in their use than monads are
10:46:51 <merijn> svipal: I don't think I've ever used them
10:48:11 <EvanR> i had no idea there were more than a couple (haskell) comonads
10:48:36 <dsal> EvanR: there's a whole stack of them
10:48:52 <merijn> hah
10:49:25 <dsal> Yay, my code compiles.  My tests  are going to be quite an uphill battle, I bet...
10:49:56 <EvanR> if it compiles it's good. If it passes tests it's perfect (tm)
10:50:17 <dsal> Well, it's not failing tests...
10:50:20 <svipal> there's some serious voodoo magic going on in the Traced Monad
10:50:24 <svipal> Comonad*
10:50:40 <svipal> what were you trying to do dsal ?
10:51:00 <dsal> Just convert some hand wavy Int timestamps and durations to UTCTime and NominalDiffTime
10:51:23 <dsal> I have actual data to work on now, so I know more about what I'm doing.
10:51:32 <crestfallen> hi I'm trying to get readMay to work with 'import Data.Monoid' and one of the following: 1) {-# LANGUAGE Safe #-} 2) import Data.Safe (readMay)
10:51:40 <crestfallen> neither works
10:52:12 <merijn> crestfallen: Doesn't work how?
10:52:20 <merijn> What do you expect and what happens instead?
10:53:52 <crestfallen> won't compile with number of 'Variable not in scope: readMay :: [Char] -> Maybe Int'
10:53:59 <crestfallen> errora
10:54:04 <crestfallen> errors*
10:56:02 <EvanR> it doesn't make sense that you'd get that error but Data.Safe imported without error
10:56:22 <EvanR> i think there's a bug in your question
10:56:37 <crestfallen> could be :)
10:56:49 <crestfallen> let me pastebin 
10:57:40 <crestfallen> https://termbin.com/4kpj EvanR merijn 
10:58:08 <int-e> you commented out the import
10:58:32 <crestfallen> yeah I've tried both of those on line 2 and 3
10:58:44 <EvanR> {-# LANGUAGE Safe #-} doesn't have anything to do with readMay
10:58:51 <crestfallen> ok
10:59:13 <crestfallen> I'm trying to get readMay to work in this program
10:59:14 <int-e> Are you sure it's Data.Safe? I've found a Safe module in a package of the same name...
10:59:41 <EvanR> crestfallen should have package `safe' installed
11:00:07 <sicklorkin> > mapM (id &&& id) $ take 10 (cycle [8,0,0,8,s])
11:00:09 <lambdabot>  (8 <> 0 <> 0 <> 8 <> s <> 8 <> 0 <> 0 <> 8 <> s <> mempty,[8,0,0,8,s,8,0,0,8...
11:00:11 <crestfallen> initially I tried 'import Safe (readMay)'
11:00:33 <crestfallen> as per video tutorial
11:00:36 <int-e> crestfallen: that should work once you install/depend on the safe package
11:00:57 <int-e> cf. https://hackage.haskell.org/package/safe
11:01:27 <crestfallen> ok I'll use cabal to install: '$ cabal install safe'   ?
11:01:33 <int-e> (how you install it depends on your favorite toolchain... cabal install safe  or  stack install safe  seem the most likely.
11:01:44 <crestfallen> thanks!
11:02:19 <svipal> are you trying to use it in your code or in ghci ?
11:02:39 <EvanR> i'm now inspired to put everything in top level modules
11:02:48 <EvanR> screw the hierarchy
11:04:08 <svipal> I completely abandoned having a lot of neatly organized submodules after  struggling with HS boots newtypes and typeclasses
11:04:30 <crestfallen> that compiled thanks ALL
11:05:07 <EvanR> crestfallen: no one dared ask, at first, if you even had the package installed because you didn't really explain what the error you were seeing was...
11:05:08 <dsal> crestfallen: hey, np
11:05:58 <crestfallen> please be patient with this babe in the woods
11:06:03 <EvanR> i think it would have a been a "is it plugged in" type of situation
11:18:09 <merijn> Hmm, given an 'f :: [a] -> [a] -> [a]' and 'l :: [[a]]' is the a function that nicely applies 'f' to each individual list without introducing an extra wrapping for the empty list? foldr isn't quite it
11:18:39 <merijn> (since foldr would have to use [] as zero element for the empty list)
11:20:22 <dsal> I think my conversion from relatively small numbers for time to a fairly wide range of picosecond-based timestamps may have blown out my tests a bit.
11:21:43 <dmwit> merijn: foldr1?
11:22:11 <dmwit> (Or, what do you want it to do if `l = []`?)
11:22:14 <merijn> dmwit: heh, why'd I forget about that one >.>
11:22:54 <merijn> dmwit: Can't happen :)
11:41:14 * hackage sbv 8.5 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  https://hackage.haskell.org/package/sbv-8.5 (LeventErkok)
11:52:15 <crestfallen> I'm looking at the definition of semigroup which says: "A semigroup generalizes a monoid in that there might not exist an identity element. It also (originally) generalized a group (a monoid with all inverses) to a type where every element did not have to have an inverse, thus the name semigroup" so this is something I don't understand about these mathematical classes. How can a set with a single binary operation be a generalization of something 
11:52:15 <crestfallen> far more specific, such as a monoid or group (I understand groups to an elementary degree) thanks. 
11:52:46 <merijn> crestfallen: More generic = less specific
11:53:27 <merijn> crestfallen: So "semigroup" is a generalisation of monoid (less specific) and monoid a specialisation/subset of semigroup (i.e. more specific)
11:54:08 <crestfallen> yeah thanks, but in haskell it came later that Semigroup became a superclass of Monoid right?
11:54:15 <merijn> So?
11:55:00 <crestfallen> I was wondering about the need to make that change, when monoid was being used unrelated to semigroup, or is that wrong?
11:55:19 <crestfallen> trying to form my questions...
11:55:50 <merijn> crestfallen: The problem is that without that superclass you can define monoids which are not semigroups, which means you can't generalise monoid code to semigroup code without that superclass
11:56:41 <merijn> There's not technical reason semigroup has to be a superclass of Monoid. You could define instances for both before that was the case
11:57:07 <merijn> crestfallen: What the superclass gets you is the guarantee that *every* Monoid also has a Semigroup instances
12:03:40 <crestfallen> thanks merijn please stand by
12:04:02 <dignissimus> I want to install a project is it recommended that I use `cabal install` or `stack install`?
12:04:22 <merijn> dignissimus: Well, how are you building the project right now?
12:04:55 <dignissimus> It's an external one, I don't have it: https://github.com/hdevtools/hdevtools/
12:05:24 <merijn> Does hdevtools even work anymore?
12:06:21 <dignissimus> Not sure, looking at the repo, it does seem quite old
12:07:10 <merijn> There's plenty of repos that are quite old and still work
12:07:40 <merijn> The more problematic thing is that I remember writing emergency CPR patches to keep it working several years ago and I don't think maintenance has gotten more active :p
12:08:26 <merijn> dignissimus: I've been playing with ghcide recently which works marvellous (well for my simpler projects, lack of TH support is killing me)
12:08:58 <crestfallen> merijn, ok I see. monoid has a "single most natural operation for combining values" which is different from a binary operator, correct? so foldr for example, also doesn't need to apply a binary operator necessary to the list
12:09:31 <merijn> crestfallen: Where did you find that definition?
12:09:31 <crestfallen> necessarily* 
12:09:53 <crestfallen> https://wiki.haskell.org/Monoid
12:09:56 <merijn> crestfallen: Because the proper definition of a monoid is "an associative binary operation + identity element"
12:11:00 <crestfallen> its the first sentence there
12:11:20 <merijn> Yeah, that's sloppy "human terminology" not a proper definition
12:11:29 <crestfallen> oh boy
12:13:08 <merijn> crestfallen: The laws of Monoid (the Haskell class and also the math notion) are as follows: "mappend a (mappend b c) == mappend (mappend a b) c" and "mappend mempty x = x = mappend x mempty"
12:14:12 <crestfallen> so mappend is technically a binary operation? because the definition I posted seems like the writer was careful not to say binary operation
12:14:13 <Athas> Although a mathematician would slap you for writing it like that.
12:14:14 <dminuoso> Are there some notable projects displaying how to properly structure a parser using megaparsec?
12:14:27 <merijn> crestfallen: Mappend *is* a binary operation, not just technically
12:14:59 <merijn> dminuoso: Eh, the same way you do it with parsec, trifecta, attoparsec? >.>
12:15:19 <dminuoso> merijn: Sure, so any reference for those? ;)
12:15:25 <MarcelineVQ> dminuoso: there's a selection of megaparsec tutorials
12:15:39 <merijn> dminuoso: I usually try to mimic the BNF/logical blocks
12:15:49 <merijn> dminuoso: and make it up as I go along :p
12:16:17 <MarcelineVQ> e.g. https://markkarpov.com/megaparsec/megaparsec.html
12:21:39 <crestfallen> > foldr not Bool [True,False,True]
12:21:42 <lambdabot>  error:
12:21:42 <lambdabot>      • Data constructor not in scope: Bool
12:21:42 <lambdabot>      • Perhaps you meant variable ‘bool’ (imported from Data.Bool)
12:21:53 <crestfallen> sorry what should the seed value be there?
12:22:03 <dmwit> can't be made to work
12:22:06 <sm[m]> dminuoso: I don't know about properly, but hledger is a real world app using it
12:22:15 <dmwit> not is unary, foldr needs a binary operation
12:22:17 <sm[m]> it is mostly in monadic style, not applicative
12:22:50 <crestfallen> dmwit dang I thought I was working with that a while back
12:24:02 <merijn> crestfallen: There's two monoids on Bool (well, actually a lot more, but two common/oft used ones)
12:24:18 <merijn> crestfallen: But since you can only have one instance per type you need newtypes to use them
12:24:26 <merijn> crestfallen: Which in this case are Any and All
12:24:40 <merijn> > foldMap Any [True, False, True, False]
12:24:42 <lambdabot>  Any {getAny = True}
12:24:50 <merijn> > foldMap All [True, False, True, False]
12:24:53 <lambdabot>  All {getAll = False}
12:25:50 <crestfallen> merijn, ok thanks I was thinking of a snippet I was working on, where the seed was True or Bool, like a snippet to illustrate boolean logic
12:27:30 <crestfallen> so the difference b/t foldable and monoid is that foldable needs no identity
12:27:39 <crestfallen> confused
12:28:25 <merijn> crestfallen: I'm not sure what you mean by that?
12:35:14 <dmwit> (There are four monoids on Bool: (&&)/True, (/=)/False, (==)/True, (||)/False. These correspond to making two independent choices: either Sum or Product, and which of False/True represents 0/1.)
12:35:43 <merijn> dmwit: You're forgetting *at least* two
12:35:53 <merijn> oh, wait no I'm thinking of semigroups
12:36:13 <merijn> (First and Last)
12:36:44 <dmwit> There are 8 semigroups.
12:38:42 <crestfallen> dmwit I need to study that thanks both you and merijn .. I gotta go.. you'll be hearing from me again :)
12:38:44 <dmwit> (besides First and Last, there's const False and const True)
12:39:09 <crestfallen> this stuff is rough
12:39:33 <crestfallen> I need to listen to Leonard Cohen
12:39:38 <merijn> crestfallen: Lets rewind, how'd you end up with these questions? Because perhaps you don't need to know the answer right now :)
12:40:15 <boxscape> dmwit so const False and const True are Semigroup but not Monoids?
12:40:35 <crestfallen> I was trying to get one point straight, then other questions came up, then your input made me wonder about various foggy areas
12:40:50 <crestfallen> It's a bit soup
12:40:55 <crestfallen> big*
12:41:12 <dmwit> boxscape: right
12:41:26 <boxscape> dmwit why can't you just set mempty to True for const True and False for const False?
12:42:01 <boxscape> wait I should probably just look at the identity laws huh
12:42:29 <dmwit> boxscape: No matter what mempty you pick, mempty <> False = True, which isn't okay.
12:42:37 <boxscape> okay, that makes sense
12:42:49 <dmwit> (Sorry, I meant const (const False) and const (const True), of course.)
12:48:11 <crestfallen> merijn, I'm trying to get it from the math side as well so I've been reading about these different structures
12:48:14 * hackage hsinspect 0.0.5 - Inspect Haskell source files.  https://hackage.haskell.org/package/hsinspect-0.0.5 (tseenshe)
12:49:42 <crestfallen> hey how do you make the little bullet to make clever little comments under your handle in say hexchat? like: crestfallen nods
12:49:59 <svipal>   *tries*
12:50:04 <dmwit> cabal v2-* searches up the directory tree for a cabal.project file. If it doesn't find one, but it sees a *.cabal file, it uses that. Can I ask it to skip looking for a cabal.project file and just behave as it would if it just used the *.cabal file in the current directory?
12:50:09 * svipal tries again
12:50:20 <svipal> crest, /me
12:51:35 <crestfallen> svipal sorry?
12:51:52 <crestfallen> what do I type precisely..
12:52:29 <boxscape> you type /me nods
12:52:40 * crestfallen nods
12:52:48 <crestfallen> thanks ! boxscape 
12:53:11 <crestfallen> I've been wondering about that for many moons :)
12:53:13 * sm[m] high-fives crestfallen
12:53:28 * crestfallen hip hip hooray!
12:54:06 <dmwit> I thought I'd be clever and try `cabal v2-build --project-file <(echo packages: $(pwd))`, but it tells me 'No cabal.project file or cabal file matching the default glob './*.cabal' was found.'.
12:54:13 <dmwit> Which... seems like an odd error in the circumstances.
12:54:14 <dminuoso> Wow. 80 lines megaparsec program taking about 22 seconds to compile. o.o
12:54:18 <dminuoso> This is.. odd.
12:58:22 <crestfallen> Athas, sorry did you mean a mathematician would slap the member helping me or the o.p. haskell wiki writer for writing it that way?
12:59:06 <dminuoso> sm[m], merijn, MarcelineVQ: Cheers by the way for the tips.
13:00:00 <Athas> crestfallen: neither.  A mathematician would never use prefix application to demonstrate associativity.
13:00:40 <Athas> It was just a small joke about merijn's statement about the "math motion" contrasted with his Haskell notation.
13:05:23 <crestfallen> Athas, thanks I see, you don't like prefix notation like "mappend a (mappend b c) == mappend (mappend a b) c"  . I studied scheme for a minute and got used to prefix notation so I often prefer it. it's weird how sometimes it just looks wrong, other times clean.
13:16:08 <higherorder> Hi! Is `Maybe` referred to as a `higher-kinded type`?
13:16:16 <merijn> higherorder: No
13:16:25 <dminuoso> % :k StateT
13:16:25 <yahb> dminuoso: StateT :: * -> (* -> *) -> * -> *
13:16:40 <higherorder> marijn: what's the definition of higher-kinded? a type that takes type constructors as params?
13:16:43 <EvanR> StateT has a higher order kind
13:16:55 <higherorder> I've seen Maybe being referred to as higher kinded, which I thought was.. odd (on stackoverflow)
13:16:56 <dminuoso> higherorder: Not necessarily type constructors, but sure.
13:17:02 <dminuoso> higherorder: c.f. higher order function
13:17:09 <higherorder> dminuoso: so a higher-kinded type is a higher-order function on types? 
13:17:18 <dminuoso> higherorder: One could say that, yes. :)
13:17:22 <EvanR> it's becoming apparently that "higher-kinded" doesn't make much sense
13:17:37 <dminuoso> higherorder: Though "higher-kinded" is not really a term, yeah.
13:17:49 <dminuoso> higher order type-function perhaps?
13:18:02 <EvanR> seems more likely
13:18:10 <higherorder> dminuoso: makes sense, thanks :)
13:18:16 <EvanR> which makes Maybe not one of those
13:18:21 <lyxia>  @let higher-kinded = higher order type-function
13:18:24 <lyxia> now it's a term.
13:18:26 <higherorder> dminuoso: and would you refer to `Functor :: (Type -> Type) -> Constraint` as a higher-kinded type? or a higher-kinded constraint?
13:18:49 <higherorder> @lyxia what does that command do? 
13:18:49 <lambdabot> Unknown command, try @list
13:19:00 <lyxia> @let x = 32
13:19:01 <lambdabot>  Defined.
13:19:02 <dminuoso> higherorder: Kind of depends on your view of things.
13:19:02 <lyxia> > x
13:19:04 <lambdabot>  error:
13:19:04 <lambdabot>      Ambiguous occurrence ‘x’
13:19:04 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.x’,
13:19:09 <lyxia> darn
13:19:13 <lyxia> @let xy = 32
13:19:15 <lambdabot>  Defined.
13:19:16 <lyxia> > xy
13:19:18 <lambdabot>  32
13:19:19 <EvanR> lyxia changed the fabric of the jargon continuum
13:19:30 <dignissimus> There are issues here, the compiler does give errors but even after reading them I don't understnd exactly what's wrong: https://paste.debian.net/hidden/c03d8f63/ https://paste.debian.net/hidden/9d6f3173/ https://i.imgur.com/cb1sumy.png
13:19:34 <dignissimus> I've given the compiler output, my code and an image from my linter. Right now I don't think I want to know how to fix it but I just firstly want to know what's wrong  
13:20:12 <higherorder> dminuoso: how so?
13:20:13 <merijn> dignissimus: isRight followed by fromRight :(
13:20:34 <merijn> dignissimus: You can replace that by just directly using result in the case-of
13:20:39 <dminuoso> higherorder: It depends on how much you consider constraints to be proper types perhaps?
13:20:51 <dminuoso> higherorder: I suppose since ConstraintKinds they could be considered as such?
13:20:59 <higherorder> dminuoso: ah fair
13:21:02 <merijn> dignissimus: In general, using isRight/isLeft should be avoided
13:21:09 <higherorder> dminuoso: thanks!
13:21:10 <lyxia> maybe the etymology of "higher-kinded" sucks but I think it's somewhat well established already
13:21:30 <dignissimus> merijn: oh, what should I use instead?
13:21:37 <merijn> dignissimus: Pattern matching :)
13:21:44 <dignissimus> Ahhh
13:21:53 <EvanR> this IRC channel can change the establishment :)
13:21:56 <dmwit> higherorder: Some people say "higher kinded" to mean "any arrow kind". Under this definition, Maybe is higher-kinded.
13:21:59 <merijn> dignissimus: Oh, you can actually simplify some other things even more
13:22:26 <merijn> dignissimus: see how in runPolish you only do something if you have a Right and otherwise return the original input?
13:22:26 <higherorder> dmwit: isnt' that a bit at odd with the "higher order function" terminology?
13:22:52 <merijn> dignissimus: That's just the Functor/Applicative for Either :)
13:23:05 <dmwit> higherorder: No. Because here "higher" means "higher than C". ^_^
13:23:23 <higherorder> dmwit: haha
13:23:26 <dminuoso> higherorder: It would be yes, but language is often imprecise and you have to work with some common definition - so usually one accepts the definition of the other party, regardless of whether they agree with it..
13:23:32 <merijn> dignissimus: Instead of "calculatePolish (fromRight stack)" do "calculatePolish <$> stack"
13:23:38 <dminuoso> (Because otherwise you end up with useless bikeshedding of terminology)
13:23:45 <EvanR> higher kinded would appear to be flexing wrt some other language that has any kinds at all
13:23:51 <higherorder> dminuoso: yeah fair, I'm just curious about the ethimology of it
13:23:52 <EvanR> which includes...
13:23:59 <EvanR> not C
13:24:24 <dminuoso> higherorder: For example "dynamic typing" does not exist in the sense of type theory, although sadly its not a useful point to raise when someone wants to compare his dynamically typed language to your (actually) typed one.
13:55:25 <dignissimus> Right now I'm mostly confused as to why I can't return `Right ...` https://paste.rs/HlY.hs https://paste.rs/aNl https://i.imgur.com/TuUjWCO.png
13:56:12 <EvanR> Right (number:stack) ?
13:56:21 <EvanR> you write (Right number):stack
13:56:24 <EvanR> wrote*
13:57:22 <dadefsad> has anyone ever bought drugs here https://partydron.com ? they make drone delivery anonymously, it looks good but I need some opinions,Any experience with them? Thanks
13:57:49 <monochrom> click bait
13:58:32 <sm[m]> well that's surely an honest request for help, eh
13:58:44 * hackage language-c-quote 0.12.2.1 - C/CUDA/OpenCL/Objective-C quasiquoting library.  https://hackage.haskell.org/package/language-c-quote-0.12.2.1 (GeoffreyMainland)
13:58:46 <geekosaur> sigh
13:58:48 <dmwit> I'd ban, but it doesn't really seem like it would stick anyway.
14:05:41 <dignissimus> I understand the second error but I don't know what to do about it: https://paste.rs/Fr9.hs https://paste.rs/qDV
14:06:18 <EvanR> i can't tell what line it's talking about
14:06:28 <dignissimus> It can't induce that I want to read a number but I don't know how to tell it that I want a number, I've already given the type for calculatePolish
14:06:43 <EvanR> right
14:07:11 <EvanR> you need to add more type info somehow
14:08:10 <monochrom> No, you only have "Num a" you need both (Read a, Num a)
14:08:41 * dignissimus sighs
14:08:44 <arstneio> I'm trying to run `ghcide` in a nix shell (just created by running `cabal2nix --shell . > shell.nix`) in a Haskell project, but I'm getting this error: https://pastebin.com/kbL1hRTN. What am I doing wrong?
14:08:48 <monochrom> If you say "I've already done that for runPolish" well that's not enough.
14:08:50 <dignissimus> I ignored that becayse I was adament I had that in there
14:09:38 <EvanR> heh
14:09:53 <monochrom> Hand-written types are a two-edged sword.
14:10:13 <EvanR> i can't compile your code because the number of arguments to runPolish seems to lacking
14:14:01 <EvanR> we're still in the ancient world where types and code are written by hand for the most part
14:14:17 <EvanR> no one will believe it in 4019
14:14:36 <EvanR> or understand it
14:14:49 <monochrom> Perhaps no one will be even there!
14:15:08 <EvanR> well it's always "no one is there" somewhere
14:15:20 <EvanR> if jimmy buffet was a nihilist
14:17:14 <dmwit> I thought about switching to nihilism, but then I thought, eh, why bother?
14:17:59 <monochrom> haha
14:18:27 <tdammers> I don't believe nihilism exists
14:18:34 <monochrom> hehe
14:18:47 <hpc> nihilism doesn't believe you exist either
14:18:51 <siraben> How can I get rid of writing this Monoid constraint in these writer instances? https://gist.github.com/siraben/a0d43c4d0d5e4fa6c393289ca965bd44#file-monad-transformers-hs-L157-L169
14:18:52 <dmwit> Ah, an anihilismist.
14:18:53 <siraben> Can I move it up to the newtype declaration of Writer?
14:19:18 <dmwit> Why do you want to get rid of them?
14:19:23 <monochrom> No, you must keep it.
14:19:28 <dmwit> (You can't get rid of them.)
14:19:30 <EvanR> you really want the constraints on the operations not the data type
14:19:50 <dmwit> (So the next step is to figure out what can be done to help you achieve your goals without getting rid of them, hence "Why?".)
14:20:28 <dignissimus> My code works! Any improvements I can make to it? I heard I could replace the code in runPolish with an fmap expression https://paste.rs/ttU.hs
14:20:34 <dmwit> You can eliminate it from the Functor instance, I guess.
14:20:41 <siraben> dmwit: Because the MTL does it better; https://hackage.haskell.org/package/mtl-2.2.1/docs/src/Control.Monad.Writer.Class.html#MonadWriter
14:20:57 <siraben> Well, looks like MTL still has monoid constraints on the instances
14:21:07 <dmwit> siraben: How does that link support the claim "MTL does it better"?
14:21:36 <siraben> dmwit:  Nvm I just realized that my WriterMonad class has the same constraints as MTL
14:22:55 <dmwit> dignissimus: Perhaps you can `runPolish eStack text = eStack >>= \stack -> calculatePolish stack text`.
14:23:06 <dmwit> It can be prettier still if you're willing to switch the argument order around a bit.
14:23:15 <siraben> So, I have to keep the constraints, ok.
14:23:32 <dmwit> :t foldM
14:23:33 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
14:23:38 <siraben> Also, if w is already a string, show w makes it have additonal quotes around it. Do I have to define a new instance for Writer when w is a string?
14:23:51 <siraben> @show "hello"
14:23:52 <lambdabot> "\"hello\""
14:24:10 <dmwit> dignissimus: You might like `executeCalculation = foldM calculatePolish [] . words`.
14:25:14 <dmwit> siraben: How is "show w makes it have additional quotes" related to the second part of your question?
14:26:53 <siraben> dmwit:  Just a preference, I suppose.
14:27:08 <dmwit> ?
14:27:19 <dmwit> I mean, your instances don't even call show. So who cares what it does?
14:30:48 <dignissimus> dmwit: Thanks, after understanding what foldM does, it feels weirdly convenient
14:32:00 <merijn> dignissimus: Well yes, that's why people were telling you to use "Left" as error yesterday (if I remember correctly?) because then all those Functor/Applicative/Monad instances evaporate away half your code/error checking ;)
14:33:35 <jumper149> Hi, I have a function of type (:: StateT s Maybe r). Is it possible to access the Maybe monad from within that function?
14:33:58 <dminuoso> jumper149: In what sense do you wish to "access" it?
14:34:27 <dminuoso> jumper149: What other than lift do you need?
14:34:28 <jumper149> I want to be able to make an exception while changing the state.
14:35:13 <EvanR> that's just lift Nothing right
14:35:37 <jumper149> from MonadTrans?
14:35:59 <EvanR> :t lift
14:36:00 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
14:36:05 <EvanR> apparently
14:37:04 <jumper149> that's why i asked: http://sprunge.us/Ih6Zq5
14:37:24 <jumper149> hoogle misleading me^^ stil ty
14:37:47 <EvanR> oh man somebody stepped right on `lift' in that lib :)
14:38:36 <EvanR> something about the value of names beyond the usual bureaucracy of alpha equivalence and type checking
14:39:36 <EvanR> i think edwardk has almost exhausted the dictionary at this point
14:42:59 <dmwit> % :t runStateT
14:42:59 <yahb> dmwit: StateT s m a -> s -> m (a, s)
14:43:19 <dmwit> % runStateT (fail "hi") () :: Maybe ((), ())
14:43:19 <yahb> dmwit: Nothing
14:43:59 <EvanR> state go down the hole
14:44:07 <dmwit> % runStateT empty () :: Maybe ((), ())
14:44:07 <yahb> dmwit: Nothing
14:44:42 <dmwit> jumper149: ^ two other ways to make an "exception"
14:46:48 <dignissimus> merijn: Yes, it makes sense now haha
14:46:53 <dignissimus> Thanks all!
14:54:04 <svipal> https://www.youtube.com/watch?v=XZ9nPZbaYfE what language is this ? (6:00)
14:54:55 <svipal> oh Im dumb
14:54:59 <monochrom> Looks like scala
14:55:01 <svipal> she just says it 2 secs later
14:55:04 <svipal> yeah
15:10:03 <higherorder> I'm having a weird "problem" with GHCI. It would seem like the flag `print-explicit-foralls` prints the forall in the order variables appear in the signature, and not in the order they're specified in an explicit forall. e.g. `f :: forall b a. a -> b`, and then `:t f` in GHCI prints `forall {a} {b}. a -> b` 
15:10:16 <evocatus> @hoogle a -> a
15:10:16 <lambdabot> Prelude id :: a -> a
15:10:17 <lambdabot> Data.Function id :: a -> a
15:10:17 <lambdabot> GHC.Exts breakpoint :: a -> a
15:10:30 <evocatus> @hoogle (a -> b -> c) -> [a] -> b -> [c]
15:10:31 <lambdabot> System.FilePath.Find liftOp :: Monad m => (a -> b -> c) -> m a -> b -> m c
15:11:42 <evocatus> strange - only System.FilePath implements such a function?
15:12:49 <EvanR> :t zipWith3
15:12:50 <lambdabot> (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
15:12:56 <EvanR> er
15:13:16 <EvanR> zipWith f xs (cycle b) ?
15:14:05 <EvanR> @djinn (a -> b -> c) -> [a] -> b -> [c]
15:14:05 <lambdabot> Error: Undefined type []
15:14:47 <evocatus> @pl (\f c xs -> (flip f) c <$> xs)
15:14:47 <lambdabot> ((<$>) .) . flip
15:15:16 <evocatus> yeah, considered doing cycle or a repeat or something
15:15:26 <EvanR> i meant repeat
15:16:02 <evocatus> was wondering if there was something terser (and more comprehensible than the above symbol soup lol)
15:16:08 <EvanR> it's close enough to zipWith and unusual enough it doesn't merit its own library function
15:16:20 <boxscape> oh no
15:16:23 <boxscape> I thought I understood this finally
15:16:24 <evocatus> I suppose it is
15:16:33 <boxscape> % const 4 (I# (undefined :: Int#))
15:16:34 <yahb> boxscape: 4
15:16:36 <boxscape> why does this not crash
15:16:38 <EvanR> lol
15:16:40 <boxscape> I thought unboxed values are strict
15:16:53 <EvanR> the gift that keeps on giving
15:16:54 <boxscape> oh wait
15:16:58 <boxscape> I guess the I# is non-strict
15:17:04 <boxscape> or something
15:17:24 <EvanR> const is not strict
15:17:30 <EvanR> in the second arg
15:17:54 <EvanR> > const 4 undefined
15:17:56 <lambdabot>  4
15:17:57 <boxscape> EvanR right but "undefined :: Int#" usually crashes in the examples I've come up with so far because it is strict, because Int# isn't lifted
15:18:17 <EvanR> you mean the strictness is leaking sort of?
15:18:33 <boxscape> % case undefined of (_ :: Int#) -> 4
15:18:34 <yahb> boxscape: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:119:1 in interactive:Ghci25
15:18:35 <boxscape> this is what I mean
15:18:48 <boxscape> % case undefined of (_ :: Int) -> 4 -- whereas with Int it doesn't crash, I hope
15:18:48 <yahb> boxscape: 4
15:19:10 <EvanR> um
15:19:32 <EvanR> the second example there is the same as const 4 (I# undefined)
15:19:44 <boxscape> that's a good point
15:20:46 <lyxia> why is undefined :: Int# legal
15:21:03 <boxscape> lyxia because undefined has a levity polymorphic type declaration
15:21:04 <EvanR> undefined is levity polymorphic
15:21:13 <EvanR> because error is
15:21:17 <EvanR> but there are bugs
15:21:47 <EvanR> and what it even means is still confusing to me
15:22:13 <EvanR> there seems to be a sort of locality issue
15:22:26 <nshepperd2> interesting that that's not a kind error
15:22:56 * EvanR tries to figure out how to print the full type out in all its glory
15:24:34 <nshepperd2> I guess you can't have an undefined *value* of type Int#, but you can still throw an exception when constructing one
15:24:35 <lyxia> My guess is "case" on an unlifted type cannot be non-strict because there is no "bottom" in unlifted types for "non-strict" to even make sense.
15:24:49 <nshepperd2> > let x = undefined :: Int# in 4
15:24:50 <lambdabot>  error:
15:24:51 <lambdabot>      Not in scope: type constructor or class ‘Int#’
15:24:51 <lambdabot>      Perhaps you meant one of these:
15:24:52 <EvanR> https://stackoverflow.com/questions/49986342/why-is-the-undefined-function-levity-polymorphic-when-using-it-with-unboxed-type
15:24:58 <nshepperd2> % let x = undefined :: Int# in 4
15:24:59 <yahb> nshepperd2: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:124:9 in interactive:Ghci26
15:25:14 <boxscape> you'd think you wouldn't be able to assign unboxed variables in a let binding
15:25:21 <boxscape> % let x = 5# in 4
15:25:22 <yahb> boxscape: 4
15:25:24 <boxscape> wait
15:25:28 <EvanR> well, you can
15:25:32 <EvanR> and that is good
15:25:36 <boxscape> I must be misremembering how this works
15:25:59 <EvanR> nothing about let bindings requires boxed ness
15:26:02 <boxscape> % let x = 5#
15:26:02 <yahb> boxscape: ; <interactive>:1:1: error: GHCi can't bind a variable of unlifted type: x :: Int#
15:26:05 <boxscape> maybe that's what I was thinking of
15:27:02 <EvanR> the surprising part is, you'd think "crash when evaluated" requires boxedness
15:27:54 <EvanR> because unboxed seems to imply "always evaluated"
15:28:32 <boxscape> % case ((let x = x in x) :: Int#) of (_ :: Int#) -> 4
15:28:32 <yahb> boxscape: ; <interactive>:127:21: error:; * Couldn't match a lifted type with an unlifted type; When matching types; t0 :: *; Int# :: TYPE 'GHC.Exts.IntRep; * In the expression: x; In the expression: ((let x = x in x) :: Int#); In the expression: case ((let x = x in x) :: Int#) of { (_ :: Int#) -> 4 }
15:28:34 <boxscape> hmm
15:29:01 <nshepperd2> with unboxed things, evaluation is simultaneous with construction
15:29:39 <nshepperd2> % let f :: Int# -> Int#; f x = error "callee" in f (error "caller")
15:29:39 <yahb> nshepperd2: ; <interactive>:128:1: error:; * Couldn't match a lifted type with an unlifted type; When matching types; () :: *; Int# :: TYPE 'GHC.Exts.IntRep; * In the first argument of `print', namely `it'; In a stmt of an interactive GHCi command: print it
15:30:03 <nshepperd2> oh right
15:30:09 <EvanR> careful trying to demonstrate anything on this topic, because boxscape uncovered some egregious bugs
15:30:23 <nshepperd2> % let f :: Int# -> Int#; f x = error "callee"; tmp = f (error "caller") in 4
15:30:23 <yahb> nshepperd2: *** Exception: caller; CallStack (from HasCallStack):; error, called at <interactive>:129:55 in interactive:Ghci27
15:30:46 <boxscape> well, one, I think, but there's already a merge request for it
15:30:56 <boxscape> % let bottom :: forall (r :: RuntimeRep). forall (a :: TYPE r). a ~ a => a; bottom = bottom in I# (bottom :: Int#)
15:31:01 <yahb> boxscape: [Timed out]
15:31:53 <boxscape> curiously if you specialize that it doesn't work
15:31:59 <boxscape> % let bottom :: Int#; bottom = bottom in I# (bottom :: Int#)
15:32:00 <yahb> boxscape: ; <interactive>:1:5: error: Recursive bindings for unlifted types aren't allowed: bottom = bottom
15:32:45 <EvanR> ok that is whack
15:33:17 <boxscape> (it also doesn't work if you leave out the `a ~ a` but for different reasons)
15:33:49 <boxscape> oh actually
15:33:50 <boxscape> same reason
15:33:56 <boxscape> % let bottom :: Int ~ Int => Int#; bottom = bottom in I# (bottom :: Int#)
15:34:01 <yahb> boxscape: [Timed out]
15:34:31 <boxscape> this bottom can be recursive because it's a function
15:34:40 <EvanR> um. why?
15:34:56 <nshepperd2> hah
15:34:58 <nshepperd2> nice
15:35:06 <boxscape> because `Int ~ Int` is a parameter, automatically solved by ghc and apparently has zero sized, but it's still a parameter
15:35:21 <boxscape> s/sized/size
15:36:09 <EvanR> haskell is starting to jump the shark maybe
15:36:14 <nshepperd2> so bottom is secretly actually boxed there?
15:36:25 <boxscape> yes nshepperd2
15:36:40 <nshepperd2> seems reasonable
15:36:56 <nshepperd2> % let bottom :: Int ~ Int => Int#; bottom = bottom in 4
15:36:57 <yahb> nshepperd2: 4
15:37:09 <boxscape> % let bottom :: () => Int#; bottom = bottom in 4
15:37:09 <yahb> boxscape: ; <interactive>:2:5: error: Recursive bindings for unlifted types aren't allowed: bottom = bottom
15:37:11 <boxscape> :(
15:37:34 <EvanR> "seems reasonable"
15:40:44 * hackage lingo 0.3.0.0 - File extension based programming language detection  https://hackage.haskell.org/package/lingo-0.3.0.0 (patrick_thomson)
15:41:09 <boxscape> hm now I'm wondering whether (Show a, Eq a) is one tuple argument or two arguments
15:41:18 <boxscape> probably two?
15:43:18 <boxscape> EvanR btw, I think I actually got the "can't use unboxed types with let bindings" from the STG paper, because you have to use case instead in STG for unboxed values
15:43:27 <boxscape> IIRC
15:44:13 <EvanR> so maybe it's a thing in core
15:44:31 <boxscape> possibly
15:51:02 <boxscape> % let bottom :: ((), ()) => Void#; bottom = bottom in 4 -- works
15:51:02 <yahb> boxscape: 4
15:51:03 <nshepperd2> looks like it is two arguments
15:51:30 <boxscape> nshepperd2 from what does it look like that?
15:51:57 <boxscape> from what I just pasted it looks like one tuple argument to me
15:52:06 <EvanR> oh, Void#... is that available. Sounds useful
15:52:14 <boxscape> % let bottom :: () => () => Void#; bottom = bottom in 4 -- because this doesn't works
15:52:14 <yahb> boxscape: ; <interactive>:8:5: error: Recursive bindings for unlifted types aren't allowed: bottom = bottom
15:52:34 <boxscape> EvanR not really sure what you would use it for but it's the simplest unboxed type I found
15:53:09 <nshepperd2> boxscape: some cunning testing with unsafeCoerce :)  https://zlkj.in:9000/uploads/d08a00e41d901f65/test.hs 
15:53:32 <EvanR> often you are told "unfortunately haskell has no truly uninhabited type"
15:53:51 <boxscape> nshepperd2 ah, fair enough :) I think actually the reason why there's a difference in my two versions is that the first one is two unit constraints, whereas the second one is two empty constraint lists
15:54:07 <boxscape> so () is even more overloaded than I thought
15:54:41 <boxscape> EvanR yeah but then you can still do undefined :: Void# so... hm
15:54:52 <EvanR> uhg
15:54:58 <nshepperd2> those are different? i figured ghc just had some special case code to elide () =>
15:55:10 <boxscape> nshepperd2 I suppose that's possible as well
15:59:12 <nshepperd2> undefined :: Void# is a bit different than Void though, in that you can never be 'given' a value of type Void# 
15:59:43 <boxscape> yeah, that's true
16:00:10 <nshepperd2> you get an exception when you try to create one, not when someone tries to use it
16:00:51 <dsal> Is there a thing in ghci that will spit out the definition of a thing?
16:02:15 <boxscape> :i will at least tell you where to find the definition
16:02:45 <nshepperd2> apparently :list will print out source code
16:03:11 <boxscape> % :list
16:03:11 <yahb> boxscape: Not stopped at a breakpoint; nothing to list
16:03:52 <boxscape> % f = 4
16:03:52 <yahb> boxscape: 
16:03:54 <boxscape> % :list f
16:03:55 <yahb> boxscape: cannot list source code for f: module interactive:Ghci6 is not interpreted
16:03:59 <boxscape> meh
16:04:42 <nshepperd2> i guess it won't work in yahb
16:04:50 <boxscape> unless we load in a file
16:05:00 <dsal> yeah, list doesn't quite work for me, but it's what I was asking for.
16:05:20 <boxscape> % :l LensSplice.hs
16:05:20 <yahb> boxscape: [1 of 1] Compiling LensSplice ( LensSplice.hs, interpreted ); LensSplice.hs:1:81: error:; Parse error: module header, import declaration; or top-level declaration expected.; |; 1 | module LensSplice where { import Control.Lens.TH; data Foo a = Foo { foo :: a}; makeLenses ''Foo }; | ^^^^^^^^^^^^^^^^; Failed,
16:05:29 <boxscape> fine, be that way
16:05:40 <nshepperd2> lol
16:06:53 <boxscape> dsal if you have a module loaded you should be able to write ":list <identifier>" and it should print the source code around the line it was defined
16:07:03 <boxscape> at least that's what it's doing for me
16:08:08 <dsal> It's giving me the "not interpreted" error.   AFAIK, the ghci I'm using is rather magic.
16:08:33 <boxscape> maybe it's loading a compiled version of the module or something like that?
16:09:31 <dsal> Yeah.  I'm not using a straight ghci, but a thing someone made that acts a lot like ghci.
16:09:41 <boxscape> hm, okay
16:18:12 <boxscape> uugh I don't like this
16:18:23 <boxscape> % undefined :: ((Show a => Eq a => Int) ~ ((Show a, Eq a) => Int)) => Int
16:18:23 <yahb> boxscape: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:18:1 in interactive:Ghci1
16:18:26 <boxscape> that compiles
16:18:38 <EvanR> nice
16:18:40 <boxscape> % undefined :: ((() => () => Int) ~ (((), ()) => Int)) => Int 
16:18:41 <yahb> boxscape: ; <interactive>:19:1: error:; * Couldn't match type `Int' with `(() :: Constraint, () :: Constraint) => Int' arising from an expression type signature; * In the expression: undefined :: ((() => () => Int) ~ (((), ()) => Int)) => Int; In an equation for `it': it = undefined :: ((() => () => Int) ~ (((), ()) => Int)) => Int
16:18:42 <boxscape> this doesn't
16:19:01 <EvanR> o_O
16:20:24 <boxscape> to be fair I had to enable -XImpredicativeTypes for this
16:20:28 <boxscape> so maybe it doesn't count
16:20:53 <EvanR> so wait... (Show a, Eq a) is syntactic sugar for Show a => Eq a => ? or other way around
16:21:22 <boxscape> I think the first one, judging by what nshepperd1 said about his unsafeCoerce experiments
16:21:32 <boxscape> or nshepperd2, rather
16:21:40 <EvanR> or "their" experiments :)
16:21:47 <boxscape> right
16:23:00 <EvanR> the other direction would be kind of weirdo
16:23:06 <EvanR> uncurrying
16:23:21 <EvanR> though might be more efficient in the end
16:26:28 <boxscape> the STG paper says that compilers usually implement uncurried versions much more efficiently, and doesn't include STG in that "usually", so if it's more efficient it at least shouldn't be much more efficient
16:27:24 <Cale> It's a constant factor, but it's a constant factor that can be pretty significant.
16:28:32 <boxscape> constant in the number of arguments that are curried?
16:29:11 <Cale> Haha, well, I suppose it's probably linear in the number of arguments
16:29:15 <boxscape> okay
16:29:25 <Cale> But there's typically a small maximum number that you actually handle
16:29:34 <boxscape> that's true
16:29:36 <Cale> and then larger numbers of arguments don't receive that optimisation
16:29:45 <boxscape> oh I misunderstood
16:29:47 <boxscape> still presumably true thouhg
16:45:36 <nshepperd2> so  (Show a, Eq a) => is syntactic sugar for Show a => Eq a =>
16:45:49 <boxscape> looks like it
16:46:59 <nshepperd2> but functions that accept multiple arguments *are* implemented in a curried way in ghc iirc
16:47:52 <nshepperd2> as in you put multiple arguments in registers / on stack, then enter the code pointer
16:48:41 <boxscape> nshepperd2 I'm not super familiar with the details but at least the STG *language* has syntax for applying multiple arguments at once, that being `f {x, y z}`
16:50:07 <boxscape> % () :: (((Ord a, Eq a), Show a) => ()) ~ ((Ord a, (Eq a, Show a)) => ()) => ()
16:50:07 <yahb> boxscape: ; <interactive>:21:7: error:; * Illegal qualified type: ((Ord a, Eq a), Show a) => (); GHC doesn't yet support impredicative polymorphism; * In an expression type signature: (((Ord a, Eq a), Show a) => ()) ~ ((Ord a, (Eq a, Show a)) => ()) => (); In the expression: () :: (((Ord a, Eq a), Show a) => ()) ~ ((Ord a, (Eq a, Show a)) => ()) => (); In an equation for `it': it = () ::
16:50:09 <boxscape> it's not associative :(
16:50:28 <boxscape> okay wait
16:50:38 <boxscape> % :set -XImpredicativeTypes
16:50:38 <yahb> boxscape: 
16:50:42 <boxscape> % () :: (((Ord a, Eq a), Show a) => ()) ~ ((Ord a, (Eq a, Show a)) => ()) => ()
16:50:42 <yahb> boxscape: ; <interactive>:23:7: error:; * Couldn't match type `Show a0' with `(Eq a0, Show a0)'; * In the ambiguity check for an expression type signature; To defer the ambiguity check to use sites, enable AllowAmbiguousTypes; In an expression type signature: (((Ord a, Eq a), Show a) => ()) ~ ((Ord a, (Eq a, Show a)) => ()) => (); In the expression: () :: (((Ord a, Eq a), Show a) => ()) 
16:50:46 <boxscape> it's not associative :(
16:50:52 <boxscape> wait I'm still not done
16:51:11 <boxscape> % :set -XAllowAmbiguousTypes
16:51:11 <yahb> boxscape: 
16:51:15 <boxscape> % () :: (((Ord a, Eq a), Show a) => ()) ~ ((Ord a, (Eq a, Show a)) => ()) => ()
16:51:15 <yahb> boxscape: ; <interactive>:25:7: error:; * Couldn't match type `Show a0' with `(Eq a0, Show a0)'; * In the ambiguity check for an expression type signature; In an expression type signature: (((Ord a, Eq a), Show a) => ()) ~ ((Ord a, (Eq a, Show a)) => ()) => (); In the expression: () :: (((Ord a, Eq a), Show a) => ()) ~ ((Ord a, (Eq a, Show a)) => ()) => ()
16:51:22 <boxscape> yeah, no, it really isn't associative
16:52:07 <nshepperd2> https://zlkj.in:9000/uploads/dc4d972b276a97ec/test.hs -- it works whether you pass multiple arguments or an unboxed tuple
16:52:22 <boxscape> interesting
16:52:35 <nshepperd2> (because an unboxed tuple is just... multiple arguments with a name)
16:53:00 <boxscape> okay
16:54:07 <nshepperd2> and yeah, I assume ~ on constraints is structural, so it can't be associative
16:54:07 <boxscape> hm, not sure how something like (Ord a, (Eq a, Show a)) => () gets desugared
16:54:51 <boxscape> hm, okay
16:55:10 <boxscape> % () :: ((Ord a, (Eq a, Show a)) => ()) ~ (Ord a => (Eq a, Show a) => ()) => ()
16:55:10 <yahb> boxscape: ; <interactive>:26:7: error:; * Couldn't match type `()' with `Show a0 => ()'; * In the ambiguity check for an expression type signature; In an expression type signature: ((Ord a, (Eq a, Show a)) => ()) ~ (Ord a => (Eq a, Show a) => ()) => (); In the expression: () :: ((Ord a, (Eq a, Show a)) => ()) ~ (Ord a => (Eq a, Show a) => ()) => ()
16:55:13 <boxscape> I would expect that to work at least
16:55:16 <nshepperd2> % :t show :: (f () ~ Show (), f a) => a -> String
16:55:16 <yahb> nshepperd2: Show a => a -> String
16:57:08 <nshepperd2> boxscape: ghci complains of something being impredicative when I try that O_O
16:57:22 <boxscape> nshepperd2 yeah I enabled -XImpredicativeTypes in yahb :P
16:57:55 <nshepperd2> I guess using ~ on types with constraints is no bueno
16:58:12 <boxscape> nshepperd2 giving a type signature to an existing type seems to use a different mechanism from ~, to some extent. defining `f :: ((), ()) => ()` and then asking `:t f` results in ()
16:58:15 <nshepperd2> that is, (a => b) ~ c is bad
16:58:50 <boxscape> yeah I guess I'll have to wait until the Quick look impredicativity proposal is implemented before I can complain about something related to that
16:59:10 <boxscape> s/existing type/existing term
16:59:48 <nshepperd2> which makes sense. i don't think you can instantiate type variables with constrainted things either
17:00:32 <boxscape> okay
17:04:25 <boxscape> (uh actually I should have been using `:t +v f`, then it shows the original type)
17:25:14 * hackage hw-rankselect-base 0.3.2.3 - Rank-select base  https://hackage.haskell.org/package/hw-rankselect-base-0.3.2.3 (haskellworks)
17:26:15 <dsal> I'm hilariously bad at math.  If I take the timestamp 1995-10-12 00:04:10.248 and truncate it to the nearest two seconds, I get 1982--11-21 12:02:05
17:27:46 <Axman6> =|
17:28:14 <dsal> It was a dumb error, but not surprising.
17:28:14 * hackage context-free-art 0.2.0.0 - Generate art from context-free grammars  https://hackage.haskell.org/package/context-free-art-0.2.0.0 (414owen)
17:30:26 <dsal> My tests are pretty brutal, though.  They're not letting me get away with anything.  :(
17:48:00 <d34df00d> Hi!
17:48:26 <d34df00d> My brain is slow towards the evening, but can I easily avoid impredicativity here?
17:48:38 <d34df00d> convert :: (MonadError String m, MonadIO m, Show e) => (forall m'. (MonadError e m', MonadIO m') => m' a) -> m a
17:50:16 <jle`> d34df00d: you can just move the forall m' to the front, right?
17:50:25 <d34df00d> jle`: nope.
17:50:45 <d34df00d> At least I don't think so.
17:51:08 <d34df00d> That'd change the semantics — now the calling code has to specify m'. Likely explicitly, because how the compiler would infer it?
17:52:15 <d34df00d> Ah, dammit, I'm an idiot.
17:52:24 <d34df00d> It was complaining not about signature, but about `convert = undefined`
17:52:37 <d34df00d> It was trying to instantiate a in `undefined :: forall a. a` with that mess.
17:52:40 <d34df00d> Got it.
17:52:53 <d34df00d> `convert = convert` works.
17:52:57 <jle`> ah yeah, undefined is weird here :)
17:53:01 <jle`> you can also do convert _ = undefined
17:53:09 <jle`> (that's what i do)
17:57:44 * hackage arbor-monad-metric-datadog 1.1.1 - Metric library backend for datadog.  https://hackage.haskell.org/package/arbor-monad-metric-datadog-1.1.1 (arbornetworks)
17:59:53 <d34df00d> Yeah, that also works!
18:25:24 <Jonathan8> I have a question about private dependencies with cabal.
18:27:11 <Jonathan8> As I develop an application I often develop a library allow with it.  Thus far I have just made said libraries internal-libraries but I find myself wanting to use those same libraries within other projects.
18:28:03 <Jonathan8> Is it possible to somehow setup a local library on my computer for use--without having to publish it to hackage.
18:28:11 <Jonathan8> Is it possible to somehow setup a local library on my computer for use--without having to publish it to hackage?
18:30:14 <Jonathan8> Google has been no help, and I have not found anything in the Cabal User Guide
18:31:51 <c_wraith> Jonathan8: see https://www.haskell.org/cabal/users-guide/nix-local-build.html#developing-multiple-packages
18:33:26 <Jonathan8> Thanks!
18:37:19 <Jonathan8> c_wraith: That is exactly what I was looking for thanks.  Not sure why Google didn't get me to it.  I vaguely remember seeing that a while ago but when I was still very new to Haskell and misunderstood what it was for.
18:37:46 <c_wraith> Yeah, I was only able to find it by searching for "cabal.project" because I remembered what the config file was named.
18:38:23 <Jonathan8> lol
18:39:42 <Welkin> Jonathan8: what happened to the first 7?
18:40:04 <Jonathan8> The first 7 Jonathan's?
18:40:16 <c_wraith> probably eaten.
18:40:50 <MarcelineVQ> Same thing that happened to the first 4 johnnys
18:41:21 <c_wraith> They're all fine and programmed to find and kill the last one?
18:41:36 <Welkin> they became toasters
18:42:14 <c_wraith> I'm still unsure of the mechanism by which lightning causes general artificial intelligence, but hey - lightning is mysterious stuff.
18:42:35 <Welkin> it flips bits in just the right way
18:43:01 <Welkin> before it causes all of the capacitors to explode or melt
18:43:19 <MarcelineVQ> The lightning spirit is myschevious, it is known.
18:43:36 <c_wraith> I'd expect lightning to blow all the diodes, too.  Remember the words of a wise man:  "Any diode can be light-emitting.  Once."
18:44:13 <Welkin> lightning is so hot it could melt the whole board
18:45:20 <MarcelineVQ> And so cool it'll make your hair stand up
18:45:47 <MarcelineVQ> c_wraith: Electronics are powered by the blue smoke of spirits that they carefully harness in factories in arcane and wicked ceremony, you can let the smoke out but once.
18:47:55 <c_wraith> so...  electronics factories are really facilities for the mass enslavement of blue smoke spirits?
18:48:03 <MarcelineVQ> Of course.
18:49:34 <MarcelineVQ> The spirits are goaded by the angry pixies that live in your wallcopper but too many pixies will set the spirits free, capricious as they are.
18:52:00 <Welkin> factories are by default made for mass enslavement
19:04:05 <Greenman33> Hi. I'm trying to learn about the concept of functional programming and a common thing I see is:
19:04:18 <Greenman33> "Functions have side effects"
19:04:25 <Greenman33> What does that mean?
19:06:41 <MarcelineVQ> generally it refers to a function that does more to affect the world than just return a result, like print to the console or 
19:06:50 <MarcelineVQ> or like, don't wait around..
19:11:03 <Welkin> functions are by definition pure
19:11:19 <Welkin> what you know as "functions" in many programming languages are actually procedures, not functions
19:11:27 <rotaerk> the person's gone
19:11:30 <MarcelineVQ> Welkin: he left after 2 mins
19:11:33 <Welkin> fuck 'em
19:11:52 <rotaerk> explaining it for your own pleasure then? :P
19:11:58 <Welkin> what is with people here today?
19:12:05 <Welkin> joining and leaving after asking a question
19:12:21 <rotaerk> well, we're defective if we don't respond as quickly as google
19:12:35 <MarcelineVQ> That's not an especially uncommon occurence on irc, idk why people act like its a new behvaiour too.
19:12:50 <ysangkok> people might change because of chatting on other platforms :P
19:12:56 <Welkin> they think it's slack or something?
19:13:16 <MarcelineVQ> People been flyby questioning since irc started
19:13:31 <ysangkok> one could change kiwiirc to show fake "Writing..." bubbles on random people in the room :D hahaha
19:13:43 <ysangkok> or just generally add more blinkenlights :P
19:14:36 <ysangkok> i don't have JOIN/LEAVE notifications on, but i am speculating that many of the people who leave early are on kiwiirc
19:17:56 <monochrom> HIgh frequency spoon feeding.
19:19:03 <LCRERGO> Hi, does anyone know what is the name of parsec lib in Debian?
19:19:19 <LCRERGO> the apt package I mean
19:23:04 <monochrom> It probably comes with GHC and is not a separate package on Debian.
19:31:08 <NemesisD> i'm trying to write a constraint (HasMember x xs) such that there's a valid instance if x is a member of the type-level list xs. how would i write this? as a typeclass with no members? or can this be done as a type family?
19:32:30 <c_wraith> a type family is the most common approach
19:32:40 <c_wraith> a closed type family, specifically
19:33:03 <agohoth> why is haskell better than lisp forth or pharo smalltalk?
19:33:24 <c_wraith> "better" is a matter of opinion.  I prefer it over those because it has a useful type system.
19:33:39 <c_wraith> that is, the type system can actually guide code-generation at compile time.
19:33:40 <agohoth> and how do haskell apps beat say a combination of tcl and postgresql
19:33:42 <Welkin> because your mom said so
19:33:57 <agohoth> cant a well programmed psotgresql called from a bit of tcl be amazing?
19:34:01 <NemesisD> c_wraith: i'm having trouble with what the instances would look like, `type instance IsMember x xs where IsMember x (x ': xs) = ???`
19:34:08 <agohoth> Im not being a joker Im serious
19:34:08 <c_wraith> NemesisD: http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-TypeLits.html#t:TypeError  This would be your base case
19:34:23 <agohoth> I want to make a startup and dont program well yet
19:35:11 <agohoth> I read that good programmers worry about data structures not algo
19:35:29 <Welkin> those are not even remotely the same thing
19:35:32 <agohoth> and though hmm smart tables and a bit of dumb code as rob piek says so why not simple alng liek tcla nd smalrt tables in psotgrersql
19:35:47 <Welkin> if you want to "make a startup" then pay someone to built your crap
19:35:53 <agohoth> no way
19:35:57 <agohoth> I know mad linux
19:35:57 <c_wraith> In that position, I'd try to find someone who already is an experienced programmer and shares your vision to make those technical decisions, and make them a co-founder.
19:36:05 <agohoth> just need to learn bit of coding
19:36:23 <agohoth> no way most coders I dealt with are java morons
19:36:28 <agohoth> or node morons
19:36:43 <NemesisD> c_wraith: would i literally return a type-level bool?
19:36:58 <agohoth> I only trust people who like lisp forth haskell pharo smalltalk  and maybe I repsec ADA and C coders
19:37:00 <NemesisD> or maybe just a () and then use that TypeError case for a nice error message
19:37:16 <c_wraith> NemesisD: You could, using an equality constraint.  But () and TypeError is a bit easier to understand when something goes wrong.
19:44:57 <s0da> what are the compelling advanages of haskell?
19:44:59 <NemesisD> c_wraith: that's quite slick. thank you! one last thing, my error message would be much nicer if i could get the `xs` at the head of the type family into the error message but it isn't in scope: https://gist.github.com/MichaelXavier/b8ff164a7e1271c5d33cafe9dddccc16
19:45:32 <c_wraith> You could create a helper type family that passes the original xs down the line to include it in the error message, I guess?
19:47:19 <c_wraith> It's basically the exact same solution you'd use at the value level to solve that.
19:47:36 <c_wraith> except you can't define the helper locally, it has to be at the module scope.
19:49:15 <NemesisD> c_wraith: hell yeah, that worked! thank you! https://gist.github.com/MichaelXavier/b8ff164a7e1271c5d33cafe9dddccc16
19:50:20 <c_wraith> nice.
19:50:26 <NemesisD> s0da: advanced, expressive type system, optimizing compiler, easy and much safer than average concurrency tools, potentially good performance depending on what you're comparing with
19:51:25 <EvanR> s0da: many standard libraries for haskell greatly surprised me by actually making sense
19:51:38 <EvanR> that's all i got for right now
19:51:58 <c_wraith> NemesisD: while I know that things like that are possible, I've never actually done them.  So it's always nice to actually see code instead of just going "I know this can be done".
19:53:02 <NemesisD> c_wraith: i knew it could be done but all the examples i could think of were much more complicated. also its sort of mind bending that i can just return a () when the kind of the type family is a constraint? like does the compiler know () means "everything is okay, this constraint passes"?
19:53:24 <c_wraith> () is just the empty constraint.
19:55:04 <c_wraith> It's a slight special case that follows from constraints being comma-separated lists inside of () for one or more constraints. (With the parens optional with a single constraint)
19:55:43 <s0da> so its like java? c++? *ducks
19:55:54 <s0da> *ducks, just in case*
19:57:27 <EvanR> haskell has some similarities to java in select characteristics, like performance, the weighty runtime in the background, garbage collection, but that's about where the similarities end
19:57:46 <EvanR> i'm going out on a limb to say haskell has nothing to do with C++
19:58:12 <NemesisD> holy shit, so constraints are type-level tuples?
19:58:38 <ski> nope
19:58:39 <dmwit> er, no?
19:58:46 <EvanR> we established earlier (C1,C2) => is a sugar for C1 => C2 =>...
19:58:57 <dmwit> For one thing, order doesn't matter.
19:58:58 <ski> (more similar to tuple types, perhaps)
19:59:28 <dmwit> (Ord a, Show a) and (Show a, Ord a) mean the same thing, as far as you can tell from the surface language.
19:59:52 <dmwit> (By comparison, the tuples '(x, y) and '(y, x) are observably different.)
20:00:40 <ski> (also for the tuple types  (T,U)  and  (U,T)  .. those are different)
20:02:10 <Welkin> ew for U and T
20:02:21 <Welkin> looks like oops generics
20:02:46 <Welkin> oops! all berries captain crunch is so much better
20:03:04 <monochrom> Dependent Haskell is like C++ because both have type-level naturals for type parameters. >:)
20:03:22 <Welkin> I haven't used dependent haskell
20:03:28 <Welkin> is that actually happening?
20:03:33 <Welkin> and linear types?
20:04:37 <Welkin> I didn't even check what's in 8.8 yet
20:04:50 <Welkin> I recall inear haskell was planned for 8.10
20:04:51 <monochrom> Don't worry Dependent Haskell is stll in the far future.
20:05:00 <Welkin> linear*
20:05:01 <c_wraith> Dependent Haskell is like 2022 at the soonest, I'd say.
20:05:13 <monochrom> But when it's finally done you can bet you can do all the crazy things crazy C++ people do.
20:05:44 <monochrom> Such as factorization algorithms at the type level that take O(1) time at the term level.
20:05:58 <c_wraith> I'm just looking forward to printf with the format string bound with pi.
20:06:05 <c_wraith> I don't care about anything else.
20:06:11 <Welkin> what kind of pi?
20:06:18 <c_wraith> french silk
20:06:23 <Welkin> peach cobbler
20:06:29 <Welkin> blackberry
20:06:49 <Welkin> shepherd's pie
20:07:19 <monochrom> Properly made shepherd's pi contains lambda.
20:08:15 <s0da> cool. thx ppl
20:08:27 <s0da> im a programmer but only c++ and BASIC
20:08:31 <s0da> for now...
20:08:45 <s0da> but i wanna learn whatever is best
20:09:07 <monochrom> BASIC is like Perl.  They use sigils.
20:09:27 <maerwald> s0da: learn software engineering, it's the best
20:09:33 <c_wraith> s0da: the best thing about Haskell is that you basically have to learn to program all over again.  It's legitimately hard to learn for a while, because you're actually learning new things.
20:18:44 * hackage hs2ats 0.5.0.1 - Create ATS types from Haskell types  https://hackage.haskell.org/package/hs2ats-0.5.0.1 (vmchale)
20:21:14 * hackage language-ats 1.7.5.0 - Parser and pretty-printer for ATS.  https://hackage.haskell.org/package/language-ats-1.7.5.0 (vmchale)
20:21:19 <s0da> maerwald: Ive been doing EXACTLY that, in my freetime
20:21:29 <s0da> learning the basic fundamental, and concepts
20:22:17 <s0da> maerwald: are there any specific resources that you could point me to, that are the "best starting places" for a noob? (lets pretend i was a TOTAL noob for a sec.)
20:24:31 <Welkin> first you need to learn category theory and abstract algebra
20:24:35 <Welkin> then you can write hello world
20:24:55 <c_wraith> Oh, come on.  It's not funny when someone might plausibly believe it.
20:25:18 <Welkin> it may require sacrificing a goat, too
20:25:35 <s0da> Welkin: lol :)
20:25:36 <suzu> everyone at my work believes this
20:25:44 * hackage th-utilities 0.2.3.1 - Collection of useful functions for use with Template Haskell  https://hackage.haskell.org/package/th-utilities-0.2.3.1 (MichaelSloan)
20:25:45 <suzu> its hard to change their minds
20:25:49 <shachaf> It's not funny anyway.
20:25:54 <suzu> nah its pretty funny
20:26:00 <s0da> Welkin: ok. i dont need to start at the VERY very beginning.
20:26:26 <Axman6> How's your lambda calculus?
20:26:35 <s0da> just whatever "fundamental precepts" that might not have been covered in my college course (crappy community college)
20:26:36 <Axman6> (Only semi-serious)
20:27:00 <Welkin> You'll need these (()(()(()(()()(()((()())()))()))))
20:27:33 <Axman6> I hope those are properly nested Welkin *glares*
20:27:34 <Welkin> s0da: Programming in Haskell by Graham Hutton
20:28:23 <s0da> when i say fundamenal precepts imtalking stuff like UML diagrams, the concept of a "flowchart", XP, Agile, design patterns, stuff like that. basically industry-standard "Standard Operating Procedures", that me, as a semi-self-taught amateur might not know or may have skipped over, totally "unawares"...
20:28:29 <Welkin> don't waste your time with Learn You a Haskell (it's outdated and not good for learning)
20:28:44 <Welkin> who the hell learns UML, agile, and other nonsense in shcool?
20:28:45 <Axman6> s0da: I've literally never used any of those since graduating
20:28:56 <tabemann> just so you know, those "standard operating procedures" are a lot of shit
20:29:10 <monochrom> flowchart is OK.
20:29:14 <s0da> those things i listed are ALL things that I LEARNED on MY OWN. I only learned C++ in college
20:29:27 <tabemann> only on one occasion have I used a UML diagram, and then no one realy cared
20:29:32 <Welkin> well, you don't need any of those for haskell
20:29:41 <tabemann> I've never needed a flowchart
20:29:44 <monochrom> I thought UML diagrams were not OK but then lens uses them so they're OK again. >:)
20:29:45 <tabemann> I've never done SP
20:29:48 <tabemann> *XP
20:29:53 <c_wraith> If you want a practical skill for business programming - the single most valuable skill would be "managing meetings so that they don't waste time"
20:29:58 <Welkin> you just need a sharp text editor (emacs) and a web browser to view documentation
20:30:08 <tabemann> whenever companies I've worked at have said they were doing agile they were only pretending
20:30:11 <Welkin> maybe a pencil and paper to practice type unification
20:30:19 <Welkin> tabemann: haha, agile means nothing
20:30:19 <tabemann> design patterns are a load of shit
20:30:35 <Welkin> agile is "do whatever gets it done"
20:30:39 <s0da> i dont care about "meeting industry standards" so much as i care about stability, preventing errors/glitches, robustness, scalability, etc.
20:30:42 <Axman6> monochrom++
20:30:49 <tabemann> agile means "we have a meeting every day - maybe"
20:30:56 <monochrom> XP is out of favour. Agile has become a blanket term.
20:30:56 <Welkin> but then people say "but this is what the agile book says we need to do, let's plan this out"
20:31:05 <Axman6> and no one sits because chairs are expensive
20:31:05 <s0da> basically pretend for a second i was deisgning mission-critical systems for the gubberment or sumthing
20:31:26 <tabemann> you wouldn't do any of that shit
20:31:40 <monochrom> IMO the most important thing is CS --- Common Sense.  People lack it.
20:31:44 <Welkin> s0da: the compiler is the only tool you need
20:31:47 <Welkin> it will guide you
20:31:51 <tabemann> I developed such stuff at one point - I did none of that
20:31:53 <Welkin> use the ghc, luke!
20:31:58 <s0da> monochrom: lol. true.
20:32:03 <Axman6> One of the authors of the Agile Manifesto gave a good talk at Yow! about how everyone does Agile wrong. "If you're still doing SCRUM after two weeks, you're doing it wrong"
20:32:12 <Welkin> hahahaha
20:32:17 <Welkin> my company is doing scrum
20:32:19 <s0da> Welkin: lol
20:32:27 <Welkin> we have a dedicated person as the scrum authority who teaches us
20:32:35 <tabemann> ugh
20:32:37 <Welkin> and then people fight about who is doing scrum right
20:32:41 <tabemann> ugh
20:32:52 <Axman6> mission critical and government are rarely intersection terms in my experience
20:33:01 <tabemann> every methodology is a load of shit
20:33:02 <Axman6> intersecting*
20:33:03 <monochrom> Everyone is born to have CS.  Most people gradually lose it as they grow up because they keep cutting corners and they keep rationalizing cutting corners.
20:33:04 <Welkin> we have a new scrum master every sprint
20:33:13 <tabemann> there is no good methodology
20:33:18 <LysergicDreams> Anyone using the latest servant-auth-cookie package? Not quite sure how to specify an AuthProtected route w/ a QueryParam
20:33:25 <Welkin> my methodology is "get shit done"
20:33:26 <Welkin> hahaha
20:33:37 <Axman6> LysergicDreams: wehat have you tried?
20:33:38 <Welkin> I love what my teammate says "just say yes"
20:33:45 <s0da> "Xtreme Programming" is basically a misnomer. it's actually one of the most stable, reliable, "safe" ways of programming. especially i comparison to Agile (according to the C2C website, he meain website for XP Extreme Programming)
20:33:47 <Welkin> and then do whatever you nee to do
20:33:48 <Welkin> need*
20:33:52 <s0da> *in
20:34:03 <s0da> *the main
20:34:13 <Axman6> XP and "Agile" are not distinct concepts, they're orthogonal
20:34:17 <tabemann> my methodology is try to fix the bugs that the testers tell me about, take a stab at it, then send it back to the testers regardless of whether it works or not
20:34:35 <s0da> Axman6: i know
20:34:48 <Welkin> I've learned that I have to sometimes do things badly or do the wrong thing because politics
20:34:49 <tabemann> if something really seems intractable, then I just put it on ice and hope no one notices
20:35:00 <s0da> Axman6: i meant "NON-XP Agile"
20:35:06 <tabemann> I hate it when testers make mistakes
20:35:25 <tabemann> because I have to then go to them and explain how I'm actually right and it is they who fucked up
20:35:28 <s0da> Welkin: thats called "bully" bosses
20:35:42 <Axman6> My experience with pair programming has been very positive, would highly recommend it
20:35:42 <Welkin> s0da: it's not my boss though
20:35:55 <s0da> Welkin: abusive, incopetent, "pointy-haired" bosses. who couldnt SPELL computer
20:35:59 <Welkin> it's other stakeholders I don't interact with
20:36:07 <Axman6> havine two brains to catch errors, while only one has to remember how to type is excellent
20:36:21 <Axman6> clearly I'm not very good at that part
20:36:31 <Welkin> I've only tried pair programming once
20:36:34 * Axman6 thanks GHC for not putting up with his shit typing
20:36:34 <Welkin> I fuckin hated it
20:36:39 <tabemann> my problem at my company is that there's arbitrary deadlines, and arbitrary amounts of work expected for those deadlines, regardless of whether it is possible to meet them
20:36:46 <s0da> Welkin: thats one of the "principles" of XP
20:37:01 <Welkin> no personal space, having someone complain about how you wrote something every 5 minutes
20:37:21 <s0da> Welkin: lol. so theres no compelling advantages to pair programming in your experience?
20:37:26 <s0da> serious question
20:37:30 <Axman6> that's not how it's supposed to work... you were definitely doing it wrong
20:37:54 <Welkin> I've only tried it once
20:38:04 <tabemann> I'm glad I've never had to really do pair programming, because whenever I've had to share a cube with someone it always turns out frustrating
20:38:08 <Welkin> I'm used to working alone then sitting together for code reviews
20:38:30 <Axman6> I've mostly done it via VC
20:38:33 <monochrom> Hey tabemann I had slides demo-ing Bayes's theorem by setting up a scenerio "you are veteran, probability 0.001 you have a bug; tester is fresh grad (they all are), probability 0.01 they write a wrong test. What is P(bug is yours | failed a test case)?"
20:39:14 <Axman6> 0%
20:39:19 <Welkin> so wait, scrum is only meant to be used for 2 weeks?
20:39:21 <Welkin> how is that?
20:39:23 <Axman6> the test is always wrong
20:39:32 * s0da kicks back, relaxes and drinks himself, as he lurks
20:39:33 <Welkin> is there even a definition for scrum?
20:39:48 <Axman6> Welkin: because agile means changing things to find what works for your team, and continuing to change over time
20:39:52 <Welkin> yes
20:40:15 <tabemann> monochrom: I also encounter problems where testers repeatedly put failures into preexisting tickets, oftentimes the wrong tickets
20:40:27 <tabemann> so they keep on reopening tickets time and time again
20:40:31 <Welkin> also, god damn, standups that last 20 minutes where you say your thing for 10 seconds then stand there doing nothing for 19 minutes and 50 seconds is really annoying every day
20:40:50 <monochrom> Such fresh grads. So much green.
20:41:14 <s0da> so the concensus seems to be: DON'T overly focus upon Software "Engineering" or Software "Architecture". and a little bit of "quick and dirty coding" and "cowboy coding" is ok? or no? (not trying to be a troll here. srs ques.)
20:41:16 <tabemann> and I've had my boss yell at said testers to stop it, and they keep on doing it
20:41:43 <Welkin> s0da: casey muratori says it best. Exploratory programming. Do the dumbest, simplest thing that works, and go from there.
20:41:48 <Welkin> so yes, just get it working
20:41:52 <maerwald> s0da: you should only focus on software engineering =)
20:41:55 <Welkin> who cares how you get to the end result
20:42:24 <s0da> maerwald: so Software Engineering is Prime Directive? or no?
20:42:45 <tabemann> testing is necessary; it's just that oftentimes testers do things wrong
20:42:52 <tabemann> code reviews are a good thing
20:42:58 <monochrom> Do you expect there is only one single answer that fits all scenerios and contexts?
20:43:04 <Welkin> but not if they include formatting details
20:43:04 <s0da> monochrom: NO!
20:43:10 <monochrom> There you go.
20:43:12 <Welkin> formatting should be handled by an autoformatter tool
20:43:12 <tabemann> but there is no blanket one size fits all solution
20:43:14 * hackage store 0.6.0 - Fast binary serialization  https://hackage.haskell.org/package/store-0.6.0 (MichaelSloan)
20:43:28 <Axman6> Haskell is a fantastic language for that sort of programming - sum types mean you can enumerate all the possibilities you can think of, and add more as they arise. you can smash out something which gets the job done quite quickly with high confidence it actually does get it right
20:43:29 <monochrom> Every context requires its own balance between "deliver it now" and "future-proof".
20:43:32 <LysergicDreams> Axman6: I seem to be getting stuck when I make the handler I pass to cookied' take my AuthToken(that is stored in the cookie) as a parameter. E.g., this is fine: http://sleepanarchy.com/p/zMRsYG but parameterized inner route breaks: http://sleepanarchy.com/p/f1YJJT I'm guessing I need to pull some value from the AuthProtect combinator?
20:43:59 <Welkin> auth and servant are a pain
20:44:08 <monochrom> And in most contexts you can't even know the perfect balance point so you just guessetimate and do what you can.
20:44:14 * hackage store-streaming 0.2.0.0, store-core 0.4.4.1 (MichaelSloan): https://qbin.io/missed-aging-9xfx
20:44:16 <LysergicDreams> I think if I can get that working properly, I'd be able to figure out additional params fine
20:44:26 <tabemann> as mentioned coding standards should not include formatting rules but rather an autoformatter should handle that
20:44:39 <tabemann> UML is a lot of shit
20:44:45 <s0da> So, in theory... If I am writing code, the TEST-first/Goal-Achievement-Oriented (as outlined in XP oficial sources) philosophy is definitely Good in most cases?
20:44:49 <tabemann> most methodologies are loads of shit
20:45:10 <maerwald> s0da: most people focus on tools, languages and other toy stuff. Those are things that come and go. Software engineering you apply to everything, all the time. Some languages can teach you useful *views* on software engineering 
20:45:14 <Welkin> you need an AuthContext
20:45:14 <tabemann> I've never worked in a test-first environment myself
20:45:19 <Welkin> nd an AuthHandler
20:46:05 <s0da> maerwald: EXACTLY. which brings me back to the question I asked you earlier: which specific resources are best for a noob/semi-noob WRT Software Engineering/Architecture?
20:46:07 <Welkin> software development is a means to an end!
20:46:15 <s0da> links?
20:46:26 <Welkin> the whole reason you build something is to ship it and have people use it as a product or tool
20:46:36 <Welkin> who cares how you get there
20:46:41 <tabemann> ^
20:46:42 <monochrom> However history seems to suggest that most programs that people thought were "one-shot thing, won't use or extend in the future" turned out to be extended and used again and again for the next 3 decades.
20:46:43 <Axman6> s0da: if you broaden to ignore the test first part - generally when writng Haskell I'll start with the types I need to work on, then the tyopes of the functions on those types, and then fill in the blanks. data MyWidget = MyWidget Thing Doodad; updateWidget :: MyWidget -> Either Error -> MyWidget; updateWidget = undefined
20:46:45 <Welkin> but a lot of people get caught in the weeds arguing about pointless crap
20:47:00 <s0da> Welkin: it matters cuz it might do who knows what if you dont bugtest sufficiently
20:47:18 <Welkin> you can never have 100% bug-free software
20:47:30 <Welkin> the erlang phiosophy is that failures are inevitable, and they are
20:47:32 <tabemann> I myself would say that it is a good idea to try to future-proof, but don't do so at the expense of shipping in reasonable time
20:47:37 <Axman6> types >>> tests, tests only make up for what you can put into types and have the compiler verify for you statically
20:47:40 <Welkin> your type system cannot stop network failurres, for example
20:47:42 <tabemann> always assume the code may fail
20:47:47 <Welkin> nor can your tests
20:47:55 <s0da> what about buffer overflows? BSODS? rm -f? okay that last one is a joke
20:47:57 <tabemann> always assume that your tests may be wrong
20:48:10 <Axman6> Welkin: BUT I HAVE 100% TEST COVERAGE LALALALA I'M NOT LISTENING
20:48:15 <LysergicDreams> Welkin: I have both, provided by the pkg & wired into my server
20:48:43 <Axman6> LysergicDreams: There are some types missing from those snippets, it's hard to follow what's going on
20:48:45 <Welkin> LysergicDreams: using serveWithContext?
20:48:57 <tabemann> as mentioned, tests are created by humans too, and oftentimes it's less experienced humans than the developers
20:49:09 <Welkin> ask in #servant-haskell
20:49:43 <monochrom> The other angle is that you will usually have partners, so this limits how quirky you can be because somone else has to understand you and work with you.
20:49:53 * s0da searches online with his greasy sausage fingers...
20:50:04 <Welkin> monochrom: and the average developer pulls the bar pretty damn low
20:50:11 <tabemann> don't try to be too clever in your code
20:50:16 <Welkin> they can write entry level java
20:50:20 <maerwald> s0da: IMO, to understand software engingeering there are 2 domains that are useful to focus on, because they have specific pressure to be better than what you normally encounter in industry: safety-critical systems and security-critical systems.
20:50:43 <s0da> EXACTLY! 
20:50:58 <maerwald> These are also the domains where industry has pressure to develop methodologies, tools, conduct research.
20:51:03 <Welkin> they two best languages you can learn to get a strong grasp on good software engineering practices are haskell and erlang (or elixir)
20:51:13 <tabemann> but if you're working on some random web-app all you really need to know is how to securely handle password entry
20:51:17 <Welkin> Elm too, of course, as a replacement for haskell potentially
20:51:19 <s0da> maerwald: This is is the jist of what im getting at. following established best practices from military/government/big-business/hospital/etc.
20:51:27 <LysergicDreams> Axman6: Well here's the original when I was just using Tokens in headers instead of a package: https://github.com/Southern-Exposure-Seed-Exchange/southernexposure.com/blob/master/server/src/Routes/Customers.hs#L476-L481
20:51:42 <maerwald> s0da: e.g. an overly long introduction of why you should use parser combinators is reading all the papers from http://langsec.org/
20:52:22 <Welkin> tabemann makes a good poing that there is specific domain knowledge you need to know
20:52:27 <Welkin> that matter a lot too
20:52:30 <Welkin> matters*
20:53:14 <maerwald> s0da: interestingly, these emerged first in haskell (or became popular here first), but have implementations even in C now
20:53:22 <s0da> I'd like to learn the bare minimum necessary, in terms of First Principles, for a noob to get up and running. (following established best practices from military/government/big-business/hospitals/police/etc.)
20:53:54 <tabemann> learn how to program effectively in haskell on one hand and erlang on the other
20:53:59 <s0da> where its life-or-death or BY-LAW mandatory to be secure, etc
20:54:01 <tabemann> that in itself will teach you a lot
20:54:20 <LysergicDreams> Axman6: The cookied' function is supposed to transform my (AuthToken -> App MyAccountDetails) into something like (ExtendedPayloadWrapper AuthToken -> App (Cookied MyAccountDetails)): https://hackage.haskell.org/package/servant-auth-cookie-0.6.0.3/docs/Servant-Server-Experimental-Auth-Cookie.html#v:cookied
20:54:32 <tabemann> s0da: look at DO-17B
20:54:41 <s0da> so maerwald and tabemann: it looks like i have 2 ppl in agreement here...
20:54:48 <s0da> agreement that...
20:54:50 <tabemann> that's the rules used by the FAA for avionics software
20:55:05 <s0da> haskell and erlang are the most secure languages?
20:55:08 <tabemann> *DO-178B
20:55:15 <Welkin> secure?
20:55:24 <Welkin> they are the most resilient to failure
20:55:27 <maerwald> s0da: so the interesting takeaway is: parser combinators were kinda "natural" to haskell, but are not specific to haskell
20:55:28 <s0da> in terms of preventing accidental bugs? in terms of accidental security exploits?
20:55:29 <tabemann> you can write insecure code in haskell or erlang for sure
20:55:44 <Welkin> they teach you how to write good software
20:55:54 <tabemann> but haskell and erlang lends themselves best to writing good code by default
20:56:12 <s0da> tabemann: THAT is what I was looking for.
20:56:19 <s0da> thk u!
20:56:41 <s0da> can i dl haskell compiler/etc fro my default repository in LinuxMint?
20:56:48 <s0da> from*
20:56:52 <c_wraith> that's a debian derivative, right?
20:56:52 <Welkin> get it from the website instead
20:56:53 <tabemann> don't do that
20:56:55 <Welkin> use ghcup
20:56:58 <tabemann> get it from stackage
20:57:04 <maerwald> s0da: https://www.haskell.org/ghcup/
20:57:06 <s0da> what is ghcup?
20:57:08 <Welkin> https://www.haskell.org/ghcup/
20:57:12 <Welkin> it's like rustup
20:57:20 <s0da> i dot know what rustup is either
20:57:20 <Welkin> it's a way to easily get haskell installed and update it
20:57:29 <Welkin> and have the latest version
20:57:31 <c_wraith> debian packages ghc very poorly.  You should avoid its package.
20:57:35 <Welkin> your package manager will be very outdated
20:57:37 <Mrbuck> haskellup idea from restup or viceversa?
20:57:46 <c_wraith> rustup was first
20:57:55 <maerwald> there's also a ppa from hvr you can use 
20:57:55 <tabemann> how does ghcup compare to stackage?
20:58:02 <maerwald> tabemann: it doesn't
20:58:09 <s0da> is rustup the name of haskell website's PPA repository or something?
20:58:20 <Welkin> no
20:58:21 <monochrom> rustup is for rust.
20:58:23 <tabemann> s0da: by its name, I presume rustup is an installer for rust
20:58:29 <Welkin> it's a tool for installing rust, the programming language
20:58:34 <maerwald> s0da: https://launchpad.net/~hvr/+archive/ubuntu/ghc alternative
20:58:41 <s0da> i dont know what rust is either, but i am gradually learning here...
20:58:56 * s0da clicks links
20:59:05 <tabemann> rust is a very different sort of language from haskell, it's kinda meant to be a better C++
20:59:11 <Welkin> rust is a replacement for c++, but with a powerful type system to track memory management
20:59:20 <Mrbuck> tabemann: is it better ?
20:59:27 <tabemann> I've never tried rust
20:59:32 <maerwald> Mrbuck: still
20:59:36 <maerwald> but might not be in the future
20:59:39 <s0da> Welkin: in WHAT ways specifically? what are the greatest improvements over c++?
20:59:40 <maerwald> because of feature creep
20:59:50 <Welkin> s0da: no memory issues
20:59:58 <Mrbuck> maerwald:  added so many features?
21:00:09 <tabemann> memory management in C++ is difficult to get right
21:00:26 <c_wraith> I'd say that history suggests "impossible" is a better description than "difficult"
21:00:31 <s0da> Welkin: when u say memory issues, do you primarily mean exploitable buffer overflows? (sry for being a noob)
21:00:33 <tabemann> Rust is meant to be similar to C++, but designed to get memory management correct right out of the box
21:01:07 <tabemann> s0da: not just that, but things like memory leaks too
21:01:16 <tabemann> or double frees as well
21:01:22 <Welkin> also, state mutation bugs
21:01:28 <LysergicDreams> Axman6: Well, that was enough talking about my problem to help me figure it out - thanks :P
21:01:31 <Welkin> which account for 99% of bugs in my experience
21:01:37 <s0da> are memory leaks just an annoyance, or are they also an exploit/vector?
21:01:41 <Welkin> it's imutable by default, like haskell
21:02:03 <Welkin> s0da: they are a huge security risk potentially too
21:02:14 <tabemann> if the attacker intentionally triggers memory leakage
21:02:16 <maerwald> s0da: according to gregkh, *any* bug can be a potential security bug :)
21:02:28 <tabemann> and explodes the memory used by the process
21:02:30 <maerwald> which is why the kernel doesn't distinguish between "bug" and "security bug"
21:03:16 <s0da> how about in terms of performance? do mem leaks cause a noticable slowdown/waste of cpu cycles/RAM?
21:03:29 <tabemann> s0da: if they end up using swap they sure do
21:03:38 <Welkin> well it will eventually cause the program to crash/get killed by the OS
21:03:51 <Welkin> and piss off the user
21:04:02 <maerwald> Welkin: if you are using earlyoom, otherwise the kernel might swap caches until eternity
21:04:15 <Welkin> being in swap sucks too
21:04:25 <Welkin> I'm in swap all the time with firefox on this machine with only 4 GB of memory
21:04:30 <maerwald> even without swap, oom doesn't trigger reliably
21:04:35 <Welkin> it will eat up your ssd
21:04:43 <Welkin> wear it out
21:04:48 <s0da> tabemann and maerwald: so are mem leaks only caused by failing to handle de-allocation? failing to "unload" Objects/Classes? or are there other causes? (also, how does this relate to the concept of "DEstuctors", if at all?)
21:04:59 <tabemann> clue: don't have swap on an SSD
21:05:15 <maerwald> so for haskell development, you need earlyoom, because of ghc ;)
21:06:06 <monochrom> In fact I am very disappointed that people need new names like "security vulnerability" when they are merely typical bugs made by typical 1st-year students like, oh, array index out of bounds.
21:06:21 <monochrom> Like why do they even need a new name like "buffer overrun" for that?!
21:06:44 <Welkin> and those are more common than anyone would think
21:06:51 <maerwald> a bug is a bug and you should fix all of them, not try to think which one can be exploitet :)
21:07:00 <Welkin> isn't that what heartbleed was?
21:07:10 <c_wraith> monochrom: I think there's value in pointing out that there's a difference between bugs that make your program give the wrong answer and bugs that let people install ransomware on your system.
21:07:20 <Welkin> and similarly with spectre/meltdown
21:07:29 <maerwald> c_wraith: there's no exact way to distinguish that in actual code though
21:07:35 <monochrom> I would be OK if "security vulnerability" were reserved for the even-CS-grads-haven't-learned-it kinds like out of band signals like watching your timing or your electricity consumption or hammering your RAM.
21:07:48 <tabemann> s0da: they are caused by anything unused that is not freed as one would expect (and note that one can have memory leaks in garbage-collected environments)
21:07:49 <maerwald> unless you know all possible ideas an attacker might have about your code
21:08:15 <c_wraith> maerwald: the fact that it's not always obvious doesn't mean there isn't value in adding the label "security bug" when it's known to be a problem.
21:08:36 <maerwald> c_wraith: I think it causes more harm though, because then people go about just backporting what they labeled "security bug"
21:08:49 <maerwald> so the kernel approach is the correct one imo
21:09:02 <c_wraith> I mean, backporting has all sorts of issues.
21:09:21 <monochrom> If anything I am OK with a line between UB bugs and DB-but-wrong-answer.
21:09:21 <maerwald> 1. backport everything, 2. try to always run latest software at all times (if security is a concern)
21:09:35 <maerwald> c_wraith: yeah
21:09:38 <tabemann> the problem with backporting is that the debian people don't necessarily know the code as well as the original developers
21:09:54 <maerwald> tabemann: yeah, don't run debian =)
21:10:05 <Welkin> I run opensuse
21:10:19 <tabemann> like I once encountered a version of firefox on debian that failed in the backported version but worked when I downloaded a new version from mozilla
21:10:25 <Welkin> and mac
21:10:37 <s0da> maerwald: what should we run then, in terms of distros?
21:10:45 <tabemann> I personally use debian myself
21:11:01 <tabemann> it's just that debian is kinda obsessed with "stable" versions
21:11:11 <tabemann> so now I never use a stable version but always a testing one
21:11:12 <maerwald> s0da: I really don't know :(
21:11:35 <maerwald> my criteria when using a distro is maintainers attitude and policies, not features, popularity or anything else
21:11:35 <s0da> maerwald: what do YOU run? OpenBSD? Tails? GNU Herd?
21:11:51 <c_wraith> I'm usually fine with debian stable, but I don't install things that change rapidly from the repos.  That includes firefox and ghc. :)
21:12:00 <maerwald> s0da: I run a distro that's not user-friendly, so I usually don't recommend it
21:12:00 <s0da> maerwald: I HATE "popularty". stupid ppl mimic stupid ppl
21:12:17 <s0da> maerwald: is it mindfuck? pls tell me its mindfuck
21:12:23 <tabemann> my main rule with distros is don't use ubuntu
21:12:26 <Welkin> s0da: that's how we got npm and node
21:12:31 <s0da> tabemann: lol. agreed
21:13:02 <s0da> maerwald: You like to be mysterious ive noticed.
21:13:05 <maerwald> s0da: https://exherbo.org/
21:13:09 <monochrom> I have the complementary rule. I use ubuntu.
21:13:25 <sshine> maerwald, it's been years since I saw anyone mention that distro.
21:13:37 <maerwald> sshine: well, I usually don't ;)
21:13:46 <Welkin> you use templeos
21:13:49 <s0da> maerwald: what is your opinion on OpenBSD? Tails? GNU Herd? Gentoo? Slackware? Arch?
21:14:04 <s0da> maerwald: LFS?
21:14:08 <Welkin> arch is for neckbeards and they broke haskell
21:14:39 <tabemann> GNU Hurd is still not practical, despite being in development all these years
21:14:55 <sshine> I use Ubuntu Server on my laptop. breakin' the law.
21:14:55 <s0da> tabemann: in what sense is it not practical?
21:15:14 <s0da> tabe what CAN/CANT it do?
21:15:27 <Welkin> I'm tired of broken-ass linux distros, so I just use opensuse tumbleweed
21:15:47 <Welkin> it's still not perfect, but works well
21:15:55 <maerwald> s0da: I've done gentoo dev for 4 years, but it's a lot of time. They try to package haskell packages https://github.com/gentoo-haskell/gentoo-haskell but IMO, this doesn't play too well with the package manager (which installs things globally)
21:15:57 <s0da> Welkin: how does OPensus tumbleweed compare to Ubuntu-based (i know, i know) LinuxMint?
21:16:01 <monochrom> sshine: I use ubuntu server inside virtualbox on may laptop. Does that count? :)
21:16:07 <tabemann> https://www.phoronix.com/scan.php?page=news_item&px=GNU-Hurd-2019-State
21:16:15 <sshine> monochrom, what's outside of the virtualbox?
21:16:17 <rotaerk> hmm any reason it's unwise to put my used language extensions in the cabal file rather than every source file?
21:16:20 <Welkin> s0da: it's a rolling release
21:16:24 <monochrom> ubuntu desktop
21:16:52 <monochrom> (Motivation: I set up two virtual machines to mark students' IPv4 socket programming assignment.)
21:16:55 <maerwald> there are not a whole lot of distros that can manage haskell packages well... probably only NixOS, but the configuration complexity is beyond anything reasonable imo
21:16:55 <s0da> Welkin: what is a rolling release? ive heard that term before i think
21:17:25 <Welkin> you get constant updates instead of updating every 9 months to new snapshots
21:17:26 <tabemann> just the fact that the Hurd doesn't support 64-bit or SMP yet rules it out for me
21:17:39 <sshine> s0da, contrast to ubuntu: it has two yearly releases, 18.4, 18.10, 19.4, 19.10, etc.
21:17:40 <c_wraith> rotaerk: it lets you be more precise with extensions.  Sometimes you explicitly want to note that you don't have particular extensions enabled in a file.
21:17:56 <rotaerk> hmm k
21:18:08 <c_wraith> rotaerk: especially things like CPP or TemplateHaskell, which can seriously break parsing when enabled.
21:18:09 <sshine> s0da, rolling releases => whenever you hit update packages, there's possibly a small amount.
21:18:15 <rotaerk> maybe I'll do it for only *certain* extensions
21:18:24 <c_wraith> that's a reasonable compromise
21:19:01 <monochrom> rotaerk: If I don't see {-# LANGUAGE PolyKinds #-} in a file I don't expect it.
21:19:27 <s0da> So im not trying to argue or anything, i rly want to understand... can a distro be both LTS and rolling release, or are those opposites of eachother?
21:19:27 <sshine> maerwald, I'm going to reinstall my Linux soon, and I'm going to pick either Arch, Ubuntu Server, or NixOS. haven't really decided. seems like they all have drawbacks.
21:19:36 <monochrom> As usual, good communication requires redundancy.  (Learned it the hard way.)
21:20:16 <maerwald> sshine: well, none of those distros have the maintainer attitude or the packaging policy that would make me use them
21:20:49 <Welkin> sshine: if you want something that works out of the box, you never have to deal with things breaking, and you are always up to date, use opensuse
21:20:55 <sshine> maerwald, what maintainer attitude or packaging policy are you looking for in a distro, and why?
21:21:04 <c_wraith> monochrom: what about extensions that are more obvious, like MPTCs or FunDeps?
21:21:05 <maerwald> opensuse has surprisingly good policies and the maintainers are kinda reasonable
21:21:09 <Welkin> it's prm-based and has an enterprise version
21:21:15 <Welkin> rpm*
21:21:19 <sshine> Welkin, a Linux that doesn't eventually break? does it come with unicorns pre-installed, or do I have to install them myself? ;)
21:21:23 <maerwald> sshine: too much to list here lol
21:21:24 <Welkin> haha
21:21:30 <Welkin> well it hasn't broken yet on me
21:21:34 <Welkin> and I use it at home and at work
21:21:56 <monochrom> c_wraith: Then OK
21:21:58 <Welkin> ubuntu would break very often
21:21:58 <maerwald> sshine: one major thing about policy is how downstream patching is done and when
21:22:01 <Welkin> arch came pre-broken
21:22:03 <sshine> maerwald, OK, so I understand that you don't like bad policies and unreasonable maintainers.
21:22:23 <rotaerk> monochrom, I'm thinking of doing it for, say, LambdaCase, ViewPatterns ... and maybe DataKinds and TypeApplications because I pretty much use these two ubiquitously in this particular project
21:22:27 <maerwald> and then there's just the priorities of maintainers and what their understanding of quality is
21:24:29 <sshine> maerwald, I don't have that strong opinions on how packages are managed.
21:24:38 <maerwald> if you look at the state of how haskell is done in arch, you'll see there's not much about quality
21:25:18 <sshine> maerwald, I almost can't remember; they install Haskell packages via Arch'es own packages, right?
21:25:41 <sshine> I remember having a lot of problems with Haskell packages some years ago.
21:26:02 <sshine> but today I doubt that I would have those problems, letting Stack do the job.
21:26:58 <sshine> Ubuntu PPAs vs. Arch's AUR, I'm pretty happy that there's *some* way to break free from stale packages and remain within maintained packages.
21:28:26 <Welkin> there is packman for that too
21:28:37 <maerwald> https://wiki.archlinux.org/index.php/Haskell#Problems_with_linking
21:28:57 <maerwald> not sure those are the only problems. Most arch users here (and on reddit) seem to advise against using pacman for ghc
21:29:08 <Welkin> sshine: use ghcup instead
21:29:26 <sshine> Welkin, instead of?
21:29:26 <Welkin> no, not arch's pacman, but packman
21:30:05 <sshine> maerwald, that surely is annoying; especially for those who don't use GHC daily and expect their package will just work.
21:30:19 <sshine> maerwald, but I don't see how that would apply to me, were I to install Arch.
21:30:19 <Welkin> https://en.opensuse.org/Additional_package_repositories
21:30:48 <maerwald> sshine: also, AUR is a trash-pile of low-quality packages and unless you understand PKGBUILDs inside out, you should stay away from it
21:31:12 <Welkin> it's like npm for linux!
21:31:32 <maerwald> yeah, you never know what you get :)
21:31:37 <maerwald> it might even be ads
21:31:42 <Welkin> aids?
21:32:38 <sshine> maerwald, AUR surely does involve browsing and reading before installing, yes.
21:49:14 * hackage arbor-monad-logger 0.1.1.3 - Simple logging library  https://hackage.haskell.org/package/arbor-monad-logger-0.1.1.3 (arbornetworks)
21:50:18 <jle`> is that a pun on arbor and logging?
21:56:19 <sshine> I don't know, it's a super weird package
21:56:31 <sshine> the Hackage URL 404s
21:57:12 <sshine> (packetloop/arbor-monad-logger != packetloop/hs-arbor-logger)
21:57:45 <sshine> and inside hs-arbor-logger.cabal the website is listed as https://github.com/kazu-yamamoto/logger but the author Michael Snoyman.
21:58:01 <sshine> this could be the beginning of a very niché crime novel.
21:58:07 <dsal> I should probably stop coding and go to bed.  I can't do simple things.   How do I do    data T a = A | B | X a   deriving(Show, Eq)   ?
21:58:54 <sshine> dsal, just like that?
21:59:06 <dsal> I guess with ExistentialQuantification
21:59:20 <heatsink> It isn't existential
21:59:29 <sshine> dsal, I don't understand the question, then. what you typed works in itself.
21:59:33 <dsal> Nah, it doesn't let me do it.
21:59:52 <sshine> dsal, maybe you have an error somewhere else then.
22:00:04 <sarahzrf> @let data T a = A | B | X a   deriving(Show, Eq)
22:00:06 <lambdabot>  Defined.
22:00:16 <dsal> Oh.  I guess I was trying to force a constraint.
22:00:33 <dsal> Yeah, if I just don't force a constraint, it's fine.  heh
22:00:47 <sshine> OK.
22:35:13 <koz_> Building cabal-install on an ARM board sure is fun, lol.
22:37:16 <Axman6> just build on AWS A1 instances
22:37:24 <Axman6> "just"
22:39:56 <koz_> I'm good, lol.
22:40:11 <koz_> Almost done anyway.
22:40:17 <koz_> Then I can test finitary on ARM.
22:40:20 <koz_> #priorities
22:42:14 * hackage arbor-monad-metric 1.2.1 - Core metric library for publishing metrics.  https://hackage.haskell.org/package/arbor-monad-metric-1.2.1 (arbornetworks)
22:42:32 <koz_> Gotta say, GHC 8.8's Haddock theme is pretty nice-looking.
22:53:35 <dsal> I use a lot of ARM.
22:57:14 <koz_> dsal: Oh? With Haskell?
22:57:28 <dsal> Yeah.  Most of my computers are ARM.
22:57:32 <dsal> It's a bit of a pain.
22:58:07 <koz_> dsal: I can imagine. I have a bunch of ARM boxes for microserver purposes.
22:58:13 <koz_> My work machines are still x86_64 though.
23:00:59 <dsal> I can't actually build on any of mine, but I've maintained my own GHCs for some.  8.8 is apparently going to support me better.
23:12:44 * hackage arbor-monad-counter 2.0.2 - Counter library for submitting metrics to a backend such as datadog  https://hackage.haskell.org/package/arbor-monad-counter-2.0.2 (arbornetworks)
23:15:14 * hackage finitary 1.2.0.0 - A better, more type-safe Enum.  https://hackage.haskell.org/package/finitary-1.2.0.0 (koz_ross)
23:30:44 * hackage hgeometry-combinatorial 0.9.0.0 - Data structures, and Data types.  https://hackage.haskell.org/package/hgeometry-combinatorial-0.9.0.0 (FrankStaals)
23:31:35 <EvanR> /join #priorities
23:32:14 * hackage hgeometry-svg 0.9.0.0, hgeometry-ipe 0.9.0.0, hgeometry 0.9.0.0 (FrankStaals)
23:33:14 * hackage arbor-datadog 0.1.0.1 - Datadog client for Haskell.  https://hackage.haskell.org/package/arbor-datadog-0.1.0.1 (arbornetworks)
23:34:26 <koz_> Was Semigroup not in the prelude for GHC 8.2?
23:34:33 <koz_> EvanR: Lol.
23:45:14 * hackage arbor-postgres 0.0.5 - Convenience types and functions for postgresql-simple.  https://hackage.haskell.org/package/arbor-postgres-0.0.5 (arbornetworks)
23:50:29 <int-e> koz_: it was not
23:51:28 <koz_> CPP time I guess...
