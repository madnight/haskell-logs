00:06:28 <jchia> What's the difference between data-default and data-default-class? Which package should I use to get the Default class?
00:07:34 <dminuoso> jchia: It depends on which class is being used by your library.
00:07:46 <dminuoso> jchia: One way is to check hackage and look at its dependencies.
00:07:59 <jchia> dminuoso: I'm trying to pick one
00:08:05 <dminuoso> jchia: Oh wait, it seems that data-default actually depends on data-default-class
00:08:10 <dminuoso> jchia: In my opinion, don't use it. :-P
00:08:26 <dminuoso> You can just expose some `defConfig :: Config` binding.
00:45:12 * hackage ideas-math-types 1.1 - Common types for mathematical domain reasoners  https://hackage.haskell.org/package/ideas-math-types-1.1 (BastiaanHeeren)
00:46:12 * hackage Advise-me 0.1 - Assessment services for the Advise-Me project  https://hackage.haskell.org/package/Advise-me-0.1 (BastiaanHeeren)
00:56:11 * hackage connections 0.0.1 - Partial orders, Galois connections, ordered semirings, & residuated lattices.  https://hackage.haskell.org/package/connections-0.0.1 (cmk)
01:17:50 * co1or listens to anamanaguchi
01:18:42 * hackage hasql-transaction 0.8 - A composable abstraction over the retryable transactions for Hasql  https://hackage.haskell.org/package/hasql-transaction-0.8 (NikitaVolkov)
01:22:08 <dibblego> also same, my opinion
03:45:34 <isn> Hi
03:45:42 <isn> Anyone here?
03:45:53 <opqdonut> yes
03:45:55 <jgt1> isn: yes
03:46:03 <__monty__> isn: No, none of the 1500 people are here.
03:46:42 <isn> Lol, sorry bout that, most people don't respond on some channels, just wanted to make sure. :)
03:47:00 <jgt> __monty__: to be fair, loads of people appear to be in a channel via some bouncer, but rarely respond
03:47:23 <__monty__> That's the nature of irc. You have to be willing to hang around for hours to give people a chance to answer.
03:48:53 <yushyin> I'm always here, just waiting for the one question I know the answer to!
03:49:07 <isn> Anyway, I thought maybe you guys could help me come up with ideas for a challenge/application that could be created in a day and is a bit advanced.
03:49:28 <__monty__> An interpreter's always fun.
03:49:29 <jgt> isn: the standard IRC answer is DATAJA
03:49:39 <__monty__> ANd you can take it as far as you want.
03:50:09 <isn> Ah an interpreter, nice one, thanks!
03:50:14 <isn> jgt: what is DATAJA?
03:51:01 <__monty__> Do A Thing And Jry staying Alive?
03:52:00 <isn> Makes sense (almost) lol
03:52:05 <jgt> __monty__: that's exactly it
03:52:12 <jgt> isn: Don't Ask To Ask, Just Ask
03:52:50 <__monty__> Ah, ofc. I had the project suggestion context loaded in RAM.
03:54:46 <yushyin> make sure to flush caches if you change context!
03:57:40 <merijn> isn: What's reasonable for a day depends on skill level :)
03:57:45 <__monty__> Ah, yes. Avoid those Spectres.
04:03:39 <isn> Well, I've been into Haskell for a couple of days. I don't know Monads yet, so I will avoid this for now and find a challenge for that later
04:16:01 <__monty__> isn: If you just want some easy exercises try something like codewars or exercism. Skip up to the level you're at, otherwise it's a grind.
04:16:40 <lavalike> I'd consider doing advent of code in it, optimized to have fun (:
04:20:07 <yushyin> yes, aoc is fun indeed.
04:21:52 <__monty__> Gets devilishly hard unless you're familiar with many data structures already though.
04:25:28 <lavalike> I think that's unfair it's very approachable, maybe 5% of the problems posted (considering all years) are very hard
04:27:29 <yushyin> for a beginner in haskell it might be more challenging
04:29:39 <yushyin> for example one will soon encounter problems were one wants to use state monad or similar.
04:29:57 <jgt> exercism is easy, and the mentorship for the Haskell track is pretty good
04:30:15 <lavalike> I'm surprised tho, do you want to learn haskell or do some website's problems without learning haskell?
04:30:15 <jgt> which contrasts with the JavaScript track, where some of the mentor feedback is plain idiotic
04:30:42 * hackage hw-dsv 0.3.7 - Unbelievably fast streaming DSV file parser  https://hackage.haskell.org/package/hw-dsv-0.3.7 (haskellworks)
04:55:14 <WilliamHamilton> I want to be sure that I understand the details here: what's the difference between:
04:55:24 <WilliamHamilton> do a <- pure (error "hey"); pure (True || a)
04:55:34 <WilliamHamilton> do a <- undefined; pure (True || a)
04:56:08 <WilliamHamilton> in ghci; the first returns `True`, the second `*** Exception: Prelude.undefined`
04:56:36 <boxscape> % do ~a <- undefined; pure (True || a)
04:56:36 <yahb> boxscape: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:22:10 in interactive:Ghci7
04:56:39 <boxscape> interesting
04:57:08 <f-a> WilliamHamilton: pure wraps it in IO a (since we aare in IO)
04:57:32 <tabaqui1> seems fine: a would never be evaluated here
04:57:44 <tabaqui1> so there is no exception in first line
04:57:45 <f-a> and si- what tabaqui1 said
04:58:09 <WilliamHamilton> ok, but why is a evaluated in the second example?
04:58:11 <tabaqui1> but in the second be have to run IO action anyway
04:58:19 <tabaqui1> 'a' is not evaluated too
04:58:19 <WilliamHamilton> why?
04:58:27 <tabaqui1> but undefined is
04:58:51 <tabaqui1> % do a <- print 1 >> undefined; pure (True || a)
04:58:51 <yahb> tabaqui1: 1; *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:23:20 in interactive:Ghci7
04:58:57 <WilliamHamilton> ok so when we say evaluated here do we mean in weak head normal form?
04:58:57 <boxscape> WilliamHamilton keep in mind that it's desugared into `undefined >>= \a -> pure (True || a)`
04:58:59 <tabaqui1> % do a <- print 1 $> undefined; pure (True || a)
04:58:59 <yahb> tabaqui1: 1; True
05:00:00 <tabaqui1> runIO runs all side-effects here
05:00:06 <tabaqui1> pure (undefined) has no side effects
05:00:26 <tabaqui1> while undefined probably has, and we cannot get them without an exception
05:00:32 <WilliamHamilton> boxscape: the desugaring answered my question, thanks; but to be sure, does it happen because we evaluate to weak head normal form?
05:01:21 <tabaqui1> WilliamHamilton: we don't evaluate 'a' either way, but we do evaluate all IO actions here
05:01:44 <boxscape> WilliamHamilton the definition for >>= for IO starts like this: `bindIO (IO m) k = ...`, so it has to be evaluated to find out whether it matches this pattern
05:01:56 <boxscape> s/it/the first argument
05:02:32 <WilliamHamilton> makes sense, thanks guys!
05:02:52 <f-a> https://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Base.html#line-1093
05:03:04 <f-a> (and >> refers to *> which is defined in term of >>=)
05:03:42 <WilliamHamilton> thanks f-a! and where is pure defined for IO?
05:04:13 <WilliamHamilton> oh
05:04:13 <WilliamHamilton> returnIO :: a -> IO areturnIO x = IO (\ s -> (# s, x #))
05:04:35 <WilliamHamilton> that explains it all, thanks!
05:18:49 <dminuoso> What's the most lightweight templating library I can have? I just want something to template an HTML email with and interpolate a few values in there..
05:19:00 <merijn> dminuoso: mconcat + Text :p
05:19:15 <dminuoso> merijn: With 200 lines of HTML? Id rather not. :<
05:19:30 <merijn> dminuoso: Why not?
05:19:37 <dminuoso> merijn: Mmm.
05:19:41 <jgt> dminuoso: what's an example of a heavyweight templating library?
05:20:03 <merijn> dminuoso: Presumably large parts of that HTML will be static blobs so it just becomes a handful of variables mconcat with whatever interpolation you need
05:20:19 <merijn> dminuoso: You did ask for "most lightweight" :p
05:20:30 <dminuoso> jgt: mustache
05:21:39 <jgt> dminuoso: there's a mustache library on hackage, but it has far more dependencies than blaze-html
05:25:41 <pavonia> dminuoso: What about the bad r-word?
05:29:45 <merijn> uhoh, I have this weird itchy feeling that free monads are a solution to my problem >.>
05:29:54 <jzyamateur> So what does it mean to lift the composition operator? I.e. `fmap (.)`
05:30:13 <Ariakenom> :t fmap (.)
05:30:14 <dminuoso> merijn: At the minimum I'd use a QQ though.
05:30:14 <lambdabot> Functor f => f (b -> c) -> f ((a -> b) -> a -> c)
05:30:19 <dminuoso> Just to not get crazy with newlines.
05:30:35 <merijn> dminuoso: Why not use whitespace escaping?
05:30:56 <dminuoso> merijn: What do you mean?
05:31:06 <merijn> > "hello \            \ world"
05:31:08 <lambdabot>  "hello  world"
05:31:21 <merijn> dminuoso: That feature no one ever knows about unless they read the report :p
05:31:55 <merijn> Or did you mean the opposite? i.e. you want newlines in there
05:32:22 <dminuoso> merijn: Well for html it'd be fine, but I also need to include a plain text mail, so... :)
05:35:22 <pavonia> With regex substitutions you could also include static text from external files
05:51:02 <kuribas> @hoogle (a -> b -> b) -> (b -> Bool) -> [a] -> ([b], [a])
05:51:03 <lambdabot> No results found
05:51:12 * hackage rebase 1.4 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-1.4 (NikitaVolkov)
05:51:30 <merijn> kuribas: Looks like partitionBy + on?
05:51:44 <kuribas> merijn: more like an accumulating span
05:52:11 * hackage rerebase 1.4 - Reexports from "base" with a bunch of other standard libraries  https://hackage.haskell.org/package/rerebase-1.4 (NikitaVolkov)
05:52:18 <merijn> Ah, no, I don't want Free, I want Cont. This is sure to make me more sane
05:54:28 <merijn> Or is there some other way to have State, but with a state type that changes
05:56:32 <kuribas> merijn: what's your problem?
05:56:49 <kuribas> merijn: an indexed monad?
05:56:57 <merijn> kuribas: I'll let you know when I figure out what it is :p
05:57:43 <merijn> I'm pretty sure I don't want indexed monads
06:02:34 <merijn> Or rather I might, if they'd work with do notation, but they don't :\
06:03:12 <reallymemorable> how do i add stack to my PATH?
06:03:36 <f-a> has to be the most asked question on #haskell
06:05:20 <f-a> reallymemorable: are you on linux/unix?
06:05:26 <reallymemorable> mac
06:05:38 <reallymemorable> so posix?
06:05:58 <merijn> macOS is certifiably more unix than linux :p
06:06:23 <f-a> no idea how mac does it, but e.g. to add cabal path to my $PATH I add this line export PATH=~/.cabal/bin:$PATH in my ~/.bashrc
06:07:05 <reallymemorable> so `export PATH = ~/.stack/bin:$PATH`
06:07:26 <f-a> does osx sport bash? I suppose no, since they try to stay away from all things remotel- reallymemorable I think so but I don't use stack myself
06:07:31 <Ariakenom> merijn: excellent choice of words. I'm amused.
06:07:40 <reallymemorable> and for git `export PATH=~/.git/bin:$PATH`
06:08:02 <f-a> reallymemorable: wait, does .stack have a bin folder?
06:08:25 <merijn> f-a: Depends on the version
06:08:26 <Ariakenom> shouldnt homebrew or something handle that nicely?
06:08:37 <merijn> f-a: Everything up to Catalina ships with (old) bash
06:08:43 <merijn> f-a: Catalina ships with zsh
06:08:49 <f-a> thanks merijn 
06:08:49 <reallymemorable> im on High Sierra
06:09:00 <merijn> Homebrew is for people who want utter bleeding edge (and thus constantly broken things)
06:09:17 <f-a> Ariakenom: since the very specific question, I suspect it is a "download a .sh and follow this to install" thing
06:09:44 <Ariakenom> merijn: interesting
06:10:27 <f-a> reallymemorable: let's wait for stack users to just tell us what they do :P
06:12:11 <reallymemorable> ok thanks
06:13:42 * hackage hasql-transaction 0.9 - Composable abstraction over retryable transactions for Hasql  https://hackage.haskell.org/package/hasql-transaction-0.9 (NikitaVolkov)
06:13:47 <reallymemorable> fwiw, this is what im trying to do https://github.com/haskell/haskell-ide-engine
06:13:55 <reallymemorable> and it says that stack and git have to be in my PATH
06:14:09 <f-a> reallymemorable: where was stack installed?
06:14:42 <f-a> if `whereis git` gets you a path, you are ok with it
06:14:49 <f-a> (it: git)
06:15:28 <reallymemorable> `whereis stack` produces nothing, so maybe i only thought i installed it?
06:15:31 <reallymemorable> seems weird
06:15:37 <f-a> no, whereis git
06:15:45 <reallymemorable> whereis git worked
06:15:51 <f-a> stack bins are most likely in some ~/.stack/somefolder folder
06:15:57 <f-a> add that one and you are ok
06:16:11 <reallymemorable> so just add git and im fine?
06:16:48 <f-a> git is already there
06:17:16 <f-a> just cd ~/.stack and see what's in there
06:17:36 <reallymemorable> a bunch of stack related files
06:17:45 <reallymemorable> config.yaml etc
06:17:59 <Ariakenom> reallymemorable: whereis uses PATH to find things. so you can use it to check what's in it
06:18:25 <reallymemorable> oh so if its not in PATH, it wont find it
06:18:52 <reallymemorable> i added `/usr/bin/git` anyway but obviously can remove it if it will screw things up
06:19:47 <kuribas> I wonder if often simple recursion isn't better than a complicated combination of combinators
06:21:36 <f-a> reallymemorable: you don't need to add it (git). You just have to check (should be mentioned in the install help files or script) *where* you installed stack. then you should be ok
06:22:04 <f-a> $HOME/.local/bin <--- apparently it could be this one
06:22:09 <Ariakenom> kuribas: simple better than complicated? that sounds controversial
06:22:17 <f-a> cd ~/.local/bin and see if it's there
06:22:37 <reallymemorable> in that folder is 
06:22:38 <kuribas> @hoogle Semigroup a => (a -> Bool) -> [a] -> ([a], [a])
06:22:39 <lambdabot> Data.Vector.Generic partition :: Vector v a => (a -> Bool) -> v a -> (v a, v a)
06:22:39 <lambdabot> Data.Vector.Generic unstablePartition :: Vector v a => (a -> Bool) -> v a -> (v a, v a)
06:22:39 <lambdabot> Data.Vector.Generic span :: Vector v a => (a -> Bool) -> v a -> (v a, v a)
06:22:41 <reallymemorable> hie hie-8.2 etc
06:22:45 <Ariakenom> if you add adjectives like that your statement becomes quite toothless
06:22:59 <f-a> reallymemorable: is there any sign of stack?
06:23:22 <reallymemorable> well this command gets me there cd ~/.stack
06:23:22 <kuribas> Ariakenom: don't haskell programmers avoid primitive recursion at all costs?
06:23:40 <f-a> reallymemorable: maybe join #haskell-stack, they will be for sure more helpful than me
06:23:45 <Ariakenom> kuribas: ... no
06:23:52 <reallymemorable> ok thanks
06:24:30 <bartavelle> kuribas: not at all cost! Also, if you ask two haskellers to write some function, you will probably get 3 answers :)
06:30:03 <sm[m]> g'day all
06:30:28 <f-a> hey sm
06:31:20 <kentt_> beginner question: is there a resource (page in a textbook?) explaining what exactly the = symbol does when you're defining a function?
06:31:34 <kentt_> i feel like i've understood it badly
06:31:58 <sm[m]> man, PATH management on unix is such a usability nightmare
06:32:11 <sm[m]> I wish we could be free of it
06:32:13 <kentt_> how do you think it compares to the windows path
06:33:08 <sm[m]> I expect things are even worse on windows
06:34:05 <sm[m]> kentt_, like f a = a * 2 ?
06:34:12 <kentt_> yeah
06:34:27 <kentt_> we just did... compositing functions? in class
06:35:06 <sm[m]> f = 2  binds the name "f" to the expression 2
06:35:18 <kentt_> where you do f a b = a * b and then g a = f 3 
06:35:35 <sm[m]> f a = a * 2 binds the name "f" to the expression \a -> a * 2  (an anonymous function taking one argument)
06:35:46 <kentt_> and I realised that I had assumed that you had to write in the parameters 
06:36:35 <kentt_> i've only done oop and prodecural so far so i'm feeling a little out of my depth
06:36:42 * hackage optima-for-hasql 0.1 - Command-line arguments parsing for Hasql  https://hackage.haskell.org/package/optima-for-hasql-0.1 (NikitaVolkov)
06:37:10 <kentt_> oh ok
06:37:22 <kentt_> so if i wanted for some reason i could do
06:37:32 <kentt_> f a = a * 2
06:37:42 <kentt_> g a = f
06:37:45 <Ariakenom> > let add = (+); add1 = add 1; add12 = add1 2; in add12
06:37:47 <lambdabot>  3
06:38:22 <kentt_> and then would g also reference the anonymous function \a * 2 or would it reference f?
06:38:45 <Ariakenom> g references a function \a -> f
06:39:09 <Ariakenom> so g = \a -> (\a -> a*2)
06:39:10 <kentt_> alright
06:39:36 <kentt_> thank you both for the clarifications
06:40:17 <sm[m]> kentt_ you might enjoy https://leanpub.com/haskell-cookbook/read#leanpub-auto-interactive-ghci-shell also. It talks about composing and currying a little
06:40:59 <kentt_> we talked about currying just before lunch and honestly i was just hungry
06:41:09 <kentt_> and then i was hungrier because of the curry
06:41:15 <Ariakenom> :)
06:41:40 <kentt_> i'll read this over thanks
06:41:44 <Ariakenom> just wait until you get to burritos
06:42:07 <kentt_> burrito is probably based on foldr
06:42:35 <sm[m]> also, https://en.wikibooks.org/wiki/Haskell/Variables_and_functions#Functions
06:48:56 <kuribas> Ariakenom: actually, if there isn't a HOF or combination that fits your usecase, a good idea is to write a generic one yourself.
06:49:15 <kuribas> Ariakenom: as it is easier to test than something that relies on the rest of your program.
06:52:29 <kuribas> it can then use primitive recursion, but easier to verify than if the recursion is inside the program logic.
06:56:11 <Ariakenom> sure. sometimes testing it with the other parts it touches is easy though. then factoring it out may just make things messier 
07:01:30 <Ariakenom> :t \step -> let loop = step >=> loop in loop
07:01:32 <lambdabot> Monad m => (b -> m b) -> b -> m c
07:02:30 <Ariakenom> kuribas: I had that code, would you change it? step was another definition in scope and not an argument
07:03:26 <kuribas> :t fix 
07:03:28 <lambdabot> (a -> a) -> a
07:04:15 <kuribas> :t fix (flip (>=>))
07:04:17 <lambdabot> error:
07:04:17 <lambdabot>     • Occurs check: cannot construct the infinite type: b ~ a -> a -> b
07:04:17 <lambdabot>       Expected type: ((a -> a -> b) -> a -> a -> c)
07:04:56 <kuribas> :t \step -> fix (step >=>)
07:04:57 <lambdabot> Monad m => (a -> m a) -> a -> m c
07:05:09 <kuribas> Ariakenom: maybe this?
07:16:10 <kuribas> if you have pure code throwing an IO exception, should it be in IO then?
07:16:23 <merijn> kuribas: If you want to remain sane, yes
07:24:19 <f-a> kuribas: which kind of pure code does throw an io exception?
07:26:15 <kuribas> I just want to throw a meaningfull exception
07:26:34 <kuribas> because an invariant is broken from data from the database
07:26:38 <kuribas> but I detect it in pure code
07:29:44 <tabaqui1> data Test = Test
07:30:03 <tabaqui1> instance Read Test where { readsPrec _ 't':'e':'s':'t':x = [(Test, x)] }
07:30:16 <Ariakenom> kuribas: i prefer the recursion version. and wrt previous discussion I wouldnt test it separately.
07:30:18 <tabaqui1> can I make it prettier? I mean the pattern matching part?
07:30:35 <lavalike> doubtful
07:31:16 <tabaqui1> I am too, but maybe there is appropriate snippet with PatternSynonyms
07:31:36 <kuribas> Ariakenom: I was refering to more complicated code
07:31:45 <kuribas> not a simple loop
07:32:23 <perdonium> hello
07:32:30 <Cale> kuribas: It's often best to rework the pure code to produce an Either or Maybe value if it's expected to fail
07:32:39 <Cale> (and you want to deal with the exception)
07:33:38 <f-a> kuribas: what's wrong with an Either SomeError - yeah what Cale said?
07:33:40 <Ariakenom> that's good for not having the exception pop up somewhere you didnt expect. if it wasnt forced
07:33:49 <Cale> You can use error "foo" to produce an error message, but such exceptions thrown during evaluation are not easy to catch
07:33:52 <f-a> if it is really an invariant, error " " would do too
07:34:01 <f-a> lol Cale beat me to it once again
07:34:18 <Cale> I'd go so far as to open up one of my dependencies and begin reworking it before trying to catch exceptions thrown from pure code, most of the time.
07:34:21 <Ariakenom> f-a: what is a "real" invariant?
07:34:24 <merijn> kuribas: There's no way to reliably throw from pure code, so that way lies madness
07:35:02 <f-a> Ariakenom: e.g. broken logic, not something that could reasonably fail
07:35:03 <kuribas> right
07:35:24 <merijn> kuribas: If it really can't happen, just use error, otherwise use Either/Maybe
07:36:35 <f-a> Ariakenom: though of course the word I picked might not (is probably not) correct
07:36:43 <Ariakenom> f-a: :) agreed
07:37:08 <f-a> well, be kind and tell me the correct one
07:39:13 <Ariakenom> f-a: not sure. I suppose the useful distincion is if it is reasonable to handle it?
07:39:34 <Ariakenom> or if the program or environment is just broken if it happens
07:39:51 <f-a> Ariakenom: which I understand to be an invariant
07:42:27 <Ariakenom> to me it makes sense to call (something you try to maintain but you still recover from if you fail) an invariant.
07:43:16 <f-a> I see, reasonable indeed
07:44:25 <Ariakenom> as an invariant you keep 3 peers in the network. but if the network breaks you go into some recovery mode
07:44:35 <exarkun> When I `stack build` my Haddock docs, they're written beneath /root/project/.stack-work/install/x86_64-linux-nix/85a960d8d3cd1577388eeff03ed48a9d4c57e9f9c1a9f580834ddf815f698b0a/8.6.5/doc/
07:44:49 <exarkun> When I asked `stack path --local-doc-root` where Haddock docs live, it says /root/project/.stack-work/install/x86_64-linux-nix/99c0afcdb6d8394d3183f332043043dd93cd3ff1487dcd27ebd3637a2277806f/8.6.5/doc/
07:45:09 <exarkun> Why do the paths mismatch?  How do I get them to agree?
07:45:17 <f-a> exarkun: /root/ for real?
07:45:27 <exarkun> f-a: it's on CircleCI
07:45:29 <f-a> oh
07:46:02 <exarkun> It's still probably not great but I can only fight so many battles at a time. :)
07:47:17 <exarkun> I think this disagreement might be the result of a recent stack change.  I think this used to work.
07:47:33 <f-a> exarkun: unfortunately not a stack user (and judging by the other stack question, not many around here now). Maybe #haskell-stack can be more helpful and/or quick in answering
07:47:54 <exarkun> ah, thanks, I'll try there
07:51:01 <sm[m]> exarkun: maybe a different flag in each case, like —profile ?
07:51:30 <exarkun> sm[m]: Ah, hm.  There are some different flags set... not --profile but --fast
07:52:34 <geekosaur> that might change optimization and thereby the abi
07:53:03 <geekosaur> since cross-module inlining information will be absent with -O0 / no -O
07:55:13 * exarkun gives it a try
07:58:20 <kuribas> Ariakenom: I wrote spanAccumUntil :: (a -> a -> a) -> (a -> Bool) -> a -> [a] -> (a, [a])
07:58:39 <kuribas> Ariakenom: it accumulates until the test succeeds, or it runs out of elements.
07:59:25 <kentt_> i'm having difficulty understanding the type signature of `length
07:59:29 <kuribas> Ariakenom: it's easy to test in isolation
07:59:29 <kentt_> `
07:59:35 <kentt_> length :: Foldable t => t a -> Int
07:59:35 <kuribas> :t length
07:59:37 <lambdabot> Foldable t => t a -> Int
07:59:56 <kuribas> kentt_: it takes the length of any Foldable
07:59:57 <kentt_> why don't the t and the a have a `->` arrow between them?
08:00:20 <f-a> kentt_: it's type application
08:00:26 <kuribas> kentt_: the t is parameterised by a
08:00:31 <f-a> when you say "Maybe a" there is no arrow in there, right?
08:00:57 <kuribas> kentt_: t could be [] and a could be Int, then it would reduce to [Int] -> Int
08:01:10 <kentt_> oh ok
08:01:44 <kuribas> kentt_: note that [Int] is syntactic sugar for [] Int
08:02:55 <kentt_> so i should understand it as -- the type variable t is restricted to Foldable, and a foldable *or* a value of type a can be passed to the function, and it returns an int
08:03:11 <kentt_> i guess what i want to know is what a is doing there
08:03:18 <kuribas> kentt_: no, not or
08:03:36 <kuribas> kentt_: a foldable *requires* a second type to work
08:03:50 <kuribas> kentt_: you cannot have just a list, you have to have a list of Int, or list of String
08:04:02 <kentt_> OIC
08:04:10 <kuribas> so a can stand for Int or String
08:04:17 <kuribas> or ()
08:04:22 <kuribas> but it always stands for something
08:04:25 <kentt_> I understand kuribas> kentt_: note that [Int] is syntactic sugar for [] Int
08:04:27 <kentt_> now
08:04:39 <kuribas> good :)
08:04:57 <kentt_> thanks!
08:06:07 <f-a> kentt_: when you encounter a novel class in a type signature and want to get a concrete type to get the gist of it
08:06:10 <f-a> a useful trick is
08:06:14 <f-a> :t +d length
08:06:16 <lambdabot> [a] -> Int
08:08:05 <Ariakenom> oh defaulting in :t interesting
08:09:18 <kentt_> ah, thanks
08:09:28 <kentt_>  i'll take a note
08:10:38 <exarkun> `--fast` doesn't seem to have been related
08:10:55 <exarkun> `stack build --haddock ...` and `stack build --fast --haddock ...` write to the same path
08:14:03 <kuribas> I am wondering about how to write "non fancy haskell", that is haskell that can be understood by people who have just a basic level in haskell
08:14:50 <exarkun> aha.  I can reproduce by upgrading to stack 2.1.3.1 (previously on 1.9.3 where paths were much more boring, like ".stack-work/install/x86_64-linux-nix/lts-14.1/8.6.5/doc")
08:14:51 <jchia_> Is there a cleaner or more element way to ensure laziness than the way given here (using "pure () >>")? https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Util-EZConfig.html#v:checkKeymap
08:14:51 <kentt_> lol my installation of ghci doesn't like :t +d
08:15:02 <kentt_> parse error on input +
08:15:03 <f-a_> I suppose mostly concrete types kuribas 
08:15:25 <kuribas> f-a_: what doyou mean?
08:15:32 <jchia_> Is there a better way for maintaining laziness than using "pure () >>" as described here? https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Util-EZConfig.html#v:checkKeymap
08:15:44 <kentt_> from my perspective, only introduce one mind exploding thing at a time
08:15:47 <kuribas> using concatMap instead of foldMap ?
08:16:17 <merijn> jchia_: Sounds like the problem there is that it uses MonadFix
08:16:17 <f-a_> kuribas: using concrete types in signatures, e.g. Integer instead of Integral a => a when you can
08:16:20 <kentt_> if you're trying to write an example, only use things it actually requires to explain the example
08:16:23 <f-a_> and of course keeping it haskell 2010
08:16:38 <kuribas> f-a_: parametricity can sometimes help
08:16:47 <f-a_> indeed it does kuribas 
08:16:49 <jchia_> merijn: Who uses MonadFix?
08:16:50 <exarkun> kuribas: Use `import Foo (bar)` or `import qualified Foo` instead of `import Foo`
08:17:07 <kuribas> f-a_: length :: [a] -> Int makes more sense than [Int] -> Int
08:17:18 <merijn> jchia_: XMonad, that's what the return is for, presumably, to avoid breaking mfix
08:17:58 <kuribas> f-a_: but then using Foldable in code which doesn't need Foldable is probably more obfuscating
08:18:09 <heatsink> kuribas: Here's a project that was intended to be readable without knowing haskell.  Maybe its reading guide would help?
08:18:10 <heatsink> https://github.com/mit-plv/riscv-semantics/blob/master/READING.md
08:18:14 <jchia_> merijn: Just to be sure we're talking about the same thing, in that example, they are trying to avoid an infinite loop in the mutually-recursive definition of startupHook and myConfig.
08:18:28 <kuribas> heatsink: that's very ambitious :)
08:19:07 <merijn> jchia_: Yes, the mutual recursion through a monadic context is done via mfix
08:19:09 <merijn> :t mfix
08:19:11 <lambdabot> MonadFix m => (a -> m a) -> m a
08:19:50 <f-a_> kuribas: ah well spotted, concrete types in places of typeclasses, not parametric polymorphism (which makes indeed lots of sense)
08:20:34 <kuribas> f-a_: lens is the best example of being scary for beginners
08:20:40 <kuribas> not just beginners actually
08:21:06 <f-a_> yep
08:21:23 <kuribas> so I'd probably use microlens instead
08:21:32 <f-a_> lovely package
08:21:34 <merijn> Or, like, just don't use lens?
08:21:35 <kentt_> i am still at the 'y'all sound like you're speaking science fiction language' stage lol
08:22:03 <kuribas> merijn: some things are just painful without lens
08:22:06 <merijn> kentt_: That never stops :p
08:22:09 <kentt_> im gonna typeclass the parametric polymorph into my linux system
08:22:20 <kentt_> :^)
08:22:24 <Ariakenom> why would microlens be better? its still lenses
08:22:38 <merijn> kentt_: Blame the Haskell pyramid: https://patrickmn.com/software/the-haskell-pyramid/
08:22:47 <slack1256> I think knowing you target public is a must. Beginners can be radically different people, for example javascript-ers usually know "flatMap" and can understand monad composition with a little help. C++ guys will have lots of problem except on things that look like templates (unification).
08:23:14 <merijn> slack1256: tbh, I'd say the C++ people have a far easier time with Haskell
08:23:49 <merijn> slack1256: It depends on whether you have people that actually know C++ or "people that write something that's ostensibly C++", there's quite a large number in the latter category
08:23:53 <slack1256> Probably, the point is that they have different problems depending on the background.
08:24:03 <Ariakenom> I always get a strange sense that there's some relation betewen people using haskell and people using c++
08:24:04 <f-a_> Ariakenom: slightly less scary error messages, way more compact api, enormous global warming benefit during compilation
08:24:21 <Ariakenom> although the languages are very different to my eyes
08:24:46 <merijn> Ariakenom: Both involve type level atrocities :p
08:25:07 <Ariakenom> haskell atrocities D:
08:25:08 <kentt_> FWIW they both aren't """beginner languages"""
08:25:24 <kentt_> so if you're big into either you like doing difficult things
08:25:25 <Ariakenom> who would do that?
08:25:38 <kentt_> that's probably your overlap
08:25:41 <Ariakenom> and templates arent types :D
08:26:17 <Ariakenom> "C with std:vector" :D
08:26:49 <merijn> Ariakenom: "templates aren't types" <- says who?
08:27:07 * slack1256 has to remember not to use examples that led astray the point.
08:28:55 <Ariakenom> merijn: a library writer writing bad types gets type errors. a library writer writing bad templates give their users type errors. the former isnt necessarily true, but I tihnk its more true than the latter?
08:29:32 <Ariakenom> kentt_: I think haskell is a fine beginner's language
08:29:53 <slack1256> It was my first language.
08:29:56 <kentt_> to be fair, i'd imagine that a lot of it is simpler if you haven't got conceptions about other languages
08:30:00 <slack1256> LYAH FTW
08:30:09 <kentt_> what i mean is, there are less beginners using it than JS or Python
08:30:17 <kentt_> the merits of those are not the point
08:30:22 <geekosaur> no mfix, it's just strict so you need to avoid that first evaluation causing a loop
08:31:27 <kentt_> there is a "learn c first" crowd but i've always found them... kind of zealotish and not that friendly?
08:31:52 <geekosaur> which also describes c, for that matter :p
08:32:07 <Ariakenom> slack1256: cool. did you use much besides lyah?
08:32:11 <kentt_> ha
08:33:54 <slack1256> Ariakenom: Not really, I was fine skimming, looking at the drawing and re-implementing Data.List.
08:34:06 <kentt_> i've used the first few pages of it
08:34:10 <kentt_> not got much deeper
08:34:16 <slack1256> A good sense of humor can get you far.
08:34:31 <kentt_> i am enjoying the leanpub recommendation because i feel like it answers a lot of the questions i have
08:34:53 <kentt_> or touches on things in a way that complement LYAH / my lectures
08:36:56 <Ariakenom> slack1256: I did lyah and liked it too, humor is nice
08:38:38 <evelyn> One criticism of it which I have is there aren't any excercises in it
08:38:39 <slack1256> I think humor is why "why the lucky stiff" is missed, not his technical knowledge, but the presentation.
08:38:49 <evelyn> other than that, I did like it
08:39:50 <slack1256> There are not formal exercises, but you were encouraged to play on ghci with the code.
08:41:59 <sm[m]> kentt_: good. That HTAC is a good beginners book that gets no attention. LYAH and HPFFP have all mindshare
08:42:22 <merijn> THere's lots of valid criticisms for LYAH, it's objectively not particularly good in terms of pedagogy
08:42:30 <Rembane> What's HTAC?
08:42:38 <merijn> It's just very famous because it was the first somewhat beginner friendly book to come out
08:42:45 <kentt_> i told my course chat about it
08:42:55 <slack1256> @where HTAC
08:42:55 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
08:43:02 <slack1256> @where HPFFP
08:43:02 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
08:43:02 <kentt_> LYAH doesn't do enough concept explaining for me
08:43:26 <kentt_> i am the kind of person who needs to know on some level conceptually what everything is or i will not remember
08:43:41 <evelyn> I quite liked Learning Haskell Data Analysis coming from an R/stats background 
08:44:26 <ptrcmd> hmm..when did LYAH come out?
08:44:33 <slack1256> 2010?
08:45:00 <ptrcmd> ah
08:46:33 <kentt_> i think it's probably good to have so many different way of teaching it, though
08:46:51 <kentt_> since some people are going to have a better time with one book than another
08:47:33 <kentt_> ie. if lyah is objectively not great but gets some people to pay attention all the way through the book the way a dryer one doesn't
08:48:54 <sm[m]> it's not so good if out of date, less effective books prevent/delay new, better ones getting a foothold
08:49:35 <sm[m]> good curated haskell books guide needed maybe
08:49:36 <kentt_> well maybe one day i'll be a real brain dude and write a better textbook that's still funny
08:50:04 <Rembane> slack1256: Vielen dank, haven't seen that one. 
08:50:46 <sm[m]> eg there's https://wiki.haskell.org/Books but that doesn't cover anything new haskellers want to read
08:51:00 <sm[m]> oops, there's LYAH. I take it back
08:51:20 <sm[m]> that page with better presentation perhaps
08:52:07 <kentt_> i think it is difficult to find the middle ground of pace, interest, and working out where the starting point of the knowledge of your readers actually is
08:52:42 <kentt_> once you know something it's either hard to work out that you don't have to explain a concept or that the concepts you're using to explain something also need to be explained
08:52:54 <slack1256> Rembane: Bitte :-)
09:03:56 <kuribas> merijn: RE lenses, I find sometimes doing "over _2" clearer than using the tuple monad
09:04:10 <kuribas> merijn: or "over _1" which has no alternative
09:04:26 <merijn> Isn't that just first and second?
09:04:36 <fendor> who produces these error messages?
09:04:37 <fendor> https://gist.github.com/fendor/2ee7ec3450ee9e5a99fbe0c4e8218076
09:04:42 <fendor> is it cabal?
09:05:09 <merijn> I'd assume so
09:05:24 <kuribas> :t first
09:05:26 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
09:05:28 <fendor> the error message is weird, since there is a cabal.project and a .cabal file
09:05:30 <merijn> That's the wrong one
09:05:47 <merijn> fendor: Well, what are you running and how?
09:06:04 <merijn> :t Data.Bifunctor.first
09:06:05 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
09:06:26 <kuribas> merijn: it works on a triple as well
09:06:40 <fendor> merijn, hard to tell ;D I am running cabal-helper via haskell-ide-engine. The actual problem seems to be, that wrote "package:" instead of "packages:" in cabal.project
09:07:12 <merijn> kuribas: That seems like a rather marginal benefit to justify the overall complexity of lens, tbh
09:07:16 <fendor> yeah, that is the problem
09:07:27 <fendor> I will see if there is an issue for that already, because the error message is wrong
09:08:03 <kuribas> merijn: that's why I use microlens
09:08:34 <kuribas> merijn: and avoid line-noise operators
09:10:08 <fendor> ok, cabal v2-build's error message contains that the field "package:" is unrecognized. cabal-helper seems to hide some of the output 
09:10:21 <jle`> i'd never use fmap on a tuple. but i'd use first and second
09:10:28 <kuribas> merijn: I mostly use "over", "view" and "set"
09:10:45 <merijn> jle`: I would and I'm super annoyed tuples >2 don't have Functor instances
09:10:46 <jle`> if i have a triple, it's probably temporary until i have an actual data type
09:10:50 <Rembane> I only use fmap on tuples to be able to (fmap . ... . fmap)
09:11:00 <jle`> Rembane: why not (fmap . second . ... fmap)
09:11:07 <Rembane> jle`: ^__________^ 
09:11:10 <jle`> using fmap on tuples is like using fmap on lists
09:11:29 <merijn> jle`: Brilliant? :)
09:11:37 <jle`> sure you can, but using 'map' makes it easier to read and also helps with type errors and type inference
09:11:49 <Rembane> jle`: let third = fmap in (fmap . second . third . ...)
09:11:50 <merijn> jle`: Only if you expect to only use lists
09:12:04 <merijn> jle`: I use fmap on tuples when I want to ALSO use that code on other things
09:12:06 <jle`> "cannot match f0 a3 -> k528934 j489563 r9023" => "cannot [a] -> [b]"
09:13:03 <jle`> ok, if the tupleness or listness is not a fixed part of the program then i can see it being helpful to expand brain
09:13:28 <jle`> but i've rarely used tuples in a place where i'd *want* to be able to replace them with something else and not have type errors
09:14:00 <jle`> lists though that's admittedly more common
09:14:12 <jle`> but everything is fun and games until you accidentally use a tuple as a foldable
09:14:32 <exarkun> I found https://github.com/commercialhaskell/stack/issues/4892 which explains that you need all the same --haddock flags for `stack path` to agree with `stack build`.
09:15:48 <f-a_> good that you wrote a bug report
09:15:53 <sm[m]> nice
09:17:20 <dminuoso> Is there a way to write sum generic code in the sense of "I work for any `Int + Bool`" or do I have to use Generics for that?
09:19:24 <f-a_> well dminuoso , Generics was definitely written for that case
09:21:34 <exarkun> f-a_: happily/sadly someone else stumbled across it months ago, I just left a "me too" :)
09:59:49 <ysangkok> if i launch cabal new-repl with --haddock-all, does that ensure that haddock will be available with :doc for all modules i load? it doesn't seem so, i wonder how i can achieve this
10:14:52 <jle`> dminuoso: the lens classy prism system can generate something like that
10:15:12 <jle`> dminuoso: (AsFoo a, AsBar a) => a -> ...
10:15:25 <jle`> means that 'a' has to be a sum of Foo and Bar, at least
10:16:55 <jle`> dminuoso: also i think uniplate can give you functions that can extract or map or traverse over all Int's in a data type
10:17:20 <jle`> dminuoso: so you can write a function like getAllInts :: MyType -> [Int]
10:17:33 <jle`> or doubleAllInts :: MyType -> MyType
10:17:49 <jle`> in a way that is generic over all types, doubleAllInts :: Plated a => a -> a, or something
10:17:55 <dmwit> ysangkok: I think that v2-* runs haddock after everything else it does if it runs it at all.
10:18:09 <jle`> dminuoso: then you could have a previewer at least, getFirstInt :: Plated a => Maybe Int
10:18:10 <dmwit> ysangkok: So I guess probably what will happen is it will open up a repl, and then when you leave it will run haddock.
10:18:30 <dmwit> ysangkok: You could consider cabal v2-build --haddock-all && cabal v2-repl or something like that?
10:18:34 <jle`> dminuoso: but you wouldn't be able to make a 'constructor', so you can't construct something with only an Int.  which is what a true sum would be.
10:18:42 * hackage keycloak-hs 0.2.0 -   https://hackage.haskell.org/package/keycloak-hs-0.2.0 (CorentinDupont)
10:19:23 <dmwit> ysangkok: Is the blocker that it does not build the docs, or that it builds them but can't find them (say, for dependency packages, e.g.)?
10:22:04 <ysangkok> dmwit: well, i call ":doc" on something that looks like it has haddocks in the source, but ghci says that either there is no docs or i didn't call with -haddock. i think it does rebuild before launching the prompt since it lists the packages with "(configuration changed)".
10:23:13 <ysangkok> the project is https://github.com/ElementsProject/simplicity/ and i launch with "cabal new-repl --haddock-all Simplicity". maybe it is broken because of backpack?
10:28:37 <dminuoso> jle`: I seem perhaps I should dive into what uniplate/biplate really is about
10:29:01 <wroathe> The fact that Haskell's type system makes something like QuickCheck possible is an excellent real world argument to use if someone presses you on the value of Haskell
10:29:25 <wroathe> I can't think of a mainstream language where I'd be able to do this
10:30:25 <wroathe> Having it compute arbitrary data for arguments to functions based almost solely on the test case function type signatures is just f*ing awesome
10:30:43 <dmwit> ysangkok: Yes, it rebuilds before running the repl, but it rebuilds the packages, not their documentation. I think. But I think that question is sort of orthogonal, now that you describe the problem more fully.
10:31:15 <ysangkok> wroathe: but you can do similar things without a type system, erlang's quickcheck is very capable and only recently did quickcheck-state-machine port some of the fancy stuff
10:31:56 <wroathe> ysangkok: Would you consider Erlang or Haskell for that matter to be "mainstream" though? I'm thinking about the case of having to defend it against C#/Java/C++/Javascript etc
10:32:17 <wroathe> ysangkok: But yeah, I'll look at Erlang's implementation. Thanks for the tip.
10:33:54 <ysangkok> dmwit: ah ok, i see.... well, regarding the orthogonal problem: it doesn't build after i do control-d in ghci
10:35:42 * hackage fedora-haskell-tools 0.9 - Building and maintenance tools for Fedora Haskell  https://hackage.haskell.org/package/fedora-haskell-tools-0.9 (JensPetersen)
11:32:42 * hackage contravariant-extras 0.3.5 - Extras for the "contravariant" package  https://hackage.haskell.org/package/contravariant-extras-0.3.5 (NikitaVolkov)
11:36:17 <hyperisco> What is "Haskell's killer app"?
11:36:33 <yushyin> ghc :P
11:36:38 <lavalike> hopefully none >:)
11:38:26 <koz_> Something something avoid success at any cost something. :P
11:40:04 <lavalike> that's the spirit!
11:40:17 <EvanR> haskell's killer app is beyond haskell
11:40:41 <cocreature> lavalike: well, anduril uses Haskell so …
11:44:41 <evelyn> Who/what is anduril?
11:45:19 <shapr> hyperisco: coworkers at my last job used pandoc and ShellCheck all the time, without knowing they were written in Haskell
11:45:21 <sim590> I'm trying to use NCurses package for haskell. I have this for now: https://paste.debian.net/1112062/ for testing. Something weird: I call drawCenteredString the first time and my string is not drawn in the middle, but the second is. Why? Is there something that I'm not understanding about monads or it's about the package?
11:46:30 <hyperisco> Gabriel said that as though it was an obvious answer. Just seeing if I am missing the obvious.
11:46:44 <shapr> hyperisco: link?
11:46:56 <wejetheman> I guess I disconnected, did you guys see the question I just asked?
11:47:47 <hyperisco> shapr, https://twitter.com/GabrielG439/status/1189610465560711168 granted I don't know what "OH" means
11:47:59 <shapr> it's usually "OverHeard:" 
11:48:02 <koala_man> wejetheman: no
11:48:30 <hyperisco> Ah, well that would explain the lack of specificity
11:48:56 <koz_> lavalike: I didn't specify the parse tree of that sentence. :P
11:52:23 <wejetheman> ah okay, thanks koala_man. so i was in here the night before last and some of the lads were criticizing my toBinary implementation as inefficient. I was wondering if this fixes the problem http://codepad.org/Or3ss3WK I couldnt figure out any way to do the calculations with simple recursion and get them to come out in the right order. so i had my
11:52:23 <wejetheman> function call a new functuon that has an accumulator. 
11:57:51 <wejetheman> sorry if any of my terminology is off, i just try my best with that part but focus on actually making some new code every day
12:07:30 <sm[m]> did those lads profile it ?
12:08:12 <EvanR> "the performance lads"
12:09:37 <wejetheman> basically they said the problem was that i was doing ++ between two lists and the list on the left size was growing in length as the numbers grew, and when you ++ two lists together it has to iterate through all the values in the list on the left each time 
12:09:47 <sm[m]> assume it's just the beer talking 8-]
12:10:23 <wejetheman> they used more fancy nomenclature than that but thats what I got from it
12:10:29 <EvanR> yeah when you iterate ++ you want the lists to lean to the right
12:11:17 <EvanR> purely because of how ++ is defined
12:11:22 <EvanR> @src (++)
12:11:22 <lambdabot> []     ++ ys = ys
12:11:22 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
12:11:22 <lambdabot> -- OR
12:11:22 <lambdabot> xs ++ ys = foldr (:) ys xs
12:11:36 <EvanR> ok that might not be so clear
12:12:07 <sm[m]> more beer!
12:12:18 * EvanR checks the day of the week
12:13:39 <wejetheman> well in this solution there arent even any ++s so surely that oughta done it.
12:13:40 <EvanR> when you ++ two lists, you have to make a copy of the left list in order to change the linkage of the last node to the right list, which is reused, shared
12:16:01 <wejetheman> unless I just reinvented the wheel with regard to the problem
12:16:28 <EvanR> sorry, what is the type of newToBinary 
12:18:04 <wejetheman> oh sorry myself, Int -> [Int]
12:18:51 <EvanR> so, your newToBinary function recurses until the Int has run out of "halfs"
12:19:00 <EvanR> then it begins to output bits
12:19:20 <EvanR> since Int can only be so big it's probably not a big deal
12:19:32 <EvanR> you are basically doing a foldl
12:20:20 <EvanR> you can be more lazy by outputting the bits in reverse order
12:21:04 <wejetheman> that was my original original solution, i just reversed it
12:21:47 <wejetheman> but they said there was a way to do it more efficiently than that, they called that O(n) and said there was a O(1) solution if i could find it
12:22:12 <EvanR> for Int specifically maybe there is a O(1) solution, thanks to it's boundedness
12:23:19 <EvanR> where is your original solution?
12:24:25 <wejetheman> oh gosh let me see if I can remember it
12:29:45 <wejetheman> toBinary = reverse . f  where    f 0 = [0]    f 1 = [1]    f n = [n `mod` 2] ++ toBinary (n `div` 2) 
12:29:58 <wejetheman> http://codepad.org/YaRGwUIj
12:30:01 <wejetheman> thats clearer
12:30:35 <EvanR> well without the reverse it's perfectly lazy :)
12:30:40 <dmwit> > [testBit 0xcafebabe i | i <- [0..63]]
12:30:44 <lambdabot>  [False,True,True,True,True,True,False,True,False,True,False,True,True,True,F...
12:31:03 <wejetheman> yea... that doesnt quite give the right answers
12:31:31 <EvanR> because we read numbers big endian?
12:31:40 <EvanR> screw that
12:32:49 <dmwit> (I guess technically even if you put [0..] instead of [0..63] it's still O(1). =P)
12:33:05 <EvanR> though it's a big odd your function can begin or end with a 0
12:33:08 <EvanR> your output list
12:38:15 <EvanR> a big endian number either starts with a 1 or is zero
13:00:42 <OmegaDoug> Hi, I'm using parseUnixTimeGMT which allows me to input invalid dates. For instance, I can input "Thu, 41 Jan 2000 00:00:00 GMT" and receive back the timestamp "-2208729600". I'm wondering how to best lock down the call to this function so that the supplied day is guaranteed to be within the correct range for the supplied month.
13:02:42 <OmegaDoug> I've wrapped the parseUnixTimeGMT function. I'm thinking I can return a Maybe Int instead of an Int and perform the necessary validation. I just wanted to check if there were any other idioms that might be suitable here and hopefully learn something new today.
13:04:42 * hackage relude 0.6.0.0 - Custom prelude from Kowainik  https://hackage.haskell.org/package/relude-0.6.0.0 (shersh)
13:10:09 <EvanR> OmegaDoug: returning a Maybe Int instead of Int and doing validation sounds about right
13:11:05 <isn> I'm playing around with Haskell and trying to make a morse code encoder/decoder. This is what I have so far:
13:11:08 <isn> import Data.List
13:11:08 <isn> import Data.Maybe
13:11:09 <isn> morseDictionary :: [(String, Char)]
13:11:11 <isn> morseDictionary = [
13:11:13 <isn>     (".-", 'A'),
13:11:15 <isn>     ("-...", 'B'),
13:11:15 <koz_> isn: Please use a pastebin.
13:11:17 <isn>     ("-.-.", 'C')
13:11:19 <isn>     ]
13:11:21 <isn> fromMorseCode :: String -> Char
13:11:23 <isn> fromMorseCode m = fromMaybe '?' (find (\ (x, _) -> x == m) morseDictionary)
13:11:25 <isn> main :: IO()
13:11:27 <isn> main = fromMorseCode "-..."
13:11:29 <isn> Ah alright, will do. Brb :)
13:13:45 <isn> I'm playing around with Haskell and I'm trying to create a morse code encoder/decoder. However I'm getting some errors. Can someone point me to the right direction? My code: https://pastebin.com/xBA4c2rn And the error: https://pastebin.com/Da7HQH1V
13:15:01 <koz_> isn: First suggestion:
13:15:04 <koz_> :t lookup
13:15:06 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
13:15:34 <koz_> Secondly, 'throwing away' that Maybe isn't a great idea.
13:15:53 <OmegaDoug> EvanR Nice to hear my head is in the right mindset. ;)
13:16:05 <koz_> Wait, never mind, I misread, lol.
13:16:14 <koz_> First suggestion might still help.
13:16:27 <isn> Oh lookup actually seems like a function I actually needed lol, thanks! Why is it a bad idea?
13:16:42 <EvanR> OmegaDoug: the combination of parsing and validating can be accomplished with a parser library
13:16:49 <koz_> I misread - I thought that was fromJust, but it's fromMaybe.
13:16:58 <koz_> The reason you're getting the error is because of this:
13:17:01 <koz_> :t find
13:17:02 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
13:17:17 <koz_> In your case, t is [] and a is (String, Char).
13:17:27 <koz_> So by that logic, you'll get back a (String, Char), not a Char.
13:17:32 <koz_> lookup should do what you want.
13:17:53 <isn> Ah, that's right! So if I made my return type (String, Char) it would've worked?
13:17:56 <tabaqui1> also, checkout containers/unordered-containers libraries
13:17:59 <koz_> Yes.
13:18:13 <koz_> main would still have issues.
13:18:20 <isn> Alright, that makes sense. Thank you very much :)
13:18:22 <tabaqui1> they provide search trees and hashtables
13:18:32 <isn> Why would the main have issues?
13:18:33 <koz_> Because you need IO (), but your function (assuming that change) would give back a (String, Char).
13:18:47 <koz_> Those types definitely don't match up.
13:18:51 <isn> So I would need something like putStrLn to print it right?
13:18:56 <koz_> Yes, that'd work.
13:19:06 <isn> Awesome ty :)
13:19:11 <tabaqui1> % :t putStrLn
13:19:11 <yahb> tabaqui1: String -> IO ()
13:19:26 <koz_> Yeah, again, I should really think before answering. :P
13:19:29 <koz_> :t print
13:19:30 <lambdabot> Show a => a -> IO ()
13:19:33 <koz_> ^
13:19:37 <tabaqui1> print would be shorter, because it is basically "putStrLn . show"
13:19:38 <koz_> (I keep confusing those two)
13:20:01 <koz_> tabaqui1's suggestion of containers and unordered-containers is also a wise one.
13:20:42 <isn> Yeah, I've bookmarked it. Gonna read up on it asap! Thx guys :)
13:29:20 <OmegaDoug> EvanR Offloading the validation to the parser is an interesting idea. The date actually comes from a csv file which I'm parsing with Megaparsec.
13:32:26 <EvanR> yeah a Parser Timestamp should really never return something invalid, it should instead fail to parse
13:34:02 <OmegaDoug> It'll leave the parseUnixTimeGMT wrapper function open to invalid input, but performing the validation at the source should be good enough as this is a personal project.
13:34:34 <EvanR> sounds like you're parsing twice then
13:34:53 <OmegaDoug> I'm just passing the parsed data to a function to convert the date to a unix timestamp
13:35:15 <EvanR> parsing, validating, converting...
13:35:26 <EvanR> all sounds the same to me in megaparsec
13:36:24 <EvanR> you can split up your whole parsing validating converting process into multiple steps, but it'd behoove them not to overlap in responsibility
13:37:13 <OmegaDoug>  Each step done in Megaparsec?
13:37:40 <EvanR> first thing first have you looked at cassava
13:37:51 <OmegaDoug> No I have not.
13:38:12 <EvanR> since you're starting with CSV, i wonder how far that package would get you
13:42:16 <OmegaDoug> It looks like it could remove a fair bit of code actually. And it looks like I can take the datetime column and convert it to a timestamp.
13:42:27 <zincy_> When making requests with the Wreq library how do you have a JSON object as a FormValue in a request. https://hackage.haskell.org/package/wreq-0.5.3.2/docs/Network-Wreq-Types.html#t:FormValue
13:43:15 <OmegaDoug> I'll take a look now and see how it works out. It shouldn't be a large change to load the csv data through that lib
13:43:16 <OmegaDoug> Thanks
13:44:23 <isn> Is it possible to search by the second value in the list of tuples with the "lookup" function? 
13:45:13 <jle`> isn: lookup is sort of a very simplified function for some narrow use cases
13:45:32 <jle`> isn: in general you'd probably get better mileage out of a general function like 'find'
13:45:42 * hackage cdeps 0.1.3.0 - Extract dependencies from C code.  https://hackage.haskell.org/package/cdeps-0.1.3.0 (vmchale)
13:45:47 <lavalike> :t find
13:45:48 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
13:46:03 <jle`> > find (\(x,y) -> y == 3) (zip ['a'..'z'] [1..])
13:46:05 <lambdabot>  Just ('c',3)
13:46:12 <isn> Ah alright, I'll try to implement find then. Thanks :)
13:46:24 <jle`> lookup is sort of just a wrapper around find
13:46:42 <jle`> lookup x = fmap snd . find ((== x) . fst)
13:46:45 <lavalike> :t find . ((. snd) . (==))
13:46:46 <lambdabot> (Foldable t, Eq b) => b -> t (a, b) -> Maybe (a, b)
13:47:17 <jle`> lookup x = fmap snd . find (\(k,v) -> k == x)
13:49:11 * hackage conduino 0.2.0.0 - Lightweight composable continuation-based stream processors  https://hackage.haskell.org/package/conduino-0.2.0.0 (jle)
14:12:07 <zincy_> How do I use Aeson to parse a JSON object in a string?
14:12:50 <monochrom> decode and friends?
14:13:07 <zincy_> Yeah I am using decode and getting Error in $['myKey']: expected record (:*:), encountered String
14:13:30 <tabaqui1> https://xkcd.com/2200/
14:14:00 <tabaqui1> I've set "unreachable = error $(ALT_TEXT_FROM_THIS_COMIC)" and it is amazing
14:14:16 <tabaqui1> (unreachable is a replace for undefined)
14:14:27 <monochrom> :)
14:15:13 <monochrom> I don't know what the tell is (:*:) sounds like it's your own invention so you're using the wrong return type?  Because decode and friends are class-polymorphic over return types.
14:15:51 <monochrom> Hell now I don't know wth is "$['myKey']" either, is it even JSON syntax?
14:15:58 <isn> Alright, so I've managed to get morse code decoding working, but now I'm stuck when encoding. This is what I have so far: https://pastebin.com/hCBq7dtG - it fails on "encode = map toMorseCode". What am I doing wrong?
14:16:29 <monochrom> this is a rabbit hole leading down to a thousand lines of code I don't want to check so I don't want to know.
14:16:47 <zincy_> 'myKey' is what I substituted for the real key dont worry
14:16:57 <merijn> isn: String is [Char], right?
14:17:06 <isn> merijn: yes 
14:17:14 <zincy_> :*: isn't in my code
14:17:27 <merijn> isn: And "map :: (a -> b) -> [a] -> [b]"
14:17:56 <isn> Ah, it expects just Char instead of [Char]/String?
14:18:13 <merijn> isn: The input is right, but note that 'b' in your case is String
14:18:24 <monochrom> You probably like concatMap
14:18:27 <merijn> isn: So the result of the map is [String], not String
14:18:53 <merijn> monochrom: foldMap! The one true function!
14:19:04 <isn> Oh that's right! Do you know how I could break it down to just Chars?
14:19:11 <monochrom> This is one of those instances where if you delete "encode :: String -> String" the computer will be able to tell you what your code really means.
14:19:35 <merijn> isn: No, the input string *is* passed to toMorseCode one char at a time
14:19:44 <isn> Ok, I've deleted the function signature and now it's working lol
14:19:48 <merijn> isn: The problem is that you're not getting back single character results
14:20:18 <merijn> isn: Your initial result was String (i.e. [Char]) but what you got is [String] (i.e. [[Char]])
14:20:34 <merijn> isn: If you want a String, monochrom is right and you probably want concatMap
14:20:36 <merijn> :t concatMap
14:20:38 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
14:21:11 <monochrom> map toMorseCode "AB" = [".-", "-..."], but not ".--...".  This is how you discover and learn the gap from your current code to correct code.
14:21:13 <isn> Alright, I will look into that now. I'll let you know if it works. Thanks guys :)
14:22:10 <monochrom> There is a reason GHC offers ghci.
14:23:28 <merijn> I've found a flaw with ghcide...it's so fast at typechecking things without me even saving, that I forget to save and "cabal build" gives me the wrong messages, due to running on old input >.>
14:24:09 * geekosaur suspects intersperse isi even closer to what they really want, unless they really want them all run together like that
14:24:32 <roconnor> Has the behaviour of (read ".5" :: Double) changed in the last 5 years?
14:24:51 <monochrom> Now add auto-save-per-5-minutes so the error cannot be reproduced a few minutes later.  It's Halloween upon us any time now, this is the right thing to have!
14:24:51 <merijn> roconnor: Don't think so?
14:25:05 <geekosaur> I think it was changed for consistency with Haskell language spec, so that a leading zero is required?
14:25:35 <roconnor> geekosaur: if so, that would explain why my code seems to have bitrotted.
14:26:00 <shapr> Is there a Data.Text.join ?
14:26:02 <monochrom> IMO .5 should be non-sense.
14:26:30 <merijn> shapr: You mean "mconcat"? :p
14:26:39 <shapr> oh, thanks
14:27:08 <shapr> :t mconcat $ Data.List.intersperse "," ["foo","bar"]
14:27:09 <lambdabot> [Char]
14:27:13 <shapr> close enough
14:27:52 <merijn> So, does anyone else feel like FreeT is like a videogame?
14:28:05 <merijn> A puzzle videogame, that is
14:28:26 <merijn> You try random shit until it typechecks and if it does what you want, then you beat the level...
14:28:53 <monochrom> No but that sounds like Idris.
14:28:57 <geekosaur> some people program as if that described Haskell
14:29:29 <zincy_> I always feel guilty for trying random shit
14:29:34 <merijn> This would be a lot easier if I could query the type of a subexpression...
14:29:36 <zincy_> my IT teacher at school shamed me
14:29:43 <merijn> Too many moving parts
14:29:46 <monochrom> Also I don't play video games that way either.  If I don't understand the game I give up, I don't randomized.
14:30:26 <monochrom> But I can query the type of a subexpression. :)
14:30:35 <monochrom> I bet ghcide can, too.
14:30:56 <monochrom> In my case it's haskell emacs mode asking ghci.
14:31:22 <merijn> monochrom: According to the readme, yes, but then I have to figure out how to get this LSP plugin to ask ghcide the right way
14:31:28 <monochrom> (The ghci command is unfriendly to humans, best used through editor plugins, but it exists.)
14:32:08 <monochrom> This is why I just stick to haskell emacs mode.  (dante is also OK)
14:32:34 <merijn> monochrom: That only works if you use emacs :p
14:35:46 <merijn> Ah, the LSP hover function is disabled in the terminal by default, that was the problem
14:42:46 <maralorn> I am still looking for a Haskell release a project tutorial.
14:43:26 <maralorn> With steps like 1) what docu should I have 2) how do I do CI 3) how do I release on hackage …
14:44:25 <merijn> maralorn: With regards to step 2, have you seen: https://github.com/haskell-CI/haskell-ci/ ?
14:44:43 <merijn> maralorn: That generates a Travis-CI config from your cabal file/cabal.project file
14:45:31 <merijn> As for releasing on hackage you just need an account (and if you're creating one, mailing the admins to get uploader access)
14:53:29 <isn> I'm finally finished with a simple encoding/decoding morse code application in Haskell (my application so far: https://pastebin.com/RY50Z7yA).
14:53:40 <isn> Do you guys have any ideas/tips how I can improve this to make it more advanced?
14:53:51 <isn> Like, could I use classes etc?
14:55:27 <koz_> isn: First suggestion - [(k,v)] is not a good dictionary structure, so use something from containers or unordered-containers.
14:55:30 <merijn> isn: You could use a where block to make toMorseCode cleaner, but otoh I don't think there's much to be gained by adding more complexity or typeclasses
14:55:49 <merijn> koz_: That's not as straightforward as it initially seems
14:55:51 <koz_> You might also consider adding the capability to decode a whole string of Morse, rather than just one character.
14:55:55 <merijn> koz_: Since he uses it in both directions
14:56:12 <koz_> merijn: There is a bidirectional map on Hackage someplace, IIRC.
14:56:29 <merijn> koz_: Sure, but is that much better than the current list?
14:56:31 <koz_> But you're right, I did miss that.
14:56:39 <koz_> It's basically a pair of Maps AFAIK.
14:57:33 <merijn> isn: Anyway, that code looks, essentially, fine
14:58:48 <isn> Alright, thanks for checking it out. This is supposed to be a "big" programming challenge in which I show the professor that I've learned the language seriously. It just looks too simple, even though I've been working on it for a couple of hours now
14:59:13 <koz_> isn: That's an _extremely_ open-ended goal.
14:59:21 <isn> Exactly :p
14:59:30 <Cale> isn: Haha, you could turn it into a web application using reflex-dom :D
14:59:50 <koz_> Cale: Lol.
14:59:58 <merijn> isn: You could extend it to make it an executable that translates files/stdin from/to morse code
15:00:04 <isn> Cale: you know what, that actually sounds good! Or maybe include this in some GUI
15:00:12 <merijn> isn: That adds a bunch of IO, and some other stuff
15:00:23 <isn> merijn: you mean like reading/writing to/from files?
15:01:04 <Cale> There's a tutorial for reflex-dom here which should get you started enough that you could do a morse code translator pretty easily https://github.com/reflex-frp/reflex-platform
15:01:05 <merijn> isn: I would definitely recommend doing that in the commandline over doing a GUI/web if you want to make progress fast :p
15:01:50 <isn> merijn: yeah, fair enough :p thanks guys!
15:01:50 <merijn> isn: But writing a nice commandline parser to choose between translating from/to and which file(s) to read and write would add some nice filler to flesh it out
15:01:54 <Cale> But yeah, depends on when the project is due :)
15:02:19 <Cale> *I* could turn it into a web application in like 10-15 minutes, but I already know how to use that stuff :)
15:02:21 <merijn> Could even make it a streaming translater for stdin
15:02:29 <isn> merijn: nice!
15:02:35 <koz_> Or a Morse code translation REPL.
15:02:38 <merijn> Throw in some conduit/optparse-applicative
15:02:41 <koz_> Type in Morse, get out non-Morse.
15:02:44 <merijn> koz_: oh, nice idea
15:02:58 <koz_> Maybe have a command to switch?
15:03:03 <isn> merijn: I think I'm gonna go for that! That's sounds fun
15:03:20 <isn> Yeah commands like the ghci :set encode
15:03:22 <isn> :set decode
15:03:22 <isn> etc haha
15:03:38 <merijn> isn: besides conduit (for streaming) and optparse-applicative (for commandline parsing) I can also recommend haskeline for interactive prompts in the terminal
15:03:55 <merijn> You could even add a morse code tab completer with haskeline
15:05:17 <merijn> Oh, add prettyprinter so you can give fancy formatted error messages when someone enters illegal morse. Endless ways to extend this and make it a "real" program with non-trivial complexity
15:05:45 <sm[m]> brick-based TUI !
15:05:47 <koz_> merijn: A Morse code compiler? :P
15:05:48 <isn> I'm installing Haskeline now, gonna play around with it :)
15:06:13 <merijn> Not to mention, all those libraries I mentioned are super useful to know anyway if you ever wanna do any "real" Haskell :p
15:19:29 <siraben> Anyone know of a program that can convert MIDI files to notation like this? http://ix.io/20n2
15:19:32 <siraben> The left column is when to play the note, the right column is the pitch
15:19:45 <siraben> (the paste shown is the game of thrones theme)
15:20:27 <EvanR> use the midi package and whip that out with a couple lines of good ol fashioned functional programming xD
15:22:27 <koz_> EvanR: So by that you mean 'lists and (McCarthy) LISP', amirite? :P
15:22:46 <EvanR> pretty much
15:22:50 <siraben> Hm, https://hackage.haskell.org/package/midi has no documentation
15:22:57 <koz_> (though the 'good' qualifier might be amiss there)
15:23:03 <EvanR> try one version back
15:23:20 <EvanR> hackage autogenerates documentation once a year 
15:23:21 <koz_> Yeah, Hackage generates documentation not-well sometimes.
15:23:30 <siraben> EvanR:  Wowza
15:23:44 <EvanR> exaggerating, but when you use the lib for real you can build local docs
15:24:33 <EvanR> oh dang, it's Henning Thielemann, so all the types names are T
15:24:38 <roconnor> Is it just me, or does (Data.Digest.SHA1.hash []) go into an infinite loop?
15:24:38 <koz_> This is something to add to the maralorn list: when you upload a package to Hackage, gen the docs and upload them too.
15:24:38 <EvanR> good luck :)
15:24:57 <koz_> EvanR: Yeah, Henning 'I want Haskell to be ML and I won't let anyone tell me different' Thielemann. :P
15:27:38 <HaskellNoob> Hello
15:27:54 <HaskellNoob> I have run into a type error with a problem I have been working on
15:28:01 <HaskellNoob> This is the error code and my code:
15:28:02 <HaskellNoob> https://imgur.com/a/1uwWn00
15:28:30 <HaskellNoob> I know what the error is I just don't know how to fix it
15:29:18 <Axman6> you're passing listValues to unlines, which doesn't make sense
15:29:28 <Axman6> I think you want putStrLn . unlines . listValues
15:29:30 <HaskellNoob> right yeah I understand that
15:29:30 <monochrom> This is why you should never use $
15:29:43 <Axman6> u wot?
15:29:53 <monochrom> You're writing "(putStrLn . unlines) listValues" you mean "putStrLn . unlines . listValues"
15:30:13 <EvanR> $ is the # of all evil
15:30:51 <essentiality[m]> I love that documentation at listValues
15:30:57 <yushyin> how about some fun mixing of & and $?
15:30:57 <monochrom> Likewise the difference between "sin (sqrt)" and "sin . sqrt".
15:31:19 <koz_> EvanR: You mean the sqrt . All $ evil? :P
15:31:31 <koz_> (YES I KNOW IT DOESN'T TYPECHECK)
15:31:35 <koz_> (ahe)
15:31:38 <koz_> (ahem*)
15:32:01 <monochrom> Don't use $ until you understand function application.  Don't use "do" until you understand >>= .
15:32:17 <HaskellNoob> printValues = putStrLn . unlines . listValues
15:32:23 <HaskellNoob> was what I meant to have initially
15:32:23 <monochrom> Don't drive cars until you understand traffic lights etc.
15:32:33 <HaskellNoob> Which is still wrong but Im not sure how to fix it still ;/
15:32:38 <EvanR> application vs composition, getting mixed up right now in some other unnamed languages
15:33:00 <HaskellNoob> Can I wrap these functions in some other function or something
15:33:15 <crestfallen> hi how to get this to work:
15:33:35 <crestfallen> :t pure ((->) r)
15:33:37 <lambdabot> error: parse error on input ‘->’
15:34:00 <Axman6> HaskellNoob: wrong how?
15:34:15 <lavalike> crestfallen: you're mixing values and type in one expression
15:34:18 <koz_> crestfallen: ((->) r) is a type, not a value.
15:34:26 <koz_> lavalike: I owe you a soda.
15:34:27 <glguy> % :t pure @((->) Int)
15:34:27 <yahb> glguy: a -> Int -> a
15:34:45 <glguy> You need to 1) pick a type and 2) use type application syntax to apply pure to a type
15:34:52 <HaskellNoob> Actual type: [[Integer]]. expected [[Int]]
15:34:54 <HaskellNoob> how to fix
15:35:16 <monochrom> Then the problem is elsewhere.
15:35:23 <lavalike> koz_ (:
15:35:41 <merijn> glguy: You forgot step 3 "remove type applications because you prefer robust code" >.>
15:35:56 <crestfallen> ok thanks kindly koz_ glguy. so it has no type until you give one to r
15:36:12 <HaskellNoob> Yes monochrom 
15:36:23 <HaskellNoob> my listValues is of type Int
15:36:26 <HaskellNoob> and so is valueOf
15:36:37 <koz_> crestfallen: No, it just doesn't make sense. You can use type applications to specify what Applicative you want pure to be in, but types aren't values. 
15:36:51 <koz_> (this is what glguy demonstrated above)
15:36:55 <essentiality[m]> maybe you can put the code on repl.it ? would make it easier to check
15:37:38 <crestfallen> koz_: right I think I get it but said it poorly..
15:37:49 <merijn> https://i.imgflip.com/3ets0f.jpg >.>
15:39:10 <crestfallen> because ((->) r) is abstracted for the instance declaration of applicative for functions
15:39:10 <HaskellNoob> https://repl.it/@MistroSphere/HelpMePlease
15:40:04 <HaskellNoob> Are people able to edit that repl.it link?
15:40:27 <essentiality[m]> https://repl.it/@mehlon/HelpMePlease
15:40:40 <essentiality[m]> seems functional so far
15:41:52 <essentiality[m]> editing automatically forks the project to your own account on repl.it
15:41:52 <HaskellNoob> try printValues tP where tP = [[4,0,0],[0,0,3],[0,2,0]]
15:42:05 <crestfallen> % :t pure @((->) Int)
15:42:05 <yahb> crestfallen: a -> Int -> a
15:42:17 <crestfallen> so what is that command in ghci ?  ^
15:42:54 <lavalike> :seti -XTypeApplications
15:42:54 <koz_> In GHCi, you have to do :set -XTypeApplications first.
15:42:59 <koz_> Then it's exactly the same.
15:43:04 <crestfallen> cool thanks
15:43:20 <essentiality[m]> also works with output cyy yyb yay
15:44:06 <HaskellNoob> WHAT how
15:44:25 <essentiality[m]> check my repl.it link again, its updated
15:44:57 <essentiality[m]> so clearly the function works as intended
15:45:18 <essentiality[m]> it's some other code that's making it break
15:45:49 <HaskellNoob> thats all the code for that attempts 
15:48:02 <sm[m]> relp.it.. nice
15:48:09 <sm[m]> repl, even
15:49:12 <crestfallen> % :t pure @((->) Int)  -- so when we 'use type application syntax to apply pure to a type' , is that because ((->) r) is partial application   ?
15:49:12 <yahb> crestfallen: a -> Int -> a
15:49:58 <koz_> crestfallen: No, not exactly.
15:49:59 <merijn> oooh!
15:50:02 <koz_> % :t pure
15:50:02 <yahb> koz_: Applicative f => a -> f a
15:50:09 <koz_> ^ any Applicative will do
15:50:15 <koz_> % :t pure @((->) Int)
15:50:15 <yahb> koz_: a -> Int -> a
15:50:26 <koz_> ^ _only_ the specific Applicative that is ((->) Int) will do.
15:50:56 <merijn> ApplicativeDo has the effects happen in order that they're written down? i.e. if I want to change the order of effects wrt order I consume the arguments then ApplicativeDo will make my life better?
15:51:05 <essentiality[m]> you can use the "invite" button on repl.it to make collaborative code
15:51:20 <essentiality[m]> but it's freemium so there's only 3 editors allowed lol. https://repl.it/join/hysylbjr-mehlon
15:51:43 <crestfallen> koz_: ok thanks will read up on it.
15:51:56 <essentiality[m]> see if it works for you @HaskellNoob 
15:56:16 <monochrom> freemium = threemium? :)
15:56:48 <koz_> monochrom: such pun
15:57:12 <merijn> hmmm, the GHC user guide on ApplicativeDo is rather...slim
15:57:24 <essentiality[m]> yep
15:58:37 <monochrom> There is probably some GHC flag to dump the desugaring of ApplicativeDo so you can check.
15:58:48 <merijn> "do { x <- foo; y <- bar; pure (f y x) }" <- this will still run foo first and bar second, yes?
15:59:13 <jle`> merijn: it depends on the applicative technically
15:59:22 <jle`> merijn: but you can know at least that <*> will ahve foo on the left and bar on the right
15:59:45 <monochrom> I wouldn't commit to "runs first" but it's possible to just state how <*> is used.
15:59:48 <merijn> monochrom: I prefer documented guarantees over "statements generalised from a single sample of the generated code"
15:59:55 <jle`> and changing the order of effects while changing the order of consumption is is the main reason why i use ApplicativeDo
16:00:22 <roconnor> More tricky question: has the strictness of accumArray changed in the last 5 year (so that you cannot refer to the constructed array in the values of the array?)
16:00:52 <jle`> merijn: it will be first w.r.t. to left-to-rightness in <*>s
16:00:59 <monochrom> As usual the guarantee is probably hiding in some academic paper...
16:01:08 <merijn> jle`: That's what I meant, yeah
16:01:24 <merijn> This dramatically simplifies my life, whoo!
16:01:36 <HaskellNoob> Yeah your code is the same as mine :()
16:01:42 <monochrom> Oh but I think here is the guarantee: "Applicative do-notation desugaring preserves the original semantics, provided that the Applicative instance satisfies <*> = ap and pure = return"
16:01:49 <merijn> Although that means I just wasted like a day trying to solve a problem I don't need
16:01:51 <jle`> i think of it as ????? <$> foo <*> bar <*> each <*> other <*> line <*> inyour <*> block
16:02:18 <jle`> it just <*>'s together each line in your block and generates a fmapping function in the end to munge it all together
16:02:18 <monochrom> in which "original semantics" means monadic do
16:02:57 <jle`> monochrom: that only helps in the case where m is monadic
16:03:28 <monochrom> OK but you add a meta version of parametricity at the level of writing GHC.
16:03:40 <jle`> list comprehension syntax is probably more well-suited for 'applicative do'-like things
16:03:51 <monochrom> GHC is not going to go out of its way to "let me generate code some other way if I see your type is not monadic".
16:03:56 <jle`> we should have done ApplicativeComprehensions, not ApplicativeDo
16:04:18 <glguy> roconnor: In my local GHC 8.4.4 I can do that and I can't in 8.6.5
16:04:19 <jle`> [ f y z | x <- foo; y <- bar ]
16:04:28 <jle`> s/;/,
16:04:36 <roconnor> glguy: you are a prince!
16:04:39 <jle`> then that gets rid of the awkward special-casing of pure
16:04:52 <jle`> and that whole nightmare where pure $ x would be different than pure x for a while
16:05:19 <monochrom> You have convinced me!
16:05:56 <jle`> the rules are much simpler too, it would be just that x and y are only in scope for the "final" [ .. | segment and not in any other part of the comprehension
16:06:05 <jle`> i wonder why this didn't happen ... i'm sure it cam eup
16:06:35 <monochrom> Probably only becasue do is more popular than comprehension. Recall that MonadComprehension exists and no one uses it.
16:07:00 * glguy drags MonadComprehensions out every once and a while
16:07:22 <monochrom> Likewise C programmers are going to wish for "lambda in C" rather than doing the right thing: switching to Haskell.
16:07:42 <jle`> the main thing that bugs me with ApplicativeDo is the special casing of pure
16:07:54 <HaskellNoob> monochrom thanks for your help I figured it out
16:08:20 <jle`> oh! and also that let's dont work as you expect
16:08:30 <monochrom> Yikes.
16:08:32 <jle`> instead of do blah; blah; let x = 10; pure (x + 3)
16:08:38 <merijn> Let sucks anyway :p
16:08:45 <jle`> you have to do blah; blah; pure (let x = 10 in x + 3)
16:08:59 <glguy> I think it gets used more than TransformListComp at least :)
16:09:01 <roconnor> glguy: http://hackage.haskell.org/package/Crypto-4.2.5.1/docs/src/Data-Digest-SHA1.html#oneBlock uses accumArray in a very very awkard way (that only does listArray) that seems to be broken by the change in behaviour of accumArray.
16:09:05 <jle`> you have to float (sink?) all your lets into the pure
16:09:05 <merijn> Only reason to use them is if you use monadic return values
16:09:19 <jle`> let's are useful just to name intermediate values
16:09:25 <monochrom> If I don't float-sink my let into the final pure, what happens?
16:09:29 <jle`> since naming can be useful for readability and stuff
16:09:30 <roconnor> glguy: I'll try to submit a patch that replace accumArray with listArray (which seems to still allow recursion).
16:09:39 <jle`> monochrom: it doesn't fit one of the special-case rules of ApplicativeDo
16:09:42 * hackage hapistrano 0.3.10.0 - A deployment library for Haskell applications  https://hackage.haskell.org/package/hapistrano-0.3.10.0 (juanpaucar)
16:09:46 <jle`> monochrom: so it is parsed as monadic do
16:09:49 <monochrom> Ah.
16:10:11 <jle`> % do x <- Const "hi"; y <- Const "bye"; let z = 10; pure (x + 3)
16:10:11 <yahb> jle`: ; <interactive>:38:63: error: parse error (possibly incorrect indentation or mismatched brackets)
16:10:41 <jle`> er well pretend that gave "Const is not a Monad" error instead
16:10:52 <jle`> % do x <- Const "hi"; y <- Const "bye"; let {z = 10}; pure (x + 3)
16:10:52 <yahb> jle`: ; <interactive>:39:4: error:; * Could not deduce (Monad (Const [Char])) arising from a do statement; from the context: Num b bound by the inferred type of it :: Num b => Const [Char] b at <interactive>:39:1-64; * In a stmt of a 'do' block: x <- Const "hi"; In the expression:; do x <- Const "hi"; y <- Const "bye"; let z = 10; pure (x + 3); In
16:11:15 <jle`> % do x <- Const "hi"; y <- Const "bye"; pure (let z = 10 in z + 3)
16:11:15 <yahb> jle`: ; <interactive>:40:4: error:; * Could not deduce (Monad (Const [Char])) arising from a do statement; from the context: Num b bound by the inferred type of it :: Num b => Const [Char] b at <interactive>:40:1-64; * In a stmt of a 'do' block: x <- Const "hi"; In the expression:; do x <- Const "hi"; y <- Const "bye"; pure (let z = 10 in z + 3); In an equa
16:11:25 <jle`> % :set -XApplicativeDo
16:11:25 <yahb> jle`: 
16:11:31 <jle`> % do x <- Const "hi"; y <- Const "bye"; pure (let z = 10 in z + 3)
16:11:31 <yahb> jle`: Const "hibye"
16:11:44 <jle`> % do x <- Const "hi"; y <- Const "bye"; let {z = 10}; pure (z + 3)
16:11:44 <yahb> jle`: ; <interactive>:43:21: error:; * Could not deduce (Monad (Const [Char])) arising from a do statement; from the context: Num b bound by the inferred type of it :: Num b => Const [Char] b at <interactive>:43:1-64; * In a stmt of a 'do' block: y <- Const "bye"; In the expression:; do x <- Const "hi"; y <- Const "bye"; let z = 10; return (z + 3); 
16:11:57 <jle`> so yeah that's kind of annoying, how it's all kind of just special cases
16:12:10 <jle`> if we had ApplicativeComprehensions, 'let' is already handled perfectly well :)
16:12:22 <merijn> jle`: Patches welcome? *ducks*
16:12:53 <jle`> i wouldn't particularly mind a patch, it's just the special casing that bugs me i suppose
16:12:59 <jle`> i would always wonder if this or that worked or didn't work
16:13:18 <jle`> note i wasn't even confident enough to write pure $ let z = 10 in z + 3
16:18:51 <lavalike> do it
16:19:54 <wroathe> So I've got an FFI routine that deletes an element from a set and either the original passed in pointer if the root node remains the same, or a different pointer for one of the children depending on what's deleted. 
16:20:21 <wroathe> https://gist.github.com/JustinChristensen/cef184d59b814beca6a67935f01fe656
16:21:25 <wroathe> Here's what the quickcheck property to test this looks like. For some reason ct' is always different pointer than ct, even when it's supposed to be the same
16:21:45 <wroathe> Does Haskell FFI return the underlying pointer from the actual FFI or does it do some form of translation?
16:24:12 <wroathe> Whoops, nvm, my code appears to be wrong. Ignore this question.
16:26:09 <roconnor> I wonder if the change in strictness of accumArray is a bug or a feature.
16:26:55 <isn> I have a String/[Char] with a prefix ":encode MESSAGE". This string is being printed inside outputStrLn with a function called 'encode', like this: outputStrLn (encode input). This means that the :encode prefix also gets encoded. How would I remove the prefix of this string? Tips?
16:27:08 <crestfallen> > (+) <$> (+3) <*> (*100) $ 5   -- does 8 and 500 resolve into functors first, before being passed to fmap (+)      ?   If so, what kind of functor is it?
16:27:10 <lambdabot>  508
16:27:45 <crestfallen> not resolve into, but put into..
16:28:27 <glguy> That's just using the "instance Functor ((->) r)"
16:28:43 <glguy> Nothing has to resolve or put, functions are an instance of Functor
16:29:00 <glguy> and Applicative
16:29:51 <crestfallen> that's interesting I see glguy.. that makes me wonder if I have more questions about it. thanks. 
16:30:33 <crestfallen> so yes any function can be fmapped over
16:31:26 <crestfallen> so it looks like   (+) <$> (5+3) <*> (5*100) or something ?
16:31:46 <isn> Nvm, got it :)
16:31:55 <crestfallen> (in the interim..)
16:31:55 <dmwit> No, it looks like (+) (5+3) (5*100).
16:33:15 <jle`> crestfallen: (+) <$> (+3) <*> (*100) turns into \x -> (+) (x + 3) (x * 100)
16:35:20 <dmwit> `(+) <$> (+3)` turns into `\x -> (+) (x+3)`. `(\x -> (+) (x+3)) <*> (*100)` turns into `\y -> (\x -> (+) (x+3)) y (y*100)`, which is morally the same as `\y -> (+) (y+3) (y*100)`.
16:35:37 <crestfallen> but wouldn't that mean that there's a distinction between fmapping over functions, and a binary operation?
16:36:02 <dmwit> What is a binary operation, if not a function?
16:36:21 <dmwit> No. Don't answer that.
16:36:38 <EvanR> i'll wait until tomorrow to answer that
16:36:39 <dmwit> Let me say, instead: a binary operation is a function. Specifically, it is a function which returns a function.
16:36:39 <int-e> dmwit: now I'm confused.
16:36:44 <dmwit> That way it is firm, and less confusing.
16:36:57 <int-e> (oops, two seconds too late)
16:37:39 <wikiemol> Is GHCJS still a thing? 
16:37:49 <monochrom> Yes.
16:38:59 <crestfallen> so we need <$> to get into the ' ... <*> ... ' bit
16:40:03 <crestfallen> I take it, dmwit  ,  jle`
16:43:13 <dmwit> I don't know what that means.
16:44:10 <dmwit> ...but the answer is almost certainly "no, there are other ways to do that".
16:44:47 <monochrom> I would just simplify it to "no". >:)
16:45:54 <monochrom> General rule of thumb is if you haven't accumulated the experience of 10000 exercises you are not ready to formulate any "intuitive" wordy model.
16:46:36 <int-e> crestfallen: you /may/ think of it as  pure f <*> x = f <$> x  (though the latter works for arbitrary Functors, not just Applicatives)
16:49:13 <dmwit> 10000 is a lot.
16:49:35 <dmwit> Perhaps you simply believe that nobody is ready to formulate an intuitive, wordy model of anything.
16:50:23 <monochrom> I know right?  Some people become world chess champions after only 1000 games, some others will never make it even after 10^10.
16:50:41 <monochrom> And some, just 100.
16:51:50 <monochrom> But chess and applicatives are alike in this regard.  There exists n for you such that if you haven't played n games your intution is wrong.
16:53:04 <isn> Anyone here who has experience with Haskeline?
16:53:15 <dmwit> ?where justask
16:53:16 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
16:53:31 <monochrom> ?where dontanswer
16:53:31 <lambdabot> I know nothing about dontanswer.
16:53:39 <monochrom> I need to add that one.
16:54:01 <isn> Can someone explain this line to me? loop :: (String -> InputT IO (Maybe String)) -> Int -> InputT IO () - It's from the default Haskeline setup
16:54:28 <jackdk> isn: what have you concluded so far? don't want to retread over what you already know
16:55:27 <isn> I know that the loop function takes a function and a number and returns InputT and then IO?
16:55:43 <Axman6> have you read the documentation for the function?
16:55:50 <isn> Arent InputT and IO separate things?
16:56:06 <Axman6> InputT looks like a Monad transformer to me
16:56:18 <isn> No, I couldn't find it. I just got this code from an example of Haskeline
16:57:28 <dmwit> (Yes, it's a transformer. A big ol' stack of ReaderTs over preferences and stuff. Some IORefs in there, too, for bad measure.)
16:57:32 <jackdk> there is no loop in the haddocks, so I suspect it's not part of the library. you will need to pastebin relevant parts of the example
16:57:48 <Axman6> have you read https://hackage.haskell.org/package/haskeline-0.7.5.0/docs/System-Console-Haskeline.html?
16:59:05 <isn> Axman6: Thanks for the link! I need to learn more about Monads probably to better understand all this
17:00:20 <Axman6> well even if you don't understand monads, you can probably get a long way by reading that page and following the exampe at the top
17:55:20 <koz_> Is there a reason why IVars from Control.Monad.Par aren't Functors?
17:57:23 <nshepperd> because you can write into it?
17:58:32 <koz_> But only once, right?
17:58:46 <koz_> So once the value is written, it can't ever change.
17:59:00 <nshepperd> once is enough to break things
17:59:25 <koz_> Oh I think I see.
17:59:56 <koz_> If you fmap an IVar a into an IVar b while empty, it's 'expecting' an a, which it then can magic into a b, but we don't see that from its type.
18:01:05 <nshepperd> do { (i :: IVar Void) <- new; put (fmap absurd i) ("I'm a string"); get i } :: Par Void
18:01:19 <koz_> Yeah, point taken.
18:01:30 <koz_> I kinda wonder why IVars don't have a phantom tag indicating they're 'full'.
18:02:37 <nshepperd> otoh if you want to fmap over an IVar you can wrap it coyoneda 
18:02:57 <nshepperd> which gives you an 'original type' write end, and a read-only fmappable read end
18:11:19 <shachaf> Presumably you can also make a write-only end which you can contramap over.
18:14:16 <nshepperd> yep! you can make it a profunctor
18:14:31 <shachaf> Also true.
18:14:54 <shachaf> Foo f a b = exists x. (f x, a -> x, x -> b)
18:14:59 <shachaf> Does that have a name?
18:15:34 <nshepperd> i called it 'proyoneda' once :p
18:15:49 <koz_> LOL @Proyoneda.
18:15:51 <shachaf> Hmm, there's probably also a universal version?
18:16:00 <koz_> This Yoneda person was really good at stuff. :P
18:16:56 <koz_> But that's a really neat idea, thank you!
18:17:27 <koz_> Does 'fullness' matter for the Proyoneda Par?
18:19:00 <nshepperd> nope
18:19:37 <shachaf> Why not?
18:19:48 <shachaf> What does the contravariant universal Yoneda look like?
18:20:37 <shachaf> Oh, right.
18:20:59 <nshepperd> err, that was to koz
18:21:45 <nshepperd> but yeah, I also don't think forall x. (f x, a -> x, x -> b) is likely to be useful
18:22:14 <nshepperd> since a needs to be Void and b needs to () for those functions to exist
18:22:34 <shachaf> I don't mean that.
18:22:44 <shachaf> I mean an analog to "forall r. (a -> r) -> f r"
18:23:23 <dolio> shachaf: It's the actual yoneda embedding.
18:23:44 <dolio> Not the one us peasants use.
18:24:26 <nshepperd> https://hackage.haskell.org/package/kan-extensions-5.2/docs/Data-Functor-Contravariant-Yoneda.html
18:24:32 <shachaf> Right.
18:25:04 <shachaf> So I think "forall r. (r -> a) -> (b -> r) -> f r" should work?
18:25:14 <dolio> Yeah.
18:25:14 <shachaf> It's a profunctor at least.
18:25:26 <shachaf> I guess I want it to be cofree or something.
18:26:08 <shachaf> Why is this the actual yoneda embedding?
18:26:50 <dolio> I mean `forall r. (r -> a) -> f r` is the real one.
18:27:04 <dolio> Because presheaves.
18:27:27 <shachaf> Oh, sure.
18:28:31 <shachaf> I think you can call (exists x. (f x, x -> a)) and (forall r. (a -> r) -> f r) the free and cofree functors on a type constructor or something along those lines.
18:28:49 <dolio> Yeah.
18:32:14 <dolio> I imagine the one with both is (co)free profunctor.
18:33:49 <dolio> Although I guess that's less well defined.
18:37:10 <dolio> Because you have to say what `f ~> p` is where f :: * -> *, and p a profunctor.
18:39:06 <shachaf> I suppose something like (exists x y. (f x y, a -> x, y -> b)) would be more straightforward.
18:39:21 <dolio> Yeah, that one's more obvious.
18:40:38 <dolio> I think there might be an equivalence with `f a -> p a a`.
18:41:02 <shachaf> Right, I was thinking something along those lines.
18:44:45 <dolio> `f e -> p e e` ~ `f e -> (e -> a) -> (b -> e) -> p a b` ~ `(∃e. f e × (e -> a) × (b -> e)) -> p a b`
18:54:08 <dolio> Same sort of thing works for the reversed direction.
18:58:44 <jusss> about IO, there's no IO transformer, 'cause IO is not a type constructor, how we can handle IO effect with monad if we want?
18:59:33 <jusss> in the do notation, if IO is the monad, then what its value look like?
18:59:50 <jusss> if Maybe is the monad, we know the value is like Just 3 or Nothing
18:59:56 <jusss> :t IO
18:59:57 <lambdabot> error:
18:59:57 <lambdabot>     • Data constructor not in scope: IO
18:59:57 <lambdabot>     • Perhaps you meant ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
18:59:59 <Axman6> basically IO has to be the bottom of your stack
19:00:55 <jusss> Axman6: IO monad is in which module? what is its type?
19:02:18 <dmwit> The Prelude exports IO.
19:02:24 <dmwit> It does not have a type; it *is* a type.
19:02:59 <dmwit> (Yes, I know, TypeInType. "IO does not have a type" is a useful white lie for beginners.)
19:03:48 <dmwit> Your claim "IO is not a type constructor" is incorrect.
19:03:59 <dmwit> As for what values of type `IO X` look like, here's a few:
19:04:04 <dmwit> :t putStrLn "hi, jusss!"
19:04:06 <lambdabot> IO ()
19:04:06 <dmwit> :t getLine
19:04:08 <lambdabot> IO String
19:04:17 <dmwit> :t readFile "/dev/null"
19:04:19 <lambdabot> IO String
19:05:57 <jusss> dmwit: then why not IOT?
19:06:49 <Axman6> jusss: you're not supposed to (and don't need to) know how IO is defined. you are given hundreds of functions which work in IO, and know that it is a Functor, Applicative and Monad, which lets you combine these functions together into programs
19:08:40 <jusss> Axman6: ok, what about that IO lift function ? 
19:08:42 <dmwit> jusss: The question is a bit strange, I think. First you have to say what IOT would be if it existed. And "IOT is a transformer version of IO" isn't enough. You have to say what behavior it would have, what its (>>=) would do. Then I can answer why not that.
19:09:33 <jusss> I heard there's a function has to do with IO about other monads, I forget that function name
19:09:35 <EvanR> IOT would infringe on internet of things
19:09:42 <EvanR> not allowed
19:10:17 <jusss> liftIO
19:10:33 <dmwit> You heard correctly. There is, indeed, a function named liftIO.
19:10:35 <Axman6> :t liftIO
19:10:36 <lambdabot> MonadIO m => IO a -> m a
19:11:30 <Axman6> liftIO lets you take something in the IO monad and embed it into another monad - one which will eventually (probably) be unwrapped into IO in your main function
19:12:04 <Axman6> % liftIO (print True) :: EitherT String IO Bool
19:12:04 <yahb> Axman6: ; <interactive>:44:24: error:; Not in scope: type constructor or class `EitherT'; Perhaps you meant `Either' (imported from Prelude)
19:12:07 <jusss> how I can lift the value from IO to Maybe?
19:12:12 <dmwit> You cannot.
19:12:23 <Axman6> % runExceptT (liftIO (print True) :: ExceptT String IO Bool)
19:12:24 <yahb> Axman6: ; <interactive>:45:13: error:; * Couldn't match type `()' with `Bool'; Expected type: ExceptT String IO Bool; Actual type: ExceptT String IO (); * In the first argument of `runExceptT', namely `(liftIO (print True) :: ExceptT String IO Bool)'; In the expression: runExceptT (liftIO (print True) :: ExceptT String IO Bool); In an equation for `it': it = runExceptT (liftIO (
19:12:52 <Axman6> % runExceptT (liftIO (print True) :: ExceptT String IO ())
19:12:52 <yahb> Axman6: True; Right ()
19:13:01 <Axman6> % :t runExceptT (liftIO (print True) :: ExceptT String IO ())
19:13:01 <yahb> Axman6: IO (Either String ())
19:14:21 <jusss> Axman6: I see, liftIO can lift the value into another monad, but the another monad still in IO ?
19:14:45 <jusss> lift other monad into the IO monad
19:15:04 <dmwit> All the instances of MonadIO I know of are transformer stacks with IO at the bottom of the stack.
19:15:13 <nshepperd> the existence of a monad transformer is something which deserves more justification than its nonexistence
19:15:59 <jusss> dmwit: can I lift Mayber Monad's value into an Either Monad?
19:16:16 <dmwit> Sometimes.
19:16:28 <jusss> dmwit: example?
19:16:28 <dmwit> Well. Let's be very careful.
19:16:31 <dmwit> Either is not a Monad.
19:16:37 <jusss> Either a
19:16:37 <dmwit> It has the wrong kind.
19:16:44 <dmwit> Yes. So now my answer is: sometimes.
19:16:45 <jusss> dmwit: Reader
19:16:48 <dmwit> Specifically: when a is inhabited.
19:17:19 <jusss> dmwit: I just want to know if it's not IO,  can we lift the value of a monad from the monad to another monad?
19:17:39 <dmwit> If `x :: a`, then `maybe (Left x) Right` lifts a `Maybe b` into `Either a b`.
19:17:48 <dmwit> Sometimes.
19:18:29 <dmwit> :t \x -> maybe (Left x) Right
19:18:30 <lambdabot> a -> Maybe b -> Either a b
19:18:53 <jusss> :t maybe
19:18:54 <nshepperd> there's nothing special to Monads that enables lifting
19:18:55 <lambdabot> b -> (a -> b) -> Maybe a -> b
19:19:34 <dmwit> (Indeed, given that the answer to the more specific question of "can I lift Maybe to Either a" is "sometimes", the answer to "can I lift a value from one monad into another" *has to be* "sometimes". No other answer can be correct.)
19:20:19 <shachaf> It could also be "never, since the word lift is meaningless".
19:20:50 <nshepperd> generally, 'lifting' is just turning type a into type b. the answer to whether you can do that is 'it depends on a and b'
19:21:02 * dmwit slaps shachaf over the head with a copy of the Gricean axioms
19:21:52 <nshepperd> the MonadTrans typeclass provides one concept of 'lifting' that works for some types
19:24:31 <maerwald> would have been too easy to call it MonadLift
19:25:19 <dmwit> I don't think it's unreasonable for the class name and the method name to differ.
19:25:29 <dmwit> The class name describes the type. The method name describes the action.
19:25:36 <maerwald> MonadBaseControl is even worse... it sounds like a joke, not a typeclass
19:25:49 <maerwald> can never get used to it :P
19:26:13 <maerwald> it all started with autobots...
19:26:19 <maerwald> and now we have funny names everywhere
19:26:41 <nshepperd> even haskell programmers need a base of control sometimes
19:27:02 <mniip> monadbasecontrol
19:27:04 <wejetheman> dmwit are you one of the guys who was explaining about the efficiency of my toBinary function the other night?
19:27:12 <mniip> ah er that was the joke
19:27:47 <EvanR> or was it the performance lads
19:28:55 <wejetheman> Im asking if he was one of said lads.
19:30:25 <maerwald> https://hackage.haskell.org/package/wizard-0.1.1/docs/Wizard.html#v:leviosa
19:30:32 <maerwald> better name than lift
19:31:34 <dmwit> wejetheman: I believe no. But I suspect I could answer a question if you had one.
19:35:35 <koz_> 'The performance lads' LOL
19:36:11 <wejetheman> the meme would be better if i could remember who they were 
19:36:25 <dmwit> the slow is bad lads
19:36:51 <dsal> Base control to monad Tom
19:37:05 <wejetheman> dmwit sure, basically they were explaining how toBinary''' here http://codepad.org/Vv7fsbhS was inefficient so I made a couple of stabs at improving it toBinary' and toBinary there
19:37:56 <wejetheman> i was wondering if the final version fixed the concerns they were talking about and infact scaled at O(1)
19:37:59 <dsal> wejetheman: how are you deciding what's efficient?
19:39:04 <wejetheman> jeez idk, they just said it was bad and i really want to fix it :(
19:39:31 <dsal> wejetheman: I like criterion, but you have to be careful when using it.
19:40:42 * hackage doclayout 0.2.0.1 - A prettyprinting library for laying out text documents.  https://hackage.haskell.org/package/doclayout-0.2.0.1 (JohnMacFarlane)
19:43:21 <dmwit> criterion isn't going to tell you about the asymptotics of a function in a reliable way.
19:44:22 <dsal> No, but the bounds here are pretty small.
19:44:37 <dmwit> wejetheman: I don't like your toBinary''. But the others look fine to me.
19:44:41 <nshepperd> toBinary' seems reasonable
19:44:50 <dmwit> None of them handle negative numbers. ;-)
19:44:58 <dsal> :t divMod -- wejetheman 
19:44:59 <lambdabot> Integral a => a -> a -> (a, a)
19:45:03 <nshepperd> toBinary seems reasonable but 'toBinary' looks like a bug
19:45:14 <nshepperd> er, but 'f _ 0 = [0]' looks like a bug
19:45:27 <dmwit> I think not a bug.
19:45:33 <dmwit> But it is subtle. =)
19:45:45 <dmwit> You won't hit that case through recursion ever.
19:46:06 <dmwit> f l 1 is the base case. f _ 0 is an edge case that will never be called by the other clauses of f.
19:46:20 <dmwit> (Only by toBinary itself.)
19:46:21 <wejetheman> right dmwit, its not for recursion, the test it gets plugged into for the exercise tests it with 0
19:46:42 <wejetheman> but not any negative numbers
19:46:54 <nshepperd> ah, that's true
19:46:57 <dmwit> I'd be tempted to lift the special case out one level, to reduce the number of checks needed in the inner loop.
19:47:01 <dmwit> But it won't matter much.
19:47:03 <nshepperd> not a bug but perhaps some kind of spider
19:48:46 <nshepperd> i'd prefer to write it the same way as the next line
19:49:23 <nshepperd> then if you swapped the arguments of f it would be a difflist implementation
19:54:04 <wejetheman> well thanks for taking a look guys, i think i can finally lay this one to rest and continue on to the next exercise without this nagging at the back of my brain
19:54:11 <dsal> > reverse . unfoldr (\x -> if x == 0 then Nothing else let (d,r) = x `divMod` 2 in Just (r,d)) $ 6
19:54:13 <lambdabot>  [1,1,0]
19:54:30 <dsal> Writing code on my phone is annoying. Heh
19:54:57 <wejetheman> > [1..10]
19:55:00 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
19:55:03 <wejetheman> thats neat
19:55:41 <dsal> > reverse . unfoldr (\x -> if x == 0 then Nothing else let (d,r) = x `divMod` 2 in Just (r,d)) <$> [1..5]
19:55:43 <lambdabot>  [[1],[1,0],[1,1],[1,0,0],[1,0,1]]
20:01:42 * hackage reg-alloc-types 0.1.0.0 - Types used in register allocation API  https://hackage.haskell.org/package/reg-alloc-types-0.1.0.0 (MatthewFarkasDyck)
20:33:18 <dmwit> > [0..] >>= flip replicateM "01" >>= (:[]).('1':)
20:33:20 <lambdabot>  ["1","10","11","100","101","110","111","1000","1001","1010","1011","1100","1...
20:33:51 <Axman6> now do gray codes
20:33:57 <dmwit> oooo, good idea
20:34:52 <jusss> how to turn IO Maybe () to IO () ?  fmap (\x -> ()) (IO Just ()) ok?
20:35:15 <EvanR> holy kind errors batman
20:35:24 <Axman6> you're mixing types and values again
20:35:28 <jusss> sorry
20:35:35 <jusss> IO Just () is wrong
20:35:49 <jusss> fmap (\x -> ()) (print Just ())
20:35:55 <Axman6> so is IO Maybe (), it should be IO (Maybe ())
20:36:08 <Axman6> :t print
20:36:09 <lambdabot> Show a => a -> IO ()
20:36:18 <Axman6> :t print (Just ())
20:36:22 <lambdabot> IO ()
20:36:40 <dsal> Maybe () sounds like Bool.
20:37:02 <jusss> Axman6: how i can create a value has IO (Maybe ()) ?
20:37:19 <Axman6> :t pure (Just ())
20:37:21 <dsal> > pure (Just ()) :: IO (Maybe ())
20:37:21 <lambdabot> Applicative f => f (Maybe ())
20:37:23 <lambdabot>  <IO (Maybe ())>
20:37:28 <Axman6> :t pure @IO (Just ())
20:37:29 <lambdabot> error:
20:37:29 <lambdabot>     Pattern syntax in expression context: pure@IO
20:37:29 <lambdabot>     Did you mean to enable TypeApplications?
20:37:44 <jusss> :t fmap (\x -> ()) (pure (Just ()))
20:37:46 <lambdabot> Applicative f => f ()
20:38:03 <Axman6> urgh, can someone fix lambdabot please :( #haskell is like the place that TypeApplications is most useful
20:38:14 * dsal should learn to TypeApplications
20:39:24 <jackdk> % :t pure @IO (Just ())
20:39:24 <yahb> jackdk: IO (Maybe ())
20:39:37 <jackdk> Axman6: yahb's got your back
20:40:14 <jusss> % :t fmap (\x -> ()) (pure @IO (Just ()))
20:40:14 <yahb> jusss: IO ()
20:40:19 <jusss> aha
20:41:08 <Axman6> jusss: that's just one of an infinite number of ways to make a value of type IO (Maybe ()) though
20:41:12 <Axman6> :t readLn
20:41:13 <lambdabot> Read a => IO a
20:41:43 <Axman6> readLn will ask for a line from stdin and try to parse it as the type a which you've specified 
20:43:35 <jusss> Axman6: 'cause there's IOT, so Maybe (IO ()) doesn't exist?
20:44:43 <Axman6> well, Maybe (IO ()) exists, it's just not really useful in the same way that other monad transformers are
20:45:03 <jusss> ...
20:45:09 <Axman6> @unmtl ReaderT Config (ExceptT Error IO) ()
20:45:09 <lambdabot> Config -> ExceptT Error IO ()
20:45:16 <Axman6> @unmtl ReaderT Config (ErrorT Error IO) ()
20:45:16 <lambdabot> Config -> IO (Either Error ())
20:46:08 <Axman6> that's the type that  ReaderT Config (ErrorT Error IO) () is under the hood - it's functions which accept Config and execute some IO whose result might fail
20:48:13 <jle`> jusss: fmap (\_ -> ()) is pretty common, it's given a name, 'void'
20:48:15 <jle`> :t void
20:48:16 <lambdabot> Functor f => f a -> f ()
20:48:24 <jle`> void = fmap (const ())
20:49:52 <jusss> Axman6: IO is a monad, IO a is a type, IO is a type?
20:50:04 <dmwit> > let f c '1' = reverse c; f c _ = c in map ('1':) . concat . iterate (("01">>=) . liftA2 (<$>) (:) . f) $ [""]
20:50:06 <lambdabot>  ["1","10","11","100","101","111","110","1000","1001","1011","1010","1110","1...
20:50:13 <jle`> jusss: under the typical reckoning, yes
20:50:38 <Axman6> IO is a type constructor - it has kind * -> *; it needs another type to produce a type
20:51:06 <jusss> Axman6: so IO is not a type
20:51:29 <Axman6> just like Just isn't a value of type Maybe a, it'sd a function when when given an a returns something of tyoe May e a
20:51:34 <Axman6> Maybe a*
20:51:36 <jusss> jle`: the whole IO stuff is really weird to me
20:51:38 <Axman6> no
20:51:39 <jle`> but, Just is a value
20:51:55 <jusss> wait, jle` Just is a value?
20:52:00 <Axman6> yes, the analigy isn't very good
20:52:03 <jle`> yes, it is a value of type a -> Maybe a
20:52:04 <Axman6> analogy*
20:52:05 <jusss> Just is value constructor
20:52:10 <jusss> Just is a function
20:52:25 <jle`> Just, the "J-u-s-t" token thing you type into a text file, is the type constructor
20:52:28 <Axman6> IO is a type construction
20:52:30 <jle`> it *denotes* a value
20:52:37 <Axman6> constructor*
20:52:39 <dmwit> IO is a type.
20:52:43 <dmwit> It is also a type constructor.
20:53:00 <dmwit> It is also a type of arrow kind, which is probably what Axman6 means when he says type constructor.
20:53:05 <jusss> aha, argue began
20:53:08 <jle`> typically you'd say IO is a type too.  It is a type that is denoted by the "I-O" symbols you type into a text editor
20:53:15 <dmwit> Not an important argument. Just a terminology argument.
20:53:34 <Axman6> we're not really arguing at all, I'm just not being as clear as I should be
20:54:01 <dmwit> Just is a data constructor, not a type constructor. (Without extensions, this is true.)
20:55:02 <jle`> a lot of it is just the distinction between the letters you type into the text editor, vs. the things that they represent
20:55:09 <dmwit> Type constructors are the types that are not applications and not variables.
20:55:22 <dmwit> Maybe, IO, Int, Either, Bool are type constructors.
20:55:41 <dmwit> Either Int is not a type constructor, because it is an application; x is not a type constructor because it is a variable.
20:56:46 <Axman6> People oftern make a distinction between "values" and "functions" - in Haskell functions are also values, but only functions can be applied to other values. f with type a -> b is a value, but f a is also a value. In the same way, type constructors are also types, but only type constructors can be applied t other types - IO has _kind_ * -> *, which means it can be applied to something of kind * to produce something of kind *
20:57:36 <dmwit> (Axman6 and I are using different definitions of the phrase "type constructor".)
20:57:37 <jusss> IO is a type function?
20:57:40 * Axman6 should probably leave tthis to others who're better at explaining this
20:57:52 <dmwit> (For Axman6, "type constructor" means "type with arrow kind". For me it means what I said above.)
20:58:37 <jle`> "types" are just the things you can play with at the type level to construct the things denoting what you want to mean
20:58:48 <jle`> so you can use IO, you can use Int, you can put them together to get IO Int, etc.
20:59:00 <jle`> each is useful in different situations
20:59:07 <jle`> they all have different roles, every type is useful
20:59:17 <jle`> otherwise we wouldn't care enough to talk about them :)
20:59:40 <jle`> IO is useful for some situations, Int is useful for some other situations, IO Int is useful for still even other situations
20:59:54 <dmwit> I think "IO is a type function" is basically right.
21:00:19 <jusss> dmwit: and IO is a type?
21:00:22 <jle`> indeed i don't think there is anything wrong with it
21:00:28 <dmwit> I like "IO is a type".
21:00:50 <jusss> is ther a 'but'?
21:01:05 <jusss> jle`: IO is a type?
21:01:07 <dmwit> Yes; some people use "type" to mean something different than me.
21:01:25 <jle`> yeah, it's a type. just not a "capital-T" Type
21:01:58 <jusss> can we say Maybe is a type? Maybe is a type function, which kind is * -> *
21:02:03 <jusss> Maybe Int is a type
21:02:10 <dmwit> I like all of those sentences.
21:02:18 <jle`> yeah. Just is a value. Just is a value function, which has type a -> Maybe a
21:02:23 <jle`> `Just True` is a value
21:03:07 <jusss> :t print Just
21:03:09 <lambdabot> error:
21:03:09 <lambdabot>     • No instance for (Typeable a0) arising from a use of ‘print’
21:03:09 <lambdabot>     • In the expression: print Just
21:03:16 <jusss> % :t print Just
21:03:16 <yahb> jusss: ; <interactive>:1:1: error:; * No instance for (Show (a0 -> Maybe a0)) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In the expression: print Just
21:03:24 <jle`> not all values have a Show instance
21:03:32 <jusss> % :t print (Just 3)
21:03:32 <yahb> jusss: IO ()
21:06:19 <Axman6> % print (Just True)
21:06:19 <yahb> Axman6: Just True
21:06:37 <koz_> Why did GHC decide on Type :: Type versus the 'Type tower' that Idris and Agda have?
21:06:59 <dsal> koz_: tower?
21:07:10 <Axman6> (what yahbis showing is what is printed to stdout, which the result of applying show to Just True and then writing that string to stdout)
21:07:21 <c_wraith> koz_: because it's simpler to implement with the semantics GHC already has
21:07:23 <koz_> dsal: In Idris, Type :: Type1, Type1 :: Type2, and so on.
21:07:28 <koz_> (I may not be getting the names right)
21:07:39 <dsal> I don't know idris.  I have a passing familiarity  with agda.
21:07:55 <koz_> dsal: I believe Agda also does this, with possibly different names.
21:09:28 <mycroftiv> i think its convienience vs consistency, haskell isnt committed to being logically consistent in the way a proof oriented language like agda is
21:09:39 <EvanR> a cumulative (or not) hierarchy of type universes
21:09:48 <koz_> Also, is it incorrect to understand Type1 as being 'Kind'?
21:10:04 <EvanR> what's Kind
21:10:15 <koz_> All kinds?
21:10:19 <EvanR> heh
21:10:25 <EvanR> BOX ?
21:10:33 <koz_> EvanR: Wut.
21:10:43 <EvanR> the type of kinds
21:12:17 <koz_> Good to know. So is BOX the same as Type1, then, or is my understanding off?
21:14:19 <EvanR> i don't understand the problems that Type :: Type potentially poses
21:15:20 <koz_> EvanR: It's inconsistent, but apparently this isn't an issue for GHC. I am unsure of why.
21:15:24 <mycroftiv> the barber paradox
21:15:38 <koz_> mycroftiv: Or, as I prefer to call it, Russel's Paradox.
21:15:44 <koz_> s/Russel/Russell/
21:16:10 <heatsink> It isn't an issue for GHC because GHC evaluates coercions strictly.
21:16:17 <jle`> koz_: values, types, kinds, sorts
21:16:49 <koz_> heatsink: Could you elaborate on that? Specifically, how evaluating coercions strictly helps dodge Russell's Paradox?
21:17:00 <mycroftiv> in another way it 'isnt an issue' because most languages deliberately allow you to express broken constructions. whether or not the ease of expression is worth losing safety is a big can of worms
21:17:01 <koz_> jle`: Are those all Type1?
21:17:46 <jle`> that's the 'hierarchy'
21:17:48 <heatsink> Paradoxes are effectively nonterminating loops that promise to provide evidence that x ~ y, but never deliver a result
21:17:58 <jle`> values have types, types have kinds, kinds have sorts
21:18:06 <jle`> above that i don't know if there are specific names
21:18:08 <koz_> jle`: Ah, I see.
21:18:22 <koz_> I think I saw a few people mention them, but the names got too ridiculous to remember. :P
21:18:40 <heatsink> So, a paradox will loop forever and not actually let you do something unsafe
21:18:42 <jle`> kind of like the displacement, velocity, acceleration, jerk ... then according to some, snap, crackle, pop...and above that no other names really
21:19:47 <jle`> even though the tenth derivative of displacement exists as a concept, nobody has bothered to give it a name
21:20:31 <EvanR> koz_: the paradox is Girard's paradox and I haven't been able to grok it nearly as easily as Russell's
21:22:12 * hackage emd 0.2.0.0 - Empirical Mode Decomposition and Hilbert-Huang Transform  https://hackage.haskell.org/package/emd-0.2.0.0 (jle)
21:22:30 <EvanR> or how to avoid it, i.e. what needs to be in what universe
21:31:59 <slack1256> EvanR: I used to think that restrict "inter-level comunication" was enough, so values can depend on other values and types on other types. The I discovered dependent typing and became confused again.
21:33:12 <EvanR> in which family of types indexed by values is totally the point
21:33:29 <slack1256> Yep
21:34:45 <EvanR> the details get nontrivial fast ime
21:48:19 <koz_> Agreed.
21:48:33 <koz_> That be where the devil lives, yo.
22:42:42 * hackage connections 0.0.2 - Partial orders & Galois connections.  https://hackage.haskell.org/package/connections-0.0.2 (cmk)
22:56:12 * hackage rings 0.0.2 - Rings, semirings, and dioids.  https://hackage.haskell.org/package/rings-0.0.2 (cmk)
22:57:23 <koz_> Huh, someone beat me to a dioid library lol.
22:57:54 <EvanR> is that like a double monoid
22:58:14 <koz_> EvanR: Sort of. It's two monoids with some additional relationships between their mempties and (<>)s.
22:58:24 <koz_> I could look this up if you're super curious.
22:58:45 <EvanR> no that's probably enough info to infer the rest :)
22:59:13 <koz_> There's a bunch of different ones, and they're basically a good way to talk about 'various numbery things'.
23:00:27 <koz_> If you wanna look into the underlying theory, the book you want is 'Graphs, Diods and Semirings: New Models and Algorithms'.
23:01:41 <EvanR> ought to be good for sources of semirings that aren't monoids
23:09:56 <nshepperd> is it a category with two objects
23:17:11 * hackage network-run 0.2.1 - Simple network runner library  https://hackage.haskell.org/package/network-run-0.2.1 (KazuYamamoto)
