00:00:07 <jellostahps> yeah, with a predicate: (\x -> x>3) [2,3,4,5,6] , it adds 3 to the list that it shouldnt
00:00:13 <jellostahps> it is handling it as x>=3
00:00:35 <jellostahps> output: ([6,5,4],[3,2])
00:00:38 <EvanR> uhm... why would it do that
00:01:09 <jellostahps> yeah im gunna figur eit out hopefully
00:01:14 <jellostahps> figure it *
00:04:54 <jellostahps> :t (>)
00:04:55 <lambdabot> Ord a => a -> a -> Bool
00:06:19 <EvanR> if it's greater than 3, put it in the first list
00:07:08 <jellostahps> oh smh sry man, wasting your time being dumb
00:07:26 <jellostahps> and thx
00:45:22 <jle`> to be fair i have often stared at >= and wondered if it was a monadic operator like >>=
00:53:53 <jusss`> dminuoso: I suddently understand your `newtyfpe F = MkF { unF :: Int -> F }`,  I talked infinite type with a typescript guy, and he give me a `type Fun = (_: any) => Fun` for that `const f : Fun = _ =>{console.log(_); return f};` and then I tried to turn it to haskell, I wrote `data Fun = any -> Fun`, but `any -> Fun` is already a type, so we have to add a value constructor MkFun, which is `data Fun = MkFun (any -> Fun)`, and your `unF
00:53:53 <jusss`> F :: Int -> F`,  let's assume `f :: Int -> F` , so `unF (MkF f) = f`
00:54:32 <koz_> jle`: A half-bind?
00:54:37 <jusss`> dminuoso: and this `unF (MkF f) = f` is look like Y g = g (Y g) , right?
01:22:12 <jusss``> dminuoso: a little misunderstood here, you use `f::F; f=MkF (\i -> f);` then `unF f 1 = f `
01:24:11 <jusss``> unF (unF f 1) 2 = f       which is related to Y g = g (Y g) = g (g (Y g)) ???
01:33:02 * hackage funflow 1.5.0 - Workflows with arrows  https://hackage.haskell.org/package/funflow-1.5.0 (nclarke)
01:55:44 <jusss``> function return itself, it's useful when it works on some side-effect operations, 
01:56:15 <kuribas> is haskell performance on par with java?
01:57:57 <boxscape> kuribas here's a comparison of a few simple benchmarks - it looks like sometimes, haskell is faster, and sometimes, Java is: https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/haskell.html
02:02:05 <iqubic> Haskell needs a Ring type class.
02:03:27 <maerwald> do we need typeclasses? :P
02:04:10 <iqubic> yes indeed.
02:04:36 <__monty__> iqubic: Yeah, we're gonna regret that aren't we? Cause if we liked it then we should've put a Ring on it.
02:06:41 <iqubic> Yes.
02:08:47 <Taneb> iqubic: "Num" is more or less a Ring class
02:09:13 <Taneb> Apart from abs and signum which are gross :(
02:13:18 <iqubic> yeah. That's right
02:14:01 * hackage reader-soup 0.1.0.0 - Vinyl-based reader-like monad composition  https://hackage.haskell.org/package/reader-soup-0.1.0.0 (YvesPares)
02:26:52 <[Leary]> Rather than having a Ring class, it'd be nice to break Num up better and have things like `0 :: Monoid (Additive a) => a; 1 :: Monoid (Multiplicative a) => a; class NatLiteral a where fromNatural :: Natural -> a; (+) :: Semigroup (Additive a) => a -> a -> a; (*) :: Semigroup (Multiplicative a) => a -> a -> a` etc.
03:16:01 * hackage reader-soup 0.1.0.1 - Vinyl-based reader-like monad composition  https://hackage.haskell.org/package/reader-soup-0.1.0.1 (YvesPares)
03:17:01 * hackage docrecords 0.1.0.0 - Vinyl-based records with hierarchical field names, default values and documentation  https://hackage.haskell.org/package/docrecords-0.1.0.0 (YvesPares)
03:18:02 * hackage porcupine-s3 0.1.0.0, porcupine-http 0.1.0.0, porcupine-core 0.1.0.0 (YvesPares): https://qbin.io/phpbb-marc-7vud
03:43:25 <bwe> Can I define fromRational and fromInteger for Data.Fixed.E2?
03:44:26 <phadej> E2 is not a number
03:45:07 <phadej> Centi = Fixed E2 is
03:45:18 <phadej> (and have Num  and Fractional instances)
03:46:34 <Taneb> > fromRational (4/7) :: Data.Fixed.Fixed E2
03:46:35 <lambdabot>  0.57
03:49:52 <bwe> Do I need to define the methods on my own or not? https://repl.it/repls/KnowledgeableFeistyCallback
03:52:03 <bwe> Taneb: Isn't it the other way around in my case ^^ ? I am starting off with a Data.Fixed.Fixed.E2 that is buried in a sum constructor.
03:52:43 <bwe> I feel I'd just need to inherit the Num and Fractional instances to the sum constructor...
03:55:14 <Taneb> bwe: ah, you will need to define those yourself
03:55:56 <bwe> Taneb: okay! Then my approach was not bad at all. So how should I go about the fromRational and fromInteger?
03:58:15 <Taneb> That depends on what sort of semantics you want
03:59:36 <bwe> I actually don't use anything that requires those methods. However, I want to fix them as it is a GHC warning and it's good practice to define them completely.
04:03:23 <Taneb> I'd need to understand your goals in a lot more detail to help you here
04:09:33 <bwe> Well, I just want to use (/) (+) (-) with A Centi | B Centi | C Centi just like https://repl.it/repls/KnowledgeableFeistyCallback -- lines 13-15
04:10:22 <Taneb> What should A 1 * B 3 be?
04:10:24 <boxscape> what about (A 3.333) / (B 3.333)?
04:11:24 <bwe> boxscape: Good point! In this case B will be converted to A using toA :: ABC -> ABC, so we actually divide only As with As.
04:12:51 <Clint> do you want the Fractional instance to automatically convert B to A?
04:13:18 <boxscape> In that case I personally would wrap Centi in three newtypes and make a Sum type of those newtypes, to make sure I'm not accidentally adding an A to a B or something
04:14:15 <bwe> Clint: if I don't need to, can I auto-derive the instances then?
04:17:04 <boxscape> What is an auto-derived instance supposed to do when it encounters A 3 * B 3?
04:25:25 <bwe> boxscape: That's not possible.
04:25:58 <bwe> Auto-derived excludes the current sum type implementation.
04:26:24 <boxscape> Ah, I thought you were asking about auto deriving the instance for the sum type
04:27:17 <bwe> No, I am questioning whether the sum type is the right choice for the problem I try to solve: M | Mm | Cm -- units
04:42:41 <Ariakenom> bwe: what's the reason you're not using only the most general type?
04:43:12 <Ariakenom> (or chosing a canonical form)
05:00:07 <boxscape> hmm the user guide says "A partial type signature is a type signature containing special placeholders written with a leading underscore (e.g., “_”, “_foo”, “_bar”) called wildcards."
05:00:26 <boxscape> and yet from what I can tell anything apart from _ without suffix is simply treated as type variabel
05:00:40 <boxscape> % undefined :: _
05:00:40 <yahb> boxscape: ; <interactive>:185:14: error:; * Found type wildcard `_' standing for `w1'; Where: `w1' is a rigid type variable bound by; the inferred type of <expression> :: w1; at <interactive>:185:14; To use the inferred type, enable PartialTypeSignatures; * In an expression type signature: _; In the expression: undefined :: _; In an equation for `it': it 
05:00:48 <boxscape> % undefined :: _a
05:00:48 <yahb> boxscape: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:186:1 in interactive:Ghci57
05:00:58 <boxscape> % undefined :: forall t . _a
05:00:58 <yahb> boxscape: ; <interactive>:187:25: error: Not in scope: type variable `_a'
05:19:10 <lyxia> boxscape: that's the NamedWildCard extension mentioned a few paragraphs below
05:30:22 <boxscape> lyxia the sentence I copied is from PartialTypeSignatures
05:31:54 <lyxia> yes I know
05:32:56 <boxscape> lyxia oh, I see what you mean
05:32:57 <boxscape> okay
05:33:54 <lyxia> it might be worth reporting as a doc bug, to clarify that it needs that other extension
05:34:45 <boxscape> I suppose I'll do that
05:50:05 <nshepperd2> % :set -XPartialTypeSignatures
05:50:05 <yahb> nshepperd2: 
05:50:18 <nshepperd2> % undefined :: _a
05:50:19 <yahb> nshepperd2: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:189:1 in interactive:Ghci57
05:50:46 <nshepperd2> % undefined :: _
05:50:46 <yahb> nshepperd2: ; <interactive>:190:14: warning: [-Wpartial-type-signatures]; * Found type wildcard `_' standing for `w'; Where: `w' is a rigid type variable bound by; the inferred type of <expression> :: w; at <interactive>:190:14; * In an expression type signature: _; In the first argument of `GHC.GHCi.ghciStepIO :: forall a. IO a -> IO a', namely `(undefined :: _)'; 
05:51:20 <nshepperd2> Makes sense
05:57:30 <boxscape> Hm, -fdefer-type-errors makes this somewhat less important, but it would be nice if ghci, when failing to reload a file, simply keeps the old incarnation loaded instead of having no version loaded
06:07:50 <Guest_49> hello
06:10:27 <boxscape> hi
06:24:31 * hackage porcupine-core 0.1.0.1 - Express portable, composable and reusable data tasks and pipelines  https://hackage.haskell.org/package/porcupine-core-0.1.0.1 (YvesPares)
06:28:22 <sicklork1n> I'm curious to know if optparse would be a good solution for things like a search box or other in-app user interfaces.  My gut says this is a terrible idea, one being that it's not very user friendly to have to type options, but leaving that aside, presumably you could restrict yourself to arguments only.
06:29:37 <lavalike> it's probably simpler to just write some Parsec
06:29:59 <sicklork1n> Up until now i've been using megaparsec, but then someone said why aren't u using optparse.. 
06:30:17 <lavalike> darn someone
06:30:43 <alaendle> @pl \x -> x
06:30:43 <lambdabot> id
06:31:15 <alaendle> @pl cstr = peekCString cstr >>= callback
06:31:15 <lambdabot> cstr = fix ((callback =<<) . peekCString)
06:31:26 <sicklork1n> Does the order of argument matter in optparse (assuming each argument has a uniq type)?
06:32:14 <evelyn> It depends how you write your parser
06:32:33 <evelyn> But surely this is a separate problem from introducing a search box to a given program?
06:33:35 <sicklork1n> evelyn: there are several interaces to command the ship (as it were). A CLI, Slack interfface, and a web interface... 
06:35:31 <alaendle> @pl cstr = callback <<=  peekCString cstr
06:35:31 <lambdabot> cstr = fix ((callback <<=) . peekCString)
06:36:12 <boxscape> alaendle you probably meant =<<, rather than <<=
06:36:39 <sicklork1n> My commands right now look like `set foo bar 2 /SomeGlob/` which would change foo=bar for all systems that match SomeGlob.. 
06:37:03 <sicklork1n> ignore that 2, it was a typo
06:38:08 <sicklork1n> YOu can run muliple commands by separating any token i.e. set, with a newline..
06:39:27 <sicklork1n> So, infact, something like boomerang seems like a better approach infact.. since I do want to be able to go from SomeCommand -> Text; and Text -> SomeCOmmand..
06:49:32 <merijn> sicklork1n: optparse itself isn't a good find, but it's kinda similar to a think that is (lemme see if I can recall what the name was)
06:49:48 <merijn> Something like formlets, I think
06:52:55 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
06:52:55 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
06:52:55 --- names: list (clog_ theophil97 zekt83 carldd1 okuu nbloomf o1lo01ol_ stux|RC-- ziyourenxiang_ comerijn milanj_ pfurla rsoeldner__ bahamas cr3 stef204 nineonin_ cybai s00pcan ddellacosta rocket_man bermraj alaendle pie_ oish guyit cheater hyperisco nschoe merijn keep-learning[m] spew grag[m] jonge[m] labs[m] lions[m] Richy[m]1 Testitunnari[m] betz[m] gentlehelm[m] DenisLehmann[m] slrtbtfs[m] edwel[m] matrixyz[m] luminousnine[m] NickHu joe[m]5 georgescratcherd neurocyte[m])
06:52:55 --- names: list (entropi[m] ist5shreawf[m] eckt[m] sicklork1n jwaksbaum[m] royal_screwup21 torkel[m] doublex josiah_sama voyons_osti jlvvlj[m] maigel[m] laniusfnv[m] nolep[m] alice[m]1 mossplix absnc benzoid[m] alibabzo ystael fiberpunk[m] olmvnec[m] buggeas40d[m] rihardsk[m] ldesgoui[m] Ekho[m] atopuzov[m] Orbstheorem[m] mujx[m]1 Lite[m] mssx89m[m] cesar[m] fiddeldibu[m] jibby[m]1 rgamma[m] jwerner[m] case_ratchet[m] aryaan[m] intellection3to3 BaMaung[m] fabianhjr[m])
06:52:55 --- names: list (lerowukta[m] boutil[m] D[m]2 Hanma[m] kaster[m] Bertschneider[m] mmynsted[m] tomtau[m] erasure[m] vsts[m] JakeO[m] whoops Ericson2314 spacekitteh[m] rahduro[m] Azel peter-js[m] xmpln[m] eruvarn[m] PonyDuck3000[m] Mesa[m]1 josef[m] eyenx[m] jumzi[m] kaychaks[m] EuAndreh[m] xalek[m] aitzol[m] neiluj[m] hans[m]6 LasEspuelas twom[m] ppseafield[m] zmlww[m]1 richardax[m] guiraldelli[m] Mitch[m] kupo_[m] Hakan[m] jibby vikraman iffsid themsay[m] ChrisPenner[m])
06:52:55 --- names: list (humanwire[m] tuxsoy alephu5[m] seekerus3r[m] pothyurf[m] likliklik abbe[m] hsw[m] dlilja[m] midi[F][m] MrAxilus yesided[m] triste[m] kai10[m] markus[m]4 Chromad[m] Ben[m]5 foxadee[m] unitymember[m] meu76[m] jak[m]1 NickHu1 Soft[m] joenase[m] asonixDogHeThey[ Wizek[m] shiroeni[m] fulgjon MichalLaskus[m] blakec[m] sputny[m] imposs[m] pleasesendnudes[ amb007[m] alex[m]17 vkleen PrimeSeeker[m] denbrahe[m] alxev[m] n0ma_d[m] amerocu[m] fswalker[m] vector[m]1)
06:52:55 --- names: list (ninjatrappeur[m] hjoest[m] hovgaard[m] cbg[m] parmesan[m] anton-latukha[m] edejong[m] admdch[m] elfets nnm imdoor[m] pietromrtn[m] butterth- Kaivo milanj dddddd gxt oisdk takuan_dozo OnkelTem umachan machinedgod vlatkoB ggole jeltsch Batholith roman2 solonarv ziyourenxiang poljar1 MarcelineVQ unlink2 DTZUZO_ boxscape jedws ubert chalkmonster phreedom runforestrun hpc gargawel Cthalupa sfvm Anthaas lprd NinjaTrappeur Wuzzy Boomerang justanotheruser iqubic sw1nn)
06:52:55 --- names: list (linarcx qskwx __monty__ jakalx rruizt macroprep delYsid spion seventh__ thc202 kuribas regakakobigman asheshambasta logzet fweht abhixec raichoo ggVGc danvet chele fphilipe Ariakenom sQVe mceier cynick lnostdal meck ephemera_ tromp raoulb mulk carlomagno reggie__ day ChaiTRex feuerbach zaquest acidjnk_new Lord_of_Life sword865 lemmih lagothrix maralorn theDon andi- mountaingoat d34df00d nav2002_ stepnem tabemann crobbins sshine Kaiepi carldd kuttifunk uberj_)
06:52:55 --- names: list (dolio Igloo moldybits alx741 nemesit|znc aarvar dazage MonkeyNOS calloc raduom quintasan ph88 nullifidian jb55 SCHAPiE darjeeling_ thaumavorio hc inkbottle Sgeo wrengr_away Lowl3v3l gwern Velpoman t7 pavonia JoelMcCracken m0rphism wild_buffalo LnL suppi markus1189 pacak good2cu tombusby nahra defanor_ mjuad zariuq hackage wire[m] insanitea gabiruh Digit atk sigmundv_ jluttine perrier-jouet sagax MindlessDrone ichor khisanth_ DrAwesomeClaws Yucheng mozzarella)
06:52:55 --- names: list (Paks sujeet _ashbreeze_ linduxed jlamothe ericsagnes wonko77 jdt nckx mounty cgfbee rosalux phadej zfnmxt infinity0 tomboy64 DTZUZU theorbtwo thyriaen[m] biox[m] mat8913[m] kylos[m] johanejg[m] k4l1gr4[m] nalix[m] neat72[m] Mougan[m] qasim[m] luisjira[m] jdks[m] xethrog42[m] rainbyte[m] ponette[m] shachiku[m] M31violet13[m] buster528[m] haskelllisp[m] xlogan[m] BoraKaplan[m]1 periapseez[m] gd2398[m] M2ktsre[m] imp0s5ible brevalda[m] kicker22004[m]1 Bimmie[m])
06:52:55 --- names: list (mithrandi[m] legowheels[m] Rama[m] than1133[m] danielemarsella[ dl3br[m] M|GNUisnotLinux[ trevortknguyen[m jlorand[m] mgiagante[m] Alec[m]1 adziahel[m] afontain[m] PotatoRick[m] Surgeon[m] Syllo[m] zopsi[m] hackeryarn[m] Cloud[m] alana[m]1 pschooom[m] patonw[m] Undefined[m] greta[m] thekyriarchy[m]1 maxmaguire[m] cepxuo jochens[m] AkikoHimenokoji[ firefly1927[m] jonreeve[m] natmac[m] MerlinGttlinger[ avocado yi[m] uelen[m] rgh[m]2 brandon123[m] glothit7ok[m])
06:52:55 --- names: list (cal[m] tkots[m] ryemantis[m] bobach[m] ghastfilms[m] nartir[m] atpotts texpat[m] dice[m]1 tasrev[m] flawr[m] pagoda_5b[m] tmallard[m] sayukimans[m] klaadum[m] ciroyo[m] jay[m]1 Cenion[m] noteventime abc123zzz[m] vespuccy[m] yur3shmukcik[m] wrunt[m] M0ddba11[m] dustyp[m] GNULambda[m] cawal[m] Kit[m]2 zorkedon[m] ciet[m] Kenneth[m] kxra[m] blake_rain[m] adaizen[m] hifutakiko[m] ludovicdanjoumad liso[m] tempaccount1[m] AMlivinfree[m] Paavo[m] unrooted[m])
06:52:55 --- names: list (actartis[m] deikatsuo[m] jhgarner[m] carola[m]1 heyakyra[m] yrid[m] TheD6[m] donnyllionaire[m charliebucket[m] jeeg[m] inkstain[m] contrun[m] bartholomews[m] dude[m]1 unclechu hr[m] midi[m] AaronWeiss[m] GhostofaConsole[ abdolence[m] rowan[m] markalanrichards jak[m] jorge-jbs[m] d0g01[m] grorg[m] cabalcorp[m] hamechi[m] testacc3[m] alko[m] somni[m] gkobeaga[m] hoohaw[m] reconmaster[m] Daquilla[m] moats mouse008[m] pqwy[m] pablo-pie[m] snupples[m] JoGoSi[m])
06:52:55 --- names: list (zukken[m] krowlan3[m] GNULizard[m] rinor[m] GreenKarm[m]1 corin[m] vorbex[m] nybble41[m] Cele[m] ilmu[m] freu[m] reedhhw[m] ShujaRafi[m] gspia[m] deklund[m] JulesRen-Georges souldev[m] sergiotarxz[m] jesusvega[m] kumarbis[m] soaoaig[m] makos999[m] bt[m] provessor[m] arianvp[m] guzmanillo[m] masaeedu[m] olep[m] Gw3n[m] themadman[m] beatricejensen[m vigilian[m] bkl[m] Noughtmare[m] aquarial[m] korlaplankton[m] thosgood[m] talvdav[m] jg[m] odd13[m] Vincent[m]1)
06:52:55 --- names: list (teaknow[m] gmips[m] Grgoire[m] tarigo[m] se224[m] lapav[m] cyclops19[m] SamuelH[m] NirvinM[m] nasius[m] PhilipWhite[m] chris[m]12 suppenkasper[m] janustroelsen[m] ovigren vhzr[m] Rich[m] EmilKarlson wobbol[m] keith[m] beaverfever[m] petrolifero[m] quiet_laika[m] potato44[m] sm[m] ircer[m] akt[m]1 corin[m]1 vars[m] lukasubo[m] kinga06[m] aterius apurvapavaskar wildtrees[m] godzilla[m] steamedbun[m] dxml[m] dikini[m] hogarth[m] RIOTIM[m] shanesveller[m] lihram)
06:52:55 --- names: list (kitsune[m] cosson[m] kahuna[m] godva[m] MarquisKurt[m] papazeus[m] sphalerit ad5twoknebor[m] triskeon[m] M2en[m] arturo[m] oniani[m] Eclipse[m] nonlinear[m] weebull[m] yoltid[m] vpei[m] roberth blackspider76[m] dag[m] tet[m] tswett[m] inflationova[m] runningriot9[m] derberg[m] JoelMcCracken[m] asayers[m]1 aquarial jak_wolf[m] hvariant[m] makos[m] pebeto[m] br0p0p[m] SmiVan[m] miseenplace[m] linxnp[m] javjarfer[m] PoopSick[m] ookfof[m] StevenY[m] link2xt[m])
06:52:55 --- names: list (gandi[m] sriehl[m] Jonathan[m]3 cjskaggs[m] kompass[m] dumuzid[m] nh2[m] aruncom2006[m] elosil[m] jennie[m] laith1[m] Kimani[m] gswuichet[m] crvs[m] freeman42x[m] limabeans[m] hkimhvyh[m] popo[m] supersweetsweetc krangbae[m] danielbmarkham[m max3raza[m] aqtusia[m] mujx[m5 lmolr[m] luftmensch[m] homebeach[m]1 krhubert[m] javbit[m] schum ajirx[m] tops[m] SFL[m] pineapple[m] Godslatestgift[m kyleondy[m] MartinKlimi[m] iantownsend phanimahesh[m] friedm[m])
06:52:55 --- names: list (kaiyou[m] iarp[m] MonsieurArcher[m Brio[m] ChristopherBurg[ sudorebootnowsud tindvik[m] test_f[m] WeiTang[m] mattia[m] aearnus[m] Godel[m] coil[m] xxthatgirlxx[m] paulus[m] thekyriarchy anarcolepsia[m] wuxianhuiyi[m] texasmynsted bee[m]1 mathyouguy alexfmpe[m] VaNilLa[m] giuseppe[m]1 vk3wtf[m] dominicusin[m] srid[m] roninkaizen[m] jrozanski noam[m] aloiscochard[m] m00n[m] gmind[m] tejok[m] isair[m] tehidiot[m] kadoban luke-clifton[m] siraben aviD stan[m] fgaz)
06:52:55 --- names: list (supersven[m] Videled[m] lierdakil[m] chorhizo[m] vaibhavsagar GregKNicholson[m simbergm peel1 coldpress[m] sdicke[m] ternarysolo steshaw[m] macerbi[m]1 iceychris[m] ClownMaster[m] boistordu sepp2k domenkozar[m] hdurer[m] afk[m] sielicki drewr gienah_ xstill sylvie[m] abrar nurupo Twey tsrt^ gentauro saml e3 tabaqui thunderrd ClaudiusMaximus seanparsons cchalmers liff mostendocrine toppler yumh michaelpj mimi_vx troydm xplat poga bydo Unhammer ekleog fliife)
06:52:55 --- names: list (acarrico unyu m1dnight_ lowryder lkurusa stzsch ent tlax tsani theophil9 sellout- shutdown_-h_now scavenger_ teardown acro lstdgtfp Kiruwa zmt01 and_pete glamas jstolarek Jesin _deepfire SquidDev matheus Majiir drbrule ixian stux|RC sphalerite cp iskander badzergling cartwright bgavran mr_yogurt tsahyt fuzen laxask incertia Natch evanjs davr0s davr0s_ Ulrar aesi leah2 a3Dman eyenx [Leary] dmwit dave_uy dopplerg- Chobbes chirpsalot spoonm amiri yahb avn dequbed)
06:52:56 --- names: list (Ke arahael Mzg jwynn6 marmalodak Cale Axman6 neildaemond rajivr___ stiell Jonno_FTW Clint hiredman anathema Vtec234 arianvp Guest82049 urdh dustinm srhb coldpress ahri wagle Nickerson andreas303 Neuromancer albel727 datajerk srnty m4lvin ap5 yitz remexre tinwood Folkol_ PtxDK andreabedini kjak infinisil mikolaj_ dqd kmelvn evelyn shachaf atomi gluegadget verement redcheck copypasteque Unode Tourist andyo bdw rotty Rudd0 Sose TC` tomjaguarpaw lavalike sim590)
06:52:56 --- names: list (noexcept gilbertw1 aplainzetakind Niamkik subfacto1 jfredett anishathalye mikolaj militia Guest74859 tms_ tumdedum catsup Fubar^ _xor fryguybob rootnode kirand kwantam juri_ valdyn rotaerk ski kAworu nesqi tabaqui1 kini koz_ noan DigitalKiwi Maxdamantus forell jmsx Foritus Vq strangeglyph Fairy Bergle_1 jackhill bgamari sdrodge cc0k33 ccokee sleepnap chindy nekomune jophish _Tristan_ sqrt2 earthy dmiles glguy elcaro nee` abbe dibblego thebnq erikd yaroot)
06:52:56 --- names: list (echoreply styledash bsima APic TemporalShift rembo10 iomonad lassulus tv gspia int-e lambdabot dxld chin-tastic haasn leothrix jrm xelxebar jchia1 boj s4msung reorder_ averell tensorpudding arkeet petercommand tessier_ miklcct swater alanz lemald Arguggi Madars devurandom Tspoon_ pja acowley klntsky TMA Slothel_ nshepperd2 bendo dunningk marble_visions grumble obfusk__ Enigmagic nikivi adamCS glowpelt droplet Adeon ereu nuxdie Shun131 auri_ landonf sdx23)
06:52:56 --- names: list (Ranhir Hijiri MasseR orzo pingu_ Remavas DustyDingo caasih coot dmj` hjozwiak entel statusbot qzo enikar jassob1 pikajude wz1000 lockshaw_ cpape bjobjo joehillen inimino clynamen_ ziman rawles Intensity c-rog jzl niklasb_ teehemkay irclogger_com dminuoso johnstein michalisko monochrom madnight ft ion Tuplanolla EvanR dumptruckman nonzen betawaffle deu wadadli xtsee apoc asm89 freusque samebchase coeus MatrixBot3 vk3wtf sea-gull ammar2 mjrosenb energizer guios)
06:52:56 --- names: list (zekt8 Jello_Raptor sandman13 dredozub- Moyst dyl_ PHO fr33domlover h32 tristanC klugez Hasefroch w1gz zerokarm1left scal_ flebron_ heath dixie_ comboy_ lucas8 mxf hyperfekt vio_ Sparad0x ocharles adamse pierrot devalot le_jonge jbetz implementation_ bbear- TimWolla daissgr sis7 null_ptr haskell_enthusia alp mycroftiv runawayfive dan64 zzz adadelta rkrishnan mniip fiQ2 Guillaum Ring0` peel nlofaro phlym obiwahn carbolymer eagleflo tomku stylewarning Klumben)
06:52:56 --- names: list (xacktm SolarAquarion TommyC AWizzArd esph cyberlard saurik andjjj23 amosbird johs joeyh komasa tnks Nevoic bwe ambrosia_ SegFaultAX mikeplus64 arsdragonfly Hotbees idupree2 ab9rf absence silver_needles pong julienXX Taneb stefan bcoppens hvr Jon ps-auxw aurieeeh polux7 lnx telser mingc raek mnrmnaugh ^[ jamestmartin amatecha_ dongcarl Orbstheorem darthThorik thi_ phaazon bjs metalrain jesyspa kip ajmcmiddlin ghuntley eacameron xyggos EduardoBautista dani-)
06:52:56 --- names: list (s94a84d2e wildsebastian jackdk J_Arcane boeg tazjin d0liver DrDuck runeks pent gonz_ dsal milessabin typetetris ebutleriv Seich azahi bspar rzmt Athas bandali RecursiveG NightA Xandaros sm Willis Forkk uniquerockrz Bigcheese_ tdammers statusfailed amuck nil p3n edwtjo hive-mind electrostat raoul fionnan pingiun vimto Jacoby6000 opqdonut kapil_ mccoyc lexi-lambda joel135 Peter_Storm Firedancer mpickering terrorjack__ adius heyj mitchellsalad_ linoge spinda)
06:52:56 --- names: list (hamishmack PoliticsII_ sgraf rann sethetter datapup_ affinespaces srid Tritlo benl23 sivs _janne evilmonads cruxeternus magicman bollu parseval noCheese bbear so @ChanServ bitonic alunduil iravid Lermex epicallan monad_cat alexelcu bradparker winny nkaretnikov Nascha dpn` jsatk fredcy- natim87 rubik Blkt banjiewen interruptinuse PyroLagus zabracks ryzokuken feepo unsymbol morgib dukedave Jabbslad sebhoss simony AfC ephemeron fingerzam xnyhps jlpeters)
06:52:56 --- names: list (Konehaltia jonrh scav alexknvl NemesisD casdr_ Ferdirand paf31_ edmundnoble aib bananagram `slikts mstruebing griddle dgpratt m-renaud sclv jetpack_joe lieven robogoat bitemyapp koala_man Annihitek monokrome crtschin_ vin-ivar Mon_Ouie nibbling_ mtjmullen pdxleif dashkal habbah loc vodkaInferno chivay raid mankyKitty lightandlight higherorder ibloom tolt AndreasK rizary_ ProofTechnique spamlessj sebastianrkg integral mjlee nh2_ dexterfoo newhoggy)
06:52:56 --- names: list (TallerGhostWalt_ ryjm lsix uwap akermu vqrs Geekingfrog twk- t36s lurkless _flow_ solarus kloeri relrod jameekim PierreM Kneiva mrus gregberns atle w1d3m0d3 micro topos myme nitrix Cathy andromeda-galaxy codedmart vktec zymurgy epta tureba krystianbajno JSharp drdo ullbeking dfordivam pasukon haveo hodapp blackdog fiddlerwoaroof kosmikus pharaun fiatjaf adarshaj d3lxa crooked lortabac exferenceBot Deewiant a7250ag seliopou greymalkin xarian wraithm sterni bind)
06:52:56 --- names: list (rodlogic Mo0O artem jvanbure Firedancer_ bob_twinkles Rembane exarkun Phyx- michalrus gsingh93 gambpang connrs- [df] Aleksejs exio4 geal luigy sssilver avp djanatyn jinblack markhuge iron_houzi joeytwiddle ZoFLo kraem koankeeper cheshircat divVerent maerwald shadowdaemon DDR noko_ reyu jdevlieghere nivpgir_ mupf tstat lpsmith kqr jtcs Squarism travv0 connrs_ locallycompact deni Putonlalla oleks Ornedan Someguy123 jrslepak arw [exa] ByronJohnson Tene wtw)
06:52:56 --- names: list (charukiewicz Drezil catern qz SlashLife CindyLinz digia shapr Flonk stvc zv rootmos suzu RoguePointer ecx86 flogfr Eliel Nik05 __4matter_ nopf hexagoxel kubrat pdgwien ManiacTwister S007 beaky deadk nyuszika7h aidecoe graingert moobar Adluc srk quaestor petermw rom1504 atraii cbarrett coddinkn puffnfresh diginet restrictedchoice totte daGrevis n3t luite nshepperd1 carter kaol jokester cyphase edwardk lally SrPx noctux yushyin i7c dogui @Sigyn rodgzilla sveit)
06:52:56 --- names: list (ycheng amx Randy cheers nisstyre peschkaj megaTherion Philonous hongminhee ysangkok angerman scivola gothos c_wraith bengt_ moocow drewbarbs _ht barrucadu Zemyla jix Robin_Jadoul malthe cjay- mmaruseacph2 freeside immae Entroacceptor cross oeblink duairc Logio kipras`away abuss Nikotiini saidinwot1 nyaomi chessai hsiktas sukbeom Ekho aldum vjoki beka abra0 Ankhers thoradam elvishjerricco PotatoGim nbouscal glowcoil billstclair Kamuela kyagrd__ liquorice)
06:52:56 --- names: list (verlet64 rslima___ niko sariyar riatre joshmeredith dolanbatar a3f PragCypher cocreature hegge dh canta mudri sarahzrf davean PatrickRobotham runde Jaxan enemeth79 ynyounuo dagit agrim aweinstock Deadhand PlasmaStar pcoutin trucy teej debugloop kiix benwr_ dcoutts AkhILman M2tias Ckat sobhan eldritch anderson lukelau simplegauss jorj bolverkr kav systemfault clog cods lyxia dysfigured dilinger)
06:53:24 <boxscape> In the source code for undefined, there's a comment saying "It is expected that compilers will recognize this and insert error messages which are more appropriate to the context in which 'undefined' appears.". Is that a thing that happens? I can't think of anything ghc does that would qualify, unless we count printing stack traces.
06:54:05 <boxscape> (whoops got disconnected for a second)
06:54:47 <boxscape> In fact this isn't just in the source code, it's in the haddock docs
06:59:24 <comerijn> sicklork1n: Formlets are much more general than html
07:00:03 <comerijn> sicklork1n: They were originally designed wrt HTML forms, but the general abstraction is "some (potentially optional) user input field requiring validation"
07:00:55 <sicklork1n> comerijn: i'm digging a little deeper now.. So the idea is to have these types of things compose as well which is nice..
07:01:29 <hyperisco> I don't know "formlets" at all. Every time I have encountered something that sounds like this, though, they fall flat because they're somewhere between a nightmare and impossible to style correctly
07:02:12 <hyperisco> Typically there is *the* way they present themselves as HTML, and if that doesn't work for ya then good luck
07:02:26 <comerijn> hyperisco: Formlets say nothing about styling, they're for handling input you reserve
07:02:58 <hyperisco> Styling and HTML are joined at the hip
07:03:02 <comerijn> hyperisco: They're a "parsing"/validation abstraction, not a method of creating UIs (although most libraries that implement them also try and do that)
07:03:09 <sicklork1n> comerijn: for the sake of research I shall adopt yet another package I know nothing about..
07:04:08 <hyperisco> comerijn, okay. So there is extra legwork to give it an interface, like a web page
07:04:28 <sicklork1n> So now I need to figure how if the validation will work in a way I need it to..
07:05:12 <hyperisco> So then maybe not "more general than HTML" but "has nothing to do with HTML"
07:08:11 <sicklork1n> comerijn: Wait.. this won't work at all.. I need something that can go from Text -> SomeCommand.. i.e. set foo bar 12321 -> CommandSet Text Text ComplexSearchType. 
07:09:32 <comerijn> sicklork1n: What's the problem you're trying to solve?
07:09:59 <boxscape> I understand why we can't just take all the partial functions out of the Prelude, but.. wouldn't it make sense to at least make it very clear in the haddock that they are partial?
07:10:21 <sicklork1n> I need to keep the textual versions of commands consistent w/the types.
07:10:25 <comerijn> boxscape: Patches welcome? ;)
07:10:46 <comerijn> boxscape: I'm sure a patch updating all base docs to indicate partialness will be welcome
07:11:07 <boxscape> comerijn I might do that, but I thought I'd ask first to hear opinions :)
07:11:32 <boxscape> I've often discovered that something about haskell that seemed like an obvious improvement to me would actually be a bad idea
07:11:48 <comerijn> boxscape: I think the main reason is "it takes a lot of time to annotate all this and most people are very busy" :)
07:11:57 <boxscape> that makes sense
07:13:40 <comerijn> boxscape: Hell, if you're supermotivated you could see if Haddock could be extended with an annotation for partiality (like the @since annotation for when things were added)
07:14:03 <boxscape> that sounds like a nice idea actually
07:16:51 <maerwald> I've never been bitten by a function where I didn't know that it's partial. It's more like, you know it, you use it and occasionally have a few problems. 
07:17:00 <maerwald> But not big enough to want everything wrapped in Maybe.
07:17:15 <boxscape> hmm
07:18:20 <comerijn> maerwald: Sure, but beginners don't know all of those :)
07:18:37 <comerijn> maerwald: I don't think there's any reason not to annotate partial functions
07:18:48 <maerwald> sure, I would do that too
07:18:55 <maerwald> (and also document all exceptions)
07:19:02 <comerijn> I don't really see removing them happening, it'd break too much code. But simply adding that to the documentation would be nice
07:19:19 <Ariakenom>  @throws ErrorCall
07:19:43 <Ariakenom> on empty list. descriptions are good
07:20:16 <agohoth> ok ok now tell me
07:20:29 <agohoth> if I learn haskell after only knowing bash sofar
07:20:35 <agohoth> will I be able to make cool websites?
07:20:42 <maerwald> in bash or haskell?
07:20:48 <agohoth> haskell
07:21:18 <maerwald> frontend will be quite a challenge
07:21:24 <agohoth> I'm a huge ae van vogt fan
07:21:29 <maerwald> if you want quick results, check out elm instead
07:21:35 <agohoth> happstack.com looks awesome
07:21:41 <maerwald> for backend haskell is more common
07:21:44 <agohoth> whats a front end?
07:23:24 <boxscape> The part of a website that the user interacts with, the visuals and buttons such
07:23:37 <boxscape> *and such
07:23:40 <agohoth> huh?
07:23:47 <agohoth> I prefer model of server side web apps
07:23:52 <agohoth> www.happstack.com
07:24:56 <agohoth> The goal of Happstack is to fully exploit the unique properties of Haskell to create a web framework that is better than what could be done in any other language.
07:25:19 <boxscape> sounds good
07:25:49 <day> "better than any"....my gut tells me... NOPE
07:31:49 <tdammers> better on which axis
07:33:17 <maerwald> "it's more difficult to get anything done, but when you accidentially do, you will feel a rush of superiority" xD
07:33:36 <agohoth> werc.cat-v.org might be the dark horse
07:33:45 <agohoth> for werb domiantion and big data riches
07:34:26 <sm[m]> hey, ae van vogt! what made you say that agohoth ?
07:40:21 <alaendle> @pl \message -> do result <- eventLoop message; writeIORef continue result
07:40:22 <lambdabot> (line 1, column 43):
07:40:22 <lambdabot> unexpected ';'
07:40:22 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
07:40:36 <agohoth> I onyl discovered AE van vogt in my liek 40s 
07:40:45 <agohoth> Im so angery he waqsnt talked about more when I was yugner
07:40:51 <agohoth> him and jack vance and 
07:41:01 <agohoth> I found robert e howard and michael moorcock on my own
07:41:29 <agohoth> Haskell seems complex........can a smart haskell programmer beat a tcl and postgresql solution?
07:41:42 <agohoth> I read rob piek adnhe says data structures more improtant thatn algorithm
07:41:48 <agohoth> dubm code to query smart tables
07:42:05 <boxscape> % newtype N1 = MkN1 N2 deriving Eq; newtype N2 = MkN2 N1
07:42:05 <yahb> boxscape: ; <interactive>:193:31: error:; * Couldn't match representation of type `N2' with that of `N1' arising from the coercion of the method `==' from type `N2 -> N2 -> Bool' to type `N1 -> N1 -> Bool'; * When deriving the instance for (Eq N1)
07:42:14 <agohoth> does this mean a fast database is more powerful than a smart language liek haskell or lisp or smalltalk?
07:42:14 <boxscape> is there a non-recursive case where something like this happens?
07:44:36 <alaendle> @pl \message -> eventLoop message >>= writeIORef continue
07:44:36 <lambdabot> (writeIORef continue =<<) . eventLoop
07:45:39 <geekosaur> you can chain together pl and undo
07:46:01 <boxscape> %  newtype N1 = MkN1 N2 deriving Show; newtype N2 = MkN2 N1 deriving Show
07:46:02 <yahb> boxscape: 
07:46:07 <boxscape> % MkN1 undefined
07:46:13 <yahb> boxscape: MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1 (MkN2 (MkN1
07:46:27 <geekosaur> @. pl undo \message -> do result <- eventLoop message; writeIORef continue result
07:46:27 <lambdabot> (writeIORef continue =<<) . eventLoop
07:46:43 <unfixpoint> Is there a way to set static values (Word8 and String/ByteString) with cabal?
07:47:11 <geekosaur> CPP but that's kinda ugly
07:47:13 <unfixpoint> At the moment I'm using a separate module and `import Config` everytime I need such a value, is there a better/cabal way?
07:47:31 <unfixpoint> Yeah, I'd rather have a Config than CPP :(
07:48:09 <geekosaur> not sure if you can abuse backpack for this but I suuspect that ends up like the import Config solution
07:52:20 <alaendle> @pl \message -> (print message) >> (pure $ message == "exit")
07:52:20 <lambdabot> liftM2 (>>) print (pure . ("exit" ==))
07:52:39 <gobby> is there a way to use `ApplicativeDo` in a module that also has monadic do notation?
07:52:46 <unfixpoint> Hm, didn't know about backpack but doesn't look like it's an improvement over the current solution. 
07:54:34 <Boomerang> gobby: I thought ApplicativeDo would automatically choose between Applicative and Monad depending on the way the depdendencies work out for each do block
07:54:56 <c_wraith> gobby: ApplicativeDo just adds some special case desugaring rules so that if your do block matches them, it gets translated to using <$> and <*> instead of >> and >>=
07:55:53 <gobby> Boomerang apparently not: `No instance for (Monad Parser) arising from a do statement`
07:56:04 <gobby> I'm using `opt-parse-applicative`
07:56:12 <Taneb> agohoth: that sounds like you're not using ApplicativeDo at all
07:56:15 <unfixpoint> Boomerang: You can also refine the type, `do a <- ma; pure a` could be typed  as `Monad m => m a -> m a`
07:56:25 <Taneb> gobby: ^^ sorry
07:57:03 <gobby> Taneb the pragma is at the top of my module
07:57:33 <geekosaur> gobby, it also has to *be* Applicative
07:57:44 <geekosaur> if you do anything that requires Monad, it'll desugar that way
07:58:02 <geekosaur> this one's easy to get wrong. so what expression are you trying to write with ApplicativeDo?
07:58:39 <geekosaur> there are some common things in "do" that can't be done using only Applicative
07:58:47 <Boomerang> gobby what do the dependencies look like? For example `do a <- ma; b <- mb; pure (a, b)` is Applicative but `do a <- ma; b <- f a; pure (a, b)` is Monad
07:59:25 <geekosaur> specifically no <- can depend on any of the others; only Monad allows that
07:59:32 <Boomerang> I also think ApplicativeDo doesn't like when you finish the do block with fmap instead of `pure/return`
08:00:19 <geekosaur> probably; it looks for specific patterns, and that may be too difficult for it or it might be a missing pattern
08:01:10 <c_wraith> yeah, ApplicativeDo is limited.  It was mostly added as a way to let HAXL make some operations concurrent without needing to teach the people writing its rules about the difference between Applicative and Monad.
08:01:45 <boxscape> hm interesting that do syntax still works if Prelude isn't imported
08:02:11 <boxscape> i.e. something like  `do a <- Prelude.Nothing; (Prelude.Just b) <- Prelude.Nothing; Prelude.pure (a, b)` works in ghci without importing Prelude
08:02:27 <geekosaur> ghci does implicit imports with fully qualified names
08:02:41 <geekosaur> there's an extension to enable that in ghc, even, which is how ghci enables it
08:02:42 <c_wraith> if you use -XNoImplicitPrelude, it makes do notation desugar to whatever (>>=) is in scope, rather than the Prelude operator
08:02:52 <boxscape> but there's no >>= in scope
08:03:12 <c_wraith> did you use -XNoImplicitPrelude?
08:03:15 <boxscape> yes
08:03:17 <boxscape> and :m
08:03:32 <boxscape> (and :t (>>=) shows it's not in scope)
08:03:52 <hackerman> Hello. It is necessary to make an error output when starting the program without arguments.
08:03:52 <hackerman> Implemented similar through: `if`.
08:03:52 <hackerman> https://imgur.com/u19ljOT.png
08:03:52 <hackerman> But at launch: ./todo
08:03:52 <hackerman> Instead of printing your mistake.
08:03:53 <hackerman> I get: todo: user error (Pattern match failure in do expression at todo.hs:24:4-20)
08:03:55 <hackerman> How to fix it?
08:05:47 <c_wraith> Guess you need -XRebindableSyntax along with -XNoImplicitPrelude to totally get rid of that
08:05:52 <comerijn> hackage: Add the missing case to todo.hs on line 24?
08:06:01 <geekosaur> hm, looks like they changed it from implicitly importing on use to -f(no-)implicit-import-qualified
08:06:07 <comerijn> auto complete fail >.>
08:06:33 <c_wraith> boxscape: yeah, combine -XNoImplicitPrelude with -XRebindableSyntax
08:06:58 <c_wraith> boxscape: then even numeric literal don't compile because fromInteger isn't in scope.  :)
08:07:02 <geekosaur> hackerman, that's not going to work anyway, since it's null (something:something) it'll always produce False
08:08:00 <geekosaur> and the failure's in the pattern on the previous line since it insists there's at least one thing in the argument list.
08:08:17 <geekosaur> but note that getArgs does *not* give you the program name as the first parameter
08:08:21 <geekosaur> use getProgramName for that
08:08:24 <boxscape> c_wraith hm, that still leaves me confused about why it works when RebindableSyntax isn't enabled
08:08:40 <geekosaur> boxscape, because it's wired in
08:08:52 <boxscape> ah, ok, that does make sense
08:09:01 * hackage crypto-enigma 0.1.1.6 - An Enigma machine simulator with display.  https://hackage.haskell.org/package/crypto-enigma-0.1.1.6 (Orome)
08:09:08 <geekosaur> there's some discusssion in the ghc Commentary and in the users guide about wired-in names and RebindableSyntax
08:09:15 <boxscape> okay
08:09:29 <geekosaur> which is more or less why the RebidnableSyntax extension is necessary to begin with
08:12:01 * hackage patat 0.8.4.0 - Terminal-based presentations using Pandoc  https://hackage.haskell.org/package/patat-0.8.4.0 (JasperVanDerJeugt)
08:14:01 * hackage bv-little 1.1.1 - Efficient little-endian bit vector library  https://hackage.haskell.org/package/bv-little-1.1.1 (recursion_ninja)
08:17:08 <gobby> does Generic also derive monad instances?
08:17:22 <gobby> `deriving Generic`*
08:21:11 <geekosaur> I don't think so
08:21:23 <geekosaur> it's easy enough to also derive Monad there though
08:21:30 <geekosaur> presuming it can be derived
08:22:31 * hackage haskoin-core 0.9.2 - Bitcoin & Bitcoin Cash library for Haskell  https://hackage.haskell.org/package/haskoin-core-0.9.2 (xenog)
08:26:06 <Guest_90> i m trying to run ghci comman but its not working can anyone help me with that
08:27:20 <geekosaur> sure let people have time to respond >.>
08:27:45 <gobby> I think I figured out my `ApplicativeDo` issue. I'm using a `let` clause in my do block.
08:29:51 <evelyn> you could have something like do ... where ..., instead, and put your let clause after `where`.
08:30:25 <evelyn> (obviously, don't put `let` after `where`, but it should still be as clear to someone reading the code.)
08:32:23 <geekosaur> if you can't come up with a way to do that, you need to consider whether what you're trying to do is even possible using only Applicative
08:34:28 <agohoth> what is a monad?
08:35:14 <knightseq> test
08:35:53 <knightseq> is there something like GADTs for class declarations, like class Ord a => Myclass a where...
08:36:10 <gobby> geekosaur Removing the `let` clause and shifting my expression to a `where` clause solved my problem. Unfortunately the values in the applicative block that I needed for my let expression are not in scope so I had to turn my let value into a function inside the where clause
08:36:53 <geekosaur> knightseq, that looks like the start of a normal class declaration to me?
08:37:38 <knightseq> geekosaur you're right, it just compiled, learned something new :)
08:38:05 <geekosaur> keep in mind a typeclass is not an OOP class, if you're coming to this from another language
08:39:51 <c_wraith> agohoth: how much Haskell do you know?  There are a lot of correct answers to that question.  If you're a beginner, the most correct answer is "not something that's important right now".
08:41:30 <cheater> are foldrM / foldlM going to cause stack overflows?
08:41:31 <tdammers> you could say that a monad is "something that provides >>= and return"
08:41:56 <tdammers> and then of course the next questions would be "what's >>=?" and "what's return?"
08:42:54 <kuribas> bind
08:43:06 <phadej> something warm and fuzzy (i'd say return is warm and >>= if fuzzy)
08:44:03 <c_wraith> I still think my analogy to java's Iterator interface is about right.  It's a thing that's useful, the language provides some syntactic sugar for working with, and is not important to learning the language.
08:44:05 <cheater> are we writing a monad tutorial
08:44:30 <geekosaur> hopefully not
08:44:33 <cheater> a monad is like porridge
08:44:49 <cheater> wait, no. like scrambled eggs?
08:44:59 <geekosaur> a monad is.
08:51:28 <heatsink> a monad is a rainstorm spattering against the parched autumn rocks, for all the rain runs together and no one can put it back in the sky.
08:51:32 <cheater> the implementation of foldrM looks like it's going to have the same issues as foldr, is that correct? Why isn't there a foldrM'? https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Foldable.html#foldrM
08:52:11 <iqubic`> hello
08:53:27 <cheater> and also, would replacing foldl with foldl' fix that?
08:59:01 <Moe3> Hey guys is there anyone onlin
08:59:05 <lyxia> sure
08:59:08 <Moe3> online*
08:59:10 <rocket_man> I think it's interesting that haskell solved the https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/ problem with monads only to end up with the same problem for strict/non-strict
08:59:49 <Moe3> I am having a problem with using the ghci, I am using terminal (mac). I tried upgrading my ghci to the latest which is 8.8.1, but now I think I messed up the files somehow
08:59:51 <Moe3> GHCi, version 8.8.1: https://www.haskell.org/ghc/  :? for help<interactive>:1:1: error:    • Failed to load interface for ‘GHC.GHCi.Helpers’      Perhaps you haven't installed the "dyn" libraries for package ‘base-4.13.0.0’?      Use -v (or `:set -v` in ghci) to see a list of the files searched for.    • In the expression:
08:59:52 <Moe3> GHC.GHCi.Helpers.disableBuffering      In an equation for ‘_compileParsedExpr’:          _compileParsedExpr = GHC.GHCi.Helpers.disableBuffering
08:59:59 <Moe3> I get this error when typing ghci in the terminal
09:00:04 <Moe3> could anyone please help me fix this issue
09:00:28 <rocket_man> Although I guess you can call strict functions from lazy functions and vice versa, so it's only an issue for the implementor? The caller still needs to keep track of strictness though since it's not part of the type system
09:01:35 <cheater> ok so it looks like it doesn't matter if the monad's bind is strict, and in my case, IO is strict https://stackoverflow.com/questions/8249958/folding-function-composition-monads-and-laziness-oh-my/8250334#8250334
09:02:58 <cheater> rocket_man: yes, if a single value could have multiple types assigned to it, we cold have a special kind of types for strictness, and a special kind of types for runtime complexity.
09:03:28 <cheater> even for space complexity
09:20:14 <inkbottle> I've got an explicit forall in a tuto: How do I know what extension I must enable? https://haskell-at-work.com/episodes/2018-04-09-your-first-web-application-with-spock.html
09:24:16 <c_wraith> You probably want ScopedTypeVariables
09:25:09 <inkbottle> OK
09:25:21 <c_wraith> though...  that doesn't look like something you're supposed to implement
09:25:30 <inkbottle> indeed
09:25:30 <c_wraith> that looks like it's pointing out something in the library
09:27:01 <inkbottle> This tuto is fun and you can't download the sources, you have to actually read it and "type" it
09:29:51 <dmj`> I think passing in GHC arguments to runghc is broken
09:30:01 <dmj`> --ghc-arg as the guide says doesn't seem to work
09:35:31 * hackage git-annex 7.20191009 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-7.20191009 (JoeyHess)
09:37:43 <boxscape> dmj` `runghc --ghc-arg=-fdefer-type-errors file.hs` works for me on both 8.6.5 and 8.8.1
09:40:23 <inkbottle> c_wraith: there, it works: https://paste.debian.net/1105573/
09:50:02 <dmj`> boxscape: -threaded works ?
09:51:25 <boxscape> dmj` threaded is a runtime system option, right? So you probably have to do something like runghc --ghc-arg="+RTS -threaded -RTS", but I'm not sure of the exact syntax
09:52:00 <boxscape> dmj` https://stackoverflow.com/questions/29339643/how-can-i-pass-rts-options-to-runghc
09:52:31 <boxscape> dmj` from that it sounds like you can't actually pass runtime system options via --ghc-arg
09:53:07 <dmj`> I don't think it's a runtime system arg, like -N
09:53:15 <boxscape> hmm
09:53:31 <sm[m]> it's a ghc flag
09:53:34 <boxscape> yeah okay
09:53:39 <dmwit> -threaded is a compile-time flag
09:54:01 <dmwit> But runghc does not compile.
09:54:15 <dmwit> (Well. It's a link-time flag.)
09:55:40 <dmj`> dmwit: I'm trying to do something like this: runghc Setup.hs build pm --builddir=dist-pm-runner --ghc-arg=-threaded
09:56:12 <dmwit> I don't think you can choose which runtime runghc uses.
09:56:31 <dmwit> But I'm pretty sure it uses the threaded runtime by default anyway, so...?
09:57:39 <dmj`> when I try to run it dist-pm-runner/build/pm/pm +RTS -N -RTS I get an error about it needing to be compiled with threaded, maybe I'm just off by a character or something
10:00:57 <dmwit> Oh, I understand the question now.
10:01:11 <dmwit> You're confused about what you want. ^_^
10:01:42 <dmwit> --ghc-arg passes arguments to *runghc* for choosing how Setup.hs should be run.
10:01:53 <dmwit> But you want to pass arguments to *the ghc that Setup.hs runs*.
10:02:06 <cheater> is there a way in haskell to find all subexpressions that have a specific type?
10:02:15 <dmwit> For that, you can almost certainly pass --ghc-opts to Setup.hs unless Setup.hs is especially weird.
10:02:15 <cheater> when compiling with ghc of course
10:02:35 <dmwit> So something like runghc Setup.hs -- build pm --builddir=... --ghc-options=-threaded
10:02:50 <dmwit> But probably the -threaded thing should just go in your cabal file...?
10:03:08 <dmwit> I can't remember whether -threaded is allowed as a build argument or only during the configure phase.
10:03:28 <dmwit> So you may even need something like runghc Setup.hs -- configure --ghc-options=-threaded && runghc Setup.hs -- build pm --builddir=...
10:03:56 <boxscape> what's the use case for running a Setup.hs file manually? I've never done that
10:04:01 <sm> runghc --help ways "--ghc-arg=<arg>       Pass an option or argument to GHC"
10:04:04 <sm> says
10:04:20 <dmj`> it's weird because -threaded *is* in my cabal file
10:04:36 <dmwit> sm: Yeah, but it's getting passed to the wrong ghc.
10:04:39 <dmwit> dmj`: sohw
10:04:41 <dmwit> dmj`: show
10:04:52 <dmj`> dmwit: ok, let me reproduce
10:05:03 <dmwit> boxscape: I think no, but see also :type-at
10:06:33 <boxscape> dmwit uhm, that doesn't seem like an answer to a "what is" question, and where do I have to enter :type-at?
10:06:49 <dmwit> boxscape: and :all-types, too, I guess
10:07:10 <dmwit> boxscape: Oh, sorry, misnick.
10:07:16 <boxscape> kk
10:07:18 <dmwit> cheater: I think no, but see also :type-at and :all-types.
10:07:36 <dmj`> so when I do this
10:07:41 <dmj`> runghc Setup.hs build pm --builddir=dist-pm-runner --ghc-arg=-threaded
10:07:52 <dmj`> I get: unrecognized 'build' option `--ghc-arg=-threaded'
10:08:16 <dmwit> dmj`: It isn't ghc-arg, it's ghc-options
10:08:21 <dmwit> or maybe ghc-opts, I can't remember
10:08:24 <dmwit> --help will know
10:08:51 <dmj`> according to the latest ghc user guide it says, "Alternatively you can use the runghc option --ghc-arg=<arg> to pass any flag or argument directly to GHC."
10:09:03 <dmj`> and --help says
10:09:05 <dmj`>  --ghc-arg=<arg>       Pass an option or argument to GHC
10:09:12 <dmwit> I know. As I told both you and sm now: that's passing -threaded to the wrong ghc.
10:09:25 <dmwit> And I'm talking about runghc Setup.hs -- --help, not runghc --help
10:09:35 <dmwit> Well, runghc Setup.hs -- build --help
10:09:36 <cheater> dmwit: i googled for those but found nothing. what do they do?
10:09:59 <dmwit> cheater: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html?highlight=type#ghci-cmd-:all-types
10:10:25 <boxscape> % :type-at
10:10:25 <yahb> boxscape: Couldn't read "" as String
10:10:32 <boxscape> oh it needs an argument
10:13:46 <cheater> oh, type-at is like a dual of what i want.
10:17:08 <cheater> thanks a lot dmwit 
10:17:47 <EvanR> type-at me bro
10:24:44 <dmj`> dmwit: it seems to have worked... --ghc-option=-threaded, the strange part is runghc Setup.hs build pm && dist/build/pm/pm +RTS -N -RTS complains about -threaded not being enabled despite it being in the cabal file. This could also be an issue where the old object files are being used. Now it just gets stuck in building or linking , which is odd
10:24:58 <dmj`> (after cleaning)
10:27:00 <monochrom> data Song = Batman | Na Song
10:27:20 <sshine> haha
10:27:51 <dmwit> dmj`: show us your cabal file
10:28:51 <monochrom> @quote dfletcher Batman
10:28:51 <lambdabot> dfletcher says: > ((++" Batman!") . take 48 . cycle . show) (0/0)
10:29:13 <monochrom> @quote fgaz Batman
10:29:13 <lambdabot> fgaz says: > (++ " Batman!") $ join $ replicate 7 $ show (0/0)
10:29:25 <monochrom> (Note: 0/0 becomes NaN.)
10:29:45 <EvanR> oh... MaN
10:29:51 <monochrom> haha
10:31:58 * dmj` generates cabal file from hpack
10:33:06 <dmj`> dmwit: https://gist.github.com/dmjio/5b8fe90e70bd3f48d0d6984855b75ab4
10:34:30 <dmwit> weird
10:34:31 <dmwit> looks ok
10:34:53 <dmj`> yea I assume that both ghc-options sections will get combined, one before the conditional, and one inside the conditional
10:37:02 <dmwit> yes
10:37:42 <dmwit> And complaining about not having -threaded survives a clean and rebuild?
10:37:45 <dmwit> weird
10:37:53 * dmwit doesn't have an explanation
10:39:59 <olle> is there a way in haskell to forbid side-effects in a function? i.e., not use the IO monad or any other things.
10:41:08 <lyxia> functions already don't have effects
10:41:13 <koala_man> are you trying to sandbox potentially malicious code?
10:41:30 <cocreature> olle: just don’t use IO in your type? or are you trying to protect against a malicious attacker that can use unsafePerformIO and similar shenanigans?
10:41:34 <olle> koala_man: I'm trying to increase testability
10:41:45 <dmwit> olle: {-# Language Safe #-} and give it a type whose return is visibly not IO.
10:41:55 <olle> cocreature: ah, so IO is always in the type signature if IO is used?
10:42:08 <dmwit> If you aren't worried about adversaries but rather about uncareful programmers, you can probably skip the {-# Language Safe #-} bit.
10:42:26 <cocreature> yeah you can’t escape IO (unless you deliberately do so using something like unsafePerformIO)
10:42:27 <dmwit> olle: To a first approximation, yes, once in IO always in IO.
10:42:41 <dmj`> dmwit: yea, it doesn't even get to the part where it begins compiling the modules, just immediately yells at me when I try to evaluate this bash function https://gist.github.com/dmjio/77a9ade8ab424add2303a37bb2b6b21b
10:42:44 <olle> cocreature: ok
10:42:44 <cocreature> so if you’re after testability just having a type signature that forbids IO is totally sufficient
10:42:55 <olle> cocreature: +1
10:43:54 <dmwit> dmj`: Oh, you're again passing arguments to the wrong runtime.
10:44:02 <dmwit> dmj`: You need --RTS +RTS -N -RTS.
10:44:17 <dmwit> dmj`: So that you're passing the arguments to .../pm instead of to runghc.
10:45:22 <dmj`> dmwit:  dist-pm-runner/build/pm/pm --RTS +RTS -N -RTS
10:45:36 <dmwit> In that script, yes.
10:45:37 <dmj`> seems to start building, which invocation of runghc does --RTS terminate ?
10:45:45 <dmwit> The --RTS can go anywhere in the command line, so long as it's before the +RTS.
10:46:00 <dmwit> There is only one invocation of runghc there. ^_^
10:46:23 <dmwit> Well, anyway. It terminates the first one.
10:47:16 <dmj`> I'm still confused. By the time we call dist-pm-runner/build/pm/pm, runghc should no longer be in the picture
10:47:31 <dmj`> we're just using it to create the pm binary
10:47:35 <dmwit> The whole damn line is a big long collection of arguments to the outermost runghc.
10:47:46 <dmwit> *Including* the +RTS -N -RTS at the end.
10:48:13 <dmwit> You're *hoping* that it passes those arguments along to util/Runner.hs, and util/Runner.hs passes them along to dist-pm-runner/.../pm. But it ain't so.
10:48:30 <dmwit> runghc gobbles up any +RTS in its arguments, no matter where... until it sees a --RTS of course.
10:48:52 <dmj`> so --RTS escapes the outermost call to runghc, and passes it into the binary
10:49:00 <dmj`> dmwit: should I be wrapping everything in quotes ?
10:49:13 <dmwit> Won't help. The shell isn't mangling anything important here.
10:49:40 <dmj`> Util.hs is just a file watcher to reload the call to configure, build and dist/../pm/pm .. etc
10:49:51 <dmj`> I've never even seen --RTS before
10:50:07 <dmj`> hidden features of ghc 
10:50:16 <dmwit> Not very hidden. +RTS --help describes it
10:51:17 <dmj`> oh wow, yea I see it
10:51:21 <dmj`> runghc:   --RTS    Indicates that ALL subsequent arguments will be given to the
10:51:21 <dmj`> runghc:            program (including any of these RTS flags)
10:52:22 <dmj`> dmwit: very cool, thanks :)
10:52:49 <dmwit> (Also described in the GHC manual of course.)
10:52:54 <cocreature> note that `--` which is a bit more common outside of Haskell also disables processing of following RTS flags with the difference being that the program sees the `--` itself (which can be useful with things like optparse-applicative)
10:52:58 <dmwit> (But it's a big manual, and easy to overlook this stuff.)
10:53:18 <dmwit> -- doesn't disable RTS processing
10:53:38 <dmwit> oh wait
10:53:44 <dmwit> It does, wow!
10:54:17 <dmj`> I don't see --RTS in the manual
10:54:39 <cocreature> dmwit: I’m not making this up! https://gitlab.haskell.org/ghc/ghc/blob/f691f0c21dcc576e02313123e8b091e241d23b51/rts/RtsFlags.c#L694
10:55:25 <dmwit> dmj`: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-opts-cmdline
10:55:41 <dmwit> cocreature: Yeah, neato!
10:56:32 <dmwit> The two documentation spots I pointed at don't mention --.
10:56:45 <dmj`> well I'll be
10:59:08 <dmwit> cocreature++
10:59:39 <dmj`> dmwit: it seems to respect the cabal file now, doesn't complain if I don't have --ghc-options=-threaded
10:59:46 <cocreature> dmwit: yeah I think I found it by accident and then read the source to confirm it works as I thought it does
10:59:51 <cocreature> I should send a docs patch at some point
10:59:56 <dmwit> yeah!
11:00:09 <dmwit> dmj`: rad
11:02:26 <dmj`> that cocreature is always on the ball
11:11:30 <oats> where should I add dependencies when I'm using the simple stack template? I've been adding them to package.cabal, but I thought that file was supposed to be auto-generated by package.yaml
11:11:38 <oats> which doesn't seem to be present in the simple template
11:14:28 <fendor> oats, if you dont have package.yaml, you have to add it to your *.cabal file
11:16:03 <oats> fendor: thanks!
11:23:08 <olle> just trowing a thing out there: what would you thinkg about a language where side-effects are allowed BUT only on the first level of the stacktrace?
11:32:22 <sternmull> isn't that what Haskell does? IO actions have to bubble up to main to be evaluated.
11:45:05 <siraben> Is it possible to write an Applicative instance for an exception monad transformer without the monad constraint?
11:45:06 <siraben> http://ix.io/1Yal
11:45:55 <siraben> I haven't been able to figure out how to write (<*>) :: EXC m (a -> b) -> EXC m a -> EXC m b without unwrapping the function via (<-) in do-notation
11:46:12 <lyxia> no, because you need to look at the result of the first action to decide whether to run the second one
11:46:17 <glguy> siraben: No, not if you want the behavior to be that if there's an exception in the first argument of <*> that it doesn't run the second
11:47:10 <cocreature> which is why the applicative instance of "ExceptT e m" is not the same as Compose m (Either e)
11:47:51 <siraben> Ah, so the Monad constraint is necessary then.
11:48:51 <olle> sternmull: is it?
11:49:06 <olle> sternmull: but you can still "schedule" a database access at lower levels?
11:49:10 <EvanR> sternmull: bubbling sounds like permuting tree nodes
11:49:28 <EvanR> rather if you have a computation that results in an IO action, the nodes don't even exist yet
11:49:43 <olle> nodes?
11:50:35 <EvanR> you can pick your friends, you can pick your nodes, but don't pick your friend's nodes
11:50:45 <sternmull> yes "bubbling" was the wrong word. "Passed to" is probably more correct.
11:50:50 <dmwit> olle: I write `main = foo; foo = putStrLn "hi"`. Does this qualify as "at the first level of the stacktrace" for you?
11:50:59 <dmwit> If not, I hate your idea, because it means I cannot do any abstraction.
11:51:13 <olle> dmwit: yes, that would be the drawback
11:51:29 <olle> dmwit: I mean, you can extend it to first or second level, but the point was to have a limit
11:51:48 <sternmull> how would that be useful?
11:51:54 <siraben> lyxia:  glguy: What about for the applicative instance of the state transformer monad?
11:51:54 <olle> sternmull: testability
11:52:01 <siraben> Is it possible to write it without a monad constraint?
11:52:18 <cocreature> olle: how does that increase testability?
11:52:30 <olle> cocreature: side-effects destroy testability
11:52:31 <dminuoso> siraben: Well that's sort of what a superclass means..
11:52:34 <olle> it is known ^^
11:52:54 <dminuoso> siraben: The fact that we tend to write Functor/Applicative in terms of Monad is not out of necessity, its just out of convenience
11:53:08 <siraben> Ah, I see.
11:53:45 <cocreature> olle: I’m not sure that’s true in general but yeah they definitely make it harder. What I don’t get is why forcing users to cram all their side effects into one big definition at the top-level makes things easier to test than allowing them to write their side effects in small isolated pieces that you might be able to test a lot easier than testing everything together.
11:54:03 <siraben> Is the a categorical reason why we cannot write an Applicative instance for monad transformers without the Monad constraint?
11:54:23 <olle> cocreature: hm, an alternative would be a language where you CANNOT mix statements and expressions in the same function
11:54:25 <siraben> Something to do with "unwrapping" the function in m (f (a -> b))
11:54:26 <dmwit> I think no. Each transformer has its own unique reason.
11:54:37 <techro> Hello guys! Can I ask a simple question here? I can't seem to find an answer anywhere :(
11:54:47 <dminuoso> techro: Shoot.
11:54:56 <olle> cocreature: the problem with freedom is that it is abused. the language has to enforce the discipline.
11:55:01 <dmwit> As evidence: instance Applicative f => Applicative (ReaderT r f)
11:55:35 <dmwit> So any reason that Applicative is not a good enough constraint cannot generalize to all transformers.
11:55:45 <techro> I am trying to count non empty list in a list of lists. I tryed to do it this way but it doesn't work: nonEmptyCount :: [[a]] -> Int
11:55:48 <cocreature> olle: I think that’s better enforced on a case by case basis in code review than trying to enforce it via a somewhat arbitrary restriction at the language level
11:55:55 <techro> sorry for the formatting hit enter accidentaly
11:56:22 <dminuoso> techro: So what exactly should that do?
11:56:49 <dminuoso> techro: Count how many inner lists are empty/not-empty?
11:56:53 <siraben> dmwit:  Ah I see.
11:57:06 <techro> I want to generate a list that contains all the non-empty lists, then count that first list so I get the number of all the non-emtpy lists
11:57:30 <techro> dminuoso
11:57:44 <dmwit> Are you also known as Beszteri on StackOverflow?
11:58:06 <techro> No, did he ask the same question?
11:58:26 <dmwit> Yes. I am hoping you are not yet done asking, and so not yet making the same mistake they did.
11:58:41 <dmwit> What's the rest of your attempted implementation look like?
11:59:08 <EvanR> a list of all infinite lists?
11:59:34 <EvanR> it's like cantor's bat signal
11:59:38 <techro> nonEmptyCount [] = 0;
11:59:41 <dminuoso> There's infinite reasons why you might want that, EvanR.
11:59:45 <techro> This is the code I wrote so far
12:00:03 <techro> Do I need to use recursive code here?
12:00:20 <techro> (sorry for my dumb questions, I'm a beginner)
12:00:24 <dmwit> You do not need to use explicit recursion. But it will certainly be one easy way to proceed.
12:00:28 <dminuoso> techro: Is this some sort of homework assignment?
12:00:33 <techro> Yes
12:02:10 <olle> cocreature: sad
12:02:34 <dminuoso> techro: Well, you did wonder whether to use recursion. Have you tried following that train of thought?
12:02:35 <olle> cocreature: isn't that the same thing as saying, it doesn't matter if you use php or haskell, the code review will solve it anyway
12:03:15 <techro> dminuoso Yes, but I can't figure out how to implement it I feel so dumb
12:04:00 <techro> We only learned about recursion recently but I need to use it in this assignment
12:04:00 <cocreature> olle: I don’t think it is. things are not black and white. I don’t think enforcing everything at the language level is something worth aiming for. That doesn’t mean that I think nothing should be enforced at the language level
12:04:02 <dmwit> techro: It's probably also worth telling us a bit about your course's policy on seeking out external help, so that we do not accidentally do something that may get you in trouble.
12:04:43 <techro> dmwit We just have to submit the code, we don't get any points its just homework for our own good
12:04:53 <sternmull> olle: In Haskell you see if a function uses IO actions because its type signature tells it is in the IO monad.
12:05:00 <techro> dmwit I could submit a googled code and get a good result but I want to understand it
12:05:20 <dmwit> Okay, cool, that opens things up a lot. Thanks.
12:05:48 <olle> sternmull: yeah, but you can put IO at main and then all bets are off
12:06:10 <sternmull> why that?
12:06:56 <sternmull> You can use pure functions inside main (or other IO actions) and you immediately can see on the type that you don't have to consider IO when you want to test them.
12:07:07 <cocreature> putting IO at main isn’t the issue. the issue is not separating your logic so that there are parts outside of main that are not in IO
12:07:18 <olle> hm
12:07:26 <EvanR> it would be cool to test IO code
12:07:34 <EvanR> using mocks or something
12:07:34 <techro> In fact, can I use recursion inside a list comprehension?
12:07:39 <jellostahps> I am having trouble understanding how the 'x' and 'y' are figured out in the last list comprehension function: https://pastebin.com/s38DgDyL
12:07:44 <dmwit> techro: Yes.
12:08:08 <olle> EvanR: we test side-effects extensively
12:08:13 <olle> file access, database access
12:09:08 <dmwit> jellostahps: Do you understand how x and y are figured out in `[x+y | (x,y) <- [(1,5),(2,7)]]`?
12:09:30 <cocreature> I don’t find mocking side effects that useful. I prefer factoring out the logic from the side effects so that I can nicely test the logic in isolation without having to mock side effects and then have integration tests for the side-effecting part that actually test what I care about instead of some mock that misses all the tricky parts of actually doing side-effects
12:09:52 <jellostahps> dmwit: I would just be guesing, but there doesn't seem to be any other choice other than being the first tuple in the list
12:10:09 <dmwit> Cool. It turns out there are other choices!
12:10:11 <EvanR> yeah i was wondering to the extent it's even feasible
12:10:26 <EvanR> sounding good in a meeting is one thing, actually benefiting is another
12:10:37 <dmwit> In particular: you can loop over all the tuples in the list.
12:10:44 <dmwit> (And this is in fact the choice that Haskell makes.)
12:11:04 <dmwit> The "body" of the loop is to the left of the |. So in my example, that's `x+y`.
12:11:42 <dmwit> > [x+y | (x,y) <- [(1,5),(2,7)]]
12:11:43 <lambdabot>  [6,9]
12:11:53 <dmwit> jellostahps: Does this result ^ now make sense to you?
12:12:12 <jellostahps> 1 sec
12:13:01 <techro> nonEmptyCount :: [[a]] -> Int
12:25:52 <jellostahps> dmwit: yes I think so. So, the list comprehension iterates through all the elements in the provided list?
12:26:03 <merijn> sm[m]: The way I robustly do auto-paging is my not caring at all about Windows. Which is probably not the answer you wanted yesterday ;)
12:26:12 <dmwit> jellostahps: yes
12:26:27 <ooo_miguel> Eh I'm trying to parse some xml with xmlbf-0.4.1 but I am utterly failing. Anyone was successfull and/or can point me to a simple example?
12:26:36 <jellostahps> dmwit: ill get back once i try to look at my example that way
12:28:01 * hackage language-javascript 0.7.0.0 - Parser for JavaScript  https://hackage.haskell.org/package/language-javascript-0.7.0.0 (ErikDeCastroLopo)
12:28:35 <techro> nonEmptyCount :: [[a]] -> Int
12:31:50 <jellostahps> dmwit: so in my code, myzip creates a list of tuples. One by one those tuples are assigned the value x and y, and then checked for if x==y, and if the test passes then that tuple is added to the final list. Finally, myhead only returns the first (tuple?)
12:32:08 <jellostahps> https://pastebin.com/s38DgDyL
12:32:10 <dmwit> Sounds right to me.
12:32:39 <jellostahps> ah the back and forth can get confusing.
12:35:26 <cheater> using hedgehog, how can i create a subsequence of a list in a random fashion? i am using randomIO, but that isn't controlled by Hedgehog's random seed.
12:35:43 <jellostahps> oh wait, its wrong, cuz in the list comprehension, the list is made of just the first element of the tuple, so the final list is of non-tuple elements. meaning myhead returns the first instance of  a repeated element in the list.
12:41:40 <sshine> cheater, http://hackage.haskell.org/package/hedgehog-1.0.1/docs/Hedgehog-Gen.html#v:shrink says "Apply a shrinking function to a generator.
12:41:52 <sshine> This will give the generator additional shrinking options, while keeping the existing shrinks intact."
12:43:20 <sshine> cheater, if you do you want to create subsequences for shrinking purposes, or for some other purpose?
12:45:46 <sshine> cheater, if it's for shrinking, I'd go through 'shrink'. if it's because you are constructing a generator, you could generate two random indices using 'int' in the range of (0, length xs) and extract the subsequence using 'take' and 'drop'.
12:49:09 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
12:49:09 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
12:49:09 --- names: list (clog jgt nschoe cosimone jneira otulp linarcx Intensity Lears saml_ oisdk_ mdunnio merijn paulasdf___ ooo_miguel nineonine SquidDev Deide milanj raichoo jellostahps mossplix aleator toony1 rosalux kupi captjakk_ bahamas ravenousmoose doublex roman2 paulasdf fendor_ ahri justanotheruser oats Ariakenom khisanth_ replay olle nbloomf toblorone sektor dansho housecarpenter_ Tsukimaru msvan dbmikus_ rsoeldner gienah gehmehgeh jathan stepnem_ fphilipe alx741 Ulrar)
12:49:09 --- names: list (p0lyph3m vise890 topos prophet boxscape Sheilong Lord_of_Life stux|RC takuan pfurla acidjnk_new wildtrees ht_ seventh__ o1lo01ol_ s00pcan Neuromancer zerotech machinedgod xff0x DoYouKnow t7 dale greggerz cpape nckx daGrevis agohoth lucasb toppler Folkol LnL pacak cgfbee myme abuss wrengr raoulb Jello_Raptor notzmv jluttine carlomagno sandman13 fiatjaf krystianbajno lnostdal darjeeling_ dredozubov zymurgy rodgzilla blackdog lemald relrod vktec eldritch ullbeking)
12:49:09 --- names: list (nyaomi sternmull Cathy AkhILman d3lxa epta affinespaces dddddd Robin_Jadoul haskell_enthusia kAworu_ adarshaj crooked Xandaros PHO jameekim1 day pharaun dmwit andromeda-galaxy mrus JSharp barrucadu w1gz hodapp jlamothe lagothrix mmaruseacph2 kosmikus Guest31486 Maxdamantus gregberns_ sethetter_ haveo simplegauss_ tumdedum tureba_ juri__ drdo pasukon Tspoon__ mxf_ lstdgtfp_ Guest53666 atle_ Kneiva_ nefercheprure kiix1 PierreM_ Entroacceptor dfordiva1 Ke mikolaj__)
12:49:09 --- names: list (ybit marble_visions_ nitrix tsahyt_ codedmart Sparadox fiddlerwoaroof_ bbear_ implementation telser- mulk kuttifunk dunningk- sujeet w1d3m0d3 theophil97 zekt83 carldd1 unyu cr3 stef204 cybai ddellacosta bermraj guyit cheater hyperisco keep-learning[m] spew grag[m] jonge[m] labs[m] lions[m] Richy[m]1 Testitunnari[m] betz[m] gentlehelm[m] DenisLehmann[m] slrtbtfs[m] edwel[m] matrixyz[m] luminousnine[m] NickHu joe[m]5 georgescratcherd neurocyte[m] entropi[m])
12:49:09 --- names: list (ist5shreawf[m] eckt[m] sicklork1n jwaksbaum[m] torkel[m] josiah_sama voyons_osti jlvvlj[m] maigel[m] laniusfnv[m] nolep[m] alice[m]1 absnc benzoid[m] alibabzo fiberpunk[m] olmvnec[m] buggeas40d[m] rihardsk[m] ldesgoui[m] Ekho[m] atopuzov[m] Orbstheorem[m] mujx[m]1 Lite[m] mssx89m[m] cesar[m] fiddeldibu[m] jibby[m]1 rgamma[m] jwerner[m] case_ratchet[m] aryaan[m] intellection3to3 BaMaung[m] fabianhjr[m] lerowukta[m] boutil[m] D[m]2 Hanma[m] kaster[m])
12:49:09 --- names: list (Bertschneider[m] mmynsted[m] tomtau[m] erasure[m] vsts[m] JakeO[m] whoops Ericson2314 spacekitteh[m] rahduro[m] peter-js[m] xmpln[m] eruvarn[m] PonyDuck3000[m] Mesa[m]1 josef[m] eyenx[m] jumzi[m] kaychaks[m] EuAndreh[m] xalek[m] aitzol[m] neiluj[m] hans[m]6 LasEspuelas twom[m] ppseafield[m] zmlww[m]1 richardax[m] guiraldelli[m] Mitch[m] kupo_[m] Hakan[m] jibby vikraman iffsid themsay[m] ChrisPenner[m] humanwire[m] tuxsoy alephu5[m] seekerus3r[m] pothyurf[m])
12:49:09 --- names: list (likliklik abbe[m] hsw[m] dlilja[m] midi[F][m] MrAxilus yesided[m] triste[m] kai10[m] markus[m]4 Chromad[m] Ben[m]5 foxadee[m] unitymember[m] meu76[m] jak[m]1 NickHu1 Soft[m] joenase[m] asonixDogHeThey[ Wizek[m] shiroeni[m] fulgjon MichalLaskus[m] blakec[m] sputny[m] imposs[m] pleasesendnudes[ amb007[m] alex[m]17 vkleen PrimeSeeker[m] denbrahe[m] alxev[m] n0ma_d[m] amerocu[m] fswalker[m] vector[m]1 ninjatrappeur[m] hjoest[m] hovgaard[m] cbg[m] parmesan[m])
12:49:09 --- names: list (anton-latukha[m] edejong[m] admdch[m] elfets nnm imdoor[m] pietromrtn[m] butterth- Kaivo OnkelTem umachan jeltsch Batholith solonarv poljar1 MarcelineVQ unlink2 DTZUZO_ jedws phreedom hpc gargawel Cthalupa sfvm Anthaas lprd NinjaTrappeur Wuzzy sw1nn __monty__ jakalx rruizt delYsid spion thc202 regakakobigman logzet abhixec danvet mceier cynick meck ephemera_ tromp reggie__ ChaiTRex feuerbach zaquest lemmih maralorn theDon andi- mountaingoat d34df00d crobbins)
12:49:09 --- names: list (sshine uberj_ dolio Igloo moldybits nemesit|znc aarvar dazage MonkeyNOS calloc raduom quintasan ph88 nullifidian jb55 SCHAPiE thaumavorio hc inkbottle Sgeo gwern Velpoman JoelMcCracken m0rphism wild_buffalo suppi markus1189 good2cu tombusby defanor_ mjuad hackage wire[m] insanitea gabiruh Digit atk sigmundv_ perrier-jouet sagax MindlessDrone ichor DrAwesomeClaws Yucheng mozzarella Paks _ashbreeze_ linduxed ericsagnes wonko77 jdt mounty phadej zfnmxt infinity0)
12:49:09 --- names: list (tomboy64 DTZUZU theorbtwo thyriaen[m] biox[m] mat8913[m] kylos[m] johanejg[m] k4l1gr4[m] nalix[m] neat72[m] Mougan[m] qasim[m] luisjira[m] jdks[m] xethrog42[m] rainbyte[m] ponette[m] shachiku[m] M31violet13[m] buster528[m] haskelllisp[m] xlogan[m] BoraKaplan[m]1 periapseez[m] gd2398[m] M2ktsre[m] imp0s5ible brevalda[m] kicker22004[m]1 Bimmie[m] mithrandi[m] legowheels[m] Rama[m] than1133[m] danielemarsella[ dl3br[m] M|GNUisnotLinux[ trevortknguyen[m jlorand[m])
12:49:09 --- names: list (mgiagante[m] Alec[m]1 adziahel[m] afontain[m] PotatoRick[m] Surgeon[m] Syllo[m] zopsi[m] hackeryarn[m] Cloud[m] alana[m]1 pschooom[m] patonw[m] Undefined[m] greta[m] thekyriarchy[m]1 maxmaguire[m] cepxuo jochens[m] AkikoHimenokoji[ firefly1927[m] jonreeve[m] natmac[m] MerlinGttlinger[ avocado yi[m] uelen[m] rgh[m]2 brandon123[m] glothit7ok[m] cal[m] tkots[m] ryemantis[m] bobach[m] ghastfilms[m] nartir[m] atpotts texpat[m] dice[m]1 tasrev[m] flawr[m] pagoda_5b[m])
12:49:09 --- names: list (tmallard[m] sayukimans[m] klaadum[m] ciroyo[m] jay[m]1 Cenion[m] noteventime abc123zzz[m] vespuccy[m] yur3shmukcik[m] wrunt[m] M0ddba11[m] dustyp[m] GNULambda[m] cawal[m] Kit[m]2 zorkedon[m] ciet[m] Kenneth[m] kxra[m] blake_rain[m] adaizen[m] hifutakiko[m] ludovicdanjoumad liso[m] tempaccount1[m] AMlivinfree[m] Paavo[m] unrooted[m] actartis[m] deikatsuo[m] jhgarner[m] carola[m]1 heyakyra[m] yrid[m] TheD6[m] donnyllionaire[m charliebucket[m] jeeg[m] inkstain[m])
12:49:09 --- names: list (contrun[m] bartholomews[m] dude[m]1 unclechu hr[m] midi[m] AaronWeiss[m] GhostofaConsole[ abdolence[m] rowan[m] markalanrichards jak[m] jorge-jbs[m] d0g01[m] grorg[m] cabalcorp[m] hamechi[m] testacc3[m] alko[m] somni[m] gkobeaga[m] hoohaw[m] reconmaster[m] Daquilla[m] moats mouse008[m] pqwy[m] pablo-pie[m] snupples[m] JoGoSi[m] zukken[m] krowlan3[m] GNULizard[m] rinor[m] GreenKarm[m]1 corin[m] vorbex[m] nybble41[m] Cele[m] ilmu[m] freu[m] reedhhw[m] ShujaRafi[m])
12:49:09 --- names: list (gspia[m] deklund[m] JulesRen-Georges souldev[m] sergiotarxz[m] jesusvega[m] kumarbis[m] soaoaig[m] makos999[m] bt[m] provessor[m] arianvp[m] guzmanillo[m] masaeedu[m] olep[m] Gw3n[m] themadman[m] beatricejensen[m vigilian[m] bkl[m] Noughtmare[m] aquarial[m] korlaplankton[m] thosgood[m] talvdav[m] jg[m] odd13[m] Vincent[m]1 teaknow[m] gmips[m] Grgoire[m] tarigo[m] se224[m] lapav[m] cyclops19[m] SamuelH[m] NirvinM[m] nasius[m] PhilipWhite[m] chris[m]12)
12:49:09 --- names: list (suppenkasper[m] janustroelsen[m] ovigren vhzr[m] Rich[m] EmilKarlson wobbol[m] keith[m] beaverfever[m] petrolifero[m] quiet_laika[m] potato44[m] sm[m] ircer[m] akt[m]1 corin[m]1 vars[m] lukasubo[m] kinga06[m] aterius apurvapavaskar wildtrees[m] godzilla[m] steamedbun[m] dxml[m] dikini[m] hogarth[m] RIOTIM[m] shanesveller[m] lihram kitsune[m] cosson[m] kahuna[m] godva[m] MarquisKurt[m] papazeus[m] sphalerit ad5twoknebor[m] triskeon[m] M2en[m] arturo[m] oniani[m])
12:49:09 --- names: list (Eclipse[m] nonlinear[m] weebull[m] yoltid[m] vpei[m] roberth blackspider76[m] dag[m] tet[m] tswett[m] inflationova[m] runningriot9[m] derberg[m] JoelMcCracken[m] asayers[m]1 aquarial jak_wolf[m] hvariant[m] makos[m] pebeto[m] br0p0p[m] SmiVan[m] miseenplace[m] linxnp[m] javjarfer[m] PoopSick[m] ookfof[m] StevenY[m] link2xt[m] gandi[m] sriehl[m] Jonathan[m]3 cjskaggs[m] kompass[m] dumuzid[m] nh2[m] aruncom2006[m] elosil[m] jennie[m] laith1[m] Kimani[m])
12:49:09 --- names: list (gswuichet[m] crvs[m] freeman42x[m] limabeans[m] hkimhvyh[m] popo[m] supersweetsweetc krangbae[m] danielbmarkham[m max3raza[m] aqtusia[m] mujx[m5 lmolr[m] luftmensch[m] homebeach[m]1 krhubert[m] javbit[m] schum ajirx[m] tops[m] SFL[m] pineapple[m] Godslatestgift[m kyleondy[m] MartinKlimi[m] iantownsend phanimahesh[m] friedm[m] kaiyou[m] iarp[m] MonsieurArcher[m Brio[m] ChristopherBurg[ sudorebootnowsud tindvik[m] test_f[m] WeiTang[m] mattia[m] aearnus[m] Godel[m])
12:49:09 --- names: list (coil[m] xxthatgirlxx[m] paulus[m] thekyriarchy anarcolepsia[m] wuxianhuiyi[m] texasmynsted bee[m]1 mathyouguy alexfmpe[m] VaNilLa[m] giuseppe[m]1 vk3wtf[m] dominicusin[m] srid[m] roninkaizen[m] jrozanski noam[m] aloiscochard[m] m00n[m] gmind[m] tejok[m] isair[m] tehidiot[m] kadoban luke-clifton[m] siraben aviD stan[m] fgaz supersven[m] Videled[m] lierdakil[m] chorhizo[m] vaibhavsagar GregKNicholson[m simbergm peel1 coldpress[m] sdicke[m] ternarysolo steshaw[m])
12:49:10 --- names: list (macerbi[m]1 iceychris[m] ClownMaster[m] boistordu sepp2k domenkozar[m] hdurer[m] afk[m] sielicki drewr xstill sylvie[m] nurupo Twey tsrt^ gentauro e3 tabaqui thunderrd ClaudiusMaximus seanparsons cchalmers liff mostendocrine yumh michaelpj mimi_vx troydm xplat poga bydo Unhammer ekleog fliife acarrico m1dnight_ lowryder lkurusa stzsch ent tlax tsani sellout- shutdown_-h_now scavenger_ teardown acro Kiruwa zmt01 glamas jstolarek Jesin _deepfire matheus Majiir)
12:49:10 --- names: list (drbrule ixian sphalerite cp iskander badzergling cartwright bgavran mr_yogurt fuzen laxask incertia Natch evanjs davr0s davr0s_ aesi leah2 a3Dman eyenx dave_uy dopplerg- Chobbes chirpsalot spoonm amiri yahb avn dequbed arahael Mzg jwynn6 marmalodak Cale Axman6 neildaemond rajivr___ stiell Jonno_FTW Clint hiredman anathema Vtec234 arianvp Guest82049 urdh dustinm srhb coldpress wagle Nickerson andreas303 albel727 datajerk srnty m4lvin ap5 yitz remexre tinwood PtxDK)
12:49:10 --- names: list (andreabedini kjak infinisil mikolaj_ dqd kmelvn evelyn shachaf atomi gluegadget verement redcheck copypasteque Unode Tourist andyo bdw rotty Rudd0 Sose TC` tomjaguarpaw lavalike sim590 noexcept gilbertw1 aplainzetakind Niamkik subfacto1 jfredett anishathalye militia tms_ catsup Fubar^ fryguybob rootnode kirand kwantam valdyn rotaerk ski nesqi tabaqui1 kini koz_ noan DigitalKiwi forell jmsx Foritus Vq strangeglyph Fairy Bergle_1 jackhill bgamari sdrodge cc0k33)
12:49:10 --- names: list (ccokee sleepnap chindy nekomune jophish _Tristan_ sqrt2 earthy dmiles glguy elcaro nee` abbe dibblego thebnq erikd yaroot echoreply styledash bsima APic TemporalShift rembo10 iomonad lassulus tv gspia int-e lambdabot dxld chin-tastic haasn leothrix jrm xelxebar jchia1 boj s4msung reorder_ averell tensorpudding arkeet petercommand tessier_ miklcct swater alanz Arguggi Madars devurandom pja acowley klntsky Slothel_ nshepperd2 bendo grumble obfusk__ Enigmagic nikivi)
12:49:10 --- names: list (adamCS glowpelt droplet Adeon ereu nuxdie Shun131 auri_ landonf sdx23 Ranhir Hijiri MasseR orzo pingu_ Remavas DustyDingo caasih coot dmj` hjozwiak entel statusbot qzo enikar pikajude wz1000 lockshaw_ bjobjo joehillen inimino clynamen_ ziman rawles @ChanServ bitonic alunduil iravid Lermex epicallan monad_cat alexelcu bradparker winny nkaretnikov Nascha dpn` jsatk fredcy- natim87 rubik Blkt banjiewen interruptinuse PyroLagus zabracks ryzokuken feepo unsymbol)
12:49:10 --- names: list (morgib dukedave Jabbslad sebhoss simony AfC ephemeron fingerzam xnyhps jlpeters Konehaltia jonrh scav alexknvl NemesisD casdr_ Ferdirand paf31_ edmundnoble aib bananagram `slikts mstruebing griddle dgpratt m-renaud sclv jetpack_joe lieven robogoat bitemyapp koala_man Annihitek monokrome crtschin_ vin-ivar Mon_Ouie nibbling_ mtjmullen pdxleif dashkal habbah loc vodkaInferno chivay raid mankyKitty lightandlight higherorder ibloom tolt AndreasK rizary_)
12:49:10 --- names: list (ProofTechnique spamlessj sebastianrkg integral mjlee nh2_ dexterfoo newhoggy TallerGhostWalt_ ryjm lsix uwap akermu vqrs Geekingfrog twk- t36s lurkless _flow_ solarus kloeri lortabac exferenceBot Deewiant a7250ag seliopou greymalkin xarian wraithm sterni bind rodlogic Mo0O artem jvanbure Firedancer_ bob_twinkles Rembane exarkun Phyx- michalrus gsingh93 gambpang connrs- [df] Aleksejs exio4 geal luigy sssilver avp djanatyn jinblack markhuge iron_houzi joeytwiddle)
12:49:10 --- names: list (ZoFLo kraem koankeeper cheshircat divVerent maerwald shadowdaemon DDR noko_ reyu jdevlieghere nivpgir_ mupf tstat lpsmith kqr jtcs Squarism travv0 connrs_ locallycompact deni Putonlalla oleks Ornedan Someguy123 jrslepak arw [exa] ByronJohnson Tene wtw charukiewicz Drezil catern qz SlashLife CindyLinz digia shapr Flonk stvc zv rootmos suzu RoguePointer ecx86 flogfr Eliel Nik05 __4matter_ nopf hexagoxel kubrat pdgwien ManiacTwister S007 beaky deadk nyuszika7h)
12:49:10 --- names: list (aidecoe graingert moobar Adluc srk quaestor petermw rom1504 atraii cbarrett coddinkn puffnfresh diginet restrictedchoice totte n3t luite nshepperd1 carter kaol jokester cyphase edwardk lally SrPx noctux yushyin i7c dogui @Sigyn sveit ycheng amx Randy cheers nisstyre peschkaj megaTherion Philonous hongminhee ysangkok angerman scivola gothos c_wraith bengt_ moocow drewbarbs _ht Zemyla jix malthe cjay- freeside immae cross oeblink duairc Logio kipras`away Nikotiini)
12:49:10 --- names: list (saidinwot1 chessai hsiktas sukbeom Ekho aldum vjoki beka abra0 Ankhers thoradam elvishjerricco PotatoGim nbouscal glowcoil billstclair Kamuela kyagrd__ liquorice verlet64 rslima___ niko sariyar riatre joshmeredith dolanbatar a3f PragCypher cocreature hegge dh canta mudri sarahzrf davean PatrickRobotham runde Jaxan enemeth79 ynyounuo dagit agrim aweinstock Deadhand PlasmaStar pcoutin trucy teej debugloop benwr_ dcoutts M2tias Ckat sobhan anderson lukelau jorj)
12:49:10 --- names: list (bolverkr kav systemfault cods lyxia dysfigured dilinger so bbear noCheese parseval bollu magicman cruxeternus evilmonads _janne sivs benl23 Tritlo srid datapup_ rann sgraf PoliticsII_ hamishmack spinda linoge mitchellsalad_ heyj adius terrorjack__ mpickering Firedancer Peter_Storm joel135 lexi-lambda mccoyc kapil_ opqdonut Jacoby6000 vimto pingiun fionnan raoul electrostat hive-mind edwtjo p3n nil amuck statusfailed tdammers Bigcheese_ uniquerockrz Forkk Willis)
12:49:10 --- names: list (sm NightA RecursiveG bandali Athas rzmt bspar azahi Seich ebutleriv typetetris milessabin dsal gonz_ pent runeks DrDuck d0liver tazjin boeg J_Arcane jackdk wildsebastian s94a84d2e dani- EduardoBautista xyggos eacameron ghuntley ajmcmiddlin kip jesyspa metalrain bjs phaazon thi_ darthThorik Orbstheorem dongcarl amatecha_ jamestmartin ^[ mnrmnaugh raek mingc lnx polux7 aurieeeh ps-auxw Jon hvr bcoppens stefan Taneb julienXX pong silver_needles absence ab9rf)
12:49:10 --- names: list (idupree2 Hotbees arsdragonfly mikeplus64 SegFaultAX ambrosia_ bwe Nevoic tnks komasa joeyh johs amosbird andjjj23 saurik cyberlard esph AWizzArd TommyC SolarAquarion xacktm Klumben stylewarning tomku eagleflo carbolymer obiwahn phlym nlofaro peel Ring0` Guillaum fiQ2 mniip rkrishnan adadelta zzz dan64 runawayfive mycroftiv alp null_ptr sis7 daissgr TimWolla jbetz le_jonge devalot pierrot adamse ocharles vio_ hyperfekt lucas8 comboy_ dixie_ flebron_ scal_)
12:49:10 --- names: list (zerokarm1left Hasefroch klugez tristanC h32 fr33domlover dyl_ Moyst guios energizer mjrosenb ammar2 sea-gull vk3wtf MatrixBot3 coeus samebchase freusque asm89 apoc xtsee wadadli deu betawaffle nonzen dumptruckman EvanR Tuplanolla ion ft madnight monochrom michalisko johnstein dminuoso irclogger_com teehemkay niklasb_ jzl c-rog)
12:50:12 <boxscape> what does the "safe" mean in "Matching instances: instance [safe] Eq (a Bool) -- Defined at <interactive>:3:10"?
12:50:39 <dansho> % :t (swap . (,))
12:50:39 <yahb> dansho: ; <interactive>:1:9: error:; * Couldn't match type `b0 -> (a, b0)' with `(a1, b)'; Expected type: a -> (a1, b); Actual type: a -> b0 -> (a, b0); * Probable cause: `(,)' is applied to too few arguments; In the second argument of `(.)', namely `(,)'; In the expression: (swap . (,))
12:52:15 <merijn> hmm, what'd be the best mutable counter? IORef Int? TVar?
12:52:26 <dansho> % :t (swap . ((,) 1))
12:52:26 <yahb> dansho: Num a => b -> (b, a)
12:52:47 <dansho> does the rhs of . have to be unary?
12:52:53 <dmwit> dansho: no
12:53:03 <dansho> what was wrong with (swap . (,))?
12:53:32 <dmwit> swap operates on tuples. (,) returns a function.
12:53:44 <boxscape> (swap . (,)) x == swap ((,) x)
12:53:57 <dmwit> Or: the RHS of . does not have to be unary, but if it is not unary, the LHS of . has to be able to handle functions.
12:54:13 <tdammers> and ((,) x) == (x,) == \y -> (x, y)
12:54:32 <dansho> hmm
12:54:45 <dmwit> :t ($4) . (+)
12:54:46 <lambdabot> Num c => c -> c
12:55:55 <Cale> :t map . map
12:55:56 <lambdabot> (a -> b) -> [[a]] -> [[b]]
12:57:55 <subhadeep1912> hi
12:58:18 <subhadeep1912> hello
12:58:19 <dmwit> dansho: https://gist.github.com/dmwit/c0496a30ab107480241a554089 may help a bit?
13:00:31 <dansho> page not found
13:00:46 <dansho> :t (\x y -> swap $ (,) x y)
13:00:48 <lambdabot> a -> b -> (b, a)
13:01:00 <dansho> is there a point-free way to write with swap and (,)?
13:01:20 <infinisil> @pl \x y -> swap $ (,) x y
13:01:20 <lambdabot> (swap .) . (,)
13:01:34 <dansho> :o
13:01:56 <dansho> is there a ghci command for that?
13:02:36 <infinisil> dansho: There's https://hackage.haskell.org/package/pointfree you can use in the terminal
13:02:44 <EvanR> @unpl (swap .) . (,)
13:02:44 <lambdabot> (\ x x0 -> swap (((,)) x x0))
13:02:54 <infinisil> Oh and in ghci too apparently
13:03:27 <EvanR> uhm... isn't \x y -> swap $ (,) x y  just swap ?
13:03:33 <EvanR> oh no
13:03:45 <EvanR> but let me just say \x y -> (y,x) is clearer
13:03:52 <dmwit> ?let swap (x,y) = (y,x)
13:03:53 <lambdabot>  Defined.
13:03:54 <dmwit> :t uncurry swap
13:03:56 <lambdabot> error:
13:03:56 <lambdabot>     Ambiguous occurrence ‘swap’
13:03:56 <lambdabot>     It could refer to either ‘Data.Tuple.swap’,
13:04:00 <dmwit> ?undefine
13:04:01 <lambdabot> Undefined.
13:04:03 <dmwit> :t uncurry swap
13:04:05 <lambdabot> error:
13:04:05 <lambdabot>     • Couldn't match type ‘(b, a)’ with ‘b1 -> c’
13:04:05 <lambdabot>       Expected type: (a, b) -> b1 -> c
13:04:20 <siraben> Is there a way to write "[v | (Just v) <- x]" without list comprehensions?
13:04:22 <dmwit> Oh, right.
13:04:23 <siraben> Say, with do notation instead.
13:04:24 <dmwit> :t curry swap
13:04:26 <lambdabot> a -> b -> (b, a)
13:04:42 <EvanR> curry swap... ok
13:04:43 <dmwit> siraben: Sure, `do { Just v <- x; return v }`. Or `catMaybes x`.
13:04:48 <dminuoso> % :t catMaybes -- siraben 
13:04:48 <yahb> dminuoso: [Maybe a] -> [a]
13:04:59 <siraben> Ah, I see.
13:05:17 <EvanR> @src catMaybes
13:05:17 <lambdabot> catMaybes ls = [x | Just x <- ls]
13:05:20 <EvanR> heh
13:05:24 <dminuoso> :-)
13:05:34 <dminuoso> siraben: But sure, you can avoid the list-comprehension and write it in unlimited other ways.
13:05:47 <dminuoso> siraben: You could write it as a foldr, for example.
13:06:16 <EvanR> exercise for the reader, write it in unlimited ways
13:06:33 <dminuoso> Report once you are done?
13:07:08 <infinisil> [x | Just x <- l ], [x | (Just x) <- l ], [x | ((Just x)) <- l ], ...
13:07:32 <dmwit> way n = unwords (["catMaybes ls ="] ++ replicate n ["id"] ++ ["[x | Just x <- ls]"])
13:07:38 <dmwit> Oh, infinisil beat me to the joke. ^_^
13:07:48 <monochrom> modulo abstract syntax tree equivalence and alpha-equivalence
13:08:02 <infinisil> dmwit: Yours is better because it's actually a different AST :)
13:11:28 <merijn> So, if you have to implement a mutable counter that has to be communicated between two different IO parts of the program, which would people use? IORef, TVar, MVar?
13:11:58 <c_wraith> Not enough information
13:12:21 <sicklork1n> merijn: any forks?
13:12:34 <merijn> c_wraith: I need to, effectively, reference count a file so I know when to delete it
13:13:29 <EvanR> ah so it also has to decrement
13:13:37 <c_wraith> I'd go with something like https://hackage.haskell.org/package/atomic-primops-0.8.3/docs/Data-Atomics-Counter.html
13:13:43 <merijn> i.e. "I create the file and N tasks need to use it" the tasks get dispatched to different threads and as soon as they all finish I need to delete the file to free up diskspace
13:14:29 <merijn> EvanR: Well yes, hence mutable :)
13:14:30 <sicklork1n> merijn: you could use fsnotify and remove files after some long enough duration to consider them stale/complete
13:15:19 <merijn> sicklork1n: No, we're talking thousands of files measured tens of gigabytes per file. "Wait until some long enough duration" is not acceptable :)
13:15:37 <EvanR> merijn: well counting doesn't necessarily imply uncounting heh
13:15:53 <EvanR> and it matters for concurrent data structure impleemntation
13:16:04 <sicklork1n> merijn: if now - mtime > 2ms then xpunge
13:16:22 <sicklork1n> aywa.. it's a hack..
13:17:03 <sicklork1n> but the nice feature is that you cleanup stale files..
13:18:47 <merijn> c_wraith: tbh, atomic-primops API looks a bit to painful to warrant here
13:19:24 <merijn> I wonder if I can get away with making the cleanup a finalizer on a dummy ForeignPtr...
13:19:45 <cheater> hello
13:19:46 <merijn> That doesn't guarantee prompt cleanup, though
13:20:35 <sicklork1n> merijn: https://hackage.haskell.org/package/async-pool-0.9.0.2/docs/Control-Concurrent-Async-Pool.html `wait`
13:20:37 <ClaudiusMaximus> merijn: what about: create file; open it N times; unlink it from the filesystem; pass N handles or fds or whatever to the threads?  iirc linux at least lets you keep accessing files that have been deleted
13:20:47 <EvanR> is "just freakin use TVar" too simple
13:21:21 <ClaudiusMaximus> merijn: space gets reclaimed when the last handle/fd is closed
13:21:25 <merijn> EvanR: Well, hence the poll
13:21:36 <merijn> EvanR: I'm increasingly thinking probably TVar Int is simplest
13:22:07 <merijn> ClaudiusMaximus: Creation and processing of the files happens in external processes
13:22:41 <ClaudiusMaximus> ok, my method won't work then
13:22:47 <merijn> EvanR: Initially I was thinking QSem semaphore, but that only has a "wait" that blocks, not a "do something on 0" method
13:30:53 <cheater> sshine: i want to generate both the list, and a subsequence of the list.
13:31:27 <cheater> sshine: and the subsequence should work like this: for every element of the whole list, there should be a 50% chance of it being included or not.
13:31:42 <cheater> it's not for shrinking
13:34:08 <c_wraith> merijn: if an easy "the counter is at 0" trigger is what you're looking for, TVar is what you want.
13:38:05 <Ariakenom> I'm interested why wouldn't multiple handles and deleting work?
13:38:36 <merijn> Ariakenom: Because the files aren't created nor processed by my Haskell code
13:40:45 <triskai> register triskai Triskai_0312 vsftsai@gmail.com
13:40:51 <dmwit> oof
13:40:57 <merijn> Probably pick a better password ;)
13:41:19 <dmwit> strongly recommend changing that password if you've reused it anywhere else
13:41:47 <triskai> haha nope it was exclusively for this, but thanks)
13:41:54 <Ariakenom> also all passwords of similar strength :p
13:42:11 <Ariakenom> merijn: ok
13:42:23 <EvanR> do all that stuff in a server window
13:42:32 <monochrom> No I think no password was in there, just nickname username email.
13:43:47 <triskai> thanks just gonna show myself out now :')
13:44:12 <monochrom> Also the hardcore diehard "text mode console IRC client" people do not have a notion of "window".
13:44:33 <merijn> monochrom: irssi has windows :p
13:44:56 <Ariakenom> forkIO do { atomically do {c <- readTVar counter; guard (c==0)}; delete}
13:45:22 <Ariakenom> interestingly this thread  will die if counter is GCed. afaik
13:45:42 <merijn> Ariakenom: I was gonna package a reference to the TVar with every job and after the job finishes decrement the value and if zero do cleanup
13:45:42 <c_wraith> counter can't be GC'd while that thread is alive...
13:45:58 <c_wraith> that thread holds a reference to counter
13:46:08 <merijn> c_wraith: Might get indefinitely stuck in TVar, maybe
13:46:13 <c_wraith> that can happen
13:46:14 <merijn> Not sure, though
13:46:24 <Ariakenom> if the thread blocks on Counter it can maybe
13:46:28 <EvanR> ah right, many people use IRC via theramin-connected-to-cat5
13:46:31 <Ariakenom> no capital C
13:47:37 <Ariakenom> the "blocked indefinetely on MVar" exception is that
13:48:44 <dmwit> I still think STM should have a MonadFail instance so you could write `do { 0 <- readTVar counter; pure () }`
13:50:11 <phadej> fail _ = retry ?
13:50:44 <Ariakenom> yes
13:51:00 <monochrom> Yikes.
13:51:13 <phadej> I think it's reasonable, as there's `MonadPlus STM` instance
13:51:23 <monochrom> But that's ironic, enable "this monad can fail" so it can never fail...
13:51:26 <phadej> so fail _ = mzero (= retry) won't be too surprising
13:53:47 <phadej> in https://wiki.haskell.org/MonadFail_Proposal speaks about
13:53:49 <phadej> Some types have different definitions for mzero and fail. Although STM is MonadPlus it uses the default fail = error. It should therefore not get a MonadFail instance.
13:54:20 <phadej> one can however argue that `fail = error` for STM was pointless anyway
13:58:11 <nshepperd1> merijn: a fairly normal way to do "upon x, do y" is to forkIO (wait for x >> y)
13:58:35 <merijn> nshepperd1: Except 'x' is happening in a conduit pipeline :)
13:59:33 <c_wraith> I thought the whole reason you wanted a mutable variable was so that changes to it could be seen from anywhere
14:00:20 <merijn> c_wraith: There's no easy way to track a count over a pipeline that runs parts in parallel
14:00:59 <c_wraith> I'm just saying, forkIO and wait works just fine when the mutations are being done in a conduit pipeline.
14:01:03 <merijn> So I can't just wrap it in StateT under the conduit
14:03:55 <merijn> hmm, I guess
14:04:10 <merijn> I should revisit the design when it's not 23:00 at night :p
14:04:11 <nshepperd1> merijn: oh, also, not sure if this applies to you, but finalizers on ForeignPtrs do get prompt cleanup if they are C finalizers
14:04:51 <merijn> nshepperd1: No, finalize only happens upon the next GC, which isn't guaranteed to be soon after you're done
14:05:25 <c_wraith> easy fix: add a thread that generates garbage constantly so the next GC is always prompt!  this is a brilliant idea and can have no flaws!
14:06:04 <comerijn> nshepperd1: No, finalize only happens upon the next GC, which isn't guaranteed to be soon after you're done
14:06:27 <c_wraith> your non-co statement made it through, too
14:06:52 <comerijn> ah
14:07:18 <geekosaur> merijn is fmap?
14:07:24 <nshepperd1> Oh, finalization upon gc is what i meant by 'prompt'
14:07:46 <geekosaur> (bad joke...)
14:08:05 <nshepperd1> I'd call finalization immediately upon becoming garbage 'instant' or something :p
14:08:09 <comerijn> nshepperd1: "prompt" = "as soon as possible" (which may be before the next GC happens)
14:08:54 <nshepperd1> Most finalizers in ghc may not happen at the next gc or indeed ever iirc
14:08:54 <comerijn> Something becoming garbage and GHC realising that has happened are independent, unfortunately :p
14:09:52 <comerijn> anyhoo, bedtime :)
14:09:58 <nshepperd1> C finalizers on ForeignPtrs are the exception to that
14:11:51 <monochrom> The threaded RTS detects idling and runs GC spontaneously.
14:14:56 <monochrom> This is why a long time ago someone said on haskell-cafe "does the unthreaded run time leak file descriptors? my program leaks on unthreaded run time, but it cannot be my fault because no leak on threaded run time"
14:22:38 <pertl> can anybody help? I try to use 'stack new myproject' and get "Unable to parse cabal file for arbor-lru-cache-0.1.1.1@sha256:4b72f2de5c2d8123fe71f6fda5c80e5659ec376450fc39a09e44d23212fc4a49,2493"
14:22:47 <pertl> I use current stack
14:25:31 * hackage hw-mquery 0.2.0.2 - Monadic query DSL  https://hackage.haskell.org/package/hw-mquery-0.2.0.2 (haskellworks)
14:27:18 <geekosaur> stack may be using an older version of the Cabal library (which reads package descriptions)
14:29:12 <phadej> or you use old `stack`
14:29:54 <phadej> stack --version should tell the version, latest seems to be 2.1.3.1
14:32:45 <geekosaur> they said stack was current
14:32:59 <geekosaur> but this sounds like Cabal-lib
14:33:15 <geekosaur> and something in the package index probably wants Cabal-3
14:33:46 <hoppfull> I just found out about coproducts. Do we have something that is to tuples what sum types are to records? For example, f :: (a | b | c) -> d
14:33:52 <geekosaur> (multiple namd library stanzas seems likely for breakage)
14:34:27 <hoppfull> ie ad hoc and not messy
14:36:08 <phadej> nothing in package index currently wants Cabal-3
14:36:31 <phadej> that package is cabal-version: 2.4
14:36:34 <phadej> https://hackage.haskell.org/package/arbor-lru-cache-0.1.1.1/arbor-lru-cache.cabal
14:36:38 <phadej> easy to check
14:37:28 <phadej> even stack-1.9.3 uses Cabal-2.4 library, so I suspect that pertl has very old `stack`
14:37:43 <pertl> no, it's current 2.1.3
14:37:47 <pertl> Version 2.1.3, Git revision 0fa51b9925decd937e4a993ad90cb686f88fa282 (7739 commits) x86_64 hpack-0.31.2
14:37:50 <pertl> on mac
14:37:55 <phadej> then it's a bug in stack :/
14:38:10 <pertl> maybe some leftover from an older installation?
14:38:16 <pertl> I tried haskell several times
14:38:35 <pertl> how can I query the cabal version of stack?
14:38:50 <siraben> If I have "type T a = [a]" and "type S a = Maybe a", how do I do "instance Monad (S (T a)) where ..."? Haskell complains that "Expected kind ‘* -> *’, but ‘S (T a)’ has kind ‘*’"
14:41:13 <phadej> siraben: newtype ST a = ST (S (T a)), instance Monad ST where 
14:41:50 <siraben> phadej:  Ah, thanks.
14:41:59 <phadej> pertl: good question, I'm not sure, but I'm quite sure it's 2.4, so it should be fine. Maybe there's some cache file problem, but I don't know stack that well to help
14:42:18 <pertl> I purged everything and try again
14:42:25 <pertl> maybe things get better this time
15:31:13 <zeta_0> what is the current progress of integrating web assembly with haskell?
15:55:14 <Grubble> Anyone have any good tips for having Monad code that can run on GHC 8.6 and 8.8+ without modification? I've read https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail and its suggested code dies on 8.8+.
15:55:35 <MarcelineVQ> zekt83: asterius is the last I've seen on it
15:55:55 <MarcelineVQ> zekt83: woops :> I gues zeta_0 left
15:56:20 <Grubble> Specifically, fun with     ‘fail’ is not a (visible) method of class ‘Monad’    |125 |     fail = Fail.fail    |     ^^^^
15:57:53 <glguy> Grubble: You'll need to use CPP to conditionally define fail in the Monad instance for old GHC
15:58:00 <glguy> http://hackage.haskell.org/package/transformers-0.5.6.2/docs/src/Control.Monad.Trans.Maybe.html#line-159
15:58:25 <glguy> Or even better, don't implement fail or MonadFail at all
15:58:26 <Grubble> And if I don't want to or can't use CPP?
15:58:44 <glguy> then you can leave fail out
15:59:05 <Grubble> Some Monads actually do have a meaningful implementation of fail.
15:59:15 <glguy> or you can get clever with template haskell, but CPP is the right answer
16:01:01 <Grubble> I don't want to “get clever”, I just want to write simple code that can be used regardless of which version of GHC is installed.  Maybe I'm not the end user.
16:01:11 <glguy> OK, then CPP
16:02:04 <Grubble> Meh.
16:03:10 <Grubble> Someone needs to edit https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail since it currently doesn't recommend CPP (even though an older version of the page did https://wiki.haskell.org/MonadFail_Proposal).
16:03:26 <Grubble> It also has:
16:03:27 <Grubble>   -- GHC may or may not ignore a definition in terms of MonadFail(fail) (decision pending)
16:03:44 <Grubble> Apparently, the chosen decision was for pain.
16:42:01 <lyxia> you can also not use fail
16:45:36 <EvanR> so uncommon wisdom would have this be the end of fail
16:46:03 <EvanR> now that it's out of Monad we can forget it
17:34:32 <cheater> why is fail out of monad?
17:35:21 <hpc> because it doesn't have anything to do with the mathematical object that the Monad class models
17:35:29 <cheater> k
17:35:33 <Axman6> because it doesn't make sense for most monads, even some which it seems it like it should make sense for (like Either)
17:35:40 <cheater> where is fail going to go
17:35:47 <hpc> MonadFail
17:35:49 <cheater> k
17:36:04 <Axman6> going to -> gone
17:36:10 <Axman6> this hazs been in the works for several years
17:37:12 <Axman6> has*
17:38:02 * hackage antiope-es 7.4.4 - Please see the README on Github at <https://github.com/arbor/antiope#readme>  https://hackage.haskell.org/package/antiope-es-7.4.4 (arbornetworks)
17:54:12 <cheater> alright
17:54:21 <cheater> hopefully soon we'll also swap : and :: =)
17:55:05 <Axman6> The thing I really want to change is change import qualified Foo as F to import Foo qualified as F
17:55:55 <cheater> i want fmap <-> map =)
18:03:35 <cheater> what's a good data structure where i only ever add new items, a lot of them (small ones), and need some sort of sequential id to access them?
18:03:43 <cheater> (actually the sequential id might be unnecessary)
18:07:40 <Guest8878> any reason why fix is always presented as (fix f = let x = fix f in f x) instead of (fix f = f (fix f) ?)
18:08:42 <Axman6> the former creates an actual loop, with x pointing to f x
18:08:42 <Guest8878> * )) ?
18:09:12 <Axman6> so if you do fix (1:), you have the tail of the list pointing to itself
18:09:42 <Axman6> so that uses constant memopry - it's x = 1:x, and actual circular, infinite list
18:10:06 <Axman6> if you use the second definition you'd use infinite memory if you tried to evaluate it
18:11:18 <jusss> Axman6: does that fixed-point have special purpose than make a loop?
18:11:30 <jusss> loop in the nest
18:11:42 <kleisli> have there been any languages that implement "modular type classes" as described by Harper et al (https://www.cs.cmu.edu/~rwh/papers/mtc/short.pdf) ?
18:11:45 <Axman6> any recursive function can be written using fix
18:12:16 <jusss> Axman6: and any other purpose?
18:12:42 <Axman6> so, if we only had fix, we could write any computable function, even if we weren't allowed to use recursion directly
18:13:16 <jusss> Axman6: yeah, recursive with lambdas
18:13:24 <Axman6> well no, but it's not really any different than things lik const, (.) etc. existing. it exists because it does
18:14:26 <Guest8878> how does a let binding cause this?
18:14:27 <jusss> Axman6: and that fix can work on type?
18:16:01 <jusss> Axman6: turn a recursive function to a fix way, is that related to CPS?
18:17:49 <Axman6> Guest8878: let gives a name for a specific computation, it will only be evaluated once
18:17:57 <Axman6> jusss: maybe? not really IMO
18:20:34 <Guest8878> i see. i was under the false assumption that any function called with the same argument would only be evaluated once
18:21:36 <Axman6> no
18:21:41 <Guest8878> so in the second case, each 1 in the list would be a different 1 in memory
18:22:18 <Axman6> the compiler _may_ optimise fix f = f (fix f), but it probably won't because maybe you don't want the change in how it executes
18:23:41 <Guest8878> and there is no difference whatsoever between let and where bindings, right?
18:28:09 <sshine> Guest8878, well yes
18:29:24 <sshine> Guest8878, for example, 'where' bindings cannot refer to bindings within a do-block, but 'let'-bindings inside the do-block can.
18:31:40 <Guest8878> right
18:31:45 <Guest8878> i mean in this case
18:33:19 <Guest8878> i know let bindings are expressions and where clauses are part of the function definition syntax
18:34:29 <Axman6> I think there's a difference in the polymorphism of definitions in the two, but I've never unstood what the difference is
18:34:33 <Axman6> understood*
18:34:46 <Axman6> > let x = 1 in (x::Int,x::Double)
18:34:48 <lambdabot>  (1,1.0)
18:35:15 <Axman6> > (x::Int,x::Double) where x = 1
18:35:17 <lambdabot>  <hint>:1:20: error: parse error on input ‘where’
18:35:30 <Axman6> > let f = (x::Int,x::Double) where x = 1 in f
18:35:33 <lambdabot>  (1,1.0)
18:35:37 <Axman6> hmm, maybe not
18:36:04 <Guest8878> i know patterns in let expressions are implicitly irrefutable
18:36:24 <Guest8878> i'm not sure if they are on where clauses
18:47:53 <jusss> Axman6: what're actions and what're functions?
18:50:43 <rotaerk> darn, I missed the context of that question
18:50:49 <MarcelineVQ> functions are things that have types like "a -> b", actions is a bit of a vague term but it tends to mean things with types like "f a" which have Applicative or Monad instances
18:50:53 <Axman6> no idea, what's the context?
18:51:05 <Guest8878> (turns out they are)
18:53:03 <jusss> MarcelineVQ: wait a sec, why actions have to do with Applicative or Monad?
18:53:07 <rotaerk> a function is a parameterized expression, an expression that differs depending on the parameter.  alternatively, it's something that takes an input and for each possible input value, has a rule that says what the corresponding output value is
18:53:35 <MarcelineVQ> jusss: just that it tends to be the interface we use to work with them
18:53:37 <Axman6> jusss: they don't, the term needs context to give youy an answer
18:54:05 <Axman6> functions _are_ actions, depending on the context
18:54:23 <Axman6> I would say that in Haskell, most actions are functions, in one form or another
18:54:54 <jusss> Just is a function?
18:54:57 <rotaerk> a value of type `IO ()` is not a function, but it's an action
18:55:01 <rotaerk> an "IO action"
18:55:03 <Axman6> :t Just
18:55:04 <lambdabot> a -> Maybe a
18:55:10 <Axman6> looks like a function to me
18:55:45 <jusss> :t Nothing
18:55:47 <lambdabot> Maybe a
18:55:54 <Guest8878> this is interesting: if i have (f x = let (a:as) = x in aa) and (g x = aa where (a:aa) = x) i get an ambiguous type variable error for f [0] but not for g [0]
18:55:56 <MarcelineVQ> Some actions are functions, when f is (r ->) is a common case. idk about saying most actions are functions, seems somewhat backwards
18:55:56 <jusss> Nothing is function?
18:56:08 <MarcelineVQ> No, there's no -> there.
18:56:30 <Axman6> :t Nothing
18:56:31 <lambdabot> Maybe a
18:56:55 <rotaerk> "action" is a fairly casual term, while "function" is pretty well defined
18:57:07 <jusss> MarcelineVQ: so we can think everything within a -> can be functions?
18:57:25 <Axman6> well yes, that's what -> means
18:57:28 <MarcelineVQ> Directly, if your type (after constraints) starts with -> it's a function, because -> is the type of functions. Just :: a -> Maybe a is, Just :: (->) a (Maybe a), Just starts with ->
18:58:44 <DrAwesomeClaws> haskell is annoying, stuff starts working before i get to the code
18:58:53 <MarcelineVQ> The reason I say that in that way is because you might see foo :: IO​ (a -> b), this is not a function despite having ->
18:58:56 <rotaerk> Guest8878, do you have a typo there? did you mean as instead of aa?
18:59:07 <rotaerk> DrAwesomeClaws, what
18:59:21 <jusss> rotaerk: Nothing is action?
18:59:23 <DrAwesomeClaws> i just type out types and a few function interfaces and half my stuff works just via pattern matching 
18:59:35 <jusss> IO () is action
18:59:52 <Axman6> action is not a well defined term
19:00:06 <jusss> Axman6: action is realted to side-effect?
19:00:39 <Guest8878> ah ok. it was a typo
19:02:01 <Guest8878> my bad
19:02:10 <jusss> % data F = MkF (Int -> F)
19:02:11 <yahb> jusss: 
19:02:19 <jusss> % :t MkF
19:02:19 <yahb> jusss: (Int -> F) -> F
19:04:44 <EvanR> you got your monadic actions, your applicative actions, your monoid actions, group actions
19:05:23 <novum> I am doing some code wars like a good boy. I hope that this isn't stupid. http://ix.io/1Ycj  is that stupid? it's stupid. I am stupid. :(
19:05:26 <jusss`> EvanR: what is monadic actions look like?
19:05:41 <DrAwesomeClaws> stupid code is the best code
19:06:13 <EvanR> jusss`: just some value
19:06:16 <Axman6> :t digitToInt
19:06:17 <lambdabot> Char -> Int
19:06:28 <Axman6> > digitToInt '0'
19:06:30 <lambdabot>  0
19:06:30 <novum> how can you convert Char->Int without doing (read [x] :: Int) :o I DON'T HAVE digitToInt IN MY GHCI >:{
19:06:38 <Axman6> > digitToInt 'a' -- probably not good
19:06:40 <lambdabot>  10
19:06:43 <Axman6> > digitToInt 'z' -- probably not good
19:06:45 <lambdabot>  *Exception: Char.digitToInt: not a digit 'z'
19:06:55 <MarcelineVQ> @index digitToInt
19:06:55 <lambdabot> Data.Char
19:07:19 <novum> ohhh Data...... Data.Char. I tried import Char becuase I am a bad boy!
19:07:35 <jusss`> EvanR: Just 3 is a monadic value, it's a monadic action?
19:07:38 <Axman6> > foldr (const . digitToInt) 0 . filter isDigit $ "He111o"
19:07:39 <lambdabot>  1
19:07:50 <EvanR> uhm yeah you got it
19:08:12 <novum> why thanks MarcelineVQ and DrAwesomeClaws
19:08:14 <EvanR> > Just 3 >>= \x -> Just (x+1)
19:08:15 <lambdabot>  Just 4
19:08:29 <EvanR> > Nothing >>= \x -> Just (x+1)
19:08:31 <novum> Axman6, y u show off no bad boy
19:08:31 <lambdabot>  Nothing
19:08:36 <novum> go to time out
19:08:46 <Axman6> u wot m8
19:08:51 <novum> TIME OUT
19:08:54 <jusss`> EvanR: in your cases, which is the term "monadic action"?
19:09:07 <novum> interesting solution. thanks ^u^
19:09:14 <EvanR> Just 3, Just (x+1), Nothing
19:09:34 <jusss`> EvanR: what those monadic action can do?
19:09:47 <jusss`> EvanR: put them into >>=?
19:09:56 <EvanR> Nothing corresponds to "bail out"
19:10:30 <jusss`> EvanR: what they can do? what they're used for?
19:10:35 <jusss`> monadic actions
19:11:07 <novum> isDigit ... that seems useful ... filter ... that seems useful ... foldr ... that seems useful. Information overflow maximized. System shut down in 3 .. 2 .. *silence*
19:11:54 <EvanR> jusss`: whatever the Monad instance says they do. Or whatever class
19:12:21 <EvanR> as long as it follows the laws
19:14:46 <jusss`> EvanR: Just 3, Nothing are monadic values also monadic actions, but Just is also a function, and Nothing is not a function, right?
19:14:51 <DrAwesomeClaws> I'm kind of guessing here, but i think of monadic actions as providing a common way to thread (via composition) some (monad) context through disparately typed pure functions.  But i don't really understand this stuff 
19:15:19 <EvanR> context can explain a lot of things
19:16:13 <EvanR> jusss`: Just and Nothing are constructors
19:16:36 <jusss`> EvanR: yeah, they're, 
19:28:10 <novum> Axman6, why you no use foldl
19:31:10 <Axman6> > foldr (const . digitToInt) 0 . filter isDigit $ '1':repeat 'a'
19:31:12 <lambdabot>  1
19:31:25 <Axman6> > foldl (const digitToInt) 0 . filter isDigit $ '1':repeat 'a'
19:31:33 <lambdabot>  mueval: ExitFailure 1
19:31:38 <Axman6> :O
19:32:02 <Axman6> foldl can't return an answer until it hits a []. there may not be a []. foldl can return as soon as it wants
19:32:09 <novum> > foldl (const . digitToInt) 0 . filter isDigit $ '1':repeat 'a'
19:32:11 <lambdabot>  error:
19:32:11 <lambdabot>      • Couldn't match type ‘Int’ with ‘Char’
19:32:11 <lambdabot>        Expected type: Int -> Char -> Int
19:32:41 <Axman6> :t foldl
19:32:42 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
19:32:44 <Axman6> :t foldr
19:32:45 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
19:32:46 <novum> > foldl (const . digitToInt) 0 . filter isDigit $ "hel1l0"
19:32:48 <lambdabot>  error:
19:32:48 <lambdabot>      • Couldn't match type ‘Int’ with ‘Char’
19:32:48 <lambdabot>        Expected type: Int -> Char -> Int
19:33:08 <Axman6> needs to be const digitToInt, not const . digitToInt
19:33:14 <Axman6> for foldl
19:33:24 <novum> not make sense. it's k.
19:33:27 <MarcelineVQ> *foldr can return as soon as it wants
19:33:48 <Axman6> ah yes sorry
19:33:58 <novum> ok. I will memorize this tidbit of information and pretend like I know that this is fact. "foldr can return as soon as it wants"
19:34:03 <novum> boom.
19:34:52 <Axman6> > foldr f z [a,b,c] :: Expr
19:34:54 <lambdabot>  f a (f b (f c z))
19:35:20 <Axman6> notice that if f doesn't care about it second argument, it can return immediately
19:35:33 <Axman6> > foldr const z [a,b,c] :: Expr
19:35:35 <lambdabot>  a
19:35:47 <Axman6> > foldl f z [a,b,c] :: Expr
19:35:49 <lambdabot>  f (f (f z a) b) c
19:36:14 <novum> I don't really know what foldl and foldr do. so. I assume something with foldable things
19:36:19 <Axman6> now notice that foldl has to get to the last element of the list before it can return anything
19:37:32 <novum> ah looks like it creates .. I don't know if those are closures but it creates a recursive call for each item in a foldable?
19:37:47 <Axman6> ignore foldable, just stick to lists
19:38:22 <Axman6> > foldl (+) 0 [1..10]
19:38:23 <lambdabot>  55
19:40:41 <novum> why are there 3 params and not 2. Eg foldl (+) [1..10]
19:41:19 <Axman6> what happens if the list is []? you need to start somewhere
19:41:26 <novum> I guess it's like ... (9 + (10 + 0)) I guess that makes sense
19:41:35 <Axman6> > foldr (+) 0 [1,2,3] :: Expr
19:41:36 <lambdabot>  1 + (2 + (3 + 0))
19:41:44 <Axman6> > foldl (+) 0 [1,2,3] :: Expr
19:41:46 <lambdabot>  0 + 1 + 2 + 3
19:41:57 <novum> uwot haskell
19:42:07 <Axman6> a.k.a. (((0 + 1) + 2) + 3)
20:05:31 * hackage hw-rankselect 0.13.3.1 - Rank-select  https://hackage.haskell.org/package/hw-rankselect-0.13.3.1 (haskellworks)
20:13:51 <siraben> Anyone have suggestions on refactoring the monad instance here; http://ix.io/1YcB
20:14:50 <Axman6> what is Out?
20:15:30 <siraben> "newtype Out a = MkOut (String, a)"
20:16:20 <Axman6> :t liftA2 (<*>)
20:16:21 <lambdabot> (Applicative f1, Applicative f2) => f1 (f2 (a -> b)) -> f1 (f2 a) -> f1 (f2 b)
20:16:44 <siraben> This is similar in flavor to https://hackage.haskell.org/package/transformers-0.5.6.2/docs/src/Control.Monad.Trans.Writer.Lazy.html#line-197 , but since WriterT uses a tuple it doesn't need to unwrap Out via fromOut
20:17:10 <Axman6> mf <*> ma = MkOUT $ liftA2 (<*>) (fromOUT mf) (fromOUT ma) I think
20:17:21 <lyxia> siraben: you can write   "(w, a) <- fromOut m"
20:17:22 <Axman6> means you don't need a Monad constraint on the Applicative instance
20:18:18 <Axman6> MkOut (w,a) <- fromOUT m
20:18:24 <Axman6> since it's a newtype
20:18:39 <Axman6> a newtype over a tuple feels weird
20:18:54 <siraben> Axman6:  oh wow, thanks for that using liftA2, now that gets rid of the monad constraint on m in the Applicative instance
20:19:27 <siraben> Axman6:  yeah, this is an example from the 2nd edition of Richard Bird "Introduction to Functional Programming Using Haskell"
20:19:38 <siraben> One of the exercises is to write a writer monad transformer
20:20:35 <Axman6>   m >>= k = MkOUT $ do MkOut (w,a)  <- fromOUT m; MkOut (w',b) <- fromOUT (k a); return $ MkOut (w ++ w', b)
20:20:38 <Axman6> (replace the ;'
20:20:40 <siraben> Axman6:  thanks, that removes the lets.
20:20:47 <Axman6> ;'s with new lines)*
20:21:30 <siraben> Hm, for this case "MkOut (w, a)  <- fromOUT m" works because MkOut is the only constructor for Out, but what if there was another one?
20:21:34 <siraben> What would happen?
20:21:48 <Axman6> it could fail
20:22:21 <siraben> Resulting in an exception?
20:23:09 <lyxia> it would call the "fail" function from Monad m or MonadFail m
20:24:12 <novum> well, I did my first easy haskell program on code wars that wasn't just dumb easy. proud of myself despite the crappy code. good night.
20:25:02 <novum> reading other peoples' solutions makes you realize how bad you are :P
20:25:39 <koz_> novum: This never changes.
20:25:53 * koz_ thinks back to dmwit solving an issue I was having with maximum elegance recently.
20:26:12 <novum> :) I don't doubut it. I feel like I must have read this in "Real World Haskell" but I just can't remember. What is . between functions?
20:26:38 <koz_> novum: Composition.
20:26:40 <koz_> :t (.)
20:26:42 <lambdabot> (b -> c) -> (a -> b) -> a -> c
20:26:55 <novum> I was 92.1% sure that was the case. thanks
20:27:02 <Axman6> @src (.)
20:27:03 <lambdabot> (f . g) x = f (g x)
20:27:21 <MarcelineVQ> koz_: glguy's solutions to things will break your heart, they're just too elegant and obvious
20:27:24 <Axman6> or, f . g = \x -> f (g x) if you prefer
20:27:45 <koz_> MarcelineVQ: I bet.
20:28:08 <EvanR> guys Axman6 is just too good at haskell, it hurts
20:28:38 <siraben> What would be a suitable definition for an OutMonad class? "class Monad m => OutMonad m where \n out :: String -> Out ()" makes the Haskell typechecker complain.
20:29:04 <heatsink> What is Out here?  You probably mean m
20:29:44 * Axman6 looks at EvanR
20:29:59 <glguy> MarcelineVQ: That was nice of you to say.
20:30:22 <siraben> heatsink:  Ah, yes.
20:31:29 <Axman6> siraben: the question is what do you want OutMonad to do
20:34:52 <siraben> Axman6:  In the context of monad transformers, http://ix.io/1YcI
20:35:30 <siraben> Something that would allow me to augment an existing OutMonad with a monad transformer such as EXC "instance OutMonad m => OutMonad (EXC m) where"
20:36:29 <siraben> So I could have an evaluator with output and exceptions; "evalOutEx :: Term -> OUT (EXC Id) Int"
20:38:01 <siraben> By the way, how do monad transformers compare to extensible effects? It seems quite difficult to work to monad transformers to combine monads.
20:38:12 <siraben> work with*
20:38:52 <EvanR> transformers are pretty easy, esp if you use a library
20:39:17 <EvanR> but they are better for implementing monads than using directly as the monad
20:40:56 <EvanR> there seems to be many ways to do extensible effects, and they seem p complicated to me
20:41:07 <heatsink> Monad transformers generally don't commute, while effects do.  StateT (ErrorT a) is not the same as ErrorT (StateT a).  "uses files and network" is the same as "uses network and files".
20:41:17 <maerwald> types are definitely more complicated with e-e, but the approach is way more declarative
20:41:22 <maerwald> transformers are not really declarative
20:41:24 <heatsink> So they don't express the same concepts
20:42:14 <Axman6> there's overlap
20:42:34 <siraben> Hm. So with extensible effects I can have stateful and exceptional interpreters such as "evalStEx :: Term -> STT (EXC Id) Int" ?
20:42:41 <siraben> Just like monad transformers?
20:43:17 <Axman6> you get fairly close to estensible effects with mtl - your functions just specify which effects the monad they're running in need, and it's up to the plae in the code where you execute them which ordering of effects you get
20:45:31 * hackage yesod-test 1.6.7 - integration testing for WAI/Yesod Applications  https://hackage.haskell.org/package/yesod-test-1.6.7 (MichaelSnoyman)
20:46:43 <siraben> I see. Should I read the extensible effects paper to get a better idea of how it works?
20:47:04 <siraben> There's also a "Freer Monads, More Extensible Effects" paper O.O
20:50:44 <Axman6> yes and yes. Also isovector's posts on polysemy are fantastic
20:51:41 <siraben> Wow. The more Haskell you know, the less you seem to know.
20:53:52 <dmj`> siraben: here, here !
20:54:03 * dmj` chugs pint
20:54:09 <kiwi_18> is anyone willing to do a short little code review?
20:54:16 <dmj`> kiwi_18: sure
20:55:32 <Axman6> not if you don't share the code :)
20:55:50 <Axman6> siraben: this is very true, and is a feature, not a bug. 
20:56:24 <Axman6> languages where you can know everything are limiting you. you can learn Go iun a week and never learn anything ever again. screw that nonsense
20:56:44 <siraben> In the imperative world all you need to know IO (), and more IO ()
20:56:54 <Axman6> yah
20:56:59 <EvanR> man if only the imperative world was as nice as IO ()
20:57:25 <siraben> I'm guessing Haskell also gives an endless fountain of academic papers.
20:57:49 <Axman6> if you want. I haven't read any for a few years (sadly)
21:03:05 <siraben> Anyone know of operators which allow for the horizontal composition of functors? I wrote; https://gist.github.com/siraben/a1b7ecf5eb72bf4378ba850fc0d43aa6#file-monad-composition-hs-L31-L47
21:03:31 * hackage pantry 0.2.0.0 - Content addressable Haskell package management  https://hackage.haskell.org/package/pantry-0.2.0.0 (MichaelSnoyman)
21:04:35 <kiwi_18> dmj` Axman6 I appreciate any code review on this: https://gist.github.com/charleskinbote/26a81d9eb2bfe8b380e413423f0d1e51
21:05:01 * hackage http-conduit 2.3.7.3 - HTTP client package with conduit interface and HTTPS support.  https://hackage.haskell.org/package/http-conduit-2.3.7.3 (MichaelSnoyman)
21:10:55 <Axman6> kiwi_18: LOOKS LIKE SOMETHING WENT WRONG WITH THE INDENTATION?
21:11:12 <wejetheman> this one time i was working with someone in freenode and he linked me code with a haskell pastebin type service that would actually run the code. google searching i found this https://repl.it but i dont think it was that.
21:11:38 <kiwi_18> Axman6 could be, the way the gist ingested it. any line in particular?
21:11:39 <Axman6> uh, what I said, but with less shouting - I should read what I write before sending
21:11:47 <EvanR> codepad.org claims to run haskell code but i don't think it works
21:12:16 <Axman6> lines 6, 14, 22, 28, 31, 45, 47 and all of main
21:12:27 <glguy> I think I've seen repl.it working for Haskell code
21:12:34 <EvanR> yeah
21:13:09 <wejetheman> codepad looks ri
21:13:23 <wejetheman> looks right. fits my memory
21:16:39 <kiwi_18> Axman6 that's odd
21:16:55 <kiwi_18> not sure what to do about it, i can run it fine on my machine
21:18:08 <kiwi_18> I am using spaces in the gist if that's your issue
21:18:57 <Axman6> hmm, looks fine after reloading. weird
21:19:01 * hackage grammatical-parsers 0.4.1 - parsers that combine into grammars  https://hackage.haskell.org/package/grammatical-parsers-0.4.1 (MarioBlazevic)
21:19:32 * hackage incremental-parser 0.3.3 - Generic parser library capable of providing partial results from partial input.  https://hackage.haskell.org/package/incremental-parser-0.3.3 (MarioBlazevic)
21:20:52 <siraben> Is there a function with the following type? Functor f => (f b -> t) -> (a -> b) -> f a -> t
21:21:13 <siraben> This works: f <>> g = f . fmap g , but I was wondering if the standard library had it.
21:21:54 <dmwit> I believe no. You could ask Hoogle.
21:23:20 <koz_> Hoogle says no.
21:23:26 <dmwit> Your <<> is just <>> for the Compose functor, though.
21:24:03 <EvanR> @pl \f g -> f . fmap g
21:24:04 <lambdabot> (. fmap) . (.)
21:24:23 * EvanR hangs that on the wall
21:24:43 <siraben> @pl \x -> return (do {Just v <- x; return v})
21:24:43 <lambdabot> (line 1, column 18):
21:24:43 <lambdabot> unexpected "{"
21:24:43 <lambdabot> expecting variable, "(", operator or ")"
21:24:57 <EvanR> @pl \f g -> g . fmap f
21:24:58 <lambdabot> flip (.) . fmap
21:25:28 <siraben> @pl \x -> (\y -> [y]) (do {Just v <- x; return v})
21:25:28 <lambdabot> (line 1, column 23):
21:25:28 <lambdabot> unexpected "{"
21:25:28 <lambdabot> expecting variable, "(", operator or ")"
21:25:36 <EvanR> siraben: just out of kneejerk reaction i'd put the first two arguments in opposite order from what you said
21:25:38 <siraben> This is valid Haskell why is pl failing?
21:26:06 <dmwit> I don't think it knows do syntax.
21:26:17 <glguy> pl handles a subset of valid Haskell syntax
21:26:29 <EvanR> @undo do {Just v <- x; return v}
21:26:29 <lambdabot> x >>= \ a -> case a of { Just v -> return v; _ -> fail ""}
21:26:37 <dmwit> I also don't think it knows pattern matching, so.
21:26:37 <siraben> EvanR:  Hm, I wanted to make it correspond to horizontal (or was it vertical?) composition of functors
21:27:13 <EvanR> i'm it's still that
21:27:16 <EvanR> i'm sure
21:28:02 <siraben> Basically, in CT one writes muS :: S (S a) -> S a, then composing id <>> muS :: T (S (S a)) -> T (S a)
21:28:17 <siraben> CT; 1muS :: TSS -> TS
21:29:16 <iqubic> What is CT?
21:29:30 <siraben> Category Theory, oops.
21:36:29 <dsal> I feel like a need an OO.  I want to be able to provide a persistence hook to this library that has a get, set, and delete.  Is that just a product type of functions?
21:37:02 <siraben> Is there a proof that all programs (at least λ-calculus) can be rewritten in a pointfree way?
21:37:17 <EvanR> siraben: see SKI calculus
21:37:27 <siraben> There's compiling to SKI terms, of course, but that's not exactly convenient, more like abuse of (.)
21:37:37 <siraben> I mean, can it be done in Haskell without resorting to SKI
21:38:03 <EvanR> there are other universal combination sets
21:38:07 <EvanR> combinator
21:38:44 <siraben> @pl \a b c d e -> (a b) c (e . a) b
21:38:44 <lambdabot> ((const .) .) . join . ((flip . (flip .)) .) . liftM2 flip ((flip . ((.) .)) .) (flip (.))
21:39:01 <siraben> ^l like that
21:39:39 <EvanR> To Mock a Mockingbird and Other Logic Puzzles
21:39:57 <siraben> Hm, I wonder what combination of parens and (.) will make @pl give the longest output for a given function of N arguments
21:41:48 <heatsink> @pl \a b c d e -> d e c a d e
21:41:48 <lambdabot> const . flip flip id . ((flip . (ap .)) .) . flip flip id . (liftM2 flip .) . flip (flip . (flip .) . flip flip)
21:43:56 <iqubic> That's a pointless decade.
21:45:18 <siraben> Huh, GHCi complains about infinite type in that pointfree version.
21:45:54 <jle`> @pl \a b c d e f -> d e a d b e e f
21:45:54 <lambdabot> (const .) . flip flip id . ((flip . (ap .)) .) . flip flip id . ((flip . (ap .)) .) . flip . (flip .) . join . (flip .) . flip flip
21:45:58 <siraben> @t \a b c d e -> d e c a d e
21:45:58 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
21:46:01 <heatsink> pl doesn't check types
21:46:06 <jle`> siraben: it might be because @pl doesn't typecheck
21:46:17 <jle`> it just shuffles things around symbolically
21:46:33 <glguy> pl can even introduce type errors
21:46:36 <siraben> @pl \a b c d e f -> a b a d b a b e c a r
21:46:38 <lambdabot> ((((const .) .) .) .) . flip flip r . ((flip . ((flip . (flip .)) .)) .) . (flip =<< ((flip . ((flip . (flip .)) .) . flip . (flip .)) .) . join . (flip .) . (flip =<< (flip .) . join . (flip .) .
21:46:38 <lambdabot> join flip))
21:46:44 <jle`> @pl \x -> x x
21:46:44 <lambdabot> join id
21:46:49 <jle`> ^ something that clearly shouldn't typecheck
21:46:57 <siraben> Wowza.
21:51:36 <dmj`> :t filter id
21:51:38 <lambdabot> [Bool] -> [Bool]
21:52:21 <EvanR> @unpl join id
21:52:21 <lambdabot> (\ b0 -> b0 b0)
21:54:30 <jle`> whoops
21:55:26 <jle`> :t join id
21:55:28 <lambdabot> error:
21:55:29 <lambdabot>     • Occurs check: cannot construct the infinite type: m ~ (->) (m a)
21:55:29 <lambdabot>       Expected type: m (m a)
21:55:37 <EvanR> untypable lambda calculus :)
21:56:02 <EvanR> lisp was right all along
21:58:00 <Axman6> Y tho
22:08:04 <__dingbat__> Can someone help me understand this error please?  
22:08:05 <__dingbat__> • Couldn't match expected type ‘M.Map SharedStruct a0’
22:08:07 <__dingbat__> service>                   with actual type ‘GHC.Int.Int32 -> IO SharedStruct’
22:08:31 <Axman6> not without seeing the code we can't
22:08:43 <__dingbat__> ok will share a link
22:08:45 <Axman6> other than to say the compiler expedted a map and you gave it a function
22:18:13 <__dingbat__> Axman6: here please https://www.codepile.net/pile/Zg6G9NdR
22:20:10 <cocreature> __dingbat__: that is missing too much context. SharedIFace.getStruct seems to be a crucial part here but you haven’t shown that to us
22:20:35 <Axman6> getStruct clearly takes two arguments but you've only given it one
22:20:52 <Axman6> what is the type og getStruct?
22:21:01 <Axman6> this is very strange code
22:21:12 <Axman6> feels like OOP not Haskell
22:21:29 <__dingbat__> the problem is its Apache Thrift auto generated code
22:21:36 <__dingbat__> so I am confused 
22:23:11 <Axman6> I _think_ you want something like: xx <- getStruct handler 0
22:23:38 <__dingbat__> I just added this 
22:23:40 <__dingbat__> class SharedService_Iface a where
22:23:41 <__dingbat__>   getStruct :: a -> I.Int32 -> P.IO SharedStruct
22:24:07 <cocreature> the second argument is the key of the map that you want to read whatever that means in this context
22:24:22 <__dingbat__> yup thank you
22:24:37 <Axman6> "self" :'(
22:24:39 <__dingbat__> realized it myself when I managed to dig up the function decl.
22:25:51 <__dingbat__> thank you both!
22:36:32 * hackage tldr 0.5.1 - Haskell tldr client  https://hackage.haskell.org/package/tldr-0.5.1 (psibi)
22:57:53 <EvanR> self is a fundamental aspect of OOP, or so i'm told
22:58:16 <lubegasimon> hello everyone, having this code `triple waxOn = x * 5         where           x = y ^ 2           y = z + 8           z = 7```
22:59:15 <lubegasimon> hello everyone, having the code below and loading it in REPL
22:59:26 <lubegasimon> jj
23:00:31 * hackage shakespeare 2.0.22 - A toolkit for making compile-time interpolated templates  https://hackage.haskell.org/package/shakespeare-2.0.22 (MichaelSnoyman)
23:04:34 <Axman6> lubegasimon: want to try again? 
23:05:47 <lubegasimon> yea, but  I have failed to edit the message, when I try `ctrl + enter` to hit the next line, it instead sends the message
23:08:47 <__dingbat__> Axman6: I am facing this error now 
23:08:48 <__dingbat__> • Couldn't match expected type ‘SharedStruct’
23:08:50 <__dingbat__> service>                   with actual type ‘IO SharedStruct’
23:08:54 <lubegasimon> Axman6 yea, but  I have failed to edit the message, when I try `ctrl + enter` to hit the next line, it instead sends the message
23:09:02 <__dingbat__> can you please help?
23:09:13 <Axman6> lubegasimon: you can edit messages on IRC
23:09:44 <Axman6> __dingbat__: did you update the code?
23:09:53 <Axman6> lubegasimon: uh, you can't*
23:10:09 <__dingbat__> Axman6: yes, only a couple of new lines
23:10:15 <lubegasimon> Axman6, yes
23:10:55 <lubegasimon> Axman6, am using `https://webchat.freenode.net/`
23:11:09 <Axman6> __dingbat__: we need to know the types of functions you be able to help you. what are the types of sharedStruct_key and sharedStruct_value?
23:12:37 <Axman6> lubegasimon: you can't edit messages on IRC at all. just ask your question. if you need to paste multiple lines of code, use a pastebin
23:12:40 <Axman6> @where paste
23:12:40 <lambdabot> https://gist.github.com
23:13:22 <__dingbat__> Axman6: sorry , i have added it now
23:13:50 <__dingbat__> its just a data record
23:14:54 <Axman6> that error message isn't from that code, there is no z
23:15:52 <Axman6> I added the return () so it could compile btw
23:16:53 <Axman6> __dingbat__: you changed xx <- into let xx =, these are not the same thing
23:18:03 <__dingbat__> the return () does not help actually
23:18:23 <lubegasimon> okay, Axman6, I have this code `triple waxOn = x * 5         where           x = y ^ 2           y = z + 8           z = 7` but when I load it in REPL, it throws ` ...<interactive>:10:8: Not in scope: ‘waxOn’`
23:18:59 <Axman6> I assume those spaces are newlines?
23:19:09 <lubegasimon> yes
23:19:36 <Axman6> try: let triple waxOn = x * 5 where x = y ^ 2; y = z + 8; z = 7
23:19:48 <lubegasimon> and on loading `triple waxOn`, I want the result of the expression to be triple
23:19:54 <__dingbat__> the <- thingy worked, could you point me the difference? how the IO stuff works please?
23:20:09 <__dingbat__> Axman6: thank you!
23:20:15 <Axman6> __dingbat__: are you using a tutorial?
23:20:28 <macroprep> lubegasimon: you cannot send multi-line messages
23:20:43 <Axman6> lubegasimon: I don't understand what you're after
23:20:51 <macroprep> consider Slack instead
23:20:53 <__dingbat__> Axman6 not really
23:21:04 <lubegasimon> Axman6, I don't have to use `let` when writing in source file...
23:21:19 <macroprep> there probs a haskell slack channel somewher
23:21:20 <macroprep> e
23:21:35 <Axman6> lubegasimon: GHCi is not a source file though
23:21:45 <lubegasimon> macroprep, could you please send me the slack link?
23:22:11 <macroprep> https://slack.com/get-started
23:22:24 <lubegasimon> Axman6, am writing in the local files and loading the code in ghci
23:23:01 <lubegasimon> macroprep, I meant haskell slack channel
23:23:19 <Axman6> lubegasimon: can you share the file you''ve written then?
23:23:22 <Axman6> @where paste
23:23:22 <lambdabot> https://gist.github.com
23:23:59 <macroprep> https://www.reddit.com/r/haskell/comments/4z2bsm/good_slack_channel_for_beginners/
23:24:47 <Axman6> macroprep: this isn't helpful advice IMO
23:25:06 <Axman6> lambdabot: share the code, and tell us what you're writing inGHCI, and what's not working. we're blind here
23:25:13 <macroprep> https://fpchat-invite.herokuapp.com/
23:26:12 <lubegasimon> Axman6, https://gist.github.com/lubegasimon/93a792c19a073f78fea19d3e57e82f09
23:26:35 <Axman6> and what did you write in ghci?
23:28:56 <macroprep> https://i.imgur.com/KX5tqSn.png
23:29:33 <Axman6> did you write triple waxOn? because if so, waxOn isn't defined, so you can't use  it as an argument
23:31:45 <lubegasimon> Axman6, see comment https://gist.github.com/lubegasimon/93a792c19a073f78fea19d3e57e82f09
23:32:09 <Axman6> lubegasimon: waxOn is the name of an argument to triple, it's not actually used in your function. so you can write triple (), triple True, triple 7 and they'll all return 1125x
23:32:32 <Axman6> 1125*
23:35:57 <lubegasimon> Axman6, so how can I implement what you think am trying to do, because am reading some books and that is an exercise
23:38:54 <dsal> lubegasimon: what do you expect 'waxOn' to be?
23:39:31 <dsal> You're using it as a symbol that you intend to pass to that function, but you never defined it.
23:40:04 <Axman6> > let f waxOn = 1125 in (f True, f 123, f "Hello")
23:40:06 <lubegasimon> Axman6 and i want it to do triple 1125 to give 3375
23:40:06 <lambdabot>  (1125,1125,1125)
23:40:38 <Axman6> so you want triple waxOn = 3 * waxOn?
23:41:02 <lubegasimon> yea
23:41:16 <Axman6> then write that :)
23:41:21 <lubegasimon> but I believe I can do that
23:41:26 <Axman6> you never told us what you wanted to do btw
23:42:31 <dsal> The code above does something quite different... which Axman6 demonstrated with lambdabot
23:44:23 <Axman6> lubegasimon: we are here to help you, but we can't help if you don't tell us what you're trying to do. You said "so how can I implement what you think am trying to do" but hadn't said what that was. like I said, we're working blind
23:45:03 <lubegasimon> Axman6, see the instrution of the book am reading...https://gist.github.com/lubegasimon/93a792c19a073f78fea19d3e57e82f09
23:46:05 <Axman6> that's more context you didn't give us. it looks like just above the part of the book you'vw shared, waxOn is defined
23:56:46 <lubegasimon> Axman6, see https://gist.github.com/lubegasimon/93a792c19a073f78fea19d3e57e82f09
