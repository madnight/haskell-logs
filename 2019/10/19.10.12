00:10:29 <dminuoso> jle`: Mmm. Ive basically ended up reimplementing what phadej did for Free.
00:10:41 <dminuoso> (For the higher kinded monoid we were talking about)
00:11:53 <dminuoso> jle`: Also I dont think you can write `instance EFMonoid t i f (TList t i f)` without at least imposing additional constraints like `Tensor f`
00:12:17 <dminuoso> (And perhaps even a stronger one which oleg called HAppend)
00:14:16 <dminuoso> dmwit: ^- what jle` said above. Basically I was thinking of constructing a monoid in the monoidal (equipped with These) category of Hask.
00:17:29 <amosbird> Hello, anyway to have an aarch version of shellcheck?
00:17:30 <jle`> dminuoso: yeah, EFMonoid t i f (TList t i f) is equivalent to Tensor f, i think
00:17:38 <amosbird> is there a ghc toolchain on aarch64?
00:18:15 <jle`> er i mean, Tensor t
00:20:31 <amosbird> yay https://github.com/koalaman/shellcheck/issues/1569
00:21:55 <dminuoso> jle`: Im just saying that you cannot implement this without knowing quite a bit about t and i. (Actually come to think of it, using that encoding it'd rather have to be some `TensorI t i`
00:23:46 <dminuoso> For example, you need to have some way of talking about `class (Functor t, Functor i) => Tensor t i | t -> i where ... elim2 :: Functor g => t i g -> g`
00:24:17 <jle`> dminuoso: yeah, you can probably implement it for *specific* t and i
00:24:21 <dminuoso> Right
00:24:25 <jle`> in a way that is polymorphic for all Functor f
00:24:31 <jle`> that's the 'freeness' of it
00:24:35 <dminuoso> Indeed. :)
00:24:38 <jle`> EFMonoid gives you a new free construction for every specific t and i
00:24:51 <jle`> but, abstracting over all the possible t and i? might not be a super useful abstraction
00:25:31 <dminuoso> I have no idea, Im just trying it out because it looks interesting.
00:26:17 <dminuoso> But the more Im doing, Im realizing Im just repeating the work Oleg has already done for his blog post.
00:26:31 <sim590> dmwit: the issue was about foldl vs foldr. I was reconstructing submatrixes in the inverse order, so I was inverting the lines.. hehe
00:27:02 <dminuoso> 09:17:09         jle` | dminuoso: yeah, EFMonoid t i f (TList t i f) is equivalent to Tensor f, i think
00:27:04 <dminuoso> Its not by the way
00:27:05 <jle`> dminuoso: that's a good thing, i think -- it basically means you can check your work
00:28:23 <dminuoso> jle`: `instance EFMonoid t i f (TList t i f)` is rather roughly equivalent to `class Tensor h => HAppend h elim1    :: Functor f => h f (I h) ~> felim2    :: Functor g => h (I h) g ~> gassoc    :: (Functor f, Functor g, Functor k) => h f (h g k) ~> h (h f g) kdisassoc :: (Functor k) => h (h f g) k ~> h f (h g k)instance (HBifunctor h, Functor i) => Functor (Free h i f) wherefmap f (Done x) = Done (fmap f
00:28:25 <dminuoso> x)fmap f (More x) = More (bfmap f x)class Tensor h => HAppend h where happend :: Free h (I h) f `h` Free h (I h) f ~> Free h (I h) f`
00:28:31 <dminuoso> Wait, what was that in my clipboard
00:28:34 <jle`> hm, you need HAppend. how unfortunate
00:28:47 <dminuoso> jle`: Well it *is* HAppend basicaly
00:28:54 <dminuoso> If you stare at the types
00:29:00 <dminuoso>     happend :: Free h (I h) f `h` Free h (I h) f ~> Free h (I h) f
00:29:13 <dminuoso> unit_ :: f `t` f ~> f
00:29:29 <dminuoso> and instantiate f with (Free t i f)
00:29:41 <jle`> ah. i mean, you can't get it with Tensor alone
00:29:53 <jle`> this feels weird
00:30:49 <jle`> and it throws a wrench in my new system ...
00:32:18 <dminuoso> jle`: The reason is that the plumbing to append two Free/TList differs between each tensor
00:32:46 <dminuoso> (I mean sure, you could equip the Tensor class with that method of course)
00:32:57 <dminuoso> Which might even make sense
00:33:17 <jle`> it feels a little ad-hoc to put it in the Tensor class
00:33:30 <jle`> but then again Tensor's CT laws are definitely kind of wonky
00:33:48 <jle`> they're definitely not as clean as their simple idea seems to imply
00:35:01 <dminuoso> By the way, are selective functors to be found in all of this?
00:35:11 <dminuoso> Wouldn't they be sort of comonoids?
00:35:33 <jle`> hm, maybe the problem with getitng this to work with my new system is the reason why i originally implemented functor-combinators the way i did...
00:35:48 <jle`> hm, i've never really gotten a sense of how selective functors fit into all of this
00:36:03 <jle`> they feel like more 'practical' tools, without a source in CT
00:36:16 <jle`> but i could be wrong
00:36:41 <dminuoso> jle`: I mean if you compare selective functors with the Monoidal representation of Applicative, they are kind of dual to each.. sort of with some squinting
00:39:15 <jle`> hm yeah, there might be promise
00:39:15 <dminuoso> select :: f (Either a b) -> f (a -> b) -> f b 
00:39:42 <dminuoso> Is basically `(><) :: f a -> f b -> f (Either a b)` (except this one doesnt have the parametricity)
00:46:14 <dminuoso> % data Foo f g a where (:<!!!>:) :: f (Either a b) -> g (b -> a) -> Foo f g a
00:46:15 <yahb> dminuoso: 
00:46:25 <dminuoso> Is this a suitable tensor? I have no idea.
01:08:50 <jzyamateur> What are some common use cases for which you reach out to zipWith? Coming from other langs, the maximum I can think about using is map/fold when needing to loop.
01:12:41 <pavonia> Loop?
01:13:44 <jzyamateur> pavonia: like a for loop
01:14:28 <jzyamateur> or a versatile list.forEach
01:15:58 <pavonia> Hhm, I can't give a specific use case
01:45:47 <sim590> I'm trying to use GADTs to not write everywhere the constraints on a given type called Permutation (see this https://paste.debian.net/1106021/). But I get errors like `No instance for (Ord a) arising from a use of ‘mempty’` even though I have `Permutation :: (Eq a, Ord a) => [[a]] -> Permutation a` in the where clause in the type declaration GADT-style. What's wrong?
01:58:07 <Philonous> sim590, You need a »Ord a« constraint on mult 
01:58:50 <Philonous> Wait
01:58:54 <sim590> Philonous: But I thought that the point of GADTs would be to remove that need since the GADT type specifies it.
01:59:49 <Philonous> Ah, yes
02:00:16 <Philonous> You can say » mult p0@Permutation{} p1 = [...] «
02:00:30 <Philonous> But you need to pattern match on Permutation to recover the constraint
02:00:45 <Philonous> So the constraint is in scope on the RHS of a pattern match
02:02:29 <sim590> Philonous: Oh... Why doesn't `mult :: Permutation a -> Permutation a -> Permutation a` suffice?
02:02:58 <sim590> Also, how would I do that if I don't have pattern matching like for `simplify = Permutation . filterAll . lFromP`.
02:03:10 <Philonous> Because then the compiler has to invent an Ord constraint for any type a. 
02:03:36 <Philonous> invent an Ord implementation, I mean
02:03:58 <Philonous> consider e.g. »mult undefined undefined« 
02:04:45 <Philonous> undefined :: Permutation $a -- for some type $a that's not an instance of Ord 
02:05:40 <Philonous> This isn't a problem when you pattern match, because then you really have to have an Ord implementation or pattern matching diverges
02:06:06 <sim590> But then why wouldn't compiler find out about it if I do have `Permutation :: (Eq a, Ord a) => [[a]] -> Permutation a` constraint. That's a bit odd to me.
02:07:41 <Philonous> Well, another way to look at it is that »Ord a =>» means you have an Ord-dictionary as an implicit parameter. The dictionary gets packaged up in your GADT, but to recover it you need to pattern match on the GADT
02:08:31 <Philonous> Without pattern matching the compiler has no way to come up with another Ord dictionary for you, it can't invent it out of thin air
02:08:56 <sim590> Is that because it doesn't look at my function signature?
02:09:05 <sim590> The function signature says that the parameter is Permutation
02:09:34 <sim590> and since `Permutation a` needs `a` to be an instance of Ord and Eq, it should know, shouldn't it?
02:10:21 <Philonous> Sure, but the Ord dictionary is stored inside the Permutation _constructor_, and there's no guarantee that a value of type »Permutation a« is made up from a Permutation constructor
02:11:28 <sim590> Hmmmm OK. How could it be otherwise?
02:11:37 <Philonous> In the general case your type might have more than one constructor, and not all of them need to carry the dictionary, and even if the type only has one constructor like in your case, there's always the possibility that the value is bottom (e.g. undefined, error, infinite loop)
02:13:01 <Philonous> Btw. the trick for simplify is to eta-expand it, then you can pattern match again and recover the Ord a
02:13:18 <sim590> OK, so I'm trading (Eq a, Ord a) => for @Permutation{} @Permutation{} ... It may be OK if the number of constraint grows, but I'm not sure that I'm winning alot now.
02:13:31 <Philonous> i.e. simplify p@Permutation{} = Permutation . filterAll . lFromP $ p 
02:14:10 <Philonous> You only need to pattern match on one of the parameters, because the can only be one Ord a dictionary globally 
02:14:20 <Philonous> But yes
02:14:56 <sim590> Oh, so I don't need to put more than one if I have many Permutation parmaters.
02:15:38 <Philonous> Yes, you can eta-reduce the other one if you like
02:16:55 <sim590> One case seems to stand out again:   mempty = Permutation [[]]. It's complaining and I don't have any parameter to apply the pattern match trick.
02:18:13 <Philonous> You really do need the »Ord a => « in the instance header, because otherwise what you're saying would be that you can create a »Permutation a« for _any_ a, even for an a that's not Ord, and then you could pattern match on it and have an Ord dictionary for something that's not Ord
02:19:22 <sim590> Alright, but now what about Functor. I can't add type restriction.
02:19:29 <sim590> instance Functor Permutation where
02:20:32 <Philonous> Yeah, your Permutation isn't a Functor 
02:21:13 <sim590> I created the instance for it. It worked before I started using GADTs
02:21:15 <Philonous> It's not just that GHC doesn't allow you to write it, it really isn't
02:21:47 <Philonous> Yes, packaging up the constraints in the Constructor is what prevents it from being a Functor 
02:22:02 <Philonous> It's the price you pay 
02:22:54 <sim590> Oh OK. Is that a question of implementation. I mean is it going to change in the future of the language or it's always going to be like that?
02:23:21 <sim590> I'm begining to question the use of GADTs for the sole reason to avoid writing constraints on all functions.
02:23:47 <sim590> I think that there are other reasons to use GADTs, but I don't know them for now.
02:24:18 <Philonous> No, functor has a specific mathematical meaning, it comes with laws attached. Your construction really isn't a (lower-case) functor, that's why you can't make it a (capital letter) Functor
02:24:38 <Philonous> GADTs aren't the problem, they just allow you to build more complicated things
02:24:44 <bifunctor> Hi all
02:24:44 <Philonous> Some of which aren't Functors 
02:25:25 <Philonous> data Permutation a where Permutation :: [[a]] -> Permutation a -- GADT, yet admits Functor implementation 
02:25:58 <Philonous> Yes, GADTs allow you to do some cool things that you really can't do without them. 
02:27:44 <sim590> I'm not sure to understand why I can't make my type a Functor now if I could before using GADTs.
02:28:26 <sim590> This code `fmap f (Permutation pl) = Permutation $ map (f<$>) pl`  was working before changing to GADTs.é
02:28:34 <Philonous> However, you have to consider that maybe your Permutation type _shouldn't_ be a Functor. If the semantics is that the elements have to be ordered than it really just isn't a functor
02:29:34 <Philonous> Yes, because Functors have to work with any element type. Once you place restrictions on the type of the Element it can't be a Functor
02:30:12 <sim590> OK. That is what I needed to read.
02:30:24 <sim590> Thank you.
03:14:17 <evelyn>   
03:14:23 <evelyn> whoops
04:31:11 <dignissimus> o/ I'm running arch and I'm new to haskell, what's the recommended way to set up a dev environment?
04:31:51 <dignissimus> As in, I could use ghcup or I could install packages from the arch repos
04:35:16 <Philonous> I find the easiest way is to install stack and let stack handle GHC 
04:38:17 <Philonous> So »pacman -S stack« , then »stack init« in your project if you already have a .cabal or package.yaml file or »stack new« if you want to create a new one. Then you can build with »stack build --install-ghc« . 
04:39:11 <Philonous> (You only need --install-ghc on the first run)
04:46:15 <dignissimus> Philonous: Done all that now, time to start learning haskell!
05:02:50 <klntsky_> how can i set heap size limit in a pragma? I tried {-# OPTIONS_GHC +RTS -M20m -RTS #-} but this does not work.
05:03:39 <c_wraith> that sets the heap size of the compiler
05:05:51 <klntsky_> c_wraith: I want it to work the same way it works in ghci but with compiled binaries. More specifically, I need it to demonstrate how some functions leak heap.
05:06:20 <c_wraith> it would be a lot easier to just set it when you run the demo program
05:06:40 <klntsky_> with rtsopts?
05:10:12 <sm[m]> Philonous: isn’t —install-ghc the default ?
05:13:34 <orcus> Is there a way to mark a core plugin as compatible with -XSafe, on 8.6.5 (-fno-safe-haskell would work, but is only in 8.8)?
05:33:28 <klntsky_> Why there is no INLINE pragma for $! in Prelude? 
05:41:27 <sicklorkin> klntsky_: Are infix operators inlineable?
05:41:52 <hpc> they're just functions
05:45:16 <sicklorkin> hpc: If I wrote `strictDolla = $!` and $! was INLINEABLE would strictDolla also be INLINEABLE?
05:45:52 <sicklorkin> s/INLINEABLE/INLINE/
05:46:20 <hpc> not sure, haven't looked terribly in-depth at inline stuff
05:46:35 <hpc> but there's nothing special about infix identifiers
05:47:04 <hpc> actually, they're not even "just functions"
05:47:07 <hpc> they're "just values"
05:47:09 <hpc> > let (%%) = 5 in (%%)
05:47:12 <lambdabot>  5
05:48:27 <hpc> if strictDolla and ($!) had the same definition and pragmas applied to them, they would be indistinguishable except by name
05:49:14 <sicklorkin> hpc: but their fixity would be different non?
05:49:32 <hpc> fixity is unrelated to inlineability
05:49:46 <hpc> but you can also define fixity for "wordy" identifiers
05:50:59 <hpc> Prelude> :{
05:51:00 <hpc> Prelude| infixr 9 `foo`
05:51:00 <hpc> Prelude| foo = 5
05:51:00 <hpc> Prelude| :}
05:51:04 <hpc> works in ghci
06:02:46 <olligobber> hpc, `let (%%) = 5 in 1 %% 2' yields 5 if you make `instance (Num a => Num (b -> a)'
06:03:00 <olligobber> that's missing a bracket
06:05:06 <iqubic> @pl \f g x -> f x + g x
06:05:06 <lambdabot> liftM2 (+)
06:05:10 <iqubic> What?!?!
06:06:00 <olligobber> I used liftA2, but same thing
06:06:10 <olligobber> it's the monad instance of (->) that does it
06:06:33 <iqubic> Does that mean that 'instance (Num a => Num (b -> a)' is basically just fmap/liftA2?
06:06:56 <olligobber> you also need pure for fromInteger, but yeah
06:07:04 <olligobber> `> instance (Num a => Num (b -> a)) where (+) = liftA2 (+); (*) = liftA2 (*); abs = fmap abs; signum = fmap signum; fromInteger = pure . fromInteger; negate = fmap negate'
06:07:10 <iqubic> @pl \f x -> abs $ f x
06:07:10 <lambdabot> (abs .)
06:07:19 <iqubic> :t fmp signum
06:07:20 <lambdabot> error:
06:07:20 <lambdabot>     • Variable not in scope: fmp :: (Integer -> Integer) -> t
06:07:20 <lambdabot>     • Perhaps you meant ‘fmap’ (imported from Control.Monad.Writer)
06:07:28 <iqubic> :t fmap signum
06:07:29 <lambdabot> (Functor f, Num b) => f b -> f b
06:07:56 <olligobber> oh yeah, fmap x = (x .) in the functor instance of (->)
06:08:14 <dminuoso> $ :t join (,)
06:08:18 <dminuoso> % :t join (,)
06:08:19 <yahb> dminuoso: b -> (b, b)
06:08:37 <dminuoso> This is a fun one that is not really instantly obvious. :)
06:08:53 <olligobber> where is join from?
06:09:06 <dminuoso> olligobber: Control.Monad.join
06:09:06 <iqubic> It's a monad thing.
06:09:10 <iqubic> :t join
06:09:11 <lambdabot> Monad m => m (m a) -> m a
06:09:32 <olligobber> oh, it's that join
06:09:44 <iqubic> How does join (,) work?
06:09:51 <iqubic> :t (,)
06:09:51 <dminuoso> iqubic: Consider it a challenge.
06:09:52 <lambdabot> a -> b -> (a, b)
06:10:22 <iqubic> (,) has type "a -> (b -> (a, b))"
06:10:28 <olligobber> :t (,) :: a -> a -> (a,a)
06:10:30 <lambdabot> a -> a -> (a, a)
06:10:57 <olligobber> m = (->) a
06:11:24 <iqubic> :t (,) :: (->) a ((->) a (a,a))
06:11:25 <lambdabot> a -> a -> (a, a)
06:11:25 <olligobber> dminuoso, nice
06:11:38 <iqubic> What does join do?
06:12:01 <iqubic> I mean what does it for funtions?
06:12:04 <dminuoso> iqubic: You've been around long enough. Wrong question.
06:12:38 <dminuoso> iqubic: Identify the instance its acting on, look it up (its in base)
06:13:12 <dminuoso> olligobber: The rather subtle part is why the b disappears. :-)
06:13:39 <MarcelineVQ> or try to write it since this one only has one way
06:13:51 <olligobber> dminuoso, type resolution, it has to match m = (->) a = (->) b, so a = b
06:13:53 <iqubic> Monad ((->) r :: Type -> Type)
06:14:33 <sicklorkin> :t join (***)
06:14:34 <lambdabot> Arrow a => a b' c' -> a (b', b') (c', c')
06:14:38 <iqubic> :t (,) :: (->) a ((->) b (a,b))
06:14:39 <lambdabot> a -> b -> (a, b)
06:15:49 <olligobber> I can think of how to define (>>=) in terms of join, but not the other way around for some reason
06:16:08 <dminuoso> olligobber: Sure. I mean its rather handwavy, since actual type unification would require properly replacing tyvars in used identifiers with unificationals
06:16:11 <olligobber> is it just (>>= id)?
06:16:31 * hackage tomland 1.2.0.0 - Bidirectional TOML serialization  https://hackage.haskell.org/package/tomland-1.2.0.0 (shersh)
06:16:32 <dminuoso> olligobber: Try it out with ghci? :)
06:16:38 <olligobber> yeah, that's it
06:16:46 <iqubic> instance Monad ((->) r) where
06:16:57 <iqubic> f >>= k = \ r -> k (f r) r
06:17:54 <olligobber> so in this case, join (,) = (,) >>= id = \r -> id ((,) r) r = \r -> (,) r r
06:18:51 <iqubic> Yes. That's right.
06:18:51 <olligobber> but of course that's what it does, at a type level it has type b -> (b,b), so that's the only sensible function
06:19:15 <iqubic> Correct.
06:19:59 <dminuoso> sicklorkin: I like that
06:20:15 <dminuoso> (I still dont understand Arrows really)
06:20:20 <iqubic> Does anyone ever use do notation for the function monad?
06:20:29 <iqubic> I don't know Arrows either.
06:20:39 <dminuoso> iqubic: It's usually called Reader monad.
06:20:44 <dminuoso> iqubic: And sure, its used sometimes.
06:21:39 <iqubic> I have been around here long enough that I really really should have known that.
06:21:43 <lyxia> I could imagine using (>>=) and applicative for code golfing
06:22:05 <lyxia> but not do notation
06:22:08 <olligobber> I have used do notation for the functor monad
06:22:15 <olligobber> I mean the function monad
06:22:26 <dminuoso> lyxia: There's actually quite a lot of apps using do-notation, its mostly MonadUnliftIO based stacks (usually wrapping some environment and a logger)
06:22:38 <lyxia> do notation for (->)
06:22:54 <iqubic> What is MonadUnliftIO?
06:23:00 <dminuoso> Sure. Perhaps via some newtype wrapper, but if you have `newtype App a = LoggingT (ReaderT Env IO) a`
06:23:08 <olligobber> ok, I did use the do notation for the function monad, but then realised what I'd written was shorter just using >>=
06:23:12 <dminuoso> (And this style is somewhat common, I myself use it frequently)
06:23:20 <dminuoso> Oh, missed a newtype constructor there.
06:23:29 <lyxia> do y <- f ; z <- g y ; pure (f y z)   =  \x -> let y = f x ; z = g y x in f y z
06:23:33 <dminuoso> newtype App a = App { runApp :: LoggingT (ReaderT Env IO) a }
06:23:40 <dminuoso> iqubic: The opposite of MonadIO
06:23:54 <lyxia> my point is (->), which was iqubic's question.
06:23:57 <iqubic> How does that work?
06:24:00 <dminuoso> Ahh I see.
06:24:27 <olligobber> I had a lot of calculations to compose, but all also required the same extra piece of data, so `eqMapping = (!) . (startEqTable >>= flip solveTable >>= flip convertTable)'
06:24:53 <dminuoso> iqubic: Well.. it works for essentially just ReaderT (and isomorphic things) based stacks.
06:25:18 <iqubic> I kinda understand, but not really.
06:25:45 <dminuoso> It gives you access to a primitive which, for the sake of discussion, could be thought of `unliftIO :: MonadUnliftIO m => m a -> IO a` (the actual methods it has are slightly more complicated because of how our type system works)
06:26:52 <iqubic> So by opposite, you mean dual. Got it.
06:27:04 <dminuoso> No I mean opposite
06:27:10 <iqubic> I see.
06:28:09 <dminuoso> askRunInIO :: MonadUnliftIO m => m (m a -> IO a) 
06:32:20 <olligobber> now I'm falling down the bottomless pit of category theory
06:32:24 <olligobber> better go to sleep instead
07:07:16 <d34df00d> Is it possible to write a type family instance constrained on the type classes implemented by the family's argument?
07:08:07 <d34df00d> To avoid X-Y problem, I'm trying to do something with generics using type families, and I need to have `Foo (K1 _ a) = Foo (Rep a)` somewhere, but only if `a` has the corresponding `Rep` type instance (otherwise computing the type family obviously gets stuck).
07:12:40 <lyxia> there's no way to branch on the existence of a type instance
07:13:11 <d34df00d> That quite sucks.
07:13:40 <dminuoso> d34df00d: What would you want to happen, if no such type instance exists?
07:13:59 <d34df00d> dminuoso: I'd have a fallback instance.
07:14:21 <d34df00d> Smth like Generic a => Foo (K1 _ a) = Foo (Rep a) ; Foo _ = 'Fail
07:14:50 <lyxia> Generics are pretty bad with recursive types
07:15:06 <d34df00d> lyxia: glad you specifically answered. You might remember a couple of months ago you helped me writing a generic implementation of Has ( https://gist.github.com/Lysxia/e02e587ca1a08e5373301dc7d7f6a8be ), and I suddenly realised it doesn't recurse into nested types.
07:15:12 <lyxia> or whenever you want to apply some strategy through the fields of a type
07:15:33 <d34df00d> So I'm sort of trying to fix that.
07:16:17 <gobby> Has anybody used `wai-lambda` on AWS?
07:16:27 <dminuoso> gobby: Yes.
07:17:19 <gobby> dminuoso how do you incorporate HTTPS and use `wai-lambda`? `runTLS` results in `IO () `
07:17:30 <dminuoso> I have no idea, I dont even know what it is.
07:18:10 <gobby> dminuoso ? 
07:18:24 <lyxia> d34df00d: oh yeah I remember
07:19:35 <lyxia> why not use generic-lens
07:20:27 <d34df00d> lyxia: it's fun to write your own stuff.
07:20:37 <d34df00d> But thanks for the hint, I'll take a look at how they write it.
07:20:50 <d34df00d> But... My gut feel is that lens don't need to do this sort of recursion.
07:20:54 <lyxia> take a look at what types does.
07:21:33 <d34df00d> lyxia: you mean Data.Generics.Product.Types ?
07:21:43 <d34df00d> (in generic-lens)
07:21:49 <lyxia> Well, I especially worked on that sort of recursion for that module.
07:22:01 <d34df00d> Awesome, will look into it!
07:22:54 <gobby> dminuoso what was your `wai-lamba` experience?
07:23:22 <lyxia> d34df00d: it still boils down to the fact that you will need to either list types that implement Generic or those that don't, somehow.
07:24:02 <dminuoso> gobby: You just asked whether anyone has ever used it. I deduced it must have because it has a few hundred downloads..
07:24:18 <gobby> dminuoso don't be a smart ass
07:24:24 <dminuoso> gobby: You'll probably have a better luck asking on the issue tracker.
07:26:29 <d34df00d> lyxia: hmm. Can I have my own typeclass MyGeneric such that `deriving MyGeneric` will imply `deriving Generic`?
07:26:46 <d34df00d> I could implement type instances for my own stuff in MyGeneric.
07:45:50 <lyxia> The closest you can do without TH is deriving (Generic, MyGeneric)
09:04:57 <__dingbat__> Hello, can someone help me understand the constructor :
09:05:00 <__dingbat__> Transport a => BinaryProtocol a	
09:05:36 <__dingbat__> How do I instantiate a BinaryProtocol object please?
09:05:50 <__dingbat__> https://hackage.haskell.org/package/thrift-0.12.0/docs/Thrift-Protocol-Binary.html
09:06:21 <d34df00d> Alright, I no longer undertand PolyKinds. What exactly are the semantics of `k` in something like `type family Foo (arg :: k -> *)`?
09:06:26 <d34df00d> Is it polymorphic on k?
09:07:02 <heatsink> yes
09:07:23 <EvanR> imagine a forall k . in front
09:07:36 <EvanR> k quantifies over all kinds
09:07:44 <d34df00d> That's good, that agrees with my intuition.
09:07:47 <merijn> __dingbat__: Looks like it's an existential, but that might be completely irrelevant to use it. Simply pass any "a" that's an instance of Transport to BinaryProtocol
09:07:49 <d34df00d> But why do I then get the following error?
09:08:00 <d34df00d> Expected kind ‘k -> *’, but ‘Rep b’ has kind ‘* -> *’
09:08:18 <d34df00d> (I try to do smth like `Foo (Rep Int)`
09:08:55 <EvanR> merijn: d34df00d wait how can you have a constraint on the data ctor like that...
09:08:55 <merijn> d34df00d: The arg *must* accept any kind 'k'
09:09:01 <EvanR> er __dingbat__ 
09:09:02 <merijn> EvanR: It's a GADT
09:09:16 <__dingbat__> merijn: Thank you, that seems to work. But I am stuck trying to declare a data type like this:
09:09:17 <__dingbat__> data NetworkServiceHandler = NetworkServiceHandler {
09:09:19 <__dingbat__>                      rpcQueue :: TChan RPCCall
09:09:20 <__dingbat__>                     , binProto :: MVar (BinaryProtocol )
09:09:21 <merijn> EvanR: So it's just ExistentialQuantification with GADT syntax :)
09:09:22 <__dingbat__>                 }
09:09:24 <EvanR> merijn: it's not using GADT syntax and it's not enabled in the file...
09:09:33 <EvanR> oh Existential
09:09:50 <d34df00d> merijn: so it's more like `Foo (arg :: forall k. k -> *)` and not `Foo forall k. (g :: k -> *)`?
09:09:52 <merijn> EvanR: Oh, I had guessed it was a GADT, because I dislike Existential without them :p
09:10:00 <merijn> d34df00d: That's my guess, yes
09:10:16 <EvanR> __dingbat__: well in your record there you must name what type BinaryProtocol takes
09:10:17 <d34df00d> Hmm, that doesn't agree with my intuition.
09:10:27 <d34df00d> Crap, I should probably make a minimal reproducing example.
09:10:30 <__dingbat__> merijn: I am yet to read/understand GADTs
09:10:45 <EvanR> MVar wants a complete type
09:10:55 <merijn> __dingbat__: Fortunately it's not even a GADT, just ExistentialQuantification (although that's not easier to understand :p)
09:11:02 <EvanR> BinaryProtocol Foo would work if Foo has a Transport instance
09:11:13 <merijn> I don't even understand *why* it's an existential, except to smuggle the typeclass somewhere
09:11:32 <EvanR> because existential == OOP
09:11:40 <EvanR> in bizarro world
09:12:04 <__dingbat__> just this doesnt work, binProto :: MVar (BinaryProtocol Transport)
09:12:15 <EvanR> Transport isn't a type
09:12:25 <__dingbat__> so I have to create a new type thats an instance of Transport?
09:12:25 <merijn> EvanR: Well, it's a type, but it's not a datatype :p
09:12:43 <merijn> __dingbat__: Well, presumably that library already has types that are instance of Transport
09:13:12 <merijn> __dingbat__: Indeed, if you go to https://hackage.haskell.org/package/thrift-0.12.0/docs/Thrift-Transport.html#t:Transport you will see a list of instances at the bottom
09:13:52 <__dingbat__> merijn: thanks will try it out!
09:15:22 <__dingbat__> I used the EmptyTransport, seems the most appropriate
09:15:53 <EvanR> sounds like that transport will accomplish a lot of nothing
09:19:37 <__dingbat__> EvanR: its only for use in another constructor where I create a handle that will subsequently be properly setup
09:26:45 <higherorder> Hi! Is there a systematic way to use `try` with megaparsec? I am finding myself kind of throwing it around the grammar when I encounter cases it cannot parse, which doesn't seem... wise
09:28:01 <merijn> higherorder: This has some notes on how to use it: http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
09:28:23 <higherorder> merijn: thanks!
09:42:17 <dignissimus> Does haskell have anything like this [https://hastebin.com/efazagibot.hl] where a function can take either 1 or 2 parameters
09:42:48 <dignissimus> I just pulled some code from learn you a haskell
09:47:02 <EvanR> common wisdom imho is to use two different function names, one with 1 param one with 2. Perhaps define one in terms of the other
09:47:34 <essentiality[m]> hello haskell..ers
09:47:42 <dignissimus> Thanks!
09:47:51 <EvanR> you can also pass in an argument like Either A (A,B) but down this road leads the agony of javascript, ruby APIs
09:47:59 <dmj`> dignissimus: there is a hack to make a function of arbitrary arity using typeclass induction on (->)
09:48:14 * dmj` waves to essentiality[m]
09:50:31 * hackage ftp-client 0.5.1.3 - Transfer files with FTP and FTPS  https://hackage.haskell.org/package/ftp-client-0.5.1.3 (miscyb)
09:52:22 <essentiality[m]> hmm yes... sounds mathy
09:52:51 <d34df00d> Can I write a type family `If` such that it requires reducing only the argument chosen by the corresponding boolean parameter?
09:53:21 <d34df00d> In other words, I want `If 'True T Stuck` and `if 'False Stuck T` both evaluate to T even when Stuck is, well, stuck.
09:54:45 <EvanR> i didn't think type families had the notion of evaluation order
09:54:57 <EvanR> since they can't bottom out
09:55:21 <EvanR> hopefully the result doesn't depend on evaluation order
09:55:22 <d34df00d> Uh, sorry for bad question. I didn't mean evaluation order, I rather meant which argument gets evaluated at all.
09:55:42 <EvanR> that's what i'm saying, shouldn't make a difference?
09:55:46 <geekosaur> the typechecker isn't lazy
09:55:49 <heatsink> Type families do interact with the type checker's notion of type equality
09:56:07 <d34df00d> EvanR: nope, assume there's `type family Stuck a` with no instances.
09:56:34 <d34df00d> Then what does `If 'True Int (Stuck Int)` evaluate to?
09:56:35 <heatsink> You might want `type family If (b :: Bool) :: * -> *` instead of `type family If (b :: Bool) a :: *`
09:56:39 <EvanR> Int ?
09:56:50 <heatsink> Uh, I missed one parameter but you get the idea
09:56:52 <d34df00d> EvanR: nope, because it needs to evaluate Stuck Int as well, if I understand correctly.
09:57:02 <EvanR> "evaluate"
09:57:06 <d34df00d> Reduce.
09:57:11 <EvanR> if there are no instances, so what?
09:57:26 <d34df00d> So it's stuck, and I don't get my precious Int.
09:57:53 <EvanR> have we actually tried this
09:57:54 <d34df00d> heatsink: I tried something similar, having `type family Fst (a :: k) (b :: k) :: k where Fst a _ = a` and similarly for Snd.
09:58:05 <d34df00d> heatsink: and then I have `If 'True = Fst`
09:58:15 <d34df00d> But it doesn't work:
09:58:57 <d34df00d>     • The type family ‘Fst’ should have 2 arguments, but has been given none
09:59:08 <d34df00d> EvanR: yep. It doesn't reduce.
09:59:11 <dmj`> I think the type level evaluation strategy is strict
09:59:24 <EvanR> i think i was thinking If was a function
09:59:27 <EvanR> but it's a relation
09:59:38 <EvanR> so it's like you have a tuple component that can't be anything
09:59:47 <EvanR> so nothing is the right answer
10:00:18 <d34df00d> Sort of.
10:00:23 <d34df00d> I think. At least I have a similar intuition.
10:03:36 <heatsink> d34df00d: If you do it that way, Fst needs to be a newtype constructor and you need to explicitly wrap or unwrap it
10:04:03 <d34df00d> heatsink: I'm not sure I understand how that would look like.
10:04:04 <heatsink> when you want to convert Fst a b <-> a
10:04:23 <d34df00d> I mean newtype is term-level stuff, right? But we're in typeland.
10:04:55 <heatsink> foo :: If 'True Int Bool -> Int; foo (Fst n) = n
10:05:06 <heatsink> bar :: If 'False Int Bool -> Bool; bar (Snd b) = b
10:05:33 <EvanR> newtype is type-level ONLY :)
10:05:44 <d34df00d> Hmm.
10:05:53 <d34df00d> heatsink: but foo and bar are term-level functions.
10:06:00 <d34df00d> While I'm doing all my things in types.
10:06:07 <d34df00d> (that If will be used as an RHS of some other type family)
10:06:14 <EvanR> foo looks like a type
10:06:36 <EvanR> ah yeah i see the definitions. But they don't do anything
10:07:21 <EvanR> foo and bar make sense but how would you make use of them for "decisions"
10:08:30 <dignissimus> `Num is not a subclass of Ord`, why? Or, what kind of numerical value can't be ordered?
10:08:31 <heatsink> I'm not sure how d34df00d wants to make use of type-level booleans for decisions
10:08:54 <heatsink> complex numbers can't be ordered
10:09:02 <dignissimus> Ah yes
10:09:06 <d34df00d> ...in a way compatible with multiplication.
10:09:21 <d34df00d> Or with ring structure, better say.
10:10:09 <EvanR> would the subclass relationships help
10:10:11 <d34df00d> heatsink: I'm not sure yet either. I have a rough idea but that'd be a huge digression.
10:10:12 <geekosaur> or, no matter how you try to flatten two values / dimensions into one, you lose information
10:11:04 <EvanR> unless there is some compelling reason the default hierarchy should be "none"
10:15:25 <d34df00d> Uh, dammit. Turns out I cannot have a top-level `type instance Foo a = 'False` and then more specific `type instance Foo MyType = 'True`.
10:15:48 <EvanR> heh...
10:16:04 <EvanR> overrides!
10:16:10 <merijn> You need a closed type family for that
10:16:31 <d34df00d> merijn: the whole purpose is to know if a type implements a given type in a type-family-friendly context.
10:16:35 <d34df00d> So it can't be closed.
10:16:48 <EvanR> instanceOf!
10:17:16 <heatsink> What do you mean by implements?  Instance of a type class?
10:17:20 <merijn> d34df00d: Well, that's not gonna have any answers more pleasant than an elder god melting your brain out :p
10:17:32 <d34df00d> heatsink: yep.
10:17:52 <EvanR> checking for instance of at compile time is sure to break a lot of haskellisms
10:18:17 <EvanR> because of separate compilation, class coherence stuff
10:18:31 <heatsink> Could you just capture the type class constraint in a suitable data structure?  Having the data structure would be evidence that it's an instance of the class.
10:19:09 <d34df00d> heatsink: I'm not sure. I basically want to know if a type t is an instance of Generic and if I could do `Rep t` without my type families getting stuck.
10:19:45 <EvanR> library compiled under the notion that A does not implement class C, then someone using the library is also using a version of the library where A is infact an instance of C
10:20:11 <EvanR> version of another library where A comes from
10:20:19 <d34df00d> In other words, let's say I have `type family Search k part (grec :: k -> *)`, and then I'd like to have instances such as
10:20:21 <merijn> I recommend the much easier solution of "stop wanting what you're currently wanting", but that's not very constructive :)
10:20:33 <d34df00d> Search k part (K1 _ part) = 'Found
10:20:39 <merijn> On the upside, you'd become much happier!
10:21:00 <d34df00d> Search k part (K1 _ other) = Search * part (Rep other) -- if `other` implements Generic, even if it requires some manual annotations
10:21:08 <d34df00d> Search k part (K1 _ other) = 'NotFound -- otherwise
10:21:10 <EvanR> no it still might be a case of "what are you really trying to do"
10:21:37 <heatsink> You can't make a type-level decision based on whether a type implements a type class.
10:22:01 <d34df00d> heatsink: even if the type class in question is in my control, so I can try sort of registering all of the implementations?
10:22:24 <heatsink> You still can't
10:22:29 <d34df00d> EvanR: I want to be able, having two data types `part` and `record`, deduce if `record` contains `part` recursively.
10:22:32 <Welkin> who runs the haskell.org website?
10:22:40 <d34df00d> That really sucks, meh.
10:22:57 <Welkin> I showed someone the site and they tried the embedded repl, and all of the suggestions I gave to them to type in failed to work
10:23:02 <geekosaur> d34df00d, "registering" sounds like closed type family to me. (typeclasses are always open)
10:23:12 <merijn> Welkin: A bunch of people. There's an admin address
10:23:15 <Welkin> it left a bad impression of the language and completely misses the point of "why haskell"
10:23:18 <heatsink> The type system tries to preserve the constraint that if your code compiles, then defining new instances won't change its behavior
10:23:18 <geekosaur> but you said no closed type family…
10:23:20 <merijn> Welkin: Also #haskell-infrastructure
10:23:35 <heatsink> *fulfill the property that...
10:23:46 <d34df00d> geekosaur: I mean, it's ok if I have to do `type instance IsRegistered Foo = 'True`.
10:24:00 <d34df00d> But I don't know all such Foos at the point of IsRegistered definition.
10:24:07 <merijn> Welkin: It works here? Do you know which browser they used?
10:24:23 <geekosaur> it freezes up for me? chrome, linux
10:24:34 <merijn> I'm using Chrome on macOS
10:25:00 <Welkin> merijn: the most basic examples (the ones suggested) work
10:25:06 <heatsink> I would suggest searching for the instance at runtime, at the value level instead
10:25:20 <Welkin> but I tried to import Data.Foldable and check the types of things
10:25:22 <EvanR> Welkin: this is why you don't haskell evangelize :)
10:25:23 <Welkin> neither worked
10:25:28 <EvanR> it will just backfire 
10:26:09 <Welkin> by contrast, look at the Elm repl
10:26:15 <geekosaur> and I don't think anyone intends that it allow imports, etc.; you need some fairly solid bulletproofing for a full environment. and certainly no IO
10:26:16 <d34df00d> heatsink: the point is to accept (or reject) certain code at compiletime.
10:26:28 <Welkin> it's the full elm compiler in the browser and autocompiles
10:26:30 <Ariakenom> d34df00d: How would Maybe (Data.Constraint.Dict (Generic a)) work for you? https://hackage.haskell.org/package/constraints-0.11.2/docs/Data-Constraint.html#t:Dict
10:26:38 <EvanR> Welkin: i tried tryhaskell a few days ago was pleased to see it still working
10:26:42 <Welkin> https://elm-lang.org/try
10:26:45 <merijn> Welkin: Patches welcome? :p
10:27:21 <heatsink> I see.  The repl suggests to try importing things, but it can't parse "import"
10:27:25 <merijn> Like, I get that "all of Elm works in the browser" is really cool, but that's a shitton of work the, all likelihood, no one will ever get paid to do
10:27:52 <EvanR> .oO( now how did elm get all that money... oh ruby)
10:28:16 <Welkin> elm doesn't get money, haha
10:28:18 <EvanR> oh elm.. not elixit
10:28:35 <Welkin> the community is just very focused on making it easy to get people using it
10:28:39 <merijn> EvanR: Well, you don't necessarily need money. You need someone who has both the skill, time and motivation to implement it without wanting to be paid
10:29:11 <cheater> hi
10:29:12 <merijn> There's lots of people with the skill in haskell, but most if not all are dramatically lacking in time :p
10:29:12 <Welkin> Elm has its own codepen called Ellie
10:29:15 <Welkin> it's pretty awesome
10:29:51 <merijn> So the only way it will happen is if someone steps up and makes it happen
10:30:04 <Welkin> sure
10:30:30 <Welkin> I'm trying to get more buy-in for functional programming at work and will definitely try to introduce elm
10:30:40 <Welkin> but haskell is going to be a hellof a hard sell for people used to java
10:31:02 <Welkin> if I get  skunkworks team for a microservice, then maybe
10:31:37 <heatsink> It runs on the JVM now
10:31:42 <Welkin> yes, eta-lang
10:32:38 <EvanR> selling haskell... i don't envy this task
10:33:11 <Welkin> I should have an easier time selling elixir, especially because it solves scalability problems immediately and clearly, and has an easier learning curve
10:33:40 <Ariakenom> I have around 10 people who said they would be interested in a hs workshop at work :)
10:33:54 <EvanR> i'm in the board room or water cooler room or something, telling everyone Don't you like Functors?? Come on
10:34:04 <Welkin> my plan for personal projects and products is to use elixir for the backbone of my services with haskell for processing workloads
10:34:25 <cheater> i have a simple ADT that only contains integers and bytestrings and I'd like to send it out via a binary protocol. what's a good way to serialize it into a bytestring?
10:34:37 <EvanR> the binary package
10:34:41 <cheater> thanks EvanR 
10:34:46 <cheater> any other contenders?
10:35:05 <Welkin> that's standard
10:35:17 <Welkin> there aren't really contenders
10:35:25 <EvanR> there's a few
10:35:36 <cheater> eg?
10:35:51 <EvanR> cereal, serialise (spelled wrong)
10:36:10 <EvanR> cborg
10:36:20 <Ariakenom> adding more distribution and concurrency into programs is not something I would do freely
10:36:25 <cheater> thanks
10:36:29 <cheater> what's wrong with serialise?
10:36:42 <EvanR> nothing it just looks funny
10:36:47 <cheater> ok :)
10:37:13 <Ariakenom> flat is another
10:37:34 <cheater> thx
10:38:33 <Ariakenom> here is a benchmark. perf isn't everything but it does list some libs https://github.com/haskell-perf/serialization
10:39:01 <cheater> oh, nice!
10:39:02 <Welkin> Ariakenom: of course, but it makes sense in many cases, if you are familiar with how erlang works
10:39:56 <Welkin> an erlang application is actually a collection of independetn applications that send messages to each other, all on the same machine
10:39:58 * EvanR hugs the async library
10:40:08 <Ariakenom> I havent used it myself but I have a colleague who works in it
10:40:53 <EvanR> yes erlang is basically an OS
10:40:58 <Welkin> for your ORM/database layer, you run it as a separate service that gets messaged by your API service
10:41:03 <EvanR> it's unfortunate the actual OS isn't as popular
10:43:38 <Welkin> you can run it on microcontrollers too
10:43:47 <Welkin> yes, there is an erlang OS
10:43:50 <Welkin> it's pretty damn awesome
10:44:02 <EvanR> there are these interesting VMs which just run your application instead of the OS
10:44:02 <Welkin> it never crashes
10:44:26 <EvanR> then at least it's not embarassingly redundant
10:44:27 <Rembane> No, it always crashes and then restarts immediately.
10:44:37 <Welkin> haha, sure
10:44:49 <Welkin> parts of the sysem can go down, but the whole thing never does
10:44:55 <Welkin> and to the user, it looks like it never crashes
10:45:04 <Welkin> nothing happens at all
10:45:06 <EvanR> again, OS :)
10:45:25 <EvanR> OS called they want their sales bullet points back
10:53:34 <sm[m]> Welkin: good feedback. I doubt that widget has an active champion unfortunately
10:54:27 <sm[m]> personally I would expect any kind of importing to work in such a widget; that would be unusual
10:54:32 <sm[m]> I would NOT expect
10:54:56 <sm[m]> I think probably the real lesson here is practise your pitch beforehand
10:57:07 <EvanR> having to import things for simple tasks is not something i would brag about :(
10:58:31 <sm[m]> indeed
10:58:58 <sm[m]> that's why we need easyhaskell, with all the batteries already in scope
10:59:16 <Welkin> well I also think the homepage misses the point
10:59:19 <merijn> I'm not sure all the batteries necessarily make things easier :)
10:59:43 <Welkin> the real strength of haskell is the type system (curry-howard isomorphism), immutability, and concurrency
10:59:53 <sm[m]> of course I mean: all the ones that make things easier :)
11:00:02 <EvanR> there is a measurable difference between just shooting off some line of code into repl and first having to arrange some imports
11:00:10 <Welkin> how you can demonstrate that is the goal here
11:00:46 <Welkin> I don't think most people understand that state mutation is the root of almost all bugs
11:00:49 <EvanR> it's like the same reason git was created, the other version systems took too long to run, messing up your mojo
11:01:02 <merijn> @quote i.have.to.explain
11:01:02 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of
11:01:02 <lambdabot> these nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
11:02:01 <EvanR> state mutation is one reason what you thought was was not there. Another reason is no type system
11:02:18 <EvanR> another reason is not even checking variables make sense before runtime (ruby)
11:02:55 * EvanR allocates more space for this list of reasons
11:03:21 <Welkin> when I showed a coworker the repl on the homepage, and I showed him a `reverse` example using foldr, he said "I can do that in python by just using list[-1]"
11:03:45 <Welkin> a facepalm moment
11:04:06 <Welkin> the example didn't show anything useful about the language other than "look at this alien syntax"
11:04:49 <merijn> Welkin: The answer is "you can't show this off 'in the small'"
11:04:54 <Welkin> yes
11:04:59 <Welkin> peolpe don't know what they don't know
11:05:30 <EvanR> unexpectedly, i got a positive response when i used the mundane record field update in an example
11:05:42 <EvanR> do that in python
11:06:54 <merijn> I think the best way to show off Haskell in small examples at the moment is: parsing, streaming data processing, and high concurrency
11:07:01 <merijn> Especially mixing those two
11:07:14 <Welkin> I like that quote though
11:07:17 <Welkin> I'm going to use that one
11:07:20 <merijn> Welkin: :)
11:07:21 <Welkin> "there's no variables"
11:07:36 <Welkin> it's provacative enough to make people say "tell me more"
11:07:50 <Welkin> provocative*
11:08:53 <EvanR> it's also notoriously false
11:09:14 <Welkin> it's more appropriate to say there is no assignment
11:09:18 <Welkin> because there isn't
11:09:30 <Welkin> also, it's pretty true
11:09:32 <Ariakenom> list[::-1]
11:09:36 <Welkin> variables "vary"
11:09:42 <Welkin> that make's them variables :P
11:09:48 <Welkin> yes Ariakenom, I typo'd
11:09:58 <merijn> Welkin: I was looking up some similar quotes from my quotes file and have concluded: I have lots of great quotes
11:10:23 <merijn> Also, relatedly, god #haskell is a bunch of nerds
11:10:27 <EvanR> i've so over correcting everyone's "wrong" terminology and understanding from other languages. What is more interesting in assuring people that haskell is a usable programming languages with many similarities to things people know and happen to also make sense
11:10:39 <sm[m]> excuse you!
11:11:04 <merijn> EvanR: Show them up by writing "impossible" programs as a single programmer :p
11:11:05 <EvanR> there is a unifying spirit buried somewhere in haskell, many features correspond with things people know
11:11:22 <Welkin> the number one most important feature is immutability
11:11:31 <Welkin> then the type system after that
11:12:08 <Welkin> in terms of concepts
11:12:18 <merijn> EvanR: Honestly, if we wanna convert people we should aim at the expert C/C++ people, those usually appreciate safety and high level coding, but think they can't have those. So you just have to convince them that they can easily call out to/fallback on C via the FFI and how easy that is :p
11:12:23 <EvanR> difference between "haskell is better than your language" and "haskell is accessible and cool"
11:12:38 <merijn> Once we've suckered them in they'll realise they hardly ever need that stuff
11:12:52 <merijn> Oh, also
11:13:04 <merijn> @quote stares.at.type
11:13:04 <lambdabot> autrijus says: * autrijus stares at type Eval x = forall r. ContT r (ReaderT x IO) (ReaderT x IO x) and feels very lost <shapr> Didn't you write that code? <autrijus> yeah. and it works <autrijus> I
11:13:04 <lambdabot> just don't know what it means.
11:14:13 <Welkin> the number one problem at my workplace is null pointer exceptions. It has caused countless production issues/failures/emergencies
11:14:27 <Rembane> I really wanted cabal to have the new-new command.
11:14:33 <Welkin> and we know there are thousands of them in the application
11:14:43 <Welkin> (it's java)
11:14:52 <EvanR> then make them feel more comfortable in haskell by introducing error :)
11:15:05 <EvanR> look you can get something like null pointer exceptions in haskell
11:15:24 <Welkin> and null is used *everywhere*
11:15:31 <Welkin> values are intialized to null be default
11:15:46 <EvanR> for the few people who think null pointer exception is avoidable, secretly tell them about Maybe on the side
11:16:00 <boxscape> GHC.Prim has nullAddr#
11:16:17 <heatsink> Do they use @nullable, Welkin?
11:16:21 <heatsink> or @nonnull
11:16:31 <Welkin> no
11:16:31 <Welkin> I don
11:16:36 <Welkin> I don't know what that is
11:16:40 <merijn> @quote Cale Lisps.are.functional
11:16:40 <lambdabot> Cale says: Lisps are functional programming languages to me in the same way that penguins are birds.
11:16:43 <Welkin> I'm not a java programmer
11:16:58 <EvanR> oh that's harsh cheater 
11:17:05 <EvanR> er, Cale
11:17:10 <Welkin> haha
11:17:16 <Welkin> someone asked me about lisp being functional
11:17:20 <Welkin> I told them the history of lisp
11:17:21 <nshepperd2> but penguins are birds!
11:17:28 <merijn> nshepperd2: They are, but also, not
11:17:32 <EvanR> so was T-Rex
11:17:33 <merijn> nshepperd2: That's the joke
11:17:33 <Welkin> "well, lisp is a family of languages with different branches"
11:18:00 <wildtrees> Welkin, try to get them to use kotlin instead of java, it has some null protection operations iirc 
11:18:04 <merijn> Actually, related to the discussion of "how do we convince beginners the language is accessible"
11:18:04 <Welkin> then someone pulled up the lisp history flowchart
11:18:11 <Ariakenom> beware of c++ programmers. they're scary
11:18:11 <heatsink> Welkin: You can annotate function parameters and returns with @nonnull in Java.  The compiler accepts and ignores the annotation.  There are some static analysis tools that use it to detect missing null checks.
11:18:12 <Ariakenom> @quote ieee.float
11:18:12 <lambdabot> edwardk says: type level ieee floats are a crime against nature. i had to implement them in c++ for template meta programming once. never ever again
11:18:13 * nshepperd2 comforts the poor misunderstood penguins. "I'll not let them compare you to a lisp"
11:18:15 <merijn> @quote Cale Beginners
11:18:15 <lambdabot> Cale says: Beginners are confusing to beginners. I move that we remove them from the language altogether.
11:19:27 <Welkin> wildtrees: we are moving from a monolith to microservices, that's the goal anyway
11:19:47 <Welkin> I want to introduce elm, haskell, and erlang/elixir at some point
11:19:58 <EvanR> the Null Protection Conjecture
11:20:06 <merijn> Welkin: Ah, so the famous "let's get rid of our single point of failure by introducing multiple points of failure"?
11:20:17 <wildtrees> Welkin, are you gonna containerize the microservices? 
11:20:43 <Welkin> wildtrees: no idea. That's not part of my job
11:21:27 <wildtrees> Welkin, you do frontend? 
11:21:34 <Welkin> I do development
11:21:35 <Welkin> front and backend
11:22:28 <Welkin> we have SREs and DBE/As and others who focus on production deployments
11:22:36 <cocreature> merijn: turning every problem into a distributed system problem surely must simplify things, right?
11:22:50 <merijn> cocreature: It does!
11:23:02 <merijn> cocreature: Now you can always blame another team when something breaks
11:23:17 <merijn> "Distributed Systems, not even once"
11:23:28 <Welkin> it just requires a different way of working
11:23:50 <merijn> Relatedly, don't pull too hard if you see a wire sticking out in distributed code
11:24:00 <merijn> I once went "huh, that's funny..."
11:24:18 <dsal> I feel like I should understand these layers of monad transformers before trying to implement something using them.
11:24:26 <merijn> Only to discover the distributed reference counting in our distributed system had been fundamentally broken for over a decade
11:24:44 <merijn> dsal: Have you implemented State and StateT from scratch yet?
11:24:55 <heatsink> distributed reference counting, eek
11:24:55 <dsal> A while back.  Not in a useful way.
11:25:08 <Welkin> wait waht
11:25:13 <dsal> I'm trying to implement a conduit thing.  I'm at the "I know what I want, but I'm unfamiliar with all this junk" stage.
11:25:15 <Welkin> what's the point of that?
11:25:15 <heatsink> If one computer crashes, do the others leak memory? 
11:25:17 <EvanR> raft algorithm, can't go wrong
11:25:25 <merijn> Welkin: What's the point of what?
11:25:31 <Welkin> how erlang solves this is that each process has its own heap and GC
11:25:32 <dsal> Control.Monad.Trans.Control and stuff
11:25:37 <merijn> heatsink: Naah, they potentially leak memory even if nothing crashes
11:25:43 <heatsink> oh, whew
11:25:44 <Welkin> merijn: distributed reference counting
11:25:46 <merijn> dsal: Is that the MonadBaseControl one?
11:25:52 <dsal> merijn: yeah
11:25:54 <merijn> Welkin: For resource that can migrate between machines
11:26:00 <merijn> dsal: Avoid that like the plague :p
11:26:14 <merijn> dsal: MonadBaseControl is super confusing and not worth the hassle, imo
11:26:26 <dsal> heh.  awesome.  I'll see if I can do something simpler.  My main problem is that I know what I want on the inside, but I don't understand what all the types are that are wanted here.
11:26:29 <merijn> I have to (re)figure out how it works every time
11:26:40 <merijn> dsal: So what are you trying to do?
11:26:54 <EvanR> LambdaMOO solves that by having only 1 thread, 1 heap, and 1 server
11:27:01 <EvanR> and 1 database
11:27:14 <dsal> merijn: Build a websocket conduit thing.  I've got TCP and TLS backends for my protocol.  It can also run on websockets, so I'm trying to adapt a websocket library.
11:27:24 <EvanR> i predict LambdaMOO will become the new hotness in web programming in 2030
11:27:34 <EvanR> "based on solid code with many years of experience"
11:27:51 <EvanR> it will make a lot of good points about having zero concurrency and zero distributivity
11:28:20 <merijn> EvanR: This reminds me of a tweet I saw recently
11:28:26 <Ariakenom> just solid code, not even SOLID?
11:28:51 <EvanR> in LambdaMOO handler code is cancelled if it takes too long to run, automatically satisfying the issue of things taking too long
11:28:59 <merijn> EvanR: https://twitter.com/ZachWeiner/status/1180867707845169152
11:29:01 <EvanR> ensuring prompt latency
11:29:17 <EvanR> lol yeah
11:29:41 <Welkin> merijn: I get an error "that page doesn't exist"
11:30:31 <Ariakenom> see, distributed things cant be trusted
11:31:10 <dsal> There's a much easier way to do this if I don't try to do all the fancy things this stuff's doing.
11:31:42 <sternmull> It just took me quite a while to see how with "f :: (a -> b -> c) -> a -> b -> c" the expression "f id" gets the type "(b -> c) -> b -> c". What can i read/exercise to get better at this? I seems like what i have to do is equational reasoning on the type level, is that right?
11:32:32 <Welkin> yes
11:32:32 <EvanR> id is polymorphic so what you did begins a process of solving for how to instantiate the type of id
11:32:34 <Welkin> it takes practice
11:32:41 <Welkin> do these exercises on paper
11:32:45 <EvanR> you can't do that in your head or not :)
11:32:50 <Welkin> find the type for (.).(.)
11:32:52 <EvanR> uhg... you CAN
11:32:58 <Welkin> it is very fun
11:33:04 <Welkin> also try `const id`
11:33:04 <merijn> sternmull: First step would be to add all hte necessary parentheses :)
11:33:07 <koz_> Or fmap . fmap . fmap
11:33:11 <Welkin> yes, that too
11:34:04 <Welkin> there is a step by step process of substituion, then reduction, rinse and repeat
11:34:22 <EvanR> unification
11:34:35 <EvanR> the reverse of substitution
11:34:40 <sternmull> Hm, but is there a name to this process that i can google for? In this case i succeeded after a lot of thinking and wondering. That was an interesting experience. But it would be helpful if there are any explanation how to do it efficient and what to watch out for.
11:36:31 <merijn> sternmull: Unification and and substitution are key words, yes. I don't know of any good explanations of it, though
11:36:36 <heatsink> sternmull: maybe this https://pointlessfunctor.blogspot.com/2017/05/efficient-unification.html
11:36:52 <merijn> sternmull: Honestly, the best way is to keep a pen and paper nearby and do it A LOT by hand in the start
11:36:58 <sternmull> Welkin: Yeah, "const id" was the first thing if this kind that made curious.
11:37:06 <merijn> sternmull: After a while you can do most simple things in your head easy enough
11:37:25 <merijn> Although you will still need paper for complex things
11:38:03 <sternmull> Ok, thanks. If everybody is doing it this way then i will too.
11:38:32 * hackage lazy-search 0.1.2.0 - Finds values satisfying a lazy predicate  https://hackage.haskell.org/package/lazy-search-0.1.2.0 (JonasDuregard)
11:40:07 <Ariakenom> sternmull: for example, when you have f id then you will get an equation  type of first argument = type of id; (a -> b -> c) = (x -> x); so you find a type for x that works. make sure to not mix up variables
11:48:08 <sternmull> ah, unification... right. I learned that 20 years ago in school :)
11:48:57 <sm[m]> Welkin: one way to persuade folks in that kind of environment is to port a small production service with known error rate to haskell. After a while running with much reduced error rate (and no other downsides, hopefully), you can reopen discussions, or better, just make sure it's noticed without making a lot of fuss about it, and repeat
11:50:19 <sm[m]> and when someone says I know what to do, we must migrate to haskell, say "hey good idea, I'll help you"
11:51:15 <sm[m]> and if you can arrange for that someone to be the boss, that's ideal :)
11:52:20 <Welkin> well, there are many levels of "boss" here
11:52:31 <Welkin> I have a bos who has a boss, who has a boss, who has a boss, who has a boss
11:53:20 <novum> I am just learning about Monads from https://en.wikibooks.org/wiki/Haskell/Understanding_monads and am creating a full implementation for Person with a first name and last name. In order to extrapolate the first name, last name, mother, and father, I am creating types like  type pFname String  ..  type pMother Maybe Person  is that conventional
11:54:14 <sm[m]> if you have a bos, you're in good shape :)
11:54:24 <Welkin> haha
11:56:28 * geekosaur was thinking that too…
11:59:48 <EvanR> how many levels of boss
12:00:29 <geekosaur> it's a boss-stack and you need the equivalent of MonadBaseControl
12:00:48 <EvanR> it's bosses all the way down
12:01:13 <Rembane> All your base are belong to us.
12:01:32 <EvanR> dang.
12:01:51 * EvanR tries to find an even older meme
12:02:45 <EvanR> Mr. T ate my boss
12:03:40 <Rembane> You fool! 
12:04:01 <koz_> geekosaur: MonadBossControl?
12:04:27 <geekosaur> sounds even harder than MonadBaseControl indeed
12:06:21 <cocreature> if your boss understands MonadBaseControl you’ve succeeded at MonadBossControl and can use Haskell at work
12:09:00 <geekosaur> heh
12:22:02 <dsal> My brain is a little broken.  Can I have a      (A -> IO ()) -> IO ()    and transform it to a  (B -> IO ()) -> IO ()      if I have an A -> B  ?
12:23:06 <dsal> These functions  are all a little upside down.  I think I might just end up having to make my own adaptations to avoid this inverted "run*" stuff.
12:27:14 <merijn> dsal: No, it's contravariant
12:27:21 <merijn> dsal: You need "B -> A"
12:27:29 <merijn> Actually
12:27:32 <merijn> Wait, no, you can
12:27:37 <merijn> Damn continuations!
12:27:38 <koz_> merijn: Was about to say.
12:27:41 <koz_> It's like Cont.
12:27:47 <merijn> It *is* Cont
12:28:12 <dsal> Hmm...  How does this work?
12:28:31 <merijn> dsal: First, you melt your brain
12:28:35 <dsal> Done.
12:28:40 <merijn> dsal: No, it's easy actually
12:28:59 <merijn> Suppose we have "foo :: (A -> IO ()) -> IO ()"
12:29:31 <merijn> and "convert :: A -> B"
12:29:49 <merijn> \f -> foo (f . convert)
12:36:39 <dsal> Well that worked.  I should eat lunch before trying to figure out why.
12:40:05 <dsal> Thanks, merijn.  This is a good step forward for me.
12:43:46 <novum> Is record syntax commonly used for `data` construction. Seems nice to get the getter functions
12:44:31 <pikajude> yeah it is usually
12:44:59 <EvanR> though getters is just one way to access the fields
12:45:36 <EvanR> you also have a salad bar of pattern matching and extensions to pattern matching
12:45:43 <EvanR> and lens
12:46:34 <sicklorkin> What's the canonical way of defining `instance Semigroup Foo10Fields where (<>) (Foo10Fields a..j) (Foo..a'..j') = Foo10Fields a+a' b+b'... Is there a Generics.Deriving.Semi?
12:47:01 * hackage IntFormats 0.1.0.0 - Convert integers in various bases to and from strings  https://hackage.haskell.org/package/IntFormats-0.1.0.0 (LyraSolomon)
12:47:04 <sicklorkin> i guess it would be like an AdditiveGroup addV
12:48:20 <EvanR> Foo10Fields looks like an extensible record with an interpretation functor that contains a semigroup instance
12:49:25 <sicklorkin> EvanR: Num a => Foo10F a..a
12:49:30 <sicklorkin> a..j
12:49:42 <EvanR> ok, Num
12:49:54 <EvanR> though Semigroup kind of makes more sense here
12:50:07 <EvanR> and to get a semigroup for each thing you had a Num for youd do...
12:50:21 * sicklorkin hears a drum roll
12:50:50 <EvanR> newtype Additive a, instance Num a => Semigroup (Additive a) where...
12:50:59 <EvanR> then Additive is the interpretation functor
12:51:25 <sicklorkin> addV U1 U1 = U1... (K1 i a) = K1 (x ^+^ y)..
12:51:29 <sicklorkin> etc..?
12:54:16 <EvanR> (extensible records would be bypassing Generics here)
12:55:29 <sicklorkin> EvanR: Okay I got it.. thanks for ur help
13:21:16 <AWizzArd> Does someone have experience with GC latency in apps that have many gigabytes of live data?
13:22:24 <Lycurgus> no but I have advice: don't keep the date in program space
13:22:39 <Lycurgus> i.e the place where gc latency matters
13:24:01 <AWizzArd> If I wanted to do manual memory management, could I use a huge byte array, say 20 GB? It would count for the GC as just one single object, and I could serialize/deserialize into this array.
13:24:22 <EvanR> storable vector lives outside the usual heap, afaik
13:24:41 <EvanR> or you could use an in-memory database which is probably more convenient
13:25:39 <Lycurgus> *data
13:26:10 <AWizzArd> EvanR: in-mem DB as in external process, running on the same machine?
13:26:23 <EvanR> or in the same process
13:26:38 <EvanR> someone else had the same issue a few days ago and SQLite came up
13:45:20 <merijn> AWizzArd: Does the data get updated? Or is it read only?
13:46:17 <merijn> SQLite always comes up, because it's great :p
13:46:58 <merijn> AWizzArd: Also, what kinda objects?
13:56:06 <sicklorkin> 144
13:56:13 <sicklorkin> oops
13:56:58 <MarcelineVQ> 240 at least
14:03:32 * hackage path-io 1.6.0 - Interface to ‘directory’ package for users of ‘path’  https://hackage.haskell.org/package/path-io-1.6.0 (mrkkrp)
14:33:17 <oats> Is there no way to put multiple matches in a single case arm?
14:34:07 <oats> like `case x of pattern1, pattern2 -> y`
14:34:24 <merijn> oats: Sadly, no
14:34:46 <merijn> oats: best alternative is to move y into a where/let definition and reuse it for each pattern
14:35:06 <EvanR> depending on specifics there might be a way to write it with less code
14:35:06 <oats> ok, thanks :<
14:37:27 <oats> http://ix.io/1Ys9/hs
14:39:16 <merijn> That's just long enough to be annoying and just short enough that all alternatives almost cost more boilerplate than they save :p
14:39:28 <MarcelineVQ> ... = continue . (`turn`g) $ case ... of ... -> North; ... -> South; ...
14:40:11 <infinisil> Wasn't there some ghc proposal for multiple matches?
14:40:13 <oats> MarcelineVQ: that's about what I figured :P
14:40:19 <oats> er, * merijn 
14:40:33 <MarcelineVQ> inimino: or patterns
14:40:42 <MarcelineVQ> or-patterns
14:42:21 <boxscape> the proposal for or patterns is here https://github.com/ghc-proposals/ghc-proposals/pull/43
14:42:48 <boxscape> the conclusion was "I don't have time and motivation to work on this project anymore, so closing."
14:43:21 <boxscape> there's some package on hackage that allows or patterns with TH, IIRC
14:43:49 <merijn> TH breaks like 90% of tools and slows down compilation significantly, though
14:46:17 <boxscape> also, not quite the same thing, but sometimes you can do what you would have done with or patterns by writing a case like `x | x `elem` [case1, case2`
14:46:45 <boxscape> ]
14:47:41 <infinisil> boxscape: Ah nice
14:47:47 <infinisil> (Or not nice)
14:48:03 <boxscape> well, at least it wasn't rejected, I guess
14:48:06 <MarcelineVQ> a person can just tuple to match two things ((VtyEvent (V.EvKey key), V.KDown) at once but it's still noisy
14:48:49 <MarcelineVQ> "<merijn> ... alternatives almost cost more boilerplate than they save :p" involves solutions like that
14:50:14 <MarcelineVQ> er, I'm not sure what I was thinking just there with that exact example,hopefully the idea gets across even if that one isn't correct
15:22:53 <sshine> in Haskell, undefined :: a -> b.
15:24:18 <heatsink> undefined :: a
15:30:19 <sshine> it was a pun on Javascript.
15:31:08 <jackdk> JS: undefined is not a function. HS: undefined can be whatever you want it to be.
15:31:36 <EvanR> IS: somewhere in between
15:50:26 <boxscape> % :k forall a b . (a => b ~ b) => ()
15:50:27 <yahb> boxscape: forall a b . (a => b ~ b) => () :: *
15:50:36 <boxscape> hm, this doesn't typecheck in 8.8.1
15:50:39 <boxscape> well, sort of
15:50:50 <boxscape> you can have undefined of that type, but it doesn't with :k
15:54:40 <dansho> how do i get a term-level Integer from a Nat?
15:54:53 <pikajude> :t natVal
15:54:55 <lambdabot> error: Variable not in scope: natVal
15:55:02 <boxscape> % :t natVal
15:55:02 <yahb> boxscape: ; <interactive>:1:1: error: Variable not in scope: natVal
15:55:15 <boxscape> % :t GHC.TypeLits.natVal
15:55:16 <yahb> boxscape: GHC.TypeNats.KnownNat n => proxy n -> Integer
15:55:56 <boxscape> % :t GHC.TypeLits.natVal' -- or this, depending on which kind of proxy you prefer
15:55:56 <yahb> boxscape: GHC.TypeNats.KnownNat n => Proxy# n -> Integer
15:56:12 <dansho> well, how do i get a proxy though? i only have a type Dimension :: Nat
15:56:24 <boxscape> % :t GHC.Exts.proxy#
15:56:24 <yahb> boxscape: forall k0 (a :: k0). Proxy# a
15:56:31 <boxscape> that's how
15:56:35 <merijn> You don't even need a proxy
15:56:58 <merijn> In the "proxy n" one proxy is a type variable
15:57:10 <merijn> So you can use whatever type you've got lying around
15:57:29 <boxscape> > undefined :: proxy n
15:57:31 <lambdabot>  error:
15:57:31 <lambdabot>      • Ambiguous type variables ‘proxy0’,
15:57:31 <lambdabot>                                 ‘n0’ arising from a use of ‘show_M87842422239...
15:57:32 * hackage fast-arithmetic 0.6.4.3 - Fast functions on integers.  https://hackage.haskell.org/package/fast-arithmetic-0.6.4.3 (vmchale)
15:57:33 <boxscape> meh
15:57:54 <jle`> boxscape: in order to Show anything you need a concrete type
15:58:00 <boxscape> yeah that makes sense
15:58:02 <jle`> > undefined :: q r
15:58:04 <lambdabot>  error:
15:58:04 <lambdabot>      • Ambiguous type variables ‘q0’,
15:58:04 <lambdabot>                                 ‘r0’ arising from a use of ‘show_M87701564919...
15:58:18 <jle`> > undefined :: [Int]
15:58:20 <lambdabot>  *Exception: Prelude.undefined
15:58:25 <boxscape> it's just a bit counterintuitive with undefined because you're gonna get the same showed result no matter what type you give it :P
15:58:25 <jle`> that one at least typechecks :)
15:58:47 <jle`> boxscape: yeah, that's where extended defaulting is supposed to come in
15:58:54 <jle`> but it's very ad-hoc
15:58:57 <jle`> > show []
15:58:58 <lambdabot>  "[]"
15:59:10 <jle`> extended defaulting allows that to typecheck even though it really shouldn't
15:59:20 <boxscape> right
15:59:30 <jle`> ...or maybe that's just normal defaulting
16:00:01 <boxscape> % :set -XNoExtendedDefaultRules 
16:00:01 <yahb> boxscape: 
16:00:03 <boxscape> % []
16:00:03 <yahb> boxscape: ; <interactive>:107:1: error:; * Ambiguous type variable `a0' arising from a use of `print'; prevents the constraint `(Show a0)' from being solved.; Probable fix: use a type annotation to specify what `a0' should be.; These potential instances exist:; instance Show a => Show (ZipList a) -- Defined in `Control.Applicative'; instance Show NestedAtomically -- Defined in
16:00:08 <boxscape> % :set -XExtendedDefaultRules 
16:00:08 <yahb> boxscape: 
16:00:20 <boxscape> jle` nope, it's extended defaultign
16:00:51 <jle`> dansho: simplest way wouild just be to use (Proxy :: Proxy Dimension)
16:00:52 <dansho> not sure how to use proxy# https://hastebin.com/reliteyewo.haskell
16:01:00 <jle`> dansho: that uses Proxy for the proxy  variable
16:01:06 <jle`> i don't think proxy# would work, it's not the right kind
16:01:23 <jle`> dansho: or you can use -XTypeApplications and do natVal (Proxy @Dimension)
16:01:38 <jle`> % natVal (Proxy :: Proxy 3)
16:01:38 <yahb> jle`: ; <interactive>:109:1: error: Variable not in scope: natVal :: Proxy 3 -> t
16:01:40 <boxscape> dansho if you do end up wanting to use proxy# you need to enable the MagicHash extension
16:01:47 <jle`> % import GHC.TypeNats
16:01:47 <yahb> jle`: 
16:01:49 <boxscape> dansho otherwise it thinks # is an infix operaor
16:01:51 <jle`> % natVal (Proxy :: Proxy 3)
16:01:51 <yahb> jle`: 3
16:01:58 <jle`> % natVal (Proxy @3)
16:01:59 <yahb> jle`: 3
16:02:03 <boxscape> % natVal' (proxy# :: Proxy# 3)
16:02:03 <yahb> boxscape: 3
16:02:46 <jle`> dansho: note that it doesn't matter if you use Proxy or any other concrete data type, what's important is the type parameter
16:03:02 <jle`> dansho: read the type signature as `natVal :: f n -> Natural`, maybe
16:03:12 <jle`> using a word like proxy there makes it seem more complicated than it actually is
16:03:26 <jle`> what's important isn't the 'f' you use, it's the n; natVal :: KnownNat n => f n -> Natural
16:03:28 <dansho> thanks, that worked
16:03:58 <jle`> remember that lowercase identifiers in type signatures are just type variables
16:04:52 <pikajude> :t Left () :: Either () 3
16:04:53 <lambdabot> error:
16:04:53 <lambdabot>     • Expected a type, but ‘3’ has kind ‘GHC.Types.Nat’
16:04:53 <lambdabot>     • In the second argument of ‘Either’, namely ‘3’
16:04:57 <pikajude> oh yeah
16:05:20 <jle`> :t Tagged () :: Tagged () 3
16:05:21 <lambdabot> error:
16:05:21 <lambdabot>     Not in scope: type constructor or class ‘Tagged’
16:06:00 <jle`> :t Tagged () :: Tagged () 3
16:06:01 <lambdabot> error:
16:06:01 <lambdabot>     Not in scope: type constructor or class ‘Tagged’
16:06:13 <jle`> % :t Tagged () :: Tagged () 3
16:06:14 <yahb> jle`: ; <interactive>:1:24: error:; * Expected a type, but `3' has kind `Nat'; * In the second argument of `Tagged', namely `3'; In an expression type signature: Tagged () 3; In the expression: Tagged () :: Tagged () 3
16:06:23 <jle`> huh, that feels weird
16:06:27 <jle`> oh maybe i'm thinking about Const
16:06:47 <jle`> % :t Const () :: Const () 3
16:06:47 <yahb> jle`: Const () 3
16:06:49 <boxscape> % :t Tagged () :: Tagged 3 ()
16:06:49 <yahb> boxscape: Tagged 3 ()
16:07:01 <jle`> yeah, Const would work here but Tagged wouldn't
16:07:14 <pikajude> so can Nat be any positive integer
16:07:15 <pikajude> that's kinda neat
16:07:26 <jle`> it can even be zero :)
16:07:37 <pikajude> what if it's like, 1e10000000
16:07:42 <pikajude> do you run out of memory at that point
16:08:12 <boxscape> that doesn't seem like it should take more than 10 megabytes of memory
16:08:15 <jle`> i believe underlyingly it's implemented using Natural/Integer
16:08:26 <boxscape> oh yeah, that, too
16:08:27 <pikajude> what if it's running on a microcontroller
16:08:39 <jle`> in that case it would also probably be implemented using Natural/Integer
16:08:54 <pikajude> ok well that makes sense
16:09:05 <jle`> well, the actual "value" of it only comes up in a few situations
16:09:07 <boxscape> still, you can of course have Integers that are larger than the available memory. But it's a significantly larger number
16:09:25 <jle`> because of type erasure, a lot of times it doesn't exist at all during runtime
16:09:36 <boxscape> % 651561e56156156 :: Integer
16:09:41 <yahb> boxscape: ; <interactive>:121:1: error:; * No instance for (Fractional Integer) arising from the literal `651561e56156156'; * In the expression: 651561e56156156 :: Integer; In an equation for `it': it = 651561e56156156 :: Integer
16:09:48 <boxscape> missing the extension :(
16:09:51 <boxscape> I don't remember the name
16:10:06 <jle`> but a signature like myFunction :: KnownNat n => Blah -> Blah -> Bah is implemented at run-time as essentailly myFunction :: Natural -> Blah -> Blah -> Blah
16:10:39 <boxscape> % :set -XNumDecimals
16:10:39 <yahb> boxscape: 
16:10:40 <jle`> at the type-level, the value sometimes matters during compile-time. it matters for some type family/type class resolution, and also some situations with unifications
16:11:09 <boxscape> % 651561e56156156 :: Integer
16:11:10 <jle`> for example GHC is able to unify (3 + 4) with 7. so there's some memory usage going on at compiletime
16:11:14 <yahb> boxscape: [Timed out]
16:11:57 <jle`> % [Proxy @(3 + 4), Proxy @(2 + 5), Proxy @(1+6), Proxy @(0+7]
16:11:58 <yahb> jle`: ; <interactive>:1:59: error: parse error on input `]'
16:12:05 <jle`> % [Proxy @(3 + 4), Proxy @(2 + 5), Proxy @(1+6), Proxy @(0+7)]
16:12:05 <yahb> jle`: ; <interactive>:2:12: error: Not in scope: type constructor or class `+'; <interactive>:2:28: error: Not in scope: type constructor or class `+'; <interactive>:2:43: error: Not in scope: type constructor or class `+'; <interactive>:2:57: error: Not in scope: type constructor or class `+'
16:12:31 <jle`> % [Proxy @(3 + 4), Proxy @(2 + 5), Proxy @(1+6), Proxy @(0+7)]
16:12:31 <yahb> jle`: [Proxy,Proxy,Proxy,Proxy]
16:12:43 <jle`> so ghc does have to do some arithmetic to typecheck that list
16:13:07 <jle`> presumably it could overflow memory if your integers are sufficiently large
16:13:57 <jle`> % :t Proxy (651561 * 10^56156156
16:13:57 <yahb> jle`: ; <interactive>:1:28: error: parse error (possibly incorrect indentation or mismatched brackets)
16:13:59 <jle`> % :t Proxy (651561 * 10^56156156)
16:14:00 <yahb> jle`: ; <interactive>:1:1: error:; * Couldn't match expected type `Integer -> t' with actual type `Proxy t0'; * The function `Proxy' is applied to one argument,; but its type `Proxy t0' has none; In the expression: Proxy (651561 * 10 ^ 56156156)
16:14:06 <jle`> % :t Proxy @(651561 * 10^56156156)
16:14:07 <yahb> jle`: ; <interactive>:1:9: error:; * Expected kind `* -> Nat -> Nat', but `651561' has kind `Nat'; * In the first argument of `(^)', namely `651561 * 10'; In the type `(651561 * 10 ^ 56156156)'; In the expression: Proxy @(651561 * 10 ^ 56156156)
16:14:44 <boxscape> % :set -XNoStarIsType
16:14:45 <yahb> boxscape: 
16:14:52 <boxscape> % :t Proxy @(651561 * 10^56156156)
16:14:53 <jle`> % :t Proxy @(651561 * 10^56156156)
16:14:54 <yahb> boxscape: Proxy*** Exception: heap overflow
16:14:57 <yahb> jle`: Proxy*** Exception: heap overflow
16:15:44 <jle`> interesting, Show starts doing its job before the Proxy is typechecked
16:16:25 <pikajude> that's showing the type, not the value
16:16:25 <boxscape> huh
16:16:33 <jle`> ah
16:16:33 <boxscape> % Proxy @(651561 * 10^56156156)
16:16:36 <yahb> boxscape: *** Exception: heap overflow
16:16:52 <jle`> that makes more sense
16:18:19 <pikajude> wait so 1e100000000 is actually fromRational (10000000... % 1)
16:18:25 <pikajude> hmmm
16:18:51 <boxscape> not with NumDecimals, right?
16:19:05 <pikajude> no
16:41:01 * hackage reflex-dom-retractable 0.1.0.0 - Routing and retractable back button for reflex-dom  https://hackage.haskell.org/package/reflex-dom-retractable-0.1.0.0 (NCrashed)
16:47:07 <EvanR> heh...
16:47:27 <EvanR> 1e100000000 eh
16:47:37 <pikajude> oh i see, so 123.456 is just fromRational (123456 % 1000)
16:47:39 <pikajude> thats quite clever actually
16:47:51 <EvanR> i think you'd need recursively run length encoded natural numbers
16:48:50 <EvanR> > 10**100000000 :: CReal
16:48:58 <lambdabot>  mueval-core: Time limit exceeded
16:49:13 <EvanR> > 10^100000000 :: Integer
16:49:22 <lambdabot>  mueval-core: Time limit exceeded
16:49:22 <lambdabot>  mueval: ExitFailure 1
16:49:56 <jle`> > 10^100000000 :: Int
16:49:58 <lambdabot>  0
16:50:01 <jle`> much better
16:50:51 <pikajude> i kinda like CReal for breakfast to be honest
16:52:49 <EvanR> is the Int calculation 0 because it lands directly on 2^64 at some point
16:53:01 <hpc> yes
16:53:16 <EvanR> lucky
16:53:20 <hpc> 10 has 2 as a factor
16:53:28 <hpc> and if my calculations are correct, 10000000 is larger than 64
16:53:36 <pikajude> double check
16:53:39 <pikajude> > 10000000 > 64
16:53:39 <EvanR> ah
16:53:41 <lambdabot>  True
16:53:44 <pikajude> thank god
16:53:50 <hpc> :D
16:54:06 <EvanR> > 10000000 - 64
16:54:08 <lambdabot>  9999936
16:54:21 <hpc> > 10 ^ 64 :: Int
16:54:23 <EvanR> 10^9999936 * 10^64
16:54:23 <lambdabot>  0
16:54:36 <hpc> > (10 ^ 65 :: Int, 10 ^ 63 :: Int)
16:54:38 <lambdabot>  (0,-9223372036854775808)
16:55:45 <EvanR> 10^64 = 2^64 5^64, got it
16:56:05 <jle`> > drop 63 . iterate (* 10) $ 1
16:56:07 <lambdabot>  [1000000000000000000000000000000000000000000000000000000000000000,1000000000...
16:56:12 <boxscape> > 5^64 :: Int
16:56:14 <lambdabot>  7942358959831785217
16:56:27 <jle`> > drop 63 . iterate (* 10) $ (1 :: Int)
16:56:28 <lambdabot>  [-9223372036854775808,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
16:56:51 <jle`> > drop 60 . iterate (* 10) $ (1 :: Int)
16:56:53 <lambdabot>  [1152921504606846976,-6917529027641081856,4611686018427387904,-9223372036854...
16:57:10 <jle`> if i were a cpu i would definitely feel some sort of relief at that point
16:57:37 <jle`> > drop 61 . iterate (* 10) $ (1 :: Int)
16:57:38 <lambdabot>  [-6917529027641081856,4611686018427387904,-9223372036854775808,0,0,0,0,0,0,0...
16:57:45 <EvanR> ok change it from 10 to 9
16:57:45 <jle`> if CPUs and ALUs could feel emotion
16:58:12 <EvanR> > 9^10000000
16:58:15 <lambdabot>  1242777118901561676313492794761354046962194659541146010562348259221141522424...
16:58:22 <EvanR> what
16:58:53 <EvanR> > 10^10000000
16:58:55 <jle`> defaults to Integer
16:58:56 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
16:59:12 <EvanR> i thought it mueval time limited exceeded
16:59:26 <jle`> how dare you understimate mueval
16:59:41 <EvanR> > 9^100000000
16:59:48 <lambdabot>  mueval-core: Time limit exceeded
16:59:50 <EvanR> > 9^100000000 :: Int
16:59:52 <lambdabot>  3864949847545407489
17:00:19 <EvanR> over 9^100000000thousand
17:00:55 <jle`> slow saturday in #haskell
17:01:10 * tabemann is busy hacking on his Forth implementation
17:02:27 <EvanR> i see if the base has no factor of two it can't possibly land on 2^64 ever
17:02:28 <pikajude> what happened to the first three?
17:32:01 * hackage net-mqtt 0.6.0.0 - An MQTT Protocol Implementation.  https://hackage.haskell.org/package/net-mqtt-0.6.0.0 (dustin)
17:51:53 <boxscape> on no I just wrote up a whole GHC issue just to realize right before hitting enter that the cause for the problem is a completely different bug from what I described :o
17:52:07 <boxscape> s/enter/submit
17:54:05 <AWizzArd> Can I compile a small .hs file into an .so lib and have some binary (also compiled by ghc) that loads this .so at runtime and calls functions in it? I.e. can I write a software/binary that can be load Haskell plugins?
17:54:18 * sshine understands free monads and goes up one level.
17:54:33 <sshine> AWizzArd, yes.
17:57:18 <AWizzArd> sshine: can I search functions via String in the .so and get a pointer to call it?
17:58:18 <sshine> AWizzArd, urm, I imagine that you can, but I don't know how.
18:00:08 <sshine> AWizzArd, https://stackoverflow.com/questions/34732/how-do-i-list-the-symbols-in-a-so-file
18:00:17 <sshine> AWizzArd, maybe there's a Haskell library for that as well.
18:02:32 * hackage matplotlib 0.7.5 - Bindings to Matplotlib; a Python plotting library  https://hackage.haskell.org/package/matplotlib-0.7.5 (AndreiBarbu)
18:03:06 <AWizzArd> For me it's already nice to know that there _is_ a way to load so-s and call functions in them.
18:23:01 * hackage language-ats 1.7.3.1 - Parser and pretty-printer for ATS.  https://hackage.haskell.org/package/language-ats-1.7.3.1 (vmchale)
18:44:38 <novum> why no work http://ix.io/1YsO  last line error "cannot bind type Person to Maybe Person"
18:45:25 <novum> Person is Maybe Person >:(
18:46:28 <pikajude> no it isn't
18:46:32 <pikajude> mama is Person not Maybe Person
18:46:59 <slack1256> You can "lift" a Person to `Maybe Person` with `pure`.
18:47:00 <novum> right. that's what it says. so, how do I do it?
18:47:16 <slack1256> > pure 8 :: Maybe Int
18:47:17 <lambdabot>  Just 8
18:48:07 <novum> I just did this and it worked. http://ix.io/1YsP I forgot about Just to "bring it into the monad"
18:48:19 <novum> I am noob. I don't know monads. I make monads for learning
18:48:43 <pikajude> you're not using the monad instance anywhere in that code though
18:49:18 <slack1256> Maybe making that distinction at this point is not helpful.
18:49:26 <pikajude> yea possibly
18:49:37 <pikajude> never too early a time for someone to learn that "Monad" =/= "a container" though
18:49:52 <novum> Maybe is a monad. I am getting this set up to practice using bind (>>=)
18:52:53 <crestfallen> https://termbin.com/iy89      hi I've been trying to get this construct to work in ghci. I'm assuming I need pure in the tuple of arguments there..or somewhere
18:53:45 <crestfallen> I'm not sure what that program is supposed to do
18:54:11 <heatsink> The program is supposed to do all combinations of the 3 inputs
18:54:22 <heatsink> f 3 2, f 4 2, g 3 2, g 4 2
18:54:27 <heatsink> and put all the results into a list
18:54:37 <crestfallen> right. what's my issue?
18:54:59 <crestfallen> I thought I'd stick pure in the arguments but that didn't do it
18:55:18 <heatsink> Just pass ((+), (*)) without pure, I think
18:55:42 <crestfallen> tried that. one moment pls
18:55:45 <pikajude> :t (<*>)
18:55:46 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
18:56:46 <heatsink> > [(+), (*)] <*> [1, 5] <*> [1, 5]
18:56:49 <lambdabot>  [2,6,6,10,1,5,5,25]
18:57:30 <slack1256> > :t (<*>)
18:57:31 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
18:57:42 <heatsink> For the list type, `pure x` is the same as `[x]`.  Since you have already put f and g in a list, you don't need pure.
18:59:19 <crestfallen> @let tt = (\(f,g) -> [f,g] <*> [2,2] <*> [3,4]) ((*),(+)) 
18:59:21 <lambdabot>  Defined.
18:59:26 <crestfallen> > tt
18:59:29 <lambdabot>  [6,8,6,8,5,6,5,6]
19:00:22 <crestfallen> thanks, weird. the hardest part of haskell for me is getting things to show or print, and IO   
19:00:55 <pikajude> within programs you can use Debug.Trace which is quite nice
19:01:06 <pikajude> it's like a very budget debugger
19:01:21 <novum> Did I do that properly?  baby = Person "Baby" "Person" (Just mama) (Just papa)  ?
19:01:30 <sshine> has anyone got a neat way to make TravisCI (or CircleCI) to display an icon on your GitHub that says how many of your tests that succeeded? my project is still very early stage, so I have a whole bunch of tests that fail, and I'd like to automate keeping track of how finished it is in terms of how many tests it fails.
19:01:39 <novum> is that the way one would construct such an instance?
19:02:24 <pikajude> loosk good
19:02:59 <novum> I don't quite understand why you need `Just`
19:03:02 <crestfallen> thanks pikajude. problem with Trace is .. how to know where to place showTrace within the program. never understood it
19:03:23 <slack1256> On the expression you want to print.
19:03:35 <pikajude> it's executed whenever thing is evaluated
19:04:01 * hackage ghcjs-base-stub 0.3.0.2 - Allow GHCJS projects to compile under GHC and develop using intero.  https://hackage.haskell.org/package/ghcjs-base-stub-0.3.0.2 (louispan)
19:04:01 <c_wraith> @quote oasis
19:04:02 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
19:04:02 * hackage language-ats 1.7.4.0, ats-pkg 3.2.6.1, ats-format 0.2.0.31 (vmchale)
19:04:28 <pikajude> @src Maybe
19:04:28 <lambdabot> data Maybe a = Nothing | Just a
19:04:32 <pikajude> that's why
19:04:41 <pikajude> if foo :: Person, Just foo :: Maybe Person
19:05:09 <novum> yes I am familiar with the fact that Just is a value constructor for Maybe. I guess that is the only reason you need to use Just. To make it a Maybe Person. Is that all there is to it?
19:05:46 <pikajude> yes
19:05:48 <crestfallen> ok thanks. maybe there's a tutorial on it somewhere
19:05:51 <slack1256> let repeated = trace "Look at me, I am being executed" 2 in repeated + repeated
19:05:52 <EvanR> you need that wrapper to know it's not Nothing
19:06:38 <slack1256> It is good for debugging, but as a side effect it weird. That expression could be evaluated once or twice depending on what ghc decides to do.
19:06:43 <novum> that last statement doesn't make much sense to me because a Person instance is clearly not Nothing
19:06:56 <EvanR> the field is not type Person though
19:07:05 <slack1256> But in debugging you are interested that at least prints once, so it works.
19:07:06 <EvanR> if it were you won't need the wrapper
19:07:08 <novum> yes. I see this now
19:07:11 <EvanR> and it could not be Nothing
19:07:30 <EvanR> Person can't be Nothing
19:07:51 <EvanR> one of the phenomena in haskell that you don't often get in other languages
19:09:11 <EvanR> if you have a Person then you do not have Nothing, null pointer, null value, nil, a value of the wrong type entirely, or monkeys flying out of your nose
19:10:04 <EvanR> or in PHP, FALSE
19:10:17 * slack1256 something, something, undefined, something...
19:10:19 <slack1256> :-)
19:10:43 <EvanR> at least undefined doesn't cause monkeys to fly out of your nose. In C this is actually a possible result of undefined
19:10:51 <EvanR> behavior
19:11:05 <c_wraith> I'm not sure it's possible.  But if it was possible, it would be valid.
19:11:37 <EvanR> cause your floppy drive to spin itself to smithereens
19:11:59 <pikajude> has anyone actually written a C compiler that does rm -rf / whenever it encounters undefined behavior
19:12:13 <novum> there is a shell similar to that
19:12:22 <slack1256> There was a version of ghc that deleted your file when it encountered type errors.
19:13:20 <pikajude> well that's not explicitly in the standard though
19:13:20 <novum> ..bashrc.. ghc(){ cp $1 $1.bak; ghc $1 } # :o
19:13:37 <slack1256> I think this was before the standard.
19:14:19 <EvanR> the standard now says it won't delete your file?
19:14:29 <EvanR> if not fair game
19:14:49 <slack1256> I need to find that slide by SPJ, it was hilarious! lol
19:15:07 <novum> logical. Why not just rewrite / with windows xp?
19:15:21 <novum> The standard does not say it does not do that, so
19:15:27 <EvanR> floppy drives, windows xp...
19:16:01 <EvanR> haskell is UP 2 DATE
19:20:14 <crestfallen> pikajude, thing is, when I use ((pure (*)),(pure (+))) , I get an error. so it's not just superfluous, right?
19:20:27 <pikajude> well because that's a tuple
19:20:36 <pikajude> :t (pure (*), pure (+))
19:20:37 <lambdabot> (Applicative f1, Applicative f2, Num a1, Num a2) => (f1 (a1 -> a1 -> a1), f2 (a2 -> a2 -> a2))
19:20:41 <pikajude> :t [(*), (+)]
19:20:43 <lambdabot> Num a => [a -> a -> a]
19:20:48 <pikajude> completely different
19:21:50 <crestfallen> so the pattern match doesn't doesn't convert that, as in \(f,g) -> [f,g] ... 
19:22:02 <pikajude> oh, where is that
19:22:34 <crestfallen> @let tt = (\(f,g) -> [f,g] <*> [2,2] <*> [3,4] ) ((*), (+))
19:22:35 <lambdabot>  .L.hs:162:1: error:
19:22:35 <lambdabot>      Multiple declarations of ‘tt’
19:22:35 <lambdabot>      Declared at: .L.hs:161:1
19:22:44 <crestfallen> @let ttt = (\(f,g) -> [f,g] <*> [2,2] <*> [3,4] ) ((*), (+))
19:22:45 <lambdabot>  Defined.
19:22:49 <crestfallen> ttt
19:23:01 <crestfallen> > ttt
19:23:03 <lambdabot>  [6,8,6,8,5,6,5,6]
19:23:17 <pikajude> well if you do the substitution yourself, you'll see that it works out to [pure (+), pure (*)] and you just want [(+), (*)]
19:26:01 <crestfallen> so it's the pattern match itself that lets you not need pure
19:26:34 <pikajude> i'm not sure i understand
19:27:02 <pikajude> what are you using pure for?
19:27:08 <crestfallen> no prob, I only had a hunch that it would work either with or without pure
19:27:34 <pikajude> no, any function taking a specific type should never work "with or without" pure
19:27:56 <crestfallen> copy that, thanks
19:28:37 <crestfallen> I was using pure pikajude , because...
19:30:07 <crestfallen> my book says a common pattern is pure f <*> x1 <*> x2 <*> ... xn
19:30:56 <pikajude> in my experience, it's more common to see f <$> x1 <*> x2 ...
19:31:00 <pikajude> :t (<$>)
19:31:01 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:31:03 <pikajude> :t (<*>)
19:31:04 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:31:08 <pikajude> do you see the difference?
19:31:35 <pikajude> `f <$> a` is equivalent to `pure f <*> a`
19:31:59 <pikajude> pure doesn't do anything magical that "makes" <*> work
19:32:41 <pikajude> :t (<*>) `asAppliedTo` [(+), (*)]
19:32:42 <lambdabot> Num a => [a -> a -> a] -> [a] -> [a -> a]
19:33:16 <pikajude> this works because `[(+), (*)]` matches the type `Applicative f => f (a -> b) -> f a -> f b`
19:33:25 <pikajude> in that case, f = the list type []
19:34:15 <crestfallen> pure puts a pure function f into a context, so that it can be applied to the 'a' in f a ,etc.
19:34:46 <pikajude> ya
19:34:57 <crestfallen> so it's f (a->b) -> f a -> f b
19:35:14 <crestfallen> thanks alot it was just the tuple that was throwing me off
19:35:25 <pikajude> tuples can be tricky
19:35:57 <sshine> I think sums are more tricky.
19:36:15 <pikajude> anything can be tricky if you try hard enough
19:36:38 <slack1256> SPJ said that non-strict-semantics lead to unrestricted beta substitution. I didn't know there was a restriction with strict semantics, is this documented somewhere?
19:36:47 <sshine> parts of proofs that involve disjunction are always more elaborate than proofs that involve conjunction, I've lately experienced.
19:37:16 <crestfallen> no it taught me something about pattern matching, that is a sort I never came across \(f,g) -> [f,g]
19:37:30 <pikajude> pattern matching is great
19:38:07 <crestfallen> I finally met someone in person who is a haskell badass, so I'm feeling great in any case!
19:38:39 <sshine> beauty is in the eye of the beholder.
19:38:58 <crestfallen> meaning..
19:39:34 <sshine> meaning I'd feel great too for recognizing someone who is good at something, because it says something good about my capacity to recognize it. :)
19:40:06 <pikajude> oh, i thought it was a reference to pattern matching
19:40:44 <crestfallen> I'll just say it was an absolute serendipity
19:41:02 <slack1256> Who did you meet?
19:41:43 <crestfallen> slack1256, if I may to decline to answer..
19:42:29 <slack1256> OK, continue flexing then :-)
19:42:31 <novum> awkwaaaaard
19:43:00 <crestfallen> sorry novum, I should have kept silent. I work in a major university town
19:44:42 <sshine> slack1256, I don't actually know what what you said means, but googling around a bit, it looks like "unrestricted" means that "any term may be substituted for any variable" (https://www.cs.ox.ac.uk/andrew.ker/docs/lambdacalculus-lecture-notes-ht2009.pdf ) -- I suppose you can't substitute freely under strict semantics because evaluation order necessitates evaluation before substitution in some nested cases
19:44:48 <sshine> ?
19:48:54 <sshine> slack1256, I wonder if what he says should not appear naturally as part of the substitution semantics of a strictly typed lambda calculus, if one goes to look for one such thing.
19:49:34 <sshine> s/typed/evaluated/
19:49:57 <slack1256> I still don't know how `evaluation semantics` interact with lambda calculus, which in my mind only deals with substitutions.
19:50:10 <slack1256> But it can be what you say, it maybe doesn't appears naturally.
19:50:15 <crestfallen> the above function wasn't working in ghci without a let statement, now I swear it is. maddening**
19:50:44 <crestfallen> > tt = (\(f,g) -> [f,g] <*> [2,2] <*> [3,4] ) ((*), (+))
19:50:46 <lambdabot>  <hint>:1:4: error:
19:50:46 <lambdabot>      parse error on input ‘=’
19:50:46 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
19:51:02 <monochrom> I think you can understand evaluation semantics as rules about substitutions. Or more accurate, rules about whether you can use beta reduction.
19:51:37 <slack1256> So, why do we need to restrict beta reduction on a strict setting?
19:51:44 <monochrom> Call-by-value (non-lazy) says that you can only plug in values. If your parameter isn't a value yet, eval until it is.
19:52:21 <monochrom> Call-by-name says that just go ahead plug in arbitrary expressions.
19:52:38 <crestfallen> normal vs applicative order, something I still don't fully get
19:53:14 <sshine> so f(x) = x*x, and f(g(x)) = g(x)*g(x) under non-strict, but you can't perform that substitution under strict, so restricted.
19:53:24 <crestfallen> I thought beta reduction was just a kind of sugar
19:53:40 <slack1256> monochrom: what is value on a strict setting? I guessing thunks aren't otherwise it would be the same in the lazy setting?
19:53:47 <monochrom> Call-by-name is almost lazy. It's missing sharing and it has more duplication.  (\x -> x+x) (4+5) -> (4+5)+(4+5) you get two independent copies of 4+5 now, you will do redundant work.
19:54:23 <slack1256> oh so values are whatever is expressed on a normal form!
19:54:34 <EvanR> so re-strict-ed is a bit redundant
19:54:43 <monochrom> OK if you have lambda calculus alone without other data types (numbers, booleans, strings, lists...) then a value is a free variable or a lambda.
19:54:57 <slack1256> yes yes.
19:55:18 <slack1256> I mean you can "represent" numbers, booleans, list with lambdas anyways.
19:55:34 <slack1256> OK now is clearer monochrom.
19:55:35 <EvanR> all you need is lambda
19:55:37 <crestfallen> monochrom thanks for schooling me the other day : experimentation in ghci is the best way to learn, since its true scientific method
19:55:43 <sshine> slack1256, nice question. I learned something that I didn't know I didn't know. :)
19:55:45 <monochrom> Suppose you have (\x -> x) ((\y -> y) z).
19:56:01 <slack1256> sshine: :-)
19:56:10 <monochrom> Call-by-value says -> (\x -> x) z -> z
19:56:18 <sshine> crestfallen, :m + Data.Scientific -- you can make it even more so!
19:56:23 <monochrom> Call-by-name says -> (\y -> y) z -> z
19:57:03 <crestfallen> sshine, looks like homework!
19:57:28 <sshine> crestfallen, it was just a pun.
19:57:52 <slack1256> In effect, it seems that call-by-name extends the notion of "values" to include "suspended expression with a normal form".
19:58:00 <crestfallen> oh!
19:58:21 <crestfallen> Thanks all
19:58:23 <sshine> crestfallen, "the true scientific method in GHCi", I thought you must surely need the Scientific data type. ok, I spoiled it.
19:58:28 <slack1256> so values = free variables | lambdas | "expresions with a normal form".
19:59:02 <crestfallen> ghci is a good place for unabashed crying.
19:59:17 <divVerent> I misread that as unabashed currying first
19:59:17 <monochrom> I wouldn't do that because you would be tossed when you see "use call-by-name to eval this until you get a value".
20:00:30 <EvanR> i am calling a value an expression that is a lambda or a constructor
20:00:35 <EvanR> in my project
20:01:59 <slack1256> What are you working on?
20:03:29 <EvanR> it's lazy lambda calculus with recursive let
20:03:37 <EvanR> and an interpreter in C
20:03:59 <slack1256> Nice
20:04:16 <slack1256> Good for embeeding?
20:04:24 <EvanR> didn't even think of that
20:04:43 <EvanR> if libjit works on the embedded platform then yeah
20:07:07 <slack1256> Oh, I meant embedding as "onto another program" not a embedded platform.
20:08:31 <EvanR> like lua... didn't think of that either :)
20:09:28 <slack1256> Yeah like lua. Currently where I work we want to extend a core product with scripting options but I've looked for a "pure FP scripting lang".
20:10:30 <dsal> Haskell would be great for that.  You could find a lot of errors in your script at compile time.
20:11:10 <dsal> I used guile a while back.
20:11:25 <slack1256> Yeah but it is a tough sell, it is to foreign and big. The typechecking introduces extra delays.
20:12:53 <dsal> Typechecking just moves the delays up front.
20:14:01 <EvanR> somehow "scripting" with a type system sounds funny 
20:14:38 <EvanR> also yeah "no type checking" = "move fast break things"
20:15:12 <EvanR> better to ask forgiveness than permission to foreign and big
20:15:28 <slack1256> heh, good motto.
20:15:44 <dsal> I've been working on a project at work in Haskell just because I don't know how to do it otherwise.
20:16:01 <EvanR> "i just think in haskell"
20:16:11 <dsal> I'm getting there.  I don't think in monad transformers, though.
20:16:13 <slack1256> I actually do that when the algorithms don't work.
20:16:21 <EvanR> haha
20:16:50 <slack1256> Take the implementation I know it is failing, translate it to haskell, use ghci to step through and find the error.
20:17:19 <dsal> I've mainly been doing the thing where I don't think very hard, but write good QC properties and have it continually call me stupid.  Turns out, one of my ideas was impossible...  I could've known that if I thought harder, but I adapted around the things I could actually get QC to pass.
20:17:20 <EvanR> ok now make that translator a program
20:17:41 <dsal> TLA+?
20:17:54 <monochrom> w00t TLA+
20:18:16 <dsal> I used to use gnu tla, so TLA+ is a natural transition for me.
20:18:18 <heatsink> QC=quality control?
20:18:24 <heatsink> quickcheck?
20:18:35 <slack1256> quickcheck I guess.
20:18:49 <dsal> @check \x -> x > (3::Int)
20:18:51 <lambdabot>  *** Failed! Falsifiable (after 1 test):
20:18:51 <lambdabot>  0
20:19:02 <sshine> at work we have three things that people call "QA". gotta love corporate acronyms.
20:19:27 <dsal> I've outsourced most of my thinking to QuickCheck lately.
20:19:42 <monochrom> QA76.8 is computer science ^_^
20:19:49 <slack1256> dsal: "I used to use gnu tla, so TLA+ is a natural transition for me." not sure if serious...
20:19:53 <slack1256> lol
20:19:54 <sshine> dsal, @check is pretty neat.
20:20:41 <dsal> We program in go a lot.  It's so painful there... At least the stdlib implementation is incredibly bad.  But it's still better than thinking up all the cases.  I had a coworker send me a couple pages of test for a single bug he wrote (along with the fix).  I wrote a QC test for it in about the same amount of code and sent it back.  It failed after his bug fix.
20:20:45 <dsal> He never did explain why...
20:20:52 <heatsink> It feels to me like as the data structures get more complex, I still have to think more carefully in order for quickcheck to have a chance of generating the important corner cases.
20:21:28 <dsal> sshine: QC as a whole is great.  I've got a lot better at writing shrinks now, so most of the failures I got in this thing were like, tiny numbers that made it really obvious what I was doing wrong.
20:21:54 <sshine> dsal, I've been getting into Hedgehog lately. automatic shrinking and all.
20:22:03 <dsal> I've still not tried hedgehog.
20:22:12 <slack1256> Does go have a QC-like library?
20:22:19 <sshine> slack1256, probably.
20:22:39 <dsal> slack1256: https://godoc.org/testing/quick
20:22:51 <dsal> There are better third-party ones, for sure.  That's been frozen since the beginning of time.
20:23:36 <dsal> No replay, no shrinkage.  And, being go, the output isn't very useful.  It prints out the state of the mutated stuff you mutated it all into when a test fails.  Like, here's the soup you meant to make into a cake.  Something went wrong.
20:24:48 <dsal> The stuff I was doing was quantizing time spans into windowed count things.  I was using counterexample to show me the input, shrunk computed output and why it was wrong.  In many cases, it was a super obvious off-by-one or oh-yeah-I-can't-even-do-this error.
20:29:33 <sshine> dsal, nice. I recently received a PR containing a Hedgehog generator for my pet project that found two kinds of bugs in a Megaparsec parser of numbers. that was quite enjoyable.
20:30:07 <sshine> so "1." and "-.1" were basically not handled correctly. :)
20:30:19 <slack1256> Coool
20:31:27 <sshine> the generator itself contained a bug where it would produce "1e+-1", but at least you have two programs that are duals, so the parser failing sort of found that one.
20:31:59 <dsal> I'll have to try it out someday.  I ended up publishing Arbitrary instances for all my MQTT types since I used that to write tests for the C version I was working on.
20:32:09 <sshine> dsal, MQTT?
20:32:24 <dsal> http://hackage.haskell.org/package/net-mqtt
20:32:27 <dsal> IoT stuff.
20:33:16 <slack1256> https://youtu.be/06x8Wf2r2Mc?t=2383 here is SPJ speaking of a version of GHC that deleted your program when it found a type error LOL.
20:34:47 <dsal> I keep building stuff into this.  I wrote a N-way bridge because the built-in stuff mosquitto ships with is not very useful if you use any advanced features.  Mine does all the things I need (currently no translations).  I just added websocket support today, so I tested publishing a message on my laptop (localhost), bridging via websockets to a public server and picking that up via the lower-level protocol.
20:35:04 <EvanR> i think they should have made that a flag instead of fixing it
20:35:24 <heatsink> I thought SPJ had stopped using comic sans in his presentations
20:35:42 <heatsink> Oh, thiat was a re-uploaded old presentation 
20:35:50 <dsal> heh.  I forgot my irc client displays "comic sans" in comic sans.
20:36:03 <heatsink> interesting feature
20:36:11 <EvanR> /nick comic sans
20:36:22 <slack1256> It's an old presentation. But now in my mind, everytime I see comic sans I think of proffesionalism & spj.
20:36:39 <dsal> https://usercontent.irccloud-cdn.com/file/dQf7iB9f/comic%20sans
20:36:56 <slack1256> I think I once gave a sighly higher grade to a student because of it, lol.
20:37:56 <dsal> I keep failing to write my influxdb -> mqtt gateway.  I accomplished a lot today, so I guess that's OK.
20:38:31 * hackage language-ats 1.7.4.1 - Parser and pretty-printer for ATS.  https://hackage.haskell.org/package/language-ats-1.7.4.1 (vmchale)
20:45:47 <sshine> slack1256, I saw the SPJ video you linked to from the point in time you linked to, and I couldn't help but think: three men who are more than one decade older than me are standing on a podium and musing about lambdabot's @pl command. this reminds me of when I first heard a woman say "lol" in real life.
20:48:39 <slack1256> Haha
20:49:03 <slack1256> I like how atleast some people on that conference actually used @pl 
20:49:52 <slack1256> lambdabot must be old.
20:50:00 <dsal> I've learned useful stuff from @pl
20:50:31 <heatsink> sshine: It is weird to think that some people make money by playing video games that I used to play as a kid
20:50:48 <koz_> @pl is a useful tool
20:50:48 <lambdabot> is a useful tool
20:50:55 <koz_> (also agreed)
20:51:36 <c010r> hi. can anyone explain to me in a brief way what POSIX is? (ive had several ppl ATTEMPT to do so, but the explaination bounced off my thick noob forehead)
20:51:45 <c010r> explainlikeimfive
20:51:46 <c010r> pls
20:51:59 <slack1256> It can also show dominance
20:51:59 <heatsink> POSIX is a standard API for operating system features, such as accessing files
20:52:06 <slack1256> @slap slack1256
20:52:06 * lambdabot decomposes slack1256 into several parts using the Banach-Tarski theorem and reassembles them to get two copies of slack1256!
20:52:14 <slack1256> God dammit
20:52:44 <heatsink> The idea is that if your program is written using the POSIX API, then it can run on any POSIX-compliant operating system
20:53:30 <slack1256> c010r: The wikipedia "history" part gives a good background. To understand why posix was neccesary (the balkanization of unix) you need to understand that.
20:53:34 <slack1256> Good luck.
20:54:00 <c010r> so which things are defined by the standard? bash scripts? ascii text file formats? the pretty menu on upper right hand of a Xwindow (min, max, and close buttons)?
20:54:17 <slack1256> Read the standard
20:54:18 <c010r> just silly example quetions to indicate my ignorance
20:54:36 <heatsink> I believe POSIX just defines a C API and loosely defines what the API functions should do
20:54:47 <c010r> i read the wikip entry on it,leaving me more confused
20:54:55 <c010r> its over my head
20:55:06 <c010r> but i hear ppl use the term constantly
20:55:24 <dsal> In what context?  File systems?
20:56:15 <c010r> um... mainly when im researching about shell commands (im an absolute/semi noob to linux.... 2.5 weeks since installing it)
20:56:27 <dsal> My windows don't have min, max, or close buttons.
20:56:39 <c010r> as i said, just silly example quetions to indicate my ignorance
20:57:09 <dsal> "bash scripts" make me sad.  So much nonstandard stuff.
20:57:34 <c010r> what causes bash scripts to be non stnadard?
20:57:50 <dsal> Bash does.
20:58:00 <dsal> It's the c-with-classes of shells.
20:58:03 <c010r> oh... so there was already a "standard" in place before bash existed?
20:58:22 <dsal> Yeah. sh is standard.  Bash extends it
20:58:30 <c010r> i c...
20:58:51 <dsal> I've used tons of systems that didn't have /bin/bash, but all had /bin/sh
20:59:15 <sshine> POSIX sh
20:59:18 <c010r> so... when u say standard, do u mean..... a standard way of SCRIPTING at the command prompt? standard INERNAL commands? standard external commands? standard syntax?
20:59:32 <dsal> Anyway, it's a bit off topic here unless your working on a POSIX monad.
20:59:37 <c010r> ok.
20:59:51 <c010r> i have not yet made any batch files on linux yet.
20:59:55 <dsal> Ugh, my phone spelled the wrong you're. I should be kicked
21:00:00 <mozzarella> posix monad *chuckles*
21:00:23 <sshine> whenever I google how to do something in shell script, I always have to add "posix sh -bash" to my query.
21:00:34 <ion> sh is Turing complete, therefore you can implement monads in sh. This is left as en exercise to the reader.
21:00:37 <slack1256> A monad were composition is trademark infrigment.
21:00:55 <c010r> just for clarification, when linux ppl talk about writing "scripts" and "scripting", are they talking about making a FILE of some sort?
21:01:07 <c010r> (like batch files in windows)?
21:01:19 <dsal> Heh, /bin/true on my old Solaris boxes was a huge shell script with 0 lines of code
21:01:38 <sshine> c010r, yes, either a script, like a .bat file, except it might be a .sh file or a .pl file, or some other scripting language, or it may be an expression which you can stick into a one-liner
21:02:08 <heatsink> dsal: so, it didn't support --help and --version?  How janky
21:02:09 <dsal> You can script stack
21:02:43 <c010r> ok.... so most shells use a unified scripting language then? 
21:02:58 <c010r> but bash "bucks the trend"?
21:03:28 <dsal> c010r: there are countless ways to script and an exception to anything you might consider a rule
21:04:16 <c010r> cuz i DO know that there are many different shells available on linux systems. although i dont understand why (im from windows, where there is only one)
21:04:16 <heatsink> c010r: Most unix-like operating systems would come with shells implementing the same features
21:04:30 <sshine> c010r, most shells (bash, zsh, dash, and so on) have some common subset. the farther you go back, the smaller that subset becomes.
21:04:36 <ChaiTRex> c010r: In Windows, there are two: cmd and powershell.
21:04:38 <jle`> c010r: well, the 'why' is simple -- it's the same reason why you have more than one internet browser available
21:04:46 <jle`> c010r: anyone and their mother can just make their own
21:05:01 <jle`> as to why there is more than one popular one ... that's the real mystery :)
21:05:07 <sshine> c010r, but as long as you have a recent system, writing "sh" will work on *BSD and *N*X. :)
21:05:07 <c010r> im an ex winxp user. i dont remember powershell. might not be on winxp
21:05:11 <ChaiTRex> c010r: They also added bash through the Linux layer for Windows, whatever it's called.
21:05:17 <dsal> I used to live in tcsh... The bash of csh
21:05:25 <ChaiTRex> c010r: You had to download it for XP, I think.
21:05:27 <heatsink> SFU
21:05:44 <sshine> ChaiTRex, WSL (Windows Subsystem for Linux)?
21:05:50 <ChaiTRex> sshine: Yeah, that's it.
21:06:21 <heatsink> Well, there is also a Windows Services for UNIX
21:06:29 <sshine> dsal, I even ran tclsh as my command prompt at some point in 1999.
21:06:45 <dsal> heatsink: is that systemd?
21:06:53 <dsal> sshine: nice
21:07:06 <sshine> dsal, it wasn't. I don't recall that it had readline support.
21:07:09 <c010r> ok forgive me 4 being a noob.... just to clarify: the reason there are so many "shells" is that they are nothing more than a command-line "launcher" of other programs, thus making hem (theoretically) EASY to write? (hence the joke about anybody's mother can make one?) am i understanding what you wrote correctly?
21:07:21 <c010r> *them
21:07:25 <sshine> dsal, but somehow, I don't even remember when that became normal.
21:07:27 <heatsink> I don't think it's systemd.  Also according to wikipedia, SFU is no longer supported
21:07:48 <jle`> c010r: yeah, the joke was that, it's not like there is any privileged "the shell":
21:07:59 <jle`> c010r: shells are just programs like any other. just like internet browsers
21:08:13 <c010r> jle`: AHHHH
21:08:16 <c010r> i c
21:08:20 <jle`> not that it's necessarily easy to write. just that it's writable in the first place by anyone who has the time
21:08:25 <dsal> I've never used windows (well, more than a few minutes).  Hard for me to relate.
21:08:30 <heatsink> Since SFU is no longer supported, I can no longer recommend windows users to SFU
21:08:44 <jle`> writing a good internet browser is difficult, of course
21:09:02 <dsal> lynx was eventually replaced by links
21:09:11 <sshine> and then w3m?
21:09:12 <jle`> but writing a shell isn't an uncommon side-project for people to do in their spare time for fun
21:09:25 <jle`> github is probably littered with the remains of dead shells-for-fun
21:09:38 <jle`> same as how people osmetimes try writing an internet browser as a learning project
21:09:48 <c010r> ok, so.... forgive me for being a noob, but... is there a "layer" or "type of app/utility/interface-layer" between so called "shell" programs and the "command" programs that they launch?
21:10:11 <c010r> or do shells just simply launch the commands (programs)?
21:10:26 <sshine> https://www.dillo.org <- I remember running that browser on OpenBSD and viewing the fact that it doesn't follow 301 redirects automatically as a security feature. how nuts can you get.
21:11:06 <c010r> (note: i know my questions are not haskell-related, per se...)
21:11:09 <jle`> c010r: the shell works with the OS to do the launching and stuff
21:11:28 <jle`> so i suppose maybe that API that the OS offers could be said to be the sort of thing that POSIX is
21:11:40 <c010r> but you guys have advancd knowledge on this channel, compared to other channels
21:11:45 <slack1256> sshine: I always wonder if people who implement "security features" do start with a threat model.
21:11:59 <heatsink> c010r: If you want to be precise, the operating system is the interface layer for launching programs.  Shells use that interface.  Shells are not special in that regard; any other program could use the same interface to launch new programs.
21:13:06 <c010r> THANKS HEATSINK. ahhhh. so enduser's finger (keyboard) --> shell --> OS --> app/utility   ???    did i miss any lego-blocks/puzzle-pieces?
21:13:07 <sm[m]> c010r: #bash and #programming are also good channels for this
21:14:10 <c010r> sm[m]: thx, imma go to those tight now
21:14:14 <c010r> *right
21:14:18 <jle`> c010r: yeah, and i think you can say that POSIX is a common API that many different OS's or emulators can offer to build programs on top of
21:14:26 <jle`> shells being a type of program
21:15:24 <c010r> ok... man this just keeps getting more complicated... thx guys/gals
21:15:48 <c010r> any good noob level resources WRT this type of stuff?
21:15:52 <sm[m]> c010r: also, checkout wikipedia for good overviews
21:16:19 <c010r> yeah i tried wikipedia.org/posix only to get confused by everything...
21:16:36 <jle`> hm. well learning what an operating system is might be a good place to start
21:17:02 <jle`> operating systems have to expose some set of functionality to programs running on them, for those programs to be able to do the things they want to do
21:17:17 <c010r> i know what an os is. just not in DETAIL DETAIL . that article assumes a deeper level of experience/knowledge than i have... (perhaps i should not be worrying about posix then?)
21:17:35 <jle`> but it would be very annoying if every OS exposed its functionality in a different way
21:17:41 <jle`> or even if the functionality differs in weird ways
21:17:56 <jle`> so it's useful to standardize what sort of functionality an OS can offer, and what sort of names/etc. it would expose them by
21:18:15 <c010r> jle`: THERE we go... im started to get enlightened. go on...
21:18:16 <jle`> otherwise you'd have to completely rewrite your program i/o for every single OS
21:18:58 <jle`> so one such set of standardizations is called POSIX; it establishes a common set of features that OS's are expected to offer, with a common naming system and semantics etc.
21:19:10 <c010r> so i presume windows is not posix-compliant, then? but every linux and every unix IS?
21:19:24 <jle`> so now if you make your own operating system, you can offer a POSIX-compliant API so that programs "know" what sort of things your OS offers and how it offers it
21:19:52 <jle`> it isn't, but you can write programs that 'wrap' over windows to pretend it is POSIX-compliant. and programs can use that wrapped interface
21:20:28 <c010r> interesting, jle` ... so is what you just described what cygwin does?
21:20:37 <jle`> yeah, that's what projects like cygwin try to do
21:20:46 <c010r> is that what cygwin is primarily for?
21:21:07 <c010r> oh, u answered me.
21:21:16 <c010r> :)
21:21:36 <c010r> thx agn!
21:21:59 <c010r> im starting to conceptualize a model of how all this stuff "works" at the theoretical level
21:22:00 <jle`> yeah, program can talk to cygwin expecting a posix-like API. and cygwin will work directly with windows to do what those programs expect, and give back the right answers and stuff
21:22:26 <c010r> i bet that incurs a penalty? or no?
21:22:32 <c010r> just curious
21:23:06 <jle`> i believe so, yes. it's not what we would call 'native'
21:23:13 <heatsink> It depends on the details of how much compatibility it provides
21:23:46 <c010r> ok.. so WINE *WOULD* be "native", correct? in other words, WINE is "bare-metal" so theres no slowdown?
21:24:05 <jle`> c010r: you might be interested in reading through the story of SerenityOS
21:24:13 <heatsink> Wine is a compatibility layer in the other direction, and it incurs overhead for similar reasons
21:24:32 <jle`> c010r: it starts by building an OS from scratch, and designing its interface for programs to use
21:24:56 <jle`> c010r: and it writes programs on top of that OS using the interface it made, and eventually last week they were able to write a browser on it
21:25:03 <c010r> serenity... i am interested, actually. link?
21:25:11 <jle`> c010r: http://www.serenityos.org/happy/1st/index.html
21:25:14 <heatsink> I believe that Wine also does more work to behave more like Windows
21:25:16 <c010r> thx. 
21:25:27 <dsal> I wrote a shell once called "psh" it was Bourne shell with parallel constructs. I called it "pourne shell"
21:25:57 <jle`> hm, i'm not sure if there was a blog going through every step of the way. there are some videos on that page
21:27:34 <jle`> c010r: wine is not native, no. it's basically the same thing as cygwin is, but for linux to run windows programs.  basically windows program that 'expect' things from the OS, can talk to wine instead. wine will understand what they are asking for and then work with the OS directly to give the right answers/do the right things
21:28:07 <jle`> er, running programs on wine would not be native, i mean
21:29:14 <c010r> ok.... so when we talk about "native"... that really refers to the PROGRAMS, correct? in other words, one would speak of a "native" or "non-native" PROGRAM, rather than WINE or cygwin being "native"?
21:30:01 <c010r> am i using the terminology correctly?
21:30:13 <jle`> i don't know about the formal definition, but colloquially i take it to mean that the programs use the OS and its API directly instead of via a compatibility layer
21:31:19 <c010r> jle`: GOTCHA. so notepad and MIcrosoft word are "native" Win programs. and SUperTuxKart is a "native" Linux program?
21:32:05 <jle`> the versions of them for windows are, at least, yeah. i believe there is a a native osx version of Word as well
21:32:38 <c010r> cool. ok thx. ill be back got somerading to do.
21:32:45 <c010r> *reading
21:32:48 * c010r afk
21:33:33 <jle`> actually not sure if you are familiar with mobile development or not, but HTML5+JS runtime is often used as a compatibility layer as well. it offers functionality that a JS/HTML5 program can use. then that program can now run on any HTML5/JS runtime-compliant browser, including mobile browsers
21:34:07 <jle`> so HTML5/JS runtime is an established 'standard interface' that a program written for the browser should be able to expect, with standardized semantics across all browsers
21:34:18 <heatsink> so you can run google docs or cookie clicker on any OS
21:34:26 <jle`> and then the browsers look at what these webapp programs are asking for, and then natively talk to the OS to have it do what the web apps expect
21:39:04 <c010r> so javascript and java also usetheir own java "compatibility layer", to enable universal compatibility of a single binary? and it is much like the WINE and CYGWIN ones?
21:39:32 <c010r> well, .jar not binary
21:40:36 <heatsink> Browsers that run javascript are like a compatibility layer for web applications, even though they weren't originally created for that prupose.
21:42:39 <jle`> yeah, java programs use a runtime called the jvm, which has a bunch of things that it offers for programs to use. java's job is to interact natively with the OS to make the jvm "work" for the programs running on it.
21:42:59 <jle`> the jvm is actually so nice that a lot of programming languages actually compile to jvm, instead of any native code
21:43:55 <jle`> in this context javascript and HTML5 are closer to the 'specification' level, like POSIX and the 'windows OS api specification'
21:44:50 <jle`> every browser has to provide an envirionment that will accept programs 'talking' to it in the (literal) language of HTML/DOM/JS
21:46:13 <rotaerk> > sequence [[1, 2], [3, 4], [5, 6]]
21:46:15 <lambdabot>  [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
21:46:20 <jle`> hm. i guess the line is a little blurred here and the analogy is kind of fuzzy.
21:46:25 <c010r> jle wow that really clarifies things thanks!
21:46:29 <rotaerk> what would you call those lists in relation to the original lists?
21:46:44 <jle`> rotaerk: hm, "choices" maybe?
21:46:50 <jle`> or selections
21:46:51 <heatsink> elements of the cartesian product
21:46:55 <c010r> maybe i need a detailed shiny, beautiful "diagram"
21:47:01 <c010r> so b4 i go....
21:47:34 <rotaerk> hmm, I think I'll go with selections
21:47:37 <jle`> > sequence [["wheat","rye"],["cheddar","pepperjack"],["turkey","chicken","ham"]]
21:47:39 <lambdabot>  [["wheat","cheddar","turkey"],["wheat","cheddar","chicken"],["wheat","chedda...
21:47:56 <jle`> would enumerate all the ways you can build a sandwhich from one thing in each list
21:48:00 <rotaerk> I was using "combos" but ... that's confusable with something else
21:48:03 <jle`> er .. sandwich ?
21:48:41 <MarcelineVQ> sanvidtch
21:48:49 <sshine> jle`, you neglect the paleo "sandwich" in which the outer wrapping is replaced with salad leaves.
21:49:00 <jle`> my model is flawed apparently
21:49:07 <rotaerk> lol
21:49:08 <c010r> in reverse order:   BIOS <--> OS Kernel <--> low level utils/drivers <--> util/apps <--> shell <--> user??? (did i skip any interface/API "levels"???)
21:49:41 <jle`> i would put shells on the same level as other programs. sometimes they can launch other programs but sometimes other programs can launch them too
21:49:43 <rotaerk> I could call them "products"
21:49:52 <rotaerk> err
21:50:07 <c010r> (i omitted keyboard, monitor, and speaker.... i "abstracted" those things INTO "user" at the end of my "diagram")
21:50:09 <jle`> hm. i suppose the list itself would be the product
21:50:13 <sshine> c010r, the shell is just another user-level application.
21:50:15 <jle`> the single product
21:50:20 <rotaerk> ya
21:50:27 <jle`> and the lists inside would be elements of the product
21:51:09 <sshine> c010r, https://www.sciencedirect.com/topics/computer-science/operating-system-layer
21:51:29 <c010r> ok... so the "output" aspect of a program generally goes to one of two places, in order to reach the end-user's eyeballs: either a gui or text outputted into the "shell" program. correct?
21:51:53 <sshine> c010r, the output could go through any device, including the speaker.
21:52:13 <c010r> oh yeah i forgot about outputting to a file and speaker, printe, etc
21:52:20 <c010r> *printer
21:52:45 <sshine> c010r, did you at one point control the PC speaker by echo'ing frequencies to a device driver? it was enjoyable.
21:53:02 <c010r> sshine: lol  so.... very last question:
21:53:04 <sshine> c010r, you could write a shell script that played melodies by changing the frequency and sleeping.
21:53:43 <jle`> a lot of these concepts are looping back and forth, and not necessarily arranged in a straight line
21:53:58 <c010r> all the TEXT out-putted from CLI apps/utils running within a shell, is outputted THROUGH that shell, correct?
21:54:17 <sshine> c010r, as a historical perspective, you may like to read https://unix.stackexchange.com/questions/225537/everything-is-a-file
21:54:36 <c010r> ok... i just clicked on both of those links...
21:54:50 <sshine> c010r, the latter one is quicker to finish. I'd just look at the drawings of the former.
21:55:29 <jle`> % sequence [["wheat","rye"],["cheddar","pepperjack"],["turkey","chicken","ham"]]
21:55:30 <yahb> jle`: [["wheat","cheddar","turkey"],["wheat","cheddar","chicken"],["wheat","cheddar","ham"],["wheat","pepperjack","turkey"],["wheat","pepperjack","chicken"],["wheat","pepperjack","ham"],["rye","cheddar","turkey"],["rye","cheddar","chicken"],["rye","cheddar","ham"],["rye","pepperjack","turkey"],["rye","pepperjack","chicken"],["rye","pepperjack","ham"]]
21:55:38 <c010r> so lets say for sake of example im running midnight commander... its beautiful (ugly?) interface is being "spraypainted" onto he "wall" of bash, which is then beamed by my monitor into my eyeballs?
21:56:12 <jle`> unless you're using some sort of terminal directly, your terminal emulator itself is a GUI application
21:56:31 <c010r> jle`: THANK you
21:56:47 <c010r> so i discovered an additional "layer": the terminal emulator
21:57:25 <sshine> c010r, you may also view the graphical interface (X11 in Linux) as a layer.
21:57:44 <c010r> so in my previous example, it should have been more like THIS?...:   BIOS <--> OS Kernel <--> low level utils/drivers <--> util/apps <--> shell (bash, etc) <--> terminal emu <---> user??? (did i skip any interface/API "levels"???)
21:57:58 <jle`> a terminal emulator is a GUI application that renders what the shell dispalys, sends keypresses to it, etc.
21:58:06 <sshine> c010r, but it depends on how you define layers. in the simplest diagram of an operating system, you have mainly "kernel space" and "user space".
21:58:07 <jle`> c010r: i don't think it's really "levels", they're all sort of running together
21:58:10 <c010r> jle`: gotcha
21:58:12 <heatsink> BIOS is only involved when the computer is booting
21:58:28 * slack1256 thinks it is so easy to /add/ layers, but how to /remove/ them?... brb working on graalvm
21:58:46 <sshine> (also, BIOS isn't really BIOS after NVMe became the norm, right?)
21:59:39 <jle`> c010r: so for example when you push a key to type something into 'shell', that key goes to the OS, which sends it to whatever application is waiting for input -- in this case, the terminal emulator.  the emulator then sends that keypress to the shell, which updates the shell state, which the terminal sees and renders to the GUI
22:00:05 <jle`> the GUI then sends a picture to the OS, and the OS displays that picture to your monitor
22:00:12 <jle`> (simplified story)
22:00:16 <c010r> okay its getting more complete...:   Firmware/Metal/"Stuff" <--> OS Kernel <--> low level utils/drivers <--> util/apps <--> shell (bash, etc) <--> terminal emu <---> x11 window <--> user???
22:00:17 <sshine> (true story)
22:01:07 <sshine> c010r, now you're using <--> to separate both layers and jle`'s one-directional story of a keypress.
22:01:20 <jle`> of note, the GUI itself is also just another user-space program here in this story; it's just the program that takes what the terminal renders and all the other graphical elements and sends it to the OS, which the OS is happy to send to the monitor to display
22:01:40 <jle`> so you can see in a single keypress-to-eyeball situation, we move through the OS and terminal emulator etc. multiple times back and forth
22:02:00 <c010r> go on...
22:03:11 <jle`> and let's say you run a command line application. when you press enter, it goes from keyboard to OS to terminal to shell; the shell then asks the OS to launch a program, and the OS ties the program's I/O to the shell app.  then later when the program outputs anything to the OS, the OS sends it to the shell, which is rendered by the terminal, which is all put together by the GUI, which is sent to the OS and
22:03:14 <jle`> then to the monitor
22:03:20 <sshine> c010r, "BIOS <--> Kernel <--> Userland" is one model, and you can then split "Userland" into e.g. "X11 <--> terminal emulator <--> shell"
22:04:06 <sshine> c010r, or, e.g. in my case, the first program that runs after I log in is just "shell" (no emulator), after which I startx, run a terminal emulator, and then another shell.
22:04:39 <slack1256> No WM except TWM?
22:06:51 <sshine> c010r, jle`'s story of going forth and back between the kernel and userland has to do with system calls (keypresses, re-rendering of monitor, reading/writing files, and so on): actually affecting those resources happens in kernel space, but it is often applications in user space that want this to happen, and system calls is the interface for the forth-and-back. they don't extend the layers, but they operat
22:06:57 <sshine> e between them, so in a sense, they're the machinery inside your <--> operator.
22:08:40 <sshine> slack1256, I use Xmonad.
22:09:40 <sshine> slack1256, I had a pretty slick twm and fvwm configuration once.
22:10:36 <slack1256> I am actually afraid of leaving XMonad once wayland stabilises.
22:10:54 <sshine> slack1256, maybe there will be a Wmonad. ;-P
22:11:15 <sshine> I hope it will be simpler.
22:11:24 <sshine> slack1256, actually, what I say is a lie. I did just install a login manager. my boss got annoyed at the fact that I don't have a screenlock. I figured a screen lock isn't worth much if you can just jump out of X11 with a keypress.
22:11:25 <slack1256> There is Sway, which is more i3-oriented.
22:12:17 <rotaerk> say I have a function that takes a list and produces a list of equal length, is there a type I can use instead of list that enforces the length equality?
22:13:20 <c010r> sshine: i just read what you wrote about system calls above, so....
22:13:26 <slack1256> There is the GADT for indexed vectores (which are list with a type level index indicating the length), so maybe that?
22:13:45 <sshine> rotaerk, I don't know what the preferred library is, so googling around a bit I found at least: https://blog.jle.im/entry/fixed-length-vector-types-in-haskell.html (incidentally, by jle`)
22:13:46 <heatsink> what slack1256 said
22:13:51 <c010r> sshine: in other words, you are saying that apps dont "truly" interact with one-another DIRECTLY, but use the OS as a go-between?
22:14:16 <sshine> c010r, sure.
22:14:47 <slack1256> rotaerk: https://hackage.haskell.org/package/vec see an incarnation of the idea.
22:14:54 <sshine> c010r, apps only ever interact directly with its own memory, and even then, it most likely does so via a virtual memory system. (unless you're using MirageOS or TempleOS, RIP.)
22:14:58 <jle`> c010r: yeah i tried to say as much in my story
22:15:22 <rotaerk> thanks
22:15:40 <jle`> rotaerk: yeah, in practice this isn't super useful for lists, but i've had a lot of use for this with vectors
22:15:45 <c010r> Firmware/Metal/"Stuff" <--> OS Kernel <--> low level utils/drivers <--> util/apps <--> OS-Systemcalls <--> shell (bash, etc) <--> OS-Systemcalls <--> terminal emu <---> OS-Systemcalls <--> x11 window <--> ??? <--> graphics card <--> monitor/keyboard <--> noobuser
22:15:50 <jle`> rotaerk: and for that i use vector-sized (using the principles outlined in that blog post)
22:15:52 <slack1256> To create a function `gen :: [a] -> Vec n a` and to unify that `n` you probably need *gasp* singletons
22:16:59 <jle`> you don't quite use singletons for that actually, you just need some mechanisms of existential types
22:17:08 <jle`> singletons are for the other direction, when you take Vec n a as input
22:17:34 <rotaerk> the reason I'm doing this is that I have a function that takes a list of things that choose a value, and returns a list of the corresponding choices
22:17:46 <jle`> or well, when you take 'n' as an input, instead of in this case where it would be an 'output'
22:18:02 <rotaerk> so I want "each thing in the output corresponds to the thing with the same index in the input" to be clearer
22:18:15 <jle`> the reason why i don't think lists are very useful for sized collections is that lists aren't very good at being collections in the first place
22:18:28 <jle`> rotaerk: ah, you can do that somewhat by using type variables in your output, to communicate this to the user
22:18:39 <jle`> if it's just a documentation thing
22:18:57 <jle`> [f a] -> f [a]
22:19:07 <jle`> assuming f is "fixed-shape"
22:19:26 <jle`> hm, or maybe i'm misinterpreting what you are saying
22:20:07 <rotaerk> yeah that's essentially what I have right now:  [v] -> [QualificationM m v] -> m [v]
22:20:11 <jle`> yeah i do'nt understand what your function does exactly
22:20:51 <jle`> hm, i have to update that blog post. type-combinators is no longer actively maintained
22:21:18 <rotaerk> each qualification picks a single value from the [v].  thus if you have N qualifications, you get N values back
22:21:34 <rotaerk> a qualification is a predicate (for filtering to candidates) and a comparer (for identifying the best candidate)
22:21:53 <jle`> [v] -> Vec n (Qualification m v) -> Vec n v ?
22:22:05 <rotaerk> yeah that seems to fit what I'm looking for
22:22:12 <rotaerk> though I see several libraries for that :P
22:22:23 <rotaerk> https://hackage.haskell.org/package/fixed-vector  seems to have the highest number of downloadds
22:23:17 <jle`> how i'd probably write this is as a [v] -> Qualification m v -> m v
22:23:30 <jle`> then when you actually use it, you can fmap over your container
22:23:40 <jle`> fmap is guaranteed to preserve lengths
22:23:57 <jle`> or in this case, 'traverse'/'mapM'
22:24:00 <rotaerk> already have one of those but I'm building upon it with uh
22:26:39 <rotaerk> https://github.com/Rotaerk/vulkanTest/blob/master/sandbox/sandbox/src/Prelude/Local.hs#L95-L105
22:27:26 <c010r> thx agn jle
22:27:34 <rotaerk> picksByM will produce set of equally-best candidates from the list
22:27:37 <c010r> and everyone
22:27:44 * c010r lurks
22:28:09 <sshine> rotaerk, isn't your QualificationM more like a QualificationT if it takes an m that is presumably Monad m => m?
22:28:28 <rotaerk> QualificationM isn't a monad though
22:28:41 <sshine> right, so the ...M part seems a bit misleading.
22:29:02 <rotaerk> look at the definitions of them and tell me if you have a better suggestion
22:29:12 <rotaerk> how the M ones are distinguished from the pure ones
22:30:03 <rotaerk> they're on lines 21-31
22:31:11 <sshine> rotaerk, thanks. I'm sorry, I just got enlightened by what a free monad is, and I can no longer say what abstraction best describes your PredicateM.
22:31:17 <rotaerk> lol
22:33:41 <rotaerk> I'm thinking of making a:  selectionsFromM :: Monad m => Vec n (QualificationM m a) -> [v] -> m [Vec n v]
22:34:19 <rotaerk> it's I think clearer about the correspondence than this is:  [QualificationM m a] -> [v] -> m [[v]]
22:34:29 <rotaerk> jle`, would you agree with this?
22:38:35 <jle`> yeah, i think it does make it clear :)
22:39:27 <jle`> but i still think the pre-traversed way is the simplest, unless you do some sort of post-processing after that doesn't allow for a striaght traverse
22:40:12 <jle`> hm, actually the pre-traversed way might not work because the [Vec n v], not Vec n [v]
22:40:20 <rotaerk> note that what selectionsFromM is not just the corresponding picks of each qualification
22:42:00 <rotaerk> say I have list [1, 2, 3, 4], and qualifications [q1, q2].  q1 will pick [1, 3], and q2 will pick [2, 4].  the "selections" would be [[1,2], [1,4], [3,2], [3,4]]
22:42:58 <jle`> yeah, putting the numbers there makes it clear where the numeric dependence is coming from
22:43:19 <jle`> alternatively also Traversable t => t (QualificationM m a) -> [v] -> m [t v], maybe
22:43:35 <rotaerk> hmm good idea
22:43:56 <jle`> that sort of hints that they'll have the same "shape", although it isn't quite guaranteed in the type system
22:44:00 <jle`> it's just more of a documentation hint
22:44:24 <rotaerk> thanks
23:43:32 * hackage net-spider 0.3.3.0 - A graph database middleware to maintain a time-varying graph.  https://hackage.haskell.org/package/net-spider-0.3.3.0 (debugito)
23:52:02 * hackage net-spider-cli 0.2.0.0, net-spider-rpl-cli 0.1.2.0 (debugito): https://qbin.io/acute-decade-ojhw
