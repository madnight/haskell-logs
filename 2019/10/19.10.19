00:22:47 <dignissimus> How should I represent a 2d array? I want to use it for a game board, I wouldn't mind using an external library if that would work better
00:23:21 <koz_> dignissimus: There's massiv for actual 2D arrays, or you could 'flatten' it and use a Vector.
00:24:35 <dignissimus> Ah I hadn't thought of the last one, my mind went straight to a list of lists
00:25:55 <koz_> Yeah... definitely a bad plan.
00:26:16 <koz_> Lists of lists are about the worst thing you can do if you want a grid, especially if you need to access arbitrary cells of said grid.
00:30:38 <EvanR> well 8x8 isn't that bad. Except for accidentally going out of bounds
00:34:59 <Rembane> dignissimus: You can also use a Map and use a coordinate tuple as key and the cell as value. 
00:40:59 <koz_> EvanR: You can accidentally out of bounds with all the other suggestions so far as well. :P
00:45:43 <jle`> yeah, for a sparse array (like a chess board) i'd probably use something like Map (Int, Int)
00:46:22 <jle`> that's what i mostly used for advent of code
00:50:21 <EvanR> yep can't go outta bounds there
00:51:02 <Rembane> If you newtype your board and is a bit careful it's hard to go out of bounds regardless of underlying representation.
00:51:40 <svipal> I' m hard stuck on something
00:52:06 <EvanR> i mean... smart ctor does what when you accidentally go out of bounds
00:52:34 <svipal> I'm reading this paper (https://arxiv.org/pdf/1309.5135.pdf, dw it's very haskelly) and really not understanding why foldr takes a function with 3 arguments as first parameter in the definition of reverse with foldr 
00:53:17 <svipal> reverse xs = (foldr (\x k ys -> k (x:ys)) id xs) []
00:54:03 <EvanR> you can define an (a -> b -> c) with 3 not 2 args when c is itself a function type
00:54:42 <EvanR> see how id is the second arg of foldr, so c is a function type
00:55:01 <svipal>  yeah I see that
00:55:07 <svipal> but it' s not clicking
00:55:15 <EvanR> write c as d -> e
00:55:30 <EvanR> so foldr is taking a (a -> b -> d -> e)
00:55:36 <EvanR> 3 arhs
00:56:52 <svipal> yes, no I get that "theoretically" but in the context of what the function is doing it' s a major block
00:57:25 <EvanR> k is the result of the fold
00:58:20 <EvanR> at least there's that :)
00:59:23 <EvanR> reflect on that in the case where xs is one element. The simplest case other than empty
00:59:42 <EvanR> then on two elements, the simplest case that reverse will do anything
01:01:08 <dignissimus> Is this a good module layout for a tictactoe game? I think I might remove Player.hs because I'm not sure what a player type would hold: http://0x0.st/z3-F.txt
01:02:08 <svipal> honestly, maybe I 'm doing things wrong but I usually lay out the code in a single file before I think about Module subdivision unless it' s already very clear in my head from the get go
01:02:12 <svipal> EvanR: wil ldo
01:02:29 <ski> > foldr (\x k acc -> k (f x acc)) (\acc -> g acc :: Expr) [a,b,c,d] z
01:02:31 <lambdabot>  g (f d (f c (f b (f a z))))
01:02:39 <ski> > foldr (\x k acc -> k (f x acc)) (\acc -> acc) [a,b,c,d] z
01:02:41 <lambdabot>  f d (f c (f b (f a z)))
01:04:06 <ski> > foldr (\x res -> f x res) z [a,b,c,d]
01:04:08 <lambdabot>  f a (f b (f c (f d z)))
01:04:34 <koz_> I would agree with svipal.
01:05:28 <ski>      (foldr (\x k -> (\acc -> k (x:acc))) (\acc -> acc) [a,b,c,d]) z
01:07:28 <ski>   =  ((\x k -> (\acc -> k (x:acc))) a (foldr (\x k -> (\acc -> k (x:acc))) (\acc -> acc) [b,c,d])) z
01:08:16 <ski>   =  ((\x k -> (\acc -> k (x:acc))) a ((\x k -> (\acc -> k (x:acc))) b (foldr (\x k -> (\acc -> k (x:acc))) (\acc -> acc) [c,d]))) z
01:08:27 <ski>   =  ((\x k -> (\acc -> k (x:acc))) a ((\x k -> (\acc -> k (x:acc))) b ((\x k -> (\acc -> k (x:acc))) c (foldr (\x k -> (\acc -> k (x:acc))) (\acc -> acc) [d])))) z
01:08:43 <ski>   =  ((\x k -> (\acc -> k (x:acc))) a ((\x k -> (\acc -> k (x:acc))) b ((\x k -> (\acc -> k (x:acc))) c ((\x k -> (\acc -> k (x:acc))) d (foldr (\x k -> (\acc -> k (x:acc))) (\acc -> acc) []))))) z
01:09:09 <ski>   =  ((\x k -> (\acc -> k (x:acc))) a ((\x k -> (\acc -> k (x:acc))) b ((\x k -> (\acc -> k (x:acc))) c ((\x k -> (\acc -> k (x:acc))) d (\acc -> acc))))) z
01:09:48 <ski>   =  ((\k -> (\acc -> k (a:acc))) ((\x k -> (\acc -> k (x:acc))) b ((\x k -> (\acc -> k (x:acc))) c ((\x k -> (\acc -> k (x:acc))) d (\acc -> acc))))) z
01:09:55 <ski>   =  ((\k -> (\acc -> k (a:acc))) ((\k -> (\acc -> k (b:acc))) ((\x k -> (\acc -> k (x:acc))) c ((\x k -> (\acc -> k (x:acc))) d (\acc -> acc))))) z
01:10:02 <ski>   =  ((\k -> (\acc -> k (a:acc))) ((\k -> (\acc -> k (b:acc))) ((\k -> (\acc -> k (c:acc))) c ((\x k -> (\acc -> k (x:acc))) d (\acc -> acc))))) z
01:10:14 <ski>   =  ((\k -> (\acc -> k (a:acc))) ((\k -> (\acc -> k (b:acc))) ((\k -> (\acc -> k (c:acc))) ((\k -> (\acc -> k (d:acc))) (\acc -> acc))))) z
01:11:01 <jusss> is there slack robot api for haskell?
01:11:10 <ski>   =  ((\k -> (\acc -> k (a:acc))) ((\k -> (\acc -> k (b:acc))) ((\k -> (\acc -> k (c:acc))) (\acc -> (\acc -> acc) (d:acc))))) z
01:11:15 <svipal> http://hackage.haskell.org/package/slack-api
01:12:06 <ski>   =  ((\k -> (\acc -> k (a:acc))) ((\k -> (\acc -> k (b:acc))) (\acc -> (\acc -> (\acc -> acc) (d:acc)) (c:acc)))) z
01:12:46 <jusss> svipal: how I can install that package? with cable?
01:12:55 <ski>   =  ((\k -> (\acc -> k (a:acc))) (\acc -> (\acc -> (\acc -> (\acc -> acc) (d:acc)) (c:acc)) (b:acc))) z
01:13:06 <svipal> yes just plug in the cable
01:13:17 <svipal> lol I'm joking, cabal or stack should do the trick =)
01:13:40 <ski>   =  (\acc -> (\acc -> (\acc -> (\acc -> (\acc -> acc) (d:acc)) (c:acc)) (b:acc)) (a:acc)) z
01:13:51 <EvanR> cable would be basically cheating
01:13:54 <ski>   =  (\acc -> (\acc -> (\acc -> (\acc -> acc) (d:acc)) (c:acc)) (b:acc)) (a:z))
01:14:41 <ski>   =  (\acc -> (\acc -> (\acc -> acc) (d:acc)) (c:acc)) (b:a:z)
01:14:55 <ski>   =  (\acc -> (\acc -> acc) (d:acc)) (c:b:a:z)
01:15:07 <ski>   =  (\acc -> acc) (d:c:b:a:z)
01:15:11 <ski>   =  d:c:b:a:z
01:15:16 <ski> is more or less it
01:15:28 <jle`> svipal: maybe don't think about foldr as taking a function with three parameters, think about it as taking a function with two parmaeters and returning a function
01:15:52 <EvanR> is performance of reverse worse with foldr?
01:16:07 <jle`> worse compared to what?
01:16:08 <EvanR> that seemed like a lot of steps
01:16:10 <ski> the last stage i showed is the accumulator being passed inwards, collecting `a',`b',`c',`d' (in that order), along the way, adding them, one at the time, in front of the initial `z' in the accumulator
01:16:20 <EvanR> jle`: foldl
01:17:04 <jle`> there's more than one way to define reverse using foldr and foldl
01:17:23 <jle`> you can't really just pass in the same accumulator and same function
01:17:30 <EvanR> i mean, the obvious way with foldl vs what we just saw
01:17:32 <jusss> ok, I found I need to update my archlinux to install cabal...
01:17:37 <jle`> what is the obvious way with foldl?
01:17:48 <jle`> foldr with difflist as we just saw is pretty fast
01:17:51 <EvanR> foldl (:) [] xs
01:18:07 <ski> however, i showed some steps out of order (for clarity). the last stage shown would, with by-name / lazy evaluation, be interleaved with the traversing of the list `[a,b,c,d]' (i showed first traversing the list, replacing `:'s in `a:b:c:d:[]' with `\x k -> (\acc -> k (x:acc)', and finally replacing `[]' by `\acc -> acc', not propagating the accumulator inwards, as we go inwards
01:18:13 <ski> but that's what would actually happen
01:18:33 <jle`> > foldl (:) [] [1,2,3]
01:18:35 <lambdabot>  error:
01:18:35 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ [a]
01:18:35 <lambdabot>        Expected type: [a] -> [a] -> [a]
01:18:53 <koz_> :t flip (:)
01:18:54 <svipal> thank you ski
01:18:54 <lambdabot> [a] -> a -> [a]
01:18:56 <ski> > foldl (\xs x -> x:xs) [] [0,1,2,3]
01:18:58 <EvanR> flip (:)
01:18:58 <lambdabot>  [3,2,1,0]
01:19:37 <EvanR> ok the one that is as obvious as possible but no obviouser
01:19:39 <ski> svipal : i made a couple of typos (forgot to remove `c' in one step, e.g. .. also, i think some excessive (mismatched) brackets). but hopefully the gist should be clear
01:19:56 <koz_> EvanR: We need the obviousest.
01:20:21 <ski> svipal : you may compare with the conceptually simpler
01:20:31 <EvanR> jle`: i think what we just saw was: (foldr (\x k ys -> k (x:ys)) id xs) []
01:20:32 <ski>      foldr f z (a:b:c:d:[])
01:20:42 <ski>   =  f a (foldr f z (b:c:d:[]))
01:20:47 <ski>   =  f a (f b (foldr f z (c:d:[])))
01:20:54 <ski>   =  f a (f b (f c (foldr f z (d:[]))))
01:21:03 <ski>   =  f a (f b (f c (f d (foldr f z []))))
01:21:03 <jle`> foldr (\x xs -> xs . (x:)) id, yeah
01:21:09 <ski>   =  f a (f b (f c (f d z))
01:21:43 <ski> svipal : the first steps i made above corresponds exactly to that, with `f' here being `\x k -> (\acc -> k (x:acc))', and `z' being `\acc -> acc'
01:22:34 <ski> (however, with a real `f', the application of `f', i.e. `\x k -> (\acc -> k (x:acc))', would be interleaved with these steps, rather than happen after them (what i showed first, above). i already mentioned this, just repeating, for emphasis)
01:22:40 <svipal> ski : yep, I got it ! thanks
01:22:49 <svipal> by doing my own steps
01:22:55 <ski> yes
01:23:15 <jle`> foldr (\x xs -> xs . (x:)) id [1,2,3] = (1:) . (2:) . (3:) . id
01:23:48 <ski> jle` : wrong order
01:23:56 <jle`> whoops yeah
01:24:24 <jle`> foldr (\x xs -> (x:) >>> xs) id [1,2,3] = (1:) >>> (2:) >>> (3:) >>> id
01:24:44 <ski> if we had just `[1]', then `xs' would be `id', and `x' is `1', so `xs . (x:)' is `id . (1:)', rather than `(1:) . id'
01:25:27 <EvanR> foldr (\x xs -> xs . (x:)) id [1,2,3] = foldr (\x xs -> xs . (x:)) id [2,3]) . (1:)
01:25:38 <jle`> because foldr (\x y -> g (f x) y) is the same as foldr g . map f
01:25:57 <jle`> we can rewrite the above as `foldr (>>>) id . map (:)`
01:26:04 <jle`> so it turns [1,2,3]
01:26:13 <ski> if we had `[1,2]', then, counting from the end of that list, `xs' would be `id', and `x' is `2', so `xs . (x:)' is `id . (2:)'. next (really previous, but ..), `xs' becomes that `id . (2:)', and `x' is `1', so `xs . (x:)' then is `id . (2:) . (1:)'
01:26:16 <jle`> into [(1:),(2:),(3:)]
01:26:17 <ski> and so on ..
01:26:27 <jle`> into (1:) >>> (2:) >>> (3:) >>> id
01:27:13 <jle`> where (>>>) = flip (.)
01:27:45 * ski moves cards from top of one deck, to top of another deck, one card at a time
01:28:29 <EvanR> put the deck on the table then stand on head
01:28:35 <jle`> when you foldr with an associative operator, you can use the ol' intuition of foldr (+) 0 turning (1:2:3:[]) into (1+2+3+0)
01:29:01 <jle`> so here foldr (>>>) id turns ((1:) : (2:) : (3:) : []) into (1:) >>> (2:) >>> (3:) >>> id
01:29:18 <ski> doesn't work, deck is at ceiling (table), won't fall down on floor
01:29:24 <sicklorkin> mapM_ (id &&& id) "JKQA"
01:29:32 <sicklorkin> > mapM_ (id &&& id) "JKQA"
01:29:34 <lambdabot>  error:
01:29:34 <lambdabot>      • No instance for (Monoid Char) arising from a use of ‘mapM_’
01:29:34 <lambdabot>      • In the expression: mapM_ (id &&& id) "JKQA"
01:30:02 <sicklorkin> > mapM_ (id &&& id) [1..10]
01:30:04 <lambdabot>  error:
01:30:04 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M284677311131...
01:30:04 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
01:30:09 <svipal> lol
01:30:17 <ski> > mapM_ ((id &&& id) . (: "")) "JKQA"
01:30:20 <lambdabot>  ("JKQA",())
01:30:27 <ski> > mapM ((id &&& id) . (: "")) "JKQA"
01:30:29 <lambdabot>  ("JKQA",["J","K","Q","A"])
01:31:08 <jle`> > mapM_ (id &&& id) ["hello","world","ok"]
01:31:09 <lambdabot>  ("helloworldok",())
01:31:20 <ski> > mapM (id &&& id) ["hello","world","ok"]
01:31:22 <lambdabot>  ("helloworldok",["hello","world","ok"])
01:31:35 <ski> > mapM (reverse &&& id) ["hello","world","ok"]
01:31:38 <lambdabot>  ("ollehdlrowko",["hello","world","ok"])
01:31:42 <sicklorkin> you beat me
01:32:00 <jle`> :t [mconcat, fst . mapM_ (id &&& id), fst . mapM_ (join (,))]
01:32:01 <ski> oh
01:32:01 <lambdabot> Monoid a => [[a] -> a]
01:32:06 <ski> > mapM (id &&& reverse) ["hello","world","ok"]
01:32:07 <EvanR> heh
01:32:08 <lambdabot>  ("helloworldok",["olleh","dlrow","ko"])
01:32:27 <ski> @type writer
01:32:27 <jle`> :t [fold, fst . mapM_ (id &&& id), fst . mapM_ (join (,))]
01:32:28 <lambdabot> MonadWriter w m => (a, w) -> m a
01:32:28 <ski> @type WriterT
01:32:29 <lambdabot> (Foldable t, Monoid m) => [t m -> m]
01:32:29 <EvanR> foldl (+) 0 [1,2,3,4] = (0+1+2+3+4)
01:32:29 <lambdabot> m (a, w) -> WriterT w m a
01:32:49 <EvanR> foldr (+) 0 [1,2,3,4] = (1+2+3+4+0)
01:33:25 * ski keep getting confused by wrong order in `Writer'/`WriterT' (and also `State',`StateT') .. in this case by the wrong order not being used (since we used `(,)', not `Writer')
01:33:35 <jle`> it always bugs me too
01:33:45 <jle`> and also why wouldn't writer be uncurried
01:33:47 <jle`> *curried
01:34:12 * jle` . o O ( writer :: a -> w -> m a )
01:34:26 * jle` . o O ( writer :: w -> a -> m a )
01:34:27 <ski> `writer' should just apply `newtype' constructors, so be a noop (`O(0)' operation)
01:34:54 <jle`> it already can't do that
01:34:55 <ski>   writer wa = WriterT (Identity wa)
01:35:06 <EvanR> Writer is the gift that keeps on giving
01:35:26 <jle`> it can only do that if m is represtnationally role'd on is parameter
01:35:29 <jle`> *its
01:35:54 <jle`> so there is no getting around an fmap and so non-noop
01:36:08 <jle`> er wait maybe i reasoned through this wrong
01:36:13 <ski> hm, where is the `fmap' ?
01:36:19 <jle`> ...yeah i think i'm wrong, don't mind me, it's late :)
01:36:30 <ski> it's okay, it's even later here :)
01:36:46 <jle`> still, a curried writer makes sense
01:36:55 <jle`> how often do you have a tuple (a, w) just laying around?
01:36:57 <ski> as a convenience, sure
01:37:04 <jle`> more likely you will have a, w as separate things
01:37:08 <jle`> and you will have to manually tuple them
01:37:13 <jle`> so in the end you just shift the work
01:37:49 <ski>   curriedWriter = WriterT .: Identity .: (,)
01:37:50 <jle`> the work saved by a coerce-like uncurried writer is wasted in the construction of the tuple
01:38:01 <ski>                 = (WriterT . Identity) .: (,)
01:39:05 <ski> mhm
01:40:05 <__dingbat__> Hello, can anyone help with CBOR serialize/deserialize please?   https://www.codepile.net/pile/Zg6G9NdR
01:40:16 <ski>   pattern Writer :: (w,a) -> Writer w a
01:40:18 <ski>   pattern Writer wa = WriterT (Identity wa)
01:41:18 <sicklorkin> that code is doing any encoding / decoding __dingbat
01:41:24 <sicklorkin> *isn't
01:42:12 <__dingbat__> sicklorkin: not sure I follow, I am facing a compile error which I've provided in the link
01:42:56 <Rembane> __dingbat__: I think the compiler error says that you need to do all that stuff in the ST-monad, but I don't know if you do.
01:44:46 <__dingbat__> Rembane: I am not using any ST-monad, why do I need that to get it to serialize/deserialize plz?
01:45:24 <Rembane> __dingbat__: Probably because those operations do some very creative things that shouldn't escape into a global context.
01:46:10 <__dingbat__> Rembane: any pointers for how to achive that (ST monad thingy) please?
01:47:44 <Rembane> __dingbat__: Try to replace the let req = ... with req <- ...
01:52:18 <__dingbat__> Rembane: that gives an error : 
01:52:20 <__dingbat__> Couldn't match expected type ‘IO
01:52:21 <__dingbat__>                                       Data.ByteString.Lazy.Internal.ByteString’
01:52:23 <__dingbat__>                   with actual type ‘Data.ByteString.Lazy.Internal.ByteString’
01:54:33 <merijn> __dingbat__: "IO Something" isn't interchangeable with "Something"
01:54:48 <merijn> __dingbat__: You are, presumably, missing a bind or fmap somewhere
01:55:47 <__dingbat__> merijn: the original error is in the link plz. https://www.codepile.net/pile/Zg6G9NdR
01:56:11 <__dingbat__> I am getting error on line 19
01:57:45 <merijn> __dingbat__: there's a whole bunch of confusion there, tbh. For example line 11. "readTChan queue" produces "STM RPCCall" so item isn't actually an item, it's an STM transaction that (when run) will produce an item
01:58:16 <merijn> So you will need to use atomicall + bind (or do notation) to actually run said STM transaction
01:58:25 <maerwald> > view (_Just . to (++ "d")) Nothing -- this is why optics > lens
01:58:27 <lambdabot>  ""
01:58:44 <maerwald> Instead of defaulting to Monoid mempty, it doesn't compile :)
02:01:35 <__dingbat__> merijn: seems there was something wrong with the codepile site, you guys were seeing a very stale copy
02:01:43 <__dingbat__> here is the fresh link https://www.codepile.net/pile/dL05XvWn
02:01:59 <__dingbat__> there is no readTChan etc
02:03:02 <maerwald> and not to speak of the documentation, which is magnitudes better
02:03:09 <merijn> __dingbat__: Ah, same issue, though. Looks like "serialise" produces an "IO Something" which deserialise doesn't accept
02:04:06 <__dingbat__> I first tried using x <- ... instead of let x = ...
02:04:09 <merijn> __dingbat__: It would help (both you and everyone else) if you wrote down the type signatures for all the bindings, because now we just have to guess what the types of 'x', 'serialise', etc. is
02:04:43 <merijn> __dingbat__: Also, if this is inside a file, rather than GHC than it can't work like this anyway, since you can do "let" and "<-" at the top level
02:09:30 <__dingbat__> merijn: serialise is a library function in Codec.Serialise
02:10:38 <__dingbat__> I just loaded the serialised result in variable x to immediately deserialise it as per this example http://hackage.haskell.org/package/serialise-0.2.1.0/docs/Codec-Serialise-Tutorial.html
02:11:59 <merijn> oh, wait, I got the problem reversed
02:12:46 <merijn> The problem is that you're using "y <- deserialise x" the <- leads to it inferring "IO a" as result for deserialise (which doesn't work, because IO doesn't have a Serialise instance)
02:13:08 <merijn> More importantly, it's not going to work because you're not annotating deserialise with the type you want to get
02:18:58 <merijn> So you'd want just "y :: MyType; y = deserialise x" or (in GHCi) "deserialise x :: MyType"
02:26:49 <__dingbat__> merijn: I got is sorted out, basically the deserialise was expecting IO ByteString, and I was merely passing it ByteString in the dummy program
02:27:18 <__dingbat__> using getLine solves it ------>  getLine :: IO ByteString
02:27:29 <merijn> deserialise doesn't shouldn't expect "IO ByteString" with the link you gave...
04:11:40 <dignissimus> Is `place location piece board :: (Int, Int) -> GamePiece -> Board -> Board` a good function for placing a piece on the board?
04:11:56 <dignissimus> hm I mucked that one up
04:12:27 <dignissimus> `place location piece board = ...`, `place :: (Int, Int) -> GamePiece -> Board -> Board`
04:12:41 <dignissimus> And is the parmeter order ok?
04:14:42 <jzyamateur> So a function can be a functor e.g. (negate)? How ?
04:16:27 <__monty__> dignissimus: For parameter order I always think to myself "which one might I want to keep fixed?" In this case, would you be more likely to move to a fixed position? Move a fixed piece? Or move many pieces on one fixed board?
04:18:48 <jzyamateur> Its as if negate is its own world where everything is negative.. and you can fmap onto it.
04:19:55 <MarcelineVQ> depends on the game but probably board, if any, since what position you move to depends on your piece and vica-versa for most games.
04:20:55 <jzyamateur> `fmap (+1) negate` is valid and is a function
04:21:33 <jzyamateur> What is the kind of a simple function like `(+1)` or `negate`? It is `*` right?
04:23:40 <jzyamateur> How is `negate` a valid functor?
04:24:18 <Guest_43> Hello
04:24:20 <MarcelineVQ> jzyamateur: There's a Functor instance of (->) r, this can be read as (r ->) and means that in fmap you replace f with (r ->)
04:24:39 <Guest_43> I am trying to install Haskell on my computer and I cannot
04:25:03 <MarcelineVQ> % :t fmap
04:25:03 <yahb> MarcelineVQ: Functor f => (a -> b) -> f a -> f b
04:25:06 <MarcelineVQ> % :t fmap @((->)_)
04:25:06 <yahb> MarcelineVQ: (a -> b) -> (w -> a) -> w -> b
04:25:21 <MarcelineVQ> negate can fit (w -> a) just fine
04:25:44 <jzyamateur> What is `@((->)_)` ?
04:26:05 <jzyamateur> What is `@`?
04:27:38 <MarcelineVQ> It's from an extension called TypeAppications it's just a little syntax to have ghci fill in the f with ((->)_) for me for demonstration
04:27:59 <jzyamateur> I found out that `:k (forall a. (->) a)` is `* -> *` which fits the bill for being a functor..
04:28:35 <MarcelineVQ> So I guess it wasn't especially clarifying hehe. I'm using ((->)_) for (->) r where I don't care what type it uses for r so I put _
04:28:57 <Lears> If you forget the "container" analogy for a second: for a `Functor f`, an `f a` value is just something with a way to produce `a` values, and `fmap` is a way to use `a -> b` values to augment that production. So really, `(->) r` is the most natural/obvious Functor there is.
04:28:58 <MarcelineVQ> % :t fmap @((->) Int)
04:28:58 <yahb> MarcelineVQ: (a -> b) -> (Int -> a) -> Int -> b
04:30:11 <jzyamateur> I got it, still how does negate fit in for `(->) r` ?
04:30:19 <__monty__> MarcelineVQ: Ah, you're overlooking the immutability though. For a chess engine trying out many variations that could be true but in a simple game you'd usually only use a "board" for one move.
04:30:34 <mniip> if you recall the container analogy, (a -> b) is a container of b's that is indexed by a's
04:30:56 <MarcelineVQ> __monty__: Is it chess? idk, just giving my first impression :>
04:31:43 <Guest_43> Where can I go to get help installing haskell?
04:31:57 <MarcelineVQ> jzyamateur: it fits in for (r -> a),  fmap :: (a -> b) -> (r -> a) -> r -> b  when f is (r ->)
04:32:19 <jzyamateur> aah... now I got it..
04:36:26 <__monty__> MarcelineVQ: Not sure what game. Was just using it as an example of a case where that'd make sense to me.
04:38:10 <MarcelineVQ> howdareyou
04:38:11 <royal_screwup21> can i ask in algorithmic question?
04:38:22 <royal_screwup21> an*
04:39:38 <MarcelineVQ> do it doug
04:43:08 <royal_screwup21> https://codereview.stackexchange.com/questions/230991/color-the-fence-codeforces-tle
04:57:48 <svipal> Guest_43 what are you trying to install ? 
04:57:55 <svipal> stack or the platform ?
04:58:08 <svipal> and what OS are you on ?
05:02:13 <MarcelineVQ> royal_screwup21: what does it mean by maximum number?
05:02:42 <royal_screwup21> MarcelineVQ the biggest number
05:03:50 <ziman> royal_screwup21: you're searching short numbers composed of costly digits as well as long numbers composed of cheap digits; can you tell whether it's better to have a long number or a number with high digits?
05:04:08 <MarcelineVQ> I think I must not understand the restrictions, because it seems like you can just repeat 1 to use up all your paint and get the largest number
05:04:26 <ziman> 1 is not necessarily the cheapest digit in terms of paint
05:31:59 <literallyCrevice> I have an aeson Value v, and when trying `v ^. key "key"` I get an error that key is not a Monoid. I can swear this has worked for me before. What am I doing wrong?
05:38:15 <merijn> literallyCrevice: No clue, I'd say "add more type signatures"
05:39:48 <phadej> literallyCrevice: use ^?
05:39:57 <phadej> i.e. "get me a value, if one exists"
05:40:18 <phadej> key might not be there...
05:40:38 <literallyCrevice> phadej: I count on it being there but I see your point.
05:40:48 <literallyCrevice> merijn: Yep, adding . _String solved it. Thanks!
05:41:08 <phadej> . _String doesn't really solve it
05:41:22 <phadej> > ["foo", "bar"] ^. id
05:41:25 <lambdabot>  ["foo","bar"]
05:41:29 <phadej> > ["foo", "bar"] ^. folded . id
05:41:31 <lambdabot>  "foobar"
05:41:35 <phadej> you get concatenation
05:41:54 <phadej> i.e. you'll get an empty string if key is not there
05:42:01 <literallyCrevice> Yeah, I know
05:42:10 <literallyCrevice> As I said, I count on it being ther.e
05:42:40 <phadej> with json, I wouldn't, ymmv
05:48:25 <merijn> I would like to remind everyone that optparse-applicative actual freaking magic and I never want to write non-trivial commandline parsers in other languages again >.>
05:58:32 <Ariakenom> merijn: what did you write? was it complicated?
05:59:23 <merijn> Ariakenom: Well specifically, I just realised some super tricky changes I wanted boiled down to "two Applicative/Alternative combinators"
05:59:59 <merijn> Ariakenom: Although I would say I have a fairly elaborate commandline parser by now. Not necessarily complicated, but certainly big
07:07:21 <literallyCrevice> How can I apply function f to the second element of a tuple using lens?
07:09:00 <literallyCrevice> Nvm, got it
07:42:24 <juri_> how do i sanely mix catMaybe and forM? I have an array i'm iterating over, and in this case, i want to use something that touches a StateT, so i have switched from mapMaybe to forM... but when i return a Just or Nothing, that's ton getting stripped, like mapMaybe does.
07:46:31 <merijn> Well, what's the monad you're using with forM?
07:47:43 <juri_> StateT IO.
07:48:01 <jusss> is that haskell.org on AWS?
07:48:24 <merijn> juri_: I'm kinda lost exactly what the problem is and what you're asking
07:48:30 <merijn> jusss: Pretty sore it's not
07:48:36 <jusss> I can't use cabal update or cabal v2-update to download the list of pacakges
07:48:47 <jusss> merijn: then where it is? 
07:49:11 <jusss> it's stucking in "Downloading the latest package list from hackage.haskell.org" for 5 mintes
07:49:14 <MarcelineVQ> I think stack's version of things are on AWS howevers
07:49:17 <merijn> Used to be Hetzner but somewhere last year it migrated to somewhere else
07:49:34 <merijn> jusss: The package list is on a CDN
07:49:44 <merijn> jusss: Fastly, iirc
07:49:50 <evelyn> works ok here
07:49:59 <merijn> jusss: Are you behind a proxy?
07:50:16 <jusss> merijn: I'm in China
07:50:49 <juri_> merijn: mapMaybe has the attribute of stripping the 'Just' 'Nothing', and producing a list of just the Justs... I have to use mapM instead in this case since one of the function touches the StateT.. but how do i turn the StateT IO [Maybe MyType] into StateT IO [MyType], dropping all of the Nothings?
07:51:19 <merijn> jusss: https://support.fastly.com/hc/en-us/community/posts/360040166951-Fastly-CDN-content-blocked-by-the-Great-Firewall-of-China <- not sure if any of this helps
07:51:19 <glguy> fmap catMaybes
07:51:33 <merijn> ^^
07:52:37 <merijn> jusss: I think there are some public mirrors, though
07:53:07 <jusss> merijn: China has the worst network, AWS, google, and others cloud services are blocked
07:53:24 <jusss> which is why I don't use stack, it's on AWS
07:53:42 <merijn> jusss: Then I guess FPComplete's mirror is on AWS too
07:53:59 <merijn> jusss: oh!
07:54:00 <merijn> jusss: https://stackoverflow.com/questions/56668007/how-to-use-the-tsinghua-mirrors-of-hackage-and-stackage-with-haskell-stack-packa
07:54:38 <merijn> That's about stack, but should be something like that for cabal-install
07:54:55 <juri_> glguy: thanks! :)
07:55:00 <merijn> jusss: Otherwise I'd try mailing the haskell-cafe mailing list to see who has mirrors of Hackage that might be accessible
07:56:14 * hackage termonad 2.1.0.0 - Terminal emulator configurable in Haskell  https://hackage.haskell.org/package/termonad-2.1.0.0 (cdepillabout)
07:56:54 <jusss> merijn: it's 2mins, I still can't visit your stackover link... what a network
07:57:25 <jusss> merijn: they didn't block freenode, what a suprise
08:05:24 <jusss> finally, cabal updated
08:05:34 <jusss> but I have an new issue https://paste.ubuntu.com/p/v2r7xxrsQZ/
08:05:45 <jusss> getDirectoryContents:openDirStream: does not exist (No such file or directory)
08:09:24 <geekosaur> you may need to build the package first, or may want v1-install. v2-install assumes a build has been done first and may be checking before it's done one, which on a new install may well mean there's no store yet
08:09:55 <geekosaur> (v2-install is a bit of a hack since it exports programs from an internal sandbox)
08:12:44 <jusss> geekosaur: I created that directory, and it works now
08:13:07 <merijn> geekosaur: Wut?
08:13:16 <geekosaur> yeh, that's probably good enough for first use
08:13:19 <merijn> geekosaur: Depends how you configure cabal
08:13:21 <jusss> geekosaur: I don't understand why there's v1 and v2
08:13:55 <jusss> it's like pip2 and pip3
08:14:02 <merijn> jusss: v1 was the original interface, which sucked, v2 is the new one, which is much better. But immediately deleting v1 and switching to v2 would break things, so there's a transition period
08:14:06 <geekosaur> v1 was un-sandboxed and could make messes if multiple versions of a package were installed. v2 carefully tracks dependencies and only exposes the ones specifically needed, like nix does
08:14:28 <jusss> merijn: it sounds like python2 and python3
08:14:30 <merijn> jusss: Not really, the main difference is how it decides what to build and where those things are put
08:14:44 <merijn> jusss: The same code and packages compile fine with both
08:14:44 <geekosaur> v1 is more convenient for some things, but the messes it makes are a real pain to fix
08:15:28 <merijn> geekosaur: Anyway, you can use --install-method to make cabal install executables instead of symlink with v2-install
08:16:16 <merijn> jusss: If you have cabal-install 3.0 or later you can forget about v1/v2 and just use "build", "install", etc. the reason people mention v1/v2 is because people on pre-3.0 versions of the tool have different defaults
08:16:18 <geekosaur> that's kinda not the point? the point is that v2-install was an afterthought and may assume a build just so it can query the package db like this. making it work simply by creating an empty directory would seem to support this
08:17:20 <evelyn> are there any stats on how many people are using older versions of cabal?
08:17:26 <jusss> merijn: https://paste.ubuntu.com/p/7RwWQb3gTx/
08:17:42 <jusss> merijn: I'm using archlinux
08:17:45 <merijn> jusss: Right, so you're using 2.x
08:17:58 <merijn> oh...arch
08:18:07 <geekosaur> "whee"
08:18:27 <merijn> jusss: cabal-install is the name of the package that gives you cabal (the executable)
08:18:40 <merijn> jusss: See also: https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07
08:18:44 <geekosaur> that's its own level of pain because arch installs a bunch of packages that are broken by default. if you force dynamic build they mostly work
08:19:31 <merijn> Does anyone actually like Arch's policy? Because the Arch linux reddit also hates how they package haskell. Seems like it's just dogmatic adherence to rules in a situation where they don't make sense...
08:19:34 <geekosaur> but better is to remove any haskell-based packages aside from ghc, ghc-static, and cabal-install; then use cabal to install everything else, because arch's versions are too painful to make work
08:20:08 <jusss> merijn: that archlinux, they don't make ghc package depend on ghc-static, so if you only installed ghc and could never compile code to static libraries, I asked them why they do that, they think it's not share with other tools, so they just leave ghc-static alone,
08:20:31 <geekosaur> debian also likes to do the dogmatic thing, which hurt adoption of linux mint until debian got rid of gnome 2 (they had decided even though mint was evolving in a different direction, it was really gnome 2 underneath and shoould share packages. which, no.)
08:21:17 <jusss> what a story! are they assuming all the people just run their haskell code in ghci?
08:21:48 <geekosaur> they're assuming most people install pandoc or other executables via pacman and never work directly with haskell
08:22:06 <merijn> jusss: Basically Arch is saying "dynamic libraries/linking by default *always*", so they make it the default way to build Haskell dependencies. Except GHC normally links statically, so that setup breaks all the default uses of GHC
08:22:34 <merijn> jusss: It also doesn't really make sense to link Haskell libs dynamically, since you can never upgrade them independently (as GHC has no stable ABI)
08:24:50 <jusss> merijn: which distro you're using?
08:24:54 <geekosaur> hm, I should clarify above rant but it's off topic. mate, for which mint was an indirecty debian-based showcase, was the thing being hurt by debian policy
08:26:19 <jusss> merijn: I tried to install Intellij Idea haskell plugin on windows 10, and it doesn't stuck in stack config...
08:26:23 <merijn> jusss: macOS, so that's not really helpful ;)
08:27:10 <merijn> jusss: That's not entirely true, I also use CentOS on the university cluster. But I'm stubborn (and don't have root) so I always install GHC from bindists and cabal-install by hand (because that works the same on every *nix platform)
08:27:20 <merijn> jusss: There's also ghcup, which many people seem to like
08:28:08 <jusss> merijn: aha, did iOS 13 and macOS Catalina suprise you?
08:28:27 <merijn> jusss: I haven't upgraded to Catalina yet
08:28:34 <merijn> And I don't have any iOS devices
08:29:03 <jusss> merijn: why all the upgrade sucks nowadays
08:30:15 <merijn> I rarely have difficulty, but usually I don't upgrade macOS until 3-6 months after the new release so everyone else can fix the bugs before I do :p
08:30:23 <oisdk> Is there a class for things with the following operations: (+) :: f a -> f b -> f (Either a b); (*) :: f a -> f b -> f (a, b); one :: f (); zer :: f Empty;
08:30:35 <oisdk> basically a lifted semiring kind of thing
08:31:03 <oisdk> I *don't* get any form of pure or return, though. And you can only map over the f with a surjection
08:31:34 <merijn> oisdk: That looks like Applicative + Alternative?
08:31:48 <oisdk> Yeah it's very similar
08:32:06 <oisdk> but f isn't a functor
08:32:20 <merijn> oisdk: (*) is "liftA2 (,)", one is "pure ()" and zero is "empty" and (+) is <|>
08:32:43 <merijn> oisdk: That seems...awfully specific for something that isn't a functor? :)
08:33:05 <oisdk> it is!
08:33:19 <oisdk> you can map over the inhabitants with a surjection
08:34:22 <oisdk> basically I have those combinators for a type I'm working with, and they look like the kinds of things which should have a name. So I'd like to say "this type forms a _"
09:04:30 <fraktor> I've got a function like (b -> a -> Maybe b), and I've been able to make foldM work on it. However, I'm running into a situation where I need to scan instead of fold, and there isn't a scanM.
09:06:29 <heatsink> The easiest solution would be to write your own scanM.  If you're familiar with how it should work, it just takes a few lines.  Can you do that?
09:06:34 <ski> (`(+)' is not `(<|>)')
09:07:12 <fraktor> heatsink: I'm not sure I could.  My instinct is to maybe write it in terms of scanl and perhaps >>=, but I'm pretty new to Haskell.
09:07:19 <fraktor> I'll pop open a repl and see what I can do.
09:08:23 <heatsink> fraktor: You could try writing the regular list-based scanl as a refresher, then add >>= and return in the right places.
09:09:22 <heatsink> That is, it's kind of like scanl, but the function argument's type is (a -> b -> m b) instead of (a -> b -> b)
09:09:48 <heatsink> So you can try fixing up scanl to thread the computation through the monad 
09:11:12 <fraktor> Wouldn't it be (b -> a -> m b)? But yes, that's a good idea.
09:11:33 <ski> @type foldl
09:11:35 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
09:11:36 <ski> @type foldM
09:11:37 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
09:11:56 <ski> @type scanl
09:11:58 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
09:12:26 <merijn> ski: Well <|> plus fmap Left/Right is
09:12:33 <merijn> ski: I say "close enough"
09:12:43 <ski>   scanM :: Monad m => (b -> a -> m b) -> (b -> [a] -> m [b])  -- ?
09:12:54 * ski nods to merijn
09:16:10 <bifunc2> zip - Codec.Archive.Zip
09:16:10 <bifunc2> tar - Codec.Archive.Tar
09:16:19 <bifunc2> two libraries, same naming. maybe there are more examples.
09:16:36 <bifunc2> i'm wondering why  did we bother with "Codec."? Why not just start at "Archive."?
09:16:39 <bifunc2> some historical accident?
09:18:30 <dsal> Hey, can I have some guidance on exceptions?  Should I just throw an IOException when my stuff breaks, or is a custom exception (as I have now) preferred?
09:18:52 <dsal> I end up with this kind of thing:     forever $ catches (go ch) [Handler (\(ex :: MQTTException) -> handler (show ex)),  Handler (\(ex :: IOException) -> handler (show ex))]
09:19:37 <dmwit> custom
09:19:50 <bifunc2> https://tech.fpcomplete.com/haskell/tutorial/exceptions
09:19:54 <dsal> OK, I'll go with what I've got.
09:19:55 <merijn> dsal: Custom
09:20:19 <fraktor> heatsink: I'm not really sure about this. I've never used >>= before (mostly gotten by with do notation), so I'm a bit confused by it.
09:20:38 <merijn> dsal: In fact, if you have multiple different exceptions, you should use hierarchical exception so users can catch all of your libraries exceptions in one go!
09:20:51 <heatsink> You can use do notation for it too
09:21:04 <merijn> Control.Exception's most underutilised/appreciated feature
09:21:34 <dsal> dminuoso, bifunc2, merijn: Thanks.  I'll do some more reading before I publish a new version of this library.  I realized I didn't even export MQTTException.
09:21:35 <fraktor> Here's what I've got: https://0paste.com/40282
09:21:40 <merijn> bifunc2: Eh...people can make up whatever module name they like :)
09:21:45 <fraktor> But ghc is complaining about it.
09:22:13 <merijn> dsal: The Control.Exception docs refer to "Extensible Hierarchy of Exceptions" paper, which is worth a read
09:22:24 <merijn> (or whatever the exact title was)
09:22:40 <merijn> dsal: Turns you can basically do "exception subclassing"
09:22:46 <merijn> s/Turns/Turns out
09:23:14 <dsal> Yeah, that's kind of what I thought would make sense.  Mine would make sense as an IOException if that were possible.
09:23:26 <geekosaur> bifunc2, there are other kinds of codecs. most people ignore that but haskell users do tend toward more precision
09:23:35 <dsal> Though I don't throwIO all the time.
09:23:38 <merijn> dsal: That paper covers all the details
09:23:58 <merijn> dsal: Also, if you're developing a library you should also support non-throwing operations, IMO
09:24:12 <dsal> What's that mean?
09:24:19 <dsal> Oh, sorry, read that weird.
09:24:42 <merijn> dsal: https://hackage.haskell.org/package/broadcast-chan-0.2.0.2/docs/BroadcastChan.html#v:readBChan
09:24:59 <dsal> The library is mostly doing IO.  I tried making it not do exceptions at some point and ended up with it just being less reliable.
09:25:46 <merijn> dsal: I'm just saying wherever possible people should explicitly "opt-in" for throwing operations, so where possible also support non-throwing (Maybe/Either/Bool) versions
09:26:36 <dsal> Yeah, that makes sense.  It uses STM internally and I found leaking a tiny bit of that detail made it easier to make an application using it simpler and more reliable.
09:26:53 <dsal> I could have a transaction that's listening on a tchan as long as the client is connected.
09:27:09 <dsal> That kind of magic is a bit mind blowing. heh
09:36:06 <fraktor> dsal: Honestly that's how I feel about all of Haskell.
09:39:01 <merijn> dsal: You should definitely expose STM directly from your lib, that way people can use it in larger transactions where convenient
09:49:03 <shinka> If I wanted to have a class for fuzzy sets with a single elementOffunction, I could have: class FuzzySet fs where elementOf elem -> fs -> Double. The problem is 'elem', which is not defined anywhere. If I understand correctly, it's a problem that could be solved either with a multi-parameter type class or using dependent types, right?
09:51:38 <merijn> shinka: Well, my first question would be: Should this really be a class?
09:51:47 <merijn> To which the answer is most likely "no"
09:52:28 <shinka> OK, maybe?
09:54:07 <shinka> But why? I mean, there are many different objects, from functions to Map, vectors, and hash maps, that can be used to model fuzzy sets. They all shared a function: elementOf :: elem -> fs -> Double.
09:57:05 <merijn> shinka: Adding typeclasses, especially multiparam ones, to your code almost never makes things easier/simpler and almost always makes the type errors more inscrutable. Lots of people attempt to invent "collection" typeclasses, but they (almost) always give up. So the heuristic of "Do I need my own typeclass?" -> "no" is pretty safe
09:57:53 <merijn> shinka: Even if you want to abstract over many collections you could capture that via "record of functions" approach possibly with some existentials
09:58:50 <shinka> OK, I'll think about it.
10:05:01 <dunce> Hello, I was wonder if someone would look at a snippit just for style review, I don't need help making anything work, just readability 
10:05:13 <dunce> I have 3 examples, https://gist.githubusercontent.com/FreezeSnail/3a600adab84cf0d67b62978917ac3f54/raw/a8db873aa1f03c4db557fca34c96a225be4f43fe/gistfile1.txt
10:05:48 <dunce> I tried to rewrite parts to be like I what saw last time you guys helped me
10:07:42 <merijn> dunce: Instead of wrapping with [] and using ++ to prepend you can just use directly use (:) which is more efficient too
10:08:07 <merijn> dunce: I'd rewrite the if/then/else in matchBitString using guards
10:11:01 <dmwit> (foo:) is definitely more idiomatic than ([foo]++), but GHC is smart enough that it isn't more efficient.
10:12:36 <dmwit> What does compareBitString do?
10:13:23 <bifunc2> Has anyone worked with hsc files?
10:13:26 <bifunc2> particular with stack
10:13:31 <bifunc2> particularly
10:14:55 <dmwit> dunce: I'd definitely skip the Bin Tip x r pattern in path, and would almost certainly skip the Bin l x Tip pattern, too, until I had very good evidence that path was a bottleneck and this case fired a lot.
10:15:39 <dunce>  [(x, b)] ++ append xs bl , should be , (x, b) (:) append xs bl ?
10:16:02 <dmwit> `[(x,b)] ++ append xs bl` is the same as `(x,b) : append xs bl`.
10:16:24 <dunce> oh no ()
10:16:35 <dmwit> I wouldn't define paths, either. =P
10:16:42 <dunce> i thought it was like map (x:)
10:17:54 <dunce> the reason I added paths is I need an empty case to be [] not [[]]
10:18:11 <dunce> so I just pulled that out 
10:18:20 <dmwit> Are you sure you need that?
10:19:03 <dunce> I tried to make tip just return [] but It wouldnt compile, I'm a little confused on how map works tbh
10:19:16 <dunce> so that was my easy solution to duct tape it together lol
10:19:33 <dunce> I like your handle btw '=D 
10:20:28 <dmwit> I'm not sure I believe either claim of "making Tip just return [] wouldn't compile" or "I need the Tip case to be [] and not [[]]". For the former, I suspect if it didn't compile, you changed something else, too. For the latter, I suspect confusion in your definition of whatever is consuming the result of paths.
10:21:03 <dunce> 1 moment
10:21:21 <dmwit> (It would compile but have the wrong behavior, namely, always returning the empty list even for non-empty trees.)
10:21:45 <dunce> https://gist.githubusercontent.com/FreezeSnail/13ec34d23aef295bbdd1db393fb82379/raw/039bf6ef0a0dab176b7a96e2a98071b1294843ff/gistfile1.txt
10:21:57 <dunce> that includes the example cases
10:22:33 <dmwit> These cases are handed down to you from on high?
10:22:53 <dunce> what do you mean?
10:23:04 <dunce> also youre right I miss remembered it just always outs []
10:23:14 * hackage ofx 0.4.4.0 - Parser for OFX data  https://hackage.haskell.org/package/ofx-0.4.4.0 (OmariNorman)
10:23:34 <dmwit> Where did these examples come from, and why do you want paths to behave in the way shown in them?
10:23:42 <dunce> if by on high you mean the lord of my grade then yes lol
10:24:17 <dmwit> Then I suspect confusion on high.
10:24:41 <dunce> so you think [[]] should be the correct output for that case?
10:24:56 <dunce> in a sane universe?
10:24:57 <dmwit> It is the obviously correct choice. ^_^
10:25:37 <dunce> My personal belief is this was done to scalp a point or two off peoples grades
10:25:38 <dunce> lol
10:33:00 <dunce> Otherwise is my indenting ok?
10:33:09 <dunce> I made the changes you suggested, I like the guards
10:33:42 <dunce> are they similar to switch(case) in other languages?
10:33:48 <fraktor> I have an operation that is recursive and generates a list of items.  I tried to figure out a way to implement it as a fold/map combination, but couldn't. Is it bad to do list joining in a recursive loops? I ask because it's not tail-call recursive.
10:34:13 <fraktor> dunce: Very similar, yes. You can also do "case x of" and then use the same pattern if you want to use a more explicit switch statement.
10:34:28 <fraktor> And if you want a default case, you just use `_`.
10:37:59 <jle`> fraktor: recursive loops are usually more of a 'avoid if you can' situation
10:38:15 <jle`> so avoid it if you can, but if you can't, then that'll have to do
10:38:37 <fraktor> I'll post a paste of my code, maybe there's a way to make it work with foldl or something.
10:38:48 <EvanR> tail-call recursive is not necessarily always good in haskell
10:38:55 <EvanR> @src foldl
10:38:56 <lambdabot> foldl f z []     = z
10:38:56 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:39:18 <fraktor> https://0paste.com/40284
10:39:51 <fraktor> The code that I am trying to rewrite is "reevaluateBids".
10:41:02 <EvanR> are you trying to run through the list using a set along the way?
10:41:12 <EvanR> and replace the list elements 1 by 1
10:41:34 <jle`> hm that does look like just a stateful map
10:42:01 <EvanR> there's mapAccumR
10:42:05 <EvanR> :t mapAccumR
10:42:06 <jle`> so you can use something like mapAccumL
10:42:07 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
10:42:12 <EvanR> :t mapAccumL
10:42:14 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
10:42:18 <jle`> you could also foldl it but it'd be kind of clunky
10:42:39 <jle`> mapAccumX basically wrap around foldX in a way that captures a common pattern
10:42:53 <jle`> it captures a common 'recursion scheme', you might say
10:45:09 <fraktor> Exactly! I'm trying to update each item in the list in a way involving a set along the way.
10:45:27 <jle`> % :t mapAccumL @[] @(S.Set Double) @Bid @Bid
10:45:27 <yahb> jle`: (S.Set Double -> Bid -> (S.Set Double, Bid)) -> S.Set Double -> [Bid] -> (S.Set Double, [Bid])
10:46:25 <jle`> that's how you'd instantiate it in your case i think; your state is a Set Int
10:46:30 <jle`> % :t mapAccumL @[] @(S.Set Int) @Bid @Bid
10:46:31 <yahb> jle`: (S.Set Int -> Bid -> (S.Set Int, Bid)) -> S.Set Int -> [Bid] -> (S.Set Int, [Bid])
10:46:42 <jle`> and you process each Bid in the list and output (newState, newBid)
10:46:59 <jle`> um it might also be mapAccumR, hm
10:47:18 <EvanR> mapAccumR f Set.empty bids where
10:47:37 <EvanR>   f s bid = (s', bid') where
10:47:40 <EvanR>     s' = ?
10:47:43 <EvanR>     bid' = ?
10:47:47 <EvanR>     other stuff
10:47:57 <dunce> by defualt is that the same as | otherwise = fizz abc 
10:48:03 <EvanR> i'm not sure what the difference L or R makes
10:48:14 <EvanR> @src mapAccumR
10:48:15 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
10:48:16 <pikajude> it's whether it uses foldr or foldl
10:48:28 <EvanR> ok but
10:48:47 <EvanR> with foldr the empty set comes last right
10:49:02 <freeman42x> when using Miso, anyone know how to read the state of a radio button when performing the Install action in this example? https://gist.github.com/razvan-flavius-panda/913c1e1c2a12ebd33eb33e6efb55dafe#file-main-hs-L46-L49 
10:49:06 <EvanR> with foldl the empty set comes first but you have to start at the end of the list
10:50:01 <fraktor> That did exactly what I needed. Thanks!
10:52:22 <EvanR> heh, mapAccumL and mapAccumR are defined in terms of StateL and StateR from Functor.Utils...
10:53:11 <EvanR> the plot thickens
10:55:59 <EvanR> i think foldl or foldr would make the state threading inefficient
11:05:09 <freeman42x> Miso question: https://stackoverflow.com/q/58466586/750216
11:05:48 <fraktor> EvanR: So I was able to write the code in terms of mapAccumL, but uh, it's pretty hard to understand by my standards.
11:07:50 <EvanR> pastebin it and well see if theres some style issue
11:08:38 <fraktor> https://0paste.com/40289
11:08:43 <merijn> I can see how it's pretty tricky to understand, it's not immediately obvious to me so if you're much less comfortable staring at types it can be pretty intimidating
11:09:23 <merijn> fraktor: Unrelated style remark, I'd change tryPushBid to use guards and move the "let" into where
11:10:49 <merijn> fraktor: So like: https://paste.debian.net/1108382/
11:11:55 <merijn> fraktor: Similarly, I think moving the lambda you're passing to mapAccumL into a where block and giving it a name (and type signature) could make it a lot easier to follow
11:14:07 <merijn> fraktor: Refactored without a clue what it's doing: https://paste.debian.net/1108383/
11:14:42 <merijn> The answer to "this Haskell code is confusing/intimidating" is always "more bindings and types"
11:14:47 <fraktor> Is `where` generally preferred over `let`? Or is that a holy war?
11:15:03 <merijn> I would have annotated processBids with a type if I knew what it was :p
11:15:36 <merijn> fraktor: I think in general where is preferred yes. Getting "let ... in" to look nice is tricky and let without "in" only works in do blocks
11:15:45 <fraktor> https://0paste.com/40293
11:16:19 <tdammers> sometimes, let is needed though, especially in a do {} context
11:16:36 <fraktor> Also, are guards preffered over `if` or `case _ of`?
11:16:40 <tdammers> do { x <- something; let y = f x; a y } -- you can't easily do this using where
11:16:55 <merijn> fraktor: I'd say guards and case-of are both preferred over if
11:17:10 <tdammers> case vs. guards is a stylistic choice though
11:17:22 <merijn> fraktor: I prefer guards for boolean conditions and case for patterns
11:17:30 <tdammers> "if" is something some people argue should never have existed in the first place
11:18:05 <fraktor> tdammers: Can't you just do `do { x <- something; a $ f x }` in that case? I get that it's a toy example, but still.
11:18:31 <tdammers> yes, you can, but when you have something more complex for f and a, then you may want to factor it out into a let
11:18:48 <tdammers> you never technically *need* let, except maybe when you're messing with `seq` and friends
11:19:48 <merijn> fraktor: For reference, in my current code base of 9k LOC "if" occurs 4 times (and one of those 4 is inside a string of C++ code that I'm generating, so isn't even Haskell :p)
11:20:05 <fraktor> Well why don't you refactor those other 3?
11:20:08 <merijn> oh, I just noticed another of the 4 is just english in a comment
11:20:16 <merijn> So just 2 :p
11:20:16 <fraktor> s/3/2/
11:20:47 <merijn> fraktor: Because they're somewhere in the middle of some do block, so factoring them out to replace with guards is inconvenient
11:21:13 <merijn> I don't think anyone wants to completely ban if/then/else, but I would say guards/patterns are strongly preferred
11:21:37 <tdammers> you're generating C++?
11:21:39 <tdammers> holy shit
11:22:01 <tdammers> anyway, the argument against if is that it's trivial to implement as a function
11:22:12 <merijn> tdammers: A binary decision tree generated in python, evaluated in Haskell and output to C++ :p
11:22:13 <tdammers> so making it a language construct is wrong
11:22:36 <tdammers> merijn: I bet when you look at that code, it groans "kill... me..."
11:23:22 <merijn> tdammers: Basically, my GPU code is all C++ and I need to access my decision tree models from it, so I generate a simple (like...50 lines of code, plus >10k lines of array declaration :p) of C++ to access it
11:23:40 <merijn> tdammers: Well, I picked C++ over Haskell because I was worried about GC pauses messing up my measurements
11:23:45 <merijn> tdammers: Worst decision I ever made
11:23:55 <tdammers> ah, hmm
11:24:01 <geekosaur> (cuda shuda wuda)
11:24:07 <merijn> Would've been much easier to fix/work around the GC than I lost in generic refactoring/engineering effort by using C++
11:24:17 <tdammers> I'm currently doing a bit of C++, and strangely enough, it's nowhere near as terrible as I had feared
11:24:42 <merijn> tdammers: C++ is ok, if you don't mind utterly inscrutable errors and extreme verbosity
11:24:48 <rotaerk> in theory (I haven't actually confirmed it), GC pause can be made not-a-problem by moving chunks of data out of managed memory into manually allocated memory
11:24:51 <merijn> tdammers: Especially if you're using C++11 or later
11:25:02 <tdammers> the errors are mind blowing, yes
11:25:07 <tdammers> though they have nothing on clojure
11:25:10 <rotaerk> only have actively-used data in managed memory
11:25:10 <merijn> tdammers: C++ lambda's are also pretty damn good given the constraints
11:25:17 <tdammers> merijn: word.
11:25:35 <tdammers> I love how they made them blend in with the rest of the language
11:25:42 <merijn> tdammers: I've reached a joyous milestone in the past month or two, though
11:25:45 <tdammers> [captures](args) -> ret { body } // yay
11:26:09 <tdammers> also the way you can capture by value or by ref - that feels very idiomatic
11:26:29 <merijn> tdammers: Github tells me "48.7% Haskell, 40.2% C++", so for the first time in >4 years my repo has more Haskell than C++ :)
11:26:35 <tdammers> hah
11:27:06 <tdammers> I think the last time I did anything in C++ myself was when C++11 was still in flux
11:27:30 <tdammers> ah no, I did one project in C++11, so that's not true
11:30:44 <merijn> Right now I'm trying to see if I can place in the global top 10 for "largest optparse-applicative CLI parsers" :p
11:34:24 <fraktor> I tried to parse what that means and got nothing.
11:34:42 <merijn> fraktor: What what means? :)
11:35:07 <fraktor> "optparse-applicative"
11:35:13 <merijn> fraktor: It's a library :)
11:35:20 <merijn> @hackage optparse-applicative
11:35:20 <lambdabot> http://hackage.haskell.org/package/optparse-applicative
11:35:41 <merijn> fraktor: It's an Applicative (obviously :P) based option parser
11:35:53 <pikajude> it's an applicative based option parser :)
11:36:54 * fraktor writes down "TODO: look up 'applicative'"
11:37:13 <merijn> fraktor: You've seen Functor, I assume?
11:37:22 <pikajude> it's just a version of monad where you don't need actions to depend on the results of previous actions
11:37:24 <bifunc2> "stack build" automatically compiles hsc files under the hood, but it appears in vs code, intero/haskero doesn't highlight/read hsc files
11:37:36 <bifunc2> have you found good ways to deal with hsc files in vs code?
11:38:06 <pikajude> intero isn't responsible for highlighting is it?
11:38:07 <fraktor> merijn: Imagine I'm a 5-year-old who is terrified of category theory.  How might you explain a Functor?
11:38:14 <pikajude> i use a different package for syntax highlighting
11:38:28 <merijn> fraktor: "structure preserving map"
11:38:42 <merijn> fraktor: Alternatively "generalised map"
11:38:54 <fraktor> Does... does a map not preserve structure?
11:39:06 <fraktor> Or do you mean that it always has an inverse map?
11:39:07 <merijn> fraktor: It does, for lists "fmap == map"
11:39:24 <geekosaur> a map is a specific structure which is preserved by the map operation. fmap does the same for any other structure that can be preserved
11:39:36 <pikajude> fmap is generalized map
11:39:38 <merijn> > fmap even $ Just 2
11:39:40 <lambdabot>  Just True
11:39:43 <pikajude> like you can't `map` a `Maybe` but you can `fmap` it
11:39:44 <merijn> > fmap even $ Nothing
11:39:46 <lambdabot>  Nothing
11:39:50 <fraktor> I need to eat something and I will be back.
11:40:04 <pikajude> in fact, `map` could be removed from prelude or changed to `map = fmap` but isn't, for historical reasons
11:40:05 <geekosaur> sorry, a list is.Mapp the structure also has a map operation, but instead of every structure having its own map we prefer to generalize as fmap
11:40:06 <fraktor> Oh, that actually kind of makes sense.
11:40:19 <merijn> :t fmap
11:40:21 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:40:29 <EvanR> fraktor: i took a crack at it https://0paste.com/40297
11:40:35 <fraktor> So kind of like lift for monads?
11:40:47 <pikajude> not really, no
11:40:52 <pikajude> lift is m a -> t m a right?
11:41:01 <geekosaur> if you meant liftM, that's actually fmap
11:41:07 <geekosaur> historical reasons that it's separate
11:41:08 <merijn> fraktor: "If I have a type 'f' that takes an argument type, then 'fmap' applies a function to the argument type in a way that preserves the structure of the 'f' part"
11:41:15 <pikajude> oh yeah, liftM = fmap
11:41:23 <geekosaur> (Monad originally didn't build on Functor; that was corrected a couple years ago)
11:41:26 <merijn> fraktor: So, for Maybe it means "can't change Just to Nothing and can't Nothing to Just"
11:41:42 <fraktor> Oh man, this is big brain time
11:41:44 * hackage language-ats 1.7.6.1 - Parser and pretty-printer for ATS.  https://hackage.haskell.org/package/language-ats-1.7.6.1 (vmchale)
11:41:51 <merijn> fraktor: If you have a tree, it means you must keep the same levels and nesting, etc.
11:41:56 <EvanR> fraktor: the avoided repeated projection of parsels was accomplished with NamedFieldPuns
11:42:11 <pikajude> that's one of the laws of Functor
11:42:15 <pikajude> namely, fmap id = id
11:42:16 <fraktor> EvanR: Is that what that `@` does?
11:42:18 <EvanR> no
11:42:21 <EvanR> that just names the argument
11:42:28 <EvanR> no extention required for that
11:42:29 <geekosaur> and haskell does stretch your brain. in a good way, it gets bigger afterward
11:42:36 <pikajude> for example, you could write an implementation of fmap for lists that reverses the list and applies the mapping function, but it wouldn't satisfy that law
11:42:41 <merijn> fraktor: Now (f)map generally only works for functions that take only one argument (you can fmap functions that takes more, but then your function is "stuck" inside the 'f')
11:42:44 * hackage coinbase-pro 0.6.0.0 - Client for Coinbase Pro  https://hackage.haskell.org/package/coinbase-pro-0.6.0.0 (mdunnio)
11:42:47 <merijn> For example:
11:42:47 <pikajude> haskell has no baked-in way to actually *enforce* typeclass laws, btw
11:42:54 <pikajude> they're just conventions agreed upon by the community
11:42:54 <merijn> :t fmap (+) (Just 2)
11:42:56 <lambdabot> Num a => Maybe (a -> a)
11:42:57 <Ariakenom> tdammers: wrt closures. what is [](){} makes for a great c++ question
11:43:11 <fraktor> EvanR: I'm not able to get that to compile, I get a parse error.
11:43:19 <EvanR> i know.. i screwed up
11:43:28 <merijn> EvanR: Shame! Shame! ;)
11:43:30 <pikajude> does @ require TypeApplications? or is this for patterns?
11:43:37 <EvanR> try this https://0paste.com/40298 also you need NamedFieldPuns enabled
11:43:46 <geekosaur> pattern, here
11:43:50 <merijn> pikajude: @ is an alias pattern
11:44:06 <pikajude> i know, but usually if i get a parse error on @ it's because i forgot to enable that extension
11:44:07 <fraktor> How do I enable that?
11:44:13 <pikajude> and it seems like the kind of thing evanr would bring up :)
11:44:24 <pikajude> you don't need to enable anything to get @ to work in patterns
11:44:36 <pikajude> but it does require a specific syntax
11:44:38 <merijn> I hope not, TypeApplications should be kept far away from beginners (or everyone, really)
11:44:41 <EvanR> right but you need {-# LANGUAGE NamedFieldPuns #-}
11:44:46 <pikajude> i love TypeApplications
11:45:07 <pikajude> it's totally redundant in code with everything given explicit signatures, but it's awesome in ghci
11:45:07 <EvanR> what's wrong with TypeApplications :(
11:45:25 <pikajude> actually it can be convenient in real code when dealing with intermediate numeric types during conversions
11:45:27 <merijn> pikajude: Just you wait. You will get fucked over by it at some point and be humbled at my genius foresight in predicting it :)
11:45:40 <pikajude> implying i will ever work on a project that's not mine and is written in haskell
11:45:44 <pikajude> that's optimistic
11:46:04 <EvanR> well a monomorphic intermediate function might make it easier to read
11:46:21 <EvanR> and potentially useful elsewhere
11:46:23 <fraktor> Quick question before I go eat: what on earth is a pun, and why is punning illegal unless I enable that extension?
11:46:23 <pikajude> i think the function i most commonly use type applications for is `round` or `fromIntegral`
11:46:32 <pikajude> so you know how datatypes work
11:46:34 <tdammers> pikajude: the fact that you can't enforce them is what makes them "laws". if you could enforce them, they'd be part of the typeclass itself.
11:46:38 <pikajude> data Foo = Foo { bar :: Int }
11:46:51 <pikajude> usually if you want to pattern match on the `bar` field of Foo, you have to write something like
11:46:52 <EvanR> fraktor: see the field parsels.. it's used as a variable and a field name there. So it's a pun
11:47:01 <EvanR> one word two meanings
11:47:02 <pikajude> myFoo Foo { bar = myBar } = ...
11:47:07 <pikajude> NamedFieldPuns lets you write this:
11:47:10 <pikajude> myFoo Foo { bar } = ...
11:47:13 <merijn> fraktor: tbh, I think EvanR got a bit carried a way and introduced a bunch of stuff I probably would've waited with until you were more comfortable with the basics :)
11:47:19 <pikajude> and then, in the body of myFoo, `bar` is just bound to the value of the field
11:47:27 <fraktor> Technically that's not a pun but an entendre, but point taken
11:47:30 <pikajude> instead of needing to assign it to `myBar`
11:47:37 <EvanR> you could have done {parsels=theParsels}
11:47:41 <pikajude> it's pretty useful
11:47:42 <EvanR> that requires no extension
11:48:20 <EvanR> and makes more sense given how patterns are supposed to work
11:54:31 <EvanR> i just decided i'm on a crusade against $. Unless I'm really lazy in ghci
11:55:02 <ski> \o/
11:55:19 <EvanR> even though people love it in elixir, somehow people see it in haskell and declare it has too many operators
11:55:29 * ski 's gut feeling is to agree with merijn here
11:56:08 <pikajude> that's very evanr-ish
11:56:19 <EvanR> what is
11:56:42 <pikajude> introducing lots of stuff at once
11:56:52 * EvanR considers this
11:57:01 <EvanR> fine forget i ever mentioned NamedFieldPuns
11:57:02 <fraktor> Why is $ bad?
11:57:09 <merijn> fraktor: It's not
11:57:21 <fraktor> Why is $ bad according to some?
11:57:22 <pikajude> some people dislike it stylistically, but it's not like an antipattern or anything
11:57:23 <EvanR> it's not intrisincally bad
11:57:25 <pikajude> just depends on the code you're working on
11:57:35 <pikajude> i think people view it as too noisy?
11:57:41 <merijn> "It's trade-offs all the way down"
11:57:51 <fraktor> I see. I can see why it might be a little Perlish
11:57:54 <merijn> pikajude: Well, using multiple $ to compose a bunch of functions is bad!
11:58:00 <pikajude> really? ok
11:58:05 <pikajude> i didn't even know you could use $ to compose functions
11:58:08 <merijn> pikajude: But I have objective reasons!
11:58:22 <merijn> pikajude: Well, you can't, that's sorta the problem :)
11:58:23 <pikajude>  nice
11:58:23 <EvanR> i've been able to refactor $ code to look fine, and in most cases it's really not needed. 
11:58:47 <EvanR> When it is "needed", then we negotiate. But for instance now you don't need it on a "dangling do"
11:58:49 <merijn> pikajude: Some people write like this "foo $ bar $ baz $ x" which should be "foo . bar . baz $ x"
11:58:50 <fraktor> So it's better to do "a . b . c $ d" as opposed to "a $ b $ c $ d"?
11:58:53 <pikajude> oh, okay
11:58:55 <merijn> fraktor: Yes
11:58:57 <pikajude> is that actually better though?
11:59:01 <EvanR> forM_ xs do
11:59:16 <fraktor> It certainly looks nicer in my opinion, but functionally it's equivalent in this case
11:59:25 <EvanR> fraktor: a . b . c $ d is gross to me!
11:59:27 <pikajude> merijn said objective reasons
11:59:27 <merijn> fraktor, pikajude: The reason is that you can move any arbitrary section of "." composition into a new variable and it will still typecheck
11:59:30 <pikajude> is it a perf issue?
11:59:32 <pikajude> oh
11:59:39 <pikajude> okay so they ARE functionally equivalent
11:59:51 * ski writes `(foo . bar . baz) x' / `(a . b . c) d', usually
11:59:59 <pikajude> but one of them adds 2.5 seconds to your editing flow D:
12:00:03 <merijn> You cannot refactor to "let newName = foo $ bar in newName . baz $ x" as this doesn't timecheck
12:00:10 <fraktor> Ah, a fellow LaTeXer I see.
12:00:23 <ski> `.' is associative. `$' isn't
12:00:37 <pikajude> oh yeah, and $ is great for passing blocks as arguments
12:00:40 <merijn> pikajude: I will very often write very long compositions when trying to get something working (like, 10+ lines sometimes) and refactoring when you used . is trivial
12:00:47 <pikajude> i'm not sure if BlockArguments is well supported by formatting tools
12:00:50 <merijn> with $ youhave to edit everything
12:00:53 <ski> pikajude : `BlockArguments' solve that problem :)
12:00:59 <merijn> pikajude: I'm sure it isn't :p
12:01:18 <EvanR> i'm still not really comfortable with BlockArguments
12:01:45 <EvanR> it's like spelling words with double letters, you need those $ on block arguments (for no reason other than indoctrination)
12:01:48 * ski has been using it in lambda-calculus, before
12:02:17 <ski>   f \x.
12:02:20 <ski>   g \y.
12:02:25 <pikajude> well, and the other problem is it's very new, so if you're writing libraries you can't opt in at all
12:02:27 <ski>   k (foo x y)
12:02:43 <ski> (CPS)
12:02:49 <fraktor> It's okay when you're doing print though, right? I just do `print $ ...' in that case.
12:03:05 <EvanR> i use it in ghci for laziness reasons
12:03:18 <rotaerk> it bugs me for some reason when I have to flip a function just to make sure the big argument comes last, so I can use $ before it
12:03:35 <rotaerk> or when I need two big arguments on a function, in which case that doesn't work at all, and I have to wrap them in ()
12:03:39 <ski> fraktor : i typically don't, but i suppose it's not quite as bad there (or say `pure $' or `return $')
12:03:43 <pikajude> well that's what forM is for(M)
12:04:35 <rotaerk> what do you mean?
12:04:38 <ski>   (`runStateT` s0) $ do ... -- rotaerk ?
12:04:54 <pikajude> forM and stuff like that lets you give the lambda arg as the last one
12:04:56 <pikajude> so you can use $ do
12:05:01 <rotaerk> yeah or `flip runState s0 $ do`
12:05:05 <ski>   (`map` xs) \x -> ..x..
12:05:06 <pikajude> that too
12:05:11 <ski>   pam xs \x -> ..x..
12:05:19 <rotaerk> forM is only a solution to the problem if you would otherwise use mapM
12:05:33 <pikajude> there are analogs for a lot of commonly used functions though
12:05:40 <pikajude> :t traverse
12:05:41 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:05:48 <pikajude> @hoogle t a -> (a -> f b) -> f (t b)
12:05:48 <EvanR> why do all the run functions take the action first
12:05:48 <lambdabot> Control.Concurrent.Async.Lifted forConcurrently :: (Traversable t, MonadBaseControl IO m) => t a -> (a -> m b) -> m (t b)
12:05:48 <lambdabot> Control.Concurrent.Async.Lifted.Safe forConcurrently :: (Traversable t, MonadBaseControl IO m, Forall (Pure m)) => t a -> (a -> m b) -> m (t b)
12:05:48 <lambdabot> Control.Monad forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
12:05:56 <pikajude> oh, forM *is* just flipped traverse
12:05:58 <EvanR> because they are implemented as newtypes
12:05:58 <pikajude> i'm an idiot
12:06:09 <ski> pikajude : `mapM'
12:06:18 <EvanR> :t for
12:06:19 <lambdabot> (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
12:06:22 <pikajude> i never claimed to be an expert
12:06:31 <pikajude> or did i...
12:07:09 <ski> EvanR : sometimes i like to distinguish between `unFoo' and `runFoo', where the latter uses a "convenient" parameter ordering
12:07:27 <EvanR> brilliant
12:07:28 <fraktor> EvanR: I think it's because partial function application makes more sense with the action first.
12:07:45 <ski> (also, i often wish `elem',`lookup' were `flip'ped ..)
12:07:59 <EvanR> hmm no it's because the actions are really newtype wrappers and runFoo happens to also be the unwrapper
12:08:02 <ski> (`unFoo' being the `newtype' destructor)
12:08:33 <pikajude> i do wish runReader were flipped
12:08:38 <rotaerk> naming of functions is made tricky with the way turning functions into bops works
12:09:24 <rotaerk> because if a function is intended to be applied in the normal fashion, you tend to name it as though it's operating on the first argument, e.g. "insert" would take the element first, while "insertInto" would take the collection first
12:09:38 <ski> sometimes the callback is large, in which case you want it last. sometimes it's small (e.g. just a function name) (or you're just providing it, not the other parameter), and then you want it not last
12:09:47 <EvanR> taking collections last makes sense
12:09:49 <rotaerk> but if the function's intended to be used as a bop, you name it as though it would be read `first argument, verb, second argument`
12:10:06 <EvanR> bop ?
12:10:10 <fraktor> Binary operator
12:10:31 <ski> EvanR : `mele :: Eq a => [a] -> (a -> Bool)'
12:10:58 <EvanR> insert k x col  makes sense just so insert k x can be reused on many collections
12:11:01 <ski>   pukool :: Eq k => [(k,v)] -> (k -> Maybe v)
12:11:28 <rotaerk> insert col k x makes sense just so it can be reused on many elements :)
12:11:42 <pikajude> melee, lol
12:11:43 <EvanR> if you were looking through elements maybe
12:11:51 <EvanR> looping
12:11:52 <rotaerk> yeah, it's context dependent which one is more appropriate
12:12:08 <ski> parameter ordering can be hard
12:12:22 <pikajude> yes, i'd like two parameters please, medium rare
12:12:29 <fraktor> Although if you want to use a bop but give it one argument over the other, can't you do for example "(`elem` col)"?
12:12:46 <rotaerk> though if it's an immutable collection, I guess you wouldn't be re-using col for every element
12:12:48 <pikajude> yes
12:12:51 <rotaerk> you'd be using a modified col every time
12:12:58 <EvanR> rotaerk: big maybe... since you have two args now
12:13:13 <EvanR> insert k x is one arg remaining, insert col has two
12:13:20 <EvanR> so some uncurrying probably needs to also happen
12:14:19 <ski> OCaml has these named parameters, which you can partially apply, out of order
12:14:31 <ski> <https://caml.inria.fr/pub/docs/manual-ocaml/lablexamples.html>
12:14:35 <fraktor> Oh man, that's the best of both worlds honestly
12:14:46 <fraktor> A cross between Haskell and Python.
12:15:03 <merijn> fraktor: You'd think that, but that's mostly "just Haskell" ;)
12:15:19 <fraktor> Haskell with some Python sprinkled on top
12:15:38 <ski> fraktor : i do that sort of thing, quite commonly (partially applying `elem' on right parameter)
12:15:53 <merijn> Several years ago I started designing a Haskell inspired Python. Actually spend quite some time thinking things through, writing things down and then after 2 weeks I realised "wait, this is just Haskell with different syntax"
12:16:18 <fraktor> That is super useful when you want to do something like 'filter (`elem` col1) col2'
12:16:21 <merijn> So then I stopped and just wrote Haskell ;)
12:16:22 <EvanR> haskell with multiple inheritance?
12:16:26 <rotaerk> https://hackage.haskell.org/package/named-0.1.0.0/docs/Named.html  did nothing ever come of this
12:16:39 <merijn> EvanR: non-interface inheritance is dumb anyway :p
12:16:39 <ski> merijn : "I got better." :)
12:17:04 <EvanR> aw man i wanted to see a genuine frakenlanguage
12:17:10 <EvanR> franken
12:17:16 * ski . o O ( coinheritance of pattern-matching functions on variant/sum / algebraic data types )
12:17:17 <rotaerk> fricken
12:18:14 * hackage ats-pkg 3.2.6.2 - A build tool for ATS  https://hackage.haskell.org/package/ats-pkg-3.2.6.2 (vmchale)
12:18:17 <dignissimus> In record syntax should the fields be like `getBoard :: Board` or like `board :: Board`?
12:18:28 <merijn> dignissimus: "yes" :p
12:18:34 <dignissimus> hmmm
12:18:42 <rotaerk> I tend to do:  data Foo = Foo { foo'field1 :: _, foo'field2 :: _ }
12:18:51 <merijn> dignissimus: I'd say it depends on the exact record, how it's used, etc.
12:19:00 <geekosaur> ^
12:19:12 <merijn> dignissimus: For example if you use NamedFieldPuns/RecordWildCards the "getX" style seems kinda weird
12:20:09 <ziman> x{ getBoard = ... } sounds strange, too
12:20:20 <ziman> (unless it's a functional field)
12:20:45 <dsal> let getValue = 4 in Thing{..}
12:20:50 <EvanR> i'm going out on a limb to say getBoard as a field name is a symptom of field names and accessors being the same thing
12:21:22 <EvanR> somehow haskell record design step in something here
12:21:52 <merijn> EvanR: Fortunately, an extension will soon fix this!
12:21:56 <jle`> dignissimus: my common thing is something like data Game = Game { gBoard :: Board }, but yeah it's kind of ugly because record accessors are weird
12:21:56 <EvanR> oh?
12:22:17 <merijn> EvanR: That allows you to make fieldnames fieldname only (so you will need to use record syntax of NamedFieldPuns to access them)
12:22:18 <jle`> dignissimus: the problem with 'board' is that 'board' is a useful identifier you might want to use, and
12:22:36 <jle`> i don't know why i said 'and'
12:22:49 <EvanR> merijn: what's the name of this extension
12:23:06 <merijn> EvanR: https://github.com/ghc-proposals/ghc-proposals/pull/160
12:23:20 <merijn> EvanR: I don't think it was implemented yet, but the proposal was accepted
12:23:24 <rotaerk> I kind of wish record types acted as namespaces, just like modules do.  So for instance, given `data Foo = Foo { bar :: _, baz :: _ }`, if you wanted to refer to the function `bar :: Foo -> _`, you would do `Foo.bar`
12:23:46 <hpc> rust works that way and it's very pleasant
12:24:07 <rotaerk> I could see it might be a problem though in terms of disambiguating from (Foo . bar)
12:24:38 <rotaerk> you'd be forced to consider spaces significant
12:24:50 <Rembane> Don't we already do that? 
12:24:55 <rotaerk> do we? hmm
12:25:00 <merijn> rotaerk: Yes
12:25:02 <ski> `NamedFieldPuns' and `RecordWildCards' are broken, with current (broken) record design (conflating fields with field accessors) (so that you shadow the accessors .. great job)
12:25:05 <merijn> > Just.even $ 2
12:25:05 <Rembane> If you import a module qualified
12:25:07 <lambdabot>  error:
12:25:07 <lambdabot>      Not in scope: ‘Just.even’
12:25:07 <lambdabot>      No module named ‘Just’ is imported.
12:25:11 <merijn> > Just . even $ 2
12:25:13 <lambdabot>  Just True
12:25:16 <ski> EvanR : "field names and accessors being the same thing" is the problem, yea :/
12:25:20 <rotaerk> interesting; didn't realize
12:25:38 <merijn> ski: I would love NoRecordSelectors + NamedFieldPuns
12:25:40 <hpc> quick, someone write RecordNamespaces
12:25:40 <ski> merijn : oh
12:25:53 <merijn> ski: Also means it's safe to have sum types with non-matching fields
12:26:10 <rotaerk> and if you *wanted* to avoid having to say `Foo.bar` you would `import Foo'sModule.Foo`
12:26:16 <ski> merijn : having `#x pt' or `pt #x' (cf. `pt .x' in OCaml), or something along those lines (cf. SML), would be great
12:27:03 <EvanR> i like how an extension can remove features :)
12:27:05 <rotaerk> though maybe you'd need a different kind of import for importing record namespaces... because that would have to be disambiguated from importing a submodule called Foo
12:27:07 <ski> (`#x' being the field accessor function. in the `pt #x' (or `pt .x') version, it's taken to be a post-fix operator)
12:27:44 <rotaerk> err not submodule ... a module with name `Foo'sModule.Foo`
12:27:55 <ski> merijn : "safe to have sum types with non-matching fields" -- hm, elaborate ?
12:28:11 <EvanR> apostrophes in my identifiers makes me think i'm programming in klingon
12:28:14 <ski> EvanR : s/extension/restriction/ ?
12:28:32 <EvanR> restriction sounds bad
12:28:36 <merijn> ski: "data Foo = Foo { bar :: Int } | Bar { baz :: Bool }" <-currently produces warnings because the accessors are partial
12:28:40 <Rembane> EvanR: Klingon programming is a good thing
12:28:43 <nshepperd2>  there was a talk at haskellx about making records so that you can just say foo.bar
12:28:46 <rotaerk> RankNTypes adds a restriction
12:28:50 <merijn> ski: If you don't create selectors and only use NamedFieldPuns, it's fine
12:29:08 <ski> in OO subtyping ("interface / record type inheritance"), you extend a record type by new fields, getting a subtype
12:30:06 <ski> (with "alterative / variant type coinheritance" (O'Haskell,Timber,Erik Poll), you'd extend a variant type by new alternatives, getting a supertype)
12:30:51 <EvanR> spj "I like this proposal. I think of a field name as local to the data type or even the data constructor, and it's annoying to have a short, useful name removed from my top-level namespace." i was thinking the same thing. You often want to use field names like id, name, board, etc. No selectors lets you do this guilt free
12:30:59 <ski> in refinement types, you restrict a variant type by removing alternatives, getting a subtype
12:31:23 <ski> (what is it called, when you restrict a record type, by removing fields, getting a supertype ?)
12:31:39 <rotaerk> structural subtyping?
12:31:48 <EvanR> restriction maybe
12:31:49 <rotaerk> err supertyping?
12:32:20 * ski . o O ( Superclassing proposal for Haskell, by jmeacham, at <http://www.repetae.net/recent/out/supertyping.html> )
12:32:29 <heatsink> row types?
12:32:32 <ski> rotaerk : converse of subtyping
12:32:45 <ski> merijn, ok
12:33:17 <ski> merijn : i want selectors (at least by default), i just don't want them named the same as the corresponding fields
12:33:47 <EvanR> esp because fields are often name simple short words
12:33:52 <EvanR> including `id' heh
12:36:07 <ski> structural subtyping, and row types, (both being usable for light-weight record and variant types (see e.g. OCaml)) are interesting
12:36:55 <ski> <https://caml.inria.fr/pub/docs/manual-ocaml/lablexamples.html#sec49>,<https://caml.inria.fr/pub/docs/manual-ocaml/objectexamples.html>
12:37:14 * hackage ats-pkg 3.2.6.3 - A build tool for ATS  https://hackage.haskell.org/package/ats-pkg-3.2.6.3 (vmchale)
12:38:13 <dignissimus> If I have a module Board that's going to export Board and GamePiece, should I import it as qualified and use `Board.Board` and `Board.GamePiece` or just import it and use `Board` and `GamePiece`?
12:39:57 <evelyn> IMO that depends on style
12:40:01 <EvanR> or split it up into two modules
12:40:22 <EvanR> and i guess return to this same question again
12:41:19 <EvanR> yeah whether to qualify things really depends
12:42:59 <heatsink> Do you abbreviate qualified imports?
12:43:09 <heatsink> import qualified Data.Vector.Unboxed as VU
12:44:34 <heatsink> The full name feels too verbose
12:52:14 <EvanR> VU V M S BS BSL T
12:52:23 <EvanR> the usual suspects
12:53:32 <heatsink> L XL XXL
12:53:50 <heatsink> I guess that's vector, map, set, bytestring.  What is T?
12:54:03 <EvanR> Text
12:54:04 <tdammers> Text
12:54:18 <heatsink> ah
12:54:28 <tdammers> personally, I draw the line at "BS, LBS, LText"
12:55:23 <merijn> IM/IS for IntMap/IntSet
12:55:36 <evelyn> ^ I think this is largely stylistic :)
12:55:53 <EvanR> it gotta be done somehow
12:56:18 <EvanR> unless you want to spell everything out like a jamoke
12:57:01 <tdammers> my usual rule is that all imports are either qualified or explicit, except for Prelude (and, depending on my mood, some open-door modules from base, like Control.Applicative etc.)
12:59:03 <merijn> tdammers: If a module is heavily dedicated to a single thing (say, optparse-applicative parser) I might import that unqualified too, but then I try to stick to only one module/package with unqualified imports
13:00:28 <evelyn> I only tend to import something as qualified if I'm using functions from it which conflicts with functions from other modules I'm already using.
13:01:50 <merijn> evelyn: That requires tight upperbounds on dependencies or lots of fixing, though. Since adding new names is a minor bump
13:02:28 <merijn> Anyway, I'm calling quits on code for the day :p
13:13:06 <dignissimus> How bad is it that I have a module "Game.Game" that exports "Game"?
13:13:31 <EvanR> do one thing and do it well
13:13:58 <dignissimus> Is that a reference to modularity?
13:14:09 <heatsink> Data.Data exports Data
13:14:14 <EvanR> no it's just as excuse for not getting more done in a module
13:14:25 <heatsink> So it's consistent with standard library conventions...
13:14:42 <EvanR> often you do need to move type definitions into a module of it's own because reasons
13:15:11 <EvanR> or maybe a Types module
13:15:38 <tdammers> I have two reasons for my strategy
13:15:55 <lavalike> CPU: 33MHz x 3, RAM: 112 MB, HDD: 2GB, OS: OpenBSD/luna88k
13:15:58 <lavalike> what a fun guy
13:16:04 <tdammers> the first one is that when I or someone else needs to read the code later, being able to trivially figure out where a particular identifier comes from is a huge benefit
13:16:22 <tdammers> much bigger than saving a few keystrokes, or writing things in a slightly more compact form
13:17:20 <evelyn> I think that's the most important thing
13:17:31 <tdammers> the second one is that it plays nicer with the PVP
13:17:48 <tdammers> the rules make sure that when a dependency adds identifiers to its API, they cannot break my code
13:17:52 <evelyn> trying and failing to understand code you wrote a month ago is not fun; and it is even less fun for other people
13:18:15 <tdammers> and that allows me to infer practical upper bounds for my dependencies (x.y.*)
13:18:26 <wildtrees> lavalike, who runs a pc like that in this day and age? 
13:18:32 <lavalike> oops wrong channel!
13:18:32 <tdammers> IMO both reasons are fairly big
13:18:56 <lavalike> wildtrees: someone on OpenBSD was talking about a japanese guy who's keeping up a port on a very strange machine with those specs
13:19:13 <lavalike> some pictures: https://pbs.twimg.com/media/D_UkCKMU4AEc_Ve.jpg:orig https://pbs.twimg.com/media/D_UkIXIU0AI34uf.jpg:orig
13:19:16 <wildtrees> is that something from the late 80's early 90s? 
13:19:36 <lavalike> definitely
13:19:43 <wildtrees> lavalike, crazy :)
13:20:07 <evelyn> if the computer is not broken, there is no reason it should not run the latest OS!
13:20:13 <lavalike> last link so you can see more on your own https://twitter.com/ao_kenji/status/1149846812057931777
13:22:41 <EvanR> if you set TTL high enough a port could be kept open by a franciscan monk
13:22:44 * hackage util 0.1.14.0 - Utilities  https://hackage.haskell.org/package/util-0.1.14.0 (MatthewFarkasDyck)
13:23:59 <wildtrees> lavalike, seems some of the omron 88k's had 4 processors! 
13:24:10 <lavalike> cool
13:24:26 <wildtrees> I wonder if you could get hugs to run on it or something :) 
13:24:28 <evelyn> there was a lot more weird PC hardware in Japan... presumably part of the reason there's a [relatively] large crowd for NetBSD
13:43:33 <wildtrees> is the tagless final style a good thing to learn and/or a good way to go with general , possibly larger , program development in haskell?
13:44:19 <MarcelineVQ> probably better for library dev than program dev if it's better for one
13:44:54 <MarcelineVQ> But then I'm not writing libs with it so opinion could be out to lunch
13:45:00 <MarcelineVQ> *so that opinion
13:45:09 <wildtrees> out to lunch? 
13:45:59 <MarcelineVQ> not a useful opinion
13:46:09 * ski goes out, to lunch
13:46:19 <MarcelineVQ> like, I probably shouldn't have said anything it's so not-useful
13:46:47 <EvanR> tagless final is a technique to take your nice and and then make it fast and unmaintainable?
13:46:52 <EvanR> your nice code*
13:48:49 <MarcelineVQ> EvanR: tagless final is a way to create dsl's with many (read 'any you like') interpretations, this does also allow for some pretty interesting optomizations
13:49:04 <wildtrees> I heard it's kind a fast and extensible 
13:49:40 <MarcelineVQ> EvanR: summary here http://okmij.org/ftp/tagless-final/index.html
13:50:28 <wildtrees> I am making a polymorphic list even more polymorphic, learning tagless final 
13:50:37 <ski> lavalike, twm <3
13:52:10 <mniip> hmm, where do I have a better chance of having a TH question answered: here or in #ghc ?
13:52:34 <mniip> probably here, since this is technically a user question
13:52:58 <mniip> how does GadtC work? why is there a list of Name's where I would expect to see a single constructor name?
13:53:44 <mniip> ah I think I answered my own question
13:53:52 <mniip> apparently this is valid
13:53:58 <mniip> data D where C1, C2 :: D
13:54:08 <MarcelineVQ> That is valid yes
13:54:18 <MarcelineVQ> also for records
13:54:21 <mniip> though I question whether this should be reported as a single Con in a DataD
13:54:30 <wildtrees> EvanR, here is my rudimentary overloaded tagless final list https://paste.ofcode.org/FwM76ynz64Aj3W249ZmGER 
13:54:42 <mniip> MarcelineVQ, you mean RecC?
13:54:46 <mniip> it has a single Name
13:55:08 <wildtrees> I do a regular list with it, a string representation , a reversing of it, and an IO printing of the list 
13:55:27 <ski>   even,odd :: Integral a => a -> Bool
13:55:43 <ski> @src Eq
13:55:43 <lambdabot> class Eq a where
13:55:43 <lambdabot>     (==), (/=) :: a -> a -> Bool
13:55:51 <lavalike> ski: indeed (:
13:57:52 <mniip> well this is encouraging
13:57:55 <MarcelineVQ> er, dunno about that, rather just meant the multiple delcarations at once. data Foo a = MkFoo {rec,dec :: Int} 
13:58:05 <mniip> % :set -XTemplateHaskell
13:58:06 <yahb> mniip: 
13:58:10 <mniip> % $(pure [Language.Haskell.TH.DataD [] (Language.Haskell.TH.mkName "D") [] Nothing [Language.Haskell.TH.GadtC [] [] (Language.Haskell.TH.ConT (Language.Haskell.TH.mkName "D"))] []]);
13:58:10 <yahb> mniip: *** Exception: compiler/typecheck/TcTyClsDecls.hs:1927:14-35: Non-exhaustive patterns in L _ name : _
13:58:31 <mniip> MarcelineVQ, that gets reported as separate VarBangType's
13:58:55 <MarcelineVQ> There's a section in the manual showing a few places where you can use the multi-delcaration syntax, I don't know about their TH translations though
13:59:02 <EvanR> wildtrees: i see so the ctors are represented as methods
13:59:10 <EvanR> instances are interpretations
13:59:12 <wildtrees> ctors?
13:59:16 <EvanR> constructors
13:59:27 <mniip> you know part of me says this should be NonEmpty
13:59:33 <mniip> another part of me knows how bulky it is
14:00:02 <wildtrees> yea it makes code very polymorphic, oleg uses it in a paper to implement interpreters for various languages, I am trying something simpler with it then an interpreter 
14:00:26 <ski> MarcelineVQ : just a few other instances of "multiple delcarations at once", to compare with
14:01:01 <wildtrees> EvanR, I use the Poly type with wrapping and unwrapping and RankNTypes to give me more polymorphism then is usually allowed in haskell 
14:01:24 * ski isn't quite sure why it's going `repr a', rather than just `repr'
14:02:04 <EvanR> are there any laws these instances have to follow
14:02:19 <ski> mniip : refinement types :/
14:02:26 <wildtrees> ski, I tried just using repr, but couldn't get how a -> repr -> repr would work for lists of [a]
14:02:36 <mniip> { x | x /= [] }
14:02:51 <ski> no, not those
14:03:18 <wildtrees> EvanR, no laws, you can use it instead of using like an AST with an eval function 
14:03:22 <ski>   data NonEmpty a :< [a] = a : [a]
14:03:40 <ski> generating a subtype of `[a]', by removing alternatives
14:04:09 <ski>   data EvenEmpty a :< [a] = [] | a :  OddList a
14:04:20 <ski>   data  OddEmpty a :< [a] =      a : EvenList a
14:04:26 <EvanR> wildtrees: is it automatically safer
14:04:26 <ski> (mutually recursive example)
14:04:54 <wildtrees> EvanR, you get some typechecking for the construction from haskell 
14:05:21 <ski> (i'd call `{ x | x /= [] }' a subset type, not a "refinement type". dunno why LiquidHaskell uses that term for those)
14:05:47 <wildtrees> EvanR, I am like 10 pages into the oleg paper on tagless final and it is a course that is like 45 pages long 
14:06:02 <ski> er, s/EvenEmpty/EvenList/,s/OddEmpty/OddList/ ..
14:07:06 <EvanR> i want to play around with this...
14:07:15 <EvanR> but i have to go to a stupid wedding!
14:07:39 <EvanR> maybe there will be a computer with haskell installed there
14:09:33 <dmwit> ski: Why isn't that a refinement type? It fits my understanding of the term well, and jives well with Wikipedia's definition ("a type endowed with a predicate which is assumed to hold for any element of the refined type").
14:14:10 <lyxia> or, what's the difference between "subset type" and "refinement type" and why does it matter?
14:15:11 <EvanR> is x /= [] supposed to be a test, or a proposition
14:15:22 <EvanR> or something else
14:16:26 <lyxia> To me they're the kind of term that's used rarely enough that 99% of interlocutors are not going to tell the difference, or we can agree on more precise definitions only when that matters.
14:16:50 <EvanR> that's... what i was afraid of :)
14:16:59 <EvanR> "vague mathy looking thing"
14:19:22 <EvanR> perhaps it's a decidable proposition
14:22:00 <EvanR> i guess i was trying to drive at what kind of support is required before we can be in the {x | _? } slot
14:22:24 <ski> dmwit : i dunno. i've never heard of the "predicate" meaning of "refinement type", until i saw LiquidHaskell. when i saw "refinement types" mentioned in papers, it meant what i sketched (removing alternatives / constructors from variant types, yielding subtypes)
14:23:19 <c_wraith> That meaning is just a subset of the meaning currently on wikipedia. :P
14:24:30 <ski> by "subset type" i mean a type specified using the "set builder/comprehension" idea, `{x : T | ..x..}' (which can be seen as a form of `exists x : T. ..x..' (or `(x :) T * (..x..)', a "sigma" type), where we're blind in the proof part, but not in the witness part)
14:24:31 <EvanR> given the fluidity of set theory language it's easy to pull it out, dump it all over the subject matter, and then it might be hard to tell whether anything useful happened
14:25:43 <ski> (not to be confused with (structural) "subset" (of a type/set), in general)
14:27:06 <ski> lyxia : iow, by "refinement type", i mean a particular way of yielding new types, from old types, in a subtyping relationship. if you add constructors to a variant type ("alternative coinheritance"), you get a supertype. if you remove them (restricting), you get a subtype
14:28:21 <ski> (similarly, in record-based subtyping, as in OO, if you add fields/methods to a record type ("interface inheritance"), you get a subtype. if you remove them (restricting), you get a supertype. cf. the jmeacham superclass proposal link i mentioned above)
14:28:44 <ski> EvanR : a proposition, at least. probably a test, in case of LiquidHaskell
14:29:13 <EvanR> ok so a boolean 
14:29:49 <lyxia> ski: ok that makes sense
14:30:10 <lyxia> as usual. But I still think it's splitting hairs.
14:30:18 <ski> in how i used the term above, "refinement types" works in the opposite way of the usual notion of yielding new types from old, in a subtyping relationship (namely by extending, adding fields/methods/destructors (for record types), adding alternatives/constructors (for variant types))
14:30:41 <ski> l	possibly
14:30:46 <ski> lyxia : possibly
14:31:13 <ski> (just elaborating on what i understand by the term "refinement types")
14:31:31 <ski> c_wraith : heh :)
14:32:02 <EvanR> i find it helpful to give a description other than "bool tests" if there is one
14:32:03 * ski . o O ( <https://en.wikipedia.org/wiki/Principle_of_Least_Power> )
14:32:49 <ski> `Bool' tests are helpful here, i suppose, since a `Bool'ean can be true, in at most one way
14:33:16 <ski> (this trivially satisfying the requirement for being blind in the subset membership evidence)
14:33:56 <EvanR> with that establshed i wonder how the type checker can even work if the values involved aren't constants
14:34:13 <mniip> I don't suppose TH offers a way to apply a substitution to a type
14:36:44 <ski> EvanR : i suppose, evaluating open expressions, with unknown variables in it, by using definitions of operations, non-abstractly (not hiding implementation)
14:37:15 <EvanR> { x | x has even length && every other element is prime }
14:37:33 <EvanR> wondering where the limits to the test language is
14:38:47 <ski> can't quantify over infinity domains, iirc
14:39:19 <EvanR> so x /= [] is out
14:39:28 <ski> that's not a quantification
14:39:47 <EvanR> oh
14:40:25 <ski> can't say `type Prime = { p :: Natural | forall d :: Natural. divides d p => d == 1 || d == p }'
14:40:39 <ski> can say `type Prime = { p :: Natural | forall d :: Natural | d =< p. divides d p => d == 1 || d == p }'
14:40:43 <ski> or something like that
14:41:14 <ski> can't quantify over all naturals `d'. can quantify over the ones that are at most `p', since there's finitely many
14:42:06 <ski> (oh, and i suppose one also needs to somehow express the condition there that the "or" is exclusive .. forgot that. otherwise `1' is a prime, too)
14:47:59 <mniip> can I ask "are these two types equal" in Q>
14:50:19 <mniip> I'm getting a feeling that I'll have to `reifyInstances` for type families and match them by hand
15:01:24 <fraktor> Is there a more elegant way to do something like (\a b -> (f a, g b)) than that?
15:02:46 <lyxia> probably not
15:03:04 <dminuoso> fraktor: bimap from bifunctor gets you half the way
15:04:00 * ski . o O ( `(***)' )
15:04:00 <dmwit> fraktor: uncurry (f *** g)
15:04:14 <dmwit> or... maybe curry (f *** g)? I can never remember which is which
15:04:19 <ski> yes, that one
15:04:32 <dminuoso> % :t \f g -> curry (bimap f g)
15:04:33 <yahb> dminuoso: (a -> b) -> (c -> d) -> a -> c -> (b, d)
15:04:39 <ski> (i had that alrady typed out, but decided to not show it, since "half the way" was mentioned)
15:04:40 <dminuoso> % :t \f g -> curry (f *** g)
15:04:41 <yahb> dminuoso: (a -> c) -> (b -> c') -> a -> b -> (c, c')
15:05:16 <dmwit> fraktor: But, uh... those might not actually be more elegant than the explicit lambda. ^_^
15:05:46 <dminuoso> Unless you can drop the curry bit, then ***/bimap are quite decent I think.
15:06:46 <dignissimus> (How) can I use multiple function calls in a case statement?
15:07:14 <dminuoso> dignissimus: What do you mean exactly?
15:08:09 <ski> > liftA2 (,) (f . fst :: (Expr,Expr) -> Expr) (g . snd :: (Expr,Expr) -> Expr) (a,b)
15:08:11 <lambdabot>  (f a,g b)
15:08:13 <ski> > let ff,gg :: Expr -> Expr; [ff,gg] = [f,g] in liftA2 (,) (ff . fst) (gg . snd) (a,b)
15:08:15 <lambdabot>  (f a,g b)
15:08:31 <dignissimus> dminuoso: This doesn't work http://0x0.st/z3N0.hs
15:08:52 <dignissimus> It sees startGame as an argument for putStrLn 
15:09:04 <dmwit> dignissimus: Just _ -> do
15:09:06 <dminuoso> dignissimus: Did you forget a `do` there?
15:09:17 <dminuoso> dignissimus: Also note that this is not multiple function calls.
15:09:30 <dmwit> Isn't it?
15:09:32 <ski> this would be multiple commands, in a `do'-expression
15:09:53 <dminuoso> dmwit: Well it is, but Im presuming that its not what they really meant
15:10:22 <dignissimus> Yup, I forgot a do, thanks all
15:10:33 <dmwit> dignissimus: Dunno if this is just a mispaste, but you'll also need to make sure the definition and declaration of main are indented equally.
15:10:57 <ski> dminuoso : just because you have a `do' which includes the `case' as a command, doesn't mean the "commandness" extends inside automatially, to branches of this `case'-expression. you'll have to reopen a new `do' in the branch, if you want multiple commands there
15:11:08 <dignissimus> Nah, the indentation is fine, thanks though!
15:11:09 <dminuoso> dignissimus: ^-
15:11:10 <ski> dignissimus ^
15:11:16 <ski> sorry, dminuoso
15:11:16 <dminuoso> Pretty sure ski's comment was directed at you, dignissimus. :)
15:13:17 <dignissimus> ski: Ok, I think I get that, thank you
15:17:11 <ski> np :)
15:18:49 <ski> dignissimus : or, in other words : there are no `case'-commands, in a `do' (otoh, there are `let'-commands, `<-'-commands, and expression-commands). your `case' is just an expression(-command)
15:21:17 <fraktor> I'm in a situation where I'm manipulating data and parsing some dates, and I'd like to turn a Nothing into a "fail" (which is one of Aeson's functions). How might I figure out how to apply this?
15:21:20 <ski> (perhaps it could be nice, if the syntax were extended to allow `case'-commands (and `if'-commands ?), in a `do' ? .. cf. how in arrowic `proc', there are `case'- and `if'- commands)
15:22:57 <ski> @type maybe (fail "blah") pure
15:22:58 <lambdabot> Monad m => Maybe a -> m a
15:23:45 <ski> @hoogle fromMaybe
15:23:45 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
15:23:45 <lambdabot> System.Directory.Internal.Prelude fromMaybe :: () => a -> Maybe a -> a
15:23:45 <lambdabot> Distribution.Compat.Prelude.Internal fromMaybe :: () => a -> Maybe a -> a
15:23:47 <ski> @hoogle fromMaybe;
15:23:47 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
15:23:47 <lambdabot> System.Directory.Internal.Prelude fromMaybe :: () => a -> Maybe a -> a
15:23:47 <lambdabot> Distribution.Compat.Prelude.Internal fromMaybe :: () => a -> Maybe a -> a
15:23:51 <ski> er
15:23:54 <ski> @hoogle fromMaybeM
15:23:55 <lambdabot> Control.Monad.Extra fromMaybeM :: Monad m => m a -> m (Maybe a) -> m a
15:23:55 <lambdabot> Extra fromMaybeM :: Monad m => m a -> m (Maybe a) -> m a
15:23:55 <lambdabot> Control.FromSum fromMaybeM :: Applicative m => m a -> Maybe a -> m a
15:23:58 <ski> hmpf !
15:24:36 <ski> hm, perhaps the last one would actually work. not sure which package it's from, though
15:28:52 <fraktor> Actually, I'm in a slightly different position now: I can get it down to "Parser (Parser Day, Double)", but I don't know how to get that into "Parser (Day, Double)".
15:29:39 <xenon-> how did you end up with Parser (Parser Day, Double) in the first place?
15:30:59 <Welkin> Double Day
15:31:23 <dmwit> :t (>>= \(pday, double) -> pday >>= \day -> pure (day, double))
15:31:25 <lambdabot> Monad m => m (m a, b) -> m (a, b)
15:31:36 <dmwit> There are fancier ways.
15:31:53 <dmwit> But this way is quite readable, and should show you how to refactor your existing code to not produce this terrible type in the first place anyway, HA!
15:32:25 <fraktor> xenon-: I'm trying to parse a string into a day, and it has the ability to do a "failure" monad. I used Parser as my failure monad just because I'm already using it, but Maybe might be easier.
15:32:46 <fraktor> :t parseTimeM
15:32:47 <lambdabot> error: Variable not in scope: parseTimeM
15:33:03 <dmwit> show code
15:34:23 <fraktor> https://0paste.com/40316
15:35:11 <fraktor> For context, I have no idea what I'm doing
15:37:07 <dmwit> don't return (getDay (unpack s), getPrice text). Instead
15:37:25 <dmwit> getDay (unpack s) >>= \day -> return (day, getPrice text).
15:37:33 <dmwit> Then again your getPrice is also awful. =P
15:37:40 <fraktor> Okay. What should I do instead?
15:37:58 <EvanR> (,) <$> getDay <*> getPrice .... ?
15:38:11 <EvanR> liftA2 (,) getDay getPrice
15:38:36 <dmwit> EvanR: Not yet. First getPrice has to become a Parser.
15:38:48 <EvanR> make it so
15:38:59 <xenon-> or if you prefer do:  do day <- getDay $ unpack s; return (day, getPrice text)
15:39:00 <dmwit> fraktor: Instead of read (unpack str), use readMaybe (unpack str) and convert Nothing to fail, as before.
15:39:28 <dmwit> fraktor: So something like `getPrice = maybe (fail "whatever") pure . readMaybe . unpack`.
15:39:54 <ski>   day <- getDay $ unpack s
15:39:59 <ski>   return (day,getPrice text)
15:40:00 <dmwit> fraktor: Then `parseRecord s val = flip (withText "price") val $ \text -> liftA2 (,) (getDay (unpack s)) (getPrice text)`.
15:40:10 <fraktor> What does `pure` do? I've seen it in a couple places.
15:40:18 <dmwit> :t pure
15:40:20 <ski> fraktor : same as `return'
15:40:20 <lambdabot> Applicative f => a -> f a
15:40:24 <fraktor> Okay.
15:40:32 <xenon-> fraktor, that cleared it up?  :)
15:40:37 <dmwit> pure :: Double -> Parser Double -- for example
15:40:40 <xenon-> > pure 10 :: Maybe Int
15:40:43 <lambdabot>  Just 10
15:40:46 <xenon-> > pure 10 :: [Int]
15:40:48 <lambdabot>  [10]
15:40:56 <fraktor> This is very confusing to me. So many symbols
15:40:57 <xenon-> > pure 10 :: IO Int
15:40:59 <lambdabot>  <IO Int>
15:41:03 <dmwit> For Parser, it means, roughly: don't consume any input, and just produce the given value every time.
15:41:32 <dmwit> (Or maybe "ignore the input" is better than "don't consume any input" for aeson.)
15:41:37 <jle`> it's the 'no-op' parser
15:41:50 <fraktor> Where is liftA2 defined?
15:42:29 * ski . o O ( `pure trance :: Junko Mizuno' )
15:42:30 <jle`> if you are using a generic failure monad it's probably better to use Maybe
15:42:36 <ski> @index liftA2
15:42:36 <lambdabot> Control.Applicative
15:42:38 <jle`> oh, but if you're already in Parser, you can directly bind it with do notation
15:42:48 <jle`> and continue from there
15:43:16 <jle`> if i had `thingThatMakesParserDay :: Parser Day`, i could write:
15:43:25 <jle`> do day <- thingThatMakesParserDay
15:43:33 <jle`>   pure (day, 0.3)
15:43:38 <dmwit> You're like two years too late with that. ^_^
15:43:42 <jle`> s/  /   /
15:43:44 * ski smiles
15:43:49 <jle`> ah i should probably read scrollback better
15:44:05 <jle`> D:
15:44:27 <dignissimus> ghcup wants to edit my bashrc, is it good at doing this?
15:44:32 <fraktor> I'm now getting the error "Couldn't match Maybe with Parser". I think it's because I copied this code in wrong.
15:44:40 <hpc> here in #haskell we are aware that reading scrollback is hard, that's why we always answer in majestic stereo
15:45:08 <ski> @remember hpc here in #haskell we are aware that reading scrollback is hard, that's why we always answer in majestic stereo
15:45:08 <lambdabot> Done.
15:46:43 <fraktor> https://0paste.com/40317
15:47:14 <xenon-> fraktor, this compiles. https://pastebin.com/LmwLN7Li
15:47:20 <jle`> fraktor: yeah try getting rid of that :: Maybe Day
15:47:29 <xenon-> (whether it works how you want it to, I don't know, I didn't test)
15:48:19 <jle`> and um liftA2 with pure is just fmap
15:48:37 <jle`> (,getPrice text) <$> getDay s
15:48:50 <dmwit> jle`: noooo
15:48:57 <dmwit> jle`: Tell him to use readMaybe and fail instead.
15:49:12 <jle`> ah i didn't see that getPrice comes from read ...
15:49:47 <fraktor> Oh that's a really good idea.
15:50:11 <fraktor> @index readMaybe
15:50:11 <lambdabot> Text.Read
15:50:21 <jle`> yeah, in that case getPrice could be Text -> Parser Double
15:51:02 <jle`> getPrice str = case readMaybe (unpack str) of
15:51:12 <jle`>   Nothing -> fail "bad string :("
15:52:10 <mniip> hmm
15:52:30 <xenon-> if it is a parser, shouldn't it just be getPrice :: Parser Double?
15:52:42 <xenon-> maybe parsePrice would be a better name, too
15:52:46 <jle`> that's not quite how aeson parsers are structured
15:53:02 <jle`> it's kind of weird
15:53:05 <ski> `str' comes from `withText'
15:53:31 <ski>   getPrice txt = maybe (fail "bad text, no double serving for you") return (readMaybe (unpack txt))
15:54:22 <jle`> hm. yeah, this could all probably be restructured since aeson's parser already does a lot of this automatically
15:54:33 <mniip> does anyone wanna help me implement a typechecker in TH
15:54:34 <mniip> :P
15:54:54 <jle`> parseRecords r = do
15:55:56 <jle`>   hm :: HM.HashMap Text Double <- parseJSON r
15:56:45 <jle`>   traverseWithKey convertTheKey hm
15:57:06 <jle`> then you only need to convert the Text into the Day; the Double's are already parsed for you
15:57:41 <jle`>   convertTheKey k v = (v,) <$> getDay k
15:57:49 <jle`> * (,v)
15:58:23 <jle`> Day does have a FromJSONKey instance so you can directly get a HashMap Day Double. however the FromJSON instance might not be the one you want
15:58:56 <jle`> oh that gives you a Parser (HashMap Day Double), but you can fmap toList it
16:00:14 <jle`> parseRecords = traverseWithKey (\k v -> (v,) <$> getDay k) <=< parseJSON
16:00:35 <jle`> oh wait, traverseWithKey doesn't do that, it only replaces the value, heh
16:01:06 <jle`> parseREcords = mapM (\(k,v) -> (,v) <$> getDay k) . HM.toList <=< parseJSON
16:01:11 <dignissimus> Is there a way that I can write  for 2 patterns to do the same thing without repeating myself? 
16:01:21 <dignissimus> In a case statement ^
16:01:25 <jle`> dignissimus: do you have an example of what you mean
16:01:32 <dignissimus> Yea
16:01:43 <ski> define a function, perhaps, and call it twice (maybe in a view pattern)
16:02:01 <ski> (or a pattern synonym)
16:05:26 <dignissimus> It's not a great example because I can just make use of `_` here, but if I wanted `Just _` and `Nothing` to do the same thing, let's say `error "something"`, could I do that while only writing error ""` once?
16:05:55 <ski> still not getting your situation
16:06:32 <dignissimus> http://0x0.st/z3qq.hs
16:06:38 <ski> > case Just "foo" of _ -> error "blah !"
16:06:40 <lambdabot>  *Exception: blah !
16:06:43 <ski> > case Nothing of _ -> error "blah !"
16:06:45 <lambdabot>  *Exception: blah !
16:06:58 <ski> i replaced your "`Just _` and `Nothing`" by a single `_'
16:07:10 <dmwit> ski: perhaps deduplicating "a" and "b" in case x of 0 -> "a"; 1 -> "a"; 2 -> "b"; 3 -> "b"; _ -> "too big"
16:07:45 <ski> dignissimus : i only see one `error', there
16:07:48 <dmwit> dignissimus: No two of those cases do the same thing?
16:07:57 <Welkin> you cna also combine case expressions with boolean guards
16:08:26 <dmwit> dignissimus: Ah, perhaps I see. You want to combine the 'y' and 'n' cases, maybe.
16:08:41 <ski> dmwit : hm, disjunctive patterns
16:09:26 <dmwit> dignissimus: perhaps: Just c <- getInputChar "AI?"; when (c `notElem` "yn") (outputStrLn "Defaulting to yes..."); startGame ('n' /= c)
16:12:10 <ski>   pattern YN :: Bool -> Maybe Char
16:12:16 <ski>   pattern YN b <- ((`lookup` [('y',True),('n',False)]) -> Just b)
16:12:20 <ski>     where
16:12:21 <ski>     YN b = Just (if b then 'y' else 'n')
16:12:29 <ski>   case entered of
16:12:35 <ski>     YN b -> startGame b
16:12:40 <ski>     Just _ -> ...
16:12:42 <ski>     ...
16:12:54 <dmwit> oof
16:13:12 <ski> (perhaps a bit overkill, yea .. just wanted to see how it'd look like)
16:14:49 <ski> hm, i suppose there should be a `Just' after the `<-'
16:46:57 <sshine> hmm, I'm using Megaparsec's makeExprParser and I run into a problem: '=' has lower precedence than '==', but they have overlap.
16:51:52 <dminuoso> In megaparsec, is there a way to run try and run a parser but throw away its result?
16:52:29 <dminuoso> Sort of like `justConsume p = void (try p <|> pure undefined)`
16:53:26 <xenon-> justConsume p = void $ try p ?  which should return Parser ()
16:53:34 <koz_> Is it true that, given Applicative f, a -> f b is isomorphic to Compose ((->) a) f b?
16:53:54 <dminuoso> xenon-: That will still fail if p fails.
16:54:02 <xenon-> oh, right
16:55:42 <sshine> dminuoso, yes, there's also 'lookAhead' http://hackage.haskell.org/package/megaparsec-7.0.5/docs/Text-Megaparsec.html#v:lookAhead
16:56:02 <sshine> if '==' had the highest precedence, it'd not be a problem.
16:56:17 <dminuoso> sshine: I want it to consume.
16:56:42 <sshine> sorry, I said the wrong thing before. '=' has highest procedence and so '=' is consumed before reaching the second '='.
16:56:55 <dminuoso> sshine: Basically I want a consuming variant of lookAhead ;)
16:57:26 <dminuoso> I could probably use `observing` rather than using undefined.
16:58:19 <xenon-> justConsume p = (try p >> return ()) <|> pure ()  ?
16:58:26 <sshine> maybe "notFollowedBy (char '=')" after the '=' parser.
16:58:36 <xenon-> (should probably be more consistent with regards to pure/return :) 
16:58:39 <dminuoso> xenon-: Ah I guess thats a bit cleaner. :)
17:00:23 <koz_> :t sequenceA
17:00:25 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
17:02:07 <koz_> I'm under the impression that '(->) (Finite n)' is a Traversable. Am I off-base? If not, how on earth would that instance look?
17:06:21 <ski> koz_ : using `KnownNat n', i imagine ?
17:06:44 <koz_> ski: Yeah, I need that just for _Foldable_ to work.
17:07:00 <ski> howso ?
17:07:00 <koz_> I have an intuition that this is possible, but every time I try to write it, I can't see how.
17:07:35 <koz_> ski: foldMap f g = foldMap (f . g) finites
17:07:42 <koz_> Unless there's a better way?
17:10:26 <ski> koz_ : hm, i was thinking some kind of induction/recursion on the `n'
17:10:38 <ski> (not quite sure how one'd express that, though)
17:10:43 <koz_> ski: I'm not sure either.
17:11:07 <koz_> The thing driving my intuition is that sized vectors are Traversable (and Representable for that matter).
17:11:34 <koz_> However, the implementation just leans on _un_sized vectors, which isn't terribly instructive.
17:14:39 <ski>   knownNatPrimRec :: KnownNat n => (n ~ 0 => o) -> (forall m. (KnownNat m,1 + m ~ n) => o -> o) -> o
17:15:11 <ski>   knownNatInd :: KnownNat n => p 0 -> (forall m. KnownNat m => p m -> p (1 + m)) -> p n
17:15:23 <ski> something along those lines, i'd like to have, i think
17:15:58 <koz_> ski: Is this for the Foldable instance, or the Traversable instance, for (->) (Finite n)? I'm not sure I see how those would help.
17:16:04 <dmwit> koz_: You might like http://hackage.haskell.org/package/universe-reverse-instances-1.1/docs/src/Data.Universe.Instances.Traversable.html
17:16:42 <koz_> dmwit: Is universeF some kind of parallel-reality 'finites' in this case?
17:16:54 <dmwit> probably
17:16:58 <dmwit> universeF :: Finite a => [a]
17:17:10 <koz_> Yeah, that appears to be the case.
17:17:12 <dmwit> With the promise that all fully-defined inhabitants have finite index in universeF.
17:17:40 <koz_> Well, the Foldable instance is essentially what I have then, since their mconcat-map combo is basically foldMap.
17:17:50 <ski>   knownNatStrongInd :: KnownNat n => (forall m. KnownNat m => (forall l. (KnownNat l,l < m) => p l) -> p m) -> p n  -- possibly also this
17:18:05 <dmwit> koz_: Ah, yeah! I should use foldMap, thanks!
17:18:11 <koz_> dmwit: You're welcome!
17:18:45 <ski> koz_ : hm, not sure
17:18:52 <koz_> mconcat . map g is, after all, foldMap g.
17:19:19 <koz_> Now to try and understand that sequenceA.
17:19:50 <koz_> So you basically nondeterministically pair off the domain with every result, sequenceA _that_ to get... something?
17:20:00 <dmwit> In short: run all possible inputs and build a lookup table.
17:20:06 <koz_> And then index into it?
17:21:10 <dmwit> (You can use fromAscList if you arrange the right laws for universeF, but we didn't arrange that, so...)
17:21:46 <ski> koz_ : it's a lookup-table
17:21:54 <koz_> Hmm, interestingly, finites gives me enough strength that I can do better. It produces the values in ascending order, so I can jam them into a sized vector then look _that_ up.
17:22:04 * dmwit nods
17:22:33 <dmwit> Depending on your implementation of sized vectors, that might not actually be better.
17:22:47 <dmwit> e.g. the standard linked-list implementation will make lookups linear time instead of log-time as Map will give you.
17:22:52 <koz_> I'd be using the ones from vector-sized, which are just thin wrappers around _un_sized ones.
17:22:58 <dmwit> But if your underlying structure is an actual vector/array, then that will be better than Map.
17:23:03 <koz_> And unsized vectors have constant lookups I think.
17:23:08 * dmwit nods again
17:23:47 <koz_> It might get kinda painful if n is large, because I basically dunno how Vector fusion will behave in this case.
17:26:59 <koz_> Hmm, now I wonder if there's something which can give me (a -> b) -> (a -> (a, b))
17:27:23 <dmwit> :t (id &&&)
17:27:25 <lambdabot> (b -> c') -> b -> (b, c')
17:27:31 <koz_> Woah wut.
17:27:44 <koz_> :t (&&&)
17:27:46 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
17:28:05 <koz_> Wait, I remember seeing something that looked similar in profunctors as well.
17:28:21 <dmwit> Not too surprising. Profunctors are like a better Arrow.
17:28:31 * koz_ goes and checks again.
17:28:46 <koz_> 'Anything is possible if you add enough Edward packages'
17:30:54 <ski> @let graph :: Arrow ar => ar a b -> ar a (a,b); graph f = arr id &&& f; cograph :: ArrowChoice ar => ar a b -> ar (Either a b) b; cograph f = f ||| arr id
17:30:56 <lambdabot>  Defined.
17:31:01 <koz_> Well, Arrow is 'Strong Category' apparently, and Strong gives me first' and second', which are p a b -> p (a, c) (b, c) and p a b -> p (c, a) (c, b).
17:31:12 <ski> @type graph :: (a -> b) -> (a -> (a,b))  -- koz_
17:31:12 <koz_> I guess that's what triggered my associative memory.
17:31:13 <lambdabot> (a -> b) -> a -> (a, b)
17:31:40 <koz_> ski: Oooh, like the 'graph of a function' notion of graph? Neat.
17:31:44 <ski> yes
17:32:19 <ski> `a -> (a,b)' (injective) represents a subobject of `(a,b)', the graph of the function, being a binary relation between `a' and `b'
17:32:28 <dmwit> (The only difference between ski's graph and my proposal is that he lifted id into the arrow and then dropped it back down to a function with a type annotation after.)
17:32:47 <koz_> I guess id &&& will work.
17:33:04 <ski> similarly, `Either a b -> b' (surjection) represents a factor/quotient object on `Either a b'
17:33:37 <koz_> This looks _so much_ like Strong and Choice.
17:33:45 <jle`> adjunctions sort of makes working with traversals-of-functions nicely too
17:33:54 <ski> a cograph of a function is roughly a table associating inputs in one column to outputs in another. put inputs that map to the same output in the same equivalence class (also with the output itself), after tagging inputs and outputs
17:34:50 <ski> or, if you have a function from a number line to another, draw arrows from input points to output points. if you can follow arrows (in any direction) from one point to another, then they're in the same equivalence class
17:35:22 <ski> dmwit : yep. i mostly added my version because of the name `graph', and also for the opportunity to mention `cograph'
17:35:39 <ski> koz_ : "Strong and Choice" ?
17:37:04 <koz_> ski: https://hackage.haskell.org/package/profunctors-5.5/docs/Data-Profunctor.html#t:Strong and https://hackage.haskell.org/package/profunctors-5.5/docs/Data-Profunctor.html#t:Choice
17:37:11 <jle`> Strong and Choice sort of are orthogonal generatlizations of (***) and (+++)
17:37:24 <jle`> but of (&&&) and (|||), i don't think there is a profunctors analogue
17:37:44 <koz_> jle`: That's a bit surprising, especially considering that Arrow is apparently Strong Category.
17:38:31 <jle`> er wait, i'm thinking of Bifunctor generalizing (***) in a dfiferent way
17:38:51 <jle`> koz_: yeah, you have to add Category to do most "arrow-y stuff"
17:38:57 <jle`> Arrow/Category are inherently monoidal
17:39:13 <jle`> which profunctors in general aren't
17:39:26 <jle`> note that all of the Data.Pofunctor class methods only take "one" p a b and return one p b c
17:39:32 <jle`> none of them take "two" p a b's
17:39:52 <jle`> it's sort of like how Functor only takes one 'f a', but you need Applicative or MOnad to ever talk about two f a's
17:40:06 <koz_> Yeah, I see what you mean.
17:40:23 <jle`> so Profunctors is more of the abstractions you can talk about where you only have "one" p a b
17:40:37 <jle`> where Arrow and Category are all abstractions where you mostly think about combining r a b's
17:40:44 <koz_> Hmm, interesting.
17:40:56 <koz_> So basically you have to add _something_ monoidal to 'mash together' profunctors?
17:41:08 <jle`> Profunctor is what happened when we realized that we usually don't care about two p a b's, because we usually have one p a b and many a -> b's
17:41:32 <jle`> koz_: yeah. Category turns profunctors monoidal with respect to profunctor composition
17:42:08 <koz_> I see.
17:42:11 <ski> koz_ : hm, wondering why the name `Strong', there ..
17:42:13 <jle`> Category is a ... monoid in the (compositionally monoidal) category of profunctors
17:42:25 <jle`> maybe
17:42:40 <koz_> jle`: So basically, everywhere we had 'Arrow', we can just talk about 'Strong Category' or 'Choice Category' or something?
17:43:00 <jle`> i think Arrow is Strong Category, ArrowChoice would be Choice Category or something maybe
17:43:07 <koz_> ski: I dunno - I'm sure there's something in the category theory literature justifying this.
17:43:18 <jle`> but one of the reasons Arrow is a 'dead abstraction' is that we usually don't ever need to generalize to combine p a b's
17:43:44 <jle`> except when we're dealing with Category maybe, and in that case we usually don't even awlays have strong categories
17:44:09 <koz_> Yeah, but from what I can see, the two most common Categories seem to be (->) and Kleisli.
17:44:14 <koz_> And they're both Strong.
17:44:25 <flebron> So I've noticed some hackage packages now highlight both the general (declared) and specific (instantiated variables) types of identifiers, like mousing over error or rangeSize in http://hackage.haskell.org/package/array-0.5.4.0/docs/src/Data.Array.Base.html#safeRangeSize. Some packages don't. Anyone know how I can get my package to have that, and when this started? It's way cool :)
17:44:37 <ski> koz_ : usually you'd call either `Functor f => f (a -> b) -> (a -> f b)' or `Functor f => (a,f b) -> f (a,b)', `strength', i think
17:44:45 <jle`> but yeah if you use Procompose as your tensor, then Category is the ability to turn Procompose p p a b -> p a b
17:44:54 <koz_> ski: Well, you'd have to ask Edward.
17:45:00 <jle`> just like how if Compose is your tensor, Monoid is the ability to turn Compose m m a -> m a
17:45:08 <jle`> * Monad
17:45:19 <koz_> jle`: Yeah, I was about to say 'that looks an awful lot like join'.
17:46:35 <koz_> (also as it turns out, I needed (a -> f b) -> (a -> f (a, b)) argh)
17:46:45 <koz_> Misread dmwit's code.
17:46:54 <jle`> \f x -> (x,) <$> f x 
17:47:20 <koz_> It's not quite as magical-looking as id &&& though. :P
17:47:25 <dmwit> jle`: What do you know, that's exactly the function I used in my code!
17:47:36 <koz_> dmwit: Modulo tuple section.
17:47:37 <dmwit> Though I spelled it without TupleSections for back-compat.
17:47:57 <jle`> how far back do you have to go to not support TupleSections ;)
17:48:12 <ski> @type runKleisli . graph . Kleisli
17:48:12 <dmwit> Dunno, and didn't want to bother finding out.
17:48:14 <lambdabot> Monad m => (a -> m b) -> a -> m (a, b)
17:48:17 <jle`> although there is that ghc proposal i saw that was incomplatible with TupleSections
17:48:34 <koz_> ski: Oooh, that's really cool.
17:48:35 <ski> hm, although that requires `Monad', not just `Functor'
17:48:42 <koz_> ski: I have Applicative.
17:48:50 <koz_> (which is unfortunately not Monad either :()
17:49:13 <koz_> @pl \f x -> (x,) <$> f x
17:49:13 <lambdabot> (line 1, column 11):
17:49:13 <lambdabot> unexpected ","
17:49:13 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
17:49:16 <koz_> Awwwww
17:49:26 <dmwit> ?pl \f x -> (,) x <$> f x
17:49:26 <lambdabot> liftM2 (<$>) (,)
17:49:35 <jle`> :t runKleisli . first . Kleisli
17:49:37 <lambdabot> Monad m => (b -> m c) -> (b, d) -> m (c, d)
17:49:40 <jle`> darn, so close
17:49:43 <dmwit> That's... pretty readable, actually.
17:49:58 <koz_> :t liftA2
17:49:59 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
17:50:04 <koz_> (that would do I think)
17:50:27 <dmwit> liftA2 or liftM2 is an aesthetic choice here, because the f is being monomorphed to function type.
17:50:34 <jle`> i have somewhat of an objection to the idea that liftA2 (<$>) (,) is readable
17:50:45 <koz_> jle`: Readability is (somewhat) relative.
17:50:54 <dmwit> i.e. the liftM2 is not using the same Functor as the (<$>)
17:51:28 <dmwit> So the type of this thing will still only have Functor as a constraint, even if you use liftM2.
17:51:31 <dmwit> :t liftM2 (<$>) (,)
17:51:33 <lambdabot> Functor f => (a1 -> f a2) -> a1 -> f (a1, a2)
17:51:43 <ski> @let onKleisli :: (Monad m0,Monad m1) => (Kleisli m0 a0 b0 -> Kleisli m1 a1 b1) -> ((a0 -> m0 b0) -> (a1 -> m1 b1)); onKleisli = (runKleisli .) . (. Kleisli)
17:51:45 <lambdabot>  Defined.
17:52:01 <ski> @type onKleisli graph
17:52:03 <lambdabot> Monad m1 => (a1 -> m1 b) -> a1 -> m1 (a1, b)
17:52:05 <ski> @type onKleisli first
17:52:06 <lambdabot> Monad m1 => (b -> m1 c) -> (b, d) -> m1 (c, d)
17:52:22 <ski> hm
17:52:36 <ski> oh, i suppose i don't need the `Monad' constraints, actually
17:54:54 <koz_> traverse f (Dim ix) = fmap (Dim . VS.index) . sequenceA . VS.generate $ (f . ix)
17:54:59 <koz_> (Dim is a newtype wrapper)
17:55:15 <koz_> THank you all for your help and insights! You are all amazing, intelligent and highly-attractive people. :P
17:55:16 <dmj`> is it possible to load an import qualified in a .ghci file
17:55:32 <koz_> dmj`: You can just write 'import qualified ...' I think?
17:55:34 <dmwit> import qualified Foo
17:55:39 <koz_> as Bar
17:55:48 <dmwit> Only if you want the qualification different.
17:56:05 <koz_> What's the 'default' qualification? All of Foo?
17:56:10 <dmwit> Yes.
17:56:24 <dmwit> In fact, "qualified" does not mean "define qualified names". It means "do not define unqualified names".
17:56:25 <dmj`> koz_: when I do that, it says it cannot find my module
17:56:26 <koz_> It shows exactly what I import qualified that I haven't done it enough to remember it. :P
17:56:48 <dmj`> koz_: yet this syntax works fine ':load ArrayFire'
17:56:53 <dmwit> The "default" qualification is exactly the same as it would be if you hadn't said "qualified" at all.
17:57:07 <dmwit> dmj`: Oh, a local module? Then :load it first, then import it.
17:57:35 <dmwit> You can load without putting its stuff into scope by :load ArrayFire; :m - ArrayFire
17:57:58 <dmwit> So a complete .ghci would be like load ArrayFire; m - ArrayFire; import qualified ArrayFire
17:58:42 <dmwit> uh... actually you may need the colons?
17:58:50 <dmwit> I can't remember how .ghci's work exactly.
17:59:09 <dmwit> Yeah. :load AF; :m - AF; import qualified AF
17:59:15 <dmj`> dmwit: oh net, thank you
17:59:38 <dmj`> dmwit: I have some functions that overlap though, unless I use a letter with the qualified import, collisions occur unfortunately
17:59:45 <dmj`> like the function 'sum' for example
18:00:13 <dmwit> What does "unless I use a letter with the qualified import" mean?
18:00:27 <dmwit> If it means "use an `as` clause", then I challenge your claim.
18:00:44 * hackage partial-records 0.2.2.0 - Template haskell utilities for constructing records with default values  https://hackage.haskell.org/package/partial-records-0.2.2.0 (mniip)
18:00:55 <dmj`> dmwit: import qualified Module as M
18:01:06 <dmj`> dmwit: as opposed to 'import qualified Module'
18:01:10 <dmwit> I don't believe you.
18:01:33 <dmj`> dmwit: yes, I 'import qualified M' and ghc yells at me :( saying 'sum' could refer to either
18:02:13 <dmwit> Well 1. it should be `import qualified Module` and 2. I still don't believe you.
18:02:34 <dmwit> In particular, I think you did `import Module as M` instead of `import qualified Module`.
18:04:25 <dmwit> But I'd love to see a ghci transcript showing what you see.
18:04:36 <dmj`> dmwit: alright, here we go. In my .ghci file I have this line ':load ArrayFire' followed by this line 'import qualified ArrayFire '
18:05:03 <dmwit> You need `:m - ArrayFire` after `:load ArrayFire`. :load does an implicit unqualified import.
18:05:26 <dmwit> (In fact, even worse than unqualified! It does a deep import that even imports stuff not exported by ArrayFire.)
18:06:40 <dmwit> Indeed, not even changing `import qualified ArrayFire` to `import qualified ArrayFire as AF` would fix the resulting name collisions. So now I challenge even the other half of your claim, namely that using a letter helps!
18:07:13 <dmj`> so I added the `:m - Arrayfire` in between the other two lines of the .ghci file
18:07:48 <dmj`> but yet when I do `cabal repl`, it still yells at me 
18:07:53 <dmj`> when I try to call `sum`
18:08:00 <dmwit> Yes, cabal repl *also* loads additional stuff.
18:08:13 <dmwit> Use cabal exec ghci instead.
18:10:31 <dmj`> woa
18:11:25 <dmj`> do I need -isrc too then? It's complaining it can't find the top level module that re-exports all others
18:13:08 <dmj`> dmwit: it's also complaining now that it can't find a third party C library 
18:13:25 <dmwit> ick
18:13:44 <dmj`> dmwit: this is why a letter is better :) at least cabal respects my extra-lib-dirs and include-dirs
18:13:54 <dmwit> I still don't believe the letter actually works.
18:13:58 <dmj`> but I have this same problem with doctest as well
18:14:08 <dmj`> you mean, it doesn't complain about conflicts ?
18:14:13 <dmj`> or A.sum would barf
18:14:17 <dmj`> or just not be found
18:14:22 <dmwit> I mean, import qualified ArrayFire as AF; sum -> still complains
18:15:18 <dmwit> The qualified name will not barf even without the "as AF".
18:15:28 <dmwit> import qualified ArrayFire; ArrayFire.sum -> no complaint
18:15:37 <dmwit> So you are comparing apples and oranges.
18:15:58 <dmwit> You are comparing "include as clause, use qualified name" to "do not include as clause, use unqualified name".
18:16:05 <dmwit> The scientific test changes only one of the two variables at a time.
18:16:57 <dmwit> I am not claiming that including an as clause is a bad idea. Just that it's not a necessary condition for making progress.
18:19:07 <dmj`> dmwit: so plot twist, the A.sum does work
18:19:13 <dmj`> ghc doesn't complain of collision
18:20:22 <dmwit> Why is that a plot twist? It is 100% in line with my predictions.
18:21:06 <dmj`> oh, I read that incorrectly
18:21:06 <pikajude> maybe the plot twist is that you were correct?
18:21:24 <dmj`> I thought you were saying AF.sum -> still complains
18:21:28 <dmj`> but it was sum -> still complains
18:21:30 <dmj`> yes that's true
18:21:51 <pikajude> so what's the point of importing unqualified and renaming anyway?
18:21:59 <pikajude> why not one or the other?
18:22:33 <dmwit> unqualified+rename is handy when most names don't collide, but one or two do and you want a short way to refer to the colliding names.
18:22:53 <pikajude> oh yeah, i guess
18:24:43 <dmwit> Although I think `import hiding; import qualified as` is the more common solution to that problem.
18:33:14 <dmj`> dmwit: and thanks :) this works well
19:05:14 * hackage monoid-extras 0.5.1 - Various extra monoid-related definitions and utilities  https://hackage.haskell.org/package/monoid-extras-0.5.1 (BrentYorgey)
19:08:44 * hackage dual-tree 0.2.2.1 - Rose trees with cached and accumulating monoidal annotations  https://hackage.haskell.org/package/dual-tree-0.2.2.1 (BrentYorgey)
19:13:14 * hackage diagrams-core 1.4.2 - Core libraries for diagrams EDSL  https://hackage.haskell.org/package/diagrams-core-1.4.2 (BrentYorgey)
19:16:08 <koz_> THis is doing my head in a bit - I have 'newtype CM c a = CM (StateT Natural (Writer c) a)', and I'm trying to write 'instance (Monoid c) => MonadWriter c (CM c)', but 'listen' is proving impossible to implement. I know I have to unwrap, then rewrap, CM, but in the middle, I need something of type 'StateT Natural (Writer c) a -> StateT Natural (Writer c) (a, c)', and 'lift listen' (using the
19:16:10 <koz_> WriterT listen) doesn't work.
19:18:44 * hackage active 0.2.0.14 - Abstractions for animation  https://hackage.haskell.org/package/active-0.2.0.14 (BrentYorgey)
19:28:40 <koz_> Never mind - just found out about liftListen and liftPass.
19:39:36 <koz_> Also, do I understand correctly that ((Finite n -> a -> CM c ()) -> CM c ()) is isomorphic to Cont (CM c ()) (Finite n -> a)?
19:43:54 <OmegaDoug> I'm wondering why my program stops working when I consume channel data in forkIO: https://gist.github.com/DouglasBrunner/7dcb498973bc8a58d1ef7ee20d66fa63
19:44:09 <dmj`> has anyone ever gotten doctests to work when a third-party library was required?
19:45:21 <dmj`> I think darwin doesn't allow sub processes to inherit environment variables that would allow the sub process to find a shared library at runtime
19:45:23 <OmegaDoug> If I call the function that reads and displays the channel data in the main thread the program reads and displays the data. But if I call the same function in a forked thread, nothing happens. It's puzzling.
19:47:01 <dmj`> this also breaks cabal-doctest
19:47:51 <MarcelineVQ> koz_: isn't that Cont, ((Finite n -> a) -> CM c ()) -> CM c ())
19:48:05 <koz_> MarcelineVQ: Yeah, I _just_ realized.
19:48:12 <koz_> Guess I'll have to manually do all this, sigh.
19:48:35 <MarcelineVQ> could using -> for m help?
19:48:57 <koz_> MarcelineVQ: Nah, I think I'll save myself sanity and just write against the 'longer' representation.
19:49:02 <koz_> It'll be good mental practice for me.
19:54:02 <koz_> Seriously, Cont-style stuff still breaks my brain.
19:55:32 <MarcelineVQ> Did you have a trampoline when you were younger?
19:55:56 <koz_> MarcelineVQ: Why do you ask?
19:56:49 <koz_> MarcelineVQ: If you can help de-break my brain, I'd appreciate it very much: https://gist.github.com/kozross/60bcf545fbf34dbfeebc05eb99d6c94f
19:58:59 <koz_> The key part I'm not sure how to feed it is the 'Finite n' it needs for the callback.
20:05:21 <ski> koz_ : `ContT () (CM c) (Finite n,a)' / `Cont (CM c ()) (Finite n,a)'
20:06:06 <koz_> ski: Ah, currying. How could I forget.
20:06:22 <koz_> Any chance you could help me un-break my brain with the 'unwrapped' version? https://gist.github.com/kozross/60bcf545fbf34dbfeebc05eb99d6c94f
20:06:52 <koz_> I got as far as 'pure x = DimP (\f -> f _ x)', but I have no 'Finite n' to feed it. And it shouldn't even matter, since it basically just jams 'x' into every index.
20:07:56 <MarcelineVQ> I can't figure out what to import to run this
20:08:05 <ski> s/(Monoid c) => /Monoid c => /
20:08:15 <ski>   deriving (Functor,Applicative,Monad,MonadState Natural,MonadWriter c)
20:08:31 <ski>   deriving Functor
20:08:34 <koz_> ski: It won't let me derive those.
20:08:42 <koz_> (I tried that with GND)
20:08:48 <koz_> Let me just paste the whole thing for clarity.
20:09:04 <ski> oh, okay
20:09:15 <koz_> https://gist.github.com/kozross/784e1028f94605adbb099b2b43e671cc#file-sized-hs-L73
20:10:03 <koz_> I still find continuation-related stuff brain breaking.
20:10:10 <ski>   pure x = DimP (\f -> f _ x)
20:10:22 <ski> what is type of `x',`f',`_' ?
20:10:42 <koz_> x :: a, f :: Finite n -> a -> CM c (), _ :: Finite n
20:11:04 <ski> hmm
20:11:07 <koz_> (according to GHC)
20:11:30 <ski> how is `Applicative (DimP 0 c)' supposed to work ?
20:11:50 <koz_> That's an empty array, so it'd just completely ignore x.
20:11:51 * ski . o O ( s/,/;/ )
20:12:14 <ski> hm
20:12:17 <koz_> (for pure)
20:12:25 <ski> i suppose it might be okay
20:12:44 <ski> i still think you probably need `KnownNat n', though
20:12:48 <koz_> I suspect I do.
20:12:58 <koz_> I usually start with minimal constraints and add as I go.
20:13:06 <ski> and then, loop through all `i' where `0 =< i < n'
20:13:20 <ski> for each of them, call `f i x'
20:13:25 <ski> i think ?
20:13:27 <koz_> And then mash them all together?
20:13:43 <koz_> Isn't that like, traverse_?
20:13:52 <ski> i suppose ?
20:13:58 <koz_> Thanks, that's exactly what I needed.
20:14:12 <koz_> (this will definitely need KnownNat for the obvious implementation)
20:14:17 <ski> (keep in mind i have no idea what this code is supposed to do)
20:14:26 <koz_> ski: No, what you suggested makes all the sense.
20:14:58 * ski would also rename `f' to `k' (or maybe `c'), to conform with convention/tradition
20:15:10 <koz_> Yeah, that makes sense - it's a continuation, right?
20:15:13 <ski> yes
20:15:23 <koz_> (or perhaps 'kontinuation')
20:15:32 <koz_> (from Soviet Russia, where programs run you)
20:15:38 <ski> in this case, it's sortof like a loop body, or a callback, which is going to be used multiple times
20:15:42 <ski> so, it's nqCPS
20:15:47 <koz_> nqCPS?
20:16:00 * ski often uses `c' instead of `k', in such cases .. that's just a personal convention, though
20:16:08 <ski> not-quite-CPS
20:16:42 <ski> because not every call is a tail call
20:16:44 <koz_> ski: What I wanted was 'DimP (\k -> traverse_ (`k` x) finites)'. Thanks so much!
20:16:53 <ski> (because you do something after calling `c')
20:17:05 <ski> (namely call `c' again)
20:17:30 <ski> np :)
20:17:34 <koz_> This translates to 'compile a program which blatantly ignores each index and just shoves x in there, then mash them all together'.
20:18:42 <ski> i suppose if you think of this as something like an array of size `n', then `pure x' just makes an array where all elements are instantiated to `x'
20:18:52 <koz_> Yep, that is, in fact, the idea.
20:19:17 <ski> then, `(<*>)' will do lockstep/"parallel" traversal of two arrays of the same length
20:19:27 <koz_> Yeah - it's zip.
20:19:28 <ski> and `join' will select the diagonal of a matrix
20:19:43 <ski> and you can derive what `(>>=)' does, from that, and `fmap'
20:19:55 * ski nods
20:20:01 <koz_> fmap just applies a pure function to each computed value.
20:20:17 <ski> iow, `join' will apply the same index, `i', both for the outer array, and the selected inner array
20:20:28 <ski> yes, that one is obvious
20:21:21 <ski> hmm
20:22:12 <ski> perhaps i'm not thinking correctly, for `join'
20:22:21 <koz_> I don't plan on this having a Monad instance anyway.
20:22:30 <koz_> (it's gonna have the same instances as the pull array above)
20:23:31 <ski>   join xss = \c -> xss \i xs -> xs \j x -> c (..i..j..) x
20:23:32 <ski> i think ?
20:24:03 <koz_> Is that diagonalization?
20:24:18 <ski> so, rather than having one index, and needing two (diagonalization), it seems we here do the opposite ?
20:24:21 <ski> hmm
20:24:26 <ski> oh
20:24:33 <ski> perhaps one can do diagonalization, anyway
20:24:51 <ski> by checking whether `i == j', and doing nothing, otherwise
20:24:56 <koz_> Yep.
20:25:12 <ski>   join xss = \c -> xss \i xs -> xs \j x -> when (i == j) (c i x)
20:25:45 <ski> it might be nicer if one didn't need to scan the whole matrix, here, hmm
20:26:20 <ski>   newtype DimP n c a = DimP ([Finite n] -> (Finite n -> a -> CM c ()) -> CM c ())
20:26:23 <ski> maybe
20:26:34 <ski> passing a list that it should iterate over, does that make sense ?
20:26:59 <ski> seems too easy .. i suspect something doesn't make sense, here
20:27:29 <koz_> ski: It's not needed - I can 'magic up' every valid index using 'finites'.
20:27:31 <ski> (that just looks like `traverse_', now)
20:27:43 <koz_> Since that will just give me a list of '0, 1, ..., n - 1' in Finite-n form.
20:27:56 <ski> yes, but what if you only wanted say even indices ?
20:28:03 <ski> or only indices `j', where `i == j' ?
20:28:08 <koz_> Filter the list?
20:28:13 <koz_> It's in ascending order.
20:28:22 <ski> would have to do that, before the `traverse_'
20:29:24 <ski>   join xss = \is c -> xss is \i xs -> xs [i] \_i x -> c i x
20:29:58 <koz_> OK, brain is breaking again on liftA2.
20:30:09 * ski isn't sure whether this is going in a direction that is useful for whatever koz_ is doing
20:30:46 <ski> (does remind me of advanced indexing schemes, with strides, and perhaps modulos too)
20:30:58 <koz_> liftA2 is basically zipWith, but in pseudo-Cont form.
20:30:59 <ski> hm, the `zipWith'
20:31:02 <ski> yea
20:31:19 * ski idly wonders whether one would need to do coroutines, there ..
20:31:33 <ski> one might need to, to proceed in lockstep
20:31:40 <ski> hm
20:31:42 <koz_> What do you mean by 'coroutines' here?
20:32:26 <ski> @type flip (flip . foldr) :: [a] -> (forall o. (a -> o -> o) -> o -> o)
20:32:28 <lambdabot> [a] -> (a -> o -> o) -> o -> o
20:32:34 <ski> @type GHC.Exts.build
20:32:36 <lambdabot> (forall b. (a -> b -> b) -> b -> b) -> [a]
20:32:40 <ski> these are inverses
20:32:50 <ski>   build f = f (:) []
20:32:56 <koz_> Yeah - one tears down, the other builds up?
20:33:10 <ski> `forall o. (a -> o -> o) -> o -> o' is the Church representation of `[a]'
20:33:19 <ski> can you write
20:33:31 <ski>   zipWith :: (a -> b -> c) -> (List a -> List b -> List c)
20:33:33 <ski> if
20:33:40 <ski>   type List a = forall o. (a -> o -> o) -> o -> o
20:33:41 <ski> ?
20:33:46 * koz_ thinks hard.
20:34:19 <ski> another way to say it : can you write `zipWith' (the usual one), so that you only deconstruct the two input lists, and do recursion, via `foldr' ?
20:34:26 <ski> (only one call per input list)
20:34:49 <ski> this is a fun exercise i was pondering, and solved, years ago
20:35:18 <ski> (a bit later, i noticed Oleg had pondered more or less the same thing, with, i think, more or less the same solution)
20:35:21 <koz_> You gotta rebuild 'behind you' as you go - you basically pull of the heads, staple them together with the helper function, then carry on.
20:35:29 <koz_> But that's on _non_ Church-encoded lists.
20:35:39 <koz_> s/of/off/
20:35:56 <ski> my intuition here was to construct two "coroutines", each would traverse its list, one step more, then hand over the "baton" to the other coroutine
20:36:31 <koz_> Can you link me to Oleg's teardown? It might help me understand better, because right now, I can't make heads or tails of this.
20:36:31 <ski> each of them would be constructed by a single call to `foldr', on its list (which isn't mentioned more than once)
20:37:54 <ski> "How to zip folds: A library of fold transformers (streams)" by Oleg in 2008-06-16 (?) at <http://okmij.org/ftp/Streams.html#zip-folds>, i think
20:38:00 <ski> (it was a long time since i looked at that)
20:38:14 <ski>   -- I apparently wrote this 2007-04-10.
20:38:18 <ski> that's from my solution
20:39:26 <ski> anyway, i'm not saying coroutines would help you. i just have a hunch that they might help. but perhaps it would require reformulating the `DimP' type a bit, i'm not sure
20:39:46 <koz_> OK, thanks - I will read and think some more.
20:40:26 <ski> btw, iirc, i thought my version was simpler and clearer
20:40:46 <ski> (but perhaps Oleg's allows more functionality. i was only thinking about `zipWith')
20:41:27 <ski> (i'm not sure whether Oleg was thinking in terms of "coroutines", at all. however, istr the approach ending up to do the same, more or less, regardless)
20:41:44 * ski should probably recheck it .. though is a bit too tired atm, to do that now
20:43:17 <ski> if you squint a bit, your type is sortof `a^n'/`Vec n a'. so it seems to me that it could be possible to do the coroutine thing i did. but perhaps not with your current representation
20:43:39 <koz_> It should be sort-of Vec n a - that's the entire point. :P
20:44:35 <ski> (hm, in your case, you have an iterator that gets passed the current index, rather than having a "step" function that gets passed the current element, and a "baton" to continue processing of the remaining elements. so it doesn't look quite the same .. hmmm)
20:45:05 <ski> (well, current index, *and* current element)
20:45:33 <koz_> Yeah, that's the part that's throwing me.
20:46:03 <koz_> I have one computation which produces code that generates an array full of a, and another which does the same for an array full of b, and a way to mash together a and b to get d.
20:46:18 <koz_> And I need to produce with that a computation that generates an array full of d.
20:48:45 <ski> hm, i think i used the "recursive result" part in `foldr', as the coroutine "baton" (representing current, frozen, coroutine control state) to pass along to the other coroutine
20:48:51 <ski> but you don't have that here, hmm
20:49:19 <ski> perhaps one could use `IO' or `ST s', instead, hmm
20:49:41 <ski> (or just introduce some kind of "reverse accumulator", or something)
20:50:10 <ski> hm, i'm probably too tired to think of this, atm
20:50:19 <koz_> It's fine - you've already been a very big help, thank you!
20:50:20 <ski> koz_ : good luck, have fun
20:50:24 <koz_> Thanks - I will try.
20:50:43 <ski> perhaps there's another, nicer approach, that better fits with what you're currently doing
21:10:12 <Guest92596> exit
21:11:51 <docmerlin> hey folks
21:12:14 <docmerlin> I'm very new to haskell, trying to delare a parser, and ghci is giving me a strange error
21:12:30 <docmerlin> import Text.Parsecimport qualified Text.Parsec.Tokenimport Text.Parsec.Language (emptyDef, LanguageDef, GenLanguageDef)assertLang :: LanguageDef st
21:12:35 <docmerlin> arg
21:12:49 <docmerlin> ok that didn't format correctly
21:13:18 <docmerlin> import Text.Parsecimport qualified Text.Parsec.Tokenimport Text.Parsec.Language (emptyDef, LanguageDef, GenLanguageDef)assertLang :: LanguageDef st
21:13:40 <pikajude> don't paste in here, please
21:13:49 <docmerlin> ok, where should I paste?
21:13:56 <pikajude> see topic
21:15:10 <docmerlin> https://gist.github.com/docmerlin/cdfdd560f63dfe5b0ab7cb324ec5327d
21:29:18 <jle`> docmerlin: ghci tries to print everything you type into it
21:29:25 <jle`> or, any expression you give
21:29:55 <jle`> docmerlin: so the error here is that ghci is trying to print assertLang, but assertLang cannot be shown
21:30:37 <docmerlin> thanks
21:30:53 <jle`> there is no string representation of it
21:31:05 <jle`> docmerlin: one thing you can do is, instead, name it
21:31:15 <jle`> let myLang = assertLang :: LanguageDefst
21:31:46 <jle`> assuming assertLang is a value you have already defined
21:32:07 <docmerlin> it isn't.  This is me defining it.
21:32:23 <jle`> oh, hm, that's a different story then
21:32:40 <jle`> ghci takes every <enter> as a new definition
21:32:45 <jle`> (by default)
21:32:53 <docmerlin> ah
21:33:12 <jle`> so it can be tricky to define multi-line things in ghci
21:33:21 <jle`> there's a multi-line mode, :set +m
21:33:28 <jle`> but it just makes it possible, not convenient
21:34:11 <jle`> probably the easiest thing would be to write a file with these definitions and then use :l to load it in and play around with them interactively
21:34:27 <koz_> jle`: Mind helping me unbreak my brain from Cont? https://gist.github.com/kozross/784e1028f94605adbb099b2b43e671cc#file-sized-hs-L76
21:34:38 <docmerlin> thanks jle`
21:35:31 <jle`> koz_: does auto-deriving Applicative with GeneralizedNewtypeDeriving work?
21:35:39 <koz_> Sadly not.
21:35:56 <koz_> Apparently it cannot eta-reduce the representation type enough.
21:36:04 <jle`> ah
21:36:12 <jle`> it doesn't see the continess
21:36:17 <koz_> I can't blame it.
21:36:34 <jle`> er i mean, the compiness
21:36:35 <koz_> It's conting into a giant transformer stack using a curried callback. :P
21:37:16 <jle`> try deriving via ContT () (CM c) :.: (,) (Finite n)
21:38:13 <koz_> So change the definition to ContT () (CM c) :.: (,) (Finite n), or literally use DerivingVia?
21:38:21 <jle`> using DerivingVia
21:38:25 <koz_> Hmm.
21:38:28 <jle`> beucase it shoudl be able to GND an Applicative instance for that
21:39:24 <jle`> koz_: hm, but does that commented thing compile?
21:39:30 <koz_> :.: is from Generics?
21:39:43 <jle`> yeah, or also Compose from Data.Functor.Compose
21:40:06 <koz_> Apparently my Data.Functor.Compose doesn't export that.
21:40:18 <jle`> it's called Compose there i think
21:40:36 <pikajude> :.: is infix Compose?
21:40:48 <koz_> Needs (Monoid (Finite n)) to make that fire, jle`. I already ran into this when I tried
21:40:58 <jle`> pikajude: yeah
21:41:11 <koz_> DimP (fmap (<*>) contF <*> contX)
21:41:12 <jle`> newtype (f :.: g) a = Comp1 (f (g a))
21:41:25 <jle`> koz_: ah, that's the same Applicative instance you'd get
21:41:36 <jle`> koz_: well, hm. what behavior do you wnat?
21:41:44 <jle`> what would you want 'pure' to do
21:41:47 <koz_> Maybe it might be easier to define liftA2. 
21:41:59 <koz_> pure is 'produce the code to generate a vector where everything is an x'.
21:42:04 <koz_> liftA2 is basically zipWith.
21:42:42 <jle`> is DimP n c a supposed to be Vector n a ?
21:42:51 <koz_> It's a push Vector n a, yes.
21:43:26 <koz_> I'm trying out mashing together ideas from Gibbons, Svennson and Svenningson, Zucker.
21:43:30 <jle`> what is the c?
21:43:37 <koz_> The generated code.
21:43:42 <koz_> (any Monoid will do here)
21:44:12 <docmerlin> my experience in fp is lisps, scheme, erlang etc, this is so alien.
21:44:18 <docmerlin> but kind of neat
21:44:41 <jle`> koz_: hm, i'm not quite seeing the representation. can you write the to-and-from? 
21:45:15 <koz_> What do you mean by 'the to-and-from'?
21:45:22 <jle`> docmerlin: yeah :) it's kind of odd, i think, that we lump both ML-like languages like Haskell and lisps as both 'functional programming'
21:45:29 <jle`> docmerlin: when they don't have way too much in common when you hit the ground
21:45:35 <koz_> Even Haskell and ML are actually quite different.
21:45:55 <docmerlin> this feels a lot closer to ocaml than it does to lisp
21:46:28 <jle`> koz_: like , the function from DimP n c a to Vector n a, and back
21:46:30 <jle`> that is an isomorphism
21:46:40 <mozzarella> wait, lisp is ml-like?
21:46:54 <docmerlin> no, he's saying its not
21:47:02 <jle`> mozzarella: no, heh i grouped FP into two broad categories
21:47:06 <docmerlin> its FP but extremely different from ml
21:47:18 <jle`> the ML camp, that draws its 'power' from expressive types
21:47:31 <docmerlin> rust, ocaml, etc etc
21:47:36 <jle`> and the lisp camp, which draws its power from metaprogramming
21:48:11 <koz_> jle`: I can just quote the paper: "The Push array is a higher-order function whose result is a monadic computation. As input, this higher-order function takes a write-function (in my case, Finite n -> a -> CM ()) that represents a way to consume the elements produced (for example, by writing them to memory). In essence, a Push array is a function accepting a continuation.
21:48:28 <docmerlin> are there compile time functions in haskell?
21:48:31 <koz_> The idea is that a push array builds up the _code_ necessary to do the array things you wanna do.
21:48:38 <koz_> docmerlin: There's several ways to do CTE if you want it.
21:48:44 <docmerlin> neato
21:48:48 <jle`> docmerlin: there are, but it's more of an escape hatch if you can't do it the normal way
21:48:53 <koz_> However, it's not often done.
21:49:04 <docmerlin> Ah, so it isn't a common performance optimization?
21:49:10 <jle`> docmerlin: and actually a lot of language development in Haskell is done in the aim of reducing the necessary metaprogramming
21:49:12 <koz_> docmerlin: There's usually not a need for it.
21:49:46 <koz_> If I think of the standard 'high performance' Haskell libraries, such as vector, I don't think many of them bother with CTE of any sort.
21:50:09 <MarcelineVQ> depends if rewrite rules count
21:50:35 <koz_> MarcelineVQ: I guess yeah, if you count rewrite rules as CTE, then they all use it, as does GHC itself for things like list optimization.
21:50:52 <pikajude> if you think about it, basically everything GHC does is compile time execution
21:51:40 <docmerlin> er fair enough, and llvm does the rest?
21:51:46 <koz_> docmerlin: Optionally.
21:52:05 <koz_> (the default backend isn't LLVM, because surprisingly, LLVM isn't optimized for compiling functional languages a la Haskell)
21:52:10 <koz_> (someone wrote about that recently in fact)
21:52:38 <docmerlin> what is  the best backend? have a link?
21:52:48 <koz_> docmerlin: There is no 'best' back-end. :P
21:52:50 <jle`> the difference between that and what i would usually call metaprogramming/CTE is that it isn't really written in "normal code"
21:52:53 <pikajude> the rts library?
21:53:02 <koz_> To the writeup, however, one sec.
21:53:07 <jle`> writing rewrite rules is done in a special meta-language
21:53:11 <jle`> and not first class haskell
21:53:27 <jle`> and also dealing with ghc optimizations can be magical as well 
21:53:52 <docmerlin> thats a shame, one thing I liked about go was performance was pretty straightforward to implement
21:54:09 <koz_> docmerlin: That's because Go does _basically nothing for you_.
21:54:09 <docmerlin> like it was easy to modify stuff to go faster usually just by looking at it
21:54:13 <docmerlin> thats true
21:54:16 <koz_> It doesn't even have proper generic programming.
21:54:30 <koz_> Sure, if you resemble C minus minor pain points, everything's 'straightforward'. :P
21:55:01 <docmerlin> its like c + GC + green threads + really nice ergos
21:55:13 <koz_> Yeah, and literally nothing else.
21:55:36 <koz_> Also, it seems I am bad at locating information.
21:55:54 <koz_> docmerlin: https://andreaspk.github.io/posts/2019-08-25-Opinion%20piece%20on%20GHC%20backends.html
21:55:58 <jle`> koz_: hm if you can write those to/from functions i could see the correspondence better
21:56:07 <jle`> and then even at least you can write <*> in terms of those
21:56:34 <koz_> jle`: Those functions depend very heavily on what choice you make for 'c'. Essentially, push arrays are code generator monads.
21:59:20 <jle`> so is (DimP n c a) supposed to represent a vector, and <*> is vector zipping?
21:59:57 <koz_> (DimP n c a) is indeed supposed to represent a vector. <*> is basically zipWith ($), while liftA2 is zipWith.
22:00:15 <koz_> I think implementing liftA2 might be easier in this case.
22:03:38 <koz_> Maybe it is easier to not employ ContT like that, and just write it in the full form, which is (a newtype around) (Finite n -> a -> CM c ()) -> CM c ().
22:04:17 <koz_> The main thing that makes this annoying is that the continuation wants _two_ things instead of one.
22:06:01 <jle`> if you write toVec/fromVec
22:06:16 <jle`> then you can do x <*> y = fromVec (toVec x <*> toVec x)
22:23:14 * hackage conduino 0.1.0.0 - Lightweight composable continuation-based stream processors  https://hackage.haskell.org/package/conduino-0.1.0.0 (jle)
22:23:39 <jle`> oh noooo i uploaded the wrong package lol
22:23:46 <koz_> Was about to say lol.
22:24:03 <pikajude> that was a fast deprecation
22:24:32 <jle`> i guess i'm at least squatting the name
22:24:43 <koz_> conduino isn't exactly a common name. :P
22:25:02 <jle`> that's what i get for having so many packages open at once :|
22:25:44 * hackage emd 0.1.10.0 - Empirical Mode Decomposition and Hilbert-Huang Transform  https://hackage.haskell.org/package/emd-0.1.10.0 (jle)
22:31:22 <koz_> I think I need to better understand co and contravariance for function types.
22:31:35 <koz_> All I know is that in the case of a -> b, a is contravariant, b is covariant.
22:31:45 <koz_> But once you get into anything more complex, I clearly have no idea what I'm on about.
22:31:56 <koz_> Like, if we have a -> b -> c, what's the variance of each of these?
22:32:23 <jle`> a -> (b -> c) -- one trick i've seen is to think of it like multiplication
22:32:40 <koz_> OK, so a -> (b -> c) -- a is clearly contravariant, right?
22:33:24 <jle`> "input" is negative, "output" is positive
22:33:38 <koz_> So in this case, a is negative, (b -> c) positive?
22:33:39 <jle`> and when things start getting nesting, the rules are like for multiplication
22:33:49 <jle`> yeah, a is negative, b -> c is positive
22:33:54 <jle`> and b is negative too
22:33:59 <jle`> it's negative in the positive
22:34:07 <koz_> And c is positive in the positive?
22:34:12 <jle`> yeah
22:34:24 <koz_> So a is contra, b is contra, c is co?
22:34:25 <jle`> (a -> b) -> (c -> d)
22:34:49 <jle`> a is negative in the negative, so it's positive
22:34:52 <jle`> and so it's covariant
22:35:04 <koz_> And so is d, right?
22:35:11 <koz_> But b and c are contra?
22:35:35 <jle`> yeah
22:35:45 <koz_> OK, so let me try on my current example
22:35:54 <koz_> I have (Finite n -> a -> CM ()) -> CM ()
22:36:01 <koz_> That second CM () is co.
22:36:15 <koz_> Then on the 'negative' side, I really have (Finite n -> (a -> CM ())
22:36:27 <koz_> So Finite n is co as well, since it's negative of negative.
22:37:02 <koz_> (a -> CM ()) is 'negative', so a is co, and the remaining CM () is contra?
22:38:00 <koz_> OK, that makes... some sense then.
22:38:06 <jle`> yeah, so here your covariant variables are Finite n, a, and the second CM ().  and the contravariant one is just the first CM ()
22:38:52 <koz_> A better question - how on earth do I construct fmap for stuff that deeply nested without leaning on GHC?
22:39:09 <pie__> cabal sandbox init is telling me to use new-sandbox instead but new-sandbox isnt even a valid command
22:41:24 <jle`> koz_: without using something automated, just a lot of manual plumbing i think
22:41:54 <koz_> Yeah, that makes sense. I still find this stuff extremely brain-bending.
23:04:00 <koz_> jle`: Hmm, this is relevant to my interests: http://www.cse.chalmers.se/~josefs/talks/ArrayDual.pdf
23:04:25 <koz_> In short - push arrays are monads (and thus, Applicatives), but only semi-efficiently, which apparently _can_ be addressed with static size!
23:05:55 <koz_> And you were right about the toVec-fromVec thing - according to this, >>= requires intermediate allocation. The slides also say that this can be made efficient with static sizes, but it required indexed monads. Not sure if that means that there's _no_ need for an intermediate array?
23:15:47 <jle`> ah, i see
23:15:55 <jle`> the input is the writing function
23:16:00 <koz_> Yes.
23:16:02 <jle`> is there any reason you're using Cont to represent this?
23:16:12 <koz_> None - in fact, I've switched away from it.
23:16:21 <koz_> I saw that it was actually Cont, and thought it _might_ make it easier.
23:16:22 <koz_> (it didn't)
23:16:32 <koz_> Let me show you what I have so far.
23:17:11 <koz_> https://gist.github.com/kozross/f50f9b4e7f830be891547f84bdc7ed96
23:17:35 <jle`> it loooks like the monad/applicative instance they have there are the Vector instances
23:17:37 <koz_> http://okmij.org/ftp/Haskell/zip-folds.lhs <-- this seems highly relevant, but I'm not sure I understand it properly, or whether I can do something similar in my case.
23:17:47 <jle`> like, the cross product instances
23:17:51 <koz_> For Pull arrays, yes.
23:18:02 <koz_> Because for pull arrays, the isomorphism is obvious.
23:18:05 <koz_> _Push_ is harder.
23:18:16 <koz_> (page 30 for push monad)
23:18:29 <jle`> their Push monad instance is the cross product instance
23:18:35 <jle`> you can tell because return is a singleton vector
23:18:55 <koz_> So it's basically like the default list, not ZipList, in intent?
23:19:00 <jle`> yeah
23:19:05 <jle`> your return would be different
23:19:10 <koz_> Indeed it is.
23:19:36 <jle`> it'd be return x = Push $ \write -> traverse (`write` x) finites
23:19:38 <koz_> It basically rips through all valid indices, and calls the continuation on every one of them, 'burning in' the element you want written everywhere.
23:19:58 <koz_> https://gist.github.com/kozross/f50f9b4e7f830be891547f84bdc7ed96#file-sized-hs-L77
23:20:01 <koz_> I think that's basically that.
23:20:25 <jle`> ah yeah exactly :)
23:20:35 <koz_> liftA2 is thus zipWith.
23:20:40 <koz_> But that's giving me massive conniptions.
23:21:50 <koz_> I'm not sure it's possible without materialization.
23:21:51 <jle`> i think the simple way of questionable efficiency would be to just allocate both vectors
23:21:57 <jle`> and then read from it
23:21:59 <koz_> Yeah - this is basically what they do.
23:23:01 <jle`> yeah, allocate two mutable vectors, generate both of them, freeze them, zip them
23:23:13 <koz_> (while collecting all writes)
23:23:25 <jle`> hm i don't think you would need to
23:23:50 <koz_> Ah yeah, because the resulting continuation would handle this.
23:23:58 <koz_> It's basically CTE in a weird sort of way. :P
23:27:16 <fraktor> So I'm querying an API endpoint to get some data and tried to break my key to see what it would do. As far as I can tell, so long as your key isn't empty, it happliy gives you the data. Naughty naughty
23:27:48 <jle`> koz_: hm you could even skip the freezing part
23:27:58 <jle`> but that would keep the arrays in memroy so maybe not a good idea
23:28:15 <koz_> Yeah, that's not a good plan definitely.
23:28:17 <jle`> fraktor: tricksy
23:28:35 <koz_> Such secure.
23:28:38 <koz_> Very protect.
23:29:42 <jle`> koz_: i added a comment with an implementation i had in mind
23:29:45 <fraktor> Oh also, I'm using cabal to build my project, and I'm including a few different libraries. The resulting binary is 28M, which seems a little large; is that because it's a debug build, or are binaries just large in general?
23:30:57 <koz_> jle`: Ah, yeah, I see the idea here. I guess the freezes are just there to enable fusion or something?
23:31:18 <jle`> koz_: you don't need to freeze but at least it will release fvec and xvec from memory
23:31:36 <jle`> otherwise you could directly do the reading from the mutable vectors when you traverse 'finites'
23:31:42 <koz_> Yeah, that's true.
23:31:50 <koz_> I'll just use that implementation then - thanks!
23:31:56 <jle`> fraktor: hm, that does feel a little large, but 20MB ish for a small project isn't too out of the ordinary
23:32:21 <jle`> i believe a lot of it is just from the runtime
23:32:27 <pie__> hehe "Some features described in this manual are not implemented. If you need them, please give us a shout and we’ll prioritize accordingly."
23:32:31 <pie__> wrong chan
23:32:38 <jle`> fraktor: so there's a base chunk that is the runtime, and only a small part is your actual special program logic
23:33:08 <jle`> so it's like the y-intercept of the binary size vs. project size 
23:33:25 <pie__> is the rts really that big though
23:33:35 <fraktor> I think it mostly comes from the libraries though. Like, earlier one it was about 1.1M.
23:33:45 <jle`> hm, yeah now that i think about it, i think i'm confusing the binary size with memory
23:33:48 <jle`> runtime memory
23:33:56 <koz_> jle`: Are unsafeFreezes OK there, or do they have to be safe freezes?
23:33:59 <jle`> yeah, for a 28m project a lot of it could just be the library
23:34:00 <fraktor> And I get why the libraries as a whole would be that big, but I'm only using pretty small parts of them.
23:34:25 <jle`> koz_: unsafe freeze probably ok here because you don't mutate the vectors anymore
23:35:18 <jle`> it's funny how different the 'unsafe' means for unsafeNew and unsafeFreeze
23:35:36 <jle`> unsafeNew just means you'll get wonky data when you read from the items that you don't initialize it
23:35:41 <koz_> Yeah. Also different to unsafePerformIO. :P
23:35:43 <jle`> unsafeFreeze means you'll literally break referential transparency
23:35:54 <jle`> unsafeFreeze is closer in nature to unsafePerformIO i think
23:36:10 <jle`> because you can use the same value twice and get different results if someone mutates the ref in a different thread
23:36:11 <fraktor> Hmm.  Reading online it looks like the libraries as a whole get bundled in whether they're used or not. Sad.
23:36:15 <koz_> Yep.
23:36:19 <jle`> fraktor: oh, that's interesting
23:36:45 <fraktor> It looks like there's a feature you can modify for GHC/Cabal though.
23:52:14 * hackage hmp3-ng 2.7.0 - A 2019 fork of an ncurses mp3 player written in Haskell  https://hackage.haskell.org/package/hmp3-ng-2.7.0 (galen)
