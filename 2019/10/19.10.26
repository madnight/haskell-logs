00:07:58 <tomjaguarpaw> How can I run a naked .hs file in the cabal v2 package environment?
00:08:15 <tomjaguarpaw> I have `test.hs` in my home directory, and I just want to run it (or compile it) without writing a .cabal file
00:09:29 <f-a> tomjaguarpaw: with cabal scripts
00:09:43 <f-a> #! /usr/bin/env cabal
00:09:53 <f-a> and then somethin- let me fetch an example
00:10:36 <f-a> https://www.haskell.org/cabal/users-guide/nix-local-build.html there tomjaguarpaw ("what a script looks like") 
00:11:51 <tomjaguarpaw> Oh, that's interesting.
00:12:15 * hackage twitter-types 0.9.0 - Twitter JSON parser and types  https://hackage.haskell.org/package/twitter-types-0.9.0 (TakahiroHimura)
00:12:29 <tomjaguarpaw> Is there no way of telling cabal "just choose a sensible maximal set of compatible packages"?
00:13:29 <sclv> you can also use env files
00:13:44 * hackage twitter-types-lens 0.9.0 - Twitter JSON types (lens powered)  https://hackage.haskell.org/package/twitter-types-lens-0.9.0 (TakahiroHimura)
00:13:45 <sclv> to create a package env your stuff shares
00:13:56 <f-a> tomjaguarpaw: I don't think so, imagine the conflicts etc. In cabal 1 you could install stuff globally but then again, it was why people worked hard to deliver v2!
00:14:24 <sclv> you can install stuff into an env in v2
00:14:44 <sclv> see the cabal-env tools
00:18:31 <tomjaguarpaw> Hmm, now I'm really confused.  What is the v2 way to install the package I am developing?
00:18:39 <tomjaguarpaw> cabal v2-install seems to be a no-op
00:19:13 <sclv> pass the —lib flag to install a lib
00:19:24 <sclv> It does exes by default
00:19:37 <sclv> also you should be on cabal 3
00:19:49 <sclv> The earlier versions are v partial
00:20:09 <tomjaguarpaw> Oh OK
00:23:41 <tomjaguarpaw> Interestingly cabal-install-3.0.0.0 seems to use cabal-the-library Cabal-2.4.1.0
00:28:45 <phanimahesh> I found stack creating package.yaml along with .cabal files, and editing .cabal files to add dependencies directly is showing a warning.
00:28:45 <tomjaguarpaw> Oh *and* it uses Cabal-3.0.0.0???
00:28:59 <phanimahesh> is package.yaml the new way to do things?
00:29:54 <tomjaguarpaw> f-a, sclv: Thanks for your help.  I will see how far I can get.
00:30:40 <phanimahesh> Hunting around the internet shows it's hpack, a new format, and .cabal can be generated from it.
00:31:09 <f-a> tomjaguarpaw: good
00:31:09 <phanimahesh> But I couldn't find if it is widely used
00:31:26 <Rembane> phanimahesh: If you can avoid it, don't use package.yaml it just adds another level of indirection to very little gain. 
00:31:34 <Rembane> ...imo
00:32:22 <tomjaguarpaw> Compiling cabal is more taxing on my machine than compiling GHC!
00:33:47 <DigitalKiwi> Rembane: you're not alone
00:34:02 <f-a> tomjaguarpaw: to speed things up a bit, use -j (if you haven't used it already)
00:34:37 <tomjaguarpaw> I think that may consume more memory than my machine has ...
00:35:16 <tomjaguarpaw> Although embarrassingly I just remembered I installed cabal 3 yesterday with ghcup :)
00:35:34 <Rembane> DigitalKiwi: Good. I should really create a stack template that doesn't create the package.yaml file. 
00:37:03 <DigitalKiwi> broke: use hpack, woke: use stack, but not hpack, bespoke: don't use stack
00:38:41 <phanimahesh> Oh, okay. I've always only worked with stack, never directly with cabal. I'll just ignore package.yaml for now then
00:40:10 <Rembane> phanimahesh: Oh, and take a look at .gitignore in the project folder if you use git, you might want to remove the *.cabal in that file. 
00:40:41 <tomjaguarpaw> OK, now I've got the most bizarre v2-configure failure: "(conflict: requires ViewPatterns)".   What on earth does that mean?
00:43:12 <phanimahesh> Rembane: oh wow. it is ignored, yes. So stack is encouraging package.yaml
00:43:33 <tomjaguarpaw> Aha "This is a known problem when using cabal 3 on a project previously built with cabal 2.x. Delete your dist-newstyle directory or clean your repository then retry."
00:43:47 <phanimahesh> Lemme experiment with what happens if I edit package.yaml and not cabal, or if .cabal is deleted, etc etc
00:44:57 <phanimahesh> tomjaguarpaw: :') The joys of ever changing toolchains. I love "Known Problems"(tm)
00:46:06 <tomjaguarpaw> OK, so I am running cabal v2-install in a directory with a .cabal file, but it's *also* trying to install the package whose .cabal file is in a subdirectory.  Why!?
00:46:10 <tomjaguarpaw> And how do I get it to stop?!
00:46:19 <Rembane> phanimahesh: It is, the cabal file is a derived file in the package.yaml world. 
00:47:08 <tomjaguarpaw> Why on earth is the command for "install the package whose .cabal file is in the current directory" the same as the command for "install a package from a centralised network server"??
00:52:17 <tomjaguarpaw> And why does v2-install require rebuilding dependent packages but v2-build does not?  So much unexpected behaviour ...
00:52:37 <tomjaguarpaw> And it's also rebuilding Cabal-3.0.0.0?? What??
01:00:36 <phanimahesh> tomjaguarpaw: I thought omitting the package name installs project from current directory and using the name installs from centralized network server?
01:01:00 <phanimahesh> or is that my js (npm/yarn) talking?
01:06:14 <phanimahesh> experiment results: package.yaml is considered the source of truth, and a warning is displayed on edits to .cabal. It is silently generated if deleted, and ignored by default in git.
01:06:54 <phanimahesh> I've decided to embrace package.yaml. Makes my life easier if I don't fight the toolchain much. Hopefully.
01:07:50 <phanimahesh> * it being .cabal file in [it is silently gen...]
01:37:23 <phanimahesh> @pl \r -> fmap (rab r) ra r
01:37:23 <lambdabot> rab `ap` ra
02:12:55 <ollehar> Test?
02:13:09 <ChaiTRex> ollehar: Hello
02:13:11 <gonz_> Test!
02:13:22 <ollehar> +1
02:14:40 <gonz_> it :: Integral a => a -> a
02:15:34 <ollehar> ^^
02:16:55 <gonz_> Not even correct, SMH
02:25:32 <Ariakenom> gonz_: you're safe. nobody understands the number classes :p
02:26:57 <gonz_> heh
03:07:35 <tomjaguarpaw> phanimahesh: Yes, that's right.  But they shouldn't both be called "install".  
03:08:20 <maerwald> tomjaguarpaw: v2-install doesn't require rebuilding depdnent packages
03:08:32 <maerwald> are you talking about local packages?
03:08:43 <maerwald> like source-repository in cabal.project?
03:10:01 <tomjaguarpaw> I "cabal v2-build"ed opaleye in my local git checkout.  Then I "cabal v2-install"ed it.  The latter decided to build and install a whole bunch of depended-upon packages, including Cabal!
03:10:40 <tomjaguarpaw> And rerunning the exact same command now fails?!
03:10:47 <tomjaguarpaw> This is unbelievable
03:11:38 <tomjaguarpaw> I ran "~/.ghcup/bin/cabal v2-install  --lib opaleye", it installed.  I just reran the exact same command on the exact same source tree and it now has a dependency conflict!
03:13:53 <tomjaguarpaw> Because of something to do with directory ...
03:16:48 <maerwald> yare you running v2-install from different directories?
03:17:27 <tomjaguarpaw> No, the same place each time
03:17:36 <tomjaguarpaw> What should I be doing?
03:18:05 <maerwald> why are you trying to install a lib manually?
03:18:30 <tomjaguarpaw> Because I'm its developer!
03:18:56 <maerwald> Cannot follow
03:19:26 <maerwald> Be more specific about your use case
03:19:36 <tomjaguarpaw> I am adding a new feature to Opaley
03:19:39 <tomjaguarpaw> I want to install it
03:19:44 <maerwald> and then?
03:19:45 <tomjaguarpaw> so I can compile other packages against it
03:19:48 <tomjaguarpaw> to test a new feature
03:19:51 <maerwald> well, you use https://www.haskell.org/cabal/users-guide/nix-local-build.html#specifying-packages-from-remote-version-control-locations for that
03:20:36 <tomjaguarpaw> But there isn't a version on github
03:20:39 <tomjaguarpaw> I'm still developing the feature
03:20:59 <maerwald> you can point to a local directory in cabal.project too
03:21:10 <tomjaguarpaw> I really don't want to do that
03:21:22 <tomjaguarpaw> I just want to install this particular version of my package into the normal cabal place
03:21:56 <tomjaguarpaw> and then use it from other packages in the normal cabal way
03:22:40 <maerwald> if anything triggers a rebuild of the lib for whatever reason in any package (e.g. flags), you lost your changes anyway
03:22:45 <maerwald> so it isn't reliable
03:23:28 <tomjaguarpaw> This is a mess
03:23:28 <maerwald> the only way to reliably force a package to use a specific *state* of a package is via the mentioned methods
03:23:44 <tomjaguarpaw> Hmm
03:24:26 <maerwald> https://www.haskell.org/cabal/users-guide/nix-local-build.html#specifying-the-local-packages
03:24:56 <jzyamateur> So is this a common pattern/idiom in defining monoid instance for structures, given substructures are monoids, e.g. `mempty = pure mempty` and `mappend = liftA2 mappend` ?
03:27:46 <tomjaguarpaw> maerwald: How do I use that in a "#!/usr/bin/env cabal" setup?
03:27:53 <tomjaguarpaw> I get: Warning: script block:2:1: Unknown field: "packages"
03:28:41 <maerwald> aww, yeah, that syntax is horribly limited
03:29:26 <tomjaguarpaw> maerwald: So what do you suggest I do?  I want to test my local changes to my library by writing a small .hs file in an arbitrary directory on my filesystem.
03:29:50 <maerwald> I would just create a dummy project and a cabal.project file
03:29:52 <maerwald> not that much work
03:31:13 <tomjaguarpaw> So are .cabal files not the recommended way anymore?
03:31:29 <maerwald> tomjaguarpaw: of course, cabal.project files are just additional
03:31:40 <maerwald> they can encompass multiple projects
03:31:49 <tomjaguarpaw> So much complexity
03:31:54 <tomjaguarpaw> This is grim
03:32:08 <maerwald> why so... imagine you wanna bundle 5 libraries 
03:32:11 <maerwald> how to do it?
03:32:27 <tomjaguarpaw> We need a solid API for building packages
03:32:38 <tomjaguarpaw> and tools can call that however they like
03:33:06 <__monty__> Sounds like Cabal.
03:33:33 <tomjaguarpaw> Notice the adjective "solid"
03:33:49 <maerwald> tomjaguarpaw: a foo.cabal file describes a *single* project... that is the idea. cabal.project allows to set information that goes beyond that (such as pulling dependencies from remotes)
03:34:10 <maerwald> imo, the separation of these config files makes sense
03:34:40 <tomjaguarpaw> So instead of running a simple script I have to set up a dummy project with fully specified .cabal and cabal.project files?
03:34:51 <tomjaguarpaw> And compile my 10 line script as though it were a project?
03:34:52 <maerwald> it's not that hard
03:34:55 <maerwald> yeah
03:35:11 <tomjaguarpaw> This is absurd
03:35:28 <tomjaguarpaw> I would dread to be a new Haskeller now
03:35:38 <maerwald> well, how about you use cabal new-repl in your library checkout and then load a source file into it?
03:36:58 <tomjaguarpaw> How do I specify the additional dependencies of that source file?
03:39:08 <maerwald> cabal new-repl --package ...
03:39:25 <tomjaguarpaw> Aha!
03:39:39 <maerwald> no
03:39:40 <maerwald> cabal new-repl --build-depends lens
03:39:42 <maerwald> for example
03:40:36 <tomjaguarpaw> Hmm, that doesn't actually seem to work
03:42:22 <tomjaguarpaw> ~/.ghcup/bin/cabal new-repl --package microlens --package tmp-postgres, but then when I try to load my file I get "Could not find module ‘Database.Postgres.Temp’", "Could not find module ‘Lens.Micro’"
03:42:41 <maerwald> use --build-depends
03:42:47 <maerwald> not --package
03:42:56 <tomjaguarpaw> Ah, thanks, didn't see that
03:45:23 <tomjaguarpaw> Right, it loads.
03:45:44 <tomjaguarpaw> I have loaded my module with :l, but I can't access any of its contents ...
03:45:49 <tomjaguarpaw> main
03:45:49 <tomjaguarpaw> <interactive>:6:1: error:
03:45:49 <tomjaguarpaw>     • Variable not in scope: main
03:45:56 <tomjaguarpaw> This may be my unfamiliarity with ghc
03:48:49 <tomjaguarpaw> OK, so I need to "import Main" and I also need to have an explicit export list (why?)
03:53:12 <tomjaguarpaw> And somehow cabal repl overwrites my PATH?
04:00:16 <tomjaguarpaw> Hmm, maybe it doesn't overwrite my PATH.  Not sure what happened there.  
04:00:21 <tomjaguarpaw> maerwald: Thanks, this is a working solution!
04:12:14 * hackage lightstep-haskell 0.1.2 - LightStep OpenTracing client library  https://hackage.haskell.org/package/lightstep-haskell-0.1.2 (DmitryIvanov)
04:55:23 <dignissimus> Is there a function that takes a function and a list of values and returns a list of tuples containing the values and the result of applying the fucntion to them
04:55:44 <dignissimus> So something like `(a->b) -> [a] -> [(a, b)]`
04:59:39 <dibblego> @type fmap . (<*>) (,)
04:59:40 <lambdabot> Functor f => (a1 -> a2) -> f a1 -> f (a1, a2)
05:00:47 <maerwald> that's quite obscure
05:03:15 <maerwald> dignissimus: hoogle is your friend, if there is nothing, then just roll your own. Sometimes it also helps to alternate [a] with 'f a' in the hoogle search
05:58:24 <bartavelle> is there a template haskell function that turns a value into the "Q Exp" that represents that value ?
06:02:20 <heatsink> bartavelle: lift
06:02:31 <heatsink> It's a method of class Lift
06:03:11 <bartavelle> argh, that sounds so obvious
06:03:11 <bartavelle> thanks!
06:31:06 <sshine> dignissimus, I might have done '\f -> map (id &&& f)'
06:34:46 <heatsink> One of the API tricks I've seen is to define a default value of a record type so you can override different fields, like defaultFoo { extension = "ogg" }
06:35:32 <heatsink> Is it a good practice to provide default values like this where some fields are _|_ and you must assign them?
06:36:31 <glguy> That sounds like a bad idea
06:36:44 * hackage lightstep-haskell 0.1.3 - LightStep OpenTracing client library  https://hackage.haskell.org/package/lightstep-haskell-0.1.3 (DmitryIvanov)
06:38:08 <heatsink> I see
06:42:01 <unfixpoint> Stack question: What could be the reason why I get `Could not find discord-haskell-1.1.3 on Hackage` when I do exactly what they tell me to do?
06:42:25 <unfixpoint> (Stack upgrade tells me I'm at the newest version, and update tells me I'm in sync)
06:42:56 <unfixpoint> (Selected mirror: https://s3.amazonaws.com/hackage.fpcomplete.com/)
06:45:44 <unfixpoint> heatsink: Yeah, don't do that if the values are needed later. If they're not you should probably use `Maybe v` instead, also consider using `Data.Default`'s typeclass it'd be really nice if everyone would adhere to that :)
06:46:16 <glguy> No, don't consider using Default
06:46:31 <glguy> it just makes the code harder to read without providing any extra generalization
06:47:39 <unfixpoint> What's exactly harder to read, if they decide to do? It's not about generalisation, but uniformity
06:48:00 <glguy> It just makes the user do some extra type inference to read the code
06:48:14 <glguy> for a superficial benefit of getting to use the name def
06:49:54 <unfixpoint> It's a matter of personal taste, I guess. I like it, you don't. So they should consider it, whether they use it or not, is up to them
06:50:06 <glguy> It's just a bad practice to get into
06:50:22 <glguy> and the topic was "good practice"
06:53:12 <unfixpoint> `def & setPort p` isn't really harder to read than `defaultSettings & setPort p`, especially given that it most likely succeeds `runTLSSocket` or `runSettingsSocket`. Most of the time it's immediately obvious what `def` stands for, if it's not there's probably a (smart-)constructor that should be used
06:54:56 <glguy> "defaultSettings" is rarely descriptive enough, it's better to have a named setting that's easy to distinguish as it's like to be used in a variety of situations, it's often not obvious what the "defaults" are and the programmer will want to know
06:55:18 <glguy> when you want to make a new set of "defaults" its good to not having to change the old ones under the old "magic" def name
06:57:51 <unfixpoint> I see your point, but I disagree. Imo it's the job of documentation, to describe that behaviour not the code.
06:58:21 <glguy> The programmer will have to do type inference to know what documentation to look up
06:58:33 <glguy> so by using a unique name you make it easier to find that documentation
06:58:36 <glguy> so we agree on tha tone
06:58:39 <unfixpoint> In any case, I think we can all agree on "It's a really bad idea, to provide default values that contain _|_."
07:02:32 <glguy> yup
07:03:05 <unfixpoint> A good argument: error messages might get trickier to decipher. But having to do additional "type inference" is no biggie if they already decided to read the docs, imo
07:03:23 <glguy> No, reading the docs doesn't mean that type inference is easy
07:03:57 <glguy> The only advantage of using def is that you save on typing
07:04:18 <glguy> which is rarely the thing you're optimizing for in programming
07:07:06 <unfixpoint> Anyway, does someone using stack know where my issue could come from?
07:08:27 <unfixpoint> (nvm, there's #haskell-stack - I should probably use that channel instead)
07:11:50 <glguy> unfixpoint: stack find that package when I try
07:12:05 <glguy> You have it listed in your extra-deps?
07:12:54 <glguy> unfixpoint: Do you get any interesting output building with -v ?
07:13:11 <unfixpoint> Yeah, it is
07:14:07 <unfixpoint> (This is the stack.yaml: pastebin.com/xQuHwQyx)
07:14:39 <unfixpoint> Nah, `-v` doesn't give me additional information
07:15:50 <unfixpoint> This is so weird, I'll just remove ~/.stack safe the config.yaml and will try again..
07:17:09 <MarcelineVQ> it would save you time to just delete .stack/indices  if you're wanting to start hackage over for stack
07:18:35 <unfixpoint> ~5s late, haha  damn..
07:18:42 <glguy> unfixpoint: I think you'll run into some trouble; that version of discord-haskell isn't supported by the lts you're using
07:19:12 <glguy> The versions of http-client and req are too old in it
07:19:42 <unfixpoint> Ugh, that's what they suggest [here](https://github.com/aquarial/discord-haskell/wiki/Installing-the-Library)
07:22:02 <glguy> using the Cabal - Haskell method at the bottom works
07:24:29 <glguy> As checked by: cabal repl -w ghc-8.6.5 --build-dep discord-haskell
07:24:37 <hasnokell> Hey guys, has anybody got an idea how to write something like "any(\x -> checkFnc x)[1..n]" shorter?
07:24:50 <glguy> any checkFnc [1..n] ?
07:25:43 <hasnokell> right, but I would like to use the implementation of checkFnc right there, sorry :D
07:26:17 <hasnokell> in order to have it shorter overall, because the implentation of checkFnc counts, too
07:26:26 <MarcelineVQ> which part are you hoping to shorten?
07:28:08 <hasnokell> everything - the whole statement is "any(\c -> c*c `mod` a == b `mod` a)[1..a]"
07:28:10 <geekosaur> ghc knows how to inline stuff, and when it'll be a win
07:28:44 <unfixpoint> glguy: Cheers for checking on this issue! I'm trying w/ lts-14.11 just now, but it will take a while ^^
07:44:54 <unfixpoint> glguy: It works now, seems like removing .stack to get that weird error away & the switch to lts-14.11 to get rid of the compilation error(s) did the trick.
07:45:30 <unfixpoint> No idea how, I managed to bork my ~/.stack, besides the config.yaml I never touched it by hand
07:53:17 <bolver> is there a good rule of thumb on when to create your own data type vs when to use type synonyms?
07:57:12 <ivegotasthma> hello
07:57:19 <ivegotasthma> I'm trying to learn haskell by writing a web server
07:57:31 <ivegotasthma> what framework should I pick? I'm trying with yesod but it's a bit too much
07:58:31 <dsal> bolver: type synonyms are more useful for documentation or maybe abbreviation than anything.  If you want things like compilation safety and behavioral differences, make a type.
07:59:16 <dsal> ivegotasthma: If you're going to use a web framework to write a web server to learn haskell, that's not what you're going to learn.
07:59:23 <sm[m]> ivegotasthma: scotty or spock are a bit simpler
08:00:01 <bolver> dsal: what did you mean by `behavioral differences`?
08:00:37 <ivegotasthma> dsal: what else do you suggest?
08:00:45 <dsal> bolver: Like, if you need instances or even an ability to distinguish the types.
08:01:08 <dsal> ivegotasthma: haskellbook.com -- the long road is shorter.
08:01:23 <dsal> I wrote a web-based application in haskell before I learned haskell.  It was frustrating and I didn't learn much.
08:01:39 <ivegotasthma> ah, okay. I have the book already
08:01:53 <sm[m]> bolver: I usually start with a type synonym for convenience, and convert to a newtype if things start feeling error prone
08:03:09 <dsal> I just did a bunch of stuff with some type synonyms and when I tried to replace them with real types, I found a ton of mistakes I'd made that would've been avoided.  My recency bias is informing me that it's not a good idea.  heh
08:03:28 <bolver> sm[m]: would you make a type when, for example, you need different behaviors based on its values?
08:03:34 <dsal> They're very useful for documentation and disambiguation of certain things.  e.g., different Text values that mean different things.
08:05:08 <sm[m]> bolver: if it has more than two values, yes quite likely
08:05:51 <geekosaur> bolver: doesn't help with distinguishing between values (that's subtyping which isn't supported), but if you use smart constructors to check values a newtype over Text will help keep it correct subsequently
08:07:43 <bolver> geekosaur: ok, i am not sure i asked the question about `Text`.  i think someone else did.  i am asking a very generic question -- when you would make data type vs a type synonym?
08:08:18 <geekosaur> oh, I mixed eitht he comment after your uestion. answer still applies to other types
08:09:19 <geekosaur> type synonyms are most useful for hiding unnecessary details of complex types: compare Parser, ParserT, and ParserM in the parsec package, which hide different parts of the most general parser type
08:10:11 <bolver> i see
08:10:20 <geekosaur> newtype is useful when you want to replace or add a behavior on an existing type, since you can "copy through" the behaviors (typeclass instances) you want to keep and then define your custom ones
08:10:22 <sm[m]> you mean “hide” as in visually hide, reducing boilerplate, there
08:10:35 <geekosaur> data is used for application specific data
08:11:15 <geekosaur> yeh. like, parsec has a built-in state that isn't often used, so Parsec and ParsecT synonyms pass () as the state type
08:12:13 <geekosaur> Parsec also passes Identity as the underlying monad, whereas ParsecT exposes that part. ParsecM exposes everything, but `ParsecM () Identity` is noticeably longer than `Parsec`
08:13:39 <bolver> geekosaur: i hadn't thought of that, but that makes sense.  so clients are given a more simple synonym for a complex type, i suppose
08:13:49 <geekosaur> (The state is also redundant as parsec was fixed to work properly with StateT some years back)
08:15:23 <sm[m]> when just starting out, prototyping, etc, type synonyms can be attractive to clarify code, eg: type Name = String, type Address = String, etc. You get to still use all the standard String functions, and you don’t have to write a bunch of helper functions wrapping and unwrapping your custom types
08:16:06 <bolver> sm[m]: so when would you switch to a type then from the synonym?
08:16:19 <bolver> when you need compiler saftey?  an example?
08:16:36 <geekosaur> when you start making errors because you passed an Address to a function wanting a Name
08:16:39 <sm[m]> when you or your library users start mixing them up, it’s a good sign that making them new types is worthwhile
08:16:41 <geekosaur> :)
08:18:03 <bolver> sm[m]: that would be too late, i think?  what is the drawback of the reverse strategy?  make types first, and then if you feel things are not needed, make them synonyms.
08:18:52 <sm[m]> not at all, that’s refactoring. Doing it in the reverse order means you did it the hard way unnecessarily
08:19:21 <bolver> sm[m]: i think a good case for synonyms would be as abbreviations or to hide unneeded complexity.  i can't see anything beyond that.
08:19:26 <sm[m]> if you know up front you’re going to want newtypes, then of course you’d go straight to that
08:20:07 <sm[m]> well, I just described another use. But code a bit more and it’ll be clear
08:22:19 <bolver> sm[m]: yeah, i know.  here is another thing.  i've done a lot of OO stuff -- there you make a type -- called a class -- when your data needs behavior.  is that applicable here?  an example would be -- based on a type's data values, you've different behaviors -- like pattern matching on data constructors.
08:23:06 <bolver> i hope i am clear
08:23:51 <EvanR> there are several ways to go about OO in haskell
08:24:04 <EvanR> one of them is to not do OO and do something else
08:24:24 <sm[m]> yes.. I think in haskell that most often translates as having a module for each type, where you (try to) gather the functions that work on that type
08:24:26 <bolver> EvanR: i think you misunderstood the question
08:25:12 <EvanR> one example is to use a record of functions (or not functions) for your behaviors
08:25:32 <EvanR> then you can change behavior by changing the record
08:25:54 <bolver> sm[m]: you're talking about something else, i believe
08:25:58 <EvanR> this may remove the need for "the data value" itself
08:26:40 <sm[m]> maybe.. well I’ll add: then within the functions that operate on your type, you must pattern match and handle each possible value
08:26:55 <EvanR> with first class functions you can change behavior by just changing the function
08:27:55 <bolver> for example, if you've data X = A | B | C, and you need different `behaviors` for A, , C, i think you would need a data type -- not a synonym
08:28:39 <bolver> sm[m]: correct -- so you would define a type for those situations
08:29:22 <heatsink> bolver, in that case X is the data type.  A, B, C are not data types as far as haskell is concerned; you couldn't make a function that takes only A as a parameter
08:30:22 <bolver> heatsink: i meant that based on the pattern match on the value constrctor, you would call different functions
08:30:36 <sm[m]> bolver: yes, that would be normal in haskell. You can of course switch behaviour based on the content of a string but we would normally wrinkle our nose at that.
08:30:53 <bolver> sm[m]: great, thank you!
08:31:47 <bolver> sm[m]: also, i found data types help to group and carry data that you can pass over to functions.
08:32:20 <EvanR> i didn't understand the question because there's about 1 million reasons to make a class in OO languages
08:33:04 <sm[m]> bolver: well actually I’m conflating two things slightly. If you want to pattern match values for different behaviours, it’s usually good style to use a type which has distinct constructors so the compiler can check it. Whether that type is a new type, or a synonym for another type which happens to be the right shape (eg: Either), is a separate question. But a new type is most likely.
08:33:17 <EvanR> a sum type with exactly 3 cases is actually kind of annoying to do in OO since subclasses are open ended, and you can't check for completeness
08:33:22 <bolver> EvanR: no, actually in OO, there is basically just 1 reason to make a class -- because its data has behaviors attached to it.  that's just it -- nothing more.
08:33:53 <heatsink> In OO you often make classes that are not associated with data.  An example is a visitor.
08:34:28 <EvanR> in OO you often make classes with no data of it's own, like a module with utility routines in them
08:35:08 <bolver> heatsink: actually, OO  -- very few people know how to write good OO.  so you end with classes that are almost entirely filled with functions that work on data from other classes.
08:35:40 <bolver> good OO has no getters and no setters.
08:36:08 <EvanR> my understanding of OO greatly expanded once I started writing haskell, ironically
08:37:26 <bolver> sm[m]: btw, i found the Data.List.Split library written by brent yorgey to be really good haskell code.
08:37:47 <bolver> very beautiful code
08:38:35 <sm[m]> reading code on hackage is a great way to learn
08:38:35 <heatsink> bolver, in my experience, many OO features are only accessible using classes, which is the reason that you end up writing extra classes.
08:38:36 <bolver> sm[m]: also, some of the stuff written by bryan sullivan -- like criterion -- very good places to learn about good haskell code
08:38:47 <heatsink> In C++, if you want an associated type, you have to define a class
08:39:09 <dsal> I've used oo languages without classes.
08:39:29 <bolver> dsal: like python?
08:39:34 <EvanR> yeah OO should be about objects, not classes, shouldn't it ? :)
08:39:41 <dsal> I think the thing oo and fp have in common is that nobody knows what they are.
08:39:58 <dsal> bolver: io and JavaScript mostly.
08:40:21 <bolver> dsal: i found your comment quiet humorous
08:41:18 <bolver> dsal: actually OO is quite sipmple -- it is about grouping functions and data together -- which is called a class.
08:41:42 <bolver> unfortunately, most books and most blogs don't get it
08:42:01 <EvanR> there are other variations about what OO is
08:42:16 <sm[m]> those fools
08:42:20 <bolver> so you look at your code and see which functions work on what data and group them
08:42:34 <heatsink> bolver: Namespaces would fit that description too
08:43:40 <Athas> Namespaces do not maintain state (well, I guess you can make global mutable variables in some languages).
08:45:04 <EvanR> well bolver's definition didn't involve state
08:45:30 <EvanR> certainly many ways to look at OO without mentioning it
08:45:30 <bolver> EvanR: yes, it did => data = state
08:45:39 <heatsink> Data and state are not the same thing
08:45:43 <EvanR> k now you've gone too far
08:45:49 <bolver> group functions and data together
08:45:55 <bolver> in OO
08:46:02 <Athas> Yeah, I also feel that OO is fairly ill-defined.  Lots of disagreement about what it means.
08:46:15 <heatsink> If I have a matrix-matrix multiply function that takes two matrices and returns a new matrix, which part of that is the state?
08:46:21 <Athas> "FP" is also not completely precise, but lots of different things are called OO.
08:46:27 <heatsink> Is it the first operand matrix?  The second operand matrix?  The returned matrix?
08:46:30 <bolver> data in the matrxi
08:46:42 <dsal> bolver: I learned oo initially from Object Oriented Software Construction when I used to work in Eiffel.  Many of the very important principles that book taught were very much not how you do Java (which I learned later).  Both differed a lot from smalltalk, where folks ought to know oo
08:46:53 <EvanR> there are many good ways to capture what state is, but "data" doesn't seem to
08:47:27 <bolver> dsal: i see
08:48:39 <bolver> if you want know how to do good OO, read this: https://www.cs.helsinki.fi/u/luontola/tdd-2009/ext/ObjectCalisthenics.pdf
08:48:43 <EvanR> when you keep doing the same thing and expect different results, you have either gone insane or were using state
08:48:57 <EvanR> or both
08:49:25 <bolver> btw, OO is hard -- i don't find it intuitive -- i find haskell to be much more expressive 
08:50:43 <bolver> haskell is much fun to write, at least for me.  java is a nightmare.  after haskell, i like python
08:51:05 <wejetheman> i started with c++ and actually quit coding for a while because i found it to be such needless bs, im dont feel any of the same frustration learning haskell this time around
08:51:31 <bolver> wejetheman: i see
08:51:34 <geekosaur> I often feel like C++ is "let's go too far in the other direction from C"
08:51:44 <heatsink> hah
08:51:59 <bolver> and java -- talk about some boilerplate
08:53:16 <bolver> i tried some clojure as well -- but i couldn't find anything where i could write code as expressively as in haskell.  i've heard good things about smalltalk though.
08:53:22 <dsal> bolver: I could give you a ton of conflicting "how to write good oo" books.  I liked OOSC, but you can't do much of what it suggests in Java.  So I gave up.  Mostly on oo altogether after a while.
08:53:41 <wejetheman> i do think ill read that though, good oo code sounds like a unicorn interesting enough to track down if you are sure you saw it
08:55:17 <bolver> dsal: the thing OO is -- you look at code and you find a bunch of classes and, at least for me, it is not intuitively clear or expressive -- i mean when you begin to read code, you find yourself jumping from1 class to another.
08:55:28 <EvanR> curiously erlang processes, async threads capture a lot of use cases for OO presented, encapsulation, combining data and behavior
08:55:53 <EvanR> though they have nothing to do with objects or classes
08:56:05 <bolver> so after that, i just don't believe in OO stuff anymore
08:56:20 <heatsink> I feel that Erlang's use cases emphasize encapsulating mutable state
08:56:23 <heatsink> which is what OO is good at
08:56:31 <bolver> most of the code out there in OO (especially java) is really very bad.
08:56:44 <voidy> Hello, I can't find the type here at line 14, It works with a type hole but I would like to really understand : https://gist.github.com/Smatchcube/144157c61ba84fd93f2525d5c9602252
08:57:11 <EvanR> it's a tough sell to blame bad java code on "OO" itself
08:57:45 <rotaerk> IMO programming shouldn't be about following paradigms, but thinking about all your decisions from the position of "what are the practical consequences of this decision?"
08:57:58 <LKoen> EvanR: I think they were blaming OO code on java
08:58:10 <heatsink> voidy: The return type of nextPoint is (Point, g) and the return value is (f p, newGen).
08:58:28 <heatsink> voidy: Looking at the second part of the pair, you can see that newGen :: g
08:58:43 <geekosaur> bjut you need ScopedTypeVariables to get there
08:58:44 <dsal> heatsink: erlang is a great oo language
08:59:17 <heatsink> voidy: Now, looking at the type hole on line 14, the _ is the type of newGen
08:59:30 <bolver> sm[m]: i read your earlier comment -- i think i agree with what you said.  like you suggested earlier, if you code more, i think i'll get a good idea on when to make types vs when to make synonyms.
08:59:38 <EvanR> rotaerk: the programming book industry has been notified about your dissent, the reeducation team is on their way
08:59:44 <heatsink> voidy: So the type is the type variable g.
08:59:54 <rotaerk> :P
09:00:02 <heatsink> voidy: Note that you need to turn on an extension if you want to write `g` there.
09:00:39 <geekosaur> and add a forall
09:01:18 * dsal still doesn't understand when forall is needed
09:01:36 <heatsink> Be on the safe side and put it everywhere
09:01:41 <geekosaur> here, it's "declaring" that the scope of a type variable is different from the default
09:01:43 <heatsink> main :: forall. IO ()
09:01:56 <rotaerk> >_<
09:02:10 <voidy> heatsink: ok that's why it was not typechecking with `g`, thank you for the answer
09:45:22 <fendor> stack is having problems finding a build-plan. The error is in my opinion wrong, e.g. the dep clash should not happen as described by stack. Moreover, cabal can find a build plan. How can I debug that?
09:45:45 <dsal> I'm trying to figure out if I'm leaking threads.  This is harder than I hoped.  threadscope is telling me I need to add -lf if I want more stats.  I did, but it still says that.  I just want to know if the threads I'm starting are ending around the time I expect.
09:46:32 <fendor> log of the build command: https://hastebin.com/apupobokax.sql
09:54:14 <jusss> :t forkIO
09:54:15 <lambdabot> error: Variable not in scope: forkIO
09:54:45 <dsal> @hoogle async
09:54:45 <lambdabot> package async
09:54:45 <lambdabot> Control.Concurrent.Async async :: IO a -> IO (Async a)
09:54:45 <lambdabot> Text.Blaze.Html5.Attributes async :: AttributeValue -> Attribute
09:54:56 <dsal> jusss: if you think you need forkIO, you probably want async
09:55:41 <irc27313>  ok
09:57:01 <jusss> dsal: we can put a loop into forkIO, but we can't put a async into loop
09:57:26 <dsal> jusss: I don't know what you mean, but I don't think you're correct.
10:02:15 <jusss> dsal: if there's a loop like do { A; f } in function f, A is a blocked function, if we use forkIO we can do { forIO (A); f}, that's fine, if use async, do { h <- async $ A; anwser <- h; f} in f, that f will be recursive immeditly, so that async will fail I assume
10:02:39 <dsal> "do {A; F}" isn't a loop.  I'm not sure what it is.
10:03:09 <jusss> dsal: f = do {A; f}
10:03:17 <dsal> It's not clear to me what you think forkIO does.
10:03:57 <jusss> sorry, this is wrong
10:04:25 <jusss> dsal: it should be f = do (forIO A) f
10:04:48 <jusss> so that forIO A can be a loop and it won't affect the outside loop f
10:05:11 <jusss> no,
10:05:13 <dsal> What do you think the difference is between forkIO and async?
10:05:28 <jusss> (forIO A); f = do ... f
10:05:46 <jusss> dsal: I think there're two loop will be in main thread
10:06:10 <jusss> dsal: we can put a loop into forkIO, another one in main
10:06:16 <dsal> Do you mean forkIO?   What does A mean here?  I assume it's a data constructor, but it can't be an argument to forkIO
10:06:19 <jusss> dsal: async can handle two loop?
10:06:29 <dsal> :t async
10:06:30 <lambdabot> error: Variable not in scope: async
10:06:31 <Ariakenom> async runs in its own thread
10:06:37 <dsal> % :t async
10:06:37 <yahb> dsal: ; <interactive>:1:1: error: Variable not in scope: async
10:06:41 * dsal sigh
10:06:45 <Ariakenom> its not like python or js or c#
10:07:06 <Ariakenom> yahb is picky about IO and threading
10:07:31 <jusss> dsal: the question is, if there're two loop running at the same time, can async handle that?
10:07:49 <Ariakenom> jusss: async starts a new thread for the action
10:07:50 <dsal> jusss: async is how you would make that happen.  I don't know what you mean by "handle".
10:07:51 <geekosaur> % import Control.Async
10:07:51 <yahb> geekosaur: ; <no location info>: error:; Could not find module `Control.Async'; It is not a module in the current program, or in any known package.
10:08:49 <jusss> Ariakenom: dsal then I must misunderstand it
10:09:09 <dsal> forkIO ~= async  -- async just provides some better abstractions and stuff.
10:09:33 <dsal> You spawn a new thread to perform an io action.
10:09:38 <geekosaur> forkIO is very low level and makes you manage the threads manually. async provides tools to manage threads
10:09:40 <dsal> I think saying "loop" is confusing things a bit.
10:10:09 <jusss> https://paste.ubuntu.com/p/F8J8HhTWgZ/
10:10:21 <jusss> this recvMsg is a loop function
10:10:24 <Ariakenom> jusss: "its not like python or js or c#" like many things haskell :)
10:11:03 <jusss> and that recv need to be in a loop too
10:11:48 <dsal> I still think "loop" is confusing things, but it's not an interesting detail.  You probably want async instead of forkIO
10:12:37 <jusss> dsal: thread is OS thread in haskell?
10:12:42 <dmj`> async uses STM to transfer exceptions raised by child threads to parent threads, it's good for both synchronous and asynchronous exceptions
10:12:56 <dmj`> jusss: thread is a green thread, not OS thread
10:13:25 <jusss> dmj`: and what forkIO start?
10:13:32 <jusss> a green thread or OS thread?
10:13:41 <dmj`> jusss: forkIO is a green thread, forkOS is an OS thread
10:13:43 <geekosaur> haskell has n:m threading, so green threads which may or may not be on muliple OS threads
10:14:44 <Ariakenom> dmj`: forkOS creates a bound green thread
10:14:54 <Ariakenom> its all green threads
10:15:25 <dmj`> Ariakenom: you're right
10:16:21 <dsal> One reason I prefer RecordWildCards to NamedFieldPuns is that I can never remember the name of the latter.
10:16:51 <Ariakenom> RecordExtenionPins
10:17:36 <Ariakenom> edit distance = 2
10:25:32 <hololeap> i'm confused as to how to implement ArrowApply for this arrow: http://dpaste.com/2RWYTRN
10:28:07 <hololeap> also, if this were to be implemented, would it be another form of the State monad? (Just a guess)
10:28:55 <irc27313> :t Text
10:28:57 <lambdabot> error:
10:28:57 <lambdabot>     • Data constructor not in scope: Text
10:28:57 <lambdabot>     • Perhaps you meant one of these:
10:30:11 <jusss> :t import Data.Text
10:30:13 <lambdabot> error: parse error on input ‘import’
10:30:37 <jusss> % import Data.Text
10:30:37 <yahb> jusss: 
10:30:49 <jusss> % :t Text
10:30:49 <yahb> jusss: ; <interactive>:1:1: error:; * Data constructor not in scope: Text; * Perhaps you meant one of these: variable `text' (imported from Text.PrettyPrint.HughesPJ), variable `next' (imported from System.Random)
10:31:29 <hololeap> i found this which answered my question (thanks phadej) https://stackoverflow.com/questions/27603108/what-is-wrong-with-this-instance-arrowapply-automaton
10:34:36 <hololeap> (also i just found the Control.Arrow.Transformer.* modules)
10:41:37 <dmj`> there should really be a tool that helps you write haddocks for your code
10:44:39 <dsal> dmj`: I use emacs for that.
10:45:17 <dmj`> dsal: I use emacs yasnippets too, but there needs to be something more holistic.
10:52:37 <dmj`> like, parse the source and stuff
10:53:29 <dsal> To do what?  I want the documentation to tell me the stuff the code doesn't.  :)
10:58:52 <dmj`> It'd be nice if there was an open spec for this sort of thing, could create haddocks directly from C header files, could even do codegen.
11:07:41 <dsal> Do you just mean like some kind of pandoc?  Documentation is only valuable if it tells you something  you can't get from the code.
11:10:48 <MarcelineVQ> It's also useful if you don't want to look at the code (read: learn the implementation) to see how to use an API
11:11:44 <fendor> can I somehow change the cabal-install version that ships with a lts snapshot?
11:14:58 <fendor> or Cabal version?
11:14:59 <dmj`> dsal: no, not like pandoc
11:15:37 <dsal> MarcelineVQ: Sure.  I just haven't seen many cases where generated code tells me particularly useful stuff.  I've seen a lot more cases of obligatory docs generated by tools.    f :: [a] -> [a]     "f takes a list and returns a list of the same type"   Cool, is it sort?  tail?
11:16:39 <MarcelineVQ> I agree
11:18:53 <dmj`> dsal: a good example is C API calls, modelling them from a high level Haskell API. Sometimes the parameters are just Int, Double, etc. It would be nice if a tool could analyze the docs in the C library and produce high level haskell functions pre-haddocked. This would require some kind of open specification to make things machine readable
11:19:40 <dsal> But I don't need the doc to tell me that a parameter is an Int.  I need it to tell me why I should pass a particular Int to the function.
11:20:14 <dsal> A pandoc sort of thing might make sense if you have a well-documented C API and you want to translate that documentation in your generated FFI thing.
11:22:35 <dmj`> dsal: that's exactly what I'm saying
11:22:49 <dmj`> dsal: there would be an open documentation spec that both the C library and generated haskell library both use
11:23:03 <dmj`> It would answer the "why" question, not just the what
11:23:34 <dsal> Ah.  OK.
11:23:39 <dmj`> the libraries I deal w/ are usually too bespoke for pandoc to deal with accurately
11:30:55 <tomjaguarpaw> Why does cabal think directory-1.3.4.0 is a "user goal" when I try to install a package from my local source tree?
11:30:58 <tomjaguarpaw> [__1] trying: directory-1.3.4.0 (user goal)
11:32:26 <tomjaguarpaw> The version that comes with my ghc is directory-1.3.1.5 and cabal seems to think that imposes a conflict
11:32:38 <tomjaguarpaw> (This is with cabal v2-install, cabal-install version 3.0.0.0)
11:33:34 <int-e> tomjaguarpaw: ugh there are some other configuration files where this could come from, besides the command line. cabal.project maybe?
11:35:08 <tomjaguarpaw> Nope
11:35:41 <tomjaguarpaw> I doubt this package even knows about cabal.project.  It was last updated in 2015.  https://hackage.haskell.org/package/happstack-lite
11:43:27 <tomjaguarpaw> Where else could the goal come from?
11:45:45 <tomjaguarpaw> Hmm, perhaps it's this: https://github.com/haskell/cabal/issues/5559
11:47:40 <dmwit> tomjaguarpaw: Perhaps take a look in .ghc/<version>/environments
11:47:55 <dmwit> Oh, your link says the same.
11:48:39 <fresheyeball> what is the easiest way to print a float without the scientific notation?
11:49:13 <tomjaguarpaw> dmwit: What do I do with that?
11:49:14 <dmwit> fresheyeball: Have a look through the Numeric module
11:49:39 <dmwit> tomjaguarpaw: Maybe delete directory-1.3.1.5 from the default environment.
11:49:41 <dmwit> er
11:49:45 <dmwit> directory-1.3.4.0 I mean
11:49:47 <dmwit> the conflicting one
11:50:00 <dmwit> tomjaguarpaw: I don't really know. I haven't had to solve this problem here, so I'm flying blind.
11:50:35 <dmwit> fresheyeball: I think showFFloat is the one you want?
11:51:15 <fresheyeball> showFFloat :: RealFloat a => Maybe Int -> a -> ShowS ?
11:51:34 <fresheyeball> that is the least documenting type signature ever
11:51:47 <fresheyeball> I will wag this
11:51:58 <dmwit> Good thing it has documentation, then.
11:52:09 <tomjaguarpaw> dmwit: Haha, well that worked, kind of!  I deleted all the packages in that file that had a hash attached (since I assumed that meant I installed them myself).  Then the package installed fine, but in doing so all the packages that I deleted reappeared!
11:52:37 <dmwit> I bet not all of them. =)
11:52:55 <dmwit> Or at least, not all the same hashes.
11:53:37 <EvanR> > showFFloat Nothing 3.14 ""
11:53:40 <lambdabot>  "3.14"
11:53:50 <EvanR> > showFFloat Nothing (1e100) ""
11:53:52 <lambdabot>  "100000000000000000000000000000000000000000000000000000000000000000000000000...
11:54:11 <tomjaguarpaw> dmwit: I think they are the same as I only have one version of each installed in my store.
11:54:35 <fresheyeball> what is the role of the "" at the end?
11:54:45 <dsal> > showFFloat (Just 2) 3.52848248248 "ms"
11:54:47 <lambdabot>  "3.53ms"
11:54:53 <fresheyeball> dmwit:++
11:55:05 <fresheyeball> dmwit++
11:55:19 <fresheyeball> eck karma must be down
11:55:24 * dsal prefers dmwit<>
11:55:30 <EvanR> it just doesn't appear
11:55:34 <geekosaur> karma isn't verbose here
11:55:50 <geekosaur> @karma dmwit
11:55:50 <lambdabot> dmwit has a karma of 83
11:56:17 <tomjaguarpaw> What *is* a ghc environment?  The default set of packages?
12:01:23 <rotaerk> hmm how do you create a binding to a C function that returns a struct, rather than a pointer to a struct?
12:01:39 <dmwit> rotaerk: You write wrappers that return pointers.
12:02:20 <dmwit> tomjaguarpaw: s/default//, then you got it exactly right
12:02:42 <dmwit> tomjaguarpaw: Additionally, there is a default environment.
12:03:18 <rotaerk> where do you write such wrappers?
12:03:34 <heatsink> You would write them in C
12:03:54 <heatsink> GHC doesn't know about the layout of C structs, which is why you need to write that part in C
12:04:38 <rotaerk> okay, and if I'm returning it as a pointer to the struct, where in memory would this pointer be pointing? would I have to malloc something to store the struct?
12:04:48 <rotaerk> and then somehow clean it up from the haskell side?
12:05:23 <heatsink> malloc is probably what you want.  You could malloc on either the haskell or C side
12:05:31 <heatsink> and free on the haskell side
12:06:14 <rotaerk> hmm so I could wrap `SomeStruct foo(...)` with `void fooWrapper(..., SomeStruct*)`
12:07:37 <dmwit> That's a good way if you plan to allocate on the Haskell side.
12:07:48 <dmwit> `SomeStruct *foo(...)` is a good way if you plan to allocate on the C side.
12:07:48 <heatsink> Do you want to access the struct's contents in haskell code, or just pass the struct to other C code?
12:08:03 <rotaerk> access from haskell side
12:08:32 <heatsink> Consider marshaling it to a haskell data type
12:09:50 <rotaerk> yeah, can use the signature I gave above, alloca a pointer to some Storable, pass that pointer to the fooWrapper, and then peek back the result
12:10:06 <rotaerk> as one option at least
12:10:37 <heatsink> right
12:16:17 <tomjaguarpaw> dmwit: Thanks.  Do you understand why cabal fiddles with it?  (Or perhaps it's only incidentally that it is getting changed by cabal)
12:28:36 <heatsink> @karma c/c
12:28:36 <lambdabot> c/c has a karma of 2099
12:31:24 <geekosaur> clearly we don't mention c-- enough :p  (well, we also are more likely to call it cmm)
12:42:16 <Mx8v> Trying to setup emacs/intero/stack and I've exhausted everything I could think of. I'm getting the haskeline not installed and libtinfo issue messages... but they're there, AFAIK. If anyone feels like giving a hand: https://pastebin.com/ExDp8Jnp   I put some space between most commands... or just ctrl-f for mx8v to spot commands I guess.
12:44:53 <erisco> I have been using Haskell for a few years, and what I have learned is that a language is only as good as it's people. Haskell has a fantastic community, who I have been fortunate enough to discover.
12:51:08 <erisco> The only criticism I have about Haskell is that it only has the 'm' for multiple parameter polymorphism. If we really wanted multiple parameter polymorphism, the 'm' could also be 'p'.
12:54:04 <__monty__> Wait, what?
12:55:34 <erisco> Let me explain what I mean by "multiple parameter polymorphism". There are different kinds of polymorphism in Haskell, but all can be defined as two polymorphic functions:
12:55:54 <erisco> > [ ] :: a -> Monad m => a -> [ b ] [ a ] x @ ( x : xs ) = x @ xs [ ] ( x : xs ) = if x == 0 then x : xs else 1
12:55:56 <lambdabot>  <hint>:1:43: error: parse error on input ‘@’
12:56:24 <fresheyeball> https://youtu.be/b4Vyma9wPHo?t=471
12:56:34 <fresheyeball> so I am trying to do this super basic gradient decent tutorial
12:56:46 <fresheyeball> and at the end of the video I just posted he give exercise 3-2
12:56:56 <fresheyeball> gradient decent with a model containing to weights
12:57:00 <fresheyeball> https://gitlab.com/fresheyeball/torch-sandy/blob/master/examples/sandy/Main.hs
12:57:08 <fresheyeball> this is my version of it in Haskell
12:57:31 <fresheyeball> to be honest I can't tell if I got it right
12:57:33 <fresheyeball> but I suspect not
12:57:42 <heatsink> It is not publicly accessible
12:58:25 <heatsink> Can you pastebin it?
12:59:01 <fresheyeball> https://pastebin.com/d6KKxbGw
12:59:07 <fresheyeball> this is the output of my program
12:59:11 <fresheyeball> oh I will make it public
12:59:39 <fresheyeball> https://pastebin.com/VyNHTcQY
12:59:43 <fresheyeball> decided to pastebin it instead
12:59:46 <fresheyeball> faster
12:59:49 <heatsink> If it's more than a few lines of code, we probably won't be able to just look at it and judge whether it's right
13:00:06 <fresheyeball> its quite small
13:00:33 <heatsink> For a solver, you can generally check if the result is correct by putting it into the original equation it's supposed to solve
13:01:06 <heatsink> This is finding the solution to some equation like f(x) = 0, right?  So evaluate f(x) with the solver's result and see if it's close to zero
13:01:13 <fresheyeball> heatsink: if you look at the output
13:01:18 <fresheyeball> the loss goes down
13:01:21 <fresheyeball> then it goes up!
13:01:27 <fresheyeball> I do not think it should go up
13:01:35 <heatsink> Does "ls" stand for loss?
13:01:45 <fresheyeball> the point of the gradient decent here is to get the w1 and w2 such that loss is minized
13:02:00 <erisco> __monty__, I was having fun to see if AI could autopilot writing/conversations I don't want to think about https://talktotransformer.com/
13:02:28 <erisco> Turns out it isn't so competent at writing Haskell code.
13:03:03 <heatsink> Right, the error or residual should keep decreasing
13:03:11 <fresheyeball> heatsink: it stands for losses
13:03:22 <fresheyeball> the loss per epoch is the average of the losses
13:03:34 <fresheyeball> we want the average loss to be minimized I should say
13:04:02 <suzu> erisco: i'd add to that and also say that the ecosystem matters a lot for a language
13:04:09 <suzu> especially for things like industry adoption
13:04:30 <erisco> Now the mystery is… are those *your* words or an AI's words? :P
13:04:34 <suzu> not being able to just pull off an aws library or framework just off of a shelf implies a lot of risk
13:05:07 <fresheyeball> suzu: you advocating for Idris or something?
13:05:19 <fresheyeball> don't most languages have an off the shelf aws thing?
13:06:49 <suzu> no, not advocating for anything
13:06:54 <suzu> i just think ecosystem is a very important piece of the puzzle
13:07:36 <fresheyeball> I think I found the error in my math
13:07:43 <fresheyeball> my derivative calculation is wrong
13:09:05 <dmwit> tomjaguarpaw: cabal fiddles with it because that's what you asked it to do. cabal install --lib changes the default environment.
13:09:15 <dmwit> That is sort of it's entire purpose.
13:16:40 <fresheyeball> I think I figured it out
13:16:54 <fresheyeball> I was taking the derivative of the model, and not of the loss
13:19:07 <fresheyeball> is there an IRC for this?
13:19:13 <fresheyeball> maybe Haskell is the wrong one
13:23:39 <heatsink> idk.  Is there a freenode channel for numerical algorithms?
13:24:25 <voidy> there is #math for general maths
13:31:20 <__monty__> There's #numerical-haskell.
13:35:10 <juri_> so, is there a 'cabal 3 breaks Setup.hs with ghc 8.6.5' guide? I upgraded my system from cabal2 to cabal3, and ghc 8.4 to ghc 8.6, and now Setup.hs won't compile with: $(GHC) -O2 -Wall --make Setup
13:36:32 <pikajude> error?
13:36:34 <juri_> at first it couldn't find Distribution.Simple, then when i a...
13:36:38 <juri_> wait, wut?
13:36:44 <juri_> nevermind?
13:36:44 <pikajude> what's the error?
13:36:46 <pikajude> ok
13:36:51 * juri_ stares at her machine.
13:36:51 <pikajude> you're welcome :)
13:36:58 <juri_> pikajude: good job!
13:37:03 <pikajude> ++me
13:37:09 <juri_> 5 stars, would bother again.
13:38:18 <pikajude> the juri is out
13:38:41 * Clint golfclaps.
13:59:14 * hackage predicate-typed 0.1.0.3 - Predicates, Refinement types and Dsl  https://hackage.haskell.org/package/predicate-typed-0.1.0.3 (gbwey)
14:04:44 <arsdragonfly> Hi, I have `hspec` listed as a dependency in `build-depends` in my `.cabal` file under the `test-suite test` section,
14:05:46 <arsdragonfly> but somehow ghcmod is still complaining "Could not load module `Test.Hspec`" in `test/Tests.hs`
14:07:07 <arsdragonfly> is anybody able to verify if ghcmod correctly tries to load `build-depends` of test suites?
14:20:14 * hackage predicate-typed 0.1.0.4 - Predicates, Refinement types and Dsl  https://hackage.haskell.org/package/predicate-typed-0.1.0.4 (gbwey)
14:36:03 <koz_> Why oh why can I never remember the function argument to foldr...
14:36:24 <dmwit> koz_: It's just got the same type as (:) itself of course!
14:36:44 <koz_> dmwit: Yeah, I guess that makes sense, but it's not memorable in its full generality. :P
14:36:47 <dmwit> foldr f z replaces all the (:)'s with f's and all the []'s with z's.
14:36:56 <heatsink> foldl doesn't have the same type though
14:37:12 <koz_> :t evalState
14:37:13 <lambdabot> State s a -> s -> a
14:37:13 <dmwit> foldr f z (a:b:c:[]) = a`f`b`f`c`f`z
15:10:25 <epta> eecv                                                                                                                                                                                                                                                                                                                                                                                                                       
15:10:27 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:10:29 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:10:31 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:10:33 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:10:35 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:10:37 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:10:39 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:10:41 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:10:43 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:10:45 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:10:47 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:10:49 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:10:51 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:10:53 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:10:55 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:10:57 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:10:59 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:11:01 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:11:03 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:11:05 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:11:07 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:11:09 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:11:11 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:11:13 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:11:15 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:11:17 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:11:19 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:11:21 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:11:23 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:11:25 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:11:27 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:11:27 <tdammers> @where ops
15:11:27 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
15:11:29 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:11:31 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:11:33 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:11:35 <epta>                                                                                                                                                                                                                                                                                                                                                                                                                            
15:11:37 <epta>                                                                                                                                                                               
15:11:39 <epta> i
15:11:43 <epta> sorry for that
15:19:22 <suzu> lol
15:22:21 <marxS> how often do you people use haskell? everyday?
15:22:28 <haasn> more or less
15:22:42 <haasn> I use `ghci` as my go-to calculator
15:22:45 <koz_> marxS: Yep, pretty much daily.
15:23:08 <marxS> koz_, do you use other languages too? or do you use haskell for everything?
15:23:25 <koz_> marxS: I use other languages periodically. For personal use, it's nearly 100% Haskell.
15:23:38 <suzu> kotlin in the streets, haskell in the sheets here
15:23:46 <suzu> though sometimes i will use python or ruby for personal things
15:24:03 <suzu> because i can get something stupid done in a few minutes and i dont care about maintainability
15:24:10 <haasn> I use C for a lot of things where haskell would be fighting me more than helping me
15:24:16 <suzu> just pull off some packages that do a bunch of stuff for me, profit, and move on
15:25:13 <suzu> sadly haskell doesn't have the strong ecosystem of other languages and you'd have to spend quite a bit more time doing the same thing in haskell
15:34:08 <ibloom> Is there a good way to cull unneeded imports from a haskell codebase?
15:35:25 <suzu> compile with -fwarn-unused-imports
15:35:34 <c_wraith> ghc itself has an option to list the minimal imports needed in a file.  I'm sure lots of IDE plugins use that information for you, but I don't use them
15:43:14 <dignissimus> Is there a speed difference between a*a and a**2?
15:44:21 <koz_> :t (**)
15:44:23 <lambdabot> Floating a => a -> a -> a
15:45:14 <sshine> :t (*)
15:45:15 <lambdabot> Num a => a -> a -> a
15:45:35 <sshine> so the answer depends on what you're multiplying?
15:45:50 <dmwit> dignissimus: I double-dog dare you to write a program where that question makes a difference.
15:46:09 <dignissimus> haha, It's a competetive programming kind of thing
15:46:20 <suzu> is haskell a good fit for competitive programming?
15:46:21 <sshine> dignissimus, one is tempted to wonder if GHC does constant folding here, right?
15:46:32 <dignissimus> I heard it's faster than C?
15:46:43 <suzu> afaict writing common algorithms in haskell is real backwards
15:46:47 <suzu> and hard
15:46:59 <sshine> suzu, my friends from university who did competitive programming (in the kind of competition where you have to provide solutions to as many problems in as short amount of time as possible) say no.
15:47:05 <dmwit> Is the competition about how fast the program runs, or how fast the programmer runs?
15:47:08 <suzu> you pretty much need ST or something to do it fluently
15:47:13 <suzu> dmwit: both normally
15:47:16 <suzu> sshine: thought so
15:47:19 <c_wraith> glguy frequently is in the top 10 global scores in the advent of code with haskell
15:47:31 <suzu> yeah that's true
15:47:46 <dmwit> (But where would he be with a different language? He's Very Good.)
15:47:52 <suzu> if i had to write a bfs or dfs in something, i could write it out in a minute or two in python with no problem
15:48:08 <c_wraith> those algorithms are also both trivial in haskell
15:48:12 <dmwit> agreed
15:48:14 <suzu> in haskell i'm pretty stumped
15:48:21 <suzu> with how to even represent the graph
15:48:27 <suzu> let alone write the traversal
15:48:39 <suzu> perhaps i just need to practice with haskell's ds and container libraries
15:48:42 <Rembane> It depends... :D
15:48:46 <dmwit> import Data.Graph.Inductive
15:48:58 <c_wraith> if you want something harder than you'd expect in other languages in Haskell, union/find is the go-to
15:49:02 <dmwit> (...and Data.Graph.Inductive.Query.{BFS,DFS})
15:49:09 * koz_ just wrote actual code involving fmap . fmap.
15:49:27 <koz_> My only thought is 'Bro, do I even lift?'.
15:49:31 <suzu> c_wraith: as in, union find is harder to write in haskell than in other languages?
15:49:32 <sshine> koz_, I just merged a PR containing fmap . fmap . fmap recently. :o
15:49:42 <koz_> sshine: Was it lens-related?
15:49:46 <suzu> union-find is simple in other languages because you can mutate your array directly
15:49:53 <suzu> to join sets
15:50:02 <sshine> koz_, not actually. I thought "this could be more readable, but I'll roll with it."
15:50:20 <koz_> suzu: In fact, SPJ and [insert other guy initials] used union-find as a motivation for ST in their original ST paper.
15:50:29 <suzu> oh TIL
15:50:47 <suzu> as in, "writing union find melts your brain without mutation, so here's ST and this'll solve it nicely"?
15:51:16 <c_wraith> It's impossible to add the kind of sharing the union portion needs for efficiency without mutating shared refs
15:51:30 <sshine> koz_, I think it was a property test of some function returning a 'Maybe [Text]', so Property, Maybe and [] being three layers.
15:51:42 <koz_> sshine: Something something transformers.
15:51:50 <sshine> koz_, hehe.
15:51:57 <suzu> there's a post someplace on r/haskell where someone is asking about how to implement some kind of thing without mutation
15:51:59 <koz_> suzu: Not quite - it was more like 'We can't really do this efficiently without mutable state'.
15:52:10 <koz_> (which is true if you're talking about Tarjan's union-find)
15:52:12 <koz_> (which they were)
15:52:19 <suzu> and ekmett comes in and says, "just use mutation. otherwise this will not be ergonomic. mutation isnt all that evil"
15:52:26 <suzu> or something like that
15:52:27 <koz_> (the one which is O([whole tonne of log](n)))
15:52:50 <koz_> Edward says sensible things like that.
15:53:13 <koz_> I'm surprised it wasn't 'Actually you can do this with cotraversable comonad cotransformers in Hask -> Constraint'.
15:53:21 <Rembane> Just put the mutation in an enclosed space and it will all be fine.
15:53:21 <koz_> 'Here's the library I wrote that does that in 2 lines'.
15:53:46 <suzu> ah this is it
15:53:47 <suzu> https://www.reddit.com/r/haskell/comments/djy72x/monte_carlo_tree_search_question/f494ewq/
15:53:53 <c_wraith> Still, there are a lot of problems that don't need mutation to solve efficiently
15:54:05 <suzu> > Use mutability? It isn't evil, just mark where your code is imperative with some kind of ST s-like region parameter and go on with your business.
15:54:07 <c_wraith> So it's not like you have to go to ST for everything
15:54:08 <lambdabot>  <hint>:1:30: error: parse error on input ‘,’
15:54:15 <sshine> I guess it's hard to say objectively whether Haskell is a good competition language, because it depends heavily on the competitor. typically the problems you encounter are covered imperatively in algorithms courses (like DP), so a competitor using Haskell, I think, might have to re-study implementing algorithms in Haskell quite a bit.
15:54:22 <suzu> > But there is no reason to wear the hair shirt here. You can just use references. In general algebraic data types suck at DAGs, so its usually a sign that I should break out the ST when they pop up in my work.
15:54:24 <lambdabot>  <hint>:1:103: error: parse error on input ‘data’
15:54:38 <c_wraith> sshine: haskell is really good at dynamic programming problems, thanks to laziness. :P
15:54:51 <koz_> sshine: Not to be outdone, I am about to seriously use liftA2 . liftA2. :P
15:55:06 <Rembane> sshine: There are two recursion schemes with scary names that fit incredibly well with DP. 
15:55:08 <suzu> i still wouldn't use haskell for algorithms/ds technical interviews
15:55:12 <sshine> c_wraith, it certainly is! but I only found out about this when trying to solve these kinds of problems, realizing I'm not going to win this competition because I'm learning how this stuff works in the process. :-D
15:55:15 <suzu> but that's because haskell doesn't communicate well
15:55:22 <koz_> Rembane: Chronomorphism and?
15:55:31 <suzu> to people who won't know it, it just looks like some turbonerd stuff
15:55:49 <suzu> and will be difficult to explain to an interviewer
15:55:55 <c_wraith> The real issue with Haskell is that a lot of tools were built to give alternatives to imperative code and then thrown into common libraries...  and then the competition environment doesn't give you those libraries
15:56:06 <sshine> suzu, honestly, if I were going to pick a reason not to use Haskell as a chalkboard language, it'd be because the interviewer would think that I'm cheating.
15:56:10 <dsal> koz_: gesundheit
15:56:40 <suzu> yeah
15:56:57 <suzu> "dont worry i can do all this stuff because the language is lazy and will only eval the stuff i need here"
15:57:02 <suzu> "uhhhhhhhhhhhhhhHHHHHHHHHHHH okay"
15:57:10 <suzu> thanks for your time
15:57:15 <suzu> we'll keep your resume on file
15:57:17 <suzu> bye bye
15:57:18 <sshine> c_wraith, possibly. I don't know how compile times come into it, but you can't exactly sit and wait for 40 abstract libraries to compile before you submit. so you'd need to be allowed to cache the compilation of the things in your toolbelt. I don't think C++ competitors have the same problem.
15:57:29 <Rembane> koz_: I saw histomorphism and hylomorphism and err... dynamorphism, oh well, I'm totally guessing now. 
15:57:41 <koz_> Rembane: Histomorphism is the one.
15:57:47 <koz_> Hylo is just ana then cata.
15:58:11 <sshine> rembanemorphism
15:58:19 <Rembane> koz_: Got it! Thanks! 
15:58:19 <c_wraith> sshine: you don't have that problem in competitive environments because you install the libraries ahead of time.  In haskell, too.
15:58:32 <Rembane> sshine: I'm quite fond of that morphism.
15:58:52 <c_wraith> sshine: there's no requirement that every single thing you do in haskell be in its own sandbox.
15:59:17 <c_wraith> sshine: this is, of course, one of the many areas where competition programming is very different from building production software :)
15:59:20 <sshine> c_wraith, if Haskell were more mainstream in competitions, it'd just be one of those things you take into account. I just assumed that C++ competitors are happy enough with only the standard library, whereas Haskellers miiight want a few more packages geared towards tackling some of those problem types. but I don't know, I never did this.
15:59:31 <sshine> c_wraith, ha, yes.
16:01:07 <sshine> c_wraith, the company I work for co-sponsors the Danish national programming contests, so I get a tiny bit of insight. basically all the top-league students use C++. but I guess this comes from them having learned this sufficiently at an age of <20. one Haskeller who did well this year (who incidentally is a student programmer here) still picked C++ in the competition.
16:01:41 <c_wraith> you have to practice using haskell for competitions to be able to use it for competitions.  There's no way around that.
16:01:49 <sshine> right.
16:02:59 <Rembane> sshine: What's the kind of problems to solve in the competition?
16:03:04 <c_wraith> It is a different skill set.  In some cases, though, I think it's just as good as any other skill set.  Those cases mostly being Advent of Code style things, where you can write libraries to handle all the common competition patterns beforehand.
16:03:05 <suzu> i did competitive programming for a bit in C++
16:03:05 * sshine is a slow coder. I did enjoy one website with a style of competition that was "code golf in 5 minutes", trying to bring back Perl honor from those who do so well in Python nowadays.
16:03:08 <suzu> i did practice that
16:03:12 <suzu> and got alright at it
16:03:19 <suzu> but then i switched to python and became a lot lot better
16:03:20 <sshine> Rembane, algorithms problems.
16:03:33 <zeta_0> can i use something like `acid-state` or `acid-world` to replace a database like postgresql for real world projects ?
16:03:41 <Rembane> sshine: Cool, how big are the data sets? 
16:03:42 <sshine> zeta_0, it's kinda slow.
16:03:42 <suzu> making certain kinds of data-structures was much easier
16:03:52 <suzu> and python would take care of a lot more heavy-lifting than C++ did
16:04:11 <sshine> Rembane, what do you mean? the number of problems?
16:04:20 <zeta_0> sshine: so i'll take it as a no ?
16:04:21 <suzu> so i do think language choice matters
16:04:34 <c_wraith> Like, I mentioned how glguy places highly - he has ca ustom library  for centralizing common idioms without hardcoding in too many direct "this solves that problem" sorts of things.
16:04:36 <Rembane> sshine: No, more like, is the speed of the implementation important? 
16:04:48 <c_wraith> *has a custom
16:04:52 <suzu> oh does he
16:04:59 <suzu> that's clever
16:05:07 <sshine> Rembane, yes. typically brute force solutions won't fit within the time window for a C++ solution.
16:05:48 <sshine> Rembane, the speed isn't as important as it's a factor in making the problem harder to adjust for difficulty.
16:06:23 <sshine> c_wraith, ok.
16:06:27 <Rembane> sshine: Cool, that means that good Haskell solutions are actually needed. :)
16:06:53 <sshine> zeta_0, I don't know. I liked the thought at one point, but also thought to myself that if my project should ever grow, I'd probably want/need a relational database eventually.
16:07:17 <sshine> zeta_0, I don't know of any stories of people who started with acid-state and what their experience was after a while, but that'd be interesting to find.
16:07:24 <suzu> i started with sqlite
16:07:35 <suzu> as i just wanted to use something well-tested and lazy to implement
16:07:35 <marxS> thats smart
16:07:49 <sshine> suzu, that probably compares wrt. performance? I don't even know.
16:07:59 <suzu> idk i didn't care at the time
16:08:09 <suzu> this wasn't a high-frequency trading app or something
16:08:17 <suzu> just some simple projects and random ideas
16:08:18 <sshine> that's probably the takeaway: if you can afford not to care, it's an interesting enough experiment. :)
16:08:43 <suzu> i switched to postgres with beam later
16:09:44 <c_wraith> hackage 1 is probably the best-known example of acid-state failing
16:09:53 <sshine> Rembane, yes, it means you need to think properly about the problem regardless of the language, making it more of a mental exercise than a language proficiency one. :)
16:10:01 <Rembane> sshine: Good stuff. 
16:10:08 <c_wraith> it had performance problems they couldn't figure out, *and* bugs that made it... not so much ACID.  it lost data sometimes.
16:10:39 <suzu> yyeah
16:10:41 <suzu> lol
16:10:46 <suzu> just use sqlite and move on to more important things
16:11:37 <sshine> Lemmih (the author of acid-state) took a course once I was TA'ing. I thought, I can't teach this guy anything.
16:12:14 <zeta_0> i am trying to decide between `acid-state/acid-world` or `selda(used with postgresql)` for work, what would you guys recommend ? https://github.com/acid-state/acid-state https://github.com/matchwood/acid-world https://github.com/valderman/selda https://github.com/postgres/postgres
16:13:28 <zeta_0> what do you guys think would be best to use and why ?
16:13:51 <sshine> zeta_0, drawing from the project kowainik/issue-wanted, I'd go with 'postgresql-simple'. the why is in the package name.
16:14:34 <sshine> zeta_0, also, it rates fairly well on DLs in Hackage in lack of any better measure.
16:14:53 <zeta_0> and here is the main link for `selda` what do you guys think of it ? https://selda.link/
16:15:00 <sshine> zeta_0, there's a lot of fancier alternatives. decide what you like to learn and how steep a curve you want.
16:15:23 <suzu> beam is pretty nice
16:15:29 <suzu> but it's got a lot of type-level machinery
16:15:39 <suzu> you probably don't need to burden yourself with that honestly
16:15:44 <zeta_0> suzu: `beam` ?'
16:16:07 <suzu> Beam is a highly-general library for accessing any kind of database with Haskell. It supports several backends. beam-postgres and beam-sqlite are included in the main beam repository. Others are hosted and maintained independently, such as beam-mysql and beam-firebird. The documentation here shows examples in all known backends.
16:16:09 <suzu> Beam is highly extensible and other backends can be shipped independently without requiring any changes in the core libraries.For information on creating additional SQL backends, see the manual section for more.
16:16:13 <suzu> https://tathougies.github.io/beam/
16:16:16 <sshine> suzu, oohh, it has schema generation!
16:16:29 <suzu> sort of, yes
16:16:33 <suzu> that part is a little immature
16:16:42 <suzu> it can /validate/ schemas though so i have the application do that upon boot
16:16:46 <suzu> and i deal with migrations myself
16:16:56 <sshine> good to know, thanks.
16:17:14 <suzu> it can generate migrations using some logic proof stuff
16:17:21 <suzu> that i don't understand and i think is still under development
16:17:25 <suzu> so i dont use that stuff
16:17:26 <zeta_0> sshine: i have never heard of `postgresql-simple`` what are the main differences between that and the regular `postgresql` ?
16:19:38 <zeta_0> suzu: cool, so what are the main differences between: `selda` and `beam` ?
16:20:19 <suzu> i don't know anything about selda
16:20:22 <suzu> so.. don't know
16:22:44 * hackage can-i-haz 0.2.1.0 - Generic implementation of the Has and CoHas patterns  https://hackage.haskell.org/package/can-i-haz-0.2.1.0 (0xd34df00d)
16:22:59 <zeta_0> thanks for the information guys, i am going to try out yesod, i am just seeing the best way to do database programming with haskell
16:23:56 <suzu> there's lots of choice, yeah
16:24:03 <suzu> and everyone will have different opinions and answers
16:24:44 <suzu> just go ahead and get started with pretty much whatever
16:24:53 <zeta_0> suzu: yeah, it's very confusing trying to compare these things
16:24:58 <suzu> haskell is the kind of language where you can confidently replace these sorts of large systems
16:25:01 <suzu> so that's a big big plus
16:26:19 <suzu> i got started with yesod and changed to something else quickly and painlessly
16:26:29 <suzu> started with sqlite and moved to beam confidently as well
16:26:31 <suzu> etc
16:26:52 <dsal> I started with sqlite and just kept using it because it's awesome.
16:27:00 <suzu> yeah it is pretty good tbh
16:28:18 <zeta_0> suzu: yeah, that's i want to use haskell for everything
16:29:49 <zeta_0> from what i here web_assembly/haskell integration is not done yet, so i am still going to have to use other web programming languages
16:30:18 <suzu> haskell still does suck at a lot of stuff
16:30:21 <zeta_0> hear (not here)
16:30:30 <zeta_0> typo
16:30:40 <suzu> ghcjs is sorta a pain
16:30:48 <suzu> can't really do mobile dev with haskell
16:31:01 <suzu> i've found writing "scripts" aka bad programs to be a bit more tedious in haskell
16:31:16 <suzu> in cases like that i just go get ruby or something and import something already built and just profit off that
16:31:20 <suzu> /shrug
16:31:23 <dsal> I wrote a relatively crappy eventlog script today and feel pretty good about it.
16:31:33 <suzu> like if i need a crud webapp real quick
16:31:37 <suzu> i go get rails and i'm done in 20 minutes
16:31:45 <suzu> is it horrible? yeah. but it works and i can move on
16:32:07 <suzu> if i need user authentication or other stuff i just go fetch some packages and glue it together quite fast
16:32:23 <suzu> so those sorts of things are much more convenient in other languages with big big ecosystems
16:32:30 <zeta_0> web_assembly/haskell integration sounds good, do you guys know it's progress ?
16:32:38 <suzu> but long-term maintainability and maturity.. haskell is best in class i think
16:32:53 <dignissimus> Out of all the solutions to the challenge, haskell is the fastest and most memory efficient: https://i.imgur.com/jeU9GG2.png
16:33:22 <suzu> 0 megabytes of memory eh
16:48:32 <godisded> Is there any data type which returns True for any (==) call?
16:48:47 <ChaiTRex> godisded: ()?
16:49:06 <dsal> :t any
16:49:07 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
16:49:13 <godisded> * with type "a".
16:50:11 <dsal> I don't see how you could pass (==) to any.  That's not the right type.
16:50:14 <dsal> :t (==)
16:50:16 <lambdabot> Eq a => a -> a -> Bool
16:50:29 <godisded> Oh, your right. My question is silly.
16:51:19 <godisded> I'm just trying to ignore part of data structure in hspec. 
16:52:12 <godisded> Something like "f x `shouldBe` Foo 2 idontcare".
16:55:06 <ChaiTRex> godisded: case f x of { Foo 2 _ -> True; _ -> False }
16:55:47 <godisded> Thanks!
16:56:18 <ChaiTRex> godisded: No problem.
17:03:57 <EvanR> c_wraith: mysterious acid-state bugs, sounds bad :S
17:05:23 <EvanR> > if people insist on quoting blocks of text using an angle bracket seems like lambdabot could notice the pattern and ignore
17:05:26 <lambdabot>  <hint>:1:36: error: parse error on input ‘of’
17:13:14 <remexre> with aeson, is there some way to parse and get whether I need more input, and get the rest of the input after the first Value
17:14:22 <remexre> something like data Result2 a = Ok (a, String) | NeedsMore String | Error String
17:16:20 <Cale> remexre: I don't believe so
17:16:30 <Cale> (what you're looking for is called incremental parsing)
17:16:57 <remexre> oh, googling for that gets me json-stream
17:17:24 <Cale> Yeah, I noticed that as well -- I've never used that library, but it might be worth a shot.
17:17:56 <remexre> http://hackage.haskell.org/package/json-stream-0.4.2.4/docs/Data-JsonStream-Parser.html#t:ParseOutput
17:17:57 <remexre> bingo
18:59:02 <irc27313> hi
19:01:00 <Guest_68> Hi guys
19:02:14 <Guest_68> i've added the HOME/.ghcup/env to my PATH but the ghc command still doesn't work, im on macos mojave
19:02:19 <Guest_68> does anybody know why
19:02:21 <Guest_68> ?
19:09:29 <evelyn> Guest_68: what does 'echo $PATH' say?
19:15:06 <Guest_68> it includes the ghcup env
19:15:26 <Guest_68> the output is : /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:$HOME/.ghcup/env:$HOME/.local/bin
19:15:46 <evelyn> OK, and what happens when you attempt to run the ghc command?
19:16:11 <MarcelineVQ> that looks wrong, afaik .ghcup/env isn't a path, it's a file that contains paths
19:16:30 <MarcelineVQ> you're meant to 'source' it, or copy the paths if contains
19:17:01 <MarcelineVQ> *paths it contains
19:18:05 <MarcelineVQ> also when adding to your PATH yourself it's preferrable to add paths to the start of PATH not the end, so they things you add yourself are found first
19:19:13 <Guest_68> oh, the $HOME/.ghcup/env file contains this: export PATH="$HOME/.cabal/bin:${GHCUP_INSTALL_BASE_PREFIX:=$HOME}/.ghcup/bin:$P$
19:19:23 <Guest_68> should i copy and paste that to the PATH file?
19:19:53 <suzu> you should `source` the $HOME/.ghcup/env file
19:20:01 <suzu> as marceline pointed out
19:23:10 <Guest_68> sorry, i don't really know what that means
19:23:19 <Guest_68> what should i write on my PATH file?
19:33:12 <suzu> do you have a ~/.bashrc file?
19:33:35 <suzu> add the line "source $HOME/.ghcup/env` to the end
19:33:42 <suzu> or create it if it does not exist and add it
19:33:59 <suzu> then open a new shell and the ghc command should work
19:34:23 <suzu> err sorry, the line is: source $HOME/.ghcup/env
19:47:51 <irc27313> :t liftA2
19:47:52 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
19:48:04 <Guest_68> thank you all for your help!
19:51:20 <justsomeguy> Is it possible to define many modules in one file?
19:53:11 <lyxia> no
19:57:48 <rotaerk> I'm trying to decide if it would be strictly beneficial to directly read from field offsets within a byte array, rather than building an entire record from one using the Storable instance
19:58:20 <rotaerk> it seems like an unnecessary copy, if you only end up using parts of the structure...
19:58:45 <rotaerk> but I feel like I'm missing a potential reason why it's not worth doing, why just peeking the whole thing is the best option
20:06:17 <ibloom> Let's say I have a Linear vector and I want to write a traversal where I do an operation on each element of the vector and for each step of the traversal, I traverse every other element of the vector. Anybody know of a polymorphic way to do this?
20:07:16 <ibloom> With normal vectors I guess I can do it with indexed traversal
20:17:09 <irc27313> we can only use do notation for monad?
20:17:47 <koz_> irc27313: In some cases, Applicative is OK if you turn on the ApplicativeDo extension (and have a recent enough GHC).
20:19:32 <irc27313> if there’re several expressions in one functions definition, how we can combine them?
20:20:32 <irc27313> and that expressions may not be with monad
20:22:02 <rotaerk> irc27313, like what, specifically
20:22:14 <rotaerk> paste example to a pastebin
20:23:46 <koz_> Yeah, this is too general a question to answer.
20:23:48 <irc27313> ok
20:24:36 <rotaerk> hmm I've decided there *is* value in keeping the bytearray around and reading individual fields out of it, rather than just marshaling the whole thing to a record...
20:25:30 <rotaerk> because sometimes that byte array needs to continue to be used by the C library you're interacting with
20:26:20 <irc27313> I’m using my phone, I'll paste later :)
20:26:40 <rotaerk> if it's simple enough, type it here
20:27:42 * hackage net-mqtt 0.6.1.0 - An MQTT Protocol Implementation.  https://hackage.haskell.org/package/net-mqtt-0.6.1.0 (dustin)
20:27:53 <rotaerk> the question is just very generic because ... well, it's generally functions that are going to combine values to produce one value, and so the question becomes *which* function do you want to combine them with?
20:28:08 <rotaerk> which depends entirely on how you want to combine them
20:29:21 <koz_> And what you want said combination to mean.
20:45:41 <arsdragonfly> hey folks, I'm having the following snippet and I'm trying to rewrite the let into where
20:45:42 <arsdragonfly> https://gist.github.com/arsdragonfly/e3317804ff598b38911c2d769affe0c4
20:46:41 <arsdragonfly> but no matter what I try, either x is out of scope or result is out of scope...
20:47:16 <arsdragonfly> what is the correct way I can rewrite the `let result =...` into `where result=...`?
20:47:55 <lyxia> don't use guards for this
20:48:22 <lyxia> findChanges bill (x : xs) = case result of ...     where result = ...
20:49:34 <lyxia> that's also   findChanges (bill - x) xs <|> findChanges bill xs
20:51:55 <arsdragonfly> wow thanks
20:52:55 <arsdragonfly> I'm wondering why <|> doesn't appear when I search for Maybe a -> Maybe a -> Maybe a on hoogle...
20:54:19 <arsdragonfly> or is that too much to ask for
20:57:25 <lyxia> yeah it seems there could be too many false positives
21:10:05 <crestfallen> hi not sure what this does. I've seen similar but I'm confused about this:
21:10:26 <crestfallen> > cc = fmap (\x y z -> x + y / z) [3,4,5,6]
21:10:29 <lambdabot>  <hint>:1:4: error:
21:10:29 <lambdabot>      parse error on input ‘=’
21:10:29 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
21:10:48 <crestfallen> @let cc = fmap (\x y z -> x + y / z) [3,4,5,6]
21:10:50 <lambdabot>  Defined.
21:11:57 <crestfallen> so I'd like to apply a lambda function to this such as:
21:12:18 <crestfallen> (<$>) bb cc
21:12:34 <crestfallen> but I'm not sure what the partial application in cc gives us
21:12:44 <ChaiTRex> @type cc
21:12:46 <lambdabot> Fractional a => [a -> a -> a]
21:13:10 <ChaiTRex> Looks like it fills in x and leaves y and z to be filled in later.
21:13:56 <crestfallen> so I need to apply it to a 2-element... what?
21:14:12 <ChaiTRex> It's a list of functions  with two arguments.
21:14:40 <crestfallen> like [a -> (a -> a)]
21:15:13 <crestfallen> thanks one moment
21:15:15 <ChaiTRex> [(\ y z -> 3 + y / z), (\ y z -> 4 + y / z), ..., (\ y z -> 6 + y / z)]
21:20:02 <crestfallen> ChaiTRex, so you're saying that bb should look like this? :
21:20:59 <crestfallen> sorry I'm confused ChaiTRex 
21:21:43 <crestfallen> if I want to write bb and have       > (<$>) bb cc
21:21:59 <crestfallen> produce something
21:23:22 <ChaiTRex> What is bb?
21:23:36 <ChaiTRex> Or what is it supposed to be?
21:23:45 <crestfallen> for example:
21:25:02 <crestfallen> @let nn = fmap (++) (Just "Hey")
21:25:03 <lambdabot>  .L.hs:210:1: error:
21:25:04 <lambdabot>      Multiple declarations of ‘nn’
21:25:04 <lambdabot>      Declared at: .L.hs:207:1
21:25:34 <crestfallen> @let oo = (\x -> x " Joe")
21:25:36 <lambdabot>  .L.hs:210:1: error:
21:25:36 <lambdabot>      Multiple declarations of ‘oo’
21:25:36 <lambdabot>      Declared at: .L.hs:208:1
21:26:12 <crestfallen> @let qq = (\x -> x " Joe")
21:26:13 <lambdabot>  .L.hs:210:1: error:
21:26:13 <lambdabot>      Multiple declarations of ‘qq’
21:26:13 <lambdabot>      Declared at: .L.hs:205:1
21:26:22 <MarcelineVQ> geeze suprised lambdabot hasn't been reset recently
21:26:26 <crestfallen> what?
21:26:27 <MarcelineVQ> @unlet
21:26:27 <lambdabot>  Define what?
21:26:40 <crestfallen> @let nn = fmap (++) (Just "Hey")
21:26:41 <lambdabot>  .L.hs:210:1: error:
21:26:42 <lambdabot>      Multiple declarations of ‘nn’
21:26:42 <lambdabot>      Declared at: .L.hs:207:1
21:26:46 <crestfallen> @let oo = (\x -> x " Joe")
21:26:47 <MarcelineVQ> It's got all your old defintions still, based on the errors you're causing
21:26:47 <lambdabot>  .L.hs:210:1: error:
21:26:47 <lambdabot>      Multiple declarations of ‘oo’
21:26:47 <lambdabot>      Declared at: .L.hs:208:1
21:26:55 <ChaiTRex> @reset
21:26:56 <lambdabot> Say again?
21:27:05 <MarcelineVQ> No sense wipingit now :>
21:27:25 <crestfallen> how about now? :)
21:27:32 <MarcelineVQ> :t oo
21:27:34 <lambdabot> ([Char] -> t) -> t
21:27:38 <MarcelineVQ> seems fine
21:27:52 <crestfallen> oo <$> nn
21:27:58 <crestfallen> > oo <$> nn
21:28:00 <lambdabot>  Just "Hey Joe"
21:28:49 <crestfallen> so well I'm looking for the same input to bb <$> cc
21:29:03 <crestfallen> but I can't see the structure of it
21:31:04 <crestfallen> so fmapping  (\x y z -> x + y / z) [3,4,5,6] just takes care of the x
21:31:39 <ChaiTRex> crestfallen: To take care of the y, cc <$> [1, 2, 3]
21:32:04 <ChaiTRex> crestfallen: That should give you 12 functions.
21:32:13 <ChaiTRex> crestfallen: In a list.
21:34:21 <MarcelineVQ> "<crestfallen> so fmapping  (\x y z -> x + y / z) [3,4,5,6] just takes care of the x" yes, because fmap for lists is map, and map applies its function a single time for each item of a list. building  new list of partially applied functions in this case.
21:35:14 <ChaiTRex> crestfallen: Sorry, it would be <*> rather than <$>
21:35:39 <ChaiTRex> @type cc <*> [1, 2, 3]
21:35:41 <lambdabot> Fractional a => [a -> a]
21:36:35 <crestfallen> so we can't use the same structure as oo <$> nn above?
21:36:48 <crestfallen> with 2 fmaps
21:37:39 <crestfallen> @let bb = <*> [1,2,3]
21:37:39 <lambdabot>  Parse failed: Parse error: <*>
21:37:47 <ChaiTRex> crestfallen: It would be something like (\ x y z -> x + y / z) <$> [3..6] <*> [1..3]
21:37:50 <crestfallen> @let bb = (<*>) [1,2,3]
21:37:51 <lambdabot>  Defined.
21:38:07 <ChaiTRex> @type (\ x y z -> x + y / z) <$> [3..6] <*> [1..3]
21:38:08 <lambdabot> (Fractional a, Enum a) => [a -> a]
21:38:14 <crestfallen> > bb <$> cc
21:38:16 <lambdabot>  error:
21:38:16 <lambdabot>      • Couldn't match type ‘Double -> Double -> Double’ with ‘[a0]’
21:38:16 <lambdabot>        Expected type: [[a0]]
21:38:17 <sarahzrf> i just got a heap overflow error... wat
21:40:15 <crestfallen> > cc <$> bb
21:40:17 <lambdabot>  error:
21:40:17 <lambdabot>      • Couldn't match expected type ‘[b0] -> b’
21:40:17 <lambdabot>                    with actual type ‘[Double -> Double -> Double]’
21:44:01 <crestfallen> @type (\ x y z -> x + y / z) <$> [3..6] <*> [1..3] <*> [6,7,8]
21:44:02 <lambdabot> (Fractional b, Enum b) => [b]
21:45:32 <crestfallen> @let aa = (<*>) [6,7,8]
21:45:35 <lambdabot>  Defined.
21:47:00 <ChaiTRex> crestfallen: (<*>) [6..8] is the same as (\ x -> [6..8] <*> x), not (\ x -> x <*> [6..8])
21:47:47 <ChaiTRex> @type (<*>) [6, 7, 8]
21:47:48 <lambdabot> Num (a -> b) => [a] -> [b]
21:47:54 <ChaiTRex> @type (<*> [6, 7, 8])
21:47:56 <lambdabot> Num a => [a -> b] -> [b]
21:50:03 <crestfallen> ChaiTRex, so we can't do this the same as the ' Just "Hey Joe" ' example above, with 2 fmaps?
21:50:37 <ChaiTRex> crestfallen: No, fmap has a function that's not in the functor. It's a function, not a list of functions.
21:51:17 <ChaiTRex> crestfallen: For a list of functions to apply, you generally want <*>.
21:51:26 <crestfallen> ok so the arguments have to be organized using <*>
21:51:39 <ChaiTRex> @type fmap
21:51:41 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:51:45 <ChaiTRex> @type (<*>)
21:51:47 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
21:52:32 <crestfallen> @let aa = (<*> [6..8])
21:52:33 <lambdabot>  .L.hs:212:1: error:
21:52:33 <lambdabot>      Multiple declarations of ‘aa’
21:52:33 <lambdabot>      Declared at: .L.hs:211:1
21:52:40 <crestfallen> @let xx = (<*> [6..8])
21:52:42 <lambdabot>  Defined.
21:53:58 <crestfallen>  @let qq = (<*> [1,2,3])
21:54:12 <crestfallen> @let qq = (<*> [1,2,3])
21:54:12 <lambdabot>  .L.hs:213:1: error:
21:54:13 <lambdabot>      Multiple declarations of ‘qq’
21:54:13 <lambdabot>      Declared at: .L.hs:205:1
21:54:21 <crestfallen> @let ww = (<*> [1,2,3])
21:54:23 <lambdabot>  Defined.
21:58:15 <crestfallen> @let clusterF = cc xx ww
21:58:16 <lambdabot>  .L.hs:214:12: error:
21:58:16 <lambdabot>      • Couldn't match expected type ‘([Integer -> b0] -> [b0])
21:58:16 <lambdabot>                                      -> ([Integer -> b1] -> [b1]) -> t’
21:58:43 <crestfallen> ChaiTRex, you like my artwork?
21:59:44 <arsdragonfly> btw @lyxia it turned out that using <|> was wrong, in a very subtle way
22:00:03 <arsdragonfly> for the codewars problem that I was working on
22:03:03 <dsal> Someday I'm going to learn why people like stuff like mtl instead of just passing a bunch of parameters around.
22:06:33 <suzu> just use extensible effects yall
22:06:38 <suzu> mtl is old news!!
22:07:17 <rotaerk> which package do *you* recommend for that
22:07:46 <suzu> 🤔
22:07:54 <suzu> polysemy
22:08:07 <suzu> is a fine choice
22:10:25 <rotaerk> k
22:12:54 <suzu> eff is very new but maybe that too
22:12:56 <suzu> https://github.com/hasura/eff
22:13:07 <suzu> like its 4 days old
22:13:40 <nshepperd> i like mtl because it makes me feel fuzzy and warm inside
22:22:13 <koz_> nshepperd: Interesting. :P
22:27:39 <koz_> suzu: Is that Alexis' work?
22:37:46 <koz_> Also, what kind of type class am I hunting for that permits m (a, a) -> (m a, m a) ?
22:38:17 <koz_> Functor, extensible effecting really?
22:41:32 <MarcelineVQ> koz_: I think there was something called distribute that might have been the opposite of bitraverse, can't check just now
22:43:40 <nshepperd> :t \m -> (fmap fst m, fmap snd m)
22:43:42 <lambdabot> Functor f => f (a, b) -> (f a, f b)
22:44:13 <koz_> Yeah, nshepperd just quoted the thing I found. :P
22:44:35 <koz_> (also, for the record, 'distribute' is the opposite of 'traverse' - there is no 'bidistribute' as far as I'm aware)
22:45:08 <nshepperd> Distributive is a thing too but i don't really understand it
22:45:33 <koz_> nshepperd: It's a stepping stone to Representable mainly.
