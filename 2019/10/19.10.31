01:42:36 <Ariakenom> exceptions! when using threads you may end up wanting to rethrow several of them, any nice solution?
01:45:17 <Ariakenom> in python I've sometimes thrown an exception from a handler. which creates a chain of "this exception directly caused the following exception". which I thought was useful for including lower and higher level information in the stack trace. anyone have anything that solves similar issues?
01:47:08 <Ariakenom> I can imagine a (withAdditionalExceptionText "Failed to write key X") wrapper
01:48:16 <Rembane> Which kind of exceptions are you using? 
01:49:01 <Ariakenom> Rembane: I dont have any specific code im talking about
01:49:11 * hackage servant-elm 0.7.1 - Automatically derive Elm functions to query servant webservices.  https://hackage.haskell.org/package/servant-elm-0.7.1 (k_bx)
01:49:46 <Rembane> Ariakenom: Got it. 
01:50:23 <Ariakenom> Rembane: which different kinds do you mean?
01:50:54 * Ariakenom fears for his life after having said "in python I" in a haskell channel
01:51:18 <Rembane> Ariakenom: There are ExceptT, the IO exceptions, the IO exceptions but in a more general monadic context, and those are the ones I remember on the top of my head.
01:52:08 <Ariakenom> right
01:53:23 <Rembane> And you have the exceptions you really shouldn't mess with and those that you should, and syncronous ones and asynchronous ones
01:53:51 <Ariakenom> indeed
01:54:03 <Rembane> It's an interesting topic. 
01:56:44 <Ariakenom> the questions probably apply to all types. maybe even async since its about rethrowing
02:07:53 <maerwald> there's more than ExceptT even :)
02:08:43 <nesqi> Hi! I'm looking for the correct terminologi so that I know where to dig out more info online. First of all, what are the abstract data types using the | operator called in contrast to the types without | (like a record)? 
02:09:17 <plakband> nesqi: sum types?
02:09:26 <maerwald> do you mean algebraic data types? abstract data types is something different
02:09:46 <plakband> nesqi: https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/sum-types
02:10:20 <nesqi> Yeah, I probably mixed up the words =u
02:11:00 <nesqi> Right, sum types.
02:11:21 <boxscape> nesqi  `data A = MkA Int String` on the other hand would be a product type
02:11:54 <nesqi> Are sum-types and product types both algebraic types?
02:12:27 <boxscape> yes
02:12:54 <boxscape> in fact that's why they're called algebraic types, because sum types and product types form an algebra, with many of the usual rules for adding and multiplying
02:12:55 <isn> Hey guys. I'm trying to make simple rock, paper & scissors game using typeclasses etc. Can you take a look at my code at: https://pastebin.com/VpxrAkwB - I think I've got the logic, but not sure how I could execute this
02:13:05 <nesqi> Ok, great! Now maybe I can formulate my real question =)
02:14:26 <plakband> isn: you'll have to be more specific about what you mean by execute
02:15:40 <isn> Well, I've got the data type, class and instance. I want to test it out in the ghci, but I'm not sure how. Do I need to make 2 variables of type Move? 
02:16:50 <isn> When I want to create a variable, Rock for example like this: let t :: Move = Rock, I'm getting the error: Illegal type signature: ‘Move’
02:17:48 <plakband> isn: at this point you can ask ghci e.g.  Paper `beats` Paper
02:18:19 <plakband> you don't need the type signature, it's clear from the context
02:18:23 <isn> Ah awesome, it indeed works! Thanks! :)
02:18:57 <plakband> There's an extension to support that syntax, but you def don't need it
02:19:49 <isn> Ah alright, thanks for checking it out :)
02:20:18 <boxscape> isn: what you wanted to do works as well, but you have to do `let t :: Move; t = Rock`
02:20:20 <isn> I was confused because everything is "automatically" being loaded
02:21:03 <plakband> I have a recursive data structure, that has both a Lift element (like a free monad), as well as an annotation at every recursion (like a cofree comonad). Is there some recursion scheme that combines these two properties?
02:21:53 <coot> @Phyx-  thanks a lot for `ghc` package on `chocolatey`, this makes provisioning Windows VMs into really pleasant experience! `ghc-8.6.5` comes with `cabal-install-3.0` which is better than the official haskell-platform!
02:21:53 <lambdabot> Unknown command, try @list
02:23:31 <nesqi> I have a huge AST that is build up from many algebraic datatypes. I figure i can access and modify product-types using records and lenses. My problem is with the sum-types. I need some kind of alternative to pattern-matching as it's truely impractical to match all fields when you have 2 or 3 levels of types. I guess I cold generate composible predicates usig GADT but it feels like this problem already has b
02:23:37 <nesqi> een solved many times by others and I'm looking for a hinter where to go next. For example will some part of the lenses library help me with this? 
02:25:44 <boxscape> % Right 4 & _Left .~ True & _Right .~ "foo"
02:25:44 <yahb> boxscape: Right "foo"
02:25:51 <boxscape> do prisms do what you need?
02:26:26 <nesqi> I dont know =) I'm looking for tips on where to readup =) Maybe they do.
02:26:59 <boxscape> they're a lot like lenses (and in the lens library) but for values that might or might not exist, such as in sum types
02:28:30 <nesqi> Sounds about right
02:29:07 <boxscape> % [Right 5, Left "no", Right 6] & traverse._Right .~ True -- perhaps a more interesting example
02:29:08 <yahb> boxscape: [Right True,Left "no",Right True]
02:31:14 <merijn> That's just "fmap.fmap.const" with more complications :p
02:31:44 <boxscape> that's fair, but not every sum type is a Functor
02:32:19 <Rembane> Set the sum types Free! 
02:47:03 <jpcooper> Hello. I have locally cloned a stack package from github, and I have made some changes. I now want to include this package as an extra-dep in another stack package. I do not want to include it as a git repository, as I do not want to make a commit every time I make a change. Is it possible to include it in some other way so that all changes are automtaically incorporated by the including stack package?
02:47:07 <jpcooper> (when building)
02:48:49 <MarcelineVQ> sure, just add its dir to extra-deps
02:49:57 <jpcooper> MarcelineVQ: I tried that, but it doesn't seem to be recompiling when I make changes. I added the line '- /dirname' to extra-deps
02:51:42 <MarcelineVQ> oh? hmm
02:56:04 <jpcooper> Might be worth going down the git route for now
03:00:23 <jpcooper> Sorry. I was including the wrong directory. It works fine
03:06:12 * hackage optima-for-hasql 0.1.0.1 - Command-line arguments parsing for Hasql  https://hackage.haskell.org/package/optima-for-hasql-0.1.0.1 (NikitaVolkov)
03:22:22 <boxscape> hasql is such a good name
03:35:13 <nesqi> boxscape: Thank you! I think prisms are what I was looking for!
03:35:20 <boxscape> nice
03:49:01 <Phyx-> coot: np :) if you also install msys2 via chocolatey you'll get everything platform gives. the cabal package will detect this and configure itself to work with it automatically 
03:49:45 <Phyx-> coot: the `haskell-dev` package is more or less a drop in replacement for platform. it's a synonym for choco install ghc cabal msys2
03:51:53 <Phyx-> coot: btw, you probably know if you're provisioning VMs, but do you know boxstarter? :) it makes things even easier since any chocolatey package that requires a restart to configure it'll restart and continue on it's own.
03:55:05 <coot> @Phyx-  All I need was `choco install ghc git` (and maybe `choco install cabal`); cool, I didn't know boxstarter, thx for a tip.  I am not provisioning very often, and mostly just to get my own dev-environment.
03:55:05 <lambdabot> Unknown command, try @list
03:57:40 <Phyx-> coot: yeah, any ghc > 7.4 I believe has the cabal dependency specified in the package, older ones don't like if using 6.4 or something :) you'll need msys2 if you want to install configure based packages like gtk or network. but you can install it any time with choco install msys2, the package will still pick it up
04:01:18 <coot> Phyx-: I think `msys2` comes as a dependency of `git`, but I am not sure.  Good point, I will needed it as I am working on an application which is network heavy (cardano node for IOHK).
04:26:06 <JohnRobinson> Hello all. I'm trying to create a simple api with Servant but I'm getting compile errors based around my use of :<|> . and my imports list . I'm absolutely stumped as to how I can resolve it. If someone could give me some advice, it would be very much appreciated
04:26:24 <JohnRobinson> I've created a gist with the code here - https://gist.github.com/jrobinson-scottlogic/60b5134390c74024bbae5b8c611f346e
04:27:11 <JohnRobinson> If I change my Servant import line to:import Servant (Application, Get, JSON, serve, (:>), (:<|>))
04:27:41 <JohnRobinson> then it fails. but if I just use: import Servant 
04:27:53 <JohnRobinson> then it works. 
04:28:24 <JohnRobinson> Could someone give me some advice as to how I might get it to compile using the first strategy?
04:32:15 <phadej> ... , (:<|>)(..))
04:33:07 <phadej> cv. import Data.Functor.Identity (Identity (..))
04:33:09 <phadej> cf
04:36:48 <erisco> Anyone know of FP communities in Ontario?
04:37:17 <JohnRobinson> That works! Many thanks phadej :)
04:37:31 <absence> there are tens of hits when searching for an uri library on hackage. does anyone know which is "the" uri library? i want to do stuff like build an url from its parts without worrying about encoding or "?" "&" "#", preferably with a representation that isn't a cache hostile linked list of utf-32 characters
04:45:06 <phadej> there's network-uri and uri-bytestring
05:17:00 <zincy_> How do you decide between JSON serialisation vs binary generally? If you can in the abstract?
05:17:32 <MarcelineVQ> whynotboth.jpg
05:17:52 <zincy_> oh yeah
05:20:53 <unfixpoint> I'm using stack to build multiple executables from common code, so I use a .cabal w/ `library bla-lib ...`, `executable bla0 ...` and `executable bla1 ...` which works if I use a common folder for the executables and a separate folder for the library. Basically, like this: https://pastebin.com/bH2JM2ei
05:21:49 <unfixpoint> But this feels rather awkward, building is fine. However, firing up `ghci` is annoying, I always need to `:set -ilib -isrc`. Thus I'm wondering, if this is the right approach?
05:22:31 <__monty__> Does `stack ghci` help?
05:22:32 <tabaqui1> unfixpoint: try to replace "library bla" with just "library"
05:22:57 <tabaqui1> and replace your "build-depends: bla-" with your cabal package name
05:23:14 <unfixpoint> __monty__: That's what I meant, sorry
05:23:39 <unfixpoint> One sec, I'll check. Sounds promising!
05:23:43 <tabaqui1> when you define "library blah", you make it internal
05:25:06 <unfixpoint> I see, yeah this works like a charm!
05:25:28 <unfixpoint> Beautiful, thank you kindly =)
05:25:36 <tabaqui1> cool :)
05:28:59 <absence> phadej: yes, and a bunch of others as well, and some of them (for example network-uri) are represented as a linked list of characters, hence my question :)
05:40:00 <nesqi> How can you view the intermediate haskel generated with template haskell?
05:40:09 <tabaqui1> --dump-splices
05:42:05 <nesqi> And how do you pass that if your building using stack =)?
05:43:13 <tabaqui1> *-ddump-splices
05:43:25 <tabaqui1> --ghc-options -ddump-splices, for example
05:44:47 <fendor> @where type-theory
05:44:47 <lambdabot> I know nothing about type-theory.
05:44:55 <fendor> @where type
05:54:45 <boxscape> hmm odd that lambdabot doesn't respond to that
05:55:35 <boxscape> @where where
05:55:36 <lambdabot> ^^^^^^
05:57:20 <fendor> maybe lambdabot needed a break
05:57:22 <fendor> @ehere type
05:57:26 <fendor> @where type
05:57:33 <fendor> @where me
05:57:33 * lambdabot knows nothing about me.
05:57:39 <boxscape> @where you
05:57:39 <lambdabot> I'm right here, silly.
05:57:55 <fendor> @where we
05:57:55 <lambdabot> I know nothing about we.
05:59:11 <boxscape> @where hott fendor: FWIW this exists but it might not have been what you were looking for
05:59:11 <lambdabot> http://homotopytypetheory.org/book/
05:59:58 <__monty__> @where tapl <- for the more basic stuff.
05:59:58 <lambdabot> "Types and Programming Languages" by Benjamin C. Pierce in 2002-02-01 at <https://www.cis.upenn.edu/~bcpierce/tapl/>
06:00:11 <fendor> I am looking for a book that explained at the beginning sum and producttypes very well, as well as type isomorphism. I started it, but lost it some time ago
06:00:37 <fendor> like, a light introduction to type theory
06:00:50 <fendor> may be less light at the end, but i dunno
06:02:58 <dolio> hott is definitely not light.
06:04:36 <fendor> dolio, the first sentence hints at it :D 
06:04:42 <nesqi> Oh... it seems you cannot combine lenses with GADTs, is that correct is or there some more depth to this?
06:04:45 <fendor> Homotopy type theory is (among other things) a foundational language for mathematics, i.e.,an alternative to Zermelo–Fraenkel set theory.
06:04:56 <tabaqui1> oh, hackage now shows definition in floating window
06:04:58 <tabaqui1> so cool
06:05:30 <dolio> Well, it's way nicer than ZF.
06:05:49 <fendor> My favourite quote from a report: "This report should be readable by nearly everybody — even with only a moderate mathematical literacy."
06:06:01 <__monty__> nesqi: What makes you say this? (Don't have anything to contribute but surprises me.)
06:06:09 <dolio> I think it's probably not a good way to learn type theory unless you're already a mathematician, though.
06:07:51 <fendor> yeah, as said, the one I got from here, I think, was very light and breezy. Perfect while drinking a nice cup of coffee and only having a minor in cs
06:08:18 <fendor> not that the major would help me
06:08:47 <__monty__> fendor: TAPL's a really good book, so I'd still recommend it as "light reading" : >
06:08:51 <nesqi> __monty__: Well, error messages... I'm revisiting old code so I'm not entirely sure it's actual GADTs i'm using =)
06:09:14 <nesqi> IS GADTs a new language directive?
06:09:26 <__monty__> It's a language extension yes.
06:11:43 <nesqi> I thought I was using GADTs but i'm "only" extending with these....  {-# LANGUAGE PolyKinds #-} {-# LANGUAGE TypeOperators #-} {-# LANGUAGE DeriveGeneric #-} {-# LANGUAGE DeriveAnyClass #-} {-# LANGUAGE FlexibleContexts #-} {-# LANGUAGE FlexibleInstances #-} {-# LANGUAGE DefaultSignatures #-} {-# LANGUAGE ScopedTypeVariables #-}
06:12:16 <nesqi> So I was thinking that maybe GADTs is the new way of doing it and that my code is old.
06:12:55 <boxscape> nesqi it looks like maybe the template haskell generation of lens doesn't work with some GADTs, but that doesn't stop you from uses lenses with GADTs. Worst case scenario is just having to define the lenses by hand
06:12:58 <nesqi> Oh man.. I should probably just throw it all out and use template-haskell
06:13:06 <fendor> __monty__, books are great iff they start with a chapter dependency graph
06:13:12 <__monty__> GADTs aren't *that* popular, ime. I'd say only use them if you need them. Or use them if you need them somewhere in the project and you want consistency.
06:14:00 <__monty__> fendor: : ) EOPL is another goody, less about type theory though, more language implementation, kind of a sequel to sicp.
06:17:22 <fendor> __monty__, thanks, enough books for now :D 
06:22:26 <nesqi> The only reason I hade for using GADTs was that I didn't like template-haskel but now I have to use that anyway if I'm going to use makeLenses.
06:25:16 <nesqi> Hm.. I'm mixing up terminology again. I'm using generics not GADTs.
06:28:45 <kosmikus> nesqi: generic-lens ?
06:29:29 <nesqi> kosmikus: What is that?
06:29:37 <kosmikus> http://hackage.haskell.org/package/generic-lens
06:30:53 <nesqi> It's a way to use generics instead of template-haskell to make lenses?
06:31:11 <kosmikus> yes
06:31:41 <cheater> is there a way i could easily download all packages from hackage that have been updated in the last 3 years, or 5 years, or something similar? i only need the most recent version. i want to analyse the source code.
06:32:02 <merijn> cheater: Probably simpler to just download everything and filter locally?
06:32:26 <cheater> is there a way i can download everything without putting a lot of load on hackage?
06:32:27 <kosmikus> cheater: there's http://neilmitchell.blogspot.com/2018/11/downloading-all-of-hackage.html ; perhaps you can adapt that to your purposes
06:32:56 <cheater> i wonder how large all packages would be? i don't have terabytes free so i was hoping to prevent downloading loads of stuff that i'd have to delete
06:33:00 <merijn> cheater: hackage is behind a CDN anyway, so I wouldn't worry about it
06:33:06 <cheater> ah
06:33:09 <cheater> kosmikus: thanks
06:33:15 <merijn> cheater: Probably sooner to be like a few GB *max*?
06:34:50 <boxscape> cheater I downloaded it the other day, don't remember how large it is, but it's not that bad
06:35:50 <merijn> cheater: Fastly does Hackage's CDN hosting as charity to open source
06:36:15 <boxscape> cheater be sure to check the comments of that blogpost for the actual solution
06:36:26 <merijn> Pretty sure their infrastructure can handle one or two infrequent scrapes ;)
06:36:27 <cheater> boxscape: yeah i noticed. just a bash one liner
06:37:55 <cheater> i'm slowly trying to define another new keyboard layout and i'd like to see what sort of code is being written in haskell, to get a clear indication for how to structure this layout. between haskell and english and readline commands that's probably the largest use of the keyboard that i do.
06:40:07 <boxscape> personally I set up editor shortcuts for frequently used sequences in haskell, something similar to (but not exactly) "-." expanding to " -> "
06:40:17 <boxscape> (i.e. adds spaces and shift)
06:42:02 <nesqi> kosmikus: Have you used generic-lens? It seems nice but a bit complicated =) Does it come with caveats?
06:45:02 <boxscape> nesqi I haven't really used but tried out generic-lens, from what I can see the nicest feature is being able to have #name as lens for a record field called "name", but using that feature comes with the caveat of using orphan instances for IsLabel
06:46:29 <boxscape> though that was before I knew that lens lets you make lenses for duplicate record fields as well
06:46:41 <boxscape> (with its template haskell machinery)
07:00:06 <c_wraith> boxscape: generic-lens lets you use lenses for named fields as long as the record type has a Generic instance.  Shouldn't need orphans for that.
07:00:31 <boxscape> c_wraith the docs for Data.Generics.Labels start with "Provides an (orphan) IsLabel instance for field lenses and constructor prisms. Use at your own risk.
07:00:33 <boxscape> "
07:01:17 <c_wraith> yes, but you should be looking at Data.Generics.Product.Fields
07:01:54 <boxscape> ah, but that doesn't allow you to write #name, which to me was the most appealing aspect
07:03:55 <c_wraith> Oh.  I just looked at Data.Generics.Labels - it *provides* the instance.  You don't need to add any more.
07:04:08 <boxscape> right
07:04:35 <c_wraith> So it really doesn't matter that it's orphaned, unless one of the dependencies decides to add it.
07:05:01 <boxscape> Isn't that the case with orphan instances in general?
07:06:30 <c_wraith> sure.  But not having to add another one for every single data type is the big win
07:06:42 <boxscape> that's ture
07:06:45 <boxscape> true*
07:09:42 * hackage lightstep-haskell 0.2.0 - LightStep OpenTracing client library  https://hackage.haskell.org/package/lightstep-haskell-0.2.0 (DmitryIvanov)
07:17:12 * hackage taskell 1.7.0.0 - A command-line kanban board/task manager  https://hackage.haskell.org/package/taskell-1.7.0.0 (smallhadroncollider)
07:17:33 <cheater> ok so it's like 1-2 gigs
07:17:36 <cheater> that's alright
07:33:12 * hackage hpqtypes 1.8.0.0 - Haskell bindings to libpqtypes  https://hackage.haskell.org/package/hpqtypes-1.8.0.0 (arybczak)
07:38:32 <dmwit> boxscape: Hey, me too! https://gist.github.com/dmwit/88c2c9806191075b32b491864efaafc9#file-haskell-vim-L3-L25
07:39:01 <dmwit> You should share yours so I can steal the good ones.
07:40:41 <boxscape> dmwit not at home right now unfortunately, so don't have access to it
07:40:52 <boxscape> but thanks for sharing yours :)
08:06:12 * hackage fields-json 0.4.0.0 - Abusing monadic syntax JSON objects generation.  https://hackage.haskell.org/package/fields-json-0.4.0.0 (arybczak)
08:06:57 <merijn> hmm, so does anyone have any suggestions on how to nicely linewrap long GADT declarations? (i.e. the constructor type signatures becoming long)
08:07:38 <MarcelineVQ> whatchu got?
08:08:23 <merijn> MarcelineVQ: Nothing tbh, usually my GADTs had like 1 or 2 arguments
08:14:28 <MarcelineVQ> I tend to put what fits on a line and line up -> with :: when I \n. e.g. 
08:14:28 <MarcelineVQ> data Foo a where
08:14:28 <MarcelineVQ>   Kap :: Foo a
08:14:28 <MarcelineVQ>   Dob :: (Applicative g, Applicative f)
08:14:28 <MarcelineVQ>       => (a -> b -> c) -> f (g a) -> f (g b)
08:14:29 <MarcelineVQ>       -> SomeLongerTypeName c
08:15:20 <MarcelineVQ> pretend the last ends in Foo as well
08:18:12 <lyxia> type SomeLongerTypeName = Foo
08:18:14 <lyxia> :P
08:18:20 <infandum> I have a huge file that I need to stream to read, filter, and transform. Can I parallelize this process? Can the reading be parallelized?
08:19:04 <merijn> infandum: parallelising the reading is hard, parallelising the transform might be doable, depending on what you're doing and why you wanna parallelise
08:19:18 <merijn> infandum: I assume the data is some sequence of "records"?
08:20:09 <merijn> Because I'd probably just use conduit + some convenient parser library to a streaming parse of the input data to process it
08:20:35 <merijn> Now, if you wanna parallelise it because the transform is some sort of slow IO-bound thing, then I actually have a trivial solution for you :p
08:20:43 <infandum> merijn: Essentially a tab delimited file, each row is a "record", sure.
08:21:00 <merijn> infandum: And what does transforming entail?
08:21:34 <MarcelineVQ> there's an interesting series of posts on this subject https://haskell-works.github.io/archive.html
08:23:48 <infandum> I basically need to change the format of the lines and then output them to another file. Then I need to take the same original file, stream it again to convert it to a matrix (think of it like a row\tcolumn\tvalue (but I need to transform it to get those)) by generating indices from the possible rows and columns (I have HashMaps to Ints, but I need to read all of the values first and thus destroy the stream).
08:24:27 <merijn> infandum: I don't really see how you'd parallelise that process?
08:25:05 <infandum> Technically I can't parallelize this process, as it requires a stream, but if I could parallelize that stream (1 process do the first 10000, 1 process do the second 10000, etc.)
08:25:15 <infandum> Right now I'm using the streaming library
08:25:35 <infandum> So there isn't a way to start each process at various points of the file or a stream?
08:26:03 <merijn> Is there "a" way, sure. but not one that's prebuilt
08:26:41 <merijn> I mean, you can just hSeek to random offsets, but then you need to somehow identify where (for example) the line ends relative to your offset, etc. which is all possible, but tricky and messy
08:26:51 <merijn> So whether it's worth it depends on the size of your input file
08:27:06 <merijn> You say "huge", but what's huge? 100s of MBs? 100s of GBs?
08:27:20 <merijn> And how fast does it need to be
08:27:49 <infandum> At least 10GB
08:28:55 <infandum> In terms of how fast -- I don't have any particular time constraint, but as fast as I can reasonably get without going too low level
08:29:09 <infandum> So parallelizing is the "simplest" solution right now
08:29:30 <infandum> Also, these matrices take up a lot of space -- is there a Haskell solution to work with them on disk?
08:29:32 <Geekingfrog> infandum, recently there was a post about implementing `wc` in haskell. The guy did parallel reading with some clever knowledge about new lines in utf8: https://github.com/ChrisPenner/wc
08:30:42 <infandum> I think HDF5 or something can do the disk storage trick? Not sure.
08:31:14 <boxscape> % newtype N = N Int
08:31:14 <yahb> boxscape: Could not find module `GHC.TypeLits.Normalise'; Use -v to see a list of the files searched for.
08:31:16 <boxscape> what does this mean
08:32:41 <MarcelineVQ> % :show language
08:32:41 <yahb> MarcelineVQ: base language is: Haskell2010; with the following modifiers:; -XBangPatterns; -XConstrainedClassMethods; -XConstraintKinds; -XDataKinds; -XNoDatatypeContexts; -XDeriveDataTypeable; -XDeriveFoldable; -XDeriveFunctor; -XDeriveTraversable; -XDisambiguateRecordFields; -XEmptyCase; -XExistentialQuantification; -XExplicitForAll; -XExplicitNamespaces; -XFlexibleContexts; -XFlexibleInstance
08:32:51 <infandum> Geekingfrog: Ah, seems he uses "hSeek fileHandle AbsoluteSeek offset"
08:33:26 <infandum> The offset is given as bytes though
08:33:39 <geekosaur> %k N
08:33:42 <geekosaur> er
08:33:45 <geekosaur> % :k N
08:33:46 <yahb> geekosaur: ; <interactive>:1:1: error: Not in scope: type constructor or class `N'
08:34:02 <geekosaur> not sure why it's looking for natnormalise
08:34:04 <Geekingfrog> infandum, you may be able to do something similar with some aditional knowledge about your dataset.
08:35:09 <infandum> Geekingfrog: possibly, yeah
08:35:13 <MarcelineVQ> kinda seems like a ghc bug, mine doesn't do that at least, even with DataKinds on, which would have seemed like the most likely culprit since nothing is being 'derive'd
08:35:29 <geekosaur> hSeek offset is always in bytes. for lines, one can read forward from an arbitrary position to the next newline; this works better when the standard deviation of the lengths of lines is low
08:36:22 <merijn> geekosaur: I'm not sure you can actually sanely do that?
08:36:58 <merijn> geekosaur: Suppose the file is utf-8, how would you determine you're actually decoding the right codepoints?
08:37:20 <geekosaur> if the 8th bit is set, you'r'e in the middle of a codepoint
08:37:42 <merijn> geekosaur: Ah, so all multi-byte ones have the high bit set?
08:37:46 <geekosaur> yes
08:38:11 <c_wraith> In fact, they have n high bits set, where n is the number of extra bytes devoted to the codepoint
08:38:18 <merijn> That's something, I suppose. Now you just need to hope it's indeed utf-8 :)
08:38:19 <geekosaur> ^
08:38:40 <infandum> Well it should be ASCII, but no more than utf-8
08:39:09 <geekosaur> utf8 was specifically designed to support this, to minimize the amount of work needed to port programs assuming ASCII or ISO
08:39:18 <geekosaur> thus doing things like this kind of seeking
08:49:16 <ddellacosta> Are there standard approaches to writing an event loop in Haskell for an app that requires user interaction? Or does this tend to be dependent on whatever GUI library folks use?
08:50:10 <merijn> ddellacosta: The standard approach is "one thread per activity and just write blocking code"
08:50:42 <merijn> ddellacosta: If you need to serialise processing in, say, your UI drawing thread you could create a channel and have the UI thread read events from the channel
08:51:35 <ddellacosta> merijn: gotcha, that's helpful enough to get me started I think. Thanks
08:52:11 <merijn> ddellacosta: The runtime system already uses an event loop to schedule individual threads
08:54:22 <ddellacosta> merijn: yeah, was just looking at e.g. https://hackage.haskell.org/package/brick-0.50/docs/Brick-Main.html#g:1 and trying to understand how that fit into more general architectural practices in Haskell, but I think you've answered that
08:54:53 <merijn> ddellacosta: I'd say Chan/MVar to signal various threads
08:55:35 <merijn> Could even use a Chan to publish "events" to and then parts of the publication can "opt-in" to receiving them
08:55:49 <merijn> Although then you should probably use BroadcastChan to avoid space leaks
08:57:33 <ddellacosta> merijn: okay, thanks for the tips. I sense that I will be revisiting the concurrent programming bits from Simon Marlow's book in the very near future...
08:57:43 <merijn> @hackage broadcastchan
08:57:44 <lambdabot> http://hackage.haskell.org/package/broadcastchan
08:57:53 <merijn> oh, wait, probably broadcast-chan
08:58:07 <merijn> @hackage broadcast-chan
08:58:07 <lambdabot> http://hackage.haskell.org/package/broadcast-chan
08:58:35 <ddellacosta> interesting, thanks
08:58:37 <dsal> :t newBroadcastTChan
08:58:38 <lambdabot> error: Variable not in scope: newBroadcastTChan
08:58:50 <dsal> I used that recently, anyway.  It's pretty nice.
08:59:07 <merijn> dsal: This fixes the problem that newBroadcastTChan fixes for TChan, yes
08:59:21 <dsal> Oh, broadcast-chan does?
08:59:46 * dsal is early and confused
08:59:51 <merijn> dsal: I suggested adding "newBroadcastChan" to Control.Concurrent.Channel, was told "we're not sure there is demand for that"
09:00:19 <dsal> Oh.  Yeah, that's a little weird.  I needed that in my first concurrent project in haskell.
09:00:27 <merijn> So I wrote my own library, but I since extended it with other stuff like being able to close them (so if you have a thread looping over a Chan you can actually detect when the other side is done writing
09:01:13 <merijn> dsal: Of course, the real killer feature *now* is the parMap stuff I added because I kept reinventing it in every concurrent project I did
09:01:28 <dsal> How is that related?
09:01:45 <merijn> dsal: It uses broadcast-chan to implement things
09:02:25 <merijn> In hindsight broadcast-chan is a bit of a misnomer, since the most useful stuff is actually *using* those, rather than implementing them :p
09:06:07 <ChrisPenner[m]> infandum: if you look at the Streamly implementation at the bottom of the post you'll see that Streamly can easily parallelize a linear streaming task across multiple threads. It sounds like what you want
09:15:50 <dmj`> streamly is a cool idea, take the vector streaming internals and make a library out of it
09:18:56 <ddellacosta> merijn: how does your broadcast-chan approach compare to using bounded channels?
09:19:29 <ddellacosta> I'm looking at https://hackage.haskell.org/package/stm-chans-3.0.0.4/docs/Control-Concurrent-STM-TBChan.html and some other libraries that are out there now
09:20:55 <merijn> ddellacosta: It doesn't really, as there's no STM based implementation (yet) and BroadcastChan isn't bounded. Probably the stm channel will perform slightly better (at least TQueue and co are faster)
09:22:27 <merijn> If I ever have free time I might finally get around to implementing/benchmarking STM stuff
09:26:15 <ddellacosta> yeah I'm also just wondering if there are any cases where you'd want one more than the other for any reason...like, I guess with a bounded channel you'd be more likely to lose messages, so maybe broadcast-chan would be better for a system with a lot of variability in how many messages may be sitting in a queue at any point
09:45:40 <dsal> shrinkin' ain't easy
09:46:44 <omer> l
09:47:07 <dsal> Bounded channels in go block by default.  It's pretty good behavior to limit unbounded growth.  You can always do a non-blocking send that will tell you whether you successfully added to a channel or not.
10:00:41 * hackage twitter-conduit 0.4.0 - Twitter API package with conduit interface and Streaming API support.  https://hackage.haskell.org/package/twitter-conduit-0.4.0 (TakahiroHimura)
10:07:41 <nil> why isn't there a law requiring mapM to be equivalent to traverse?
10:09:07 <dmwit> Seems reasonable enough. Probably just an oversight.
10:10:28 <nil> hm
10:11:34 <EvanR> i'm ok if a given haddock doesn't have a wall of laws
10:11:53 <EvanR> a couple at a time if digestible
10:12:27 <nil> i mean, is there even a point to having mapM and sequence part of the Traversable class, these days?
10:13:23 <EvanR> since mapM and traverse should coincide when appropriate, you might want to implement mapM more efficiently for the given type
10:14:35 <nil> when does Monad allow more efficiency than Applicative?
10:15:26 <EvanR> i mean, mapM used to be outside a class and couldn't be reimplemented at all
10:15:48 <EvanR> so if you had a faster traverse, mapM would be useless
10:16:28 <EvanR> this devolves into whether any monad-specific stuff is necessary now that Applicative is a superclass
10:17:04 <nil> are there any arguments in favour?
10:17:05 <EvanR> liftM
10:17:30 <EvanR> -\o/-
10:18:36 <nil> ?
10:18:54 <EvanR> shrug, dunno
10:19:13 <EvanR> many monad API things are historical
10:22:18 <nil> :/
10:45:51 <kuribas> So in idris your typeclasses would come with proof that the laws are valid?
10:46:19 <kuribas> Then you could do rewrite rules that are proven correct.
10:46:50 <infandum> ChrisPenner[m]: But that may not be for streaming IO
10:47:53 <MarcelineVQ> sometimes. other times it might be convenient to have a record of functions and proofs instead like agda, it's not well explored in idris yet. idris also doesn't curently have rewrite rules afaik, maybe that's a thing that elborator reflection could do though, idk
10:48:30 <kuribas> I dabbled a bit in idris, but I found writing proofs rather painful
10:51:01 <phadej> even if it's not, you need functional extensionality (i.e. magic trustMe) to prove even that `Reader` is a monad.
10:51:06 <MarcelineVQ> so far strictly positivite types is the more demanding limitation for me, when trying to translate haskell blog posts to it
11:32:40 <monochrom> liftM and ap can be useful if you write your >>= and then want to get fmap and <*> for free.
11:32:47 <monochrom> (and if you don't mind)
11:58:50 <brettgilio> Anybody here doing Haskell development on Guix?
12:12:16 <texasmynsted> Never heard of Guix until now.
12:14:41 * hackage stratosphere 0.44.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.44.0 (jdreaver)
12:18:05 <Chukk> Isnt guix some libre linux distro?
12:19:05 <brettgilio> Chukk: guix.gnu.org
12:19:29 <brettgilio> It is based on some of the same principles as NixOS.
12:20:06 <yushyin> Chukk: GuixSD is the name of the distro
12:20:59 <Chukk> Is it comparable to trisquel or parabola? 
12:21:49 <shapr> what does nixOS use instead of guile? C++? Haskell?
12:21:50 <brettgilio> Chukk: only in it being fsf-approved. Otherwise, they are nothing alike.
12:22:09 <brettgilio> shapr: Nix uses it's own DSL.
12:22:33 <Chukk> Looks interesting. I will try it out. 
12:22:59 <shapr> What's the advantage of guix over nixOS? fsf approval?
12:23:26 <brettgilio> shapr: Scheme. But that's my opinion
12:23:34 <brettgilio> I think Scheme is preferable over the nix language.
12:23:39 <shapr> oh, hm
12:23:52 <shapr> I heard rumors that nixOS would be going back to Haskell at some point, is that true?
12:24:02 <brettgilio> Also, guix has more work in reproducible builds and deterministic boostrapping
12:24:11 <brettgilio> shapr: I doubt it 
12:25:49 <shapr> hm, I should ask around
12:26:05 <shapr> I'd love to have a Haskell EDSL nix language
12:26:31 <brettgilio> Nix does take a lot from Haskell already. But it is not nearly as nice as Haskell
12:30:35 <Chukk> is DSL  a domain specific language ? 
12:30:56 <gaze__> yes
12:30:58 <brettgilio> Chukk: yes
12:31:47 <gaze__> edwardk ( ekmett ?) : In your AD package, why the name of Khan for the reverse AD mode?
12:50:38 <shapr> how do you usually hook hlint into your build?
12:51:06 <shapr> Is there a way to use two -F -pgmF commands?
12:51:12 * hackage hjugement-protocol 0.0.9.20191031 - A cryptographic protocol for the Majority Judgment.  https://hackage.haskell.org/package/hjugement-protocol-0.0.9.20191031 (julm)
12:51:26 <shapr> for example, both {-# OPTIONS_GHC -F -pgmF hlint-test #-} and {-# OPTIONS_GHC -F -pgmF hspec-discover #-} ?
12:52:11 * hackage hjugement-cli 0.0.0.20191031 - Majority Judgment and Helios-C command line tool  https://hackage.haskell.org/package/hjugement-cli-0.0.0.20191031 (julm)
12:59:17 <vaibhavsagar> shapr: can you use two separate files?
12:59:24 <vaibhavsagar> one with `hspec-discover` and another one with `hlint-test`?
13:01:01 <vaibhavsagar> shapr: actually it looks like you might need a separate test-suite stanza just for `hlint-test`
13:33:42 * hackage persistent-postgresql 2.10.1 - Backend for the persistent library using postgresql.  https://hackage.haskell.org/package/persistent-postgresql-2.10.1 (parsonsmatt)
13:39:42 * hackage esqueleto 3.2.2 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-3.2.2 (parsonsmatt)
14:02:42 * hackage language-ats 1.7.7.0 - Parser and pretty-printer for ATS.  https://hackage.haskell.org/package/language-ats-1.7.7.0 (vmchale)
14:04:11 * hackage shake-ats 1.10.4.0 - Utilities for building ATS projects with shake  https://hackage.haskell.org/package/shake-ats-1.10.4.0 (vmchale)
14:24:42 * hackage tmp-postgres 1.0.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.0.0.0 (JonathanFischoff)
14:42:01 <jackdk> wow it's ATS day today!
14:43:21 <[exa]> what's ATS? (I can only think about Abstract Tree Syntax, which is obviously wrong)
14:43:54 <EvanR> http://www.ats-lang.org/
14:44:34 <[exa]> oh a language, cool
14:46:44 <Orbstheorem> Hi!, how can I use aeson to parse an object that may or may not contain a list in attribute foo into a `data bar {foo :: [Baz]}` ?
14:47:17 <Orbstheorem> well, `data Bar = Bar { foo :: [Baz] }` ^^
14:51:55 <EvanR> Orbstheorem: so, Parser is an instance of Alternative so if you had a parser that gets the array out of an object and returns a list of Baz, you can use <|> to react to failure and pure []
14:54:08 <n33b> Sorry if I ask here a beginner question. Is the basecase from deleteGuesses :: [(String,Int)] -> [(String,Int)]  // deleteGuesses _ [ ] = [ ] ?
14:55:13 <dminuoso> n33b: Without knowing what the intend is, its hard to say...
14:56:00 <EvanR> Orbstheorem: what do you want to happen if the array is there but contains a bogus non-Baz entry
14:56:39 <nil> n33b: but regardless, that looks like a type error
14:56:57 <Orbstheorem> EvanR: I would like a failure
14:57:45 <n33b> @nil how would the right one look like?
14:57:45 <lambdabot> Maybe you meant: url unpl pl id bid
14:57:56 <chreekat> Chukk: "Guix from the Nix perspective": https://youtu.be/aUG9aGYYCY8?t=335   <-- from NixCon last week
14:58:22 <EvanR> Orbstheorem: the (.:?) operator does a lookup on the object and gives a parser that returns Nothing when the key isn't present
14:58:27 <n33b> nil Just try to delete invalid guesses
14:58:32 <nil> n33b: i *guess* you meant `deleteGuesses [] = []`, but as dminuoso said it's hard to say without knowing what the function does
14:58:53 <nil> if it's a "filter" kind of function, then yes, that's the base case you want
14:59:04 <EvanR> .!= let's you pick a default value, in this case []
15:00:04 <Orbstheorem> So far, I was using Aeson's TH deriveJSON function; do I have to write my own implementation for all fields if I want to use .!= ?
15:00:29 <dminuoso> Orbstheorem: Not necessarily. You could newtype the field...
15:01:36 <Orbstheorem> dminuoso: Oh, good idea
15:02:08 <dminuoso> Orbstheorem: Overall I dont think newtyping just for the purpose of handsteering a parser is a great idea.
15:02:40 <dminuoso> Orbstheorem: It's better to just handroll the instance. With do-notation and RecordWildCards its very fast and makes the behavior more explicit.
15:03:25 <dminuoso> (Assuming this record has non-trivial amounts of fields)
15:03:46 <Orbstheorem> Oh well...
15:03:51 <Orbstheorem> Alright, I'll do it by hand xD
15:04:18 <Orbstheorem> It's quite simple so far: https://paste.gnugen.ch/raw/Y8FX
15:18:22 <Orbstheorem> \o/
15:18:24 <Orbstheorem> Thanks !
15:25:12 * hackage morpheus-graphql 0.5.0 - Morpheus GraphQL  https://hackage.haskell.org/package/morpheus-graphql-0.5.0 (nalchevanidze)
16:06:04 <Am3nadiel> grep
16:06:16 <Am3nadiel> grep >
16:22:42 * hackage wai-middleware-auth 0.2.1.0 - Authentication middleware that secures WAI application  https://hackage.haskell.org/package/wai-middleware-auth-0.2.1.0 (lehins)
17:07:42 * hackage unused 0.10.0.0 - A command line tool to identify unused code.  https://hackage.haskell.org/package/unused-0.10.0.0 (joshuaclayton)
17:18:42 * hackage matrix-static 0.2.1 - Type-safe matrix operations  https://hackage.haskell.org/package/matrix-static-0.2.1 (wchresta)
17:56:51 <zio_> YAYA
17:57:07 <zio_> in me we can trust
17:58:50 <cheater> if you take every package (in its latest version), that.s 1.04 GB of .hs files.
17:58:56 <cheater> on hackage.
17:59:55 <yakib00m> in silence we contemplate the Work of God
18:05:46 <Axman6> In silence, I contemplate the work of man and I say: WTF wrote this awful code?
18:08:12 * hackage morpheus-graphql-cli 0.1.0 - Morpheus GraphQL CLI  https://hackage.haskell.org/package/morpheus-graphql-cli-0.1.0 (nalchevanidze)
18:12:04 <Orbstheorem> Hello, I'm using stack+hpack to build my project. I just splitted my main into three files, but module A in file fA cannot find module B in file fB. Here's my package.yaml: https://paste.gnugen.ch/raw/cXTf
18:16:59 <Orbstheorem> I renamed the files and it works now ¯\\_(ツ)_/¯
18:20:45 <Axman6> file names are important
18:29:18 <ddellacosta> so are there approaches to using stm with mtl without a MonadSTM class or the like? That seems kind of heavy
18:30:29 <Axman6> MonadIO and atomically? you generally want to be explicit when you are executing an transaction
18:31:03 <Axman6> a*
18:31:04 <ddellacosta> Axman6: I see, thanks
18:31:33 <Axman6> you could quite easily make MonadSTM though, with atomically :: STM a -> m a
18:32:10 <ddellacosta> seems like it'd involve a lot of wrapper functions, but maybe I'm overthinking it
18:32:17 <koz_> :t atomically
18:32:18 <lambdabot> error: Variable not in scope: atomically
18:32:37 <Axman6> @hoogle atomically
18:32:37 <lambdabot> GHC.Conc atomically :: STM a -> IO a
18:32:37 <lambdabot> GHC.Conc.Sync atomically :: STM a -> IO a
18:32:37 <lambdabot> Control.Monad.STM atomically :: () => STM a -> IO a
18:37:56 <dmwit> ddellacosta: https://github.com/dmwit/mcmario/blob/wip/macerole/src/MCMario/STM.hs ;-)
18:41:48 <ddellacosta> dmwit: haha thanks :-D
18:42:35 <ddellacosta> I have nothing to complain about now
18:42:53 <Axman6> dmwit: ... y tho
18:43:06 <Axman6> I've seen that code before and I feel like I also asked that
18:43:19 <ddellacosta> yeah I mean, if you just do atomically then I can see a pretty minimal version
18:47:04 <Orbstheorem> How can I know which version of ghc include base-x.y.z ?
18:47:51 <Orbstheorem> I got this error when trying to build a package and I though about downgrading by version of ghc: https://paste.gnugen.ch/raw/FgeC
18:47:54 <Axman6> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Libraries/VersionHistory
18:49:24 <Orbstheorem> Thanks !
18:50:29 <koz_> Is ghcid 'tied' to a specific version of GHC? More specifically, if I build ghcid with GHC 8.6.5, does this mean that I can no longer use this ghcid with, say, GHC 8.4.4?
19:02:45 <slack1256> koz_: Not sure, but I would think so. The GHC API is version specific.
19:02:57 <koz_> slack1256: That's rather annoying lol.
19:06:42 <slack1256> koz_: I use nixos, so it's no problem to me >:^)
19:07:15 <koz_> slack1256: Not like it seems to matter, since ghcid mysteriously never works for me.
19:07:34 <koz_> I just tried on another machine, where I'm pinned to a specific GHC anyway. cabal new-install build me ghcid just fine.
19:07:49 <slack1256> But in all seriousness, maybe the GHC-API should work with all major numbers, ie 8.6.x , 8.8.x etc.
19:07:54 <koz_> Then when I tried the vim plugin it tried to build it _again_, and everything fails with no error messages other than the equivalent of 'it blew up lol'.
19:08:12 * hackage nonempty-vector 0.2.0.0 - Non-empty vectors  https://hackage.haskell.org/package/nonempty-vector-0.2.0.0 (topos)
19:08:27 <hololeap_> are there any good libraries that focus on merging constraint(s) for all types in a type-level list?
19:08:52 <koz_> hololeap_: There are a large range of possible constraints that could apply to even a single type.
19:08:58 <koz_> Which specific constraints were you seeking to merge?
19:09:15 * Axman6 doesn't understand the question
19:12:00 <hololeap_> sorry, "merging" probably isn't the most common way to say it
19:12:41 <hololeap> http://hackage.haskell.org/package/vinyl-0.12.0/docs/Data-Vinyl-TypeLevel.html#t:AllConstrained
19:12:49 <hololeap> basically, stuff like that
19:13:38 <dmwit> Axman6: Well, the comment at the top says y tho
19:15:01 <dmwit> It's very pretty. If you write `do { ...; Just x <- readTVar tv; ... }`, then that efficiently blocks until `tv` has a `Just` in it.
19:15:17 <dmwit> (Or whatever pattern.)
19:15:22 <hololeap> different question: how does this have two different kinds for t?
19:15:24 <hololeap> https://hackage.haskell.org/package/singletons-2.6/docs/Data-Singletons-Prelude-List-NonEmpty.html#v:sTake
19:21:12 * hackage haskell-src-exts 1.22.0 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  https://hackage.haskell.org/package/haskell-src-exts-1.22.0 (DanBurton)
19:27:12 * hackage uniq-deep 1.2.0 - uniq-deep  https://hackage.haskell.org/package/uniq-deep-1.2.0 (ncaq)
19:39:03 <zeta_0> hello guys, i am looking to upgrade ihaskell and i need to use a tarball file, but i can't find where it is located ? https://github.com/gibiansky/IHaskell
19:50:42 * hackage ats-format 0.2.0.32 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.2.0.32 (vmchale)
19:52:38 <Axman6> zeta_0: is there a releases tab at the top?
19:54:04 <Axman6> doesn't look like it
19:54:59 <Axman6> zeta_0: what do you mean by "i need to use a tarball file"?
19:55:58 <Axman6> dmwit: ah right, yeah fail = error seems like a bad idea
20:00:26 <zeta_0> Axman6: i need to replace this link with a ihaskell tarball: (let ihaskell = builtins.fetchTarball { url = "https://github.com/gibiansky/IHaskell.git";
20:01:00 * Axman6 pings jackdk for nix problems
20:01:59 <dibblego> he's out atm
20:17:18 <jackdk> zeta_0: why do you believe you need a tarball?
20:17:30 <jackdk> (nix has builtins.fetchGit, and I'm checking for XY problems)
20:21:20 <zeta_0> jackdk: oh, i was trying to find the options, thanks for the help
20:26:24 <zeta_0> jackdk: i am trying to install ihaskell: https://hastebin.com/zupajiyexo.bash
20:26:38 <zeta_0> jackdk: with nix
21:15:19 <jackdk> yeah so I'd either use builtins.fetchGit, or fetchFromGitHub, or builtins.fetchTarball the archive link on github
21:40:18 <wejetheman> how come this works fine in ghci but wont compile with ghc? http://codepad.org/lfYNub3M
21:44:54 <ghoulguy> wejetheman: GHCi has Extended Defaulting rules enabled by default
21:45:38 <ghoulguy> Try: print (testBit (4 :: Integer) 2)
21:46:04 <EvanR> "ghoulguy" nice
21:46:47 <wejetheman> i could have sworn i did try that
21:46:55 <wejetheman> but thanks
22:24:07 <jusss> is anyone using yesod? I found that yesod can't make the other files in the same directory with the program to be available on the website, like /usr/share/www/ is avaiable as the root for nginx
22:24:36 <jusss> how I can make a vaiable root directory to share files for others via yesod?
22:24:54 <jusss> keyword please
22:27:57 <heatsink> It seems like it involves making a handler that calls sendFile 
22:29:23 <jusss> thanks
22:31:21 <heatsink> When a web server provides data from files, instead of the server creating the data, it is called "static"
22:31:44 <heatsink> If you search for "static" in the yesod documentation, you could find something relevant
22:33:04 <jusss> there's "static" in https://www.yesodweb.com/book/routing-and-handlers
22:33:37 <jusss> I'm not sure if it's what I need, In order to serve static files from /static, you would need a resource line like: /static StaticR Static getStatic
22:58:19 <toast92> Hi, I was wondering if someone could help me understand how GHC solves constraints.
22:58:22 <jellostahps> I can type 'stack run' to run my program outside of ghci, but if I type 'stack ghci' first, then how would I run my program once inside ghci?
22:58:55 <jellostahps> I tried ':run' ':Main" to no avail
22:59:08 <toast92> jellostahps you can just call main
22:59:15 <jellostahps> idk the syntax
22:59:57 <toast92> Prelude> main
23:00:02 <toast92> then enter
23:00:07 <dminuoso> 06:57:56         toast92 | Hi, I was wondering if someone could help me understand how GHC solves constraints.
23:00:21 <dminuoso> toast92: Can you elaborate more on what you want to know exactly?
23:00:40 <toast92> Ok. I was looking at Data.HVect
23:00:58 <toast92> particularly the ListContains constraint
23:01:07 <toast92> type ListContains n x ts = (SNatRep n, InList x ts ~ n, HVectIdx n ts ~ x)
23:01:35 <toast92> from what I've seen about its usage, you don't need to supply n
23:02:10 <toast92> so how does GHC know what n is?
23:02:49 <dminuoso> toast92: Do you see the `InList x ts ~ n` constraint?
23:02:55 <toast92> does it calculate InList x ts first to get an n, then check if this n satisfies HVectIDx n ts ~ x?
23:04:03 <toast92> @dminuoso yes
23:04:03 <lambdabot> Unknown command, try @list
23:05:51 <jellostahps> typing Prelude> main does nothing
23:06:13 <EvanR> toast92: no it may not know exactly what n is
23:06:15 <jellostahps> It says data constructor not in scope
23:06:50 <EvanR> all ~ does is denote a contraint that two types are equal
23:07:49 <toast92> jellostahps: Don't type the "Prelude>", that is the prompt
23:08:28 <toast92> I'm guessing after you type stack ghci, it loads your Main module and whatever libraries in src right?
23:09:12 <toast92> So you end up with something like this:
23:09:22 <toast92> *Main Lib>
23:10:06 <jellostahps> toast92: yes exactly
23:10:06 <toast92> now all your functions in your Main module and Lib module are available in ghci
23:10:17 <jellostahps> but how do I 'run' form that point
23:10:23 <toast92> type 
23:10:24 <toast92> main
23:10:26 <toast92> then enter
23:10:43 <jellostahps> oh screw me, i kept typing :main
23:10:47 <jellostahps> thx
23:11:03 <toast92> main is just an ordinary function
23:11:19 <dminuoso> toast92: It's not a function.
23:11:21 <dminuoso> It's an IO action.
23:11:40 <jellostahps> Okay, because I have a function main in my file Main.hs, so when I type 'main' then it references that function, and that functions runs the rest of my program?
23:11:56 <c_wraith> it's still not a function
23:11:56 <jellostahps> or IO action as you say
23:12:02 <toast92> dminuoso I stand corrected
23:13:16 <dminuoso> jellostahps: GHCi is, essentially, a REPL-style big "do ..." block running in IO.
23:13:54 <dminuoso> With some special sugar mixed in. You can just type some IO action, like `getLine` or `putStrLn "foo"` or `main` - and it will execute that action upon pressing enter.
23:13:56 <toast92> ghci is a REPL - it reads whatever arbitrary Haskell code you type at the prompt, evaluates it, then prints out the evaluated expression
23:14:23 <dminuoso> toast92: That's not really accurate. :)
23:14:50 <dminuoso> toast92: If that was the case, it should fail to type check when you enter any IO action, as there is no `instance Sho (IO a)`
23:15:11 <dminuoso> IO actions are not shown and printed. they are *executed*
23:15:43 <jellostahps> ok so hey are functions but are executed instead of displayed, unless the execution inclues displays of course
23:15:47 <jellostahps> so they*
23:15:54 <dminuoso> jellostahps: Again. Not functions.
23:16:04 <EvanR> don't try to execute functions
23:16:13 <EvanR> or show them
23:16:27 <jellostahps> okay ill consider that
23:16:33 <EvanR> you can only pass them around and apply them to ... argument
23:17:17 <EvanR> a function has a type like A -> B
23:17:53 <EvanR> these facts are followed so closely in haskell it hurts... in a good way :)
23:18:40 <dminuoso> jellostahps: If you enter an expression of type `IO a` for some choice of a into GHCi, it will execute it. Any other expression will be printed.
23:19:21 <dminuoso> jellostahps: Many more modern traditional languages heavily intertwine the notion of "procedure" and "function". Haskell keeps these ideas separate.
23:19:23 <jellostahps> ok
23:19:37 <toast92> EvanR so how does GHC check that both constraints involving n are satisfied?
23:19:44 <dminuoso> jellostahps: IO actions can best be thought of as "list of assembly instructions". You wouldn't think of a list of instructions as a function, would you? :)
23:20:52 <EvanR> toast92: what is the specific situation ?
23:21:11 <dminuoso> jellostahps: To us a function is the raw notion of "mapping values to values" where you can basically "look up the corresponding value X to Y" by "applying the function to Y and obtaining X in the process". This process is pure, there's no side effects, things dont happen.
23:21:13 <EvanR> what operation are you trying to do, what code are you try to write
23:21:51 <toast92> This is from Spock
23:21:58 <toast92> `adminHook :: ListContains n User xs => Action (HVect xs) (HVect (IsAdmin ': xs))`
23:21:59 <dminuoso> jellostahps: There's no sequence of actions to happen. That notion is better described as "action" or "routine" :)
23:22:11 <dminuoso> EvanR: findFirst :: forall x ts n. (ListContains n x ts) => HVect ts -> x
23:22:18 <EvanR> mkay
23:22:24 <jellostahps> ok
23:22:28 <EvanR> where are you using findFirst
23:23:01 <dminuoso> (Or adminHook in their case, the difference is irrelevant I suppose)
23:23:33 <toast92> So ListContains is used to ensure User is in the existing HVect
23:23:40 <dminuoso> jellostahps: So the *evaluation* of an action amounts to calculating that "list of assembly instructions" - can you see the difference between "calculating a list of instructions" and "executing them"?
23:24:10 <EvanR> yes
23:24:21 <jellostahps> I will have to give this a look later as I am busy contemplating a different part of Haskell, but thanks for the information, Ive screenshoted it
23:24:31 <EvanR> though User is still the only concrete part of the example given
23:25:35 <dminuoso> toast92: Ah! I think the idea here is to express that the element could be at any position in the list..
23:25:38 <EvanR> ghc isn't verying any constraints for findFirst in isolation, it has to be used somewhere
23:25:50 <toast92> Ok so for a concrete example, let's say you accidentally used adminhook wrongly somewhere
23:26:00 <dminuoso> EvanR: It'd still be strange because the type variable is not named anywhere in the signature.
23:26:15 <toast92> like you used it when HVect is empty
23:26:18 <dminuoso> (Outside the context I mean)
23:26:27 <EvanR> i missed adminhook entirely... scrolling back
23:26:41 <toast92> i.e. HVect '[]
23:26:43 <dminuoso> EvanR: It's the same story as with findFirst, really.
23:27:10 <EvanR> a random % of my screen is explaining what an action is
23:28:13 <EvanR> alright
23:28:21 <EvanR> so adminHook is a polymorphic value
23:28:54 <EvanR> unless Action is secretly a synonym for a function
23:29:06 <dminuoso> jellostahps: To bring this to a conclusion (feel free to make sense of it later), the *execution* of IO actions only happens in main. To execute an IO action you feed it into `main` in a regular Haskell program.
23:29:28 <dminuoso> jellostahps: GHCi is special because you can just execute arbitrary IO actions by specifying them in the cli and hitting enter.
23:32:23 <EvanR> toast92: so in the case xs = '[] you can see how type checking will fail
23:33:35 <EvanR> looking into ListContains, there is a usage of InList User '[], InList is a type family and ghc will try to reduce this to something
23:33:58 <EvanR> but there is no instance for second argument '[]
23:35:32 <toast92> Oh that's true... Then if that's the case why is there the need for the second constraint `HVectIdx n ts ~ x`
23:36:22 <toast92> If the desired type is not in the list, type checking should already fail at InList would it not?
23:36:32 <EvanR> the InList means the type is in the type level list somewhere
23:36:43 <EvanR> HVectIdx means the value is in the HVect somewhere
23:37:47 <EvanR> if the type is in the list, type checking can still fail
23:39:01 <EvanR> if the value of that type is not at the same position as the type in the type list
23:39:05 <EvanR> in the vect
23:39:17 <EvanR> logic sucks :)
23:39:57 <toast92> Hmmmmmmmmmm
23:40:10 <toast92> I will try to break it to see how it works haha
23:40:39 <toast92> wait, but back to the question of how n comes about
23:40:44 <EvanR> you might find seemingly redundant logic in type level haskell because sometimes ghc isn't smart enough to see certain things given the code so far. Not sure if this is the case here
23:41:24 <toast92> So would it be right to say that GHC first solves InList x ts ~ n
23:41:44 <toast92> then uses the calculated n to try solve  HVectIdx n ts ~ x
23:41:59 <EvanR> i would say it expands InList x ts and HVectIdx n ts type family applications
23:43:24 <EvanR> then wherever adminHook is used (did we get a concrete example yet?), types are inferred. The types are used to look for instances of class constraints and deduce proofs of equality constraints
23:45:00 <EvanR> if that succeeds, you can imagine instance dictionaries and equality proofs being passed in as arguments, as => becomes effectively a ->
23:46:29 <toast92> I haven't thought about this actually. What does the typeclass dictionary for a Constraint like ListContains n x ts look like?
23:46:42 <EvanR> type inference is probably where you get a concrete n in example code
23:47:03 <EvanR> ListContains n x ts is a triple of constraints
23:47:04 <toast92> Is it passing anything of value? I imagine it's purely used in typechecking
23:47:15 <EvanR> two equalities and one instance
23:47:24 <EvanR> the SNatRep n
23:47:44 <EvanR> that might be used at runtime
23:51:36 <toast92> OH I just realised that SNatRep is a class...
23:51:57 <toast92> Its not exported by Data.HVect so I missed it
23:52:02 <EvanR> i saw that
23:52:33 <toast92> I kept thinking its SNat, so I was confused why a type could appear on the left of =>
23:52:50 <EvanR> so that's why it's not in the doc, not exported
23:54:40 <toast92> Sorry for asking so many questions but is there a need to declare the SNatRep n constraint?
23:55:09 <toast92> Could we just have `( InList x ts ~ n, HVectIdx n ts ~ x)`
23:55:26 <EvanR> SNatRep lets you get an actual number at runtime
23:55:32 <EvanR> what is it used for? No idea
23:55:42 <EvanR> have to look at the implementation of adminHook
23:55:57 <EvanR> without that n would be totally unknown at runtime
23:58:56 <toast92> Ok thank you so much!
