00:19:02 <dminuoso> dsal: Regarding your "fail
00:19:10 <dminuoso> "fail" vs "error" thing, they should be different.
00:23:03 <Axman6> > fail "Oh no!" :: Maybe Int
00:23:06 <lambdabot>  Nothing
00:23:12 <Axman6> > error "Oh no!" :: Maybe Int
00:23:14 <lambdabot>  *Exception: Oh no!
00:26:33 <dminuoso> dsal: (Keep in mind that `fail` uses the respective Monad/MonadFail implementation, while error is always a pure exception)
00:27:15 <dminuoso> Oh it seems that perhaps Im a bit far behind. My bouncer apparently has some bugs wrt timestamps..
01:05:36 <doroseen> have a great day, guys! i just started to learn haskell the other day, and a nice guy recommended me to come here for questions, so thank you in advance for your help :)
01:06:23 <dminuoso> Welcome to the channel, doroseen!
01:06:47 <maerwald> great to have you here!
01:07:36 <dminuoso> Well we don't know that yet.
01:24:27 <boxscape> In the documentation of the removed feature linear implicit parameter, the ghc User's guide mentions 'with' clauses. Is that still a thing? I've never heard of 'with' clauses in haskell
01:27:11 <dminuoso> boxscape: I think its a typo and meant to read 
01:27:13 <dminuoso> "where"
01:27:23 <boxscape> hm, that would make sense
01:39:20 <mpickering> Is there any library for tries where the keys can be `[a]`? It seems there is nothing this simple..
01:40:09 <mpickering> perhaps trie-simple
01:45:25 <niks> Wow, this community has grown so much since I was last here 5 years ago
01:46:28 <doroseen> it is a good thing, right? :)
01:46:58 <niks> Yes I think so, but I thought the motto was "avoid success at all costs" :)
01:48:26 <merijn> niks: "avoid (success at all costs)" ;)
01:48:49 <merijn> niks: As alternate parse instead of "avoid success (at all costs)"
01:49:24 <niks> Haha that's fair, don't want to compromise on the principles of the language - still a bit tongue in cheek though :P
01:50:33 <niks> Though, the last time I visited this community is also the last time I programmed in haskell. What are the recommendations to get back into it? I'd already worked through LYAH, RWH (3/4ths), Write Yourself a Scheme in 48 hours, and some other stuff - not sure where to go for a refresher
01:51:29 <merijn> niks: For a refresher maybe the tutorial?
01:51:32 <merijn> @where tutorial
01:51:32 <lambdabot> http://www.haskell.org/tutorial/
01:52:04 <niks> Ah thanks, I'll check that out
01:54:13 <boxscape> The cis194 course could also be interesting if there's a particular topic in this table of contents that you'd want to read up on https://www.seas.upenn.edu/~cis194/spring13/lectures.html
01:55:38 <niks> Ooh yes, this also looks great - I'll start with these 2 and then probably skim RWH to get to some practical projects
01:55:46 <niks> Thanks for the help folks :)
02:02:03 <dminuoso> niks: Id say drop RWH and just go through xis194.
02:02:24 <niks> What makes you say that?
02:02:37 <niks> I do remember RWH being kind of boring to read when I first did it
02:02:56 <dminuoso> niks: Both RWH and LYAH are fairly dated.
02:03:16 <dminuoso> cis194 is pretty up-to-date with modern Haskell
02:03:42 <niks> Ah I see, that makes sense. Then I'll just work through that then 
02:03:46 <dminuoso> Also if you've already finished the books you mentioned, chances are cis194 is a better fit anyway
02:03:54 <boxscape> more generally, this has a collection of resources https://github.com/bitemyapp/learnhaskell
02:05:48 <niks> Thanks boxscape, they should put that on the official haskell website
02:06:28 <niks> Oh wait, it's on there. I just missed it
02:07:15 <boxscape> hmm, lyah and rwh are still the first two 2 resources mentioned on the website
02:08:10 <boxscape> s/two 2/2
02:08:53 <dminuoso> @where cis194 niks 
02:08:53 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
03:26:20 <Ariakenom> Has anyone looked at the more recent cis194 with CodeWorld?
03:27:38 <__monty__> @where cis194
03:27:38 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
03:47:39 <Ariakenom> __monty__: I meant the 2016 version. It changed quie a bit and it looks interesting.
03:48:34 <dansho> what's a concise way to write a function that maps [["a", "b"], ["c", "d", "e"], ...] to [[0, 1], [2, 3, 4], ...] ?
03:48:56 <dansho> [[a]] -> [[Int]]
03:49:05 <Ariakenom> > fromEnum "a"
03:49:07 <lambdabot>  error:
03:49:08 <lambdabot>      • No instance for (Enum [Char]) arising from a use of ‘fromEnum’
03:49:08 <lambdabot>      • In the expression: fromEnum "a"
03:49:15 <Ariakenom> > fromEnum 'a'
03:49:16 <__monty__> Ariakenom: Oh, you just reminded me I've been meaning to check out the original.
03:49:17 <lambdabot>  97
03:49:41 <dansho> the strings were just for example, should be a generic list of lists [[a]]
03:49:41 <Ariakenom> __monty__: have you done the one with codeworld?
03:49:43 <dminuoso> % :t let a = ord 'a' in fmap (\x -> ord x - a) . fmap
03:49:43 <yahb> dminuoso: ; <interactive>:1:45: error:; * Couldn't match type `f b' with `Char'; Expected type: (a -> b) -> f a -> Char; Actual type: (a -> b) -> f a -> f b; * In the second argument of `(.)', namely `fmap'; In the expression: fmap (\ x -> ord x - a) . fmap; In the expression: let a = ord 'a' in fmap (\ x -> ord x - a) . fmap
03:49:52 <__monty__> Ariakenom: No, neither.
03:50:43 <dansho> % 1 + 1
03:50:43 <yahb> dansho: 2
03:50:48 <dminuoso>  % let a = ord 'a' in fmap (fmap (\x -> ord x - a)) ["a", "b"]
03:50:50 <dminuoso> % let a = ord 'a' in fmap (fmap (\x -> ord x - a)) ["a", "b"]
03:50:50 <yahb> dminuoso: [[0],[1]]
03:51:09 <dminuoso> dansho: ^- this sort of. Thing is, how do you want [["foo"]] to be handled?
03:51:51 <dminuoso> dansho: Or can you weaken it to ["ab", "cde"] ?
03:51:53 <dansho> [["foo"]] -> [[1]]
03:51:57 <dansho> err [["foo"]] -> [[0]]
03:52:05 <Ariakenom> oh you want it to index the elements
03:52:09 <dansho> yes
03:52:16 <Ariakenom> that's the problem with just giving an example
03:52:21 <Ariakenom> it's amiguous
03:52:22 <dminuoso> dansho: use zip :)
03:53:03 <dansho> % map (\list -> map fst $ zip [0..] list) [['a', 'b'], ['c', 'd', 'e']]
03:53:03 <yahb> dansho: [[0,1],[0,1,2]]
03:53:46 <dansho> i couldn't figure out how to get the index to continue from the previous list
03:54:30 * hackage postgresql-query 3.7.0 - Sql interpolating quasiquote plus some kind of primitive ORMusing it  https://hackage.haskell.org/package/postgresql-query-3.7.0 (AlekseyUymanov)
03:57:48 <dansho> % scanl (\n list -> map fst $ zip [n..] list) 0 [['a', 'b'], ['c', 'd', 'e']]
03:57:48 <yahb> dansho: ; <interactive>:22:19: error:; * Occurs check: cannot construct the infinite type: b ~ [b]; * In the expression: map fst $ zip [n .. ] list; In the first argument of `scanl', namely `(\ n list -> map fst $ zip [n .. ] list)'; In the expression: scanl (\ n list -> map fst $ zip [n .. ] list) 0 [['a', 'b'], ['c', 'd', 'e']]; * Relevant bindings include; n :: b (bound at <int
03:58:06 <dansho> % foldl (\n list -> map fst $ zip [n..] list) 0 [['a', 'b'], ['c', 'd', 'e']]
03:58:06 <yahb> dansho: ; <interactive>:27:19: error:; * Occurs check: cannot construct the infinite type: b ~ [b]; * In the expression: map fst $ zip [n .. ] list; In the first argument of `foldl', namely `(\ n list -> map fst $ zip [n .. ] list)'; In the expression: foldl (\ n list -> map fst $ zip [n .. ] list) 0 [['a', 'b'], ['c', 'd', 'e']]; * Relevant bindings include; n :: b (bound at <int
03:58:49 <dansho> % foldl (\n list -> map fst $ zip [n..] list) (0 :: Int) [['a', 'b'], ['c', 'd', 'e']]
03:58:49 <yahb> dansho: ; <interactive>:30:19: error:; * Couldn't match expected type `Int' with actual type `[Int]'; * In the expression: map fst $ zip [n .. ] list; In the first argument of `foldl', namely `(\ n list -> map fst $ zip [n .. ] list)'; In the expression: foldl (\ n list -> map fst $ zip [n .. ] list) (0 :: Int) [['a', 'b'], ['c', 'd', 'e']]
03:59:48 <dminuoso> % its l = let ix _x = modify (+1) >> get; in getCompose (evalState (traverse ix (Compose l)) 0) -- dansho 
03:59:48 <yahb> dminuoso: 
03:59:58 <dminuoso> % its [["a", "b"], ["c", "d", "e"]]
03:59:58 <yahb> dminuoso: [[1,2],[3,4,5]]
04:00:11 <trcc> So currently I am using scotty and my backend framework. From a get request, I am returning a file. Now, I would like, that after they get request, the file is deleted. What is my best approach for this? Spawn a fire/forget thread just before sending the file? 
04:00:14 <trcc> as*
04:01:04 <dminuoso> dansho: Ah that has an odd offset
04:01:05 <dansho> =O
04:01:20 <dminuoso> % its l = let ix _x = do x <- get; modify (+1); pure x; in getCompose (evalState (traverse ix (Compose l)) 0) -- dansho 
04:01:21 <yahb> dminuoso: 
04:01:23 <dminuoso> % its [["a", "b"], ["c", "d", "e"]]
04:01:23 <yahb> dminuoso: [[0,1],[2,3,4]]
04:02:07 <dminuoso> Or, with less parens
04:05:07 <errelion> hey there
04:05:32 <errelion> im quite new to programming, and have simple question, sorry for that :D
04:05:55 <dminuoso> % its = getCompose . flip evalState 0 . traverse ix . Compose where  ix _x = do x <- get; modify (+1); pure x -- dansho
04:05:56 <yahb> dminuoso: 
04:06:01 <errelion> but i just wanted to write a function, that recursively divides all elements of a list and somehow i get strange results even with this simple function
04:06:04 <dansho> hmm, i guess evalState requires transformers or mtl?
04:06:11 <dminuoso> dansho: Yes.
04:06:27 <errelion> divideList [x] = x
04:06:39 <errelion> divideList (x:xs) = x/divideList xs
04:06:52 <boxscape> what strange results do you get?
04:07:06 <errelion> the results are way off
04:07:20 <errelion> for example divideList [1..5] gets 1.875
04:07:35 <errelion> when "foldl (/) 1 [1..5] gets 8.33e-3
04:08:40 <errelion> and to be honest i really cant get behind whats wrong there, because the function is so basic i dont see anything wrong with it
04:09:23 <hpc> > foldl (/) a [b, c, d] :: Expr
04:09:26 <lambdabot>  a / b / c / d
04:09:35 <hpc> > foldr (/) a [b, c, d] :: Expr
04:09:37 <lambdabot>  b / (c / (d / a))
04:10:09 <hpc> that's what you're running into here
04:10:19 <hpc> (/) isn't associative
04:10:52 <boxscape> > 1 / (2 / (3 / (4 / 5)))
04:10:53 <lambdabot>  1.875
04:11:01 <boxscape> > 1 / 2 / 3 / 4 / 5
04:11:03 <MarcelineVQ> In that your definition aligns with foldr's
04:11:03 <lambdabot>  8.333333333333333e-3
04:11:15 <errelion> ohhh
04:11:16 <errelion> i see
04:11:48 <errelion> any suggestions how i could write the recursive function so that it acts like foldl?
04:12:59 <hpc> @src foldl
04:12:59 <lambdabot> foldl f z []     = z
04:12:59 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
04:13:18 <hpc> something like
04:13:46 <errelion> thanks, i'll give it a try! :)
04:14:15 <dminuoso> dansho: You could of course drop the Compose and use a nested traverse too if you prefer, but I find Compose to be cleaner.
04:14:35 <fendor> @where wadler
04:14:36 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/
04:14:46 <hpc> errelion: there's also foldl1 which may be useful
04:15:05 <boxscape> @src foldl1
04:15:05 <lambdabot> foldl1 f (x:xs) = foldl f x xs
04:15:05 <lambdabot> foldl1 _ []     = undefined
04:15:13 <dminuoso> % its = flip evalState 0 . traverse (traverse ix) where ix _x = do x <- get; modify (+1); pure x -- dansho
04:15:13 <yahb> dminuoso: 
04:15:49 <dansho> ty
04:42:53 <boxscape> % type family F where
04:42:53 <yahb> boxscape: 
04:42:55 <boxscape> % type family F where { }
04:42:55 <yahb> boxscape: 
04:43:12 <boxscape> are these the same? Should you add { } with empty closed type families?
04:44:05 <cocreature> does aeson have a variant of "object" that allows me to omit optional fields or do I have to throw catMaybes or something like that in front to filter them out?
04:48:31 <jgt> I would filter them first
04:48:53 <jgt> I'm guessing you already know about omitNothingFields
04:50:01 <cocreature> yeah but that doesn’t help me if I have to write the instance by hand
04:52:31 <jgt> I'd say to use genericToJSON, but that still involves explicitly defining the instance
04:57:45 <ski> boxscape : should be the same
04:57:56 <boxscape> okay
04:58:12 <boxscape> So I guess it's just used to emphasize that it's empty
05:15:20 <boxscape> % :i *
05:15:34 <boxscape> yahb seems broken
05:15:43 <MarcelineVQ> % :q
05:15:50 <MarcelineVQ> yep
05:18:08 <yahb> boxscape: class Num a where; ...; (*) :: a -> a -> a; ...; -- Defined in `GHC.Num'; infixl 7 *
05:18:08 <yahb> MarcelineVQ: 
05:19:01 <boxscape> there we go
05:27:58 <merijn> hmm, I'm confused
05:28:15 <merijn> This looks like what I want: https://hackage.haskell.org/package/conduit-extra-1.3.4/docs/Data-Conduit-Process.html#t:BuilderInput
05:28:28 <merijn> But it says the pipe is *not* automatically closed, so how do I close it? >.>
05:35:41 <merijn> Oh, wait, it's just cryptically hidden
06:24:43 <sshine> I'm using 'Text.Megaparsec.Char.Lexer.scientific' in my own parser, but it turns out that it doesn't parse ".1" as 0.1 :: Scientific. the syntax for which I'm parsing have some LL(1) ambiguities wrt. things that start with '.', anyway, so I thought I'd special-case this form; still, I wonder if there's a way I can rely on the 'scientific' built-in.
06:25:37 <sshine> my initial thought is: maybe I can temporarily stuff "0." into the stream for 'try scientific', but I don't know if that's possible or potentially messy.
06:28:05 <freeman42x> using the Turtle library. Is using which the correct way to tell whether an executable is on path?
06:32:29 <dminuoso> freeman42x: `which` ?
06:34:33 <dminuoso> freeman42x: I think Turtle interfaces with bash right? You could also use `type -P ...`
06:40:37 <sshine> ah, this is silly. I'll make my own parser that works as I intend it to.
06:41:10 <merijn> dminuoso: It'd be weird if it interfaced with bash, why would it do that?
06:41:33 <merijn> sshine: You can mix those two ideas
06:42:10 <merijn> sshine: Write your own parser that decides whether to accept the lexical element and returns a "fixed" string (i.e. with prepended 0 if necessary)
06:42:25 <merijn> sshine: Then use Scientific to parse that string so you don't have to write your own conversion
06:43:45 <dminuoso> merijn: Ah mmm. It seems to delegate its responsibility to System.Process.shell
06:44:07 <merijn> Whoo!
06:44:27 <merijn> It's been ~30 seconds since having to debug an accidental deadlock by not using -threaded >.>
06:55:43 <Ariakenom__> Has anyone looked at the more recent cis194 haskell course with CodeWorld?
06:59:15 <sshine> no
07:00:00 <dminuoso> Ariakenom__: Im going to say yes.
07:00:05 <sshine> merijn, so, run an entirely separate parser inside a parser?
07:02:16 <Ariakenom__> you mean ∃x and not x := dminuoso I presume
07:02:24 <dminuoso> :-)
07:02:50 <sshine> merijn, thanks for that idea! I'm going to eventually replace Scientific, so writing a custom parser won't be pointless, as I can change it into returning another value.
07:03:02 <doroseen> guys, :: is read as "has type of" ???
07:03:06 <dminuoso> doroseen: Yes.
07:03:10 <dminuoso> doroseen: Or rather "has type"
07:03:17 <dminuoso> "foo :: Int" reads "foo has type Int"
07:03:22 <doroseen> damn, in 4 sec  you read and replyed
07:03:28 <doroseen> thank you, mate
07:03:39 <dminuoso> doroseen: Depending on the context :: can also mean "has kind"
07:03:58 <doroseen> i will keep that in mind, thank you again
07:13:59 <boxscape> > let a :: *; a = undefined in const () a -- is there some non-bottom term that a could be at this point in ghc?
07:14:01 <lambdabot>  ()
07:15:56 <Cale> That's bizarre, I would never have expected that code to go through. I don't think you should be allowed to give * as the type of a term.
07:16:03 <boxscape> Why not?
07:16:12 <Cale> Because it's a kind and not a type
07:16:13 <boxscape> Types and kinds are the same thing
07:16:36 <Rembane> Are they? Last time I checked they weren't, I might have misread though.
07:16:40 <boxscape> they are now
07:16:47 <boxscape> just ask dminuoso ;0
07:16:52 <boxscape> s/0/;
07:16:52 <Rembane> Oh. In which version did it happen? :)
07:16:55 <Cale> I suppose if they've made them exactly the same thing, that explains it, but it's still not meaninful for * to be regarded as a type
07:17:01 <boxscape> 8.something
07:17:37 <boxscape> Cale: * is TYPE 'LiftedRep, and TYPE has a regular data definition
07:17:45 <boxscape> wait
07:17:45 <Rembane> Got it! 
07:17:52 <boxscape> I don't know if that makes it make more sense actually
07:18:29 <merijn> sshine: Yeah, I've done that in the past to deal with complex situations where the parser I wanted to run couldn't correctly handle boundary conditions (imagine sending something in a fixed length field of bytes so you need to run a Binary parser without reading more than N bytes)
07:18:57 <merijn> sshine: Binary now has an operator for that, but in the past I'd handle that by just reading N bytes into a ByteString, then running the field parser on that result :)
07:22:16 <boxscape> % :i Test
07:22:17 <yahb> boxscape: ; <interactive>:1:1: error: Not in scope: `Test'
07:22:19 <boxscape> % :i Type
07:22:20 <yahb> boxscape: type Type = * -- Defined in `GHC.Types'
07:22:38 <boxscape> % :set -XNoStarIsType
07:22:39 <yahb> boxscape: 
07:22:40 <boxscape> % :i Type
07:22:40 <yahb> boxscape: type Type = Type -- Defined in `GHC.Types'
07:22:43 <boxscape> That's somewhat amusing
07:23:10 <boxscape> since it's only an artifact of how ghci prints Type and couldn't actually be compiled
07:23:16 <dminuoso> boxscape: https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Kind.html
07:23:27 <dminuoso> Oh wait
07:24:00 <dminuoso> type Type = TYPE 'LiftedRep
07:24:07 <dminuoso> (Take that, three times the word "type")
07:24:36 <boxscape> neat
07:25:02 <dminuoso> boxscape: Though we should pretend TYPE doesnt exist for a moment, and pretend it read `type Type = *` instead.
07:25:41 <boxscape> Why?
07:27:04 <boxscape> huh even haddock says "type Type = Type"
07:27:39 <Ariakenom__> boxscape: what was an artifact of that?
07:27:50 <Ariakenom__> oh Type = Type
07:27:54 <boxscape> yeah
07:27:59 <boxscape> % type Test = Test
07:28:00 <yahb> boxscape: ; <interactive>:15:1: error: Cycle in type synonym declarations: <interactive>:15:1-16: type Test = Test
07:28:10 <dminuoso> boxscape: Well so the story is this. The type alias for `type Type = *` was for readability (such that you could say `Int :: Type`)
07:28:23 <dminuoso> boxscape: I think it was levity polymorphism that introduced the TYPE primitive.
07:28:46 <boxscape> did the line `type Type = *` actually exist at some point in source code?
07:29:24 <Ariakenom__> boxscape: where in haddock?
07:29:39 <boxscape> https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Kind.html#t:Type Ariakenom__
07:30:05 <dminuoso> boxscape: https://gitlab.haskell.org/ghc/ghc/wikis/dependent-haskell/phase1#-is-hard-to-parse-will-become-type
07:31:03 <Ariakenom__> also * is just a worse name than Type
07:31:15 <dminuoso> Ariakenom__: I think in the old kind model is was a good choice.
07:31:28 <dminuoso> Since you had a way to visually differentiate the type and kind level
07:31:41 <dminuoso> * and # were kind level things
07:32:00 <boxscape> % :k GHC.Exts.Int#
07:32:00 <yahb> boxscape: GHC.Exts.Int# :: TYPE 'GHC.Exts.IntRep
07:32:43 <Ariakenom__> I dunno. not a fan of using a symbol there
07:33:04 <boxscape> I wonder if :t and :k will be combined at some point
07:33:12 <dminuoso> boxscape: Huh
07:33:18 <dminuoso> boxscape: Different level!
07:33:34 <boxscape> but types and kinds are the same thing
07:33:37 <dminuoso> boxscape: :t takes a value thing and tells you its type, :k takes a type level thing and tells you its... type/kind.
07:33:42 <dminuoso> boxscape: Sure, but values and types are not.
07:34:01 <dminuoso> boxscape: :t operates on values, :k operates on types (and kinds since TypeInType)
07:34:21 <boxscape> but they might become in the future, I would think. There's a proposal currently to extend termlevel name lookups to the type level, which is the first step for that
07:34:42 <dminuoso> Which proposal are you thinking of?
07:35:02 <boxscape> https://github.com/ghc-proposals/ghc-proposals/pull/270
07:36:15 <dminuoso> boxscape: I think you misunderstood that pull request.
07:36:30 <dminuoso> boxscape: That change is quite orthogonal to this discussion.
07:37:04 <dminuoso> boxscape: The desired change is to allow for `f :: forall a. ...; f = ... sizeOf a ...;`
07:37:32 <boxscape> Well, I think it would allow you to write something like ":t Int" without getting an error about Int not being defined. You would get an error about not being able to use types on the term-level instead
07:37:41 <dminuoso> ah mmm.
07:45:31 <boxscape> % :k True -- and this way around it already mostly works, dminuoso
07:45:31 <yahb> boxscape: True -- and this way around it already mostly works, dminuoso :: Bool
07:46:46 <boxscape> (well, mostly works for data constructors, anyway)
07:46:51 <dminuoso> boxscape: That doesnt do what you think it does.
07:46:56 <dminuoso> boxscape: This is just DataKinds
07:46:59 <boxscape> I know
07:47:13 <dminuoso> boxscape: It's not the same thing.
07:47:31 <boxscape> But maybe it points in the direction of getting there at some point?
07:48:20 <merijn> Ok, suppose I have two datatypes whose only constructors are (semantically) "Never" "Auto" and "Always" do I: 1) prefix them with a specific type, 2) newtype wrap a single datatype, 3) use the same type twice, 4) something else
07:49:39 <dminuoso> Or mmm. Perhaps you are right, its actually that already in the opposite direction boxscape 
07:50:35 <dminuoso> merijn: Mmm, do you have any interesting typeclass instances for that datatype?
07:50:43 <merijn> dminuoso: No
07:50:44 <geekosaur> I think that's actually why there's a proposal to get types usable as terms of some kind, because it already works in the other direction with DataKinds
07:51:26 <geekosaur> it's more or less what DataKinds does. I thought it was also a step in dependent haskell
07:51:48 <dminuoso> Why do we have these ' prefixes at all? Are they not redundant?
07:52:09 <boxscape> they will likely be deprecated with that proposal
07:52:10 <merijn> dminuoso: They are not
07:52:15 <geekosaur> I think they still help to disambiguate in some cases
07:52:25 <boxscape> you can't type things like '() without them currenlty
07:52:27 <merijn> dminuoso: [Int] <- is this * or [*]?
07:53:11 <dminuoso> merijn: Im not sure that comparison is fair. Im talking about the ' prefix for DataKind lifted constructions.
07:53:25 <merijn> dminuoso: That was about DataKinds
07:53:37 <geekosaur> the () one is syntactic, I think, with respect to lifted () hence DataKinds
07:53:38 <boxscape> :k [Int]
07:53:39 <lambdabot> *
07:53:43 <boxscape> % :k '[Int]
07:53:43 <yahb> boxscape: '[Int] :: [Type]
07:53:57 <dminuoso> merijn: ^- my point is, you don't need to write 
07:54:01 <dminuoso> '['Int]
07:54:06 <dminuoso> Err
07:54:21 <dminuoso> % :k '[True]
07:54:21 <yahb> dminuoso: '[True] :: [Bool]
07:54:33 <dminuoso> Rather than '['True]
07:54:36 <merijn> dminuoso: If you have to write it for some types why would the syntax not work on all types?
07:54:52 <boxscape> dminuoso you still need it for puns, like data T = T, how do you disambiguate?
07:55:02 <dminuoso> ah
07:55:07 <dminuoso> I think Im getting the discussion now.
07:55:14 <dminuoso> Idris folks solve this by just not doing that right?
07:55:20 <boxscape> yeah
07:55:32 <merijn> dminuoso: Do you want the syntax to only apply in cases where it's required? That seems way less consistent
07:55:51 <boxscape> dminuoso the proposal solves it by introducing imports that only import names from the type level or only names from the term level, and gets rid of '
07:56:14 <dminuoso> merijn: Mmm
07:56:44 <boxscape> (the proposal also introduces warnings for puns)
07:56:52 * geekosaur doesn't know idris but guesses it's all one namespace
07:57:20 <boxscape> (but not enabled-by-default warnings)
08:01:54 <ski> % :kind False -- Nothing
08:01:54 <yahb> ski: False -- Nothing :: Bool
08:02:04 <ski> % :type False -- Nothing
08:02:04 <yahb> ski: Bool
08:02:11 <ski> hm
08:02:21 <boxscape> interesting
08:03:40 <boxscape> that appears to be yahb specific though, not ghci specific
08:04:26 <boxscape> I can't wait for :type! so we can finally evaluate term-level expressions
08:08:05 <boxscape> % type family F where F = F
08:08:05 <yahb> boxscape: 
08:08:10 <boxscape> % :kind! F
08:08:11 <yahb> boxscape: F :: k; = F
08:08:18 <boxscape> huh
08:08:34 <boxscape> my ghci crashes if I do that
08:14:55 <geekosaur> I need UndecidableInstances apparently to even enter that definition
08:15:16 <geekosaur> (8.6.5; yet to pull 8.8 onto here)
08:32:35 <asheshambasta> https://github.com/christian-marie/phone-numbers/blob/master/lib/Data/PhoneNumber.hs -- why so many unsafePerformIO? Am I missing something here? Or is the assumption here that the IO is unnecessary since this uses FFI? 
08:38:38 <spuz> I'm looking for an algorithm that can return a list of permutations of a list. I am not sure how to describe it though. Here is an example: [a, b, c] -> [[a], [a, b], [a, b, c], [b], [b, c], [c]]
08:39:34 <Cale> Those aren't permutations, but combinations
08:39:42 <Cale> Permutations are where you reorder the list's elements
08:39:59 <Cale> > filterM (const [False, True]) [1,2,3]
08:40:01 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
08:40:24 <LKoen> those aren't permutations, but sublists
08:40:26 <Cale> > subsequences [1,2,3]
08:40:28 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
08:40:33 <Entroacceptor> asheshambasta: the functions from LowLevel.hs need to bei IO() for internal technical reasons. They are then capsuled in unsafePerformIO which basically says "I know this is technically IO, but trust me, the state won't be affected"
08:40:36 <LKoen> Cale: but you have [1, 3] in there; spuz didn't have [a, c] in their example
08:40:56 <Cale> they also didn't have []
08:41:17 <spuz> LKoen that's my mistake
08:41:18 <pja> Data.List.permutations?
08:41:19 <asheshambasta> Entroacceptor: I see, yeah. 
08:41:20 <Cale> I'm not sure if there was a reason for that or not... if you only want contiguous sublists...
08:41:26 <spuz> [a, c] should definitely be in there
08:41:49 <Cale> ah, okay :)
08:45:59 <pja> spuz: actually, looking at your spec you want concatMap permutations $ subsequences [1,2,3]
08:46:13 <pja> > concatMap permutations $ subsequences [1,2,3]
08:46:15 <lambdabot>  [[],[1],[2],[1,2],[2,1],[3],[1,3],[3,1],[2,3],[3,2],[1,2,3],[2,1,3],[3,2,1],...
08:46:55 <Cale> pja: Are you sure? [a,b] was listed, but not [b,a]...
08:46:55 <pja> oh, but you don’t want [1,2] and [2,1]?
08:47:02 <spuz> yeah I don't want [b,a]
08:47:19 <spuz> Why does the following return an error? "length Data.List.subsequences "abc""
08:47:45 <pja> isn’t that just subsequences then?
08:47:50 <Cale> yes
08:48:15 <pja> spuz: you want length $ subsequences "abc"
08:48:25 <pja> > length $ subsequences "abc"
08:48:27 <lambdabot>  8
08:48:50 <pja> you can’t take the length of a function :)
08:50:10 <spuz> tbhanks
09:22:30 * hackage toysolver 0.6.0 - Assorted decision procedures for SAT, SMT, Max-SAT, PB, MIP, etc  https://hackage.haskell.org/package/toysolver-0.6.0 (MasahiroSakai)
09:23:43 <Squarism> Anyone know if theres a tool that can take a haskell expression and format it. Say you evaluate a tree of sorts and its just unreadable as a oneliner. Something that takes that line and adds newline + tabs to make expose the "structure" of it?
09:24:28 <merijn> there's several haskell formatters, but I don't like any of them, tbh :p
09:25:51 <Squarism> i dont want to use it in my code, rather on complex results from GHCI
09:26:29 <merijn> Squarism: You mean data structures?
09:27:18 <Squarism> merijn, yeah a value in some complex datastructure(?) 
09:27:29 <midi[F][m]> You mean a pretty printer?
09:27:34 <Squarism> i guess
09:27:34 <merijn> @hackage pretty-show
09:27:34 <lambdabot> http://hackage.haskell.org/package/pretty-show
09:28:09 <merijn> Squarism: Formatting expressions is hard, make large datastructure output more readable is fairly easy :p
09:28:25 <boxscape> % type family F where F = F -- had to go offline earlier after I found this out but any idea how yahb manages :kind! here even though my ghci locally stack overflows?
09:28:25 <yahb> boxscape: 
09:28:33 <midi[F][m]> @hackage pretty-simple
09:28:33 <lambdabot> http://hackage.haskell.org/package/pretty-simple
09:28:34 <boxscape> % :kind! F
09:28:34 <yahb> boxscape: F :: k; = F
09:28:52 <merijn> boxscape: Which ghc do you have locally and which does yahb have? :p
09:28:54 <midi[F][m]> Wow, the bot doesn't like me today
09:29:02 <boxscape> I tried 8.8, 8.6 and HEAD, yahb has 8.6
09:29:07 <boxscape> % :!ghc --version
09:29:07 <yahb> boxscape: The Glorious Glasgow Haskell Compilation System, version 8.6.0.20180620
09:29:07 <midi[F][m]> Nvm, it is just slow
09:29:24 <boxscape> I guess technically I tried 8.6.5, it could have changed between those two
09:29:59 <midi[F][m]> Squarism: Check out these b/c you can find more for your specific use case: https://hackage.haskell.org/packages/search?terms=pretty+printer
09:30:21 <merijn> Ignore all of those and use prettyprinter :p
09:30:25 <Squarism> merijn, midi[F][m] ok ill try them both
09:30:29 <Squarism> ok
09:30:37 <merijn> But that's more for making your own pretty printers
09:30:51 <merijn> pretty-show is for taking normal Show output and making it suck less for human readers
09:31:51 <midi[F][m]> merijn:  Same does pretty-simple
10:12:00 * hackage metaheuristics 0.0.8 - Generalised local search within Haskell, for applications in combinatorial optimisation.  https://hackage.haskell.org/package/metaheuristics-0.0.8 (richardjamessenington)
10:13:38 <tomsen> I got a datatype Pitch PitchSymbol Int, where PitchSymbol = C | D | E ..., both datatypes have Read derived. Anyone has a clue why "print $ (read "[Pitch E 0]" :: [Pitch])" says "no parse" ? Do i have a stupid bug or is read not able to parse lists this way?
10:14:13 <mroutis> why can't I type the naive definition of fibonacci on the ghci?
10:14:35 <mroutis> write* (since type has a different meaning here)
10:15:55 <EvanR> > read "[0,1,2]" :: [Int]
10:15:57 <lambdabot>  [0,1,2]
10:16:04 <EvanR> tomsen: read can parse lists, at least...
10:16:19 <EvanR> tomsen: maybe pastebin some code of your declaration
10:16:36 <iqubic> % PitchSymbol = C | D | E deriving (Show, Read)
10:16:36 <yahb> iqubic: ; <interactive>:56:17: error: parse error on input `|'
10:16:50 <iqubic> % let PitchSymbol = C | D | E deriving (Show, Read)
10:16:50 <yahb> iqubic: ; <interactive>:57:21: error: parse error on input `|'
10:17:09 <tomsen> i have data PitchSymbol... ok let me create a pastebin, thx so far : )
10:17:11 <iqubic> Is it impossible to define ADTs in GHCi?
10:17:33 <EvanR> iqubic: you're just not doing it right... fix it in PM :)
10:17:59 <iqubic> % data PitchSymbol = C | D | E deriving (Show, Read)
10:17:59 <yahb> iqubic: 
10:18:11 <iqubic> % show C
10:18:11 <yahb> iqubic: "C"
10:18:30 <iqubic> % show (C :: PitchSymbol)
10:18:30 <yahb> iqubic: "C"
10:18:36 <tomsen> https://pastebin.com/sY1wxCi0
10:19:00 <EvanR> tomsen: it's because of the record
10:19:17 <EvanR> deriving gave you a Read instance which accepts the record syntax
10:19:23 <tomsen> ah ic
10:19:32 <iqubic> Oh, the generic read instance uses the metadata? I did not know that.
10:19:35 <EvanR> in this way Read and Show end up being (sort of) inverses
10:19:48 <tomsen> is there a workaround? i like the namings on the record, but it don't want to create a parser since its just a little script
10:20:06 <iqubic> % data Pitch = Pitch PitchSymbol Int deriving (show, read)
10:20:06 <yahb> iqubic: ; <interactive>:61:46: error:; * Illegal deriving item `show'; * In the data declaration for `Pitch'; <interactive>:61:52: error:; * Illegal deriving item `read'; * In the data declaration for `Pitch'
10:20:27 <iqubic> % data Pitch = Pitch PitchSymbol Int deriving (Show, Read)
10:20:27 <yahb> iqubic: 
10:20:37 <EvanR> tomsen: you could get rid of the record syntax and define field accessors separately
10:21:06 <tomsen> kk, i'm fine with this. didnt know how read works internally. thx for quick help EvanR!
10:21:13 <iqubic> read ("[Pitch E 0]" :: [Pitch])
10:21:21 <iqubic> % read ("[Pitch E 0]" :: [Pitch])
10:21:21 <yahb> iqubic: ; <interactive>:63:7: error:; * Couldn't match type `Char' with `Pitch'; Expected type: [Pitch]; Actual type: [Char]; * In the first argument of `read', namely `("[Pitch E 0]" :: [Pitch])'; In the expression: read ("[Pitch E 0]" :: [Pitch]); In an equation for `it': it = read ("[Pitch E 0]" :: [Pitch]); <interactive>:63:7: error:; * Couldn't match type `Pitch' with `C
10:21:25 <EvanR> holy
10:21:40 <iqubic> Well, that's another issue you have to account for.
10:21:58 <iqubic> I have no idea what just happened there.
10:22:21 <iqubic> % :t [Pitch E 0]
10:22:21 <yahb> iqubic: [Pitch]
10:22:27 <EvanR> iqubic: you put the annotation in the wrong place
10:22:48 <iqubic> % read [Pitch E 0] :: [Pitch]
10:22:49 <yahb> iqubic: ; <interactive>:65:7: error:; * Couldn't match expected type `Char' with actual type `Pitch'; * In the expression: Pitch E 0; In the first argument of `read', namely `[Pitch E 0]'; In the expression: read [Pitch E 0] :: [Pitch]
10:22:59 <iqubic> Bloody bludgering hell.
10:23:03 <tomsen> iqubic are you giving me a lesson here? :D
10:23:07 <iqubic> No.
10:23:08 <EvanR> lol
10:23:13 <tomsen> kk ^^
10:23:15 <iqubic> I'm trying to do some learning myself.
10:23:16 <EvanR> language
10:23:25 <iqubic> EvanR: Can you help me here?
10:23:47 <EvanR> % read "[Pitch E 0]" :: [Pitch]
10:23:47 <yahb> EvanR: [Pitch E 0]
10:23:51 <iqubic> % read @[Pitch] "[Pitch E 0]"
10:23:51 <yahb> iqubic: [Pitch E 0]
10:24:00 * hackage mainland-pretty 0.7.0.1 - Pretty printing designed for printing source code.  https://hackage.haskell.org/package/mainland-pretty-0.7.0.1 (GeoffreyMainland)
10:24:01 <inkbottle> lines 7-11 are "real" comments, viz not used by the stack command? https://github.com/haskell/haskell-ide-engine/blob/master/install.hs
10:24:05 <iqubic> That also works, and looks better in my opinion.
10:24:45 <EvanR> looks better not sure, but it does elucidate the mystery of type classes somewhat
10:25:17 <iqubic> I have never really liked explicit type annotations.
10:25:27 <iqubic> I mean, not at the term level.
10:25:43 <iqubic> I'm a big advocate of type level programming.
10:25:58 <EvanR> DOOM at the type level would be pretty bad ass
10:26:19 <iqubic> How would that work? That would be a massive undertaking.
10:26:30 <EvanR> i'll let you figure that out
10:26:41 <iqubic> I have no idea how to do IO at the type level.
10:27:15 <EvanR> with a type level runtime
10:27:26 <iqubic> Which Haskell doesn't really have yet.
10:27:31 <EvanR> lol
10:27:45 <iqubic> But hopefully we'll get dependent types at some point soon.
10:28:20 <iqubic> soon meaning like Spring 2020.
10:36:46 <midi[F][m]> <EvanR "DOOM at the type level would be "> There has already been chess at the type level
10:37:35 <midi[F][m]> If you're wanting type level programming, Haskell is not the best choice of language. SystemF is fairly limited
10:38:13 <ski> @quote type.level
10:38:13 <lambdabot> edwardk says: type level ieee floats are a crime against nature. i had to implement them in c++ for template meta programming once. never ever again
10:38:20 <midi[F][m]> It would be better to pick a language with stronger dependent type support and quantitative types. Something that may have support for Homotopy type theory
10:38:40 <EvanR> homotopical doom
10:39:01 <EvanR> the fundamental group of circle strafing in a room with N pillars
10:39:45 <iqubic> How do you have Chess at the type level?
10:40:02 * ski didn't know there were that many separation axioms
10:40:11 <midi[F][m]> <iqubic "How do you have Chess at the typ"> Well, types are just logic programming
10:40:20 <midi[F][m]> So, it would be near identical to prolog chess
10:40:22 <ski> no backtracking
10:40:43 <iqubic> Oh, now you decide to trot out the Curry-Howard Isomorphism
10:40:48 <iqubic> I see how it is.
10:41:48 <midi[F][m]> <iqubic "Oh, now you decide to trot out t"> Just for type level programming. Curry-Howard Isomorphism is fine at the function-value level
10:42:01 <midi[F][m]> Haskell is good for what it does
10:42:46 <midi[F][m]> For type level, you'll need more room to express with a language such as coq, agda, or idris
10:43:07 <midi[F][m]> Thankfully, agda compiles to haskell though
10:59:30 * hackage morpheus-graphql 0.3.0 - Morpheus GraphQL  https://hackage.haskell.org/package/morpheus-graphql-0.3.0 (nalchevanidze)
10:59:31 <merijn> hmm, if I have a function returning two Ints (average and max) what do I do? Define a record with named fields or just return (Int, Int)?
11:00:47 <dsal> I'm pretty sure I'd start with a tuple.
11:01:30 <sm[m]> yup, try the simplest thing first
11:01:52 <iqubic> Yeah, just start with (Int, Int).
11:02:32 <ysangkok> why not make newtypes so that you can't mix up avg/max?
11:03:11 <merijn> Well, that was the alternative, yes
11:03:12 <sm[m]> But of course, document it in the haddock. You could also use type aliases for the items if it seems useful.
11:03:34 <merijn> sm[m]: Hah, funny joke ;)
11:04:07 <sm[m]> I was being serious :)
11:04:14 <dsal> type PairOfIntsWhereTheFirstIsAverageAndTheSecondIsMax = (Int,Int)
11:04:17 <merijn> sm[m]: So was I, there's no Haddocks :p
11:04:22 <dsal> average :: PairOfIntsWhereTheFirstIsAverageAndTheSecondIsMax -> Int; average = fst
11:04:41 <dsal> You don't need docs when your code is prose.
11:05:09 <merijn> I'm the only user anyway, if someone wants docs they can bloody well pay me >.>
11:05:30 <midi[F][m]> <dsal "I'm pretty sure I'd start with a"> You can do a custom product type
11:06:34 <sm[m]> Personally I’d want either a doc or a new type there
11:07:19 <midi[F][m]> <sm[m] "Personally I’d want either a doc"> Same
11:07:21 <dsal> I probably regret not making types more than making  types.  But regrets can be fun.
11:08:43 <isovector1> i've got packages A and B. A depends on B, but B:test depends on A
11:08:52 <isovector1> this is not actually a dependency, but cabal is trippin and thinks it is
11:09:14 <merijn> isovector1: It *is* an actual dependency (for now)
11:09:29 <isovector1> merijn: what does that mean
11:09:39 <merijn> isovector1: You can only depend on packages, not components (although that is coming and maybe already partially in 3.0)
11:10:22 <isovector1> sure
11:10:27 <isovector1> but it's the test executable that forms the cylce
11:10:36 <isovector1> but who cares about the tests?
11:10:53 <isovector1> actually the test executable doesn't even form a cycle. 
11:10:54 <merijn> isovector1: Dependencies are not resolved independently for individual components
11:11:00 <isovector1> stack builds it just fine?
11:11:30 <merijn> I don't know stack, so no clue what that's doing
11:11:41 <isovector1> okay
11:11:41 <isovector1> thanks
11:11:50 <isovector1> is there any solution here other than moving my tests to a new package?
11:11:54 <isovector1> which is an atrocious solution
11:12:03 <merijn> isovector1: What do you meany by "the test executable isn't even a cycle"? You mean it doesn't depend on B?
11:12:50 <isovector1> yeah, the test does depend on B. but if i am just building the libraries and not the tests, what's the problem?
11:13:45 <merijn> isovector1: Can't you simply move B:test to A if it depends on A anyway?
11:14:03 <merijn> Then your cycle is broken and everyone's happy
11:15:19 <isovector1> yeah i guess that works
11:15:25 <isovector1> except that really and truly it belongs in B
11:16:10 <isovector1> how much work would a cabal patch be?
11:16:33 <merijn> No clue, multi-component stuff has been in the works for a while
11:16:50 <isovector1> this is super frustrating
11:16:53 <isovector1> but thank you for the information
11:20:14 <freeman42x> what am I doing wrong here? https://i.imgur.com/khZfbsM.png
11:20:30 * hackage arion-compose 0.1.0.0 - Run docker-compose with help from Nix/NixOS  https://hackage.haskell.org/package/arion-compose-0.1.0.0 (RobertHensing)
11:20:41 <c_wraith> posting text as an image is usually a problem. 
11:21:06 <c_wraith> text is easier to read and easier to interact with 
11:21:46 <merijn> I'm betting 10 dollars on "findExecutable is in IO" but we can't say because it's not in the paste
11:21:57 <argent0> freeman42x: findExecutable "foo" >>= \bar -> case bar of ...
11:22:37 <isovector1> https://github.com/haskell/cabal/issues/4087
11:22:48 <argent0> freeman42x: also: paste here https://bpaste.net/+haskell
11:24:30 <dmwit> merijn: It actually is in the paste, surprisingly. A bit hidden, though, and you don't lose your $10.
11:24:47 <merijn> Whoo!
11:28:21 <freeman42x> got it, needed to do something like this: https://bpaste.net/show/-wX9
11:32:59 <iqubic> freeman42x: It turns out that findExecutable is indeed in IO.
11:36:00 * hackage loopbreaker 0.1.1.1 - inline self-recursive definitions  https://hackage.haskell.org/package/loopbreaker-0.1.1.1 (TheMatten)
11:36:26 <merijn> Sometimes I wish existentials were better supported :\
11:40:10 <freeman42x> iqubic, yeah... it was like... in the image...
11:41:06 <freeman42x> is there some Haskell library that allows editing and saving .nix files?
11:58:48 <freeman42x> my use-case is that I would like to make some edits to a .nix file and save it. But I would rather not have to use a parser to do that.
12:07:14 <ysangkok> how would you edit an AST node of any language without parsing first?
12:09:16 <dmwit> (And what would a library do if not parse it?)
12:13:01 <ysangkok> anyway there is a project trying to reimplement nix in haskell, i think it is called hnix
12:21:23 <Squarism> is there any boilerplate in mapping between a record and Data.Map and back?
12:22:16 <Squarism> .../lib
12:30:41 <boxscape> The release notes for 8.8.1 ( https://downloads.haskell.org/~ghc/8.8.1/docs/html/users_guide/8.8.1-notes.html )state that ghc *now* supports visible type application, and link to the -XTypeApplications docs. And yet *that* page says that -XTypeApplications has been around since 8.0.1 (which it has, afaik). What's up with that?
12:32:48 <boxscape> Oh
12:32:53 <boxscape> they mean visible *kind* applications
12:32:57 <boxscape> didn't write it though
12:34:30 * hackage concurrency 1.8.0.0 - Typeclasses, functions, and data types for concurrency and STM.  https://hackage.haskell.org/package/concurrency-1.8.0.0 (barrucadu)
12:35:30 * hackage dejafu 2.1.0.1 - A library for unit-testing concurrent programs.  https://hackage.haskell.org/package/dejafu-2.1.0.1 (barrucadu)
12:39:54 <boxscape> ah but it's fixed in HEAD
12:49:43 <EvanR> can someone help me write this do notation in terms of kleisli arrows and composition:  do { x <- getLine; print "foo"; print x; }
12:50:02 <EvanR> i'm not sure how to get the x to the right spot
12:50:52 <EvanR> do you necessarily have to use join/bind
12:52:57 <merijn> :t getLine >>= (print "foo" >>) . print -- doesn't need Kleisli arrows
12:52:58 <lambdabot> IO ()
12:53:33 <EvanR> i know
12:53:59 <EvanR> so is the answer "can't be done with just kleisli arrows"
12:54:29 <merijn> Well, "It Depends" do you insist on the usage of Kleisli arrows to be sensible according to human logic?
12:54:35 <EvanR> no
12:54:59 <merijn> You'd at very least need >>= anyway to deal with the getLine, I think
12:55:09 <EvanR> that's the question
12:55:13 <merijn> Although I suppose you could wrap it as "\() -> getLine"
12:55:32 <EvanR> yes take getLine to be an () -> String
12:55:32 <merijn> :t (\() -> getLine) >=> (print "foo" >>) . print
12:55:34 <lambdabot> () -> IO ()
12:56:00 <EvanR> i think you printed the x first there?
12:56:08 <merijn> No
12:56:25 <merijn> % (\() -> getLine) >=> (print "foo" >>) . print $ () -- probably doesn't work I suppose
12:56:30 <maralorn> :t getLine >>= (print "foo" $>) >>= print
12:56:30 <yahb> merijn: [Timed out]
12:56:31 <lambdabot> IO ()
12:57:16 <midi[F][m]> <maralorn ":t getLine >>= (print "foo" $>) "> You don't need monad bind for this
12:57:20 <merijn> EvanR: No, it's correct in my ghci
12:57:34 <merijn> EvanR: Note the >> section
12:57:53 <maralorn> midi[F][m]: What do you mean?
12:57:54 <EvanR> i see
12:58:13 <EvanR> :t (print "foo" >>) . print
12:58:14 <lambdabot> Show a => a -> IO ()
12:58:26 <midi[F][m]> <maralorn "midi[F]: What do you mean?"> Remember that IO is an applicative functor
12:58:34 <merijn> % (print "foo" >>) . print $ True
12:58:35 <yahb> merijn: "foo"; True
12:58:54 <EvanR> this doesn't really solve the issue since >> is just >>= that ignores the argument
12:59:10 <EvanR> unless theres a >> in terms of kleisli?
12:59:19 <midi[F][m]> Use `<*>` where you can
12:59:53 <maralorn> midi[F][m]: Let me think about it.
13:00:00 <merijn> :t (\() -> getLine) >=> ((\() -> print "foo") >=>) . const . print
13:00:01 <lambdabot> error:
13:00:01 <lambdabot>     • Couldn't match type ‘() -> IO ()’ with ‘IO c’
13:00:01 <lambdabot>       Expected type: String -> IO c
13:00:07 <merijn> hmmm, so close
13:00:13 <EvanR> my question is about monads in general btw, not IO
13:00:40 <merijn> EvanR: Of course there's a >> in terms of Kleisli, just add a few dummy arguments
13:00:48 <EvanR> arguments to what
13:01:41 <merijn> EvanR: "foo >> bar" -> "(\() -> foo) >=> (\_ -> bar) $ ()"
13:02:03 <EvanR> alright
13:02:04 <maralorn> :t const getLine >=> (print "foo" $>) >=> print $ ()
13:02:05 <lambdabot> IO ()
13:02:15 <maralorn> EvanR: Is this what you are looking for?
13:02:17 <EvanR> that implements >>, but you lose the input
13:02:37 <merijn> EvanR: Sure, because >> doesn't have an input
13:03:00 <EvanR> maralorn: let me decode it and see
13:03:14 <EvanR> you guys and your sections...
13:03:35 <maralorn> :t ($>)
13:03:36 <lambdabot> Functor f => f a -> b -> f b
13:03:48 <EvanR> (print "foo" $>) means....
13:03:56 <EvanR> uhg
13:04:02 <maralorn> I hoogled that. You can use it to make a "IO a" to a "a -> IO a"
13:04:30 <maralorn> And with this you can pass the value through the statement that doesn‘t care about it.
13:04:43 <merijn> maralorn: THat's both clever and disgusting
13:04:52 <EvanR> yeah i was trying to do this at some point and failing
13:04:53 <merijn> maralorn: You should be ashamed and proud of yourself
13:04:59 <maralorn> You can use it to make a "IO ()" to a "a -> IO a" 
13:05:12 <EvanR> i believe you now i will try to get it
13:05:34 <maralorn> merijn: Ask all my nerd friends. I am famous for "clever and disgusting".^^
13:05:36 <EvanR> by first translating it into fmap
13:07:24 <EvanR> some blog post constructed everything necessary to finally get to kleisli category, and said "and this is a very general and powerful notion of computation" and i'm like... ok
13:07:38 <EvanR> can't even translate this do notation (until now) :)
13:10:15 <EvanR> nah wait
13:10:47 <ski> @let graph :: Arrow ar => ar a b -> ar a (a,b); graph f = Control.Category.id &&& f; cograph :: ArrowChoice ar => ar a b -> ar (Either a b) b; cograph f = f ||| Control.Category.id
13:10:49 <lambdabot>  Defined.
13:10:54 <ski> @type runKleisli (Kleisli (\() -> getLine) >>> graph (Kleisli (\_ -> print "foo")) >>> Kleisli (return . snd))
13:10:55 <lambdabot> () -> IO ()
13:10:56 <maralorn> a >=> b >=> c == \x -> do {y <- a x; z <- b y; c z}.
13:10:58 <ski> (or `arr snd')
13:11:33 <ski> hum, i suppose `fst' really
13:11:36 <ski> @type runKleisli (Kleisli (\() -> getLine) >>> graph (Kleisli (\_ -> print "foo")) >>> Kleisli (return . fst))
13:11:37 <lambdabot> () -> IO String
13:13:23 <maralorn> midi[F][m]: I don‘t see how I could have used (<*>) there. Can you enlighten me?
13:13:37 <EvanR> maralorn: so the middle term is a "kleiskli lambda" rather than a primitive arrow or fmap or composition of arrows...
13:14:17 <EvanR> it seems that to get it without lambda-on-the-kleisli-level you'd have to join an fmap?
13:15:29 <maralorn> EvanR: I am not really firm with the nomenclature. Is "a -> m a" == "kleisli lambda"?
13:15:38 <EvanR> that's an arrow
13:15:48 <merijn> What is a Kleisli lambda?
13:16:08 <EvanR> foo >=> \x -> some normal IO action
13:16:13 <merijn> And what does "on the kleisli level" mean?
13:16:25 <maralorn> Well, Kleisli composition is arrow composition, isn‘t it?
13:16:35 <maralorn> :t (print "foo" $>)
13:16:36 <lambdabot> error:
13:16:36 <lambdabot>     • Variable not in scope: ($>) :: IO () -> t
13:16:36 <lambdabot>     • Perhaps you meant one of these:
13:16:58 <EvanR> kleisli composition involves fmap and join
13:17:10 <EvanR> fmap involves a function in the original category
13:17:31 <EvanR> but kleisli arrows are.....
13:18:02 <EvanR> i was taking them to be primitives
13:18:13 <EvanR> or id, or composition
13:18:16 <EvanR> or fmap
13:18:54 <EvanR> but if the original category has lambdas i guess it can also be lambdas?
13:19:44 <EvanR> ok
13:20:29 <merijn> EvanR: You're being very vague about the exact definitions you wanna use. Are we talking in terms of CT here or in terms of Haskell?
13:20:37 <maralorn> a >=> b = \x -> join $ fmap b (a x)
13:21:05 <EvanR> basically, can we do anything a monad can do if you move to the kleisli category
13:21:15 <maralorn> EvanR: Yes.
13:21:32 <EvanR> proof?
13:22:17 <maralorn> EvanR: You can recover monadic bind very easily from a kleisli composition a >>= b = (const a >=> b) ()
13:22:46 <freeman42x> I am running a command in GHCI which requires root. How can I keep testing the program in GHCI and give it root?
13:22:49 <EvanR> hmm is >>= that general?
13:22:52 <EvanR> what about join
13:24:02 <Ferdirand> :t (>>= id)
13:24:03 <lambdabot> Monad m => m (m b) -> m b
13:24:13 <EvanR> can you recover join from kleisli composition
13:25:00 <dmwit> Yes, by combining maralorn's translation and Ferdirand's translation.
13:25:21 <dmwit> join m = m >>= id = (const m >=> id) ()
13:25:23 <EvanR> erhm... maralorn translation goes left to right
13:25:28 <EvanR> not right to left
13:25:39 <maralorn> :t \a -> (const a >=> id) ()
13:25:40 <lambdabot> Monad m => m (m c) -> m c
13:25:46 <dmwit> It goes both ways. But left-to-right is enough.
13:26:01 <EvanR> i have a program in terms of >=> and i want it in terms of joins
13:26:23 <dmwit> ok
13:26:40 <EvanR> so left to right doesn't seem to match
13:26:44 <dmwit> (f >=> g) x = f x >>= g = join (fmap g (f x))
13:26:46 <maralorn> EvanR: I think then you want "a >=> b = \x -> join $ fmap b (a x)"
13:27:20 <EvanR> ok
13:28:19 <EvanR> wait... join m = m >>= id = (const m >=> id) (), this involves application?
13:28:34 <dmwit> Yes.
13:28:40 * EvanR head scratch
13:28:59 <EvanR> what if the category doesn't have a notion of apply an arrow to something
13:29:02 <dmwit> Argument-free monadic computations must introduce a spurious argument if you want a Kleisli-based representation of them.
13:29:33 <dmwit> () -> m a is the closest analog you can have of m a if you stay inside the Kleisli category.
13:29:59 <dmwit> So `const m >=> id` is the closest analog you can of `join m` if you stay inside the Kleisli category.
13:30:00 <EvanR> () -> m a is one thing, but applying to () is another
13:30:19 <dmwit> If `m :: m (m a)`, then `const m >=> id :: () -> m a`.
13:30:32 <dmwit> If `m :: () -> m (m a)`, then `m >=> id :: () -> m a`.
13:30:37 <EvanR> ok maybe i was just thrown off by the application
13:30:59 <EvanR> join m = const m >=> id
13:31:08 <dmwit> no
13:31:13 <EvanR> ...
13:32:18 <dmwit> Choose, please: do you want to represent your monadic computations as `() -> m a` or in some other way?
13:32:39 <dmwit> If you want that representation, then the correct type for our join analog is `(() -> m (m a)) -> (() -> m a)`.
13:32:54 <EvanR> i have no problem with source () and target T(a)
13:32:57 <dmwit> And the correct implementation is `joinAnalog m = m >=> id` (no const).
13:32:59 <merijn> The problem is that he's mixing Haskell and CT
13:33:01 <maralorn> EvanR: I don‘t think this stuff works in a category without exponentials.
13:33:09 <EvanR> which stuff
13:33:25 <maralorn> EvanR: At least our solutions to your questions.
13:33:30 <EvanR> yeah i would like to mix out the haskell
13:33:42 <EvanR> how much of this is out the window if you throw out haskell
13:34:11 <dmwit> Very little. It's just that the "compilation" phase from a Kleisli composition to a monadic thing (or vice versa) is a meta-level compilation, not an internal one.
13:34:17 <dmwit> Haskell is special because the compilation can be internal.
13:34:48 <maralorn> EvanR: Well I guess the solutions I gave you work in any category with exponentials and a terminal object. (allthough the later is probably optional.)
13:35:20 <EvanR> terminal object ok, exponentials is the thing that gives you a lambda?
13:35:28 <maralorn> EvanR: Yep
13:36:00 <EvanR> now monads don't depend on terminal objects or lambdas right
13:36:03 <EvanR> in general
13:36:04 <maralorn> But I am still a bit foggy about this if you want it really formal.
13:38:04 <maralorn> EvanR: I feel I mixed this up a bit. 1. Yes you can have a Monad in a category without exponentials.
13:40:31 <maralorn> And then you can always construct the Kleislicategory for it.
13:41:18 <EvanR> in which case fish f g = join (fmap f) . g
13:41:50 <EvanR> erm...
13:42:54 <EvanR> here's the post i'm on http://www.stephendiehl.com/posts/monads.html
13:43:17 <maralorn> fish f g = join  . fmap f . g
13:44:46 <EvanR> now i presume we can go from join to something with fish, i'll try to figure it out 
13:58:01 <EvanR> :t id >=> id
13:58:02 <lambdabot> Monad m => m (m c) -> m c
13:58:07 <EvanR> \i/
13:58:14 <EvanR> \o/
13:58:16 <merijn> My code works \o/ Now I just need to make it less of an atrocity >.>
13:59:16 <EvanR> said no one ever
13:59:19 <ystael> merijn: rewrite it in J, because why minimize atrocity when you could maximize it
13:59:32 <merijn> ystael: Because I still need to improve it :p
13:59:58 <merijn> EvanR: That's what makes haskell great I can write terrible code to make it work, then refactor it easily into something less terrible!
14:00:01 <ystael> J is an immutable programming language. Once you write code, it's impossible to modify.
14:01:54 <maralorn> I have this tendency to refactor my code until there is no way to deduce my intention at all …
14:02:00 <EvanR> yeah in another language terrible code has to stay that way because it's too gnarly to even touch
14:04:25 <merijn> Writing ugly versions quickly lets me avoid having to think of a name until I know a piece of code will stick :p
14:04:57 <maralorn> EvanR: Nice solution. But it confused me alot because "id" is not the identity of the kleisli category, but of the base category.
14:05:51 <EvanR> let me type check it
14:06:15 <maralorn> EvanR: The identity of kleisli is "pure".
14:06:44 <EvanR> :t pure >=> pure
14:06:45 <lambdabot> Monad m => c -> m c
14:06:51 <EvanR> O_o
14:07:04 <EvanR> :t pure >=> id
14:07:05 <lambdabot> Monad m => m c -> m c
14:07:11 <EvanR> :t id >=> pure
14:07:12 <lambdabot> Monad m => m c -> m c
14:07:33 <koz_> EvanR: Pure fish pure?
14:08:07 <EvanR> so in join . fmap id . id, the first id is identity arrow on T a
14:08:17 <EvanR> and the second id is...
14:08:56 <EvanR> first id is identity arrow on a, promoted to T a -> T a
14:09:04 <maralorn> EvanR: But nice. You found a solution to recover join without using any additional requirements to the monad. I stared at the wikipedia page for 20 minutes without figuring it out.^^
14:09:53 <EvanR> i did? i mean once i figure out what the second id is
14:10:33 <maralorn> EvanR: Well there is always "fmap id = id".
14:11:12 <maralorn> (But that probably doesn‘t help for your question.^^)
14:11:20 <EvanR> in fish f g, isn't g supposed to have type a -> T b or something
14:11:29 <maralorn> Yep.
14:11:41 <EvanR> so not sure how id can ...
14:12:00 <comerijn> EvanR: When the input has type "T b" too
14:12:10 <comerijn> EvanR: Same way ">>= id" works as join
14:12:15 <EvanR> oh, a = T b
14:12:19 <EvanR> wait
14:12:27 <comerijn> :t (>>= id)
14:12:28 <lambdabot> Monad m => m (m b) -> m b
14:12:53 <maralorn> so in fish id id, we have fish (id :: a -> T b) (id :: b -> T c) with a :: T b, b :: T c, thus a :: T (T c)
14:13:10 <EvanR> with a = T b, b = T c
14:13:14 <EvanR> a = T (T c)
14:13:19 <maralorn> Yes!
14:13:57 <EvanR> ok
14:14:05 <maralorn> That was fun!
14:14:21 <EvanR> you can now all convert all your monad code to fishes
14:14:32 <wildtrees> freeman42x: try: :! sudo your-command-here inside of ghci 
14:17:55 <freeman42x> wildtrees, I started cabal v1-repl under root and all is fine
14:18:24 <maralorn> EvanR: Well that‘s mostly cosmetics isn‘t it? Its like the difference between (c . b . a $ x) and (c $ b $ a $ x)
14:18:30 * hackage bins 0.1.2.0 - Aggregate continuous values into discrete bins  https://hackage.haskell.org/package/bins-0.1.2.0 (jle)
14:18:40 <tdammers> so I learned today that when you fire off some threads with forkIO, and rely on them to be killed at program shutdown, and you then do all that in ghcid, then a ghcid reload won't kill those threads - they will keep running while the reloaded code starts new versions, so now you have the old code and the new code running in parallel
14:18:42 <wildtrees> freeman42x: oh ok :) 
14:18:42 <EvanR> i'm about to find out by answering my original question
14:18:50 <tdammers> it feels a lot like livecoding in clojure
14:19:26 <maralorn> (c <=< b <=< a $ x) = (c =<< b =<< a x)
14:19:29 <comerijn> tdammers: This is why you should implement proper explicit cleanup from the spawning thread :p
14:19:42 <freeman42x> question in link: https://bpaste.net/show/oLoo
14:19:48 <tdammers> comerijn: tricky.
14:20:20 <comerijn> tdammers: I know :)
14:20:43 <comerijn> tdammers: What are the threads doing?
14:21:00 <EvanR> maralorn: there is still this issue of getting to variables introduces earlier in the chain
14:21:31 <EvanR> like seems like there would be a kleisli version of @pl flipping and .-ing
14:21:35 <tdammers> well, I have a web app running that serves a bunch of websockets, and those threads are driving the data sources that then get dispatched onto those websockets
14:21:58 <tdammers> but the whole thing runs in a `forever` loop, so there's not really a logical place for the cleanup
14:22:21 <tdammers> I guess I'd have to use either weakptrs of sorts, or somehow mess with exceptions
14:22:45 <comerijn> or spawn them via async
14:25:02 <dmwit> freeman42x: foldr addToConfigurationIfDoesNotExist config ["compiler", "cabal", "atom"] -- ?
14:25:33 <dmwit> I dunno, you might need to flip your addTCIDNE.
14:25:37 <tdammers> comerijn: would just plain async be sufficient for that? the documentation isn't quite clear on the matter
14:26:17 <comerijn> tdammers: You wanna tie the lifetime to the parent thread via exceptions
14:26:47 <tdammers> I guess so, yes
14:26:56 <comerijn> tdammers: Alternatively, you can crib from my threading code in broadcast-chan, but it's messy to setup right (hence why I decided to do it properly once so I'd never have to again ;))
14:27:06 <tdammers> hmhm
14:27:55 <tdammers> or I could just leave it as is, because ghcid isn't how we're going to deploy this into production
14:28:23 * tdammers feels the dark side of the force flowing through him
14:28:42 <dmwit> :t mfix . \ref v -> writeIORef ref v >> getLine
14:28:43 <lambdabot> error:
14:28:43 <lambdabot>     • Variable not in scope: writeIORef :: t -> String -> IO a0
14:28:43 <lambdabot>     • Perhaps you meant ‘writeSTRef’ (imported from Data.STRef)
14:29:04 <dmwit> :t mfix . \ref v -> writeSTRef ref v >> pure "hi"
14:29:05 <lambdabot> STRef s [Char] -> ST s [Char]
14:29:11 <dmwit> spooky
14:29:17 <maralorn> EvanR: Well i normally decide that that is the point were I should use do notation. But if its just one variable at a time that you need you can use the functor trick I gave above.
14:29:56 <EvanR> maralorn: well, i think we established that using nothing but fish is a fairly balls way to program in general. But then how did this blog post about implementing I/O using it make any sense... http://comonad.com/reader/2011/free-monads-for-less-3/
14:30:00 <maralorn> EvanR: If it‘s more than one variable at a time you need to preserve you call have to use tuples.
14:30:36 <EvanR> ok it wasn't kleisli, but it ended up being primitive functions of type i -> o
14:30:47 <EvanR> and you string them together
14:34:01 <EvanR> ok, rereading it
14:34:14 <maralorn> EvanR: Well it‘s certainly doable. It just sounds very tedious.
14:35:37 <dmwit> % mfix (\v -> putStrLn v >> getLine)
14:35:37 <freeman42x> dmwit, I'd rather use a Semigroup for this with <>, code would read nicer
14:35:42 <yahb> dmwit: [Timed out]
14:37:50 <dmwit> freeman42x: I disagree. But if you must, you can use (.) instead of (<>). flip aTCIDNE "haskell" . flip aTCIDNE "cabal" . flip aTCIDNE "atom" $ config
14:39:05 <maralorn> Are there preludes with "(++) = (<>)"?
14:39:23 <maralorn> I think ++ looks much nicer.
14:40:09 <maralorn> But <> is more general, so I would prefer to have ++ with the semantics of <>. (Also this is obviously irrelevant and I should probably just go to bed.)
14:40:56 <freeman42x> dmwit, I disagree with you disagreeing. using <> is perfect
14:41:14 * dmwit . o O ( appEndo (Endo (flip aTCIDNE "haskell") <> Endo (flip aTCIDNE "cabal") <> Endo (flip aTCIDNE "cabal")) config )
14:41:17 <dmwit> so beautiful
14:41:21 <dmwit> so perfect
14:42:17 <EvanR> i suggest replacing both ++ and <> with unicode snowman and the more general type signature
14:42:25 <EvanR> half serious
14:42:43 <freeman42x> dmwit, no, wait, actually I agree with you. But I will still do it haha
14:43:08 <maralorn> EvanR: I guess typing that would be a bit annyoing.
14:43:10 <dmwit> I find your preferences very confusing.
14:44:42 <freeman42x> dmwit, a bit differently though. I will create a Semigroup for <> packages together, but not with original configuration
14:45:27 <dmwit> You definitely aren't going to get a lighter-weight syntax than `["haskell","cabal","atom"]`.
14:46:06 <dmwit> Which... already has a suitable <>.
14:48:23 <EvanR> clojure and their [:haskell :cabal :atom] are laughing at us
14:48:46 <dmwit> What makes that better?
14:48:59 <dmwit> Oh, you mean the half a dozen fewer keystrokes?
14:49:24 <EvanR> lack of quotes and commas
14:49:29 <EvanR> they would say
14:50:24 * dmwit shrugs
14:50:37 <maralorn> I always trip over nix lists not having commas.
14:50:41 <dmwit> I have a hard time getting too worked up about minor differences in string literal syntax.
14:51:33 <EvanR> gotta admit there is less visual noise 
14:51:50 <dmwit> I\ don't\ have\ to\ admit\ any\ such\ thing.
14:51:57 <EvanR> carpal tunnel syndrome is an editor issue though
14:52:01 <koz_> EvanR: :foo is a symbol in Clojure, not a string.
14:52:07 <EvanR> i know
14:52:36 <EvanR> i.e. a lightweight string
14:54:43 <maralorn> I guess you could solve that in haskell with OverloadedLabels, couldn‘t you?
14:56:23 <EvanR> my brain is fried can't process another feature :)
14:58:11 <freeman42x> dmwit, you are probably right, that is probably the easiest way, but it needs to be foldl not foldr: let newConfig = foldl addToConfigurationIfDoesNotExist config ["haskell.compiler.ghc865", "haskellPackages.cabal-install", "atom"]
14:58:18 <maralorn> Well, I don‘t think it would be useful and the type errors would probably look terrible.
14:58:40 <dmesg> Hi there! I'm trying to get some data out of postgres and then return it as a JSON array to the client. I don't know/care about the data in the database, I just want it as an Aeson.Value. Any ideas on what type hints I should give the compiler? I'm using http://hackage.haskell.org/package/postgresql-simple-0.6.2 to access postgres and here's a
14:58:41 <dmesg> small repro http://dpaste.com/397EV40
15:04:48 <maralorn> dmesg: I don‘t think you can get that with just some type hints.
15:05:23 <maralorn> I guess you would need a FromField instance for JSON.Value.
15:07:04 <maralorn> Uh, wait, there is such an instance.^^
15:08:38 <maralorn> dmesg: I would try appending ':: IO [JSON.Value]' in the first line of the do statement.
15:09:23 <dmesg> yeah, but I don't think that's what I want. If I tell the compiler the return type is a list of `[JSON.Value]` the library will expect postgres to send back a list of json blobs which isn't what necessarily true?
15:09:54 <maralorn> dmesg: Uh, yeah, that’s true.
15:10:14 <maralorn> That’s certainly not what you want.
15:10:16 <dmesg> (and it would be `IO [[JSON.Value]]` since it's on FromField right?)
15:11:07 <dmesg> what I want to say is "look library you'll get something that I swear if you call `JSON.toJSON` on will return a `JSON.Value`
15:11:33 <maralorn> dmesg: But GHC needs to no what Instance of toJSON to call.
15:11:52 <maralorn> *needs to know
15:12:41 <maralorn> I wonder if the easiest way would be to just use the postgres function for converting the answer to a json string …
15:13:03 <dmesg> hah, in the SQL query itself? That's not a bad idea
15:13:56 <maralorn> dmesg: Yes. I don‘t like it very much, but it‘s the only solution I can fathom right now.
15:14:00 * hackage emd 0.1.7.1 - Empirical Mode Decomposition and Hilbert-Huang Transform  https://hackage.haskell.org/package/emd-0.1.7.1 (jle)
15:14:22 <EvanR> for whatever reason json in my database has never been pleasant
15:16:00 * hackage emd 0.1.8.0 - Empirical Mode Decomposition and Hilbert-Huang Transform  https://hackage.haskell.org/package/emd-0.1.8.0 (jle)
15:16:50 <maralorn> dmesg: The next best Idea I have is manually implementing a ToJSON instance for newtype around JSON.Value with a parser that can translate most stuff tha postgres could return to JSON. But that sounds like something that has been solved before.
15:19:30 * hackage emd 0.1.8.1 - Empirical Mode Decomposition and Hilbert-Huang Transform  https://hackage.haskell.org/package/emd-0.1.8.1 (jle)
15:22:53 <dmwit> dmesg: You may use the standard tricks for passing a type argument.
15:23:12 <dmesg> maralorn yeah that's what I'm going to try now - I agree I feel like it should be a solved problem somewhere in the postgres library? The sqlite library equivalent has the SQLData type (which is what I'm porting this from) that solved this problem http://hackage.haskell.org/package/sqlite-simple-0.4.16.0/docs/Database-SQLite-Simple.html#t:SQLData
15:23:33 <dmesg> dmwit the standard tricks?
15:24:14 <dmwit> dmesg: The old way is `queryHandler :: proxy a -> Connection -> IO Value` and use a type-restricted version of `query_` that understands proxies, or use ScopedTypeVariables, AllowAmbiguousTypes, and TypeApplication to write `queryHandler :: forall a. Connection -> IO Value` and then write `query_ conn "SQL" :: IO a` in the body.
15:24:28 <dmwit> ("or use ..." is the new way)
15:25:13 <dmwit> For an example of a proxy-aware `query_`, you could write `queryProxy :: FromField a => proxy a -> Connection -> String -> IO a; queryProxy _ = query_` or so.
15:25:53 <dmwit> dmesg: Then, at the callsite, for the old way you write `queryHandler (Proxy :: Proxy WhateverTypeIWantToGrab)`; for the new way you write `queryHandler @WhateverTypeIWantToGrab`.
15:27:10 <dmwit> N.B. I know Haskell very well, but this library not at all. I made up the names FromField and Connection. I assume you know enough to fix those up properly.
15:27:43 <dmesg> dmwit but the problem is I don't have a type I want to grab? I'm going to throw this JSON over the network, it's opaque to me. If I do `queryHandler @JSON.Value` what that be the equivalent to doing `results <- query_ conn "SELECT..." :: IO [[JSON.Value]]`?
15:27:57 <dmwit> You need to know what type you want to grab.
15:28:01 <dmesg> s/what that/won't that
15:28:30 <dmwit> A single database entry may plausibly be decodable at multiple different types, with different ToJSON instances.
15:28:37 <dmwit> So the JSON you send depends on which type you choose.
15:28:55 <dmwit> That is: it is not *just* that you have to pick a type here. Picking a type also picks a *behavior*.
15:29:22 <dmesg> right, and the behaviour I want to describe is "it will give you something that will have a ToJSON instance on it"
15:29:30 <dmwit> No, you're not listening.
15:29:47 <dmwit> You can have two types that both have ToJSON instances that *do different things*.
15:30:07 <dmwit> Meaning that the caller might get two different JSON Values from the same database, if they choose different intermediate types.
15:30:36 <dmwit> Like... okay.
15:30:42 <dmwit> Imagine you have a column in your database that stores a number.
15:30:55 <dmwit> You can read out that number as either a Sum Int or a Product Int, for lack of imagination.
15:30:57 <maralorn> dmwit: I think the point is, that dmesg wants a behavior which is not provide by any instance.
15:31:13 <dmwit> If you convert those both to JSON, you get {"sum": 3} in the one case, and {"product": 3} in the other.
15:31:18 <dmwit> You have to choose *which* of those you want.
15:31:42 <dmwit> And this is the compiler's way of telling you that you must choose right here.
15:32:06 <dmwit> Or else push the choice off onto the caller, that's fine too, but you *must choose what code to call to convert from your SQL database to JSON values*.
15:33:13 <maralorn> dmwit: But you have to admit that there should be a way to convert most postgres result to json without statically knowing what the type of the result is.
15:33:25 <dmwit> I don't have to admit that at all. Why should I have to admit that?
15:34:11 <dmesg> okay...how does the sqlite variant of this library get away this then? When it puts the result into a SQLData (http://hackage.haskell.org/package/sqlite-simple-0.4.16.0/docs/Database-SQLite-Simple.html#t:SQLData) how does it know which constructor to call?
15:34:45 <maralorn> dmwit: I feel like you are explaining the type error. And your explanation is correct. But we are talking about finding a solution to a legitimate programing task.
15:36:02 <dmwit> It looks at the Field it's given to know.
15:36:06 <dmwit> You can do the same thing.
15:36:39 <EvanR> heh, postgres fields of certain basic types can be converted to json basic atomic values. But then........ what about postgres json fields
15:36:40 <dmwit> I don't yet understand the task goal.
15:36:49 <dmwit> maralorn: ^
15:36:51 <EvanR> recursively unpack the json into json?
15:37:07 <EvanR> repack
15:37:51 <maralorn> dmwit: I think what dmesg wants is a datatype which can represent basically any postgres datatype which has a FromField and a ToJSON instance.
15:38:02 <dmwit> No, you can't do that. Sorry.
15:38:27 <maralorn> dmwit: Why not?
15:38:36 <dmwit> I mean, you can, but it won't help, because a single postgres field can be decoded to two isomorphic types with differing ToJSON instances.
15:38:48 <dmwit> So you are just pushing the decision about which of those instances off to somebody else.
15:38:54 <dmwit> Which is fine. But the decision must be made.
15:39:27 <dmwit> I think my Sum/Product example was pretty good about illustrating this problem.
15:40:11 <dmesg> Okay, can I define the mapping then between FromField to ToJSON instances? So I'll pick in the ambiguous cases?
15:40:38 <dmwit> No, that mapping is fixed. There is at most once instance each of FromField and ToJSON for each type.
15:41:14 <maralorn> dmwit: Well JSON Values have really just a few types. So this new datatype implementation would be very lossy.
15:41:46 <dmesg> maralorn that's fine, anything unsupported I'm happy to exception on.
15:41:46 <dmwit> Hold on. Give me a second to create a really simple example showing why this matters, okay?
15:41:54 <dmesg> absolutely!
15:43:09 <dmesg> and just to reiterate, the task here is to take a table of unknown schema and convert it's result into a JSON result which is sent over the network. I don't really care what the table contains or what the JSON output is, as long as whatever the table returns can be converted to json.
15:44:28 <dmesg> If someones using something esoteric in the table I'm happy to exception on those cases. If there are cases where the result from postgres can be serialized into JSON in multiple ways I'm happy to make the decision
15:46:57 <dmwit> dmesg: https://gist.github.com/dmwit/d9bca87865ac7bb941239f13ef03ffea
15:47:31 <dmesg> sweet, looking
15:47:44 <maralorn> I think, if we just don‘t talk about typeclasses for a second, what you need to write at the end is a "RowParser JSON.Value". But implementing it would be a bit tedious. You would inspect a field for its type and then decide which parser to use from a hardcoded list and convert that result to a JSON.Value.
15:47:47 <dmwit> dmesg: So make a FromField and ToJSON instance for Field.
15:48:00 <dmwit> dmesg: And then choose Field as the type which is currently ambiguous.
15:48:24 <dmesg> dmwit and Field here is?
15:48:30 <dmwit> (Or maybe from (Field, Maybe ByteString)?)
15:48:48 <dmesg> (this thing? http://hackage.haskell.org/package/postgresql-simple-0.6.2/docs/Database-PostgreSQL-Simple-FromField.html#t:Field)
15:48:51 <dmwit> Field here is the Field from postgresql-simple, the type given to you by a FieldParser in FromField.
15:50:19 <maralorn> dmwit: Are you sure that the actual data is also contained in the Field value. The docs say "epresents metadata about a particular field" I think the parser get’s the actuall data as a bytestring.
15:50:41 <dmwit> Yeah, I amended to say you probably need it to be (Field, Maybe ByteString), not Field.
15:51:31 <maralorn> dmesg: The cheapest method to get away with would be to just convert the ByteString to Text and go with that. But for some fieldtypes that is probably a bad choice.
15:51:47 <dmesg> okay I think that makes sense. So postgres _is_ sending some information about the types. I understand what you're describing dmwit in your example, but I don't think that's quite the case here as the DB knows the schema (and is sending that)?
15:52:04 <maralorn> dmwit: Ah, sorry. Didn‘t read that, because I was busy typing.^^
15:52:28 <dmwit> dmesg: But that's the thing. Suppose I tell you the schema of `database` in my example is: "it has an integer". That doesn't actually answer the question of whether to decode to A or B!
15:53:02 <dmwit> dmesg: Not even if I pass the information that it's an integer into `parse`.
15:53:14 <maralorn> dmwit: Yeah, but JSON has just one integer type. So you just go with a reasoable default which converts in a plausible way to JSON.
15:54:01 * dmwit squints
15:54:06 <maralorn> But of course for deciding which instance to use you need to write manual code, ghc can‘t know.
15:54:17 <tdammers> arguably, JSON has zero integer types
15:54:27 <dmesg> right, I think that was the mapping I was referring (badly) to earlier
15:55:02 <maralorn> tdammers: s/integer/number/
15:55:25 <dmwit> Point of order: I say, from now on, "type" is taboo. You must say "SQL type", "Haskell type", "JSON type".
15:55:38 <maralorn> dmwit: Fair enough.
15:56:01 <dmwit> Because then you will see that you are talking about "SQL type", I am talking about "Haskell type". So of course the same claims don't apply.
15:57:16 <dmwit> If you would like to be able to decode anything a database can hold, you must make a Haskell type which can represent anything that a database can hold.
15:57:20 <maralorn> So we need a parser which decides for every SQL type which JSON type to use. And since you probably don‘t want to implement the actual parsers yourself you will pick a reasonable Haskell Type as intermediate.
15:57:32 <dmesg> yeap exactly
15:57:33 <dmwit> Then you may decode your database to that type, and say how to encode anything in that Haskell type to JSON.
15:57:37 <maralorn> dmwit: Exactly.
15:57:41 <dmwit> Then you will be done, and you will not have any ambiguous Haskell types.
15:59:16 <dmwit> At no point do you need a type which represents any Haskell type that has both a FromField instance and a ToJSON instance.
15:59:40 <maralorn> But now that we analyzed this in detail I think the by far least amount of work would be to just modify the query to just make postgres serialize the result to json before it touches any Haskell.
15:59:43 <dmwit> (first "type" should also be "Haskell type")
16:00:28 <dmwit> (Not only you don't need it: you also don't even want it.)
16:01:06 <maralorn> Because I think that feature exists and will probably give a better conversion than anything one would hack together by doing it on your own.
16:02:19 <maralorn> dmwit: I am sorry my sentence about "FromField and ToJSON instances" was very badly phrased by missing logical parantheses.
16:03:42 <maralorn> I meant exactly what we now agreed on.
16:04:12 <wildtrees> if you have a choice of database, just use mongoDB and serve the json it spits back to you after queries :) unless you need transactions or ACID stuff 
16:14:00 * hackage pretty-relative-time 0.1.0.0 - Pretty relative time  https://hackage.haskell.org/package/pretty-relative-time-0.1.0.0 (Norfair)
16:21:55 <incertia> does anyone know why im unable to declare a function whose name is (:/)?
16:22:20 <incertia> Invalid type signature: (:/) :: ...
16:22:33 <incertia> i can do (/:) just fine
16:24:34 <glguy> Operator symbols starting with : are reserved as constructors
16:24:57 <glguy> data Example = Int :/ Int
16:25:58 <incertia> i see
16:26:02 <incertia> thanks for clarifying
16:26:27 <glguy> % data T = (:/) deriving Show
16:26:27 <yahb> glguy: 
16:26:28 <nshepperd> : is uppercase ;)
16:26:44 <glguy> % (:/)
16:26:44 <yahb> glguy: (:/)
16:27:51 <glguy> % let (/:) = 10 in (/:) + (/:)
16:27:52 <yahb> glguy: 20
16:28:52 <incertia> nshepperd: that suddenly makes so much more sense
16:28:54 <incertia> LOL
16:37:13 <sim590> in the example following the section "guard" https://en.wikibooks.org/wiki/Haskell/Alternative_and_MonadPlus#guard, one can read the comment in the code (exercise 2) saying that the `do` block helps with preventing pattern matching errors, but it's not the case! If you do `char 'a' ""`, you get an exception...
16:39:28 <sim590> The pattern match could not fail in another manner. It has to be an empty list case, but the code doesn't help returning `Nothing`. It throws an exception... :/ Am I understanding this incorrectly?
16:39:39 <glguy> You've identified an error on that page!
16:40:05 <glguy> To get the described failure behavior it would need to be "c' : s' <- Just s" instead of "let (c':s') = s"
16:41:26 <sim590> Alright. I thought so. Thanks for confirming!
16:41:32 <sim590> I should modify the wiki I guess.
16:44:14 <glguy> sim590: I'd prefer to see: https://gist.github.com/glguy/207e19ddc543ffc05bb4fbff9b840f71
16:45:48 <sim590> Since the chapter is on Monads, I think that your first proposition is better, no?
16:47:05 <sim590> I see that you got rid of the `if` clause.
16:54:23 <sim590> glguy: https://paste.debian.net/1104577/ this is also good, no?
16:54:41 <sim590> It is making use of `guard` which has just been introduced before so that's relevant.
16:55:32 <glguy> sim590: It's not really important to the concept of monads that a pattern match failure in do-notation calls fail. We actually moved that method out of the Monad class and into MonadFail. I don't see where it's using guard
16:56:33 <sim590> I did put `guard (c == c')` here: https://paste.debian.net/1104577/
16:57:00 <sim590> It's not on the wiki yet. I'm discussing it with you.
16:58:24 <sim590> Also, I don't think that the notation `c' : s' | c == c'` has been introduced so far in the book. We have read about | in list comprehension, but it was not clear that you could use that in pattern matching. IMO judging from the book.
17:03:03 <glguy> sim590: That paste is fine, you don't need the () around the pattern though
17:04:21 <sim590> Yes. That's true.
17:06:41 <sim590> I made the changes.
17:12:30 * hackage freer-simple 1.2.1.1 - Implementation of a friendly effect system for Haskell.  https://hackage.haskell.org/package/freer-simple-1.2.1.1 (lexi_lambda)
17:12:40 <jayyy> Hello? is this the correct place to ask a question?
17:13:01 <MarcelineVQ> yep, if it's about the haskell programming language :>
17:13:10 <jayyy> that does happen to be the topic
17:13:16 <jayyy> what a coincidence
17:15:01 <jayyy> so my Docker knowledge is limited, im trying to build Geordi http://www.eelis.net/geordi/#install and it keeps failing with this error https://paste.mod.gg/qasipozijo.sql which a google search of makes it seem like docker is trying to use the wrong version of the haskel compiler. is there a way to install an older version of the compiler?
17:15:01 <jayyy> https://paste.mod.gg/ejipizaluv.coffeescript
17:15:09 <jayyy> docker file for reference ^^}
17:34:43 <wglasspoint1> I'm learning to use Haskell with the book learn you a haskell and the video companion course. I have expanded the tictactoe program demonstrated in video #5 to simulate games with 2 computer players. They always end up with the same moves so I want to introuce randomness. My research indicates that System.Random is depreciated, indeed I can't
17:34:44 <wglasspoint1> import it in ghci. What is the best way to generate a random value (preferably a number) in haskell?
17:35:50 <wglasspoint1> Thank you for any tips anyone can provide I've tried using the package `mwc-random` but it results in import issues that lead me to believe there must be a better way
17:45:28 <incertia> anyone able to help me with some weird polysemy type magic?
17:45:56 <incertia> if i concretize my type inferencing works as expected but if i relax the type signature with `Member` things break
17:48:00 <incertia> with main' :: Sem '[MyProgram, Error MyError, Embed IO] (), i get: main' & interpretMyProgram & runError & runM :: :: IO (Either MyError ())
17:48:53 <incertia> whereas with main' :: (Members '[MyProgram, Error MyError] r) => Sem r (), the type of main' & interpretMyProgram & runError & runM is some random bullshit that refuses to typecheck
17:49:49 <keklel> hi guys
17:49:53 <keklel> what about haskell?
17:54:20 <dmwit> Some impatient folks tonight.
18:08:48 <incertia> seems like it's a thing that the plugin is able to do for me
18:51:00 * hackage conferer-warp 0.1.0.2 - conferer's FromConfig instances for warp settings  https://hackage.haskell.org/package/conferer-warp-0.1.0.2 (ludat)
18:51:04 <sim590> So I have a cool function which asks for a password forever until it's valid https://paste.debian.net/1104588/. It's cool and all, but what if I want to say "Hey your password is bad, try again". I would need something else other than `guard` function. I want to avoid returning explicitly Nothing in the wrong case since the monad could do that for me.
18:52:00 * hackage conferer-provider-json 0.1.0.4, conferer-hspec 0.1.0.2, conferer-snap 0.1.0.4 (ludat)
18:53:00 * hackage conferer-provider-json 0.1.0.5 - conferer's provider for reading json files  https://hackage.haskell.org/package/conferer-provider-json-0.1.0.5 (ludat)
18:54:09 <dmwit> sim590: The quick hack is `askPassphrase : repeat (lift (putStrLn "hey your password is bad") >> askPassphrase)`.
18:55:16 <sim590> dmwit: Oh right!! Outside of the function. True. That's good.
18:56:16 <dmwit> Also, enforcing a maximum length on passwords is a violation of intergalactic law.
18:56:49 <sim590> dmwit: I didn't know about that organization. ;)
18:56:58 <shachaf> I enforce a maximum length of 1TB on all passwords.
18:57:21 <mycroftiv> my passwords is archive.org. no not "archive.org". the binary string of their current collection
18:58:00 * hackage simple-cabal 0.1.1 - Cabal file wrapper library  https://hackage.haskell.org/package/simple-cabal-0.1.1 (JensPetersen)
18:58:34 <sim590> dmwit: but what if I want to keep the password logic inside the function and not put it outside.
19:00:24 <sim590> Plus I don't want to print "Your password is bad" before asking the first time. That's rude.
19:00:57 <dmwit> My solution does not print "Your password is bad" before asking the first time.
19:02:00 <sim590> Oh. So that's the `:` I missed.
19:02:12 <dmwit> I didn't respond to "inside the function", because I don't understand it.
19:03:09 <sim590> dmwit: I mean inside the askPassphrase function. I want to put the string about having bad password inside the askPassphrase description as it lets me keep things logically linked together if that makes sense
19:03:25 <dmwit> So put it in there. What's the problem?
19:04:20 <sim590> I don't know what to put instead of "guard"
19:04:25 <sim590> To display a message.
19:04:41 <dmwit> Why don't you do it exactly how I showed you?
19:04:53 <dmwit> You can name the action I showed you if that matters to you. That's the whole point of referential transparency.
19:05:55 <sim590> OK, may be I didn't understand correctly your solution. Let me try to make it work and play with it. But ideally, I wouldn't want the string about errors to be inside the definition of "main", but inside the definition of "askPassphrase"
19:05:56 <dmwit> complainAndAskPassphrase = lift (putStrLn "hey bad") >> askPassphrase
19:06:00 * hackage hkgr 0.2.4 - Simple Hackage release workflow for package maintainers  https://hackage.haskell.org/package/hkgr-0.2.4 (JensPetersen)
19:08:42 <ddk> which companies are using Cloud Haskell in Production ?
19:09:00 * hackage dbus 1.2.10 - A client library for the D-Bus IPC system.  https://hackage.haskell.org/package/dbus-1.2.10 (blaze)
19:11:26 <sim590> dmwit: You mean to create a loop by calling recursively the function, right? Then I don't need repeat in the main.
19:14:04 <sim590> dmwit: But I don't want to have to write `Nothing` inside askPassphrase. I would like the monad to implicitely run my action (putting the string to stdout about the error) in case `Nothing` is to be returned..
19:14:34 <rotaerk> hmm what do you guys do when your build process includes more than just cabal build?  e.g. I have some GLSL shaders to compile into SPIR-V shaders, and I want the resulting SPIR-V shaders to be in some subfolder relative to the cabal-built binaries
19:16:35 <sim590> I have written some comments explaining what I mean: https://paste.debian.net/1104602/.
19:17:00 * hackage dbus 1.2.11 - A client library for the D-Bus IPC system.  https://hackage.haskell.org/package/dbus-1.2.11 (blaze)
19:17:21 <dmwit> sim590: What don't you like about my complainAndAskPassphrase?
19:18:29 <sim590> dmwit: Do you write it inside "main" ? If so that's what I don't like.
19:18:42 <dmwit> rotaerk: build-type: Configure?
19:18:49 <dmwit> sim590: No, I don't.
19:19:11 <dmwit> And even if I did, you don't have to just because I do.
19:20:03 <sim590> dmwit: Where would I call complainAndAskPassphrase ?
19:20:18 <sim590> I'd prefer complaining from inside "askPassphrase" not from "main".
19:21:24 * dmwit shrugs
19:21:30 <dmwit> The less quick hack involves writing your own loop.
19:21:31 <dmwit> Your call.
19:22:02 <dmwit> If you're willing to write your own loop, ExceptT is the big brother to MaybeT that lets you report a message.
19:22:19 <rotaerk> dmwit, hmm... thanks
19:22:31 <sim590> I thought that may be there was just a way I could write something else other than the `guard` which just exits with `Nothing`. It thought may be I could write an action before quitting with a function equivalent to `guard`.
19:22:58 <sim590> dmwit: Oh. May be that's what I was looking for. I will look at this.
19:23:27 <dsal> :t when -- sim590 
19:23:28 <lambdabot> Applicative f => Bool -> f () -> f ()
19:24:01 <sim590> dsal: Yes! I think that's waht I saw once in another exercise I did.
19:32:04 <sim590> So `when` actually does what I wanted at first. The only annoying thing is that I'm calling "isValid" twice (once for `when` and once for `guard`).
19:33:13 <dsal> Why do you need guard?
19:33:36 <sim590> dsal: To exit if it's `Nothing`.
19:33:44 <sim590> Oh
19:33:50 <sim590> Yeah I don't need it.
19:33:52 <sim590> lol
19:34:10 <sim590> dsal: thanks.
19:34:38 <sim590> Actually.
19:34:45 <sim590> Now I need it for the reason I mentionned.
19:34:57 <sim590> If the passphrase is bad, I don't want to return the passphrase, but `Nothing`.
19:41:23 <crestfallen> hi on lines 5,6, 5 I believe is clear because g after f, then h, so that is a->b , b->c, c->d . But the application order on line 6 seems like the precedence of (h . g) would not have an 'a' for f.        https://paste.debian.net/1104605/
19:42:40 <shachaf> h . (g . f) and (h . g) . f are equal and have the same type.
19:43:11 <shachaf> I don't think the rest of that document makes sense. Certainly "=" is used with some bizarre meaning.
19:43:39 <crestfallen> it seems like it would be b->c, c->d then f would need an 'a' :  f = a->b 
19:43:42 <crestfallen> shachaf, 
19:43:57 <shachaf> The words you're saying also don't make sense.
19:44:07 <shachaf> I recommend being very careful and verbose.
19:44:50 <glguy> It's dangerous to go alone, take a towel
19:45:10 <crestfallen> so if we compose h after g, we have b->c -> (c->d), right?
19:45:29 <crestfallen> on line 6
19:46:40 <shachaf> You're continuing to say things that don't make sense. What do those arrows mean?
19:46:50 <ddk> do you know about companies are using `Cloud Haskell` in Production, currently  ?
19:47:15 <shachaf> Here are the kinds of statements you could be making that would make sense to me: "the type of f is a -> b; the type of g is b -> c; therefore the type of g . f is a -> c"
19:47:27 <shachaf> Here "->" means the type of  function and nothing else.
19:47:27 <crestfallen> (h . g) on line six means "h after g," right?
19:48:05 <crestfallen> ok, let me put it this way:
19:48:21 <crestfallen> the way I read (h . g) . f   is:
19:48:27 <shachaf> "after" is an English word that you'll need to define if you want to use it. I recommend not using it.
19:49:01 <rotaerk> (h . g) x = h (g x)
19:49:05 <crestfallen> b->c->c->d->a->b , which seems wrong
19:49:57 <crestfallen> shachaf, I read that (h . g) may be read: h after g
19:49:58 <shachaf> That doesn't seem right or wrong to me.
19:50:17 <shachaf> You'll have to explain what it means, if you want to write something like that. What do those arrows mean?
19:50:24 <shachaf> (But I recommend not writing anything like that.)
19:50:45 <shachaf> You can pronounce "." as "after" if you like, but that doesn't change anything.
19:51:20 <rotaerk> I don't think you should get hung up on how-to-say the various elements of your code
19:51:28 <rotaerk> you shouldn't be reading code aloud in general anyway
19:52:10 <crestfallen> forget about that. I'm saying that when I try to write out the composition using -> "morphisms," I don't get a -> b -> c -> d
19:52:59 <crestfallen> from (h . g) . f
19:53:41 <shachaf> You're saying thing like "a -> b -> c -> d" but you're not saying what they mean.
19:53:43 <rotaerk> I don't know what it means to "write out the composition using -> morphisms", myself
19:54:18 <rotaerk> when I see a -> b -> c -> d, I see (casually speaking) a 3-parameter function
19:54:21 <shachaf> You should explain what that means, if you're saying it. It sure looks from here like you're just stringing together symbols randomly.
19:54:45 <crestfallen> thanks let me sort it out
19:55:55 <crestfallen> please look at the entire document, about 1/3 down this paste https://termbin.com/3p3em
19:56:44 <crestfallen> where it says Consider:   shachaf rotaerk 
19:57:42 <shachaf> Did you write that or copy it from a book or something?
19:58:36 <crestfallen> notes from a video I watched that I wrote
19:58:55 <rotaerk> I think "a -> b -> c" just means a function (or generally, an arrow) from a -> b composed with another from b -> c
19:59:07 <rotaerk> and thus a -> b -> c = a -> c
20:00:04 <rotaerk> I think i understand the "consider" section
20:00:32 <crestfallen> very sorry I must leave a cafe. I'll be on later in about 45 mins.  thanks kindly rotaerk shachaf 
20:15:55 <rotaerk> dmwit, reading about cabal build types ... did you mean build-type: Custom?
20:17:13 <rotaerk> Configure seems to be for ... system-dependent stuff
20:33:14 <dmwit> No, I meant Configure. Custom is usually too much work to be worth the trouble.
20:33:54 <dmwit> I'd be very surprised if the thing you described doesn't fit smoothly into the standard configure-then-make recipe.
20:35:25 <rotaerk> hmm k
20:36:33 <dmwit> Remember: configure is a shell script. It can do anything.
20:36:39 <dmwit> Including compile your shader or whatever.
20:37:44 <rotaerk> I see
20:41:27 <crestfallen> rotaerk, shachaf you all on? this is the same paste: https://termbin.com/by6y
20:41:42 <crestfallen> I'm a bit flustered
20:41:45 <rotaerk> I'm here
20:41:48 <crestfallen> hi
20:41:53 <rotaerk> what's the question?
20:42:23 <crestfallen> nvim 
20:42:25 <crestfallen> oops
20:45:24 <crestfallen> the question is the same, put differently: if     h . (g .f)    (h . g) . f    are equivalent, how can there be precedence with (h . g) ?
20:46:32 <rotaerk> what do you mean? Are you referring to where it says "Parentheses take precedence." ?
20:46:33 <dmwit> They are extensionally equal -- that is, as functions, when given any particular input, they both compute the same output -- but intentionally different -- that is, the way the computer performs the computation is different for the two.
20:47:13 <crestfallen> ok thanks so...
20:47:20 <dmwit> Like, think of `\x -> x + x` and `\x -> x * 2`. They'll both get to the same place, they just get there in different ways.
20:47:39 <dmwit> (For a sensible Num instance, and yadda yadda.)
20:48:41 <dmwit> (Hm, is it spelled "intensional"?)
20:49:04 <dmwit> (Wikipedia says yes.)
20:49:43 <crestfallen> see if you were to say : " (h after g) after f " , that would make sense and give a -> b -> c -> d
20:49:57 <crestfallen> correct?
20:50:36 <crestfallen> but then how does that connote precedence of (h . g) ?
20:51:18 <crestfallen> rotaerk, yes that's what I was referring to, thanks
20:51:39 <rotaerk> that just means you do the composition inside the parentheses first
20:52:08 <rotaerk> but because it's associative, you get the same result regardless of whether you do `h . (g . f)` or `(h . g) . f`
20:52:34 <rotaerk> (extensionally)
20:53:45 <incertia> if you want to see it more clearly just write it at a point
20:54:05 <incertia> (h . (g . f))(x) = h(g(f(x))) = ((h . g) . f)(x)
20:57:10 <crestfallen> so it actually *is* read (h after g) after f, I believe
20:57:15 <crestfallen> incertia, 
20:57:29 <incertia> you are free to read it that way
20:57:32 <dmwit> I don't know the "give" relation.
20:57:45 <incertia> i come from a math background so my head just says compose
20:57:45 <dmwit> "(h after g) after f" does not have type a -> b -> c -> d.
20:58:28 <crestfallen> dmwit, that's why I'm having trouble here. 
20:58:41 <incertia> don't think of a -> b -> c -> d as a type
20:58:45 <incertia> just think of it as type flow
20:58:47 <incertia> i guess
20:58:54 <incertia> you go through f which turns a -> b
20:59:01 <incertia> then it goes through g which turns b -> c
20:59:01 <incertia> etc
20:59:14 <incertia> the paste seems weirdly written
20:59:38 <crestfallen> how would you write the notes below the 2 compositions in question?
21:00:17 <crestfallen> incertia, ^
21:00:56 <rotaerk> yea this `a -> b -> c -> d` notation has nothing to do with haskell's notation that looks the same
21:01:19 <MarcelineVQ> One would probably need to see the relevant parts of the video the notes are about
21:01:56 <crestfallen> hmm
21:02:01 <MarcelineVQ> If you're asking how to write the notes
21:04:20 <crestfallen> thanks all. one last thing. so this is not the same as f :: (a -> b), g :: (b -> c) etc?
21:04:27 <rotaerk> crestfallen, what "notes" are you talking about?
21:04:52 <crestfallen> rotaerk, essentially the note about parens take precedence
21:05:31 <rotaerk> that note is silly; I would just omit it.  the whole point of parentheses in expressions is to override precedence
21:05:50 <crestfallen> interesting
21:05:54 <crestfallen> ok
21:06:13 <MarcelineVQ> One part that jumps out as odd is "Two composable morphisms have arrows where the end of one is the beginning of the other: a -> b -> c = a -> c" This doesn't show two morphisms where the end of one is the beginning of the other. a -> b, b -> c would show two morphisms where the end of one is the begining of the other. Which when composed can give you a -> c
21:07:11 <rotaerk> and yes, in haskell `f :: a -> b` means f is a function from a to b.  and `f :: a -> b -> c` is equal to `f :: a -> (b -> c)` which means f is a function from a to (b -> c).  (i.e. it returns a function from b -> c, given an a)
21:07:12 <crestfallen> thanks MarcelineVQ that might be a typo on my part, but I was very particular about these notes iirc 
21:07:28 <rotaerk> which is different from the notation in this text
21:08:27 <crestfallen> btw this is bartosz milewski who I usually follow fairly well
21:08:38 <rotaerk> in this text, a -> b -> c is equivalent to a -> c, but where the intermediate transformations are explicit
21:09:01 <rotaerk> and haskell types don't do that
21:09:56 <crestfallen> rotaerk, explicit as in (a -> b) -> (b -> c)
21:10:58 <rotaerk> in haskell if you have `f :: a -> b` and `g :: b -> c`, then `g . f :: a -> c`.  *not* `g . f :: a -> b -> c`
21:11:16 <crestfallen> copy that thank you
21:11:22 <rotaerk> as a -> b -> c means something different
21:12:27 <crestfallen> ok h(g(f x)) it is then
21:12:47 <MarcelineVQ> What video are these notes from?
21:13:32 <crestfallen> bartosz milewski. he is chit-chatty so it could be that is how the lecture was transcribed by yours truly
21:14:04 <MarcelineVQ> What partcular video are these notes from?
21:14:29 <crestfallen> that I would have to get back to you on
21:14:58 <crestfallen> like in sweden or norway or someplace
21:15:15 <MarcelineVQ> I'm just asking for the video name :>
21:15:32 <crestfallen> I was reviewing these old notes
21:16:46 <rotaerk> are you saying you wrote these notes during a live talk by this person, and not while watching a video?
21:17:19 <crestfallen> no its a video (I've never been to norway but have been to sweden) :)
21:17:30 <rotaerk> where is this video? is it online?
21:17:39 <rotaerk> i.e. how could we watch it
21:17:52 <crestfallen> let me find it. youtube for certain
21:18:04 <crestfallen> he has many videos
21:18:51 <crestfallen> the notation is category theory so it could be I mixed it up with haskell notation. not surprising
21:26:37 <rotaerk> crestfallen, just FYI, that's what Marceline was trying to ask for :P  wasn't asking about the location where the video was filmed
21:27:05 <Welkin> which camera did you use to film it?
21:28:47 <crestfallen> rotaerk, yeah I know but sweden or norway may have been in the conference title on the video, so I mentioned it
21:29:10 <crestfallen> it was like a functional programming conference
21:29:25 <crestfallen> lamba days maybe ?
21:29:31 <crestfallen> lambda
21:29:36 <rotaerk> if you don't remember, that's fine
21:29:48 <crestfallen> thanks for the help
21:30:04 <crestfallen> Welkin, it was a 8mm
21:45:35 <jsomedon> if I am writting Maybe as an Applicatives, should `pure` be `pure = Just` or `pure _ = Nothing`?
21:47:38 <jsomedon> in terms of type check, both work right?
21:48:09 <dmwit> Both typecheck fine.
21:48:29 <dmwit> The Applicative laws will rule out one or both implementations, depending on your implementation of (<*>).
21:48:38 <dmwit> (and fmap, I guess)
21:48:41 <jsomedon> oh ok
21:48:45 <Welkin> fmap fmap fmap
21:49:46 <koz_> Welkin: You mean fmap . fmap . fmap amirite? :P
21:50:12 <Welkin> :t fmap fmap fmap
21:50:13 <lambdabot> (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
21:50:17 <Welkin> :t fmap . fmap . fmap
21:50:18 <lambdabot> (Functor f1, Functor f2, Functor f3) => (a -> b) -> f1 (f2 (f3 a)) -> f1 (f2 (f3 b))
21:50:48 <Welkin> :t fmap `fmap` fmap `fmap` fmap
21:50:49 <lambdabot> (Functor f1, Functor f2, Functor f3) => (a -> b) -> f1 (f2 (f3 a)) -> f1 (f2 (f3 b))
21:50:53 <Welkin> :D
21:57:58 <incertia> oh the wonders of functors
22:00:21 <Welkin> you can use them in a box, with a fox, in your socks
22:00:24 <Welkin> and your burritos too
22:00:33 <jsomedon> dmwit: just checked what Applicatives laws are and looks like `pure _ = Nothing` will break the id preservation law?
22:01:51 <jsomedon> dmwit: oh and my <*> is `Nothing <*> _ = Nothing`
22:02:45 <jsomedon> dmwit: and `(Just f) <*> ma = fmap f ma`
22:02:51 <dmwit> I expect `pure f <$> x = fmap f x` will not be satisfied by `pure _ = Nothing` and any sensible `fmap`.
22:03:11 <dmwit> `pure f <*> x = fmap f x`, I mean.
22:04:18 <jsomedon> dmwit: is that one of 4 Applicative laws..?
22:06:24 <shachaf> Hmm, the Applicative laws aren't very nice, are they.
22:06:36 <shachaf> I bet they're nicer with other formulations of Applicative.
22:06:58 <jsomedon> I am too noob to figure out if the laws are nice or not haha
22:08:21 <dmwit> The documentation claims it is a consequence of the laws.
22:08:40 <dmwit> I suspect this fact depends on parametricity, though.
22:09:37 <jsomedon> I see
22:13:18 <shachaf> Yes, with parametericity you can show that two Functor instances must be equal.
22:13:29 <shachaf> (With some caveats.)
22:15:27 <jle`> jsomedon: i like to think of the applicative laws in terms of how they merge effects together w.r.t *>/<*>/etc., and most of the laws in the formulation (or the liftA2 (,)-based ones) can come from it
22:16:04 <jle`> jsomedon: basically the principle is that the 'effects' of (x *> y) *> z should be the same as the effects of x *> (y *> z), and using pure with *>/etc. should not change effects
22:16:26 <jle`> so *>/etc. become a monoidal action (associative, and with identity generated by pure)
22:16:28 <shachaf> What's the nicest way to phrase the Applicative laws?
22:16:45 <shachaf> I bet "unit/mult" and "lift0/lift2" are about equally nice.
22:17:00 <jle`> this way of looking at them, we don't care about the 'result values', only the effects. but the result values will be preserved no matter what because of parametricity
22:17:33 <jle`> shachaf: i believe the two aren't too different, yeah; the main difference is how they handle talking about the 'values inside'
22:17:37 <jle`> the result values themselves
22:17:49 <jle`> which i think is largely irrelevant ... because that stuff sorts itself out with parametricity
22:18:01 <jle`> the unit/mult way at least has a cleaner way of talking about result values
22:18:47 <jle`> that is, instead of thinking about functions and function application, think instead of tuples and units.  although i guess that's not necessarily cleaner, maybe just more accessible
22:19:27 <jsomedon> jle`: 1. is `*>` a function? 2. I see on my book it mentions "effectful programming" soon and I didn't read it yet, I am guessign if the term means side effect?
22:19:41 <jle`> basically different book-keeping required to talk about reuslt values neatly
22:19:48 <jle`> jsomedon: yeah, (*>) :: f a -> f b -> f b
22:19:59 <shachaf> Hmm, you can define fmap in terms of lift0/lift2, and not in terms of unit/mult.
22:20:39 <jle`> jsomedon: i'm using (*>) instead of (<*>) so we don't have to worry about the types of the result values (the a's and b's)
22:20:39 <shachaf> What are the actual laws? For unit/mult I assume you have left/right identity and associativity; is that it?
22:21:01 <jle`> that's it, modulo fmaps of tuple reshuffling
22:22:15 <shachaf> And for lift0/lift2?
22:22:18 <shachaf> I guess I should work it out.
22:22:45 <sami> bnjour
22:22:46 <jle`> i believe all of the law reformulations are just left/right identity and associativity, with just different fmappings to massage the types of result values
22:23:06 <jsomedon> jle`: uhm.. so is that *> function part of some class?
22:23:37 <nshepperd1> . o O (writing the applicative laws with ApplicativeDo?)
22:24:00 <jle`> jsomedon: x *> y = flip const <$> x <*> y
22:24:20 <jle`> jsomedon: it's just <*>, but you ignore the result of the first thing
22:25:01 <jle`> the 'result' here as in, the 'result' of the action x or y.  for example 'getLine *> getLine' will sequence getLine twice, but the final result will be the result of the second getLine
22:25:51 <jle`> ( try it out on ghci :) )
22:26:26 <jsomedon> I didn't even know *> exists
22:26:38 <jsomedon> until I just :t on it
22:26:40 <jle`> it's useful when you care about the 'effects' of an action, but not its results
22:26:52 <jle`> it's actually the main building block of do notation
22:26:58 <jle`> do x; y; z => x *> y *> z
22:27:01 <jle`> s/the main/one of the main
22:27:06 <Welkin> that's >>
22:27:10 <jsomedon> cool
22:27:10 <jle`> ah, you might also recognize it as its more popular name, (>>)
22:27:42 <jsomedon> do you guys mean it has two names, >> and *>
22:27:55 <jle`> jsomedon: so when you write `main = do putStrLn "hi"; putStrLn "bye"; putStrLn "ok"`, that's sugar for putStrLn "hi" *> putStrLN "bye" *> putStrLn "ok"
22:28:03 <jle`> jsomedon: (>>) = (*>)
22:28:22 <jsomedon> jle`: I :t on both and types look different though
22:28:25 <jle`> so you might see it in a lot of haskell tutorials, but people might refer to it as (>>) instead of (*>), for historical reasons
22:28:29 <jle`> :t (>>)
22:28:30 <lambdabot> Monad m => m a -> m b -> m b
22:28:33 <jle`> :t (*>)
22:28:34 <lambdabot> Applicative f => f a -> f b -> f b
22:28:47 <jle`> :t [(>>), (*>)]
22:28:47 <jsomedon> so one is monad the other is f?
22:28:48 <lambdabot> Monad m => [m a -> m b -> m b]
22:29:02 <rotaerk> is there some documentation on how to write the "configure" file used by build-type: Configure?  I wrote one that compiles my shaders in shaders/ and puts the results into shaders/spv/, and when I run it directly it works.  but when cabal runs it, it seems to be relative to a subfolder within dist-newstyle ... so I'm not sure how I should be writing this
22:29:05 <jle`> jsomedon: one is only for Monads, but the other works for all Applicatives
22:29:16 <jle`> jsomedon: "one is Monad the other is Applicative"
22:29:29 <jle`> the choice of variable names is kind of weird here, but remember that the variable name doesn't matter
22:29:38 <jle`> you can think of the type of (>>) as Monad f => f a -> f b -> f b
22:29:45 <jle`> and the type of (*>) as Applicative f => f a -> f b -> f b
22:29:50 <jsomedon> jle`: ok gotta get myself solid on Applicatives before I read chapter on Monad thouh.
22:29:58 <jle`> the actual type variable name doesn't matter
22:30:18 <jle`> jsomedon: yeah, i'm just making the connection in case you have ever heard of (>>), then you had already heard of (*>) basically
22:30:29 <jsomedon> yes type matters most
22:31:01 <jsomedon> uhm about the effect and result, you mentioend above
22:31:08 <jle`> but if you haven't heard of (>>) before, then ignore what i said about it :)
22:32:15 <jsomedon> didn't hear about >> ( *> neither haha) but good to know I think
22:32:36 <jsomedon> so the effect and result, what do you really mean by these two terms/concept ?
22:33:19 <jle`> ah. well, many Applicative instances come with a particular 'interpretation' of effect and results, which guide how you can think of how the Applicative instance works on values of that type
22:33:48 <jle`> every type is different in how it interprets what an effect and a result is, but if you nail down this specific interpretation for a specific type, it helps you understand what its Applicative instance does
22:34:21 <jsomedon> so let's say it's Maybe type
22:34:24 <jle`> for example, for IO: for a value of type `IO Int`, it describes some I/O action as its effects, and as the result of executing those effects, would generate a result of type Int 
22:34:48 <jle`> so for `getLine :: IO String`, its I/O action/effect is "get a line from stdin", and its result is the line that it gets
22:35:17 <jsomedon> ah so result is the value "contained"
22:35:18 <jle`> for Maybe, the 'effect' is short-circuiting failure, and the 'result' is the value you would get on a success
22:35:30 <jle`> jsomedon: not necessarily 'contained', because remember IO doesn't 'contain' any values of its result type in it
22:35:40 <jle`> it's like a recipe: it only contains a description on how you would produce a value of that result type
22:36:06 <jsomedon> that's interesting way to think
22:36:07 <jle`> so for IO, the result type abstractly refers to the value the IO action is describing how to construct, using I/O
22:36:21 <jle`> for Maybe, then you can think of it as the value 'contained' in the case that your computation is succesful
22:36:49 <jsomedon> I like your recipe metaphore
22:37:02 <jle`> so for `Maybe Int`, this represents some computation that might fail, which would produce an Int in the case that it succeeds
22:37:18 <jle`> note that this isn't the "only" way to interpret Maybe Int, as a type
22:37:29 <jle`> but it's just the specific way that makes sense with its Applicative instance in specific
22:37:51 <jle`> so it's one way of looking at Maybe that gives semantic meaning to its Applicative instance 
22:37:57 <jsomedon> so what other crazy interpretation do people have on Maybe?
22:38:52 <jle`> for Maybe, nothing too much different from this :) but for a lot of other Applicative values, its applicative 'interpretation' is very different from normal interpretations of that type
22:38:57 <jle`> one example is [], lists
22:39:21 <jle`> lists people usually just think of an ordered containers of values, but you can interpret it as representing effects/results in a way that gives meaning to its Applicative instance
22:40:17 <jle`> jsomedon: so if we look at Maybe, and think of its 'effect' as success vs. failure, then we cna now interpret what (*>) 'has' to do
22:40:40 <jle`> namely, the Just-or-Nothing status of x *> (y *> z) has to be the same as the Just-or-Nothing status of (x *> y) *> z
22:40:56 <jle`> and, pure blah *> x, should have the same Just-or-Nothing status as 'x' alone
22:41:04 <rotaerk> dmwit, I'm not clear on 1) how to make it actually run the configure script every time I build, and 2) how my configure script can know where to find the input shader files (because it's trying to put them into a subfolder of dist-newstyle instead of relative to package root)
22:41:05 <jsomedon> ah
22:41:06 <jle`> and x *> pure blah should have the same Just-or-Nothing status as 'x' alone
22:41:15 <jle`> basically, exactly the Monoid laws
22:41:32 <rotaerk> (and it's trying to read the shaders' source from a subfolder of dist-newstyle)
22:41:43 <jle`> now, we don't say anything about the actual 'results' of pure blah *> x, x, and x *> pure blah.  that's going to be different for each one
22:42:05 <jle`> but we can reason, at least, with the *effects*: i can tell you if all of them will be Just or Nothing, just by knowing if x is Just or Nothing
22:42:42 <dmwit> rotaerk: What is the "it" in "it's trying to read the shaders' source from a subfolder"?
22:42:58 <rotaerk> the configure script
22:43:00 <jle`> (because we interpreted the 'effect' of Maybe as Just-or-Nothing, success-or-failure)
22:43:09 <dmwit> rotaerk: Aren't you in control of what the configure script does?
22:43:17 <rotaerk> http://ix.io/1XEd
22:43:42 <jle`> so the Applicative laws can be stated as this: the effects of x *> (y *> z) has to be the same as teh effects of (x *> y) *> z: sequencing effects is associative
22:44:12 <rotaerk> dmwit, I have it trying to pull shader source from the shaders/ folder, compile them, and put the results into shaders/spv/.  when I run this manually, it works.  but when cabal runs it, the PWD is different
22:44:19 <jle`> and, the effects of pure r *> x has to be the same as the effects of x *> pure r, which all have to be the same as the effects of just 'x' (*> has an identity with pure)
22:44:28 <jle`> *sequencing has an identity with pure
22:44:30 <dmwit> rotaerk: dump stuff into extra-source-files, probably
22:44:56 <rotaerk> I added shaders/*.frag and shaders/*.vert into that already
22:45:25 <dmwit> But they are not available next to the configure script when it runs?
22:45:34 <shachaf> The vertical shaders and the fragrance shaders.
22:46:25 <rotaerk> the shaders folder is right next to the configure script, in my project root
22:47:32 <rotaerk> when configure is run by cabal, the PWD is dist-newstyle/build/x86_64-linux/ghc-8.6.5/sandbox-0.1.0.0/build
22:47:56 <rotaerk> a shaders folder exists within that, but it's empty
22:48:19 <rotaerk> except it contains a spv folder (which configure created), but that's also empty
22:48:40 <jle`> jsomedon: under this interpretation we really can't directly rule out pure _ = Nothing, buuuut as soon as we make any implementation of (*>), it will uniquely determine our pure implementation
22:48:51 <jle`> jsomedon: just like how for monoids, as soon as you define (<>), it uniquely determines mempty
22:48:54 <rotaerk> the reason it's empty is because the .vert and .frag files aren't there
22:50:12 <rotaerk> (putting them in extra-source-files doesn't get them copied over)
22:53:17 <rotaerk> basically, my configure script is generating stuff in that dist-newstyle/*/build folder, but it's unable to *read* the source files (how does it know where they are?)
22:56:33 <rotaerk> and then there's the problem of getting it to actually run the configure whenever I build... I may have to use build-type Custom just to get something running during build rather than configure
22:57:55 <dmwit> That seems a bit strange to me. I'm looking at http://hackage.haskell.org/package/X11-1.9.1/src/X11.cabal right now, which uses build-type: Configure.
22:58:23 <dmwit> I know its configure script needs the configure.ac and *.in files available next to the configure script when it runs.
22:58:28 <dmwit> So I wonder what it's doing that you aren't.
22:58:28 <rotaerk> oh cool, an example
23:06:16 <jsomedon> jle`: been re-reading your comments several tiems and I am confused why effect of x *> (y *> z) should be same as effect of (x *> y) *> z, can I prove this from Applicatives laws?
23:06:43 <shachaf> Yes, you can prove it.
23:07:46 <Welkin> (*>) x ((*>) y (*>) z) == ((*>) x (*>)) y (*>) z
23:07:50 <Welkin> it reduces to the same expression
23:07:54 <jle`> jsomedon: my claim is that these "are" an alternative version of the applicative laws, not necessarily that they can be proven from the one in base.  but proving them from base can be tricky because it doesn't ever actually explicitly mention 'effects'
23:08:04 <jle`> but in this case we have a stronger equivalence than equivalence of effects
23:08:08 <dmwit> Welkin: No, it is not the same expression.
23:08:18 <jle`> the laws in base actualyl demand x *> (y *> z) is actualyl literally equal to (x *> y) *> z
23:08:21 <Welkin> oops, one extra in there
23:08:51 <jle`> hm, i did the same typo twice there somehow
23:09:04 <jsomedon> haha
23:09:27 <jle`> actually i think my equalities there can be interpreted as literally equal. x *> (y *> z) == (x *> y) *> z
23:09:39 <jle`> pure r *> x == x
23:09:45 <jle`> x <* pure r == x    (note, using <* there instead)
23:10:11 <jsomedon> uh
23:10:27 <jsomedon> so haskell has <* too..
23:10:40 <jle`> see if you can guess what it does :)
23:10:49 <jsomedon> well I just :t on it so..
23:10:58 <jle`>  :t doesn't quite tell the whole picture
23:11:27 <jle`> both *> and <* are basically "sequence these", the difference is which 'result' value is kept in the final answer
23:12:20 <jle`> try it in ghci: getLine *> getLine, vs. getLine <* getLine
23:12:27 <jle`> > Just 3 <* Just 10
23:12:29 <lambdabot>  Just 3
23:12:30 <jle`> > Just 3 *> Just 10
23:12:32 <lambdabot>  Just 10
23:12:48 <jsomedon> by looking at their types and what you said above, I would say *> keeps right Applicative's result adn <* keeps left's
23:13:04 <jsomedon> interesting names though
23:13:24 <jsomedon> so in that sense, <*> means keep right and left's result??
23:15:02 <Welkin> no
23:15:08 <Welkin> :t (*>)
23:15:09 <lambdabot> Applicative f => f a -> f b -> f b
23:15:11 <Welkin> :t (<*>)
23:15:13 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
23:15:13 <dibblego> I tend to think of them as: (<*>) is function application, (<*) is const id and (*>) is const, all with an Applicative effect
23:19:49 <jle`> jsomedon: you can sort of think of it that way, yeah, keep the result of both left *and* right
23:19:52 <jle`> and combine them using ($)
23:21:07 <dibblego> and yeah, "the spaceship wing points to the thing to keep"
23:22:35 <jsomedon> ha spaceship
23:25:10 <jsomedon> jle`: yeah that makes perfect sense of "keeping result"
23:30:05 <rotaerk> dmwit, looks like the configure of the X11 package is doing work to find the source direcctory
23:30:19 <rotaerk> starting at the:  # Find the source files, if location was not specified
23:30:21 <dmwit> That's unfortunate.
23:31:52 <dmwit> This is unreadable.
23:31:58 <rotaerk> that's bash for you
23:32:47 <rotaerk> I'll look into Custom, since I need to trigger this on build anyway
23:32:53 <dmwit> Good luck.
23:33:00 <rotaerk> only way I've found to do it with Configure is to `cabal clean` and then re-build
23:33:22 <rotaerk> thanks for the help
