00:02:16 <cal[m]> so i have just recently started haskell stuff
00:02:41 <cal[m]> i built pascal's triangle in the language, and i was wondering if one of you got a moment, if you'd check it out and tell me what i could have done differently
00:02:48 <cal[m]> link: https://gist.github.com/calware/75cf54c493765b5aba90089cc3f930eb
00:09:42 <lavalike> > iterate ((\xs -> [1] ++ xs ++ [1]) . (zipWith (+) <*> tail)) [1]
00:09:45 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
00:10:26 <Axman6> cute
00:11:19 <cal[m]> oh cool that does work
00:11:19 <cal[m]> very cool
00:12:09 <cal[m]> so instead of giving me one-liners or calling it cute, could one of you maybe tell me if there are structural changes i should have made?
00:12:49 <cal[m]> if i should have thought about writing some function differently etc
00:13:33 <Axman6> [prev !! i | i <- [1..((length prev) - 1)]] feels odd, and I'm struggling to understand it
00:14:11 <Axman6> yeah that's just a very expensive way to write init I think
00:14:59 <cal[m]> is there a less convoluted solution?
00:15:04 <cal[m]> for what that line achieves
00:15:12 <Axman6> > let prev = 1,2,3,4,5] in [prev !! i | i <- [1..((length prev) - 1)]]
00:15:14 <lambdabot>  <hint>:1:13: error: parse error on input ‘,’
00:15:18 <Axman6> > let prev = [1,2,3,4,5] in [prev !! i | i <- [1..((length prev) - 1)]]
00:15:20 <lambdabot>  [2,3,4,5]
00:15:27 <Axman6> oh that's just tail
00:15:43 <Axman6> > let prev = [1,2,3,4,5] in tail prev
00:15:45 <lambdabot>  [2,3,4,5]
00:16:03 <Axman6> indexing lists in Haskell is something we almost never do
00:16:14 <cal[m]> really
00:16:15 <cal[m]> damn
00:16:17 <Axman6> It has probably been years since I used (!!)
00:16:25 <cal[m]> oh wow
00:16:28 <cal[m]> okay, that is very good to note then
00:16:58 <cal[m]> i can think of a lot of situations where i'd need to index into a list like that, what do you do instead?
00:17:05 <cal[m]> or how would you think about it instead
00:17:37 <Axman6> iterate over the list (or use one of the many function we have for doing that for you)
00:18:01 <Axman6> so you can just use newRow = zipWith (+) prev (tail prev) in this case - tail isn't safe, but the way you're using it it is
00:18:10 <Axman6> you can also just use drop 1 tail to be more safe
00:18:20 <Axman6> > drop 3 [1,2,3,4,5,6]
00:18:22 <lambdabot>  [4,5,6]
00:18:27 <Axman6> > drop 1 [1,2,3,4,5,6]
00:18:29 <lambdabot>  [2,3,4,5,6]
00:18:33 <Axman6> > drop 1 []
00:18:34 <lambdabot>  []
00:20:01 <cal[m]> i verified using tail in zip, thank you that was an excellent catch... i shouldn't have gotten so caught up in the logic of that statement
00:20:15 <Axman6> we also almost never use length, since lists can be infinite
00:20:39 <cal[m]> are they ever? in a practical sense
00:20:48 <trcc> So I have import qualified Data.Text.Lazy as TL and I would like to compare x :: TL.Text and "a". But I cannot find a function to do such a check. How do I create TL.Text from "a"? TL.Pack?
00:20:49 <Axman6> yes, all the time
00:21:10 <Axman6> in haskell, lists aren't data structures, they're control flow
00:21:30 <cal[m]> that's very different from the languages i've worked with :)
00:21:35 <Axman6> yes :)
00:22:11 <cal[m]> what did you think about lavalike's solution?
00:22:44 <Axman6> > zipWith (\idx s -> show idx ++ " " ++ s) [0..] ["Hello","world","these","are","some","words"]
00:22:47 <lambdabot>  ["0 Hello","1 world","2 these","3 are","4 some","5 words"]
00:23:26 <Ariakenom> @quote zip`ap`tail
00:23:26 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
00:23:30 <Axman6> I thought it was cute but not very readable, more of a code golf solution. It would have taken me a while to understand it if I hadn't seen the output of it being run
00:24:15 <Axman6> cal[m]: note how above, [0..] is used like you would do for (i = 0; ; i++) in other languages
00:24:17 <cal[m]> i appreciate your feedback
00:24:18 <Ariakenom> :t zip`ap`tail
00:24:19 <lambdabot> [a] -> [(a, a)]
00:24:44 <Axman6> :t zipWith(+)`ap`tail
00:24:45 <lambdabot> Num c => [c] -> [c]
00:25:03 <Axman6> (don't actually use zip`ap`tail unless you want to confuse people)
00:25:24 <cal[m]> and that's a good example of where you might find an infinite list yes?
00:25:36 <Ariakenom> ap is punishable by exile
00:25:47 <Axman6> yes
00:26:16 <Axman6> if you're used to doing for (i in things) { ...} then you're closer to where you need to be to write haskell
00:26:28 <Axman6> indexing is just not a thing we do (because it's slow, O(n))
00:28:16 <cal[m]> if you don't mind my asking: what do you find yourself using haskell for?
00:28:20 <Ariakenom> I don't care much about slow. Working with whole things is easier.
00:28:20 <Axman6> so Apple released a new version of Numbers the other day - this wouldn't normally be something i'd mention in here, but they've changed their calculation engine to use conary coded decimal instead of ieee-754
00:28:35 <cal[m]> thank you again for the help. especially with how to better think about the functions before making them
00:29:02 <Axman6> cal[m]: I write data processing things on AWS at the moment. I've used it for a lot of web services in the past too
00:29:48 <Ariakenom> is that the same as BCD? I thought that was dead
00:29:54 <cal[m]> that sounds like a big job
00:30:05 <Axman6> yes, and me too!
00:31:05 <lavalike> sql is also including bcd in the most recent standard iirc
00:32:17 <Ariakenom> ... but why
00:32:44 <Axman6> more accurate results for a lot of computations humans care about
00:33:01 <Axman6> 10 - 9.8 should be 0.2 and not 0.19999999999999
00:33:20 <Ariakenom> but why BCD over something fraction-based?
00:33:43 <Axman6> probably efficiency - they're specifically using 128bit BCD
00:34:00 <Axman6> or, "128-bit Decimal Floating Point"
00:34:16 <Ariakenom> oh decimal floating point is different
00:34:50 <Axman6> hmm, is that more like out Scientific type?
00:35:18 <Axman6> yes
00:36:01 <Axman6> the article uses the two interchangably, which it probably shouldn't: https://support.apple.com/en-au/HT210179
00:40:51 <cal[m]> hey Axman6 , what did you think of those function declarations? I had a lot of trouble with it
00:41:38 <Axman6> they're fine, your indentation is a bit weird but other than that it's quite readable
00:43:10 <Axman6> [x | ent <- nums, x <- (show ent ++ " " )] is a bit odd, you might want to look at the function unwords:
00:43:13 <Axman6> :t unwords
00:43:14 <lambdabot> [String] -> String
00:43:39 <Axman6> > unwords ["a","b","c"]
00:43:42 <lambdabot>  "a b c"
00:43:48 <Axman6> and map
00:43:54 <Axman6> > map show [1,2,3]
00:43:56 <lambdabot>  ["1","2","3"]
00:44:03 <Axman6> > unwords $  map show [1,2,3]
00:44:05 <lambdabot>  "1 2 3"
00:44:24 <Axman6> printPad is just replicate:
00:44:33 <Axman6> > replicate 3 'a'
00:44:35 <lambdabot>  "aaa"
00:45:13 <Axman6> cal[m]: without changing the list comprehensions, this is how I would lay out that code: https://gist.github.com/axman6/029360216584cd47f36597df04c10c7f
00:46:06 <Axman6> also you should consider separating the code which produces the strings from the code printing them. if build returns [String] then you can just use mapM_ putStrLn to print all the lines
00:46:29 <Axman6> separate your IO from your pure code
00:49:31 <Ariakenom> the post did not mix up decimal floating point and BCD. but it used BCD as a decimal number turned into binary floating point, which is wrong
00:50:08 <Ariakenom> there are appearantly two 128bit decimal float formats
00:51:24 <Axman6> in the same standard no less!
00:51:34 <Ariakenom> they probably use the one with a binary integer significand field. which makes the "BCD" comment even more strange
00:52:59 <cal[m]> that is a very kind think you just did
00:53:12 <cal[m]> i did not consider using map after having arranged the strings
00:55:04 <cal[m]> i noticed you left the function declarations... they're alright then? I wanted to use integrals quite a lot throughout that project, but got quite a lot of problems
00:55:08 <Axman6> Always thing first about the data, IO comes later
00:55:28 <Axman6> they're ok, but it would be better to separate the processing from IO
00:55:48 <Axman6> This is an exercise left to the reader,as they say :)
00:55:58 <cal[m]> :>
01:00:12 <cal[m]> how you layed out the functions is a lot cleaner
01:00:27 <Ariakenom> ... I suppose it is a compact transfer format
01:07:58 <aae_> exit
01:15:09 <svipal> quasiquotes are more than quasicool
01:20:01 <maerwald> it seems nested if conditionals are not possible in hakyll -.-
01:23:43 <maerwald> or: the generator does no syntax checking :P
01:24:06 <MarcelineVQ> In a template?
01:25:22 <maerwald> yeah
01:25:30 <maerwald> just generated garbage
01:54:30 * hackage indents 0.5.0.1 - indentation sensitive parser-combinators for parsec  https://hackage.haskell.org/package/indents-0.5.0.1 (JasperVanDerJeugt)
01:57:10 <sicklorkin> anyone familiar with persist? I'm trying to figure out how to get prevent this `id` column from getting generated during migrations..https://pastebin.com/gGptYsEe
01:57:27 <merijn> sicklorkin: You need to define an explicit Primary key if you want to avoid that
01:57:49 <merijn> sicklorkin: More importantly, if you care about controlling the details of your schema I'd probably recommend avoiding persistent
01:58:26 <sicklorkin> merijn: but I have defined an explicit Pkey
01:58:26 <merijn> sicklorkin: Oh, wait, you have an explicit primary key. Which version of persistent are you using and which database?
01:59:18 <sicklorkin> merijn: sqlite, persistent-2.9.2, persistent-sqlite-2.9.3, persistent-template-2.5.4
02:00:12 <merijn> sicklorkin: Yeah, they don't support that
02:00:43 <sicklorkin> merijn: if i have a table with three columns that make-believe column isn't created tho which is really effed-up
02:00:45 <merijn> sicklorkin: I had to fix it at some point, I know that 2.10 at least has my fix
02:01:00 <merijn> sicklorkin: It's because the migration logic was broken
02:01:13 <sicklorkin> merijn: tha'ts good to know.. i'll try upgrading.. thanks!
02:02:03 <merijn> sicklorkin: https://github.com/yesodweb/persistent/commit/d0ef59b3252f91a0d3347b41b29554dd82724672 <- 2.10.1 by the looks of it
02:02:18 <merijn> sicklorkin: Although, I honestly wouldn't recommend using persistent for any new projects >.>
02:02:51 <sicklorkin> merijn: most of the stuff in this projects are exploratory.. I dont' think i'd ever recommend somone using it either..
02:03:09 <sicklorkin> (same goes for stack)
02:04:39 <merijn> sicklorkin: Exploratory projects never stay exploratory :p
02:04:50 <sicklorkin> sadly
02:05:02 <merijn> That's how I ended up with a bunch of bug fixes/features/etc. in persistent, because at this point migrating away is too much work :p
02:05:33 <merijn> Selda looks like it might be more promising (but I'm not sure), but I'm wondering whether sqlite-simple isn't the best way to go :p
02:06:28 <Nevoic> Kind of random question, I know with RecordWildCard I'm able to do `User {..}` to bring all the functions on that record into the scope of the function without having to do `name user`. 
02:06:37 <Nevoic> Is there anything like this but with all functions, even those not on the record?
02:06:53 <merijn> Nevoic: eh...what does that even mean?
02:07:26 <Nevoic> if I have other functions like `doX :: User -> String` when I do `User {..}` I actually have to do `user@User {..}` and then later in the function `doX user`
02:07:56 <Nevoic> I should mention all functions in scope, so those that are imported/in the file etc.
02:08:08 <merijn> Nevoic: That sounds like a *terrible* idea, tbh
02:08:22 <Nevoic> mmkay, does that mean it's not possible?
02:08:58 <merijn> It's not and I would argue that's a good thing. That sounds like a great way to write code that's even more brittle than recordwildcards
02:09:13 <merijn> Nevoic: Additionaly, how would you even decide which functions count?
02:09:28 <Nevoic> Those that accept the type you're "extending" as a first argument.
02:09:50 <merijn> Nevoic: Ok, so how about "id"?
02:09:52 <merijn> :t id
02:09:54 <lambdabot> a -> a
02:09:57 <merijn> :t show
02:09:59 <lambdabot> Show a => a -> String
02:10:04 <Nevoic> I was assuming it wouldn't do polymorphic functions.
02:10:09 <Nevoic> Just those that explicitly use the record type.
02:10:17 <Nevoic> as yeah that'd be way too intense.
02:10:19 <merijn> Nevoic: Right, but now you need to start special casing all sorts of things :)
02:10:28 <Nevoic> I'm not the person making the language lol
02:10:34 <Nevoic> figured it might've been done, cool to know it hasn't.
02:11:51 <mpickering> quiet_laika[m]: Not yet, but soon
02:19:30 * hackage FormalGrammars 0.4.0.0 - (Context-free) grammars in formal language theory  https://hackage.haskell.org/package/FormalGrammars-0.4.0.0 (ChristianHoener)
02:21:30 <svipal> so when you use type families inside typeclasses you can only operate on values of the type instances with class methods ? 
02:22:48 <merijn> svipal: No, that's basically a syntactic lie
02:23:01 <merijn> svipal: "associated type families" are just global
02:24:20 <svipal> I feel like I haven' t really understood the subject then. Can you give an example of that not being the case ? 
02:24:48 <svipal> Oh wait, I think I get it
02:26:27 <svipal> you can operate on them by using functions declared outside the typeclass because outside function can refer to the supposedly nested type families ?
02:26:57 <merijn> svipal: Not sure what you mean by "operate" or "them" there
02:27:26 <lortabac> Nevoic: you can do something like that if it helps you https://pastebin.com/kpSMMQT4
02:27:37 <merijn> svipal: Also, what does "nested type family" mean?
02:28:00 <svipal> by nested I meant a type family declared in a typeclass
02:28:28 <svipal> them was "values of the type instances" 
02:28:45 <merijn> svipal: There's not really something like "in" a typeclass. There's not much difference between defining a type family "in" a class definition or doing so outside of the class
02:30:16 <svipal> ok, that' s waht I meant by "supposedly nested"
03:00:30 * hackage GrammarProducts 0.2.0.0 - Grammar products and higher-dimensional grammars  https://hackage.haskell.org/package/GrammarProducts-0.2.0.0 (ChristianHoener)
03:04:59 <l33_> i'm geting a lot of collision messages.... what does 'a collision' mean?
03:05:02 <l33_> collision between `/nix/store/38haafnq4pnvsy48nhnpy765niykm3bk-virtualbox-5.2.28/libexec/virtualbox/sdk/bindings/xpcom/include/nsISimpleEnumerator.h' and `/nix/store/k05h2wras4ppf705829k1nl2ab81h3cq-virtualbox-5.2.28/libexec/virtualbox/sdk/bindings/xpcom/include/nsISimpleEnumerator.h'
03:11:06 <Nevoic> lortabac hey thanks for taking a look! Yeah I could wrap all my functions in another record and then return a sort of default of that record, but there are a lot of functions so it'd be pretty verbose.
03:18:02 <Nevoic> I'm actually running into an issue if anyone is willing to take a look, that'd be pretty helpful!. It's with typeclasses, and I know generally if you're having issues with typeclasses you probably are using them wrong/should use something else, but I don't know what else provides this kind of abstraction.
03:18:14 <Nevoic> https://pastebin.com/xS8v4PKA here's the code https://imgur.com/a/EcG2ZWr and here's the error
03:19:07 <Nevoic> It's a simplified example of what I'm actually doing, I have a few hundred lines of code, but I tried to distill it into a small example.
03:20:58 <Nevoic> oh wait I might actually have it, I've been stuck on it for an hour and the second I ask I think I might have figured it out
03:20:58 <Nevoic> lego
03:21:01 <__monty__> Nevoic: Well, you can't display a Maybe value because there's no `instance item Maybe`.
03:21:16 <Nevoic> yeah that was it lool lego bois
03:21:27 <Nevoic> thanks though :) you figured it out way quicker than I did
03:21:56 <__monty__> I'd use the `maybe` function providing a default for the Nothing case. Or you could do `when isJust item; display (fromJust item)`
03:23:13 <__monty__> Nevoic: The trick is to read the error message carefully. It usually says everything you need to know. For some reason people are conditioned to ignore errors for being opaque (Java errors aren't exactly super clear but not bad enough to teach people to ignore them imo, so I don't know where it comes from.)
03:28:15 <Nevoic> Yeah, maybe I'm just tired, I read it over a lot of times but it just didn't click.
03:29:47 <Nevoic> Anyway, another question, which might not really make sense. Is there a way to enforce that every method that uses an `ItemRepository a` has `a` constrained to `Item` without specifying that constraint for every method?
03:31:21 <Nevoic> I'll never have my `ItemRepository` return anything that isn't an `Item`, the actual implementations of it are always constrained to `Item a =>`, and obviously same with any other method that needs to use the methods available on `Item` .
03:35:45 <__monty__> Nevoic: Constraints on data are bad juju: https://wiki.haskell.org/Data_declaration_with_constraint
03:36:32 <__monty__> Usual solution is to bubble up the constraints to your API.
03:37:15 <Nevoic> Doesn't this break the DRY principle? Or is there some other way to get around repeating yourself?
03:37:54 <tdammers> I recommend ditching DRY in favor of "single source of truth"
03:38:10 <Nevoic> I want to build a structure where by I can have a set of polymorphic types that share some set of properties, and then return that polymorphic type everywhere without having to constrain every function that uses that type.
03:39:09 <tdammers> that's why I suggest "single source of truth" rather than DRY
03:39:21 <Nevoic> I don't know what you mean by `single source of truth`. Is something untruthful about "ItemRepository" returns Items?
03:39:24 <Nevoic> returning*
03:39:26 <tdammers> in this case, you *should* repeat yourself, because each repetition expresses a different truth
03:39:48 <tdammers> "single source of truth" means that every truth should be expressed exactly once. no more, no less.
03:40:07 <tdammers> but if it's not the same truth, then merging the expressions is just as wrong as repeating the same truth in multiple disjoint places
03:40:16 <Nevoic> Seems arbitrary. Isn't it true that a String is an `IsString`? Why don't I have to constrain those methods?
03:40:22 <tdammers> DRY only addresses the latter failure, but is misguiding in the former case
03:40:29 <Nevoic> f :: IsString a => a` as opposed to `f :: String`
03:41:00 <tdammers> because what you want to express is that function foo requires an IsString instance for its first argument, and that bar also requires an IsString instance for its first argument
03:41:57 <Nevoic> So what if it's inherently true that all my `ItemRepository`'s `a`s are `Item`s?
03:42:22 <Nevoic> Wouldn't it be best to have that single source of truth inside the GADT instead of repeated in every single function that uses an ItemRepository?
03:42:30 <tdammers> but that would be a lie
03:42:41 <Nevoic> That's only a lie because I'm unable to make it true.
03:42:42 <tdammers> the ItemRepository data structure doesn't need its elements to be Items
03:42:52 <Nevoic> Seems like a self-fulfilling prophecy.
03:42:55 <tdammers> there is nothing about the data structure itself that requires it
03:43:02 <Nevoic> That's the problem I'm having.
03:43:07 <tdammers> there is, however, something about the functions that manipulate it that does
03:43:22 <tdammers> so attach the expression of the truth to the functions, not the data structures
03:43:36 <tdammers> (and it turns out that data structures practically never have such inherent constraints)
03:44:04 <tdammers> I'd just stop worrying about it and put the constraint on the function
03:44:13 <Nevoic> Okay, I see what you're saying. I'm able to represent the data without the constraints.
03:44:30 <merijn> Nevoic: Additionally, putting constraints on the data does nothing useful
03:45:03 <Nevoic> Well I know it does nothing useful, but it could in theory. The reason so many beginners flock to that is because to some, it makes conceptual sense that an `ItemRepository` would always return items.
03:45:08 <merijn> Nevoic: Generally when people want to constrain data it's because "I don't want to write constraints on all my functions", but that's not a solution, because if you constraint the data you *still* have to write the constraints on functions
03:45:18 <Nevoic> And then it seems to be redundant to have to explicitly state "this ItemRepository is using Items"
03:45:42 <Taneb> How many instances of Items is there?
03:46:01 <Nevoic> in the above example two, in my actual code 3.
03:46:03 <Nevoic> But I plan on making more.
03:47:02 <Nevoic> an `Item` is pretty much just something that can be saved or displayed. Talking about it now, I might split them up into two separate type classes. Only reason I wouldn't use Show is because my entire repo uses Text.
03:47:45 <Nevoic> And I guess at that point I won't have this problem, because it won't be the case anymore that I have `Item a =>` on a crap ton of my functions. It'll at least be half the repetition problem.
03:48:57 <Nevoic> So maybe the lesson is that typeclasses should be extremely small in their functionality so you don't end up putting the constraint on an entire module of functions.
03:50:05 <Nevoic> I liked: "there is nothing about the data structure itself that requires it" + "there is, however, something about the functions that manipulate it that does"
03:50:08 <Nevoic> tdammers
03:50:13 <Nevoic> that clicked the most for me out of everything you said.
03:50:53 <Nevoic> I guess for it to matter on the data structure you'd probably need to be using kind classes or something like that.
03:51:05 <Nevoic> like specifying things about kinds that aren't just *
03:52:13 <tdammers> yeah, you'd have one foot in dependently-typed land for it to matter
03:52:45 <tdammers> although there are situations where you do want to constrain your term-level values through the types, but the type system can't feasibly represent your constraints
03:53:12 <tdammers> the textbook example being range-limited integers (e.g. "an integer, but such that its value is between 0 and 1000")
03:53:36 <tdammers> the usual approach here, however, is to use "smart constructors", which is just a fancy way of saying that you use plain old functions to construct them
03:53:59 <tdammers> but if you then apply the constraints at that point, and enforce them with typeclasses, well, then we're really back to "put constraints on functions, not data"
04:08:24 <int-e> good-bye matrix
04:23:21 <boxscape> yikes I just realized the synonym for (a) in GHC.Tuples is called Unit...
04:23:41 <romanix> Hi Guys! Is there a way to run GHCi without an interactive shell? I'd like to pipe some commands to it (for editor integration) and have it stay running. However it closes down as soon as it processes the first statement I send it on stdin.
04:24:09 <boxscape> (and then two lines further up the docs contradict that name by saying "The unit datatype ()" -.-)
04:25:28 <boxscape> romanix you could try adapting https://github.com/ndmitchell/ghcid to what you want
04:26:17 <romanix> boxscape, I'm actually trying to get intero to work with my editor :)
04:26:47 <romanix> boxscape, and intero behaves just like ghci, hence my question
04:30:30 * hackage generic-lens 1.2.0.1 - Generically derive traversals, lenses and prisms.  https://hackage.haskell.org/package/generic-lens-1.2.0.1 (kcsongor)
04:36:30 * hackage raven-haskell 0.1.2.1 - Haskell client for Sentry logging service.  https://hackage.haskell.org/package/raven-haskell-0.1.2.1 (AlexanderBondarenko)
04:48:00 * hackage hw-dump 0.1.0.0 - File Dump  https://hackage.haskell.org/package/hw-dump-0.1.0.0 (haskellworks)
04:57:09 <moulder> Hi! quick question
04:57:23 <lavalike> time is ticking
04:57:30 <moulder> https://pastebin.com/T8CYkt7V
04:57:32 <moulder> haha
04:57:46 <moulder> I want the returntype of wrapper to be Ast
04:57:52 <moulder> not [Ast]
04:58:34 <lavalike> and what do you want to do with the input list?
04:58:53 <moulder> should still be [String] like it is
04:59:18 <int-e> moulder: what should the result for [] be?
04:59:42 <moulder> well that is the question i suppose
05:00:18 <lavalike> how about a Maybe Ast as a result
05:00:20 <moulder> wrapper [] has to return something, but I don't know how to make it return nothing
05:00:28 <lavalike> :t Nothing
05:00:30 <lambdabot> Maybe a
05:00:31 <lavalike> literally!
05:01:31 * hackage flow 1.0.19 - Write more understandable Haskell.  https://hackage.haskell.org/package/flow-1.0.19 (fozworth)
05:02:42 <int-e> moulder: Let me rephrase this slightly... is `wrapper` allowed to assume that the input is valid? ([] and ["1","2"] would be invalid for slightly different reasons.)
05:03:15 <moulder> yes the input to wrapper is always valid
05:04:55 <int-e> moulder: So why don't you drop the empty list case, and the recursive call from wrapper?
05:09:27 <moulder> well I need the recursive call to iterate through parse
05:09:54 <moulder> I'm openn to suggestions to do it in another way though
05:10:40 <int-e> moulder: parse already does its own recursive calls, the wrapper doesn't need its own?
05:11:03 <int-e> moulder: Assuming that [] and ["1","2"] are indeed invalid inputs.
05:11:44 <moulder> goddamit, now i feel dumb
05:11:49 <moulder> so it does indeed
05:11:55 <moulder> thanks :)
05:14:00 * hackage Monadoro 0.2.1.8 - A minimalistic CLI Pomodoro timer.  https://hackage.haskell.org/package/Monadoro-0.2.1.8 (patryk_kocielnik)
05:18:00 * hackage cabal-doctest 1.0.8 - A Setup.hs helper for doctests running  https://hackage.haskell.org/package/cabal-doctest-1.0.8 (phadej)
05:28:42 <boxscape> okay, I give up
05:28:43 <boxscape> % let f x = unsafeCoerce (print x >> pure f) in f 6 proxy# 7 proxy# 8 proxy# 9
05:28:43 <yahb> boxscape: 6; 7; 8; 9
05:28:47 <boxscape> why does this work
05:28:55 <boxscape> but anything aside from proxy# doesn't
05:29:15 <boxscape> presumably is has something to do with it not having a runtime representation
05:32:32 <boxscape> int-e maybe you know? You told me that it works yesterday
05:36:42 <int-e> boxscape: The trick is that proxy# and State# a have the same representation (namely, they are erased at runtime). There's a special function application for erased stuff... see stg_ap_v and friends in the RTS ("v" is for "void", I suppose).
05:37:20 <boxscape> I shall take a look at that, thanks
05:38:09 <hoppfull> Hello, are there any good books or tutorials on making type systems?
05:39:02 <hoppfull> Is it enough to understand the curry howard correspondence or is there a big leap from there to making a type system from scratch?
05:40:16 <merijn> hoppfull: I don't know the answer to that question, but I do know the crucial tool for making type systems from scratch :)
05:40:23 <merijn> @where tapl
05:40:23 <lambdabot> "Types and Programming Languages" by Benjamin C. Pierce in 2002-02-01 at <https://www.cis.upenn.edu/~bcpierce/tapl/>
05:40:50 <entel> what's a good beginners book that isnt learn you a haskell?
05:40:56 <hoppfull> merijn: I was thinking that if I create a simple logic language, maybe it could be used to check code
05:41:40 <hoppfull> merijn: though I don't know how hard it would be. microKanren can be implemented in less than 50loc
05:41:48 <merijn> hoppfull: Do you have a copy of TaPL? Because if not, you should get one, it's the single most important book for anyone remotely interested in creating their own type system
05:42:57 <merijn> entel: Haskell from First Principles is fairly comprehensive and has lots of exercises, but not everyone's a fan. There's also Graham Hutton's "Programming in Haskell" which I've heard is good, but don't have personal experience with
05:43:00 * hackage bits-extra 0.0.1.4 - Useful bitwise operations  https://hackage.haskell.org/package/bits-extra-0.0.1.4 (haskellworks)
05:43:01 <hoppfull> merijn: No, but I'll definately take a look at it!
05:43:32 <entel> merijn: thanks 
05:43:55 <merijn> hoppfull: It's *the* de facto standard book for introduction to type systems from undergrad level all the way up to phd. It starts out with untyped lambda calculus and then shows how to create increasingly complex type systems on top of that
05:44:14 <merijn> entel: It also depends a bit on your background I suppose
05:44:24 <merijn> hoppfull: (including example implementations of type checkers)
05:44:53 <merijn> hoppfull: It uses ocaml, but only the really simple subset of it, so anyone who knows beginner levels of Haskell should be able to understand the code without much effort
05:45:15 <entel> im almost done with learn you a haskell. some parts confuse me because the code examples introduce new things but dont explain them
05:45:31 <merijn> entel: LYAH is...not great in terms of pedagogy, no :)
05:45:53 <boxscape> It's great in terms of fun drawings though
05:46:01 <merijn> entel: See also: https://github.com/bitemyapp/learnhaskell
05:46:15 <opqdonut> entel: beating my own drum a bit here, but many have liked https://github.com/opqdonut/haskell-exercises
05:46:41 <opqdonut> (most haskell texts don't have enough good exercises)
05:46:53 <entel> these look perfect thanks guy
05:47:16 <entel> i tried a site called exercism that seemed nice
05:47:27 <entel> you get feedback from a real person
05:48:02 <merijn> entel: This channel is also a good place to get feedback on code :)
05:52:19 <enikar> entel: try the wikibook: https://en.wikibooks.org/wiki/Haskell
06:01:51 <merijn> Aesthetics poll: If a program produces a large list of "id - values" lines (intended for human consumption), should the lines be aligned on the -? And if yes, should (numeric) ids be left or right aligned?
06:02:58 <tdammers> will there be spaces inside id's?
06:03:07 <tdammers> if not, I'd ditch the "-" and only align
06:03:07 <merijn> tdammers: They're numeric, so no
06:03:30 <merijn> tdammers: Yes, but right or left? ;)
06:03:32 <tdammers> left or right I'm not sure
06:03:41 <tdammers> right would suggest their numeric value matters, which it does not
06:20:50 <ovitus> In Haskell, you can use -- to make a comment. Is there any way to embed comments in the middle of a function? 
06:21:32 <c_wraith> {- comment goes here -}
06:23:30 * hackage ghc-lib-parser 0.20191002 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-0.20191002 (shayne_fletcher)
06:23:38 <ovitus> thanks!
06:24:31 * hackage greskell 0.2.3.1, greskell-core 0.1.2.7 (debugito): https://qbin.io/surge-server-iy3k
06:24:33 * hackage ghc-lib 0.20191002 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-0.20191002 (shayne_fletcher)
06:25:12 <boxscape> > {- you can even {- have comments -} inside of comments -}
06:25:14 <lambdabot>  <no location info>: error:
06:25:14 <lambdabot>      not an expression: ‘{- you can even {- have comments -} inside of commen...
06:25:30 <boxscape> well okay maybe don't try to use a comment as an expression like I did though
06:25:47 <boxscape> (it works in ghci)
06:28:09 <hyperisco> > {- {- -} -} 0 {- {- -} -}
06:28:12 <lambdabot>  0
06:32:02 <tdammers> nested block comments are an awkward point in the PL design space
06:32:11 <tdammers> block comments in general, actually
06:32:37 <merijn> tdammers: How so? Making comments syntactical rather than lexical is obvious, IMO
06:33:12 <tdammers> yeah, but now you have two things inside comments that matter
06:33:23 <merijn> How so?
06:33:46 <tdammers> without nested comments, the only thing that's interesting inside a comment is the end-of-comment marker
06:34:08 <tdammers> but with nested comments, you also have to watch for start-of-comment tokens, and then you need to match them correctly
06:35:03 <tdammers> I find myself avoiding them in general, because this doesn't only add mental overhead when you write a parser, but also when you're reading the code
06:35:18 <merijn> tdammers: Not with syntax highlighting...
06:35:30 <boxscape> I avoid block comments because I don't feel like writing more than --
06:35:56 <merijn> I like them for quickly commenting out bodies and replacing them with a hole when I broke something during refactoring
06:36:23 <ggole> Nested comments are sometimes used by people to comment out large amounts of code that already contains comments
06:36:40 <ggole> (Without using some kind of editor support for that.)
06:36:45 <tdammers> ggole: yeah, but I much much prefer line comments for that, because they nest in trivial and obvious ways
06:37:01 <boxscape> in a way, you could view line comments as non-nestable block comments that have -- as start token and \n as end token
06:37:08 <merijn> tdammers: Those can't easily start halfway down a line, though
06:37:14 <tdammers> no.
06:37:20 <ggole> Yeah, line comments do work. If you have the other kind, though, making them nest isn't a terrible idea.
06:37:23 <tdammers> my code rarely needs commenting out mid-line
06:37:49 <merijn> tdammers: Like I said, when I'm refactoring and need to comment out the body of a function, which happens fairly frequently
06:38:09 <boxscape> Usually when I want to comment out something midline temporarily, I copy the while line, comment out the original (with line comment), and alter the copy
06:38:17 <tdammers> that, yeah
06:38:19 <boxscape> s/while/whole
06:38:24 <tdammers> or just write it on a separate line in the first place
06:38:32 <tdammers> I generally do this at least for function bodies
06:39:45 <boxscape> Might just be because I have bindings for line comments but not for block comments
06:39:55 <ggole> Some lisps have sexp comments, which is a neat idea
06:40:04 <ggole> Not really applicable for Haskell though
06:41:09 <tdammers> why not?
06:41:21 <tdammers> comment :: String -> a -> a
06:41:31 <tdammers> comment _ x = x
06:42:03 <tdammers> I've seen people doing something similar in Ruby
06:42:09 <ggole> You can't comment out an argument, part of a pattern, part of a data type etc with that.
06:42:35 <tdammers> oh, I thought you were talking about actual comments rather than disabling code
06:43:03 <ggole> People use comments for both, of course.
06:43:05 <tabaqui1> Does GHC correctly parse nested block comments?
06:43:09 <boxscape> yes
06:43:19 <tabaqui1> Well, gcc doesn't
06:43:38 <tabaqui1> or at least didn't years ago
06:43:40 <merijn> tabaqui1: That's because C/C++ comments don't have syntactic comments but lexical ones
06:44:02 <merijn> tabaqui1: It's not "not parsing them correctly", it *is* parsing them correctly. Correct just doesn't mean what you'd like it to
06:44:25 <tabaqui1> what's the difference between syntactic and lexical ones?
06:44:39 <merijn> tabaqui1: lexical doesn't keep context and thus can't track nesting levels
06:45:30 <boxscape> does that mean comments are part of the initial AST that ghc builds?
06:46:36 <boxscape> ^ merijn
06:47:16 <jzyamateur> typeclass definition only allows single type parameter/variable by default? e.g. "class monad m where ..."
06:47:44 <boxscape> jzyamateur there's an extension called MultiParamTypeClasses
06:47:52 <boxscape> but by default, yes
06:47:55 <merijn> boxscape: No clue :)
06:48:02 <boxscape> fair enough
06:50:32 <tabaqui1> jzyamateur: and also check out FunctionalDependencies, cause it's closely related to
06:52:31 * hackage haskoin-core 0.9.1 - Bitcoin & Bitcoin Cash library for Haskell  https://hackage.haskell.org/package/haskoin-core-0.9.1 (xenog)
06:53:00 <jzyamateur> got it, thanks tabaqui1
06:57:51 <sshine> quick reminder that there is a list of open haskell hacktoberfest issues: https://github.com/issues?q=language%3Ahaskell+label%3Ahacktoberfest+is%3Aissue+is%3Aopen+archived%3Afalse
06:58:30 <boxscape> Does haskell get compiled into C-- at some point during compilation, or is that just used for writing the RTS?
06:58:59 <merijn> boxscape: The RTS is mostly not written in C--, but in regular C and Haskell
06:59:10 <boxscape> right, but it has some C--, doesn't it?
06:59:18 <merijn> Maybe, not sure
06:59:47 <boxscape> I assume that implies that haskell source code is at some point in the chain compiled into C--
06:59:50 <merijn> Haskell -> Core -> STG -> Cmm
06:59:57 <int-e> boxscape: look for *.cmm files in the rts subdirectory
07:00:01 <merijn> Then from there either "Cmm -> LLVM IR -> machine code"
07:00:01 <boxscape> okay, thanks
07:00:07 <merijn> Or "Cmm -> machine code"
07:00:10 <boxscape> I see
07:00:20 <merijn> boxscape: Also, note that GHC's Cmm is *not* C--
07:00:27 <boxscape> oh
07:00:32 <boxscape> what
07:00:36 <boxscape> 's the differnce
07:00:44 <merijn> boxscape: Cmm has diverged from the C-- spec
07:00:49 <boxscape> I see
07:01:00 * hackage haskoin-node 0.9.11 - Haskoin Node P2P library for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-node-0.9.11 (xenog)
07:01:15 <merijn> boxscape: C-- was proposed as portable assembly, but never really got much adoption beyond GHC. It's at this point basically dead and it's planned role has been taken over by LLVM asm
07:01:23 <boxscape> okay
07:01:42 <merijn> Since there are basically no C-- tools, there was no point in staying faithful to the spec and Cmm has diverged where it was convenient for GHC
07:02:00 <boxscape> that makes sense
07:02:36 <boxscape> (I thought C itself was supposed to be a portable assembly language...)
07:02:42 <merijn> Hah
07:02:47 <merijn> Not likely
07:03:28 <boxscape> It's a phrase I thought I remembered hearing with C, but maybe I'm mixing something up. K&R did write that it
07:03:37 <merijn> boxscape: People like to say that, sure
07:03:58 <boxscape> ah, okay
07:04:06 <merijn> boxscape: But the way modern CPUs and modern C compilers work there's 0 truth behind it
07:04:27 <boxscape> ok
07:04:41 <merijn> For a portable assembler you want predictability on how it ends up running on the CPU. C gives you none of that, but people think they know how the generated assembly will look
07:05:59 <c_wraith> I think maybe the general opinion on C is starting to turn, thanks to enough publicized bugs caused by over-aggressive abuse of UB by compilers
07:06:12 <c_wraith> people are at least beginning to accept that it's not assembly
07:09:00 * hackage yesod-newsfeed 1.7.0.0 - Helper functions and data types for producing News feeds.  https://hackage.haskell.org/package/yesod-newsfeed-1.7.0.0 (MichaelSnoyman)
07:09:09 <hyperisco> That maybe was how you'd market C to resistant Assembly programmers.
07:10:00 * hackage blaze-markup 0.8.2.3 - A blazingly fast markup combinator library for Haskell  https://hackage.haskell.org/package/blaze-markup-0.8.2.3 (JasperVanDerJeugt)
07:19:56 <gobby> is panic better than fai?l
07:19:59 <gobby> fail*
07:21:59 <ski> "panic" ?
07:22:20 <boxscape> % panic "test"
07:22:20 <yahb> boxscape: ; <interactive>:19:1: error: Variable not in scope: panic :: [Char] -> t
07:23:47 <geekosaur> something that lets you handle special conditions inline (like ExceptT) is better than either, in general. exceptions should be, well, exceptional. and part of Haskell is minimizing these by reducing the number of cases where they can occur via e.g. the type system
07:23:53 * ski is still disappointed in LLVM not allowing multiple results, to be put in virtual registers
07:25:03 <geekosaur> some will be unavoidable (out of heap, communication error) but that's where you use exception handlers. or for comms errors ExceptT is still often usable. sadly the standard library doesn't do this and throws even for e.g. failure to open a file, which ought to be returned inline really
07:26:03 <Ariakenom> ski: really? (and result from what)
07:30:11 * geekosaur imagines that's painful to convert to machine code on a platform other than, say, SPARC
07:31:13 <merijn> If I have a class that needs to be able to return an opaque, instance specific handle, what's the best approach? Associated data family?
07:33:43 <merijn> Also: Can I somehow make ghci list everything in scope from a certain module?
07:33:56 <boxscape> :browse module?
07:34:01 <ski> Ariakenom : instead of just `ret', after putting result(s) in specified registers, you do `ret <reg>' :/
07:36:48 <Ariakenom> ski: but there are calling conventions with multiple return values (even except ghc)
07:37:31 <Ariakenom> you can return a struct afaict
07:38:50 <geekosaur> which is done with space allocated on the stack, on most platforms
07:40:14 <geekosaur> which means the caller has to participate in the convention, unlike CPUs with dedicated large output register windows or similar
07:40:58 <geekosaur> well, hypothetically it could be allocated right after the CALL and then indexed off the stack pointer, with care that nothing else uses the stack immediately so the caller still needs to know some convention
07:41:06 <ski> Ariakenom : yea, but one could just as well argue that one doesn't need multiple parameters, could just pass a struct
07:41:30 * hackage InternedData 0.0.0.1 - Data interning (with compact regions where possible)  https://hackage.haskell.org/package/InternedData-0.0.0.1 (ChristianHoener)
07:41:42 <geekosaur> (of course, it has to know to check output registers in that case, but generally it's safe for a caller not expecting it to ignore them without causing memory corruption)
07:43:40 <Ariakenom> here is llvm documentation on ghc calling convention "cc 10" http://releases.llvm.org/6.0.0/docs/LangRef.html#callingconv
07:50:30 * hackage regex-pcre-builtin 0.95.1.0.8.43 - PCRE Backend for "Text.Regex" (regex-base)  https://hackage.haskell.org/package/regex-pcre-builtin-0.95.1.0.8.43 (AudreyTang)
08:07:32 <Guest_96> i ve got these kind of message :
08:07:36 <Guest_96> Failed to install, consider updating this script via: ghcup upgrade"ghcup --cache install" failed!
08:09:00 <ovitus> i've tried using embedded comments with {- comment -}, but I can't use more then one in a function before it starts throwing errors
08:09:06 <asheshambasta> is there a library that lets me compile foreign haskell code from within haskell? 
08:09:15 <merijn> asheshambasta: ghc? :p
08:09:36 <asheshambasta> touche. 
08:09:52 <geekosaur> hint might be a simpler wrapper thereto
08:09:59 <merijn> mueval can also work
08:10:11 <merijn> I think the correct answer depends on: With what goal?
08:10:28 <heatsink> There is a "plugins" library.  It supports compiling and loading a new module into the currently running program
08:10:37 <heatsink> I had a lot of trouble using it though
08:10:58 <heatsink> Don't remember the exact name of that library
08:11:10 <asheshambasta> merijn: rather simple: accept some HTML text from the user, run blaze-from-html on it (resulting in Haskell code) and at least "evaluate it" to get some functions at runtime and see if they compile. 
08:12:21 <merijn> asheshambasta: Seems like it be easier to extend blaze-from-html (or write a replacement) that doesn't generate textual output but just directly produces a Blaze result you can use?
08:12:40 <geekosaur> ovitus, seems to work here. can you provide a failing example? (which compiles without the comments)
08:13:27 <geekosaur> heatsink, it's called plugins. it's known to be somewhat hairy though.
08:13:44 <geekosaur> hint is said to be easier for this for at least some use cases, but I have no direct experience
08:14:14 <asheshambasta> geekosaur: yeah the API looks clean and pretty much what I'd need  
08:15:30 * hackage NaturalLanguageAlphabets 0.2.1.0 - Simple scoring schemes for word alignments  https://hackage.haskell.org/package/NaturalLanguageAlphabets-0.2.1.0 (ChristianHoener)
08:15:53 <ovitus> dolet test {-one-} x = x + 1 + 2 + 3test 1
08:15:57 <ovitus> that works
08:16:01 <ovitus> dolet test {-one-} x = {-two-} x + 1 + 2 + 3test 1
08:16:04 <ovitus> that doesn't
08:16:30 * hackage blaze-html 0.9.1.2 - A blazingly fast HTML combinator library for Haskell  https://hackage.haskell.org/package/blaze-html-0.9.1.2 (JasperVanDerJeugt)
08:16:38 <geekosaur> can you do that with a pastebin of some kind so I don't have to guess where you stuck the newlines? also remember that indentation matters
08:16:50 <geekosaur> you can't unindent the comment and expect it to work
08:17:17 <geekosaur> hm, actually thatr did just work for me
08:17:42 <heatsink> hint looks nice
08:18:29 <geekosaur> https://gist.github.com/geekosaur/f69a06fc6904185d2d98da25eab1cb3a fwiw
08:20:02 <geekosaur> also in a file you can't just have "test 1" like that, it'd need to be in a function or CAF. "main" will be run if you have a program; in ghci, use ":main" to run it with arguments or redirections, or just "main" if you don't need any
08:20:31 <ovitus> hmm
08:21:00 <ovitus> i'm running this in Tidal, that may be wy
08:27:44 <aztex> Hi does the GHC optimizer has the full freedom of running inside the IO monad?
08:28:20 <dminuoso> aztex: Are you asking whether the optimizer, internally, has access to IO?
08:28:31 <aztex> I know this sounds vague. But what I am trying to understand is that given pure functions the optimizer has full power to inline and do all other optimizations
08:28:56 <aztex> But when you are inside the IO monad where the order of the operations are defined by the bind operator
08:29:07 <aztex> can GHC reorder things to make it more efficient?
08:29:27 <heatsink> The optimizer is implemented using pure functions that the optimizer can inline and optimize
08:29:31 <merijn> aztex: The implementation of IO enforces the ordering of side-effects
08:29:33 <dminuoso> aztex: The IO type is to ensure GHC cant reorder bits.
08:29:48 <merijn> aztex: So it can reorder, but not in a way that changes the order of effects
08:29:48 <dminuoso> aztex: That is, the fundamental nature of how IO is implemented internally makes it impossible to reorder.
08:30:18 <ggole> "Impossible" -> "quite a bit more difficult"
08:30:23 <dminuoso> Heh fair enough.
08:30:55 <aztex> merijn: when you say "it can reorder but not in a way that changes the order of effects" could you give me a small example of this?
08:31:42 <ggole> If you have two writes to disjoint refs, you can perform them in either order.
08:31:47 <geekosaur> were it pure, `putStrLn "1" >> putStrLn "2"` could have the two actions swapped
08:32:08 <geekosaur> but IO enforces ordering by making the second one depend implicitly on the first
08:32:48 <dminuoso> aztex: The optimizer rather applies stuctural optimizations like inlining (which is one of the most important things in GHC)
08:32:49 <heatsink> Here is an example: In f x y = do { print (x + y); print (x + y) }, the expression (x + y) is evaluated twice, but GHC can optimize it to evaluate x + y only once
08:33:04 <geekosaur> unless you do certain very inadvisable things (the best known got its name changed to "accursedUnutterable…" to remind its inventors why they needed to be cautious using it)
08:33:15 <heatsink> It can do that even though it has to look across IO operations, because it can detect that x + y isn't affected by IO side effects
08:33:51 <aztex> I see
08:34:13 <dminuoso> aztex: Basically GHC will apply transformations such that the resulting code is extensionally equivalent. :)
08:34:26 <dminuoso> aztex: For example case-of-case
08:35:38 <Ariakenom> ggole: two IORefs? that would be observable by other threads
08:36:57 <dminuoso> aztex: So a lot of optimizations try to open up inlining opportunities.
08:37:02 <geekosaur> order is preserved in that case too, btw. there's a fake parameter threaded through by the IO monad, such that IO actions depend on earlier actions; there's nothing done in terms of comparing resources used
08:37:22 <geekosaur> (in ghc. other haskell implementations may do something different)
08:37:24 <dminuoso> (The optimizer is implemented as a sort of loop, in which each pass can open up new optimization possibilities for other passes)
08:39:27 <aztex> so if I have something like `f = do { x <- getInt; let z = x + 1; let y = z + 2; print (y,y)}` would GHC optimize this to `f = do { x<- getInt ; print (x+3, x+3)}`
08:40:01 <aztex> I am imagining an imaginary function called `getInt` here which is of type IO Int
08:40:31 <asheshambasta> merijn: I see what you mean, and yeah that could also be an option 
08:40:53 <dminuoso> aztex: It more likely would optimize it into `{ x <- getInt; let y = x + 3 in print (y, y) }`
08:41:11 <dminuoso> aztex: That is, you've already written the optimized form.
08:41:23 <dminuoso> Or, perhaps it choses to inline that particular bit.
08:41:39 <dminuoso> It could go either way in general.
08:43:05 <ovitus> geekosaur can you take a look: https://gist.github.com/geekosaur/f69a06fc6904185d2d98da25eab1cb3a
08:43:08 <ovitus> I responded with a test
09:39:00 * hackage ref-tf 0.4.0.2 - A type class for monads with references using type families.  https://hackage.haskell.org/package/ref-tf-0.4.0.2 (GeoffreyMainland)
09:40:00 * hackage ref-fd 0.4.0.2 - A type class for monads with references using functionaldependencies.  https://hackage.haskell.org/package/ref-fd-0.4.0.2 (GeoffreyMainland)
10:00:24 <dmwit> ovitus: possibly relevant: https://stackoverflow.com/q/57892797/791604
10:01:11 <jzyamateur> I have mentioned multiple ways to data declarations in https://gist.github.com/chetnashah/bf94fe9d14b3cad8dfb2111ced873786
10:01:19 <jzyamateur> Which is the preferred way?
10:01:25 <jzyamateur> and Why?
10:01:26 <dsal> Is there a     Maybe a -> Maybe a -> Maybe a    that takes the first Just?
10:01:48 <glguy> mplus
10:02:06 <dansho> is there an extension that gives records their own namespaces or am i thinking of idris?
10:02:39 <dsal> glguy: Thanks.  I knew this was a thing...
10:02:47 <glguy> > [ (x,y,mplus x y) | x <- [Nothing, Just 'a'], y <- [Nothing, Just 'b']]
10:02:49 <lambdabot>  [(Nothing,Nothing,Nothing),(Nothing,Just 'b',Just 'b'),(Just 'a',Nothing,Jus...
10:03:29 <boxscape> Or Alternative's <|> 
10:03:30 <boxscape> > [ (x,y,x <|> y) | x <- [Nothing, Just 'a'], y <- [Nothing, Just 'b']]
10:03:32 <lambdabot>  [(Nothing,Nothing,Nothing),(Nothing,Just 'b',Just 'b'),(Just 'a',Nothing,Jus...
10:03:48 <dmwit> > [(fold x, fold y, fold (mplus x y)) | x <- [Nothing, Just "a"], y <- [Nothing, Just "b"]]
10:03:50 <lambdabot>  [("","",""),("","b","b"),("a","","a"),("a","b","a")]
10:04:33 <heatsink> dansho: You might check the proposals in https://gitlab.haskell.org/ghc/ghc/wikis/records/
10:04:45 <heatsink> Several of them are attempts to improve record namespacing
10:05:32 <boxscape> jzyamateur I think it's pretty much up to personal preference, but if you go with the second one, use newtype instead of data for HumanName and HumanAge
10:06:12 <EvanR> improving records qualify of life seems to have sailed on the good ship "lost cause"
10:07:42 <boxscape> jzyamateur you also forgot the data constructors on those declarations, and they'll need deriving clauses as well
10:12:10 <dsal> Oh, I somehow forgot about alternative.  Different context.
10:13:20 <dansho> yeah, looks about the same as it was a couple years ago
10:14:37 <dmwit> > Just "a" <> Just "b"
10:14:40 <lambdabot>  Just "ab"
10:43:03 <jzyamateur> Which of the three is the preferred way and why? https://gist.github.com/chetnashah/bf94fe9d14b3cad8dfb2111ced873786
10:46:41 <glguy> 2 is incorrect, you either want: newtype NumanName = MkHumanName String ; or type HumanName = String
10:47:13 <glguy> If you're going to have more than a small collection of fields on the data type using a record is nice as the reader doesn't have to memorize the positions of the different fields
10:47:42 <glguy> type synonyms aren't good documentation and make your code harder to understand in many cases because the reader has to memorize the definitions of them anyway
10:48:07 <glguy> newtypes are good when there's a limited set of operations that should be supported
10:48:28 <Ariakenom> (type synonyms is version 2 but using "type")
10:48:30 <jzyamateur> yeah ,  but it helps in some kind of type checking right? HumanName will only type check against HumanName and not any String?
10:48:36 <glguy> no
10:48:43 <glguy> well, it depends if you use type or newtype
10:49:04 <glguy> newtyping can be good if you want to ensure that ages don't get added together or divided, which doesn't really make sense for an age
10:52:56 <jzyamateur> Is there any case where type aliases like type HumanName = String is useful ? for subsequent data declarations?
10:53:58 <glguy> type synonyms are most useful when they are shorter than their definitions and remove redundancy to an extent that outweighs the cost of the reader having to memorize them
10:55:21 <glguy> Like you might be writing a module for parsing some stuff and you're using a parser library that is parameterized over a stream and token and error type
10:55:41 <glguy> So you could define: type P = Parser MyError ByteString MyToken
10:55:50 <glguy> and then use P everywhere as a convenience in that module
10:57:07 <glguy> Here you can argue that it's worth the cost of the reader/writer of the code to memorize that P is that particular kind of parser rather than having to deal with the repetition of Parser MyError ByteString MyToken everywhere
10:57:24 <jzyamateur> like an abbreviation of sorts for reducing redundancy. the use case I mentioned earlier was a documentation case.
10:57:26 <glguy> saves on typing and having to manually verify at each use site that the instantiation of Parser didn't chantge
10:57:43 <glguy> type synonyms aren't useful for documentation, we have haddock comments for that
10:58:26 <jzyamateur> No I mean it would make more sense that a HumanName was coming somewhere then just a plain String?
10:58:59 <glguy> The types tell you what operations a value is going to support. Hiding that behind HumanName doesn't help there
10:59:12 <jzyamateur> got it
10:59:22 <glguy> unless you want to support a differentset of operations than those supported by normal String
10:59:40 <glguy> (in which case you use a newtype)
11:31:48 <Guest_50> Hello! I'm trying to install `ghcup` from `curl https://get-ghcup.haskell.org -sSf` sh and found that it downloaded an HTML file that indicates GitLab is down. 
11:32:10 <Guest_50> Guess all I can do is wait?
11:33:01 <glguy> There's a mirror of the ghcup repo, the script is available here: https://github.com/haskell/ghcup/blob/master/ghcup
11:33:32 <glguy> The installer script is available too https://github.com/haskell/ghcup/blob/master/bootstrap-haskell if you want to use it
11:35:00 <glguy> (the installer script would require modifying it not to point to gitlab, but you can just download the ghcup script itself and put it in ~/.ghcup/bin/ and update your path
11:37:35 <dsal> Is there a good way to make a default instance of a class based on a constraint?
11:38:23 <dsal> I guess I don't actually need this class at all.  Maybe I'll do that instead.
11:38:49 <glguy> dsal: Either by using DefaultSignatures https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#default-method-signatures or providing default implementations like foldMapDefault
11:40:46 <dsal> Thanks.  I figured there was an easy way  to do this, but then I realized it's easier for me to just not do it.
11:44:12 <boxscape> hm, the website linked in the topic for the logs of this channel seems to be down. Anyone know if that's a temporary/new thing?
11:44:23 <boxscape> wait I was going to post that in #ghc
11:44:26 <boxscape> -.-
11:57:32 <gobby> I'm currently getting: ```HandshakeFailed (Error_Misc "no keys found\nCallStack (from HasCallStack):\n  error, called at ./Network/Wai/Handler/WarpTLS.hs:265:20 in warp-tls-3.2.5-2FsWeMf1nNvA0nztofVYMj:Network.Wai.Handler.WarpTLS")``` using `warp-tls`. 
11:58:12 <gobby> my settings are: `tlsSettings "22cb488c23a886e2.pem" "generated-private-key.txt"` 
11:58:30 <gobby> im testing on localhost 
11:58:50 <gobby> even if I host my website via `ngrok` it still complains no keys found but my keys are there
12:02:49 <gobby> I've converted "generated-private-key.txt" to "generated-private-key.pem" with the same result
12:11:30 * hackage FontyFruity 0.5.3.5 - A true type file format loader  https://hackage.haskell.org/package/FontyFruity-0.5.3.5 (VincentBerthoux)
12:18:30 * hackage JuicyPixels 3.3.4 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  https://hackage.haskell.org/package/JuicyPixels-3.3.4 (VincentBerthoux)
12:23:15 <EvanR> is there any relationship between "heap data structure" and the runtime heap, the runtime thing that is not the stack
12:25:43 <Ariakenom> EvanR: How strong of a relationship? I guess they both go for "somewhat unordered" in their use of the word.
12:29:50 <EvanR> is that what it is
12:29:56 <Ariakenom> the memory region compared to a stack. and the data structure compared to an ordered list
12:30:06 <EvanR> i thought it was a weird word to pull out of nowhere , then use in different circumstances
12:30:07 <Ariakenom> that's what I can come up with
12:30:26 <EvanR> like you were supposed to draw "related"ness
12:31:09 <EvanR> and then you have voltaic pile, which is really a stack
12:37:37 <hikari-chan> hi, I haven't used Haskell in a while (i.e. like three years ;-;), I see `cabal sandbox` is gone, how do I make a sandbox now
12:43:26 <Ariakenom> hikari-chan: you can use the cabal v2-X commands and it will be sandboxed
12:43:41 <hikari-chan> just, by default?
12:46:26 <Ariakenom> hikari-chan: yes. it will put your dependencies into a system wide cache but they will not be globally installed
12:47:10 <Ariakenom> I haven't used much cabal but I think that I'm giving you the right idea :]
12:47:14 <hikari-chan> thanks
13:09:00 * hackage arithmetic 1.5 - Natural number arithmetic  https://hackage.haskell.org/package/arithmetic-1.5 (JoeHurd)
13:29:00 * hackage shower 0.2.0.2 - Clean up the formatting of 'show' output  https://hackage.haskell.org/package/shower-0.2.0.2 (Artyom)
13:35:45 <Guest_65> How can I solve this problem on Mac OS? "Failed to install, consider updating this script via: ghcup upgrade"ghcup --cache install" failed!"
13:43:03 <texasmynsted> Guest_65: did you get it working?
13:43:31 <bg> q
13:43:45 <texasmynsted> q?
13:43:59 <bg> sorry fat finger mistake
13:44:26 <texasmynsted> np
13:54:45 <Guest_65> texasmynstedNOT yet...
13:55:38 <Guest_65> I have no idea now
14:17:32 <tabaqui1> can I force stack to run all actions sequentially?
14:17:46 <tabaqui1> I suspect that parallel build cause lock error on Windows
14:18:29 <gentauro> https://gitlab.com/uniprocess/haskell-template#repoducible-build-hash-on-nixos-1903
14:19:20 <gentauro> why does having a different version of `stack` change the RBH?
14:19:26 <gentauro> doesn't give sense ...
14:19:37 <gentauro> (tested with 1.9.3 and 2.1.3)
14:20:17 <gentauro> shouldn't `stack` just "build" with the given `compiler` as specificed in the `LTS` and the used packages combined with the specific `NixOS` snapshot?
14:20:55 <MarcelineVQ> tabaqui1: -j1 can slow things down a bit
14:21:11 <MarcelineVQ> but just for dependencies I think
14:21:39 <__monty__> gentauro: Well, if a bug in stack gets fixed the output should surely differ.
14:22:09 <tabaqui1> MarcelineVQ: now logs seems sequential
14:22:16 <gentauro> __monty__: Why?
14:22:23 <tabaqui1> but it's not a race, what is bad
14:22:37 <gentauro> Isn't `stack` just a tool that automate `build`
14:22:51 <tabaqui1> I get an error in my docker build, but I cannot reproduce it on a local machine
14:22:51 <gentauro> I mean the translation is done by the compiler amirite?
14:22:58 <tabaqui1> "[info] Unable to get a write lock on the Stack database, waiting..."
14:23:01 * hackage webby 0.4.0 - A super-simple web server framework  https://hackage.haskell.org/package/webby-0.4.0 (AdityaManthramurthy)
14:23:16 <gentauro> tabaqui1: just delete stack.yaml.lock
14:23:49 <tabaqui1> gentauro: it's not about stack.yaml, but "stack.sqlite3.pantry-write-lock"
14:24:00 <gentauro> tabaqui1: ahhh
14:24:12 <__monty__> gentauro: Well yes. But if stack makes a mistake, like passing a flag it shouldn't. That could change the build. Also though, afaik GHC doesn't do reproducible builds yet?
14:24:42 <tabaqui1> and what is the worst - I always start the build on fresh repo, and the build process fails somewhere during precompiled packages check
14:24:46 <gentauro> __monty__: it looks like I found a way to do it :)
14:25:04 <gentauro> __monty__: if you are on NixOS, try this -> https://gitlab.com/uniprocess/haskell-template#repoducible-build-hash-on-nixos-1903
14:25:14 <gentauro> you should get `48af0734b138062ef32dca9d054c28af8befe5325abb3293f1a85920bb4630a6`
14:25:22 <tabaqui1> ah, I'll leave it for tomorrow
14:25:48 <gentauro> kudos to boomerang who helped me at the NixOS Meetup today
14:30:51 <Guest_7> Hi~ How can I fix this problem?     "configure: error: C compiler cannot create executablesSee `config.log' for more detailsFailed to install, consider updating this script via: ghcup upgrade"ghcup --cache install" failed!"
14:32:39 <__monty__> Guest_7: Probably read config.log to see what the problem is.
14:41:06 <texasmynsted> Guest_65: looks like you are gone :(
14:42:33 <MarcelineVQ> Soon to be back. The problem probably occurs earlier than that, failed to find expected compiler for cc or something possibly, so it'd be good for them to look at the whole build output
14:43:47 <texasmynsted> Guest_65: what happens if you do "ghcup list"
14:44:49 <texasmynsted> maybe try "ghcup -v install"
16:01:00 * hackage smt 0.0.0.0 - Interface to Satisfiability Modulo Theories solvers  https://hackage.haskell.org/package/smt-0.0.0.0 (MatthewFarkasDyck)
16:01:20 <boxscape> hm, actually seems kind of odd that you can't use -> as a termlevel operator
16:02:13 <boxscape> makes syntax highlighting easier for me though, so that's nice
16:08:16 <dsal> I keep managing to get quickcheck shrink to blow up uncontrollably on lists.  Am I doing something wrong?   Ideally, I just  want to try a few arrangements of the list, but it  seems my tests run forever.   I'm just doing       Container <$> shrinkList (:[])  stuff
16:11:21 <dsal> > shrinkList (:[]) [1, 2, 3]
16:11:23 <lambdabot>  [[],[2,3],[1,3],[1,2],[1,2,3],[1,2,3],[1,2,3]]
16:11:38 <dsal> I guess it's because it like, outputs itself.  That's not helpful.
16:15:14 <dsal> I guess I just have to filter those, which seems dumb.
16:32:01 <dmwit> :t shrinkList
16:32:02 <lambdabot> (a -> [a]) -> [a] -> [[a]]
16:32:42 <dsal> The first argument is for shrinking individual things (e.g., shrinking the number there).  I don't want to shrink them, I just want the container shrunk.
16:33:17 <dmwit> > shrinkList (\n -> [0..n-1]) [1,2,3]
16:33:19 <lambdabot>  [[],[2,3],[1,3],[1,2],[0,2,3],[1,0,3],[1,1,3],[1,2,0],[1,2,1],[1,2,2]]
16:33:31 <dmwit> If you pass a correct shrinker, you get a correct shrinker.
16:33:35 <dmwit> If you don't... you don't.
16:33:39 <dmwit> That seems like it's on you.
16:33:58 <dmwit> > shrinkList (\n -> []) [1,2,3]
16:34:00 <lambdabot>  [[],[2,3],[1,3],[1,2]]
16:34:13 <dsal> Oh.  Yeah.  That looks like what I want.
16:34:26 <dsal> I've been doing it wrong for a while and being confused when it doesn't work correctly.
16:34:42 <dsal> So (const []) is my shrinker?
16:34:50 <dmwit> Sure, why not.
16:39:32 * dmwit frowns at smt
16:47:00 * hackage safecopy 0.10.2 - Binary serialization with version control.  https://hackage.haskell.org/package/safecopy-0.10.2 (DavidFox)
17:43:30 * hackage tree-sitter-java 0.3.0.0 - Tree-sitter grammar/parser for Java  https://hackage.haskell.org/package/tree-sitter-java-0.3.0.0 (robrix)
17:46:43 <Axman6> @pl (\hm (k,v) -> HashMap.insert k v hm)
17:46:43 <lambdabot> (`ap` snd) . (. fst) . flip (flip . HashMap.insert)
17:47:26 <Axman6> @pl (\hm (k,v) -> uncurry HashMap.insert (k, v) hm) 
17:47:27 <lambdabot> (`ap` snd) . (. fst) . flip (flip . (uncurry HashMap.insert .) . (,))
18:11:53 <MarcelineVQ> Axman6: flip (uncurry insert) ?
18:14:21 <Axman6> yeah
18:14:44 <Axman6> I thought pl knew about curry and uncurry
18:18:40 <dmwit> ?pl \k v -> HashMap.insert k v hm
18:18:40 <lambdabot> flip flip hm . HashMap.insert
18:18:54 <dmwit> uh
18:19:09 <dmwit> sure, why not
18:19:29 <boxscape> hm, kind of counter-intuitive that Prelude.[] can't be parsed
18:19:46 <dmwit> [] isn't an identifier. It's magic syntax.
18:19:57 <boxscape> I know, but it's still counter-intuitive :P
18:20:20 <dmwit> Okay. [] is a special case in a lot of ways, not just this one.
18:20:25 <boxscape> that's fair
18:20:26 <EvanR> @src []
18:20:27 <lambdabot> data [] a = [] | a : [a]
18:20:34 <EvanR> ^ lies... all lies
18:20:40 <dmwit> For example, [ ] is completely fine. But you probably wouldn't expect Prelude.[ ] to work...
18:20:56 <boxscape> to be honest I wouldn't expect [ ] to work either
18:21:08 <dmwit> But you expect [ 3 ] to work?
18:21:14 <boxscape> yeah, I do :/
18:21:23 <dmwit> Now who's being counterintuitive? =P
18:21:29 <lyxia> Set.[1, 2, 3]
18:21:42 * lyxia goes back to OCaml.
18:22:37 <dmwit> % [3,4] :: Set Int
18:22:37 <yahb> dmwit: fromList [3,4]
18:22:47 <dmwit> % [4,3,4,5,4,3] :: Set Int
18:22:47 <yahb> dmwit: fromList [3,4,5]
18:22:52 <boxscape> % :set
18:22:52 <yahb> boxscape: options currently set: none.; base language is: Haskell2010; with the following modifiers:; -XBangPatterns; -XConstrainedClassMethods; -XConstraintKinds; -XDataKinds; -XNoDatatypeContexts; -XDeriveDataTypeable; -XDeriveFoldable; -XDeriveFunctor; -XDeriveTraversable; -XDisambiguateRecordFields; -XEmptyCase; -XExistentialQuantification; -XExplicitForAll; -XExplicitNamespaces; -XFlexible
18:23:11 <dmwit> OverloadedLists is the one you want your eyes to alight on
18:23:25 <boxscape> I guess it's past the cutoff
18:23:28 <dmwit> guess so
18:23:48 <shachaf> OverloadedLists doesn't handle the one use case I'd really want it for.
18:24:03 <shachaf> Which is overloading : and [] separately to make a "list" of things of different types.
18:24:43 <boxscape> can you give an example?
18:27:39 <shachaf> A list of things that you can apply show to, or something?
18:27:53 <shachaf> [show x, show y, show z] is a valid list; map show [x,y,z] isn't valid.
18:28:22 <boxscape> sounds like the sort of thing that you could maybe do with existential types but I guess it might depend on the exact circumstances
18:28:22 <EvanR> data Hanoi a where Base :: Hanoi Infinity; Stack :: BlockSize n -> Hanoi (GreaterThan n) -> Hanoi n
18:28:25 <shachaf> But showCons :: Show a => a -> [String] -> [String] is a function you can write such that showCons x (showCons y (showConst z [])) is a valid list.
18:28:32 <shachaf> (Maybe there's a type conflict in this case but you get what I mean.)
18:28:43 <shachaf> Existentials as implemented in GHC don't buy you anything here.
18:28:49 <boxscape> hm, okay
18:28:57 <EvanR> 1:3:5:7:[] ok,  but 7:1:3:[] no good
18:30:00 * hackage hw-fingertree-strict 0.1.1.2 - Generic strict finger-tree structure  https://hackage.haskell.org/package/hw-fingertree-strict-0.1.1.2 (haskellworks)
18:32:12 <EvanR> for my hanoi example you have to do 1 `Stack` 3 `Stack` 7 `Stack` Base
18:32:23 <EvanR> or an operator ctor
18:32:58 <EvanR> in idris if you use ctor names :: and Nil you can use list syntax
18:34:26 <boxscape> is there an advantage to using IsList over simply doing that?
18:34:57 <shachaf> Doing what?
18:35:07 <EvanR> in my example BlockSize n elements all have different type
18:35:22 <boxscape> over doing what Idris does
18:35:39 <boxscape> I guess if Haskell did it the Idris way then you couldn't use List syntax for more than one type within a module
18:35:49 <boxscape> but that might be less of an issue in Idris given overloading of names
18:36:10 <EvanR> ime TDNR is an issue
18:36:49 <EvanR> i'm not sure what IsList would look like with dependent types
18:39:07 <MarcelineVQ> boxscape: you can, you just use namespaces
18:39:35 <MarcelineVQ> Which overloading is fine with
18:40:08 <EvanR> in idris you have to do a special thing to qualify which list syntax you want
18:40:31 <boxscape> oh yeah I remember something like that. It's been years since I've looked at Idris.
18:44:40 <EvanR> when math text says "in the following (,,...) means whatever", we can emulate that pretty easy in a programming language
18:45:22 <EvanR> would be similar to imports. But then when they say "in the follow it'll be obvious whether notation means thing A or thing B by context"
18:49:24 <EvanR> maybe they should prove by providing the type inference algorithm :)
18:50:00 <boxscape> "the proof of obviousness is left as an exercise to the reader"
18:50:32 <Jeanne-Kamikaze> Best quote.
18:58:04 <EvanR> whitespace is best notation obvious by context
19:25:20 <pacak> I'm trying to use stack with system ghc. There's about 330 system packages listed in package.yaml and ghc-pkg list sees them all, but "slack build --dry-run" complains that it can't find two of them. For one it says it can't find it at all (even though ghc-pkg dump that stack itself calls sees it) for second one it says it can't find specified version (even though I'm not specifying any and stack itself detects one). Are there any more ways t
20:02:59 <fabianhjr[m]> check the stack resolver and add those to extra-pkgs if appropriate
20:03:01 <fabianhjr[m]> It should be in stack.yaml
20:03:19 <fabianhjr[m]> https://www.stackage.org/
20:12:18 <fragamus> isovector are you here
20:14:36 <Axman6> doesn't look like it
20:16:11 <fragamus> yeah but quantum physics
20:27:29 <pacak> fabianhjr[m]: Resolver contains two lines - name and and compiler and works fine for 328 packages out of 320. There's no extra-pkgs and I'm not using stackage either.
20:30:12 <EvanR> 328 out of 320 ain't bad
20:31:52 <pacak> I agree, they are not very useful packages. Just need to convince stack
20:39:00 <stevejb> hello, I am working on haddock documentation for a project and as part of that, I want to document some parsers. As part of this, I would like to enclude a sample JSON snippet. What is the right way to do this in Haddock? 
20:40:16 <stevejb> And similarly, if I had some documentation which included a "this is the equivalent python code:..." would it be possible to have that code syntax highlighted
20:41:14 <heatsink> Ignoring syntax highlighting, do you know how to include a code block in haddock?
20:44:04 <heatsink> I mean, I don't have an answer for the syntax highlighting part, but you can format code in haddock.  Inline code in text is enclosed between @ symbols.  Multiline code is as a separate paragraph, each line starting with "> "
20:51:52 <stevejb> heatsink the @ code blocks are Haskell specific right, its not just verbatim right?
20:53:38 <heatsink> IIRC, @code blocks@ are monospace formatted, not necessarily Haskell
21:03:55 <fabianhjr[m]> stevejbbackticks if I remember correctly.
21:05:46 <fabianhjr[m]> NVM https://www.haskell.org/haddock/doc/html/ch03s08.html#ftn.idm140354810780208
21:05:47 <fabianhjr[m]> As heatsink said.
21:30:30 * hackage hhp 0.0.2 - Happy Haskell Programming  https://hackage.haskell.org/package/hhp-0.0.2 (KazuYamamoto)
21:40:33 <iqubic> :t (:)
21:40:34 <lambdabot> a -> [a] -> [a]
21:54:48 <rotaerk> :t (<.>)
21:54:49 <lambdabot> Indexable (i, j) p => (Indexed i s t -> r) -> (Indexed j a b -> s -> t) -> p a b -> r
22:01:30 * hackage axel 0.0.12 - The Axel programming language.  https://hackage.haskell.org/package/axel-0.0.12 (jgrosso256)
22:11:00 * hackage hw-rankselect 0.13.3.0 - Rank-select  https://hackage.haskell.org/package/hw-rankselect-0.13.3.0 (haskellworks)
22:26:56 <spaceghost> Clint.
22:46:30 * hackage arbor-lru-cache 0.1.1.1 - LRU cache based on STM  https://hackage.haskell.org/package/arbor-lru-cache-0.1.1.1 (arbornetworks)
