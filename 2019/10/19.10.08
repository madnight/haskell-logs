00:02:25 <EvanR> if has had eager evaluation, foldl's definition would actually make sense
00:02:56 <EvanR> and foldr wouldn't
00:05:19 <EvanR> s/has/haskell/
00:10:32 <jsomedon> EvanR: so, in your foldr on "hello" example
00:10:50 <jsomedon> when it iterate on the first char, the 'h'
00:11:05 <jsomedon> the f, which is \x rest -> succ x
00:11:13 <jsomedon> never really make use of rest
00:11:18 <EvanR> right
00:11:29 <jsomedon> and in this step, rest is "ello"
00:11:31 * hackage crypto-rng 0.1.1.0 - Cryptographic random number generator.  https://hackage.haskell.org/package/crypto-rng-0.1.1.0 (MikhailGlushenkov)
00:11:36 <EvanR> no
00:11:40 <jsomedon> uhm?
00:11:52 <jsomedon> ah
00:11:56 <jsomedon> no it's not
00:11:58 <jsomedon> it's ah..
00:12:00 <jsomedon> somethign
00:12:09 <jsomedon> that I will get in future
00:12:13 <EvanR> foldr f '0' "hello"
00:12:16 <jsomedon> like foldr on ello
00:12:36 <EvanR> f 'h' (foldr f '0' "ello")
00:12:41 <jsomedon> ah yes
00:13:24 <jsomedon> so this rest is never used by the function, so haskell simply won't evaluet it
00:13:30 <EvanR> right
00:13:33 <jsomedon> so the iteration stops here..
00:13:34 <jsomedon> ha
00:13:46 <jsomedon> thanks guys, this is very helpful
00:13:46 <EvanR> that's why the second version with infinite list still works
00:13:51 <jsomedon> I see
00:14:14 <jsomedon> I always thought it's right to left..
00:14:17 <EvanR> and more generally why infinite lists can even exist
00:16:13 <EvanR> the real power rune here is knowing how functions are applied
00:16:28 <EvanR> the arguments aren't evaluated first
00:16:42 <EvanR> that solves a lot more than the mysteries of foldr
00:20:03 <koz_> foldr is a very useful thing - get comfortable with it, because you'll be using it a lot.
00:20:32 <koz_> Also, speaking of foldr - EvanR, are you now convinced that foldr is equipotent with general recursion?
00:21:18 <EvanR> no, because (prepares something)
00:21:55 <koz_> I believe the TMR6 article I directed at you shows that it's capable of expressing Y.
00:21:56 <dminuoso> koz_: Is it equipotent?
00:21:58 <[Leary]> Only in the presence of an infinite list.
00:22:13 <[Leary]> Which is kinda hard to get without recursion.
00:22:52 <EvanR> righhht..
00:22:55 <koz_> dminuoso: I kept hearing that. Then EvanR called me on it. So I dragged out some material which I believe shows that.
00:23:50 <EvanR> koz_: so foldr is basically the classic list eliminator. It's the go to way to define functions on lists when your language has nothing else. The corresponding thing for natural numbers is this thing... basically called primitive induction
00:24:07 <EvanR> and it's established that primitive induction falls somewhat short of general recursion
00:24:29 <EvanR> i mean, primitive recursion
00:24:39 <EvanR> also known as "induction"
00:24:40 <koz_> Yeah, _that_ I can agree to.
00:24:54 <koz_> Because primitive recursive functions are a subset of mu-recursive functions.
00:25:05 <koz_> (assuming I recall the right Greek letter)
00:25:08 <EvanR> so when [Leary] said it works if the list is infinite, is primitive recursion able to do general recursion if you feed in an infinite natural number?
00:25:21 <koz_> EvanR: There _is_ no infinite natural number.
00:25:27 <EvanR> there is in haskell
00:25:53 <koz_> EvanR: In what sense?
00:26:03 <EvanR> iterate S
00:26:35 <koz_> I think the fix-via-foldr example given in TMR6 uses 'repeat undefined' to make its list.
00:26:39 <koz_> @src repeat
00:26:39 <lambdabot> repeat x = xs where xs = x : xs
00:26:53 <EvanR> let inf = S inf in inf
00:27:54 <koz_> Knot-tying stuff still breaks my brain.
00:28:14 <EvanR> it's basically an S in the heap that points to itself
00:28:42 <koz_> What about repeat up there?
00:28:53 <EvanR> thats a cons cell that points to itself
00:28:58 <koz_> Ah, so it's like
00:29:07 * koz_ needs an online doodle thing.
00:30:12 <koz_> Never mind, can't find one, but I think I get it.
00:30:59 <koz_> Is there a way we can use that to write a cyclic list of _two_ cons cells?
00:31:15 <koz_> Would that be something like
00:31:23 <EvanR> let us = x:y:us in us
00:31:28 <koz_> repeat2 x y = xs where xs = x : y : xs ?
00:32:29 <koz_> Is there actually a difference between let and where definitions, syntax aside?
00:32:34 <EvanR> no
00:33:12 <koz_> Ah, so basically two ways to do the same thing, got it.
00:33:41 <koz_> OK EvanR, I also heard the claim being made that foldl is equipotent to tail recursion.
00:33:44 <jsomedon> EvanR: how exactly can I make a con cell pointing itself in Haskell code..
00:33:50 <koz_> jsomedon: Just as above.
00:33:56 <jsomedon> huh?
00:34:01 <koz_> iTouchMyself x = xs where xs = x : xs
00:35:06 <EvanR> lol
00:35:20 <Cortex> hello!
00:35:55 <jsomedon> this right hand side looks so confusing
00:36:32 <jsomedon> this `xs` comes out of no where
00:36:41 <EvanR> try this
00:37:06 <EvanR> > let us = '0' : '1' : us in us
00:37:08 <lambdabot>  "010101010101010101010101010101010101010101010101010101010101010101010101010...
00:37:13 <dminuoso> @src cycle
00:37:13 <lambdabot> cycle [] = undefined
00:37:13 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
00:37:29 <EvanR> where is good in production code, but it compiles into let
00:37:30 <jsomedon> uh
00:37:41 <EvanR> understand let, which is just an expression
00:38:16 <koz_> EvanR: Ah, so everything is let in the end.
00:38:17 <jsomedon> let some_variable_assignemnt in some_expression?
00:38:52 <koz_> Can we have let with type sigs? Wheres can have them.
00:38:56 <EvanR> yes
00:39:07 <koz_> jsomedon: Here's another motivating example:
00:39:16 <EvanR> > let x::Char; x='a' in (x,x)
00:39:18 <lambdabot>  ('a','a')
00:39:31 <koz_> pingPong x y = ping where ping = x : pong; pong = y : ping
00:39:47 <koz_> That should make the self-reference a bit more obvious.
00:39:56 <MarcelineVQ> "<koz_> EvanR: Ah, so everything is let in the end." let and case
00:40:13 <koz_> MarcelineVQ: How does case feature here?
00:40:25 <dminuoso> jsomedon: I tend to think of haskell evaluation as a pointer zipping around in my code. Using that intuiion, if you evalutae `us` you jump into its definition, you find some '0' cons'ed to some '1' consed to some us, to get us you jump do its definition, finding some '0' cons'ed to some '1' and some us... and so forth.
00:40:41 <EvanR> let defines recursive relationships, case expresses the computation rules that analyze data
00:41:14 <jsomedon> dminuoso: ah
00:41:20 <jsomedon> dminuoso: that's helpful
00:41:22 <koz_> EvanR: Like pattern matching?
00:41:39 <koz_> dminuoso: How does mdo fit into that picture?
00:41:49 <EvanR> pattern matching can be compiled into a more basic version of case
00:41:54 <dminuoso> koz_: its just syntax sugar in the end
00:43:25 <dminuoso> jsomedon: The relevant part is that evaluation stops whenever a data constructor or a lambda is encountered. :)
00:44:11 <koz_> dminuoso: Is that WHNF?
00:44:54 <EvanR> that's what WHNF is and i wish we had a better name for it :)
00:45:41 <EvanR> WHNF is what allows the more basic case to work, or for function application to work
00:45:51 <EvanR> that's why we care
00:46:32 <koz_> @src foldl
00:46:32 <lambdabot> foldl f z []     = z
00:46:33 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
00:46:46 <koz_> @src foldl'
00:46:46 <lambdabot> foldl' f a []     = a
00:46:46 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
00:47:53 <EvanR> foldl' exactly implements what i was saying about "if haskell did eager evaluation"
00:49:26 <jsomedon> dminuoso: uhm, you mean, if I make a function, and in my function definition such self-pointing value appears somewhere, then until such self-pointing value is used by calling this function, such self-pointing value is never evaluated?
00:52:17 <EvanR> that's the essence of lazy evaluation, nothing is evaluated until it's "used" (needed)
00:52:22 <EvanR> self-pointing or not
00:52:35 <koz_> Haskell basically goes 'I'll leave doing anything until as late as possible cause laziness'.
00:52:46 <koz_> So you can go
00:52:52 <koz_> 'Hey Haskell, gimme all the natural numbers!'
00:52:58 <koz_> And Haskell will go
00:53:00 <koz_> 'Sure'
00:53:04 <koz_> and then do nothing.
00:53:08 <EvanR> lol
00:53:25 <EvanR> yeah
00:53:30 <koz_> Then you say 'Hey Haskell, pair those off with lowercase Latin letters!'
00:53:35 <koz_> And Haskell will go 'Sure'.
00:53:40 <koz_> And then _still_ do nothing.
00:54:06 <koz_> Then you go 'OK, that's the first element of that?'
00:54:29 <koz_> Then Haskell grumbles and actually does some work, but only enough to deliver (0, 'a'), and then goes 'You know what, I'll do the rest later.'.
00:54:37 <koz_> 'You don't want them now anyway.'
00:55:16 <Lycurgus> even when u said strict?
00:55:50 <jsomedon> I think I get that picture, just I am not sure what dminuoso means by "evaluation stops when ctor/lambda is encountered"
00:56:22 <koz_> Lycurgus: That's me standing over Haskell and making it work.
00:56:35 <koz_> jsomedon: Consider the above example of 'gimme all the natural numbers'.
00:56:52 <koz_> When I first make the request, Haskell will evaluate out to the Cons list constructor
00:56:59 <koz_> So you'd get like Cons _ _
00:57:06 <koz_> Where _ is 'I haven't figured this out yet'.
00:57:14 <koz_> Until I demand more than that, Haskell will just leave it be.
00:57:26 <jsomedon> ah
00:57:30 <jusss`> dminuoso: I found an anwser is like your anwser a few days ago, about that recursive type, https://stackoverflow.com/questions/18249583/infinite-type-error-when-returning-a-self-referential-function-in-haskell       but I still don't know what this means...
00:57:32 <EvanR> if you were analyzing "all natural numbers", you basically only need the _:_
00:57:43 <koz_> Then if I go 'OK, what's the second element of that?', Haskell will go
00:57:49 <EvanR> to decide if its [] or not
00:57:50 <koz_> _:1:_
00:57:52 <jusss`> about the anwser, I can't understand why create an new value constructor can solve that
00:57:54 <Lycurgus> koz_, that's me implicitly equating Haskell and GHC
00:58:13 <koz_> Lycurgus: Yeah, I do that too. Although I shouldn't.
00:58:22 <jsomedon> ok so that covers data ctor
00:58:27 <jsomedon> how about lambda
00:58:27 <EvanR> if you did something more complex that involved the actual numbers, more would need to be evaluated
00:58:42 <koz_> For lambda, I bow out to the smarter folks around me.
00:58:46 <koz_> Such as dminuoso.
00:59:21 <EvanR> jsomedon: you have to imagine that whatever work you want to do comes in the form of a case analysis (on data) or function application
00:59:28 <jusss`> how this trick can solve recursive type, can make function to return itself without product an infinite type
00:59:31 <jsomedon> ok
00:59:33 <jsomedon> then?
00:59:36 <EvanR> you can't case analyze without having the ctor
00:59:42 <EvanR> you can't apply a function without the lambda
00:59:45 <Lycurgus> as far as compilers are concerned, lambda, function pointers, etc. are like "and then a miracle happened"
01:00:14 <EvanR> so WHNF is a natural next question
01:00:41 <[Leary]> Lambda is just opaque; its only interface is application so there's nothing to evaluate without an argument.
01:00:44 <Lycurgus> *happens
01:00:54 <koz_> Basically, we now need 'Learn Evaluation with Haskell-chan', featuring an animu mascot who's always napping. :P
01:01:35 <jsomedon> so, you mean it lazily stops if, say it sees code like `f a` then it stops and be like "I am not gonna actually execute f with arguement a unless I really have to" EvanR is this what you mean
01:01:44 <merijn> jusss`: Infinite types are problematic because they bork the typechecker. Consider "x = [x]" what's the type of 'x'?
01:02:18 <merijn> jusss`: Obviously it's an infinitely nested [], but there's no way to work with infinite nestings in the compiler, you'd just loop forever
01:02:38 <jsomedon> [[[[[[[[[...]]]]]]]]]]
01:02:46 <EvanR> jsomedon: you told it to reduce f a to WHNF (for whatever reason). But you can't apply f to a without f being first reduced to a lambda
01:02:57 <merijn> jusss`: By going "newtype Foo = MkFoo [Foo]" you insert a sort of loopbreaker
01:03:05 <ski> (it's not that hard to adapt a type-checker to be able to work with such infinite types. however, enabling them would make a lot of common mistakes into strange inferred types, rather than type errors)
01:03:22 <jsomedon> EvanR: what is WHNF
01:03:29 <merijn> "x = Foo [x]" What's the type of 'x'? "Foo", done. What's inside a "Foo"? A list, containing a Foo.
01:03:39 <ski> (if you want to play with such types, try `ocaml -rectypes')
01:03:43 <koz_> merijn: Is this similar to the Fix type recursion schemes use?
01:04:03 <EvanR> jsomedon: a data constructor expression, or lambda expression
01:04:05 <merijn> jusss`: Note that now none of the questions ever have to deal with an uncomfortable answer that requires infinite unrolling to answer
01:04:15 <EvanR> jsomedon: see, f a isn't that
01:04:17 <merijn> koz_: Fix is a newtype (instead of a type alias) to workaround this, yes
01:04:33 <jsomedon> EvanR: right? and your point is?
01:04:42 <merijn> koz_: Fix is one of the most common "infinitely nested" types
01:04:55 <EvanR> jsomedon: how far back are we going? or are we in an infinite loop of points
01:06:16 <merijn> jusss`: Wanting to nest an infinite/indefinite number of times isn't wrong, doing it "directly" just makes the type checker infinite loop while checking things (therefore making it impossible to handle them directly)
01:06:27 <jsomedon> EvanR: so you mean,`f a` needs to become WHNF first, and what lazily-stop means is stopping when it's about to turn some code into WHNF? is this what you mean?
01:07:34 <EvanR> our hypothesis is we want f a in weak head normal form. To do that we need to apply f to a. To accomplish this with least work, first reduce f to WHNF. (hence providing a possible reason we are even asking :)
01:07:51 <EvanR> time loop closed
01:08:28 <EvanR> ultimately, you want data constructors so the I/O system or arithmetic can operate
01:08:47 <EvanR> but it only needs a few at a time
01:28:11 <jusss``> merijn: sorry about the bad network, I just saw your anwsers, what is the Foo of "x = Foo [x]"? a function? a value constructor?
01:29:12 <dminuoso> jusss``: Its both a function and a data constructor.
01:29:37 <jusss``> dminuoso: then how it's defined?
01:29:57 <dminuoso> jusss``: I think merijn made a typo and meant to write `x = MkFoo [x]`
01:30:18 <jusss``> is this related fix-point stuff?
01:30:26 <jusss``> y combinator?
01:30:46 <merijn> jusss``: x is a variable with type Foo and value "Foo [x]"
01:30:55 <merijn> eh, yes
01:31:06 <merijn> jusss``: Foo is is Fix specialised to Foo, yes
01:31:44 <jusss``> merijn: I just know the name and I never understand it 
01:33:13 <jusss``> merijn:  x = Foo [x]   but x is a variable, not a function name, how we canuse  x = Foo [x] to define function Foo?
01:34:25 <jusss``> Foo [x] = x?
01:39:36 <jsomedon> for second solution of the puzzle: writting dropWhile using fold(mentioned in the Monad.Reader: https://wiki.haskell.org/wikiupload/1/14/TMR-Issue6.pdf) so really there are two rounds of iteration right? first round is when it compose function, second round is when it drops stuff using compossed function from first round? and both round iterates until the same stop point where it actually start
01:39:37 <jsomedon> not dropping things?
01:42:18 <jsomedon> I mean, it really is two rounds of iterations right? and both round iterates same amount of steps right?
01:45:55 <merijn> jusss``: Fix is "I have a Functor and I want to nest it an infinite number of times"
01:46:36 <merijn> jusss``: So Foo was nesting lists an infinite number times, but we could also, say, want to infintely nest Maybe, or "Either e", etc.
01:47:31 <merijn> jusss``: "newtype Fix f = MkFix (f (Fix f)"
01:48:09 <merijn> jusss``: So, say, "Fix Maybe" is "a MkFix constructor containing 'Maybe (Fix Maybe)" inside it
01:49:37 <merijn> Now, Fix with Maybe is usually not very interesting, because it's just going to be a bunch of "Just" until you eventually (maybe...) hit a Nothing
01:50:47 <int-e> jsomedon: Hmm. I came up with a single foldr that produces a pair of lists... one being the result of dropWhile, the other being a reconstruction of the original list.
01:51:42 <jsomedon> int-e: sounds like the first solution mentioned in the pdf?
01:51:50 <int-e> jsomedon: I didn't look at the pdf.
01:51:53 <jsomedon> oh
01:53:07 <jusss``> merijn: how we implement the MkFix function?
01:53:29 <int-e> jsomedon: But yes, it's the first solution.
01:53:30 <jusss``> merijn: your examples is like binary tree
01:53:41 <merijn> jusss``: Suppose we define "data Foo b a = Foo b a | Nil" now if we look at "Fix (Foo a)" we get...[a]! "Fix (Foo a)". Let's see what's inside Fix. We see MkFix which has a "Foo a (Fix (Foo a))" so it has an element 'a' and another "Fix (Foo a)", alternatively inside our MkFix we find "Nil" and the list is finished
01:54:05 <merijn> jusss``: "newtype Fix f = MkFix (f (Fix f)" <- this *is* the definition of MkFix
01:54:30 <jusss``> data Tree a = Leaf a | Node (Tree a) (Tree a) deriving (Show)
01:55:36 <merijn> jusss``: You could also do trees using Fix, yes. "data TreeF a b = Leaf a | Node b b" then "Fix (TreeF a)" becomes equivalent to "Tree a"
01:55:37 <jusss``> merijn: the function form of MkFix?
01:55:54 <merijn> jusss``: MkFix is a constructor, just like Just or Nothing
01:56:03 <int-e> jsomedon: so regarding your question, yes, this will make two passes over the list.
01:56:42 <jusss``> merijn: this confused me, data constructor is function or not?
01:57:18 <merijn> jusss``: Yes, no, maybe. It depends on how you define "is" and function. They have a function type, yes
01:57:20 <jusss``> newtype or data are used to define types
01:57:43 <jusss``> merijn: f x = x, this is a function
01:57:59 <ski> `newtype' and `data' are used to define type constructors, and associated data constructors
01:58:12 <jusss``> merijn: f Int :: Int , this is a function type signature
01:58:40 <ski> some data constructors (like `Just',`MkFix') are functions. some are not (like `Nothing',`False',`True')
01:59:02 <dminuoso> jusss``: We've been interacting for a while now, and it is my honest opinion that what you are doing is ineffective.
01:59:20 <ski> `f Int :: Int' is not a function type signature
01:59:21 <jusss``> ski: and do those Just MkFix have a function form? or can those turn to lambda expressions?
01:59:47 <dminuoso> jusss``: You seem to digress in topics that are not relevant for writing effective Haskell code and, at the same time, far outside your reach. :)
01:59:49 <ski> `Just' is already a function. not sure what you mean by "function form"
02:00:02 <jusss``> dminuoso: I just feel it's so hard to return function itself within those static type-checked languages...
02:00:14 <ski> `Just' is equal to `\x -> Just x'. that's a lambda expression
02:00:50 <dminuoso> jusss``: I think the main problem is that you still conflate functions and actions - if you properly understood the difference, you wouldn't even be asking about "how can a function return itself".
02:01:02 <dminuoso> jusss``: (Im saying this, because I know why you are chasing this stopic)
02:01:20 <jusss``> dminuoso: sorry, I should stop
02:02:02 <dminuoso> jusss``: It's just my opinion. If you want to carry on, feel free to - but when after weeks you still have difficulties with this, I think you could spend your time more effectively and visit this topic later when you have basic type level competencies.
02:04:15 <dminuoso> jusss``: The original topic came up when you asked for the equivalent of `f(1)(2)(3)` where f would print a value, and then return itself. In Haskell you'd just write `f 1 >> f 2 >> f 3 ...` there's little point in f returning itself, since you already have access to f.
02:04:46 <dminuoso> Or, equivalently: traverse_ f [1,2,3,...]
02:05:37 <koz_> Yay traverse_. Probbo my favourite function.
02:05:44 <dminuoso> And even here, the notion of "a function returning something" and "f executing some actions" are orthogonal things. You are just chasing the function part, but we cant express printing something in a function.
02:05:57 <koz_> How would you even pronounce 'traverse_'? 'Traverse underscore'?
02:06:32 <merijn> dminuoso: Well, you can, it just doesn't mean what you'd naively expect it to mean from other languages :p
02:07:14 <dminuoso> merijn: The point Im getting at, is that a function itself doesn't do the printing.
02:07:21 <dminuoso> (Ignoring things like unsafePerformIO for sanity)
02:08:35 <dminuoso> So "a function that first prints something and then returns itself" would rather be expressed as some `f ~ Int -> IO f`
02:11:45 <ski> @let newtype Consumer m a = Consume {applyConsumer :: a -> m (Consumer m a)}
02:11:46 <lambdabot>  Defined.
02:12:29 <ski> @let printConsumer :: Show a => Consumer IO a; printConsumer = Consume (\a -> do print a; return printConsumer)
02:12:30 * hackage mollie-api-haskell 0.2.0.2 - Mollie API client for Haskell http://www.mollie.com  https://hackage.haskell.org/package/mollie-api-haskell-0.2.0.2 (tolgapaksoy)
02:12:31 <lambdabot>  Defined.
02:14:22 <ski> @type printConsumer `applyConsumer` 0 >>= (`applyConsumer` 1) >>= (`applyConsumer` 2)
02:14:23 <lambdabot> (Show a, Num a) => IO (Consumer IO a)
02:14:53 <ski> (that's rather clunky, though)
02:17:04 <ski> @let printAccumulator :: (Show a,Num a) => Consumer IO a; printAccumulator = loop 0 where loop acc0 = Consume (\n -> do let {acc1 = acc0 + n}; print acc1; return (loop acc1))
02:17:06 <lambdabot>  Defined.
02:23:38 <jusss```> dminuoso: actually I'm not chasing about the printing stuff, 
02:30:44 <dminuoso> ski: This smells like there's a monad transformer hidden.
02:33:56 <ski> well, this one is contravariant in `a'
02:35:16 <maerwald> you're smelling a contravariant transformer?
02:47:00 * hackage stylish-haskell 0.9.3.0 - Haskell code prettifier  https://hackage.haskell.org/package/stylish-haskell-0.9.3.0 (JasperVanDerJeugt)
02:57:16 <jsomedon> int-e: I see, thanks :-)
02:59:33 <bwe> I don't understand   :t \p -> p %= \oldValue -> newValue
02:59:41 <bwe> from https://stackoverflow.com/questions/20626963/haskell-lenses-getters-and-setters
03:00:39 <bwe> What does %= actually do?
03:00:47 <bwe> How do I use this operator?
03:03:46 <int-e> :t (Control.Lens.%=)
03:03:47 <lambdabot> MonadState s m => ASetter s s a b -> (a -> b) -> m ()
03:04:31 <phadej> it's a fancy `modify`
03:04:47 <phadej> :t Control.Monad.State.modify
03:04:48 <lambdabot> MonadState s m => (s -> s) -> m ()
03:05:17 <bwe> I actually want to use set and view ops in a function at the same time. Is this the right tool for this?
03:05:23 <phadej> :t \setter f -> Control.Monad.State.modify (over setter f)
03:05:24 <lambdabot> MonadState s m => ASetter s s a b -> (a -> b) -> m ()
03:07:10 <phadej> bwe: you might want `over`
03:22:16 <bwe> phadej: I've created a minimum non-working example: https://repl.it/repls/CarefreeRedWebsphere
03:23:00 * hackage ghc-typelits-knownnat 0.7.1 - Derive KnownNat constraints from other KnownNat constraints  https://hackage.haskell.org/package/ghc-typelits-knownnat-0.7.1 (ChristiaanBaaij)
03:25:38 <phadej> bwe: you want to take ALens argument and use https://hackage.haskell.org/package/lens-4.18.1/docs/Control-Lens-Lens.html#v:cloneLens or ^# / #%~ (below in the same module). The reasons are technical, something you don't have problems with using `optics` (https://hackage.haskell.org/package/optics, shameless plug). There you can just take Lens' Drawers Drawer and view/over would just work
03:26:05 <phadej> TL;DR there are no short explanation
03:28:35 <bwe> phadej: OK, if I just use view, over, set from Lens right now, can I simply use Optics as a drop-in replacement?
03:33:59 <sshine> bwe, optics uses a different composition operator.
03:34:03 <phadej> in that example it would work, but the `Lens` type is different in `lens` and `optics`: https://gist.github.com/phadej/f9cca25ea57c86e0dd1a1bae76fbe3cf
03:34:10 <phadej> yes, . -> % (I mention that)
03:34:17 <sshine> ok
03:34:38 <phadej> but if you have to use other libraries using `lens` representation of lenses, then one need to convert things
03:34:48 <phadej> but in isolated things, optics works just well
03:36:23 <bwe> phadej: Thanks a bunch! I'll try that out.
03:36:36 <phadej> hmm, or you could just write `Lens' Drawers Drawer` in `lens` code too - and enable RankNTypes
03:39:53 <boxscape> hm, for some reason "test :: Int; test @5 = 4" compiles in HEAD
03:40:04 <boxscape> I'm trying to figure out what the story behind that is
03:40:21 <boxscape> oh wait
03:40:27 <boxscape> no never mind
03:40:45 <boxscape> is it just an at pattern?
03:41:52 <boxscape> yeah, it is
03:42:07 <cheater> what is the current consensus on the best general purpose property testing library? quickcheck, smallcheck, smartcheck, hedgehog? i don't have very complicated code to test, i just want to generate some data structures with numbers in them, and ensure that if f a b c returns true, then a + b > c
03:42:32 <boxscape> (I think I got confused with having -XTypeApplications turned on or off between different versions)
03:44:58 <Philonous> Oh wow, that's actually confusing. So. test @2 = 4 is something like let test = 4 in case test of 2 -> test  
03:45:16 <boxscape> yeah
03:45:23 <Philonous> Fun
03:45:59 <boxscape> I thought I was looking at the first implications of https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0155-type-lambda.rst
03:46:02 <boxscape> but apparently not
03:46:44 <Guest5331> yovyeahh
03:47:09 <Philonous> Oh, true, the proposal steals syntax. Wonder if that's been discussed
03:47:31 <Guest5331> bebişim 
03:47:35 <boxscape> it has, it's under Effects and Interactions, the first point, Philonous
03:47:35 <Guest5331> aşkim 
03:47:41 <Guest5331> ciğerim
03:48:36 <Philonous> Ah, good. 
03:51:28 <Taneb> Is there any writing about the nitty-gritty details of BlockedIndefinitelyOnMVar?
03:55:12 <phadej> Taneb: yes, e.g. http://blog.ezyang.com/2011/07/blockedindefinitelyonmvar/ and http://blog.ezyang.com/2011/07/blockedindefinitelyonmvar/ (where latter shows an example where it's annoying)
03:56:10 <cheater> specifically what i'm looking for most is usability, like integrations with a testing framework or nice output, rather than ultimate speed or a specially strong abstraction
03:56:13 <Taneb> phadej: that's the same link twice
03:56:22 <phadej> https://www.fpcomplete.com/blog/2016/06/async-exceptions-stm-deadlocks the latter
03:56:25 <phadej> Taneb: ^
03:56:30 <Taneb> phadej: thank you!
03:59:26 <phadej> TL;DR it's a heuristic to not leak blocked threads, which usually works, but sometimes you have to be aware of it
04:02:00 <sshine> I've got a Megaparsec parser that is too greedy: https://gist.github.com/sshine/f8d984afc4975c38732b8455134e2fa1 -- it seems that the 'modulePart' is eating the characters and expects a "::", and fails without backtracking to let 'part' eat the last bit.
04:03:08 <phadej> now I wonder what erlang VM does, where there a process blocked in receive, but no-one have that process pid anymore... (or is there some global registry, so "someone" always have?)
04:03:19 <sshine> so I should somehow make 'modulePart' backtrack . is that 'many (try modulePart)', I wonder.
04:04:03 <sshine> phadej, that last part, I think, is true.
04:04:14 <phadej> many (try ...) will fail, as many should be given something which consumes at least one character
04:05:00 <sshine> phadej, registered/0 returns all processes for a VM node, I think.
04:05:07 <merijn> sshine: I haven't looked at your code, but I bet this is useful for you: http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
04:05:27 <sshine> merijn, yeah, thanks.
04:06:05 <sshine> so maybe I should rewrite my grammar into LL(1) and parse many '::part'
04:06:24 <sshine> thanks!
04:06:30 <cheater> any idea why i'm getting "unexpected where" here? http://paste.ubuntu.com/p/PwHWsHCN5B/
04:06:47 <sshine> cheater, missing 'else'
04:06:55 <cheater> else is below
04:07:07 <sshine> cheater, it expects 'else' but gets 'where', so the 'where' is unexpected.
04:07:18 <sshine> cheater, oh, you can't put a 'where' in the middle of an if-then-else.
04:07:21 <merijn> cheater: where attaches to bindings, they can't be in random places
04:07:23 <cheater> like this https://paste.ubuntu.com/p/355TnCkmSB/
04:07:30 <sshine> cheater, 'where' come at the end of declarations.
04:07:40 <cheater> how do i attach "where" inside the "then" clause?
04:07:43 <sshine> cheater, if you need to make a temporary binding in the middle of something, use 'let-in'
04:07:52 <merijn> cheater: You don't. You use let/in
04:07:56 <cheater> ok
04:07:57 <cheater> thanks
04:08:09 <sshine> cheater, or just put the 'where' at the bottom.
04:10:37 <cheater> i have considered that
04:10:43 <cheater> i'll just go with let instead, thanks
04:10:54 <cheater> any suggestions on what property testing lib to use?
04:11:09 <cheater> i have some comments in the scollback ~15 minutes ago
04:11:21 <cheater> and 30
04:12:30 <sshine> cheater, QuickCheck or Hedgehog.
04:12:34 <cheater> thanks
04:12:45 <cheater> why would i use one over the other?
04:12:58 <cheater> i've looked into hedgehog some time ago and chose not to use it
04:13:11 <sshine> cheater, Hedgehog has a bit of a learning curve, I think.
04:13:40 <sshine> cheater, I mean, so does QuickCheck. but I'm used to QuickCheck and find Hedgehog a little difficult. :)
04:13:53 <sshine> cheater, there are better tutorials and examples for QuickCheck.
04:15:13 <sshine> cheater, it depends on where you want to place your learning goals. both QuickCheck and Hedgehog integrate well with other test frameworks.
04:15:39 <cheater> what's the difference in their integration?
04:15:42 <cheater> thanks
04:15:51 <sshine> cheater, what do you mean?
04:16:00 * hackage monoid-subclasses 1.0 - Subclasses of Monoid  https://hackage.haskell.org/package/monoid-subclasses-1.0 (MarioBlazevic)
04:16:22 <sshine> cheater, I don't know if there is a significant difference. I just mean, you can test a property via Hspec or Tasty.
04:16:47 <cheater> thanks. wouldn't you use testing-framework instead?
04:17:12 <sshine> cheater, it's not an either-or.
04:17:24 <merijn> I like hspec, personally
04:17:28 <sshine> me too
04:17:31 <merijn> eh
04:17:36 <sshine> but I like the output format of Tasty.
04:17:39 <merijn> what, why did I write hspec...
04:17:43 <sshine> haha
04:17:45 <merijn> I hate hspec, I meant tasty >.<
04:17:46 <sshine> freudian slip.
04:18:01 <cheater> OK
04:18:04 <cheater> thanks
04:18:14 <cheater> so i'll try tasty and hedgehog, just to learn something new, perhaps.
04:18:40 <merijn> cheater: Basically, hspec uses typeclasses to write a "pseudo-english" DSL (which I dislike, because it makes type errors more confusing/annoying and hard to see what things are)
04:18:41 <sshine> cheater, you should probably ask yourself what you want to learn about, and then solve the things you don't want to learn about with simple means.
04:19:06 <cheater> i'm not sure how to answer that question.
04:19:15 <cheater> merijn: and tasty?
04:19:33 <sshine> cheater, basically, hspec uses typeclasses to write a "pseudo-english" DSL (which I like, because the test code reads out nicely, but you're playing two games, because the test output errors don't necessarily look nice.)
04:19:34 <merijn> cheater: tasty just uses regular datatypes to work and looks more like "just code", both support most testing libraries
04:20:05 <cheater> OK
04:20:34 <cheater> so what does that code look like? e.g. if i want to generate a simple data type like data Foo = Bar Int
04:20:49 <sshine> cheater, what's the question?
04:21:07 <cheater> sshine: i don't know how to answer the question you posed, which is "what i want to learn about"
04:21:20 <cheater> tbh i don't really need to learn about anything, i just want to write some property tests :)
04:21:50 <cheater> therefore i'm not sure what there /is/ to learn and which i would prefer between the options we've discussed.
04:21:59 <sshine> cheater, ah. well, there's just so much. testing frameworks is a subject of itself, so if you just go with e.g. tasty, you're probably covered for a while.
04:22:13 <Rembane> cheater: Pick one, and start coding. 
04:22:13 <sshine> cheater, if you only want to write property tests, you can use QuickCheck alone.
04:23:04 <merijn> cheater: With tasty you just have a datatype "TestTree" and a functions "testGroup :: [TestTree] -> TestTree" (and the various libraries like tasty-quickcheck and tasty-hunit, etc. provide ways to making single tests to combine in group with testGroup)
04:23:40 <merijn> cheater: So just start with, say, quickcheck and write some stuff. Then you look at tasty-quickcheck how to wrap them up into groups/testsuites
04:24:40 <sshine> cheater, shortest path is: write some property prop_Whatever, and do 'main = quickCheck prop_Whatever'
04:24:41 <merijn> cheater: Then if you decide you want to customise (like run in parallel, filtering, configuration, setup, etc.) you can use the stuff from tasty to add more stuff and run those tests
04:25:07 * sshine just used Tasty filtering for the first time today.
04:25:28 <merijn> sshine: Do you use travis?
04:25:33 <sshine> merijn, not yet.
04:25:35 <sshine> merijn, why?
04:25:39 <sshine> merijn, I mean, not for this project.
04:25:53 <merijn> sshine: Because I have a fancy tasty plugin that adds colours and folding to travis output ;)
04:26:07 <sshine> merijn, oohh, I'd like that. :)
04:26:13 <merijn> @hackage tasty-travis
04:26:13 <lambdabot> http://hackage.haskell.org/package/tasty-travis
04:26:39 <merijn> sshine: https://travis-ci.org/merijn/broadcast-chan/jobs/569443636#L1442
04:26:51 <merijn> sshine: See the triangles on the left of the line that you can expand :)
04:27:10 <sshine> I have a related bug: https://github.com/exercism/haskell/issues/783 -- I'd like to avoid the red colors on 'stack test' runs that are supposed to fail. (or do something else so the red colors don't show up.)
04:27:11 <merijn> It can also out-unfold trees containing failed tests, etc.
04:27:50 <sshine> merijn, I've been interested in making Travis output fold, so it's nice to see that you've done the legwork.
04:28:05 <boxscape> Is there some library that abstracts over file system interaction, so you don't have to CPP between System.Posix.IO and System.Win32.File?
04:28:50 <merijn> boxscape: System.Directory?
04:29:25 <merijn> And the related System.FilePath ?
04:29:25 <cheater> makes sense. thanks
04:29:39 <boxscape> merijn ah, yeah, thanks
04:30:15 <sshine> cheater, good luck with QuickCheck. let us know how you progress.
04:30:26 <merijn> sshine: Also, you're aware of the haskell-CI project? (Not sure how well it works with stack, though...)
04:30:48 <sshine> merijn, I don't know? I have used 'language: haskell' and was pretty happy with it.
04:31:00 <sshine> merijn, ohhh, *that*.
04:31:17 <merijn> sshine: Haskell-CI lets you generate complex setups from your cabal file automatically for travis. It works really nicely :)
04:31:36 <merijn> Including build matrices, multi-ghc testing, etc.
04:33:17 <sshine> merijn, the .travis.yml it generates seem really bulky compared to https://kodimensional.dev/posts/2019-02-25-haskell-travis -- my needs are not currently beyond what that simple template gives me.
04:34:29 <cheater> sshine: thanks :)
04:34:50 <sshine> merijn, I guess most of the power lies in the line 'language: haskell'. I reduced build times for one package quite a lot just by using this template: https://github.com/kuribas/aeson-diff-generic/pull/2#pullrequestreview-287822158
04:38:01 <phadej> the key idea of haskell-ci is that .travis.yml is just some artifact, whether it's 1k or 2k in size, doesn't really matter
04:38:39 <merijn> sshine: Does that also take care of caching, trying with GHC HEAD, etc.?
04:38:56 <phadej> all features are motivated by mistakes people make when releasing packages (e.g. forgetting extra-source-files)
04:39:20 <merijn> Oh, right, testing sdist functionality too
04:40:00 <sshine> merijn, it takes care of some caching, and no, there's a lot of stuff it doesn't.
04:40:27 <merijn> phadej: Incidentally, as I also posted on github, GitHub actions is actually very flexible in supporting versioned workflows/actions
04:40:53 <phadej> good to know
04:40:54 <sshine> merijn, I'll start using it when my needs make me write custom .travis.ymls :)
04:41:01 <merijn> phadej: So we could still do proper versioning of testing workflows if we keep most of the boilerplate inside haskell-ci repo
04:41:27 <phadej> sshine: the problem is that it's often too late to realise "i should have tested for that too"
04:42:01 <sshine> phadej, so what I mean is that I'll probably start using it before I release anything onto hackage. :P
04:42:35 <merijn> phadej: i.e. workflows are built of multiple actions which can be defined in the same repo OR a remote one and the action can *also* be tagged with various versioning schemes. So we could easily support both completely standalone static workflows, stable shared actions/workflows and experimental "state of the art"/beta branches. It's really looking quite cool
04:42:53 <merijn> phadej: I'll experiment in my own fork first (when I get around to it) and play a bit with what works
04:43:13 <phadej> merijn: good, as I said on the issue, I'm not one implementing anything of that
04:43:57 <merijn> phadej: But I think the idea of (opt-in) centrally updateable workflows is really cool (for example for automatically getting support for newer compilers, especially combined with their support for cron test jobs)
04:44:40 <sshine> it'd be cool if there was a "dependabot" for Haskell.
04:44:56 <phadej> that's against haskell-ci idea. it says tested-with: GHC ==8.8.1 so it won't accidentally say tested-with: GHC ==8.8.2
04:45:56 <phadej> of course if the specification is tested-with: GHC==8.8.* then one could add more jobs
04:47:04 <phadej> I don't really see a point. Those are changes that I as a package author want to be notified. "by the way, your package works well with 8.8.2 too"
04:47:11 <__monty__> phadej: That's kinda what merijn is saying though. You could specify a tagged workflow like "8.8.*".
04:47:25 <merijn> phadej: I'm not saying "ignore the specification", but right now if my repo is tested against "HEAD" but I don't update the travis.yml or my package at all then it never actually tests with the new releases
04:47:30 * hackage reanimate-svg 0.9.3.1 - SVG file loader and serializer  https://hackage.haskell.org/package/reanimate-svg-0.9.3.1 (DavidHimmelstrup)
04:48:41 <phadej> merijn: so? HEAD is special case, and haskell-ci **wont** ever do anything to encourage omittign upper bounds on base (i.e .having something stupid like <5)
04:50:02 <Philonous> Having the .<whatever>-ci.yaml in the same repo as the source code has always seemed conceptually odd to me. If the point is to specify a set of requirements that code has to pass before it can be admitted, why do we allow commits to carry and potentially modify the very requirements that they are supposed to be measured against
04:50:31 <Philonous> I supposed in practive you would notive when a pull request changes the CI instructions, but it still just seems off.
04:50:51 <Philonous> notice, even
04:51:09 <merijn> Anyway, I'll have to start playing with things first before suggesting too much blue sky thinking :p
04:52:03 <__monty__> The Github Actions make that weirder, Philonous. It used to be that the repo's travis config was run on PRs. With Github Actions the PR branch's CI config is run.
04:52:41 <phadej> __monty__: are you sure?
04:53:01 <__monty__> Yes.
04:53:03 <phadej> I'm 100% confident that the .travis.yml in the branch/merge commit is used for travis config
04:53:10 <sshine> yes.
04:53:18 <phadej> not the one in the "master" or whatever is the target branch
04:53:21 <merijn> Pretty sure phadej is right there
04:53:32 <__monty__> Oh, was talking about the Github Actions, side of things.
04:54:21 <merijn> __monty__: Now we just need dhall-to-actions >.>
04:54:23 <__monty__> Then yeah, nvm.
04:54:42 <sshine> that's incidentally a neat way to demonstrate changes to Travis: you submit a PR, Travis runs and documents the effect that the change has.
04:55:04 <__monty__> merijn: Wouldn't dhall-yaml be enough? Not as convenient, sure.
04:55:40 <merijn> __monty__: I meant more like dhall definitions for all the workflows like dhall-to-cabal
04:55:51 <Philonous> I feel like does two conceptually unrelated things at the same time: it specifies which tools and versions it is designed for and _also_ how to build it in the _current_ environment, where "current environment" is the one that happens to be relevant when the commit was cut. For example, if you move your project from github to gitlab you suddenly have a bunch of irrelevant data in your repo, even though the software itself was never in any 
04:55:51 <Philonous> way related to github
04:58:41 <phadej> yes, perfectly you'd have say `./validate.sh` and whatever CI would just run that
04:59:00 <phadej> but in practice theory doesn't work so well
04:59:38 <phadej> e.g. haskell-ci generates mammoth .travis.yml because it's conceptually simpler to "version" single file
05:00:57 <phadej> vs. approach where there are auxiliary scripts: then you'll need to update them too, and all the problems with conflicts
05:03:51 <phadej> it would be great if the haskell-ci generation could be done in some intermediate step, betwen github and travis, as to repeat .travis.yml is simply a committed artifact.
05:04:10 <phadej> the cabal.haskell-ci configuration is quite travis-independent
05:04:21 <phadej> configuration file
05:04:39 <merijn> phadej: Is that file format documented anywhere, btw?
05:05:00 <phadej> merijn: haskell-ci dump-config
05:05:29 <Philonous> Yes, was about to say, best would be to have all the actually relevant configuration in a yaml file and have a yaml-to-travis or yaml-to-gitlab tool (or maybe that file could be the *.cabal or stack.yaml).
05:05:48 <Philonous> In a import-from-derivation kind of way, as nix calls it
05:06:08 <merijn> phadej: ok, thanks
05:06:24 <merijn> Philonous: New backends for haskell-ci are welcome ;)
05:07:27 <merijn> Contribute to Haskell's world domination by superior tooling robustness!
05:07:47 <phadej> there's even some legwork done for gitlab, we have docker images!
05:08:21 <hpc> oh, speaking of
05:08:29 <hpc> if anyone is in the github actions beta, the haskell CI is broken
05:08:29 <phadej> https://gitlab.com/haskell-ci/haskell-ci/container_registry (which I could update at some point)
05:08:38 <hpc> you need to click through to the repo where it's defined and copy it from there
05:08:53 <hpc> what it gives you by default is missing an action to set up ghc/cabal/etc
05:09:26 <merijn> hpc: haskell-CI doesn't have github action support, so I'm nore sure what you mean?
05:09:43 <hpc> only vaguely related
05:09:48 <merijn> hpc: (Since we were just discussing I might work on that when I procrastinate from my thesis...)
05:10:15 <merijn> hpc: Or did you just mean that the default github action suggestion doesn't work
05:11:28 <hpc> that
05:11:51 <hpc> i just figured since we were already talking about ci
05:13:01 * hackage ChasingBottoms 1.3.1.7 - For testing partial and infinite values.  https://hackage.haskell.org/package/ChasingBottoms-1.3.1.7 (NilsAndersDanielsson)
05:34:30 * hackage ron-rdt 0.10 - Replicated Data Types (RON-RDT)  https://hackage.haskell.org/package/ron-rdt-0.10 (cblp)
05:40:50 <fendor> cabal build fails: https://hastebin.com/rilevijuni.coffeescript what am I missing? I am on nixos and the shell nix looks like this:https://hastebin.com/gemimapone.bash
05:52:18 <inkbottle> HIE: LSP :: Main.hs not in project or it is blacklisted. How do I "register" my files into the project (it's already a stack project)
06:05:36 <Unhammer> https://hoogle.haskell.org/?hoogle=%5B(a%2C%20%5Bb%5D)%5D%20-%3E%20%5B(a%2Cb)%5D :(
06:07:54 <boxscape> % undefined @Int
06:07:54 <yahb> boxscape: ; <interactive>:153:12: error:; * Expected kind `RuntimeRep', but `Int' has kind `*'; * In the type `Int'; In the expression: undefined @Int; In an equation for `it': it = undefined @Int
06:07:59 <boxscape> interesting error message
06:08:18 <Unhammer> (wanted `map (\(a,b) -> map (a,) b)` but I guess I'm getting too use-case-specific to hoogle)
06:08:39 <boxscape> % :t undefined @Int
06:08:40 <yahb> boxscape: ; <interactive>:1:12: error:; * Expected kind `RuntimeRep', but `Int' has kind `*'; * In the type `Int'; In the expression: undefined @Int
06:08:50 <boxscape> huh I got something else for that locallt
06:08:57 <boxscape> s/t/y
06:09:13 <boxscape> (it simply doesn't output anything on ghc 8.8)
06:10:32 <inkbottle> Is it me, or HIE isn't "really" working? Has anyone succeeded in using it?
06:11:31 * hackage ron-storage 0.11 - RON Storage  https://hackage.haskell.org/package/ron-storage-0.11 (cblp)
06:11:49 <lortabac> inkbottle: every time I tried it, it stopped working after ~1 week
06:12:16 <ski> % undefined @LiftedRep @Int
06:12:17 <yahb> ski: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:160:1 in interactive:Ghci49
06:13:21 <boxscape> it does make sense if you look at the full type instead of the cheaty "undefined :: a" I suppose. Although I don't understand why the output of :t is empty
06:13:47 <boxscape> in fact I'm not sure I've ever seen that with any other expression given to it
06:14:29 <inkbottle> lortabac: So what setup (development environment) do you use 'instead"?
06:15:49 <ski>   undefined :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => a
06:18:40 <fendor> inkbottle, it works for me
06:19:11 <lortabac> inkbottle: just GHCI
06:20:28 <inkbottle> fendor: OK; I have so many errors, and it always says to "check in the README" when there isn't any
06:20:44 <inkbottle> or so it is reported by "users"
06:20:53 <fendor> inkbottle, what is your project?
06:21:24 <boxscape> @ :t undefined @IntRep
06:21:31 <boxscape> % :t undefined @IntRep
06:21:31 <yahb> boxscape: ; <interactive>:1:12: error:; Ambiguous occurrence `IntRep'; It could refer to either `GHC.Exts.IntRep', imported from `GHC.Exts' (and originally defined in `GHC.Types'); or `Data.Data.IntRep', imported from `Data.Data'
06:21:39 <boxscape> % :t undefined @GHC.Exts.IntRep
06:21:39 <yahb> boxscape: a
06:21:58 <boxscape> as if
06:22:15 <inkbottle> fendor: well I'm trying to build that: https://haskell-at-work.com/episodes/2018-04-09-your-first-web-application-with-spock.html
06:22:30 <inkbottle> fendor: the purpose only being to see if things are working
06:22:58 <fendor> is there some final project to download?
06:23:15 <boxscape> inkbottle just in case you're using cabal3 - afaik, last I tried it, hie doesn't work with that and you have to use cabal2
06:23:33 <fendor> pretty sure stack was mentioned
06:23:37 <boxscape> ah
06:23:45 <fendor> which should work iirc
06:24:31 <fendor> wait, I think that was a different bug report... sorry :D 
06:25:16 <dminuoso> fendor: https://gist.github.com/paf31/9d84ecf6a6a9b69cdb597a390f25764d
06:25:38 <dminuoso> fendor: This is a cool use of the tardis monad, which uses backwards and future propagating changes. :-)
06:25:47 <boxscape> hmm looks like :t just doesn't show kind errors in 8.8
06:25:51 <boxscape> how odd
06:26:05 <fendor> dminuoso, yeah tardis is really cool! is there real software written with it?
06:26:48 <dminuoso> fendor: Im not aware of any. The uses Ive seen appear to have bad runtime characteristics.
06:27:22 <boxscape> you'd think with time travel you'd be able to get amazing runtime stats, but no...
06:27:59 <inkbottle> I think my stack path isn't correctly configured because I've done 'stack build hoogle'; but if I type 'hoogle' it says 'command not found'
06:28:03 <fendor> dminuoso, what a pity. it is still really cool that it is possible! 
06:28:10 <fendor> inkbottle, no that is fine
06:28:20 <fendor> inkbottle, you have to do `stack exec hoogle generate`
06:28:40 <dminuoso> fendor: Most of the time it's more likely that MonadFix already does the job for you. :P
06:29:14 <fendor> dminuoso, never tried MonadFix. Is that more efficient?
06:31:21 <inkbottle> fendor: okay, doing that.
06:35:28 <fendor> inkbottle, what other errors are you encountering?
06:39:24 <inkbottle> fendor: the hoogle generate thing just finished; I still don't have 'hoogle' from command line. Is that normal?
06:39:40 <fendor> inkbottle, yes that is normal and ok
06:39:46 <inkbottle> ok
06:40:00 <inkbottle> It tell you for the other errors
06:41:59 <inkbottle> I*
06:42:03 <inkbottle> fendor: LSP :: cabal-install is not installed.
06:42:19 <fendor> inkbottle, that is a warning that you can ignore
06:48:02 <inkbottle> fendor: okay, so, for the present I can't see it is not working... I sure could use a manual about how to use HIE
06:49:56 <fendor> inkbottle, you can see that it is not working or you cant see if it is working? 
06:50:05 <boxscape> is there a way to see what ghc version lambdabot uses?
06:51:32 <inkbottle> fendor: It is "probably" working; only so far I don't know how to use it.
06:52:11 <fendor> inkbottle, Hover on an identifier, it should report its type
06:53:02 <fendor> inkbottle, or my personal favourite, use an identifier you know is not in scope from a library, e.g. `hPutStrLn`, see if hie is angry at it and check if there is a code action to `import System.IO`
06:53:05 <inkbottle> fendor: yess, it does that, nice
06:53:43 <inkbottle> OK, I try this one
06:54:50 <inkbottle> (emacs bad color theme: I can't read yellow on white)
06:55:09 <inkbottle> must fix that and tell you what it's written
06:55:17 <fendor> inkbottle, if this succeeds, then code actions work, hoogle db is correctly set up and formatters are working
06:56:07 <inkbottle> fendor: I fix color theme and then tell you 
07:09:58 <boxscape> kind of weird how `fun : (a : Type) -> Bool` in Idris means something completely different from `fun : (a :: Type) -> Bool` in haskell
07:10:18 <boxscape> (uh that should be `fun ::` for haskell)
07:11:19 <boxscape> I'm not even sure which one is more intuitive
07:11:29 <ski> neither
07:11:35 <boxscape> hmm
07:11:45 <ski> (both are bad)
07:12:30 <boxscape> is there a better way in which one could annotate the kinds of parameters?
07:13:56 <lyxia> forall (a :: Type), a -> Bool
07:14:05 <boxscape> ah, true
07:14:07 <ski> personally, i write `<value> (: <type>)' (and `<type> (: <kind>)') for ascriptions, on paper
07:15:14 <ski> (and `(<value pattern> :) <type> -> <type>' for dependent function type)
07:15:36 <boxscape> I see
07:17:37 <ski> (clearly indicating which is "primary part" and which is "afterthought")
07:17:43 <shell43> 99.116.40.240
07:18:17 <ski> shell43 ?
07:18:30 <shell43> help
07:18:32 <shell43> hello
07:18:58 * ski blinks
07:32:55 <msvan> Help, I'm getting this error message from stack and I don't know how to proceed:
07:32:58 <msvan> In the dependencies for transformers-compat-0.6.5:
07:33:00 <msvan>     transformers-0.5.6.2 from stack configuration does not match >=0.3 && ==0.2.*
07:33:26 <msvan> Where is ">=0.3 && ==0.2.*" coming from?
07:34:32 <msvan> I've ripgrepped my whole project and it's not from me. Both transformers and transformers-compat are at the version pinned by stack's lts-14.7, so I don't understand why there would be a problem
07:36:42 <wild_buffalo> Hi, the signature for all looks like this: all :: Foldable t => (a -> Bool) -> t a -> Bool
07:37:00 <wild_buffalo> What does the `t a` mean?
07:37:20 <wild_buffalo> Is it a Foldable containing `a`s?
07:37:31 <wild_buffalo> What does that notation mean in general?
07:38:38 <msvan> `Foldable t =>` means that t is a Foldable thing. `t a` means a `t` containing `a`s
07:39:06 <Philonous> t is a type variable, so the type for all is polymorphic in it.
07:39:44 <Philonous> In his case it is higher-kinded, that is, it takes anotehr type as an argument (for example, Maybe, [] or IO )
07:39:57 <Philonous> But it is required to be an instance of Foldable
07:40:23 <wild_buffalo> Perfect, thanks all
07:40:56 <Philonous> Saying that it "contains" a's is misleading. an »IO Int« doesn't contain Ints, neither does »Proxy Int« 
07:41:47 <Philonous> Another example: »data Foo a where Bar :: Bool -> Foo Int«  here »Foo Int« actually contains a Bool 
07:43:55 <marvel_> Hello, Any steps towards running Haskell with OrientDB, besides the effort at: https://github.com/GoorMoon/orientdb
07:48:01 <boxscape> Philonous IO isn't an instance of Foldable
07:49:05 <Philonous> boxscape, No, but it's an example of a higher-kinded type 
07:50:15 <boxscape> I think for Foldable in particular (rather than Functor), saying "`t a` is a `t` that contains some number of `a`s" is much more appropriate. (Where that number is 0 for Proxy)
07:52:06 <hyperisco> Is infinity a number?
07:52:19 <tabaqui1> what is number?
07:52:30 <tabaqui1> peano - no, extended real numbers - yes
07:52:32 <hyperisco> what is?
07:52:44 <tabaqui1> yeah, which axioms do you use?
07:53:08 <ggVGc> does infinity even exist
07:53:36 <tabaqui1> it is not more real than 0 or any other number
07:53:51 <Philonous> boxscape, It's certainly much more defensible, even though I still think it's misleading. 
07:55:33 <tabaqui1> s/number/notion/g
07:56:00 <hyperisco> As far as I am aware, Foldable doesn't say anything about the structure of a data type.
07:56:13 <geekosaur> numbers are notional. show me a "three". (not the written representation we use to mean "3")
07:56:45 <tabaqui1> you can start from "integers are Z and S :: Int -> Int with axioms ..." or from "reals are linear ordered field with Euclid principle"
07:56:56 <geekosaur> hyperisco, it requires a type that can be flattened into a list somehow. granting it doesn't say how.
07:57:22 <hyperisco> If it doesn't say how, then it doesn't say anything about the structure, I wouldn't think.
07:57:41 <boxscape> Are there no laws that a Foldable instance should adhere to?
07:58:04 * geekosaur gets popcorn
07:59:09 <boxscape> hm, typeclassopedia doesn't seem to list any
07:59:53 <geekosaur> it's come up a number of times as an argument against Foldable
07:59:57 <hyperisco> instance Foldable f where foldMap _ _ = mempty
08:00:17 <hyperisco> I saved you from ever having to write a Foldable instance! Thank me later.
08:01:08 <hyperisco> (It is also highly performant)
08:01:09 <boxscape> even better, instance {-# OVERLAPS #-} Foldable f where foldMap _ _ = mempty
08:01:50 <boxscape> uh
08:01:55 <boxscape> I meant OVERLAPPING actually
08:02:23 <heatsink> fold-related laws for lists should generalize to foldable
08:02:24 <hyperisco> This argument is as sane as  instance Eq a where _ == _ = true;  instance Ord a where compare _ _ = EQ
08:02:42 <heatsink> foldr' f z . fmap g = foldr' (f . g) z
08:03:19 <geekosaur> heatsink, the problem is fold doesnt have laws, it's a natural extension of what lists are
08:03:37 <geekosaur> which is why the only requirement for Foldable is that you be able to make your type into a list somehow
08:04:49 <marvel_> Hello, Any steps towards running Haskell with OrientDB, besides the effort at: https://github.com/GoorMoon/orientdb
08:04:55 <hyperisco> Somehow the freak of nature that is Functor became the trendsetter
08:04:56 <boxscape> actually Data.Foldable does list four laws though
08:04:58 * heatsink . o O ( instance ToList t => Foldable t )
08:10:03 <lyxia> the point is that they're barely laws
08:10:12 <boxscape> I see
08:11:25 <lyxia> they just say that your implementation of various methods must agree with the default implementation
08:11:53 <hyperisco> Foldable is over-defined. Those laws just say how each way of defining a Foldable must agree with one another.
08:12:36 <lyxia> most of the time you only implement foldMap, and there is no equation that restrains what it can do.
08:13:01 <hyperisco> What about the conditional law? muahaha
08:13:16 <hyperisco> "If the type is also a Functor …"
08:14:00 <Philonous> I'm having a hard time coming up with an implementation that violates that constraint
08:14:11 <hyperisco> The conditional one?
08:14:14 <Philonous> Yes
08:14:25 <hyperisco> foldMap _ _ = mempty   will violate it much of the time
08:14:31 <berndl> Quick question: how do you use $! on a function that that takes multiple arguments?
08:14:49 <Philonous> hyperisco, Does it?
08:15:40 <hyperisco> nope
08:15:49 <berndl> Do I just write e.g. f $! x $! y when I want x and y to be evaluated first before applying f?
08:16:17 <boxscape> berndl it looks like you need to write (f $! x) $! y
08:16:28 <Philonous> hyperisco, The law we're talking about is foldmap f . fmap g = foldmap (f . g), no? Your foldMap doesn't violate that. 
08:16:40 <berndl> boxscape: OK
08:19:27 <boxscape> Feels weird that the historical classes (unlike Foldable) are still defined in GHC.Base rather than in their own respective modules
08:20:54 <lyxia> Philonous: pretty sure that's a free theorem
08:21:08 <boxscape> (Also seems like there isn't a terribly good reason for keeping it this way but maybe I'm missing something)
08:21:23 <lyxia> so it can't be broken
08:21:36 <c_wraith> boxscape: a lot of stuff in base is organized the way it is to avoid cyclic depedencies between modules
08:21:55 <Philonous> lyxia, Not quite, you need the naturality of fmap, and I don't think you get that out of a free theorem
08:22:03 <boxscape> Ah, I see c_wraith
08:22:06 <hyperisco> Philonous, I have a feeling this is a free theorem
08:22:55 <Philonous> You do get it from parametricity + naturality of fmap, though 
08:23:57 <lyxia> naturality of fmap?
08:24:05 <boxscape> Isn't naturality of fmap implied by parametricity as well?
08:24:12 <boxscape> (I might be misremembering)
08:24:46 <lyxia> that's also my thought
08:25:09 <nil> @free fmap :: (a -> b) -> F a -> F b
08:25:09 <lambdabot> g . h = k . f => $map_F g . fmap h = fmap k . $map_F f
08:25:25 <nil> iirc you can derive naturality from that
08:26:16 <Philonous> data Foo a = { value :: a, mapped :: Bool}; brokenFmap f Foo{value = v} = Foo {value = f c, mapped = True} ; brokenFoldMap f Foo{ value =v, mapped =m} = if mapped then mempty else f v 
08:26:22 <lyxia> nil: what is naturality
08:26:23 <pong> i prefer artifical
08:26:47 <pong> natural in the sense that it's a natural transformation
08:27:05 <lyxia> I know that, I'm asking what it means in this context specifically "naturality of fmap"
08:27:20 <nil> er, i might be thinking about naturality in the monad laws
08:28:09 <Philonous> lyxia, By naturality I mean fmap f . fmap g = fmap (f . g) and fmap id = id 
08:28:36 <Philonous> And you don't get these for free
08:28:41 <lyxia> Ok fair enough
08:28:57 <lyxia> If you tell me you have a Functor instance I would assume they hold though.
08:29:02 <pong> so same rules as functor but your point is already a functor?
08:29:19 <lyxia> And the Foldable docs probably assume as much.
08:29:59 <Philonous> Yes, if it's a law-abiding Functor you do, and then you can't write a foldMap that breaks the stated law
08:39:49 <ski> Philonous : `fmap' isn't a natural transformation
08:40:34 <ski> hmm
08:41:38 <ski> or is it ?
08:42:05 <ski> (at least, i think naturality wouldn't correspond to `fmap f . fmap g = fmap (f . g)' and `fmap id = id' (functor laws))
08:43:20 <Philonous> Yeah, I mixed the terminology up. :(
08:45:26 <ski> ok, consider a functor `F : C >---> D', and then functors `Hom_C : C^op * C >---> Set' and `Hom_D . (F^op * F) : C^op * C >---> Set' (where `Hom_D : D^op * D >---> Set'). then perhaps `fmap' could be a natural transformation from `Hom_C' to `Hom_D . (F^op * F)' ?
08:46:03 <lyxia> something like that yes
08:46:58 * ski was first thinking naturality didn't match the laws Philonous had in mind, then was thinking perhaps `fmap' was a dinatural transformation .. but upon closer look, it would probably be a plain natural transformation, along these lines
08:47:53 <ski> Philonous : it's okay, that's how we often learn
08:54:01 * hackage storable-enum 0.0 - Wrapper that makes any Enum type Storable  https://hackage.haskell.org/package/storable-enum-0.0 (HenningThielemann)
08:59:13 <msvan> Is there a nicer way of writing this: `files <- getDirectoryContents dir >>= return . (filterM doesFileExist)`
09:01:23 <dminuoso> msvan: More bindings, more lines.
09:02:44 <dminuoso> msvan: Also what's the point of that `return .` composition exactly?
09:03:32 <dminuoso> Ah
09:03:43 <dminuoso> % :t filterM
09:03:43 <yahb> dminuoso: Applicative m => (a -> m Bool) -> [a] -> m [a]
09:03:56 <ski> presumably no point at all ?
09:05:03 <msvan> yes, that's a good point because it doesn't even compile with the return composition :)
09:05:10 <dminuoso> `do { files <- filterM doesFileExist =<< getDirectoryContents dir }`
09:05:13 <dminuoso> This seems fairly fine to me.
09:05:56 <dminuoso> Or, if you prefer via two lines: `do { files <- getDirectoryContents dir; filterM doesFileExist files }`
09:06:05 <msvan> thanks, though I understand the suggestion to simply have more lines
09:06:25 <dminuoso> msvan: Perhaps not just more lines, but really more bindings! :-)
09:06:56 * dminuoso recently had this revelation that having many really small bindings leads to better code
09:10:33 <boxscape> making everything as pointfree as possible isn't the answer? :o
09:11:52 * ski . o O ( s/pointfree/pointless/ )
09:11:54 <evelyn> is pointfree trolling a bannable offence?
09:12:06 <ski> what is that ?
09:24:31 * hackage haskoin-node 0.9.12 - Haskoin Node P2P library for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-node-0.9.12 (xenog)
09:36:01 * hackage haskoin-store 0.18.3 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.18.3 (xenog)
09:43:27 <rocket_man> how can I turn this into point-free notation? `coprime n k = 1 == gcd n k`
09:43:43 <rocket_man> I tried `coprime = ((==) 1) . gcd` but that gave me 'Non type-variable argument in the constraint: Num (a -> a)'
09:44:01 <c_wraith> @pointfree coprime n k = 1 == gcd n k
09:44:01 <lambdabot> Unknown command, try @list
09:44:06 <c_wraith> @pointless coprime n k = 1 == gcd n k
09:44:06 <lambdabot> coprime = ((1 ==) .) . gcd
09:44:07 <ChaiTRex> @pl \n k -> 1 == gcd n k
09:44:07 <lambdabot> ((1 ==) .) . gcd
09:44:17 <ski>   coprime n k = 1 == gcd n k
09:44:33 <ski>               = (1 ==) (gcd n k)
09:44:42 <c_wraith> being point-free isn't that interesting of a goal in and of itself, as it's trivial for the computer to do it
09:44:44 <ski>               = ((1 ==) . gcd n) k
09:44:55 <ski>   coprime n = (1 ==) . gcd n
09:45:07 <ski>             = ((1 ==) .) (gcd n)
09:45:17 <ski>             = (((1 ==) .) . gcd) n
09:45:27 <ski>   coprime = ((1 ==) .) . gcd
09:45:57 <ski> aka
09:45:58 <rocket_man> ah, so I need two . because there's two arguments
09:46:03 <ski>   coprime = (1 ==) .: gcd
09:46:05 <ski> given
09:46:11 <ski>   (.:) = (.) . (.)
09:46:51 <ski> (and yes, this is already stretching readability)
09:47:22 <jzyamateur> Hello all, what exactly does `stack setup` do? I have run `stack path`, but I am not sure if I am running a sandbox mode, since most of paths are somewhere in `AppData\Local` 
09:47:31 <rocket_man> hmm yeah I imagined that would look nicer
09:48:30 <ski> quite often, turning a piece of code into pointless, is quite pointless
09:48:41 * nil . o O ( coprime = curry $ (1 ==) . uncurry gcd )
09:48:42 <ski> (a light amount, may sometimes help)
09:48:58 * ski shudders at the use of `$'
09:49:06 <nil> i think this could actually look good, if there was some sort of syntactic sugar for curry/uncurry
09:49:11 <c_wraith> the best results usually come from reducing a single parameter.
09:49:57 <EvanR> syntactic sugar rots the brain
09:52:31 * hackage haskoin-node 0.9.13 - Haskoin Node P2P library for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-node-0.9.13 (xenog)
09:56:24 <rocket_man> I have the following function: https://pastebin.com/aqaYF8xE. I want to refactor it so that if `nums` has the wrong length, it tells you the proper length of a function. Any ideas for how to do that without lots of if/else statements?
09:56:38 <rocket_man> *proper number of arguments to the function
09:57:55 <jzyamateur> So In haskell, The filename has to match the module name, and filename can be in lowercase but module name has to be upper case?
09:59:58 <fendor> jzyamateur, yes
10:11:18 <jle`> rocket_man: what is the proper length of a function?
10:11:26 <jle`> oh ah, didn't see the typo
10:11:56 <jle`> rocket_man: i'm not sure exactly what you mean still. but if you write out the full code with all the if/else statements, we can maybe look at that and see how we could simplify it
10:13:01 <lyxia> I think rocket_man means that for example if your "func"tion name is "derangement" then "nums" must have length 1 and if not there should be a proper error message
10:15:34 <lyxia> you might want to create a data type to represent functions of different arities
10:19:48 <rocket_man> lyxia: exactly, I want ArityError to hold an Int 
10:28:19 <boxscape> I just spent a while proving that n + m = m + n, and I was wondering, does the way haskell does constraint solving make something like idris's "rewrite" unnecessary? From how I just proved it, it seems like it does, but it's been a while since I've used idris
10:29:27 <EvanR> (aside, rewrite isn't strictly necessary, its like a tactic that uses replace)
10:29:34 <boxscape> hm, okay
10:32:24 <rocket_man> here it is with if/else, I only did 2 functions but the rest would be similar: https://pastebin.com/YbEuU7s4
10:35:17 <rocket_man> in python this is very simple because all the types are dynamic, I have a dictionary of {"name": func} and call it like this: `func(*nums)`. I'm trying to translate that to haskell but it looks like it's going to be unpleasant
10:35:47 <EvanR> basically you want varargs in haskell
10:36:06 <rocket_man> yes, but I want it to give a type error if I pass the wrong number of args
10:36:06 <boxscape> hm I implemented varargs in haskell like three days ago
10:36:26 <EvanR> so now you want C++ overloading in haskell
10:36:39 <hyperisco> rocket_man, why do you punish yourself so?
10:36:59 <rocket_man> I don't want overloading. All the functions I'm using have a fixed number of arguments, I just want to dispatch to a function based on a string
10:37:13 <EvanR> it's a fixed number of args?
10:37:19 <rocket_man> hyperisco: the use case is something like `busybox` where it calls a different function based on the name of the program
10:37:38 <EvanR> so now you want dependent types
10:37:46 <rocket_man> each _function_ has a fixed number of arguments, but that fixed number is not the same for every function
10:37:58 <EvanR> String -> (exists n . FuncArity n)
10:38:30 <hyperisco> I don't know why programmers are so fascinated with this sort of thing. Not saying it is wrong. I just don't get it.
10:38:36 <ski> @hackage dependent-map
10:38:36 <lambdabot> http://hackage.haskell.org/package/dependent-map
10:38:42 <boxscape> what sort of thing?
10:39:08 <hyperisco> This is asking to take a collection of functions and automatically generate a CLI frontend, more or less
10:39:32 <EvanR> sounds useful
10:39:39 <hyperisco> I'd say, if this was really important, go straight to TH
10:39:49 <rocket_man> ^ if there's a library for this I'm happy to use it
10:40:08 <ski> @wiki TV
10:40:08 <lambdabot> https://wiki.haskell.org/TV
10:40:08 <hyperisco> EvanR, most people call it ghci :P
10:40:16 <rocket_man> oh boy, where do I go to learn template haskell lol
10:41:01 <lyxia> rocket_man: https://gist.github.com/Lysxia/1b36e00d063cc89924ee994540b6a46c
10:41:18 <Lycurgus> some people use the documentation
10:41:27 <Lycurgus> it's a minority position igess
10:41:30 <hyperisco> First you must locate the dusty tomes. But, they're incomplete; many were lost in time.
10:41:40 <c_wraith> the template haskell section of the GHC user manual is really good
10:42:01 <c_wraith> as are the haddocks for exploring API details once you have the big picture
10:42:19 <hyperisco> To complete your knowledge you must travel to the disciples of TH
10:42:29 <rocket_man> lyxia: that looks really nice actually
10:43:02 <rocket_man> let me play with that for a little while
10:43:04 <hyperisco> But most have gone insane and have hid from the world
10:43:42 <c_wraith> it is a bit confusing that there are currently two template haskells and very little pushing people towards the new one
10:43:48 <EvanR> somehow dependent map sounds like a interesting tangent to the problem
10:43:52 <EvanR> more interesting than TH 
10:43:59 <Lycurgus> https://www.haskell.org/th/ used to be a thing
10:44:21 <ski> @wiki Template Haskell
10:44:21 <lambdabot> https://wiki.haskell.org/Template_Haskell
10:44:33 <lyxia> two template haskell??
10:44:47 <ski> two ?
10:45:03 <hyperisco> These code generators grow many warts over time. What about adding help info? Grow a wart. What about custom parsers and printers for arbitrary data types? Grow a few more warts.
10:45:09 <c_wraith> Yes, there's the old one using $ splices, and the new one using $$ splices.
10:45:16 <c_wraith> New types for everything in there.
10:45:20 <ski> mhm
10:45:31 <EvanR> 2 template haskell 2 quit
10:46:11 <hyperisco> What about aliases or abbreviated names? Another wart.
10:46:46 <c_wraith> I still think the $ on top-level splices never should have been made optional.
10:46:59 <hyperisco> What if I want to forward shell arguments to a sub process? Another wart.
10:47:17 * ski agrees with c_wraith
10:47:19 <lyxia> typed splices are not really as expressive as untyped ones though
10:48:21 <hyperisco> Can we turn a Haskell library into an exe with ghci as a frontend? That might not be terrible here.
10:48:38 <c_wraith> Hmmm..  That's a cool project idea.
10:49:08 <rocket_man> sounds neat but not my usecase, I want it to be non-interactive
10:49:19 <hyperisco> You can pipe data into ghci
10:49:49 <rocket_man> then I end up writing a shell script for each function which defeats the purpose
10:50:24 <hyperisco> I am not sure how that is. You just write one script that takes the name of the function, and the arguments, and gives it to ghci
10:50:53 <rocket_man> ah I see what you mean, that might work
10:51:02 <rocket_man> still interested to see if lyxia's approach works though
10:52:35 <jle`> rocket_man: i'd probably just do this by cases, yeah
10:52:42 <jle`> rocket_man: and you don't have to use if/else's, you can just use guards
10:52:56 <jle`> resultOf func
10:53:26 <jle`>   | func `elem` ["D","derangement"] -> ..
10:53:38 <jle`> hm, you could make this nicer using PatternGuards so you can do a catch-all at the end in a nice way
10:53:40 <jle`> resultOf func
10:53:54 <jle`>   | func `elem` ["D', "derangement"]
10:54:08 <jle`>   , [n] <- nums = Ok $ derangements !! fromInteger n
10:54:25 <jle`>   | func `elem` ["gcd","euclidean"]
10:54:47 <jle`>   , [n,k] <- nums = Ok $ ...
10:55:09 <jle`> ah, this second way doesn't let you do custom arity methods.
10:55:18 * ski . o O ( <https://en.wikipedia.org/wiki/Derangement> )
10:55:23 <tabaqui1> what means this syntax with dot? " | <cond>, <expr?> = <expr>"?
10:55:39 <jle`> tabaqui1: what dot are you referring to?
10:55:40 <EvanR> what's derangement in english
10:55:42 <rocket_man> exactly, that's what I had to start: https://pastebin.com/aqaYF8xE
10:55:54 <tabaqui1> ", [n] <- ..."
10:55:56 <tabaqui1>  ^
10:56:08 <Philonous> rocket_man, you can simulate "varargs" with type classes, see https://gist.github.com/Philonous/760034884f30c0c74c007d0839e81933
10:56:10 <rocket_man> EvanR: the number of functions from a set to itself such that no element of the set ends up back where it started
10:56:12 <hyperisco> rocket_man, also look at protobuf/grpc
10:56:29 <hyperisco> I am not sure if they have Haskell generators but if they do then that could be another shortcut.
10:56:37 <tabaqui1> hyperisco: thrift does
10:56:45 <rocket_man> protobuf sounds way too heavy for what I need
10:56:57 <jle`> yeah, making a new typeclass is like ... 99% of the time waay to much power
10:57:04 <tabaqui1> jle`:
10:57:08 <tabaqui1> ", [n] <- nums ..."
10:57:10 <tabaqui1>  ^
10:57:17 <jle`> tabaqui1: it's PatternGuards
10:57:20 <hyperisco> It is an interface spec, and there are code generators for it
10:57:29 <hyperisco> Which is exactly what you'd be building in TH, if you went that route
10:58:06 <jle`> rocket_man: one convenient way would be maybe to make a list of handlers and run them all
10:58:13 <tabaqui1> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-460003.13
10:58:44 <lyxia> jle`: sounds like what I suggested earlier https://gist.github.com/Lysxia/1b36e00d063cc89924ee994540b6a46c
10:59:12 <hyperisco> tabaqui1, how many gRPC vs Thrift articles should I read?
10:59:22 <ski> EvanR,rocket_man : bijective functions
10:59:34 <tabaqui1> Thrift - probably two are enough
10:59:41 <tabaqui1> grpc - I've no idea
10:59:47 <rocket_man> ski: no, bijective allows x = f(x)
10:59:57 <rocket_man> derangements are a strict subset of bijections
11:00:00 <jle`> ah yeah, that way is nice and doesn't use any weird tricks
11:00:00 <tabaqui1> https://diwakergupta.github.io/thrift-missing-guide/
11:00:02 <hyperisco> How many (gRPC vs Thrift) articles should I read?
11:00:04 <tabaqui1> This one is good
11:00:04 <ski> rocket_man : not if you disallow fixpoints
11:00:17 <rocket_man> that's the definition of a derangement lol
11:00:30 <ski> rocket_man : my issue was that you allowed any fixpoint-free functions, rather than just the fix-point free bijections
11:00:39 <jle`> if you want to be cute you can even have Func be an infix constructor
11:01:07 <jle`> ["D","derangement","derangements"] :=> Arity1 (\n -> ...)
11:02:28 <hyperisco> I guess the question is… which is more thorough and boring? That is better than quick and flashy.
11:02:50 <hyperisco> I think the brands answer that outright.
11:03:19 <jle`> lyxia, rocket_man: the way you gave uses foldMap for applyFuncs, but it might be worth noting that you can do this without defining any instances or anything and just using foldr with the 'get the first OK' function
11:03:32 <tabaqui1> the link above is thorough and not much boring. Anyway it has a reference of the original whitepaper
11:03:50 <hyperisco> I mean the technologies as a whole
11:03:57 <rocket_man> eyy that did it!
11:04:20 <hyperisco> Two years from now, which would you be more happy having chosen?
11:04:21 <EvanR> "technologies"
11:04:26 <jle`> :D
11:04:33 <tabaqui1> the worst problem is that thrift library on hackage wasn't updated for years and generated code produces a lot of warnings
11:04:54 <rocket_man> https://gist.github.com/jyn514/2d3b5ecc7be563096f004c3d9aa62adc/edit
11:06:01 <rocket_man> example run: $ ./gcd usage: gcd n m`
11:06:10 <jle`> rocket_man: nice :)
11:06:26 <hyperisco> I see. Reconstituting libraries is nothing new in my daily experience.
11:06:34 <jle`> rocket_man: in practice because you have a fixed universe of functions, it might be cleaner to make an ADT of them
11:06:57 <jle`> data FuncName = Derangement | Factorial | GCD | Parition | Sterling | Combinations
11:07:09 <jle`> then you can say, make a map from names to functions to look them up
11:07:17 <jle`> functionMap :: Map String FuncName
11:07:52 <hyperisco> I'd do this with type classes just because I am insane.
11:08:02 <jle`> functionMap = M.fromList [("D",Dernagement), ("derangement",Dernagement) ...] etc. (or you can use your same `elem` guard branching)
11:08:17 <jle`> then applying functions would be simpler, you can write:
11:08:30 <jle`> runFunc :: FuncName -> FuncBody
11:08:38 <hyperisco> call @"+Int" 1 2   say :)
11:08:47 <jle`> runFunc Derangement = Arity1 $ \n -> derangements !! fromInteger n
11:08:52 <EvanR> hyperisco: totally unecessary uses of type classes, sounds like an ongoing blog post seris
11:08:57 <jle`> runFunc Factorial = Arity1 factorial
11:09:03 <hyperisco> I have a running start
11:09:09 <jle`> runFunc GHC = Arity2 gcd
11:09:22 <rocket_man> that still requires me to make a new `runFunc` for every new function
11:09:32 <jle`> no it'd beht same runFunc :)
11:09:36 <jle`> that's just how haskell syntax works
11:09:39 <jle`> runFunc fn = case fn of
11:09:47 <jle`>   Derangement -> Arity1 ...
11:09:50 <rocket_man> right, right, but I mean that I need two or three extra lines for every function I add
11:10:13 <rocket_man> using this way means I just have to add `Func ["name1", "name2"] (Arity1 myfunc)`
11:10:14 <jle`> yeah, but i don't think you can ever avoid that
11:10:39 <jle`> yeah, this case it would be just:
11:10:44 <hyperisco> class NamedValue (s :: Symbol) (x :: a) | s -> x where val :: x
11:10:45 <jle`>   NewFuncName -> Arity1 myFuncName
11:11:02 <hyperisco> (x :: Type) whoops
11:11:28 <hyperisco> instance NamedValue "+Int" (Int -> Int -> Int) where val = (+)
11:11:30 <jle`> rocket_man: but, then you'd also have to add the new constructor and also new lookups in a different place, so the new code you'd add would be scattered everywhere yeah
11:11:32 <hyperisco> Ship it!
11:11:48 <chloekek> In Erlang every thread has its own heap and its own GC. Communication between threads requires copying of values. I was wondering, is something like this even remotely possible with GHC RTS? I'm afraid not. I'm asking because I'm running into long GC pauses (tens of GBs of data on the heap). Compact regions leviate the problem a little bit, but it would be nice if one thread GCing wouldn't affect other
11:11:50 <chloekek> threads, and an Erlang-like model would help. Especially if compact regions *could* be shared between such heaps without copying.
11:11:55 <jle`> rocket_man: it'd be the same amount of new code, but just scattered across the file instead of all in one line
11:12:21 <jle`> rocket_man: so yeah, there would be pro's and cons
11:12:28 <chloekek> If not, is it possible to share compact regions between processes (different address spaces) with shared memory?
11:13:38 <jle`> hyperisco: that's basically just a sneaky way of defining normal functions on a global namespace, heh.
11:13:39 <chloekek> I'm aware of compact region serialization, but it has a reported bug that makes it impossible to use for regions > 4 GB, and it's not very fast (linear time).
11:13:51 <jle`> or i guess the typeclass is the namespace
11:13:55 <jle`> did you just invent a module system
11:14:37 <hyperisco> Fully qualified name in, definition out, seems so :P
11:14:39 <boxscape> hmm I defined typeclasses for + and *, without changing the prelude fixities of those operators, but somehow `S n * m :~: m + n * m` ends up being parsed as `S n * m :~: (m + n) * m`
11:15:16 <jle`> boxscape: by 'without changing' do you mean copying over?
11:15:32 <jle`> boxscape: also, what do you expect that to be parsed as?
11:15:41 <EvanR> chloekek: see also cloud haskell
11:15:48 <boxscape> jle`, no, I'm just implicitly importing Prelude - do I have to redeclare the fixities myself?
11:15:51 <jle`> boxscape: but yeah, if you define a new name, you have to give that new name fixities
11:15:56 <boxscape> ahh okay
11:16:00 <jle`> the fixities are per-identifier
11:16:05 <jle`> not per "same lexical name"
11:16:11 <boxscape> got it
11:16:12 <jle`> so Prelude.* is different than YourModule.*
11:16:28 <boxscape> but MyModule.* on the type level is the same as MyModule.* on the term level
11:16:29 <boxscape> afaik
11:16:32 <boxscape> that's what confused me
11:16:40 <jle`> yeah but all of those are different than Prelude.*
11:16:44 <boxscape> right
11:17:09 <rocket_man> ok last crazy request, make it work for different output types :P
11:17:11 <EvanR> chloekek: also not sure how you could copy data to another heap in under linear time? compresion?
11:17:30 <rocket_man> So `Integer -> Integer -> Bool` as well as `Integer -> Integer -> Integer`
11:17:44 <chloekek> EvanR: I imagine that due to the restrictions imposed onto values inside compact regions, sharing a compact region is as simple as copying a pointer to it.
11:18:04 <jle`> rocket_man: so the way you would scale this system in normal haskell would be to make it Arity2Bool, Arity2Int, etc.
11:18:16 <jle`> so...not the cleanest thing
11:18:41 <EvanR> chloekek: if two independent runtimes are looking at the same object... and it works fine. Then why have separate heaps ...
11:18:43 <jle`> rocket_man: however, because all you ever do is 'show' the result
11:18:58 <jle`> rocket_man: you can just have all the Arity's be Arity2 (Integer -> Integer -> String)
11:19:05 <jle`> and show the result as you return it
11:19:09 <rocket_man> oh I can just make it a String! oh that's evil genius
11:19:34 <jle`> this won't work if you ever plan on implementing function composition
11:19:39 <jle`> but it works in this simple case, heh
11:19:41 <chloekek> EvanR: so that garbage collecting only has to pause the threads that use the heap that you're collecting garbage from. Threads that use other heaps can continue running.
11:19:59 <rocket_man> I'm not planning to do composition with the crazy frontend, just with the functions themselves
11:20:17 <jle`> ah, ok :)
11:20:18 <EvanR> chloekek: right. But eventually something has to gc the compact region
11:20:37 <jle`> hm, i'm trying to think of any other way this could go wrong
11:20:38 <chloekek> EvanR: I suppose you could put a reference count on it, counting how many heaps point to it.
11:20:59 <chloekek> Freeing the memory occupied by a compact region is trivial.
11:21:07 <EvanR> and discover this count in the course of independent gc runs?
11:21:16 <rocket_man> FuncBody doesn't like that I typed `Arity2` as `Integer->Integer->Integer`, is there a way to say `Integer -> Integer -> a`?
11:21:26 <EvanR> manual reference counting is out
11:21:33 <chloekek> EvanR: Increment the count when sending the compact region handle to another thread. Decrement it when GCing the handle.
11:21:57 <EvanR> your question is relevant since i am about to implement some thing with processes
11:21:58 <jle`> rocket_man: there is but you have to parameterize Arity on 'a', but then you'd ahve to parameterize FuncBody on 'a', and then now you can no longer put them all in a list
11:22:06 <EvanR> i was planning on just have separate heaps, but i also want large objects
11:22:11 <EvanR> relevant to me*
11:22:13 <jle`> rocket_man: ah okay, here's a more principled approach that will let you one day implement composition or anything else fancy
11:22:19 <chloekek> But I don't think this is a thing in GHC right now; the RTS seems to use globals, which means there can only be one per process.
11:22:22 <jle`> data IntOrBool = I Integer | B Bool
11:22:29 <jle`> Arity1 (Integer -> IntOrBool)
11:22:32 * hackage tree-sitter 0.5.0.0 - Unstable bindings for the tree-sitter parsing library.  https://hackage.haskell.org/package/tree-sitter-0.5.0.0 (robrix)
11:22:36 <jle`> | Arity2 (Integer -> Integer -> IntOrBool)
11:22:41 <chloekek> EvanR: so it might be better to look at shared memory, I think.
11:22:44 <rocket_man> I'm looking at philonious's typeclasses again actually
11:22:57 <jle`> then you printing code would just need to be a little smarter
11:23:18 <EvanR> chloekek: just to narrow down your topic here, you're talking about a special feature of compact regions that let you share them among independent haskell processes at low cost. On the same machine
11:23:33 <EvanR> so no cloud anything
11:23:38 <chloekek> EvanR: there's actually a trick that you can do in Erlang if you want to simulate a compact region: codegen and then load a module that defines top-level constants. Those are shared between Erlang processes. :P There's a library by Discord that does this.
11:23:41 <jle`> rocket_man: but yeah if you tweak Arity1 to (Int -> Int -> String), or whatever type, everything should work ok. you just need to show or wrap when you define the function
11:23:56 <chloekek> EvanR: oh yes, not distributed. It's on a single machine.
11:24:05 <jle`>  Func ["!","factorial"], Arity1 (show . factorial)
11:24:27 <chloekek> EvanR: and the compact regions are large, some over 10 GB.
11:24:44 <jle`>  Func ["s","S","sterling"] (Arity2 (\x y -> show (sterling x y))
11:25:36 <EvanR> chloekek: i think you're right about GHC, they don't even have separate-heap threads much less the ability to share something between runtimes
11:25:39 <rocket_man> hmm that would work with your FuncOutput setup as well
11:25:54 <rocket_man> sorry I mean `I Integer | B Bool`
11:26:32 <EvanR> almost forgot the original issue was GC time
11:27:16 <EvanR> good to know about that erlang trick
11:27:49 <chloekek> EvanR: I'm already doing some nasty tricks to reduce the amount of data the GC has to traverse, by using unboxed vectors of Addr# instead of boxed vectors of pointers to values inside compact regions. I get the Addr#s using anyToAddr#. The GC then ignores the vector contents instead of traversing them, greatly reducing GC time. And it's safe since compact regions are never moved by the GC. But it's not
11:27:51 <chloekek> enough.
11:30:01 * hackage tree-sitter-java 0.4.0.0 - Tree-sitter grammar/parser for Java  https://hackage.haskell.org/package/tree-sitter-java-0.4.0.0 (robrix)
11:30:12 <jle`> rocket_man: be careful of doing anything with type variables in this case though because your main limiting factor is that you have to store all of these handlers in the same list
11:30:15 <aleator> Does anyone know what could cause stack error "Could not find package id of package X" for a local package
11:30:23 <chloekek> EvanR: Might spend some more time trying to reduce garbage production and retention.
11:30:29 <jle`> rocket_man: and resist the temptation of using existentials ;)
11:31:09 <rocket_man> ok so no longer as pretty as it used to look but still does everything I want: https://gist.github.com/jyn514/2d3b5ecc7be563096f004c3d9aa62adc
11:31:10 <EvanR> chloekek: not enough?
11:32:25 <chloekek> Still too much time in GC. :P
11:32:45 * EvanR thinks very hard
11:33:00 <EvanR> have you tried tuning the GC runtime parameters
11:33:01 * hackage tree-sitter-json 0.3.0.0 - Tree-sitter grammar/parser for JSON  https://hackage.haskell.org/package/tree-sitter-json-0.3.0.0 (robrix)
11:34:16 <chloekek> Yes
11:34:21 <chloekek> But I could try again.
11:34:59 <EvanR> is it the pause times or the proportion of total time in gc that is offesive
11:35:45 <chloekek> What's the difference?
11:35:59 <chloekek> Ah, the pauses are very long, sometimes 15s or 20s.
11:36:01 * hackage tree-sitter-python 0.6.0.0 - Tree-sitter grammar/parser for Python  https://hackage.haskell.org/package/tree-sitter-python-0.6.0.0 (robrix)
11:36:03 <EvanR> latency vs throughput type of thing
11:36:11 <chloekek> As a result the total GC time is high.
11:36:31 <EvanR> 20s, yeesh
11:37:19 <chloekek> :P
11:37:38 <EvanR> so you have a lot of live data basically
11:37:45 <EvanR> very large IntMaps etc ?
11:39:13 <chloekek> Millions of HashMaps, I was thinking of replacing them with IntMaps.
11:39:19 <chloekek> Vector would be nice, but they have high update times.
11:39:32 <EvanR> Vector still has to be copied
11:39:50 <chloekek> Yeah but they don't have the complex internal structure.
11:40:08 <chloekek> HashMap of size n has many more objects than a Vector of size n.
11:41:07 <EvanR> with large live data size of whatever kind, any major gc will pause everything for a while
11:41:18 <chloekek> Maybe I should employ a SIMD-inspired technique. Instead of HashMap Key Value, have HashMap Key (Vector Value). Work on values in batches.
11:41:38 <chloekek> That would cut down on HashMap overhead.
11:41:58 <chloekek> And perhaps speed up computation as well due to fewer hashmap operations, though I need to visit more branches and apply masks.
11:43:02 * hackage haskoin-store 0.18.4 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.18.4 (xenog)
11:43:09 <EvanR> you have lots of small hashmaps?
11:43:38 <chloekek> Millions of them. They initially are in a compact region, but are then modified many times.
11:44:02 <rocket_man> out of curiosity, what are you doing with millions of hashmaps?
11:44:07 <chloekek> Number of keys ranges between 5 to 200.
11:45:55 <chloekek> Also, the set of unique sets of keys across all hash maps is small (10~50).
11:46:22 <chloekek> rocket_man: processing items that are all similar in structure. They are all in memory because to avoid I/O latency.
11:46:33 <chloekek> Maybe I/O is faster than GC though. :P
11:47:12 <EvanR> third option, they are in memory but mutable memory that uses IO to access
11:47:24 <EvanR> mutable vector etc
11:48:23 <chloekek> I think mutable vectors are always fully traversed in minor GCs even if they are in the 2nd generation.
11:48:46 <chloekek> Unless they're unboxed vectors, of course.
11:48:55 <EvanR> unboxed vector of Addr :)
11:49:19 <chloekek> Yeah, already doing that in some places, Addrs point into compact regions which don't get moved.
11:49:42 <chloekek> It's nasty but never caused a segfault. :P
11:50:04 <chloekek> Just have to make sure you don't let the compact region get collected while you still have the addrs.
11:50:41 <chloekek> Which can be achieved via the dreaded touch primop.
11:54:36 <EvanR> chloekek: heh... keep the live data serialized (in memory). When an operation comes up, deserialize, operate, reserialize, forget living structure to keep live data low
11:54:48 <EvanR> pay a high cost to avoid even higher cost?
11:54:54 <merijn> chloekek: Depends on the kind of vector
11:55:08 <merijn> chloekek: For example, Storable Vector is just a ForeignPtr, so those aren't traversed
11:55:50 <chloekek> EvanR: Yeah that might be an idea.
11:56:18 <merijn> (I missed the initial context, though)
11:56:58 <EvanR> chloekek: the storage for serialized data would need to be somewhere the gc doesn't go though...
11:57:34 <chloekek> Yeah just use byte arrays for that.
11:57:36 <merijn> What kinda data are we talking?
11:58:45 <chloekek> Array of millions of hash maps, each with the same key set, with mostly Text values inside of them. Multiple such arrays. Processed with maps, filters, etc.
11:59:17 <merijn> Ok, potentially dumb question: Have you considered a database? >.>
11:59:41 <chloekek> Oh yes, they are read out of a database into memory, ready for processing.
12:00:09 <EvanR> it sounds like a sort of cache/accelerator... and it's not working :)
12:00:09 <merijn> chloekek: Maybe use an SQLite in memory database for local caching?
12:00:49 <chloekek> Have not considered using in-memory DBMS, will start considering that!
12:00:51 <chloekek> Thanks.
12:01:09 <merijn> chloekek: With SQLite you can actually inject application function into the queries if you like
12:01:40 <merijn> chloekek: I use that to aggregate results into a Vector during the query (instead of having complicated N way joins and building the vector in the application)
12:01:45 <merijn> It works really well
12:01:49 <chloekek> Neat.
12:02:28 <EvanR> sqlite haskell bindings?
12:02:44 <merijn> EvanR: I'm using persistent for hysterical reasons, but yeah
12:03:29 <merijn> EvanR: I even patched persistent-sqlite to make accessing the underlying SQLite pointer possible to use parts of the API persistent doesn't implement :p
12:03:43 <chloekek> hysterical or historical?
12:03:52 <EvanR> hysterical raisins
12:03:58 <merijn> chloekek: "yes"
12:04:02 <chloekek> Hmmst.
12:04:12 <merijn> chloekek: http://www.catb.org/jargon/html/H/hysterical-reasons.html
12:05:01 <chloekek> owo
12:05:27 <merijn> I have nothing but good things (well...SQLite consider types "optional" is stupid, but what are you gonna do) to say about the SQLite part, its the persistent layer in between that's been frustrating
12:05:54 <EvanR> i really like sqlite itself
12:06:01 <EvanR> haven't used it in haskell
12:06:23 <merijn> chloekek: Example: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/cbits/sqlite-functions.c#L41-L93
12:06:25 <hyperisco> But what about concurrency? Oh the sadness
12:06:27 <chloekek> I found it lacking in SQL features but it's better than nothing.
12:06:57 <merijn> chloekek: That's an aggregate function that allocates space for a vector, then incrementally builds it and returns it as byte blob
12:06:58 <EvanR> sqlite supports concurrency
12:07:05 <EvanR> ACID
12:07:05 <merijn> hyperisco: Read concurrency is fine
12:07:17 <merijn> hyperisco: Write concurrency is less good, but not everyone needs that
12:07:34 <merijn> hyperisco: Even concurrency between many readers and single writer is fine
12:07:35 <hyperisco> good luck
12:07:57 <EvanR> clearly if you need real performance you would use mongo
12:07:59 <merijn> chloekek: A bunch of stuff has been added recently, there's window functions now \o/
12:08:25 <dsal> I use sqlite in haskell.  It's pretty nice.
12:08:33 <merijn> hyperisco: Not everyone uses databases for concurrent webservices :)
12:08:38 <lavalike> dsal: what package do you use to interface to it?
12:08:45 <merijn> I've heard good things about sqlite-simple
12:08:46 <dsal> sqlite-simple
12:08:52 <merijn> I might consider trying Selda
12:08:57 <hyperisco> Most web services don't even do concurrency right, so
12:09:01 <merijn> Persistent is too rigid, imo
12:09:11 <dsal> I've backed high volume concurrent web services with sqlite.
12:09:21 <lavalike> excellent
12:09:27 <dsal> It's really one of the best databases out there.
12:09:39 <merijn> A few weeks ago a guy in ##sqlite casually mentioned having several TB in an SQLite database >.>
12:09:42 <dsal> Though mostly, I don't even use it as a database as much as a file format.
12:09:44 <lavalike> :o
12:09:56 <merijn> dsal: IMO if you just know SQLite and postgres you're set for life :p
12:10:06 <lavalike> can't argue with that!
12:10:09 <dsal> Yeah.  Postgres is also pretty great.
12:10:10 <merijn> SQLite where possible, postgres where not :p
12:10:20 <dsal> Yeah, I'm good with that.
12:10:32 <dsal> For anyone who hasn't seen it...  https://sqlite.org/testing.html
12:10:47 <merijn> dsal: Yeah, same here, if you use it as an application file format, where you aware you can store a version number in the database?
12:11:13 <dsal> This is the last database I spent any time in:  https://research.google.com/pubs/archive/41344.pdf
12:11:20 <merijn> dsal: Like, not in a table, there's a dedicated field in the file format spec for version field with user-defined meaning :)
12:11:28 <dsal> Oh neat.  Where is that?
12:11:35 <merijn> dsal: I'm using it to version my schema
12:11:54 <merijn> dsal: https://www.sqlite.org/pragma.html#pragma_user_version
12:12:26 <dsal> Oh neat.  It's been a while since I've read through the pragmas.  For a while, it was my job to know sqlite pretty well.
12:12:35 <lavalike> nice job
12:13:09 <chloekek> I once spent half an hour trying to figure out how to the the SQLite pragma for strict group bys.
12:13:26 <chloekek> Only to find out that it the web page was about hypothetical pragmas that could one day be added.
12:13:31 <dsal> ha
12:13:35 <chloekek> And that unknown pragmas are silently ignored.
12:14:28 <merijn> chloekek: Anyway, so you could actually just push your application logic for map/filter directly into the queries, so that might really work well for your usecase
12:14:37 <dsal> Dr. Hipp is pretty amazing, though.  I was talking to him about doing JSON stuff in SQLite and he sent me an example implementation of a thing he was thinking about like, the next day.
12:15:23 <lavalike> hah!
12:15:47 <hyperisco> So lets say I am a dirty web developer and I want to use SQLite on the client side…
12:17:10 <merijn> hyperisco: Yes?
12:17:51 <hyperisco> The inference is: "how is that done?"
12:18:55 <merijn> There used to be a Web SQL spec, but looks like it was killed
12:19:06 <merijn> Local storage probably has something like that
12:19:38 <hyperisco> I know almost for certain this isn't practically possible. Local storage is a mess on web.
12:19:44 <dsal> Yeah, there's a standard for storing data on the client side.  It almost certainly *uses* sqlite in the browser.
12:20:09 <chloekek> Web SQL is deprecated.
12:20:53 <chloekek> You can compile SQLite to WASM and that'll work but I don't know where you'd store the blob. There's probably an API suitable for that.
12:21:37 <hyperisco> There is no API for file seeking or streaming or any of that. You have to deal in whole file contents.
12:26:47 <hyperisco> Maybe SQLite from a Node environment is possible.
12:27:01 <hyperisco> Minimally, the proper file APIs are there.
12:28:53 <phadej> then one just use the c-lib
12:29:05 <phadej> i'm sure there are bindings
12:29:42 <hyperisco> Unless you have to program for a locked down system, one you cannot install whatever you want on
12:31:11 <comerijn> If you've got a shell and a compiler, you've got SQLite ;)
12:31:22 <hyperisco> No and no :P
12:31:35 <hyperisco> But Emscripten might compile SQLite to run in a Node environment
12:31:36 <merijn> Static link all the things?
12:31:49 <c_wraith> you need a file system with particular semantics to have sqlite.
12:31:51 <merijn> I've seen a Node SQLite thing
12:32:02 <merijn> c_wraith: Not if you run in-memory :p
12:32:29 <merijn> c_wraith: "with particular semantics" <- all you really need is "not broken posix locks" aka "not NFS"
12:32:48 <c_wraith> It doesn't work on WSL...
12:32:50 <hyperisco> I am not sure what Node has to say about locks. Probably nothing.
12:32:59 <c_wraith> Which sure isn't using NFS
12:33:12 <c_wraith> It probably does have broken locks
12:33:12 <hyperisco> Actually almost certainly nothing. I don't think any of Node is defined beyond names of things.
12:35:31 <hyperisco> This is the basic problem I encounter trying to use any respectable database solution
12:36:18 <phadej> locked down system with Node.js pre-installed? Run out of that job, as far as you can.
12:36:37 <phadej> a problem not worth solving
12:37:15 <hyperisco> It is, uh, a creative opportunity
12:38:05 <dsal> I use sqlite in memory regularly.
12:39:17 <monochrom> That just moves the locking question to the inter-thread level :)
12:39:45 <monochrom> "does your shared memory have not-broken locking semantics?" >:)
12:41:23 <monochrom> Actually the shared memory is OK. The multiple cores have instruction re-ordering and local caching and delayed writing, that's where locking semantics is messy.
12:44:13 <monochrom> Everyone needs to go watch Ford vs Ferrari when it comes out to experience how human lives and millions of dollars of investment can perish if so much emphasis is placed on "performance" and so much safety is sacrificed.
12:45:23 <sternmull> I tried to solve some simple equational reasoning exercises from https://ertes.eu/tutorial/foldr.html and got someting that looks ok. But see https://gist.github.com/sternmull/0cda4ffb18b9204dddccfbdf376fd896 Is it ok to strip the last argument on the right and left side if it is equal? See the last few lines, looks like i am taking a wrong turn there. But i don't understand how that happens.
12:46:02 <monochrom> Most people are like, in the trailer, that suit-and-tie boss whom Matt Damon brought into a racing car prototype and asked "are you ready?".  You think you're "born to be ready".  But no, after the ride you find out you are not ready.
12:49:07 <tabaqui1> ah, what a heck?!
12:49:12 <hyperisco> sternmull, it is not okay if you're not sure if it is okay ;)
12:49:27 <tabaqui1> dbus package exports different types with the same name Signal
12:50:12 <tabaqui1> I've never seen such s**t before
12:50:19 <sternmull> hyperisco: But why not? If "a x = b x" then "a = b" is not ok?
12:51:18 <hyperisco> sternmull, I just mean, it is fine to ask if your justification holds, but if the question is "is it okay to take a step I cannot justify" then the answer is always no
12:51:44 <hyperisco> sternmull, yes, in Haskell, if  a x = b x  for all x  then  a = b
12:51:58 <tabaqui1> sternmull: in general, you can use point-free definition, ofc, but in this specific case you cannot
12:52:07 <ski> sternmull : fyi, this is called "function extensionality"
12:52:26 <tabaqui1> because if you use pattern matching in function definition, each rule should have the same number of arguments
12:52:59 <tabaqui1> so you cannot "f [] x = smth; f xs = smth2"
12:53:04 <sternmull> but why do i come to the wrong solution in that last part?
12:53:38 <hyperisco> sternmull, where does _j appear from?
12:54:07 <hyperisco> And _n as well
12:54:23 <sternmull> hyperisco: it is a placeholder for the second argument to maybe, see below the the "Template:" comment
12:54:57 <hyperisco> okay, so they are unbound variables
12:55:04 <sternmull> https://ertes.eu/tutorial/foldr.html is the original source (for the case i messed something up)
12:55:30 <hyperisco> mApply defY (Just f) = \x -> maybe _n _j (Just f)
12:56:24 <hyperisco> So then you have  (\x -> maybe _n _j (Just f)) = f  and I am not sure where you'll go from there
12:56:34 <sternmull> you mean stripping the last argument on both sides is not valid?
12:57:10 * ski misses ertes .. :/
12:57:13 <hyperisco> Only by assuming  mApply defY (Just f) x = f x  for all x
12:57:43 <hyperisco> If that is true, then  mApply defY (Just f) = f
12:58:27 <hyperisco> If it is only true for some x then you would start doing case analysis on x
12:58:37 <sternmull> i am not sure i get that, during this equational reasoning stuff... isn't something like x a placeholder for all possible values for x?
12:59:11 <sternmull> i don't get what "foar all x" adds
12:59:28 <hyperisco> That's the implicit quantifier
13:00:22 <hyperisco> id x = (*2) x  only for some x, not all x
13:01:10 <hyperisco> So, there is a distinction to be made. Yes, in the sort of reasoning you are doing, it is implicitly assumed you're talking about "all" and not "some".
13:01:14 <merijn> ski: I'm glad his site got mirrored/reinstated (I forgot who was responsible)
13:07:02 <monochrom> sternmull: Either you start with "mApply d Nothing x = d; mApply d (Just f) x = f x" and accept that the solutions to _n and/or _j will have to use that x, or...
13:07:48 <monochrom> or you start with "mApply d Nothing = \x -> d; mApply d (Just f) = \x -> f x" if you want to be less pointful.
13:09:13 <ski> merijn : one "Michael Fitzmayer", apparently
13:10:36 <ski> sternmull : `forall x. (f x = g x => f = g)' is very different from `(forall x. f x = g x) => f = g'
13:12:45 <sternmull> ski: Is it about the scope of "forall x"? Does it not enclose "g x" in the second version?
13:13:43 <hyperisco> forall x. ((-1) x = (+1) x => (-1) = (+1))  is true
13:14:16 <hyperisco> actually it is true in the second example too isn't it lol
13:14:45 <monochrom> Actually "_j f = f" is fine. (Hell, my "\x -> f x" is merely f.)  But _n is \_ -> defY, not defY alone.
13:15:21 <hyperisco> Use  id  and  (*2)  again then
13:15:29 <monochrom> Long story short if you want to be pointfree, you've got to be consistently pointfree for both the Nothing case and the Just case.
13:15:54 <hyperisco> forall x. (id x = (*2) x => f = g)  is false, but  (forall x. id x = (*2) x) => f = g  is true
13:16:10 <ski> sternmull : yes, it's about the scope (and "polarity"). but no, `(forall x. f x = g x) => f = g' means `(forall x. (f x = g x)) => f = g'
13:16:20 <monochrom> If you want to write "foo d (Just f) = f" then you also have to write "foo d Nothing = \_ -> d".
13:16:54 <hyperisco> Because in the first example there is a counter-example of  x = 0
13:16:55 <ski> sternmull : note that `forall x. (f x = g x => f = g)' is the same as `(exists x. f x = g x) => f = g' .. which hopefully now is clearly different from `(forall x. f x = g x) => f = g'
13:17:22 <hyperisco> And because of that counter-example,  forall x id x = (*2) x  is false, so any implication from that is true
13:17:45 <ski> sternmull : `forall x. (f x = g x => f = g)' would claim that if `f' and `g' give the same result, for *any* given input (it's enough with one), then they're equal
13:18:17 <ski> sternmull : `(forall x. f x = g x) => f = g' would claim that if `f' and `g' give the same result, for *every* possibly input, then they're equal
13:18:40 <hyperisco> Maybe it is useful to expand  f = g
13:19:04 * ski replaces hyperisco's `f' respectively `g' with `id' resp. `(* 2)'
13:19:16 <hyperisco> forall x. (f x = g x ⇒ (forall y. f y = g y))
13:19:44 <hyperisco> vs  (forall x. f x = g x) => (forall y. f y = g y)
13:20:31 <sternmull> i knew i have a knowledge gap considering "forall" but i did not expect it to get relevant here...
13:21:04 <hyperisco> This is covered in intro logic courses, of which I am sure you can find on YT or something
13:22:07 <EvanR> what's YT
13:22:12 <merijn> EvanR: YouTube
13:23:13 <dmwit> tabaqui1: You almost certainly have seen that before. Map, Vector, ByteString, Text all spring to mind as examples.
13:24:48 <hyperisco> Go learn about LEM so we can yank it away from you
13:32:59 <merijn> Man, sometimes tiny seemingly insignificant features can make your program so much better :>
13:33:20 <merijn> I just added and automatic pager to all large outputs of my program and it's brilliant :D
13:36:49 <sternmull> Thanks guys. I don't really get it yet. But i think you helped me quite a bit.
13:39:02 <hyperisco> merijn, that happens if you measure features by LoC or implementation difficulty
13:44:18 <EvanR> fly on the wall in a scrum hears: Good job last week we accomplished N units of implementation difficulty
13:47:09 <hyperisco> Approximate by hours spent
13:47:20 <EvanR> even better
13:47:42 <EvanR> last week, 40 hours of difficulty accomplished
13:47:47 <EvanR> we maxed out
13:48:05 <hyperisco> Under that metric, tedious is indistinguishable from difficult, but maybe if you mix LoC into the measure you can counteract that
13:48:57 <merijn> If tediousness valued into it, then my current problem would reign supreme >.>
13:49:23 <hyperisco> High hours and high LoC is tedious, high hours and low LoC is difficult. Low hours and high LoC is copy&paste, low hours and low LoC is an easy patch.
13:49:54 <merijn> Oh! Never mind, I think I may have realised a workaround
13:51:56 <hyperisco> My only point is https://xkcd.com/1425/
13:52:57 <koz_> hyperisco: With the addendum 'and even then, it'll be at best 50% accurate'.
13:54:28 <dmwit> I wonder if anyone tries to use stereo vision to make a 3d model of the objects in photos for computer vision.
13:54:54 <MarcelineVQ> acowley: do they?
13:54:58 <ultr0n> what is a stereo vision
13:55:11 <dmwit> Now that I say it aloud, I'm almost certain this idea has occurred to somebody. So the fact that I don't hear about it literally everywhere probably means it's only marginally better than non-stereovision.
13:55:14 <EvanR> dmwit: someone showed me an app their company is working on... it does that, only without stereo
13:55:29 <dmwit> ultr0n: two eyes/cameras
13:55:37 <EvanR> he moved the phone around their head and it produced a color 3D model of their head
13:55:51 <EvanR> very impressive
13:56:05 <dmwit> neat!
13:56:23 <EvanR> company name uhhh Scandy
13:56:33 <ultr0n> EvanR:Thats pretty good actually doing it without stereo vision
13:56:50 <EvanR> even better than stereo, a moving camera video
13:59:05 <hyperisco> dmwit, you can get apps on your phone for that
13:59:31 <hyperisco> Like EvanR said, doesn't require stereo. It uses parallax instead.
13:59:33 <merijn> Man, Haskell is freaking magic... "oh, lemme just do a minor factoring and support nested parallel pipelines with a shared resource pool in less effort than it'd take to read a file in C"
14:00:08 <koz_> merijn: Yeah, I can agree to that.
14:02:07 <hyperisco> dmwit, the keyword is https://en.wikipedia.org/wiki/Photogrammetry
14:49:31 * hackage atlassian-connect-descriptor 0.4.10.0 - Code that helps you create a valid Atlassian Connect Descriptor.  https://hackage.haskell.org/package/atlassian-connect-descriptor-0.4.10.0 (RobertMassaioli)
15:12:17 <kiwi_95> i have a function thats like map but has an extra argument that takes in a random generator StdGen: (map f rng xs), and whether or not f is applied to x is dependent on rng
15:12:49 <kiwi_95> is there a clean way i can do this with the state monad
15:13:52 <kiwi_95> also rng would be updated with every recursive call
15:17:32 <dmwit> :t mapM
15:17:34 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
15:17:40 <dmwit> see also
15:17:43 <dmwit> ?hackage MonadRandom
15:17:43 <lambdabot> http://hackage.haskell.org/package/MonadRandom
15:18:34 <dmwit> (Which is just a tiny wrapper around State WhateverRandomSeedType that lets you mix another stateful monad in if you like.)
15:19:05 <dmwit> :t mapM @[] -- may be more enlighteningh
15:19:06 <lambdabot> error:
15:19:07 <lambdabot>     Pattern syntax in expression context: mapM@[]
15:19:07 <lambdabot>     Did you mean to enable TypeApplications?
15:19:13 <dmwit> % :t mapM @[]
15:19:13 <yahb> dmwit: Monad m => (a -> m b) -> [a] -> m [b]
15:20:41 <kiwi_95> how mapM would help is not totally clear
15:21:04 <kiwi_95> looking at MonadRandom now
15:26:33 <boxscape> Hm, I kinda like this proof style that ghc's constraint solving allows you to do https://pastebin.com/jcZrKPvV
15:26:41 <boxscape> just list all the little lemmas and ghc will do the rest
15:26:51 <boxscape> i.e. plumbing
15:29:13 <boxscape> (Actually I don't need the sym, that's part of said plumbing)
15:40:27 <cheater> i have a function that generates a list l :: [([(Int, Int)], [Int])]. I would like to test using hedgehog that if i take a member of this list (call it (xs, ys)), take the fst of that element (xs, it is a list itself), and take one pair from that (call it a, b), then if i look at that list l again, and look at (snd (l !! a)) !! b, then that refers to a specific number. I want to know that each number ...
15:40:33 <cheater> ... is refered to only once from within the list. how can i build this property test?
15:41:06 <cheater> i have a function that validates whether i can add stuff to the list. but i'm not sure how to use it while generating the list.
15:42:04 <sm[m]> merijn: I’m interested in your auto pager output, eg when does it cause hassles
15:45:38 <sm[m]> or, how does one do that robustly
15:45:52 <sm[m]> Eg on Windows
15:54:43 <cheater> actually let me simplify something. i'd like to create a list [Int] where the first element doesn't matter and the subsequent elements refer to previous entries in the list (just the index of the list), but each entry can be referred to only once. how would i generate that?
15:55:26 <cheater> let's say putting in 0 means "refers to nothing"
15:55:43 <cheater> so that the list isn't trivial
16:02:24 <dmwit> cheater: nub xs == xs fir one part; all (uncurry (<)) . zip [0..] for the other part
16:03:18 <dmwit> nub xs == filter (0<) xs, I guess
16:03:37 <dmwit> (There are more efficient implementations of nub in case that becomes a bottleneck.)
16:08:44 <cheater> :t nub
16:08:45 <lambdabot> Eq a => [a] -> [a]
16:09:23 <cheater> oh, no, that's exactly not what i wanted :) :)
16:09:37 <cheater> i mean it works to solve this simplified version
16:09:46 <cheater> but doesn't work for the more involved version that i posted above
16:17:46 <inkbottle> https://hoogle.haskell.org/?hoogle=runSpock; Why doesn't it return an answer?
16:18:04 <inkbottle> https://hackage.haskell.org/package/Spock-0.13.0.0/docs/Web-Spock.html
16:24:05 <cheater> hoogle doesn't seem to know about the package Spock
16:24:11 <cheater> weird!
16:37:32 * hackage morpheus-graphql 0.4.0 - Morpheus GraphQL  https://hackage.haskell.org/package/morpheus-graphql-0.4.0 (nalchevanidze)
17:03:31 * hackage amazonka-s3-streaming 1.1.0.0 - Provides conduits to upload data to S3 using the Multipart API  https://hackage.haskell.org/package/amazonka-s3-streaming-1.1.0.0 (AlexMason)
17:06:26 <cheater> am i stupid to report this as an issue? nad in if you like.)
17:06:26 <cheater> 00:18 <     dmwit > :t mapM @[] -- may be more enlighteningh
17:06:30 <cheater> erm, sorry
17:06:40 <cheater> this here https://gitlab.haskell.org/ghc/ghc/issues/17326
17:09:36 <cheater> in my .cabal, i have test-suite test, with main-is test.hs. how can i tell stack to open ghci (like stack ghci), but rather than open the Main module from Main.hs, open the Main module from test.hs?
17:12:47 <sshine> ✗ NumLit failed after 2 tests and 51 shrinks. <-- turns out there was a bug in the generator, heh.
17:13:30 <sshine> cheater, that's a good question.
17:13:41 <sshine> cheater, 'stack ghci yourproject:test'
17:13:46 <cheater> interesting
17:13:49 <cheater> thanks
17:14:23 <sshine> cheater, or just 'stack ghci :test' will work, I realize.
17:15:06 <cheater> oh you can do stack ghci --test and it'll ask you to select your Main
17:15:27 <cheater> looks like it's all described here https://docs.haskellstack.org/en/v1.7.1/build_command/#target-syntax
17:15:45 <cheater> sshine: what do you think of the bug report? good or bad?
17:15:57 <sshine> you have a point. type errors can be cryptic.
17:16:21 <cheater> i was also wondering if i maybe just missed something that allows this to be displayed already
17:17:42 <cheater> also thanks :)
17:17:44 <sshine> cheater, unfortunately there is some minimum required understanding to decipher type errors. in this case, looking at 'expected' and 'actual' should at least reveal that 'sample' is a function.
17:18:39 <cheater> sure, yeah
17:18:45 <cheater> i mean i did understand the type error
17:19:02 <cheater> it's just that having the class show would have lead me to the solution much faster :)
17:19:11 <sshine> cheater, GHC tries to convey that by saying that maybe you didn't apply enough arguments. even then, that would never result in (). it's difficult to cater meaningful errors to all audiences.
17:19:26 <cheater> sure
17:20:00 <sshine> cheater, right. so it could probably have mentioned the constraints of m0.
17:20:19 <sshine> I don't know, I just kinda live with it. :P
17:20:22 <cheater> it would have been useful :)
17:20:28 <cheater> so do i :)
17:20:49 <sshine> whenever someone new is hired where I work, I always realize how much we internalize as unchangeable until someone comes along who hasn't accepted the same premises.
17:23:43 <sshine> cheater, I think maybe mentioning the constraints would, in some cases, confuse the reader, too. e.g., what if it said 'MonadIO m0 => GenT Identity a -> m0 a'?
17:24:04 <sshine> (Gen is just an alias for GenT Identity.)
17:24:30 <monochrom> (This is why I am against type aliases >:) )
17:24:41 <sshine> I don't have any recollection of the evolution of GHC type errors, but I seem to recall that you'd get much more incomprehensible error message at one point.
17:28:45 <sshine> cheater, how's Hedgehog going?
17:38:51 <inkbottle> "stack exec -- ghcid -T :main" doesn't work, is the syntax incorrect? 
17:38:59 <inkbottle> stack exec -- ghcid --version; works
17:39:29 <inkbottle> stack exec -- ghcid --test=":main"; doesn't work
17:40:22 <inkbottle> "/bin/sh: stack: command not found"; "exited unexpectedly"
17:45:35 <cheater> sshine: slowly :)
17:45:58 <cheater> yes, maybe mentioning constraints could be a bit confusing sometimes
17:53:00 <inkbottle> It seems running "ghcid -T "main" in "nix-shell -p ghcid", is working, at least I don't get "command not found error"
18:00:05 <dmwit> cheater: Well, I don't understand the bigger property you want to test. Can you go one step more complicated, so that nub isn't right, but not all the way to the incomprehensible version?
18:01:28 <cheater> i'm not even trying to test a property yet, just generate input to a property
18:02:03 <cheater> basically i have a list, and each element of the list can hold a few values. and then that element can also refer to a few of the past values (earlier in the list)
18:03:04 <sshine> cheater, it seems that you have a [(Int, Int)] in there. why not use a data type that prevents duplicates, rather than test that it doesn't have them?
18:03:32 <sshine> cheater, e.g. Map Int Int.
18:04:00 <cheater> i don't
18:04:13 <sshine> elab
18:04:27 <cheater> i don't know where you saw [(Int, Int)]
18:04:41 <sshine> <cheater> i have a function that generates a list l :: [([(Int, Int)], [Int])].
18:05:00 <sshine> that's what you called xs.
18:05:39 <sshine> if I understood you correctly.
18:05:57 <cheater> right
18:05:59 <cheater> that's not a map
18:06:08 <sshine> is it a BiMap?
18:06:09 <cheater> the (Int, Int) is an address
18:06:41 <cheater> the first index is an index into the whole list. then you take the element of the list, look at the right side of it, and that's another list. the second index of the address is an index into that list.
18:07:04 <cheater> think of it this way, if you had [[Int]], to find a specific number in it, you'd need to use two numbers.
18:07:07 <cheater> that's how you do it here.
18:13:31 <cheater> i.e. if u :: [[Int]] then to get at a number you'd do (u !! 1) !! 7
18:13:36 <cheater> or something like that :)
18:13:51 <cheater> so you'd encode it as 
18:13:54 <cheater> (1, 7)
18:16:48 <cheater> and so in the more complicated type which is l :: [([(Int, Int)], [Int])]   if you had eg [([], []), ([], [5, 4, 3, 2]), ([(1, 3), (1, 1)],[])]     then the last element of l would be refering to the numbers 2 and 4, respectively
18:48:52 <cheater> is there a generic function that will take a list and return 0, 1, 2 ... for as long as the original list is?
18:49:12 <cheater> e.g. ["foo", "bar", "baz"] -> [0, 1, 2]
18:49:47 <cheater> all i do is fst <$> (zip [0, ..] xs) but i'm not sure if there isn't a better way
18:49:55 <MarcelineVQ> zipWith const [0..]
18:50:09 <cheater> :t zipWith
18:50:10 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
18:50:13 <cheater> oh
18:50:23 <cheater> that's a good idea, thanks MarcelineVQ!
18:52:09 <sshine> cheater, if you'd like to property test something, I have an open issue for something beginner friendly: https://github.com/sshine/hs-jq/issues/3 (item 3)
18:52:16 <sshine> cheater, err, item 2 and 3.
18:54:48 <cheater> i know the examples i post here seem simple but they're actually simple versions of a project i'm working on :)
18:56:53 <sshine> I don't think [([(Int, Int)], [Int])] is simple. :)
18:57:31 <sshine> it seems like you're doing a lot of things at once.
18:58:59 <dmwit> cheater: "i have a function that generates a list ... how can i build this property test?" and "i'm not even trying to test a property yet, just generate input to a property" appear to me to be in contradiction.
18:59:38 <cheater> that's true dmwit
18:59:51 <cheater> i'm still trying to work out what exactly best to do
19:00:05 <cheater> but i'm getting ahead :)
19:00:14 <koz_> zipWith const is so cool, someone wrote a whole article on it: https://github.com/quchen/articles/blob/master/2018-11-22_zipWith_const.md
19:01:45 <iqubic> :t (>>=) (>>=)
19:01:47 <lambdabot> Monad m => (((a -> m b1) -> m b1) -> m a -> b2) -> m a -> b2
19:02:16 <cheater> koz_: that's so cool!
19:02:20 <koz_> cheater: Agreed.
19:02:44 <iqubic> :t zipWith const
19:02:46 <lambdabot> [c] -> [b] -> [c]
19:04:08 <iqubic> > drop 1 [1,2,3]
19:04:10 <lambdabot>  [2,3]
19:06:31 <Axman6> > let halve' (_:_:xs) = ():halve' xs; halve' (_:xs) = []; halve xs = zipWith const xs (halve' xs) in halve [0..20]
19:06:33 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
19:08:16 <monochrom> Hey I should put that on the exam!  "What does zipWith const do?"
19:08:56 <koz_> monochrom: Then ask them to implement the first example in the article I linked on the next question? :P
19:10:53 <iqubic> :t flip const
19:10:54 <lambdabot> b -> c -> c
19:15:08 <monochrom> Oh that's a good idea too.
19:19:01 * hackage predicate-transformers 0.2.0.0 - A library for writing predicates and transformations over predicates in Haskell  https://hackage.haskell.org/package/predicate-transformers-0.2.0.0 (edmundnoble)
19:21:59 <maerwald> :t const flip
19:22:00 <lambdabot> b1 -> (a -> b2 -> c) -> b2 -> a -> c
19:22:13 <maerwald> oh my, I flipped it
19:23:13 <MarcelineVQ> :t flip const flip const
19:23:14 <lambdabot> a -> b -> a
19:23:34 <jusss`> what fixed-point is used for?
19:24:49 <jusss`> and it's related to id?
19:25:15 <edmundnoble> Hopefully I'll soon give a recorded talk on the predicate-transformers library, and the associated paradigm of test-writing, and link it here. I'm here for any questions about it, though without examples it may be hard to decipher
19:26:31 * hackage libmodbus 1.1.1 - Haskell bindings to the C modbus library  https://hackage.haskell.org/package/libmodbus-1.1.1 (JoeyHess)
19:30:01 <jsomedon> as a new cabal user(and a new user to any haskell toolchains in general) I don't really see how the nix-style cabal solves old cabal's problem? For example, say my project use package A and B, both depends on version C and A depends on version C1 while B on version C2, how does this nix-style cabal-install solve such problem?
19:30:41 <edmundnoble> That is not the problem it solves
19:30:57 <Axman6> that's a problem within a single project. the problem the nix style builds solves is problems between projects on the same machine
19:31:17 <jsomedon> oh
19:31:55 <monochrom> cabal (all versions) doesn't need to solve that problem at all.  It just disallows that.
19:31:58 <Axman6> in the past, if you installed foo-1.0.0.0 for project A, then if project B needed foo, it would also have to use foo. thnk of it like how OS package managers usually work - there was a single version of a package on the system. 
19:32:32 <dmwit> monochrom: Actually, cabal used to support such dependencies and nix-style is less flexible!
19:33:05 <edmundnoble> I wondered about that, when I googled it I saw that it at least used to work
19:33:12 <monochrom> Oh, right, that was a long long time ago.
19:33:22 <dmwit> monochrom: You can have dependency chain A -> B-1 -> D-1 and A -> C-1 -> D-2 and that was allowed, as long as there was no A -> D-anything dependency.
19:33:53 <dmwit> Now nix-style says a flat "no" to that.
19:33:58 <dmwit> Which... is no big loss, really.
19:34:06 <monochrom> I agree.
19:34:09 <dmwit> It was almost always a mistake to have that in the first place.
19:35:04 <monochrom> I'm even of the conservative republican opinion that even --global and --user should not do that.
19:35:56 <jsomedon> so you guys mean, the problem old cabal had, and sovled by nix-cabal is: say I have project P1 and P2, and in P1: A->C1, P2:B->C2 then the nix-cabal keeps seperate collection of pacakges for each project
19:36:02 <d34df00d> Hi!
19:36:06 <d34df00d> Is there a notion of strict right fold?
19:36:18 <Welkin> no
19:36:26 <monochrom> I.e., if you already have foo-0.1, cabal install anything should simply refuse to bring in foo-0.2 or foo-0.0 or whatever.
19:36:28 <Axman6> foldr is as strict as the function you give it
19:36:53 <Axman6> > foldr (\_ !_ -> ()) () [0..] -- oops
19:36:57 <jsomedon> monochrom: you mean that's how nix-cabal works
19:36:59 <lambdabot>  mueval-core: Time limit exceeded
19:37:00 <jle`> d34df00d: not for cons lists i don't think
19:37:00 <d34df00d> Hmm. Is there a way to express this avoiding explicit recursion?
19:37:09 <jle`> d34df00d: but for things like snoc-lists or Seq
19:37:10 <Welkin> everything is recursion
19:37:15 <Welkin> you can't escape it
19:37:24 <d34df00d> https://bpaste.net/show/aipf
19:37:24 <monochrom> No nix-cabal is incomparable.
19:37:36 <jle`> hm, i don't think that's true in a meaningful way. that's like saying that everything is bits and logic gates
19:37:45 <d34df00d> jle`: I think Seqs are not lazy enough.
19:38:06 <d34df00d> I basically want to be lazy in my input and strict in the accumulator, handling data in O(1).
19:38:11 <d34df00d> (memory-wise)
19:38:30 <monochrom> that's foldl'
19:38:44 <d34df00d> How do you write it in foldl'? I got the resulting list reversed with foldl'.
19:39:03 <d34df00d> I understand it would be foldl' if I was doing `go ((first, cur) : acc, ...)`
19:39:04 <edmundnoble> Reverse the output
19:39:05 <Axman6> what is acc doing?
19:39:07 <monochrom> Rewrite your binary operator cleverly?
19:39:13 <d34df00d> edmundnoble: that's definitely not O(1).
19:39:16 <jle`> hm, it's tricky because you're returning a list
19:39:33 <jle`> d34df00d: well, nothing you do will make this O(1)
19:39:47 <edmundnoble> Not O(1) in the size of the returned list, anyway
19:39:51 <jle`> oh i see what you mean. memorry-wise
19:39:52 <d34df00d> Axman6: lol, good question. Nothing I think.
19:40:01 <Axman6> yes =)
19:40:03 <edmundnoble> It's not constant memory anyway if you're accumulating this list
19:40:21 <edmundnoble> Your working set size is the same if you reverse it at the end
19:40:30 <monochrom> The paste looks like mapAccumL or mapAccumR I forgot which.
19:40:33 <d34df00d> monochrom: I'm apparently not clever enough.
19:40:52 <d34df00d> edmundnoble: that very code compiles to O(1), so I'm pretty certain it _can_ be done.
19:40:58 <monochrom> Or alternatively use traverse and use State for the applicative.
19:40:59 <d34df00d> (memory-wise)
19:41:28 <edmundnoble> If you consider it O(1) to allocate this list of `n` elements which is returned, then surely reversing that output list doesn't increase that
19:41:35 <jle`> hm, if you want to write this as a foldl, maybe try re-writing your recursion in a "tail-recursive" kind of way
19:41:42 <d34df00d> edmundnoble: it allocates the result lazily in this case.
19:41:56 <edmundnoble> Ah, then you will have to consume it in the same order it is produced
19:42:02 <jle`> then the conversion is a little more straightforward
19:42:13 <d34df00d> edmundnoble: yep, that's true.
19:42:16 <d34df00d> https://bpaste.net/show/f4tO <- the whole program.
19:42:46 <d34df00d> jle`: isn't it, like, already tail-recursive?
19:42:59 <edmundnoble> Looks good, this is just foldr
19:43:01 <jle`> d34df00d: not quite, the problem is line 7
19:43:12 <jle`> d34df00d: you return ??? : go ... ...
19:43:14 <d34df00d> edmundnoble: foldr consumes 1.5 gigs on 70-meg input.
19:43:26 <jle`> d34df00d: if it was tail-recursive, you'd just return go directly
19:43:31 <d34df00d> Ah, I see, right.
19:43:32 <edmundnoble> Show code then
19:43:34 <jle`> so you have to massage `go` to do what you want
19:44:11 <jle`> what are you doing here, exactly?
19:44:13 <d34df00d> edmundnoble: the code's the last paste above. The code to generate "big.txt' is this: writeFile "big.txt" $ unlines $ take 10000000 $ map show $ concat $ unfoldr (\n -> Just ([n..n+2], n+4)) 0
19:44:15 <jle`> what is this function do
19:44:21 <edmundnoble> I mean with foldr, show that code
19:44:23 <Axman6> There's no reason that code should use 1.5GB with appropriate strictness annotations
19:44:32 <monochrom> OK this is not a foldl'.  It is not a clean foldr either.  What you have is already as good as it gets.
19:44:32 <edmundnoble> And if you use foldl', there's no way you'll be able to consume the output list lazily
19:44:41 <jle`> hm, yeah, try O2, strictness annots, etc.
19:44:45 <edmundnoble> Doesn't work out monochrom? I could see that
19:44:49 <Axman6> I can't see how it would possibly be building up that much memory
19:44:55 <edmundnoble> Maybe it's a foldr once you've inspected the list first
19:45:03 <edmundnoble> (to get the first elem if present)
19:45:08 <d34df00d> jle`: ah, we were discussing implementing a stupid interview question with some folks. Given [0, 1, 2, 5, 8, 9] produce [0-2, 5, 8-9] or something similar (modulo formatting).
19:45:40 <d34df00d> jle`: tried -O2, tried strictness annotations (and even {-# LANGUAGE Strict #-}), no luck.
19:45:53 <jle`> yeah that does indeed have a high stupidity score, even for an interview question
19:45:58 <jle`> s/even//
19:46:07 <monochrom> I would blame it on what provides the input list.
19:46:09 <edmundnoble> I've seen stupider
19:46:26 <edmundnoble> At the least it's a smoke test
19:46:42 <jle`> okay yeah this shouldn't be toooo difficult to write in a directly tail recursive way
19:46:44 <d34df00d> That was for a JS position so it's probably OK.
19:47:06 <Welkin> d34df00d: fuck I hate those kinds of questions
19:47:13 <Welkin> I've gotten stupid interview questions like that
19:47:14 <jle`> the problem i think in your code is that you're mixing a foldr-type style with a tail-recursive foldr-type style
19:47:21 <MarcelineVQ> stupid questioins need stupid answers; foo _ = [0-2, 5, 8-9]
19:47:26 <jle`> so it seems a little confused
19:47:39 <jle`> *tail-recursive foldl style
19:47:40 <dmwit> > map ((head &&& last) . map snd) . groupBy fst . zipWith (\i v -> (v-i,v)) [0..] $ [0,1,2,5,8,9]
19:47:42 <lambdabot>  error:
19:47:42 <lambdabot>      • Occurs check: cannot construct the infinite type:
19:47:42 <lambdabot>          b ~ (b, b) -> Bool
19:47:58 <jle`> for example, i see that you attempted to go for a TR style by using acc
19:48:08 <jle`> but then you bypass it by using : at the outer layer, a foldr style thing
19:48:09 <d34df00d> Yeah, then I figured I got my list reversed.
19:48:17 <jle`> so now acc does literally nothing
19:48:27 <d34df00d> Yeah, Axman6 noted that too and it got removed now :)
19:48:29 <jle`> you basically just have to commit to one style over another
19:48:38 <jle`> so we can commit to a tail recursive style and keep acc
19:48:57 <dmwit> > map ((head &&& last) . map snd) . groupBy ((==)`on`fst) . zipWith (\i v -> (v-i,v)) [0..] $ [0,1,2,5,8,9]
19:48:58 <lambdabot>  [(0,2),(5,5),(8,9)]
19:49:07 <d34df00d> The problem with acc is that I prepend the current item to acc before the recursive call, so I get my list reversed.
19:49:07 <jle`> or commit to a foldr style and drop acc
19:49:09 <edmundnoble> That looks appropriately lazy
19:49:19 <monochrom> Under what circumstance does acc become something other than []?
19:49:23 <jle`> d34df00d: that isn't too bad, you can just use a diff list to get O(1) snoccing
19:49:23 <dmwit> monochrom: never
19:49:35 <d34df00d> monochrom: never.
19:49:38 <Axman6> it's unused
19:49:38 <Welkin> what
19:49:54 <jle`> :t foldl'
19:49:55 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
19:50:42 <d34df00d> jle`: I'm sort of cautious to use anything fancier than a very stupid cons-based list as I'm afraid it won't all compile down to some streaming.
19:50:42 <jle`> d34df00d: so you can accumulate into a list, but use a difflist instead of (:)
19:50:52 <d34df00d> But it's certainly worth giving a shot!
19:50:56 <Welkin> or just reverse the list
19:51:11 <jle`> 'streaming' in this context only refers to compositions of builders and consumers
19:51:28 <dmwit> (my solution is a composition of builders and consumers)
19:51:28 <Welkin> don't solve problems you don't have
19:51:35 <d34df00d> Welkin: not O(1) on memory anymore!
19:51:50 <Welkin> who cares?
19:51:52 <jle`> reverse should be properly O(1) memory i believe
19:51:57 <d34df00d> Hmm.
19:51:58 <edmundnoble> Grab dmwit's solution
19:52:00 <jle`> > sum . reverse $ [1..100000000]
19:52:03 <dmwit> Oh, head &&& last is no good for O(1) memory. Fixable, though.
19:52:03 <d34df00d> jle`: that's interesting.
19:52:06 <lambdabot>  mueval-core: Time limit exceeded
19:52:09 <jle`> > sum . reverse $ [1..1000000]
19:52:11 <lambdabot>  500000500000
19:52:12 <jle`> poops
19:52:15 <d34df00d> Welkin: my aesthetics care.
19:52:17 <jle`> that demonstrated nothing
19:52:18 <edmundnoble> `reverse` still requires that the entire list is allocated
19:52:26 <d34df00d> dmwit: nah, ghc is clever enough with -O2.
19:52:27 <edmundnoble> Though it doesn't add to the size of the working set on its own
19:52:38 <jle`> yeah, so we can do this while committing to foldl', let's see if i can draw this out
19:52:42 <dmwit> d34df00d: wow
19:52:43 <d34df00d> Your stuff is better than my straightforward stuff by a constant factor.
19:52:58 <monochrom> -Ocloud-crowd-sourced
19:53:18 <d34df00d> I'd be curious to see an interviewer reaction to that line.
19:53:20 <d34df00d> On a JS interview.
19:53:35 <Welkin> I used haskell and elm and javascript in my interviews
19:53:38 <monochrom> I would type it into a computer.
19:54:05 <Axman6> d34df00d: does removing the tuple argument and passing the arguments directly help at all? the tuple is unnecessary
19:54:06 <monochrom> I am baffled why programmers expect humans to do a good computer job and computers to do a good human job.
19:54:42 <d34df00d> Axman6: you mean with go and explicit recursion? That one is (luckily) good enough memory-wise already.
19:55:07 <d34df00d> I was curious about using folds and stuff for this.
19:55:07 <edmundnoble> I'd bet a small sum that GHC is already removing the tuple
19:55:23 <d34df00d> Or the magic that dmwit casted.
19:55:32 <edmundnoble> zipWith isn't a straightforward fold IIRC
19:55:47 <d34df00d> Who cares? The more library functions and points, the better.
19:55:55 <d34df00d> dots that is.
19:57:00 <iqubic> zipWith isn't a fold at all.
19:57:27 <Welkin> if it's too complicated to write with a fold, just use direct recursion
19:57:47 <jle`> if we commit to foldl' and tail recursive, here's a tail-recursive go
19:57:53 <monochrom> It may be a scanl and then a filter.
19:58:26 <jle`> % let trgo (acc, (x, y)) z | y + 1 == z = (acc, (x,z)) | otherwise = (acc . ((x,y):), (z,z))
19:58:26 <yahb> jle`: 
19:58:44 <jle`> d34df00d: that implements the same logic you had in your paste, but in a tail recursive way
19:58:56 <d34df00d> Ah.
19:59:00 <d34df00d> Sort of unfolded difflist, right?
19:59:21 <jle`> % first ($[]) . foldl' go (id, (0,0)) $ [1,2,3,5,6,9,10,11]
19:59:21 <yahb> jle`: ; <interactive>:172:22: error:; * Variable not in scope: go :: ([a] -> [a], (a1, b)) -> Integer -> ([a] -> [a], (a1, b)); * Perhaps you meant `to' (imported from Control.Lens)
19:59:26 <jle`> % first ($[]) . foldl' trgo (id, (0,0)) $ [1,2,3,5,6,9,10,11]
19:59:26 <yahb> jle`: ([(0,3),(5,6)],(9,11))
19:59:33 <jle`> not sure what you mean by unfolded
19:59:38 <jle`> but 'acc' is a diff list there
19:59:58 <d34df00d> I mean, not packed into a proper newtype and production-ready librarized. Nvm.
20:00:10 <Welkin> do you pronounce `acc` as "ass" or "ack"?
20:00:14 <Welkin> I say "ass"
20:00:17 <Welkin> er
20:00:18 <jle`> oh you mean like not newtype'd to give it a proper Functor instance
20:00:21 <Welkin> "ack"
20:00:29 <jle`> and a proper Foldable instance
20:00:42 <monochrom> "a" because I would just write "a" in the first place.
20:00:43 <jle`> yeah we're just using a difflist here that isn't compatible with the Functor or Foldable typeclass
20:01:02 <d34df00d> Well, since it can be interpreted to be written in cyrillic letters, and if I read those in russian, I get something really close to "ass'(.
20:01:05 <jle`> but that's fine because we only ever snoc to it
20:01:14 <dmwit> > foldr (\x v -> Just (maybe (x,x,[]) (\(start,end,pairs) -> if x+1==start then (x,end,pairs) else (x,x,(start,end):pairs)) v)) Nothing [0,1,2,5,8,9]
20:01:15 <lambdabot>  Just (0,2,[(5,5),(8,9)])
20:01:22 <dmwit> gross
20:03:23 <d34df00d> jle`: yeah, that's nice. I should practice more with this style.
20:03:30 <dmwit> oh!
20:03:37 <jle`> i don't know if it has the memory footprint you're looking for though
20:03:46 <Welkin> one-liners are not a virtue
20:03:50 <dmwit> > foldr (\x v -> case v of (start,end):pairs | x+1==start -> (x,end):pairs; _ -> (x,x):v) [] [0,1,2,5,8,9]
20:03:52 <lambdabot>  [(0,2),(5,5),(8,9)]
20:03:54 <Welkin> readable and understandable is best
20:04:34 <d34df00d> dmwit: > ;
20:04:35 <d34df00d> Cheating!
20:04:37 <dmwit> This probably forces the whole list into memory, though? I don't... really have a good intuition for how it behaves operationally.
20:05:02 <jle`> what is memory anyway
20:06:44 <Axman6> baby don’t hurt me, don’t hurt me, no more
20:07:16 <Welkin> it's a grid of capacitors
20:07:32 <Welkin> or magnetic discs/tape
20:07:36 <d34df00d> Welkin: not necessarily.
20:07:39 <d34df00d> Cores, all that stuff.
20:08:41 <dmwit> I wonder if we can make it so that it's visibly (x,_):_.
20:08:43 <dmwit> Let's see...
20:10:01 <dmwit> > foldr (\x v -> let (next,rest) = case v of { (start,end):pairs | x+1==start -> (end,pairs); _ -> (x,v) } in (x,next):rest) [] [0,1,2,5,8,9]
20:10:03 <lambdabot>  [(0,2),(5,5),(8,9)]
20:10:14 <dmwit> There we go. That one should have the right operational behavior.
20:10:29 <d34df00d> How do you even reason about that?
20:10:30 <dmwit> > foldr (\x v -> let (next,rest) = case v of { (start,end):pairs | x+1==start -> (end,pairs); _ -> (x,v) } in (x,next):rest) [] [0,2..]
20:10:33 <lambdabot>  [(0,0),(2,2),(4,4),(6,6),(8,8),(10,10),(12,12),(14,14),(16,16),(18,18),(20,2...
20:10:36 <dmwit> ^_^
20:11:09 <dmwit> jle`: What do you think of this solution?
20:11:16 <jle`> i can dig it
20:11:19 <jle`> i resonate a lot more with a foldr version
20:11:22 <dmwit> d34df00d: Well... you just... I dunno. Think about it really hard?
20:11:54 <dmwit> d34df00d: Like, you picture what it would have to compute to know whether the `case` match on the recursive value of the tail matched this pattern or that one.
20:11:55 <jle`> it feels like something more naturally foldr since the list is basically producable as it is consumable
20:11:59 <Axman6> > foldr (\x v -> let (next,rest) = case v of { (start,end):pairs | x+1==start -> (end,pairs); _ -> (x,v) } in (x,next):rest) [] $ filter (\x -> mod x 3 /= 0 && x mod 5 /= 0) [0..]
20:12:01 <lambdabot>  error:
20:12:01 <lambdabot>      • No instance for (Integral
20:12:01 <lambdabot>                           ((Integer -> Integer -> Integer) -> Integer -> Inte...
20:12:13 <Axman6> > foldr (\x v -> let (next,rest) = case v of { (start,end):pairs | x+1==start -> (end,pairs); _ -> (x,v) } in (x,next):rest) [] $ filter (\x -> mod x 3 /= 0 && mod x 5 /= 0) [0..]
20:12:15 <lambdabot>  [(1,2),(4,4),(7,8),(11,11),(13,14),(16,17),(19,19),(22,23),(26,26),(28,29),(...
20:12:18 <jle`> er... it's consumable as it is being produced
20:12:27 <jle`> so it makes sense to be foldr, which is more of a stream processing style
20:13:08 <jle`> foldl waits until the entire list is consumed to return anything, but in this case it's possible to pop things out as they are created
20:13:08 <dmwit> d34df00d: And then you try to make it so that it can match this pattern or that one with only some small, predictable amount of lookahead.
20:13:57 <dmwit> d34df00d: In this case, to know which pattern matches, you need to know the value of the the fst of the head. So you try to write the result of the calculation in a way that makes this easy to see.
20:14:01 <dmwit> ...and you land where I did.
20:14:14 <dmwit> I dunno. That's a bit of a ramble. Not sure how much sense it makes outside my head and inside yours.
20:14:44 <jle`> you can reason it in terms of stream processing vocabulary, like python iterators or haskell conduit stuff
20:14:54 <jle`> "take item. if matches condition, yield. repeat"
20:15:00 <jle`> "yield" here is the consing to rest
20:15:31 <jle`> oh hm dmwit did something tricky here that throws off my analysis
20:15:31 * hackage hackport 0.6.1 - Hackage and Portage integration tool  https://hackage.haskell.org/package/hackport-0.6.1 (solpeth)
20:15:49 <dmwit> Yes, that let is trickier than it appears at first glance.
20:16:02 <jle`> in stream processing you're not really supposed to directly inspect the things downstream ...
20:16:30 <jle`> er, downstream as in the things you have outputted, not downstream as in down the stream you are processing
20:16:41 <jle`> english is weird
20:17:25 <jle`> that's sneaky.
20:18:52 <Welkin> downstream is where you find all the dead bodies
20:18:54 <jle`> without resorting that sneaky trick, i think mapAccumR would let you do this in a more principled way
20:19:09 <dmwit> gotta abuse that "write-once mutation" to the best of your ability
20:19:21 <dmwit> you'll never get the title "sneaky" if you don't
20:19:38 <d34df00d> I don't understand that mutation.
20:19:40 <d34df00d> I think.
20:19:53 <jle`> hm, no not mapAccumR.
20:20:35 <jle`> well actually yes maybe
20:21:15 <jusss`> Y g = g (Y g)  = g (g (Y g)) ?
20:21:51 <dmwit> ?let dmwit'sFancyRLE = foldr (\x v -> let (next,rest) = case v of { (start,end):pairs | x+1==start -> (end,pairs); _ -> (x,v) } in (x,next):rest) []
20:21:52 <lambdabot>  Defined.
20:22:01 <dmwit> > fst . head . dmwit'sFanceRLE $ [0..]
20:22:03 <lambdabot>  error:
20:22:03 <lambdabot>      • Variable not in scope: dmwit'sFanceRLE :: [Integer] -> [(c, b0)]
20:22:03 <lambdabot>      • Perhaps you meant ‘dmwit'sFancyRLE’ (line 157)
20:22:14 <dmwit> > fst . head . dmwit'sFancyRLE $ [0..]
20:22:16 <lambdabot>  0
20:22:27 <dmwit> jusss`: yes
20:23:03 <jusss`> dmwit: how to know if there's a Y for g?
20:23:26 <jusss`> dmwit: not every function can have its Y, right?
20:23:36 <dmwit> Easy: in case there isn't one, invent one and call it an infinite loop.
20:25:15 <dmwit> kadoban: Is a suffix array the same thing as a suffix tree?
20:25:21 <dmwit> (re: http://hackage.haskell.org/package/suffix-array )
20:25:29 <jle`> huh i didn't realize mapAccumL was lazy on the list
20:25:34 <jle`> anyways here ya go
20:27:30 <jle`> % let go_ (x,y) z | y + 1 == z = ((x,z), Nothing) | otherwise = ((z,z), Just (x,y))
20:27:30 <yahb> jle`: 
20:27:47 <jle`> % second catMaybes . mapAccumL go (0,0) $ [1,2,3,5,6,9,10,11]
20:27:47 <yahb> jle`: ; <interactive>:178:30: error:; * Variable not in scope: go :: (a, b) -> Integer -> ((a, b), Maybe a1); * Perhaps you meant one of these: `to' (imported from Control.Lens), `go_' (line 177)
20:27:51 <jle`> % second catMaybes . mapAccumL go_ (0,0) $ [1,2,3,5,6,9,10,11]
20:27:51 <yahb> jle`: ((9,11),[(0,3),(5,6)])
20:28:02 <kadoban> dmwit: No, but they're quite related. A suffix array allows (almost?) all queries that a suffix tree does, but you tend to have to do them a bit differently. In terms of uses, it's something like a space optimized suffix tree, except not quite
20:28:22 <jle`> dealing with getting the first input right, dmwit style, isn't too tricky but it's not as clean on irc
20:29:11 <jle`> % let go__ Nothing z = (Just (z,z), Nothing); go__ (Just (x,y)) z | y + 1 == z = (Just (x,z), Nothing) | otherwise = (Just (z,z), Just (x,y))
20:29:11 <yahb> jle`: 
20:29:17 <kadoban> To be less vague, a suffix array is just a sorted array of all suffixes of a string
20:29:33 <dmwit> kadoban: I'd like to find the minimal rotation of a list. I think I can compute the suffix tree of xs++xs and take the `length xs` prefix of the minimal suffix. Can I do a similar thing with a suffix array? Will one structure or the other likely be faster?
20:29:34 <jle`> % catMaybes . snd . mapAccumL go Nothing $ [1,2,3,5,6,9,10,11]
20:29:34 <yahb> jle`: ; <interactive>:181:29: error:; * Variable not in scope: go :: Maybe a0 -> Integer -> (Maybe a0, Maybe a); * Perhaps you meant one of these: `to' (imported from Control.Lens), `go_' (line 177)
20:29:40 <jle`> % catMaybes . snd . mapAccumL go__ Nothing $ [1,2,3,5,6,9,10,11]
20:29:40 <yahb> jle`: [(1,3),(5,6)]
20:30:01 <jle`> % second catMaybes . mapAccumL go__ Nothing $ [1,2,3,5,6,9,10,11]
20:30:01 <yahb> jle`: (Just (9,11),[(1,3),(5,6)])
20:30:04 <jle`> huh that's annoying
20:30:28 <jle`> well the nice thing about this is that it's O(1) space too because this works for infinite lists
20:30:47 <jle`> % take 3 . catMaybes . snd . mapAccumL go__ Nothing $ [1,2,3,5,6,9,10,11] ++ [23..]
20:30:47 <yahb> jle`: [(1,3),(5,6),(9,11)]
20:31:03 <d34df00d> Alright, stupid questions incoming.
20:31:08 <d34df00d> dmwit:  so let's take your last solution.
20:31:16 <dmwit> yay!
20:31:21 <jle`> so this method demonstrates more cleanly the 'stream -based processing with yield' thought process
20:31:38 <d34df00d> Let's say I put not the second element in `next`, but the whole pair.
20:32:10 <d34df00d> (so it's gonna be ((x, end), pairs) and ((x, x), v) in the corresponding case branches)
20:32:32 <d34df00d> This immediately kills all the streaming and makes a huge difference on memory consumption.
20:32:34 <d34df00d> So, why?
20:32:37 <kadoban> dmwit: yes, you should be able to do exactly the same thing. A suffix array should usually be faster I believe, but no promises mine actually will be. I didn't get around to doing much optimization on that implementation, even ignoring that i didn't pick the exactly optimal algorithm either
20:33:04 <kadoban> (because it was more complicated to implement)
20:33:17 <dmwit> kadoban: Great, thanks! Looks like there are other implementations on Hackage, too, so I'll test a few. I asked you because you were the only name I recognized. =P
20:33:29 <kadoban> :)
20:33:51 <dmwit> d34df00d: Actually, I bet that's not the important change you made.
20:34:08 <dmwit> d34df00d: The important change was that in the `in ...`, you changed `(x,_):_` to something else.
20:34:35 <d34df00d> Yes. It changed from `(x, next) : rest` to `next : rest`
20:34:39 <d34df00d> Why does it matter?
20:34:45 <dmwit> d34df00d: It's really key that the `in ...` have the form `(x,_):_`, because in the next iteration of the fold, we're going to put that thing in `case ... of (start,end):pairs ->`.
20:35:03 <dmwit> d34df00d: And we want that `case` to be able to decompose cleanly and easily without recursing.
20:35:26 <dmwit> d34df00d: In your version, knowing the value of `start` requires evaluating the `case` of the recursive call to `foldr` on the tail.
20:35:30 <dmwit> d34df00d: In my version... not.
20:35:42 <d34df00d> Ah!
20:35:45 <d34df00d> Sneaky!
20:35:50 <dmwit> yay!
20:35:55 <d34df00d> Yeah, got it.
20:35:57 <d34df00d> I think.
20:36:00 <d34df00d> I'll have to internalize this.
20:36:33 <d34df00d> (which is a smart way for saying "stare at the code until I get the completely unjustified feeling of understanding")
20:37:09 <dmwit> Come back any time and explain how it works, and we'll happily pick apart any reasoning which isn't absolutely correct. ^_^_^
20:38:03 <d34df00d> That's what I call a helpful community!
20:38:15 <d34df00d> (no jokes, you folks are great)
20:39:01 <dmwit> d34df00d: (For an example of how you could make the first change you proposed, but not the important change, instead of `next:rest` you could have written `(x,snd next):rest`, and that would have also been fine and stream correctly.)
20:39:27 <d34df00d> Yeah, I basically need to make the form of the argument known.
20:39:43 <dmwit> yep
20:39:44 <d34df00d> Which is I now understand you meant by "I wonder if we can make it so that it's visibly (x,_):_."
20:39:54 <dmwit> exactly
20:40:22 <dmwit> I noticed that both branches had that form, and that this was the form I needed for the pattern match.
20:40:26 <d34df00d> Reasoning about this sort of stuff is perhaps the hardest part in haskell for me. Not all the datakinds and typeintype.
20:40:38 <dmwit> Oh, heck, it's hard for everybody.
21:15:14 <justsomeguy> Does Haskell have statements?
21:16:41 <heatsink> What kind of statements are you referring to?
21:17:03 <justsomeguy> Chunks of code that have some effect, and don't reduce to a value.
21:17:14 <justsomeguy> (It's more of a conceptual question.)
21:17:36 <heatsink> Things of IO type are basically that
21:18:05 <heatsink> Like `do { s <- getLine; putStrLn s }
21:19:01 <heatsink> `getLine` and `putStrLn s` don't reduce any further.  They have side effects.
21:19:56 <justsomeguy> Those are good examples. I came across this blog post that argues that Haskell doesn't have statements, which is why I'm asking about it here. http://www.haskellforall.com/2013/07/statements-vs-expressions.html
21:20:52 <justsomeguy> I don't really understand monads yet, though, so I'm not sure if just wrapping a statement in a monad magically makes it an expression somehow. I don't see how it possibly can.
21:20:59 <ChaiTRex> justsomeguy: Well, it's kind of like your imperative program in a do block is technically a value. You can write functions that write a program for you because the imperative parts are values.
21:22:17 <heatsink> Compare `putStrLn s` to the C statement `printf("%s", s);`
21:22:26 <heatsink> They both represent a chunk of code that prints s
21:22:55 <heatsink> The Haskell code is a value.  You can put it in a place where it will get executed; you can also put it in a variable, or a data structure
21:23:32 <heatsink> The C statement is not a value.  You can't put it in a variable.  You can only put it in a place where it will get executed
21:24:10 <maerwald> use function pointers ;)
21:24:37 <heatsink> So in Haskell, values like `100` have more in common with values like `putStrLn s`
21:24:55 <ammar2> heh, but then the statement itself isn't the value
21:24:59 <ammar2> the function wrapping it is
21:25:13 <ammar2> (re function pointers, not haskell)
21:26:00 <ChaiTRex> heatsink: Yep. One's a number. One's a short segment of a program. Both are values you can toss around.
21:32:18 <justsomeguy> Couple other questions. Is a function definition an equation? Or is a clause of a function definition an equation, and the entire thing is a declaration?
21:32:54 * justsomeguy is thinking that an equation is a term-level declaration, so an entire function definition would be an equation, but he's not sure.
21:33:22 <justsomeguy> Bouncing around between the haskell report an a few books makes me question the terminology sometimes.
21:36:28 <justsomeguy> A gentle introduction to Haskell says "Function in Haskell are normally defined by a series of equations."
21:37:15 <EvanR> sems right
21:37:24 <EvanR> a gentle intro is still my favorite
21:39:16 <justsomeguy> I like that it's no-BS. Concise writing is underrated.
21:41:46 <EvanR> it's kind of beautiful when whatever defining equations someone is talking about exactly match the haskell code for some algorithm
21:42:15 <EvanR> certain kinds of haskell definitions break the illusion by overlapping on purpose
21:44:03 <justsomeguy> EvanR: There's a book called Introduction to Recursive Programming that has all it's example code written in math notation first. Translating it to Haskell was almost just like writing the mathematical definitions. Was a pretty cool experience.
21:44:39 <justsomeguy> Until my brain melted out through my ears and I had to stop. I'll come back to it, though.
21:46:42 <EvanR> i have The Haskell Road to Logic, Maths and Programming
21:47:39 <dmwit> I think that (1) a function definition may have multiple equations and (2) there are probably some resources out there that are not careful about that distinction, so don't worry about it too much if something seems to be inconsistent in that way.
21:47:48 <justsomeguy> Ah, I have that book, too! Looks awesome. Haven't gotten around to reading it yet, though.
21:48:02 <dmwit> It's probably not the author trying to sneakily hide a deep point, just a mistake on the part of the author.
21:49:07 <justsomeguy> dmwit: That's pretty much my conclusion, too. But maybe functions can a be a system of equations? :^)
21:49:33 <DrAwesomeClaws> That book is great (The haskell road).  It's the perfect blend of approachable and in-depth for someone like me who doesn't have a background in maths/category theory 
21:50:18 <EvanR> you can see something like f False = blah and f True = blaw as being equational laws that f satisfies
21:50:38 <EvanR> coincidentally this totally defines f
21:50:40 <EvanR> in this case
21:51:57 <EvanR> point being multiple defining equations makes sense
21:53:46 <DrAwesomeClaws> it's very powerful.  I'm writing some code i originally wrote in typescript.  So many functions just become simple pattern matching in haskell.  
22:14:15 <sarahzrf> EvanR: well, order matters :}
22:14:22 <sarahzrf> for conflict resolution
22:14:33 <EvanR> yeah
22:14:56 <EvanR> unless there is no overlap then order only matters for performance
22:27:25 <jle`> justsomeguy: yeah, haskell has what many call "first-class statements"
22:27:52 <jle`> justsomeguy: whereas statements in most other languages are given special syntax and baked in, haskell "statements" are just normal first-class data types we can manipualte and pass
22:53:15 <c010r> woah
22:53:22 <c010r> thats alotta ppl
22:53:28 <c010r> in this channel
22:54:12 <c010r> whois glguy
22:56:06 <c010r> who is Jacoby6000 
22:56:54 <c010r> w/hois
23:52:29 <jellostahps> Plz help me work this 2 line code. If the predicate is satisfied, add the item to the first list, otherwise add it to the second list....is what I am trying to do. I get compiler errors. https://pastebin.com/6AD2eUig
23:53:00 <jellostahps> I am trying out folds
23:53:49 <EvanR> :t partition
23:53:50 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
23:54:22 <EvanR> jellostahps: well... the error msg is pointing out this <-
23:54:30 <EvanR> lambda has ->
23:57:03 <jellostahps> oh damn, thx
23:57:48 <jellostahps> first actual attempt at folds, im proud thats the only error heh
23:58:11 <jellostahps> *other than the fact that the code doesn't do what i want it to
23:58:30 <EvanR> yeah that's bad
23:59:30 * EvanR points out that "p x == True" is redundant because it equals "p x"
23:59:52 <jellostahps> jellostahps: is very thankful
