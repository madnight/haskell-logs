00:00:00 <EvanR> (though this package probably needs some maintanence for latest ghc and base)
00:05:51 <ariakenom> jusss: that depends more on which packages you look at than which language they are in
00:13:16 <tdammers> there is a breathtaking amount of lousy, underdocumented, buggy code in the python universe too. it may be a bit less visible though
00:13:36 <tdammers> honestly, I don't think the problem is that "haskellers don't document their code"
00:13:47 <maerwald> tdammers: well, well-typed does ;P
00:13:48 <tdammers> it's "hackage is low-threshold"
00:14:00 <tdammers> maerwald: depends on the client ;)
00:14:03 <maerwald> I think the optics package is probably in the top 5 of well-documented packages
00:14:16 <tdammers> but yes, we do value code quality
00:15:03 <maerwald> Also, people often don't seem to understand that documentation isn't enough, but how to *navigate* through your documentation
00:15:39 <maerwald> If I start at some random low-level point of your lib, I'll be lost before I reach the meat
00:15:41 <tdammers> another thing non-haskellers often fail to understand how much someone fluent in haskell can actually infer from the types
00:15:58 <jusss> maerwald: put those mostly used methods examples on the READ.ME
00:16:00 <tdammers> types aren't (always/automatically) *sufficient* documentation, but they *are* documentation
00:16:48 <maerwald> tdammers: yeah, depends on how big the domain of the type is... FilePath and IO () doesn't communicate too much
00:16:52 <EvanR> oh man i forgot to inb4 somebody said something about types-only docs
00:17:10 <tdammers> maerwald: no, but those are lousy APIs, we just can't seem to come up with anything better in practice
00:17:11 <EvanR> i figured no one would do it
00:17:48 <EvanR> IO functions and actions should really have blurbs about what they do
00:17:56 <tdammers> EvanR: my stance is that "self-documenting code" is the ideal situation, but you can rarely get there in practice
00:18:22 <maerwald> anything sufficiently low-level needs tons of documentation
00:18:29 <EvanR> self documenting code hopefully isn't what you are looking at the manual
00:18:39 <EvanR> in the manual (haddock)
00:18:57 <EvanR> in the source code maybe
00:19:09 <tdammers> what do you mean?
00:19:14 <tdammers> why not in the haddock?
00:19:22 <ariakenom> the other day I started commenting with "forever upda ..." then I realised I could just use "forever" in the code instead. I was pleased
00:19:31 <EvanR> consider a haddock with 3 pages of IO actions
00:19:59 <EvanR> you have the names, but nothing else. I don't think the code should be there instead
00:20:07 <tdammers> you have the names, the types, and the ordering
00:20:20 <EvanR> the ordering...
00:20:22 <tdammers> and if the programmer did their job, you also have some kind of module structure
00:20:23 <EvanR> of arguments?
00:20:30 <tdammers> of identifiers in the haddock
00:20:46 <tdammers> haddock lists them in the order they are exported
00:20:53 <EvanR> APIs like this usually have something along the lines of man pages for each one 
00:21:08 <tdammers> but you're in chicken-and-egg mode here
00:21:28 <tdammers> of course if all your functions are :: String -> IO String, then you have failed to write self-documenting code
00:21:37 * EvanR headscratch
00:21:47 <EvanR> no one is looking at *code* on a page full of type signatures
00:21:54 <EvanR> do you mean self documenting type signatures
00:22:18 <tdammers> but if you have a function httpGet :: URL -> HttpContext HttpResponse -- then what else can you say about this?
00:22:40 <ariakenom> exceptions
00:22:41 <EvanR> my imagination on this one is running while
00:22:48 <EvanR> wild
00:23:05 <EvanR> httpGet is not exactly uniquely defined here
00:23:06 <tdammers> ariakenom: ah yes, true. that one I might actually document, either here, or on the HttpContext monad
00:23:26 <ariakenom> possibly things like timeout lengths
00:23:37 <EvanR> strictness laziness
00:23:40 <tdammers> timeouts, I suppose those would be configured through the context
00:23:53 <EvanR> all the ways it depends on context
00:23:59 <tdammers> yes
00:24:21 <tdammers> but the point is that compared to String -> IO String, this new type signature adds a massive amount of information
00:24:30 <tdammers> enough to allow you to figure out how to use it
00:25:26 <EvanR> by contrast if httpGet had an extensive advanced type, i guess it may need absolutely zero further description? :)
00:25:29 <tdammers> the stuff that isn't documented, you can, just to get you started, assume the worst, or assume reasonable defaults (e.g., wrt strictness, you could assume that it's lazy, wrt exceptions, assume that it can throw all sorts of things, etc.)
00:25:41 <tdammers> possibly, yes
00:25:55 <tdammers> although I don't see how you would do type-level timeouts in practice
00:25:58 <EvanR> i'm gonna have to side with maerwald 
00:26:43 <tdammers> oh, I agree in principle - the lower-level you go, the more generic your types will be, and the less you can capture in the types
00:26:56 <tdammers> that's kind of the definition of "low-level" - not having a lot of abstractions in place
00:27:17 <EvanR> http is not example a "high level abstraction in place"
00:27:20 <EvanR> not exactly
00:27:49 <tdammers> it is an abstraction over "pumping byte streams over sockets"
00:28:30 <tdammers> so you can write types that know more about those byte streams and sockets than that they are byte streams and sockets
00:28:49 <tdammers> and those types also restrict what you can use those byte streams and sockets for
00:29:21 <EvanR> in the move from pumping bytes into a buffer i think we increased the need for docs exponentially
00:29:33 <tdammers> yes
00:29:39 <tdammers> the abstraction itself needs tons of documentation
00:29:45 <dminuoso> jusss: I think a lot of the python world is not well documented, you just have random examples you can copy and paste, such that you dont have to understand how the library works.
00:29:52 <EvanR> may we missed the possibility whoever reads this is not a web programming junkie who knows everything about http
00:29:57 <dminuoso> jusss: So its a red hering
00:30:18 <dminuoso> jusss: The Python ecosystem is, in fact, one of the worst documented ones around.
00:30:21 <tdammers> EvanR: that's a more fundamental problem though; how much of the problem domain do you feel responsible to explain?
00:30:37 <tdammers> EvanR: fortunately, HTTP itself is thoroughly documented, there's a standard and all
00:30:50 <EvanR> right
00:31:05 <EvanR> i sometimes felt my mikmod docs were pointless
00:31:09 <EvanR> "just look at the C docs"
00:31:31 <EvanR> but then i think i'd be part of this gripe again haskell docs
00:31:41 <tdammers> I think it's useful to summarize crucial parts of the problem domain as part of your documentation
00:31:59 <EvanR> so trifeca is a parser lib
00:32:11 <EvanR> i'm pretty sure everything you need to know about trifeca is written somewhere
00:32:13 <EvanR> just not in the docs
00:32:19 <dminuoso> Haskell question. Im in the Put monad and I need a source of entropy. What do?
00:32:36 <EvanR> so it needs no docs?
00:32:36 <ammar2> "such that you dont have to understand how the library works." if your objective is to do the most common thing, getting a deep understanding of how the library works is completely unnecessary
00:32:45 <ammar2> and the "random examples" get you on your way much faster
00:32:57 <tdammers> trifecta is written by a prodigy, for prodigies ;)
00:33:07 <EvanR> :(
00:33:23 <dminuoso> ammar2: That's short sighted. Its a result of "I just want to solve the problem with the least effort"
00:33:35 <ammar2> you say short sighted, I say pragmatic
00:33:47 <tdammers> ammar2: haskell culture abhors using things without understanding them; many of us come from years of doing that and falling on our faces time and again
00:33:50 <dminuoso> Pragmatism is a synonym for unprincipled and brittle.
00:34:17 <EvanR> ammar2 has a point
00:34:22 <tdammers> personally, I think that if you have solved a problem without understanding it, you haven't actually solved it (or you can't tell whether you have solved it, which is even worse)
00:34:24 <EvanR> i'm sorry to say
00:34:30 <ammar2> I mean take the example of the guy who was in here before asking about a telegram library
00:34:36 <dminuoso> You cannot even begin to judge the quality of your code if you have absolutely no idea what its doing.
00:34:44 <dminuoso> Or correctness.
00:34:47 <ammar2> you think he wanted a deep understanding of how to connect over the telegram api and use sockets and all that minutia?
00:34:52 <dminuoso> If you cant say "this code is decent or even correct", why bother shipping it?
00:34:53 <ammar2> he just wanted to make something cool
00:35:04 <ammar2> and the lack of simple documentation gets in the way
00:35:05 <tdammers> that said, it's OK to use an abstraction with well-defined semantics without understanding how it's done under the hood, as long as you understand the exposed semantics
00:35:08 <dminuoso> ammar2: Then I'd say his goal is outside his horizon.
00:35:16 <dminuoso> tdammers: Indeed.
00:35:49 <EvanR> welcome to haskell hardliners
00:36:01 <tdammers> so for a Telegram API, I would expect something like a Telegram monad, a function that gets you "into" that monad from IO, and that function would probably take a bunch of configuration; and then a function in the Telegram monad to read and write messages
00:36:35 <tdammers> you can write such an API in a way that requires minimal documentation, is easy to understand, and doesn't require the user to know how it works behind the scenes
00:36:43 <EvanR> i like fully understanding things and am frustrated when i don't. But people around me are even more frustrated when i demand they feel the same
00:37:19 <tdammers> and when you do, examples might be helpful to confirm suspicions as to how you'd use it, but with a well-written API, a semi-experienced haskeller should have absolutely no trouble figuring out how to use it
00:37:19 <EvanR> it's not ecological
00:37:56 <tdammers> insisting on basing decisions on your experience doesn't make you popular in general
00:38:59 <EvanR> i've tried dragging people kicking and screaming into "the straight path".
00:39:38 <EvanR> net loss
00:41:21 <dminuoso> Python is full of examples but no documentation or clear semantics. That makes it fast to copy and paste, get some results - you just cant be sure what those results really are, what they mean, and how they vary in different scenarios.
00:42:12 <dminuoso> The Haskell ecosystem generally lacks examples and verbose documentation, but we have a strong type system so we more than make up for the lack of every haddock filled with explicit "copy and paste to do XYZ" examples.
00:42:56 <EvanR> my incredibly unpopular packages have code ready to copy and paste :)
00:43:22 <ammar2> what is the most popular haskell http library?
00:43:31 <dminuoso> ammar2: http library in what sense?
00:43:40 <ammar2> sorry, http client
00:43:52 <ammar2> make requests, fetch web pages, hit up json apis etc
00:44:04 <dminuoso> ammar2: servant-client is fairly nice, there's also http-client, HTTP, wreq, req..
00:44:21 <tdammers> I wouldn't base my decision on popularity alone
00:44:33 <dminuoso> ^- this.
00:44:44 <dminuoso> Ive found some really great gems that are surprisingly unpopular.
00:44:45 <EvanR> wreq comes up in here a lot
00:44:45 <ammar2> alright, what is the most elegant one in your opinion?
00:45:01 <dminuoso> ammar2: depends on the exact problem domain
00:45:12 <dminuoso> And what kind of ergonomics you want
00:45:15 <tdammers> exactly
00:45:17 <ammar2> let's say, interacting with a REST api
00:45:24 <ammar2> just talking json over http basically
00:45:27 <dminuoso> ammar2: servant-client is generally a great solution if you have a non-trivial API.
00:46:29 <dminuoso> ammar2: http-client is perfectly fine too
00:46:49 <tdammers> servant-client is great, but comes with a significant initial learning overhead
00:47:14 <tdammers> making it as flexible as you want in order to consume moving third-party targets is a bit of a challenge
00:47:29 <tdammers> (and the type safety it offers may not even be worth it in such a situation)
00:47:41 <tdammers> IMO, servant is most suitable when you control both ends
00:47:50 <dminuoso> I think servant gets most of its benefits when you also provide the API from Haskell (such that you can make a servant-server and share the API in a library)
00:47:53 <dminuoso> Indeed!
00:48:09 <dminuoso> Though I have servant-only servers and clients here.
00:48:27 <dminuoso> http-client should not be understated though :)
00:48:44 <tdammers> absolutely
00:48:57 <tdammers> if you just want to talk to some third-party API for a simple task, servant is overkill
00:49:24 <dminuoso> and equivalently, http-client can work for large and complex APIs too (phadej's github package)
00:49:28 <Rembane> But very fun! 
00:49:58 <phadej> github package has a fancy own framework
00:50:06 <phadej> http-client is only an executor (in a single module)
00:50:06 <tdammers> it's also a bit of an architectural question - at what point in the chain do you draw the boundary between "loosely-typed, basically just JSON with some operationally defined constraints" and "strongly-typed, declaratively constrained data structures"
00:50:30 <phadej> (ok, maybe not fancy, as nothing really happens on the type-level)
00:51:20 <dminuoso> phadej: I like your package nevertheless. It's a shame I dont have any need for it. :(
00:51:43 <dminuoso> (Or I suppose its not even yours originally)
00:52:21 <phadej> nope
00:53:34 <phadej> Copyright 2012-2013 Mike Burns, Copyright 2013-2015 John Wiegley, Copyright 2016-2019 Oleg Grenrus
00:55:29 <jusss> another silly issue, is that all the instances of typeclass Show, which means that instances have a method `print' ?
00:56:12 <EvanR> you can get info on typeclass Show in ghci
00:56:14 <EvanR> :i Show
00:57:22 <jusss> I didn't see `print', but `show'
00:57:39 <EvanR> print is a library routine that uses show
00:57:44 <phadej> @src print
00:57:45 <lambdabot> print x = putStrLn (show x)
00:58:34 <jusss> EvanR: I don't get it, show won't put something on the screen?
00:58:51 <EvanR> show is just a function
00:59:00 <EvanR> no side effects
00:59:01 <jusss> putStrLn is an action, will put something on screen, so print x will output something on screen
00:59:17 <EvanR> oh, it sounds like you get it
00:59:17 <jusss> EvanR: so you mean show won't put something on screen?
00:59:28 <EvanR> correct
00:59:33 <ammar2> :t show
00:59:34 <lambdabot> Show a => a -> String
00:59:49 <jusss> ok
01:00:47 <Sam2> i get so many useful tips from just watching this IRC. Thanks.
01:02:51 <jusss> :t print
01:02:53 <lambdabot> Show a => a -> IO ()
01:03:13 <tdammers> useful habit when reading Haskell: trust the types of things more than the names.
01:03:47 <tdammers> "show" suggests that it somehow shows something, but Show a => a -> String says it actually can't
01:04:06 <jusss> I'm changing the code that I pasted today earlier, and it works now
01:04:35 <jusss> the first telegram-api robot project, the last one is too fancy to me, I can't understand
01:07:00 <jusss> EvanR: I know the reason the I asked the question about UpdatesResponse, that getUpdate will return an IO (Either _ _), but I use resultEither <- return $ getUpdate ..., so it's still a IO (Either ..), I should remove that `return $'...
01:07:20 <EvanR> that had to have been like 18 hours ago
01:07:24 <EvanR> i should be asleep
01:07:51 <EvanR> and yeah somebody told you that 18 hours ago
01:07:56 <jusss> EvanR: no, it's been 7 hours agon
01:08:57 <jusss> sorry, I have reading disorder...
01:19:56 <jusss> there's a "Update {update_id = 79107285, message = Just (Message {message_id = 24, from..."  how I can get the message from it in the do-notation?
01:21:28 <jusss> https://paste.ubuntu.com/p/6RRxtPFrn3/
01:21:59 <jusss> head m has the value "Update { update _id ... "
01:22:52 <jusss> I miss the dict in other languages...
01:28:20 <EvanR> jusss: you can a pattern match to get it, or you can use lenses
01:29:34 <EvanR> if you're doing a case...
01:30:10 <EvanR>   Update {message = Just msg} -> ..msg..
01:30:37 <EvanR>   _ -> message was Nothing
01:32:07 <EvanR> there are other ways to deal with the Maybe, what's good depends on circumstances
01:39:04 <tdammers> "miss the dict"?
01:39:23 <tdammers> you can have "dictionaries" (a.k.a. hashmaps) just fine in Haskell
01:39:51 <tdammers> we just don't abuse them to model things that we know a bit more about than "it's a name-indexed bag of arbitrary things"
01:40:33 <jusss> tdammers: what's the right way for those nested stuff?
01:46:42 <maerwald> tdammers: but we abuse lists ;)
01:48:30 <sarna> jusss: you just make a custom type, most of the time
01:54:33 <ariakenom> anyone have usd chris' "jl"? although I think the issue is elsewhere. I am searching through some json. whcih works fine except it prints "not enough input" at the end
01:55:33 <jusss> sarna: https://github.com/fizruk/telegram-bot-simple/blob/master/src/Telegram/Bot/API/Types.hs     this data Message has about 30+ message, how I can only get one of them? 
01:56:01 <jusss> use `case' to match it seems not good, I need to create 30 identifier to match it
01:56:21 <jusss> I mean Message a1 a2 a3 a4 a5 ... a30
01:56:43 <jusss> but I only want a3 or a9 from it
01:58:39 <jusss> if I use the accessor to do that like `a1 Message' but ghc will not resolv a1
01:59:05 <jusss> how I can import that function or accessor a1 to let ghc know?
02:00:01 <lortabac> jusss: accessors are (almost) regular functions
02:00:02 <jusss> EvanR: do you know how to import accessor so let ghc know it's an accessor
02:00:22 <jusss> lortabac: but ghc won't resolv it 'cause of it from other files
02:00:31 <lortabac> if you want to import all of them you do 'import Message(..)'
02:00:57 <jusss> lortabac: ok
02:01:06 <lortabac> jusss: what do you mean by "won't resolve it"?
02:04:14 <jusss> lortabac: Update {message = Just msg} -> ..msg..  if this is not defined in current Main.hs, ghc won't resolv message, if I use `message Update'
02:05:58 <yushyin> Telegram.Bot.API seems to reexport most of the stuff you'll need
02:11:05 <yushyin> the workshop example even uses some of the accessors
02:11:38 <lortabac> jusss: the argument of an accessor function is not the constructor, but the value
02:12:11 <lortabac> 'message Update' will not work
02:12:35 <ghibe> Hi, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-flag--M%20⟨size⟩ explains that `-M` can be used to limit the memory used. In https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-options-environment there's even a TIP explaining that it can be used to prevent the
02:12:36 <ghibe> machine from killing the process.I added ghc-options: '-Wall -with-rtsopts="-T -M150m"'  ghc-options: '-Wall -with-rtsopts="-T -M150m"' 
02:12:46 <ghibe> but it still grew in memory above the limit
02:18:06 <jusss> lortabac: sorry, the value is too long, so let assume x :: Update { ...}, does `message x' will work？
02:18:34 <jusss> yushyin: can you point the link?
02:19:32 <yushyin> https://github.com/fizruk/lambdaconf-2018-workshop
02:19:39 <lortabac> jusss: yes
02:20:01 <lortabac> jusss: assuming 'message' is an accessor of 'Update'
02:21:07 <yushyin> jusss: https://github.com/fizruk/telegram-bot-simple/blob/master/src/Telegram/Bot/API.hs as you can see it reexports all the stuff from .Types and much more.
02:21:29 <yushyin> jusss: the example uses a qualified import like so https://github.com/fizruk/lambdaconf-2018-workshop/blob/master/app/stages/stage_8.hs#L18
02:21:44 * hackage th-tc 0.1.1.0 - Typechecking in Template Haskell  https://hackage.haskell.org/package/th-tc-0.1.1.0 (mniip)
02:22:12 <jusss> yushyin: oh, sorry, I sent the wrong github project...
02:22:44 <yushyin> all my research for nothing!
02:22:46 <yushyin> :P
02:25:34 <jusss> yushyin: truly sorry
02:26:36 <jusss> yushyin: I did try to learn this project a few hours, and I found out his code is too fancy to me, :)
02:27:06 <jusss> so I go back to the old one, that's not so fancy one
02:28:12 <jusss> but the case is common
02:29:09 <jusss> if there's data T = T a1 a2 a3 .. a30, x :: T, how we can get a3 from x? use case to do that we need create 30 identifiers,
02:29:43 <jusss> via accessor is easy, just `a3 x' will do it
02:30:25 <jusss> but if this data T is not defined in current Main.hs, ghc won't resolv a3
02:31:21 <lortabac> jusss: can you share the error message you are having?
02:31:36 <yushyin> also the source code
02:31:39 <absence> i've imported a module that uses DuplicateRecordFields, and as expected i get errors about ambiguous occurences if i try to use a selector function defined for more than one record. a web search suggests it should be possible to do "fieldName @RecordName" to disambiguate, but i still get errors. the more verbose (fieldName :: RecordName -> FieldType) does work however. what am i missing?
02:32:14 <__monty__> absence: Probably the type applications extension?
02:32:23 <lortabac> absence: you can use 'getField' from GHC.Record
02:32:42 <lortabac> getField @fieldName
02:34:09 <absence> __monty__: if i did, i would get an error about that, rather than about ambiguous occurences :)
02:34:36 <absence> lortabac: interesting, i'll look into it
02:34:55 <absence> still, why doesn't type applications work? are the people suggesting it online mistaken?
02:35:48 <yushyin> jusss: you are using this project right? http://hackage.haskell.org/package/telegram-api 
02:37:21 <jusss> yushyin: yeah, but this an old version, I'm using on that from github
02:37:33 <jusss> getUpdates   :: Token    -> Maybe Int -- ^ offset    -> Maybe Int -- ^ limit    -> Maybe Int -- ^ timeout    -> Manager-> IO (Either ClientError UpdatesResponse)
02:37:41 <yushyin> as far as i can see it exports the accessors just fine. We will need to see your code and error
02:39:02 <jusss> type UpdatesResponse = Response [Update]
02:40:40 <__monty__> absence: Maybe it's @(RecordName -> FieldType)? Where are you reading just RecordName's fine?
02:40:43 <jusss> I can't find the data Update where it's defined
02:41:24 <jusss> yushyin: do you know where the data Updata is defined?
02:42:57 <jusss> yeah, I foud it
02:43:11 <jusss> https://github.com/klappvisor/haskell-telegram-api/blob/master/src/Web/Telegram/API/Bot/Data.hs
02:45:55 <jusss> lortabac: yushyin: https://paste.ubuntu.com/p/M9rGVWvHvZ/
02:53:33 <lortabac> jusss: what is the type of the 'result' field of 'Response'?
02:55:10 <jusss> this is where data Message defined https://github.com/klappvisor/haskell-telegram-api/blob/master/src/Web/Telegram/API/Bot/Data.hs
02:56:01 <jusss> and this code works now https://paste.ubuntu.com/p/WwXxnqfVhJ/
02:56:47 <jusss> also data Update defined in that link too
02:57:18 <jusss> lortabac: Response [Update]
02:57:29 <lortabac> jusss: maybe there is a function called 'message' in scope?
02:58:03 <lortabac> jusss: "let message = pack $ head l"
02:58:12 <lortabac> you should rename that variable :)
02:58:26 <jusss> lortabac: aha
03:00:06 <jusss> lortabac: if I `import Web.Telegram.API.Bot.Data' can I use data Update and Message in current Main.hs? Update and Message are defined in that 
03:00:31 <jusss> lortabac: also that accessor for Update , I can use them?
03:00:36 <yushyin> you can already do that without that import
03:00:52 <jusss> haskell's module stuff are really ...
03:01:26 <yushyin> because Web.Telegram.API.Bot reexports Web.Telegram.API.Bot.Data
03:01:36 <jusss> ok
03:02:18 <jusss> time to go, bye
03:02:22 <yushyin> jusss: it might be for the better import it qualified as Telegram
03:35:19 <k0ral> is this the right place to ask questions about cabal-install ?
03:41:39 <yushyin> yes
03:48:20 <k0ral> using cabal-install 3+, v2-commands are now the default; but it seems that --enable-nix has never worked with v2-commands; am I right ?
04:09:49 <nil> any ideas how i might implement automatic semicolon insertion at the end of lines after certain tokens, using parser combinators? i was thinking of using state (such as provided by Parsec) to remember whether the last token was a "final" token, and if so, when parsing a semicolon, accept a newline as well
04:10:11 <nil> could this be done without state?
04:11:01 <nil> i'm basically trying to "insert" a semicolon in the token stream under certain conditions, but i'm not sure how to translate that with parser combinators
04:13:14 * hackage validators 0.0.1 - Composable validations for your Haskell data types  https://hackage.haskell.org/package/validators-0.0.1 (luc_tielen)
04:26:32 <bolver> i have some code pasted here -- https://www.paste.org/100945
04:27:16 <bolver> foldrTest function in that code runs a lot slower than concatTest function
04:27:22 <bolver> i am wondering why
04:27:44 * hackage Monadoro 0.2.1.9 - A minimalistic CLI Pomodoro timer.  https://hackage.haskell.org/package/Monadoro-0.2.1.9 (patryk_kocielnik)
04:28:59 <bolver> appreciate any help
04:30:09 <dminuoso> bolver: concatMap uses build (which builds up a list using Church lists internally), foldrTest will build up a large chain of (++) 
04:30:09 <bolver> in fact, the concatTest outputs immediately whereas the foldrTest doesn't
04:30:23 <dminuoso> bolver: You could partially address it by using shows instead of show.
04:30:28 <dminuoso> (in your foldrTest)
04:30:28 <bolver> dminuoso: i see
04:31:38 <bolver> dminuoso: i used difference list in foldrTest -- isn't that same as shows?
04:31:48 <eze> I am not able to upgrade cabal-install to 3.0. However, Cabal is in 3.0 version.... any pointers?
04:32:14 <eze> I tried cabal update already
04:32:24 <MarcelineVQ> bolver: You didn't though, the base case of a difference list isn't "", you're applying those functions not composing a chain of them them
04:32:27 <eze> cabal install Cabal shows me that I am at 3.0
04:32:49 <eze> after cabal install cabal-install and cabal -V I see an old version of cabal-install
04:32:51 <MarcelineVQ> iow  "(show x ++ ) . (", " ++ ) $ acc" is a list, not a function of lists
04:33:09 <bolver> MarcelineVQ: i see -- so how should i do what you suggested?
04:33:17 <dminuoso> bolver: Use shows.
04:33:47 <bolver> dminuoso: i see
04:33:56 <MarcelineVQ> conceptually  "(show x ++ ) . (", " ++ ) . acc)" (const "") or something similar, I'm not sure exactly right this moment, but the idea is to compose, not apply
04:35:12 <MarcelineVQ> might be id instead of const "", can't recall just now without writing it
04:35:31 <dminuoso> bolver: What you are building up is building a large chain of `.. show 0 ++) ++ show 1) ++ show 2) ++ show 3) ...`
04:35:32 <bolver> MarcelineVQ: and then you apply at the very end? after foldr returns?
04:36:08 <dminuoso> bolver: You'd just say `shows x . ...`
04:36:40 <MarcelineVQ> bolver: foldr would consturct a function that you'd then apply to ""  down where you wrote print $ take 10 $ foldrTest xs.
04:37:25 <bolver> dminuoso: alright, but i am not very clear though
04:38:18 <bolver> MarcelineVQ: i see
04:40:03 <dminuoso> % foldr shows "" [1,2,3,4,5] -- bolver 
04:40:03 <yahb> dminuoso: "12345"
04:40:38 <bolver> dminuoso: so in foldr, you keep composing functions, and after foldr returns, you apply it using shows
04:40:53 <dminuoso> bolver: No.
04:41:01 <bolver> dminuoso: got it
04:41:06 <dminuoso> bolver: It might be helpful to think of foldr replacing : and [] in a list.
04:41:34 <dminuoso> https://wiki.haskell.org/wikiupload/3/3e/Right-fold-transformation.png
04:41:41 <dminuoso> That `f` can be any function you like.
04:41:56 <dminuoso> You can use foldr to construct function compositions if you like, but not in the case above.
04:42:18 <dminuoso> 13:40:44        dminuoso | bolver: It might be helpful to think of foldr replacing : and [] in a list.
04:42:23 <dminuoso> But that's the core idea. :)
04:42:37 <bolver> dminuoso: correct, so shows is that function i should use here in foldr
04:42:46 <dminuoso> Well in my example:
04:42:50 <dminuoso>  % foldr shows "" [1,2,3,4,5] -- bolver
04:42:57 <dminuoso> If we use the explicit cons notation:
04:43:08 <dminuoso>  % foldr shows "" (1:2:3:4:5:[])
04:43:11 <dminuoso> Turns into
04:43:35 <bolver> dminuoso: got it, but even with that, concaMap would be quicker, is uppose?
04:43:49 <bolver> concatMap, i men
04:43:54 <bolver> i mean
04:43:54 <dminuoso> % 1 `shows` (2 `shows` (3 `shows` (4 `shows` (5 `shows` ""))))
04:43:54 <yahb> dminuoso: "12345"
04:44:46 <bolver> dminuoso: i see
04:44:48 <dminuoso> bolver: I dont know honestly.
04:45:52 <bolver> dminuoso: thanks, i will check it out after making the changes
04:46:21 <bolver> but with the code as it is, concatMap runs very quickly -- instantly, in fact
04:46:21 <dminuoso> I'd expect them to have similar runtime characteristics.
04:47:37 <bolver> while the foldr stuff, in that code, is damn slow -- perhaps, with shows they may show similiar speed -- i will need to check it out
04:47:44 * hackage Monadoro 0.2.1.10 - A minimalistic CLI Pomodoro timer.  https://hackage.haskell.org/package/Monadoro-0.2.1.10 (patryk_kocielnik)
04:48:02 <dminuoso> bolver: Its not the foldr thats slow. Its the building up of `.. show 0 ++) ++ show 1) ++ show 2) ++ show 3) ...`
04:48:21 <dminuoso> bolver: ++ essentially has to go through the entire left list.. do I need to say more? :)
04:48:37 <dminuoso> (It has linear cost in the length of its left-hand side list)
04:48:54 <bolver> dminuoso: correct, but the same build up using ++ is there in concatTest as well, but it is real quick
04:48:59 <dminuoso> bolver: No its not.
04:49:27 <dminuoso> bolver: You just have many small `show 1 ++ ","` bits 
04:49:32 <dminuoso> Remember that concatMap doesnt actually itself use ++
04:49:41 <dminuoso> It uses build + foldr internally 
04:49:42 <bolver> dminuoso: i see -- you mentioned it uses build to construct church list -- i didn't know that
04:49:46 <dminuoso> Right.
04:50:00 <dminuoso> Or rather, build is the function that turns a church list into a [a] type of list
04:50:14 <dminuoso> So concatMap builds a church list which is then efficiently turned into a regular list.
04:50:24 <bolver> dminuoso: i see
04:50:48 <dminuoso> concatMap f xs = build (\c n -> foldr (\x b -> foldr c b (f x)) n xs)
04:50:54 <bolver> dminuoso: that's what i missed -- thanks
04:51:36 <dminuoso> And `build g = g (:) []` of course
04:52:02 <bolver> dminuoso: i see
04:52:12 <dminuoso> bolver: But try using foldr with just shows internally and tell me about the results. Id expect them both to behave similarly.
04:52:56 <bolver> dminuoso: 1 question -- this `show 1 ++ ","` bits in concatTest isn't a big deal, as you say, is it?
04:53:06 <dminuoso> bolver: (And there's apparently a lot of subtleties of the simplifier, so that above definition of build is not helpful)
04:53:32 <dminuoso> bolver: Right. Its more than likely that the optimizer will completely inline everything.
04:53:56 <dminuoso> Or well.. it cant because of the show.
04:56:43 <bolver> dminuoso: thanks much ... i will test it ... just a side note ... i first wrote the foldr code, and then i had a hunch whether it is problematic, profiles it and saw it was true, and then used concatMap and saw it was quick.  so all very coincidental!
04:59:51 <bolver> MarcelineVQ: thanks much for your help
05:05:14 * hackage haskoin-core 0.9.4 - Bitcoin & Bitcoin Cash library for Haskell  https://hackage.haskell.org/package/haskoin-core-0.9.4 (xenog)
05:07:55 <absence> sometimes when putting values in a map, the key is extracted from the value, e.g. M.insert (getId val) val. ideally i guess one should make a new type that contains everything except the key, and insert that instead, but is there a key-value-like data structure that gets around this by using a function/view for the key instead?
05:12:44 * hackage tasty-tmux 0.1.0.1 - Terminal user acceptance testing (UAT) via tmux  https://hackage.haskell.org/package/tasty-tmux-0.1.0.1 (frasertweedale)
05:13:44 * hackage Monadoro 0.2.1.11 - A minimalistic CLI Pomodoro timer.  https://hackage.haskell.org/package/Monadoro-0.2.1.11 (patryk_kocielnik)
05:14:02 <lyxia> absence: a Set on a newtype around your structure
05:15:02 <lyxia> that makes lookups tricky though if you don't have a value with the key you're looking for
05:15:28 <mpickering> Does anyone know how "short" a ShortByteString should be?
05:18:47 <mniip> mpickering, I'm guessing less than 32/64 bytes
05:19:00 <mniip> as that's the approximate size of a heap object
05:19:11 <mniip> and ShortByteString is an unpinned bytearray
05:19:37 <mniip> (it will have to be moved around)
05:21:44 * hackage haskoin-core 0.9.5 - Bitcoin & Bitcoin Cash library for Haskell  https://hackage.haskell.org/package/haskoin-core-0.9.5 (xenog)
05:22:57 <absence> lyxia: yes, that's the problem
05:23:03 <mpickering> Not sure that reasoning follows mniip 
05:23:19 <absence> lyxia: lookup by key is necessary
05:24:21 <mpickering> Isn't the point that the time spent copying will be greater if you have a long ShortByteString?
05:24:31 <mniip> yes
05:24:46 <mniip> well there is always going to be copying overhead
05:24:48 <mpickering> anyway, seeing `Text` is unpinned
05:24:59 <mpickering> I would have expected "small" to be < 1mb or something like that
05:25:04 <mniip> ah
05:25:08 <mpickering> ie anything human writeable is small
05:25:20 <mpickering> but there's no logic to that other than knowing `Text` is unpinned
05:27:45 <mniip> hmm, 1MB of latex is roughly 1000 pages
05:28:26 <MarcelineVQ> mpickering: dcoutts might have an idea about what short suggests
05:28:57 <mpickering> I felt like it was deliberately left ambiguous in the docs because no one had done any measurements..
05:29:17 <mniip> how do you measure something like this
05:29:44 <mniip> you have the apples - memory fragmentation, and the oranges - copying overhead
05:34:08 <mpickering> there might as well be no guidance at the moment as understanding what "short" means is impossible
05:34:48 <mpickering> so any quanitifiable guidance would be useful
05:35:04 <mpickering> such as "If you do X then Y will happen"
05:35:30 <mpickering> We want to use unpinned memory to use compact regions anyway so there isn't much choice
05:53:17 <jusss> how to import data Text ? Data.Tex
05:53:34 <jusss> import Data.Text, I still can't use Text in current env
05:55:39 <lortabac> jusss: this module is usually imported qualified, because it contains names that clash with the ones in Prelude
05:55:50 <lortabac> import qualified Data.Text as Text
05:57:08 <MarcelineVQ> you need to make the text package available to your current env
05:57:24 <mceier> or use "Data.Text." instead of "Text."
05:59:05 <MarcelineVQ> without seeing what you tried it's hard to say what else to try, how do you know you can't use Text?
05:59:49 <jusss> lortabac: https://paste.ubuntu.com/p/9vTmPNVYRy/
06:00:27 <MarcelineVQ> import Data.Text (pack) only imports pack, if you want Text you probably need to   import Data.Text (pack, Text(..))
06:00:42 <jusss> " , text                    :: Maybe Text -- ^ For text messages, the actual UTF-8 text of the message"  from https://github.com/klappvisor/haskell-telegram-api/blob/master/src/Web/Telegram/API/Bot/Data.hs
06:00:48 <MarcelineVQ> I see the error says that as well "Perhaps you want to add `Text' to the import list in the import of `Data.Text' (Main.hs:11:1-23)."
06:01:06 <jusss> MarcelineVQ: ok, I'll try
06:02:47 <deni> I'm having a rather silly problem to solve.... I wanna transform a list [1..n] :: Int into a "shrinked" list of [String] where I only show the first element, last element, and the selected element (current index) with 3 values to the left and 3 values to the right of it. Think pagination list where I wanna show something like "*1*,2,3,4...33" or "1...4,5,6,*7*,8,9,10...30" as to not show the full
06:02:48 <deni> list which would be too long. 
06:03:13 <absence> is anyone familiar with docker in stack? i'm doing "stack run | less", but less doesn't handle the keyboard properly. i'm guessing something something docker interactive shell, but i have no idea
06:03:58 <deni> looking at Data.Traversable but having trouble wrapping my head around it.... I can always do an imperative solution (of sorts) with for...but was thinking about using something more functional with mapWith or something
06:04:14 <jusss> if there's a do-notation, result :: [Maybe Text], do -> fmap print result , why this wrong?
06:05:25 <jusss> the do is in IO context
06:05:29 <absence> deni: i don't think Traversable lets you shrink the list
06:05:39 <jusss> but the result is [] monad
06:05:54 <absence> juss, try "traverse print result"
06:06:40 <deni> absence: I'm looking at Foldable as well but like I said, it's bending my mind a bit at the moment (short on coffee :D)
06:07:19 <deni> I know I'm giving this way too much thought instead of doing the dirty simple solution... but it got me curious what can I say 
06:07:30 <absence> jusss: the type of fmap print result is [IO ()], and you need "IO something"
06:07:30 <jusss> https://paste.ubuntu.com/p/t9cWb3Qxsd/
06:08:06 <jusss> absence: how I turn [IO ()] to IO ()
06:08:23 <absence> :t sequenceA
06:08:25 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
06:08:44 <absence> it gets you IO [()]
06:09:05 <jusss> the context in do-notation is IO, but there's a [] ...
06:09:46 <absence> :t sequenceA_
06:09:47 <lambdabot> (Foldable t, Applicative f) => t (f a) -> f ()
06:10:28 <absence> so you could write "sequenceA_ (fmap print result)", which is the same as "traverse_ print result"
06:11:59 <absence> deni: Traversable and Foldable are quite generic and don't care much about the contents. you probably have to be more explicit about it
06:12:26 <deni> absence: yeah you're right
06:12:37 <jusss> absence: there's no such sequenceA_...
06:12:37 <absence> deni: or well, you could do it with a fold
06:12:44 <jusss> only sequencdA in Prelude
06:12:45 <absence> jusss: it's in Data.Foldable
06:13:48 <absence> deni: but i'm not sure it's the clearest way to do it :)
06:14:09 <MarcelineVQ> it's fine to use sequence_ since the things you're using are Monad anyway
06:14:12 <jusss> absence: it works! thanks
06:14:28 <deni> absence: yeah I'm not sure what the clearest way would be either.... 
06:14:31 <jusss> but new question, how I can to use monad in a monad?
06:15:02 <jusss> like this case, do came with IO context, but there's List Monad also Maybe Monad, which I'd like to use, how I can do that?
06:15:26 <jusss> use othe monads in a monad
06:21:31 <MarcelineVQ> deni: a zipper for the middle part would be a neat exercise, data Zipper a = Zip [a] a [a]       a zipper of  [1,2,3,4,5]  with the focus at 4 is  Zip [2,1] 3 [4,5]  if you want to move the focus right it becomes Zip [3,2,1] 4 [5]  or left becomes Zip [1] 2 [3,4,5]  converting Zip to the form you need is reasonably straightforward
06:21:48 <MarcelineVQ> *with the focus at 3 is
06:22:18 <MarcelineVQ> There's packages for this if you don't want to write it yourself
06:22:43 <evelyn> jusss: I'm not sure if I understand what you're asking right, but if you for instance wanted to return values in the Maybe monad that are produced by IO actions, you'd e.g. need to have the type  of the function you're doing this in be IO (Maybe a) and so on.
06:22:50 <MarcelineVQ> in particular this is a list zipper, there's a few kinds out there, mostly trees which lists are a degenerate form of
06:24:50 <absence> jusss: maybe monad transformers are what you want
06:25:04 <absence> jusss: check out the transformers and mtl packages
06:26:11 <jusss> evelyn: yes
06:31:06 <jusss> absence: fmap print result :: [IO ()],  if I use `return (fmap print result)' would it be IO [IO ()] ? in that do notation
06:35:44 * hackage haskoin-store 0.18.5 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.18.5 (xenog)
06:36:22 <lyxia> :t \result -> return (fmap print result)
06:36:24 <lambdabot> (Monad m, Show a, Functor f) => f a -> m (f (IO ()))
06:37:44 * hackage haskoin-store 0.18.6 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.18.6 (xenog)
06:37:51 <jusss> Control.Monad.Trans.List  Deprecated: This transformer is invalid on most monads
06:40:11 <ski> shapr : oh, i hadn't noticed they were absent ..
06:45:56 <jusss> how to make a loop within `main ' ?
06:46:22 <ski> what kind of loop ?
06:46:26 <deni> MarcelineVQ: interesting.... I'll take a look 
06:48:08 <ski> you can use explicit recursion, you can use `mapM_'/`forM_'/`traverse_'/`traverse_' (or the `_'-less variants, if you want to collect results in a collection), you can use `foldM' or `foldr', you can use the usual `map',`filter',`concatMap',list comprehensions,`fmap',&c.
06:52:21 <ski> deni : hm, perhaps you could use `init',`tails',`last' ?
06:52:34 <ski> hm, or you always have a continuous sequence from `1' to `n' ?
06:53:34 <ski> if you want to be able to change the current position, locally, then a zipper might be interesting, yea
06:53:59 <ski> but if you always have `[1 .. n]', then this is possibly overkill
06:54:22 <jusss> ski: https://paste.ubuntu.com/p/X9qg8TSm8T/
06:54:40 <jusss> ski:  this only recv once message, then the whole program exit
06:54:56 <jusss> I'd like to make it keeping recv messages
06:55:18 <ski> how many times / until when ?
06:55:23 <jusss> in other lanagues, I can use a for-loop
06:55:37 <jusss> recv() and print() in that for-loop
06:57:06 <k0ral> how would you name `f :: (b -> a -> (a, Maybe b)) -> b -> a -> a` ? Looks like a known standard function, yet Hoogle can't find anything with that signature
06:58:07 <c_wraith> it looks like a combination of unfoldr and last
07:00:34 <ski> jusss : so .. just look forever ? try using `forever' ?
07:01:34 <ski> s/look/loop/
07:02:16 <ski> instead of `x <- return foo', you can use `let x = foo'
07:02:48 <k0ral> c_wraith: I fail to see the connection with "last": f fun root init is iteratively applying fun on init
07:02:56 <absence> jusss: yes, "return" wraps the result in a dummy layer of IO
07:02:58 <ski> jusss : do you want to abort the loop on error ? retry ? continue ?
07:03:19 <ski> k0ral : last state
07:03:42 <dmwit> :t \f -> last . unfoldr (sequence . f)
07:03:43 <lambdabot> (a -> (c, Maybe a)) -> a -> c
07:03:44 <ski> (s/state/root approximation/ ?)
07:03:49 <dmwit> k0ral: ^
07:04:02 <ski> (that doesn't thread state)
07:04:16 <absence> jusss: "return" is a bit of a misleading name though, you might want to consider the more modern "pure". for monads, return = pure
07:04:17 <k0ral> oh, right
07:04:17 <dmwit> oops, that's not it
07:04:27 * ski isn't quite sure why it's both looping around `a' and `b', though
07:04:40 <ski> k0ral : it seems a bit .. particular, i think ?
07:04:58 <k0ral> ski: is it ? I thought it was a common pattern
07:06:48 <c_wraith> looks like a different unfold than ana.  There's must be a variant that's like ?:ana::para:cata
07:07:57 <ski> k0ral : i assume you have `foo fun root0 state0 = case mroot1 of { Nothing -> state1; Just root1 -> foo fun root1 state1 } where (state1,mroot1) = fun root0 state0' ?
07:08:26 * ski looks at jusss
07:08:36 <dmwit> :t \f -> last . unfoldr (fmap (join (,)) . sequence . f)
07:08:37 <lambdabot> Traversable t => (t a -> t (Maybe a)) -> t a -> t a
07:08:43 <dmwit> There we go ^_^
07:09:01 <dmwit> Specifically pick t ~ (,) b
07:09:07 <k0ral> ski: yes this s it
07:09:11 <k0ral> is*
07:09:50 <dmwit> :t \f -> fst . last . unfoldr (fmap (join (,)) . sequence . f)
07:09:51 <ski> k0ral : the "particular" bit would be having two pieces of state being passed around, one using `Maybe' in the result, the other not
07:09:52 <lambdabot> ((c, a) -> (c, Maybe a)) -> (c, a) -> c
07:12:07 <ksqsf> :t ((fst .) .)
07:12:08 <lambdabot> (a1 -> a2 -> (c, b)) -> a1 -> a2 -> c
07:12:17 <ski> dmwit : hm, doesn't that give the penultimate `a' ?
07:12:29 * ksqsf is not sure about `Maybe'
07:12:38 <ski> (`sequence' throwing away the ultimate one)
07:13:39 <jusss> ski: sorry, I was just in  another room
07:14:04 <ski>   sequence :: (a,Maybe b) -> Maybe (a,b)  -- will throw away the `a' that is generated last
07:14:06 <jusss> ski: can I do forever in do-notation?
07:14:18 <jusss> 'cause there's some actions just need to be run once
07:14:23 <ski> no, by you can mix it with `do'-notation
07:14:31 <k0ral> dmwit: that's it indeed, but I guess it does not help me in describing/naming the pattern in few words :)
07:14:39 <ski> you can call `forever' inside a `do', and then have another `do' inside that
07:15:09 <k0ral> somehow, I expected a composition of fewer "primitives"
07:15:49 <ski> k0ral : this is being used to find an ultimate approximation of something ? or some version of fixpoint iteration ?
07:15:50 <c_wraith> it really is an unusual pattern, though
07:16:12 <c_wraith> it very uncommon to need to thread the previously-generated state through
07:16:30 <tabaqui1> I have "foo :: (Lift a, Show a) => a -> ExpQ; foo s = [| print s |]", but compiler told me that Show a is redundant here?
07:16:40 <tabaqui1> why so? Lift doesn't imply Show
07:16:59 <k0ral> ski: I meant to use this pattern for an iterative search function
07:17:26 <k0ral> f searchStep originalLocation resultDataStructure
07:17:28 <c_wraith> tabaqui1: because the show constraint is in the generated code, not in the implementation of foo
07:17:53 <jusss> ski: https://paste.ubuntu.com/p/tcgn8dqCcF/
07:18:04 <ski> tabaqui1 : the function doesn't use any `Show' functionality. it generates code which does
07:18:25 <k0ral> f calls searchStep at originalLocation, results in (newResult, maybe nextSearchLocation)
07:18:26 * ski . o O ( Mealy,Moore machines )
07:18:43 <ski> @index forever
07:18:43 <lambdabot> Control.Monad
07:18:46 <ski> jusss ^
07:19:06 <c_wraith> k0ral: we're not saying it's hard to understand.  we're saying it's more complexity than most problems need.
07:19:06 <k0ral> result is a data structure that keeps track of what has been explored up to now, and what search has found
07:19:27 <tabaqui1> ok, I'll better disable this warning than omit the constraint
07:19:33 <tabaqui1> c_wraith, ski: thanks
07:19:36 <deni> absence: MarcelineVQ ski I took the naive approach in the end: http://dpaste.com/08T5AES
07:19:44 <deni> it's not pretty but it works ok(ish)
07:19:52 <ski>   getResult = map (maybe (error "can't happen : getResult") text . message)  -- jusss
07:19:56 <deni> (it's purescript not haskell but it's the same more or less)
07:20:41 <c_wraith> tabaqui1: it's not like it can accidentally compile somehow if you use a type without a Show instance.
07:20:47 * ski . o O ( vertex vs. edge ? )
07:21:41 <tabaqui1> c_wraith: I understand, but I guess, compilation would fail sooner
07:21:50 <k0ral> c_wraith: ok, I guess my intuition that this was a common pattern, was wrong
07:22:07 <ski> deni : how's that `Array' defined ?
07:22:21 <deni> ski: that's just [a] they just don't have syntax sugar for it
07:22:32 <c_wraith> k0ral: note that ski's comment on Mealy/Moore was relevant to you.  They're an alternative way to look at this which might result in simpler code than thinking of it as an unfold
07:23:03 <jusss> ski: this getUpdates is not a block function, forever make it loop so fast, wow
07:23:12 <deni> ski: I just realized this doesn't do exactly what I want... for instance ["1","...","21","22","23","24","...","100"] if my current index is 24 then I don't have 25 in that list to click on
07:23:55 <jusss> ski: is there sleep function in haskell?
07:23:57 <ski> deni : hm (re paste), i think that may repeat some elements, in case you're near the end, or the start. also i'd factor out the magic number `4'
07:24:08 <jusss> put sleep in for loop
07:24:26 <c_wraith> threadDelay
07:24:29 <ski> deni : "that's just [a] they just don't have syntax sugar for it" -- yea, a little bit confusing, since there's already an `Array' in the standard library, which i first thought you were using :)
07:24:32 <c_wraith> but make sure you pay attention to the docs.
07:24:44 <c_wraith> the number it takes is *microseconds*, not the milliseconds most people expect
07:25:17 <k0ral> c_wraith, ski: will look into both recursive patterns and mealy/moore machines, thank you for the pointers
07:26:07 <deni> ski: if I'm using the edge value in the list: like 4 in [1,2,3,4] or 24 in [21,22,23,24] then this breaks down... I mean it's not terrible but it'd be nice if I add at least one digit to the right (or left) of the edge number
07:26:08 <ski> deni : "I just realized this doesn't do exactly what I want..." -- oh, i thought your `divvy' gave a "sliding window"
07:26:36 <deni> ski: divvy is from here https://pursuit.purescript.org/packages/purescript-split/0.2.0/docs/Data.Array.Split
07:26:37 <ariakenom> I like defining a sleep = threadDelay . ceiling . (*1000000)
07:26:52 <deni> ski: I couldn't find something in the libraries that gave me a sliding window 
07:29:02 <deni> again it's not haskell but I figured the problem would be fairly trivial to implement either way
07:30:29 <ski> deni : <https://hackage.haskell.org/package/split-0.2.3.3/docs/Data-List-Split.html#v:divvy>
07:30:43 <ski> hm
07:30:57 <ski> oh, you're doing PureScript ?
07:31:09 <ski> ok
07:31:29 <c_wraith> sliding windows are somewhat awkward in Haskell.  I can't think of a better way to do them than Data.Sequence, which seems like ridiculous overkill.  There probably is a better approach, but it's something requiring cleverness
07:32:15 <ski> deni : do you want to be able to handle an arbitrary (say distinct) list of elements (perhaps in increasing order), or just continuous elements (always starting at `1', possibly) ?
07:32:32 <c_wraith> Well, I guess you can do them with mutable arrays too, if you're willing to work in an environment where those exist
07:33:12 * ski idly wonders whether `Array' is linked-list, in PureScript
07:34:06 <lortabac> I'd suppose they compile to JavaScript arrays, so no
07:34:20 <lortabac> but I know zero Purescript
07:34:24 <ski> deni : why not an odd window size, like three or five ?
07:34:39 <deni> ski: always starting at 1 to n where N isn't going to be a large number
07:34:46 <ski> aye
07:34:50 <ski> and always continuous ?
07:34:51 <deni> ski: I hadn't considered odd window sizes
07:34:59 <deni> ski: always continuous yes
07:35:26 <ski> with odd, you could have the currently selected one in the middle, which sounds like you might want ?
07:36:51 <deni> ski: if I set the window so let's say 5. I still have the issue when the current index is let's say 25
07:38:18 <ski> so, given `n', and window size (odd) is `m', check if current index `i' satisfies `1 =< i < 2*m' or `2*m =< i =< n-2*m+1' or `n-2*m+1 < i =< n', and handle these cases differently ?
07:38:29 <deni> ski: oh...re Arrays...it compiles to JS arrays so it's not really a linked list. I just simplified a bit cause it didn't pertain to the problem at hand I guess
07:38:54 <ski> ok, then i suppose `Array' makes a bit sense
07:39:26 * ski thinks it looks a bit strange to use `/\' for pair (`Tuple') constructor (pattern synonym ?)
07:39:36 <deni> me 2 :D
07:41:31 <ski> so you have, with `n = 20',`m = 3', (`i = 5') `1,2,3,4,*5*,6,...,18,19,20' vs. (`i = 6', e.g.) `1,2,3,...,5,*6*,7,...,18,19,20' vs. (`i = 16') `1,2,3,...,15,*16*,17,18,19,20'
07:41:49 <ski> or, do you only want to show "half" the window, at the two ends ?
07:42:06 <ski> ah, i see in your example, you only showed one
07:42:22 <ski> anyway, something like this could be adapted
07:42:37 <deni> it doesn't really matter...I only showed the ends because that's what I typed out first...the outlined example above that you gave looks corrects to me
07:43:07 <__dingbat__> Hello, can someone help understand why this Aeson decode is failing please? 
07:43:09 <__dingbat__> https://www.codepile.net/pile/O5lOYExa
07:43:53 <ski> deni : so, do you need an array of indices, at all ? can you just do some arithmetic with `n',`m = 5' (or whatever), and `i' ?
07:45:01 <deni> Well it's not really an array of indices...it's an array of page numbers
07:45:04 <deni> but sure
07:45:17 <deni> that idea is that the resulting array can be just shown to the user
07:45:22 <deni> (well sort of)
07:46:26 <ski> well, you're showing the current element, hightlighted somehow
07:46:32 <ski> so you're not just showing the array
07:46:39 <deni> oh right
07:46:48 <ski> you're constructing a text string, to show
07:46:49 <lyxia> __dingbat__: the default FromJSON instance expects a different format
07:47:15 <ski> so, i'm not sure if there's any other reason why you'd like to keep the array of indices / page numbers
07:48:26 * ski considers page numbers to be more or less indices
07:48:36 <deni> ski: I'm not sure what you're asking. Yes i'm applying some function to it so that I can display it. In the simplified example it's just "show". 
07:48:53 <__dingbat__> lyxia: I updated the link with an additional log line, can you please have another look?
07:49:36 <deni> ski: in the actual code it's now going to be show but a function that applies some html
07:49:45 <deni> ski: but in essence it's the same
07:49:53 <__dingbat__> lyxia: I have updated the link with the default ToJSON and FromJSON too..
07:49:55 <ski> your `shrinkPages' takes an array. i'm asking whether there's any reason for that input array to exist at all. why not just pass `n' to the function that is to produce your page number output, with elided page numbers, and the current one highlighted ?
07:50:12 <deni> ski: oh I see...yeah no reason for that at all
07:50:17 <ski> (itym, s/now/not/)
07:50:32 <lyxia> __dingbat__: you need to change the defaultOptions https://hackage.haskell.org/package/aeson-1.4.5.0/docs/Data-Aeson.html#t:SumEncoding
08:01:44 * hackage krank 0.1.0 - Krank checks your code source comments for important markers  https://hackage.haskell.org/package/krank-0.1.0 (guibou)
08:23:43 <arampaa> hey, noob question: I'm currently trying to figure out how to extract the medoid of a list of integers. Specifically, the element for which the number of elements strictly smaller than it is at most 1 higher than the number of elements strictly bigger than it. So far, I used a quicksort implementation to split the list into two lists (smaller and
08:23:44 <arampaa> larger elements than the pivot). However, Haskell keeps complaining when I try to compare the lengths of the two lists (I'm guessing it's kind of nonsensical since one could theoretically be of infinite length?) Can someone point me in the right direction here?
08:24:08 <arampaa> quicksort :: [Int] -> Intquicksort [] = 0quicksort (x:xs) =    let smallerSorted = quicksort (filter (<=x) xs)        biggerSorted = quicksort (filter (>x) xs)
08:25:45 <arampaa> https://gist.github.com/arampaa/b453b166836f104da3aed2004eec9203
08:26:52 <dminuoso> arampaa: The problem has to do with
08:26:52 <arampaa> this is basically what I have, the "in" statement is what I would like to return (which I suppose would be the pivot element x in that case)
08:26:54 <dminuoso> % :t fromIntegral
08:26:54 <yahb> dminuoso: (Integral a, Num b) => a -> b
08:27:12 <dminuoso> arampaa: ^- this is basically a family of functions.
08:27:33 <dminuoso> arampaa: GHC has to know which exact function you want from that family. It does so by figuring out what type you want for `a` and `b` respectively.
08:28:03 <dminuoso> % left = fromIntegral 10
08:28:04 <yahb> dminuoso: 
08:28:09 <dminuoso> % right = fromIntegral 10
08:28:09 <yahb> dminuoso: 
08:28:47 <arampaa> so, there's a type mismatch when I use fromIntegral for the length of a list?
08:29:45 <dminuoso> arampaa: Ah actually there's several things wrong.
08:30:32 <dminuoso> arampaa: What type do you think `biggerSorted` has?
08:31:01 <kuribas> how would you implement a timer library than can report timings in json on a live system?  Maybe a Timer monad transformer, then using unsafePerformIO to get timings?
08:31:02 <arampaa> I believe it's [Int] right?
08:31:16 <dminuoso> arampaa: So lets do what GHC does!
08:31:39 <dminuoso> arampaa: would you agree that biggerSorted has to have the same type as the right hand expression?
08:32:10 <arampaa> dminuoso sure
08:32:57 <dminuoso> `quicksort (filter (>x) xs)` the type of this expression is... whatever `quicksort` gives you back after applying one argument to it (lets even ignore its argument! things will work out regardless of whether that matches)
08:33:18 <deni> ski: Ok still the naive approach but this works out fine in the sense that there's a sliding window now: http://dpaste.com/2DRN3M9
08:33:43 <deni> ski: I'd like to make it more general and have been looking into ZipperArray but for now...meh
08:35:06 <dminuoso> arampaa: What does your quicksort return after one argument?
08:35:52 <arampaa> oooh I figured out one of the things that's wrong!
08:37:12 <arampaa> basically it has been trying to figure out the length of something that's not a list
08:40:33 <dminuoso> arampaa: Indeed. I was a bit side tracked by the other diagnostic (Once there's a type incorrectness, the way our inference works you usually get strange diagnostic artifacts in seemingly unrelated places)
08:45:13 <arampaa> dminuoso indeed now there are no errors. However, now it is still unclear to me how I can get to this x in the middle. My in now looks like this   if (lengthSmaller > lengthBigger) then [x] ++ smallerSorted ++ biggerSorted else [x] (for now I ignore the else part). However, this always returns the first element of the original list
08:46:28 <dminuoso> arampaa: just flip it around? :)
08:47:54 <jusss> in `forever' loop, what if there's parameter need to change everytime , how to do that?
08:48:45 <arampaa> dminuoso you mean smallerSorted ++ [x] ++ biggerSorted? or the other way around?
08:48:49 <dminuoso> jusss: dont use forever. make an explicit loop
08:48:51 <arampaa> it still does the same
08:49:14 <jusss> dminuoso: you mean make loop inside main?
08:49:35 <dminuoso> jusss: A loop is just encoded by recursion.
08:49:59 <dminuoso> % let looped = putStr "Hi" >> looped in looped
08:50:04 <yahb> dminuoso: HiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHi
08:51:10 <jusss> dminuoso: but there're a sequence actions, not just one
08:51:21 <dminuoso> jusss: Its still a single action.
08:51:27 <dminuoso> % :t looped = putStr "Hi" >> looped in looped
08:51:28 <yahb> dminuoso: ; <interactive>:1:8: error:; parse error on input `='; Perhaps you need a 'let' in a 'do' block?; e.g. 'let x = 5' instead of 'x = 5'
08:51:39 <dminuoso> % :t let looped = putStr "Hi" >> looped in looped
08:51:39 <yahb> dminuoso: IO b
08:51:48 <dminuoso> Do you see it's just a regular IO action? :)
08:52:44 * hackage persistent 2.10.2 - Type-safe, multi-backend data serialization.  https://hackage.haskell.org/package/persistent-2.10.2 (MaxGabriel)
08:53:36 <dsal> I don't think I completely understand what    v{a=x}   does.
08:53:55 <jusss> dminuoso: https://paste.ubuntu.com/p/BbcxHFjqZZ/
08:54:04 <dminuoso> dsal: It updates the record v with the value of the field a replaced by x.
08:54:16 <dminuoso> (By update I mean "return a new value" of course)
08:54:39 <jusss> dminuoso: this is a telgram api bot code, the getUpdates function to recv msg, I'm trying to run it every 3 secs
08:54:40 <dsal> Yeah, I've used it a lot... but I don't quite get it.  In particular, this type doesn't have its constructors exposed, but the individual fields are exposed.
08:55:07 <jusss> but there's a parameter need to be changed everytime, the second parameter of getUpdates
08:55:13 <jusss> which is Nothing now, 
08:55:28 <dminuoso> jusss: Do you understand how my example above works?
08:55:34 <jusss> this parameter need to store the value every it produces for next call
08:55:48 <dsal> No wait... this actually works.  I just don't understand why.  heh
08:56:05 <dminuoso> dsal: Presumably because a field accessor is enough to update a field?
08:56:16 <dminuoso> dsal: field accessors are magical, they are more than just functions.
08:56:19 <jusss> dminuoso: putStr "Hi" >> putStr "Hi" >> ...
08:56:19 <dsal> Yeah.  It just seems a little magical.
08:56:23 <dminuoso> % data Foo a = Foo a
08:56:23 <yahb> dminuoso: 
08:56:36 <dminuoso> % field (Foo a) = a
08:56:37 <yahb> dminuoso: 
08:56:50 <dminuoso> % let v = Foo 'c' in v{field = 'd'}
08:56:50 <yahb> dminuoso: ; <interactive>:5:22: error:; * `field' is not a record selector; * In the expression: v {field = 'd'}; In the expression: let v = Foo 'c' in v {field = 'd'}; In an equation for `it': it = let v = Foo 'c' in v {field = 'd'}
08:57:12 <dminuoso> dsal: I dont fully understand how GHC knows this, but record selectors definitely are special.
08:58:13 <dminuoso> jusss: Sure. So you understand it. Now modify it to include a counter that is bumped by one each turn and then printed.
08:59:47 <dminuoso> dsal: Ah the Haskell report specifies this: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-490003.15
09:00:57 <dminuoso> "These field labels can be used to construct, select from, and update fields in a manner that is independent of the overall structure of the datatype. "
09:02:33 <dminuoso> dsal: The Haskell semantics are relevant before desugaring, not after. So it doesnt matter that this does indeed desugar into pattern matching, merely that the semantics specify that you can update a data value using a field label.
09:02:53 <nxths> hi does anyone how to compile GHC 8.8.1 w/ stack currently? seem to be blocked on https://gitlab.haskell.org/ghc/ghc/issues/17246 because stack can't find the newer base/etc libs on hackage
09:05:18 <dsal> dminuoso: Hmm... OK.  I just thought that not being exposed as it were, it wouldn't work.  But I guess I'll take it.
09:06:31 <dminuoso> dsal: Well if that was differently, labels shouldnt work at all without the data constructor in case
09:06:51 <dminuoso> Because regardless of whether you update or just read out, its going to desugar into pattern matching with the data constructor either way.
09:07:51 <dminuoso> Ah perhaps not, because you could think of them as just functions.
09:08:32 <jusss> dminuoso: f x = do print x; f (x+1);      
09:08:44 <dminuoso> jusss: There you go. :)
09:08:45 <dsal> The confusing part is that, at least in reading the docs, it feels like I wanted to run the function the other way.
09:08:59 <dsal> f x = print x >> f (x + 1)
09:09:00 <dminuoso> jusss: Just like in regular functions, we model loops with recursion and state with parameter passing.
09:09:03 <pie_> ski: i made a little progress, ill probably pick it up again later today
09:09:20 <dsal> or I guess...
09:09:28 <dsal> @undo do print x; f (x+1)
09:09:28 <lambdabot> print x >> f (x + 1)
09:09:43 <ski> pie_ : oh .. i suppose you're responding re what you said in #haskell-beginners
09:09:47 <dminuoso> jusss: Modelling state as simple function arguments is a very neat trick that is pervasive in Haskell.
09:09:52 <jusss> dminuoso: sorry, I'm not familar with `let' `where' keywords yet
09:10:19 <jusss> dminuoso: do you expect my anwser like yours?
09:10:29 <jusss> with `let' and `>>'
09:12:34 <ski> dani- : instead of `elem' you could there just use ordinary arithmetic comparisions. it would be possible to combine the two `filter's (you could also use a list comprehension, if you prefer)
09:22:30 <dminuoso> jusss: No its perfectly fine. :)
09:23:46 <jusss> dminuoso: there must be a way like that, but I don't know yet, you would know how it's like I think :)
09:23:59 <ski> jusss : hmm, did you answer any of my questions ?
09:25:33 <jusss> ski: <ski>   getResult = map (maybe (error "can't happen : getResult") text
09:25:33 <jusss>       . message)  -- jusss this one?
09:26:23 <jusss> ski: my ERC shows this is the last one message you sent me, sorry, I've reading disorder, sometimes I missing some words
09:28:04 <ski> e.g.
09:29:09 <ski> also
09:29:28 <ski> <jusss> how to make a loop within `main ' ?  <ski> what kind of loop ?  <ski> you can use explicit recursion, you can use `mapM_'/`forM_'/`traverse_'/`traverse_' (or the `_'-less variants, if you want to collect results in a collection), you can use `foldM' or `foldr', you can use the usual `map',`filter',`concatMap',list comprehensions,`fmap',&c.
09:29:51 <ski> <jusss> ski: https://paste.ubuntu.com/p/X9qg8TSm8T/  <jusss> ski:  this only recv once message, then the whole program exit  <jusss> I'd like to make it keeping recv messages  <ski> how many times / until when ?  <jusss> in other lanagues, I can use a for-loop  <jusss> recv() and print() in that for-loop
09:30:21 <ski> <ski> instead of `x <- return foo', you can use `let x = foo'  absence> jusss: yes, "return" wraps the result in a dummy layer of IO
09:30:43 <ski> <absence> jusss: "return" is a bit of a misleading name though, you might want to consider the more modern "pure". for monads, return = pure
09:30:57 <ski> <ski> jusss : so .. just loop forever ? try using `forever' ?  <ski> jusss : do you want to abort the loop on error ? retry ? continue ?
09:31:49 <ski> jusss : also not sure what you meant by "this getUpdates is not a block function, forever make it loop so fast, wow"
09:32:55 <jusss> ski: my apoligies, I did not make the question clear
09:33:21 <jusss> ski: I were fuzzy too
09:34:37 <jusss> ski: getUpdate is not a blocked function, it won't block the main thread, so forever will run it repeatly
09:35:00 <jusss> without a waiting time
09:35:00 <dsal> That's forever's only job.
09:35:21 <dsal> Oh.  Yeah, you can toss a ``>> threadDelay x''  in there.
09:35:59 * ski is still waiting for jusss to answer questions
09:38:09 <jusss> ski: I want' a recursion loop, x <- return foo equal to let x = foo , yes, loop forever, yes, abort loop on error? yes, what else?
09:39:11 <ski> "I want' a recursion loop" doesn't say much. in the end, all looping is recursion. perhaps you're saying you want explicit recursion, though
09:39:39 <ski> jusss : you do `case' on `Either'. do you want to abort the loop, in case of a `Left' ?
09:39:56 <ski> jusss> :t sendMessage
09:40:02 <ski> jusss> :t getUpdates
09:40:37 <jusss> I was out when you asked me , sorry again, I didn't check full message clear
09:41:40 <ski> okay
09:41:47 <jusss> ski: yes, in case of a `Left', that's what Either used to
09:42:25 <ski> ok. so what about `sendMessage' and `getUpdates' ?
09:42:40 <jusss> ski: sendMessage and getUpdates https://github.com/klappvisor/haskell-telegram-api/blob/master/src/Web/Telegram/API/Bot/API/Updates.hs
09:43:03 * ski was just asking for their types, but ok
09:43:06 <jusss> getUpdates    :: Token    -> Maybe Int -- ^ offset    -> Maybe Int -- ^ limit    -> Maybe Int -- ^ timeout    -> Manager    -> IO (Either ClientError UpdatesResponse)
09:44:00 <jusss> type UpdatesResponse = Response [Update]
09:44:00 <ski> hm, i see no `sendMessage' there
09:44:48 <jusss> https://github.com/klappvisor/haskell-telegram-api/blob/master/src/Web/Telegram/API/Bot/Responses.hs
09:44:54 <jusss> ski: wait a sec, I'm finding
09:45:51 <jusss> data Update = Update  {    update_id            :: Int    , message              :: Maybe ...}  from https://github.com/klappvisor/haskell-telegram-api/blob/master/src/Web/Telegram/API/Bot/Data.hs
09:46:10 <jusss> also data Message is here too
09:46:54 <jusss> ski: sendMessage_               :: Token -> SendMessageRequest -> ClientM MessageResponse  from https://github.com/klappvisor/haskell-telegram-api/blob/master/src/Web/Telegram/API/Bot/API/Messages.hs
09:48:00 <jusss> there's not a good document on this project, so we have to find something in the code
09:48:27 <jusss> that old version on hackage is not matched the latest on github
09:51:50 <jusss> ski: this is the code I'm tring to change https://paste.ubuntu.com/p/BbcxHFjqZZ/
09:52:19 <jusss> I'm gonna take the getUpdates function out of main, and put it on a new function,
09:52:35 <jusss> and call  the  new function in main,
09:53:12 <jusss> and that function will be recursive like f x = do print x >> f (x+1)
09:55:49 <ski> jusss : no, not `sendMessage_', i was asking about `sendMessage' (no underscore there, at the end)
09:57:41 <jusss> ski: sendMessage :: Token -> SendMessageRequest -> Manager -> IO (Either ClientError MessageResponse)  sendMessage = runM sendMessageM
09:58:07 <jusss> which is from https://github.com/klappvisor/haskell-telegram-api/blob/master/src/Web/Telegram/API/Bot/API/Messages.hs
09:58:24 <ski>   getUpdates :: Token -> {- offset :: -} Maybe Int -> {- limit :: -} Maybe Int -> {- timeout :: -} Maybe Int -> Manager -> IO (Either ClientError UpdatesResponse)
09:58:32 <ski>   sendMessage :: Token -> SendMessageRequest -> Manager -> IO (Either ClientError MessageResponse)
09:58:36 <ski> yea, i found it
09:58:50 <ski> ok
10:00:01 <ski> jusss : ok, so you have `IO (Either ClientError (...))', using the same "exception type" `ClientError' in both cases (`sendMessage' and `getUpdates')
10:00:28 <ski> jusss : so, you could possibly instead use `ExceptT ClientError IO (...)', rather than `IO (Either ClientError (...))' here
10:00:43 <jusss> ski: yeah
10:01:03 <ski> then the `Left' cases would automatically abort
10:01:13 <ski> (if you want to, you could catch them, further out)
10:08:23 <jusss> ski: yes, and print the error message
10:17:20 <jusss> ski: time to sleep, good night!
10:17:48 <ski> mhm
10:25:00 <dsal> This code is weird.  It has lots of things like    Applicative.pure (Maybe.Just chunk))
10:25:53 <dsal> And everything's a do block.   Like        defaultConfig = do; Config{stuff}
10:26:22 <ski> that's sounds weird, yea
10:26:31 <dsal> Bool.False  
10:26:48 <dsal> I feel like this author's been burned before.  heh
10:27:19 <EvanR> this looks like elixir style code
10:27:28 <EvanR> you qualify everything
10:27:49 <ski> if you import `False' from `Prelude', then if someone else would provide `False' in some module you import unqualified, there'd be an ambiguity error, no ?
10:30:16 <Ariakenom> ski yes
10:31:48 <dsal> Every import is qualified and NoImplicitPrelude
10:31:48 <EvanR> haskell has made me appreciate a well chosen universe of names
10:32:11 <EvanR> if only haskell used that well chosen univere of names without a ton of imports or custom prelude
10:32:46 <ski> ah, `NoImplicitPrelude'
10:32:57 <ski> dsal : and, dare i ask, is `Prelude' imported, qualified ?
10:33:23 <dsal> No Prelude at all.
10:33:30 <EvanR> heh
10:33:32 <ski> i see
10:33:52 <ski> perhaps there's some hope for sanity, then
10:37:04 <dsal> Haskell is several languages, I think.
10:37:44 <Ariakenom> dsal: what was the context? that sort of make sense as practise code. 
10:38:28 <dsal> This was a library I was using.  I stopped using it because it was missing a feature and the docs were like, "If you need this one feature, write the whole library yourself."  So I just copied some of the concept from the inside.  But the implementation looked strange.
10:38:31 <dsal> Not incorrect, just strange.
10:41:51 <ooo_miguel> hi
10:42:35 <ooo_miguel> what is the ~ in: i ~ j => Indexable i (Indexed j)
10:42:37 <ooo_miguel> ?
10:42:47 <ski> equality of types constraint
10:43:06 <ooo_miguel> ah ok thank you
10:43:30 * ski assumes this is an `instance' declaration ?
10:43:38 <dsal> ski: How would you translate that to English?
10:43:52 <dsal> i.e., couldn't you just use 'a' there instead of i and j?
10:44:00 <ooo_miguel> yes it is
10:44:09 <ski> the `Indexable' relation holds between `i' and `Indexed j', if `i' and `j' are equal
10:45:17 <ski> if you just said `Indexable i (Indexed i)', then that would express the same relationship. however, in that case, you could possibly also add a separate instance declaration `Indexable Foo (Indexed Bar)' (assuming `Foo' and `Bar' are distinct)
10:45:58 <ski> with `i ~ j => Indexable i (Indexed j)' you prohibit that, since you can't have overlapping `instance' heads (no back-tracking, like in logic programming)
10:46:41 <ooo_miguel> I saw some overlapping instances, but they used some ghc extensions, and not sure it this would apply here
10:46:50 <dsal> Ah, OK.  I've not needed to do that sort of thing yet.  Thanks.
10:47:09 <ski> it's generally agreed that `OverlappingInstances' (and `IncoherentInstances') are (almost always ?) a bad idea
10:48:16 <ski> (`UndecidableInstances' is fine, though. the worst that can happen is that the instance resolution phase won't terminate (or rather, run into a time-out, or a maximum recursion or resolution count, or something like that))
11:04:40 <sternmull> What is a better way to write "iterateFoo n = foldr (\_ acc -> foo acc) z (replicate n undefined)"? I basically want to a apply the Nth composition of a function with itself to an argument.
11:05:50 <EvanR> :t iterate
11:05:52 <lambdabot> (a -> a) -> a -> [a]
11:06:14 <EvanR> iterate f myFoo !! n
11:06:49 <EvanR> @src iterate
11:06:49 <lambdabot> iterate f x = x : iterate f (f x)
11:07:10 <EvanR> and more fundamentally you could use iter
11:07:29 <sternmull> i found interate but didn't like to access the nth element of the list... assumed it wouldn't be efficient.
11:07:34 <EvanR> iter f z 0 = z
11:08:00 <EvanR> iter f z n = f (iter f z (n-1))
11:08:18 <EvanR> iter :: (a -> a) -> a -> N -> a
11:08:54 <EvanR> the eliminator for N
11:10:44 * hackage wai-middleware-auth 0.2.0.0 - Authentication middleware that secures WAI application  https://hackage.haskell.org/package/wai-middleware-auth-0.2.0.0 (lehins)
11:11:19 <sternmull> Can't find iter with that signature in any packet.
11:11:26 <sternmull> Of course i could define it myself.
11:11:26 <EvanR> it doesn't exist
11:11:29 <sternmull> ah, ok
11:12:00 <EvanR> you probably want to define it yourself and then modify it to suit your performance needs, should it be strict or lazy
11:12:58 <wildtrees> could I use gtk3 which is LGPL (version 2.1) inside of a haskell program that I distribute commericially, or would I have to give out the source code to my program linked with gtk3? linking isn't clear from the license and I know haskell isn't exactly linking in the normal sense the haskell "shim" for gtk3 , I believe it is including the code and compiling it with my program, or is this a grey area?
11:14:20 <EmilKarlson> IANAL, but afaik it would be normally dynamically linking in the end, which is explicitly allowed by lgpl
11:14:23 <wildtrees> I have read like 2/3 of the lgpl version 2.1 and its still not clear 
11:14:37 <EmilKarlson> unless the haskell wrapper is lgpl licensed, in which case you might be in trouble
11:14:49 <wildtrees> yea but it says the gtk3 haskell module is under lgpl, I know there is normal linking of the gtk c library at the end 
11:15:14 <EvanR> as if haskell GUIs don't have enough to worry about :(
11:15:45 <wildtrees> I have a hard time getting haskell graphic stuff to work totally in the way I want to , other than gloss
11:16:17 <wildtrees> i had a gtk2/gtk3 app working in msys2 the other year , but couldnt figure out what dll's I needed to include in its directory or path to succesfully distribute it 
11:17:00 <wildtrees> rewrote most of it in scala with swing, and swing was like some ancient nightmare from the 90's 
11:17:31 <wildtrees> I can almost see why everyone is just moving everything to web app or phone apps 
11:18:02 <wildtrees> EmilKarlson, IANAL = I am not a lawyer? 
11:18:21 <EvanR> wildtrees: or... perhaps native desktop framework
11:18:56 <wildtrees> yea f# with some native windows gui library wasn't too hard to develop for or distribute , like 1 or 2 dlls with the exe 
11:19:19 <EmilKarlson> yes
11:21:01 <wildtrees> maybe the greyness of the LGPL is why google with android made the bsd licensed bionic layer over the linux kernel instead of using the regular gnu libraries for linux 
11:22:06 * EvanR wonders what the state of windows GUI programming is in haskell
11:26:24 <wildtrees> EvanR, I have gotten gtk2 and gtk3 working with haskell using msys2 before. msys2 gives you like a *nix like environment on windows with the pacman package manager, with quite a few packages for it, but i cant figure out how to distribute the apps, like what dll's are needed, gloss works, and the hugs graphic library used to work a few years ago, but not sure if you can really consider those gui libraries 
11:26:46 <EvanR> i've heard of gtk+ working
11:26:50 <wildtrees> I tried sdl a few years ago, and couldnt get it working too good on windows at all
11:27:00 <wildtrees> is gtk+ gtk3? 
11:27:03 <EvanR> sure
11:27:10 <wildtrees> yea I dunno either 
11:27:16 <EvanR> but i was referring to you know... windows GUI
11:27:28 <EvanR> winforms? win32? 
11:27:35 <wildtrees> people used to recommend wx sometimes 
11:27:44 <EvanR> wx O_o
11:27:56 <EvanR> does not count as windows programming
11:28:07 <wildtrees> it does native looking guis for each operating system it supports 
11:28:18 <EvanR> at least there's that
11:28:32 <EvanR> but you don't get access to the native features, which is part of the point
11:28:40 <EvanR> you're limited to a "common" subset
11:29:05 <wildtrees> dont know if it still works, hacking on it trying to get it work on freebsd once, the build script for wx called ld or ldd with linux specific options and broke my freebsd install really bad 
11:29:16 <EvanR> also wx is a C++ lib
11:30:08 <EvanR> basically there is this semi mythological method where you use the actual OS provided API and everything works great for that platform because you played by all their rules
11:30:23 <EvanR> that many open source programmers don't do because it's not cross platform
11:31:44 * hackage schemas 0.3.0 - schema guided serialization  https://hackage.haskell.org/package/schemas-0.3.0 (PepeIborra)
11:32:05 <wildtrees> I am actually trying to get a specialized monad that only allows like putStrLn and getline in it for IO to be polymorphic in a tagless final style and work with gtk as well as console and a debugging harness, got sidetracked reading the license for gtk3 
11:33:33 <EvanR> combining final tagless with monads
11:33:49 <wildtrees> yea 
11:33:55 <wildtrees> mtl already kinda does it 
11:34:28 <EvanR> two very abstract things
11:34:30 <wildtrees> I have had problems trying to use mtl constraints like MonadWriter in my typeclass instance constraints 
11:34:51 <wildtrees> had to make my instances have a more concrete monad type 
11:35:38 <wildtrees> do notation is almost kinda like final tagless in a way 
11:36:18 <wildtrees> if you dont use any concrete monad actions/functions in the do block, the do block is totally polymorphic over any monad 
11:36:21 <EvanR> after reading the lecture notes and stuff i see final tagless everywhere haha
11:36:45 <wildtrees> yea I am seeing it a bit, its like a light is going on for how I can use typeclasses 
11:37:09 <wildtrees> their use other than prebaked ones, always kind of eluded me 
11:37:29 <EvanR> i'm sure there's many ways to abuse type classes we haven't even dreamed of yet
11:37:46 <wildtrees> I am debating if I should finish the paper or code more 
11:41:20 <EvanR> a while back i noted a way to abstract your monad code another way
11:41:43 <EvanR> define the API in a record that is polymorphic in the monad m
11:42:29 <EvanR> then write all code against this record type and it automatically works in any monad as long as you provide the implementations
11:43:00 <EvanR> i guess it's the direct dictionary version of final tagless
11:43:25 <EvanR> this idea due to Cale
11:51:39 <EvanR> wildtrees: data System m = System { putStrLn :: String -> m (); getLine :: m String }   then type App m = Reader (System m)  and some helpers to avoid manually mentioning the dictionary all the time
11:52:08 <EvanR> myProgram :: Monad m => App m ()
11:52:17 <wildtrees> isn't that like just doing typeclasses by hand? 
11:52:31 <MarcelineVQ> mhmm, but now you don't need newtypes
11:53:19 <MarcelineVQ> Assuming you're making a record that replaces something that needed them in the first place :>
11:53:27 <wildtrees> with final tagless I have Gets m stringy and Puts m stringy, that supply maybeGets = maybeGetLine and puts = putStrLn roughly , and I can use a constraint like this (Gets m stringy,Puts m stringy) => (stringy -> stringy) -> m () 
11:53:38 <wildtrees> so the typeclasses are kinda compositional 
11:54:21 <wildtrees> the (stringy -> stringy) is a selector I use internally, because i have polymorphic packing and unpacking to work with Data.Text or String
11:54:38 <EvanR> i saw that final tagless lets you add on features piecemeal, even if you already wrote a bunch of code against version 1, compiled binaries and shipped them, never to be able to recompile them
11:54:53 <EvanR> and now want to add new op codes
11:55:14 <wildtrees> i think you need to recompile something for it work in haskell 
11:55:18 <EvanR> that's pretty interesting and the record can't really do that
11:55:34 <EvanR> what i mean is avoids recompling all the modules
11:55:54 <wildtrees> I basically have a piecemeal constructed, heavily restricted "IO" monad that I can interpret however I want 
11:55:56 <wildtrees> ahh 
11:56:46 <EvanR> are you making the constraints managable with constraint synonyms or
11:59:09 <wildtrees> I haven't worked with any of the new constraint machinery at all, ever
11:59:35 <wildtrees> here is the code https://paste.ofcode.org/N7fSiBS46aceLLeLqvFaT5 some of it is a bit messy a line here or there and I dont use the uncons1 or uncons2 functions I wrote at all 
12:00:11 <wildtrees> also I know the debugging state instance, its output could be quadratic cause I append onto the end of a list 
12:00:41 <wildtrees> main and test are the main functionality, everything else is mostly just a framework for those two functions 
12:01:26 <wildtrees> EvanR, I like paste.ofcode.org btw seems nice since lpaste has passed onto to the great server in the sky 
12:01:49 <EvanR> i've been using that and 0paste lately
12:01:52 <wildtrees> I also dont use the MonadWriter anymore, 
12:01:57 <EvanR> can't say they are proper replacements though
12:02:06 <wildtrees> what are they lacking?
12:02:18 <wildtrees> if you are a commandline person ix.io is kinda nice, not much for formatting though 
12:02:18 <EvanR> also termbin is probably good but i haven't used it
12:02:37 <wildtrees> is termbin a pastebin from the command line like ix.io?
12:02:40 <EvanR> netcat command to paste and you get raw text served back
12:02:58 <EvanR> as god intended
12:03:00 <wildtrees> yea ix.io uses curl or something 
12:03:53 <wildtrees> brb
12:04:34 <EvanR> lpaste.net has a login screen
12:09:37 * wildtrees returns 
12:12:14 * hackage servant-purescript 0.9.0.4 - Generate PureScript accessor functions for you servant API  https://hackage.haskell.org/package/servant-purescript-0.9.0.4 (eskimo)
12:22:36 <dminuoso> Oh my. I stepped into a blackhole and cant seem to get out.
12:22:38 <dminuoso> within :: MonadPlus m => LensLike' (Indexing (Bazaar' (Indexed Int) a)) s a -> (h :> (s :@ j)) -> m ((h :> (s :@ j)) :>> a) 
12:38:14 <paulasdf> does anyone have opinions on the mtl library?
12:39:00 <[exa]> paulasdf: what kind of opinion btw? (mine: "it's useful" )
12:40:01 <jle`> paulasdf: it's useful as long as you remember it's not a monad transformer library :)
12:40:44 <paulasdf> i heard it's sort of a divisive library, but I'm not sure why  
12:41:11 <jle`> i don't think it's super divisive, but it's the main 'effects system' in common usage
12:41:20 <jle`> polymorphic effects system
12:41:34 <jle`> there are some issues with it i think and so some people have tried the newer fancier ones
12:41:41 <jle`> but it's good enough for almost every application
12:42:06 <jle`> we don't know if it's the 'best', but it's good enough definitely :)
12:42:50 <jle`> there are some faults but none of it make it unusable or unsuitable for most applications
12:43:24 <jle`> maybe it worked so well that it stifled development on alternative polymorphic effects systems
12:43:57 <paulasdf> what are the newer fancier ones?
12:53:25 <yushyin> @hackage polysemy
12:53:25 <lambdabot> http://hackage.haskell.org/package/polysemy
12:54:08 <Zemyla> There should be in base something like data Box a = Box a, which would basically be a boxed version of Identity.
12:54:42 <Zemyla> It'd be for controlling how much stuff is evaluated and so on.
12:56:54 <dmwit> Hackage OneTuple
12:57:02 <dmwit> ?hackage OneTuple
12:57:02 <lambdabot> http://hackage.haskell.org/package/OneTuple
12:57:18 <dminuoso> paulasdf: There's also http://hackage.haskell.org/package/effect-handlers
12:58:30 <dminuoso> This implementation of the effect monad uses Free over a Union of functors and then applies Codensity over it for asymptotic improvements of ill-associated binds.
12:58:37 <dminuoso> It goes without saying.
12:58:43 <EvanR> what if everyone started depending on OneTuple, everyone also started auto upgrading versions of dependencies, and then someone broke the OneTuple package
12:59:49 <EvanR> nevermind, preposterous :)
13:00:49 <MarcelineVQ> You should call it LeftTuple if you want to be on the nose
13:03:50 <boblehest> Hey, I have this applicative parser type defined like so: type Parser a = StateT a Maybe
13:04:05 <boblehest> Actually, let me just create a simple test case
13:05:36 <boblehest> http://ix.io/1ZDm
13:05:54 <boblehest> I'm curious why    (x:xs) <- get    doesn't fail when the state has an empty array
13:06:09 <boblehest> well, I guess it kind of does fail since it returns `Nothing`, but I expected it to raise an exception
13:06:38 <boblehest> (since `foo` returns `Nothing`, to be precise)
13:07:05 <Cale> @undo do (x:xs) <- get; return x
13:07:05 <lambdabot> get >>= \ a -> case a of { (x : xs) -> return x; _ -> fail ""}
13:07:11 <Cale> boblehest: ^^ that's why
13:08:09 <koala_man> huh, how does that work? 
13:08:39 <boblehest> Cale: Oh, cool. Thanks :)  So basically some MonadFail magic?
13:09:08 <Cale> yeah
13:09:10 <boblehest> Now I'm curious why MonadFail is pulled into this
13:09:38 <Ariakenom> is it possible to remove all instances of MonadFail?
13:10:48 <boblehest> (I'm thinking maybe because I'm doing `lift Nothing`, which I just ended up writing to make my code compile/parse)
13:10:49 <Cale> You can't remove an instance which exists.
13:11:04 <evelyn> TIL about that OneTuple thing. But it looks pretty much impossible to break such a package ;)
13:11:12 <Ariakenom> that seems like it could be useful. or am i crazy
13:11:15 <Cale> boblehest: Well, the MonadFail for StateT s m uses the MonadFail for m
13:11:24 <Cale> Ariakenom: why?
13:11:59 <Ariakenom> ah I guess it would destroy other code
13:12:52 <Ariakenom> Cale: in this case maybe you dont want anything with a "fail". I suppose there is a flag for not inserting them implicitly
13:13:17 <Ariakenom> removing eq ord for float is another case
13:13:37 <Ariakenom> but probably that will break the world so its not really doable
13:14:22 <boblehest> Oh: "MonadFail: When a value is bound in do-notation, the pattern on the left hand side of <- might not match. In this case, this class provides a function to recover."
13:15:01 <boblehest> I haven't read the docs for MonadFail before. I assumed it had a much more general purpose
13:15:14 * hackage inline-c-cpp 0.3.0.3 - Lets you embed C++ code into Haskell.  https://hackage.haskell.org/package/inline-c-cpp-0.3.0.3 (FrancescoMazzoli)
13:27:03 <boblehest> (Also, I just noticed that I'm not even using the Parser type I defined, which isn't even the correct type)
13:27:14 <boblehest> should be StateT [a] Maybe a
13:28:44 * hackage servant-subscriber 0.6.0.3 - When REST is not enough ...  https://hackage.haskell.org/package/servant-subscriber-0.6.0.3 (eskimo)
13:31:02 <boblehest> Heh, I just quickly translated a grammar into Haskell code, and I ended up with this parser: parseFunApp = (FunApp <$> parseFunApp) <|> parseExpr
13:32:17 <boblehest> and thought I had had a huge problem (since the parser loops forever)
13:33:36 <boblehest> I have no idea what I'm doing, but my intuition told me to try folding the parser over `FunApp`, and it magically worked as intended
13:43:44 * hackage Win32 2.8.4.0 - A binding to Windows Win32 API.  https://hackage.haskell.org/package/Win32-2.8.4.0 (TamarChristina)
14:00:25 <dminuoso> koala_man: Patterns in do-notation call fail (MonadFail) when the pattern does not match.
14:05:21 <MarcelineVQ> I'm having a little trouble reconciling a particular instance of Applicative vs an instance of Monad, I'm able to write Monad with just Functor but I'm stuck seeming to need Applicative for Applicative. If Monad only needs Functor so should Applicative right?
14:05:22 <MarcelineVQ> https://gist.github.com/MarcelineVQ/61c0bb5e6ea439b7e443298e45a3a1fb
14:06:44 * hackage text-builder 0.6.6 - An efficient strict text builder  https://hackage.haskell.org/package/text-builder-0.6.6 (NikitaVolkov)
14:06:50 <matheus23> Hi! I'm using polysemy and I'm getting a (I think) weird type error: Could not deduce: r ~ '[Sized]
14:06:52 <matheus23>       from the context: Members '[Sized] r
14:07:45 <dminuoso> MarcelineVQ: Right. I mean you can mechanically do the transformation by remembering that (<*>) = ap
14:07:49 <dminuoso> @src ap
14:07:49 <lambdabot> ap = liftM2 id
14:07:55 <dminuoso> Heh.
14:08:26 <lyxia> matheus23: what is the code where the error comes from
14:09:40 <matheus23> lyxia:https://pastebin.com/raw/kYFgRGDX
14:09:56 <dmwit> MarcelineVQ: One thing that looks different to me: your (>>=) is recursive, but your (<*>) isn't.
14:11:11 <dmwit> MarcelineVQ: I suspect if you just resume (say) f, then you will find that the thing you naturally want to do is to use fmap @s with a recursive call to (<*>) and fa, rather than resume fa.
14:11:32 <MarcelineVQ> I'll check those leads in a little bit, thanks for answering so quickly you two
14:12:03 <matheus23> lyxia:I think I get it. It is possible that my widgetDef has more effects than only Sized. So I need to not only know that Sized is one of them
14:12:24 <lyxia> yes that's it
14:12:39 <matheus23> It's late today. I think I should just stop coding atm. I'll continue tomorrow. Thank you anyway, lyxia  :)
14:15:33 <wildtrees> can I polymorphise or overload the lambda bindings in do notaion from x <- someAction ? 
14:16:51 <jle`> wildtrees: what are you proposing to instantiate it as?
14:18:01 <wildtrees> was wondering if I could write final tagless code that uses do notation and have it run as a regular haskell program, and overload it so I could spit out javascript or ruby from the haskell code 
14:18:19 <dminuoso> Mmmm. Is this possibly a GHC bug? https://gist.github.com/dminuoso/33b85e93a1431eae3590b5fcfcebb077
14:18:24 <wildtrees> I think to do that I would need to overload most of the language constructs I am using 
14:18:48 <jle`> wildtrees: you might be able to use RebindableSyntax, but as for getting things like the name "x", that's out of scope of rebindable syntax
14:19:07 <dminuoso> Ohh nevermind!
14:19:17 <dminuoso> I somehow thought `:type +v` would always print explicit binders.
14:19:27 <jle`> RebindableSyntax would let you use a different function other that (>>=)
14:19:31 <dminuoso> But good to know to finally figure out the meaning of {} in `forall {a}. ...`
14:19:50 <jle`> but i believe there are some haskell libraries that that give you tools to write code in a way that can be 'reified' like that
14:43:10 <dminuoso> Wow, the situation with :type is quite tricky it seems
14:43:17 <dminuoso> % :set -fprint-explicit-foralls
14:43:17 <yahb> dminuoso: 
14:43:21 <dminuoso> % :type length
14:43:21 <yahb> dminuoso: forall {t :: * -> *} {a}. Foldable t => t a -> Int
14:43:36 <dminuoso> % :type (length @[])
14:43:37 <yahb> dminuoso: forall {a}. [a] -> Int
14:43:59 <dminuoso> % :type +v length
14:43:59 <yahb> dminuoso: forall (t :: * -> *) a. Foldable t => t a -> Int
14:46:37 <nshepperd2> Huh, i thought {} meant the type argument was not visible
14:48:03 <dminuoso> nshepperd2: Indeed! https://gitlab.haskell.org//ghc/ghc/issues/11376
14:49:37 <dminuoso> Essentially this is a similar artifact of it:
14:49:51 <dminuoso> % f = length; f @[] [1,2,3,4]
14:49:52 <yahb> dminuoso: ; <interactive>:34:13: error:; Parse error: module header, import declaration; or top-level declaration expected.
14:49:58 <dminuoso> % let f = length in f @[] [1,2,3,4]
14:49:59 <yahb> dminuoso: ; <interactive>:35:19: error:; * Cannot apply expression of type `t0 a0 -> Int'; to a visible type argument `[]'; * In the expression: f @[] [1, 2, 3, 4]; In the expression: let f = length in f @[] [1, 2, 3, ....]; In an equation for `it': it = let f = length in f @[] [1, 2, ....]
14:51:06 <nshepperd2> Heh. I, too, use -XTypeInType as -XKitchenSink
14:53:55 <jle`> dminuoso: yeah, that's the only way that makes sense i think
14:54:05 <jle`> otherwise "who knows" the order of type variables are declared for f
14:54:23 <jle`> it could take the a first then the t, or the t first then the a
14:55:02 <dminuoso> jle`: Its not quite related to that though.
14:55:31 <jle`> isn't it? the reason is because f has no given type sigature
14:55:35 <dminuoso> jle`: It's rather because :type gives you the type an identifier would have inferred, if the supplied expression was given to it.
14:55:56 <dminuoso> jle`: And then you have instantiation and regeneralization going on.
14:56:02 <dminuoso> At that point the type variables are no longer visible
14:56:25 <jle`> i interpret this as, length has at ype. but for f = length, f has no declared type
14:56:36 <jle`> and you can only apply types to things that have a declared type signature
14:57:06 <dminuoso> jle`: Oh I see, sure.
14:57:24 <jle`> so as soon as you bind f = length, you are no longer applying @[] @Int to length
14:57:27 <jle`> you're applying it to f
14:57:39 <jle`> but f has no type signature so you cannot apply anything to it
14:58:18 <dminuoso> jle`: Oh yeah absolutely, I wasn't even thinking about the motivation behind it.
14:58:27 <jle`> f shields the type applicatiosn you give it from length, and it can even rearrange it
14:58:40 <jle`> you could have f :: forall t a. Foldable t => t a -> Int, or f :: forall a t. Foldable t => t a -> Int
14:59:06 <dminuoso> Its kind of odd I havent run into this before
14:59:27 <dminuoso> But I guess I type annotate everything.
14:59:46 <jle`> yeah, it feels like it should come up more than it does
15:00:21 <jle`> but, think of the main way we usually use type applications -- for typeclass methods
15:00:28 <jle`> and in that case the type declaration is always there
15:01:04 <dminuoso> Speaking of which... I kind of want do-applications in the sense of `do @IO { ... }`
15:01:17 <jle`> and also top level declarations like genericLength, usually have sigs
15:01:23 <dminuoso> (Which would desugar into @IO applications onto (>>) and (>>=))
15:01:26 <jle`> dminuoso: yeah...that would definitely be very helpful i think
15:01:36 <jle`> it would definitely sort out a lot of bugs
15:01:45 <jle`> that happen from using the 'wrong monad' in a do line
15:01:51 <dminuoso> Indeed. :)
15:01:55 <jle`> and the type error is sometimes unable to know what 'monad' you "wanted"
15:02:15 <jle`> maybe we just need type annotation sections
15:02:19 <jle`> (:: IO ()) $ do ...
15:02:37 <dminuoso> Type annotation sections?
15:03:01 <jle`> (:: Int) x
15:03:04 <jle`>  ==> x :: Int
15:03:04 <dminuoso> Is that a thing in some other languages?
15:03:25 <jle`> it was more of a joke :)
15:03:39 <jle`> but it isn't too unheard of in languages like idris with 'first class' type annotations
15:03:40 <dminuoso> In here, you never know.
15:03:53 <jle`> ah, you can do it in haskell too
15:04:05 <jle`> > id @Double $ read "1.2"
15:04:08 <lambdabot>  error:
15:04:08 <lambdabot>      Pattern syntax in expression context: id@Double
15:04:08 <lambdabot>      Did you mean to enable TypeApplications?
15:04:14 <jle`> % id @Double $ read "1.2"
15:04:15 <yahb> jle`: 1.2
15:04:24 <jle`> so you could have `id @(IO ()) $ do ...`
15:04:36 <jle`> or id @(IO _) $ do ...
15:08:54 <YakMan> Hi! I'm working on the learn you a Haskell course and I have a very basic question. I'm not sure how this function works.
15:09:36 <YakMan> length' xs = sum [1 | _ <- xs]
15:10:14 <YakMan> I don't understand how the 1 is replacing every element in the list xs.
15:10:59 <Athas> It's list comprehension notation.  It is equivalent to 'sum (map (\x -> 1) xs)'.  Is that more understandable?
15:11:23 <Athas> Note that in the anonymous function (\x -> 1), the parameter 'x' is not used at all.  Hence the function just always returns 1.
15:11:48 <lavalike> @undo \xs -> [1 | _ <- xs]
15:11:48 <lambdabot> \ xs -> concatMap (\ _ -> [1]) xs
15:12:21 <lavalike> @pl \xs -> concatMap (\_ -> [1]) xs
15:12:22 <lambdabot> (>> [1])
15:13:25 <jakalx> YakMan: you could evaluate [1 | _ <-  xs] and see that it generates a list of 1s
15:14:53 <jakalx> It maps every element of xs to 1
15:18:44 <zeta_0> hello guys, i am currently using `haskell-ide-engine` in emacs, the main problem that i am having with it, is that it's very slow, why is that ?
15:23:14 * hackage bitvec 1.0.2.0 - Space-efficient bit vectors  https://hackage.haskell.org/package/bitvec-1.0.2.0 (Bodigrim)
15:23:37 <MarcelineVQ> dminuoso, dmwit: oh but it's not recursive, that >>= belongs to the m constraint
15:24:18 <MarcelineVQ> or, wait.. lemme check that, 'cause it feels wrong now that I've said it
15:24:34 <MarcelineVQ> No that has to be for Coroutine, nvm, I'll keep working on it
15:25:12 <MarcelineVQ> only the first >>= is for the 'm', so it is recursive
15:29:51 <zeta_0> no one is responding in #haskell-ide-engine ?
15:37:14 * hackage functor-products 0.1.1.0 - General functor products for various Foldable instances  https://hackage.haskell.org/package/functor-products-0.1.1.0 (jle)
15:37:58 * ski never heard of that channel before
15:38:16 * ski idly wonders how long zeta_0 waited
15:43:29 <zeta_0> ski: i've been waiting for about 20 minutes and no one has responded yet
15:44:06 <EvanR> hopefully they have some nice "on hold" music playing in there
15:46:33 <zeta_0> EvanR: i guess i'll just try out the emacs debugging tools to try and see what is slowing haskell-ide-engine down
15:57:09 <ski> @tell zeta_0 (re #haskell-ide-engine) "i've been waiting for about 20 minutes and no one has responded yet" -- hm, twenty minutes isn't a long time, on a slow IRC channel. try waiting at least two hours, or two days ?
15:57:09 <lambdabot> Consider it noted.
15:57:44 * hackage context-free-art 0.2.0.2 - Generate art from context-free grammars  https://hackage.haskell.org/package/context-free-art-0.2.0.2 (414owen)
16:07:20 <jle`> just tweeted this, but does anyone have any ideas of how to give this a nicer error message (library design)
16:07:30 <jle`> func :: F a b -> F b c -> Z
16:07:43 <jle`> sometimes a common bug would be providing "F a X" and "F Y c"
16:07:52 <jle`> normally ghc says "cannot match X and Y"
16:08:11 <jle`> but i want ot catch this common error for X and Y specifically and give the user a better error message explaining why they might have thought using X and Y was ok and why it's not
16:08:59 <jle`> one way i can imagine is donig something like func :: Valid b b' => F a b -> F b' c -> Z, and having instance TypeError ... => Valid X Y, but i feel like this makes the type signature less clear and type inference worse
16:10:23 <cryptomonad> Hi all. Can I have an extended interface without methods? e.g. interface (Ord a, Show a, Read a) => Foo a? The compiler eats it but weird things happen when I try to define an implementation.
16:11:08 <jle`> cryptomonad: hm, do you mean typeclass? or instance?
16:11:26 <erisco> classes can be without members
16:12:32 <cryptomonad> jle`: I'm not sure I understand the question.
16:12:47 <jle`> cryptomonad: 'interface' isn't a concept in haskell
16:12:53 <jle`> so i'm not sure if you really are referring to some haskell concept
16:12:58 <jle`> like typeclasses or typeclass instances
16:12:59 <cryptomonad> lol. I thought this was #idris
16:13:04 <cryptomonad> sorry :/
16:13:10 <jle`> ah, it happens :)
16:25:59 <aviaviavi> Hi, anyone familiar with Codec.Compression.Lzma? I'm getting `Codec.Compression.Lzma.decompressWith: decoding error LzmaRetFormatError` on a `.xz` compressed file that otherwise opens fine, and I'm not sure how to troubleshoot the issue
16:31:03 <Axman6> aviaviavi: can you set decompressTellUnsupportedCheck to False?
16:31:11 <Axman6> https://hackage.haskell.org/package/lzma-0.0.0.3/docs/Codec-Compression-Lzma.html#v:decompressTellUnsupportedCheck
16:31:41 <Axman6> hmm, sorry that's probably the wrong thing
16:32:09 <aviaviavi> ah yeah that does seem to return a different error than the one i'm getting
16:32:20 <aviaviavi> but i'll try anything at this point :)  
16:32:36 <Axman6> unset ALL THE THINGS \o/
16:33:47 <aviaviavi> ah looks like False is the default there anyway
16:34:04 <aviaviavi> appreciate you looking though!
16:38:33 <dmj`> haddocks report newtypes as 'data'
16:53:22 <Squarism> I know it sounds semi wierd. But I realize Id need a serializable addresses to elements in arbitrary datastructure. Like getter lenses that can be written in text, read by something that can use it to query a datastructure for the component?
16:53:54 <Squarism> Anyone know if theres such a thing?
17:22:58 <dmwit> Well it's certainly not possible for arbitrary data structures.
17:23:15 <dmwit> But there are various query languages for, say, JSON.
17:23:23 <Squarism> dmwit, yeah I guess thats wishing to much
17:23:24 <dmwit> Or XML.
17:23:38 <sicklorkin> aviaviavi: I seem to recall I had some issues w/this before and it was due to the params I used to compress and the opts I used to decompress.. 
17:24:14 * hackage text-builder 0.6.6.1 - An efficient strict text builder  https://hackage.haskell.org/package/text-builder-0.6.6.1 (NikitaVolkov)
17:24:55 <sicklorkin> Squarism: winery does soemthing like this
17:25:06 <aviaviavi> sicklorkin Got it. Unfortunately I'm trying to decompress something that's hosted online and not compressed by me. I'll keep playing with the params then, maybe I'll stumble on the right thing. 
17:25:08 <aviaviavi> Thanks!
17:25:14 <Squarism> ok, ill check that out
17:27:17 <dmwit> Squarism: see also xquery, xpath, jsonpath, SQL
17:28:51 <sicklorkin> aviaviavi: are there any tools in the lzma package you can use to test with? e.g. xz-cat
17:30:33 <aviaviavi> Interesting, wasn't familiar with xzcat. It's also telling me it doesn't recognize it, which definitely gives me something to work with now
17:31:12 <sicklorkin> aviaviavi: file foo.xz help?
17:31:40 <aviaviavi> Aha! `tmp-scarf-package-install.tar.xz: bzip2 compressed data, block size = 900k`
17:33:07 <aviaviavi> Mystery solved then, very much appreciated sicklorkin. (Also great to know about file!) 
17:33:43 <aviaviavi> Didn't expect to be learning about two new unix utils by coming to #haskell :)  
17:46:14 * hackage papillon 0.1.1.0 - packrat parser  https://hackage.haskell.org/package/papillon-0.1.1.0 (YoshikuniJujo)
18:07:22 <OmegaDoug> I need to continually read from one channel, aggregate the results according to a timestamp, write the result to a second channel, and repeat with a new time stamp
18:07:35 <OmegaDoug> I'm wondering what an idomatic way to accomplish this would be
18:07:39 <OmegaDoug> https://gist.github.com/DouglasBrunner/7dcb498973bc8a58d1ef7ee20d66fa63
18:07:49 <OmegaDoug> That's the type signature I'm working with if it helps
18:24:44 * hackage papillon 0.1.1.1 - packrat parser  https://hackage.haskell.org/package/papillon-0.1.1.1 (YoshikuniJujo)
18:33:52 <jusss> if there're [1,2] and [1,2,3], how to get [3]?
18:34:09 <jusss> get the diffrent elements
18:34:39 <jusss> with reduce?
18:36:20 <Axman6> > [1,2] \\ [1,2,3]
18:36:22 <lambdabot>  []
18:36:35 <Axman6> > [1,2] // [1,2,3]
18:36:37 <lambdabot>  error:
18:36:37 <lambdabot>      • Couldn't match expected type ‘Array i e’
18:36:37 <lambdabot>                    with actual type ‘[Integer]’
18:36:39 <Axman6> hmm
18:37:48 <jusss> Axman6: that would be a form like `fmap compareFunc listA listB' ?
18:38:10 <jusss> :t fmap
18:38:12 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:40:05 <Axman6> @hoogle Eq a => [a] -> [a] -> [a]
18:40:05 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
18:40:05 <lambdabot> Data.List union :: Eq a => [a] -> [a] -> [a]
18:40:06 <lambdabot> Data.List intersect :: Eq a => [a] -> [a] -> [a]
18:40:11 <Axman6> :t difference
18:40:13 <lambdabot> error:
18:40:13 <lambdabot>     • Variable not in scope: difference
18:40:13 <lambdabot>     • Perhaps you meant one of these:
18:40:17 <Axman6> hmmmmm
19:02:25 <sarahzrf> > [1, 2, 3] \\ [1, 2]
19:02:27 <lambdabot>  [3]
19:05:52 <jusss> sarahzrf: what's the name of \\ ? how you pronounce it?
19:07:31 <sarahzrf> dunno
19:08:29 <jusss>  > [2,3] \\ [1,2]
19:08:48 <jusss> > [2,3] \\ [1,2]
19:08:49 <lambdabot>  [3]
19:10:39 <jusss> > [2] \\ []
19:10:41 <lambdabot>  [2]
19:45:02 <texasmynsted> Not sure if this is an hlint issue, or a floaskell setting I need to change, or something else.
19:45:04 <texasmynsted> https://imgur.com/a/OeKTn5V
19:45:26 <texasmynsted> For some reason I am getting complaints based on white space
19:45:36 <dsal> This eventlog sucks.  Doesn't have anything I need.
19:46:28 <texasmynsted> any idea?
19:48:44 <jle`> jusss: difference
19:52:29 <dibblego> texasmynsted: which module name?
19:54:07 <dibblego> texasmynsted: are you using the online ide https://gitpod.io/#https://github.com/data61/fp-course ?
19:54:11 <texasmynsted> It is complaining about anything with white space added, such as "NoImplicitPrelude", "Control.Monad", "Course.Core", and "Prelude". See the image.
19:54:22 <texasmynsted> no
19:54:38 <dibblego> texasmynsted: are you in the base directory, containing the .ghci file?
19:54:42 <texasmynsted> Just using a file from fp-course as an example
19:55:07 <dibblego> I only see "Couldn't guess that module name"
19:55:52 <texasmynsted> right
19:55:53 <dibblego> what happens if you type ghci in a terminal?
19:55:53 <texasmynsted> It says that for all the lines with the vertical bar a the left-most part of the editor window
19:56:05 <dibblego> can it find ghc at all?
19:56:09 <dibblego> Prelude certainly exists
19:56:28 <texasmynsted> ghci is fine with it
19:56:36 <dibblego> an editor config issue?
19:56:38 <texasmynsted> They all exist
19:56:57 <texasmynsted> The code in the file is correct.
19:57:06 <dibblego> yes but why is Prelude not found?
19:57:41 <texasmynsted> The error only shows when the file gets re-formatted via floskell
19:57:47 <texasmynsted> (automagically)
19:58:10 <dibblego> I don't know what that is, but why would that screw up whatever tool you are using?
19:58:53 <texasmynsted> Heh
19:58:56 <texasmynsted> I guess the tool has bugs
19:59:07 <dibblego> well, if ghci works … 
20:00:07 <maerwald> oh, gitpod looks interesting
20:00:46 <texasmynsted> yes. Okay. It looks like I need to track down why HIE in vscode is showing bs warnings
20:00:49 <maerwald> but it fails :o
20:01:26 <texasmynsted> When I run hlint manually (one source of warnings), hlint correctly does not warn me.
20:01:55 <texasmynsted> and actually provides useful suggestins
20:01:58 <texasmynsted> suggestions
20:02:20 <jusss> I'd like to write a function that take the value from Maybe, like `takeIt = \(Just a) -> a'  `takeIt = \(Nothing) -> Nothing'   how to do that?
20:02:39 <jusss> takeIt :: Maybe a -> a
20:02:46 <jusss> but Nothing don't have a, 
20:02:47 <dibblego> there is no such function
20:02:53 <dibblego> the function you wrote does not have this type
20:03:01 <dibblego> you wrote :: Maybe (Maybe a) -> Maybe a
20:03:05 <jusss> I know, I don't know how to write that one
20:03:18 <dibblego> which one?
20:04:13 <dibblego> @type \m -> case m of Nothing -> Nothing; Just a -> a
20:04:14 <lambdabot> Maybe (Maybe a) -> Maybe a
20:04:17 <jusss> dibblego: takeIt take a (Just a) return a, take Nothing return Nothing, it's result polymorphic
20:04:30 <dibblego> there it is ^^
20:04:40 <jusss> maybe I should return Either, then use either to take it out
20:05:19 <dibblego> you can also have :: a -> Maybe a -> a
20:05:34 * texasmynsted facepalm
20:05:56 <texasmynsted> Okay I see the issue. (Me)
20:06:06 <texasmynsted> snap
20:06:18 <jusss> dibblego: but a is from Maybe a, how I suppose to know a before the function run?
20:06:31 <texasmynsted> Sorry to bother you all. Heh
20:06:42 <texasmynsted> It is working _correctly_
20:06:46 <dibblego> jusss: not all (Maybe x) have an x in it
20:07:04 <dibblego> "I have 0 or 1 things, return me exactly 1 thing"
20:07:17 <dibblego> this is not a possible task
20:09:33 <jusss> dibblego: https://paste.ubuntu.com/p/h9b5TtJBsf/
20:10:21 <dibblego> "I have (0 or 1 (0 or 1)), return me (0 or 1) things"
20:10:27 <dibblego> this is possible, and the function you wrote
20:10:44 <dibblego> the expression Just 3 does not satisfy this type
20:10:48 <dibblego> :type f
20:11:12 <jusss> dibblego: ok, 
20:12:05 <jusss> takeIt :: Maybe String -> String;  takeIt = \x -> case x of Just a -> a; Nothing -> "Nothing"
20:12:08 <jusss> this should work
20:12:14 <dibblego> yes this is possible
20:12:31 <dibblego> "I have 0 or 1 strings, return me exactly 1 string"
20:13:05 <dsal> :t fromMaybe
20:13:06 <lambdabot> a -> Maybe a -> a
20:13:26 <jusss> what's the definition of fromMaybe?
20:13:32 <maerwald> dibblego: how did you make gitpod work?
20:13:45 <dibblego> maerwald: I didn't, ask ghuntley in #qfpl
20:13:47 <jusss> takeIt :: Maybe a -> Either a (Maybe a)
20:14:00 <dsal> fromMaybe is pretty straightforward to write.
20:14:09 <dibblego> fromMaybe, "I have exactly 1 thing and (0 or 1) things, and I will return exactly 1 thing"
20:14:19 <dibblego> there are two possible ways to satsify this
20:14:29 <jusss> either :: Either a (Maybe a) -> (Maybe a -> a) -> (a -> a) 
20:14:31 <dibblego> one way is to always return the first thing
20:14:35 <dsal> :t const
20:14:37 <lambdabot> a -> b -> a
20:14:38 <dibblego> it does the other one
20:19:48 <maerwald> seems to have no syntax highlighting even :(
20:19:58 <dibblego> ghuntley: ^^
20:21:28 <maerwald> ghcup works inside the container though :P
20:21:41 <maerwald> hope they have size limits...
20:22:06 <maerwald> and I'm not blowing up someones infrastructure bill
20:26:12 <jusss> takeIt :: Maybe Text -> Text
20:26:23 <jusss> takeIt = \(Just a) -> a
20:26:33 <jusss> takeIt Nothing = pack "Nothing"
20:26:52 <jusss> why there's Multiple declarations of 'takeIt' error?
20:27:08 <dibblego> takeIt (Just a) = a
20:27:42 <jusss> dibblego: but takeIt = \(Just a) -> a is not equal to takeIt (Just a) = a?
20:27:53 <dibblego> they are two different syntaxes
20:27:57 <dibblego> they do the same thing
20:28:07 <jusss> dibblego: then why ghc report this error?
20:28:26 <dibblego> because it is not valid syntax
20:28:31 <dibblego> actually, it is
20:28:37 <dibblego> but that is a coincidence
20:28:49 <jusss> dibblego: using two syntax to define a function is not valid?
20:29:17 <dibblego> you did not use case/of in the first one, you used \ on the left of =, and so the function is fully defined
20:35:44 * hackage i3ipc 0.1.0.1 - A type-safe wrapper around i3's IPC  https://hackage.haskell.org/package/i3ipc-0.1.0.1 (leshow)
20:36:11 <jusss> dibblego: you mean using lambda to define a function, it won't be ablt to use patter-macthing to expand to define it?
20:36:36 <jusss> sorry, my English is not good, I don't know how to express it properly
20:37:10 <dibblego> if you do, you then use case/of to pattern-match
20:37:29 <jusss> dibblego: ok
20:43:36 <jusss> why there's no ++ for Text?
20:44:18 <maerwald> :t (++)
20:44:19 <lambdabot> [a] -> [a] -> [a]
20:44:23 <maerwald> text is not a list
20:44:25 <dibblego> <>
20:44:47 <jusss> yeah, <>
20:50:14 * hackage readme-lhs 0.2.1 - See readme.md  https://hackage.haskell.org/package/readme-lhs-0.2.1 (tonyday567)
20:51:23 <sicklorkin> > [1] <> [2]
20:51:26 <lambdabot>  [1,2]
20:53:14 * hackage zasni-gerna 0.0.7.1 - lojban parser (zasni gerna)  https://hackage.haskell.org/package/zasni-gerna-0.0.7.1 (YoshikuniJujo)
20:57:14 * hackage readme-lhs 0.2.2 - See readme.md  https://hackage.haskell.org/package/readme-lhs-0.2.2 (tonyday567)
20:57:38 <jusss> > "a" <> "b"
20:57:40 <lambdabot>  "ab"
20:59:56 <jusss> how to pronouce <> ?
21:00:01 <jusss> semigroup?
21:00:37 <jusss> there're so many symbol in haskell, I don't know how to pronounce, 
21:01:48 <Welkin> mappend
21:02:20 <Welkin> :t mappend
21:02:22 <lambdabot> Monoid a => a -> a -> a
21:02:24 <Welkin> :t (<>)
21:02:26 <lambdabot> Semigroup a => a -> a -> a
21:02:32 <Welkin> :t (Data.Monoid.<>)
21:02:34 <lambdabot> Semigroup a => a -> a -> a
21:03:13 <Welkin> all of the symbols have names
21:03:19 <Welkin> >>= is bind, <*> is ap
21:03:37 <sicklorkin> > mempty <> [1]
21:03:39 <lambdabot>  [1]
21:03:39 <Welkin> $ is apply, >> is sequence
21:09:27 <jusss> Welkin: and -> ?
21:10:21 <c_wraith> syntax
21:10:44 * hackage perf-analysis 0.1.0.0 - analysis example using perf  https://hackage.haskell.org/package/perf-analysis-0.1.0.0 (tonyday567)
21:10:50 <jusss> c_wraith: we call -> as "syntax"?
21:10:57 <jusss> I mean pronounce
21:12:09 <Welkin> that one has several meanings
21:12:21 <Welkin> -> is called "to" in types
21:12:36 <Welkin> it is called "yields" in code (usually)
21:12:46 <Welkin> for functional dependencies in types, it means "depends on"
21:13:12 <Welkin> for both case expressions and lambdas it is pronounced "yields"
21:13:26 <Welkin> you can learn how many of these are pronounced by watching any talk by Simon Peyton Jones
21:16:41 <jusss> reverse is defined in Prelude, Data.List, Data.Text
21:16:50 <jusss> I want to use Data.Text.reverse
21:17:06 <jusss> `import Data.Text (reverse)' ?
21:17:22 <jusss> why haskell has so many same name functions...
21:35:17 <jle`> jusss: usually people do import qualified Data.Text as T 
21:35:21 <jle`> and then you can do T.reverse
21:37:56 <Welkin> jusss: because it keeps the API consistent regardless of which type/module you are using
21:38:04 <Welkin> it is a *huge* benefit of haskell
22:18:43 <jusss> what's the name 'green thread' in haskell?
22:19:04 <jusss> async/await Promise in js
22:19:29 <Axman6> they're threads which aren't OS threads
22:19:44 <Axman6> they're much more lightweight, much more like erlang processes
22:19:57 <Axman6> promise wishes it could be Haskell's threads
22:20:17 <jusss> I'd like to bridge IRC to telegram, there would be two socket connections, I'm afraid they will block the main thread
22:20:42 <Axman6> the fork a thread for data flowing in each direction
22:21:00 <jusss> Axman6: with the name of?
22:21:11 <jusss> the function/module name?
22:22:08 <Mrbuck> hi one doubt in oop I understand myList = ['a','b']   first my list reference to a listObject and they reference to string objects like in this example...How it is done in fp/haskell ?
22:22:46 <jusss> Mrbuck: [String]
22:23:09 <jusss> [Char] or [[Char]]
22:23:17 <Axman6> jusss: use the async package - but also read Simon Marlow's book (it's free online); it explains everything you need to know about doing concurrency safely in Haskell
22:23:55 <jusss> Axman6: ok
22:24:10 <Mrbuck> jusss: ok I will explore more thank you
22:25:09 <Axman6> Mrbuck: myList would point to a value, in this casse, of type [Char] (if you meant for a list of strings, then it would be ["a","b"]). that value of type [Char] is either [] (also know as nil), or a (:) (also known as cons) which would point to a Char value and another [Char], and so on
22:25:35 <Axman6> so ['a','b'] is really 'a' : ('b' : [])
22:25:49 <Axman6> @where marlow
22:25:50 <lambdabot> I know nothing about marlow.
22:25:59 <Axman6> @where pcph
22:25:59 <lambdabot> "Parallel and Concurrent Programming in Haskell" by Simon Marlow in 2013 at <http://community.haskell.org/~simonmar/pcph/>,<http://chimera.labs.oreilly.com/books/1230000000929/>,<https://web.archive.
22:25:59 <lambdabot> org/web/20180117194842/http://chimera.labs.oreilly.com/books/1230000000929>,<https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/>
22:26:03 <Axman6> jusss: ^
22:26:40 <Mrbuck> Axman6:  thank you it is more clear now 
22:27:32 <jusss> Axman6: async is built-in ghc? I can't import Control.Concurrent.Async
22:30:49 <jusss> jle`: I wonder why `import qulified Data.Text (reverse)' won't work, ghc steel don't know it's Data.Text.reverse not Prelude or Data.IO
22:30:56 <jusss> Data.List
22:34:25 <int-e> jusss: https://hackage.haskell.org/package/async is an extra package
22:35:34 <jle`> jusss: you'd have to use Data.Text.reverse in that case
22:35:47 <jusss> int-e: ok
22:35:51 <jle`> jusss: import qualified My.Module (blah), would import blah as My.Module.blah
22:36:09 <jusss> jle`: yes, that' what I did
22:36:28 <jle`> Prelude also exports 'reverse'
22:36:57 <int-e> "won't work" -- what did you expect it to do?
22:37:32 <jusss> jle`: what about `import Data.Text.reverse as reverse'?
22:37:40 <jle`> that's not valid syntax
22:38:16 <jusss> import reverse as Data.Text.reverse , is?
22:38:28 <jle`> what happens when you try? :)
22:38:54 <jusss> int-e: expect ghc will take reverse from Data.Text, not others
22:38:55 <int-e> jusss: import Data.Text (reverse)  does make `reverse` available as a plain name in principle. But you have to hide the one from Prelude somehow. For example, `import Prelude hiding (reverse)` would do the trick. I'd not recommend it though!
22:39:31 <jusss> int-e: yeah, and I have to hide that reverse in Data.List
22:39:33 <Axman6> import qualified Data.Text; ... Data.Text.reverse should work
22:40:00 <int-e> The thing is (and this has already been said), Data.Text is designed to be imported qualified, and the standard way to avoid typing "Data.Text." all over again is to rename the module to something shorter, as in import qualified Data.Text as T.
22:40:04 <Axman6> the usual way to do this is import qualified Data.Text as T and use T.reverse; this is the style this is used most commonly
22:40:10 <jusss> can I remove that `qualified' ?
22:40:16 <jle`> jusss: note that module imports don't 'affect' the other -- having one doesn't affect the other. so importing reverse from Data.Text doesn't affect how you would import reverse from Prelude as well
22:40:23 <jle`> i think it would be more confusing if it did
22:40:28 <jle`> jusss: what happens when you try?
22:40:31 <int-e> If you remove the `qualified` you'll get extra unqualified imports that will clash with Prelude.
22:40:54 <int-e> Back to square one...
22:41:03 <jusss> import Data.Text as T,   T.reverse
22:41:20 <Axman6> if you do than then it imports everything in Data.Text
22:41:44 <Axman6> which means that if you use map, or null, or anything else from PRelude which is also in Data.Text you will keep getting these errors
22:41:47 <jusss> ok
22:41:53 <jle`> jusss: if you did import Data.Text as T, then you can use both 'T.pack' and 'pack', without qualification
22:41:57 <Axman6> just do import qualified Data.Text as T
22:42:24 <jle`> jusss: but yeah, all lines in a module import list are 'additive'
22:42:32 <Axman6> the full pattern people often use is import qualified Data.Text as T; import Data.Text (Text), so you don't need to write T.Text everywhere
22:42:33 <jle`> jusss: adding new lines to an import list only ever brings in new imported things
22:42:44 <jle`> jusss: it doesn't ever 'subtract' or negate other imports, if you add another import
22:44:01 <jle`> jusss: so if i write `import XXXXX` then later add `import YYYYY`, that second line will never 'remove' any imports that the import XXXXX brought in
22:44:06 <jle`> it can only add to the items in scope
22:44:07 <jle`> not subtract
22:44:42 <int-e> The only exception is that if you import Prelude explicitly, it will not be imported implicitly.
22:44:46 <jusss> jle`: ok, I will use `import qualified Data.Text as T' then T.reverse
22:44:51 <jle`> jusss: so if you write import Data.List, then later write import Data.Text (reverse), it won't 'subtract' any imports from Data.List
22:45:04 <jle`> no imports from Data.List will be "removed" from the namespace
22:45:08 <jle`> no matter what you import later
22:45:21 <jle`> there is no import you can add later that would "delete" Data.List (reverse) from the namespace
22:46:04 <sicklorkin> jusss: https://stackoverflow.com/questions/3175583/proper-way-to-import-things-already-defined-in-the-prelude-in-haskell
22:46:59 <Axman6> jle`: this is starting to feel like it will end like https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/#answer-1732454
22:48:52 <sicklorkin> Axman6: that's a great answer
22:49:18 <Axman6> it's one of the classics
22:50:16 <dminuoso> Axman6: Reminds me of https://www.reddit.com/r/haskell/comments/2cbgpz/flee_traveller_flee_or_you_will_be_corrupted_and/cjdu62e/
22:50:32 <bolver> i have some code at http://bit.ly/2pPkces
22:51:10 <bolver> foldr seems to run real slow when i have a conditional check on the accumulator
22:51:27 <bolver> i am not sure why -- appreciate any help
22:51:45 <Axman6> foldr doesn't have an "accumulator" per se
22:52:24 <dminuoso> bolver: You are not scrutinizing on the "accumulator", just on the current element.
22:52:26 <bolver> yeah, i know -- i mean `acc` in foldr (\x acc -> ..)
22:52:54 <dminuoso> bolver: We covered why your first function is slow yesterday.
22:52:56 <Axman6> this feels like it might be accidentally exponential complexity...
22:52:58 <dminuoso> bolver: Was there anything not clear?
22:53:15 <jusss> jle`: <jusss> import reverse as Data.Text.reverse , is? <jle`> what happens when you try? :) <interactive>:1:8: error: parse error on input ‘reverse’
22:53:20 <bolver> dminuoso: this is the same problem i asked yesterday ... i tested what you suggested, but the problem is not with the ++
22:53:28 <dminuoso> bolver: Also, what you are doing is very hard to optimize by the way.
22:53:54 <dminuoso> bolver: There's knowledge in the programmers head (namely that the condition is only satisfied on the first element, then never), but the compiler is unlikely to know this.
22:54:34 <bolver> dminuoso: please see the code ... i tested your suggestion ... i didn't see the problem is with ++
22:54:34 <Axman6> bolver: do you understand that for the first a to execute that case statement, every other a also has to finish executing that statement first?
22:55:07 <bolver> Axman6: i see ... i am sorry i didn't
22:55:27 <Axman6> to know whether acc is empty, the next iteration needs to have checked if its acc is empty before it can return 
22:55:57 <jusss> jle`: <jusss> can I remove that `qualified' ? <jle`> jusss: what happens when you try?                   import Data.Text as T; :t T.reverse T.reverse :: Text -> Text
22:55:57 <Axman6> you might find that changing it to: \x acc -> show x ++ case acc of ... improves things
22:55:59 <dminuoso> bolver: You do know that this acc is not necessary right?
22:56:19 <Axman6> since that show x and the list it builds doesn't depend on acc at all
22:57:08 <Axman6> meaninf that the previous call to this lambda can see if acc is empty as soon as show has returned its first constructor
22:57:40 <bolver> Axman6: i see ... i am trying to grasp what you are saying
22:58:25 <Axman6> in theory GHC could optimise thigns and bring out that show x ++ to outside the case statement, but it won't because it would change the semantics of the code (it maybe you knew what you were doing and wanted this exponential behaviour :)
22:58:48 <dminuoso> % t1 = foldr (\x -> shows x . (", " ++)) ""
22:58:48 <yahb> dminuoso: 
22:59:10 <dminuoso> % let t1 = foldr (\x -> shows x . (", " ++)) "" in take 1000 (t1 [1..])
22:59:10 <yahb> dminuoso: "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 10
22:59:21 <bolver> Axman6: thank you ... but i didn't know what i was doin, honestly ... i stumbled on it by accident
22:59:22 <dminuoso> bolver: You dont need to be talking about some accumulator! :-)
22:59:35 <Axman6> bolver: with what I'm saging, if you have foldrTest [1,2,3] you get (\x acc -> show x ++ case acc of "" -> ...) 1 (foldr ...)
22:59:56 <bolver> Axman6: i see
23:00:30 <bolver> dminuoso: thank you ... your idea didn't come to my mind, to be honest
23:00:56 <Axman6> bolver: can you see how you can't make any progress until acc is ""?
23:01:11 <Axman6> uh, when the input list is []
23:01:30 <bolver> Axman6: i am yet to understand that ... i have to look into it a bit more, i suppose
23:01:58 <dminuoso> bolver: foldr shouldn't be thought of as "a step-wise reduction with an acculumator around" but rather a structural transformation of a list. Do you recall the graphic I showed you yesterday?
23:02:10 <dminuoso> (Im talking about foldr on lists specifically, of course)
23:02:18 <bolver> Axman6: i am a bit slow ... bear with me, plaese
23:02:18 <Axman6> bolver: time to write out the execution of foldr step by step then
23:02:36 <bolver> dminuoso: yes, i do
23:02:55 <Axman6> foldr f "" [1,2,3] -> f a (f 2 (f 3 "")). now replace f with your lambda and see what's happened
23:02:58 <bolver> Axman6: yes, that's what i need to do ... thank you
23:03:06 <Axman6> uh, f 1*
23:03:25 <dminuoso> bolver: So the first argument foldr is what you replace the cons (:) with, and the second argument replaces the empty list (which is found at the end of every finite list)
23:03:53 <Axman6> for the outermost call to f, it can't proceed until it knows whether f 2 (f 3 "") is "" or not
23:03:53 <bolver> dminuoso: yes
23:04:06 <bolver> Axman6: correct
23:04:10 <Axman6> and f 2 can't proceed until it knows if f 3 "" is "" or not
23:04:20 <bolver> Axman6: yes
23:04:42 <bolver> Axman6: so the chain has to go all the way to the end of the list
23:04:59 <Axman6> f 3 "" has to evaluate its case statement before it can return anything, so it returns show 3 ++ acc (a.k.a "")
23:05:15 <Axman6> now f 2 can see if that's "" or not, and do what it needs to do
23:05:25 <Axman6> yep exactly... and where is the end of [1..]?
23:05:39 <Axman6> or [0..]?
23:05:58 <bolver> infinite
23:06:10 <Axman6> exactly, so it can never return anything
23:06:20 <feynhat> hello
23:06:26 <Axman6> but it will use a lot (read infinite) memory trying to do it, in case there is an end
23:06:47 <Axman6> foldr doesn't know it'll never reach a []
23:07:49 <bolver> Axman6: so in the case of foldrTest', it spits out instatntly -- why is that?
23:08:39 <bolver> Axman6: perhaps you've already explained it
23:08:48 <feynhat> I am trying to right a function to check if an integer is a perfect squre. This is what I have:  f n = (floor $ sqrt n)^2 == n.
23:09:24 <feynhat> But, when I call it, I get 'Ambiguous type variable a0 arising from a use of h...'
23:09:37 <Axman6> :t sqrt
23:09:38 <lambdabot> Floating a => a -> a
23:09:48 <dminuoso> feynhat: There is no `h` in that code.
23:09:52 <Axman6> Integers aren't instances of Floating
23:09:53 <dminuoso> feynhat: Can you share the actual code you have?
23:09:55 <feynhat> I meant f
23:10:07 <Axman6> bolver: because it's only looking at the head of the list, not acc
23:10:27 <bolver> Axman6: got it, thanks much
23:10:36 <feynhat> dminuoso, Actually the definition is h n = ...
23:11:16 <bolver> Axman6: very quick analysis from you ... i am very impresed
23:11:20 <bolver> impressed
23:11:27 <feynhat> h n = (floor $ sqrt n)^2 == n
23:11:48 <dminuoso> % f n = (floor $ sqrt n)^2 == n
23:11:48 <yahb> dminuoso: 
23:11:50 <dminuoso> % :t f
23:11:50 <yahb> dminuoso: forall {a}. (RealFrac a, Integral a, Floating a) => a -> Bool
23:11:57 <bolver> Axman6: thanks much for your time
23:12:08 <bolver> dminuoso: thanks a bunch
23:12:19 <__dingbat__> I am using send :: MonadIO m => Socket -> ByteString -> m ()   http://hackage.haskell.org/package/network-simple-0.4.5/docs/Network-Simple-TCP.html
23:12:27 <feynhat> Strangely though, when I enter (floor $ sqrt n)^2 == n for different value of n, I do get the expected result.
23:12:32 <feynhat> *in ghci
23:12:34 <__dingbat__> wondering if the 'send' is threadsafe?
23:12:57 <Axman6> __dingbat__: depends what you mean by threadsafe
23:13:39 <__dingbat__> Axman6: if two threads simultaneously attempt to send some bytes, will they remain exclusive or can it get mixed up?
23:14:04 <dminuoso> feynhat: It works for me. Are you sure that is the exact same code?
23:14:21 <Axman6> I would say that it would be best if you ensured it was threadsafe using something like an MVar
23:14:40 <Lears> % f 3
23:14:41 <yahb> Lears: ; <interactive>:48:1: error:; * Ambiguous type variable `a0' arising from a use of `f'; prevents the constraint `(RealFrac a0)' from being solved.; Probable fix: use a type annotation to specify what `a0' should be.; These potential instances exist:; instance forall a. HasResolution a => RealFrac (Fixed a) -- Defined in `Data.Fixed'; instance forall a. Integral a => 
23:14:42 <feynhat> Yes.
23:14:43 <__dingbat__> Axman6: I see. Thanks
23:14:49 <feynhat> dminuoso, Yes
23:14:51 <dminuoso> Lears: Oh. 
23:14:52 <Axman6> I imaging it's probably find, it should be able to send a whole buffer at once, but send followed by send might be interleaved
23:15:00 <Axman6> fine*
23:15:25 <dminuoso> feynhat: So the problem is that numeric literals are polymorphic
23:15:25 <feynhat> dminuoso, can you try calling it for some integers?
23:16:00 <__dingbat__> Axman6: so I will call the 'send' in a single thread, but will queue items to be sent via this thread into a threasafe TChan
23:16:35 <dminuoso> feynhat: A type variable essentially means "consumer must pick a type for this". GHC will do this via inference rules, essentially.
23:16:53 <feynhat> I see.
23:16:55 <dminuoso> feynhat: the type variable in `f` cannot be deduced from the return type.
23:17:09 <dminuoso> feynhat: so it'd have to be deduced by whatever you pass to it, but 5 itself is polymorphic too
23:19:25 <dminuoso> feynhat: Annotate the argument to f with the type you want to resolve the ambiguity
23:29:11 <dminuoso> Mmm, where can I find the definition of how deriving Ord works for multi parameter constructors in the Haskell report?
23:30:39 <opqdonut> > Derived comparisons always traverse constructors from left to right
23:30:42 <lambdabot>  error:
23:30:42 <lambdabot>      Data constructor not in scope:
23:30:42 <lambdabot>        Derived
23:30:44 <opqdonut> I think that's the key phrase
23:30:49 <opqdonut> gah, shouldn't quote with > here
23:31:17 <opqdonut> https://www.haskell.org/onlinereport/haskell2010/haskellch11.html#x18-18300011.1
23:32:45 <dminuoso> opqdonut: The example seems to rather illustrate how it should behave with respect to bottom no? I mean I could just `seq` my way to satisfy the example but use a random order of the elements?
23:33:44 <dminuoso> opqdonut: Oh I have it.
23:33:56 <dminuoso> " The latter seven operators are defined so as to compare their arguments lexicographically with respect to the constructor set given, with earlier constructors in the datatype declaration counting as smaller than later ones."
23:33:56 <dminuoso> That's it.
23:34:13 <dminuoso> Or maybe not.
23:34:14 <opqdonut> no, that talks about multiple constructors
23:34:30 <dminuoso> It does appear to me as if its left unspecified..
23:34:35 <opqdonut> I think "traverse constructors from left to right" really wants to say "traverse constructor arguments from left to right"
23:35:13 <opqdonut> the example is kinda crappy though, it conflates strictness and ordering
23:39:16 <dminuoso> opqdonut: The thing is, the example only illustrates strictness but not ordering.
23:40:23 <dminuoso> Something like ⌜(1, 2, undefined) `compare` (1, 3, undefined) ⇒ LT⌝ would have done the job better.
23:42:20 <dminuoso> By merely looking at ⌜(1,undefined) == (2,undefined) ⇒ False⌝ and ⌜(undefined,1) == (undefined,2) ⇒ ⊥⌝ - which, if you read the sentence above, illustrates the property of "traversing from left to right" - you cannot deduce whether ⌜compare (1, 2) (2, 1)⌝ should give you LT or GT.
23:42:40 <dminuoso> (So from that I take, that the property its talking about is about strictness)
23:43:40 <bolver> dminuoso: foldr (\x -> shows x . (", " ++)) "" [1..5] returns `"1, 2, 3, 4, 5, "`, but i didn't want the `, ` after the last item which is why i used the accumulator check 
23:43:55 <bolver> just wanted to clarify ...
23:44:26 <bolver> but i understand now why the `acc` check results in exponential time
23:45:42 <bolver> so the problem is not with `++` operation but for the reason /u/ `Axman6` explained
23:46:05 <dminuoso> % foldr (\x -> (", " ++) . shows x) "" [1..5]
23:46:05 <yahb> dminuoso: ", 1, 2, 3, 4, 5"
23:46:21 <dminuoso> And then bolt the ('0' :) to it by hand? :)
23:46:47 <dminuoso> bolver: right, good catch
23:47:08 <bolver> yeah, thanks, btw
23:47:56 <bolver> dminuoso: btw, `++` operation within foldr is still right associative, so you don't need to use `shows` at all
23:48:29 <bolver> i checked it ... it makes no difference whatsoever
23:48:42 <bolver> so thought i will inform you
23:50:05 <bolver> good bye, now
