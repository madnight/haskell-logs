00:00:06 <koz_> Axman6: To summon Ed, you need to draw the Sephirot of Lens. :P
00:04:00 * hackage github 0.23 - Access to the GitHub API, v3.  https://hackage.haskell.org/package/github-0.23 (phadej)
00:09:21 <dminuoso> In what situations could Haskell generated code hang inside native sqlite3 bindings? Every way I look at this, it appears that if there's any error inside sqlite then control is not passed back to the Haskell code.
00:16:00 * hackage overloaded 0.1.2 - Overloaded pragmas as a plugin  https://hackage.haskell.org/package/overloaded-0.1.2 (phadej)
00:24:11 <maerwald> error handling in haskell: have MonadThrow, MonadFail, MonadError instances, wrap everything in ExceptT from time to time, sometimes throw IO errors, sometimes have pure exceptions you need to force and generally have no idea what short-circuits and what doesn't
00:25:19 <maerwald> Also, catched exceptions are only in your dreams ;)
00:25:41 <maerwald> s/catched/checked/
00:26:09 <dminuoso> maerwald: I think that list a is a bit skewed.
00:27:15 <Axman6> we tend to only really use exceptions for unrecoverable things (which generally means it's not thrown from our code). all other errors are using MonadError
00:27:28 <dminuoso> maerwald: MonadThrow/MonadError just generalize IO/ExceptT - and MonadFail is something else entirely.
00:27:40 <Ariakenom> personally I only use ints as return values where negative is an error code.
00:27:56 <maerwald> Ariakenom: stop coding C^^
00:28:22 <dminuoso> I mean overall we have MonadThrow and MonadError as error mechanisms, and that's basically it.
00:28:27 <Ariakenom> I was told haskell was a better C
00:28:56 <dminuoso> Ariakenom: What can I say. Since yesterday Ive been trying to debug why this sqlite-simple keeps hanging inside the C library portion of it.
00:29:02 <dminuoso> The Haskell code works fine.
00:29:13 <maerwald> dminuoso: there are more ways to describe errors than that :)
00:29:36 <dminuoso> maerwald: Not really many, realistically.
00:29:39 <maerwald> Doesn't even have to be mtl/transformers
00:29:41 <dminuoso> I mean yeah, there's ContT
00:29:54 <maerwald> You can just use Either (and also wrap that in ExceptT)
00:30:11 <maerwald> You can also use some of the effects libraries and have something entirely different
00:30:12 <dminuoso> maerwald: Using Either is just a different way of doing it all by hand, like you would do in any language.
00:30:18 <maerwald> Or you just do IO errors and document them :)
00:30:35 <dminuoso> say return codes in C is akin to Either. Its not really a solution, it's just the most manual way of encoding errors.
00:30:47 <maerwald> dminuoso: in Go, error handling is fairly standardises (yet ugly)
00:31:06 <maerwald> I think it's just hard to standardise things in a highly expressive language
00:31:08 <dminuoso> maerwald: Its standardized in the sense that there is none and you are forced to do it all by hand with no boiler plate solution.
00:31:43 <maerwald> dminuoso: of course there is, error is a built-in type
00:31:50 <maerwald> but yeah, there is no boiler plate solution
00:32:21 <maerwald> just ranting, while documenting a function that can fail in ~4 different ways :P
00:32:21 <dminuoso> I think ultimately its rather things like ContT or the Monad interface of `Maybe/Either a` that are special. :)
00:35:14 <maerwald> dminuoso: ContT is great if you want no one else to understand your code :P
00:35:39 <dminuoso> maerwald: Ive started to realize that this is a myth. ContT has some really good applications that dramatically improve readability.
00:36:16 <maerwald> Even the documentation warns about its use.
00:36:48 <dminuoso> What warning is that?
00:38:44 <maerwald> dminuoso: https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Cont.html
00:38:58 <maerwald> "Abuse of the Continuation monad can produce code that is impossible to understand and maintain." ;)
00:40:08 <dminuoso> Well sure. You did read that first word correctly right?
00:40:14 <dminuoso> It says "Abuse" not "Usage" :)
00:40:43 <dminuoso> Similar things could be said for exceptions.
00:42:07 <maerwald> dminuoso: that's true for unchecked exceptions, yes
00:42:36 <dminuoso> maerwald: Even for checked exceptions. The problem is not that you don't know what exceptions can be thrown, it's that control flow can be hard to follow.
00:43:10 <dminuoso> If you start using exceptions for more than just failure situations, but in order to direct control flow - then you can rapidly produce code that is very hard to understand.
00:43:22 <merijn> For exceptional control flow that's not really an issue, where not being able to know what is thrown *is* an issue
00:44:05 <dminuoso> Oh merijn! Just the person I wanted to talk. Mind if I annoy you with one further sqlite question?
00:44:08 <merijn> Haskell isn't python, it's already easy to write code that's hard to understand, so that's a terrible excuse to keep things being awful
00:44:15 <Ariakenom> pfor iter action = catch (forever (iter >>= action)) (\StopIteration -> return ())
00:44:15 <merijn> dminuoso: Sure?
00:44:51 <dminuoso> merijn: My code keeps hanging inside sqlite whenever there's an error to the point that not even timeout can preempt it. It appears to happen in any situation.
00:45:21 <dminuoso> The strange thing is, this happens so consistently, that I expected this to be some "general known thing" with some "obvious cause", but I cant find anything about it
00:46:17 <Ariakenom> https://docs.python.org/3/library/exceptions.html#StopIteration
00:47:29 <merijn> dminuoso: Never heard of that, tbh. What's your code doing?
00:47:39 <dminuoso> merijn: I just insert a single row that violates a NOT NULL constraint.
00:47:39 <merijn> dminuoso: I do actually have a hunch, though
00:47:44 <Axman6> @hoogle f (a -> b) -> a -> f b
00:47:45 <lambdabot> Control.Lens.Lens (??) :: Functor f => f (a -> b) -> a -> f b
00:47:45 <lambdabot> Control.Lens.Operators (??) :: Functor f => f (a -> b) -> a -> f b
00:47:45 <lambdabot> DBus.Generation (??) :: Functor f => f (a -> b) -> a -> f b
00:47:55 <merijn> dminuoso: Is your database on an NFS filesystem?
00:48:18 <dminuoso> merijn: Nope, its a local ext4 filesystem.
00:48:52 <merijn> dminuoso: Wait, timeout as in System.Timeout?
00:48:54 <dminuoso> Ive gotten rid of transactions too.. sqlite receives nothing but a single INSERT statement and then just hangs inside the native portion of it.
00:48:55 <dminuoso> merijn: Yes.
00:49:05 <merijn> dminuoso: Well, of course that's not going to work
00:49:37 <merijn> dminuoso: Presumably it's stick inside the sqlite C part. timeout just throws an async exception, which can't/won't be delivered until it's running Haskell code again
00:49:38 <dminuoso> merijn: My point is just, that gave me the confidence its hung inside the C portion of it, rather than Haskell.
00:49:48 <dminuoso> Right
00:50:07 <merijn> Try loading it in a debugger?
00:50:46 <Ariakenom> could be masked hs still. or a mean loop.
00:51:04 <dminuoso> Ariakenom: Im already running fno-omit-yield, so a mean loop cant be it.
00:53:16 <dminuoso> Mmm, how can I direct cabal v2-* to generate DWARF?
00:54:29 <merijn> dminuoso: DWARF is just a GHC flag, afaik, so you could just at that to ghc-options
00:54:47 <Ariakenom> does "yield points enabled" mean that -fno-omit-yields is default? https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-optimisation.html#ghc-flag--fomit-yields
00:57:47 <dminuoso> Curious, I just see a stack frame `#0  0x000000000040d960 in AgnarziException_zdwzdcfromException_info ()`
00:59:34 <merijn> So, not inside SQLite, then
01:00:16 <merijn> dminuoso: In fact, "fromException" and (iirc) Agnarzi was the name of your code, yes
01:00:43 <merijn> dminuoso: Are you sure you didn't fuck up your implementation of Exception, leading to an infinite loop when it tries to throw/catch an exception? ;p
01:00:44 <dminuoso> Well the strange thing is, Ive tried print-debugging with `finally` with no result
01:02:12 <EvanR> error handling in elixir, just let stuff die. Oh yeah we can do that with async!
01:03:01 <dminuoso> merijn: Haha! Indeed!
01:03:19 <dminuoso> merijn: My exception hierarchy graphy was cyclic!
01:03:31 <EvanR> yeesh
01:03:34 <dminuoso> Boy what a weird night.
01:04:34 <merijn> <- genius
01:04:54 <dminuoso> merijn: The truly strange part now is, the cycle is unrelated to the exception being thrown...
01:05:23 <EvanR> "use functional patterns to process your data instead of loops so you don't accidentally cause a dreaded freeze up"   then haskell gives you a millions new ways to do that
01:06:10 <dminuoso> merijn: Oh wow! Turns out, it was not. This was one major coincidence!
01:06:11 <EvanR> whoever heard of loops in your exceptions until haskell
01:06:42 <dminuoso> merijn: Thanks! Should you make it to London next week, one drink is on me!
01:06:43 <merijn> EvanR: "Haskell is so safe it's impossible to do anything!"
01:07:13 <merijn> EvanR: Me, writing MagicHash and forcibly converting ByteString's into Storable Vectors: "What?"
01:07:52 <EvanR> yeah
01:08:09 <Axman6> take THAT, safety!
01:08:15 <EvanR> can we somehow exploit all this crap and make people like haskell
01:08:20 <dminuoso> All I had was ⌜executeOp op `catch` failed where failed :: SmtpException -> Agnar ()⌝, and of course no SmtpException was being thrown. But the way that catch works, it attempts to "convert" the exception being thrown into an SmtpException (which it wasnt!) - but the code there had a cycle. 
01:08:24 <EvanR> look at all the stupid things you can do
01:08:45 <Axman6> > length (1,2,3,4,5)
01:08:47 <lambdabot>  error:
01:08:47 <lambdabot>      • No instance for (Foldable
01:08:47 <lambdabot>                           ((,,,,) Integer Integer Integer Integer))
01:08:51 <EvanR> hahahaha
01:08:55 <Axman6> u wot
01:08:56 <merijn> EvanR, Axman6: tbh, I do think this is a selling point
01:09:03 <Axman6> It's not
01:09:15 <Axman6> but people like Ruby despite it all being bonkers
01:09:15 <merijn> Axman6: No foldable instance for tuples other than two elements, sadly
01:09:23 <Axman6> this is madness
01:09:40 <EvanR> i mean, lisp
01:09:44 <EvanR> nuffsaid
01:10:13 <merijn> Axman6: It is, though. I have some high performance code that I need to run in a tight loop that I wrote in C, but I don't want to write all the commandline parsing, file IO, networking and concurrency in C, because that sucks. With Haskell I can just wrap that 1 C function up into a higher level abstraction, dump it into a conduit and we're off
01:10:59 <maerwald> merijn: I like that approach.
01:11:10 <maerwald> (except you should use streamly instead of conduit)
01:11:11 <merijn> Sure, it'd be *better* if I could write that one function in Haskell instead, but sometimes you just have a bunch of existing nonsense and that's just not an option. The fact that Haskell makes it super easy to integrate low level things into high level abstractions is amazing and WAAAAY undersold feature
01:11:12 <dminuoso> Axman6: Ruby is liked because features are always considered and designed around how they visually appear. I mean you could introduce a new feature that changes the language semantics, but 95% of the discussion is whether you should use `piyo ⌜$⌝` as syntax or `hoge ⌝%⌜ - and the saddest thing is, this is not even sarcasm.
01:11:34 <merijn> dminuoso: Wadler's law
01:11:42 <Axman6> merijn: what is the C doing that you couldn't do in Haskell?
01:12:04 <dminuoso> merijn: Heh
01:12:28 <merijn> Axman6: In my case nothing, because I replaced said C with "ripping out the ForeignPtr of a ByteString and casting it to a Storable Vector" by now :p
01:13:01 <EvanR> dminuoso: i gave a presentation where i computed complex data structures from short strings in a quasi quoter... should we be telling rubyists about quasi quoters
01:13:05 <merijn> Axman6: But that implementation is (still) 1.5x slower than the original C and sometime you have a large library or existing code that you can't easily "just reimplement"
01:13:20 <EvanR> well, quasi quoted languages don't get syntax highlighting so that's probably out
01:13:21 <merijn> Axman6: Also "can you do it in Haskell" is not a relevant question
01:13:37 <merijn> Axman6: The real question is: Is it pragmatic/economically viable to rewrite this in Haskell?
01:13:41 <dminuoso> EvanR: well in Ruby the notion of QQ is silly becaue QQ and the underlying language are already intertwined.
01:14:05 <merijn> Axman6: The fact that I can still use Haskell for >90% of my application code even if that 10% isn't viable to rewrite in terms of economics is great
01:14:06 <dminuoso> EvanR: any rubyist would be looking strange at you "why do we need to "quote forth and back" if we can just throw these levels together, just like in lisp?"
01:14:37 <EvanR> on that note, ignoring quasi quoter, haskell does give you minimal room to change the look
01:15:00 <EvanR> i've never thought about that as being the 1st and only thing being considered
01:15:07 <EvanR> but it's probably right
01:15:07 <merijn> EvanR: What, you don't like -XRebindableSyntax? ;)
01:15:32 <Axman6> merijn: the abilityt to add non-painful concurrency to that sort of code is also very nice (assumig the underlying C is threadsafe)
01:15:34 <EvanR> probably not
01:16:50 <merijn> Axman6: As for what can you do in C that you can't in Haskell, if you need to vectorise things and control cache access patterns for performance, then C is still better than Haskell
01:17:38 <Axman6> this is true, the state of vector types in Haskell is pretty poor. we need some good abstractions
01:18:27 <EvanR> C is also better at trigraphs
01:18:37 <Axman6> do you even bool?
01:18:41 <Axman6> oh, wrong thing
01:19:00 <Axman6> trigraphs is not ternary operator
01:19:16 <EvanR> haskell has that
01:19:41 <merijn> Axman6: carter is working on it, but I don't think many other people are working on it atm
01:19:49 <Axman6> yeah
01:21:17 <EvanR> on the subject of thought-to-be inconsequential but probably isn't issues with haskell, there isn't syntax to create and take apart "maps" (IntMap, Map, ...)
01:22:36 <maerwald> merijn: although I think it's cooler to write high performance code in rust, then expose a C interface and use that in haskell!
01:23:13 <EvanR> and to me part of the pain is importing
01:23:15 <Taneb> maerwald: cooler still is to do precisely that backwards
01:23:48 <merijn> maerwald: I rarely have reason to use Rust, tbh
01:23:54 <Axman6> > [("Hello","EvanR"),("I'm a", "Map")] :: Map String String
01:23:56 <merijn> Because I can almost always afford a GC
01:23:56 <lambdabot>  error:
01:23:56 <lambdabot>      Not in scope: type constructor or class ‘Map’
01:23:56 <lambdabot>      Perhaps you meant ‘M.Map’ (imported from Data.Map)
01:24:03 <EvanR> ^
01:24:14 <Axman6> > [("Hello","EvanR"),("I'm a", "Map")] :: M.Map String String -- inb4 no OverloadedLists
01:24:16 <lambdabot>  error:
01:24:16 <lambdabot>      • Couldn't match expected type ‘M.Map String String’
01:24:16 <lambdabot>                    with actual type ‘[([Char], [Char])]’
01:24:29 <dminuoso> Mmm, semantically Control.Exception.catch itself runs with async exceptions masked right?
01:24:43 <dminuoso> Im a bit lost chasing the definitions through haddoc.
01:24:46 <merijn> dminuoso: The handler runs with async masked, yes
01:25:30 <dminuoso> Presumably that's rigged inside catch# somehow?
01:25:31 <merijn> dminuoso: Conclusion: it's a mess and last time me and Peaker campaigned to change it there was only a sort of "half consensus/agreement" and I didn't have time to do it and then proceed to struggle to actually get it in so I shelved it
01:33:18 <boxscape> hm, is it acceptable to comment on the discussion of accepted but unimplemented proposals if you have an idea for an adjustment? (Presumably another proposal would have to actually accept any such adjustment)
01:35:33 <boxscape> s/would have/would have to be made
01:38:15 <boxscape> though actually it might not as easy to implement what I had in mind as I thought, so maybe it's a moot point
01:41:30 * hackage cabal-rpm 1.0.1 - RPM packaging tool for Haskell Cabal-based packages  https://hackage.haskell.org/package/cabal-rpm-1.0.1 (JensPetersen)
01:45:01 <boxscape> basically https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0229-whitespace-bang-patterns.rst introduces a concept of ! being a suffix in something like "a! b", but a suffix is usually just interpreted as infix. I thought it could be nice if it were interpreted as a PostfixOperator if that extension is enabled, considering the
01:45:02 <boxscape> proposal introduces similar whitespace dependent behaviour for (-) if -XLexicalNegation is enabeld
01:45:43 <boxscape> but it looks like this might just apply to !, ~, @, and possibly $ and $$ rather than every operator
01:49:44 <anup> hi guys
01:49:51 <anup> midterm tomorrow..need help
01:50:00 * hackage servant-errors 0.1.3.1 - Servant Errors wai-middlware  https://hackage.haskell.org/package/servant-errors-0.1.3.1 (epicallan)
01:50:15 <Guest42138> how to find max element in list using foldr???????
01:50:25 <dminuoso> Guest42138: What have you tried?
01:50:46 <Axman6> I remember doing that homework
01:51:44 * jgt wistfully remembers his first foldr
01:51:59 <Guest42138> max (x:xs) = foldr ( \x -> \acc->if x>acc then x: max xs else max xs
01:52:00 <Guest42138> ?
01:52:05 <Guest42138> is it right?
01:52:23 <dminuoso> Guest42138: You tell me.
01:52:36 <dminuoso> Guest42138: Is that right? Does that typecheck? Does that do what you expect it to?
01:53:03 <Guest42138> max :: [Int]-> Int
01:53:38 <Guest42138> max (x:xs) = foldr ( \x -> \acc->if x>acc then x  else max xs
01:53:40 <Guest42138> ?
01:53:45 <Axman6> looks like there are several problems with that code. it's not valid haskell to start with
01:54:02 <Guest42138> thats why i am here
01:54:14 <Axman6> the point of using foldr is that you don't need to use explicit recursion, so you shouldn't be calling max again inside max
01:54:45 <Axman6> x:max xs is definitely a list, which isn't the type you want
01:55:06 <Guest42138> max (x:xs) = foldr ( \x -> \acc->if x>acc then x  else max xs
01:55:10 <Guest42138> check this
01:55:31 <Axman6> you haven't closed that bracket yet
01:55:51 <Guest42138> max (x:xs) = foldr ( \x -> \acc->if x>acc then x  else max xs)
01:56:00 <Guest42138> dude
01:56:24 <Axman6> :t foldr
01:56:25 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
01:56:43 <dminuoso> Guest42138: Are you just guessing?
01:56:54 <Guest42138> yeah
01:57:06 <dminuoso> Guest42138: Okay let's start with that. Dont. :)
01:57:10 <Axman6> foldr needs threee things: a function to process elements of the list, a default value for the end of the list, and the list. you 've only given it the first argument
01:57:11 <Guest42138> ok
01:57:23 <Guest42138> yup
01:57:47 <dminuoso> Guest42138: can you use foldr to add a list of integers together?
01:57:55 <Guest42138> yes
01:58:13 <Guest42138> 0 as initial value and (+) as function
01:58:19 <Axman6> foldr ??? ? [1,2,3] -> 6
01:58:26 <Axman6> good
01:58:40 <dminuoso> Guest42138: You can use lambdabot go write a quick demonstration, by starting the line with > and then writing a haskell expression.
01:58:43 <dminuoso> > 1 + 3
01:58:45 <lambdabot>  4
01:59:01 <dminuoso> Guest42138: Can you show us, how you would sum a list of [1,2,3,4] using foldr in lambdabot?
01:59:49 <Guest42138> >1_+2+3+4+0
02:00:27 <Guest42138> >1+2+3+4+0
02:00:45 <dminuoso> Guest42138: No I meant the full haskell code using foldr.
02:00:53 <dminuoso> Guest42138: You also need to add an additional space after the >
02:00:58 <dminuoso> > 1 + 4
02:01:00 <lambdabot>  5
02:01:16 <Guest42138> never mind 
02:01:22 <Guest42138> i dont have all night
02:01:35 <Axman6> you're welcome
02:01:38 <maerwald> :o
02:01:45 <dminuoso> Time to watch stackoverflow.
02:01:49 <Axman6> yah
02:02:02 <dminuoso> A muffin says there's a question about foldr coming up shortly...
02:02:13 <maerwald> well, I think some university started a haskell course, so lately it has been full of homework questions
02:02:18 <Axman6> AS I SAID IN #HASKELL, CAN YOU ADD THE NUMBERS IN A LIST USING FOLDR????
02:04:19 <dminuoso> I clearly should have offered the solution in exchange for the usual freelancer fees.
02:04:54 <Axman6> YEAH
02:05:27 * Axman6 adds anup to his list of people who don't deserve help
02:05:40 <dminuoso> It's quite funny, I've nabbed a few short freelancer bits via IRC already, charging usual prices - and they paid up front without knowing me at all.
02:05:54 <dminuoso> So people who understand how this works do exist after all.
02:06:12 <Axman6> heh
02:06:25 <Axman6> how often do you get paid to do people's homework for them?
02:06:45 <Axman6> because all his questions lately have been clearly homework
02:07:04 <dminuoso> Back in school? Quite frequently!
02:07:09 <dminuoso> Easy money
02:08:05 <__monty__> Hmm, maybe that's how we can create more haskell job opportunities. Just chide anyone who gives away homework answers in #haskell.
02:18:35 <jgt> come on guys, can you just do the work for me please? I don't have all night
02:19:56 * jgt wishes he were smart enough to make money at school doing other people's homework, instead of selling pirated stuff
02:23:35 <__monty__> I've heard ridiculous stuff like law students being willing to pay upwards of 100 euro to format their Word documents.
02:25:29 <jgt> some Arab guy wanted me to edit his "book" for him. I charged him £500 per chapter, and then just offloaded the work onto some 16 year old for £30 per chapter. There were eight chapters.
02:25:30 <nekenzon> I have installed ghc in mac OS but how to run them?How to adjust path variable in mac OS? 
02:25:53 <Ariakenom> __monty__: that's absurd. who would spend hours fighting a loosing battle against word for that little
02:26:49 <maerwald> nekenzon: how did you install
02:27:22 <__monty__> nekenzon: The usual advice for bash applies.
02:27:42 <nekenzon> use terminal 
02:27:49 <__monty__> Ariakenom: These are not thesis size documents.
02:27:55 <maerwald> nekenzon: what do you mean by that
02:27:57 <merijn> monochrom: You mentioned setting split-sections in ~/.cabal/config this week, right? Ever run into any issues
02:28:19 <maerwald> did you install from tarball, using stack, ghcup, ...?
02:28:28 <nekenzon> by typing curl https://get-ghcup.haskell.org -sSf | sh
02:28:39 <nekenzon> ghcup
02:28:50 <maerwald> nekenzon: you need to source the file ~/.ghcup/env in your shell
02:29:11 <maerwald> if you use bash that might be ~/.bashrc or ~/.bash_profile
02:29:48 <nekenzon> how to source the file in my shell?
02:30:01 <maerwald> source ~/.ghcup/env
02:30:24 <nekenzon> type it in terminal right?
02:30:38 <maerwald> (and you may want to add that line to ~/.bashrc or ~/.bash_profile)
02:30:39 <maerwald> yes
02:30:48 <nekenzon> thank you
02:35:00 * hackage chiphunk 0.1.2.0 - Haskell bindings for Chipmunk2D physics engine  https://hackage.haskell.org/package/chiphunk-0.1.2.0 (DavidHimmelstrup)
02:41:46 <nekenzon> maerwald it works now. But when i close the terminal and open it again, the ghci command is not working unless i source the file again. 
02:42:56 <__monty__> nekenzon: That's why maerwald told you to put that line in .bashrc
02:43:35 <__monty__> That file is automatically sourced when opening a new shell so if you put the line in there it'll automatically be executed in every new shell.
02:44:39 <merijn> __monty__: Well, not *every* :p
02:44:56 <__monty__> merijn: Simplifying so as not to overwhelm.
02:44:57 <merijn> __monty__: Then again, no one properly distinguishes .bashrc/.bash_profile/etc. these days
02:45:15 <nekenzon> ok, i will try it again 
02:48:52 <__monty__> nekenzon: For a rainy night `man bash` is worth a read.
02:49:49 <nekenzon> XD
02:51:37 <jakov99> Hi ! I am sorry if this is a little offtopic, but maybe there is someone who knows enough about the Shake Buildsystem: I have a C compilation going, and when i issue "clean" on only some of the object files, it still rebuilds all of them.
02:51:57 <jakov99> You can have a look at the shakefile here: https://github.com/JackTheEngineer/Drone
02:52:25 <__monty__> I'm not even joking. If you're gonna be spending considerable time in a terminal the effort'll repay itself a thousand times over.
02:52:54 <jakov99> https://github.com/JackTheEngineer/Drone/blob/master/Shakebuild.hs
02:56:32 <__monty__> jakov99: Does your clean target actually remove only some of the files?
03:07:16 <jakov99> yes. It does. it removes the files that are in "src//*", arbitrarily deep, and only in the toplevel build directory "/*.*"    .              I checked on that
03:21:36 <__monty__> jakov99: So it doesn't remove all .o's? Hmm, the only other problem I can think of is the command that generates your .o's doesn't discriminate, i.e., it just rebuilds everything.
03:22:36 <jakov99> Would this mean, that if i call the buildsystem twice, then it would still rebuild everything ?
03:23:20 <jakov99> It doesn't. That's the point. And if i 'touch' one file, then it rebuilds only that file. 
03:34:56 <boxscape> Am I seeing this right that @ syntax has been used for type application in Core since the beginning?
03:38:02 <__monty__> jakov99: Does the amount of rebuilding depend on what .o's you remove?
03:43:54 <jakov99> no, it rebuilds all of them, as if the clean target causes everything to be rebuild.
03:45:11 <jakov99> If you like to, you can clone the repository, download 'arm-none-eabi-gcc 4_9' ( in the readme) adjust the "arm_base" path to match your installation and then you can try it out. 
03:45:44 <jakov99> assuming you have a linux computer, as i havent tried it on windows.
03:46:16 <__monty__> I'm on a mac but don't have time for that anyway.
03:47:04 <jakov99> alright. But thank you for your help anyway :) 
03:51:50 <__monty__> jakov99: I recommend running your build command with --profile the reasons for rebuilding things should be somewhere in the resulting report.html
03:52:16 <Phyx-> arm-none-eabi-gcc 4.9? why?
03:58:53 <jakov99> It's an infineon M4 microcontroller, and they ship their buildsystem (DAVE) with 4.9. I've heard some rumors ( i don't understand the details very well) that rely on the old version, as they are fixing some hardware bugs in the startup Code, relying on the version. 
03:59:18 <jakov99> i haven't tried the newer ones. 
04:00:17 <jakov99> Phyx- , would you give arm-none-eabi-gcc 8 q3 a go ?
04:00:28 <merijn> So, anyone here have experience with setting up direct cradles with ghcide? It recognises about half of my modules, but the rest is a whole slew of errors and I don't really know where to start fixing those :\
04:01:13 <Phyx-> jakov99: yes, the difference between 8 and 4.9 is night and day on certain things
04:02:02 <jakov99> alright thanks ! I am curious as to wether it will work, or break :D
04:02:47 <Phyx-> what's the context for what you're trying to do? :) my system restarted so can't scroll back
04:11:51 <jakov99> https://github.com/JackTheEngineer/Drone/blob/master/Shakebuild.hs
04:12:18 <jakov99> I am programming a Quadrocopter drone from scrath, and building my buildsystem with shake. 
04:13:16 <jakov99> And when i tell shake to remove only clean certain '.o' files, but leave others in place, it rebuilds all of them.  
04:13:49 <dminuoso> Mmm, is there a way to figure out what Exception is being thrown?
04:14:03 <dminuoso> That is, can I take some SomeException and figure out what it really is?
04:16:33 <dminuoso> Ah I suppose I could just do (`catch` \(SomeException e) -> print (typeOf e))
04:16:44 <f-a> indeed
04:16:47 <Axman6> or even just print e
04:17:38 <dminuoso> Axman6: Actually that wont do the trick, since that assumes that the Show instance will tell you what it is.
04:18:19 <Axman6> hmm, I guess - that's usually a pretty reasonable thing for an exception though
04:20:33 <dminuoso> Axman6: You'd think so, until someone uses `fail` in their code and you get an IOException flung in your way!
04:21:04 <merijn> cocreature: ok, I've been trying to write a direct cradle for an hour or so now and I'm not managing to get it to correctly load more than half of the modules and I'm utterly lost how to even determine why the rest is failing
04:21:12 <dminuoso> Axman6: https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.IO.Exception.html#line-416
04:24:55 <cocreature> merijn: is your project and the cradle public?
04:26:17 <merijn> cocreature: The cradle not yet, because I didn't commit it, but I can pastebin it
04:29:14 <merijn> cocreature: The code is here https://github.com/merijn/GPU-benchmarks I mostly care about the benchmark-analysis subdirectory not the other haskell packages listed in the cabal.project, so I've also tried simply defining the cradle local that one
04:29:51 <merijn> cocreature: The cradle is just: https://gist.github.com/merijn/40f7c33e6d6a8497515fa7469367570f (i.e. the include directories)
04:30:25 <merijn> cocreature: But despite the explicit include of the autogen dir (which does indeed have a Paths_ module) it complains it can't find Paths_
04:30:36 <cocreature> merijn: can you also pastebin the error you get when running ghcide in a terminal
04:31:22 <merijn> cocreature: Yeah, just added it
04:31:40 <merijn> Bunch of compiler (?) crashes and inability to find Paths_ despite the autogen path
04:32:03 <merijn> Also a bunch of "main:" related confusion that I don't understand
04:32:40 <merijn> cocreature: (oh! note that I managed to get rid of the path/line stuff in the messages! but it's *super* hacky >.>)
04:34:20 <merijn> I tried adding -fobject-code, thinking it was maybe getting hungup on the TH when trying to load things, but that doesn't seem to change/fix anything
04:35:21 <merijn> Meanwhile ghci seems to be perfectly happy loading everything from just the .ghc.environment
04:36:06 <hoxtrop[m]> > I like the two-person-game semantics for this. Works for both logic and types.
04:36:06 <hoxtrop[m]> > Like this: http://vex.net/~trebla/weblog/any-all-some.html
04:36:07 <hoxtrop[m]> Thanks
04:36:08 <lambdabot>  <hint>:1:79: error:
04:36:08 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
04:36:09 <lambdabot>  error:
04:36:09 <lambdabot>      • Data constructor not in scope: Like :: t1 -> a0
04:36:09 <lambdabot>      • Perhaps you meant variable ‘like’ (imported from Control.Lens)error: V...
04:36:51 <cocreature> merijn: TH is definitely not working properly atm so I wouldn’t be surprised if a significant number of those issues are caused by TH
04:37:13 <Synthetica> Hey, is there a way to tell Cabal to use an old revision of a package on Hackage? Specifically: I want to use collections-api, on modern ghc, and -r0 specifies base<5, but it was revised to say base<4.8 
04:37:28 <Synthetica> Any pointers?
04:37:31 <merijn> cocreature: :\
04:38:02 <merijn> Synthetica: eh, the reason that revision was added is, presumably, because it doesn't work with newer GHCs
04:38:34 <merijn> Synthetica: So the answer is "no, there's no way to do that" and the reason is that "the problem that would solve isn't actually the problem you have"
04:38:42 <kuribas> I want to write a haskell library for composing SQL statements, but without advanced type hackery
04:38:45 <kuribas> What would be the right way to support multiple backends?
04:38:57 <kuribas> Just different packages, typeclasses, something else?
04:39:08 <merijn> kuribas: "Text" *ducks*
04:39:19 <kuribas> merijn: text is what I want to avoid
04:39:40 <merijn> Synthetica: Especially since the revision was added by one of the Hackage trustees, who, in principle, only add revision to avoid breakage
04:40:25 <Synthetica> merijn: Yeah, I feared as much
04:40:28 <merijn> Synthetica: Looking at the API and the base restriction I guess it got broken by the Foldable/Traversable transition, so you'd first have to fix the package
04:40:45 <merijn> Synthetica: The good news, if the package is indeed broken by Foldable/Traversable fixing it should be fairly straightforward
04:41:43 <Synthetica> Say I fix it, could I get my fix uploaded on Hackage?
04:41:57 <merijn> Synthetica: https://wiki.haskell.org/Taking_over_a_package
04:42:24 <kuribas> the the problem is that the return types of the DB may be different for each backend
04:42:30 <Synthetica> merijn: Thank you :)
04:42:31 <tdammers> kuribas: I don't think there's proper consensus on this, but an obvious approach would be to first design a query EDSL that is backend-agnostic, then an interface between that and the backends, and then the actual backend implementations
04:43:07 <merijn> Synthetica: That said, a lot of that package seems redundant?
04:43:24 <kuribas> tdammers: I want an applicative interface that converts between the return type of the database and the haskell type, but cannot be backend-agnostic
04:43:27 <tdammers> kuribas: if you want to do the backend mapping at compile time, then the interface needs to be a typeclass, and you would parametrize the query writer over the backend type; if you want to be able to switch backends without recompiling, then the interface would be a record type, and backends would be values of that type
04:43:42 <merijn> Synthetica: Oh, wait, it's just MonoFoldable with a clashing name
04:43:55 <tdammers> kuribas: oh, you mean matching SQL types with Haskell types?
04:44:06 <merijn> @hackage mono-traversable
04:44:06 <lambdabot> http://hackage.haskell.org/package/mono-traversable
04:44:14 <kuribas> tdammers: yes
04:44:16 <merijn> Synthetica: Check if that packages does what you want
04:44:54 <tdammers> kuribas: I would just not attempt that at all. Just have an SqlValue unitype, a FromSql typeclass, and allow that to fail if the database result doesn't have the right type
04:45:02 <kuribas> tdammers: something like this: select (Person <*> "name" <$> "age") (from "persons" <> where_ ("age" .> 20))
04:45:19 <tdammers> but you're really mixing two concerns here - data mapping, and query writing. the two are orthogonal
04:45:54 <Synthetica>   merijn: looks promising on first sight
04:46:05 <kuribas> tdammers: it's convenient, I got everything in one place
04:46:34 <tdammers> I'd still keep the two concerns conceptually separated
04:46:45 <kuribas> tdammers: you can still use a tuple
04:47:05 <merijn> cocreature: So essentially you guys just don't use TH as digital-asset? And once again my hopes are dashed :<
04:47:21 <tdammers> but anyway, I'd start with the AST for representing queries, without worrying too much about marshalling types yet
04:47:57 <kuribas> tdammers: the problem is that different backends have different features.
04:48:18 <tdammers> yes, I know
04:48:20 <kuribas> tdammers: so a universal AST or sum type would work for every backend
04:48:32 <tdammers> you have several choices here, and they all suck
04:48:50 <tdammers> you can make the AST backend-specific, but that would ruin much of the purpose of the library
04:48:58 <kuribas> maybe I'll just go with several packages like the *-simple libraies
04:49:19 <tdammers> you can make the AST such that it supports all the features of all the backends, but then you have to error out late when someone tries to use a feature that isn't available on the backend
04:49:38 <merijn> cocreature: Confusingly a whole bunch of stuff that doesn't use TH doesn't work either, though. I'd be fine with giving up on the modules using TH, but I don't know what's broken about all the others
04:49:50 <tdammers> you can emulate features that are missing from a backend, but that tends to end badly (inefficient or outright wrong queries being generated, up to and including security critical stuff)
04:50:05 <cocreature> merijn: TH works iirc if you define the TH that is executed in an external package. we don’t define our own TH
04:50:11 <tdammers> you can support only features present on all backends, but then you get a crippled experience on all of them
04:50:18 <cocreature> but yeah I think we have no or very little TH in our codebase
04:50:37 <kuribas> tdammers: or a "common" import, and then extras which depend on the backend
04:50:56 <tdammers> yes, but then you need to make the EDSL extensible, which adds considerable complexity
04:51:00 <merijn> cocreature: Oh, but I don't define my own TH though, it's just splices/quasiquoters imported from other packages
04:51:03 <tdammers> can't just make it a sum type anymore
04:51:12 <cocreature> merijn: hm, then maybe my assumption was wrong :)
04:51:14 <merijn> So then I'm back to not understanding why it doesn't work
04:51:41 <cocreature> still fairly sure it’s TH, it just sounds like my assumption that it works if it comes from an external package isn’t correct
04:52:22 <merijn> cocreature: Normally when I have TH issues ghci also fails, but that appears to work fine, even without -fobject-code
04:53:55 <kuribas> tdammers: my idea was to have a "selector", which is a tuple ([String], [SqlType] -> (a, [SqlType])), the rows of the query, and the list of returned values from the DB.
04:54:15 <kuribas> tdammers: but I want to avoid the mess of conversion that some libraries have, like selda.
04:54:17 <merijn> ok, sounds like I should just go back to giving up on Haskell editor integration entirely
04:55:04 <tdammers> kuribas: start with the explicit way, then layer sugar on top to make it more palatable
04:55:21 <tdammers> I don't really understand what the "selector" does though
04:56:01 <tdammers> conceptually, you want something like render :: SqlDialect -> Query -> Text
04:56:16 <tdammers> where Query is the query AST, and SqlDialect defines the SQL flavor
04:56:55 <tdammers> you can also have something like tyInfer :: Query -> ([ParamT], ResultT)
04:57:08 <merijn> cocreature: oh, hah, this is probably exactly the same issue ocharles already reported on github >.>
04:58:40 <kuribas> tdammers: it is a row (from the SELECT in the query), and also a converter
05:00:12 <kuribas> tdammers: in the example above I use overloaded strings
05:00:30 * hackage hw-prim 0.6.2.35 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.6.2.35 (haskellworks)
05:02:51 <Nosh> Sorry if this is a FAQ, but the setup for my haskell compiler platform is not working properly, even after restarting windows.
05:03:35 <Nosh> When I run the setup, even as an administrator, a message briefly appears on the screen about extracting files. However, it quickly disappears, and nothing happens after that.
05:04:25 <domenkozar[m]> is there getContents alternative that doesn't block if stdin is not closed, but rather just returns what it has so far?
05:05:24 <merijn> domenkozar[m]: What are you trying to do?
05:06:21 <kuribas> tdammers: without overloaded strings it would be like: select (Person <*> stringRow "name" <$> intRow "age") (from (table "persons") <> where_ (field "age" .> 20))
05:06:22 <domenkozar[m]> read stdin without blocking on further input
05:06:24 <jusss> `f x = x` parse error on input `=' why?
05:06:51 <merijn> domenkozar[m]: Yes, but what do you want to *do* with that input
05:07:22 <kuribas> tdammers: the type of stringRow "String -> (String, [SqlType] -> (String, [SqlType]))"
05:07:26 <domenkozar[m]> check if there's stdin without blocking the program
05:07:32 <Nosh> I dont mean to derail the topic, but I'm able to get ghci running through ubuntu wsl, although I immensely prefer the gui for the windows platform. Any help would be appreciated.
05:08:07 <merijn> domenkozar[m]: That's almost certainly the wrong thing to do, but I can't suggest anything better from this
05:08:23 <boxscape> Nosh is it possible to run the setup through a previously opened cmd to see if you can see an error message before it closes?
05:08:53 <Nosh> I'm not exactly sure how to do that, this is my first language I'm learning so my scope of knowledge is very limited
05:09:19 <jusss> Prelude> f x =x
05:09:30 <jusss> <interactive>:2:5: parse error on input `='
05:09:39 <Nosh> I was able to catch a glimpse of the message, but it didn't say anything about errors, it was the exact same message as other setups gave on other systems
05:09:41 <hpc> in ghci, definitions start with "let"
05:09:53 <Nosh> except it worked with the other systems
05:10:03 <jusss> hpc: but I tried to use :{ and :} to contain that
05:10:07 <jusss> same error
05:10:09 <hpc> it's like a giant do-block
05:10:13 <boxscape> Nosh press Windows key+R, a windows should open that lets you run a program. type cmd in the line and press enter, a command line should open. Then you can enter the full file name of the setup file, and hopefully get useful output
05:10:29 <hpc> all :{ :} does is let you enter things on multiple lines
05:10:46 <boxscape> hpc you don't need to use let anymore in ghci
05:10:54 <jusss> hpc: how I can create a type which is Int -> Int?
05:11:21 <jusss> hpc: data F = Int | Int -> Int
05:11:50 <hpc> maybe something like
05:11:51 <jusss> or Either Int (Int -> Int) is possilble?
05:11:55 <hpc> let f :: Int -> Int
05:11:58 <hpc>     f x = x
05:12:04 <hpc> as a multi-line definition
05:12:14 <hpc> i can't test because my ghci is new enough to support non-let definitions
05:12:14 <jusss> hpc: that f can be a type?
05:12:17 <boxscape> > Left 4 :: Either Int (Int -> Int)
05:12:19 <lambdabot>  Left 4
05:12:45 <Nosh> would I just normally type the file path in there, or? It's not recognizing the file name as an internal/external command boxscape
05:12:46 <jusss> I really want to do is result polymorphic
05:12:59 <boxscape> Nosh yeah full file name including the full path
05:13:15 <jusss> boxscape: (Int -> Int) is a type?
05:13:19 <boxscape> yes
05:13:39 <Nosh> so C:\Users\Username\Downloads\HaskellPlatform-8.6.5-core-x86_setup.exe?
05:14:20 <boxscape> Nosh yeah, ideally surround with "" to make sure nothing goes wrong so "C:\Users\Username\Downloads\HaskellPlatform-8.6.5-core-x86_setup.exe", but shouldn't actually make a difference int his case
05:15:25 <jusss> boxscape: is there a function which may return a Int or Int -> Int?
05:15:50 <boxscape> jusss as in a function that has "Either Int (Int -> Int)" as return type? Or something esle?
05:16:35 <jusss> boxscape: in js, f = _ => {console.log(_); return f}
05:16:47 <jusss> boxscape: but that won't happen in hasekll? right?
05:17:03 <jusss> boxscape: 'cause it will cause an infite type?
05:17:08 <jusss> infinite
05:17:18 <jusss> a function return itself
05:18:32 <boxscape> You don't get an infinite type if the number of arguments line up correctly, but you might still get an infinite loop at runtime depending on what you do
05:18:39 <Nosh> boxscape I ran the program but it's just a blank prompt, nothing's happening 
05:18:48 <jusss> so I wonder can we just return a clear several times,
05:18:51 <boxscape> Nosh hmm that's odd
05:18:54 <Nosh> a new prompt popped up with the title of the file
05:19:21 <Nosh> but it's completely blank
05:20:54 <dminuoso> jusss: Such a construct would have an infinite type in Haskell indeed.
05:21:01 <boxscape> Nosh if you can't figure it out via the haskell platform you might be able to install ghc via stack and then install winghci (which seems to be what you want the haskell platform for), as described on https://github.com/haskell/winghci/wiki/Installation
05:21:27 <jusss> dminuoso: do you know kotlin?
05:21:38 <jusss> another type-checked language
05:22:47 <dminuoso> I am aware of it.
05:23:48 <domenkozar[m]> merijn: thanks, I think I found a solution that will avoid whole handle buffering
05:24:01 <jusss> dminuoso: https://paste.ubuntu.com/p/Z6vSnsc7jH/
05:24:42 <jusss> dminuoso: they can point out the type manually, so it can return it several times
05:25:03 <jusss> dminuoso: I wonder if this is possible in haskell
05:25:06 <dminuoso> jusss: Well apparently they have some `Any` type which appears to act like an escape hatch.
05:26:18 <jusss> dminuoso: I don't think that's the point...
05:26:41 <jusss> dminuoso: by the way why we don't have 'Any' or 'Object' type and null value?
05:27:47 <dminuoso> jusss: Well strictly speaking we have something akin to Any, its called Dynamic.
05:27:54 <jusss> Java doesn't has first-class functions, which is insane to me, but why those other static type languages can't return itself from a function?
05:28:10 <dminuoso> jusss: Because returning itself would produce an infinite type.
05:28:21 <jusss> dminuoso: if a function can't return itself, why we could call it functional?
05:28:24 <dminuoso> jusss: Tell me this. What would be the type of a function that returned itself?
05:28:46 <Nosh> boxscape I've successfully downloaded ghci, but I cant find the binary distribution for winghci
05:28:52 <jusss> dminuoso: but that python and javascript can return function itself
05:29:44 <jusss> dminuoso: so I wonder if one function can return an Int or Int->Int, the result is polymorphic
05:29:44 <Nosh> or rather I can, but I'm unable to find the files referenced
05:29:46 <dminuoso> jusss: You'd end up with an equation like: `b ~ a -> b`, which if you expand leads to `b ~ a -> a -> b`, which if you expand leads to `b ~ a -> a -> ... ad infinitum `
05:30:06 <dminuoso> jusss: Python and JavaScript are untyped. They do not have a type system
05:30:23 <boxscape> Nosh have you tried winGhci-1.0.2-bin.zip in https://code.google.com/archive/p/winghci/downloads ?
05:30:32 <boxscape> though this might be pretty outdated, I'm not sure
05:30:56 <jusss> dminuoso: like in the kotlin examples, we can point the times manually, like f :: Int -> (Int -> Int) so f will return f once, then f will return an Int finally, this is not an infinite type
05:31:08 <jusss> it eventually return an Int
05:31:20 <carter> merijn: let’s write a datalog ;)
05:31:24 <dminuoso> jusss: The type of such a function is an infinite type.
05:31:44 <dminuoso> jusss: Again. Lets take a function that accepts an Int and returns itself. What's the type of such a function?
05:32:27 <jusss> dminuoso: what that kotlin handle that? it's a type-checked language too
05:32:41 <dminuoso> jusss: Kotlin seems to have an escape hatch there.
05:32:48 <boxscape> jusss can you write the kotlin snippet without Any?
05:32:53 <Nosh> boxscape Nah, I can't find any relevant install files there ._.
05:33:29 <jusss> boxscape: I don't know...
05:33:43 <boxscape> Nosh really? When I open https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/winghci/winGhci-1.0.2-bin.zip I get a zip with a filder that contains all the files that are mentioned in the first link
05:33:57 <dminuoso> jusss: Ignore the Kotlin example for a moment. Using Haskells type system language, try and describe a function that returns itself.
05:34:09 <boxscape> (mentioned the first link that I linked, that is)
05:34:10 <dminuoso> jusss: Just put yourself into Haskells type system for a moment.
05:34:10 <Nosh> That appears to be a different link
05:34:30 <jusss> dminuoso: at first, we should create a type named Function
05:34:32 <Nosh> When I clicked your previous link it took me to a different folder, iirc
05:34:45 <dminuoso> jusss: We have that, its called (->)
05:34:48 <boxscape> Nosh it is one of the links from that page
05:35:01 <Nosh> My bad
05:35:10 <dminuoso> jusss: `(->) Int Char` is the type of all functions from Int to Char.
05:35:13 <Nosh> I just woke up so I'm not processing everything you say, sorry
05:35:17 <boxscape> np
05:35:29 <dminuoso> Can also be written in infix notation, `Int -> Char`, but the above is hopefully a bit more explicit.
05:35:52 <jusss> dminuoso: in python, function is an instance, so they have an Function class I think, 
05:37:02 <boxscape> Nosh However when I try it I can't actually get it to run right now, so that might not work...
05:37:37 <jusss> dminuoso: data F = Int | Int -> Int; f :: Int -> F is possible?
05:38:31 <jusss> or using type alias
05:38:44 <boxscape> Nosh (tbh I'd recommend getting used to the command line interface of the regular ghci, I don't think haskell platform is that widely used anymore)
05:40:22 <jusss> avoid the value constructor has the same name with type Int, we may use f Either Int (Int->Int) -> Either Int (Int->Int)
05:40:32 <dminuoso> jusss: That's not a valid data definition
05:41:21 <jusss> dminuoso: what his one f :: Either Int (Int->Int) -> Either Int (Int->Int)
05:41:26 <dminuoso> 14:37:15         jusss | dminuoso: data F = Int | Int -> Int; f :: Int -> F is possible?
05:41:27 <dminuoso> That one.
05:41:47 <dminuoso> jusss: But sure, such a type is legit. But that's not the type of the function I asked you to write.
05:43:12 <jusss> dminuoso: you asked is f :: Int -> (Int -> (Int -> ...
05:43:26 <dminuoso> jusss: Do you recognize that this is an infinite type
05:44:15 <dminuoso> However, we can make a trick.
05:44:21 <jusss> dminuoso: this is like a recursion, what we need is just a value in the bottom, here is a type
05:44:23 <dminuoso> % data F = MkF { unF :: Int -> F }
05:44:24 <yahb> dminuoso: 
05:44:38 <dminuoso> `f :: F` and then you have your specified function.
05:45:29 <jusss> dminuoso: sorry, I don't understand MkF and unF
05:46:26 <jusss> unF (MkF Int)::F ?
05:47:49 <dminuoso> jusss: MkF is just a regular data constructor, and unF is just a field accessor.
05:47:58 <dminuoso> (well you could actually make this a newtype instead I suppose)
05:48:06 <dminuoso> % newtype F = MkF { unF :: Int -> F }
05:48:06 <yahb> dminuoso: 
05:49:17 <jusss> dminuoso: in plain ADT?
05:50:00 <dminuoso> jusss: Yes.
05:50:02 <jusss> unF :: Mkf Int -> F ?
05:50:15 <dminuoso> jusss: unF :: F -> Int -> F
05:50:19 <dminuoso> % :t unF
05:50:19 <yahb> dminuoso: F -> Int -> F
05:50:35 <dminuoso> % :t MkF
05:50:35 <yahb> dminuoso: (Int -> F) -> F
05:52:27 <dminuoso> % f :: F; f = F (\i -> f)
05:52:27 <yahb> dminuoso: ; <interactive>:70:13: error: Data constructor not in scope: F :: (p0 -> F) -> F
05:52:31 <dminuoso> % f :: F; f = MkF (\i -> f)
05:52:32 <yahb> dminuoso: 
05:52:59 <jusss> dminuoso: wait, if unF :: F->Int-F and unF :: Mkf Int -> F are both correcte, then Mkf Int should equal to F -> Int
05:52:59 <dminuoso> % unF (unF (unF f 1) 2) 3 
05:52:59 <yahb> dminuoso: ; <interactive>:73:1: error:; * No instance for (Show F) arising from a use of `print'; * In a stmt of an interactive GHCi command: print it
05:53:02 <dminuoso> % :t unF (unF (unF f 1) 2) 3 
05:53:02 <yahb> dminuoso: F
05:53:21 <dminuoso> jusss: MkF is a data constructor.
05:53:33 <dminuoso> % :t unF (unF (unF (unF f 1) 2) 3) 4
05:53:34 <yahb> dminuoso: F
05:54:11 <jusss> dminuoso: but you use :t Mkf
05:54:18 <jusss> :t MkF
05:54:20 <lambdabot> error: Data constructor not in scope: MkF
05:55:03 <bolver> question: print . id 2 should be written as print . id $ 2, but if i define r = print id, then i can write r 2, instead of r $ 2.  is it because in the latter case, haskell parses it as (print . id) 2?
05:55:38 <dminuoso> jusss: Perhaps this helps: https://gist.github.com/dminuoso/87a25941122c1032d7f5545d47cb2f51
05:56:50 <dminuoso> bolver: `print . id 2` is different from `print . id $ 2`
05:57:08 <dminuoso> bolver: The first associates as `print . (id 2)`, which if you apply beta reduction is equal to `print . 2`
05:57:14 <bolver> dminuoso: correct
05:58:23 <jusss> dminuoso: ok, what's the trick to help that?
05:58:26 <bolver> yes, i know that, but why does the latter case, where if you define r = print . id, then r 2 work?
05:58:40 <dminuoso> jusss: I used GADTStyle notation to reduce the confusion between "whats in the type level" and "whats on the value level"
05:58:50 <dminuoso> jusss: There MkF and unF are value level constructs (they have type annotations!)
05:58:59 <dminuoso> *GADTSyntax
05:59:30 <dminuoso> bolver: Put imaginary parens around r
05:59:54 <dminuoso> So if you think of `r 2` as `(r) 2`, then you can apply mechanical substitution. :)
06:00:00 <jusss> dminuoso: err, I mean the help to that function return itself
06:00:06 <dminuoso> jusss: The function does that!
06:00:19 <dminuoso> If you write `f :: F` then that's a way to encode a function that returns itself.
06:00:23 <bolver> so in case of r = print . id, haskell does (print . id) 2?
06:00:25 <dminuoso> % :t f
06:00:25 <yahb> dminuoso: F
06:00:32 <dminuoso> % :t (unF f) 1
06:00:32 <yahb> dminuoso: F
06:00:37 <dminuoso> % :t (unF (unF f) 1) 2
06:00:37 <yahb> dminuoso: ; <interactive>:1:1: error:; * Couldn't match expected type `Integer -> t' with actual type `F'; * The function `unF' is applied to three arguments,; but its type `F -> Int -> F' has only two; In the expression: (unF (unF f) 1) 2; <interactive>:1:7: error:; * Couldn't match expected type `F' with actual type `Int -> F'; * Probable cause: `unF' is applied to too few arguments; 
06:00:49 <dminuoso> % :t unF ((unF f) 1) 2
06:00:49 <yahb> dminuoso: F
06:00:55 <dminuoso> % :t unF (unF ((unF f) 1) 2) 3
06:00:55 <yahb> dminuoso: F
06:01:00 * hackage net-spider-rpl 0.3.0.0 - NetSpider data model and utility for RPL networks  https://hackage.haskell.org/package/net-spider-rpl-0.3.0.0 (debugito)
06:01:07 <dminuoso> bolver: Yes. :)
06:01:37 <dminuoso> bolver: The relevant interaction here is the fixity of identifiers.
06:01:37 <bolver> dminuoso: ah, thanks ... i thought so!
06:02:02 <dminuoso> bolver: If you just subtitute a definition, ideally put parents around the identifier first.
06:02:13 <jusss> dminuoso: what about use this unF to print something like 1 2 3?
06:02:29 <dminuoso> So `r 2` becomes `(r) 2`, and then substitute r with its definition so it becomes `(print . id) 2`
06:02:29 <jusss> f(1)(2)(3) print 1 2 3
06:02:44 <dminuoso> jusss: Well this is just a function, we can't do IO here. :-)
06:03:36 <dminuoso> bolver: In the other case of `print . id $ 2` something else happens. It's not about about the definitions of `.` or `$`
06:04:27 <dminuoso> bolver: When you define an operator (well technically any identifier even!), you can define whether that operator is grammatically left or right associative. You can then further specifiy how much it is associative (we call this fixity)
06:04:54 <bolver> dminuoso: i see ... correct
06:04:57 <dminuoso> And that decides how things associate together (that is, where you could place redundant parens)
06:05:08 <dminuoso> % :i (.)
06:05:08 <yahb> dminuoso: (.) :: (b -> c) -> (a -> b) -> a -> c -- Defined in `GHC.Base'; infixr 9 .
06:05:11 <dminuoso> % :i ($)
06:05:11 <yahb> dminuoso: ($) :: (a -> b) -> a -> b -- Defined in `GHC.Base'; infixr 0 $
06:05:28 <bolver> dminuoso: correct
06:05:28 <dminuoso> bolver: ^- you can see that (.) is right-associative, with a fixity of 0. ($) is also right associative, but with a fixity of 0.
06:05:41 <dminuoso> Oops, (.) has a fixity of 9. :-)
06:06:01 <bolver> dminuoso: correct ... i wondered why you said 0
06:06:53 <dminuoso> bolver: Note that a higher number denotes higher predecence. So 9 is the highest precedence you can specify
06:07:05 <dminuoso> bolver: Function application (juxtaposition with a space in between) is considered to have precedence of 10.
06:07:11 <bolver> dminuoso: correct
06:07:51 <dminuoso> So `print . id 2` will associate as `print . (id 2)` and `print . id $ 2` will associate as `(print . id) $ 2`
06:07:51 <bolver> dminuoso: so in the case of r = print . id, r 2 parses as (r) 2?
06:08:22 <dminuoso> bolver: well sure, but the two topics are orthogonal.
06:08:40 <dminuoso> bolver: One is about how associativity works grammatically, and the other is how function definitions work.
06:09:25 <bolver> dminuoso: i understand the situation with print . id 2 and what the problem there is, but i wanted to understand how r 2 works
06:09:37 <dminuoso> bolver: The transfer from `r 2` to `(print . id) 2` is not one that happens automatically, it's one you can do manually.
06:09:50 <dminuoso> bolver: Because `r 2` is, optimizations aside, going to remain `r 2`
06:10:43 <bolver> dminuoso: but it does work automatically -- i mean i don't have to write r $ 2
06:10:56 <dminuoso> bolver: $ = id 
06:11:12 <dminuoso> bolver: $ is just a syntax trick to change associativity
06:11:35 <dminuoso> $ doesn't actually do anything, it's just an elaborate hoax by using an operator with the lowest possible fixity
06:11:48 <bolver> dminuoso: correct
06:12:46 <dminuoso> 15:10:22        bolver | dminuoso: but it does work automatically -- i mean i don't have to write r $ 2
06:13:05 <dminuoso> bolver: Well depends on how you look at it. The compiler isn't just going to replace r with its definitions (again as long as optimizations are disabled)
06:13:22 <dminuoso> Or rather, the language does not mandate this to happen.
06:13:35 <bolver> dminuoso: got it -- as you said earlier, r 2 is about about function definition
06:14:11 <dminuoso> Right. So the question of "how is function application evaluated" is very orthogonal to "how do things associate together"
06:14:13 <boxscape> what's the reason for .5 and 5. not being allowed in haskell?
06:14:57 <merijn> boxscape: makes parsing . in your head even harder
06:15:07 <merijn> boxscape: Also, when would you ever need to write 5. ?
06:16:01 <bolver> dminuoso: correct -- i had the gut feeeling along the same lines you mentioned, but i wanted to clarify things up.
06:16:08 <boxscape> merijn probably never really in haskell, though it would ensure that the type of the literal is an instance of Floating or something.
06:16:10 <bolver> dminuoso: thanks a bunch
06:16:17 <dminuoso> bolver: You are welcome.
06:16:31 <boxscape> maybe Fractional?
06:16:32 <merijn> boxscape: It'd be Rational, so that doesn't really narrow things down much
06:16:37 <merijn> eh, Fractional, not Rational
06:16:41 <boxscape> :t 5.0
06:16:43 <lambdabot> Fractional p => p
06:16:47 <boxscape> yea, okay
06:17:08 <boxscape> I find it quite useful in C but admittedly haskell is not C
06:17:35 <merijn> As for .5 I'd counter: is there any specific reason why that *should* be allowed?
06:18:13 <boxscape> it's allowed in a lot of other languages with IEEE754 support, which I'd argue speaks in its favor
06:18:22 <merijn> I don't see much value in "you can very occasionally leave out a single character and all it costs you is that parsing . (the most ambiguous character in Haskell) becomes *even more* ambiguous
06:18:31 <boxscape> that's fair
06:18:54 <merijn> boxscape: "f .5" <- is this f applied to '0.5' or is this 'f' composed with '5'?
06:19:20 <boxscape> Oh I guess 5 could be a function if you make a Num instance for functions, huh
06:19:24 <merijn> I don't think lambdabot still has it, but for years it had a function instance for numbers and I know there's some libraries that still have it
06:19:41 <merijn> The same argument actually also applies to "5."
06:19:56 <boxscape> doesn't it technically also apply to 5.5?
06:20:07 <dminuoso> boxscape: Sure, but at some point pragmatism comes.
06:20:12 <merijn> Well, no
06:20:26 <merijn> Because floating point literals are a single lexical element
06:20:57 <merijn> The proble with 5. and .5 is that now you have extended the possible elements representing Rationals with one that requires a choice
06:21:28 <merijn> boxscape: Similarly you're not allowed to write "Just.even" instead of "Just . even" because that gets parsed as a qualified name
06:21:40 <merijn> :t Just.even
06:21:42 <lambdabot> error:
06:21:42 <lambdabot>     Not in scope: ‘Just.even’
06:21:42 <lambdabot>     No module named ‘Just’ is imported.
06:21:55 <boxscape> I would argue you had to make that same choice when first deciding to lex 5.5 as a single element, but I admit that it's more justifiable
06:22:12 <merijn> boxscape: Which is already a confusing enough edge cases, adding more for little to no gain isn't great
06:22:48 <boxscape> :t (Just.Just).Just
06:22:49 <lambdabot> error:
06:22:49 <lambdabot>     Not in scope: data constructor ‘Just.Just’
06:22:50 <lambdabot>     No module named ‘Just’ is imported.
06:33:32 <dminuoso> Haha I tricked myself into believing that eta-reduction from `e x = e x` was a valid thing.
06:33:48 <dminuoso> Turns out that `e x = e x` is very different from `e = e` :D
06:34:03 <dminuoso> (Assuming that e is a method and this is inside an instance declaration)
06:36:27 <dminuoso> It's interesting that `instance Show T where show = show` is different from `instance Show T where show s = show s`, but what's the exact reason for this
06:36:44 <dminuoso> (I mean I get what the difference is, but not why)
06:37:52 <jusss> dminuoso: about IO, can we have a simple function that just do it? like print in python, printf in C, println in kotlin, console.log in javascript, can we have a simple function that just do it?
06:38:14 <merijn> :t print -- seems like a simple function?
06:38:15 <lambdabot> Show a => a -> IO ()
06:38:16 <dminuoso> jusss: When we say function we mean something different from what these languages call functions.
06:38:33 <c_wraith> merijn: print is a simple function, but it doesn't *do* the IO
06:38:43 <dminuoso> jusss: What python/C/kotlin/javascript calls functions, we call procedures/actions.
06:38:44 <jusss> dminuoso: but haskell is really make me hard to code...
06:38:58 <merijn> c_wraith: Depending on how we define "it", "do", and "IO" :)
06:39:02 <dminuoso> jusss: Because Haskell forces you to unlearn some bad habits you have picked up.
06:39:26 <jusss> dminuoso: I learn haskell several months, but I really don't write code or I can't, it's so hard to code
06:39:56 <dminuoso> jusss: Learning Haskell can often feel like you are learning programming all over from scratch again.
06:40:15 <dminuoso> jusss: Note that this is not because Haskell is hard, its just that there's some fundamental differences you need to wrap your head around first.
06:40:26 <c_wraith> jusss: I think you might be overthinking things.  It's not *hard*, it's just *new*.  There's a lot to learn, but it isn't difficult for the sake of being difficult.  It's not difficult to gatekeep.  It's just different.
06:41:02 <jusss> dminuoso: c_wraith those concepts is hard
06:41:11 <jusss> are hard to understand
06:41:17 <dminuoso> jusss: They are just unfamiliar.
06:41:31 <dminuoso> jusss: Here's my advice for you: Stop comparing things with Python/Kotlin/JavaScript.
06:41:43 <dminuoso> Treat Haskell like something completely new.
06:42:09 <dminuoso> You can revisit drawing comparisons later when you have basic proficiencies, at which point you might have some interesting revelations.
06:42:23 <jusss> dminuoso: but that comparing can help me to learn haskell, see what they're looks like in haskell, and what're different between those
06:42:26 <dminuoso> But until then, it's probably more effective to just reshape your head and accept all of this as new paradigms.
06:42:43 <merijn> jusss: The problem is that comparing *won't* help, because it's too different
06:43:00 * hackage cachix 0.3.4 - Command line client for Nix binary cache hosting https://cachix.org  https://hackage.haskell.org/package/cachix-0.3.4 (domenkozar)
06:44:19 <dminuoso> jusss: Most of the "traditional languages" are very similar to each other behind the seams, which is why comparing features between them is a useful technique. For example JavaScript, Ruby, Python, Perl... they are all essentially just different shades of the same color. Their differences are just minor ergonomics.
06:44:44 <dminuoso> Any Python knowledge is instantly transferrable to the other languages there.
06:45:39 <jusss> dminuoso: and FPs? Idris, Scala, OCaml, and Haskell?
06:46:04 <jusss> can they be comparing?
06:46:07 <c_wraith> There's a lot of difference in that set
06:46:14 <merijn> Not sure about Scala, but OCaml and Idris can be compared with Haskell much easier
06:46:47 <merijn> c_wraith: Sure, lots of difference, but comparing Haskell to those is bound to be infinitely more constructive than comparing with Python :)
06:47:01 <c_wraith> Scala depends on the specific code.  It's often used as slightly more expressive java.  In that case, it won't help.
06:47:35 <dminuoso> jusss: I think at the end, it's easier to learn a language from its semantics, not by creating mental bridges where "oh feature XYZ is just feature ABC in language Y"
06:47:36 <jusss> actually my first FP language is Elm, and I found that I can't understand it, so I start with Haskell, and then I found I jump into an endless hole...
06:47:37 <merijn> I'll grant you Scala is the least likely to be helpful of those
06:47:44 <dminuoso> jusss: These bridges can be built later *after* having learned the language.
06:48:07 <dminuoso> jusss: Does that make any sense?
06:49:14 <jusss> dminuoso: yeah, but only after "learned"
06:52:23 <c_wraith> jusss: if it helps, I promise there's a certain elegance to Haskell's approach.  It's not perfect because nothing can be, but it is a well-reasoned set of tradeoffs.
06:53:15 <c_wraith> which is to day - I think it's worth learning for itself, not just for how it relates to other things.
06:53:44 <jusss> c_wraith: haha, 
06:54:17 * jusss sorry to the complaint
06:54:50 <jusss> about
06:54:58 <dminuoso> Haskell sure has a lot of issues, but its gotten more things right than wrong. :-)
06:55:15 <boxscape> (and it's getting better all the time!)
06:55:17 <jusss> the type stuff really make me hard to code
06:55:40 <dminuoso> jusss: If its any consolation, I find that once you learn to navigate the type system, it will be your best friend.
06:56:11 <jusss> dminuoso: I wonder if one day we can handle the infinite type ? or recursive type?
06:56:42 <dminuoso> jusss: Well we can express such types like I showed you.
06:56:58 <jusss> dminuoso: with unF :: F -> Int -> F ?
06:59:37 <jusss> dminuoso: sorry, I don't understand what MkF is used to, unF take a function and an Int, apply that Int on the function, and return that function, that's ok, but Mkf :: (Int -> F) -> F, what this suppose to do?
07:00:41 <dminuoso> jusss: Why don't we focus on something more productive. Why do you want such a function in the first place?
07:01:06 <dminuoso> What's the underlying problem for which you think such a tool would be the solution?
07:01:34 <jusss> dminuoso: 'cause other languages do that... 
07:02:05 <dminuoso> jusss: That's not an answer to my question.
07:02:24 <dminuoso> Well it is, if you didn't read my clarification that followed. :)
07:03:31 <jusss> dminuoso: you mean 
07:03:31 <jusss> <dminuoso> % :t unF (unF (unF (unF f 1) 2) 3) 4
07:03:31 <jusss> <yahb> dminuoso: F
07:03:31 <jusss> <jusss> dminuoso: but you use :t Mkf  [20:53]
07:03:35 <jusss> <jusss> :t MkF
07:03:38 <jusss> <lambdabot> error: Data constructor not in scope: MkF
07:03:41 <jusss> *** Ariakenom_ (~Ariakenom@h-208-40.A163.corp.bahnhof.se) has joined channel
07:03:44 <jusss>     #haskell  [20:54]
07:03:47 <jusss> <bolver> question: print . id 2 should be written as print . id $ 2, but if i
07:03:50 <jusss> 	 define r = print id, then i can write r 2, instead of r $ 2.  is it
07:03:53 <jusss> 	 because in the latter case, haskell parses it as (print . id) 2?
07:03:56 <jusss> *** rruizt (~rruizt@83-84-23-124.cable.dynamic.v4.ziggo.nl) has joined channel
07:03:59 <jusss>     #haskell
07:04:03 <jusss> <dminuoso> jusss: Perhaps this helps:
07:04:06 <jusss> 	   https://gist.github.com/dminuoso/87a25941122c1032d7f5545d47cb2f51
07:04:09 <jusss> *** Ariakenom_ (~Ariakenom@h-208-40.A163.corp.bahnhof.se) has quit: Remote
07:04:12 <jusss>     host closed the connection  [20:55]
07:04:15 <jusss> <dminuoso> bolver: `print . id 2` is different from `print . id $ 2`  [20:56]
07:04:19 <jusss> *** Nosh (a2f7570a@162.247.87.10) has quit: Remote host closed the connection
07:04:19 <jusss> <dminuoso> bolver: The first associates as `print . (id 2)`, which if you
07:04:22 <jusss> 	   apply beta reduction is equal to `print . 2`
07:04:27 <jusss> <bolver> dminuoso: correct
07:04:27 <dminuoso> @ops
07:04:27 <lambdabot> Maybe you meant: pl oeis docs
07:04:38 <dminuoso> Well. I guess that was the kline :-)
07:05:12 <int-e> it was @where ops, wasn't it?
07:05:27 <merijn> int-e: No, exceeded the lines threshold
07:05:47 <boxscape> % let f x = unsafeCoerce (print x >> pure f) in f 6 7 -- awww :(
07:05:47 <yahb> boxscape: 6; [Segmentation fault]
07:06:01 <boxscape> not unexpected, but worth a try, maybe
07:06:21 <dminuoso> int-e: Indeed.
07:06:24 <int-e> boxscape: hmm hmm. try passing a Proxy value instead?
07:06:46 <boxscape> Not sure in what way
07:06:49 <dminuoso> boxscape: Just dont show that when juss comes back. :-)
07:07:04 <boxscape> okay ;0
07:07:11 <boxscape> s/0/)
07:07:55 <dminuoso> % newtype F = F (Int -> IO F); 
07:07:56 <yahb> dminuoso: 
07:08:06 <dminuoso> % newtype F = F { unF :: Int -> IO F }
07:08:06 <yahb> dminuoso: 
07:08:34 <dminuoso> % f = F (\i -> print i >> pure f)
07:08:34 <yahb> dminuoso: 
07:08:50 <dminuoso> I suppose something along those lines would be a direct copy
07:09:54 <dminuoso> Though not quite
07:10:08 <int-e> boxscape: Using GHC.Exts.proxy#: f 6 proxy# :: ()  doesn't crash.
07:10:22 <jusss> sorry, ERC crashed!
07:10:53 <boxscape> int-e hmm, it also doesn't produce the desired behviour of printing 7 though
07:10:54 <jusss> dminuoso: you said Mkf is a data constructor?
07:11:08 <dminuoso> jusss: Please don't spam the channel. It's what got you disconnected.
07:11:26 <dminuoso> jusss: No my question is: Do you have a concrete problem that you believe mandates this solution?
07:11:28 <jusss> dminuoso: sorry, I don't mean that, it's my ERC...
07:11:56 <int-e> boxscape: you can get that with f 6 proxy# 7 proxy# :: ()
07:12:05 <boxscape> int-e oh, nice!
07:12:19 <jusss> dminuoso: actually I do have a concrete problem, but the original code is java, so ...
07:12:29 <dminuoso> jusss: Problems are not in any language.
07:12:33 <dminuoso> jusss: What's the problem?
07:12:36 <int-e> boxscape: obviously this is really dirty magic :)
07:12:43 <dminuoso> Or are you just trying to translate your Java code into Haskell?
07:13:02 <jusss> dminuoso: do you want the code or just describe?
07:13:27 <jusss> dminuoso: no, that's a common issue, not just java or haskell
07:13:34 <dminuoso> jusss: What's that common issue?
07:13:51 <jusss> dminuoso: can a function return itself
07:14:12 <dminuoso> jusss: That's a solution, not the underlying problem.
07:14:19 <dminuoso> Or rather, a possible solution.
07:14:28 <tdammers> > let f x = f -- let's find out!
07:14:30 <lambdabot>  <no location info>: error:
07:14:30 <lambdabot>      not an expression: ‘let f x = f -- let's find out!’
07:14:38 <tdammers> @let f x = f -- let's find out!
07:14:39 <lambdabot>  .L.hs:180:7: error:
07:14:39 <lambdabot>      Ambiguous occurrence ‘f’
07:14:39 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f’,
07:14:42 <tdammers> aww
07:14:47 <merijn> tdammers: Foiled by simple-reflect
07:14:53 <tdammers> awwoof
07:14:54 <boxscape> int-e yeah I'm still trying to figure out what's happening
07:15:02 <tdammers> @let ffs x = ffs -- let's find out!
07:15:03 <lambdabot>  .L.hs:180:1: error:
07:15:04 <lambdabot>      • Occurs check: cannot construct the infinite type: t ~ p0 -> t
07:15:04 <lambdabot>      • Relevant bindings include ffs :: t (bound at .L.hs:180:1)
07:15:20 <tdammers> see how that says "infinite type"? gee...
07:15:35 <dminuoso> jusss: The point Im trying to make is, you cant make this easily in Haskell. But, this is not a problem in the slightest
07:15:35 <boxscape> int-e no spoilers though!
07:15:39 <dminuoso> jusss: You dont need such a primitive.
07:15:51 <dminuoso> jusss: In fact in all my career I cant recall ever seeing or needing such a construct.
07:16:10 <dminuoso> It's certainly not a necessary construct. Whatever your use case, you can solve your problem without it.
07:16:45 <dminuoso> Prelude.head: empty list
07:16:51 <dminuoso> Thanks library authors.
07:17:22 <jusss> dminuoso: actually it's an android problem, I need to write lots of same methods in an class, so I wonder if I can return the method itself, so I can call it by the chain like f(1)(2)(3), and then I found out Java doesn't have first class functions, and then I wonder can I do that in kotlin, because I can use kotlin in android too, and I found kotlin can return itself several time only if I point out the type, so I recall it's so easy
07:17:22 <jusss> to do in python or js, why it's so hard on those static type languages, and then I asked here, 
07:17:56 <jusss> I did that same thing in python, javascript, kotlin, and I can't do it in java, so I wonder in haskell
07:18:30 * hackage reanimate 0.1.8.0 - Animation library based on SVGs.  https://hackage.haskell.org/package/reanimate-0.1.8.0 (DavidHimmelstrup)
07:18:38 <dminuoso> jusss: And Im telling you that translating such rudimentary cludges into other languages is not necessarily helpful.
07:18:47 <boxscape> oh wow I didn't realize until now that GHC.Prim isn't in base
07:18:49 <dminuoso> jusss: This is a trick you can employ in untyped languages, but its not necessarily a good trick.
07:19:14 <dminuoso> jusss: If you can do `f(1)(2)(3)` you can also just do f(1); f(2); f(3);
07:19:30 <dminuoso> jusss: And lose that weird self-referencing circle which buys you nothing.
07:19:50 <dminuoso> So in Haskell you'd just do `f 1 >> f 2 >> f 3` instead.
07:20:41 <jusss> dminuoso: the point is the sequence, in that java code, f is async, I want that (2) to wait f(1)
07:20:52 <dminuoso> jusss: In some degree, being unable to translate something into Haskells type system can often, but not always, mean that your idea is off.
07:21:13 <dminuoso> jusss: Great! We have a tool for that.
07:21:15 <jusss> dminuoso: but f(1); f(2); f(3); f(3) may run first, which is not I want
07:21:22 <dminuoso> jusss: it's captured by `f1 >> f2 >> f3 >> ...`
07:21:50 <jusss> dminuoso: so I have to implement >> in java first?
07:21:58 <dminuoso> jusss: This is not #java
07:22:10 <jusss> dminuoso: :)
07:22:27 <Ariakenom> :t (>>)
07:22:29 <lambdabot> Monad m => m a -> m b -> m b
07:22:46 <Ariakenom> don't implement that in java :)
07:23:15 <jusss> dminuoso: I think translating in langauges are funny :)
07:23:23 <geekosaur> when it works
07:23:40 <jusss> yeah, only when it works, it's funny
07:24:25 <jusss> the most languages have the common concepts, like monad, continuation, closure, blablablah,
07:26:17 <jusss> and the magic is lambda, if we translate our code into lambda, does it mean we can use it on those languages as soon as possible?
07:26:21 <dminuoso> Mmm, how can I find error exceptions thrown in libraries?
07:26:40 <merijn> dminuoso: Read the documentation
07:26:59 <merijn> dminuoso: If those doesn't mention them, you flog the maintainer until it does
07:27:05 <dminuoso> merijn: Some transitive library somewhere is using `head`, and I dont know which.
07:27:25 <merijn> dminuoso: oh, so you just want a stack trace?
07:27:27 <boxscape> I assume if ghc says "report this as a bug" while you're using unsafeCoerce that doesn't mean that you should report that crash as a bug, right?
07:27:40 <merijn> boxscape: pastebin the full message?
07:27:46 <dminuoso> merijn: Mmm. Yes.
07:27:49 <boxscape> % unsafeCoerce 140527955706112000000000000000000 :: [Integer]
07:27:50 <yahb> boxscape: [<interactive>: internal error: ARR_WORDS object entered!; (GHC version 8.6.0.20180620 for x86_64_unknown_linux); Please report this as a GHC bug: http://www.haskell.org/ghc/reportabug; [Aborted]
07:27:51 <merijn> dminuoso: Compile with profiling and run with +RTS -xc
07:28:15 <boxscape> (i got that number from unsafeCoercing [1..5] as Integer)
07:28:24 <merijn> boxscape: oh, that's just ghci intercepting a segfault
07:28:28 <boxscape> I see
07:28:33 <merijn> (at least, I'm assuming it's segfaulting or something)
07:29:02 <boxscape> hm, sometimes yahb just says [segmentation fault], so maybe something subtly different
07:29:04 <merijn> boxscape: If you'd written that code in a file and GHC had given that error, then it would be a bug :)
07:29:11 <boxscape> ah, I see
07:29:24 <merijn> boxscape: The mixup here is the wrong code and ghci being the same process :)
07:29:32 <boxscape> okay
07:29:48 <merijn> boxscape: But in principle unsafeCoerce should never crash your compiler (it's very likely to crash the compiled code, obviously)
07:30:00 <boxscape> okay
07:31:40 <boxscape> merijn hm so
07:31:45 <boxscape> it does happen if I enter it in a file
07:31:47 <boxscape> and compile it
07:31:48 <boxscape> and run it
07:32:08 <boxscape> but waut
07:32:10 <boxscape> wait*
07:32:12 <boxscape> that's fine
07:32:19 <boxscape> it doesn't crash the compiler
07:32:28 <merijn> boxscape: Well yes, it's trying to turn some random number into a pointer into a list, obviously that crashes :)
07:32:34 <boxscape> but the message isn't any different because of ghci, which is worth noting
07:33:23 <geekosaur> right, it'll dpeend on the exact number instead as to how it goes wrong
07:33:29 <boxscape> okay
07:33:56 <geekosaur> some will segfault as invalid pointers, some will point to random memory and you'll get weirdness or just possibly some unexpected value if it somehow managed to make sense as a value
07:34:45 <boxscape> (although intuitively I would've expected coercing from a list to an int and back to work just fine, and it does work if I do it in one step)
07:35:11 <boxscape> s/int/Integer
07:35:41 <geekosaur> as long as you don't try to look at the thing pointed to (remember normal values in Haskell are boxed, hence pointers)
07:35:47 <boxscape> I see
07:36:05 <geekosaur> @quote unsafeCoerce.*unsafeCoerce.*unsafeCoerce
07:36:05 <lambdabot> monochrom says: isTrue = (unsafeCoerce :: Either a b -> Bool) . (unsafeCoerce :: Maybe c -> Either a b) . (unsafeCoerce :: Bool -> Maybe c)
07:36:23 <merijn> boxscape: unsafeCoerce is basically the Haskell equivalent of "let's cast this to a random pointer and see what happens" in C
07:37:01 <merijn> The name doesn't quite adequately describe how unsafe it is compared to, say, unsafePerformIO
07:37:15 <merijn> Maybe it should've been reallyUnsafeCoerce :p
07:37:28 <geekosaur> it's not quite a malevolent agent of chaos :)
07:37:32 <merijn> ;)
07:37:46 <merijn> geekosaur: I've always been fond of reallyUnsafePtrEquality# too
07:38:20 <dminuoso> accursedUnutterablePerformIO still holds a special place in my heart.
07:39:46 <boxscape> so if unsafeCoerce [1..5] :: Integer gives me a number, what's the actual difference between using that value and using a different Integer with that value? Obviously the address is different, but I don't think that by itself should matter - can the actual contents of that address be different, making the first coercible back to a list but not the
07:39:46 <boxscape> second?
07:40:31 <nshepperd> boxscape: it doesn't work because some of that Integer is a the bits of a pointer to where the tail of the list was allocated
07:40:35 <Taneb> Well, the second won't have a rest of the list after it
07:41:02 <merijn> Taneb: I'm not sure of that
07:41:11 <geekosaur> that depends. consider that an Integer has 3 constructors: small values are actually encoded as Ints, or positive or negative GMP bigint
07:41:12 <nshepperd> which won't exist once the list is garbage collected
07:41:22 <geekosaur> and the result of a calculation may get you a small value in a bigint
07:41:27 <boxscape>  hmm, it looks like unsafeCoerce [1,2,3,4,5] is different from unsafeCoerce [1..5]
07:41:50 <geekosaur> so there's somee trickiness underneath you need to know to be certain what will happen
07:41:55 <boxscape> okay
07:42:09 <geekosaur> likewise that since one is literal and one may be an unevaluated thunk. which won't be forced by unsafeCoerce
07:42:24 <boxscape> I see
07:42:24 <geekosaur> "[1..5]" is actually "enumFromTo 1 5"
07:43:01 <boxscape> so the actual function application is coerced into an Integer?
07:43:14 <geekosaur> and ghc won't expand it while compiling (someday more clever constant folding would be nice, but...)
07:43:48 <geekosaur> yes. pointer to a closure, I think, although it's a trivial closure here
07:44:01 <nshepperd> huh, let xs = [1..5] in unsafeCoerce xs :: Integer freezes ghci
07:44:36 <geekosaur> it'ss trying to print them. I think that goes wrong at 3?
07:45:10 <boxscape> unsafeCoerce [undefined] :: Integer *sometimes* freezes ghci, and sometimes returns a really large number
07:45:13 <boxscape> or wait
07:45:19 <boxscape> it's just a much larger number this time
07:45:23 <boxscape> tha's why it froze for a while
07:45:38 <boxscape> (orders of magnitude longer...)
07:46:16 <geekosaur> you didn't need that memory anyway :)
07:46:24 <boxscape> it's still printing...
07:58:03 <boxscape> (got around 10^150 million)
07:58:46 <dminuoso> merijn: Sigh. The beauty of this code: getCode = read . head . words
07:59:00 <merijn> dminuoso: ick
07:59:04 <merijn> dminuoso: Where'd you find that?
07:59:12 <dminuoso> merijn: HaskellNet-SSL
07:59:36 <merijn> I...wouldn't trust that with my SSL anymore :p
07:59:46 <dminuoso> Heh that was my exact same thought.
07:59:59 <dminuoso> Luckily it seems like the tls integration is rather simple.
08:01:02 <bolver> question: what is the O(n) for list1 == list2?  is it O(n^2)?
08:01:14 <dminuoso> bolver: With respect to what cost?
08:01:32 <bolver> dminuoso: time
08:01:39 <merijn> bolver: Depends on whether you ever look at that Bool ;)
08:01:47 <dminuoso> Sneaky.
08:02:00 <merijn> But it's O(n)
08:02:09 <merijn> Why would it be n^2?
08:02:42 <bolver> merijn: because each element has to be compared
08:02:47 <merijn> So?
08:02:55 <merijn> That's only linear in the length of the list...
08:03:07 <bolver> n * n comparisons
08:03:10 <dminuoso> No.
08:03:11 <boxscape> bolver if the two lists contain the same element in different orders, what would you expect list1 == list2 to return?
08:03:11 <merijn> No
08:03:15 <dminuoso> boxscape: The implementation is:
08:03:16 <merijn> boxscape: That's n comparisons
08:03:35 <bolver> boxscape: false
08:03:40 <dminuoso> instance Eq a where (x:xs) == (y:ys) = x == y && xs == ys; ...
08:03:51 <boxscape> bolver okay, that's right
08:03:52 <dminuoso> Plus some pattern for the empty list.
08:04:12 <dminuoso> boxscape: You basically navigate both spines in parallel, once one side is different you stop.
08:04:32 <boxscape> ^ meant for bolver I think
08:04:38 <iqubic`> testing
08:04:57 <bolver> dminuoso: so it is O(n)?
08:05:50 <bolver> yeah, got it, it is O(n)
08:06:05 <bolver> merijn: thanks
08:06:57 <bolver> dminuoso: thnaks
08:21:49 <Aknj625> hi guys
08:22:13 <Aknj625> can anyone tell me about divergence in haskell pattern matching...?
08:23:32 <dmwit> Sure.
08:23:40 <Aknj625> oh ...thank you
08:24:08 <dmwit> If you make a data constructor pattern match on a computation that diverges, then the computation doing the match diverges.
08:24:17 <dmwit> There's... not a ton more to say than that, I think.
08:25:00 <dmwit> I guess there's a bit more, which is that there's a first pass made by the compiler that turns nested patterns into single-level pattern matches.
08:25:11 <Aknj625> can u explain with example..
08:25:17 <geekosaur> diverge here meaning it's an infinite value, undefined, or otherwise doesn't terminate normally (runs on forever or throws an exception or crashes)
08:25:30 <dmwit> For example, `case foo of (Just bar, baz) -> quux` gets compiled to `case foo of (bar', baz) -> case bar' of Just bar -> quux`.
08:25:32 <Aknj625> i am new to haskell....dont understand the terminologies
08:26:22 <dmwit> > case let diverge = diverge in diverge of () -> "we never get here" -- an example for you, Aknj625
08:26:26 <lambdabot>  "*Exception: <<loop>>
08:26:50 <dmwit> `let diverge = diverge in diverge` is the diverging computation. `()` is the data constructor pattern.
08:26:55 <Aknj625> ok..i was looking for an answer for this question
08:26:58 <Aknj625> Explain why Haskell is able to succesfully evaluate zip [1,2,3] [1..] without
08:27:24 <geekosaur> because zip stops with the shorter list
08:27:36 <Aknj625> ok..
08:27:46 <geekosaur> and leaves the rest of the infinite one unevaluated. this is demand-driven evaluation, or what is commonly called laziness
08:28:12 <Aknj625> what i understand is if one of the input parameter is infinite...then pattern matching can go diverging
08:28:24 <geekosaur> sometimes you will hear someon e talk about "thunks
08:28:26 <dmwit> No, infinite and diverging are not the same thing.
08:28:55 <geekosaur> ". this is a chunk of code that hasn't been evaluated yet, that should either roduce a value or diverge when evaluated. it will normally be evaluated only as far as needed to produce the next value
08:28:57 <dmwit> [1..] is infinite but not diverging.
08:28:58 <Aknj625> hm..
08:29:33 <geekosaur> "length [1..]" will diverge because it tries to produce all values in a list. "take 2 [1..]" will not diverge because it only needs two values and discards the rest of the infin ite list
08:29:58 <dmwit> (By comparison, you might say that `loop :: (); loop = loop` is not infinite but is diverging. And `x = [1,2,3]` is neither infinite nor diverging.)
08:30:27 <geekosaur> er, all values in an infinite list
08:30:42 <Aknj625> so...diverging happens when we dont get definite result for pattern matching
08:30:42 <Aknj625> ??
08:30:44 <geekosaur> > take 2 [1..] -- [1,2]
08:30:46 <lambdabot>  [1,2]
08:30:55 <dmwit> Aknj625: I think that's one sensible summary, yes.
08:31:09 <Aknj625> oh....thank you
08:31:46 <dmwit> Aknj625: diverging means you can keep computing as long as you want, and never arrive at a term that is an application of a data constructor to some subterms.
08:31:58 <dmwit> (Plus some niggles about never arriving at a lambda.)
08:31:59 <Aknj625> perfect
08:33:16 <dmwit> [1..] pretty much immediately becomes the application of a data constructor to some subterms.
08:33:31 <dmwit> Because it immediately, after one computation step, becomes 1 : [2..], and (:) is a data constructor.
08:33:54 <dmwit> (Well, if we're being careful, it becomes 1 : [1+1..], okay.)
08:34:12 <EvanR> there's the concept of doing computation steps until you get a constructor or lambda
08:34:19 <EvanR> it may take many steps
08:34:29 <EvanR> but if it takes infinite steps, this is diverging
08:35:12 <nil> dmwit: not `1 : [succ 1..]` ? :)
08:35:24 <dmwit> I think no.
08:35:52 <nil> oh well
08:36:32 <dmwit> From the Report: "The sequence enumFrom e_1 is the list [e_1,e_1+1,e_1+2,...]."
08:36:54 <EvanR> :t enumFrom
08:36:55 <lambdabot> Enum a => a -> [a]
08:37:27 <dmwit> (This applies only to Int, Integer, Float, and Double, of course. Your custom Num/Enum instance may do something else.)
08:37:27 <EvanR> so it's mapping back and forth from Int 
08:37:48 <EvanR> oh right
08:40:37 <dmwit> Of course the whole argument is moot because the Report just specifies the behavior, and the implementation is waaaay more complicated and loops on an unboxed thing when it can and stuff like that.
08:41:54 <dmwit> Hm, interesting. I wonder if the Double instance actually conforms to the spec.
08:41:54 <Ariakenom> yes lots of hashes
08:42:03 <dmwit> > 2^53 == (2^53+2 :: Double)
08:42:06 <lambdabot>  False
08:42:24 <Ariakenom> and I presume the highly technical term blarg
08:42:24 <Ariakenom> -- Blarg: technically I guess enumFrom isn't strict!
08:42:25 <dmwit> > let xs = [2^53..] in head xs == (xs !! 2 :: Double)
08:42:27 <lambdabot>  False
08:42:32 <dmwit> Wow, it does!
08:44:16 <EvanR> > [2^53 ..] :: Double
08:44:18 <lambdabot>  error:
08:44:18 <lambdabot>      • Couldn't match expected type ‘Double’
08:44:18 <lambdabot>                    with actual type ‘[Integer]’
08:44:24 <EvanR> > [2^53 ..] :: [Double]
08:44:26 <lambdabot>  [9.007199254740992e15,9.007199254740992e15,9.007199254740994e15,9.0071992547...
08:44:40 <EvanR> nice
08:44:59 <EvanR> that explains why it needs to be +1, +2, 
08:45:03 <dmwit> indeed
08:45:07 <EvanR> Double would get stuff succing
08:45:10 <EvanR> stuck*
08:45:37 <EvanR> > succ 9.007199254740992e15
08:45:39 <lambdabot>  9.007199254740992e15
08:45:52 <dmwit> > 2^53+3 :: Double
08:45:54 <lambdabot>  9.007199254740996e15
08:45:58 <dmwit> hehe
08:46:16 <EvanR> wth...
08:46:24 <EvanR> oh it's right
08:46:26 <geekosaur> have some IEEE
08:46:27 <EvanR> no
08:46:27 <dmwit> > zipWith (==) [2^53..] (drop 1 [2^53 :: Double ..])
08:46:29 <lambdabot>  [True,False,False,True,True,False,False,True,True,False,False,True,True,Fals...
08:46:39 <dmwit> EvanR: Yes, it's right. Banker's rounding ^_^
08:46:49 <aveltras> does anyone have an example repo of a web application written using free monad ? (ideally polysemy)
08:47:28 <jusss> dminuoso: your unF seems like const?
08:47:32 <jusss> :t const
08:47:33 <lambdabot> a -> b -> a
08:48:40 <jusss> % :t unF
08:48:41 <yahb> jusss: ; <interactive>:1:1: error:; * Variable not in scope: unF; * Perhaps you meant `un' (imported from Control.Lens)
08:49:03 <jusss> % newtype F = MkF { unF :: Int -> F }
08:49:03 <yahb> jusss: 
08:49:14 <jusss> % :t unF
08:49:14 <yahb> jusss: F -> Int -> F
08:50:55 <dmwit> It is not const.
08:51:14 <dmwit> Well.
08:51:23 <dmwit> hm =)
08:52:13 <jusss> dmwit: more details?
08:53:43 <Aknj625> i have question
08:53:58 <Aknj625> how much haskell developer get paid??
08:54:09 <Aknj625> i am js developer...just wondering
08:54:10 <jusss> return = const in the Reader Monad IIRC, const is an interesting function
08:55:51 <jusss> why not people just use the plain ADT... 
08:58:53 <jgt> Aknj625: how much you get paid depends on much more than what language you write most of your code in
08:59:53 <Aknj625> god bless you
09:00:10 * jgt #blessed like Lewis Hamilton
09:00:24 <Guest51893> Hi, can someone explain the difference between Fractional and Floating ?
09:01:02 <boxscape> % :i Floating
09:01:03 <yahb> boxscape: class Fractional a => Floating a where; pi :: a; exp :: a -> a; log :: a -> a; sqrt :: a -> a; (**) :: a -> a -> a; logBase :: a -> a -> a; sin :: a -> a; cos :: a -> a; tan :: a -> a; asin :: a -> a; acos :: a -> a; atan :: a -> a; sinh :: a -> a; cosh :: a -> a; tanh :: a -> a; asinh :: a -> a; acosh :: a -> a; atanh :: a -> a; log1p :: a -> a; expm1 :: a -> a; log1pexp :: a
09:01:28 <tabaqui1> % :set -XPatternSynonyms
09:01:28 <yahb> tabaqui1: 
09:01:32 <Guest51893> % :i Fractional
09:01:32 <yahb> Guest51893: class Num a => Fractional a where; (/) :: a -> a -> a; recip :: a -> a; fromRational :: Rational -> a; {-# MINIMAL fromRational, (recip | (/)) #-}; -- Defined in `GHC.Real'; instance Integral a => Fractional (Ratio a) -- Defined in `GHC.Real'; instance Fractional a => Fractional (Identity a) -- Defined in `Data.Functor.Identity'; instance forall a k (b :: k). Fractional a => Fractional (Const a
09:01:33 <tabaqui1> % data Foo = Foo Int
09:01:33 <yahb> tabaqui1: 
09:01:38 <tabaqui1> % pattern F x = Foo x
09:01:38 <yahb> tabaqui1: 
09:01:40 <Guest51893> WoAH
09:01:41 <boxscape> Floating has a whole bunch of methods defined that Fractional instances don't need to implement
09:01:44 <tabaqui1> % bar :: Foo -> Int; bar (F x) = x
09:01:44 <yahb> tabaqui1: 
09:01:47 <tabaqui1> uh
09:02:11 <tabaqui1> well, if you type these lines in your ghci, you'll get a warning "Pattern match(es) are non-exhaustive: _"
09:02:19 <tabaqui1> which is incorrect of course
09:02:23 <Guest51893> boxscape so is float and double floating ?
09:02:41 <Guest51893> and so fractional too?
09:02:51 <boxscape> yes, there are Floating instances for Float and Double in the Prelude, Guest51893
09:02:58 <boxscape> and yes that makes them Fractional as well
09:03:03 <Guest51893> okay thanks a lot
09:19:04 <jle`> tabaqui1: if you're asking a question about how to fix that, you can add COMPLETE pragmas to your pattern
09:19:14 <jle`> {-# COMPLETE F #-}
09:20:01 <jle`> but actually hm in that specific case it would make sense for GHC to be able to verify it is complete. i guess maybe it just defers to letting the user specify, in case they want to define their own behavior
09:51:52 <sdx23> Hi. What is currently the recommended vim setup with haskell? Two years ago I had syntastic with ghc-mod and hdevtools. Meanwhile ghc-mod died and hdevtools seems to have problems with stack. I saw haskell-ide-engine, but that hardly compiles on my not too modern machine. Also it seems too much for what I want: mainly mark erroneous pieces of code, type annotation would be a plus but not required.
09:56:00 <glguy> sdx23: I prefer running ghcid along side my editor. It's really easy to set up and almost always works without extra configuration fussing
09:56:52 <boxscape> sdx23 haskell-ide-engine worked really well for me for a bit before cabal 3 came along, it should still work pretty well with cabal 2 and coc.nvim
09:57:21 <boxscape> But I don't think there's one recommended setup
09:59:23 <sdx23> glguy: thanks, I almost forgot about that. I guess that'll be my fallback solution. I really like ":Errors" and the jump mechanism in vim, but if need be I'll do without that.
10:02:06 <sdx23> boxscape: my problem with haskell-ide-engine was that it crashed my machine by eating all the memory(4G) while compiling. I tried it (with LanguageServer-client plugin) on some newer desktop and it seemed slow. It might be better with coc, I have no idea. But your comment regarding cabal3 lets me doubt I really want to put in the effort to get it to run.
10:03:19 <boxscape> sdx23 apparently there's a branch of it that supports cabal3, but yeah, not master at the moment
10:11:30 * hackage vty 5.26 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.26 (JonathanDaugherty)
10:28:13 <aveltras> anyone successfully running latest polysemy-plugin using nix package management ? 
10:29:00 * hackage hnock 0.4.0 - A Nock interpreter.  https://hackage.haskell.org/package/hnock-0.4.0 (JaredTobin)
10:32:30 * hackage chs-deps 0.1.0.0 - c2hs dependency analyzer  https://hackage.haskell.org/package/chs-deps-0.1.0.0 (vmchale)
10:33:30 * hackage chs-cabal 0.1.0.0 - Cabal with c2hs dependencies  https://hackage.haskell.org/package/chs-cabal-0.1.0.0 (vmchale)
10:34:42 <dsal> My mqtt sometimes manages to not fail properly when a server disconnects.  I can't figure out how to reproduce it in isolation.  I guess I need some kind of thread debugger.
10:35:56 <explorer53> /list
10:35:57 <explorer53> /msg chanserv info ##welcome-message-testing
10:39:30 * hackage libarchive 2.0.0.0 - Haskell interface to libarchive  https://hackage.haskell.org/package/libarchive-2.0.0.0 (vmchale)
10:40:30 * hackage free-categories 0.1.0.0 - free categories  https://hackage.haskell.org/package/free-categories-0.1.0.0 (echatav)
10:41:13 <dsal> Oh nice.  It does work on this program when I kill locally.
10:44:14 * dsal adds print statements like a pro
10:45:52 <dsal> oooh.  I think I understand what I've done here.
10:46:00 * hackage chs-cabal 0.1.0.1 - Cabal with c2hs dependencies  https://hackage.haskell.org/package/chs-cabal-0.1.0.1 (vmchale)
10:50:30 * hackage glirc 2.33.1 - Console IRC client  https://hackage.haskell.org/package/glirc-2.33.1 (EricMertens)
10:50:34 <dsal> I'm using mapConcurrently_ but I really want something raceABunchOfStuff_
10:52:36 <cocreature> dsal: something like "waitAnyCatchCancel . map async"?
10:54:15 <dsal> Ooh, yeah.  That sounds good.
10:56:07 <debian_> hey anybody here
10:56:29 <dmwit> no
10:57:01 <debian_> helloo anybody
10:57:30 * hackage libarchive 2.0.0.1 - Haskell interface to libarchive  https://hackage.haskell.org/package/libarchive-2.0.0.1 (vmchale)
10:57:32 <boxscape> debian_: you have a question, feel free to ask it, if someone knows an answer they will respond
10:58:41 <debian_> i want to ask about fonctional programming more precisely resources to be read 
10:58:54 <dsal> debian_: do it!
10:59:06 <dmwit> ?where tutorials
10:59:06 <lambdabot> http://haskell.org/haskellwiki/Tutorials
10:59:16 <dmwit> ?where books
10:59:16 <lambdabot> See `LYAH',`RWH',`YAHT',`SOE',`HR',`PIH',`wikibook',`PCPH',`HPFFP',`HTAC',`TwT',`FoP',`PFAD',`WYAH',`non-haskell-books'
10:59:28 <debian_> i went through the tutorials 
11:00:05 <boxscape> @where haskellbook
11:00:05 <lambdabot> http://haskellbook.com
11:00:09 <boxscape> is widely recommended
11:00:40 <boxscape> this is a good summary of resources https://github.com/bitemyapp/learnhaskell
11:00:47 <debian_> i am more intressted in the type of programming haskell uses and more efficiet ways to use it compared to my object oriented programming style 
11:16:07 <dsal> I think I finally  just have to accept exceptions properly.
11:16:31 <dsal> Deadhand: haskellbook is good for that.  There's an unlearning process, so  it's best to start as if you don't know anything about programming.
11:16:36 <dsal> damnit
11:16:42 <dsal> tab failed when person left.
11:18:42 <EvanR> except acceptions?
11:21:34 <koz_> EvanR: Much except.
11:22:15 <nshepperd2> I always accept exceptions, except when I don't
11:23:00 * hackage ADPfusion 0.6.0.0 - Efficient, high-level dynamic programming.  https://hackage.haskell.org/package/ADPfusion-0.6.0.0 (ChristianHoener)
11:24:00 * hackage first-class-patterns 0.3.2.5 - First class patterns and pattern matching, using type families  https://hackage.haskell.org/package/first-class-patterns-0.3.2.5 (shersh)
11:38:30 * hackage rocksdb-query 0.3.0 - RocksDB database querying library for Haskell  https://hackage.haskell.org/package/rocksdb-query-0.3.0 (xenog)
11:48:28 <EvanR> pretend the name chosen for arbitrary precision integer was Int... what would you call machine int then
11:49:40 <merijn> EvanR: Usually word, but that's already taken too :p
11:49:55 <EvanR> right
11:50:35 <merijn> Is there a venue to get attention for open issues that you don't have time to solve yourself? >.>
12:01:53 <Ariakenom> EvanR: CInt :p
12:02:45 <dmwit> MachineInt
12:02:53 <EvanR> C is presuming way too much
12:03:05 <dmwit> NativeInt
12:03:11 <EvanR> ForeignInt :P
12:03:12 <dmwit> HardwareInt
12:03:35 <dmwit> FastButWrongInt
12:03:54 <Ariakenom> CInt, Int8, Int32, etc. no more distinction needed I think
12:03:59 <EvanR> the nature of signed int seems to defy easy naming
12:04:30 <EvanR> it's not Z mod 2^64 
12:05:10 <Ariakenom> Z%64-32
12:05:38 <EvanR> yeeee...
12:06:03 <EvanR> things were simpler in 1970 when nothing had a name yet
12:06:16 <EvanR> befores names existed
12:06:18 <Ariakenom> add a special case for operators in type names just for that name. its just that good
12:07:05 <Ariakenom> we all know civilized time started with lambda calculus
12:13:00 <evelyn_> There were no machines before 1/1/1970 otherwise UNIX time would obviously go back further.
12:22:25 <dmwit> It's isomorphic to Z mod 2^64, no?
12:22:55 <Ariakenom> wdym by isomorphic?
12:23:08 <dmwit> Good question.
12:23:48 <dmwit> I mean there is a ring isomorphism, I think.
12:25:37 <dmwit> (Specifically, the one that C's casting would give you, where it just reinterprets the bits as 2's complement.)
12:26:19 <dmwit> Of course, it's not an Ord isomorphism.
12:27:15 <merijn> dmwit: C doesn't give you that :p
12:27:40 <dmwit> Okay. Please fix my sentence for me. I am confident that I transmitted the idea from my brain to yours.
12:28:40 <merijn> dmwit: No amount of trying will get rid of my knee jerk need to convince everyone they don't know C >.>
12:28:51 <dmwit> I am convinced.
12:29:26 <shachaf> What is the thing C doesn't give you?
12:29:44 <merijn> shachaf: two's complement, nor something similar to Z mod 2^64
12:29:55 <shachaf> C doesn't guarantee two's complement representation, but it does define casting unsigned integers to signed integers.
12:30:17 <shachaf> (I'm talking about (int) x, not *(int *)&x, of course.)
12:30:37 <shachaf> Or maybe I'm talking about signed to unsigned.
12:31:02 <merijn> Anyway, hating on C(++) is my therapy for dealing with the amount of C in my code base >.<
12:31:24 <EvanR> gather around everybody for today's two minutes hate
12:31:35 <evelyn_> C++ is just C with more colons
12:31:40 * EvanR turns on projection of SPJ
12:31:42 <merijn> EvanR: Two minutes? Those are rookie numbers!
12:31:57 <shachaf> Yes, I was thinking of signed to unsigned. I guess unsigned to signed is trickier.
12:32:04 <merijn> evelyn_: Don't forget the less useful errors >.>
12:32:24 <evelyn_> :) C++ is alright
12:32:24 <merijn> Anyway, back on topic with Haskell... >.>
12:32:31 <EvanR> no you still have 45 seconds
12:32:57 <merijn> EvanR: I already complained to colleagues for over half an hour :p
12:33:08 <EvanR> ok, then you're absolved
12:33:35 <boxscape> reading through the ghc proposals is fun. It's neat to see the slow but steady changes in the direction of dependent haskell
12:34:21 <merijn> boxscape: The depressing thing is the sheer amount of essentially pointless tweaking proposals that get submitted, breaking tons of things for essentially no gain >.>
12:34:36 <boxscape> but presumably most of those don't get accepted?
12:34:56 <merijn> boxscape: Still takes up everyone's time to respond/read those
12:35:01 <boxscape> yeah that's true
12:44:52 <freeman42x> does this error say anything to anyone? https://gist.github.com/razvan-flavius-panda/12d550324a2faf7523b6d905ba7a79cf
12:49:38 <EvanR> (exit 1): failed
12:49:45 <EvanR> best error
12:50:01 <merijn> HIE is calling out to cabal-helper-wrapper which is crashing/failing
12:50:42 <tabaqui1> jle`: didn't know about the COMPLETE pragma before, thanks
12:50:48 <tabaqui1> I thought, it's a bug in ghc
12:51:17 <jle`> np! i actually think i rmeember, before COMPLETE pragmas were introduced, those sort of patterns were checked properly for completion. or maybe my memory is failing me
12:53:10 <freeman42x> got an even better one...
12:53:20 <freeman42x> cabal init , and output: fd:14: hGetContents: invalid argument (invalid byte sequence)
12:53:40 <boxscape> freeman42x the first one might have something to do with this, IIRC I got a similar error when I tried to use HIE with cabal 3 https://github.com/haskell/haskell-ide-engine/issues/1376#issuecomment-531661519
12:53:46 <merijn> That looks like a borked locale environment
12:55:42 <boxscape> jle` from the commit message of https://github.com/ghc/ghc/commit/1a3f1eebf81952accb6340252816211c7d391300 it sounds like it wasn't possible before the COMPLETE pragma
13:02:27 <jle`> huh, interesting
13:07:00 * hackage schemas 0.2.0.1 - schema guided serialization  https://hackage.haskell.org/package/schemas-0.2.0.1 (PepeIborra)
14:01:38 <Guest_99> I need help
14:02:48 <Guest_99> when I type ghci it says command not found
14:05:07 <dmwit> Where did you install GHC? What operating system are you on?
14:05:47 <Guest_99> I'm on a mac
14:06:03 <Guest_99> I installed it from the terminal
14:06:16 <Guest_99> just copied what it said on the website
14:06:39 <dmwit> What website?
14:06:50 <Guest_99> Haskell Platform download
14:07:15 <Guest_99> curl https://get-ghcup.haskell.org -sSf | sh
14:07:32 <Guest_99> I just pasted that
14:07:35 <Guest_99> in the terminal
14:07:43 <dmwit> At the end, it should have given you some instructions about modifying your PATH. Did you do this?
14:07:57 <Guest_99> then it said to use ghc I needed to do something to path
14:08:10 <Guest_99> ahh that bit , I didn't understand that
14:10:03 <ggVGc> why do people still curl into sh :(((
14:10:06 <ggVGc> makes me cry inside every time
14:10:07 <Guest_99> what exactly do I need to do to make it work?
14:11:25 <dmwit> Guest_99: From last time you asked: https://pastebin.com/DsNu1XZ6
14:13:26 <merijn> ggVGc: Because, in this case, they are not familiar with the commandline or why that's a terrible idea
14:14:16 <Guest_99> ahh I just started a CS course, no idea what's going on
14:14:19 <ggVGc> merijn: let me rephrase. Why do people who are proficient with linux systems and publish large open source projects still tell people who are not comfortable with said systems, to curl into sh
14:14:36 <merijn> ggVGc: Because everything is terrible
14:14:46 <ggVGc> I agree and dislike this answer :(
14:15:25 <dmwit> "Why do X?" questions are very hard to answer. It is much easier to answer "What makes X a better alternative than Y?".
14:15:55 <ggVGc> dmwit: there surely are a lot better alternatives than telling people to blindly run internet traffic into their shell
14:16:02 <dmwit> (I am willing to take "for goal Z" as implicit. I am not willing to take Y as implicit.)
14:16:53 <dmwit> ggVGc: Do you have a witness for this existential hypothesis?
14:17:57 <ggVGc> literally every time someone publishes a proper package to an official package manage instead
14:18:09 <ggVGc> which isn't perfect, but still better
14:18:34 <merijn> ggVGc: Ah, but for which distro and architecture?
14:18:43 <quiet_laika[m]> the fisher project (a plugin manager for fish shell) just curls scripts onto your system without running them, and then fish can use them as "autoloaded functions" after you inspect them to your satisfaction
14:18:54 <ggVGc> merijn: aren't those things going to be #IFDEFs in the shell script anyway?
14:18:57 <merijn> ggVGc: Everytime I have to grab one of the bindists for linux it's guess work (macOS is simple)
14:19:04 <dmwit> curl | sh is preferable to offering packages because it is much easier to make it work on all Linuxes.
14:19:06 <quiet_laika[m]> obviously that only works when you have some kind of interpreter for what you want to run, but it works well for that particular project
14:19:18 <merijn> ggVGc: Sure, but uninformed people don't know how to pick
14:19:28 <dmwit> And it's not like a package is any less "running random code from the Internet" than curl | sh is.
14:19:36 <quiet_laika[m]> everyone should just learn nix, duh
14:19:42 <ggVGc> depending on the distro it is
14:19:47 <ggVGc> but yeah, it's maybe not much better...
14:19:56 <merijn> quiet_laika[m]: Maybe when Nix can be bothered to work without root
14:20:14 <dmwit> In fact, a package might be worse: the user may be forced to run their package manager as root.
14:20:23 <quiet_laika[m]> <merijn "quiet_laika: Maybe when Nix can "> to install nix itself?
14:20:37 <merijn> dmwit: There's no excuse for all package manager requiring that >.>
14:20:44 <ggVGc> I'd still prefer "Download the shell script and check against this checksum" over "curl | sh"
14:20:45 <merijn> quiet_laika[m]: To use
14:20:50 <dmwit> Whether there is an excuse or not, it is the state of the art.
14:21:28 <quiet_laika[m]> merijn: is this for multi user mode? i never need to sudo anything for my single user install...
14:21:59 <merijn> quiet_laika[m]: That's because root already created /nix for you
14:22:05 <ggVGc> I always have to use "sudo pacman", so for me dmwit's point is very true
14:22:19 <merijn> quiet_laika[m]: Nix requires /nix by default, so you can't use it as non-root unless you build it from source
14:22:32 <quiet_laika[m]> ahhh
14:23:01 <merijn> quiet_laika[m]: Of course "build Nix from source" kinda defeats it's purpose as "the solution to needing to build tool X from source"
14:23:16 <merijn> Because Nix has like 20 dependencies I'd have to manually install from source
14:23:34 <quiet_laika[m]> yes :p i guess first we need everyone to move to nixos... heh
14:23:53 <ggVGc> guess all software should just be blogs with tutorials on how to create the programs you need
14:23:57 <merijn> quiet_laika[m]: You'd need to move everyone to linux before you can do that
14:24:04 <ggVGc> so you don't have to sun package managers as root, or curl into shell
14:24:44 <merijn> ggVGc: There's no package managers would need root, tbh. Just install user local instead of /usr/bin and make installing in /usr/bin optional...
14:28:23 <ggVGc> merijn: can you make this the staus quo?
14:28:37 <merijn> ggVGc: Once elected dictator of the world, sure
14:28:51 <merijn> It'll be my first decree, together with banning anything other than utf8
14:31:54 <EvanR> utf8 only: the other first decree
14:37:00 * hackage exception-transformers 0.4.0.8 - Type classes and monads for unchecked extensible exceptions.  https://hackage.haskell.org/package/exception-transformers-0.4.0.8 (GeoffreyMainland)
14:38:21 <Ariakenom> merijn: have you tried any namespace solution to rootless nix?
14:38:41 <merijn> Ariakenom: I have no clue what that means, so no
14:39:00 * hackage bitvec 1.0.1.1 - Space-efficient bit vectors  https://hackage.haskell.org/package/bitvec-1.0.1.1 (Bodigrim)
14:46:38 <Ariakenom> merijn: I just meant using linux namespaces as user to mount something to /nix. I think all the "Installing without root permissions" listed here do that https://nixos.wiki/wiki/Nix_Installation_Guide
14:48:15 <merijn> Ariakenom: It already fails at that unshare command :p
14:48:50 <merijn> Ariakenom: The next step is grep /proc/config which also doesn't exist :p
14:53:49 <texasmynsted> I have one machine that appears to be installed with ghcup and another with ??? (bin's are stored in /Users/mmynsted/Library/Haskell/bin/)
14:54:22 <texasmynsted> I think it would be best to migrate one of them so they used the same mechanism. Any recommendations?
14:54:55 <texasmynsted> FWIW, I like using cabal rather than stack
14:54:58 <merijn> texasmynsted: Libary/Haskell/bin sounds like Haskell Platform
14:55:18 <merijn> texasmynsted: tbh, I always just install the GHC bindists
14:55:30 <texasmynsted> Is it possible to migrate from Haskell Platform to ghcup (if that was a wise choice)
14:55:41 <sclv> sure
14:55:46 <Ariakenom> merijn: D: I suppose you need the powers that be to enable user namespaces. there is also a PRoot alternative that may or may not be too clunky
14:55:47 <merijn> texasmynsted: I mean, define "migrate"
14:55:51 <sclv> Just use ghcup to install a new ghc
14:55:57 <sclv> It won’t overlap
14:56:11 <texasmynsted> I just want something easy because I will forget what I did. Want something I can practically automate
14:56:45 <texasmynsted> there are quite a number of apps installed in /Users/mmynsted/Library/Haskell/bin
14:57:44 <merijn> texasmynsted: On macOS (and on linux, because it always works the same everywhere) I just install https://www.haskell.org/ghc/download_ghc_8_6_5.html#macosx_x86_64 That's about as "minimal" you can get, tbh
14:57:57 <texasmynsted> The only problem with having both is then I do not know which I should be maintaining 
14:58:44 <merijn> texasmynsted: "./configure --prefix=$HOME/ghc86 && make install" If I want to add a new GHC version I just install in a new $HOME/ghcXX, if I wanna delete it, I just nuke the relevant $HOME/ghc (and the relevant store subdirectory)
14:59:21 <boxscape> Is there an easier way to see how many packages use a certain extension than downloading all packages and grepping?
14:59:33 <merijn> texasmynsted: Which to maintain is a matter of "which are you actually using?" (try running "type ghc" in your shell)
15:01:02 <Ariakenom> merijn: if you want to try more #nixos has been super helpful
15:01:29 <merijn> Ariakenom: As far as I can tell this linux distro is to ancient to use the namespace stuff they recommend
15:01:55 <texasmynsted> interesting
15:02:05 <texasmynsted> type seems to work like "which"
15:02:13 <merijn> texasmynsted: Except better
15:02:37 <texasmynsted> One system reports /usr/local/bin/ghc and the other /Users/mmynsted/.ghcup/bin/ghc
15:02:48 <merijn> texasmynsted: Because it also works for shell functions and, unlike which, the output of type is standardised :)
15:03:07 <merijn> texasmynsted: oh, /usr/local/bin/ghc could very well be Homebrew too
15:03:09 <texasmynsted> nice
15:04:18 <texasmynsted> I do not see an active macport or homebrew for haskell or ghc
15:10:51 <texasmynsted> Hmm Haskell platform claims I should use ghcup. Heh /Users/mmynsted/.ghcup/bin/ghc
15:10:53 <texasmynsted> oops
15:11:08 <texasmynsted> https://www.haskell.org/platform/mac.html
15:14:30 <glguy> texasmynsted: It's also the best way to go for Linux, too
15:18:06 <texasmynsted> okay I can accept that. I simply wonder what the best way to "upgrade"/"update" my "haskell platform" install to "ghcup" install 
15:18:45 <glguy> Uninstall the one, install ghcup script, change your PATH to point to ghcup's install bin dir
15:21:43 <texasmynsted> and what about all the things installed in /Users/mmynsted/Library/Haskell/bin/ (some are symlinked to .cabal/store/ghc-8.2.2/. . . )
15:22:15 <texasmynsted> will ghcup _magically_ know what to do?
15:23:23 <glguy> ghcup doesn't care about any of that, it just installs GHC binary distributions and copies down a cabal-install executable for your platform
15:25:10 <davean> texasmynsted: theres no magic, .cabal is the data for cabal, which both use. 
15:25:38 <davean> texasmynsted: those areas it just adds to the data. 
15:25:47 <texasmynsted> so then 1. `uninstall-hs all` 2. `curl https://get-ghcup.haskell.org -sSf | sh`
15:25:55 <sclv> you can even do 2 without 1
15:25:57 <davean> You'd only have a problem if you removed data in that set 
15:26:00 <sclv> they're entirely independent installations
15:28:18 <texasmynsted> mmkay
15:28:33 <texasmynsted> that sounds messy.
15:29:18 <merijn> texasmynsted: How so?
15:30:22 <texasmynsted> How do I know which cabal config is in use? How do I know which ghc is in use? How do I know which `summon` to update?
15:30:40 <merijn> texasmynsted: There is only one cabal config, the one in ~/.cabal/config
15:30:57 <merijn> texasmynsted: And cabal just uses whatever ghc is first in your path
15:33:44 <Kaiepi> huh i forgot i never installed stack
15:33:54 <texasmynsted> I guess there are not too many globally installed haskell binaries for me. https://gist.github.com/mmynsted/377f107acd22176e108b40bc3b60bf29
15:34:28 <texasmynsted> That gist is what uninstall-hs claims it will do.
15:34:28 <Kaiepi> how well does stack work on openbsd?
15:45:16 <texasmynsted> Kaiepi: I do not know how well it works on openbsd.
15:46:40 <texasmynsted> okay thank you. The ghcup seems fine so far. Re-installing the binaries 
15:49:45 <texasmynsted> heh. I have been typing `cabal v2-install . . .`. I now wonder if the default is v2?
15:50:03 <merijn> texasmynsted: v2 is the default in 3.0
15:50:07 <merijn> So "maybe"
15:50:09 <texasmynsted> heh
15:50:37 <texasmynsted> yes cabal 3.0.0.0 is the one.
15:52:57 <jle`> this is it
15:55:51 <texasmynsted> so safe to just `cabal install`, etc leaving off the v2? was reading the "readthedocs" site for cabal and could not find the answer
15:58:20 <texasmynsted> wow, whomever it was that suggested `type` over `which`, thank you! This is so much better.
15:58:42 <texasmynsted> works for built-in shell commands as well
15:58:55 <merijn> texasmynsted: :)
15:59:04 <merijn> texasmynsted: More portable too!
16:02:42 <sm[m]> only for bash users ?
16:04:53 <texasmynsted> If I `type type` it tells me it is a shell builtin. So bash or perhaps those with common ancestors
16:05:18 <texasmynsted> sm[m]: what shell are you using?
16:08:54 <merijn> sm[m]: type is posix
16:09:50 <sm[m]> Aha
16:31:00 * hackage hw-json-simd 0.1.0.3 - SIMD-based JSON semi-indexer  https://hackage.haskell.org/package/hw-json-simd-0.1.0.3 (haskellworks)
16:31:26 <Chorhizo> Hey, I'm not sure if this is a thing but I've written a small 50ish line thing, would anyone be willing to give me style advice?
16:32:26 <quiet_laika[m]> anyone know about how i can instruct `ghcide` (more specifically, `hie-bios`) to ignore certain files that it thinks are "of interest"?
16:35:24 <glguy> Chorhizo: If you have a question you should just ask it. If you wait for someone to commit to your question without seeing it you're likely to get no help at all
16:39:30 <Chorhizo> Made a basic wiki in haskell, wondering if anyone has any style advice https://gist.github.com/PotterJam/94ffed3b06bcaa655c8c0bbfaea8830c (cheers glguy)
16:43:53 <glguy> I'd recommend using writeFile and withFile over openFile and hClose. I'd recommend using System.Console.GetOpt over manually processing command line arguments. For long names line 75 will print the name with no whitespace before the tag. I don't know if that's what you wanted.
16:46:58 <Chorhizo> GetOpt looks really good, and yeah I thought there might be some higher level functions but I couldn't seem to find them
16:47:26 <Chorhizo> The long names thing is because I just want shortish names for wikis and will prevent input of >15 chars or something
17:10:03 <anti_fap> guys, do you know why the hole (_) is used?
17:10:09 <anti_fap> are there any benefits ?
17:10:28 <Axman6> do you mean why are there brackets?
17:10:37 <anti_fap> I'm not in the level of monads yet, I'm asking in the level of bindings
17:10:54 <Axman6> I don't understand what you're asking for
17:11:01 <anti_fap> in pattern matching, sometimes when we don't use variable, we use the _
17:11:07 <Axman6> _ is just a way to explicitly ignore an argument
17:11:21 <anti_fap> is there any benefit of not using that ?
17:11:26 <sm[m]> They compile but with useful error messages
17:11:27 <boxscape> makes sure you don't accidentally use it and prevents warning about unused variables
17:11:30 <anti_fap> or using that
17:12:06 <anti_fap> okay
17:12:08 <anti_fap> thanks
17:12:16 <sm[m]> Really, the ghc manual probably explains this much better than we are :)
17:13:14 <anti_fap> yeah, but they started explaining with usage of monads, and I'm not in that level yet
17:13:32 <boxscape> I don't think anyone mentioned monads
17:13:34 <Axman6> it has nothing to do with monads
17:16:02 <boxscape> to be fair though it's not exactly easy to find where _ is described in the user's guide
17:16:52 <boxscape> (I haven't found any mention of it so far)
17:16:53 <kiwihunter> Guys, I want to know the reason why in haskell they have Int and Integer, 
17:17:08 <boxscape> Integer allows you to have an arbitrarily large number, Int is more efficient
17:17:49 <kiwihunter> when we supply a parameter to a function with typeclass Num, is it passed as an Int or Integer?
17:18:09 <kiwihunter> *with typeconstraint  of typeclass NUm
17:18:41 <boxscape> Depends on the context. If you have a numeric integer literal in a source file and no other constraints, it defaults to Integer, but you can change the default.
17:19:31 <kiwihunter> why then when I declare :
17:19:35 <kiwihunter> let x = 3
17:19:43 <Chorhizo> kiwihunter if you know Java it's like BigInt and Int
17:19:48 <kiwihunter> it's defined as a typeconstraint Num, and not of type Integer
17:20:09 <boxscape> Ah, well I suppose what I said wasn't quite precise enough
17:20:58 <boxscape> I would imagine that it defaults to Integer as soon as it's actually given to a function that requires a Num constraint
17:21:06 <boxscape> but I'm not 100% on the specifics
17:22:05 <boxscape> (Doesn't actually have to be a Num constraint, could be something like Eq or Show as well, for example)
17:22:18 <hpc> kiwihunter: beyond Int and Integer, there are many other things you may want x to be as well
17:22:29 <hpc> like Double, or a complex number
17:22:45 <kiwihunter> yeah, I'm very confused ...
17:23:05 <hpc> when it says x :: Num a => a, that means it can be used as any of those
17:23:10 <hpc> % :info Num
17:23:11 <yahb> hpc: class Num a where; (+) :: a -> a -> a; (-) :: a -> a -> a; (*) :: a -> a -> a; negate :: a -> a; abs :: a -> a; signum :: a -> a; fromInteger :: Integer -> a; {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}; -- Defined in `GHC.Num'; instance Integral a => Num (Ratio a) -- Defined in `GHC.Real'; instance Num Word -- Defined in `GHC.Num'; instance Num Integer -- Defined in 
17:23:41 <hpc> there's a bunch of instances for Num, anything that can satisfy those function definitions
17:23:42 <pikajude> it's because literals like that are actually `fromIntegral (x :: Integer)`
17:23:50 <pikajude> uhh fromInteger
17:23:52 <pikajude> sorry, muscle memory :)
17:24:15 <boxscape> (And I take that back, I'm not sure how exactly defaulting works, but it defaults even if you have `const 'a' 4` (as shown by -Wtype-defaults), where the 4 isn't even used)
17:24:44 <pikajude> i don't think ghc has compile-time knowledge whether arguments are used
17:24:48 <hpc> defaulting is for integer-y numbers and float-y numbers, and can be extended to try () otherwise
17:24:51 <kiwihunter> :(  very confused..
17:24:57 <hpc> boxscape: ^
17:25:07 <boxscape> that makes sense
17:25:25 <pikajude> also, you still have to typecheck the `const`
17:25:42 <dsal> Is there any way to do a where clause that covers multiple heads?
17:25:43 <pikajude> i don't think you can pass it unlifted types? so `const whatever 4` still needs to check that both args are lifted types
17:25:45 <kiwihunter> @hpc @boxscape can you please elaborate more 
17:25:46 <lambdabot> Maybe you meant: src rc pl ghc
17:26:07 <hpc> kiwihunter: so, there are lots of type classes other than Num
17:26:20 <hpc> that let you work generically with things
17:26:37 <hpc> and it's common for libraries to define their own as part of their API, for extensibility
17:26:41 <jellostahps> Please help me understand how 'cases' work in line 8-10. IDK what is going on : https://pastebin.com/93zDvgrQ
17:26:51 <boxscape> pikajude I think Num a => a is already lifted though
17:26:59 <hpc> basically you have "class Foo a where bunch of definitions"
17:27:05 <hpc> that defines the interface
17:27:06 <pikajude> can you not define Num for an unlifted type?
17:27:12 <pikajude> i guess that wouldn't make sense
17:27:14 <boxscape> let me try
17:27:48 <hpc> what parameters the class takes in a type signature, and what operations it gives you access to
17:28:00 <boxscape>     • Expecting a lifted type, but ‘Int#’ is unlifted    • In the first argument of ‘Num’, namely ‘Int#’
17:28:05 <pikajude> :(
17:28:08 <hpc> Num has addition, multiplication, handling numeric literals, etc
17:28:13 <hpc> another example is Eq
17:28:17 <hpc> @src Eq
17:28:17 <lambdabot> class Eq a where
17:28:17 <lambdabot>     (==), (/=) :: a -> a -> Bool
17:28:34 <kiwihunter> @src Num
17:28:34 <lambdabot> class Num a where
17:28:34 <lambdabot>     (+), (-), (*)       :: a -> a -> a
17:28:34 <lambdabot>     negate, abs, signum :: a -> a
17:28:34 <lambdabot>     fromInteger         :: Integer -> a
17:28:45 <kiwihunter> @src Integral
17:28:45 <lambdabot> class (Real a, Enum a) => Integral a where
17:28:45 <lambdabot>     quot, rem, div, mod :: a -> a -> a
17:28:45 <lambdabot>     quotRem, divMod     :: a -> a -> (a, a)
17:28:45 <lambdabot>     toInteger           :: a -> Integer
17:29:08 <kiwihunter> where does the + - * defined ?
17:29:09 <hpc> if you define your own type and do deriving (Eq, whatever else), the language is giving you a generated Eq instance
17:29:17 <kiwihunter> @src Int
17:29:17 <lambdabot> data Int = I# Int#
17:29:19 <hpc> it lets you use (==) and (/=)
17:29:29 <pikajude> there's an instance Num Int somewhere in base
17:29:32 <hpc> so, (+) is defined in multiple places
17:29:35 <pikajude> i think if you do :i Int in ghci it'll probably tell you
17:29:37 <hpc> it gets its type from the class definition
17:29:40 <hpc> then there are instances
17:29:40 <boxscape> pikajude pretty sure it defaults because it has to know which Num dictionary to use
17:29:54 <hpc> "instance Num Int where (+) = blahblah"
17:29:57 <pikajude> yeah i'm sure there's a reason somewhere around here
17:30:08 <kiwihunter> so a type is an instance of typeclass ?
17:30:28 <hpc> instances are defined all over the place, and each instance has a value-level definition of (+) that's appropriate for a specific type
17:30:37 <pikajude> yeah typeclass instances are types
17:30:47 <pikajude> Int (type) is an instance of Num (class)
17:30:52 <boxscape> I think technically types *have* instances rather than *being* instances
17:31:31 <sm[m]> boxscape, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#typed-holes is where I found it. I'm not saying it was easy to find, though
17:31:31 <hpc> with language extensions, classes and instances can get /very/ interesting
17:31:52 <hpc> even at their base level of power, they're quite effective though
17:31:53 <pikajude> class Foo (a :: Constraint) where ...
17:32:00 <hpc> we get to do math in a very generic way
17:32:04 <boxscape> sm[m] sorry to disappoint, but that's not actually it. Typed holes are a relatively new feature, using _ in parameter lists is very old
17:32:05 <kiwihunter> okay, when a type is supplied to Num, what instance did it pick for (+) operator
17:32:08 <hpc> we get to define our own ways of operating generically on things
17:32:18 <hpc> and we get to apply those to our own types whenever we want
17:32:29 <hpc> and it's all type-checked rather than being an untyped mess
17:32:34 <pikajude> it picks the instance based on what type the expression is
17:32:45 <pikajude> (3 + 4) :: Int -- uses Num instance for Int for +
17:33:04 <sm[m]> boxscape: but.. but.. it says "Typed Holes"..
17:33:07 <kiwihunter> if I don't supply the :: what is the default 
17:33:13 <boxscape> sm[m] but the question wasn't about typed holes ;)
17:33:14 <pikajude> for ints it's Integer
17:33:17 <pikajude> for floats it's Double (i think){
17:33:22 <hpc> kiwihunter: by default, it will try to be as polymorphic as possible
17:33:34 <pikajude> > read "foo"
17:33:36 <lambdabot>  *Exception: Prelude.read: no parse
17:33:38 <hpc> kiwihunter: unless it's in some very specific circumstances, where it defaults to... Integer iirc
17:33:42 <hpc> maybe Int
17:33:46 <hpc> it doesn't come up very often
17:33:52 <pikajude> oh wait, ghci has those screwy defaulting rules
17:33:57 <hpc> when working with floating point numbers, the default is Double
17:33:59 <pikajude> @type read
17:34:00 <lambdabot> Read a => String -> a
17:34:18 <jellostahps> Please help me understand how 'cases' work in line 8-10. IDK what is going on : https://pastebin.com/93zDvgrQ
17:34:27 <pikajude> ordinarily it would say something along the lines of like, "No instance for (Read a0) arising from ..."
17:34:31 <sm[m]> alrighty then
17:34:31 <boxscape> sm[m] the person mentioned that they were talking about not using a value while pattern matching
17:34:34 <kiwihunter> @hpc the Num itself didn't have the (+) defined right?  how does it choose from one of it's instance, and how does it comeback to be Num again
17:34:34 <lambdabot> Maybe you meant: src rc pl ghc
17:34:42 <pikajude> because a0 can mean anything, and then GHC will suggest a type
17:35:05 <hpc> classes don't have definitions (generally), only the type
17:35:12 <pikajude> kiwihunter: the compiler chooses based on the type of the expression
17:35:25 <hpc> if it helps, think of class definitions as interfaces and instance definitions as implementations
17:36:30 <hpc> it doesn't pick any particular instance until it's being used in a non-generic way
17:37:01 <kiwihunter> hmmm...
17:37:16 <kiwihunter> but then how is it evaluated to 7 ?
17:37:17 <hpc> :t \a b c -> a*a + b*b + c*c -- nothing here requires it to use any specific instance, for example
17:37:18 <lambdabot> Num a => a -> a -> a -> a
17:37:42 <pikajude> the compiler chooses which instance based on the type of the expression
17:37:53 <hpc> when you just put "3 + 4" into ghci on its own, that's a scenario where it defaults
17:37:58 <pikajude> whenever you import any module, all instances defined in that module are in scope
17:38:15 <hpc> it sees that the result to display is of type "Num a => a", and just picks Int
17:38:36 <pikajude> is there a way to disable type defaulting?
17:38:42 <pikajude> i think that would be helpful for demonstration
17:38:46 <hpc> the only other time it defaults is in a file if you do a top-level definition with no type signature and no "parameters"
17:38:55 <hpc> ie, x = ... as opposed to f x = ...
17:39:14 <hpc> "f = \x -> ..." will be defaulted, btw
17:39:26 <hpc> importantly, this is only if you don't give it a type signature
17:39:29 <pikajude> > default ()
17:39:31 <lambdabot>  <hint>:1:1: error: parse error on input ‘default’
17:39:33 <pikajude> oh
17:39:40 <pikajude> :(
17:39:51 <boxscape> % default()
17:39:51 <yahb> boxscape: 
17:39:55 <kiwihunter> :(
17:39:59 <pikajude> % 3
17:39:59 <yahb> pikajude: ; <interactive>:18:1: error:; * Ambiguous type variable `a0' arising from a use of `print'; prevents the constraint `(Show a0)' from being solved.; Probable fix: use a type annotation to specify what `a0' should be.; These potential instances exist:; instance Show a => Show (ZipList a) -- Defined in `Control.Applicative'; instance Show NestedAtomically -- Defined in 
17:40:01 <hpc> you can disable defaulting with the NoMonomorphismRestriction extension, but it's not recommended
17:40:04 <pikajude> there you go
17:40:10 <pikajude> yahb is telling me it doesn't know what type "3" is
17:40:13 <pikajude> because 3 is type Num a => a
17:40:19 <pikajude> % (3 :: Int)
17:40:19 <yahb> pikajude: 3
17:40:32 <kiwihunter> % 3 + 4
17:40:32 <yahb> kiwihunter: ; <interactive>:20:1: error:; * Ambiguous type variable `a0' arising from a use of `print'; prevents the constraint `(Show a0)' from being solved.; Probable fix: use a type annotation to specify what `a0' should be.; These potential instances exist:; instance Show a => Show (ZipList a) -- Defined in `Control.Applicative'; instance Show NestedAtomically -- Defined in 
17:40:32 <pikajude> type defaulting makes this whole process slightly more confusing to learn
17:40:42 <kiwihunter> % :t 3
17:40:42 <yahb> kiwihunter: Num p => p
17:40:51 <kiwihunter> % (3::Int) + 4
17:40:51 <yahb> kiwihunter: 7
17:40:59 <kiwihunter> okay thanks...
17:41:01 <kiwihunter> a lot
17:41:06 <pikajude> :)
17:41:47 <boxscape> hm, ghci defaulting is quite strange. maxBound on its own defaults to (), but in `const 'c' maxBound` it's ambiguous, whereas `const 'c' 4` works and defaults to Integer.
17:42:08 <pikajude> % let b = 3 + 4 in ()
17:42:08 <yahb> pikajude: ()
17:42:25 <hpc> boxscape: it looks at class constraints
17:42:37 <hpc> :t maxBound -- it's not Num, so no defaulting
17:42:38 <lambdabot> Bounded a => a
17:42:40 <pikajude> it's not actually necessary for these exprs to be of a concrete type unless they're "used" by something
17:42:52 <boxscape> hpc but ghci clearly has a defaulting rule for () as well
17:42:53 <pikajude> and by default in ghci, if you just type in a value, it tries to use the Show instance to print it out
17:43:01 <boxscape> hmm
17:43:14 <hpc> oh, i see what you mean
17:43:15 <pikajude> % let b = 3 + 4 in (b :: Int, b :: Double)
17:43:16 <yahb> pikajude: (7,7.0)
17:43:21 <pikajude> polymorphism :o
17:43:34 <hpc> i suspect it doesn't want to default things that don't appear in the result type
17:43:49 <boxscape> but why does that not apply to Integer as well
17:43:52 <kiwihunter> wow
17:43:54 <hpc> in extended defaulting, anyway
17:44:09 <boxscape> is extended defaulting more than just writing default(Integer, String, ())?
17:44:17 <boxscape> (and maybe IO or something)
17:44:18 <hpc> maybe extended and... "default" defaulting are slightly different?
17:44:26 <boxscape> maybe
17:45:46 <boxscape> It might be because Num has a special role in defaulting, whereas Bounded doesn't
17:46:13 <hpc> hmm
17:46:17 <hpc> try your const thing with IsString
17:46:26 <hpc> maybe it's class-based defaulting in general?
17:47:52 <boxscape> I'm not sure what that means
17:48:05 <boxscape> it wouldn't seem to differentiate Bounded from other classes
17:48:05 <hpc> like instead of const 'c' 4, const 'c' "four"
17:48:15 <boxscape> yeah that works, with OverloadedStrings
17:48:17 <kiwihunter> btw what's default default ?
17:48:38 <hpc> kiwihunter: either Int/Double or Integer/Double, i forget
17:48:44 <boxscape> in ghc it's default(Integer, Double, String)
17:48:47 <boxscape> in ghci it's more complicated
17:48:51 <kiwihunter> Okay thanks
17:49:01 <boxscape> but includes ()
17:49:29 <jellostahps> disregard I think i figured it out
17:50:00 * hackage cpkg 0.2.3.4 - Build tool for C  https://hackage.haskell.org/package/cpkg-0.2.3.4 (vmchale)
17:50:45 <boxscape> hpc the user guide mentions that one of the situations in which it defaults is specifically if a constraint is numeric, and I imagine with OverloadedStrings there's a similar rule for IsString
17:51:09 <boxscape> it also says though that it defaults if "all the classes are standard", whatever that means
17:51:42 <boxscape> or wait those are conditions that *all* have to be fulfilled
17:52:06 <boxscape> so all constraints of a variable have to be standard (in base?) classes and one of them has to be Num or a subclass of Num
17:52:16 <boxscape> *then* it defaults
17:52:53 <boxscape> with ExtendedDefaultRules there's a few more classes aside from Num, i.e. Eq, Show, Ord, Traversable, Foldable
17:53:11 <boxscape> notably Bounded is not part of that, whereas IsString probably is, *if* OverloadedStrings is enabled
17:54:51 <Axman6> kiwihunter: I haven't looked through the whole scrollback, but did someone explain to you that 1 in Haskell actually means fromInteger (1 :: Integer)? the syntax 1 is "syntax sugar" for that, which means we can use integer literals for all types which implement Num
18:06:30 * hackage http-client-overrides 0.1.1.0 - HTTP client overrides  https://hackage.haskell.org/package/http-client-overrides-0.1.1.0 (robbiemcmichael)
18:09:09 <EvanR> Axman6: that explantion might make sense... if 1 :: Integer was treated specially apart from 1 :: Int or 1 :: Word
18:09:18 <EvanR> but i'm not sure it is
18:10:18 <EvanR> if 1::Int ==> (fromInteger (1::Integer))::Int... then 1::Integer ==> (fromInteger (fromInteger (fromInteger (....
18:20:36 <pikajude> but for Integer, fromInteger x = x
18:21:28 <pikajude> i think the literal 1 is S# 1#
18:21:33 <pikajude> probably, right
18:21:57 <EvanR> yeah core has this notion of integer literal that is different, i think thats the real story
18:22:28 <pikajude> so 1 :: Int is fromInteger (S# 1#) :: Int
18:23:14 <EvanR> now explain 999999999999 :: Int
18:23:35 <EvanR> maybe that's not enough 9s
18:23:42 <pikajude> i dunno what BigNat literals look like
18:23:42 <EvanR> > maxBound :: Int
18:23:44 <lambdabot>  9223372036854775807
18:25:18 <pikajude> 9223372036854775807 bottles of beer on the wall, 9223372036854775807 bottles of beer...
18:26:00 <EvanR> what ever you do, don't put 1 bottle of beer on the wall
18:26:11 <pikajude> it would be useful for clearing out cabinet space though
18:26:26 <dmwit> Who puts beer on walls, anyway?
18:26:41 <pikajude> how does it stay up there
18:26:48 <dmwit> I think they nail it in.
18:26:55 <EvanR> the tavern is clearly on its side
18:26:58 <pikajude> well then how are you meant to take one down and pass it around
18:27:10 <pikajude> use a crowbar?
18:27:29 <dmwit> I think you hit the nail on the head.
18:27:31 <monochrom> The wall passes by you.
18:27:52 <monochrom> This is known as continuation passing style because the wall is continuous. >:)
18:28:13 <monochrom> "Don't pass us, we'll pass you"
18:28:18 * Clint twitches.
18:29:42 <EvanR> beers = GHC.Types.I# 9223372036854775807
18:30:01 <pikajude> that's a type error
18:30:08 <EvanR> no, it's core output
18:30:17 <pikajude> that's dumb
18:30:32 <EvanR> i think it has a it's own notion of integer literals
18:30:49 <pikajude> for core, literals are Int# probably
18:31:06 <monochrom> I# is the data constructor of Int.
18:31:15 <monochrom> Its field has type Int#
18:31:15 <EvanR> beers is an Int, I# is the data ctor for Int, but that literal is not an Int
18:31:35 <EvanR> e
18:31:35 <EvanR> er
18:31:38 <pikajude> no its an Int#
18:31:39 <EvanR> i did the wrong experiment
18:32:03 <EvanR> beers = fromInteger @ Int GHC.Num.$fNumInt (__integer 9223372036854775808)
18:32:29 <EvanR> so, can't be an Int
18:32:31 <EvanR> or Int#
18:32:44 <pikajude> maybe __integer = I# :)
18:33:23 <EvanR> if beers is Integer, then core would be beers = __integer 9223372036854775808
18:33:41 <dmwit> The Report states it this way: "An integer literal represents the applications of the function `fromInteger` to the appropriate value of type `Integer`.".
18:33:56 <dmwit> This neatly avoids the infinite regress that you seem to be so hung up on.
18:34:16 <EvanR> that's the report, and it makes sense as is
18:34:26 <pikajude> maybe evan is right, and every haskell program that deals with integers actually never terminates
18:34:34 <EvanR> 3 = fromIntegral (3 :: Integer) doesn't really make sense
18:34:53 <monochrom> Also -ddump-prep is more honest than -ddump-simpl
18:35:03 <EvanR> and "in reality" we have this core which makes sense but using so far unelucidated semantics
18:35:28 <dmwit> > let 3 = fromIntegral (3 :: Integer) in text "nyah nyah"
18:35:30 <lambdabot>  nyah nyah
18:36:32 <EvanR> i am now decoding wth -ddump-prep outputs
18:36:35 <pikajude> > let 2 = 3 in 4
18:36:37 <lambdabot>  4
18:37:55 <erisco> > let 2 = 3 in 2 + 2
18:37:58 <lambdabot>  4
18:38:02 <erisco> much disappoint
18:38:04 <pikajude> it's too smart for us
18:38:57 <EvanR> ddump-prep appears to spell out a linked list of Int# which make up the big int
18:38:57 <erisco> Looks like I have to go to Ruby for the sensibilities of redefining numbers.
18:38:59 <dmwit> > let !2 = 3 in "yikes"
18:39:01 <lambdabot>  "*Exception: <interactive>:3:5-10: Non-exhaustive patterns in 2
18:39:16 <EvanR> big integers don't exist after all :(
18:39:22 <dmwit> > let !3 = fromIntegral (3 :: Integer) in text "this one is still fine though"
18:39:24 <lambdabot>  this one is still fine though
18:40:06 <pikajude> why wouldn't it be
18:46:30 * hackage archive-libarchive 0.2.0.0 - Common interface using libarchive  https://hackage.haskell.org/package/archive-libarchive-0.2.0.0 (vmchale)
18:54:09 <stevejb> Hello all, I am trying to use haddock to generate documentation for a library and executable  for a simple stack-based project. Using the command:
18:54:11 <stevejb> stack exec -- haddock --html app/Main.hs src/Lib.hs --hyperlinked-source --odir=dist/docs 
18:54:33 <stevejb> I am getting erros of the type
18:54:34 <stevejb> Haddock coverage:src/Lib.hs:30:1: error:    Ambiguous module name ‘Data.HashSet’:      it was found in multiple packages:      hashmap-1.3.3 unordered-containers-0.2.10.0   |30 | import           Data.HashSet            (HashSet)
18:57:45 <dmwit> You can either remove one of the dependencies, or use the PackageImports extension to disambiguate which you want.
18:58:39 <stevejb> dmwit thank you I will look into PackageImports
18:58:53 <stevejb> The code builds fine, but I haven't used haddock on this project before
18:59:25 <Axman6> any reason you're not using stack haddock?
18:59:35 <dmwit> I'm sort of surprised by the claim that the code builds fine.
18:59:40 <dmwit> Are you sure src/Lib.hs is getting built?
19:00:04 <stevejb> yeah, I have used the program quite a bit.
19:00:12 <dmwit> Ah, but perhaps Data.HashSet is mentioned only in haddock comments and not in the import list.
19:00:14 <stevejb> it seems like all the bits and pieces are there
19:00:41 <stevejb> yeah, `stack build` works just fine
19:00:44 <dmwit> In which case... I don't actually know whether PackageImports will help. I'm going with a solid "maybe".
19:00:57 <stevejb> stack haddock works but doens't document main.hs?
19:01:49 <stevejb> that was my main issue, I wanted to generate some documentation for main.hs
19:03:03 <int-e> stevejb: hmm cabal haddock has a --executables option, does stack have anything like that?
19:19:30 * hackage archive-sig 0.2.0.2 - Backpack signature for archive libraries  https://hackage.haskell.org/package/archive-sig-0.2.0.2 (vmchale)
19:29:45 <Anupknj> hi guys
19:30:02 <Anupknj> today i had exam...found a question
19:30:07 <Anupknj> just need to evaluate
19:30:45 <Anupknj> foldr(\x->\acc->x:x:acc) [9] [1,2,3]
19:30:53 <Anupknj> any idea...........?
19:31:34 <Axman6> have you looked at the definition of foldr?
19:31:42 <Anupknj> yeah....
19:31:43 <Axman6> all you need to do it step through its execution
19:31:46 <Axman6> @src foldr
19:31:46 <lambdabot> foldr f z []     = z
19:31:46 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
19:31:49 <Anupknj> i wrote answer as [1]
19:32:23 <Axman6> that doesn't sound correct to me
19:32:31 <Anupknj> hm...
19:32:45 <Anupknj> i thought foldr would return only one element
19:32:47 <dmwit> If I were marking the exam, and [1] were the correct computational result, I would still give you essentially no credit for that answer.
19:32:53 <monochrom> Do what Axman6 said.
19:33:18 <Anupknj> [1,1,2,2,3,3,9]
19:33:24 <Anupknj> is this answer?
19:33:58 <dmwit> Why do you believe it is the answer?
19:34:14 <Anupknj> x:x
19:34:22 <Axman6> why do you think that is the answer?
19:34:32 <Axman6> can you step through the execution of the foldr call?
19:34:41 <Anupknj> sure
19:34:50 <Axman6> foldr(\x->\acc->x:x:acc) [9] [1,2,3] matches which definition of foldr?
19:34:56 <Axman6> does it match foldr f z []     = z?
19:35:21 <Anupknj> i dont get u guys
19:35:28 <Anupknj> take me step by step
19:35:39 <Axman6> I'm trying to
19:35:45 <Anupknj> ok
19:37:20 <Anupknj> foldr(\x->\acc->x:x:acc) [9] [1,2,3] matches which definition of foldr?
19:37:25 <Anupknj> i dont get this
19:38:32 <Axman6> does which equation for foldr does foldr(\x->\acc->x:x:acc) [9] [1,2,3] match? foldr f z [] or foldr f z (x:xs)
19:38:49 <Anupknj> foldr f z (x:xs)
19:39:34 <Anupknj> right?
19:39:44 <Axman6> yep, and what do f, z, x and xs get bound to?
19:40:03 <Axman6> f = ???, z = ???, x= ???, xs = ???
19:40:18 <Anupknj> i dont understand
19:40:24 <Anupknj> bound to????
19:40:49 <Anupknj> sorry..its been week i am learning haskell
19:41:07 <Axman6> what do the function arguments become when youy call foldr with (\x->\acc->x:x:acc) [9] [1,2,3]
19:41:49 <EvanR> Axman6 demands to know how many lights Anupknj sees
19:42:21 <Axman6> f = (\x->\acc->x:x:acc), z =  [9], x = 1, xs = [2,3]
19:42:30 <monochrom> Maybe you can do a simpler example?  I have "f x = 1 + f (x - 1)" can you do one step of "f 4"?  Just one step?
19:42:35 <Anupknj> ok...got it
19:42:37 <Axman6> that is the answer I wanted you to give me Anupknj
19:42:45 <Anupknj> yup
19:42:51 <Anupknj> i knew that
19:43:02 <Anupknj> i didn't understand it properly
19:43:14 <Axman6> ok, well we know that if we have matched the foldr f z (x:xs) case of foldr, we substitute the definition for that case: f x (foldr f z xs) 
19:43:38 <Anupknj> yes
19:44:20 <Anupknj> go on
19:44:37 <Axman6> so substitute f, z, x and xs with the values I gave you above
19:45:01 <Axman6> if f = (\x->\acc->x:x:acc), z =  [9], x = 1, xs = [2,3], then f x (foldr f z xs) = ???
19:45:26 <Anupknj> f 1 : f $ 2: 3: 9
19:45:57 <Axman6> that's not the substitution I asked for
19:46:14 <Axman6> take f x (foldr f z xs)  and replace all f's with (\x->\acc->x:x:acc)
19:46:29 <Axman6> then replace all z's with [9]
19:47:24 <Axman6> then replace all x's with 1 (except for the ones since the lambda, those are _different_ x's, so don't change (\x->\acc->x:x:acc) into (\1->\acc->1:1:acc))
19:47:40 <Axman6> and replace all the xs's with [2,3]
19:48:05 <Axman6> you're trying to take shortcuts, take this one step at a time
19:48:28 <Anupknj> ok
19:48:38 <Axman6> so, if f = (\x->\acc->x:x:acc), z =  [9], x = 1, xs = [2,3], then f x (foldr f z xs) = ??? 
19:48:47 <Anupknj> [1,1,2,2,3,3,9].........is this right?
19:49:01 <Axman6> you're not paying attention -_-
19:49:14 <Anupknj> i am curious about answer
19:49:16 * EvanR hands Axman6 the "buzzer"
19:49:44 <Axman6> you asked to take this one step at a time, but you keep trying to jump immediately to the answer, when you clearly don't understand the fundamentals which lead to getting the answer
19:50:00 <Axman6> if you don't want to pay attention to the help you're being given, then don't ask for the help
19:50:21 <Anupknj> 1:1:(2:2:(3:3:9))
19:50:23 <Anupknj> ?
19:50:28 <Axman6> no
19:50:34 <Axman6> one step at a time
19:50:36 <Anupknj> okay
19:50:53 <Axman6> that is the _final_ answer, but it is not the answer you need to understand first
19:51:05 <Axman6> if f = (\x->\acc->x:x:acc), z =  [9], x = 1, xs = [2,3], then what does f x (foldr f z xs) become
19:51:30 <Axman6> this is just find and replace
19:51:34 <Anupknj> f 1 ( foldr f [9] [2,3])
19:51:40 <Axman6> close, good
19:51:52 <Axman6> now replace the f's with (\x->\acc->x:x:acc) and you're done
19:51:59 <Axman6> (for this step)
19:52:20 <Anupknj> (\x->\acc->x:x:acc) 1 ( foldr (\x->\acc->x:x:acc) [9] [2,3])
19:52:24 <nineonine> greetings
19:52:26 <Axman6> great!
19:52:28 <dmwit> nineonine: sup!
19:52:32 <Anupknj> haha
19:52:53 <Anupknj> (\x->\acc->x:x:acc) 1 (\x->\acc->x:x:acc)2 (\x->\acc->x:x:acc) [9] [3]
19:52:57 <Anupknj> right?
19:52:59 <nineonine> what happens when haskell program runs out of heap memory?
19:53:08 <EvanR> haskell could be made into a sort of tetris game, probably
19:53:11 <dmwit> nineonine: crash
19:53:15 <Axman6> ok, we can now start applying (\x->\acc->x:x:acc) to its arguments: substitute x for 1, and acc for ( foldr (\x->\acc->x:x:acc) [9] [2,3])
19:53:24 <nineonine> is there a specific exception that is thrown?
19:53:29 <Axman6> Anupknj: no, you're skipping ahead again
19:53:30 <nineonine> or just silent crash?
19:53:30 <EvanR> catch the falling arguments with the lambda
19:53:47 <EvanR> form bonus forms... or something
19:53:55 <Axman6> one step at a time please Anupknj :)
19:54:18 <Anupknj> (\x->\acc->x:x:acc) 1 (\x->\acc->x:x:acc)2 (\x->\acc->3:3:9) 
19:54:18 <EvanR> make sure it has a dubstep soundtrack
19:54:39 <Axman6> (\x->\acc->x:x:acc) 1 ( foldr (\x->\acc->x:x:acc) [9] [2,3]) becomes 1:1:(foldr (\x->\acc->x:x:acc) [9] [2,3])
19:54:52 <Anupknj> (\x->\acc->x:x:acc) 1 (\x->\acc->x:x:acc) [3,3,9] [2]
19:54:56 <Axman6> we substitute x for 1, and acc for (foldr (\x->\acc->x:x:acc) [9] [2,3])
19:55:09 <Axman6> no, you're still skiping ahead
19:55:23 <Axman6> you haven't shown you understand what's actually going on yet
19:55:54 <Axman6> Anupknj: do you undersatand the step : (\x->\acc->x:x:acc) 1 ( foldr (\x->\acc->x:x:acc) [9] [2,3]) becomes 1:1:(foldr (\x->\acc->x:x:acc) [9] [2,3])?
19:56:01 <Anupknj> (\x->\acc->1:1:[2,2,3,3,9]) 
19:56:10 <Anupknj> [1,1,2,2,3,3,9]
19:56:19 <Axman6> no
19:56:23 <Anupknj> right or wrong?
19:56:29 <Axman6> wrong
19:56:43 <Anupknj> omg...could you tell me the answer...ill figure it out 
19:56:49 <dmwit> nineonine: It is not catchable.
19:57:21 <Anupknj> do you undersatand the step : (\x->\acc->x:x:acc) 1 ( foldr (\x->\acc->x:x:acc) [9] [2,3]) becomes 1:1:(foldr (\x->\acc->x:x:acc) [9] [2,3])?
19:57:22 <Anupknj> yes
19:57:31 <nineonine> sooo.... silent crash is correct answer?
19:57:44 <nineonine> is it documented somwehre?
19:57:46 <dmwit> It isn't silent. It displays information on stderr.
19:57:51 <Axman6> Anupknj: you already know that the answer is [11,22,33,9] but you clearly don't understand why that is the answer. that is what I'm helping you to do. if you don't want the help, then let me know
19:58:30 <Anupknj> your help is not helping me
19:58:31 <Axman6> uh, [1,1,2,2,3,3,9], sorry
19:59:11 <Axman6> the help would be more useful if you paid attention to what you're being asked to do, but you keep doing things which you weren't asked to do
19:59:29 <EvanR> probably better to just let Anupknj go
19:59:43 <nineonine> ok if it dumps something to stDerr, is there a specific message ?
19:59:53 <Anupknj> hm..
20:00:00 <Axman6> yeash I did decide after last night's rude response to help to not help, I guess I should folow through. you're on your own Anupknj
20:00:24 <Anupknj> last night' response??
20:00:35 <dmwit> nineonine: Yes. Why not write a small program that allocates a lot, and set a nice small heap size, to see it?
20:01:03 <nineonine> I could do that, of course! thanks for the suggestion
20:01:14 <nineonine> I was just hoping it is documented somewhere
20:01:14 <Axman6> Are you not the same person as anup from last night, who was asking questions that were clearly homework for a university course?
20:01:31 <Anupknj> oh..yes
20:01:33 <dmwit> nineonine: I don't know of a place it is documented. You might poke around in the GHC Commentary.
20:01:41 <Axman6> I believe it was EvanR who was trying to help you, and you were very rude to him too
20:01:42 <Anupknj> i was studying for midterm and i was in hurry
20:01:52 <Anupknj> i was in rush
20:01:53 <nineonine> I am on it!
20:02:01 <monochrom> Ah then it was EvanR's mistake. >:)
20:02:10 <EvanR> i don't recall
20:02:12 <dmwit> nineonine: Which is intended to describe how the runtime system works to new GHC developers; since this is a runtime system thing, that would be the place to talk about it if anything did.
20:02:19 <Anupknj> its not intentional...it was impulse
20:02:26 <Axman6> Anupknj: we're happy to help you learn, but you need to put in the effort. there are no shortcuts to understanding
20:02:36 <Anupknj> thank you guys..exam went well
20:02:58 <monochrom> I was on a math channel and we guys on the math channel learned it the hard way. If the deadline is tomorrow, the student is unable to learn today.  Don't bother answering.
20:03:08 <Anupknj> sorry ..if i had hurt anyone...i was completely got carried awy
20:03:11 <Anupknj> away
20:03:32 <dmwit> monochrom: (Sometimes the student is unable to learn the day after tomorrow, too.)
20:03:42 <monochrom> So typically we didn't "help" anyone on Sundays.
20:03:49 <Axman6> do you want to have another go at understanding why foldr (\x->\acc->x:x:acc) [9] [1,2,3] is equal to [1,1,2,2,3,3,9]?
20:04:00 <Anupknj> yeah sure
20:05:17 <Anupknj> foldr (\x->\acc->x:x:acc)  [1,2,3,9]
20:05:35 <Axman6> we got to  1:1:(foldr (\x->\acc->x:x:acc) [9] [2,3]), the next thing to evaluate is the call to foldr again. which equation for foldr does foldr (\x->\acc->x:x:acc) [9] [2,3] match?
20:05:37 <Axman6> @src foldr
20:05:37 <lambdabot> foldr f z []     = z
20:05:37 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:06:36 <Anupknj> 1:1:2:2(foldr (\x->\acc->x:x:acc) [9] [3]
20:07:09 <Axman6> not quite the answer I was looking for, but (nearly) correct
20:07:17 <Axman6>  1:1:2:2:(foldr (\x->\acc->x:x:acc) [9] [3]
20:07:17 <Anupknj> 1:1:2:2:(foldr (\x->\acc->3:3:9)
20:07:27 <nineonine> interesting discussion here: https://gitlab.haskell.org/ghc/ghc/issues/1791
20:07:46 <nineonine> which indicates there is not Heap overflow exception thrown at the moment
20:08:14 <Anupknj> 1:1:(2:2:(3:3:9))
20:08:23 <Anupknj> [1,1,2,2,3,3,9]
20:08:36 <Axman6> not quite. youy'rte satill skipping steps and making mistakes because of it
20:08:42 <Axman6> you're*
20:09:00 <Axman6> one substitution at a time please =)
20:09:13 <Anupknj> it becomes long
20:09:23 <Anupknj> thats why skipping steps
20:09:36 <Axman6> we've got to 1:1:2:2:(foldr (\x->\acc->x:x:acc) [9] [3], we can evaluate the foldr again, that matches the second case, with x = 3 and xs = []
20:09:52 <Anupknj> ok
20:10:07 <Axman6> but you're getting the wrong answers because you're skipping steps
20:10:19 <Anupknj> ok
20:10:40 <Anupknj> go on
20:10:46 <Axman6> so, is we evaluate the foldr in 1:1:2:2:(foldr (\x->\acc->x:x:acc) [9] [3] we get 1:1:2:2:3:3:(foldr (\x->\acc->x:x:acc) [9] [])
20:10:58 <Axman6> which equation of foldr does _this_ call match?
20:11:08 <Axman6> @src foldr
20:11:08 <lambdabot> foldr f z []     = z
20:11:08 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:11:12 <Axman6> top or bottom
20:11:18 <Anupknj> foldr f z []     = z
20:11:19 <dmwit> ?index Natural
20:11:20 <lambdabot> GHC.Natural, Numeric.Natural
20:11:25 <Axman6> good
20:12:04 <Axman6> so if it matches that equation, we only care what z is, so what is z?
20:12:38 <Anupknj> 1:1:2:2:3:3:9:9:[]
20:12:52 <Axman6> no
20:12:56 <Axman6> what does z equal
20:13:08 <Axman6> stop taking shortcuts >_<
20:13:23 <Axman6> if I ask you a question you should answer that question, not another one
20:13:36 <Anupknj> z is []
20:13:43 <Axman6> no
20:13:52 <Anupknj> z is 9
20:14:04 <Axman6> foldr (\x->\acc->x:x:acc) [9] [] matches foldr f z [], which means that z = [9]
20:14:12 <Anupknj> yes
20:14:40 <Axman6> ok, so we get 1:1:2:2:3:3:[9]
20:14:46 <Anupknj> yes
20:14:48 <Axman6> which is the same as [1,1,2,2,3,3,9]
20:15:04 <Anupknj> ok...i said the same in the beginning
20:15:20 <dmwit> Yes. But when you said it in the beginning, you were wrong.
20:15:38 <Axman6> yes, but you didn't undersatand why that was the answer. the answer doesn't matter, why it is the answer is what matters
20:16:06 <Anupknj> right
20:16:29 <Anupknj> now i get it ...thanks
20:16:43 <Axman6> if I give you this problem, will you get the correct answer? foldr (\x -> \acc -> x:(x*x):acc) [7,6,5] [1,2,3]
20:16:54 <Anupknj> sure..ill try
20:17:03 <Axman6> Anupknj: I'm not convinced you do get it yet
20:17:11 <Anupknj> hm...
20:17:13 <EvanR> o_O
20:17:17 <Anupknj> let me try
20:17:56 <Axman6> go for it. please feel free to show all the steps (apologies to everyone else, this is probably going to continue to be noisy)
20:18:10 <monochrom> Don't worry, it's good.
20:19:33 <Anupknj> [1,1,2,4,3,9,7,6,5]
20:19:46 <Anupknj> right?
20:19:48 <Axman6> why?
20:19:52 <Axman6> you tell me
20:20:18 <iqubic> :t foldr
20:20:19 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
20:20:26 <Axman6> I don';t care about the answe, I care _why_ it is the answer
20:20:27 <Anupknj> foldr (\x -> \acc -> x:(x*x):acc) [7,6,5] [1,2,3]
20:20:57 <Axman6> and so does your lecturer. they know the answer, they want to know if you understand why it is the answer
20:21:02 <Anupknj> 1:1 :(foldr (\x -> \acc -> x:(x*x):acc) [7,6,5] [2,3])
20:21:21 <Axman6> you've skipped a step again =)
20:21:54 <Axman6> I'm not very smart, I can't see why we have 1:1:, where did that come from?
20:22:11 <Anupknj> 1:1:(2:4:(foldr (\x -> \acc -> x:(x*x):acc) [7,6,5] [3]
20:22:26 <Anupknj> after applying foldr function to [1]
20:22:37 <Axman6> why do we get a 2:4: now?
20:22:51 <Anupknj> applying foldr function to [2]
20:23:02 <Anupknj> x:(x*x)
20:23:36 <Axman6> @src foldr
20:23:36 <lambdabot> foldr f z []     = z
20:23:37 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:24:27 <Anupknj> 1:1:(2:4:(3:9((foldr (\x -> \acc -> x:(x*x):acc) [7,6,5] [])))
20:24:28 <Axman6> what is the very first thing that happens after we call foldr (\x -> \acc -> x:(x*x):acc) [7,6,5] [1,2,3]; it gets substituted for the right hand side of the equation which matches the call, correct?
20:24:33 <Axman6> what is that substitution?
20:24:45 <Anupknj> 1:1:2:4:3:9:7:6:5
20:24:55 <Axman6> nope
20:25:40 <Anupknj> empty list in the end is replaced by accumulator
20:25:54 <Axman6> foldr (\x -> \acc -> x:(x*x):acc) [7,6,5] [1,2,3] becomes  (\x -> \acc -> x:(x*x):acc) 1 (foldr (\x -> \acc -> x:(x*x):acc) [7,6,5] [2,3])
20:26:04 <Axman6> that's the answer I want to see
20:26:30 <Anupknj> ok..got it
20:26:32 <Axman6> it's long, but luckily we have computers to do this for us once we understand it
20:26:40 <Anupknj> yup
20:27:19 <Axman6> so what happens when we evaluate  (\x -> \acc -> x:(x*x):acc) applies to  1 (and only the 1)
20:27:24 <Axman6> applied*
20:27:59 <Axman6>  (\x -> \acc -> x:(x*x):acc) 1 (foldr (\x -> \acc -> x:(x*x):acc) [7,6,5] [2,3]) = ??? (when we substitute x for 1)
20:28:01 <Anupknj> 1:1: foldr(\x -> \acc -> x:(x*x):acc) [7,6,5] [2,3]
20:30:24 <Axman6> close, going back one step we have:  (\x -> \acc -> x:(x*x):acc) 1 (foldr (\x -> \acc -> x:(x*x):acc) [7,6,5] [2,3]) ==>  (\acc -> 1:(1*1):acc) (foldr (\x -> \acc -> x:(x*x):acc) [7,6,5] [2,3])
20:31:12 <Axman6> and  (\acc -> 1:(1*1):acc) (foldr (\x -> \acc -> x:(x*x):acc) [7,6,5] [2,3]) ==>  1:(1*1):(foldr (\x -> \acc -> x:(x*x):acc) [7,6,5] [2,3])
20:31:21 <Axman6> we're being _really_ explicit here
20:33:36 <Axman6> Anupknj: do those steps make sense?
20:34:12 <iqubic> ertegrul had a really nice explanation of all of this on his website. It's a shame that he's not around any more.
20:34:12 <Axman6> Anupknj: you've definitely shown improvement from an hour ago btw, good work :)
20:35:09 <Anupknj> i understand it....
20:35:14 <Anupknj> thank you
20:35:33 <Anupknj> its easy to write all steps on paper than typing
20:36:22 <Anupknj> Anyways...thank you so much for the time
20:36:43 <Anupknj> great explanation
20:36:45 <Axman6> Usually I would do these steps in a text editor - for each step, take the previous step, paste it, and then edit it to show what the next step of execution is
20:36:54 <Axman6> and repeat
20:37:04 <Anupknj> oh..ill try that
20:37:18 <iqubic> Actually, Ertugrul's foldr tutorial is still online, and still on his website.
20:37:19 <iqubic> https://ertes.eu/tutorial/foldr.html
20:37:36 <iqubic> How odd. I wonder who's paying the server upkeep costs.
20:37:54 <EvanR> ertes!
20:37:57 <Anupknj> looks good
20:38:18 <kaol> http://foldr.com/
20:38:26 <iqubic> He's been gone for like 1 year. How is his website still online?
20:38:49 <Axman6> nothing ever dies on the internet
20:38:51 <EvanR> death and the internet is weird
20:39:15 <Anupknj> so..u guys are haskell developers??
20:39:24 <Anupknj> or learning?
20:39:25 <Axman6> my website would be up for several years until my domain expired
20:39:58 <Axman6> I'm a Haskell developer
20:40:20 <Anupknj> great
20:40:21 <iqubic> Axman6: You have a website? This is news to me.
20:40:23 <kaol> It's usual to have years of experience with Haskell and still be learning.
20:40:28 <iqubic> Can you link it here?
20:40:47 * Axman6 .com
20:40:57 <Axman6> there's not much on it
20:41:30 <EvanR> you should have but \b in your domain so that would have worked
20:42:05 <Axman6> ha
20:43:32 <Anupknj> one more question
20:43:55 <Anupknj> can one just integrate module to project in haskell?
20:44:16 <Anupknj> say...module in haskell integrated to pyhton project
20:44:25 <Anupknj> *python
20:45:38 <Axman6> not easily, no. it can be done by using their foreign function interfaces and exporting functions as C functions, but this is not trivial
20:46:24 <Anupknj> ok..so if u want to do a project using haskell...Entire thing has to be in haskell?
20:46:58 <dmwit> That is the most common way, to be sure.
20:46:59 <Axman6> ususally yes, but it's not that hard to call C from Haskell
20:47:10 <dmwit> If the project is big enough, you may find it worthwhile to overcome the cost of using the FFI.
20:47:14 <dmwit> Eventually.
20:47:20 <Anupknj> FFI?
20:47:29 <dmwit> Foreign function interface.
20:47:35 <Anupknj> oh..i see
20:47:46 <dmwit> The part of the language which lets you call (or expose) C functions.
20:48:03 <Anupknj> what kind of projects are built using haskell?
20:48:16 <dmwit> You could browse Hackage...?
20:48:21 <maerwald> Anupknj: web apps, backend etc are most common
20:48:23 <Anupknj> cool
20:48:35 <Anupknj> wow
20:48:59 <Anupknj> i need to explore more then...
20:49:01 <maerwald> because these have good coverage wrt libraries and frameworks
20:49:16 <maerwald> with other domains, you will have less luck often
20:49:32 <maerwald> but that's an ecosystem issue, not a language issue (most of the time)
20:49:59 <Anupknj> hm...
20:50:12 <Anupknj> i want to do a small awesome project
20:50:24 <Anupknj> beginner level
20:50:29 <Anupknj> any suggestion???
20:50:31 <maerwald> what domains are you interested in
20:51:00 * hackage language-thrift 0.11.0.0 - Parser and pretty printer for the Thrift IDL format.  https://hackage.haskell.org/package/language-thrift-0.11.0.0 (abhinav)
20:51:01 <Anupknj> what are the domains apart from web development
20:51:02 <Anupknj> ?
20:51:10 <maerwald> anything
20:51:35 <Anupknj> ML?
20:51:44 <heatsink> There is groq
20:51:55 <heatsink> But, that's not a beginner project
20:52:11 <maerwald> Anupknj: machine learning?
20:52:15 <Anupknj> yes
20:52:44 <Axman6> we use Haskell for building data processing systems on AWS
20:52:59 <Anupknj> oh..sounds interesting
20:53:07 <Anupknj> i know litttle bit of aws
20:53:20 <maerwald> Anupknj: don't have much knowledge about that domain or how good library coverage is, but https://github.com/austinvhuang/awesome-haskell-deep-learning
20:53:31 <heatsink> Writing a ray tracer is a nice, small project.  You would need to know some math related to 3D vectors.
20:53:45 <maerwald> there are tensorflow bindings
20:54:00 <Anupknj> oh...cool
20:54:13 <Anupknj> but looks advance level
20:54:20 <Axman6> for machine learning, there's also Grenade, which is insanely cool - it's all type safe machine learning, no more mismatch between the output of one layer and the input of another
20:55:11 <maerwald> Anupknj: if you like image creating/generation stuff (you can also use it to visualise simple 2d algorithms), diagrams is interesting: https://archives.haskell.org/projects.haskell.org/diagrams/
20:55:23 <heatsink> ooh, grenade looks nice
20:56:37 <Anupknj> great....got couple of ideas
20:56:47 <Axman6> jle`'s blog posts on singletons nicely ties in with how grenade can be used to load networks of dynamic shape at runtime, as long as the inputs and outputs match the expected sizes
20:56:49 <Anupknj> ill research and pick one and work
20:56:59 <Axman6> Anupknj: good luck
20:57:14 <Axman6> Anupknj: and thanks for putting in the effort to learn today, it's been good
20:57:43 <Anupknj> i was not interested in haskell in the beginning.....just doing it for course
20:57:52 <Anupknj> but now i think its interesting
20:57:57 <Anupknj> want to explore more
20:58:03 <Axman6> welcome to the club
20:58:18 <Anupknj> thanks to you guys
20:58:43 <Anupknj> if i had not come here, i would be just finishing course
20:58:53 <Anupknj> great platform
21:00:23 <maerwald> heh, finally someone not just asking homework questions ;)
21:00:31 <Anupknj> haha
21:00:39 <maerwald> (we've had a lot of those lately)
21:01:19 <Anupknj> this site is mentioned in learnyouhaskell book
21:01:36 <Anupknj> hence lot of students come in for answer
21:01:48 <Anupknj> thats how i came
21:01:57 <maerwald> Anupknj: most people don't recommend lyah for learning
21:02:03 <maerwald> check out https://www.cis.upenn.edu/~cis194/spring13/ instead
21:03:37 <Anupknj> thank you,..i will look into it
21:05:15 <Anupknj> see you guys.....hopefully not with the homework;D 
21:38:00 * hackage process 1.6.6.0 - Process libraries  https://hackage.haskell.org/package/process-1.6.6.0 (MichaelSnoyman)
21:46:30 <svipal> yo
21:47:12 <svipal> Does anyone know what became of "setSourceName" in megaparsec ? trying to convert this exemple https://www.schoolofhaskell.com/user/marcin/quasiquotation-101 to megaparsec
21:52:37 <svipal> (actually the whole getPosition/setPosition)
22:00:05 <svipal> nvm got it
22:15:10 <ashwin> Hi, I was trying to build a web server using Warp and hasql.  But I'm having trouble getting them to co-exist.
22:15:24 <ashwin> installing hasql breaks Warp and vice-versa.
22:15:32 <Axman6> "breaks" how?
22:17:07 <ashwin> Warp is pulling in http-date-0.0.8. which creates a version conflict with attoparsec that hasql needs.
22:17:30 <Axman6> what are you using to build your project?
22:17:48 <ashwin> cabal
22:17:56 <ashwin> not sandboxed
22:18:10 <Axman6> have you tried allow-newer? not sure how you do that with cabal
22:18:19 <Axman6> you should try sandboxed first
22:19:38 <ashwin> will give that a go.  Is stack preferred over cabal in general??
22:19:39 <Axman6> using cabal unsandboxed is generally a bad idea
22:20:26 <sclv> new-build is the most common way these days
22:21:03 <ashwin> Axman6: understood!  This is my first haskell experiment.  So I haven't polluted the global "namespace" much yet. 
22:21:32 <ashwin> sclv: Got it. I'll check that out, thank you. 
22:24:45 <ashwin> Axman6: Sandboxed build fixed it.
22:24:54 <ashwin> Thank you!
22:25:22 <ashwin> Why does it not report similar conflicts though?  Since I need the exact same packages within the sandbox.
22:32:38 <jzyamateur> When we are talking about "type level expressions" and "type variables", is a Type-Constructor valid where a type variable is needed e.g. a "typeclass definition" when we say "instance Monad Maybe", there we see "Maybe" is a TypeConstructor.
22:34:18 <Axman6> @kind Monad
22:34:19 <lambdabot> (* -> *) -> Constraint
22:35:12 <jzyamateur> I mean when I see "class Monad m where ...", I see that m is the type variable.
22:36:11 <jzyamateur> When I see the instance definition "instance Monad Maybe", I see the typeconstructor "Maybe" is a valid for type variable "m"
22:36:49 <Axman6> it is a type variable, but for something with kind * -> T, not *
22:37:16 <Axman6> uh, *->*
22:37:37 <jzyamateur> Yes Maybe typeconstructor is itself parametrized to be realized into a concrete type.
22:37:57 <jzyamateur> But that doesn't have to do with anything with what I said earlier right?
22:39:01 <svipal> not related sorry : Where did extQ go ?
22:40:22 <svipal> it's not in Language.Haskell.TH.Quote or Language.Haskell.TH
22:41:06 <cocreature> svipal: https://hoogle.haskell.org/?hoogle=extq%20is%3Aexact
22:41:34 <svipal> yeah I looked it up but were the quasiquotation tutorials using syb ??
22:41:52 <cocreature> jzyamateur: it depends on the kind of a type variable, if like for Monad the kind is * -> * then Maybe is acceptable. if the type variable has kind * e.g. Monoid then Maybe does not work
22:42:00 <cocreature> svipal: probably? hard to say without knowing the tutorial
22:43:35 <svipal> these ones : https://wiki.haskell.org/Quasiquotatio, https://www.schoolofhaskell.com/user/marcin/quasiquotation-101 and I don't see syb
22:45:54 <cocreature> “import Data.Generics” very much looks like syb
22:46:38 <svipal> *slaps own face*
22:46:59 <jzyamateur> cocreature Got it, I just saw full definition for Monad which has explicit restriction on type constructor to have kind *->*
22:47:32 <svipal> sorry for the dumb question .. but really does everyone and their mothers use syb to write quasiquoters these days ?
22:49:25 <svipal> just for that one function whose source is tiny af 
22:55:01 <dminuoso> jzyamateur: Note that it may not be specified explicitly. It could have been inferred from `class Functor m => Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b` from either a) the type signature of return, the type signature of (>>=) or from the superclass constraint.
22:57:12 <jzyamateur> Even functor typeclass says "class Functor (f :: * -> * ) where"  and f is the type variable
22:57:17 <dminuoso> And it's these methods that limit it to `* -> *`
22:57:41 <dminuoso> Since, the method must accept something of type `a` it *must* be *-kinded (since * is the kind of all inhabitatable types)
22:58:07 <dminuoso> And since the methods presume the existance of values of type `m a`, it too must be *-kinded
22:58:28 <cocreature> jzyamateur: no it doesn’t? https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#Functor has no explicit kind annotation
22:59:14 <jzyamateur> ah, it shows up when i do ":i Monad" or ":i Functor" in GHci
22:59:24 <dminuoso> jzyamateur: Right, that's just GHCi being nice to you.
22:59:42 <dminuoso> jzyamateur: Alternatively you could also ask `:k Monad`
23:02:22 * dsal is behind on RSS and just got to https://xkcd.com/2210/
23:03:22 <jzyamateur> Isn't it a good idea to annotate types as much as possible? especially when everything is very higher order/kinded etc.?
23:07:30 <sm[m]> doh.. RSS.. so that's how you follow xkcd
23:14:30 * hackage hw-kafka-client 2.6.1 - Kafka bindings for Haskell  https://hackage.haskell.org/package/hw-kafka-client-2.6.1 (alexeyraga)
23:20:22 <dminuoso> `+RTS -xc` tells me GHC.List.CAF is the source of `Prelude.head: empty list` exception. What exactly does that tell me?
23:26:14 <nshepperd> probably that you need to set -fprof-auto to get more cost center annotations?
23:28:27 <dminuoso> nshepperd: Mm, why the CAF bit though? Which CAF is it?
23:34:31 <dminuoso> nshepperd: Though Im already building with `cabal v2-build --enable-profiling --profiling-detail all-functions`
23:37:09 <cal[m]> anyone still on?
23:38:57 <dminuoso> Oh hah.
23:39:03 <dminuoso> Reading the GHC manual helps, nshepperd. :-)
23:40:39 <Axman6> cal[m]: there are over a thousand people in this channel, there is _always_ someone still on
23:46:40 <trcc> https://gist.github.com/CThuleHansen/6203ab9a1728b74aa7c3d039248ce491 the Right x -> Right x seems unnecessary. Is there a good way to write this better?
23:48:51 <Soft[m]> http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Arrow.html#v:left Maybe this
23:50:43 <trcc> hmm not, do not think se. 
23:50:45 <trcc> so*
23:51:33 <MarcelineVQ> trcc: pretend a is ->
23:51:41 <trcc> ahh
23:52:20 <MarcelineVQ> relatedly there's first from Bifunctor
23:52:43 <Axman6> which is probably the more common way to do that these days
23:52:45 <MarcelineVQ> where p is Either
23:52:55 <Axman6> :t first
23:52:56 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
23:53:02 <Axman6> bad lambdabot
23:53:10 <Axman6> :t Data.Bifunctor.first
23:53:11 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
23:53:23 <trcc> first :: (a -> b) -> Either a c -> Either b c
23:53:31 <trcc> Thanks. I will try to work with it
23:58:12 <trcc> Hurray. It works
23:58:13 <trcc> Thanks
