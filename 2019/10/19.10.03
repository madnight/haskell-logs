00:04:30 * hackage language-ats 1.7.2.0 - Parser and pretty-printer for ATS.  https://hackage.haskell.org/package/language-ats-1.7.2.0 (vmchale)
00:27:30 * hackage warp 3.3.3 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.3.3 (KazuYamamoto)
00:43:30 * hackage regex-pcre-builtin 0.95.1.1.8.43 - PCRE Backend for "Text.Regex" (regex-base)  https://hackage.haskell.org/package/regex-pcre-builtin-0.95.1.1.8.43 (AudreyTang)
01:02:37 <Ariakenom> % floor (log 0) :: Int -- D:
01:02:38 <yahb> Ariakenom: 0
01:06:58 <merijn> % log 0
01:06:58 <yahb> merijn: -Infinity
01:07:17 <merijn> oh, right
01:07:36 <merijn> Ariakenom: floor (and really most conversions) from Infinity and NaN are wonky
01:42:12 <Ariakenom> merijn: yeah. very D:
01:42:51 <merijn> Ariakenom: I mean, it's not really obvious what the alternative is
01:43:57 <Ariakenom> merijn: bottom is much better
01:44:07 <Ariakenom> % floor (log 0) :: Integer -- interestingly
01:44:07 <yahb> Ariakenom: -179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216
01:44:27 <merijn> Just never convert from Double to anything else ;)
01:46:12 <Ariakenom> it's very convenient for my logarithmic numbers
01:46:17 <Ariakenom> :)
01:48:34 <Ariakenom>  > [0, 0.1, 0.5, 1, 2, 3] :: [L8]
01:48:42 <Ariakenom> [3.90625e-3,9.63881765879963e-2,0.5,1.0,2.0,2.9536522918789987]
01:49:07 <Ariakenom> strange number types are fun
01:52:43 <Ariakenom> for all the badness of haskell's number system the overloading is fun to play with
01:55:29 <maerwald> what is L8?
01:56:09 <Ariakenom> newtype L8 = L8 Int8
01:56:20 <Ariakenom> L8 x = 2**(x/16)
01:57:07 <Ariakenom> a number represented as 2^x where x is a signed fixed point number
01:57:32 <Ariakenom> also with just 8 bits because that's more fun :D
01:58:10 <Ariakenom> (currently) there is no sign bit and no zero
02:00:04 <Rembane> data L08 = LZero | L8 Int8
02:00:08 <Rembane> Is fix! 
02:01:25 <Ariakenom> thank
02:02:10 <Ariakenom>  > 100 + 100 :: L8
02:02:14 <Ariakenom> 197.40298565221642
02:02:18 <Ariakenom> eh close enough
02:03:33 <maerwald> xD
02:10:59 <Ariakenom> here's the code https://gist.github.com/Ariakenom/bee6f59a12fcf79c6229c64213360aac
02:22:39 <Ariakenom> when I started testing fractionals with L8 at first didn't work. I realized I had used Word8 and I needed Int8. the only thing I had to change was the newtype declaration and add an import. \o/ In something like C that type would have been spread everywhere.
05:00:38 <bolver> question:  i have a list [[1,3],[4,6],[7,9],[10,12]] and i want to get [[3,4],[6,7],[9,10]].  is there a neat way to do this using foldr & higher order functions??
05:02:11 <Rembane> bolver: Yes! Check out the solve'! https://gist.github.com/Rembane/14273990cb3b25d53d022de42ccc364d
05:11:16 <bolver> Rembane: thanks, by the way.  the solution you've given is for a question i had posed some days ago on haskell channel?
05:11:37 <Rembane> bolver: Yeah, I just assumed it was the same. :D
05:11:59 <Rembane> bolver: I had the solution done about two seconds after you left.
05:12:09 <bolver> Rembane: i see
05:15:24 <bolver> Rembane: that one i solved it on similiar lines that you've done, using a combination of recursion and foldr
05:15:42 <Rembane> bolver: Sweet! 
05:16:31 <bolver> but i was still wondering if there is a better way to do it, avoiding recursion altogether
05:17:46 <bolver> the essential question is -- if recursion involves dependencies between elements of a list, then i am feeling that just using foldr may not work
05:18:33 <bolver> because foldr just spins thru each element, so hard to factor dependencies between elements
05:18:39 <Rembane> That is true. Then you need to augment the list with something. 
05:18:53 <Ariakenom> bolver: did you look at solve' ?
05:19:11 <bolver> Ariakenom: yes
05:19:37 <bolver> Ariakenom: in fact, i solved the same problem some days on similiar lines
05:21:00 <Ariakenom> but what do you mean by not using recursion then?
05:21:48 <Ariakenom> there are two different solutions in that link
05:21:55 <Ariakenom> solve and solve'
05:22:06 <Rembane> From line 7 and forward it becomes exciting: https://gist.github.com/Rembane/14273990cb3b25d53d022de42ccc364d#file-lists-hs-L7
05:31:46 <bolver> Ariakenom: i am not what you ar asking me
05:32:55 <bolver> Ariakenom: ah, i see ... let me check again
05:39:42 <bolver> Remavas: nice solution -- sorry for overlooking it on my part.  thanks
05:40:36 <bolver> Ariakenom: thanks for pointing it out -- i got what you were saying earlier about solve'
05:41:52 <Ariakenom> bolver: nice
05:42:11 <bolver> Rembane: nice solution in solve'  -- i overlooked it at first.  clever way of using a function with zipWith
05:42:43 <bolver> Rembane: i learned something there from your solve'
05:43:16 <bolver> Rembane: thanks
05:48:30 * hackage mono-traversable 1.0.13.0 - Type classes for mapping, folding, and traversing monomorphic containers  https://hackage.haskell.org/package/mono-traversable-1.0.13.0 (MichaelSnoyman)
05:48:48 <bolver> Rembane: zipWith is pretty cool, if you know how to use it cleverly, as you done zipWith xss $ tail xss
05:49:11 <ski> @quote aztec
05:49:11 <lambdabot> alpounet says: map succ/pred is a scandinavian name generator or what? ... well, scandinavian and aztec
05:49:24 <ski> @quote aztec.god
05:49:24 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
05:51:18 <Rembane> ^^
05:51:28 <Rembane> bolver: No worries. :)
06:12:30 * hackage publicsuffix 0.20191003 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20191003 (wereHamster)
06:13:00 <kwaleko> hi
06:14:22 <kwaleko> anyone using nix with spacemacs?
06:18:51 <lavalike> @fresh
06:18:51 <lambdabot> Hati
06:58:29 <tabaqui1> I still get an error during stack build "[info] Unable to get a write lock on the Stack database, waiting..."
06:58:49 <tabaqui1> but now, I've rebuild stack and filelock with trace output
06:59:10 <tabaqui1> Here is the last lines of it:
06:59:13 <tabaqui1> "Release lock on C:\\build\\SRC\\.stack-work\\stack.sqlite3.pantry-write-lock"
06:59:18 <tabaqui1> "Acquire lock on C:\\build\\SRC\\.stack-work\\stack.sqlite3.pantry-write-lock"
06:59:20 <tabaqui1> "Lock exception, code=33"
06:59:25 <tabaqui1> "Lock failed on C:\\build\\SRC\\.stack-work\\stack.sqlite3.pantry-write-lock"
07:00:33 <tabaqui1> ERROR_LOCK_VIOLATION: The process cannot access the file because another process has locked a portion of the file.
07:01:30 <tabaqui1> how could this be possible, if I know all requests made with filelock dependency?
07:01:50 <merijn> Something crashed/failed and didn't clean up an existing lock file
07:02:31 <tabaqui1> in this case, I would see an dirty request in the trace
07:03:03 <tabaqui1> s/an/a
07:05:33 <tabaqui1> probably, I don't trace all methods, I'll rebuild and start again
07:10:57 <inkbottle> I've been looking for examples of Monadic Parser Combinators applied to the Haskell language, and I haven't found anything
07:12:19 <merijn> inkbottle: What do you mean? You mean like using parser combinators to parse Haskell?
07:12:45 <inkbottle> merijn: or even subsets of it
07:13:27 <merijn> I'm sure some people have written something like that, but I don't know any well known implementations
07:13:31 <merijn> inkbottle: Why, specifically?
07:14:35 <inkbottle> merijn: primary practical purpose, to make helper functions for editors
07:15:04 <merijn> inkbottle: I don't think there's any implementations that are complete enough for that
07:15:36 <inkbottle> merijn: toy like examples very much welcome
07:15:38 <merijn> inkbottle: There's https://hackage.haskell.org/package/haskell-src-exts for parsing things, but that's probably not what you want
07:18:15 <inkbottle> merijn: I've tried it, and no, not what I want; perhaps because it's too complicated for me to understand it; even the output it's giving is cryptic iirc; plus it might be using happy under the hood and not a monadic parser
07:18:44 <merijn> Although, tbh, writing a parser that's good enough for stuff like indentation probably wouldn't be too hard
07:19:23 <merijn> Depending on how complicated you want to get with what you do with the source
07:19:43 <tabaqui1> nothing changed
07:20:27 <inkbottle> I don't think indentation is the primary concern; I've found descriptions of Haskell grammar and those descriptions was very difficult to understand
07:20:34 <tabaqui1> I'll make a bug report
07:20:57 <merijn> inkbottle: You mean the ones in the report?
07:21:11 <merijn> What did you have trouble with?
07:22:01 <inkbottle> merijn: probably... the description in itself contains so many "nodes" or generators; very difficult to grasp for human mind
07:22:23 <inkbottle> the nodes have cryptic names
07:22:39 <inkbottle> hang on that I have it in front of me
07:23:00 <merijn> inkbottle: You're not supposed to grasp (or implement it) in a single go. You first implement the leaves as parser combinators, than implement the higher nodes from your leaf parsers
07:24:05 <inkbottle> merijn: sure, I'll keep that (nice way to put it by the way) in mind
07:25:02 <merijn> inkbottle: I have a (fairly minimal and simple-ish) parser for a lambda calculus lying around you can look at as example (don't look at the rest, the typechecking was horribly broken so I deleted it and never had time to reimplement..)
07:25:12 <merijn> inkbottle: https://github.com/merijn/lambda-except/blob/master/Parser.hs parts of it are also in Lexer.hs
07:25:34 <inkbottle> merijn: mice, tx a lot
07:25:41 <inkbottle> nice*
07:25:53 <merijn> inkbottle: It corresponds (very roughly) to the grammar/language from the Henk paper: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.50.7152&rep=rep1&type=pdf
07:27:47 <inkbottle> Are you using a separate tokenizer? (this part of "parsec" has evolved a lot lately I understood; and again not so many examples using a tokenizer)
07:28:03 <merijn> inkbottle: Not really
07:28:09 <inkbottle> OK
07:28:23 <merijn> There's a *very* minimal sort of tokenization in Lexer.hs, but it mostly deals with tracking indents/comments
07:28:41 <merijn> inkbottle: Incidentally, if you're gonna start something new I'd recommend megaparsec over parsec
07:28:57 <inkbottle> why that?
07:29:21 <inkbottle> I've looked at the two of them, and made examples with the two of them
07:29:26 <merijn> inkbottle: Parsec is essentially "maintenance only" and conflics with a bunch of modern Haskell (Applicative/Alternative/etc.)
07:29:38 <inkbottle> really?
07:29:48 <merijn> inkbottle: Megaparsec started off as a fork of parsec that fixed those things and then started improving/adding features
07:30:06 <merijn> inkbottle: Well, when parsec was initially written those things didn't exist :p
07:30:41 <merijn> inkbottle: Many of the combinators/operators in Control.Applicative were copied from/inspired by Parsec, but they have slightly different precedences
07:30:49 <inkbottle> I've understood, a lots of changes have taken place in Parsec, very recently
07:31:06 <inkbottle> OK, i'll keep that in mind
07:31:15 <inkbottle> didn't know about it too
07:31:36 <merijn> inkbottle: If I look at the parsec commit history I don't see lots of changes, tbh
07:31:46 <boxscape> I don't suppose a way to tell ghci to just crash the current execution instead of all of ghci if a segfault occurs? yahb somehow manages it, it seems
07:32:06 <inkbottle> merijn: Also, I find both as easy to use
07:32:09 <merijn> boxscape: Not easily
07:32:13 <boxscape> okay
07:32:18 <merijn> inkbottle: Well sure, the API is almost identical, on purpose :p
07:32:44 <merijn> inkbottle: There's nothing wrong with the core idea/API of parsec, it was just a bunch of legacy stuff that got cleaned up with megaparsec :)
07:33:40 <maerwald> backtracking depends on types, doesn't it?
07:34:10 <inkbottle> merijn: I was refering to "The Text.ParserCombinators.Parsec module hierarchy contains the legacy parsec-2 API and may be removed at some point in the future."; which might not be *that* new btw.
07:34:53 <inkbottle> merijn: anyway, tx a lot
07:47:03 <geekosaur> the "may be removed" has been there since shortly after parsec3 came out, iirc
07:47:17 <geekosaur> but there's a lot of stuff including tutorials and such still referring to it
07:48:06 <geekosaur> boxscape, a segfault takes out the whole process and process memory can't generally be trusted afterward. yahb restarts ghci if it dies.
07:48:39 <boxscape> geekosaur: so yahb keeps track of everything that was defined and defines it again after it restarts?
07:48:50 <boxscape> or wait
07:48:54 <boxscape> maybe I'm misremembering
07:50:58 <boxscape> yeah okay defined variables are gone after it segfaults
07:58:01 * hackage haskoin-store 0.17.2 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.17.2 (xenog)
08:03:01 <boxscape> % a <- newIORef []
08:03:01 <yahb> boxscape: 
08:03:03 <boxscape> % :t a
08:03:03 <yahb> boxscape: IORef [GHC.Exts.Any]
08:03:09 <boxscape> is the Any part a ghci specific thing?
08:03:26 <boxscape> not Any itself but the fact that it defaults to Any
08:10:33 <geekosaur> %% :show language
08:10:33 <yahb> geekosaur: http://qp.mniip.com/y/14
08:10:42 <lyxia> It's a GHC thing at least. I'm not sure to what extent the standard explains how to type things.
08:11:25 <geekosaur> I'd expect defaulting to () normally, but ghci so at minimum ExtendedDefaultRules (and I did the wrong show)
08:11:29 <geekosaur> %% :showi language
08:11:30 <yahb> geekosaur: http://qp.mniip.com/y/15
08:11:55 <geekosaur> hm
08:13:25 <boxscape> what's the default declaration that ghci has?
08:13:26 <lyxia> defaulting to () only works at kind Type
08:15:28 <boxscape> maybe I'm misreading the docs but it doesn't seem to me like they say that ExtendedDefaultRules should default something like this
08:15:30 <ski> boxscape : in SML/NJ, it would invent a new "skolem constant" (like an abstract data type) `X' (in an unspecified module, `?'), and use that. next time, a new type
08:15:50 <lyxia> it's not part of the default rules
08:16:21 <boxscape> ok
08:16:28 <ski> boxscape : in OCaml, it'd invent a new meta-variable, `_a', and `a' would get the type `IORef [_a]' (no `forall'). as soon as you used `a' so as to pin down `_a', that meta-variable would disappear
08:16:32 <lyxia> default rules explain how to default types that have constraints on them
08:16:45 <ski> (so `_a' is just a place-holder, until the context determines which actual type to use)
08:17:35 <lyxia> but when there is no constraint it's 100% safe to default to something arbitrary, which GHC calls Any
08:17:55 <ski> (but it uses the same `Any', every time)
08:18:00 * hackage sequenceTools 1.4.0.5 - A package with tools for processing DNA sequencing data  https://hackage.haskell.org/package/sequenceTools-1.4.0.5 (stephan_schiffels)
08:18:02 <boxscape> hm, okay
08:19:09 <lyxia> that it leaks in ghci is a little bad but not a big deal.
08:20:25 * geekosaur wonders what would happen if it printed that type as _ instead of Any
08:20:34 <Tritlo> Shouldn't there be a function `fromDyn_maybe :: Dynamic -> Proxy a -> Maybe a` somewhere?
08:20:53 <boxscape> looks like you can at least unsafeCoerce it to a concrete type after that, though I'm not sure if that's always safe
08:21:08 <boxscape> (assuming you use the same type every time)
08:21:12 <Tritlo> Currently I can't tell if it managed to extract the value or not :/
08:21:37 <boxscape> Tritlo how is that better than fromDynamic?
08:22:12 <boxscape> ...or maybe you didn't know about fromDynamic? I can't quite tell
08:22:30 * hackage semilattices 0.0.0.4 - Semilattices  https://hackage.haskell.org/package/semilattices-0.0.0.4 (robrix)
08:22:59 <boxscape> % :t Data.Dynamic.fromDynamic
08:22:59 <yahb> boxscape: Typeable a => Dynamic -> Maybe a
08:25:10 <Tritlo> boxscape: ah oof, I should have looked harder... I was convinced I needed to provide the type as input somehow
08:25:30 <boxscape> Tritlo if you run into a situation where that's really necessary, you can use TypeApplication
08:25:43 <EvanR> red herring, Proxy a  isn't the type as input, types don't exist at runtime
08:26:04 <EvanR> But Typeable is the standin
08:29:00 <boxscape> % print (fromDynamic @Integer (toDyn 4)) -- Tritlo: you can use this instead of a Proxy
08:29:00 <yahb> boxscape: Just 4
08:31:14 <Ariakenom> anyone know anything about CIS194 past 2016 with CodeWorld?
09:05:00 * hackage semantic-source 0.0.0.1 - Types and functionality for working with source code  https://hackage.haskell.org/package/semantic-source-0.0.0.1 (robrix)
09:40:00 * hackage language-ats 1.7.3.0 - Parser and pretty-printer for ATS.  https://hackage.haskell.org/package/language-ats-1.7.3.0 (vmchale)
10:23:06 <joel135> In a presentation, tail recursion can be implemented as "...; In the rest of my talk I would like to say something about ..." It helps memory allocation in listeners :-)
10:26:26 <iqubic> Lol.
10:28:45 <dsal> Every time I do manual recursion I feel like I've failed to understand something.
10:52:34 <boxscape> hm, so I know you can write a variadic printf in Haskell, and I've implemented something similar with liftA where the first argument (in printf the String, in liftA the function) determines how many more arguments a function should take. Is it possible to have a variadic function where the first argument doesn't have that information? I'm trying to
10:52:34 <boxscape> implement listOf, which takes an arbitrary number of arguments and returns a list of them, but I always get stuck somewhere
11:02:38 <lyxia> there's a printf in base that's like that https://hackage.haskell.org/package/base-4.12.0.0/docs/Text-Printf.html
11:07:51 <int-e> boxscape: The string provided to printf does not determine the number of arguments... you'll get a runtime error if the format string and the arguments don't match. It's the result type (String, or IO ()) that marks the end of the arguments...
11:09:04 <boxscape> hm, I'm pretty sure that you *can* implement a typesafe printf in haskell, but the one in base might not be. But in that case I guess what I'm asking for is probably possible...
11:09:17 <int-e> boxscape: so the same approach as taken for printf will work for listOf, but you need to fix the result type to be a list (by a type annotation, for example). Otherwise the compiler will not know whether  listOf  should be of type [a], a -> [a], a -> a -> [a], and so on.
11:09:24 <boxscape> okay
11:09:39 <jp_rider> Hi. How do I get the [Id](https://hackage.haskell.org/package/ghc-8.6.5/docs/Var.html#t:Id) of [I#](https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Exts.html#v:I-35-)?
11:10:30 * hackage skylighting-core 0.8.2.3 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-core-0.8.2.3 (JohnMacFarlane)
11:11:30 * hackage skylighting 0.8.2.3 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-0.8.2.3 (JohnMacFarlane)
11:28:04 <oats> hi there, just got a quick question. Is there a more elegant way I could write this little function? http://ix.io/1XuR/hs
11:28:39 <oats> just counting things in an array according to a key
11:32:01 <dsal> Not really more elegant, but using RecordWildCards would make it less repetitive.
11:32:35 <oats> use a record instead of a tuple?
11:32:38 <merijn> Or even NamedFieldPuns (I missed the question)
11:33:00 <dsal> merijn: http://ix.io/1XuR/hs
11:33:10 <dsal> That, but with more elegance.
11:33:50 <merijn> ctype is a record field?
11:34:05 <merijn> Because you can already do that more nicely without any extensions
11:34:30 <merijn> Also, guards + == for this is no bueno :)
11:35:52 <oats> merijn: yeah, ctype is a field
11:36:27 <oats> lol, sorry :P
11:36:52 <merijn> I mean, the simplest/most obvious fix would be: https://paste.debian.net/1104057/
11:38:45 <dsal> You could do something like:  https://www.irccloud.com/pastebin/MOe7YJMd/this.hs
11:39:10 <merijn> Alternate more verbose form (assuming the constructor of Component is Component: https://paste.debian.net/1104058/
11:41:02 <oats> mm, I like those
11:41:04 <oats> thanks a lot :)
11:41:41 <merijn> oats: FYI, matching constructors with == is generally a bad idea compared to pattern matching
11:41:54 <oats> right, I should've realized that :P
11:42:05 <merijn> oats: Because it requires an Eq constraint
11:42:16 <MarcelineVQ> case ctype component of ...
11:42:23 <boxscape> okay, I did manage to implement listOf now. (trick was to have a helper function that uses an accumulator)
11:42:32 <merijn> :t let f l | l == [] = True in f
11:42:33 <lambdabot> Eq a => [a] -> Bool
11:42:44 <merijn> :t let f [] = True in f
11:42:45 <lambdabot> [a] -> Bool
11:42:55 <merijn> MarcelineVQ: Yeah, that was my first suggestion
11:42:58 <dsal> I don't know NamedFieldPuns.  I've heard suggestions that might be better than RecordWildcards for some problem I've not run into recently.  :)
11:43:21 <merijn> dsal: It's "recordwildcards, but with explicit names instead of .."
11:43:25 <MarcelineVQ> merijn: oh okay ehe, I had that in the buffer and figured I'd clear hehe
11:43:43 <dsal> merijn: that's how I read it at a glance.  I'm sure I'll suffer someday and come back to that.  :)
11:43:53 <merijn> dsal: So if we have "data Foo = Foo {bar :: Int, baz :: String}" then you can do "f Foo{bar} = ..."
11:44:21 <dsal> Oh, so just grab a subset?
11:44:27 <merijn> dsal: Yeah
11:44:35 <dsal> Yeah that looks useful.
11:44:52 <merijn> dsal: Which is better, because 1) adding a field doesn't run the risk of shadowing and breaking something, and 2) it's more obvious which names come from the record
11:45:33 <dsal> Yeah.  I've got at least one case in front of me where that'd be slightly better.
11:47:12 <dsal> Cool.  It improved three cases.  {..} was good in a few others.
11:47:48 <MarcelineVQ> Anecdotally RecordWildcards use seemed to be more for the updating than the selecting
11:48:17 <MarcelineVQ> Though puns has its own related improvement there
11:49:30 * hackage birch-beer 0.2.1.0 - Plot a colorful tree.  https://hackage.haskell.org/package/birch-beer-0.2.1.0 (GregorySchwartz)
11:51:38 <boxscape> % 2e
11:51:38 <yahb> boxscape: ; <interactive>:14:2: error: Variable not in scope: e
11:51:48 <boxscape> hm I'm getting a different error message for some reason
11:52:25 <boxscape> I'm getting "Non type-variable argument in the constraint Num (t1 -> t2)"
11:52:48 <boxscape> why would that be
11:52:51 <merijn> % 2 pi
11:52:51 <yahb> merijn: ; <interactive>:15:1: error:; * Could not deduce (Floating t0); from the context: (Floating t, Num (t -> t1)); bound by the inferred type for `it':; forall t t1. (Floating t, Num (t -> t1)) => t1; at <interactive>:15:1-4; The type variable `t0' is ambiguous; * In the ambiguity check for the inferred type for `it'; To defer the ambiguity check to 
11:53:06 <merijn> boxscape: You're accidentally using a number as a function
11:53:21 <boxscape> merijn but why does yahb show a different error message
11:53:29 <merijn> boxscape: So it infers "Num (a -> b)", etc.
11:53:54 <merijn> boxscape: Probably it's inferring a fixed return type for the function which violates the constraint specification, since that requires FlexibleContexts
11:54:05 <merijn> > 2 True
11:54:07 <lambdabot>  error:
11:54:07 <lambdabot>      • No instance for (Num (Bool -> ())) arising from a use of ‘e_12’
11:54:07 <lambdabot>          (maybe you haven't applied a function to enough arguments?)
11:54:31 <shapr> > let 5 = 2 + 2
11:54:33 <lambdabot>  <no location info>: error: not an expression: ‘let 5 = 2 + 2’
11:54:36 <shapr> aw
11:54:42 <boxscape> hm okay I'll check if I get the same error message if I enable all the same extensions
11:54:44 <shapr> > let 2 + 2 = 5 in 2 + 2
11:54:47 <lambdabot>  5
11:54:50 * shapr cackles cheerfully
11:55:19 <shapr> > let 5 = 2 + 2 in 5
11:55:21 <lambdabot>  5
11:55:23 <boxscape> % let 5 = 4
11:55:23 <yahb> boxscape: 
11:55:40 <shapr> both of those are weird edge cases
11:55:44 <boxscape> I guess it's okay because it's never used?
11:56:20 <shapr> let 2 + 2 = 5 is "create a new infix operator called + that matches only one case, where both first and second arguments are the value 2. When that is matched, explicitly return 5
11:56:47 <shapr> let 5 = 2 + 2 I'm not completely sure, but I think it's a pattern match with zero patterns, so it just vanishes
11:56:57 <boxscape> > let a@5 = 2+2 in a
11:56:59 <lambdabot>  *Exception: <interactive>:3:5-13: Non-exhaustive patterns in a@5
11:57:02 <merijn> shapr: It's never forced
11:57:24 <shapr> I used smdiehl's "ghci-core" alias to investigate "let 5 = 2 + 2" and it produces an empty result, perhaps the dead code is pruned?
11:57:42 <shapr> ghci-core shell alias is here: http://www.stephendiehl.com/posts/ghc_03.html
11:59:37 <shapr> merijn: still curious why the core is empty
12:00:09 <boxscape> merijn hm, maybe it's another extension but with or without FlexibleContexts the error messages of my ghci and of yahb do not change and remain different
12:00:44 <boxscape> well, my ghci error message changes a bit, but not much
12:01:04 <boxscape> ah
12:01:08 <boxscape> it's AllowAmbiguousTypes
12:02:47 <boxscape> (at least enabling that brings my ghci to yahb's error message, though disabling it in yahb doesn't change it)
12:04:35 <shapr> ghc error messages have improved so much the past few years: In module ‘System.Process’: ‘NoStream’ is a data constructor of ‘StdStream’ To import it use import System.Process( StdStream( NoStream ) ) or import System.Process( StdStream(..) )
12:04:39 * shapr hops cheerfully
12:10:00 * hackage bitvec 1.0.1.2 - Space-efficient bit vectors  https://hackage.haskell.org/package/bitvec-1.0.1.2 (Bodigrim)
12:19:27 <boxscape> This seem reasonable enough or am I making things more complicated than they have to be? https://gist.github.com/JakobBruenker/42b35d27c025b6d286b0090461158fc4
12:19:30 <boxscape> (my variadic listOf)
12:22:40 <iqubic> Looks great
12:24:08 <jle`> boxscape: instead of a type family you can also use an mptc, or maybe an associated type would clean it up
12:24:19 <jle`> boxscape: but i think definitely the entire problem itself is something more complicated than it has to be ;)
12:24:32 <boxscape> that's fair :)
12:24:58 <boxscape> but thanks I'll see if I can make something I like more with one of those
12:25:29 <jle`> class ListOfable a t | t -> a where listOfWithAcc :: [a] -> t
12:25:51 <boxscape> okay
12:25:52 <jle`> instance ListOfablea [a] where ...
12:26:11 <jle`> instance ListOfable a t => ListOfable a (a -> t) where ..
12:26:18 <boxscape> thanks
12:26:46 <jle`> if you like the type family then it might make more sense to use it as an associated type instead of sitting outside of the typeclass for cleanliness
12:27:05 <boxscape> okay
12:31:00 * hackage too-many-cells 0.2.1.0 - Cluster single cells and analyze cell clade relationships.  https://hackage.haskell.org/package/too-many-cells-0.2.1.0 (GregorySchwartz)
13:27:35 <boxscape> hm apparently there were already mailing list discussions about something like OverloadedLabels in 2006
13:28:05 <boxscape> (see here https://mail.haskell.org/pipermail/haskell-prime/2006-February/000463.html)
13:30:33 <ooo_miguel> I am playing with the haskell OpenGL bindings and wonder what the fastest way to preserve some state would be? Should I use mvars?
13:36:06 <Zemyla> So the name for the typeclass with a function hoist :: (??? t, Functor g) => (forall x. f x -> g x) -> t f a -> t g a is MFunctor, right?
13:37:56 <Zemyla> Is there an MFoldable, like mfold :: (MFoldable t, Applicative g) => (forall x. f x -> g x) -> t f a -> g a?
13:39:56 * geekosaur misses hayoo
13:42:39 <ooo_miguel> and now something completely different. How is it resolved (on hackage) if there are two "imports" with the same name?
13:43:07 <ooo_miguel> i. e. can there be two packages providing System.Foo.Bar ?
13:43:15 <geekosaur> it isn't; you're expected to manage packages appropriately
13:43:31 <geekosaur> and there's PackageImports for those rare cases where you need both/mulltiple
13:43:32 <ooo_miguel> what does "manage appropriately" mean?
13:44:11 <dmwit> ooo_miguel: Yes, MVars, or inversion of control.
13:44:26 <dmwit> ooo_miguel: Hackage doesn't care if two packages provide the same module.
13:44:51 <geekosaur> nothing grabs from hackage all by itself as such, your build infrastructure should decide what to do including warning you of the collision and letting you decide to switch to a non-colliding package or use PackageImports or whatever
13:44:51 <dmwit> ooo_miguel: If you make a cabal project that depends on two packages providing the same module, imports of that module will fail at compile time.
13:45:17 <ooo_miguel> so a rare case where I require both colliding packages might occur right? 
13:45:47 <geekosaur> the PackageImports extension extends imports with: import "packagename" Module.Name (with the usual "as" etc. so you can distinguish them in your code)
13:46:28 <dmwit> ooo_miguel: Yes, that can happen.
13:47:27 <ooo_miguel> geekosaur: ah ok. makes sense. not that I came across such a collision in real, but I was jus concerned ;), thanks 
13:47:55 <ooo_miguel> I did not know / forgot  about this PackageImports extension
13:48:49 <geekosaur> https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html#package-qualified-imports
13:49:00 <ooo_miguel> dmwit: concerning my "state sharing" question. Where can I read about this "inversion control" approach?
13:49:10 <ooo_miguel> "state preserving"
13:49:11 <geekosaur> interestingly it doesn't say how you combine it with "qualified" (which comes first?)
13:49:39 <geekosaur> hm, and I see it now points you to backpack instead
13:51:12 <ooo_miguel> dmwit: I read on wikipedia for a start ;)
13:52:46 <ooo_miguel> but I suppose I can just pass some state around, based on which I keep creating a new state on each iteration
13:55:08 <ooo_miguel> I like this explenation (from wikipedia): Inversion of control is sometimes facetiously referred to as the "Hollywood Principle: Don't call us, we'll call you". 
14:12:34 <mastarija> How can I write a block of text in a haskell module documentation without it being ignored or interpreted as function description?
14:14:06 <mastarija> I've seen I can do the named document chunk, but then I have to do list all of my functions in the module export list if I want to have it in correct order.
14:20:16 <ski> ooo_miguel : fwiw, <https://philipnilsson.github.io/Badness10k/escaping-hell-with-monads/> briefly mentions it ..
14:22:58 <ski> <http://www.vex.net/~trebla/haskell/cont.xhtml#quantifiers>
14:23:06 <ski> @hackage managed
14:23:06 <lambdabot> http://hackage.haskell.org/package/managed
14:24:38 <ski> % :t traverse (ContT . BS.useAsCString) >=> ContT . Foreign.Marshal.withArray  -- courtesy of mniip,2019-09-10,<http://tunes.org/~nef/logs/haskell/19.09.10>
14:24:38 <yahb> ski: [BS.ByteString] -> ContT r IO (Ptr Foreign.C.String.CString)
14:26:43 <dmwit> ooo_miguel: http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html
14:27:08 <dmwit> ooo_miguel: https://www.thev.net/PaulLiu/invert-inversion.html has a lot of the right keywords, but unlike the previous one, I didn't read it, so I'm less confident in recommending it.
14:28:01 * hackage plot 0.2.3.10 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  https://hackage.haskell.org/package/plot-0.2.3.10 (VivianMcPhail)
14:30:48 <Slaus> < 1
14:31:52 <Slaus> > getZipList $ (,,) <$> ZipList "dog" <*> ZipList "cat" <*> ZipList "rat"
14:31:55 <lambdabot>  [('d','c','r'),('o','a','a'),('g','t','t')]
14:32:07 <Slaus> does this example mean you can partially apply tuples?
14:32:13 <Slaus> or I misunderstand something?
14:32:54 <oats> You can partially apply tuples :)
14:33:20 <ski> > zipWith ($) (map ((,,) 'f') "eou") "eom"
14:33:21 <oats> "(,,)" is shorthand for "\a b c -> (a,b,c)"
14:33:22 <lambdabot>  [('f','e','e'),('f','o','o'),('f','u','m')]
14:33:40 <Slaus> but why this doesn't work then:
14:33:49 <Slaus> > (1,2,)
14:33:51 <lambdabot>  error:
14:33:51 <lambdabot>      • No instance for (Typeable t0)
14:33:51 <lambdabot>          arising from a use of ‘show_M12121178696902179534877’
14:34:01 <ski> can't show a function
14:34:11 <Slaus> > let a = (1,2,)
14:34:13 <lambdabot>  <no location info>: error: not an expression: ‘let a = (1,2,)’
14:34:18 <ski> @type ('a','b',)
14:34:19 <lambdabot> t -> (Char, Char, t)
14:34:34 <ski> > ('a','b',) 'c'
14:34:36 <lambdabot>  ('a','b','c')
14:34:47 <ski> > map ('a','b',) "def"
14:34:49 <lambdabot>  [('a','b','d'),('a','b','e'),('a','b','f')]
14:35:15 <Slaus> interesting :)
14:36:15 <Slaus> but how can you store partially apply tuple as a curried function?
14:36:21 <Slaus> for example why it's not working:
14:36:29 <Slaus> > let a = (1,2,)
14:36:31 <lambdabot>  <no location info>: error: not an expression: ‘let a = (1,2,)’
14:36:33 <ski> > let a = (1,2,) in map a "def"
14:36:35 <lambdabot>  [(1,2,'d'),(1,2,'e'),(1,2,'f')]
14:36:39 <ski> works fine, here
14:37:00 <ski> lambdabot does understand `> let ...' with no `in', though
14:37:03 <Slaus> but somehow store for use later?
14:37:03 <ski> sorry
14:37:12 <ski> does not understand
14:37:35 <ski> Slaus : type into module in source file. save file, load into interactor ?
14:39:13 <Slaus> I get "Illegal tuple section: use TupleSections" error, hm
14:39:59 <oats> @type (,,)
14:40:00 <lambdabot> a -> b -> c -> (a, b, c)
14:40:25 <oats> It tickles me that all the tuple types are manually defined
14:43:22 <Slaus> anyway, thank you guys for examples, didn't know you can do tuples partial application stuff like map, etc
14:43:46 <Slaus> creating incomplete tuples doesn't make a lot of sense for me now though, so it's okey ^^
15:32:00 * hackage avro 0.4.5.3 - Avro serialization support for Haskell  https://hackage.haskell.org/package/avro-0.4.5.3 (haskellworks)
15:35:55 <ski> Slaus : you didn't enable the `TupleSections' extension, which is needed for `(1,2,)' .. however `(,,)' should be fine without extensions
15:41:06 <Slaus> ski: like this? https://paste.debian.net/1104106/
15:41:19 <Slaus> getting error: parse error (possibly incorrect indentation or mismatched brackets)
15:41:51 <Slaus> never enabled extensions before =$ 
15:43:35 <boxscape> is this in a .hs file or in ghci?
15:43:45 <boxscape> ^ Slaus
15:44:11 <Slaus> it's tuple.hs file which I try to load with ":l tuple" command
15:44:38 <boxscape> You can't write let bindings like this on the top level. Do it without let.
15:44:49 <boxscape> just "curried_tuple = (1,2,)"
15:45:15 <maralorn> I have a question about library design. I am thinking about writing a library, which offers a standardised set of simple wizard-like user dialogs and offers different backends to run those dialogs (e.g. prompt, ncurses, web, rofi). No I think polysemy would be a great match for that. (Writing one Effect and many effecthandlers.) But that seems highly opinionated for a library to put on hackage. Is there a
15:45:17 <maralorn> way to design a library "effect-system-agnostic".
15:45:19 <maralorn> ?
15:45:20 <Slaus> it worked! thank you
15:45:24 <boxscape> np
15:50:52 <EvanR> maralorn you could try to define a type class for the backend API you will need and let whoever implement instances for the particular system. A driver driver...
15:57:06 <freeman42x> trying to follow the GHCJS install steps in here: https://github.com/ghcjs/ghcjs#quick-start---developing-ghcjs does this look like it succeeded? https://gist.github.com/razvan-flavius-panda/0ed9735e2c335497c25d48798b0b48f6
15:57:59 <freeman42x> running `stack build` after that gives: /home/neo/Sources/ghcjs/lib/ghc-api-ghcjs/: getDirectoryContents:openDirStream: does not exist (No such file or directory)
16:05:00 <maralorn> EvanR: I am not sure if I understand. Something like class MonadDialog?
16:06:20 <EvanR> it might not be possible depending on how different all the effect systems you want to support are
16:06:35 <EvanR> sorry i'm not sure
16:10:18 <maralorn> EvanR: That’s a good question.
16:11:16 <maralorn> I guess the minimum would be offering a Monad and an IO-runner. Most effectsystems can use that somehow.
16:12:17 <maralorn> Then generalizing to make it compatible with mtl would probably help a lot of people.
16:14:15 <maralorn> The question is also how I can be compatible with them all without having them as dependencies.
16:28:41 <jle`> hm, i wonder when the new base is going to show up on hackage
16:28:47 <jle`> it's been like a month now i think
16:29:34 <boxscape> who's responsible for that?
16:29:46 <jle`> good question. i might ask over at #ghc
16:30:59 <jle`> it's not on the stackage docs either so it seems like there is nowhere online publicly to get documentation for it
16:32:10 <boxscape> the haddock comments in the source code are public :P
16:37:33 <jle`> yeah, just not publicly rendered i mean :)
16:37:44 <jle`> with the nice linking and usability benefits conferred
16:37:56 <boxscape> fair
16:58:05 <entel> anyone know a nice haskell eval bot i can get to put in my channel?
17:00:24 <Axman6> well lambdabot exists, and I believe is on hackage. yahb is more modern and seems to be more useful a lot of the time
17:00:33 <Axman6> not sure if yahb is around anywhere
17:00:43 <Axman6> as in, the code
17:01:00 <boxscape> pretty much the only stuff I use lambdabot for these days is the other features that aren't evaluating haskell 
17:03:14 <hpc> yahb's code is gone?
17:03:40 <Axman6> I've never looked it for, so have no idea if it's open source or not
17:05:10 <gaze__> hey guys, is there any example of someone using *parsec to patch a file?
17:06:37 <EvanR> so yahb is like Lt Cmdr Data. One of a kind until you need a season cliffhanger or something
17:06:37 <gaze__> specifically I have a gcode file for a 3D printer and I want to modify some of the commands in it that are sandwiched between comments that take a certain form
17:07:33 <EvanR> you would have to carefully parse while preserving whitespace information
17:07:43 <EvanR> then you could reverse it
17:08:42 <hpc> that sounds like it would be fun to try and generalize
17:08:52 <hpc> substitution combinators, or something like that
17:09:18 <hpc> there are some reversible parser libraries out there
17:10:23 <hpc> they are fairly close to parser combinators, but the things that drop information in *parsec work differently
17:10:48 <Axman6> you could probably steal some stuff from darcs
17:11:30 <shapr> I want to use an IO function on a Maybe value, is this the best way? x <- sequence $ liftM BS.readFile $ Nothing
17:11:54 <hpc> :t mapM
17:11:56 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
17:12:34 <hpc> mapM might be cleaner
17:12:47 <hpc> :t mapM openFile (Just "/etc/passwd")
17:12:49 <lambdabot> error:
17:12:49 <lambdabot>     Variable not in scope: openFile :: [Char] -> m b
17:12:52 <hpc> % :t mapM openFile (Just "/etc/passwd")
17:12:52 <yahb> hpc: IOMode -> Maybe (IO Handle)
17:12:57 <shapr> er, oh
17:13:04 <shapr> hpc: thanks, I'll try that
17:13:13 <shapr> hpc: also, I'll try to meet you again next time I'm in the area!
17:13:14 <gaze__> @EvanR That was one idea... I was also thinking of a parser that generates patch ranges, and then you process the patch ranges and the original document in parallel to execute the patch
17:13:14 <lambdabot> Unknown command, try @list
17:13:20 <hpc> pretend that's a better example operation
17:13:46 <hpc> shapr: yeah, i really wanted to go but it would have ended up being pretty much the whole day getting into the city
17:14:16 <hpc> like 10 to 2 or something like that
17:14:22 <EvanR> gaze__: sounds interesting
17:14:33 <shapr> hpc: no worries, we can meetup some other time
17:14:40 <hpc> yeah
17:14:45 <shapr> hm, I want to float this Maybe through several steps
17:16:02 <hpc> eventually you should just use MaybeT
17:23:00 * hackage fold-debounce 0.2.0.9 - Fold multiple events that happen in a given period of time.  https://hackage.haskell.org/package/fold-debounce-0.2.0.9 (debugito)
17:31:00 * hackage wild-bind-x11 0.2.0.8 - X11-specific implementation for WildBind  https://hackage.haskell.org/package/wild-bind-x11-0.2.0.8 (debugito)
17:47:12 <nshepperd> gaze__: i've written something like that based on this primitive: findAll :: Parser a -> Parser [Either Text a]
17:48:42 <gaze__> How’s that work?
17:59:28 <nshepperd> it finds all hits of the parser in the range (together with the unmatched text)
17:59:46 <nshepperd> so that if foo is a reversible parser, findAll foo is a reversible parser
18:07:00 * hackage fast-logger 3.0.0 - A fast logging system  https://hackage.haskell.org/package/fast-logger-3.0.0 (KazuYamamoto)
18:08:00 * hackage wai-logger 2.3.6 - A logging system for WAI  https://hackage.haskell.org/package/wai-logger-2.3.6 (KazuYamamoto)
18:08:45 <nshepperd> well, i guess the actual primitive is hits :: (a -> Text) -> Parser a -> Traversal' Text a
18:18:39 <nshepperd> which is made of that
18:30:26 <boxscape> so in HEAD, visible dependent quantification in kinds is implemented. Which means you can write something like "type family F (t :: forall a -> a -> *)". Yet if you write something like "type family G (t :: forall a (b :: a) . a -> (b :: a) -> *)", ghc claims that it's not okay, because `b` has kind `a` instead of being a type. Does that make
18:30:26 <boxscape> sense? It seems like `a` in `F` should produce the same error.
18:36:52 <boxscape> hmm or maybe not
18:36:58 <boxscape> I don't know I'm confused
18:38:35 <quiet_laika[m]> im way out of my element
18:38:54 <boxscape> you would get that warning if you typed "forall (a :: b) -> a -> *" and I feel like that probably makes sense
18:38:55 <quiet_laika[m]> but my intuition is that b has kind a, but a has kind `Type`?
18:39:01 <boxscape> yeah that sounds right
18:39:25 <boxscape> I think for some reason I didn't think `a` would have kind Type
18:40:29 <quiet_laika[m]> having slight distinctions between type and value level terms (idk if thats even correct terminology) makes things like this harder for me to follow
18:49:38 <boxscape> % test :: * -> Int -> Int; test t int = int
18:49:38 <yahb> boxscape: 
18:49:42 <boxscape> this is kind of funny
18:49:47 <boxscape> I had no idea you could use * in types
18:51:23 <boxscape> (not that it's particularly useful... yet)
18:56:42 <novum> anyone know how to take 8 bits and flip them around using bitwise operators such that if you start with 0b1000 then you get 0b0001 ... 0b0100 -> 0b0010 .. etc
18:58:11 <boxscape> novum: if no one has implemented a haskell version yet this has a few good solutions that should be adaptable - but it doesn't look like there's anything that's both elegant and efficient https://stackoverflow.com/questions/2602823/in-c-c-whats-the-simplest-way-to-reverse-the-order-of-bits-in-a-byte
18:59:09 <novum> thank you very much. it's for python also but I am trying to stay within the bit realm, for I am operating on bit boards. sorry for working in poopthon, don't kill me, it's for a group project *hides*
18:59:26 <novum> I couldn't quite wrap my head around how to, and I guess that explains why .. 'preciate it a lot though
19:00:22 <novum> grrrrr I might just end up using  reversed('{:08b}'.format(the_number)))  how horrible .. I am converting it to a string anyway
19:00:31 <novum> ''.join(reversed(..))
19:03:18 <crestfallen> hi this compiles but I'm getting a hasCallStack error on line 8 (mappend = undefined). Should this work with the way I have main written?  https://termbin.com/6c20
19:03:49 <EvanR> novum: yep, reverse will reverse a string... of bits
19:03:59 <EvanR> > reverse "01000"
19:04:01 <lambdabot>  "00010"
19:04:19 <dmwit> crestfallen: Suppose it did work. What would you expect it to do?
19:04:26 <dmwit> (And why?)
19:04:27 <EvanR> if you are working with machine words, your computer might have a bit reversal opcode
19:04:42 <novum> yes but it's a number. So, I guess in haskell reverse $ show the_number and similar thing in python might be fastest, but that is sad
19:04:55 <novum> *cries on inside*
19:06:00 <Axman6> crestfallen: what do youy expect it to do instead of throwing an error
19:06:05 <EvanR> > let f = read . reverse . show in f 100100111
19:06:08 <lambdabot>  *Exception: Prelude.read: no parse
19:06:11 <EvanR> > let f = read . reverse . show in f 100100111 :: Int
19:06:13 <lambdabot>  111001001
19:06:16 <EvanR> \o/
19:06:17 <crestfallen> I don't know I figured it wouldn't work since mappend is undefined. the book says "expected output" the first one being Only (Sum {getSum = 2})
19:06:49 <novum> heck it. I am going to make a heckin' tuple that returns the appropriate string
19:07:02 <crestfallen> or in this case {getSum = 8}
19:07:07 <EvanR> also this is funny, what is the opposite of \o/
19:07:10 <dmwit> crestfallen: This is almost certainly intended to be an exercise, and the "expected output" is telling you a way to check if you got the exercise right.
19:07:11 <EvanR> > reverse "\o/"
19:07:13 <lambdabot>  <hint>:1:12: error:
19:07:13 <lambdabot>      lexical error in string/character literal at character '/'
19:07:21 <dmwit> > reverse "\\o/"
19:07:24 <lambdabot>  "/o\\"
19:07:26 <EvanR> game over gmane
19:07:29 <crestfallen> the paragraph is written a bit convoluted or I'm reading it that way
19:08:27 <crestfallen> the main statement I wrote just hoping it would work
19:09:20 <crestfallen> but oh hold on sorry I see yeah I forgot this book writes undefined as the incompleted part
19:09:52 <dmwit> > let f n = go 8 0 n; go 0 m _ = m; go i m n = go (i-1) (shiftL m 1 .|. (n .&. bit 0)) (shiftR n 1) in f 0b01000000
19:09:54 <lambdabot>  error: Variable not in scope: b01000000
19:10:07 <dmwit> > let f n = go 8 0 n; go 0 m _ = m; go i m n = go (i-1) (shiftL m 1 .|. (n .&. bit 0)) (shiftR n 1) in f 0x40
19:10:08 <lambdabot>  2
19:10:16 <dmwit> novum: ^
19:10:52 <EvanR> holy bejmoly
19:11:41 <boxscape> are there no binary literals in ghc?
19:11:48 <dmwit> There are, but you need an extension turned on.
19:11:51 <boxscape> ah
19:12:15 <dmwit> Wow, I really like the second answer at boxscape's link.
19:12:34 <EvanR> optimizing a karnaugh map to do the reversal on N bits is like, digital logic 101
19:13:24 <EvanR> or black magic depending on who is doing it
19:14:05 <boxscape> yeah the second answer is neat
19:15:03 <crestfallen> tbh dmwit I cannot follow the preceding text of that exercise   https://termbin.com/avez
19:15:37 <EvanR> if only you could cross N wires on silicon, you could just do like Ж
19:16:08 <crestfallen> its entitled reusing Algebras by asking for Algebras. that should stop anyone in their tracks
19:17:19 <boxscape> EvanR it should still be pretty simple to do on silicon if you don't insist on crossing them all at the same point, I would think
19:17:36 <EvanR> yeah i thought of that, but then you need to make all the wires the same length somehow
19:17:43 <EvanR> if you don't want to introduce extra latency
19:18:00 <EvanR> sounds like a good nerdsnipe
19:19:00 <EvanR> actually i already know what the shape looks like
19:19:08 <boxscape> EvanR brute force solution would be to just introduce some serpentines into the shorter paths but I'm not sure if that's something people do on silicon or only on PCBs
19:19:28 <dmwit> Why not use the shape suggested by the second answer in boxscape's link? ^_^
19:19:52 <boxscape> I think that would need more real estate, and a lot more transistors than 0
19:20:03 <dmwit> Why?
19:20:24 <boxscape> Oh I guess you don't technically need the ORs, huh
19:20:29 <dmwit> right
19:20:47 <boxscape> okay, fair enough, that could work
19:20:47 <EvanR> ok this is wrong but is technically "swapping" https://imgur.com/a/fpKiQSv
19:21:03 <boxscape> pretty
19:21:36 <boxscape> that's step one of the second answer
19:21:45 <EvanR> yeah i generated it with a quasi quoter with input [a b c d e f g h -> e f g h a b c d]
19:22:02 <boxscape> @pl \a b c d e f g h -> e f g h a b c d
19:22:03 <EvanR> let me try [a b c d e f g h -> h g f e d c d a]
19:22:03 <lambdabot> ((((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .))
19:22:20 <EvanR> yeah
19:22:48 <EvanR> mine outputs adjacent swaps and identity
19:23:07 <EvanR> and is way bigger
19:23:21 <crestfallen> dmwit if you're defining mappend, I'm thinking we need 2 statements in a where clause
19:23:21 <EvanR> but i tried to make sure it was "optimal"
19:23:36 <crestfallen> since nada doesn't take a type
19:24:17 <crestfallen> or and if/else statement?
19:24:48 <crestfallen> an*
19:29:07 <MarcelineVQ> if won't be useful to you for this exercise, you also don't require where or let, though you're welcome to use them if you do feel the need. start by spelling out the different cases that mappend can have, like Booly did above
19:31:46 <EvanR> boxscape: nice... just do a "half size" version of that picture on the two halfs, then do a "quarter size" version on the last 4 quarters... and all wires are the same length since they all undergo 3 "braidings"
19:31:57 <EvanR> why don't more CPUs have this
19:32:07 <crestfallen> to begin with I don't understand the constraint:     Monoid b => Monoid (a -> b) .. Monoid (a -> b) being the "larger" monoid
19:32:26 <boxscape> EvanR yeah, that's kind of what I expected. I guess it's probably just not used that much in practice.
19:32:39 <crestfallen> I don't know what going on from the beginner of this section.
19:32:46 <EvanR> it makes homework problems too easy
19:32:55 <boxscape> heh
19:33:17 <crestfallen> beginning 
19:33:19 <Hoxtrop[m]> Hyperactive group and I can't understand a thing. Be back once I'm actually learning Haskell.
19:34:00 * hackage net-spider 0.3.2.1 - A graph database middleware to maintain a time-varying graph.  https://hackage.haskell.org/package/net-spider-0.3.2.1 (debugito)
19:34:29 <MarcelineVQ> Monoid b => Monoid (a -> b) says that if b has a Monoid instance so does Monoid (a -> b). How this is useful is that since we have assumed that b has a Monoid instance we're allowed to use b's mappend and mempty in our implementation of Monoid (a -> b)
19:35:29 <boxscape> I just finally really understood what I was confused about earlier with visible dependent quantification - I didn't fully grok that forall introduces a variable that the rest of the type can depend on, where -> doesn't
19:35:30 * hackage net-spider-rpl 0.3.1.0 - NetSpider data model and utility for RPL networks  https://hackage.haskell.org/package/net-spider-rpl-0.3.1.0 (debugito)
19:36:02 <EvanR> i'm wrong, they undergo distinct number of crossings
19:36:10 <boxscape> huh
19:36:30 * hackage net-spider-cli 0.1.0.2 - CLI option parsers for NetSpider objects  https://hackage.haskell.org/package/net-spider-cli-0.1.0.2 (debugito)
19:36:40 <EvanR> um nevermind
19:36:54 <boxscape> okay I was wondering how that's possible
19:37:03 <crestfallen> MarcelineVQ, thanks, working... 
19:37:05 <EvanR> they spend different times "going straight" but it adds up to the same
19:37:19 <boxscape> (though you'd run into trouble if you wanted to reverse anything that's not 2^n bits, probably)
19:37:30 * hackage net-spider-pangraph 0.1.1.1 - Conversion between net-spider and pangraph  https://hackage.haskell.org/package/net-spider-pangraph-0.1.1.1 (debugito)
19:37:34 <EvanR> you still might end up in trouble at very high frequency
19:37:44 <boxscape> what kind of trouble?
19:37:58 <EvanR> let a binary number be a collection of "1 pulses" or nothing
19:38:07 <EvanR> now the pulses will not travel together through this thing
19:38:23 <EvanR> they would arrive at the same time, if there wasn't some weird cross talk
19:38:30 * hackage net-spider-rpl-cli 0.1.1.1 - CLI executable of NetSpider.RPL.  https://hackage.haskell.org/package/net-spider-rpl-cli-0.1.1.1 (debugito)
19:38:45 <boxscape> hm
19:39:11 <EvanR> works if the voltage is varying slowly 
19:39:38 <EvanR> thats just the case no matter what you're doing
19:39:45 <boxscape> this is getting beyond my knowledge of electrical engineering
19:40:10 <EvanR> yeah i think theyre at their frequency limit these days
19:42:00 <crestfallen> what a drag MarcelineVQ I don't understand the text. gotta go thanks for the help
19:42:04 <MarcelineVQ> crestfallen: this is the literal meaning of "Reusing algebras by asking for algebras" Monoid b => Monoid (a -> b) can be read as asking to be allowed to use Monoid b's versions of mempty and mappend when we're working with Monoid (a -> b)
19:42:27 <MarcelineVQ> re-read 12.2 if algebra is a scary word
19:42:31 <MarcelineVQ> *15.2
19:43:25 <crestfallen> ok will do thanks
19:48:17 <MarcelineVQ> should really restart from the book's beginning though and get pattern-matching figured out :( 'if' should not be the instinctual starting point for this task by this point in the text
19:49:13 <EvanR> which book is this
19:49:24 <MarcelineVQ> haskell programming from first principles
19:49:34 <EvanR> i.e. haskellbook ?
19:49:37 <MarcelineVQ> ye
19:49:56 <MarcelineVQ> And about halfway through it
20:29:00 * hackage symbiote 0.0.1.1 - Data serialization, communication, and operation verification implementation  https://hackage.haskell.org/package/symbiote-0.0.1.1 (athanclark)
21:23:36 <EvanR> does anyone know of an article called something like "You could have invented IO" or something
21:23:52 <EvanR> and build IO up as an ADT
21:26:51 <dsal> What is undefined?  I'm a little confused as to how a failure is escaping a poorly defined function.
21:27:28 <dsal> Specifically, I'm using async f >>= link and `fail` does what I expect, but undefined just kind of silently drops things.
21:27:55 <Axman6> @src undefined
21:27:55 <lambdabot> undefined = error "Prelude.undefined"
21:28:01 <Axman6> :t error
21:28:02 <lambdabot> [Char] -> a
21:28:22 <maerwald> dsal: error happens when it's evaluated
21:28:30 * hackage texmath 0.11.3 - Conversion between formats used to represent mathematics.  https://hackage.haskell.org/package/texmath-0.11.3 (JohnMacFarlane)
21:28:31 <Axman6> it's a value that alwys type checks because it will never return a resul, it will only cause an error
21:28:39 <eacameron> Is there a polykinded "Either" I can use?
21:28:51 <Axman6> > error "Oh no!" :: Int 
21:28:54 <maerwald> dsal: so the error doesn't necessarily happen where you "wrote" it
21:28:54 <lambdabot>  *Exception: Oh no!
21:28:55 <int-e> > fix error
21:28:57 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
21:28:59 <Axman6> > error "Oh no!" :: [Bool]
21:29:02 <lambdabot>  *Exception: Oh no!
21:29:04 <dsal> Oh.  that's kind of inconvenient.  Can I make it happen in a particular bit of code?
21:29:09 <maerwald> dsal: yes
21:29:44 <EvanR> dsal: are you sure async isn't reacting properly to it?
21:29:52 <maerwald> dsal: evaluate $ force $ pureComputation
21:29:55 <EvanR> it just hangs?
21:30:04 <dsal> EvanR: If I fail "x" the right thing happens.  If I undefined, it just seems to disappear.
21:30:10 <maerwald> see Control.Exception and Control.DeepSeq
21:30:20 <iqubic> The error occurs when the value is evaluated. But evaluation in Haskell is weird because Haskll lazy by default.
21:30:25 <EvanR> dsal: i mean, are you waiting on this thread in some other thread
21:30:36 <maerwald> dsal: and then you can catch it via: (`withAsync` waitCatch)
21:31:02 <nshepperd> what does 'just seems to disappear' mean? i don't think programs can disappear
21:31:18 <EvanR> conservation of program
21:31:41 <dsal> It's processing incoming packets.  Function is called and then a response is sent back.  If the function has 'undefined' the response never gets sent and the server gets mad and stops sending me data.
21:31:55 <eacameron> I guess Either with Proxy is what I need
21:32:30 <EvanR> dsal: this is why you might want to use more async threads, when the responder crashes, you can react by reporting a 500 or whatever
21:32:56 <EvanR> if any thread whatsoever has a chance of failing, i have a monitor thread (that "can't")
21:33:30 <Axman6> dsal: undefined is a time bomb, it blows up if you look at it. it is not something that should ever be in a progeram except when you intend to define that definition later
21:33:34 <dsal> EvanR: I'm processing the handler with a linked thread.  Well... I guess halfway.  The function itself isn't called in an async.  But yeah, I see what you're saying.
21:34:03 <dsal> Axman6: In this case, it's a user of my library whose undefined function makes weird things happen.  I want to fall apart better when code I'm calling breaks.
21:34:19 <Axman6> :(
21:34:23 <Axman6> yo7u have bad uders
21:34:25 <dsal> Also, I'm the user of my library in this case.
21:34:30 <Axman6> you have bad users too
21:34:36 <EvanR> you can still be more robust in the face of user provided code
21:34:40 <Axman6> you are bad user
21:34:55 <Axman6> but yes, there are ways to handle exceptions better
21:34:57 <EvanR> not responding to a request sounds completely avoidable
21:35:09 <maerwald> catching and evaluating 'error' strictly isn't hard, see above
21:35:11 <Axman6> I would recommend you read Parallel and Coincurrent Programming in Haskell
21:35:21 <Axman6> @where PACPH
21:35:21 <lambdabot> I know nothing about pacph.
21:35:24 <Axman6> @where PACP
21:35:24 <lambdabot> I know nothing about pacp.
21:35:35 <EvanR> @where parallel
21:35:35 <lambdabot> http://www.haskell.org/haskellwiki/Parallel
21:35:43 <heatsink> HDPH?
21:35:53 <heatsink> I mean, DPH?
21:35:57 <Axman6> https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/
21:35:59 <Axman6> no
21:36:13 <nshepperd> it's @where parconc
21:36:15 <Axman6> free to read online (though worth buying because Simon is awesome)
21:37:35 <dsal> Axman6: I've gone through it in the past.  I just want to make sure that if someone does something dumb and I call their stuff, it doesn't just cause confusion.
21:37:42 <dsal> @hoogle pureComputation
21:37:42 <lambdabot> No results found
21:38:09 <dsal> oh.  heh
21:38:22 <Axman6> dsal: then you need to understand asynchronous exceptions, and that's the best resource on the topic
21:39:07 <dsal> Yeah, I mostly get it.
21:40:02 <dsal> It was just a bit odd to me that "fail" worked and "undefined" didn't.  I understand why.
21:40:29 <EvanR> still mysterious what didn't work means
21:40:42 <maerwald> also, did you know that 'try' catches async exceptions? ;)
21:41:56 <EvanR> does parallel and concurrent haskell go into any depth regarding unix processes?
21:42:18 <EvanR> i.e. poor man's concurrent
21:42:53 <Axman6> looks like it does
21:42:57 <EvanR> cool
21:43:10 <dsal> evaluate.force  at least has things fall apart expectedly.
21:43:14 <Axman6> hmm, maybe not, thgat section is about distributed-process
21:43:53 <EvanR> for every question about haskell threads and async exceptions, some functor maps that to unix processes and signals
21:44:30 * hackage mptcp-pm 0.0.2 - A work in progress Multipath TCP path manager  https://hackage.haskell.org/package/mptcp-pm-0.0.2 (teto)
21:46:00 <EvanR> dsal: yes evaluate is your friend
21:46:14 <dsal> Getting rid of this partial function in this program would also be good.
21:46:43 <dsal> But I like knowing that things will still be predictable when misused.
21:46:51 <EvanR> it's a tricky afair, lazy data is computed on demand, not necessarily in the thread that created it
21:47:34 <dsal> Yeah.  I learned that lesson a while back.  Then I forgot it.
21:48:46 <dsal> I still don't fully understand where the undefined actually went.  The behavior was such that the function neither returned nor threw an exception (that link picked up) and yet everything else seemed to continue, so the client was effectively hung.  I had monitoring telling me stuff was breaking, though.
21:48:54 <iqubic> :t evaluate
21:48:56 <lambdabot> a -> IO a
21:49:01 <iqubic> Ouch.
21:49:13 <iqubic> I don't like IO in my pure functions.
21:50:06 <maerwald> "maerwald: dsal: evaluate $ force $ pureComputation" ;)
21:50:24 <dsal> Apparently learned about evaluate on or around Sun Aug 27 05:23:47 2017
21:51:18 <EvanR> iqubic: ... every function is pure, IO or not
21:51:27 <dsal> iqubic: My stuff's pretty dirty here.  I'm implementing a protocol that has callback that can have side effects.  It's pretty great, but I keep finding weird edge cases that can break sometimes.
21:52:03 <int-e> iqubic: in pure functions you just use `seq` at appropriate points (or bang patterns...)
21:53:12 <dsal> I rather rely on this program, so whatever is failing is recent, but a glance at the callback shows a couple ways it can fail poorly.
21:54:41 <dsal> I mean, it's supposed to be kind of impossible.  But also, it's happening.  Maybe I should get a Turing Award.
21:55:05 <EvanR> is the undefined in a function result or in an ADT
21:56:05 <dsal> It's the init of my foldr.  I'm receiving data I've asked for and matching against patterns I asked for.  So it's a little surprising.
21:56:06 <int-e> EvanR: it's a bottom result value
21:56:32 <int-e> I think I lack context, ignore me.
21:56:35 <dsal> I'm not 100% sure this particular problem is happening, but it's the first one.
21:56:57 <EvanR> anyway, you can add different kinds of robustness by wrapping your threads in yet another monitor thread that at least goes "so and so is dead!!!", and perhaps restarts so and so
21:57:19 <EvanR> or takes some other action
21:58:05 <EvanR> if it takes some precarious action of it's own, it gets its own monitor thread
21:58:05 <dsal> Yeah.  I used to program in erlang a lot.  I guess I can do that again.  heh
21:58:50 <EvanR> almost any interaction with the outside world can explode, and apparently dsal's pure functions can also explode. So yeah
21:59:25 <dsal> I'm not entirely sure where the explosion is.
21:59:42 <EvanR> you just said it's undefined at the end of a foldr
21:59:58 <EvanR> your pattern checks somehow didn't
22:00:46 <nshepperd> does the program not print out a big 'exception: undefined!!!'?
22:00:49 <dsal> I don't actually  know how this particular thing is breaking in real life.  I did a little model with undefined and fail.
22:01:13 <EvanR> no logs i presume
22:01:21 <dsal> The program didn't print anything out.  A thread somewhere down deep just stopped doing stuff.
22:02:05 <dsal> The library itself doesn't log.  Is there a way to do that users would be happy about?
22:02:33 <EvanR> doesn't really sounds like a library more like a server
22:02:40 <EvanR> with no logs :)
22:03:18 <dsal> server?  It's just a client library.  The protocol allows concurrent messages inbound and outbound, so I've got a callback to handle inbound messages.
22:03:30 * hackage h2048 0.3.0.0 - An Implementation of Game 2048  https://hackage.haskell.org/package/h2048-0.3.0.0 (javran)
22:04:19 <dsal> I use it in a few places.  It works pretty well for the most part.  This particular failure of a callback was a little surprising.
22:05:03 <EvanR> what evidence do you have it has anything to do with the undefined. I.e. is this a wild goose convo
22:05:52 <dsal> I made a tiny sample program with a callback that was just 'undefined' and it would exhibit the behavior.  If I put 'fail "x"' in the callback instead, it would fall apart as expected.
22:06:14 <dsal> With the evaluate.force, both fall apart expectedly.
22:06:18 <EvanR> not incredibly convincing
22:06:42 <dsal> Always fails in one thing and always succeeds in the other convinced me, at least.
22:07:45 <EvanR> undefined = error "undefined"   can't make a thread hang up
22:08:11 <EvanR> unless... it's specifically catching error and intentionally hanging up?
22:09:14 <dsal> You can try it if you want.  it's github.com/dustin/mqtt-hs -- the last commit added evaluate.force.   the last line of app/example/Main.hs is a callback.  You can run the example and if there's an error in the callback, the client should end up disconnected.  Before that change, undefined would just leave it sitting there neither working nor failing
22:09:36 <EvanR> ah code
22:10:36 <dsal> The last change also shows exactly  where the callback happens.  It's a little complicated in QoS2, but it should be relatively straightforward with async f >>= link
22:12:36 <EvanR> well evaluate . force is redundant
22:13:18 <EvanR> i don't see where undefined would be / is
22:17:02 <dsal> Yeah, I don't know... now I'm getting hung up on more frequently.  The thing I was seeing in the other program is that it was neither proceeding nor failing to proceed.
22:18:33 <dsal> It's quite possible I don't know what the actual failure is.
22:22:19 <EvanR> something about eliminating the impossible
22:22:48 <dsal> Is there an easy way to get a snapshot of threads/stacks on a running process?
22:24:15 <dsal> Because the other possibility is the callback was stuck doing something and just like, never returned.
22:24:27 <EvanR> threadscope
22:25:36 <dsal> I think I've used this before.  Just have to figure out how I even got it.
22:41:41 <dsal> Weird.  I left myself notes.
22:42:08 <EvanR> and so begins one of those escape room games
22:42:57 <dsal> My notes were mostly in the form of a shell script that edits all the lib paths so threadscope will run on my machine.
22:42:58 <dsal> It does!
22:43:14 <dsal> Next is seeing if I can capture data on an ARM64 executable and debug on a Mac.
