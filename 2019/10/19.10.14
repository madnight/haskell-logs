00:07:23 <dminuoso> __dingbat__: I suppose part of the confusion was that you readily used `do` - can you explain why you used it?
00:10:14 <EvanR> though it had no effect in that case
00:10:30 <dminuoso> EvanR: It sort of did, indirectly.
00:10:46 <EvanR> @undo do{ let x = "foo"; return x }
00:10:46 <lambdabot> <unknown>.hs:1:29:Parse error: }
00:11:36 <c_wraith> need more braces to make that happy
00:11:51 <c_wraith> @undo do{ let {x = "foo"}; return x }
00:11:51 <lambdabot> let { x = "foo"} in return x
00:12:38 <EvanR> thx
00:13:31 <dminuoso> Let's just wait and see what they respond. :)
00:13:40 <EvanR> yeah it's funny sometimes do doesn't "do" anything... e.g. do print "foo" vs print "foo"
00:13:58 <dminuoso> By the way, it just occured to me it would be nice to have type applications on do.
00:14:04 <dminuoso> `do @[] { ... }`
00:15:00 <dminuoso> Anyway. Time to replace lens with optics and see how the experience goes. :)
00:15:10 <Ariakenom> in this case do can be compared to braces in C. print str vs do print str. print(str); vs {print(str);};
00:15:54 <EvanR> also demonstrates how "programmable semicolon" isn't always right
00:16:10 <EvanR> in that C code you can't make the semicolon do anything there
00:16:27 <EvanR> if the C code was haskell. Or something
00:18:49 <dminuoso> EvanR: Like all analogies it falls short somewhere.
00:19:11 <Ariakenom> single statement: "put x", "put(x);" multiple statements: "do {put x; put x;}", "{put(x); put(x);};"
00:19:13 <dminuoso> And I think the idea of calling it a programmable semicolon is a bit one-sided and doesn't really capture the essence of it.
00:19:59 <dminuoso> For one the semicolon is just a syntax artifact with no semantics of its own.
00:21:32 <EvanR> as we begin to dwell on do ... it's becoming more and more annoying how it looks spelled totally wrong vs how it's pronounced
00:23:52 <EvanR> do re mi fa
00:25:19 <Ariakenom> spelling reflecting pronunciation? in english? lol
00:25:20 <EvanR> doesn't help that Ariakenom is making good case it being unnecessary
00:26:29 <sshine> EvanR, some friends from university made a jest interview of Bjarne Stroustrup where they asked him unreasonable questions unprepared (sort of like Between Two Ferns, but not rude), and one of them was why he hadn't overloaded the semicolon.
00:26:35 <Ariakenom> usually you use layout syntax and get to lose the braces
00:26:39 <dminuoso> EvanR: Indeed we should also have re-notation and mi-notation.
00:27:00 <EvanR> holy crap yes
00:28:48 <[exa]> guys this is getting out of control
00:29:05 <[exa]> I thought pfannkuchen were a problem
00:29:18 <Ariakenom> I like the comparison more in layout syntax. although it is very similar like this
00:31:21 <macroprep> is it possible to represent a matrix as a row array and column array? or would it need to be represented as a single array (if the matrix itself is to be resizable), eg how would i set row 0 column 1, and row 5 column 1
00:32:11 <maerwald> sshine: xD
00:35:53 <dminuoso> maerwald: There's various forms of encoding matrices. Do you have any particular requirements?
00:36:57 <dminuoso> I meant macroprep :)
00:39:23 <dminuoso> macroprep: In order to represent a matrix you could either: Represent every row or column with a container itself, and store them in another container. You could also store them flat inside a container translate a coordinate into an index.
00:39:34 <dminuoso> There's then optimizations for example for sparse matrices.
00:40:43 <merijn> Or...novel idea
00:40:52 <merijn> You use hmatrix and stop thinking about it ;)
00:41:58 <dminuoso> merijn, did you ever hate the type signature of decodeUtf8With?
00:42:18 <dminuoso> You actually need IO in order to have strict decoding, its incredibly annoying.
00:42:45 <dminuoso> (Because it throws pure exceptions)
00:43:10 <cocreature> dminuoso: unsafePerformIO $ catch ‚Ä¶ :P
00:43:17 <dminuoso> cocreature: What could possibly go wrong!
00:43:28 <merijn> dminuoso: decodeUtf'
00:43:34 <merijn> eh, decodeUtf8'
00:43:49 <dminuoso> Yeah I guess so. :(
00:44:11 <cocreature> dminuoso: the quality of Haskell programs is measure in the number of unsafeCoerces, unsafePerformIO and magic hashes and of course more means better
00:44:38 <dminuoso> decodeUtf8' = unsafeDupablePerformIO . try . evaluate . decodeUtf8With strictDecode
00:44:40 <dminuoso> Heh!
00:45:01 <merijn> cocreature: This spells great things for my PhD codebase!
00:50:32 * hackage generics-mrsop 2.3.0 - Generic Programming with Mutually Recursive Sums of Products.  https://hackage.haskell.org/package/generics-mrsop-2.3.0 (vcmiraldo)
01:12:27 <pja> cocreature: You forgot ‚Äúnumber of ghc language extensions required to compile it‚Äù there.
01:14:00 <cocreature> pja: good point!
01:14:00 <dminuoso> cocreature: I just read some interesting remarks from Duncan why such a construct breaks the semantics of the language.
01:15:01 * hackage ghc-datasize 0.2.2 - Determine the size of data structures in GHC's memory  https://hackage.haskell.org/package/ghc-datasize-0.2.2 (DennisFelsing)
01:29:21 <maerwald> can you force 'allow-newer' in a nix build?
01:40:31 * hackage generics-mrsop-gdiff 0.0.2 - Reimplementation of the gdiff algorithm for generics-mrsop  https://hackage.haskell.org/package/generics-mrsop-gdiff-0.0.2 (vcmiraldo)
01:41:05 <dminuoso> Mmm, is there a way to convert from Data.ByteString.Lazy.Char8.ByteString to Data.ByteString.Lazy.ByteString directly?
01:41:59 <shachaf> I think id can do it?
01:42:56 <dminuoso> shachaf: Ohh! I didn't realize it was the same underlying type! So it's just the surrounding functions that differ?
01:52:10 <dmj`> the placebo effect
02:18:26 <merijn> Anyone using MonadLogger know if there's a convenient way to temporarily replace/alter the log function behaviour? Or do I have to just define my own MVar based one so I can replace it
02:38:50 <merijn> Somewhat relatedly, is there a way to check if two Handles refer to the same file?
02:58:02 <infinisil> merijn: co-log supports changing the logging function
02:58:57 <infinisil> With http://hackage.haskell.org/package/co-log-core-0.2.0.0/docs/Colog-Core-Class.html#t:HasLog
02:59:18 <infinisil> (which is used by http://hackage.haskell.org/package/co-log-0.3.0.0/docs/Colog-Monad.html#t:WithLog)
02:59:48 <infinisil> (which is used by http://hackage.haskell.org/package/co-log-0.3.0.0/docs/Colog-Message.html#v:log and such)
03:01:15 <phadej> merijn: https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.IO.Handle.Types.html#Handle to some approximation, you can use the definition of Handle
03:04:41 <sicklorkin> merijn: Are handles the same as FileDescriptors?
03:04:50 <sicklorkin> if it's the same process you should be able to
03:06:17 <sicklorkin> or you could seek to some random position(s) and see if the two handle return the same data? ucky
04:25:59 <trcc> If someone should be interested - I am looking for some feedback on my first semi-production application: https://mail.haskell.org/pipermail/haskell-cafe/2019-October/131586.html
04:44:46 <dminuoso> trcc: It's good style to check in the hpack generated cabal file, such that non-stack users can use your package seamlessly.
04:45:21 <trcc> dminuoso: is that the .cabal?
04:45:42 <dminuoso> trcc: Yes.
04:46:12 <trcc> dminuoso: Done. thanks!
04:54:01 <svipal> Why is the composition of applicative functors always applicative, but the composition of monads  not always a monad ? (from Data.Functor.Compose)
04:54:28 <dminuoso> svipal: The reason is quite simple:
04:54:51 <dminuoso> svipal: Imagine you have a composition of monads, `m (n (m (n a)))`
04:55:17 <dminuoso> svipal: You are now equipped with two joins, one that can do `m :.: m ~> m` and one that can do `n :.: n ~> n`
04:55:38 <dminuoso> svipal: In order to do that with your above computation you need to be able to sort of "commute/switch" the layer order
04:56:24 <dminuoso> So you'd need to have some way of doing `m (n (m (n a))) -> m (m (n (n a)))` after which you could then do `join` on the inner and `join` on the outer two layers.
04:56:51 <dminuoso> And this transformation does not exist for any two monads.
04:58:24 <svipal> I see. Though I understand the reasoning, I' m not familiar with that squiggly arrow notation 
04:58:39 <dminuoso> svipal: Thats just a shorthand notation for "natural transformation".
04:58:50 <dminuoso> `m ~> n` is the same as `forall a. m a -> n a`
04:58:50 <hpc> basically (n ~> m) is the same as (forall a. n a -> m a)
04:59:56 <svipal> Alright
05:00:00 <svipal> Thanks !
05:05:48 <dminuoso> svipal: This is a bit more precise :) https://gist.github.com/dminuoso/cf572b3ff5f4528a7fbf5253faaa6fe2
05:06:57 <dminuoso> svipal: And every two monads for which you can implement that function interchange indeed compose to a new monad.
05:07:41 <boxscape> seems kind of like `sequence`
05:08:09 <svipal> makes sense
05:08:21 <svipal> thanks for taking the time for this :)
05:08:24 <dminuoso> svipal: Actually I was a bit careless. Not just any choice for that function works, it needs to satisfy the monad laws still
05:08:35 <dminuoso> (And Im not sure that this is guaranteed by parametricity)
05:29:35 <sarna> hi, I've been browsing the code on the benchmarks game and.. does every high-performance Haskell program look like this? I mean using Foreign.C.Types, Foreign.Ptr, IO.Unsafe and others
05:31:11 <dminuoso> sarna: This happens a lot when you need to do FFI.
05:31:51 <sarna> dminuoso: what if I just want a high performance program? would I need to resort to these as well?
05:32:03 <dminuoso> sarna: It depends a lot on your problem domain, Id say.
05:33:00 <dminuoso> sarna: "high-performance" is a really broad description.
05:33:02 * hackage manifolds-core 0.5.0.4 - The basic classes for the manifolds hierarchy.  https://hackage.haskell.org/package/manifolds-core-0.5.0.4 (leftaroundabout)
05:33:30 <dminuoso> sarna: For example running physical simulations is a fairly different problem to running heavy web servers.
05:33:32 <sarna> dminuoso: well, not hard real-time, but low-latency web servers, for example
05:35:03 <sarna> dminuoso: or just crunching lots of data :)
05:35:24 <dminuoso> sarna: It depends heavily on the data and the type of computation, really.
05:36:15 <dminuoso> sarna: For example certain types of numerical computations are much much faster on the GPU which GHC doesn't directly target, but you can FFI into that.
05:36:45 <sarna> dminuoso: ah, no, I wouldn't go as far as  to reach for the GPU
05:37:45 <merijn> sarna: I think the answer is "It Depends"
05:37:47 <dminuoso> sarna: Do you have a particular problem domain in mind?
05:38:11 <sarna> merijn: yeah, the ultimate answer :D
05:38:19 <dminuoso> Well your question was rather broad...
05:38:33 <merijn> sarna: I mean, non-FFI Haskell is (with a little optimisation) still be *much* faster python/ruby/etc. and lots of people write web servers with high load in those
05:38:47 <boxscape> (even with GPU stuff though, there are libraries like accelerate that put a layer of abstraction over it so you don
05:38:49 <dminuoso> If we're just talking about web servers, then you can get very far without FFI or unsafe magic. :)
05:38:53 <boxscape> 't have to ffi yourself)
05:39:00 <sarna> dminuoso: as for now it's just command line apps that have to process a lot data fast, an example program would be ripgrep
05:39:02 <merijn> sarna: More realistcally, if you *really* want high performance code you generally care most about your innermost loop
05:39:03 <boxscape> s/to ffi/to use the ffi/
05:39:33 <merijn> sarna: And the fact that Haskell makes it easy to "call out" on your inner loop, means you can write the remaining 98% of your code in a nice high level language
05:39:37 <dminuoso> sarna: Okay! So with GHC Haskell you have full control at any level. You can write C-style imperative code, and Haskell is really superb there.
05:39:50 <dminuoso> sarna: So you can do all kinds of manual memory allocations, building your own memory things.
05:39:54 <merijn> sarna: Although, half the time it turns out that you actually don't even need to call out in your inner loop for many applications
05:40:12 <merijn> boxscape: tbh, none of those libraries are really remotely adequate
05:40:25 <boxscape> hm, I've only used them a little
05:40:27 <dminuoso> sarna: But you can make use of libraries like vector or containers, together with Unbox you can get quite good performance characteristics.
05:40:42 <dminuoso> sarna: There's also things like conduit that allows you to think heavily in terms of streaming.
05:40:53 <merijn> boxscape: Most high level GPU solutions lose a lost of the potential performance
05:41:00 <boxscape> okay
05:41:34 <sarna> dminuoso, merijn: thanks for explaining, that resolves most of my concerns :)
05:41:37 <Athas> sarna: my experience is that Haskell tends to be both fast and elegant for things that are innately slow (like, IO).
05:41:42 <merijn> sarna: I mean, you certainly CAN write code like that, but there's not as much focus so you might have to hand roll a bunch of low level stuff
05:41:59 <Athas> Ironically, Haskell is mostly slow for pure computation (number crunching), although it can be made fast by writing ugly low-level code.
05:42:39 <merijn> Athas: More importantly, Haskell is one of the few languages where you can conveniently write such "ugly low-level code" in a way that you can later wrap it up/hide it behind a nice abstraction
05:43:10 <Athas> Most of the time, Haskell is fast enough.  And most slow Haskell programs are not slow because of the language, but because of the humans writing in it.
05:43:25 <dminuoso> And once its not, you can trivially FFI into C/C++/Rust/whatever :)
05:43:44 <Athas> Sure, but that's the case for most languages.  Although I will grant that Haskell has a very elegant and lightweight FFI.
05:44:16 <boxscape> speaking of optimization - can something like `foo = print 4 >> foo` be tail-call optimized? I wouldn't have thought so, since foo isn't the outermost call, but it can go through billions of iterations without significantly increasing memory usage
05:44:21 <merijn> sarna: So I generally write very IO heavy Haskell, lots of FFI stuff, etc. and I fully agree with the "Haskell is my favourite imperative language" comment many people make a lot :)
05:44:30 <merijn> boxscape: Define tail call optimised
05:44:32 * hackage linearmap-category 0.4.0.0 - Native, complete, matrix-free linear algebra.  https://hackage.haskell.org/package/linearmap-category-0.4.0.0 (leftaroundabout)
05:44:38 <dminuoso> sarna: In our code, one of the primary things to make stuff go fast, is by using vector a lot and taking a little bit of control of memory layout (mostly to please the caches)
05:44:51 <merijn> Athas: It's really one of Haskell/GHC's most underrated features, imo
05:45:08 <merijn> People used to tell me "Python is great for high level glue code, because it's so easy to call C"
05:45:11 <sarna> merijn: that's an interesting statement, never heard that before :D
05:45:18 <dminuoso> Writing cache aware code is usually not so difficult - its a really juicy low hanging fruit for many algorithms.
05:45:25 <merijn> That's total BS, calling C from Python or vice versa is an utter PITA
05:45:32 <boxscape> merijn I guess what I'm thinking of is any optimization that would allow this to allow arbitrarily often without increasing memory usage unboundedly
05:45:35 <merijn> Meanwhile, calling C from Haskell is like magic fairy dust
05:45:43 <Athas> sarna: I think it's Bob Harper's claim, but he really didn't intend it as a compliment.  He strongly dislikes laziness.
05:45:52 <boxscape> uh, allow this to *run* arbitrarily often
05:46:11 <sarna> dminuoso: that's great! I thought writing cache-aware code would be a pain in Haskell
05:46:15 <merijn> boxscape: GHC Haskell doesn't have a function call stack, so that's only a problem if you end up repeatedly pattern matching, which your example doesn't
05:46:21 <merijn> boxscape: So your example should already work
05:46:22 <boxscape> Ah, I see
05:46:54 <dminuoso> sarna: Look into Data.Vector.Unboxed and Data.Vector.Storable 
05:47:19 <Athas> The 'vector' package is indeed very good.  I've used it for (relatively) high-performance data loading.
05:47:31 <merijn> <3 vector
05:47:31 <Athas> My favourite aspect is how you can use the fast unboxed mutable vectors in ST, not just IO.
05:47:56 <sarna> dminuoso: thanks, I'll check them out :)
05:48:18 <sarna> Athas: well, laziness is a tradeoff, isn't it
05:48:18 <dminuoso> Even the non-unboxed/storable are great, but they have somewhat poor locality of reference.
05:48:21 <merijn> sarna: Have you had a look at the details of the FFI yet? If you're comfortable with C/linking you should be right at home and love how easy it is
05:48:42 <Athas> I still think that vector-y code tends to not look as syntactically elegant as the equivalent code in C, but it's a small sacrifice.
05:48:48 <boxscape> merijn any idea what I should look into if I want to find out more about why ghc doesn't need a call stack?
05:49:07 <Athas> sarna: yes, but it makes the types lie (if you are pedantic).  An 'Int' in Haskell is not just the type of integers; it's the type of integers plus bottom.
05:49:09 <dminuoso> Athas: Thats probably because you are trying to be smart, using Haskelly things. You can write it to look identical to C code..
05:49:20 <sarna> merijn: not yet! I stopped learning Haskell some time ago (got stuck/discouraged/distracted around monoids), now thinking about getting back to it :)
05:49:22 <merijn> sarna: As long as you don't need to pass structs by value (as opposed to pointer) and don't have to mutate them from Haskell, then the FFI is super easy. If you do need to mutate structs it's slightly more painful, but not much
05:49:26 <merijn> @where stg
05:49:26 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
05:49:30 <merijn> boxscape: ^^ that paper
05:49:33 <boxscape> thanks!
05:49:57 <Athas> dminuoso: the equivalent of 'a[i++] = v' is much more syntactically heavy in vector.
05:50:28 <dminuoso> Athas: See I wouldn't write that in the first place because its a true mess because there's two magic things happening in a non-obvious way.
05:50:43 <sarna> Athas: doesn't bottom just mean it won't finish computing? like, everything can be bottom in any program, even if you don't formally say it could be bottom (halting problem)
05:50:50 <sarna> at least that's how I understand it
05:51:26 <Athas> sarna: yes, computation can be bottom, but values normally cannot.  I'm not saying I agree with Bob Harper here, but that's (one of) his major problems with Haskell.
05:51:29 <dminuoso> sarna: The problem is that the underlying representation needs to care for that.
05:51:41 <Athas> (I also dislike laziness, but for more pragmatic reasons of efficiency.)
05:51:44 <sarna> ohh, I see
05:51:46 <dminuoso> sarna: For example, if `error "foo"` is a valid value of Int, then how does that work representationally?
05:52:19 <sarna> Athas: and yet you write in Haskell, how curious :^)
05:52:25 <boxscape> % error "foo" :: Int#
05:52:25 <yahb> boxscape: ; <interactive>:45:1: error:; * Couldn't match a lifted type with an unlifted type; When matching types; () :: Type; Int# :: TYPE 'GHC.Exts.IntRep; * In the first argument of `print', namely `it'; In a stmt of an interactive GHCi command: print it
05:52:52 <Athas> sarna: sure!  Haskell is the best general-purpose language for several reasons, but I don't count laziness among them (although many others do).
05:53:02 <dminuoso> boxscape: Note that unboxed and unlifted are orthogonal.
05:53:21 <Athas> I would like Haskell epsilon more if it were strict, but it's not that big a deal.  I still prefer it to OCaml.
05:53:26 <dminuoso> boxscape: Int# is both unlifted and unboxed. There exists at least one type that is boxed but unlifted. :-)
05:53:53 <sarna> I've heard laziness eliminates the need for macros in most cases
05:54:06 <Athas> Only for control-flow macros.
05:54:29 <merijn> Athas: See, I don't want neither, I just want "strictness inference" so you could write "strictness polymorphic code"!
05:54:32 <sarna> oh, right
05:54:42 <Athas> And I don't think they are that common.  Honestly, for me, 'do'-notation is much more useful for replacing the macros I used to write in Common Lisp.
05:54:47 <boxscape> dminuoso which type are you referring to? It looks like Array# and such qualify
05:54:51 <dminuoso> boxscape: Right.
05:54:54 <boxscape> okay
05:55:15 <dminuoso> boxscape: Though Array# is a sort of weirdness. The reason its unboxed is because it needs to be on the heap I think?
05:55:21 <Athas> Most macros can be replaced with higher-order functions and explicit lambdas, but lambdas are syntactically ugly.  'do'-notation hides them.  It's wonderful!
05:55:22 <dminuoso> *the reason its boxed
05:55:23 <boxscape> hm, okay
05:56:04 <dminuoso> boxscape: But it should be obvious that unboxed lifted cannot work. Lifting requires boxing.
05:56:15 <dminuoso> (But boxing does not imply lifting)
05:56:16 <Athas> merijn: has anyone ever designed a strictness-polymorphic language?  I worry the complexity would exceed the utility.
05:56:53 <boxscape> dminuoso yeah I believe that makes sense to me
05:57:39 <merijn> Athas: It's on my todo list!
05:57:54 <merijn> Athas: Together with my pure checked exceptions!
05:58:07 <dminuoso> Athas: Honestly I found that most arguments against lazy-by-default to be uninteresting. They appear to be of theoretical nature at best.
05:58:15 <merijn> Athas: So, you know, at the current rate I'll get to it somewhere 2025 unless someone pays me :p
05:58:28 <dminuoso> If I go through our software projects, or just browse randomly through hackage project pages, lazyness is not the thing that regularly causes bugs or problems.
05:58:51 <Athas> dminuoso: really?  I'd expect the main arguments to be about efficiency and predictability, which are pretty pragmatic.
05:58:58 <Athas> No PL theoretician would care about space leaks!
05:59:21 <dminuoso> This is presuming space leaks happen *that* frequently.
05:59:29 <dminuoso> Which I dont really see.
05:59:42 <dminuoso> Id rather have composable-by-default and clean-algorithms-by-default
05:59:49 <merijn> Well, foldMap and sum are kinda shite due to their laziness
05:59:51 <boxscape> though actually my earlier yahb query is somewhat misleading
05:59:54 <boxscape> %  I# (undefined :: Int#)
05:59:54 <yahb> boxscape: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:48:5 in interactive:Ghci16
06:00:40 <boxscape> I remember asking here why that works but I forgot now -.-
06:00:43 <Athas> There are so few pure-but-strict languages around that it's hard to know what the relative impact of Haskell's laziness might be.
06:00:55 <dminuoso> Athas: Well you could compare PureScript to Haskell.
06:01:10 <dminuoso> They are fairly comparable
06:01:55 <Athas> Doesn't PureScript compile to Javascript?
06:02:04 <dminuoso> So?
06:02:20 <dminuoso> Also I think there's an llvm backend for purescript
06:02:24 <Athas> That makes it hard to compare directly with the quality of code generated by GHC.
06:02:29 <dminuoso> Or rather.. well C++.
06:02:55 <Athas> That might be useful for a comparison.  Is PureScript also an optimising compiler?
06:02:57 <sshine> I'm toying around with modelling electric resistors as monoids, and someone (who speaks Rust) suggested that if I make it a type class -- I imagine like 'class Resistor a where ohms :: Fractional r => a -> r' -- rather than a data type... err, if I need the 'Fractional r => a -> r', then I'm describing a GADT, right? Maybe it is more common to make up traits in Rust than type classes in Haskell? I have the
06:03:03 <sshine>  impression that you shouldn't.
06:03:41 <Athas> I think the interesting question is whether laziness overall helps or hinders compiler optimisations.  (This is why I wanted a pure language, because the MLs are heavily hampered by impurity.)
06:03:50 <EvanR> the default strategy to just reach for a class is usually wrong in haskell
06:04:07 <dminuoso> sshine: The usual motiviation for wanting typeclasses is overloading (usually in a lawful manner)
06:04:25 <Athas> sshine: that is not a GADT.
06:05:05 <tazjin> isovector1: http://liamoc.net/posts/2015-11-10-patch-theory.html
06:05:13 <Athas> I wonder what the average number of class definitions in non-library Haskell code is like.
06:05:17 <EvanR> i think you want something like newtype Parallel a = MkParallel a and then instance Num a => Monoid (Parallel a) where
06:05:29 <isovector1> tazjin: thanks bb
06:05:45 <EvanR>   mempty = infinity; mappend x y = 1 / ((1/x) + (1/y))
06:06:01 <Athas> I seem to define 62 classes in a 55k SLOC program.  That's one class for every 887 lines.
06:06:02 <EvanR> infinity is going to require more support than just Num though
06:06:12 <Athas> sshine: So that is your budget.  No type classes until you hit 800 lines of code!
06:06:13 <EvanR> the important part is this isn't a new class
06:06:25 <sshine> Athas, haha.
06:06:45 <tazjin> isovector1: https://jneem.github.io/merging/
06:06:50 <EvanR> Sum, Product are ways to change the notion of Monoid for Num types
06:06:52 <dminuoso> sshine: GADTs are basically just an extension to the idea that... an ADT is `class Expr a where MkBool :: Bool -> Expr a; MkInt :: Int -> Expr a; IsEq :: Expr a -> Expr a -> Bool` is unconstrained in what the data constructors return.
06:06:55 <merijn> I define a bunch of classes in my codebase, but those 90% are synonyms for (sets of) existing classes
06:07:09 <EvanR> Parallel is yet another thing like that. And Sum = Series
06:07:10 <Athas> merijn: why not use ContextKinds?
06:07:13 <dminuoso> sshine: A GADT allows you to say "MkBool :: Bool -> Expr Bool" instead - and that's the core idea of GADTs. :)
06:07:42 <sshine> Athas, 'newtype Resistor a = Resistor { ohms :: Rational }' was the data type I was aiming for. so stuffing the 'Fractional r => r' into it, I get 'data Resistor a where ohms :: Fractional r => a -> r', which is a GADT, right?
06:08:00 <dminuoso> sshine: No its not, that's not a valid definition of anything.
06:08:01 <Athas> sshine: right, that's a GADT, but you probably don't want that.
06:08:07 <maybefbi> anyone familiar with postgrest? or is there a more relevant active channel for it?
06:08:08 <Athas> Oh yeah, you need Ohms.
06:08:23 <merijn> Athas: You mean ConstraintKinds?
06:08:24 <Athas> Generally: put the typeclass constraints on your *functions*, not constructors.
06:08:29 <Athas> merijn: oh yeah, that.
06:08:36 <dminuoso> sshine: You could make it existentially quantified.
06:08:40 <sshine> Athas, I honestly don't have a use-case for the abstraction, except for wanting to generalize the fractional. but I would probably be fine with Rational.
06:08:50 <merijn> Athas: Because I need it to work as an mtl style class in several contexts
06:08:53 <EvanR> sshine: newtype Resistor a = Resistor { unResistor :: a }
06:09:07 <dminuoso> sshine: `newtype Resistor a = forall a. Fractional r => Resistor { ohms :: r }`
06:09:30 <EvanR> now you can use any numeric type that would make sense give your use sites
06:09:31 <dminuoso> (Or do this via GADTs - but the core idea is existential quantification)
06:09:41 <merijn> I have 3 classes in 8k lines of code, apparently
06:09:43 <dminuoso> Sorry I misspelled!
06:09:50 <dminuoso> % newtype Resistor = forall r. Fractional r => Resistor { ohms :: r }
06:09:50 <yahb> dminuoso: ; <interactive>:49:20: error:; * A newtype constructor cannot have a context in its type; Resistor :: forall r. Fractional r => r -> Resistor; * In the definition of data constructor `Resistor'; In the newtype declaration for `Resistor'
06:09:58 <dminuoso> % data Resistor = forall r. Fractional r => Resistor { ohms :: r }
06:09:58 <yahb> dminuoso: 
06:10:01 <dminuoso> There we go.
06:10:02 * hackage manifolds 0.5.0.4 - Coordinate-free hypersurfaces  https://hackage.haskell.org/package/manifolds-0.5.0.4 (leftaroundabout)
06:10:08 <EvanR> i really don't see the utility of the existential
06:10:32 <merijn> Athas: So you're 1 class per 800 is generous, 2.6k lines seems more like it
06:10:44 <merijn> admittedly, that's "wc -l" so includes whitespace and comments
06:10:54 <merijn> On the other hand, there's barely any comments, so...
06:11:02 <Athas> merijn: yeah, I think I have more type classes than is normal.
06:11:31 <maybefbi> its ok im going to ask #postgres
06:11:42 <Athas> That actually pisses me off a little bit.  I should see if I can shrink them.
06:12:08 <sshine> scrap your type classes.
06:12:26 <Athas> Now that would suck for my use case.
06:12:34 <EvanR> i think scrap your type classes was referring to actual cases where you'd normally want to use them
06:12:42 <Athas> What I really want is ML modules, but well.
06:12:52 <EvanR> rather than abused type classes where you shouldn't even have them
06:12:57 <dminuoso> EvanR: The use case is generalizing like sshine wanted to? 
06:12:58 <merijn> Athas: Backpack!
06:13:01 <sshine> EvanR, I didn't know the term existed. I assumed it meant "get rid of".
06:13:04 <merijn> Athas: Be my guinea pig ;)
06:13:06 <dminuoso> % :t (ohms q, q)
06:13:06 <yahb> dminuoso: Fractional a => (a, Resistor)
06:13:13 <EvanR> sshine: it's a blog post or something
06:13:13 <Athas> merijn: ugh.
06:13:16 <merijn> sshine: Tekmo wrote a blogpost called that, I think
06:13:43 <merijn> brb, switching machines
06:14:09 <isovector1> tazjin: thanks fam
06:14:33 <dminuoso> EvanR: Oh, perhaps it should rather be polymorphic inside heh
06:14:34 <tazjin> isovector1 ur welcom bb :*
06:14:38 <sshine> merijn, is Tekmo = Gabriel Gonzalez? I read that once.
06:14:50 <comerijn> sshine: Yeah
06:15:09 <sshine> this is confusing. what happens when you compose, merijn/comerijn?
06:15:44 <EvanR> 1/co
06:15:45 <merijn> Nothing, which is why my thesis isn't finished yet ;)
06:17:32 <EvanR> .oO what do you get when you compose sine and cosine
06:17:52 <merijn> But hey, at least I managed to figure out how to do: terminal paging, haskeline autocomplete, and a ton of other useful things rather than finish my thesis :p
06:18:33 <boxscape> Can someone remind me why `I# (undefined :: Int#)` compiles? It seems like the unliftedness of Int# oughtn't allow this
06:18:46 <merijn> boxscape: undefined is levity polymorphic
06:18:55 <merijn> I think we had this discussion earlier this week?
06:19:07 <merijn> (for some value of "we" referring to people in #haskell)
06:19:12 <EvanR> :t I# undefined
06:19:13 <lambdabot> error:
06:19:13 <lambdabot>     ‚Ä¢ Data constructor not in scope: I# :: t0 -> t
06:19:13 <lambdabot>     ‚Ä¢ Perhaps you meant ‚ÄòIn‚Äô (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
06:19:32 <EvanR> % I# undefined
06:19:32 <yahb> EvanR: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:62:4 in interactive:Ghci23
06:19:34 <Athas> merijn: is autocompletion in haskeline good?
06:19:34 <boxscape> merijn right but what does it mean that only lifted values can contain bottom if this works?
06:19:35 <EvanR> % :t I# undefined
06:19:36 <yahb> EvanR: Int
06:19:46 <Athas> I've considered adding it to the futhark REPL.
06:19:55 <Athas> (Which uses haskeline.)
06:20:01 <merijn> Athas: I mean, that depends on your implementation :p
06:20:08 <merijn> Athas: But it's fairly easy to do, yeah
06:20:54 <EvanR> % (\x -> x + I# 1#) 2
06:20:54 <yahb> EvanR: 3
06:20:58 <EvanR> % (\x -> x + I# undefined) 2
06:20:58 <yahb> EvanR: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:65:15 in interactive:Ghci24
06:21:13 <merijn> Athas: I register all experimental setups/etc. in a single SQLite database and it now actually does query backed autocompletion (so, if you're filling in a "algorithm" field it will query the database for registered algorithms and complete using those
06:22:02 <boxscape> chromium
06:22:02 <dminuoso> merijn: Why would that compile though?
06:22:05 <boxscape> oops
06:22:10 <boxscape> that was meant for my terminal
06:22:11 <merijn> dminuoso: hmm?
06:22:20 <EvanR> how does it even throw the exception :)
06:22:59 <EvanR> surely all 64 bits can be used for the unboxed int
06:23:03 <dminuoso> merijn: Are you saying that: `undefined :: forall r a. (a :: TYPE r)` ?
06:23:15 <boxscape> that's pretty much what haddock says dminuoso
06:23:24 <dminuoso> Oh heh!
06:23:28 <dminuoso> I guess it is. :)
06:23:33 <merijn> dminuoso: I dunno man, I said you couldn't use undefined as Int# this week and then someone proved me wrong
06:23:39 <merijn> I'm just repeating the conversation
06:23:58 <boxscape> I think that was me, but I don't remember the ultimate outcome of that discussion :/
06:24:04 <boxscape> I'm trying to find it in the logs
06:24:08 <merijn> Athas: I actually have a bit more complicated setup so I can dynamically switch the completion method on context
06:24:12 <EvanR> maybe the I# box contains a bit for "herein lies an unboxed undefined"
06:24:35 <Athas> merijn: wasn't your thesis about graph algorithms on GPUs?
06:24:40 <EvanR> but that seems off
06:24:45 <boxscape> EvanR but you don't even need the I#, `undefined :: Int#` is valid on its own, just hard to use in ghci
06:24:59 <merijn> Athas: Yeah
06:25:12 <EvanR> boxscape: this proves i don't understand unboxing
06:25:17 <Athas> Your apartment must be full of yak hair.
06:25:33 <merijn> Athas: Although, at this point it's probably more "how do you properly design and implement a system for systematic benchmarking"
06:26:01 * hackage hledger-flow 0.12.4.0 - An hledger workflow focusing on automated statement import and classification.  https://hackage.haskell.org/package/hledger-flow-0.12.4.0 (apauley)
06:26:04 <[exa]> Is there any nice way for rounding numbers to fixed number of decimal digits, without pulling in much libraries?
06:26:06 <merijn> Athas: tbh, my PhD would've been way more constructive and useful if I'd done this stuff immediately instead of "no! I will focus on doing science and getting results!"
06:26:07 <boxscape> % const () (undefined (undefined :: Int#))
06:26:07 <yahb> boxscape: ()
06:26:30 <merijn> [exa]: Do you need to convert existing numbers to that or are you fine with just always using fixed point?
06:26:33 <[exa]> ie. replacement for stuff like '(/ 100) .  fromInteger .  round .  (* 100)'  (which rounds to 2 digits)
06:26:56 <merijn> > 0.479879724 :: Deci
06:26:57 <lambdabot>  0.4
06:27:01 <merijn> > 0.479879724 :: Centi
06:27:03 <lambdabot>  0.47
06:27:06 <merijn> > 0.479879724 :: Milli
06:27:08 <lambdabot>  0.479
06:27:19 <[exa]> ok cool
06:27:21 <[exa]> thanks!
06:27:29 <merijn> [exa]: Check Data.Fixed in base for more
06:27:47 <merijn> [exa]: Can even pretty trivially define your own custom precision if you want
06:27:51 <EvanR> > 0.479879724 :: Myria
06:27:53 <lambdabot>  error:
06:27:53 <lambdabot>      Not in scope: type constructor or class ‚ÄòMyria‚Äô
06:28:02 <[exa]> yeah, it looks precisely like what I wanted
06:28:04 <[exa]> thanks a lot :D
06:29:56 <[exa]> oh, any alternative that can round the numbers up as well?
06:31:08 <merijn> Not sure
06:31:18 <EvanR> > (-0.479879724) :: Centi
06:31:20 <lambdabot>  -0.47
06:32:38 <boxscape> % let x = undefined :: (Int#) in ()
06:32:39 <yahb> boxscape: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:70:9 in interactive:Ghci26
06:33:02 <boxscape> found it, the conclusion from the last conversation was that unlifted types are implicitly strict
06:33:11 <[exa]> EvanR: okay cool. :]
06:33:59 <EvanR> boxscape: so the compiler will insert a crash right before a usage of unboxed undefined
06:34:22 <boxscape> right
06:34:35 <boxscape> well, even before "right before"
06:34:43 <boxscape> it's never used in that example
06:34:57 <EvanR> it's inserted "before" the () heh
06:35:06 <EvanR> crash `seq` ()
06:35:33 <boxscape> I think it's similar to
06:35:38 <EvanR> which seems odd because x has no !
06:35:39 <boxscape> % let !x = undefined :: (Int) in ()
06:35:39 <yahb> boxscape: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:71:10 in interactive:Ghci26
06:35:47 <boxscape> right EvanR
06:36:26 <boxscape> % let f | x <- (undefined :: Int#) = () in f
06:36:26 <yahb> boxscape: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:72:15 in interactive:Ghci26
06:36:32 <boxscape> % let f | !x <- (undefined :: Int) = () in f
06:36:32 <yahb> boxscape: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:73:16 in interactive:Ghci26
06:36:43 <boxscape> uhm
06:36:44 <novum> hello, lovely and smart haskellers. I have been (slowly unfortunately) working on monads. I have this http://ix.io/1YCR see first explicit function, getFname. It is weird. I was trying to figure out how I can use `fname` function (implicitly defined in `Person`) on a **`Maybe Person`**
06:37:30 <boxscape> % let f | !_ <- undefined = () in f -- only doesn't crash without type annotation :)
06:37:30 <yahb> boxscape: ()
06:38:03 <EvanR> whatta...
06:38:13 <boxscape> (I opened an issue about this yesterday)
06:38:32 <EvanR> % case undefined of !_ -> ()
06:38:32 <yahb> EvanR: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:79:1 in interactive:Ghci28
06:38:49 <boxscape> EvanR https://gitlab.haskell.org/ghc/ghc/issues/17343
06:39:34 <EvanR> i'm curious how the implementation even allows that
06:39:54 <EvanR> considering the sugar plums and gums drops world pattern guards are translated into more primitive terms
06:40:03 <EvanR> in the ideal world
06:40:28 <ski> novum : `getFname mp = fmap fname mp'
06:40:41 <EvanR> % let f | !x <- undefined = () in f
06:40:41 <yahb> EvanR: ()
06:40:52 <boxscape> EvanR I don't know if this is the desugaring that's actually used for that, but in the talk SPJ gave at haskellX he explained how for exhaustiveness checking, *everything* is translated *into* pattern guards
06:40:59 <ski> @src Maybe fmap
06:40:59 <lambdabot> fmap _ Nothing  = Nothing
06:40:59 <lambdabot> fmap f (Just a) = Just (f a)
06:41:08 <EvanR> % let f | !x <- undefined = (1,x) in f
06:41:09 <yahb> EvanR: (1,*** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; x, called at <interactive>:81:30 in interactive:Ghci29
06:41:10 <boxscape> but there might be different desugarings for different purposes
06:41:13 <novum> gwah WhAt ski ski üéø
06:41:23 <dminuoso> boxscape: No.
06:41:28 <dminuoso> boxscape: You understood that wrongly.
06:41:31 <boxscape> okay
06:41:40 <dminuoso> boxscape: The translation into pattern guards is *merely* for the purpose of exhaustiveness checking.
06:41:47 <dminuoso> boxscape: Simon even said that.
06:41:52 <novum> don't tell me a Monad is a Functor
06:41:53 <dminuoso> boxscape: Its not the actual runtime code.
06:42:04 <EvanR> novum: a Monad is a Functor oops
06:42:14 <boxscape> dminuoso okay, I missed that - I did say just say that that's a possibility though :)
06:42:31 * novum has parted (I quit haskell. Good luck.)
06:42:33 <EvanR> so bang in pattern guards "sometimes works depending"
06:43:06 <ski> novum : could also use bind, `getFname mp = bindMaybe mp (\p -> Just (fname p))', assuming `bindMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b'
06:43:10 <EvanR> maybe there is a reason in terms of desugaring
06:44:45 <boxscape> % let f | !_ <- let x = x in x = () in f -- using a different bottom makes it, well, bottom
06:44:51 <yahb> boxscape: [Timed out]
06:45:19 <EvanR> whattt
06:45:21 <novum> ski, how many seconds does it take to go from haskell noob to haskell pro. I have invested 362880 seconds roughly (if it is assumed that I worked about 30% of each day for 2 weeks on haskell)
06:45:33 <merijn> novum: Define "pro"
06:45:53 <dminuoso> novum: Is that 362880 seconds including sleep?
06:45:56 <Athas> You can become a professional in the time it takes to sign an employment contract.
06:46:03 <Athas> It takes ten years to become a good programmer.
06:46:09 <EvanR> boxscape: "depending" just got a lot my inexplicable
06:46:13 <EvanR> more*
06:46:35 <EvanR> what other kinds of bottom are there
06:47:04 <boxscape> pattern match failure?
06:47:29 <novum> I have never done functional programming nor category theory nor monads. So, it has entailed a few headaches, but I have worked hard. I was purely joking ^u^ I know it won't be instantaneous
06:47:41 <EvanR> % let f | !False <- True  in f
06:47:42 <yahb> EvanR: ; <interactive>:3:25: error: parse error on input `in'
06:47:42 <ski> > mapAccumR divMod 362880 [7,24,60,60]
06:47:43 <lambdabot>  (0,[4,4,48,0])
06:48:05 <boxscape> % let f | !False <- True = ()  in f
06:48:05 <yahb> boxscape: *** Exception: <interactive>:4:5-27: Non-exhaustive patterns in function f
06:48:06 <merijn> novum: category theory is (almost) entirely irrelevant to beginners (or even advanced Haskell programmers...)
06:48:55 <ski> novum : have you defined `bindMaybe' (possibly under another name) ?
06:48:56 <novum> but a monad is a monoid in the category of endofunctors or something. so, it's really quite simple .. so long as you know category theory.
06:48:59 <boxscape> EvanR though you don't even need a BangPattern for that one
06:49:10 <EvanR> % let f | !_ <- (case False of True -> ()) = ()  in f
06:49:10 <yahb> EvanR: *** Exception: <interactive>:6:16-39: Non-exhaustive patterns in case
06:49:12 <novum> ski, I didn't make any Monads yet. Just using Maybe monad
06:49:19 <kuribas> merijn: It's interesting, but has very little practical use for most code.
06:49:19 <EvanR> % let f | _ <- (case False of True -> ()) = ()  in f
06:49:20 <yahb> EvanR: ()
06:49:28 <boxscape> interesting
06:49:30 <merijn> novum: I'd say a few weeks to a month before you can write simple "real" programs.
06:49:54 <EvanR> at this point pattern guards seems like a hemonculus with inscrutible motives
06:49:56 <merijn> kuribas: Don't get me wrong, I fully support learning CT for learning's sake. I just discourage learning it for "learning Haskell"'s sake :p
06:50:11 <kuribas> merijn: yeah, that's my stance on it too
06:50:25 <novum> merijn, I may have to start sooner. I have being doing exercism.io and codewars. I don't know how "real" those are. Maybe you remember me. I am the kid who will be creating a package manager in haskell with a groupmate who is a little more haskell literate than he
06:50:31 <EvanR> this is not the haskell i signed up for
06:50:36 <ski> novum : that's why i asked about `bindMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b', not `(>>=)'
06:50:38 <kuribas> it's very useful to see the patterns in programming, and math
06:50:57 <novum> ski, I have defined no such thing
06:51:24 <ski> novum : it could help cut down on the boiler-plate in that paste
06:51:44 <ski> (the rightward drift of the nested `case's, with the repeated `Nothing -> Nothing's)
06:52:18 <kuribas> what's your stance on with, "it doesn't matter which language you use, as long as the design and algorithms are right"?
06:52:34 <novum> I believe it. I am not worried about boilerplate right now. Make it as verbose as it can be. I am learning about Maybe monad. Then I will make my own Monad. Then I will learn about Functors. Then I will do some practice.
06:52:54 <kuribas> my stance is "sort of", but still doing it in haskell saves some time.
06:52:56 <EvanR> um Functors should be first
06:53:08 * novum pouts fine
06:53:14 <boxscape> EvanR IIRC undefined is defined in terms of `error`
06:53:15 <boxscape> % let f | !_ <- error "test" = ()  in f
06:53:16 <yahb> boxscape: *** Exception: test; CallStack (from HasCallStack):; error, called at <interactive>:15:15 in interactive:Ghci7
06:53:23 <novum> but let me finish that which I started or I will turn into the hulk
06:53:25 <kuribas> novum: try monoid, it's the simplest one.
06:53:34 <novum> I know what a monoid is
06:53:34 * ski thinks "(m|p)aternal grand(mo|fa)ther" is such a clunky term, prefers "(mo|fa)ther(mo|fa)ther"
06:53:39 <EvanR> boxscape: if so that just broke referential transparency
06:53:46 <boxscape> yup
06:54:02 <ski> novum : what i was talking about was directly about "learning about Maybe monad"
06:54:32 <novum> yes. I saw. thanks for the tips. I want to do it the "hard way" so that I appreciate the "easy way"
06:54:36 * EvanR cries over the shards of referential transparency on the floor
06:54:41 <novum> and so that I more fully understand .. ?
06:54:44 <ski> novum : that's good
06:54:50 <Ariakenom_> EvanR: bottom is bottom is bottom
06:55:00 <boxscape> Ariakenom_ but bottom is not ()
06:55:00 <EvanR> until it's not
06:55:16 <EvanR> % let f | !_ <- undefined = ()  in f
06:55:16 <yahb> EvanR: ()
06:55:39 <EvanR> % let f | !_ <- error "!" = ()  in f
06:55:39 <yahb> EvanR: *** Exception: !; CallStack (from HasCallStack):; error, called at <interactive>:17:15 in interactive:Ghci8
06:55:41 <novum> the boring class has done the terminating. Is is the time for the me to do the leaving. Love you all thanks for help and understanding. Best channel on freenode
06:55:57 <Ariakenom_> oh I misread
06:56:12 <ski> yw, novum
06:56:52 <merijn> !!
06:57:29 <merijn> International Obfuscated C Code Contest winners are finally released, so we can finally see how some masochist implemented a Haskell compiler in 4KB of C...
06:57:55 <Rembane> \o/
06:58:29 <merijn> https://ioccc.org/2019/lynn/hint.html
06:59:24 <boxscape> source code appears to be this? https://www.ioccc.org/2019/lynn/prog.c
07:00:31 <merijn> boxscape: That looks about right :p
07:01:22 <EvanR> i'm having trouble finding the definition of undefined
07:01:48 <boxscape> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Err.html#undefined
07:01:52 <boxscape> EvanR ^
07:02:41 <boxscape> (hoogle for undefined -> click on first link -> click on source)
07:03:01 * hackage manifold-random 0.5.0.4 - Sampling random points on general manifolds.  https://hackage.haskell.org/package/manifold-random-0.5.0.4 (leftaroundabout)
07:03:02 * ski . o O ( "Bool must be defined as: `data Bool = True | False;' so that it matches the Scott-encoded booleans internally used by the primitive function (<=)." :/ )
07:04:26 <EvanR> so ghc runs on Booleans. The secret would ruin us
07:04:52 <boxscape> > To interoperate with GHC, our compiler treats any undefined functions as the identity function
07:04:53 <lambdabot>  <hint>:1:25: error: parse error on input ‚Äò,‚Äô
07:08:37 <EvanR> is yahb on that version of GHC
07:09:09 <geekosaur> % :show version
07:09:09 <yahb> geekosaur: syntax: :show [args | prog | editor | stop | imports | modules | bindings | linker | breaks | context | packages | paths | language | targets]
07:09:13 <EvanR> seems like a series bug
07:09:17 <geekosaur> mm, right
07:09:24 <EvanR> serious
07:09:43 <boxscape> % :!ghc --version
07:09:43 <yahb> boxscape: The Glorious Glasgow Haskell Compilation System, version 8.6.0.20180620
07:10:11 <EvanR> wait.. you can run shell commands :)
07:10:33 <boxscape> yeah you don't even need to go via :!, it has bash built in. But I don't remember the syntax
07:10:36 <boxscape> it also hsa Lua built in
07:11:03 <EvanR> % :!cat urmom
07:11:03 <yahb> EvanR: 
07:11:32 <EvanR> % :!cat foo
07:11:32 <yahb> EvanR: cat: foo: Is a directory
07:11:38 <EvanR> lol
07:11:55 <EvanR> let the abuse begin
07:12:56 <tabaqui1> why Word8 and Int8 are not synonims?
07:13:16 <geekosaur> because Int8 is signed but Word8 unsigned
07:13:28 <geekosaur> (-1 :: Word8)
07:13:31 <tabaqui1> oh, then it is a issue in thrift
07:13:37 <geekosaur> > (-1 :: Word8)
07:13:40 <lambdabot>  255
07:13:42 <tabaqui1> I thought that Int8 has the same bounds
07:13:45 <tabaqui1> thanks
07:14:01 <Taneb> > 128 :: Int8
07:14:03 <lambdabot>  -128
07:14:42 <Athas> > round (1/0)
07:14:44 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
07:14:51 <EvanR> > ((-128) `div` (-1)) :: Int8
07:14:53 <lambdabot>  *Exception: arithmetic overflow
07:15:20 <Athas> I will go to my grave wondering why 'round' does not raise an exception on NaNs and infinities.
07:15:23 <Athas> > round (0/0)
07:15:26 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
07:15:37 <boxscape> > floor (1/0) == ceiling (1/0)
07:15:39 <EvanR> for speed!
07:15:39 <lambdabot>  True
07:15:48 <EvanR> move fast break things
07:16:13 <Rembane> It seems after all that Haskell is web scale
07:16:20 <EvanR> > round (0/0) :: Int
07:16:22 <lambdabot>  0
07:16:27 <EvanR> > round (1/0) :: Int
07:16:29 <lambdabot>  0
07:16:30 <Taneb> :'(
07:17:35 <geekosaur> there was a -cafe post about round and company
07:18:12 <geekosaur> there's an underlying function that does the heavy lifting and which ignores Inf and NaN, digging into the internal representation instead of doing it the "correct" way
07:19:00 <dminuoso> If I want to compare values of two records that share a large subset of fields (semantically), what's the safest way of comparing them?
07:19:12 <dminuoso> Here safe means with low risk of introducing bugs if I add fields.
07:19:19 <dminuoso> Through an intermediate data type?
07:20:16 <Athas> My otherwise-pure compiler/interpeter, written in Haskell, uses the FFI solely to access C's sane rounding functions, because the one in Haskell is so defective.
07:20:20 <geekosaur> don't things like vinyl handle this somehow?
07:20:24 <Athas> This is the opposite of how it should be!
07:20:43 <merijn> Athas: How is it defective?
07:20:52 <merijn> Athas: Lack of error reporting on NaN/Infinity?
07:20:57 <geekosaur> I think the Haskell take is Float and Double are defective :)
07:20:59 <dminuoso> geekosaur: Mmm oh perhaps it does. It feels a bit heavy to depend on vinyl just for this though.
07:21:23 <merijn> geekosaur: Not if/when we finally switch to trapping NaN!
07:21:42 <geekosaur> I think this problem is the source of the heaviness, though; it's doing a lot of "HasField
07:21:48 <geekosaur> " management for you, IIRC
07:22:07 <geekosaur> which is pretty much the only way to do this, via whatever means
07:22:22 <Athas> merijn: the big problem is that rounding and type conversion is merged into a single operation.
07:22:26 <EvanR> C's "sans" rounding is identity on +-infinity and NaN
07:22:30 <merijn> Athas: Agreed
07:22:33 <EvanR> which we can't do but actually i wish we could
07:22:41 <EvanR> a floor that returns a float back would be nice
07:22:51 <Athas> I also vaguely remember that 'round' had the usual defects in edge cases, but I may be confusing that with other languages.
07:23:04 <merijn> Athas: Which usual defects?
07:23:08 <boxscape> floor :: Float -> Either Float Integer
07:23:15 <EvanR> eww
07:23:24 <merijn> I mean, it uses banker's rounding, yeah, but that's the IEEE-754 specified default
07:23:26 <Athas> merijn: things like rounding incorrectly when you are epsilon away from midpoints.
07:23:37 <EvanR> drake rejects that. drake likes floor :: Float -> Float
07:23:52 <Athas> But as I said, I might misremember and GHC might actually get this one right.
07:24:10 <merijn> Athas: Are you sure that you aren't confusing "correctly per IEEE-754" with "how school teaches it"? ;)
07:24:18 <Athas> merijn: yes, absolutely.
07:24:19 <boxscape> floor :: foreach (x :: Double) -> FloorType x
07:24:35 <EvanR> nice
07:24:59 <boxscape> now we just need to wait two or three years until that's actually valid
07:25:14 <Athas> > round (-0.4999999701976776123046875 :: Float)
07:25:16 <lambdabot>  0
07:25:19 <EvanR> dependent types are always 40 years away
07:25:40 <merijn> Athas: Numeric conversion in general isn't nice in Haskell :/
07:25:43 <Athas> > round (-0.500000059604644775390625 :: Float)
07:25:45 <lambdabot>  -1
07:25:58 <boxscape> Richard said he's hoping for I think something like first half of 2021 at haskellX in his talk
07:26:03 <Athas> > round (2.2517998136852485 :: Float)
07:26:05 <lambdabot>  2
07:26:18 <Athas> > round (2.2517998136852485e15 :: Float)
07:26:20 <lambdabot>  2251799813685248
07:27:39 <Athas> Looks like GHC might actually get the rounding right (except for NaNs and infinities).  Maybe there's a point to converting floats to rationals first!
07:28:47 <merijn> > 2.251799813685248e15 :: Int --is NumDecimals on?
07:28:48 <lambdabot>  error:
07:28:49 <lambdabot>      ‚Ä¢ No instance for (Fractional Int)
07:28:49 <lambdabot>          arising from the literal ‚Äò2.251799813685248e15‚Äô
07:28:56 <Athas> Wait, no, something is really fishy in 'round'.  I cannot possibly believe it is correct, although I can't really synthesise a counterexample.
07:28:56 <merijn> % :set -XNumDecimals
07:28:57 <yahb> merijn: 
07:29:07 <merijn> % 2.251799813685248e15 :: Int --is NumDecimals on?
07:29:07 <yahb> merijn: 2251799813685248
07:29:24 <merijn> Athas: What's fishy?
07:29:38 <merijn> (Incidentally, <3 NumDecimals)
07:31:13 <boxscape> % 0_____0
07:31:13 <yahb> boxscape: 0
07:31:35 <Athas> merijn: it converts a float to a fraction (n,r), then does control flow based on 'r - 0.5'.
07:31:45 <Athas> Specially, the sign of 'r - 0.5'.
07:31:59 <Athas> Seems like some shenanigans should be possible there.
07:32:36 <EvanR> try writing a failing test
07:32:43 <Athas> But I may be wrong!  I'm not really very good at numerical analysis; I just spent some time reading up on the pitfalls when implementing Futhark.
07:34:12 <boxscape> just do an exhaustive check of all Floats, 2^32 isn't so bad
07:35:02 <boxscape> as long as you have a correct round function to compare it to, that is
07:35:16 * EvanR checks Data.Half
07:35:37 <EvanR> Numeric.Half
07:36:50 <EvanR> defined in terms of Float round
07:37:35 <Athas> On a CPU, half-precision is just a storage format anyway.  No chip I know of has instructions for those things.
07:38:12 <EvanR> an ASIC could
07:38:16 <EvanR> er FPGA
07:55:13 <dminuoso> geekosaur: Mmm, I think Im going with the intermediate data types such that Ill have to do `eqS r l = levelR r == levelL l` - it gives me less headaches than vinyl.
07:56:01 <dminuoso> It's a bit annoying to have to write a couple conversion functions, but I think its saner than this pile of magicness plus whatever vinyl costs in terms of compilation time
07:56:04 <geekosaur> it'd make me want to script the necessary boilerplate somehow, either TH or a shell/perl script to generate it for me :)
07:57:20 <geekosaur> (or even haskell + haskell-src-exts + runghc)
07:57:35 <dminuoso> Oh you mean like pseudo-TH? :-)
07:58:11 <geekosaur> something like that, yes
07:58:15 <oats> could someone help me understand what's going on with the type signature of `f` here? https://www.reddit.com/r/haskell/comments/dho9ij/how_would_i_solve_this_problem_in_haskell/f3pl3hn/
07:58:17 * geekosaur misses the zeroth package
07:58:20 <oats> is it using the function monad?
07:58:25 <geekosaur> it's still there but long since bitrotted
07:59:02 <dminuoso> oats: What is the underlying problem?
07:59:16 <geekosaur> oats, yes. clever and a bit evil since it's non-obvious. I prefer to let the compiler write the incomprehensible code :)
07:59:31 <oats> @type join (liftA2 (+))
07:59:32 <lambdabot> (Applicative f, Num c) => f c -> f c
07:59:46 <oats> @type join
07:59:47 <lambdabot> Monad m => m (m a) -> m a
07:59:57 <oats> @type liftA2 (+)
07:59:58 <lambdabot> (Applicative f, Num c) => f c -> f c -> f c
07:59:59 <ski> s/function monad/environment monad/
08:00:03 <oats> yeah, that's black magic
08:00:04 <dminuoso> oats: join on the reader monad basically "doubly applies" :)
08:00:15 <dminuoso> % :t join (,)
08:00:15 <yahb> dminuoso: b -> (b, b)
08:00:19 <oats> I don't understand, what does the reader monad have to do with this?
08:00:28 <dminuoso> oats: This is the reader monad instance. 
08:00:34 <geekosaur> the function monad is a primitive version of Reader
08:00:48 <ski> it's `Monad (rho ->)'
08:00:56 <geekosaur> or put otherwise, Reader is a newtype wrapper around function application
08:01:03 <dminuoso> Or well yes. I just call the `instance Monad ((->) e)` Reader.
08:01:22 <ski> ("application" ?)
08:01:39 <geekosaur> I call it the primitive reader monad, since that's a bit less confusing than calling it Reader when that exists already
08:02:00 * ski calls it "environment"
08:02:01 <oats> I guess I don't really understand the Reader monad then lol
08:02:25 <ski> oats : do you know how `(>>=)' is defined for it ?
08:02:32 <ski> oats : do you know how `join' is defined ?
08:02:38 <dminuoso> oats:  join f = f >>= id = \r -> id (f r) r = \r -> f r r
08:02:51 <ski> spoilsport
08:03:13 <geekosaur> it transparently passes some parameter, often called the environment, to some function (primitive reader) or wrapped function (Reader's ReaderT)
08:03:41 * ski would say, "distributes"
08:04:20 <oats> dminuoso: huh, it's a double application
08:04:23 <Rembane> As in the math-term distributes or as in the logistical term? 
08:04:57 <geekosaur> @unmtl Reader r a
08:04:57 <lambdabot> r -> a
08:04:58 <ski> either ?
08:05:21 <boxscape> % :t (>>=) @((->) _) -- is there something I can fill in here to get a non-partial signature without changing the meaning?
08:05:22 <yahb> boxscape: (w -> a) -> (a -> w -> b) -> w -> b
08:06:36 <ski> think of it as distributing a value (the "environment") down all branches of a tree
08:06:53 <ski> (also cf. environment variables, and forking processes)
08:27:12 <arianvp> how do I know why I package is not in stackage anymore?
08:27:38 <arianvp> http-client-openssl seems to have disappeared, but I cant find a commit referring to it anywhere. is there a way to search stackage to figure out exactly in what snapshot it was removed?
08:32:18 <Athas> arianvp: I don't think you can search for it directly, but I usually look for it in build-constraints.yaml in the main stackage repository.
08:32:35 <sm[m]> arianvp: clone the repo, use git blame or git log ‚Äîgrep?
08:33:25 <sm[m]> Or adjust the snapshot version in the url of the package‚Äôs stackage page until you find it
08:33:29 <Athas> I do admit I find build-constraints.yaml a bit mysterious.  It does not seem to list all packages and it has no version numbers.
08:33:50 <sm[m]> Or search for package name in the issue tracker
08:34:59 <Athas> https://www.stackage.org/package/http-client-openssl/snapshots
08:35:08 <Athas> Doesn't say why it was removed, though.
08:35:41 <Athas> Rather mysterious!  That package is still actively maintained by Michael Snoyman.  It makes no sense that it would fall out of Stackage.
08:40:31 <cocreature> Even stack managed to fall out of stackage at some point
08:41:06 <merijn> cocreature: :D
08:41:35 <Athas> There is a set of things I like about Stack.  The way the snapshots are generated is not one of them.
08:46:43 <arianvp> so i am not crazy? 
08:47:10 <arianvp> In nixos commits that remove packages at least mention the name of the package in question, which makes removals trackable
08:47:40 <arianvp> but so it got dropped after 12.26 for some reason??
08:48:31 <Athas> My impression is that packages end up in snapshots because they are explicitly listed in build-constraints.yaml, or because a package that depends on them is.  My guess is that http-client-openssl was only there because something else needed it, and then that something was removed.
08:48:46 <sm[m]> it‚Äôs probably just the usual fallout from a major ghc upgrade. Things are being updated for 8.8
08:49:04 <sm[m]> Git history would tell you
08:52:20 <arianvp> Ok but how do I figure out in what commit this was removed?
08:52:25 <arianvp> git log --grep didnt find any culprits
08:55:32 <sm[m]> Sorry I‚Äôm on phone & out of ideas
08:56:57 <sm[m]> (I assume git log has some super special search flag)
08:57:46 <lyxia> arianvp: git log -S searches diffs instead of commit messages (which are often uninformative for this repo)
08:59:34 <arianvp> Even that isn't very informative
09:00:00 <arianvp> it occurs many times in many diffs either as deletion or insertion
09:00:07 <arianvp> hard to figure out which one actually caused the change
09:00:09 <arianvp> :/
09:07:52 <sm[m]> Or, search the url space like I said ? It shouldn‚Äôt be so hard
09:08:25 <sm[m]> and what about the issue tracker ?
09:12:59 <dignissimus> When getting input, is it possible to exit the programme when the user presses the escape key?
09:13:26 <chisui_> :k ("sym", Int)
09:13:27 <lambdabot> error:
09:13:27 <lambdabot>     ‚Ä¢ Expected a type, but ‚Äò"sym"‚Äô has kind ‚ÄòGHC.Types.Symbol‚Äô
09:13:28 <lambdabot>     ‚Ä¢ In the type ‚Äò("sym", Int)‚Äô
09:13:58 <chisui_> Does anyone know why this ^ doesn't work?
09:14:58 <merijn> chisui_: Requires DataKinds
09:15:20 <merijn> dignissimus: Yes, no, maybe.
09:15:28 <merijn> dignissimus: How are you getting input and from where?
09:16:15 <pikajude> :k (,)
09:16:17 <lambdabot> * -> * -> *
09:16:23 <pikajude> yeah, i think (,) can only hold Types
09:16:24 <chisui_> merijn: locally I have DataKands, PolyKinds and TypeInType enabled in ghc 8.6.5 and I get the same Error
09:16:33 <dignissimus> meirjn: It's a project on github and right now it uses `getInputLine`
09:16:40 <pikajude> you'd have to make your own tuple-ish type
09:16:57 <chisui_> pikajude: shouldn't PolyKinds get rid of that restriction?
09:17:05 <merijn> dignissimus: So it's using haskeline in the terminal?
09:17:08 <pikajude> well, to be honest, i have no idea
09:17:11 <pikajude> maybe
09:17:22 <dignissimus> merijn: Yea
09:18:18 <chisui_> :k []
09:18:20 <lambdabot> * -> *
09:18:25 <merijn> dignissimus: Then no, because the application never gets/sees the escape
09:18:47 <pikajude> i'm not sure chisui_, i think that only applies to types you define
09:19:02 <pikajude> @let data Pair2 (a :: k) (b :: k2)
09:19:04 <lambdabot>  Defined.
09:19:07 <pikajude> :k Pair2
09:19:08 <lambdabot> k -> k2 -> *
09:19:12 <dignissimus> merijn: thanks!
09:19:15 <pikajude> :k Pair2 "foo" Int
09:19:16 <lambdabot> *
09:19:56 <chisui_> pikajude: Ah ok, thanks
09:20:06 <pikajude> from what i've read through a quick google search, PolyKinds causes new declarations to infer that their arguments can be of any kind rather than specifically *
09:20:24 <pikajude> but (,) is defined elsewhere as type * -> * -> * so you need to make your own
09:21:03 <pikajude> which makes sense to be honest. (,) is designed to hold two values and i don't believe it's possible to construct a value of type k if k isn't Type
09:21:17 <pikajude> :k Tagged
09:21:18 <lambdabot> error:
09:21:18 <lambdabot>     Not in scope: type constructor or class ‚ÄòTagged‚Äô
09:21:20 <pikajude> oh
09:21:44 <pikajude> :k Data.Tagged.Tagged
09:21:46 <lambdabot> k -> * -> *
09:21:53 <pikajude> that might do what you want
09:22:39 <chisui_> Ahh thanks
09:24:02 <ski> % :kind '("sym", Int)
09:24:03 <yahb> ski: '("sym", Int) :: (GHC.Types.Symbol, *)
09:24:32 * hackage hoauth2 1.9.0 - Haskell OAuth2 authentication client  https://hackage.haskell.org/package/hoauth2-1.9.0 (HaishengWu)
09:26:10 <chisui_> ski: Huh, I thought the ' was optional. Thanks
09:30:26 <pikajude> totally forgot that was even a thing
09:30:28 <pikajude> there you go
09:35:45 <dsal> I was having breakfast reading a history book and my brain was like, "Hey, yesterday you wrote `sequence (res <$> segs)` which is the same thing as `traverse res segs`"
09:37:21 <jle`> dsal: breakfast really does stimulate the brain huh
09:38:05 <dsal> It mentioned something about mapM first...
09:38:36 <heatsink> Must have been very recent history if it mentioned mapM
09:38:41 <dsal> ha
09:39:10 <dsal> I don't know haskell history well.  I'd think traverse would be newer than mapM
09:39:48 <heatsink> mapM is older.  Originally it was for lists only.
09:39:52 <pikajude> traverse is part of the definition of applicative isn't it?
09:40:02 <jle`> it's a part of Traversable
09:40:07 <pikajude> oh
09:40:25 <pikajude> now that you mention it, that makes some kind of sense
09:40:35 <jle`> since its main "goal" is to be able to generalize over different containers
09:40:41 <dsal> I just remember that mapM ~= traverse
09:40:51 <pikajude> Applicative should have a function `applicate`
09:40:53 <pikajude> for comparison
09:41:18 <dsal> I think <*> should be pronounced "applicate"
09:41:25 <pikajude> how is <$> pronounced
09:41:35 <dsal> func that
09:41:59 <jle`> fmap
09:42:10 <jle`> although i suppose that can be confusing
09:42:25 <pikajude> well they are equivalent
09:42:37 <dsal> I want to make a new language that is exactly haskell, but without return, and map is just fmap.
09:42:37 <jle`> "fmapped onto", maybe
09:43:33 <jzyamateur> Not sure why following has issues: https://gist.github.com/chetnashah/4684fc4ae14ff9eec5e93cc19a3cff4e,  it says : no instance for `(Semigroup (Listy a))`
09:43:48 <pikajude> Semigroup is a superclass of Monoid now
09:43:58 <pikajude> so you have to define that first
09:44:04 <jle`> jzyamateur: just like how you need to define Eq to define Ord
09:44:08 <jle`> note you don't have to define Semigroup "first"
09:44:11 <dsal> jzyamateur: semigroup and monoid split at some point.  a monoid needs to be a semigroup
09:44:13 <jle`> you can define it after, as well, as long as it's somewhere
09:44:15 <pikajude> you can define it second too
09:44:21 <pikajude> or even third, if you're feeling adventurous
09:44:22 <jzyamateur> Here  https://gist.github.com/chetnashah/4684fc4ae14ff9eec5e93cc19a3cff4e
09:44:34 <jle`> try adding:
09:44:39 <jzyamateur> Got it,I'll give it a shot
09:44:42 <jle`> instance Semigroup (Listy a) where
09:44:44 <jle`>   (<>) = mappend
09:44:51 <pikajude> wait, that works?
09:44:59 <pikajude> oh, i guess it would if you overrode the mappend definition
09:45:06 <jle`> yeah, ordering of definitions doesn't matter in haskell
09:45:12 <jle`> only order of case statements and guards
09:45:14 <pikajude> no, i was thinking about the default definition of mappend
09:45:16 <pikajude> mappend = (<>)
09:45:31 <jle`> ah yeah, to be clear that is (<>) = mappend :: Listy a -> Listy a -> List y
09:45:38 <jle`> specifically the mappend that was already defined for Listy
09:45:46 <jle`> which was defined on line 8
09:46:15 <pikajude> üëç
09:46:35 <jle`> jzyamateur: alternatively you can do Listy l <> Listy l' = Listy (mappend l l') as well, moving your deifnition to (<>), instead of as mappend
09:46:46 <jle`> pikajude: that's what i meant when i said you can define it second/after :)
09:46:55 <pikajude> or Listy l <> Listy l' = Listy (l <> l')
09:47:02 <monochrom> You can define it 100 lines later!
09:47:13 <dsal> Is 100 the limit?
09:47:16 <pikajude> does GND work here or no
09:47:17 <jzyamateur> Finally adding Semgroup instance worked: https://gist.github.com/chetnashah/4684fc4ae14ff9eec5e93cc19a3cff4e
09:47:25 <pikajude> i would think not since [a] doesn't match a
09:47:28 <jle`> i suppose i mean 'you can define it after' in a topological sort sense
09:47:33 <svipal> I don't understand "experiment" from the Store Comonads
09:47:42 <monochrom> I am actually disappointed that you can't write your "import Control.Monad" 100 lines later, but thankfully rust has fixed that!
09:47:51 <jle`> jzyamateur: nice :)
09:48:01 <jle`> svipal: what part do you not understand?
09:48:13 <jle`> svipal: its type, how it is implemented, or what its purpose is?
09:48:32 <svipal> the last two are still murky. the first one I understand somewhat
09:48:44 <svipal> I just did this tuto : https://chrispenner.ca/posts/conways-game-of-life
09:49:13 <jle`> also to be clear, are you talking about ComonadStore, or Comonad Store?
09:49:55 <jle`> ie, the experiment 'abstraction' that works for many different store-like types, or specifically experiment for the concrete Store type
09:50:01 <jle`> with a specific implementation
09:50:05 <svipal> In this particular case, the Store from Control.Comonad.Representable.Store
09:50:30 <svipal> but I think the abstraction, not a specific impl
09:50:54 <ChrisPenner[m]> I cover Store in pretty good detail here: https://youtu.be/dOw7FRLVgY4
09:50:57 <ChrisPenner[m]> üòÑ
09:51:07 <jle`> ah okay, that one is a little trickier than the store from Control.Comonad.Store
09:51:16 <jle`> but yes, listen to ChrisPenner[m] :)
09:51:28 <pikajude> the [m] stands for monad
09:52:00 <svipal> Haha. Alright, will watch 
09:53:14 <jle`> svipal: if it helps, the type of 'experiment' should remind you somewhat of the type of traverse or traverse_. and also if you are familiar with lenses there are some shared concepts too
09:53:41 <jle`> (both of these are an attempt to hint at why it might be useful)
09:54:22 <jle`> svipal: another way of approaching it is that you can use 'experiment' to define pos, peek, peeks, seek, seeks, extract, duplicate, etc.
09:54:44 <jle`> (er i haven't checked duplicate but i believe it should be possible)
09:54:56 <pikajude> why isn't it called `cojoin` :(
09:54:56 <jle`> svipal: so in a way experiment is like a 'mother function' from which the others can be seen to arise from
09:55:25 <jle`> it unites aspects of pos/peek/seek/extract/etc. into a unified interface, generalizing all of them
09:55:56 <jle`> letting you do things like combining them to do more than one at once and stuff like that
09:56:12 <jle`> it also generalizes a very common usage pattern of Store, so in that sense you might not be able to appreciate it until you use Store a lot
10:07:24 <svipal> thank you for the writeup
10:07:28 <svipal> do you use Store a lot ?
10:17:37 <jzyamateur> Although I have question, I am seeing implementations monoid instances of `Sum`, `Product`, do not need to provide Semigroup instances? 
10:17:53 <jzyamateur> https://hackage.haskell.org/package/base-4.5.0.0/docs/src/Data-Monoid.html#Last
10:20:32 * hackage RSA 2.4.1 - Implementation of RSA, using the padding schemes of PKCS#1 v2.1.  https://hackage.haskell.org/package/RSA-2.4.1 (AdamWick)
10:33:56 <jzyamateur> When defining monoid instance for `Sum` , there is no need to provide Semigroup  instance? https://hackage.haskell.org/package/base-4.5.0.0/docs/src/Data-Monoid.html#Sum
10:34:31 <cocreature> jzyamateur: you are looking at a very old version of base
10:36:18 <jzyamateur> So >4.7 is considered modern then?
10:36:18 <cocreature> jzyamateur: https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Semigroup.Internal.html#Sum
10:37:34 <cocreature> not sure what you can call modern but 4.5 corresponds to GHC 7.4 which is definitely not modern :)
10:37:49 <cocreature> the latest 3 GHC releases is usually a good rule of thumb for ‚Äúmodern‚Äù
10:38:19 <jzyamateur> the stack templates have `base >=4.7 && <5` so I thought... :)
10:40:55 <cocreature> base 4.7 corresponds to GHC 7.8 which was released in 2014
10:47:09 <freeman42x> is it possible to do this with cabal v1? https://github.com/haskell/cabal/issues/4271#issuecomment-504792843 basically compile a dependency "miso" with a flag
11:02:58 <liff> does anyone know if `hoogle search -c` is the same as `hoogle search --color`? it says `-c` is unknown but that flag is used here: https://github.com/NixOS/nixpkgs/blame/master/doc/languages-frameworks/haskell.section.md#L322
11:08:27 <MarcelineVQ> idk but that says -cl not -c
11:11:14 <dsal> Any estimates on how long it will be until ghc 8.8 is totally ready for my projects?
11:12:04 <liff> MarcelineVQ: afaik -cl is the same as -c -l and -l is --link in the current version at least
11:12:26 <dsal> unrelated:  Kind of annoyed that my test was failing because I passed a value of the wrong type to a function.  I type aliased two different things to Int and the compiler was fine with that.
11:14:19 <dmwit> dsal: I mean... that's what type aliases do. You want the compiler to distinguish, you gotta newtype.
11:15:54 <MarcelineVQ> liff: oh right for short opts -cl should be the same as -c -l , hmm
11:32:02 * hackage constraint-tuples 0.1 - Partially applicable constraint tuples  https://hackage.haskell.org/package/constraint-tuples-0.1 (ryanglscott)
11:32:48 <dsal> dmwit: Yeah, I know...  These are really just stand-in types.  I'm going to suffer a bit when I come up with a proper type.
11:34:46 <pikajude> you can just make it a newtype now
11:35:11 <pikajude> then it won't typecheck but you can swap out the implementation for whatever you like later :)
11:36:22 <dsal> Yeah.  That'll save me time in the future.
11:37:04 <dsal> I still don't fully understand the difference between newtype and data.  Is there ever reason I'd want to use data when newtype would work?
11:37:14 <pikajude> if you need more than one field
11:37:23 <EvanR> then a newtype would not work
11:37:24 <dsal> Yeah, but then newtype wouldn't work.
11:37:24 <jle`> dsal: some extra laziness, maybe
11:37:30 <pikajude> oh yeah, right
11:37:34 <EvanR> yeah, only if you wanted an extra bottom
11:37:41 <pikajude> no i don't think so, HLint has a warning actually for if you use a one-field data constructor
11:37:46 <jle`> some people like to define data Thunk a = Thunk { getThunk :: a }
11:37:48 <ghoulguy> YOu might use a data type instead of a newtype to add strictness.
11:37:49 <pikajude> "note: increases laziness" or something
11:37:56 <ghoulguy> For example monadLib provides both Id and Lift
11:38:11 <pikajude> but for something that wraps Int you probably don't want the extra wrapper
11:38:22 <pikajude> i did the same thing when trying to write an idle game that would handle extremely large numbers
11:39:11 <EvanR> yeah i imagine you usually want newtype if it would work
11:39:59 <ghoulguy> http://hackage.haskell.org/package/monadLib-3.10/docs/MonadLib.html
11:40:19 <dsal> I was just wondering why data didn't automatically newtype when it could.
11:40:38 <pikajude> well they have different semantics according to the standard, i think
11:41:23 <EvanR> yep you don't want compiler changing semantics on your behalf
11:41:43 <dsal> Sure.  Just wondering when it matters.  I write a lot of blue collar haskell.
11:41:50 <pikajude> can't you sort of pretend to be a newtype data if it's data Foo a = Foo { unFoo :: !a }
11:41:58 <pikajude> or am I misunderstanding
11:42:16 <EvanR> you might be able to prove they are equivalent in that case
11:42:41 <jle`> there's still a level of indirection, i believe 
11:42:48 <ghoulguy> pikajude: That changes the runtime representation and behavior of pattern matching
11:43:03 <jle`> data Foo a = Foo !a would have the same sort of infrastructure, representation-wise, as data FOo a = Foo !a | Bar Something
11:43:09 <jle`> ie, it would still have a "constructor" tag
11:43:14 <pikajude> ew
11:43:14 <EvanR> ah
11:43:25 <jle`> the rep is [constructor][values]
11:43:28 <EvanR> equivalent semantics but different performance
11:43:48 <jle`> yeah i'm trying to think of a situation where the semantics would be different
11:45:44 <jle`> @let data Identito a = Identito !a
11:45:46 <lambdabot>  Defined.
11:45:53 <EvanR> if same semantics, compile could indeed implement that as a newtype, and woe be to anybody who thinks they no what theyre doing with unsafeCoerce
11:45:54 <jle`> > case undefined of Identity _ -> "hi"
11:45:56 <lambdabot>  "hi"
11:46:04 <jle`> > case undefined of Identito _ -> "hi"
11:46:06 <lambdabot>  "*Exception: Prelude.undefined
11:46:19 <jle`> yeah, that's the difference there. in the first case the pattern match essentially does nothing because there is no constructor to match on
11:46:29 <jle`> but in the second case it still looks for the 'constructor', which fails because undefined
11:46:36 <EvanR> blaw
11:46:37 <jle`> ( dsal )
11:47:02 <jle`> or maybe it was pikajude 
11:47:26 <dsal> :t Identity
11:47:27 <lambdabot> a -> Identity a
11:47:33 <jle`> newtype Identity a = Identity a
11:47:37 <dsal> Ah.
11:47:42 <dsal> That's interesting.
11:47:55 <jle`> data types always have a 'constructor' you must match on to get to the value inside
11:48:03 <jle`> runtime wise, in memory, i mean. at least for ghc
11:48:11 <EvanR> even when there is only 1 ctor
11:48:14 <pikajude> was it me?
11:49:01 <jle`> you can bypass the constructor matching semantics with lazy pattern matches, but that doesn't change the representation of the type, just how you match on it
11:49:08 <jle`> > case undefined of ~(Identito _) -> "hi"
11:49:10 <lambdabot>  "hi"
11:49:40 <jle`> in that case it just defers the 'matching' on the constructor until ... *checks script* never
11:50:07 <jle`> (in general, until the time when you actually use the values bound inside the constructor)
11:52:06 <EvanR> going further, does that mean matching on a newtype ctor is always lazy
11:52:41 <jle`> i'm not sure i would say 'lazy', but i think it would match the semantics of ~(Identito _) there
11:52:47 <jle`> since newtype ctors don't exist at runtime
11:52:48 <EvanR> > case Identity undefined of Identity _ -> ()
11:52:50 <lambdabot>  ()
11:53:06 <EvanR> > case undefined of Identity _ -> ()
11:53:08 <lambdabot>  ()
11:53:11 <EvanR> heh
11:53:39 <EvanR> there are too many cases like this to consider, it's annoying
11:54:08 <jle`> i think the general heuristic i use is that newtype is just the exact same rep as the inner type
11:54:14 <EvanR> combination of newtype vs data, bang patter vs normal pattern vs lazy pattern
11:54:18 <jle`> whereas data is [constructor][val1][val2]
11:54:29 <jle`> from there the rest of it can follow logically
11:55:03 <jle`> although i think a couple of weeks ago i had some confusion on nested bangs and laziness. not that the result was not understandable, but that there were a lot of layers of meanings to go through, heh
12:04:30 <MarcelineVQ> liff: tbh I can't even tell why some args have short opts and some don't, --link and --numbers are exactly the same in the code as far as I can find, yet one has a short opt
12:14:31 * hackage secp256k1-legacy 0.5.6 - fork of secp256k1  https://hackage.haskell.org/package/secp256k1-legacy-0.5.6 (fommil)
12:36:14 <liff> MarcelineVQ: i wonder if System.Console.CmdArgs automatically generates short options from long names
12:37:35 <liff> MarcelineVQ: the --color option has been there for a long time but at some point --compare was added, which would conflict with -c
12:37:40 <MarcelineVQ> but the longer name is the one missing the short opt :> (whe comparing info and numbers) it's really weird
12:38:03 <MarcelineVQ> *link and numbers
12:39:57 <liff> well link doesn't have first letter conflicts but numbers does via --count
12:44:57 <MarcelineVQ> oh I see, count was given -n shortcode
12:46:14 <MarcelineVQ> at least that is explicit in the code hehe: ,count = 10 &= name "n" &= help "Maximum number of results to return"
12:47:42 <ondrejs> Hi. I am running into a problem with `ekg-influxdb`, there's a `NaN` `Double` value (mean of empty dataset `Prelude System.Metrics.Distribution> new >>= System.Metrics.Distribution.read  \n Stats {mean = NaN, variance = 0.0, count = 0, sum = 0.0, min = 0.0, max = 0.0}`) and it fails to format to influxdb (because there `NaN` is not a valid float).
12:47:43 <ondrejs> Anyone ever run into this?
12:49:16 <ondrejs> I am not sure where to try fixing this, maybe `ekg-core` shouldn't return `NaN` here (it doesn't do it for other parts of the `Stats` record which don't make much sense when `count = 0` either).
12:49:18 <dmwit> I find it a bit odd that it would bother encoding the mean at all.
12:49:35 <dmwit> Since it is presumably completely recoverable from the sum and count.
12:49:48 <dmwit> Perhaps you could cook up a patch that encodes this idea.
12:50:58 <MarcelineVQ> liff: it does seem pretty likely that -c is supposed to be color, even in quite old ones count's shortcode is -n so color shouldn't have had a conflict back then and, if it had one automatically, would likely end up with -c
12:51:32 <ondrejs> dmwit: That's what I've done so far but just dropping this might be a backward compatibility breaker for a lot of things?
12:52:06 <The_Tick> is there a channel specific to the regex implementation?
12:52:44 <ondrejs> Come to think of it I'd like to see some (other) percentiles there...
12:53:20 <dmwit> The_Tick: I don't know of one. If your question is Haskell-related, it's welcome here.
12:53:37 <The_Tick> well we have a user in #regex asking regex questions
12:53:45 <liff> MarcelineVQ: agreed, i suppose i could confirm it by building some old version of hoogle but not sure if it's worth it :)
12:53:55 <The_Tick> and it makes me want to stab whoever decided 42 different regex variants was a good idea
12:53:55 <dmwit> ondrejs: Computing other percentiles online forces you to store all samples.
12:54:00 <dmwit> ondrejs: Which is probably why it isn't done.
12:54:49 <The_Tick> I didn't want to drown the channel in regex specific questions if there was a side channel
12:55:09 <ondrejs> Yeah, quite likely. It seems to me that I'd sooner have the problem of not having them than being overflown by data but that's for another discussion.
12:55:52 <dmwit> ondrejs: I don't know enough about influxdb to give good back-compatibility advice.
12:56:04 <dmwit> Perhaps corresponding with the author of ekg-influxdb would be the right next step.
12:56:31 <ondrejs> Agreed, I am already making a patch.
12:56:43 <dmwit> ondrejs++
12:57:03 <dsal> I've been doing a lot with influxdb lately
12:58:12 <dsal> I don't know what ekg is, though.
12:58:58 <dmwit> ondrejs: Possibly: store a dummy value for that field when writing, but ignore it when reading.
12:59:27 <ondrejs> dsal: monitors your haskell app. For example garbage collection statistics, endpoint usage for Servant APIs,...
13:00:03 <ondrejs> dmwit: precisely. The Stats type is defined in ekg-core, I am just going to patch ekg-influxdb to ignore the value
13:00:07 <dmwit> dsal: The minimal version of the question is either 1. how do you store a NaN? or 2. how do you delete a field/column/whatever influxdb calls it from a structure in a backwards compatible way?
13:02:11 <dsal> It's sort of column oriented. You can omit values.  Deleting is just removing all the records containing the column you don't want, I think.  I've run into a variety of bugs, though.
13:04:42 <Guest_99> Hello everyone
13:04:55 <Guest_99> I'm not sure this is the right spot where to ask
13:05:02 <Guest_99> but i'd like to remove ghcup
13:05:09 <Guest_99> where i can find an uninstaller?
13:08:26 <ondrejs> Guest_99: what operating system are you using?
13:08:32 <Guest_99> linux
13:08:40 <Guest_99> archlinux to be correct
13:09:33 <Guest_99> i have installed ghcup running "curl https://get-ghcup.haskell.org -sSf | sh"
13:10:42 <Guest_99> I'd like to nuke anything haskell related in order to re-install later
13:11:12 <ondrejs> I wonder whether it even has some uninstaller but looking into it maybe just removing the directories and the file changes it made would be enough?
13:11:25 <ondrejs> doesn't seem to do that much so it could be feasible
13:11:51 <Guest_99> i was looking for a more definitive solution
13:11:53 <trcc> I am looking at this: http://hackage.haskell.org/package/wai-logger-2.3.6/docs/Network-Wai-Logger.html#t:IPAddrSource but I do not know which one to choose between: FromSocket, FromHeader, FromFallback. I am creating a backend application. Can someone help me understand the differences?
13:12:16 <Guest_99> because i also need to clean up all the different stack's copy of ghc
13:15:06 <ondrejs> Guest_99: sorry and welcome to the club of victims of shell script installers :-)
13:15:36 <EvanR> most installers really... don't provide you with the log of all it did by default
13:15:46 <EvanR> and people are not in the habit of expecting one
13:16:19 <EvanR> package managers sometimes provide this but have their own issues
13:17:03 <EvanR> i gave up trying to uninstall things long ago :)
13:17:09 <zeta_0> hello guys, i am looking at this `haskell operators and other lexical notation` pdf, one of the symbols that is confusing me is the `>@>` (object composition operator(monads)), i can't seem to find this operator `>@>` being used on the internet ?
13:17:49 <ondrejs> trcc: never really worked with this but my guess would be that "from socket" will use the address given by the underlying network layer, "from headers" will use what the http client claims (might be useful for example if you're using proxies which might set these headers) and the last one is a combination of the previous two as described
13:18:00 <trcc> ahh
13:18:03 <trcc> thanks ondrejs
13:18:48 <EvanR> zeta_0: never heard of it. But hoogle does point to a library that defines >@>
13:18:59 <ChaiTRex> zeta_0: Hoogle (with an h on the front) finds only this: https://hoogle.haskell.org/?hoogle=(%3E%40%3E)
13:19:09 <zeta_0> i forgot to post the link: https://imada.sdu.dk/~rolf/Edu/DM22/F06/haskell-operatorer.pdf
13:19:46 <EvanR> zeta_0: that looks old old... you want (>=>) 
13:20:36 <zeta_0> so (>@>) is not used anymore, or it is only used for a special use case?
13:20:59 <zeta_0> there are no examples of this on the internet?
13:21:07 <ondrejs> well clearly `(>@>) = ><(((¬∫>` /s
13:22:11 <ChaiTRex> zeta_0: It's hard to search for it, since Google thinks it's punctuation rather than working properly.
13:22:12 <EvanR> zeta_0: https://github.com/haskellcats/haskell-operators
13:22:43 <dignissimus> Os tjere a wprd fpr non-laazy functions?
13:23:01 <dignissimus> *Is there a word for non-lazy functions?
13:23:13 <ChaiTRex> dignissimus: eager
13:23:21 <dignissimus> Thanks
13:26:07 <EvanR> :t getLine >=> putStrLn
13:26:08 <lambdabot> error:
13:26:08 <lambdabot>     ‚Ä¢ Couldn't match expected type ‚Äòa -> IO String‚Äô
13:26:08 <lambdabot>                   with actual type ‚ÄòIO String‚Äô
13:26:19 <EvanR> dang
13:26:30 <EvanR> :t const getLine >=> putStrLn
13:26:32 <lambdabot> b -> IO ()
13:26:53 <ChaiTRex> @type (>=>)
13:26:54 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
13:27:08 <EvanR> not a very motivating example fish operator
13:30:54 <zeta_0> thanks guys
13:32:13 <cheater> hello
13:32:37 <ondrejs> dmwit: https://github.com/angerman/ekg-influxdb/pull/2
13:33:04 <cheater> can this type be expressed in another way? ((a -> Int) -> Int)
13:35:31 <EvanR> if you consider a -> Int to consist only of constant functions then
13:35:38 <EvanR> Int -> Int
13:36:28 <cheater> is there a way for a function f :: a -> Int to not be constant?
13:36:32 <EvanR> intIntIfy :: ((a -> Int) -> Int) -> (Int -> Int)
13:37:03 <EvanR> intIntIfy f i = f (const i)
13:38:14 <EvanR> cheater: f :: forall a . a -> Int can't possible use its argument for anything, and can't analyze it
13:38:25 <cheater> true
13:38:28 <EvanR> it has nothing to go on
13:38:35 <cheater> but it doesn't have to be forall a
13:38:44 <EvanR> that's what a -> Int means
13:38:44 <cheater> it could be newtype T a = (a -> Int)
13:38:57 <ChaiTRex> cheater: You could do something like getting the type name and turning it into an Int.
13:39:15 <cheater> in which case if I have T Int, I could have f1 x = 2*x, f2 x = 2+x
13:39:25 <cheater> ChaiTRex: i'm not talking about that :)
13:39:27 <EvanR> well T Int means you have an Int -> Int
13:39:32 <EvanR> not an a -> Int
13:39:35 <dsal> ondrejs: makes sense to me.  Otherwise, you'd conditionally include it only if it could be computed.
13:39:46 <EvanR> that is another situation entirely
13:39:46 <cheater> i could also have T Char
13:39:54 <EvanR> you could have a Char -> Int
13:39:55 <cheater> and that could be ord or whatever
13:39:57 <cheater> yes
13:40:14 <EvanR> but we're talking about a polymorphic function of type a -> Int
13:40:23 <cheater> i'm not
13:40:27 <EvanR> o_O
13:40:33 <cheater> i think you thought at some point it was polymorphic. but it isn't
13:40:39 <cheater> i'm talking about a situation like T a
13:40:45 <EvanR> start over
13:40:56 <EvanR> completely
13:41:01 <cheater> I have newtype T a = (a -> Int) -> Int
13:41:07 <cheater> sorry
13:41:10 <cheater> I have newtype T a = T (a -> Int) -> Int
13:41:21 <cheater> and i'm trying to figure out if this type can be expressed another way
13:41:56 <EvanR> do you mean newtype T = forall a . T ((a -> Int) -> Int)
13:42:02 <higherorder> Hey! What's the difference between the monad stack `StateT Maybe` and `MaybeT State`? (difference in behaviour)
13:42:10 <cheater> there's no explicit forall written out
13:42:16 <cheater> i don't know if it's there implicitly? is it?
13:42:20 <EvanR> note the missing a in front
13:42:38 <cheater> no, i'm talking about newtype T a = T ((a -> Int) -> Int)
13:42:40 <ghoulguy> ?unmtl MaybeT (State s) a
13:42:40 <lambdabot> s -> (Maybe a, s)
13:42:44 <EvanR> in GADT syntax
13:42:46 <ghoulguy> ?unmtl StateT s MaybeT a
13:42:46 <lambdabot> Plugin `unmtl' failed with: `MaybeT (a, s)' is not applied to enough arguments.
13:42:48 <ghoulguy> ?unmtl StateT s Maybe a
13:42:48 <lambdabot> s -> Maybe (a, s)
13:43:00 <EvanR>   T :: forall a . ((a -> Int) -> Int) -> T a
13:43:04 <ghoulguy> higherorder: Do you see the difference in those two types?
13:43:21 <cheater> EvanR: i don't see why we need to turn this into a GADT..
13:43:41 <EvanR> i didn't use GADT features just the syntax to establish what were dealing with
13:43:54 <cheater> i don't know what it looks like in GADT syntax.
13:43:57 <higherorder> ghoulguy: so one gives me what I guess is the partial state until you reached the "error", and the other only gives me the final state if no error?
13:44:05 <EvanR> like that ^
13:44:05 <ghoulguy> higherorder: Yes
13:44:07 <cheater> this is confusing. i'm gonna go eat something :)
13:44:11 <cheater> i don't know that :)
13:44:13 <cheater> cya later
13:44:26 <higherorder> ghoulguy: I see; thanks! do you have any tips for how to think about the behaviour of stacks of transformers like that?
13:44:36 <ondrejs> dsal: neat, thanks
13:45:12 <cheater> higherorder: if you take a lasagna and put it on top of another lasagna it's just one lasagna
13:45:19 <ghoulguy> higherorder: The monad transformers define their behaviors in terms of the transformed monad's unchanged behavior
13:46:19 <ghoulguy> higherorder: I'll sometimes remember it by remembering that if I transform IO, the effects that run can't be lost
13:46:32 <ghoulguy> The monads in that position are more "primitive"
13:46:52 <ghoulguy> So if Maybe is the monad being transformed, then there won't be any results in the case of Nothing
13:47:12 <higherorder> ghoulguy: but so, taking the example of state & maybe, how can I make sense of the fact that one returns the state "up to the error"?
13:47:17 <higherorder> ah, I see
13:47:19 <ghoulguy> If State is the monad being transformed, then the running state can't be lost by MaybeT
13:49:35 <MarcelineVQ> EvanR: what are you getting at? :> showing how something must be constant (meaning like const) to inhabit T?
13:50:05 <EvanR> that's wrong so i better not be getting at that
13:51:01 <EvanR> rearrange the question to be, is there another way to represent the type (A -> Int) -> Int where A is a specific concrete type
13:51:55 <shapr> I just realized I want to filter a Vector, and I can use Data.Vector.filter as I can do with a bunch of other types, but why can't I use a Foldable instance to filter?
13:52:08 <shapr> much like I can use fmap on most anything, why am I limited to using filter on lists?
13:52:23 <shapr> Perhaps there's a sensible explanation?
13:52:24 * shapr thinks
13:52:27 <EvanR> Foldable doesn't let you create structure it can only destroy
13:52:50 <shapr> traversable?
13:52:53 <EvanR> there's a blog post about this exact issue... and also a class to do what you say sort of "Witherable"
13:53:00 <shapr> oh?
13:53:02 * shapr asks google
13:53:26 <shapr> EvanR: do you know the blog post? I can't find it.
13:53:46 * EvanR trying
13:53:57 <ghoulguy> traversable offers no way to change or create structure.
13:54:18 <shapr> so I'd have to jump through Monad in order to change structure?
13:54:32 <shapr> I've only seen Monad increase structure, hmm
13:54:32 * shapr thinks
13:54:51 <shapr> I don't see why it couldn't remove structure.
13:55:43 <EvanR> https://wiki.haskell.org/Foldable_and_Traversable#Some_trickier_functions:_concatMap_and_filter
13:55:57 * shapr reads
13:56:22 <shapr> yow, that's interesting and roundabout
13:56:24 <ghoulguy> shapr: the Traversable laws ensure that the structure doesn't change
13:56:32 <EvanR> prescious little info there..
13:56:40 <shapr> ah, I need to read through the typeclassopedia
13:57:20 <shapr> again
14:00:27 <ghoulguy> shapr: for some intuition, consider "data V2 a = Mk a a"
14:01:03 <ghoulguy> This admits a Traversable instance, but what would it mean to filter this?
14:01:09 <EvanR> i haven't seen Data.Witherable get lambasted yet for being off the rockers, so maybe the classes defined in there make sense. At least they have laws and incorporate pre-existing classes
14:01:44 <trcc> So I have gotten so far as to define a Network.Wai.Logger.ApacheLoggerActions, but I need to figure out how to use this in context of Network.Wai.Middleware for Scotty. Anyone up for helping? https://gist.github.com/CThuleHansen/a48d53eb5233e239dff7a18778fe9ea6#file-logger-hs-L80-L88
14:01:47 <EvanR> yes filtering requires a carefully coordinated 'punch-out' of a given data structure
14:02:40 <shapr> ghoulguy: that is good intuition, thanks
14:03:02 <shapr> ghoulguy: I could always fire Foldable.toList and filter that?
14:03:04 <pikajude> for Map, isn't filter just fromList . filter . toList
14:03:19 <ghoulguy> shapr: only if you wanted a list
14:03:22 <pikajude> is there any datastructure where filter can be implemented efficiently besides lists?
14:03:32 <EvanR> sure
14:04:02 <shapr> well, list is fine, but I'm enjoying the realization that this could be generalized, and wondering why not
14:04:29 <ghoulguy> shapr: but the Traversable operations don't change the type between input and output
14:04:36 <EvanR> Data.Map gives O(n) for it's filter operation
14:04:41 <ghoulguy> ?type traverse
14:04:42 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
14:04:51 <infinisil> pikajude: Generalization of filter: https://hackage.haskell.org/package/mono-traversable-1.0.13.0/docs/Data-Sequences.html#v:filter
14:05:01 <ghoulguy> Filtering Map via lists is also linear time
14:05:16 <EvanR> shapr: heh, Vector is an instance of Filterable
14:05:23 <ghoulguy> shapr: the t remains unchanged
14:05:31 <shapr> there's a Filterable typeclass? oy
14:05:38 <shapr> @where typeclassopedia
14:05:38 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
14:05:40 <EvanR> that's what i've been trying to tell you! :)
14:05:44 <shapr> is that really the latest version?
14:05:51 <ghoulguy> shapr: that's just in mono-traversable
14:05:51 <shapr> I'm finding too many versions of the Typeclassopedia
14:05:55 <EvanR> haskell wiki is old :(
14:06:00 <shapr> I figured as much
14:06:00 <geekosaur> I don;t think it speaks of Witherable and friends, or mono-traversable
14:06:11 <geekosaur> they're neither of them standard classes
14:07:02 <dignissimus> Is there a way I could write this in one line? `name <- io_function; another_function name;`
14:07:03 <shapr> so if I really needed to filter a Vector and get a Vector, I should just use Data.Vector.filter
14:07:13 <EvanR> mapMaybe :: Filterable f => (a -> Maybe b) -> f a -> f b
14:07:27 <ghoulguy> Yeah, using the vector specific operation is a good idea
14:07:29 <shapr> if I'm fine with a list, filter on the result of Foldable.toList
14:07:32 <EvanR> filter :: Filterable f => (a -> Bool) -> f a -> f a
14:07:38 <pikajude> yeah but still
14:07:42 <ChaiTRex> @undo do { name <- io_function; another_function name }
14:07:42 <lambdabot> io_function >>= \ name -> another_function name
14:07:44 <shapr> but it certainly FEELS like there should be a generalization of some sort
14:07:44 <geekosaur> dignissimus: io_function >>= another_function
14:07:49 <pikajude> you can pretend to have a Filterable instance with fromList . filter f . toList
14:07:53 <EvanR> these classes have laws
14:07:56 <pikajude> because Foldable defines toList and pretty much everything defines fromList
14:07:59 <pikajude> anything that's containery
14:08:04 <ChaiTRex> dignissimus: Looks like io_function >>= another_function.
14:08:11 <dignissimus> geekosaur: So tha's what that operator does, thank you!
14:08:16 <EvanR> pikajude: yes but all these structures have a more efficient filter
14:08:23 <dignissimus> ChaiTRex: Thanks also
14:08:24 <pikajude> like what?
14:08:34 <EvanR> all the instances for Filterable here
14:08:53 <shapr> what are the laws for a catamorphism? must that necessarily work like Foldable, where it produces a single summary value?
14:08:54 <EvanR> IntMap, Map, Vector, Seq..
14:08:58 <pikajude> what's here
14:09:05 <EvanR> https://hackage.haskell.org/package/witherable-0.3.4/docs/Data-Witherable.html
14:09:09 <pikajude> oh ok
14:09:17 <pikajude> i was looking in the buffer for Filterable
14:09:35 <pikajude> oh yeah i see, Map's filter is actually not implemented that way
14:09:43 <pikajude> i wonder where i saw that. it must have been somewhere
14:09:59 <geekosaur> thta's the default if not overridden by an instance, I think
14:10:06 <geekosaur> but most instances that can do better, do
14:10:23 <shapr> looks like the Typeclassopedia on the Haskell wiki is the latest
14:10:36 <EvanR> i imagine it doesnt' often come up that you want to be polymorphic over a thing that is filtering
14:10:48 <EvanR> for whatever reason
14:10:49 <MarcelineVQ> dignissimus: do syntax is really just a mechanical translation to >>= and >> this is a good tutorial that covers that as you go throught it, http://www.vex.net/~trebla/haskell/IO.xhtml
14:10:55 <geekosaur> yes, as I said, it concerns only standard and would-be-standard (e.g. Apply) classes, not things like Witherable
14:10:57 <shapr> Will someone remind me after Halloween that I should pick up The Monad.Reader again? So much great content came out of TMR, it's time for more!
14:11:08 <shapr> I also want to restart the International Obfuscated Haskell Code Contest
14:11:49 <shapr> I still have the winning entries from the last contest on my hard drive somewhere
14:11:49 <dignissimus> MarcelineVQ: Thank you, I'll take a look at that link
14:11:58 * shapr finds them
14:15:36 <shapr> The Succ Zero IOHCC entries are wondrous, I'd forgotten just how entertaining ...
14:17:04 * shapr goes back to writing useful code
14:22:38 <dignissimus> Are there any reasons that I shouldn't use newStdGen as opposed to managing the value from getStdGen?
14:24:26 <geekosaur> nobody's ever been quite sure about split?
14:25:06 <geekosaur> then again, what do you mean by managing? if you want to use it across threads, you probably want to newStdGen for each thread rather than try to multiplex access to one
14:27:07 <dignissimus> Ah, I mean running getStdGen once and taking values from it, with newStdGen it's a differen't generator which means you don't have to worry about getting different values, I want to ask whether there's any reason to use getStdGen over newStdGen 
14:30:04 <geekosaur> they're different things. newStdGen gives you a new derived but semi-independent RNG seed, getStdGen gives you a copy of the internal default RNG seed
14:30:11 <ghoulguy> No, you shouldn't use getStdGen
14:30:19 <geekosaur> in general you don't use getStdGen, you should use the standard accessors
14:31:49 <dignissimus> Thanks all
14:31:54 <geekosaur> randomRIO and randomIO access and update the standard RNG seed for you, in general you want those when working with it. newStdGen would be used if you want threads with their own RNG seeds
14:32:56 <geekosaur> you might also look at the MonadRandom package in that case, to help carry the StdGen around. but most of the time you'd just use randomIO or randomRIO and ignore the seed stuff
14:33:28 <geekosaur> newStdGen would be like making a new RNG instead of getting a random value
14:36:19 <dsal> If I have a    newtype T = T Int    is there a shortcut to Enum, Num, etc...?
14:37:22 <MarcelineVQ> yes, look up GeneralizedNewtypeDeriving
14:37:32 <ChaiTRex> dsal: You can use newtype T = T Int deriving (Enum, Num, etc)
14:37:44 <MarcelineVQ> "<EvanR> rearrange the question to be, is there another way to represent the type (A -> Int) -> Int where A is a specific concrete type" After playing a bit in ghci I find that I don't know.
14:37:58 <dsal> Oh.  yeah, I guess I could've followed that error...
14:48:08 <EvanR> MarcelineVQ: i came to the same conclusion
14:48:34 * MarcelineVQ backspaces the large buffer that was filling up with supposition.
14:51:33 <int-e> The special case (() -> Int) -> Int already covers all partially recursive functions.
14:51:42 <int-e> Uhm.
14:51:49 <int-e> Well, I imagined Integer, not Int.
14:52:27 <dsal> Note to self:  Don't "type X = Int" as a short cut and come back to fix it later...
14:52:28 <int-e> But even for Int this is an immensely big function space :)
14:52:49 <EvanR> Int -> Int
14:53:09 <EvanR> behold 
14:56:32 <int-e> EvanR: Even (A -> Bool) -> Bool is a pretty rich type.
14:56:50 <int-e> Somehow this is a fun question. Not sure it's useful...
14:57:28 <EvanR> but wait there's more
14:57:58 <EvanR> newtype U = U ((A -> U) -> U)
14:58:33 <EvanR> eventually we will bump into "polymorphism is not set theoretic"
14:59:11 <EvanR> yes that is changing the subject of cheaters question back to polymorphism
15:00:20 <int-e> EvanR: Now that one is only interesting because of bottoms, I think.
15:01:36 <EvanR> well, you can implement things that eat A's
15:01:59 <EvanR> they can be unfolded as long as you have a supply of A
15:02:20 <int-e> It's inhabited, but you can't really observe anything if you restrict yourself to total functions.
15:02:34 <EvanR> you're anti-observing
15:03:17 <int-e> Once you do add bottoms to the mix though, you get an (potentially infinite) A-branching tree with bottoms at the leaves.
15:03:40 <EvanR> i'm pretty much only considering the infinite case
15:03:57 <EvanR> so the bottoms, if they even exist, wouldn't matter
15:05:14 <EvanR> i think newtype U = U (A -> U) does this matter
15:05:22 <EvanR> does this better*
15:05:45 <int-e> This reminds me of a puzzle I've been pondering... newtype L = Abs (L -> L)   can be used to encode the untyped lambda calculus. Can we use observations on bottoms (in the form of exceptions) to get a lambda term from a value of type L, assuming it has a (beta) normal form?
15:06:34 <int-e> Ah and that's a special case of U of course.
15:06:35 <EvanR> basically using exceptions to stand for leaves
15:06:47 <EvanR> yeah it is
15:07:20 <EvanR> if you had a U... you could implement Stream A -> U -> ???
15:08:09 <EvanR> if A=U then you'd need more stuff
15:08:41 <int-e> That (L being a special case of U) suggests that U is not simply a tree... elements of U can construct their own A -> U functions internally and do wild stuff with those values.
15:09:28 <EvanR> yeah there is a form of lambda calculus involved, i remember that when i first saw U-like things
15:10:12 <int-e> I think I better leave it... this is beginning to feel like a bottomless pit, a black hole of confusion :)
15:10:51 <EvanR> back to reality, (A -> Bool) -> Bool :)
15:11:02 * hackage arbor-monad-logger 0.1.1.2 - Simple logging library  https://hackage.haskell.org/package/arbor-monad-logger-0.1.1.2 (arbornetworks)
15:15:01 <lyxia> you can also augment L with a few constructors to do "normalization by evaluation" or similar-sounding kinds of things
15:20:16 <int-e> lyxia: Yeah I know.
15:55:37 <EvanR> do you think that backpack could replace some usages of type classes? For instance, ad hoc overloading of things like +
16:00:02 <pikajude> backpack can replace any typeclass afaik
16:00:08 <EvanR> i guess for that it would sometimes need to pull in multiple implementations of the same interface simultaneously
16:00:16 <pikajude> and you can also replace any typeclass with a datatype that represents the implementation
16:00:40 <EvanR> really...
16:01:15 <pikajude> data Show a = Show { show :: a -> String }
16:01:52 <EvanR> i meant, replace in usage rather than literally substitute in a module
16:02:40 <pikajude> well
16:02:56 <pikajude> still yes
16:03:01 <EvanR> really...
16:03:26 <pikajude> anywhere that a typeclass is used, a backpack (interface?) can be used instead
16:03:28 <pikajude> i forget what they're called
16:03:30 <pikajude> a signature?
16:05:02 <EvanR> sometimes type classes are used in categorical ways, they form a kind of network of law abiding types
16:05:14 <EvanR> i don't expect backpack to pull that stuff off
16:06:41 <EvanR> but when you have stuff like, "which AbstractFooTransportImpl do you want"
16:06:58 <EvanR> that seems like backpacky. Now where do you draw the line
16:08:14 <pikajude> wherever you want
16:08:40 <EvanR> in a new language would you even need type classes then?
16:11:51 <pikajude> just like typeclasses vs datatypes, either could be used based on your preference and usecase
16:11:58 <MarcelineVQ> depends on the support, iiuc agda uses the record approach but has a mechanism to allow automatically searching for them like you do typeclasses instances
16:12:54 <EvanR> this is specifically so you aren't plumbing records around right
16:13:06 <EvanR> but i don't think you're doing that in backpack
16:13:26 <lyxia> If you want to use Set with 14 types, do you need to instantiate the Set interface 14 times
16:15:13 <EvanR> that devolves into asking if Set should carry around an Ord instance or not...
16:15:24 <EvanR> so is Set specific. Do you have another example?
16:16:34 <EvanR> though the way Set currently works is a pretty awesome showcase of type classes
16:16:58 <lyxia> I'm not sure how you would do Set without an Ord constraint one way or another
16:17:28 <lyxia> I was questioning the claim that backpack replaces type classes
16:17:32 <EvanR> ok good
16:17:54 <pikajude> i'm not saying it should
16:18:07 <pikajude> but evan asked if backpack can replace "some uses" of typeclasses
16:18:13 <pikajude> which is true, backpack can replace any use of typeclasses
16:18:26 <EvanR> ok how would it facilitate Set
16:18:29 <lyxia> that's what I'm very skeptical about
16:18:52 <pikajude> Set isn't a typeclass
16:19:06 <EvanR> the interaction of Set and Ord 
16:19:15 <lyxia> Set uses Ord
16:19:20 <lyxia> if you can replace Ord you can replace Set
16:19:23 <pikajude> yeah
16:19:29 <pikajude> you could write a signature for Ord using backpack
16:19:40 <pikajude> @src Ord
16:19:40 <lambdabot> class (Eq a) => Ord a where
16:19:40 <lambdabot>     compare              :: a -> a -> Ordering
16:19:40 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
16:19:40 <lambdabot>     max, min             :: a -> a -> a
16:19:43 <pikajude> you would just need to put those in it
16:20:08 <EvanR> that's one thing, would you spell it all out everytime, or could it be "cloned" / imported / whatever
16:20:09 <lyxia> ok I thought you were making a more outlandish claim.
16:20:20 <pikajude> it could be imported
16:20:35 <pikajude> import OrdInt as I
16:20:38 <pikajude> 3 I.< 4
16:20:39 <pikajude> and so on
16:20:59 <EvanR> ehm... so you couldn't overload the < ?
16:21:06 <pikajude> not without TDNR
16:21:08 <lyxia> "interfaces" is a very limited description of type classes though.
16:21:25 <pikajude> what's something you can do in a typeclass and not backpack?
16:21:41 <EvanR> you could still import 1 Ord instance at a time and use the usual symbols. This is what i was getting at with the + example
16:21:56 <EvanR> but i guess 2 is out of the question
16:22:16 <pikajude> no, i don't believe so
16:22:22 <pikajude> a typeclass would be much better suited to that
16:22:28 <lyxia> you can implement Set once and freely use it with any type with an Ord instance with zero additional boilerplate
16:22:48 <pikajude> well, thing is, with backpack you can also define a Set type that imports the Ord sig
16:23:05 <lyxia> If you have to instantiate a backpack interface for each of Set Int, Set Integer, Set String, etc, you've lost.
16:23:07 <pikajude> and then Set would support whatever type you want if an Ord instance is in scope
16:23:11 <lyxia> My question was whether you can do that
16:23:12 <pikajude> ok
16:23:14 <pikajude> but the question was
16:23:24 <pikajude> ok
16:23:33 <EvanR> i have same question
16:24:05 <pikajude> i wonder if instantiating a backpack instance for each subtype of Set you want would be more performant
16:24:11 <pikajude> since it doesn't have to carry around the Ord dictionary at runtime
16:24:21 <pikajude> i mean, we have IntSet already
16:24:24 <pikajude> lol
16:25:03 <EvanR> kmett also used Set as an example in type classes vs the world
16:25:23 <EvanR> but now we've been talking about Set for 20 minutes
16:25:39 <pikajude> i know head hackage has a backpack signature package for string-y things
16:25:43 <edwardk> pikajude: i have backacked set code around
16:25:47 <pikajude> which sounds neat
16:26:01 <edwardk> http://hackage.haskell.org/package/unpacked-containers
16:26:22 <edwardk> though, now with multiple public libraries in cabal it'd be a lot nicer to refactor that and make little sub-libraries
16:26:52 <pikajude> oh that looks fun
16:27:04 <EvanR> so backpack can improve performance
16:27:11 <EvanR> but there is some boilerplate
16:27:24 <EvanR> type classes cost something but are hella convenient
16:27:31 <pikajude> there you go
16:28:02 <EvanR> like, ridiculously convenient
16:28:12 <EvanR> i feel silly even questioning them
16:28:13 <pikajude> edwardk: so the capacity of Set from that package depends on the bounds of the type you instantiate Key with?
16:29:02 <pikajude> oh no, i'm sorry
16:29:09 <pikajude> i'm an idiot
16:29:13 <edwardk> pikajude: Set there is basically Data.Set with the key type inlined
16:29:33 <pikajude> yeah I had Set backwards in my head, I thought it was map with [() => key] but it's [key => ()]
16:29:35 <edwardk> using the ability i accidentally found to UNPACK through a backpack signature
16:29:35 <EvanR> i was really wondering if one or the other is better at modularity i guess
16:30:03 <EvanR> if you didn't care about boilerplate
16:30:17 <pikajude> i don't actually know what problems backpack is best suited for, sadly
16:30:29 <edwardk> EvanR: backpack is pretty awful for a lot of things. you can't keep any partial implementations around, so its like java interfaces before they added defaults. no default definitions, trying to do things that have lots of conditional members explodes the number of backpacked packages drastically
16:30:36 <edwardk> a fun experiment is trying to write a backpacked MTL
16:30:56 <pikajude> typeclasses without default implementations (or default signatures)
16:30:56 <pikajude> nice
16:31:18 <edwardk> you can write the monad transformers themselves (more or less) by making, say StateT as a module parameterized on the state type it has and on the base monad module.  but now you have a dilemma
16:31:33 <edwardk> i often use things like StateT (MyState s) (ST s)
16:31:45 <edwardk> and i don't have a good way to smuggle those extra parameters in
16:31:59 <edwardk> so you need to come up with some way to pass extra arguments down to each of the modules you need for state, etc.
16:32:37 <EvanR> hmm
16:32:40 <edwardk> then you have an issue of writing the backpack modules for how ask/local lift over StateT, which is _another_ package for each such instance
16:32:47 <edwardk> er another library anyways
16:33:16 <edwardk> so the n^2 in the mtl becomes more O(n^2) sub-libraries
16:33:40 <edwardk> thats assuming you figured out the arg smuggling
16:33:53 <Lycurgus> smuggling
16:33:55 <edwardk> or just cut and pasted the code for a version that also passes some 's'
16:34:26 <edwardk> and then made extra modules for states that just use s as the state, added layers that split the s before passing them down to lower layers...
16:35:06 <edmundnoble> If we had an alternate form of polymorphism closer to C++ templates we could avoid this, I don't like having to use an entirely different way to abstract just to unpack things
16:35:15 <edwardk> and god forbid you need to make a type like StateT (Foo s) (ST s) where Foo s contains a StateT (Foo s) (ST s) action!
16:35:15 <EvanR> ok this sounds like some serious usage of type classes, as highly non trivial computation
16:35:20 <edwardk> because now you can't pass the layering
16:35:33 <edmundnoble> Choosing parametric polymorphism vs a bunch of existentials should be totally orthogonal to performance
16:35:55 <edwardk> edmundnoble: meh. right now i'm writing java to get high performance code ;)
16:36:05 <edwardk> abstraction, what is that?
16:36:06 <edwardk> =P
16:36:25 <edmundnoble> Lmao at least you got out of writing Scala
16:36:40 <edwardk> edmundnoble: not my fault. scala couldn't work for this. =(
16:36:55 <edwardk> i was keen to scala it up until i realized it was causing me pain
16:37:04 <edwardk> more pain than the usual scala pain
16:37:17 <edwardk> i even looked into kotlin for it
16:37:34 <edwardk> neither were appropriate =(
16:38:21 <edmundnoble> And now, *I* write Haskell
16:38:25 <edmundnoble> How the turntables have turned
16:39:11 <edwardk> i'm somewhat keen to try writing part of this in eta, but i have a hard time wanting to replace my 5s build times with 50s build times
16:39:46 <EvanR> so ML modules get a lot of hype, but backpack ...
16:39:55 <EvanR> isn't all that?
16:40:31 <edmundnoble> I like backpack a lot more than ML modules, they just both have usecases I've never encountered, excluding one thing
16:40:53 <edmundnoble> https://github.com/edmundnoble/trees-from-bags
16:41:11 <edwardk> EvanR: backpack is usable. it has a number of scenarios where it is indispensible. but it requires a pretty heavy level of 'programming in cabal' rather than 'programming in haskell' to use, forces you to give up stack, has issues with things like default types in class associated data types, requires you to give up -j in builds...
16:41:36 <edmundnoble> Requires you to give up -j, that I didn't know
16:41:53 <edwardk> The latter two were awkward enough for MIRI that we funded some work to fix, so those patches should merge soon.
16:42:57 <EvanR> ok some of these issues don't seem to be problems with the concept as a whole
16:43:05 <edwardk> they aren't really
16:43:10 <edwardk> it just needs someone to love it
16:43:13 <EvanR> like, couldn't you just add default stuff if you had infinite time and money
16:43:16 <edwardk> ed yang has moved on
16:43:38 <edwardk> i still love backpack for separation of concerns
16:43:50 <edwardk> it lets me make code _way_ more testable
16:44:00 <edwardk> completely independent of the unpack thing
16:44:15 <edwardk> it also lets me avoid picking up 50000 arguments to types for everything i might ever work with it with
16:44:39 <edwardk> both of those have fundamentally changed the way i work
16:45:16 <edwardk> no free monads with some crappy interpretation function, just write the module signature with the ops and mock it up for testing. abstract over what you need from the previous layer rather than the concrete implementation, etc.
16:45:41 <EvanR> that's what i wanna hear
16:45:51 <edwardk> which?
16:45:56 <edwardk> the latter is easy to see in some of the coda code
16:47:07 <EvanR> that sounds like a modularity win
16:47:26 <edwardk> https://github.com/ekmett/coda/blob/master/coda.cabal#L138 lets me write up code that is parameterized over the choice of concrete group to work with. then i instantiate it the next level up. 
16:47:57 <EvanR> but edmundnoble suggests C++ templates would be even better?
16:48:01 <edwardk> there is also code in there for a generalized dyck language monoid that is parameterized over the token type, layout that is parameterized over the parser that produces syntax trees, etc.
16:48:10 <edmundnoble> C++ templates would be nice for the unpacking stuff
16:48:16 <edmundnoble> That's it
16:48:24 <edwardk> c++-style templates give one component of code reuse. for objects. but here its really the _modules_ that are what you want to parameterize
16:48:31 <edmundnoble> Avoiding type param (and regular param) explosion is what modules get you
16:49:02 <edmundnoble> It's orthogonal to unpacking things, as you can see for example in languages with first-class modules, which don't get anything unpacked
16:50:43 <EvanR> my original question was if backpack could well replace certain usages of type classes, but it sounds like the winning situations so far given are stuff type classes could never do
16:50:47 <edmundnoble> One example of this as edk is implying is the problem with multi-param type classes without fundeps
16:51:06 <edmundnoble> I think he is anyway
16:51:35 <edmundnoble> Things which people say "ugh this *ought* to be a type class but it can't because unique instances/coherence/uninferrable"
16:51:37 <EvanR> what is the problem with multi-param type classes without fundeps. That they don't resolve for you?
16:52:14 <edwardk> EvanR: make a class like class Monoid m => MonoidAction m s where act :: m -> s -> s; -- act mempty = id; act (m <> n) = act m . act n
16:52:14 <EvanR> ok
16:52:28 <edmundnoble> Yeah monoid actions in particular, that sort of thing, actions in general
16:52:45 <EvanR> something something associated type
16:53:00 <edwardk> EvanR: now you run into problems. you'd like MonoidAction m m     and MonoidAction (Endo m) m  -- and a bunch of peculiar sets for your particular monoid m, and some sets that might work for all monoids MonoidAction m (), etc.
16:53:08 <edwardk> but those instances conflict
16:53:17 <edwardk> no argument is being 'refined' consistently
16:53:38 <EvanR> man...
16:54:00 <edwardk> the coda relevative example i linked makes a class Relative a where rel :: Delta -> a -> a -- rel plays the role of 'act' above, Delta is 'm', but we're parameterised over a module providing 'm'
16:54:00 <EvanR> type classes never stop with the puzzles :)
16:54:20 <edwardk> now you know 'm' based on the module you imported 'Relative' from
16:54:30 <edwardk> so you aren't relying on crappy inference. no instance conflict, etc.
16:54:47 <edwardk> and the code that is there can know 'm' and UNPACK it
16:54:50 <edwardk> wins all around
16:55:06 <edmundnoble> For an example, `newtype Drop = Drop Int; instance MonoidAction Drop [a] where act (Drop n) = drop n`
16:55:22 <edmundnoble> And a monoid instance `Drop n <> Drop n' = Drop (n + n')`
16:55:34 <edwardk> that monoid action is one i use for parsers a lot
16:56:03 <edmundnoble> There's a monad (transformer) called the update monad (transformer) which is like a writer/state thing parameterized on a monoid action
16:56:08 <edmundnoble> Which is totally hopeless if you don't use backpack
16:56:16 <edmundnoble> (or reflection, lole)
16:56:25 <edwardk> technically you don't even want a _monoid_ for the update monad, but something a little weaker
16:56:35 <edwardk> the unit can depend on 's'
16:56:53 <edwardk> this lets you reconsititute something just the right size
16:57:10 <edwardk> this has some deep connections to directed containers
16:59:57 <EvanR> sounds like in this case we knew exactly what we wanted but the languages of type classes would not do it. And backpack manages to. But would there have been an even better language for it?
17:01:12 <EvanR> maybe i'm at too much coffee stage
17:01:20 <EvanR> i need to check out update monad and the trees that grow paper
17:03:57 <EvanR> modularity wrangling languages
17:07:32 * hackage Yampa 0.13.1 - Elegant Functional Reactive Programming Language for Hybrid Systems  https://hackage.haskell.org/package/Yampa-0.13.1 (IvanPerez)
17:10:02 <koz_> EvanR: How much coffee is too much coffee?
17:16:32 * hackage predicate-transformers 0.4.0.0 - A library for writing predicates and transformations over predicates in Haskell  https://hackage.haskell.org/package/predicate-transformers-0.4.0.0 (edmundnoble)
17:19:18 <EvanR> if you gotta ask you'll never know!
17:28:02 * hackage yampa-test 0.2 - Testing library for Yampa.  https://hackage.haskell.org/package/yampa-test-0.2 (IvanPerez)
18:03:02 * hackage tls 1.5.2 - TLS/SSL protocol native implementation (Server and Client)  https://hackage.haskell.org/package/tls-1.5.2 (KazuYamamoto)
18:07:02 * hackage tls-debug 0.4.8 - Set of programs for TLS testing and debugging  https://hackage.haskell.org/package/tls-debug-0.4.8 (KazuYamamoto)
18:13:10 <arahael> koz_: From personal observations, I'd say 12 and 20 cups a day is far too much.  Much harder to determine an exact figure where "sufficient coffee" becomes "too much coffee", but for me, it's past that point when I have 6 cups. :)
18:13:40 <MarcelineVQ> should really count by grounds ounces :>
18:14:02 <arahael> MarcelineVQ: That only helps if the style of preparation and the beans are consistent.
18:14:22 <arahael> (Eg, I start my day with Turkish coffee).
18:14:54 <arahael> My dad having 12 a day was having "1.5 teaspoons of instant coffee" in each.  And my minister who had 20 a day...  Was using a plunger.
18:23:56 <jle`> huh in my last git commit the first 8 character of the sha were all decimal digits. i wonder if that's a sign
18:24:35 <sm[m]> I think when that happens you get the next day off
18:25:38 <dmwit> > (5/8)**8
18:25:40 <lambdabot>  2.3283064365386963e-2
18:25:51 <dmwit> you get a lot of days off
18:25:56 <dmwit> or you don't make commits very frequently
18:27:25 <MarcelineVQ> jle`: It's the end times.
18:29:01 <arahael> jle`: Have a coffee.
18:34:46 <dmwit> groupByKey f vs = M.fromListWith (++) [(f v, [v]) | v <- vs] -- useful surprisingly often
18:36:06 <shapr> For testing my research paper annotation tool, I need a friend to fork this repo: https://github.com/shapr/flmdata (please tell me your github username if I'm not already following you)
18:36:34 <siraben> Is it possible to write the function with the following spec recursively? (\y -> any (\x -> x == reverse x) (permutations y))
18:36:43 <siraben> (given a list of things, return True if any permutation of it is a palindrome)
18:36:55 <siraben> Imperative solutions often need some sort of hashmap or set to keep track of occurrences of characters.
18:36:56 <jackdk> I kinda wish the default Monoid instance for map was instance (Semigroup a, Ord k) => Monoid (Map k a)
18:40:44 <jle`> jackdk: the struggle :'(
18:41:04 <jle`> jackdk: i sometimes make a throwaway newtype wrapper just for it
18:41:21 <jle`> there's a package on hackage that provides a newtype wrapper but it pulls in lens as a dep for some reason
18:41:32 <jle`> dmwit: thanks for making me feel less special
18:41:50 <jle`> i guess i'll save my day off for the 9 digit one
18:44:07 <jle`> jackdk: it's especially annoying because the 'keep the first' instance could be easily recovered by wrapping the values in FIrst
18:44:19 <Nevoic9> Does anyone here know why this type of function wouldn't be possible to construct in idris? `f : Vect n a -> (m : Nat) -> {auto p: m * 2 < n = True} -> (a,a)`
18:44:36 <jackdk> jle`: monoidal-containers wants lens because it wants to provide FooWithIndex instances for the newtypes, and they can't leave lens for ed-flavoured performance reasons (there are a few closed issues about this)
18:49:46 <jackdk> jle`: found: https://github.com/ekmett/lens/issues/258
18:53:29 <dmwit> jle`: =(
18:53:43 <dmwit> jle`: I can make you feel even less special if you want...
19:00:06 <jusss> dmwit: getLine is not a function, it's a IO action, right?
19:00:07 <dmwit> siraben: `import qualified Data.MultiSet as MS; null . drop 1 . filter ((>1).snd) . MS.toOccurList . MS.fromList`
19:00:10 <jusss> % :t getLine
19:00:11 <yahb> jusss: IO String
19:00:14 <dmwit> jusss: Right.
19:00:35 <dmwit> siraben: Sorry, should be `odd.snd`, not `(>1).snd`.
19:01:02 <jusss> dmwit: can I think action are some operations which may have side-effect?
19:01:09 <dmwit> Sure.
19:01:24 * ski . o O ( s/side-effects/effects/ )
19:01:47 <jusss> ski: functions have effects too
19:01:59 <ski> you might think of an action as "list of instructions", or a "recipe"
19:02:09 <ski> jusss : not in this sense
19:03:03 <jusss> ski: wait a sec, what are monad actions? it means that may have side effects?
19:03:11 <jusss> or monadic actions?
19:03:28 <ski> remove "side"
19:03:40 <jusss> those terms I saw them a lot, when I learned Monad, but I never understood them
19:03:52 <ski> they're not happening on the side. it's an explicit part of the value (the monadic action)
19:04:16 <jusss> ski: why ? you don't think funtions have effects? or what you call them?
19:04:20 <ski> it's not `openFile :: FilePath -> IOMode -> Handle', it's `openFile :: FilePath -> IOMode -> IO Handle'
19:04:48 <ski> the `IO' is an explicit part of the result. the I/O is not happening "on the side"
19:05:18 <ski> @type lookup
19:05:19 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
19:05:20 <jusss> ski: sorry, I don't get the term of "on the side", it's a metaphor ? or just literally?
19:06:02 <ski> same thing there, the `Maybe'-effects aren't happening on the side (no exceptions (possibly) implicitly being thrown). failure (`Nothing') is an explicit result
19:07:38 <jusss> ski: and what's happening on the side?
19:08:12 <ski> when calling `FILE *fopen(const char *path, const char *mode);' in C, like `fopen("/path/to/file","r")', that is an expression of type `FILE *'. the I/O that is happening as a result of the call is not explicitly declared in the result type
19:08:29 <ski> in Haskell, nothing is happening on the side. no side-effects in Haskell
19:08:55 <jusss> ski: waht?
19:09:17 <jusss> ski: "no side-effects in Haskell" ? then how print somthing, visit files?
19:09:31 <ski> those are effects, not side-effects, in Haskell
19:09:33 <ski> @type print
19:09:35 <lambdabot> Show a => a -> IO ()
19:09:50 <dmwit> I don't think I've ever heard this distinction made before, but I like it a lot.
19:09:58 <ski> the I/O is part of the result, is explicitly declared in the result type
19:10:12 <jusss> ski: then functions does have effects?
19:10:16 <ski> no
19:10:22 <jusss> ski: aha!
19:10:28 <ski> calling `print' doesn't cause any I/O to happen
19:10:51 <ski> *executing* the resulting I/O-action, causes the I/O to happen
19:11:19 <ski> the only way to cause I/O to happen, is by making the `IO'-action part of `main' (or by entering it into the interactor)
19:11:54 <ski> just calling `print' will "compute what to do", but won't actually do it
19:12:25 <ski> evaluating expressions (which includes calling functions) can't cause I/O to happen. can't cause `IO'-actions to be executed
19:12:52 <jusss> ski: then what will cause IO actions to be executed?
19:13:10 <jusss> ski: put them to `main'?
19:13:20 <ski> (however, to execute an `IO'-action, one must determine what I/O-operations to perform. iow, one must first evaluate the action. in practice, these two "phases", execution and evaluation of an `IO'-action, are interleaved)
19:13:24 <ski> yes
19:14:16 <ski> also, note that it doesn't matter that "it all mutates memory locations, and probably does memory-mapped I/O, or else some I/O machine instructions"
19:14:38 <ski> (or that it executes C code, when GHC used to compile via C)
19:15:08 <ski> whether something has side-effects, or merely effects, is a matter of perspective, of which language one's looking from
19:15:28 <jusss> ski: if we put IO actions into functions, and put functions to `main', this IO actions will be executed?
19:15:39 <jusss> % :t putStrLn
19:15:39 <yahb> jusss: String -> IO ()
19:15:51 <ski> it's about what reasoning laws one can apply, at the level of the language. how it is implemented is irrelevant
19:16:04 <jusss> like you see putStrLn is a function, which has an IO action as the result
19:16:13 <ski> if you write
19:16:22 <ski>   main = putStrLn =<< getline
19:17:34 <ski> then this will (evaluate and) execute `getLine', and the resulting monadic result (a `String', call it `s') will be passed to `putStrLn' (calling `putStrLn', like `putStrLn s', call the resulting action `p'), then that action `p' will be executed
19:18:12 <ski> so, depending on the run-time result of executing `getLine', we'll perform/execute *different* actions (returned by `putStrLn') next
19:18:46 <jusss> ski: actions can be executed, and actions have effects, functions can be evaluated, and functions don't have effects, that's right?
19:19:01 <ski> dmwit : hm, i would have assumed you'd heard this story before, given that you've been here some time (can't recall how long ..)
19:19:17 <ski> functions are called
19:19:23 <ski> expressions are evaluated
19:19:31 <ski> an expression can be a function call/application
19:19:40 <jusss> ski: wow,
19:19:49 <ski> yes "functions don't have effects"
19:20:44 <ski> however, as a shorthand, we commonly say "invoke `openFile'", when we mean "call `openFile', and execute the resulting action"
19:20:54 <jusss> ski: then what's the different between functions and expressions, also function calls and function applications?
19:21:05 <ski> (and, sometimes people say "call `openFile'" when they mean this)
19:21:17 <crestfallen> https://termbin.com/e5rom hi I don't understand the textbook passage in this paste. what does it mean by "intermediate results?" thanks
19:21:21 <ski> `2' is an expression. so is `x'
19:21:26 <ski> neither of those are function calls
19:21:39 <ski> `let x = 2 in max x y' is not a function call
19:21:42 <MarcelineVQ> Nevoic9: There's soo much going on with the == and multiplying Nat for idris to cut through things, recomend you use a predicate type to make things direct. f : Vect n a -> (m : Nat) -> (p : m * 2 `LT` n) -> (a,a)
19:21:58 <crestfallen> the output is identical
19:22:05 <dmwit> ski: evaluate/execute I've seen many times. side-effect/effect I've never seen.
19:22:10 <ski> the output of what is identical to what ?
19:22:23 <MarcelineVQ> Nevoic9: Now you can case on p to inform the shape of vect
19:22:35 <ski> dmwit : i drew out the lines of this story, years ago
19:22:53 <crestfallen> ski those two functions yield identical outputs with identical arguments
19:23:37 <ski> crestfallen : oh, okay
19:23:59 <ski> crestfallen : hm. i suspect they mean `x' and `y'
19:24:57 <jusss> ski: then expressions can be executed, expressions don't have effects, expressions can be function calls, 
19:25:06 <jusss> ski: what's function application?
19:25:21 <crestfallen> ski I see, I wonder why author calls x and y intermediate results, but there is some sense in it
19:25:30 <jusss> this term I saw it a lot, but I don't get it
19:25:45 <crestfallen> thanks
19:25:48 <MarcelineVQ> Nevoic9: in other words it's possible to construct but there's a bit of indirection due to Ord's definitions and the fact that m * 2 < n = True doesn't directly say anything about the Nats despite how it looks, it's more of a proof about Bool's, so idris doesn't learn/infer much due to it. A predicate type like LTE (using LT in this case) proves things about the Nats it involves which makes this much more direct.
19:26:11 <ski> jusss : expressions are syntactic things (things in the program text). functions are really semantic things (things when the program is running). however one can talk about expressions which will evaluate to functions, and often also just call those "functions" as well
19:27:02 <ski> jusss : `f x' is function application. `f' is a function expression (an expression evaluating to a function), `x' is another expression whose value will be passed to the function
19:27:58 <ski> jusss : "function application" is more or less synonymous to "function call". by the former, we typically mean the thing in the program text. by the latter, we often also mean how it behaves, when the program is running
19:28:30 <jusss> ski: but `f' and `f x' both are expressions? 
19:28:31 <ski> crestfallen : you can think of "executing a list action" as "selecting an element from the list", which is what `x <- xs' and `y <- ys' do
19:28:36 <ski> jusss : yes
19:29:01 <ski> crestfallen : you could also write `do x <- xs; y <- ys; return (x * y)'
19:29:29 <ski> crestfallen : now, if `xs' and `ys' weren't lists, but `IO'-actions, then you'd have no qualms about calling `x' and `y' intermediate results, right ?
19:30:12 <ski> jusss : `max x (min y z)' is also a function application. applying `max x' to `min y z'
19:30:23 <ski> (`f x' is applying `f' to `x')
19:31:51 <jusss> ski: function expressions and function calls are expressions, expressions can be evaluated to functions, and functions don't have effects, actions can be executed, actions have effects, this is right?
19:32:24 <ski> "expressions can be evaluated to functions" -- in case they have function types, yes
19:32:53 <ski> by "function expressions" i basically means "expressions of function types"
19:33:09 <ski> jusss : yes
19:33:55 <ski> also, the only way to cause `IO'-actions to execute, is by making them part of `main' (or entering them into the interactor)
19:34:29 <ski> however, you can e.g. execute `Maybe'-actions, without needing to do anything like that
19:35:36 <jusss> ski: expressions like `2', function expressions like `f', function applications like `f 2', they all are expressions, but only function expressions and function applications can be evaluated to functions, this is ok?
19:35:58 <ski> you can write `let act = do k1 <- lookup k0 env0; v <- lookup k1 env1; guard (pred v); return (frob v) in case act of Nothing -> ...; Just w -> ..w..'
19:36:21 <ski> here, one could argue the `case act of ...' causes the execution of the `Maybe'-action `act'
19:37:27 <ski> jusss : "function applications can be evaluated to functions" sounds confused. a function application does not evaluate to a function, unless the function being applies is a function whose result will also be a function (e.g. if the function is defined in "curried style")
19:38:15 <crestfallen> ski thanks sorry reading back to your comments
19:38:15 <ski> the function application `not False' will not evaluate to a function (however, in order to evaluate that application, we first need to evaluate the function expression `not', getting back the function value)
19:39:00 <ski> otoh, `delete "b"' is a function expression which will evaluate to a function
19:39:04 <ski> @type delete
19:39:05 <lambdabot> Eq a => a -> [a] -> [a]
19:39:15 <jusss> ski: about the monad Maybe action, I still have a little confused
19:39:37 <jusss> ski: it's an action, so it has an effect
19:39:46 <ski> > let f = delete "b" in map f [["a","b"],["b","cde"],["c","de","f"]]
19:39:48 <lambdabot>  [["a"],["cde"],["c","de","f"]]
19:39:49 <crestfallen> ski copy that, thanks!
19:40:36 <ski> jusss : yes. the effect in that case is "possible failure to compute a monadic result"
19:41:10 <ski> jusss : very roughly (and vaguely) speaking, an "effect" is "any deviation from computing a single result, nothing else"
19:41:34 <ski> jusss : `Maybe' allows expressing "possibly no result at all"-effects
19:41:58 <jusss> ski: which means all the monad actions have their own effects?
19:42:25 <ski> jusss : `Either e' also allows expressing failure like this, except that instead of just having a single ("anonymous") kind of failure, you have failures labelled with values of type `e' ("exceptions")
19:42:30 <ski> jusss : yes
19:42:38 <jusss> ski: and `IO'?
19:42:55 <ski> jusss : `[]' allows expresssing "possibly no result at all, and possibly more than one result"-effects
19:43:36 <ski> jusss : `return x' (equal to `pure x') always gives an action which actually performs no effects at all. or, if you prefer, only performs the "trivial effect", the "no-op effect"
19:43:47 <jusss> ski: next time I meet a monad, I should ask what its effect is first
19:44:37 <jusss> % :t return
19:44:37 <yahb> jusss: Monad m => a -> m a
19:45:05 <jusss> ski: this m a is an action, right?
19:45:43 <ski> jusss : `IO' is (primarily) for doing Input/Output interaction, with the outside world (from the POV of the Haskell process). however, `IO' tends to be used as a sin-bin, so it also allows expressing local mutable state, and multiple threads of execution (whose synchronization is indeterministic)
19:46:05 <ski> jusss : no, the *value* of type `m a' is an `m'-action. `m a' itself is the *type* of that action
19:46:21 <ski> (that may be what you meant. but you didn't say it)
19:46:56 <maerwald> ski: what do you mean with sin-bin?
19:47:18 * ski thinks it can help to be an extra bit pedantic, about terminology, when concepts are a bit unclear
19:47:50 <ski> maerwald : a potpourri of different effects, all mixed together in the same monad
19:48:08 <jusss> ski: m a is the type of m-action, right?
19:48:28 <maerwald> ski: well, that is exactly what it is for
19:48:47 <maerwald> since there is no sensible way to separate that multitude of effects
19:49:51 <maerwald> most monad stacks have MonadIO somewhere inside, which blows up the entire purpose
19:50:28 <ski> well, depends
19:51:06 <ski> some parts might be like `frob :: Monad m => ... -> T m X'
19:52:46 <ski> jusss : an `m'-action is a value of type `m a', for some type `a', yes. where `m' is a monad, or an idiom (or maybe sometimes only a functor, but i think it's more common to not say "action" then. sometimes "collection" feels like an appropriate word. can also often be used in the monad and idiom cases)
19:54:05 <maerwald> until we have a *proper* effects system, I believe IO is the right choice for anything that has any intersection with real IO
19:54:37 <arahael> I thought we had one available? (But not in common use) - something similar to what's done in PureScript?
19:55:12 <ski> i have used multi-level continuation stack, over `IO' (or `ST s', if preferred)
19:55:24 <heatsink> Disciple was an experimental haskell dialect with effects
19:55:30 <ski> (the depth of the stack being determined at run-time)
19:55:31 <arahael> Something like https://hackage.haskell.org/package/freer-effects
19:55:48 <maerwald> arahael: yeah, freer is nice, but also very leaky
19:56:04 <maerwald> but, we have 3+ implementations of it
19:56:08 <maerwald> and none of them are really used
19:56:16 <arahael> Leaky?  Blegh. :(
19:56:24 <maerwald> leaky in terms of API/Types
19:56:35 <maerwald> if you don't understand the implementation, you'll likely not understand the error messages
19:57:22 <maerwald> mtl isn't that bad when it comes to errors
19:57:49 <maerwald> but then you can't even have two readers...
19:57:51 <ski> dmwit : comment/opinion on the side- / effect story ?
19:58:39 <jusss> ski: where is your story online?
19:58:51 <ski> on logs of this channel
19:59:23 <maerwald> In the end, I'm disappointed by all attempts. Either they are too complicated, leak implementation details or are too weak. So I embrace IO and write atomic functions.
19:59:24 * ski might have gone through it at least a dozen times
20:00:02 <maerwald> ski: have you used freer/e-e in a project?
20:00:09 <ski> i haven't
20:00:13 <arahael> maerwald: Blegh. :(  I kind of like it with purescript, but I didn't stick with them for long.  What about manually implementing free monads? (Feels like too much work, though)
20:00:15 <maerwald> I've only messed with it, but since the ecosystem coverage is non-existent
20:00:21 <maerwald> how to even try properly
20:00:24 <ski> remind me, can it express composable continuation effects ?
20:00:36 <maerwald> dunno
20:00:50 * ski str many such attempts failing at that
20:01:47 <ski> sometimes i'd want an ordered logic of monad class (like `MonadReader',&c.) constraints. also named (so we could scrap the FDs ..)
20:01:57 <MarcelineVQ> maerwald: any opinion on polysemy?
20:01:58 <maerwald> arahael: I've always dreamed about effects outside of the type system. Yes, I think effects are misplaced on type level (I don't care how it's *implemented*, that may very well abuse the type system)
20:02:16 <ski> well, ordered as default. but where some constraints are known to commute with each other
20:02:22 <maerwald> MarcelineVQ: haven't messed with it, is it worth it?
20:02:46 <arahael> maerwald: Interesting notion - why don't you think it should be in the type system?
20:02:46 <MarcelineVQ> No clue but I've not really used effect systems so I'm askin ye :>
20:03:13 <maerwald> arahael: The same way as exceptions shouldn't
20:03:14 <ski> maerwald : it would be interesting with an implementation based on composable continuations, along the lines of Andrzej Filinski's monadic reflection
20:03:35 <maerwald> arahael: yet, there is static knowledge about them (e.g. in java)
20:04:07 <arahael> maerwald: I'm still making my mind up with exceptions.  I actually think they make perfect sense in Haskell - have them exposed by the monad (eg, as IO exceptions are), or have them handled explicitly - whatever is appropriate to the situation.
20:04:51 <ski> maerwald : in Clean, uniqueness is expressed in types. in Mercury, uniqueness is expressed in "insts" (instantiation states), and "modes" (which includes insts). perhaps one could have a story along similar lines, for effects
20:05:21 <ski> arahael : "handled explicitly" being ? like `Either e' ?
20:05:35 <maerwald> arahael: effects shouldn't enclose values, both are separate, that makes it also easier to refactor APIs without losing any guarantees
20:05:54 <ski> (insts and modes are separate from (but connected to) types)
20:06:06 <arahael> ski: Depends on what you think of as an exception.
20:06:38 <arahael> maerwald: So, in a similar way to say, ReactiveX's separation of values and errors?
20:06:41 <maerwald> arahael: the reason why enclose values in effects is because Monads make it so easy to express this relationship
20:07:11 <maerwald> I don't think anyone stopped there for a second and thought "wait, should we really do this?", because all alternatives need a new language
20:07:11 <ski> well, i think of `Either e' as expressing exceptions. also, i don't believe in "exceptions are for exceptional situations" (what even does "exceptional situations" mean ?) .. however, i was wondering what you had in mind
20:07:49 <maerwald> arahael: yeah, errors should never be values, in a way, you could argue
20:07:52 <ski> (i have no qualms about using exceptions to express the "normal exit path")
20:08:19 <arahael> ski: I think where the "exception" is an ordinary state, eg, a lost connection when dealing with an http layer, it can make sense to have it sent out through as via an IO exception, but if you're using it as a REST interface, maybe it makes more sense to have it sent out via Either's.
20:08:34 <maerwald> arahael: because it isn't really a value, it's an error, lol
20:09:04 <maerwald> that it's represented by the compiler/runtime as a value or whatever should be a hidden implementation detail
20:09:47 <ski> arahael : semi-related, i'd like to see more experimentation with something like "restarts" in the condition systems of several Lisps
20:10:04 <arahael> maerwald: Lets suppose we assume that exceptions always represent actual errors (rather than "not on the happy path...")
20:10:15 <arahael> ski: That reminds me of STM concepts.
20:11:27 <ski> signalling a condition doesn't (necessarily) abort the context that signals it. it (tail-)calls the handler. if the handler can fix the situation, then the signalling context can be resumed
20:11:40 <arahael> maerwald: Anyway, lets suppose we assume that, then it probably makes sense to make exceptions easy to log and handle, and indeed, as ski suggested, to possibly restart the operation if it makes sense, or to defer it until the situation allows it to be sensibly re-run.
20:12:38 <ski> (also, in an interactive system, as a last resort, the handler can ask the programmer what to do, as an oracle, and the programmer can inspect the context, to determine what to do)
20:12:38 <maerwald> arahael: absolutely. I think the line is very blurry for programmers. I'm currently dealing with functions that 1. may return (Right Nothing), because there's nothing in the database, 2. may return a (Left Text)
20:12:38 <maerwald> 3. may throw via MonadError, which is used in the middleware to return 500 status 4. may call error in some places where I'm unlucky, 5. may throw a proper io error, because there's MonadIO somewhere
20:12:40 <arahael> ski: Yeah.  Eg, in the case of a REST call, perhaps the handler can figure out the wifi connectivity or indicate when wifi has re-connected.
20:12:48 <maerwald> It's impossible to reasonably deal with this complexity
20:13:01 <maerwald> because you can't even see half of what might go wrong
20:13:28 <arahael> maerwald: Yeah, that's ugly. :(  In an OOP language, I'd be inclined to re-throw that as a more orderly exception, but even re-throwing a wrapped exception has big problems. :(
20:13:50 <maerwald> When you see "m (Either T.Text (Maybe Int))" you might think everything is handled, right?
20:13:53 <maerwald> But it's a lie
20:14:35 <ski> <https://mumble.net/~campbell/proposals/restart.text>,<http://www.gnu.org/software/mit-scheme/documentation/mit-scheme-ref/Restarts.html>,<https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node344.html>,<http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html>,<https://lisper.in/restarts>,<http://www.nhplace.com/kent/Papers/Condition-Handling-2001.html>
20:14:37 <maerwald> and all those failures (except the inner maybe) should not be types
20:15:57 <ski> (note that the "restart" i was mentioning doesn't necessarily have much to do with the `retry' in `STM')
20:16:30 <arahael> maerwald: I made that mistake when using Wreq.   It threw Http exceptions, despite giving every indication that it would do otherwise.
20:17:22 <arahael> maerwald: I'm not actually sure if exceptions should be a sum type - or a type class.
20:18:10 <maerwald> arahael: yeah and now imagine you do non-atomic operations on a "database". You have to 1. force evaluation of every result and function you call (pure or not), 2. catch io errors (without catching async ones), 3. catch monaderror throws, so the handler doesn't short-circuit, 4 ...
20:18:38 <maerwald> because if anything short-circuits unexpectedly, good luck
20:18:48 * masaeedu[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/uIUnLrurKiEWTOGjVYKsxpmj >
20:18:51 <ski> (then there's also another issue re exceptions. that there ought to be an efficient operation `catchBind :: Exception e => IO a -> (e -> IO b) -> (a -> IO b) -> IO b'. see paper "exceptional syntax" by Nick Benton and someone else)
20:19:08 <masaeedu[m]> (the NB is there in the source, not mine)
20:19:54 <arahael> maerwald: Yes, it's a mess. :(
20:20:20 <masaeedu[m]> `MonadZero` is basically `MonadPlus`, you can imagine it to be `type MonadPlus f = (Monad f, Alternative f)`, plus some laws ensuring their compatibility
20:22:33 <masaeedu[m]> edwardk: Being the resident expert on both profunctors and optics, I was wondering if you'd have any insight. I've been trying to get this PR in for a week
20:24:52 <maerwald> arahael: absolutely. This is the difference between an expressive language and a declarative one ;P
20:24:59 <maerwald> declarative is really really hard
20:25:16 <masaeedu[m]> the high level idea is that for profunctorial computations that have an instance of `Cochoice`, we can use a prism backwards to "demote" a computation like `p (Either Int c) (Either String c)` to `p Int String`, with the arrow itself absorbing a failure to match. For `Star`, it therefore makes sense for the `Cochoice` instance to utilize an `MonadPlus` constraint on the `f`
20:26:11 <shachaf> MonadZero (or anything Monad) seems kind of suspicious to me here.
20:26:36 <arahael> maerwald: I'm nto entirley sure I agree.  Using Swift these days, it's similarly awful. :)
20:28:02 * hackage aeson-yaml 1.0.1.0 - Output any Aeson value as YAML (pure Haskell library)  https://hackage.haskell.org/package/aeson-yaml-1.0.1.0 (patrick)
20:29:09 <masaeedu[m]> shachaf: The task we have to accomplish is `(Either a c -> f (Either b c)) -> a -> f b`.  we can feed the `Either a c` a `Left a` fairly straightforwardly, but what comes out is in an `f` context, and we necessarily need to refer to what's inside (i.e. the `Either b c` inside the `f`) to decide what to do next.
20:29:17 <masaeedu[m]> so in that sense i don't see how we can escape the monad
20:30:14 <shachaf> I don't think f is normally a monad in the first place, and thinking of it as one will often take you to awkward places.
20:30:35 <masaeedu[m]> it is very frequently a monad
20:30:50 <shachaf> At least, this is often the case for these optics things. I don't know what you're doing in this case.
20:31:27 <masaeedu[m]> although usually when it's a monad the differently named but equivalent newtype `Kleisli` is used
20:31:40 <masaeedu[m]> i am using it for these optics things
20:31:41 <shachaf> Kleisli is a different newtype because it has a different meaning.
20:31:54 <masaeedu[m]> in particular for a `Star` in `WriterT`, which is useful for modeling biparsers
20:33:13 <dmwit> ski: I love it. It makes the comment "functions don't have side effects" -> "functions don't have effects" much more defensible.
20:33:23 <masaeedu[m]> they're both `a -> f b`. i'm not sure the category theory cares what we call it
20:33:38 <dmwit> ski: With "functions don't have side effects", you have to waffle about "well, unless the return type says so...".
20:33:45 <masaeedu[m]> if it happens to have a monad available for `f`, they'll behave the same
20:37:53 <ski> dmwit : i think the POV also helps
20:38:34 <shachaf> I don't think monad actions are a very useful way to think about Star's functor argument, even if it does happen to be a monad.
20:38:46 <shachaf> Certainly you want to support non-monads like (e,).
20:39:02 <masaeedu[m]> maybe i'm missing some significance to the name "star"
20:39:22 <masaeedu[m]> would you happen to know what it means?
20:39:22 <shachaf> And these things (optics in general) do composition differently from monads.
20:40:01 <masaeedu[m]> you can certainly support non-monads. in this case optics are totally unaware of the existence of  `Star` at all
20:40:29 <masaeedu[m]> the optics themselves are polymorphic in profunctors that additionally happen to be tambara modules with respect to various monoidal tensors
20:41:09 <shachaf> The names come from http://blog.sigfpe.com/2011/07/profunctors-in-haskell.html
20:41:31 <shachaf> Which comes from the notation F^* and F_*
20:42:45 <masaeedu[m]> we're just trying to prove that `Star` has this backwards `p (Either a c) (Either b c) -> p a b` strength, so that prisms (whose machinery for composition etc., like that of any other optic, is totally agnostic of any specific concrete profunctor) can be used to adjust computations in `Star`
20:43:20 <masaeedu[m]> thanks, i'll take a look
20:44:09 <shachaf> Sure, but the questions are in which cases it has this thing, and whether this implementation is the one you'd want.
20:44:59 <shachaf> I guess you can list some concrete fs that you say should and shouldn't have Cochoice, and how it should behave for the ones that should.
20:45:20 <shachaf> But offhand I'm pretty suspicious of any Monad constraint.
20:45:57 <masaeedu[m]> fair enough. so i'll claim that `Star (ExceptT m)` should have a cochoice constraint
20:46:45 <shachaf> (I'm also pretty skeptical of uses of monad transformers here in the first place.)
20:47:05 <masaeedu[m]> `Star Maybe` then
20:47:23 <shachaf> (Maybe you just want Kleisli? I'm not sure exactly about Kleisli as a profunctor but the Monad would be more plausible at least.)
20:47:33 <masaeedu[m]> the monad transformers in the application domain are well motivated, they're pulled straight from a paper
20:48:04 <masaeedu[m]> i don't really get what the difference would be. i'm writing a new instance here, whether i call it kleisli or star when i'm defining seems immaterial to me
20:48:11 <masaeedu[m]> but sure, let's call it `Kleisli Maybe`
20:49:55 <masaeedu[m]> anyway the idea is that in the abstract, we can use optics that rely on a `X` strength "backwards" when the profunctor supports the dual strength
20:50:08 <masaeedu[m]> without figuring out what the profunctor is exactly
20:51:47 <masaeedu[m]> it turns out that in practice a bunch of bidirectional programming with partial computations like `Star Maybe` degenerates to using a prism to figure out whether you're in some correct case and if so, proceeding along some lines, and otherwise failing the computation
20:52:22 <masaeedu[m]> when you witness this as a `Cochoice` instance on `Star Maybe` directly, the manual wangling of prisms that you have to do just turns into composition of optics
20:52:40 <masaeedu[m]> a failure to match gets absorbed into the `Star Maybe` arrow, as you would expect it to
20:53:16 <masaeedu[m]> sorry, `Kleisli Maybe`
20:53:42 <shachaf> I'm not sure Kleisli is much better here. :-)
20:54:04 <masaeedu[m]> uh oh. what's wrong with `Kleisli` then?
20:54:19 <shachaf> That it doesn't fit very well with optics things.
20:54:26 <shachaf> Let me see. With regular prisms, I think the simplest way to express failure is a Pointed constraint.
20:54:32 <masaeedu[m]> is there a more formal way to say this?
20:55:16 <shachaf> If you have (g a -> f b) -> g s -> f t-style optics, you can express Lens with (Copointed g, Strong f) and Prism with (Costrong g, Pointed f)
20:55:37 <masaeedu[m]> i've never seen this style of optics
20:55:58 <masaeedu[m]> just so we're on the same page, the style of optics I'm working with is `type Optic c a b s t = forall p. c p => p a b -> p s t`
20:56:28 <masaeedu[m]> the underlying theory is from this paper: https://arxiv.org/abs/1809.00738
20:56:35 <shachaf> Yes, I know.
20:56:39 <masaeedu[m]> and more recently: https://arxiv.org/abs/1809.00738
20:56:46 <masaeedu[m]> whoops, sorry: http://events.cs.bham.ac.uk/syco/strings3-syco5/slides/roman.pdf
20:56:52 <shachaf> I invented this style of optics!
20:57:01 <masaeedu[m]> üò≤
20:57:36 <shachaf> (I mean, I proposed a simple version originally, and then figured it out with other people.)
20:58:35 <masaeedu[m]> well, glad i found you then
20:59:17 <masaeedu[m]> i'm afraid i'm still not quite following your objection concerning Kleisli/Star
20:59:31 <shachaf> But that was forever ago, it's all paged out by now.
21:00:14 <masaeedu[m]> aren't optics entirely unconcerned with any of the underlying "implementation details" of the Tambara module they're dispatching to?
21:01:00 <masaeedu[m]> are there any laws for Pointed btw?
21:01:41 <jackdk> I think that's one of the objections to having a Pointed clas
21:04:02 * hackage interpolatedstring-perl6 1.0.2 - QuasiQuoter for Perl6-style multi-line interpolated strings  https://hackage.haskell.org/package/interpolatedstring-perl6-1.0.2 (AudreyTang)
21:06:35 <shachaf> Not any meaningful laws for Pointed.
21:07:17 <shachaf> (I mean, beyond what you get from the types and parametricity.)
21:09:04 <mniip> hmm
21:09:11 <mniip> cabal/haddock troubles
21:12:02 <masaeedu[m]> given that there aren't any laws for the `point :: f x -> x`, does that definition degenerate to `type Prism s t a b = forall g. Costrong g => (g a -> b) -> g s -> t`?
21:13:03 <shachaf> point :: a -> f a
21:13:14 <masaeedu[m]> ah, so that's copoint
21:13:34 <shachaf> Yes.
21:14:26 <shachaf> You also have Iso in this representation, where Iso s t a b = forall f g. (Functor g, Functor f) => (g a -> f b) -> g s -> f t
21:14:47 <masaeedu[m]> is there a name for this representation?
21:15:03 <shachaf> We called it "symmetric lenses" back in the day.
21:15:08 <masaeedu[m]> i've seen the `(a -> f b) -> s -> f t` representation, but i've never seen one with a `g` around the contravariant position
21:15:21 <shachaf> But I think that conflicts with another name.
21:15:35 <mniip> how do I include braces in the description field in cabal
21:15:55 <shachaf> (a -> f b) -> s -> f t doesn't let you express Prism, Iso, etc.
21:16:40 <shachaf> p x y is more general than (g x -> f y) and supports the same covariant and contravariant mapping (and can also be hacked to be compatible with traverse etc.), so it's probably a better representation in general.
21:16:49 <shachaf> But I like this one.
21:17:12 <jusss> what is the higer-kind type?
21:17:55 <shachaf> Say I'm implementing "forall f g. (Functor g, Functor f) => (g a -> f b) -> g s -> f t". You give me a "g s", and I have to give you "f t". The only way to produce fs is with the function, so I have to produce "g a" to use your function.
21:18:50 <shachaf> So I have to fmap (? : s -> a) to get "g a". Then I can use the function to get "f b". But I want to return "f t", so I have to map (? : b -> t) over it.
21:19:05 <shachaf> So a thing of that type must have (s -> a) and (b -> t).
21:19:31 <sarahzrf> jusss: a type with a function kind, usually
21:21:26 <mniip> phadej, I think I found an edge case of https://github.com/haskell/cabal/issues/774 , should I reopen?
21:21:36 <shachaf> Then you can add constraints to give it more powers, like (Strong f, Copointed g) for lenses.
21:25:31 * hackage partial-records 0.1.0.0 - Template haskell utilities for constructing records withdefault values  https://hackage.haskell.org/package/partial-records-0.1.0.0 (mniip)
21:26:11 <jusss> ok
21:26:16 <masaeedu[m]> shachaf: I think a similar story emerges when all you have to work with is compositions of dimappings
21:26:24 <masaeedu[m]> and the profunctor strengths
21:26:47 <shachaf> Yep, the profunctor thing is a simplification.
21:27:58 <soda> hi
21:28:02 <soda> are there any ACTIVE channels regarding security? most are filled with lurkers only
21:28:47 <shachaf> This channel is not about security and also not about channels that are about security.
21:28:55 <soda> shachaf: ok
21:29:08 <soda> what is your recommendation?
21:29:17 <shachaf> You can try /query alis to search channels.
21:29:30 <soda> i did, but im still in the same situation
21:29:35 <soda> thx tho
21:30:46 <hololeap> can someone explain to me how this works? how do BoxId and (PrimaryKey BoxT f) have interdependent definitions? http://dpaste.com/22T8K3N
21:31:01 * hackage hledger-flow 0.12.4.0 - An hledger workflow focusing on automated statement import and classification.  https://hackage.haskell.org/package/hledger-flow-0.12.4.0 (apauley)
21:31:03 * hackage manifold-random 0.5.0.4, manifolds 0.5.0.4, linearmap-category 0.4.0.0, manifolds-core 0.5.0.4, pragmatic-show 0.1.2.1 (leftaroundabout)
21:31:05 * hackage schemas 0.2.0.3 - schema guided serialization  https://hackage.haskell.org/package/schemas-0.2.0.3 (PepeIborra)
21:31:07 * hackage secp256k1-legacy 0.5.6 - fork of secp256k1  https://hackage.haskell.org/package/secp256k1-legacy-0.5.6 (fommil)
21:31:10 * hackage interpolatedstring-perl6 1.0.2 - QuasiQuoter for Perl6-style multi-line interpolated strings  https://hackage.haskell.org/package/interpolatedstring-perl6-1.0.2 (AudreyTang)
21:31:12 * hackage hakyll-filestore 0.1.7 - FileStore utilities for Hakyll  https://hackage.haskell.org/package/hakyll-filestore-0.1.7 (aergus)
21:31:14 * hackage hoauth2 1.9.0 - Haskell OAuth2 authentication client  https://hackage.haskell.org/package/hoauth2-1.9.0 (HaishengWu)
21:31:16 * hackage eventstore 1.3.3 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-1.3.3 (YorickLaupa)
21:31:18 * hackage aeson-yaml 1.0.1.0 - Output any Aeson value as YAML (pure Haskell library)  https://hackage.haskell.org/package/aeson-yaml-1.0.1.0 (patrick)
21:31:20 * hackage symbiote 0.0.2, zeromq4-simple 0.0.0.2 (athanclark): https://qbin.io/steam-paypal-ejz8
21:31:22 * hackage yampa-test 0.2, Yampa 0.13.1 (IvanPerez): https://qbin.io/health-looks-lcdw
21:31:23 * hackage grammatical-parsers 0.4.1.1, rank2classes 1.3.1.1 (MarioBlazevic): https://qbin.io/film-newark-ycq2
21:31:26 * hackage cryptostore 0.2.1.0 - Serialization of cryptographic data types  https://hackage.haskell.org/package/cryptostore-0.2.1.0 (OlivierCheron)
21:31:27 * hackage tls-debug 0.4.8, tls 1.5.2 (KazuYamamoto): https://qbin.io/graphs-sweden-cw2y
21:31:30 * hackage pseudo-boolean 0.1.9.0 - Reading/Writing OPB/WBO files used in pseudo boolean competition  https://hackage.haskell.org/package/pseudo-boolean-0.1.9.0 (MasahiroSakai)
21:31:31 * hackage net-spider-rpl-cli 0.1.2.0, net-spider-cli 0.2.0.0, net-spider 0.3.3.0 (debugito)
21:31:33 * hackage giphy-api 0.7.0.0 - Giphy HTTP API wrapper and CLI search tool.  https://hackage.haskell.org/package/giphy-api-0.7.0.0 (passy)
21:31:36 * hackage partial-records 0.1.0.0 - Template haskell utilities for constructing records with default values  https://hackage.haskell.org/package/partial-records-0.1.0.0 (mniip)
21:31:38 * hackage RSA 2.4.1 - Implementation of RSA, using the padding schemes of PKCS#1 v2.1.  https://hackage.haskell.org/package/RSA-2.4.1 (AdamWick)
21:31:41 * hackage core-program 0.2.1.0 - Opinionated Haskell Interoperability  https://hackage.haskell.org/package/core-program-0.2.1.0 (AndrewCowie)
21:31:55 <mozzarella> nigga
21:32:04 --- mode: ChanServ set +o dmwit
21:32:06 <mozzarella> stop spamming my irc
21:33:50 <dmwit> hololeap: Those two BoxIds are not the same!
21:33:57 <dmwit> One is at the computation level, one at th etype level.
21:34:07 --- mode: dmwit set -o dmwit
21:35:24 <dmwit> hololeap: So you could write `data PrimaryKey BoxT f = BoxId1 (Columnar f SerInt); primaryKey = BoxId1 . _boxId; type BoxId2 = PrimaryKey BoxT Identity` and that would be okay.
21:36:42 <jusss> dmwit: Maybe is a type?
21:36:54 <jusss> or Maybe is a function?
21:37:06 <ghoulguy> Yes, both
21:37:34 <jusss> ghoulguy: Maybe is a higher-kinded type?
21:39:42 <dmwit> Maybe *has* a higher-kinded type.
21:39:56 <dmwit> (If we're talking about Haskell without extensions.)
21:41:08 <MarcelineVQ> hackage: myson
21:41:34 <jusss> dmwit: what it would be with extensions?
21:42:00 <ghoulguy> dmwit: Without extensions we'd say that Maybe has a type?
21:43:15 <dmwit> I'm confused and wrong.
21:43:18 <dmwit> I should be ignored.
21:43:48 <ghoulguy> jusss: Maybe is a type that has kind * -> *
21:44:12 <ghoulguy> Because it has an arrow kind it can be applied to other types, specificaly those types with kind *
21:44:19 <masaeedu[m]> ghoulguy: i don't get it. how is `Maybe` a function?
21:44:20 <dmwit> Without extensions, Maybe is a higher-kinded type. With extensions, Maybe is also a kind. But I short-circuited the thought in my brain.
21:44:41 <ghoulguy> masaeedu[m]: Functions are things you apply, Maybe Int is Maybe applied to Int
21:44:43 <mniip> Maybe is not a kind
21:45:01 <dmwit> Sure it is. Just not a kind inhabited by any types.
21:45:23 <mniip> hrm
21:45:26 <ghoulguy> Who said Maybe was a kind?
21:45:42 <mniip> let's whip out GHC core inference rules shall we
21:45:57 <dmwit> ...I did. But now I have two smart people suggesting I'm wrong, so that doesn't bode well for me. =P
21:45:58 <ghoulguy> Nah, let's stick to Haskell 2010 for now
21:46:25 <dmwit> In H2010, Maybe definitely is not a kind.
21:46:32 <ghoulguy> Someone trying to understand what it means for Maybe to be a type doesn't need GHC core inference rules
21:47:22 <mniip> I'm being facetious
21:47:56 <masaeedu[m]> ghoulguy: oh, as in it's a type constructor
21:48:20 <ghoulguy> Being a type constructor is unrelated
21:48:30 <ghoulguy> That has to do with what kind of name it is
21:48:42 <ghoulguy> whether its a variable or constructor doesn't impact its kind
21:49:29 <ghoulguy> Maybe and Int are both type constructors, so that's not so helpful in this discussion
21:49:54 <jusss> ghoulguy: we give Maybe an Int, and Maybe return a Maybe Int, right?
21:49:58 <masaeedu[m]> uh, a non-nullary type constructor?
21:50:18 <dmwit> masaeedu[m]: The easy way is just to say "a type with an arrow kind". =)
21:50:34 <dmwit> masaeedu[m]: That way you get to include things like `Either Int` that isn't a type constructor at all.
21:50:40 <dmwit> s/isn't/aren't/
21:51:50 <ghoulguy> masaeedu[m]: If you want to talk about arities like "non-nullary" as some kind of shorthand, you can just say non-nullary type
21:52:07 <ghoulguy> being a constructor is are whole separate category that we're not discussing
21:52:49 <masaeedu[m]> so it's correct to call things that don't have kind `Type` types?
21:53:09 <masaeedu[m]> e.g. promoted data constructors
21:53:15 <heatsink> yes
21:53:44 <ghoulguy> Similarly it's OK to call unapplied functions "values"
21:54:40 <ghoulguy> 'map not' is still a value even though it has an arrow type
21:55:25 <jusss`> can we think who has kind *->* then it's a higher-kinded type?
21:56:35 <__dingbat__> Hello, which module is missing please? - Could not find module ‚ÄòControl.Monad.Base‚Äô
21:57:30 <jackdk> Probably Control.Monad.Base . If you search for that on hoogle it might show the packages that provide that module.
21:59:42 <__dingbat__> jackdk: Thanks, Hoogle was useful!
22:00:59 <jackdk> __dingbat__: you're welcome. it's sometimes underappreciated for how good it is
22:03:25 <__dingbat__> jackdk: I will be using it now on
22:03:50 <xelxebar> So, super basic, but I woke up this past Saturday wondering about (.).(.) and spend some time munging the type unifications while lazing in bed. However, the commucative diagram for . is so simple, I thought that there must be a diagrammatic way to view (.).(.), and after a bit more lazing I realized that it's "just" . over slice categories!
22:04:01 <xelxebar> Dumb, but I thought it was cool
22:04:13 <masaeedu[m]> the terminology in TAPL is "type operators" and "proper types"
22:04:31 <masaeedu[m]> for what we're calling non-nullary and nullary types respectively
22:04:45 <xelxebar> And the reason it's slice instead of coslice traces back to -> being right associative.
22:05:50 <xelxebar> That, or the argument order to .
22:06:10 <xelxebar> s/or/and/
22:06:22 <mniip> slice you mean X \downarrow C where X in Ob(C) ?
22:06:22 <dmwit> jusss`: No. There are many other higher kinds.
22:06:53 <dmwit> jusss`: For example, (* -> *) -> *, and * -> (* -> *), and * -> * -> (* -> (* -> * -> *) -> *) -> *.
22:07:05 <mniip> @kind StateT
22:07:06 <lambdabot> * -> (* -> *) -> * -> *
22:07:29 <heatsink> @kind Compose
22:07:30 <lambdabot> error:
22:07:30 <lambdabot>     Not in scope: type constructor or class ‚ÄòCompose‚Äô
22:07:50 <mniip> shh you can accidentally run into PolyKinds
22:08:04 <heatsink> @kind Int#
22:08:05 <lambdabot> error:
22:08:06 <lambdabot>     Not in scope: type constructor or class ‚ÄòInt#‚Äô
22:08:06 <lambdabot>     Perhaps you meant one of these:
22:08:30 <mniip> I've recently had to work with a type of kind ((* -> *) -> * -> *) -> ((* -> *) -> *) -> (* -> *) -> * -> *
22:09:04 <ghoulguy> masaeedu[m]: It makes more sense to distinguish type operators and "proper" types in a language that actually distinguishes them
22:09:08 <mniip> speaking of, I should finish that library
22:09:50 <ghoulguy> where a type operator can't be used as a type and must first always be applied to some arguments
22:12:46 <masaeedu[m]> mniip: what library is that?
22:13:28 <masaeedu[m]> ghoulguy: are there any inhabited type operators that aren't proper types?
22:13:29 <masaeedu[m]> in haskell i mean
22:13:59 <ghoulguy> In GHC there are type families
22:14:39 <mniip> masaeedu[m], basically it's a kind of a reader monad whose environment has access to the entire monadic stack
22:14:48 <xelxebar> mniip: Yeah, I got slice and coslice backwards there.
22:15:17 <mniip> motivating use case is
22:15:33 <mniip> data Env m = Env { envLogger :: String -> m () }
22:15:35 <mniip> log :: MonadReader (Env m) m => String -> m ()
22:15:56 <mniip> except there is no datatype that can instantiate MonadReader like this
22:16:18 <mniip> long story short, behold:
22:16:20 <mniip> newtype IntrospectT (t :: (* -> *) -> * -> *) (r :: (* -> *) -> *) (m :: * -> *) (a :: *) = IntrospectT { runIntrospectT :: r (t (IntrospectT t r m)) -> m a }
22:17:16 <heatsink> What does r do?
22:17:20 <mniip> r ~ Env
22:22:37 <heatsink> ... it looks like there's some kind of fixed point in constructing an IntrospectT
22:45:28 <mniip> sure does
22:46:12 <mniip> I have a working package but 0 docs right now
23:10:02 <phadej> mniip: open a new issue
23:10:13 <mniip> ok
23:13:46 <phadej> it's surely not the same as the 7 year oldone
23:14:44 <mniip> it produces the same error message in the same circumstance
23:15:13 <phadej> still
23:17:07 <phadej> 744 is fixed, there's a regression test specifically for it
23:18:07 <mniip> it's not a good enough test
23:18:54 <dminuoso> Mmm, is there a quick idiom into partitioning a list into two list, in which you tag at least one side (or both, I dont care) with the reason why it was put there?
23:19:38 <dminuoso> Or would this just be foldr?
23:19:40 <phadej> ¬Ø\_(„ÉÑ)_/¬Ø
23:20:10 <cocreature> dminuoso: sounds like a combination of partitionEither and map
23:20:35 <cocreature> the map can add whatever evidence you want
23:21:21 <dminuoso> cocreature: Ah indeed! That's what I was looking for, cheers.
23:22:37 <dminuoso> cocreature: Yes this is really great, the `Either a` fits nicely into my scheme too. :)
23:39:06 <deepgroud> How to inference a partial function 's type .Just like id :: a->a    const :: a->b->a      .    end  get ===>    const id : b->a->a .what is the skill here?  
23:39:32 <dminuoso> deepgroud: There are no partial functions.
23:39:37 <dminuoso> deepgroud: That's, at its core, the skill to it. :)
23:40:07 <jle`> deepgroud: the technique is practicing unifying type variables
23:40:20 <jle`> one trick is to make sure you have different type variable names
23:40:30 <jle`> so if we say `id :: a -> a`, and `const :: b -> c -> b`
23:40:49 <jle`> deepgroud: if we do `const id`, then it means we are applying 'id' to 'const', so 'b' has to be 'a -> a'
23:41:13 <jle`> so if we do 'const id', it means we are using `const :: (a -> a) -> c -> (a -> a)`
23:41:35 <jle`> and so applying 'id' there becomes `const id :: c -> (a -> a)` , which is just `const id :: c -> a -> a`
23:42:36 <deepgroud> jle`: I see
23:43:28 <deepgroud> I see
23:45:35 <jle`> it's kind of just matching up type variables and 'unifying' them, seeing what they have to be
23:45:46 <jle`> in a step-by-step way
23:46:17 <mniip> phadej, https://github.com/haskell/cabal/issues/6297
23:46:33 <jle`> deepgroud: it does help to re-label the variables though before you start
23:47:05 <deepgroud> jle`: thank you  and I will practice more  
23:47:26 <mniip> hey jle`
23:47:46 <mniip> have you seen coercion-extras
