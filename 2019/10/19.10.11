00:19:23 <__dingbat__> Can someone help me with this please ? - https://www.codepile.net/pile/Zg6G9NdR
00:20:00 <__dingbat__> Basically I cant seem to figure out how to handle STM in the context of another monad
00:30:43 <jackdk> __dingbat__: about to dash, but I think you want to look at atomically :: STM a -> IO a and liftIO . atomically :: MonadIO m => STM a -> m a
00:31:29 <__dingbat__> :jackdk, thanks will look into it!
01:26:01 * hackage ormolu 0.0.1.0 - A formatter for Haskell source code  https://hackage.haskell.org/package/ormolu-0.0.1.0 (mrkkrp)
02:01:10 <qbnk4> I'm planning to write a little UI for firewall management and wanted to do so in a language I never did before (rust or haskell). Does haskell have good support for UIs (/ web UIs?) and are there already projects I could have a look at?
02:02:07 <qbnk4> Don't really know if it's a thing that should be done in haskell or where I better should choose something else (like go or js)
02:02:58 <merijn> qbnk4: For a web UI you might want to look at PureScript?
02:03:54 <merijn> qbnk4: PureScript is very much like Haskell, but seems to produce more lightweight JS. There's also ghcjs, but that appears to be a bit of a hassle to setup and the produce JS is rather big
02:05:26 <qbnk4> merijn: Never heard of it, will take a look at it. Thank you. Maybe I can pick up some Haskell during that project too (if the syntax is similar). Really in need for some projects so I can learn Haskell
02:06:43 <merijn> qbnk4: It is very similar to Haskell in many ways. For the backend of such a page Haskell seems fine, though
02:07:14 <merijn> qbnk4: There's also stuff like reflex-dom for doing web UIs, but honestly I haven't done much web stuff so I'm not sure how lightweight things are
02:07:36 <qbnk4> merijn: Can I interact with the system itself easily? Like writing to files, restarting services etc. It's basically a frontend to help some people manage their nftables / dnsmasq installation without resorting to the cli
02:08:54 <merijn> qbnk4: I mean, all that stuff is about a easy as it is in any other language (not accounting for any extra time needed to learn the basics of Haskell)
02:10:23 <qbnk4> merijn: Ok thank you. Bought a book (Haskell Programming) and will try to grasp the basics this weekend and see how far I come
02:12:31 * hackage lightstep-haskell 0.1.0 - LightStep OpenTracing client library  https://hackage.haskell.org/package/lightstep-haskell-0.1.0 (DmitryIvanov)
02:20:16 <absence> dminuoso: yesterday you suggested "inserting f = \x -> insert (f x) x" for inserting values that contain the key into a map, but the reason i was looking for a different solution is that if you map over the map later, the key and its corresponding version inside the value can go out of sync. you also mentioned representable functors, is there a way to use that to avoid the problem?
02:39:27 <cheater> since when does pattern matching a 5-tuple with a 4-tuple work without error or warning?
02:39:32 <cheater> is this a new thing?
02:41:27 <xsperry> > let (x, y, z) = (1,2) in x
02:41:29 <lambdabot>  error:
02:41:30 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚Äò(a1, b, c)‚Äô
02:41:32 <lambdabot>                    with actual type ‚Äò(Integer, Integer)‚Äô
02:42:12 <koz_> > let (x, y) = (1, 2, 3) in x
02:42:13 <lambdabot>  error:
02:42:13 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚Äò(a1, b)‚Äô
02:42:13 <lambdabot>                    with actual type ‚Äò(Integer, Integer, Integer)‚Äô
02:42:22 <koz_> cheater: Please demonstrate.
02:46:30 <cheater> oh, reading the type error, it actually included the fifth element, there was just a line break
02:46:33 <cheater> nice
02:49:26 * koz_ o O O ( the Luc Besson movie )
02:57:01 * hackage phone-numbers 0.2.0 - Haskell bindings to the libphonenumber library  https://hackage.haskell.org/package/phone-numbers-0.2.0 (ChristianMarie)
03:01:45 <sshine> koz_, there was a Luc Besson movie about 5-tuples?
03:03:04 <koz_> sshine: No, but there _was_ one about a fifth element. :)
03:10:04 <sshine> ah :) good one. is the concept of having record getters that work for any record type that contains an element that matches the name of the getter, covered by the concept of "extensible records"? I seem to recall that there were some pretty decent and uncontroversial extensions to Standard ML that allowed for this, but I can't spot the simplicity in all of the extensible record stuff going on in Haskell la
03:10:10 <sshine> nd.
03:11:18 <sshine> oh, looking back at those articles, what I was thinking about is called row types.
03:20:40 <qbnk4> Was just wondering: What is the biggest industry Haskell is used in? Never seen any Haskell jobs around me
03:21:05 <Taneb> qbnk4: I believe finance. I'm aware Standard Chartered and Barclays both use Haskell
03:21:44 <Taneb> qbnk4: where are you based?
03:22:44 <qbnk4> Taneb: Currently Germany, but in a few months France
03:23:33 <__monty__> sshine: There was T-rex (recs?) but it never made it into haskell proper afaik. Don't know much about approaches like Vinyl. But Lens is the accepted way to do things like this afaict. It's a lot more complex but it's also more general.
03:26:22 <sshine> qbnk4, I'd also assume finance. it seems that the other place is "startups", but that's not really any distinct domain.
03:27:29 <sm[m]> kiwi_92: any luck with faster randoms ?
03:27:43 <sm[m]> mozzarella: yes
03:27:57 <sshine> __monty__, I've just read http://nikita-volkov.github.io/record/ (2015, it seems)
03:29:43 <sshine> __monty__, I looked at Vinyl. not really a big fan of so much TH in practice.
03:30:35 <sm[m]> qbnk4: for non web UIs, have a look at brick, fltkhs, and the latest qt/gtk libs on hackage (whose names I forget)
03:31:04 <qbnk4> sm[m]: Ok will write those down and check them after work. Thanks
03:34:58 <sm[m]> brick (for text UIs) will be the cheapest to get something working with. fltkhs is the most cross platform and possibly the cheapest one with rich widgets.
03:35:29 <__monty__> sshine: This looks like a GHC implementation for Hugs' Trex. https://wiki.haskell.org/CTRex
03:36:31 <qbnk4> sm[m]: My preference would be a web ui as it can be accessed from every browser / phone and does not need to be installed on the end user pc but honestly to get a foot into Haskell I might as well just do a non web ui
03:36:57 <sshine> qbnk4, looking at Haskell jobs posted on Haskell Weekly in the past 4 weeks: supply chain risk management, reinsurance industry, cybersecurity, finance, blockchain, media, FPGAs, legal automation
03:38:04 <sshine> qbnk4, so largely money-related and other cool stuff where the domain stands to benefit from formalizing it to some degree, I think. :)
03:38:05 <qbnk4> sshine: Is it just because it's so reliable and those fields just need reliability / no faults at program execution? (Found Haskell a few days ago so sry if the answer seems obvious)
03:38:27 <sm[m]> Ah, well then I‚Äôd concentrate on web (server side ui with yesod or front end ui with eg miso). Too much work to do  both while also learning Haskell
03:39:21 <sshine> qbnk4, well, there was Co-Star who recently looked for a developer for a machine-learning-based mobile app for astrology... in Haskell. https://www.reddit.com/r/haskell/comments/8953h8/costar_astrology_is_hiring_a_haskell_developer_in/
03:39:47 <sshine> qbnk4, I don't know if astrology is notoriously known for reliability / no faults at program execution. :-D
03:40:06 <sm[m]> (possibly any ui beyond tty is too much work while learning Haskell .. YMMV!)
03:40:32 <maerwald> sshine: I don't think it has anything to do with the language, but the fact that haskell devs are considered smart and self-driven
03:40:44 <qbnk4> sm[m]: Ok, will add yesod and miso to my list. Luckily I'm not pressured on time for that project so I can just look at everything and learn at my own pace
03:42:00 <sshine> qbnk4, for finance, I guess it is much related to reliability, and an incidental overlap in people who like finance math and functional programming.
03:42:17 <sm[m]> sshine: I‚Äôm sure astrologers like reliable correct software too :)
03:42:37 <sshine> sm[m], yes! they must be very keen on predicting behavior.
03:44:01 <sm[m]> That co star app is actually good, try it
03:44:05 <sshine> qbnk4, once a framework is in place, I believe you can have some incredibly short release cycles. this is what one guy told me recently in his new OCaml job. then again, it's all preaching to the choir, isn't it?
03:44:14 <sshine> sm[m], I don't have a smartphone.
03:44:37 <sm[m]> I thought it was web based. I forget
03:44:59 <maerwald> sshine: in fact I would argue, with a fixed amount of money for a business, it will be harder to write correct software with haskell (hiring costs, building libraries that don't exist, exploring performance issues, ...)
03:45:00 <sshine> sm[m], it's an iOS app.
03:45:22 <maerwald> if the money isn't the primary problem, then it makes more sense
03:45:27 <qbnk4> Really looking forward to learning Haskell. Coming from a JS/Go background it's a bit different then what I'm used to
03:45:47 <sshine> qbnk4, you may like exercism.io's haskell track
03:47:34 <qbnk4> sshine: Is it any good? Already bought a book called "Haskell Programming from First Principles" that was supposed to be one of the better learning experiences
03:47:39 <sm[m]> maerwald: I think that depends, eg on the problem  to be solved
03:47:41 <maerwald> what you are really paying for isn't the language, but the developers attitude (and so it happens that businesses like haskell devs)
03:48:02 <maerwald> sm[m]: I think it doesn't, because most problems are already solved in Java ;)
03:48:24 <maerwald> but how do you get highly qualified, self-driven java devs? The spectrum is extremely broad
03:48:41 <sm[m]> eh.. not in my world :)
03:49:36 <evelyn> qbnk4: that book's great! there is a good list here too: https://wiki.haskell.org/Tutorials
03:50:21 <maerwald> sm[m]: from a business perspective, you want a haskell dev, but programming in java ;)
03:50:24 <maerwald> that's perfect
03:50:40 <sm[m]> I suppose you are talking about ‚Äúeveryday business apps‚Äù - fair enough
03:50:41 <maerwald> except you probably can't have that...
03:51:02 * hackage indexed-profunctors 0.1 - Utilities for indexed profunctors  https://hackage.haskell.org/package/indexed-profunctors-0.1 (AdamGundry)
03:51:25 <maerwald> and java is very common in fintech too
03:54:06 <__monty__> Recently heard of a company that switched to haskell for developer comfort. It's kinda becoming one of the perks like office ping pong tables and the like : )
03:54:36 <evelyn> Unless you hate your colleagues, and don't wish to ever play ping pong, of course
03:54:47 <evelyn> same with the trend for 'office dogs'
03:55:21 <evelyn> go away dog, you are paid more in prime steak than I am per hour, and you make my eyes go puffy
03:56:19 <MarcelineVQ> office dogs is a trend? that is awful
03:56:53 <maerwald> good for everyone, except people with adhd
03:56:56 <evelyn> they're a trend in companies that haven't studied discrimination laws carefully enough
03:56:56 <boxscape> % let f | !_ <- undefined = () in f
03:56:56 <yahb> boxscape: ()
03:57:08 <boxscape> why does that not throw an error, when this does?
03:57:09 <boxscape> % let f | !_ <- undefined = () in f
03:57:09 <yahb> boxscape: ()
03:57:16 <boxscape> uh, sec
03:57:23 <boxscape> % case undefined of !_ -> ()
03:57:23 <yahb> boxscape: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:36:1 in interactive:Ghci12
03:57:27 <boxscape> when this does ^
04:00:28 <MarcelineVQ> the answer will surely be somewhere within here https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#recursive-and-polymorphic-let-bindings if your eyes don't cross trying to read it
04:01:31 <boxscape> I suppose I'll see what my eyes are capable of, thanks
04:02:47 <MarcelineVQ> !_ <- undefined being a pattern guard could also be relevant
04:03:31 <boxscape> perhaps worth noting that using a let also fails:
04:03:38 <boxscape> % let f | let !_ = undefined = () in f
04:03:38 <yahb> boxscape: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:38:18 in interactive:Ghci12
04:04:32 <MarcelineVQ> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-460003.13 is where one starts their search for how to figure pattern guards
04:04:55 <boxscape> okay
04:19:32 <sshine> qbnk4, I'm biased. it's okay, I guess.
04:20:02 <sshine> qbnk4, there are exercises. you get feedback (but sometimes have to wait for it).
04:21:27 <cheater> is there a better definition for this? chooseWith xs bs = map snd $ filter fst $ zip bs xs
04:22:20 <merijn> cheater: I dunno, that looks pretty reasonable (although I'd advocate replacing the first $ with .)
04:22:44 <cheater> thx
04:23:33 <__monty__> Office dogs sounds terrible. People who think they're gross are annoyed and people who don't realize how gross they are are distracted petting and playing with them.
04:23:53 <boxscape> cheater if you like list comprehensions
04:23:54 <boxscape> % let xs = [1..5]; bs =  [True, False, True, False, True] in [ x | x <- xs | b <- bs, b ]
04:23:54 <yahb> boxscape: [1,2,3]
04:24:51 <merijn> boxscape: That requires an extension, though
04:24:57 <boxscape> that's true.
04:25:20 <boxscape> % let xs = [1..5]; bs =  [True, False, True, False, True] in [ x | (x, b) <- zip xs bs, b ]
04:25:20 <yahb> boxscape: [1,3,5]
04:25:22 <boxscape> this doesn't
04:25:42 <boxscape> wait
04:25:46 <boxscape> that's different
04:26:06 <boxscape> my first solution is actually wrong
04:26:14 <merijn> Yeah, because said lack of extension :p
04:26:44 <boxscape> % :set -XParallelListComp
04:26:44 <yahb> boxscape: 
04:26:48 <boxscape> % let xs = [1..5]; bs =  [True, False, True, False, True] in [ x | x <- xs | b <- bs, b ]
04:26:48 <yahb> boxscape: [1,2,3]
04:26:52 <boxscape> merijn no
04:27:12 <boxscape> the guards are just interpreted differently from what I thought
04:27:19 <merijn> boxscape: :set -X doesn't work
04:27:27 <merijn> % :seti -XParallelListComp
04:27:27 <yahb> merijn: 
04:27:43 <merijn> % let xs = [1..5]; bs =  [True, False, True, False, True] in [ x | x <- xs | b <- bs, b ]
04:27:44 <yahb> merijn: [1,2,3]
04:27:53 <boxscape> % :set -XNoTypeApplications
04:27:54 <yahb> boxscape: 
04:27:59 <merijn> Or is parallel comprehension with ,
04:28:03 <boxscape> % read @Int 45
04:28:03 <yahb> boxscape: ; <interactive>:51:1: error:; Pattern syntax in expression context: read@Int; Did you mean to enable TypeApplications?
04:28:07 <boxscape> % :set -XTypeApplications
04:28:07 <yahb> boxscape: 
04:28:08 <boxscape> % read @Int 45
04:28:09 <yahb> boxscape: ; <interactive>:53:11: error:; * No instance for (Num String) arising from the literal `45'; * In the second argument of `read', namely `45'; In the expression: read @Int 45; In an equation for `it': it = read @Int 45
04:28:16 <boxscape> % read @Int "45"
04:28:16 <yahb> boxscape: 45
04:28:23 <boxscape> merijn it does work
04:28:28 <merijn> hmm, then yahb is inconsistent with ghci
04:28:31 <boxscape> no
04:28:36 <boxscape> that's how I've always done it in ghci
04:28:40 <cheater> what extension does it need?
04:29:00 <merijn> ":set" sets the extension for loaded code, :seti sets the extensions enabled for interactiion
04:29:04 <boxscape> -XParallelListComp cheater, but my first solution is wrong anyway, my second one is correct and doesn't need an extension
04:29:09 <boxscape> merijn :set sets it for both
04:29:11 <cheater> ParallelListComp, just noticed, thanks
04:29:17 <cheater> why does the first solution look ok?
04:29:25 <cheater> oh
04:29:27 <cheater> it doesn't
04:29:47 <cheater> what does the comma mean in there?
04:30:02 <boxscape> cheater are you familiar with do notation?
04:30:06 <cheater> yes
04:31:06 <boxscape> cheater the List comprehension is just translated into `do (x, b) <- (xs, bs); guard b, return x`
04:31:06 <MarcelineVQ> :t (\xs bs -> concat $ zipWith (bool [] . pure) xs bs) -- these aren't elegantly hideous enough
04:31:08 <lambdabot> [a] -> [Bool] -> [a]
04:31:25 <boxscape> cheater uh, replace that last comma with a semicolon
04:32:01 <boxscape> cheater at least that's if I remember correcltly how it's desugared
04:32:58 <MarcelineVQ> I expect a foldr and mapAccumL version on my desk by the morning
04:33:06 <merijn> boxscape: It's not, desugared like that, but it means the same thing
04:33:22 <boxscape> ah, okay
04:33:22 <merijn> It's only desugared like that with monadcomprehensions enabled
04:33:26 <boxscape> I see
04:33:39 <merijn> I think the normal desugaring uses filter/concatMap directly or something
04:33:39 <cheater> i don't know what a semicolon would mean there
04:33:54 <boxscape> cheater semicolon can be used instead of a newline
04:34:01 <merijn> cheater: That semicolon is just in place of a newline in do notation
04:34:08 <cheater> i know it's like a newline
04:34:20 <merijn> cheater: You mean you don't know what the list monad does? :)
04:34:28 <cheater> oh, so you're replacing the comma with not just a semicolon, but with a semicolon and then the word guard
04:34:32 <merijn> :t (>>=) `asAppliedTo` []
04:34:33 <lambdabot> [a] -> (a -> [b]) -> [b]
04:34:36 <cheater> right?
04:34:42 <boxscape> also I slightly messed it - the zip should be in here: `do (x, b) <- zip xs, bs; guard b, return x`
04:34:43 <merijn> cheater: Can you guess what it does know? :)
04:35:03 <cheater> if you're adding guard that makes more sense
04:35:28 <merijn> > guard True :: [Int]
04:35:30 <lambdabot>  error:
04:35:30 <lambdabot>      ‚Ä¢ Couldn't match type ‚Äò()‚Äô with ‚ÄòInt‚Äô
04:35:30 <lambdabot>        Expected type: [Int]
04:35:34 <merijn> > guard True :: [()]
04:35:37 <lambdabot>  [()]
04:35:41 <merijn> > guard False :: [()]
04:35:43 <lambdabot>  []
04:35:52 <merijn> > guard True :: Maybe ()
04:35:54 <lambdabot>  Just ()
04:36:00 <merijn> > guard False :: Maybe ()
04:36:02 <lambdabot>  Nothing
04:36:09 <boxscape> (Typed it wrong again -.- this should be right `do (x, b) <- zip xs bs; guard b; return x`)
04:40:16 <boxscape> cheater it's slightly more complex than just replacing commas with semicolon + "guard", because you can have something like [ x + y | x <- xs, y <- ys ], which doesn't get a "guard"
04:40:51 <boxscape> cheater basically if it's something of the form "a <- b", no "guard" is added, but otherwise it is
04:41:11 <boxscape> % [ 4 | True ]
04:41:11 <yahb> boxscape: [4]
04:41:33 <boxscape> % let xs = [1,2]; ys = xs in [ x + y | x <- xs, y <- ys ]
04:41:33 <yahb> boxscape: [2,3,3,4]
04:55:48 <dminuoso> Mmm, is there some sort of trick to simulate let bindings, in the sense of `data Free t i f a = let r = Free t i f in More (t f r a) | ...`
04:56:29 <dminuoso> Or, I guess, is there some extension that enables this?
04:59:20 <cheater> boxscape: sure
04:59:26 <cheater> thanks
04:59:47 <cheater> :)
05:00:01 <merijn> dminuoso: I don't quite understand what you mean?
05:00:10 <merijn> dminuoso: You mean binding recursively?
05:00:36 <dminuoso> merijn: No rather, being able to name some type-level expression
05:00:42 <dminuoso> Sort of like a local type alias
05:00:43 <merijn> dminuoso: No
05:00:54 <merijn> dminuoso: Well, "type" I suppose
05:01:13 <dminuoso> merijn: Sure, but that wont have access to local type variables. :(
05:03:08 <boxscape> dminuoso CPP maybe? :P
05:04:40 <dminuoso> I should go through the ghc proposals. Surely someone has thought of type-level let bindings before.
05:05:36 <__monty__> Sounds like dependent types : >
05:05:40 <boxscape> dminuoso second newest proposal about visbile forall includes the line " we establish a policy that changes that simply bridge the gap between terms and types (such as promotion of Char, type-level if then else, etc) do not require the proposal process", but spj doesn't want that line in the proposal
05:06:16 <boxscape> dminuoso but I don't think there's a proposal yet about type level let bindings
05:07:25 <dminuoso> __monty__: Not at all, it's just about being able to write `Free :: More (t r f a) where r = Free t i f` instead of `Free :: More (t f (Free t i f) a)`
05:07:53 <dminuoso> (Or with let-style, I dont care about the specifics really)
05:07:58 <__monty__> Just teasing, cause `let`s are awfully close to `lambda`s ; )
05:08:21 <boxscape> type level lambdas don't really require dependent types either, do they?
05:08:30 <dminuoso> boxscape: Depends on what they bind.
05:08:35 <boxscape> hm, okay
05:08:45 <boxscape> sounds like it would just be an anonymous type family
05:08:46 <dminuoso> boxscape: If they bind types, thats just type operators. If they bind terms, then thats dependent types.
05:09:02 <boxscape> I see
05:09:42 <dminuoso> (Note I chose the word "type operator" here to generalize over tyfams and tycons)
05:23:48 <boxscape> hm I wonder how singletons translates let and where bindings
05:24:21 <boxscape> presumably with type families that receive the entire environment of locally bound terms as arguments, or something like that
05:26:55 <sim590> Let the following list [[1,2,3], [3], [2,5,4]]. I would like to remove duplicates from left to right, i.e. that first occurences are kept, but extra ones are removed. How can I do that? I can't use Data.List.Unique.* since those fonctions only work on lists and not list of lists. Mapping doesn't simply solve the issue since for instance filtering function would only act on a given list independantly of
05:26:57 <sim590> others. The list is wrapped inside a type that is Functor and a Foldable.
05:28:33 <MarcelineVQ> ending up with [[1,2,3], [], [5,4]] ?
05:28:43 <sim590> MarcelineVQ: Yes.
05:29:10 <dminuoso> sim590: Wrap with Compose and (StateT (Set Int)) and traverse?
05:29:29 <sim590> OK, so I really need a state.
05:31:34 <boxscape> sim590 you do, though in principle you could get "state" by using an accumulator argument rather than the state monad
05:31:37 <c_wraith> yes, but you don't necessarily need any types like State
05:36:00 <sim590> I did implement a removal of some specific types of duplicates in a single list which I did using an accumulator (well, I did use foldl). I guess that I need to implement a fold-level function to do like a mix of map and fold.
05:37:22 <c_wraith> :t mapAccumR
05:37:23 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
05:37:33 <c_wraith> mix of map and fold :)
05:37:40 <sim590> :D
05:39:55 <boxscape> though in this case I think you'd have to use mapAccumL? since you want the leftmost occurence to be kept
05:40:24 <sim590> boxscape: It sounds right.
05:40:27 <c_wraith> that's not the difference between those two functions. 
05:41:03 <boxscape> hm, the documentation says it "passes an accumulating paramtere from left to right", but I might be misunderstanding what that entails
05:41:11 <boxscape> s/parametere/parameter
05:41:25 <boxscape> (and right to left for mapAccumR)
05:44:42 <sim590> It sounds like I need mapAccumL if I want to accumulate unique values from left to right.
05:48:48 <kuribas> or traverse and State
05:48:51 <kuribas> :t state
05:48:52 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
05:49:05 <kuribas> :t evalState
05:49:06 <lambdabot> State s a -> s -> a
05:50:59 <Axman6> :t (\\)
05:51:01 <lambdabot> Eq a => [a] -> [a] -> [a]
05:51:09 <Axman6> > [1,2,3] \\ [3]
05:51:11 <lambdabot>  [1,2]
05:52:13 <Axman6> > foldr (\xs acc -> xs : map (\\ xs) acc) [] [[1,2,3], [3], [2,5,4]]
05:52:15 <lambdabot>  [[1,2,3],[],[5,4]]
05:52:24 <Axman6> > foldr (\xs acc -> xs : map (\\ xs) acc) [] [[1,2,3,5], [3], [2,5,4]]
05:52:26 <lambdabot>  [[1,2,3,5],[],[4]]
05:52:45 <Axman6> this is definitely not efficient...
05:53:21 <MarcelineVQ> [1,2,3,3,5] :X
05:53:48 <Axman6> > foldr (\xs acc -> let xs' = nub xs in xs' : map (\\ xs') acc) [] [[1,2,3,5], [3], [2,5,4]] -- in case repeats in the same list should also be removed
05:53:50 <lambdabot>  [[1,2,3,5],[],[4]]
05:54:08 <Axman6> > foldr (\xs acc -> let xs' = nub xs in xs' : map (\\ xs') acc) [] [[1,2,3,5,2], [3], [2,5,4]]
05:54:10 <lambdabot>  [[1,2,3,5],[],[4]]
05:55:45 <olligobber> so I have this number, and I tried doing `log $ fromInteger n' and haskell gave me Infinity
05:56:10 <merijn> > log 0 -- test
05:56:12 <lambdabot>  -Infinity
05:56:16 <merijn> There we go :)
05:56:31 <olligobber> no, it gave me positive infinity
05:56:52 <merijn> olligobber: You haven't really asked a question, though?
05:57:13 <olligobber> how do I get a non-infinite log of the number?
05:57:28 <merijn> olligobber: Well, what number are you passing in?
05:57:32 <c_wraith> well, what's fromInteger n
05:58:00 <c_wraith> > log (1/0)
05:58:01 <olligobber> > let a 1 = 1; a 2 = 1; a 3 = 1; a n = a (n-3) * (a (n-2) + a (n-1)) in a 30
05:58:02 <lambdabot>  Infinity
05:58:07 <lambdabot>  mueval-core: Time limit exceeded
05:58:12 <olligobber> that number
05:58:30 <c_wraith> Best guess:  fromInteger is returning Infinity
05:59:01 <merijn> > 999999999999999999999999999999999999999999999 :: Double
05:59:03 <lambdabot>  1.0e45
05:59:08 <merijn> hmm, not big enough :p
05:59:15 <olligobber> what type would it default to anyway? double?
05:59:19 <c_wraith> yes
05:59:34 <rocket_man> > log $ fromInteger 2^500000
05:59:36 <lambdabot>  Infinity
05:59:55 <c_wraith> rocket_man: that doesn't parse the way you think, but it does prove the point
05:59:55 <rocket_man> log takes a `Float`, so it has numeric limits
06:00:13 <olligobber> ok, fromInteger is giving infinity
06:00:56 <olligobber> I'll just count the number of digits instead
06:01:14 <olligobber> ~4000 digits
06:01:29 <Ariakenom> olligobber: there is a package for integer logarithms
06:01:38 <olligobber> I think I looked at it once
06:02:01 <olligobber> I remember using a lot more # in my code than I was comfortable with
06:02:14 <olligobber> something to do with boxed types
06:02:27 <boxscape> % approxLogBase10 = length . show
06:02:27 <yahb> boxscape: 
06:02:37 <merijn> olligobber: But # is how you make your code fast! :D
06:02:51 <Ariakenom> olligobber: eh. theres no need for unboxed types with integer-logarithms
06:03:35 <olligobber> merijn, you can make your code fast by putting `{-' at the start and `-} main = return ()' at the end
06:05:08 <boxscape> careful, I think in some rare cases that can subtly affect program behavior
06:08:19 <tabaqui1> I have some "data Foo a m" and I want to declare that Foo is a Functor over the 'a' variable
06:08:30 <merijn> tabaqui1: You can't without a newtype
06:08:47 <tabaqui1> I thought that there was some syntax like "instance Functor (Foo * m) where", but I cannot find it among the extensions
06:08:49 <merijn> (unless you reorder the definition of Foo to be "data Foo m a"
06:09:35 <merijn> tabaqui1: No, that'd be equivalent to having type level lambda's, which makes typechecking undecidable
06:10:16 <tabaqui1> could you explain more, please?
06:10:57 <tabaqui1> like "someFoo <$> x" make use different Functor instances with this "extension"?
06:11:09 <merijn> tabaqui1: What you're basically wanting/asking for is a way to define something that's equal to a "type level Flip" which cannot be done
06:11:09 <tabaqui1> s/make/would/g
06:11:23 <jluttine> does this signature look like some "standard" function: (a -> b -> c) -> a -> (a -> b) -> c
06:11:26 <jluttine> hoogle gives me nothing
06:11:47 <merijn> tabaqui1: No, implementing an extension that would let you implement type level lambda, having type level lambdas makes type checking undecidable
06:11:57 <merijn> tabaqui1: Hence, such an extension does not exist
06:12:06 <merijn> tabaqui1: You have to go through a newtype to make it work
06:12:14 <merijn> (Or reorder Foo's definition)
06:12:24 <olligobber> jluttine, that's the S combinator, right?
06:12:40 <tabaqui1> merijn: ok, thank you
06:12:54 <tabaqui1> jluttine: \f x g = f (g x)?
06:12:55 <olligobber> no, it's the S combinator with the argument order changed
06:13:01 <c_wraith> hmm.  mapAccumL is lazy enough after all.  I guess it's more like scanl than foldl
06:13:11 <olligobber> \f x g -> f x (g x)
06:13:20 <tabaqui1> right ^
06:13:29 <Lears> % :t (<*>) @((->) _)
06:13:30 <yahb> Lears: (w -> a -> b) -> (w -> a) -> w -> b
06:13:37 <tabaqui1> Lears: ah, you were first!
06:13:38 <Lears> That, basically.
06:13:57 <tabaqui1> Monad instance for functions is brilliant
06:14:20 <tabaqui1> % :t (>>=) @((->) _)
06:14:20 <yahb> tabaqui1: (w -> a) -> (a -> w -> b) -> w -> b
06:14:21 <tdammers> isn't that just the reader monad?
06:14:23 <merijn> tabaqui1: Is there any reason you can't simply change "Foo a m" into "Foo m a"?
06:14:33 <olligobber> oh, ofcourse it's just the monad thing
06:14:55 <jluttine> tabaqui1: yep, thanks, i formulated myself badly. i know the implementation, i was just wondering if it had some name or existed already in some "standard" library.
06:15:12 <tabaqui1> merijn: I'm playing with "newtype AppT r m a = AppT (m (r -> a))" and am wondering if I can define "instance Monad m => Category (AppT * m *)"
06:15:48 <jluttine> olligobber: ok, never heard of S combinator. i'll have a look, thanks!
06:16:03 <c_wraith> tabaqui1: you can't.  but that's what the Kleisli newtype is for
06:16:04 <merijn> tabaqui1: Does AppT *have* to be a transformer, or are you okay with AppT being the top of your stack?
06:16:24 <tabaqui1> dunno, it is just an experiment now
06:16:33 <merijn> c_wraith: Kleisli doesn't quite map to what he has
06:16:52 <c_wraith> oh, right.  Kleisli needs the m first
06:16:52 <merijn> tabaqui1: Because you can simply use "newtype App m r a" then Category is simple :)
06:17:09 <merijn> c_wraith: Kleisli is also on functions, not on an action
06:17:23 <tabaqui1> but yeah, I would like to implement Monad and Trans instances as well
06:17:24 <merijn> c_wraith: I mean, it's close, but not the same
06:17:31 <merijn> tabaqui1: Monad would still work
06:17:37 <tabaqui1> I hope so
06:18:01 <merijn> tabaqui1: No, if "AppT r m a" can be a Monad than "AppT m r" can too, no question about it
06:18:12 <merijn> tabaqui1: Since monads only drop the last type argument
06:18:45 <tabaqui1> sure, but I think that it is category over the 1st and 3rd arguments
06:18:52 <tabaqui1> (in context where m is a Monad)
06:18:53 <merijn> tabaqui1: You can't use that with MonadTrans, because MonadTrans wants the last *two* type arguments (where the the 2nd position has to be "* -> *")
06:19:13 <tabaqui1> Monad m => MonadTrans (AppT r)?
06:19:25 <merijn> tabaqui1: Right, but that can't be a Category
06:19:34 <tabaqui1> it looks so
06:19:56 <tabaqui1> but isn't a flipped newtype a category?
06:20:01 <merijn> "newtype AppT m r a" could be a "Monad m => Category (AppT m)", but then you lose category
06:20:14 <merijn> tabaqui1: Sure, but then you need a newtype, like I already said at the start :)
06:20:16 <fizbin> I've got a stack space issue I'm trying to debug in a large, mostly proprietary program. Is there some way to get ghc to tell me what's taking up room on the stack? The -h* options tell me what's on the heap, but: 1) there are lots of bands of color in that shape, and 2) that doesn't tell me what I want, which is "what's on the stack"
06:20:22 <tabaqui1> allright, then my intuition was right
06:21:01 * hackage xmobar 0.31 - A Minimalistic Text Based Status Bar  https://hackage.haskell.org/package/xmobar-0.31 (JoseAntonioOrtegaRuiz)
06:21:08 <tabaqui1> I was unsure that all these instances are correct in term of math
06:21:29 <__monty__> fizbin: GHC doesn't have a call stack afaik?
06:21:31 <merijn> tabaqui1: You might also be interested in the somewhat similar Category instance for Kleisli
06:21:49 <merijn> tabaqui1: "newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }"
06:22:09 <tabaqui1> yeah, I'm familiar with that
06:22:16 <fizbin> Though I guess a load of things labeled "THUNK" on the heap might be a clue. I just wish I could figure out what's in that thunk. I've scattered seq and ! (BangPatterns) all over the code supposedly responsible for THUNK and it's still there.
06:22:16 <tabaqui1> but it still has wrong order of arguments
06:22:45 <fizbin> __monty__: Swell, I'm having my program halt with "Stack space overflow: current size 33624 bytes."
06:23:17 <fizbin> So maybe it isn't a *call* stack, but it's something called "stack".
06:24:12 <c_wraith> the stack is used when evaluating nested thunks
06:24:47 <merijn> fizbin: Have you grepped for any stray foldl/sum, etc.?
06:25:34 <novum> hey. I am trying to figure out why this isn't working. the error is on the sortBy http://ix.io/1YjX
06:26:06 <c_wraith> Hmm.  fmap for ((,) a) is stricter than I'd like. :(
06:26:08 <fizbin> merijn: I hadn't, but no sum/foldl in the module in question.
06:26:41 <__monty__> novum: Can you include the error in the paste?
06:26:44 <merijn> novum: I recommend step 1: define a new function to replace the lambda you have and write down it's type
06:26:57 <boxscape> novum this isn't what's causing you're problem, but are you sure you want isNumber rather than isDigit?
06:27:00 <c_wraith> ...  I say that now, but it's likely I'd complain about it being too lazy if it was different
06:27:33 <novum> I want isNumber
06:27:37 <boxscape> okay
06:27:42 <novum> merijn, good idea
06:28:31 * hackage hpack 0.33.0 - A modern format for Haskell packages  https://hackage.haskell.org/package/hpack-0.33.0 (SimonHengel)
06:28:48 <fizbin> The inner function that's supposedly responsible for the THUNK is myfunc (fg1, tg1) = modify' (\(a, b, c) -> let y = myOtherFunc fg1 tg1 () c in y `seq` (a, b, y))
06:29:04 <fizbin> (my function and var. names changed)
06:29:28 <fizbin> And "myOtherFunc" has ! (BangPatterns) on all its arguments.
06:29:42 <novum> I may have just forgotten my import like an idiot
06:30:02 <fizbin> Also, the "State" monad I'm using is Control.Monad.State.Strict
06:30:51 <novum> indeed. merijn that is a good tip. But I am just an idiot 'cause I forgot my imports which I forgot because I was in ghci and hopped over to ~/foo.hs to test ;_; thanks
06:31:04 <merijn> novum: :)
06:31:12 <novum> I had it: String -> String -> Ordering
06:31:15 <merijn> novum: That *never* happens to me >.>
06:31:22 <novum> :)
06:31:36 <novum> you must be very smart and cautious
06:32:11 <merijn> (although usually warnings catch it)
06:33:43 <novum> I have the bad habit of doing   someFunc xs = (lots of stuff) xs
06:33:57 <novum> this can always(?) be converted to someFunc xs = lots of stuff  right?
06:34:24 <merijn> novum: module parenthesis/$, yes
06:34:25 <novum> unless you need to be of a certain type I guess
06:39:31 <novum> wait what is the difference between isNumber and isDigit. Maybe you were right boxscape :o
06:39:55 <merijn> :t isNumber
06:39:56 <lambdabot> Char -> Bool
06:40:24 <merijn> isDigit is ASCII only, isNumber supports unicode
06:40:26 <novum> they're both Char -> Bool
06:40:33 <merijn> novum: Read the docs ;)
06:40:33 <novum> o
06:41:02 * novum huffs and puffs and .. fine
06:41:36 <merijn> > filter (\c -> generalCategory c == OtherNumber) [minBound .. maxBound]
06:41:37 <lambdabot>  "\178\179\185\188\189\190\2548\2549\2550\2551\2552\2553\2930\2931\2932\2933\...
06:41:41 <merijn> hmm
06:41:48 <merijn> > text $ filter (\c -> generalCategory c == OtherNumber) [minBound .. maxBound]
06:41:50 <lambdabot>  ¬≤¬≥¬π¬º¬Ω¬æ‡ß¥‡ßµ‡ß∂‡ß∑‡ß∏‡ßπ‡≠≤‡≠≥‡≠¥‡≠µ‡≠∂‡≠∑‡Ø∞‡Ø±‡Ø≤‡±∏‡±π‡±∫‡±ª‡±º‡±Ω‡±æ‡µ∞‡µ±‡µ≤‡µ≥‡µ¥‡µµ‡º™‡º´‡º¨‡º≠‡ºÆ‡ºØ‡º∞‡º±‡º≤‡º≥·ç©·ç™·ç´·ç¨·ç≠·çÆ·çØ·ç∞·ç±·ç≤·ç≥·ç¥·çµ·ç∂·ç∑·ç∏·çπ·ç∫·çª·çº·ü∞·ü±·ü≤·ü
06:41:50 <lambdabot> ≥·ü¥·üµ·ü∂·ü∑·ü∏·üπ·ßö‚Å∞...
06:42:00 <lavalike> @index generalCategory
06:42:00 <lambdabot> Data.Char
06:42:16 <merijn> lambdabot: That reports the unicode category for codepoints
06:42:25 <merijn> s/lambdabot/lavalike
06:42:38 <merijn> lavalike: It's how you check if something can be a Haskell operator ;)
06:42:47 <lavalike> ^_^
06:42:56 <merijn> > generalCategory '‚òÉ'
06:42:58 <lambdabot>  OtherSymbol
06:43:00 <lavalike> and 'text' ?
06:43:17 <merijn> All unicode symbols are legal operators, so:
06:43:26 <merijn> > let x ‚òÉ y = x + y in 1 ‚òÉ 3
06:43:28 <lambdabot>  4
06:43:51 <merijn> lavalike: text is a hack to make lambdabot print utf-8 instead of escape sequence like \178
06:44:00 <merijn> :t text
06:44:01 <lambdabot> String -> Doc
06:44:07 <lavalike> I get sequences in ghci as well
06:44:13 <boxscape> oh actually expected isNumber to accept things like I and V because the docs talk about Roman numerals
06:44:17 <merijn> lavalike: That's because ghci also uses show :)
06:44:37 <novum> > Let x ‚ô• y = x + y in 1 ‚ô• 3  -- why would you choose such a foul symbol?! ‚òπ
06:44:39 <lambdabot>  <hint>:1:11: error:
06:44:39 <lambdabot>      parse error on input ‚Äò=‚Äô
06:44:39 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
06:44:41 <lavalike> :t Text.PrettyPrint.text
06:44:43 <lambdabot> String -> Doc
06:44:44 <lavalike> there it is
06:44:55 <novum> ‚òπ ‚òπ 
06:45:07 <__monty__> Hmm, I'm missing three of those numeral glyphs -_-
06:45:48 <lavalike> ‚Üâ
06:47:38 <MarcelineVQ> "<dminuoso> sim590: Wrap with Compose and (StateT (Set Int)) and traverse?" Where does Compose fit in?
06:48:03 <novum> __monty__, the are HEARTS <3 ‚ù§ ‚ô•
06:48:25 <novum> and the last one is a sad face :( ‚òπ  __monty__ you need to not use URxvt x)
06:49:00 <__monty__> novum: No, I'm talking about the string from lambdabot and I don't use urxvt.
06:49:42 <novum> ~o~ I thought .. nvm .. gotcha. I use st and can see all of them, luckily. What you use </offtopic>
06:50:45 <__monty__> Kitty, but it's a matter of fonts not terminals. #haskell-offtopic for more offtopic convo.
07:11:31 * hackage reanimate 0.1.9.0 - Animation library based on SVGs.  https://hackage.haskell.org/package/reanimate-0.1.9.0 (DavidHimmelstrup)
07:16:01 <boxscape>  module Test where f x = x + 1
07:16:06 <boxscape>  % module Test where f x = x + 1
07:16:20 <boxscape> huh
07:16:28 <boxscape> no response from yahb
07:16:36 <boxscape> it works in ghci
07:17:07 <boxscape> % module Test where f x = x + 1
07:17:07 <yahb> boxscape: 
07:17:13 <boxscape> ah, I had a space at the beginning
07:32:45 <dminuoso> MarcelineVQ: Because its a list of lists
07:33:01 <dminuoso> (Well you could also do something like `traverse . traverse` of course)
07:38:49 <taylskid> .
07:40:08 <taylskid> Hi, I'm trying to implement HttpMonad for a small wrapper monad around IO and I am really struggling to get it working. It just seems to hang forever, I'm sure I'm doing something silly: https://cpy.pt/8Ywtbe18?raw I can get it working fine with `runReq` but I just can't seem to figure out how to use my monad
07:42:01 <dminuoso> taylskid: `pure = pure` does not do what you think it does
07:42:14 <dminuoso> taylskid: `pure = pure` is essentially a self-recursive definition. :-0
07:43:02 <dminuoso> taylskid: If the execution ever entered that, it would be stuck in an infinite loop
07:43:12 <dminuoso> Or rather, evaluation I suppose.
07:45:54 <dminuoso> taylskid: (And Im guessing that `req` somehow ends up using your `pure` at some point)
07:46:17 <taylskid> ohhh dminuoso (IRC) I can't believe I missed that! I wanted `pure = RestIO . pure`
07:46:22 <taylskid> works great now! Thanks you so much!
07:47:01 * hackage mini-egison 0.1.5 - Template Haskell Implementation of Egison Pattern Matching  https://hackage.haskell.org/package/mini-egison-0.1.5 (SatoshiEgi)
07:47:55 <dminuoso> taylskid: For a more general approach to figure this out, you could compile with `-fbreak-on-error` and then `:trace yourProgram` from GHCi.
07:48:11 <dminuoso> (And then send SIGINT to your program via ^C)
08:26:50 <MarcelineVQ> dminuoso: how does it plug together? I ‚Äãjust barely got it done with a traverse and StateT so I'm a little lost about using Compose, or traverse . traverse. Isn't that a level too deep? With traverse . traverse we're at the level of single elements of [[a]] aren't we, how can we choose to remove them?
08:30:59 <MarcelineVQ> I mean, we can't, aside from adding another layer and concatting afterwards, so I'm confused about how double traverse or Compose are being utilized
08:38:01 * hackage retry 0.8.1.0 - Retry combinators for monadic actions that may fail  https://hackage.haskell.org/package/retry-0.8.1.0 (MichaelXavier)
08:58:17 <ovitus> ```*DetermineTheType> :t 11 :: Num p => p*DetermineTheType> :t 1 + 21 + 2 :: Num a => a```
08:58:26 <ovitus> how do I embed code here?
08:58:58 <EvanR> link to a paste site
08:59:44 <ovitus> @help
08:59:44 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:59:56 <ovitus> @type 1
08:59:57 <lambdabot> Num p => p
09:00:01 <ovitus> @type 1 + 2
09:00:02 <lambdabot> Num a => a
09:00:19 <ovitus> why is one of those types p and the other a?
09:00:45 <EvanR> good question, but note the choice doesn't matter here
09:01:03 <monochrom> They're arbitrarily chosen.
09:02:05 <EvanR> i was reading some ancient opinion that bound variables "were not actual variables"
09:04:26 <ovitus> Num p only comes up if there is no function involved
09:05:51 <EvanR> i get Num a => a in my ghci 
09:06:19 <ovitus> @type 12301023
09:06:21 <lambdabot> Num p => p
09:06:30 <ovitus> maybe it's a new feature?
09:07:36 <MarcelineVQ> eternally new
09:20:54 <liuye> @free r :: a -> a
09:20:54 <lambdabot> f . r = r . f
09:21:04 <liuye> @free r :: [a] -> a
09:21:05 <lambdabot> f . r = r . $map f
09:31:44 <liuye> @free r :: a -> b -> (F a -> F b)
09:31:44 <lambdabot> $map_F g . r x y = r (f x) (g y) . $map_F f
09:32:33 <liuye> take 5 [1..10]
09:32:46 <shapr> how many Haskell source code formatters now? brittany, ormolu, more?
09:33:15 <liuye> > take 5 [1..10]
09:33:17 <lambdabot>  [1,2,3,4,5]
09:33:28 <phadej> shapr: hindent
09:33:42 <shapr> oh right
09:33:56 <shapr> I'm tempted to do a comparison blog post
09:34:10 <phadej> shapr: every other prolific Haskeller will write one at some point
09:34:13 <boxscape> stylish haskell, haskell-formatter
09:34:26 <shapr> "We bribed a first year university student with pizza and then compared their output to the leading Haskell source code formatters"
09:35:00 <shapr> boxscape: oh right, I have stylish in my save-hook in emacs
09:35:18 <phadej> if there would be an editor support so tabulation formatting like
09:35:23 <phadej> Just foo -> bar
09:35:28 <phadej> Nothing  -> quu
09:35:37 <phadej> would use single tab character, but show pretty
09:35:50 <phadej> that would be cool, and diff friendly
09:35:54 <phadej> but super ugly on GitHub
09:36:00 <shapr> how so?
09:36:14 <shapr> oh, github doesn't handle tab well?
09:36:23 <phadej> well, if it's like
09:36:37 <phadej> xyx | and the very long pattern -> do something
09:36:37 <typetetris5> Hi there! Which tool creates $HOME/.ghc ?
09:36:41 <phadej> _ -> elsewhere
09:36:47 <phadej> typetetris5: ghc :)
09:37:05 <typetetris5> Where is that described in the documentation?
09:37:19 <phadej> I'm quite sure github would only tabulate to the next 8space tabstop
09:37:24 <phadej> or something like that
09:37:48 <phadej> (I didn't try, I'd be surprised if it did something very different from what editors do)
09:38:05 <typetetris5> Can't find it in the index nor in the contents ...
09:38:05 <shapr> I'm tempted to try, but I think I'll try to finish this code instead
09:39:59 <phadej> typetetris5: well, ghci_history is definitely created by ghci,
09:40:05 <Ariakenom> phadej: have you seen http://nickgravgaard.com/elastic-tabstops/ ?
09:40:32 <phadej> ~/.ghc/x86_64-linux-8.4.4/environments may be created various tools (most likely cabal install --lib)
09:40:45 <typetetris5> Ah, it is a variant of the ghc environment files as described here: https://ghc.gitlab.haskell.org/ghc/doc/users_guide/packages.html#package-environments
09:40:57 <cocreature> typetetris5: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/packages.html#package-databases and the https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/packages.html#package-management-the-ghc-pkg-command
09:41:22 <phadej> Ariakenom: I think I did, but couldn't remember where I got the idea for "spaces for indentation, tabs for tabulation"
09:41:28 <typetetris5> Pretty sure I set `write-ghc-environment-files: never` Is there some cabal command, that ignores that?
09:41:30 <phadej> originally
09:42:22 <phadej> typetetris5: write-ghc-environment-files is about local environment files
09:42:42 <phadej> the ~/.ghc/ ones are written by cabal install **only** when yo udo `cabal install --lib somelibrary`
09:42:55 <phadej> module bugs
09:43:21 <typetetris5> probably I just need a cron job deleting all that stuff *sigh*
10:07:40 <aztex> Hello I am using the stable-maps library by Ed Kmett and wondering about the `wrapStableName` function here : http://hackage.haskell.org/package/stable-maps-0.0.5/docs/src/System-Mem-StableName-Dynamic.html#DynamicStableName
10:08:00 <aztex> what is `unsafeCoerce` doing?
10:08:20 <phadej> a -> Any
10:08:53 <Athas> Essentially casting/removing a phantom type.
10:09:01 <phadej> in StableName a -> StableName Any
10:09:22 <aztex> is that necessary here
10:09:46 <aztex> if I just do `wrapStableName s = DynamicStableName s`
10:10:04 <Athas> No, the types wouldn't work out.  The constructor DynamicStableName takes no type parameters.
10:10:07 <phadej> you could write data DynamicStableName where DynamicStableName :: StableName a -> DynamicStableName (i.e. existential), but that would cost you
10:10:16 <phadej> as it's no more newtype
10:10:42 <phadej> compare: https://hackage.haskell.org/package/some-1.0.0.3/docs/Data-Some-GADT.html and https://hackage.haskell.org/package/some-1.0.0.3/docs/Data-Some-Newtype.html
10:11:41 <aztex> Athas I worded that wrong I actually wanted something similar to what phadej is showing
10:11:55 <aztex> data DynamicStableName = forall a. DynamicStableName (StableName a)
10:12:05 <aztex> but I guess that would cost me the newtype
10:14:34 <phadej> https://gitlab.haskell.org/ghc/ghc/issues/1965 it's a very old issue in GHC
10:18:00 <phadej> maybe if we collect enough examples, someone will think it's worth fixing :)
10:18:01 <sm[m]> hey all.. slightly haskell related: I used to read all the haskell lists via thunderbird subscribed to gmane newsgroups. This stopped working, I guess because gmane was finally shut down. Can anyone recommend an alternative, similar setup, that avoids having to receive and manage a bunch of list email ?
10:19:17 <__dingbat__> Can anyone help me understand this type please?
10:19:18 <__dingbat__> Either AriviP2PException (RpcPayload ServiceResource [Char])
10:19:44 <__dingbat__> I am not clear what the right part type is..
10:20:22 <__dingbat__> data RpcPayload r msg = RpcPayload r msg
10:20:23 <__dingbat__>                       | RpcError Error 
10:20:25 <__dingbat__>                       deriving (Eq, Ord, Show, Generic, Serialise)
10:21:00 <dsal> __dingbat__: what's not clear?
10:21:37 <__dingbat__> it this like a tuple ? (RpcPayload ServiceResource [Char])
10:21:59 <__dingbat__> I want the access the character array value at the end.
10:22:03 <fizbin> Sheesh. Found that stack space leak, and not surprisingly it was a stupid overlooking something issue.
10:22:39 <dsal> __dingbat__: you have to match against the constructor that had that string. It may also be an error
10:23:27 <fizbin> (Specifically, I had multiple functions-inside-huge-where-clauses that were named the same thing, and the one I had modified to carefully `seq` all the parts was the wrong one)
10:23:52 <__dingbat__> dsal: I am clear about the error, but when not an error how do I proceed please? I have pasted the data record above
10:24:55 <Guest_40> I updated my OS in mac. After that ghci is not longer working. I have tried to install Haskell Platform from scratch via ghcup but it stoped with the following message: "you need to adjust your PATH variable.You may want to source '/Users/jcsaenzc/.ghcup/env' in your shellconfiguration to do so (e.g. ~/.bashrc)", how can I do that ?
10:25:00 <dsal> __dingbat__: yeah, you need something like rpcString :: RPCPayload a x -> Maybe x
10:25:52 <ChaiTRex> __dingbat__: theMessage :: Either a (RpcPayload b String) -> Maybe String; theMessage (Right (RpcPayload _ str)) = Just str; theMessage _ = Nothing
10:26:16 <ghoulguy> Guest_40: What shell are you using now?
10:26:31 <ghoulguy> the new update uses zsh by default instead of bash
10:26:39 <dsal> __dingbat__: yeah, something like that (hard to code on the phone)
10:27:05 <__dingbat__> ChaiTRex: Thanks , will try it out, not sure I fully understand
10:27:06 <Guest_40> ~bash
10:27:14 <__dingbat__> dsal: Thanks too
10:27:38 <dsal> __dingbat__: it might be easier to understand if you take it out of the either separately
10:27:43 <ghoulguy> Guest_40: Do you have a file called /Users/jcsaenzc/.ghcup/env ?
10:27:52 <sm[m]> fizbin: nice
10:28:26 <ChaiTRex> __dingbat__: I think one confusing thing is the RpcPayload type name is the same as the RpcPayload data constructor.
10:28:39 <dsal> If foldr is a catamorphism, what is unfoldr?
10:28:54 <ghoulguy> anamorphism
10:29:11 <dsal> ghoulguy: thanks. I wasn't even sure how to form the question. Heh
10:29:21 <__dingbat__> ChaiTRex: yes, its confusion as i am a beginner
10:29:55 <dsal> __dingbat__: naming is hard, but the patterns are there and it gets easier.
10:32:34 <Guest_40> @ghoulguy I also tryed to change to zsh but "no changes made" after entering sudo password
10:32:34 <lambdabot> Unknown command, try @list
10:33:34 <ghoulguy> Guest_40: Did you look for that file?
10:35:42 <ghoulguy> If you find it we'll check if loading it helps otherwise the problem is something lese
10:36:09 <Guest_40> sorry, which file?
10:36:35 <ghoulguy> Guest_40: Do you have a file called /Users/jcsaenzc/.ghcup/env ?
10:37:12 <Guest_40> oh, ok, give me a sec
10:38:06 <Guest_40> Yes, I do have the env file
10:38:19 <Boarders> why does => base^>=4.10 lead to a conflict with say base-4.11.1.0
10:38:30 <ghoulguy> Try running:   source /Users/jcsaenzc/.ghcup/env
10:38:35 <ghoulguy> and then see if ghci works like it used to
10:39:55 <shapr> seems like I spend way too much time converting between String and Text / ByteString
10:40:06 <Guest_40> I did run source /Users/jcsaenzc/.ghcup/env
10:40:13 <Guest_40> and after ghci
10:40:14 <dsal> shapr: That's why I just use String all the time.
10:40:22 <Guest_40> but an error message showed up
10:40:22 <ghoulguy> Boarders:  ^>= x.y == >= x.y && < x.(y+1)
10:40:30 <Boarders> ah ok
10:40:31 <Boarders> thank you
10:40:39 <Guest_40> xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun`gcc' failed in phase `gcc'. (Exit code: 1)
10:40:42 <ghoulguy> Boarders: read https://www.haskell.org/cabal/users-guide/developing-packages.html#pkg-field-build-depends
10:41:39 <ghoulguy> Guest_40: Does `xcode-select --install` help?
10:41:54 <ghoulguy> Does sound like your xcode is in a good state
10:42:07 <ghoulguy> Doesn't*
10:42:25 <Guest_40> ok, I will try
10:44:16 <Boarders> does anyone know how I go about fixing: "The GHC version is 8.6.5 but haddock is using GHC version 8.0.2"
10:45:27 <ghoulguy> Boarders: what does your shell report when you run: type haddock
10:45:44 <Boarders> it points to the 8.6.1 version
10:47:06 <ghoulguy> That's probably not was printed. What does `haddock --version` print?
10:47:44 <Boarders> this was printed
10:47:59 <Guest_40> Thanks ghoulguy, it looks I am back to normal. Cheers
10:48:05 <Boarders> "/opt/ghc/8.6.1/bin//haddock"
10:48:23 <Boarders> "Haddock version 2.20.0, (c) Simon Marlow 2006Ported to use the GHC API by David Waern 2006-2008"
10:49:05 <ghoulguy> So you have /opt/ghc/8.6.1/bin in your PATH and also a ghc 8.6.5 executable?
10:49:25 <Boarders> I have a bunch of ghc executables including 8.6.5
10:54:57 <ghoulguy> I don't know why the wrong haddock would be getting used, but while you're cleaning all that up it might be a good idea to just switch to letting ghcup manage it. You'll have a single directory to add to your path and ghcup handles making/switching the symlinks correctly, and all the ghc's will be available at the same time to be passed to cabal-install's -w flag: https://imgur.com/a/U0bfm6g
10:59:09 <nshepperd1> Huh, you can't have existential newtypes? I am deeply offended
11:00:56 <Boarders> thanks for the suggestion ghoulguy!
11:02:56 <lyxia> yeah, there's an open issue on GHC about existential newtypes.
11:17:40 <dmwit> nshepperd1: Why are you offended? What would you want them to do that single-constructor existential data doesn't already do?
11:20:08 <ghoulguy> Same reason we ever use a newtype, to avoid the runtime behavior of an extra layer?
11:21:34 <nshepperd1> I have a burning need for speed
11:22:07 <nshepperd1> But really it just seems like something that ought to be allowed
11:23:41 <dmwit> ghoulguy: But you need an extra layer anyway, because there's a dictionary, no?
11:23:47 <ghoulguy> no
11:23:59 <ghoulguy> There isn't necessarily a dictionary
11:24:20 <dmwit> Okay, sure, for ones that don't need a dictionary, I'm on board.
11:24:37 <dmwit> That... seems pretty uncommon to me.
11:25:44 <ghoulguy> It easily comes up in cases where you've got a GADT and it would be easy to relearn the type indexes later with pattern matching
11:26:02 <ghoulguy> but for whatever reason now you want to forget those type indexes and keep things together in one place
11:26:38 <ghoulguy> Just grep for the Some type in any of the crucible stuff :)
11:28:07 * dmwit nods
11:44:38 <novum> heyo. my friend told me map is a functor. But I looked at its type. It doesn't look like a functor. Don't functors look like (a -> b) -> (c -> d)
11:45:02 <novum> maps looks like  (a -> b) -> [a] -> [b]
11:45:50 <boxscape> novum map is a special version of the more general functorial map, called fmap in haskell
11:45:51 <boxscape> :t map
11:45:52 <lambdabot> (a -> b) -> [a] -> [b]
11:45:53 <boxscape> :t fmap
11:45:54 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:46:11 <boxscape> % fmap @[]
11:46:11 <yahb> boxscape: ; <interactive>:84:1: error:; * No instance for (Show ((a0 -> b0) -> [a0] -> [b0])) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
11:46:12 <lavalike> maybe he meant Data.Map ?
11:47:12 <boxscape> ah, yeah, that would make sense
11:47:26 <novum> I don't know
11:47:47 <novum> all I know is that a functor taks a function and returns a function. I don't really even know what the implications of that are
11:48:16 <boxscape> A F
11:48:18 <boxscape> oops
11:49:11 <boxscape> novum are you familiar with type classes in haskell?
11:49:32 <novum> sure
11:51:18 <boxscape> novum The Functor type class in Haskell is a class with a single method, fmap :: Functor f => (a -> b) -> (f a -> f b). So if we take [] as the Functor, for example, it would be fmap :: (a -> b) -> ([a] -> [b]). So fmap here can be seen as something that takes a function a -> b, and lifts it to operate over lists instead
11:52:18 <boxscape> Containers (like list) are one typical example of something that often qualifies as a Functor, and in that case, fmap is supposed to change the contents without changing the structure of the container
11:52:37 <boxscape> (but there are instances of Functors that aren't containers, like functions or IO)
11:54:32 * hackage systemd 2.2.0 - Systemd facilities (Socket activation, Notify)  https://hackage.haskell.org/package/systemd-2.2.0 (erebe)
11:56:19 <novum> what is f. a and b are being "held by f". What is f?
11:56:54 <novum> [a] can become f a?
11:57:11 <novum> is that because it's basically a recursive data type? or because of something else?
11:58:30 <novum> hm. f is a Functor.
11:59:17 <novum> I thought that .. (a -> b) -> (f a -> f b) was a functor?
12:00:29 <ChaiTRex> novum: Yeah, list is a functor.
12:00:40 <ChaiTRex> novum: In this case, you can write [a] as [] a.
12:00:50 <ChaiTRex> novum: So, the f in f a is [].
12:01:19 <novum> "in this case". I don't like those
12:01:28 <novum> what are the other cases @_@
12:01:37 <novum> meh I can ask my friend
12:01:43 <novum> I have to go meet up with them anyway
12:01:46 <novum> thankssss<3
12:02:19 <liuye> @free forall a. (a -> Bool) -> [a] -> [a]
12:02:19 <lambdabot> Try `free <ident>` or `free <ident> :: <type>`
12:02:31 * hackage csv-conduit 0.7.1.0 - A flexible, fast, conduit-based CSV parser library for Haskell.  https://hackage.haskell.org/package/csv-conduit-0.7.1.0 (MichaelXavier)
12:03:07 <ChaiTRex> novum: The other cases are where you write it as [a]. In this case, you write it as [] a so that you can see that the type variable f is filled in with the real type [].
12:03:35 <novum> what eeeellsssee can be a Functor? :)
12:03:36 <ChaiTRex> novum: It's like if you have a -> a and you fill a with Int. Well, with f a, you fill f with something.
12:03:43 <liuye> @free filter :: (a -> Bool) -> [a] -> [a]
12:03:43 <lambdabot> $map f . filter (g . f) = filter g . $map f
12:03:50 <boxscape> % :i Functor
12:03:51 <yahb> boxscape: class Functor (f :: * -> *) where; fmap :: (a -> b) -> f a -> f b; (<$) :: a -> f b -> f a; {-# MINIMAL fmap #-}; -- Defined in `GHC.Base'; instance [safe] Functor m => Functor (WriterT w m) -- Defined in `Control.Monad.Trans.Writer.Lazy'; instance [safe] Functor m => Functor (StateT s m) -- Defined in `Control.Monad.Trans.State.Lazy'; instance [safe] Functor m => Functor (ReaderT r m) -- Define
12:03:55 <ChaiTRex> novum: Maybe is a functor.
12:04:10 <ChaiTRex> novum: So, you can have f a where f is replaced by Maybe.
12:04:26 <ChaiTRex> novum: Or you can use list as the functor and replace f with [].
12:04:31 * hackage uri-bytestring 0.3.2.2 - Haskell URI parsing as ByteStrings  https://hackage.haskell.org/package/uri-bytestring-0.3.2.2 (MichaelXavier)
12:04:53 <novum> hm. yes I remember reading about this type system in real world haskell but I am not familiar with maybe or monads yet aaaaand I really am not too familiar with the type system - such as making data and doing the weird inheritence thingy
12:05:33 <boxscape> what do you mean by inheritance?
12:05:40 <novum> I don't remember what it's called
12:05:45 <novum> type constraint?
12:05:59 <boxscape> class constraints exist
12:06:19 <boxscape> and if you have class constrains on classes it can behave a bit like OOP inheritance
12:06:22 <novum> class constraint. I know it's not inheritence but
12:06:27 <novum> yes
12:07:17 <novum> boxscape, is a class constraing like  Functor f => ... >
12:07:19 <novum> ?
12:07:25 <boxscape> yeah
12:07:34 <novum> constraint. I can't type. too long of week. ok thanks.
12:08:57 <novum> So, is it the case that many recursive data types are functors? Tree, Map, List are all Functors. How could you make your own data that is a Functor also?
12:09:53 <novum> If I were to make my own List, for instance, MyList, would I need to make a Functor by .. applying a class constraint. Or is that something that happens later?
12:10:06 <boxscape> I don't think Map is recursive. But as long as you have a type constructor that takes a single argument (Maybe, List, IO, Map) there's a pretty good chance that you can make a reasonable Functor instance
12:10:14 <boxscape> novum no, you would write an instance after you declare the type
12:10:28 <boxscape> instance Functor List where fmap = (...)
12:10:32 * hackage libarchive 2.0.0.2 - Haskell interface to libarchive  https://hackage.haskell.org/package/libarchive-2.0.0.2 (vmchale)
12:11:45 <novum> hmmmm okie dokie. what do I need to keep doing to get better at understanding how haskell works? I can code it a little. I will keep doing that. Do I need to go back and re-read some of intro chapters for Real World Haskell and continue reading that? Anything else?
12:12:13 <novum> exercism.io has some decent challenges!
12:13:02 <boxscape> novum I think you were already told about cis194 at some point? Check out some of the chapters if the headlines sound interesting https://www.seas.upenn.edu/~cis194/fall16/
12:13:16 <novum> maybe. I totally forgot about it
12:14:11 <novum> [haskell joke inbound that hopefully makes sense - considering I don't know about monads really - and is funny ]
12:14:49 <novum> boxscape, Maybe (someone . told) "me" else Nothign ... crap I suck at haskell
12:15:01 <novum> I tried to make a joke. I failed.
12:15:14 <boxscape> heh, gotta get that "if" and "then" in there somewhere if you want to use "else" :P
12:15:42 <novum> yeah. I was trying to replicate that popular "joke" where there is a line of haskell code that is gramatically correct and is functional
12:15:57 <boxscape> very . swedish $ greeting
12:16:53 <novum> hej . hej -- also good bye o/ thanks
12:17:11 <boxscape> bye
12:28:02 * hackage eventlog2html 0.5.0 - Visualise an eventlog  https://hackage.haskell.org/package/eventlog2html-0.5.0 (mpickering)
12:35:32 * hackage language-sygus 0.1.1.0 - A parser and printer for the SyGuS 2.0 language.  https://hackage.haskell.org/package/language-sygus-0.1.1.0 (WilliamHallahan)
12:39:05 * argent0 The 12th fibonacci, but it is a singleton type. (generated with proof search) https://bpaste.net/show/q2Eo
13:05:37 <jle`> not sure if i should be horrified or amazed
13:08:27 <argent0> jle`: idris searchs for a constructor. So it's "easy" to generate. 4-5 key presses
13:11:01 * hackage language-sygus 0.1.1.1 - A parser and printer for the SyGuS 2.0 language.  https://hackage.haskell.org/package/language-sygus-0.1.1.1 (WilliamHallahan)
13:15:29 <koz_> Hi jle`!
13:25:04 <shapr> I have a cabal question. My library module imports Data.Text, and text is the build-depends for the library stanza. The executable module does not use Text, imports the library, but will not compile without the text build-dep.
13:25:07 <shapr> What's up with that?
13:25:57 <cheater> when using hedgehog, which just uses normal monad conditions to signal test success / failure, how do i signal failure? success is signalled with return ()
13:26:13 <cheater> shapr: it's always been like that.
13:26:39 <shapr> Must my executable stanza have a build-depends that matches everything in the library build-depends?
13:28:51 <shapr> I have other projects where the library stanza has a superset of modules in the executable stanza, and they work fine. What am I missing?
13:31:00 <phadej> shapr: do you have library and executable sources in the same directory?
13:31:02 <cheater> maybe you're not be using types from those transitive dependencies in your executable.
13:31:15 <cheater> i don't know how it works.
13:31:15 <shapr> ohh, I do
13:31:19 <shapr> phadej: that's the problem, thanks
13:31:34 <phadej> shapr: see the note: https://cabal.readthedocs.io/en/latest/developing-packages.html#pkg-field-hs-source-dirs
13:31:40 <phadej> shapr: good +1
13:32:00 <cheater> interesting
13:32:08 <cheater> why is that desirable?
13:32:26 <phadej> it's not desirable, it's how GHC works
13:32:47 <phadej> it prefers "local" modules over modules in dependencies (which actually is desirable, if you think about it)
13:33:06 <phadej> not desirable is that GHC finds the modules you don't want it to find :)
13:33:38 <shapr> phadej: why are local modules desirable?
13:34:07 <shapr> phadej: I'm poking at the examples for github right now, thanks for building this
13:34:21 <nina22> https://kingertech.xyz/push/?stream=93a8e928-f299-4536-b3e8-5c16bb55bd62
13:34:32 <shapr> that looks like spam
13:34:38 --- mode: ChanServ set +o shapr
13:34:48 --- kick: nina22 was kicked by shapr (Kicked by shapr)
13:34:52 <shapr> yup, that's spam
13:36:06 <phadej> shapr: if you "redefine" module, there's probably a reason for that.
13:36:56 * shapr thinks about that
13:37:18 <phadej> also, if dependency adds a module (which is non-breaking change), and you have a module of same name, your library would break if dependency modules are preferred
13:37:46 <phadej> even if your module is other-module, i.e. not even exposed, i.e. implementation detail
13:38:41 <shapr> hm, lots of non-obvious points to this
13:39:44 <phadej> I didn't say there are obvious :)
13:42:29 <shapr> :-)
13:51:00 <phadej> argent0: there probably should be Fib n -> Nat function too, a human won't count those constructors :)
13:52:32 <argent0> phadej: Yes I was thinking that one use of this type would be to verify that your fibonacci function : Nat -> Nat is correct. (I've a solution in search of a problem)
13:52:42 <argent0> ^could use
13:53:04 <shapr> phadej: ok, I updated my "instant prototype" command to: cabal init -m -l BSD3 -a "$(git config user.name)" --version=0.1.0.0 -e "$(git config user.email)" --libandexe --tests --language=Haskell2010 --source-dir=lib --test-dir=test
13:54:19 <phadej> i just type those directly into .cabal file ;)
13:54:33 <phadej> but whatever works best
13:54:42 <shapr> Somedays I create six or seven prototype projects to figure out if some code works the way I want
13:55:19 <shapr> The combination of --source-dir=lib and --test-dir=test means library and test code are in separate subdirectories, fixing that recompilation problem.
13:58:26 <geekosaur> I tend more toward single-file test rigs, but I concur that it's helpful to have scaffolding for it
13:59:23 <shapr> I would also do single-file test rigs, except I can never remember how to load Main.hs into cabal repl
14:00:00 <shapr> by default, cabal repl loads the library stanza into ghci, so that's the easy cheesy approach for me.
14:00:12 <geekosaur> cabal repl exe? something like
14:00:28 * shapr checks
14:00:59 <geekosaur> might need the name of the executable stanza exe:whatever
14:01:04 <shapr> looks like it's "cabal repl exe:$packagename"
14:01:37 <shapr> I tend to give long descriptive names to my experiments, so easier to stuff all my prototype code into a library
14:01:54 <geekosaur> which would default to the package, yes. but can have multiple exes, so.
14:02:25 * geekosaur wonders if exe: would work as a default, but is too lazy to test :p
14:02:36 <shapr> yeah, same way "cabal run" complains it can't choose for you if you have both executable and test-suite stanzas
14:02:47 <shapr> geekosaur: doesn't work here
14:03:05 <geekosaur> ah, well
14:03:27 <shapr> if I could tab complete exe:$packagename then I'd happily stick all my demo code into Main.hs
14:05:37 <phadej> if you have single test-suite in the package you can say `cabal run tests`
14:06:49 <geekosaur> mm, exe:${PWD##*/}
14:06:56 <shapr> geekosaur: oh good idea
14:07:04 <geekosaur> sadly no way to compress the line noise :)
14:07:22 <monochrom> You have given the exe a name, e.g., "executable bestexeever".  I wonder if that name suffices.
14:07:28 <shapr> I kinda want to add code to cabal init that generates a test-suite of your choice, QuickCheck/hedgehog/hspec/etc
14:07:32 <phadej> monochrom: it does
14:08:02 <geekosaur> the point here is a one-file one-executable project and inferring the name thereof because cabal doesn't have a shorthand for 
14:08:05 <phadej> if the component name is unique, it's sufficient
14:08:06 <shapr> but I gotta get this thing written before Halloween, so no distractions until then
14:08:07 <geekosaur> "the executable"
14:08:18 <phadej> cabal run exes
14:08:27 <phadej> ifit's single executable
14:08:33 <geekosaur> I think we're after cabal repl here
14:08:49 <geekosaur> can't load more than one, so I wouldn't expect exes to be a valid target
14:08:50 <shapr> that was my original goal, at least
14:08:53 <phadej> the selector syntaxisthesame
14:09:00 <phadej> cabal repl exes works too
14:09:03 <geekosaur> huh
14:09:08 <phadej> TRY
14:09:19 <phadej> if package has single executable, it's unambigous
14:09:22 <shapr> Ton't Repeat Yourself?
14:09:39 <geekosaur> heh
14:10:01 <shapr> Wait, cabal repl exes works?
14:10:12 <phadej> ...
14:10:19 <shapr> wow, cool
14:10:47 <shapr> phadej: lemme guess, that's in the docs and I just haven't read enough?
14:10:53 <shapr> phadej: this is so useful, thanks!
14:11:32 --- mode: shapr set -o shapr
14:11:43 <monochrom> I know! TRY = TRY repeating yourself
14:11:49 <shapr> monochrom: ooh, even better
14:12:29 <shapr> phadej: even better, cabal repl exes seems to pick the main executable instead of the test-suite
14:12:41 <geekosaur> thta's why 'exes'
14:12:46 <geekosaur> vs. 'tests' or w/e
14:12:59 <shapr> I thought the test-suite was considered an executable?
14:13:15 <phadej> shapr: v2-repl section doesn't link to target selector syntax, but it's documented in https://cabal.readthedocs.io/en/latest/nix-local-build.html#cabal-v2-build
14:13:19 <geekosaur> but it's a different class, and this is for selecting classes/targets within a given class
14:13:23 <phadej> shapr: test-suite is test-suite
14:13:26 <phadej> i.e. in tests
14:13:42 <shapr> oh neat
14:14:21 <`Guest00000> hiya.  is there a tool which makes a *clear*, humanly legible JS code out of a Haskell program?
14:14:45 <monochrom> I think no.
14:15:04 * geekosaur wonders if someone good at docs could give the cabal manual a go-through. it seems like it gets ever harder to find stuff in it, and not enough linking
14:15:26 <`Guest00000> i hoped to make a little game in Haskell and just distribute as JS and have people look at the JS
14:15:27 <geekosaur> `Guest00000, in general that's a remarkably difficult task for any "transpiler"
14:16:06 <`Guest00000> but why remarkably difficult?
14:16:06 <phadej> geekosaur: yes, it can be improved by a relatively light editing scan
14:16:08 <geekosaur> and harder than usual for Haskell -> JS because there's a lot of scaffolding to translate between the different models the two use
14:16:17 <`Guest00000> sorry, i didn't mean super very legible
14:16:17 <sclv> fay comes the closest http://hackage.haskell.org/package/fay
14:16:26 <sclv> it does so by just _not doing_ the hard stuff :-)
14:16:40 <`Guest00000> i just meant kinda that source Haskell "meaning" doesn't get garbled/mixed up
14:16:46 <srid> Why would anyone want a tree to be _monadic_? Is there an actual use case? cf. https://hackage.haskell.org/package/containers-0.6.2.1/docs/src/Data.Tree.html#line-179
14:16:47 <geekosaur> lazy implementation of a lazy language? :)
14:17:00 <monochrom> haha
14:17:29 <phadej> srid: yes, e.g. in Hedgehog
14:17:55 <geekosaur> srid, I'd think a fair number of things want to know the difference between a leaf and a branch
14:18:03 <sclv> the problem is that call-by-value (i.e. strict) can map into fully lazy ok (i.e. call-by-name) but you need to move to a whole different model to do "lazy" (i.e., so to speak, call by need)
14:18:21 <sclv> but anyway, for that subset of haskell it covers, fay will do ok at preserving the "sense"of the original program
14:18:23 <monochrom> You may have to concede to typescript or purescript or... because you will have no luck compiling lazy evaluation to non-lazy javascript.
14:18:27 <sclv> nothing else will even remotely resemble it
14:18:29 <srid> phadej: how is it used?
14:18:43 <phadej> srid: https://hackage.haskell.org/package/hedgehog-1.0.1/docs/src/Hedgehog.Internal.Gen.html#GenT 
14:18:46 <`Guest00000> JS has closures, which are like thunks and i think are close to lazy model
14:18:54 <phadej> they actually have TreeT m, but Tree ~ TreeT Identity
14:18:59 <`Guest00000> also it is GC'd
14:19:17 <`Guest00000> so, looks like actually relatively easy target
14:19:21 <monochrom> OK, how about non-lazy non-tail-call javascript.
14:19:48 <sclv> `Guest00000: seriously. look at fay!
14:19:50 <monochrom> Also using JS closures for lazy evaluation already obfuscates.
14:20:07 <phadej> and closures don't support sharing
14:20:08 <sclv> and if you want to understand why its hard to do better while maintaining sense, look at some talks on ghcjs
14:20:25 <geekosaur> ^^
14:20:43 <monochrom> If it were easy, you would have done it yourself.
14:20:57 <geekosaur> laziness, again :)
14:21:19 * geekosaur could provide some detail, but the folks who can report from the battlefield are the better source
14:21:34 <phadej> srid: there are talks about hedgehog, explaining how it works, but I don't remember any intro-level from top of my head
14:21:39 <phadej> talks/blog posts
14:21:56 <phadej> tl;dr, sometimes you need that intance :)
14:21:58 <`Guest00000> nah i'd rather include left-pad
14:22:22 * `Guest00000 not completely serious
14:24:43 <`Guest00000> > no typeclasses in Fay
14:24:45 <lambdabot>  <hint>:1:16: error: parse error on input ‚Äòin‚Äô
14:25:19 <`Guest00000>  > because no type inference
14:25:21 <`Guest00000> bah
14:25:34 <sclv> that's because fay has to operate at the source level to stay close to the source
14:25:49 <sclv> by the time the types get fully annotated and the typeclass dictionaries translated away
14:25:58 <sclv> you have something that doesn't look at all like the source code
14:26:05 <sclv> so that's another reason for the tradeoffs :-)
14:26:30 <geekosaur> o look at ghc core, and that's relatively close to the source
14:26:38 <geekosaur> "heck, go..."
14:27:36 <sclv> yeah not sure why chris built fay over source rather than core tbh, but that's the breaks
14:28:12 <geekosaur> er, my point is you've already lost reasonable correspondence to the source at that point
14:28:54 <geekosaur> ever notice that ghcs error messages *regenerate* source instead of printing the actual source? that's more or less the best they can do at that point
14:29:30 <geekosaur> (every so often you can catch it e.g. using ; instead of line breaks, or using [] instead of "", etc.)
14:29:50 <sclv> ah gotcha :-)
14:30:41 <`Guest00000> anyway, i like Haskell
14:30:48 <`Guest00000> it's most relaxing language for me to program in
14:31:25 * geekosaur is hopeful for a haskell-related job once he can job hunt (yeah, riiight)
14:31:58 <geekosaur> oh, feh.
14:33:17 <m1cl> what is the most popular application written in haskell?
14:33:32 <m1cl> or tool 
14:33:44 <`Guest00000> <s> GHC </s>
14:34:17 <m1cl> okay, and the second most pop ?
14:34:43 <monochrom> pandoc
14:34:56 <monochrom> Backed by no data whatsoever.
14:35:38 <m1cl> ok
14:36:10 <EvanR> i wonder if geordi the bot in ##c++ counts
14:36:22 <EvanR> if its used more than pandoc
14:36:27 <nil> https://en.wikipedia.org/wiki/Haskell_(programming_language)#Applications has a list
14:37:32 <nil> EvanR: there's a Haskell bot in ##c++?
14:38:17 <monochrom> It transpires unreadable C++ to readable Haskell >:)
14:38:41 <shapr> m1cl: shellcheck is also popular
14:38:45 <EvanR> a transpirerer
14:38:47 <shapr> Elm is popular?
14:39:02 <m1cl> thank you guys!
14:39:13 <shapr> Facebook is popular?
14:39:33 <shapr> I wonder if facebook's spam detection in Haskell is the most used Haskell code?
14:40:41 <boxscape> I think that honor goes to ghc shapr ;)
14:40:53 <shapr> yeah, I can see that
14:42:20 <`Guest00000> hehe
15:05:31 * hackage intmap-graph 1.0 - A graph library that allows to explore edges after their type  https://hackage.haskell.org/package/intmap-graph-1.0 (TillmannVogt)
15:09:21 <shapr> vaibhavsagar writes so much cool stuff, have you seen https://vaibhavsagar.com/blog/2018/07/29/hamts-from-scratch/ ?
15:09:46 <shapr> I also hear vaibhavsagar is giving a talk on succint data structures at this month's New York City meeting of Papers We Love
15:11:01 * hackage collada-types 0.4 - Data exchange between graphics applications  https://hackage.haskell.org/package/collada-types-0.4 (TillmannVogt)
15:24:47 <MarcelineVQ> I hear vaibhavsagar once beat up a mountain for peaking during a game of hide and seek.
15:37:59 <infinisil> This motivates me to start some big influental project myself
15:38:17 <infinisil> Or something where people can go "wow!" at least
15:49:06 <wejetheman> I have this little bit of code for an assignment im working on "alphabetize string = concat [filter (== x) string | x <- ['a'..'z']" and its good and im pretty happy with it but just for curiosities sake I wanted to figure out how to do it without using list comprehension, probably using map in there somewhere, and i just cant figure it out.
15:56:23 <ChaiTRex> wejetheman: If you just want the answer, I think lambdabot's @undo can turn list comprehensions into noncomprehensions.
15:56:38 <ChaiTRex> wejetheman: Other than that, I'd build from the start.
15:57:24 <`Guest00000> wejetheman:  alphabetize = sort . filter (\c -> c >= 'a' && c <= 'z')
15:58:19 <ChaiTRex> wejetheman: First, we get the 'a's in the string. Then, we turn that into a lambda that can get the whatever from the string. Then, we get the individual lists that are concatted together. Then, we concat.
15:59:52 <ChaiTRex> wejetheman: So, the first step is filter (== 'a') string. The next step is...
16:02:14 <wejetheman> thats pretty clever i need to get better at lambdas
16:02:39 <wejetheman> ive read about it but i dont think ive ever actually used one
16:04:30 <MarcelineVQ> It's also helpful to know what comprehensions turn into, which is uses of >>= and guard, and then knowing what >>= means for list. Your intution that map would be involved is a good one
16:05:32 * hackage persistent-odbc 0.2.1.0 - Backend for the persistent library using ODBC  https://hackage.haskell.org/package/persistent-odbc-0.2.1.0 (gbwey)
16:06:12 <MarcelineVQ> [filter (== x) string | x <- ['a'..'z']] is ['a'..'z'] >>= (\x -> filter (== x) string) is concatMap (\x -> filter (== x) string) ['a'..'z'] is concat (map (\x -> filter (== x) string) ['a'..'z'])
16:09:20 <wejetheman> but i mean its going to come down to lambdas then is it? no simple thing like "alphabetize string = map (filter == string) ['a'..'z']" obviously that code doesnt work but just to illustrate the point
16:09:21 <MarcelineVQ> oops, that's not quite right :>
16:10:09 <MarcelineVQ> [filter (== x) string | x <- ['a'..'z']] is ['a'..'z'] >>= (\x -> return (filter (== x) string)) is concatMap (\x -> [filter (== x) string]) ['a'..'z'] is concat (map (\x -> [filter (== x) string]) ['a'..'z'])
16:11:33 <MarcelineVQ> Not quite sure what you're asking there
16:12:44 <wejetheman> idk i guess i just had this idea that there was some sort of elegant one liner way to do it using map and filter, but perhaps the reason i couldn't figure it out is because it doesn't exist
16:12:56 <`Guest00000> wejetheman: what's so special about lambdas? they're just inline expressions for functions. alternative to my version is  alphabetize = sort . filter (liftA2 (&&) (>= 'a') (<= 'z'))
16:13:32 <ChaiTRex> wejetheman: Yeah, there's a one-liner way your original code converts into.
16:14:04 <`Guest00000> if you single out lambdas, you perhaps should do same with sections
16:14:04 <ChaiTRex> wejetheman: It's not the most elegant way, but it does what your code does.
16:14:18 <`Guest00000> (+ a)  ===   (\x -> x + a)
16:15:38 <ChaiTRex> wejetheman: Here's how to do lambdas: you know functions. f a b = a + b has three parts: the function name (f), the arguments (a b), and the result (a + b). Lambdas don't have a name, but it's (\ arguments -> result), so f a b = a + b translates to (\ a b = a + b).
16:16:04 <ChaiTRex> wejetheman: Similarly, if you write your function filter
16:16:52 <wejetheman> w
16:16:57 <`Guest00000> wejetheman: maybe you seek something like:   alphabetize string = concatMap ((`filter` string) . (==)) ['a'..'z']
16:17:01 <ChaiTRex> wejetheman: Similarly, if you write your function filterIt x = filter (== x) string, you have (\ x -> filter (== x) string)
16:17:09 <`Guest00000> but this ventures into complexity of so-called pointless style
16:17:39 <ChaiTRex> wejetheman: You write out a function with a name, then you replace the name with \ and replace the = with -> and surround with parentheses.
16:17:41 <`Guest00000> or pointfree
16:17:42 <wejetheman> yea i suppose that was the sort of thing i was trying to do guest
16:18:07 <`Guest00000> https://wiki.haskell.org/Pointfree
16:19:07 <`Guest00000> not so much complexity as contrivedness
16:19:28 <wejetheman> and chai thats a really good explanation of lambdas, thats pretty simple and i think i get it, ill have to play with it later. since you cant actually ever call the function its going to have to have 2 values dumped into it at the time its created
16:20:22 <wejetheman> in your f a b example anyway
16:22:18 <wejetheman> i gotta run thanks to everyone who chipped in. really good stuff to think about
16:23:45 <`Guest00000> anyway, i consider my latter example too contrived, it's somewhat tiring to trace how those arguments thread through there, and so this illustrates that different styles are more appropriate in different contexts
16:31:01 * hackage stratosphere 0.43.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.43.0 (jdreaver)
16:44:03 <dmwit> You can do without a lambda without losing the clarity.
16:44:28 <dmwit> let inRange c = c >= 'a' && c <= 'z' in sort . filter inRange
16:44:35 <dmwit> You are never obligated to use a lambda.
16:57:35 <freeman42x> regarding this comment here: https://github.com/haskell/haskell-ide-engine/issues/1015#issuecomment-536763502 is it possible to use a library stanza but still compile it as an executable? or what is this suggestion about?
17:33:03 <crestfallen> hi I think this example came from the chatroom, but I forget what to import to get this to work: 
17:33:08 <crestfallen> > map Just $ [(+), (*), (^)] <*> [a,b] <*> [1,2,3] :: (Maybe Expr)
17:33:10 <lambdabot>  error:
17:33:10 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚ÄòMaybe Expr‚Äô
17:33:10 <lambdabot>                    with actual type ‚Äò[Maybe Expr]‚Äô
17:33:28 <crestfallen> > map Just $ [(+), (*), (^)] <*> [a,b] <*> [1,2,3] :: [Maybe Expr]
17:33:30 <lambdabot>  [Just (a + 1),Just (a + 2),Just (a + 3),Just (b + 1),Just (b + 2),Just (b + ...
17:34:01 <crestfallen> correction how to get it to work in ghci
17:34:18 <EvanR> @index Expr
17:34:18 <lambdabot> bzzt
17:34:41 <EvanR> crestfallen: package simple-reflect
17:35:21 <crestfallen> oh I did similar ...
17:35:38 <crestfallen> import simpleReflect.Expr
17:37:08 <EvanR> > sum (map f [1,2,3]) :: Expr
17:37:09 <lambdabot>  0 + f 1 + f 2 + f 3
17:37:33 <crestfallen> import Data.simpleReflect.Expr
17:37:49 <crestfallen> what exactly do I type in ghci
17:38:00 <EvanR> i would look at haddocks
17:38:11 <EvanR> i mean do you even have it installed
17:38:26 <crestfallen> no 
17:38:29 <MarcelineVQ> it = simple-reflect
17:38:44 <EvanR> install the package
17:39:23 <hpc> the documentation on hackage has the module you need to import
17:39:30 <hpc> once the package is installed
17:39:45 <crestfallen> weird. maybe I did it in a sandbox last time..
17:40:55 <crestfallen> thanks
17:46:40 <crestfallen> yeah I did it in a sandbox, hence my confusion . thanks
18:44:12 <d34df00d> Hi!
18:44:27 <d34df00d> Let's say I have a `type family Foo (arg :: k -> *) where ...`
18:44:58 <d34df00d> If I have an equation in its definition along the lines of `Foo arg = Foo (F arg)`, do I understand correctly that the kind of `F arg` shall match the kind of `arg`?
18:50:19 <d34df00d> And is there a debugger for type families? I'd like to see how it gets evaluated by the typechecker, cause I get funny results.
19:06:14 <vaibhavsagar> d34df00d: https://www.reddit.com/r/haskell/comments/34vfsz/a_poor_mans_type_level_debugger/
19:07:10 <d34df00d> vaibhavsagar: lol, nice solution!
19:07:28 <arahael> I'm trying to figure out how to use yesod - the yesod book is rather difficult to follow (It doesn't seem to explain how to use lucius templates from file, for instance, and considers 'yesod devel' too difficult to explain. :( )
19:07:38 <arahael> Does anyone have any recommendations for me to read?
19:13:45 <arahael> I suppose I /could/ create a "scaffolded" site, and then painstakingly compare and contrast the differences between that and my current app.
19:16:35 <ysangkok> what do you mean by scaffolded?
19:26:04 <jusss> data F where MkF :: Int -> F -> F
19:26:15 <jusss> % data F where MkF :: Int -> F -> F
19:26:15 <yahb> jusss: 
19:26:30 <jusss> % unF :: F -> Int -> F
19:26:31 <yahb> jusss: ; <interactive>:87:1: error:; * Variable not in scope: unF :: F -> Int -> F; * Perhaps you meant `un' (imported from Control.Lens)
19:27:49 <jusss> data F where MkF :: Int -> F -> F;  
19:27:55 <jusss> unF :: F->Int->F
19:28:03 <jusss> unF (F w) = w
19:28:24 <jusss> shouldn't it be unF (F w) = F?
19:30:18 <EvanR> i don't see how it could be
19:31:37 <jusss> EvanR: then w has which type?
19:31:49 <EvanR> do you mean unF (MkF w) =
19:32:17 <EvanR> did you mean MkF :: (Int -> F) -> F
19:32:54 <jusss> EvanR: data F = MkF (Int -> F)
19:33:18 <EvanR> so assuming "yes" to both, w :: Int -> F
19:35:07 <jusss> EvanR: then it should be unF (MkF w) = w
19:36:21 <EvanR> yes
19:38:21 <jusss> EvanR: what this used for
19:39:11 <jusss> EvanR: in the value level
19:39:27 <EvanR> let me write it out properly
19:39:46 <EvanR> data F where
19:39:54 <EvanR>   MkF :: (Int -> F) -> F
19:40:04 <EvanR> unF :: F -> Int -> F
19:40:11 <EvanR> unF (MkF w) = w
19:40:26 <arahael> ysangkok: whatever yesod means by it!
19:40:41 <arahael> ysangkok: i think it is a code-generated project.
19:43:30 <EvanR> jusss: the type F seems to be an infinitary branching tree
19:43:46 <EvanR> (viewing Int as Integers)
19:44:05 <EvanR> and this tree has no data in it
19:48:10 <jusss> EvanR: so it's useless in the value level?
19:48:31 <jusss> EvanR: no value can have that type F?
19:49:01 <EvanR> plenty of inhabitants of F
19:49:14 <EvanR> but i don't see how you can tell the difference between any of them
19:49:34 <EvanR> it just consumes Ints forever no matter what they are
19:50:07 <EvanR> it's a /dev/null for Int
19:51:02 <fresheyeball> so I have haskell ide engine working great on my standard projects
19:51:11 <fresheyeball> but I have one project that uses cabal.project
19:51:15 <fresheyeball> and multiple cabal files
19:51:21 <fresheyeball> on this one hie dies
19:51:48 <fresheyeball> ,"source":"ghcmod","message":"readCreateProcess: cabal \"configure\" \"--with-ghc=ghc\" \"--flags\" \"\" (exit 1): failed\n"}]
19:52:00 <fresheyeball> if I run cabal configure in the nix-shell its fine
19:55:56 <Squarism> I just started using nix-build. Previously used Stack. I wonder how I do stuff like running "stack repl" and "stack test .." etc
20:12:50 <arahael> ddd
20:14:05 <arahael> Squarism: I'm in a similar boat, though I haven't quite started using nix-build yet - still using stack.  "stack test" is just starting the test version of the project, as specified in the cabal file, and stack repl is - I think - just ghci?
20:14:35 <Squarism> ok, ill try that
20:15:18 <Squarism> wants me to install ghc =/
20:15:26 <arahael> ysangkok: The "scaffolded site" is described here: https://www.yesodweb.com/book/basics#basics_the_scaffolded_site
20:15:40 <Squarism> i guess i nead to be in a nix-shell
20:15:55 <arahael> Squarism: Yes, that's the usual way to develop a package in nix.
20:16:15 <arahael> Squarism: As that pulls in everything you need for that package, and gives you a shell with everyhing setup.
20:17:47 <arahael> Squarism: Btw, there are apparently pretty good docs for using haskell on the nixos site, practically walks you through it.
20:18:24 <Squarism> okok, ill check that out
20:18:28 <arahael> Squarism: https://nixos.org/nixpkgs/manual/#users-guide-to-the-haskell-infrastructure
20:20:18 <Squarism> thanks!
20:20:42 <arahael> Squarism: You're welcome.
20:21:11 <arahael> Squarism: (I say "apparently" - because I've yet to use it myself - but it's on my list of things to do...)
20:26:27 <arahael> Hmm, the yesod "quick start" guide is pretty good for me, as it turns out.  I guess if it's in the quick start, the yesod book doesn't go into much detail.
22:02:08 <Welkin> lol!
22:02:42 <Welkin> in this video about the BEAM (Erlang/Elixir) I thought the speaker said "I have to reach for a little bit of Haskell-level math" https://youtu.be/JvBT4XBdoUE?t=1700
22:03:01 <Welkin> it's only after rewinding that I realized he said "high school level" with his thick eastern european accent
22:05:34 <EvanR> how many haskell levels are you on
22:15:05 <toblorone> Hey I'm messing around with lucid and I don't really understand why this doesn't work  "renderText $ with link_ [class_ "a"]"
22:15:22 <toblorone> this is shown to work here: https://chrisdone.com/posts/lucid/
22:20:39 <toblorone> huh, the examples on the page dont work at all
22:20:42 <toblorone> wtf
22:21:57 <Welkin> use blaze-html
22:22:16 <Welkin> it works
22:32:33 <toblorone> Welkin: oh, lucid's api changed since that post was published
22:46:11 <toblorone> Welkin: nevermind. library is completely broken
22:46:21 <Welkin> yep
22:47:26 <toblorone> only certain elements can have attributes added to them. notably, the script_ element doesn't accept an attribute argument
22:48:41 <Welkin> use blaze-html if you need server side rendering of html
22:48:55 <Welkin> otherwise, there is miso (elm in haskell), or just use elm
22:49:19 <toblorone> I was looking at miso, but seemed way too complicated for what I want
22:49:41 <Welkin> if you want an in-browser application, you'll want elm
22:49:56 <Welkin> it's simple and zen
22:50:06 <Welkin> my favorite language
22:50:13 <toblorone> and blaze looks nasty compared to lucid :(. 
22:51:02 <toblorone> I'm sure it's nice, but I just need to make a 3 page website. The time it would take me to learn miso seems longer than i need to make the whole thing ha
23:04:36 <arahael> /
23:07:16 <arahael> Blaze seems pretty good, Yesod uses it.
23:09:00 <toblorone> yeah I've switched to it. wasted too much time mucking around with lucid
23:09:00 <dminuoso> % class MonoidThese a where un :: Void -> a; comb :: These a a -> a
23:09:01 <yahb> dminuoso: 
23:09:05 <dminuoso> Can you have valid instances of this?
23:09:11 <dminuoso> (Non-trivial ones I mean)
23:10:55 <arahael> toblorone: Yesod has some pretty nice Quasi-quoters for it, too.  Not sure if they're part of blaze (probably)
23:11:59 <Welkin> yesod uses the hamlet templating languages
23:12:04 <Welkin> which uses template haskell
23:12:09 <Welkin> and ocmpiles to blaze I think
23:12:33 <Welkin> I used it years ago, but I don't recommend it
23:12:41 <Welkin> html combinators are much better, less error prone
23:13:54 <sim590> I'm computing the determinant of a matrix https://paste.debian.net/1105978/. My function always gives -1 the good result. That's odd.
23:14:47 <sim590> There must be somthing fishy somewhere.
23:15:03 <sim590> I feel like it's about a misuse of the language. May be the let statement or something.
23:15:35 <Welkin> there are no statements
23:15:38 <Welkin> let is an expression
23:15:56 <sim590> Well, OK. the let expression then. ;)
23:16:13 <arahael> Welkin: Are those combinators part of Blaze, or are you referring to something else?
23:16:30 <sim590> Pardon my non specialist knowledge of languages ;).
23:16:31 <Welkin> blze *is* html combinators
23:16:38 <Welkin> blaze*
23:17:22 <arahael> Ah, heh - awesome :)
23:27:00 <dmwit> dminuoso: Any laws? What does "nontrivial" mean to you?
23:28:02 <dmwit> instance MonoidThese Int where un _ = 3; comb (This x) = x + 10; comb (That y) = y * 17; comb (These x y) = 3*x + y -- looks pretty nontrivial to me
23:33:18 <jle`> dminuoso: if it's monoidal, there are two laws
23:33:34 <jle`> or well, the 'monad' laws, but re-tooled
23:34:06 <jle`> *monoid ?
23:34:42 <jle`> namely: (1) comb . right comb == comb . left comb . reassoc
23:36:13 <jle`> and `comb . right un == ... whatever was in the This/right
23:36:21 <jle`> and comb . left un == whtehver was in the That/left
23:36:24 <jle`> not sure how to state it actually
23:37:40 <jle`> dminuoso: btw our discussion the other day has caused me to rethink a lot of the perspective i've had on things, and it might result in a rewrite of functor-combinators
23:39:59 <dmwit> sim590: It doesn't always give -1 here.
23:40:14 <dmwit> e.g. det (Matrix [[2,0],[0,2]]) = 4
23:46:25 <sim590> dmwit: Yeah, it's OK if the (-1) don't come into play because of the 0's I gues.
23:47:11 <sim590> I'm not sure now if that's algorithmic problem or a problem about human interpretion of the language.
23:49:25 <sim590> dmwit: for instance det $ Matrix [[1,2,3],[3,2,1],[4,-5,2]] will give 64 instead of giving -64 which is the right answer.
