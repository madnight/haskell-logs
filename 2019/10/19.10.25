00:01:50 <EvanR> "the aim is to do no worse than java"
00:19:14 * hackage concurrent-hashtable 0.1.3 - Thread-safe hash tables for multi-cores!  https://hackage.haskell.org/package/concurrent-hashtable-0.1.3 (PeterRobinson)
00:22:37 <sicklorkin> EvanR: as I always say, aim low that way no one gets hurt.
00:23:50 <jusss> EvanR: why the exampls online is Network, but new pacakge is Network.Socket, even different names
00:24:03 <jusss> different function names
00:24:21 <jusss> big difference than python2 and python3
00:54:14 * hackage concurrent-hashtable 0.1.4 - Thread-safe hash tables for multi-cores!  https://hackage.haskell.org/package/concurrent-hashtable-0.1.4 (PeterRobinson)
00:56:13 <pikajude> i don't think i'd say it's a bigger difference than python2 vs python3
00:59:14 * hackage concurrent-hashtable 0.1.5 - Thread-safe hash tables for multi-cores!  https://hackage.haskell.org/package/concurrent-hashtable-0.1.5 (PeterRobinson)
01:46:41 <jusss> if there's a ByteString "abc" , how I can repalce "a" with "1" ?
01:47:12 <jusss> does it need to transform to String?
01:48:01 <pikajude> map?
01:48:42 <ariakenom> also tail and cons
01:48:58 <jusss> for example?
01:49:21 <ariakenom> jusss: https://hackage.haskell.org/package/bytestring-0.10.10.0/docs/Data-ByteString.html#t:ByteString
01:50:16 <jusss> ariakenom: oh, use Word8
01:50:24 <ariakenom> no ...
01:50:27 <jusss> map :: (Word8 -> Word8) -> ByteString -> ByteString
01:50:36 <ariakenom> oh I see yeah sure
01:50:53 <pikajude> > (ord 'a', ord '1')
01:50:56 <lambdabot>  (97,49)
01:51:07 <jusss> is there String -> Word8 ?
01:51:11 <pikajude> nope
01:51:22 <jusss> [Char] -> Word8?
01:51:23 <pikajude> unless you mean like, interpreting a string as a Word8? read
01:51:30 <pikajude> > read "1234" :: Word8
01:51:32 <lambdabot>  210
01:51:40 <pikajude> oh yeah, i forgot what the maxbound of word8 is lol
01:51:49 <ariakenom> :
01:51:50 <pikajude> you shouldn't really be using read in any situation though
01:51:57 <ariakenom> :)
01:51:57 <pikajude> it's almost always the wrong answer
01:52:13 <ariakenom> :t ord
01:52:14 <lambdabot> Char -> Int
01:52:27 <jusss> wait a sec, "abc" every character has one Word8 ?
01:52:44 <ariakenom> :t fromIntegral . ord
01:52:46 <lambdabot> Num c => Char -> c
01:52:58 <ariakenom> :t (fromIntegral . ord) 'a' :: Word8
01:52:59 <lambdabot> Word8
01:53:03 <pikajude> bytestrings don't contain characters
01:53:07 <pikajude> they're strings of bytes
01:53:09 <ariakenom> > (fromIntegral . ord) 'a' :: Word8
01:53:12 <lambdabot>  97
01:53:12 <pikajude> resembling characters is purely coincidental
01:53:40 <pikajude> well not *purely* coincidental. but you get the idea
01:54:32 <jusss> so if there's ByteString "PING: xxx" how I can to transform it to "PONG: xxx"
01:54:49 * pong
01:55:08 <pikajude> just use Data.ByteString.map and replace whatever ord 'I' is with ord 'O'
01:57:21 <jusss> > ord 'I'
01:57:26 <lambdabot>  73
01:57:33 <jusss> > ord 'O'
01:57:38 <lambdabot>  79
01:58:15 <jusss> map (\i case i of 73 -> 79) "PING: xxx" ?
01:58:30 <pikajude> yeah, that will work for a string containing only Is
01:59:17 <jusss> but what about more specific? like startWith PING
01:59:26 <ariakenom> pikajude: :D
02:00:01 <ariakenom> jusss: that will crash on any byte that isnt ord 'I'
02:00:09 <pikajude> what do you mean? you asked about the string "PING: xxx"
02:00:12 <pikajude> we know that starts with "PING"
02:00:34 <pikajude> if you want to check, you would use Data.ByteString.isPrefixOf
02:01:03 <ariakenom> if it's all text you can decode it into a text type and then encode it into a Bytestring
02:01:22 <pikajude> yeah but if this is IRC syntax, the commands and parameters are explicitly ascii
02:01:26 <pikajude> so roundtripping to text would waste time
02:02:14 * hackage api-rpc-factom 0.1.3.0 - RPC API client for Factom  https://hackage.haskell.org/package/api-rpc-factom-0.1.3.0 (sigrlami)
02:04:14 * hackage api-rpc-factom 0.1.3.1 - RPC API client for Factom  https://hackage.haskell.org/package/api-rpc-factom-0.1.3.1 (sigrlami)
02:05:44 * hackage api-rpc-factom 0.1.3.2 - RPC API client for Factom  https://hackage.haskell.org/package/api-rpc-factom-0.1.3.2 (sigrlami)
02:08:23 <jusss> pikajude: ok, I should use Data.ByteString.isPrefixOf
02:09:13 <jusss> ariakenom: actually it is IRC syntax...
02:09:26 <pikajude> if it's irc syntax you should be using irc-core anyway
02:18:01 <kuribas> I am running stack again in a remote windows environment, and it's downloading ghc and the dependencies all over again.
02:18:10 <kuribas> Is it possible to use the one it used lastly?
02:21:15 <kuribas> Is it because the lts isn't fixed?
02:27:28 <jusss> D.map (\i -> case i of 73 -> 79) t
02:27:34 <jusss> "*** Exception: <interactive>:12:14-31: Non-exhaustive patterns in case
02:28:52 <lavalike> jusss: ; x -> x
02:29:28 <jusss> lavalike: I don't get it
02:29:48 <lavalike> case i of 73 -> 79; x -> x
02:29:57 <lavalike> so that if it picks up the one you want, it changes, for the others, it keeps them
02:30:21 <jusss> lavalike: I see, just like the if-then-else
02:51:25 <kuribas> ah, I ran stack in the wrong directory...
02:53:00 <__monty__> pikajude: If it's explicitly ascii how can we send unicode? 🤔
03:43:41 <DigitalKiwi> well, your first problem is you're using stack :P
03:53:27 <Tyson_911> hi
03:53:46 <lyxia> o/
03:53:57 <Tyson_911> can anyone help mee ?
03:55:07 <yushyin> Tyson_911: sure, just ask your question
03:55:56 <Tyson_911> yushyin : i created a backdoor script in C soo i am having some issues about that  
03:56:13 <DigitalKiwi> for help after hours you may subscribe to our premium support channel for only $3.99 a minute
03:57:26 <vilpan> fortunately, IRC runs on the eternal morning time :)
03:57:47 <yushyin> question about haskell/ghc* :P
04:01:14 * hackage concurrent-hashtable 0.1.6 - Thread-safe hash tables for multi-cores!  https://hackage.haskell.org/package/concurrent-hashtable-0.1.6 (PeterRobinson)
05:00:02 <berndl> What are terms of type Cont r a called? Continuation handlers?
05:01:03 <EvanR> actions maybe
05:01:42 <Athas> People got awfully angry about that "beating C with Haskell" post.
05:02:29 <berndl> EvanR: any links where they use the word "action"?
05:02:50 <EvanR> nope that is just the default when talking about values of a type which is a monad
05:03:25 <berndl> EvanR: really? I thought the default was "computations".
05:03:28 <EvanR> for Cont specifically... it's a CPS function
05:04:06 <EvanR> equivalent to ((a -> r) -> r)
05:05:03 <EvanR> computations seems a bit vague
05:05:11 <berndl> Hmm... In my mind, you can change a function a -> b into a CPS one a -> Cont r b
05:05:26 <berndl> So a -> Cont r b would be a CPS function, not Cont r b.
05:06:11 <EvanR> i don't really have a problem with any of the above
05:06:16 <berndl> EvanR: https://wiki.haskell.org/Monads_as_computation
05:06:48 <EvanR> at the very least don't call them containers uhg
05:07:18 <berndl> I honestly don't like the word "computation" either.
05:07:53 <EvanR> i'm in a phase where computation has the connotation of improving approximation
05:08:58 <berndl> That's weird. The word "approximation" would never pop into my mind when I hear "computation".
05:09:29 <EvanR> if you have an improving value, all the intermediate steps could be called an approximation
05:09:47 <EvanR> if they were values of their own
05:10:14 <EvanR> in the case of exact real arithmetic, the approximations / steps is all you have
05:10:15 <ariakenom> Athas: heh. I thought it was quite open about its issues
05:10:57 <EvanR> in lazy evaluation you have something similar
05:11:22 <EvanR> bottom being the worse possible approximation / beginning of a computation
05:12:37 <berndl> Ah, that reminds me of continuous function in CPO semantics.
05:12:46 <dminuoso> ariakenom: Its so disturbing with that lower case in your nick name.
05:12:50 <EvanR> that's what it is
05:12:58 <dminuoso> ariakenom: There should be a law against it, I cant cope with this.
05:15:41 <lyxia> berndl: (a -> Cont r b) is isomorphic to (b -> r) -> (a -> r) so I like "continuation transformer" but I just came up with it.
05:17:24 <lyxia> it also evokes "predicate transformers" which is a closely related concept.
05:18:02 <dminuoso> lyxia: prredicate transformers in the sense of `instance Contravariant (Op a)`?
05:18:32 <berndl> When I hear "transformer", I think of monad transformers.
05:22:07 <lyxia> dminuoso: uh, in the sense of (b -> Prop) -> (a -> Prop)
05:22:14 <EvanR> you heard about transformers in clojure too
05:22:25 <EvanR> but they call them transducers?
05:22:39 <dminuoso> lyxia: Ah right, so in the sense of contramap on Op.
05:22:52 <dminuoso> EvanR: transrucers is something else
05:23:28 <EvanR> well they are certainly not monad transformers
05:24:25 <kuribas> monad transformer is badly named
05:24:30 <lyxia> dminuoso: contramap describes an incredibly small subset of that type though.
05:24:31 <kuribas> it's more like a monad stack
05:24:34 <dminuoso> (Afair a transrucer was just a function between reducer functoins)
05:24:55 <kuribas> because the underlying monad isn't transformer, it still does the same thing
05:25:04 <kuribas> you just get functionality on top of it
05:25:24 <lyxia> a monad transformer t transforms a monad m into a monad (t m), that sounds pretty reasonable to me.
05:25:51 <kuribas> it encapsulates it
05:25:59 <kuribas> it doesn't "change" it
05:26:11 <berndl> kuribas: monad wrapper?
05:26:25 <berndl> or, dare I say, monad container?
05:26:27 <lyxia> I understand "transformer" as synonymous with "function"
05:26:47 <lyxia> m and t m are not the same monad, so something has definitely changed.
05:27:17 <dminuoso> lyxia: Perhaps closer to a homomorphism in that we understand that a transformer somehow respects some unspecified structure?
05:28:21 <lyxia> dminuoso: that's fair
05:32:26 <kuribas> do you ever use the continuation monad for non-local exits?
05:33:16 <kuribas> > flip runCont id $ do y <- pure 5; z <- if x > y then exit 6 else pure 7; pure $ x + y + z
05:33:19 <lambdabot>  error:
05:33:19 <lambdabot>      Variable not in scope: exit :: Integer -> ContT Expr Identity Expr
05:33:35 <kuribas> > let exit = ConT . const in flip runCont id $ do y <- pure 5; z <- if x > y then exit 6 else pure 7; pure $ x + y + z
05:33:37 <lambdabot>  error:
05:33:37 <lambdabot>      • Data constructor not in scope: ConT :: (b0 -> a) -> c
05:33:37 <lambdabot>      • Perhaps you meant ‘ContT’ (imported from Control.Monad.Cont)
05:33:48 <kuribas> > let exit = ContT . const in flip runCont id $ do y <- pure 5; z <- if x > y then exit 6 else pure 7; pure $ x + y + z
05:33:50 <lambdabot>  6
05:34:22 <kuribas> wait, where does x come from?
05:34:24 <kuribas> > x
05:34:27 <lambdabot>  x
05:34:42 <kuribas> > x > 5
05:34:44 <lambdabot>  True
05:34:49 <kuribas> > x < 5
05:34:51 <lambdabot>  False
05:34:58 <kuribas> hmm
05:35:39 <lyxia> https://hackage.haskell.org/package/simple-reflect
05:35:59 <kuribas> :t x
05:36:01 <lambdabot> Expr
05:36:15 <kuribas> lyxia: but why is it (> 5) ?
05:36:48 <lyxia> Probably because the constructor for variables appears after the constructor for numbers
05:37:49 <kuribas> ah I see
05:38:01 <lyxia> actually no there is a custom Ord instance, so the reason is whatever this does: https://hackage.haskell.org/package/simple-reflect-0.3.3/docs/src/Debug-SimpleReflect-Expr.html#Expr
05:39:02 <kuribas> a lexical comparison of the string representation it seems
05:41:01 <EvanR> is a monad transformer a monad morphism?
05:41:45 <kuribas> what do you use for non-local exits?  It seems that the MaybeT, ExceptT and ContT are all possible...
05:42:12 <EvanR> when nothing else is going on Maybe, Either
05:42:37 <kuribas> or Exceptions in IO?
05:43:22 <EvanR> if you're in IO, use async as an excuse to use exceptions as non-local exit
05:43:38 <EvanR> exit ends the current thread
05:44:53 <EvanR> in a more complex environment your custom app monad can have the feature built in (in whatever way)
05:45:20 <kuribas> ContT is probably too heavy-weight
05:45:56 <kuribas> although thunks in ghc also use CPS, so maybe it isn't that heavy...
05:46:50 <ariakenom> dminuoso: :D sorry I will go fix my nic
05:47:45 <kuribas> I rarely ever see code with ContT...
05:48:08 <EvanR> good :)
05:48:44 <kuribas> why the hate?
05:48:48 <EvanR> haskell already has an unfair reputation for being incomprehensible even when it's not written in CPS
05:48:49 <lyxia> ContT/Cont are more efficient than MaybeT...
05:49:24 <kuribas> lyxia: I would hope MaybeT gets inlined...
05:49:34 <Ariakenom> dminuoso: Im back :)
05:50:03 <EvanR> church encoded MaybeT maybe would be faster?
05:50:06 <dminuoso> Ariakenom: Much better! :)
05:50:27 <lyxia> church encoded MaybeT is pretty much what you get with ContT
05:50:37 <EvanR> right...
05:50:41 <dminuoso> kuribas: You dont just need inlining, you need fusion to happen.
05:50:52 <Ariakenom> I started using weechat and being in a terminal triggered my lower case only mode when entering nick
05:51:20 <dminuoso> Ariakenom: Looking into #haskell and seeing the usual nicknames is how I know everything is O.K. in this world. You got me worried.
05:51:37 <Ariakenom> <3
05:53:46 <kuribas> dminuoso: I believe ghc can fuse away constructors by itself
05:54:02 <kuribas> dminuoso: then then intermediate Just's can be fused away
05:54:50 <lyxia> but most programs don't consist of just "case", "Just" and "Nothing"
05:55:18 <lyxia> as soon as you have a non-inlineable computation you start paying for the cost of the case in MaybeT's (>>=)
05:55:54 <lyxia> whereas with ContT failing just means not calling the continuation
05:56:35 <lyxia> the cost doesn't pile up as easily as with MaybeT
05:57:05 <dminuoso> It probably also depends on what other layers you have in your transformer stack.
05:57:57 <dminuoso> But from experience, GHC doesn't fuse Maybe easily.
06:02:29 <lyxia> I should finish my blogpost which explains how Cont alone pretty much subsumes the whole transformers library.
06:03:37 <dminuoso> lyxia: Is that an extension of the idea that Cont is powerful enough to describe every other monadic effect?
06:04:44 <lyxia> I guess that's pretty much it, but the fact that MaybeT is still a thing suggests it's not that well known.
06:09:02 <dminuoso> So Im quite fond of ReaderT only stacks (it greatly simplifies things like exception handling), and enables MonadUnliftIO - but I find myself struggling not to have the expressivity of say MaybeT - so I start encoding shortcircuiting as exceptions in IO, but that has some caveats in that library code can catch my exceptions..
06:19:57 <spookm> so does anyone here actually know category theory? I'm sitting through a lecture on categori...cal logic? and uhhh....
06:20:36 <Rembane> spookm: I think somebody does, is it weird? 
06:20:47 <spookm> weird isn't the word I'm thinking of
06:22:33 <EvanR> lyxia: Cont is the mother of all monads? (existing blog post)
06:32:47 <rotaerk> is there an existing package that gives you a way to read directly from/write to raw byte arrays but where you're looking at it as a struct with fields at particular offsets
06:33:04 <rotaerk> like what is being done here: https://github.com/achirkin/vulkan/blob/master/vulkan-api/src/Graphics/Vulkan/Marshal/Internal.hs
06:33:12 <rotaerk> but generalized
06:33:14 * hackage sr-extra 1.64 - Module limbo  https://hackage.haskell.org/package/sr-extra-1.64 (DavidFox)
06:33:20 <dminuoso> rotaerk: Are you perhabs looking for unboxed vectors?
06:33:38 <dminuoso> (Or unboxed/storable data in general)
06:34:49 <rotaerk> well, with Storable, you convert haskell records to/from raw bytes at a record level granularity
06:35:10 <sicklorkin> rotaerk: nothing comes to mind
06:35:12 <rotaerk> whereas I'm talking about sub-record level, where you have your raw bytes, and you read the, say, 3rd field of the struct directly from it
06:35:43 <rotaerk> so that you don't have to build an entire record just to access that field
06:36:38 <rotaerk> don't think laziness really helps, because peek/poke strictly handle the entire thing
06:37:38 <sicklorkin> rotaerk: you can kinda acheive this with view/unview and Int encodings (say enum)
06:38:13 <rotaerk> the author of that accidentally made a generalized form of it in his `easytensor` library, and was trying to decide if it'd be useful to split it out into its own library
06:38:18 <rotaerk> author of vulkan-api *
06:38:50 <rotaerk> hmm "unview" doesn't turn up in hoogle
06:40:31 <rotaerk> sicklorkin, you talking about view the lense function? or view from Data.ByteArray?
06:40:43 <rotaerk> thinking the latter ...
06:40:51 <sicklorkin> not lens
06:41:02 <rotaerk> ah, unView is a field of View
06:42:08 <EvanR> (FOV)
06:42:14 <rotaerk> heh
06:42:24 <rotaerk> anyway.  I'm not sure how useful this idea is when doing most haskell programming, but it seems like it'd be very useful in the general case when working with a C-library binding
06:44:07 <rotaerk> no need to build up a data structure and marshal to bytes, when you can write directly to the byte array, just to send data to the C library... and no need to unmarshal an entire structure from a byte array, just to get a field or two out of what the C-library returned
06:45:09 <EvanR> the question is what is the diff between a fancy custom bytearray-backed record thing and a normal record with all fields unboxed unpacked
06:45:49 <rotaerk> can't get a pointer to the latter to pass to C
06:46:15 <EvanR> if that is the only difference, then there's no diff because you can hack your way in
06:46:31 <rotaerk> even if you can, who's to say its memory layout matches the expectation of the C library
06:47:24 <EvanR> next question would be how to control that memory layout
06:47:39 <EvanR> if it's indeed unexpected given the ordering and sizes
06:48:08 <rotaerk> a record syntax *would* be preferable I think
06:48:18 <rotaerk> with the vulkan-api, I end up handling data structures like...
06:48:44 <rotaerk> createVk @VkExtent (set @"width" 100 &* set @"height" 100)
06:49:15 <rotaerk> and tto read from it:  getField @"width" someExtent
06:50:41 <EvanR> there is this package storable-record but not sure if it's up to date or fast
06:51:12 <rotaerk> though that syntax is preferable in some ways, because you can do things like... make a setter that sets multiple fields at once
06:51:21 <rotaerk> can't really do that with record constructors
06:52:35 <rotaerk> let list = [...] in createVk (set @"blahCount" (fromIntegral . length $ list) &* setList @"blahArrayPointer" list)
06:52:58 <rotaerk> can be replaced with: createVk (setListCountAndRef @"blahCount" @"blahArrayPointer" [...])
06:54:27 <EvanR> you would have to make combinatorially many setters
06:54:36 <EvanR> using update syntax
06:54:50 <rotaerk> what do you mean
06:55:08 <EvanR> to make setters without special tech
06:55:18 <EvanR> that update multiple fields in 1 go
06:55:55 <EvanR> wait are you dealing with records or vectors with uniform contents
06:56:36 <rotaerk> dealing with byte arrays that hold a struct, or an array of structs
06:56:52 <EvanR> or nested such things?
06:57:12 <rotaerk> well, a struct ccan contain another struct, so yes, they might be nested
06:57:23 <EvanR> it can also contain unpacked pairs
06:57:24 <rotaerk> it's basically just an array of that you might pass or get back from a C library
06:57:31 <EvanR> it can also contain sums (now a days)
06:57:36 <rotaerk> the whole point of this is C-compatibility
06:57:46 <EvanR> in C, unions
06:57:59 <rotaerk> right, that vulkan API's thing supports unions
06:58:23 <EvanR> field might also be an array of known size
06:59:09 <rotaerk> yep also supports that.  he basically had to support all the variations vulkan itself might return
06:59:13 <EvanR> ideally you can also slice up words into individual bits which stand for separate fields of their own
06:59:13 <rotaerk> or expect
06:59:56 <EvanR> who's he ?
07:00:26 <rotaerk> Artem, author of that vulkan binding i linked above
07:06:02 <rotaerk> EvanR: basically the thing already exists but it is embedded in a vulkan library and in a tensor library, and i was trying to determine if it's redundant with anything already out there
07:06:59 <rotaerk> because I'm gonna ask him, maybe help him, to move it out to its own library
07:25:10 <maralorn> Is it common or frowned upon to write orphan instances for Arbitrary when writing tests?
07:25:37 <maralorn> I feel like Orphan instances are kinda okay if you never expect anybody else to import your module, right?
07:25:42 <geekosaur> yes
07:25:48 <geekosaur> and tests are kinda a canonical example
07:26:37 <geekosaur> note that a test library used only by your tests also qualifies for orphans, and is preferred to (say) putting the instances in your exported library
07:27:13 <geekosaur> that was a driver for support of non-exported libraries, iirc
07:29:07 <dminuoso> maralorn: Overall I think orphan instances are much less of an issue as some make it to be.
07:30:24 <maralorn> I must admit I have not grasped the concept of global coherence yet.
07:33:46 <maralorn> Which means to say, I always hear it as a buzzword and haven‘t yet read an article about.
07:36:36 <lortabac> maralorn: if I remember correctly, this talk is about coherence https://youtu.be/hIZxTQP1ifo
07:37:00 <kuribas> dminuoso: I believe they are only a problem in a library that you distribute
07:40:02 <geekosaur> the problem with orphans is they can affect code written by someone else f they ever decide to link in the library with the orphans.
07:40:45 <maralorn> geekosaur: They need an import statement for the module with the instance declaration, don‘t they?
07:40:46 <geekosaur> it could be argued that this should be reflected in versioning, but dependencies get rather complex in that case including what happens if you link in multiple libraries each of whcih declares orphan instances for the same type(s)
07:40:53 <kuribas> lyxia: but if I have a "big" computation in the MaybeT monad, then the overhead of the extra Just isn't that big compared to the function call?
07:41:26 <dminuoso> kuribas: You pay dealy in allocation and GC.
07:41:33 <dminuoso> (Especially if you do this in a light loop)
07:42:02 <pavonia> In terms of Curry-Howard isomorphism, what is the corresponding logical formula for a polymorphic type (as compared to a monomorphic)? The "forall" in Haskell is different from the universal quantification in logic, right?
07:42:03 <geekosaur> maralorn, yes, but you can't control what instances are imported; any instances are always imported.
07:42:46 <kuribas> dminuoso: in a light loop it will be inlined, no?
07:42:47 <dminuoso> pavonia: No its exactly that.
07:42:54 <dminuoso> pavonia: Type variables are implicitly quantified.
07:43:00 <kuribas> dminuoso: you mean tight loop maybe?
07:43:05 <dminuoso> pavonia: Something like `foo :: T a` is implicitly `foo :: forall a. T a`
07:43:15 <dminuoso> kuribas: Oh yes! :)
07:43:46 <geekosaur> because they're always global and importing into one module infects your whole package and all packages you import modules from, not just that one module
07:43:58 <geekosaur> and must be global, that's why they work at all
07:44:40 <pavonia> dminuoso: But https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence#General_formulation says that logical quantification corresponds to dependent product types, which seem different to me than the simple forall'ed types in Haskell
07:44:58 <pavonia> *universal quantification
07:45:07 <geekosaur> pvonia: RankNTypes?
07:45:19 <maralorn> geekosaur: So it might happen, that I change the behaviour of on lib by importing another one without the type the instance is for even being mentioned in my code?
07:45:30 <pavonia> geekosaur: What do you mean?
07:45:35 <kuribas> dminuoso: I also think worrying about small inefficiencies is usually not necessary, as haskell is good enough
07:46:00 <kuribas> dminuoso: the overhead of having clean abstractions is ok.
07:46:17 <kuribas> dminuoso: and in a tight loop you just optimize the heck out of it.
07:46:23 <maralorn> geekosaur: But that does at least need some overlapping instances or it will just error out, won‘t it?
07:47:12 <geekosaur> maralorn, in the case where you get multiple instances you'll get a linker error. in the case where you don't but you get an instance your code doesn't expect, you may simply get wrong results becakse at no point does anything know that instance is unexpected
07:48:12 <pavonia> dminuoso: Do concrete types correspond to non-quantified logical variables then?
07:48:14 <r-zip> :q
07:48:23 <geekosaur> you may indeed get "unexpected" compilation success, and not realize it should have failed because something uses the instance (granting that resolving them at compile time enables even this level of error checking)
07:48:51 <maralorn> geekosaur: Do you have an example of code that compiles and compiles again, but differently in presence of a new instance declaration?
07:50:16 <geekosaur> not right on top of my head, but it's happened. the problem here being that (a) you use typeclasses heavily (b) uses are in one package (c) instances are in a different package
07:50:33 <geekosaur> so at no point can this be validated, given separate compilation
07:50:34 <pavonia> For example the formula "\forall a : a -> b" is isomorphic to a type "a -> B" in Haskell when there's a correspondance between b and B?
07:51:25 <geekosaur> whole-program compilation could detect more such problems, but has its own problems (jhc died over them, sadly)
07:52:54 <dminuoso> pavonia: What is a "concrete type" to you?
07:53:31 <pavonia> dminuoso: Something that is not a type variable
07:53:52 <dminuoso> pavonia: I suppose thats a matter of perspective then.
07:53:54 <dminuoso> Consider
07:54:27 <dminuoso> % :set -XScopedTypeVariables
07:54:27 <yahb> dminuoso: 
07:54:40 <dminuoso> f :: forall a. a -> a; f = g where g :: a -> a; g x = x
07:54:41 <dminuoso> % f :: forall a. a -> a; f = g where g :: a -> a; g x = x
07:54:42 <yahb> dminuoso: 
07:56:51 <pavonia> Well, both a's are the same here
08:00:40 <dminuoso> pavonia: Also regarding logic, it depends on what kind of quantification you mean. Individual or propositional variables?
08:01:00 <dminuoso> The former would correspond to dependent types, the latter to parametric polymorphism.
08:02:18 <pavonia> Um, I can even tell the difference between those variable types :S
08:02:26 <kuribas> lyxia: so Nothing = ContT (const (pure Nothing)) and Just = flip runContT (pure . Just)
08:02:29 <kuribas> lyxia: ?
08:02:54 <kuribas> lyxia: erm Just = pure
08:03:11 <kuribas> lyxia: and runMaybeT = flip runContT (pure . Just)
08:03:13 <dminuoso> pavonia: Also note, if you follow this you can see why Haskells type system is an inconsistent logic.
08:03:21 <Orbstheorem> Hi, a friend of mine gave me the following challenge: find a function sh :: (a -> IO b) -> IO (a -> b) or prove that it is impossible. I've been looking for a while but I haven't been able to come up with neither a solution nor the beginning of a proof. My gut tells me it's impossible and I was wondering if someone could provide a hint in either direction ^^
08:03:34 <dminuoso> pavonia: Because we have `undefined :: forall a. a.` we can prove any proposition we want.
08:03:52 <dminuoso> Orbstheorem: There is a solution.
08:04:00 <kuribas> there is unsafePerformIO
08:04:25 <dminuoso> Orbstheorem: Is this a bet about beer?
08:04:31 <Orbstheorem> Ah, I meant from the math point of view ^^, monadic laws and such
08:04:44 <Orbstheorem> dminuoso: it's dinner ^^
08:05:06 <dminuoso> Orbstheorem: Like Simon said on the Haskell exchange... the answer is always bottom!
08:05:08 <kuribas> :t \f -> pure $ \x -> unsafePerformIO f
08:05:09 <lambdabot> error:
08:05:09 <lambdabot>     Variable not in scope: unsafePerformIO :: t -> t1
08:05:30 <Orbstheorem> Hask <3
08:06:10 <dminuoso> kuribas: Use yahb
08:06:22 <dminuoso> lambdabot is quite constrained in what you have
08:06:44 <lyxia> kuribas: exactly
08:07:07 <Orbstheorem> unsafePerformIO it's cheating :P
08:07:20 <kuribas> lyxia: it should be wrapped in a nice package
08:11:43 <dminuoso> Orbstheorem: So if we transform this a bit, it would require `distrib :: (Reader a :.: IO) ~> (IO :.: Reader a)` such that Reader and IO would be distributive.
08:12:13 <dminuoso> (Or I guess, distributive is too strong since that would require the other way around too)
08:16:15 <dminuoso> Orbstheorem: But parametricity dictates, that you cannot produce a `b` from what you have.
08:27:05 <kuribas> lyxia: I wonder if you can implement catch and throw in ContT
08:30:08 <jusss> is there a function like `select' of C in haskell?
08:30:24 <jusss> make IO blocked to non-blocked
08:30:55 <jusss> for example, Network.Socket recv is blocked
08:31:24 <jusss> Network.Socket.ByteString.recv is a blocked function, how to make it async
08:31:51 <dmwit> jusss: https://stackoverflow.com/q/11744527/791604
08:31:56 <geekosaur> jusss, in Haskell you use multiple threads instead
08:32:12 <geekosaur> select() is kinda a hack for single-threaded C
08:33:41 <Rembane> jusss: You can assume that network IO in Haskell is async by default.
08:33:53 <dmwit> what
08:34:20 <jusss> Rembane: what?
08:34:22 <dmwit> I really don't think that's correct. Or I think you are using "async" to mean something different than most people do.
08:34:53 <jusss> geekosaur: but select() is awesome, python use it to do async/await stuff
08:35:03 <nshepperd> plot twist: you can make things async by using the 'async' package
08:35:06 <geekosaur> python also doesn't have sane threads
08:35:07 <nshepperd> jusss: async doBlockingAction >>= (\h -> do { ... poll h ... })
08:35:10 <jusss> also epoll which I didn't know
08:36:08 <nshepperd> or: 'async doBlockingAction >>= (\h -> do { ... wait h ... })' if you want to start the action (or several actions) now and then wait for it to finish later
08:36:09 <geekosaur> you need to lock the whole interpreter regularly to do threads in python, so you have to use things like select. real threaded languages don't need that hack, you do things in threads which can block without blocking the whole program (or whole interpreter in python's case)
08:37:05 <jusss> nshepperd how I can use async in a do-notation
08:37:28 <jusss> like `recv socket 1024' is a blocked action
08:37:43 <geekosaur> @redo async doBlockingAction >>= (\h -> do { ... poll h ... })
08:37:43 <lambdabot> Maybe you meant: undo todo do
08:37:59 <geekosaur> @do async doBlockingAction >>= (\h -> do { ... poll h ... })
08:37:59 <lambdabot> <unknown>.hs:1:40:Parse error: ...
08:38:22 <geekosaur> oh, right, wn't do the ellipses
08:38:42 <geekosaur> @do async doBlockingAction >>= (\h -> do { x <- poll h; return x })
08:38:42 <lambdabot> do { a <- async doBlockingAction; (\ h -> do { x <- poll h; return x}) a}
08:39:20 <geekosaur> which is ugly, so didn't help. but >>= is what do notation turns into; and you should learn that so you understand what's going on with do
08:39:31 <geekosaur> it's not magic, it's mechanical
08:39:44 * hackage call-alloy 0.1.0.0 - A simple library to call Alloy given a specification  https://hackage.haskell.org/package/call-alloy-0.1.0.0 (marcellus)
08:39:57 <nshepperd> do { h <- async (recv socket 1024); do some other stuff; answer <- wait h ; do stuff with answer }
08:46:06 <Darwin226> So I have this piece of code https://gist.github.com/LukaHorvat/c0a7ffcfd76cdbe5436c859dd88d0ac0
08:46:30 <Darwin226> I'm getting and error that GHC can't deduce T Int and T Bool from (forall a. T a)
08:47:01 <Darwin226> Shouldn't this work? I'm asking for a more general context than what I actually need, but shouldn't I be able to use a subset of that context?
08:52:01 <jusss> nshepperd can we set a timeout for that?
09:09:54 <nshepperd> jusss: dunno. probably. read through https://hackage.haskell.org/package/async
09:11:07 <nshepperd> if nothing else you can do timer <- async (threadDelay 1000000) and then waitEither timer h
09:13:49 <jusss> nshepperd ok
09:25:14 <dsal> jusss: http://hackage.haskell.org/package/base-4.12.0.0/docs/System-Timeout.html
09:32:50 <electricityZZZZ> simon peyton jones says nonstrict eval by default was a design mistake, but i've asked in here about it and people seem to either like or love it and appear to consider dealing with the occasional thunk leak or whatever you want to call it no big deal,... what's the real story here? is the jury still out?
09:34:30 <int-e> I love laziness until my program is too slow or runs out of memory (or, mostly historically, overflows the stack).
09:36:48 <wildtrees> I like laziness, until the lazyio doesnt respond correctly over network sockets , it just pauses for who knows how long 
09:38:18 <int-e> I think lazy IO is generally viewed as a mistake.
09:38:29 <int-e> (Though it can be very convenient when it works.)
09:42:37 <jusss> dsal: ok
09:43:52 <MacOSInstall> Can anyone send me detailed tutorial on how to install ghci on mac os.. sorry for being a newbie
09:45:54 <dsal> MacOSInstall: brew install ghc    or   https://docs.haskellstack.org/en/stable/install_and_upgrade/
09:46:01 <sm[m]> I like laziness. I’d really like to try a fully non-lazy haskell, differing only in this respect, to compare
09:46:04 <electricityZZZZ> so why not make haskell++ with strict io, and whatever else needs to be strict?
09:46:14 <electricityZZZZ> sm[m]: purescript?
09:46:30 <dsal> Fully non-lazy haskell would make a few common things impossible, wouldn't it?
09:46:53 <sm[m]> I expect so
09:47:05 <electricityZZZZ> dsal: which few common things?
09:47:23 <dsal> > zip [1, 2, 3] $ repeat "this"
09:47:26 <lambdabot>  [(1,"this"),(2,"this"),(3,"this")]
09:48:03 <electricityZZZZ> why can't that be strict?
09:48:20 <LKoen> > repeat "this"
09:48:23 <lambdabot>  ["this","this","this","this","this","this","this","this","this","this","this...
09:48:44 <dsal> It'd have to mean something quite a bit different, I suppose.  It's no longer a list, but a generator.
09:48:46 <electricityZZZZ> oh right haskellers like infinite data structures
09:49:16 <electricityZZZZ> i really dont understand the infinite data structure phenomenon, most coding practice guidelines i've seen caution against "non-terminating loops" and other infinite things
09:49:29 <electricityZZZZ> actually not just caution against but prohibit entirely
09:49:30 <dsal> Just because it's infinite doesn't mean it doesn't terminate.
09:49:48 <electricityZZZZ> sure but it creates the risk of nontermination
09:49:53 <dsal> A zip of a list of three elements and an infinite list is well-defined.
09:51:09 <dsal> You also have to figure out how to do things like this:
09:51:10 <dsal> > maybe undefined succ $ Just 5
09:51:13 <lambdabot>  6
09:52:04 <Darwin226> My favorite argument for lazyness is that it increases compositionality. Things like: minimum xs = head (sort xs)
09:52:17 <Darwin226> is O(n) instead of O(nlogn)
09:52:27 <electricityZZZZ> darwin226: yeah i've heard that a lot but i am very skeptical of how often that is useful in real world implementations
09:53:41 <electricityZZZZ> it would make more sense imo to have some kind of static analyzer for your code and have the analyzer recommend more efficient algorithms or implementations
09:53:54 <electricityZZZZ> rather than at runtime do things which are more difficult to reason about
09:54:31 <Darwin226> Yeah, I can't say I personally used it a lot. On the other hand a very practical thing that annoys me in strict langauges is things like someOptionalValue.defaultIfNotPresent(someExpensiveFunction())
09:54:35 <LKoen> Darwin226: well, is that really guaranteed by the specification?
09:54:51 <Darwin226> always calls the someExpensiveFunction, even if the optional value is present
09:54:54 <LKoen> minimum xs = head $ sort xs, I mean
09:55:59 <Darwin226> LKoen No idea, but it does behave faster than the strict version in reality
09:57:43 <Darwin226> electricityZZZZ We do have that, but for the other direction. I'm guessing determining if a strict algorithm can be made faster with lazyness is as hard as determining which arguments should actually be strict in a lazy language
10:00:08 <electricityZZZZ> "how often" does the laziness for a strict implementation result in an efficiency gain?
10:01:15 <Darwin226> Asymptotically, I think always?
10:01:28 <Darwin226> In practice, no idea
10:10:14 * hackage git-annex 7.20191024 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-7.20191024 (JoeyHess)
10:11:31 <EvanR> electricityZZZZ: it's really an opinion on defaults, since we have many ways to introduce strictness in various scales
10:11:58 <electricityZZZZ> the purpose of a language is significantly to impose standards on best practices
10:12:05 <EvanR> if you wanted it. Which at this point i really don't think we do
10:12:20 <EvanR> really O_o
10:12:38 * Lycurgus always thought the purpose of non strict was convenience/programmer efficiency
10:12:46 <electricityZZZZ> yeah i really just want smart people to tell me the best way to program a computer and then i want to follow their practices
10:13:05 <electricityZZZZ> i don't have time both to write my programs and explore all possible ways of doing so
10:13:08 <EvanR> unfortunately, you are using haskell. You are now that smart person and people will be asking you to do that
10:13:11 <EvanR> good luck
10:13:26 <electricityZZZZ> ha, i'm not using haskell yet :-P
10:13:54 <Darwin226> In that case, you probably don't need to worry about lazyness too mush
10:14:02 <Darwin226> it really doesn't come up that often
10:14:24 <EvanR> indeed if you're not using haskell it's pretty rare!
10:14:35 * Lycurgus boy did e get a wrong number!
10:14:46 <Darwin226> As someone that tries compiling modules with -XStrict every now and then, it very rarely makes a difference in performance
10:17:18 <EvanR> i think lazy record fields by default has gotten me enough times
10:18:02 <EvanR> also, i know to be wary of lazy IORef, lazy MVar etc
10:18:05 <dsal> Hmm...  I've never considered laziness of record fields.
10:18:18 <dsal> EvanR: how does it "get" you?
10:18:49 <EvanR> if your app piles on updates to these things, they don't happen until something uses the value
10:19:11 <EvanR> in the worst case you almost never look and live memory keeps growing
10:19:38 <dsal> Yeah.  I guess I should think about where that might matter to me.
10:21:20 <EvanR> for example if you have a record with a counter in it, and sometimes you increment the counter but never use the value for anything (yet, or because the feature that would use it is disabled)
10:21:40 <EvanR> it's a simple fix, make the field / IORef / whatever strict
10:24:07 <dsal> Strict fields are probably a good default.
10:25:54 <Darwin226> -XStrictData does that
10:29:58 <EvanR> how many levels of default are you on
10:31:42 <EvanR> (why did it take me so long to search this up... ) https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#strict-by-default-data-types
10:37:44 * hackage attoparsec-time 1.0.1.1 - Attoparsec parsers of time  https://hackage.haskell.org/package/attoparsec-time-1.0.1.1 (NikitaVolkov)
10:44:10 <electricityZZZZ> on a different note can people help me understand why databases/SQL exists? i am finding that i am "supposed to use SQL" but i am also "supposed to have a good type system"
10:44:25 <electricityZZZZ> so i implement my application in a language which has a good type system, but then i can't use that type system in the database
10:45:49 <electricityZZZZ> gotta run bbl
10:53:34 <EvanR> just checked on haskelldb
10:54:22 <EvanR> HSQL and wxHaskell(??) backends supposedly supported
11:21:18 <EvanR> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#conlike-modifier guessing CONLINE is a type despite CONLINE and CONLIKE both not being real words. Since CONLINE only appears once?
11:21:28 <EvanR> is a typo*
11:25:33 <opqdonut> > The name “CONLIKE” is short for “constructor-like”
11:25:35 <lambdabot>  <hint>:1:10: error: lexical error at character 'C'
11:25:36 <opqdonut> probably yeah
11:25:50 <opqdonut> (feh, how do I always try to quote with > here)
11:27:16 <EvanR> what's constructor like
11:28:02 <opqdonut> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#how-rules-interact-with-conlike-pragmas
11:28:05 <opqdonut> read for yourself
11:30:43 <EvanR> so application of constructors are cheap enough to duplicate, because all they do is allocate a thing and put pointers in it
11:31:04 <EvanR> though they are not cheap in the sense that this contributes directly to garbage pressure
12:14:44 * hackage rewrite-inspector 0.1.0.10 - Inspection of rewriting steps  https://hackage.haskell.org/package/rewrite-inspector-0.1.0.10 (omelkonian)
12:33:53 <Ariakenom> EvanR: ah but GHC is built for garbage :)
12:39:50 <EvanR> i really want to put that to the test...
12:42:03 <moet> hi, if i recall correctly, there's a way to use a typeclass to group some constraints into one, so that you only need to declare the single typeclass
12:42:59 <dmwit> moet: class (A a, B a, C a) => D a; instance (A a, B a, C a) => D a -- with no extensions
12:43:08 <dmwit> moet: type D a = (A a, B a, C a) -- with extensions
12:43:53 <dmwit> Hm. I guess even the first one needs extensions. But less controversial ones.
12:44:02 <dmwit> (Not that ConstraintKinds is particularly controversial.)
12:44:09 <moet> Hmm, yeah, that's what i was thinking of.. i guess the problem i'm having different
12:45:14 <moet> let me come up with a small repro
12:58:32 <moet> what's our favorite pastebin these days?
12:58:42 <moet> lpaste seems to not be a thing...
12:59:11 <hololeap> my favorite is dpaste.com
12:59:26 <hololeap> but not many seem to know about it
13:00:01 <dmwit> gist.github.com also seems to work
13:00:09 <justsomeguy> I like termbin.com . It's simple and doesn't require javascript.
13:01:34 <moet> thanks i'll try one of those
13:03:25 <moet> ok, here's a repro of what i'm doing in code, in all it's uglyness... termbin.com/rkil
13:03:27 <moet> my question is in the paste
13:03:44 * hackage lenz-mtl 0.1 - mtl operations with Van Laarhoven lenses  https://hackage.haskell.org/package/lenz-mtl-0.1 (MatthewFarkasDyck)
13:04:55 <moet> there's two levels to the question (1) can the constraints be grouped easily? (2) can we back up and solve the problem differently so that the standalone instance and UndecidableInstances isn't required?
13:07:44 <dmwit> type BothShow a = (Show a, Show (Idx a)) -- ?
13:08:26 <dmwit> You could also change the class, though I don't recommend it: class Show (Idx a) => Foo a where ...
13:08:33 <siraben> Is it possible to pattern match on (++) as Wadler does on page 4 of "A Prettier Printer"? https://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf
13:08:42 <dmwit> err
13:08:51 <dmwit> class (Show a, Show (Idx a)) => Foo a where ... -- I mean
13:08:52 <siraben> He writes; text (s ++ t) = text s <> text t; text [] = nil
13:09:01 <dmwit> siraben: no
13:09:16 <dmwit> That is not a pattern match, but a law.
13:09:19 <siraben> I know (++) is not a constructor, but examples of Haskell code matching on (++) appears quite often
13:09:23 <siraben> In books and such
13:09:27 <siraben> Ah.
13:09:47 <justsomeguy> To be honest, I can't understand your paste. This is probably just because I'm new to haskell and have never used any language extensions, though.
13:09:53 <__monty__> One exception is there's matching for arithmetic operations I think?
13:09:57 <justsomeguy> The class Foo looks funky.
13:10:04 <EvanR> siraben: if ++ were a class method, then you could define many instances...
13:10:09 <siraben> __monty__:  Yeah, j+k matches
13:10:21 <siraben> It's not encouraged anymore, IIRC.
13:10:27 <dmwit> Indeed not.
13:10:34 <EvanR> i tough n+k patterns are a gone pecan?
13:10:41 <dmwit> Perhaps one day somebody will design a sensible InjectiveMatches extension or something, and then that would be ok.
13:10:54 <dmwit> But n+k patterns are too special-case for most folks' taste.
13:12:32 <moet> dmwit: changing the class still requires the standalone deriving instance on Extractor
13:12:36 <moet> so that seems unavoidable
13:12:46 <moet> i guess i'll just define the alias to the constraints
13:13:04 <moet> because then i'm not adding strange constraints to the class
13:13:07 <dmwit> moet: You could make Foo have higher kind.
13:13:41 <dmwit> Hm, ignore that. It's not a good idea.
13:14:40 <moet> i wish i knew how to evaluate ideas like that
13:17:50 <dmwit> moet: https://gist.github.com/dmwit/0bf2b43eaf537066d7c1493a2beeb7e8
13:25:23 <EvanR> siraben: type class mechanism can sort of make it seem like you are matching on operators
13:36:55 <hellcode> hello all
13:37:42 <hellcode> I am wondering, eh... what is a good emacs package to use haskell? sort of like SLIME wouldbe for Common Lisp...
13:39:46 <justsomeguy> hellcode: I don't really understand how it works, but spacemacs automatically installs an extension for haskell that shows type signatures for functions and has really nice syntax highlighting.
13:40:55 <hellcode> does it open a repl as well?
13:41:25 <shapr> I think yes, though I forget which one it uses
13:42:32 <hellcode> I guess I can just use haskell-mode see how it goes 
13:43:44 * hackage schemas 0.3.0.1 - schema guided serialization  https://hackage.haskell.org/package/schemas-0.3.0.1 (PepeIborra)
13:47:33 <dsal> hellcode: I use haskell-mode.  It gives you a repl.  I don't know that it's as nice as slime, but I have very little experience with slime.
13:49:06 <hellcode> ah, it doesn't really matter
13:49:10 <hellcode> I just need a repl lol
13:49:37 <hellcode> so I don't have to be juggliging windows or opening ghc through run-program
13:49:47 <justsomeguy> I think you can do that without any extensions.
13:50:27 <justsomeguy> M-x term
13:50:36 <justsomeguy> and then run ghci from there.
13:51:23 <justsomeguy> Heh, somehow I've learned all this weird emacs stuff even though I've only spent maybe 10 minutes using it directly.
13:51:27 <shapr> hellcode: I'm using haskell-interactive and that lets me load a buffer ghci by pressing C-c C-l
13:54:46 <hellcode> oh I found it thanks shapr 
13:56:07 <svipal> type role conflicts will end up killing me
13:57:20 <justsomeguy> Hey, at least recursion doesn't make your eyes bleed anymore.
13:58:55 * justsomeguy decides to be a good noob and stop cluttering the channel with inane comments
13:59:08 * shapr hugs justsomeguy
13:59:45 <svipal> type role conflicts are not so bad, I guess I'm just grumpy
13:59:56 <svipal> justsomeguy: touché
14:01:37 <Cale> svipal: It's just too bad that type roles are not themselves similar in nature to types. It's impossible to express the manner in which the role of some parametric type might depend on the arguments it's given.
14:08:06 <Cale> John Ericson also had some interesting ideas regarding how to replace the role system with something more general here: https://github.com/Ericson2314/ghc-proposals/blob/coercions-without-roles/proposals/0000-coercions-without-roles.rst
14:12:52 <moet> dmwit: i'm trying to understand what you did in that gist above
14:13:33 <moet> looks like instead of using an associated type-family you're using an associated type-constraint-family?
14:13:56 <moet> and then in the constraint you use the equality constraint to effect the same outcome as the literal type?
14:16:02 <moet> i'll experiment with it and see if i can understand it
14:16:04 <moet> thank you
14:29:45 <crestfallen> hi there's scant (zero?) information on  `as Applied To`. some people here were using it here yesterday
14:30:02 <crestfallen>  `as AppliedTo`
14:30:18 <crestfallen>  `asAppliedTo`is what I searched for :)
14:31:54 <int-e> :t asAppliedTo
14:31:55 <lambdabot> (a -> b) -> a -> a -> b
14:32:26 <crestfallen> thanks so it's only on lambdabot? int-e
14:32:33 <int-e> hmm
14:32:37 <crestfallen> ok thanks
14:32:37 <int-e> @hoogle asAppliedTo
14:32:38 <lambdabot> No results found
14:32:48 <int-e> good question
14:32:55 <crestfallen> weird
14:33:20 <int-e> Yes it is.
14:33:22 <int-e> @where L.hs
14:33:22 <lambdabot> what lambdabot has in scope is at http://silicon.int-e.eu/lambdabot/State/Pristine.hs
14:34:00 <int-e> Don't ask me why... what is or isn't in Pristine.hs is pretty random.
14:36:06 <crestfallen> anyway I did a type unification as per member's help here. I know what asAppliedTo does; but my sense of it's definition and type is shaky 
14:37:18 <crestfallen> @src asAppliedTo
14:37:18 <lambdabot> f `asAppliedTo` a = f where _ = f a
14:37:19 <lambdabot> infixl 0 `asAppliedTo`
14:38:56 <crestfallen> :t asAppliedTo
14:38:58 <lambdabot> (a -> b) -> a -> a -> b
14:40:23 <svipal> what's the use of that function ?..
14:41:49 <crestfallen> to illustrate steps in unifying types. svipal I'll paste something one sec
14:42:40 <crestfallen> svipal:     https://termbin.com/bx0ph    
14:43:06 <svipal> thanks, will read it when my head is less of a mess
14:43:28 <crestfallen> take a cold shower if you live in Cali
15:03:44 * hackage esqueleto 3.1.2 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-3.1.2 (parsonsmatt)
16:12:55 <developer> > take 5 [1..5]
16:12:57 <lambdabot>  [1,2,3,4,5]
17:04:14 * hackage predicate-typed 0.1.0.2 - Predicates, Refinement types and Dsl  https://hackage.haskell.org/package/predicate-typed-0.1.0.2 (gbwey)
17:29:14 * hackage cabal-cache 1.0.1.2 - CI Assistant for Haskell projects  https://hackage.haskell.org/package/cabal-cache-1.0.1.2 (haskellworks)
17:34:32 <Ospite-439> @  @@a3
17:38:06 <fraktor> I'm inside a function that is a ReaderT a EitherT b IO c, and I'm calling a function that is ReaderT a IO c.  When I try to get that result as a tuple using the <- operator, I get a could not match expected type error.  How can I diagnose and fix this?
17:38:06 <Ospite-232> /PART
17:43:18 <dmwit> fraktor: You have a couple options. The mtl way is to change your ReaderT a IO c action to be a (MonadReader a m, MonadIO m) => m c action instead. Then you can just call it.
17:43:52 <dmwit> fraktor: (Similarly, the one you're implementing now would become something like `(MonadReader a m, MonadError b m, MonadIO m) => m c`.)
17:44:16 <dmwit> fraktor: If for some reason you can't or don't want to do that, you could take a look at the mmorph package. But that way is much more painful, so I strongly recommend doing things the mtl way.
17:45:11 <fraktor> dmwit: Hmm.  I'm actually using some Servant types, which is where some of those transformers come in.  I'l post a minimal example real quick
17:45:50 <fraktor> https://0paste.com/40767#hl
18:33:11 <dmwit> fraktor: I'm not sure why you told me that. Anyway I'm pretty sure it doesn't change my answer.
18:35:36 <mozzarella> guys
18:36:10 <mozzarella> shit, wrong channel
18:36:40 <suzu> no no come back
18:36:43 <suzu> address us
18:37:44 * hackage range 0.3.0.0 - An efficient and versatile range library.  https://hackage.haskell.org/package/range-0.3.0.0 (RobertMassaioli)
18:41:08 <slack1256> @slap suzu don't look needy !
18:41:09 * lambdabot slaps suzu don't look needy !
18:41:09 <fraktor> dmwit: It's because I don't know enough about how to change the signatures for Servant types.
18:41:32 <fraktor> I'll still see if I can implement your suggestion though.
18:42:45 * suzu makes a sad face like this: :(
18:44:30 <slack1256> It's a joke though!
18:44:37 <dmwit> fraktor: `cmdListTopics :: Monad m => Connection -> GMRequest -> [String] -> m (String, [GMAttachment])`
18:45:14 <fraktor> What if I need to use asks at some point though? I just didn't include that in the example.
18:45:20 <fraktor> Will the type system figure that out?
18:45:30 <dmwit> Just toss `MonadReader Integer m` in the context.
18:45:45 <dmwit> (This is what I showed you in my original response...)
18:45:47 <fraktor> Cool cool.
19:21:44 * hackage range 0.3.0.1 - An efficient and versatile range library.  https://hackage.haskell.org/package/range-0.3.0.1 (RobertMassaioli)
19:22:36 <koz_> Is there a way I can see all the (base) type classes that (->) a is an instance of?
19:23:37 <suzu> :i (->) tells me a bunch
19:24:00 <suzu> instance Applicative ((->) a) -- Defined in ‘GHC.Base’
19:24:03 <suzu> instance Functor ((->) r) -- Defined in ‘GHC.Base’
19:24:05 <suzu> etc
19:24:21 <koz_> suzu: Thanks.
19:24:28 <MarcelineVQ> suzu: yeah but unless you import all the base modules it won't be complete
19:24:46 <suzu> import Relude and then ask ghci
19:24:47 <suzu> /shrug
19:24:48 <MarcelineVQ> e.g. import Control.Arrow and you'll see that :i change
19:28:28 <koz_> suzu: I tried that - it definitely didn't give me any Arrow-related instances. :P
19:28:55 <rotaerk> do what Marceline said
19:37:19 <suzu> yeah you have to have the instances in scope for ghci to help you out
19:37:26 <suzu> so just toss on all the modules you care about
19:37:54 <fraktor> dmwit: I'm trying to implement your suggestion, but I can't get it to compile.
19:38:13 <fraktor> Mostly because it can't determine that IO satisfies the MonadIO constraint (I believe, but it's hard for me to tell).
19:57:40 <EvanR> i find it hard to believe that is the problem
20:05:10 <fraktor> As do I
20:16:38 <MarcelineVQ> that's a hint to show the error and code that causes it
20:29:46 <fraktor> MarcelineVQ: Yes. I'
20:29:56 <fraktor> ve changed it around so much I'm not sure I could get it back to that point though.
20:42:44 * hackage range 0.3.0.2 - An efficient and versatile range library.  https://hackage.haskell.org/package/range-0.3.0.2 (RobertMassaioli)
21:28:14 * hackage reanimate-svg 0.9.4.0 - SVG file loader and serializer  https://hackage.haskell.org/package/reanimate-svg-0.9.4.0 (DavidHimmelstrup)
21:58:47 <jusss> a ByteString ":nick!~user... PRIVMSG #channel: msg", how I can get the nick and msg?
22:02:16 <ChaiTRex> jusss: Between starting colon and first ! is nick. After PRIVMSG target is either one word message or colon followed by multiword message
22:02:32 <ChaiTRex> jusss: Not sure how to do substrings with ByteString, sorry.
22:02:53 <jusss> ChaiTRex: http://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString.html
22:03:42 <shachaf> Are you just asking people who don't know how to use the API to figure it out and write your program for you?
22:04:17 <shachaf> What's your question in particular? There's nothing built-in in Haskell for parsing IRC syntax, so you'll have to write code to do it.
22:06:10 <jusss> sorry, I just wonder if there's a more better way to do this
22:10:15 <shachaf> Better than what?
22:18:08 <jusss> better way to get msg from this ByteString,
22:18:38 <jusss> one way, we can filter ":" "!" and "#channel"
22:18:55 <jusss> another way, just filter "!....#channel"
22:19:51 <jusss> or turn this to a list, so we can do like [1,2,3] \\ [1,2]
22:27:17 <wejetheman> so this is a rather vague question... but im sort of wondering how to handle situations where you need to perform separate steps sequentially to solve a problem but they are all so intimately related that you dont want to define a bunch of functions that call each other to do it. So in this first example I needed to always take the first character
22:27:18 <wejetheman> from any given input and then i needed to recurse on the rest but not keep taking the first with each recursion. http://codepad.org/tZTEGhsN (please excuse that its kinda bad it was one of my first)
22:28:08 <wejetheman> so that was how I handled it but it felt pretty sketchy at the time and it still doesnt sit quite right with me...
22:29:52 <ChaiTRex> jusss: Filtering's not going to help. If you filter out, for example '!', what happens if the message contents have a '!'? You'll ruin the message.
22:30:02 <wejetheman> this last one i was supposed to check phone number inputs to make sure they are valid and output them in a simple numerical format, http://codepad.org/osF8vXgE again i needed to check the logic, transform it, and do different checks on the new format 
22:30:55 <wejetheman> and i guess im just wondering if the way i handled it was the best way to handle it
22:39:17 <ChaiTRex> @hoogle [Maybe a] -> [a]
22:39:18 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
22:39:18 <lambdabot> System.Directory.Internal.Prelude catMaybes :: () => [Maybe a] -> [a]
22:39:18 <lambdabot> Distribution.Compat.Prelude.Internal catMaybes :: () => [Maybe a] -> [a]
22:40:19 <ChaiTRex> wejetheman: You can probably use catMaybes (zipWith f xs (tail xs))
22:40:54 <ChaiTRex> wejetheman: Then have the f return Nothing if you don't output a character, or Just capitalLetterInAcronym if you do.
22:41:24 <ChaiTRex> wejetheman: So, f 'a' 'B' would return 'B', for example.
22:41:51 <ChaiTRex> Sorry, Just 'B'
22:42:16 <ChaiTRex> wejetheman: and f 'a' 'a' would return Nothing.
22:44:11 <ChaiTRex> wejetheman: But your code is pretty understandable to begin with.
22:45:00 <wejetheman> yea I was just kind of wondering if nesting the recursion inside the where was the way to go about that sort of thing 
22:45:35 <ChaiTRex> wejetheman: Oh, as far as your current solution, yeah, the where is a good place.
22:50:59 <wejetheman> what about this http://codepad.org/1b2oj3KI is breaking parse into parse and parse' like that a good way to handle things?
22:52:15 <wejetheman> if it was all one function it would have more complex conditionals () && () kinda stuff
22:53:04 <wejetheman> where as breaking it up has some big advantages but it feels... weird...
22:53:34 <phanimahesh> Can this be made pointfree? `\x -> (f x) . g x` I forgot the lambdabot trigger. :/
22:53:56 <sarahzrf> @pl \x -> f x . g x
22:53:56 <lambdabot> liftM2 (.) f g
22:54:02 <sarahzrf> i would use liftA2
22:54:10 <sarahzrf> pl for pointless
22:54:14 <phanimahesh> Thanks!
22:54:17 <ChaiTRex> wejetheman: Yes, it separates concerns nicely.
22:54:17 <sarahzrf> :)
22:55:19 <phanimahesh> Can't believe I didn't see it. Not yet good at type tetris.
22:56:37 <wejetheman> awesome, I guess ill submit it to the mentor with confidence. thanks for taking a look.
22:58:21 <ChaiTRex> wejetheman: No problem.
23:35:04 <dmwit> jusss: There are many parser combinator libraries. Use one of them. Or use alex+happy.
23:39:18 <dsal> I use megaparsec like a perl programmer uses regex.
23:39:32 <jusss> dmwit: if there's a list [32,80,82,73,86,77,83,71,32,35,108,105,110,117,120,98,97,58], how we can just get one part of it? like get [110,117,120] ?
23:40:01 <dmwit> jusss: There are many parser combinator libraries. Use one of them. Or use alex+happy.
23:40:14 <dmwit> You can't trick me just by displaying the data in a different format. The answer is still the same.
23:41:20 <jusss> fine, but with \\ should do something
23:41:57 <dsal> :t (\\)
23:41:58 <lambdabot> Eq a => [a] -> [a] -> [a]
23:42:11 <koz_> dsal: To solve every problem, inappropriately? :P
23:42:17 <dsal> koz_: best as I can.  heh
23:42:37 <dsal> Probably more like, "This is likely overkill, but I like my screwdriver."
23:43:11 <shachaf> Writing a parser by hand is a reasonable thing to do too.
23:43:37 <shachaf> But asking people to write a parser for you isn't very reasonable.
23:49:10 <Rembane> koz_: I would love to have that on a t-shirt. 
23:51:53 <koz_> Rembane: Wait, you mean 'To solve every problem, inappropriately'?
23:53:18 <Rembane> koz_: Yes! 
23:54:07 <koz_> Rembane: Lol.
