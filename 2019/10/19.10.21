00:06:34 <guest1234566> Hi, I have a data type of Field, which can be a Text, Number, LatLon etc. Depending upon these the values in the Field data type would be resolved. How should I do this in Haskell ? From an imperative language prospective, I can do abstract class/interface etc to join and make this happen. But in Haskell, is typeclass recommended to do this ? 
00:11:08 <jackdk> I don't completely understand what you are asking, but maybe something like data Field = FText Text | FNum Number | FPos LatLong and decode :: Text -> Maybe Field ?
00:17:42 <guest1234566> jackdk rough representation of what I have in my mind https://gist.github.com/shadow-fox/5c594b38b484095224a7c7432cd0a75d 
00:31:25 <c_wraith> But why?
00:31:50 <jackdk> I'm going to have to tag out here. It's the end of the day and I'm very tired. I agree with c_wraith though, this might be an XY problem...
00:33:13 <c_wraith> that's a very OO kind of approach.  Do you actually need to make that tradeoff?  Is the set of Fields open?
00:36:35 <c_wraith> I'm not saying it's wrong.  I've done things like that.  But it's rare for it to be the right set of tradeoffs.  You need it to be the case that the set of values is open but the range of behaviors is not.
00:44:35 <guest1234566> c_wraith set of Fields is open, the behaviour of the each type of Field depends on what type it is. 
00:45:04 <guest1234566> Am I thinking in a wrong way ? May I have a reference point on how to design this ? 
00:45:47 <tdammers> guest1234566: looks like you want OOP, which may or may not be appropriate. you could try the simplest implementation of that, something like:
00:46:10 <tdammers> data Field = Field { fieldName :: Text; fieldValue :: Value; fieldTokenizer :: Value -> Tokens }
00:46:33 <tdammers> and then data Value = TextValue Text | NumberValue Number | LatLongValue LatLong | ...
00:46:43 <guest1234566> tdammers Ah. I never thought of this way. 
00:46:50 <tdammers> HOWEVER
00:47:02 <tdammers> the question is whether you actually need this
00:47:13 <tdammers> so it would be interesting to know the context for this
00:47:19 <tdammers> what it the actual problem you're solving
00:47:51 <tdammers> it might be that you can simply have the tokenizer depend on the Value constructor
00:48:14 <tdammers> i.e., just one tokenizer function of type Value -> Tokens, which would look at the Value and do whatever is required
00:48:45 <guest1234566> I am trying to write a library to index and search text data (wikipedia e.g.). This is the project I am working on. I have implemented something like this in OOP however I wanted to do in FP mainly in haskell. 
00:49:12 <tdammers> OK, but if it's just text data, why the Number and LatLong types?
00:50:20 <guest1234566> cause there will be values as number, latiitude longiitude, range values as well such as from 1900 to 2000 (year). etc. 
00:50:57 <ariakenom> . o O (data Field a = Field {name :: Text; value :: a; tokenizer :: a -> Tokens})
00:52:26 <tdammers> think about the structure of your data a little more
00:52:44 <tdammers> I'm fairly convinced that you don't need to have the tokenizer as a function value inside your record
00:53:05 <tdammers> my guess would be that you can do one of the following
00:54:11 <tdammers> A: come up with a more rigid structure for your records, so that you can ditch the "name" field, and just have a plain record type describing, well, a record: data Record = Record { pageTitle :: Text, keywords :: [Text], dateRange :: (Year, Year), geoData :: LatLng, ... }
00:54:44 <tdammers> no idea what that structure is, but if you can come up with one that makes sense, then this would be the obvious implementation
00:55:46 <tdammers> B: if you really need to have arbitrarily structured records, then you can probably still come up with a small finite number of "field types", so you'd just do data Field = Field { name :: Text, value :: FieldValue }; or maybe even just type Record = Map Text FieldValue
00:56:38 <tdammers> with data FieldValue = PageTitle Text | Keyword Text | DateRange Year Year | GeoPosition LatLng | ...
00:57:58 <guest1234566> tdammers this has helped me visualize the problem I was facing. I have now enough of data points to make my structure better. Thank you so much. 
00:58:11 <tdammers> yw
00:59:02 <tdammers> fwiw, I find that Haskell is a great tool for sorting out such things
00:59:10 <tdammers> once you're fluent in it, that is
00:59:38 <guest1234566> ariakenom that snippet is what I might go towards. However as suggested by tdammers I am going to think about the problem and try to come up with a minimal approach to solve this so that I dont dwell on what the entire application looks like. 
01:01:54 <ariakenom> guest1234566: yes. make simple things. especially if you dont know what you're doing :p
01:03:06 <guest1234566> ariakenom I am clueless. I know the theory however I have Zero practical experience in haskell. 
01:16:44 * hackage postgresql-pure 0.1.1.0 - pure Haskell PostgreSQL driver  https://hackage.haskell.org/package/postgresql-pure-0.1.1.0 (kakkun61)
01:21:01 <EvanR> everyone knows binary blob is unstructured. Also String is unstructured. Today I learned (tm) that JSON is unstructured. Where does it stop?
01:21:49 <opqdonut> I've definitely seen JSON that feels unstructured.... :)
01:23:09 <EvanR> yes. The input to the compiler in the course notes on finally tagless style is JSON
01:24:57 <EvanR> to avoid reductio ad absurdum it must be that unstructured is some kind of relativistic thing about the intended use of the data
01:25:14 * hackage postgresql-pure 0.1.2.0 - pure Haskell PostgreSQL driver  https://hackage.haskell.org/package/postgresql-pure-0.1.2.0 (kakkun61)
01:25:54 <mniip> is there an "elementary" adjunction that generates Writer?
01:27:17 <mniip> (elementary meaning preferably simpler than those you can construct for any monad (into the category of algebras, or into the kleisli category))
01:27:46 <merijn> EvanR: Well, the JSON is structured, but the data encoded to the JSON is unstructured (i.e. doesn't conform to a pre-defined spec)
01:28:09 <kaba> Hi, how could I have a polymorphic return type? I would need to have some parametric types as arguments and the return type would be one of those
01:28:39 <jle`> kaba: you could return (Either a b), which the result would be either a or b
01:28:52 <EvanR> aeson includes a parser API so that you can extract meaningful data from "unstructured" json :)
01:29:19 <EvanR> so unstructured is like euphemisism for "not in the form i want"
01:29:24 <merijn> kaba: The return has to be a single type, you can't write something like "Either a b -> ?" where ? is 'a' or 'b'
01:29:31 <EvanR> "with possible gibberish"
01:29:47 <merijn> EvanR: No, unstructured is just "not conforming to a spec"
01:30:01 <merijn> Or rather it may conform to some ad hoc undocumented spec
01:30:41 <merijn> EvanR: When people say JSON is unstructured they don't mean the "JSON" is unstructured, they're considering the JSON as a sort of "carrier format" that data has been dumped into without any spec
01:31:07 <kaba> merijn: I found this blogpost and I don't really understand then. Is it because it's ad-hoc polymorph? https://eli.thegreenplace.net/2018/return-type-polymorphism-in-haskell/ 
01:31:13 <EvanR> well, whatever the provenance, this input JSON is unarguably JSON
01:31:27 <merijn> EvanR: Compare to, for example, XML with a proper DTD or SQLite, here the "carrier format" is defined, just like with JSON, but now the *content* is also structured
01:31:47 <EvanR> without the provenance, you have to consider it "arbitrary JSON"
01:32:18 <EvanR> XML with the proper metadata is... still XML
01:32:39 <merijn> EvanR: XML with a proper DTD doesn't *just* specify that it's XML
01:33:04 <merijn> EvanR: It also specifies exactly which fields can be contained within that XML, in which order, which are optional, which can contain multiple entries, etc.
01:33:29 <EvanR> really.. ok well my profound realizable hasn't reached XML yet
01:33:31 <merijn> EvanR: That's the entire point of having a DTD, they're a validatable spec restricting a file to be less than "some random XML gobbledygook"
01:34:00 <EvanR> validatable
01:34:20 <svipal> that is a nice word, that I'm going to use
01:34:26 <svipal> valid data table
01:34:52 <merijn> EvanR: A proper DTD is an assertion that the file *will* conform (of course you shouldn't trust random strangers to not lie, but then almost no one bothers with a proper DTD anyway)
01:35:17 <guest1234566> Seeking blog post on use-case of typeclasses, how it is used in real-world scenario. 
01:35:30 <EvanR> guest1234566: that is kind of a big question
01:35:54 <svipal> what's your scenario ? they're pretty useful in a lot of contexts
01:36:22 <merijn> I'm pretty sure I haven't ever written more than, say, 10 lines of Haskell without using some typeclass :p
01:36:44 <guest1234566> I want to know whether I can model my library with typeclasses, hence looking for examples on how and where I can use typeclass. 
01:36:48 <ariakenom> note: using not defining
01:37:16 <merijn> guest1234566: The answer to "how often do you define your own typeclasses in writing Haskell?" is "almost never"
01:37:42 <merijn> Or, expert level: Quite frequently, but almost exclusively for "mocking" existing ones
01:37:43 <guest1234566> merijn Oh. okay. 
01:38:39 <EvanR> many "obvious" use cases for type classes have better more mundane ways to do it
01:38:59 <ariakenom> merijn: was expert level defining instances or classes?
01:39:35 <EvanR> because of polymorphism, higher order functions, laziness...
01:39:38 <merijn> guest1234566: In this 9k LOC codebase I have 3 typeclases, 2 of which are specialisations of "MonadReader" so I can mix multiple readers, so that leaves 1 typeclass in 9k lines.
01:40:24 <merijn> ariakenom: Defining classes, but usually just stuff like (in my case) "MonadQuery" which is just a class that uses a mix of existing class to provide a small API that I reuse in different contexts
01:54:44 <tdammers> I define typeclasses all the time, but when I do, I'm usually working on the "framework" part of my codebase
01:55:00 <tdammers> i.o.w., I'm making fairly general abstractions
01:55:02 <jle`> guest1234566: typeclasses can be useful, but usually not defining new ones for application code
01:55:09 <jle`> for example one popular typeclass is the Eq typeclass
01:55:14 <jle`> which is definitely useful in a real-world scenario
01:55:24 <jle`> it lets you generalize comparisons for equality to multiple types
01:55:35 <jle`> it's the basis behind functions like `elem`, which allow you to see if an item is in a list
01:55:42 <jle`> > 1 `elem` [1,2,3,4]
01:55:44 <lambdabot>  True
01:55:52 <jle`> > 'a' `elem` "halloween"
01:55:55 <lambdabot>  True
01:56:11 <jle`> a typeclass like Eq is useful because it allows us to define 'elem' once, and then use it for all things that can be compared for equality
01:56:35 <jle`> Ord is another very useful typeclass, it lets us define things like polymorphic sorting
01:56:38 <jle`> > sort "hello"
01:56:40 <lambdabot>  "ehllo"
01:56:42 <guest1234566> My basic understanding of typeclass is, these following rules that is defined in the class can be applied to a vast variety of types as long as they follow those said rules. 
01:56:45 <jle`> > sort [4,7,2,3,6,1,2]
01:56:47 <lambdabot>  [1,2,2,3,4,6,7]
01:57:02 <jle`> this lets us define 'sort' once, and then now  it works for many different types
01:57:05 <jle`> all types that have an instance of Ord
01:57:33 <jle`> guest1234566: for the most part you can replace rules with functions, and you can use it with types that implement those functions
01:57:47 <jle`> for example the Eq typeclass specifies (==) :: a -> a -> Bool, equality comparison
01:57:57 <guest1234566> yes. thats what I understood from the previous discussion. 
01:58:01 <jle`> so any type that wants to be an instance of Eq must define (==) :: MyType -> MyType -> Bool
01:58:07 <EvanR> haskell code is reusable thanks in part to the preponderance of "really dumb" data types like Maybe, Either, and (a,b)
01:58:30 <EvanR> when you start making type classes the reusability story starts to get a bit stretched
01:58:53 <jle`> "making" typeclasses is probably reserved for very specialized situations
01:58:58 <EvanR> unless you're oleg or edwardk 
01:58:58 <jle`> "using" them is an everyday sort of thing
01:59:16 <jle`> or at least, taking advantage of functions that "use" them
01:59:31 <jle`> for example i use the Map abstraction a lot, which is a key-value store kind of data type
01:59:42 <jle`> and the Map abstraction is built upon the Ord typeclass
01:59:55 <jle`> Map being an abstract data type
02:00:05 <jle`> that can store keys of any instance of Ord
02:00:30 <jle`> if it wasn't for the Ord typeclass, we would have to define, from scratch, a Map type for every single possible key type
02:00:47 <jle`> or at least do some messy things to hack around the lack of an Ord typeclass
02:00:57 <EvanR> luckily we only need 3 Map types
02:01:11 <EvanR> (Map IntMap and HashMap)
02:01:34 <jle`> we technically don't 'need' intmap in this situation, it's just an optimization :)
02:01:39 <EvanR> heh
02:02:47 <EvanR> if you ask langX programmer they might say you also don't need Map
02:03:04 <EvanR> hash all the things
02:03:16 <ariakenom> doesnt have to be functions either. like bounded
02:03:39 <ariakenom> % (minBound, minBound) :: (Word8, Int8)
02:03:39 <yahb> ariakenom: (0,-128)
02:04:07 <ariakenom> :t Bounded
02:04:08 <lambdabot> error: Data constructor not in scope: Bounded
02:04:10 <ariakenom> eh
02:04:13 <ariakenom> :t minBound
02:04:14 <lambdabot> Bounded a => a
02:07:21 <mniip> hmm
02:08:18 <mniip> BMxSet(<*, A>, <*, B>) = B^A x M
02:08:30 <mniip> not quite the (BxM)^A I was looking for
02:09:40 <EvanR> obi kan kenobi
02:18:37 <mniip> anakin and his friends CP^30 and R^2xD^2
02:19:30 <mniip> anyway, back to the writer monad, any ideas?
02:39:47 <arianvp> Anybody here have experience with ghcide and vscode?
02:40:13 <arianvp> the plugin keeps saying "Processing 1313/728372" and every time I hover over something the counter resets to 0 and the right-hand side increases
02:40:25 <arianvp> but it never ifnishes processing, and all the suggestions just say "Loading..."
02:44:44 * hackage higgledy 0.3.1.0 - Partial types as a type constructor.  https://hackage.haskell.org/package/higgledy-0.3.1.0 (i_am_tom)
03:46:44 * hackage semialign 1.1 - Align and Zip type-classes from the common Semialign ancestor.  https://hackage.haskell.org/package/semialign-1.1 (phadej)
03:47:04 <lavalike> > transpose . ((. (filterM (const $ get >>= ((<*) . pure) <*> (put . not)))) . (flip evalState) <$> [True,False] <*>) . pure $ [1..10]
03:47:06 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
03:47:44 * hackage semialign-optics 1.1, semialign-indexed 1.1 (phadej): https://qbin.io/mart-buses-5hmv
03:50:24 <MarcelineVQ> you monster
03:55:03 <lavalike> I had this idea but I can't compress it further
03:56:23 <svipal> what in blazes
03:58:00 <MarcelineVQ> lavalike: sit on it for a bit, shapr is doing an obfuscation contest sometime after haloween
04:01:28 <svipal> it reads to me the function itself is against it existing
04:01:39 <svipal> especially that part
04:02:13 <svipal> " <*> (put . not)))) "
04:02:19 <svipal> I read it as "please no"
04:02:33 <tdammers> "please make it stop"
04:02:57 <svipal> :t transpose
04:02:58 <lambdabot> [[a]] -> [[a]]
04:03:25 <MarcelineVQ> transpose is really cool all on its own
04:24:05 <lavalike> haha
04:24:26 <ariakenom> > let in 2 -- didnt expect this to work. gj haskell
04:24:29 <lambdabot>  2
04:40:40 <hquestion> Hi, how would I evaluate whether I should use a language extension or not. For my case I'm wondering if pattern synonyms and view patterns will get me into trouble. Is there any overview or something that tells me "these extensions are battle tested etc."
04:41:21 <merijn> hquestion: Well, define "battle tested" :p
04:41:28 <MarcelineVQ> http://dev.stephendiehl.com/hask/#language-extensions
04:41:38 <merijn> ViewPatterns is fine and pattern synonyms seems perfectly fine too
04:42:52 <hquestion> merijn: Hmm, I suppose that's a bit difficult as well. I could say stable or "this will not be deprecated within the year" or "no known crashes from using this"
04:43:44 <merijn> hquestion: GHC rarely deprecates extensions (in fact, I can't really think of any that ever have been, despite knowing a few that probably should've been...)
04:43:58 <hquestion> MarcelineVQ thanks, that seems liked a good start to me
04:45:24 <hpc> it's probably better to start with what the extension defines and deciding if it's a change to the language you would find valuable
04:46:55 <hquestion> Thanks people, I am happy.
04:47:28 <tdammers> I think the most important question to ask yourself when it comes to extensions is "who is going to be working on this three months from now"
05:32:01 <dminuoso> merijn: Well there's ImpredicativeTypes that's sort of on the brink of deprecation..
05:32:20 <merijn> dminuoso: Not anymore
05:32:26 <dminuoso> Since when?
05:32:33 <Franciman> Hi
05:32:45 <Franciman> what's the maximum number of elements I can store in a Data.Set ?
05:32:50 <Franciman> distinct elements
05:32:52 <merijn> dminuoso: I've campaigned for the removal of that, but the past few months there's been a bunch of mail on ghc-devs about a revived more principled (subset) of ImpredicativeTypes
05:32:56 <dminuoso> I mean Ive recently spotted a publication giving impredicative types in the realm of HM type inference some sort of meaning, are you referring to that?
05:33:03 <merijn> Franciman: How much RAM do you have?
05:33:06 <dminuoso> Franciman: How much memory do you have?
05:33:06 <Franciman> eh
05:33:07 <Franciman> but
05:33:12 <Franciman> I saw that indices are Ints
05:33:18 <tdammers> yes
05:33:19 <Franciman> so I can't have as much memory as I have
05:33:31 <tdammers> no, but your CPU can't address more than that anyway
05:33:45 <dminuoso> Franciman: For what its worth, the haddock mentions this
05:33:49 <Franciman> really?
05:33:51 <dminuoso> Warning "The size of the set must not exceed maxBound::Int. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined."
05:33:54 <dminuoso> https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Set.html
05:33:57 <dminuoso> Right at the top
05:34:01 <Franciman> lol
05:34:02 <Franciman> thanks
05:34:08 <merijn> Franciman: Int on 64bit platforms is 64bit
05:34:37 <Franciman> ah here it is
05:34:38 <Franciman> thanks ppl
05:34:58 <tdammers> plus there's some additional per-element overhead, so you'll exhaust the CPU address space long before you run into the limitations of the data structure itself
05:35:23 <tdammers> not to mention that you never get to allocate all the addressable RAM in the first place
05:35:31 <dminuoso> Realistically its going to be very hard to exceed the possible set size without depleting memory a long long time before.
05:35:38 <merijn> Franciman: You will almost certainly run out of RAM before you have 2^63 elements :p
05:35:50 <Franciman> I'm trying to do some calculations
05:36:10 <dminuoso> Besides, modern processor cannot map to more than 2^48ish bytes of ram currently anyway.
05:36:11 <c_wraith> heck...  x64 only gives you like 48 bits of address anyway.  Not sure *why*, but it does...
05:36:12 <Franciman> I am writing a program to generate a multistage table of unicode character properties
05:36:22 <dminuoso> c_wraith: The reason has to do with unnecessary paging table overhead.
05:36:26 <Franciman> so I store blocks of 256 integers in a set
05:36:53 <Franciman> I was afraid that it could be a huge number of blocks, but practically they are like 1000
05:36:59 <Franciman> not more
05:37:59 <Franciman> ok thank you, anyways
05:38:17 <dminuoso> c_wraith: In simplest term, each hierarchy in the page tables has 512 entries. So if you allowed for full 2^64 memory, each lookup for a small page would have to recurse through 5 dictionaries in order to resolve a virtual address.
05:38:30 <Franciman> the thing that was making me worry is that I could have exceeded the max size without knowing it
05:38:48 <Franciman> but if you say that I finish ram long before I can fill a set to its max size, I'm reassured :P
05:39:17 <dminuoso> c_wraith: (Or possibly 6 even, if you used the remaining 6 bits at the top)
05:40:44 <dminuoso> So you'd waste a lot valuable die space for larger TLB buffers, and increase the latency for TLB misses by 2 additional memory fetches.
05:40:57 <dminuoso> So its simpler to just use 4 tables
05:41:40 <dminuoso> Until those memory become realistic, CPU vendors will stick to 48 bit of addressable memory to get the most ouf ot the CPU until they have to slow down virtual address resolution.
06:09:44 * hackage aeson-extra 0.4.1.3 - Extra goodies for aeson  https://hackage.haskell.org/package/aeson-extra-0.4.1.3 (phadej)
06:20:44 * hackage cabal-plan 0.6.1.0 - Library and utility for processing cabal's plan.json file  https://hackage.haskell.org/package/cabal-plan-0.6.1.0 (phadej)
06:29:20 <merijn> Franciman: Bit late due to meeting, but consider the following, assuming you're only storing single byte elements (unlikely), then filling a Set completely would take up 8388608 terabyte (not counting memory overhead from Set itself)
06:29:44 <Franciman> perfect
06:29:49 <Franciman> thanks merijn 
06:36:14 * hackage constraint-tuples 0.1.1 - Partially applicable constraint tuples  https://hackage.haskell.org/package/constraint-tuples-0.1.1 (ryanglscott)
06:41:26 <kuribas> can you crosscompile ghc for windows on linux?
06:41:39 <__dingbat__> Hello, I am using STMContainers.Map ----   newtype Subscribers t = Subscribers (H.Map t (TVar (Set NodeId)))
06:42:05 <__dingbat__> I am unable to figure out, how to create an instance of Subscribers. Any help please?
06:43:12 <dmwit> `Subscribers <$> newIO`, for example
06:43:23 <merijn> kuribas: In theory, sure. In reality, just...don'
06:43:30 <merijn> kuribas: don't even go there
06:43:39 <merijn> kuribas: Save your sanity and yourself
06:44:13 <merijn> kuribas: Just get yourself a VM with windows, like VirtualBox and build in that
06:44:34 <kuribas> merijn: I have a dual boot, but it's annoying to have to restart
06:44:43 <merijn> kuribas: Hence, the VM :p
06:44:58 <dmwit> Microsoft offers free VMs for testing IE, but the license is relaxed enough that you can use it for testing other stuff, too.
06:45:01 <dmwit> Maybe try one of those!
06:46:05 <__dingbat__> dmwit: that worked great! thankx
07:17:22 <mjrosenb> what is the recommended way to get the State monad?
07:17:32 <mjrosenb> rather, *a* state monad?
07:17:53 <mjrosenb> and is there one that has a foo :: (s -> s) -> State s s
07:18:11 <mjrosenb> mtl has modify :: (s -> s) -> State s ()
07:18:45 <merijn> mjrosenb: I think your question is a bit confused? What do you mean by "get" and "a state monad"?
07:18:58 <c_wraith> what do you mean by "a State monad"?  The only things that can be monads are types, but you seem to be asking about values
07:19:45 <mjrosenb> by get, I mean package, since I didn't find anything at Control.Monad.State with the base library
07:20:07 <c_wraith> ah.  transformers contains the actualy type, mtl is the usual interface to it people use
07:20:14 <c_wraith> *actual
07:20:36 <mjrosenb> there's mtl, which provides Control.Monad.State, but it appears to be missing said function.
07:21:18 <c_wraith> https://hackage.haskell.org/package/mtl-2.2.2/docs/doc-index-M.html  looks like it's there to me
07:21:31 <c_wraith> (why does everyone ignore the haddock indexes?  They're amazing)
07:22:03 <mjrosenb> c_wraith: what is the name of the function?
07:22:06 <c_wraith> modify
07:22:34 <c_wraith> Oh, wait, you want something that modifies and returns...  the old value?  the new value?
07:22:43 <dmwit> mjrosenb: You ask for `foo :: (s -> s) -> State s s`. What behavior do you want from `foo`?
07:22:44 <mjrosenb> either one.
07:22:57 <c_wraith> "either one" is not useful
07:23:04 <dmwit> :t \f -> modify f >> get
07:23:05 <c_wraith> any implementation has to pick one
07:23:05 <lambdabot> MonadState b m => (b -> b) -> m b
07:23:20 <mjrosenb> right, and I don't care which implementation the library provides.
07:23:31 <c_wraith> but the library author does
07:23:53 <mjrosenb> I can write my own, but it feels like a function that a library should provide
07:23:57 <dmwit> :t state (id &&& f)
07:23:57 <c_wraith> why?
07:23:58 <lambdabot> (MonadState s m, Show s, FromExpr s) => m s
07:24:03 <lyxia> that's such a strange statement to make, that you want something but you don't care what it does.
07:24:06 <dmwit> :t state . (id &&&)
07:24:08 <lambdabot> MonadState s m => (s -> s) -> m s
07:24:36 <dmwit> There's two implementations. One returns the old state, one the new.
07:24:56 <dmwit> Also I agree with c_wraith and lyxia that it's v. v. strange to not care which one gets returned.
07:24:58 <mjrosenb> lyxia: by that I mean, for this use, my code will be nearly identical whether it returns the new value or the old.
07:25:13 <dmwit> Possibly: do you just want a freshname supply?
07:25:22 <mjrosenb> dmwit: possibly.
07:25:26 <dmwit> There are monads out there for that that don't stomp on MonadState instances.
07:25:35 <mjrosenb> and by possibly, I mean yes.
07:26:30 <dmwit> http://hackage.haskell.org/package/monad-supply-0.7/docs/Control-Monad-Supply.html
07:27:28 <mjrosenb> neato.  thanks.
07:27:57 <c_wraith> :t (id <%=)
07:27:58 <lambdabot> MonadState s m => (s -> s) -> m s
07:28:12 <c_wraith> of course lens does it. :)
07:28:20 <dmwit> :t state (\(x:xs) -> (x,xs))
07:28:22 <lambdabot> MonadState [a] m => m a
07:28:55 <dmwit> c_wraith: Yeah, but I think he was lying about the type he wanted anyway.
07:29:01 <dmwit> He wanted `state`.
07:29:47 <dmwit> Well. I dunno. Maybe.
07:30:37 <mjrosenb> I could probably use state.
07:32:49 <c_wraith> in retrospect, I shouldn't have needed to look up that operator name. it follows all the lens conventions. 
07:34:02 <mjrosenb> I think lens is a bit overkill for this project :-p
07:35:49 <c_wraith> even that one operator has way more power than it's being used for, there. 
07:39:52 <mjrosenb> yup.  I've been using lens on another project.  thusfar, there is a single thing that i've wanted to do with lens that I've determined wasn't provided.
07:40:14 * hackage perfect-vector-shuffle 0.1.1.1 - Library for performing vector shuffles  https://hackage.haskell.org/package/perfect-vector-shuffle-0.1.1.1 (callanmcgill)
07:40:56 <mjrosenb> and I don't remember what it is anymore, but I think it had to do once again with both mutating a state, and returning some part of it.
07:41:03 <maerwald> don't use lens, use optics :P
07:45:25 <ariakenom> optics is such a bad name. could it be more ambiguous?
07:45:57 <ariakenom> I guess lenses would be worse but thats as far as my imagination takes me
07:49:47 <dmj`> how would one pass ghci flags to ghcid, specifically -ignore-dot-ghci
07:50:14 * hackage ghcflags 1.0.1 - Dump the ghc flags during compilation  https://hackage.haskell.org/package/ghcflags-1.0.1 (tseenshe)
07:51:14 * hackage hsinspect 0.0.7 - Inspect Haskell source files.  https://hackage.haskell.org/package/hsinspect-0.0.7 (tseenshe)
07:51:26 <dmj`> it doesn't like ghcid -ignore-dot-ghci
07:51:34 * hodapp reads "Why Dependent Haskell is the Future of Software Development" and tries to figure out how many grains of salt to take it with
07:54:05 <c_wraith> I hope all of them. 
07:54:49 <tdammers> "optics" is as good as it gets IMO
07:54:53 <tdammers> that's what those things are called
07:55:07 <tdammers> "lens" is actually a worse name, because the library contains all sorts of things that aren't lenses
07:58:01 <ariakenom> tdammers: sure. but optics is a terrible name for a different incompatible package
07:58:22 <ariakenom> because you cant distinguish by saying you use optics
07:59:28 <tdammers> you can say "I use the optics package"
07:59:38 <ariakenom> the optics package should be enough. but what I want from a name is for it to distinguish it from similar things
07:59:52 <ariakenom> yes
08:02:20 <ariakenom> in this case it should distinguish the package "optics" from the package "lens". which I think it entirely fails at
08:06:15 <geekosaur> dmj`, ghcid --command='ghci --ignore-dot-ghci'
08:06:30 <maerwald> why did this turn into a terminology discussion xD
08:06:51 <geekosaur> there's no simpler version because then you can't sanely wrap cabal repl or stack ghci or etc. that does different option handling
08:10:13 <dmj`> geekosaur: I'm using this command, "ghcid -c 'runghc Setup.hs configure --builddir=dist-ghcid-dir && runghc Setup.hs repl app --builddir=dist-ghcid-dir'"
08:10:18 <geekosaur> sorry, -ignore-dot-ghci
08:10:44 <dmj`> I tried -ignore-dot-ghci in the runghc Setup.hs repl command, and it didnt' like it
08:10:59 <geekosaur> then you need to figure out how to pass to runghc Setup.hs repl app
08:11:02 <geekosaur> hm
08:11:57 <dmj`> the plot thickens
08:13:15 <geekosaur> I think --ghci-option=-ignore-dot-ghci
08:13:36 <geekosaur> but may need a -- to prevent runghc from eating the option
08:14:36 <dmj`> runghc --ghci-option=-ignore-dot-ghci Setup.hs repl 
08:14:49 <dmj`> ghc: unrecognised flag: --ghci-option=-ignore-dot-ghci
08:15:35 <dmj`> geekosaur: using -- breaks the command it seems
08:17:03 <Guest_56> Hi, I just installed #haskell using the gcup script, but I can't add haskell environment to $PATH for some reason – .bashrc or .bash_profile doesn't get added to the $PATH variable..... 
08:17:11 <Guest_56> It all runs on mac os mojave
08:17:50 <Guest_56> #haskell #haskell_beginners
08:18:28 <Guest_56> anyone...
08:18:45 <Guest_56> please
08:19:03 <ybit> 👋
08:19:28 <ybit> put this in your path: /Users/YOUR_NAME/.ghcup/bin/ghc
08:19:36 <ybit> er
08:19:42 <ybit> /Users/YOUR_NAME/.ghcup/bin/
08:20:11 <Guest_56> I know. Where is the path
08:20:41 <ybit> either it's in ~/.bash_profile or ~/.bashrc
08:20:48 <Guest_56> no it's not there. 
08:20:58 <ybit> then maybe put it there and source it
08:21:00 <Guest_56> I tried both
08:21:47 <ybit> and maybe ignore my advice on /Users/YOUR_NAME/.ghcup/bin and use ~/.ghcup/bin instead
08:21:50 <Guest_56> I tried adding the path to .ghcup/env both to bashrc and bash_profile; both was performed with a restart
08:22:43 <ybit> do you mean ~/.ghcup/bin instead of ~/.ghcup/env?
08:22:44 <MarcelineVQ> I'm not sure you want the path to env, env is probably a file that contains paths, idk though
08:22:54 <Guest_56> NFs-MacBook-Air:~ frog$ cat ~/.ghcup/envexport PATH="$HOME/.cabal/bin:${GHCUP_INSTALL_BASE_PREFIX:=$HOME}/.ghcup/bin:$PATH"
08:23:44 <Guest_56> env is what the installer told me to source and it has the required patches; the problem is that neither env nor the listed pathds don't display on $PATH
08:24:35 <dmj`> geekosaur: runghc --ghc-arg=-ignore-dot-ghci Setup.hs repl app --builddir=dist-ghcid-dir isn't happy either :(
08:24:55 <Guest_56>  cat .bash_profile "source ~/.ghcup/env" cat .bashrc "source ~/.ghcup/env"NFs-MacBook-Air:~ frog$ 
08:24:56 <geekosaur> not --ghc,arg, that goes to the ghc run by runghc itself
08:25:26 <dmj`> runghc doesn't seem to recognize --ghci-option
08:25:29 <merijn> Guest_56: Where did you get these instructions from?
08:25:31 <Guest_56>  echo $PATH/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/TeX/texbin
08:25:44 <Guest_56> from the installer script on the haskell homepage
08:25:53 <merijn> Which installer and which page?
08:26:05 <Guest_56> https://www.haskell.org/ghcup/
08:26:07 <geekosaur> runghc Setup.hs repl app --builddir=dist-ghcid-dir --ghci-option=-ignore-dot-ghci
08:26:10 <geekosaur> I think
08:26:22 <merijn> ghci-option doesn't exist afaik
08:26:35 <merijn> Are you sure you're not confusing it with --repl-options ?
08:26:39 <geekosaur> maybe
08:26:54 <geekosaur> it's still closer than the other one was
08:27:13 <geekosaur> right, there's --repl-options
08:27:21 <geekosaur> runghc Setup.hs repl app --builddir=dist-ghcid-dir --repl-options=-ignore-dot-ghci
08:27:29 <merijn> --ghci-option to the best of my knowledge doesn't exist, in the past you used to use --ghc-options for GHC as well as GHCI until I broke it :p
08:27:33 <dmj`> runghc's help is very sparse, only mentions "--ghc-arg=<arg>       Pass an option or argument to GHC"
08:27:40 <geekosaur> too many levels of nesting
08:27:51 <geekosaur> this option needs to go not to runghc, but to Setup.hs repl'
08:27:59 <merijn> dmj`: --repl-options would be an argument to Setup.hs, not to runghc
08:28:12 <dm9> Guest_56: Are you maybe using a different shell than bash?
08:28:24 <Guest_56> uhm....
08:28:29 <geekosaur> it's os x, it'll be an older bash probably
08:28:36 <merijn> geekosaur: Until Catalina :p
08:28:37 <Guest_56> it's terminal
08:28:44 <dmj`> merijn: that did it :) thanks
08:28:49 <Guest_56> I didn't know there is more than one bash 
08:28:49 <merijn> geekosaur: Catalina switches to zsh as default shell
08:28:50 <dmj`> geekosaur: thanks as well
08:29:02 <Guest_56> I can update to st. catalina
08:29:11 <Guest_56> is it going to solve the issue?
08:29:16 <merijn> no
08:29:22 <Guest_56> oh okay
08:29:24 <geekosaur> heh. figured they'd find a way to get out from old bash without having to go gpl3
08:29:36 <Guest_56> now when I open terminal it says -bash: source ~/.ghcup/env: No such file or directory
08:29:48 <Guest_56> I have no idea what exactly was the issue but apparently it works now :D
08:30:06 <MarcelineVQ> probably want $HOME/.ghcup/env  ~ isn't always expanded
08:30:08 <geekosaur> something seems wrong wiht that error, did you quote something?
08:30:36 <geekosaur> no, it's running "source ~/.ghcup/env" as the full command name, with the space. if that error message is completely literal, at least
08:30:54 <geekosaur> if they dropped a colon then maybe, but ~ should be expanded there (again unless quoted)
08:31:26 <MarcelineVQ> I see, I'm just adding noise then hehe, Guest_56 ignore me
08:31:55 <Guest_56> i am confused
08:32:35 <Guest_56> well, at least there is some progress – now I see the error msg on terminal opening
08:32:37 <geekosaur> the error message you stated, if it is correct, indicates you have quoted something you weren't supposed to
08:32:51 <Guest_56> quoted means ""?
08:33:10 <geekosaur> yes
08:33:33 <geekosaur> and I just scrolled back and, while you really need to use a pastebin of some kind in the future, it looks like you included the double quotes in both files
08:33:48 <geekosaur> that was only for echoing from the command line, not for putting in the actual file some other way
08:34:24 <Guest_56> cat .bash_profile'source $HOME/.ghcup/env'
08:34:30 <Guest_56> or should I 
08:34:30 <geekosaur> not single quotes either
08:34:33 <Guest_56> oh I see, I don't 
08:34:34 <Guest_56> omg
08:34:36 <geekosaur> remove the quotes
08:34:36 <Guest_56> I'm an idiot
08:35:01 <Guest_56> now everything works; thank you
08:35:30 <Taneb> Guest_56: you're new to this, making mistakes is to be expected. If you're learning, your not an idiot.
08:35:54 <maerwald> Guest_56: The script asks you whether it should do these things for you, did you overlook that part?
08:36:21 <dmj`> long live runghc
08:36:23 <Guest_56> As far as I am concernet the script told me that if I want it to do this for me, I should press return
08:36:27 <Guest_56> I pressed return
08:36:43 <maerwald> Guest_56: no, it says you should type in YES and then press return
08:37:04 <Guest_56> oh, okay. Well, that was my mistake =)  
08:37:05 <Guest_56> I have been struggling with this issue for literally two hours. I appreciate your support; maybe I will be supporting someone in a few years too  
08:37:06 <maerwald> Because I want to avoid people blindly pressing enter and then becoming angry the script changed their files
08:37:43 <maerwald> Maybe it is too specific, I don't know
08:39:18 <c_wraith> maerwald: that's not the first person I've seen say they had trouble there. 
08:39:34 <merijn> c_wraith: You don't know that ;)
08:39:42 <maerwald> I think people are in a rush and don't read most of the text the install script prints
08:40:34 <merijn> maerwald: Make it explicit YES or NO and loop until the person provides an answer? That forces them to read (well, somewhat)
08:40:38 <MarcelineVQ> when a script pauses to say something it's not unreasonable to read it though
08:40:45 <maerwald> typing in "YES" and then pressing enter is fairly straight forward... or so I thought
08:40:53 <pikajude> alas...
08:40:55 <c_wraith> iirc, if you just hit enter, it does nothing. 
08:41:02 <maerwald> exactly
08:41:19 <maerwald> merijn: mh, good point
08:41:22 <merijn> c_wraith: Right, so people just hit enter and default through it and then are confused it doesn't work
08:41:23 <MarcelineVQ> maybe a default yes with opt-in no
08:41:35 <c_wraith> maybe it needs to print another message if you hit enter instead of just sitting there. 
08:41:43 <merijn> MarcelineVQ: No, I agree with maerwald that scripts fucking with my config makes me rage
08:41:45 <pikajude> just print out the same prompt, unchanged
08:41:48 <MarcelineVQ> So the people whining about their config changing, and thus people that should knw better, are the people that didn't read
08:41:52 <pikajude> until the user realizes something is up
08:41:52 <merijn> MarcelineVQ: Not to mention it wouldn't even work
08:41:59 <c_wraith> that's what makes people think it hung. that it does *nothing* when they hit enter 
08:42:11 <pikajude> yeah, that's why you print the prompt again
08:42:22 <pikajude> then they can tell it didn't hang
08:42:29 <dminuoso> The next time someone presents me with a project "Here, can you please do XYZ. It's a simple task, so we didnt bother asking your opinion on this." Im going to to do something morally questionable and shoot him.
08:42:31 <Taneb> "Please type YES or NO" on just enter?
08:43:03 <maerwald> I wonder if people will then ask "how do I exit the install script?"
08:43:09 <MarcelineVQ> dminuoso: mortally questionable and also shoot them?
08:43:12 <merijn> maerwald: Probably
08:43:17 <dminuoso> merijn: Heh.
08:43:21 <dminuoso> MarcelineVQ: Heh.
08:43:58 <maerwald> I just think we need a gui... does zenity usually exist on mac?
08:43:59 <MarcelineVQ> What's the issue with default yes and opt-in no? Where default means it pauses and asks and you hit enter, or type yes or type no.
08:44:15 <merijn> maerwald: What's Zenity?
08:44:29 <maerwald> boring yes/no dialog boxes for shell scripting
08:44:36 <maerwald> is a gnome tool, there's also a kde one
08:44:39 <maerwald> dunno what is on mac
08:44:42 <merijn> maerwald: Then probably not
08:44:49 <merijn> maerwald: Neither gnome nor kde :p
08:47:08 <maerwald> apparently there's something called osascript
08:47:37 <pikajude> for apple? yeah
08:47:43 <pikajude> its a bit wack though
08:47:55 <merijn> Is osascript AppleScript?
08:48:03 <pikajude> osascript is the executable that runs applescript i think
08:48:11 <merijn> Because AppleScript is weird. Genius. But weird
08:48:16 <pikajude> werdius
08:48:33 <c_wraith> applescript nails "read-only language" 
08:48:43 <pikajude> i'd say perl is better for that
08:48:52 <c_wraith> perl is write-only
08:48:56 <geekosaur> no, that's w... that
08:48:59 <pikajude> oh
08:49:11 <pikajude> my messages are also write-only apparently
08:49:11 <c_wraith> applescript is easy to read, but nearly impossible to write. 
08:49:20 <geekosaur> applescript reads like english, but .. again that
08:49:40 <c_wraith> which is the biggest problem with "natural language" programming. 
08:49:51 <geekosaur> yeep
08:50:22 <c_wraith> which of the thousand ways I can express this in English does the computer actually understand? 
08:51:01 <maerwald> compiler will be an AI...
08:51:20 <c_wraith> at the far end, that's basically what it'd take. 
08:51:21 <maerwald> and if you say bad things will become depressed and...
08:51:41 <MarcelineVQ> make posts on twitter about it
08:51:46 <c_wraith> have a severe pain in the diodes down its left side? 
08:51:46 <maerwald> lol
08:52:41 <maerwald> https://github.com/cocoadialog/cocoadialog well there you go, except probably this isn't installed by default anywhere...
08:52:44 <maerwald> which makes it useless
08:52:52 <hodapp> c_wraith: I feel like this idea that $thing will make programming EASY is this promise that re-emerges regularly since someone promised it in, like, 1960
08:53:07 <geekosaur> only too true
08:53:14 * hackage insert-ordered-containers 0.2.3 - Associative containers retaining insertion order for traversals.  https://hackage.haskell.org/package/insert-ordered-containers-0.2.3 (phadej)
08:53:24 <geekosaur> although it's probably back to the jacquard loom or something
08:53:44 <hodapp> and then exactly the same thing happens each time, which is that they find a way to make easy stuff *really* easy and hard stuff nearly impossible
08:56:04 <hodapp> maerwald: there have been attempts at using "AI"(tm) to write considerable parts of the code by applying ML to the general section of code at hand (when a bug is reported) and match it to something that probably does the right thing from a big pile of Internet code, and swap that code in
08:56:21 <hodapp> which I guess is potentially useful if you are using a language full of ridiculous boilerplate but still makes me a bit twitchy
08:56:33 <c_wraith> ack. the security bugs that will introduce... 
08:56:59 <hodapp> c_wraith: it's fine, they'll identify "good" pieces of code by.... uhhh.... machine learning
08:57:29 <hodapp> and train on them
08:58:00 <c_wraith> always good to have an ML system choose its own training set. nothing can go wrong. 
09:16:47 <dm9> In shake, what advantage does `cmd` (and similar) have to using `System.Process`/`System.Process.Typed` directly?
09:26:03 <dminuoso> Sigh. The sprinking of realToFrac and fromIntegral to appease GHC is so weird.
09:26:09 <dminuoso> Is this just the life of a Haskell developer?
09:26:39 <dminuoso> Or is there some hidden pattern? Is it indicative of bad design if I keep sprinking my code with these two functions without knowing why?
09:26:58 <phadej> yes
09:27:09 <dminuoso> Which one? :)
09:27:11 <MarcelineVQ> You know why :D
09:30:16 <maerwald> dm9: the types are weirder? ;)
09:30:16 * hackage varying 0.8.1.0 - FRP through value streams and monadic splines.  https://hackage.haskell.org/package/varying-0.8.1.0 (SchellScivally)
09:32:14 * hackage haskell-ci 0.6 - Cabal package script generator for Travis-CI  https://hackage.haskell.org/package/haskell-ci-0.6 (phadej)
09:38:20 <dm9> maerwald: yeah, using `cmd` and `OverloadedStrings` together requires too many type annotations so I am inclined to forego `cmd` if that doesn't have any drawbacks
09:52:20 <EvanR> dminuoso: it might mean you decided to use an unconventional numeric type or two and now have to convert a lot
09:53:07 <EvanR> it might mean you used floats, but GHC has this issue where it is missing some basic float operations that don't send you bouncing back to an integral
09:53:24 <EvanR> which requires a conversion back to float
09:54:13 <EvanR> it might mean you should have converted sooner than later, now you are converting at the last minute everyhwere
09:55:55 <dminuoso> EvanR: Well I have the case of a wireprotocol I serialize directly into Word8 because they are just octets on the wire. But I use it in variouus library functions that just expect Int...
09:57:49 <EvanR> C is laughing at us
09:58:02 <EvanR> with it's "seamless of convenient" auto promotion
09:58:09 <EvanR> seamless and convenient
09:59:37 <EvanR> you could keep the Word8 entirely hidden behind the marshalling/unmarshalling wall, or make library functions that take Word8 ...
10:01:38 <EvanR> or version that has a ToInt constraint
10:02:14 <dsal> All of my library stuff takes my types and I have a class that converts values to bytestrings
10:03:03 <dsal> (doing low level wire protocol junk)
10:03:51 <dsal> I'm using conduit and just send high level values down a tchan that is responsible for sinking them.
10:04:10 <merijn> So, anyone know of a Haskell implementation of the CART decision tree algorithm?
10:04:50 <dsal> I don't know CART.  Is that like RAFT, but for land?
10:09:33 <ariakenom> dsal: :)
10:11:24 <ariakenom> im missing a vs code command for ghcid "watch ghcid output"
10:30:39 <EvanR> i kind of don't understand atomicWriteIORef and how what it does avoids a space leak https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.IORef.html#atomicWriteIORef
10:31:39 <EvanR> the `b' returned from the atomicModifyIORef is a (). How can ignoring it leak space... because it's a thunk that would become () if evaluated?
10:32:00 <EvanR> why doesn't this kind of thing cause space leaks more often
10:38:14 * hackage curl-runnings 0.11.1 - A framework for declaratively writing curl based API tests  https://hackage.haskell.org/package/curl-runnings-0.11.1 (aviaviavi)
10:40:07 <EvanR> oh... maybe the issue is the atomic update isn't even happening until something needs the result
10:40:17 <EvanR> and they will stack up on the IORef
10:40:54 <dmwit> No, I don't think that's it.
10:41:05 <ski> (.. hm, sure you're not thinking about the strict versions ?)
10:41:08 <dmwit> I think what's happening here is that under normal circumstances you get back a thunk that is roughly `snd (a, ())`.
10:41:17 <dmwit> Forcing it lets you throw away the reference to `a`.
10:42:36 <dmwit> And "this sort of thing" doesn't cause space leaks more often because usually a return type of () is not constructed out of an expensive calculation, but as a raw (). Here it's not.
10:44:23 <dmwit> Although I admit it would be unusual to keep a reference to the () (and hence transitively to the a) around in normal circumstances.
10:44:31 <EvanR> whatever's really going on, this seems like a haskell performance gotcha worth noting for other situations
10:44:32 <dmwit> So it seems rare for this to matter to me.
10:44:36 <dmwit> At least a priori.
10:46:28 <EvanR> "atomicModifyIORef doesn't apply the function strictly"
10:47:31 <EvanR> so like... i could read this as it replaces the value in the ref with let y = f x in fst y and returns (snd y)
10:48:09 <EvanR> if it's what you say shouldn't it say "atomicModifyIORef doesn't evaluate the result for you" or something
10:49:25 <higherorder> Hi! Quick question: is it common in Haskell to use `Either` as a sum type without one branch (e.g. the left one) having a particular attached meaning? e.g. `Either Int Bool`
10:49:58 <EvanR> "what primitives do" keeps coming up... i should figure out how to follow the trail to the implementation of primitives
10:50:59 <MarcelineVQ> EvanR: iirc you end up in stg when it comes to stm primitives
10:51:35 <EvanR> in this case atomicModifyMutVar#
10:52:24 <MarcelineVQ> higherorder: yeah
10:52:56 <dmwit> EvanR: I think your description of what atomicModifyIORef does is accurate.
10:53:07 <MarcelineVQ> Since Either attaches a useful meaning already, I have one of these, or one of those, but not both.
10:53:16 <dmwit> I don't know what nuance your proposed documentation change clarifies, though.
10:54:03 <higherorder> MarcelineVQ: cool, thanks!
10:54:47 <EvanR> the wires got crossed, if the way i said is true, the documentation is right. But i was just told otherwise
10:54:48 <dmwit> higherorder: I'm going to actually give a different answer than MarcelineVQ: in almost every use I've ever seen of Either, the left side is an error description.
10:54:56 <dmwit> higherorder: So my answer is "no, it is not common".
10:55:11 <EvanR> i.e. f x is never even evaluated until you scrutinize the b
10:55:24 <EvanR> and so the var isn't even updated yet
10:55:33 <dmwit> The var is updated with a thunk.
10:55:36 <EvanR> and the var contains nested application thunks
10:55:49 <dmwit> It's only nested if you call it many times without forcing in between. =P
10:55:51 <dmwit> But yes.
10:55:57 <EvanR> that is so lazy!
10:56:06 <EvanR> why would anyone do that
10:56:15 <dmwit> Yes. This led to a runtime leak so egregious once that it actually reduced me to tears.
10:56:34 <dmwit> (Not this exact primitive; for me it was with MVars. But the analogous thing with MVars.)
10:57:10 <crestfallen> > (<$>) (foldr (+) 0) [(Just 4.5), (Just 2), (Just 3.3)]
10:57:12 <lambdabot>  [4.5,2.0,3.3]
10:57:27 <crestfallen> weird that's not what I expected
10:57:33 <dmwit> > map sum [Just 4.5, Just 2, Just 3.3]
10:57:35 <lambdabot>  [4.5,2.0,3.3]
10:58:08 <EvanR> > sum (Just 4.5)
10:58:11 <lambdabot>  4.5
10:58:13 <dmwit> > map (foldr f z) [Nothing, Just x]
10:58:16 <lambdabot>  error:
10:58:16 <lambdabot>      Ambiguous occurrence ‘x’
10:58:16 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.x’,
10:58:21 <dmwit> ?undefine
10:58:21 <lambdabot> Undefined.
10:58:22 <dmwit> > map (foldr f z) [Nothing, Just x]
10:58:24 <lambdabot>  [z,f x z]
10:58:43 <crestfallen> sorry wait not following
10:59:39 <EvanR> > foldr (liftA2 (+)) (Just 0) [Just 4.5, Just 2, Just 3.3]
10:59:40 <lambdabot>  Just 9.8
10:59:41 <MarcelineVQ> Before the flood shall we ask what was expected?
11:00:04 <higherorder> dmwit: thanks for chiming in :) Would it still be "idiomatic" to use Either in cases where the two sides are of "equal meaning"? Or would a Haskell dev reading the code frown ?
11:00:49 <dmwit> I will not frown. Also, if I am writing the code, I will make my own type that labels the two branches more descriptively.
11:02:21 <EvanR> you can nest Eithers to "implement" any sum type you want, but the result is like using String for all your data
11:02:54 <dmwit> For example, https://github.com/dmwit/nurse-sveta/blob/master/src/Dr/Mario/Sveta.hs#L76-L79
11:03:47 <dmwit> (Chosen just because the example is fresh in my mind -- just wrote it yesterday -- which should serve as a piece of evidence about how often this kind of thing comes up. ;-)
11:06:02 <crestfallen> well first off, why does 'map sum' work on functor elements in the list?
11:06:15 <dmwit> It doesn't. It works on foldable elements in the list.
11:06:21 <dmwit> :t sum
11:06:23 <lambdabot> (Foldable t, Num a) => t a -> a
11:06:25 <dmwit> :t map sum
11:06:26 <lambdabot> (Foldable t, Num b) => [t b] -> [b]
11:07:38 <EvanR> map is still specialized to list?
11:08:04 <dmwit> Sure. We already have the perfectly good name fmap for the generalized one.
11:08:12 <dmwit> (Two names for it, in fact!)
11:08:41 <crestfallen> wait but there's no accum so that is still a fold?
11:09:16 <dmwit> I don't understand that question. What is your definition of "fold"? What is your definition of "accum"?
11:09:38 <dignissimus> I only half understand why this doesn't work, I think because I'm using haskeline, instead of being IO objects, things should be InputT IO objects? But I don't understand what should be an InputT IO object or why or how to make it one https://paste.rs/16Y.hs https://paste.rs/JgB
11:09:42 <dmwit> (...and why do you believe "there's no accum"?)
11:09:42 <crestfallen> what is being summed? in your first example with 'map sum'
11:09:55 <EvanR> (i guess i was surprised and relieved that it didn't say (Functor f, Foldable t, Num b) => f (t b) -> f b
11:09:58 <EvanR> )
11:10:05 <dmwit> In `sum (Just 4.5)`, the elements of the Maybe Double, namely, 4.5, are being summed.
11:10:27 <crestfallen> ok
11:10:47 <dignissimus> I know by using `a <- return newStdGen`  I can make `a` an `IO StdGen` object but that's not useful because I want to be able to use an StdGen object
11:11:00 <dmwit> dignissimus: Seems like you just need to insert a `lift` or `liftIO` there, as in `generator <- liftIO newStdGen`.
11:11:23 <dmwit> With such a short transformer stack, the choice between `lift` and `liftIO` is mostly aesthetic. If you plan to refactor later, `liftIO` is the more forward-compatible choice.
11:12:30 <dmwit> dignissimus: ...but since you're doing IO already, can I recommend switching from `randomR` to `randomRIO`?
11:12:44 * hackage cpsa 3.6.4 - Symbolic cryptographic protocol analyzer  https://hackage.haskell.org/package/cpsa-3.6.4 (mliskov)
11:12:54 <dmwit> That will take care of keeping a reference to the seed around, so that future invocations of `aiPlayerLogic` don't keep reseeding.
11:12:58 <dmwit> s/future/multiple/
11:13:11 <crestfallen> > map (foldr f z) [Nothing, Just x]
11:13:13 <lambdabot>  [z,f x z]
11:13:33 <crestfallen> ??
11:13:39 <dminuoso> dignissimus: note that in principle `a <- return newStdGen` is roughly equivalent to `let a = newStdGen` :)
11:13:46 <crestfallen> what's happening there
11:14:09 <EvanR> > foldr f z (Just x)
11:14:11 <lambdabot>  f x z
11:14:27 <dminuoso> dignissimus: (Im saying roughly because there are a few legitimate use cases of using the former style, when `a` is a more complicated pattern like `Just a`)
11:14:40 <EvanR> crestfallen: again with the Foldable behavior of Maybe
11:15:05 <dmwit> crestfallen: It was just a quick way to show you the definition of foldr for Maybe.
11:15:08 <dmwit> Specifically:
11:15:12 <dmwit> foldr f z Nothing = z
11:15:17 <dmwit> foldr f z (Just x) = f x z
11:15:45 <dmwit> (I don't know if the implementation of `foldr` for `Maybe` is literally these lines of code, but they're equivalent to it anyway.)
11:16:23 <EvanR> @src maybe
11:16:23 <lambdabot> maybe n _ Nothing  = n
11:16:23 <lambdabot> maybe _ f (Just x) = f x
11:17:02 <dmwit> Of course to fully explain what happened we'd have to take a detour through some pretty hairy stuff to explain how the Expr type is implemented. But I think it's just a distraction. If you can understand the above equations you've learned everything I wanted you to learn from that lambdabot query.
11:18:41 <crestfallen> tbh I'm confused...working on it
11:18:43 <EvanR> folding over a Maybe (with foldr) seems kind of an oddball thing to do. "folding" it with maybe seems more applicable and theoretically nice
11:19:34 <dmwit> I think having a Foldable instance for Maybe is nice. traverse_ has been handy a few times.
11:19:45 <dignissimus> Ok, I've replaced the randomR call with one to randomRIO imported and used liftIO and the programme works! Thanks all 
11:19:55 <EvanR> yeah the oddball Foldable instances seem to exist so Traversable works
11:19:55 <dmwit> dignissimus: Nice! ^_^
11:20:04 <dmwit> traverse_ doesn't use Traversable
11:20:08 <dignissimus> liftIO will be very useful to know about later on too
11:20:13 <EvanR> :t traverse_
11:20:15 <lambdabot> (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
11:20:30 <EvanR> :t for
11:20:31 <lambdabot> (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
11:20:56 <EvanR> k so traverse_ is like a highbrow way to do `when' heh
11:21:23 <crestfallen> > foldr f z (Just x)
11:21:25 <lambdabot>  f x z
11:21:35 <crestfallen> so you don't call z the accumulator
11:21:49 <EvanR> z is the base value or zero value
11:21:57 <dmwit> I don't. But I would probably understand what you meant if you did.
11:21:59 <EvanR> > foldr f z Nothing
11:22:01 <lambdabot>  z
11:22:22 <EvanR> the initial value of the accum
11:23:37 <crestfallen> > map (foldr f z) [Nothing, Just x]
11:23:38 <lambdabot>  [z,f x z]
11:24:02 <dmwit> higherorder: Oh yeah, and I've written about this on SO, too! https://stackoverflow.com/a/19073039/791604
11:24:10 <crestfallen> so there, z becomes the second param of f
11:24:20 <higherorder> dmwit: oh great, thanks!
11:24:25 <EvanR> crestfallen: so you can accurately understand all this by considering Maybe as a list with at most 1 element
11:24:43 <EvanR> > foldr f z [x]
11:24:45 <lambdabot>  f x z
11:24:50 <EvanR> > foldr f z []
11:24:53 <lambdabot>  z
11:25:17 <EvanR> [x] corresponds to Just x
11:25:46 <crestfallen> ok copy that but...
11:26:24 <crestfallen> why would you have the base value returned as the 2nd param of f as in f x z ?
11:26:34 <EvanR> that's just the order foldr uses
11:26:50 <dmwit> crestfallen: Okay, I accept your challenge. I decide not to use z. What do you propose that I use instead?
11:26:52 <EvanR> first arg is "this element" and second arg is "the running total"
11:27:20 <dmwit> (The second argument is not a "running total". For that to be a sensible description, the second argument would have to change. It doesn't.)
11:27:21 <crestfallen> its very interesting, hold on pls
11:27:54 <EvanR> well, nothing ever changes :) five reasons at least
11:28:05 <EvanR> > foldr f z [x,y]
11:28:06 <dmwit> (This is related to my comment earlier, "I don't [call z the accumulator].".)
11:28:06 <lambdabot>  f x (f y z)
11:28:19 <EvanR> yeah z is not the accumulator
11:28:27 <crestfallen> ok base value
11:28:30 <EvanR> but the second argument is the accumulator
11:29:06 <EvanR> in the lazy case, for foldr, this accumulator has already accumulated, but we can ignore that for now 
11:29:49 <dmwit> EvanR: All (recursive) calls to foldr see the same value in `z`. Compare `foldl'`, which actually see different values in this argument in the straightforward implementation.
11:30:22 <EvanR> all recursive calls don't see the same value, they are not all z
11:30:28 <dmwit> ?src foldr
11:30:28 <lambdabot> foldr f z []     = z
11:30:28 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:30:38 <dmwit> See? It is passed to the recursive foldr call unchanged.
11:30:42 <dmwit> ?src foldl'
11:30:42 <lambdabot> foldl' f a []     = a
11:30:42 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
11:30:46 <EvanR> the second argument is not z, its foldr f z xs
11:30:46 <dmwit> ^ Here, not
11:30:53 <EvanR> to f
11:30:56 <EvanR> not to foldr
11:31:05 <dmwit> EvanR: All (recursive) calls to *foldr* see the same value in `z`.
11:31:08 <EvanR> i think that might be the confusion
11:31:08 <dmwit> Is what I said.
11:31:27 <crestfallen> yikes
11:31:45 <dmwit> Which is *different* to the way other recursive functions behave, and specifically different to the style of recursive function where I'm comfortable calling one argument an accumulator.
11:31:50 <EvanR> i was thinking in terms of "being in the function" not foldr itself
11:31:54 <slack1256> Is there an standard resource for learning about free theorems and how to derive them on haskell?
11:32:30 <crestfallen> in this simple example, (+) is not returned along with the base value:
11:32:38 <crestfallen> > foldr (+) 5 [1,2,3,4]
11:32:40 <lambdabot>  15
11:32:52 <EvanR> > foldr f 5 [1,2,3,4]
11:32:54 <lambdabot>  error:
11:32:54 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M590353136163...
11:32:54 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
11:33:03 <dmwit> slack1256: Wadler's paper "Theorems for Free!" is quite approachable.
11:33:20 <slack1256> Got it!
11:33:25 <EvanR> f 1 (f 2 (f 3 (f 4 5)))
11:33:53 <EvanR> so second arg is an accumulator
11:33:57 <mike64> @djinn (((a->b)->b)->b) -> (a -> b)
11:33:57 <lambdabot> f a b = a (\ c -> c b)
11:34:17 <EvanR> (second arg to foldr def not)
11:36:11 <crestfallen> def == definitely EvanR ?
11:36:16 <EvanR> yes
11:36:43 <EvanR> z is the base
11:36:47 <EvanR> base case
11:40:59 <mike8> @djinn (((a->b)->b)->b) -> (a->b)
11:40:59 <lambdabot> f a b = a (\ c -> c b)
11:43:23 <literallyCrevice> I'm looking for a custom prelude that exports generalized list functions (for example BasicPrelude's intercalate which works on monoids) and good text conversion functions (text -> ltext -> bytestring -> lbytestring). What should I look into?
11:43:41 <literallyCrevice> If it doesn't have any partial functions that's a plus, but not certainly required.
11:44:07 <crestfallen> thanks EvanR dmwit .. if I could go back real quick..
11:44:54 <crestfallen> so " understand all this by considering Maybe as a list with at most 1 element "
11:45:03 <crestfallen> ...
11:45:51 <EvanR> pretty much
11:46:21 <crestfallen> > (<$>) (foldr (+) 0) [(Just 4.5), (Just 2), (Just 3.3)]
11:46:22 <lambdabot>  [4.5,2.0,3.3]
11:46:54 <EvanR> > (<$>) (foldr (+) 0) [[4.5], [2], [3.3]]
11:46:57 <lambdabot>  [4.5,2.0,3.3]
11:47:01 <MarcelineVQ> for lists <$> is map, if that's at all clarifying
11:48:08 <crestfallen> so (<$>) maps over the Maybe elements, but the (foldr (+) 0)  doesn't return an error, but it's not at all being utilized, right?
11:48:27 <jle`> > foldr (+) 0 (Just 10)
11:48:29 <lambdabot>  10
11:48:36 <jle`> crestfallen: foldr (+) 0 is total, it cannot return an error
11:48:42 <jle`> maybe you are thinking about whether or not it typechecks?
11:48:46 <jle`> > foldr (+) 0 Nothing
11:48:48 <lambdabot>  0
11:49:05 <jle`> crestfallen: (<$>) in your example maps over the list
11:49:18 <jle`> > map (foldr (+) 0) [Just 4.5, Just 2, Just 3.3, Nothing]
11:49:20 <lambdabot>  [4.5,2.0,3.3,0.0]
11:49:50 <EvanR> crestfallen: did you see how my example was just yours with Just 4.5 replaced with [4.5]. This is all you're doing. Sum of 1 thing
11:50:30 <jle`> oh it looks like i stumbled into a long conversation
11:51:02 <jle`> > sum Nothing
11:51:04 <lambdabot>  0
11:51:05 <jle`> > sum (Just 3)
11:51:07 <lambdabot>  3
11:51:15 <xsperry> > catMaybes [Just 1, Nothing, Just 2]
11:51:17 <lambdabot>  [1,2]
11:51:18 <jle`> > map sum [Nothing, Just 3]
11:51:21 <lambdabot>  [0,3]
11:51:24 <crestfallen> yeah ok thanks ALL it is being utilized but it returns the sum of each Maybe element which is just itself
11:51:36 <jle`> crestfallen: yeah, or 0 if it is Nothing
11:51:47 <jle`> sum is polymorphic for all Foldable containers
11:51:51 <jle`> :t sum
11:51:52 <lambdabot> (Foldable t, Num a) => t a -> a
11:52:10 <jle`> that's why saying things like 'the Maybe functor' is misleading unless you are actually talking about the functor properties itself
11:52:14 <EvanR> we returned to the beginning of the convo. Maybe this is a good time to end it :)
11:52:31 <jle`> when you do `map sum [Just x, Just y, Nothing]`, it isn't "summing over the functor values"
11:52:39 <jle`> it's summing every "foldable" value
11:52:50 <xsperry> I don't hear "Maybe functor" nearly as often as "Maybe monad"
11:53:00 <jle`> just because you see Maybe/Nothing/Just, doesn't mean that Functor is important
11:53:08 <EvanR> i want to hear about functors more often
11:53:26 <crestfallen> right. simple enough.
11:53:38 <jle`> 'map sum' will map sum over the *foldable* elements in the list. and here we have the Maybe Foldable
11:53:53 <crestfallen> you will be EvanR :)   I'm giving myself a month to fully understand them before I move on to applicative
11:53:56 <jle`> note that sum works even for types that aren't Functor
11:54:08 <jle`> > sum (S.fromList [1,2,3])
11:54:10 <lambdabot>  6
11:54:18 <jle`> (Set is not a Functor)
11:54:38 <jle`> so 'functor' isn't the important concept being used here, but rather Foldable
11:56:10 <crestfallen> copy that, thanks everyone that is deep
11:56:36 <EvanR> i want to hear about haskell's functorial IO system
11:56:59 <EvanR> haskell IO runs on functors
11:57:14 <EvanR> hehe
11:58:47 <crestfallen> > map (foldr f z) [Nothing, Just x]
11:58:49 <lambdabot>  [z,f x z]
11:58:55 <dminuoso> crestfallen: I think Applicative has a misleading signature method which somewhat contributes to its confusion.
11:59:11 <crestfallen> especially that interests me ^ because..
11:59:42 <crestfallen> I thought to operate on Maybe at all, we would need <$>
12:00:02 <merijn> crestfallen: Why?
12:00:08 <jle`> yeah, that's definitely a consequence of thinking about 'maybe monad', and definitely wrong :)
12:00:15 <jle`> crestfallen: you can always just pattern match
12:00:25 <merijn> crestfallen: "case Just 3 of Nothing -> "foo"; Just x -> show x"
12:00:34 <jle`> > map (\case Just x -> f x z; Nothing -> z) [Nothing, Just x]
12:00:36 <lambdabot>  [z,f x z]
12:00:49 <jle`> (<$>) is a useful function that we build on *top* of pattern matching
12:00:52 <dminuoso> crestfallen: The Functor interface is merely the observation that "mapping over something with a function, changing its type along side" is something we do frequently.
12:01:01 <dminuoso> crestfallen: So <$> just captures that pattern. :)
12:01:03 <jle`> it isn't a primitive action, but rather a useful handy shortcut
12:01:06 <jle`> over pattern matching
12:01:10 <xsperry> crestfallen, do you need <$> to operate on a list?
12:01:26 <jle`> do you need (==) to operate on Int?
12:02:20 <jle`> ah sorry if that came off as dogpiling :)
12:02:45 <crestfallen> geez I cannot process all that
12:02:46 <jle`> actually it's funny, for a while in java, they actually forbade people from defining <$> for Maybe
12:02:48 <dminuoso> crestfallen: I like to think of Applicative of actually having the shape `class Functor f => Monoidal f where (<+>) :: f a -> f b -> f (a, b); unit :: f ()` which hints that what this is actually about, is combining "effects two effects and just grabbing both results alongside"
12:02:57 <EvanR> crestfallen needs some to process
12:03:03 <EvanR> some time
12:03:17 <jle`> Java introduced option, and people were like "hey let's write a function to map over the contents, instead of manually 'pattern matching' and handling the cases"
12:03:25 <jle`> and the java people were like "no you can't do that"
12:03:42 <jle`> "wait that's illegal"
12:04:02 <jle`> so that would be like someone proposing to add <$> for Maybe to the standards library and people rejecting it
12:04:04 <EvanR> how do java people go about stopping you from writing a function
12:04:17 <jle`> i exaggerated some bits for my story :)
12:04:23 <jle`> but it was proposed to add to the standard interface for Option
12:04:25 <EvanR> ah
12:04:35 <EvanR> and it was illegal?
12:04:37 <jle`> so the moral of the story is that we are very lucky to even have <$> at all
12:04:42 <jle`> for Maybe
12:04:48 <jle`> a lot of people have to make do without it
12:04:50 <merijn> EvanR: You need to step up your meme game
12:05:04 <crestfallen>  > map (\case Just x -> f x z; Nothing -> z) [Nothing, Just x
12:05:10 <crestfallen> I'm still working on this
12:05:12 <EvanR> oh god... are there memes around
12:05:17 <merijn> EvanR: https://knowyourmeme.com/memes/wait-thats-illegal
12:05:21 <crestfallen> > map (\case Just x -> f x z; Nothing -> z) [Nothing, Just x
12:05:23 <lambdabot>  <hint>:1:59: error:
12:05:23 <merijn> EvanR: Memes are everywhere, man
12:05:23 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
12:05:28 <dminuoso> jle`: I think the point is not even to have <$> for Maybe, but rather a polymorphic interface such that Maybe is an acceptable choice for Functor.
12:05:38 <crestfallen> > map (\case Just x -> f x z; Nothing -> z) [Nothing, Just x]
12:05:40 <lambdabot>  [z,f x z]
12:05:43 <dminuoso> Because merely mapping over it with fmap is relatively boring, at the end.
12:05:46 <merijn> EvanR: Just look: http://lambdacats.org
12:05:49 <jle`> dminuoso: the debate was actually against having a mapping function at all for Maybe
12:05:51 <merijn> aww
12:05:54 <dminuoso> jle`: really. :S
12:05:59 <merijn> EvanR: Looks like someone took it down :(
12:06:11 <jle`> yeah, the argument was "we don't want people to start saying that Maybe is a functor. and then too much jargon."
12:06:22 <jle`> "prevent elitist FP jargon from entering java"
12:06:40 <EvanR> i have been told that using a functional pattern like that was stupid because of the overhead
12:06:58 <EvanR> use an if then else instead like everyone else, and it's faster
12:07:14 <dminuoso> jle`: Amusingly it wouldn't even be elitists entering Java. Those masochist people actually embracing the idea of having small functional tools on the JVM are already off to Scala, so they shouldn't be worried!
12:08:00 <dignissimus> I have a list of moves and also have function that can map these moves to values, I want to get the move with the largest value, my first idea was `head . sortBy valueFunction`, is that ok?
12:08:01 <jle`> there was actually a solid technical reason that i am omitting for the sake of a cheeky story
12:08:17 <crestfallen> One day I will use elistist FP jargon :)
12:08:29 <EvanR> jle`: oh good, for a minute i thought i was learning something true about java :)
12:08:30 <jle`> dignissimus: just be careful of getting an empty list
12:08:51 <jle`> i mean, from an elitist FP jargon standpoint, there is a reason to not have an fmap for java Option
12:08:58 <jle`> it's because Java Option cannot hold null
12:08:59 <dminuoso> jle`: Something to do with "higher kinded" polymorphic functions being impossible?
12:09:16 <jle`> so fmap (f . g) = fmap f . fmap g won't hold if g returns null
12:09:39 <EvanR> you can say you're writing "morally correct" java
12:09:40 <dminuoso> See, non-lawful Functor, all elitist FP would stay far away from Java. 
12:09:44 <dminuoso> Job done.
12:10:20 <crestfallen> jle`, so the pattern matching, it's like it's forced since it doesn't use <$> .. because it doesn't need to. but I guess it doesn't need to ever.
12:11:15 <jle`> crestfallen: yeah, you don't ever *need* Functor/Applicative/Monad/Foldable/Traversable/Monoid/Semigroup/Eq/Ord/etc. ever for Maybe, because you can always just pattern match
12:12:01 <jle`> (with exceptions for the cases where you feed a Maybe to a function that is polymorphic on all instances of a typeclass, like using 'sort' on a list of maybes)
12:14:00 <jle`> it just makes it convenient to be able to write `x == y`, instead of case x of Nothing -> case y of {Nothing -> True; Just _ -> False}; Just x' -> case y of {Nothing -> False; Just y' -> x == y}
12:14:19 <jle`> * x' == y' at the end
12:16:10 <xsperry> > Just 10 == Just 10   -- :)
12:16:12 <lambdabot>  True
12:16:53 <crestfallen> ok thanks again. I'm going to clean my venetian blinds now :)
12:22:23 <dmwit> jle`: Your code also works with `x == y` at the end. =P
12:23:37 <fraktor> So I need to read some configuration files that will have nested config sections.  Is there a way to define a single that would include that?
12:24:00 <dmwit> I think you accidentally a word.
12:24:26 <dmwit> But you might like the config-value package.
12:24:40 <fraktor> A single type.  That's what I accidentally'd
12:25:08 <dmwit> data Config = Atom Int | Nested [Config] -- e.g.
12:25:21 <fraktor> Oh yeah, I forgot about algebraic data types.
12:26:02 <fraktor> But since it would be kind of an arbitrary nested value, how bad is it to make a function that looks something up based on a string like "toplevel.subsection.value"?
12:27:52 <merijn> Sounds like "how bad is it to reinvent lens from first principles" ;)
12:28:03 <merijn> To which the answer varies based on who you ask ;)
12:30:16 <fraktor> I don't understand lenses, so maybe they're just what I need
12:40:04 <dsal> fraktor: that's the spirit
12:40:16 <merijn> I don't understand lenses either :p
12:42:26 <dmwit> fraktor: I don't really understand the question. But, like, perhaps `data Config = Atom Int | Nested (Map SectionName Config)` gets at what you're asking?
12:42:53 <dmwit> (And if so, you might consider using an OMap, so that your pretty-printer can get the right ordering even after you make some changes. ;-)
12:42:56 <dmwit> ?hackage ordered-containers
12:42:57 <lambdabot> http://hackage.haskell.org/package/ordered-containers
12:43:38 <dsal> Map isn't ordered?
12:43:45 <dsal> ooh, insertion order
12:43:58 <merijn> It is
12:56:48 <EvanR> OMap is a Functor .. ?
12:58:56 <EvanR> oh duh, it's OSet which is not Functor
13:04:40 <dmwit> It is a fun exercise to think about how to support both insertion and deletion (with sensible asymptotics). I highly recommend it. Peeking at my answer before you have your own is highly discouraged.
13:28:41 <dignissimus> I found out maximumBy exists, but is there a function that takes a list and an ordering/value function and returns a list of the highest ranked items ([1, 7, 5, 7, 3, 7, 1, 5] --> [7, 7, 7]). If there isn't one, I could use (groupBy . sortBy) and get the first item of that
13:29:47 <dignissimus> Comparing/valuing the items is resource intensive so I might first map the items to a tuple containing its value and itself
13:33:14 <xsperry> > let xs = [1,2,3,3] in filter (== (maximum xs)) xs
13:33:16 <lambdabot>  [3,3]
13:33:32 <xsperry> instinctively, I think this would be more efficient. not sure though
13:34:19 <godisded> I'm looking for some function f :: [(a, [b])] -> [(a, b)].
13:34:35 <pikajude> == maximum is O(n^2) isnt it
13:34:44 <EvanR> xsperry your version has to traverse the entire list before producing the first item of the filter
13:35:06 <xsperry> pikajude, it should be O(n)
13:35:14 <pikajude> sorry, i mean
13:35:19 <pikajude> filter (== (maximum xs)) should be O(n^2)
13:35:26 <pikajude> unless maximum xs is shared?
13:35:38 <xsperry> EvanR, you have to traverse the whole list to find the largest element
13:35:50 <EvanR> yes
13:35:53 <pikajude> the point being you should be able to condense the two steps into one
13:36:20 <EvanR> but there may be a way that doesn't involve materializing the entire list up front
13:36:26 <pikajude> no there isn't
13:36:41 <xsperry> you can't know what is the largest element until you inspect the last element
13:36:44 <EvanR> proof?
13:36:49 <EvanR> i agree with that
13:37:03 <EvanR> but i'm not convinced of the connection from A to B
13:37:24 <pikajude> i'm gonna see if i can write this
13:37:28 <pikajude> it should be a fairly simple fold
13:37:50 <godisded> * I'm looking for some function f :: [(a, [b])] -> [(a, b)], such that e.g. f [('a', [1, 2]), ('b', [3])] == [('a', 1), ('a', 2), ('b', 3)].
13:37:54 <xsperry> EvanR, how can you start returning largest elements, until you know what the largest element is (and you can't know, until you go through the entire list)
13:38:01 <EvanR> you can't
13:38:23 <EvanR> but you might be able to do a better job during the walk of dealing with what you know so far
13:38:42 <EvanR> maximum first, then filter means having the entire list in memory at some point
13:38:46 <monochrom> You know you can be more precise by saying "less memory".
13:39:15 <monochrom> or even "forget past elements you know won't make it"
13:39:28 <EvanR> i can? ok, less memory
13:39:50 * EvanR waits for magic
13:40:52 <xsperry> that's trivial then, just rewrite maximum function and keep maxElements instead of maxElement
13:41:06 <monochrom> Yeah.
13:42:11 <EvanR> i thought there was a way but... surprised to hear it's trivial :)
13:42:26 <monochrom> In retrospect.
13:42:47 <EvanR> the best kind of trivial
13:43:04 <monochrom> Plus, things tend to be more obvious after someone writes more precisely.
13:43:12 <xsperry> I thought your objection was that filter won't return until the end of the list.. but neither with proposed maximums function
13:43:22 <xsperry> s/with/will
13:43:42 <EvanR> "don't materialize the entire list" ...
13:43:45 <lavalike> > fmap (uncurry (flip replicate) . fst) . M.maxViewWithKey . F.foldr (flip (M.insertWith (+)) 1) M.empty $ [1,7,5,7,3,7,1,5]
13:43:46 <lambdabot>  Just [7,7,7]
13:44:02 <pikajude> https://gist.github.com/pikajude/71ed0b6d39e9966d99cb2cce4959033c
13:44:17 <EvanR> whatever i'll tell you where you can precisely go
13:45:11 <pikajude> i think the one with map is nlogn
13:45:14 <pikajude> this should be linear
13:45:42 <dignissimus> godisded: I don't know if a function already exists but you can use map, repeat and zip
13:45:50 <dignissimus> to implement that I mean
13:46:14 * hackage flatbuffers 0.2.0.0 - Haskell implementation of the FlatBuffers protocol.  https://hackage.haskell.org/package/flatbuffers-0.2.0.0 (dcastro)
13:46:41 <pikajude> mine does have the drawback of not actually returning anything until the full list is processed though
13:46:58 <pikajude> although i don't know if you can write it in a way that works on an infinite list?
13:47:07 <EvanR> avoiding having an entire list in memory at the same time is important for speed because gc, at least when the list is long
13:47:37 <EvanR> when it's infinite, at least some of the time you can avoid using infinite memory :)
13:47:41 <monochrom> An adversary-based argument shows that you need to examine the entire list.
13:47:45 <jle`> godisded: looks like sequence
13:48:19 <monochrom> An example like [7,7,7,7,7,7,7,7,7] shows that you may end up returning the whole list.
13:48:19 <jle`> > sequence ('a', [1,2])
13:48:21 <lambdabot>  [('a',1),('a',2)]
13:48:33 <jle`> godisded: so you can concatMap sequence
13:48:41 <xsperry> it could work on an infinite list if one element was maxBound 
13:48:47 <EvanR> i never said you don't need to examine the entire list
13:48:54 <jle`> > concatMap sequence [('a',[1,2]),('b',[3])]
13:48:55 <lambdabot>  [('a',1),('a',2),('b',3)]
13:49:11 <pikajude> yeah you could maybe short circuit that
13:49:33 <pikajude> but otherwise, you can't stream a list of the maximum elements from an infinite list, because if you encounter a larger maximum later in the stream, you retroactively have to un-return all the old results
13:49:37 <xsperry> Bounded constraint wasn't part of original specification though
13:50:17 <dmwit> > traverse (traverse id) [('a',[1,2]),('b',[3])]
13:50:19 <lambdabot>  [[('a',1),('b',3)],[('a',2),('b',3)]]
13:50:21 <godisded> jle`: Wow, thanks!
13:50:33 <dmwit> oh, right
13:50:47 <jle`> godisded: np :)
13:50:58 <monochrom> But you can maximize streaming in what you return.
13:51:01 <jle`> anytime it looks like you want "flip" functor composition, sequence is a good first thing to check
13:51:08 <dmwit> godisded: You might also consider `foo xs = [(a,b) | (a,bs) <- xs; b <- bs]`.
13:51:10 <pikajude> you can't return anything until you either encounter maxbound or the end of the list
13:51:26 <jle`> s/;/,
13:51:28 <dmwit> To me, that one looks instantly readable in a way that concatMap sequence doesn't.
13:51:34 <pikajude> that's a weird emoji jle
13:51:37 <dmwit> Oops, yes, thank you jle` 
13:51:42 <jle`> yeah, i do agree the list comp version is more readable
13:51:44 <monochrom> But the maximized streaming is still very insignificant.
13:51:54 <jle`> pikajude: it's elvis, can't you see
13:54:06 <lavalike> > foldl (\maxs x -> if null maxs || any (<x) maxs then [x] else if x == head maxs then x:maxs else maxs) [] [1,7,5,7,3,7,1,5]
13:54:08 <lambdabot>  [7,7,7]
13:54:15 <ovitus> ```myMaximumBy' :: (a -> a -> Ordering) -> [a] -> amyMaximumBy' f (x:y:[]) = if f x y == LT then x else y myMaximumBy' f (x:y:xs)      | f x y == LT = myMaximumBy f (x:xs)      | otherwise = myMaximumBy f (y:xs)```
13:54:46 <ovitus> @help
13:54:46 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:54:55 <ovitus> @help list
13:54:56 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
13:55:53 <dignissimus> My own implementaion looks like the one lavalike just sent here, is that as efficient as the earlier one? Because I only understand the last one
14:01:56 <dignissimus> It looks like this: https://paste.rs/ngC.hs
14:08:52 <devalot> Is it possible to write this function? (a -> m b) -> m (a -> b)
14:09:36 <merijn> No
14:09:46 <devalot> I guess I should say: (Monad m) => (a -> m b) -> m (a -> b)
14:09:53 <merijn> Still no :)
14:09:57 <devalot> merijn: ;)
14:10:08 <devalot> I figured as much, but thought I'd ask
14:10:08 <merijn> devalot: Consider this: Which effects are run can depend on the value of 'a'
14:10:23 <merijn> So you can't run them before having 'a'
14:18:08 <jle`> yeah, consider for something like putStrLn
14:18:18 <jle`> putStrLn would basically be printing before you get the string
14:18:35 <NemesisD> i've got a record like `data R f = R (f A) (f B)` which derives generic. i've got a function that can do `f a -> Either AnError (g (TypeFamilyMappingTo b))`, how can i write `R f -> Either AnError (R g)`? it sort of looks like `gmapM :: forall m. Monad m => (forall d. Data d => d -> m d) -> a -> m a`, but that first argument is a doozy
14:19:10 <NemesisD> do i have to create bespoke generic typeclasses for every such example where i want to generically modify a record?
14:21:53 <dmwit> devalot: Yes, if `a` is finite, and it works by applying the function to all possible inputs and making a lookup table.
14:22:10 <dmwit> devalot: There is an implementation here: http://hackage.haskell.org/package/universe-reverse-instances-1.1/docs/Data-Universe-Instances-Traversable.html
14:22:53 <devalot> dmwit: Right, but in this case I don't have any constraints I can apply to `a' :(
14:23:01 <dmwit> sequenceA :: (Ord e, Finite e, Applicative f) => (a -> f b) -> f (a -> b)
14:23:05 <dmwit> uh
14:23:10 <dmwit> (Ord a, Finite a, ...) I mean
14:23:41 <dmwit> devalot: Perhaps you can add them! Or perhaps you can figure out a different way to solve whatever super-problem led to this subproblem.
14:24:40 <geekosaur> x, meet y
14:26:29 <devalot> dmwit: I think I need to restructure this code so my brain doesn't explode.
14:34:02 <dminuoso> I have a pure parser in which I parse some preamble - and I need some small bit of information much later in the parser. Is it sane to drag that around via unsafePerformIO+IORef, or should I just bite the bullet and add a ReaderT? Im a bit worried that this might hinder optimizations for passing an argument that is needed in only a small portion.
14:37:00 <dmj`> dminuoso: why not just pass it as an argument to the parsing function, why does it need to be in an IORef or a Reader
14:41:26 <dminuoso> dmj`: Because its not just a single parsing function, but a monadic Get parser, so I'd have to drag that information around until it lands in the parsing bit that needs it.
14:46:01 <jle`> that sounds like the same thing that would happen if you use ReaderT
14:47:17 <dminuoso> Right, hence the idea of sneaking the information using an IORef ;)
14:50:05 <merijn> How would that help?
14:50:13 <merijn> You'd still have to pass the IORef somehow
14:50:13 <EvanR> a global IORef ?
14:50:18 <dminuoso> Yeah
14:50:23 <EvanR> classy
14:50:27 * dminuoso chuckles
14:50:41 <merijn> dminuoso: Then you can never use said parser concurrently...
14:51:04 <dmj`> dminuoso: just turn it into one function with a bunch of where blocks, the where blocks will all be able to access the first parameter of the top-level function
14:51:06 <EvanR> for information that never changes and is derived from IO later, you can use IVar instead of IORef
14:51:15 <EvanR> reading an IVar can be done in pure code
14:51:50 <EvanR> a global IVar can begin uninitialized then written to by some thread while pure code is waiting on it
14:51:58 <EvanR> after which is reads immediately
14:52:02 <EvanR> it
14:52:52 <EvanR> that would solve the concurrency issue, not sure what else
14:53:17 <merijn> EvanR: no it wouldn't
14:53:28 <merijn> unless you assume every parser always reads the same thing
14:53:35 <merijn> In which case, just hard code that
14:53:37 <EvanR> right i was assuming that
14:53:44 <EvanR> sometimes you can't hard code it though
14:53:52 <merijn> How so?
14:54:19 <merijn> EvanR: I can't think of a single thing where you can't hardcode AND it work across concurrent parser invocations
14:54:33 <merijn> Either it's input independent, or it isn't
14:54:53 <EvanR> it requires a bit of expanding on the idea of what is part of the program
14:54:55 <jle`> hm, does your parser have a ParserT kind of variant?
14:54:58 <jle`> if so then you can use State under it
14:55:03 <jle`> or Reader with local
14:55:56 <EvanR> merijn: "the" database schema is a thing that doesn't change... until it does
14:56:46 <EvanR> all this being said, you can always pass whatever the IVar holds in as an argument
15:41:31 <pikajude> isn't reader evil?
15:42:43 <mniip> evil how
15:43:55 <paulasdf> is there a way to avoid building executable components of an external dependency? that is, bulid the library only?
15:44:28 <pikajude> only if they expose a cabal flag for that, i believe
15:49:56 <EvanR> i've heard theories that "Reader with local" is evil somehow
15:55:06 <NemesisD> is there another way to apply a function to all fields of a record without having to write a custom typeclass so you can write instances for K1, :*:, :+: and so on
15:56:28 <pikajude> onRecord (Record a b c) = Record (f a) (f b) (f c) ?
15:57:21 <pikajude> oh, sorry, this is generic
15:57:23 <pikajude> i didn't see
16:09:11 <lyxia> NemesisD: there are libraries that already have those instances so you don't have to write them, notably one-liner and product-profunctors.
16:17:14 * hackage nonempty-containers 0.3.2.0 - Non-empty variants of containers data types, with full API  https://hackage.haskell.org/package/nonempty-containers-0.3.2.0 (jle)
16:42:42 <fraktor> Is there a preferred way of doing logging throughout a Haskell program?
16:44:38 <pikajude> i think people use monad-logger
16:44:50 <pikajude> or i guess for an actual logging backend, fast-logger
16:45:03 <hpc> if you feel like being particularly linuxy, hsyslog perhaps?
16:45:11 <EvanR> you can just have a logging IO action in your ReaderT over IO
16:45:15 <dibblego> NemesisD: see Control.Lens.Traversal
16:45:37 <fraktor> EvanR: I don't really know what that means...
16:45:47 <hpc> (at least for actually doing the IO)
16:45:54 <EvanR> type Logger = String -> IO ()
16:46:12 <EvanR> the only question is how to get the Logger to where it is used, hence ReaderT
16:46:25 <fraktor> Yes, but I mean, how can you put multiple things in a readerT? I though it was just "ask"
16:46:36 <EvanR> you may have a big record for your environment
16:46:40 <EvanR> with many things for the app in it
16:48:01 <EvanR> asks myLogger "message"
16:48:10 <EvanR> hmm
16:48:15 <EvanR> some sort of wrapper like that
16:50:38 <EvanR> log msg = asks myLogger >>= ($ msg)
17:15:21 <jle`> ☻
17:15:37 <jle`> whoops wrong window
17:20:00 <fraktor> I'm using the yaml package (which uses a lot of aeson's stuff under the hood) and I want to load text from a file and get back a Value, not necessarily a specific Haskell type.  Does anyone know how to do that with Aeson or yaml?
17:22:37 <EvanR> fraktor: at least with Aeson, Value is an instance of FromJSON so it's a valid target for decoding
17:22:59 <fraktor> Oh yeah.  Duh.  Thanks!
18:19:26 <monochrom> If you wrap Reader inside Reader, you have to ask to ask. >:)
18:23:29 <dmwit> ^_^_^
18:40:12 <rotaerk> lol
19:10:14 * hackage net-mqtt 0.6.0.2 - An MQTT Protocol Implementation.  https://hackage.haskell.org/package/net-mqtt-0.6.0.2 (dustin)
19:14:24 <wejetheman> working on this code for an assignment, this works fine http://codepad.org/vseOrTtC and this should be equivalent http://codepad.org/DXzSPvkh but it returns an error, im so confused
19:15:54 * dsal DoSes Amazon waiting for my package to show up
19:16:16 <dsal> wejetheman: That's a language extension:  LambdaCase
19:16:57 <wejetheman> is it built in?
19:17:09 <dsal> In ghc yeah.  Try adding this to the top of your file:   {-# LANGUAGE LambdaCase #-}
19:17:12 <ski> no, it's an extension
19:17:25 <dsal> I guess it depends on what you mean by built-in
19:17:33 <ski> provided by GHC. not built-in to the language
19:18:11 <wejetheman> that did it. thanks. but i think ill just use the old format rather than adding a line :p
19:18:33 <dsal> You're probably going to end up using some language extensions.
19:18:46 <ski>   orbitalPeriodOf Mercury = 0.2408467
19:18:57 <ski>   orbitalPeriodOf Venus   = 0.6151972
19:18:59 <ski>   ...
19:19:08 <ski> that's probably how i would write it
19:19:13 <dsal> Yeah, I agree with that.
19:20:05 <ski> (so that each defining equation can be read as a separate (independently) true fact about `orbitalPeriodOf')
19:21:25 <wejetheman> that makes sense to me
19:21:56 <ski> if you want to account to Gregorian (sometimes lack of) leap years, then it should be `365.2425', not `365.25', i suppose ..
19:22:16 * ski . o O ( `Tellus' )
19:25:12 <wejetheman> lol making a leap year calculator was an earlier assignment. this was my submission. http://codepad.org/kCrs9LI1
19:25:50 <wejetheman> well leap year tester i guess
19:27:55 <dsal> Leap years are a scam.
19:29:57 <wejetheman> like globe earth
19:33:35 <dsal> Yeah.
19:45:14 * hackage hsdev 0.3.3.6 - Haskell development library  https://hackage.haskell.org/package/hsdev-0.3.3.6 (AlexandrRuchkin)
19:52:30 <Axman6> Matt Parker's alternative to the current leap year system was pretty intriguing. and was based on powers of two which makes calculation very simple
19:53:32 <EvanR> except for this weird offset to account for leap years up to this point o_O
19:54:11 <Axman6> https://www.youtube.com/watch?src_vid=IJhgZBn-LHg&v=qkt_wmRKYNQ
19:54:23 <EvanR> any calendar is half-assing it because you can't get it exact, unless you give up and use a simple calendar with no leap days
19:54:37 <EvanR> stop worrying and just let it drift
19:54:56 <EvanR> same with leap seconds
19:54:57 <Axman6> but my crops!
19:55:27 <EvanR> really... 
19:57:31 <shapr> golly, left fish solves my problem with a stack of lookup calls
19:58:29 <shapr> :t flip Data.Map.lookup (Data.Map.empty) <=< Data.Map.lookup "key"
19:58:30 <lambdabot> Ord k => M.Map [Char] k -> Maybe c
19:59:00 <shapr> now that I have three left fishes on one line, I worry no one else will be able to read this code.
19:59:26 <EvanR> the "haskell has too many operators" police will show up
19:59:33 * shapr calls the operator
20:00:18 <EvanR> fish also falls outside "operators that are there with no imports"
20:01:05 <shapr> previously I had a dozen lines of case M.lookup uid userState of Nothing -> Nothing
20:01:20 <shapr> I think I'll have four left fish on this line when it's done
20:10:13 <maerwald> too many operators wouldn't be a problem if we had at least a single properly working IDE
20:12:02 <shapr> maerwald: what about vscode?
20:12:47 <Axman6> VSCode + TabNine is quite scary
20:13:56 <maerwald> shapr: works well with typescript ;)
20:14:12 <Axman6> it works fine with Haskell too
20:14:55 <maerwald> if it doesn't crash your machine, because HIE is eating up all your ram... or if the type info windows even show up
20:14:59 <maerwald> or the completion
20:16:26 <Axman6> cmd-shift-r -> reload window usually fixes that. I believe that's a HIE problem more than a VS code one
20:16:38 <maerwald> https://github.com/haskell/haskell-ide-engine/issues/1146
20:17:02 <shapr> I'm excited about how things are improving in the Haskell tooling world.
20:17:15 <maerwald> I won't hold my breath
20:17:19 <Axman6> performance still seems to be a big issue
20:17:30 <Axman6> and memory usage
20:17:41 <Axman6> I need to give the new thing from tweag a go
20:18:06 <shapr> ormolu?
20:18:09 <shapr> which thing?
20:18:25 <Axman6> ghcide or something?
20:18:39 <Axman6> ah Digital Asset, not Tweag
20:27:00 <shapr> yay, my code works!
20:27:23 <shapr> now I need to create the "initial user" part, and it's ready for alpha testing
20:30:53 <MarcelineVQ> arf arf alpha
21:03:48 <jusss> there's no Control.Monad.Trans.Either ?
21:05:31 <dibblego> ExceptT
21:05:38 <dibblego> http://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Except.html#t:ExceptT
21:05:55 <jusss> dibblego: since when?
21:06:05 <dibblego> several years afaik
21:06:35 <dibblego> there is this though, https://hackage.haskell.org/package/either-4.4.1/docs/Control-Monad-Trans-Either.html
21:06:36 <jusss> dibblego: I use cabal to install telegram-api, and the error message is 'could not find module `Control.Monad.Trans.Either' in API/API.hs:34
21:06:47 <dibblego> ok, it's that one I guess ^
21:06:56 <jusss> dibblego: what I suppose to do? just edit this API.hs?
21:07:35 <dibblego> get it to find that module
21:09:02 <maerwald> dibblego: it seems it doesn't exist in version 5.x.x
21:09:34 <jusss> dibblego: how?
21:09:48 <jusss> maerwald: how I can get this Control.Monad.Trans.Either
21:09:50 <dibblego> use the correct GHC version, at a guess
21:10:09 <jusss> the current version is 8.6.5
21:11:17 <dibblego> > "correct" == "current"
21:11:19 <lambdabot>  False
21:11:46 <maerwald> jusss: you are building from github?
21:21:40 <jusss> maerwald: from cabal
21:22:14 <maerwald> what does that mean? hackage?
21:22:25 <jusss> maerwald: hackage I think
21:23:13 <jusss> maerwald: I just put the name in to .cabal's depends section, then `cabal repl'
21:26:14 * hackage predicate-typed 0.1.0.0 - Predicates, Refinement types and Dsl  https://hackage.haskell.org/package/predicate-typed-0.1.0.0 (gbwey)
21:31:46 <jusss> mtl package is not same with transformers pacakge?
21:34:16 <jle`> jusss: transformers package offers monad transformers
21:34:25 <jusss> jle`: and mtl?
21:34:45 <jusss> jle`: and can I use EitherT in ghc 8.6.5?
21:34:46 <jle`> jusss: mtl is an effects system that lets you write actions polymorphically over different monads
21:35:00 <jle`> using typeclasses to constrain monads on effects they must support
21:35:15 <jle`> if you are looking for an Either monad transformer you can use ExceptT
21:35:50 <jusss> jle`: why telegram-api using that EitherT since Either Transformer is abandoned
21:36:16 <jle`> maybe they didn't realize
21:36:26 <jusss> jle`: https://paste.ubuntu.com/p/JPBFkXzz4M/
21:36:33 <jusss> jle`: and how I can fix it?
21:37:35 <jle`> maybe file an issue
21:37:41 <jle`> to the maintainers
21:38:30 <jle`> this is rather unfortunate
21:39:10 <jusss> jle`: the cabal shows build telgram-api-0.3.0.0 failed, but based on the hackage which is current 0.7.2.0
21:39:26 <jusss> jle`: and I just cabal update yesterday, and v3
21:39:30 <jusss> why this happend
21:40:09 <jusss> do I need run cabla update every time when I create an new project?
21:42:00 <sclv> jusss: add a constraint to the depends to force the latest telegram-api
21:42:24 <sclv> telegram-api >= 0.7.0.0
21:43:21 <jusss> sclv: then base verion is conflicted with that, 
21:44:00 <jusss> sclv: why base >=4.12 && <4.13 as the default, when I'm in ghc 8.6.5
21:44:22 <jusss> and cabal is v3, the default .cabal is generated by `cabal init'
21:44:51 <sclv> what pins that base version
21:45:29 <sclv> Oh — servant!
21:45:50 <sclv> if you cabal update it should worj
21:46:09 <sclv> If its servant
21:46:18 <sclv> If its something else, maybe not
21:46:39 <sclv> anyway, you need to find out what's forcing the base to be too low
21:46:41 <sclv> and fix that
21:47:19 <jusss> sclv: https://paste.ubuntu.com/p/C5zbx96GvD/
21:47:39 <jusss> I'm on debian sid
21:48:21 <sclv> ok, telebot pins servant-client-core to an old version
21:48:24 <sclv> which requires an old base
21:48:42 <sclv> so Telebot (wherever its from) needs to fix that?
21:48:43 <jusss> sclv: which means it needs a low-version ghc?
21:49:06 <sclv> is TeleBot your code?
21:49:26 <jusss> sclv: yes, and just create it now
21:49:33 <sclv> so don't pin to old versions of servant
21:49:36 <sclv> use the latest ones!
21:49:51 <jusss> change the servant's version?
21:50:20 <sclv> yes, and client-core etc
21:50:22 <sclv> use the latest versions
21:50:30 <sclv> you're using older versions, which only work with older ghcs
21:50:54 <fraktor> Is there an alternative to `take n (repeat "foo")`?  Where I just directly generate a finite list.
21:51:05 <sclv> :ty replicate
21:51:10 <sclv> ?ty replicate
21:51:11 <lambdabot> Int -> a -> [a]
21:51:22 <sclv> > replicate 12 "hi"
21:51:23 <lambdabot>  ["hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi"]
21:51:36 <sclv> ?hoogle Int -> a -> [a]
21:51:36 <lambdabot> Prelude replicate :: Int -> a -> [a]
21:51:37 <lambdabot> Data.List replicate :: Int -> a -> [a]
21:51:37 <lambdabot> GHC.List replicate :: Int -> a -> [a]
21:51:55 <sclv> fraktor: hoogle is your best friend for these questions :-)
21:52:14 <jusss> sclv: why the author did that? use the old version
21:52:43 <sclv> maybe it wasn't the old version when they wrote the code!
21:52:44 <fraktor> sclv: I've used Hoogle before, but that didn't occur to me this time for some reason.
21:53:00 <sclv> jusss: as it is, the code may be bitrotted and not work perfectly with the latest version
21:53:36 <jusss> sclv: but they didn't update the dependent packages version
21:53:45 <sclv> beats me
21:53:56 <jusss> sclv: is there other tool for telegram?
21:54:04 <sclv> beats me
21:54:59 <sclv> jusss: https://hackage.haskell.org/packages/search?terms=telegram
21:57:28 <sclv> it looks like they updated telegram-api on github but didn't do a new hackage release for some reason https://github.com/klappvisor/haskell-telegram-api
21:57:50 <Axman6> @src replicate
21:57:50 <lambdabot> replicate n x = take n (repeat x)
21:59:53 <maerwald> https://www.haskell.org/cabal/users-guide/nix-local-build.html#cabal-v2-run why does the script annotation not support 'with-compiler'?
22:03:42 <jusss> sclv: if I git clone that project to local, how I can use it?
22:04:27 <sclv> iirc if its a subdir of your main project it'll use the clone
22:04:41 <sclv> you may need to create a cabal.project to enforce that, but i don't recall if you do
22:06:17 <jusss> sclv: we should have a pip tool...
22:06:19 <maerwald> https://cabal.readthedocs.io/en/latest/nix-local-build.html#specifying-packages-from-remote-version-control-locations
22:06:29 <maerwald> jusss: you mean 'cabal get'?
22:06:52 <jusss> maerwald: I mean a package manager just works well like pip in python...
22:07:02 <sclv> cabal is better
22:07:15 <maerwald> then I don't know what you want from pip that cabal doesn't do
22:07:20 <sclv> the thing that "works" in pip is just that the ecosystem is more well maintained in the happy path overall
22:07:26 <sclv> because there are so many more users
22:07:48 <sclv> so it appears better to use pip just because basic usage gets you way further
22:07:58 <sclv> due to way more people fixing up everything behind the scenes in the overall ecosystem
22:08:21 <maerwald> yeah, you can't fix the input by tooling
22:09:08 <jusss> about libghc-base-dev in debian sid, it seems be 4.12.0.0....
22:09:32 <jusss> but that telegram-api asked base >= 4.7
22:09:44 <sclv> its not the direct base dep that's the problem
22:09:47 <sclv> its the transitive dep
22:09:53 <sclv> telegram-api depends on an old servant
22:09:57 <sclv> which constrains the base package more significantly
22:09:59 <jusss> what's the right base?
22:10:07 <sclv> whatever shipped with your ghc
22:10:14 <sclv> you can find out by running `ghc-pkg list`
22:10:41 <jusss> sclv: yeah, base-4.12.0.0
22:11:10 <jusss> ghc 8.6.5
22:13:36 <jusss> servant-client need base >=4.7 and <4.11 but my base is 4.12
22:15:15 <sclv> yes
22:15:22 <sclv> lift the bound on servant client
22:15:47 <sclv> the github version of telegram-api has a  higher bound https://github.com/klappvisor/haskell-telegram-api
22:27:14 * hackage graphql 0.5.1.0 - Haskell GraphQL implementation  https://hackage.haskell.org/package/graphql-0.5.1.0 (belka)
22:29:30 <nineonine> I have an Exception which I throw with "throwTo"
22:29:45 <nineonine> it looks like it ends up wrapped with AsyncException
22:30:40 <nineonine> question: how can I implement a predicate with this type signature 
22:30:41 <nineonine> pred :: SomeException -> Bool
22:30:53 <nineonine> that would allow me to detect this exception
22:31:36 <nineonine> it looks like my problem is that this SomeAsyncException is existential so it forgets the thing it wraps
22:31:46 <nineonine> perhaps there is some "cast" trickery that could be done?
22:33:04 <sclv> if you `catch` you can `catch` only the exception subtype you want
22:33:16 <sclv> you don't need to downcast explicitly by catching `SomeException` and then casting it
22:33:58 <sclv> also
22:34:05 <sclv> ?hoogle fromException
22:34:05 <lambdabot> Control.Exception fromException :: Exception e => SomeException -> Maybe e
22:34:05 <lambdabot> Control.Exception.Base fromException :: Exception e => SomeException -> Maybe e
22:34:05 <lambdabot> Control.Monad.Catch fromException :: Exception e => SomeException -> Maybe e
22:34:12 <sclv> if you want to do it yourself
22:34:42 <nineonine> so I have this patten in code
22:34:58 <nineonine> forkFinally runRequest cleanUp
22:35:30 <nineonine> in cleanup function I branch on "Either SomeException a"
22:36:03 <nineonine> the branch that handles SomeException does "fromException"
22:36:09 <nineonine> which is where it fails
22:36:17 <nineonine> pattern*
22:36:23 <sclv> so you're saying fromException doesn't work?
22:36:30 <nineonine> no
22:37:00 <nineonine> with some tracing I can see that it is catching the SomeAsyncException
22:37:12 <nineonine> typeOf returns SomeAsyncException
22:37:21 <nineonine> but `show` returns my custom Exception
22:37:46 <nineonine> it is like I cannot look through SomeAsyncException but I am pretty sure it is doable
22:38:57 <nineonine> I tried this
22:38:58 <nineonine> asyncExceptionFromException :: Exception e => SomeException -> Maybe eSource
22:38:59 <sclv> ?hoogle asyncExceptionFromException
22:38:59 <lambdabot> Control.Exception asyncExceptionFromException :: Exception e => SomeException -> Maybe e
22:38:59 <lambdabot> Control.Exception.Base asyncExceptionFromException :: Exception e => SomeException -> Maybe e
22:38:59 <lambdabot> Control.Exception.Compat asyncExceptionFromException :: Exception e => SomeException -> Maybe e
22:39:02 <nineonine> didn't work
22:39:06 <sclv> welp
22:39:13 <sclv> that's what looks like it should do it to me
22:41:40 <sclv> Prelude Control.Exception> let test = asyncExceptionToException (CompactionFailed "test")
22:41:40 <sclv> Prelude Control.Exception> asyncExceptionFromException test :: Maybe AssertionFailed 
22:41:40 <sclv> Nothing
22:41:40 <sclv> Prelude Control.Exception> asyncExceptionFromException test :: Maybe CompactionFailed
22:41:40 <sclv> Just compaction failed: test
22:42:56 <nineonine> hmm
22:48:01 <nshepperd2> Use fromException :: SomeException -> Maybe YourException?
22:48:42 <nineonine> simply using "fromException" does not work
22:48:51 <nineonine> I am (re)trying asyncExceptionFromException again
22:49:17 <nshepperd2> What does "does not work" mean
22:50:12 <tenniscp25> I want to model a problem with nested map, something like: Map OuterKey (Map InnerKey Data). I also want it to support concurrent insert/update/delete so I add TVar to both inner and outer maps to be like: TVar (Map OuterKey (TVar (Map InnerKey Data))). Does this look ok or should I model it with something else? 
22:50:32 <nshepperd2> " typeOf returns SomeAsyncException" sounds like you are using fromException at the wrong type
22:50:44 <Axman6> tenniscp25: why do you need the nner TVars?
22:50:53 <Axman6> inner*
22:50:59 <nshepperd2> You should have SomeAsyncException nowhere in your code
22:51:43 <nineonine> "does not work" means "fromException returns Nothing"
22:51:58 <nineonine> but not "Just MyException"
22:52:14 <sclv> the extra concurrency from nested tvars may well not be worth the cost
22:52:27 <sclv> just the outer one will usually suffice, but its hard to say without looking at usage
22:52:37 <nineonine> "You should have SomeAsyncException nowhere in your code" 
22:52:38 <nineonine> why ?
22:55:14 <nshepperd2> fromException is normally supposed to handle all the unwrapping of sub-exceptions itself
22:55:35 <nineonine> I agree, this is what I expect
22:56:14 <tenniscp25> It's like TVar (Map TruckId (TVar (Map RouteId RouteInfo))). There are many trucks. Each truck has many routes. There can be updates both to trucks and to routes.
22:56:19 <fraktor> I'm trying to update a field in a record, and I'm getting a "not in scope" error. I know for a fact that I've spelled it correctly, and the compiler is fine with the type.  What else can I check?
22:56:23 <nshepperd2> Though maybe async exceptions are a special case, since they're not really part of the hierarchy
22:56:48 <tenniscp25> Axman6: It's like TVar (Map TruckId (TVar (Map RouteId RouteInfo))). There are many trucks. Each truck has many routes. There can be updates both to trucks and to routes.
22:56:52 <nineonine> https://markkarpov.com/static/img/exception-hierarchy.svg
22:57:01 <Axman6> tenniscp25: I would just use TVar (Map k (Map k2 v)). (or even IORef and atomicModifyIORef)
22:57:04 <sclv> tenniscp25: sure. but if your pattern is to not hang onto the transactional stuff for very long, then the extra nesting won't matter much
22:57:19 <jusss> sclv: I just git cloned that project on github, and then `cabal build', now it works
22:57:23 <sclv> great!
22:57:52 <tenniscp25> Would the nested tvars increase concurrency? I'm feeling like I'm overengineering..
22:58:02 <sclv> they almost certainly won't
22:58:12 <Axman6> they would probably add overhead which would decrease concurrency
22:58:23 <sclv> they only would if you hung onto the transaction and did a lot of computation inside of it
22:58:32 <tenniscp25> Okay..
22:58:51 <tenniscp25> Problem is it needs quite a bit of computation..
22:59:01 <tenniscp25> Thanks.. I'll look into it
22:59:19 <Axman6> well, the real answer is: try them all and benchmark
23:01:24 <nshepperd2> nineonine: how is the Exception instance for your type defined?
23:02:07 <nineonine> data JobCancelledException = JobCancelledException deriving (Show, Typeable)
23:02:18 <nineonine> instance Exception JobCancelledException
23:06:52 <nshepperd2> Where is SomeAsyncException coming into it then
23:07:02 <sclv> nineonine: try declaring it like this https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.IO.Exception.html#AllocationLimitExceeded
23:07:38 <nineonine> I will try that now, thanks
23:09:47 <fraktor> What would lead to a "not in scope" error when updating a record?
23:12:18 <nineonine> wow, it actually worked
23:12:20 <nineonine> hmmmm
23:12:34 <nineonine> thanks sclv!
23:12:44 <opqdonut> fraktor: the record not exposing fields?
23:12:48 <nineonine> probably the deriving mechanism does not factor in Async wrapper ?
23:12:50 <nineonine> hmmmm
23:13:22 <fraktor> opqdonut: Huh. It is in a different module, but I thought that I had exported all that.
23:13:36 <fraktor> Exporting Record(..) should be enough, right?
23:14:25 <nineonine> fraktor, yes correct, this will do
23:16:41 <fraktor> https://0paste.com/40505#hl This is my code. I'm getting an error on the line that says "... Right topic { topicId = endUpdated }"
23:18:44 * hackage authenticate-oauth 1.6.0.1 - Library to authenticate with OAuth for Haskell web applications.  https://hackage.haskell.org/package/authenticate-oauth-1.6.0.1 (HiromiIshii)
23:50:54 <dminuoso> fraktor: Your paste site is throwin 502 errors.
