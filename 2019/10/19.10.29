00:01:05 <koz_> If I have State s a and State t b, can I mash them together into State (s, t) (a, b)?
00:08:55 <jackdk> turn them into functions, combine them into (s, t) -> ((a, b), (s, t)) and wrap them back up in State seems easiest to me
00:09:23 <koz_> jackdk: Ah, so no easy pleasant combination function? Sad.
00:09:37 <jackdk> I dunno if one exists
00:11:30 <koz_> Maybe jle`'s functor-combinators library might have me covered.
00:11:46 <jackdk> runState, state and (***) from control.arrow seem promising
00:12:27 <koz_> jackdk: I guess I could try that approach too.
00:13:48 <Madara> Greetings! haskellers
00:13:49 <dibblego> it won't work, you could write it using lens, but it's not worth it
00:21:09 <jackdk> beside left right = state $ (\((a,s),(b,t)) -> ((a,b),(s,t))) <$> (runState left *** runState right) is the best I could do
00:24:16 <koz_> You could also argue for something similar for Reader: Reader r a -> Reader s b -> Reader (r, s) (a, b).
00:24:22 <koz_> I find it weird that no such thing exists.
00:31:43 <martijnbastiaan> http://hackage.haskell.org/package/concurrent-supply currently doesn't build on 8.8 due to its tight hashable bounds. Could someone change the bounds to `>=1.1 && <1.4`? Tested over here: https://github.com/ekmett/concurrent-supply/pull/7.
00:34:12 * hackage dl-fedora 0.7.2 - Fedora image download tool  https://hackage.haskell.org/package/dl-fedora-0.7.2 (JensPetersen)
00:34:36 <koz_> martijnbastiaan: You can request an NMU here: https://github.com/haskell-infra/hackage-trustees/issues
00:35:47 <martijnbastiaan> koz_: Thanks!
00:42:45 <jusss> how to use multiple-lines in let .. in ?
00:42:58 <jusss> `let a=b, c=d in ...'
00:43:04 <jusss> parse error on ,
00:43:50 <martijnbastiaan> jusss: let a=3; b=4 in a + b
00:44:44 <dminuoso> martijnbastiaan you can also try poking edwardk in here. :p
00:45:24 <martijnbastiaan> edwardk: https://github.com/ekmett/concurrent-supply/pull/7 O:)
00:45:53 <dminuoso> martijnbastiaan: Mind my asking, why is it blocking your release?
00:46:34 <dminuoso> martijnbastiaan: Do you have a hard dependency on hashable-1.3 ?
00:47:34 <martijnbastiaan> dminuoso: no, it's just that hashable < 1.3 doesn't build on 8.8
00:48:36 <dminuoso> martijnbastiaan: Wow really? Why is that?
00:49:26 <dminuoso> hashable has `base (>=4.5 && <4.14)`
00:49:34 <martijnbastiaan> hmmm
00:49:39 <hololeap> what does Seq from Data.Singletons.Prelude do?
00:49:44 <dminuoso> martijnbastiaan: The reason Im asking is because I think I know what your problem is.
00:49:47 <dminuoso> martijnbastiaan: Is cabal failing to find a plan?
00:50:11 <martijnbastiaan> dminuoso: haven't tried for a while actually! Let me try
00:50:31 <koz_> hololeap: It's a linear structure with fast prepend and append.
00:50:48 <jusss> martijnbastiaan: let a = b; c=d in f x where xxx this form is ok?
00:50:50 <jusss> https://paste.ubuntu.com/p/jwfj5txT6z/
00:51:03 <hololeap> koz_: so it's the same as from Data.Sequence? i can't find any readable docs for singleton
00:51:17 <martijnbastiaan> jusss I think so :). Try it in GHCi!
00:51:28 <koz_> hololeap: Oh wait, that's something else, lol.
00:51:34 <koz_> I should read more carefully.
00:52:36 <martijnbastiaan> dminuoso: https://pastebin.com/8RMeS0gr
00:52:53 <jusss> sawas listA listB =      let lengthB = D.length listB; copyB = listB in      f listA listB [] 0   where f ....  this say lengthB and copyB not in scope
00:53:27 <jusss> in the `where ' block , it can access lengthB and copyB?
00:53:33 <sshine> jusss, you can also use gist.github.com for many lines.
00:53:48 <martijnbastiaan> dminuoso: Right, so, concurrent-supply forces hashable 1.2.7.0. Hashable 1.2.7.0 has base (>=4.4 && <4.13), and GHC 8.8 ~ base-4.13
00:54:04 <jusss> sshine: I'm on windows, also gist.github.com is blocked...
00:54:25 <dminuoso> martijnbastiaan: Ah I see.
00:57:54 <edwardk> martijnbastiaan: merged
00:59:11 <edwardk> martijnbastiaan: either i can get around to doing a maintainer release, or someone like phadej or george wilson or hvr can
00:59:27 <edwardk> basically it just needs a revision
00:59:37 <martijnbastiaan> edwardk: thank you! 
00:59:50 <martijnbastiaan> yeah
01:00:12 <martijnbastiaan> edwardk: would it be an option to edit the version bounds using http://hackage.haskell.org/package/concurrent-supply/maintain ?
01:00:18 <MarcelineVQ> jusss: no    let a in b    means that a only exists in b
01:00:29 <edwardk> thats what i'm doing
01:00:51 <edwardk> i revised the latest i just need to decide how far back to go
01:00:55 <yushyin> jusss: who would block github? oO
01:01:08 <jusss> yushyin: the Greate FireWall
01:01:09 <martijnbastiaan> edwardk perfect, thank you :)
01:01:25 <jusss> yushyin: not whole github, just gist.github
01:01:36 <yushyin> jusss: and VPN is not an option?
01:02:24 <jusss> yushyin: lots of VPN is bloked too since a month ago
01:02:26 <edwardk> martijnbastiaan: everything from 0.1.4.1 forward is revised.
01:02:45 <edwardk> martijnbastiaan: i can't go back further than that because they have a hard cap on 1.2 below that
01:02:45 <martijnbastiaan> edwardk great!
01:02:57 <jusss> yushyin: since its 70th anniversary
01:03:08 <martijnbastiaan> edwardk: no problem
01:04:07 <yushyin> jusss: such a bummer :/
01:06:34 <jusss`> yushyin: yeah, even visit stackoverflow.com will take 1 minute
01:07:16 <sicklorkin> jusss: there are many different sites for pasting text, pastebin.net
01:08:28 <jusss`> sicklorkin: ok
01:14:07 <jusss`> hmm, how to create a namespace in a function for other with-in-thing to access? like `let' in scheme?
01:15:05 <jusss`> (let ((a 1) (b 2)) do-stuff-with-a-b)
01:16:04 <sicklorkin> let f = let a = 1 \n    b = 2 in a + b
01:16:20 <yushyin> > let a=1; b=2 in a+b
01:16:23 <lambdabot>  3
01:16:25 <jusss`> I create a function to split a list with a list https://pastebin.com/NRJKykQm
01:17:12 <jusss`> sawas [1,2,3] [2] will be [[1],[3]],
01:18:41 <jusss`> sicklorkin: yushyin in my link, the 9th, how to make `where' can visit 'let..in ' https://pastebin.com/NRJKykQm
01:19:08 <sicklorkin> splitOn sep (x:xs) | sep = x = [] : splitOn sep xs ; | True = let (xs':xss) = splitOn seq xs in (x:xs'):xss
01:19:26 <sicklorkin> splitOn :: Eq a => a -> [a] -> [[a]]
01:19:30 <yushyin> jusss`: it cannot
01:26:07 <yushyin> jusss`: the definition in the where-clause in line 11 ff. will never see the bindings from the let-in in line 9.
01:26:50 <jusss`> yushyin: yeah
01:27:09 <jusss`> everything in haskell syntax is so hard
01:31:42 * hackage fedora-dists 1.1.0 - Library for Fedora distribution versions  https://hackage.haskell.org/package/fedora-dists-1.1.0 (JensPetersen)
01:33:18 <lortabac> jusss`: let and where are two different syntaxes for the same thing
01:34:14 <jusss`> lortabac: ok
01:34:18 <lortabac> choose one of the two and use it consistently
01:35:44 <jusss`> lortabac: I move that let..in part to where , now it works https://pastebin.com/Ush9saHW
01:37:11 <yushyin> I use both at times, because they are different. Let-in beeing an expression and where-clause not.
02:22:42 * hackage haskoin-core 0.9.6 - Bitcoin & Bitcoin Cash library for Haskell  https://hackage.haskell.org/package/haskoin-core-0.9.6 (xenog)
02:33:12 * hackage simple-cmd-args 0.1.4 - Simple command args parsing and execution  https://hackage.haskell.org/package/simple-cmd-args-0.1.4 (JensPetersen)
02:42:42 * hackage o-clock 1.1.0 - Type-safe time library.  https://hackage.haskell.org/package/o-clock-1.1.0 (gromak)
02:44:34 <sicklorkin> Are these hackage package updates delivered here by-way-of RSS?
02:46:05 <sshine> good question.
02:47:56 <sshine> mniip, does your hackagebot have open source code?
02:49:08 <sshine> sicklorkin, you could certainly poll http://hackage.haskell.org/packages/recent -- I don't know if there's a hidden smarter way.
02:49:50 <sicklorkin> sshine: thanks - i've been brute forcing the well known paths but :shrug:
02:49:53 <phadej> <link rel="alternate" type="application/rss+xml" title="Hackage RSS Feed" href="/recent.rss" />
02:49:59 <phadej> look at the source :)
02:50:03 <sicklorkin> ahhh
02:50:04 <sicklorkin> thanks
02:50:16 <sicklorkin> http://hackage.haskell.org/packages/recent.rss
02:50:26 <sshine> phadej, I did! but I was so impatient that I closed the window before finding it. ;)
02:51:16 <sicklorkin> `/feed http://hackage.haskell.org/packages/recent.rss` in slack :)
02:54:00 <sicklorkin> Anyone on the slack haskell here? I want to add ^^^^ to #hackage - too much?
02:54:50 <sicklorkin> functionalprogramming.slack.com is the actual workspace
02:57:02 <sshine> nah, I don't like Slack. suddenly it wants me to pay $5/mo. for my message history.
02:57:42 * hackage lightstep-haskell 0.1.5 - LightStep OpenTracing client library  https://hackage.haskell.org/package/lightstep-haskell-0.1.5 (DmitryIvanov)
02:58:07 <sicklorkin> sshine: yeah, it's not very nice - however, add a bot to the channel and you can log everything
02:59:38 <sicklorkin> (I personally :hat: slack, but the masses seem to, so i digress)
03:00:54 <sshine> sicklorkin, I take part in Exercism.io, and they're very happy about Slack. until some GitHub post says "You know, that thing that was discussed/decided." and there's no reference of it whatsoever. I think Slack ruins transparency for open cooperation.
03:03:19 <sshine> at least IRC is so inconvenient you don't start inlining editable documents in the history. ;)
03:04:44 <sicklorkin> sshine: exactly, it's terrible cause it has somehow become some middle where between everything important and documentation; then to add fuel to the ambers people try to turn slack into full CRM solutions and don't care about findability
03:08:52 <sicklorkin> sshine: does slack still support their IRC protocol?
03:11:04 <sshine> sicklorkin, they disabled their official IRC gateway some years ago.
03:11:52 <sshine> sicklorkin, https://it.slashdot.org/story/18/03/08/2049255/slack-is-shutting-down-its-irc-gateway
03:12:03 <sshine> sicklorkin, sorry, <2 years ago.
03:12:56 <sshine> sicklorkin, their argument does make sense for IRC, but not really for XMPP, so they were criticized for their silo business model. but hey, that's how they're gonna make money.
03:27:48 <jackdk> sicklorkin: after bootstrapping enough users via xmpp and irc bridges, slack pulled the ladder up behind them. As weird and old as IRC is, I like having an open standard instead of apps everywhere
03:28:52 <jackdk> (It's like 2000 all over again, but instead of AIM, Yahoo!Messenger, MSN, ICQ, ...; it's Slack, Discord, Gitter, ...)
03:32:30 <maerwald> ICQ... good times
03:32:40 <maerwald> also miss the ads
03:55:41 * hackage cabal-flatpak 0.1 - Generate a FlatPak manifest from a Cabal package description  https://hackage.haskell.org/package/cabal-flatpak-0.1 (HenningThielemann)
04:07:41 * hackage elm2nix 0.1.2 - Turn your Elm project into buildable Nix project  https://hackage.haskell.org/package/elm2nix-0.1.2 (domenkozar)
04:40:11 * hackage websockets 0.12.6.1 - A sensible and clean way to write WebSocket-capable servers in Haskell.  https://hackage.haskell.org/package/websockets-0.12.6.1 (JasperVanDerJeugt)
04:58:12 * hackage stylish-haskell 0.9.4.0 - Haskell code prettifier  https://hackage.haskell.org/package/stylish-haskell-0.9.4.0 (JasperVanDerJeugt)
05:23:11 * hackage polysemy 1.2.3.0 - Higher-order, low-boilerplate, zero-cost free monads.  https://hackage.haskell.org/package/polysemy-1.2.3.0 (isovector)
05:28:10 <isovector1> hackage won't allow me to upload a package with `-dcore-lint` enabled in my tests
05:28:38 <isovector1> but the tests are for a typechecker plugin that can violate corelint, and has before
05:28:42 <isovector1> is there a way to get around this?
05:29:09 <merijn> isovector1: Ask in #hackage ?
05:29:49 <isovector1> merijn: thanks
05:38:41 * hackage polysemy-plugin 0.2.4.0 - Disambiguate obvious uses of effects.  https://hackage.haskell.org/package/polysemy-plugin-0.2.4.0 (isovector)
05:43:25 <bwe> Can I compare getter/setters of Control.Lens for equality?
05:44:22 <dminuoso> bwe: In what sense? Do you want to test whether two given getters are extensionally equivalent?
05:44:56 <EvanR> since they are functions, you can't just compare their value
05:45:00 <bwe> dminuoso: What do you mean with extensionally?
05:45:19 <dminuoso> bwe: They are functions. Haskell functions can be extensoinally or intensionally equivalent.
05:45:19 <bwe> EvanR: I would like to compare, in a sense, if they are the same function.
05:45:31 <EvanR> well, what sense
05:45:34 <dminuoso> bwe: "the same function" can mean different things.
05:45:58 <EvanR> reallyUnsafePtrEquality heh
05:45:59 <dminuoso> bwe: Extensional equivalence essentially means they map the same points in their domain to the same points in their codomain.
05:46:49 <dminuoso> bwe: There's no automated solution to test for extensional equivalence because of the halting undecidability.
05:47:23 <EvanR> going out on a limb to predict that whatever reason you need to compare if two lenses are the same function then you're doing something wrong
05:47:41 * hackage fastparser 0.3.2 - A fast, but bare bones, bytestring parser combinators library.  https://hackage.haskell.org/package/fastparser-0.3.2 (SimonMarechal)
05:48:22 <bwe> data MyRecord = MyRecord { _a :: String, _b :: String, ... } deriving (Show, Generic) -- I have a function that takes 'a' or 'b' as a Lens, so it does the job on _a if I supply it with 'a'. I want to make it behave differently for 'b'.
05:49:23 <EvanR> what do you want it to do for b
05:50:39 <bwe> EvanR: preciser: I want it to execute an operation on any field supplied except for field b. so for b it should be a non-op.
05:51:02 <bwe> but I feel I am trying to solve a problem at the wrong place.
05:51:06 <EvanR> yes
05:51:13 <EvanR> sounds like an XY problem
05:54:44 <bwe> I need some rule of thumb how to spot an XY problem
05:55:05 <bwe> ;-)
05:55:31 <lyxia> @where xy
05:55:31 <lambdabot> http://xyproblem.info/
05:55:42 * hackage hs-speedscope 0.1.0.0 - Convert an eventlog into the speedscope json format  https://hackage.haskell.org/package/hs-speedscope-0.1.0.0 (mpickering)
05:55:55 <EvanR> well, Z is how to compare functions by ptr equality, which is usually not a thing you do in haskell
05:56:13 <merijn> EvanR: In any language, tbh :p
05:56:28 <EvanR> we  don't know what X is yet
06:01:41 * hackage fastparser 0.4.0 - A fast, but bare bones, bytestring parser combinators library.  https://hackage.haskell.org/package/fastparser-0.4.0 (SimonMarechal)
06:15:41 * hackage lightstep-haskell 0.1.6 - LightStep OpenTracing client library  https://hackage.haskell.org/package/lightstep-haskell-0.1.6 (DmitryIvanov)
06:42:38 <jpcooper> Hello. I have built an executable with stack, which I see through ldd depends on libffi.so.6 and libffi.so.7. I do not have libffi.so.7. I am not aware of any packages in the dependency graph which depend on a specific version of libffi. What tools can I use to find out which Haskell package depends on libffi.so.7?
06:51:12 <merijn> jpcooper: GHC and the FFI depend on libffi
06:54:03 <ovitus> is there any way to write a function that condenses the parameter list?
06:54:22 <merijn> ovitus: What do you mean by that?
06:54:35 <ovitus> not a great example, but say I have something worse then this, with tons of function parameters
06:54:38 <ovitus> let exampleFunc a b c d e f = a + b - c * d / e ^ f
06:54:54 <ovitus> I can't do something like let exampleFunc [a..f] = a + b - c * d / e ^ f
06:55:10 <heatsink> You could make a data structure for passing the parameters
06:55:15 <kuribas> ovitus: you can do exampleFunc (a, b, c, d, e, f) = ...
06:55:21 <jpcooper> merijn: Thanks. I'll look into that
06:55:39 <heatsink> Instead of passing 6 parameters, put them into one data structure and pass that
06:56:00 <ovitus> any example of that?
06:56:30 <ovitus> kuribas, how is that more concise though?
06:56:34 <heatsink> You could take a look at the System.Process API
06:57:06 <heatsink> It has a function createProcess, which takes a CreateProcess argument that has many fields
06:57:17 <kuribas> ovitus: you can put that in a variable
06:57:35 <kuribas> ovitus: not sure what you want though, the first version looks perfectly fine for me.
06:58:02 <kuribas> ovitus: if you are using the same parameters often, I would put it in a datatype.
07:01:31 <EvanR> ovitus: when passing a record, you can access all the components using a pattern
07:01:49 <EvanR> that way you don't mess up your formula with record selectors
07:02:45 <ovitus> hmm need some example of what you're talking about
07:05:24 <EvanR> kuribas showed basically the same thing
07:05:33 <EvanR> tuple and record are pretty much the same thing
07:07:05 <jchia_> Is there a package that lets me query and set pulseaudio volume?
07:51:35 <exarkun> Where are the LetsEncrypt (ACME) client libraries for Haskell?
07:53:59 <dmwit> jchia_: I believe no. =(
07:54:06 <dmwit> At least last time I checked. I guess that was a few years ago.
08:04:44 <jpcooper> How can I find out in the context of a stack project which packages depend on a chosen package?
08:05:12 * hackage lightstep-haskell 0.1.7 - LightStep OpenTracing client library  https://hackage.haskell.org/package/lightstep-haskell-0.1.7 (DmitryIvanov)
08:08:32 <dmwit> You could look at the reverse dependencies site. Won't tie in to stack, but might be useful anyway.
08:08:35 <dmwit> ?where revdeps
08:08:36 <lambdabot> <http://packdeps.haskellers.com/reverse>,<http://packdeps.haskellers.com/>,<http://www.yesodweb.com/blog/2011/02/reverse-packdeps>
08:10:33 <jpcooper> Thanks, dmwit. I'm supposing then that there is no existing way to do this for a specific stack project
08:16:07 <geekosaur> isn't there stack planner? it might provide some clues, at least
08:16:52 <geekosaur> afaik there's no way to ask either stack or cabal-install what induces a particular dependency
08:17:41 <jpcooper> geekosaur: I couldn't find anything on "stack planner"
08:17:45 <geekosaur> both should have it in debug / sufficiently verbose output, but it's voluminous and difficult to understand
08:17:57 <dmwit> cabal will give you a JSON file that includes the complete dependency tree.
08:18:10 <dmwit> But I don't know of any extant tool that processes that file to answer the exact query jpcooper wants to run.
08:18:35 <jpcooper> dmwit: That's a start. Do you know how to run cabal so it uses the database of the stack project?
08:18:49 <dmwit> I know next to nothing about stack.
08:18:57 <geekosaur> loks like it became "stack ls dependencies"
08:18:59 <glguy> Create a freeze file and remove the package in question 
08:19:30 <glguy> Give an impossible constraint on it and see the error message
08:23:12 * hackage stylish-haskell 0.9.4.3 - Haskell code prettifier  https://hackage.haskell.org/package/stylish-haskell-0.9.4.3 (JasperVanDerJeugt)
08:42:26 <jusss> how I can change a outside variable in a function?
08:42:53 <dmwit> mu
08:42:57 <jusss> like `a=1; f _ = a=2'
08:43:12 <dmwit> Can't.
08:43:15 <dmwit> Make a different plan.
08:43:28 <jusss> python and c call this global variable
08:43:40 <dmwit> Still can't, even if other languages can do other things.
08:43:45 <Zemyla> Variables in Haskell are immutable.
08:43:47 <jusss> or dynamic variale
08:44:46 <geekosaur> won't help to try to find a different name for it; it's not a thing in Haskell. immutability is a large part of the point
08:45:05 <jusss> dmwit: what's the other plan? make a new binding ?
08:45:10 <geekosaur> there are mutable IORefs, but they don't work this way either
08:45:26 <Athas> So, what's the fastest way to write the recursive Fibonacci function in Haskell?
08:45:35 <Athas> Unboxed integers?
08:45:44 <geekosaur> generally you thread a valeu through a computation, producing a new one in each step; see foldl/foldr for an example
08:45:51 <dmwit> jusss: One standard alternative is to pass in the old value and return the new value.
08:46:05 <dmwit> jusss: Leave it to the caller to keep track of which value is newest.
08:46:21 <jusss> here is the case, there's recursive function, there's a socket function `recv' in it, when it recvs something, it need to change some values
08:46:25 <dmwit> jusss: (There is a monad that will make this less painful, but it can be worth practicing doing it yourself first so you know what's going on.)
08:46:26 <merijn> Athas: The exponential recursive one or just "Fibonacci" which is recursive because that's what you do in Haskell?
08:46:41 <Athas> merijn: the exponential one.  I'm benchmarking recursion.
08:47:22 <merijn> Unboxed int, probably, although I'd get worried about GHC getting to smart and uppity and defeating my benchmark :)
08:47:49 <dmwit> jusss: Does this require communicating between threads?
08:48:01 <jusss> dmwit: no
08:48:09 <dmwit> Then simply pass around the correct value.
08:48:36 <dmwit> Have your recursive function take the current value as an argument; when you recurse, pass in the modified value.
08:48:55 <Athas> Well, looks like a straightforward implementation is actually quite fast.
08:49:22 <Ariakenom> unboxed Word8? :p
08:49:45 <merijn> Ariakenom: Word8 and Int are the same size
08:50:00 <dmwit> I wouldn't be surprised if GHC were smart enough to turn the straightforward implementation into a worker-wrapper around an unboxed implementation at higher optimization levels.
08:50:03 <geekosaur> Athas, ghc is clever about converting recursion to loops
08:50:07 <geekosaur> yeh
08:50:18 <Ariakenom> eh yeah true
08:50:20 <Athas> It certainly has unboxed the Int.
08:50:39 <Athas> It's still doing the exponential recursion, which is good.
08:50:48 <merijn> microbenchmarking optimising compilers is *hard*
08:51:19 <Athas> Looks very nice to me: https://gist.github.com/athas/cfbfb18e6d09128386a1be40e0421af7
08:51:25 <geekosaur> monochrom has an example @quote of gcc outwitting him at one point
08:51:42 <jusss> dmwit: but what if the number of parameters in recursive function are not sure, they may be 3 parameter or 2 parameters
08:51:59 <Athas> merijn: well, I'm just trying to figure out where in the performance spectrum my hacked-up manually encoded recursion for Futhark lies.  It does explicit stack management with an array.
08:52:23 <Athas> So far, it it's twice as slow as C, about 50% slower than GHC, and a small bit faster than mlton and mlkit.
08:52:43 <dmwit> jusss: Sounds strange. Maybe you should just have two functions that are mutually recursive. Or maybe you should take a Maybe argument. I don't know. The question is too vague to answer definitively.
08:54:50 <jusss> dmwit: actually it's just about how value stored and can we change that value, like other languages's global variable, we store a value in a global variable, and we can get access and change it anywhere
08:54:50 <dmwit> jusss: Anyway, that question appears to be completely orthogonal to "how do I simulate global variables".
08:55:07 <jusss> dmwit: yes, it is.
08:56:39 <geekosaur> as I mentioned earlier, there are IORefs. you still have to pass the IORef itself around (there are unsafe hacks to achieve "global" but you need to be careful or ghc will hand you your butt) but its contents are mutable. note that you need to be in IO to use them, though
08:57:04 <jusss> we maybe bind a value to a indentifer, we don't want to use it now, and after several code sections, we may want to use this indentifier and restore it with other value
08:57:09 <geekosaur> the short answer to "how do i make a global variable like in language X" is "you don't"
08:57:28 <jusss> geekosaur: ok
08:58:02 <jusss> except the way as a paramter to a recursive function to do that, any others way?
08:58:34 <dmwit> What don't you like about that way?
08:58:56 <geekosaur> the whole point of Haskell is we don't do that, all values including bindings are immutable and this enables lazy pure functional programming
08:59:21 <jusss> dmwit: that means I have to point that parameter every recursion
09:00:27 <geekosaur> worker/wrapper
09:01:04 <geekosaur> the wrapper binds a value, it's available to the worker. (this assumes it's a constant. or something like an IORef / STRef)
09:01:35 <jusss> ok
09:01:37 <geekosaur> if it needs to change, you have to pass it on. State / StateT will do this for you, and ghc is often clever enough to turn it into a loop
09:02:29 <geekosaur> we prefer to be able to write code that's easy to understand and make the compiler do the clever part
09:09:47 <lukelau> Is it possible to have a type family return bottom?
09:11:08 <lukelau> I’m trying to create a type family that only accepts two different types https://gist.github.com/e746c5156d69e0da54edf321c4e7cfb4
09:13:38 <EvanR> i tried globals in haskell a few times and it never seem to help
09:14:09 <jzyamateur> Composition operator is associative, right ?
09:14:16 <shryke47> it is
09:14:17 <merijn> jzyamateur: Yes
09:14:18 <edmundnoble> lukelau: Maybe you want `TypeError`
09:14:48 <merijn> jzyamateur: Which is why (.) and id form a Monoid :)
09:15:02 <EvanR> um...
09:15:04 <EvanR> Category?
09:15:21 <merijn> EvanR: That too
09:15:37 <EvanR> what is the Monoid, Endo ?
09:15:40 <merijn> Yes
09:15:48 <EvanR> got it
09:15:59 <lukelau> edmundnoble: that worked, thanks!
09:16:05 <merijn> Strictly inferior to the function monoid MVP
09:17:07 <merijn> If I ever have spare time I'm going to write an ode to "instance Monoid m => Monoid (a -> m)", most versatile of all the monoids :p
09:17:21 <dminuoso> optparse-applicative question, Im using subparser to parse one of two commands. If I dont specify any command, the generated docs doesn't list available commands but gives me the options for the *first* command rather.
09:17:23 <dminuoso> Why might that be?
09:18:49 <merijn> dminuoso: Sounds like you attached those options to the wrong parser?
09:19:06 <merijn> dminuoso: For my parsers it only lists the global options and complains about a missing command
09:19:26 <merijn> dminuoso: Link you parser?
09:19:36 <dminuoso> merijn: https://gist.github.com/dminuoso/4171aedfad29a2e8a49256eda8863473
09:19:48 <dminuoso> (I can include more if you want)
09:20:38 <merijn> dminuoso: It's including options for server in the output?
09:21:29 <dminuoso> merijn: Hard to say since there's no server specific options, but I think so.
09:21:52 <dminuoso> (Its definitely not listing the sync options)
09:22:04 <GreyFaceNoSpace> hello.. i am getting an error "parse error on input ‘%’" when i type : let x = 1 % 2   in to ghci. can anyone tell me why?
09:22:38 <dminuoso> merijn: Ive updated the gist to show the output
09:22:45 <merijn> dminuoso: add a dummy option to server to check?
09:23:14 <dsal> > let x = 1 % 2 in show x -- GreyFaceNoSpace more context?
09:23:16 <lambdabot>  "1 % 2"
09:23:20 <merijn> dminuoso: And the bug is? That it doesn't list help for sync?
09:23:28 <dminuoso> merijn: It doesnt list the available commands.
09:23:44 <merijn> dminuoso: That's because by default missing commands are handled different from --help
09:23:45 <dminuoso> merijn: And yes, its listing the options for server. :)
09:24:02 <GreyFaceNoSpace> dsal, i am trying to use the Rational data type. was just testing whether i can construct a Rational using the syntax documented here: https://wiki.haskell.org/Rational
09:24:10 <GreyFaceNoSpace> dsal, and i am getting this error
09:24:14 <dminuoso> merijn: Can you elaborate?
09:24:15 <merijn> dminuoso: By default missing commands trigger the "missing parse" handler which reports short/abbreviated help, rather than full help
09:24:16 <shryke47> GreyFaceNoSpace: did you import the necessary module?
09:24:25 <merijn> dminuoso: Try running --help instead
09:24:27 <GreyFaceNoSpace> yes, Data.Ratio
09:24:29 <dsal> Even not imported, you won't get a parse error.
09:24:52 <GreyFaceNoSpace> the weird thing is, it worked yesterday. 
09:24:57 <shryke47> Prelude> let x = 1 % 2
09:24:57 <shryke47> <interactive>:2:11: error:
09:24:57 <shryke47>     Variable not in scope: (%) :: Integer -> Integer -> t
09:25:08 <shryke47> no parse errors
09:25:11 <merijn> dminuoso: Presumably you want prefShowHelpOnError or prefShowHelpOnEmpty from https://hackage.haskell.org/package/optparse-applicative-0.15.1.0/docs/Options-Applicative.html#t:ParserPrefs
09:25:11 <dminuoso> merijn: Ah indeed.
09:26:05 <dminuoso> merijn: Perfect! That's what I was looking for, cheers. :)
09:27:16 <dminuoso> merijn: I guess hsubparser would be helpful too.
09:27:36 <dminuoso> Alright, thank you. :)
09:27:44 <GreyFaceNoSpace> sooo...any idea how i can fix that guys?
09:27:46 <dminuoso> optparse-applicative is really lovely. 
09:28:03 <EvanR> GreyFaceNoSpace: try turning it off and on again
09:28:11 <GreyFaceNoSpace> ghci?
09:28:15 <EvanR> yeah
09:28:17 <GreyFaceNoSpace> i did
09:28:29 <GreyFaceNoSpace> same error. not in scope : '%'
09:28:38 <EvanR> that's a different error
09:28:55 <GreyFaceNoSpace> oh
09:28:56 <GreyFaceNoSpace> ok
09:29:00 <GreyFaceNoSpace> sorry didnt notice
09:29:04 <EvanR> so you're making progress
09:29:54 <GreyFaceNoSpace> i guess you can count it as progress
09:30:21 <EvanR> not in scope at least makes sense, and suggests that you didn't import Data.Ratio after all
09:31:16 <GreyFaceNoSpace> sec. i'll paste my code in a pastebin
09:32:13 <kuribas> @hoogle ([a] -> (b, [a])) -> [b]
09:32:13 <lambdabot> No results found
09:32:19 <GreyFaceNoSpace> https://pastebin.com/AJLyC6YK
09:32:28 <GreyFaceNoSpace> maybe something's wrong with my file?
09:32:42 <EvanR> remove let
09:33:02 <GreyFaceNoSpace> why?
09:33:07 <GreyFaceNoSpace> it worked when i removed let
09:33:09 <GreyFaceNoSpace> but why?
09:33:32 <EvanR> let x = foo at the "top level" is ghci only
09:33:42 <EvanR> not allowe in source files
09:33:46 <GreyFaceNoSpace> oh i see
09:34:02 <GreyFaceNoSpace> so in source files i just type the variable name and assign it's value?
09:34:05 <dsal> GreyFaceNoSpace: If you remove the 'let' it'd be OK
09:34:09 <dsal> Also in ghci
09:34:14 <kuribas> :t unfoldr
09:34:15 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
09:34:18 <GreyFaceNoSpace> dsal, yeah. i did and it worked
09:34:43 <EvanR> looking at some existing haskell code would explain a few things by example
09:35:32 <GreyFaceNoSpace> EvanR, normally yes, but haskell has alot of syntactic sugar in comparison to other languages
09:35:45 <GreyFaceNoSpace> so it gets a bit confusing
09:35:52 <EvanR> really...
09:35:52 <dsal> It has less than most languages I've used.
09:35:55 <GreyFaceNoSpace> i did alot of ocaml
09:36:11 <GreyFaceNoSpace> and ocaml has considerably less syntactic sugar
09:36:56 <kuribas> GreyFaceNoSpace: like?
09:36:59 <GreyFaceNoSpace> or maybe i'm just finding it hard to get used to haskell
09:36:59 <dsal> Maybe.  I've not written ocaml in long enough that I don't remember much of it.  I never actually used the OO system.
09:37:13 <kuribas> haskell has a lot of extensions
09:37:48 <GreyFaceNoSpace> just to be clear, i'm not syaing ocaml is better, infact i think haskell is much better which is why i am trying to learn it
09:38:50 <dsal> 'do' is syntactic sugar that can be a little confusing.  Operators can sometimes look like syntax.
09:39:56 <EvanR> if then else
09:40:04 <dsal> Oh yeah.  I don't like that one.
09:40:16 <dsal> I'm wondering if Data.Bool.bool is better.
09:40:42 <EvanR> for higher order functions maybe but
09:40:58 <EvanR> i use case analysis a lot
09:41:11 <dsal> I've not bothered replacing any if/then/else with bool, so I don't seem convinced, anyway.
09:41:24 <rotaerk> my main problem with actually using `bool` is that the parameter order is weird and a reader can misread it
09:41:32 <EvanR> yes
09:41:38 <dsal> It makes sense, but possibly weird.
09:41:48 <dsal> > bool "was false" "was true" True
09:41:51 <lambdabot>  "was true"
09:42:53 <dsal> I kind of like the way agda does it.  i.e., don't bother
09:43:34 <dminuoso> I find that trying to move tests on bools into pattern guards is really neat.
09:44:38 <kuribas> EvanR: if should have been just a function
09:44:55 <kuribas> there is no reason for it to be a construct, other than because other languages have it.
09:45:00 <dsal> That's what 'bool' is, but haskell doesn't have mixfix
09:45:09 <kuribas> :t bool
09:45:10 <lambdabot> a -> a -> Bool -> a
09:45:12 <EvanR> the bool being last in `bool' is fine
09:45:24 <EvanR> but the first two args ...
09:45:33 <EvanR> easy to mix up and there's no way to fix it
09:45:46 <Madderote> Looking for a clever sol to exchange params between front and back using Scotty. Don't want to use TH and QQ too much, just quick and dirty
09:45:52 <EvanR> that being said this function is necessary as being the recursor for Bool
09:45:59 <dminuoso> It's like... does filter remove or keep elements that satisfy its predicate?
09:46:16 <dminuoso> Madderote: What is the frontend written in?
09:46:46 <Madderote> @diminuoso: JS and HTML
09:46:46 <lambdabot> Unknown command, try @list
09:47:22 <EvanR> i'm glad haskell didnt' rename filter
09:48:14 <Madderote> dminuoso: JS and HTML
09:48:15 <EvanR> ruby decided to rename map, filter, fold, 
09:48:56 <kuribas> EvanR: keepIf is nicer than filter
09:49:08 <kuribas> it's to late to rename it
09:49:32 <EvanR> it was preexisting terminology 
09:50:02 <Madderote> dminuoso : JS and HTML - still getting the hang of IRC aoo Stack
09:50:07 <dminuoso> EvanR: Im not convinced filter is the best name.
09:50:07 <dminuoso> map and fold dont have much "its hard to remember it right" to it
09:50:10 <EvanR> bools in general make it hard to remember what is what
09:50:26 <EvanR> problem with bools, not filter's name
09:50:31 <dminuoso> A while ago I had a bug caused by a flipped boolean in an stm guard. The stuck thread took me ages to find.
09:50:44 <dminuoso> i.e. some actual `guard some_expr`
09:50:58 <EvanR> :t mapMaybe
09:51:00 <lambdabot> (a -> Maybe b) -> [a] -> [b]
09:51:00 <dminuoso> EvanR: I think its the same problem, somehow.
09:51:23 <EvanR> now there's no question what it does
09:51:30 <EvanR> beacuse of the type
09:52:55 <EvanR> @index mapMaybe
09:52:55 <lambdabot> Data.Maybe, Data.IntMap.Strict, Data.IntMap.Lazy, Data.IntMap, Data.Map.Strict, Data.Map.Lazy, Data.Map
09:53:05 <dsal> > mapMaybe (\x -> bool Nothing (Just x)) [True, False]
09:53:07 <lambdabot>  error:
09:53:07 <lambdabot>      • Couldn't match expected type ‘Maybe b’
09:53:07 <lambdabot>                    with actual type ‘Bool -> Maybe Bool’
09:53:25 <dsal> > mapMaybe (bool Nothing (Just x)) [True, False]
09:53:27 <lambdabot>  [x]
09:53:42 <dsal> Oh, mapMaybe is filter.
09:53:51 * dsal did have a question as to what it does
09:53:53 <EvanR> yeah it has to be
09:54:01 <EvanR> or well it could also return []
09:54:06 <dsal> I thought it could've returned []
09:54:15 <EvanR> it can but it would be useless
09:54:50 <EvanR> if it ever returns anything but [] it must filter
09:59:00 <dsal> > let filt'r f = mapMaybe (ap (bool Nothing . Just) f)   in   filt'r odd [1..5]
09:59:03 <lambdabot>  [1,3,5]
09:59:20 <dsal> I recreated the problem!
10:00:42 <EvanR> > mapMaybe (\x -> if odd x then Just x else Nothing) [1..5]
10:00:44 <lambdabot>  [1,3,5]
10:01:10 <dsal> I'm trying to practice not using if/then/else to see if I like it.
10:01:43 <jle`> > mapMaybe (mfilter odd . Just) [1..10]
10:01:45 <lambdabot>  [1,3,5,7,9]
10:02:04 <EvanR> nice
10:02:21 <jle`> if/then/else syntax is, i believe, purposefully ugly and unweildy, to try to convince us not to use it if there's a better way
10:02:34 <EvanR> > filter odd [1..10]
10:02:36 <lambdabot>  [1,3,5,7,9]
10:02:45 <EvanR> \o/
10:02:49 <dsal> [1,3 .. 10]
10:02:51 <dsal> > [1,3 .. 10]
10:02:54 <lambdabot>  [1,3,5,7,9]
10:03:05 <dsal> :t mfilter
10:03:07 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
10:03:14 <EvanR> > [1,3..10] :: [Double]
10:03:16 <lambdabot>  [1.0,3.0,5.0,7.0,9.0,11.0]
10:03:18 <jle`> filter is def a bad name/type though, every time other time i use it i wonder if the True is the thing i keep or the thing i throw away
10:03:46 <jle`> dsal: think of it as filter for Maybe
10:04:06 <jle`> ....so i guess that brings us back to square one
10:04:14 <EvanR> yes
10:04:59 <jle`> i basically just replaced the burden of remembering what filter does to the burden of remembering what mfilter does
10:05:25 <EvanR> parity :: (n::N) -> Either (Even n) (Odd n)
10:05:44 <jle`> > partition odd [1..10]
10:05:47 <lambdabot>  ([1,3,5,7,9],[2,4,6,8,10])
10:06:15 <EvanR> the original sin in this situation is odd for using Bool
10:06:46 <jzyamateur> In the repl, how come we are able to print values of type `IO a`, but not of `[IO a]`?
10:07:18 <jle`> jzyamateur: you actually can't print values of type 'IO a', but i can see where it might be confusing
10:07:31 <jle`> jzyamateur: what is actually happening is that ghci is executing the 'IO a', to produce an 'a'
10:07:34 <jle`> and you print the 'a'
10:07:38 <EvanR> % print getLine
10:07:39 <yahb> EvanR: ; <interactive>:121:1: error:; * No instance for (Show (IO String)) arising from a use of `print'; * In the expression: print getLine; In an equation for `it': it = print getLine
10:07:58 <EvanR> % getLine
10:08:03 <yahb> EvanR: [Timed out]
10:08:14 <jle`> jzyamateur: the confusing thing is that the implicit execution-and-print looks the same as printing any other ol' thing
10:08:22 <jle`> and it's invisible to the user
10:08:32 <EvanR> % "any old thing"
10:08:33 <yahb> EvanR: "any old thing"
10:08:36 <EvanR> hmm yeah
10:08:52 <jle`> but yeah, ghci uses some heuristics to determine between "the user probably wants to print this" and "the user probably wants me to execute this and then print the results"
10:08:59 <lyxia> I wonder how wrong things could go if GHC just started traversing things in IO if that allowed it to print something.
10:09:04 <jle`> and the main rule it uses is "is it `IO ???`"
10:09:08 <jzyamateur> what about `[IO a]`? it can print arrays and it can print `IO a`, so was thinking.
10:09:16 <jle`> jzyamateur: it cannot print IO a
10:09:20 <jle`> `IO a` cannot be printed
10:09:24 <jle`> so neither can `[IO a]`
10:09:41 <jle`> lyxia: it'x ghci, not ghc, so it's not super horrible; just exploratory programming things
10:09:55 <jzyamateur> got it, it executed the effects for `IO a` value
10:09:57 <jzyamateur> ?
10:10:01 <jle`> jzyamateur: yeah, and it prints the 'a'
10:10:37 <jle`> ghci uses some heuristics to determine between "the user probably wants me to print this value" vs. "the user probably wants me to execute this value, and then print the results"
10:11:00 <jle`> so for the case of something like an 'Int', ghci things "well they probably want me to print this"
10:11:10 <dsal> :t sequence
10:11:11 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
10:11:17 <dsal> :t let a :: [IO String]; a = undefined in sequence a
10:11:19 <lambdabot> IO [String]
10:11:20 <jle`> and for something like `IO Int`, ghci thinks "they probably don't want me to print this, that would be pretty silly. they probably want me to exectute this and then print the reuslts"
10:11:35 <jzyamateur> got it
10:11:51 <jle`> but yeah, you can turn an '[IO a]' into an 'IO [a]' using a function like sequence
10:12:00 <jle`> or sequence_ :: [IO a] -> IO () if you don't care about the results
10:12:06 <jle`> and then you have something that ghci can execute
10:12:41 <jle`> % sequence [putStrLn "hi"; putStrLn "bye"]
10:12:41 <yahb> jle`: ; <interactive>:2:24: error: parse error on input `;'
10:12:46 <jle`> % sequence [putStrLn "hi", putStrLn "bye"]
10:12:46 <yahb> jle`: hi; bye; [(),()]
10:12:52 <jle`> % sequence_ [putStrLn "hi", putStrLn "bye"]
10:12:52 <yahb> jle`: hi; bye
10:13:01 <jzyamateur> yeah, was working with multiple responses from `wreq` lib requests.
10:13:32 <jle`> ah. yeah, if you have a list of IO responses, those are probably a list of IO actions to produce
10:13:44 <jle`> note that using sequence_ and running the result will execute all of those actions, and so run all of those requests
10:14:19 <jle`> and for normal IO, it will have to run and complte all of those requests, in sequence, before returning any results
10:14:24 <jzyamateur> requests won't be run till we execute sequence,it seems?
10:14:53 <jle`> if the request is the IO action, yeah
10:15:03 <jle`> what you basically have in [IO a] is a list of IO actions
10:15:12 <jle`> "descriptions" of IO you can run, if you wanted to
10:15:30 <jle`> now you can do control flow by picking which one you want to run/execute
10:15:37 <jle`> or use sequence to execute them all
10:15:41 <jzyamateur> all the IO effects are postponed, until they are run from a central entry point IO like called via `main` or `ghci` ?
10:15:59 <jle`> using `myListOfRequests !! 3` will only execute the 3rd item in the list, for instance
10:16:21 <jle`> jzyamateur: i wouldn't really call it 'postponed', that sounds like calling them 'main' triggers something
10:16:30 <jle`> really in normal Haskell, nothing executes IO
10:16:40 <jle`> the only thing you can do is *describe* IO
10:16:49 <jle`> by using descriptions of type 'IO a'
10:17:09 <jle`> if you name something main, then the ghc compiler takes the IO action that main describes and turns it into the bytecode that it represents
10:17:28 <jle`> and then you can run that executable
10:17:52 <jzyamateur> got it
10:17:59 <EvanR> a value of type IO a is like a piece of paper that says "attack at dawn"
10:18:06 <jle`> in the case of ghci, IO actions are also just descriptions, but if you give ghci a 'naked' IO action, it will trigger the runtime into executing the effects it des ribes
10:18:18 <EvanR> it's not anyone waiting to attack or an attack in progress, just data
10:18:59 <EvanR> which is why you have them in a list
10:19:16 <jle`> one nice thing about having [IO a], a list of IO actions, is that you can make decisions about 'which one' you want to execute or how you want to combine them, without executing them prematurely
10:19:49 <jle`> so you can do things like, only run the third one (myList !! 3), 'do them all in order', `seqeuce myList`, 'do them concurrently', `sequenceConcurrently myList`
10:20:09 <jle`> the only thing that matters is that final IO action you end up creating and executing
10:20:19 <DeefCry> :-D
10:20:25 <jzyamateur> oh, nice
10:20:25 <jle`> and you can construct that final IO action however way you want, with a lot of attention to detail
10:20:40 <jle`> a lot of detailed/fine tuned options, i mean
10:21:40 <dsal> :t mapConcurrently
10:21:42 <lambdabot> error: Variable not in scope: mapConcurrently
10:23:29 <jle`> i think that doesn't exist in base, but it's easy enough to define using combinators in Control.Exception
10:23:39 <jle`> er, Control.Concurrent
10:23:48 <jle`> it's defined in async i believe
10:24:07 <dsal> Yeah, I use mapConcurrently a lot.
10:24:43 <jzyamateur> also do you read `ab :: IO String` as a description of an effect, which when run (usually forced by another/parent IO execution) would produce a string?
10:25:21 <EvanR> yes!
10:53:12 * hackage context-free-art 0.3.0.1 - Generate art from context-free grammars  https://hackage.haskell.org/package/context-free-art-0.3.0.1 (414owen)
11:10:12 * hackage net-mqtt 0.6.1.1 - An MQTT Protocol Implementation.  https://hackage.haskell.org/package/net-mqtt-0.6.1.1 (dustin)
11:46:40 <siraben> I'm having trouble completing the Applicative instance for the free monad; http://ix.io/2091
11:47:04 <siraben> Any suggestions?
11:49:40 <jzyamateur> Had question about `sequence` behavior as seen in comment for the last expression in https://gist.github.com/chetnashah/1b929e4551571d8c0827fdc513c1dc8c
11:50:10 <jzyamateur> Does `sequence` also do some kind of folding behind the scenes?
11:50:34 <dminuoso> jzyamateur: sequence = traverse id
11:50:54 <lyxia> siraben: have you tried hole-directed programming https://reasonablypolymorphic.com/blog/typeholes/
11:51:12 <dminuoso> While you could implement one in terms of the other, I think `traverse` shows the fundamental nature of it better.
11:51:27 <siraben> lyxia:  what's what I'm trying to do
11:51:31 <dminuoso> jzyamateur: And, concretely, the behavior you are looking for comes from the Applicative instance of Const (which is the same as Constant)
11:51:43 <siraben> So, "Impure _" so far,
11:51:53 <dminuoso> jzyamateur: If you try and implement an Applicative instance for `Const a`, it might be a good way to understand it. :)
11:52:05 <jzyamateur> still, My understanding till now has been of switching context of applicative/foldable when using `sequence`/`traverse`.
11:52:21 <siraben> lyxia: It's possible to define the applicative instance without making an Applicative constraint right?
11:52:26 <jzyamateur> yeah I'll look into the Applicative instance for `Const`
11:52:29 <MarcelineVQ> siraben: your _ hole is  f (Term f b)    we have    fx : f (Term f (a -> b))     a : Term f a    and f is Functor, so I'd be inclined to try fmapping into fx to get started
11:52:29 <lyxia> siraben: right
11:52:34 <dmwit> jzyamateur: No, sequence doesn't do folding. But the Applicative instance for Const does folding.
11:52:40 <monochrom> siraben: Consider "Pure f <*> eh = ???" and "Impure fx <*> eh = ???" and not care what "eh" is, instead let fmap worry about it.
11:52:43 <dminuoso> jzyamateur: traverse basically "traverses" along some structure, maps each element it finds to some effect and then sequences those effects.
11:52:58 <dminuoso> % :t traverse
11:52:59 <yahb> dminuoso: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
11:53:08 <dminuoso> % :t traverse @[] @IO
11:53:08 <yahb> dminuoso: (a -> IO b) -> [a] -> IO [b]
11:53:15 <dmwit> jzyamateur: Also: instead of `sequenceA $ fmap f xs`, consider `traverse f xs`. It does the same thing, but is gentler on the garbage-collector.
11:53:34 <siraben> Hm, ok.
11:53:35 <jzyamateur> cool, got it thanks.
11:55:40 <jzyamateur> i have noticed usage of `mappend`/monoid restriction in applicative instances with more than one typevars.
11:55:54 <dmwit> Just coincidence.
11:56:13 <dmwit> There are many Applicative instances of multi-argument types which do not need it.
11:56:45 <jzyamateur> Hmmm
11:57:01 <siraben> lyxia:  I'm trying (_ fx a), now I have to produce a function of type "f (Term f (a -> b)) -> Term f a -> f (Term f b)"
11:57:07 <dmwit> Stupid human brain wants to find patterns everywhere, even if there is not one there.
11:57:37 <siraben> Somehow I need to fmap into fx to get it to Term f b, then transform it to f (Term f b)
11:57:54 <siraben> fmap into a*
11:58:06 <dmwit> siraben: Luckily, you have (<*>) :: Term f (a -> b) -> Term f a -> Term f b, right? ;-)
11:58:58 <siraben> dmwit:  Ah, interesting.
12:01:26 <MarcelineVQ> siraben: you can make holes work for you, attack parts of the problem instead of the entire signature.    Impure _hole   "hmm, I have a _hole of f (Term f b), the only thing I have that starts with f is  fx :: f (Term f (a -> b)), what hole do I get if I use that to start with?"   Impure $ fmap _hole fx
12:03:59 <siraben> MarcelineVQ:  (Impure fx) <*> a = Impure $ fmap (<*> a) fx
12:03:59 <siraben> Phew.
12:04:04 <MarcelineVQ> gj
12:05:03 <MarcelineVQ> The new hole having a type of   _hole ::​ Term f (a -> b) -> Term f b   hopefully made it easier to see the parts of the puzzle you needed to fit together
12:05:06 <siraben> Onto the rest of Swierstra's paper "Data types à la carte!"
12:05:28 <siraben> He only makes a monad and functor instance, but not of applicative
12:05:50 <siraben> Right, so with typed hole-directed programming, how would I know when to do something like "Ah, I need to fmap _ fx"
12:07:21 <MarcelineVQ> "I have a goal of  f (Term f b), the pieces I have to work with are   fx :: f (Term f (a -> b)  and   a :: Term f a   Since I know that f is Functor I'm allowed to use fmap on f, since I have something that starts with an f and so does my goal, I should prefer to use that first.
12:07:37 <siraben> Seems like it requires some sort of foresight
12:07:45 <siraben> I see.
12:09:27 <MarcelineVQ> It's not something immediately obvious but you start to see it more and more. Actually I asked a very similar question in here recently iirc
12:11:39 <siraben> MarcelineVQ:  Is it possible to rewrite the Applicative instance here without the monad constraint? http://ix.io/209d
12:11:57 <wroathe> The rabbit hole for newtypes and Arbitrary instances goes very very deep
12:13:24 <siraben> Felt like cheating a little to define (<*>) in terms of (>>=)
12:14:40 <MarcelineVQ> is Exc like Either?
12:15:43 <siraben> MarcelineVQ:  data Exc e a = Raise e | Ok a
12:16:58 <siraben> So, like Either yeah
12:17:56 <MarcelineVQ> yes it's possible
12:18:43 <dminuoso> Is there some simple quasiquoter to get some rudimentary templating with Text?
12:18:50 <siraben> "mf <*> ma = ExceptT $ (_ (runExceptT mf)) (runExceptT ma)", the hole is now _ :: f (Exc e (a -> b)) -> f (Exc e a) -> f (Exc e b)
12:19:06 <dminuoso> I dont need anything fancy, just basic "interpolate some text variable here"
12:19:52 <MarcelineVQ> siraben: What do we know about f?
12:20:51 <siraben> It's an Applicative, so we can use <*>
12:20:59 <MarcelineVQ> let's start there then
12:21:05 <siraben> "mf <*> ma = ExceptT $ (_ (runExceptT mf)) <*> (runExceptT ma)", now _ :: f (Exc e (a -> b)) -> f (Exc e a -> Exc e b)
12:27:43 <MarcelineVQ> yeah that's a bit harder to see the pattern, so I'd start by writing  ExceptT r <*> ExceptT x = ExceptT $ _foo
12:28:42 <MarcelineVQ> this lets you see r and x more plainly in your hole's context, or  mf and ma w/e you like, I​ happened to call them r and x
12:29:26 <siraben> MarcelineVQ:  mf <*> ma = ExceptT $ (fmap (<*>) (runExceptT mf)) <*> (runExceptT ma)
12:31:05 <MarcelineVQ> good job, I'd move to using liftA2 to clean things up a bit, and in fact I tend to start with it, when​ I see  r :: m (Either e (a -> b))    x :: m (Either e a)   where m is Applicative, I automatically write liftA2 _hole r x   and see what it suggests to combine them
12:31:12 <MarcelineVQ> @src liftA2
12:31:13 <lambdabot> liftA2 f a b = f <$> a <*> b
12:36:11 * hackage data-dword 0.3.1.3 - Stick two binary words together to get a bigger one  https://hackage.haskell.org/package/data-dword-0.3.1.3 (MikhailVorozhtsov)
12:37:23 <siraben> MarcelineVQ:  mf <*> ma = ExceptT $ liftA2 (<*>) (runExceptT mf) (runExceptT ma)
12:37:31 <siraben> I'm not terribly familiar with when to use liftA2.
12:38:08 <siraben> Or even (<*>), for that matter.
12:38:54 <siraben> As it can be expressed with do-notation.
12:40:02 <texasmynsted> So reading this --> https://wiki.haskell.org/Let_vs._Where , It looks to me like I should be preferring to use `let` unless `where` is vastly more readable. Is that fair?
12:42:19 <merijn> texasmynsted: I would say "where" always unless not possible
12:42:52 <merijn> let/in looks ugly, is hard to format nicely
12:42:59 <texasmynsted> Also anybody here use HIE (Haskell Language Server) on vscode and know how hlint is supposed to work? I never get hlint messages unless I manually use hlint from command line.
12:43:39 <texasmynsted> merijn: Yes, that is true. Hmm
12:44:56 <wroathe> texasmynsted: You'll want to read the vscode HIE documentation on enabling log output and it should report errors if vscode can't find hlint in your path or something like that
12:45:20 <texasmynsted> oh okay I did not see that in the docs I will try that.
12:46:45 <MarcelineVQ> siraben: liftA2 f x y is, to me, combine x and y using f. so if I have some x :: m a, y :: m b, liftA2 _foo x y  tells me what f I need to write to combine them
12:49:31 <dsal> > liftA2 (,) (Just 1) (Just 2)
12:49:32 <lambdabot>  Just (1,2)
12:49:50 <dsal> I use it to clean up that sort of thing in parsers a lot.
12:49:57 <siraben> MarcelineVQ:  I see.
12:50:55 <siraben> I get an error: "Could not deduce (f :<: g0) from the context: (f :<: g, g :<: h)" http://ix.io/209v when I try to make an instance "instance (f :<: g, g :<: h) => f :<: h where"
12:51:08 <siraben> What could be causing the ambiguous type?
12:55:00 <siraben> foo :: (f :<: g, g :<: h) => f a -> h a
12:55:00 <siraben> foo = inj . inj
12:55:00 * jgt is grateful for GHC 8.6.*, as he writes many dodgy pattern matches which no longer compile
12:55:27 <siraben> This should be valid, but Haskell complains and wants me to enable AllowAmbiguousTypes
12:56:14 <texasmynsted> wroathe: I turned on tracing but that is all I could find.
13:00:24 <jackdk> siraben: how do you propose GHC infers which fits in between?
13:01:26 <wroathe> texasmynsted: https://github.com/alanz/vscode-hie-server/search?q=log&unscoped_q=log
13:02:23 <texasmynsted> Oh interesting. So edit the shell script. I did not see anything in the docs but I can surely alter the shell script. Thank you.
13:02:24 <wroathe> texasmynsted: If you read the code there you'll see that it's passing along the right flags at startup to enable server logging, and writing output to a temporary log file. You'll need to track that down
13:02:37 <wroathe> texasmynsted: No, the settings should get you what you need
13:03:00 <wroathe> https://github.com/alanz/vscode-hie-server/blob/2f304a6b8d5832d5c019ba90fde29867295e7513/src/extension.ts#L143-L154
13:04:43 <siraben> jackdk:  Does g not fit in between?
13:05:54 <merijn> siraben: How does GHC know what 'g' is?
13:06:35 <siraben> Some other type constructor, right?
13:07:00 <siraben> It knows that f :<: g, so I can get from f a to g a via inj, and g :<: h, so I can get from g a -> h a via inj as well
13:07:05 <merijn> siraben: It's ambiguous which one, GHC won't just randomly pick one
13:07:10 <siraben> So it follows that inj . inj :: f a -> h a
13:07:13 <merijn> siraben: Hence, ambiguous type error
13:07:42 <merijn> siraben: 'g' appears nowhere in that type, so GHC can't infer it
13:07:47 <siraben> Hm, so there's no "f :<: g, for some g"?
13:07:58 <merijn> No
13:07:59 <siraben> I see.
13:08:54 <siraben> I was beginning to read 'instance p => q'  as logical propositions.
13:13:03 <edmundnoble> The only issue with that view is that type class instances have content
13:13:10 <edmundnoble> Unlike logical propositions
13:15:11 * hackage minio-hs 1.5.1 - A MinIO Haskell Library for Amazon S3 compatible cloudstorage.  https://hackage.haskell.org/package/minio-hs-1.5.1 (MinioDevTeam)
13:16:12 * hackage schemas 0.3.0.2 - schema guided serialization  https://hackage.haskell.org/package/schemas-0.3.0.2 (PepeIborra)
13:31:12 * hackage shake-ats 1.10.3.0 - Utilities for building ATS projects with shake  https://hackage.haskell.org/package/shake-ats-1.10.3.0 (vmchale)
13:41:19 * texasmynsted shrug
13:41:41 <texasmynsted> wroathe did this work for you?
14:01:36 <hololeap> i've been slowly exploring the singletons library and i've noticed the plethora of type family "functions" available, but i don't understand the point of (~>) instead of a regular (->)
14:09:24 <hololeap> also, are higher-level type functions not possible in haskell? for instance, if you have a type family PlusOne that can (+1) to a Nat, and a type family Map (f :: a -> b) (x :: a) :: b, can you combine them?
14:09:56 <geekosaur> it's kinda lifted (->). and no, there's lots of things you can't do in Haskell as yet, which is why singletons exists
14:09:58 <hololeap> sorry that would actually be: Map (f :: a -> b) (xs :: [a]) :: [b]
14:10:42 <hololeap> geekosaur: can you explain what you mean by "kinda lifted"? one thing i've been disappointed with the singletons library is the documentation
14:11:57 <geekosaur> https://blog.jle.im/entry/introduction-to-singletons-1.html might be the best documentation available as to why; it's the first part of a multipart explanation of why singletons and what you can do with it that you can't do in standard Haskell
14:12:39 <geekosaur> there's ongoing work on Dependent Haskell but it won't be coming quite as soon as hinted at the top of that post
14:12:49 <hololeap> i've been through the first two parts of that. i haven't explored the third yet. (actually i may not have finished the second.) does it explain (~>) ?
14:13:17 <geekosaur> it should
14:13:32 <hololeap> ok, then i just need to take the time to finish it
14:15:41 <hololeap> i wanted to zip a [Bool] with a [k] and then filter using the Bool values using the type families they provide, but i realized there wasn't a good way to combine them. i was hoping (~>) might be a way to provide this
14:16:40 <hololeap> not that it's that hard to write my own custom type families, but code reuse would be nice
14:17:12 <geekosaur> gm, I stand corrected, don't see it in there.
14:17:42 <hololeap> gm?
14:18:31 <dmwit> Standard functional programming with type families is coming soon, hopefully. In the meantime there's defunctionalization.
14:18:45 <geekosaur> "hm"
14:18:49 * geekosaur typoes a lot
14:18:59 <hololeap> oh, no worries :D
14:19:09 <hololeap> i'm always ready to learn new lingo
14:19:26 <dmwit> https://hackage.haskell.org/package/first-class-families
14:19:28 <geekosaur> I think it's in the original paper but it's using fancy arrows instead of ASCII versions…
14:20:40 <geekosaur> https://cs.brynmawr.edu/~rae/papers/2012/singletons/paper.pdf (you'll get a cert error because brynmawr's cert expired 8 days ago, whoops)
14:20:52 <hololeap> i'll be honest, the papers i've tried to read are difficult for me to parse because they tend to lean heavily toward "general" functional programming, whereas haskell is the only thing i know in that area
14:21:38 <geekosaur> this one is Haskell based, but "fancy Haskell" with → arrows and such
14:22:59 <hololeap> dmwit: i've heard the term before and tried to explore some blog posts, but can you explain what you mean by that and how it would help?
14:23:15 <maralorn> Is there some place where I can drop praise for Haskell? There are some many projects/people/processes that I think are awesome. And I wanna tell people that, but I don‘t want to open an issue in their project for that.^^
14:23:42 <dmwit> hololeap: Everything I know is at the link I posted.
14:23:52 <hololeap> ok
14:24:54 <jle`> a thousand generations live in you now
14:30:34 <dsal> maralorn: you can do that here.  Anyone sharing stuff and not lurking in IRC will just miss out.
14:30:45 <siraben> What is https://github.com/polysemy-research/polysemy based on?
14:30:47 <lyxia> hololeap: well defunctionalization is exactly the word at the origin of (~>) https://typesandkinds.wordpress.com/2013/04/01/defunctionalization-for-the-win/
14:30:52 <siraben> Extensible Effects?
14:35:16 <siraben> Ah looks like isovector has a blog post on the internals; https://reasonablypolymorphic.com/blog/freer-higher-order-effects/
14:38:48 <hololeap> lyxia: sweet. thanks everyone
14:39:21 <sm[m]> maralorn: also, twitter ? haskell reddit ?
14:44:49 <hololeap> jle`: who exactly were you addressing with that? :)
14:45:26 <jle`> hololeap: you :) sorry, it was star wars trailer reference heh
14:46:20 <hololeap> lol. i'm super confused by what you mean, but i also haven't seen that
14:48:08 <nshepperd2> I guess rey becomes the kwisatz haderach in the next star wars
14:50:28 <maralorn> Is System.Process the recommended way to call processes?
14:51:27 <maralorn> I am using `withCreateProcess (proc "cmd" []) $ \stdin _ _ _ ->` and get a Nothing as stdin.
14:53:47 <nshepperd2> maralorn: i think you need to set some sort of option to get a stdin handle
14:53:51 <hololeap> maralorn: i usually use `readProcess` since that provides all the functionality i need. it passes a string to stdin
14:56:04 <maralorn> hololeap: Oh, thanks. I oversaw that.
14:56:22 <hololeap> no problemo
15:00:06 <jle`> hololeap: the implication was that dmwit has passed on all he knows, so now it is up to you to continue the tradition
15:01:58 <maralorn> Is it a bad idea to use show for ByteString -> String?
15:02:01 <hololeap> oh nice i get it now
15:03:40 <maralorn> @hoogle ByteString -> String
15:03:41 <lambdabot> Control.Lens.Internal.ByteString unpackStrict8 :: ByteString -> String
15:03:41 <lambdabot> Control.Lens.Internal.ByteString unpackLazy8 :: ByteString -> String
15:03:41 <lambdabot> Data.ByteString.Lazy.UTF8 toString :: ByteString -> String
15:04:36 <hololeap> maralorn: you probably want to use Data.Text.Encoding.streamDecodeUtf8 from the text package.
15:05:02 <maralorn> hololeap: Yeah, but readProcess takes a String. :-(
15:06:34 <jle`> maralorn: it depends on what you want to do
15:06:42 <hololeap> text <-> string isn't hard
15:06:58 <jle`> 'show' will give you basically debugging display for the contents of the bytestring
15:07:05 <jle`> kind of like hexdump
15:07:17 <jle`> so it's not a bad idea if you want to implement something like hexdump
15:07:24 <jle`> inspect a binary blob
15:08:04 <hololeap> there should be a way to pass a ByteString to a process
15:09:17 <jle`> maralorn: it's a bad idea if your binary blob bytestring represents text
15:10:37 <hololeap> maralorn: if you want to pass a ByteString in directly, there is this from the conduit-extra package: https://hackage.haskell.org/package/conduit-extra-1.3.4/docs/Data-Conduit-Process.html#v:sourceCmdWithStreams
15:11:15 <hololeap> that, of course, requires an understanding of the conduit library
15:18:15 <maralorn> hololeap: Seems as a little overkill to pull in a conduit dependency just for one command.
15:18:21 <maralorn> But thanks anyways.
15:20:01 <maralorn> Is there somewhere a tutorial for releasing libraries on hackage?
15:20:34 <hololeap> conduit is pretty useful imo. the tutorial on github is good quality. but i understand if it seems like overkill
15:21:06 <nshepperd2> you can use withCreateProcess (proc "cmd" [] { std_in = CreatePipe }) and write to the handle
15:21:29 <nshepperd2> with ByteString functions
15:21:59 <maralorn> nshepperd2: Aaah
15:29:01 <hololeap> nshepperd1: that's a good call
15:29:12 <hololeap> *good catch
15:33:25 <hololeap> so, what's the bottom line with why lazy IO is bad? is it because it can create calls in an unusual order?
15:36:04 <jle`> it's not necessarily bad, just unpredictable except in the simplest of cases
15:36:19 <jle`> you can't really predict or control when handles close and open and stuff like that
15:36:23 <jle`> and when IO calls actually happen
15:36:48 <hololeap> ok, that makes sense
15:37:17 <jle`> so it's perfectly fine in simple situations as black magic, but if you want to do anything non-trivial with file streaming, it's good to switch to a system where you can make guarantees about handles closing and opening
15:38:42 <jle`> lazy IO is essentially a very limited form of unsafePerformIO...it sort of breaks how you expect haskell execution/evaluation to work, in order to simplify some certain situations
15:39:36 <hololeap> that's essentially what i was getting at. i did read someone saying that it isn't so bad if you treat it as you would for a concurrent system.
15:41:02 <zeta_0> hello guys, in emacs i enabled flycheck globally but for some reason when i i open a haskell program and haskell-ide-engine activates it defaults to flymake, i think this may be what is slowing things down, so why is this and how do i fix it ?
15:41:06 <unfixpoint> Say I have `data Expr a = Id a | Not (Expr a)`, and I have a parser that parses a list of these guaranteeing the simplification `Not (Not a) -> a`. Now what would be an elegant way to transform a list of these `[Expr a]` into `([a], [a])` where one contains the `Id a` and the other the `Not a` ones?
15:41:44 <unfixpoint> It's simple to just do `partition (\case Not _ -> True; _ -> False)` and then walk over each list, unpacking the elements. But is there a nicer way?
15:42:07 <jle`> unfixpoint: how about mapEither?
15:42:08 <novum> hello, lovely haskellers. we need to use C code in haskell. So, we have been looking into FFI (foreign function interface). I have written some C code to understand how libalpm works, and it requires storing some C pointers for a few different struct instances (like a alpm_db_t* pointer) in haskell and such. However, we don't want to have to link in all of the code into one big binary.
15:42:10 <novum> /usr/include/alpm.h exists (what we import in C) and /usr/lib/libalpm.so (a shared library) also exists. So, do we need to (a) make a wrapper C program that can import eveything from alpm and create some functions that we need or (b) can we just use alpm via FFI without compiling any C in?
15:42:11 <unfixpoint> Possibly only using `deriving` mechanism and `base` functions?
15:42:45 <jle`> er, partitionEithers i suppose
15:42:50 <jle`> it's a non-blind version of partition
15:44:56 <unfixpoint> jle`: Yes, this is what I look for! But I will need to move them to an `Either _ _` first, however I don't think it's possible w/o that 
15:45:20 <unfixpoint> (it's essentially the unpacking step from the other way)
15:46:16 <jle`> yeah, the difference is that you don't 'throw away information'
15:46:22 <jle`> so your unpacking is 'safe'
15:46:32 <jle`> whereas in the partition way, it's unsafe: you could accidentally return True when it should be False
15:46:40 <jle`> and your later unpacking would ignore that
15:47:16 <unfixpoint> Yeah, that's the thing that annoyed me earlier. It was obvious, no exception will but still
15:47:25 <unfixpoint> Cheers!
15:47:34 <jle`> np :)
15:53:24 <maralorn> Well talking about unpredictable lazy IO. The std_in solution doesn‘t do anything.
15:53:55 <maralorn> I can‘t even tell if the process is being called or not, but it doesn seem to have any effect.
15:54:44 <maralorn> I mean probably I did something wrong, but the std_out stuff works …
15:56:25 <lyxia> the problem with lazy IO is that many might not realize its limitations without someone telling them, and either way unless they take the time to investigate what's going on, what they get away from it is that "laziness is bad".
15:56:51 <maralorn> Its not very minimal but this is the code, which doesn‘t seem to have an effect: https://termbin.com/royy
15:57:02 <maralorn> Maybe I need to flush a handle or something?
15:57:03 <lyxia> That would be less of a problem if it weren't part of the standard library and there were big red banners to warn people.
15:57:55 <maralorn> (The last line in there is only for debugging.)
15:58:46 <hololeap> unfixpoint: you could just convert Expr to Either in the function that needs it, or write a helper function, instead of switching to something that uses Either explicitly.
15:59:19 <lyxia> maralorn: hPut most likely buffers
16:01:40 <hololeap> i've often thought that there should be typeclasses that convert to Either and Maybe, because it also tells a lot about the structure of the type
16:03:53 <jle`> hololeap: what instances would that class have?
16:03:56 <jle`> or what methods
16:04:25 <zeta_0> does anyone here know the release dates of the books: `haskell from first principles` and `haskell almanac` ?
16:05:37 <hololeap> ideally it would be something like class IsEither t a b => toEither :: t -> Either a b
16:06:12 <hololeap> and maybe some voodoo to derive for sum types with exactly two parts
16:06:12 <c_wraith> that would need some fundeps
16:06:31 <unfixpoint> hololeap: Converting from Either to Maybe yeah. But the other way around we'd need to specify what Left would be
16:06:31 <EvanR> probably better to just use Either in the first place
16:06:40 <jle`> i don't think it makes too much sense as a typeclass because there might not necessarily be one 'canonical' split of a type into a sum
16:06:48 <hololeap> unfixpoint: Left would be ()
16:07:07 <jle`> it makes sense to provide those as just normal non-typeclass functions
16:07:08 <unfixpoint> So `maybe (Left ()) Right`?
16:07:09 <jle`> like what prisms do
16:07:27 <hololeap> Maybe a -> Either () a
16:08:05 <EvanR> there's a package with utility functions for maybe to either and back
16:10:39 <hololeap> the primary use-cases would be 1) to do what unfixpoint wanted and easily derive instances to use with Either(/Maybe) functions if the type is isomorphic to them, and 2) give some guarantees about the structure of the type
16:11:59 <EvanR> not sold that this is generally applicable
16:12:03 <hololeap> point 2 would be more useful in the case of IsMaybe, where you are guaranteed to have some sort of constructor that is empty e.g. isomorphic to Nothing
16:12:24 <EvanR> or that isomorphic to Nothing is well defined
16:12:24 <jle`> hololeap: it seems rare that your type is going to always be *exactly* one of two cannoical splits
16:12:39 <jle`> hololeap: even in unfixpoint's situation, if they ever add another constructor, this becomes useless
16:12:48 <jle`> or at least, no longer canonical
16:12:59 <hololeap> i've made many custom data types that had one empty constructor
16:13:13 <hololeap> and the Just would be in line with pure
16:13:16 <jle`> exactly one empty constructor, and one single-value constructor?
16:13:27 <EvanR> instead of using Maybe? 
16:14:01 <novum> I presume we just use  gcc -lalpm theprogram.hs
16:14:29 <novum> I mean ghc -lalpm
16:14:58 <jle`> novum: what is your goal?
16:15:17 <novum> to use FFI to acquire alpm functionality in haskell
16:15:30 <novum> alpm being a C library
16:17:58 <unfixpoint> Btw. my type wasn't isomorph to `Either` at all, the `Not _` constructor was recursive.. but yeah if my type changed it would have been a mess
16:18:35 <hololeap> instance IsMaybe BTree (BTree a, a, BTree a) where toMaybe t = (case t of ; BBranch (bt1) x (bt2) -> Just (bt1, x, bt2) ; BLeaf -> Nothing)
16:18:39 <unfixpoint> Imo my mistake *was* that I used a non-isomorphic to `Either` type, I moved it towards `Either` completely as it's much cleaner now
16:19:21 <unfixpoint> Ie. the parser directely goes `Either X X` and then I can use elegantly use `partitionEither`, no mess anymore
16:19:53 <hololeap> that's one example off the top of my head. it doesn't seem particularily useful at first, but sometimes you want to be able to check if a functor is at its "end"
16:20:06 <jle`> yeah, this isn't 'isomorphic' -- it means that you can project into either
16:20:16 <jle`> projecting into either makes sense as a function, since there is often more than one way you can do it
16:20:36 <hololeap> that particular example *is* isomorphic
16:20:48 <jle`> ah sorry, i was referring to unfixpoint's example
16:21:09 <jle`> that sounds like more of an uncons kind of class
16:21:15 <jle`> like in monotraversable
16:21:32 <hololeap> i was just saying that you could derive it if it was isomorphic. otherwise there would be the option of defining it yourself
16:21:53 <jle`> my point is that there is more than one way to meaningfully project into an Either
16:21:57 <jle`> in most cases
16:22:13 <hololeap> yeah, i don't have as many good examples for that one
16:22:16 <jle`> so having a canonical 'projection to either' class is sort of out of the scope of what typeclasses would normally be used for
16:22:30 <jle`> but a class for things that can be "unconsed" would make sense for a typeclass
16:22:50 <jle`> class Uncons f where uncons :: f a -> Maybe (a, f a), or something like that
16:23:08 <jle`> where you provide more semantics to limit what the function could 'mean'
16:26:14 <hololeap> i suppose my whole motivation for this is because i have been playing around with going over multiple recursive data structures at once, and i realized that for finite structures you need to know when one ends if the other is still continuing
16:26:43 <hololeap> i admit it's a pretty limited use case
16:27:20 <jle`> it can be worth it in that specific domain if there are abstractions you can build with that typeclass that you couldn't build without it
16:27:28 <maralorn> Wow, that‘s annoying as hell. I can fix my code by putting a small threadDelay at the end of my withCreateProcess handler.
16:27:36 <jle`> ie Map justifies Ord
16:27:42 <jle`> well, Map and sort
16:27:45 <jle`> and lots of other things :)
16:27:47 <maralorn> How can I do that in proper?
16:28:01 <jle`> maralorn: maybe look at the source of readProcess
16:28:07 <jle`> to see what they do to make sure things work correctly
16:28:21 <jle`> did lyxia's suggestion of manual flushing help, btw?
16:29:13 <hololeap> jle`: i have played around with different implementations, but ideally it would be nice if a particular functor told me that it was at a state that does not recurse
16:29:56 <novum> jle`, do you know of said -l flag to ghc?
16:30:07 <jle`> novum: i'm not too familiar with ffi, sorry :|
16:30:20 <jle`> hololeap: hm, you can do something like that with uniplate type methods
16:30:26 * novum kicks a can down the road. no problem. thanks
16:30:40 <jle`> plate methods can give you things like allRecursiveChildren :: MyType -> [MyType]
16:30:59 <maralorn> jle`: I think the problem was the whole time that I killed my process prematurely.
16:31:01 <jle`> "uniplate-type" methods
16:31:10 <jle`> maralorn: ah yeah, forking can do that
16:31:23 <maralorn> jle`: I think using waitForProcess is the way to go.
16:31:29 <jle`> one common trick to make sure your threads stay alive long enough is to use an mvar/semaphore to wait on a thread to complete
16:31:32 <jle`> ah, there's that too
16:32:58 <jle`> hololeap: in the unpliate library, it's children :: Uniplate on => on -> [on]
16:33:04 <jle`> so children [1,2,3] => [2,3]
16:33:37 <jle`> children (Add (Lit 1) (Mul (Lit 2) (Lit 3)) => [Lit 1, Mul (Lit 2, Lit 3)]
16:34:36 <jle`> children (Lit 1) => []
16:35:49 <novum> maybe you can help with this, however. import Network.HTTP => Could not find module ‘Network.HTTP’
16:36:02 <novum> cabal install network; cabal install HTTP => same error
16:36:30 <jle`> novum: hm, are you writing a cabal/stack project?
16:37:05 <jle`> you would need to add whatever package provides Network.HTTP to your cabal file
16:37:08 <jle`> or package.yaml
16:37:09 <novum> nope. I just did  vim foo.hs
16:37:17 <novum> just a test program
16:37:22 <hololeap> eek! lens!
16:37:54 <jle`> hololeap: uniplate itself doesn't really do anything wiht lens, but lens offers its own re-export of it i think
16:37:55 <maralorn> jle`: Hm, so a ByteString version of readProcess would have been very helpful …
16:38:16 <maralorn> Hm, didn‘t mean to highlight you, sorry.^^
16:38:26 <jle`> novum: ah, yeah, to write anything with dependencies the reasonable way to go is usually to be inside a project
16:38:44 <jle`> novum: well, if you want a test file, you can actually use stack scripts
16:38:49 <jle`> (this is what i do for my test files)
16:38:50 <novum> but I no want no damn project fine whatever grumble anger ire sadness frustration
16:39:03 <maralorn> Now it works, but just so that I don‘t have to convert to Bytestring and back I got about 10 lines of boilerplate for handling my process.
16:39:14 <jle`> novum: you can add a little bang thing at the top of your file and stack will handle all the deps
16:39:31 <novum> I want this
16:39:37 <novum> show me de way
16:39:42 <jle`> novum: actually this blog post uses the exact library you are talking about 
16:39:44 <jle`> https://tech.fpcomplete.com/haskell/tutorial/stack-script
16:40:57 <jle`> but yeah at the top of your file you would write:
16:41:07 <jle`> #!/usr/bin/env stack
16:41:21 <jle`> -- stack --package HTTP runghc
16:41:36 <jle`> and then you can run your script as an executable, `./myscript.hs`
16:47:59 <novum> eh jle` that says Invalid option `--package'
16:48:39 <novum> but moving runghc before --package fix
16:48:42 <jle`> novum: ah hm, try -- stack runghc --package HTTP
16:48:56 <jle`> oh yeah heh. that's kind of wierd
16:50:14 <novum> now I have  get url = simpleHTTP (getRequest url) >>= getResponseBody  and I want to take the response body and parse it as json. But first, I want to just print it out. I suck so much at haskell, that I have much sadness.
16:50:28 <novum> please help me have less sadness
16:50:35 <jackdk> % :kind (=>)
16:50:36 <yahb> jackdk: ; <interactive>:1:2: error: parse error on input `=>'
16:50:43 <novum> jle`, foremost, though thank you very much <3
16:51:26 <jackdk> I would have expected it to be kinded Constraint -> Type -> Type. is it special syntax still?
16:57:41 <jle`> jackdk: yes
16:57:47 <jle`> well, (->) is also special syntax
16:58:22 <jle`> hm, i feel like ther ewas a good reason, but i can't remember it at th moment
16:59:41 <jle`> novum: np!
17:00:07 <novum> I read the thing you link. it help. I must leave now, too. Good bye. Thank you
17:02:38 <jle`> happy haskelling
17:20:28 <maralorn> I am wondering: There are so many functions which one sometimes needs for String, Text, ByteString in Lazy or Strict. Wouldn‘t it be usefull to abstract them over a typeclass?
17:21:12 <maralorn> I could just copy and paste read
17:21:54 <maralorn> ... readProcess to change it from String to ByteString because the functions used are actually called the same …
17:22:43 <dmwit> Maybe you should make a package with a class and some instances!
17:24:50 <int-e> you could also look at existing packages like https://hackage.haskell.org/package/string-class (no endorsement, I was just wondering whether people have done this)
17:25:56 <nil> are there any (performance?) differences between `f x = foo (f x)` and `f x = let y = foo y in y` ?
17:26:07 <dmwit> Woof. And looking at that package, you see why nobody does this. ^_^
17:26:13 <int-e> (I don't actually know whether there are more packages like this.)
17:26:51 <dmwit> nil: Do those even do the same thing?
17:27:05 <dmwit> Hm. I guess they do.
17:27:28 <dmwit> nil: Anyway, yes, there's a performance difference. And also you don't need the `x` argument.
17:27:46 <int-e> nil: making the sharing explicit is probably a good idea.
17:27:48 <nil> i meant in a general case where `foo` could be anything
17:27:53 <dmwit> There's no performance difference between `f = foo f` and `f = let y = foo y in y`.
17:28:04 <dmwit> Which is what you should have written as the two alternatives. ;-)
17:28:19 <int-e> even though the compiler /may/ convert the former to the latter during optimization, I wouldn't want to rely on that.
17:28:29 <nil> int-e: ok
17:29:14 <int-e> (I don't know whether it would. It doesn't exactly look like a common subexpression...)
17:30:28 <nil> a concrete example is the definition of `fix`: `fix f = f (fix f)` vs `fix f = let x = f x in x`
17:30:47 <nil> prelude seems to be using the latter
17:30:58 <nil> well, base
18:28:08 <jusss> is there a shadow stuff in haskell?
18:28:47 <jusss> variable shadowing
18:29:52 <lyxia> > let s = 3 in let s = 4 in s
18:29:54 <lambdabot>  4
18:30:06 <jusss> ok
18:30:57 <synaps3> let makes a new scope right ?
18:32:25 * dsal recommends -Wall
18:33:54 <wroathe> Anyone know of a version of bracket generalized to arbitrary monads?
18:33:54 <siraben> Is the monad-loops package still suitable for use or should I use a different one?
18:34:17 <wroathe> In particular I want to execute a property in quickcheck, and then perform cleanup regardless of whether or not the property failed
18:34:29 <hololeap> jle`: uniplate looks cool. thanks
18:34:45 <dsal> wroathe: Isn't that just finally?
18:35:01 <wroathe> :t finally
18:35:02 <lambdabot> IO a -> IO b -> IO a
18:35:11 <wroathe> :t bracket
18:35:12 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
18:36:04 <wroathe> Oh, I guess there's gbracket
18:36:46 <wroathe> Oh, but that's in ghc :(
18:39:20 <wroathe> Oh, duh, exceptions
18:42:13 <wroathe> But quickcheck's PropertyM isn't an instance of MonadMask :(
18:44:31 <lyxia> you can do IO in Properties
18:46:10 <lyxia> that's ioProperty
18:46:18 <wroathe> lyxia: https://gist.github.com/JustinChristensen/64e3e35deea3cd683338dbe8fc167124
18:46:22 <wroathe> Something like this is what I'm trying to do
18:46:52 <wroathe> I've got an FFI datatype that requires me to free it after the property finishes
18:48:49 <wroathe> Actually, I just pushed. Here's the project: https://github.com/JustinChristensen/compilers-notes/tree/master/test/libs/base/props
18:49:35 <wroathe> This builds: https://github.com/JustinChristensen/compilers-notes/blob/master/test/libs/base/props/CIntSet.hs#L82-L86, but because the "test" prop I'm wrapping calls fail it doesn't get to the last line where it frees the resources
18:49:52 <wroathe> I was thinking QuickCheck would offer an API for this, but I don't see it in hackage
18:53:59 <lyxia> do you have another reason to use PropertyM
18:55:20 <wroathe> Well, the goal was to keep the inner test function constrainted to basically the same API described in Test.Quickcheck.Monadic
18:55:39 <wroathe> https://github.com/JustinChristensen/compilers-notes/blob/master/test/libs/base/props/CIntSetProps.hs#L30-L36
18:55:42 <wroathe> For example
18:56:42 <wroathe> So arbitrary is generating some overlapping sets for me and performing the corresponding binary operation (union, intersection, etc), and this with* helper is mapping those sets to my FFI set data type, running the prop, and then ideally freeing the FFI set type
19:01:48 <lyxia> ok so since PropertyM is Cont maybe you can use the MkProperty constructor with bracket
19:03:10 <wroathe> Cont?
19:03:58 <wroathe> Oh, MonadCont
19:05:25 <wroathe> I'll just pick this up again tomorrow. I've been at this for too long and the lines of text are starting to blur :P
19:06:33 <lyxia> wroathe: https://dpaste.de/eYhR without PropertyM
19:06:49 <DeathBySudoku> Evening fellow humans.
19:07:28 <DeathBySudoku> I am DeathBySudoku, not to be confused by my twin: DeathBySeppuku 
19:07:46 <DeathBySudoku> I have some haskell errors I am hoping I could get some help with
19:07:55 <DeathBySudoku> My problem is this:
19:08:50 <DeathBySudoku> The function takes a list of lists and returns a grid of water sources that are exactly enough to cover the area
19:09:55 <DeathBySudoku> If my input was [4,0,0],[0,0,3],[0,2,0]] an acceptable output would be [[a,a,a],[a,b,b],[c,c,b]]
19:10:07 <DeathBySudoku> If anyone is able to help me try to learn this I would be really appreciative!
19:12:23 <lyxia> what does the list mean
19:12:32 <DeathBySudoku> The list of lists?
19:12:34 <lyxia> both
19:12:40 <Silent_Alex> tuple?
19:12:50 <DeathBySudoku> well the first list of lists would be the input for a function
19:13:11 <DeathBySudoku> Could you be more specific?
19:13:18 <lyxia> but what do the number correspond to with respect to the problem in English
19:13:25 <DeathBySudoku> Right
19:13:43 <koz_> Is there an elegant way to write a function whose signature is (c, a -> b) -> a -> (c, b)?
19:13:58 <lyxia> koz_: sequence
19:14:03 <koz_> :t sequence
19:14:05 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
19:14:11 <koz_> Wait seriously?
19:14:14 <lyxia> "elegant" *cough* *cough*
19:14:42 <DeathBySudoku> So, imagine this: You are a farmer. You want to divide your farmland into "fenced" areas, each with its own water source
19:15:00 <koz_> lyxia: That is some galaxy brain right there, thanks!
19:15:02 <DeathBySudoku> A section with a number is a water source
19:15:30 <DeathBySudoku> A 0 represents an area covered by a water source
19:15:52 <DeathBySudoku> you can see in my 3rd list the b is at the end./... the water sources have to be connected ie fenced
19:16:08 <DeathBySudoku> Sorry for blowing up chat btw
19:16:32 <DeathBySudoku> Does that make sense though?
19:16:43 <lyxia> yes that's clearer. do the numbers mean anything quantitatively?
19:17:06 <lyxia> are all sources identical?
19:17:07 <DeathBySudoku> The higher the number the larger the water source
19:17:09 <DeathBySudoku> yes
19:17:41 <lyxia> so there are big and small sources
19:18:14 <DeathBySudoku> There can be in any given solution
19:18:15 <lyxia> okay I understand the problem
19:18:31 <DeathBySudoku> an acceptable solution could be [[1,1,1],[1,1,1],[1,1,1]]
19:18:33 <lyxia> now what did you need help with?
19:18:51 <DeathBySudoku> I am trying to replace the numbers in the initial list with the proper letters corresponding
19:19:20 <DeathBySudoku> I also have no idea how to do this for a list of n size
19:21:43 <DeathBySudoku> Does that still make sense
19:23:11 * hackage aeson-qq 0.8.3 - JSON quasiquoter for Haskell  https://hackage.haskell.org/package/aeson-qq-0.8.3 (SimonHengel)
19:24:28 <EvanR> > map (map (\x -> 'a')) [[1,1,1],[1,1,1],[1,1,1]]
19:24:31 <lambdabot>  ["aaa","aaa","aaa"]
19:24:41 <DeathBySudoku> Oh damn
19:25:22 <DeathBySudoku> I wish I didn't have to hard code it 
19:25:29 <DeathBySudoku> But that is an interesting idea
19:25:55 <EvanR> where 'a' is you could put a lookup into a table computed elsewhere, visible by lexical scope
19:27:30 <DeathBySudoku> How would I do that? Sorry I don't understand.
19:29:21 <EvanR> > let table = [(1,'a'),(2,'b')] in map (mapMaybe (\i -> lookup i table)) [[1,2,1],[1,1,2],[1,1,1]]
19:29:25 <lambdabot>  ["aba","aab","aaa"]
19:30:42 <DeathBySudoku> Can I extend that first one you did for more numbers than a  list of 1's?
19:31:07 <DeathBySudoku> Ie to differentiate between 1's, 2's in a list? What does that lamda function look like?
19:32:00 <EvanR> > let table = [(1,'a'),(2,'b'),(3,'c')] in map (mapMaybe (\i -> lookup i table)) [[1,2,1],[1,3,2],[3,1,1]]
19:32:02 <lambdabot>  ["aba","acb","caa"]
19:33:24 <EvanR> i guess i don't understand what you mean
19:33:36 <DeathBySudoku> You are helping lots
19:33:47 <DeathBySudoku> At least helping me think differently about this problem
19:34:32 <MarcelineVQ> the first one you saw doesn't care about the 1's, it just replaces every item with 'a'
19:34:48 <DeathBySudoku> The table solution is great except the solver doesn't care for keeping the letters grouped which I need
19:36:22 <EvanR> um so the solver isn't solving correctly?
19:36:43 <DeathBySudoku> Well it does what you told it to do
19:38:00 <DeathBySudoku> What platform do we use for screencapping?
19:38:25 <MarcelineVQ> whatever you like, you would just link a url here
19:38:31 <DeathBySudoku> Oh. Great
19:40:55 <DeathBySudoku> https://imgur.com/a/j0RgyfM 
19:41:23 <DeathBySudoku> Supposedly the solution can be very elegant
19:41:32 <DeathBySudoku> I am too much of an orc to figure out how though
19:42:20 <EvanR> then the solver should return the area id and not the water source
19:42:52 <EvanR> then you can map id's to letters
19:42:55 <DeathBySudoku> that is right
19:43:03 <DeathBySudoku> How can it work for user input though
19:43:13 <DeathBySudoku> Im not sure how to generalize it
19:46:50 <irc27313> :t id
19:46:51 <lambdabot> a -> a
19:48:31 <pavonia> (5. Find a solution that requires the least amount of fence.)
19:48:56 <irc27313> wow,
19:49:14 <DeathBySudoku> Yes its a bugger
19:49:18 <DeathBySudoku> I am really struggling 
19:52:29 <Axman6> irc27313: ir is profound, isn't it
19:53:18 <EvanR> id, ego, super-ego
19:54:25 <dsal> Is there a Monad instance of super ego?
19:55:00 <heatsink> Yes, according to Immanuel Kant
19:56:48 <irc27313> yeah
19:57:07 <DeathBySudoku> i c
19:59:27 <siraben> @pf queueCopyProp l = monadicIO $ run (queueCopyCheck l) >>= assert
19:59:27 <lambdabot> Maybe you meant: pl bf
19:59:35 <siraben> @pl queueCopyProp l = monadicIO $ run (queueCopyCheck l) >>= assert
19:59:35 <lambdabot> queueCopyProp = monadicIO . (assert =<<) . run . queueCopyCheck
20:01:03 <siraben> @pl queueProp l n = monadicIO $ queueCheck l n >>= assert
20:01:04 <lambdabot> queueProp = (monadicIO .) . flip flip assert . ((>>=) .) . queueCheck
20:01:22 <siraben> Ok "flip flip assert" is definitely not better.
20:02:02 <EvanR> lol
20:02:09 <EvanR> :t flip flip f
20:02:10 <lambdabot> FromExpr b => (a -> b -> c) -> a -> c
20:02:40 <EvanR> :t flip (flip f)
20:02:42 <lambdabot> (Show a, Show b, FromExpr c) => a -> b -> c
20:02:46 <Axman6> :t flip flip flip
20:02:48 <lambdabot> (a1 -> ((a2 -> b -> c1) -> b -> a2 -> c1) -> c2) -> a1 -> c2
20:02:48 <EvanR> o_O
20:03:01 <Axman6> :t \f -> flip (flip f)
20:03:03 <lambdabot> (a -> b -> c) -> a -> b -> c
20:03:10 <Axman6> :t \f -> flip flip f
20:03:11 <lambdabot> b -> (a -> b -> c) -> a -> c
20:03:12 <EvanR> where did Show come from
20:03:25 <Axman6> it came from f which is an Expr
20:03:27 <Axman6> :t f
20:03:29 <lambdabot> FromExpr a => a
20:04:35 <EvanR> :t flip . flip
20:04:36 <lambdabot> (b -> a -> c) -> b -> a -> c
20:04:51 <EvanR> better be :)
20:05:05 <siraben> How do I fold a list of flips into flip flip flip flip...
20:05:31 <siraben> :t foldr1 (.) (take 10 (repeat flip))
20:05:33 <lambdabot> (a -> a -> c) -> a -> a -> c
20:05:44 <siraben> :t foldr1 (.) (take 11 (repeat flip))
20:05:45 <lambdabot> (a -> a -> c) -> a -> a -> c
20:05:59 <siraben> Aww I was hoping for some sort of parity checker
20:06:15 <Axman6> it kind of is if you use bool
20:06:21 <siraben> even/odd number of flips reflected in the type signature
20:06:27 <Axman6> foldr1 (.) (take 10 (repeat flip)) bool
20:06:35 <Axman6> :t foldr1 (.) (take 10 (repeat flip)) bool
20:06:37 <lambdabot> a -> a -> Bool -> a
20:06:55 <Axman6> :t foldr1 (.) (take 10 (repeat flip)) bool "Even" Odd" True
20:06:56 <lambdabot> error:
20:06:56 <lambdabot>     lexical error in string/character literal at end of input
20:07:09 <Axman6> > foldr1 (.) (take 10 (repeat flip)) bool "Even" "Odd" True
20:07:11 <lambdabot>  "Odd"
20:07:19 <Axman6> > foldr1 (.) (take 10 (repeat flip)) bool "Even" "Odd" False
20:07:21 <lambdabot>  "Even"
20:07:35 <siraben> What's "bool"
20:07:40 <Axman6> :t bool
20:07:42 <lambdabot> a -> a -> Bool -> a
20:07:46 <Axman6> it's the catamorphism for Bool
20:07:49 <Axman6> :t maybe
20:07:51 <lambdabot> b -> (a -> b) -> Maybe a -> b
20:07:52 <Axman6> :t either
20:07:53 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
20:07:54 <Axman6> :t foldr
20:07:56 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
20:08:02 <Axman6> :t foldr @[]
20:08:03 <lambdabot> error:
20:08:04 <lambdabot>     Pattern syntax in expression context: foldr@[]
20:08:04 <lambdabot>     Did you mean to enable TypeApplications?
20:08:08 <Axman6> %:t foldr @[]
20:08:08 <siraben> GHCi doesn't have it, no?
20:08:20 <Axman6> @hoolge bool
20:08:21 <lambdabot> Data.Bool bool :: a -> a -> Bool -> a
20:08:21 <lambdabot> Data.Aeson.Encoding bool :: Bool -> Encoding
20:08:21 <lambdabot> Data.Aeson.Encoding.Internal bool :: Bool -> Encoding
20:08:25 <Axman6> yes
20:08:32 <Axman6> but not Prelude
20:08:44 <siraben> Ah I see.
20:09:04 <siraben> :t foldr1 (.) (take 1337 (repeat flip)) bool "Even" "Odd" False
20:09:06 <lambdabot> [Char]
20:09:14 <siraben> > foldr1 (.) (take 1337 (repeat flip)) bool "Even" "Odd" False
20:09:16 <lambdabot>  "Odd"
20:09:25 <siraben> Heh a roundabout way to write even/odd
20:11:38 <siraben> Can I shorten this list of foreign imports? http://ix.io/20js
20:12:13 <siraben> Seems like I can't do multiple imports in one block
20:12:29 <Axman6> that would be a great proposal for GHC though
20:12:55 <siraben> Template Haskell to the rescue, maybe?
20:13:30 <EvanR> editor fu ?
20:15:13 <siraben> I've been implementing a queue in C and using QuickCheck, just to learn about the FFI more, can it be done with C++ as well?
20:15:18 <siraben> If I implement a Queue class, for instance.
20:15:53 <Axman6> you'd need to make C wrappers to the functions IIRC
20:16:03 <Axman6> there's no support for calling C++ functions in the FFI
20:16:12 <siraben> Hm, looks like https://stackoverflow.com/questions/12475726/haskell-ffi-interfacing-with-simple-c#12477125
20:16:14 <siraben> Right.
20:19:36 <libertyprime> having trouble getting this to run https://asciinema.org/a/Z7G0B7ZmNtwjcnSSylEAWpUaI https://github.com/ThomasZumsteg/exercism-haskell/blob/master/say/say_test.hs
20:19:42 <libertyprime> not sure why
20:20:19 <libertyprime> the module is defined in say.hs in the same directory as say_test.hs
20:20:37 <Axman6> you probably want Say.hs
20:24:15 <libertyprime> thanks axman. that will probably be the issue. i cant confirm right now as im following a trail of errors, but that particular error appears to have diappeared
20:24:58 <dsal> In general, you can only call C++ code from C++ code unless it's extern'd.  They've still not figured out a portable C++ ABI.  Guessing that's not happening any time soon.
20:32:34 <koz_> dsal: s/soon/ever/
20:33:34 <jusss> is fold related to fmap?
20:34:27 <hyponoia> in which sense 'related'?
20:34:49 <jusss> handle on list?
20:35:00 <EvanR> map vs reduce
20:35:14 <EvanR> industry experts assert they are orthogonal :)
20:35:47 <jusss> there're three functions, the most languages have them, map, reduce and filter?
20:36:30 <EvanR> mapping is parallel, reducing is sequential
20:36:35 <jusss> map -> fmap in haskell, reduce -> fold , and filter -> ?
20:36:39 <dmj`> has anyone used Haskell w/ SWIG (http://www.swig.org/)
20:36:47 <jle`> reduce probably closer to foldr or foldl
20:37:18 <jle`> haskell does have a function called 'fold' which is related but not the same
20:37:22 <jle`> haskell has filter as well
20:37:38 <EvanR> filter is the oddball
20:37:39 <jusss> I heard that GvR the python creator had some complains about to implement about reduce on python3k
20:37:54 <hyponoia> I believe folding (or its derivative) is not restricted to lists but will work on any functor (of which list is an instance)
20:37:56 <jle`> GvR has a lot of opinions
20:38:21 <jle`> hyponoia: folding works on many things that are not Functors as well, and many things that are not really functors either
20:38:23 <EvanR> folding works on any Foldable, which is independent from Functor
20:40:55 <jle`> jusss: but yeah, map, reduce, and filter seem to be the 'trifecta' of list processing in "functional" languages and platforms
20:41:13 <jle`> even in functional languages in the "other camp" (lisp-likes), like scheme and clojure
20:41:18 <koz_> I would also add that 'reducing' (if we mean folding) is not _inherently_ sequential. You can fold a tree in parallel.
20:42:18 <EvanR> yeah, but does google ever reduce in parallel?
20:42:27 <koz_> EvanR: What Google do is none of my problem.
20:42:37 <koz_> Google don't determine the laws of computation last I checked. :P
20:42:38 <EvanR> i mean, you're right. They could :)
20:43:05 <jle`> yeah what's that big google fp-inspired platform again
20:43:08 <jle`> Ma Produce?
20:43:32 <jle`> with parallelism
20:43:56 <jusss> jle`: Data.Text, Text is monoid, not monad, right?
20:44:05 <jle`> it is Monoid, not Monad
20:44:13 <jle`> it's the wrong 'kind' to be Monad
20:44:29 <jusss> ok, I saw there's <> in it
20:44:38 <dsal> <> is semigroup
20:44:44 <dsal> :t (<>)
20:44:46 <lambdabot> Semigroup a => a -> a -> a
20:44:46 <jusss> jle`: is there something is semigroup but not monoid?
20:44:58 <jle`> yea, Data.Semigroup has some neat examples
20:44:59 <dsal> Sure, it's easier to be a semigroup than a monoid.
20:45:04 <jle`> Min/Max for types that aren't Bounded
20:45:06 <jle`> First/Last
20:45:18 <jle`> NonEmpty
20:46:02 <jle`> hm. that's all i got, from base
20:47:01 <jusss> semigroup need to implement the associativity law, monoid need associativity law and identity law
20:47:14 <dsal> a monoid needs to be a semigroup
20:47:45 <dsal> % :i Monoid
20:47:45 <yahb> dsal: class Semigroup a => Monoid a where; mempty :: a; mappend :: a -> a -> a; mconcat :: [a] -> a; {-# MINIMAL mempty #-}; -- Defined in `GHC.Base'; instance Monoid BS.ByteString -- Defined in `Data.ByteString.Internal'; instance Monoid BSL.ByteString -- Defined in `Data.ByteString.Lazy.Internal'; instance [safe] Applicative f => Monoid (Traversed a f) -- Defined in `Control.Lens.Internal.Fold'; ins
20:48:02 <jusss> and monad? monad hs the associativity law and identity law, but monad don't have to be monoid
20:48:08 <jusss> that I'm confused
20:48:26 <jle`> jusss: Monad and Monoid are not really compatible haskell
20:48:29 <jle`> they're on different tracks
20:48:32 <jle`> *in haskell
20:48:39 <jle`> Monad is a higher-kinded abstraction
20:48:44 <jle`> Monoid is a normal-kinded abstraction
20:48:45 <EvanR> Semigroup was broken out from Monoid for a reason, and you might have to ask edwardk about it
20:48:47 <jle`> * -> *, vs. *
20:48:48 <jusss> oh, I forget that, they're not same in haskell and math
20:48:59 <jle`> there are some links but not the same concept
20:50:54 <reallymemorable> I’m trying to install: https://github.com/haskell/haskell-ide-engine on OSX High Sierra
20:51:03 <reallymemorable> when i get to this step, I get this: https://gist.github.com/reallymemorable/6a2cae0a5beafd69de8a2b0c36776bac
20:51:10 <hololeap> monads are just monoids in the category of endofunctors
20:51:12 * hackage yesod-persistent 1.6.0.3 - Some helpers for using Persistent from Yesod.  https://hackage.haskell.org/package/yesod-persistent-1.6.0.3 (MichaelSnoyman)
20:51:30 <reallymemorable> I ran `sudo nano /etc/paths` and have this in there: https://gist.github.com/reallymemorable/f2ee12db1dbd7471fe4a9124925bd70d
20:52:07 <jle`> jusss: admittedly they have very similar-sounding names, so it can be pretty confusing
20:52:08 <Axman6> what does env say your PATH is?
20:52:17 <reallymemorable> how do i check that
20:52:22 <Axman6> run env
20:52:28 <EvanR> hololeap that'll be 40 pushups
20:52:40 <jle`> jusss: the similarities in the name are pretty coincidental actually
20:52:44 <jle`> math is weird
20:53:03 <jusss> jle`: I'm not good at math...
20:53:26 <jle`> same
20:53:32 <Axman6> language is weird
20:53:38 <jle`> math history is weird, maybe
20:53:40 <dsal> I'm hilariously bad at math.
20:53:45 <jle`> i'm math at bad
20:53:56 <hololeap> math is just bad
20:54:00 <reallymemorable> Axman6: https://gist.github.com/reallymemorable/c7e52b0d8f7fbd60bb6a2a788e3b848a
20:54:05 <Axman6> there is an equivalence relationship between maths and bad
20:54:14 <jle`> baths make me mad
20:55:00 <Axman6> reallymemorable: you should be able to run ./install cabal-build-all without stack
20:55:15 <jusss> it takes me two days to write a function that split a list with a list, my math is very not good, https://paste.ubuntu.com/p/4tG4NsCPsk/
20:55:40 <reallymemorable> `reallymemorable:haskell-ide-engine reallymemorable$ ./install cabal-build-all
20:55:41 <reallymemorable> -bash: ./install: is a directory
20:55:42 <reallymemorable> `
20:56:07 <jle`> to be fair, i don't really think list splitting functions are indicative of proficiency in math or programming
20:56:10 <Axman6> ./install.hs
20:56:43 <Axman6> I can't figure out what that splitList function is even supposed to do, so you're doing better than me!
20:57:04 <jle`> yeah it would probably take me two days to even know what it means to split a list with a list
20:57:11 <jle`> s/know/figure out
20:57:12 <reallymemorable> https://gist.github.com/reallymemorable/485edc7034c151067131dd0de2131fdb
20:57:23 <Axman6> it's splitting by an infix sublist I think
20:58:09 <reallymemorable> is that meant for me?
20:58:19 <Axman6> hmm, I get the same error
20:58:25 <Axman6> no
20:58:47 <Axman6> why are you using cabal-build-all ?
20:59:05 <reallymemorable> `To install HIE for all GHC versions that are present on your system, use:`
20:59:10 <reallymemorable> ^^^ from the docs
20:59:13 <Axman6> hmm
20:59:15 <hololeap> jusss: http://hackage.haskell.org/package/split-0.2.3.3/docs/Data-List-Split.html#v:splitOn
20:59:26 <Axman6> I've only used "./install.hs hie-8.6.3 hie-8.6.5" in the past
20:59:46 <reallymemorable> so i should check which hie i have?
20:59:50 <reallymemorable> and just use that
21:00:04 <Axman6> you should compile foir the ghc versions you intend to use
21:00:22 <reallymemorable> how can i check which ghc versions i have
21:00:42 <Axman6> you can also use ./install.hs build-all according to ./uinstall.hs help
21:01:46 <jusss> hololeap: they should show up in Data.ByteString... or other Data.List
21:02:15 <Axman6> why would functions for working with lists be in Data.ByteString?
21:02:36 <jusss> Axman6: then Data.List
21:03:06 <hololeap> jusss: the fact that splitting a list can mean so many different things means that there should be a package dedicated to it
21:03:18 <Axman6> probably a lot of the functions from Data.List.Split should be in Data.List, yes
21:37:12 * hackage h2048 0.4.0.0 - An Implementation of Game 2048  https://hackage.haskell.org/package/h2048-0.4.0.0 (javran)
21:43:42 * hackage persistent 2.10.4 - Type-safe, multi-backend data serialization.  https://hackage.haskell.org/package/persistent-2.10.4 (MichaelSnoyman)
21:46:41 * hackage doctemplates 0.7 - Pandoc-style document templates  https://hackage.haskell.org/package/doctemplates-0.7 (JohnMacFarlane)
22:14:17 <siraben> Can I pass the -lstdc++ option to ghc -c foo.cpp ?
22:14:32 <siraben> I'm getting errors like "operator new(unsigned long)", referenced from: _c_newQueue in foo.o"
22:14:45 <Axman6> probably with something like -optl=-lstdc++
22:15:23 <Axman6> check the ghc manual for how to pass flags to the linker
22:17:06 <siraben> Whoa, I just got it to work
22:17:16 <siraben> "ghc --make main.hs foo.o -pgml g++"
22:17:19 <siraben> -pgml, whatever that does.
22:18:13 <Axman6> it says which program to use as the linker
22:36:04 <jusss> what is `dependent type' ?
22:36:26 <Axman6> a type which is determined by values at the value level.
22:39:34 <jusss> Axman6: so we can not to declare the type?
22:40:42 * hackage chiphunk 0.1.2.1 - Haskell bindings for Chipmunk2D physics engine  https://hackage.haskell.org/package/chiphunk-0.1.2.1 (DavidHimmelstrup)
22:40:53 <Axman6> it's not something we currently have in Haskell (we have some ways to do it but it's not currently a language feature). 
22:41:20 <koz_> Axman6: This is the cause of much of my sads.
22:41:45 <jusss> it's realted to type inference?
22:42:23 <Axman6> an example might be something like replicateVec :: (n :: Int) -> a -> Vec n a where Vec is a list of length n, with the length known to the type system. you could then write replicateVec 3 True and get  [True, True, True] :: Vec 3 Bool
22:43:11 * hackage profunctor-misc 0.0.0.1 - Profunctor miscellany  https://hackage.haskell.org/package/profunctor-misc-0.0.0.1 (cmk)
22:46:11 * hackage rex 0.6 - A quasi-quoter for typeful results of regex captures.  https://hackage.haskell.org/package/rex-0.6 (MichaelSloan)
22:48:37 <Axman6> jusss: well, sort of, it's something which gives the type system much more power to describe how your program works and make it much safer. if you can encode structure in the type system then the compiler can check that a functionm of type Vec (n+3) a -> a which gives you back the third element in the vector is always safe - in Haskell we would have to use [a] -> Maybe a because we can't know ahead of time that our list has at leats three ele
22:48:37 <Axman6> ments
22:55:35 <koz_> It's related to type inference by being impossible for it. :P
22:57:21 <dminuoso> jusss: Polymorphic types are (value-levels) terms that can bind a type, dependent types are types that can bind a (value-level) term. :)
22:57:21 <dminuoso> % :t fmap
22:57:21 <yahb> dminuoso: Functor f => (a -> b) -> f a -> f b
22:57:26 <dminuoso> % :t fmap @[] @Int
22:57:26 <yahb> dminuoso: (Int -> b) -> [Int] -> [b]
22:57:45 <dminuoso> ^- this can be seen as applying a value-level term to types! GHC does this automatically behind the scenes, figuring out what types to insert.
23:00:31 <dminuoso> I want a light quasiquoter that lets me template lazy text and gives me interpolation. Is there something on hackage Im not seeing?
23:01:04 <jusss> dminuoso: dependent types are related to kind?
23:01:21 <dminuoso> jusss: No. Remember how we have "type" functions like "Maybe" ?
23:01:35 <dminuoso> jusss: We can apply Maybe to types only. In dependent types we can apply type-level things to values.
23:01:40 <jusss> dminuoso: data Maybe a = Just a |Nothing
23:02:03 <dminuoso> jusss: Right! And Maybe is a type level function producing types, so `Maybe` applies to `Int` gives us `Maybe Int`.
23:02:31 <jusss> dminuoso: wait a sec, type and value are two levels, 
23:02:36 <dminuoso> jusss: Indeed!
23:02:49 <jusss> dminuoso: why people want type apply on value ?
23:03:01 <Axman6> in dependant types they are just different levels of a heirarchy, which can be mixed
23:03:27 <jusss> dminuoso: Axman6 they can do that in OOP?
23:03:29 <dminuoso> jusss: It's so that we can encode value-level information into the type.
23:03:44 <jusss> OOP's class can think as type
23:03:45 <Axman6> can you do anything interesting in OOP? (no)
23:03:51 <dminuoso> jusss: For example "Vec 10 Int" is the *type* of a vector containing 10 integers. :)
23:04:25 <jusss> dminuoso: ... but 10 is a value, and 10::Int, Int is a type not a value,
23:04:30 <dminuoso> jusss: Yup!
23:04:41 * hackage property 0.0.1 - common properties  https://hackage.haskell.org/package/property-0.0.1 (cmk)
23:04:46 <Axman6> if we have than, then we can write functions like drop :: (n :: Int) -> Vec (n+m) a -> Vec m a
23:04:47 <dminuoso> jusss: And dependent types is about mixing these levels intentoinally this way.
23:04:51 <jusss> dminuoso: so "Vec 10 Int" is a type or a value?
23:04:53 <MarcelineVQ> That's why it's called dependent type, a type depending on a value.
23:04:54 <dminuoso> jusss: Its a type!
23:05:15 <jusss> dminuoso: oh, I see
23:05:42 <jusss> MarcelineVQ: it should call dependent-on-value type
23:06:18 <dminuoso> jusss: People are lazy and like short terms. :)
23:06:40 <dminuoso> jusss: Which is why fancy mathy people call them Pi types.
23:07:02 <dminuoso> jusss: Do note, that in Haskell we mix type and value too.
23:07:16 <MarcelineVQ> Π types if you're too fancy
23:07:25 <dminuoso> jusss: But for us its the other way around. In dependent types you can apply types to values, in GHC we can apply values to types.
23:07:31 <dminuoso> % :t id
23:07:31 <dminuoso> % :t id @Int
23:07:31 <yahb> dminuoso: a -> a
23:07:31 <yahb> dminuoso: Int -> Int
23:07:39 <dminuoso> This is called "polymorphic types"
23:07:48 <Axman6> %\Pi types% if you've extra fancy
23:08:26 <dibblego> 🥧
23:08:50 <ammar2> now that's a pie I can get behind
23:08:53 <MarcelineVQ> dminuoso: did you accidently flip that?  @ is called a Type Application after all
23:09:05 <dminuoso> MarcelineVQ: Flip what exactly?
23:09:11 <MarcelineVQ> "In dependent types you can apply types to values, in GHC we can apply values to types."
23:09:12 <dminuoso> MarcelineVQ: The term "type applications" is mixed up.
23:09:22 <dminuoso> MarcelineVQ: Functions are applied to arguments.
23:09:51 <dminuoso> (Oh that pun in "the term ..." was not intentional)
23:12:19 <MarcelineVQ> When writing  @Int  you're calling Int a value?
23:12:19 <dminuoso> MarcelineVQ: Another way to put it "polymorphic types are terms binding types and dependent types are types binding terms"
23:12:59 <dminuoso> No? It's a type.
23:13:01 <jusss> dminuoso: this @ symbol, I saw it once, and someone send me a link about it, I foreget it... it's a article about something 's created in 2015
23:13:36 <MarcelineVQ> I don't understand what "in GHC we can apply values to types" means then followed by your id example
23:14:13 <Axman6> id @Int is applying id ('s type) to @Int
23:14:54 <ammar2> jusss: it's called visible type application, basically when we have `id: a -> a` it really means that `id: for any type a, a -> a`, when we do `id @Int`, we fill that "any type" with `Int` explicitly to make `Int -> Int`
23:15:08 <Axman6> if :: forall a. a -> a is basically a fancy type level lambda: \\a --> (a -> a)
23:15:23 <dminuoso> jusss: In a perfect world we could imagine it wasn't there.
23:15:23 <dminuoso> jusss: So try and squint a bit and ignore the @ symbol. :)
23:15:23 <dminuoso> MarcelineVQ: `f 1` is f applied to 1. `f @Int` is f applied to Int.
23:15:24 <dminuoso> MarcelineVQ: Just like in the sense of System F....
23:15:26 <Axman6> (making up syntax for what type level lambdas could look like
23:15:56 <dminuoso> 07:15:01          Axman6 | if :: forall a. a -> a is basically a fancy type level lambda: \\a --> (a -> a)
23:15:58 <dminuoso> No!
23:16:02 <dminuoso> That's just false.
23:16:15 * Axman6 ducks
23:16:26 <dminuoso> Axman6: type families are type level lambda
23:16:35 <dminuoso> Or non-nullary type constructors
23:16:51 <dminuoso> Consider:
23:17:12 <dminuoso>  /\t.\x^t. x : ∀r. r
23:17:28 <jle`>  > type families are a type level lambda
23:17:29 <dminuoso> The lambda abstraction you are thinking of really exists on the value world.
23:17:36 <jle`> [doubt]
23:17:42 <dminuoso> jle`: In what sense
23:17:48 <jle`> aren't lambdas anonymous?
23:17:52 <jle`> but all type families must have names
23:17:54 <dminuoso> jle`: Heh.
23:18:03 <Axman6> type families are type level functions, sure
23:18:05 <dminuoso> It's a fair point.
23:18:15 <dminuoso> Axman6: But really the point is, the binding happens in the *value* world.
23:18:21 <jle`> anonymity is the defining characteristic of lambda-ness
23:19:04 <MarcelineVQ> "<dminuoso> MarcelineVQ: `f 1` is f applied to 1. `f @Int` is f applied to Int." should probably be a line in the manual
23:19:47 <Axman6> you could argue that f 1 is f applied implicitly to Int and applied to the value 1
23:20:21 <dminuoso> MarcelineVQ: The really weird thing is how ScopedTypeVariables visually binds from a type signature, as opposed to something like: f :: ∀x. x -> x; f @t = id @t
23:22:57 <dminuoso> MarcelineVQ: ^- this would be more honest to how we have system fc in core.
23:47:12 * hackage rings 0.0.1 - basic algebra  https://hackage.haskell.org/package/rings-0.0.1 (cmk)
23:52:25 <jusss> dminuoso: when we need to use type application?
23:52:33 <jusss> like id @Int
23:59:42 * hackage json-pointy 0.1.0.1 - JSON Pointer (RFC 6901) parsing, access, and modification  https://hackage.haskell.org/package/json-pointy-0.1.0.1 (IanDuncan)
