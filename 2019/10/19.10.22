00:28:10 <mjrosenb> lens question: I have a structure, data Foo  = Foo {_a :: AType }, and update :: AType -> AType, and am using fooValue & a ~. update.
00:29:24 <mjrosenb> I now realize that I need more information about this transform, and would like to use betterUpdate :: AType -> (AType, ExtraType), and end up with a (Foo, ExtraType)
00:29:38 <mjrosenb> or any of the 4 permutations of those two tuples.
00:29:59 <mjrosenb> is there something that does this, or do I need to just do a get and a set?
00:30:35 <phadej> where from the ExtraType comes?
00:31:31 <phadej> fooValue & a %~ \aValue -> fst (betterUpdate (aValue, extraValue))
00:32:44 <mjrosenb> phadej: ExtraType is returned by betterUpdate, it isn't an argument.
00:32:57 <jackdk> Can anyone point me towards a way of putting injectivity annotations on associated types, or other ways of dealing with associated types in a type class which have ambiguous type variables? https://www.irccloud.com/pastebin/H7mA2Hkd/Merge.hs
00:33:08 <ggVGc> Woke up thinking "Might it be time to add Lens to my current project... But I don't want even longer compile times..." :(
00:34:01 <dminuoso> ggVGc: Look into `optics` perhaps? :)
00:34:30 <mjrosenb> so, a simplified description of what I'm trying to do, AType is Int update is update 0 = 0; update n = (n-1), and now I also want to know if it just transitioned from 1 to 0, since looking at the return value, I won't know if it just transitioned to 0, or it was already there,
00:34:39 <phadej> mjrosenb: I see
00:34:45 <phadej> > forOf _2 ('x', True) $ \b -> (show b, not b)
00:34:47 <lambdabot>  ("True",('x',False))
00:34:49 <mjrosenb> and I don't particularly want to duplicate the logic for decrementing it.
00:35:18 <dminuoso> ggVGc: It has pretty good compilation times.
00:36:00 <phadej> or using operator-soup
00:36:01 <phadej> http://hackage.haskell.org/package/base
00:36:03 <phadej> > ('x', True) & _2 %%~ \b -> (show b, not b)
00:36:05 <lambdabot>  ("True",('x',False))
00:36:23 <ggVGc> hm, maybe I'm misremembering. Last time I used it I remember my compilation times going up noticably. Should try again I guess
00:36:57 <phadej> and cache the dependencies
00:37:06 <dminuoso> ggVGc: Well sure its not for free, but it has a really low dependency footprint (because it comes with its own small profunctor implementation)
00:38:13 <mjrosenb> ahh, and %%~ is using the fact that (a,) is a functor.
00:38:16 <mjrosenb> clever.
00:38:17 <ariakenom> ggVGc: just to check. did you notice that dminouse was talking about the package "optics" that is different from the package "lens"
00:39:11 <dminuoso> ariakenom: Did you guess that from "last time I used it" ? ;)
00:39:13 <mjrosenb> phadej: thanks!
00:39:49 <phadej> mjrosenb: or actually an Applicative, yes.
00:40:57 <ariakenom> dminuoso: im just gonna assume that if people talk about "optics" without explicitly saying "package" at least twice then they arent talking about it
00:41:23 <dminuoso> ariakenom: Heh. Adam sold me on optics two weeks ago.
00:41:41 <dminuoso> My major reason is that it makes using type holes to figure out the type of some optics a charm.. 
00:42:12 <dminuoso> (Say once you start composing things without closely keeping track of the types of your optics, with lens you end up with just a gibberish of constraints..
00:42:53 * jackdk is scared that in the name of dependency footprints, we may end up having parallel implementations hanging around for fundamental things like profunctors
00:43:01 <ggVGc> ah, I misread dminuoso, sorry. Will try out optics
00:43:34 <jackdk> I'd love to see class Profunctor tidied up with a quantified constraint, then fold it into base and fix arrow etc.
00:43:54 <jackdk> There are good reasons why it's not easy, but hey, I like to dream.
00:44:00 <ariakenom> I knew it, that name is incredibly bad
00:44:32 <maerwald> dminuoso: the biggest selling point is actually the documentation lol
00:44:42 <ariakenom> dminuoso: I should look into it. you think they can be convinced to change the name though?
00:44:43 <ariakenom> :p
00:44:44 <maerwald> I can read it and understand it...
00:45:02 <mjrosenb> jackdk: when you say "fix arrow", do you mean repairing arrows, or fixed arrows?
00:47:06 <jackdk> mjrosenb: there was talk in the profunctor-into-base gitlab issue about setting Arrow's superclasses up so they played nice with the classes from `profunctors`
00:48:07 <mjrosenb> ok, so repairing arrows.
00:48:34 <jackdk> mjrosenb: specifically https://gitlab.haskell.org/ghc/ghc/issues/16173#note_219206 and immediately below
00:53:14 <mjrosenb> I should really try to figure out arrows, I've read a bunch on them, and can use them to do one thing, but I feel like they are waaay more powerful
00:54:25 <mjrosenb> that "one thing" being effectively (_1 ~%)/(_2 ~%), now that I have some understanding of lenses.
00:55:18 <jle`> mjrosenb: arrow as an abstraction is somewhat of a dead abstraction
00:55:28 <jle`> you won't get much out of studying them as a polymorphic abstraction
00:55:38 <jle`> but sometimes the methods for the (->) instance can be handy
00:55:53 <mjrosenb> sweet! I've successfully put it off long enough!
00:56:18 <jle`> but that's really just
00:56:24 <jle`> % :t (&&&) @(->)
00:56:24 <yahb> jle`: (b -> c) -> (b -> c') -> b -> (c, c')
00:56:28 <jle`> % :t (***) @(->)
00:56:28 <yahb> jle`: (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
00:56:34 <jle`> that second one we often just use bimap these days
00:56:40 <jle`> % :t bimap @(,)
00:56:41 <yahb> jle`: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
00:56:51 <jle`> only the first one people sometimes use for (->) specifically
00:57:00 <jle`> without any need to understand Arrow as an abstraction
01:01:06 <dminuoso> jackdk: I think its not scary but one of the main reasons.
01:01:13 <dminuoso> jackdk: https://hackage.haskell.org/package/indexed-profunctors c.f. http://hackage.haskell.org/package/profunctors
01:01:31 <dminuoso> jackdk: Id say the former has a light dependency footprint. The latter drags in half the kmettiverse.
01:02:25 <jackdk> I don't mind that, because everything depends on the kmettverse anyway
01:02:34 <dminuoso> I dont think that really holds true.
01:02:47 <Athas> I try to avoid the kmettverse.
01:03:25 <Athas> profunctors doesn't look too bad at first glance.
01:03:25 <jle`> at the application level i love kmettverse
01:03:29 <merijn> I try to avoid the lens-verse, kmettverse has a bunch of useful stuff :p
01:03:42 <Athas> Yeah, what merijn says.  I use bifunctors, for example.
01:03:43 <dminuoso> Athas: It pulls in semigroups.
01:04:32 <dminuoso> merijn: have you tried the new optics package? :)
01:04:36 <Athas> Is semigroups so bad?
01:06:16 <merijn> dminuoso: No
01:06:31 <merijn> Mostly because I just don't really use lenses
01:07:13 <phadej> https://raw.githubusercontent.com/phadej/acme-kmett/master/deps-8.8.1.png
01:07:24 <phadej> profunctors pulls in contravariant and bifunctors
01:08:19 <phadej> (on GHC-8.8.1, on older GHC there is more compat packages, but they are... compat)
01:08:53 <phadej> so step from bifunctors to profunctors is small; yet the most useful parts of bifunctors are in base
01:09:20 <dminuoso> Mmm, can you generate thee graphs via cabal?
01:09:25 <phadej> TL;DR, saying that profunctors drags half the kmettiverse is not true
01:09:31 <dminuoso> fair enough
01:10:27 <phadej> @package cabal-plan
01:10:28 <lambdabot> http://hackage.haskell.org/package/cabal-plan
01:10:37 <dminuoso> Merci
01:10:46 <phadej> who maintains lambdabot, that one could tell https:// links
01:11:03 <dminuoso> int-e ^-
01:11:32 <merijn> I wonder if this works
01:11:37 <merijn> @remember- cabal-plan
01:11:37 <lambdabot> Incorrect arguments to quote
01:12:04 <merijn> @remember cabal-plan https://hackage.haskell.org/package/cabal-plan
01:12:04 <lambdabot> Done.
01:12:09 <merijn> @where cabal-plan
01:12:09 <lambdabot> I know nothing about cabal-plan.
01:12:26 <merijn> heh
01:12:27 <int-e> remember is for quotes...
01:12:39 <int-e> @forget cabal-plan https://hackage.haskell.org/package/cabal-plan
01:12:39 <lambdabot> Done.
01:12:43 <int-e> @where+t cabal-plan https://hackage.haskell.org/package/cabal-plan
01:12:44 <lambdabot> Good to know.
01:12:45 <merijn> int-e: Oh wait, i guess it's where+
01:13:00 <merijn> E_INSUFFICIENT_COFFEE
01:13:09 <int-e> anyway, @hackage just prepends a fixed string
01:13:14 <int-e> @hackage see what I mean?
01:13:14 <lambdabot> http://hackage.haskell.org/package/see what I mean?
01:13:18 <phadej> :)
01:13:53 <phadej> that fixed string could have https:// :)
01:13:59 <merijn> int-e: Right, but I think phadej's point was that it should fix the fixed string to https ;)
01:14:14 <int-e> lisppaste2: url
01:14:14 <lambdabot> Haskell pastebin: http://lpaste.net/
01:14:17 <int-e> wth
01:15:37 <int-e> @where paste
01:15:37 <lambdabot> https://gist.github.com
01:15:42 <int-e> mmm
01:15:56 <int-e> @bug
01:15:56 <lambdabot> https://hackage.haskell.org/trac/ghc/newticket?type=bug
01:20:08 <phadej> I like this https://raw.githubusercontent.com/phadej/acme-kmett/master/deps-7.2.2.png
01:20:20 <phadej> not much stuff on old GHC
01:21:28 <dminuoso> Lens vs optics dep tree: https://pasteboard.co/ID7DdLo.png https://pasteboard.co/ID7D2Bj.png
01:22:28 <merijn> Sure, but lens is intentionally fat
01:22:44 <merijn> So that doesn't apply to all of the kmettiverse
01:24:10 <mjrosenb> random style question: what do people like better (True, foo & f & g & h) or foo & f & g & h & (True,)
01:24:48 <dminuoso> mjrosenb: f = (True, x) where x = ..
01:24:48 <Athas> mjrosenb: definitely the former.
01:24:51 <dminuoso> (Or let-equivalent)
01:26:54 <mjrosenb> cool, that is what I have now.
01:27:14 * hackage logging-effect 1.3.7 - A mtl-style monad transformer for general purpose & compositional logging  https://hackage.haskell.org/package/logging-effect-1.3.7 (OliverCharles)
01:35:31 <phadej> h $ $ g $ f foo
01:35:44 <phadej> h $ g $ f foo
01:36:21 <ski>   (True,h (g (f foo)))
01:36:33 <ski>   (True,(h . g . f) foo)
01:37:00 <dminuoso> let s = h . g . f in (True, s foo)
01:37:15 <mjrosenb> so, h, g, f, etc. are lens updates. I suspect the precedence of . would not play nicely with that.
01:37:59 <dminuoso> mjrosenb: Can you show us the real code then perhaps?
01:38:22 <__dingbat__> Hello, can someone help me understand the difference b/w STM - readTVar & Concurrent's - readMVar ?
01:38:36 <phadej> the use different vars :)
01:39:00 <__dingbat__> are they both blocking? readMVar says its blocking until value can be read. How about readTVar plz?
01:39:10 <dminuoso> __dingbat__: TVar is a high level abstraction whereas MVar is closer to a concurrency primitive.
01:39:27 <dminuoso> __dingbat__: Do you know what transactions are, say from database theory?
01:39:43 <__dingbat__> dminuoso: yes I understand transactions
01:39:55 <merijn> I think the most important thing to note is: MVar can be *empty*
01:39:59 <ski> @hoogle TMVar
01:40:00 <lambdabot> module Control.Concurrent.STM.TMVar
01:40:00 <lambdabot> Control.Concurrent.STM.TMVar data TMVar a
01:40:00 <lambdabot> UnliftIO.STM data TMVar a
01:40:03 <merijn> You can't read an 'a' from something empty
01:40:04 <__dingbat__> I am particularly asking about blocking nature b/w the two
01:40:14 <ski> `TMVar' is the `STM' version of `IO's `MVar'
01:40:26 <ski> a `TVar' can't be empty, as merijn suggested
01:40:33 <dminuoso> __dingbat__: TVar is not itself blocking, its rather transactions can be blocked (by means of retry)
01:40:52 <mjrosenb>                         if | Just (_:l@(n:_)) <- animState ^? steps -> (False, animState & steps .~ l & frame .~ Animate.frameCount n)
01:41:08 <__dingbat__> I am not sure I understand 'TVar' cant be empty.
01:41:15 <dminuoso> __dingbat__: Its like an IORef but transactional.
01:41:43 <dminuoso> That is, a TVar can be thought of as a transactional IORef.
01:41:49 <merijn> __dingbat__: "TVar a" is basically like a pointer of sorts. It points to a value of type 'a' that you can read transactionally
01:41:51 <__dingbat__> dminuoso: i see
01:42:02 <merijn> __dingbat__: "MVar a" is more like a pointer to a "Maybe a"
01:42:19 <__dingbat__> merijn: I get it now
01:42:24 <merijn> __dingbat__: So it can point to either "Nothing" or "Just a" and if you read it while Nothing, you will block until it's no longer Nothing
01:42:27 <dminuoso> __dingbat__: As such, TVar doesnt really have blocking semantics built-in.
01:42:58 <__dingbat__> thank you both!
01:43:01 <dminuoso> __dingbat__: You can simply read it out - however, blocking can still happen on a transactional level (by retry'ing, and then your transaction is blocked until someone updates some of your transactions dependencies)
01:45:06 <ariakenom> . o O (A TVar that always retries when read)
01:46:19 <__dingbat__> I see. thank you
01:49:09 <dminuoso> I suppose in some sense MVar is kind of like a semaphore.
01:49:10 * ski . o O ( `newUnfillableTMVar :: STM (TMVar a)' )
02:02:00 <__dingbat__> dminuoso: I suspect this is whats happening in my code ---> "You can simply read it out - however, blocking can still happen on a transactional level (by retry'ing, and then your transaction is blocked until someone updates some of your transactions dependencies)"
02:02:17 <__dingbat__> dminuoso: how do I prevent it from blocking
02:02:30 <merijn> __dingbat__: Depends on what you're doing and why it's blocking
02:03:53 <__dingbat__> merijn: I am trying to read a Set from a TVar, each time an event happens. If the event happens successively then the subsequent readTVar's are blocked, until the TVar is updated in another thread by some other event
02:04:32 <merijn> __dingbat__: So you read the Set, then write an updated set back?
02:04:59 <__dingbat__> Not in the thread that reads, another thread updates the Set based on some conditions.
02:05:22 <__dingbat__> Would MVar be a better choice for this ?
02:05:59 <__dingbat__> I would have to peek with MVars in the first thread I believe.
02:07:44 <ariakenom> __dingbat__: one possibilty is that the transaction cannot complete
02:08:25 <ariakenom> which is probably an error
02:09:14 <__dingbat__> ariakenom: readTVar returns the value first time immediately. The next readTVar is blocked until the TVar is updated by another thread asyncronously
02:09:33 <dminuoso> __dingbat__: Can you perhaps just share your code?
02:10:50 <ariakenom> __dingbat__: "atomically (readTVar (t :: TVar (Data.Set a)))" should probably almost always work
02:11:33 <__dingbat__> ariakenom: will share in a bit
02:12:06 <__dingbat__> I didnt have 'atomically' before readTVar
02:12:32 <dminuoso> __dingbat__: Lets just have a look at your code, its probably easier than trying to figure out the details by successively asking.
02:21:45 <__dingbat__> ariakenom: dminuoso: https://www.codepile.net/pile/z1zO2PdG
02:22:12 <__dingbat__> can you please have a look?
02:25:12 <dminuoso> % :t atomically
02:25:13 <yahb> dminuoso: STM a -> IO a
02:25:41 <dminuoso> __dingbat__: What is the type signature of your `H.lookup` ?
02:26:10 <__dingbat__> Subscribers hash map is of type STMContainers.Map
02:26:29 <dminuoso> __dingbat__: Your code was changed wasnt it? That code wont type check
02:26:40 <dminuoso> Ah
02:26:44 <__dingbat__> lookup :: Key k => k -> Map k v -> STM (Maybe v)
02:26:50 <dminuoso> Alright nevermind.
02:26:52 <__dingbat__> I didn't change anything
02:27:11 <dminuoso> I didnt know it was stm-containers
02:30:41 <__dingbat__> is stm-containers an issue?
02:31:06 <ariakenom> __dingbat__: the publish STM action is missing no?
02:31:18 <dminuoso> I dont know
02:31:28 <dminuoso> But from the looks of it, it shouldnt be ever blocking in subscribersForTopic
02:31:39 <dminuoso> But I dont know stm-container semantics well enough
02:31:46 <__dingbat__> but I felt the hashmap is not an issue , as its merely holding the TVar (Set NodeId)
02:32:45 <ariakenom> __dingbat__: why are you not reading the Set in the same transaction? also why is there another TVar around the Set?
02:33:29 <__dingbat__> So the other thread/s can update the HashMap value
02:33:42 <__dingbat__> i.e. the modified Set
02:33:44 <dminuoso> __dingbat__: Here's a question.. is there any unsafePerformIO in your code?
02:34:05 <__dingbat__> nope, no unsafePerformIO
02:34:08 <ariakenom> __dingbat__: they can already do that by modifying the map, no?
02:34:11 <dminuoso> (Im wondering whether you're perhaps dragging an unsafe transactional mutation into subscribersForTopic via evaluation)
02:34:51 <__dingbat__> ariakenom: yes, I suppose, it was this type before I switched to STMContainers.Map
02:35:23 <__dingbat__> but are you sure the TVar within is causing the issue?
02:35:38 <ariakenom> __dingbat__: no. but it smells bad :)
02:35:49 <__dingbat__> ariakenom: haha :)
02:36:13 <dminuoso> __dingbat__: So just to get this right. Your output prints "publish called" but never actually prints after subscribersForTopic (on the second invocation of publish)?
02:36:27 <__dingbat__> correct
02:36:53 <dminuoso> Im not seeing how this code could do this.
02:37:02 <dminuoso> Assuming that stm-containers doesnt have some nasty bug
02:37:22 <dminuoso> (And I looked at stm-containers/focus/stm-hamt, at first glance they dont seem to be doing anything weird)
02:39:28 <__dingbat__> dminuoso: hmm.. I completely understand your point. I am baffled as well. I dont have any other code interfering with this ..
02:40:05 <__dingbat__> u think I should get rid of the TVar inside the HM?
02:40:15 <ariakenom> __dingbat__: you've only answered half my questions. the publish STM action is missing no?
02:41:19 <__dingbat__> ariakenom: sorry I dont get what you mean..
02:41:39 <dminuoso> But yeah, this should really rather be some `newtype Subscribers t = Subscribers (TVar (H.Map t (Set NodeId)))`
02:42:09 <ariakenom> __dingbat__: there is only a get subscribers stm action in the paste. there is nothing adding subscribers
02:42:40 <ariakenom> dminuoso: why the outer TVar?
02:42:40 <__dingbat__> oh yes, I omitted it earlier, will add it too..
02:42:47 <dminuoso> __dingbat__: Are you really sure there's no unsafePerformIO (or equivalent) lingering around? The only way I can see this blow up, is if the map was a lazy thunk where evaluation triggered some unrelated atomically that blocks.
02:43:11 <dminuoso> ariakenom: Oh right. :)
02:43:52 <dminuoso> What if...
02:44:00 <dminuoso> This is not an stm block, but just some infinite loop you are tapping into?
02:45:43 <__dingbat__> there is no unsafePerformIO anywhere in the code
02:45:45 <ariakenom> dminuoso: yes. subs or yy make excellent candidates
02:45:58 <dminuoso> ariakenom: subs or yy?
02:46:15 <ariakenom> variables in subscribersfortopic
02:46:33 <dminuoso> Ah, yes.
02:46:47 <dminuoso> __dingbat__: Should be easy to check. Is your CPU running hot when the program appears to be stuck?
02:46:48 <ariakenom> the set in yy too
02:47:23 <__dingbat__> sorry I dont follow about the variables subs & yy, what about them?
02:47:24 <dminuoso> ariakenom: or the `t`
02:47:28 <__dingbat__> no CPU is idling
02:47:41 <dminuoso> __dingbat__: Can you run this from GHCi?
02:48:26 <mniip> dminuoso, sometimes GHC would optimize out infinite loops
02:48:30 <ariakenom> is it compiled with -threaded?
02:48:33 <mniip> it's done that in our production builds
02:48:51 <dminuoso> mniip: Heh really. What does it generate then?
02:49:11 <mniip> the thread just gets garbage collected
02:49:18 <comerijn> Is there a nice fold for building maps that produces an error on duplicate keys?
02:49:35 <mniip> I haven't investigated too deeply but I accidentally left a `x = x` thing in code once
02:49:38 <mniip> it did not use 100% cpu
02:49:44 <comerijn> mniip: That doesn't sound like optimised out
02:49:58 <comerijn> mniip: That sounds like it just threw <<loop>> and then the thread exited due to uncaught exception
02:50:02 <mniip> it did not use cpu at all, it just didn't reply to the HTTP request and went on with its business
02:50:17 <__dingbat__> It doesnt run in GHCi, I am a haskell noob and unable to get it to run
02:52:06 <dminuoso> mniip: I tend to agree with comerijn here. Im not sure how GHC could optimize an infinite loop away into anything but <<loop>> exceptions.
02:52:46 <kuribas> we have a (java) timer library which collects timing information (possibly nested), then allows you to output a json object with all the information.  How would a haskell version look?  Perhaps a Timing monad transformer, then using unsafePerformIO to get the timing information (after evaluating to WHNF)?
02:53:09 <comerijn> <<loop>> isn't even an optimisation, it's just opportunistic error detection
02:53:24 <dminuoso> comerijn: One could say its a power-efficiency optimization. ;)
02:53:33 <dminuoso> You still bottom out, after all.
02:53:36 <comerijn> dminuoso: Optimisations happen at compile time
02:53:43 <comerijn> dminuoso: <<loop>> detection is runtime
02:53:46 <dminuoso> comerijn: So? :)
02:53:47 <mniip> ok maybe there was an exception that was caught in an odd way
02:53:49 <mniip> can't say
02:54:15 <dminuoso> comerijn: I think it's a bit too rigid to state "all optimizations happen at compile time"
02:54:26 <dminuoso> It's a just-in-time optimization of sorts! :p
02:54:59 <comerijn> Anyway, back to more interesting issues, like my question of: How to build a Map with sanity checking against duplicate keys
02:56:13 <merijn> Guess I'll just have to use a custom foldM
02:57:10 <dminuoso> merijn: Why a custom foldM? Whats wrong with the one from base?
02:57:31 <merijn> dminuoso: Well custom folding function, I mean
02:57:50 <merijn> Seems weird that there's no error-handling construction function for Map :\
02:58:07 <kuribas> merijn: you want an error when a key is already in the map?
02:58:13 <merijn> kuribas: Yes
02:58:17 <dminuoso> merijn: You could use `insertWith (const Nothing) k (Just v)`
02:58:35 <merijn> dminuoso: No, that doesn't give an error
02:58:45 <dminuoso> Ah
02:58:54 <dminuoso> So you want to short-circuit on the first duplicate?
02:59:29 <merijn> My input shouldn't have any duplicates, unless something's horribly fucked, so I would like to detect if something is, indeed, horribly fucked
02:59:47 <merijn> Given that said input comes from python code and is therefore utterly untrustworthy
03:00:20 <dminuoso> merijn: Do you need this in a streaming fashion? Or couldn't you just validate the data beforehand?
03:00:51 <kuribas> merijn: you can compare the length of the input and the length of the map
03:01:23 <merijn> dminuoso: Well, the only way to detect duplicates that way is to loop over it with a Set, so I might as well just do it once while constructing...
03:06:36 <dminuoso> __dingbat__: Try inserting an exception handler around it to see if an exception is thrown perhaps.
03:09:43 <kuribas> merijn: no, you only need to compare the length
03:09:55 <kuribas> merijn: if there are no duplicates, the  lengths are the same
03:11:15 <kuribas> merijn: if there are duplicates, the map is smaller than the input
03:47:34 <merijn> kuribas: Sure, but that'd still be walking the list twice
03:47:44 <merijn> Anyway
03:50:05 <kuribas> merijn: you want to stream it?
03:50:56 <kuribas> you could use the foldl library
04:19:52 <dminuoso> insertWithM :: (Monad m, Ord k) => (a -> a -> m a) -> k -> a -> Map k a -> m (Map k a);
04:19:57 <dminuoso> merijn: Something like this is what you need, right?
04:28:45 <merijn> dminuoso: Yeah, or MonadPlus, I suppose, I'm just writing my own "a 
04:37:10 <dminuoso> merijn: Mmm, its a bit said that you cant implement it efficiently (since Map constructors are not exposed)
04:55:44 * hackage mmsyn2 0.1.6.1 - The library that can be used for multiple (Ord a) => a -> b transformations  https://hackage.haskell.org/package/mmsyn2-0.1.6.1 (OleksandrZhabenko)
05:03:14 * hackage mmsyn3 0.1.2.0 - A small library to deal with executable endings  https://hackage.haskell.org/package/mmsyn3-0.1.2.0 (OleksandrZhabenko)
05:07:14 * hackage mmsyn4 0.1.2.0 - The "glue" between electronic tables and GraphViz  https://hackage.haskell.org/package/mmsyn4-0.1.2.0 (OleksandrZhabenko)
05:08:42 <ariakenom> BlockArguments is real nice
05:10:38 <Rembane> ariakenom: Do you avoid all parentheses nowadays?
05:11:31 <EvanR> zero parenthetical footprint
05:17:04 <ariakenom> Rembane: no. I just removed some $ do
05:20:04 <EvanR> "what will you do with all your extra $ now that you no longer need them"
05:20:42 <EvanR> allowing multiple do blocks in a row without parens is pretty cool
05:20:51 <ariakenom> very punny
05:22:11 <Rembane> ariakenom: Very nice 
05:22:22 <Rembane> EvanR: Put them in my trunk! 
05:23:08 <EvanR> avoiding $ is good in so far as $ is some sort of mutant hack 
05:23:20 <EvanR> for whatever reason
05:23:52 <opqdonut> $ can't buy happiness
05:24:48 <c_wraith> well, the levity polymorphism stuff removed one of the $ hacks.   There's a GHC proposal active right now that might remove the other $ hack.
05:25:09 <dminuoso> You mean the impredicativity hack?
05:25:12 <c_wraith> yeah
05:25:21 <Rembane> What does that hack do?
05:25:27 <dminuoso> Rembane: Consider runST
05:25:29 <dminuoso> % :t runST
05:25:29 <yahb> dminuoso: (forall s. ST s a) -> a
05:25:35 <dminuoso> % :t ($)
05:25:35 <yahb> dminuoso: (a -> b) -> a -> b
05:25:51 <c_wraith> in practice the hack roughly inlines fully-saturate $ before type-checking
05:26:04 <Rembane> c_wraith: Got it! 
05:26:15 <c_wraith> *saturated
05:26:31 <Rembane> dminuoso: Should I see something in those types, or will there be more? :)
05:26:48 <dminuoso> Rembane: Nevermind. :)
05:26:58 <dminuoso> Rembane: Wasn't sure whether you knew the underlying issue.
05:28:29 <c_wraith> I'm not sure the current-proposed impredactive instantiation work would actually remove that hack.
05:29:19 <c_wraith> It would probably mean you'd need to enable an extension to get the current behavior for ($), which might be seen as too much of a regression
05:29:57 <c_wraith> Then again, it might be seen as a fix instead of a regression :)
05:31:34 <c_wraith> On the other hand, if we're making that claim, BlockArguments also fixes the runST issue so the $ hack isn't needed so much anymore...
05:32:36 <dminuoso> c_wraith: Can you elaborate what you mean by "inlining fully saturated ($)"?
05:34:11 <c_wraith> sure.  the hack is just that (exp1 $ exp2) is converted to ((exp1) (exp2)) internally before type checking.  This avoids instantiating type parameters for ($) at all.
05:35:15 <dminuoso> c_wraith: Ah. What triggers that? Merely matching exp1 against runST?
05:35:29 <c_wraith> No, there's nothing runST-specific in the hack
05:36:21 <c_wraith> It's just all uses of ($) which provide two arguments syntactically.
05:36:43 <Rembane> dminuoso: ^^
05:38:56 <dminuoso> % :t blah
05:38:57 <yahb> dminuoso: (forall (a :: k). Const Int a) -> Int
05:39:04 <dminuoso> % blah $ Const 1
05:39:04 <yahb> dminuoso: 1
05:39:31 <dminuoso> c_wraith: Ah interesting, so its a ($) specific hack, but it was mainly tailored for runST. :)
05:39:37 <c_wraith> yep
05:40:11 <c_wraith> % blah `id` Const 1
05:40:11 <yahb> c_wraith: ; <interactive>:113:1: error:; * Couldn't match type `forall (a :: k0). Const Int a' with `Const Integer b0'; Expected type: Const Integer b0 -> Int; Actual type: (forall (a :: k0). Const Int a) -> Int; * In the first argument of `id', namely `blah'; In the expression: blah `id` Const 1; In an equation for `it': it = blah `id` Const 1
05:40:33 <c_wraith> note that id does not have that hack. :)
05:42:38 <EvanR> :t runSt $ (return 0)
05:42:40 <lambdabot> error:
05:42:40 <lambdabot>     • Variable not in scope: runSt :: m0 Integer -> t
05:42:40 <lambdabot>     • Perhaps you meant ‘runST’ (imported from Control.Monad.ST)
05:42:48 <EvanR> :t runST $ (return 0)
05:42:49 <lambdabot> Num a => a
05:43:01 <EvanR> :t runST `is` (return 0)
05:43:02 <lambdabot> error:
05:43:02 <lambdabot>     • Cannot instantiate unification variable ‘t0’
05:43:02 <lambdabot>       with a type involving foralls: (forall s. ST s a0) -> a0
05:43:04 <dminuoso> EvanR: These redundant parens.
05:43:10 <dminuoso> EvanR: You should be ashamed.
05:43:26 <c_wraith> not even using them to conserve $
05:43:54 <EvanR> ((runST)) `(id)` ((return) (00))
05:44:08 <c_wraith> pretty sure that's a syntax error
05:44:13 <EvanR> yeah
05:44:21 <c_wraith> backticks only work with identifiers, not expressions
05:44:23 <EvanR> we need an extension to nest `` and ()
05:44:39 <c_wraith> I think that introduces ambiguity to the grammar
05:44:49 <EvanR> i'm not serious
05:45:15 <EvanR> :t runST `id` return 0
05:45:17 <lambdabot> error:
05:45:17 <lambdabot>     • Couldn't match type ‘forall s. ST s t’ with ‘m0 Integer’
05:45:17 <lambdabot>       Expected type: m0 Integer -> t
05:46:03 <dminuoso> c_wraith: Its interesting that the error does not mention anything about impredicative types./
05:46:07 <dminuoso> (I mean from above)
05:46:15 <dminuoso> % blah `id` Const 1
05:46:15 <yahb> dminuoso: ; <interactive>:114:1: error:; * Couldn't match type `forall (a :: k0). Const Int a' with `Const Integer b0'; Expected type: Const Integer b0 -> Int; Actual type: (forall (a :: k0). Const Int a) -> Int; * In the first argument of `id', namely `blah'; In the expression: blah `id` Const 1; In an equation for `it': it = blah `id` Const 1
05:46:42 <dminuoso> I mean it requires some pretty good knowledge to understand why these two cant match..
05:46:57 <dunce> hello friendos
05:47:06 <dminuoso> otoh the mention of impredicative types only helps if you already understand them..
05:47:17 <c_wraith> exactly.  that's the reason it doesn't mention it
05:47:54 <c_wraith> as I tried to explain before, the problem many people have with GHC's error message isn't that the messages are poorly written, it's that the ideas are complicated.
05:51:28 <mjrosenb> IIRC, someone wrote a pair of operators, </ and /> in ocaml that could be use to "infixify" any expression. could probably do the same in haskell, but you wouldn't be able to change the precedence.
05:51:39 <EvanR> heh, mailing list on BlockArgument has a post from somebody who laments that this is a backwards compatible extension and doesn't make the behavior default. Haskell is becoming too conservative
05:52:34 <dminuoso> Haha. Haskell already is at the top of "willing to make breaking changes" when it comes to APIs.
05:53:33 <EvanR> "how hard do you add this to haskell"
05:53:38 <EvanR> KABOOM
06:02:24 <syd> Anyone familiar with `brick` here?
06:03:35 <dminuoso> syd: Ask your question instead of asking meta questions. You have a higher chance of success! :)
06:03:44 <syd> hah, fair point
06:03:48 <lavalike> but what chance of meta-success?
06:03:51 <syd> I'm trying to make a 2D map
06:04:05 <syd> so a worldmap that is empty but has one dot on it
06:04:10 <syd> on given coords (col, row)
06:04:20 <syd> with (0,0) in the middle
06:04:50 <dunce> So I'm looking at foldr/l stuff and have this `foldNatL f z n = if n < 1 then z else foldNatL f (f z) n`
06:05:00 <dunce> I need to write a factorial using that 
06:05:16 <dunce> `fac n = fst (foldNatR f (1,0) n) where (fac_n, n) = (fac_n * n, n + 1)`
06:05:28 <dunce> im confused on the (1,0) part
06:05:40 <syd> and I can use `showCursor` to put the _blinking cursor_ in the right place
06:05:48 <syd> but I can't seem to put a _character_ in the right place
06:07:03 <dminuoso> dunce: Look at how foldNatL is implemented.
06:07:39 <dunce> isnt f a function in foldr though?
06:07:43 <dunce> why is it in a tuple
06:08:01 <dminuoso> foldNatL f z n = ... foldNatL f (f z) n
06:08:10 <dminuoso> dunce: ^- do you see this? (Ive removed the if expression to focus on the remaining part)
06:08:21 <EvanR> blurg matrix.org
06:08:58 <dminuoso> % foldNatL f z n = if n < 1 then z else foldNatL f (f z) n
06:08:58 <yahb> dminuoso: 
06:09:00 <dminuoso> % :t foldNatL
06:09:00 <yahb> dminuoso: (Ord t1, Num t1) => (t2 -> t2) -> t2 -> t1 -> t2
06:09:30 <c_wraith> that definition of factorial used foldNatR, not foldNatL
06:09:37 <dminuoso> Oh my bad
06:09:58 <dminuoso> Fundamentally it doesn't really change much anyway.
06:10:09 <dminuoso> But its a fair point :P
06:10:23 <c_wraith> I think that might actually be the point of confusion, if those two have different argument orders
06:10:32 <dminuoso> Ah, perhaps 
06:11:01 <dminuoso> c_wraith: It would match with foldNatL though.
06:12:20 <dunce> I dont have a deffinition of foldNatR
06:12:21 <dunce> lol
06:12:32 <dunce> its not a library function right?
06:12:42 <dminuoso> It might be for one of your libraries?
06:12:45 <dminuoso> Its definitely not in base.
06:14:14 <dunce> no lol this is just some text file this guy wrote lol
06:14:23 <dunce> we have no libraries 
06:14:42 <dunce> I'm going to just ignore this and try and use normal foldr to write a factorial
06:15:06 <EvanR> this form of fold on Nats (iteration) is going to require tuples a lot of the time to get anything done
06:15:18 <EvanR> there is one that makes things more convenient (recursion)
06:15:36 <EvanR> it just passes the predecessor to the f as well
06:16:14 <c_wraith> ie, paramorphism on Nat is more convenient than catamorphism
06:16:39 <c_wraith> Even though they're of equivalent power in recursion theory
06:17:06 <c_wraith> :t foldNatR
06:17:08 <lambdabot> (a -> a) -> a -> Int -> a
06:17:45 <dmwit> syd: Well... what have you tried?
06:17:56 <syd> I've tried all sorts of things
06:17:58 <syd> the thing I'm trying now
06:18:06 <syd> is to make a multi-line string that represents the map
06:18:09 <syd> and then just showing that
06:18:15 <syd> but that's a bit complex
06:18:27 <syd> and it wolud be nice if I didn't have to do that 
06:18:48 <dmwit> Sounds pretty reasonable to me, honestly.
06:19:03 <syd> I'll try :
06:19:14 * hackage data-interval 2.0.0 - Interval datatype, interval arithmetic and interval-based containers  https://hackage.haskell.org/package/data-interval-2.0.0 (MasahiroSakai)
06:25:00 <dunce> is this: Prelude> :t foldl1foldl1 :: Foldable t => (a -> a -> a) -> t a -> athe same as foldl`
06:25:02 <dunce> ?
06:25:15 <dunce> oh sorry the returns got messed up
06:25:32 <dunce> anyway t: foldl' gives me an out of scope error
06:25:32 <ski> > foldl1 (+) []
06:25:34 <lambdabot>  *Exception: Prelude.foldl1: empty list
06:25:46 <ski> > foldl' (+) 0 []
06:25:48 <lambdabot>  0
06:26:18 <dunce> relude> :t foldl'  <interactive>:1:1: error   • Variable not in scope: foldl'
06:26:25 <dunce> thats what I mean
06:26:54 <ski> @index foldl'
06:26:54 <lambdabot> Data.Foldable, Data.List, GHC.OldList, Data.ByteString.Lazy.Char8, Data.ByteString.Lazy, Data.ByteString.Char8, Data.ByteString, Data.IntMap.Strict, Data.IntMap.Lazy, Data.IntMap, Data.IntSet, Data.
06:26:55 <lambdabot> Map.Lazy, Data.Map.Strict, Data.Map, Data.Set
06:27:14 <dunce> oh ok you need to import it
06:27:15 <ski> try `:m + Data.List' ?
06:27:47 <dunce> this is supposed to be hard to understand at first right '=D 
06:28:49 <c_wraith> I'm not sure who the authority on "supposed to be" is, but...  Yeah, it was a challenge for a while.  :)
06:30:20 <EvanR> dunce: just play around in ghci, look at types, and try to explain stuff that is happening until it's predictable
06:31:15 <c_wraith> dunce: but don't worry, eventually you'll think words like "paramorphism" and "catamorphism" are totally normal things describing useful ideas! :)
06:31:16 <EvanR> i still haven't been able to pull this off in most languages
06:31:55 <dunce> :') 
06:32:06 <dunce> gana tank tomorrow lol
06:32:44 <EvanR> you have a test or something ?
06:34:28 <dunce> idk man 
06:34:30 <dunce> i guess
06:34:55 <dunce> this whole thing is scuffed 
06:38:15 * hackage data-interval 2.0.1 - Interval datatype, interval arithmetic and interval-based containers  https://hackage.haskell.org/package/data-interval-2.0.1 (MasahiroSakai)
06:38:34 <dunce> https://gist.githubusercontent.com/FreezeSnail/1afe619be41937cd56a8457bb424bcc8/raw/847a2b491f6d3dbae2dae9c040313f0921f63fc3/gistfile1.txt
06:39:11 <dunce> So the given one doesnt work 
06:39:24 <dunce> unless I'm loosing my mind lol
06:39:47 <dunce> 1* 0, 0*1, 0*2, ... 0* n+1
06:40:01 <c_wraith> oh, hah. yes
06:40:08 <c_wraith> the first one will always return 0
06:40:14 <c_wraith> that's actually a common mistake
06:40:29 <dunce> this is such a joke man
06:40:43 <dunce> shouldn't be having to figure out all the mistakes in the answers '=D 
06:41:13 <dminuoso> dunce: Perhaps its a good indicator you should pick a different learning resource then.
06:41:15 <c_wraith> At least it's effective.  If you're correcting the "answers", you know that you actually know the material
06:41:44 <dminuoso> Somewhat sure, but it makes the resource ineffective because it doesn't keep you on track of what its trying to teach.
06:42:00 <dminuoso> But I guess working out bugs can be helpful
06:42:08 <c_wraith> Oh, it's certainly not an endorsement of the material
06:42:10 <dunce> I cant use a different source this is what my test is based off of :') 
06:42:25 <dunce> I can't wait for the graders to grade everything wrong
06:43:01 <dunce> its really a shame because I like math and this would probably be pretty enjoyable If i was learning it naturally out of interest
06:44:03 <c_wraith> ah, memories of huffman trees.  I handled the single-symbol alphabet correctly, the grader didn't understand why my program only included the tree and length, and not bits for each character in the input, despite my program demonstrably giving correct ouptput.
06:44:07 <EvanR> these are some quite metaeducational gripes now
06:45:23 <dunce> dont talk about huffman trees I'm still sore from butchering the language to get that ast to work 
06:45:31 <dunce> '=D 
06:46:35 <dunce> for this, > `sum1 = foldr (+) 0` > `try1 = sum1 veryBigList`
06:47:07 <dunce> isnt this just boiling down to 'sum1 = foldr (+) 0 verybiglist'
06:47:16 <Rembane> Yes! 
06:47:21 <Rembane> If > means next step
06:47:37 <dunce> yes
06:47:57 <dunce> im confused on how that works lol
06:48:28 <dunce> shouldnt it have to be `suml xs = foldr (+) 0 xs`
06:48:51 <dunce> I guess the interpreter handles that?
06:49:48 <Rembane> dunce: It does, have you internalized that you can use equational reasoning in Haskell?
06:51:11 <dunce> im not sure what you mean
06:51:16 <dunce> rn my brain is thinking of an inline function in c
06:51:43 <dunce> so the interpreter just dumps suml's contencts where its called.
06:51:48 <ariakenom> dunce: you meant this? try1 = foldr (+) 0 verybiglist
06:52:06 <dunce> im not really sure whats the point tho
06:52:16 <ariakenom> sum1 is not the same as try1
06:52:43 <dunce> I just ment the stuff after the = 
06:52:51 <dunce> sorry I'm not very articulate 
06:52:59 <dunce> how about this, 
06:54:08 <dunce> whats the advantage of writing it like that as 2 functions
06:54:21 <dunce> I think I'm just getting held up on the example.  
06:54:33 <dminuoso> dunce: equational reasoning means that if you see something like `sum1 = foldr (+) 0 verybiglist` then you can replace occurences of the left-hand side with the right-hand side (with values bound to variables accordingly) with no change of meaning.
06:54:43 <dminuoso> (Or the other way around, you can replace the right-hand side with the left hand side)
06:54:56 <dunce> like I'd write, `suml n = foldr (+) 0 [1..n]`
06:54:57 <dminuoso> So really in a lot of sense, declarations can be thought of as equations
06:55:08 <dunce> I do know that will overflow for a large n
06:55:16 <dminuoso> (Incidentally this mindmodel can be used to understand how things get evaluated)
06:55:31 <ariakenom> > 10^123
06:55:34 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
06:55:41 <Rembane> We ran out of zeroes. :(
06:55:44 <dunce> lol
06:55:56 <ariakenom> overflow? whats that? :p
06:56:17 <Rembane> > (10^123) :: Int
06:56:20 <lambdabot>  0
06:56:23 <Rembane> :D
06:56:58 <ariakenom> 10^123 :: Float
06:57:01 <ariakenom> > 10^123 :: Float
06:57:03 <lambdabot>  Infinity
06:59:00 <jusss> https://paste.ubuntu.com/p/KRr3ngZyWT/
06:59:08 <jusss> why this l is not in scope?
06:59:46 <dminuoso> jusss: Because the `l` is only available inside inside the do-expression following the line `l <- getLine`
07:00:04 <dminuoso> jusss: a where group can only reference identifiers bound in the declaration it belongs to, and outside of that.
07:00:17 <dminuoso> so `foo l = ... where m = l` is valid
07:00:29 <ski>   message <- getLine
07:00:30 <dminuoso> `foo = bar $ \l -> ... where m = l` is not.
07:00:32 <ski> or use `let'
07:01:22 <dminuoso> jusss: And indeed, if you desugar the do-expression you end up with something like `main = getLine >>= \l -> ... where ... message = l`
07:01:30 <dminuoso> Hopefully its clear from that, that its not valid.
07:01:54 <jusss> dminuoso: ok
07:02:31 <ariakenom> let is probably easier than where
07:03:22 <jusss> ski: I follow you said, change l to message, but I get another issue https://paste.ubuntu.com/p/nYHqMMnXY5/
07:03:54 <jusss> there's Data.Text.Internal.Text?
07:04:06 <jusss> I can't import this in ghc 8.6.5
07:04:57 <dmwit> You need to either use the text package's getLine, or call pack on the result of Prelude's getLine.
07:05:00 <dunce> `foldtree f z (Bin l x r) = f (foldtree f z l) (foldtree f z r) x`  I need to define my own add right?  I tried using (+) and it didnt work out lol
07:05:54 <dmwit> Yes. You may use a lambda to avoid giving it a name if that pleases you.
07:05:59 <jusss> dmwit: wow, there's two getLine? how I can point what I want?
07:06:14 <jusss> either.getLine?
07:07:12 <dmwit> jusss: In https://stackoverflow.com/a/8331995/791604 I describe how to use the module system. Read until "Here ends the bare basics you need to understand about the module system.".
07:15:47 <jusss> dmwit: I have read it
07:17:39 <jusss> dmwit: how I can know getLine is in text pacakge or not?  http://hackage.haskell.org/package/text-1.2.4.0/docs/Data-Text-IO.html
07:17:53 <jusss> I found it in hackage website, but this is a good way?
07:19:11 <ariakenom> jusss: hoogle is useful https://hoogle.haskell.org/?hoogle=getline&scope=set%3Astackage
07:19:40 <dunce> `Expected type: p -> p -> a -> p Actual type: (a -> p) -> (a -> p) -> a -> p` is the error
07:30:07 <dminuoso> Mmm, is there something as elegant and composable as optparse-applicative for config files?
07:31:42 <ariakenom> use optparse as the config format? :) 
07:32:27 * geekosaur often does that kind of thing, setting the option prefix to the empty string
07:32:31 <tabaqui1> you can run optparse-applicative on any [String] input
07:32:37 <MarcelineVQ> dminuoso: check out gluy's 2 config language packages
07:33:04 <MarcelineVQ> idr the name just now, it's something simple
07:33:13 <tabaqui1> but I prefer attoparsec or yaml(/aeson) for actual config files
07:33:27 <geekosaur> (and I have a perl hack that uses Getopt::Long that way and parses with override config file, environment variable, command line. as yet not had reason to do this to / in Haskell)
07:34:16 <dminuoso> tabaqui1: Well sure, but optparse really isnt well suited for it.
07:34:39 <dminuoso> I mean something that automatically generates man pages for the config file, akin to how optparse-applicative generates help pages, that'd be superb.
07:35:02 <dminuoso> MarcelineVQ: Are you talking about config-value?
07:35:11 <MarcelineVQ> ye
07:35:18 <MarcelineVQ> and config-schema maybe
07:51:54 <jusss> https://paste.ubuntu.com/p/mf7JGhkmxG/
07:52:31 <jusss> dmwit: I changed the getLine line, but how I can get string from command line
07:53:26 <jusss> I don't understand, why Prelude.getLine get a String is fine, but that Data.Text.IO get Text type
07:55:12 <jusss> I know what's wrong with this case, command line buffer
07:55:39 <jusss> why not just disable that command line buffer feature
07:55:55 <geekosaur> windows offers the whole command line as a string; unix and os x do not
07:56:34 <geekosaur> the shell always pre-parses into "words" and you get a list of strings from the OS
07:59:00 <geekosaur> also, you can't get command line parameters as Text because they're ByteStrings with no particular interpretation. no, UTF8 is still not the law everywhere always
07:59:43 <jusss> geekosaur: how I can change this code? https://paste.ubuntu.com/p/mf7JGhkmxG/
08:00:05 <jusss> geekosaur: use Prelude.getLine to get String, and turn String to Text?
08:00:15 <jusss> so it can be used
08:00:29 <geekosaur> there's a "pack" operation in Data.Text
08:01:40 <geekosaur> :t T.pack
08:01:41 <lambdabot> String -> T.Text
08:11:22 <jusss> import Data.Text as T;  T.pack works
08:13:32 <dminuoso> tabaqui1: Can you elaborate on what you meant by that?
08:14:00 <dunce> `>flip' :: (a -> b -> c) -> (b -> a -> c)  >flip' f = g  where g x y = f y x`  why not just define this as `flip' f x y = f y x`
08:14:11 <tabaqui1> dminuoso: excuse me, by what?
08:14:32 <dminuoso> 16:32:09    tabaqui1 | you can run optparse-applicative on any [String] input
08:15:02 <tabaqui1> ah
08:16:04 <dunce> oh that was the next example lol nvm
08:16:40 <dminuoso> tabaqui1: I mean I understand what you are saying, but not how this approach would be useful.
08:17:11 <tabaqui1> well, I didn't understand at first what did you mean by "optparse for files"
08:18:18 <jusss> dminuoso: I don't understand, if I use `import qualified Data.Text.IO' so that getLine will still not be from Data.Text.IO?
08:18:19 <tabaqui1> basically, execParser is somewhat like "execParserPure prefs opts <$> getArgs", but is is not useful, because your config is hardly a bunch of flags
08:18:34 <fweht> how come the typescript typing system seems so expressive?  it doesnt look really sophisticated thought, at least i dont know of many papers or theory behind it while there is tons for haskell or haskell like languages...  is it because its more dirty, i.e. more dynamic typing involved?
08:18:46 <jusss> why I need let it `as P' then P.getLine
08:18:51 <tabaqui1> nevermind
08:21:35 <dminuoso> tabaqui1: Heh yeah. I mean I actually always use execParserPure (to make testing easier) :)
08:22:12 <dminuoso> fweht: its not really expressive
08:22:26 <dminuoso> fweht: Its tons less expressive, in fact.
08:22:59 <fweht> dminuoso: ok, then i didnt use haskell to its full potential...  but there are bits that look like dependent types to me
08:23:18 <dminuoso> fweht: Its definitely not dependent. :)
08:23:41 <MarcelineVQ> "<dminuoso> fweht: its not really expressive" which it?
08:23:48 <dminuoso> MarcelineVQ: TypeScript
08:24:51 <fweht> you can do things like `type MakeRecord<Keys, Type> = { [Key in keyof Keys]: Type };` where the resulting types depends on properties in the object `Keys`, isn't that kind of dependent typing?
08:25:22 <fweht> what would be the haskell equivalent?
08:25:31 <fweht> sorry if thats offtopic, feel free to ask me to leave
08:26:00 <dminuoso> fweht: So dependent typing would rather be something like...
08:26:33 <dminuoso> fweht: A vector which is not just parametrized by its content type, but a type level natural denoting its length - and every operation correctly changes the type to reflect the new size.
08:28:05 <fweht> dminuoso: yeah, i think the second part is the nontrivial one...  thats what i meant, on first glance typescript looks expressive because e.g. types constructors can take object arguments, but i guess it doesnt give you the safety as some *real* dependently typed language
08:29:12 <dminuoso> fweht: To quote some Idris ideas:
08:29:14 <dminuoso> data Vect : Nat -> Type -> Type where Nil : Vect Z a; (::) : a -> Vect k a -> Vect (S k) a
08:29:38 <dminuoso> This would be the equivalent of a haskell list which carries a type level natural denoting its length
08:30:23 <dminuoso> (++) : Vect n a -> Vect m a -> Vect (n + m) a; <here goes implementation>
08:31:23 <fweht> but the non-trivial part is that all type checking in idris occurs at compilation time
08:31:28 <fweht> and i dont know about typescript
08:31:33 <dminuoso> Right.
08:31:53 <dminuoso> Type checking a dependently typed language (one that has non-trivial semantics and features) is quite hard, apparently.
08:32:18 <fweht> so that was my initial question, is typescript only strong on first glance because most of the type checking occurs dynamically?
08:32:26 <fweht> or do i just know too little haskell
08:32:37 <dminuoso> The type checking doesnt occur dynamically, after the compiler is done its all gone.
08:32:50 <fweht> oh yeah, right
08:32:53 <maerwald> it's just that you have a lot of gaps via 'any'
08:33:05 <fweht> yes, so its not that safe
08:33:05 <maerwald> json parsing returns 'any' etc
08:33:08 <dminuoso> fweht: I think its just some syntax sugar to reduce boilerplating.
08:33:18 <fweht> ok makes sense
08:33:29 <maerwald> fweht: however, I get much more done in typescript than in haskell... I think the two reasons are: 1. tooling and 2. structural typing is just very convenient
08:33:35 <dminuoso> But indeed, the presence of `any` makes typescript extremely weak.
08:33:37 <maerwald> but I generally trust a typescript codebase a little less
08:34:08 <fweht> i see
08:34:40 <dminuoso> fweht: I recommend giving Pierces Types and Programming Languages section 1.3 a quick read.
08:34:58 <dminuoso> fweht: It describes nicely why retrofitting a type system usually doesnt yield good results
08:35:19 <fweht> great, will do!
08:35:36 <dminuoso> (In fact the entire book is a brilliant read if you want to know more about type systems)
08:35:56 <fweht> 👍
08:36:19 <dminuoso> It's a shame that PragmataPro doesn't have glyphs for emojis. :(
08:37:11 <MarcelineVQ> :thumbsup:
08:37:16 <MarcelineVQ> maerwald, dminuoso: if you've an interest in avoiding 'any' json https://arxiv.org/pdf/1808.09234.pdf :>
08:47:47 <dminuoso> MarcelineVQ: Cheers, looks like an interesting read.
08:48:23 <dminuoso> % import Data.Binary.Put
08:48:24 <yahb> dminuoso: 
08:48:51 <dminuoso> % newtype PutR a = PutR { runPutR :: ReaderT Int -> PutM a }
08:48:51 <yahb> dminuoso: ; <interactive>:120:36: error:; * Expecting two more arguments to `ReaderT Int'; Expected a type, but `ReaderT Int' has kind `(k0 -> *) -> k0 -> *'; * In the type `ReaderT Int -> PutM a'; In the definition of data constructor `PutR'; In the newtype declaration for `PutR'
08:48:58 <dminuoso> % newtype PutR a = PutR { runPutR :: ReaderT Int PutM a }
08:48:58 <yahb> dminuoso: 
08:49:18 <dminuoso> Is there a common idiom how to lift say `put` into that?
08:49:36 <dminuoso> (Because of the newtype layer I cant use ReaderT's MonadTrans instance)
08:50:46 <geekosaur> can't you derive MonadTrans?
08:51:15 <dminuoso> geekosaur: PutR is not a monad transformer
08:51:15 <glittershark> well `instance MonadTrans PutR` wouldn't be well-kinded
08:51:37 <glittershark> MonadTrans :: ((Type -> Type) -> (Type 
08:51:45 <glittershark> MonadTrans :: ((Type -> Type) -> (Type -> Type)) -> Constraint
08:52:02 <glittershark> you could `coerce put`
08:52:39 <dminuoso> glittershark: You mean `coerce (lift put)`, right?
08:53:01 <dminuoso> % :t coerce put :: PutR ()
08:53:01 <yahb> dminuoso: ; <interactive>:1:1: error:; * Couldn't match representation of type `Data.Binary.Put.PairS ()' with that of `m0 ()' arising from a use of `coerce'; * In the expression: coerce put :: PutR ()
08:53:16 <dminuoso> % :t coerce (lift put) :: PutR ()
08:53:16 <yahb> dminuoso: ; <interactive>:1:1: error:; * Couldn't match representation of type `Int -> PutM ()' with that of `t0 ((->) s0) (m0 ())' arising from a use of `coerce'; * In the expression: coerce (lift put) :: PutR ()
08:53:23 <dminuoso> oh
08:53:58 <dminuoso> % :t coerce (put ()) :: PutR () -- glittershark 
08:53:58 <yahb> dminuoso: ; <interactive>:1:1: error:; * Couldn't match representation of type `Int -> PutM ()' with that of `m0 ()' arising from a use of `coerce'; * In the expression: coerce (put ()) :: PutR ()
08:54:32 <dminuoso> There's no MonadPut beneath (otherwise I could get that from GeneralizedNewtypeDeriving)
08:57:44 <dminuoso> I mean I can of course write `liftP = PutR . ReaderT . const` - but surely there has to be some way without handwriting this.
09:04:15 <glguy> PutR . lift ?
09:08:14 <dminuoso> glguy: Oh. Indeed. :o
09:08:46 <dminuoso> % :t coerce lift put :: PutR ()
09:08:46 <yahb> dminuoso: ; <interactive>:1:1: error:; * Couldn't match representation of type `Int -> PutM ()' with that of `t0 m1 a0' arising from a use of `coerce'; * In the expression: coerce lift put :: PutR ()
09:08:58 <dminuoso> Why doesn't that type check then though?
09:09:05 <dminuoso> I mean there's just a newtype wrapper in between
09:19:31 <ClaudiusMaximus> maybe roles?  eg i don't think you can `coerce :: Set a -> Set b` when a and b have different Ord instances
09:21:14 * hackage haskoin-core 0.9.3 - Bitcoin & Bitcoin Cash library for Haskell  https://hackage.haskell.org/package/haskoin-core-0.9.3 (xenog)
09:22:14 * hackage miso 1.3.0.0 - A tasty Haskell front-end framework  https://hackage.haskell.org/package/miso-1.3.0.0 (DavidJohnson)
09:23:14 * hackage miso-examples 1.3.0.0 - A tasty Haskell front-end framework  https://hackage.haskell.org/package/miso-examples-1.3.0.0 (DavidJohnson)
09:31:20 <dmwit> justanotheruser: What goes wrong with the code you pasted and asked me about? It looks fine to me. Maybe you need Data.Text.Lazy.IO instead of Data.Text.IO but otherwise that should work fine.
09:32:27 <dmwit> justanotheruser: Sorry, misnick.
09:32:50 <dmwit> (The right person is gone and tab-complete tricked me.)
09:41:23 <M0b10s> hey guys! quick one...how can i compare a data type created by me without using pattern matching?
09:42:34 <lyxia> uh, you can't
09:42:45 <M0b10s> ;D
09:42:48 <dsal> M0b10s: compare in what way?
09:44:02 <M0b10s> imagine i have a list of type "data Movimento = Norte | Sul | Este | Oeste deriving Show" i was trying to compare the head of the list to one of those movements 
09:46:00 <dminuoso> M0b10s: In what sense do you want to compare?
09:48:04 <M0b10s> dminuoso, say i'm building a recursive... i will receive a (x,y) "(Int,Int)" and for the list the func receives i will alter the (x,y) state... 
09:48:58 <M0b10s> " posicao (x,y) (Norte:t) = posicao (x,y+1) t " for example... moves y+1 
09:49:09 <dminuoso> M0b10s: Just like that.
09:49:21 <dminuoso> M0b10s: You could use StateT/State to make the plumbing a bit easier if you want.
09:49:44 <M0b10s> how does that work?
09:50:17 <dminuoso> M0b10s: Then you could have a function `f :: Movimento -> State (Int, Int)`
09:50:43 <dminuoso> And then just traverse with that function over your list, `traverse_ f directions`
09:51:22 <M0b10s> i see...i would have to build an auxiliary one... so there is no other was besides that...
09:51:46 <dminuoso> M0b10s: Well this is actually advantageous because you can separate the function mapping Movimento to State actions.
09:52:51 <dminuoso> % data Movimento = Norte | Sul | Este | Oeste deriving Show
09:52:51 <yahb> dminuoso: 
09:53:47 <M0b10s> it need's to be done in one single func but they say that i can build auxiliar so =D thumbs up :dminuoso!! 
09:55:51 <dminuoso> % :q
09:55:51 <yahb> dminuoso: 
09:57:27 <dminuoso> % foo = _snd %= (+1)
09:57:27 <yahb> dminuoso: ; <interactive>:1:1: error:; GHC internal error: `Ghci4.$trModule' is not in scope during type checking, but it passed the renamer; tcl_env of environment: [r1pY0 :-> Identifier[foo::forall s (m :: * -> *). MonadState s m => m (), TopLevelLet]]
09:57:33 <dminuoso> Can someone explain to me what's happening with GHCi here?
09:59:01 <dminuoso> % f = _f
09:59:02 <yahb> dminuoso: ; <interactive>:1:1: error:; GHC internal error: `Ghci4.$trModule' is not in scope during type checking, but it passed the renamer; tcl_env of environment: [r1uNc :-> Identifier[f::forall t. t, TopLevelLet]]
09:59:21 <MarcelineVQ> just a ghc bug for that version
10:03:23 <lavalike> > let up = second succ; down = second pred; right = first succ; left = first pred; in (traverse_ (modify . (\x -> case x of 0 -> up; 1 -> right; 2 -> down; 3 -> left)) [1,1,1,0,0,0,3,3,2,2]) `execState` (0,0)
10:03:25 <lambdabot>  (1,1)
10:03:33 <dminuoso> lavalike: shush!
10:03:37 <lavalike> ^______^
10:03:56 <dminuoso> % :t second
10:03:57 <yahb> dminuoso: Arrow a => a b c -> a (d, b) (d, c)
10:04:09 <lavalike> :t Data.Bifunctor.second
10:04:10 <lambdabot> Bifunctor p => (b -> c) -> p a b -> p a c
10:04:15 <dminuoso> % f North = _2 %= (+1); f South = _2 %= subtract 1; f West = _1 %= (-1); f East = _1 %= (+1)
10:04:15 <yahb> dminuoso: 
10:05:23 <dminuoso> % evalState (traverse_ f [North, West, North, North, West, South]) (0,0)
10:05:23 <yahb> dminuoso: ; <interactive>:23:22: error:; * No instance for (Num (Integer -> Integer)) arising from a use of `f'; (maybe you haven't applied a function to enough arguments?); * In the first argument of `traverse_', namely `f'; In the first argument of `evalState', namely `(traverse_ f [North, West, North, North, ....])'; In the expression: evalState (traverse_ f [North, West, North, Nor
10:08:41 <dminuoso> % let f North = _2 %= (+1); f South = _2 %= subtract 1; f West = _1 %= (-1); f East = _1 %= (+1) in execState (traverse_ f [North, West, North, North, West, South]) (0,0)
10:08:41 <yahb> dminuoso: ; <interactive>:33:1: error:; * No instance for (Num (Integer -> Integer)) arising from a use of `it'; (maybe you haven't applied a function to enough arguments?); * In the first argument of `print', namely `it'; In a stmt of an interactive GHCi command: print it
10:08:50 <dminuoso> % let f North = _2 %= (+1); f South = _2 %= subtract 1; f West = _1 %= subtract 1; f East = _1 %= (+1) in execState (traverse_ f [North, West, North, North, West, South]) (0,0)
10:08:50 <yahb> dminuoso: (-2,2)
10:09:14 <dminuoso> Im quite bad at copy pasting. :(
10:11:26 <gaze__> Hey folks. If I run my program with +RTS -sstderr, I get "...  MUT     time   12.751s  ( 12.752s elapsed) ", which is correct. If I run with "+RTS -p" I get "total time  =        0.09 secs " which is of course nonsense.
10:11:31 <gaze__> any idea what's going on?
10:15:46 <dsal> gaze__: What do you mean?
10:16:34 <slack1256> Parallel program?
10:16:51 <gaze__> I think it's the profiler's interaction with the FFI... https://mail.haskell.org/pipermail/haskell-cafe/2018-August/129820.html
10:16:54 * slack1256 or time travel dun dun DUN
10:16:57 <gaze__> Oh well.
10:19:50 <dmwit> dminuoso: single :: Dir -> (Sum Int, Sum Int); single North = (0, 1); {- etc. -}; f = foldMap single
10:21:39 <dminuoso> dmwit: Cunning, I like it.
10:30:49 <M0b10s> 0.o u guys make me wanna cry x) looks easy after you do it... 
10:33:14 <dm9> What could be the reason that `cabal v2-build one-out-of-several-subprojects` compiles but `cabal v2-install one-out-of-several-subprojects` fails with "Could not resolve dependencies"?
10:33:33 <Ariakenom> M0b10s: I feel excited about when you will get that skilled!
10:35:55 <M0b10s> Ariakenom: working on it...mostly crying and screaming and hitting the keys yet x)
10:36:20 <Ariakenom> ahh the sounds of progress
10:42:14 * hackage polysemy 1.2.2.0 - Higher-order, low-boilerplate, zero-cost free monads.  https://hackage.haskell.org/package/polysemy-1.2.2.0 (isovector)
10:47:44 * hackage partial-records 0.2.2.1 - Template haskell utilities for constructing records with default values  https://hackage.haskell.org/package/partial-records-0.2.2.1 (mniip)
10:50:44 * hackage pickle 0.1.0.1 - Instant StatsD in Haskell  https://hackage.haskell.org/package/pickle-0.1.0.1 (Luabee)
11:04:14 * hackage pickle 1.0.0.0 - Instant StatsD in Haskell  https://hackage.haskell.org/package/pickle-1.0.0.0 (Luabee)
11:11:44 * hackage language-dot 0.1.1 - A library for the analysis and creation of Graphviz DOT files  https://hackage.haskell.org/package/language-dot-0.1.1 (BenGamari)
11:27:55 <jzyamateur> Is it possible to define functor for this type: `newtype Mu f = InF { outF :: f (Mu f) }` ? When I print out the kind of Mu, it is `(* -> *) -> *`, How do I go to `* -> *` ?
11:29:29 <lyxia> its kind is not * -> * so it can't be a Functor
11:30:35 <jzyamateur> Yeah but usually when we have something like ` * -> * -> * `, we define functor by adding an type variable e.g. `Either a` is `* -> *`. here I see ` ( * -> * ) -> *` which cannot be fixed right?
11:34:02 <slack1256> Curry at type level?
11:34:08 <slack1256> wait, nvm
11:36:09 <lyxia> jzyamateur: right
11:41:14 <slack1256> dm9: Maybe one of those projects was a dependency of that specific subproject?
11:56:47 <dm9> slack1256: the sub-projects are independent from one another ... the offending dependency has an entry `== 1.3.3.0 || == 1.3.4.0` in the `cabal.project.freeze` file, so maybe it's got something to do with that
11:57:38 <gaze__> if I'm looking for a high performance hash map, even at the expense of idiomaticity, what's the suggested implementation?
11:57:45 <gaze__> mutable, immutable, it's all good
11:57:57 <gaze__> just looking for the fastest thing I can use from haskell
12:07:53 <Ariakenom> gaze__: haskell has good C bindings. fast hashmaps probably have good C bindings.
12:14:37 <gaze__> I feel like I shouldn't have to go through the FFI to get a good hashtable?
12:14:49 <gaze__> ok maybe I should be more precise.
12:15:16 <gaze__> the fastest hashtable without writing bindings. looks like the hashtable package is very good.
12:17:05 <dmwit> I believe unordered-containers is the defacto standard.
12:17:09 <dmwit> It's pretty idiomatic.
12:19:15 <gaze__> ah okay excellent. Thanks!
12:19:31 <gaze__> yeah "defacto standard" is really what I was after.
12:19:41 <dmwit> I hadn't seen hashtables before. But if the effort put into its intro documentation is any indication, it is likely to be pretty good, too.
12:23:24 <gaze__> one other question... what's that function you use to back out the type of something? It just errors out if evaluated.
12:24:42 <fendor> gaze__, undefined?
12:24:48 <shapr> that function is undefined
12:24:52 * shapr makes a pun
12:25:08 <gaze__> I think I defined it pretty well...
12:25:14 <shapr> :-D
12:25:16 <gaze__> (lol thanks)
12:25:27 * shapr hugs gaze__
12:25:41 <dmwit> You may also like error, in case you want to specify a helpful message to print as you crash.
12:27:14 <shachaf> error has the additional benefit of being a function.
12:28:36 <shapr> ski: whatever happened to Saizan?
12:48:49 <Zemyla> So I think Map is an instance of Extend, and a hypothetical NonEmptyMap is a Comonad.
12:49:24 <sm> hmm.. why is this not "3.23" ?  ghci> (3 * 1.075, printf "%0.2f" (3 * 1.075) ::String) -> (3.2249999999999996,"3.22")
12:49:34 <Zemyla> :t extended
12:49:35 <lambdabot> error: Variable not in scope: extended
12:49:58 <Zemyla> @let import Data.Functor.Extend (Extend(..))
12:49:59 <lambdabot>  Defined.
12:51:01 <sm> though, this is:  (3 * 1.075, printf "%0.2f" (3 * 1.075 :: Float) ::String)  -> (3.2249999999999996,"3.23")
12:51:27 <sm> but then this is not: (3 * 1.075, printf "%0.2f" (3 * 1.075 :: Double) ::String) -> (3.2249999999999996,"3.22")
12:52:09 <dmwit> > 3 * 1.075 :: Float
12:52:11 <lambdabot>  3.2250001
12:52:13 <dmwit> > 3 * 1.075 :: Double
12:52:15 <lambdabot>  3.2249999999999996
12:52:20 <dmwit> sm: Does this answer the question?
12:52:38 <sm> so printf rounds a 5 digit downward ?
12:52:44 * hackage bulmex 2.1.0 - Reflex infused with bulma (css)  https://hackage.haskell.org/package/bulmex-2.1.0 (Jappie)
12:53:01 <dmwit> No, and also this isn't exactly halfway between two things.
12:53:14 <dmwit> So how printf rounds exact midpoints isn't relevant.
12:53:24 <dmwit> 3.2250001 is closer to 3.23 than to 3.22
12:54:00 <sm> well, in my usual dim way I mentally round starting from the rightmost digit. Doesn't that get me to 3.225 ? Which most often would become 3.23 ?
12:54:17 <dmwit> I don't know what "starting from the rightmost digit" means.
12:54:24 <dmwit> But rounding is not a thing you do repeatedly.
12:54:37 <Lycurgus> it's hard for people to grasp the diff between real and float
12:54:38 <dmwit> So, no, you never pass through 3.225 on the way to an answer.
12:54:51 <Lycurgus> but once you do finally get it ... .
12:55:21 <Lycurgus> these days most computers have floating point hardware
12:55:39 <Lycurgus> so it's more used and more of an issue maybe
12:55:45 <Lycurgus> slightly
12:55:49 <sm> I basically printf rounds differently from what I expected
12:55:54 <sm> I think
12:56:04 <dmwit> sm: I think your expectation is just broken.
12:56:05 <Lycurgus> no it's the type
12:56:12 <Lycurgus> as realized by hardware
12:56:23 <dmwit> sm: It would be weird and wrong to round to a number which is farther from the real answer than to a number which is closer to the real answer.
12:56:39 <dmwit> 1.500000000001 rounds to 2, not 1, every time.
12:56:56 <dmwit> (what to do with the exact value 1.5 is a different question. but 1.5000000000001 is not 1.5)
12:57:15 <sm> I guess it must be! I'll get some oxygen into the brain
12:58:55 <sm> thanks all
13:01:24 <Zemyla> :t \f m -> flip evalState [] $ flip M.traverseWithKey m $ \k a -> state $ \ls -> let { ls' = (k, a):ls; m' = M.fromDistinctDescList ls' } in (f m', ls')
13:01:25 <lambdabot> (M.Map k a -> b) -> M.Map k a -> M.Map k b
13:01:26 <dmwit> (There is a separate question of why 1.075*3 and is not exactly 3.225, of course, which is a longer topic, and whose short answer is "3.225 does not exist in either of the types Float or Double".)
13:01:30 <Zemyla> :t extended
13:01:31 <lambdabot> Extend w => (w a -> b) -> w a -> w b
13:02:09 <Zemyla> :t M.lookupMin
13:02:10 <lambdabot> M.Map k a -> Maybe (k, a)
13:05:34 <dmwit> :t \f m -> flip evalState M.empty $ flip M.traverseWithKey m $ \k a -> state $ \m' -> let m'' = M.insert k a m' in (f m'', m'')
13:05:36 <lambdabot> Ord k => (M.Map k a -> b) -> M.Map k a -> M.Map k b
13:06:06 <dmwit> Zemyla: ^ likely marginally more efficient, since fromDistinctDescList is O(n) but insert is O(log n).
13:22:11 <texasmynsted> if I installed a package via "cabal v2-install foo" and now want to uninstall it... Is this possible?
13:23:27 <dmwit> Not really.
13:23:40 <dmwit> You can delete the links to the executables it created.
13:23:59 <dmwit> But extricating the stuff it put in the store is complicated and doesn't currently have any UI to help with.
13:24:11 <geekosaur> v2-install normlly just creates a symlink; remove the symlink. the package itself… nether cabal nor stack allows uninstalling from their stores, at present
13:24:12 <dmwit> There are plans for a cabal v2-gc.
13:24:24 <geekosaur> last I heard, at least
13:24:44 <dmwit> Might be worth asking: why do you want to uninstall it?
13:25:33 <geekosaur> actually I found the store simple to poke around in and remove stuff, and did while diagnosing an issue that turned out to be "make it copy instead" (relative symlinks into folders that are themselves symlinked doesn't end well)
13:26:20 <geekosaur> that said, manually remove something that another package in the store depends on and I expect things can end badly
13:29:21 <texasmynsted> okay just removed the symlink 
13:29:23 <texasmynsted> good enough
13:44:33 <newhoggy> Anyone know of a way I can write some unit tests that loads some markdown files and checks they compile?
13:45:01 * newhoggy As in the markdown file contains snippets of Haskell and I want to check they compile.
13:51:07 <geekosaur> http://hackage.haskell.org/package/doctest ?
13:52:06 <newhoggy> Oh nice!
13:52:08 <newhoggy> Thanks!
14:17:14 * hackage eventlog2html 0.6.0 - Visualise an eventlog  https://hackage.haskell.org/package/eventlog2html-0.6.0 (mpickering)
14:19:53 <dsal> mpickering: Hey, that looks neat.
14:20:03 <dsal> Can that replace threadscope?
14:20:07 <koz_> Can someone tell me why GHC requires this pattern matching case? https://gist.github.com/kozross/9dc9c5d8bc26bdf02acff44db7d30d76
14:20:18 <mpickering> dsal: Not at the moment because it only visualises heap profiles
14:20:29 <mpickering> but in theory it could replace some uses of threadscope if someone would implement it
14:21:38 <dsal> I'd like to replace threadscope.  I've never got actual use out of it, but even to try, I've got a document that describes how I have to edit the binary distribution in order to run on my machine.
14:21:43 <dmwit> koz_: Because negative information (like "no constructors can have such-and-such type") is hard?
14:22:23 <dmwit> koz_: I mean the fact that the types of Basic and Higher can't be unified is pretty subtle.
14:22:57 <koz_> dmwit: Does that have something to do with the fact that '[t] is actually t ': '[]?
14:23:02 <dmwit> koz_: e.g. what is the type of `Higher () undefined`? Might it be possible to unify its type with `IndexOf [()]`?
14:23:40 <dmwit> sort of?
14:24:09 <dmwit> I mean, '[t] is *definitely* actually t ': '[]. The "sort of" is not whether that equality holds. The "sort of" is about whether that's relevant or not.
14:24:39 <koz_> dmwit: I figured.
14:24:40 <jle`> koz_: i think there it has to go through a few too many steps to deduce it
14:24:47 <jle`> koz_: but you can get ghc to be happy if you refactor it i think
14:24:53 <dmwit> But make it even simpler: `data Foo b where STrue :: Foo True; SFalse :: Foo False`.
14:25:02 <koz_> jle`: How would you suggest I refactor it?
14:25:03 <jle`> (==) = \case Basic i -> \case Basic j -> i == j
14:25:06 <dmwit> I would bet you still need to specify all the branches in an implementation of (==).
14:25:12 <koz_> jle`: Ah, I see.
14:25:21 <koz_> Let me try that actually.
14:25:34 <jle`>              Higher i is -> \case Higher j js -> i == j && is == js
14:25:43 <jle`> i think this one GHC can verify as complete
14:25:49 <jle`> because in each case you at least narrow things down
14:26:04 <jle`> hm, actually maybe it cannot even.
14:26:15 <dmwit> Yeah, my `Higher () undefined` example still stands. ^_^
14:26:22 <jle`> ah, maybe try making the fields strict
14:26:40 <dmwit> Does strictness affect the completeness checker?? wow
14:26:44 <jle`> that should trigger ghc 8.8's new absurd-in-fields tool
14:26:47 <jle`> dmwit: yeah, it does, as of 8.8
14:26:57 <koz_> jle`: Seems to help!
14:27:01 <dmwit> That's pretty nuts.
14:27:02 <jle`> and this will also rule out dmwit's clever counter-example, which my version didn't catch
14:27:12 <jle`> koz_: yeah, i think it's because before, you'd have to do:
14:27:21 <jle`> \case Basic i -> \case Higher i is -> case is of {}
14:27:28 <jle`> (assumg you also handle Basic j)
14:27:44 <jle`> and that one, at least, will be complete, since there is noIndexOf '[]
14:27:56 <jle`> but now in 8.8, if is is strict, ghc will automatically expand that part out
14:28:45 <jle`> i think the logic is if at least one of the strict fields is uninhabited, then the whole constructor will be uninhabited
14:29:12 <dmwit> koz_: But uh... given the names, are you sure you don't want something like `data IndexOf sh where Here :: q -> IndexOf (q:qs); Higher :: IndexOf qs -> IndexOf (q:qs)`?
14:29:34 <koz_> dmwit: It's a higher-order (,).
14:29:42 <phadej> koz_: watch the HaskellX 2019 by SPJ
14:29:45 <dmwit> IndexOf is a bad name for higher-order (,). =P
14:29:48 <phadej> it's exactly about your issue
14:29:55 <koz_> dmwit: I agree, the naming could be better.
14:29:56 <phadej> You need to tell GHC
14:30:00 <phadej> instance (AllEq sh) => Eq (IndexOf sh) where (Basic i) == (Basic j) = i == j (Higher i is) == Higher j js = i == j && is == js
14:30:03 <phadej> Basic _ == Higher _ x = case x of {} Higher _ x == Basic _ = case x of {}
14:30:11 <phadej> argh, insert newlines
14:30:24 <phadej> GHC-8.10 might be smarter with this
14:30:51 <koz_> jle`: Sorry, but could you show me the whole thing you're suggesting? I'm a bit lost now.
14:30:54 <dmwit> koz_: Given that you want higher-order (,), your base case sucks. =P
14:31:04 <phadej> SPJ have actually an example (he uses Void, but so is IndexOf '[] empty type)
14:31:05 <dmwit> koz_: `Basic :: IndexOf '[]` is better.
14:31:14 <koz_> dmwit: Yeah, I agree.
14:31:14 <dmwit> koz_: ...and avoids this weird issue, too.
14:34:06 <koz_> dmwit: You were absolutely right - thank you!
14:35:34 * jle` . o O ( IndexOf ~ Rec Identity )
14:36:19 <phadej> NP Identity
14:36:45 <phadej> https://hackage.haskell.org/package/sop-core-0.5.0.0/docs/Data-SOP-NP.html
14:36:47 <dmwit> Happily, I was wrong about Foo.
15:04:08 <koz_> phadej: Thanks!
15:16:47 <ibloom> Is there a function to lookup and simultaneously remove an item from a Data.Sequence by index?
15:21:51 <EvanR> if you can't find one, you can in so many words accomplish it with splitAt
15:22:58 <EvanR> maybe not
15:25:49 <ibloom> EvanR, yeah I was just looking for an efficient way to do it without rewriting the library. I basically need to pick the item out of the sequence like a marble from a bag.
15:26:12 <EvanR> yeah
15:28:28 <wildtrees> ibloom, maybe a set or an IntMap perhaps 
15:28:42 <phadej> I think the splitAt is as efficient as it gets
15:28:57 <phadej> there's no much you can do while searching for an item
15:30:13 <ibloom> phajej, but don't I need to then take the head of the second split and merge the resulting sequences.
15:30:38 <ibloom> wildtrees, I'll check those thanks.
15:31:11 <phadej> ibloom: if you just remove, then deleteAt
15:32:19 <ibloom> phadej, yes I just want deleteAt but with the deleted item. So the type would be Int -> Seq a -> (Seq a, a)
15:32:36 <ibloom> I'm trying to avoid two tree traversals for the operation.
15:34:48 <phadej> my gut feeling says that index + deleteAt would be faster than trying to fuse those
15:35:06 <phadej> deletion is quite complicated
15:35:48 <ibloom> Alright.
15:35:55 <ibloom> Thanks
15:36:00 <EvanR> lookup and then optionally deleteAt
15:36:08 <EvanR> seems like the simplest
15:36:42 <EvanR> though you could imagine with internal access being able to do both of these at once
15:37:35 <phadej> EvanR: look at the code, you wouldn't
15:37:48 <phadej> you'll spend more time debugging the code than you'll save in CPU time ever
15:37:51 <EvanR> heh
15:38:02 <EvanR> Data.Map has an operation like this though :\
15:38:59 <ibloom> Data.Map might actually be better for this. I may be able to discount the order....
15:39:27 <EvanR> well with Int keys, IntMap
15:39:50 <ibloom> Was using the order to rank gene base pairs, but I think there is a better way.
15:40:03 <ibloom> Yes IntMap as well.
15:48:34 <zeta_0> have any of you guys gotten `hasklig-mode` to work in emacs ?
16:01:13 <filipa> hello
16:01:55 <dsal> zeta_0: I just tried it.  Works on my Mac.
16:03:19 <dsal> zeta_0: https://usercontent.irccloud-cdn.com/file/4uooyMlx/hasklig
16:04:45 <filipa> ##Portugal
16:05:53 <zeta_0> dsal: cool, but it is not working for me, i am running linux with a 3k monitor, and i am running hasklig-mode with haskell-ide-engine so i am not sure what the problem is ?
16:06:15 <dsal> Probably just the font.  I tried it on Linux first and didn't get the font working.  I put very little effort into it.
16:08:30 <zeta_0> dsal: i used the example configuration, everythin is working except the symbols, they don't form correctly and then go invisible when the cursor is not focused on them, i have no idea why ? https://github.com/minad/hasklig-mode/tree/386c098c93a744f6b30ad937d193eebf0fd79e1b
16:09:52 <dsal> zeta_0: yeah, that's the font problem I had
16:10:57 <zeta_0> dsal: well, how did you fix it ?
16:11:24 <dsal> I used a different computer where I knew how to get fonts installed.  :)
16:12:42 <zeta_0> dsal: what is the problem with the font ?
16:12:55 <dsal> Do you have it installed?
16:13:43 <dsal> I just installed the font and hasklig-mode and it worked well on my mac.  I don't know how to install a font on my Linux machine.  I could figure it out, but without the font, it does exactly what you described.
16:14:43 <zeta_0> dsal: i do have `hasklig-mode` installed in linux, why can't you install it ?
16:15:00 <dsal> That's not a font.  It's just an emacs mode.
16:15:13 <dsal> It uses the hasklig font to replace digraphs with glyphs.
16:15:50 <zeta_0> dsal: oh so i need the font as well ? what is the name of the package ?
16:16:14 <dsal> I didn't find a package.  Just a zip of hasklig fonts at github.com/i-tu/Hasklig
16:17:04 <ibloom> Here's another question along the same lines as my earlier question: How do I randomly select an element from a Data.Map if I know the size of the map but not the keys. I'd like to also have logarithmic access by key.
16:22:00 <EvanR> if the size is a power of two, binary search using the splitting API
16:22:12 <EvanR> coin flipping at each step
16:23:07 <EvanR> i'm wrong, the splitting API works by key
16:24:27 <zeta_0> dsal: oh i did not know that i needed two packages (`hasklig(a linux package)` and `hasklig-mode(an emacs package)`), i'll let you know if the haskell ligature works or not after installing the other package
16:24:58 <ibloom> I see, Data.Map.Internal has an elemAt function.
16:25:07 <dsal> > let m = M.fromList [("a", 1), ("b", 2), ("c", 3)]; randomNumber = 2  in    head . drop randomNumber $ M.toList m -- ibloom here's an inefficient hack
16:25:09 <lambdabot>  ("c",3)
16:25:18 <koala_man> nice
16:26:18 <ibloom> dsal: that can't be efficient?
16:26:26 <dsal> Why not?
16:26:45 <koala_man> it's linear, not logarithmic
16:27:09 <EvanR> you'd be picking from a long list not a bag
16:27:50 <dsal> Yeah.  Depends on needs.  I don't write everything to be efficient on the first pass.  Sometimes, a long list is fine.
16:27:56 <EvanR> i like how this is "tasks Map and Sequence suck at " day
16:28:24 <koala_man> elemAt seems perfect
16:28:31 <dsal> splitRoot looks neat.
16:29:39 <dsal> I forgot about Sequence.  I used that for something a while back, I think...
16:30:37 <EvanR> in closure everything is done with their "hasharraymappedtrie"
16:31:00 <EvanR> but we don't use that for anything, for some reason
16:35:45 <dsal> splitRoot doesn't quite do what I thought it did, but it's not useless for this task.  Still, not ideal.
16:37:55 <EvanR> is there State-like thing that lets you stream state transitions
16:47:03 <eze> I run cabal new-run and get this response
16:47:29 <eze> cabal: TODO: add support for fetching and reading local tarballs, remote
16:47:30 <eze> tarballs, remote repos and passing named packages through
16:48:01 <eze> any hints to what is wrong?
16:56:07 <mniip> behold, things that should not exist:
16:56:44 * hackage th-tc 0.1.0.0 - Typechecking in Template Haskell  https://hackage.haskell.org/package/th-tc-0.1.0.0 (mniip)
17:06:07 <lyxia> o.o
17:07:38 <lyxia> nifty
17:11:09 <pikajude> ewww
17:15:06 <mniip> docs ready https://hackage.haskell.org/package/th-tc-0.1.0.0/docs/Language-Haskell-TH-Typecheck.html
17:15:44 <pikajude> this will be useful if people want to do typechecking during compilation
17:15:51 <freeman42x> lens beginner here. I used makeLenses on my data type. Which operator is for setting the value of one of its fields? https://github.com/fairy-tale-agi-solutions/haskell-editor-setup/blob/23c4fbfafc98dc4bdb3af1893f5dace4c73d6dea/src/Main.hs#L53
17:17:33 <mniip> pikajude, I want to do typechecking during compilation
17:17:40 <pikajude> yeah
17:17:45 <pikajude> hopefully that functionality gets moved into GHC at some point :D
17:17:50 <mniip> hopefully
17:19:30 <mniip> patching GHC was one of the options abut then we'd have to wait for 8.10
17:19:36 <mniip> and 8.8 isn't even fully ouy
17:20:07 <lyxia> :t (.~)
17:20:08 <lambdabot> ASetter s t a b -> b -> s -> t
17:20:16 <jackdk> freeman42x: (.~) is the operator for setting. If `l :: Lens s t a b` and `a :: a`, then `l .~ b :: s -> t`
17:20:17 <lyxia> freeman42x: ^
17:22:14 * hackage hw-uri 0.1.1.11 - Supports IO on URIs  https://hackage.haskell.org/package/hw-uri-0.1.1.11 (haskellworks)
17:55:27 <pie_> how do you thread around asynchronous exceptions and computation results? :/
17:55:53 <pie_> consider this pseudocode https://bpaste.net/show/QO6LC
17:56:16 <pie_> turtle uses asynchronous exceptions to return the nonzero exit code of a process
17:56:50 <pie_> so i want to get the result of some streaming processing, and once the process exists, also its exit code
17:57:06 <freeman42x> @karma+ jackdk thank you!
17:57:06 <lambdabot> jackdk's karma raised to 1.
17:57:24 <jackdk> @karma+lyxia fair's fair
17:57:24 <lambdabot> Unknown command, try @list
17:57:29 <jackdk> @karma+ lyxia fair's fair
17:57:29 <lambdabot> lyxia's karma raised to 19.
17:58:13 <MarcelineVQ> @karma+ jackdk carma circle
17:58:13 <lambdabot> jackdk's karma raised to 2.
18:00:40 <EvanR> pie_: are you using async anywhere?
18:00:49 <jusss> if there's data Updates defined in A.hs file, if I import that A, can I use that Updates?
18:01:04 <EvanR> or does turtle use it's own framework
18:01:05 <jusss> haskell's module system really got me angry
18:02:42 <EvanR> jusss: well technically, A.hs may not export Updates and then no you can't use it
18:02:55 <jusss> EvanR: what's the right way?
18:03:14 <EvanR> what is the actual issue?
18:03:37 <pie_> EvanR: no
18:03:38 <jusss> EvanR: https://paste.ubuntu.com/p/ZyjWDRP6fq/
18:03:52 <pie_> EvanR: rather, i dont know how to answer taht
18:04:00 <jusss> EvanR: UpdatesResponse is a data in Responses.hs
18:04:06 <EvanR> pie_: async has a pretty good story for forking threads in a way that lets you get how they died
18:04:46 <jusss> EvanR: and getUpdates return an Either _ UpdatesResponse 
18:05:24 <EvanR> jusss: the error says the module couldn't even be imported
18:05:50 <jusss> EvanR: yeah, so how I can use that type in Main.hs
18:06:04 <EvanR> figure out why it can't be imported
18:06:10 <EvanR> didn't install a package? spelled it wrong?
18:06:32 <jusss> https://hackage.haskell.org/package/telegram-api-0.2.1.0/candidate/docs/Web-Telegram-API-Bot-Responses.html#t:UpdatesResponse
18:06:58 <dmwit> import qualified Web.Telegram.API.Bot.Responses (UpdatesResponse) will import the type.
18:07:00 <EvanR> import qualified Web.Tele^
18:07:02 <jusss> https://hackage.haskell.org/package/telegram-api-0.2.1.0/candidate/docs/Web-Telegram-API-Bot-API.html#g:1
18:07:06 <dmwit> import qualified Web.Telegram.API.Bot.Responses (UpdatesResponse(..)) will import the type and all its constructors.
18:07:26 <dmwit> If you don't want to have to fully qualify... then don't include the "qualified".
18:08:40 <jusss> Not in scope: data constructor `UpdatesResponse'
18:08:53 <dmwit> Show code.
18:09:15 <dmwit> Prediction: "If you don't want to have to fully qualify..."
18:09:42 <jusss> https://paste.ubuntu.com/p/NYTF7DDB94/
18:13:22 <EvanR> you imported qualified
18:13:44 <EvanR> it means You.Have.To.Refer.To.Things.With.The.Whole.Path
18:14:09 <jusss> EvanR: I just remove that qualified , and same error
18:14:28 <EvanR> i'm skeptical
18:14:43 <dmwit> Nailed my prediction.
18:14:50 <dmwit> Also: show code. And error.
18:15:52 <jusss> https://paste.ubuntu.com/p/ggxkQph7YT/
18:15:59 <dmwit> (Also may be worth checking: are you sure you are looking at the documentation for the same version of the package that you actually have installed?)
18:17:16 <EvanR> you imported all the constructors of UpdatesResponse
18:17:31 <EvanR> now it stands to reason that UpdatesResponse isn't actually any of those constructors
18:17:40 <jusss> there's no document on his github, and yeah, the version is not matched
18:18:06 <dmwit> Okay. You may build the documentation yourself, or you may look at the source directly.
18:18:35 <EvanR> you're flying blind here?
18:18:38 <jusss> dmwit: I'm doing that
18:19:34 <jusss> EvanR: I change it to `import Web.Telegram.API.Bot.Responses (UpdatesResponse)', still same error
18:19:48 <jusss> what's wrong with the namespace
18:19:49 <EvanR> that doesn't address what i said
18:19:50 <dmwit> I have just looked at the source myself. When you said, "UpdatesResponse is a data in Responses.hs", you lied.
18:20:17 <jusss> dmwit: https://hackage.haskell.org/package/telegram-api-0.2.1.0/candidate/docs/Web-Telegram-API-Bot-Responses.html#t:UpdatesResponse
18:20:35 <dmwit> We have just established that this documentation does not correspond to the code you are actually building.
18:20:38 <dmwit> So why link to it?
18:20:42 <jusss> data UpdatesResponse = UpdatesResponse  {    update_result :: [Update]  } deriving (Show, Generic)
18:20:42 <jusss>  
18:20:58 <EvanR> the documentation was a decoy
18:21:21 <EvanR> a fake
18:21:43 <pikajude> i was working on a rust project today where when i ran `cargo doc` it would generate documentation for a type i needed but which didn't actually exist....that was annoying
18:22:10 <dmwit> EvanR: https://www.youtube.com/watch?v=7qKcJF4fOPs
18:22:21 <EvanR> hhahahaha
18:22:47 <jusss> dmwit: I have no idea where he put this in his github
18:25:21 <jusss> -- | This object represents 'getUpdates' response   type UpdatesResponse = Response [Update]
18:25:30 <jusss> https://github.com/klappvisor/haskell-telegram-api/blob/master/src/Web/Telegram/API/Bot/Responses.hs
18:27:10 <EvanR> jusss: so, the constructor name is Response not UpdatesResponse (for some reason)
18:27:31 <EvanR> actually it's not even a data type
18:27:52 <EvanR> it's a type synonym for something with ctor name Response
18:29:27 <pikajude> that's not even a constructor name, it's a type name
18:30:16 <EvanR> we've been wondering what the ctor should be for a while... after enough following the crumbs it's Response
18:31:13 <jusss> data Response a = Response  {    result     :: a  , parameters :: Maybe ResponseParameters  } deriving (Show, Generic, FromJSON)
18:37:58 <jusss> https://paste.ubuntu.com/p/4ZrhG3CrDw/
18:41:26 <EvanR> should this line be Right (Response { result = r }) -> do  ?
18:42:17 <jusss> EvanR: still same
18:44:13 <EvanR> you seem to be having a genuine type error now
18:45:40 <MarcelineVQ> should resultEither have that return
18:47:41 <EvanR> i didn't want to start debugging a fragment of a paste with an error vaguely possibly caused by that but yeah
18:47:52 <EvanR> might be an issue
18:47:55 <MarcelineVQ> well, getUpdates reults in an IO already, so..
18:48:11 <dmwit> No. And it should have another argument.
18:48:38 <dmwit> Uh. No, it should not have that return, and it should have another argument.
18:49:25 <MarcelineVQ> presumably manager
18:49:32 * dmwit nods
18:51:51 <shapr> glguy: I wish for saveValueToFile as well as loadValueFromFile
18:51:59 <shapr> er, that is.. for config-schema
18:52:02 * shapr files an issue
19:00:10 <jusss> getUpdates    :: Token    -> Maybe Int -- ^ offset    -> Maybe Int -- ^ limit    -> Maybe Int -- ^ timeout    -> Manager -> IO (Either ClientError UpdatesResponse)
19:00:17 <jusss> what the hell is Manager?
19:01:02 <shachaf> It's unknowable.
19:01:15 <rotaerk> SingletonFactoryVisitorManager
19:01:35 <EvanR> the barrier between you and administration
19:02:06 <pikajude> manager holds a connection pool doesn't it?
19:02:47 <jusss> May I should change another project for telegram?
19:15:49 <wejetheman> is there a function to test if a number is a perfect square? i found this http://hackage.haskell.org/package/arithmoi-0.10.0.0/docs/Math-NumberTheory-Powers.html but when I try to import it I get an error.
19:16:16 <dmwit> Have you installed the arithmoi package yet?
19:16:38 <dmwit> But, generally: if you don't tell us the error, you aren't going to get informed responses.
19:16:41 <wejetheman> no idea what that is but it sounds like my problem
19:17:43 <dmwit> Okay. If you are in the context of a cabal package, then you should add arithmoi to the `build-depends` list in your cabal file. If you are not, then you could try `cabal v2-install --lib arithmoi`.
19:18:29 <dmwit> If this is your first time using cabal, you may need to install it and run `cabal update` first.
19:18:45 <wejetheman> I feel like I probably shouldn't use something non built in for the assignment thou
19:19:01 <dmwit> Okay. I can't make that judgment call for you.
19:19:14 <wejetheman> i didn't realize it was going to be something that not everyone was going to be able to compile
19:20:01 <wejetheman> your response was none the less very helpful ive been searching around in circles for ages 
19:20:04 <wejetheman> thanls
19:20:10 <wejetheman> thanks
19:21:03 <dmwit> ^_^
19:23:59 <wejetheman> Is there anything in the basic libraries that will give me some more math related functions. looking here http://hackage.haskell.org/package/base nothing seems to fit that
19:24:14 <dmwit> I think basically no.
19:24:48 <dmwit> If you are aware of the rounding issues and okay with that, you could use `sqrt` as part of your implementation.
19:24:51 <dmwit> :t sqrt
19:24:53 <lambdabot> Floating a => a -> a
19:25:13 <dmwit> Otherwise I recommend implementing a simple search. If this is a class assignment, perhaps just linear search is quick enough.
19:26:50 <dmwit> There is some beautiful mathematics to learn, too, if you're into that.
19:27:28 <pikajude> how large does the number have to be before the rounding error is actually significant enough to matter?
19:27:54 <monochrom> If you don't mind going through floating point (or you're allowed to) there is sqrt and rounding.
19:28:01 <dmwit> Double can represent all integers from 0 to 2^53 exactly.
19:28:38 <monochrom> If you prefer to stay with integers, there is binary search to find the nearest integer to the square root.
19:28:58 <monochrom> Either way afterwards you square back to see whether you get the original number back.
19:29:19 <dmwit> (And even if rounding is a problem, sqrt can get you a good first approximation to run your Newton-Raphson on, provided your starting number is representable by Double at all of course.)
19:29:53 <monochrom> A really math-nerd way but dog-slow for large integers is prime factorization and then check that all exponents are even.
19:30:11 <dmwit> Oof, yeah, don't do that.
19:30:16 <monochrom> But it's the math-nerd kind of beautiful.
19:30:28 <monochrom> Goedel would approve.
19:31:10 <wejetheman> monochrom yea i feel like something like this should work "isPerfectSquare x = x == round (sqrt x)"
19:31:10 <pie_> haha
19:31:53 <dmwit> wejetheman: After a bit of fixing, that will work well for small numbers, yes.
19:33:04 <pikajude> i think that'll only work for 1, right?
19:33:14 <pikajude> don't think it works for 2
19:33:16 <pie_> how can I get this https://bpaste.net/show/GZB7U to use the MonadCatch version of catch and not IO? its implemented http://hackage.haskell.org/package/turtle-1.5.15/docs/Turtle-Shell.html#t:Shell
19:33:45 <pikajude> inproc is type IO, you need to lift it
19:33:49 <dmwit> pikajude: Needs a little bit of fixing. I'm confident wejetheman can figure out how on their own, though. ;-)
19:34:04 <wejetheman> yes im confident i can as well
19:34:44 <pikajude> also instead of wrapping the result you can use `try`
19:35:23 <pie_> pikajude: oh. im really clueless with exceptions. dont you need catch for async stuff
19:35:35 <pikajude> `try` is implemented via catch
19:35:38 <pikajude> it's like uhh
19:35:47 <pikajude> try x = Right <$> x `catch` \ e -> Left e
19:35:51 <pikajude> something along those lines
19:35:59 <pie_> um ok, ill try that direction
19:36:04 <pie_> also inproc :: Text -> [Text] -> Shell Line -> Shell Line
19:36:04 <monochrom> Too many "catch"es.
19:36:12 <pikajude> there's only the one
19:36:15 <wejetheman> isPerfectSquare x = sqrt x == fromIntegral (round (sqrt x)) seems to work
19:36:22 <pikajude> oh yeah, sorry pie_ 
19:36:24 <pikajude> i had it backwards
19:36:33 <pikajude> you have to import Control.Monad.Catch most likely
19:36:47 <pie_> pikajude: right, so i tried lifting it but it didnt work, i can try again maybe i did it wrong
19:36:59 <pie_> oh ok ill try that import, i tried importing some other stuff
19:37:08 <pie_> like..control.monad
19:37:11 <pikajude> does the second argument of catch also need to return `m a`
19:37:19 <pikajude> oh, you're doing that already
19:37:48 <pie_> aaand i need to change my .cabal to import it
19:37:59 <pikajude> indeed
19:38:10 <pie_> is there a way to save the currently set options of ghci somehow
19:38:25 <pikajude> no, but you can put the relevant commands in the file .ghci
19:38:29 <pikajude> and they'll be loaded
19:39:08 <dmwit> > let isPerfectSquare x = sqrt x == fromIntegral (round (sqrt x)) in map isPerfectSquare [x^2+1 | x <- [5, 10, 2^32]]
19:39:10 <lambdabot>  [False,False,True]
19:39:13 <pie_> well thats kind of annoying
19:39:13 <dmwit> wejetheman: ^
19:39:17 <pie_> but ok
19:39:29 <pie_> (i mean id like it if i could have semi-resumable sessions)
19:39:44 <MarcelineVQ> pie_: you can include new packages in ghci without exiting though, :set -package foo iirc
19:40:36 <MarcelineVQ> well 'not current loaded' packages, new would depend on what's putting them in scope
19:40:47 <dmwit> (I think 5, 10, 2^32 may be one of my new favorite sequences. I'm sure it's in OEIS somewhere.)
19:41:17 <MarcelineVQ> dmwit: 0, 1, uwu
19:41:21 <monochrom> Prelude doesn't have "catch".
19:42:32 <dmwit> wejetheman: (Report back when you figure out that the right way to fix these false positives is to do your squaring and equality checks in integer-land. Then I'll show you how to make false negatives. >:-D )
19:43:37 <pie_> pikajude: the .Catch import fixed it
19:43:38 <pie_> whew,,,
19:44:03 <dmwit> (Actually, hm, with `round` instead of `floor` or `ceiling` that might actually legitimately be hard without cheating and going outside of `Double` range.)
19:44:04 <wejetheman> to do squaring in integer land i would have to abandon sqrt
19:44:23 <dmwit> wejetheman: Interesting. Why?
19:44:54 <wejetheman> sqrt :: Floating a => a -> a
19:45:01 <dmwit> I'm with you so far.
19:45:08 <dmwit> What's the next step in the argument?
19:46:03 <pikajude> pie_, `:t catch` will tell you the type of catch, and `:i catch` will tell you its signature and which module it's defined in
19:47:37 <wejetheman> i guess id have to implement my own square root function but i really cant get into all that ri
19:47:45 <wejetheman> right now
19:48:15 <dmwit> wejetheman: You've said that twice now, but haven't convinced me it's true yet.
19:48:29 <monochrom> (It's false.)
19:48:55 <monochrom> Great way to start a journey of XY problems.
19:49:15 <dmwit> wejetheman: Also, some people find the style of pedagogy I'm engaging in right now very annoying. If that's you, let me know, and I'll stop.
19:49:24 <pikajude> (i do, but i'm not asking)
19:49:38 <wejetheman> yea i could make an infinate list of all multiples and check if a number was in it with a limit to stop it evaluating eternally
19:50:10 <dmwit> Why do all that when you have sqrt?
19:50:58 <maerwald> best way is to not engage in pedagogy at all 
19:51:31 <pikajude> yeah, it's generally a terrible method of teaching, but it's pretty satisfying for the pedagogeur
19:51:38 <monochrom> I hold the opposite opinion. Every communication is pedagogy.
19:51:58 <maerwald> if it's mutual and on the same level maybe
19:52:37 <pikajude> for pedagogy, consent should be established first
19:52:46 <dmwit> Hah! I love it.
19:53:06 <EvanR> what's worse pedagogy or metadiscussion
19:53:37 <maerwald> EvanR: terminology-nitpicking metadiscussion full of pedagogy?
19:53:39 <dmwit> How many levels of meta are you on? This message is on level 3.
19:54:12 <monochrom> I'm at level 1 because I use TypeInType.
19:54:29 <shachaf> dmwit: I think it's a theorem that a message can't discuss its own meta level.
19:55:02 <pikajude> sometimes it's unhelpful if the answer is actually very simple but someone doesn't happen to have figured it out yet
19:55:04 <maerwald> I'm actually interested in conducting a survey about the nature of slightly-less-tech discussions in different programming channels, because they are vastly different
19:55:06 <pikajude> by chance
19:55:16 <monochrom> Yes I did have desugared grape juice two hours ago.
19:56:19 <pie_> pikajude: ive been using :t a lot yeah, just couldnt figure out what to do about it using the wrong function
19:56:52 <maerwald> 1. #go: "I want to get this microservice done", 2. #haskell: "I want to create an abstraction for a flux compensator", 3. #python: "how do I write a for-loop?" -- not entirely serious
19:57:03 <pie_> pikajude: well this feels kind of horrible but at least im making progress https://github.com/Gabriel439/Haskell-Turtle-Library/issues/269#issuecomment-545225483
19:57:29 <pie_> maerwald: im stuck in the haskell tarpit :D
19:58:04 <pikajude> why not just use the flux compensator module in base?
19:58:22 <maerwald> it doesn't compose with my choice of effects system... hah
19:58:22 <wejetheman> i am still really curious about what you guys were getting at
19:58:32 <monochrom> pie_: In this specific case I would have noticed, in the doc, that "inproc"'s type involves "Shell", then I would click on "Shell", then I would notice that it's an instance of "MonadCatch", then I would click it to see which package, which module it came from.  And would never guess or presume anything.
19:58:38 <pikajude> oh, dmwit was trying to make you understand that you can use sqrt just fine
19:59:02 <pie_> monochrom: thanks, i got most of the way there
20:02:09 <glguy> shapr: What is the behavior you'd expect for loadValueFromFile if there was no file?
20:16:01 <pie_> can you define mutually recursive (top level) functions in ghci?
20:19:14 * hackage doclayout 0.2 - A prettyprinting library for laying out text documents.  https://hackage.haskell.org/package/doclayout-0.2 (JohnMacFarlane)
20:24:41 <MarcelineVQ> yes
20:48:17 * hackage simple-sendfile 0.2.29 - Cross platform library for the sendfile system call  https://hackage.haskell.org/package/simple-sendfile-0.2.29 (KazuYamamoto)
21:12:50 <laika___> is a type like `foral a . a -> b` valid ? if so, what is the significance of b?
21:13:05 <EvanR> that's the same as forall a b . a -> b
21:13:15 <EvanR> b is implicitly quantified
21:13:32 <shachaf> It has the same significance as it does in the type "a -> b".
21:14:01 <EvanR> k that's probably more righter
21:14:19 <laika___> so any unconstrained variable in a type signature is universally quantified?
21:14:55 <EvanR> unbound type variables
21:15:11 <EvanR> Num a => a -> a -> a  is the same situation
21:15:27 <EvanR> forall a . Num a => a -> a -> a
21:18:38 <laika___> sorry for the probably obvious questions, but what is an example of a bound type variable? 
21:18:56 <EvanR> forall is the bind here
21:19:01 <EvanR> is the binder 
21:19:10 <laika___> ahh
21:19:21 <laika___> so any type variable without its OWN forall
21:19:28 <laika___> gets an implicit universal quantification?
21:20:15 <EvanR> you will also see types like (forall a . Num a => a -> a -> X) -> X
21:20:51 <EvanR> a won't be quantified (again)
21:21:01 <laika___> this is a rank 2 type?
21:21:08 <EvanR> yeah
21:21:32 <laika___> ok, i think that clicks
21:22:28 <EvanR> no free type vars left behind
21:23:37 <pikajude> anytime you don't see a forall there's an implicit one
21:23:46 <pikajude> you can also use :set -fprint-explicit-foralls in ghci to see what they are
21:45:39 <dminuoso> 06:13:57        laika___ | so any unconstrained variable in a type signature is universally quantified?
21:45:45 <dminuoso> Ah they left.
21:52:43 <shapr> glguy: Maybe? or error?
21:53:06 <glguy> So it'd just be parse <$> readFile thefilename?
22:10:44 * hackage store-core 0.4.4.2 - Fast and lightweight binary serialization  https://hackage.haskell.org/package/store-core-0.4.4.2 (MichaelSloan)
22:11:44 * hackage store 0.6.0.1 - Fast binary serialization  https://hackage.haskell.org/package/store-0.6.0.1 (MichaelSloan)
23:06:55 <jusss> data P = P {i :: Int, ii :: String}，  this mean the value has a form like P 3 "3", right/
23:07:00 <jusss> not P {3, "3"}
23:07:32 <jusss> I'm a little confused, and it's related to record syntax?
23:08:06 <jusss> data MkWhat = MkWhat { runMkWhat :: What }
23:08:41 <jusss> runMkWhat MkWhat What = What
23:08:44 <EvanR> no P {3,"3"}. But you can say P {i=3, ii="3"}
23:09:02 <EvanR> what you just wrote is wrong
23:09:13 <jusss> EvanR: correct me
23:09:39 <EvanR> runMkWhat (MkWhat w) = w
23:10:30 <dminuoso> jusss: Record syntax just gives you syntax sugar to deal with ADTs having multiple values. :)
23:10:39 <dminuoso> At the end, its really just syntax sugar.
23:11:07 <jusss> dminuoso: but here, this data P is using record syntax? 'cause this i isn't a function, right?
23:11:15 <jusss> but runMkWhat is a function
23:11:19 <EvanR> i is a field. It's also an accessor
23:11:29 <EvanR> i (P x y) = x
23:11:44 <jusss> what's the diffrent between i and runMkWhat?
23:11:45 <dminuoso> jusss: Well it depends on what you mean by "using". Its declared as such, which just means it generates accessor functions.
23:11:48 <EvanR> nothing
23:11:51 <dminuoso> jusss: None!
23:12:16 <dminuoso> jusss: The accessor functions GHC generates could be written manually.
23:12:57 <dminuoso> jusss: `newtype Foo a = Foo { runFoo :: a }` is pretty much the same as writing `newtype Foo a = Foo a; runFoo :: Foo a -> a; runFoo (Foo a) = a`
23:15:12 <maerwald> anyone knows of a python 'click' equivalent in haskell?
23:15:14 <dminuoso> jusss: The main difference is that actual field selectors can be used in updating syntax like `foo{x=5}` or record construction syntax. :)
23:15:28 <dminuoso> jusss: But that's just a convenience trick. 
23:15:54 <jusss> dminuoso: I tried i (P 3 "3") and yeah, it's 3
23:15:57 <dminuoso> maerwald: optparse-applicative
23:16:09 <maerwald> dminuoso: that's not really a declarative thing
23:16:28 <maerwald> in 'click' I don't parse anything
23:17:01 <dminuoso> Ahh, I see. click ties into cli interaction
23:17:47 <dminuoso> maerwald: Well you still do, its just that the click library implicitly does it for you.
23:17:48 <maerwald> I would imagine something similar in haskell would make heavy use of template haskell
23:17:50 <tolt> What would you call the step that GHC does when it turns the left hand of an associated type family to the right side? Simplification? Reduction?
23:18:32 <maerwald> dminuoso: well yeah, that's the difference of declarative vs non-declarative ;)
23:18:35 <dminuoso> tolt: Id say reduction
23:18:39 <dminuoso> maerwald: Not really.
23:18:44 <dminuoso> maerwald: Thats the difference between implicit and explicit.
23:18:55 <dminuoso> declarative really means something else.
23:19:07 <EvanR> ok, ok, what does 'click' do
23:19:08 <maerwald> well, optparse-applicative definitely isn't
23:19:27 <maerwald> EvanR: https://click.palletsprojects.com/en/7.x/
23:20:16 <EvanR> maerwald: i noticed it has "callbacks for validation"
23:20:30 <EvanR> this is where "parsing" would come in
23:21:17 <EvanR> and applicative is a pretty declarative way to parse
23:21:26 <maerwald> I don't want to parse :)
23:21:48 <dminuoso> maerwald: Processing user input into data is what exactly in your mind?
23:21:51 <jusss> dminuoso: EvanR  can we call this runFoo as function?
23:22:05 <dminuoso> optparse-applicative gives you a fairly declarative way of constructing a parser
23:22:06 <jusss> 'cause there's (->) in its type
23:22:14 <dminuoso> click is just a parser at the end too
23:22:15 <EvanR> maerwald: right so, a library of premade optparse-applicative options would probably be nice to have
23:22:31 <EvanR> if the ones already there don't do what you want
23:22:32 <maerwald> dminuoso: yeah, I'm looking for a declarative framework of building multi-command cli programs without ever interacting with a parser API
23:22:53 <EvanR> optparse-applicative lets you parse, but at the opt level you put in command line options
23:23:13 <EvanR> at the top level
23:23:49 <maerwald> I'm aware I can build such stuff *myself* or just do that little exta work (isn't much for a simple cli program), but that wasn't my question
23:23:52 <EvanR> you use Monoid to modify the behvior of the options
23:24:08 <maerwald> so I guess we currently have no equivalent :/
23:24:28 <EvanR> you might not, depending on what the real difference between the two libs is
23:24:37 <EvanR> which no one here seems to know
23:25:33 <maerwald> EvanR: I don't write a main function in 'click', nor do I interact with any program argument string or any parser API. I just write cli commands as if they were functions, add a decorator with meta info and the rest is done by the library
23:25:40 <dminuoso> maerwald: Have you tried optparse-applicative?
23:25:44 <maerwald> yes
23:26:15 <EvanR> that just sounds like you get a pythonic wrapper
23:26:26 <maerwald> yeah
23:26:28 <EvanR> i doubt that's going to happen in haskell
23:27:33 <maerwald> dminuoso: optparse-applicative would, obviously, be the first choice if no such framework exists
23:27:38 <EvanR> you could return literal functions from the opt-parse applicative
23:28:04 <EvanR> unfortunately there will be no object or decorators
23:29:01 <EvanR> but the usual haskellism (hasochism?) applies, you pass whatever you need to the subprogram
23:29:14 <yeboi> May i ask you how can i make a simple function in haskell that would give me the number of unique characters in a string ? For example unique :: String -> Int    unique "aabbcc"  and the output would be 3 ?
23:29:57 <opqdonut> is this homework?-)
23:30:06 <yeboi> Indeed
23:30:34 <opqdonut> what functions do you know that might help?
23:32:26 <yeboi> Am supposed to create one, but dont really know how
23:32:50 <EvanR> using existing library functions?
23:34:07 <maerwald> yeboi: https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html you should be allowed to use the haskell Prelude I guess... and it should be easy to use some of the List functions from there to do what you want
23:34:31 <maerwald> and probably a rough understanding of how lists work in haskell
23:34:54 <maerwald> if not, then something is wrong with your homework
23:37:31 <yeboi> I know how to make a function that counts every single character in a given string but not the "unique" characters 
23:37:59 <EvanR> how did you do that function
23:38:08 <dminuoso> yeboi: If you try and split your problem into smaller subproblems, what kind of functions do you think you would need?
23:38:52 <EvanR> the assignment might expect you to walk through the string character by character keeping a set of chars already seen
23:39:03 <EvanR> if that other function did something like that
23:42:20 <yeboi> welp, i was given an answer
23:42:34 <yeboi> remove :: String -> String
23:42:38 <yeboi> but dont reallz know how it works tho
23:42:39 <yeboi> sad
23:43:05 <EvanR> haha
23:43:41 <maerwald> I think without documentation this function could do anything. Remove the string from where? front, end, middle, anywhere? once? twice?
23:43:45 <EvanR> what is remove the answer to
23:44:05 <EvanR> remove str = ""
23:44:58 <jusss> type SendMessgae = "sendMessage" :> ReqBody '[JSON] SendMessageRequest :> Post '[JSON] (Response Message)
23:45:06 <jusss> this SendMessage is still a type?
23:45:11 <EvanR> improveMyWriting bodyText = ""
23:45:43 <jusss> also what @SendMessage mean? sendMessage = client (Proxy @SendMessage)
23:45:57 <jusss> https://github.com/fizruk/telegram-bot-simple/blob/master/src/Telegram/Bot/API/Methods.hs
23:46:01 <EvanR> @SendMessage is using TypeApplication
23:46:01 <lambdabot> Unknown command, try @list
23:46:18 <EvanR> type SendMessage is a type synonym
23:46:44 <EvanR> the type is expands to is pretty advanced
23:47:05 <jusss> EvanR: aha, 
23:47:06 <EvanR> it is using type level lists and strings (symbols)
23:47:17 <jusss> it's too fancy to me
23:47:35 <EvanR> maybe for now but you will get sucked in eventually
23:47:44 <maerwald> jusss: http://www.servant.dev/posts/2018-07-12-servant-dsl-typelevel.html
23:47:46 <EvanR> soon you will be writing DOOM at the type level
23:48:23 <maerwald> EvanR: with a raytracer in mysql
23:49:09 <EvanR> if it's turing complete then it ought to be abused as such
23:49:23 <jusss> EvanR: is the DOOM related to Doomsday?
23:49:33 <EvanR> um no
23:49:58 <EvanR> it's a "really old" video game
23:50:33 <EvanR> it's my joke form of PONG at the type level
23:50:49 <EvanR> it's equally ridiculous to me at the type level as PONG
23:50:59 <jusss> hah
23:51:32 <jusss> I just want to get a telegram bot written by Haskell, so I can use it to bridge IRC to Telegram
23:51:49 <jusss> I have tried four projects, 
23:52:29 <jusss> this one code is pretty less, but there's no such good document for me
23:52:47 <jusss> no good examples, specific
23:53:11 <jusss> all the other haskell projects doing this way?
23:53:42 <EvanR> if you try to use certain libraries you may find you are now the person who knows the most about it
23:53:54 <EvanR> in other cases libraries have a lot of good docs
23:54:16 <EvanR> i think you gave up too early on some of your projects
23:54:17 <jusss> I feel like it's like the scheme, everyone implement their own stuff, and the others don't care, no good documents
23:55:07 <tdammers> that's not unique to haskell
23:55:34 <jusss> on the oppsite, python do have lots of documents and good examples for their projects, and lots people using them
23:56:43 <jusss> they even have examples to explain how to on in their documents
23:56:48 <jusss> use
23:57:13 <jusss> which I may never see on haskell's docuements :)
23:59:32 <EvanR> don't blame me: https://hackage.haskell.org/package/mikmod-0.2.0.1/docs/Sound-MikMod.html
